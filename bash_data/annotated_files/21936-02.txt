    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* code for HTML client-side image maps */
    1: 
    1: #include "nsImageMap.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsPresContext.h"
    1: #include "nsIURL.h"
    1: #include "nsIURL.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsNetUtil.h"
    1: #include "nsTextFragment.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMHTMLMapElement.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLCollection.h"
    1: #include "nsIDocument.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsGkAtoms.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIFrame.h"
    1: #include "nsFrameManager.h"
    1: #include "nsCoord.h"
    1: #include "nsIImageMap.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsIDocument.h"
    1: #include "nsContentUtils.h"
    1: 
    1: static NS_DEFINE_CID(kCStringBundleServiceCID, NS_STRINGBUNDLESERVICE_CID);
    1: 
    1: class Area {
    1: public:
    1:   Area(nsIContent* aArea);
    1:   virtual ~Area();
    1: 
    1:   virtual void ParseCoords(const nsAString& aSpec);
    1: 
    1:   virtual PRBool IsInside(nscoord x, nscoord y) const = 0;
16486:   virtual void Draw(nsIFrame* aFrame, nsIRenderingContext& aRC) = 0;
16486:   virtual void GetRect(nsIFrame* aFrame, nsRect& aRect) = 0;
    1: 
    1:   void HasFocus(PRBool aHasFocus);
    1: 
    1:   void GetHREF(nsAString& aHref) const;
    1:   void GetArea(nsIContent** aArea) const;
    1: 
    1:   nsCOMPtr<nsIContent> mArea;
    1:   nscoord* mCoords;
    1:   PRInt32 mNumCoords;
    1:   PRPackedBool mHasFocus;
    1: };
    1: 
    1: Area::Area(nsIContent* aArea)
    1:   : mArea(aArea)
    1: {
    1:   MOZ_COUNT_CTOR(Area);
    1:   mCoords = nsnull;
    1:   mNumCoords = 0;
    1:   mHasFocus = PR_FALSE;
    1: }
    1: 
    1: Area::~Area()
    1: {
    1:   MOZ_COUNT_DTOR(Area);
    1:   delete [] mCoords;
    1: }
    1: 
    1: void 
    1: Area::GetHREF(nsAString& aHref) const
    1: {
    1:   aHref.Truncate();
    1:   if (mArea) {
    1:     mArea->GetAttr(kNameSpaceID_None, nsGkAtoms::href, aHref);
    1:   }
    1: }
    1:  
    1: void 
    1: Area::GetArea(nsIContent** aArea) const
    1: {
    1:   *aArea = mArea;
    1:   NS_IF_ADDREF(*aArea);
    1: }
    1: 
    1: #include <stdlib.h>
    1: 
    1: inline PRBool
    1: is_space(char c)
    1: {
    1:   return (c == ' ' ||
    1:           c == '\f' ||
    1:           c == '\n' ||
    1:           c == '\r' ||
    1:           c == '\t' ||
    1:           c == '\v');
    1: }
    1: 
    1: static void logMessage(nsIContent*      aContent,
    1:                        const nsAString& aCoordsSpec,
    1:                        PRInt32          aFlags,
    1:                        const char* aMessageName) {
    1:   nsIURI* documentURI = nsnull;
    1:   nsIDocument* doc = aContent->GetOwnerDoc();
    1:   if (doc) {
    1:     documentURI = doc->GetDocumentURI();
    1:   }
    1:   nsContentUtils::ReportToConsole(
    1:      nsContentUtils::eLAYOUT_PROPERTIES,
    1:      aMessageName,
    1:      nsnull,  /* params */
    1:      0, /* params length */
    1:      documentURI,
    1:      PromiseFlatString(NS_LITERAL_STRING("coords=\"") +
    1:                        aCoordsSpec +
    1:                        NS_LITERAL_STRING("\"")), /* source line */
    1:      0, /* line number */
    1:      0, /* column number */
    1:      aFlags,
    1:      "ImageMap");
    1: }
    1: 
18895: void Area::ParseCoords(const nsAString& aSpec)
    1: {
18895:   char* cp = ToNewCString(aSpec);
18895:   if (cp) {
    1:     char *tptr;
    1:     char *n_str;
    1:     PRInt32 i, cnt;
    1:     PRInt32 *value_list;
    1: 
    1:     /*
    1:      * Nothing in an empty list
    1:      */
18895:     mNumCoords = 0;
18895:     mCoords = nsnull;
18895:     if (*cp == '\0')
    1:     {
18895:       return;
    1:     }
    1: 
    1:     /*
    1:      * Skip beginning whitespace, all whitespace is empty list.
    1:      */
18895:     n_str = cp;
    1:     while (is_space(*n_str))
    1:     {
    1:       n_str++;
    1:     }
    1:     if (*n_str == '\0')
    1:     {
18895:       return;
    1:     }
    1: 
    1:     /*
    1:      * Make a pass where any two numbers separated by just whitespace
    1:      * are given a comma separator.  Count entries while passing.
    1:      */
    1:     cnt = 0;
    1:     while (*n_str != '\0')
    1:     {
    1:       PRBool has_comma;
    1: 
    1:       /*
    1:        * Skip to a separator
    1:        */
    1:       tptr = n_str;
    1:       while (!is_space(*tptr) && *tptr != ',' && *tptr != '\0')
    1:       {
    1:         tptr++;
    1:       }
    1:       n_str = tptr;
    1: 
    1:       /*
    1:        * If no more entries, break out here
    1:        */
    1:       if (*n_str == '\0')
    1:       {
    1:         break;
    1:       }
    1: 
    1:       /*
    1:        * Skip to the end of the separator, noting if we have a
    1:        * comma.
    1:        */
    1:       has_comma = PR_FALSE;
    1:       while (is_space(*tptr) || *tptr == ',')
    1:       {
    1:         if (*tptr == ',')
    1:         {
    1:           if (has_comma == PR_FALSE)
    1:           {
    1:             has_comma = PR_TRUE;
    1:           }
    1:           else
    1:           {
    1:             break;
    1:           }
    1:         }
    1:         tptr++;
    1:       }
    1:       /*
    1:        * If this was trailing whitespace we skipped, we are done.
    1:        */
    1:       if ((*tptr == '\0')&&(has_comma == PR_FALSE))
    1:       {
    1:         break;
    1:       }
    1:       /*
    1:        * Else if the separator is all whitespace, and this is not the
    1:        * end of the string, add a comma to the separator.
    1:        */
    1:       else if (has_comma == PR_FALSE)
    1:       {
    1:         *n_str = ',';
    1:       }
    1: 
    1:       /*
    1:        * count the entry skipped.
    1:        */
    1:       cnt++;
    1: 
    1:       n_str = tptr;
    1:     }
    1:     /*
    1:      * count the last entry in the list.
    1:      */
    1:     cnt++;
    1:  
    1:     /*
    1:      * Allocate space for the coordinate array.
    1:      */
    1:     value_list = new nscoord[cnt];
    1:     if (!value_list)
    1:     {
18895:       return;
    1:     }
    1: 
    1:     /*
    1:      * Second pass to copy integer values into list.
    1:      */
18895:     tptr = cp;
    1:     for (i=0; i<cnt; i++)
    1:     {
    1:       char *ptr;
    1: 
    1:       ptr = strchr(tptr, ',');
    1:       if (ptr)
    1:       {
    1:         *ptr = '\0';
    1:       }
    1:       /*
    1:        * Strip whitespace in front of number because I don't
    1:        * trust atoi to do it on all platforms.
    1:        */
    1:       while (is_space(*tptr))
    1:       {
    1:         tptr++;
    1:       }
    1:       if (*tptr == '\0')
    1:       {
    1:         value_list[i] = 0;
    1:       }
    1:       else
    1:       {
    1:         value_list[i] = (nscoord) ::atoi(tptr);
    1:       }
    1:       if (ptr)
    1:       {
    1:         *ptr = ',';
    1:         tptr = ptr + 1;
    1:       }
    1:     }
    1: 
18895:     mNumCoords = cnt;
18895:     mCoords = value_list;
    1:   
    1:     NS_Free(cp);
    1:   }
    1: }
    1: 
    1: void Area::HasFocus(PRBool aHasFocus)
    1: {
    1:   mHasFocus = aHasFocus;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: class DefaultArea : public Area {
    1: public:
    1:   DefaultArea(nsIContent* aArea);
    1: 
    1:   virtual PRBool IsInside(nscoord x, nscoord y) const;
16486:   virtual void Draw(nsIFrame* aFrame, nsIRenderingContext& aRC);
16486:   virtual void GetRect(nsIFrame* aFrame, nsRect& aRect);
    1: };
    1: 
    1: DefaultArea::DefaultArea(nsIContent* aArea)
    1:   : Area(aArea)
    1: {
    1: }
    1: 
    1: PRBool DefaultArea::IsInside(nscoord x, nscoord y) const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
16486: void DefaultArea::Draw(nsIFrame* aFrame, nsIRenderingContext& aRC)
    1: {
16486:   if (mHasFocus) {
16486:     nsRect r = aFrame->GetRect();
16486:     r.MoveTo(0, 0);
16486:     nscoord x1 = r.x;
16486:     nscoord y1 = r.y;
16486:     const nscoord kOnePixel = nsPresContext::CSSPixelsToAppUnits(1);
16486:     nscoord x2 = r.XMost() - kOnePixel;
16486:     nscoord y2 = r.YMost() - kOnePixel;
16486:     // XXX aRC.DrawRect(r) result is ugly, that's why we use DrawLine.
16486:     aRC.DrawLine(x1, y1, x1, y2);
16486:     aRC.DrawLine(x1, y2, x2, y2);
16486:     aRC.DrawLine(x1, y1, x2, y1);
16486:     aRC.DrawLine(x2, y1, x2, y2);
16486:   }
    1: }
    1: 
16486: void DefaultArea::GetRect(nsIFrame* aFrame, nsRect& aRect)
    1: {
16486:   aRect = aFrame->GetRect();
16486:   aRect.MoveTo(0, 0);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: class RectArea : public Area {
    1: public:
    1:   RectArea(nsIContent* aArea);
    1: 
    1:   virtual void ParseCoords(const nsAString& aSpec);
    1:   virtual PRBool IsInside(nscoord x, nscoord y) const;
16486:   virtual void Draw(nsIFrame* aFrame, nsIRenderingContext& aRC);
16486:   virtual void GetRect(nsIFrame* aFrame, nsRect& aRect);
    1: };
    1: 
    1: RectArea::RectArea(nsIContent* aArea)
    1:   : Area(aArea)
    1: {
    1: }
    1: 
    1: void RectArea::ParseCoords(const nsAString& aSpec)
    1: {
    1:   Area::ParseCoords(aSpec);
    1: 
    1:   PRBool saneRect = PR_TRUE;
    1:   PRInt32 flag = nsIScriptError::warningFlag;
    1:   if (mNumCoords >= 4) {
    1:     if (mCoords[0] > mCoords[2]) {
    1:       // x-coords in reversed order
    1:       nscoord x = mCoords[2];
    1:       mCoords[2] = mCoords[0];
    1:       mCoords[0] = x;
    1:       saneRect = PR_FALSE;
    1:     }
    1:   
    1:     if (mCoords[1] > mCoords[3]) {
    1:       // y-coords in reversed order
    1:       nscoord y = mCoords[3];
    1:       mCoords[3] = mCoords[1];
    1:       mCoords[1] = y;
    1:       saneRect = PR_FALSE;
    1:     }
    1: 
    1:     if (mNumCoords > 4) {
    1:       // Someone missed the concept of a rect here
    1:       saneRect = PR_FALSE;
    1:     }
    1:   } else {
    1:     saneRect = PR_FALSE;
    1:     flag = nsIScriptError::errorFlag;
    1:   }
    1: 
    1:   if (!saneRect) {
    1:     logMessage(mArea, aSpec, flag, "ImageMapRectBoundsError");
    1:   }
    1: }
    1: 
    1: PRBool RectArea::IsInside(nscoord x, nscoord y) const
    1: {
    1:   if (mNumCoords >= 4) {       // Note: > is for nav compatability
    1:     nscoord x1 = mCoords[0];
    1:     nscoord y1 = mCoords[1];
    1:     nscoord x2 = mCoords[2];
    1:     nscoord y2 = mCoords[3];
    1:     NS_ASSERTION(x1 <= x2 && y1 <= y2,
    1:                  "Someone screwed up RectArea::ParseCoords");
    1:     if ((x >= x1) && (x <= x2) && (y >= y1) && (y <= y2)) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
16486: void RectArea::Draw(nsIFrame* aFrame, nsIRenderingContext& aRC)
    1: {
    1:   if (mHasFocus) {
    1:     if (mNumCoords >= 4) {
    1:       nscoord x1 = nsPresContext::CSSPixelsToAppUnits(mCoords[0]);
    1:       nscoord y1 = nsPresContext::CSSPixelsToAppUnits(mCoords[1]);
    1:       nscoord x2 = nsPresContext::CSSPixelsToAppUnits(mCoords[2]);
    1:       nscoord y2 = nsPresContext::CSSPixelsToAppUnits(mCoords[3]);
    1:       NS_ASSERTION(x1 <= x2 && y1 <= y2,
    1:                    "Someone screwed up RectArea::ParseCoords");
    1:       aRC.DrawLine(x1, y1, x1, y2);
    1:       aRC.DrawLine(x1, y2, x2, y2);
    1:       aRC.DrawLine(x1, y1, x2, y1);
    1:       aRC.DrawLine(x2, y1, x2, y2);
    1:     }
    1:   }
    1: }
    1: 
16486: void RectArea::GetRect(nsIFrame* aFrame, nsRect& aRect)
    1: {
    1:   if (mNumCoords >= 4) {
    1:     nscoord x1 = nsPresContext::CSSPixelsToAppUnits(mCoords[0]);
    1:     nscoord y1 = nsPresContext::CSSPixelsToAppUnits(mCoords[1]);
    1:     nscoord x2 = nsPresContext::CSSPixelsToAppUnits(mCoords[2]);
    1:     nscoord y2 = nsPresContext::CSSPixelsToAppUnits(mCoords[3]);
    1:     NS_ASSERTION(x1 <= x2 && y1 <= y2,
    1:                  "Someone screwed up RectArea::ParseCoords");
    1: 
    1:     aRect.SetRect(x1, y1, x2, y2);
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: class PolyArea : public Area {
    1: public:
    1:   PolyArea(nsIContent* aArea);
    1: 
    1:   virtual void ParseCoords(const nsAString& aSpec);
    1:   virtual PRBool IsInside(nscoord x, nscoord y) const;
16486:   virtual void Draw(nsIFrame* aFrame, nsIRenderingContext& aRC);
16486:   virtual void GetRect(nsIFrame* aFrame, nsRect& aRect);
    1: };
    1: 
    1: PolyArea::PolyArea(nsIContent* aArea)
    1:   : Area(aArea)
    1: {
    1: }
    1: 
    1: void PolyArea::ParseCoords(const nsAString& aSpec)
    1: {
    1:   Area::ParseCoords(aSpec);
    1: 
    1:   if (mNumCoords >= 2) {
    1:     if (mNumCoords & 1U) {
    1:       logMessage(mArea,
    1:                  aSpec,
    1:                  nsIScriptError::warningFlag,
    1:                  "ImageMapPolyOddNumberOfCoords");
    1:     }
    1:   } else {
    1:     logMessage(mArea,
    1:                aSpec,
    1:                nsIScriptError::errorFlag,
    1:                "ImageMapPolyWrongNumberOfCoords");
    1:   }
    1: }
    1: 
    1: PRBool PolyArea::IsInside(nscoord x, nscoord y) const
    1: {
    1:   if (mNumCoords >= 6) {
    1:     PRInt32 intersects = 0;
    1:     nscoord wherex = x;
    1:     nscoord wherey = y;
    1:     PRInt32 totalv = mNumCoords / 2;
    1:     PRInt32 totalc = totalv * 2;
    1:     nscoord xval = mCoords[totalc - 2];
    1:     nscoord yval = mCoords[totalc - 1];
    1:     PRInt32 end = totalc;
    1:     PRInt32 pointer = 1;
    1: 
    1:     if ((yval >= wherey) != (mCoords[pointer] >= wherey))
    1:       if ((xval >= wherex) == (mCoords[0] >= wherex))
    1:         intersects += (xval >= wherex) ? 1 : 0;
    1:       else
    1:         intersects += ((xval - (yval - wherey) *
    1:                         (mCoords[0] - xval) /
    1:                         (mCoords[pointer] - yval)) >= wherex) ? 1 : 0;
    1: 
    1:     // XXX I wonder what this is doing; this is a translation of ptinpoly.c
    1:     while (pointer < end)  {
    1:       yval = mCoords[pointer];
    1:       pointer += 2;
    1:       if (yval >= wherey)  {
    1:         while((pointer < end) && (mCoords[pointer] >= wherey))
    1:           pointer+=2;
    1:         if (pointer >= end)
    1:           break;
    1:         if ((mCoords[pointer-3] >= wherex) ==
    1:             (mCoords[pointer-1] >= wherex)) {
    1:           intersects += (mCoords[pointer-3] >= wherex) ? 1 : 0;
    1:         } else {
    1:           intersects +=
    1:             ((mCoords[pointer-3] - (mCoords[pointer-2] - wherey) *
    1:               (mCoords[pointer-1] - mCoords[pointer-3]) /
    1:               (mCoords[pointer] - mCoords[pointer - 2])) >= wherex) ? 1:0;
    1:         }
    1:       }  else  {
    1:         while((pointer < end) && (mCoords[pointer] < wherey))
    1:           pointer+=2;
    1:         if (pointer >= end)
    1:           break;
    1:         if ((mCoords[pointer-3] >= wherex) ==
    1:             (mCoords[pointer-1] >= wherex)) {
    1:           intersects += (mCoords[pointer-3] >= wherex) ? 1:0;
    1:         } else {
    1:           intersects +=
    1:             ((mCoords[pointer-3] - (mCoords[pointer-2] - wherey) *
    1:               (mCoords[pointer-1] - mCoords[pointer-3]) /
    1:               (mCoords[pointer] - mCoords[pointer - 2])) >= wherex) ? 1:0;
    1:         }
    1:       }
    1:     }
    1:     if ((intersects & 1) != 0) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
16486: void PolyArea::Draw(nsIFrame* aFrame, nsIRenderingContext& aRC)
    1: {
    1:   if (mHasFocus) {
    1:     if (mNumCoords >= 6) {
    1:       nscoord x0 = nsPresContext::CSSPixelsToAppUnits(mCoords[0]);
    1:       nscoord y0 = nsPresContext::CSSPixelsToAppUnits(mCoords[1]);
    1:       nscoord x1, y1;
    1:       for (PRInt32 i = 2; i < mNumCoords; i += 2) {
    1:         x1 = nsPresContext::CSSPixelsToAppUnits(mCoords[i]);
    1:         y1 = nsPresContext::CSSPixelsToAppUnits(mCoords[i+1]);
    1:         aRC.DrawLine(x0, y0, x1, y1);
    1:         x0 = x1;
    1:         y0 = y1;
    1:       }
    1:       x1 = nsPresContext::CSSPixelsToAppUnits(mCoords[0]);
    1:       y1 = nsPresContext::CSSPixelsToAppUnits(mCoords[1]);
    1:       aRC.DrawLine(x0, y0, x1, y1);
    1:     }
    1:   }
    1: }
    1: 
16486: void PolyArea::GetRect(nsIFrame* aFrame, nsRect& aRect)
    1: {
    1:   if (mNumCoords >= 6) {
    1:     nscoord x1, x2, y1, y2, xtmp, ytmp;
    1:     x1 = x2 = nsPresContext::CSSPixelsToAppUnits(mCoords[0]);
    1:     y1 = y2 = nsPresContext::CSSPixelsToAppUnits(mCoords[1]);
    1:     for (PRInt32 i = 2; i < mNumCoords; i += 2) {
    1:       xtmp = nsPresContext::CSSPixelsToAppUnits(mCoords[i]);
    1:       ytmp = nsPresContext::CSSPixelsToAppUnits(mCoords[i+1]);
    1:       x1 = x1 < xtmp ? x1 : xtmp;
    1:       y1 = y1 < ytmp ? y1 : ytmp;
    1:       x2 = x2 > xtmp ? x2 : xtmp;
    1:       y2 = y2 > ytmp ? y2 : ytmp;
    1:     }
    1: 
    1:     aRect.SetRect(x1, y1, x2, y2);
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: class CircleArea : public Area {
    1: public:
    1:   CircleArea(nsIContent* aArea);
    1: 
    1:   virtual void ParseCoords(const nsAString& aSpec);
    1:   virtual PRBool IsInside(nscoord x, nscoord y) const;
16486:   virtual void Draw(nsIFrame* aFrame, nsIRenderingContext& aRC);
16486:   virtual void GetRect(nsIFrame* aFrame, nsRect& aRect);
    1: };
    1: 
    1: CircleArea::CircleArea(nsIContent* aArea)
    1:   : Area(aArea)
    1: {
    1: }
    1: 
    1: void CircleArea::ParseCoords(const nsAString& aSpec)
    1: {
    1:   Area::ParseCoords(aSpec);
    1: 
    1:   PRBool wrongNumberOfCoords = PR_FALSE;
    1:   PRInt32 flag = nsIScriptError::warningFlag;
    1:   if (mNumCoords >= 3) {
    1:     if (mCoords[2] < 0) {
    1:       logMessage(mArea,
    1:                  aSpec,
    1:                  nsIScriptError::errorFlag,
    1:                  "ImageMapCircleNegativeRadius");
    1:     }
    1:   
    1:     if (mNumCoords > 3) {
    1:       wrongNumberOfCoords = PR_TRUE;
    1:     }
    1:   } else {
    1:     wrongNumberOfCoords = PR_TRUE;
    1:     flag = nsIScriptError::errorFlag;
    1:   }
    1: 
    1:   if (wrongNumberOfCoords) {
    1:     logMessage(mArea,
    1:                aSpec,
    1:                flag,
    1:                "ImageMapCircleWrongNumberOfCoords");
    1:   }
    1: }
    1: 
    1: PRBool CircleArea::IsInside(nscoord x, nscoord y) const
    1: {
    1:   // Note: > is for nav compatability
    1:   if (mNumCoords >= 3) {
    1:     nscoord x1 = mCoords[0];
    1:     nscoord y1 = mCoords[1];
    1:     nscoord radius = mCoords[2];
    1:     if (radius < 0) {
    1:       return PR_FALSE;
    1:     }
    1:     nscoord dx = x1 - x;
    1:     nscoord dy = y1 - y;
    1:     nscoord dist = (dx * dx) + (dy * dy);
    1:     if (dist <= (radius * radius)) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
16486: void CircleArea::Draw(nsIFrame* aFrame, nsIRenderingContext& aRC)
    1: {
    1:   if (mHasFocus) {
    1:     if (mNumCoords >= 3) {
    1:       nscoord x1 = nsPresContext::CSSPixelsToAppUnits(mCoords[0]);
    1:       nscoord y1 = nsPresContext::CSSPixelsToAppUnits(mCoords[1]);
    1:       nscoord radius = nsPresContext::CSSPixelsToAppUnits(mCoords[2]);
    1:       if (radius < 0) {
    1:         return;
    1:       }
    1:       nscoord x = x1 - radius;
    1:       nscoord y = y1 - radius;
    1:       nscoord w = 2 * radius;
    1:       aRC.DrawEllipse(x, y, w, w);
    1:     }
    1:   }
    1: }
    1: 
16486: void CircleArea::GetRect(nsIFrame* aFrame, nsRect& aRect)
    1: {
    1:   if (mNumCoords >= 3) {
    1:     nscoord x1 = nsPresContext::CSSPixelsToAppUnits(mCoords[0]);
    1:     nscoord y1 = nsPresContext::CSSPixelsToAppUnits(mCoords[1]);
    1:     nscoord radius = nsPresContext::CSSPixelsToAppUnits(mCoords[2]);
    1:     if (radius < 0) {
    1:       return;
    1:     }
    1: 
    1:     aRect.SetRect(x1 - radius, y1 - radius, x1 + radius, y1 + radius);
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: 
    1: nsImageMap::nsImageMap() :
    1:   mPresShell(nsnull),
    1:   mImageFrame(nsnull),
    1:   mContainsBlockContents(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsImageMap::~nsImageMap()
    1: {
    1:   NS_ASSERTION(mAreas.Count() == 0, "Destroy was not called");
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS4(nsImageMap,
    1:                    nsIMutationObserver,
    1:                    nsIDOMFocusListener,
    1:                    nsIDOMEventListener,
    1:                    nsIImageMap)
    1: 
    1: NS_IMETHODIMP
    1: nsImageMap::GetBoundsForAreaContent(nsIContent *aContent, 
    1:                                    nsPresContext* aPresContext, 
    1:                                    nsRect& aBounds)
    1: {
16486:   NS_ENSURE_TRUE(aContent && aPresContext, NS_ERROR_INVALID_ARG);
16486: 
    1:   // Find the Area struct associated with this content node, and return bounds
    1:   PRInt32 i, n = mAreas.Count();
    1:   for (i = 0; i < n; i++) {
    1:     Area* area = (Area*) mAreas.ElementAt(i);
    1:     if (area->mArea == aContent) {
16486:       aBounds = nsRect();
16486:       nsIPresShell* shell = aPresContext->PresShell();
16486:       if (shell) {
16486:         nsIFrame* frame = shell->GetPrimaryFrameFor(aContent);
16486:         if (frame) {
16486:           area->GetRect(frame, aBounds);
16486:         }
16486:       }
    1:       return NS_OK;
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: void
    1: nsImageMap::FreeAreas()
    1: {
    1:   nsFrameManager *frameManager = mPresShell->FrameManager();
    1: 
    1:   PRInt32 i, n = mAreas.Count();
    1:   for (i = 0; i < n; i++) {
    1:     Area* area = (Area*) mAreas.ElementAt(i);
    1:     frameManager->RemoveAsPrimaryFrame(area->mArea, mImageFrame);
    1: 
    1:     nsCOMPtr<nsIContent> areaContent;
    1:     area->GetArea(getter_AddRefs(areaContent));
    1:     if (areaContent) {
 1418:       areaContent->RemoveEventListenerByIID(this, NS_GET_IID(nsIDOMFocusListener));
    1:     }
    1:     delete area;
    1:   }
    1:   mAreas.Clear();
    1: }
    1: 
    1: nsresult
    1: nsImageMap::Init(nsIPresShell* aPresShell, nsIFrame* aImageFrame, nsIDOMHTMLMapElement* aMap)
    1: {
    1:   NS_PRECONDITION(nsnull != aMap, "null ptr");
    1:   if (nsnull == aMap) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   mPresShell = aPresShell;
    1:   mImageFrame = aImageFrame;
    1: 
    1:   mMap = do_QueryInterface(aMap);
    1:   NS_ASSERTION(mMap, "aMap is not an nsIContent!");
    1:   mMap->AddMutationObserver(this);
    1: 
    1:   // "Compile" the areas in the map into faster access versions
    1:   return UpdateAreas();
    1: }
    1: 
    1: 
    1: nsresult
    1: nsImageMap::SearchForAreas(nsIContent* aParent, PRBool& aFoundArea,
    1:                            PRBool& aFoundAnchor)
    1: {
    1:   nsresult rv = NS_OK;
    1:   PRUint32 i, n = aParent->GetChildCount();
    1: 
    1:   // Look for <area> or <a> elements. We'll use whichever type we find first.
    1:   for (i = 0; i < n; i++) {
    1:     nsIContent *child = aParent->GetChildAt(i);
    1: 
    1:     if (child->IsNodeOfType(nsINode::eHTML)) {
    1:       // If we haven't determined that the map element contains an
    1:       // <a> element yet, then look for <area>.
    1:       if (!aFoundAnchor && child->Tag() == nsGkAtoms::area) {
    1:         aFoundArea = PR_TRUE;
    1:         rv = AddArea(child);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:         
    1:         // Continue to next child. This stops mContainsBlockContents from
    1:         // getting set. It also makes us ignore children of <area>s which
    1:         // is consistent with how we react to dynamic insertion of such
    1:         // children.
    1:         continue;
    1:       }
    1:       // If we haven't determined that the map element contains an
    1:       // <area> element yet, then look for <a>.
    1:       if (!aFoundArea && child->Tag() == nsGkAtoms::a) {
    1:         aFoundAnchor = PR_TRUE;
    1:         rv = AddArea(child);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1:     }
    1:     
    1:     if (child->IsNodeOfType(nsINode::eELEMENT)) {
    1:       mContainsBlockContents = PR_TRUE;
    1:       rv = SearchForAreas(child, aFoundArea, aFoundAnchor);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageMap::UpdateAreas()
    1: {
    1:   // Get rid of old area data
    1:   FreeAreas();
    1: 
    1:   PRBool foundArea = PR_FALSE;
    1:   PRBool foundAnchor = PR_FALSE;
    1:   mContainsBlockContents = PR_FALSE;
    1: 
    1:   return SearchForAreas(mMap, foundArea, foundAnchor);
    1: }
    1: 
    1: nsresult
    1: nsImageMap::AddArea(nsIContent* aArea)
    1: {
    1:   nsAutoString coords;
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::_empty, &nsGkAtoms::rect, &nsGkAtoms::rectangle,
    1:      &nsGkAtoms::poly, &nsGkAtoms::polygon, &nsGkAtoms::circle,
    1:      &nsGkAtoms::circ, &nsGkAtoms::_default, nsnull};
    1: 
    1:   aArea->GetAttr(kNameSpaceID_None, nsGkAtoms::coords, coords);
    1: 
    1:   Area* area;
    1:   switch (aArea->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::shape,
    1:                                  strings, eIgnoreCase)) {
    1:     case nsIContent::ATTR_MISSING:
    1:     case 0:
    1:     case 1:
    1:     case 2:
    1:       area = new RectArea(aArea);
    1:       break;
    1:     case 3:
    1:     case 4:
    1:       area = new PolyArea(aArea);
    1:       break;
    1:     case 5:
    1:     case 6:
    1:       area = new CircleArea(aArea);
    1:       break;
    1:     case 7:
    1:       area = new DefaultArea(aArea);
    1:       break;
    1:     default:
    1:       // Unknown area type; bail
    1:       return NS_OK;
    1:   }
    1:   if (!area)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   //Add focus listener to track area focus changes
 1418:   aArea->AddEventListenerByIID(this, NS_GET_IID(nsIDOMFocusListener));
    1: 
21936:   // This is a nasty hack.  It needs to go away: see bug 135040.  Once this is
21936:   // removed, the code added to nsCSSFrameConstructor::RestyleElement,
21936:   // nsCSSFrameConstructor::ContentRemoved (both hacks there), and
21936:   // nsCSSFrameConstructor::ProcessRestyledFrames to work around this issue can
21936:   // be removed.
    1:   mPresShell->FrameManager()->SetPrimaryFrameFor(aArea, mImageFrame);
    1:   aArea->SetMayHaveFrame(PR_TRUE);
    1:   NS_ASSERTION(aArea->MayHaveFrame(), "SetMayHaveFrame failed?");
    1: 
    1:   area->ParseCoords(coords);
    1:   mAreas.AppendElement(area);
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsImageMap::IsInside(nscoord aX, nscoord aY,
    1:                      nsIContent** aContent) const
    1: {
    1:   NS_ASSERTION(mMap, "Not initialized");
    1:   PRInt32 i, n = mAreas.Count();
    1:   for (i = 0; i < n; i++) {
    1:     Area* area = (Area*) mAreas.ElementAt(i);
    1:     if (area->IsInside(aX, aY)) {
    1:       area->GetArea(aContent);
    1: 
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
16486: nsImageMap::Draw(nsIFrame* aFrame, nsIRenderingContext& aRC)
    1: {
    1:   PRInt32 i, n = mAreas.Count();
    1:   for (i = 0; i < n; i++) {
    1:     Area* area = (Area*) mAreas.ElementAt(i);
16486:     area->Draw(aFrame, aRC);
    1:   }
    1: }
    1: 
    1: void
    1: nsImageMap::MaybeUpdateAreas(nsIContent *aContent)
    1: {
    1:   if (aContent == mMap || mContainsBlockContents) {
    1:     UpdateAreas();
    1:   }
    1: }
    1: 
    1: void
    1: nsImageMap::AttributeChanged(nsIDocument* aDocument,
    1:                              nsIContent*  aContent,
    1:                              PRInt32      aNameSpaceID,
    1:                              nsIAtom*     aAttribute,
 3410:                              PRInt32      aModType,
 3410:                              PRUint32     aStateMask)
    1: {
    1:   // If the parent of the changing content node is our map then update
    1:   // the map.  But only do this if the node is an HTML <area> or <a>
    1:   // and the attribute that's changing is "shape" or "coords" -- those
    1:   // are the only cases we care about.
    1:   if ((aContent->NodeInfo()->Equals(nsGkAtoms::area) ||
    1:        aContent->NodeInfo()->Equals(nsGkAtoms::a)) &&
    1:       aContent->IsNodeOfType(nsINode::eHTML) &&
    1:       aNameSpaceID == kNameSpaceID_None &&
    1:       (aAttribute == nsGkAtoms::shape ||
    1:        aAttribute == nsGkAtoms::coords)) {
    1:     MaybeUpdateAreas(aContent->GetParent());
    1:   }
    1: }
    1: 
    1: void
    1: nsImageMap::ContentAppended(nsIDocument *aDocument,
    1:                             nsIContent* aContainer,
    1:                             PRInt32     aNewIndexInContainer)
    1: {
    1:   MaybeUpdateAreas(aContainer);
    1: }
    1: 
    1: void
    1: nsImageMap::ContentInserted(nsIDocument *aDocument,
    1:                             nsIContent* aContainer,
    1:                             nsIContent* aChild,
    1:                             PRInt32 aIndexInContainer)
    1: {
    1:   MaybeUpdateAreas(aContainer);
    1: }
    1: 
    1: void
    1: nsImageMap::ContentRemoved(nsIDocument *aDocument,
    1:                            nsIContent* aContainer,
    1:                            nsIContent* aChild,
    1:                            PRInt32 aIndexInContainer)
    1: {
    1:   MaybeUpdateAreas(aContainer);
    1: }
    1: 
    1: nsresult
    1: nsImageMap::Focus(nsIDOMEvent* aEvent)
    1: {
    1:   return ChangeFocus(aEvent, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsImageMap::Blur(nsIDOMEvent* aEvent)
    1: {
    1:   return ChangeFocus(aEvent, PR_FALSE);
    1: }
    1: 
    1: nsresult
16353: nsImageMap::ChangeFocus(nsIDOMEvent* aEvent, PRBool aFocus)
16353: {
    1:   //Set which one of our areas changed focus
    1:   nsCOMPtr<nsIDOMEventTarget> target;
    1:   if (NS_SUCCEEDED(aEvent->GetTarget(getter_AddRefs(target))) && target) {
    1:     nsCOMPtr<nsIContent> targetContent(do_QueryInterface(target));
    1:     if (targetContent) {
    1:       PRInt32 i, n = mAreas.Count();
    1:       for (i = 0; i < n; i++) {
    1:         Area* area = (Area*) mAreas.ElementAt(i);
    1:         nsCOMPtr<nsIContent> areaContent;
    1:         area->GetArea(getter_AddRefs(areaContent));
    1:         if (areaContent.get() == targetContent.get()) {
    1:           //Set or Remove internal focus
    1:           area->HasFocus(aFocus);
    1:           //Now invalidate the rect
    1:           nsCOMPtr<nsIDocument> doc = targetContent->GetDocument();
    1:           //This check is necessary to see if we're still attached to the doc
    1:           if (doc) {
  981:             nsIPresShell *presShell = doc->GetPrimaryShell();
    1:             if (presShell) {
    1:               nsIFrame* imgFrame = presShell->GetPrimaryFrameFor(targetContent);
    1:               if (imgFrame) {
    1:                 nsRect dmgRect;
16486:                 area->GetRect(imgFrame, dmgRect);
19380:                 imgFrame->Invalidate(dmgRect);
    1:               }
    1:             }
    1:           }
16353:           break;
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageMap::HandleEvent(nsIDOMEvent* aEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsImageMap::Destroy(void)
    1: {
    1:   FreeAreas();
    1:   mMap->RemoveMutationObserver(this);
    1: }
