32367: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
32367: /* ***** BEGIN LICENSE BLOCK *****
32367:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32367:  *
32367:  * The contents of this file are subject to the Mozilla Public License Version
32367:  * 1.1 (the "License"); you may not use this file except in compliance with
32367:  * the License. You may obtain a copy of the License at
32367:  * http://www.mozilla.org/MPL/
32367:  *
32367:  * Software distributed under the License is distributed on an "AS IS" basis,
32367:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32367:  * for the specific language governing rights and limitations under the
32367:  * License.
32367:  *
32367:  * The Original Code is nsStyleAnimation.
32367:  *
32367:  * The Initial Developer of the Original Code is
32367:  * The Mozilla Corporation.
32367:  * Portions created by the Initial Developer are Copyright (C) 2009
32367:  * the Initial Developer. All Rights Reserved.
32367:  *
32367:  * Contributor(s):
32367:  *   Daniel Holbert <dholbert@mozilla.com>, Mozilla Corporation
32396:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
32367:  *
32367:  * Alternatively, the contents of this file may be used under the terms of
32367:  * either the GNU General Public License Version 2 or later (the "GPL"), or
32367:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32367:  * in which case the provisions of the GPL or the LGPL are applicable instead
32367:  * of those above. If you wish to allow use of your version of this file only
32367:  * under the terms of either the GPL or the LGPL, and not to allow others to
32367:  * use your version of this file under the terms of the MPL, indicate your
32367:  * decision by deleting the provisions above and replace them with the notice
32367:  * and other provisions required by the GPL or the LGPL. If you do not delete
32367:  * the provisions above, a recipient may use your version of this file under
32367:  * the terms of any one of the MPL, the GPL or the LGPL.
32367:  *
32367:  * ***** END LICENSE BLOCK ***** */
32367: 
32367: /* Utilities for animation of computed style values */
32367: 
32367: #include "nsStyleAnimation.h"
32367: #include "nsCOMArray.h"
32367: #include "nsIStyleRule.h"
63693: #include "mozilla/css/StyleRule.h"
32367: #include "nsString.h"
32367: #include "nsStyleContext.h"
32367: #include "nsStyleSet.h"
32367: #include "nsComputedDOMStyle.h"
38849: #include "nsCSSParser.h"
47937: #include "mozilla/css/Declaration.h"
64095: #include "mozilla/dom/Element.h"
32396: #include "prlog.h"
32399: #include <math.h>
74281: #include "gfxMatrix.h"
32367: 
47936: namespace css = mozilla::css;
64095: namespace dom = mozilla::dom;
47936: 
32367: // HELPER METHODS
32367: // --------------
32367: /*
32367:  * Given two units, this method returns a common unit that they can both be
32367:  * converted into, if possible.  This is intended to facilitate
32367:  * interpolation, distance-computation, and addition between "similar" units.
32367:  *
32367:  * The ordering of the arguments should not affect the output of this method.
32367:  *
34029:  * If there's no sensible common unit, this method returns eUnit_Null.
32367:  *
32367:  * @param   aFirstUnit One unit to resolve.
32367:  * @param   aFirstUnit The other unit to resolve.
32367:  * @return  A "common" unit that both source units can be converted into, or
34029:  *          eUnit_Null if that's not possible.
32367:  */
32367: static
34029: nsStyleAnimation::Unit
53924: GetCommonUnit(nsCSSProperty aProperty,
53924:               nsStyleAnimation::Unit aFirstUnit,
34029:               nsStyleAnimation::Unit aSecondUnit)
32367: {
32367:   if (aFirstUnit != aSecondUnit) {
53924:     if (nsCSSProps::PropHasFlags(aProperty, CSS_PROPERTY_STORES_CALC) &&
53924:         (aFirstUnit == nsStyleAnimation::eUnit_Coord ||
53924:          aFirstUnit == nsStyleAnimation::eUnit_Percent ||
53924:          aFirstUnit == nsStyleAnimation::eUnit_Calc) &&
53924:         (aSecondUnit == nsStyleAnimation::eUnit_Coord ||
53924:          aSecondUnit == nsStyleAnimation::eUnit_Percent ||
53924:          aSecondUnit == nsStyleAnimation::eUnit_Calc)) {
53924:       // We can use calc() as the common unit.
53924:       return nsStyleAnimation::eUnit_Calc;
53924:     }
34029:     return nsStyleAnimation::eUnit_Null;
32367:   }
32367:   return aFirstUnit;
32367: }
32367: 
53925: static
53925: nsCSSUnit
53925: GetCommonUnit(nsCSSProperty aProperty,
53925:               nsCSSUnit aFirstUnit,
53925:               nsCSSUnit aSecondUnit)
53925: {
53925:   if (aFirstUnit != aSecondUnit) {
53925:     if (nsCSSProps::PropHasFlags(aProperty, CSS_PROPERTY_STORES_CALC) &&
53925:         (aFirstUnit == eCSSUnit_Pixel ||
53925:          aFirstUnit == eCSSUnit_Percent ||
53925:          aFirstUnit == eCSSUnit_Calc) &&
53925:         (aSecondUnit == eCSSUnit_Pixel ||
53925:          aSecondUnit == eCSSUnit_Percent ||
53925:          aSecondUnit == eCSSUnit_Calc)) {
53925:       // We can use calc() as the common unit.
53925:       return eCSSUnit_Calc;
53925:     }
53925:     return eCSSUnit_Null;
53925:   }
53925:   return aFirstUnit;
53925: }
53925: 
53925: 
34064: // Greatest Common Divisor
34064: static PRUint32
34064: gcd(PRUint32 a, PRUint32 b)
34064: {
34064:   // Euclid's algorithm; O(N) in the worst case.  (There are better
34064:   // ways, but we don't need them for stroke-dasharray animation.)
34064:   NS_ABORT_IF_FALSE(a > 0 && b > 0, "positive numbers expected");
34064: 
34064:   while (a != b) {
34064:     if (a > b) {
34064:       a = a - b;
34064:     } else {
34064:       b = b - a;
34064:     }
34064:   }
34064: 
34064:   return a;
34064: }
34064: 
34064: // Least Common Multiple
34064: static PRUint32
34064: lcm(PRUint32 a, PRUint32 b)
34064: {
34064:   // Divide first to reduce overflow risk.
34064:   return (a / gcd(a, b)) * b;
34064: }
34064: 
53922: inline void
53922: nscoordToCSSValue(nscoord aCoord, nsCSSValue& aCSSValue)
53922: {
53922:   aCSSValue.SetFloatValue(nsPresContext::AppUnitsToFloatCSSPixels(aCoord),
53922:                           eCSSUnit_Pixel);
53922: }
53922: 
53921: // Like nsStyleCoord::Calc, but with length in float pixels instead of nscoord.
53921: struct CalcValue {
53921:   float mLength, mPercent;
53921:   PRBool mHasPercent;
53921: };
53921: 
53925: // Requires a canonical calc() value that we generated.
53925: static CalcValue
53925: ExtractCalcValueInternal(const nsCSSValue& aValue)
53925: {
53925:   NS_ABORT_IF_FALSE(aValue.GetUnit() == eCSSUnit_Calc, "unexpected unit");
53925:   nsCSSValue::Array *arr = aValue.GetArrayValue();
53925:   NS_ABORT_IF_FALSE(arr->Count() == 1, "unexpected length");
53925: 
53925:   const nsCSSValue &topval = arr->Item(0);
53925:   CalcValue result;
53925:   if (topval.GetUnit() == eCSSUnit_Pixel) {
53925:     result.mLength = topval.GetFloatValue();
53925:     result.mPercent = 0.0f;
53925:     result.mHasPercent = PR_FALSE;
53925:   } else {
53925:     NS_ABORT_IF_FALSE(topval.GetUnit() == eCSSUnit_Calc_Plus,
53925:                       "unexpected unit");
53925:     nsCSSValue::Array *arr2 = topval.GetArrayValue();
53925:     const nsCSSValue &len = arr2->Item(0);
53925:     const nsCSSValue &pct = arr2->Item(1);
53925:     NS_ABORT_IF_FALSE(len.GetUnit() == eCSSUnit_Pixel, "unexpected unit");
53925:     NS_ABORT_IF_FALSE(pct.GetUnit() == eCSSUnit_Percent, "unexpected unit");
53925:     result.mLength = len.GetFloatValue();
53925:     result.mPercent = pct.GetPercentValue();
53925:     result.mHasPercent = PR_TRUE;
53925:   }
53925: 
53925:   return result;
53925: }
53925: 
53925: // Requires a canonical calc() value that we generated.
53921: static CalcValue
53921: ExtractCalcValue(const nsStyleAnimation::Value& aValue)
53921: {
53924:   CalcValue result;
53924:   if (aValue.GetUnit() == nsStyleAnimation::eUnit_Coord) {
53924:     result.mLength =
53924:       nsPresContext::AppUnitsToFloatCSSPixels(aValue.GetCoordValue());
53924:     result.mPercent = 0.0f;
53924:     result.mHasPercent = PR_FALSE;
53924:     return result;
53924:   }
53924:   if (aValue.GetUnit() == nsStyleAnimation::eUnit_Percent) {
53924:     result.mLength = 0.0f;
53924:     result.mPercent = aValue.GetPercentValue();
53924:     result.mHasPercent = PR_TRUE;
53924:     return result;
53924:   }
53921:   NS_ABORT_IF_FALSE(aValue.GetUnit() == nsStyleAnimation::eUnit_Calc,
53921:                     "unexpected unit");
53921:   nsCSSValue *val = aValue.GetCSSValueValue();
53925:   return ExtractCalcValueInternal(*val);
53925: }
53921: 
53925: static CalcValue
53925: ExtractCalcValue(const nsCSSValue& aValue)
53925: {
53925:   CalcValue result;
53925:   if (aValue.GetUnit() == eCSSUnit_Pixel) {
53925:     result.mLength = aValue.GetFloatValue();
53921:     result.mPercent = 0.0f;
53921:     result.mHasPercent = PR_FALSE;
53925:     return result;
53925:   }
53925:   if (aValue.GetUnit() == eCSSUnit_Percent) {
53925:     result.mLength = 0.0f;
53925:     result.mPercent = aValue.GetPercentValue();
53921:     result.mHasPercent = PR_TRUE;
53925:     return result;
53921:   }
53925:   return ExtractCalcValueInternal(aValue);
53921: }
53921: 
53927: static void
53922: SetCalcValue(const nsStyleCoord::Calc* aCalc, nsCSSValue& aValue)
53922: {
53922:   nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(1);
53922:   if (!aCalc->mHasPercent) {
53922:     nscoordToCSSValue(aCalc->mLength, arr->Item(0));
53922:   } else {
53922:     nsCSSValue::Array *arr2 = nsCSSValue::Array::Create(2);
53922:     arr->Item(0).SetArrayValue(arr2, eCSSUnit_Calc_Plus);
53922:     nscoordToCSSValue(aCalc->mLength, arr2->Item(0));
53922:     arr2->Item(1).SetPercentValue(aCalc->mPercent);
53922:   }
53922: 
53922:   aValue.SetArrayValue(arr, eCSSUnit_Calc);
53922: }
53922: 
59721: static already_AddRefed<nsStringBuffer>
59721: GetURIAsUtf16StringBuffer(nsIURI* aUri)
59721: {
59721:   nsCAutoString utf8String;
59721:   nsresult rv = aUri->GetSpec(utf8String);
59721:   NS_ENSURE_SUCCESS(rv, nsnull);
59721: 
59721:   return nsCSSValue::BufferFromString(NS_ConvertUTF8toUTF16(utf8String));
59721: }
59721: 
32367: // CLASS METHODS
32367: // -------------
32367: 
32367: PRBool
34869: nsStyleAnimation::ComputeDistance(nsCSSProperty aProperty,
34869:                                   const Value& aStartValue,
34029:                                   const Value& aEndValue,
32367:                                   double& aDistance)
32367: {
53924:   Unit commonUnit =
53924:     GetCommonUnit(aProperty, aStartValue.GetUnit(), aEndValue.GetUnit());
32367: 
32367:   switch (commonUnit) {
34083:     case eUnit_Null:
50938:     case eUnit_Auto:
34083:     case eUnit_None:
50938:     case eUnit_Normal:
35515:     case eUnit_UnparsedString:
50938:       return PR_FALSE;
50938: 
34083:     case eUnit_Enumerated:
34870:       switch (aProperty) {
34870:         case eCSSProperty_font_stretch: {
34870:           // just like eUnit_Integer.
34870:           PRInt32 startInt = aStartValue.GetIntValue();
34870:           PRInt32 endInt = aEndValue.GetIntValue();
71173:           aDistance = NS_ABS(endInt - startInt);
50938:           return PR_TRUE;
34870:         }
34870:         default:
50938:           return PR_FALSE;
34870:       }
36526:    case eUnit_Visibility: {
36526:       PRInt32 startVal =
36526:         aStartValue.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
36526:       PRInt32 endVal =
36526:         aEndValue.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
71173:       aDistance = NS_ABS(startVal - endVal);
50938:       return PR_TRUE;
36526:     }
34812:     case eUnit_Integer: {
34812:       PRInt32 startInt = aStartValue.GetIntValue();
34812:       PRInt32 endInt = aEndValue.GetIntValue();
71173:       aDistance = NS_ABS(endInt - startInt);
50938:       return PR_TRUE;
34812:     }
34029:     case eUnit_Coord: {
32367:       nscoord startCoord = aStartValue.GetCoordValue();
32367:       nscoord endCoord = aEndValue.GetCoordValue();
32367:       aDistance = fabs(double(endCoord - startCoord));
50938:       return PR_TRUE;
32367:     }
34029:     case eUnit_Percent: {
32367:       float startPct = aStartValue.GetPercentValue();
32367:       float endPct = aEndValue.GetPercentValue();
32367:       aDistance = fabs(double(endPct - startPct));
50938:       return PR_TRUE;
32367:     }
34029:     case eUnit_Float: {
34029:       float startFloat = aStartValue.GetFloatValue();
34029:       float endFloat = aEndValue.GetFloatValue();
34029:       aDistance = fabs(double(endFloat - startFloat));
50938:       return PR_TRUE;
33689:     }
34029:     case eUnit_Color: {
32399:       // http://www.w3.org/TR/smil-animation/#animateColorElement says
32399:       // that we should use Euclidean RGB cube distance.  However, we
32399:       // have to extend that to RGBA.  For now, we'll just use the
32399:       // Euclidean distance in the (part of the) 4-cube of premultiplied
32399:       // colors.
32399:       // FIXME (spec): The CSS transitions spec doesn't say whether
32399:       // colors are premultiplied, but things work better when they are,
32399:       // so use premultiplication.  Spec issue is still open per
32399:       // http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
32399:       nscolor startColor = aStartValue.GetColorValue();
32399:       nscolor endColor = aEndValue.GetColorValue();
32399: 
32399:       // Get a color component on a 0-1 scale, which is much easier to
32399:       // deal with when working with alpha.
32399:       #define GET_COMPONENT(component_, color_) \
32399:         (NS_GET_##component_(color_) * (1.0 / 255.0))
32399: 
32399:       double startA = GET_COMPONENT(A, startColor);
32399:       double startR = GET_COMPONENT(R, startColor) * startA;
32399:       double startG = GET_COMPONENT(G, startColor) * startA;
32399:       double startB = GET_COMPONENT(B, startColor) * startA;
32399:       double endA = GET_COMPONENT(A, endColor);
32399:       double endR = GET_COMPONENT(R, endColor) * endA;
32399:       double endG = GET_COMPONENT(G, endColor) * endA;
32399:       double endB = GET_COMPONENT(B, endColor) * endA;
32399: 
32399:       #undef GET_COMPONENT
32399: 
32399:       double diffA = startA - endA;
32399:       double diffR = startR - endR;
32399:       double diffG = startG - endG;
32399:       double diffB = startB - endB;
32399:       aDistance = sqrt(diffA * diffA + diffR * diffR +
32399:                        diffG * diffG + diffB * diffB);
50938:       return PR_TRUE;
32399:     }
53921:     case eUnit_Calc: {
53921:       CalcValue v1 = ExtractCalcValue(aStartValue);
53921:       CalcValue v2 = ExtractCalcValue(aEndValue);
53921:       float difflen = v2.mLength - v1.mLength;
53921:       float diffpct = v2.mPercent - v1.mPercent;
53921:       aDistance = sqrt(difflen * difflen + diffpct * diffpct);
53921:       return PR_TRUE;
53921:     }
34265:     case eUnit_CSSValuePair: {
34265:       const nsCSSValuePair *pair1 = aStartValue.GetCSSValuePairValue();
34265:       const nsCSSValuePair *pair2 = aEndValue.GetCSSValuePairValue();
53925:       nsCSSUnit unit[2];
53925:       unit[0] = GetCommonUnit(aProperty, pair1->mXValue.GetUnit(),
53925:                               pair2->mXValue.GetUnit());
53925:       unit[1] = GetCommonUnit(aProperty, pair1->mYValue.GetUnit(),
53925:                               pair2->mYValue.GetUnit());
59721:       if (unit[0] == eCSSUnit_Null || unit[1] == eCSSUnit_Null ||
59721:           unit[0] == eCSSUnit_URL) {
34265:         return PR_FALSE;
34265:       }
34265: 
34265:       double squareDistance = 0.0;
53925:       static nsCSSValue nsCSSValuePair::* const pairValues[2] = {
34265:         &nsCSSValuePair::mXValue, &nsCSSValuePair::mYValue
34265:       };
53925:       for (PRUint32 i = 0; i < 2; ++i) {
34265:         nsCSSValue nsCSSValuePair::*member = pairValues[i];
53925:         double diffsquared;
53925:         switch (unit[i]) {
53925:           case eCSSUnit_Pixel: {
53925:             float diff = (pair1->*member).GetFloatValue() -
34265:                          (pair2->*member).GetFloatValue();
53925:             diffsquared = diff * diff;
34265:             break;
53925:           }
53925:           case eCSSUnit_Percent: {
53925:             float diff = (pair1->*member).GetPercentValue() -
34265:                          (pair2->*member).GetPercentValue();
53925:             diffsquared = diff * diff;
34265:             break;
53925:           }
53925:           case eCSSUnit_Calc: {
53925:             CalcValue v1 = ExtractCalcValue(pair1->*member);
53925:             CalcValue v2 = ExtractCalcValue(pair2->*member);
53925:             float difflen = v2.mLength - v1.mLength;
53925:             float diffpct = v2.mPercent - v1.mPercent;
53925:             diffsquared = difflen * difflen + diffpct * diffpct;
53925:             break;
53925:           }
34265:           default:
34265:             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
34265:             return PR_FALSE;
34265:         }
53925:         squareDistance += diffsquared;
34265:       }
34265: 
34265:       aDistance = sqrt(squareDistance);
50938:       return PR_TRUE;
34265:     }
74756:     case eUnit_CSSValueTriplet: {
74756:       const nsCSSValueTriplet *triplet1 = aStartValue.GetCSSValueTripletValue();
74756:       const nsCSSValueTriplet *triplet2 = aEndValue.GetCSSValueTripletValue();
74756:       nsCSSUnit unit[3];
74756:       unit[0] = GetCommonUnit(aProperty, triplet1->mXValue.GetUnit(),
74756:                               triplet2->mXValue.GetUnit());
74756:       unit[1] = GetCommonUnit(aProperty, triplet1->mYValue.GetUnit(),
74756:                               triplet2->mYValue.GetUnit());
74756:       unit[2] = GetCommonUnit(aProperty, triplet1->mZValue.GetUnit(),
74756:                               triplet2->mZValue.GetUnit());
74756:       if (unit[0] == eCSSUnit_Null || unit[1] == eCSSUnit_Null ||
74756:           unit[0] == eCSSUnit_URL) {
74756:         return PR_FALSE;
74756:       }
74756: 
74756:       double squareDistance = 0.0;
74756:       static nsCSSValue nsCSSValueTriplet::* const pairValues[3] = {
74756:         &nsCSSValueTriplet::mXValue, &nsCSSValueTriplet::mYValue, &nsCSSValueTriplet::mZValue
74756:       };
74756:       for (PRUint32 i = 0; i < 3; ++i) {
74756:         nsCSSValue nsCSSValueTriplet::*member = pairValues[i];
74756:         double diffsquared;
74756:         switch (unit[i]) {
74756:           case eCSSUnit_Pixel: {
74756:             float diff = (triplet1->*member).GetFloatValue() -
74756:                          (triplet2->*member).GetFloatValue();
74756:             diffsquared = diff * diff;
74756:             break;
74756:           }
74756:           case eCSSUnit_Percent: {
74756:             float diff = (triplet1->*member).GetPercentValue() -
74756:                          (triplet2->*member).GetPercentValue();
74756:              diffsquared = diff * diff;
74756:              break;
74756:           }
74756:           case eCSSUnit_Calc: {
74756:             CalcValue v1 = ExtractCalcValue(triplet1->*member);
74756:             CalcValue v2 = ExtractCalcValue(triplet2->*member);
74756:             float difflen = v2.mLength - v1.mLength;
74756:             float diffpct = v2.mPercent - v1.mPercent;
74756:             diffsquared = difflen * difflen + diffpct * diffpct;
74756:             break;
74756:           }
74756:           case eCSSUnit_Null:
74756:             break;
74756:           default:
74756:             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
74756:             return PR_FALSE;
74756:         }
74756:         squareDistance += diffsquared;
74756:       }
74756: 
74756:       aDistance = sqrt(squareDistance);
74756:       return PR_TRUE;
74756:     }
36525:     case eUnit_CSSRect: {
36525:       const nsCSSRect *rect1 = aStartValue.GetCSSRectValue();
36525:       const nsCSSRect *rect2 = aEndValue.GetCSSRectValue();
36525:       if (rect1->mTop.GetUnit() != rect2->mTop.GetUnit() ||
36525:           rect1->mRight.GetUnit() != rect2->mRight.GetUnit() ||
36525:           rect1->mBottom.GetUnit() != rect2->mBottom.GetUnit() ||
36525:           rect1->mLeft.GetUnit() != rect2->mLeft.GetUnit()) {
36525:         // At least until we have calc()
36525:         return PR_FALSE;
36525:       }
36525: 
36525:       double squareDistance = 0.0;
36525:       for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(nsCSSRect::sides); ++i) {
36525:         nsCSSValue nsCSSRect::*member = nsCSSRect::sides[i];
36525:         NS_ABORT_IF_FALSE((rect1->*member).GetUnit() ==
36525:                             (rect2->*member).GetUnit(),
36525:                           "should have returned above");
36525:         double diff;
36525:         switch ((rect1->*member).GetUnit()) {
36525:           case eCSSUnit_Pixel:
36525:             diff = (rect1->*member).GetFloatValue() -
36525:                    (rect2->*member).GetFloatValue();
36525:             break;
36525:           case eCSSUnit_Auto:
36525:             diff = 0;
36525:             break;
36525:           default:
36525:             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
36525:             return PR_FALSE;
36525:         }
36525:         squareDistance += diff * diff;
36525:       }
36525: 
36525:       aDistance = sqrt(squareDistance);
50938:       return PR_TRUE;
36525:     }
34064:     case eUnit_Dasharray: {
34064:       // NOTE: This produces results on substantially different scales
34064:       // for length values and percentage values, which might even be
34064:       // mixed in the same property value.  This means the result isn't
34064:       // particularly useful for paced animation.
34064: 
34064:       // Call AddWeighted to make us lists of the same length.
34064:       Value normValue1, normValue2;
34869:       if (!AddWeighted(aProperty, 1.0, aStartValue, 0.0, aEndValue,
34869:                        normValue1) ||
34869:           !AddWeighted(aProperty, 0.0, aStartValue, 1.0, aEndValue,
34869:                        normValue2)) {
50938:         return PR_FALSE;
34064:       }
34064: 
34265:       double squareDistance = 0.0;
34064:       const nsCSSValueList *list1 = normValue1.GetCSSValueListValue();
34064:       const nsCSSValueList *list2 = normValue2.GetCSSValueListValue();
34064: 
34064:       NS_ABORT_IF_FALSE(!list1 == !list2, "lists should be same length");
34064:       while (list1) {
34064:         const nsCSSValue &val1 = list1->mValue;
34064:         const nsCSSValue &val2 = list2->mValue;
34064: 
34064:         NS_ABORT_IF_FALSE(val1.GetUnit() == val2.GetUnit(),
34064:                           "unit match should be assured by AddWeighted");
34064:         double diff;
34064:         switch (val1.GetUnit()) {
34064:           case eCSSUnit_Percent:
34064:             diff = val1.GetPercentValue() - val2.GetPercentValue();
34064:             break;
34064:           case eCSSUnit_Number:
34064:             diff = val1.GetFloatValue() - val2.GetFloatValue();
34064:             break;
34064:           default:
34064:             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
34064:             return PR_FALSE;
34064:         }
34265:         squareDistance += diff * diff;
34064: 
34064:         list1 = list1->mNext;
34064:         list2 = list2->mNext;
34064:         NS_ABORT_IF_FALSE(!list1 == !list2, "lists should be same length");
34064:       }
34064: 
34265:       aDistance = sqrt(squareDistance);
50938:       return PR_TRUE;
34064:     }
34062:     case eUnit_Shadow: {
34062:       // Call AddWeighted to make us lists of the same length.
34062:       Value normValue1, normValue2;
34869:       if (!AddWeighted(aProperty, 1.0, aStartValue, 0.0, aEndValue,
34869:                        normValue1) ||
34869:           !AddWeighted(aProperty, 0.0, aStartValue, 1.0, aEndValue,
34869:                        normValue2)) {
50938:         return PR_FALSE;
34062:       }
34062: 
34062:       const nsCSSValueList *shadow1 = normValue1.GetCSSValueListValue();
34062:       const nsCSSValueList *shadow2 = normValue2.GetCSSValueListValue();
34062: 
47195:       double squareDistance = 0.0;
34064:       NS_ABORT_IF_FALSE(!shadow1 == !shadow2, "lists should be same length");
34064:       while (shadow1) {
34062:         nsCSSValue::Array *array1 = shadow1->mValue.GetArrayValue();
34062:         nsCSSValue::Array *array2 = shadow2->mValue.GetArrayValue();
46243:         for (size_t i = 0; i < 4; ++i) {
34062:           NS_ABORT_IF_FALSE(array1->Item(i).GetUnit() == eCSSUnit_Pixel,
34062:                             "unexpected unit");
34062:           NS_ABORT_IF_FALSE(array2->Item(i).GetUnit() == eCSSUnit_Pixel,
34062:                             "unexpected unit");
34062:           double diff = array1->Item(i).GetFloatValue() -
34062:                         array2->Item(i).GetFloatValue();
34265:           squareDistance += diff * diff;
34062:         }
34062: 
34062:         const nsCSSValue &color1 = array1->Item(4);
34062:         const nsCSSValue &color2 = array2->Item(4);
47699: #ifdef DEBUG
47699:         {
34062:           const nsCSSValue &inset1 = array1->Item(5);
34062:           const nsCSSValue &inset2 = array2->Item(5);
34062:           // There are only two possible states of the inset value:
34062:           //  (1) GetUnit() == eCSSUnit_Null
34062:           //  (2) GetUnit() == eCSSUnit_Enumerated &&
34062:           //      GetIntValue() == NS_STYLE_BOX_SHADOW_INSET
34062:           NS_ABORT_IF_FALSE(color1.GetUnit() == color2.GetUnit() &&
34062:                             inset1 == inset2,
34062:                             "AddWeighted should have failed");
47699:         }
47699: #endif
34062: 
34062:         if (color1.GetUnit() != eCSSUnit_Null) {
34062:           nsStyleAnimation::Value color1Value
34062:             (color1.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
34062:           nsStyleAnimation::Value color2Value
34062:             (color2.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
34062:           double colorDistance;
34062: 
34062:         #ifdef DEBUG
34062:           PRBool ok =
34062:         #endif
34869:             nsStyleAnimation::ComputeDistance(eCSSProperty_color,
34869:                                               color1Value, color2Value,
34062:                                               colorDistance);
34062:           NS_ABORT_IF_FALSE(ok, "should not fail");
34265:           squareDistance += colorDistance * colorDistance;
34062:         }
34062: 
34062:         shadow1 = shadow1->mNext;
34062:         shadow2 = shadow2->mNext;
34064:         NS_ABORT_IF_FALSE(!shadow1 == !shadow2, "lists should be same length");
34062:       }
34265:       aDistance = sqrt(squareDistance);
50938:       return PR_TRUE;
34062:     }
47195:     case eUnit_Transform: {
56403:       return PR_FALSE;
56403:     }
36527:     case eUnit_CSSValuePairList: {
36527:       const nsCSSValuePairList *list1 = aStartValue.GetCSSValuePairListValue();
36527:       const nsCSSValuePairList *list2 = aEndValue.GetCSSValuePairListValue();
47195:       double squareDistance = 0.0;
36527:       do {
36527:         static nsCSSValue nsCSSValuePairList::* const pairListValues[] = {
36527:           &nsCSSValuePairList::mXValue,
36527:           &nsCSSValuePairList::mYValue,
36527:         };
36527:         for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairListValues); ++i) {
36527:           const nsCSSValue &v1 = list1->*(pairListValues[i]);
36527:           const nsCSSValue &v2 = list2->*(pairListValues[i]);
53925:           nsCSSUnit unit =
53925:             GetCommonUnit(aProperty, v1.GetUnit(), v2.GetUnit());
53925:           if (unit == eCSSUnit_Null) {
50938:             return PR_FALSE;
36527:           }
53925:           double diffsquared = 0.0;
53925:           switch (unit) {
53925:             case eCSSUnit_Pixel: {
53925:               float diff = v1.GetFloatValue() - v2.GetFloatValue();
53925:               diffsquared = diff * diff;
36527:               break;
53925:             }
53925:             case eCSSUnit_Percent: {
53925:               float diff = v1.GetPercentValue() - v2.GetPercentValue();
53925:               diffsquared = diff * diff;
36527:               break;
53925:             }
53925:             case eCSSUnit_Calc: {
53925:               CalcValue val1 = ExtractCalcValue(v1);
53925:               CalcValue val2 = ExtractCalcValue(v2);
53925:               float difflen = val2.mLength - val1.mLength;
53925:               float diffpct = val2.mPercent - val1.mPercent;
53925:               diffsquared = difflen * difflen + diffpct * diffpct;
53925:               break;
53925:             }
36527:             default:
36527:               if (v1 != v2) {
50938:                 return PR_FALSE;
36527:               }
36527:               break;
36527:           }
53925:           squareDistance += diffsquared;
36527:         }
36527:         list1 = list1->mNext;
36527:         list2 = list2->mNext;
36527:       } while (list1 && list2);
36527:       if (list1 || list2) {
50938:         // We can't interpolate lists of different lengths.
50938:         return PR_FALSE;
50938:       }
36527:       aDistance = sqrt(squareDistance);
50938:       return PR_TRUE;
36527:     }
36527:   }
50938: 
50938:   NS_ABORT_IF_FALSE(false, "Can't compute distance using the given common unit");
50938:   return PR_FALSE;
32367: }
32367: 
34030: #define MAX_PACKED_COLOR_COMPONENT 255
34030: 
34030: inline PRUint8 ClampColor(double aColor)
34030: {
34030:   if (aColor >= MAX_PACKED_COLOR_COMPONENT)
34030:     return MAX_PACKED_COLOR_COMPONENT;
34030:   if (aColor <= 0.0)
34030:     return 0;
34030:   return NSToIntRound(aColor);
34030: }
34030: 
69568: template <typename T>
69568: T
69568: RestrictValue(PRUint32 aRestrictions, T aValue)
69568: {
69568:   T result = aValue;
69568:   switch (aRestrictions) {
69568:     case 0:
69568:       break;
69568:     case CSS_PROPERTY_VALUE_NONNEGATIVE:
69568:       if (result < 0) {
69568:         result = 0;
69568:       }
69568:       break;
69568:     case CSS_PROPERTY_VALUE_AT_LEAST_ONE:
69568:       if (result < 1) {
69568:         result = 1;
69568:       }
69568:       break;
69568:     default:
69568:       NS_ABORT_IF_FALSE(PR_FALSE, "bad value restriction");
69568:       break;
69568:   }
69568:   return result;
69568: }
69568: 
69568: template <typename T>
69568: T
69568: RestrictValue(nsCSSProperty aProperty, T aValue)
69568: {
69568:   return RestrictValue(nsCSSProps::ValueRestrictions(aProperty), aValue);
69568: }
69568: 
47189: static inline void
47189: AddCSSValuePixel(double aCoeff1, const nsCSSValue &aValue1,
47189:                  double aCoeff2, const nsCSSValue &aValue2,
69568:                  nsCSSValue &aResult, PRUint32 aValueRestrictions = 0)
47189: {
47189:   NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Pixel, "unexpected unit");
47189:   NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Pixel, "unexpected unit");
69568:   aResult.SetFloatValue(RestrictValue(aValueRestrictions,
69568:                                       aCoeff1 * aValue1.GetFloatValue() +
69568:                                       aCoeff2 * aValue2.GetFloatValue()),
47189:                         eCSSUnit_Pixel);
47189: }
47189: 
47189: static inline void
47189: AddCSSValueNumber(double aCoeff1, const nsCSSValue &aValue1,
47189:                   double aCoeff2, const nsCSSValue &aValue2,
69568:                   nsCSSValue &aResult, PRUint32 aValueRestrictions = 0)
47189: {
47189:   NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Number, "unexpected unit");
47189:   NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Number, "unexpected unit");
69568:   aResult.SetFloatValue(RestrictValue(aValueRestrictions,
69568:                                       aCoeff1 * aValue1.GetFloatValue() +
69568:                                       aCoeff2 * aValue2.GetFloatValue()),
47189:                         eCSSUnit_Number);
47189: }
47189: 
47189: static inline void
47189: AddCSSValuePercent(double aCoeff1, const nsCSSValue &aValue1,
47189:                    double aCoeff2, const nsCSSValue &aValue2,
69568:                    nsCSSValue &aResult, PRUint32 aValueRestrictions = 0)
47189: {
47189:   NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Percent, "unexpected unit");
47189:   NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Percent, "unexpected unit");
69568:   aResult.SetPercentValue(RestrictValue(aValueRestrictions,
69568:                                         aCoeff1 * aValue1.GetPercentValue() +
69568:                                         aCoeff2 * aValue2.GetPercentValue()));
47189: }
47189: 
53925: // Add two canonical-form calc values (eUnit_Calc) to make another
53925: // canonical-form calc value.
53925: static void
53925: AddCSSValueCanonicalCalc(double aCoeff1, const nsCSSValue &aValue1,
53925:                          double aCoeff2, const nsCSSValue &aValue2,
53925:                          nsCSSValue &aResult)
53925: {
53925:   CalcValue v1 = ExtractCalcValue(aValue1);
53925:   CalcValue v2 = ExtractCalcValue(aValue2);
53925:   NS_ABORT_IF_FALSE(v1.mHasPercent || v2.mHasPercent,
53925:                     "only used on properties that always have percent in calc");
53925:   nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2),
53925:                               acalc = nsCSSValue::Array::Create(1);
53925:   a->Item(0).SetFloatValue(aCoeff1 * v1.mLength + aCoeff2 * v2.mLength,
53925:                            eCSSUnit_Pixel);
53925:   a->Item(1).SetPercentValue(aCoeff1 * v1.mPercent + aCoeff2 * v2.mPercent);
53925:   acalc->Item(0).SetArrayValue(a, eCSSUnit_Calc_Plus);
53925:   aResult.SetArrayValue(acalc, eCSSUnit_Calc);
53925: }
53925: 
47195: static void
47195: AddCSSValueAngle(const nsCSSValue &aValue1, double aCoeff1,
47195:                  const nsCSSValue &aValue2, double aCoeff2,
47195:                  nsCSSValue &aResult)
47195: {
47195:   aResult.SetFloatValue(aCoeff1 * aValue1.GetAngleValueInRadians() +
47195:                         aCoeff2 * aValue2.GetAngleValueInRadians(),
47195:                         eCSSUnit_Radian);
47195: }
47195: 
34062: static PRBool
34062: AddShadowItems(double aCoeff1, const nsCSSValue &aValue1,
34062:                double aCoeff2, const nsCSSValue &aValue2,
34062:                nsCSSValueList **&aResultTail)
34062: {
34062:   // X, Y, Radius, Spread, Color, Inset
34062:   NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Array,
34062:                     "wrong unit");
34062:   NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Array,
34062:                     "wrong unit");
34062:   nsCSSValue::Array *array1 = aValue1.GetArrayValue();
34062:   nsCSSValue::Array *array2 = aValue2.GetArrayValue();
34062:   nsRefPtr<nsCSSValue::Array> resultArray = nsCSSValue::Array::Create(6);
34062: 
46243:   for (size_t i = 0; i < 4; ++i) {
47189:     AddCSSValuePixel(aCoeff1, array1->Item(i), aCoeff2, array2->Item(i),
69568:                      resultArray->Item(i),
69568:                      // blur radius must be nonnegative
69568:                      (i == 2) ? CSS_PROPERTY_VALUE_NONNEGATIVE : 0);
34062:   }
34062: 
34062:   const nsCSSValue& color1 = array1->Item(4);
34062:   const nsCSSValue& color2 = array2->Item(4);
34062:   const nsCSSValue& inset1 = array1->Item(5);
34062:   const nsCSSValue& inset2 = array2->Item(5);
34062:   if (color1.GetUnit() != color2.GetUnit() ||
34062:       inset1.GetUnit() != inset2.GetUnit()) {
34062:     // We don't know how to animate between color and no-color, or
34062:     // between inset and not-inset.
34062:     return PR_FALSE;
34062:   }
34062: 
34062:   if (color1.GetUnit() != eCSSUnit_Null) {
34062:     nsStyleAnimation::Value color1Value
34062:       (color1.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
34062:     nsStyleAnimation::Value color2Value
34062:       (color2.GetColorValue(), nsStyleAnimation::Value::ColorConstructor);
34062:     nsStyleAnimation::Value resultColorValue;
34062:   #ifdef DEBUG
34062:     PRBool ok =
34062:   #endif
34869:       nsStyleAnimation::AddWeighted(eCSSProperty_color, aCoeff1, color1Value,
34869:                                     aCoeff2, color2Value, resultColorValue);
34062:     NS_ABORT_IF_FALSE(ok, "should not fail");
34062:     resultArray->Item(4).SetColorValue(resultColorValue.GetColorValue());
34062:   }
34062: 
34062:   NS_ABORT_IF_FALSE(inset1 == inset2, "should match");
34062:   resultArray->Item(5) = inset1;
34062: 
34062:   nsCSSValueList *resultItem = new nsCSSValueList;
34062:   if (!resultItem) {
34062:     return PR_FALSE;
34062:   }
34062:   resultItem->mValue.SetArrayValue(resultArray, eCSSUnit_Array);
34062:   *aResultTail = resultItem;
34062:   aResultTail = &resultItem->mNext;
34062:   return PR_TRUE;
34062: }
34062: 
47195: static void
47195: AddTransformTranslate(const nsCSSValue &aValue1, double aCoeff1,
47195:                       const nsCSSValue &aValue2, double aCoeff2,
47195:                       nsCSSValue &aResult)
47195: {
47195:   NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Percent ||
47195:                     aValue1.GetUnit() == eCSSUnit_Pixel ||
47195:                     aValue1.IsCalcUnit(),
47195:                     "unexpected unit");
47195:   NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Percent ||
47195:                     aValue2.GetUnit() == eCSSUnit_Pixel ||
47195:                     aValue2.IsCalcUnit(),
47195:                     "unexpected unit");
47195: 
47195:   if (aValue1.GetUnit() != aValue2.GetUnit() || aValue1.IsCalcUnit()) {
47195:     // different units; create a calc() expression
56403:     AddCSSValueCanonicalCalc(aCoeff1, aValue1, aCoeff2, aValue2, aResult);
47195:   } else if (aValue1.GetUnit() == eCSSUnit_Percent) {
47195:     // both percent
47195:     AddCSSValuePercent(aCoeff1, aValue1, aCoeff2, aValue2, aResult);
47195:   } else {
47195:     // both pixels
47195:     AddCSSValuePixel(aCoeff1, aValue1, aCoeff2, aValue2, aResult);
47195:   }
47195: }
47195: 
47195: static void
47195: AddTransformScale(const nsCSSValue &aValue1, double aCoeff1,
47195:                   const nsCSSValue &aValue2, double aCoeff2,
47195:                   nsCSSValue &aResult)
47195: {
47195:   // Handle scale, and the two matrix components where identity is 1, by
47195:   // subtracting 1, multiplying by the coefficients, and then adding 1
47195:   // back.  This gets the right AddWeighted behavior and gets us the
47195:   // interpolation-against-identity behavior for free.
47195:   NS_ABORT_IF_FALSE(aValue1.GetUnit() == eCSSUnit_Number, "unexpected unit");
47195:   NS_ABORT_IF_FALSE(aValue2.GetUnit() == eCSSUnit_Number, "unexpected unit");
47195: 
47195:   float v1 = aValue1.GetFloatValue() - 1.0f,
47195:         v2 = aValue2.GetFloatValue() - 1.0f;
47195:   float result = v1 * aCoeff1 + v2 * aCoeff2;
47195:   aResult.SetFloatValue(result + 1.0f, eCSSUnit_Number);
47195: }
47195: 
47195: static already_AddRefed<nsCSSValue::Array>
47195: AppendTransformFunction(nsCSSKeyword aTransformFunction,
47195:                         nsCSSValueList**& aListTail)
47195: {
47195:   PRUint32 nargs;
47195:   if (aTransformFunction == eCSSKeyword_matrix) {
47195:     nargs = 6;
47195:   } else if (aTransformFunction == eCSSKeyword_translate ||
47195:              aTransformFunction == eCSSKeyword_skew ||
47195:              aTransformFunction == eCSSKeyword_scale) {
47195:     nargs = 2;
74281:   } else if (aTransformFunction == eCSSKeyword_interpolatematrix) {
74281:     nargs = 4;
47195:   } else {
47195:     NS_ABORT_IF_FALSE(aTransformFunction == eCSSKeyword_translatex ||
47195:                       aTransformFunction == eCSSKeyword_translatey ||
47195:                       aTransformFunction == eCSSKeyword_scalex ||
47195:                       aTransformFunction == eCSSKeyword_scaley ||
47195:                       aTransformFunction == eCSSKeyword_skewx ||
47195:                       aTransformFunction == eCSSKeyword_skewy ||
47195:                       aTransformFunction == eCSSKeyword_rotate,
47195:                       "must be a transform function");
47195:     nargs = 1;
47195:   }
47195: 
47195:   nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(nargs + 1);
47195:   arr->Item(0).SetStringValue(
47195:     NS_ConvertUTF8toUTF16(nsCSSKeywords::GetStringValue(aTransformFunction)),
47195:     eCSSUnit_Ident);
47195: 
47195:   nsCSSValueList *item = new nsCSSValueList;
47195:   item->mValue.SetArrayValue(arr, eCSSUnit_Function);
47195: 
47195:   *aListTail = item;
47195:   aListTail = &item->mNext;
47195: 
47195:   return arr.forget();
47195: }
47195: 
47195: /*
47195:  * The relevant section of the transitions specification:
47195:  * http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
47195:  * defers all of the details to the 2-D and 3-D transforms specifications.
47195:  * For the 2-D transforms specification (all that's relevant for us, right
47195:  * now), the relevant section is:
47195:  * http://dev.w3.org/csswg/css3-2d-transforms/#animation
47195:  * This, in turn, refers to the unmatrix program in Graphics Gems,
47195:  * available from http://tog.acm.org/resources/GraphicsGems/ , and in
47195:  * particular as the file GraphicsGems/gemsii/unmatrix.c
47195:  * in http://tog.acm.org/resources/GraphicsGems/AllGems.tar.gz
47195:  *
47195:  * The unmatrix reference is for general 3-D transform matrices (any of the
47195:  * 16 components can have any value).
47195:  *
47195:  * For CSS 2-D transforms, we have a 2-D matrix with the bottom row constant:
47195:  *
47195:  * [ A C E ]
47195:  * [ B D F ]
47195:  * [ 0 0 1 ]
47195:  *
47195:  * For that case, I believe the algorithm in unmatrix reduces to:
47195:  *
47195:  *  (1) If A * D - B * C == 0, the matrix is singular.  Fail.
47195:  *
47195:  *  (2) Set translation components (Tx and Ty) to the translation parts of
47195:  *      the matrix (E and F) and then ignore them for the rest of the time.
47195:  *      (For us, E and F each actually consist of three constants:  a
47195:  *      length, a multiplier for the width, and a multiplier for the
47195:  *      height.  This actually requires its own decomposition, but I'll
47195:  *      keep that separate.)
47195:  *
47195:  *  (3) Let the X scale (Sx) be sqrt(A^2 + B^2).  Then divide both A and B
47195:  *      by it.
47195:  *
47195:  *  (4) Let the XY shear (K) be A * C + B * D.  From C, subtract A times
47195:  *      the XY shear.  From D, subtract B times the XY shear.
47195:  *
47195:  *  (5) Let the Y scale (Sy) be sqrt(C^2 + D^2).  Divide C, D, and the XY
47195:  *      shear (K) by it.
47195:  *
47195:  *  (6) At this point, A * D - B * C is either 1 or -1.  If it is -1,
47847:  *      negate the XY shear (K), the X scale (Sx), and A, B, C, and D.
47195:  *      (Alternatively, we could negate the XY shear (K) and the Y scale
47195:  *      (Sy).)
47195:  *
47195:  *  (7) Let the rotation be R = atan2(B, A).
47195:  *
47195:  * Then the resulting decomposed transformation is:
47195:  *
47195:  *   translate(Tx, Ty) rotate(R) skewX(atan(K)) scale(Sx, Sy)
47195:  *
47195:  * An interesting result of this is that all of the simple transform
47195:  * functions (i.e., all functions other than matrix()), in isolation,
47195:  * decompose back to themselves except for:
47195:  *   'skewY(φ)', which is 'matrix(1, tan(φ), 0, 1, 0, 0)', which decomposes
47195:  *   to 'rotate(φ) skewX(φ) scale(sec(φ), cos(φ))' since (ignoring the
47195:  *   alternate sign possibilities that would get fixed in step 6):
47195:  *     In step 3, the X scale factor is sqrt(1+tan²(φ)) = sqrt(sec²(φ)) = sec(φ).
47195:  *     Thus, after step 3, A = 1/sec(φ) = cos(φ) and B = tan(φ) / sec(φ) = sin(φ).
47195:  *     In step 4, the XY shear is sin(φ).
47195:  *     Thus, after step 4, C = -cos(φ)sin(φ) and D = 1 - sin²(φ) = cos²(φ).
47195:  *     Thus, in step 5, the Y scale is sqrt(cos²(φ)(sin²(φ) + cos²(φ)) = cos(φ).
47195:  *     Thus, after step 5, C = -sin(φ), D = cos(φ), and the XY shear is tan(φ).
47195:  *     Thus, in step 6, A * D - B * C = cos²(φ) + sin²(φ) = 1.
47195:  *     In step 7, the rotation is thus φ.
47195:  *
47195:  *   skew(θ, φ), which is matrix(1, tan(φ), tan(θ), 1, 0, 0), which decomposes
47195:  *   to 'rotate(φ) skewX(θ + φ) scale(sec(φ), cos(φ))' since (ignoring
47195:  *   the alternate sign possibilities that would get fixed in step 6):
47195:  *     In step 3, the X scale factor is sqrt(1+tan²(φ)) = sqrt(sec²(φ)) = sec(φ).
47195:  *     Thus, after step 3, A = 1/sec(φ) = cos(φ) and B = tan(φ) / sec(φ) = sin(φ).
47195:  *     In step 4, the XY shear is cos(φ)tan(θ) + sin(φ).
47195:  *     Thus, after step 4,
47195:  *     C = tan(θ) - cos(φ)(cos(φ)tan(θ) + sin(φ)) = tan(θ)sin²(φ) - cos(φ)sin(φ)
47195:  *     D = 1 - sin(φ)(cos(φ)tan(θ) + sin(φ)) = cos²(φ) - sin(φ)cos(φ)tan(θ)
47195:  *     Thus, in step 5, the Y scale is sqrt(C² + D²) =
47195:  *     sqrt(tan²(θ)(sin⁴(φ) + sin²(φ)cos²(φ)) -
47195:  *          2 tan(θ)(sin³(φ)cos(φ) + sin(φ)cos³(φ)) +
47195:  *          (sin²(φ)cos²(φ) + cos⁴(φ))) =
47195:  *     sqrt(tan²(θ)sin²(φ) - 2 tan(θ)sin(φ)cos(φ) + cos²(φ)) =
47195:  *     cos(φ) - tan(θ)sin(φ) (taking the negative of the obvious solution so
47195:  *     we avoid flipping in step 6).
47195:  *     After step 5, C = -sin(φ) and D = cos(φ), and the XY shear is
47195:  *     (cos(φ)tan(θ) + sin(φ)) / (cos(φ) - tan(θ)sin(φ)) =
47195:  *     (dividing both numerator and denominator by cos(φ))
47195:  *     (tan(θ) + tan(φ)) / (1 - tan(θ)tan(φ)) = tan(θ + φ).
47195:  *     (See http://en.wikipedia.org/wiki/List_of_trigonometric_identities .)
47195:  *     Thus, in step 6, A * D - B * C = cos²(φ) + sin²(φ) = 1.
47195:  *     In step 7, the rotation is thus φ.
47195:  *
47195:  *     To check this result, we can multiply things back together:
47195:  *
47195:  *     [ cos(φ) -sin(φ) ] [ 1 tan(θ + φ) ] [ sec(φ)    0   ]
47195:  *     [ sin(φ)  cos(φ) ] [ 0      1     ] [   0    cos(φ) ]
47195:  *
47195:  *     [ cos(φ)      cos(φ)tan(θ + φ) - sin(φ) ] [ sec(φ)    0   ]
47195:  *     [ sin(φ)      sin(φ)tan(θ + φ) + cos(φ) ] [   0    cos(φ) ]
47195:  *
47195:  *     but since tan(θ + φ) = (tan(θ) + tan(φ)) / (1 - tan(θ)tan(φ)),
47195:  *     cos(φ)tan(θ + φ) - sin(φ)
47195:  *      = cos(φ)(tan(θ) + tan(φ)) - sin(φ) + sin(φ)tan(θ)tan(φ)
47195:  *      = cos(φ)tan(θ) + sin(φ) - sin(φ) + sin(φ)tan(θ)tan(φ)
47195:  *      = cos(φ)tan(θ) + sin(φ)tan(θ)tan(φ)
47195:  *      = tan(θ) (cos(φ) + sin(φ)tan(φ))
47195:  *      = tan(θ) sec(φ) (cos²(φ) + sin²(φ))
47195:  *      = tan(θ) sec(φ)
47195:  *     and
47195:  *     sin(φ)tan(θ + φ) + cos(φ)
47195:  *      = sin(φ)(tan(θ) + tan(φ)) + cos(φ) - cos(φ)tan(θ)tan(φ)
47195:  *      = tan(θ) (sin(φ) - sin(φ)) + sin(φ)tan(φ) + cos(φ)
47195:  *      = sec(φ) (sin²(φ) + cos²(φ))
47195:  *      = sec(φ)
47195:  *     so the above is:
47195:  *     [ cos(φ)  tan(θ) sec(φ) ] [ sec(φ)    0   ]
47195:  *     [ sin(φ)     sec(φ)     ] [   0    cos(φ) ]
47195:  *
47195:  *     [    1   tan(θ) ]
47195:  *     [ tan(φ)    1   ]
47195:  */
47195: 
47195: /*
47195:  * DecomposeMatrix implements the non-translation parts of the above
47195:  * decomposition algorithm.
47195:  */
47195: static PRBool
74281: DecomposeMatrix(const gfxMatrix &aMatrix,
47195:                 float &aRotate, float &aXYShear, float &aScaleX, float &aScaleY)
47195: {
74281:   float A = aMatrix.xx,
74281:         B = aMatrix.yx,
74281:         C = aMatrix.xy,
74281:         D = aMatrix.yy;
47195:   if (A * D == B * C) {
47195:     // singular matrix
47195:     return PR_FALSE;
47195:   }
47195: 
47195:   float scaleX = sqrt(A * A + B * B);
47195:   A /= scaleX;
47195:   B /= scaleX;
47195: 
47195:   float XYshear = A * C + B * D;
47195:   C -= A * XYshear;
47195:   D -= B * XYshear;
47195: 
47195:   float scaleY = sqrt(C * C + D * D);
47195:   C /= scaleY;
47195:   D /= scaleY;
47195:   XYshear /= scaleY;
47195: 
47195:  // A*D - B*C should now be 1 or -1
71173:   NS_ASSERTION(0.99 < NS_ABS(A*D - B*C) && NS_ABS(A*D - B*C) < 1.01,
47195:                "determinant should now be 1 or -1");
47195:   if (A * D < B * C) {
47195:     A = -A;
47195:     B = -B;
47195:     C = -C;
47195:     D = -D;
47195:     XYshear = -XYshear;
47195:     scaleX = -scaleX;
47195:   }
47195: 
47195:   float rotation = atan2f(B, A);
47195: 
47195:   aRotate = rotation;
47195:   aXYShear = XYshear;
47195:   aScaleX = scaleX;
47195:   aScaleY = scaleY;
47195: 
47195:   return PR_TRUE;
47195: }
47195: 
74281: /* Force small values to zero.  We do this to avoid having sin(360deg)
74281:  * evaluate to a tiny but nonzero value.
74281:  */
74281: static double FlushToZero(double aVal)
47195: {
74281:   if (-FLT_EPSILON < aVal && aVal < FLT_EPSILON)
74281:     return 0.0f;
74281:   else
74281:     return aVal;
74281: }
47195: 
74281: /* Computes tan(aTheta).  For values of aTheta such that tan(aTheta) is
74281:  * undefined or very large, SafeTangent returns a manageably large value
74281:  * of the correct sign.
74281:  */
74281: static double SafeTangent(double aTheta)
74281: {
74281:   const double kEpsilon = 0.0001;
47195: 
74281:   /* tan(theta) = sin(theta)/cos(theta); problems arise when
74281:    * cos(theta) is too close to zero.  Limit cos(theta) to the
74281:    * range [-1, -epsilon] U [epsilon, 1].
74281:    */
74281:   double sinTheta = sin(aTheta);
74281:   double cosTheta = cos(aTheta);
47195: 
74281:   if (cosTheta >= 0 && cosTheta < kEpsilon)
74281:     cosTheta = kEpsilon;
74281:   else if (cosTheta < 0 && cosTheta >= -kEpsilon)
74281:     cosTheta = -kEpsilon;
47195: 
74281:   return FlushToZero(sinTheta / cosTheta);
74281: }
47195: 
47195: 
74281: /* static */ gfxMatrix
74281: nsStyleAnimation::InterpolateTransformMatrix(const gfxMatrix &aMatrix1,
74281:                                              double aCoeff1,
74281:                                              const gfxMatrix &aMatrix2,
74281:                                              double aCoeff2)
74281: {
47195:   float rotate1, XYshear1, scaleX1, scaleY1;
47195:   DecomposeMatrix(aMatrix1, rotate1, XYshear1, scaleX1, scaleY1);
47195:   float rotate2, XYshear2, scaleX2, scaleY2;
47195:   DecomposeMatrix(aMatrix2, rotate2, XYshear2, scaleX2, scaleY2);
47195: 
47195:   float rotate = rotate1 * aCoeff1 + rotate2 * aCoeff2;
47195: 
57583:   float skewX = atanf(XYshear1) * aCoeff1 + atanf(XYshear2) * aCoeff2;
47195: 
47195:   // Handle scale, and the two matrix components where identity is 1, by
47195:   // subtracting 1, multiplying by the coefficients, and then adding 1
47195:   // back.  This gets the right AddWeighted behavior and gets us the
47195:   // interpolation-against-identity behavior for free.
47195:   float scaleX =
47195:     ((scaleX1 - 1.0f) * aCoeff1 + (scaleX2 - 1.0f) * aCoeff2) + 1.0f;
47195:   float scaleY =
47195:     ((scaleY1 - 1.0f) * aCoeff1 + (scaleY2 - 1.0f) * aCoeff2) + 1.0f;
47195: 
74281:   gfxMatrix result;
47195: 
74281:   gfxMatrix skew;
74281:   skew.xy = SafeTangent(skewX);
74281:   result.Translate(gfxPoint(aMatrix1.x0 * aCoeff1 + aMatrix2.x0 * aCoeff2,
74281:                    aMatrix1.y0 * aCoeff1 + aMatrix2.y0 * aCoeff2));
74281:   result.Rotate(rotate);
74281:   result.PreMultiply(skew);
74281:   result.Scale(scaleX, scaleY);
47195: 
74281:   return result;
74281: }
47195: 
74281: static nsCSSValueList*
74281: AddDifferentTransformLists(const nsCSSValueList* aList1, double aCoeff1,
74281:                            const nsCSSValueList* aList2, double aCoeff2)
74281: {
74281:   nsAutoPtr<nsCSSValueList> result;
74281:   nsCSSValueList **resultTail = getter_Transfers(result);
47195: 
74281:   nsRefPtr<nsCSSValue::Array> arr;
74281:   arr = AppendTransformFunction(eCSSKeyword_interpolatematrix, resultTail);
74281: 
74281:   arr->Item(1).SetPercentValue(aCoeff1);
74281:   aList1->CloneInto(arr->Item(2).SetListValue());
74281:   arr->Item(3).SetPercentValue(aCoeff2);
74281:   aList2->CloneInto(arr->Item(4).SetListValue());
47195: 
47195:   return result.forget();
47195: }
47195: 
47195: static nsCSSValueList*
47195: AddTransformLists(const nsCSSValueList* aList1, double aCoeff1,
47195:                   const nsCSSValueList* aList2, double aCoeff2)
47195: {
47195:   nsAutoPtr<nsCSSValueList> result;
47195:   nsCSSValueList **resultTail = getter_Transfers(result);
47195: 
47195:   do {
47195:     const nsCSSValue::Array *a1 = aList1->mValue.GetArrayValue(),
47195:                             *a2 = aList2->mValue.GetArrayValue();
47195:     NS_ABORT_IF_FALSE(nsStyleTransformMatrix::TransformFunctionOf(a1) ==
47195:                       nsStyleTransformMatrix::TransformFunctionOf(a2),
47195:                       "transform function mismatch");
47195: 
47195:     nsCSSKeyword tfunc = nsStyleTransformMatrix::TransformFunctionOf(a1);
47195:     nsRefPtr<nsCSSValue::Array> arr;
74835:     if (tfunc != eCSSKeyword_matrix && tfunc != eCSSKeyword_interpolatematrix) {
47195:       arr = AppendTransformFunction(tfunc, resultTail);
47195:     }
47195: 
47195:     switch (tfunc) {
47195:       case eCSSKeyword_translate: {
47195:         NS_ABORT_IF_FALSE(a1->Count() == 2 || a1->Count() == 3,
47195:                           "unexpected count");
47195:         NS_ABORT_IF_FALSE(a2->Count() == 2 || a2->Count() == 3,
47195:                           "unexpected count");
47195: 
47195:         // FIXME: This would produce fewer calc() expressions if the
47195:         // zero were of compatible type (length vs. percent) when
47195:         // needed.
47195:         nsCSSValue zero(0.0f, eCSSUnit_Pixel);
47195:         // Add Y component of translation.
47195:         AddTransformTranslate(a1->Count() == 3 ? a1->Item(2) : zero,
47195:                               aCoeff1,
47195:                               a2->Count() == 3 ? a2->Item(2) : zero,
47195:                               aCoeff2,
47195:                               arr->Item(2));
47195: 
47195:         // Add X component of translation (which can be merged with case
47195:         // below in non-DEBUG).
47195:         AddTransformTranslate(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
47195:                               arr->Item(1));
47195:         break;
47195:       }
47195:       case eCSSKeyword_translatex:
47195:       case eCSSKeyword_translatey: {
47195:         NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
47195:         NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
47195:         AddTransformTranslate(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
47195:                               arr->Item(1));
47195:         break;
47195:       }
47195:       case eCSSKeyword_scale: {
47195:         NS_ABORT_IF_FALSE(a1->Count() == 2 || a1->Count() == 3,
47195:                           "unexpected count");
47195:         NS_ABORT_IF_FALSE(a2->Count() == 2 || a2->Count() == 3,
47195:                           "unexpected count");
47195: 
47195:         // This is different from skew() and translate(), since an
47195:         // omitted second parameter repeats the first rather than being
47195:         // zero.
47195:         // Add Y component of scale.
47195:         AddTransformScale(a1->Count() == 3 ? a1->Item(2) : a1->Item(1),
47195:                           aCoeff1,
47195:                           a2->Count() == 3 ? a2->Item(2) : a2->Item(1),
47195:                           aCoeff2,
47195:                           arr->Item(2));
47195: 
47195:         // Add X component of scale (which can be merged with case below
47195:         // in non-DEBUG).
47195:         AddTransformScale(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
47195:                           arr->Item(1));
47195: 
47195:         break;
47195:       }
47195:       case eCSSKeyword_scalex:
47195:       case eCSSKeyword_scaley: {
47195:         NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
47195:         NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
47195: 
47195:         AddTransformScale(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
47195:                           arr->Item(1));
47195: 
47195:         break;
47195:       }
57583:       // It would probably be nicer to animate skew in tangent space
57583:       // rather than angle space.  However, it's easy to specify
57583:       // skews with infinite tangents, and behavior changes pretty
57583:       // drastically when crossing such skews (since the direction of
57583:       // animation flips), so interop is probably more important here.
47195:       case eCSSKeyword_skew: {
47195:         NS_ABORT_IF_FALSE(a1->Count() == 2 || a1->Count() == 3,
47195:                           "unexpected count");
47195:         NS_ABORT_IF_FALSE(a2->Count() == 2 || a2->Count() == 3,
47195:                           "unexpected count");
47195: 
47195:         nsCSSValue zero(0.0f, eCSSUnit_Radian);
47195:         // Add Y component of skew.
57583:         AddCSSValueAngle(a1->Count() == 3 ? a1->Item(2) : zero,
47195:                          aCoeff1,
47195:                          a2->Count() == 3 ? a2->Item(2) : zero,
47195:                          aCoeff2,
47195:                          arr->Item(2));
47195: 
47195:         // Add X component of skew (which can be merged with case below
47195:         // in non-DEBUG).
57583:         AddCSSValueAngle(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
47195:                          arr->Item(1));
47195: 
47195:         break;
47195:       }
47195:       case eCSSKeyword_skewx:
57583:       case eCSSKeyword_skewy:
47195:       case eCSSKeyword_rotate: {
47195:         NS_ABORT_IF_FALSE(a1->Count() == 2, "unexpected count");
47195:         NS_ABORT_IF_FALSE(a2->Count() == 2, "unexpected count");
47195: 
47195:         AddCSSValueAngle(a1->Item(1), aCoeff1, a2->Item(1), aCoeff2,
47195:                          arr->Item(1));
47195: 
47195:         break;
47195:       }
74835:       case eCSSKeyword_matrix:
74835:       case eCSSKeyword_interpolatematrix: {
74281:         // FIXME: If the matrix contains only numbers then we could decompose
74281:         // here. We can't do this for matrix3d though, so it's probably
74281:         // best to stay consistent.
74281: 
74281:         // Construct temporary lists with only this item in them.
74281:         nsCSSValueList tempList1, tempList2;
74281:         tempList1.mValue = aList1->mValue;
74281:         tempList2.mValue = aList2->mValue;
47195: 
47195:         *resultTail =
74281:           AddDifferentTransformLists(&tempList1, aCoeff1, &tempList2, aCoeff2);
47195: 
47195:         while ((*resultTail)->mNext) {
47195:           resultTail = &(*resultTail)->mNext;
47195:         }
47195: 
47195:         break;
47195:       }
47195:       default:
47195:         NS_ABORT_IF_FALSE(PR_FALSE, "unknown transform function");
47195:     }
47195: 
47195:     aList1 = aList1->mNext;
47195:     aList2 = aList2->mNext;
47195:   } while (aList1);
47195:   NS_ABORT_IF_FALSE(!aList2, "list length mismatch");
47195: 
47195:   return result.forget();
47195: }
47195: 
32367: PRBool
34869: nsStyleAnimation::AddWeighted(nsCSSProperty aProperty,
34869:                               double aCoeff1, const Value& aValue1,
34030:                               double aCoeff2, const Value& aValue2,
34029:                               Value& aResultValue)
32367: {
53924:   Unit commonUnit =
53924:     GetCommonUnit(aProperty, aValue1.GetUnit(), aValue2.GetUnit());
32367:   // Maybe need a followup method to convert the inputs into the common
32367:   // unit-type, if they don't already match it. (Or would it make sense to do
32367:   // that in GetCommonUnit? in which case maybe ConvertToCommonUnit would be
32367:   // better.)
32367: 
32367:   switch (commonUnit) {
34083:     case eUnit_Null:
50938:     case eUnit_Auto:
34083:     case eUnit_None:
50938:     case eUnit_Normal:
35515:     case eUnit_UnparsedString:
50938:       return PR_FALSE;
50938: 
34083:     case eUnit_Enumerated:
34870:       switch (aProperty) {
34870:         case eCSSProperty_font_stretch: {
34870:           // Animate just like eUnit_Integer.
34870:           PRInt32 result = NS_floor(aCoeff1 * double(aValue1.GetIntValue()) +
34870:                                     aCoeff2 * double(aValue2.GetIntValue()));
69568:           if (result < NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED) {
69568:             result = NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED;
69568:           } else if (result > NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED) {
69568:             result = NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED;
69568:           }
34870:           aResultValue.SetIntValue(result, eUnit_Enumerated);
50938:           return PR_TRUE;
34870:         }
34870:         default:
50938:           return PR_FALSE;
34870:       }
36526:     case eUnit_Visibility: {
36526:       PRInt32 val1 = aValue1.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
36526:       PRInt32 val2 = aValue2.GetIntValue() == NS_STYLE_VISIBILITY_VISIBLE;
36526:       double interp = aCoeff1 * val1 + aCoeff2 * val2;
36526:       PRInt32 result = interp > 0.0 ? NS_STYLE_VISIBILITY_VISIBLE
36526:                                     : NS_STYLE_VISIBILITY_HIDDEN;
36526:       aResultValue.SetIntValue(result, eUnit_Visibility);
50938:       return PR_TRUE;
36526:     }
34812:     case eUnit_Integer: {
34812:       // http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
34812:       // says we should use floor
34870:       PRInt32 result = NS_floor(aCoeff1 * double(aValue1.GetIntValue()) +
34870:                                 aCoeff2 * double(aValue2.GetIntValue()));
34870:       if (aProperty == eCSSProperty_font_weight) {
69568:         if (result < 100) {
69568:           result = 100;
69568:         } else if (result > 900) {
69568:           result = 900;
69568:         }
72752:         result -= result % 100;
69568:       } else {
69568:         result = RestrictValue(aProperty, result);
34870:       }
34870:       aResultValue.SetIntValue(result, eUnit_Integer);
50938:       return PR_TRUE;
34812:     }
34029:     case eUnit_Coord: {
69568:       aResultValue.SetCoordValue(RestrictValue(aProperty, NSToCoordRound(
34030:         aCoeff1 * aValue1.GetCoordValue() +
69568:         aCoeff2 * aValue2.GetCoordValue())));
50938:       return PR_TRUE;
32367:     }
34029:     case eUnit_Percent: {
69568:       aResultValue.SetPercentValue(RestrictValue(aProperty,
34030:         aCoeff1 * aValue1.GetPercentValue() +
69568:         aCoeff2 * aValue2.GetPercentValue()));
50938:       return PR_TRUE;
32367:     }
34029:     case eUnit_Float: {
69568:       aResultValue.SetFloatValue(RestrictValue(aProperty,
34030:         aCoeff1 * aValue1.GetFloatValue() +
69568:         aCoeff2 * aValue2.GetFloatValue()));
50938:       return PR_TRUE;
33689:     }
34029:     case eUnit_Color: {
34030:       nscolor color1 = aValue1.GetColorValue();
34030:       nscolor color2 = aValue2.GetColorValue();
32399:       // FIXME (spec): The CSS transitions spec doesn't say whether
32399:       // colors are premultiplied, but things work better when they are,
32399:       // so use premultiplication.  Spec issue is still open per
32399:       // http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
32399: 
32399:       // To save some math, scale the alpha down to a 0-1 scale, but
32399:       // leave the color components on a 0-255 scale.
34030:       double A1 = NS_GET_A(color1) * (1.0 / 255.0);
34030:       double R1 = NS_GET_R(color1) * A1;
34030:       double G1 = NS_GET_G(color1) * A1;
34030:       double B1 = NS_GET_B(color1) * A1;
34030:       double A2 = NS_GET_A(color2) * (1.0 / 255.0);
34030:       double R2 = NS_GET_R(color2) * A2;
34030:       double G2 = NS_GET_G(color2) * A2;
34030:       double B2 = NS_GET_B(color2) * A2;
34030:       double Aresf = (A1 * aCoeff1 + A2 * aCoeff2);
32399:       nscolor resultColor;
34030:       if (Aresf <= 0.0) {
32399:         resultColor = NS_RGBA(0, 0, 0, 0);
32399:       } else {
34030:         if (Aresf > 1.0) {
34030:           Aresf = 1.0;
34030:         }
34030:         double factor = 1.0 / Aresf;
34030:         PRUint8 Ares = NSToIntRound(Aresf * 255.0);
34030:         PRUint8 Rres = ClampColor((R1 * aCoeff1 + R2 * aCoeff2) * factor);
34030:         PRUint8 Gres = ClampColor((G1 * aCoeff1 + G2 * aCoeff2) * factor);
34030:         PRUint8 Bres = ClampColor((B1 * aCoeff1 + B2 * aCoeff2) * factor);
34030:         resultColor = NS_RGBA(Rres, Gres, Bres, Ares);
32399:       }
32399:       aResultValue.SetColorValue(resultColor);
50938:       return PR_TRUE;
32399:     }
53921:     case eUnit_Calc: {
53921:       CalcValue v1 = ExtractCalcValue(aValue1);
53921:       CalcValue v2 = ExtractCalcValue(aValue2);
53921:       double len = aCoeff1 * v1.mLength + aCoeff2 * v2.mLength;
53921:       double pct = aCoeff1 * v1.mPercent + aCoeff2 * v2.mPercent;
53921:       PRBool hasPct = (aCoeff1 != 0.0 && v1.mHasPercent) ||
53921:                       (aCoeff2 != 0.0 && v2.mHasPercent);
53921:       nsCSSValue *val = new nsCSSValue();
53921:       nsCSSValue::Array *arr = nsCSSValue::Array::Create(1);
53921:       val->SetArrayValue(arr, eCSSUnit_Calc);
53921:       if (hasPct) {
53921:         nsCSSValue::Array *arr2 = nsCSSValue::Array::Create(2);
53921:         arr2->Item(0).SetFloatValue(len, eCSSUnit_Pixel);
53921:         arr2->Item(1).SetPercentValue(pct);
53921:         arr->Item(0).SetArrayValue(arr2, eCSSUnit_Calc_Plus);
53921:       } else {
53921:         arr->Item(0).SetFloatValue(len, eCSSUnit_Pixel);
53921:       }
53921:       aResultValue.SetAndAdoptCSSValueValue(val, eUnit_Calc);
53921:       return PR_TRUE;
53921:     }
34265:     case eUnit_CSSValuePair: {
34265:       const nsCSSValuePair *pair1 = aValue1.GetCSSValuePairValue();
34265:       const nsCSSValuePair *pair2 = aValue2.GetCSSValuePairValue();
53925:       nsCSSUnit unit[2];
53925:       unit[0] = GetCommonUnit(aProperty, pair1->mXValue.GetUnit(),
53925:                               pair2->mXValue.GetUnit());
53925:       unit[1] = GetCommonUnit(aProperty, pair1->mYValue.GetUnit(),
53925:                               pair2->mYValue.GetUnit());
59721:       if (unit[0] == eCSSUnit_Null || unit[1] == eCSSUnit_Null ||
59721:           unit[0] == eCSSUnit_URL) {
34265:         return PR_FALSE;
34265:       }
34265: 
34265:       nsAutoPtr<nsCSSValuePair> result(new nsCSSValuePair);
53925:       static nsCSSValue nsCSSValuePair::* const pairValues[2] = {
34265:         &nsCSSValuePair::mXValue, &nsCSSValuePair::mYValue
34265:       };
69568:       PRUint32 restrictions = nsCSSProps::ValueRestrictions(aProperty);
53925:       for (PRUint32 i = 0; i < 2; ++i) {
34265:         nsCSSValue nsCSSValuePair::*member = pairValues[i];
53925:         switch (unit[i]) {
34265:           case eCSSUnit_Pixel:
47189:             AddCSSValuePixel(aCoeff1, pair1->*member, aCoeff2, pair2->*member,
69568:                              result->*member, restrictions);
34265:             break;
34265:           case eCSSUnit_Percent:
47189:             AddCSSValuePercent(aCoeff1, pair1->*member,
47189:                                aCoeff2, pair2->*member,
69568:                                result->*member, restrictions);
34265:             break;
53925:           case eCSSUnit_Calc:
53925:             AddCSSValueCanonicalCalc(aCoeff1, pair1->*member,
53925:                                      aCoeff2, pair2->*member,
53925:                                      result->*member);
53925:             break;
34265:           default:
34265:             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
34265:             return PR_FALSE;
34265:         }
34265:       }
34265: 
34266:       aResultValue.SetAndAdoptCSSValuePairValue(result.forget(),
34266:                                                 eUnit_CSSValuePair);
50938:       return PR_TRUE;
34265:     }
74756:     case eUnit_CSSValueTriplet: {
74756:       nsCSSValueTriplet triplet1(*aValue1.GetCSSValueTripletValue());
74756:       nsCSSValueTriplet triplet2(*aValue2.GetCSSValueTripletValue());
74756: 
74756:       if (triplet1.mZValue.GetUnit() == eCSSUnit_Null) {
74756:         triplet1.mZValue.SetFloatValue(0.0, eCSSUnit_Pixel);
74756:       }
74756:       if (triplet2.mZValue.GetUnit() == eCSSUnit_Null) {
74756:           triplet2.mZValue.SetFloatValue(0.0, eCSSUnit_Pixel);
74756:       }
74756: 
74756:       nsCSSUnit unit[3];
74756:       unit[0] = GetCommonUnit(aProperty, triplet1.mXValue.GetUnit(),
74756:                               triplet2.mXValue.GetUnit());
74756:       unit[1] = GetCommonUnit(aProperty, triplet1.mYValue.GetUnit(),
74756:                                triplet2.mYValue.GetUnit());
74756:       unit[2] = GetCommonUnit(aProperty, triplet1.mZValue.GetUnit(),
74756:                               triplet2.mZValue.GetUnit());
74756:       if (unit[0] == eCSSUnit_Null || unit[1] == eCSSUnit_Null ||
74756:           unit[0] == eCSSUnit_Null || unit[0] == eCSSUnit_URL) {
74756:         return PR_FALSE;
74756:       }
74756: 
74756:       nsAutoPtr<nsCSSValueTriplet> result(new nsCSSValueTriplet);
74756:       static nsCSSValue nsCSSValueTriplet::* const tripletValues[3] = {
74756:         &nsCSSValueTriplet::mXValue, &nsCSSValueTriplet::mYValue, &nsCSSValueTriplet::mZValue
74756:       };
74756:       PRUint32 restrictions = nsCSSProps::ValueRestrictions(aProperty);
74756:       for (PRUint32 i = 0; i < 3; ++i) {
74756:         nsCSSValue nsCSSValueTriplet::*member = tripletValues[i];
74756:         switch (unit[i]) {
74756:           case eCSSUnit_Pixel:
74756:             AddCSSValuePixel(aCoeff1, &triplet1->*member, aCoeff2, &triplet2->*member,
74756:                              result->*member, restrictions);
74756:             break;
74756:           case eCSSUnit_Percent:
74756:             AddCSSValuePercent(aCoeff1, &triplet1->*member,
74756:                                aCoeff2, &triplet2->*member,
74756:                                result->*member, restrictions);
74756:             break;
74756:           case eCSSUnit_Calc:
74756:             AddCSSValueCanonicalCalc(aCoeff1, &triplet1->*member,
74756:                                      aCoeff2, &triplet2->*member,
74756:                                      result->*member);
74756:             break;
74756:           default:
74756:             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
74756:             return PR_FALSE;
74756:         }
74756:       }
74756: 
74756:       if (result->mZValue.GetUnit() == eCSSUnit_Pixel &&
74756:           result->mZValue.GetFloatValue() == 0.0f) {
74756:         result->mZValue.Reset();
74756:       }
74756: 
74756:       aResultValue.SetAndAdoptCSSValueTripletValue(result.forget(),
74756:                                                    eUnit_CSSValueTriplet);
74756:       return PR_TRUE;
74756:     }
36525:     case eUnit_CSSRect: {
69568:       NS_ABORT_IF_FALSE(nsCSSProps::ValueRestrictions(aProperty) == 0,
69568:                         "must add code for handling value restrictions");
36525:       const nsCSSRect *rect1 = aValue1.GetCSSRectValue();
36525:       const nsCSSRect *rect2 = aValue2.GetCSSRectValue();
36525:       if (rect1->mTop.GetUnit() != rect2->mTop.GetUnit() ||
36525:           rect1->mRight.GetUnit() != rect2->mRight.GetUnit() ||
36525:           rect1->mBottom.GetUnit() != rect2->mBottom.GetUnit() ||
36525:           rect1->mLeft.GetUnit() != rect2->mLeft.GetUnit()) {
36525:         // At least until we have calc()
36525:         return PR_FALSE;
36525:       }
36525: 
36525:       nsAutoPtr<nsCSSRect> result(new nsCSSRect);
36525:       for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(nsCSSRect::sides); ++i) {
36525:         nsCSSValue nsCSSRect::*member = nsCSSRect::sides[i];
36525:         NS_ABORT_IF_FALSE((rect1->*member).GetUnit() ==
36525:                             (rect2->*member).GetUnit(),
36525:                           "should have returned above");
36525:         switch ((rect1->*member).GetUnit()) {
36525:           case eCSSUnit_Pixel:
47189:             AddCSSValuePixel(aCoeff1, rect1->*member, aCoeff2, rect2->*member,
47189:                              result->*member);
36525:             break;
36525:           case eCSSUnit_Auto:
36525:             if (float(aCoeff1 + aCoeff2) != 1.0f) {
36525:               // Interpolating between two auto values makes sense;
36525:               // adding in other ratios does not.
36525:               return PR_FALSE;
36525:             }
36525:             (result->*member).SetAutoValue();
36525:             break;
36525:           default:
36525:             NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
36525:             return PR_FALSE;
36525:         }
36525:       }
36525: 
36525:       aResultValue.SetAndAdoptCSSRectValue(result.forget(), eUnit_CSSRect);
50938:       return PR_TRUE;
36525:     }
34064:     case eUnit_Dasharray: {
34064:       const nsCSSValueList *list1 = aValue1.GetCSSValueListValue();
34064:       const nsCSSValueList *list2 = aValue2.GetCSSValueListValue();
34064: 
34064:       PRUint32 len1 = 0, len2 = 0;
34064:       for (const nsCSSValueList *v = list1; v; v = v->mNext) {
34064:         ++len1;
34064:       }
34064:       for (const nsCSSValueList *v = list2; v; v = v->mNext) {
34064:         ++len2;
34064:       }
34064:       NS_ABORT_IF_FALSE(len1 > 0 && len2 > 0, "unexpected length");
35513:       if (list1->mValue.GetUnit() == eCSSUnit_None ||
35513:           list2->mValue.GetUnit() == eCSSUnit_None) {
35513:         // One of our values is "none".  Can't do addition with that.
35513:         NS_ABORT_IF_FALSE(
35513:           (list1->mValue.GetUnit() != eCSSUnit_None || len1 == 1) &&
35513:           (list2->mValue.GetUnit() != eCSSUnit_None || len2 == 1),
35513:           "multi-value valuelist with 'none' as first element");
35513:         return PR_FALSE;
35513:       }
34064: 
34064:       nsAutoPtr<nsCSSValueList> result;
34064:       nsCSSValueList **resultTail = getter_Transfers(result);
34064:       for (PRUint32 i = 0, i_end = lcm(len1, len2); i != i_end; ++i) {
34064:         const nsCSSValue &v1 = list1->mValue;
34064:         const nsCSSValue &v2 = list2->mValue;
34064:         NS_ABORT_IF_FALSE(v1.GetUnit() == eCSSUnit_Number ||
34064:                           v1.GetUnit() == eCSSUnit_Percent, "unexpected");
34064:         NS_ABORT_IF_FALSE(v2.GetUnit() == eCSSUnit_Number ||
34064:                           v2.GetUnit() == eCSSUnit_Percent, "unexpected");
34064:         if (v1.GetUnit() != v2.GetUnit()) {
34064:           // Can't animate between lengths and percentages (until calc()).
34064:           return PR_FALSE;
34064:         }
34064: 
34064:         nsCSSValueList *item = new nsCSSValueList;
34064:         if (!item) {
34064:           return PR_FALSE;
34064:         }
34064:         *resultTail = item;
34064:         resultTail = &item->mNext;
34064: 
34064:         if (v1.GetUnit() == eCSSUnit_Number) {
69568:           AddCSSValueNumber(aCoeff1, v1, aCoeff2, v2, item->mValue,
69568:                             CSS_PROPERTY_VALUE_NONNEGATIVE);
34064:         } else {
69568:           AddCSSValuePercent(aCoeff1, v1, aCoeff2, v2, item->mValue,
69568:                              CSS_PROPERTY_VALUE_NONNEGATIVE);
34064:         }
34064: 
34064:         list1 = list1->mNext;
34064:         if (!list1) {
34064:           list1 = aValue1.GetCSSValueListValue();
34064:         }
34064:         list2 = list2->mNext;
34064:         if (!list2) {
34064:           list2 = aValue2.GetCSSValueListValue();
34064:         }
34064:       }
34064: 
34266:       aResultValue.SetAndAdoptCSSValueListValue(result.forget(),
34266:                                                 eUnit_Dasharray);
50938:       return PR_TRUE;
34064:     }
34062:     case eUnit_Shadow: {
34062:       // This is implemented according to:
34062:       // http://dev.w3.org/csswg/css3-transitions/#animation-of-property-types-
34062:       // and the third item in the summary of:
34062:       // http://lists.w3.org/Archives/Public/www-style/2009Jul/0050.html
34062:       const nsCSSValueList *shadow1 = aValue1.GetCSSValueListValue();
34062:       const nsCSSValueList *shadow2 = aValue2.GetCSSValueListValue();
34062:       nsAutoPtr<nsCSSValueList> result;
34062:       nsCSSValueList **resultTail = getter_Transfers(result);
34062:       while (shadow1 && shadow2) {
34062:         if (!AddShadowItems(aCoeff1, shadow1->mValue,
34062:                             aCoeff2, shadow2->mValue,
34062:                             resultTail)) {
34062:           return PR_FALSE;
34062:         }
34062:         shadow1 = shadow1->mNext;
34062:         shadow2 = shadow2->mNext;
34062:       }
34062:       if (shadow1 || shadow2) {
34062:         const nsCSSValueList *longShadow;
34062:         double longCoeff;
34062:         if (shadow1) {
34062:           longShadow = shadow1;
34062:           longCoeff = aCoeff1;
34062:         } else {
34062:           longShadow = shadow2;
34062:           longCoeff = aCoeff2;
34062:         }
34062: 
34062:         while (longShadow) {
34062:           // Passing coefficients that add to less than 1 produces the
34062:           // desired result of interpolating "0 0 0 transparent" with
34062:           // the current shadow.
34062:           if (!AddShadowItems(longCoeff, longShadow->mValue,
34062:                               0.0, longShadow->mValue,
34062:                               resultTail)) {
34062:             return PR_FALSE;
34062:           }
34062: 
34062:           longShadow = longShadow->mNext;
34062:         }
34062:       }
34266:       aResultValue.SetAndAdoptCSSValueListValue(result.forget(), eUnit_Shadow);
50938:       return PR_TRUE;
34062:     }
47195:     case eUnit_Transform: {
47195:       const nsCSSValueList *list1 = aValue1.GetCSSValueListValue();
47195:       const nsCSSValueList *list2 = aValue2.GetCSSValueListValue();
47195: 
47195:       // We want to avoid the matrix decomposition when we can, since
47195:       // avoiding it can produce better results both for compound
47195:       // transforms and for skew and skewY (see below).  We can do this
47195:       // in two cases:
47195:       //   (1) if one of the transforms is 'none'
47195:       //   (2) if the lists have the same length and the transform
47195:       //       functions match
47195:       nsAutoPtr<nsCSSValueList> result;
47195:       if (list1->mValue.GetUnit() == eCSSUnit_None) {
47195:         if (list2->mValue.GetUnit() == eCSSUnit_None) {
47195:           result = new nsCSSValueList;
47195:           if (result) {
47195:             result->mValue.SetNoneValue();
47195:           }
47195:         } else {
47195:           result = AddTransformLists(list2, aCoeff2, list2, 0);
47195:         }
47195:       } else {
47195:         if (list2->mValue.GetUnit() == eCSSUnit_None) {
47195:           result = AddTransformLists(list1, aCoeff1, list1, 0);
47195:         } else {
47195:           PRBool match = PR_TRUE;
47195: 
47195:           {
47195:             const nsCSSValueList *item1 = list1, *item2 = list2;
47195:             do {
47195:               nsCSSKeyword func1 = nsStyleTransformMatrix::TransformFunctionOf(
47195:                                      item1->mValue.GetArrayValue());
47195:               nsCSSKeyword func2 = nsStyleTransformMatrix::TransformFunctionOf(
47195:                                      item2->mValue.GetArrayValue());
47195:               if (func1 != func2) {
47195:                 break;
47195:               }
47195: 
47195:               item1 = item1->mNext;
47195:               item2 = item2->mNext;
47195:             } while (item1 && item2);
47195:             if (item1 || item2) {
47195:               // Either |break| above or length mismatch.
47195:               match = PR_FALSE;
47195:             }
47195:           }
47195: 
47195:           if (match) {
47195:             result = AddTransformLists(list1, aCoeff1, list2, aCoeff2);
47195:           } else {
74281:             result = AddDifferentTransformLists(list1, aCoeff1, list2, aCoeff2);
47195:           }
47195:         }
47195:       }
47195: 
47195:       aResultValue.SetAndAdoptCSSValueListValue(result.forget(),
47195:                                                 eUnit_Transform);
47195:       return PR_TRUE;
47195:     }
36527:     case eUnit_CSSValuePairList: {
36527:       const nsCSSValuePairList *list1 = aValue1.GetCSSValuePairListValue();
36527:       const nsCSSValuePairList *list2 = aValue2.GetCSSValuePairListValue();
36527:       nsAutoPtr<nsCSSValuePairList> result;
36527:       nsCSSValuePairList **resultTail = getter_Transfers(result);
36527:       do {
36527:         nsCSSValuePairList *item = new nsCSSValuePairList;
36527:         if (!item) {
50938:           return PR_FALSE;
36527:         }
36527:         *resultTail = item;
36527:         resultTail = &item->mNext;
36527: 
36527:         static nsCSSValue nsCSSValuePairList::* const pairListValues[] = {
36527:           &nsCSSValuePairList::mXValue,
36527:           &nsCSSValuePairList::mYValue,
36527:         };
69568:         PRUint32 restrictions = nsCSSProps::ValueRestrictions(aProperty);
36527:         for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(pairListValues); ++i) {
36527:           const nsCSSValue &v1 = list1->*(pairListValues[i]);
36527:           const nsCSSValue &v2 = list2->*(pairListValues[i]);
36527:           nsCSSValue &vr = item->*(pairListValues[i]);
53925:           nsCSSUnit unit =
53925:             GetCommonUnit(aProperty, v1.GetUnit(), v2.GetUnit());
53925:           if (unit == eCSSUnit_Null) {
50938:             return PR_FALSE;
36527:           }
53925:           switch (unit) {
36527:             case eCSSUnit_Pixel:
69568:               AddCSSValuePixel(aCoeff1, v1, aCoeff2, v2, vr, restrictions);
36527:               break;
36527:             case eCSSUnit_Percent:
69568:               AddCSSValuePercent(aCoeff1, v1, aCoeff2, v2, vr, restrictions);
36527:               break;
53925:             case eCSSUnit_Calc:
53925:               AddCSSValueCanonicalCalc(aCoeff1, v1, aCoeff2, v2, vr);
53925:               break;
36527:             default:
50938:               if (v1 != v2) {
50938:                 return PR_FALSE;
50938:               }
36527:               vr = v1;
36527:               break;
36527:           }
36527:         }
36527:         list1 = list1->mNext;
36527:         list2 = list2->mNext;
36527:       } while (list1 && list2);
36527:       if (list1 || list2) {
50938:         // We can't interpolate lists of different lengths.
50938:         return PR_FALSE;
50938:       }
50938: 
36527:       aResultValue.SetAndAdoptCSSValuePairListValue(result.forget());
50938:       return PR_TRUE;
36527:     }
36527:   }
50938: 
50938:   NS_ABORT_IF_FALSE(false, "Can't interpolate using the given common unit");
50938:   return PR_FALSE;
32367: }
32367: 
63693: already_AddRefed<css::StyleRule>
32367: BuildStyleRule(nsCSSProperty aProperty,
64095:                dom::Element* aTargetElement,
40150:                const nsAString& aSpecifiedValue,
40150:                PRBool aUseSVGMode)
32367: {
32367:   // Set up an empty CSS Declaration
48864:   nsAutoPtr<css::Declaration> declaration(new css::Declaration());
48857:   declaration->InitializeEmpty();
32367: 
32367:   PRBool changed; // ignored, but needed as outparam for ParseProperty
32367:   nsIDocument* doc = aTargetElement->GetOwnerDoc();
32367:   nsCOMPtr<nsIURI> baseURI = aTargetElement->GetBaseURI();
38849:   nsCSSParser parser(doc->CSSLoader());
32367: 
40150:   if (aUseSVGMode) {
40150:     parser.SetSVGMode(PR_TRUE);
40150:   }
40150: 
35519:   nsCSSProperty propertyToCheck = nsCSSProps::IsShorthand(aProperty) ?
35519:     nsCSSProps::SubpropertyEntryFor(aProperty)[0] : aProperty;
35519: 
48857:   // Get a parser, parse the property, and check for CSS parsing errors.
48857:   // If any of these steps fails, we bail out and delete the declaration.
68767:   if (NS_FAILED(parser.ParseProperty(aProperty, aSpecifiedValue,
32367:                                      doc->GetDocumentURI(), baseURI,
32367:                                      aTargetElement->NodePrincipal(),
40135:                                      declaration, &changed, PR_FALSE)) ||
35575:       // check whether property parsed without CSS parsing errors
48857:       !declaration->HasNonImportantValueFor(propertyToCheck)) {
32367:     NS_WARNING("failure in BuildStyleRule");
32367:     return nsnull;
32367:   }
32367: 
64685:   nsRefPtr<css::StyleRule> rule = new css::StyleRule(nsnull, declaration.forget());
64685:   return rule.forget();
32367: }
32367: 
32367: inline
32367: already_AddRefed<nsStyleContext>
64095: LookupStyleContext(dom::Element* aElement)
32367: {
32367:   nsIDocument* doc = aElement->GetCurrentDoc();
46225:   nsIPresShell* shell = doc->GetShell();
32367:   if (!shell) {
32367:     return nsnull;
32367:   }
64095:   return nsComputedDOMStyle::GetStyleContextForElement(aElement, nsnull, shell);
32367: }
32367: 
35512: 
35512: /**
35512:  * Helper function: StyleWithDeclarationAdded
35512:  * Creates a nsStyleRule with the specified property set to the specified
35512:  * value, and returns a nsStyleContext for this rule, as a sibling of the
35512:  * given element's nsStyleContext.
35512:  *
35512:  * If we fail to parse |aSpecifiedValue| for |aProperty|, this method will
35512:  * return nsnull.
35512:  *
35512:  * @param aProperty       The property whose value we're customizing in the
35512:  *                        custom style context.
35512:  * @param aTargetElement  The element whose style context we'll use as a
35512:  *                        sibling for our custom style context.
35512:  * @param aSpecifiedValue The value for |aProperty| in our custom style
35512:  *                        context.
40150:  * @param aUseSVGMode     A flag to indicate whether we should parse
40150:  *                        |aSpecifiedValue| in SVG mode.
35512:  * @return The generated custom nsStyleContext, or nsnull on failure.
35512:  */
35512: already_AddRefed<nsStyleContext>
35512: StyleWithDeclarationAdded(nsCSSProperty aProperty,
64095:                           dom::Element* aTargetElement,
40150:                           const nsAString& aSpecifiedValue,
40150:                           PRBool aUseSVGMode)
35512: {
35512:   NS_ABORT_IF_FALSE(aTargetElement, "null target element");
35512:   NS_ABORT_IF_FALSE(aTargetElement->GetCurrentDoc(),
35512:                     "element needs to be in a document "
35512:                     "if we're going to look up its style context");
35512: 
35512:   // Look up style context for our target element
35512:   nsRefPtr<nsStyleContext> styleContext = LookupStyleContext(aTargetElement);
35512:   if (!styleContext) {
35512:     return nsnull;
35512:   }
35512: 
63693:   // Parse specified value into a temporary StyleRule
63693:   nsRefPtr<css::StyleRule> styleRule =
40150:     BuildStyleRule(aProperty, aTargetElement, aSpecifiedValue, aUseSVGMode);
35512:   if (!styleRule) {
35512:     return nsnull;
35512:   }
35512: 
35577:   styleRule->RuleMatched();
35577: 
35512:   // Create a temporary nsStyleContext for the style rule
35512:   nsCOMArray<nsIStyleRule> ruleArray;
35512:   ruleArray.AppendObject(styleRule);
35512:   nsStyleSet* styleSet = styleContext->PresContext()->StyleSet();
40171:   return styleSet->ResolveStyleByAddingRules(styleContext, ruleArray);
35512: }
35512: 
32367: PRBool
32367: nsStyleAnimation::ComputeValue(nsCSSProperty aProperty,
64095:                                dom::Element* aTargetElement,
32367:                                const nsAString& aSpecifiedValue,
40150:                                PRBool aUseSVGMode,
34029:                                Value& aComputedValue)
32367: {
32367:   NS_ABORT_IF_FALSE(aTargetElement, "null target element");
32367:   NS_ABORT_IF_FALSE(aTargetElement->GetCurrentDoc(),
32367:                     "we should only be able to actively animate nodes that "
32367:                     "are in a document");
32367: 
56404:   nsCSSProperty propToParse =
56404:     nsCSSProps::PropHasFlags(aProperty, CSS_PROPERTY_REPORT_OTHER_NAME)
56404:       ? nsCSSProps::OtherNameFor(aProperty) : aProperty;
56404: 
35512:   nsRefPtr<nsStyleContext> tmpStyleContext =
56404:     StyleWithDeclarationAdded(propToParse, aTargetElement,
40150:                               aSpecifiedValue, aUseSVGMode);
35512:   if (!tmpStyleContext) {
32367:     return PR_FALSE;
32367:   }
32367: 
35519:  if (nsCSSProps::IsShorthand(aProperty) ||
35519:      nsCSSProps::kAnimTypeTable[aProperty] == eStyleAnimType_None) {
35515:     // Just capture the specified value
35515:     aComputedValue.SetUnparsedStringValue(nsString(aSpecifiedValue));
35515:     return PR_TRUE;
35515:   }
32367:   // Extract computed value of our property from the temporary style rule
32367:   return ExtractComputedValue(aProperty, tmpStyleContext, aComputedValue);
32367: }
32367: 
32413: PRBool
32413: nsStyleAnimation::UncomputeValue(nsCSSProperty aProperty,
32413:                                  nsPresContext* aPresContext,
34029:                                  const Value& aComputedValue,
50932:                                  nsCSSValue& aSpecifiedValue)
33650: {
33650:   NS_ABORT_IF_FALSE(aPresContext, "null pres context");
33650: 
33650:   switch (aComputedValue.GetUnit()) {
35658:     case eUnit_Normal:
50932:       aSpecifiedValue.SetNormalValue();
35658:       break;
35658:     case eUnit_Auto:
50932:       aSpecifiedValue.SetAutoValue();
35658:       break;
34029:     case eUnit_None:
50932:       aSpecifiedValue.SetNoneValue();
33650:       break;
34083:     case eUnit_Enumerated:
36526:     case eUnit_Visibility:
50932:       aSpecifiedValue.
34083:         SetIntValue(aComputedValue.GetIntValue(), eCSSUnit_Enumerated);
34083:       break;
34812:     case eUnit_Integer:
50932:       aSpecifiedValue.
34812:         SetIntValue(aComputedValue.GetIntValue(), eCSSUnit_Integer);
34812:       break;
50932:     case eUnit_Coord:
50932:       nscoordToCSSValue(aComputedValue.GetCoordValue(), aSpecifiedValue);
33650:       break;
34029:     case eUnit_Percent:
50932:       aSpecifiedValue.SetPercentValue(aComputedValue.GetPercentValue());
33650:       break;
34029:     case eUnit_Float:
50932:       aSpecifiedValue.
34029:         SetFloatValue(aComputedValue.GetFloatValue(), eCSSUnit_Number);
33689:       break;
34029:     case eUnit_Color:
33650:       // colors can be alone, or part of a paint server
50932:       aSpecifiedValue.SetColorValue(aComputedValue.GetColorValue());
50928:       break;
53921:     case eUnit_Calc: {
53921:       nsCSSValue *val = aComputedValue.GetCSSValueValue();
53921:       NS_ABORT_IF_FALSE(val->GetUnit() == eCSSUnit_Calc, "unexpected unit");
53921:       aSpecifiedValue = *val;
53921:       break;
53921:     }
50928:     case eUnit_CSSValuePair: {
50928:       // Rule node processing expects pair values to be collapsed to a
50928:       // single value if both halves would be equal, for most but not
50928:       // all properties.  At present, all animatable properties that
50928:       // use pairs do expect collapsing.
50928:       const nsCSSValuePair* pair = aComputedValue.GetCSSValuePairValue();
50928:       if (pair->mXValue == pair->mYValue) {
50932:         aSpecifiedValue = pair->mXValue;
50928:       } else {
50932:         aSpecifiedValue.SetPairValue(pair);
33650:       }
50928:     } break;
74756:     case eUnit_CSSValueTriplet: {
74756:       // Rule node processing expects triplet values to be collapsed to a
74756:       // single value if both halves would be equal, for most but not
74756:       // all properties.  At present, all animatable properties that
74756:       // use pairs do expect collapsing.
74756:       const nsCSSValueTriplet* triplet = aComputedValue.GetCSSValueTripletValue();
74756:       if (triplet->mXValue == triplet->mYValue && triplet->mYValue == triplet->mZValue) {
74756:         aSpecifiedValue = triplet->mXValue;
74756:       } else {
74756:         aSpecifiedValue.SetTripletValue(triplet);
74756:       }
74756:     } break;
50929:     case eUnit_CSSRect: {
50932:       nsCSSRect& rect = aSpecifiedValue.SetRectValue();
50929:       rect = *aComputedValue.GetCSSRectValue();
50929:     } break;
34064:     case eUnit_Dasharray:
34062:     case eUnit_Shadow:
47195:     case eUnit_Transform:
50932:       aSpecifiedValue.
50931:         SetDependentListValue(aComputedValue.GetCSSValueListValue());
34062:       break;
36527:     case eUnit_CSSValuePairList:
50932:       aSpecifiedValue.
50930:         SetDependentPairListValue(aComputedValue.GetCSSValuePairListValue());
36527:       break;
33650:     default:
33650:       return PR_FALSE;
33650:   }
33650:   return PR_TRUE;
33650: }
33650: 
33650: PRBool
33650: nsStyleAnimation::UncomputeValue(nsCSSProperty aProperty,
33650:                                  nsPresContext* aPresContext,
34029:                                  const Value& aComputedValue,
32413:                                  nsAString& aSpecifiedValue)
32413: {
32413:   NS_ABORT_IF_FALSE(aPresContext, "null pres context");
32413:   aSpecifiedValue.Truncate(); // Clear outparam, if it's not already empty
32413: 
35515:   if (aComputedValue.GetUnit() == eUnit_UnparsedString) {
35515:     aComputedValue.GetStringValue(aSpecifiedValue);
35515:     return PR_TRUE;
35515:   }
50928:   nsCSSValue val;
33650:   if (!nsStyleAnimation::UncomputeValue(aProperty, aPresContext,
50932:                                         aComputedValue, val)) {
32413:     return PR_FALSE;
32413:   }
48855: 
50928:   val.AppendToString(aProperty, aSpecifiedValue);
48855:   return PR_TRUE;
32413: }
32413: 
32396: inline const void*
32396: StyleDataAtOffset(const void* aStyleStruct, ptrdiff_t aOffset)
32396: {
32396:   return reinterpret_cast<const char*>(aStyleStruct) + aOffset;
32396: }
32396: 
32396: inline void*
32396: StyleDataAtOffset(void* aStyleStruct, ptrdiff_t aOffset)
32396: {
32396:   return reinterpret_cast<char*>(aStyleStruct) + aOffset;
32396: }
32396: 
33817: static void
33817: ExtractBorderColor(nsStyleContext* aStyleContext, const void* aStyleBorder,
41419:                    mozilla::css::Side aSide, nsStyleAnimation::Value& aComputedValue)
33817: {
33817:   nscolor color;
33817:   PRBool foreground;
33817:   static_cast<const nsStyleBorder*>(aStyleBorder)->
33817:     GetBorderColor(aSide, color, foreground);
33817:   if (foreground) {
33817:     // FIXME: should add test for this
33817:     color = aStyleContext->GetStyleColor()->mColor;
33817:   }
33817:   aComputedValue.SetColorValue(color);
33817: }
33817: 
34029: static PRBool
34029: StyleCoordToValue(const nsStyleCoord& aCoord, nsStyleAnimation::Value& aValue)
34029: {
34029:   switch (aCoord.GetUnit()) {
34029:     case eStyleUnit_Normal:
34029:       aValue.SetNormalValue();
34029:       break;
34029:     case eStyleUnit_Auto:
34029:       aValue.SetAutoValue();
34029:       break;
34029:     case eStyleUnit_None:
34029:       aValue.SetNoneValue();
34029:       break;
34029:     case eStyleUnit_Percent:
34029:       aValue.SetPercentValue(aCoord.GetPercentValue());
34029:       break;
34029:     case eStyleUnit_Factor:
34029:       aValue.SetFloatValue(aCoord.GetFactorValue());
34029:       break;
34029:     case eStyleUnit_Coord:
34029:       aValue.SetCoordValue(aCoord.GetCoordValue());
34029:       break;
34083:     case eStyleUnit_Enumerated:
34083:       aValue.SetIntValue(aCoord.GetIntValue(),
34083:                          nsStyleAnimation::eUnit_Enumerated);
34812:       break;
34029:     case eStyleUnit_Integer:
34812:       aValue.SetIntValue(aCoord.GetIntValue(),
34812:                          nsStyleAnimation::eUnit_Integer);
34812:       break;
53922:     case eStyleUnit_Calc: {
53922:       nsAutoPtr<nsCSSValue> val(new nsCSSValue);
53927:       SetCalcValue(aCoord.GetCalcValue(), *val);
53922:       aValue.SetAndAdoptCSSValueValue(val.forget(),
53922:                                       nsStyleAnimation::eUnit_Calc);
53922:       break;
53922:     }
35509:     default:
35509:       return PR_FALSE;
34029:   }
34029:   return PR_TRUE;
34029: }
34029: 
53925: static PRBool
34265: StyleCoordToCSSValue(const nsStyleCoord& aCoord, nsCSSValue& aCSSValue)
34265: {
34265:   switch (aCoord.GetUnit()) {
34265:     case eStyleUnit_Coord:
36525:       nscoordToCSSValue(aCoord.GetCoordValue(), aCSSValue);
34265:       break;
34265:     case eStyleUnit_Percent:
34265:       aCSSValue.SetPercentValue(aCoord.GetPercentValue());
34265:       break;
53925:     case eStyleUnit_Calc:
53927:       SetCalcValue(aCoord.GetCalcValue(), aCSSValue);
53925:       break;
34265:     default:
34265:       NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
53925:       return PR_FALSE;
34265:   }
53925:   return PR_TRUE;
34265: }
34265: 
47195: /*
47195:  * Assign |aOutput = aInput|, except with any non-pixel lengths
56403:  * replaced with the equivalent in pixels, and any non-canonical calc()
56403:  * expressions replaced with canonical ones.
47195:  */
47195: static void
47195: SubstitutePixelValues(nsStyleContext* aStyleContext,
47195:                       const nsCSSValue& aInput, nsCSSValue& aOutput)
47195: {
56403:   if (aInput.IsCalcUnit()) {
56403:     PRBool canStoreInRuleTree = PR_TRUE;
56403:     nsRuleNode::ComputedCalc c =
56403:       nsRuleNode::SpecifiedCalcToComputedCalc(aInput, aStyleContext,
56403:                                               aStyleContext->PresContext(),
56403:                                               canStoreInRuleTree);
56403:     nsStyleCoord::Calc c2;
56403:     c2.mLength = c.mLength;
56403:     c2.mPercent = c.mPercent;
56403:     c2.mHasPercent = PR_TRUE; // doesn't matter for transform translate
56403:     SetCalcValue(&c2, aOutput);
56403:   } else if (aInput.UnitHasArrayValue()) {
47195:     const nsCSSValue::Array *inputArray = aInput.GetArrayValue();
47195:     nsRefPtr<nsCSSValue::Array> outputArray =
47195:       nsCSSValue::Array::Create(inputArray->Count());
47195:     for (size_t i = 0, i_end = inputArray->Count(); i < i_end; ++i) {
47195:       SubstitutePixelValues(aStyleContext,
47195:                             inputArray->Item(i), outputArray->Item(i));
47195:     }
47195:     aOutput.SetArrayValue(outputArray, aInput.GetUnit());
47195:   } else if (aInput.IsLengthUnit() &&
47195:              aInput.GetUnit() != eCSSUnit_Pixel) {
47195:     PRBool canStoreInRuleTree = PR_TRUE;
47195:     nscoord len = nsRuleNode::CalcLength(aInput, aStyleContext,
47195:                                          aStyleContext->PresContext(),
47195:                                          canStoreInRuleTree);
47195:     aOutput.SetFloatValue(nsPresContext::AppUnitsToFloatCSSPixels(len),
47195:                           eCSSUnit_Pixel);
47195:   } else {
47195:     aOutput = aInput;
47195:   }
47195: }
47195: 
32367: PRBool
32367: nsStyleAnimation::ExtractComputedValue(nsCSSProperty aProperty,
32367:                                        nsStyleContext* aStyleContext,
34029:                                        Value& aComputedValue)
32367: {
32396:   NS_ABORT_IF_FALSE(0 <= aProperty &&
32396:                     aProperty < eCSSProperty_COUNT_no_shorthands,
32396:                     "bad property");
32396:   const void* styleStruct =
32396:     aStyleContext->GetStyleData(nsCSSProps::kSIDTable[aProperty]);
32396:   ptrdiff_t ssOffset = nsCSSProps::kStyleStructOffsetTable[aProperty];
32396:   nsStyleAnimType animType = nsCSSProps::kAnimTypeTable[aProperty];
33817:   NS_ABORT_IF_FALSE(0 <= ssOffset || animType == eStyleAnimType_Custom,
33817:                     "must be dealing with animatable property");
32396:   switch (animType) {
33817:     case eStyleAnimType_Custom:
33817:       switch (aProperty) {
33817:         // For border-width, ignore the border-image business (which
33817:         // only exists until we update our implementation to the current
33817:         // spec) and use GetComputedBorder
33817: 
33817:         #define BORDER_WIDTH_CASE(prop_, side_)                               \
33817:         case prop_:                                                           \
33817:           aComputedValue.SetCoordValue(                                       \
33817:             static_cast<const nsStyleBorder*>(styleStruct)->                  \
33817:               GetComputedBorder().side_);                                     \
33817:           break;
33817:         BORDER_WIDTH_CASE(eCSSProperty_border_bottom_width, bottom)
33817:         BORDER_WIDTH_CASE(eCSSProperty_border_left_width_value, left)
33817:         BORDER_WIDTH_CASE(eCSSProperty_border_right_width_value, right)
33817:         BORDER_WIDTH_CASE(eCSSProperty_border_top_width, top)
33817:         #undef BORDER_WIDTH_CASE
33817: 
35569:         case eCSSProperty__moz_column_rule_width:
35569:           aComputedValue.SetCoordValue(
35569:             static_cast<const nsStyleColumn*>(styleStruct)->
35569:               GetComputedColumnRuleWidth());
35569:           break;
35569: 
33817:         case eCSSProperty_border_bottom_color:
33817:           ExtractBorderColor(aStyleContext, styleStruct, NS_SIDE_BOTTOM,
33817:                              aComputedValue);
33817:           break;
33817:         case eCSSProperty_border_left_color_value:
33817:           ExtractBorderColor(aStyleContext, styleStruct, NS_SIDE_LEFT,
33817:                              aComputedValue);
33817:           break;
33817:         case eCSSProperty_border_right_color_value:
33817:           ExtractBorderColor(aStyleContext, styleStruct, NS_SIDE_RIGHT,
33817:                              aComputedValue);
33817:           break;
33817:         case eCSSProperty_border_top_color:
33817:           ExtractBorderColor(aStyleContext, styleStruct, NS_SIDE_TOP,
33817:                              aComputedValue);
33817:           break;
33817: 
33817:         case eCSSProperty_outline_color: {
33817:           const nsStyleOutline *styleOutline =
33817:             static_cast<const nsStyleOutline*>(styleStruct);
33817:           nscolor color;
33817:         #ifdef GFX_HAS_INVERT
40182:           // This isn't right.  And note that outline drawing itself
40182:           // goes through this codepath via GetVisitedDependentColor.
33817:           styleOutline->GetOutlineColor(color);
33817:         #else
33817:           if (!styleOutline->GetOutlineColor(color))
33817:             color = aStyleContext->GetStyleColor()->mColor;
33817:         #endif
33817:           aComputedValue.SetColorValue(color);
33817:           break;
33817:         }
33817: 
40524:         case eCSSProperty__moz_column_rule_color: {
40524:           const nsStyleColumn *styleColumn =
40524:             static_cast<const nsStyleColumn*>(styleStruct);
40524:           nscolor color;
40524:           if (styleColumn->mColumnRuleColorIsForeground) {
40524:             color = aStyleContext->GetStyleColor()->mColor;
40524:           } else {
40524:             color = styleColumn->mColumnRuleColor;
40524:           }
40524:           aComputedValue.SetColorValue(color);
40524:           break;
40524:         }
40524: 
35568:         case eCSSProperty__moz_column_count: {
35568:           const nsStyleColumn *styleColumn =
35568:             static_cast<const nsStyleColumn*>(styleStruct);
35568:           if (styleColumn->mColumnCount == NS_STYLE_COLUMN_COUNT_AUTO) {
35568:             aComputedValue.SetAutoValue();
35568:           } else {
35568:             aComputedValue.SetIntValue(styleColumn->mColumnCount,
35568:                                        eUnit_Integer);
35568:           }
35568:           break;
35568:         }
35568: 
64456:         case eCSSProperty_text_decoration_color: {
64456:           const nsStyleTextReset *styleTextReset =
64456:             static_cast<const nsStyleTextReset*>(styleStruct);
64456:           nscolor color;
64456:           PRBool isForeground;
64456:           styleTextReset->GetDecorationColor(color, isForeground);
64456:           if (isForeground) {
64456:             color = aStyleContext->GetStyleColor()->mColor;
64456:           }
64456:           aComputedValue.SetColorValue(color);
64456:           break;
64456:         }
64456: 
64456:         case eCSSProperty_text_decoration_style: {
64456:           PRUint8 decorationStyle =
64456:             static_cast<const nsStyleTextReset*>(styleStruct)->
64456:               GetDecorationStyle();
64456:           aComputedValue.SetIntValue(decorationStyle, eUnit_Enumerated);
64456:           break;
64456:         }
64456: 
35570:         case eCSSProperty_border_spacing: {
35570:           const nsStyleTableBorder *styleTableBorder =
35570:             static_cast<const nsStyleTableBorder*>(styleStruct);
59083:           nsAutoPtr<nsCSSValuePair> pair(new nsCSSValuePair);
35570:           if (!pair) {
35570:             return PR_FALSE;
35570:           }
36525:           nscoordToCSSValue(styleTableBorder->mBorderSpacingX, pair->mXValue);
36525:           nscoordToCSSValue(styleTableBorder->mBorderSpacingY, pair->mYValue);
59083:           aComputedValue.SetAndAdoptCSSValuePairValue(pair.forget(),
35570:                                                       eUnit_CSSValuePair);
35570:           break;
35570:         }
35570: 
35570:         case eCSSProperty__moz_transform_origin: {
35570:           const nsStyleDisplay *styleDisplay =
35570:             static_cast<const nsStyleDisplay*>(styleStruct);
74756:           nsAutoPtr<nsCSSValueTriplet> triplet(new nsCSSValueTriplet);
74756:           if (!triplet ||
53925:               !StyleCoordToCSSValue(styleDisplay->mTransformOrigin[0],
74756:                                     triplet->mXValue) ||
53925:               !StyleCoordToCSSValue(styleDisplay->mTransformOrigin[1],
74756:                                     triplet->mYValue) ||
74756:               !StyleCoordToCSSValue(styleDisplay->mTransformOrigin[2],
74756:                                     triplet->mZValue)) {
35570:             return PR_FALSE;
35570:           }
74756:           if (triplet->mZValue.GetUnit() == eCSSUnit_Pixel &&
74756:               triplet->mZValue.GetFloatValue() == 0.0f) {
74756:             triplet->mZValue.Reset();
74756:           }
74756:           aComputedValue.SetAndAdoptCSSValueTripletValue(triplet.forget(),
74756:                                                          eUnit_CSSValueTriplet);
35570:           break;
35570:         }
35570: 
74758:         case eCSSProperty_perspective_origin: {
74758:           const nsStyleDisplay *styleDisplay =
74758:             static_cast<const nsStyleDisplay*>(styleStruct);
74758:           nsAutoPtr<nsCSSValuePair> pair(new nsCSSValuePair);
74758:           if (!pair ||
74758:               !StyleCoordToCSSValue(styleDisplay->mPerspectiveOrigin[0],
74758:                                     pair->mXValue) ||
74758:               !StyleCoordToCSSValue(styleDisplay->mPerspectiveOrigin[1],
74758:                                     pair->mYValue)) {
74758:             return PR_FALSE;
74758:           }
74758:           aComputedValue.SetAndAdoptCSSValuePairValue(pair.forget(),
74758:                                                       eUnit_CSSValuePair);
74758:           break;
74758:         }
74758: 
34064:         case eCSSProperty_stroke_dasharray: {
34064:           const nsStyleSVG *svg = static_cast<const nsStyleSVG*>(styleStruct);
34064:           NS_ABORT_IF_FALSE((svg->mStrokeDasharray != nsnull) ==
34064:                             (svg->mStrokeDasharrayLength != 0),
34064:                             "pointer/length mismatch");
35513:           nsAutoPtr<nsCSSValueList> result;
34064:           if (svg->mStrokeDasharray) {
35513:             NS_ABORT_IF_FALSE(svg->mStrokeDasharrayLength > 0,
35513:                               "non-null list should have positive length");
34064:             nsCSSValueList **resultTail = getter_Transfers(result);
34064:             for (PRUint32 i = 0, i_end = svg->mStrokeDasharrayLength;
34064:                  i != i_end; ++i) {
34064:               nsCSSValueList *item = new nsCSSValueList;
34064:               if (!item) {
34064:                 return PR_FALSE;
34064:               }
34064:               *resultTail = item;
34064:               resultTail = &item->mNext;
34064: 
34064:               const nsStyleCoord &coord = svg->mStrokeDasharray[i];
34064:               nsCSSValue &value = item->mValue;
34064:               switch (coord.GetUnit()) {
34064:                 case eStyleUnit_Coord:
34064:                   // Number means the same thing as length; we want to
34064:                   // animate them the same way.  Normalize both to number
34064:                   // since it has more accuracy (float vs nscoord).
34064:                   value.SetFloatValue(nsPresContext::
34064:                     AppUnitsToFloatCSSPixels(coord.GetCoordValue()),
34064:                     eCSSUnit_Number);
34064:                   break;
34064:                 case eStyleUnit_Factor:
34064:                   value.SetFloatValue(coord.GetFactorValue(),
34064:                                       eCSSUnit_Number);
34064:                   break;
34064:                 case eStyleUnit_Percent:
34064:                   value.SetPercentValue(coord.GetPercentValue());
34064:                   break;
34064:                 default:
34064:                   NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit");
34064:                   return PR_FALSE;
34064:               }
34064:             }
35513:           } else {
35513:             result = new nsCSSValueList;
35513:             if (!result) {
35513:               return PR_FALSE;
35513:             }
35513:             result->mValue.SetNoneValue();
35513:           }
34266:           aComputedValue.SetAndAdoptCSSValueListValue(result.forget(),
34266:                                                       eUnit_Dasharray);
34064:           break;
34064:         }
34064: 
34870:         case eCSSProperty_font_stretch: {
34870:           PRInt16 stretch =
34870:             static_cast<const nsStyleFont*>(styleStruct)->mFont.stretch;
34870:           PR_STATIC_ASSERT(NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED == -4);
34870:           PR_STATIC_ASSERT(NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED == 4);
34870:           if (stretch < NS_STYLE_FONT_STRETCH_ULTRA_CONDENSED ||
34870:               stretch > NS_STYLE_FONT_STRETCH_ULTRA_EXPANDED) {
34870:             return PR_FALSE;
34870:           }
34870:           aComputedValue.SetIntValue(stretch, eUnit_Enumerated);
34870:           return PR_TRUE;
34870:         }
34870: 
34870:         case eCSSProperty_font_weight: {
34870:           PRUint16 weight =
34870:             static_cast<const nsStyleFont*>(styleStruct)->mFont.weight;
34870:           if (weight % 100 != 0) {
34870:             return PR_FALSE;
34870:           }
34870:           aComputedValue.SetIntValue(weight, eUnit_Integer);
34870:           return PR_TRUE;
34870:         }
34870: 
36525:         case eCSSProperty_image_region: {
36525:           const nsStyleList *list =
36525:             static_cast<const nsStyleList*>(styleStruct);
36525:           const nsRect &srect = list->mImageRegion;
36525:           if (srect.IsEmpty()) {
36525:             aComputedValue.SetAutoValue();
36525:             break;
36525:           }
36525: 
36525:           nsCSSRect *vrect = new nsCSSRect;
36525:           nscoordToCSSValue(srect.x, vrect->mLeft);
36525:           nscoordToCSSValue(srect.y, vrect->mTop);
36525:           nscoordToCSSValue(srect.XMost(), vrect->mRight);
36525:           nscoordToCSSValue(srect.YMost(), vrect->mBottom);
36525:           aComputedValue.SetAndAdoptCSSRectValue(vrect, eUnit_CSSRect);
36525:           break;
36525:         }
36525: 
36525:         case eCSSProperty_clip: {
36525:           const nsStyleDisplay *display =
36525:             static_cast<const nsStyleDisplay*>(styleStruct);
50929:           if (!(display->mClipFlags & NS_STYLE_CLIP_RECT)) {
50929:             aComputedValue.SetAutoValue();
50929:           } else {
36525:             nsCSSRect *vrect = new nsCSSRect;
36525:             const nsRect &srect = display->mClip;
36525:             if (display->mClipFlags & NS_STYLE_CLIP_TOP_AUTO) {
36525:               vrect->mTop.SetAutoValue();
36525:             } else {
36525:               nscoordToCSSValue(srect.y, vrect->mTop);
36525:             }
36525:             if (display->mClipFlags & NS_STYLE_CLIP_RIGHT_AUTO) {
36525:               vrect->mRight.SetAutoValue();
36525:             } else {
36525:               nscoordToCSSValue(srect.XMost(), vrect->mRight);
36525:             }
36525:             if (display->mClipFlags & NS_STYLE_CLIP_BOTTOM_AUTO) {
36525:               vrect->mBottom.SetAutoValue();
36525:             } else {
36525:               nscoordToCSSValue(srect.YMost(), vrect->mBottom);
36525:             }
36525:             if (display->mClipFlags & NS_STYLE_CLIP_LEFT_AUTO) {
36525:               vrect->mLeft.SetAutoValue();
36525:             } else {
36525:               nscoordToCSSValue(srect.x, vrect->mLeft);
36525:             }
50929:             aComputedValue.SetAndAdoptCSSRectValue(vrect, eUnit_CSSRect);
36837:           }
36525:           break;
36525:         }
36525: 
36527:         case eCSSProperty_background_position: {
36527:           const nsStyleBackground *bg =
36527:             static_cast<const nsStyleBackground*>(styleStruct);
53920:           nsAutoPtr<nsCSSValuePairList> result;
53920:           nsCSSValuePairList **resultTail = getter_Transfers(result);
36527:           NS_ABORT_IF_FALSE(bg->mPositionCount > 0, "unexpected count");
36527:           for (PRUint32 i = 0, i_end = bg->mPositionCount; i != i_end; ++i) {
36527:             nsCSSValuePairList *item = new nsCSSValuePairList;
36527:             *resultTail = item;
36527:             resultTail = &item->mNext;
36527: 
36527:             const nsStyleBackground::Position &pos = bg->mLayers[i].mPosition;
70428:             // XXXbz is there a good reason we can't just
70428:             // SetCalcValue(&pos.mXPosition, item->mXValue) here?
70428:             if (!pos.mXPosition.mHasPercent) {
70428:               NS_ABORT_IF_FALSE(pos.mXPosition.mPercent == 0.0f,
70428:                                 "Shouldn't have mPercent!");
70428:               nscoordToCSSValue(pos.mXPosition.mLength, item->mXValue);
70428:             } else if (pos.mXPosition.mLength == 0) {
53919:               item->mXValue.SetPercentValue(pos.mXPosition.mPercent);
36527:             } else {
70428:               SetCalcValue(&pos.mXPosition, item->mXValue);
36527:             }
70428:             if (!pos.mYPosition.mHasPercent) {
70428:               NS_ABORT_IF_FALSE(pos.mYPosition.mPercent == 0.0f,
70428:                                 "Shouldn't have mPercent!");
70428:               nscoordToCSSValue(pos.mYPosition.mLength, item->mYValue);
70428:             } else if (pos.mYPosition.mLength == 0) {
53919:               item->mYValue.SetPercentValue(pos.mYPosition.mPercent);
36527:             } else {
70428:               SetCalcValue(&pos.mYPosition, item->mYValue);
36527:             }
36527:           }
36527: 
53920:           aComputedValue.SetAndAdoptCSSValuePairListValue(result.forget());
36527:           break;
36527:         }
36527: 
43359:         case eCSSProperty_background_size: {
36527:           const nsStyleBackground *bg =
36527:             static_cast<const nsStyleBackground*>(styleStruct);
53920:           nsAutoPtr<nsCSSValuePairList> result;
53920:           nsCSSValuePairList **resultTail = getter_Transfers(result);
36527:           NS_ABORT_IF_FALSE(bg->mSizeCount > 0, "unexpected count");
36527:           for (PRUint32 i = 0, i_end = bg->mSizeCount; i != i_end; ++i) {
36527:             nsCSSValuePairList *item = new nsCSSValuePairList;
36527:             *resultTail = item;
36527:             resultTail = &item->mNext;
36527: 
36527:             const nsStyleBackground::Size &size = bg->mLayers[i].mSize;
36527:             switch (size.mWidthType) {
36527:               case nsStyleBackground::Size::eContain:
36527:               case nsStyleBackground::Size::eCover:
36527:                 item->mXValue.SetIntValue(size.mWidthType,
36527:                                           eCSSUnit_Enumerated);
36527:                 break;
36527:               case nsStyleBackground::Size::eAuto:
36527:                 item->mXValue.SetAutoValue();
36527:                 break;
53919:               case nsStyleBackground::Size::eLengthPercentage:
70429:                 // XXXbz is there a good reason we can't just
70429:                 // SetCalcValue(&size.mWidth, item->mXValue) here?
70429:                 if (!size.mWidth.mHasPercent &&
70429:                     // negative values must have come from calc()
70429:                     size.mWidth.mLength >= 0) {
70429:                   NS_ABORT_IF_FALSE(size.mWidth.mPercent == 0.0f,
70429:                                     "Shouldn't have mPercent");
70429:                   nscoordToCSSValue(size.mWidth.mLength, item->mXValue);
70429:                 } else if (size.mWidth.mLength == 0 &&
70429:                            // negative values must have come from calc()
70429:                            size.mWidth.mPercent >= 0.0f) {
53919:                   item->mXValue.SetPercentValue(size.mWidth.mPercent);
53919:                 } else {
70429:                   SetCalcValue(&size.mWidth, item->mXValue);
53919:                 }
36527:                 break;
36527:             }
36527: 
36527:             switch (size.mHeightType) {
36527:               case nsStyleBackground::Size::eContain:
36527:               case nsStyleBackground::Size::eCover:
36527:                 // leave it null
36527:                 break;
36527:               case nsStyleBackground::Size::eAuto:
36527:                 item->mYValue.SetAutoValue();
36527:                 break;
53919:               case nsStyleBackground::Size::eLengthPercentage:
70429:                 // XXXbz is there a good reason we can't just
70429:                 // SetCalcValue(&size.mHeight, item->mYValue) here?
70429:                 if (!size.mHeight.mHasPercent &&
70429:                     // negative values must have come from calc()
70429:                     size.mHeight.mLength >= 0) {
70429:                   NS_ABORT_IF_FALSE(size.mHeight.mPercent == 0.0f,
70429:                                     "Shouldn't have mPercent");
70429:                   nscoordToCSSValue(size.mHeight.mLength, item->mYValue);
70429:                 } else if (size.mHeight.mLength == 0 &&
70429:                            // negative values must have come from calc()
70429:                            size.mHeight.mPercent >= 0.0f) {
53919:                   item->mYValue.SetPercentValue(size.mHeight.mPercent);
53919:                 } else {
70429:                   SetCalcValue(&size.mHeight, item->mYValue);
53919:                 }
36527:                 break;
36527:             }
36527:           }
36527: 
53920:           aComputedValue.SetAndAdoptCSSValuePairListValue(result.forget());
36527:           break;
36527:         }
36527: 
47195:         case eCSSProperty__moz_transform: {
47195:           const nsStyleDisplay *display =
47195:             static_cast<const nsStyleDisplay*>(styleStruct);
47195:           nsAutoPtr<nsCSSValueList> result;
47195:           if (display->mSpecifiedTransform) {
47195:             // Clone, and convert all lengths (not percents) to pixels.
47195:             nsCSSValueList **resultTail = getter_Transfers(result);
47195:             for (const nsCSSValueList *l = display->mSpecifiedTransform;
47195:                  l; l = l->mNext) {
47195:               nsCSSValueList *clone = new nsCSSValueList;
47195:               *resultTail = clone;
47195:               resultTail = &clone->mNext;
47195: 
47195:               SubstitutePixelValues(aStyleContext, l->mValue, clone->mValue);
47195:             }
47195:           } else {
47195:             result = new nsCSSValueList();
47195:             result->mValue.SetNoneValue();
47195:           }
47195: 
47195:           aComputedValue.SetAndAdoptCSSValueListValue(result.forget(),
47195:                                                       eUnit_Transform);
47195:           break;
47195:         }
47195: 
33817:         default:
33817:           NS_ABORT_IF_FALSE(PR_FALSE, "missing property implementation");
33817:           return PR_FALSE;
33817:       };
33817:       return PR_TRUE;
32396:     case eStyleAnimType_Coord:
34029:       return StyleCoordToValue(*static_cast<const nsStyleCoord*>(
34029:         StyleDataAtOffset(styleStruct, ssOffset)), aComputedValue);
32396:     case eStyleAnimType_Sides_Top:
32396:     case eStyleAnimType_Sides_Right:
32396:     case eStyleAnimType_Sides_Bottom:
34029:     case eStyleAnimType_Sides_Left: {
32396:       PR_STATIC_ASSERT(0 == NS_SIDE_TOP);
32396:       PR_STATIC_ASSERT(eStyleAnimType_Sides_Right - eStyleAnimType_Sides_Top
32396:                          == NS_SIDE_RIGHT);
32396:       PR_STATIC_ASSERT(eStyleAnimType_Sides_Bottom - eStyleAnimType_Sides_Top
32396:                          == NS_SIDE_BOTTOM);
32396:       PR_STATIC_ASSERT(eStyleAnimType_Sides_Left - eStyleAnimType_Sides_Top
32396:                          == NS_SIDE_LEFT);
34029:       const nsStyleCoord &coord = static_cast<const nsStyleSides*>(
32396:         StyleDataAtOffset(styleStruct, ssOffset))->
41419:           Get(mozilla::css::Side(animType - eStyleAnimType_Sides_Top));
34029:       return StyleCoordToValue(coord, aComputedValue);
34029:     }
34265:     case eStyleAnimType_Corner_TopLeft:
34265:     case eStyleAnimType_Corner_TopRight:
34265:     case eStyleAnimType_Corner_BottomRight:
34265:     case eStyleAnimType_Corner_BottomLeft: {
34265:       PR_STATIC_ASSERT(0 == NS_CORNER_TOP_LEFT);
34265:       PR_STATIC_ASSERT(eStyleAnimType_Corner_TopRight -
34265:                          eStyleAnimType_Corner_TopLeft
34265:                        == NS_CORNER_TOP_RIGHT);
34265:       PR_STATIC_ASSERT(eStyleAnimType_Corner_BottomRight -
34265:                          eStyleAnimType_Corner_TopLeft
34265:                        == NS_CORNER_BOTTOM_RIGHT);
34265:       PR_STATIC_ASSERT(eStyleAnimType_Corner_BottomLeft -
34265:                          eStyleAnimType_Corner_TopLeft
34265:                        == NS_CORNER_BOTTOM_LEFT);
34265:       const nsStyleCorners *corners = static_cast<const nsStyleCorners*>(
34265:         StyleDataAtOffset(styleStruct, ssOffset));
34265:       PRUint8 fullCorner = animType - eStyleAnimType_Corner_TopLeft;
34265:       const nsStyleCoord &horiz =
34265:         corners->Get(NS_FULL_TO_HALF_CORNER(fullCorner, PR_FALSE));
34265:       const nsStyleCoord &vert =
34265:         corners->Get(NS_FULL_TO_HALF_CORNER(fullCorner, PR_TRUE));
59083:       nsAutoPtr<nsCSSValuePair> pair(new nsCSSValuePair);
53925:       if (!pair ||
53925:           !StyleCoordToCSSValue(horiz, pair->mXValue) ||
53925:           !StyleCoordToCSSValue(vert, pair->mYValue)) {
34265:         return PR_FALSE;
34265:       }
59083:       aComputedValue.SetAndAdoptCSSValuePairValue(pair.forget(),
59083:                                                   eUnit_CSSValuePair);
34265:       return PR_TRUE;
34265:     }
32397:     case eStyleAnimType_nscoord:
32397:       aComputedValue.SetCoordValue(*static_cast<const nscoord*>(
32397:         StyleDataAtOffset(styleStruct, ssOffset)));
32397:       return PR_TRUE;
34083:     case eStyleAnimType_EnumU8:
34083:       aComputedValue.SetIntValue(*static_cast<const PRUint8*>(
34083:         StyleDataAtOffset(styleStruct, ssOffset)), eUnit_Enumerated);
34083:       return PR_TRUE;
33689:     case eStyleAnimType_float:
34029:       aComputedValue.SetFloatValue(*static_cast<const float*>(
33689:         StyleDataAtOffset(styleStruct, ssOffset)));
33691:       if (aProperty == eCSSProperty_font_size_adjust &&
34029:           aComputedValue.GetFloatValue() == 0.0f) {
33691:         // In nsStyleFont, we set mFont.sizeAdjust to 0 to represent
33691:         // font-size-adjust: none.  Here, we have to treat this as a keyword
33691:         // instead of a float value, to make sure we don't end up doing
33691:         // interpolation with it.
33691:         aComputedValue.SetNoneValue();
33691:       }
33689:       return PR_TRUE;
32399:     case eStyleAnimType_Color:
32399:       aComputedValue.SetColorValue(*static_cast<const nscolor*>(
32399:         StyleDataAtOffset(styleStruct, ssOffset)));
32399:       return PR_TRUE;
32400:     case eStyleAnimType_PaintServer: {
32400:       const nsStyleSVGPaint &paint = *static_cast<const nsStyleSVGPaint*>(
32400:         StyleDataAtOffset(styleStruct, ssOffset));
32400:       if (paint.mType == eStyleSVGPaintType_Color) {
32400:         aComputedValue.SetColorValue(paint.mPaint.mColor);
32400:         return PR_TRUE;
32400:       }
59721:       if (paint.mType == eStyleSVGPaintType_Server) {
59721:         if (!paint.mPaint.mPaintServer) {
59721:           NS_WARNING("Null paint server");
59721:           return PR_FALSE;
59721:         }
59721:         nsAutoPtr<nsCSSValuePair> pair(new nsCSSValuePair);
59721:         nsRefPtr<nsStringBuffer> uriAsStringBuffer =
59721:           GetURIAsUtf16StringBuffer(paint.mPaint.mPaintServer);
59721:         NS_ENSURE_TRUE(!!uriAsStringBuffer, PR_FALSE);
59721:         nsIDocument* doc = aStyleContext->PresContext()->Document();
59721:         nsRefPtr<nsCSSValue::URL> url =
59721:           new nsCSSValue::URL(paint.mPaint.mPaintServer,
59721:                               uriAsStringBuffer,
59721:                               doc->GetDocumentURI(),
59721:                               doc->NodePrincipal());
59721:         pair->mXValue.SetURLValue(url);
59721:         pair->mYValue.SetColorValue(paint.mFallbackColor);
59721:         aComputedValue.SetAndAdoptCSSValuePairValue(pair.forget(),
59721:                                                     eUnit_CSSValuePair);
59721:         return PR_TRUE;
59721:       }
59721:       NS_ABORT_IF_FALSE(paint.mType == eStyleSVGPaintType_None,
59721:           "Unexpected SVG paint type");
33434:       aComputedValue.SetNoneValue();
33434:       return PR_TRUE;
33434:     }
34062:     case eStyleAnimType_Shadow: {
34062:       const nsCSSShadowArray *shadowArray =
34062:         *static_cast<const nsRefPtr<nsCSSShadowArray>*>(
34062:           StyleDataAtOffset(styleStruct, ssOffset));
34062:       if (!shadowArray) {
34266:         aComputedValue.SetAndAdoptCSSValueListValue(nsnull, eUnit_Shadow);
34062:         return PR_TRUE;
34062:       }
34062:       nsAutoPtr<nsCSSValueList> result;
34062:       nsCSSValueList **resultTail = getter_Transfers(result);
34062:       for (PRUint32 i = 0, i_end = shadowArray->Length(); i < i_end; ++i) {
34062:         const nsCSSShadowItem *shadow = shadowArray->ShadowAt(i);
34062:         // X, Y, Radius, Spread, Color, Inset
34062:         nsRefPtr<nsCSSValue::Array> arr = nsCSSValue::Array::Create(6);
36525:         nscoordToCSSValue(shadow->mXOffset, arr->Item(0));
36525:         nscoordToCSSValue(shadow->mYOffset, arr->Item(1));
36525:         nscoordToCSSValue(shadow->mRadius, arr->Item(2));
34062:         // NOTE: This code sometimes stores mSpread: 0 even when
34062:         // the parser would be required to leave it null.
36525:         nscoordToCSSValue(shadow->mSpread, arr->Item(3));
34062:         if (shadow->mHasColor) {
34062:           arr->Item(4).SetColorValue(shadow->mColor);
34062:         }
34062:         if (shadow->mInset) {
34062:           arr->Item(5).SetIntValue(NS_STYLE_BOX_SHADOW_INSET,
34062:                                    eCSSUnit_Enumerated);
34062:         }
34062: 
34062:         nsCSSValueList *resultItem = new nsCSSValueList;
34062:         if (!resultItem) {
34062:           return PR_FALSE;
34062:         }
34062:         resultItem->mValue.SetArrayValue(arr, eCSSUnit_Array);
34062:         *resultTail = resultItem;
34062:         resultTail = &resultItem->mNext;
34062:       }
34266:       aComputedValue.SetAndAdoptCSSValueListValue(result.forget(),
34266:                                                   eUnit_Shadow);
34062:       return PR_TRUE;
34062:     }
32396:     case eStyleAnimType_None:
32396:       NS_NOTREACHED("shouldn't use on non-animatable properties");
32396:   }
32396:   return PR_FALSE;
32396: }
34029: 
34812: nsStyleAnimation::Value::Value(PRInt32 aInt, Unit aUnit,
34812:                                IntegerConstructorType)
34083: {
34812:   NS_ASSERTION(IsIntUnit(aUnit), "unit must be of integer type");
34812:   mUnit = aUnit;
34083:   mValue.mInt = aInt;
34083: }
34083: 
34029: nsStyleAnimation::Value::Value(nscoord aLength, CoordConstructorType)
34029: {
34029:   mUnit = eUnit_Coord;
34029:   mValue.mCoord = aLength;
34029: }
34029: 
34029: nsStyleAnimation::Value::Value(float aPercent, PercentConstructorType)
34029: {
34029:   mUnit = eUnit_Percent;
34029:   mValue.mFloat = aPercent;
34029: }
34029: 
34029: nsStyleAnimation::Value::Value(float aFloat, FloatConstructorType)
34029: {
34029:   mUnit = eUnit_Float;
34029:   mValue.mFloat = aFloat;
34029: }
34029: 
34029: nsStyleAnimation::Value::Value(nscolor aColor, ColorConstructorType)
34029: {
34029:   mUnit = eUnit_Color;
34029:   mValue.mColor = aColor;
34029: }
34029: 
34029: nsStyleAnimation::Value&
34029: nsStyleAnimation::Value::operator=(const Value& aOther)
34029: {
34029:   FreeValue();
34029: 
34029:   mUnit = aOther.mUnit;
34029:   switch (mUnit) {
34029:     case eUnit_Null:
34029:     case eUnit_Normal:
34029:     case eUnit_Auto:
34029:     case eUnit_None:
34029:       break;
34083:     case eUnit_Enumerated:
36526:     case eUnit_Visibility:
34812:     case eUnit_Integer:
34083:       mValue.mInt = aOther.mValue.mInt;
34083:       break;
34029:     case eUnit_Coord:
34029:       mValue.mCoord = aOther.mValue.mCoord;
34029:       break;
34029:     case eUnit_Percent:
34029:     case eUnit_Float:
34029:       mValue.mFloat = aOther.mValue.mFloat;
34029:       break;
34029:     case eUnit_Color:
34029:       mValue.mColor = aOther.mValue.mColor;
34029:       break;
53921:     case eUnit_Calc:
53921:       NS_ABORT_IF_FALSE(aOther.mValue.mCSSValue, "values may not be null");
53921:       mValue.mCSSValue = new nsCSSValue(*aOther.mValue.mCSSValue);
53921:       if (!mValue.mCSSValue) {
53921:         mUnit = eUnit_Null;
53921:       }
53921:       break;
34265:     case eUnit_CSSValuePair:
34265:       NS_ABORT_IF_FALSE(aOther.mValue.mCSSValuePair,
34265:                         "value pairs may not be null");
34265:       mValue.mCSSValuePair = new nsCSSValuePair(*aOther.mValue.mCSSValuePair);
34265:       if (!mValue.mCSSValuePair) {
34265:         mUnit = eUnit_Null;
34265:       }
34265:       break;
74756:     case eUnit_CSSValueTriplet:
74756:       NS_ABORT_IF_FALSE(aOther.mValue.mCSSValueTriplet,
74756:                         "value triplets may not be null");
74756:       mValue.mCSSValueTriplet = new nsCSSValueTriplet(*aOther.mValue.mCSSValueTriplet);
74756:       if (!mValue.mCSSValueTriplet) {
74756:         mUnit = eUnit_Null;
74756:       }
74756:       break;
36525:     case eUnit_CSSRect:
36525:       NS_ABORT_IF_FALSE(aOther.mValue.mCSSRect, "rects may not be null");
36525:       mValue.mCSSRect = new nsCSSRect(*aOther.mValue.mCSSRect);
36525:       if (!mValue.mCSSRect) {
36525:         mUnit = eUnit_Null;
36525:       }
36525:       break;
34064:     case eUnit_Dasharray:
34062:     case eUnit_Shadow:
47195:     case eUnit_Transform:
47195:       NS_ABORT_IF_FALSE(mUnit == eUnit_Shadow || aOther.mValue.mCSSValueList,
47195:                         "value lists other than shadows may not be null");
34265:       if (aOther.mValue.mCSSValueList) {
34265:         mValue.mCSSValueList = aOther.mValue.mCSSValueList->Clone();
34265:         if (!mValue.mCSSValueList) {
34265:           mUnit = eUnit_Null;
34265:         }
34265:       } else {
34265:         mValue.mCSSValueList = nsnull;
34265:       }
34265:       break;
36527:     case eUnit_CSSValuePairList:
36527:       NS_ABORT_IF_FALSE(aOther.mValue.mCSSValuePairList,
36527:                         "value pair lists may not be null");
36527:       mValue.mCSSValuePairList = aOther.mValue.mCSSValuePairList->Clone();
36527:       if (!mValue.mCSSValuePairList) {
36527:         mUnit = eUnit_Null;
36527:       }
36527:       break;
35515:     case eUnit_UnparsedString:
35515:       NS_ABORT_IF_FALSE(aOther.mValue.mString, "expecting non-null string");
35515:       mValue.mString = aOther.mValue.mString;
35515:       mValue.mString->AddRef();
35515:       break;
34029:   }
34029: 
34029:   return *this;
34029: }
34029: 
34029: void
34029: nsStyleAnimation::Value::SetNormalValue()
34029: {
34029:   FreeValue();
34029:   mUnit = eUnit_Normal;
34029: }
34029: 
34029: void
34029: nsStyleAnimation::Value::SetAutoValue()
34029: {
34029:   FreeValue();
34029:   mUnit = eUnit_Auto;
34029: }
34029: 
34029: void
34029: nsStyleAnimation::Value::SetNoneValue()
34029: {
34029:   FreeValue();
34029:   mUnit = eUnit_None;
34029: }
34029: 
34029: void
34083: nsStyleAnimation::Value::SetIntValue(PRInt32 aInt, Unit aUnit)
34083: {
34812:   NS_ASSERTION(IsIntUnit(aUnit), "unit must be of integer type");
34083:   FreeValue();
34083:   mUnit = aUnit;
34083:   mValue.mInt = aInt;
34083: }
34083: 
34083: void
34029: nsStyleAnimation::Value::SetCoordValue(nscoord aLength)
34029: {
34029:   FreeValue();
34029:   mUnit = eUnit_Coord;
34029:   mValue.mCoord = aLength;
34029: }
34029: 
34029: void
34029: nsStyleAnimation::Value::SetPercentValue(float aPercent)
34029: {
34029:   FreeValue();
34029:   mUnit = eUnit_Percent;
34029:   mValue.mFloat = aPercent;
34029: }
34029: 
34029: void
34029: nsStyleAnimation::Value::SetFloatValue(float aFloat)
34029: {
34029:   FreeValue();
34029:   mUnit = eUnit_Float;
34029:   mValue.mFloat = aFloat;
34029: }
34029: 
34029: void
34029: nsStyleAnimation::Value::SetColorValue(nscolor aColor)
34029: {
34029:   FreeValue();
34029:   mUnit = eUnit_Color;
34029:   mValue.mColor = aColor;
34029: }
34029: 
34029: void
35515: nsStyleAnimation::Value::SetUnparsedStringValue(const nsString& aString)
35515: {
35515:   FreeValue();
35515:   mUnit = eUnit_UnparsedString;
58631:   mValue.mString = nsCSSValue::BufferFromString(aString).get();
35515:   if (NS_UNLIKELY(!mValue.mString)) {
35515:     // not much we can do here; just make sure that our promise of a
35515:     // non-null mValue.mString holds for string units.
35515:     mUnit = eUnit_Null;
35515:   }
35515: }
35515: 
35515: void
53921: nsStyleAnimation::Value::SetAndAdoptCSSValueValue(nsCSSValue *aValue,
53921:                                                   Unit aUnit)
53921: {
53921:   FreeValue();
53921:   NS_ABORT_IF_FALSE(IsCSSValueUnit(aUnit), "bad unit");
53921:   NS_ABORT_IF_FALSE(aValue != nsnull, "values may not be null");
53921:   mUnit = aUnit;
53921:   mValue.mCSSValue = aValue; // take ownership
53921: }
53921: 
53921: void
34266: nsStyleAnimation::Value::SetAndAdoptCSSValuePairValue(
34266:                            nsCSSValuePair *aValuePair, Unit aUnit)
34265: {
34265:   FreeValue();
34265:   NS_ABORT_IF_FALSE(IsCSSValuePairUnit(aUnit), "bad unit");
34265:   NS_ABORT_IF_FALSE(aValuePair != nsnull, "value pairs may not be null");
34265:   mUnit = aUnit;
34266:   mValue.mCSSValuePair = aValuePair; // take ownership
34265: }
34265: 
34265: void
74756: nsStyleAnimation::Value::SetAndAdoptCSSValueTripletValue(
74756:                            nsCSSValueTriplet *aValueTriplet, Unit aUnit)
74756: {
74756:     FreeValue();
74756:     NS_ABORT_IF_FALSE(IsCSSValueTripletUnit(aUnit), "bad unit");
74756:     NS_ABORT_IF_FALSE(aValueTriplet != nsnull, "value pairs may not be null");
74756:     mUnit = aUnit;
74756:     mValue.mCSSValueTriplet = aValueTriplet; // take ownership
74756: }
74756: 
74756: void
36525: nsStyleAnimation::Value::SetAndAdoptCSSRectValue(nsCSSRect *aRect, Unit aUnit)
36525: {
36525:   FreeValue();
36525:   NS_ABORT_IF_FALSE(IsCSSRectUnit(aUnit), "bad unit");
36525:   NS_ABORT_IF_FALSE(aRect != nsnull, "value pairs may not be null");
36525:   mUnit = aUnit;
36525:   mValue.mCSSRect = aRect; // take ownership
36525: }
36525: 
36525: void
34266: nsStyleAnimation::Value::SetAndAdoptCSSValueListValue(
34266:                            nsCSSValueList *aValueList, Unit aUnit)
34062: {
34062:   FreeValue();
34265:   NS_ABORT_IF_FALSE(IsCSSValueListUnit(aUnit), "bad unit");
34265:   NS_ABORT_IF_FALSE(aUnit != eUnit_Dasharray || aValueList != nsnull,
34265:                     "dasharrays may not be null");
34062:   mUnit = aUnit;
34266:   mValue.mCSSValueList = aValueList; // take ownership
34062: }
34062: 
34062: void
36527: nsStyleAnimation::Value::SetAndAdoptCSSValuePairListValue(
36527:                            nsCSSValuePairList *aValuePairList)
36527: {
36527:   FreeValue();
36527:   NS_ABORT_IF_FALSE(aValuePairList, "may not be null");
36527:   mUnit = eUnit_CSSValuePairList;
36527:   mValue.mCSSValuePairList = aValuePairList; // take ownership
36527: }
36527: 
36527: void
34029: nsStyleAnimation::Value::FreeValue()
34029: {
53921:   if (IsCSSValueUnit(mUnit)) {
53921:     delete mValue.mCSSValue;
53921:   } else if (IsCSSValueListUnit(mUnit)) {
34062:     delete mValue.mCSSValueList;
34265:   } else if (IsCSSValuePairUnit(mUnit)) {
34265:     delete mValue.mCSSValuePair;
74756:   } else if (IsCSSValueTripletUnit(mUnit)) {
74756:     delete mValue.mCSSValueTriplet;
36525:   } else if (IsCSSRectUnit(mUnit)) {
36525:     delete mValue.mCSSRect;
36527:   } else if (IsCSSValuePairListUnit(mUnit)) {
36527:     delete mValue.mCSSValuePairList;
35548:   } else if (IsStringUnit(mUnit)) {
35515:     NS_ABORT_IF_FALSE(mValue.mString, "expecting non-null string");
35515:     mValue.mString->Release();
34062:   }
34029: }
34029: 
34029: PRBool
34029: nsStyleAnimation::Value::operator==(const Value& aOther) const
34029: {
34029:   if (mUnit != aOther.mUnit) {
34029:     return PR_FALSE;
34029:   }
34029: 
34029:   switch (mUnit) {
34029:     case eUnit_Null:
34029:     case eUnit_Normal:
34029:     case eUnit_Auto:
34029:     case eUnit_None:
34029:       return PR_TRUE;
34083:     case eUnit_Enumerated:
36526:     case eUnit_Visibility:
34812:     case eUnit_Integer:
34083:       return mValue.mInt == aOther.mValue.mInt;
34029:     case eUnit_Coord:
34029:       return mValue.mCoord == aOther.mValue.mCoord;
34029:     case eUnit_Percent:
34029:     case eUnit_Float:
34029:       return mValue.mFloat == aOther.mValue.mFloat;
34029:     case eUnit_Color:
34029:       return mValue.mColor == aOther.mValue.mColor;
53921:     case eUnit_Calc:
53921:       return *mValue.mCSSValue == *aOther.mValue.mCSSValue;
34265:     case eUnit_CSSValuePair:
34265:       return *mValue.mCSSValuePair == *aOther.mValue.mCSSValuePair;
74756:     case eUnit_CSSValueTriplet:
74756:       return *mValue.mCSSValueTriplet == *aOther.mValue.mCSSValueTriplet;
36525:     case eUnit_CSSRect:
36525:       return *mValue.mCSSRect == *aOther.mValue.mCSSRect;
34064:     case eUnit_Dasharray:
34062:     case eUnit_Shadow:
47195:     case eUnit_Transform:
48853:       return *mValue.mCSSValueList == *aOther.mValue.mCSSValueList;
36527:     case eUnit_CSSValuePairList:
48853:       return *mValue.mCSSValuePairList == *aOther.mValue.mCSSValuePairList;
35515:     case eUnit_UnparsedString:
35515:       return (NS_strcmp(GetStringBufferValue(),
35515:                         aOther.GetStringBufferValue()) == 0);
34029:   }
34029: 
34029:   NS_NOTREACHED("incomplete case");
34029:   return PR_FALSE;
34029: }
34029: 
