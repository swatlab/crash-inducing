47652: //
70456: // Copyright (c) 2002-2011 The ANGLE Project Authors. All rights reserved.
47652: // Use of this source code is governed by a BSD-style license that can be
47652: // found in the LICENSE file.
47652: //
47652: 
47652: // libGLESv2.cpp: Implements the exported OpenGL ES 2.0 functions.
47652: 
47652: #define GL_APICALL
47652: #include <GLES2/gl2.h>
47652: #include <GLES2/gl2ext.h>
47652: 
47652: #include <exception>
47652: #include <limits>
47652: 
47652: #include "common/debug.h"
61598: #include "common/version.h"
47652: 
47652: #include "libGLESv2/main.h"
47652: #include "libGLESv2/mathutil.h"
47652: #include "libGLESv2/utilities.h"
47652: #include "libGLESv2/Buffer.h"
47652: #include "libGLESv2/Context.h"
55266: #include "libGLESv2/Fence.h"
47652: #include "libGLESv2/Framebuffer.h"
47652: #include "libGLESv2/Program.h"
47652: #include "libGLESv2/Renderbuffer.h"
47652: #include "libGLESv2/Shader.h"
47652: #include "libGLESv2/Texture.h"
47652: 
71571: bool validImageSize(GLint level, GLsizei width, GLsizei height)
71571: {
71571:     if (level < 0 || width < 0 || height < 0)
71571:     {
71571:         return false;
71571:     }
71571: 
71571:     if (gl::getContext() && gl::getContext()->supportsNonPower2Texture())
71571:     {
71571:         return true;
71571:     }
71571: 
71571:     if (level == 0)
71571:     {
71571:         return true;
71571:     }
71571: 
71571:     if (gl::isPow2(width) && gl::isPow2(height))
71571:     {
71571:         return true;
71571:     }
71571: 
71571:     return false;
71571: }
71571: 
47652: extern "C"
47652: {
47652: 
47652: void __stdcall glActiveTexture(GLenum texture)
47652: {
61598:     EVENT("(GLenum texture = 0x%X)", texture);
47652: 
47652:     try
47652:     {
70456:         gl::Context *context = gl::getContext();
70456: 
70456:         if (context)
70456:         {
70456:             if (texture < GL_TEXTURE0 || texture > GL_TEXTURE0 + context->getMaximumCombinedTextureImageUnits() - 1)
47652:             {
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             context->setActiveSampler(texture - GL_TEXTURE0);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glAttachShader(GLuint program, GLuint shader)
47652: {
61598:     EVENT("(GLuint program = %d, GLuint shader = %d)", program, shader);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652:             gl::Shader *shaderObject = context->getShader(shader);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             if (!shaderObject)
47652:             {
47652:                 if (context->getProgram(shader))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             if (!programObject->attachShader(shaderObject))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBindAttribLocation(GLuint program, GLuint index, const GLchar* name)
47652: {
61598:     EVENT("(GLuint program = %d, GLuint index = %d, const GLchar* name = 0x%0.8p)", program, index, name);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             if (strncmp(name, "gl_", 3) == 0)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             programObject->bindAttributeLocation(index, name);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBindBuffer(GLenum target, GLuint buffer)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLuint buffer = %d)", target, buffer);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             switch (target)
47652:             {
47652:               case GL_ARRAY_BUFFER:
47652:                 context->bindArrayBuffer(buffer);
47652:                 return;
47652:               case GL_ELEMENT_ARRAY_BUFFER:
47652:                 context->bindElementArrayBuffer(buffer);
47652:                 return;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBindFramebuffer(GLenum target, GLuint framebuffer)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLuint framebuffer = %d)", target, framebuffer);
47652: 
47652:     try
47652:     {
55266:         if (target != GL_FRAMEBUFFER && target != GL_DRAW_FRAMEBUFFER_ANGLE && target != GL_READ_FRAMEBUFFER_ANGLE)
47652:         {
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
55266:             if (target == GL_READ_FRAMEBUFFER_ANGLE || target == GL_FRAMEBUFFER)
55266:             {
55266:                 context->bindReadFramebuffer(framebuffer);
55266:             }
55266:             
55266:             if (target == GL_DRAW_FRAMEBUFFER_ANGLE || target == GL_FRAMEBUFFER)
55266:             {
55266:                 context->bindDrawFramebuffer(framebuffer);
55266:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBindRenderbuffer(GLenum target, GLuint renderbuffer)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLuint renderbuffer = %d)", target, renderbuffer);
47652: 
47652:     try
47652:     {
47652:         if (target != GL_RENDERBUFFER)
47652:         {
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->bindRenderbuffer(renderbuffer);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBindTexture(GLenum target, GLuint texture)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLuint texture = %d)", target, texture);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Texture *textureObject = context->getTexture(texture);
47652: 
47652:             if (textureObject && textureObject->getTarget() != target && texture != 0)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             switch (target)
47652:             {
47652:               case GL_TEXTURE_2D:
47652:                 context->bindTexture2D(texture);
47652:                 return;
47652:               case GL_TEXTURE_CUBE_MAP:
47652:                 context->bindTextureCubeMap(texture);
47652:                 return;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
47652: {
61598:     EVENT("(GLclampf red = %f, GLclampf green = %f, GLclampf blue = %f, GLclampf alpha = %f)",
47652:           red, green, blue, alpha);
47652: 
47652:     try
47652:     {
47652:         gl::Context* context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setBlendColor(gl::clamp01(red), gl::clamp01(green), gl::clamp01(blue), gl::clamp01(alpha));
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBlendEquation(GLenum mode)
47652: {
47652:     glBlendEquationSeparate(mode, mode);
47652: }
47652: 
47652: void __stdcall glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
47652: {
61598:     EVENT("(GLenum modeRGB = 0x%X, GLenum modeAlpha = 0x%X)", modeRGB, modeAlpha);
47652: 
47652:     try
47652:     {
47652:         switch (modeRGB)
47652:         {
47652:           case GL_FUNC_ADD:
47652:           case GL_FUNC_SUBTRACT:
47652:           case GL_FUNC_REVERSE_SUBTRACT:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (modeAlpha)
47652:         {
47652:           case GL_FUNC_ADD:
47652:           case GL_FUNC_SUBTRACT:
47652:           case GL_FUNC_REVERSE_SUBTRACT:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setBlendEquation(modeRGB, modeAlpha);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBlendFunc(GLenum sfactor, GLenum dfactor)
47652: {
47652:     glBlendFuncSeparate(sfactor, dfactor, sfactor, dfactor);
47652: }
47652: 
47652: void __stdcall glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
47652: {
61598:     EVENT("(GLenum srcRGB = 0x%X, GLenum dstRGB = 0x%X, GLenum srcAlpha = 0x%X, GLenum dstAlpha = 0x%X)",
47652:           srcRGB, dstRGB, srcAlpha, dstAlpha);
47652: 
47652:     try
47652:     {
47652:         switch (srcRGB)
47652:         {
47652:           case GL_ZERO:
47652:           case GL_ONE:
47652:           case GL_SRC_COLOR:
47652:           case GL_ONE_MINUS_SRC_COLOR:
47652:           case GL_DST_COLOR:
47652:           case GL_ONE_MINUS_DST_COLOR:
47652:           case GL_SRC_ALPHA:
47652:           case GL_ONE_MINUS_SRC_ALPHA:
47652:           case GL_DST_ALPHA:
47652:           case GL_ONE_MINUS_DST_ALPHA:
47652:           case GL_CONSTANT_COLOR:
47652:           case GL_ONE_MINUS_CONSTANT_COLOR:
47652:           case GL_CONSTANT_ALPHA:
47652:           case GL_ONE_MINUS_CONSTANT_ALPHA:
47652:           case GL_SRC_ALPHA_SATURATE:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (dstRGB)
47652:         {
47652:           case GL_ZERO:
47652:           case GL_ONE:
47652:           case GL_SRC_COLOR:
47652:           case GL_ONE_MINUS_SRC_COLOR:
47652:           case GL_DST_COLOR:
47652:           case GL_ONE_MINUS_DST_COLOR:
47652:           case GL_SRC_ALPHA:
47652:           case GL_ONE_MINUS_SRC_ALPHA:
47652:           case GL_DST_ALPHA:
47652:           case GL_ONE_MINUS_DST_ALPHA:
47652:           case GL_CONSTANT_COLOR:
47652:           case GL_ONE_MINUS_CONSTANT_COLOR:
47652:           case GL_CONSTANT_ALPHA:
47652:           case GL_ONE_MINUS_CONSTANT_ALPHA:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (srcAlpha)
47652:         {
47652:           case GL_ZERO:
47652:           case GL_ONE:
47652:           case GL_SRC_COLOR:
47652:           case GL_ONE_MINUS_SRC_COLOR:
47652:           case GL_DST_COLOR:
47652:           case GL_ONE_MINUS_DST_COLOR:
47652:           case GL_SRC_ALPHA:
47652:           case GL_ONE_MINUS_SRC_ALPHA:
47652:           case GL_DST_ALPHA:
47652:           case GL_ONE_MINUS_DST_ALPHA:
47652:           case GL_CONSTANT_COLOR:
47652:           case GL_ONE_MINUS_CONSTANT_COLOR:
47652:           case GL_CONSTANT_ALPHA:
47652:           case GL_ONE_MINUS_CONSTANT_ALPHA:
47652:           case GL_SRC_ALPHA_SATURATE:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (dstAlpha)
47652:         {
47652:           case GL_ZERO:
47652:           case GL_ONE:
47652:           case GL_SRC_COLOR:
47652:           case GL_ONE_MINUS_SRC_COLOR:
47652:           case GL_DST_COLOR:
47652:           case GL_ONE_MINUS_DST_COLOR:
47652:           case GL_SRC_ALPHA:
47652:           case GL_ONE_MINUS_SRC_ALPHA:
47652:           case GL_DST_ALPHA:
47652:           case GL_ONE_MINUS_DST_ALPHA:
47652:           case GL_CONSTANT_COLOR:
47652:           case GL_ONE_MINUS_CONSTANT_COLOR:
47652:           case GL_CONSTANT_ALPHA:
47652:           case GL_ONE_MINUS_CONSTANT_ALPHA:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         bool constantColorUsed = (srcRGB == GL_CONSTANT_COLOR || srcRGB == GL_ONE_MINUS_CONSTANT_COLOR ||
47652:                                   dstRGB == GL_CONSTANT_COLOR || dstRGB == GL_ONE_MINUS_CONSTANT_COLOR);
47652: 
47652:         bool constantAlphaUsed = (srcRGB == GL_CONSTANT_ALPHA || srcRGB == GL_ONE_MINUS_CONSTANT_ALPHA ||
47652:                                   dstRGB == GL_CONSTANT_ALPHA || dstRGB == GL_ONE_MINUS_CONSTANT_ALPHA);
47652: 
47652:         if (constantColorUsed && constantAlphaUsed)
47652:         {
47652:             ERR("Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR invalid under WebGL");
47652:             return error(GL_INVALID_OPERATION);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setBlendFactors(srcRGB, dstRGB, srcAlpha, dstAlpha);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLsizeiptr size = %d, const GLvoid* data = 0x%0.8p, GLenum usage = %d)",
47652:           target, size, data, usage);
47652: 
47652:     try
47652:     {
47652:         if (size < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         switch (usage)
47652:         {
47652:           case GL_STREAM_DRAW:
47652:           case GL_STATIC_DRAW:
47652:           case GL_DYNAMIC_DRAW:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Buffer *buffer;
47652: 
47652:             switch (target)
47652:             {
47652:               case GL_ARRAY_BUFFER:
47652:                 buffer = context->getArrayBuffer();
47652:                 break;
47652:               case GL_ELEMENT_ARRAY_BUFFER:
47652:                 buffer = context->getElementArrayBuffer();
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             if (!buffer)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             buffer->bufferData(data, size, usage);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLintptr offset = %d, GLsizeiptr size = %d, const GLvoid* data = 0x%0.8p)",
47652:           target, offset, size, data);
47652: 
47652:     try
47652:     {
47652:         if (size < 0 || offset < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (data == NULL)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Buffer *buffer;
47652: 
47652:             switch (target)
47652:             {
47652:               case GL_ARRAY_BUFFER:
47652:                 buffer = context->getArrayBuffer();
47652:                 break;
47652:               case GL_ELEMENT_ARRAY_BUFFER:
47652:                 buffer = context->getElementArrayBuffer();
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             if (!buffer)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if ((size_t)size + offset > buffer->size())
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             buffer->bufferSubData(data, size, offset);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: GLenum __stdcall glCheckFramebufferStatus(GLenum target)
47652: {
61598:     EVENT("(GLenum target = 0x%X)", target);
47652: 
47652:     try
47652:     {
55266:         if (target != GL_FRAMEBUFFER && target != GL_DRAW_FRAMEBUFFER_ANGLE && target != GL_READ_FRAMEBUFFER_ANGLE)
47652:         {
47652:             return error(GL_INVALID_ENUM, 0);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
55266:             gl::Framebuffer *framebuffer = NULL;
55266:             if (target == GL_READ_FRAMEBUFFER_ANGLE)
55266:             {
55266:                 framebuffer = context->getReadFramebuffer();
55266:             }
55266:             else
55266:             {
55266:                 framebuffer = context->getDrawFramebuffer();
55266:             }
47652: 
47652:             return framebuffer->completeness();
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, 0);
47652:     }
47652: 
47652:     return 0;
47652: }
47652: 
47652: void __stdcall glClear(GLbitfield mask)
47652: {
61598:     EVENT("(GLbitfield mask = %X)", mask);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->clear(mask);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
47652: {
61598:     EVENT("(GLclampf red = %f, GLclampf green = %f, GLclampf blue = %f, GLclampf alpha = %f)",
47652:           red, green, blue, alpha);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setClearColor(red, green, blue, alpha);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glClearDepthf(GLclampf depth)
47652: {
61598:     EVENT("(GLclampf depth = %f)", depth);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setClearDepth(depth);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glClearStencil(GLint s)
47652: {
61598:     EVENT("(GLint s = %d)", s);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setClearStencil(s);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
47652: {
61598:     EVENT("(GLboolean red = %d, GLboolean green = %d, GLboolean blue = %d, GLboolean alpha = %d)",
47652:           red, green, blue, alpha);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setColorMask(red == GL_TRUE, green == GL_TRUE, blue == GL_TRUE, alpha == GL_TRUE);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glCompileShader(GLuint shader)
47652: {
61598:     EVENT("(GLuint shader = %d)", shader);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Shader *shaderObject = context->getShader(shader);
47652: 
47652:             if (!shaderObject)
47652:             {
47652:                 if (context->getProgram(shader))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             shaderObject->compile();
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, 
47652:                                       GLint border, GLsizei imageSize, const GLvoid* data)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLint level = %d, GLenum internalformat = 0x%X, GLsizei width = %d, " 
47652:           "GLsizei height = %d, GLint border = %d, GLsizei imageSize = %d, const GLvoid* data = 0x%0.8p)",
47652:           target, level, internalformat, width, height, border, imageSize, data);
47652: 
47652:     try
47652:     {
71571:         if (!validImageSize(level, width, height) || border != 0 || imageSize < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
58582:         switch (internalformat)
58582:         {
58582:           case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
58582:           case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
77552:           case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
77552:           case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
58582:             break;
58582:           default:
58582:             return error(GL_INVALID_ENUM);
58582:         }
58582: 
58582:         if (border != 0)
58582:         {
58582:             return error(GL_INVALID_VALUE);
58582:         }
58582: 
58582:         gl::Context *context = gl::getContext();
58582: 
58582:         if (context)
58582:         {
58582:             if (level > context->getMaximumTextureLevel())
58582:             {
58582:                 return error(GL_INVALID_VALUE);
58582:             }
58582: 
47652:             switch (target)
47652:             {
47652:               case GL_TEXTURE_2D:
58582:                 if (width > (context->getMaximumTextureDimension() >> level) ||
58582:                     height > (context->getMaximumTextureDimension() >> level))
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:                 break;
47652:               case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
47652:               case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
47652:               case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
47652:               case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
47652:               case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
47652:               case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
47652:                 if (width != height)
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652: 
58582:                 if (width > (context->getMaximumCubeTextureDimension() >> level) ||
58582:                     height > (context->getMaximumCubeTextureDimension() >> level))
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
77552:             switch (internalformat) {
77552:               case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
77552:                 if (!context->supportsDXT1Textures())
55266:                 {
55266:                     return error(GL_INVALID_ENUM); // in this case, it's as though the internal format switch failed
55266:                 }
77552:                 break;
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
77552:                 if (!context->supportsDXT3Textures())
77552:                 {
77552:                     return error(GL_INVALID_ENUM); // in this case, it's as though the internal format switch failed
77552:                 }
77552:                 break;
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
77552:                 if (!context->supportsDXT5Textures())
77552:                 {
77552:                     return error(GL_INVALID_ENUM); // in this case, it's as though the internal format switch failed
77552:                 }
77552:                 break;
77552:               default: UNREACHABLE();
77552:             }
55266: 
55266:             if (imageSize != gl::ComputeCompressedSize(width, height, internalformat))
55266:             {
55266:                 return error(GL_INVALID_VALUE);
55266:             }
55266: 
55266:             if (target == GL_TEXTURE_2D)
55266:             {
55266:                 gl::Texture2D *texture = context->getTexture2D();
55266: 
55266:                 if (!texture)
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
55266:                 texture->setCompressedImage(level, internalformat, width, height, imageSize, data);
55266:             }
55266:             else
55266:             {
55266:                 gl::TextureCubeMap *texture = context->getTextureCubeMap();
55266: 
55266:                 if (!texture)
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
55266:                 switch (target)
55266:                 {
55266:                   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
55266:                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
55266:                   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
55266:                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
55266:                   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
55266:                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
55266:                     texture->setCompressedImage(target, level, internalformat, width, height, imageSize, data);
55266:                     break;
55266:                   default: UNREACHABLE();
55266:                 }
55266:             }
55266:         }
55266: 
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         return error(GL_OUT_OF_MEMORY);
55266:     }
55266: }
55266: 
55266: void __stdcall glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
55266:                                          GLenum format, GLsizei imageSize, const GLvoid* data)
55266: {
61598:     EVENT("(GLenum target = 0x%X, GLint level = %d, GLint xoffset = %d, GLint yoffset = %d, "
55266:           "GLsizei width = %d, GLsizei height = %d, GLenum format = 0x%X, "
55266:           "GLsizei imageSize = %d, const GLvoid* data = 0x%0.8p)",
55266:           target, level, xoffset, yoffset, width, height, format, imageSize, data);
55266: 
55266:     try
55266:     {
55266:         if (!gl::IsTextureTarget(target))
55266:         {
55266:             return error(GL_INVALID_ENUM);
55266:         }
55266: 
71571:         if (xoffset < 0 || yoffset < 0 || !validImageSize(level, width, height) || imageSize < 0)
55266:         {
55266:             return error(GL_INVALID_VALUE);
55266:         }
55266: 
55266:         switch (format)
55266:         {
55266:           case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
55266:           case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
77552:           case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
77552:           case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
55266:             break;
55266:           default:
55266:             return error(GL_INVALID_ENUM);
55266:         }
55266: 
55266:         if (width == 0 || height == 0 || data == NULL)
55266:         {
55266:             return;
55266:         }
55266: 
55266:         gl::Context *context = gl::getContext();
55266: 
55266:         if (context)
55266:         {
58582:             if (level > context->getMaximumTextureLevel())
58582:             {
58582:                 return error(GL_INVALID_VALUE);
58582:             }
58582: 
77552:             switch (format) {
77552:               case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
77552:                 if (!context->supportsDXT1Textures())
77552:                 {
77552:                     return error(GL_INVALID_ENUM); // in this case, it's as though the internal format switch failed
77552:                 }
77552:                 break;
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
77552:                 if (!context->supportsDXT3Textures())
77552:                 {
77552:                     return error(GL_INVALID_ENUM); // in this case, it's as though the internal format switch failed
77552:                 }
77552:                 break;
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
77552:                 if (!context->supportsDXT5Textures())
77552:                 {
77552:                     return error(GL_INVALID_ENUM); // in this case, it's as though the internal format switch failed
77552:                 }
77552:                 break;
77552:               default: UNREACHABLE();
55266:             }
55266: 
55266:             if (imageSize != gl::ComputeCompressedSize(width, height, format))
55266:             {
55266:                 return error(GL_INVALID_VALUE);
55266:             }
55266: 
55266:             if (xoffset % 4 != 0 || yoffset % 4 != 0)
55266:             {
55266:                 return error(GL_INVALID_OPERATION); // we wait to check the offsets until this point, because the multiple-of-four restriction
77552:                                                     // does not exist unless DXT textures are supported.
55266:             }
55266: 
55266:             if (target == GL_TEXTURE_2D)
55266:             {
55266:                 gl::Texture2D *texture = context->getTexture2D();
55266: 
55266:                 if (!texture)
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
55266:                 if (!texture->isCompressed())
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
55266:                 if ((width % 4 != 0 && width != texture->getWidth()) || 
55266:                     (height % 4 != 0 && height != texture->getHeight()))
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
55266:                 texture->subImageCompressed(level, xoffset, yoffset, width, height, format, imageSize, data);
55266:             }
55266:             else if (gl::IsCubemapTextureTarget(target))
55266:             {
55266:                 gl::TextureCubeMap *texture = context->getTextureCubeMap();
55266: 
55266:                 if (!texture)
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
55266:                 if (!texture->isCompressed())
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
55266:                 if ((width % 4 != 0 && width != texture->getWidth()) || 
55266:                     (height % 4 != 0 && height != texture->getHeight()))
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
55266:                 texture->subImageCompressed(target, level, xoffset, yoffset, width, height, format, imageSize, data);
55266:             }
55266:             else
55266:             {
55266:                 UNREACHABLE();
55266:             }
55266:         }
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         return error(GL_OUT_OF_MEMORY);
55266:     }
55266: }
55266: 
55266: void __stdcall glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
55266: {
61598:     EVENT("(GLenum target = 0x%X, GLint level = %d, GLenum internalformat = 0x%X, "
55266:           "GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d, GLint border = %d)",
55266:           target, level, internalformat, x, y, width, height, border);
55266: 
55266:     try
55266:     {
71571:         if (!validImageSize(level, width, height))
55266:         {
55266:             return error(GL_INVALID_VALUE);
55266:         }
55266: 
58582:         if (border != 0)
58582:         {
58582:             return error(GL_INVALID_VALUE);
58582:         }
58582: 
58582:         gl::Context *context = gl::getContext();
58582: 
58582:         if (context)
58582:         {
81795:             if (level > context->getMaximumTextureLevel())
81795:             {
81795:                 return error(GL_INVALID_VALUE);
81795:             }
81795: 
55266:             switch (target)
55266:             {
55266:               case GL_TEXTURE_2D:
58582:                 if (width > (context->getMaximumTextureDimension() >> level) ||
58582:                     height > (context->getMaximumTextureDimension() >> level))
55266:                 {
55266:                     return error(GL_INVALID_VALUE);
55266:                 }
55266:                 break;
55266:               case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
55266:               case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
55266:               case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
55266:               case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
55266:               case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
55266:               case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
55266:                 if (width != height)
55266:                 {
55266:                     return error(GL_INVALID_VALUE);
55266:                 }
55266: 
58582:                 if (width > (context->getMaximumCubeTextureDimension() >> level) ||
58582:                     height > (context->getMaximumCubeTextureDimension() >> level))
55266:                 {
55266:                     return error(GL_INVALID_VALUE);
55266:                 }
55266:                 break;
55266:               default:
55266:                 return error(GL_INVALID_ENUM);
55266:             }
55266: 
58582:             gl::Framebuffer *framebuffer = context->getReadFramebuffer();
58582: 
58582:             if (framebuffer->completeness() != GL_FRAMEBUFFER_COMPLETE)
58582:             {
58582:                 return error(GL_INVALID_FRAMEBUFFER_OPERATION);
58582:             }
58582: 
58582:             if (context->getReadFramebufferHandle() != 0 && framebuffer->getColorbuffer()->getSamples() != 0)
58582:             {
58582:                 return error(GL_INVALID_OPERATION);
58582:             }
58582: 
58582:             gl::Colorbuffer *source = framebuffer->getColorbuffer();
70456:             GLenum colorbufferFormat = source->getInternalFormat();
58582: 
58582:             // [OpenGL ES 2.0.24] table 3.9
55266:             switch (internalformat)
55266:             {
47652:               case GL_ALPHA:
58582:                 if (colorbufferFormat != GL_ALPHA &&
58582:                     colorbufferFormat != GL_RGBA &&
58582:                     colorbufferFormat != GL_RGBA4 &&
58582:                     colorbufferFormat != GL_RGB5_A1 &&
58582:                     colorbufferFormat != GL_RGBA8_OES)
58582:                 {
58582:                     return error(GL_INVALID_OPERATION);
58582:                 }
58582:                 break;
47652:               case GL_LUMINANCE:
58582:               case GL_RGB:
58582:                 if (colorbufferFormat != GL_RGB &&
58582:                     colorbufferFormat != GL_RGB565 &&
58582:                     colorbufferFormat != GL_RGB8_OES &&
58582:                     colorbufferFormat != GL_RGBA &&
58582:                     colorbufferFormat != GL_RGBA4 &&
58582:                     colorbufferFormat != GL_RGB5_A1 &&
58582:                     colorbufferFormat != GL_RGBA8_OES)
58582:                 {
58582:                     return error(GL_INVALID_OPERATION);
58582:                 }
58582:                 break;
47652:               case GL_LUMINANCE_ALPHA:
47652:               case GL_RGBA:
58582:                 if (colorbufferFormat != GL_RGBA &&
58582:                     colorbufferFormat != GL_RGBA4 &&
58582:                     colorbufferFormat != GL_RGB5_A1 &&
58582:                     colorbufferFormat != GL_RGBA8_OES)
58582:                  {
58582:                      return error(GL_INVALID_OPERATION);
58582:                  }
58582:                  break;
58582:               case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
58582:               case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
77552:                 if (context->supportsDXT1Textures())
77552:                 {
77552:                     return error(GL_INVALID_OPERATION);
77552:                 }
77552:                 else
77552:                 {
77552:                     return error(GL_INVALID_ENUM);
77552:                 }
77552:                 break;
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
77552:                 if (context->supportsDXT3Textures())
77552:                 {
77552:                     return error(GL_INVALID_OPERATION);
77552:                 }
77552:                 else
77552:                 {
77552:                     return error(GL_INVALID_ENUM);
77552:                 }
77552:                 break;
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
77552:                 if (context->supportsDXT5Textures())
58582:                 {
58582:                     return error(GL_INVALID_OPERATION);
58582:                 }
58582:                 else
58582:                 {
58582:                     return error(GL_INVALID_ENUM);
58582:                 }
47652:                 break;
47652:               default:
58582:                 return error(GL_INVALID_ENUM);
58582:             }
58582: 
58582:             if (target == GL_TEXTURE_2D)
58582:             {
58582:                 gl::Texture2D *texture = context->getTexture2D();
58582: 
58582:                 if (!texture)
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
58582: 
61598:                 texture->copyImage(level, internalformat, x, y, width, height, framebuffer);
58582:             }
58582:             else if (gl::IsCubemapTextureTarget(target))
58582:             {
58582:                 gl::TextureCubeMap *texture = context->getTextureCubeMap();
58582: 
58582:                 if (!texture)
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
61598:                 texture->copyImage(target, level, internalformat, x, y, width, height, framebuffer);
47652:             }
58582:             else UNREACHABLE();
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLint level = %d, GLint xoffset = %d, GLint yoffset = %d, "
47652:           "GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d)",
47652:           target, level, xoffset, yoffset, x, y, width, height);
47652: 
47652:     try
47652:     {
47652:         if (!gl::IsTextureTarget(target))
47652:         {
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
58582:         if (level < 0 || xoffset < 0 || yoffset < 0 || width < 0 || height < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (std::numeric_limits<GLsizei>::max() - xoffset < width || std::numeric_limits<GLsizei>::max() - yoffset < height)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (width == 0 || height == 0)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
58582:             if (level > context->getMaximumTextureLevel())
58582:             {
58582:                 return error(GL_INVALID_VALUE);
58582:             }
58582: 
55266:             gl::Framebuffer *framebuffer = context->getReadFramebuffer();
58582: 
48434:             if (framebuffer->completeness() != GL_FRAMEBUFFER_COMPLETE)
48434:             {
48434:                 return error(GL_INVALID_FRAMEBUFFER_OPERATION);
48434:             }
48434: 
55266:             if (context->getReadFramebufferHandle() != 0 && framebuffer->getColorbuffer()->getSamples() != 0)
55266:             {
55266:                 return error(GL_INVALID_OPERATION);
55266:             }
55266: 
48434:             gl::Colorbuffer *source = framebuffer->getColorbuffer();
70456:             GLenum colorbufferFormat = source->getInternalFormat();
58582:             gl::Texture *texture = NULL;
58582: 
47652:             if (target == GL_TEXTURE_2D)
47652:             {
58582:                 texture = context->getTexture2D();
58582:             }
58582:             else if (gl::IsCubemapTextureTarget(target))
58582:             {
58582:                 texture = context->getTextureCubeMap();
58582:             }
58582:             else UNREACHABLE();
47652: 
47652:             if (!texture)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
70456:             GLenum textureFormat = texture->getInternalFormat();
58582: 
58582:             // [OpenGL ES 2.0.24] table 3.9
58582:             switch (textureFormat)
58582:             {
58582:               case GL_ALPHA:
58582:                 if (colorbufferFormat != GL_ALPHA &&
58582:                     colorbufferFormat != GL_RGBA &&
58582:                     colorbufferFormat != GL_RGBA4 &&
58582:                     colorbufferFormat != GL_RGB5_A1 &&
58582:                     colorbufferFormat != GL_RGBA8_OES)
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
58582:                 break;
58582:               case GL_LUMINANCE:
58582:               case GL_RGB:
58582:                 if (colorbufferFormat != GL_RGB &&
58582:                     colorbufferFormat != GL_RGB565 &&
58582:                     colorbufferFormat != GL_RGB8_OES &&
58582:                     colorbufferFormat != GL_RGBA &&
58582:                     colorbufferFormat != GL_RGBA4 &&
58582:                     colorbufferFormat != GL_RGB5_A1 &&
58582:                     colorbufferFormat != GL_RGBA8_OES)
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
58582:                 break;
58582:               case GL_LUMINANCE_ALPHA:
58582:               case GL_RGBA:
58582:                 if (colorbufferFormat != GL_RGBA &&
58582:                     colorbufferFormat != GL_RGBA4 &&
58582:                     colorbufferFormat != GL_RGB5_A1 &&
58582:                     colorbufferFormat != GL_RGBA8_OES)
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
58582:                 break;
58582:               case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
58582:               case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
55266:                 return error(GL_INVALID_OPERATION);
58582:               default:
55266:                 return error(GL_INVALID_OPERATION);
55266:             }
55266: 
61598:             texture->copySubImage(target, level, xoffset, yoffset, x, y, width, height, framebuffer);
47652:         }
47652:     }
47652: 
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: GLuint __stdcall glCreateProgram(void)
47652: {
61598:     EVENT("()");
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             return context->createProgram();
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, 0);
47652:     }
47652: 
47652:     return 0;
47652: }
47652: 
47652: GLuint __stdcall glCreateShader(GLenum type)
47652: {
61598:     EVENT("(GLenum type = 0x%X)", type);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             switch (type)
47652:             {
47652:               case GL_FRAGMENT_SHADER:
47652:               case GL_VERTEX_SHADER:
47652:                 return context->createShader(type);
47652:               default:
47652:                 return error(GL_INVALID_ENUM, 0);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, 0);
47652:     }
47652: 
47652:     return 0;
47652: }
47652: 
47652: void __stdcall glCullFace(GLenum mode)
47652: {
61598:     EVENT("(GLenum mode = 0x%X)", mode);
47652: 
47652:     try
47652:     {
47652:         switch (mode)
47652:         {
47652:           case GL_FRONT:
47652:           case GL_BACK:
47652:           case GL_FRONT_AND_BACK:
47652:             {
47652:                 gl::Context *context = gl::getContext();
47652: 
47652:                 if (context)
47652:                 {
47652:                     context->setCullMode(mode);
47652:                 }
47652:             }
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDeleteBuffers(GLsizei n, const GLuint* buffers)
47652: {
61598:     EVENT("(GLsizei n = %d, const GLuint* buffers = 0x%0.8p)", n, buffers);
47652: 
47652:     try
47652:     {
47652:         if (n < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             for (int i = 0; i < n; i++)
47652:             {
47652:                 context->deleteBuffer(buffers[i]);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
55266: void __stdcall glDeleteFencesNV(GLsizei n, const GLuint* fences)
55266: {
61598:     EVENT("(GLsizei n = %d, const GLuint* fences = 0x%0.8p)", n, fences);
55266: 
55266:     try
55266:     {
55266:         if (n < 0)
55266:         {
55266:             return error(GL_INVALID_VALUE);
55266:         }
55266: 
55266:         gl::Context *context = gl::getContext();
55266: 
55266:         if (context)
55266:         {
55266:             for (int i = 0; i < n; i++)
55266:             {
55266:                 context->deleteFence(fences[i]);
55266:             }
55266:         }
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         return error(GL_OUT_OF_MEMORY);
55266:     }
55266: }
55266: 
47652: void __stdcall glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers)
47652: {
61598:     EVENT("(GLsizei n = %d, const GLuint* framebuffers = 0x%0.8p)", n, framebuffers);
47652: 
47652:     try
47652:     {
47652:         if (n < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             for (int i = 0; i < n; i++)
47652:             {
47652:                 if (framebuffers[i] != 0)
47652:                 {
47652:                     context->deleteFramebuffer(framebuffers[i]);
47652:                 }
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDeleteProgram(GLuint program)
47652: {
61598:     EVENT("(GLuint program = %d)", program);
47652: 
47652:     try
47652:     {
47652:         if (program == 0)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (!context->getProgram(program))
47652:             {
47652:                 if(context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             context->deleteProgram(program);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers)
47652: {
61598:     EVENT("(GLsizei n = %d, const GLuint* renderbuffers = 0x%0.8p)", n, renderbuffers);
47652: 
47652:     try
47652:     {
47652:         if (n < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             for (int i = 0; i < n; i++)
47652:             {
47652:                 context->deleteRenderbuffer(renderbuffers[i]);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDeleteShader(GLuint shader)
47652: {
61598:     EVENT("(GLuint shader = %d)", shader);
47652: 
47652:     try
47652:     {
47652:         if (shader == 0)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (!context->getShader(shader))
47652:             {
47652:                 if(context->getProgram(shader))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             context->deleteShader(shader);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDeleteTextures(GLsizei n, const GLuint* textures)
47652: {
61598:     EVENT("(GLsizei n = %d, const GLuint* textures = 0x%0.8p)", n, textures);
47652: 
47652:     try
47652:     {
47652:         if (n < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             for (int i = 0; i < n; i++)
47652:             {
47652:                 if (textures[i] != 0)
47652:                 {
47652:                     context->deleteTexture(textures[i]);
47652:                 }
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDepthFunc(GLenum func)
47652: {
61598:     EVENT("(GLenum func = 0x%X)", func);
47652: 
47652:     try
47652:     {
47652:         switch (func)
47652:         {
47652:           case GL_NEVER:
47652:           case GL_ALWAYS:
47652:           case GL_LESS:
47652:           case GL_LEQUAL:
47652:           case GL_EQUAL:
47652:           case GL_GREATER:
47652:           case GL_GEQUAL:
47652:           case GL_NOTEQUAL:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setDepthFunc(func);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDepthMask(GLboolean flag)
47652: {
61598:     EVENT("(GLboolean flag = %d)", flag);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setDepthMask(flag != GL_FALSE);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDepthRangef(GLclampf zNear, GLclampf zFar)
47652: {
61598:     EVENT("(GLclampf zNear = %f, GLclampf zFar = %f)", zNear, zFar);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setDepthRange(zNear, zFar);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDetachShader(GLuint program, GLuint shader)
47652: {
61598:     EVENT("(GLuint program = %d, GLuint shader = %d)", program, shader);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652: 
47652:             gl::Program *programObject = context->getProgram(program);
47652:             gl::Shader *shaderObject = context->getShader(shader);
47652:             
47652:             if (!programObject)
47652:             {
47652:                 gl::Shader *shaderByProgramHandle;
47652:                 shaderByProgramHandle = context->getShader(program);
47652:                 if (!shaderByProgramHandle)
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:             }
47652: 
47652:             if (!shaderObject)
47652:             {
47652:                 gl::Program *programByShaderHandle = context->getProgram(shader);
47652:                 if (!programByShaderHandle)
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:             }
47652: 
47652:             if (!programObject->detachShader(shaderObject))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDisable(GLenum cap)
47652: {
61598:     EVENT("(GLenum cap = 0x%X)", cap);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             switch (cap)
47652:             {
47652:               case GL_CULL_FACE:                context->setCullFace(false);              break;
47652:               case GL_POLYGON_OFFSET_FILL:      context->setPolygonOffsetFill(false);     break;
47652:               case GL_SAMPLE_ALPHA_TO_COVERAGE: context->setSampleAlphaToCoverage(false); break;
47652:               case GL_SAMPLE_COVERAGE:          context->setSampleCoverage(false);        break;
47652:               case GL_SCISSOR_TEST:             context->setScissorTest(false);           break;
47652:               case GL_STENCIL_TEST:             context->setStencilTest(false);           break;
47652:               case GL_DEPTH_TEST:               context->setDepthTest(false);             break;
47652:               case GL_BLEND:                    context->setBlend(false);                 break;
47652:               case GL_DITHER:                   context->setDither(false);                break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDisableVertexAttribArray(GLuint index)
47652: {
61598:     EVENT("(GLuint index = %d)", index);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
61598:             context->setEnableVertexAttribArray(index, false);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDrawArrays(GLenum mode, GLint first, GLsizei count)
47652: {
61598:     EVENT("(GLenum mode = 0x%X, GLint first = %d, GLsizei count = %d)", mode, first, count);
47652: 
47652:     try
47652:     {
47652:         if (count < 0 || first < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->drawArrays(mode, first, count);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices)
47652: {
61598:     EVENT("(GLenum mode = 0x%X, GLsizei count = %d, GLenum type = 0x%X, const GLvoid* indices = 0x%0.8p)",
47652:           mode, count, type, indices);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
61598:         gl::Context *context = gl::getContext();
61598: 
61598:         if (context)
61598:         {
47652:             switch (type)
47652:             {
47652:               case GL_UNSIGNED_BYTE:
47652:               case GL_UNSIGNED_SHORT:
61598:                 break;
47652:               case GL_UNSIGNED_INT:
61598:                 if (!context->supports32bitIndices())
61598:                 {
61598:                     return error(GL_INVALID_ENUM);    
61598:                 }
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         
47652:             context->drawElements(mode, count, type, indices);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glEnable(GLenum cap)
47652: {
61598:     EVENT("(GLenum cap = 0x%X)", cap);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             switch (cap)
47652:             {
47652:               case GL_CULL_FACE:                context->setCullFace(true);              break;
47652:               case GL_POLYGON_OFFSET_FILL:      context->setPolygonOffsetFill(true);     break;
47652:               case GL_SAMPLE_ALPHA_TO_COVERAGE: context->setSampleAlphaToCoverage(true); break;
47652:               case GL_SAMPLE_COVERAGE:          context->setSampleCoverage(true);        break;
47652:               case GL_SCISSOR_TEST:             context->setScissorTest(true);           break;
47652:               case GL_STENCIL_TEST:             context->setStencilTest(true);           break;
47652:               case GL_DEPTH_TEST:               context->setDepthTest(true);             break;
47652:               case GL_BLEND:                    context->setBlend(true);                 break;
47652:               case GL_DITHER:                   context->setDither(true);                break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glEnableVertexAttribArray(GLuint index)
47652: {
61598:     EVENT("(GLuint index = %d)", index);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
61598:             context->setEnableVertexAttribArray(index, true);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
55266: void __stdcall glFinishFenceNV(GLuint fence)
55266: {
61598:     EVENT("(GLuint fence = %d)", fence);
55266: 
55266:     try
55266:     {
55266:         gl::Context *context = gl::getContext();
55266: 
55266:         if (context)
55266:         {
55266:             gl::Fence* fenceObject = context->getFence(fence);
55266: 
55266:             if (fenceObject == NULL)
55266:             {
55266:                 return error(GL_INVALID_OPERATION);
55266:             }
55266: 
55266:             fenceObject->finishFence();
55266:         }
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         return error(GL_OUT_OF_MEMORY);
55266:     }
55266: }
55266: 
47652: void __stdcall glFinish(void)
47652: {
61598:     EVENT("()");
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
81204:             context->sync(true);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glFlush(void)
47652: {
61598:     EVENT("()");
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
81204:             context->sync(false);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLenum attachment = 0x%X, GLenum renderbuffertarget = 0x%X, "
47652:           "GLuint renderbuffer = %d)", target, attachment, renderbuffertarget, renderbuffer);
47652: 
47652:     try
47652:     {
55266:         if ((target != GL_FRAMEBUFFER && target != GL_DRAW_FRAMEBUFFER_ANGLE && target != GL_READ_FRAMEBUFFER_ANGLE)
80841:             || (renderbuffertarget != GL_RENDERBUFFER && renderbuffer != 0))
47652:         {
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
55266:             gl::Framebuffer *framebuffer = NULL;
55266:             GLuint framebufferHandle = 0;
55266:             if (target == GL_READ_FRAMEBUFFER_ANGLE)
55266:             {
55266:                 framebuffer = context->getReadFramebuffer();
55266:                 framebufferHandle = context->getReadFramebufferHandle();
55266:             }
55266:             else
55266:             {
55266:                 framebuffer = context->getDrawFramebuffer();
55266:                 framebufferHandle = context->getDrawFramebufferHandle();
55266:             }
55266: 
80841:             if (!framebuffer || (framebufferHandle == 0 && renderbuffer != 0))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             switch (attachment)
47652:             {
47652:               case GL_COLOR_ATTACHMENT0:
47652:                 framebuffer->setColorbuffer(GL_RENDERBUFFER, renderbuffer);
47652:                 break;
47652:               case GL_DEPTH_ATTACHMENT:
47652:                 framebuffer->setDepthbuffer(GL_RENDERBUFFER, renderbuffer);
47652:                 break;
47652:               case GL_STENCIL_ATTACHMENT:
47652:                 framebuffer->setStencilbuffer(GL_RENDERBUFFER, renderbuffer);
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLenum attachment = 0x%X, GLenum textarget = 0x%X, "
47652:           "GLuint texture = %d, GLint level = %d)", target, attachment, textarget, texture, level);
47652: 
47652:     try
47652:     {
55266:         if (target != GL_FRAMEBUFFER && target != GL_DRAW_FRAMEBUFFER_ANGLE && target != GL_READ_FRAMEBUFFER_ANGLE)
47652:         {
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (attachment)
47652:         {
47652:           case GL_COLOR_ATTACHMENT0:
47652:           case GL_DEPTH_ATTACHMENT:
47652:           case GL_STENCIL_ATTACHMENT:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (texture == 0)
47652:             {
47652:                 textarget = GL_NONE;
47652:             }
47652:             else
47652:             {
47652:                 gl::Texture *tex = context->getTexture(texture);
47652: 
47652:                 if (tex == NULL)
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652: 
55266:                 if (tex->isCompressed())
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
47652:                 switch (textarget)
47652:                 {
47652:                   case GL_TEXTURE_2D:
47652:                     if (tex->getTarget() != GL_TEXTURE_2D)
47652:                     {
47652:                         return error(GL_INVALID_OPERATION);
47652:                     }
47652:                     break;
47652: 
47652:                   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
47652:                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
47652:                   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
47652:                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
47652:                   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
47652:                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
47652:                     if (tex->getTarget() != GL_TEXTURE_CUBE_MAP)
47652:                     {
47652:                         return error(GL_INVALID_OPERATION);
47652:                     }
47652:                     break;
47652: 
47652:                   default:
47652:                     return error(GL_INVALID_ENUM);
47652:                 }
47652: 
47652:                 if (level != 0)
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
55266:             gl::Framebuffer *framebuffer = NULL;
55266:             GLuint framebufferHandle = 0;
55266:             if (target == GL_READ_FRAMEBUFFER_ANGLE)
55266:             {
55266:                 framebuffer = context->getReadFramebuffer();
55266:                 framebufferHandle = context->getReadFramebufferHandle();
55266:             }
55266:             else
55266:             {
55266:                 framebuffer = context->getDrawFramebuffer();
55266:                 framebufferHandle = context->getDrawFramebufferHandle();
55266:             }
55266: 
55266:             if (framebufferHandle == 0 || !framebuffer)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             switch (attachment)
47652:             {
47652:               case GL_COLOR_ATTACHMENT0:  framebuffer->setColorbuffer(textarget, texture);   break;
47652:               case GL_DEPTH_ATTACHMENT:   framebuffer->setDepthbuffer(textarget, texture);   break;
47652:               case GL_STENCIL_ATTACHMENT: framebuffer->setStencilbuffer(textarget, texture); break;
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glFrontFace(GLenum mode)
47652: {
61598:     EVENT("(GLenum mode = 0x%X)", mode);
47652: 
47652:     try
47652:     {
47652:         switch (mode)
47652:         {
47652:           case GL_CW:
47652:           case GL_CCW:
47652:             {
47652:                 gl::Context *context = gl::getContext();
47652: 
47652:                 if (context)
47652:                 {
47652:                     context->setFrontFace(mode);
47652:                 }
47652:             }
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGenBuffers(GLsizei n, GLuint* buffers)
47652: {
61598:     EVENT("(GLsizei n = %d, GLuint* buffers = 0x%0.8p)", n, buffers);
47652: 
47652:     try
47652:     {
47652:         if (n < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             for (int i = 0; i < n; i++)
47652:             {
47652:                 buffers[i] = context->createBuffer();
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGenerateMipmap(GLenum target)
47652: {
61598:     EVENT("(GLenum target = 0x%X)", target);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Texture *texture;
47652: 
47652:             switch (target)
47652:             {
47652:               case GL_TEXTURE_2D:
47652:                 texture = context->getTexture2D();
47652:                 break;
47652: 
47652:               case GL_TEXTURE_CUBE_MAP:
47652:                 texture = context->getTextureCubeMap();
47652:                 break;
47652: 
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
55266:             if (texture->isCompressed())
55266:             {
55266:                 return error(GL_INVALID_OPERATION);
55266:             }
55266: 
47652:             texture->generateMipmaps();
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
55266: void __stdcall glGenFencesNV(GLsizei n, GLuint* fences)
55266: {
61598:     EVENT("(GLsizei n = %d, GLuint* fences = 0x%0.8p)", n, fences);
55266: 
55266:     try
55266:     {
55266:         if (n < 0)
55266:         {
55266:             return error(GL_INVALID_VALUE);
55266:         }
55266: 
55266:         gl::Context *context = gl::getContext();
55266: 
55266:         if (context)
55266:         {
55266:             for (int i = 0; i < n; i++)
55266:             {
55266:                 fences[i] = context->createFence();
55266:             }
55266:         }
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         return error(GL_OUT_OF_MEMORY);
55266:     }
55266: }
55266: 
47652: void __stdcall glGenFramebuffers(GLsizei n, GLuint* framebuffers)
47652: {
61598:     EVENT("(GLsizei n = %d, GLuint* framebuffers = 0x%0.8p)", n, framebuffers);
47652: 
47652:     try
47652:     {
47652:         if (n < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             for (int i = 0; i < n; i++)
47652:             {
47652:                 framebuffers[i] = context->createFramebuffer();
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGenRenderbuffers(GLsizei n, GLuint* renderbuffers)
47652: {
61598:     EVENT("(GLsizei n = %d, GLuint* renderbuffers = 0x%0.8p)", n, renderbuffers);
47652: 
47652:     try
47652:     {
47652:         if (n < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             for (int i = 0; i < n; i++)
47652:             {
47652:                 renderbuffers[i] = context->createRenderbuffer();
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGenTextures(GLsizei n, GLuint* textures)
47652: {
61598:     EVENT("(GLsizei n = %d, GLuint* textures =  0x%0.8p)", n, textures);
47652: 
47652:     try
47652:     {
47652:         if (n < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             for (int i = 0; i < n; i++)
47652:             {
47652:                 textures[i] = context->createTexture();
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
47652: {
61598:     EVENT("(GLuint program = %d, GLuint index = %d, GLsizei bufsize = %d, GLsizei *length = 0x%0.8p, "
47652:           "GLint *size = 0x%0.8p, GLenum *type = %0.8p, GLchar *name = %0.8p)",
47652:           program, index, bufsize, length, size, type, name);
47652: 
47652:     try
47652:     {
47652:         if (bufsize < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             if (index >= (GLuint)programObject->getActiveAttributeCount())
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             programObject->getActiveAttribute(index, bufsize, length, size, type, name);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
47652: {
61598:     EVENT("(GLuint program = %d, GLuint index = %d, GLsizei bufsize = %d, "
47652:           "GLsizei* length = 0x%0.8p, GLint* size = 0x%0.8p, GLenum* type = 0x%0.8p, GLchar* name = 0x%0.8p)",
47652:           program, index, bufsize, length, size, type, name);
47652: 
47652:     try
47652:     {
47652:         if (bufsize < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             if (index >= (GLuint)programObject->getActiveUniformCount())
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             programObject->getActiveUniform(index, bufsize, length, size, type, name);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders)
47652: {
61598:     EVENT("(GLuint program = %d, GLsizei maxcount = %d, GLsizei* count = 0x%0.8p, GLuint* shaders = 0x%0.8p)",
47652:           program, maxcount, count, shaders);
47652: 
47652:     try
47652:     {
47652:         if (maxcount < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             return programObject->getAttachedShaders(maxcount, count, shaders);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: int __stdcall glGetAttribLocation(GLuint program, const GLchar* name)
47652: {
61598:     EVENT("(GLuint program = %d, const GLchar* name = %s)", program, name);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652: 
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION, -1);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE, -1);
47652:                 }
47652:             }
47652: 
47652:             if (!programObject->isLinked())
47652:             {
47652:                 return error(GL_INVALID_OPERATION, -1);
47652:             }
47652: 
47652:             return programObject->getAttributeLocation(name);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, -1);
47652:     }
47652: 
47652:     return -1;
47652: }
47652: 
47652: void __stdcall glGetBooleanv(GLenum pname, GLboolean* params)
47652: {
61598:     EVENT("(GLenum pname = 0x%X, GLboolean* params = 0x%0.8p)",  pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (!(context->getBooleanv(pname, params)))
47652:             {
47652:                 GLenum nativeType;
47652:                 unsigned int numParams = 0;
47652:                 if (!context->getQueryParameterInfo(pname, &nativeType, &numParams))
47652:                     return error(GL_INVALID_ENUM);
47652: 
47652:                 if (numParams == 0)
47652:                     return; // it is known that the pname is valid, but there are no parameters to return
47652: 
47652:                 if (nativeType == GL_FLOAT)
47652:                 {
47652:                     GLfloat *floatParams = NULL;
47652:                     floatParams = new GLfloat[numParams];
47652: 
47652:                     context->getFloatv(pname, floatParams);
47652: 
47652:                     for (unsigned int i = 0; i < numParams; ++i)
47652:                     {
47652:                         if (floatParams[i] == 0.0f)
47652:                             params[i] = GL_FALSE;
47652:                         else
47652:                             params[i] = GL_TRUE;
47652:                     }
47652: 
47652:                     delete [] floatParams;
47652:                 }
47652:                 else if (nativeType == GL_INT)
47652:                 {
47652:                     GLint *intParams = NULL;
47652:                     intParams = new GLint[numParams];
47652: 
47652:                     context->getIntegerv(pname, intParams);
47652: 
47652:                     for (unsigned int i = 0; i < numParams; ++i)
47652:                     {
47652:                         if (intParams[i] == 0)
47652:                             params[i] = GL_FALSE;
47652:                         else
47652:                             params[i] = GL_TRUE;
47652:                     }
47652: 
47652:                     delete [] intParams;
47652:                 }
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLenum pname = 0x%X, GLint* params = 0x%0.8p)", target, pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Buffer *buffer;
47652: 
47652:             switch (target)
47652:             {
47652:               case GL_ARRAY_BUFFER:
47652:                 buffer = context->getArrayBuffer();
47652:                 break;
47652:               case GL_ELEMENT_ARRAY_BUFFER:
47652:                 buffer = context->getElementArrayBuffer();
47652:                 break;
47652:               default: return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             if (!buffer)
47652:             {
47652:                 // A null buffer means that "0" is bound to the requested buffer target
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             switch (pname)
47652:             {
47652:               case GL_BUFFER_USAGE:
47652:                 *params = buffer->usage();
47652:                 break;
47652:               case GL_BUFFER_SIZE:
47652:                 *params = buffer->size();
47652:                 break;
47652:               default: return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: GLenum __stdcall glGetError(void)
47652: {
61598:     EVENT("()");
47652: 
47652:     gl::Context *context = gl::getContext();
47652: 
47652:     if (context)
47652:     {
47652:         return context->getError();
47652:     }
47652: 
47652:     return GL_NO_ERROR;
47652: }
47652: 
55266: void __stdcall glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
55266: {
61598:     EVENT("(GLuint fence = %d, GLenum pname = 0x%X, GLint *params = 0x%0.8p)", fence, pname, params);
55266: 
55266:     try
55266:     {
55266:     
55266:         gl::Context *context = gl::getContext();
55266: 
55266:         if (context)
55266:         {
55266:             gl::Fence *fenceObject = context->getFence(fence);
55266: 
55266:             if (fenceObject == NULL)
55266:             {
55266:                 return error(GL_INVALID_OPERATION);
55266:             }
55266: 
55266:             fenceObject->getFenceiv(pname, params);
55266:         }
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         return error(GL_OUT_OF_MEMORY);
55266:     }
55266: }
55266: 
47652: void __stdcall glGetFloatv(GLenum pname, GLfloat* params)
47652: {
61598:     EVENT("(GLenum pname = 0x%X, GLfloat* params = 0x%0.8p)", pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (!(context->getFloatv(pname, params)))
47652:             {
47652:                 GLenum nativeType;
47652:                 unsigned int numParams = 0;
47652:                 if (!context->getQueryParameterInfo(pname, &nativeType, &numParams))
47652:                     return error(GL_INVALID_ENUM);
47652: 
47652:                 if (numParams == 0)
47652:                     return; // it is known that the pname is valid, but that there are no parameters to return.
47652: 
47652:                 if (nativeType == GL_BOOL)
47652:                 {
47652:                     GLboolean *boolParams = NULL;
47652:                     boolParams = new GLboolean[numParams];
47652: 
47652:                     context->getBooleanv(pname, boolParams);
47652: 
47652:                     for (unsigned int i = 0; i < numParams; ++i)
47652:                     {
47652:                         if (boolParams[i] == GL_FALSE)
47652:                             params[i] = 0.0f;
47652:                         else
47652:                             params[i] = 1.0f;
47652:                     }
47652: 
47652:                     delete [] boolParams;
47652:                 }
47652:                 else if (nativeType == GL_INT)
47652:                 {
47652:                     GLint *intParams = NULL;
47652:                     intParams = new GLint[numParams];
47652: 
47652:                     context->getIntegerv(pname, intParams);
47652: 
47652:                     for (unsigned int i = 0; i < numParams; ++i)
47652:                     {
47652:                         params[i] = (GLfloat)intParams[i];
47652:                     }
47652: 
47652:                     delete [] intParams;
47652:                 }
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLenum attachment = 0x%X, GLenum pname = 0x%X, GLint* params = 0x%0.8p)",
47652:           target, attachment, pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
55266:             if (target != GL_FRAMEBUFFER && target != GL_DRAW_FRAMEBUFFER_ANGLE && target != GL_READ_FRAMEBUFFER_ANGLE)
55266:             {
55266:                 return error(GL_INVALID_ENUM);
55266:             }
55266: 
55266:             gl::Framebuffer *framebuffer = NULL;
55266:             if (target == GL_READ_FRAMEBUFFER_ANGLE)
55266:             {
55266:                 if(context->getReadFramebufferHandle() == 0)
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652: 
55266:                 framebuffer = context->getReadFramebuffer();
55266:             }
55266:             else 
55266:             {
55266:                 if (context->getDrawFramebufferHandle() == 0)
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
55266:                 framebuffer = context->getDrawFramebuffer();
47652:             }
47652: 
47652:             GLenum attachmentType;
47652:             GLuint attachmentHandle;
47652:             switch (attachment)
47652:             {
47652:               case GL_COLOR_ATTACHMENT0:    
55266:                 attachmentType = framebuffer->getColorbufferType();
55266:                 attachmentHandle = framebuffer->getColorbufferHandle(); 
47652:                 break;
47652:               case GL_DEPTH_ATTACHMENT:     
55266:                 attachmentType = framebuffer->getDepthbufferType();
55266:                 attachmentHandle = framebuffer->getDepthbufferHandle();
47652:                 break;
47652:               case GL_STENCIL_ATTACHMENT:   
55266:                 attachmentType = framebuffer->getStencilbufferType();
55266:                 attachmentHandle = framebuffer->getStencilbufferHandle();
47652:                 break;
47652:               default: return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             GLenum attachmentObjectType;   // Type category
47652:             if (attachmentType == GL_NONE || attachmentType == GL_RENDERBUFFER)
47652:             {
47652:                 attachmentObjectType = attachmentType;
47652:             }
47652:             else if (gl::IsTextureTarget(attachmentType))
47652:             {
47652:                 attachmentObjectType = GL_TEXTURE;
47652:             }
47652:             else UNREACHABLE();
47652: 
47652:             switch (pname)
47652:             {
47652:               case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
47652:                 *params = attachmentObjectType;
47652:                 break;
47652:               case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
47652:                 if (attachmentObjectType == GL_RENDERBUFFER || attachmentObjectType == GL_TEXTURE)
47652:                 {
47652:                     *params = attachmentHandle;
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_ENUM);
47652:                 }
47652:                 break;
47652:               case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
47652:                 if (attachmentObjectType == GL_TEXTURE)
47652:                 {
47652:                     *params = 0; // FramebufferTexture2D will not allow level to be set to anything else in GL ES 2.0
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_ENUM);
47652:                 }
47652:                 break;
47652:               case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
47652:                 if (attachmentObjectType == GL_TEXTURE)
47652:                 {
47652:                     if (gl::IsCubemapTextureTarget(attachmentType))
47652:                     {
47652:                         *params = attachmentType;
47652:                     }
47652:                     else
47652:                     {
47652:                         *params = 0;
47652:                     }
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_ENUM);
47652:                 }
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetIntegerv(GLenum pname, GLint* params)
47652: {
61598:     EVENT("(GLenum pname = 0x%X, GLint* params = 0x%0.8p)", pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (!(context->getIntegerv(pname, params)))
47652:             {
47652:                 GLenum nativeType;
47652:                 unsigned int numParams = 0;
47652:                 if (!context->getQueryParameterInfo(pname, &nativeType, &numParams))
47652:                     return error(GL_INVALID_ENUM);
47652: 
47652:                 if (numParams == 0)
47652:                     return; // it is known that pname is valid, but there are no parameters to return
47652: 
47652:                 if (nativeType == GL_BOOL)
47652:                 {
47652:                     GLboolean *boolParams = NULL;
47652:                     boolParams = new GLboolean[numParams];
47652: 
47652:                     context->getBooleanv(pname, boolParams);
47652: 
47652:                     for (unsigned int i = 0; i < numParams; ++i)
47652:                     {
47652:                         if (boolParams[i] == GL_FALSE)
47652:                             params[i] = 0;
47652:                         else
47652:                             params[i] = 1;
47652:                     }
47652: 
47652:                     delete [] boolParams;
47652:                 }
47652:                 else if (nativeType == GL_FLOAT)
47652:                 {
47652:                     GLfloat *floatParams = NULL;
47652:                     floatParams = new GLfloat[numParams];
47652: 
47652:                     context->getFloatv(pname, floatParams);
47652: 
47652:                     for (unsigned int i = 0; i < numParams; ++i)
47652:                     {
47652:                         if (pname == GL_DEPTH_RANGE || pname == GL_COLOR_CLEAR_VALUE || pname == GL_DEPTH_CLEAR_VALUE || pname == GL_BLEND_COLOR)
47652:                         {
47652:                             params[i] = (GLint)(((GLfloat)(0xFFFFFFFF) * floatParams[i] - 1.0f) / 2.0f);
47652:                         }
47652:                         else
47652:                             params[i] = (GLint)(floatParams[i] > 0.0f ? floor(floatParams[i] + 0.5) : ceil(floatParams[i] - 0.5));
47652:                     }
47652: 
47652:                     delete [] floatParams;
47652:                 }
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetProgramiv(GLuint program, GLenum pname, GLint* params)
47652: {
61598:     EVENT("(GLuint program = %d, GLenum pname = %d, GLint* params = 0x%0.8p)", program, pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             switch (pname)
47652:             {
47652:               case GL_DELETE_STATUS:
47652:                 *params = programObject->isFlaggedForDeletion();
47652:                 return;
47652:               case GL_LINK_STATUS:
47652:                 *params = programObject->isLinked();
47652:                 return;
47652:               case GL_VALIDATE_STATUS:
47652:                 *params = programObject->isValidated();
47652:                 return;
47652:               case GL_INFO_LOG_LENGTH:
47652:                 *params = programObject->getInfoLogLength();
47652:                 return;
47652:               case GL_ATTACHED_SHADERS:
47652:                 *params = programObject->getAttachedShadersCount();
47652:                 return;
47652:               case GL_ACTIVE_ATTRIBUTES:
47652:                 *params = programObject->getActiveAttributeCount();
47652:                 return;
47652:               case GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
47652:                 *params = programObject->getActiveAttributeMaxLength();
47652:                 return;
47652:               case GL_ACTIVE_UNIFORMS:
47652:                 *params = programObject->getActiveUniformCount();
47652:                 return;
47652:               case GL_ACTIVE_UNIFORM_MAX_LENGTH:
47652:                 *params = programObject->getActiveUniformMaxLength();
47652:                 return;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog)
47652: {
61598:     EVENT("(GLuint program = %d, GLsizei bufsize = %d, GLsizei* length = 0x%0.8p, GLchar* infolog = 0x%0.8p)",
47652:           program, bufsize, length, infolog);
47652: 
47652:     try
47652:     {
47652:         if (bufsize < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             programObject->getInfoLog(bufsize, length, infolog);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLenum pname = 0x%X, GLint* params = 0x%0.8p)", target, pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (target != GL_RENDERBUFFER)
47652:             {
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             if (context->getRenderbufferHandle() == 0)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             gl::Renderbuffer *renderbuffer = context->getRenderbuffer(context->getRenderbufferHandle());
47652: 
47652:             switch (pname)
47652:             {
70456:               case GL_RENDERBUFFER_WIDTH:           *params = renderbuffer->getWidth();          break;
70456:               case GL_RENDERBUFFER_HEIGHT:          *params = renderbuffer->getHeight();         break;
70456:               case GL_RENDERBUFFER_INTERNAL_FORMAT: *params = renderbuffer->getInternalFormat(); break;
70456:               case GL_RENDERBUFFER_RED_SIZE:        *params = renderbuffer->getRedSize();        break;
70456:               case GL_RENDERBUFFER_GREEN_SIZE:      *params = renderbuffer->getGreenSize();      break;
70456:               case GL_RENDERBUFFER_BLUE_SIZE:       *params = renderbuffer->getBlueSize();       break;
70456:               case GL_RENDERBUFFER_ALPHA_SIZE:      *params = renderbuffer->getAlphaSize();      break;
70456:               case GL_RENDERBUFFER_DEPTH_SIZE:      *params = renderbuffer->getDepthSize();      break;
70456:               case GL_RENDERBUFFER_STENCIL_SIZE:    *params = renderbuffer->getStencilSize();    break;
70456:               case GL_RENDERBUFFER_SAMPLES_ANGLE:
70456:                 if (context->getMaxSupportedSamples() != 0)
70456:                 {
70456:                     *params = renderbuffer->getSamples();
47652:                 }
47652:                 else
47652:                 {
55266:                     return error(GL_INVALID_ENUM);
55266:                 }
55266:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetShaderiv(GLuint shader, GLenum pname, GLint* params)
47652: {
61598:     EVENT("(GLuint shader = %d, GLenum pname = %d, GLint* params = 0x%0.8p)", shader, pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Shader *shaderObject = context->getShader(shader);
47652: 
47652:             if (!shaderObject)
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             switch (pname)
47652:             {
47652:               case GL_SHADER_TYPE:
47652:                 *params = shaderObject->getType();
47652:                 return;
47652:               case GL_DELETE_STATUS:
47652:                 *params = shaderObject->isFlaggedForDeletion();
47652:                 return;
47652:               case GL_COMPILE_STATUS:
47652:                 *params = shaderObject->isCompiled() ? GL_TRUE : GL_FALSE;
47652:                 return;
47652:               case GL_INFO_LOG_LENGTH:
47652:                 *params = shaderObject->getInfoLogLength();
47652:                 return;
47652:               case GL_SHADER_SOURCE_LENGTH:
47652:                 *params = shaderObject->getSourceLength();
47652:                 return;
80841:               case GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE:
80841:                 *params = shaderObject->getTranslatedSourceLength();
80841:                 return;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog)
47652: {
61598:     EVENT("(GLuint shader = %d, GLsizei bufsize = %d, GLsizei* length = 0x%0.8p, GLchar* infolog = 0x%0.8p)",
47652:           shader, bufsize, length, infolog);
47652: 
47652:     try
47652:     {
47652:         if (bufsize < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Shader *shaderObject = context->getShader(shader);
47652: 
47652:             if (!shaderObject)
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             shaderObject->getInfoLog(bufsize, length, infolog);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision)
47652: {
61598:     EVENT("(GLenum shadertype = 0x%X, GLenum precisiontype = 0x%X, GLint* range = 0x%0.8p, GLint* precision = 0x%0.8p)",
47652:           shadertype, precisiontype, range, precision);
47652: 
47652:     try
47652:     {
47652:         switch (shadertype)
47652:         {
47652:           case GL_VERTEX_SHADER:
47652:           case GL_FRAGMENT_SHADER:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (precisiontype)
47652:         {
47652:           case GL_LOW_FLOAT:
47652:           case GL_MEDIUM_FLOAT:
47652:           case GL_HIGH_FLOAT:
47652:             // Assume IEEE 754 precision
47652:             range[0] = 127;
47652:             range[1] = 127;
47652:             *precision = 23;
47652:             break;
47652:           case GL_LOW_INT:
47652:           case GL_MEDIUM_INT:
47652:           case GL_HIGH_INT:
47652:             // Some (most) hardware only supports single-precision floating-point numbers,
47652:             // which can accurately represent integers up to +/-16777216
47652:             range[0] = 24;
47652:             range[1] = 24;
47652:             *precision = 0;
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
47652: {
61598:     EVENT("(GLuint shader = %d, GLsizei bufsize = %d, GLsizei* length = 0x%0.8p, GLchar* source = 0x%0.8p)",
47652:           shader, bufsize, length, source);
47652: 
47652:     try
47652:     {
47652:         if (bufsize < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Shader *shaderObject = context->getShader(shader);
47652: 
47652:             if (!shaderObject)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             shaderObject->getSource(bufsize, length, source);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
80841: void __stdcall glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
80841: {
80841:     EVENT("(GLuint shader = %d, GLsizei bufsize = %d, GLsizei* length = 0x%0.8p, GLchar* source = 0x%0.8p)",
80841:           shader, bufsize, length, source);
80841: 
80841:     try
80841:     {
80841:         if (bufsize < 0)
80841:         {
80841:             return error(GL_INVALID_VALUE);
80841:         }
80841: 
80841:         gl::Context *context = gl::getContext();
80841: 
80841:         if (context)
80841:         {
80841:             gl::Shader *shaderObject = context->getShader(shader);
80841: 
80841:             if (!shaderObject)
80841:             {
80841:                 return error(GL_INVALID_OPERATION);
80841:             }
80841: 
80841:             shaderObject->getTranslatedSource(bufsize, length, source);
80841:         }
80841:     }
80841:     catch(std::bad_alloc&)
80841:     {
80841:         return error(GL_OUT_OF_MEMORY);
80841:     }
80841: }
80841: 
47652: const GLubyte* __stdcall glGetString(GLenum name)
47652: {
61598:     EVENT("(GLenum name = 0x%X)", name);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         switch (name)
47652:         {
47652:           case GL_VENDOR:
61598:             return (GLubyte*)"Google Inc.";
47652:           case GL_RENDERER:
77552:             return (GLubyte*)((context != NULL) ? context->getRendererString() : "ANGLE");
47652:           case GL_VERSION:
61598:             return (GLubyte*)"OpenGL ES 2.0 (ANGLE "VERSION_STRING")";
47652:           case GL_SHADING_LANGUAGE_VERSION:
61598:             return (GLubyte*)"OpenGL ES GLSL ES 1.00 (ANGLE "VERSION_STRING")";
47652:           case GL_EXTENSIONS:
47652:             return (GLubyte*)((context != NULL) ? context->getExtensionString() : "");
47652:           default:
47652:             return error(GL_INVALID_ENUM, (GLubyte*)NULL);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, (GLubyte*)NULL);
47652:     }
47652: 
47652:     return NULL;
47652: }
47652: 
47652: void __stdcall glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLenum pname = 0x%X, GLfloat* params = 0x%0.8p)", target, pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Texture *texture;
47652: 
47652:             switch (target)
47652:             {
47652:               case GL_TEXTURE_2D:
47652:                 texture = context->getTexture2D();
47652:                 break;
47652:               case GL_TEXTURE_CUBE_MAP:
47652:                 texture = context->getTextureCubeMap();
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             switch (pname)
47652:             {
47652:               case GL_TEXTURE_MAG_FILTER:
47652:                 *params = (GLfloat)texture->getMagFilter();
47652:                 break;
47652:               case GL_TEXTURE_MIN_FILTER:
47652:                 *params = (GLfloat)texture->getMinFilter();
47652:                 break;
47652:               case GL_TEXTURE_WRAP_S:
47652:                 *params = (GLfloat)texture->getWrapS();
47652:                 break;
47652:               case GL_TEXTURE_WRAP_T:
47652:                 *params = (GLfloat)texture->getWrapT();
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetTexParameteriv(GLenum target, GLenum pname, GLint* params)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLenum pname = 0x%X, GLint* params = 0x%0.8p)", target, pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Texture *texture;
47652: 
47652:             switch (target)
47652:             {
47652:               case GL_TEXTURE_2D:
47652:                 texture = context->getTexture2D();
47652:                 break;
47652:               case GL_TEXTURE_CUBE_MAP:
47652:                 texture = context->getTextureCubeMap();
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             switch (pname)
47652:             {
47652:               case GL_TEXTURE_MAG_FILTER:
47652:                 *params = texture->getMagFilter();
47652:                 break;
47652:               case GL_TEXTURE_MIN_FILTER:
47652:                 *params = texture->getMinFilter();
47652:                 break;
47652:               case GL_TEXTURE_WRAP_S:
47652:                 *params = texture->getWrapS();
47652:                 break;
47652:               case GL_TEXTURE_WRAP_T:
47652:                 *params = texture->getWrapT();
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetUniformfv(GLuint program, GLint location, GLfloat* params)
47652: {
61598:     EVENT("(GLuint program = %d, GLint location = %d, GLfloat* params = 0x%0.8p)", program, location, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (program == 0)
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject || !programObject->isLinked())
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!programObject->getUniformfv(location, params))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetUniformiv(GLuint program, GLint location, GLint* params)
47652: {
61598:     EVENT("(GLuint program = %d, GLint location = %d, GLint* params = 0x%0.8p)", program, location, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (program == 0)
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject || !programObject->isLinked())
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!programObject)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!programObject->getUniformiv(location, params))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: int __stdcall glGetUniformLocation(GLuint program, const GLchar* name)
47652: {
61598:     EVENT("(GLuint program = %d, const GLchar* name = 0x%0.8p)", program, name);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (strstr(name, "gl_") == name)
47652:         {
47652:             return -1;
47652:         }
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION, -1);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE, -1);
47652:                 }
47652:             }
47652: 
47652:             if (!programObject->isLinked())
47652:             {
47652:                 return error(GL_INVALID_OPERATION, -1);
47652:             }
47652: 
79597:             return programObject->getUniformLocation(name);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, -1);
47652:     }
47652: 
47652:     return -1;
47652: }
47652: 
47652: void __stdcall glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params)
47652: {
61598:     EVENT("(GLuint index = %d, GLenum pname = 0x%X, GLfloat* params = 0x%0.8p)", index, pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
61598:             const gl::VertexAttribute &attribState = context->getVertexAttribState(index);
47652: 
47652:             switch (pname)
47652:             {
47652:               case GL_VERTEX_ATTRIB_ARRAY_ENABLED:
61598:                 *params = (GLfloat)(attribState.mArrayEnabled ? GL_TRUE : GL_FALSE);
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_SIZE:
47652:                 *params = (GLfloat)attribState.mSize;
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_STRIDE:
47652:                 *params = (GLfloat)attribState.mStride;
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_TYPE:
47652:                 *params = (GLfloat)attribState.mType;
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
47652:                 *params = (GLfloat)(attribState.mNormalized ? GL_TRUE : GL_FALSE);
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
48434:                 *params = (GLfloat)attribState.mBoundBuffer.id();
47652:                 break;
47652:               case GL_CURRENT_VERTEX_ATTRIB:
47652:                 for (int i = 0; i < 4; ++i)
47652:                 {
47652:                     params[i] = attribState.mCurrentValue[i];
47652:                 }
47652:                 break;
47652:               default: return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params)
47652: {
61598:     EVENT("(GLuint index = %d, GLenum pname = 0x%X, GLint* params = 0x%0.8p)", index, pname, params);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
61598:             const gl::VertexAttribute &attribState = context->getVertexAttribState(index);
47652: 
47652:             switch (pname)
47652:             {
47652:               case GL_VERTEX_ATTRIB_ARRAY_ENABLED:
61598:                 *params = (attribState.mArrayEnabled ? GL_TRUE : GL_FALSE);
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_SIZE:
47652:                 *params = attribState.mSize;
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_STRIDE:
47652:                 *params = attribState.mStride;
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_TYPE:
47652:                 *params = attribState.mType;
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
47652:                 *params = (attribState.mNormalized ? GL_TRUE : GL_FALSE);
47652:                 break;
47652:               case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
48434:                 *params = attribState.mBoundBuffer.id();
47652:                 break;
47652:               case GL_CURRENT_VERTEX_ATTRIB:
47652:                 for (int i = 0; i < 4; ++i)
47652:                 {
47652:                     float currentValue = attribState.mCurrentValue[i];
47652:                     params[i] = (GLint)(currentValue > 0.0f ? floor(currentValue + 0.5f) : ceil(currentValue - 0.5f));
47652:                 }
47652:                 break;
47652:               default: return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer)
47652: {
61598:     EVENT("(GLuint index = %d, GLenum pname = 0x%X, GLvoid** pointer = 0x%0.8p)", index, pname, pointer);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:             {
47652:                 return error(GL_INVALID_VALUE);
47652:             }
47652: 
47652:             if (pname != GL_VERTEX_ATTRIB_ARRAY_POINTER)
47652:             {
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             *pointer = const_cast<GLvoid*>(context->getVertexAttribPointer(index));
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glHint(GLenum target, GLenum mode)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLenum mode = 0x%X)", target, mode);
47652: 
47652:     try
47652:     {
47652:         switch (mode)
47652:         {
47652:           case GL_FASTEST:
47652:           case GL_NICEST:
47652:           case GL_DONT_CARE:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM); 
47652:         }
55266: 
55266:         gl::Context *context = gl::getContext();
55266:         switch (target)
55266:         {
55266:           case GL_GENERATE_MIPMAP_HINT:
55266:             if (context) context->setGenerateMipmapHint(mode);
55266:             break;
55266:           case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES:
55266:             if (context) context->setFragmentShaderDerivativeHint(mode);
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: GLboolean __stdcall glIsBuffer(GLuint buffer)
47652: {
61598:     EVENT("(GLuint buffer = %d)", buffer);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context && buffer)
47652:         {
47652:             gl::Buffer *bufferObject = context->getBuffer(buffer);
47652: 
47652:             if (bufferObject)
47652:             {
47652:                 return GL_TRUE;
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, GL_FALSE);
47652:     }
47652: 
47652:     return GL_FALSE;
47652: }
47652: 
47652: GLboolean __stdcall glIsEnabled(GLenum cap)
47652: {
61598:     EVENT("(GLenum cap = 0x%X)", cap);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             switch (cap)
47652:             {
47652:               case GL_CULL_FACE:                return context->isCullFaceEnabled();
47652:               case GL_POLYGON_OFFSET_FILL:      return context->isPolygonOffsetFillEnabled();
47652:               case GL_SAMPLE_ALPHA_TO_COVERAGE: return context->isSampleAlphaToCoverageEnabled();
47652:               case GL_SAMPLE_COVERAGE:          return context->isSampleCoverageEnabled();
47652:               case GL_SCISSOR_TEST:             return context->isScissorTestEnabled();
47652:               case GL_STENCIL_TEST:             return context->isStencilTestEnabled();
47652:               case GL_DEPTH_TEST:               return context->isDepthTestEnabled();
47652:               case GL_BLEND:                    return context->isBlendEnabled();
47652:               case GL_DITHER:                   return context->isDitherEnabled();
47652:               default:
47652:                 return error(GL_INVALID_ENUM, false);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, false);
47652:     }
47652: 
47652:     return false;
47652: }
47652: 
55266: GLboolean __stdcall glIsFenceNV(GLuint fence)
55266: {
61598:     EVENT("(GLuint fence = %d)", fence);
55266: 
55266:     try
55266:     {
55266:         gl::Context *context = gl::getContext();
55266: 
55266:         if (context)
55266:         {
55266:             gl::Fence *fenceObject = context->getFence(fence);
55266: 
55266:             if (fenceObject == NULL)
55266:             {
55266:                 return GL_FALSE;
55266:             }
55266: 
55266:             return fenceObject->isFence();
55266:         }
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         return error(GL_OUT_OF_MEMORY, GL_FALSE);
55266:     }
55266: 
55266:     return GL_FALSE;
55266: }
55266: 
47652: GLboolean __stdcall glIsFramebuffer(GLuint framebuffer)
47652: {
61598:     EVENT("(GLuint framebuffer = %d)", framebuffer);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context && framebuffer)
47652:         {
47652:             gl::Framebuffer *framebufferObject = context->getFramebuffer(framebuffer);
47652: 
47652:             if (framebufferObject)
47652:             {
47652:                 return GL_TRUE;
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, GL_FALSE);
47652:     }
47652: 
47652:     return GL_FALSE;
47652: }
47652: 
47652: GLboolean __stdcall glIsProgram(GLuint program)
47652: {
61598:     EVENT("(GLuint program = %d)", program);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context && program)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (programObject)
47652:             {
47652:                 return GL_TRUE;
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, GL_FALSE);
47652:     }
47652: 
47652:     return GL_FALSE;
47652: }
47652: 
47652: GLboolean __stdcall glIsRenderbuffer(GLuint renderbuffer)
47652: {
61598:     EVENT("(GLuint renderbuffer = %d)", renderbuffer);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context && renderbuffer)
47652:         {
47652:             gl::Renderbuffer *renderbufferObject = context->getRenderbuffer(renderbuffer);
47652: 
47652:             if (renderbufferObject)
47652:             {
47652:                 return GL_TRUE;
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, GL_FALSE);
47652:     }
47652: 
47652:     return GL_FALSE;
47652: }
47652: 
47652: GLboolean __stdcall glIsShader(GLuint shader)
47652: {
61598:     EVENT("(GLuint shader = %d)", shader);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context && shader)
47652:         {
47652:             gl::Shader *shaderObject = context->getShader(shader);
47652: 
47652:             if (shaderObject)
47652:             {
47652:                 return GL_TRUE;
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, GL_FALSE);
47652:     }
47652: 
47652:     return GL_FALSE;
47652: }
47652: 
47652: GLboolean __stdcall glIsTexture(GLuint texture)
47652: {
61598:     EVENT("(GLuint texture = %d)", texture);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context && texture)
47652:         {
47652:             gl::Texture *textureObject = context->getTexture(texture);
47652: 
47652:             if (textureObject)
47652:             {
47652:                 return GL_TRUE;
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY, GL_FALSE);
47652:     }
47652: 
47652:     return GL_FALSE;
47652: }
47652: 
47652: void __stdcall glLineWidth(GLfloat width)
47652: {
61598:     EVENT("(GLfloat width = %f)", width);
47652: 
47652:     try
47652:     {
47652:         if (width <= 0.0f)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setLineWidth(width);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glLinkProgram(GLuint program)
47652: {
61598:     EVENT("(GLuint program = %d)", program);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             programObject->link();
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glPixelStorei(GLenum pname, GLint param)
47652: {
61598:     EVENT("(GLenum pname = 0x%X, GLint param = %d)", pname, param);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             switch (pname)
47652:             {
47652:               case GL_UNPACK_ALIGNMENT:
47652:                 if (param != 1 && param != 2 && param != 4 && param != 8)
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652: 
47652:                 context->setUnpackAlignment(param);
47652:                 break;
47652: 
47652:               case GL_PACK_ALIGNMENT:
47652:                 if (param != 1 && param != 2 && param != 4 && param != 8)
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652: 
47652:                 context->setPackAlignment(param);
47652:                 break;
47652: 
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glPolygonOffset(GLfloat factor, GLfloat units)
47652: {
61598:     EVENT("(GLfloat factor = %f, GLfloat units = %f)", factor, units);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setPolygonOffsetParams(factor, units);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
47652: {
61598:     EVENT("(GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d, "
47652:           "GLenum format = 0x%X, GLenum type = 0x%X, GLvoid* pixels = 0x%0.8p)",
47652:           x, y, width, height, format, type,  pixels);
47652: 
47652:     try
47652:     {
47652:         if (width < 0 || height < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         switch (format)
47652:         {
47652:           case GL_RGBA:
47652:             switch (type)
47652:             {
47652:               case GL_UNSIGNED_BYTE:
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:             break;
51844:           case GL_BGRA_EXT:
51844:             switch (type)
51844:             {
51844:               case GL_UNSIGNED_BYTE:
51844:               case GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT:
51844:               case GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT:
51844:                 break;
51844:               default:
51844:                 return error(GL_INVALID_OPERATION);
51844:             }
51844:             break;
47652:           case gl::IMPLEMENTATION_COLOR_READ_FORMAT:
47652:             switch (type)
47652:             {
47652:               case gl::IMPLEMENTATION_COLOR_READ_TYPE:
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_OPERATION);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->readPixels(x, y, width, height, format, type, pixels);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glReleaseShaderCompiler(void)
47652: {
61598:     EVENT("()");
47652: 
47652:     try
47652:     {
47652:         gl::Shader::releaseCompiler();
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
55266: void __stdcall glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
55266: {
61598:     EVENT("(GLenum target = 0x%X, GLsizei samples = %d, GLenum internalformat = 0x%X, GLsizei width = %d, GLsizei height = %d)",
55266:           target, samples, internalformat, width, height);
47652: 
47652:     try
47652:     {
47652:         switch (target)
47652:         {
47652:           case GL_RENDERBUFFER:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
58582:         if (!gl::IsColorRenderable(internalformat) && !gl::IsDepthRenderable(internalformat) && !gl::IsStencilRenderable(internalformat))
58582:         {
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
58582:         if (width < 0 || height < 0 || samples < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
58582:             if (width > context->getMaximumRenderbufferDimension() || 
58582:                 height > context->getMaximumRenderbufferDimension() ||
58582:                 samples > context->getMaxSupportedSamples())
55266:             {
55266:                 return error(GL_INVALID_VALUE);
55266:             }
55266: 
48434:             GLuint handle = context->getRenderbufferHandle();
48434:             if (handle == 0)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             switch (internalformat)
47652:             {
47652:               case GL_DEPTH_COMPONENT16:
55266:                 context->setRenderbufferStorage(new gl::Depthbuffer(width, height, samples));
47652:                 break;
47652:               case GL_RGBA4:
47652:               case GL_RGB5_A1:
47652:               case GL_RGB565:
55266:               case GL_RGB8_OES:
55266:               case GL_RGBA8_OES:
55266:                 context->setRenderbufferStorage(new gl::Colorbuffer(width, height, internalformat, samples));
47652:                 break;
47652:               case GL_STENCIL_INDEX8:
55266:                 context->setRenderbufferStorage(new gl::Stencilbuffer(width, height, samples));
48434:                 break;
48434:               case GL_DEPTH24_STENCIL8_OES:
55266:                 context->setRenderbufferStorage(new gl::DepthStencilbuffer(width, height, samples));
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
55266: void __stdcall glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
55266: {
55266:     glRenderbufferStorageMultisampleANGLE(target, 0, internalformat, width, height);
55266: }
55266: 
47652: void __stdcall glSampleCoverage(GLclampf value, GLboolean invert)
47652: {
61598:     EVENT("(GLclampf value = %f, GLboolean invert = %d)", value, invert);
47652: 
47652:     try
47652:     {
47652:         gl::Context* context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setSampleCoverageParams(gl::clamp01(value), invert == GL_TRUE);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
55266: void __stdcall glSetFenceNV(GLuint fence, GLenum condition)
55266: {
61598:     EVENT("(GLuint fence = %d, GLenum condition = 0x%X)", fence, condition);
55266: 
55266:     try
55266:     {
55266:         if (condition != GL_ALL_COMPLETED_NV)
55266:         {
55266:             return error(GL_INVALID_ENUM);
55266:         }
55266: 
55266:         gl::Context *context = gl::getContext();
55266: 
55266:         if (context)
55266:         {
55266:             gl::Fence *fenceObject = context->getFence(fence);
55266: 
55266:             if (fenceObject == NULL)
55266:             {
55266:                 return error(GL_INVALID_OPERATION);
55266:             }
55266: 
55266:             fenceObject->setFence(condition);    
55266:         }
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         return error(GL_OUT_OF_MEMORY);
55266:     }
55266: }
55266: 
47652: void __stdcall glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
47652: {
61598:     EVENT("(GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d)", x, y, width, height);
47652: 
47652:     try
47652:     {
47652:         if (width < 0 || height < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context* context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setScissorParams(x, y, width, height);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glShaderBinary(GLsizei n, const GLuint* shaders, GLenum binaryformat, const GLvoid* binary, GLsizei length)
47652: {
61598:     EVENT("(GLsizei n = %d, const GLuint* shaders = 0x%0.8p, GLenum binaryformat = 0x%X, "
47652:           "const GLvoid* binary = 0x%0.8p, GLsizei length = %d)",
47652:           n, shaders, binaryformat, binary, length);
47652: 
47652:     try
47652:     {
47652:         // No binary shader formats are supported.
47652:         return error(GL_INVALID_ENUM);
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glShaderSource(GLuint shader, GLsizei count, const GLchar** string, const GLint* length)
47652: {
61598:     EVENT("(GLuint shader = %d, GLsizei count = %d, const GLchar** string = 0x%0.8p, const GLint* length = 0x%0.8p)",
47652:           shader, count, string, length);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Shader *shaderObject = context->getShader(shader);
47652: 
47652:             if (!shaderObject)
47652:             {
47652:                 if (context->getProgram(shader))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             shaderObject->setSource(count, string, length);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glStencilFunc(GLenum func, GLint ref, GLuint mask)
47652: {
47652:     glStencilFuncSeparate(GL_FRONT_AND_BACK, func, ref, mask);
47652: }
47652: 
47652: void __stdcall glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
47652: {
61598:     EVENT("(GLenum face = 0x%X, GLenum func = 0x%X, GLint ref = %d, GLuint mask = %d)", face, func, ref, mask);
47652: 
47652:     try
47652:     {
47652:         switch (face)
47652:         {
47652:           case GL_FRONT:
47652:           case GL_BACK:
47652:           case GL_FRONT_AND_BACK:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (func)
47652:         {
47652:           case GL_NEVER:
47652:           case GL_ALWAYS:
47652:           case GL_LESS:
47652:           case GL_LEQUAL:
47652:           case GL_EQUAL:
47652:           case GL_GEQUAL:
47652:           case GL_GREATER:
47652:           case GL_NOTEQUAL:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (face == GL_FRONT || face == GL_FRONT_AND_BACK)
47652:             {
47652:                 context->setStencilParams(func, ref, mask);
47652:             }
47652: 
47652:             if (face == GL_BACK || face == GL_FRONT_AND_BACK)
47652:             {
47652:                 context->setStencilBackParams(func, ref, mask);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glStencilMask(GLuint mask)
47652: {
47652:     glStencilMaskSeparate(GL_FRONT_AND_BACK, mask);
47652: }
47652: 
47652: void __stdcall glStencilMaskSeparate(GLenum face, GLuint mask)
47652: {
61598:     EVENT("(GLenum face = 0x%X, GLuint mask = %d)", face, mask);
47652: 
47652:     try
47652:     {
47652:         switch (face)
47652:         {
47652:           case GL_FRONT:
47652:           case GL_BACK:
47652:           case GL_FRONT_AND_BACK:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (face == GL_FRONT || face == GL_FRONT_AND_BACK)
47652:             {
47652:                 context->setStencilWritemask(mask);
47652:             }
47652: 
47652:             if (face == GL_BACK || face == GL_FRONT_AND_BACK)
47652:             {
47652:                 context->setStencilBackWritemask(mask);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
47652: {
47652:     glStencilOpSeparate(GL_FRONT_AND_BACK, fail, zfail, zpass);
47652: }
47652: 
47652: void __stdcall glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
47652: {
61598:     EVENT("(GLenum face = 0x%X, GLenum fail = 0x%X, GLenum zfail = 0x%X, GLenum zpas = 0x%Xs)",
47652:           face, fail, zfail, zpass);
47652: 
47652:     try
47652:     {
47652:         switch (face)
47652:         {
47652:           case GL_FRONT:
47652:           case GL_BACK:
47652:           case GL_FRONT_AND_BACK:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (fail)
47652:         {
47652:           case GL_ZERO:
47652:           case GL_KEEP:
47652:           case GL_REPLACE:
47652:           case GL_INCR:
47652:           case GL_DECR:
47652:           case GL_INVERT:
47652:           case GL_INCR_WRAP:
47652:           case GL_DECR_WRAP:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (zfail)
47652:         {
47652:           case GL_ZERO:
47652:           case GL_KEEP:
47652:           case GL_REPLACE:
47652:           case GL_INCR:
47652:           case GL_DECR:
47652:           case GL_INVERT:
47652:           case GL_INCR_WRAP:
47652:           case GL_DECR_WRAP:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         switch (zpass)
47652:         {
47652:           case GL_ZERO:
47652:           case GL_KEEP:
47652:           case GL_REPLACE:
47652:           case GL_INCR:
47652:           case GL_DECR:
47652:           case GL_INVERT:
47652:           case GL_INCR_WRAP:
47652:           case GL_DECR_WRAP:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             if (face == GL_FRONT || face == GL_FRONT_AND_BACK)
47652:             {
47652:                 context->setStencilOperations(fail, zfail, zpass);
47652:             }
47652: 
47652:             if (face == GL_BACK || face == GL_FRONT_AND_BACK)
47652:             {
47652:                 context->setStencilBackOperations(fail, zfail, zpass);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
55266: GLboolean __stdcall glTestFenceNV(GLuint fence)
55266: {
61598:     EVENT("(GLuint fence = %d)", fence);
55266: 
55266:     try
55266:     {
55266:         gl::Context *context = gl::getContext();
55266: 
55266:         if (context)
55266:         {
55266:             gl::Fence *fenceObject = context->getFence(fence);
55266: 
55266:             if (fenceObject == NULL)
55266:             {
55266:                 return error(GL_INVALID_OPERATION, GL_TRUE);
55266:             }
55266: 
55266:             return fenceObject->testFence();
55266:         }
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         error(GL_OUT_OF_MEMORY);
55266:     }
55266:     
55266:     return GL_TRUE;
55266: }
55266: 
47652: void __stdcall glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height,
47652:                             GLint border, GLenum format, GLenum type, const GLvoid* pixels)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLint level = %d, GLint internalformat = %d, GLsizei width = %d, GLsizei height = %d, "
47652:           "GLint border = %d, GLenum format = 0x%X, GLenum type = 0x%X, const GLvoid* pixels =  0x%0.8p)",
47652:           target, level, internalformat, width, height, border, format, type, pixels);
47652: 
47652:     try
47652:     {
71571:         if (!validImageSize(level, width, height))
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
58582:         if (internalformat != format)
58582:         {
58582:             return error(GL_INVALID_OPERATION);
58582:         }
58582: 
70456:         switch (format)
58582:         {
58582:           case GL_ALPHA:
58582:           case GL_LUMINANCE:
58582:           case GL_LUMINANCE_ALPHA:
58582:             switch (type)
58582:             {
58582:               case GL_UNSIGNED_BYTE:
58582:               case GL_FLOAT:
58582:               case GL_HALF_FLOAT_OES:
58582:                 break;
58582:               default:
58582:                 return error(GL_INVALID_ENUM);
58582:             }
58582:             break;
58582:           case GL_RGB:
58582:             switch (type)
58582:             {
58582:               case GL_UNSIGNED_BYTE:
58582:               case GL_UNSIGNED_SHORT_5_6_5:
58582:               case GL_FLOAT:
58582:               case GL_HALF_FLOAT_OES:
58582:                 break;
58582:               default:
58582:                 return error(GL_INVALID_ENUM);
58582:             }
58582:             break;
58582:           case GL_RGBA:
58582:             switch (type)
58582:             {
58582:               case GL_UNSIGNED_BYTE:
58582:               case GL_UNSIGNED_SHORT_4_4_4_4:
58582:               case GL_UNSIGNED_SHORT_5_5_5_1:
58582:               case GL_FLOAT:
58582:               case GL_HALF_FLOAT_OES:
58582:                 break;
58582:               default:
58582:                 return error(GL_INVALID_ENUM);
58582:             }
58582:             break;
58582:           case GL_BGRA_EXT:
58582:             switch (type)
58582:             {
58582:               case GL_UNSIGNED_BYTE:
58582:                 break;
58582:               default:
58582:                 return error(GL_INVALID_ENUM);
58582:             }
58582:             break;
58582:           case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:  // error cases for compressed textures are handled below
58582:           case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
77552:           case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
77552:           case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
58582:             break; 
58582:           default:
58582:             return error(GL_INVALID_VALUE);
58582:         }
58582: 
58582:         if (border != 0)
58582:         {
58582:             return error(GL_INVALID_VALUE);
58582:         }
58582: 
58582:         gl::Context *context = gl::getContext();
58582: 
58582:         if (context)
58582:         {
81795:             if (level > context->getMaximumTextureLevel())
81795:             {
81795:                 return error(GL_INVALID_VALUE);
81795:             }
81795: 
47652:             switch (target)
47652:             {
47652:               case GL_TEXTURE_2D:
58582:                 if (width > (context->getMaximumTextureDimension() >> level) ||
58582:                     height > (context->getMaximumTextureDimension() >> level))
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:                 break;
47652:               case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
47652:               case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
47652:               case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
47652:               case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
47652:               case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
47652:               case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
47652:                 if (width != height)
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652: 
58582:                 if (width > (context->getMaximumCubeTextureDimension() >> level) ||
58582:                     height > (context->getMaximumCubeTextureDimension() >> level))
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
77552:             switch (format) {
77552:               case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
77552:                 if (context->supportsDXT1Textures())
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266:                 else
55266:                 {
55266:                     return error(GL_INVALID_ENUM);
55266:                 }
77552:                 break;
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE:
77552:                 if (context->supportsDXT3Textures())
77552:                 {
77552:                     return error(GL_INVALID_OPERATION);
77552:                 }
77552:                 else
77552:                 {
77552:                     return error(GL_INVALID_ENUM);
77552:                 }
77552:                 break;
77552:               case GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE:
77552:                 if (context->supportsDXT5Textures())
77552:                 {
77552:                     return error(GL_INVALID_OPERATION);
77552:                 }
77552:                 else
77552:                 {
77552:                     return error(GL_INVALID_ENUM);
77552:                 }
77552:                 break;
77552:               default:
77552:                 break;
55266:             }
55266: 
55266:             if (type == GL_FLOAT)
55266:             {
55266:                 if (!context->supportsFloatTextures())
55266:                 {
55266:                     return error(GL_INVALID_ENUM);
55266:                 }
55266:             }
55266:             else if (type == GL_HALF_FLOAT_OES)
55266:             {
55266:                 if (!context->supportsHalfFloatTextures())
55266:                 {
55266:                     return error(GL_INVALID_ENUM);
55266:                 }
55266:             }
55266: 
47652:             if (target == GL_TEXTURE_2D)
47652:             {
47652:                 gl::Texture2D *texture = context->getTexture2D();
47652: 
47652:                 if (!texture)
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652: 
70456:                 texture->setImage(level, width, height, format, type, context->getUnpackAlignment(), pixels);
47652:             }
47652:             else
47652:             {
47652:                 gl::TextureCubeMap *texture = context->getTextureCubeMap();
47652: 
47652:                 if (!texture)
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652: 
47652:                 switch (target)
47652:                 {
47652:                   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
70456:                     texture->setImagePosX(level, width, height, format, type, context->getUnpackAlignment(), pixels);
47652:                     break;
47652:                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
70456:                     texture->setImageNegX(level, width, height, format, type, context->getUnpackAlignment(), pixels);
47652:                     break;
47652:                   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
70456:                     texture->setImagePosY(level, width, height, format, type, context->getUnpackAlignment(), pixels);
47652:                     break;
47652:                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
70456:                     texture->setImageNegY(level, width, height, format, type, context->getUnpackAlignment(), pixels);
47652:                     break;
47652:                   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
70456:                     texture->setImagePosZ(level, width, height, format, type, context->getUnpackAlignment(), pixels);
47652:                     break;
47652:                   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
70456:                     texture->setImageNegZ(level, width, height, format, type, context->getUnpackAlignment(), pixels);
47652:                     break;
47652:                   default: UNREACHABLE();
47652:                 }
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glTexParameterf(GLenum target, GLenum pname, GLfloat param)
47652: {
47652:     glTexParameteri(target, pname, (GLint)param);
47652: }
47652: 
47652: void __stdcall glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params)
47652: {
47652:     glTexParameteri(target, pname, (GLint)*params);
47652: }
47652: 
47652: void __stdcall glTexParameteri(GLenum target, GLenum pname, GLint param)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLenum pname = 0x%X, GLint param = %d)", target, pname, param);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Texture *texture;
47652: 
47652:             switch (target)
47652:             {
47652:               case GL_TEXTURE_2D:
47652:                 texture = context->getTexture2D();
47652:                 break;
47652:               case GL_TEXTURE_CUBE_MAP:
47652:                 texture = context->getTextureCubeMap();
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652: 
47652:             switch (pname)
47652:             {
47652:               case GL_TEXTURE_WRAP_S:
47652:                 if (!texture->setWrapS((GLenum)param))
47652:                 {
47652:                     return error(GL_INVALID_ENUM);
47652:                 }
47652:                 break;
47652:               case GL_TEXTURE_WRAP_T:
47652:                 if (!texture->setWrapT((GLenum)param))
47652:                 {
47652:                     return error(GL_INVALID_ENUM);
47652:                 }
47652:                 break;
47652:               case GL_TEXTURE_MIN_FILTER:
47652:                 if (!texture->setMinFilter((GLenum)param))
47652:                 {
47652:                     return error(GL_INVALID_ENUM);
47652:                 }
47652:                 break;
47652:               case GL_TEXTURE_MAG_FILTER:
47652:                 if (!texture->setMagFilter((GLenum)param))
47652:                 {
47652:                     return error(GL_INVALID_ENUM);
47652:                 }
47652:                 break;
47652:               default:
47652:                 return error(GL_INVALID_ENUM);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glTexParameteriv(GLenum target, GLenum pname, const GLint* params)
47652: {
47652:     glTexParameteri(target, pname, *params);
47652: }
47652: 
47652: void __stdcall glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
47652:                                GLenum format, GLenum type, const GLvoid* pixels)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLint level = %d, GLint xoffset = %d, GLint yoffset = %d, "
47652:           "GLsizei width = %d, GLsizei height = %d, GLenum format = 0x%X, GLenum type = 0x%X, "
47652:           "const GLvoid* pixels = 0x%0.8p)",
47652:            target, level, xoffset, yoffset, width, height, format, type, pixels);
47652: 
47652:     try
47652:     {
47652:         if (!gl::IsTextureTarget(target))
47652:         {
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
58582:         if (level < 0 || xoffset < 0 || yoffset < 0 || width < 0 || height < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (std::numeric_limits<GLsizei>::max() - xoffset < width || std::numeric_limits<GLsizei>::max() - yoffset < height)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (!gl::CheckTextureFormatType(format, type))
47652:         {
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         if (width == 0 || height == 0 || pixels == NULL)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
58582:             if (level > context->getMaximumTextureLevel())
58582:             {
58582:                 return error(GL_INVALID_VALUE);
58582:             }
58582: 
55266:             if (format == GL_FLOAT)
55266:             {
55266:                 if (!context->supportsFloatTextures())
55266:                 {
55266:                     return error(GL_INVALID_ENUM);
55266:                 }
55266:             }
55266:             else if (format == GL_HALF_FLOAT_OES)
55266:             {
55266:                 if (!context->supportsHalfFloatTextures())
55266:                 {
55266:                     return error(GL_INVALID_ENUM);
55266:                 }
55266:             }
55266: 
47652:             if (target == GL_TEXTURE_2D)
47652:             {
47652:                 gl::Texture2D *texture = context->getTexture2D();
47652: 
47652:                 if (!texture)
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652: 
55266:                 if (texture->isCompressed())
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
70456:                 if (format != texture->getInternalFormat())
55266:                 {
55266:                     return error(GL_INVALID_OPERATION);
55266:                 }
55266: 
47652:                 texture->subImage(level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
47652:             }
47652:             else if (gl::IsCubemapTextureTarget(target))
47652:             {
47652:                 gl::TextureCubeMap *texture = context->getTextureCubeMap();
47652: 
47652:                 if (!texture)
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652: 
47652:                 texture->subImage(target, level, xoffset, yoffset, width, height, format, type, context->getUnpackAlignment(), pixels);
47652:             }
47652:             else
47652:             {
47652:                 UNREACHABLE();
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniform1f(GLint location, GLfloat x)
47652: {
47652:     glUniform1fv(location, 1, &x);
47652: }
47652: 
47652: void __stdcall glUniform1fv(GLint location, GLsizei count, const GLfloat* v)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)", location, count, v);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniform1fv(location, count, v))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniform1i(GLint location, GLint x)
47652: {
47652:     glUniform1iv(location, 1, &x);
47652: }
47652: 
47652: void __stdcall glUniform1iv(GLint location, GLsizei count, const GLint* v)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)", location, count, v);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniform1iv(location, count, v))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniform2f(GLint location, GLfloat x, GLfloat y)
47652: {
47652:     GLfloat xy[2] = {x, y};
47652: 
47652:     glUniform2fv(location, 1, (GLfloat*)&xy);
47652: }
47652: 
47652: void __stdcall glUniform2fv(GLint location, GLsizei count, const GLfloat* v)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)", location, count, v);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652:         
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniform2fv(location, count, v))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniform2i(GLint location, GLint x, GLint y)
47652: {
47652:     GLint xy[4] = {x, y};
47652: 
47652:     glUniform2iv(location, 1, (GLint*)&xy);
47652: }
47652: 
47652: void __stdcall glUniform2iv(GLint location, GLsizei count, const GLint* v)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)", location, count, v);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniform2iv(location, count, v))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniform3f(GLint location, GLfloat x, GLfloat y, GLfloat z)
47652: {
47652:     GLfloat xyz[3] = {x, y, z};
47652: 
47652:     glUniform3fv(location, 1, (GLfloat*)&xyz);
47652: }
47652: 
47652: void __stdcall glUniform3fv(GLint location, GLsizei count, const GLfloat* v)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)", location, count, v);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniform3fv(location, count, v))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniform3i(GLint location, GLint x, GLint y, GLint z)
47652: {
47652:     GLint xyz[3] = {x, y, z};
47652: 
47652:     glUniform3iv(location, 1, (GLint*)&xyz);
47652: }
47652: 
47652: void __stdcall glUniform3iv(GLint location, GLsizei count, const GLint* v)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)", location, count, v);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniform3iv(location, count, v))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniform4f(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
47652: {
47652:     GLfloat xyzw[4] = {x, y, z, w};
47652: 
47652:     glUniform4fv(location, 1, (GLfloat*)&xyzw);
47652: }
47652: 
47652: void __stdcall glUniform4fv(GLint location, GLsizei count, const GLfloat* v)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, const GLfloat* v = 0x%0.8p)", location, count, v);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniform4fv(location, count, v))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniform4i(GLint location, GLint x, GLint y, GLint z, GLint w)
47652: {
47652:     GLint xyzw[4] = {x, y, z, w};
47652: 
47652:     glUniform4iv(location, 1, (GLint*)&xyzw);
47652: }
47652: 
47652: void __stdcall glUniform4iv(GLint location, GLsizei count, const GLint* v)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, const GLint* v = 0x%0.8p)", location, count, v);
47652: 
47652:     try
47652:     {
47652:         if (count < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniform4iv(location, count, v))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, GLboolean transpose = %d, const GLfloat* value = 0x%0.8p)",
47652:           location, count, transpose, value);
47652: 
47652:     try
47652:     {
47652:         if (count < 0 || transpose != GL_FALSE)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniformMatrix2fv(location, count, value))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, GLboolean transpose = %d, const GLfloat* value = 0x%0.8p)",
47652:           location, count, transpose, value);
47652: 
47652:     try
47652:     {
47652:         if (count < 0 || transpose != GL_FALSE)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniformMatrix3fv(location, count, value))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
47652: {
61598:     EVENT("(GLint location = %d, GLsizei count = %d, GLboolean transpose = %d, const GLfloat* value = 0x%0.8p)",
47652:           location, count, transpose, value);
47652: 
47652:     try
47652:     {
47652:         if (count < 0 || transpose != GL_FALSE)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (location == -1)
47652:         {
47652:             return;
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *program = context->getCurrentProgram();
47652: 
47652:             if (!program)
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             if (!program->setUniformMatrix4fv(location, count, value))
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glUseProgram(GLuint program)
47652: {
61598:     EVENT("(GLuint program = %d)", program);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject && program != 0)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             if (program != 0 && !programObject->isLinked())
47652:             {
47652:                 return error(GL_INVALID_OPERATION);
47652:             }
47652: 
47652:             context->useProgram(program);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glValidateProgram(GLuint program)
47652: {
61598:     EVENT("(GLuint program = %d)", program);
47652: 
47652:     try
47652:     {
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             gl::Program *programObject = context->getProgram(program);
47652: 
47652:             if (!programObject)
47652:             {
47652:                 if (context->getShader(program))
47652:                 {
47652:                     return error(GL_INVALID_OPERATION);
47652:                 }
47652:                 else
47652:                 {
47652:                     return error(GL_INVALID_VALUE);
47652:                 }
47652:             }
47652: 
47652:             programObject->validate();
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glVertexAttrib1f(GLuint index, GLfloat x)
47652: {
61598:     EVENT("(GLuint index = %d, GLfloat x = %f)", index, x);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             GLfloat vals[4] = { x, 0, 0, 1 };
47652:             context->setVertexAttrib(index, vals);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glVertexAttrib1fv(GLuint index, const GLfloat* values)
47652: {
61598:     EVENT("(GLuint index = %d, const GLfloat* values = 0x%0.8p)", index, values);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             GLfloat vals[4] = { values[0], 0, 0, 1 };
47652:             context->setVertexAttrib(index, vals);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
47652: {
61598:     EVENT("(GLuint index = %d, GLfloat x = %f, GLfloat y = %f)", index, x, y);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             GLfloat vals[4] = { x, y, 0, 1 };
47652:             context->setVertexAttrib(index, vals);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glVertexAttrib2fv(GLuint index, const GLfloat* values)
47652: {
61598:     EVENT("(GLuint index = %d, const GLfloat* values = 0x%0.8p)", index, values);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             GLfloat vals[4] = { values[0], values[1], 0, 1 };
47652:             context->setVertexAttrib(index, vals);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
47652: {
61598:     EVENT("(GLuint index = %d, GLfloat x = %f, GLfloat y = %f, GLfloat z = %f)", index, x, y, z);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             GLfloat vals[4] = { x, y, z, 1 };
47652:             context->setVertexAttrib(index, vals);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glVertexAttrib3fv(GLuint index, const GLfloat* values)
47652: {
61598:     EVENT("(GLuint index = %d, const GLfloat* values = 0x%0.8p)", index, values);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             GLfloat vals[4] = { values[0], values[1], values[2], 1 };
47652:             context->setVertexAttrib(index, vals);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
47652: {
61598:     EVENT("(GLuint index = %d, GLfloat x = %f, GLfloat y = %f, GLfloat z = %f, GLfloat w = %f)", index, x, y, z, w);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             GLfloat vals[4] = { x, y, z, w };
47652:             context->setVertexAttrib(index, vals);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glVertexAttrib4fv(GLuint index, const GLfloat* values)
47652: {
61598:     EVENT("(GLuint index = %d, const GLfloat* values = 0x%0.8p)", index, values);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setVertexAttrib(index, values);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)
47652: {
61598:     EVENT("(GLuint index = %d, GLint size = %d, GLenum type = 0x%X, "
47652:           "GLboolean normalized = %d, GLsizei stride = %d, const GLvoid* ptr = 0x%0.8p)",
47652:           index, size, type, normalized, stride, ptr);
47652: 
47652:     try
47652:     {
47652:         if (index >= gl::MAX_VERTEX_ATTRIBS)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         if (size < 1 || size > 4)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         switch (type)
47652:         {
47652:           case GL_BYTE:
47652:           case GL_UNSIGNED_BYTE:
47652:           case GL_SHORT:
47652:           case GL_UNSIGNED_SHORT:
47652:           case GL_FIXED:
47652:           case GL_FLOAT:
47652:             break;
47652:           default:
47652:             return error(GL_INVALID_ENUM);
47652:         }
47652: 
47652:         if (stride < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
48434:             context->setVertexAttribState(index, context->getArrayBuffer(), size, type, (normalized == GL_TRUE), stride, ptr);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: void __stdcall glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
47652: {
61598:     EVENT("(GLint x = %d, GLint y = %d, GLsizei width = %d, GLsizei height = %d)", x, y, width, height);
47652: 
47652:     try
47652:     {
47652:         if (width < 0 || height < 0)
47652:         {
47652:             return error(GL_INVALID_VALUE);
47652:         }
47652: 
47652:         gl::Context *context = gl::getContext();
47652: 
47652:         if (context)
47652:         {
47652:             context->setViewportParams(x, y, width, height);
47652:         }
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
55266: void __stdcall glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
55266:                                       GLbitfield mask, GLenum filter)
55266: {
61598:     EVENT("(GLint srcX0 = %d, GLint srcY0 = %d, GLint srcX1 = %d, GLint srcY1 = %d, "
55266:           "GLint dstX0 = %d, GLint dstY0 = %d, GLint dstX1 = %d, GLint dstY1 = %d, "
55266:           "GLbitfield mask = 0x%X, GLenum filter = 0x%X)",
55266:           srcX0, srcY0, srcX1, srcX1, dstX0, dstY0, dstX1, dstY1, mask, filter);
55266: 
55266:     try
55266:     {
55266:         switch (filter)
55266:         {
55266:           case GL_NEAREST:
55266:             break;
55266:           default:
55266:             return error(GL_INVALID_ENUM);
55266:         }
55266: 
55266:         if ((mask & ~(GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)) != 0)
55266:         {
55266:             return error(GL_INVALID_VALUE);
55266:         }
55266: 
55266:         if (srcX1 - srcX0 != dstX1 - dstX0 || srcY1 - srcY0 != dstY1 - dstY0)
55266:         {
55266:             ERR("Scaling and flipping in BlitFramebufferANGLE not supported by this implementation");
55266:             return error(GL_INVALID_OPERATION);
55266:         }
55266: 
55266:         gl::Context *context = gl::getContext();
55266: 
55266:         if (context)
55266:         {
55266:             if (context->getReadFramebufferHandle() == context->getDrawFramebufferHandle())
55266:             {
55266:                 ERR("Blits with the same source and destination framebuffer are not supported by this implementation.");
55266:                 return error(GL_INVALID_OPERATION);
55266:             }
55266: 
55266:             context->blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask);
55266:         }
55266:     }
55266:     catch(std::bad_alloc&)
55266:     {
55266:         return error(GL_OUT_OF_MEMORY);
55266:     }
55266: }
55266: 
47652: void __stdcall glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth,
47652:                                GLint border, GLenum format, GLenum type, const GLvoid* pixels)
47652: {
61598:     EVENT("(GLenum target = 0x%X, GLint level = %d, GLenum internalformat = 0x%X, "
47652:           "GLsizei width = %d, GLsizei height = %d, GLsizei depth = %d, GLint border = %d, "
47652:           "GLenum format = 0x%X, GLenum type = 0x%x, const GLvoid* pixels = 0x%0.8p)",
47652:           target, level, internalformat, width, height, depth, border, format, type, pixels);
47652: 
47652:     try
47652:     {
47652:         UNIMPLEMENTED();   // FIXME
47652:     }
47652:     catch(std::bad_alloc&)
47652:     {
47652:         return error(GL_OUT_OF_MEMORY);
47652:     }
47652: }
47652: 
47652: __eglMustCastToProperFunctionPointerType __stdcall glGetProcAddress(const char *procname)
47652: {
47652:     struct Extension
47652:     {
47652:         const char *name;
47652:         __eglMustCastToProperFunctionPointerType address;
47652:     };
47652: 
47652:     static const Extension glExtensions[] =
47652:     {
47652:         {"glTexImage3DOES", (__eglMustCastToProperFunctionPointerType)glTexImage3DOES},
55266:         {"glBlitFramebufferANGLE", (__eglMustCastToProperFunctionPointerType)glBlitFramebufferANGLE},
61598:         {"glRenderbufferStorageMultisampleANGLE", (__eglMustCastToProperFunctionPointerType)glRenderbufferStorageMultisampleANGLE},
55266:         {"glDeleteFencesNV", (__eglMustCastToProperFunctionPointerType)glDeleteFencesNV},
55266:         {"glGenFencesNV", (__eglMustCastToProperFunctionPointerType)glGenFencesNV},
55266:         {"glIsFenceNV", (__eglMustCastToProperFunctionPointerType)glIsFenceNV},
55266:         {"glTestFenceNV", (__eglMustCastToProperFunctionPointerType)glTestFenceNV},
55266:         {"glGetFenceivNV", (__eglMustCastToProperFunctionPointerType)glGetFenceivNV},
55266:         {"glFinishFenceNV", (__eglMustCastToProperFunctionPointerType)glFinishFenceNV},
55266:         {"glSetFenceNV", (__eglMustCastToProperFunctionPointerType)glSetFenceNV},
80841:         {"glGetTranslatedShaderSourceANGLE", (__eglMustCastToProperFunctionPointerType)glGetTranslatedShaderSourceANGLE},
47652:     };
47652: 
47652:     for (int ext = 0; ext < sizeof(glExtensions) / sizeof(Extension); ext++)
47652:     {
47652:         if (strcmp(procname, glExtensions[ext].name) == 0)
47652:         {
47652:             return (__eglMustCastToProperFunctionPointerType)glExtensions[ext].address;
47652:         }
47652:     }
47652: 
47652:     return NULL;
47652: }
47652: 
70456: void __stdcall glBindTexImage(egl::Surface *surface)
70456: {
70456:     EVENT("(egl::Surface* surface = 0x%0.8p)",
70456:           surface);
70456: 
70456:     try
70456:     {
70456:         gl::Context *context = gl::getContext();
70456: 
70456:         if (context)
70456:         {
70456:             gl::Texture2D *textureObject = context->getTexture2D();
70456: 
70456:             if (textureObject)
70456:             {
70456:                 textureObject->bindTexImage(surface);
70456:             }
70456:         }
70456:     }
70456:     catch(std::bad_alloc&)
70456:     {
70456:         return error(GL_OUT_OF_MEMORY);
70456:     }
70456: }
70456: 
70456: }
