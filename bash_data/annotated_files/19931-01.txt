    1: /* -*- Mode: objc; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License
    1:  * Version 1.1 (the "License"); you may not use this file except in
    1:  * compliance with the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is 
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Josh Aas <josh@mozilla.com>
    1:  *   Mark Mentovai <mark@moxienet.com>
    1:  *   HÃ¥kan Waara <hwaara@gmail.com>
    1:  *   Stuart Morgan <stuart.morgan@alumni.case.edu>
10305:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or 
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include <unistd.h>
    1:  
    1: #include "nsChildView.h"
 3574: #include "nsCocoaWindow.h"
    1: 
11978: #include "nsObjCExceptions.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsToolkit.h"
    1: #include "nsCRT.h"
    1: #include "nsplugindefs.h"
12394: #include "nsIPrefService.h"
12394: #include "nsIPrefBranch.h"
    1: 
    1: #include "nsIFontMetrics.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIRegion.h"
    1: #include "nsIRollupListener.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIServiceManager.h"
 3545: #include "nsILocalFile.h"
 3545: #include "nsILocalFileMac.h"
    1: #include "nsGfxCIID.h"
 8345: #include "nsIMenuRollup.h"
    1: 
    1: #include "nsDragService.h"
    1: #include "nsCursorManager.h"
    1: #include "nsWindowMap.h"
    1: #include "nsCocoaUtils.h"
10884: #include "nsMenuBarX.h"
    1: 
    1: #include "gfxContext.h"
    1: #include "gfxQuartzSurface.h"
    1: 
15067: #include <dlfcn.h>
15067: 
    1: #undef DEBUG_IME
    1: #undef DEBUG_UPDATE
    1: #undef INVALIDATE_DEBUGGING  // flash areas as they are invalidated
    1: 
 5676: #ifdef MOZ_LOGGING
 5676: #define FORCE_PR_LOG
 5676: #endif
 5676: #include "prlog.h"
 5676: 
 3545: #ifdef PR_LOGGING
 3545: PRLogModuleInfo* sCocoaLog = nsnull;
 3545: #endif
 3545: 
 5762: // npapi.h defines NPEventType_AdjustCursorEvent but we don't want to include npapi.h here.
 5762: // We need to send this in the "what" field for certain native plugin events. WebKit does
 5762: // this as well.
 5762: #define adjustCursorEvent 33
 5762: 
    1: extern "C" {
    1:   CG_EXTERN void CGContextResetCTM(CGContextRef);
    1:   CG_EXTERN void CGContextSetCTM(CGContextRef, CGAffineTransform);
    1:   CG_EXTERN void CGContextResetClip(CGContextRef);
    1: }
    1: 
15067: #if MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_4
15067: struct __TISInputSource;
15067: typedef __TISInputSource* TISInputSourceRef;
15067: #endif
15067: TISInputSourceRef (*Leopard_TISCopyCurrentKeyboardLayoutInputSource)() = NULL;
15067: void* (*Leopard_TISGetInputSourceProperty)(TISInputSourceRef inputSource, CFStringRef propertyKey) = NULL;
15097: CFArrayRef (*Leopard_TISCreateInputSourceList)(CFDictionaryRef properties, Boolean includeAllInstalled) = NULL;
15067: CFStringRef kOurTISPropertyUnicodeKeyLayoutData = NULL;
15097: CFStringRef kOurTISPropertyInputSourceID = NULL;
15067: 
11675: extern PRBool gCocoaWindowMethodsSwizzled; // Defined in nsCocoaWindow.mm
11675: 
 3592: extern nsISupportsArray *gDraggedTransferables;
 3592: 
  539: PRBool nsTSMManager::sIsIMEEnabled = PR_TRUE;
  539: PRBool nsTSMManager::sIsRomanKeyboardsOnly = PR_FALSE;
 4726: PRBool nsTSMManager::sIgnoreCommit = PR_FALSE;
  539: NSView<mozView>* nsTSMManager::sComposingView = nsnull;
 4726: TSMDocumentID nsTSMManager::sDocumentID = nsnull;
 4726: NSString* nsTSMManager::sComposingString = nsnull;
  539: 
    1: static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
    1: static NSView* sLastViewEntered = nil;
    1: #ifdef INVALIDATE_DEBUGGING
    1: static void blinkRect(Rect* r);
    1: static void blinkRgn(RgnHandle rgn);
    1: #endif
    1: 
    1: nsIRollupListener * gRollupListener = nsnull;
    1: nsIWidget         * gRollupWidget   = nsnull;
    1: 
    1: 
    1: @interface ChildView(Private)
    1: 
    1: // sets up our view, attaching it to its owning gecko view
 6754: - (id)initWithFrame:(NSRect)inFrame geckoChild:(nsChildView*)inChild;
    1: 
    1: // sends gecko an ime composition event
19835: - (nsRect) sendCompositionEvent:(PRInt32)aEventType;
    1: 
    1: // sends gecko an ime text event
    1: - (void) sendTextEvent:(PRUnichar*) aBuffer 
    1:                        attributedString:(NSAttributedString*) aString
    1:                        selectedRange:(NSRange)selRange
    1:                        markedRange:(NSRange)markRange
    1:                        doCommit:(BOOL)doCommit;
    1: 
 2315: // do generic gecko event setup with a generic cocoa event. accepts nil inEvent.
 2315: - (void) convertGenericCocoaEvent:(NSEvent*)inEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent;
 2315: 
 2315: // set up a gecko mouse event based on a cocoa mouse event
 2315: - (void) convertCocoaMouseEvent:(NSEvent*)aMouseEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent;
 2315: 
 2315: // set up a gecko key event based on a cocoa key event
 2315: - (void) convertCocoaKeyEvent:(NSEvent*)aKeyEvent toGeckoEvent:(nsKeyEvent*)outGeckoEvent;
    1: 
    1: - (NSMenu*)contextMenu;
    1: - (TopLevelWindowData*)ensureWindowData;
    1: 
    1: - (void)setIsPluginView:(BOOL)aIsPlugin;
  130: - (BOOL)isPluginView;
    1: 
    1: - (BOOL)childViewHasPlugin;
    1: 
    1: - (BOOL)isRectObscuredBySubview:(NSRect)inRect;
    1: 
    1: - (void)processPendingRedraws;
    1: 
14962: - (PRBool)processKeyDownEvent:(NSEvent*)theEvent keyEquiv:(BOOL)isKeyEquiv;
14962: 
 7637: - (BOOL)ensureCorrectMouseEventTarget:(NSEvent *)anEvent;
 3574: 
 3574: - (void)maybeInitContextMenuTracking;
 3574: 
14962: + (NSEvent*)makeNewCocoaEventWithType:(NSEventType)type fromEvent:(NSEvent*)theEvent;
14962: 
19297: - (BOOL)isPaintingSuppressed;
19297: 
    1: #if USE_CLICK_HOLD_CONTEXTMENU
    1:  // called on a timer two seconds after a mouse down to see if we should display
    1:  // a context menu (click-hold)
    1: - (void)clickHoldCallback:(id)inEvent;
    1: #endif
    1: 
    1: #ifdef ACCESSIBILITY
    1: - (id<mozAccessible>)accessible;
    1: #endif
    1: 
    1: @end
    1: 
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: /* Convenience routines to go from a gecko rect to cocoa NSRects and back
    1:  *
    1:  * Gecko rects (nsRect) contain an origin (x,y) in a coordinate
    1:  * system with (0,0) in the top-left of the screen. Cocoa rects
    1:  * (NSRect) contain an origin (x,y) in a coordinate system with
    1:  * (0,0) in the bottom-left of the screen. Both nsRect and NSRect
    1:  * contain width/height info, with no difference in their use.
    1:  * If a Cocoa rect is from a flipped view, there is no need to
    1:  * convert coordinate systems.
    1:  */
    1: 
    1: 
    1: static inline void
19835: GeckoRectToNSRect(const nsRect & inGeckoRect, NSRect & outCocoaRect)
    1: {
    1:   outCocoaRect.origin.x = inGeckoRect.x;
    1:   outCocoaRect.origin.y = inGeckoRect.y;
    1:   outCocoaRect.size.width = inGeckoRect.width;
    1:   outCocoaRect.size.height = inGeckoRect.height;
    1: }
    1: 
    1: static inline void
19835: NSRectToGeckoRect(const NSRect & inCocoaRect, nsRect & outGeckoRect)
19835: {
19835:   outGeckoRect.x = static_cast<nscoord>(inCocoaRect.origin.x);
19835:   outGeckoRect.y = static_cast<nscoord>(inCocoaRect.origin.y);
19835:   outGeckoRect.width = static_cast<nscoord>(inCocoaRect.size.width);
19835:   outGeckoRect.height = static_cast<nscoord>(inCocoaRect.size.height);
    1: }
    1: 
    1: 
    1: static inline void 
    1: ConvertGeckoRectToMacRect(const nsRect& aRect, Rect& outMacRect)
    1: {
    1:   outMacRect.left = aRect.x;
    1:   outMacRect.top = aRect.y;
    1:   outMacRect.right = aRect.x + aRect.width;
    1:   outMacRect.bottom = aRect.y + aRect.height;
    1: }
    1: 
    1: // Flips a screen coordinate from a point in the cocoa coordinate system (bottom-left rect) to a point
    1: // that is a "flipped" cocoa coordinate system (starts in the top-left).
    1: static inline void
    1: FlipCocoaScreenCoordinate (NSPoint &inPoint)
    1: {  
 8779:   inPoint.y = nsCocoaUtils::FlippedScreenY(inPoint.y);
    1: }
    1:   
    1: 
    1: static PRUint32
    1: UnderlineAttributeToTextRangeType(PRUint32 aUnderlineStyle, NSRange selRange)
    1: {
    1: #ifdef DEBUG_IME
    1:   NSLog(@"****in underlineAttributeToTextRangeType = %d", aUnderlineStyle);
    1: #endif
    1: 
    1:   // For more info on the underline attribute, please see: 
    1:   // http://developer.apple.com/techpubs/macosx/Cocoa/TasksAndConcepts/ProgrammingTopics/AttributedStrings/Tasks/AccessingAttrs.html
    1:   // We are not clear where the define for value 2 is right now. 
    1:   // To see this value in japanese ime, type 'aaaaaaaaa' and hit space to make the
    1:   // ime send you some part of text in 1 (NSSingleUnderlineStyle) and some part in 2. 
    1:   // ftang will ask apple for more details
    1:   //
    1:   // it probably means show 1-pixel thickness underline vs 2-pixel thickness
    1:   
    1:   PRUint32 attr;
    1:   if (selRange.length == 0) {
    1:     switch (aUnderlineStyle) {
    1:       case 1:
    1:         attr = NS_TEXTRANGE_RAWINPUT;
    1:         break;
    1:       case 2:
    1:       default:
    1:         attr = NS_TEXTRANGE_SELECTEDRAWTEXT;
    1:         break;
    1:     }
    1:   }
    1:   else {
    1:     switch (aUnderlineStyle) {
    1:       case 1:
    1:         attr = NS_TEXTRANGE_CONVERTEDTEXT;
    1:         break;
    1:       case 2:
    1:       default:
    1:         attr = NS_TEXTRANGE_SELECTEDCONVERTEDTEXT;
    1:         break;
    1:     }
    1:   }
    1:   return attr;
    1: }
    1: 
    1: 
    1: static PRUint32
    1: CountRanges(NSAttributedString *aString)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
    1:   // Iterate through aString for the NSUnderlineStyleAttributeName and count the 
    1:   // different segments adjusting limitRange as we go.
    1:   PRUint32 count = 0;
    1:   NSRange effectiveRange;
    1:   NSRange limitRange = NSMakeRange(0, [aString length]);
    1:   while (limitRange.length > 0) {
    1:     [aString attribute:NSUnderlineStyleAttributeName 
    1:                atIndex:limitRange.location 
    1:  longestEffectiveRange:&effectiveRange
    1:                inRange:limitRange];
    1:     limitRange = NSMakeRange(NSMaxRange(effectiveRange), 
    1:                              NSMaxRange(limitRange) - NSMaxRange(effectiveRange));
    1:     count++;
    1:   }
    1:   return count;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
    1: }
    1: 
    1: 
    1: static void
    1: ConvertAttributeToGeckoRange(NSAttributedString *aString, NSRange markRange, NSRange selRange, PRUint32 inCount, nsTextRange* aRanges)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // Convert the Cocoa range into the nsTextRange Array used in Gecko.
    1:   // Iterate through the attributed string and map the underline attribute to Gecko IME textrange attributes.
    1:   // We may need to change the code here if we change the implementation of validAttributesForMarkedText.
    1:   PRUint32 i = 0;
    1:   NSRange effectiveRange;
    1:   NSRange limitRange = NSMakeRange(0, [aString length]);
    1:   while ((limitRange.length > 0) && (i < inCount)) {
    1:     id attributeValue = [aString attribute:NSUnderlineStyleAttributeName 
    1:                               atIndex:limitRange.location 
    1:                               longestEffectiveRange:&effectiveRange
    1:                               inRange:limitRange];
    1:     aRanges[i].mStartOffset = effectiveRange.location;                         
    1:     aRanges[i].mEndOffset = NSMaxRange(effectiveRange);                         
    1:     aRanges[i].mRangeType = UnderlineAttributeToTextRangeType([attributeValue intValue], selRange); 
    1:     limitRange = NSMakeRange(NSMaxRange(effectiveRange), 
    1:                              NSMaxRange(limitRange) - NSMaxRange(effectiveRange));
    1:     i++;
    1:   }
    1:   // Get current caret position.
    1:   // Caret is indicator of insertion point, so mEndOffset = 0.
    1:   aRanges[i].mStartOffset = selRange.location + selRange.length;                         
    1:   aRanges[i].mEndOffset = 0;                         
    1:   aRanges[i].mRangeType = NS_TEXTRANGE_CARETPOSITION;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: static void
    1: FillTextRangeInTextEvent(nsTextEvent *aTextEvent, NSAttributedString* aString, NSRange markRange, NSRange selRange)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // Count the number of segments in the attributed string and add one more count for sending current caret position to Gecko.
    1:   // Allocate the right size of nsTextRange and draw caret at right position.
    1:   // Convert the attributed string into an array of nsTextRange and get current caret position by calling above functions.
    1:   PRUint32 count = CountRanges(aString) + 1;
    1:   aTextEvent->rangeArray = new nsTextRange[count];
11978:   if (aTextEvent->rangeArray) {
    1:     aTextEvent->rangeCount = count;
    1:     ConvertAttributeToGeckoRange(aString, markRange, selRange, aTextEvent->rangeCount,  aTextEvent->rangeArray);
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: nsChildView::nsChildView() : nsBaseWidget()
    1: , mView(nsnull)
    1: , mParentView(nsnull)
    1: , mParentWidget(nsnull)
    1: , mVisible(PR_FALSE)
    1: , mDrawing(PR_FALSE)
    1: , mLiveResizeInProgress(PR_FALSE)
  130: , mIsPluginView(PR_FALSE)
    1: , mPluginDrawing(PR_FALSE)
  130: , mPluginIsCG(PR_FALSE)
10367: , mInSetFocus(PR_FALSE)
    1: {
 3545: #ifdef PR_LOGGING
15069:   if (!sCocoaLog) {
 3545:     sCocoaLog = PR_NewLogModule("nsCocoaWidgets");
15069:     CFIndex idx;
15069:     KLGetKeyboardLayoutCount(&idx);
15069:     PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("Keyboard layout configuration:"));
15069:     for (CFIndex i = 0; i < idx; ++i) {
15069:       KeyboardLayoutRef curKL;
15069:       if (KLGetKeyboardLayoutAtIndex(i, &curKL) == noErr) {
15069:         CFStringRef name;
15069:         if (KLGetKeyboardLayoutProperty(curKL, kKLName, (const void**)&name) == noErr) {
15069:           int idn;
15069:           KLGetKeyboardLayoutProperty(curKL, kKLIdentifier, (const void**)&idn);
15069:           int kind;
15069:           KLGetKeyboardLayoutProperty(curKL, kKLKind, (const void**)&kind);
15069:           char buf[256];
15069:           CFStringGetCString(name, buf, 256, kCFStringEncodingASCII);
15069:           PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("  %d,%s,%d\n", idn, buf, kind));
15069:         }
15069:       }
15069:     }
15069:   }
 3545: #endif
 3545: 
 5676:   SetBackgroundColor(NS_RGB(255, 255, 255));
 5676:   SetForegroundColor(NS_RGB(0, 0, 0));
15067: 
15067:   if (nsToolkit::OnLeopardOrLater() && !Leopard_TISCopyCurrentKeyboardLayoutInputSource) {
15704:     // This libary would already be open for LMGetKbdType (and probably other
15704:     // symbols), so merely using RTLD_DEFAULT in dlsym would be sufficient,
15704:     // but man dlsym says: "all mach-o images in the process (except ...) are
15704:     // searched in the order they were loaded.  This can be a costly search
15704:     // and should be avoided."
15067:     void* hitoolboxHandle = dlopen("/System/Library/Frameworks/Carbon.framework/Frameworks/HIToolbox.framework/Versions/A/HIToolbox", RTLD_LAZY);
15067:     if (hitoolboxHandle) {
15067:       *(void **)(&Leopard_TISCopyCurrentKeyboardLayoutInputSource) = dlsym(hitoolboxHandle, "TISCopyCurrentKeyboardLayoutInputSource");
15067:       *(void **)(&Leopard_TISGetInputSourceProperty) = dlsym(hitoolboxHandle, "TISGetInputSourceProperty");
15097:       *(void **)(&Leopard_TISCreateInputSourceList) = dlsym(hitoolboxHandle, "TISCreateInputSourceList");
15067:       kOurTISPropertyUnicodeKeyLayoutData = *static_cast<CFStringRef*>(dlsym(hitoolboxHandle, "kTISPropertyUnicodeKeyLayoutData"));
15097:       kOurTISPropertyInputSourceID = *static_cast<CFStringRef*>(dlsym(hitoolboxHandle, "kTISPropertyInputSourceID"));
15067:     }
15067:   }
    1: }
    1: 
    1: 
    1: nsChildView::~nsChildView()
    1: {
    1:   // notify the children that we're gone
    1:   for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
 3233:     nsChildView* childView = static_cast<nsChildView*>(kid);
    1:     childView->mParentWidget = nsnull;
    1:   }
    1: 
15567:   NS_WARN_IF_FALSE(mOnDestroyCalled, "nsChildView object destroyed without calling Destroy()");
15567: 
15567:   // An nsChildView object that was in use can be destroyed without Destroy()
15567:   // ever being called on it.  So we also need to do a quick, safe cleanup
15567:   // here (it's too late to just call Destroy(), which can cause crashes).
15567:   // It's particularly important to make sure widgetDestroyed is called on our
15567:   // mView -- this method NULLs mView's mGeckoChild, and NULL checks on
15567:   // mGeckoChild are used throughout the ChildView class to tell if it's safe
15567:   // to use a ChildView object.
15567:   [mView widgetDestroyed]; // Safe if mView is nil.
15567:   mParentWidget = nil;
15567:   TearDownView(); // Safe if called twice.
    1: }
    1: 
    1: 
15919: NS_IMPL_ISUPPORTS_INHERITED1(nsChildView, nsBaseWidget, nsIPluginWidget)
    1: 
    1: 
    1: // Utility method for implementing both Create(nsIWidget ...)
    1: // and Create(nsNativeWidget...)
    1: nsresult nsChildView::StandardCreate(nsIWidget *aParent,
19835:                       const nsRect &aRect,
    1:                       EVENT_CALLBACK aHandleEventFunction,
    1:                       nsIDeviceContext *aContext,
    1:                       nsIAppShell *aAppShell,
    1:                       nsIToolkit *aToolkit,
    1:                       nsWidgetInitData *aInitData,
    1:                       nsNativeWidget aNativeParent)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
11675:   // See NSWindow (MethodSwizzling) in nsCocoaWindow.mm.
11675:   if (!gCocoaWindowMethodsSwizzled) {
11675:     nsToolkit::SwizzleMethods([NSWindow class], @selector(sendEvent:),
11675:                               @selector(nsCocoaWindow_NSWindow_sendEvent:));
11675:     gCocoaWindowMethodsSwizzled = PR_TRUE;
11675:   }
11675: 
    1:   mBounds = aRect;
    1: 
    1:   BaseCreate(aParent, aRect, aHandleEventFunction, 
    1:               aContext, aAppShell, aToolkit, aInitData);
    1: 
    1:   // inherit things from the parent view and create our parallel 
    1:   // NSView in the Cocoa display system
    1:   mParentView = nil;
    1:   if (aParent) {
    1:     SetBackgroundColor(aParent->GetBackgroundColor());
    1:     SetForegroundColor(aParent->GetForegroundColor());
    1: 
    1:     // inherit the top-level window. NS_NATIVE_WIDGET is always a NSView
    1:     // regardless of if we're asking a window or a view (for compatibility
    1:     // with windows).
    1:     mParentView = (NSView*)aParent->GetNativeData(NS_NATIVE_WIDGET); 
    1:     mParentWidget = aParent;   
    1:   }
    1:   else
 3233:     mParentView = reinterpret_cast<NSView*>(aNativeParent);
    1:   
    1:   // create our parallel NSView and hook it up to our parent. Recall
    1:   // that NS_NATIVE_WIDGET is the NSView.
    1:   NSRect r;
    1:   GeckoRectToNSRect(mBounds, r);
    1:   mView = [CreateCocoaView(r) retain];
    1:   if (!mView) return NS_ERROR_FAILURE;
    1: 
    1:   // If this view was created in a Gecko view hierarchy, the initial state
    1:   // is hidden.  If the view is attached only to a native NSView but has
    1:   // no Gecko parent (as in embedding), the initial state is visible.
    1:   if (mParentWidget)
    1:     [mView setHidden:YES];
    1:   else
    1:     mVisible = PR_TRUE;
    1: 
    1:   // Hook it up in the NSView hierarchy.
    1:   if (mParentView) {
    1:     NSWindow* window = [mParentView window];
    1:     if (!window &&
    1:         [mParentView respondsToSelector:@selector(nativeWindow)])
    1:       window = [mParentView nativeWindow];
    1: 
    1:     [mView setNativeWindow:window];
    1: 
    1:     [mParentView addSubview:mView];
    1:   }
    1: 
    1:   // if this is a ChildView, make sure that our per-window data
    1:   // is set up
    1:   if ([mView isKindOfClass:[ChildView class]])
    1:     [(ChildView*)mView ensureWindowData];
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: // Creates the appropriate child view. Override to create something other than
    1: // our |ChildView| object. Autoreleases, so caller must retain.
    1: NSView*
    1: nsChildView::CreateCocoaView(NSRect inFrame)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 6754:   return [[[ChildView alloc] initWithFrame:inFrame geckoChild:this] autorelease];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: 
    1: void nsChildView::TearDownView()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (!mView)
    1:     return;
    1: 
    1:   NSWindow* win = [mView window];
    1:   NSResponder* responder = [win firstResponder];
    1:   
    1:   // We're being unhooked from the view hierarchy, don't leave our view
    1:   // or a child view as the window first responder.
    1:   if (responder && [responder isKindOfClass:[NSView class]] &&
    1:       [(NSView*)responder isDescendantOf:mView]) {
    1:     [win makeFirstResponder:[mView superview]];
    1:   }
    1: 
 2000:   // If mView is win's contentView, win (mView's NSWindow) "owns" mView --
 2000:   // win has retained mView, and will detach it from the view hierarchy and
 2000:   // release it when necessary (when win is itself destroyed (in a call to
 2000:   // [win dealloc])).  So all we need to do here is call [mView release] (to
 2000:   // match the call to [mView retain] in nsChildView::StandardCreate()).
 2000:   // Also calling [mView removeFromSuperviewWithoutNeedingDisplay] causes
 2000:   // mView to be released again and dealloced, while remaining win's
 2000:   // contentView.  So if we do that here, win will (for a short while) have
 2000:   // an invalid contentView (for the consequences see bmo bugs 381087 and
 2000:   // 374260).
 2000:   if ([mView isEqual:[win contentView]]) {
    1:     [mView release];
 2000:   } else {
 2000:     // Stop NSView hierarchy being changed during [ChildView drawRect:]
 2000:     [mView performSelectorOnMainThread:@selector(delayedTearDown) withObject:nil waitUntilDone:false];
 2000:   }
    1:   mView = nil;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: // create a nsChildView
    1: NS_IMETHODIMP nsChildView::Create(nsIWidget *aParent,
19835:                       const nsRect &aRect,
    1:                       EVENT_CALLBACK aHandleEventFunction,
    1:                       nsIDeviceContext *aContext,
    1:                       nsIAppShell *aAppShell,
    1:                       nsIToolkit *aToolkit,
    1:                       nsWidgetInitData *aInitData)
    1: {  
    1:   return(StandardCreate(aParent, aRect, aHandleEventFunction, aContext,
    1:                         aAppShell, aToolkit, aInitData, nsnull));
    1: }
    1: 
    1: 
    1: // Creates a main nsChildView using a native widget (an NSView)
    1: NS_IMETHODIMP nsChildView::Create(nsNativeWidget aNativeParent,
19835:                       const nsRect &aRect,
    1:                       EVENT_CALLBACK aHandleEventFunction,
    1:                       nsIDeviceContext *aContext,
    1:                       nsIAppShell *aAppShell,
    1:                       nsIToolkit *aToolkit,
    1:                       nsWidgetInitData *aInitData)
    1: {
    1:   // what we're passed in |aNativeParent| is an NSView. 
    1:   return(StandardCreate(nsnull, aRect, aHandleEventFunction, aContext,
    1:                         aAppShell, aToolkit, aInitData, aNativeParent));
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::Destroy()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (mOnDestroyCalled)
    1:     return NS_OK;
    1:   mOnDestroyCalled = PR_TRUE;
    1: 
    1:   [mView widgetDestroyed];
    1: 
    1:   nsBaseWidget::OnDestroy();
    1:   nsBaseWidget::Destroy();
    1: 
10305:   ReportDestroyEvent(); 
    1:   mParentWidget = nil;
    1: 
    1:   TearDownView();
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
10305: 
    1: #pragma mark -
    1: 
    1: 
    1: #if 0
    1: static void PrintViewHierarchy(NSView *view)
    1: {
    1:   while (view) {
    1:     NSLog(@"  view is %x, frame %@", view, NSStringFromRect([view frame]));
    1:     view = [view superview];
    1:   }
    1: }
    1: #endif
    1: 
    1: 
    1: 
    1: // Return native data according to aDataType
    1: void* nsChildView::GetNativeData(PRUint32 aDataType)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
11978: 
    1:   void* retVal = nsnull;
    1: 
    1:   switch (aDataType) 
    1:   {
 6013:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_DISPLAY:
    1:       retVal = (void*)mView;
    1:       break;
    1: 
    1:     case NS_NATIVE_WINDOW:
    1:       retVal = [mView nativeWindow];
    1:       break;
    1: 
 6013:     case NS_NATIVE_GRAPHIC:
 6013:       NS_ASSERTION(0, "Requesting NS_NATIVE_GRAPHIC on a Mac OS X child view!");
 6013:       retVal = nsnull;
    1:       break;
    1: 
    1:     case NS_NATIVE_OFFSETX:
    1:       retVal = 0;
    1:       break;
    1: 
    1:     case NS_NATIVE_OFFSETY:
    1:       retVal = 0;
    1:       break;
    1: 
    1:     case NS_NATIVE_PLUGIN_PORT:
  130: #ifndef NP_NO_QUICKDRAW
  130:     case NS_NATIVE_PLUGIN_PORT_QD:
    1:     {
  130:       mPluginIsCG = PR_FALSE;
  130:       mIsPluginView = PR_TRUE;
    1:       if ([mView isKindOfClass:[ChildView class]])
    1:         [(ChildView*)mView setIsPluginView:YES];
    1: 
    1:       NSWindow* window = [mView nativeWindow];
    1:       if (window) {
    1:         WindowRef topLevelWindow = (WindowRef)[window windowRef];
    1:         if (topLevelWindow) {
  130:           mPluginPort.qdPort.port = ::GetWindowPort(topLevelWindow);
    1: 
    1:           NSPoint viewOrigin = [mView convertPoint:NSZeroPoint toView:nil];
    1:           NSRect frame = [[window contentView] frame];
    1:           viewOrigin.y = frame.size.height - viewOrigin.y;
    1:           
    1:           // need to convert view's origin to window coordinates.
    1:           // then, encode as "SetOrigin" ready values.
  130:           mPluginPort.qdPort.portx = (PRInt32)-viewOrigin.x;
  130:           mPluginPort.qdPort.porty = (PRInt32)-viewOrigin.y;
  130:         }
  130:       }
  130: 
  130:       retVal = (void*)&mPluginPort;
  130:       break;
  130:     }
  130: #endif
  130: 
  130:     case NS_NATIVE_PLUGIN_PORT_CG:
  130:     {
  130:       mPluginIsCG = PR_TRUE;
  130:       mIsPluginView = PR_TRUE;
  130:       if ([mView isKindOfClass:[ChildView class]])
  130:         [(ChildView*)mView setIsPluginView:YES];
  130: 
  130:       mPluginPort.cgPort.context = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
  130: 
  130:       NSWindow* window = [mView nativeWindow];
  130:       if (window) {
  130:         WindowRef topLevelWindow = (WindowRef)[window windowRef];
  130:         mPluginPort.cgPort.window = topLevelWindow;
  130:       }
  130: 
  130:       retVal = (void*)&mPluginPort;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return retVal;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
    1: }
    1: 
    1: #pragma mark -
    1: 
16601: nsTransparencyMode nsChildView::GetTransparencyMode()
16601: {
16601:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
16601: 
16601:   return [mView isOpaque] ? eTransparencyOpaque : eTransparencyTransparent;
16601: 
16601:   NS_OBJC_END_TRY_ABORT_BLOCK;
16601:   return eTransparencyOpaque;
 9499: }
 9499: 
 9499: 
 9499: // This is called by nsContainerFrame on the root widget for all window types
16601: // except popup windows (when nsCocoaWindow::SetTransparencyMode is used instead).
16601: void nsChildView::SetTransparencyMode(nsTransparencyMode aMode)
16601: {
16601:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
16601: 
16601:   BOOL isTransparent = aMode == eTransparencyTransparent;
 9499:   BOOL currentTransparency = ![[mView nativeWindow] isOpaque];
16601:   if (isTransparent != currentTransparency) {
 9499:     // Find out if this is a window we created by seeing if the delegate is WindowDelegate. If it is,
 9499:     // tell the nsCocoaWindow to set its background to transparent.
 9499:     id windowDelegate = [[mView nativeWindow] delegate];
 9499:     if (windowDelegate && [windowDelegate isKindOfClass:[WindowDelegate class]]) {
 9499:       nsCocoaWindow *widget = [(WindowDelegate *)windowDelegate geckoWidget];
 9499:       if (widget) {
16601:         widget->MakeBackgroundTransparent(aMode);
16601:         [(ChildView*)mView setTransparent:isTransparent];
16601:       }
16601:     }
16601:   }
16601: 
16601:   NS_OBJC_END_TRY_ABORT_BLOCK;
 9499: }
 9499: 
 9499: 
    1: NS_IMETHODIMP nsChildView::IsVisible(PRBool& outState)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (!mVisible) {
    1:     outState = mVisible;
    1:   }
    1:   else {
    1:     // mVisible does not accurately reflect the state of a hidden tabbed view
    1:     // so verify that the view has a window as well
    1:     outState = ([mView window] != nil);
    1:     // now check native widget hierarchy visibility
    1:     if (outState && NSIsEmptyRect([mView visibleRect])) {
    1:       outState = PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
14641: void nsChildView::HidePlugin()
14641: {
14641:   NS_ASSERTION(mIsPluginView, "HidePlugin called on non-plugin view");
14641: 
14641:   if (mPluginInstanceOwner && !mPluginIsCG) {
14641:     nsPluginWindow* window;
14641:     mPluginInstanceOwner->GetWindow(window);
14641:     nsCOMPtr<nsIPluginInstance> instance;
14641:     mPluginInstanceOwner->GetInstance(*getter_AddRefs(instance));
14641:     if (window && instance) {
14641:        window->clipRect.top = 0;
14641:        window->clipRect.left = 0;
14641:        window->clipRect.bottom = 0;
14641:        window->clipRect.right = 0;
14641:        instance->SetWindow(window);
14641:     }
14641:   }
14641: }
14641: 
14641: 
14641: static void HideChildPluginViews(NSView* aView)
14641: {
14641:   NSArray* subviews = [aView subviews];
14641: 
14641:   for (unsigned int i = 0; i < [subviews count]; ++i) {
14641:     NSView* view = [subviews objectAtIndex: i];
14641: 
14641:     if (![view isKindOfClass:[ChildView class]])
14641:       continue;
14641: 
14641:     ChildView* childview = static_cast<ChildView*>(view);
14641:     if ([childview isPluginView]) {
14641:       nsChildView* widget = static_cast<nsChildView*>([childview widget]);
14641:       if (widget) {
14641:         widget->HidePlugin();
14641:       }
14641:     } else {
14641:       HideChildPluginViews(view);
14641:     }
14641:   }
14641: }
14641: 
14641: 
    1: // Hide or show this component
    1: NS_IMETHODIMP nsChildView::Show(PRBool aState)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (aState != mVisible) {
    1:     [mView setHidden:!aState];
    1:     mVisible = aState;
14641:     if (!mVisible)
14641:       HideChildPluginViews(mView);
    1:   }
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: nsIWidget*
    1: nsChildView::GetParent(void)
    1: {
    1:   return mParentWidget;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::ModalEventFilter(PRBool aRealEvent, void *aEvent,
    1:                                             PRBool *aForWindow)
    1: {
    1:   if (aForWindow)
    1:     *aForWindow = PR_FALSE;
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::Enable(PRBool aState)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::IsEnabled(PRBool *aState)
    1: {
    1:   // unimplemented
    1:   if (aState)
    1:    *aState = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::SetFocus(PRBool aRaise)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
10367:   // Don't do anything if SetFocus() has been called reentrantly on the same
10367:   // object.  Sometimes calls to nsChildView::DispatchEvent() can get
10367:   // temporarily stuck, causing calls to [ChildView sendFocusEvent:] and
10367:   // SetFocus() to be reentered.  These reentrant calls are probably the
10367:   // result of one or more bugs, and doing things on a reentrant call can
10367:   // cause problems:  For example if mView is already the first responder and
10367:   // we send it an NS_GOTFOCUS event (see below), this causes the Mochitests
10367:   // to get stuck in the toolkit/content/tests/widgets/test_popup_button.xul
10367:   // test.
10367:   if (mInSetFocus)
10367:     return NS_OK;
10367:   mInSetFocus = PR_TRUE;
    1:   NSWindow* window = [mView window];
10367:   if (window) {
14024:     nsAutoRetainCocoaObject kungFuDeathGrip(mView);
10367:     // For reasons that aren't yet clear, focus changes within a window (as
10367:     // opposed to those between windows or between apps) should only trigger
10367:     // NS_LOSTFOCUS and NS_GOTFOCUS events (sent to Gecko) in the context of
10367:     // a call to nsChildView::SetFocus() (or nsCocoaWindow::SetFocus(), which
10367:     // in any case re-routes to nsChildView::SetFocus()).  If we send these
10367:     // events on every intra-window focus change (on every call to
10367:     // [ChildView becomeFirstResponder:] or [ChildView resignFirstResponder:]),
10367:     // the result will be strange focus bugs (like bmo bugs 399471, 403232,
10367:     // 404433 and 408266).
10367:     NSResponder* firstResponder = [window firstResponder];
10367:     if ([mView isEqual:firstResponder]) {
10367:       // Sometimes SetFocus() is called on an nsChildView object that's
10367:       // already focused.  In principle this shouldn't happen, and in any
10367:       // case we shouldn't have to dispatch any events.  But if we don't, we
10367:       // sometimes get text-input cursors blinking in more than one text
10367:       // field, or still blinking when the browser is no longer active.  For
10367:       // reasons that aren't at all clear, this problem can be avoided by
10367:       // always sending an NS_GOTFOCUS message here.
10367:       if ([mView isKindOfClass:[ChildView class]])
10367:         [(ChildView *)mView sendFocusEvent:NS_GOTFOCUS];
10367:     } else {
10367:       // Retain and release firstResponder around the call to
10367:       // makeFirstResponder.
10367:       [firstResponder retain];
10367:       if ([window makeFirstResponder:mView]) {
10367:         if ([firstResponder isKindOfClass:[ChildView class]])
10367:           [(ChildView *)firstResponder sendFocusEvent:NS_LOSTFOCUS];
10367:         if ([mView isKindOfClass:[ChildView class]])
10367:           [(ChildView *)mView sendFocusEvent:NS_GOTFOCUS];
10367:       }
10367:       [firstResponder release];
10367:     }
10367:   }
10367:   mInSetFocus = PR_FALSE;
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: // Set the colormap of the window
    1: NS_IMETHODIMP nsChildView::SetColorMap(nsColorMap *aColorMap)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
15578: NS_IMETHODIMP nsChildView::SetMenuBar(void* aMenuBar)
    1: {
    1:   return NS_ERROR_FAILURE; // subviews don't have menu bars
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::ShowMenuBar(PRBool aShow)
    1: {
    1:   return NS_ERROR_FAILURE; // subviews don't have menu bars
    1: }
    1: 
    1: 
    1: // Override to set the cursor on the mac
    1: NS_IMETHODIMP nsChildView::SetCursor(nsCursor aCursor)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   nsBaseWidget::SetCursor(aCursor);
    1:   [[nsCursorManager sharedInstance] setCursor: aCursor];
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: // implement to fix "hidden virtual function" warning
    1: NS_IMETHODIMP nsChildView::SetCursor(imgIContainer* aCursor,
    1:                                       PRUint32 aHotspotX, PRUint32 aHotspotY)
    1: {
    1:   return nsBaseWidget::SetCursor(aCursor, aHotspotX, aHotspotY);
    1: }
    1: 
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: // Get this component dimension
19835: NS_IMETHODIMP nsChildView::GetBounds(nsRect &aRect)
    1: {
    1:   aRect = mBounds;
    1:   return NS_OK;
    1: }
    1: 
    1: 
19835: NS_IMETHODIMP nsChildView::SetBounds(const nsRect &aRect)
11978: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   nsresult rv = Inherited::SetBounds(aRect);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     NSRect r;
    1:     GeckoRectToNSRect(aRect, r);
    1:     [mView setFrame:r];
    1:   }
    1: 
    1:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::ConstrainPosition(PRBool aAllowSlop,
    1:                                              PRInt32 *aX, PRInt32 *aY)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // Move this component, aX and aY are in the parent widget coordinate system
    1: NS_IMETHODIMP nsChildView::Move(PRInt32 aX, PRInt32 aY)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 7635:   if (!mView || (mBounds.x == aX && mBounds.y == aY))
 7635:     return NS_OK;
 7635: 
    1:   mBounds.x = aX;
    1:   mBounds.y = aY;
    1: 
    1:   NSRect r;
    1:   GeckoRectToNSRect(mBounds, r);
    1:   [mView setFrame:r];
    1: 
 7635:   if (mVisible)
    1:     [mView setNeedsDisplay:YES];
    1: 
    1:   ReportMoveEvent();
 7635: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 7635:   if (!mView || (mBounds.width == aWidth && mBounds.height == aHeight))
 7635:     return NS_OK;
 7635: 
    1:   mBounds.width  = aWidth;
    1:   mBounds.height = aHeight;
    1: 
    1:   NSRect r;
    1:   GeckoRectToNSRect(mBounds, r);
    1:   [mView setFrame:r];
    1: 
    1:   if (mVisible && aRepaint)
    1:     [mView setNeedsDisplay:YES];
    1: 
    1:   ReportSizeEvent();
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 7635:   BOOL isMoving = (mBounds.x != aX || mBounds.y != aY);
 7635:   BOOL isResizing = (mBounds.width != aWidth || mBounds.height != aHeight);
 7635:   if (!mView || (!isMoving && !isResizing))
 7635:     return NS_OK;
 7635: 
 7635:   if (isMoving) {
 7635:     mBounds.x = aX;
 7635:     mBounds.y = aY;
 7635:   }
 7635:   if (isResizing) {
 7635:     mBounds.width  = aWidth;
 7635:     mBounds.height = aHeight;
 7635:   }
 7635: 
 7635:   NSRect r;
 7635:   GeckoRectToNSRect(mBounds, r);
 7635:   [mView setFrame:r];
 7635: 
 7635:   if (mVisible && aRepaint)
 7635:     [mView setNeedsDisplay:YES];
 7635: 
10305:   if (isMoving) {
 7635:     ReportMoveEvent();
10305:     if (mOnDestroyCalled)
10305:       return NS_OK;
10305:   }
 7635:   if (isResizing)
 7635:     ReportSizeEvent();
 7635: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: NS_METHOD nsChildView::GetPreferredSize(PRInt32& aWidth, PRInt32& aHeight)
    1: {
    1:   return NS_ERROR_FAILURE; // nobody call this anywhere in the code
    1: }
    1: 
    1: 
    1: NS_METHOD nsChildView::SetPreferredSize(PRInt32 aWidth, PRInt32 aHeight)
    1: {
    1:   return NS_ERROR_FAILURE; // nobody call this anywhere in the code
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::BeginResizingChildren(void)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::EndResizingChildren(void)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
16520: static const PRInt32 resizeIndicatorWidth = 15;
16520: static const PRInt32 resizeIndicatorHeight = 15;
16520: PRBool nsChildView::ShowsResizeIndicator(nsIntRect* aResizerRect)
16520: {
16520:   NSView *topLevelView = mView, *superView = nil;
17108:   while ((superView = [topLevelView superview]))
16520:     topLevelView = superView;
16520: 
16520:   if (![[topLevelView window] showsResizeIndicator])
16520:     return PR_FALSE;
16520: 
16520:   if (aResizerRect) {
16520:     NSSize bounds = [topLevelView bounds].size;
16520:     NSPoint corner = NSMakePoint(bounds.width, [topLevelView isFlipped] ? bounds.height : 0);
16520:     corner = [topLevelView convertPoint:corner toView:mView];
16520:     aResizerRect->SetRect(NSToIntRound(corner.x) - resizeIndicatorWidth,
16520:                           NSToIntRound(corner.y) - resizeIndicatorHeight,
16520:                           resizeIndicatorWidth, resizeIndicatorHeight);
16520:   }
16520:   return PR_TRUE;
16520: }
16520: 
16520: 
    1: NS_IMETHODIMP nsChildView::GetPluginClipRect(nsRect& outClipRect, nsPoint& outOrigin, PRBool& outWidgetVisible)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
  130:   NS_ASSERTION(mIsPluginView, "GetPluginClipRect must only be called on a plugin widget");
  130:   if (!mIsPluginView) return NS_ERROR_FAILURE;
    1:   
    1:   NSWindow* window = [mView nativeWindow];
    1:   if (!window) return NS_ERROR_FAILURE;
    1:   
    1:   NSPoint viewOrigin = [mView convertPoint:NSZeroPoint toView:nil];
    1:   NSRect frame = [[window contentView] frame];
    1:   viewOrigin.y = frame.size.height - viewOrigin.y;
    1:   
    1:   // set up the clipping region for plugins.
    1:   NSRect visibleBounds = [mView visibleRect];
    1:   NSPoint clipOrigin   = [mView convertPoint:visibleBounds.origin toView:nil];
    1:   
    1:   // Convert from cocoa to QuickDraw coordinates
    1:   clipOrigin.y = frame.size.height - clipOrigin.y;
    1:   
    1:   outClipRect.x = (nscoord)clipOrigin.x;
    1:   outClipRect.y = (nscoord)clipOrigin.y;
    1:   
    1:   
    1:   PRBool isVisible;
    1:   IsVisible(isVisible);
    1:   if (isVisible && [mView window] != nil) {
    1:     outClipRect.width  = (nscoord)visibleBounds.size.width;
    1:     outClipRect.height = (nscoord)visibleBounds.size.height;
    1:     outWidgetVisible = PR_TRUE;
    1:   }
    1:   else {
    1:     outClipRect.width = 0;
    1:     outClipRect.height = 0;
    1:     outWidgetVisible = PR_FALSE;
    1:   }
    1: 
    1:   // need to convert view's origin to window coordinates.
    1:   // then, encode as "SetOrigin" ready values.
    1:   outOrigin.x = (nscoord)-viewOrigin.x;
    1:   outOrigin.y = (nscoord)-viewOrigin.y;
    1:   
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::StartDrawPlugin()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
  130:   NS_ASSERTION(mIsPluginView, "StartDrawPlugin must only be called on a plugin widget");
  130:   if (!mIsPluginView) return NS_ERROR_FAILURE;
  130: 
13180:   // Prevent reentrant "drawing" (or in fact reentrant handling of any plugin
13180:   // event).  Doing this for both CoreGraphics and QuickDraw plugins restores
13180:   // the 1.8-branch behavior wrt reentrancy, and fixes (or works around) bugs
13180:   // caused by plugins depending on the old behavior -- e.g. bmo bug 409615.
    1:   if (mPluginDrawing)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NSWindow* window = [mView nativeWindow];
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   // It appears that the WindowRef from which we get the plugin port undergoes the
    1:   // traditional BeginUpdate/EndUpdate cycle, which, if you recall, sets the visible
    1:   // region to the intersection of the visible region and the update region. Since
    1:   // we don't know here if we're being drawn inside a BeginUpdate/EndUpdate pair
    1:   // (which seem to occur in [NSWindow display]), and we don't want to have the burden
    1:   // of correctly doing Carbon invalidates of the plugin rect, we manually set the
14027:   // visible region to be the entire port every time. It is necessary to set up our
14027:   // window's port even for CoreGraphics plugins, because they may still use Carbon
14027:   // internally (see bug #420527 for details).
14027:   CGrafPtr port = ::GetWindowPort(WindowRef([window windowRef]));
14027:   if (!mPluginIsCG)
14027:     port = mPluginPort.qdPort.port;
14027: 
    1:   RgnHandle pluginRegion = ::NewRgn();
    1:   if (pluginRegion) {
14027:     PRBool portChanged = (port != CGrafPtr(GetQDGlobalsThePort()));
    1:     CGrafPtr oldPort;
    1:     GDHandle oldDevice;
    1: 
    1:     if (portChanged) {
    1:       ::GetGWorld(&oldPort, &oldDevice);
14027:       ::SetGWorld(port, ::IsPortOffscreen(port) ? nsnull : ::GetMainDevice());
    1:     }
    1: 
    1:     ::SetOrigin(0, 0);
    1:     
    1:     nsRect clipRect; // this is in native window coordinates
    1:     nsPoint origin;
    1:     PRBool visible;
    1:     GetPluginClipRect(clipRect, origin, visible);
    1:     
    1:     // XXX if we're not visible, set an empty clip region?
    1:     Rect pluginRect;
    1:     ConvertGeckoRectToMacRect(clipRect, pluginRect);
    1:     
    1:     ::RectRgn(pluginRegion, &pluginRect);
14027:     ::SetPortVisibleRegion(port, pluginRegion);
14027:     ::SetPortClipRegion(port, pluginRegion);
    1:     
    1:     // now set up the origin for the plugin
    1:     ::SetOrigin(origin.x, origin.y);
    1:     
    1:     ::DisposeRgn(pluginRegion);
    1: 
    1:     if (portChanged)
    1:       ::SetGWorld(oldPort, oldDevice);
    1:   }
    1: 
    1:   mPluginDrawing = PR_TRUE;
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::EndDrawPlugin()
    1: {
  130:   NS_ASSERTION(mIsPluginView, "EndDrawPlugin must only be called on a plugin widget");
  130:   if (!mIsPluginView) return NS_ERROR_FAILURE;
  130: 
    1:   mPluginDrawing = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: 
14641: NS_IMETHODIMP nsChildView::SetPluginInstanceOwner(nsIPluginInstanceOwner* aInstanceOwner)
14641: {
14641:   mPluginInstanceOwner = aInstanceOwner;
14641: 
14641:   return NS_OK;
14641: }
14641: 
14641: 
    1: void nsChildView::LiveResizeStarted()
    1: {
    1:   // XXX todo. Use this to disable Java async redraw during resize
    1:   mLiveResizeInProgress = PR_TRUE;
    1: }
    1: 
    1: 
    1: void nsChildView::LiveResizeEnded()
    1: {
    1:   mLiveResizeInProgress = PR_FALSE;
    1: }
    1: 
14962: static NSString* ToNSString(const nsAString& aString)
14962: {
14962:   return [NSString stringWithCharacters:aString.BeginReading()
14962:                                  length:aString.Length()];
14962: }
14962: 
15097: struct KeyboardLayoutOverride {
15097:   PRInt32 mKeyboardLayout;
15097:   PRBool mOverrideEnabled;
15097: };
15097: 
15097: static KeyboardLayoutOverride gOverrideKeyboardLayout;
14962: 
14962: static const PRUint32 sModifierFlagMap[][2] = {
14962:   { nsIWidget::CAPS_LOCK, NSAlphaShiftKeyMask },
14962:   { nsIWidget::SHIFT_L, NSShiftKeyMask },
14962:   { nsIWidget::CTRL_L, NSControlKeyMask },
14962:   { nsIWidget::ALT_L, NSAlternateKeyMask },
14962:   { nsIWidget::COMMAND, NSCommandKeyMask },
14962:   { nsIWidget::NUMERIC_KEY_PAD, NSNumericPadKeyMask },
14962:   { nsIWidget::HELP, NSHelpKeyMask },
14962:   { nsIWidget::FUNCTION, NSFunctionKeyMask }
14962: };
14999: nsresult nsChildView::SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
14962:                                                PRInt32 aNativeKeyCode,
14962:                                                PRUint32 aModifierFlags,
14962:                                                const nsAString& aCharacters,
14962:                                                const nsAString& aUnmodifiedCharacters)
14962: {
14999:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
14962:   
14962:   PRUint32 modifierFlags = 0;
14962:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(sModifierFlagMap); ++i) {
14962:     if (aModifierFlags & sModifierFlagMap[i][0]) {
14962:       modifierFlags |= sModifierFlagMap[i][1];
14962:     }
14962:   }
14962:   int windowNumber = [[mView window] windowNumber];
14962:   NSEvent* downEvent = [NSEvent keyEventWithType:NSKeyDown
14962:                                         location:NSMakePoint(0,0)
14962:                                    modifierFlags:modifierFlags
14962:                                        timestamp:0
14962:                                     windowNumber:windowNumber
14962:                                          context:[NSGraphicsContext currentContext]
14962:                                       characters:ToNSString(aCharacters)
14962:                      charactersIgnoringModifiers:ToNSString(aUnmodifiedCharacters)
14962:                                        isARepeat:NO
14962:                                          keyCode:aNativeKeyCode];
14962: 
14962:   NSEvent* upEvent = [ChildView makeNewCocoaEventWithType:NSKeyUp
14962:                                                 fromEvent:downEvent];
14962: 
14962:   if (downEvent && upEvent) {
15097:     KeyboardLayoutOverride currentLayout = gOverrideKeyboardLayout;
15097:     gOverrideKeyboardLayout.mKeyboardLayout = aNativeKeyboardLayout;
15097:     gOverrideKeyboardLayout.mOverrideEnabled = PR_TRUE;
14984:     [NSApp sendEvent:downEvent];
14984:     [NSApp sendEvent:upEvent];
14962:     // processKeyDownEvent and keyUp block exceptions so we're sure to
14962:     // reach here to restore gOverrideKeyboardLayout
14962:     gOverrideKeyboardLayout = currentLayout;
14962:   }
14962: 
14999:   return NS_OK;
14999: 
14999:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
14962: }
    1: 
15578: // Used for testing native menu system structure and event handling.
15578: NS_IMETHODIMP nsChildView::ActivateNativeMenuItemAt(const nsAString& indexString)
15578: {
16264:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
16264: 
15578:   NSString* title = [NSString stringWithCharacters:indexString.BeginReading() length:indexString.Length()];
15578:   NSArray* indexes = [title componentsSeparatedByString:@"|"];
15578:   unsigned int indexCount = [indexes count];
15578:   if (indexCount == 0)
15578:     return NS_OK;
15578:   
15578:   NSMenu* currentSubmenu = [NSApp mainMenu];
15578:   for (unsigned int i = 0; i < (indexCount - 1); i++) {
15578:     NSMenu* newSubmenu = nil;
15578:     int targetIndex;
15578:     // We remove the application menu from consideration for the top-level menu
15578:     if (i == 0)
15578:       targetIndex = [[indexes objectAtIndex:i] intValue] + 1;
15578:     else
15578:       targetIndex = [[indexes objectAtIndex:i] intValue];
15578:     int itemCount = [currentSubmenu numberOfItems];
15578:     if (targetIndex < itemCount) {
15578:       NSMenuItem* menuItem = [currentSubmenu itemAtIndex:targetIndex];
15578:       if ([menuItem hasSubmenu])
15578:         newSubmenu = [menuItem submenu];
15578:     }
15578:     
15578:     if (newSubmenu)
15578:       currentSubmenu = newSubmenu;
15578:     else
15578:       return NS_ERROR_FAILURE;
15578:   }
15578: 
15578:   int itemCount = [currentSubmenu numberOfItems];
15578:   int targetIndex = [[indexes objectAtIndex:(indexCount - 1)] intValue];
16264:   // We can't perform an action on an item with a submenu, that will raise
16264:   // an obj-c exception.
16264:   if (targetIndex < itemCount && ![[currentSubmenu itemAtIndex:targetIndex] hasSubmenu]) {
15578:       // NSLog(@"Performing action for native menu item titled: %@\n",
15578:       //       [[currentSubmenu itemAtIndex:targetIndex] title]);
15578:       [currentSubmenu performActionForItemAtIndex:targetIndex];      
15578:   }
15578:   else {
15578:     return NS_ERROR_FAILURE;
15578:   }
15578: 
15578:   return NS_OK;
16264: 
16264:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
16264: }
16264: 
16264: 
16264: NS_IMETHODIMP nsChildView::ForceNativeMenuReload()
16264: {
16264:   id windowDelegate = [[mView nativeWindow] delegate];
16264:   if (windowDelegate && [windowDelegate isKindOfClass:[WindowDelegate class]]) {
16264:     nsCocoaWindow *widget = [(WindowDelegate *)windowDelegate geckoWidget];
16264:     if (widget) {
16264:       nsMenuBarX* mb = widget->GetMenuBar();
16264:       if (mb) {
16264:         mb->ForceNativeMenuReload();
16264:       }
16264:     }
16264:   }
16264: 
16264:   return NS_OK;
16264: }
16264: 
15578: 
    1: #pragma mark -
    1: 
    1: 
    1: #ifdef INVALIDATE_DEBUGGING
    1: 
    1: static Boolean KeyDown(const UInt8 theKey)
    1: {
    1:   KeyMap map;
    1:   GetKeys(map);
    1:   return ((*((UInt8 *)map + (theKey >> 3)) >> (theKey & 7)) & 1) != 0;
    1: }
    1: 
    1: static Boolean caps_lock()
    1: {
    1:   return KeyDown(0x39);
    1: }
    1: 
    1: static void blinkRect(Rect* r)
    1: {
    1:   StRegionFromPool oldClip;
    1:   if (oldClip != NULL)
    1:     ::GetClip(oldClip);
    1: 
    1:   ::ClipRect(r);
    1:   ::InvertRect(r);
    1:   UInt32 end = ::TickCount() + 5;
    1:   while (::TickCount() < end) ;
    1:   ::InvertRect(r);
    1: 
    1:   if (oldClip != NULL)
    1:     ::SetClip(oldClip);
    1: }
    1: 
    1: static void blinkRgn(RgnHandle rgn)
    1: {
    1:   StRegionFromPool oldClip;
    1:   if (oldClip != NULL)
    1:     ::GetClip(oldClip);
    1: 
    1:   ::SetClip(rgn);
    1:   ::InvertRgn(rgn);
    1:   UInt32 end = ::TickCount() + 5;
    1:   while (::TickCount() < end) ;
    1:   ::InvertRgn(rgn);
    1: 
    1:   if (oldClip != NULL)
    1:     ::SetClip(oldClip);
    1: }
    1: 
    1: #endif
    1: 
    1: 
    1: // Invalidate this component's visible area
    1: NS_IMETHODIMP nsChildView::Invalidate(PRBool aIsSynchronous)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (!mView || !mVisible)
    1:     return NS_OK;
    1: 
    1:   if (aIsSynchronous) {
    1:     [mView display];
    1:   }
    1:   else if ([NSView focusView]) {
    1:     // if a view is focussed (i.e. being drawn), then postpone the invalidate so that we
    1:     // don't lose it.
    1:     [mView setNeedsPendingDisplay];
    1:   }
    1:   else {
    1:     [mView setNeedsDisplay:YES];
    1:   }
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: // Invalidate this component's visible area
19835: NS_IMETHODIMP nsChildView::Invalidate(const nsRect &aRect, PRBool aIsSynchronous)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (!mView || !mVisible)
    1:     return NS_OK;
    1: 
    1:   NSRect r;
    1:   GeckoRectToNSRect(aRect, r);
    1:   
    1:   if (aIsSynchronous) {
    1:     [mView displayRect:r];
    1:   }
    1:   else if ([NSView focusView]) {
    1:     // if a view is focussed (i.e. being drawn), then postpone the invalidate so that we
    1:     // don't lose it.
    1:     [mView setNeedsPendingDisplayInRect:r];
    1:   }
    1:   else {
    1:     [mView setNeedsDisplayInRect:r];
    1:   }
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: // Validate the widget
    1: NS_IMETHODIMP nsChildView::Validate()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   [mView setNeedsDisplay:NO];
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: // Invalidate this component's visible area
    1: NS_IMETHODIMP nsChildView::InvalidateRegion(const nsIRegion *aRegion, PRBool aIsSynchronous)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   if (!mView || !mVisible)
    1:     return NS_OK;
    1: 
    1:   // FIXME rewrite to use a Cocoa region when nsIRegion isn't a QD Region
    1:   NSRect r;
19835:   nsRect bounds;
 3233:   nsIRegion* region = const_cast<nsIRegion*>(aRegion);     // ugh. this method should be const
    1:   region->GetBoundingBox(&bounds.x, &bounds.y, &bounds.width, &bounds.height);
    1:   GeckoRectToNSRect(bounds, r);
    1:   
    1:   if (aIsSynchronous)
    1:     [mView displayRect:r];
    1:   else
    1:     [mView setNeedsDisplayInRect:r];
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: inline PRUint16 COLOR8TOCOLOR16(PRUint8 color8)
    1: {
    1:   // return (color8 == 0xFF ? 0xFFFF : (color8 << 8));
    1:   return (color8 << 8) | color8;  /* (color8 * 257) == (color8 * 0x0101) */
    1: }
    1: 
    1: 
    1: // Dummy impl, meant to be overridden
    1: PRBool
    1: nsChildView::OnPaint(nsPaintEvent &event)
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: // this is handled for us by UpdateWidget
    1: NS_IMETHODIMP nsChildView::Update()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   // Update means "Flush any pending changes right now."  It does *not* mean
    1:   // repaint the world. :) -- dwh
    1:   [mView displayIfNeeded];
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: // Scroll the bits of a view and its children
    1: // FIXME: I'm sure the invalidating can be optimized, just no time now.
19835: NS_IMETHODIMP nsChildView::Scroll(PRInt32 aDx, PRInt32 aDy, nsRect *aClipRect)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
19519:   NS_ASSERTION(mParentView, "Attempting to scroll a view that does not have a parent");
19519:   if (!mParentView)
19519:     return NS_ERROR_NOT_AVAILABLE;
19519: 
    1:   BOOL viewWasDirty = NO;
    1:   if (mVisible) {
    1:     viewWasDirty = [mView needsDisplay];
    1: 
    1:     NSSize scrollVector = {aDx,aDy};
    1:     [mView scrollRect: [mView visibleRect] by:scrollVector];
    1:   }
    1:   
    1:   // Scroll the children (even if the widget is not visible)
    1:   for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
    1:     // We use resize rather than move since it gives us control
    1:     // over repainting.  We can scroll like a bat out of hell
    1:     // by not wasting time invalidating the widgets, since it's
    1:     // completely unnecessary to do so.
19835:     nsRect bounds;
    1:     kid->GetBounds(bounds);
    1:     kid->Resize(bounds.x + aDx, bounds.y + aDy, bounds.width, bounds.height, PR_FALSE);
    1:   }
    1: 
10305:   if (mOnDestroyCalled)
10305:     return NS_OK;
10305: 
    1:   if (mVisible) {
    1:     if (viewWasDirty) {
    1:       [mView setNeedsDisplay:YES];
    1:     }
    1:     else {
    1:       NSRect frame = [mView visibleRect];
    1:       NSRect horizInvalid = frame;
    1:       NSRect vertInvalid = frame;
    1:   
    1:       if (aDx != 0) {
    1:         horizInvalid.size.width = abs(aDx);
    1:         if (aDx < 0)
    1:           horizInvalid.origin.x = frame.origin.x + frame.size.width + aDx;
    1:         [mView setNeedsDisplayInRect: horizInvalid];
    1:       }
    1: 
    1:       if (aDy != 0) {
    1:         vertInvalid.size.height = abs(aDy);
    1:         if (aDy < 0)
    1:           vertInvalid.origin.y = frame.origin.y + frame.size.height + aDy;
    1:         [mView setNeedsDisplayInRect: vertInvalid];
    1:       }
    1: 
    1:       // We also need to check for any ChildViews which overlap this widget
    1:       // but are not descendent widgets.  If there are any, we need to
    1:       // invalidate the area of this view that these ChildViews will have been
    1:       // blitted into, since these widgets aren't supposed to scroll with
    1:       // this widget.
    1: 
    1:       // To do this, start at the root Gecko NSView, and walk down along
    1:       // our ancestor view chain, looking at all the subviews in each level
    1:       // of the hierarchy.  If we find a non-ancestor view that overlaps
    1:       // this view, invalidate the area around it.
    1: 
    1:       // We need to convert all rects to a common ancestor view to intersect
    1:       // them, since a view's frame is in the coordinate space of its parent.
    1:       // Use mParentView as the frame of reference.
    1:       NSRect selfFrame = [mParentView convertRect:[mView frame] fromView:[mView superview]];
    1:       NSView* view = mParentView;
    1:       BOOL selfLevel = NO;
    1: 
    1:       while (!selfLevel) {
    1:         NSView* nextAncestorView = nil;
    1:         NSArray* subviews = [view subviews];
    1:         for (unsigned int i = 0; i < [subviews count]; ++i) {
    1:           NSView* subView = [subviews objectAtIndex: i];
    1:           if (subView == mView)
    1:             selfLevel = YES;
    1:           else if ([mView isDescendantOf:subView])
    1:             nextAncestorView = subView;
    1:           else {
    1:             NSRect intersectArea = NSIntersectionRect([mParentView convertRect:[subView frame] fromView:[subView superview]], selfFrame);
    1:             if (!NSIsEmptyRect(intersectArea)) {
    1:               NSPoint origin = [mView convertPoint:intersectArea.origin fromView:mParentView];
    1: 
    1:               if (aDy != 0) {
    1:                 vertInvalid.origin.x = origin.x;
    1:                 if (aDy < 0)  // scrolled down, invalidate above
    1:                   vertInvalid.origin.y = origin.y + aDy;
    1:                 else          // invalidate below
    1:                   vertInvalid.origin.y = origin.y + intersectArea.size.height;
    1:                 vertInvalid.size.width = intersectArea.size.width;
    1:                 [mView setNeedsDisplayInRect: vertInvalid];
    1:               }
    1: 
    1:               if (aDx != 0) {
    1:                 horizInvalid.origin.y = origin.y;
    1:                 if (aDx < 0)  // scrolled right, invalidate to the left
    1:                   horizInvalid.origin.x = origin.x + aDx;
    1:                 else          // invalidate to the right
    1:                   horizInvalid.origin.x = origin.x + intersectArea.size.width;
    1:                 horizInvalid.size.height = intersectArea.size.height;
    1:                 [mView setNeedsDisplayInRect: horizInvalid];
    1:               }
    1:             }
    1:           }
    1:         }
    1:         view = nextAncestorView;
    1:       }
    1:     }
    1:   }
    1:   
    1:   // This is an evil hack that doesn't always work.
    1:   // 
    1:   // Drawing plugins in a Cocoa environment is tricky, because the
    1:   // plugins are living in a Carbon WindowRef/BeginUpdate/EndUpdate
    1:   // world, and Cocoa has its own notion of dirty rectangles. Throw
    1:   // Quartz Extreme and QuickTime into the mix, and things get bad.
    1:   // 
    1:   // This code is working around a cosmetic issue seen when Quartz Extreme
    1:   // is active, and you're scrolling a page with a QuickTime plugin; areas
    1:   // outside the plugin fail to scroll properly. This [display] ensures that
    1:   // the view is properly drawn before the next Scroll call.
    1:   //
    1:   // The time this doesn't work is when you're scrolling a page containing
    1:   // an iframe which in turn contains a plugin.
    1:   //
    1:   // This is turned off because it makes scrolling pages with plugins slow.
    1:   // 
    1:   //if ([mView childViewHasPlugin])
    1:   //  [mView display];
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
 6118: // Invokes callback and ProcessEvent methods on Event Listener object
    1: NS_IMETHODIMP nsChildView::DispatchEvent(nsGUIEvent* event, nsEventStatus& aStatus)
    1: {
12976: #ifdef DEBUG
12976:   debug_DumpEvent(stdout, event->widget, event, nsCAutoString("something"), 0);
12976: #endif
12976: 
    1:   aStatus = nsEventStatus_eIgnore;
    1: 
11297:   nsCOMPtr<nsIWidget> kungFuDeathGrip(mParentWidget ? mParentWidget : this);
    1:   if (mParentWidget) {
    1:     nsWindowType type;
    1:     mParentWidget->GetWindowType(type);
    1:     if (type == eWindowType_popup) {
 4173:       // use the parent popup's widget if there is no view
 4173:       void* clientData = nsnull;
 4173:       if (event->widget)
 4173:         event->widget->GetClientData(clientData);
10305:       if (!clientData)
    1:         event->widget = mParentWidget;
    1:     }
 4173:   }
    1: 
    1:   if (mEventCallback)
    1:     aStatus = (*mEventCallback)(event);
    1: 
    1:   // dispatch to event listener if event was not consumed
    1:   if (mEventListener && aStatus != nsEventStatus_eConsumeNoDefault)
 6118:     aStatus = mEventListener->ProcessEvent(*event);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: PRBool nsChildView::DispatchWindowEvent(nsGUIEvent &event)
    1: {
    1:   nsEventStatus status;
    1:   DispatchEvent(&event, status);
    1:   return ConvertStatus(status);
    1: }
    1: 
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: PRBool nsChildView::ReportDestroyEvent()
    1: {
    1:   nsGUIEvent event(PR_TRUE, NS_DESTROY, this);
    1:   event.time = PR_IntervalNow();
 3653:   return DispatchWindowEvent(event);
    1: }
    1: 
    1: 
    1: PRBool nsChildView::ReportMoveEvent()
    1: {
    1:   nsGUIEvent moveEvent(PR_TRUE, NS_MOVE, this);
    1:   moveEvent.refPoint.x = mBounds.x;
    1:   moveEvent.refPoint.y = mBounds.y;
    1:   moveEvent.time       = PR_IntervalNow();
 3653:   return DispatchWindowEvent(moveEvent);
    1: }
    1: 
    1: 
    1: PRBool nsChildView::ReportSizeEvent()
    1: {
    1:   nsSizeEvent sizeEvent(PR_TRUE, NS_SIZE, this);
    1:   sizeEvent.time        = PR_IntervalNow();
    1:   sizeEvent.windowSize  = &mBounds;
    1:   sizeEvent.mWinWidth   = mBounds.width;
    1:   sizeEvent.mWinHeight  = mBounds.height;
 3653:   return DispatchWindowEvent(sizeEvent);
    1: }
    1: 
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: /*  Calculate the x and y offsets for this particular widget
    1:  *  @update  ps 09/22/98
    1:  *  @param   aX -- x offset amount
    1:  *  @param   aY -- y offset amount 
    1:  *  @return  NOTHING
    1:  */
    1: NS_IMETHODIMP nsChildView::CalcOffset(PRInt32 &aX,PRInt32 &aY)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   aX = aY = 0;
    1:   NSRect bounds = {{0, 0}, {0, 0}};
    1:   bounds = [mView convertRect:bounds toView:nil];
 3233:   aX += static_cast<PRInt32>(bounds.origin.x);
 3233:   aY += static_cast<PRInt32>(bounds.origin.y);
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: // Find if a point in local coordinates is inside this object
    1: PRBool nsChildView::PointInWidget(Point aThePoint)
    1: {
    1:   // get the origin in local coordinates
19835:   nsPoint widgetOrigin(0, 0);
    1:   LocalToWindowCoordinate(widgetOrigin);
    1: 
    1:   // get rectangle relatively to the parent
19835:   nsRect widgetRect;
    1:   GetBounds(widgetRect);
    1: 
    1:   // convert the topLeft corner to local coordinates
    1:   widgetRect.MoveBy(widgetOrigin.x, widgetOrigin.y);
    1: 
    1:   // finally tell whether it's a hit
    1:   return widgetRect.Contains(aThePoint.h, aThePoint.v);
    1: }
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: //    Convert the given rect to global coordinates.
    1: //    @param aLocalRect  -- rect in local coordinates of this widget
    1: //    @param aGlobalRect -- |aLocalRect| in global coordinates
19835: NS_IMETHODIMP nsChildView::WidgetToScreen(const nsRect& aLocalRect, nsRect& aGlobalRect)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   NSRect temp;
    1:   GeckoRectToNSRect(aLocalRect, temp);
    1:   
    1:   // 1. First translate this rect into window coords. The returned rect is always in
    1:   //    bottom-left coordinates.
    1:   //
    1:   //    NOTE: convertRect:toView:nil doesn't care if |mView| is a flipped view (with
    1:   //          top-left coords) and so assumes that our passed-in rect's origin is in
    1:   //          bottom-left coordinates. We adjust this further down, by subtracting
    1:   //          the final screen rect's origin by the rect's height, to get the origo
    1:   //          where we want it.
    1:   temp = [mView convertRect:temp toView:nil];  
    1:   
    1:   // 2. We turn the window-coord rect's origin into screen (still bottom-left) coords.
    1:   temp.origin = [[mView nativeWindow] convertBaseToScreen:temp.origin];
    1:   
    1:   // 3. Since we're dealing in bottom-left coords, we need to make it top-left coords
    1:   //    before we pass it back to Gecko.
    1:   FlipCocoaScreenCoordinate(temp.origin);
    1:   
    1:   // 4. If this is rect has a size (and is not simply a point), it is important to account 
    1:   //    for the fact that convertRect:toView:nil thought our passed-in point was in bottom-left 
    1:   //    coords in step #1. Thus, we subtract the rect's height, to get the top-left rect's origin 
    1:   //     where we want it.
    1:   temp.origin.y -= temp.size.height;
    1:   
    1:   NSRectToGeckoRect(temp, aGlobalRect);
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: //    Convert the given rect to local coordinates.
    1: //    @param aGlobalRect  -- rect in screen coordinates 
    1: //    @param aLocalRect -- |aGlobalRect| in coordinates of this widget
19835: NS_IMETHODIMP nsChildView::ScreenToWidget(const nsRect& aGlobalRect, nsRect& aLocalRect)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   NSRect temp;
    1:   GeckoRectToNSRect(aGlobalRect, temp);
    1:   FlipCocoaScreenCoordinate(temp.origin);
    1: 
    1:   temp.origin = [[mView nativeWindow] convertScreenToBase:temp.origin];   // convert to screen coords
    1:   temp = [mView convertRect:temp fromView:nil];                     // convert to window coords
    1: 
    1:   NSRectToGeckoRect(temp, aLocalRect);
    1:   
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: } 
    1: 
    1: 
    1: // Convert the coordinates to some device coordinates so GFX can draw.
    1: void nsChildView::ConvertToDeviceCoordinates(nscoord &aX, nscoord &aY)
    1: {
    1:   PRInt32 offX = 0, offY = 0;
    1:   this->CalcOffset(offX,offY);
    1: 
    1:   aX += offX;
    1:   aY += offY;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::CaptureRollupEvents(nsIRollupListener * aListener, 
    1:                                                PRBool aDoCapture, 
    1:                                                PRBool aConsumeRollupEvent)
    1: {
    1:   // this never gets called, only top-level windows can be rollup widgets
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::SetTitle(const nsAString& title)
    1: {
 3653:   // child views don't have titles
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsChildView::GetAttention(PRInt32 aCycleCount)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   [NSApp requestUserAttention:NSInformationalRequest];
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: // Force Input Method Editor to commit the uncommited input
15919: // Note that this and other IME methods don't necessarily
    1: // get called on the same ChildView that input is going through.
    1: NS_IMETHODIMP nsChildView::ResetInputState()
    1: {
    1: #ifdef DEBUG_IME
    1:   NSLog(@"**** ResetInputState");
    1: #endif
    1: 
  539:   nsTSMManager::CommitIME();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // 'open' means that it can take non-ASCII chars
    1: NS_IMETHODIMP nsChildView::SetIMEOpenState(PRBool aState)
    1: {
  539: #ifdef DEBUG_IME
  539:   NSLog(@"**** SetIMEOpenState aState = %d", aState);
  539: #endif
  539: 
  539:   nsTSMManager::SetIMEOpenState(aState);
  539:   return NS_OK;
    1: }
    1: 
    1: 
    1: // 'open' means that it can take non-ASCII chars
    1: NS_IMETHODIMP nsChildView::GetIMEOpenState(PRBool* aState)
    1: {
  539: #ifdef DEBUG_IME
  539:   NSLog(@"**** GetIMEOpenState");
  539: #endif
  539: 
  539:   *aState = nsTSMManager::GetIMEOpenState();
  539:   return NS_OK;
  539: }
  539: 
  539: 
  539: NS_IMETHODIMP nsChildView::SetIMEEnabled(PRUint32 aState)
    1: {
  539: #ifdef DEBUG_IME
  539:   NSLog(@"**** SetIMEEnabled aState = %d", aState);
  539: #endif
  539: 
  539:   switch (aState) {
15919:     case nsIWidget::IME_STATUS_ENABLED:
  539:       nsTSMManager::SetRomanKeyboardsOnly(PR_FALSE);
  539:       nsTSMManager::EnableIME(PR_TRUE);
  539:       break;
15919:     case nsIWidget::IME_STATUS_DISABLED:
  539:       nsTSMManager::SetRomanKeyboardsOnly(PR_FALSE);
  539:       nsTSMManager::EnableIME(PR_FALSE);
  539:       break;
15919:     case nsIWidget::IME_STATUS_PASSWORD:
  539:       nsTSMManager::SetRomanKeyboardsOnly(PR_TRUE);
  539:       nsTSMManager::EnableIME(PR_FALSE);
  539:       break;
  539:     default:
  539:       NS_ERROR("not implemented!");
  539:   }
  539:   return NS_OK;
  539: }
  539: 
  539: 
  539: NS_IMETHODIMP nsChildView::GetIMEEnabled(PRUint32* aState)
    1: {
  539: #ifdef DEBUG_IME
  539:   NSLog(@"**** GetIMEEnabled");
  539: #endif
  539: 
  539:   if (nsTSMManager::IsIMEEnabled())
15919:     *aState = nsIWidget::IME_STATUS_ENABLED;
  539:   else if (nsTSMManager::IsRomanKeyboardsOnly())
15919:     *aState = nsIWidget::IME_STATUS_PASSWORD;
  539:   else
15919:     *aState = nsIWidget::IME_STATUS_DISABLED;
  539:   return NS_OK;
    1: }
    1: 
    1: 
    1: // Destruct and don't commit the IME composition string.
    1: NS_IMETHODIMP nsChildView::CancelIMEComposition()
    1: {
    1: #ifdef DEBUG_IME
    1:   NSLog(@"**** CancelIMEComposition");
    1: #endif
    1: 
  539:   nsTSMManager::CancelIME();
    1:   return NS_OK;
    1: }
    1: 
    1: 
 2475: NS_IMETHODIMP nsChildView::GetToggledKeyState(PRUint32 aKeyCode,
 2475:                                               PRBool* aLEDState)
 2475: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 2475: #ifdef DEBUG_IME
 2475:   NSLog(@"**** GetToggledKeyState");
 2475: #endif
 2475:   NS_ENSURE_ARG_POINTER(aLEDState);
 2475:   PRUint32 key;
 2475:   switch (aKeyCode) {
 2475:     case NS_VK_CAPS_LOCK:
 2475:       key = alphaLock;
 2475:       break;
 2475:     case NS_VK_NUM_LOCK:
 2475:       key = kEventKeyModifierNumLockMask;
 2475:       break;
 2475:     // Mac doesn't support SCROLL_LOCK state.
 2475:     default:
 2475:       return NS_ERROR_NOT_IMPLEMENTED;
 2475:   }
12558:   PRUint32 modifierFlags = ::GetCurrentEventKeyModifiers();
 2475:   *aLEDState = (modifierFlags & key) != 0;
 2475:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 2475: }
 2475: 
 2475: 
    1: #pragma mark -
    1: 
    1: 
    1: gfxASurface*
    1: nsChildView::GetThebesSurface()
    1: {
    1:   if (!mTempThebesSurface) {
    1:     mTempThebesSurface = new gfxQuartzSurface(gfxSize(1, 1), gfxASurface::ImageFormatARGB32);
    1:   }
    1: 
 1556:   return mTempThebesSurface;
    1: }
    1: 
    1: 
 6348: NS_IMETHODIMP
 6348: nsChildView::BeginSecureKeyboardInput()
 6348: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 6348:   nsresult rv = nsBaseWidget::BeginSecureKeyboardInput();
 6348:   if (NS_SUCCEEDED(rv))
 6348:     ::EnableSecureEventInput();
 6348:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 6348: }
 6348: 
 6348: 
 6348: NS_IMETHODIMP
 6348: nsChildView::EndSecureKeyboardInput()
 6348: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 6348:   nsresult rv = nsBaseWidget::EndSecureKeyboardInput();
 6348:   if (NS_SUCCEEDED(rv))
 6348:     ::DisableSecureEventInput();
 6348:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 6348: }
 6348: 
 6348: 
    1: #ifdef ACCESSIBILITY
    1: void
    1: nsChildView::GetDocumentAccessible(nsIAccessible** aAccessible)
    1: {
    1:   *aAccessible = nsnull;
    1:   
    1:   nsCOMPtr<nsIAccessible> accessible = do_QueryReferent(mAccessible);
    1:   if (!mAccessible) {
    1:     // need to fetch the accessible anew, because it has gone away.
    1:     nsEventStatus status;
    1:     nsAccessibleEvent event(PR_TRUE, NS_GETACCESSIBLE, this);
    1:     DispatchEvent(&event, status);
    1:   
    1:     // cache the accessible in our weak ptr
    1:     mAccessible = do_GetWeakReference(event.accessible);
    1:     
    1:     // now try again
    1:     accessible = do_QueryReferent(mAccessible);
    1:   }
    1:   
    1:   NS_IF_ADDREF(*aAccessible = accessible.get());
    1: 
    1:   return;
    1: }
    1: #endif
    1: 
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: @implementation ChildView
    1: 
    1: 
    1: // globalDragPboard is non-null during native drag sessions that did not originate
    1: // in our native NSView (it is set in |draggingEntered:|). It is unset when the
    1: // drag session ends for this view, either with the mouse exiting or when a drop
    1: // occurs in this view.
    1: NSPasteboard* globalDragPboard = nil;
    1: 
    1: 
 6245: // gLastDragView and gLastDragEvent are only non-null during calls to |mouseDragged:|
    1: // in our native NSView. They are used to communicate information to the drag service
    1: // during drag invocation (starting a drag in from the view). All drag service drag
    1: // invocations happen only while these two global variables are non-null, while |mouseDragged:|
    1: // is on the stack.
 6245: NSView* gLastDragView = nil;
 6245: NSEvent* gLastDragEvent = nil;
    1: 
    1: 
 6754: // initWithFrame:geckoChild:
 6754: - (id)initWithFrame:(NSRect)inFrame geckoChild:(nsChildView*)inChild
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   if ((self = [super initWithFrame:inFrame])) {
 6563:     mWindow = nil;
    1:     mGeckoChild = inChild;
    1:     mIsPluginView = NO;
12429: 
    1:     mCurKeyEvent = nil;
 8339:     mKeyDownHandled = PR_FALSE;
13042:     mKeyPressHandled = NO;
12429:     mKeyPressSent = NO;
    1: 
    1:     // initialization for NSTextInput
    1:     mMarkedRange.location = NSNotFound;
    1:     mMarkedRange.length = 0;
12429: 
13976:     mLastMouseDownEvent = nil;
    1:     mDragService = nsnull;
15585: 
15585:     mPluginTSMDoc = nil;
    1:   }
    1:   
    1:   // register for things we'll take from other applications
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView initWithFrame: registering drag types\n"));
    1:   [self registerForDraggedTypes:[NSArray arrayWithObjects:NSFilenamesPboardType,
    1:                                                           NSStringPboardType,
    1:                                                           NSURLPboardType,
 3545:                                                           NSFilesPromisePboardType,
 1933:                                                           kWildcardPboardType,
 6273:                                                           kCorePboardType_url,
 6387:                                                           kCorePboardType_urld,
 6273:                                                           kCorePboardType_urln,
    1:                                                           nil]];
19344:   [[NSNotificationCenter defaultCenter] addObserver:self
19492:                                            selector:@selector(systemColorChanged)
19344:                                                name:NSControlTintDidChangeNotification
19344:                                              object:nil];
19492:   [[NSNotificationCenter defaultCenter] addObserver:self
19492:                                            selector:@selector(systemColorChanged)
19492:                                                name:NSSystemColorsDidChangeNotification
19492:                                              object:nil];
    1: 
    1:   return self;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: 
    1: - (void)dealloc
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   [mPendingDirtyRects release];
13976:   [mLastMouseDownEvent release];
15585:   if (mPluginTSMDoc)
15585:     ::DeleteTSMDocument(mPluginTSMDoc);
    1:   
    1:   if (sLastViewEntered == self)
    1:     sLastViewEntered = nil;
    1: 
19344:   [[NSNotificationCenter defaultCenter] removeObserver:self];
19344: 
 6013:   [super dealloc];    
 6013: 
 6013:   // This sets the current port to _savePort.
 6013:   // todo: Only do if a Quickdraw plugin is present in the hierarchy!
 6013:   ::SetPort(NULL);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)widgetDestroyed
    1: {
15931:   nsTSMManager::OnDestroyView(self);
    1:   mGeckoChild = nsnull;
19931:   mWindow = nil;
 6789:   // Just in case we're destroyed abruptly and missed the draggingExited
 6789:   // or performDragOperation message.
 6789:   NS_IF_RELEASE(mDragService);
    1: }
    1: 
    1: 
    1: // mozView method, return our gecko child view widget. Note this does not AddRef.
    1: - (nsIWidget*) widget
    1: {
 3233:   return static_cast<nsIWidget*>(mGeckoChild);
    1: }
    1: 
    1: 
    1: // mozView method, get the window that this view is associated with
    1: - (NSWindow*)nativeWindow
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   NSWindow* currWin = [self window];
    1:   if (currWin)
    1:      return currWin;
    1:   else
    1:      return mWindow;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: 
    1: // mozView method, set the NSWindow that this view is associated with (even when
    1: // not in the view hierarchy).
    1: - (void)setNativeWindow:(NSWindow*)aWindow
    1: {
    1:   mWindow = aWindow;
    1: }
    1: 
    1: 
19492: - (void)systemColorChanged
19344: {
19344:   if (!mGeckoChild)
19344:     return;
19344: 
19344:   nsGUIEvent guiEvent(PR_TRUE, NS_THEMECHANGED, mGeckoChild);
19344:   mGeckoChild->DispatchWindowEvent(guiEvent);
19344: }
19344: 
19344: 
    1: - (void)setNeedsPendingDisplay
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   mPendingFullDisplay = YES;
    1:   [self performSelector:@selector(processPendingRedraws) withObject:nil afterDelay:0];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)setNeedsPendingDisplayInRect:(NSRect)invalidRect
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (!mPendingDirtyRects)
    1:     mPendingDirtyRects = [[NSMutableArray alloc] initWithCapacity:1];
    1:   [mPendingDirtyRects addObject:[NSValue valueWithRect:invalidRect]];
    1:   [self performSelector:@selector(processPendingRedraws) withObject:nil afterDelay:0];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: // Clears the queue of any pending invalides
    1: - (void)processPendingRedraws
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (mPendingFullDisplay) {
    1:     [self setNeedsDisplay:YES];
    1:   }
    1:   else {
    1:     unsigned int count = [mPendingDirtyRects count];
    1:     for (unsigned int i = 0; i < count; ++i) {
    1:       [self setNeedsDisplayInRect:[[mPendingDirtyRects objectAtIndex:i] rectValue]];
    1:     }
    1:   }
    1:   mPendingFullDisplay = NO;
    1:   [mPendingDirtyRects release];
    1:   mPendingDirtyRects = nil;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (NSString*)description
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   return [NSString stringWithFormat:@"ChildView %p, gecko child %p, frame %@", self, mGeckoChild, NSStringFromRect([self frame])];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: 
    1: // Find the nearest scrollable view for this ChildView
    1: // (recall that views are not refcounted)
    1: - (nsIScrollableView*) getScrollableView
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
11978: 
    1:   nsIScrollableView* scrollableView = nsnull;
    1: 
    1:   ChildView* currView = self;
    1:   // we have to loop up through superviews in case the view that received the
    1:   // mouseDown is in fact a plugin view with no scrollbars
    1:   while (currView) {
    1:     // This is a hack I learned in nsView::GetViewFor(nsIWidget* aWidget)
    1:     // that I'm not sure is kosher. If anyone knows a better way to get
    1:     // the view for a widget, I'd love to hear it. --Nathan
    1: 
    1:     void* clientData;
    1:     [currView widget]->GetClientData(clientData);
    1: 
    1:     nsISupports* data = (nsISupports*)clientData;
    1:     nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(data));
    1:     if (req) {
    1:       req->GetInterface(NS_GET_IID(nsIScrollableView), (void**)&scrollableView);
    1:       if (scrollableView)
    1:         break;
    1:     }
    1: 
    1:     if ([[currView superview] isMemberOfClass:[ChildView class]])
    1:         currView = (ChildView*)[currView superview];
    1:     else
    1:         currView = nil;
    1:   }
    1: 
    1:   return scrollableView;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
    1: }
    1: 
    1: 
    1: // set the closed hand cursor and record the starting scroll positions
    1: - (void) startHandScroll:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   mHandScrollStartMouseLoc = [[self window] convertBaseToScreen:[theEvent locationInWindow]];
    1: 
    1:   nsIScrollableView* aScrollableView = [self getScrollableView]; 
    1: 
    1:   // if we succeeded in getting aScrollableView
    1:   if (aScrollableView) {
    1:     aScrollableView->GetScrollPosition(mHandScrollStartScrollX, mHandScrollStartScrollY);
    1:     mGeckoChild->SetCursor(eCursor_grabbing);
    1:     mInHandScroll = TRUE;
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: // update the scroll position based on the new mouse coordinates
    1: - (void) updateHandScroll:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   nsIScrollableView* aScrollableView = [self getScrollableView];
    1:   if (!aScrollableView)
    1:     return;
    1: 
    1:   NSPoint newMouseLoc = [[self window] convertBaseToScreen:[theEvent locationInWindow]];
    1: 
    1:   PRInt32 deltaX = (PRInt32)(mHandScrollStartMouseLoc.x - newMouseLoc.x);
    1:   PRInt32 deltaY = (PRInt32)(newMouseLoc.y - mHandScrollStartMouseLoc.y);
    1: 
    1:   // convert to the nsIView coordinates
    1:   PRInt32 p2a = mGeckoChild->GetDeviceContext()->AppUnitsPerDevPixel();
    1:   nscoord newX = mHandScrollStartScrollX + NSIntPixelsToAppUnits(deltaX, p2a);
    1:   nscoord newY = mHandScrollStartScrollY + NSIntPixelsToAppUnits(deltaY, p2a);
    1:   aScrollableView->ScrollTo(newX, newY, NS_VMREFRESH_IMMEDIATE);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: // Return true if the correct modifiers are pressed to perform hand scrolling.
    1: + (BOOL) areHandScrollModifiers:(unsigned int)modifiers
    1: {
    1:   // The command and option key should be held down.  Ignore capsLock by
    1:   // setting it explicitly to match.
    1:   modifiers |= NSAlphaShiftKeyMask;
    1:   return (modifiers & NSDeviceIndependentModifierFlagsMask) ==
    1:       (NSAlphaShiftKeyMask | NSCommandKeyMask | NSAlternateKeyMask);
    1: }
    1: 
    1: 
    1: // If the user is pressing the hand scroll modifiers, then set
    1: // the hand scroll cursor.
    1: - (void) setHandScrollCursor:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   BOOL inMouseView = NO;
    1: 
    1:   // check to see if the user has hand scroll modifiers held down; if so, 
    1:   // find out if the cursor is in an ChildView
19704:   if ([ChildView areHandScrollModifiers:nsCocoaUtils::GetCocoaEventModifierFlags(theEvent)]) {
    1:     NSPoint pointInWindow = [[self window] mouseLocationOutsideOfEventStream];
    1: 
    1:     NSView* mouseView = [[[self window] contentView] hitTest:pointInWindow];
    1:     inMouseView = (mouseView != nil && [mouseView isMemberOfClass:[ChildView class]]);   
    1:   }
    1:   if (inMouseView) {
    1:       mGeckoChild->SetCursor(eCursor_grab);
    1:   } else {
    1:     nsCursor cursor = mGeckoChild->GetCursor();
    1:     if (!mInHandScroll) {
    1:       if (cursor == eCursor_grab || cursor == eCursor_grabbing)
    1:         mGeckoChild->SetCursor(eCursor_standard);
    1:     }
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: // reset the scroll flag and cursor
    1: - (void) stopHandScroll:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   mInHandScroll = FALSE;
    1:   [self setHandScrollCursor:theEvent];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: // When smooth scrolling is turned on on panther, the parent of a scrollbar (which
    1: // I guess they assume is a NSScrollView) gets called with this method. I have no
    1: // idea what the correct return value is, but we have to have this otherwise the scrollbar
    1: // will not continuously respond when the mouse is held down in the pageup/down area.
    1: -(float)_destinationFloatValueForScroller:(id)scroller
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
    1:   return [scroller floatValue];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0.0);
    1: }
    1: 
    1: 
    1: // Override in order to keep our mouse enter/exit tracking rect in sync with
    1: // the frame of the view
    1: - (void)setFrame:(NSRect)frameRect
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   [super setFrame:frameRect];
    1:   if (mMouseEnterExitTag)
    1:     [self removeTrackingRect:mMouseEnterExitTag];
    1: 
    1:   if ([self window])
    1:     mMouseEnterExitTag = [self addTrackingRect:[self bounds]
    1:                                          owner:self
    1:                                       userData:nil
    1:                                   assumeInside:[[self window] acceptsMouseMovedEvents]];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: // Make the origin of this view the topLeft corner (gecko origin) rather
    1: // than the bottomLeft corner (standard cocoa origin).
    1: - (BOOL)isFlipped
    1: {
    1:   return YES;
    1: }
    1: 
    1: 
 9499: - (void)setTransparent:(BOOL)transparent
 9499: {
 9499:   mIsTransparent = transparent;
 9499: }
 9499: 
 9499: 
    1: - (BOOL)isOpaque
    1: {
 9499:   return !mIsTransparent;
    1: }
    1: 
    1: 
    1: -(void)setIsPluginView:(BOOL)aIsPlugin
    1: {
    1:   mIsPluginView = aIsPlugin;
    1: }
    1: 
    1: 
  130: -(BOOL)isPluginView
    1: {
    1:   return mIsPluginView;
    1: }
    1: 
    1: 
    1: - (BOOL)childViewHasPlugin
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
    1:   NSArray* subviews = [self subviews];
    1:   for (unsigned int i = 0; i < [subviews count]; i ++) {
    1:     id subview = [subviews objectAtIndex:i];
  130:     if ([subview respondsToSelector:@selector(isPluginView)] && [subview isPluginView])
    1:       return YES;
    1:   }
    1:   
    1:   return NO;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
    1: }
    1: 
    1: 
 4208: - (void)sendFocusEvent:(PRUint32)eventType
 4208: {
 4208:   if (!mGeckoChild)
 4208:     return;
 4208: 
 4208:   nsEventStatus status = nsEventStatus_eIgnore;
 4208:   nsGUIEvent focusGuiEvent(PR_TRUE, eventType, mGeckoChild);
 4208:   focusGuiEvent.time = PR_IntervalNow();
 4208:   mGeckoChild->DispatchEvent(&focusGuiEvent, status);
 4208: }
 4208: 
 4208: 
    1: // We accept key and mouse events, so don't keep passing them up the chain. Allow
    1: // this to be a 'focussed' widget for event dispatch
    1: - (BOOL)acceptsFirstResponder
    1: {
    1:   return YES;
    1: }
    1: 
    1: 
    1: - (void)viewWillMoveToWindow:(NSWindow *)newWindow
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (mMouseEnterExitTag)
    1:     [self removeTrackingRect:mMouseEnterExitTag];
    1: 
    1:   [super viewWillMoveToWindow:newWindow];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)viewDidMoveToWindow
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if ([self window])
    1:     mMouseEnterExitTag = [self addTrackingRect:[self bounds] owner:self
    1:                                       userData:nil assumeInside: [[self window]
    1:                                       acceptsMouseMovedEvents]];
    1: 
    1:   [super viewDidMoveToWindow];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)viewWillStartLiveResize
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (mGeckoChild && mIsPluginView)
    1:     mGeckoChild->LiveResizeStarted();
    1:   
    1:   [super viewWillStartLiveResize];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)viewDidEndLiveResize
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (mGeckoChild && mIsPluginView)
    1:     mGeckoChild->LiveResizeEnded();
    1: 
    1:   [super viewDidEndLiveResize];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)scrollRect:(NSRect)aRect by:(NSSize)offset
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // Update any pending dirty rects to reflect the new scroll position
    1:   if (mPendingDirtyRects) {
    1:     unsigned int count = [mPendingDirtyRects count];
    1:     for (unsigned int i = 0; i < count; ++i) {
    1:       NSRect oldRect = [[mPendingDirtyRects objectAtIndex:i] rectValue];
    1:       NSRect newRect = NSOffsetRect(oldRect, offset.width, offset.height);
    1:       [mPendingDirtyRects replaceObjectAtIndex:i
    1:                                     withObject:[NSValue valueWithRect:newRect]];
    1:     }
    1:   }
    1:   [super scrollRect:aRect by:offset];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (BOOL)mouseDownCanMoveWindow
    1: {
    1:   return NO;
    1: }
    1: 
    1: 
    1: - (void)lockFocus
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // Set the current GrafPort to a "safe" port before calling [NSQuickDrawView lockFocus],
    1:   // so that the NSQuickDrawView stashes a pointer to this known-good port internally.
    1:   // It will set the port back to this port on destruction.
 6013:   ::SetPort(NULL);  // todo: only do if a Quickdraw plugin is present in the hierarchy!
    1:   [super lockFocus];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
19297: - (BOOL)isPaintingSuppressed
19297: {
19297:   NSWindow* win = [self window];
19295:   return ([win isKindOfClass:[ToolbarWindow class]] &&
19295:           [(ToolbarWindow*)win isPaintingSuppressed]);
19295: }
19295: 
19295: 
    1: // The display system has told us that a portion of our view is dirty. Tell
    1: // gecko to paint it
    1: - (void)drawRect:(NSRect)aRect
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   PRBool isVisible;
19295:   if (!mGeckoChild || NS_FAILED(mGeckoChild->IsVisible(isVisible)) ||
19297:       !isVisible || [self isPaintingSuppressed])
    1:     return;
    1: 
    1:   CGContextRef cgContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
    1: 
19835:   nsRect geckoBounds;
    1:   mGeckoChild->GetBounds(geckoBounds);
    1: 
    1:   NSRect bounds = [self bounds];
    1:   nsRefPtr<gfxQuartzSurface> targetSurface =
  314:     new gfxQuartzSurface(cgContext, gfxSize(bounds.size.width, bounds.size.height));
    1: 
    1: #ifdef DEBUG_UPDATE
    1:   fprintf (stderr, "---- Update[%p][%p] [%f %f %f %f] cgc: %p\n  gecko bounds: [%d %d %d %d]\n",
    1:            self, mGeckoChild,
    1:            aRect.origin.x, aRect.origin.y, aRect.size.width, aRect.size.height, cgContext,
    1:            geckoBounds.x, geckoBounds.y, geckoBounds.width, geckoBounds.height);
    1: 
    1:   CGAffineTransform xform = CGContextGetCTM(cgContext);
    1:   fprintf (stderr, "  xform in: [%f %f %f %f %f %f]\n", xform.a, xform.b, xform.c, xform.d, xform.tx, xform.ty);
    1: #endif
    1: 
    1:   nsRefPtr<gfxContext> targetContext = new gfxContext(targetSurface);
    1: 
    1:   nsCOMPtr<nsIRenderingContext> rc;
    1:   mGeckoChild->GetDeviceContext()->CreateRenderingContextInstance(*getter_AddRefs(rc));
    1:   rc->Init(mGeckoChild->GetDeviceContext(), targetContext);
    1: 
    1:   /* clip and build a region */
    1:   nsCOMPtr<nsIRegion> rgn(do_CreateInstance(kRegionCID));
    1:   if (rgn)
    1:     rgn->Init();
    1: 
    1:   const NSRect *rects;
    1:   int count, i;
    1:   [self getRectsBeingDrawn:&rects count:&count];
    1:   for (i = 0; i < count; ++i) {
    1:     const NSRect& r = rects[i];
    1: 
    1:     // add to the region
    1:     if (rgn)
    1:       rgn->Union((PRInt32)r.origin.x, (PRInt32)r.origin.y, (PRInt32)r.size.width, (PRInt32)r.size.height);
    1: 
    1:     // to the context for clipping
    1:     targetContext->Rectangle(gfxRect(r.origin.x, r.origin.y, r.size.width, r.size.height));
    1:   }
    1:   targetContext->Clip();
    1:   
    1:   // bounding box of the dirty area
19835:   nsRect fullRect;
    1:   NSRectToGeckoRect(aRect, fullRect);
    1: 
    1:   nsPaintEvent paintEvent(PR_TRUE, NS_PAINT, mGeckoChild);
    1:   paintEvent.renderingContext = rc;
    1:   paintEvent.rect = &fullRect;
    1:   paintEvent.region = rgn;
    1: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
    1:   mGeckoChild->DispatchWindowEvent(paintEvent);
10305:   if (!mGeckoChild)
10305:     return;
    1: 
    1:   paintEvent.renderingContext = nsnull;
    1:   paintEvent.region = nsnull;
    1: 
    1:   targetContext = nsnull;
    1:   targetSurface = nsnull;
    1: 
    1:   // note that the cairo surface *MUST* be destroyed at this point,
    1:   // or bad things will happen (since we can't keep the cgContext around
    1:   // beyond this drawRect message handler)
    1: 
    1: #ifdef DEBUG_UPDATE
    1:   fprintf (stderr, "  window coords: [%d %d %d %d]\n", fullRect.x, fullRect.y, fullRect.width, fullRect.height);
    1:   fprintf (stderr, "---- update done ----\n");
    1: 
    1: #if 0
    1:   CGContextSetRGBStrokeColor (cgContext,
    1:                             ((((unsigned long)self) & 0xff)) / 255.0,
    1:                             ((((unsigned long)self) & 0xff00) >> 8) / 255.0,
    1:                             ((((unsigned long)self) & 0xff0000) >> 16) / 255.0,
    1:                             0.5);
    1: #endif 
    1:   CGContextSetRGBStrokeColor (cgContext, 1, 0, 0, 0.8);
    1:   CGContextSetLineWidth (cgContext, 4.0);
    1:   CGContextStrokeRect (cgContext,
    1:                        CGRectMake(aRect.origin.x, aRect.origin.y, aRect.size.width, aRect.size.height));
    1: #endif
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
 3595: // Allows us to turn off setting up the clip region
    1: // before each drawRect. We already clip within gecko.
    1: - (BOOL)wantsDefaultClipping
    1: {
    1:   return NO;
    1: }
    1: 
    1: 
    1: #if USE_CLICK_HOLD_CONTEXTMENU
    1: //
    1: // -clickHoldCallback:
    1: //
    1: // called from a timer two seconds after a mouse down to see if we should display
    1: // a context menu (click-hold). |anEvent| is the original mouseDown event. If we're
    1: // still in that mouseDown by this time, put up the context menu, otherwise just
    1: // fuhgeddaboutit. |anEvent| has been retained by the OS until after this callback
    1: // fires so we're ok there.
    1: //
    1: // This code currently messes in a bunch of edge cases (bugs 234751, 232964, 232314)
    1: // so removing it until we get it straightened out.
    1: //
    1: - (void)clickHoldCallback:(id)theEvent;
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if( theEvent == [NSApp currentEvent] ) {
    1:     // we're still in the middle of the same mousedown event here, activate
    1:     // click-hold context menu by triggering the right mouseDown action.
    1:     NSEvent* clickHoldEvent = [NSEvent mouseEventWithType:NSRightMouseDown
    1:                                                   location:[theEvent locationInWindow]
19704:                                              modifierFlags:nsCocoaUtils::GetCocoaEventModifierFlags(theEvent)
    1:                                                  timestamp:[theEvent timestamp]
    1:                                               windowNumber:[theEvent windowNumber]
    1:                                                    context:[theEvent context]
    1:                                                eventNumber:[theEvent eventNumber]
    1:                                                 clickCount:[theEvent clickCount]
    1:                                                   pressure:[theEvent pressure]];
    1:     [self rightMouseDown:clickHoldEvent];
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: #endif
    1: 
    1: 
 9368: // We sometimes need to reroute events when there is a rollup widget and the
 9368: // event isn't targeted at it.
 8779: //
 8779: // Rerouting may be needed when the user tries to navigate a context menu while
 8779: // keeping the mouse-button down (left or right mouse button) -- the OS thinks this
 8779: // is a dragging operation, so it sends events (mouseMoved and mouseUp) to the
 3574: // window where the dragging operation started (the parent of the context
 7637: // menu window).  It also works around a bizarre Apple bug - if (while a context
 7637: // menu is open) you move the mouse over another app's window and then back over
 7637: // the context menu, mouseMoved events will be sent to the window underneath the
 7637: // context menu.
 7637: - (BOOL)ensureCorrectMouseEventTarget:(NSEvent*)anEvent
 3574: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 9368:   // If there is no rollup widget we assume the OS routed the event correctly.
 9368:   if (!gRollupWidget)
 7637:     return YES;
 7637: 
 9368:   // If this is the rollup widget and the event is not a mouse move then trust the OS routing.  
 9368:   // The reason for this trust is complicated.
 9368:   //
 9368:   // There are three types of mouse events that can legitimately need to be targeted at a window
 9368:   // that they are not over. Mouse moves, mouse drags, and mouse ups. Anything else our app wouldn't
 9368:   // handle (if the mouse was not over any window) or it would go to the appropriate window.
 9368:   //
 9368:   // We need to do manual event rerouting for mouse moves because we know that in some cases, like
 9368:   // when there is a submenu opened from a popup window, the OS will route mouse move events to the
 9368:   // submenu even if the mouse is over the parent. Mouse move events are never tied to a particular
 9368:   // window because of some originating action like the starting point of a drag for drag events or
 9368:   // a mouse down event for mouse up events, so it is always safe to do our own routing on them here.
 9368:   //
 9368:   // As for mouse drags and mouse ups, they have originating actions that tie them to windows they
 9368:   // may no longer be over. If there is a rollup window present when one of these events is getting
 9368:   // processed but we are not it, we are probably the window where the action originated, and that
 9368:   // action must have caused the rollup window to come into existence. In that case, we might need
 9368:   // to reroute the event if it is over the rollup window. That is why if we're not the rollup window
 9368:   // we don't return YES here.
 8779:   NSWindow* rollupWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
 9368:   if (mWindow == rollupWindow && [anEvent type] != NSMouseMoved)
 7637:     return YES;
 9368: 
 9368:   // Find the window that the event is over.
 9368:   NSWindow* targetWindow = nsCocoaUtils::FindWindowUnderPoint(nsCocoaUtils::ScreenLocationForEvent(anEvent));
 9368: 
 9368:   // If the event was not over any window, send it to the rollup window.
 9368:   if (!targetWindow)
 9368:     targetWindow = rollupWindow;
 9368: 
 9368:   // At this point we've resolved a target window, if we are it then just return
 9368:   // yes so we handle it. No need to redirect.
 9368:   if (targetWindow == mWindow)
 9368:     return YES;
 9368: 
 9368:   // Send the event to its new destination.
 9368:   NSPoint newWindowLocation = nsCocoaUtils::EventLocationForWindow(anEvent, targetWindow);
 9368:   NSEvent *newEvent = [NSEvent mouseEventWithType:[anEvent type]
 8779:                                          location:newWindowLocation
19704:                                     modifierFlags:nsCocoaUtils::GetCocoaEventModifierFlags(anEvent)
 3574:                                         timestamp:GetCurrentEventTime()
 9368:                                      windowNumber:[targetWindow windowNumber]
 3574:                                           context:nil
 3574:                                       eventNumber:0
 3574:                                        clickCount:1
 3574:                                          pressure:0.0];
 9368:   [targetWindow sendEvent:newEvent];
 9368: 
 9368:   // Return NO because we just sent the event somewhere else.
 7637:   return NO;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 3574: }
 3574: 
 3574: 
 3574: // If we've just created a non-native context menu, we need to mark it as
 3574: // such and let the OS (and other programs) know when it opens and closes
 3574: // (this is how the OS knows to close other programs' context menus when
 3574: // ours open).  We send the initial notification here, but others are sent
 3574: // in nsCocoaWindow::Show().
 3574: - (void)maybeInitContextMenuTracking
 3574: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 3574:   if (!gRollupWidget)
 3574:     return;
12536: 
12536:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
12536:   if (prefs) {
12536:     PRBool useNativeContextMenus;
12536:     nsresult rv = prefs->GetBoolPref("ui.use_native_popup_windows", &useNativeContextMenus);
12536:     if (NS_SUCCEEDED(rv) && useNativeContextMenus)
12536:       return;
12536:   }
12536: 
 7637:   NSWindow *popupWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
 7637:   if (!popupWindow || ![popupWindow isKindOfClass:[PopupWindow class]])
 3574:     return;
 7637: 
 3574:   [[NSDistributedNotificationCenter defaultCenter]
 3574:     postNotificationName:@"com.apple.HIToolbox.beginMenuTrackingNotification"
 3574:                   object:@"org.mozilla.gecko.PopupWindow"];
 7637:   [(PopupWindow*)popupWindow setIsContextMenu:YES];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 3574: }
 3574: 
 3574: 
 8345: - (BOOL)maybeRollup:(NSEvent*)theEvent
 8345: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 8345:   PRBool retVal = PR_FALSE;
 8345:   if (gRollupWidget && gRollupListener) {
 8345:     NSWindow* currentPopup = static_cast<NSWindow*>(gRollupWidget->GetNativeData(NS_NATIVE_WINDOW));
 8779:     if (!nsCocoaUtils::IsEventOverWindow(theEvent, currentPopup)) {
 8345:       PRBool rollup = PR_TRUE;
 8345:       if ([theEvent type] == NSScrollWheel) {
 8345:         gRollupListener->ShouldRollupOnMouseWheelEvent(&rollup);
 8345:         // We don't want the event passed on for scrollwheel events if we're
 8345:         // not supposed to close the popup.  Otherwise the background window
 8345:         // will scroll when a custom context menu or the autoscroll popup is
 8345:         // open (and the mouse isn't over the popup) -- which doesn't seem right.
 8345:         // This change resolves bmo bug 344367.
 8345:         retVal = PR_TRUE;
 8345:       }
 8345:       // if we're dealing with menus, we probably have submenus and
 8345:       // we don't want to rollup if the click is in a parent menu of
 8345:       // the current submenu
 8345:       nsCOMPtr<nsIMenuRollup> menuRollup;
 8345:       menuRollup = (do_QueryInterface(gRollupListener));
 8345:       if (menuRollup) {
10352:         nsAutoTArray<nsIWidget*, 5> widgetChain;
10352:         menuRollup->GetSubmenuWidgetChain(&widgetChain);
10352:         for (PRUint32 i = 0; i < widgetChain.Length(); i++) {
10352:           nsIWidget* widget = widgetChain[i];
 8345:           NSWindow* currWindow = (NSWindow*)widget->GetNativeData(NS_NATIVE_WINDOW);
 8779:           if (nsCocoaUtils::IsEventOverWindow(theEvent, currWindow)) {
 8345:             rollup = PR_FALSE;
 8345:             break;
 8345:           }
 8345:         } // foreach parent menu widget
 8345:       } // if rollup listener knows about menus
 8345: 
 8345:       // if we've determined that we should still rollup, do it.
 8345:       if (rollup) {
 8591:         gRollupListener->Rollup(nsnull);
 8345:         retVal = PR_TRUE;
 8345:       }
 8345:     }
 8345:   }
 8345: 
 8345:   return retVal;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 8345: }
 8345: 
 8345: 
    1: - (void)mouseDown:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
13976:   // If we've already seen this event due to direct dispatch from menuForEvent:
13976:   // just bail; if not, remember it.
13976:   if (mLastMouseDownEvent == theEvent) {
13976:     [mLastMouseDownEvent release];
13976:     mLastMouseDownEvent = nil;
13976:     return;
13976:   }
13976:   else {
13976:     [mLastMouseDownEvent release];
13976:     mLastMouseDownEvent = [theEvent retain];
13976:   }
13976: 
 7637:   if (![self ensureCorrectMouseEventTarget:theEvent])
 7637:     return;
 7637: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 8345:   if ([self maybeRollup:theEvent])
    1:     return;
    1: 
19704:   unsigned int modifierFlags = nsCocoaUtils::GetCocoaEventModifierFlags(theEvent);
    1: 
    1:   // if the command and alt keys are held down, initiate hand scrolling
    1:   if ([ChildView areHandScrollModifiers:modifierFlags]) {
    1:     [self startHandScroll:theEvent];
    1:     // needed to change the focus, among other things, since we don't
    1:     // get to do that below.
    1:     [super mouseDown:theEvent];
    1:     return; // do not pass this mousedown event to gecko
    1:   }
    1: 
    1: #if USE_CLICK_HOLD_CONTEXTMENU
    1:   // fire off timer to check for click-hold after two seconds. retains |theEvent|
    1:   [self performSelector:@selector(clickHoldCallback:) withObject:theEvent afterDelay:2.0];
    1: #endif
    1: 
  656:   // in order to send gecko events we'll need a gecko widget
  656:   if (!mGeckoChild)
  656:     return;
  656: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:   geckoEvent.clickCount = [theEvent clickCount];
    1:   if (modifierFlags & NSControlKeyMask)
    1:     geckoEvent.button = nsMouseEvent::eRightButton;
    1:   else
    1:     geckoEvent.button = nsMouseEvent::eLeftButton;
    1: 
 2315:   // create native EventRecord for use by plugins
    1:   EventRecord macEvent;
    1:   macEvent.what = mouseDown;
    1:   macEvent.message = 0;
    1:   macEvent.when = ::TickCount();
    1:   ::GetGlobalMouse(&macEvent.where);
12558:   macEvent.modifiers = ::GetCurrentEventKeyModifiers();
    1:   geckoEvent.nativeMsg = &macEvent;
    1: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
    1: 
    1:   // XXX maybe call markedTextSelectionChanged:client: here?
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)mouseUp:(NSEvent *)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (mInHandScroll) {
    1:     [self updateHandScroll:theEvent];
    1:     [self stopHandScroll:theEvent];
    1:     return;
    1:   }
 2315: 
 7637:   if (![self ensureCorrectMouseEventTarget:theEvent])
 3574:     return;
 3574: 
 2315:   if (!mGeckoChild)
 2315:     return;
 2315: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
19704:   if (nsCocoaUtils::GetCocoaEventModifierFlags(theEvent) & NSControlKeyMask)
19247:     geckoEvent.button = nsMouseEvent::eRightButton;
19247:   else
19247:     geckoEvent.button = nsMouseEvent::eLeftButton;
 2315: 
 2315:   // create native EventRecord for use by plugins
    1:   EventRecord macEvent;
    1:   macEvent.what = mouseUp;
    1:   macEvent.message = 0;
    1:   macEvent.when = ::TickCount();
    1:   ::GetGlobalMouse(&macEvent.where);
12558:   macEvent.modifiers = ::GetCurrentEventKeyModifiers();
    1:   geckoEvent.nativeMsg = &macEvent;
    1: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
 5762: // sends a mouse enter or exit event into gecko
 5762: static nsEventStatus SendGeckoMouseEnterOrExitEvent(PRBool isTrusted,
  455:                                                     PRUint32 msg,
  455:                                                     nsIWidget *widget,
  455:                                                     nsMouseEvent::reasonType aReason,
12976:                                                     NSPoint* localEventLocation,
12976:                                                     nsMouseEvent::exitType type)
  455: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
  455:   if (!widget || !localEventLocation)
  455:     return nsEventStatus_eIgnore;
  455: 
  455:   nsMouseEvent event(isTrusted, msg, widget, aReason);
  455:   event.refPoint.x = nscoord((PRInt32)localEventLocation->x);
  455:   event.refPoint.y = nscoord((PRInt32)localEventLocation->y);
 2315: 
 5762:   EventRecord macEvent;
 5762:   macEvent.what = adjustCursorEvent;
 5762:   macEvent.message = 0;
 5762:   macEvent.when = ::TickCount();
 5762:   ::GetGlobalMouse(&macEvent.where);
12558:   macEvent.modifiers = ::GetCurrentEventKeyModifiers();
 5762:   event.nativeMsg = &macEvent;
 5762: 
12976:   event.exit = type;
12976: 
 2315:   nsEventStatus status;
  455:   widget->DispatchEvent(&event, status);
14142: 
14142:   // After the cursor exits a view set it to a visible regular arrow cursor.
14142:   // This lets us recover from plugins that mess with it.
14142:   if (msg == NS_MOUSE_EXIT) {
14142:     [NSCursor unhide];
14142:     [[NSCursor arrowCursor] set];
14142:   }
14142: 
  455:   return status;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsEventStatus_eIgnore);
  455: }
  455: 
  455: 
    1: - (void)mouseMoved:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
10309:   // Work around an Apple bug that causes the OS to continue sending
10309:   // mouseMoved events to a window for a while after it's been miniaturized.
10309:   // This may be related to a similar problem with popup windows (bmo bug
10309:   // 378645, popup windows continue to receive mouseMoved events after having
10309:   // been "ordered out"), which is worked around in nsCocoaWindow::Show()
10309:   // (search on 378645 in nsCocoaWindow.mm).  This problem is bmo bug 410219,
10309:   // and exists in both OS X 10.4 and 10.5.
10309:   if ([[self window] isMiniaturized])
10309:     return;
10309: 
 8779:   NSPoint windowEventLocation = nsCocoaUtils::EventLocationForWindow(theEvent, mWindow);
  455:   NSPoint viewEventLocation = [self convertPoint:windowEventLocation fromView:nil];
  455: 
 3574:   // Installing a mouseMoved handler on the EventMonitor target (in
 3574:   // nsToolkit::RegisterForAllProcessMouseEvents()) means that some of the
 3574:   // events received here come from other processes.  For this reason we need
 3574:   // to avoid processing them unless they're over a context menu -- otherwise
 3574:   // tooltips and other mouse-hover effects will "work" even when our app
 3574:   // doesn't have the focus.
 8345:   BOOL mouseEventIsOverRollupWidget = NO;
 8345:   if (gRollupWidget) {
 8345:     NSWindow *popupWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
 8779:     mouseEventIsOverRollupWidget = nsCocoaUtils::IsEventOverWindow(theEvent, popupWindow);
 8779:   }
 8779: 
 8345:   if (![NSApp isActive] && !mouseEventIsOverRollupWidget) {
 3574:     if (sLastViewEntered) {
 3574:       nsIWidget* lastViewEnteredWidget = [(NSView<mozView>*)sLastViewEntered widget];
10943:       NSPoint exitEventLocation = [sLastViewEntered convertPoint:windowEventLocation fromView:nil];
12976:       SendGeckoMouseEnterOrExitEvent(PR_TRUE, NS_MOUSE_EXIT, lastViewEnteredWidget, nsMouseEvent::eReal,
13927:                                      &exitEventLocation, nsMouseEvent::eTopLevel);
 3574:       sLastViewEntered = nil;
 3574:     }
 3574:     return;
 3574:   }
 3574: 
 7637:   if (![self ensureCorrectMouseEventTarget:theEvent])
 3574:     return;
 3574: 
  455:   NSView* view = [[mWindow contentView] hitTest:windowEventLocation];
  455:   if (view) {
  455:     // we shouldn't handle this if the hit view is not us
    1:     if (view != (NSView*)self) {
    1:       [view mouseMoved:theEvent];
    1:       return;
    1:     }
  455:   }
  455:   else {
  455:     // If the hit test returned nil then the mouse isn't over the window. If thse mouse
  455:     // exited the window then send mouse exit to the last view in the window it was over.
  455:     if (sLastViewEntered) {
10943:       NSPoint exitEventLocation = [sLastViewEntered convertPoint:windowEventLocation fromView:nil];
10943:       // NSLog(@"sending NS_MOUSE_EXIT event with point %f,%f\n", exitEventLocation.x, exitEventLocation.y);
  455:       nsIWidget* lastViewEnteredWidget = [(NSView<mozView>*)sLastViewEntered widget];
12976:       SendGeckoMouseEnterOrExitEvent(PR_TRUE, NS_MOUSE_EXIT, lastViewEnteredWidget, nsMouseEvent::eReal,
12976:                                      &exitEventLocation, nsMouseEvent::eTopLevel);
  455:       sLastViewEntered = nil;
  455:     }
  455:     return;
  455:   }
  455: 
  455:   // At this point we are supposed to handle this event. If we were not the last view entered, then
  455:   // we should send an exit event to the last view entered and an enter event to ourselves.  
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
  455:   if (sLastViewEntered != self) {
 2462:     if (sLastViewEntered) {
10943:       NSPoint exitEventLocation = [sLastViewEntered convertPoint:windowEventLocation fromView:nil];
10943:       // NSLog(@"sending NS_MOUSE_EXIT event with point %f,%f\n", exitEventLocation.x, exitEventLocation.y);
  455:       nsIWidget* lastViewEnteredWidget = [(NSView<mozView>*)sLastViewEntered widget];
12976:       SendGeckoMouseEnterOrExitEvent(PR_TRUE, NS_MOUSE_EXIT, lastViewEnteredWidget, nsMouseEvent::eReal,
12976:                                      &exitEventLocation, nsMouseEvent::eChild);
 8404: 
 8404:       // The mouse exit event we just sent may have destroyed this widget, bail if that happened.
 8404:       if (!mGeckoChild)
 8404:         return;
  455:     }
  455: 
  455:     // NSLog(@"sending NS_MOUSE_ENTER event with point %f,%f\n", viewEventLocation.x, viewEventLocation.y);
12976:     SendGeckoMouseEnterOrExitEvent(PR_TRUE, NS_MOUSE_ENTER, mGeckoChild, nsMouseEvent::eReal,
12976:                                    &viewEventLocation, nsMouseEvent::eChild);
  455: 
 8404:     // The mouse enter event we just sent may have destroyed this widget, bail if that happened.
 8404:     if (!mGeckoChild)
 8404:       return;
 8404: 
  455:     // mark this view as the last view entered
  455:     sLastViewEntered = (NSView*)self;
  455: 
  455:     // checks to see if we should change to the hand cursor
  455:     [self setHandScrollCursor:theEvent];
  455:   }
    1: 
    1:   // check if we are in a hand scroll or if the user
    1:   // has command and alt held down; if so,  we do not want
    1:   // gecko messing with the cursor.
19704:   if ([ChildView areHandScrollModifiers:nsCocoaUtils::GetCocoaEventModifierFlags(theEvent)])
    1:     return;
    1: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
 2315:   // create native EventRecord for use by plugins
    1:   EventRecord macEvent;
 5762:   macEvent.what = adjustCursorEvent;
    1:   macEvent.message = 0;
    1:   macEvent.when = ::TickCount();
    1:   ::GetGlobalMouse(&macEvent.where);
12558:   macEvent.modifiers = ::GetCurrentEventKeyModifiers();
    1:   geckoEvent.nativeMsg = &macEvent;
    1: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)mouseDragged:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7637:   if (![self ensureCorrectMouseEventTarget:theEvent])
 3574:     return;
 3574: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   // if the handscroll flag is set, steal this event
    1:   if (mInHandScroll) {
    1:     [self updateHandScroll:theEvent];
    1:     return;
    1:   }
    1: 
 6245:   gLastDragView = self;
 6245:   gLastDragEvent = theEvent;
    1: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
 2315:   // create native EventRecord for use by plugins
    1:   EventRecord macEvent;
    1:   macEvent.what = nullEvent;
    1:   macEvent.message = 0;
    1:   macEvent.when = ::TickCount();
    1:   ::GetGlobalMouse(&macEvent.where);
12558:   macEvent.modifiers = btnState | ::GetCurrentEventKeyModifiers();
    1:   geckoEvent.nativeMsg = &macEvent;
    1: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
    1: 
10305:   // Note, sending the above event might have destroyed our widget since we didn't retain.
10305:   // Fine so long as we don't access any local variables from here on.
10305: 
 6245:   gLastDragView = nil;
 6245:   gLastDragEvent = nil;
    1:   // XXX maybe call markedTextSelectionChanged:client: here?
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)rightMouseDown:(NSEvent *)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7637:   if (![self ensureCorrectMouseEventTarget:theEvent])
 7637:     return;
 7637: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 8345:   [self maybeRollup:theEvent];
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   // The right mouse went down, fire off a right mouse down event to gecko
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:   geckoEvent.button = nsMouseEvent::eRightButton;
 2315:   geckoEvent.clickCount = [theEvent clickCount];
 2315: 
 2315:   // create native EventRecord for use by plugins
    1:   EventRecord macEvent;
    1:   macEvent.what = mouseDown;
    1:   macEvent.message = 0;
    1:   macEvent.when = ::TickCount();
    1:   ::GetGlobalMouse(&macEvent.where);
    1:   macEvent.modifiers = controlKey;  // fake a context menu click
    1:   geckoEvent.nativeMsg = &macEvent;
    1: 
18401:   PRBool handled = mGeckoChild->DispatchWindowEvent(geckoEvent);
10305:   if (!mGeckoChild)
10305:     return;
10305: 
    1:   if (!handled)
    1:     [super rightMouseDown:theEvent]; // let the superview do context menu stuff
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)rightMouseUp:(NSEvent *)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7637:   if (![self ensureCorrectMouseEventTarget:theEvent])
 3574:     return;
 3574: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:   geckoEvent.button = nsMouseEvent::eRightButton;
 2315:   geckoEvent.clickCount = [theEvent clickCount];
 2315: 
 2315:   // create native EventRecord for use by plugins
    1:   EventRecord macEvent;
    1:   macEvent.what = mouseUp;
    1:   macEvent.message = 0;
    1:   macEvent.when = ::TickCount();
    1:   ::GetGlobalMouse(&macEvent.where);
    1:   macEvent.modifiers = controlKey;  // fake a context menu click
    1:   geckoEvent.nativeMsg = &macEvent;
    1: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
 3574: - (void)rightMouseDragged:(NSEvent*)theEvent
 3574: {
 7637:   if (![self ensureCorrectMouseEventTarget:theEvent])
 3574:     return;
 3574: 
 3574:   if (!mGeckoChild)
 3574:     return;
 3574: 
 3574:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
 3574:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 3574:   geckoEvent.button = nsMouseEvent::eRightButton;
 3574: 
 3574:   // send event into Gecko by going directly to the
 3574:   // the widget.
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 3574: }
 3574: 
 3574: 
    1: - (void)otherMouseDown:(NSEvent *)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7637:   if (![self ensureCorrectMouseEventTarget:theEvent])
 7637:     return;
 7637: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 8345:   if ([self maybeRollup:theEvent])
 7637:     return;
 3574: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 2315:   geckoEvent.button = nsMouseEvent::eMiddleButton;
    1:   geckoEvent.clickCount = [theEvent clickCount];
 2315: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: - (void)otherMouseUp:(NSEvent *)theEvent
    1: {
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:   geckoEvent.button = nsMouseEvent::eMiddleButton;
    1: 
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
    1: }
    1: 
    1: 
 3574: - (void)otherMouseDragged:(NSEvent*)theEvent
 3574: {
 3574:   if (!mGeckoChild)
 3574:     return;
 3574: 
 3574:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
 3574:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
 3574:   geckoEvent.button = nsMouseEvent::eMiddleButton;
 3574: 
 3574:   // send event into Gecko by going directly to the
 3574:   // the widget.
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
 3574: }
 3574: 
 3574: 
    1: // Handle an NSScrollWheel event for a single axis only.
    1: -(void)scrollWheel:(NSEvent*)theEvent forAxis:(enum nsMouseScrollEvent::nsMouseScrollFlags)inAxis
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
19319:   float scrollDelta = 0;
19319:   float scrollDeltaPixels = 0;
19319:   PRBool checkPixels = PR_TRUE;
19319: 
19319:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
19319:   if (prefs)
19319:     prefs->GetBoolPref("mousewheel.enable_pixel_scrolling", &checkPixels);
19319: 
19319:   EventRef theCarbonEvent = [theEvent _eventRef];
19319:   UInt32 carbonEventKind = theCarbonEvent ? ::GetEventKind(theCarbonEvent) : 0;
19319:   // Calling deviceDeltaX or deviceDeltaY on theEvent will trigger a Cocoa
19319:   // assertion and an Objective-C NSInternalInconsistencyException if the
19319:   // underlying "Carbon" event doesn't contain pixel scrolling information.
19319:   // For these events, carbonEventKind is kEventMouseWheelMoved instead of
19319:   // kEventMouseScroll.
19319:   if (carbonEventKind != mozkEventMouseScroll)
19319:     checkPixels = PR_FALSE;
19319:   // Some scrolling devices supports pixel scrolling, e.g. a Macbook
19319:   // touchpad or a Mighty Mouse. On those devices, [event deviceDeltaX/Y]
19319:   // contains the amount of pixels to scroll. 
19319:   if (inAxis & nsMouseScrollEvent::kIsVertical) {
    1:     scrollDelta       = -[theEvent deltaY];
19319:     if (checkPixels && (scrollDelta == 0 || scrollDelta != floor(scrollDelta))) {
19319:       scrollDeltaPixels = -[theEvent deviceDeltaY];
19319:     }
19319:   } else if (inAxis & nsMouseScrollEvent::kIsHorizontal) {
    1:     scrollDelta       = -[theEvent deltaX];
19319:     if (checkPixels && (scrollDelta == 0 || scrollDelta != floor(scrollDelta))) {
19319:       scrollDeltaPixels = -[theEvent deviceDeltaX];
19319:     }
19319:   } else {
10305:     return; // caller screwed up
19319:   }
19319: 
19319:   BOOL hasPixels = (scrollDeltaPixels != 0);
19319: 
19319:   if (!hasPixels && scrollDelta == 0)
19319:     // No sense in firing off a Gecko event.
    1:      return;
    1: 
19319:   if (scrollDelta != 0) {
19319:     // Send the line scroll event.
    1:     nsMouseScrollEvent geckoEvent(PR_TRUE, NS_MOUSE_SCROLL, nsnull);
 2315:     [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:     geckoEvent.scrollFlags |= inAxis;
    1: 
19319:     if (hasPixels)
19319:       geckoEvent.scrollFlags |= nsMouseScrollEvent::kHasPixels;
19319: 
    1:     // Gecko only understands how to scroll by an integer value. Using floor
    1:     // and ceil is better than truncating the fraction, especially when
    1:     // |delta| < 1.
    1:     if (scrollDelta < 0)
    1:       geckoEvent.delta = (PRInt32)floorf(scrollDelta);
    1:     else
    1:       geckoEvent.delta = (PRInt32)ceilf(scrollDelta);
    1: 
14024:     nsAutoRetainCocoaObject kungFuDeathGrip(self);
    1:     mGeckoChild->DispatchWindowEvent(geckoEvent);
10305:     if (!mGeckoChild)
10305:       return;
    1: 
    1:     // dispatch scroll wheel carbon event for plugins
    1:     {
    1:       EventRef theEvent;
    1:       OSStatus err = ::MacCreateEvent(NULL,
    1:                                       kEventClassMouse,
    1:                                       kEventMouseWheelMoved,
    1:                                       TicksToEventTime(TickCount()),
    1:                                       kEventAttributeUserEvent,
    1:                                       &theEvent);
    1:       if (err == noErr) {
    1:         EventMouseWheelAxis axis;
    1:         if (inAxis & nsMouseScrollEvent::kIsVertical)
    1:           axis = kEventMouseWheelAxisY;
    1:         else if (inAxis & nsMouseScrollEvent::kIsHorizontal)
    1:           axis = kEventMouseWheelAxisX;
    1:         
    1:         SetEventParameter(theEvent,
    1:                           kEventParamMouseWheelAxis,
    1:                           typeMouseWheelAxis,
    1:                           sizeof(EventMouseWheelAxis),
    1:                           &axis);
    1:         
    1:         SInt32 delta = (SInt32)-geckoEvent.delta;
    1:         SetEventParameter(theEvent,
    1:                           kEventParamMouseWheelDelta,
    1:                           typeLongInteger,
    1:                           sizeof(SInt32),
    1:                           &delta);
    1:         
    1:         Point mouseLoc;
    1:         ::GetGlobalMouse(&mouseLoc);
    1:         SetEventParameter(theEvent,
    1:                           kEventParamMouseLocation,
    1:                           typeQDPoint,
    1:                           sizeof(Point),
    1:                           &mouseLoc);
    1:         
 1016:         ::SendEventToEventTarget(theEvent, GetWindowEventTarget((WindowRef)[[self window] windowRef]));
    1:         ReleaseEvent(theEvent);
    1:       }
    1:     }
19319:   }
19319: 
19319:   if (hasPixels) {
19319:     // Send the pixel scroll event.
19319:     nsMouseScrollEvent geckoEvent(PR_TRUE, NS_MOUSE_PIXEL_SCROLL, nsnull);
19319:     [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
19319:     geckoEvent.scrollFlags |= inAxis;
19319:     geckoEvent.delta = NSToIntRound(scrollDeltaPixels);
19319:     nsAutoRetainCocoaObject kungFuDeathGrip(self);
19319:     mGeckoChild->DispatchWindowEvent(geckoEvent);
19319:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: -(void)scrollWheel:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 8345:   if ([self maybeRollup:theEvent])
 4358:     return;
    1: 
10305:   if (!mGeckoChild)
10305:     return;
10305: 
    1:   // It's possible for a single NSScrollWheel event to carry both useful
    1:   // deltaX and deltaY, for example, when the "wheel" is a trackpad.
    1:   // NSMouseScrollEvent can only carry one axis at a time, so the system
    1:   // event will be split into two Gecko events if necessary.
    1:   [self scrollWheel:theEvent forAxis:nsMouseScrollEvent::kIsVertical];
10305:   if (!mGeckoChild)
10305:     return;
    1:   [self scrollWheel:theEvent forAxis:nsMouseScrollEvent::kIsHorizontal];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: -(NSMenu*)menuForEvent:(NSEvent*)theEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 2462:   if (!mGeckoChild || [self isPluginView])
    1:     return nil;
    1: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 8345:   [self maybeRollup:theEvent];
10305:   if (!mGeckoChild)
10305:     return nil;
 4842: 
13976:   // Cocoa doesn't always dispatch a mouseDown: for a control-click event,
13976:   // depends on what we return from menuForEvent:. Gecko always expects one
13976:   // and expects the mouse down event before the context menu event, so
13976:   // get that event sent first if this is a left mouse click.
13976:   if ([theEvent type] == NSLeftMouseDown) {
13976:     [self mouseDown:theEvent];
13976:     if (!mGeckoChild)
13609:       return nil;
13976:   }
    1: 
    1:   nsMouseEvent geckoEvent(PR_TRUE, NS_CONTEXTMENU, nsnull, nsMouseEvent::eReal);
 2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
    1:   geckoEvent.button = nsMouseEvent::eRightButton;
18401:   mGeckoChild->DispatchWindowEvent(geckoEvent);
10305:   if (!mGeckoChild)
10305:     return nil;
 3574: 
12394:   [self maybeInitContextMenuTracking];
12394: 
    1:   // Go up our view chain to fetch the correct menu to return.
    1:   return [self contextMenu];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: 
    1: - (NSMenu*)contextMenu
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   NSView* superView = [self superview];
    1:   if ([superView respondsToSelector:@selector(contextMenu)])
    1:     return [(NSView<mozView>*)superView contextMenu];
    1: 
    1:   return nil;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: 
    1: - (TopLevelWindowData*)ensureWindowData
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   WindowDataMap* windowMap = [WindowDataMap sharedWindowDataMap];
    1: 
    1:   TopLevelWindowData* windowData = [windowMap dataForWindow:mWindow];
    1:   if (mWindow && !windowData)
    1:   {
    1:     windowData = [[TopLevelWindowData alloc] initWithWindow:mWindow];
    1:     [windowMap setData:windowData forWindow:mWindow]; // takes ownership
    1:     [windowData release];
    1:   }
    1:   return windowData;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: 
    1: static PRBool ConvertUnicodeToCharCode(PRUnichar inUniChar, unsigned char* outChar)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
    1:   UnicodeToTextInfo converterInfo;
    1:   TextEncoding      systemEncoding;
    1:   Str255            convertedString;
    1:   OSStatus          err;
    1:   
    1:   *outChar = 0;
    1:   
    1:   err = ::UpgradeScriptInfoToTextEncoding(smSystemScript, kTextLanguageDontCare, kTextRegionDontCare, NULL, &systemEncoding);
    1:   if (err != noErr)
    1:     return PR_FALSE;
    1:   
    1:   err = ::CreateUnicodeToTextInfoByEncoding(systemEncoding, &converterInfo);
    1:   if (err != noErr)
    1:     return PR_FALSE;
    1:   
    1:   err = ::ConvertFromUnicodeToPString(converterInfo, sizeof(PRUnichar), &inUniChar, convertedString);
    1:   if (err != noErr)
    1:     return PR_FALSE;
    1: 
    1:   *outChar = convertedString[1];
    1:   ::DisposeUnicodeToTextInfo(&converterInfo);
    1:   return PR_TRUE;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(PR_FALSE);
    1: }
    1: 
    1: 
    1: static void ConvertCocoaKeyEventToMacEvent(NSEvent* cocoaEvent, EventRecord& macEvent, PRUint32 keyType = 0)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:     UInt32 charCode = 0;
    1:     if ([cocoaEvent type] == NSFlagsChanged) {
    1:       macEvent.what = keyType == NS_KEY_DOWN ? keyDown : keyUp;
    1:     } else {
13547:       if ([[cocoaEvent characters] length] > 0)
    1:         charCode = [[cocoaEvent characters] characterAtIndex:0];
    1:       if ([cocoaEvent type] == NSKeyDown)
    1:         macEvent.what = [cocoaEvent isARepeat] ? autoKey : keyDown;
    1:       else
    1:         macEvent.what = keyUp;
    1:     }
    1: 
    1:     if (charCode >= 0x0080) {
    1:         switch (charCode) {
    1:         case NSUpArrowFunctionKey:
    1:             charCode = kUpArrowCharCode;
    1:             break;
    1:         case NSDownArrowFunctionKey:
    1:             charCode = kDownArrowCharCode;
    1:             break;
    1:         case NSLeftArrowFunctionKey:
    1:             charCode = kLeftArrowCharCode;
    1:             break;
    1:         case NSRightArrowFunctionKey:
    1:             charCode = kRightArrowCharCode;
    1:             break;
    1:         default:
    1:             unsigned char convertedCharCode;
    1:             if (ConvertUnicodeToCharCode(charCode, &convertedCharCode))
    1:               charCode = convertedCharCode;
    1:             //NSLog(@"charcode is %d, converted to %c, char is %@", charCode, convertedCharCode, [cocoaEvent characters]);
    1:             break;
    1:         }
    1:     }
19704:     macEvent.message = (charCode & 0x00FF) | (nsCocoaUtils::GetCocoaEventKeyCode(cocoaEvent) << 8);
    1:     macEvent.when = ::TickCount();
    1:     ::GetGlobalMouse(&macEvent.where);
12558:     macEvent.modifiers = ::GetCurrentEventKeyModifiers();
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: // Key code constants
    1: enum
    1: {
    1:   kEscapeKeyCode      = 0x35,
 7636:   kRCommandKeyCode    = 0x36, // right command key
    1:   kCommandKeyCode     = 0x37,
    1:   kShiftKeyCode       = 0x38,
    1:   kCapsLockKeyCode    = 0x39,
 7636:   kOptionkeyCode      = 0x3A,
    1:   kControlKeyCode     = 0x3B,
 7636:   kRShiftKeyCode      = 0x3C, // right shift key
 7636:   kROptionKeyCode     = 0x3D, // right option key
 7636:   kRControlKeyCode    = 0x3E, // right control key
    1:   kClearKeyCode       = 0x47,
    1: 
    1:   // function keys
    1:   kF1KeyCode          = 0x7A,
    1:   kF2KeyCode          = 0x78,
    1:   kF3KeyCode          = 0x63,
    1:   kF4KeyCode          = 0x76,
    1:   kF5KeyCode          = 0x60,
    1:   kF6KeyCode          = 0x61,
    1:   kF7KeyCode          = 0x62,
    1:   kF8KeyCode          = 0x64,
    1:   kF9KeyCode          = 0x65,
    1:   kF10KeyCode         = 0x6D,
    1:   kF11KeyCode         = 0x67,
    1:   kF12KeyCode         = 0x6F,
    1:   kF13KeyCode         = 0x69,
    1:   kF14KeyCode         = 0x6B,
    1:   kF15KeyCode         = 0x71,
    1:   
    1:   kPrintScreenKeyCode = kF13KeyCode,
    1:   kScrollLockKeyCode  = kF14KeyCode,
    1:   kPauseKeyCode       = kF15KeyCode,
    1:   
    1:   // keypad
    1:   kKeypad0KeyCode     = 0x52,
    1:   kKeypad1KeyCode     = 0x53,
    1:   kKeypad2KeyCode     = 0x54,
    1:   kKeypad3KeyCode     = 0x55,
    1:   kKeypad4KeyCode     = 0x56,
    1:   kKeypad5KeyCode     = 0x57,
    1:   kKeypad6KeyCode     = 0x58,
    1:   kKeypad7KeyCode     = 0x59,
    1:   kKeypad8KeyCode     = 0x5B,
    1:   kKeypad9KeyCode     = 0x5C,
    1: 
 2959: // The following key codes are not defined until Mac OS X 10.5
 2959: #if MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_4
 2959:   kVK_ANSI_1          = 0x12,
 2959:   kVK_ANSI_2          = 0x13,
 2959:   kVK_ANSI_3          = 0x14,
 2959:   kVK_ANSI_4          = 0x15,
 2959:   kVK_ANSI_5          = 0x17,
 2959:   kVK_ANSI_6          = 0x16,
 2959:   kVK_ANSI_7          = 0x1A,
 2959:   kVK_ANSI_8          = 0x1C,
 2959:   kVK_ANSI_9          = 0x19,
 2959:   kVK_ANSI_0          = 0x1D,
 2959: #endif
 2959: 
    1:   kKeypadMultiplyKeyCode  = 0x43,
    1:   kKeypadAddKeyCode       = 0x45,
    1:   kKeypadSubtractKeyCode  = 0x4E,
    1:   kKeypadDecimalKeyCode   = 0x41,
    1:   kKeypadDivideKeyCode    = 0x4B,
    1:   kKeypadEqualsKeyCode    = 0x51, // no correpsonding gecko key code
    1:   kEnterKeyCode           = 0x4C,
    1:   kReturnKeyCode          = 0x24,
    1:   kPowerbookEnterKeyCode  = 0x34, // Enter on Powerbook's keyboard is different
    1:   
    1:   kInsertKeyCode          = 0x72, // also help key
    1:   kDeleteKeyCode          = 0x75, // also forward delete key
    1:   kTabKeyCode             = 0x30,
10884:   kTildeKeyCode           = 0x32,
    1:   kBackspaceKeyCode       = 0x33,
    1:   kHomeKeyCode            = 0x73, 
    1:   kEndKeyCode             = 0x77,
    1:   kPageUpKeyCode          = 0x74,
    1:   kPageDownKeyCode        = 0x79,
    1:   kLeftArrowKeyCode       = 0x7B,
    1:   kRightArrowKeyCode      = 0x7C,
    1:   kUpArrowKeyCode         = 0x7E,
    1:   kDownArrowKeyCode       = 0x7D
    1: };
    1: 
    1: 
 7164: static PRBool IsPrintableChar(PRUnichar aChar)
 7164: {
 7164:   return (aChar >= 0x20 && aChar <= 0x7E) || aChar >= 0xA0;
 7164: }
 7164: 
 6825: static PRUint32 GetGeckoKeyCodeFromChar(PRUnichar aChar)
 6825: {
 6946:   // We don't support the key code for non-ASCII characters
 7164:   if (aChar > 0x7E)
 6946:     return 0;
 6946: 
 7164:   if (aChar >= 'a' && aChar <= 'z') // lowercase
 7164:     return PRUint32(toupper(aChar));
 7164:   else if (aChar >= 'A' && aChar <= 'Z') // uppercase
 7164:     return PRUint32(aChar);
 7164:   else if (aChar >= '0' && aChar <= '9')
 7164:     return PRUint32(aChar - '0' + NS_VK_0);
 7164: 
 6825:   switch (aChar)
 6825:   {
 6825:     case kReturnCharCode:
 6825:     case kEnterCharCode:
 6825:     case '\n':
 6825:       return NS_VK_RETURN;
 6825:     case '{':
 6825:     case '[':
 6825:       return NS_VK_OPEN_BRACKET;
 6825:     case '}':
 6825:     case ']':
 6825:       return NS_VK_CLOSE_BRACKET;
 6825:     case '\'':
 6825:     case '"':
 6825:       return NS_VK_QUOTE;
 6825: 
 6825:     case '\\':                  return NS_VK_BACK_SLASH;
 6825:     case ' ':                   return NS_VK_SPACE;
 6825:     case ';':                   return NS_VK_SEMICOLON;
 6825:     case '=':                   return NS_VK_EQUALS;
 6825:     case ',':                   return NS_VK_COMMA;
 6825:     case '.':                   return NS_VK_PERIOD;
 6825:     case '/':                   return NS_VK_SLASH;
 6825:     case '`':                   return NS_VK_BACK_QUOTE;
 6825:     case '\t':                  return NS_VK_TAB;
 7164:     case '-':                   return NS_VK_SUBTRACT;
 7164:     case '+':                   return NS_VK_ADD;
 6825: 
 6825:     default:
 7164:       if (!IsPrintableChar(aChar))
 6825:         NS_WARNING("GetGeckoKeyCodeFromChar has failed.");
 6825:       return 0;
 6825:     }
 7164: }
 6825: 
 6825: 
    1: static PRUint32 ConvertMacToGeckoKeyCode(UInt32 keyCode, nsKeyEvent* aKeyEvent, NSString* characters)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
    1:   PRUint32 geckoKeyCode = 0;
 6946:   PRUnichar charCode = 0;
    1:   if ([characters length])
    1:     charCode = [characters characterAtIndex:0];
    1: 
    1:   switch (keyCode)
    1:   {
    1:     // modifiers. We don't get separate events for these
    1:     case kEscapeKeyCode:        geckoKeyCode = NS_VK_ESCAPE;         break;
 7636:     case kRCommandKeyCode:
    1:     case kCommandKeyCode:       geckoKeyCode = NS_VK_META;           break;
 7636:     case kRShiftKeyCode:
    1:     case kShiftKeyCode:         geckoKeyCode = NS_VK_SHIFT;          break;
    1:     case kCapsLockKeyCode:      geckoKeyCode = NS_VK_CAPS_LOCK;      break;
 7636:     case kRControlKeyCode:
    1:     case kControlKeyCode:       geckoKeyCode = NS_VK_CONTROL;        break;
 7636:     case kROptionKeyCode:
    1:     case kOptionkeyCode:        geckoKeyCode = NS_VK_ALT;            break;
    1:     case kClearKeyCode:         geckoKeyCode = NS_VK_CLEAR;          break;
    1: 
    1:     // function keys
    1:     case kF1KeyCode:            geckoKeyCode = NS_VK_F1;             break;
    1:     case kF2KeyCode:            geckoKeyCode = NS_VK_F2;             break;
    1:     case kF3KeyCode:            geckoKeyCode = NS_VK_F3;             break;
    1:     case kF4KeyCode:            geckoKeyCode = NS_VK_F4;             break;
    1:     case kF5KeyCode:            geckoKeyCode = NS_VK_F5;             break;
    1:     case kF6KeyCode:            geckoKeyCode = NS_VK_F6;             break;
    1:     case kF7KeyCode:            geckoKeyCode = NS_VK_F7;             break;
    1:     case kF8KeyCode:            geckoKeyCode = NS_VK_F8;             break;
    1:     case kF9KeyCode:            geckoKeyCode = NS_VK_F9;             break;
    1:     case kF10KeyCode:           geckoKeyCode = NS_VK_F10;            break;
    1:     case kF11KeyCode:           geckoKeyCode = NS_VK_F11;            break;
    1:     case kF12KeyCode:           geckoKeyCode = NS_VK_F12;            break;
    1:     // case kF13KeyCode:           geckoKeyCode = NS_VK_F13;            break;    // clash with the 3 below
    1:     // case kF14KeyCode:           geckoKeyCode = NS_VK_F14;            break;
    1:     // case kF15KeyCode:           geckoKeyCode = NS_VK_F15;            break;
    1:     case kPauseKeyCode:         geckoKeyCode = NS_VK_PAUSE;          break;
    1:     case kScrollLockKeyCode:    geckoKeyCode = NS_VK_SCROLL_LOCK;    break;
    1:     case kPrintScreenKeyCode:   geckoKeyCode = NS_VK_PRINTSCREEN;    break;
    1: 
    1:     // keypad
    1:     case kKeypad0KeyCode:       geckoKeyCode = NS_VK_NUMPAD0;        break;
    1:     case kKeypad1KeyCode:       geckoKeyCode = NS_VK_NUMPAD1;        break;
    1:     case kKeypad2KeyCode:       geckoKeyCode = NS_VK_NUMPAD2;        break;
    1:     case kKeypad3KeyCode:       geckoKeyCode = NS_VK_NUMPAD3;        break;
    1:     case kKeypad4KeyCode:       geckoKeyCode = NS_VK_NUMPAD4;        break;
    1:     case kKeypad5KeyCode:       geckoKeyCode = NS_VK_NUMPAD5;        break;
    1:     case kKeypad6KeyCode:       geckoKeyCode = NS_VK_NUMPAD6;        break;
    1:     case kKeypad7KeyCode:       geckoKeyCode = NS_VK_NUMPAD7;        break;
    1:     case kKeypad8KeyCode:       geckoKeyCode = NS_VK_NUMPAD8;        break;
    1:     case kKeypad9KeyCode:       geckoKeyCode = NS_VK_NUMPAD9;        break;
    1: 
    1:     case kKeypadMultiplyKeyCode:  geckoKeyCode = NS_VK_MULTIPLY;     break;
    1:     case kKeypadAddKeyCode:       geckoKeyCode = NS_VK_ADD;          break;
    1:     case kKeypadSubtractKeyCode:  geckoKeyCode = NS_VK_SUBTRACT;     break;
    1:     case kKeypadDecimalKeyCode:   geckoKeyCode = NS_VK_DECIMAL;      break;
    1:     case kKeypadDivideKeyCode:    geckoKeyCode = NS_VK_DIVIDE;       break;
    1: 
    1:     // these may clash with forward delete and help
    1:     case kInsertKeyCode:        geckoKeyCode = NS_VK_INSERT;         break;
    1:     case kDeleteKeyCode:        geckoKeyCode = NS_VK_DELETE;         break;
    1: 
    1:     case kBackspaceKeyCode:     geckoKeyCode = NS_VK_BACK;           break;
    1:     case kTabKeyCode:           geckoKeyCode = NS_VK_TAB;            break;
    1:     case kHomeKeyCode:          geckoKeyCode = NS_VK_HOME;           break;
    1:     case kEndKeyCode:           geckoKeyCode = NS_VK_END;            break;
    1:     case kPageUpKeyCode:        geckoKeyCode = NS_VK_PAGE_UP;        break;
    1:     case kPageDownKeyCode:      geckoKeyCode = NS_VK_PAGE_DOWN;      break;
    1:     case kLeftArrowKeyCode:     geckoKeyCode = NS_VK_LEFT;           break;
    1:     case kRightArrowKeyCode:    geckoKeyCode = NS_VK_RIGHT;          break;
    1:     case kUpArrowKeyCode:       geckoKeyCode = NS_VK_UP;             break;
    1:     case kDownArrowKeyCode:     geckoKeyCode = NS_VK_DOWN;           break;
 2959:     case kVK_ANSI_1:            geckoKeyCode = NS_VK_1;              break;
 2959:     case kVK_ANSI_2:            geckoKeyCode = NS_VK_2;              break;
 2959:     case kVK_ANSI_3:            geckoKeyCode = NS_VK_3;              break;
 2959:     case kVK_ANSI_4:            geckoKeyCode = NS_VK_4;              break;
 2959:     case kVK_ANSI_5:            geckoKeyCode = NS_VK_5;              break;
 2959:     case kVK_ANSI_6:            geckoKeyCode = NS_VK_6;              break;
 2959:     case kVK_ANSI_7:            geckoKeyCode = NS_VK_7;              break;
 2959:     case kVK_ANSI_8:            geckoKeyCode = NS_VK_8;              break;
 2959:     case kVK_ANSI_9:            geckoKeyCode = NS_VK_9;              break;
 2959:     case kVK_ANSI_0:            geckoKeyCode = NS_VK_0;              break;
    1: 
    1:     default:
    1:       // if we haven't gotten the key code already, look at the char code
 6825:       geckoKeyCode = GetGeckoKeyCodeFromChar(charCode);
    1:   }
    1: 
    1:   return geckoKeyCode;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
    1: }
    1: 
    1: 
    1: static PRBool IsSpecialGeckoKey(UInt32 macKeyCode)
    1: {
    1:   PRBool  isSpecial;
    1:   
    1:   // this table is used to determine which keys are special and should not generate a charCode
    1:   switch (macKeyCode)
    1:   {
    1:     // modifiers - we don't get separate events for these yet
    1:     case kEscapeKeyCode:
    1:     case kShiftKeyCode:
 7636:     case kRShiftKeyCode:
    1:     case kCommandKeyCode:
 7636:     case kRCommandKeyCode:
    1:     case kCapsLockKeyCode:
    1:     case kControlKeyCode:
 7636:     case kRControlKeyCode:
    1:     case kOptionkeyCode:
 7636:     case kROptionKeyCode:
    1:     case kClearKeyCode:
    1:       
    1:       // function keys
    1:     case kF1KeyCode:
    1:     case kF2KeyCode:
    1:     case kF3KeyCode:
    1:     case kF4KeyCode:
    1:     case kF5KeyCode:
    1:     case kF6KeyCode:
    1:     case kF7KeyCode:
    1:     case kF8KeyCode:
    1:     case kF9KeyCode:
    1:     case kF10KeyCode:
    1:     case kF11KeyCode:
    1:     case kF12KeyCode:
    1:     case kPauseKeyCode:
    1:     case kScrollLockKeyCode:
    1:     case kPrintScreenKeyCode:
    1:       
    1:     case kInsertKeyCode:
    1:     case kDeleteKeyCode:
    1:     case kTabKeyCode:
    1:     case kBackspaceKeyCode:
    1:       
    1:     case kHomeKeyCode:
    1:     case kEndKeyCode:
    1:     case kPageUpKeyCode:
    1:     case kPageDownKeyCode:
    1:     case kLeftArrowKeyCode:
    1:     case kRightArrowKeyCode:
    1:     case kUpArrowKeyCode:
    1:     case kDownArrowKeyCode:
    1:     case kReturnKeyCode:
    1:     case kEnterKeyCode:
    1:     case kPowerbookEnterKeyCode:
    1:       isSpecial = PR_TRUE;
    1:       break;
    1:       
    1:     default:
    1:       isSpecial = PR_FALSE;
    1:       break;
    1:   }
    1:   
    1:   return isSpecial;
    1: }
    1: 
    1: 
13738: static PRBool IsNormalCharInputtingEvent(const nsKeyEvent& aEvent)
13738: {
13738:   // this is not character inputting event, simply.
13738:   if (!aEvent.isChar || !aEvent.charCode)
13738:     return PR_FALSE;
13738:   // if this is unicode char inputting event, we don't need to check
13738:   // ctrl/alt/command keys
13738:   if (aEvent.charCode > 0x7F)
13738:     return PR_TRUE;
13738:   // ASCII chars should be inputted without ctrl/alt/command keys
13738:   return !aEvent.isControl && !aEvent.isAlt && !aEvent.isMeta;
13738: }
13738: 
13738: 
 2315: // Basic conversion for cocoa to gecko events, common to all conversions.
 2315: // Note that it is OK for inEvent to be nil.
 2315: - (void) convertGenericCocoaEvent:(NSEvent*)inEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315:   NS_ASSERTION(outGeckoEvent, "convertGenericCocoaEvent:toGeckoEvent: requires non-null outGeckoEvent");
 2315:   if (!outGeckoEvent)
 2315:     return;
 2315: 
 2315:   outGeckoEvent->widget = [self widget];
 2315:   outGeckoEvent->time = PR_IntervalNow();
 2315:   outGeckoEvent->nativeMsg = inEvent;
 2315: 
 2315:   if (inEvent) {
19704:     unsigned int modifiers = nsCocoaUtils::GetCocoaEventModifierFlags(inEvent);
 2315:     outGeckoEvent->isShift   = ((modifiers & NSShiftKeyMask) != 0);
 2315:     outGeckoEvent->isControl = ((modifiers & NSControlKeyMask) != 0);
 2315:     outGeckoEvent->isAlt     = ((modifiers & NSAlternateKeyMask) != 0);
 2315:     outGeckoEvent->isMeta    = ((modifiers & NSCommandKeyMask) != 0);
 2315:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: 
 2315: - (void) convertCocoaMouseEvent:(NSEvent*)aMouseEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315:   NS_ASSERTION(aMouseEvent && outGeckoEvent, "convertCocoaMouseEvent:toGeckoEvent: requires non-null arguments");
 2315:   if (!aMouseEvent || !outGeckoEvent)
 2315:     return;
 2315: 
 2315:   [self convertGenericCocoaEvent:aMouseEvent toGeckoEvent:outGeckoEvent];
 2315: 
 2315:   // convert point to view coordinate system
 2315:   NSPoint localPoint = [self convertPoint:[aMouseEvent locationInWindow] fromView:nil];
 3233:   outGeckoEvent->refPoint.x = static_cast<nscoord>(localPoint.x);
 3233:   outGeckoEvent->refPoint.y = static_cast<nscoord>(localPoint.y);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: 
15029: #define CHARCODE_MASK_1 0x00FF0000
15029: #define CHARCODE_MASK_2 0x000000FF
15029: #define CHARCODE_MASK   0x00FF00FF
15029: //#define DEBUG_KB 1
15029: 
15029: static PRUint32
15029: KeyTranslateToUnicode(Handle aHandle, UInt32 aKeyCode, UInt32 aModifiers,
15029:                       TextEncoding aEncoding)
15029: {
15029: #ifdef DEBUG_KB
15029:   NSLog(@"****  KeyTranslateToUnicode: aHandle: %p, aKeyCode: %X, aModifiers: %X, aEncoding: %X",
15029:         aHandle, aKeyCode, aModifiers, aEncoding);
15029:   PRBool isShift = aModifiers & shiftKey;
15029:   PRBool isCtrl = aModifiers & controlKey;
15029:   PRBool isOpt = aModifiers & optionKey;
15029:   PRBool isCmd = aModifiers & cmdKey;
15029:   PRBool isCL = aModifiers & alphaLock;
15029:   PRBool isNL = aModifiers & kEventKeyModifierNumLockMask;
15029:   NSLog(@"        Shift: %s, Ctrl: %s, Opt: %s, Cmd: %s, CapsLock: %s, NumLock: %s",
15029:         isShift ? "ON" : "off", isCtrl ? "ON" : "off", isOpt ? "ON" : "off",
15029:         isCmd ? "ON" : "off", isCL ? "ON" : "off", isNL ? "ON" : "off");
15029: #endif
15029:   UInt32 state = 0;
15029:   UInt32 val =
15029:     ::KeyTranslate(aHandle, aKeyCode | aModifiers, &state) & CHARCODE_MASK;
15029:   // If state is not zero, it is in dead key state. Then, we need to recall
15029:   // KeyTranslate for getting the actual character.
15029:   if (state) {
15029:     val =
15029:       ::KeyTranslate(aHandle, aKeyCode | aModifiers, &state) & CHARCODE_MASK;
15029:   }
15029:   PRUint32 ch = 0;
15029:   UInt8 buf[2];
15029:   CFIndex len = 0;
15029:   if (val & CHARCODE_MASK_1)
15029:     buf[len++] = (val & CHARCODE_MASK_1) >> 16;
15029:   buf[len++] = val & CHARCODE_MASK_2;
15029: 
15029:   CFStringRef str =
15029:     ::CFStringCreateWithBytes(kCFAllocatorDefault, buf, len,
15029:                               (CFStringEncoding)aEncoding, false);
15029:   ch = ::CFStringGetLength(str) == 1 ?
15029:          ::CFStringGetCharacterAtIndex(str, 0) : 0;
15029:   ::CFRelease(str);
15029: #ifdef DEBUG_KB
15029:   NSLog(@"       result: %X(%C)", ch, ch > ' ' ? ch : ' ');
15029: #endif
15029:   return ch;
15029: }
15029: 
15029: static PRUint32
15067: UCKeyTranslateToUnicode(const UCKeyboardLayout* aHandle, UInt32 aKeyCode, UInt32 aModifiers,
15029:                         UInt32 aKbType)
15029: {
15029: #ifdef DEBUG_KB
15029:   NSLog(@"**** UCKeyTranslateToUnicode: aHandle: %p, aKeyCode: %X, aModifiers: %X, aKbType: %X",
15029:         aHandle, aKeyCode, aModifiers, aKbType);
15029:   PRBool isShift = aModifiers & shiftKey;
15029:   PRBool isCtrl = aModifiers & controlKey;
15029:   PRBool isOpt = aModifiers & optionKey;
15029:   PRBool isCmd = aModifiers & cmdKey;
15029:   PRBool isCL = aModifiers & alphaLock;
15029:   PRBool isNL = aModifiers & kEventKeyModifierNumLockMask;
15029:   NSLog(@"        Shift: %s, Ctrl: %s, Opt: %s, Cmd: %s, CapsLock: %s, NumLock: %s",
15029:         isShift ? "ON" : "off", isCtrl ? "ON" : "off", isOpt ? "ON" : "off",
15029:         isCmd ? "ON" : "off", isCL ? "ON" : "off", isNL ? "ON" : "off");
15029: #endif
15029:   UInt32 deadKeyState = 0;
15029:   UniCharCount len;
15029:   UniChar chars[5];
15029:   OSStatus err = ::UCKeyTranslate(aHandle, aKeyCode,
15029:                                   kUCKeyActionDown, aModifiers >> 8,
15029:                                   aKbType, kUCKeyTranslateNoDeadKeysMask,
15029:                                   &deadKeyState, 5, &len, chars);
15029:   PRUint32 ch = (err == noErr && len == 1) ? PRUint32(chars[0]) : 0;
15029: #ifdef DEBUG_KB
15029:   NSLog(@"       result: %X(%C)", ch, ch > ' ' ? ch : ' ');
15029: #endif
15029:   return ch;
15029: }
15029: 
15029: struct KeyTranslateData {
15029:   KeyTranslateData() {
15029:     mUchr.mLayout = nsnull;
15029:     mUchr.mKbType = 0;
15029:     mKchr.mHandle = nsnull;
15029:     mKchr.mEncoding = nsnull;
15029:   }
15029: 
15704:   // The script of the layout determines the encoding of characters obtained
15704:   // from kchr resources.
15029:   SInt16 mScript;
15704:   // The keyboard layout identifier
15029:   SInt32 mLayoutID;
15029: 
15029:   struct {
15067:     const UCKeyboardLayout* mLayout;
15029:     UInt32 mKbType;
15029:   } mUchr;
15029:   struct {
15029:     Handle mHandle;
15029:     TextEncoding mEncoding;
15029:   } mKchr;
15029: };
15029: 
15029: static PRUint32
15029: GetUniCharFromKeyTranslate(KeyTranslateData& aData,
15029:                            UInt32 aKeyCode, UInt32 aModifiers)
15029: {
15029:   if (aData.mUchr.mLayout) {
15029:     return UCKeyTranslateToUnicode(aData.mUchr.mLayout, aKeyCode, aModifiers,
15029:                                    aData.mUchr.mKbType);
15029:   }
15029:   if (aData.mKchr.mHandle) {
15029:     return KeyTranslateToUnicode(aData.mKchr.mHandle, aKeyCode, aModifiers,
15029:                                  aData.mKchr.mEncoding);
15029:   }
15029:   return 0;
15029: }
15029: 
15029: static SInt32
15029: GetScriptFromKeyboardLayout(SInt32 aLayoutID)
15029: {
15029:   switch (aLayoutID) {
15029:     case 3:                      // German
15029:     case -2:     return smRoman; // US-Extended
15029:     case -18944: return smGreek; // Greek
15029:     default: NS_NOTREACHED("unknown keyboard layout");
15029:   }
15029:   return smRoman;
15029: }
15029: 
15097: static CFStringRef
15097: GetInputSourceIDFromKeyboardLayout(SInt32 aLayoutID)
15097: {
15097:   NS_ASSERTION(nsToolkit::OnLeopardOrLater() &&
15097:                Leopard_TISCopyCurrentKeyboardLayoutInputSource &&
15097:                Leopard_TISGetInputSourceProperty &&
15097:                Leopard_TISCreateInputSourceList &&
15097:                kOurTISPropertyUnicodeKeyLayoutData &&
15097:                kOurTISPropertyInputSourceID,
15097:                "GetInputSourceIDFromKeyboardLayout should only be used on Leopard or later.");
15097: 
15097:   KeyboardLayoutRef keylayout;
15097:   if (KLGetKeyboardLayoutWithIdentifier(aLayoutID, &keylayout) != noErr)
15097:     return nsnull;
15097: 
15097:   const void* uchrFromID;
15097:   if (KLGetKeyboardLayoutProperty(keylayout, kKLuchrData, &uchrFromID) != noErr)
15097:     return nsnull;
15097: 
15097:   CFDictionaryRef dict = CFDictionaryCreate(kCFAllocatorDefault, NULL, NULL, 0, NULL, NULL);
15097:   CFArrayRef inputSources = Leopard_TISCreateInputSourceList(dict, true);
15097:   CFRelease(dict);
15097: 
15097:   CFStringRef sourceID = nsnull;
15097:   for (CFIndex i = 0; i < CFArrayGetCount(inputSources); ++i) {
15097:     TISInputSourceRef tis = static_cast<TISInputSourceRef>(const_cast<void *>(CFArrayGetValueAtIndex(inputSources, i)));
15097:     CFDataRef data = static_cast<CFDataRef>(Leopard_TISGetInputSourceProperty(tis, kOurTISPropertyUnicodeKeyLayoutData));
15097:     if (!data)
15097:       continue;
15097: 
15097:     const UCKeyboardLayout* uchr = reinterpret_cast<const UCKeyboardLayout*>(CFDataGetBytePtr(data));
15097:     if (uchr == uchrFromID) {
15097:       sourceID = static_cast<CFStringRef>(Leopard_TISGetInputSourceProperty(tis, kOurTISPropertyInputSourceID));
15097:       break;
15097:     }
15097:   }
15097: 
15097:   CFRelease(inputSources);
15097: 
15097:   return sourceID;
15097: }
15097: 
15072: static PRUint32
15072: GetUSLayoutCharFromKeyTranslate(UInt32 aKeyCode, UInt32 aModifiers)
15072: {
15072:   KeyTranslateData kt;
15072:   Handle handle = ::GetResource('uchr', kKLUSKeyboard); // US keyboard layout
15072:   if (!handle || !(*handle)) {
15072:     NS_ERROR("US keyboard layout doesn't have uchr resource");
15072:     return 0;
15072:   }
15072:   UInt32 kbType = 40; // ANSI, don't use actual layout
15072:   return UCKeyTranslateToUnicode((UCKeyboardLayout*)(*handle), aKeyCode,
15072:                                  aModifiers, kbType);
15072: }
15029: 
 2315: - (void) convertCocoaKeyEvent:(NSEvent*)aKeyEvent toGeckoEvent:(nsKeyEvent*)outGeckoEvent
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315:   NS_ASSERTION(aKeyEvent && outGeckoEvent, "convertCocoaKeyEvent:toGeckoEvent: requires non-null arguments");
 2315:   if (!aKeyEvent || !outGeckoEvent)
 2315:     return;
 2315: 
 2315:   [self convertGenericCocoaEvent:aKeyEvent toGeckoEvent:outGeckoEvent];
 2315: 
 2315:   // coords for key events are always 0,0
    1:   outGeckoEvent->refPoint.x = outGeckoEvent->refPoint.y = 0;
    1: 
    1:   // Initialize whether or not we are using charCodes to false.
    1:   outGeckoEvent->isChar = PR_FALSE;
    1: 
    1:   // Check to see if the message is a key press that does not involve
    1:   // one of our special key codes.
19704:   if (outGeckoEvent->message == NS_KEY_PRESS &&
19704:       !IsSpecialGeckoKey(nsCocoaUtils::GetCocoaEventKeyCode(aKeyEvent))) {
 2315:     outGeckoEvent->isChar = PR_TRUE; // this is not a special key
    1:     
    1:     outGeckoEvent->charCode = 0;
12429:     outGeckoEvent->keyCode  = 0; // not set for key press events
    1:     
14328:     NSString* chars = [aKeyEvent characters];
14328:     if ([chars length] > 0)
14328:       outGeckoEvent->charCode = [chars characterAtIndex:0];
    1:     
    1:     // convert control-modified charCode to raw charCode (with appropriate case)
    1:     if (outGeckoEvent->isControl && outGeckoEvent->charCode <= 26)
    1:       outGeckoEvent->charCode += (outGeckoEvent->isShift) ? ('A' - 1) : ('a' - 1);
    1: 
15704:     // Accel and access key handling needs to know the characters that this
15704:     // key produces with Shift up or down.  So, provide this information
15704:     // when Ctrl or Command or Alt is pressed.
14491:     if (outGeckoEvent->isControl || outGeckoEvent->isMeta ||
14491:         outGeckoEvent->isAlt) {
15029:       KeyTranslateData kt;
15067: 
15097:       if (gOverrideKeyboardLayout.mOverrideEnabled) {
15097:         kt.mLayoutID = gOverrideKeyboardLayout.mKeyboardLayout;
15097:         kt.mScript = GetScriptFromKeyboardLayout(kt.mLayoutID);
15097:       } else {
15704:         // GetScriptManagerVariable and GetScriptVariable are both deprecated.
15704:         // KLGetCurrentKeyboardLayout is newer but also deprecated in OS X
15704:         // 10.5.  It's not clear from the documentation but it seems that
15704:         // KLGetKeyboardLayoutProperty with kKLGroupIdentifier may provide the
15704:         // script identifier for a KeyboardLayoutRef (bug 432388 comment 6).
15704:         // The "Text Input Source Services" API is not available prior to OS X
15704:         // 10.5.
15097:         kt.mScript = ::GetScriptManagerVariable(smKeyScript);
15097:         kt.mLayoutID = ::GetScriptVariable(kt.mScript, smScriptKeys);
15097:       }
15097: 
15067:       CFDataRef uchr = NULL;
15704:       // GetResource('uchr', kt.mLayoutID) fails on OS X 10.5
15067:       if (nsToolkit::OnLeopardOrLater() &&
15067:           Leopard_TISCopyCurrentKeyboardLayoutInputSource &&
15067:           Leopard_TISGetInputSourceProperty &&
15097:           Leopard_TISCreateInputSourceList &&
15097:           kOurTISPropertyUnicodeKeyLayoutData &&
15097:           kOurTISPropertyInputSourceID) {
15097:         if (gOverrideKeyboardLayout.mOverrideEnabled) {
15097:           CFStringRef sourceID = GetInputSourceIDFromKeyboardLayout(kt.mLayoutID);
15097:           NS_ASSERTION(sourceID, "unable to map keyboard layout ID to input source ID");
15097:           const void* keys[] = { kOurTISPropertyInputSourceID };
15097:           const void* vals[] = { sourceID };
15097:           CFDictionaryRef dict = CFDictionaryCreate(kCFAllocatorDefault, keys, vals, 1, NULL, NULL);
15097:           CFArrayRef inputSources = Leopard_TISCreateInputSourceList(dict, true);
15097:           CFRelease(dict);
15097:           if (CFArrayGetCount(inputSources) == 1) {
15097:             TISInputSourceRef tis = static_cast<TISInputSourceRef>(const_cast<void *>(CFArrayGetValueAtIndex(inputSources, 0)));
15097:             uchr = static_cast<CFDataRef>(Leopard_TISGetInputSourceProperty(tis, kOurTISPropertyUnicodeKeyLayoutData));
15097:           }
15097:           CFRelease(inputSources);
15097:         } else {
15067:           TISInputSourceRef tis = Leopard_TISCopyCurrentKeyboardLayoutInputSource();
15067:           uchr = static_cast<CFDataRef>(Leopard_TISGetInputSourceProperty(tis, kOurTISPropertyUnicodeKeyLayoutData));
15067:         }
15097:       }
15097: 
15704:       // This fails for Azeri on 10.4 even though kKLKind (2) indicates that
15704:       // the layout has a uchr resource.  Perhaps KLGetKeyboardLayoutProperty
15704:       // with kKLuchrData would be helpful here.
15029:       Handle handle = ::GetResource('uchr', kt.mLayoutID);
15067:       if (uchr) {
15704:         // We should be here on OS X 10.5 for any Apple provided layout, as
15704:         // they are all uchr.  It may be possible to still use kchr resources
15704:         // from elsewhere, so they may be picked by
15704:         // GetScriptManagerVariable(smKCHRCache) below
15067:         kt.mUchr.mLayout = reinterpret_cast<const UCKeyboardLayout*>
15067:           (CFDataGetBytePtr(uchr));
15067:       } else if (handle) {
15704:         // uchr (Unicode) keyboard layout resource prior to 10.5.
15029:         kt.mUchr.mLayout = *((UCKeyboardLayout**)handle);
15029:       } else {
15704:         // kchr (non-Unicode) keyboard layout resource.
15704: 
15704:         // There are no know cases where GetResource succeeds here, and so
15704:         // tests (gOverrideKeyboardLayout.mOverrideEnabled) currently end up
15704:         // with no keyboard layout.  KLGetKeyboardLayoutWithIdentifier and
15704:         // KLGetKeyboardLayoutProperty with kKLKCHRData would be useful here.
15029:         kt.mKchr.mHandle = ::GetResource('kchr', kt.mLayoutID);
15704: 
15097:         if (!kt.mKchr.mHandle && !gOverrideKeyboardLayout.mOverrideEnabled)
15029:           kt.mKchr.mHandle = (char**)::GetScriptManagerVariable(smKCHRCache);
15029:         if (kt.mKchr.mHandle) {
15029:           OSStatus err =
15029:             ::GetTextEncodingFromScriptInfo(kt.mScript, kTextLanguageDontCare,
15029:                                             kTextRegionDontCare,
15029:                                             &kt.mKchr.mEncoding);
15029:           if (err != noErr)
15029:             kt.mKchr.mHandle = nsnull;
15029:         }
15029:       }
15029: 
15097:       // If a keyboard layout override is set, we also need to force the
15097:       // keyboard type to something ANSI to avoid test failures on machines
15097:       // with JIS keyboards (since the pair of keyboard layout and physical
15097:       // keyboard type form the actual key layout).  This assumes that the
15097:       // test setting the override was written assuming an ANSI keyboard.
15097:       if (kt.mUchr.mLayout)
15097:         kt.mUchr.mKbType = gOverrideKeyboardLayout.mOverrideEnabled ? 40 : ::LMGetKbdType();
15097: 
19704:       UInt32 key = nsCocoaUtils::GetCocoaEventKeyCode(aKeyEvent);
15079: 
15079:       // Caps lock and num lock modifier state:
15079:       UInt32 lockState = 0;
19704:       if (nsCocoaUtils::GetCocoaEventModifierFlags(aKeyEvent) & NSAlphaShiftKeyMask)
15079:         lockState |= alphaLock;
19704:       if (nsCocoaUtils::GetCocoaEventModifierFlags(aKeyEvent) & NSNumericPadKeyMask)
15079:         lockState |= kEventKeyModifierNumLockMask;
15072: 
15029:       // normal chars
15079:       PRUint32 unshiftedChar = GetUniCharFromKeyTranslate(kt, key, lockState);
15081:       UInt32 shiftLockMod = shiftKey | lockState;
15079:       PRUint32 shiftedChar = GetUniCharFromKeyTranslate(kt, key, shiftLockMod);
15079: 
15079:       // characters generated with Cmd key
15079:       // XXX we should remove CapsLock state, which changes characters from
15079:       //     Latin to Cyrillic with Russian layout on 10.4 only when Cmd key
15072:       //     is pressed.
15080:       UInt32 numState = (lockState & ~alphaLock); // only num lock state
15079:       PRUint32 uncmdedChar = GetUniCharFromKeyTranslate(kt, key, numState);
15096:       UInt32 shiftNumMod = numState | shiftKey;
15096:       PRUint32 uncmdedShiftChar =
15096:                  GetUniCharFromKeyTranslate(kt, key, shiftNumMod);
15079:       PRUint32 uncmdedUSChar = GetUSLayoutCharFromKeyTranslate(key, numState);
15080:       UInt32 cmdNumMod = cmdKey | numState;
15079:       PRUint32 cmdedChar = GetUniCharFromKeyTranslate(kt, key, cmdNumMod);
15080:       UInt32 cmdShiftNumMod = shiftKey | cmdNumMod;
15079:       PRUint32 cmdedShiftChar =
15079:         GetUniCharFromKeyTranslate(kt, key, cmdShiftNumMod);
15029: 
15029:       // Is the keyboard layout changed by Cmd key?
15029:       // E.g., Arabic, Russian, Hebrew, Greek and Dvorak-QWERTY.
15072:       PRBool isCmdSwitchLayout = uncmdedChar != cmdedChar;
15029:       // Is the keyboard layout for Latin, but Cmd key switches the layout?
15029:       // I.e., Dvorak-QWERTY
15072:       PRBool isDvorakQWERTY = isCmdSwitchLayout && kt.mScript == smRoman;
15029: 
15029:       // If the current keyboard is not Dvorak-QWERTY or Cmd is not pressed,
15029:       // we should append unshiftedChar and shiftedChar for handling the
15704:       // normal characters.  These are the characters that the user is most
15704:       // likely to associate with this key.
14328:       if ((unshiftedChar || shiftedChar) &&
15029:           (!outGeckoEvent->isMeta || !isDvorakQWERTY)) {
14328:         nsAlternativeCharCode altCharCodes(unshiftedChar, shiftedChar);
14328:         outGeckoEvent->alternativeCharCodes.AppendElement(altCharCodes);
14328:       }
15072: 
15704:       // Most keyboard layouts provide the same characters in the NSEvents
15704:       // with Command+Shift as with Command.  However, with Command+Shift we
15704:       // want the character on the second level.  e.g. With a US QWERTY
15704:       // layout, we want "?" when the "/","?" key is pressed with
15704:       // Command+Shift.
15096: 
15096:       // On a German layout, the OS gives us '/' with Cmd+Shift+SS(eszett)
15096:       // even though Cmd+SS is 'SS' and Shift+'SS' is '?'.  This '/' seems
15096:       // like a hack to make the Cmd+"?" event look the same as the Cmd+"?"
15096:       // event on a US keyboard.  The user thinks they are typing Cmd+"?", so
15096:       // we'll prefer the "?" character, replacing charCode with shiftedChar
15096:       // when Shift is pressed.  However, in case there is a layout where the
15096:       // character unique to Cmd+Shift is the character that the user expects,
15096:       // we'll send it as an alternative char.
15096:       PRBool hasCmdShiftOnlyChar =
15096:         cmdedChar != cmdedShiftChar && uncmdedShiftChar != cmdedShiftChar;
15096:       PRUint32 originalCmdedShiftChar = cmdedShiftChar;
15096: 
15704:       // If we can make a good guess at the characters that the user would
15704:       // expect this key combination to produce (with and without Shift) then
15704:       // use those characters.  This also corrects for CapsLock, which was
15704:       // ignored above.
15072:       if (!isCmdSwitchLayout) {
15704:         // The characters produced with Command seem similar to those without
15704:         // Command.
15079:         if (unshiftedChar)
15079:           cmdedChar = unshiftedChar;
15096:         if (shiftedChar)
15072:           cmdedShiftChar = shiftedChar;
15072:       } else if (uncmdedUSChar == cmdedChar) {
15704:         // It looks like characters from a US layout are provided when Command
15704:         // is down.
15079:         PRUint32 ch = GetUSLayoutCharFromKeyTranslate(key, lockState);
15079:         if (ch)
15079:           cmdedChar = ch;
15079:         ch = GetUSLayoutCharFromKeyTranslate(key, shiftLockMod);
15096:         if (ch)
15072:           cmdedShiftChar = ch;
15072:       }
15072: 
15704:       // Only charCode (not alternativeCharCodes) is available to javascript,
15704:       // so attempt to set this to the most likely intended (or most useful)
15704:       // character.  Note that cmdedChar and cmdedShiftChar are usually
15704:       // Latin/ASCII characters and that is what is wanted here as accel
15704:       // keys are expected to be Latin characters.
15704:       //
15072:       // XXX We should do something similar when Control is down (bug 429510).
15072:       if (outGeckoEvent->isMeta &&
15072:            !(outGeckoEvent->isControl || outGeckoEvent->isAlt)) {
15072: 
15072:         // The character to use for charCode.
15072:         PRUint32 preferredCharCode = 0;
15072:         preferredCharCode = outGeckoEvent->isShift ? cmdedShiftChar : cmdedChar;
15072: 
15072:         if (preferredCharCode) {
15072: #ifdef DEBUG_KB
15072:           if (outGeckoEvent->charCode != preferredCharCode) {
15072:             NSLog(@"      charCode replaced: %X(%C) to %X(%C)",
15072:                   outGeckoEvent->charCode,
15072:                   outGeckoEvent->charCode > ' ' ? outGeckoEvent->charCode : ' ',
15072:                   preferredCharCode,
15072:                   preferredCharCode > ' ' ? preferredCharCode : ' ');
15072:           }
15072: #endif
15072:           outGeckoEvent->charCode = preferredCharCode;
15072:         }
15072:       }
15072: 
15029:       // If the current keyboard layout is switched by the Cmd key,
15072:       // we should append cmdedChar and shiftedCmdChar that are
15029:       // Latin char for the key. But don't append at Dvorak-QWERTY.
15072:       if ((cmdedChar || cmdedShiftChar) &&
15029:           isCmdSwitchLayout && !isDvorakQWERTY) {
15072:         nsAlternativeCharCode altCharCodes(cmdedChar, cmdedShiftChar);
15029:         outGeckoEvent->alternativeCharCodes.AppendElement(altCharCodes);
15029:       }
15096:       // Special case for 'SS' key of German layout. See the comment of
15096:       // hasCmdShiftOnlyChar definition for the detail.
15096:       if (hasCmdShiftOnlyChar && originalCmdedShiftChar) {
15096:         nsAlternativeCharCode altCharCodes(0, originalCmdedShiftChar);
15096:         outGeckoEvent->alternativeCharCodes.AppendElement(altCharCodes);
15096:       }
14328:     }
    1:   }
    1:   else {
    1:     NSString* characters = nil;
    1:     if ([aKeyEvent type] != NSFlagsChanged)
 2959:       characters = [aKeyEvent charactersIgnoringModifiers];
    1:     
19704:     outGeckoEvent->keyCode =
19704:       ConvertMacToGeckoKeyCode(nsCocoaUtils::GetCocoaEventKeyCode(aKeyEvent), outGeckoEvent, characters);
    1:     outGeckoEvent->charCode = 0;
    1:   } 
    1: 
 9889:   if (outGeckoEvent->message == NS_KEY_PRESS && !outGeckoEvent->isMeta)
  603:     [NSCursor setHiddenUntilMouseMoves:YES];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
15585: // Called from PluginKeyEventsHandler() (a handler for Carbon TSM events) to
15585: // process a Carbon key event for the currently focused plugin.  Both Unicode
15585: // characters and "Mac encoding characters" (in the MBCS or "multibyte
15585: // character system") are (or should be) available from aKeyEvent, but here we
15585: // use the MCBS characters.  This is how the WebKit does things, and seems to
15585: // be what plugins expect.
15585: - (void) processPluginKeyEvent:(EventRef)aKeyEvent
15585: {
15585:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
15585: 
15585:   if (!mGeckoChild)
15585:     return;
15585: 
15585:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
15585: 
15585:   UInt32 numCharCodes;
15585:   OSStatus status = ::GetEventParameter(aKeyEvent, kEventParamKeyMacCharCodes,
15585:                                         typeChar, NULL, 0, &numCharCodes, NULL);
15585:   if (status != noErr)
15585:     return;
15585: 
15585:   nsAutoTArray<unsigned char, 3> charCodes;
15585:   charCodes.SetLength(numCharCodes);
15585:   status = ::GetEventParameter(aKeyEvent, kEventParamKeyMacCharCodes,
15585:                               typeChar, NULL, numCharCodes, NULL, charCodes.Elements());
15585:   if (status != noErr)
15585:     return;
15585: 
15585:   UInt32 modifiers;
15585:   status = ::GetEventParameter(aKeyEvent, kEventParamKeyModifiers,
15585:                                typeUInt32, NULL, sizeof(modifiers), NULL, &modifiers);
15585:   if (status != noErr)
15585:     return;
15585: 
15585:   UInt32 macKeyCode;
15585:   status = ::GetEventParameter(aKeyEvent, kEventParamKeyCode,
15585:                                typeUInt32, NULL, sizeof(macKeyCode), NULL, &macKeyCode);
15585:   if (status != noErr)
15585:     return;
15585: 
15585:   EventRef cloneEvent = ::CopyEvent(aKeyEvent);
15585:   for (unsigned int i = 0; i < numCharCodes; ++i) {
15585:     status = ::SetEventParameter(cloneEvent, kEventParamKeyMacCharCodes,
15585:                                  typeChar, 1, charCodes.Elements() + i);
15585:     if (status != noErr)
15585:       break;
15585: 
15585:     EventRecord eventRec;
15585:     if (::ConvertEventRefToEventRecord(cloneEvent, &eventRec)) {
15585:       nsKeyEvent keyDownEvent(PR_TRUE, NS_KEY_DOWN, mGeckoChild);
15585: 
15585:       PRUint32 keyCode(ConvertMacToGeckoKeyCode(macKeyCode, &keyDownEvent, @""));
15585:       PRUint32 charCode(charCodes.ElementAt(i));
15585: 
15585:       keyDownEvent.time       = PR_IntervalNow();
15585:       keyDownEvent.nativeMsg  = &eventRec;
15585:       if (IsSpecialGeckoKey(macKeyCode)) {
15585:         keyDownEvent.keyCode  = keyCode;
15585:       } else {
15585:         keyDownEvent.charCode = charCode;
15585:         keyDownEvent.isChar   = PR_TRUE;
15585:       }
15585:       keyDownEvent.isShift   = ((modifiers & shiftKey) != 0);
15585:       keyDownEvent.isControl = ((modifiers & controlKey) != 0);
15585:       keyDownEvent.isAlt     = ((modifiers & optionKey) != 0);
15585:       keyDownEvent.isMeta    = ((modifiers & cmdKey) != 0); // Should never happen
15585:       mGeckoChild->DispatchWindowEvent(keyDownEvent);
15585:       if (!mGeckoChild)
15585:         break;
15585:     }
15585:   }
15585: 
15585:   ::ReleaseEvent(cloneEvent);
15585: 
15585:   NS_OBJC_END_TRY_ABORT_BLOCK;
15585: }
15585: 
15585: 
19835: - (nsRect)sendCompositionEvent:(PRInt32) aEventType
 2315: {
 2315: #ifdef DEBUG_IME
 2315:   NSLog(@"****in sendCompositionEvent; type = %d", aEventType);
 2315: #endif
 2315: 
 2462:   if (!mGeckoChild)
19835:     return nsRect(0, 0, 0, 0);
 2462: 
 2315:   // static void init_composition_event( *aEvent, int aType)
 2315:   nsCompositionEvent event(PR_TRUE, aEventType, mGeckoChild);
 2315:   event.time = PR_IntervalNow();
 2315:   mGeckoChild->DispatchWindowEvent(event);
 2315:   return event.theReply.mCursorPosition;
 2315: }
 2315: 
 2315: 
 2315: - (void)sendTextEvent:(PRUnichar*) aBuffer 
 2315:                       attributedString:(NSAttributedString*) aString  
 2315:                       selectedRange:(NSRange) selRange 
 2315:                       markedRange:(NSRange) markRange
 2315:                       doCommit:(BOOL) doCommit
 2315: {
 2315: #ifdef DEBUG_IME
 2315:   NSLog(@"****in sendTextEvent; string = '%@'", aString);
 2315:   NSLog(@" markRange = %d, %d;  selRange = %d, %d", markRange.location, markRange.length, selRange.location, selRange.length);
 2315: #endif
 2315: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
 2315:   nsTextEvent textEvent(PR_TRUE, NS_TEXT_TEXT, mGeckoChild);
 2315:   textEvent.time = PR_IntervalNow();
 2315:   textEvent.theText = aBuffer;
 2315:   if (!doCommit)
 2315:     FillTextRangeInTextEvent(&textEvent, aString, markRange, selRange);
 2315: 
 2315:   mGeckoChild->DispatchWindowEvent(textEvent);
 2315:   if (textEvent.rangeArray)
 2315:     delete [] textEvent.rangeArray;
 2315: }
 2315: 
 2315: 
 2315: #pragma mark -
 2315: // NSTextInput implementation
 2315: 
 2315: #define MAX_BUFFER_SIZE 32
 2315: 
 2315: 
 2315: - (void)insertText:(id)insertString
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in insertText: '%@'", insertString);
11914:   NSLog(@" markRange = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
 2462:   if (!mGeckoChild)
 2462:     return;
 2315: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 4726: 
 2315:   if (![insertString isKindOfClass:[NSAttributedString class]])
 2315:     insertString = [[[NSAttributedString alloc] initWithString:insertString] autorelease];
 2315: 
 2315:   NSString *tmpStr = [insertString string];
 2315:   unsigned int len = [tmpStr length];
14365:   if (!nsTSMManager::IsComposing() && len == 0)
 4726:     return; // nothing to do
 2315:   PRUnichar buffer[MAX_BUFFER_SIZE];
 2315:   PRUnichar *bufPtr = (len >= MAX_BUFFER_SIZE) ? new PRUnichar[len + 1] : buffer;
 2315:   [tmpStr getCharacters:bufPtr];
 4726:   bufPtr[len] = PRUnichar('\0');
 2315: 
 2315:   if (len == 1 && !nsTSMManager::IsComposing()) {
12491:     // don't let the same event be fired twice when hitting
12491:     // enter/return! (Bug 420502)
12491:     if (mKeyPressSent)
12491:       return;
12491: 
 2315:     // dispatch keypress event with char instead of textEvent
 2315:     nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_PRESS, mGeckoChild);
 2315:     geckoEvent.time      = PR_IntervalNow();
 2315:     geckoEvent.charCode  = bufPtr[0]; // gecko expects OS-translated unicode
 7164:     geckoEvent.keyCode   = 0;
 2315:     geckoEvent.isChar    = PR_TRUE;
 8339:     if (mKeyDownHandled)
 2315:       geckoEvent.flags |= NS_EVENT_FLAG_NO_DEFAULT;
 2315:     // don't set other modifiers from the current event, because here in
 2315:     // -insertText: they've already been taken into account in creating
 2315:     // the input string.
 2315:         
 2315:     // create native EventRecord for use by plugins
 2315:     EventRecord macEvent;
 2315:     if (mCurKeyEvent) {
13547:       // XXX The ASCII characters inputting mode of egbridge (Japanese IME)
13547:       // might send the keyDown event with wrong keyboard layout if other
13547:       // keyboard layouts are already loaded. In that case, the native event
13547:       // doesn't match to this gecko event...
 2315:       ConvertCocoaKeyEventToMacEvent(mCurKeyEvent, macEvent);
 2315:       geckoEvent.nativeMsg = &macEvent;
19704:       geckoEvent.isShift   = (nsCocoaUtils::GetCocoaEventModifierFlags(mCurKeyEvent) & NSShiftKeyMask) != 0;
 7164:       if (!IsPrintableChar(geckoEvent.charCode)) {
 6825:         geckoEvent.keyCode = 
19704:           ConvertMacToGeckoKeyCode(nsCocoaUtils::GetCocoaEventKeyCode(mCurKeyEvent), &geckoEvent,
 6825:                                    [mCurKeyEvent charactersIgnoringModifiers]);
 7164:         geckoEvent.charCode = 0;
 7164:       }
 6825:     } else {
 6825:       // Note that insertText is not called only at key pressing.
 7164:       if (!IsPrintableChar(geckoEvent.charCode)) {
 6825:         geckoEvent.keyCode = GetGeckoKeyCodeFromChar(geckoEvent.charCode);
 7164:         geckoEvent.charCode = 0;
 7164:       }
 2315:     }
 2315: 
13042:     mKeyPressHandled = mGeckoChild->DispatchWindowEvent(geckoEvent);
12429:     mKeyPressSent = YES;
 2315:   }
 2315:   else {
 2315:     if (!nsTSMManager::IsComposing()) {
 2315:       [self sendCompositionEvent:NS_COMPOSITION_START];
10305:       // Note: mGeckoChild might have become null here. Don't count on it from here on.
 2315:       nsTSMManager::StartComposing(self);
10305:       // Note: mGeckoChild might have become null here. Don't count on it from here on.
 2315:     }
 2315: 
 4726:     if (nsTSMManager::IgnoreCommit()) {
 4726:       tmpStr = [tmpStr init];
 4726:       len = 0;
 4726:       bufPtr[0] = PRUnichar('\0');
 4726:       insertString =
 4726:         [[[NSAttributedString alloc] initWithString:tmpStr] autorelease];
 4726:     }
 2315:     [self sendTextEvent:bufPtr attributedString:insertString
 2315:                                selectedRange:NSMakeRange(0, len)
 2315:                                markedRange:mMarkedRange
 2315:                                doCommit:YES];
10305:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
10305: 
 2315:     [self sendCompositionEvent:NS_COMPOSITION_END];
10305:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
 2315:     nsTSMManager::EndComposing();
11914:     mMarkedRange = NSMakeRange(NSNotFound, 0);
 2315:   }
 2315: 
 2315:   if (bufPtr != buffer)
 2315:     delete[] bufPtr;
 4726: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: 
 2315: - (void)insertNewline:(id)sender
 2315: {
12574:   [self insertText:@"\n"];
 2315: }
 2315: 
 2315: 
 2315: - (void) doCommandBySelector:(SEL)aSelector
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12574: 
 2315: #if DEBUG_IME 
13042:   NSLog(@"**** in doCommandBySelector %s (ignore %d)", aSelector, mKeyPressHandled);
 2315: #endif
12574: 
13042:   if (!mKeyPressHandled)
 2315:     [super doCommandBySelector:aSelector];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: 
 2315: - (void) setMarkedText:(id)aString selectedRange:(NSRange)selRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315: #if DEBUG_IME 
 2315:   NSLog(@"****in setMarkedText location: %d, length: %d", selRange.location, selRange.length);
11914:   NSLog(@" markRange = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315:   NSLog(@" aString = '%@'", aString);
 2315: #endif
 2315: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 4726: 
 2315:   if (![aString isKindOfClass:[NSAttributedString class]])
 2315:     aString = [[[NSAttributedString alloc] initWithString:aString] autorelease];
 2315: 
 2315:   NSMutableAttributedString *mutableAttribStr = aString;
 2315:   NSString *tmpStr = [mutableAttribStr string];
 2315:   unsigned int len = [tmpStr length];
 2315:   PRUnichar buffer[MAX_BUFFER_SIZE];
 2315:   PRUnichar *bufPtr = (len >= MAX_BUFFER_SIZE) ? new PRUnichar[len + 1] : buffer;
 2315:   [tmpStr getCharacters:bufPtr];
 4726:   bufPtr[len] = PRUnichar('\0');
 2315: 
 2315: #if DEBUG_IME 
 2315:   printf("****in setMarkedText, len = %d, text = ", len);
 2315:   PRUint32 n = 0;
 2315:   PRUint32 maxlen = len > 12 ? 12 : len;
11914:   for (PRUnichar *a = bufPtr; (*a != PRUnichar('\0')) && n<maxlen; a++, n++)
11914:     printf((*a&0xff80) ? "\\u%4X" : "%c", *a); 
 2315:   printf("\n");
 2315: #endif
 2315: 
 2315:   mMarkedRange.length = len;
 2315: 
14534:   if (!nsTSMManager::IsComposing() && len > 0) {
11914:     nsQueryContentEvent selection(PR_TRUE, NS_QUERY_SELECTED_TEXT, mGeckoChild);
11914:     mGeckoChild->DispatchWindowEvent(selection);
11914:     mMarkedRange.location = selection.mSucceeded ? selection.mReply.mOffset : 0;
 2315:     [self sendCompositionEvent:NS_COMPOSITION_START];
10305:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
 2315:     nsTSMManager::StartComposing(self);
10305:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
 2315:   }
 2315: 
14534:   if (nsTSMManager::IsComposing()) {
 4726:     nsTSMManager::UpdateComposing(tmpStr);
 4726: 
14534:     BOOL commit = len == 0;
 2315:     [self sendTextEvent:bufPtr attributedString:aString
 2315:                                   selectedRange:selRange
 2315:                                     markedRange:mMarkedRange
14534:                                        doCommit:commit];
10305:     // Note: mGeckoChild might have become null here. Don't count on it from here on.
10305: 
14534:     if (commit) {
14534:       [self sendCompositionEvent:NS_COMPOSITION_END];
14534:       nsTSMManager::EndComposing();
14534:     }
10305:   }
 2315: 
 2315:   if (bufPtr != buffer)
 2315:     delete[] bufPtr;
 4726: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: 
 2315: - (void) unmarkText
 2315: {
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in unmarkText");
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
 4726:   nsTSMManager::CommitIME();
 2315: }
 2315: 
 2315: 
 2315: - (BOOL) hasMarkedText
 2315: {
11914: #if DEBUG_IME
11914:   NSLog(@"****in hasMarkText");
11914:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
11914: #endif
 2315:   return (mMarkedRange.location != NSNotFound) && (mMarkedRange.length != 0);
 2315: }
 2315: 
 2315: 
 2315: - (long) conversationIdentifier
 2315: {
11914: #if DEBUG_IME
11914:   NSLog(@"****in conversationIdentifier");
11914: #endif
11914:   if (!mGeckoChild)
 2315:     return (long)self;
11914:   nsQueryContentEvent textContent(PR_TRUE, NS_QUERY_TEXT_CONTENT, mGeckoChild);
11914:   textContent.InitForQueryTextContent(0, 0);
11914:   mGeckoChild->DispatchWindowEvent(textContent);
11914:   if (!textContent.mSucceeded)
11914:     return (long)self;
11914: #if DEBUG_IME
11914:   NSLog(@" the ID = %ld", (long)textContent.mReply.mContentsRoot);
11914: #endif
11914:   return (long)textContent.mReply.mContentsRoot;
 2315: }
 2315: 
 2315: 
 2315: - (NSAttributedString *) attributedSubstringFromRange:(NSRange)theRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in attributedSubstringFromRange");
 2315:   NSLog(@" theRange      = %d, %d", theRange.location, theRange.length);
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
11914:   if (!mGeckoChild || theRange.length == 0)
 2462:     return nil;
 2462: 
11914:   nsAutoString str;
11914:   nsQueryContentEvent textContent(PR_TRUE, NS_QUERY_TEXT_CONTENT, mGeckoChild);
11914:   textContent.InitForQueryTextContent(theRange.location, theRange.length);
11914:   mGeckoChild->DispatchWindowEvent(textContent);
11914: 
11914:   if (!textContent.mSucceeded || textContent.mReply.mString.IsEmpty())
11914:     return nil;
11914: 
14962:   NSString* nsstr = ToNSString(textContent.mReply.mString);
11914:   NSAttributedString* result =
11914:     [[[NSAttributedString alloc] initWithString:nsstr
 2315:                                      attributes:nil] autorelease];
 2315:   return result;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 2315: }
 2315: 
 2315: 
 2315: - (NSRange) markedRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in markedRange");
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
 2315: 
 2315:   if (![self hasMarkedText]) {
 2315:     return NSMakeRange(NSNotFound, 0);
 2315:   }
 2315: 
 2315:   return mMarkedRange;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakeRange(0, 0));
 2315: }
 2315: 
 2315: 
 2315: - (NSRange) selectedRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in selectedRange");
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
11914:   if (!mGeckoChild)
11914:     return NSMakeRange(NSNotFound, 0);
11914:   nsQueryContentEvent selection(PR_TRUE, NS_QUERY_SELECTED_TEXT, mGeckoChild);
11914:   mGeckoChild->DispatchWindowEvent(selection);
11914:   if (!selection.mSucceeded)
11914:     return NSMakeRange(NSNotFound, 0);
11914: 
11914: #if DEBUG_IME
11914:   NSLog(@" result of selectedRange = %d, %d",
11914:         selection.mReply.mOffset, selection.mReply.mString.Length());
11914: #endif
11914:   return NSMakeRange(selection.mReply.mOffset,
11914:                      selection.mReply.mString.Length());
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakeRange(0, 0));
 2315: }
 2315: 
 2315: 
 2315: - (NSRect) firstRectForCharacterRange:(NSRange)theRange
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in firstRectForCharacterRange");
 2315:   NSLog(@" theRange      = %d, %d", theRange.location, theRange.length);
 2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
11914:   // XXX this returns first character rect or caret rect, it is limitation of
11914:   // now. We need more work for returns first line rect. But current
11914:   // implementation is enough for IMEs.
11914: 
11914:   NSRect rect;
11914:   if (!mGeckoChild || theRange.location == NSNotFound)
11914:     return rect;
11914: 
19835:   nsRect r;
11914:   PRBool useCaretRect = theRange.length == 0;
11914:   if (!useCaretRect) {
11914:     nsQueryContentEvent charRect(PR_TRUE, NS_QUERY_CHARACTER_RECT, mGeckoChild);
11914:     charRect.InitForQueryCharacterRect(theRange.location);
11914:     mGeckoChild->DispatchWindowEvent(charRect);
11914:     if (charRect.mSucceeded)
11914:       r = charRect.mReply.mRect;
11914:     else
11914:       useCaretRect = PR_TRUE;
11914:   }
11914: 
11914:   if (useCaretRect) {
11914:     nsQueryContentEvent caretRect(PR_TRUE, NS_QUERY_CARET_RECT, mGeckoChild);
11914:     caretRect.InitForQueryCaretRect(theRange.location);
11914:     mGeckoChild->DispatchWindowEvent(caretRect);
11914:     if (!caretRect.mSucceeded)
11914:       return rect;
11914:     r = caretRect.mReply.mRect;
11914:     r.width = 0;
11914:   }
11914: 
11914:   nsIWidget* rootWidget = mGeckoChild->GetTopLevelWidget();
11914:   NSWindow* rootWindow =
11914:     static_cast<NSWindow*>(rootWidget->GetNativeData(NS_NATIVE_WINDOW));
11914:   NSView* rootView =
11914:     static_cast<NSView*>(rootWidget->GetNativeData(NS_NATIVE_WIDGET));
11914:   if (!rootWindow || !rootView)
11914:     return rect;
11914:   GeckoRectToNSRect(r, rect);
11914:   rect = [rootView convertRect:rect toView:nil];
11914:   rect.origin = [rootWindow convertBaseToScreen:rect.origin];
11914: #if DEBUG_IME
11914:   NSLog(@" result rect (x,y,w,h) = %f, %f, %f, %f",
11914:         rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
11914: #endif
11914:   return rect;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakeRect(0.0, 0.0, 0.0, 0.0));
 2315: }
 2315: 
 2315: 
 2315: - (unsigned int)characterIndexForPoint:(NSPoint)thePoint
 2315: {
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in characterIndexForPoint");
11914:   NSLog(@" markRange = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
 2315: 
 2315:   // To implement this, we'd have to grovel in text frames looking at text offsets.
 2315:   return 0;
 2315: }
 2315: 
 2315: 
 2315: - (NSArray*) validAttributesForMarkedText
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 2315: #if DEBUG_IME
 2315:   NSLog(@"****in validAttributesForMarkedText");
11914:   NSLog(@" markRange = %d, %d", mMarkedRange.location, mMarkedRange.length);
 2315: #endif
 2315: 
 2315:   //return [NSArray arrayWithObjects:NSUnderlineStyleAttributeName, NSMarkedClauseSegmentAttributeName, NSTextInputReplacementRangeAttributeName, nil];
 2315:   return [NSArray array]; // empty array; we don't support any attributes right now
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 2315: }
 2315: 
 2315: 
 2315: #pragma mark -
 2315: 
 2315: 
 7100: + (NSEvent*)makeNewCocoaEventWithType:(NSEventType)type fromEvent:(NSEvent*)theEvent
 7100: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 7100:   NSEvent* newEvent = [NSEvent keyEventWithType:type
 7100:                                        location:[theEvent locationInWindow] 
19704:                                   modifierFlags:nsCocoaUtils::GetCocoaEventModifierFlags(theEvent)
 7100:                                       timestamp:[theEvent timestamp]
 7100:                                    windowNumber:[theEvent windowNumber]
 7100:                                         context:[theEvent context]
 7100:                                      characters:[theEvent characters]
 7100:                     charactersIgnoringModifiers:[theEvent charactersIgnoringModifiers]
 7100:                                       isARepeat:[theEvent isARepeat]
19704:                                         keyCode:nsCocoaUtils::GetCocoaEventKeyCode(theEvent)];
 7100:   return newEvent;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 7100: }
 7100: 
14962: #ifdef PR_LOGGING
14962: static const char* ToEscapedString(NSString* aString, nsCAutoString& aBuf)
14962: {
14962:   for (PRUint32 i = 0; i < [aString length]; ++i) {
14962:     unichar ch = [aString characterAtIndex:i];
14962:     if (ch >= 32 && ch < 128) {
14962:       aBuf.Append(char(ch));
14962:     } else {
14962:       aBuf += nsPrintfCString("\\u%04x", ch);
14962:     }
14962:   }
14962:   return aBuf.get();
14962: }
14962: #endif
 7100: 
13042: // Returns PR_TRUE if Gecko claims to have handled the event, PR_FALSE otherwise.
13042: - (PRBool)processKeyDownEvent:(NSEvent*)theEvent keyEquiv:(BOOL)isKeyEquiv
13042: {
13042:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2462:   if (!mGeckoChild)
13042:     return NO;
 2462: 
14962: #ifdef PR_LOGGING
14962:   nsCAutoString str1;
14962:   nsCAutoString str2;
14962: #endif
14962:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS,
14962:          ("ChildView processKeyDownEvent: keycode=%d,modifiers=%x,chars=%s,charsIgnoringModifiers=%s\n",
19704:           nsCocoaUtils::GetCocoaEventKeyCode(theEvent),
19704:           nsCocoaUtils::GetCocoaEventModifierFlags(theEvent),
14962:           ToEscapedString([theEvent characters], str1),
14962:           ToEscapedString([theEvent charactersIgnoringModifiers], str2)));
14962: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 2315:   mCurKeyEvent = theEvent;
 2315: 
 2315:   BOOL nonDeadKeyPress = [[theEvent characters] length] > 0;
 8339:   if (nonDeadKeyPress) {
 8339:     if (![theEvent isARepeat]) {
 8339:       NSResponder* firstResponder = [[self window] firstResponder];
 8339: 
 2315:       nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_DOWN, nsnull);
 2315:       [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
 2315:       // create native EventRecord for use by plugins
 2315:       EventRecord macEvent;
 2315:       ConvertCocoaKeyEventToMacEvent(theEvent, macEvent);
 2315:       geckoEvent.nativeMsg = &macEvent;
12429: 
 8339:       mKeyDownHandled = mGeckoChild->DispatchWindowEvent(geckoEvent);
 7100:       if (!mGeckoChild)
13042:         return mKeyDownHandled;
 8339: 
 2315:       // The key down event may have shifted the focus, in which
 2315:       // case we should not fire the key press.
 8339:       if (firstResponder != [[self window] firstResponder]) {
13042:         PRBool handled = mKeyDownHandled;
 2315:         mCurKeyEvent = nil;
 8339:         mKeyDownHandled = PR_FALSE;
13042:         return handled;
 2315:       }
 8339:     }
 8339: 
12536:     // If this is the context menu key command, send a context menu key event.
19704:     unsigned int modifierFlags =
19704:       nsCocoaUtils::GetCocoaEventModifierFlags(theEvent) & NSDeviceIndependentModifierFlagsMask;
12536:     if (modifierFlags == NSControlKeyMask && [[theEvent charactersIgnoringModifiers] isEqualToString:@" "]) {
12536:       nsMouseEvent contextMenuEvent(PR_TRUE, NS_CONTEXTMENU, [self widget], nsMouseEvent::eReal, nsMouseEvent::eContextMenuKey);
12536:       contextMenuEvent.isShift = contextMenuEvent.isControl = contextMenuEvent.isAlt = contextMenuEvent.isMeta = PR_FALSE;
13042:       PRBool cmEventHandled = mGeckoChild->DispatchWindowEvent(contextMenuEvent);
12536:       [self maybeInitContextMenuTracking];
12536:       // Bail, there is nothing else to do here.
13042:       PRBool handled = (cmEventHandled || mKeyDownHandled);
12536:       mCurKeyEvent = nil;
12536:       mKeyDownHandled = PR_FALSE;
13042:       return handled;
12536:     }
12536: 
 2315:     nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_PRESS, nsnull);
 2315:     [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
 2315:     // if this is a non-letter keypress, or the control key is down,
 2315:     // dispatch the keydown to gecko, so that we trap delete,
 2315:     // control-letter combinations etc before Cocoa tries to use
 2315:     // them for keybindings.
 2315:     if ((!geckoEvent.isChar || geckoEvent.isControl) &&
 2315:         !nsTSMManager::IsComposing()) {
12429:       if (mKeyDownHandled)
12429:         geckoEvent.flags |= NS_EVENT_FLAG_NO_DEFAULT;
12429: 
 2315:       // create native EventRecord for use by plugins
 2315:       EventRecord macEvent;
 2315:       ConvertCocoaKeyEventToMacEvent(theEvent, macEvent);
 2315:       geckoEvent.nativeMsg = &macEvent;
 2315: 
13042:       mKeyPressHandled = mGeckoChild->DispatchWindowEvent(geckoEvent);
13042:       mKeyPressSent = YES;
 7100:       if (!mGeckoChild)
13042:         return (mKeyDownHandled || mKeyPressHandled);
12429:     }
12429:   }
12429: 
16548:   // We need to initialize the TSMDocument *before* interpretKeyEvents when
16548:   // IME is enabled.
16548:   if (!isKeyEquiv && nsTSMManager::IsIMEEnabled()) {
16548:     // We need to get actual focused view. E.g., the view is in bookmark dialog
16548:     // that is <panel> element. Then, the key events are processed the parent
16548:     // window's view that has native focus.
16548:     nsQueryContentEvent textContent(PR_TRUE, NS_QUERY_TEXT_CONTENT,
16548:                                     mGeckoChild);
16548:     textContent.InitForQueryTextContent(0, 0);
16548:     mGeckoChild->DispatchWindowEvent(textContent);
16548:     NSView<mozView>* focusedView = self;
16548:     if (textContent.mSucceeded && textContent.mReply.mFocusedWidget) {
16548:       NSView<mozView>* view =
16548:         static_cast<NSView<mozView>*>(textContent.mReply.mFocusedWidget->
16548:                                       GetNativeData(NS_NATIVE_WIDGET));
16548:       if (view)
16548:         focusedView = view;
16548:     }
16548:     nsTSMManager::InitTSMDocument(focusedView);
16548:   }
16548: 
12429:   // Let Cocoa interpret the key events, caching IsComposing first.
12429:   // We don't do it if this came from performKeyEquivalent because
12429:   // interpretKeyEvents isn't set up to handle those key combinations.
12429:   PRBool wasComposing = nsTSMManager::IsComposing();
13738:   PRBool interpretKeyEventsCalled = PR_FALSE;
13856:   if (!isKeyEquiv &&
13856:       (nsTSMManager::IsIMEEnabled() || nsTSMManager::IsRomanKeyboardsOnly())) {
 2315:     [super interpretKeyEvents:[NSArray arrayWithObject:theEvent]];
13738:     interpretKeyEventsCalled = PR_TRUE;
13738:   }
12429: 
12429:   if (!mGeckoChild)
13042:     return (mKeyDownHandled || mKeyPressHandled);;
12429: 
12429:   if (!mKeyPressSent && nonDeadKeyPress && !wasComposing && !nsTSMManager::IsComposing()) {
12429:     nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_PRESS, nsnull);
12429:     [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
13738: 
13738:     // If we called interpretKeyEvents and this isn't normal character input
13738:     // then IME probably ate the event for some reason. We do not want to
13738:     // send a key press event in that case.
13738:     if (!(interpretKeyEventsCalled && IsNormalCharInputtingEvent(geckoEvent))) {
12429:       if (mKeyDownHandled)
12429:         geckoEvent.flags |= NS_EVENT_FLAG_NO_DEFAULT;
12429: 
12429:       // create native EventRecord for use by plugins
12429:       EventRecord macEvent;
12429:       ConvertCocoaKeyEventToMacEvent(theEvent, macEvent);
12429:       geckoEvent.nativeMsg = &macEvent;
12429: 
13042:       mKeyPressHandled = mGeckoChild->DispatchWindowEvent(geckoEvent);
 7860:     }
13738:   }
 2315: 
10305:   // Note: mGeckoChild might have become null here. Don't count on it from here on.
10305: 
13042:   PRBool handled = (mKeyDownHandled || mKeyPressHandled);
13042: 
12429:   // See note about nested event loops where these variables are declared in header.
13042:   mKeyPressHandled = NO;
12429:   mKeyPressSent = NO;
 2315:   mCurKeyEvent = nil;
 8339:   mKeyDownHandled = PR_FALSE;
11978: 
13042:   return handled;
13042: 
13042:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 8339: }
 8339: 
 2315: 
15585: // Create a TSM document for use with plugins, so that we can support IME in
15585: // them.  Once it's created, if need be (re)activate it.  Some plugins (e.g.
15585: // the Flash plugin running in Camino) don't create their own TSM document --
15585: // without which IME can't work.  Others (e.g. the Flash plugin running in
15585: // Firefox) create a TSM document that (somehow) makes the input window behave
15585: // badly when it contains more than one kind of input (say Hiragana and
15585: // Romaji).  (We can't just use the per-NSView TSM documents that Cocoa
15585: // provices (those created and managed by the NSTSMInputContext class) -- for
15585: // some reason TSMProcessRawKeyEvent() doesn't work with them.)
15585: - (void)activatePluginTSMDoc
15585: {
15585:   if (!mPluginTSMDoc) {
15585:     // Create a TSM document that supports both non-Unicode and Unicode input.
15585:     // Though [ChildView processPluginKeyEvent:] only sends Mac char codes to
15585:     // the plugin, this makes the input window behave better when it contains
15585:     // more than one kind of input (say Hiragana and Romaji).  This is what
15585:     // the OS does when it creates a TSM document for use by an
15585:     // NSTSMInputContext class.
15585:     InterfaceTypeList supportedServices;
15585:     supportedServices[0] = kTextServiceDocumentInterfaceType;
15585:     supportedServices[1] = kUnicodeDocumentInterfaceType;
15585:     ::NewTSMDocument(2, supportedServices, &mPluginTSMDoc, 0);
15585:     // We'll need to use the "input window".
15585:     ::UseInputWindow(mPluginTSMDoc, YES);
15585:     ::ActivateTSMDocument(mPluginTSMDoc);
15585:   } else if (::TSMGetActiveDocument() != mPluginTSMDoc) {
15585:     ::ActivateTSMDocument(mPluginTSMDoc);
15585:   }
15585: }
15585: 
15585: 
12429: - (void)keyDown:(NSEvent*)theEvent
12429: {
15585:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
15585: 
15585:   // If a plugin has the focus, we need to use an alternate method for
15585:   // handling NSKeyDown and NSKeyUp events (otherwise Carbon-based IME won't
15585:   // work in plugins like the Flash plugin).  The same strategy is used by the
15585:   // WebKit.  See PluginKeyEventsHandler() and [ChildView processPluginKeyEvent:]
15585:   // for more info.
15585:   if (mGeckoChild && mIsPluginView) {
15585:     [self activatePluginTSMDoc];
15585:     // We use the active TSM document to pass a pointer to ourselves (the
15585:     // currently focused ChildView) to PluginKeyEventsHandler().  Because this
15585:     // pointer is weak, we should retain and release ourselves around the call
15585:     // to TSMProcessRawKeyEvent().
15585:     nsAutoRetainCocoaObject kungFuDeathGrip(self);
15585:     ::TSMSetDocumentProperty(mPluginTSMDoc, kFocusedChildViewTSMDocPropertyTag,
15585:                              sizeof(ChildView *), &self);
15585:     ::TSMProcessRawKeyEvent([theEvent _eventRef]);
15585:     ::TSMRemoveDocumentProperty(mPluginTSMDoc, kFocusedChildViewTSMDocPropertyTag);
15585:     return;
15585:   }
15585: 
12429:   [self processKeyDownEvent:theEvent keyEquiv:NO];
15585: 
15585:   NS_OBJC_END_TRY_ABORT_BLOCK;
12429: }
12429: 
12429: 
 7100: static BOOL keyUpAlreadySentKeyDown = NO;
 2315: 
 2315: - (void)keyUp:(NSEvent*)theEvent
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14962: #ifdef PR_LOGGING
14962:   nsCAutoString str1;
14962:   nsCAutoString str2;
14962: #endif
14962:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS,
14962:          ("ChildView keyUp: keycode=%d,modifiers=%x,chars=%s,charsIgnoringModifiers=%s\n",
19704:           nsCocoaUtils::GetCocoaEventKeyCode(theEvent),
19704:           nsCocoaUtils::GetCocoaEventModifierFlags(theEvent),
14962:           ToEscapedString([theEvent characters], str1),
14962:           ToEscapedString([theEvent charactersIgnoringModifiers], str2)));
14962: 
15585:   if (!mGeckoChild)
15585:     return;
15585: 
15585:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
15585: 
15585:   if (mIsPluginView) {
15585:     // I'm not sure the call to TSMProcessRawKeyEvent() is needed here (though
15585:     // WebKit makes one).
15585:     ::TSMProcessRawKeyEvent([theEvent _eventRef]);
15585: 
15585:     // Don't send a keyUp event if the corresponding keyDown event(s) is/are
15585:     // still being processed (idea borrowed from WebKit).
15585:     ChildView *keyDownTarget = nil;
15585:     OSStatus status = ::TSMGetDocumentProperty(mPluginTSMDoc, kFocusedChildViewTSMDocPropertyTag,
15585:                                                sizeof(ChildView *), nil, &keyDownTarget);
15585:     if (status != noErr)
15585:       keyDownTarget = nil;
15585:     if (keyDownTarget == self)
15585:       return;
15585: 
15585:     // PluginKeyEventsHandler() never sends keyUp events to [ChildView
15585:     // processPluginKeyEvent:], so we need to send them to Gecko here.  (This
15585:     // means that when commiting text from IME, several keyDown events may be
15585:     // sent to Gecko (in processPluginKeyEvent) for one keyUp event here.
15585:     // But this is how the WebKit does it, and games expect a keyUp event to
15585:     // be sent when it actually happens (they need to be able to detect how
15585:     // long a key has been held down) -- which wouldn't be possible if we sent
15585:     // them from processPluginKeyEvent.)
15585:     nsKeyEvent keyUpEvent(PR_TRUE, NS_KEY_UP, nsnull);
15585:     [self convertCocoaKeyEvent:theEvent toGeckoEvent:&keyUpEvent];
15585:     EventRecord macKeyUpEvent;
15585:     ConvertCocoaKeyEventToMacEvent(theEvent, macKeyUpEvent);
15585:     keyUpEvent.nativeMsg = &macKeyUpEvent;
15585:     mGeckoChild->DispatchWindowEvent(keyUpEvent);
15585:     return;
15585:   }
15585: 
 2315:   // if we don't have any characters we can't generate a keyUp event
15585:   if ([[theEvent characters] length] == 0)
 2315:     return;
 2315: 
 7281:   // Cocoa doesn't send an NSKeyDown event for control-tab on 10.4, so if this
 7100:   // is an NSKeyUp event for control-tab, send a down event to gecko first.
 7280:   if (!nsToolkit::OnLeopardOrLater() && !keyUpAlreadySentKeyDown &&
19704:       nsCocoaUtils::GetCocoaEventModifierFlags(theEvent) & NSControlKeyMask &&
19704:       nsCocoaUtils::GetCocoaEventKeyCode(theEvent) == kTabKeyCode) {
 7100:     // We'll need an NSKeyDown copy of our native event so we convert to a gecko event correctly.
 7100:     NSEvent* nativeKeyDownEvent = [ChildView makeNewCocoaEventWithType:NSKeyDown fromEvent:theEvent];
 7100: 
 7100:     // send a key down event if we should
 7100:     PRBool keyDownHandled = PR_FALSE;
 7100:     if (![nativeKeyDownEvent isARepeat]) {
 7100:       nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_DOWN, nsnull);
 7100:       [self convertCocoaKeyEvent:nativeKeyDownEvent toGeckoEvent:&geckoEvent];
 7100: 
 7100:       // create native EventRecord for use by plugins
 7100:       EventRecord macEvent;
 7100:       ConvertCocoaKeyEventToMacEvent(nativeKeyDownEvent, macEvent);
 7100:       geckoEvent.nativeMsg = &macEvent;
12429: 
 7100:       keyDownHandled = mGeckoChild->DispatchWindowEvent(geckoEvent);
 7100:       if (!mGeckoChild)
 7100:         return;
 7100:     }
 7100: 
 7100:     // Check to see if we are still the first responder.
 7100:     // The key down event may have shifted the focus, in which
 7100:     // case we should not fire the key press.
 7100:     NSResponder* resp = [[self window] firstResponder];
 7100:     if (resp != (NSResponder*)self) {
 7100:       keyUpAlreadySentKeyDown = YES;
 7100:       [resp keyUp:theEvent];      
 7100:       keyUpAlreadySentKeyDown = NO;
 7100:       return;
 7100:     }
 7100: 
 7100:     // now send a key press event if we should
 7100:     if (!nsTSMManager::IsComposing()) {
 7100:       nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_PRESS, nsnull);
 7100:       [self convertCocoaKeyEvent:nativeKeyDownEvent toGeckoEvent:&geckoEvent];
 7100: 
 7100:       if (keyDownHandled)
 7100:         geckoEvent.flags |= NS_EVENT_FLAG_NO_DEFAULT;
 7100: 
 7100:       // create native EventRecord for use by plugins
 7100:       EventRecord macEvent;
 7100:       ConvertCocoaKeyEventToMacEvent(nativeKeyDownEvent, macEvent);
 7100:       geckoEvent.nativeMsg = &macEvent;
 7100: 
 8339:       mGeckoChild->DispatchWindowEvent(geckoEvent);
 7100:       if (!mGeckoChild)
 7100:         return;
 7100:     }
 7100:   }
 7100: 
 2315:   nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_UP, nsnull);
 2315:   [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
 2315:   // create native EventRecord for use by plugins
 2315:   EventRecord macEvent;
 2315:   ConvertCocoaKeyEventToMacEvent(theEvent, macEvent);
 2315:   geckoEvent.nativeMsg = &macEvent;
 2315: 
 2315:   mGeckoChild->DispatchWindowEvent(geckoEvent);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: 
 2315: - (BOOL)performKeyEquivalent:(NSEvent*)theEvent
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
12429:   // don't do anything if we don't have a gecko widget
11091:   if (!mGeckoChild)
12429:     return NO;
12429: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
12467: 
15574:   // If we're not the first responder and the first responder is an NSView
15574:   // object, pass the event on.  Otherwise (if, for example, the first
15574:   // responder is an NSWindow object) we should trust the OS to have called
15574:   // us correctly.
14024:   id firstResponder = [[self window] firstResponder];
14024:   if (firstResponder != self) {
15574:     // Special handling if the other first responder is a ChildView.
14024:     if ([firstResponder isKindOfClass:[ChildView class]])
14024:       return [(ChildView *)firstResponder performKeyEquivalent:theEvent];
15574:     if ([firstResponder isKindOfClass:[NSView class]])
12429:       return [super performKeyEquivalent:theEvent];
14024:   }
12429: 
12429:   // don't process if we're composing, but don't consume the event
11531:   if (nsTSMManager::IsComposing())
11091:     return NO;
11091: 
16983:   // Set to true if embedding menus handled the event when a plugin has focus.
16983:   // We give menus a crack at handling commands before Gecko in the plugin case.
16983:   BOOL handledByEmbedding = NO;
16983: 
14024:   // Perform native menu UI feedback even if we stop the event from propagating to it normally.
14024:   // Recall that the menu system won't actually execute any commands for keyboard command invocations.
14738:   //
14738:   // If this is a plugin, we do actually perform the action on keyboard commands. See bug 428047.
14738:   // If the action on plugins here changes the first responder, don't continue.
14024:   NSMenu* mainMenu = [NSApp mainMenu];
14738:   if (mIsPluginView) {
16983:     if ([mainMenu isKindOfClass:[GeckoNSMenu class]]) {
14738:       [(GeckoNSMenu*)mainMenu actOnKeyEquivalent:theEvent];
16983:     }
16983:     else {
16983:       // This is probably an embedding situation. If the native menu handle the event
16983:       // then return YES from pKE no matter what Gecko or the plugin does.
16983:       handledByEmbedding = [mainMenu performKeyEquivalent:theEvent];
16983:     }
14738:     if ([[self window] firstResponder] != self)
14738:       return YES;
14738:   }
14738:   else {
14024:     if ([mainMenu isKindOfClass:[GeckoNSMenu class]])
14024:       [(GeckoNSMenu*)mainMenu performMenuUserInterfaceEffectsForEvent:theEvent];
14738:   }
 2315: 
14871:   // With Cmd key or Ctrl+Tab or Ctrl+Esc, keyDown will be never called.
14871:   // Therefore, we need to call processKeyDownEvent from performKeyEquivalent.
19704:   UInt32 modifierFlags =
19704:     nsCocoaUtils::GetCocoaEventModifierFlags(theEvent) & NSDeviceIndependentModifierFlagsMask;
19704:   UInt32 keyCode = nsCocoaUtils::GetCocoaEventKeyCode(theEvent);
14871:   PRBool keyDownNeverFiredEvent = (modifierFlags & NSCommandKeyMask) ||
14871:            ((modifierFlags & NSControlKeyMask) &&
14871:             (keyCode == kEscapeKeyCode || keyCode == kTabKeyCode));
14871: 
 2315:   // don't handle this if certain modifiers are down - those should
 2315:   // be sent as normal key up/down events and cocoa will do so automatically
 2315:   // if we reject here
14871:   if (!keyDownNeverFiredEvent &&
14871:       (modifierFlags & (NSFunctionKeyMask| NSNumericPadKeyMask)))
16983:     return handledByEmbedding;
 2315: 
14573:   // Control and option modifiers are used when changing input sources in the
14573:   // input menu. We need to send such key events via "keyDown:", which will
14573:   // happen if we return NO here. This only applies to Mac OS X 10.5 and higher,
14573:   // previous OS versions just call "keyDown:" and not "performKeyEquivalent:"
14573:   // for such events.
14871:   if (!keyDownNeverFiredEvent &&
14690:       (modifierFlags & (NSControlKeyMask | NSAlternateKeyMask)))
16983:     return handledByEmbedding;
14573: 
13042:   if ([theEvent type] == NSKeyDown) {
13042:     // We trust the Gecko handled status for cmd key events. See bug 417466 for more info.
13042:     if (modifierFlags & NSCommandKeyMask)
16983:       return ([self processKeyDownEvent:theEvent keyEquiv:YES] || handledByEmbedding);
13042:     else
12429:       [self processKeyDownEvent:theEvent keyEquiv:YES];
13042:   }
10884: 
10884:   return YES;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 2315: }
 2315: 
 2315: 
 2315: - (void)flagsChanged:(NSEvent*)theEvent
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2462:   if (!mGeckoChild)
 2462:     return;
 2462: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 2315:   // Fire key up/down events for the modifier keys (shift, alt, ctrl, command).
 2315:   if ([theEvent type] == NSFlagsChanged) {
 2315:     unsigned int modifiers =
19704:       nsCocoaUtils::GetCocoaEventModifierFlags(theEvent) & NSDeviceIndependentModifierFlagsMask;
 2315:     const PRUint32 kModifierMaskTable[] =
 2315:       { NSShiftKeyMask, NSControlKeyMask, NSAlternateKeyMask, NSCommandKeyMask };
 2315:     const PRUint32 kModifierCount = sizeof(kModifierMaskTable) /
 2315:                                     sizeof(kModifierMaskTable[0]);
 2315: 
 2315:     for (PRUint32 i = 0; i < kModifierCount; i++) {
 2315:       PRUint32 modifierBit = kModifierMaskTable[i];
 2315:       if ((modifiers & modifierBit) != (mLastModifierState & modifierBit)) {
 2315:         PRUint32 message = ((modifiers & modifierBit) != 0 ? NS_KEY_DOWN :
 2315:                                                              NS_KEY_UP);
 2315: 
 2315:         // Fire a key event.
 2315:         nsKeyEvent geckoEvent(PR_TRUE, message, nsnull);
 2315:         [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
 2315: 
 2315:         // create native EventRecord for use by plugins
 2315:         EventRecord macEvent;
 2315:         ConvertCocoaKeyEventToMacEvent(theEvent, macEvent, message);
 2315:         geckoEvent.nativeMsg = &macEvent;
 2315: 
 2315:         mGeckoChild->DispatchWindowEvent(geckoEvent);
10305:         if (!mGeckoChild)
10305:           return;
 2315: 
 2315:         // Stop if focus has changed.
 2315:         // Check to see if we are still the first responder.
 2315:         NSResponder* resp = [[self window] firstResponder];
 2315:         if (resp != (NSResponder*)self)
 2315:           break;
 2315:       }
 2315:     }
 2315: 
 2315:     mLastModifierState = modifiers;
 2315:   }
 2315: 
 2315:   // check if the hand scroll cursor needs to be set/unset
 2315:   [self setHandScrollCursor:theEvent];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: 
 2315: // This method is called when are are about to lose focus.
 2677: // We must always call through to our superclass, even when mGeckoChild is
 2677: // nil -- otherwise the keyboard focus can end up in the wrong NSView.
 2315: - (BOOL)resignFirstResponder
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2315:   return [super resignFirstResponder];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 2315: }
 2315: 
 2315: 
 2315: - (void)viewsWindowDidBecomeKey
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2315:   if (!mGeckoChild)
 2462:     return;
 2315: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 2315:   // check to see if the window implements the mozWindow protocol. This
 2315:   // allows embedders to avoid re-entrant calls to -makeKeyAndOrderFront,
 2315:   // which can happen because these activate/focus calls propagate out
 2315:   // to the embedder via nsIEmbeddingSiteWindow::SetFocus().
 2315:   BOOL isMozWindow = [[self window] respondsToSelector:@selector(setSuppressMakeKeyFront:)];
 2315:   if (isMozWindow)
 2315:     [[self window] setSuppressMakeKeyFront:YES];
 2315: 
 4208:   [self sendFocusEvent:NS_GOTFOCUS];
 4208:   [self sendFocusEvent:NS_ACTIVATE];
 2315: 
 2315:   if (isMozWindow)
 2315:     [[self window] setSuppressMakeKeyFront:NO];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: 
 2315: - (void)viewsWindowDidResignKey
 2315: {
 2315:   if (!mGeckoChild)
 2462:     return;
 2315: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305: 
 4208:   [self sendFocusEvent:NS_DEACTIVATE];
 4208:   [self sendFocusEvent:NS_LOSTFOCUS];
 2315: }
 2315: 
 2315: 
 2677: // If the call to removeFromSuperview isn't delayed from nsChildView::
 2677: // TearDownView(), the NSView hierarchy might get changed during calls to
 2677: // [ChildView drawRect:], which leads to "beyond bounds" exceptions in
 2677: // NSCFArray.  For more info see bmo bug 373122.  Apple's docs claim that
 2315: // removeFromSuperviewWithoutNeedingDisplay "can be safely invoked during
 2315: // display" (whatever "display" means).  But it's _not_ true that it can be
 2677: // safely invoked during calls to [NSView drawRect:].  We use
 2677: // removeFromSuperview here because there's no longer any danger of being
 2677: // "invoked during display", and because doing do clears up bmo bug 384343.
 2315: - (void)delayedTearDown
 2315: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2677:   [self removeFromSuperview];
 2315:   [self release];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2315: }
 2315: 
 2315: 
    1: #pragma mark -
    1: 
    1: 
    1: // drag'n'drop stuff
    1: #define kDragServiceContractID "@mozilla.org/widget/dragservice;1"
    1: 
    1: 
    1: // This is a utility function used by NSView drag event methods
    1: // to send events. It contains all of the logic needed for Gecko
    1: // dragging to work. Returns YES if the event was handled, NO
    1: // if it wasn't.
    1: - (BOOL)doDragAction:(PRUint32)aMessage sender:(id)aSender
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 2958:   if (!mGeckoChild)
    1:     return NO;
    1: 
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView doDragAction: entered\n"));
 3545: 
 2958:   if (!mDragService) {
 2958:     CallGetService(kDragServiceContractID, &mDragService);
 2958:     NS_ASSERTION(mDragService, "Couldn't get a drag service - big problem!");
 2958:     if (!mDragService)
 2958:       return NO;
 2958:   }
 2958: 
    1:   if (aMessage == NS_DRAGDROP_ENTER)
    1:     mDragService->StartDragSession();
    1: 
    1:   nsCOMPtr<nsIDragSession> dragSession;
    1:   mDragService->GetCurrentSession(getter_AddRefs(dragSession));
    1:   if (dragSession) {
  482:     if (aMessage == NS_DRAGDROP_OVER) {
  482:       // fire the drag event at the source. Just ignore whether it was
  482:       // cancelled or not as there isn't actually a means to stop the drag
  482:       mDragService->FireDragEventAtSource(NS_DRAGDROP_DRAG);
    1:       dragSession->SetCanDrop(PR_FALSE);
  482:     }
    1:     else if (aMessage == NS_DRAGDROP_DROP) {
16085:       // We make the assumption that the dragOver handlers have correctly set
    1:       // the |canDrop| property of the Drag Session.
    1:       PRBool canDrop = PR_FALSE;
18445:       if (!NS_SUCCEEDED(dragSession->GetCanDrop(&canDrop)) || !canDrop) {
18445:         nsCOMPtr<nsIDOMNode> sourceNode;
18445:         dragSession->GetSourceNode(getter_AddRefs(sourceNode));
18445:         if (!sourceNode) {
18445:           mDragService->EndDragSession(PR_FALSE);
18445:         }
    1:         return NO;
    1:       }
18445:     }
    1:     
19704:     unsigned int modifierFlags =
19704:       nsCocoaUtils::GetCocoaEventModifierFlags([NSApp currentEvent]);
    1:     PRUint32 action = nsIDragService::DRAGDROP_ACTION_MOVE;
    1:     // force copy = option, alias = cmd-option, default is move
    1:     if (modifierFlags & NSAlternateKeyMask) {
    1:       if (modifierFlags & NSCommandKeyMask)
    1:         action = nsIDragService::DRAGDROP_ACTION_LINK;
    1:       else
    1:         action = nsIDragService::DRAGDROP_ACTION_COPY;
    1:     }
    1:     dragSession->SetDragAction(action);
    1:   }
    1: 
 6754:   // set up gecko event
18445:   nsDragEvent geckoEvent(PR_TRUE, aMessage, nsnull);
 6754:   [self convertGenericCocoaEvent:nil toGeckoEvent:&geckoEvent];
 6754: 
 6754:   // Use our own coordinates in the gecko event.
 6754:   // Convert event from gecko global coords to gecko view coords.
 6754:   NSPoint localPoint = [self convertPoint:[aSender draggingLocation] fromView:nil];
 6754:   geckoEvent.refPoint.x = static_cast<nscoord>(localPoint.x);
 6754:   geckoEvent.refPoint.y = static_cast<nscoord>(localPoint.y);
 6754: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 6754:   mGeckoChild->DispatchWindowEvent(geckoEvent);
10305:   if (!mGeckoChild)
10305:     return YES;
    1: 
18445:   if ((aMessage == NS_DRAGDROP_EXIT || aMessage == NS_DRAGDROP_DROP) &&
18445:       dragSession) {
    1:     nsCOMPtr<nsIDOMNode> sourceNode;
    1:     dragSession->GetSourceNode(getter_AddRefs(sourceNode));
    1:     if (!sourceNode) {
    1:       // We're leaving a window while doing a drag that was
    1:       // initiated in a different app. End the drag session,
    1:       // since we're done with it for now (until the user
    1:       // drags back into mozilla).
  482:       mDragService->EndDragSession(PR_FALSE);
    1:     }
    1:   }
    1: 
 6754:   return YES;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
    1: }
    1: 
    1: 
    1: - (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingEntered: entered\n"));
 3545:   
    1:   // there should never be a globalDragPboard when "draggingEntered:" is
    1:   // called, but just in case we'll take care of it here.
    1:   [globalDragPboard release];
    1: 
    1:   // Set the global drag pasteboard that will be used for this drag session.
    1:   // This will be set back to nil when the drag session ends (mouse exits
    1:   // the view or a drop happens within the view).
    1:   globalDragPboard = [[sender draggingPasteboard] retain];
    1: 
    1:   BOOL handled = [self doDragAction:NS_DRAGDROP_ENTER sender:sender];
    1: 
    1:   return handled ? NSDragOperationGeneric : NSDragOperationNone;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSDragOperationNone);
    1: }
    1: 
    1: 
    1: - (NSDragOperation)draggingUpdated:(id <NSDraggingInfo>)sender
    1: {
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingUpdated: entered\n"));
 3545: 
    1:   BOOL handled = [self doDragAction:NS_DRAGDROP_OVER sender:sender];
    1:   return handled ? NSDragOperationGeneric : NSDragOperationNone;
    1: }
    1: 
    1: 
    1: - (void)draggingExited:(id <NSDraggingInfo>)sender
    1: {
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingExited: entered\n"));
 3545: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
    1:   [self doDragAction:NS_DRAGDROP_EXIT sender:sender];
 6789:   NS_IF_RELEASE(mDragService);
 2958: }
 2958: 
 2958: 
 2958: - (BOOL)performDragOperation:(id <NSDraggingInfo>)sender
 2958: {
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
 6789:   BOOL handled = [self doDragAction:NS_DRAGDROP_DROP sender:sender];
 6789:   NS_IF_RELEASE(mDragService);
 6789:   return handled;
 2958: }
 2958: 
 2958: 
 2958: // NSDraggingSource
 2958: - (void)draggedImage:(NSImage *)anImage endedAt:(NSPoint)aPoint operation:(NSDragOperation)operation
 2958: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 3592:   gDraggedTransferables = nsnull;
 3592: 
 2958:   if (!mDragService) {
 2958:     CallGetService(kDragServiceContractID, &mDragService);
 2958:     NS_ASSERTION(mDragService, "Couldn't get a drag service - big problem!");
 2958:   }
 2958: 
 2958:   if (mDragService) {
 2958:     mDragService->EndDragSession(PR_TRUE);
 2958:     NS_RELEASE(mDragService);
 2958:   }
 2958: 
    1:   [globalDragPboard release];
    1:   globalDragPboard = nil;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
 2958: // NSDraggingSource
 2958: // this is just implemented so we comply with the NSDraggingSource informal protocol
 2958: - (unsigned int)draggingSourceOperationMaskForLocal:(BOOL)isLocal
    1: {
 2958:   return UINT_MAX;
    1: }
    1: 
 3545: // This method is a callback typically invoked in response to a drag ending on the desktop
 3545: // or a Findow folder window; the argument passed is a path to the drop location, to be used
 3545: // in constructing a complete pathname for the file(s) we want to create as a result of
 3545: // the drag.
 3545: - (NSArray *)namesOfPromisedFilesDroppedAtDestination:(id <NSDraggingInfo>)dropDestination
 3545: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 3545:   nsresult rv;
 3545: 
 3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView namesOfPromisedFilesDroppedAtDestination: entering callback for promised files\n"));
 3545: 
 3545:   nsCOMPtr<nsILocalFile> targFile;
 3545:   NS_NewLocalFile(EmptyString(), PR_TRUE, getter_AddRefs(targFile));
 3545:   nsCOMPtr<nsILocalFileMac> macLocalFile = do_QueryInterface(targFile);
 3545:   if (!macLocalFile) {
 3545:     NS_ERROR("No Mac local file");
 3545:     return nil;
 3545:   }
 3545: 
 3545:   if (!NS_SUCCEEDED(macLocalFile->InitWithCFURL((CFURLRef)dropDestination))) {
 3545:     NS_ERROR("failed InitWithCFURL");
 3545:     return nil;
 3545:   }
 3545: 
 3592:   if (!gDraggedTransferables)
 3592:     return nil;
 3545: 
 3545:   PRUint32 transferableCount;
 3592:   rv = gDraggedTransferables->Count(&transferableCount);
 3545:   if (NS_FAILED(rv))
 3545:     return nil;
 3545: 
 3545:   for (PRUint32 i = 0; i < transferableCount; i++) {
 3545:     nsCOMPtr<nsISupports> genericItem;
 3592:     gDraggedTransferables->GetElementAt(i, getter_AddRefs(genericItem));
 3545:     nsCOMPtr<nsITransferable> item(do_QueryInterface(genericItem));
 3545:     if (!item) {
 3545:       NS_ERROR("no transferable");
 3545:       return nil;
 3545:     }
 3545: 
 3545:     item->SetTransferData(kFilePromiseDirectoryMime, macLocalFile, sizeof(nsILocalFile*));
 3545:     
 3545:     // now request the kFilePromiseMime data, which will invoke the data provider
 3545:     // If successful, the returned data is a reference to the resulting file.
 3545:     nsCOMPtr<nsISupports> fileDataPrimitive;
 3545:     PRUint32 dataSize = 0;
 3545:     item->GetTransferData(kFilePromiseMime, getter_AddRefs(fileDataPrimitive), &dataSize);
 3545:   }
 3545:   
 3545:   NSPasteboard* generalPboard = [NSPasteboard pasteboardWithName:NSDragPboard];
 3545:   NSData* data = [generalPboard dataForType:@"application/x-moz-file-promise-dest-filename"];
 3545:   NSString* name = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
 3545:   NSArray* rslt = [NSArray arrayWithObject:name];
 3545: 
 3545:   [name release];
 3545: 
 3545:   return rslt;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 3545: }
    1: 
    1: #pragma mark -
    1: 
    1: 
    1: #ifdef ACCESSIBILITY
    1: 
    1: /* Every ChildView has a corresponding mozDocAccessible object that is doing all
    1:    the heavy lifting. The topmost ChildView corresponds to a mozRootAccessible
    1:    object.
    1: 
    1:    All ChildView needs to do is to route all accessibility calls (from the NSAccessibility APIs)
    1:    down to its object, pretending that they are the same.
    1: */
    1: - (id<mozAccessible>)accessible
    1: {
 2462:   if (!mGeckoChild)
 2462:     return nil;
 2462: 
    1:   id<mozAccessible> nativeAccessible = nil;
    1: 
14024:   nsAutoRetainCocoaObject kungFuDeathGrip(self);
10305:   nsCOMPtr<nsIWidget> kungFuDeathGrip2(mGeckoChild);
    1:   nsCOMPtr<nsIAccessible> accessible;
    1:   mGeckoChild->GetDocumentAccessible(getter_AddRefs(accessible));
10305:   if (!mGeckoChild)
10305:     return nil;
    1: 
    1:   if (accessible)
    1:     accessible->GetNativeInterface((void**)&nativeAccessible);
    1: 
    1: #ifdef DEBUG_hakan
    1:   NSAssert(![nativeAccessible isExpired], @"native acc is expired!!!");
    1: #endif
    1:   
    1:   return nativeAccessible;
    1: }
    1: 
    1: /* Implementation of formal mozAccessible formal protocol (enabling mozViews
    1:    to talk to mozAccessible objects in the accessibility module). */
    1: 
    1: - (BOOL)hasRepresentedView
    1: {
    1:   return YES;
    1: }
    1: 
    1: - (id)representedView
    1: {
    1:   return self;
    1: }
    1: 
    1: - (BOOL)isRoot
    1: {
    1:   return [[self accessible] isRoot];
    1: }
    1: 
    1: #ifdef DEBUG
    1: - (void)printHierarchy
    1: {
    1:   [[self accessible] printHierarchy];
    1: }
    1: #endif
    1: 
    1: #pragma mark -
    1: 
    1: // general
    1: 
    1: - (BOOL)accessibilityIsIgnored
    1: {
    1:   return [[self accessible] accessibilityIsIgnored];
    1: }
    1: 
    1: - (id)accessibilityHitTest:(NSPoint)point
    1: {
    1:   return [[self accessible] accessibilityHitTest:point];
    1: }
    1: 
    1: - (id)accessibilityFocusedUIElement
    1: {
    1:   return [[self accessible] accessibilityFocusedUIElement];
    1: }
    1: 
    1: // actions
    1: 
    1: - (NSArray*)accessibilityActionNames
    1: {
    1:   return [[self accessible] accessibilityActionNames];
    1: }
    1: 
    1: - (NSString*)accessibilityActionDescription:(NSString*)action
    1: {
    1:   return [[self accessible] accessibilityActionDescription:action];
    1: }
    1: 
    1: - (void)accessibilityPerformAction:(NSString*)action
    1: {
    1:   return [[self accessible] accessibilityPerformAction:action];
    1: }
    1: 
    1: // attributes
    1: 
    1: - (NSArray*)accessibilityAttributeNames
    1: {
    1:   return [[self accessible] accessibilityAttributeNames];
    1: }
    1: 
    1: - (BOOL)accessibilityIsAttributeSettable:(NSString*)attribute
    1: {
    1:   return [[self accessible] accessibilityIsAttributeSettable:attribute];
    1: }
    1: 
    1: - (id)accessibilityAttributeValue:(NSString*)attribute
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   id<mozAccessible> accessible = [self accessible];
    1:   
    1:   // if we're the root (topmost) accessible, we need to return our native AXParent as we
    1:   // traverse outside to the hierarchy of whoever embeds us. thus, fall back on NSView's
    1:   // default implementation for this attribute.
    1:   if ([attribute isEqualToString:NSAccessibilityParentAttribute] && [accessible isRoot]) {
    1:     id parentAccessible = [super accessibilityAttributeValue:attribute];
    1:     return parentAccessible;
    1:   }
    1: 
    1:   return [accessible accessibilityAttributeValue:attribute];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: #endif /* ACCESSIBILITY */
    1: 
    1: @end
  539: 
  539: 
  539: #pragma mark -
  539: 
  539: 
15931: void
15931: nsTSMManager::OnDestroyView(NSView<mozView>* aDestroyingView)
15931: {
15931:   if (aDestroyingView != sComposingView)
15931:     return;
15931:   if (IsComposing()) {
15931:     CancelIME(); // XXX Might CancelIME() fail because sComposingView is being destroyed?
15931:     EndComposing();
15931:   }
15931: }
15931: 
15931: 
  539: PRBool
  539: nsTSMManager::GetIMEOpenState()
  539: {
  539:   return GetScriptManagerVariable(smKeyScript) != smRoman ? PR_TRUE : PR_FALSE;
  539: }
  539: 
  539: 
  539: void
16548: nsTSMManager::InitTSMDocument(NSView<mozView>* aViewForCaret)
16548: {
16548:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
16548: 
16548:   sDocumentID = ::TSMGetActiveDocument();
16548:   if (!sDocumentID)
16548:     return;
16548: 
16548:   // We need to set the focused window level to TSMDocument. Then, the popup
16548:   // windows of IME (E.g., a candidate list window) will be over the focused
16548:   // view. See http://developer.apple.com/technotes/tn2005/tn2128.html#TNTAG1
16548:   NSInteger TSMLevel, windowLevel;
16548:   UInt32 size = sizeof(TSMLevel);
16548: 
16548:   OSStatus err =
16548:     ::TSMGetDocumentProperty(sDocumentID, kTSMDocumentWindowLevelPropertyTag,
16548:                              size, &size, &TSMLevel);
16548:   windowLevel = [[aViewForCaret window] level];
16548: 
16548:   // Chinese IMEs on 10.5 don't work fine if the level is NSNormalWindowLevel,
16548:   // then, we need to increment the value.
16548:   if (windowLevel == NSNormalWindowLevel)
16548:     windowLevel++;
16548: 
16548:   if (err == noErr && TSMLevel >= windowLevel)
16548:     return;
16548:   ::TSMSetDocumentProperty(sDocumentID, kTSMDocumentWindowLevelPropertyTag,
16548:                            sizeof(windowLevel), &windowLevel);
16548: 
16548:   // ATOK (Japanese IME) updates the window level at activating,
16548:   // we need to notify the change with this hack.
16548:   ::DeactivateTSMDocument(sDocumentID);
16548:   ::ActivateTSMDocument(sDocumentID);
16548: 
16548:   NS_OBJC_END_TRY_ABORT_BLOCK;
16548: }
16548: 
16548: 
16548: void
  539: nsTSMManager::StartComposing(NSView<mozView>* aComposingView)
  539: {
  539:   if (sComposingView && sComposingView != sComposingView)
  539:     CommitIME();
  539:   sComposingView = aComposingView;
16548:   NS_ASSERTION(::TSMGetActiveDocument() == sDocumentID,
16548:                "We didn't initialize the TSMDocument");
 4726: }
 4726: 
 4726: 
 4726: void
 4726: nsTSMManager::UpdateComposing(NSString* aComposingString)
 4726: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14421:   if (sComposingString)
14421:     [sComposingString release];
14421:   sComposingString = [aComposingString retain];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  539: }
  539: 
  539: 
  539: void
  539: nsTSMManager::EndComposing()
  539: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
  539:   sComposingView = nsnull;
 4726:   if (sComposingString) {
 4726:     [sComposingString release];
 4726:     sComposingString = nsnull;
 4726:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  539: }
  539: 
  539: 
  539: void
  539: nsTSMManager::EnableIME(PRBool aEnable)
  539: {
  539:   if (aEnable == sIsIMEEnabled)
  539:     return;
  539:   CommitIME();
  539:   sIsIMEEnabled = aEnable;
  539: }
  539: 
  539: 
  539: void
  539: nsTSMManager::SetIMEOpenState(PRBool aOpen)
  539: {
  539:   if (aOpen == GetIMEOpenState())
  539:     return;
  539:   CommitIME();
  539:   KeyScript(aOpen ? smKeySwapScript : smKeyRoman);
  539: }
  539: 
  539: 
  539: #define ENABLE_ROMAN_KYBDS_ONLY -23
  539: void
  539: nsTSMManager::SetRomanKeyboardsOnly(PRBool aRomanOnly)
  539: {
  539:   if (aRomanOnly == sIsRomanKeyboardsOnly)
  539:     return;
  539:   CommitIME();
  539:   KeyScript(aRomanOnly ? ENABLE_ROMAN_KYBDS_ONLY : smKeyEnableKybds);
  539:   sIsRomanKeyboardsOnly = aRomanOnly;
  539: }
  539: 
  539: 
  539: void
 4726: nsTSMManager::KillComposing()
 4726: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 4726:   // Force commit the current composition
 4726:   // XXX Don't use NSInputManager. Because it cannot control the non-forcused
 4726:   // input manager, therefore, on deactivating a window, it does not work fine.
 4726:   NS_ASSERTION(sDocumentID, "The TSMDocumentID is null");
 4726:   ::FixTSMDocument(sDocumentID);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 4726: }
 4726: 
 4726: 
 4726: void
  539: nsTSMManager::CommitIME()
  539: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 4726:   if (!IsComposing())
  539:     return;
 4726:   KillComposing();
 4726:   if (!IsComposing())
 4726:     return;
 4726:   // If the composing transaction is still there, KillComposing only kills the
 4726:   // composing in TSM. We also need to kill the our composing transaction too.
 4726:   NSAttributedString* str =
 4726:     [[NSAttributedString alloc] initWithString:sComposingString];
 4726:   [sComposingView insertText:str];
 4726:   [str release];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  539: }
  539: 
  539: 
  539: void
  539: nsTSMManager::CancelIME()
  539: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 4726:   if (!IsComposing())
  539:     return;
 4726:   // For canceling the current composing, we need to ignore the param of
 4726:   // insertText. But this code is ugly...
 4726:   sIgnoreCommit = PR_TRUE;
 4726:   KillComposing();
 4726:   sIgnoreCommit = PR_FALSE;
 4726:   if (!IsComposing())
 4726:     return;
 4726:   // If the composing transaction is still there, KillComposing only kills the
 4726:   // composing in TSM. We also need to kill the our composing transaction too.
 4726:   NSAttributedString* str = [[NSAttributedString alloc] initWithString:@""];
 4726:   [sComposingView insertText:str];
 4726:   [str release];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
11978: }
15585: 
15585: 
15585: // Target for text services events sent as the result of calls made to
15585: // TSMProcessRawKeyEvent() in [ChildView keyDown:] (above) when a plugin has
15585: // the focus.  The calls to TSMProcessRawKeyEvent() short-circuit Cocoa-based
15585: // IME (which would otherwise interfere with our efforts) and allow Carbon-
15585: // based IME to work in plugins (via the NPAPI).  This strategy doesn't cause
15585: // trouble for plugins that (like the Java Embedding Plugin) bypass the NPAPI
15585: // to get their keyboard events and do their own Cocoa-based IME.
15585: OSStatus PluginKeyEventsHandler(EventHandlerCallRef inHandlerRef,
15585:                                 EventRef inEvent, void *userData)
15585: {
15585:   id arp = [[NSAutoreleasePool alloc] init];
15585: 
15585:   TSMDocumentID activeDoc = ::TSMGetActiveDocument();
15585:   if (!activeDoc) {
15585:     [arp release];
15585:     return eventNotHandledErr;
15585:   }
15585: 
15585:   ChildView *target = nil;
15585:   OSStatus status = ::TSMGetDocumentProperty(activeDoc, kFocusedChildViewTSMDocPropertyTag,
15585:                                              sizeof(ChildView *), nil, &target);
15585:   if (status != noErr)
15585:     target = nil;
15585:   if (!target) {
15585:     [arp release];
15585:     return eventNotHandledErr;
15585:   }
15585: 
15585:   EventRef keyEvent = NULL;
15585:   status = ::GetEventParameter(inEvent, kEventParamTextInputSendKeyboardEvent,
15585:                                typeEventRef, NULL, sizeof(EventRef), NULL, &keyEvent);
15585:   if ((status != noErr) || !keyEvent) {
15585:     [arp release];
15585:     return eventNotHandledErr;
15585:   }
15585: 
15585:   [target processPluginKeyEvent:keyEvent];
15585: 
15585:   [arp release];
15585:   return noErr;
15585: }
15585: 
15585: static EventHandlerRef gPluginKeyEventsHandler = NULL;
15585: 
15585: // Called from nsAppShell::Init()
15585: void NS_InstallPluginKeyEventsHandler()
15585: {
15585:   if (gPluginKeyEventsHandler)
15585:     return;
15585:   static const EventTypeSpec sTSMEvents[] =
15585:     { { kEventClassTextInput, kEventTextInputUnicodeForKeyEvent } };
15585:   ::InstallEventHandler(::GetEventDispatcherTarget(),
15585:                         ::NewEventHandlerUPP(PluginKeyEventsHandler),
15585:                         GetEventTypeCount(sTSMEvents),
15585:                         sTSMEvents,
15585:                         NULL,
15585:                         &gPluginKeyEventsHandler);
15585: }
15585: 
15585: // Called from nsAppShell::Exit()
15585: void NS_RemovePluginKeyEventsHandler()
15585: {
15585:   if (!gPluginKeyEventsHandler)
15585:     return;
15585:   ::RemoveEventHandler(gPluginKeyEventsHandler);
15585:   gPluginKeyEventsHandler = NULL;
15585: }
