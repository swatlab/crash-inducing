    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
39425:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Implementation of selection: nsISelection,nsISelectionPrivate and nsFrameSelection
    1:  */
    1: 
82651: #include "mozilla/Attributes.h"
82651: 
    1: #include "nsCOMPtr.h"
    1: #include "nsWeakReference.h"
    1: #include "nsIFactory.h"
    1: #include "nsIEnumerator.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsISelectionListener.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsContentCID.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsRange.h"
    1: #include "nsCOMArray.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIDOMKeyEvent.h"
    1: #include "nsITableLayout.h"
    1: #include "nsITableCellLayout.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsTArray.h"
37057: #include "nsIScrollableFrame.h"
    1: 
    1: #include "nsISelectionListener.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsIDocumentEncoder.h"
    1: 
    1: // for IBMBIDI
    1: #include "nsFrameTraversal.h"
    1: #include "nsILineIterator.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIFrameTraversal.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsBidiPresUtils.h"
    1: static NS_DEFINE_CID(kFrameTraversalCID, NS_FRAMETRAVERSAL_CID);
30695: #include "nsTextFrame.h"
    1: 
    1: #include "nsIDOMText.h"
    1: 
    1: #include "nsContentUtils.h"
    1: #include "nsThreadUtils.h"
70840: #include "mozilla/Preferences.h"
    1: 
    1: //included for desired x position;
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
15969: #include "nsCaret.h"
    1: 
    1: 
    1: #include "nsITimer.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsFrameManager.h"
32820: #include "nsIScrollableFrame.h"
    1: // notifications
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDocument.h"
    1: 
    1: #include "nsISelectionController.h"//for the enums
    1: #include "nsAutoCopyListener.h"
    1: #include "nsCopySupport.h"
    1: #include "nsIClipboard.h"
    1: 
    1: #ifdef IBMBIDI
    1: #include "nsIBidiKeyboard.h"
    1: #endif // IBMBIDI
    1: 
56998: #include "nsDOMError.h"
74131: #include "mozilla/dom/Element.h"
56998: 
70840: using namespace mozilla;
70840: 
    1: //#define DEBUG_TABLE 1
    1: 
    1: static NS_DEFINE_IID(kCContentIteratorCID, NS_CONTENTITERATOR_CID);
    1: static NS_DEFINE_IID(kCSubtreeIteratorCID, NS_SUBTREEITERATOR_CID);
    1: 
    1: //PROTOTYPES
    1: class nsSelectionIterator;
    1: class nsFrameSelection;
    1: class nsAutoScrollTimer;
    1: 
79445: static bool IsValidSelectionPoint(nsFrameSelection *aFrameSel, nsINode *aNode);
    1: 
26995: static nsIAtom *GetTag(nsINode *aNode);
26995: // returns the parent
26995: static nsINode* ParentOffset(nsINode *aNode, PRInt32 *aChildOffset);
26995: static nsINode* GetCellParent(nsINode *aDomNode);
    1: 
    1: #ifdef PRINT_RANGE
26998: static void printRange(nsIRange *aDomRange);
    1: #define DEBUG_OUT_RANGE(x)  printRange(x)
    1: #else
    1: #define DEBUG_OUT_RANGE(x)  
    1: #endif //MOZ_DEBUG
    1: 
74711: 
    1: 
    1: //#define DEBUG_SELECTION // uncomment for printf describing every collapse and extend.
    1: //#define DEBUG_NAVIGATION
    1: 
    1: 
    1: //#define DEBUG_TABLE_SELECTION 1
    1: 
    1: struct CachedOffsetForFrame {
    1:   CachedOffsetForFrame()
    1:   : mCachedFrameOffset(0, 0) // nsPoint ctor
    1:   , mLastCaretFrame(nsnull)
    1:   , mLastContentOffset(0)
80486:   , mCanCacheFrameOffset(false)
    1:   {}
    1: 
    1:   nsPoint      mCachedFrameOffset;      // cached frame offset
    1:   nsIFrame*    mLastCaretFrame;         // store the frame the caret was last drawn in.
    1:   PRInt32      mLastContentOffset;      // store last content offset
79445:   bool mCanCacheFrameOffset;    // cached frame offset is valid?
    1: };
    1: 
    1: struct RangeData
    1: {
28161:   RangeData(nsIRange* aRange) :
28161:     mRange(aRange) {}
    1: 
26992:   nsCOMPtr<nsIRange> mRange;
27654:   nsTextRangeStyle mTextRangeStyle;
    1: };
    1: 
28161: static RangeData sEmptyData(nsnull);
26995: 
 8295: // Note, the ownership of nsTypedSelection depends on which way the object is
 8295: // created. When nsFrameSelection has created nsTypedSelection,
 8295: // addreffing/releasing nsTypedSelection object is aggregated to
 8295: // nsFrameSelection. Otherwise normal addref/release is used.
 8295: // This ensures that nsFrameSelection is never deleted before its
 8295: // nsTypedSelections.
 8295: 
75112: class nsTypedSelection : public nsISelectionPrivate,
    1:                          public nsSupportsWeakReference
    1: {
    1: public:
    1:   nsTypedSelection();
    1:   nsTypedSelection(nsFrameSelection *aList);
    1:   virtual ~nsTypedSelection();
    1:   
23902:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
75112:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsTypedSelection, nsISelectionPrivate)
    1:   NS_DECL_NSISELECTION
    1:   NS_DECL_NSISELECTIONPRIVATE
    1: 
    1:   // utility methods for scrolling the selection into view
    1:   nsresult      GetPresContext(nsPresContext **aPresContext);
    1:   nsresult      GetPresShell(nsIPresShell **aPresShell);
58206:   // Returns a rect containing the selection region, and frame that that
58206:   // position is relative to. For SELECTION_ANCHOR_REGION or
58206:   // SELECTION_FOCUS_REGION the rect is a zero-width rectangle. For
58206:   // SELECTION_WHOLE_SELECTION the rect contains both the anchor and focus
58206:   // region rects.
37078:   nsIFrame*     GetSelectionAnchorGeometry(SelectionRegion aRegion, nsRect *aRect);
58206:   // Returns the position of the region (SELECTION_ANCHOR_REGION or
58206:   // SELECTION_FOCUS_REGION only), and frame that that position is relative to.
58206:   // The 'position' is a zero-width rectangle.
58206:   nsIFrame*     GetSelectionEndPointGeometry(SelectionRegion aRegion, nsRect *aRect);
    1: 
79445:   nsresult      PostScrollSelectionIntoViewEvent(SelectionRegion aRegion, bool aFirstAncestorOnly);
56443:   enum {
56443:     SCROLL_SYNCHRONOUS = 1<<1,
56443:     SCROLL_FIRST_ANCESTOR_ONLY = 1<<2,
56446:     SCROLL_DO_FLUSH = 1<<3
56443:   };
 4886:   // aDoFlush only matters if aIsSynchronous is true.  If not, we'll just flush
 4886:   // when the scroll event fires so we make sure to scroll to the right place.
56443:   nsresult      ScrollIntoView(SelectionRegion aRegion,
 5245:                                PRInt16 aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE,
56442:                                PRInt16 aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE,
56443:                                PRInt32 aFlags = 0);
28161:   nsresult      SubtractRange(RangeData* aRange, nsIRange* aSubtract,
28161:                               nsTArray<RangeData>* aOutput);
26992:   nsresult      AddItem(nsIRange *aRange, PRInt32* aOutIndex = nsnull);
26992:   nsresult      RemoveItem(nsIRange *aRange);
20590:   nsresult      RemoveCollapsedRanges();
    1:   nsresult      Clear(nsPresContext* aPresContext);
26992:   nsresult      Collapse(nsINode* aParentNode, PRInt32 aOffset);
26992:   nsresult      Extend(nsINode* aParentNode, PRInt32 aOffset);
26995:   nsresult      AddRange(nsIRange* aRange);
27584:   // The nsIRange version of RemoveRange assumes the caller is holding
27584:   // a strong reference to aRange.
26996:   nsresult      RemoveRange(nsIRange* aRange);
26996:   nsIRange*     GetRangeAt(PRInt32 aIndex);
26996:   nsresult      GetTableSelectionType(nsIRange* aRange,
26996:                                       PRInt32* aTableSelectionType);
    1: 
    1:   // methods for convenience. Note, these don't addref
26992:   nsINode*     GetAnchorNode();
26992:   PRInt32      GetAnchorOffset();
    1: 
26992:   nsINode*     GetFocusNode();
26992:   PRInt32      GetFocusOffset();
    1: 
26993:   // Get the anchor-to-focus range if we don't care which end is
26993:   // anchor and which end is focus.
26993:   const nsIRange* GetAnchorFocusRange() const {
26993:     return mAnchorFocusRange;
26993:   }
26993: 
    1:   nsDirection  GetDirection(){return mDirection;}
    1:   void         SetDirection(nsDirection aDir){mDirection = aDir;}
26992:   nsresult     CopyRangeToAnchorFocus(nsIRange *aRange);
26993:   void         ReplaceAnchorFocusRange(nsIRange *aRange);
    1: 
79445:   //  NS_IMETHOD   GetPrimaryFrameForRangeEndpoint(nsIDOMNode *aNode, PRInt32 aOffset, bool aIsEndNode, nsIFrame **aResultFrame);
    1:   NS_IMETHOD   GetPrimaryFrameForAnchorNode(nsIFrame **aResultFrame);
79445:   NS_IMETHOD   GetPrimaryFrameForFocusNode(nsIFrame **aResultFrame, PRInt32 *aOffset, bool aVisual);
    1:   NS_IMETHOD   LookUpSelection(nsIContent *aContent, PRInt32 aContentOffset, PRInt32 aContentLength,
79445:                              SelectionDetails **aReturnDetails, SelectionType aType, bool aSlowCheck);
    1:   NS_IMETHOD   Repaint(nsPresContext* aPresContext);
    1: 
37078:   // Note: StartAutoScrollTimer might destroy arbitrary frames etc.
37078:   nsresult     StartAutoScrollTimer(nsIFrame *aFrame,
    1:                                     nsPoint& aPoint,
    1:                                     PRUint32 aDelay);
    1: 
    1:   nsresult     StopAutoScrollTimer();
    1: 
    1: private:
    1:   friend class nsAutoScrollTimer;
    1: 
37078:   // Note: DoAutoScroll might destroy arbitrary frames etc.
37078:   nsresult DoAutoScroll(nsIFrame *aFrame, nsPoint& aPoint);
    1: 
    1: public:
    1:   SelectionType GetType(){return mType;}
    1:   void          SetType(SelectionType aType){mType = aType;}
    1: 
    1:   nsresult     NotifySelectionListeners();
    1: 
    1: private:
    1:   friend class nsSelectionIterator;
    1: 
    1:   class ScrollSelectionIntoViewEvent;
    1:   friend class ScrollSelectionIntoViewEvent;
    1: 
    1:   class ScrollSelectionIntoViewEvent : public nsRunnable {
    1:   public:
    1:     NS_DECL_NSIRUNNABLE
    1:     ScrollSelectionIntoViewEvent(nsTypedSelection *aTypedSelection,
56442:                                  SelectionRegion aRegion,
79445:                                  bool aFirstAncestorOnly)
    1:       : mTypedSelection(aTypedSelection),
56442:         mRegion(aRegion),
56442:         mFirstAncestorOnly(aFirstAncestorOnly) {
    1:       NS_ASSERTION(aTypedSelection, "null parameter");
    1:     }
    1:     void Revoke() { mTypedSelection = nsnull; }
    1:   private:
    1:     nsTypedSelection *mTypedSelection;
    1:     SelectionRegion   mRegion;
79445:     bool              mFirstAncestorOnly;
    1:   };
    1: 
26995:   void setAnchorFocusRange(PRInt32 aIndex); // pass in index into mRanges;
26995:                                             // negative value clears
26995:                                             // mAnchorFocusRange
30695:   nsresult     SelectAllFramesForContent(nsIContentIterator *aInnerIter,
30695:                                nsIContent *aContent,
79445:                                bool aSelected);
79445:   nsresult     selectFrames(nsPresContext* aPresContext, nsIRange *aRange, bool aSelect);
26992:   nsresult     getTableCellLocationFromRange(nsIRange *aRange, PRInt32 *aSelectionType, PRInt32 *aRow, PRInt32 *aCol);
79445:   nsresult     addTableCellRange(nsIRange *aRange, bool *aDidAddRange, PRInt32 *aOutIndex);
    1: 
33462:   nsresult FindInsertionPoint(
28161:       nsTArray<RangeData>* aElementArray,
26992:       nsINode* aPointNode, PRInt32 aPointOffset,
33462:       nsresult (*aComparator)(nsINode*,PRInt32,nsIRange*,PRInt32*),
33462:       PRInt32* aPoint);
79445:   bool EqualsRangeAtPoint(nsINode* aBeginNode, PRInt32 aBeginOffset,
26992:                             nsINode* aEndNode, PRInt32 aEndOffset,
28161:                             PRInt32 aRangeIndex);
26992:   nsresult GetRangesForIntervalCOMArray(nsINode* aBeginNode, PRInt32 aBeginOffset,
26992:                                         nsINode* aEndNode, PRInt32 aEndOffset,
79445:                                         bool aAllowAdjacent,
26992:                                         nsCOMArray<nsIRange>* aRanges);
28161:   void GetIndicesForInterval(nsINode* aBeginNode, PRInt32 aBeginOffset,
28161:                              nsINode* aEndNode, PRInt32 aEndOffset,
79445:                              bool aAllowAdjacent,
28161:                              PRInt32 *aStartIndex, PRInt32 *aEndIndex);
27654:   RangeData* FindRangeData(nsIDOMRange* aRange);
    1: 
28161:   // These are the ranges inside this selection. They are kept sorted in order
28161:   // of DOM start position.
28161:   //
28161:   // This data structure is sorted by the range beginnings. As the ranges are
28161:   // disjoint, it is also implicitly sorted by the range endings. This allows
28161:   // us to perform binary searches when searching for existence of a range,
28161:   // giving us O(log n) search time.
28161:   //
28161:   // Inserting a new range requires finding the overlapping interval, requiring
28161:   // two binary searches plus up to an additional 6 DOM comparisons. If this
28161:   // proves to be a performance concern, then an interval tree may be a
28161:   // possible solution, allowing the calculation of the overlap interval in
28161:   // O(log n) time, though this would require rebalancing and other overhead.
12258:   nsTArray<RangeData> mRanges;
28161: 
26992:   nsCOMPtr<nsIRange> mAnchorFocusRange;
23902:   nsRefPtr<nsFrameSelection> mFrameSelection;
12258:   nsWeakPtr mPresShellWeak;
12258:   nsRefPtr<nsAutoScrollTimer> mAutoScrollTimer;
    1:   nsCOMArray<nsISelectionListener> mSelectionListeners;
    1:   nsRevocableEventPtr<ScrollSelectionIntoViewEvent> mScrollEvent;
    1:   CachedOffsetForFrame *mCachedOffsetForFrame;
12258:   nsDirection mDirection;
12258:   SelectionType mType;
    1: };
    1: 
    1: // Stack-class to turn on/off selection batching for table selection
82651: class NS_STACK_CLASS nsSelectionBatcher MOZ_FINAL
    1: {
    1: private:
    1:   nsCOMPtr<nsISelectionPrivate> mSelection;
    1: public:
    1:   nsSelectionBatcher(nsISelectionPrivate *aSelection) : mSelection(aSelection)
    1:   {
    1:     if (mSelection) mSelection->StartBatchChanges();
    1:   }
15599:   ~nsSelectionBatcher() 
    1:   { 
    1:     if (mSelection) mSelection->EndBatchChanges();
    1:   }
    1: };
    1: 
    1: class nsSelectionIterator : public nsIBidirectionalEnumerator
    1: {
    1: public:
    1: /*BEGIN nsIEnumerator interfaces
    1: see the nsIEnumerator for more details*/
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_DECL_NSIENUMERATOR
    1: 
    1:   NS_DECL_NSIBIDIRECTIONALENUMERATOR
    1: 
    1: /*END nsIEnumerator interfaces*/
    1: /*BEGIN Helper Methods*/
26995:   nsIRange* CurrentItem();
    1: /*END Helper Methods*/
    1: private:
    1:   friend class nsTypedSelection;
    1: 
    1:   //lame lame lame if delete from document goes away then get rid of this unless its debug
    1:   friend class nsFrameSelection;
    1: 
    1:   nsSelectionIterator(nsTypedSelection *);
    1:   virtual ~nsSelectionIterator();
    1:   PRInt32     mIndex;
    1:   nsTypedSelection *mDomSelection;
    1:   SelectionType mType;
    1: };
    1: 
    1: class nsAutoScrollTimer : public nsITimerCallback
    1: {
    1: public:
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   nsAutoScrollTimer()
    1:   : mFrameSelection(0), mSelection(0), mPresContext(0), mPoint(0,0), mDelay(30)
    1:   {
    1:   }
    1: 
    1:   virtual ~nsAutoScrollTimer()
    1:   {
    1:    if (mTimer)
    1:        mTimer->Cancel();
    1:   }
    1: 
37078:   // aPoint is relative to aPresContext's root frame
74711:   nsresult Start(nsPresContext *aPresContext, nsPoint &aPoint)
    1:   {
    1:     mPoint = aPoint;
    1: 
    1:     // Store the presentation context. The timer will be
    1:     // stopped by the selection if the prescontext is destroyed.
    1:     mPresContext = aPresContext;
    1: 
74711:     mContent = nsIPresShell::GetCapturingContent();
    1: 
    1:     if (!mTimer)
    1:     {
    1:       nsresult result;
    1:       mTimer = do_CreateInstance("@mozilla.org/timer;1", &result);
    1: 
    1:       if (NS_FAILED(result))
    1:         return result;
    1:     }
    1: 
    1:     return mTimer->InitWithCallback(this, mDelay, nsITimer::TYPE_ONE_SHOT);
    1:   }
    1: 
    1:   nsresult Stop()
    1:   {
    1:     if (mTimer)
    1:     {
    1:       mTimer->Cancel();
    1:       mTimer = 0;
    1:     }
    1: 
    1:     mContent = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult Init(nsFrameSelection *aFrameSelection, nsTypedSelection *aSelection)
    1:   {
    1:     mFrameSelection = aFrameSelection;
    1:     mSelection = aSelection;
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult SetDelay(PRUint32 aDelay)
    1:   {
    1:     mDelay = aDelay;
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_IMETHOD Notify(nsITimer *timer)
    1:   {
    1:     if (mSelection && mPresContext)
    1:     {
36801:       nsWeakFrame frame =
36801:         mContent ? mPresContext->GetPrimaryFrameFor(mContent) : nsnull;
56428:       if (!frame)
56428:         return NS_OK;
    1:       mContent = nsnull;
    1: 
56428:       nsPoint pt = mPoint -
56428:         frame->GetOffsetTo(mPresContext->PresShell()->FrameManager()->GetRootFrame());
56428:       mFrameSelection->HandleDrag(frame, pt);
32820:       if (!frame.IsAlive())
32820:         return NS_OK;
32820: 
47902:       NS_ASSERTION(frame->PresContext() == mPresContext, "document mismatch?");
37078:       mSelection->DoAutoScroll(frame, pt);
    1:     }
    1:     return NS_OK;
    1:   }
    1: private:
    1:   nsFrameSelection *mFrameSelection;
    1:   nsTypedSelection *mSelection;
    1:   nsPresContext *mPresContext;
37078:   // relative to mPresContext's root frame
    1:   nsPoint mPoint;
    1:   nsCOMPtr<nsITimer> mTimer;
    1:   nsCOMPtr<nsIContent> mContent;
    1:   PRUint32 mDelay;
    1: };
    1: 
 4345: NS_IMPL_ISUPPORTS1(nsAutoScrollTimer, nsITimerCallback)
    1: 
    1: nsresult NS_NewDomSelection(nsISelection **aDomSelection)
    1: {
    1:   nsTypedSelection *rlist = new nsTypedSelection;
    1:   *aDomSelection = (nsISelection *)rlist;
    1:   NS_ADDREF(rlist);
    1:   return NS_OK;
    1: }
    1: 
    1: static PRInt8
    1: GetIndexFromSelectionType(SelectionType aType)
    1: {
    1:     switch (aType)
    1:     {
    1:     case nsISelectionController::SELECTION_NORMAL: return 0; break;
    1:     case nsISelectionController::SELECTION_SPELLCHECK: return 1; break;
    1:     case nsISelectionController::SELECTION_IME_RAWINPUT: return 2; break;
    1:     case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT: return 3; break;
    1:     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT: return 4; break;
    1:     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT: return 5; break;
    1:     case nsISelectionController::SELECTION_ACCESSIBILITY: return 6; break;
16313:     case nsISelectionController::SELECTION_FIND: return 7; break;
69254:     case nsISelectionController::SELECTION_URLSECONDARY: return 8; break;
16313:     default:
16313:       return -1; break;
    1:     }
    1:     /* NOTREACHED */
    1:     return 0;
    1: }
    1: 
    1: static SelectionType 
    1: GetSelectionTypeFromIndex(PRInt8 aIndex)
    1: {
    1:   switch (aIndex)
    1:   {
    1:     case 0: return nsISelectionController::SELECTION_NORMAL; break;
    1:     case 1: return nsISelectionController::SELECTION_SPELLCHECK; break;
    1:     case 2: return nsISelectionController::SELECTION_IME_RAWINPUT; break;
    1:     case 3: return nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT; break;
    1:     case 4: return nsISelectionController::SELECTION_IME_CONVERTEDTEXT; break;
    1:     case 5: return nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT; break;
    1:     case 6: return nsISelectionController::SELECTION_ACCESSIBILITY; break;
16313:     case 7: return nsISelectionController::SELECTION_FIND; break;
69254:     case 8: return nsISelectionController::SELECTION_URLSECONDARY; break;
    1:     default:
    1:       return nsISelectionController::SELECTION_NORMAL; break;
    1:   }
    1:   /* NOTREACHED */
    1:   return 0;
    1: }
    1: 
    1: /*
    1: The limiter is used specifically for the text areas and textfields
    1: In that case it is the DIV tag that is anonymously created for the text
    1: areas/fields.  Text nodes and BR nodes fall beneath it.  In the case of a 
    1: BR node the limiter will be the parent and the offset will point before or
    1: after the BR node.  In the case of the text node the parent content is 
    1: the text node itself and the offset will be the exact character position.
    1: The offset is not important to check for validity.  Simply look at the 
    1: passed in content.  If it equals the limiter then the selection point is valid.
    1: If its parent it the limiter then the point is also valid.  In the case of 
    1: NO limiter all points are valid since you are in a topmost iframe. (browser
    1: or composer)
    1: */
79445: bool         
26992: IsValidSelectionPoint(nsFrameSelection *aFrameSel, nsINode *aNode)
26992: {
26992:   if (!aFrameSel || !aNode)
80486:     return false;
26992: 
 2896:   nsIContent *limiter = aFrameSel->GetLimiter();
26992:   if (limiter && limiter != aNode && limiter != aNode->GetParent()) {
26992:     //if newfocus == the limiter. that's ok. but if not there and not parent bad
80486:     return false; //not in the right content. tLimiter said so
    1:   }
26992: 
 2896:   limiter = aFrameSel->GetAncestorLimiter();
26992:   return !limiter || nsContentUtils::ContentIsDescendantOf(aNode, limiter);
    1: }
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsSelectionIterator)
    1: NS_IMPL_RELEASE(nsSelectionIterator)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsSelectionIterator)
    1:   NS_INTERFACE_MAP_ENTRY(nsIEnumerator)
    1:   NS_INTERFACE_MAP_ENTRY(nsIBidirectionalEnumerator)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mDomSelection)
    1: 
    1: 
    1: ///////////BEGIN nsSelectionIterator methods
    1: 
    1: nsSelectionIterator::nsSelectionIterator(nsTypedSelection *aList)
    1: :mIndex(0)
    1: {
    1:   if (!aList)
    1:   {
    1:     NS_NOTREACHED("nsFrameSelection");
    1:     return;
    1:   }
    1:   mDomSelection = aList;
    1: }
    1: 
    1: 
    1: 
    1: nsSelectionIterator::~nsSelectionIterator()
    1: {
    1: }
    1: 
    1: 
    1: 
    1: ////////////END nsSelectionIterator methods
    1: 
    1: ////////////BEGIN nsSelectionIterator methods
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSelectionIterator::Next()
    1: {
    1:   mIndex++;
    1:   PRInt32 cnt = mDomSelection->mRanges.Length();
    1:   if (mIndex < cnt)
    1:     return NS_OK;
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSelectionIterator::Prev()
    1: {
    1:   mIndex--;
    1:   if (mIndex >= 0 )
    1:     return NS_OK;
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSelectionIterator::First()
    1: {
    1:   if (!mDomSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1:   mIndex = 0;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSelectionIterator::Last()
    1: {
    1:   if (!mDomSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1:   mIndex = mDomSelection->mRanges.Length() - 1;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsSelectionIterator::CurrentItem(nsISupports **aItem)
    1: {
26995:   *aItem = CurrentItem();
26995:   if (!*aItem) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
26995:   NS_ADDREF(*aItem);
    1:   return NS_OK;
    1: }
    1: 
26995: nsIRange*
26995: nsSelectionIterator::CurrentItem()
26995: {
26995:   return mDomSelection->mRanges.SafeElementAt(mIndex, sEmptyData).mRange;
26995: }
26995: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSelectionIterator::IsDone()
    1: {
    1:   PRInt32 cnt = mDomSelection->mRanges.Length();
    1:   if (mIndex >= 0 && mIndex < cnt) {
    1:     return NS_ENUMERATOR_FALSE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ////////////END nsSelectionIterator methods
    1: 
    1: 
    1: ////////////BEGIN nsFrameSelection methods
    1: 
    1: nsFrameSelection::nsFrameSelection()
80486:   : mDelayedMouseEvent(false, 0, nsnull, nsMouseEvent::eReal)
    1: {
    1:   PRInt32 i;
    1:   for (i = 0;i<nsISelectionController::NUM_SELECTIONTYPES;i++){
    1:     mDomSelections[i] = new nsTypedSelection(this);
    1:     mDomSelections[i]->SetType(GetSelectionTypeFromIndex(i));
    1:   }
    1:   mBatching = 0;
80486:   mChangesDuringBatching = false;
80486:   mNotifyFrames = true;
    1:   mLimiter = nsnull; //no default limiter.
 2896:   mAncestorLimiter = nsnull;
    1:   
80486:   mMouseDoubleDownState = false;
    1:   
    1:   mHint = HINTLEFT;
    1: #ifdef IBMBIDI
    1:   mCaretBidiLevel = BIDI_LEVEL_UNDEFINED;
    1: #endif
80486:   mDragSelectingCells = false;
    1:   mSelectingTableCellMode = 0;
    1:   mSelectedCellIndex = 0;
    1: 
    1:   // Check to see if the autocopy pref is enabled
    1:   //   and add the autocopy listener if it is
70840:   if (Preferences::GetBool("clipboard.autocopy")) {
    1:     nsAutoCopyListener *autoCopy = nsAutoCopyListener::GetInstance();
    1: 
    1:     if (autoCopy) {
    1:       PRInt8 index =
    1:         GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
    1:       if (mDomSelections[index]) {
    1:         autoCopy->Listen(mDomSelections[index]);
    1:       }
    1:     }
    1:   }
    1: 
    1:   mDisplaySelection = nsISelectionController::SELECTION_OFF;
    1: 
80486:   mDelayedMouseEventValid = false;
    1:   mSelectionChangeReason = nsISelectionListener::NO_REASON;
    1: }
    1: 
    1: 
23902: NS_IMPL_CYCLE_COLLECTION_CLASS(nsFrameSelection)
70355: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsFrameSelection)
    1:   PRInt32 i;
23902:   for (i = 0; i < nsISelectionController::NUM_SELECTIONTYPES; ++i) {
23902:     tmp->mDomSelections[i] = nsnull;
23902:   }
23902: 
23902:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCellParent)
23902:   tmp->mSelectingTableCellMode = 0;
80486:   tmp->mDragSelectingCells = false;
23902:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mStartSelectedCell)
23902:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mEndSelectedCell)
23902:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mAppendStartSelectedCell)
23902:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mUnselectCellOnMouseUp)
23902:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mMaintainRange)
23902: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
70355: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsFrameSelection)
23902:   PRInt32 i;
23902:   for (i = 0; i < nsISelectionController::NUM_SELECTIONTYPES; ++i) {
23902:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mDomSelections[i],
23902:                                                          nsISelection)
23902:   }
23902: 
23902:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCellParent)
23902:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mStartSelectedCell)
23902:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEndSelectedCell)
23902:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAppendStartSelectedCell)
23902:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mUnselectCellOnMouseUp)
23902:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mMaintainRange)
23902: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
23902: 
70355: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsFrameSelection)
70355: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsFrameSelection)
70355: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsFrameSelection)
70355:   NS_INTERFACE_MAP_ENTRY(nsISupports)
70355: NS_INTERFACE_MAP_END
70355: 
    1: 
    1: nsresult
    1: nsFrameSelection::FetchDesiredX(nscoord &aDesiredX) //the x position requested by the Key Handling for up down
    1: {
    1:   if (!mShell)
    1:   {
43756:     NS_ERROR("fetch desired X failed");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   if (mDesiredXSet)
    1:   {
    1:     aDesiredX = mDesiredX;
    1:     return NS_OK;
    1:   }
    1: 
40045:   nsRefPtr<nsCaret> caret = mShell->GetCaret();
    1:   if (!caret)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
40045:   nsresult result = caret->SetCaretDOMSelection(mDomSelections[index]);
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
39425:   nsRect coord;
39425:   nsIFrame* caretFrame = caret->GetGeometry(mDomSelections[index], &coord);
39425:   if (!caretFrame)
39425:     return NS_ERROR_FAILURE;
39425:   nsPoint viewOffset(0, 0);
39425:   nsIView* view = nsnull;
39425:   caretFrame->GetOffsetFromView(viewOffset, &view);
39425:   if (view)
39425:     coord.x += viewOffset.x;
    1: 
    1:   aDesiredX = coord.x;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: void
    1: nsFrameSelection::InvalidateDesiredX() //do not listen to mDesiredX you must get another.
    1: {
80486:   mDesiredXSet = false;
    1: }
    1: 
    1: 
    1: 
    1: void
    1: nsFrameSelection::SetDesiredX(nscoord aX) //set the mDesiredX
    1: {
    1:   mDesiredX = aX;
80486:   mDesiredXSet = true;
    1: }
    1: 
    1: nsresult
    1: nsFrameSelection::ConstrainFrameAndPointToAnchorSubtree(nsIFrame  *aFrame,
    1:                                                         nsPoint&   aPoint,
    1:                                                         nsIFrame **aRetFrame,
    1:                                                         nsPoint&   aRetPoint)
    1: {
    1:   //
    1:   // The whole point of this method is to return a frame and point that
    1:   // that lie within the same valid subtree as the anchor node's frame,
    1:   // for use with the method GetContentAndOffsetsFromPoint().
    1:   //
    1:   // A valid subtree is defined to be one where all the content nodes in
    1:   // the tree have a valid parent-child relationship.
    1:   //
    1:   // If the anchor frame and aFrame are in the same subtree, aFrame will
    1:   // be returned in aRetFrame. If they are in different subtrees, we
    1:   // return the frame for the root of the subtree.
    1:   //
    1: 
    1:   if (!aFrame || !aRetFrame)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aRetFrame = aFrame;
    1:   aRetPoint  = aPoint;
    1: 
    1:   //
    1:   // Get the frame and content for the selection's anchor point!
    1:   //
    1: 
    1:   nsresult result;
    1:   nsCOMPtr<nsIDOMNode> anchorNode;
    1:   PRInt32 anchorOffset = 0;
    1: 
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
    1:   if (!mDomSelections[index])
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   result = mDomSelections[index]->GetAnchorNode(getter_AddRefs(anchorNode));
    1: 
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   if (!anchorNode)
    1:     return NS_OK;
    1: 
    1:   result = mDomSelections[index]->GetAnchorOffset(&anchorOffset);
    1: 
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   nsCOMPtr<nsIContent> anchorContent = do_QueryInterface(anchorNode);
    1: 
    1:   if (!anchorContent)
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   //
    1:   // Now find the root of the subtree containing the anchor's content.
    1:   //
    1: 
35608:   NS_ENSURE_STATE(mShell);
35608:   nsIContent* anchorRoot = anchorContent->GetSelectionRootContent(mShell);
37336:   NS_ENSURE_TRUE(anchorRoot, NS_ERROR_UNEXPECTED);
    1: 
    1:   //
    1:   // Now find the root of the subtree containing aFrame's content.
    1:   //
    1: 
    1:   nsIContent* content = aFrame->GetContent();
    1: 
    1:   if (content)
    1:   {
35608:     nsIContent* contentRoot = content->GetSelectionRootContent(mShell);
37336:     NS_ENSURE_TRUE(contentRoot, NS_ERROR_UNEXPECTED);
    1: 
    1:     if (anchorRoot == contentRoot)
    1:     {
74711:       // If the aFrame's content isn't the capturing content, it should be
74711:       // a descendant.  At this time, we can return simply.
74711:       nsIContent* capturedContent = nsIPresShell::GetCapturingContent();
74711:       if (capturedContent != content)
74711:       {
35608:         return NS_OK;
35608:       }
74711: 
74711:       // Find the frame under the mouse cursor with the root frame.
74711:       // At this time, don't use the anchor's frame because it may not have
74711:       // fixed positioned frames.
74711:       nsIFrame* rootFrame = mShell->FrameManager()->GetRootFrame();
74711:       nsPoint ptInRoot = aPoint + aFrame->GetOffsetTo(rootFrame);
74711:       nsIFrame* cursorFrame =
74711:         nsLayoutUtils::GetFrameForPoint(rootFrame, ptInRoot);
74711: 
74711:       // If the mouse cursor in on a frame which is descendant of same
74711:       // selection root, we can expand the selection to the frame.
74711:       if (cursorFrame && cursorFrame->PresContext()->PresShell() == mShell)
74711:       {
74711:         nsIContent* cursorContent = cursorFrame->GetContent();
74711:         NS_ENSURE_TRUE(cursorContent, NS_ERROR_FAILURE);
74711:         nsIContent* cursorContentRoot =
74711:           cursorContent->GetSelectionRootContent(mShell);
74711:         NS_ENSURE_TRUE(cursorContentRoot, NS_ERROR_UNEXPECTED);
74711:         if (cursorContentRoot == anchorRoot)
74711:         {
74711:           *aRetFrame = cursorFrame;
74711:           aRetPoint = aPoint + aFrame->GetOffsetTo(cursorFrame);
74711:           return NS_OK;
74711:         }
74711:       }
74711:       // Otherwise, e.g., the cursor isn't on any frames (e.g., the mouse
74711:       // cursor is out of the window), we should use the frame of the anchor
74711:       // root.
74711:     }
35608:   }
35608: 
    1:   //
35608:   // When we can't find a frame which is under the mouse cursor and has a same
35608:   // selection root as the anchor node's, we should return the selection root
35608:   // frame.
    1:   //
35608: 
36656:   *aRetFrame = anchorRoot->GetPrimaryFrame();
    1: 
    1:   if (!*aRetFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   //
    1:   // Now make sure that aRetPoint is converted to the same coordinate
    1:   // system used by aRetFrame.
    1:   //
    1: 
    1:   aRetPoint = aPoint + aFrame->GetOffsetTo(*aRetFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef IBMBIDI
    1: void
    1: nsFrameSelection::SetCaretBidiLevel(PRUint8 aLevel)
    1: {
    1:   // If the current level is undefined, we have just inserted new text.
    1:   // In this case, we don't want to reset the keyboard language
79445:   bool afterInsert = !!(mCaretBidiLevel & BIDI_LEVEL_UNDEFINED);
    1:   mCaretBidiLevel = aLevel;
    1:   
    1:   nsIBidiKeyboard* bidiKeyboard = nsContentUtils::GetBidiKeyboard();
    1:   if (bidiKeyboard && !afterInsert)
    1:     bidiKeyboard->SetLangFromBidiLevel(aLevel);
    1:   return;
    1: }
    1: 
    1: PRUint8
 8295: nsFrameSelection::GetCaretBidiLevel() const
    1: {
    1:   return mCaretBidiLevel;
    1: }
    1: 
    1: void
    1: nsFrameSelection::UndefineCaretBidiLevel()
    1: {
    1:   mCaretBidiLevel |= BIDI_LEVEL_UNDEFINED;
    1: }
    1: #endif
    1: 
    1: 
    1: #ifdef PRINT_RANGE
26998: void printRange(nsIRange *aDomRange)
    1: {
    1:   if (!aDomRange)
    1:   {
    1:     printf("NULL nsIDOMRange\n");
    1:   }
26998:   nsINode* startNode = aDomRange->GetStartParent();
26998:   nsINode* endNode = aDomRange->GetEndParent();
26998:   PRInt32 startOffset = aDomRange->StartOffset();
26998:   PRInt32 endOffset = aDomRange->EndOffset();
    1:   
    1:   printf("range: 0x%lx\t start: 0x%lx %ld, \t end: 0x%lx,%ld\n",
    1:          (unsigned long)aDomRange,
26998:          (unsigned long)startNode, (long)startOffset,
26998:          (unsigned long)endNode, (long)endOffset);
    1:          
    1: }
    1: #endif /* PRINT_RANGE */
    1: 
    1: static
26995: nsIAtom *GetTag(nsINode *aNode)
    1: {
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1:   if (!content) 
    1:   {
    1:     NS_NOTREACHED("bad node passed to GetTag()");
    1:     return nsnull;
    1:   }
    1:   
    1:   return content->Tag();
    1: }
    1: 
26995: // Returns the parent
26995: nsINode*
26995: ParentOffset(nsINode *aNode, PRInt32 *aChildOffset)
26995: {
26995:   if (!aNode || !aChildOffset)
26995:     return nsnull;
26995: 
26995:   nsIContent* parent = aNode->GetParent();
    1:   if (parent)
    1:   {
26995:     *aChildOffset = parent->IndexOf(aNode);
26995: 
26995:     return parent;
26995:   }
26995: 
26995:   return nsnull;
26995: }
26995: 
26995: static nsINode*
26995: GetCellParent(nsINode *aDomNode)
    1: {
    1:     if (!aDomNode)
26995:       return nsnull;
26995:     nsINode* current = aDomNode;
    1:     // Start with current node and look for a table cell
    1:     while (current)
    1:     {
26995:       nsIAtom* tag = GetTag(current);
    1:       if (tag == nsGkAtoms::td || tag == nsGkAtoms::th)
    1:         return current;
26995:       current = current->GetParent();
26995:     }
26995:     return nsnull;
    1: }
    1: 
    1: 
    1: void
    1: nsFrameSelection::Init(nsIPresShell *aShell, nsIContent *aLimiter)
    1: {
    1:   mShell = aShell;
80486:   mMouseDownState = false;
80486:   mDesiredXSet = false;
    1:   mLimiter = aLimiter;
70842:   mCaretMovementStyle =
70842:     Preferences::GetInt("bidi.edit.caret_movement_style", 2);
    1: }
    1: 
    1: nsresult
    1: nsFrameSelection::MoveCaret(PRUint32          aKeycode,
79445:                             bool              aContinueSelection,
    1:                             nsSelectionAmount aAmount)
    1: {
79445:   bool visualMovement =
    1:       (aKeycode == nsIDOMKeyEvent::DOM_VK_BACK_SPACE ||
    1:        aKeycode == nsIDOMKeyEvent::DOM_VK_DELETE ||
    1:        aKeycode == nsIDOMKeyEvent::DOM_VK_HOME ||
    1:        aKeycode == nsIDOMKeyEvent::DOM_VK_END) ?
80486:       false : // Delete operations and home/end are always logical
41477:       mCaretMovementStyle == 1 ||
41477:         (mCaretMovementStyle == 2 && !aContinueSelection);
41477: 
41477:   return MoveCaret(aKeycode, aContinueSelection, aAmount, visualMovement);
41477: }
41477: 
41477: nsresult
41477: nsFrameSelection::MoveCaret(PRUint32          aKeycode,
79445:                             bool              aContinueSelection,
41477:                             nsSelectionAmount aAmount,
79445:                             bool              aVisualMovement)
41477: {
41477:   NS_ENSURE_STATE(mShell);
41477:   // Flush out layout, since we need it to be up to date to do caret
41477:   // positioning.
41477:   mShell->FlushPendingNotifications(Flush_Layout);
41477: 
41477:   if (!mShell) {
41477:     return NS_OK;
41477:   }
41477: 
41477:   nsPresContext *context = mShell->GetPresContext();
41477:   if (!context)
41477:     return NS_ERROR_FAILURE;
41477: 
79445:   bool isCollapsed;
41477:   nscoord desiredX = 0; //we must keep this around and revalidate it when its just UP/DOWN
41477: 
41477:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
41477:   nsRefPtr<nsTypedSelection> sel = mDomSelections[index];
41477:   if (!sel)
41477:     return NS_ERROR_NULL_POINTER;
41477: 
41477:   nsresult result = sel->GetIsCollapsed(&isCollapsed);
41477:   if (NS_FAILED(result))
41477:     return result;
41477:   if (aKeycode == nsIDOMKeyEvent::DOM_VK_UP ||
41477:       aKeycode == nsIDOMKeyEvent::DOM_VK_DOWN)
41477:   {
41477:     result = FetchDesiredX(desiredX);
41477:     if (NS_FAILED(result))
41477:       return result;
41477:     SetDesiredX(desiredX);
41477:   }
41477: 
70842:   PRInt32 caretStyle =
70842:     Preferences::GetInt("layout.selection.caret_style", 0);
41477: #ifdef XP_MACOSX
41477:   if (caretStyle == 0) {
41477:     caretStyle = 2; // put caret at the selection edge in the |aKeycode| direction
41477:   }
41477: #endif
41477: 
41477:   if (!isCollapsed && !aContinueSelection && caretStyle == 2) {
41477:     switch (aKeycode){
41477:       case nsIDOMKeyEvent::DOM_VK_LEFT  :
41477:       case nsIDOMKeyEvent::DOM_VK_UP    :
41477:         {
41477:           const nsIRange* anchorFocusRange = sel->GetAnchorFocusRange();
41477:           if (anchorFocusRange) {
41477:             sel->Collapse(anchorFocusRange->GetStartParent(),
41477:                           anchorFocusRange->StartOffset());
41477:           }
41477:           mHint = HINTRIGHT;
41477:           sel->ScrollIntoView(nsISelectionController::SELECTION_FOCUS_REGION,
80486:                               false, false);
41477:           return NS_OK;
41477:         }
41477: 
41477:       case nsIDOMKeyEvent::DOM_VK_RIGHT :
41477:       case nsIDOMKeyEvent::DOM_VK_DOWN  :
41477:         {
41477:           const nsIRange* anchorFocusRange = sel->GetAnchorFocusRange();
41477:           if (anchorFocusRange) {
41477:             sel->Collapse(anchorFocusRange->GetEndParent(),
41477:                           anchorFocusRange->EndOffset());
41477:           }
41477:           mHint = HINTLEFT;
41477:           sel->ScrollIntoView(nsISelectionController::SELECTION_FOCUS_REGION,
80486:                               false, false);
41477:           return NS_OK;
41477:         }
41477:     }
41477:   }
    1: 
    1:   nsIFrame *frame;
26994:   PRInt32 offsetused = 0;
41477:   result = sel->GetPrimaryFrameForFocusNode(&frame, &offsetused,
41477:                                             aVisualMovement);
    1: 
    1:   if (NS_FAILED(result) || !frame)
    1:     return result?result:NS_ERROR_FAILURE;
    1: 
    1:   nsPeekOffsetStruct pos;
    1:   //set data using mLimiter to stop on scroll views.  If we have a limiter then we stop peeking
    1:   //when we hit scrollable views.  If no limiter then just let it go ahead
    1:   pos.SetData(aAmount, eDirPrevious, offsetused, desiredX, 
80486:               true, mLimiter != nsnull, true, aVisualMovement);
    1: 
    1:   nsBidiLevel baseLevel = nsBidiPresUtils::GetFrameBaseLevel(frame);
    1:   
    1:   HINT tHint(mHint); //temporary variable so we dont set mHint until it is necessary
    1:   switch (aKeycode){
    1:     case nsIDOMKeyEvent::DOM_VK_RIGHT : 
    1:         InvalidateDesiredX();
    1:         pos.mDirection = (baseLevel & 1) ? eDirPrevious : eDirNext;
    1:       break;
    1:     case nsIDOMKeyEvent::DOM_VK_LEFT :
    1:         InvalidateDesiredX();
    1:         pos.mDirection = (baseLevel & 1) ? eDirNext : eDirPrevious;
    1:       break;
    1:     case nsIDOMKeyEvent::DOM_VK_DELETE :
    1:         InvalidateDesiredX();
    1:         pos.mDirection = eDirNext;
    1:       break;
    1:     case nsIDOMKeyEvent::DOM_VK_BACK_SPACE : 
    1:         InvalidateDesiredX();
    1:         pos.mDirection = eDirPrevious;
    1:       break;
    1:     case nsIDOMKeyEvent::DOM_VK_DOWN : 
    1:         pos.mAmount = eSelectLine;
    1:         pos.mDirection = eDirNext;
    1:       break;
    1:     case nsIDOMKeyEvent::DOM_VK_UP : 
    1:         pos.mAmount = eSelectLine;
    1:         pos.mDirection = eDirPrevious;
    1:       break;
    1:     case nsIDOMKeyEvent::DOM_VK_HOME :
    1:         InvalidateDesiredX();
    1:         pos.mAmount = eSelectBeginLine;
    1:       break;
    1:     case nsIDOMKeyEvent::DOM_VK_END :
    1:         InvalidateDesiredX();
    1:         pos.mAmount = eSelectEndLine;
    1:       break;
    1:   default :return NS_ERROR_FAILURE;
    1:   }
    1:   PostReason(nsISelectionListener::KEYPRESS_REASON);
    1:   if (NS_SUCCEEDED(result = frame->PeekOffset(&pos)) && pos.mResultContent)
    1:   {
    1:     nsIFrame *theFrame;
    1:     PRInt32 currentOffset, frameStart, frameEnd;
    1: 
59604:     if (aAmount >= eSelectCharacter && aAmount <= eSelectWord)
    1:     {
    1:       // For left/right, PeekOffset() sets pos.mResultFrame correctly, but does not set pos.mAttachForward,
    1:       // so determine the hint here based on the result frame and offset:
    1:       // If we're at the end of a text frame, set the hint to HINTLEFT to indicate that we
    1:       // want the caret displayed at the end of this frame, not at the beginning of the next one.
    1:       theFrame = pos.mResultFrame;
    1:       theFrame->GetOffsets(frameStart, frameEnd);
    1:       currentOffset = pos.mContentOffset;
    1:       if (frameEnd == currentOffset && !(frameStart == 0 && frameEnd == 0))
    1:         tHint = HINTLEFT;
    1:       else
    1:         tHint = HINTRIGHT;
    1:     } else {
    1:       // For up/down and home/end, pos.mResultFrame might not be set correctly, or not at all.
    1:       // In these cases, get the frame based on the content and hint returned by PeekOffset().
    1:       tHint = (HINT)pos.mAttachForward;
    1:       theFrame = GetFrameForNodeOffset(pos.mResultContent, pos.mContentOffset,
    1:                                        tHint, &currentOffset);
    1:       if (!theFrame)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:       theFrame->GetOffsets(frameStart, frameEnd);
    1:     }
    1: 
    1:     if (context->BidiEnabled())
    1:     {
    1:       switch (aKeycode) {
    1:         case nsIDOMKeyEvent::DOM_VK_HOME:
    1:         case nsIDOMKeyEvent::DOM_VK_END:
    1:           // set the caret Bidi level to the paragraph embedding level
    1:           SetCaretBidiLevel(NS_GET_BASE_LEVEL(theFrame));
    1:           break;
    1: 
    1:         default:
    1:           // If the current position is not a frame boundary, it's enough just to take the Bidi level of the current frame
    1:           if ((pos.mContentOffset != frameStart && pos.mContentOffset != frameEnd)
    1:               || (eSelectLine == aAmount))
    1:           {
    1:             SetCaretBidiLevel(NS_GET_EMBEDDING_LEVEL(theFrame));
    1:           }
    1:           else
    1:             BidiLevelFromMove(mShell, pos.mResultContent, pos.mContentOffset, aKeycode, tHint);
    1:       }
20198:     }
20199:     result = TakeFocus(pos.mResultContent, pos.mContentOffset, pos.mContentOffset,
80486:                        tHint, aContinueSelection, false);
    1:   } else if (aKeycode == nsIDOMKeyEvent::DOM_VK_RIGHT && !aContinueSelection) {
    1:     // Collapse selection if PeekOffset failed, we either
    1:     //  1. bumped into the BRFrame, bug 207623
    1:     //  2. had select-all in a text input (DIV range), bug 352759.
79445:     bool isBRFrame = frame->GetType() == nsGkAtoms::brFrame;
26994:     sel->Collapse(sel->GetFocusNode(), sel->GetFocusOffset());
    1:     // Note: 'frame' might be dead here.
20199:     if (!isBRFrame) {
20199:       mHint = HINTLEFT; // We're now at the end of the frame to the left.
    1:     }
    1:     result = NS_OK;
    1:   }
    1:   if (NS_SUCCEEDED(result))
    1:   {
 4886:     result = mDomSelections[index]->
 4886:       ScrollIntoView(nsISelectionController::SELECTION_FOCUS_REGION,
80486:                      false, false);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: //END nsFrameSelection methods
    1: 
    1: 
    1: //BEGIN nsFrameSelection methods
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::ToString(PRUnichar **aReturn)
    1: {
42637:   return ToStringWithFormat("text/plain",
42637:                             nsIDocumentEncoder::SkipInvisibleContent,
42637:                             0, aReturn);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::ToStringWithFormat(const char * aFormatType, PRUint32 aFlags, 
    1:                                    PRInt32 aWrapCol, PRUnichar **aReturn)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (!aReturn)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   nsCAutoString formatType( NS_DOC_ENCODER_CONTRACTID_BASE );
    1:   formatType.Append(aFormatType);
    1:   nsCOMPtr<nsIDocumentEncoder> encoder =
    1:            do_CreateInstance(formatType.get(), &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIPresShell> shell;
    1:   rv = GetPresShell(getter_AddRefs(shell));
    1:   if (NS_FAILED(rv) || !shell) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsIDocument *doc = shell->GetDocument();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(doc);
    1:   NS_ASSERTION(domDoc, "Need a document");
    1: 
    1:   // Flags should always include OutputSelectionOnly if we're coming from here:
    1:   aFlags |= nsIDocumentEncoder::OutputSelectionOnly;
    1:   nsAutoString readstring;
    1:   readstring.AssignASCII(aFormatType);
    1:   rv = encoder->Init(domDoc, readstring, aFlags);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   encoder->SetSelection(this);
    1:   if (aWrapCol != 0)
    1:     encoder->SetWrapColumn(aWrapCol);
    1: 
    1:   nsAutoString tmp;
    1:   rv = encoder->EncodeToString(tmp);
    1:   *aReturn = ToNewUnicode(tmp);//get the unicode pointer from it. this is temporary
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsTypedSelection::SetInterlinePosition(bool aHintRight)
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_NOT_INITIALIZED; // Can't do selection
    1:   nsFrameSelection::HINT hint;
    1:   if (aHintRight)
    1:     hint = nsFrameSelection::HINTRIGHT;
    1:   else
    1:     hint = nsFrameSelection::HINTLEFT;
    1:   mFrameSelection->SetHint(hint);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsTypedSelection::GetInterlinePosition(bool *aHintRight)
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_NOT_INITIALIZED; // Can't do selection
    1:   *aHintRight = (mFrameSelection->GetHint() == nsFrameSelection::HINTRIGHT);
    1:   return NS_OK;
    1: }
    1: 
    1: nsPrevNextBidiLevels
    1: nsFrameSelection::GetPrevNextBidiLevels(nsIContent *aNode,
    1:                                         PRUint32    aContentOffset,
79445:                                         bool        aJumpLines) const
    1: {
    1:   return GetPrevNextBidiLevels(aNode, aContentOffset, mHint, aJumpLines);
    1: }
    1: 
    1: nsPrevNextBidiLevels
    1: nsFrameSelection::GetPrevNextBidiLevels(nsIContent *aNode,
    1:                                         PRUint32    aContentOffset,
    1:                                         HINT        aHint,
79445:                                         bool        aJumpLines) const
    1: {
    1:   // Get the level of the frames on each side
    1:   nsIFrame    *currentFrame;
    1:   PRInt32     currentOffset;
    1:   PRInt32     frameStart, frameEnd;
    1:   nsDirection direction;
    1:   
    1:   nsPrevNextBidiLevels levels;
    1:   levels.SetData(nsnull, nsnull, 0, 0);
    1: 
    1:   currentFrame = GetFrameForNodeOffset(aNode, aContentOffset,
    1:                                        aHint, &currentOffset);
    1:   if (!currentFrame)
    1:     return levels;
    1: 
    1:   currentFrame->GetOffsets(frameStart, frameEnd);
    1: 
    1:   if (0 == frameStart && 0 == frameEnd)
    1:     direction = eDirPrevious;
    1:   else if (frameStart == currentOffset)
    1:     direction = eDirPrevious;
    1:   else if (frameEnd == currentOffset)
    1:     direction = eDirNext;
    1:   else {
    1:     // we are neither at the beginning nor at the end of the frame, so we have no worries
    1:     levels.SetData(currentFrame, currentFrame,
    1:                    NS_GET_EMBEDDING_LEVEL(currentFrame),
    1:                    NS_GET_EMBEDDING_LEVEL(currentFrame));
    1:     return levels;
    1:   }
    1: 
    1:   nsIFrame *newFrame;
    1:   PRInt32 offset;
79445:   bool jumpedLine;
80486:   nsresult rv = currentFrame->GetFrameFromDirection(direction, false,
80486:                                                     aJumpLines, true,
    1:                                                     &newFrame, &offset, &jumpedLine);
    1:   if (NS_FAILED(rv))
    1:     newFrame = nsnull;
    1: 
    1:   PRUint8 baseLevel = NS_GET_BASE_LEVEL(currentFrame);
    1:   PRUint8 currentLevel = NS_GET_EMBEDDING_LEVEL(currentFrame);
    1:   PRUint8 newLevel = newFrame ? NS_GET_EMBEDDING_LEVEL(newFrame) : baseLevel;
    1:   
    1:   // If not jumping lines, disregard br frames, since they might be positioned incorrectly.
    1:   // XXX This could be removed once bug 339786 is fixed.
    1:   if (!aJumpLines) {
    1:     if (currentFrame->GetType() == nsGkAtoms::brFrame) {
    1:       currentFrame = nsnull;
    1:       currentLevel = baseLevel;
    1:     }
    1:     if (newFrame && newFrame->GetType() == nsGkAtoms::brFrame) {
    1:       newFrame = nsnull;
    1:       newLevel = baseLevel;
    1:     }
    1:   }
    1:   
    1:   if (direction == eDirNext)
    1:     levels.SetData(currentFrame, newFrame, currentLevel, newLevel);
    1:   else
    1:     levels.SetData(newFrame, currentFrame, newLevel, currentLevel);
    1: 
    1:   return levels;
    1: }
    1: 
    1: nsresult
    1: nsFrameSelection::GetFrameFromLevel(nsIFrame    *aFrameIn,
    1:                                     nsDirection  aDirection,
    1:                                     PRUint8      aBidiLevel,
 8295:                                     nsIFrame   **aFrameOut) const
 8295: {
 8295:   NS_ENSURE_STATE(mShell);
    1:   PRUint8 foundLevel = 0;
    1:   nsIFrame *foundFrame = aFrameIn;
    1: 
21105:   nsCOMPtr<nsIFrameEnumerator> frameTraversal;
    1:   nsresult result;
    1:   nsCOMPtr<nsIFrameTraversal> trav(do_CreateInstance(kFrameTraversalCID,&result));
    1:   if (NS_FAILED(result))
    1:       return result;
    1: 
    1:   result = trav->NewFrameTraversal(getter_AddRefs(frameTraversal),
    1:                                    mShell->GetPresContext(), aFrameIn,
    1:                                    eLeaf,
80486:                                    false, // aVisual
80486:                                    false, // aLockInScrollView
80486:                                    false     // aFollowOOFs
    1:                                    );
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   do {
    1:     *aFrameOut = foundFrame;
    1:     if (aDirection == eDirNext)
21105:       frameTraversal->Next();
    1:     else 
21105:       frameTraversal->Prev();
21105: 
21105:     foundFrame = frameTraversal->CurrentItem();
21105:     if (!foundFrame)
21105:       return NS_ERROR_FAILURE;
    1:     foundLevel = NS_GET_EMBEDDING_LEVEL(foundFrame);
    1: 
    1:   } while (foundLevel > aBidiLevel);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsFrameSelection::MaintainSelection(nsSelectionAmount aAmount)
    1: {
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
23902:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   mMaintainedAmount = aAmount;
26993: 
26993:   const nsIRange* anchorFocusRange =
26993:     mDomSelections[index]->GetAnchorFocusRange();
26993:   if (anchorFocusRange) {
26993:     return anchorFocusRange->CloneRange(getter_AddRefs(mMaintainRange));
26993:   }
26993: 
23482:   mMaintainRange = nsnull;
23482:   return NS_OK;
    1: }
    1: 
    1: 
    1: /** After moving the caret, its Bidi level is set according to the following rules:
    1:  *
    1:  *  After moving over a character with left/right arrow, set to the Bidi level of the last moved over character.
    1:  *  After Home and End, set to the paragraph embedding level.
    1:  *  After up/down arrow, PageUp/Down, set to the lower level of the 2 surrounding characters.
    1:  *  After mouse click, set to the level of the current frame.
    1:  *
    1:  *  The following two methods use GetPrevNextBidiLevels to determine the new Bidi level.
    1:  *  BidiLevelFromMove is called when the caret is moved in response to a keyboard event
    1:  *
    1:  * @param aPresShell is the presentation shell
    1:  * @param aNode is the content node
    1:  * @param aContentOffset is the new caret position, as an offset into aNode
    1:  * @param aKeycode is the keyboard event that moved the caret to the new position
    1:  * @param aHint is the hint indicating in what logical direction the caret moved
    1:  */
    1: void nsFrameSelection::BidiLevelFromMove(nsIPresShell* aPresShell,
    1:                                          nsIContent   *aNode,
    1:                                          PRUint32      aContentOffset,
    1:                                          PRUint32      aKeycode,
    1:                                          HINT          aHint)
    1: {
    1:   switch (aKeycode) {
    1: 
    1:     // Right and Left: the new cursor Bidi level is the level of the character moved over
    1:     case nsIDOMKeyEvent::DOM_VK_RIGHT:
    1:     case nsIDOMKeyEvent::DOM_VK_LEFT:
    1:     {
    1:       nsPrevNextBidiLevels levels = GetPrevNextBidiLevels(aNode, aContentOffset,
80486:                                                           aHint, false);
    1: 
    1:       if (HINTLEFT == aHint)
    1:         SetCaretBidiLevel(levels.mLevelBefore);
    1:       else
    1:         SetCaretBidiLevel(levels.mLevelAfter);
    1:       break;
    1:     }
    1:       /*
    1:     // Up and Down: the new cursor Bidi level is the smaller of the two surrounding characters      
    1:     case nsIDOMKeyEvent::DOM_VK_UP:
    1:     case nsIDOMKeyEvent::DOM_VK_DOWN:
    1:       GetPrevNextBidiLevels(aContext, aNode, aContentOffset, &firstFrame, &secondFrame, &firstLevel, &secondLevel);
32531:       aPresShell->SetCaretBidiLevel(NS_MIN(firstLevel, secondLevel));
    1:       break;
    1:       */
    1: 
    1:     default:
    1:       UndefineCaretBidiLevel();
    1:   }
    1: }
    1: 
    1: /**
    1:  * BidiLevelFromClick is called when the caret is repositioned by clicking the mouse
    1:  *
    1:  * @param aNode is the content node
    1:  * @param aContentOffset is the new caret position, as an offset into aNode
    1:  */
    1: void nsFrameSelection::BidiLevelFromClick(nsIContent *aNode,
    1:                                           PRUint32    aContentOffset)
    1: {
    1:   nsIFrame* clickInFrame=nsnull;
    1:   PRInt32 OffsetNotUsed;
    1: 
    1:   clickInFrame = GetFrameForNodeOffset(aNode, aContentOffset, mHint, &OffsetNotUsed);
    1:   if (!clickInFrame)
    1:     return;
    1: 
    1:   SetCaretBidiLevel(NS_GET_EMBEDDING_LEVEL(clickInFrame));
    1: }
    1: 
    1: 
79445: bool
    1: nsFrameSelection::AdjustForMaintainedSelection(nsIContent *aContent,
    1:                                                PRInt32     aOffset)
    1: {
    1:   if (!mMaintainRange)
80486:     return false;
    1: 
26993:   if (!aContent) {
80486:     return false;
26993:   }
20590: 
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
80486:     return false;
20590: 
26993:   nsINode* rangeStartNode = mMaintainRange->GetStartParent();
26993:   nsINode* rangeEndNode = mMaintainRange->GetEndParent();
26993:   PRInt32 rangeStartOffset = mMaintainRange->StartOffset();
26993:   PRInt32 rangeEndOffset = mMaintainRange->EndOffset();
26993: 
26993:   PRInt32 relToStart =
26993:     nsContentUtils::ComparePoints(rangeStartNode, rangeStartOffset,
26993:                                   aContent, aOffset);
26993:   PRInt32 relToEnd =
26993:     nsContentUtils::ComparePoints(rangeEndNode, rangeEndOffset,
26993:                                   aContent, aOffset);
20590: 
20590:   // If aContent/aOffset is inside the maintained selection, or if it is on the
20590:   // "anchor" side of the maintained selection, we need to do something.
84916:   if ((relToStart < 0 && relToEnd > 0) ||
20590:       (relToStart > 0 &&
20590:        mDomSelections[index]->GetDirection() == eDirNext) ||
20590:       (relToEnd < 0 &&
20590:        mDomSelections[index]->GetDirection() == eDirPrevious)) {
20590:     // Set the current range to the maintained range. 
20590:     mDomSelections[index]->ReplaceAnchorFocusRange(mMaintainRange);
20590:     if (relToStart < 0 && relToEnd > 0) {
20590:       // We're inside the maintained selection, just keep it selected.
80486:       return true;
20590:     }
20590:     // Reverse the direction of the selection so that the anchor will be on the 
20590:     // far side of the maintained selection, relative to aContent/aOffset.
20590:     mDomSelections[index]->SetDirection(relToStart > 0 ? eDirPrevious : eDirNext);
20590:   }
80486:   return false;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsFrameSelection::HandleClick(nsIContent *aNewFocus,
    1:                               PRUint32    aContentOffset,
    1:                               PRUint32    aContentEndOffset,
79445:                               bool        aContinueSelection, 
79445:                               bool        aMultipleSelection,
79445:                               bool        aHint) 
    1: {
    1:   if (!aNewFocus)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   InvalidateDesiredX();
    1: 
 2896:   if (!aContinueSelection) {
    1:     mMaintainRange = nsnull;
14636:     if (!IsValidSelectionPoint(this, aNewFocus)) {
 2896:       mAncestorLimiter = nsnull;
 2896:     }
14636:   }
    1: 
    1:   // Don't take focus when dragging off of a table
    1:   if (!mDragSelectingCells)
    1:   {
    1:     BidiLevelFromClick(aNewFocus, aContentOffset);
    1:     PostReason(nsISelectionListener::MOUSEDOWN_REASON + nsISelectionListener::DRAG_REASON);
    1:     if (aContinueSelection &&
    1:         AdjustForMaintainedSelection(aNewFocus, aContentOffset))
    1:       return NS_OK; //shift clicked to maintained selection. rejected.
    1: 
20199:     return TakeFocus(aNewFocus, aContentOffset, aContentEndOffset, HINT(aHint),
20199:                      aContinueSelection, aMultipleSelection);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameSelection::HandleDrag(nsIFrame *aFrame, nsPoint aPoint)
    1: {
 8295:   if (!aFrame || !mShell)
    1:     return;
    1: 
    1:   nsresult result;
    1:   nsIFrame *newFrame = 0;
    1:   nsPoint   newPoint;
    1: 
    1:   result = ConstrainFrameAndPointToAnchorSubtree(aFrame, aPoint, &newFrame, newPoint);
    1:   if (NS_FAILED(result))
    1:     return;
    1:   if (!newFrame)
    1:     return;
    1: 
    1:   nsIFrame::ContentOffsets offsets =
    1:       newFrame->GetContentOffsetsFromPoint(newPoint);
    1:   if (!offsets.content)
    1:     return;
    1: 
85101:   if (newFrame->IsSelected() &&
    1:       AdjustForMaintainedSelection(offsets.content, offsets.offset))
    1:     return;
    1: 
    1:   // Adjust offsets according to maintained amount
    1:   if (mMaintainRange && 
    1:       mMaintainedAmount != eSelectNoAmount) {    
    1:     
26993:     nsINode* rangenode = mMaintainRange->GetStartParent();
26993:     PRInt32 rangeOffset = mMaintainRange->StartOffset();
26993:     PRInt32 relativePosition =
26993:       nsContentUtils::ComparePoints(rangenode, rangeOffset,
26993:                                     offsets.content, offsets.offset);
    1: 
    1:     nsDirection direction = relativePosition > 0 ? eDirPrevious : eDirNext;
    1:     nsSelectionAmount amount = mMaintainedAmount;
    1:     if (amount == eSelectBeginLine && direction == eDirNext)
    1:       amount = eSelectEndLine;
    1: 
    1:     PRInt32 offset;
    1:     nsIFrame* frame = GetFrameForNodeOffset(offsets.content, offsets.offset, HINTRIGHT, &offset);
20720: 
21316:     if (frame && amount == eSelectWord && direction == eDirPrevious) {
20720:       // To avoid selecting the previous word when at start of word,
20720:       // first move one character forward.
20720:       nsPeekOffsetStruct charPos;
20720:       charPos.SetData(eSelectCharacter, eDirNext, offset, 0,
80486:                       false, mLimiter != nsnull, false, false);
20720:       if (NS_SUCCEEDED(frame->PeekOffset(&charPos))) {
20720:         frame = charPos.mResultFrame;
20720:         offset = charPos.mContentOffset;
20720:       }
20720:     }
20720: 
    1:     nsPeekOffsetStruct pos;
    1:     pos.SetData(amount, direction, offset, 0,
80486:                 false, mLimiter != nsnull, false, false);
    1: 
    1:     if (frame && NS_SUCCEEDED(frame->PeekOffset(&pos)) && pos.mResultContent) {
    1:       offsets.content = pos.mResultContent;
    1:       offsets.offset = pos.mContentOffset;
    1:     }
    1:   }
    1:   
    1:   HandleClick(offsets.content, offsets.offset, offsets.offset,
80486:               true, false, offsets.associateWithNext);
    1: }
    1: 
    1: nsresult
37078: nsFrameSelection::StartAutoScrollTimer(nsIFrame *aFrame,
    1:                                        nsPoint   aPoint,
    1:                                        PRUint32  aDelay)
    1: {
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
23902:     return NS_ERROR_NULL_POINTER;
23902: 
37078:   return mDomSelections[index]->StartAutoScrollTimer(aFrame, aPoint, aDelay);
    1: }
    1: 
    1: void
    1: nsFrameSelection::StopAutoScrollTimer()
    1: {
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
23902:     return;
23902: 
    1:   mDomSelections[index]->StopAutoScrollTimer();
    1: }
    1: 
    1: /**
    1: hard to go from nodes to frames, easy the other way!
    1:  */
    1: nsresult
    1: nsFrameSelection::TakeFocus(nsIContent *aNewFocus,
    1:                             PRUint32    aContentOffset,
    1:                             PRUint32    aContentEndOffset,
20199:                             HINT        aHint,
79445:                             bool        aContinueSelection,
79445:                             bool        aMultipleSelection)
    1: {
    1:   if (!aNewFocus)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
 8295:   NS_ENSURE_STATE(mShell);
    1: 
    1:   if (!IsValidSelectionPoint(this,aNewFocus))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Clear all table selection data
    1:   mSelectingTableCellMode = 0;
80486:   mDragSelectingCells = false;
    1:   mStartSelectedCell = nsnull;
    1:   mEndSelectedCell = nsnull;
    1:   mAppendStartSelectedCell = nsnull;
    1: 
    1:   //HACKHACKHACK
    1:   if (!aNewFocus->GetParent())
    1:     return NS_ERROR_FAILURE;
    1:   //END HACKHACKHACK /checking for root frames/content
    1: 
20199:   mHint = aHint;
20199:   
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
23902:     return NS_ERROR_NULL_POINTER;
23902: 
    1:   //traverse through document and unselect crap here
    1:   if (!aContinueSelection) {//single click? setting cursor down
    1:     PRUint32 batching = mBatching;//hack to use the collapse code.
79445:     bool changes = mChangesDuringBatching;
    1:     mBatching = 1;
    1: 
    1:     if (aMultipleSelection) {
20590:       // Remove existing collapsed ranges as there's no point in having 
20590:       // non-anchor/focus collapsed ranges.
20590:       mDomSelections[index]->RemoveCollapsedRanges();
20590: 
26995:       nsCOMPtr<nsIRange> newRange = new nsRange();
26995: 
26995:       newRange->SetStart(aNewFocus, aContentOffset);
26995:       newRange->SetEnd(aNewFocus, aContentOffset);
    1:       mDomSelections[index]->AddRange(newRange);
    1:       mBatching = batching;
    1:       mChangesDuringBatching = changes;
    1:     }
    1:     else
    1:     {
79445:       bool oldDesiredXSet = mDesiredXSet; //need to keep old desired X if it was set.
26995:       mDomSelections[index]->Collapse(aNewFocus, aContentOffset);
    1:       mDesiredXSet = oldDesiredXSet; //now reset desired X back.
    1:       mBatching = batching;
    1:       mChangesDuringBatching = changes;
    1:     }
    1:     if (aContentEndOffset != aContentOffset)
26995:       mDomSelections[index]->Extend(aNewFocus, aContentEndOffset);
    1: 
    1:     //find out if we are inside a table. if so, find out which one and which cell
    1:     //once we do that, the next time we get a takefocus, check the parent tree. 
    1:     //if we are no longer inside same table ,cell then switch to table selection mode.
    1:     // BUT only do this in an editor
    1: 
 8295:     NS_ENSURE_STATE(mShell);
39668:     PRInt16 displaySelection = mShell->GetSelectionFlags();
    1: 
    1:     // Editor has DISPLAY_ALL selection type
    1:     if (displaySelection == nsISelectionDisplay::DISPLAY_ALL)
    1:     {
26995:       mCellParent = GetCellParent(aNewFocus);
    1: #ifdef DEBUG_TABLE_SELECTION
    1:       if (mCellParent)
    1:         printf(" * TakeFocus - Collapsing into new cell\n");
    1: #endif
    1:     }
    1:   }
    1:   else {
    1:     // Now update the range list:
26995:     if (aContinueSelection && aNewFocus)
    1:     {
    1:       PRInt32 offset;
26995:       nsINode *cellparent = GetCellParent(aNewFocus);
    1:       if (mCellParent && cellparent && cellparent != mCellParent) //switch to cell selection mode
    1:       {
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf(" * TakeFocus - moving into new cell\n");
    1: #endif
80486:         nsMouseEvent event(false, 0, nsnull, nsMouseEvent::eReal);
    1: 
    1:         // Start selecting in the cell we were in before
26995:         nsINode* parent = ParentOffset(mCellParent, &offset);
26995:         if (parent)
26995:           HandleTableSelection(parent, offset,
26995:                                nsISelectionPrivate::TABLESELECTION_CELL, &event);
    1: 
    1:         // Find the parent of this new cell and extend selection to it
26995:         parent = ParentOffset(cellparent, &offset);
    1: 
    1:         // XXXX We need to REALLY get the current key shift state
    1:         //  (we'd need to add event listener -- let's not bother for now)
80486:         event.isShift = false; //aContinueSelection;
26995:         if (parent)
    1:         {
    1:           mCellParent = cellparent;
    1:           // Continue selection into next cell
26995:           HandleTableSelection(parent, offset,
26995:                                nsISelectionPrivate::TABLESELECTION_CELL, &event);
    1:         }
    1:       }
    1:       else
    1:       {
    1:         // XXXX Problem: Shift+click in browser is appending text selection to selected table!!!
    1:         //   is this the place to erase seleced cells ?????
    1:         if (mDomSelections[index]->GetDirection() == eDirNext && aContentEndOffset > aContentOffset) //didn't go far enough 
    1:         {
26995:           mDomSelections[index]->Extend(aNewFocus, aContentEndOffset);//this will only redraw the diff 
    1:         }
    1:         else
26995:           mDomSelections[index]->Extend(aNewFocus, aContentOffset);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Don't notify selection listeners if batching is on:
    1:   if (GetBatching())
    1:     return NS_OK;
    1:   return NotifySelectionListeners(nsISelectionController::SELECTION_NORMAL);
    1: }
    1: 
    1: 
    1: SelectionDetails*
 8295: nsFrameSelection::LookUpSelection(nsIContent *aContent,
 8295:                                   PRInt32 aContentOffset,
 8295:                                   PRInt32 aContentLength,
79445:                                   bool aSlowCheck) const
    1: {
    1:   if (!aContent || !mShell)
    1:     return nsnull;
    1: 
    1:   SelectionDetails* details = nsnull;
    1: 
    1:   for (PRInt32 j = 0; j < nsISelectionController::NUM_SELECTIONTYPES; j++) {
    1:     if (mDomSelections[j]) {
    1:       mDomSelections[j]->LookUpSelection(aContent, aContentOffset,
    1:           aContentLength, &details, (SelectionType)(1<<j), aSlowCheck);
    1:     }
    1:   }
    1: 
    1:   return details;
    1: }
    1: 
    1: void
79445: nsFrameSelection::SetMouseDownState(bool aState)
    1: {
    1:   if (mMouseDownState == aState)
    1:     return;
    1: 
    1:   mMouseDownState = aState;
    1:     
74711:   if (!mMouseDownState)
74711:   {
80486:     mDragSelectingCells = false;
    1:     PostReason(nsISelectionListener::MOUSEUP_REASON);
    1:     NotifySelectionListeners(nsISelectionController::SELECTION_NORMAL); //notify that reason is mouse up please.
    1:   }
    1: }
    1: 
    1: nsISelection*
 8295: nsFrameSelection::GetSelection(SelectionType aType) const
    1: {
    1:   PRInt8 index = GetIndexFromSelectionType(aType);
    1:   if (index < 0)
    1:     return nsnull;
    1: 
 3233:   return static_cast<nsISelection*>(mDomSelections[index]);
    1: }
    1: 
    1: nsresult
    1: nsFrameSelection::ScrollSelectionIntoView(SelectionType   aType,
    1:                                           SelectionRegion aRegion,
56442:                                           PRInt16         aFlags) const
    1: {
    1:   PRInt8 index = GetIndexFromSelectionType(aType);
    1:   if (index < 0)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   if (!mDomSelections[index])
    1:     return NS_ERROR_NULL_POINTER;
    1: 
56443:   PRInt32 flags = nsTypedSelection::SCROLL_DO_FLUSH;
56443:   if (aFlags & nsISelectionController::SCROLL_SYNCHRONOUS) {
56443:     flags |= nsTypedSelection::SCROLL_SYNCHRONOUS;
56443:   } else if (aFlags & nsISelectionController::SCROLL_FIRST_ANCESTOR_ONLY) {
56443:     flags |= nsTypedSelection::SCROLL_FIRST_ANCESTOR_ONLY;
56443:   }
56443: 
12392:   // After ScrollSelectionIntoView(), the pending notifications might be
12392:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
56442:   return mDomSelections[index]->ScrollIntoView(aRegion,
56443:                                                PRInt16(NS_PRESSHELL_SCROLL_ANYWHERE),
56443:                                                PRInt16(NS_PRESSHELL_SCROLL_ANYWHERE),
56443:                                                flags);
    1: }
    1: 
    1: nsresult
 8295: nsFrameSelection::RepaintSelection(SelectionType aType) const
    1: {
    1:   PRInt8 index = GetIndexFromSelectionType(aType);
    1:   if (index < 0)
    1:     return NS_ERROR_INVALID_ARG;
    1:   if (!mDomSelections[index])
    1:     return NS_ERROR_NULL_POINTER;
 8295:   NS_ENSURE_STATE(mShell);
    1:   return mDomSelections[index]->Repaint(mShell->GetPresContext());
    1: }
    1:  
    1: nsIFrame*
    1: nsFrameSelection::GetFrameForNodeOffset(nsIContent *aNode,
    1:                                         PRInt32     aOffset,
    1:                                         HINT        aHint,
 8295:                                         PRInt32    *aReturnOffset) const
 8295: {
 8295:   if (!aNode || !aReturnOffset || !mShell)
    1:     return nsnull;
    1: 
    1:   if (aOffset < 0)
    1:     return nsnull;
    1: 
    1:   *aReturnOffset = aOffset;
    1: 
    1:   nsCOMPtr<nsIContent> theNode = aNode;
    1: 
41641:   if (aNode->IsElement())
    1:   {
    1:     PRInt32 childIndex  = 0;
    1:     PRInt32 numChildren = theNode->GetChildCount();
    1: 
    1:     if (aHint == HINTLEFT)
    1:     {
    1:       if (aOffset > 0)
    1:         childIndex = aOffset - 1;
    1:       else
    1:         childIndex = aOffset;
    1:     }
    1:     else // HINTRIGHT
    1:     {
    1:       if (aOffset >= numChildren)
    1:       {
    1:         if (numChildren > 0)
    1:           childIndex = numChildren - 1;
    1:         else
    1:           childIndex = 0;
    1:       }
    1:       else
    1:         childIndex = aOffset;
    1:     }
    1:     
    1:     if (childIndex > 0 || numChildren > 0) {
    1:       nsCOMPtr<nsIContent> childNode = theNode->GetChildAt(childIndex);
    1: 
    1:       if (!childNode)
    1:         return nsnull;
    1: 
    1:       theNode = childNode;
    1:     }
    1: 
    1: #ifdef DONT_DO_THIS_YET
    1:     // XXX: We can't use this code yet because the hinting
28161:     //      can cause us to attach to the wrong line frame.
    1: 
    1:     // Now that we have the child node, check if it too
    1:     // can contain children. If so, call this method again!
    1: 
41641:     if (theNode->IsElement())
    1:     {
    1:       PRInt32 newOffset = 0;
    1: 
    1:       if (aOffset > childIndex)
    1:       {
    1:         numChildren = theNode->GetChildCount();
    1: 
    1:         newOffset = numChildren;
    1:       }
    1: 
    1:       return GetFrameForNodeOffset(theNode, newOffset, aHint, aReturnOffset);
    1:     }
    1:     else
    1: #endif // DONT_DO_THIS_YET
    1:     {
    1:       // Check to see if theNode is a text node. If it is, translate
    1:       // aOffset into an offset into the text node.
    1: 
    1:       nsCOMPtr<nsIDOMText> textNode = do_QueryInterface(theNode);
    1: 
    1:       if (textNode)
    1:       {
56863:         if (theNode->GetPrimaryFrame())
56863:         {
    1:           if (aOffset > childIndex)
    1:           {
    1:             PRUint32 textLength = 0;
    1: 
    1:             nsresult rv = textNode->GetLength(&textLength);
    1:             if (NS_FAILED(rv))
    1:               return nsnull;
    1: 
    1:             *aReturnOffset = (PRInt32)textLength;
    1:           }
    1:           else
    1:             *aReturnOffset = 0;
    1:         }
56863:         else
56863:         {
56863:           // If we're at a collapsed whitespace content node (which
56863:           // does not have a primary frame), just use the original node
56863:           // to get the frame on which we should put the caret.
56863:           theNode = aNode;
56863:         }
56863:       }
    1:     }
    1:   }
    1:   
36656:   nsIFrame* returnFrame = theNode->GetPrimaryFrame();
    1:   if (!returnFrame)
    1:     return nsnull;
    1: 
    1:   // find the child frame containing the offset we want
    1:   returnFrame->GetChildFrameContainingOffset(*aReturnOffset, aHint,
    1:                                              &aOffset, &returnFrame);
    1:   return returnFrame;
    1: }
    1: 
    1: void
79445: nsFrameSelection::CommonPageMove(bool aForward,
79445:                                  bool aExtend,
37069:                                  nsIScrollableFrame* aScrollableFrame)
37069: {
    1:   // expected behavior for PageMove is to scroll AND move the caret
    1:   // and remain relative position of the caret in view. see Bug 4302.
    1: 
    1:   //get the frame from the scrollable view
    1: 
37078:   nsIFrame* scrolledFrame = aScrollableFrame->GetScrolledFrame();
37078:   if (!scrolledFrame)
    1:     return;
    1: 
    1:   // find out where the caret is.
    1:   // we should know mDesiredX value of nsFrameSelection, but I havent seen that behavior in other windows applications yet.
    1:   nsISelection* domSel = GetSelection(nsISelectionController::SELECTION_NORMAL);
    1:   if (!domSel) 
    1:     return;
    1: 
40045:   nsRefPtr<nsCaret> caret = mShell->GetCaret();
    1: 
37078:   nsRect caretPos;
37078:   nsIFrame* caretFrame = caret->GetGeometry(domSel, &caretPos);
37078:   if (!caretFrame) 
    1:     return;
    1:   
    1:   //need to adjust caret jump by percentage scroll
37069:   nsSize scrollDelta = aScrollableFrame->GetPageScrollAmount();
    1: 
    1:   if (aForward)
    1:     caretPos.y += scrollDelta.height;
    1:   else
    1:     caretPos.y -= scrollDelta.height;
    1: 
37078:   caretPos += caretFrame->GetOffsetTo(scrolledFrame);
    1:     
    1:   // get a content at desired location
    1:   nsPoint desiredPoint;
    1:   desiredPoint.x = caretPos.x;
    1:   desiredPoint.y = caretPos.y + caretPos.height/2;
    1:   nsIFrame::ContentOffsets offsets =
37078:       scrolledFrame->GetContentOffsetsFromPoint(desiredPoint);
    1: 
    1:   if (!offsets.content)
    1:     return;
    1: 
    1:   // scroll one page
37069:   aScrollableFrame->ScrollBy(nsIntPoint(0, aForward ? 1 : -1),
37069:                              nsIScrollableFrame::PAGES,
37069:                              nsIScrollableFrame::SMOOTH);
    1: 
    1:   // place the caret
    1:   HandleClick(offsets.content, offsets.offset,
80486:               offsets.offset, aExtend, false, true);
    1: }
    1: 
    1: nsresult
79445: nsFrameSelection::CharacterMove(bool aForward, bool aExtend)
    1: {
    1:   if (aForward)
59604:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_RIGHT, aExtend, eSelectCluster);
    1:   else
59604:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_LEFT, aExtend, eSelectCluster);
    1: }
    1: 
    1: nsresult
20532: nsFrameSelection::CharacterExtendForDelete()
20532: {
80486:   return MoveCaret(nsIDOMKeyEvent::DOM_VK_DELETE, true, eSelectCluster);
20532: }
20532: 
20532: nsresult
43298: nsFrameSelection::CharacterExtendForBackspace()
43298: {
80486:   return MoveCaret(nsIDOMKeyEvent::DOM_VK_BACK_SPACE, true, eSelectCharacter);
43298: }
43298: 
43298: nsresult
79445: nsFrameSelection::WordMove(bool aForward, bool aExtend)
    1: {
    1:   if (aForward)
    1:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_RIGHT,aExtend,eSelectWord);
    1:   else
    1:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_LEFT,aExtend,eSelectWord);
    1: }
    1: 
    1: nsresult
79445: nsFrameSelection::WordExtendForDelete(bool aForward)
    1: {
    1:   if (aForward)
80486:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_DELETE, true, eSelectWord);
    1:   else
80486:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_BACK_SPACE, true, eSelectWord);
    1: }
    1: 
    1: nsresult
79445: nsFrameSelection::LineMove(bool aForward, bool aExtend)
    1: {
    1:   if (aForward)
    1:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_DOWN,aExtend,eSelectLine);
    1:   else
    1:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_UP,aExtend,eSelectLine);
    1: }
    1: 
    1: nsresult
79445: nsFrameSelection::IntraLineMove(bool aForward, bool aExtend)
    1: {
    1:   if (aForward)
    1:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_END,aExtend,eSelectLine);
    1:   else
    1:     return MoveCaret(nsIDOMKeyEvent::DOM_VK_HOME,aExtend,eSelectLine);
    1: }
    1: 
    1: nsresult
    1: nsFrameSelection::SelectAll()
    1: {
    1:   nsCOMPtr<nsIContent> rootContent;
    1:   if (mLimiter)
    1:   {
    1:     rootContent = mLimiter;//addrefit
    1:   }
 2896:   else if (mAncestorLimiter) {
 2896:     rootContent = mAncestorLimiter;
 2896:   }
    1:   else
    1:   {
 8295:     NS_ENSURE_STATE(mShell);
    1:     nsIDocument *doc = mShell->GetDocument();
    1:     if (!doc)
    1:       return NS_ERROR_FAILURE;
41634:     rootContent = doc->GetRootElement();
    1:     if (!rootContent)
    1:       return NS_ERROR_FAILURE;
    1:   }
    1:   PRInt32 numChildren = rootContent->GetChildCount();
    1:   PostReason(nsISelectionListener::NO_REASON);
80486:   return TakeFocus(rootContent, 0, numChildren, HINTLEFT, false, false);
    1: }
    1: 
    1: //////////END FRAMESELECTION
    1: 
    1: void
    1: nsFrameSelection::StartBatchChanges()
    1: {
    1:   mBatching++;
    1: }
    1: 
    1: void
    1: nsFrameSelection::EndBatchChanges()
    1: {
    1:   mBatching--;
    1:   NS_ASSERTION(mBatching >=0,"Bad mBatching");
    1:   if (mBatching == 0 && mChangesDuringBatching){
80486:     mChangesDuringBatching = false;
    1:     NotifySelectionListeners(nsISelectionController::SELECTION_NORMAL);
    1:   }
    1: }
    1: 
    1: 
    1: nsresult
    1: nsFrameSelection::NotifySelectionListeners(SelectionType aType)
    1: {
    1:   PRInt8 index = GetIndexFromSelectionType(aType);
23902:   if (index >=0 && mDomSelections[index])
    1:   {
    1:     return mDomSelections[index]->NotifySelectionListeners();
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // Start of Table Selection methods
    1: 
79445: static bool IsCell(nsIContent *aContent)
    1: {
    1:   return ((aContent->Tag() == nsGkAtoms::td ||
    1:            aContent->Tag() == nsGkAtoms::th) &&
33329:           aContent->IsHTML());
    1: }
    1: 
    1: nsITableCellLayout* 
 8295: nsFrameSelection::GetCellLayout(nsIContent *aCellContent) const
 8295: {
 8295:   NS_ENSURE_TRUE(mShell, nsnull);
36656:   nsITableCellLayout *cellLayoutObject =
36656:     do_QueryFrame(aCellContent->GetPrimaryFrame());
    1:   return cellLayoutObject;
    1: }
    1: 
    1: nsITableLayout* 
 8295: nsFrameSelection::GetTableLayout(nsIContent *aTableContent) const
 8295: {
 8295:   NS_ENSURE_TRUE(mShell, nsnull);
36656:   nsITableLayout *tableLayoutObject =
36656:     do_QueryFrame(aTableContent->GetPrimaryFrame());
    1:   return tableLayoutObject;
    1: }
    1: 
    1: nsresult
    1: nsFrameSelection::ClearNormalSelection()
    1: {
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
23902:     return NS_ERROR_NULL_POINTER;
23902: 
    1:   return mDomSelections[index]->RemoveAllRanges();
    1: }
    1: 
26997: static nsIContent*
26997: GetFirstSelectedContent(nsIRange* aRange)
26997: {
26997:   if (!aRange) {
26997:     return nsnull;
26997:   }
26997: 
26997:   NS_PRECONDITION(aRange->GetStartParent(), "Must have start parent!");
41641:   NS_PRECONDITION(aRange->GetStartParent()->IsElement(),
26997:                   "Unexpected parent");
26997: 
26997:   return aRange->GetStartParent()->GetChildAt(aRange->StartOffset());
26997: }
26997: 
    1: // Table selection support.
    1: // TODO: Separate table methods into a separate nsITableSelection interface
    1: nsresult
26995: nsFrameSelection::HandleTableSelection(nsINode *aParentContent,
26995:                                        PRInt32 aContentOffset,
26995:                                        PRInt32 aTarget,
26995:                                        nsMouseEvent *aMouseEvent)
    1: {
    1:   NS_ENSURE_TRUE(aParentContent, NS_ERROR_NULL_POINTER);
    1:   NS_ENSURE_TRUE(aMouseEvent, NS_ERROR_NULL_POINTER);
    1: 
    1:   if (mMouseDownState && mDragSelectingCells && (aTarget & nsISelectionPrivate::TABLESELECTION_TABLE))
    1:   {
    1:     // We were selecting cells and user drags mouse in table border or inbetween cells,
    1:     //  just do nothing
    1:       return NS_OK;
    1:   }
    1: 
    1:   nsresult result = NS_OK;
    1: 
    1:   nsIContent *childContent = aParentContent->GetChildAt(aContentOffset);
    1: 
    1:   // When doing table selection, always set the direction to next so
    1:   // we can be sure that anchorNode's offset always points to the
    1:   // selected cell
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
23902:     return NS_ERROR_NULL_POINTER;
23902: 
    1:   mDomSelections[index]->SetDirection(eDirNext);
    1: 
    1:   // Stack-class to wrap all table selection changes in 
    1:   //  BeginBatchChanges() / EndBatchChanges()
    1:   nsSelectionBatcher selectionBatcher(mDomSelections[index]);
    1: 
    1:   PRInt32 startRowIndex, startColIndex, curRowIndex, curColIndex;
    1:   if (mMouseDownState && mDragSelectingCells)
    1:   {
    1:     // We are drag-selecting
    1:     if (aTarget != nsISelectionPrivate::TABLESELECTION_TABLE)
    1:     {
    1:       // If dragging in the same cell as last event, do nothing
    1:       if (mEndSelectedCell == childContent)
    1:         return NS_OK;
    1: 
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf(" mStartSelectedCell = %x, mEndSelectedCell = %x, childContent = %x \n", mStartSelectedCell, mEndSelectedCell, childContent);
    1: #endif
    1:       // aTarget can be any "cell mode",
    1:       //  so we can easily drag-select rows and columns 
    1:       // Once we are in row or column mode,
    1:       //  we can drift into any cell to stay in that mode
    1:       //  even if aTarget = TABLESELECTION_CELL
    1: 
    1:       if (mSelectingTableCellMode == nsISelectionPrivate::TABLESELECTION_ROW ||
    1:           mSelectingTableCellMode == nsISelectionPrivate::TABLESELECTION_COLUMN)
    1:       {
    1:         if (mEndSelectedCell)
    1:         {
    1:           // Also check if cell is in same row/col
    1:           result = GetCellIndexes(mEndSelectedCell, startRowIndex, startColIndex);
    1:           if (NS_FAILED(result)) return result;
    1:           result = GetCellIndexes(childContent, curRowIndex, curColIndex);
    1:           if (NS_FAILED(result)) return result;
    1:         
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf(" curRowIndex = %d, startRowIndex = %d, curColIndex = %d, startColIndex = %d\n", curRowIndex, startRowIndex, curColIndex, startColIndex);
    1: #endif
    1:           if ((mSelectingTableCellMode == nsISelectionPrivate::TABLESELECTION_ROW && startRowIndex == curRowIndex) ||
    1:               (mSelectingTableCellMode == nsISelectionPrivate::TABLESELECTION_COLUMN && startColIndex == curColIndex)) 
    1:             return NS_OK;
    1:         }
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf(" Dragged into a new column or row\n");
    1: #endif
    1:         // Continue dragging row or column selection
    1:         return SelectRowOrColumn(childContent, mSelectingTableCellMode);
    1:       }
    1:       else if (mSelectingTableCellMode == nsISelectionPrivate::TABLESELECTION_CELL)
    1:       {
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf("HandleTableSelection: Dragged into a new cell\n");
    1: #endif
    1:         // Trick for quick selection of rows and columns
    1:         // Hold down shift, then start selecting in one direction
    1:         // If next cell dragged into is in same row, select entire row,
    1:         //   if next cell is in same column, select entire column
    1:         if (mStartSelectedCell && aMouseEvent->isShift)
    1:         {
    1:           result = GetCellIndexes(mStartSelectedCell, startRowIndex, startColIndex);
    1:           if (NS_FAILED(result)) return result;
    1:           result = GetCellIndexes(childContent, curRowIndex, curColIndex);
    1:           if (NS_FAILED(result)) return result;
    1:           
    1:           if (startRowIndex == curRowIndex || 
    1:               startColIndex == curColIndex)
    1:           {
    1:             // Force new selection block
    1:             mStartSelectedCell = nsnull;
    1:             mDomSelections[index]->RemoveAllRanges();
    1: 
    1:             if (startRowIndex == curRowIndex)
    1:               mSelectingTableCellMode = nsISelectionPrivate::TABLESELECTION_ROW;
    1:             else
    1:               mSelectingTableCellMode = nsISelectionPrivate::TABLESELECTION_COLUMN;
    1: 
    1:             return SelectRowOrColumn(childContent, mSelectingTableCellMode);
    1:           }
    1:         }
    1:         
    1:         // Reselect block of cells to new end location
    1:         return SelectBlockOfCells(mStartSelectedCell, childContent);
    1:       }
    1:     }
    1:     // Do nothing if dragging in table, but outside a cell
    1:     return NS_OK;
    1:   }
    1:   else 
    1:   {
    1:     // Not dragging  -- mouse event is down or up
    1:     if (mMouseDownState)
    1:     {
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf("HandleTableSelection: Mouse down event\n");
    1: #endif
    1:       // Clear cell we stored in mouse-down
    1:       mUnselectCellOnMouseUp = nsnull;
    1:       
    1:       if (aTarget == nsISelectionPrivate::TABLESELECTION_CELL)
    1:       {
79445:         bool isSelected = false;
    1: 
    1:         // Check if we have other selected cells
26997:         nsIContent* previousCellNode =
26997:           GetFirstSelectedContent(GetFirstCellRange());
    1:         if (previousCellNode)
    1:         {
    1:           // We have at least 1 other selected cell
    1: 
    1:           // Check if new cell is already selected
36656:           nsIFrame  *cellFrame = childContent->GetPrimaryFrame();
    1:           if (!cellFrame) return NS_ERROR_NULL_POINTER;
85101:           isSelected = cellFrame->IsSelected();
    1:         }
    1:         else
    1:         {
    1:           // No cells selected -- remove non-cell selection
    1:           mDomSelections[index]->RemoveAllRanges();
    1:         }
80486:         mDragSelectingCells = true;    // Signal to start drag-cell-selection
    1:         mSelectingTableCellMode = aTarget;
    1:         // Set start for new drag-selection block (not appended)
    1:         mStartSelectedCell = childContent;
    1:         // The initial block end is same as the start
    1:         mEndSelectedCell = childContent;
    1:         
    1:         if (isSelected)
    1:         {
    1:           // Remember this cell to (possibly) unselect it on mouseup
    1:           mUnselectCellOnMouseUp = childContent;
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf("HandleTableSelection: Saving mUnselectCellOnMouseUp\n");
    1: #endif
    1:         }
    1:         else
    1:         {
    1:           // Select an unselected cell
    1:           // but first remove existing selection if not in same table
26997:           if (previousCellNode &&
26998:               !IsInSameTable(previousCellNode, childContent))
    1:           {
    1:             mDomSelections[index]->RemoveAllRanges();
    1:             // Reset selection mode that is cleared in RemoveAllRanges
    1:             mSelectingTableCellMode = aTarget;
    1:           }
    1: 
26998:           return SelectCellElement(childContent);
    1:         }
    1: 
    1:         return NS_OK;
    1:       }
    1:       else if (aTarget == nsISelectionPrivate::TABLESELECTION_TABLE)
    1:       {
    1:         //TODO: We currently select entire table when clicked between cells,
    1:         //  should we restrict to only around border?
    1:         //  *** How do we get location data for cell and click?
80486:         mDragSelectingCells = false;
    1:         mStartSelectedCell = nsnull;
    1:         mEndSelectedCell = nsnull;
    1: 
    1:         // Remove existing selection and select the table
    1:         mDomSelections[index]->RemoveAllRanges();
26996:         return CreateAndAddRange(aParentContent, aContentOffset);
    1:       }
    1:       else if (aTarget == nsISelectionPrivate::TABLESELECTION_ROW || aTarget == nsISelectionPrivate::TABLESELECTION_COLUMN)
    1:       {
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf("aTarget == %d\n", aTarget);
    1: #endif
    1: 
    1:         // Start drag-selecting mode so multiple rows/cols can be selected
    1:         // Note: Currently, nsFrame::GetDataForTableSelection
    1:         //       will never call us for row or column selection on mouse down
80486:         mDragSelectingCells = true;
    1:       
    1:         // Force new selection block
    1:         mStartSelectedCell = nsnull;
    1:         mDomSelections[index]->RemoveAllRanges();
    1:         // Always do this AFTER RemoveAllRanges
    1:         mSelectingTableCellMode = aTarget;
    1:         return SelectRowOrColumn(childContent, aTarget);
    1:       }
    1:     }
    1:     else
    1:     {
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf("HandleTableSelection: Mouse UP event. mDragSelectingCells=%d, mStartSelectedCell=%d\n", mDragSelectingCells, mStartSelectedCell);
    1: #endif
    1:       // First check if we are extending a block selection
    1:       PRInt32 rangeCount;
    1:       result = mDomSelections[index]->GetRangeCount(&rangeCount);
    1:       if (NS_FAILED(result)) 
    1:         return result;
    1: 
    1:       if (rangeCount > 0 && aMouseEvent->isShift && 
    1:           mAppendStartSelectedCell && mAppendStartSelectedCell != childContent)
    1:       {
    1:         // Shift key is down: append a block selection
80486:         mDragSelectingCells = false;
    1:         return SelectBlockOfCells(mAppendStartSelectedCell, childContent);
    1:       }
    1: 
    1:       if (mDragSelectingCells)
    1:         mAppendStartSelectedCell = mStartSelectedCell;
    1:         
80486:       mDragSelectingCells = false;
    1:       mStartSelectedCell = nsnull;
    1:       mEndSelectedCell = nsnull;
    1: 
    1:       // Any other mouseup actions require that Ctrl or Cmd key is pressed
    1:       //  else stop table selection mode
79445:       bool doMouseUpAction = false;
 6499: #ifdef XP_MACOSX
    1:       doMouseUpAction = aMouseEvent->isMeta;
    1: #else
    1:       doMouseUpAction = aMouseEvent->isControl;
    1: #endif
    1:       if (!doMouseUpAction)
    1:       {
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf("HandleTableSelection: Ending cell selection on mouseup: mAppendStartSelectedCell=%d\n", mAppendStartSelectedCell);
    1: #endif
    1:         return NS_OK;
    1:       }
    1:       // Unselect a cell only if it wasn't
    1:       //  just selected on mousedown
    1:       if( childContent == mUnselectCellOnMouseUp)
    1:       {
    1:         // Scan ranges to find the cell to unselect (the selection range to remove)
26996:         // XXXbz it's really weird that this lives outside the loop, so once we
26996:         // find one we keep looking at it even if we find no more cells...
26996:         nsINode* previousCellParent = nsnull;
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf("HandleTableSelection: Unselecting mUnselectCellOnMouseUp; rangeCount=%d\n", rangeCount);
    1: #endif
    1:         for( PRInt32 i = 0; i < rangeCount; i++)
    1:         {
27584:           // Strong reference, because sometimes we want to remove
27584:           // this range, and then we might be the only owner.
27584:           nsCOMPtr<nsIRange> range = mDomSelections[index]->GetRangeAt(i);
    1:           if (!range) return NS_ERROR_NULL_POINTER;
    1: 
26996:           nsINode* parent = range->GetStartParent();
    1:           if (!parent) return NS_ERROR_NULL_POINTER;
    1: 
26996:           PRInt32 offset = range->StartOffset();
    1:           // Be sure previous selection is a table cell
26996:           nsIContent* child = parent->GetChildAt(offset);
    1:           if (child && IsCell(child))
    1:             previousCellParent = parent;
    1: 
    1:           // We're done if we didn't find parent of a previously-selected cell
    1:           if (!previousCellParent) break;
    1:         
26996:           if (previousCellParent == aParentContent && offset == aContentOffset)
    1:           {
    1:             // Cell is already selected
    1:             if (rangeCount == 1)
    1:             {
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf("HandleTableSelection: Unselecting single selected cell\n");
    1: #endif
    1:               // This was the only cell selected.
    1:               // Collapse to "normal" selection inside the cell
    1:               mStartSelectedCell = nsnull;
    1:               mEndSelectedCell = nsnull;
    1:               mAppendStartSelectedCell = nsnull;
    1:               //TODO: We need a "Collapse to just before deepest child" routine
    1:               // Even better, should we collapse to just after the LAST deepest child
    1:               //  (i.e., at the end of the cell's contents)?
26995:               return mDomSelections[index]->Collapse(childContent, 0);
    1:             }
    1: #ifdef DEBUG_TABLE_SELECTION
    1: printf("HandleTableSelection: Removing cell from multi-cell selection\n");
    1: #endif
    1:             // Unselecting the start of previous block 
    1:             // XXX What do we use now!
    1:             if (childContent == mAppendStartSelectedCell)
    1:                mAppendStartSelectedCell = nsnull;
    1: 
    1:             // Deselect cell by removing its range from selection
    1:             return mDomSelections[index]->RemoveRange(range);
    1:           }
    1:         }
    1:         mUnselectCellOnMouseUp = nsnull;
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsFrameSelection::SelectBlockOfCells(nsIContent *aStartCell, nsIContent *aEndCell)
    1: {
    1:   NS_ENSURE_TRUE(aStartCell, NS_ERROR_NULL_POINTER);
    1:   NS_ENSURE_TRUE(aEndCell, NS_ERROR_NULL_POINTER);
    1:   mEndSelectedCell = aEndCell;
    1: 
    1:   nsCOMPtr<nsIContent> startCell;
    1:   nsresult result = NS_OK;
    1: 
    1:   // If new end cell is in a different table, do nothing
26998:   nsIContent* table = IsInSameTable(aStartCell, aEndCell);
26998:   if (!table) {
    1:     return NS_OK;
26998:   }
    1: 
    1:   // Get starting and ending cells' location in the cellmap
    1:   PRInt32 startRowIndex, startColIndex, endRowIndex, endColIndex;
    1:   result = GetCellIndexes(aStartCell, startRowIndex, startColIndex);
    1:   if(NS_FAILED(result)) return result;
    1:   result = GetCellIndexes(aEndCell, endRowIndex, endColIndex);
    1:   if(NS_FAILED(result)) return result;
    1: 
    1:   if (mDragSelectingCells)
    1:   {
    1:     // Drag selecting: remove selected cells outside of new block limits
32354:     UnselectCells(table, startRowIndex, startColIndex, endRowIndex, endColIndex,
80486:                   true);
32354:   }
32354: 
32354:   // Note that we select block in the direction of user's mouse dragging,
32354:   //  which means start cell may be after the end cell in either row or column
32354:   return AddCellsToSelection(table, startRowIndex, startColIndex,
32354:                              endRowIndex, endColIndex);
32354: }
32354: 
32354: nsresult
32354: nsFrameSelection::UnselectCells(nsIContent *aTableContent,
32354:                                 PRInt32 aStartRowIndex,
32354:                                 PRInt32 aStartColumnIndex,
32354:                                 PRInt32 aEndRowIndex,
32354:                                 PRInt32 aEndColumnIndex,
79445:                                 bool aRemoveOutsideOfCellRange)
32354: {
32354:   PRInt8 index =
32354:     GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
23902:     return NS_ERROR_NULL_POINTER;
    1: 
32354:   nsITableLayout *tableLayout = GetTableLayout(aTableContent);
32354:   if (!tableLayout)
32354:     return NS_ERROR_FAILURE;
32354: 
32531:   PRInt32 minRowIndex = NS_MIN(aStartRowIndex, aEndRowIndex);
32531:   PRInt32 maxRowIndex = NS_MAX(aStartRowIndex, aEndRowIndex);
32531:   PRInt32 minColIndex = NS_MIN(aStartColumnIndex, aEndColumnIndex);
32531:   PRInt32 maxColIndex = NS_MAX(aStartColumnIndex, aEndColumnIndex);
32354: 
27584:   // Strong reference because we sometimes remove the range
27584:   nsCOMPtr<nsIRange> range = GetFirstCellRange();
26997:   nsIContent* cellNode = GetFirstSelectedContent(range);
26997:   NS_PRECONDITION(!range || cellNode, "Must have cellNode if had a range");
    1: 
32354:   PRInt32 curRowIndex, curColIndex;
    1:   while (cellNode)
    1:   {
32354:     nsresult result = GetCellIndexes(cellNode, curRowIndex, curColIndex);
32354:     if (NS_FAILED(result))
32354:       return result;
    1: 
    1: #ifdef DEBUG_TABLE_SELECTION
    1:     if (!range)
32354:       printf("RemoveCellsToSelection -- range is null\n");
    1: #endif
32354: 
32354:     if (range) {
32354:       if (aRemoveOutsideOfCellRange) {
32354:         if (curRowIndex < minRowIndex || curRowIndex > maxRowIndex || 
32354:             curColIndex < minColIndex || curColIndex > maxColIndex) {
32354: 
    1:           mDomSelections[index]->RemoveRange(range);
    1:           // Since we've removed the range, decrement pointer to next range
    1:           mSelectedCellIndex--;
    1:         }
32354: 
32354:       } else {
32354:         // Remove cell from selection if it belongs to the given cells range or
32354:         // it is spanned onto the cells range.
32354:         nsCOMPtr<nsIDOMElement> cellElement;
32354:         PRInt32 origRowIndex, origColIndex, rowSpan, colSpan,
32354:           actualRowSpan, actualColSpan;
79445:         bool isSelected;
32354: 
32354:         result = tableLayout->GetCellDataAt(curRowIndex, curColIndex,
32354:                                             *getter_AddRefs(cellElement),
32354:                                             origRowIndex, origColIndex,
32354:                                             rowSpan, colSpan, 
32354:                                             actualRowSpan, actualColSpan,
32354:                                             isSelected);
32354:         if (NS_FAILED(result))
32354:           return result;
32354: 
32354:         if (origRowIndex <= maxRowIndex &&
32354:             origRowIndex + actualRowSpan - 1 >= minRowIndex &&
32354:             origColIndex <= maxColIndex &&
32354:             origColIndex + actualColSpan - 1 >= minColIndex) {
32354: 
32354:           mDomSelections[index]->RemoveRange(range);
32354:           // Since we've removed the range, decrement pointer to next range
32354:           mSelectedCellIndex--;
32354:         }
32354:       }
32354:     }
32354: 
26997:     range = GetNextCellRange();
26997:     cellNode = GetFirstSelectedContent(range);
26997:     NS_PRECONDITION(!range || cellNode, "Must have cellNode if had a range");
    1:   }
32354: 
32354:   return NS_OK;
32354: }
32354: 
32354: nsresult
32354: nsFrameSelection::AddCellsToSelection(nsIContent *aTableContent,
32354:                                       PRInt32 aStartRowIndex,
32354:                                       PRInt32 aStartColumnIndex,
32354:                                       PRInt32 aEndRowIndex,
32354:                                       PRInt32 aEndColumnIndex)
32354: {
32354:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
32354:   if (!mDomSelections[index])
32354:     return NS_ERROR_NULL_POINTER;
32354: 
 8295:   // Get TableLayout interface to access cell data based on cellmap location
 8295:   // frames are not ref counted, so don't use an nsCOMPtr
32354:   nsITableLayout *tableLayoutObject = GetTableLayout(aTableContent);
32354:   if (!tableLayoutObject) // Check that |table| is a table.
32354:     return NS_ERROR_FAILURE;
32354: 
32354:   nsCOMPtr<nsIDOMElement> cellElement;
32354:   PRInt32 rowSpan, colSpan, actualRowSpan, actualColSpan,
32354:     curRowIndex, curColIndex;
79445:   bool isSelected;
32354:   nsresult result = NS_OK;
32354: 
32354:   PRInt32 row = aStartRowIndex;
80486:   while(true)
32354:   {
32354:     PRInt32 col = aStartColumnIndex;
80486:     while(true)
32354:     {
    1:       result = tableLayoutObject->GetCellDataAt(row, col, *getter_AddRefs(cellElement),
    1:                                                 curRowIndex, curColIndex, rowSpan, colSpan, 
    1:                                                 actualRowSpan, actualColSpan, isSelected);
    1:       if (NS_FAILED(result)) return result;
    1: 
    1:       NS_ASSERTION(actualColSpan, "!actualColSpan is 0!");
    1: 
    1:       // Skip cells that are spanned from previous locations or are already selected
    1:       if (!isSelected && cellElement && row == curRowIndex && col == curColIndex)
    1:       {
26998:         nsCOMPtr<nsIContent> cellContent = do_QueryInterface(cellElement);
26998:         result = SelectCellElement(cellContent);
    1:         if (NS_FAILED(result)) return result;
    1:       }
    1:       // Done when we reach end column
32354:       if (col == aEndColumnIndex) break;
32354: 
32354:       if (aStartColumnIndex < aEndColumnIndex)
    1:         col ++;
    1:       else
    1:         col--;
    1:     };
32354:     if (row == aEndRowIndex) break;
32354: 
32354:     if (aStartRowIndex < aEndRowIndex)
    1:       row++;
    1:     else
    1:       row--;
    1:   };
    1:   return result;
    1: }
    1: 
    1: nsresult
32354: nsFrameSelection::RemoveCellsFromSelection(nsIContent *aTable,
32354:                                            PRInt32 aStartRowIndex,
32354:                                            PRInt32 aStartColumnIndex,
32354:                                            PRInt32 aEndRowIndex,
32354:                                            PRInt32 aEndColumnIndex)
32354: {
32354:   return UnselectCells(aTable, aStartRowIndex, aStartColumnIndex,
80486:                        aEndRowIndex, aEndColumnIndex, false);
32354: }
32354: 
32354: nsresult
32354: nsFrameSelection::RestrictCellsToSelection(nsIContent *aTable,
32354:                                            PRInt32 aStartRowIndex,
32354:                                            PRInt32 aStartColumnIndex,
32354:                                            PRInt32 aEndRowIndex,
32354:                                            PRInt32 aEndColumnIndex)
32354: {
32354:   return UnselectCells(aTable, aStartRowIndex, aStartColumnIndex,
80486:                        aEndRowIndex, aEndColumnIndex, true);
32354: }
32354: 
32354: nsresult
    1: nsFrameSelection::SelectRowOrColumn(nsIContent *aCellContent, PRUint32 aTarget)
    1: {
    1:   if (!aCellContent) return NS_ERROR_NULL_POINTER;
    1: 
26998:   nsIContent* table = GetParentTable(aCellContent);
    1:   if (!table) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Get table and cell layout interfaces to access 
    1:   //   cell data based on cellmap location
    1:   // Frames are not ref counted, so don't use an nsCOMPtr
    1:   nsITableLayout *tableLayout = GetTableLayout(table);
    1:   if (!tableLayout) return NS_ERROR_FAILURE;
    1:   nsITableCellLayout *cellLayout = GetCellLayout(aCellContent);
    1:   if (!cellLayout) return NS_ERROR_FAILURE;
    1: 
    1:   // Get location of target cell:      
    1:   PRInt32 rowIndex, colIndex, curRowIndex, curColIndex;
26998:   nsresult result = cellLayout->GetCellIndexes(rowIndex, colIndex);
    1:   if (NS_FAILED(result)) return result;
    1: 
    1:   // Be sure we start at proper beginning
    1:   // (This allows us to select row or col given ANY cell!)
    1:   if (aTarget == nsISelectionPrivate::TABLESELECTION_ROW)
    1:     colIndex = 0;
    1:   if (aTarget == nsISelectionPrivate::TABLESELECTION_COLUMN)
    1:     rowIndex = 0;
    1: 
    1:   nsCOMPtr<nsIDOMElement> cellElement;
26998:   nsCOMPtr<nsIContent> firstCell;
    1:   nsCOMPtr<nsIDOMElement> lastCell;
    1:   PRInt32 rowSpan, colSpan, actualRowSpan, actualColSpan;
79445:   bool isSelected;
    1: 
    1:   do {
    1:     // Loop through all cells in column or row to find first and last
    1:     result = tableLayout->GetCellDataAt(rowIndex, colIndex, *getter_AddRefs(cellElement),
    1:                                         curRowIndex, curColIndex, rowSpan, colSpan, 
    1:                                         actualRowSpan, actualColSpan, isSelected);
    1:     if (NS_FAILED(result)) return result;
    1:     if (cellElement)
    1:     {
    1:       NS_ASSERTION(actualRowSpan > 0 && actualColSpan> 0, "SelectRowOrColumn: Bad rowspan or colspan\n");
    1:       if (!firstCell)
26998:         firstCell = do_QueryInterface(cellElement);
    1: 
    1:       lastCell = cellElement;
    1: 
    1:       // Move to next cell in cellmap, skipping spanned locations
    1:       if (aTarget == nsISelectionPrivate::TABLESELECTION_ROW)
    1:         colIndex += actualColSpan;
    1:       else
    1:         rowIndex += actualRowSpan;
    1:     }
    1:   }
    1:   while (cellElement);
    1: 
    1:   // Use SelectBlockOfCells:
    1:   // This will replace existing selection,
    1:   //  but allow unselecting by dragging out of selected region
    1:   if (firstCell && lastCell)
    1:   {
    1:     if (!mStartSelectedCell)
    1:     {
    1:       // We are starting a new block, so select the first cell
    1:       result = SelectCellElement(firstCell);
    1:       if (NS_FAILED(result)) return result;
26998:       mStartSelectedCell = firstCell;
    1:     }
    1:     nsCOMPtr<nsIContent> lastCellContent = do_QueryInterface(lastCell);
    1:     result = SelectBlockOfCells(mStartSelectedCell, lastCellContent);
    1: 
    1:     // This gets set to the cell at end of row/col, 
    1:     //   but we need it to be the cell under cursor
    1:     mEndSelectedCell = aCellContent;
    1:     return result;
    1:   }
    1: 
    1: #if 0
    1: // This is a more efficient strategy that appends row to current selection,
    1: //  but doesn't allow dragging OFF of an existing selection to unselect!
    1:   do {
    1:     // Loop through all cells in column or row
    1:     result = tableLayout->GetCellDataAt(rowIndex, colIndex,
    1:                                         getter_AddRefs(cellElement),
    1:                                         curRowIndex, curColIndex,
    1:                                         rowSpan, colSpan,
    1:                                         actualRowSpan, actualColSpan,
    1:                                         isSelected);
    1:     if (NS_FAILED(result)) return result;
    1:     // We're done when cell is not found
    1:     if (!cellElement) break;
    1: 
    1: 
    1:     // Check spans else we infinitely loop
    1:     NS_ASSERTION(actualColSpan, "actualColSpan is 0!");
    1:     NS_ASSERTION(actualRowSpan, "actualRowSpan is 0!");
    1:     
    1:     // Skip cells that are already selected or span from outside our region
    1:     if (!isSelected && rowIndex == curRowIndex && colIndex == curColIndex)
    1:     {
    1:       result = SelectCellElement(cellElement);
    1:       if (NS_FAILED(result)) return result;
    1:     }
    1:     // Move to next row or column in cellmap, skipping spanned locations
    1:     if (aTarget == nsISelectionPrivate::TABLESELECTION_ROW)
    1:       colIndex += actualColSpan;
    1:     else
    1:       rowIndex += actualRowSpan;
    1:   }
    1:   while (cellElement);
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
26997: nsIContent*
26997: nsFrameSelection::GetFirstCellNodeInRange(nsIRange *aRange) const
26997: {
26997:   if (!aRange) return nsnull;
26997: 
26997:   nsINode* startParent = aRange->GetStartParent();
    1:   if (!startParent)
26997:     return nsnull;
26997: 
26997:   PRInt32 offset = aRange->StartOffset();
26997: 
26997:   nsIContent* childContent = startParent->GetChildAt(offset);
    1:   if (!childContent)
26997:     return nsnull;
    1:   // Don't return node if not a cell
26997:   if (!IsCell(childContent))
26997:     return nsnull;
26997: 
26997:   return childContent;
26997: }
26997: 
26997: nsIRange*
26997: nsFrameSelection::GetFirstCellRange()
26997: {
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
26997:     return nsnull;
26997: 
26997:   nsIRange* firstRange = mDomSelections[index]->GetRangeAt(0);
26997:   if (!GetFirstCellNodeInRange(firstRange)) {
26997:     return nsnull;
    1:   }
    1: 
    1:   // Setup for next cell
    1:   mSelectedCellIndex = 1;
    1: 
26997:   return firstRange;
26997: }
26997: 
26997: nsIRange*
26997: nsFrameSelection::GetNextCellRange()
26997: {
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
26997:     return nsnull;
26997: 
26997:   nsIRange* range = mDomSelections[index]->GetRangeAt(mSelectedCellIndex);
    1: 
    1:   // Get first node in next range of selection - test if it's a cell
26997:   if (!GetFirstCellNodeInRange(range)) {
26997:     return nsnull;
    1:   }
    1: 
    1:   // Setup for next cell
    1:   mSelectedCellIndex++;
    1: 
26997:   return range;
    1: }
    1: 
    1: nsresult
    1: nsFrameSelection::GetCellIndexes(nsIContent *aCell,
    1:                                  PRInt32    &aRowIndex,
    1:                                  PRInt32    &aColIndex)
    1: {
    1:   if (!aCell) return NS_ERROR_NULL_POINTER;
    1: 
    1:   aColIndex=0; // initialize out params
    1:   aRowIndex=0;
    1: 
    1:   nsITableCellLayout *cellLayoutObject = GetCellLayout(aCell);
    1:   if (!cellLayoutObject)  return NS_ERROR_FAILURE;
    1:   return cellLayoutObject->GetCellIndexes(aRowIndex, aColIndex);
    1: }
    1: 
26998: nsIContent*
    1: nsFrameSelection::IsInSameTable(nsIContent  *aContent1,
26998:                                 nsIContent  *aContent2) const
    1: {
82039:   if (!aContent1 || !aContent2) return nsnull;
    1:   
26998:   nsIContent* tableNode1 = GetParentTable(aContent1);
26998:   nsIContent* tableNode2 = GetParentTable(aContent2);
26998: 
26998:   // Must be in the same table.  Note that we want to return false for
26998:   // the test if both tables are null.
26998:   return (tableNode1 == tableNode2) ? tableNode1 : nsnull;
26998: }
26998: 
26998: nsIContent*
26998: nsFrameSelection::GetParentTable(nsIContent *aCell) const
26998: {
26998:   if (!aCell) {
26998:     return nsnull;
    1:   }
    1: 
    1:   for (nsIContent* parent = aCell->GetParent(); parent;
    1:        parent = parent->GetParent()) {
    1:     if (parent->Tag() == nsGkAtoms::table &&
33329:         parent->IsHTML()) {
26998:       return parent;
26998:     }
26998:   }
26998: 
26998:   return nsnull;
26998: }
26998: 
    1: nsresult
26998: nsFrameSelection::SelectCellElement(nsIContent *aCellElement)
26998: {
26998:   nsIContent *parent = aCellElement->GetParent();
    1: 
    1:   // Get child offset
26998:   PRInt32 offset = parent->IndexOf(aCellElement);
    1: 
26996:   return CreateAndAddRange(parent, offset);
    1: }
    1: 
    1: nsresult
26992: nsTypedSelection::getTableCellLocationFromRange(nsIRange *aRange, PRInt32 *aSelectionType, PRInt32 *aRow, PRInt32 *aCol)
26992: {
    1:   if (!aRange || !aSelectionType || !aRow || !aCol)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aSelectionType = nsISelectionPrivate::TABLESELECTION_NONE;
    1:   *aRow = 0;
    1:   *aCol = 0;
    1: 
    1:   // Must have access to frame selection to get cell info
    1:   if (!mFrameSelection) return NS_OK;
    1: 
26996:   nsresult result = GetTableSelectionType(aRange, aSelectionType);
    1:   if (NS_FAILED(result)) return result;
    1:   
    1:   // Don't fail if range does not point to a single table cell,
    1:   //  let aSelectionType tell user if we don't have a cell
    1:   if (*aSelectionType  != nsISelectionPrivate::TABLESELECTION_CELL)
    1:     return NS_OK;
    1: 
    1:   // Get the child content (the cell) pointed to by starting node of range
    1:   // We do minimal checking since GetTableSelectionType assures
    1:   //   us that this really is a table cell
26992:   nsCOMPtr<nsIContent> content = do_QueryInterface(aRange->GetStartParent());
    1:   if (!content)
    1:     return NS_ERROR_FAILURE;
26992: 
26992:   nsIContent *child = content->GetChildAt(aRange->StartOffset());
    1:   if (!child)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   //Note: This is a non-ref-counted pointer to the frame
    1:   nsITableCellLayout *cellLayout = mFrameSelection->GetCellLayout(child);
    1:   if (NS_FAILED(result))
    1:     return result;
    1:   if (!cellLayout)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return cellLayout->GetCellIndexes(*aRow, *aCol);
    1: }
    1: 
    1: nsresult
79445: nsTypedSelection::addTableCellRange(nsIRange *aRange, bool *aDidAddRange,
13767:                                     PRInt32 *aOutIndex)
13767: {  
13767:   if (!aDidAddRange || !aOutIndex)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
80486:   *aDidAddRange = false;
13767:   *aOutIndex = -1;
    1: 
    1:   if (!mFrameSelection)
    1:     return NS_OK;
    1: 
    1:   if (!aRange)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsresult result;
    1: 
    1:   // Get if we are adding a cell selection and the row, col of cell if we are
    1:   PRInt32 newRow, newCol, tableMode;
    1:   result = getTableCellLocationFromRange(aRange, &tableMode, &newRow, &newCol);
    1:   if (NS_FAILED(result)) return result;
    1:   
    1:   // If not adding a cell range, we are done here
    1:   if (tableMode != nsISelectionPrivate::TABLESELECTION_CELL)
    1:   {
    1:     mFrameSelection->mSelectingTableCellMode = tableMode;
    1:     // Don't fail if range isn't a selected cell, aDidAddRange tells caller if we didn't proceed
    1:     return NS_OK;
    1:   }
    1:   
    1:   // Set frame selection mode only if not already set to a table mode
30710:   //  so we don't lose the select row and column flags (not detected by getTableCellLocation)
    1:   if (mFrameSelection->mSelectingTableCellMode == TABLESELECTION_NONE)
    1:     mFrameSelection->mSelectingTableCellMode = tableMode;
    1: 
80486:   *aDidAddRange = true;
13767:   return AddItem(aRange, aOutIndex);
    1: }
    1: 
    1: //TODO: Figure out TABLESELECTION_COLUMN and TABLESELECTION_ALLCELLS
    1: NS_IMETHODIMP
26996: nsTypedSelection::GetTableSelectionType(nsIDOMRange* aRange,
26996:                                         PRInt32* aTableSelectionType)
26996: {
26996:   nsCOMPtr<nsIRange> range = do_QueryInterface(aRange);
26996:   return GetTableSelectionType(range, aTableSelectionType);
26996: }
26996: 
26996: nsresult
26996: nsTypedSelection::GetTableSelectionType(nsIRange* aRange,
26996:                                         PRInt32* aTableSelectionType)
    1: {
    1:   if (!aRange || !aTableSelectionType)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   *aTableSelectionType = nsISelectionPrivate::TABLESELECTION_NONE;
    1:  
    1:   // Must have access to frame selection to get cell info
    1:   if(!mFrameSelection) return NS_OK;
    1: 
26996:   nsINode* startNode = aRange->GetStartParent();
    1:   if (!startNode) return NS_ERROR_FAILURE;
    1:   
26996:   nsINode* endNode = aRange->GetEndParent();
    1:   if (!endNode) return NS_ERROR_FAILURE;
    1: 
    1:   // Not a single selected node
    1:   if (startNode != endNode) return NS_OK;
    1: 
26996:   PRInt32 startOffset = aRange->StartOffset();
26996:   PRInt32 endOffset = aRange->EndOffset();
    1: 
    1:   // Not a single selected node
    1:   if ((endOffset - startOffset) != 1)
    1:     return NS_OK;
    1: 
33329:   nsIContent* startContent = static_cast<nsIContent*>(startNode);
41641:   if (!(startNode->IsElement() && startContent->IsHTML())) {
26996:     // Implies a check for being an element; if we ever make this work
26996:     // for non-HTML, need to keep checking for elements.
    1:     return NS_OK;
    1:   }
    1: 
33329:   nsIAtom *tag = startContent->Tag();
    1: 
    1:   if (tag == nsGkAtoms::tr)
    1:   {
    1:     *aTableSelectionType = nsISelectionPrivate::TABLESELECTION_CELL;
    1:   }
    1:   else //check to see if we are selecting a table or row (column and all cells not done yet)
    1:   {
26996:     nsIContent *child = startNode->GetChildAt(startOffset);
    1:     if (!child)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     tag = child->Tag();
    1: 
    1:     if (tag == nsGkAtoms::table)
    1:       *aTableSelectionType = nsISelectionPrivate::TABLESELECTION_TABLE;
    1:     else if (tag == nsGkAtoms::tr)
    1:       *aTableSelectionType = nsISelectionPrivate::TABLESELECTION_ROW;
    1:   }
    1: 
26996:   return NS_OK;
    1: }
    1: 
    1: nsresult
26996: nsFrameSelection::CreateAndAddRange(nsINode *aParentNode, PRInt32 aOffset)
    1: {
    1:   if (!aParentNode) return NS_ERROR_NULL_POINTER;
26996: 
26996:   nsCOMPtr<nsIRange> range = new nsRange();
    1: 
    1:   // Set range around child at given offset
    1:   nsresult result = range->SetStart(aParentNode, aOffset);
    1:   if (NS_FAILED(result)) return result;
    1:   result = range->SetEnd(aParentNode, aOffset+1);
    1:   if (NS_FAILED(result)) return result;
    1:   
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
23902:     return NS_ERROR_NULL_POINTER;
23902: 
    1:   return mDomSelections[index]->AddRange(range);
    1: }
    1: 
    1: // End of Table Selection
    1: 
 2896: void
 2896: nsFrameSelection::SetAncestorLimiter(nsIContent *aLimiter)
 2896: {
 2896:   if (mAncestorLimiter != aLimiter) {
 2896:     mAncestorLimiter = aLimiter;
 2896:     PRInt8 index =
 2896:       GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:     if (!mDomSelections[index])
23902:       return;
23902: 
26994:     if (!IsValidSelectionPoint(this, mDomSelections[index]->GetFocusNode())) {
 2896:       ClearNormalSelection();
 2896:       if (mAncestorLimiter) {
 2896:         PostReason(nsISelectionListener::NO_REASON);
80486:         TakeFocus(mAncestorLimiter, 0, 0, HINTLEFT, false, false);
 2896:       }
 2896:     }
 2896:   }
 2896: }
 2896: 
    1: //END nsFrameSelection methods
    1: 
    1: 
    1: //BEGIN nsISelection interface implementations
    1: 
    1: 
    1: 
    1: nsresult
    1: nsFrameSelection::DeleteFromDocument()
    1: {
    1:   nsresult res;
    1: 
    1:   // If we're already collapsed, then set ourselves to include the
    1:   // last item BEFORE the current range, rather than the range itself,
    1:   // before we do the delete.
79445:   bool isCollapsed;
    1:   PRInt8 index = GetIndexFromSelectionType(nsISelectionController::SELECTION_NORMAL);
23902:   if (!mDomSelections[index])
23902:     return NS_ERROR_NULL_POINTER;
23902: 
    1:   mDomSelections[index]->GetIsCollapsed( &isCollapsed);
    1:   if (isCollapsed)
    1:   {
    1:     // If the offset is positive, then it's easy:
26992:     if (mDomSelections[index]->GetFocusOffset() > 0)
26992:     {
26994:       mDomSelections[index]->Extend(mDomSelections[index]->GetFocusNode(), mDomSelections[index]->GetFocusOffset() - 1);
    1:     }
    1:     else
    1:     {
    1:       // Otherwise it's harder, have to find the previous node
    1:       printf("Sorry, don't know how to delete across frame boundaries yet\n");
    1:       return NS_ERROR_NOT_IMPLEMENTED;
    1:     }
    1:   }
    1: 
    1:   // Get an iterator
    1:   nsSelectionIterator iter(mDomSelections[index]);
    1:   res = iter.First();
    1:   if (NS_FAILED(res))
    1:     return res;
    1: 
    1:   while (iter.IsDone())
    1:   {
26995:     nsCOMPtr<nsIRange> range = iter.CurrentItem();
    1:     res = range->DeleteContents();
    1:     if (NS_FAILED(res))
    1:       return res;
    1:     iter.Next();
    1:   }
    1: 
    1:   // Collapse to the new location.
    1:   // If we deleted one character, then we move back one element.
    1:   // FIXME  We don't know how to do this past frame boundaries yet.
    1:   if (isCollapsed)
26994:     mDomSelections[index]->Collapse(mDomSelections[index]->GetAnchorNode(), mDomSelections[index]->GetAnchorOffset()-1);
26992:   else if (mDomSelections[index]->GetAnchorOffset() > 0)
26994:     mDomSelections[index]->Collapse(mDomSelections[index]->GetAnchorNode(), mDomSelections[index]->GetAnchorOffset());
    1: #ifdef DEBUG
    1:   else
    1:     printf("Don't know how to set selection back past frame boundary\n");
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameSelection::SetDelayedCaretData(nsMouseEvent *aMouseEvent)
    1: {
    1:   if (aMouseEvent)
    1:   {
80486:     mDelayedMouseEventValid = true;
    1:     mDelayedMouseEvent      = *aMouseEvent;
    1: 
    1:     // Don't cache the widget.  We don't need it and it could go away.
    1:     mDelayedMouseEvent.widget = nsnull;
    1:   }
    1:   else
80486:     mDelayedMouseEventValid = false;
    1: }
    1: 
    1: nsMouseEvent*
    1: nsFrameSelection::GetDelayedCaretData()
    1: {
    1:   if (mDelayedMouseEventValid)
    1:     return &mDelayedMouseEvent;
    1:   
    1:   return nsnull;
    1: }
    1: 
85101: void
85101: nsFrameSelection::DisconnectFromPresShell()
85101: {
85101:   StopAutoScrollTimer();
85101:   for (PRInt32 i = 0; i < nsISelectionController::NUM_SELECTIONTYPES; i++) {
85101:     mDomSelections[i]->Clear(nsnull);
85101:   }
85101:   mShell = nsnull;
85101: }
85101: 
    1: //END nsISelection interface implementations
    1: 
    1: #if 0
    1: #pragma mark -
    1: #endif
    1: 
    1: // nsTypedSelection implementation
    1: 
    1: // note: this can return a nil anchor node
    1: 
12258: nsTypedSelection::nsTypedSelection()
23902:   : mCachedOffsetForFrame(nsnull)
12258:   , mDirection(eDirNext)
12258:   , mType(nsISelectionController::SELECTION_NORMAL)
12258: {
12258: }
12258: 
    1: nsTypedSelection::nsTypedSelection(nsFrameSelection *aList)
12258:   : mFrameSelection(aList)
12258:   , mCachedOffsetForFrame(nsnull)
12258:   , mDirection(eDirNext)
12258:   , mType(nsISelectionController::SELECTION_NORMAL)
12258: {
12258: }
    1: 
    1: nsTypedSelection::~nsTypedSelection()
    1: {
    1:   setAnchorFocusRange(-1);
    1: 
85101:   PRUint32 count = mRanges.Length();
85101:   for (PRUint32 i = 0; i < count; ++i) {
85101:     mRanges[i].mRange->SetInSelection(false);
85101:   }
85101: 
    1:   if (mAutoScrollTimer) {
    1:     mAutoScrollTimer->Stop();
    1:     mAutoScrollTimer = nsnull;
    1:   }
    1: 
    1:   mScrollEvent.Revoke();
    1: 
    1:   if (mCachedOffsetForFrame) {
    1:     delete mCachedOffsetForFrame;
    1:     mCachedOffsetForFrame = nsnull;
    1:   }
23902: }
23902: 
23902: 
23902: NS_IMPL_CYCLE_COLLECTION_CLASS(nsTypedSelection)
23902: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsTypedSelection)
28156:   // Unlink the selection listeners *before* we do RemoveAllRanges since
28156:   // we don't want to notify the listeners during JS GC (they could be
28156:   // in JS!).
28156:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mSelectionListeners)
23902:   tmp->RemoveAllRanges();
23902:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFrameSelection)
23902: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
23902: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsTypedSelection)
23902:   {
23902:     PRUint32 i, count = tmp->mRanges.Length();
23902:     for (i = 0; i < count; ++i) {
23902:       NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRanges[i].mRange)
23902:     }
23902:   }
23902:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAnchorFocusRange)
70355:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFrameSelection)
28156:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mSelectionListeners)
23902: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
23902: 
40490: DOMCI_DATA(Selection, nsTypedSelection)
40490: 
23902: // QueryInterface implementation for nsTypedSelection
23902: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsTypedSelection)
    1:   NS_INTERFACE_MAP_ENTRY(nsISelection)
    1:   NS_INTERFACE_MAP_ENTRY(nsISelectionPrivate)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsISelection)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Selection)
    1: NS_INTERFACE_MAP_END
    1: 
23902: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsTypedSelection)
23902: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsTypedSelection)
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::SetPresShell(nsIPresShell *aPresShell)
    1: {
    1:   mPresShellWeak = do_GetWeakReference(aPresShell);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetAnchorNode(nsIDOMNode** aAnchorNode)
    1: {
26992:   nsINode* anchorNode = GetAnchorNode();
26992:   if (anchorNode) {
26992:     return CallQueryInterface(anchorNode, aAnchorNode);
26992:   }
26992: 
    1:   *aAnchorNode = nsnull;
26992:   return NS_OK;
26992: }
26992: 
26992: nsINode*
26992: nsTypedSelection::GetAnchorNode()
26992: {
    1:   if (!mAnchorFocusRange)
26992:     return nsnull;
26992:    
    1:   if (GetDirection() == eDirNext) {
26992:     return mAnchorFocusRange->GetStartParent();
26992:   }
26992: 
26992:   return mAnchorFocusRange->GetEndParent();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetAnchorOffset(PRInt32* aAnchorOffset)
    1: {
26992:   *aAnchorOffset = GetAnchorOffset();
    1:   return NS_OK;
    1: }
    1: 
    1: // note: this can return a nil focus node
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetFocusNode(nsIDOMNode** aFocusNode)
    1: {
26992:   nsINode* focusNode = GetFocusNode();
26992:   if (focusNode) {
26992:     return CallQueryInterface(focusNode, aFocusNode);
26992:   }
26992: 
    1:   *aFocusNode = nsnull;
26992:   return NS_OK;
26992: }
26992: 
26992: nsINode*
26992: nsTypedSelection::GetFocusNode()
26992: {
    1:   if (!mAnchorFocusRange)
26992:     return nsnull;
26992: 
26992:   if (GetDirection() == eDirNext){
26992:     return mAnchorFocusRange->GetEndParent();
26992:   }
26992: 
26992:   return mAnchorFocusRange->GetStartParent();
26992: }
26992: 
26992: NS_IMETHODIMP nsTypedSelection::GetFocusOffset(PRInt32* aFocusOffset)
26992: {
26992:   *aFocusOffset = GetFocusOffset();
    1:   return NS_OK;
26992: }
    1: 
    1: void nsTypedSelection::setAnchorFocusRange(PRInt32 indx)
    1: {
    1:   if (indx >= (PRInt32)mRanges.Length())
    1:     return;
    1:   if (indx < 0) //release all
    1:   {
    1:     mAnchorFocusRange = nsnull;
    1:   }
    1:   else{
    1:     mAnchorFocusRange = mRanges[indx].mRange;
    1:   }
    1: }
    1: 
    1: PRInt32
26992: nsTypedSelection::GetAnchorOffset()
26992: {
26992:   if (!mAnchorFocusRange)
    1:     return 0;
26992: 
26992:   if (GetDirection() == eDirNext){
26992:     return mAnchorFocusRange->StartOffset();
26992:   }
26992: 
26992:   return mAnchorFocusRange->EndOffset();
26992: }
    1: 
    1: PRInt32
26992: nsTypedSelection::GetFocusOffset()
26992: {
26992:   if (!mAnchorFocusRange)
    1:     return 0;
26992: 
26992:   if (GetDirection() == eDirNext){
26992:     return mAnchorFocusRange->EndOffset();
26992:   }
26992: 
26992:   return mAnchorFocusRange->StartOffset();
26992: }
26992: 
33462: static nsresult
26992: CompareToRangeStart(nsINode* aCompareNode, PRInt32 aCompareOffset,
33462:                     nsIRange* aRange, PRInt32* aCmp)
33462: {
33462:   nsINode* start = aRange->GetStartParent();
33462:   NS_ENSURE_STATE(aCompareNode && start);
55120:   // If the nodes that we're comparing are not in the same document,
55120:   // assume that aCompareNode will fall at the end of the ranges.
55120:   if (aCompareNode->GetCurrentDoc() != start->GetCurrentDoc() ||
55120:       !start->GetCurrentDoc()) {
55120:     *aCmp = 1;
55120:   } else {
33462:     *aCmp = nsContentUtils::ComparePoints(aCompareNode, aCompareOffset,
33462:                                           start, aRange->StartOffset());
55120:   }
33462:   return NS_OK;
33462: }
33462: 
33462: static nsresult
26992: CompareToRangeEnd(nsINode* aCompareNode, PRInt32 aCompareOffset,
33462:                   nsIRange* aRange, PRInt32* aCmp)
33462: {
33462:   nsINode* end = aRange->GetEndParent();
33462:   NS_ENSURE_STATE(aCompareNode && end);
55120:   // If the nodes that we're comparing are not in the same document,
55120:   // assume that aCompareNode will fall at the end of the ranges.
55120:   if (aCompareNode->GetCurrentDoc() != end->GetCurrentDoc() ||
55120:       !end->GetCurrentDoc()) {
55120:     *aCmp = 1;
55120:   } else {
33462:     *aCmp = nsContentUtils::ComparePoints(aCompareNode, aCompareOffset,
33462:                                           end, aRange->EndOffset());
55120:   }
33462:   return NS_OK;
    1: }
    1: 
    1: // nsTypedSelection::FindInsertionPoint
    1: //
28161: //    Binary searches the given sorted array of ranges for the insertion point
28161: //    for the given node/offset. The given comparator is used, and the index
28161: //    where the point should appear in the array is placed in *aInsertionPoint.
    1: //
28161: //    If there is an item in the array equal to the input point, we will return
28161: //    the index of this item.
    1: 
33462: nsresult
    1: nsTypedSelection::FindInsertionPoint(
28161:     nsTArray<RangeData>* aElementArray,
26992:     nsINode* aPointNode, PRInt32 aPointOffset,
33462:     nsresult (*aComparator)(nsINode*,PRInt32,nsIRange*,PRInt32*),
33462:     PRInt32* aPoint)
33462: {
33462:   *aPoint = 0;
    1:   PRInt32 beginSearch = 0;
28161:   PRInt32 endSearch = aElementArray->Length(); // one beyond what to check
    1:   while (endSearch - beginSearch > 0) {
    1:     PRInt32 center = (endSearch - beginSearch) / 2 + beginSearch;
    1: 
28161:     nsIRange* range = (*aElementArray)[center].mRange;
    1: 
33462:     PRInt32 cmp;
33462:     nsresult rv = aComparator(aPointNode, aPointOffset, range, &cmp);
33462:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (cmp < 0) {        // point < cur
    1:       endSearch = center;
    1:     } else if (cmp > 0) { // point > cur
    1:       beginSearch = center + 1;
    1:     } else {              // found match, done
    1:       beginSearch = center;
    1:       break;
    1:     }
    1:   }
33462:   *aPoint = beginSearch;
33462:   return NS_OK;
    1: }
    1: 
28161: // nsTypedSelection::SubtractRange
28161: //
28161: //    A helper function that subtracts aSubtract from aRange, and adds
28162: //    1 or 2 RangeData objects representing the remaining non-overlapping
28162: //    difference to aOutput. It is assumed that the caller has checked that
28162: //    aRange and aSubtract do indeed overlap
28161: 
28161: nsresult
28161: nsTypedSelection::SubtractRange(RangeData* aRange, nsIRange* aSubtract,
28161:                                 nsTArray<RangeData>* aOutput)
28161: {
28161:   nsIRange* range = aRange->mRange;
28161: 
28161:   // First we want to compare to the range start
33462:   PRInt32 cmp;
33462:   nsresult rv = CompareToRangeStart(range->GetStartParent(),
28161:                                     range->StartOffset(),
33462:                                     aSubtract, &cmp);
33462:   NS_ENSURE_SUCCESS(rv, rv);
28161: 
28161:   // Also, make a comparison to the range end
33462:   PRInt32 cmp2;
33462:   rv = CompareToRangeEnd(range->GetEndParent(),
28161:                          range->EndOffset(),
33462:                          aSubtract, &cmp2);
33462:   NS_ENSURE_SUCCESS(rv, rv);
28161: 
28161:   // If the existing range left overlaps the new range (aSubtract) then
28161:   // cmp < 0, and cmp2 < 0
28161:   // If it right overlaps the new range then cmp > 0 and cmp2 > 0
28161:   // If it fully contains the new range, then cmp < 0 and cmp2 > 0
28161: 
28161:   if (cmp2 > 0) {
28161:     // We need to add a new RangeData to the output, running from
28161:     // the end of aSubtract to the end of range
28161:     nsIRange* postOverlap = new nsRange();
28161: 
33462:     rv =
28161:       postOverlap->SetStart(aSubtract->GetEndParent(), aSubtract->EndOffset());
28161:     NS_ENSURE_SUCCESS(rv, rv);
28161:     rv =
28161:      postOverlap->SetEnd(range->GetEndParent(), range->EndOffset());
28161:     NS_ENSURE_SUCCESS(rv, rv);
28161:     if (!postOverlap->Collapsed()) {
28161:       if (!aOutput->InsertElementAt(0, RangeData(postOverlap)))
28161:         return NS_ERROR_OUT_OF_MEMORY;
28161:       (*aOutput)[0].mTextRangeStyle = aRange->mTextRangeStyle;
28161:     }
28161:   }
28161: 
28161:   if (cmp < 0) {
28161:     // We need to add a new RangeData to the output, running from
28161:     // the start of the range to the start of aSubtract
28161:     nsIRange* preOverlap = new nsRange();
28161: 
28161:     nsresult rv =
28161:      preOverlap->SetStart(range->GetStartParent(), range->StartOffset());
28161:     NS_ENSURE_SUCCESS(rv, rv);
28161:     rv =
28161:      preOverlap->SetEnd(aSubtract->GetStartParent(), aSubtract->StartOffset());
28161:     NS_ENSURE_SUCCESS(rv, rv);
28161:     
28161:     if (!preOverlap->Collapsed()) {
28161:       if (!aOutput->InsertElementAt(0, RangeData(preOverlap)))
28161:         return NS_ERROR_OUT_OF_MEMORY;
28161:       (*aOutput)[0].mTextRangeStyle = aRange->mTextRangeStyle;
28161:     }
28161:   }
28161: 
28161:   return NS_OK;
28161: }
28161: 
    1: nsresult
26992: nsTypedSelection::AddItem(nsIRange *aItem, PRInt32 *aOutIndex)
26992: {
    1:   if (!aItem)
    1:     return NS_ERROR_NULL_POINTER;
26992:   if (!aItem->IsPositioned())
26992:     return NS_ERROR_UNEXPECTED;
13767:   if (aOutIndex)
13767:     *aOutIndex = -1;
    1: 
    1:   // a common case is that we have no ranges yet
    1:   if (mRanges.Length() == 0) {
28161:     if (!mRanges.AppendElement(RangeData(aItem)))
    1:       return NS_ERROR_OUT_OF_MEMORY;
85101:     aItem->SetInSelection(true);
85101: 
13767:     if (aOutIndex)
13767:       *aOutIndex = 0;
    1:     return NS_OK;
    1:   }
    1: 
28161:   PRInt32 startIndex, endIndex;
28161:   GetIndicesForInterval(aItem->GetStartParent(), aItem->StartOffset(),
28161:                         aItem->GetEndParent(), aItem->EndOffset(),
80486:                         false, &startIndex, &endIndex);
28161: 
28161:   if (endIndex == -1) {
28161:     // All ranges start after the given range. We can insert our range at
28161:     // position 0, knowing there are no overlaps (handled below)
28161:     startIndex = 0;
28161:     endIndex = 0;
28161:   } else if (startIndex == -1) {
28161:     // All ranges end before the given range. We can insert our range at
28161:     // the end of the array, knowing there are no overlaps (handled below)
28161:     startIndex = mRanges.Length();
33042:     endIndex = startIndex;
28161:   }
28161: 
28161:   // If the range is already contained in mRanges, silently succeed
79445:   bool sameRange = EqualsRangeAtPoint(aItem->GetStartParent(),
26992:                                         aItem->StartOffset(),
26992:                                         aItem->GetEndParent(),
28161:                                         aItem->EndOffset(), startIndex);
28161:   if (sameRange) {
31375:     if (aOutIndex)
28161:       *aOutIndex = startIndex;
    1:     return NS_OK;
    1:   }
    1: 
33042:   if (startIndex == endIndex) {
33042:     // The new range doesn't overlap any existing ranges
33042:     if (!mRanges.InsertElementAt(startIndex, RangeData(aItem)))
33042:       return NS_ERROR_OUT_OF_MEMORY;
85101:     aItem->SetInSelection(true);
33042:     if (aOutIndex)
33042:       *aOutIndex = startIndex;
33042:     return NS_OK;
33042:   }
33042: 
28161:   // We now know that at least 1 existing range overlaps with the range that
28161:   // we are trying to add. In fact, the only ranges of interest are those at
28161:   // the two end points, startIndex and endIndex - 1 (which may point to the
28161:   // same range) as these may partially overlap the new range. Any ranges
28161:   // between these indices are fully overlapped by the new range, and so can be
28161:   // removed
28161:   nsTArray<RangeData> overlaps;
28161:   if (!overlaps.InsertElementAt(0, mRanges[startIndex]))
    1:     return NS_ERROR_OUT_OF_MEMORY;
28161: 
28161:   if (endIndex - 1 != startIndex) {
28161:     if (!overlaps.InsertElementAt(1, mRanges[endIndex - 1]))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
28161:   // Remove all the overlapping ranges
85101:   for (PRInt32 i = startIndex; i < endIndex; ++i) {
85101:     mRanges[i].mRange->SetInSelection(false);
85101:   }
28161:   mRanges.RemoveElementsAt(startIndex, endIndex - startIndex);
28161: 
28161:   nsTArray<RangeData> temp;
28161:   for (PRInt32 i = overlaps.Length() - 1; i >= 0; i--) {
28161:     nsresult rv = SubtractRange(&overlaps[i], aItem, &temp);
28161:     NS_ENSURE_SUCCESS(rv, rv);
28161:   }
28161: 
28161:   // Insert the new element into our "leftovers" array
33462:   PRInt32 insertionPoint;
33462:   nsresult rv = FindInsertionPoint(&temp, aItem->GetStartParent(),
28161:                                    aItem->StartOffset(),
33462:                                    CompareToRangeStart,
33462:                                    &insertionPoint);
33462:   NS_ENSURE_SUCCESS(rv, rv);
28161: 
28161:   if (!temp.InsertElementAt(insertionPoint, RangeData(aItem)))
28161:     return NS_ERROR_OUT_OF_MEMORY;
28161: 
28161:   // Merge the leftovers back in to mRanges
28161:   if (!mRanges.InsertElementsAt(startIndex, temp))
28161:     return NS_ERROR_OUT_OF_MEMORY;
28161: 
85101:   for (PRUint32 i = 0; i < temp.Length(); ++i) {
85101:     temp[i].mRange->SetInSelection(true);
85101:   }
85101: 
32963:   *aOutIndex = startIndex + insertionPoint;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
26992: nsTypedSelection::RemoveItem(nsIRange *aItem)
    1: {
    1:   if (!aItem)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Find the range's index & remove it. We could use FindInsertionPoint to
    1:   // get O(log n) time, but that requires many expensive DOM comparisons.
    1:   // For even several thousand items, this is probably faster because the
    1:   // comparisons are so fast.
    1:   PRInt32 idx = -1;
    1:   PRUint32 i;
    1:   for (i = 0; i < mRanges.Length(); i ++) {
    1:     if (mRanges[i].mRange == aItem) {
    1:       idx = (PRInt32)i;
    1:       break;
    1:     }
    1:   }
    1:   if (idx < 0)
    1:     return NS_ERROR_INVALID_ARG;
28161: 
    1:   mRanges.RemoveElementAt(idx);
85101:   aItem->SetInSelection(false);
    1:   return NS_OK;
    1: }
    1: 
20590: nsresult
20590: nsTypedSelection::RemoveCollapsedRanges()
20590: {
20590:   PRUint32 i = 0;
20590:   while (i < mRanges.Length()) {
26992:     if (mRanges[i].mRange->Collapsed()) {
26992:       nsresult rv = RemoveItem(mRanges[i].mRange);
20590:       NS_ENSURE_SUCCESS(rv, rv);
20590:     } else {
20590:       ++i;
20590:     }
20590:   }
20590:   return NS_OK;
20590: }
    1: 
    1: nsresult
    1: nsTypedSelection::Clear(nsPresContext* aPresContext)
    1: {
    1:   setAnchorFocusRange(-1);
    1: 
85101:   for (PRUint32 i = 0; i < mRanges.Length(); ++i) {
85101:     mRanges[i].mRange->SetInSelection(false);
85101:     selectFrames(aPresContext, mRanges[i].mRange, false);
26992:   }
    1:   mRanges.Clear();
    1: 
    1:   // Reset direction so for more dependable table selection range handling
    1:   SetDirection(eDirNext);
    1: 
    1:   // If this was an ATTENTION selection, change it back to normal now
23902:   if (mFrameSelection &&
23902:       mFrameSelection->GetDisplaySelection() ==
    1:       nsISelectionController::SELECTION_ATTENTION) {
    1:     mFrameSelection->SetDisplaySelection(nsISelectionController::SELECTION_ON);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
16001: NS_IMETHODIMP
16001: nsTypedSelection::GetType(PRInt16 *aType)
16001: {
16001:   NS_ENSURE_ARG_POINTER(aType);
16001:   *aType = mType;
16001: 
16001:   return NS_OK;
16001: }
16001: 
33042: // RangeMatches*Point
33042: //
33042: //    Compares the range beginning or ending point, and returns true if it
33042: //    exactly matches the given DOM point.
33042: 
79445: static inline bool
33042: RangeMatchesBeginPoint(nsIRange* aRange, nsINode* aNode, PRInt32 aOffset)
33042: {
33042:   return aRange->GetStartParent() == aNode && aRange->StartOffset() == aOffset;
33042: }
33042: 
79445: static inline bool
33042: RangeMatchesEndPoint(nsIRange* aRange, nsINode* aNode, PRInt32 aOffset)
33042: {
33042:   return aRange->GetEndParent() == aNode && aRange->EndOffset() == aOffset;
33042: }
33042: 
33042: // nsTypedSelection::EqualsRangeAtPoint
33042: //
33042: //    Utility method for checking equivalence of two ranges.
33042: 
79445: bool
33042: nsTypedSelection::EqualsRangeAtPoint(
33042:     nsINode* aBeginNode, PRInt32 aBeginOffset,
33042:     nsINode* aEndNode, PRInt32 aEndOffset,
33042:     PRInt32 aRangeIndex)
33042: {
33042:   if (aRangeIndex >=0 && aRangeIndex < (PRInt32) mRanges.Length()) {
33042:     nsIRange* range = mRanges[aRangeIndex].mRange;
33042:     if (RangeMatchesBeginPoint(range, aBeginNode, aBeginOffset) &&
33042:         RangeMatchesEndPoint(range, aEndNode, aEndOffset))
80486:       return true;
80486:   }
80486:   return false;
33042: }
33042: 
    1: // nsTypedSelection::GetRangesForInterval
    1: //
    1: //    XPCOM wrapper for the COMArray version
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetRangesForInterval(nsIDOMNode* aBeginNode, PRInt32 aBeginOffset,
    1:                                        nsIDOMNode* aEndNode, PRInt32 aEndOffset,
79445:                                        bool aAllowAdjacent,
    1:                                        PRUint32 *aResultCount,
    1:                                        nsIDOMRange ***aResults)
    1: {
    1:   if (!aBeginNode || ! aEndNode || ! aResultCount || ! aResults)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aResultCount = 0;
    1:   *aResults = nsnull;
    1: 
    1:   nsCOMArray<nsIDOMRange> results;
    1:   nsresult rv = GetRangesForIntervalCOMArray(aBeginNode, aBeginOffset,
    1:                                              aEndNode, aEndOffset,
    1:                                              aAllowAdjacent,
    1:                                              &results);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (results.Count() == 0)
    1:     return NS_OK;
    1: 
 3233:   *aResults = static_cast<nsIDOMRange**>
 3233:                          (nsMemory::Alloc(sizeof(nsIDOMRange*) * results.Count()));
    1:   NS_ENSURE_TRUE(*aResults, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   *aResultCount = results.Count();
    1:   for (PRInt32 i = 0; i < results.Count(); i ++)
    1:     NS_ADDREF((*aResults)[i] = results[i]);
    1:   return NS_OK;
    1: }
    1: 
    1: // nsTypedSelection::GetRangesForIntervalCOMArray
    1: //
    1: //    Fills a COM array with the ranges overlapping the range specified by
    1: //    the given endpoints. Ranges in the selection exactly adjacent to the
    1: //    input range are not returned unless aAllowAdjacent is set.
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetRangesForIntervalCOMArray(nsIDOMNode* aBeginNode, PRInt32 aBeginOffset,
    1:                                                nsIDOMNode* aEndNode, PRInt32 aEndOffset,
79445:                                                bool aAllowAdjacent,
    1:                                                nsCOMArray<nsIDOMRange>* aRanges)
    1: {
26992:   nsCOMPtr<nsINode> begin = do_QueryInterface(aBeginNode);
26992:   nsCOMPtr<nsINode> end = do_QueryInterface(aEndNode);
26992:   nsCOMArray<nsIRange> ranges;
26992:   nsresult rv = GetRangesForIntervalCOMArray(begin, aBeginOffset,
26992:                                              end, aEndOffset,
26992:                                              aAllowAdjacent, &ranges);
26992:   NS_ENSURE_SUCCESS(rv, rv);
26992:   for (PRInt32 i = 0; i < ranges.Count(); ++i) {
26992:     nsCOMPtr<nsIDOMRange> r = do_QueryInterface(ranges[i]);
26992:     if (!aRanges->AppendObject(r)) {
26992:       return NS_ERROR_OUT_OF_MEMORY;
26992:     }
26992:   }
26992: 
26992:   return NS_OK;
26992: }
26992: 
28161: // nsTypedSelection::GetRangesForIntervalCOMArray
28161: //
28161: //    Fills a COM array with the ranges overlapping the range specified by
28161: //    the given endpoints. Ranges in the selection exactly adjacent to the
28161: //    input range are not returned unless aAllowAdjacent is set.
28161: //
28161: //    For example, if the following ranges were in the selection
28161: //    (assume everything is within the same node)
28161: //
28161: //    Start Offset: 0 2 7 9
28161: //      End Offset: 2 5 9 10
28161: //
28161: //    and passed aBeginOffset of 2 and aEndOffset of 9, then with
28161: //    aAllowAdjacent set, all the ranges should be returned. If
28161: //    aAllowAdjacent was false, the ranges [2, 5] and [7, 9] only
28161: //    should be returned
28161: //
28161: //    Now that overlapping ranges are disallowed, there can be a maximum of
28161: //    2 adjacent ranges
28161: 
26992: nsresult
26992: nsTypedSelection::GetRangesForIntervalCOMArray(nsINode* aBeginNode, PRInt32 aBeginOffset,
26992:                                                nsINode* aEndNode, PRInt32 aEndOffset,
79445:                                                bool aAllowAdjacent,
26992:                                                nsCOMArray<nsIRange>* aRanges)
26992: {
    1:   aRanges->Clear();
28161:   PRInt32 startIndex, endIndex;
28161:   GetIndicesForInterval(aBeginNode, aBeginOffset, aEndNode, aEndOffset,
28161:                         aAllowAdjacent, &startIndex, &endIndex);
28161:   if (startIndex == -1 || endIndex == -1)
    1:     return NS_OK;
    1: 
28161:   for (PRInt32 i = startIndex; i < endIndex; i++) {
    1:     if (!aRanges->AppendObject(mRanges[i].mRange))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
28161: 
    1:   return NS_OK;
    1: }
    1: 
28161: // nsTypedSelection::GetIndicesForInterval
28161: //
28161: //    Works on the same principle as GetRangesForIntervalCOMArray above, however
28161: //    instead this returns the indices into mRanges between which the
28161: //    overlapping ranges lie.
28161: 
28161: void
28161: nsTypedSelection::GetIndicesForInterval(nsINode* aBeginNode,
28161:                                         PRInt32 aBeginOffset,
28161:                                         nsINode* aEndNode, PRInt32 aEndOffset,
79445:                                         bool aAllowAdjacent,
28161:                                         PRInt32 *aStartIndex,
28161:                                         PRInt32 *aEndIndex)
28161: {
59661:   PRInt32 startIndex;
59661:   PRInt32 endIndex;
59661: 
59661:   if (!aStartIndex)
59661:     aStartIndex = &startIndex;
59661:   if (!aEndIndex)
59661:     aEndIndex = &endIndex;
59661: 
28161:   *aStartIndex = -1;
28161:   *aEndIndex = -1;
28161: 
28161:   if (mRanges.Length() == 0)
28161:     return;
28161: 
79445:   bool intervalIsCollapsed = aBeginNode == aEndNode &&
33042:     aBeginOffset == aEndOffset;
33042: 
28161:   // Ranges that end before the given interval and begin after the given
28161:   // interval can be discarded
33462:   PRInt32 endsBeforeIndex;
33462:   if (NS_FAILED(FindInsertionPoint(&mRanges, aEndNode, aEndOffset,
33462:                                    &CompareToRangeStart,
33462:                                    &endsBeforeIndex))) {
33462:     return;
33462:   }
33042: 
33042:   if (endsBeforeIndex == 0) {
33042:     nsIRange* endRange = mRanges[endsBeforeIndex].mRange;
33042: 
33042:     // If the interval is strictly before the range at index 0, we can optimize
33042:     // by returning now - all ranges start after the given interval
33042:     if (!RangeMatchesBeginPoint(endRange, aEndNode, aEndOffset))
33042:       return;
33042: 
33042:     // We now know that the start point of mRanges[0].mRange equals the end of
33042:     // the interval. Thus, when aAllowadjacent is true, the caller is always
33042:     // interested in this range. However, when excluding adjacencies, we must
33042:     // remember to include the range when both it and the given interval are
33042:     // collapsed to the same point
33042:     if (!aAllowAdjacent && !(endRange->Collapsed() && intervalIsCollapsed))
33042:       return;
33042:   }
28161:   *aEndIndex = endsBeforeIndex;
28161: 
33462:   PRInt32 beginsAfterIndex;
33462:   if (NS_FAILED(FindInsertionPoint(&mRanges, aBeginNode, aBeginOffset,
33462:                                    &CompareToRangeEnd,
33462:                                    &beginsAfterIndex))) {
33462:     return;
33462:   }
28161:   if (beginsAfterIndex == (PRInt32) mRanges.Length())
33042:     return; // optimization: all ranges are strictly before us
28161: 
28161:   if (aAllowAdjacent) {
33042:     // At this point, one of the following holds:
33042:     //   endsBeforeIndex == mRanges.Length(),
33042:     //   endsBeforeIndex points to a range whose start point does not equal the
33042:     //     given interval's start point
33042:     //   endsBeforeIndex points to a range whose start point equals the given
33042:     //     interval's start point
33042:     // In the final case, there can be two such ranges, a collapsed range, and
33042:     // an adjacent range (they will appear in mRanges in that order). For this
33042:     // final case, we need to increment endsBeforeIndex, until one of the
33042:     // first two possibilites hold
33042:     while (endsBeforeIndex < (PRInt32) mRanges.Length()) {
33042:       nsIRange* endRange = mRanges[endsBeforeIndex].mRange;
33042:       if (!RangeMatchesBeginPoint(endRange, aEndNode, aEndOffset))
33042:         break;
28161:       endsBeforeIndex++;
28161:     }
28161: 
33042:     // Likewise, one of the following holds:
33042:     //   beginsAfterIndex == 0,
33042:     //   beginsAfterIndex points to a range whose end point does not equal
33042:     //     the given interval's end point
33042:     //   beginsOnOrAfter points to a range whose end point equals the given
33042:     //     interval's end point
33042:     // In the final case, there can be two such ranges, an adjacent range, and
33042:     // a collapsed range (they will appear in mRanges in that order). For this
33042:     // final case, we only need to take action if both those ranges exist, and
33042:     // we are pointing to the collapsed range - we need to point to the
33042:     // adjacent range
33042:     nsIRange* beginRange = mRanges[beginsAfterIndex].mRange;
33042:     if (beginsAfterIndex > 0 && beginRange->Collapsed() &&
33042:         RangeMatchesEndPoint(beginRange, aBeginNode, aBeginOffset)) {
33042:       beginRange = mRanges[beginsAfterIndex - 1].mRange;
33042:       if (RangeMatchesEndPoint(beginRange, aBeginNode, aBeginOffset))
33042:         beginsAfterIndex--;
33042:     }
28161:   } else {
33042:     // See above for the possibilities at this point. The only case where we
33042:     // need to take action is when the range at beginsAfterIndex ends on
33042:     // the given interval's start point, but that range isn't collapsed (a
33042:     // collapsed range should be included in the returned results).
33042:     nsIRange* beginRange = mRanges[beginsAfterIndex].mRange;
33042:     if (RangeMatchesEndPoint(beginRange, aBeginNode, aBeginOffset) &&
33042:         !beginRange->Collapsed())
28161:       beginsAfterIndex++;
28161: 
33042:     // Again, see above for the meaning of endsBeforeIndex at this point.
33042:     // In particular, endsBeforeIndex may point to a collaped range which
33042:     // represents the point at the end of the interval - this range should be
33042:     // included
33042:     if (endsBeforeIndex < (PRInt32) mRanges.Length()) {
33042:       nsIRange* endRange = mRanges[endsBeforeIndex].mRange;
33042:       if (RangeMatchesBeginPoint(endRange, aEndNode, aEndOffset) &&
33042:           endRange->Collapsed())
33042:         endsBeforeIndex++;
33042:      }
28161:   }
28161: 
28161:   *aStartIndex = beginsAfterIndex;
28161:   *aEndIndex = endsBeforeIndex;
28161:   return;
28161: }
28161: 
    1: //utility method to get the primary frame of node or use the offset to get frame of child node
    1: 
    1: #if 0
    1: NS_IMETHODIMP
79445: nsTypedSelection::GetPrimaryFrameForRangeEndpoint(nsIDOMNode *aNode, PRInt32 aOffset, bool aIsEndNode, nsIFrame **aReturnFrame)
    1: {
23902:   if (!aNode || !aReturnFrame || !mFrameSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   if (aOffset < 0)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   *aReturnFrame = 0;
    1:   
    1:   nsresult  result = NS_OK;
    1:   
    1:   nsCOMPtr<nsIDOMNode> node = aNode;
    1: 
    1:   if (!node)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(node, &result);
    1: 
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   if (!content)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
41641:   if (content->IsElement())
    1:   {
    1:     if (aIsEndNode)
    1:       aOffset--;
    1: 
    1:     if (aOffset >= 0)
    1:     {
    1:       nsIContent *child = content->GetChildAt(aOffset);
    1:       if (!child) //out of bounds?
    1:         return NS_ERROR_FAILURE;
    1: 
    1:       content = child; // releases the focusnode
    1:     }
    1:   }
36656:   *aReturnFrame = content->GetPrimaryFrame();
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetPrimaryFrameForAnchorNode(nsIFrame **aReturnFrame)
    1: {
    1:   if (!aReturnFrame)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   PRInt32 frameOffset = 0;
    1:   *aReturnFrame = 0;
26994:   nsCOMPtr<nsIContent> content = do_QueryInterface(GetAnchorNode());
    1:   if (content && mFrameSelection)
    1:   {
    1:     *aReturnFrame = mFrameSelection->
26992:       GetFrameForNodeOffset(content, GetAnchorOffset(),
    1:                             mFrameSelection->GetHint(), &frameOffset);
    1:     if (*aReturnFrame)
    1:       return NS_OK;
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetPrimaryFrameForFocusNode(nsIFrame **aReturnFrame, PRInt32 *aOffsetUsed,
79445:                                               bool aVisual)
    1: {
    1:   if (!aReturnFrame)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
26994:   nsCOMPtr<nsIContent> content = do_QueryInterface(GetFocusNode());
    1:   if (!content || !mFrameSelection)
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   nsIPresShell *presShell = mFrameSelection->GetShell();
    1: 
    1:   PRInt32 frameOffset = 0;
    1:   *aReturnFrame = 0;
    1:   if (!aOffsetUsed)
    1:     aOffsetUsed = &frameOffset;
    1:     
    1:   nsFrameSelection::HINT hint = mFrameSelection->GetHint();
    1: 
    1:   if (aVisual) {
40045:     nsRefPtr<nsCaret> caret = presShell->GetCaret();
40045:     if (!caret)
    1:       return NS_ERROR_FAILURE;
    1:     
    1:     PRUint8 caretBidiLevel = mFrameSelection->GetCaretBidiLevel();
    1: 
26992:     return caret->GetCaretFrameForNodeOffset(content, GetFocusOffset(),
    1:       hint, caretBidiLevel, aReturnFrame, aOffsetUsed);
    1:   }
    1:   
    1:   *aReturnFrame = mFrameSelection->
26992:     GetFrameForNodeOffset(content, GetFocusOffset(),
    1:                           hint, aOffsetUsed);
    1:   if (!*aReturnFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //select all content children of aContent
26992: nsresult
30695: nsTypedSelection::SelectAllFramesForContent(nsIContentIterator *aInnerIter,
    1:                                   nsIContent *aContent,
79445:                                   bool aSelected)
    1: {
85101:   nsresult result = aInnerIter->Init(aContent);
    1:   nsIFrame *frame;
    1:   if (NS_SUCCEEDED(result))
    1:   {
    1:     // First select frame of content passed in
36656:     frame = aContent->GetPrimaryFrame();
85101:     if (frame && frame->GetType() == nsGkAtoms::textFrame) {
85101:       nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
85101:       textFrame->SetSelectedRange(0, aContent->GetText()->GetLength(), aSelected, mType);
    1:     }
    1:     // Now iterated through the child frames and set them
85101:     while (!aInnerIter->IsDone()) {
20503:       nsCOMPtr<nsIContent> innercontent =
20503:         do_QueryInterface(aInnerIter->GetCurrentNode());
    1: 
36656:       frame = innercontent->GetPrimaryFrame();
85101:       if (frame) {
85101:         if (frame->GetType() == nsGkAtoms::textFrame) {
85101:           nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
85101:           textFrame->SetSelectedRange(0, innercontent->GetText()->GetLength(), aSelected, mType);
85101:         } else {
85101:           frame->InvalidateFrameSubtree();  // frame continuations?
85101:         }
    1:       }
    1: 
    1:       aInnerIter->Next();
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: //the idea of this helper method is to select, deselect "top to bottom" traversing through the frames
27001: nsresult
79445: nsTypedSelection::selectFrames(nsPresContext* aPresContext, nsIRange *aRange, bool aFlags)
    1: {
86094:   if (!mFrameSelection || !aPresContext || !aPresContext->GetPresShell()) {
    1:     return NS_OK; // nothing to do
86094:   }
86094:   if (!aRange) {
86094:     return NS_ERROR_NULL_POINTER;
86094:   }
85101: 
85101:   if (mFrameSelection->GetTableCellSelection()) {
85101:     nsINode* node = aRange->GetCommonAncestor();
85101:     nsCOMPtr<nsIContent> content = do_QueryInterface(node);
85101:     nsIFrame* frame = content ? content->GetPrimaryFrame()
85101:                               : aPresContext->FrameManager()->GetRootFrame();
85101:     if (frame) {
85101:       frame->InvalidateFrameSubtree();
85101:     }
31030:     return NS_OK;
85101:   }
    1: 
    1:   nsresult result;
    1:   nsCOMPtr<nsIContentIterator> iter = do_CreateInstance(
    1:                                               kCSubtreeIteratorCID,
    1:                                               &result);
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   nsCOMPtr<nsIContentIterator> inneriter = do_CreateInstance(
    1:                                               kCContentIteratorCID,
    1:                                               &result);
    1: 
85101:   if ((NS_SUCCEEDED(result)) && iter) {
    1:     result = iter->Init(aRange);
    1: 
    1:     // loop through the content iterator for each content node
26992:     // for each text node, call SetSelected on it:
26992:     nsCOMPtr<nsIContent> content = do_QueryInterface(aRange->GetStartParent());
26992: 
26992:     // we must call first one explicitly
26992:     if (!content)
26992:       return NS_ERROR_UNEXPECTED;
26992: 
85101:     if (content->IsNodeOfType(nsINode::eTEXT)) {
36656:       nsIFrame* frame = content->GetPrimaryFrame();
30695:       // The frame could be an SVG text frame, in which case we'll ignore
30695:       // it.
30695:       if (frame && frame->GetType() == nsGkAtoms::textFrame)
30695:       {
30695:         nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
30695:         PRUint32 startOffset = aRange->StartOffset();
30695:         PRUint32 endOffset;
30695:         if (aRange->GetEndParent() == content) {
30695:           endOffset = aRange->EndOffset();
30695:         } else {
30695:           endOffset = content->GetText()->GetLength();
30695:         }
30695:         textFrame->SetSelectedRange(startOffset, endOffset, aFlags, mType);
30695:       }
26992:     }
26992: 
26992:     iter->First();
85101:     while (!iter->IsDone()) {
26992:       content = do_QueryInterface(iter->GetCurrentNode());
30695:       SelectAllFramesForContent(inneriter, content, aFlags);
26992:       iter->Next();
26992:     }
26992: 
26992:     //we must now do the last one  if it is not the same as the first
26992:     if (aRange->GetEndParent() != aRange->GetStartParent())
26992:     {
26992:       content = do_QueryInterface(aRange->GetEndParent(), &result);
    1:       if (NS_FAILED(result) || !content)
    1:         return result;
    1: 
30695:       if (content->IsNodeOfType(nsINode::eTEXT))
    1:       {
36656:         nsIFrame* frame = content->GetPrimaryFrame();
30695:         // The frame could be an SVG text frame, in which case we'll
30695:         // ignore it.
30695:         if (frame && frame->GetType() == nsGkAtoms::textFrame)
30695:         {
30695:           nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
30695:           textFrame->SetSelectedRange(0, aRange->EndOffset(), aFlags, mType);
30695:         }
26992:       }
26992:     }
    1:   }
    1:   return result;
    1: }
    1: 
85101: 
    1: // nsTypedSelection::LookUpSelection
    1: //
    1: //    This function is called when a node wants to know where the selection is
    1: //    over itself.
    1: //
    1: //    Usually, this is called when we already know there is a selection over
    1: //    the node in question, and we only need to find the boundaries of it on
    1: //    that node. This is when slowCheck is false--a strict test is not needed.
    1: //    Other times, the caller has no idea, and wants us to test everything,
    1: //    so we are supposed to determine whether there is a selection over the
    1: //    node at all.
    1: //
    1: //    A previous version of this code used this flag to do less work when
    1: //    inclusion was already known (slowCheck=false). However, our tree
    1: //    structure allows us to quickly determine ranges overlapping the node,
    1: //    so we just ignore the slowCheck flag and do the full test every time.
    1: //
    1: //    PERFORMANCE: a common case is that we are doing a fast check with exactly
    1: //    one range in the selection. In this case, this function is slower than
    1: //    brute force because of the overhead of checking the tree. We can optimize
    1: //    this case to make it faster by doing the same thing the previous version
    1: //    of this function did in the case of 1 range. This would also mean that
    1: //    the aSlowCheck flag would have meaning again.
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::LookUpSelection(nsIContent *aContent, PRInt32 aContentOffset,
    1:                                   PRInt32 aContentLength,
    1:                                   SelectionDetails **aReturnDetails,
79445:                                   SelectionType aType, bool aSlowCheck)
    1: {
    1:   nsresult rv;
    1:   if (!aContent || ! aReturnDetails)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // it is common to have no ranges, to optimize that
    1:   if (mRanges.Length() == 0)
    1:     return NS_OK;
    1: 
26992:   nsCOMArray<nsIRange> overlappingRanges;
26992:   rv = GetRangesForIntervalCOMArray(aContent, aContentOffset,
26992:                                     aContent, aContentOffset + aContentLength,
80486:                                     false,
    1:                                     &overlappingRanges);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (overlappingRanges.Count() == 0)
    1:     return NS_OK;
    1: 
    1:   for (PRInt32 i = 0; i < overlappingRanges.Count(); i ++) {
26992:     nsIRange* range = overlappingRanges[i];
26992:     nsINode* startNode = range->GetStartParent();
26992:     nsINode* endNode = range->GetEndParent();
26992:     PRInt32 startOffset = range->StartOffset();
26992:     PRInt32 endOffset = range->EndOffset();
    1: 
    1:     PRInt32 start = -1, end = -1;
26992:     if (startNode == aContent && endNode == aContent) {
    1:       if (startOffset < (aContentOffset + aContentLength)  &&
    1:           endOffset > aContentOffset) {
    1:         // this range is totally inside the requested content range
32531:         start = NS_MAX(0, startOffset - aContentOffset);
32531:         end = NS_MIN(aContentLength, endOffset - aContentOffset);
    1:       }
    1:       // otherwise, range is inside the requested node, but does not intersect
    1:       // the requested content range, so ignore it
26992:     } else if (startNode == aContent) {
    1:       if (startOffset < (aContentOffset + aContentLength)) {
    1:         // the beginning of the range is inside the requested node, but the
    1:         // end is outside, select everything from there to the end
32531:         start = NS_MAX(0, startOffset - aContentOffset);
    1:         end = aContentLength;
    1:       }
26992:     } else if (endNode == aContent) {
    1:       if (endOffset > aContentOffset) {
    1:         // the end of the range is inside the requested node, but the beginning
    1:         // is outside, select everything from the beginning to there
    1:         start = 0;
32531:         end = NS_MIN(aContentLength, endOffset - aContentOffset);
    1:       }
    1:     } else {
    1:       // this range does not begin or end in the requested node, but since
    1:       // GetRangesForInterval returned this range, we know it overlaps.
    1:       // Therefore, this node is enclosed in the range, and we select all
    1:       // of it.
    1:       start = 0;
    1:       end = aContentLength;
    1:     }
    1:     if (start < 0)
    1:       continue; // the ranges do not overlap the input range
    1: 
    1:     SelectionDetails* details = new SelectionDetails;
    1: 
    1:     details->mNext = *aReturnDetails;
    1:     details->mStart = start;
    1:     details->mEnd = end;
    1:     details->mType = aType;
27654:     RangeData *rd = FindRangeData(range);
27654:     if (rd) {
27654:       details->mTextRangeStyle = rd->mTextRangeStyle;
27654:     }
    1:     *aReturnDetails = details;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::Repaint(nsPresContext* aPresContext)
    1: {
    1:   PRInt32 arrCount = (PRInt32)mRanges.Length();
    1: 
    1:   if (arrCount < 1)
    1:     return NS_OK;
    1: 
    1:   PRInt32 i;
    1:   
    1:   for (i = 0; i < arrCount; i++)
    1:   {
80486:     nsresult rv = selectFrames(aPresContext, mRanges[i].mRange, true);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsTypedSelection::GetCanCacheFrameOffset(bool *aCanCacheFrameOffset)
    1: { 
    1:   NS_ENSURE_ARG_POINTER(aCanCacheFrameOffset);
    1: 
    1:   if (mCachedOffsetForFrame)
    1:     *aCanCacheFrameOffset = mCachedOffsetForFrame->mCanCacheFrameOffset;
    1:   else
80486:     *aCanCacheFrameOffset = false;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
79445: nsTypedSelection::SetCanCacheFrameOffset(bool aCanCacheFrameOffset)
    1: {
    1:   if (!mCachedOffsetForFrame) {
    1:     mCachedOffsetForFrame = new CachedOffsetForFrame;
    1:   }
    1: 
    1:   mCachedOffsetForFrame->mCanCacheFrameOffset = aCanCacheFrameOffset;
    1: 
    1:   // clean up cached frame when turn off cache
    1:   // fix bug 207936
    1:   if (!aCanCacheFrameOffset) {
    1:     mCachedOffsetForFrame->mLastCaretFrame = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsTypedSelection::GetCachedFrameOffset(nsIFrame *aFrame, PRInt32 inOffset, nsPoint& aPoint)
    1: {
    1:   if (!mCachedOffsetForFrame) {
    1:     mCachedOffsetForFrame = new CachedOffsetForFrame;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1:   if (mCachedOffsetForFrame->mCanCacheFrameOffset &&
    1:       mCachedOffsetForFrame->mLastCaretFrame &&
    1:       (aFrame == mCachedOffsetForFrame->mLastCaretFrame) &&
    1:       (inOffset == mCachedOffsetForFrame->mLastContentOffset))
    1:   {
    1:      // get cached frame offset
    1:      aPoint = mCachedOffsetForFrame->mCachedFrameOffset;
    1:   } 
    1:   else
    1:   {
    1:      // Recalculate frame offset and cache it. Don't cache a frame offset if
    1:      // GetPointFromOffset fails, though.
37078:      rv = aFrame->GetPointFromOffset(inOffset, &aPoint);
    1:      if (NS_SUCCEEDED(rv) && mCachedOffsetForFrame->mCanCacheFrameOffset) {
    1:        mCachedOffsetForFrame->mCachedFrameOffset = aPoint;
    1:        mCachedOffsetForFrame->mLastCaretFrame = aFrame;
    1:        mCachedOffsetForFrame->mLastContentOffset = inOffset; 
    1:      }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetFrameSelection(nsFrameSelection **aFrameSelection) {
    1:   NS_ENSURE_ARG_POINTER(aFrameSelection);
    1:   *aFrameSelection = mFrameSelection;
   17:   NS_IF_ADDREF(*aFrameSelection);
    1:   return NS_OK;
    1: }
    1: 
 2896: NS_IMETHODIMP
 2896: nsTypedSelection::SetAncestorLimiter(nsIContent *aContent)
 2896: {
23902:   if (mFrameSelection)
 2896:     mFrameSelection->SetAncestorLimiter(aContent);
 2896:   return NS_OK;
 2896: }
 2896: 
27654: RangeData*
27654: nsTypedSelection::FindRangeData(nsIDOMRange* aRange)
27654: {
27654:   NS_ENSURE_TRUE(aRange, nsnull);
27654:   for (PRUint32 i = 0; i < mRanges.Length(); i++) {
27654:     if (mRanges[i].mRange == aRange)
27654:       return &mRanges[i];
27654:   }
27654:   return nsnull;
27654: }
27654: 
27654: NS_IMETHODIMP
27654: nsTypedSelection::SetTextRangeStyle(nsIDOMRange *aRange,
27654:                                     const nsTextRangeStyle &aTextRangeStyle)
27654: {
27654:   NS_ENSURE_ARG_POINTER(aRange);
27654:   RangeData *rd = FindRangeData(aRange);
27654:   if (rd) {
27654:     rd->mTextRangeStyle = aTextRangeStyle;
27654:   }
27654:   return NS_OK;
27654: }
27654: 
    1: nsresult
37078: nsTypedSelection::StartAutoScrollTimer(nsIFrame *aFrame,
    1:                                        nsPoint& aPoint,
    1:                                        PRUint32 aDelay)
    1: {
37078:   NS_PRECONDITION(aFrame, "Need a frame");
    1: 
    1:   nsresult result;
    1:   if (!mFrameSelection)
    1:     return NS_OK;//nothing to do
    1: 
    1:   if (!mAutoScrollTimer)
    1:   {
    1:     mAutoScrollTimer = new nsAutoScrollTimer();
    1: 
    1:     result = mAutoScrollTimer->Init(mFrameSelection, this);
    1: 
    1:     if (NS_FAILED(result))
    1:       return result;
    1:   }
    1: 
    1:   result = mAutoScrollTimer->SetDelay(aDelay);
    1: 
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
37078:   return DoAutoScroll(aFrame, aPoint);
    1: }
    1: 
    1: nsresult
    1: nsTypedSelection::StopAutoScrollTimer()
    1: {
    1:   if (mAutoScrollTimer)
    1:     return mAutoScrollTimer->Stop();
    1: 
    1:   return NS_OK; 
    1: }
    1: 
    1: nsresult
37078: nsTypedSelection::DoAutoScroll(nsIFrame *aFrame, nsPoint& aPoint)
37078: {
37078:   NS_PRECONDITION(aFrame, "Need a frame");
37078: 
    1:   if (mAutoScrollTimer)
85981:     (void)mAutoScrollTimer->Stop();
    1: 
37078:   nsPresContext* presContext = aFrame->PresContext();
37502:   nsRootPresContext* rootPC = presContext->GetRootPresContext();
37502:   if (!rootPC)
37502:     return NS_OK;
37502:   nsIFrame* rootmostFrame = rootPC->PresShell()->FrameManager()->GetRootFrame();
47902:   // Get the point relative to the root most frame because the scroll we are
47902:   // about to do will change the coordinates of aFrame.
47902:   nsPoint globalPoint = aPoint + aFrame->GetOffsetToCrossDoc(rootmostFrame);
37078: 
79445:   bool didScroll = presContext->PresShell()->
37078:     ScrollFrameRectIntoView(aFrame, nsRect(aPoint, nsSize(1,1)),
37057:                             NS_PRESSHELL_SCROLL_ANYWHERE,
37078:                             NS_PRESSHELL_SCROLL_ANYWHERE, 0);
    1: 
    1:   //
    1:   // Start the AutoScroll timer if necessary.
    1:   //
    1: 
    1:   if (didScroll && mAutoScrollTimer)
    1:   {
37078:     nsPoint presContextPoint = globalPoint -
47902:       presContext->PresShell()->FrameManager()->GetRootFrame()->GetOffsetToCrossDoc(rootmostFrame);
74711:     mAutoScrollTimer->Start(presContext, presContextPoint);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetEnumerator(nsIEnumerator **aIterator)
    1: {
72509:   NS_ADDREF(*aIterator = new nsSelectionIterator(this));
72509:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: /** RemoveAllRanges zeroes the selection
    1:  */
    1: NS_IMETHODIMP
    1: nsTypedSelection::RemoveAllRanges()
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_OK;//nothing to do
39823:   nsRefPtr<nsPresContext>  presContext;
    1:   GetPresContext(getter_AddRefs(presContext));
    1: 
    1: 
    1:   nsresult  result = Clear(presContext);
    1:   if (NS_FAILED(result))
    1:     return result;
    1:   
    1:   // Turn off signal for table selection
    1:   mFrameSelection->ClearTableCellSelection();
    1: 
    1:   return mFrameSelection->NotifySelectionListeners(GetType());
    1:   // Also need to notify the frames!
    1:   // PresShell::CharacterDataChanged should do that on DocumentChanged
    1: }
    1: 
    1: /** AddRange adds the specified range to the selection
    1:  *  @param aRange is the range to be added
    1:  */
    1: NS_IMETHODIMP
    1: nsTypedSelection::AddRange(nsIDOMRange* aRange)
    1: {
26992:   nsCOMPtr<nsIRange> range = do_QueryInterface(aRange);
26995:   return AddRange(range);
26995: }
26995: 
26995: nsresult
26995: nsTypedSelection::AddRange(nsIRange* aRange)
26995: {
26995:   if (!aRange) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // This inserts a table cell range in proper document order
    1:   // and returns NS_OK if range doesn't contain just one table cell
79445:   bool didAddRange;
13767:   PRInt32 rangeIndex;
26995:   nsresult result = addTableCellRange(aRange, &didAddRange, &rangeIndex);
    1:   if (NS_FAILED(result)) return result;
    1: 
    1:   if (!didAddRange)
    1:   {
26995:     result = AddItem(aRange, &rangeIndex);
    1:     if (NS_FAILED(result)) return result;
    1:   }
    1: 
13767:   NS_ASSERTION(rangeIndex >= 0, "Range index not returned");
13767:   setAnchorFocusRange(rangeIndex);
    1:   
    1:   // Make sure the caret appears on the next line, if at a newline
    1:   if (mType == nsISelectionController::SELECTION_NORMAL)
80486:     SetInterlinePosition(true);
    1: 
39823:   nsRefPtr<nsPresContext>  presContext;
    1:   GetPresContext(getter_AddRefs(presContext));
80486:   selectFrames(presContext, aRange, true);
    1: 
    1:   if (!mFrameSelection)
    1:     return NS_OK;//nothing to do
    1: 
    1:   return mFrameSelection->NotifySelectionListeners(GetType());
    1: }
    1: 
    1: // nsTypedSelection::RemoveRange
    1: //
    1: //    Removes the given range from the selection. The tricky part is updating
    1: //    the flags on the frames that indicate whether they have a selection or
    1: //    not. There could be several selection ranges on the frame, and clearing
    1: //    the bit would cause the selection to not be drawn, even when there is
    1: //    another range on the frame (bug 346185).
    1: //
    1: //    We therefore find any ranges that intersect the same nodes as the range
    1: //    being removed, and cause them to set the selected bits back on their
    1: //    selected frames after we've cleared the bit from ours.
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::RemoveRange(nsIDOMRange* aRange)
    1: {
26992:   nsCOMPtr<nsIRange> range = do_QueryInterface(aRange);
26996:   return RemoveRange(range);
26996: }
26996: 
26996: nsresult
26996: nsTypedSelection::RemoveRange(nsIRange* aRange)
26996: {
26996:   if (!aRange)
    1:     return NS_ERROR_INVALID_ARG;
26996:   nsresult rv = RemoveItem(aRange);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
26996:   nsINode* beginNode = aRange->GetStartParent();
26996:   nsINode* endNode = aRange->GetEndParent();
    1: 
56272:   if (!beginNode || !endNode) {
56272:     // Detached range; nothing else to do here.
56272:     return NS_OK;
56272:   }
56272:   
    1:   // find out the length of the end node, so we can select all of it
    1:   PRInt32 beginOffset, endOffset;
26992:   if (endNode->IsNodeOfType(nsINode::eTEXT)) {
    1:     // Get the length of the text. We can't just use the offset because
    1:     // another range could be touching this text node but not intersect our
    1:     // range.
    1:     beginOffset = 0;
26992:     endOffset = static_cast<nsIContent*>(endNode)->TextLength();
    1:   } else {
    1:     // For non-text nodes, the given offsets should be sufficient.
26996:     beginOffset = aRange->StartOffset();
26996:     endOffset = aRange->EndOffset();
    1:   }
    1: 
    1:   // clear the selected bit from the removed range's frames
39823:   nsRefPtr<nsPresContext>  presContext;
    1:   GetPresContext(getter_AddRefs(presContext));
80486:   selectFrames(presContext, aRange, false);
    1: 
    1:   // add back the selected bit for each range touching our nodes
26992:   nsCOMArray<nsIRange> affectedRanges;
    1:   rv = GetRangesForIntervalCOMArray(beginNode, beginOffset,
    1:                                     endNode, endOffset,
80486:                                     true, &affectedRanges);
    1:   NS_ENSURE_SUCCESS(rv, rv);
26992:   for (PRInt32 i = 0; i < affectedRanges.Count(); i ++) {
80486:     selectFrames(presContext, affectedRanges[i], true);
26992:   }
    1: 
20139:   PRInt32 cnt = mRanges.Length();
26996:   if (aRange == mAnchorFocusRange) {
20139:     // Reset anchor to LAST range or clear it if there are no ranges.
20139:     setAnchorFocusRange(cnt - 1);
20139: 
    1:     // When the selection is user-created it makes sense to scroll the range
    1:     // into view. The spell-check selection, however, is created and destroyed
    1:     // in the background. We don't want to scroll in this case or the view
    1:     // might appear to be moving randomly (bug 337871).
20139:     if (mType != nsISelectionController::SELECTION_SPELLCHECK && cnt > 0)
80486:       ScrollIntoView(nsISelectionController::SELECTION_FOCUS_REGION, false,
80486:                      false);
    1:   }
20139: 
    1:   if (!mFrameSelection)
    1:     return NS_OK;//nothing to do
    1:   return mFrameSelection->NotifySelectionListeners(GetType());
    1: }
    1: 
    1: 
    1: 
    1: /*
    1:  * Collapse sets the whole selection to be one point.
    1:  */
    1: NS_IMETHODIMP
    1: nsTypedSelection::Collapse(nsIDOMNode* aParentNode, PRInt32 aOffset)
    1: {
26992:   nsCOMPtr<nsINode> parentNode = do_QueryInterface(aParentNode);
26992:   return Collapse(parentNode, aOffset);
26992: }
26992: 
26992: nsresult
26992: nsTypedSelection::Collapse(nsINode* aParentNode, PRInt32 aOffset)
26992: {
    1:   if (!aParentNode)
    1:     return NS_ERROR_INVALID_ARG;
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_NOT_INITIALIZED; // Can't do selection
63262: 
63262:   nsCOMPtr<nsINode> kungfuDeathGrip = aParentNode;
63262: 
    1:   mFrameSelection->InvalidateDesiredX();
    1:   if (!IsValidSelectionPoint(mFrameSelection, aParentNode))
    1:     return NS_ERROR_FAILURE;
    1:   nsresult result;
    1:   // Delete all of the current ranges
39823:   nsRefPtr<nsPresContext>  presContext;
    1:   GetPresContext(getter_AddRefs(presContext));
    1:   Clear(presContext);
    1: 
    1:   // Turn off signal for table selection
    1:   mFrameSelection->ClearTableCellSelection();
    1: 
26992:   nsCOMPtr<nsIRange> range = new nsRange();
    1:   result = range->SetEnd(aParentNode, aOffset);
    1:   if (NS_FAILED(result))
    1:     return result;
    1:   result = range->SetStart(aParentNode, aOffset);
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1: #ifdef DEBUG_SELECTION
85101:   if (aParentNode) {
85101:     nsCOMPtr<nsIContent> content = do_QueryInterface(aParentNode);
85101:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(aParentNode);
85101:     printf ("Sel. Collapse to %p %s %d\n", aParentNode,
85101:             content ? nsAtomCString(content->Tag()).get()
85101:                     : (doc ? "DOCUMENT" : "???"),
85101:             aOffset);
    1:   }
    1: #endif
    1: 
    1:   result = AddItem(range);
85101:   if (NS_FAILED(result))
85101:     return result;
    1:   setAnchorFocusRange(0);
80486:   selectFrames(presContext, range, true);
    1:   return mFrameSelection->NotifySelectionListeners(GetType());
    1: }
    1: 
    1: /*
    1:  * Sets the whole selection to be one point
    1:  * at the start of the current selection
    1:  */
    1: NS_IMETHODIMP
    1: nsTypedSelection::CollapseToStart()
    1: {
    1:   PRInt32 cnt;
    1:   nsresult rv = GetRangeCount(&cnt);
    1:   if (NS_FAILED(rv) || cnt <= 0)
56999:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1: 
    1:   // Get the first range
26992:   nsIRange* firstRange = mRanges[0].mRange;
    1:   if (!firstRange)
    1:     return NS_ERROR_FAILURE;
    1: 
26992:   return Collapse(firstRange->GetStartParent(), firstRange->StartOffset());
    1: }
    1: 
    1: /*
    1:  * Sets the whole selection to be one point
    1:  * at the end of the current selection
    1:  */
    1: NS_IMETHODIMP
    1: nsTypedSelection::CollapseToEnd()
    1: {
    1:   PRInt32 cnt;
    1:   nsresult rv = GetRangeCount(&cnt);
    1:   if (NS_FAILED(rv) || cnt <= 0)
56999:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1: 
    1:   // Get the last range
26992:   nsIRange* lastRange = mRanges[cnt-1].mRange;
    1:   if (!lastRange)
    1:     return NS_ERROR_FAILURE;
    1: 
26992:   return Collapse(lastRange->GetEndParent(), lastRange->EndOffset());
    1: }
    1: 
    1: /*
    1:  * IsCollapsed -- is the whole selection just one point, or unset?
    1:  */
    1: NS_IMETHODIMP
79445: nsTypedSelection::GetIsCollapsed(bool* aIsCollapsed)
    1: {
    1:   if (!aIsCollapsed)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRInt32 cnt = (PRInt32)mRanges.Length();;
    1:   if (cnt == 0)
    1:   {
80486:     *aIsCollapsed = true;
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (cnt != 1)
    1:   {
80486:     *aIsCollapsed = false;
    1:     return NS_OK;
    1:   }
    1: 
26992:   *aIsCollapsed = mRanges[0].mRange->Collapsed();
26992:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetRangeCount(PRInt32* aRangeCount)
    1: {
    1:   *aRangeCount = (PRInt32)mRanges.Length();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::GetRangeAt(PRInt32 aIndex, nsIDOMRange** aReturn)
    1: {
26995:   *aReturn = mRanges.SafeElementAt(aIndex, sEmptyData).mRange;
26995:   if (!*aReturn) {
56998:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
26995:   }
26995: 
26995:   NS_ADDREF(*aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
26996: nsIRange*
26996: nsTypedSelection::GetRangeAt(PRInt32 aIndex)
26996: {
26996:   return mRanges.SafeElementAt(aIndex, sEmptyData).mRange;
26996: }
    1: 
    1: /*
    1: utility function
    1: */
26992: nsresult
26992: nsTypedSelection::CopyRangeToAnchorFocus(nsIRange *aRange)
    1: {
26993:   // XXXbz could we just clone into mAnchorFocusRange, or do consumers
26993:   // expect that pointer to not change across this call?
25550:   NS_ENSURE_STATE(mAnchorFocusRange);
26992:   
26992:   nsINode* startNode = aRange->GetStartParent();
26992:   nsINode* endNode = aRange->GetEndParent();
26992:   PRInt32 startOffset = aRange->StartOffset();
26992:   PRInt32 endOffset = aRange->EndOffset();;
    1:   if (NS_FAILED(mAnchorFocusRange->SetStart(startNode,startOffset)))
    1:   {
26993:     // XXXbz what is this doing exactly?
    1:     if (NS_FAILED(mAnchorFocusRange->SetEnd(endNode,endOffset)))
    1:       return NS_ERROR_FAILURE;//???
    1:     if (NS_FAILED(mAnchorFocusRange->SetStart(startNode,startOffset)))
    1:       return NS_ERROR_FAILURE;//???
    1:   }
    1:   else if (NS_FAILED(mAnchorFocusRange->SetEnd(endNode,endOffset)))
    1:     return NS_ERROR_FAILURE;//???
    1:   return NS_OK;
    1: }
    1: 
20590: void
26993: nsTypedSelection::ReplaceAnchorFocusRange(nsIRange *aRange)
20590: {
39823:   nsRefPtr<nsPresContext> presContext;
20590:   GetPresContext(getter_AddRefs(presContext));
20590:   if (presContext) {
80486:     selectFrames(presContext, mAnchorFocusRange, false);
26993:     CopyRangeToAnchorFocus(aRange);
80486:     selectFrames(presContext, mAnchorFocusRange, true);
20590:   }
20590: }
20590: 
    1: /*
    1: Notes which might come in handy for extend:
    1: 
    1: We can tell the direction of the selection by asking for the anchors selection
    1: if the begin is less than the end then we know the selection is to the "right".
    1: else it is a backwards selection.
    1: a = anchor
    1: 1 = old cursor
    1: 2 = new cursor
    1: 
    1:   if (a <= 1 && 1 <=2)    a,1,2  or (a1,2)
    1:   if (a < 2 && 1 > 2)     a,2,1
    1:   if (1 < a && a <2)      1,a,2
    1:   if (a > 2 && 2 >1)      1,2,a
    1:   if (2 < a && a <1)      2,a,1
    1:   if (a > 1 && 1 >2)      2,1,a
    1: then execute
    1: a  1  2 select from 1 to 2
    1: a  2  1 deselect from 2 to 1
    1: 1  a  2 deselect from 1 to a select from a to 2
    1: 1  2  a deselect from 1 to 2
    1: 2  1  a = continue selection from 2 to 1
    1: */
    1: 
    1: 
    1: /*
    1:  * Extend extends the selection away from the anchor.
    1:  * We don't need to know the direction, because we always change the focus.
    1:  */
    1: NS_IMETHODIMP
    1: nsTypedSelection::Extend(nsIDOMNode* aParentNode, PRInt32 aOffset)
    1: {
26992:   nsCOMPtr<nsINode> parentNode = do_QueryInterface(aParentNode);
26992:   return Extend(parentNode, aOffset);
26992: }
26992: 
26992: nsresult
26992: nsTypedSelection::Extend(nsINode* aParentNode, PRInt32 aOffset)
26992: {
    1:   if (!aParentNode)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   // First, find the range containing the old focus point:
    1:   if (!mAnchorFocusRange)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_NOT_INITIALIZED; // Can't do selection
    1: 
    1:   nsresult res;
    1:   if (!IsValidSelectionPoint(mFrameSelection, aParentNode))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   //mFrameSelection->InvalidateDesiredX();
26992:   nsCOMPtr<nsIRange> difRange = new nsRange();
26992:   nsCOMPtr<nsIRange> range;
26992: 
26992:   nsINode* anchorNode = GetAnchorNode();
26992:   nsINode* focusNode = GetFocusNode();
26992:   PRInt32 anchorOffset = GetAnchorOffset();
26992:   PRInt32 focusOffset = GetFocusOffset();
26992: 
26992:   if (focusNode == aParentNode && focusOffset == aOffset)
31030:     return NS_OK; //same node nothing to do!
    1: 
    1:   res = mAnchorFocusRange->CloneRange(getter_AddRefs(range));
20349:   if (NS_FAILED(res))
20349:     return res;
    1:   //range = mAnchorFocusRange;
    1: 
26992:   nsINode* startNode = range->GetStartParent();
26992:   nsINode* endNode = range->GetEndParent();
26992:   PRInt32 startOffset = range->StartOffset();
26992:   PRInt32 endOffset = range->EndOffset();;
    1: 
    1:   nsDirection dir = GetDirection();
    1: 
    1:   //compare anchor to old cursor.
    1: 
    1:   if (NS_FAILED(res))
    1:     return res;
56259:   // We pass |disconnected| to the following ComparePoints calls in order
56259:   // to avoid assertions, and there is no special handling required, since
56259:   // ComparePoints returns 1 in the disconnected case.
79445:   bool disconnected = false;
26992:   PRInt32 result1 = nsContentUtils::ComparePoints(anchorNode, anchorOffset,
56259:                                                   focusNode, focusOffset,
56259:                                                   &disconnected);
    1:   //compare old cursor to new cursor
26992:   PRInt32 result2 = nsContentUtils::ComparePoints(focusNode, focusOffset,
56259:                                                   aParentNode, aOffset,
56259:                                                   &disconnected);
    1:   //compare anchor to new cursor
26992:   PRInt32 result3 = nsContentUtils::ComparePoints(anchorNode, anchorOffset,
56259:                                                   aParentNode, aOffset,
56259:                                                   &disconnected);
    1: 
    1:   if (result2 == 0) //not selecting anywhere
    1:     return NS_OK;
    1: 
39823:   nsRefPtr<nsPresContext>  presContext;
    1:   GetPresContext(getter_AddRefs(presContext));
    1:   if ((result1 == 0 && result3 < 0) || (result1 <= 0 && result2 < 0)){//a1,2  a,1,2
    1:     //select from 1 to 2 unless they are collapsed
    1:     res = range->SetEnd(aParentNode, aOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
    1:     dir = eDirNext;
26992:     res = difRange->SetEnd(range->GetEndParent(), range->EndOffset());
26992:     res |= difRange->SetStart(focusNode, focusOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
80486:     selectFrames(presContext, difRange , true);
    1:     res = CopyRangeToAnchorFocus(range);
    1:     if (NS_FAILED(res))
    1:       return res;
    1:   }
    1:   else if (result1 == 0 && result3 > 0){//2, a1
    1:     //select from 2 to 1a
    1:     dir = eDirPrevious;
    1:     res = range->SetStart(aParentNode, aOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
80486:     selectFrames(presContext, range, true);
    1:     res = CopyRangeToAnchorFocus(range);
    1:     if (NS_FAILED(res))
    1:       return res;
    1:   }
    1:   else if (result3 <= 0 && result2 >= 0) {//a,2,1 or a2,1 or a,21 or a21
    1:     //deselect from 2 to 1
26992:     res = difRange->SetEnd(focusNode, focusOffset);
    1:     res |= difRange->SetStart(aParentNode, aOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
    1: 
    1:     res = range->SetEnd(aParentNode, aOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
    1:     res = CopyRangeToAnchorFocus(range);
    1:     if (NS_FAILED(res))
    1:       return res;
80486:     selectFrames(presContext, difRange, false); // deselect now
26992:     difRange->SetEnd(range->GetEndParent(), range->EndOffset());
80486:     selectFrames(presContext, difRange, true); // must reselect last node maybe more
    1:   }
    1:   else if (result1 >= 0 && result3 <= 0) {//1,a,2 or 1a,2 or 1,a2 or 1a2
    1:     if (GetDirection() == eDirPrevious){
    1:       res = range->SetStart(endNode, endOffset);
    1:       if (NS_FAILED(res))
    1:         return res;
    1:     }
    1:     dir = eDirNext;
    1:     res = range->SetEnd(aParentNode, aOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
26992:     if (focusNode != anchorNode || focusOffset != anchorOffset) {//if collapsed diff dont do anything
26992:       res = difRange->SetStart(focusNode, focusOffset);
26992:       res |= difRange->SetEnd(anchorNode, anchorOffset);
    1:       if (NS_FAILED(res))
    1:         return res;
    1:       res = CopyRangeToAnchorFocus(range);
    1:       if (NS_FAILED(res))
    1:         return res;
    1:       //deselect from 1 to a
80486:       selectFrames(presContext, difRange , false);
    1:     }
    1:     else
    1:     {
    1:       res = CopyRangeToAnchorFocus(range);
    1:       if (NS_FAILED(res))
    1:         return res;
    1:     }
    1:     //select from a to 2
80486:     selectFrames(presContext, range , true);
    1:   }
    1:   else if (result2 <= 0 && result3 >= 0) {//1,2,a or 12,a or 1,2a or 12a
    1:     //deselect from 1 to 2
    1:     res = difRange->SetEnd(aParentNode, aOffset);
26992:     res |= difRange->SetStart(focusNode, focusOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
    1:     dir = eDirPrevious;
    1:     res = range->SetStart(aParentNode, aOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
    1: 
    1:     res = CopyRangeToAnchorFocus(range);
    1:     if (NS_FAILED(res))
    1:       return res;
80486:     selectFrames(presContext, difRange , false);
26992:     difRange->SetStart(range->GetStartParent(), range->StartOffset());
80486:     selectFrames(presContext, difRange, true);//must reselect last node
    1:   }
    1:   else if (result3 >= 0 && result1 <= 0) {//2,a,1 or 2a,1 or 2,a1 or 2a1
    1:     if (GetDirection() == eDirNext){
    1:       range->SetEnd(startNode, startOffset);
    1:     }
    1:     dir = eDirPrevious;
    1:     res = range->SetStart(aParentNode, aOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
    1:     //deselect from a to 1
26992:     if (focusNode != anchorNode || focusOffset!= anchorOffset) {//if collapsed diff dont do anything
26992:       res = difRange->SetStart(anchorNode, anchorOffset);
26992:       res |= difRange->SetEnd(focusNode, focusOffset);
20349:       res |= CopyRangeToAnchorFocus(range);
    1:       if (NS_FAILED(res))
    1:         return res;
80486:       selectFrames(presContext, difRange, false);
    1:     }
    1:     else
    1:     {
    1:       res = CopyRangeToAnchorFocus(range);
    1:       if (NS_FAILED(res))
    1:         return res;
    1:     }
    1:     //select from 2 to a
80486:     selectFrames(presContext, range , true);
    1:   }
    1:   else if (result2 >= 0 && result1 >= 0) {//2,1,a or 21,a or 2,1a or 21a
    1:     //select from 2 to 1
    1:     res = range->SetStart(aParentNode, aOffset);
    1:     if (NS_FAILED(res))
    1:       return res;
    1:     dir = eDirPrevious;
26992:     res = difRange->SetEnd(focusNode, focusOffset);
26992:     res |= difRange->SetStart(range->GetStartParent(), range->StartOffset());
    1:     if (NS_FAILED(res))
    1:       return res;
    1: 
80486:     selectFrames(presContext, difRange, true);
    1:     res = CopyRangeToAnchorFocus(range);
    1:     if (NS_FAILED(res))
    1:       return res;
    1:   }
    1: 
    1:   DEBUG_OUT_RANGE(range);
26992: #ifdef DEBUG_SELECTION
    1:   if (eDirNext == mDirection)
    1:     printf("    direction = 1  LEFT TO RIGHT\n");
    1:   else
    1:     printf("    direction = 0  RIGHT TO LEFT\n");
    1: #endif
    1:   SetDirection(dir);
    1: #ifdef DEBUG_SELECTION
    1:   if (aParentNode)
    1:   {
    1:     nsCOMPtr<nsIContent>content;
    1:     content = do_QueryInterface(aParentNode);
    1: 
39100:     printf ("Sel. Extend to %p %s %d\n", content.get(),
39100:             nsAtomCString(content->Tag()).get(), aOffset);
    1:   }
    1:   else {
    1:     printf ("Sel. Extend set to null parent.\n");
    1:   }
    1: #endif
    1:   return mFrameSelection->NotifySelectionListeners(GetType());
    1: }
    1: 
    1: static nsresult
    1: GetChildOffset(nsIDOMNode *aChild, nsIDOMNode *aParent, PRInt32 &aOffset)
    1: {
    1:   NS_ASSERTION((aChild && aParent), "bad args");
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aParent);
    1:   nsCOMPtr<nsIContent> cChild = do_QueryInterface(aChild);
    1: 
    1:   if (!cChild || !content)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   aOffset = content->IndexOf(cChild);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::SelectAllChildren(nsIDOMNode* aParentNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aParentNode);
    1:   
    1:   if (mFrameSelection) 
    1:   {
    1:     mFrameSelection->PostReason(nsISelectionListener::SELECTALL_REASON);
    1:   }
    1:   nsresult result = Collapse(aParentNode, 0);
    1:   if (NS_SUCCEEDED(result))
    1:   {
    1:     nsCOMPtr<nsIDOMNode>lastChild;
    1:     result = aParentNode->GetLastChild(getter_AddRefs(lastChild));
    1:     if ((NS_SUCCEEDED(result)) && lastChild)
    1:     {
    1:       PRInt32 numBodyChildren=0;
    1:       GetChildOffset(lastChild, aParentNode, numBodyChildren);
    1:       if (mFrameSelection) 
    1:       {
    1:         mFrameSelection->PostReason(nsISelectionListener::SELECTALL_REASON);
    1:       }
    1:       result = Extend(aParentNode, numBodyChildren+1);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsTypedSelection::ContainsNode(nsIDOMNode* aNode, bool aAllowPartial,
79445:                                bool* aYes)
    1: {
    1:   nsresult rv;
    1:   if (!aYes)
    1:     return NS_ERROR_NULL_POINTER;
80486:   *aYes = false;
    1: 
26992:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
26992:   if (mRanges.Length() == 0 || !node)
    1:     return NS_OK;
    1: 
26992:   // XXXbz this duplicates the GetNodeLength code in nsRange.cpp
    1:   PRUint32 nodeLength;
79445:   bool isData = node->IsNodeOfType(nsINode::eDATA_NODE);
26992:   if (isData) {
26992:     nodeLength = static_cast<nsIContent*>(node.get())->TextLength();
    1:   } else {
26992:     nodeLength = node->GetChildCount();
26992:   }
26992: 
26992:   nsCOMArray<nsIRange> overlappingRanges;
26992:   rv = GetRangesForIntervalCOMArray(node, 0, node, nodeLength,
80486:                                     false, &overlappingRanges);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (overlappingRanges.Count() == 0)
    1:     return NS_OK; // no ranges overlap
    1:   
    1:   // if the caller said partial intersections are OK, we're done
    1:   if (aAllowPartial) {
80486:     *aYes = true;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // text nodes always count as inside
26992:   if (isData) {
80486:     *aYes = true;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // The caller wants to know if the node is entirely within the given range,
    1:   // so we have to check all intersecting ranges.
    1:   for (PRInt32 i = 0; i < overlappingRanges.Count(); i ++) {
79445:     bool nodeStartsBeforeRange, nodeEndsAfterRange;
26992:     if (NS_SUCCEEDED(nsRange::CompareNodeToRange(node, overlappingRanges[i],
    1:                                                  &nodeStartsBeforeRange,
    1:                                                  &nodeEndsAfterRange))) {
    1:       if (!nodeStartsBeforeRange && !nodeEndsAfterRange) {
80486:         *aYes = true;
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsTypedSelection::GetPresContext(nsPresContext **aPresContext)
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_FAILURE;//nothing to do
    1:   nsIPresShell *shell = mFrameSelection->GetShell();
    1: 
    1:   if (!shell)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   NS_IF_ADDREF(*aPresContext = shell->GetPresContext());
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsTypedSelection::GetPresShell(nsIPresShell **aPresShell)
    1: {
    1:   if (mPresShellWeak)
    1:   {
    1:     nsCOMPtr<nsIPresShell> presShell = do_QueryReferent(mPresShellWeak);
    1:     if (presShell)
    1:       NS_ADDREF(*aPresShell = presShell);
    1:     return NS_OK;
    1:   }
    1:   nsresult rv = NS_OK;
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_FAILURE;//nothing to do
    1: 
    1:   nsIPresShell *shell = mFrameSelection->GetShell();
    1: 
    1:   mPresShellWeak = do_GetWeakReference(shell);    // the presshell owns us, so no addref
    1:   if (mPresShellWeak)
    1:     NS_ADDREF(*aPresShell = shell);
    1:   return rv;
    1: }
    1: 
37078: nsIFrame *
37078: nsTypedSelection::GetSelectionAnchorGeometry(SelectionRegion aRegion,
37078:                                              nsRect *aRect)
37078: {
    1:   if (!mFrameSelection)
37078:     return nsnull;  // nothing to do
37078: 
37078:   NS_ENSURE_TRUE(aRect, nsnull);
    1: 
    1:   aRect->SetRect(0, 0, 0, 0);
    1: 
58206:   switch (aRegion) {
58206:     case nsISelectionController::SELECTION_ANCHOR_REGION:
58206:     case nsISelectionController::SELECTION_FOCUS_REGION:
58206:       return GetSelectionEndPointGeometry(aRegion, aRect);
58206:       break;
58206:     case nsISelectionController::SELECTION_WHOLE_SELECTION:
58206:       break;
58206:     default:
58206:       return nsnull;
58206:   }
58206: 
58206:   NS_ASSERTION(aRegion == nsISelectionController::SELECTION_WHOLE_SELECTION,
58206:     "should only be SELECTION_WHOLE_SELECTION here");
58206: 
58206:   nsRect anchorRect;
58206:   nsIFrame* anchorFrame = GetSelectionEndPointGeometry(
58206:     nsISelectionController::SELECTION_ANCHOR_REGION, &anchorRect);
58206:   if (!anchorFrame)
58206:     return nsnull;
58206: 
58206:   nsRect focusRect;
58206:   nsIFrame* focusFrame = GetSelectionEndPointGeometry(
58206:     nsISelectionController::SELECTION_FOCUS_REGION, &focusRect);
58206:   if (!focusFrame)
58206:     return nsnull;
58206: 
58206:   NS_ASSERTION(anchorFrame->PresContext() == focusFrame->PresContext(),
58206:     "points of selection in different documents?");
58206:   // make focusRect relative to anchorFrame
58206:   focusRect += focusFrame->GetOffsetTo(anchorFrame);
58206: 
68638:   aRect->UnionRectEdges(anchorRect, focusRect);
58206:   return anchorFrame;
58206: }
58206: 
58206: nsIFrame *
58206: nsTypedSelection::GetSelectionEndPointGeometry(SelectionRegion aRegion,
58206:                                                nsRect *aRect)
58206: {
58206:   if (!mFrameSelection)
58206:     return nsnull;  // nothing to do
58206: 
58206:   NS_ENSURE_TRUE(aRect, nsnull);
58206: 
58206:   aRect->SetRect(0, 0, 0, 0);
58206: 
26994:   nsINode    *node       = nsnull;
    1:   PRInt32     nodeOffset = 0;
    1:   nsIFrame   *frame      = nsnull;
    1: 
    1:   switch (aRegion) {
    1:     case nsISelectionController::SELECTION_ANCHOR_REGION:
26994:       node       = GetAnchorNode();
26992:       nodeOffset = GetAnchorOffset();
    1:       break;
    1:     case nsISelectionController::SELECTION_FOCUS_REGION:
26994:       node       = GetFocusNode();
26992:       nodeOffset = GetFocusOffset();
    1:       break;
    1:     default:
37078:       return nsnull;
    1:   }
    1: 
    1:   if (!node)
37078:     return nsnull;
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(node);
37078:   NS_ENSURE_TRUE(content.get(), nsnull);
    1:   PRInt32 frameOffset = 0;
    1:   frame = mFrameSelection->GetFrameForNodeOffset(content, nodeOffset,
    1:                                                  mFrameSelection->GetHint(),
    1:                                                  &frameOffset);
    1:   if (!frame)
37078:     return nsnull;
    1: 
    1:   // Figure out what node type we have, then get the
    1:   // appropriate rect for it's nodeOffset.
79445:   bool isText = node->IsNodeOfType(nsINode::eTEXT);
    1: 
    1:   nsPoint pt(0, 0);
26994:   if (isText) {
    1:     nsIFrame* childFrame = nsnull;
    1:     frameOffset = 0;
26994:     nsresult rv =
26994:       frame->GetChildFrameContainingOffset(nodeOffset,
    1:                                            mFrameSelection->GetHint(),
    1:                                            &frameOffset, &childFrame);
    1:     if (NS_FAILED(rv))
37078:       return nsnull;
    1:     if (!childFrame)
37078:       return nsnull;
    1: 
    1:     frame = childFrame;
    1: 
    1:     // Get the x coordinate of the offset into the text frame.
    1:     rv = GetCachedFrameOffset(frame, nodeOffset, pt);
    1:     if (NS_FAILED(rv))
37078:       return nsnull;
37078:   }
37078: 
37078:   // Return the rect relative to the frame, with zero width.
26994:   if (isText) {
37078:     aRect->x = pt.x;
37078:   } else if (mFrameSelection->GetHint() == nsFrameSelection::HINTLEFT) {
    1:     // It's the frame's right edge we're interested in.
37078:     aRect->x = frame->GetRect().width;
37078:   }
37078:   aRect->height = frame->GetRect().height;
37078: 
37078:   return frame;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::ScrollSelectionIntoViewEvent::Run()
    1: {
    1:   if (!mTypedSelection)
    1:     return NS_OK;  // event revoked
    1: 
56443:   PRInt32 flags = nsTypedSelection::SCROLL_DO_FLUSH |
56443:                   nsTypedSelection::SCROLL_SYNCHRONOUS;
56443:   if (mFirstAncestorOnly) {
56443:     flags |= nsTypedSelection::SCROLL_FIRST_ANCESTOR_ONLY;
56443:   }
56443: 
    1:   mTypedSelection->mScrollEvent.Forget();
56443:   mTypedSelection->ScrollIntoView(mRegion,
56443:                                   PRInt16(NS_PRESSHELL_SCROLL_ANYWHERE),
56443:                                   PRInt16(NS_PRESSHELL_SCROLL_ANYWHERE),
56443:                                   flags);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
79445: nsTypedSelection::PostScrollSelectionIntoViewEvent(SelectionRegion aRegion, bool aFirstAncestorOnly)
    1: {
    1:   // If we've already posted an event, revoke it and place a new one at the
    1:   // end of the queue to make sure that any new pending reflow events are
    1:   // processed before we scroll. This will insure that we scroll to the
    1:   // correct place on screen.
    1:   mScrollEvent.Revoke();
    1: 
    1:   nsRefPtr<ScrollSelectionIntoViewEvent> ev =
56442:       new ScrollSelectionIntoViewEvent(this, aRegion, aFirstAncestorOnly);
    1:   nsresult rv = NS_DispatchToCurrentThread(ev);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mScrollEvent = ev;
    1:   return NS_OK;
    1: }
    1: 
 5245: NS_IMETHODIMP
79445: nsTypedSelection::ScrollIntoView(SelectionRegion aRegion, bool aIsSynchronous,
 5245:                                  PRInt16 aVPercent, PRInt16 aHPercent)
 5245: {
56443:   return ScrollIntoView(aRegion, aVPercent, aHPercent,
56443:                         aIsSynchronous ? nsTypedSelection::SCROLL_SYNCHRONOUS : 0);
 5245: }
 5245: 
 4886: nsresult
 4886: nsTypedSelection::ScrollIntoView(SelectionRegion aRegion,
56442:                                  PRInt16 aVPercent, PRInt16 aHPercent,
56443:                                  PRInt32 aFlags)
    1: {
    1:   nsresult result;
    1:   if (!mFrameSelection)
    1:     return NS_OK;//nothing to do
    1: 
    1:   if (mFrameSelection->GetBatching())
    1:     return NS_OK;
    1: 
56443:   if (!(aFlags & nsTypedSelection::SCROLL_SYNCHRONOUS))
56443:     return PostScrollSelectionIntoViewEvent(aRegion,
56443:       !!(aFlags & nsTypedSelection::SCROLL_FIRST_ANCESTOR_ONLY));
    1: 
    1:   //
    1:   // Shut the caret off before scrolling to avoid
    1:   // leaving caret turds on the screen!
    1:   //
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   result = GetPresShell(getter_AddRefs(presShell));
   41:   if (NS_FAILED(result) || !presShell)
    1:     return result;
40045:   nsRefPtr<nsCaret> caret = presShell->GetCaret();
    1:   if (caret)
    1:   {
 4886:     // Now that text frame character offsets are always valid (though not
 4886:     // necessarily correct), the worst that will happen if we don't flush here
 4886:     // is that some callers might scroll to the wrong place.  Those should
 4886:     // either manually flush if they're in a safe position for it or use the
 4886:     // async version of this method.
56443:     if (aFlags & nsTypedSelection::SCROLL_DO_FLUSH) {
 4886:       presShell->FlushPendingNotifications(Flush_Layout);
 4886: 
 4886:       // Reget the presshell, since it might have gone away.
 4886:       result = GetPresShell(getter_AddRefs(presShell));
 4886:       if (NS_FAILED(result) || !presShell)
 4886:         return result;
 4886:     }
 4886: 
    1:     StCaretHider  caretHider(caret);      // stack-based class hides and shows the caret
    1: 
    1:     //
    1:     // Scroll the selection region into view.
    1:     //
    1: 
    1:     nsRect rect;
37078:     nsIFrame* frame = GetSelectionAnchorGeometry(aRegion, &rect);
37078:     if (!frame)
37078:       return NS_ERROR_FAILURE;
37078: 
56442:     presShell->ScrollFrameRectIntoView(frame, rect, aVPercent, aHPercent,
56443:       (aFlags & nsTypedSelection::SCROLL_FIRST_ANCESTOR_ONLY) ? nsIPresShell::SCROLL_FIRST_ANCESTOR_ONLY: 0);
    1:     return NS_OK;
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::AddSelectionListener(nsISelectionListener* aNewListener)
    1: {
    1:   if (!aNewListener)
    1:     return NS_ERROR_NULL_POINTER;
    1:   return mSelectionListeners.AppendObject(aNewListener) ? NS_OK : NS_ERROR_FAILURE;      // addrefs
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::RemoveSelectionListener(nsISelectionListener* aListenerToRemove)
    1: {
    1:   if (!aListenerToRemove )
    1:     return NS_ERROR_NULL_POINTER;
    1:   return mSelectionListeners.RemoveObject(aListenerToRemove) ? NS_OK : NS_ERROR_FAILURE; // releases
    1: }
    1: 
    1: 
    1: nsresult
    1: nsTypedSelection::NotifySelectionListeners()
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_OK;//nothing to do
    1:  
    1:   if (mFrameSelection->GetBatching()){
    1:     mFrameSelection->SetDirty();
    1:     return NS_OK;
    1:   }
    1:   PRInt32 cnt = mSelectionListeners.Count();
    1:   nsCOMArray<nsISelectionListener> selectionListeners(mSelectionListeners);
    1:   
    1:   nsCOMPtr<nsIDOMDocument> domdoc;
    1:   nsCOMPtr<nsIPresShell> shell;
    1:   nsresult rv = GetPresShell(getter_AddRefs(shell));
    1:   if (NS_SUCCEEDED(rv) && shell)
    1:     domdoc = do_QueryInterface(shell->GetDocument());
    1:   short reason = mFrameSelection->PopReason();
    1:   for (PRInt32 i = 0; i < cnt; i++)
    1:   {
    1:     nsISelectionListener* thisListener = selectionListeners[i];
    1:     if (thisListener)
    1:       thisListener->NotifySelectionChanged(domdoc, this, reason);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::StartBatchChanges()
    1: {
    1:   if (mFrameSelection)
    1:     mFrameSelection->StartBatchChanges();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::EndBatchChanges()
    1: {
    1:   if (mFrameSelection)
    1:     mFrameSelection->EndBatchChanges();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTypedSelection::DeleteFromDocument()
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_OK;//nothing to do
    1:   return mFrameSelection->DeleteFromDocument();
    1: }
    1: 
41477: NS_IMETHODIMP
41477: nsTypedSelection::Modify(const nsAString& aAlter, const nsAString& aDirection,
41477:                          const nsAString& aGranularity)
41477: {
41477:   // Silently exit if there's no selection or no focus node.
41477:   if (!mFrameSelection || !GetAnchorFocusRange() || !GetFocusNode()) {
41477:     return NS_OK;
41477:   }
41477: 
41477:   if (!aAlter.LowerCaseEqualsLiteral("move") &&
41477:       !aAlter.LowerCaseEqualsLiteral("extend")) {
41477:     return NS_ERROR_INVALID_ARG;
41477:   }
41477: 
41477:   if (!aDirection.LowerCaseEqualsLiteral("forward") &&
41477:       !aDirection.LowerCaseEqualsLiteral("backward") &&
41477:       !aDirection.LowerCaseEqualsLiteral("left") &&
41477:       !aDirection.LowerCaseEqualsLiteral("right")) {
41477:     return NS_ERROR_INVALID_ARG;
41477:   }
41477: 
41477:   // Line moves are always visual.
79445:   bool visual  = aDirection.LowerCaseEqualsLiteral("left") ||
41477:                    aDirection.LowerCaseEqualsLiteral("right") ||
41477:                    aGranularity.LowerCaseEqualsLiteral("line");
41477: 
79445:   bool forward = aDirection.LowerCaseEqualsLiteral("forward") ||
41477:                    aDirection.LowerCaseEqualsLiteral("right");
41477: 
79445:   bool extend  = aAlter.LowerCaseEqualsLiteral("extend");
41477: 
41477:   // The PRUint32 casts below prevent an enum mismatch warning.
41477:   nsSelectionAmount amount;
41477:   PRUint32 keycode;
41477:   if (aGranularity.LowerCaseEqualsLiteral("character")) {
59604:     amount = eSelectCluster;
41477:     keycode = forward ? (PRUint32) nsIDOMKeyEvent::DOM_VK_RIGHT :
41477:                         (PRUint32) nsIDOMKeyEvent::DOM_VK_LEFT;
41477:   }
41477:   else if (aGranularity.LowerCaseEqualsLiteral("word")) {
63601:     amount = eSelectWordNoSpace;
41477:     keycode = forward ? (PRUint32) nsIDOMKeyEvent::DOM_VK_RIGHT :
41477:                         (PRUint32) nsIDOMKeyEvent::DOM_VK_LEFT;
41477:   }
41477:   else if (aGranularity.LowerCaseEqualsLiteral("line")) {
41477:     amount = eSelectLine;
41477:     keycode = forward ? (PRUint32) nsIDOMKeyEvent::DOM_VK_DOWN :
41477:                         (PRUint32) nsIDOMKeyEvent::DOM_VK_UP;
41477:   }
41477:   else if (aGranularity.LowerCaseEqualsLiteral("lineboundary")) {
41477:     amount = eSelectLine;
41477:     keycode = forward ? (PRUint32) nsIDOMKeyEvent::DOM_VK_END :
41477:                         (PRUint32) nsIDOMKeyEvent::DOM_VK_HOME;
41477:   }
41477:   else if (aGranularity.LowerCaseEqualsLiteral("sentence") ||
41477:            aGranularity.LowerCaseEqualsLiteral("sentenceboundary") ||
41477:            aGranularity.LowerCaseEqualsLiteral("paragraph") ||
41477:            aGranularity.LowerCaseEqualsLiteral("paragraphboundary") ||
41477:            aGranularity.LowerCaseEqualsLiteral("documentboundary")) {
41477:     return NS_ERROR_NOT_IMPLEMENTED;
41477:   }
41477:   else {
41477:     return NS_ERROR_INVALID_ARG;
41477:   }
41477: 
41477:   // If the anchor doesn't equal the focus and we try to move without first
41477:   // collapsing the selection, MoveCaret will collapse the selection and quit.
41477:   // To avoid this, we need to collapse the selection first.
41477:   nsresult rv = NS_OK;
41477:   if (!extend) {
41477:     nsINode* focusNode = GetFocusNode();
41477:     // We should have checked earlier that there was a focus node.
41477:     NS_ENSURE_TRUE(focusNode, NS_ERROR_UNEXPECTED);
41477:     PRInt32 focusOffset = GetFocusOffset();
41477:     Collapse(focusNode, focusOffset);
41477:   }
41477: 
41477:   // If the base level of the focused frame is odd, we may have to swap the
41477:   // direction of the keycode.
41477:   nsIFrame *frame;
41477:   PRInt32 offset;
41477:   rv = GetPrimaryFrameForFocusNode(&frame, &offset, visual);
41477:   if (NS_SUCCEEDED(rv) && frame) {
41477:     nsBidiLevel baseLevel = nsBidiPresUtils::GetFrameBaseLevel(frame);
41477: 
41477:     if (baseLevel & 1) {
41477:       if (!visual && keycode == nsIDOMKeyEvent::DOM_VK_RIGHT) {
41477:         keycode = nsIDOMKeyEvent::DOM_VK_LEFT;
41477:       }
41477:       else if (!visual && keycode == nsIDOMKeyEvent::DOM_VK_LEFT) {
41477:         keycode = nsIDOMKeyEvent::DOM_VK_RIGHT;
41477:       }
41477:       else if (visual && keycode == nsIDOMKeyEvent::DOM_VK_HOME) {
41477:         keycode = nsIDOMKeyEvent::DOM_VK_END;
41477:       }
41477:       else if (visual && keycode == nsIDOMKeyEvent::DOM_VK_END) {
41477:         keycode = nsIDOMKeyEvent::DOM_VK_HOME;
41477:       }
41477:     }
41477:   }
41477: 
41477:   // MoveCaret will return an error if it can't move in the specified
41477:   // direction, but we just ignore this error unless it's a line move, in which
41477:   // case we call nsISelectionController::CompleteMove to move the cursor to
41477:   // the beginning/end of the line.
41477:   rv = mFrameSelection->MoveCaret(keycode, extend, amount, visual);
41477: 
41477:   if (aGranularity.LowerCaseEqualsLiteral("line") && NS_FAILED(rv)) {
41477:     nsCOMPtr<nsISelectionController> shell =
41477:       do_QueryInterface(mFrameSelection->GetShell());
41477:     if (!shell)
41477:       return NS_OK;
41477:     shell->CompleteMove(forward, extend);
41477:   }
41477:   return NS_OK;
41477: }
41477: 
    1: /** SelectionLanguageChange modifies the cursor Bidi level after a change in keyboard direction
80486:  *  @param aLangRTL is true if the new language is right-to-left or false if the new language is left-to-right
    1:  */
    1: NS_IMETHODIMP
79445: nsTypedSelection::SelectionLanguageChange(bool aLangRTL)
    1: {
    1:   if (!mFrameSelection)
    1:     return NS_ERROR_NOT_INITIALIZED; // Can't do selection
    1:   nsresult result;
    1:   nsIFrame *focusFrame = 0;
    1: 
80486:   result = GetPrimaryFrameForFocusNode(&focusFrame, nsnull, false);
26994:   if (NS_FAILED(result)) {
26994:     return result;
26994:   }
26994:   if (!focusFrame) {
26994:     return NS_ERROR_FAILURE;
26994:   }
    1: 
    1:   PRInt32 frameStart, frameEnd;
    1:   focusFrame->GetOffsets(frameStart, frameEnd);
39823:   nsRefPtr<nsPresContext> context;
    1:   PRUint8 levelBefore, levelAfter;
    1:   result = GetPresContext(getter_AddRefs(context));
    1:   if (NS_FAILED(result) || !context)
    1:     return result?result:NS_ERROR_FAILURE;
    1: 
    1:   PRUint8 level = NS_GET_EMBEDDING_LEVEL(focusFrame);
26994:   PRInt32 focusOffset = GetFocusOffset();
    1:   if ((focusOffset != frameStart) && (focusOffset != frameEnd))
    1:     // the cursor is not at a frame boundary, so the level of both the characters (logically) before and after the cursor
    1:     //  is equal to the frame level
    1:     levelBefore = levelAfter = level;
    1:   else {
    1:     // the cursor is at a frame boundary, so use GetPrevNextBidiLevels to find the level of the characters
    1:     //  before and after the cursor
26994:     nsCOMPtr<nsIContent> focusContent = do_QueryInterface(GetFocusNode());
    1:     /*
    1:     nsFrameSelection::HINT hint;
    1: 
    1:     if ((focusOffset == frameStart && level)        // beginning of an RTL frame
    1:         || (focusOffset == frameEnd && !level)) {   // end of an LTR frame
    1:       hint = nsFrameSelection::HINTRIGHT;
    1:     }
    1:     else {                                          // end of an RTL frame or beginning of an LTR frame
    1:       hint = nsFrameSelection::HINTLEFT;
    1:     }
    1:     mFrameSelection->SetHint(hint);
    1:     */
    1:     nsPrevNextBidiLevels levels = mFrameSelection->
80486:       GetPrevNextBidiLevels(focusContent, focusOffset, false);
    1:       
    1:     levelBefore = levels.mLevelBefore;
    1:     levelAfter = levels.mLevelAfter;
    1:   }
    1: 
    1:   if ((levelBefore & 1) == (levelAfter & 1)) {
    1:     // if cursor is between two characters with the same orientation, changing the keyboard language
    1:     //  must toggle the cursor level between the level of the character with the lowest level
    1:     //  (if the new language corresponds to the orientation of that character) and this level plus 1
    1:     //  (if the new language corresponds to the opposite orientation)
    1:     if ((level != levelBefore) && (level != levelAfter))
32531:       level = NS_MIN(levelBefore, levelAfter);
    1:     if ((level & 1) == aLangRTL)
    1:       mFrameSelection->SetCaretBidiLevel(level);
    1:     else
    1:       mFrameSelection->SetCaretBidiLevel(level + 1);
    1:   }
    1:   else {
    1:     // if cursor is between characters with opposite orientations, changing the keyboard language must change
    1:     //  the cursor level to that of the adjacent character with the orientation corresponding to the new language.
    1:     if ((levelBefore & 1) == aLangRTL)
    1:       mFrameSelection->SetCaretBidiLevel(levelBefore);
    1:     else
    1:       mFrameSelection->SetCaretBidiLevel(levelAfter);
    1:   }
    1:   
    1:   // The caret might have moved, so invalidate the desired X position
    1:   // for future usages of up-arrow or down-arrow
    1:   mFrameSelection->InvalidateDesiredX();
    1:   
    1:   return NS_OK;
    1: }
    1: 
74528: NS_IMETHODIMP_(nsDirection)
74528: nsTypedSelection::GetSelectionDirection() {
74528:   return mDirection;
74528: }
74528: 
74528: NS_IMETHODIMP_(void)
74528: nsTypedSelection::SetSelectionDirection(nsDirection aDirection) {
74528:   mDirection = aDirection;
74528: }
74528: 
    1: 
    1: // nsAutoCopyListener
    1: 
    1: nsAutoCopyListener* nsAutoCopyListener::sInstance = nsnull;
    1: 
    1: NS_IMPL_ISUPPORTS1(nsAutoCopyListener, nsISelectionListener)
    1: 
    1: /*
    1:  * What we do now:
    1:  * On every selection change, we copy to the clipboard anew, creating a
    1:  * HTML buffer, a transferable, an nsISupportsString and
    1:  * a huge mess every time.  This is basically what nsPresShell::DoCopy does
    1:  * to move the selection into the clipboard for Edit->Copy.
    1:  * 
    1:  * What we should do, to make our end of the deal faster:
    1:  * Create a singleton transferable with our own magic converter.  When selection
    1:  * changes (use a quick cache to detect ``real'' changes), we put the new
    1:  * nsISelection in the transferable.  Our magic converter will take care of
    1:  * transferable->whatever-other-format when the time comes to actually
    1:  * hand over the clipboard contents.
    1:  *
    1:  * Other issues:
    1:  * - which X clipboard should we populate?
    1:  * - should we use a different one than Edit->Copy, so that inadvertant
    1:  *   selections (or simple clicks, which currently cause a selection
    1:  *   notification, regardless of if they're in the document which currently has
    1:  *   selection!) don't lose the contents of the ``application''?  Or should we
    1:  *   just put some intelligence in the ``is this a real selection?'' code to
    1:  *   protect our selection against clicks in other documents that don't create
    1:  *   selections?
    1:  * - maybe we should just never clear the X clipboard?  That would make this 
    1:  *   problem just go away, which is very tempting.
    1:  */
    1: 
    1: NS_IMETHODIMP
    1: nsAutoCopyListener::NotifySelectionChanged(nsIDOMDocument *aDoc,
    1:                                            nsISelection *aSel, PRInt16 aReason)
    1: {
    1:   if (!(aReason & nsISelectionListener::MOUSEUP_REASON   || 
    1:         aReason & nsISelectionListener::SELECTALL_REASON ||
    1:         aReason & nsISelectionListener::KEYPRESS_REASON))
    1:     return NS_OK; //dont care if we are still dragging
    1: 
79445:   bool collapsed;
    1:   if (!aDoc || !aSel ||
    1:       NS_FAILED(aSel->GetIsCollapsed(&collapsed)) || collapsed) {
    1: #ifdef DEBUG_CLIPBOARD
    1:     fprintf(stderr, "CLIPBOARD: no selection/collapsed selection\n");
    1: #endif
    1:     /* clear X clipboard? */
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDoc);
    1:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
    1: 
    1:   // call the copy code
    1:   return nsCopySupport::HTMLCopy(aSel, doc, nsIClipboard::kSelectionClipboard);
    1: }
