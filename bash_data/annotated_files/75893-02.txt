75615: /* -*- Mode: c++; c-basic-offset: 4; tab-width: 40; indent-tabs-mode: nil -*- */
75615: /* vim: set ts=40 sw=4 et tw=99: */
75615: /* ***** BEGIN LICENSE BLOCK *****
75615:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
75615:  *
75615:  * The contents of this file are subject to the Mozilla Public License Version
75615:  * 1.1 (the "License"); you may not use this file except in compliance with
75615:  * the License. You may obtain a copy of the License at
75615:  * http://www.mozilla.org/MPL/
75615:  *
75615:  * Software distributed under the License is distributed on an "AS IS" basis,
75615:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
75615:  * for the specific language governing rights and limitations under the
75615:  * License.
75615:  *
75615:  * The Original Code is the Mozilla SpiderMonkey bytecode type inference
75615:  *
75615:  * The Initial Developer of the Original Code is
75615:  *   Mozilla Foundation
75615:  * Portions created by the Initial Developer are Copyright (C) 2010
75615:  * the Initial Developer. All Rights Reserved.
75615:  *
75615:  * Contributor(s):
75615:  *   Brian Hackett <bhackett@mozilla.com>
75615:  *
75615:  * Alternatively, the contents of this file may be used under the terms of
75615:  * either of the GNU General Public License Version 2 or later (the "GPL"),
75615:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
75615:  * in which case the provisions of the GPL or the LGPL are applicable instead
75615:  * of those above. If you wish to allow use of your version of this file only
75615:  * under the terms of either the GPL or the LGPL, and not to allow others to
75615:  * use your version of this file under the terms of the MPL, indicate your
75615:  * decision by deleting the provisions above and replace them with the notice
75615:  * and other provisions required by the GPL or the LGPL. If you do not delete
75615:  * the provisions above, a recipient may use your version of this file under
75615:  * the terms of any one of the MPL, the GPL or the LGPL.
75615:  *
75615:  * ***** END LICENSE BLOCK ***** */
75615: 
75615: /* Definitions related to javascript type inference. */
75615: 
75615: #ifndef jsinfer_h___
75615: #define jsinfer_h___
75615: 
75615: #include "jsarena.h"
75615: #include "jstl.h"
75615: #include "jsprvtd.h"
75686: #include "jsvalue.h"
75615: 
75616: #ifndef _MSC_VER
75616: #include <sys/time.h>
75616: #endif
75616: 
75720: namespace js {
75720:     struct CallArgs;
75720: namespace analyze {
75615:     struct Bytecode;
75615:     class Script;
75615: } }
75615: 
75615: namespace js {
75615: namespace types {
75615: 
75615: /* Forward declarations. */
75615: struct TypeSet;
75615: struct TypeCallsite;
75615: struct TypeObject;
75615: struct TypeFunction;
75615: struct TypeCompartment;
75794: struct ClonedTypeSet;
75615: 
75615: /*
75615:  * Information about a single concrete type.  This is a non-zero value whose
75615:  * lower 3 bits indicate a particular primitive type below, and if those bits
75615:  * are zero then a pointer to a type object.
75615:  */
75615: typedef jsword jstype;
75615: 
75615: /* The primitive types. */
75615: const jstype TYPE_UNDEFINED = 1;
75615: const jstype TYPE_NULL      = 2;
75615: const jstype TYPE_BOOLEAN   = 3;
75615: const jstype TYPE_INT32     = 4;
75615: const jstype TYPE_DOUBLE    = 5;
75615: const jstype TYPE_STRING    = 6;
75615: 
75615: /*
75615:  * Aggregate unknown type, could be anything.  Typically used when a type set
75615:  * becomes polymorphic, or when accessing an object with unknown properties.
75615:  */
75615: const jstype TYPE_UNKNOWN = 7;
75615: 
75615: /*
75615:  * Test whether a type is an primitive or an object.  Object types can be
75615:  * cast into a TypeObject*.
75615:  */
75615: 
75615: static inline bool
75615: TypeIsPrimitive(jstype type)
75615: {
75775:     JS_ASSERT(type);
75615:     return type < TYPE_UNKNOWN;
75615: }
75615: 
75615: static inline bool
75615: TypeIsObject(jstype type)
75615: {
75775:     JS_ASSERT(type);
75615:     return type > TYPE_UNKNOWN;
75615: }
75615: 
75615: /* Get the type of a jsval, or zero for an unknown special value. */
75615: inline jstype GetValueType(JSContext *cx, const Value &val);
75615: 
75615: /*
75718:  * Type inference memory management overview.
75718:  *
75718:  * Inference constructs a global web of constraints relating the contents of
75718:  * type sets particular to various scripts and type objects within a compartment.
75718:  * There are two issues at hand to manage inference memory: collecting
75718:  * the constraints, and collecting type sets (on TypeObject destruction).
75718:  *
75718:  * The constraints and types generated during analysis of a script depend entirely on
75718:  * that script's input type sets --- the types of its arguments, upvar locals,
75718:  * callee return values, object properties, and dynamic types (overflows, undefined
75718:  * reads, etc.). On a GC, we collect the analysis information for all scripts
75718:  * which have been analyzed, destroying the type constraints and intermediate
75718:  * type sets associated with stack values, and add new condensed constraints to
75718:  * the script's inputs which will trigger reanalysis and recompilation should
75718:  * that input change in the future.
75718:  *
75718:  * TypeObjects are collected when either the script they are associated with is
75718:  * destroyed or their prototype JSObject is destroyed.
75718:  *
75718:  * If a GC happens while we are in the middle of analysis or working with a TypeScript
75718:  * or TypeObject, we do not destroy/condense analysis information or collect any
75718:  * TypeObjects or JSScripts. This is controlled with AutoEnterTypeInference.
75718:  */
75718: 
75718: /*
75615:  * A constraint which listens to additions to a type set and propagates those
75615:  * changes to other type sets.
75615:  */
75615: class TypeConstraint
75615: {
75615: public:
75638: #ifdef DEBUG
75638:     const char *kind_;
75638:     const char *kind() const { return kind_; }
75638: #else
75638:     const char *kind() const { return NULL; }
75615: #endif
75615: 
75615:     /* Next constraint listening to the same type set. */
75615:     TypeConstraint *next;
75615: 
75718:     /*
75718:      * Script this constraint indicates an input for. If this constraint
75718:      * is not on an intermediate (script-local) type set, then during
75718:      * GC this will be replaced with a condensed input type constraint.
75718:      */
75718:     JSScript *script;
75718: 
75718:     TypeConstraint(const char *kind, JSScript *script)
75718:         : next(NULL), script(script)
75615:     {
75718:         JS_ASSERT(script);
75638: #ifdef DEBUG
75638:         this->kind_ = kind;
75615: #endif
75615:     }
75615: 
75615:     /* Register a new type for the set this constraint is listening to. */
75615:     virtual void newType(JSContext *cx, TypeSet *source, jstype type) = 0;
75625: 
75625:     /*
75833:      * For constraints attached to the index type set of an object (JSID_VOID),
75833:      * mark a change in one of the object's dynamic properties (isDenseArray,
75833:      * isPackedArray, or unknownProperties).
75625:      */
75833:     virtual void newObjectState(JSContext *cx) {}
75718: 
75718:     /*
75718:      * Whether this is an input type constraint condensed from the original
75718:      * constraints generated during analysis of the associated script.
75718:      * If this type set changes then the script will be reanalyzed/recompiled
75718:      * should the type set change at all in the future.
75718:      */
75718:     virtual bool condensed() { return false; }
75718: 
75718:     /*
75718:      * If this is a persistent subset constraint, the object being propagated
75718:      * into. Such constraints describe relationships between TypeObject
75718:      * properties which are independent of the analysis of any script.
75718:      */
75718:     virtual TypeObject * baseSubset() { return NULL; }
75625: };
75625: 
75625: /*
75625:  * Coarse kinds of a set of objects.  These form the following lattice:
75625:  *
75625:  *                    NONE
75625:  *       ___________ /  | \______________
75625:  *      /               |                \
75864:  * PACKED_ARRAY  INLINEABLE_FUNCTION  NATIVE_FUNCTION
75625:  *      |               |                 |
75864:  * DENSE_ARRAY    SCRIPTED_FUNCTION       |
75625:  *      \____________   |   _____________/
75625:  *                   \  |  /
75833:  *             NO_SPECIAL_EQUALITY
75833:  *                      |
75625:  *                   UNKNOWN
75625:  */
75625: enum ObjectKind {
75625:     OBJECT_NONE,
75625:     OBJECT_UNKNOWN,
75625:     OBJECT_PACKED_ARRAY,
75625:     OBJECT_DENSE_ARRAY,
75864:     OBJECT_INLINEABLE_FUNCTION,
75625:     OBJECT_SCRIPTED_FUNCTION,
75833:     OBJECT_NATIVE_FUNCTION,
75833:     OBJECT_NO_SPECIAL_EQUALITY
75615: };
75615: 
75720: /* Coarse flags for the contents of a type set. */
75720: enum {
75720:     TYPE_FLAG_UNDEFINED = 1 << TYPE_UNDEFINED,
75720:     TYPE_FLAG_NULL      = 1 << TYPE_NULL,
75720:     TYPE_FLAG_BOOLEAN   = 1 << TYPE_BOOLEAN,
75720:     TYPE_FLAG_INT32     = 1 << TYPE_INT32,
75720:     TYPE_FLAG_DOUBLE    = 1 << TYPE_DOUBLE,
75720:     TYPE_FLAG_STRING    = 1 << TYPE_STRING,
75720: 
75720:     TYPE_FLAG_UNKNOWN   = 1 << TYPE_UNKNOWN,
75720: 
75720:     /* Flag for type sets which are cleared on GC. */
75720:     TYPE_FLAG_INTERMEDIATE_SET = 0x1000
75720: };
75720: 
75720: /* Vector of the above flags. */
75720: typedef uint32 TypeFlags;
75720: 
75615: /* Information about the set of types associated with an lvalue. */
75615: struct TypeSet
75615: {
75615:     /* Flags for the possible coarse types in this set. */
75615:     TypeFlags typeFlags;
75615: 
75720:     /* Possible objects this type set can represent. */
75615:     TypeObject **objectSet;
75615:     unsigned objectCount;
75615: 
75615:     /* Chain of constraints which propagate changes out from this type set. */
75615:     TypeConstraint *constraintList;
75615: 
75718:     TypeSet()
75615:         : typeFlags(0), objectSet(NULL), objectCount(0), constraintList(NULL)
75718:     {}
75615: 
75638:     void print(JSContext *cx);
75615: 
75720:     void setIntermediate() { typeFlags |= TYPE_FLAG_INTERMEDIATE_SET; }
75720: 
75720:     inline void destroy(JSContext *cx);
75720: 
75615:     /* Whether this set contains a specific type. */
75615:     inline bool hasType(jstype type);
75615: 
75697:     bool unknown() { return typeFlags & TYPE_FLAG_UNKNOWN; }
75697: 
75615:     /*
75615:      * Add a type to this set, calling any constraint handlers if this is a new
75615:      * possible type.
75615:      */
75615:     inline void addType(JSContext *cx, jstype type);
75615: 
75794:     /* Add all types in a cloned set to this set. */
75794:     void addTypeSet(JSContext *cx, ClonedTypeSet *types);
75794: 
75615:     /* Add specific kinds of constraints to this set. */
75625:     inline void add(JSContext *cx, TypeConstraint *constraint, bool callExisting = true);
75718:     void addSubset(JSContext *cx, JSScript *script, TypeSet *target);
75708:     void addGetProperty(JSContext *cx, JSScript *script, const jsbytecode *pc,
75708:                         TypeSet *target, jsid id);
75708:     void addSetProperty(JSContext *cx, JSScript *script, const jsbytecode *pc,
75708:                         TypeSet *target, jsid id);
75718:     void addNewObject(JSContext *cx, JSScript *script, TypeFunction *fun, TypeSet *target);
75615:     void addCall(JSContext *cx, TypeCallsite *site);
75718:     void addArith(JSContext *cx, JSScript *script,
75615:                   TypeSet *target, TypeSet *other = NULL);
75708:     void addTransformThis(JSContext *cx, JSScript *script, TypeSet *target);
75718:     void addFilterPrimitives(JSContext *cx, JSScript *script,
75708:                              TypeSet *target, bool onlyNullVoid);
75718:     void addMonitorRead(JSContext *cx, JSScript *script, TypeSet *target);
75718: 
75718:     void addBaseSubset(JSContext *cx, TypeObject *object, TypeSet *target);
75718:     void addCondensed(JSContext *cx, JSScript *script);
75615: 
75625:     /*
75625:      * Make an intermediate type set with the specified debugging name,
75625:      * not embedded in another structure.
75625:      */
75720:     static inline TypeSet* make(JSContext *cx, const char *name);
75625: 
75775:     /*
75893:      * Methods for JIT compilation. If a script is currently being compiled
75893:      * (see AutoEnterCompilation) these will add constraints ensuring that if
75893:      * the return value change in the future due to new type information, the
75893:      * currently compiled script will be marked for recompilation.
75775:      */
75615: 
75870:     /* Completely freeze the contents of this type set. */
75893:     void addFreeze(JSContext *cx);
75870: 
75775:     /* Get any type tag which all values in this set must have. */
75893:     JSValueType getKnownTypeTag(JSContext *cx);
75622: 
75625:     /* Get information about the kinds of objects in this type set. */
75893:     ObjectKind getKnownObjectKind(JSContext *cx);
75615: 
75833:     /* Whether any objects in this type set have unknown properties. */
75893:     bool hasUnknownProperties(JSContext *cx);
75833: 
75677:     /* Get whether this type set is non-empty. */
75893:     bool knownNonEmpty(JSContext *cx);
75761: 
75845:     /* Get the single value which can appear in this type set, otherwise NULL. */
75893:     JSObject *getSingleton(JSContext *cx);
75845: 
75827:     /* Mark all current and future types in this set as pushed by script/pc. */
75827:     void pushAllTypes(JSContext *cx, JSScript *script, const jsbytecode *pc);
75827: 
75794:     /*
75827:      * Clone (possibly NULL) source onto target; if any new types are added to
75827:      * source in the future, the script will be recompiled.
75794:      */
75893:     static void Clone(JSContext *cx, TypeSet *source, ClonedTypeSet *target);
75794: 
75761:   private:
75761:     inline void markUnknown(JSContext *cx);
75615: };
75615: 
75794: /* A type set captured for use by JIT compilers. */
75794: struct ClonedTypeSet
75794: {
75794:     TypeFlags typeFlags;
75794:     TypeObject **objectSet;
75794:     unsigned objectCount;
75794: };
75794: 
75641: /* Type information about a property. */
75641: struct Property
75615: {
75641:     /* Identifier for this property, JSID_VOID for the aggregate integer index property. */
75641:     jsid id;
75638: 
75641:     /* Possible types for this property, including types inherited from prototypes. */
75641:     TypeSet types;
75615: 
75641:     /* Types for this property resulting from direct sets on the object. */
75641:     TypeSet ownTypes;
75615: 
75718:     Property(jsid id)
75718:         : id(id)
75641:     {}
75615: 
75641:     static uint32 keyBits(jsid id) { return (uint32) JSID_BITS(id); }
75641:     static jsid getKey(Property *p) { return p->id; }
75615: };
75615: 
75615: /* Type information about an object accessed by a script. */
75615: struct TypeObject
75615: {
75679: #ifdef DEBUG
75679:     /* Name of this object. */
75679:     jsid name_;
75679: #endif
75679: 
75679:     /* Prototype shared by objects using this type. */
75679:     JSObject *proto;
75679: 
75679:     /* Lazily filled array of empty shapes for each size of objects with this type. */
75679:     js::EmptyShape **emptyShapes;
75615: 
75615:     /* Whether this is a function object, and may be cast into TypeFunction. */
75615:     bool isFunction;
75615: 
75679:     /* Mark bit for GC. */
75679:     bool marked;
75679: 
75615:     /*
75708:      * Whether this is an Object or Array keyed to an offset in the script containing
75708:      * this in its objects list.
75708:      */
75708:     bool initializerObject;
75708:     bool initializerArray;
75708:     uint32 initializerOffset;
75708: 
75708:     /*
75761:      * Estimate of the contribution of this object to the type sets it appears in.
75761:      * This is the sum of the sizes of those sets at the point when the object
75761:      * was added.
75761:      *
75761:      * When the contribution exceeds the CONTRIBUTION_LIMIT, any type sets the
75761:      * object is added to are instead marked as unknown. If we get to this point
75761:      * we are probably not adding types which will let us do meaningful optimization
75761:      * later, and we want to ensure in such cases that our time/space complexity
75761:      * is linear, not worst-case cubic as it would otherwise be.
75761:      */
75761:     uint32 contribution;
75761:     static const uint32 CONTRIBUTION_LIMIT = 20000;
75761: 
75761:     /*
75679:      * Properties of this object. This may contain JSID_VOID, representing the types
75679:      * of all integer indexes of the object, and/or JSID_EMPTY, representing the types
75679:      * of new objects that can be created with different instances of this type.
75615:      */
75641:     Property **propertySet;
75641:     unsigned propertyCount;
75615: 
75641:     /* List of objects using this one as their prototype. */
75641:     TypeObject *instanceList;
75641: 
75641:     /* Chain for objects sharing the same prototype. */
75641:     TypeObject *instanceNext;
75641: 
75760:     /* Link in the list of objects associated with a script or global object. */
75615:     TypeObject *next;
75615: 
75734:     /*
75734:      * Whether all the properties of this object are unknown. When this object
75734:      * appears in a type set, nothing can be assumed about its contents, including
75734:      * whether the .proto field is correct. This is needed to handle mutable
75734:      * __proto__, which requires us to unify all type objects with unknown
75734:      * properties in type sets (see SetProto).
75734:      */
75641:     bool unknownProperties;
75615: 
75625:     /* Whether all objects this represents are dense arrays. */
75625:     bool isDenseArray;
75625: 
75625:     /* Whether all objects this represents are packed arrays (implies isDenseArray). */
75625:     bool isPackedArray;
75625: 
75864:     /* Whether any objects this represents have had their .arguments accessed. */
75864:     bool isUninlineable;
75864: 
75833:     /* Whether any objects this represents have an equality hook. */
75833:     bool hasSpecialEquality;
75833: 
75864:     /* If at most one JSObject can have this as its type, that object. */
75845:     JSObject *singleton;
75845: 
75679:     TypeObject() {}
75679: 
75615:     /* Make an object with the specified name. */
75718:     inline TypeObject(jsid id, JSObject *proto);
75615: 
75615:     /* Coerce this object to a function. */
75615:     TypeFunction* asFunction()
75615:     {
75625:         JS_ASSERT(isFunction);
75615:         return (TypeFunction *) this;
75615:     }
75615: 
75641:     /*
75679:      * Return an immutable, shareable, empty shape with the same clasp as this
75679:      * and the same slotSpan as this had when empty.
75679:      *
75679:      * If |this| is the scope of an object |proto|, the resulting scope can be
75679:      * used as the scope of a new object whose prototype is |proto|.
75679:      */
75679:     inline bool canProvideEmptyShape(js::Class *clasp);
75679:     inline js::EmptyShape *getEmptyShape(JSContext *cx, js::Class *aclasp,
75679:                                          /* gc::FinalizeKind */ unsigned kind);
75679: 
75679:     /*
75641:      * Get or create a property of this object. Only call this for properties which
75641:      * a script accesses explicitly. 'assign' indicates whether this is for an
75641:      * assignment, and the own types of the property will be used instead of
75641:      * aggregate types.
75641:      */
75641:     inline TypeSet *getProperty(JSContext *cx, jsid id, bool assign);
75615: 
75679:     inline const char * name();
75679: 
75679:     /* Mark proto as the prototype of this object and all instances. */
75705:     void splicePrototype(JSContext *cx, JSObject *proto);
75615: 
75641:     /* Helpers */
75640: 
75720:     bool addProperty(JSContext *cx, jsid id, Property **pprop);
75641:     void addPrototype(JSContext *cx, TypeObject *proto);
75720:     void markNotPacked(JSContext *cx, bool notDense);
75641:     void markUnknown(JSContext *cx);
75864:     void markUninlineable(JSContext *cx);
75641:     void storeToInstances(JSContext *cx, Property *base);
75705:     void getFromPrototypes(JSContext *cx, Property *base);
75615: 
75638:     void print(JSContext *cx);
75679:     void trace(JSTracer *trc);
75615: };
75615: 
75688: /*
75688:  * Type information about an interpreted or native function. Note: it is possible for
75688:  * a function JSObject to have a type which is not a TypeFunction. This happens when
75688:  * we are not able to statically model the type of a function due to non-compileAndGo code.
75688:  */
75615: struct TypeFunction : public TypeObject
75615: {
75615:     /* If this function is native, the handler to use at calls to it. */
75615:     JSTypeHandler handler;
75615: 
75615:     /* If this function is interpreted, the corresponding script. */
75615:     JSScript *script;
75615: 
75615:     /*
75615:      * Whether this is a generic native handler, and treats its first parameter
75615:      * the way it normally would its 'this' variable, e.g. Array.reverse(arr)
75615:      * instead of arr.reverse().
75615:      */
75615:     bool isGeneric;
75615: 
75718:     inline TypeFunction(jsid id, JSObject *proto);
75615: };
75615: 
75708: /*
75708:  * Type information about a callsite. this is separated from the bytecode
75708:  * information itself so we can handle higher order functions not called
75708:  * directly via a bytecode.
75708:  */
75708: struct TypeCallsite
75708: {
75708:     JSScript *script;
75708:     const jsbytecode *pc;
75708: 
75708:     /* Whether this is a 'NEW' call. */
75708:     bool isNew;
75708: 
75708:     /* Types of each argument to the call. */
75708:     TypeSet **argumentTypes;
75708:     unsigned argumentCount;
75708: 
75708:     /* Types of the this variable. */
75708:     TypeSet *thisTypes;
75708: 
75708:     /* Any definite type for 'this'. */
75708:     jstype thisType;
75708: 
75708:     /* Type set receiving the return value of this call. */
75708:     TypeSet *returnTypes;
75708: 
75720:     inline TypeCallsite(JSContext *cx, JSScript *script, const jsbytecode *pc,
75708:                         bool isNew, unsigned argumentCount);
75708: 
75720:     /* Force creation of thisTypes. */
75720:     inline bool forceThisTypes(JSContext *cx);
75708: 
75708:     /* Get the new object at this callsite. */
75708:     inline TypeObject* getInitObject(JSContext *cx, bool isArray);
75708: 
75718:     inline bool compileAndGo();
75718: };
75708: 
75718: /*
75718:  * Type information about a dynamic value pushed by a script's opcode.
75718:  * These are associated with each JSScript and persist after the
75718:  * TypeScript is destroyed by GCs.
75718:  */
75718: struct TypeResult
75718: {
75718:     /*
75718:      * Offset pushing the value. TypeResults are only generated for
75718:      * the first stack slot actually pushed by a bytecode.
75718:      */
75718:     uint32 offset;
75718: 
75718:     /* Type which was pushed. */
75718:     jstype type;
75718: 
75718:     /* Next dynamic result for the script. */
75718:     TypeResult *next;
75708: };
75708: 
75708: /* Type information for a script, result of AnalyzeTypes. */
75708: struct TypeScript
75708: {
75708: #ifdef DEBUG
75708:     JSScript *script;
75708: #endif
75708: 
75708:     /*
75708:      * Stack values pushed by all bytecodes in the script. Low bit is set for
75708:      * bytecodes which are monitored (side effects were not determined statically).
75708:      */
75708:     TypeSet **pushedArray;
75708: 
75708:     /* Gather statistics off this script and print it if necessary. */
75770:     void print(JSContext *cx, JSScript *script);
75708: 
75708:     inline bool monitored(uint32 offset);
75708:     inline void setMonitored(uint32 offset);
75708: 
75708:     inline TypeSet *pushed(uint32 offset);
75708:     inline TypeSet *pushed(uint32 offset, uint32 index);
75708: 
75708:     inline void addType(JSContext *cx, uint32 offset, uint32 index, jstype type);
75708: };
75708: 
75708: /* Analyzes all types in script, constructing its TypeScript. */
75718: void AnalyzeScriptTypes(JSContext *cx, JSScript *script);
75718: 
75768: /* Analyze the effect of invoking 'new' on script. */
75768: void AnalyzeScriptNew(JSContext *cx, JSScript *script);
75708: 
75770: struct ArrayTableKey;
75771: typedef HashMap<ArrayTableKey,TypeObject*,ArrayTableKey,SystemAllocPolicy> ArrayTypeTable;
75770: 
75770: struct ObjectTableKey;
75770: struct ObjectTableEntry;
75771: typedef HashMap<ObjectTableKey,ObjectTableEntry,ObjectTableKey,SystemAllocPolicy> ObjectTypeTable;
75770: 
75615: /* Type information for a compartment. */
75615: struct TypeCompartment
75615: {
75718:     /* List of objects not associated with a script. */
75615:     TypeObject *objects;
75615: 
75720:     /* Whether type inference is enabled in this compartment. */
75720:     bool inferenceEnabled;
75720: 
75720:     /* Whether type inference is active, see AutoEnterTypeInference. */
75718:     unsigned inferenceDepth;
75720:     uint64_t inferenceStartTime;
75720: 
75720:     /* Pool for all intermediate type information in this compartment. Cleared on every GC. */
75720:     JSArenaPool pool;
75718: 
75615:     /* Number of scripts in this compartment. */
75615:     unsigned scriptCount;
75615: 
75679:     /* Object to use throughout the compartment as the default type of objects with no prototype. */
75760:     TypeObject typeEmpty;
75615: 
75720:     /*
75720:      * Bit set if all current types must be marked as unknown, and all scripts
75720:      * recompiled. Caused by OOM failure within inference operations.
75720:      */
75720:     bool pendingNukeTypes;
75720: 
75720:     /*
75720:      * Whether type sets have been nuked, and all future type sets should be as well.
75720:      * This is not strictly necessary to do, but avoids thrashing from repeated
75720:      * redundant type nuking.
75720:      */
75720:     bool typesNuked;
75720: 
75636:     /* Pending recompilations to perform before execution of JIT code can resume. */
75636:     Vector<JSScript*> *pendingRecompiles;
75636: 
75883:     /*
75883:      * Number of recompilation events and inline frame expansions that have
75883:      * occurred in this compartment. If these change, code should not count on
75883:      * compiled code or the current stack being intact.
75883:      */
75883:     unsigned recompilations;
75883:     unsigned frameExpansions;
75883: 
75893:     /*
75893:      * Script currently being compiled. All constraints which look for type
75893:      * changes inducing recompilation are keyed to this script. Note: script
75893:      * compilation is not reentrant.
75893:      */
75893:     JSScript *compiledScript;
75893: 
75770:     /* Tables for determining types of singleton/JSON objects. */
75770: 
75770:     ArrayTypeTable *arrayTypeTable;
75770:     ObjectTypeTable *objectTypeTable;
75770: 
75770:     bool fixArrayType(JSContext *cx, JSObject *obj);
75770:     bool fixObjectType(JSContext *cx, JSObject *obj);
75770: 
75615:     /* Constraint solving worklist structures. */
75615: 
75615:     /* A type that needs to be registered with a constraint. */
75615:     struct PendingWork
75615:     {
75615:         TypeConstraint *constraint;
75615:         TypeSet *source;
75615:         jstype type;
75615:     };
75615: 
75615:     /*
75615:      * Worklist of types which need to be propagated to constraints.  We use a
75615:      * worklist to avoid blowing the native stack.
75615:      */
75615:     PendingWork *pendingArray;
75615:     unsigned pendingCount;
75615:     unsigned pendingCapacity;
75615: 
75615:     /* Whether we are currently resolving the pending worklist. */
75615:     bool resolving;
75615: 
75615:     /* Logging fields */
75615: 
75615:     /*
75615:      * The total time (in microseconds) spent generating inference structures
75615:      * and performing analysis.
75615:      */
75615:     uint64_t analysisTime;
75615: 
75615:     /* Counts of stack type sets with some number of possible operand types. */
75615:     static const unsigned TYPE_COUNT_LIMIT = 4;
75615:     unsigned typeCounts[TYPE_COUNT_LIMIT];
75615:     unsigned typeCountOver;
75615: 
75720:     void init(JSContext *cx);
75770:     ~TypeCompartment();
75615: 
75615:     uint64 currentTime()
75615:     {
75776: #if 0
75615:         timeval current;
75615:         gettimeofday(&current, NULL);
75615:         return current.tv_sec * (uint64_t) 1000000 + current.tv_usec;
75616: #else
75616:         /* Timing not available on Windows. */
75616:         return 0;
75616: #endif
75615:     }
75615: 
75615:     /* Add a type to register with a list of constraints. */
75615:     inline void addPending(JSContext *cx, TypeConstraint *constraint, TypeSet *source, jstype type);
75718:     void growPendingArray(JSContext *cx);
75615: 
75615:     /* Resolve pending type registrations, excluding delayed ones. */
75615:     inline void resolvePending(JSContext *cx);
75615: 
75638:     /* Prints results of this compartment if spew is enabled, checks for warnings. */
75770:     void print(JSContext *cx, JSCompartment *compartment);
75615: 
75679:     /* Make a function or non-function object associated with an optional script. */
75718:     TypeObject *newTypeObject(JSContext *cx, JSScript *script,
75679:                               const char *name, bool isFunction, JSObject *proto);
75615: 
75708:     /* Make an initializer object. */
75708:     TypeObject *newInitializerTypeObject(JSContext *cx, JSScript *script,
75708:                                          uint32 offset, bool isArray);
75708: 
75615:     /*
75633:      * Add the specified type to the specified set, do any necessary reanalysis
75633:      * stemming from the change and recompile any affected scripts.
75615:      */
75720:     bool dynamicPush(JSContext *cx, JSScript *script, uint32 offset, jstype type);
75720:     bool dynamicAssign(JSContext *cx, JSObject *obj, jsid id, const Value &rval);
75720:     bool dynamicCall(JSContext *cx, JSObject *callee, const CallArgs &args, bool constructing);
75615: 
75720:     inline bool checkPendingRecompiles(JSContext *cx);
75720: 
75720:     bool nukeTypes(JSContext *cx);
75720:     bool processPendingRecompiles(JSContext *cx);
75720: 
75720:     /* Mark all types as needing destruction once inference has 'finished'. */
75720:     void setPendingNukeTypes(JSContext *cx);
75720: 
75720:     /* Mark a script as needing recompilation once inference has finished. */
75636:     void addPendingRecompile(JSContext *cx, JSScript *script);
75636: 
75615:     /* Monitor future effects on a bytecode. */
75708:     void monitorBytecode(JSContext *cx, JSScript *script, uint32 offset);
75760: 
75760:     void condense(JSContext *cx);
75760:     void sweep(JSContext *cx);
75718: };
75637: 
75638: enum SpewChannel {
75638:     ISpewOps,      /* ops: New constraints and types. */
75638:     ISpewResult,   /* result: Final type sets. */
75638:     SPEW_COUNT
75638: };
75638: 
75638: #ifdef DEBUG
75638: 
75638: void InferSpew(SpewChannel which, const char *fmt, ...);
75640: const char * TypeString(jstype type);
75638: 
75737: /* Check that the type property for id in obj contains value. */
75737: bool TypeHasProperty(JSContext *cx, TypeObject *obj, jsid id, const Value &value);
75737: 
75638: #else
75638: 
75638: inline void InferSpew(SpewChannel which, const char *fmt, ...) {}
75640: inline const char * TypeString(jstype type) { return NULL; }
75638: 
75638: #endif
75638: 
75640: /* Print a warning, dump state and abort the program. */
75640: void TypeFailure(JSContext *cx, const char *fmt, ...);
75640: 
75615: } /* namespace types */
75615: } /* namespace js */
75615: 
75615: static JS_ALWAYS_INLINE js::types::TypeObject *
75615: Valueify(JSTypeObject *jstype) { return (js::types::TypeObject*) jstype; }
75615: 
75615: static JS_ALWAYS_INLINE js::types::TypeFunction *
75615: Valueify(JSTypeFunction *jstype) { return (js::types::TypeFunction*) jstype; }
75615: 
75615: static JS_ALWAYS_INLINE js::types::TypeCallsite *
75615: Valueify(JSTypeCallsite *jssite) { return (js::types::TypeCallsite*) jssite; }
75615: 
75615: #endif // jsinfer_h___
