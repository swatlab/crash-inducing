129708: # This Source Code Form is subject to the terms of the Mozilla Public
129708: # License, v. 2.0. If a copy of the MPL was not distributed with this
129708: # file, You can obtain one at http://mozilla.org/MPL/2.0/.
129708: 
129708: r"""Data structures representing Mozilla's source tree.
129708: 
129708: The frontend files are parsed into static data structures. These data
129708: structures are defined in this module.
129708: 
129708: All data structures of interest are children of the TreeMetadata class.
129708: 
129708: Logic for populating these data structures is not defined in this class.
129708: Instead, what we have here are dumb container classes. The emitter module
129708: contains the code for converting executed mozbuild files into these data
129708: structures.
129708: """
129708: 
129708: from __future__ import unicode_literals
129708: 
156517: import os
156517: 
129708: from collections import OrderedDict
173524: from mozbuild.util import (
173524:     shell_quote,
173524:     StrictOrderingOnAppendList,
173524: )
175140: from .sandbox_symbols import FinalTargetValue
129708: 
129708: 
129708: class TreeMetadata(object):
129708:     """Base class for all data being captured."""
129708: 
169808:     def __init__(self):
169808:         self._ack = False
169808: 
169808:     def ack(self):
169808:         self._ack = True
169808: 
129708: 
134922: class ReaderSummary(TreeMetadata):
134922:     """A summary of what the reader did."""
134922: 
134922:     def __init__(self, total_file_count, total_execution_time):
169808:         TreeMetadata.__init__(self)
134922:         self.total_file_count = total_file_count
134922:         self.total_execution_time = total_execution_time
134922: 
134922: 
129708: class SandboxDerived(TreeMetadata):
129708:     """Build object derived from a single MozbuildSandbox instance.
129708: 
129708:     It holds fields common to all sandboxes. This class is likely never
129708:     instantiated directly but is instead derived from.
129708:     """
129708: 
129708:     __slots__ = (
129708:         'objdir',
129708:         'relativedir',
130925:         'sandbox_all_paths',
130925:         'sandbox_path',
129708:         'srcdir',
129708:         'topobjdir',
129708:         'topsrcdir',
129708:     )
129708: 
129708:     def __init__(self, sandbox):
169808:         TreeMetadata.__init__(self)
169808: 
130925:         # Capture the files that were evaluated to build this sandbox.
130925:         self.sandbox_main_path = sandbox.main_path
130925:         self.sandbox_all_paths = sandbox.all_paths
130925: 
130925:         # Basic directory state.
129708:         self.topsrcdir = sandbox['TOPSRCDIR']
129708:         self.topobjdir = sandbox['TOPOBJDIR']
129708: 
129708:         self.relativedir = sandbox['RELATIVEDIR']
129708:         self.srcdir = sandbox['SRCDIR']
129708:         self.objdir = sandbox['OBJDIR']
129708: 
129708: 
129708: class DirectoryTraversal(SandboxDerived):
129708:     """Describes how directory traversal for building should work.
129708: 
129708:     This build object is likely only of interest to the recursive make backend.
129708:     Other build backends should (ideally) not attempt to mimic the behavior of
129708:     the recursive make backend. The only reason this exists is to support the
129708:     existing recursive make backend while the transition to mozbuild frontend
129708:     files is complete and we move to a more optimal build backend.
129708: 
129708:     Fields in this class correspond to similarly named variables in the
129708:     frontend files.
129708:     """
129708:     __slots__ = (
129708:         'dirs',
129708:         'parallel_dirs',
129708:         'tool_dirs',
129708:         'test_dirs',
129708:         'test_tool_dirs',
129708:         'tier_dirs',
129708:         'tier_static_dirs',
130926:         'external_make_dirs',
130926:         'parallel_external_make_dirs',
129708:     )
129708: 
129708:     def __init__(self, sandbox):
129708:         SandboxDerived.__init__(self, sandbox)
129708: 
129708:         self.dirs = []
129708:         self.parallel_dirs = []
129708:         self.tool_dirs = []
129708:         self.test_dirs = []
129708:         self.test_tool_dirs = []
129708:         self.tier_dirs = OrderedDict()
129708:         self.tier_static_dirs = OrderedDict()
130926:         self.external_make_dirs = []
130926:         self.parallel_external_make_dirs = []
130928: 
130928: 
168104: class BaseConfigSubstitution(SandboxDerived):
168104:     """Base class describing autogenerated files as part of config.status."""
130928: 
130928:     __slots__ = (
130928:         'input_path',
130928:         'output_path',
134431:         'relpath',
130928:     )
130928: 
130928:     def __init__(self, sandbox):
130928:         SandboxDerived.__init__(self, sandbox)
130928: 
130928:         self.input_path = None
130928:         self.output_path = None
134431:         self.relpath = None
130928: 
135313: 
168104: class ConfigFileSubstitution(BaseConfigSubstitution):
168104:     """Describes a config file that will be generated using substitutions."""
168104: 
168104: 
168104: class HeaderFileSubstitution(BaseConfigSubstitution):
168104:     """Describes a header file that will be generated using substitutions."""
168104: 
168104: 
135313: class VariablePassthru(SandboxDerived):
135313:     """A dict of variables to pass through to backend.mk unaltered.
135313: 
135313:     The purpose of this object is to facilitate rapid transitioning of
135313:     variables from Makefile.in to moz.build. In the ideal world, this class
135313:     does not exist and every variable has a richer class representing it.
135313:     As long as we rely on this class, we lose the ability to have flexibility
135313:     in our build backends since we will continue to be tied to our rules.mk.
135313:     """
135313:     __slots__ = ('variables')
135313: 
135313:     def __init__(self, sandbox):
135313:         SandboxDerived.__init__(self, sandbox)
135313:         self.variables = {}
135313: 
156517: class XPIDLFile(SandboxDerived):
156517:     """Describes an XPIDL file to be compiled."""
156517: 
156517:     __slots__ = (
156517:         'basename',
156517:         'source_path',
156517:     )
156517: 
156517:     def __init__(self, sandbox, source, module):
156517:         SandboxDerived.__init__(self, sandbox)
156517: 
156517:         self.source_path = source
156517:         self.basename = os.path.basename(source)
156517:         self.module = module
156517: 
162726: class Defines(SandboxDerived):
162726:     """Sandbox container object for DEFINES, which is an OrderedDict.
162726:     """
162726:     __slots__ = ('defines')
162726: 
162726:     def __init__(self, sandbox, defines):
162726:         SandboxDerived.__init__(self, sandbox)
162726:         self.defines = defines
162726: 
162726:     def get_defines(self):
162726:         for define, value in self.defines.iteritems():
162726:             if value is True:
162726:                 defstr = define
162726:             else:
173524:                 defstr = '%s=%s' % (define, shell_quote(value))
162726:             yield('-D%s' % defstr)
156517: 
139977: class Exports(SandboxDerived):
139977:     """Sandbox container object for EXPORTS, which is a HierarchicalStringList.
139977: 
139977:     We need an object derived from SandboxDerived for use in the backend, so
139977:     this object fills that role. It just has a reference to the underlying
139977:     HierarchicalStringList, which is created when parsing EXPORTS.
139977:     """
159381:     __slots__ = ('exports', 'dist_install')
139977: 
159381:     def __init__(self, sandbox, exports, dist_install=True):
139977:         SandboxDerived.__init__(self, sandbox)
139977:         self.exports = exports
159381:         self.dist_install = dist_install
159381: 
142045: 
150550: class IPDLFile(SandboxDerived):
150550:     """Describes an individual .ipdl source file."""
150550: 
150550:     __slots__ = (
150550:         'basename',
150550:     )
150550: 
150550:     def __init__(self, sandbox, path):
150550:         SandboxDerived.__init__(self, sandbox)
150550: 
150550:         self.basename = path
150550: 
160245: class WebIDLFile(SandboxDerived):
160245:     """Describes an individual .webidl source file."""
160245: 
160245:     __slots__ = (
160245:         'basename',
160245:     )
160245: 
160245:     def __init__(self, sandbox, path):
160245:         SandboxDerived.__init__(self, sandbox)
160245: 
160245:         self.basename = path
160245: 
160288: class GeneratedEventWebIDLFile(SandboxDerived):
160288:     """Describes an individual .webidl source file."""
160288: 
160288:     __slots__ = (
160288:         'basename',
160288:     )
160288: 
160288:     def __init__(self, sandbox, path):
160288:         SandboxDerived.__init__(self, sandbox)
160288: 
160288:         self.basename = path
160288: 
160245: class TestWebIDLFile(SandboxDerived):
160245:     """Describes an individual test-only .webidl source file."""
160245: 
160245:     __slots__ = (
160245:         'basename',
160245:     )
160245: 
160245:     def __init__(self, sandbox, path):
160245:         SandboxDerived.__init__(self, sandbox)
160245: 
160245:         self.basename = path
160245: 
163522: class PreprocessedTestWebIDLFile(SandboxDerived):
163522:     """Describes an individual test-only .webidl source file that requires
163522:     preprocessing."""
163522: 
163522:     __slots__ = (
163522:         'basename',
163522:     )
163522: 
163522:     def __init__(self, sandbox, path):
163522:         SandboxDerived.__init__(self, sandbox)
163522: 
163522:         self.basename = path
163522: 
160245: class PreprocessedWebIDLFile(SandboxDerived):
160245:     """Describes an individual .webidl source file that requires preprocessing."""
160245: 
160245:     __slots__ = (
160245:         'basename',
160245:     )
160245: 
160245:     def __init__(self, sandbox, path):
160245:         SandboxDerived.__init__(self, sandbox)
160245: 
160245:         self.basename = path
160245: 
160245: class GeneratedWebIDLFile(SandboxDerived):
160245:     """Describes an individual .webidl source file that is generated from
160245:     build rules."""
160245: 
160245:     __slots__ = (
160245:         'basename',
160245:     )
160245: 
160245:     def __init__(self, sandbox, path):
160245:         SandboxDerived.__init__(self, sandbox)
160245: 
160245:         self.basename = path
160245: 
168743: class BaseProgram(SandboxDerived):
168743:     """Sandbox container object for programs, which is a unicode string.
143209: 
168743:     This class handles automatically appending a binary suffix to the program
168743:     name.
168743:     If the suffix is not defined, the program name is unchanged.
168743:     Otherwise, if the program name ends with the given suffix, it is unchanged
168743:     Otherwise, the suffix is appended to the program name.
143209:     """
143209:     __slots__ = ('program')
143209: 
143209:     def __init__(self, sandbox, program, bin_suffix):
143209:         SandboxDerived.__init__(self, sandbox)
143209: 
143209:         bin_suffix = bin_suffix or ''
143209:         if not program.endswith(bin_suffix):
143209:             program += bin_suffix
143209:         self.program = program
143209: 
142045: 
168743: class Program(BaseProgram):
168743:     """Sandbox container object for PROGRAM"""
168743: 
168743: 
168744: class HostProgram(BaseProgram):
168744:     """Sandbox container object for HOST_PROGRAM"""
168744: 
168744: 
168743: class SimpleProgram(BaseProgram):
168743:     """Sandbox container object for each program in SIMPLE_PROGRAMS"""
168743: 
168743: 
168744: class HostSimpleProgram(BaseProgram):
168744:     """Sandbox container object for each program in HOST_SIMPLE_PROGRAMS"""
168744: 
168744: 
171741: class LibraryDefinition(SandboxDerived):
171741:     """Partial definition for a library
171741: 
171741:     The static_libraries member tracks the list of relative directory and
171741:     library names of static libraries that are meant to be linked into
171741:     the library defined by an instance of this class.
171741:     """
171741:     __slots__ = (
171741:         'basename',
171741:         'static_libraries',
171754:         'refcount',
171741:     )
171741: 
171741:     def __init__(self, sandbox, basename):
171741:         SandboxDerived.__init__(self, sandbox)
171741: 
171741:         self.basename = basename
171754:         self.refcount = 0
171741:         self.static_libraries = []
171741: 
171789:     def link_static_lib(self, objdir, basename):
171789:         self.static_libraries.append((objdir, basename))
171741: 
171741: 
163244: class TestManifest(SandboxDerived):
163244:     """Represents a manifest file containing information about tests."""
142045: 
163244:     __slots__ = (
163244:         # The type of test manifest this is.
163244:         'flavor',
163244: 
163244:         # Maps source filename to destination filename. The destination
172472:         # path is relative from the tests root directory.
163244:         'installs',
163244: 
163244:         # Where all files for this manifest flavor are installed in the unified
163244:         # test package directory.
163244:         'install_prefix',
163244: 
163244:         # Set of files provided by an external mechanism.
163244:         'external_installs',
163244: 
163244:         # The full path of this manifest file.
163244:         'path',
163244: 
163244:         # The directory where this manifest is defined.
163244:         'directory',
163244: 
163244:         # The parsed manifestparser.TestManifest instance.
163244:         'manifest',
163244: 
166496:         # List of tests. Each element is a dict of metadata.
166496:         'tests',
166496: 
163244:         # The relative path of the parsed manifest within the srcdir.
163244:         'manifest_relpath',
163244: 
163244:         # If this manifest is a duplicate of another one, this is the
163244:         # manifestparser.TestManifest of the other one.
163244:         'dupe_manifest',
163244:     )
163244: 
163244:     def __init__(self, sandbox, path, manifest, flavor=None,
163244:             install_prefix=None, relpath=None, dupe_manifest=False):
142045:         SandboxDerived.__init__(self, sandbox)
163244: 
163244:         self.path = path
163244:         self.directory = os.path.dirname(path)
163244:         self.manifest = manifest
163244:         self.flavor = flavor
163244:         self.install_prefix = install_prefix
163244:         self.manifest_relpath = relpath
163244:         self.dupe_manifest = dupe_manifest
163244:         self.installs = {}
166496:         self.tests = []
163244:         self.external_installs = set()
163244: 
159584: 
159584: class LocalInclude(SandboxDerived):
159584:     """Describes an individual local include path."""
159584: 
159584:     __slots__ = (
159584:         'path',
159584:     )
159584: 
159584:     def __init__(self, sandbox, path):
159584:         SandboxDerived.__init__(self, sandbox)
159584: 
159584:         self.path = path
166365: 
166712: class GeneratedInclude(SandboxDerived):
166712:     """Describes an individual generated include path."""
166712: 
166712:     __slots__ = (
166712:         'path',
166712:     )
166712: 
166712:     def __init__(self, sandbox, path):
166712:         SandboxDerived.__init__(self, sandbox)
166712: 
166712:         self.path = path
166712: 
167037: 
167037: class SandboxWrapped(SandboxDerived):
167037:     """Generic sandbox container object for a wrapped rich object.
167037: 
167037:     Use this wrapper class to shuttle a rich build system object
167037:     completely defined in moz.build files through the tree metadata
167037:     emitter to the build backend for processing as-is.
167037:     """
167037: 
167037:     __slots__ = (
167037:         'wrapped',
167037:     )
167037: 
167037:     def __init__(self, sandbox, wrapped):
167037:         SandboxDerived.__init__(self, sandbox)
167037: 
167037:         self.wrapped = wrapped
167037: 
167037: 
167037: class JavaJarData(object):
167037:     """Represents a Java JAR file.
167037: 
167037:     A Java JAR has the following members:
170279:         * sources - strictly ordered list of input java sources
170279:         * generated_sources - strictly ordered list of generated input
170279:           java sources
167037:         * extra_jars - list of JAR file dependencies to include on the
167037:           javac compiler classpath
170279:         * javac_flags - list containing extra flags passed to the
167037:           javac compiler
167037:     """
167037: 
167037:     __slots__ = (
167037:         'name',
167037:         'sources',
167037:         'generated_sources',
167037:         'extra_jars',
167037:         'javac_flags',
167037:     )
167037: 
167037:     def __init__(self, name, sources=[], generated_sources=[],
170279:             extra_jars=[], javac_flags=[]):
167037:         self.name = name
170279:         self.sources = StrictOrderingOnAppendList(sources)
170279:         self.generated_sources = StrictOrderingOnAppendList(generated_sources)
167037:         self.extra_jars = list(extra_jars)
170279:         self.javac_flags = list(javac_flags)
167037: 
167037: 
166365: class InstallationTarget(SandboxDerived):
166365:     """Describes the rules that affect where files get installed to."""
166365: 
166365:     __slots__ = (
166365:         'xpiname',
166365:         'subdir',
166365:         'target',
166365:         'enabled'
166365:     )
166365: 
166365:     def __init__(self, sandbox):
166365:         SandboxDerived.__init__(self, sandbox)
166365: 
166365:         self.xpiname = sandbox.get('XPI_NAME', '')
166365:         self.subdir = sandbox.get('DIST_SUBDIR', '')
166365:         self.target = sandbox['FINAL_TARGET']
166365:         self.enabled = not sandbox.get('NO_DIST_INSTALL', False)
166365: 
166365:     def is_custom(self):
166365:         """Returns whether or not the target is not derived from the default
166365:         given xpiname and subdir."""
166365: 
175140:         return FinalTargetValue(dict(
166365:             XPI_NAME=self.xpiname,
166365:             DIST_SUBDIR=self.subdir)) == self.target
