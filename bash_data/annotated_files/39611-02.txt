35778: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35778:  * vim: sw=4 ts=4 et :
35778:  */
35778: /* ***** BEGIN LICENSE BLOCK *****
35778:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35778:  *
35778:  * The contents of this file are subject to the Mozilla Public License Version
35778:  * 1.1 (the "License"); you may not use this file except in compliance with
35778:  * the License. You may obtain a copy of the License at
35778:  * http://www.mozilla.org/MPL/
35778:  *
35778:  * Software distributed under the License is distributed on an "AS IS" basis,
35778:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35778:  * for the specific language governing rights and limitations under the
35778:  * License.
35778:  *
35778:  * The Original Code is Mozilla Plugin App.
35778:  *
35778:  * The Initial Developer of the Original Code is
35778:  *   Chris Jones <jones.chris.g@gmail.com>
35778:  * Portions created by the Initial Developer are Copyright (C) 2009
35778:  * the Initial Developer. All Rights Reserved.
35778:  *
35778:  * Contributor(s):
35778:  *
35778:  * Alternatively, the contents of this file may be used under the terms of
35778:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35778:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35778:  * in which case the provisions of the GPL or the LGPL are applicable instead
35778:  * of those above. If you wish to allow use of your version of this file only
35778:  * under the terms of either the GPL or the LGPL, and not to allow others to
35778:  * use your version of this file under the terms of the MPL, indicate your
35778:  * decision by deleting the provisions above and replace them with the notice
35778:  * and other provisions required by the GPL or the LGPL. If you do not delete
35778:  * the provisions above, a recipient may use your version of this file under
35778:  * the terms of any one of the MPL, the GPL or the LGPL.
35778:  *
35778:  * ***** END LICENSE BLOCK ***** */
35778: 
35778: #ifndef ipc_glue_AsyncChannel_h
35778: #define ipc_glue_AsyncChannel_h 1
35778: 
35778: #include "base/basictypes.h"
35778: #include "base/message_loop.h"
35778: #include "chrome/common/ipc_channel.h"
35778: 
35882: #include "mozilla/CondVar.h"
35882: #include "mozilla/Mutex.h"
35882: 
35786: 
35786: //-----------------------------------------------------------------------------
36018: 
36018: namespace mozilla {
36018: namespace ipc {
36018: 
36018: struct HasResultCodes
36018: {
35786:     enum Result {
35786:         MsgProcessed,
35786:         MsgNotKnown,
35786:         MsgNotAllowed,
35786:         MsgPayloadError,
35786:         MsgRouteError,
35786:         MsgValueError,
35786:     };
36018: };
35786: 
36018: class AsyncChannel : public IPC::Channel::Listener, protected HasResultCodes
35778: {
35778: protected:
35882:     typedef mozilla::CondVar CondVar;
35882:     typedef mozilla::Mutex Mutex;
35882: 
35778:     enum ChannelState {
35778:         ChannelClosed,
35778:         ChannelOpening,
35859:         ChannelConnected,
38106:         ChannelTimeout,
36140:         ChannelClosing,
35778:         ChannelError
35778:     };
35778: 
35778: public:
35778:     typedef IPC::Channel Transport;
35778:     typedef IPC::Message Message;
35778: 
36018:     class /*NS_INTERFACE_CLASS*/ AsyncListener: protected HasResultCodes
35778:     {
35778:     public:
35787:         virtual ~AsyncListener() { }
36140: 
36140:         virtual void OnChannelClose() = 0;
36140:         virtual void OnChannelError() = 0;
35778:         virtual Result OnMessageReceived(const Message& aMessage) = 0;
35778:     };
35778: 
36018: public:
36140:     //
36140:     // These methods are called on the "worker" thread
36140:     //
36078:     AsyncChannel(AsyncListener* aListener);
36078:     virtual ~AsyncChannel();
35778: 
37201:     // "Open" from the perspective of the transport layer; the underlying
35882:     // socketpair/pipe should already be created.
35882:     //
35882:     // Returns true iff the transport layer was successfully connected,
35882:     // i.e., mChannelState == ChannelConnected.
35778:     bool Open(Transport* aTransport, MessageLoop* aIOLoop=0);
35778:     
36039:     // Close the underlying transport channel.
35778:     void Close();
35778: 
35778:     // Asynchronously send a message to the other side of the channel
38681:     virtual bool Send(Message* msg);
35778: 
36140:     //
36140:     // These methods are called on the "IO" thread
36140:     //
36140: 
35778:     // Implement the IPC::Channel::Listener interface
35940:     NS_OVERRIDE virtual void OnMessageReceived(const Message& msg);
35940:     NS_OVERRIDE virtual void OnChannelConnected(int32 peer_pid);
35940:     NS_OVERRIDE virtual void OnChannelError();
35778: 
35778: protected:
35971:     // Can be run on either thread
35971:     void AssertWorkerThread()
35971:     {
35977:         NS_ABORT_IF_FALSE(mWorkerLoop == MessageLoop::current(),
35977:                           "not on worker thread!");
35971:     }
35971: 
35971:     void AssertIOThread()
35971:     {
35977:         NS_ABORT_IF_FALSE(mIOLoop == MessageLoop::current(),
35977:                           "not on IO thread!");
35971:     }
35971: 
35940:     bool Connected() {
35977:         mMutex.AssertCurrentThreadOwns();
35940:         return ChannelConnected == mChannelState;
35940:     }
35940: 
35977:     // Run on the worker thread
35778:     void OnDispatchMessage(const Message& aMsg);
38099:     virtual bool OnSpecialMessage(uint16 id, const Message& msg);
38099:     void SendSpecialMessage(Message* msg);
38099: 
38106:     // Tell the IO thread to close the channel and wait for it to ACK.
38106:     void SynchronouslyClose();
38106: 
36015:     bool MaybeHandleError(Result code, const char* channelName);
36015:     void ReportConnectionError(const char* channelName);
36015: 
36015:     void PrintErrorMessage(const char* channelName, const char* msg)
36015:     {
36015:         fprintf(stderr, "\n###!!! [%s][%s] Error: %s\n\n",
36015:                 mChild ? "Child" : "Parent", channelName, msg);
36015:     }
35778: 
36140:     // Run on the worker thread
36140: 
39311:     void OnNotifyMaybeChannelError();
39311:     virtual bool ShouldDeferNotifyMaybeError() {
39311:         return false;
39311:     }
36140:     void NotifyChannelClosed();
36140:     void NotifyMaybeChannelError();
36140: 
39255:     virtual void Clear();
36140: 
35977:     // Run on the IO thread
36140: 
35778:     void OnChannelOpened();
35778:     void OnSend(Message* aMsg);
36140:     void OnCloseChannel();
39611:     void PostErrorNotifyTask();
35778: 
39261:     // Return true if |msg| is a special message targeted at the IO
39261:     // thread, in which case it shouldn't be delivered to the worker.
39261:     bool MaybeInterceptSpecialIOMessage(const Message& msg);
39261:     void ProcessGoodbyeMessage();
39261: 
35778:     Transport* mTransport;
35799:     AsyncListener* mListener;
35778:     ChannelState mChannelState;
35882:     Mutex mMutex;
35882:     CondVar mCvar;
35778:     MessageLoop* mIOLoop;       // thread where IO happens
35778:     MessageLoop* mWorkerLoop;   // thread where work is done
35974:     bool mChild;                // am I the child or parent?
36607:     CancelableTask* mChannelErrorTask; // NotifyMaybeChannelError runnable
35778: };
35778: 
35778: 
35778: } // namespace ipc
35778: } // namespace mozilla
35778: #endif  // ifndef ipc_glue_AsyncChannel_h
