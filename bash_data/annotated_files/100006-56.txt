 89745: /* -*- Mode: C++; tab-width: 6; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 78065:  * vim: set ts=8 sw=4 et tw=78:
 78065:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 78065: 
 86483: #include "jscompartment.h"
 86483: #include "jsiter.h"
 86483: #include "jsscope.h"
 86483: 
 86483: #include "GlobalObject.h"
 86483: #include "ScopeObject.h"
 94006: #include "Xdr.h"
 86483: 
 86483: #include "jsatominlines.h"
 78065: #include "jsobjinlines.h"
 78065: 
 86483: #include "ScopeObject-inl.h"
 78065: 
 86483: using namespace js;
 86483: using namespace js::types;
 78065: 
 98921: /*****************************************************************************/
 98921: 
100006: void
100006: js_PutCallObject(StackFrame *fp, CallObject &callobj)
 99993: {
100006:     JS_ASSERT(callobj.maybeStackFrame() == fp);
100006:     JS_ASSERT_IF(fp->isEvalFrame(), fp->isStrictEvalFrame());
100006:     JS_ASSERT(fp->isEvalFrame() == callobj.isForEval());
 99993: 
100006:     JSScript *script = fp->script();
100006:     Bindings &bindings = script->bindings;
 99993: 
100006:     if (callobj.isForEval()) {
100006:         JS_ASSERT(script->strictModeCode);
100006:         JS_ASSERT(bindings.numArgs() == 0);
100006: 
100006:         /* This could be optimized as below, but keep it simple for now. */
100006:         callobj.copyValues(0, NULL, bindings.numVars(), fp->slots());
100006:     } else {
100006:         JSFunction *fun = fp->fun();
100006:         JS_ASSERT(script == callobj.getCalleeFunction()->script());
100006:         JS_ASSERT(script == fun->script());
100006: 
100006:         unsigned n = bindings.count();
100006:         if (n > 0) {
100006:             uint32_t nvars = bindings.numVars();
100006:             uint32_t nargs = bindings.numArgs();
100006:             JS_ASSERT(fun->nargs == nargs);
100006:             JS_ASSERT(nvars + nargs == n);
100006: 
100006:             JSScript *script = fun->script();
100006:             if (script->bindingsAccessedDynamically
100006: #ifdef JS_METHODJIT
100006:                 || script->debugMode
100006: #endif
100006:                 ) {
100006:                 callobj.copyValues(nargs, fp->formalArgs(), nvars, fp->slots());
100006:             } else {
100006:                 /*
100006:                  * For each arg & var that is closed over, copy it from the stack
100006:                  * into the call object. We use initArg/VarUnchecked because,
100006:                  * when you call a getter on a call object, js_NativeGetInline
100006:                  * caches the return value in the slot, so we can't assert that
100006:                  * it's undefined.
100006:                  */
100006:                 uint32_t nclosed = script->numClosedArgs();
100006:                 for (uint32_t i = 0; i < nclosed; i++) {
100006:                     uint32_t e = script->getClosedArg(i);
100006: #ifdef JS_GC_ZEAL
100006:                     callobj.setArg(e, fp->formalArg(e));
100006: #else
100006:                     callobj.initArgUnchecked(e, fp->formalArg(e));
100006: #endif
 99993:                 }
 99993: 
100006:                 nclosed = script->numClosedVars();
100006:                 for (uint32_t i = 0; i < nclosed; i++) {
100006:                     uint32_t e = script->getClosedVar(i);
100006: #ifdef JS_GC_ZEAL
100006:                     callobj.setVar(e, fp->slots()[e]);
100006: #else
100006:                     callobj.initVarUnchecked(e, fp->slots()[e]);
100006: #endif
100006:                 }
 99993:             }
 99993: 
100006:             /*
100006:              * Update the args and vars for the active call if this is an outer
100006:              * function in a script nesting.
100006:              */
100006:             types::TypeScriptNesting *nesting = script->nesting();
100006:             if (nesting && script->isOuterFunction) {
100006:                 nesting->argArray = callobj.argArray();
100006:                 nesting->varArray = callobj.varArray();
100006:             }
100006:         }
100006: 
100006:         /* Clear private pointers to fp, which is about to go away. */
100006:         if (js_IsNamedLambda(fun)) {
100006:             JSObject &env = callobj.enclosingScope();
100006:             JS_ASSERT(env.asDeclEnv().maybeStackFrame() == fp);
100006:             env.setPrivate(NULL);
100006:         }
100006:     }
100006: 
100006:     callobj.setStackFrame(NULL);
100006: }
 99993: 
 78065: /*
 78065:  * Construct a call object for the given bindings.  If this is a call object
 78065:  * for a function invocation, callee should be the function being called.
 78065:  * Otherwise it must be a call object for eval of strict mode code, and callee
 78065:  * must be null.
 78065:  */
 78065: CallObject *
100006: CallObject::create(JSContext *cx, JSScript *script, HandleObject enclosing, HandleObject callee)
 78065: {
 99421:     RootedShape shape(cx);
 89745:     shape = script->bindings.callObjectShape(cx);
 89745:     if (shape == NULL)
 89745:         return NULL;
 89745: 
100006:     gc::AllocKind kind = gc::GetGCObjectKind(shape->numFixedSlots() + 1);
 78065: 
 99421:     RootedTypeObject type(cx);
 86437:     type = cx->compartment->getEmptyType(cx);
 83275:     if (!type)
 83275:         return NULL;
 83275: 
 91146:     HeapSlot *slots;
 89745:     if (!PreallocateObjectDynamicSlots(cx, shape, &slots))
 83275:         return NULL;
 78065: 
 99421:     RootedObject obj(cx, JSObject::create(cx, kind, shape, type, slots));
 78065:     if (!obj)
 78065:         return NULL;
 78065: 
 83275:     /*
 83275:      * Update the parent for bindings associated with non-compileAndGo scripts,
 83275:      * whose call objects do not have a consistent global variable and need
 83275:      * to be updated dynamically.
 83275:      */
 97353:     if (&enclosing->global() != obj->getParent()) {
 83287:         JS_ASSERT(obj->getParent() == NULL);
 99421:         if (!JSObject::setParent(cx, obj, RootedObject(cx, &enclosing->global())))
 78065:             return NULL;
 83275:     }
 78065: 
100006: #ifdef DEBUG
100006:     JS_ASSERT(!obj->inDictionaryMode());
100006:     for (Shape::Range r = obj->lastProperty(); !r.empty(); r.popFront()) {
100006:         const Shape &s = r.front();
100006:         if (s.hasSlot()) {
100006:             JS_ASSERT(s.slot() + 1 == obj->slotSpan());
100006:             break;
100006:         }
100006:     }
100006: #endif
100006: 
 86483:     if (!obj->asScope().setEnclosingScope(cx, enclosing))
 86483:         return NULL;
 83275: 
100006:     JS_ASSERT_IF(callee, callee->isFunction());
 86483:     obj->initFixedSlot(CALLEE_SLOT, ObjectOrNullValue(callee));
 83275: 
 83275:     /*
 83275:      * If |bindings| is for a function that has extensible parents, that means
 86483:      * its Call should have its own shape; see BaseShape::extensibleParents.
 83275:      */
 95355:     if (obj->lastProperty()->extensibleParents()) {
 95355:         if (!obj->generateOwnShape(cx))
 83275:             return NULL;
 95355:     }
 83275: 
 86483:     return &obj->asCall();
 78065: }
 78065: 
 91175: CallObject *
 91175: CallObject::createForFunction(JSContext *cx, StackFrame *fp)
 91175: {
 91175:     JS_ASSERT(fp->isNonEvalFunctionFrame());
100006:     JS_ASSERT(!fp->hasCallObj());
 91175: 
 99421:     RootedObject scopeChain(cx, fp->scopeChain());
 91175: 
 91175:     /*
 91175:      * For a named function expression Call's parent points to an environment
 91175:      * object holding function's name.
 91175:      */
 98921:     if (js_IsNamedLambda(fp->fun())) {
 91175:         scopeChain = DeclEnvObject::create(cx, fp);
 91175:         if (!scopeChain)
 91175:             return NULL;
 91175:     }
 91175: 
100006:     CallObject *callobj = create(cx, fp->script(), scopeChain, RootedObject(cx, &fp->callee()));
 91175:     if (!callobj)
 91175:         return NULL;
 91175: 
100006:     callobj->setStackFrame(fp);
 91175:     return callobj;
 91175: }
 91175: 
 91175: CallObject *
 91175: CallObject::createForStrictEval(JSContext *cx, StackFrame *fp)
 91175: {
100006:     CallObject *callobj = create(cx, fp->script(), fp->scopeChain(), RootedObject(cx));
100006:     if (!callobj)
100006:         return NULL;
 91175: 
100006:     callobj->setStackFrame(fp);
100006:     fp->initScopeChain(*callobj);
100006:     return callobj;
100006: }
100006: 
100006: JSBool
100006: CallObject::getArgOp(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
100006: {
100006:     CallObject &callobj = obj->asCall();
100006: 
100006:     JS_ASSERT((int16_t) JSID_TO_INT(id) == JSID_TO_INT(id));
100006:     unsigned i = (uint16_t) JSID_TO_INT(id);
100006: 
100006:     DebugOnly<JSScript *> script = callobj.getCalleeFunction()->script();
100006:     JS_ASSERT_IF(!cx->okToAccessUnaliasedBindings, script->formalLivesInCallObject(i));
100006: 
100006:     if (StackFrame *fp = callobj.maybeStackFrame())
100006:         *vp = fp->formalArg(i);
100006:     else
100006:         *vp = callobj.arg(i);
100006:     return true;
 91175: }
 91175: 
 91175: JSBool
 98960: CallObject::setArgOp(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp)
 91175: {
 91175:     CallObject &callobj = obj->asCall();
 95099: 
 91175:     JS_ASSERT((int16_t) JSID_TO_INT(id) == JSID_TO_INT(id));
 91237:     unsigned i = (uint16_t) JSID_TO_INT(id);
 91175: 
 95099:     JSScript *script = callobj.getCalleeFunction()->script();
100006:     JS_ASSERT_IF(!cx->okToAccessUnaliasedBindings, script->formalLivesInCallObject(i));
 95099: 
100006:     if (StackFrame *fp = callobj.maybeStackFrame())
100006:         fp->formalArg(i) = *vp;
100006:     else
 91175:         callobj.setArg(i, *vp);
 91175: 
 91175:     if (!script->ensureHasTypes(cx))
 91175:         return false;
 91175: 
 91175:     TypeScript::SetArgument(cx, script, i, *vp);
100006: 
100006:     return true;
100006: }
100006: 
100006: JSBool
100006: CallObject::getVarOp(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
100006: {
100006:     CallObject &callobj = obj->asCall();
100006: 
100006:     JS_ASSERT((int16_t) JSID_TO_INT(id) == JSID_TO_INT(id));
100006:     unsigned i = (uint16_t) JSID_TO_INT(id);
100006: 
100006:     DebugOnly<JSScript *> script = callobj.getCalleeFunction()->script();
100006:     JS_ASSERT_IF(!cx->okToAccessUnaliasedBindings, script->varIsAliased(i));
100006: 
100006:     if (StackFrame *fp = callobj.maybeStackFrame())
100006:         *vp = fp->varSlot(i);
100006:     else
100006:         *vp = callobj.var(i);
100006: 
100006:     JS_ASSERT(!vp->isMagic(JS_OPTIMIZED_ARGUMENTS));
 91175:     return true;
 91175: }
 91175: 
 91175: JSBool
 98960: CallObject::setVarOp(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp)
 91175: {
 91175:     CallObject &callobj = obj->asCall();
 91175: 
 91175:     JS_ASSERT((int16_t) JSID_TO_INT(id) == JSID_TO_INT(id));
 91237:     unsigned i = (uint16_t) JSID_TO_INT(id);
 91175: 
 95099:     JSScript *script = callobj.getCalleeFunction()->script();
100006:     JS_ASSERT_IF(!cx->okToAccessUnaliasedBindings, script->varIsAliased(i));
 95099: 
100006:     if (StackFrame *fp = callobj.maybeStackFrame())
100006:         fp->varSlot(i) = *vp;
100006:     else
 91175:         callobj.setVar(i, *vp);
 91175: 
 91175:     if (!script->ensureHasTypes(cx))
 91175:         return false;
 91175: 
 91175:     TypeScript::SetLocal(cx, script, i, *vp);
 91175:     return true;
 91175: }
 91175: 
100006: bool
100006: CallObject::containsVarOrArg(PropertyName *name, Value *vp, JSContext *cx)
100006: {
100006:     jsid id = NameToId(name);
100006:     const Shape *shape = nativeLookup(cx, id);
100006:     if (!shape)
100006:         return false;
100006: 
100006:     PropertyOp op = shape->getterOp();
100006:     if (op != getVarOp && op != getArgOp)
100006:         return false;
100006: 
100006:     JS_ALWAYS_TRUE(op(cx, RootedObject(cx, this), RootedId(cx, INT_TO_JSID(shape->shortid())), vp));
100006:     return true;
100006: }
100006: 
100006: static void
100006: call_trace(JSTracer *trc, JSObject *obj)
100006: {
100006:     JS_ASSERT(obj->isCall());
100006: 
100006:     /* Mark any generator frame, as for arguments objects. */
100006: #if JS_HAS_GENERATORS
100006:     StackFrame *fp = (StackFrame *) obj->getPrivate();
100006:     if (fp && fp->isFloatingGenerator())
100006:         MarkObject(trc, &js_FloatingFrameToGenerator(fp)->obj, "generator object");
100006: #endif
100006: }
100006: 
 91175: JS_PUBLIC_DATA(Class) js::CallClass = {
 91175:     "Call",
100006:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS | JSCLASS_IS_ANONYMOUS |
100006:     JSCLASS_HAS_RESERVED_SLOTS(CallObject::RESERVED_SLOTS),
 91175:     JS_PropertyStub,         /* addProperty */
 91175:     JS_PropertyStub,         /* delProperty */
 91175:     JS_PropertyStub,         /* getProperty */
 91175:     JS_StrictPropertyStub,   /* setProperty */
 91175:     JS_EnumerateStub,
 95100:     JS_ResolveStub,
100006:     NULL,                    /* convert: Leave it NULL so we notice if calls ever escape */
100006:     NULL,                    /* finalize */
100006:     NULL,                    /* checkAccess */
100006:     NULL,                    /* call        */
100006:     NULL,                    /* construct   */
100006:     NULL,                    /* hasInstance */
100006:     call_trace
 91175: };
 91175: 
 86483: Class js::DeclEnvClass = {
 86483:     js_Object_str,
 86483:     JSCLASS_HAS_PRIVATE |
 86483:     JSCLASS_HAS_RESERVED_SLOTS(DeclEnvObject::RESERVED_SLOTS) |
 86483:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
 86483:     JS_PropertyStub,         /* addProperty */
 86483:     JS_PropertyStub,         /* delProperty */
 86483:     JS_PropertyStub,         /* getProperty */
 86483:     JS_StrictPropertyStub,   /* setProperty */
 86483:     JS_EnumerateStub,
 86483:     JS_ResolveStub,
 86483:     JS_ConvertStub
 86483: };
 86483: 
 86483: DeclEnvObject *
 86483: DeclEnvObject::create(JSContext *cx, StackFrame *fp)
 86483: {
 99421:     RootedTypeObject type(cx);
 86483:     type = cx->compartment->getEmptyType(cx);
 86483:     if (!type)
 86483:         return NULL;
 86483: 
 99421:     RootedShape emptyDeclEnvShape(cx);
 86483:     emptyDeclEnvShape = EmptyShape::getInitialShape(cx, &DeclEnvClass, NULL,
 96793:                                                     &fp->global(), FINALIZE_KIND);
 86483:     if (!emptyDeclEnvShape)
 86483:         return NULL;
 86483: 
 99421:     RootedObject obj(cx, JSObject::create(cx, FINALIZE_KIND, emptyDeclEnvShape, type, NULL));
 86483:     if (!obj)
 86483:         return NULL;
 86483: 
100006:     obj->setPrivate(fp);
 96793:     if (!obj->asScope().setEnclosingScope(cx, fp->scopeChain()))
 86483:         return NULL;
 86483: 
 98921: 
 99421:     if (!DefineNativeProperty(cx, obj, RootedId(cx, AtomToId(fp->fun()->atom)),
 98921:                               ObjectValue(fp->callee()), NULL, NULL,
 98921:                               JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY,
 98921:                               0, 0)) {
 98921:         return NULL;
 98921:     }
 98921: 
 86483:     return &obj->asDeclEnv();
 78065: }
 86483: 
 86483: WithObject *
 98921: WithObject::create(JSContext *cx, HandleObject proto, HandleObject enclosing, uint32_t depth)
 86483: {
 99421:     RootedTypeObject type(cx);
 95355:     type = proto->getNewType(cx);
 86483:     if (!type)
 86483:         return NULL;
 86483: 
 99421:     RootedShape emptyWithShape(cx);
 95355:     emptyWithShape = EmptyShape::getInitialShape(cx, &WithClass, proto,
 95355:                                                  &enclosing->global(), FINALIZE_KIND);
 86483:     if (!emptyWithShape)
 86483:         return NULL;
 86483: 
 99421:     RootedObject obj(cx, JSObject::create(cx, FINALIZE_KIND, emptyWithShape, type, NULL));
 86483:     if (!obj)
 86483:         return NULL;
 86483: 
 86483:     if (!obj->asScope().setEnclosingScope(cx, enclosing))
 86483:         return NULL;
 86483: 
 86483:     obj->setReservedSlot(DEPTH_SLOT, PrivateUint32Value(depth));
 86483: 
 95355:     JSObject *thisp = proto->thisObject(cx);
 86483:     if (!thisp)
 86483:         return NULL;
 86483: 
 86483:     obj->setFixedSlot(THIS_SLOT, ObjectValue(*thisp));
 86483: 
 86483:     return &obj->asWith();
 86483: }
 86483: 
 86483: static JSBool
 98960: with_LookupGeneric(JSContext *cx, HandleObject obj, HandleId id, JSObject **objp, JSProperty **propp)
 86483: {
 86483:     /* Fixes bug 463997 */
 91237:     unsigned flags = cx->resolveFlags;
 86483:     if (flags == RESOLVE_INFER)
 86483:         flags = js_InferFlags(cx, flags);
 86483:     flags |= JSRESOLVE_WITH;
 86483:     JSAutoResolveFlags rf(cx, flags);
 86483:     return obj->asWith().object().lookupGeneric(cx, id, objp, propp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_LookupProperty(JSContext *cx, HandleObject obj, HandlePropertyName name, JSObject **objp, JSProperty **propp)
 86483: {
 99421:     return with_LookupGeneric(cx, obj, RootedId(cx, NameToId(name)), objp, propp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_LookupElement(JSContext *cx, HandleObject obj, uint32_t index, JSObject **objp,
 86483:                    JSProperty **propp)
 86483: {
 99421:     RootedId id(cx);
 98960:     if (!IndexToId(cx, index, id.address()))
 86483:         return false;
 86483:     return with_LookupGeneric(cx, obj, id, objp, propp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_LookupSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid, JSObject **objp, JSProperty **propp)
 86483: {
 99421:     return with_LookupGeneric(cx, obj, RootedId(cx, SPECIALID_TO_JSID(sid)), objp, propp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetGeneric(JSContext *cx, HandleObject obj, HandleObject receiver, HandleId id, Value *vp)
 86483: {
 86483:     return obj->asWith().object().getGeneric(cx, id, vp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetProperty(JSContext *cx, HandleObject obj, HandleObject receiver, HandlePropertyName name, Value *vp)
 86483: {
 99421:     return with_GetGeneric(cx, obj, receiver, RootedId(cx, NameToId(name)), vp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetElement(JSContext *cx, HandleObject obj, HandleObject receiver, uint32_t index, Value *vp)
 86483: {
 99421:     RootedId id(cx);
 98960:     if (!IndexToId(cx, index, id.address()))
 86483:         return false;
 86483:     return with_GetGeneric(cx, obj, receiver, id, vp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetSpecial(JSContext *cx, HandleObject obj, HandleObject receiver, HandleSpecialId sid, Value *vp)
 86483: {
 99421:     return with_GetGeneric(cx, obj, receiver, RootedId(cx, SPECIALID_TO_JSID(sid)), vp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetGeneric(JSContext *cx, HandleObject obj, HandleId id, Value *vp, JSBool strict)
 86483: {
 86483:     return obj->asWith().object().setGeneric(cx, id, vp, strict);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetProperty(JSContext *cx, HandleObject obj, HandlePropertyName name, Value *vp, JSBool strict)
 86483: {
 86483:     return obj->asWith().object().setProperty(cx, name, vp, strict);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetElement(JSContext *cx, HandleObject obj, uint32_t index, Value *vp, JSBool strict)
 86483: {
 86483:     return obj->asWith().object().setElement(cx, index, vp, strict);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid, Value *vp, JSBool strict)
 86483: {
 86483:     return obj->asWith().object().setSpecial(cx, sid, vp, strict);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetGenericAttributes(JSContext *cx, HandleObject obj, HandleId id, unsigned *attrsp)
 86483: {
 86483:     return obj->asWith().object().getGenericAttributes(cx, id, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetPropertyAttributes(JSContext *cx, HandleObject obj, HandlePropertyName name, unsigned *attrsp)
 86483: {
 86483:     return obj->asWith().object().getPropertyAttributes(cx, name, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetElementAttributes(JSContext *cx, HandleObject obj, uint32_t index, unsigned *attrsp)
 86483: {
 86483:     return obj->asWith().object().getElementAttributes(cx, index, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetSpecialAttributes(JSContext *cx, HandleObject obj, HandleSpecialId sid, unsigned *attrsp)
 86483: {
 86483:     return obj->asWith().object().getSpecialAttributes(cx, sid, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetGenericAttributes(JSContext *cx, HandleObject obj, HandleId id, unsigned *attrsp)
 86483: {
 86483:     return obj->asWith().object().setGenericAttributes(cx, id, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetPropertyAttributes(JSContext *cx, HandleObject obj, HandlePropertyName name, unsigned *attrsp)
 86483: {
 86483:     return obj->asWith().object().setPropertyAttributes(cx, name, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetElementAttributes(JSContext *cx, HandleObject obj, uint32_t index, unsigned *attrsp)
 86483: {
 86483:     return obj->asWith().object().setElementAttributes(cx, index, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetSpecialAttributes(JSContext *cx, HandleObject obj, HandleSpecialId sid, unsigned *attrsp)
 86483: {
 86483:     return obj->asWith().object().setSpecialAttributes(cx, sid, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_DeleteProperty(JSContext *cx, HandleObject obj, HandlePropertyName name, Value *rval, JSBool strict)
 86483: {
 86483:     return obj->asWith().object().deleteProperty(cx, name, rval, strict);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_DeleteElement(JSContext *cx, HandleObject obj, uint32_t index, Value *rval, JSBool strict)
 86483: {
 86483:     return obj->asWith().object().deleteElement(cx, index, rval, strict);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_DeleteSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid, Value *rval, JSBool strict)
 86483: {
 86483:     return obj->asWith().object().deleteSpecial(cx, sid, rval, strict);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_Enumerate(JSContext *cx, HandleObject obj, JSIterateOp enum_op,
 86483:                Value *statep, jsid *idp)
 86483: {
 86483:     return obj->asWith().object().enumerate(cx, enum_op, statep, idp);
 86483: }
 86483: 
 86483: static JSType
 98960: with_TypeOf(JSContext *cx, HandleObject obj)
 86483: {
 86483:     return JSTYPE_OBJECT;
 86483: }
 86483: 
 86483: static JSObject *
 98960: with_ThisObject(JSContext *cx, HandleObject obj)
 86483: {
 86483:     return &obj->asWith().withThis();
 86483: }
 86483: 
 86483: Class js::WithClass = {
 86483:     "With",
 86483:     JSCLASS_HAS_RESERVED_SLOTS(WithObject::RESERVED_SLOTS) |
 86483:     JSCLASS_IS_ANONYMOUS,
 86483:     JS_PropertyStub,         /* addProperty */
 86483:     JS_PropertyStub,         /* delProperty */
 86483:     JS_PropertyStub,         /* getProperty */
 86483:     JS_StrictPropertyStub,   /* setProperty */
 86483:     JS_EnumerateStub,
 86483:     JS_ResolveStub,
 86483:     JS_ConvertStub,
 86483:     NULL,                    /* finalize */
 86483:     NULL,                    /* checkAccess */
 86483:     NULL,                    /* call        */
 86483:     NULL,                    /* construct   */
 86483:     NULL,                    /* hasInstance */
 86483:     NULL,                    /* trace       */
 86483:     JS_NULL_CLASS_EXT,
 86483:     {
 86483:         with_LookupGeneric,
 86483:         with_LookupProperty,
 86483:         with_LookupElement,
 86483:         with_LookupSpecial,
 86483:         NULL,             /* defineGeneric */
 86483:         NULL,             /* defineProperty */
 86483:         NULL,             /* defineElement */
 86483:         NULL,             /* defineSpecial */
 86483:         with_GetGeneric,
 86483:         with_GetProperty,
 86483:         with_GetElement,
 86483:         NULL,             /* getElementIfPresent */
 86483:         with_GetSpecial,
 86483:         with_SetGeneric,
 86483:         with_SetProperty,
 86483:         with_SetElement,
 86483:         with_SetSpecial,
 86483:         with_GetGenericAttributes,
 86483:         with_GetPropertyAttributes,
 86483:         with_GetElementAttributes,
 86483:         with_GetSpecialAttributes,
 86483:         with_SetGenericAttributes,
 86483:         with_SetPropertyAttributes,
 86483:         with_SetElementAttributes,
 86483:         with_SetSpecialAttributes,
 86483:         with_DeleteProperty,
 86483:         with_DeleteElement,
 86483:         with_DeleteSpecial,
 86483:         with_Enumerate,
 86483:         with_TypeOf,
 86483:         with_ThisObject,
 86483:         NULL,             /* clear */
 86483:     }
 86483: };
 86483: 
 98921: /*****************************************************************************/
 98921: 
 86483: ClonedBlockObject *
 97353: ClonedBlockObject::create(JSContext *cx, Handle<StaticBlockObject *> block, StackFrame *fp)
 86483: {
 99421:     RootedTypeObject type(cx);
 97353:     type = block->getNewType(cx);
 86483:     if (!type)
 86483:         return NULL;
 86483: 
 91146:     HeapSlot *slots;
 97353:     if (!PreallocateObjectDynamicSlots(cx, block->lastProperty(), &slots))
 86483:         return NULL;
 86483: 
 99421:     RootedShape shape(cx);
 97353:     shape = block->lastProperty();
 86483: 
 99421:     RootedObject obj(cx, JSObject::create(cx, FINALIZE_KIND, shape, type, slots));
 86483:     if (!obj)
 86483:         return NULL;
 86483: 
 86483:     /* Set the parent if necessary, as for call objects. */
 97353:     if (&fp->global() != obj->getParent()) {
 86483:         JS_ASSERT(obj->getParent() == NULL);
 99421:         if (!JSObject::setParent(cx, obj, RootedObject(cx, &fp->global())))
 86483:             return NULL;
 86483:     }
 86483: 
 86483:     JS_ASSERT(!obj->inDictionaryMode());
 97353:     JS_ASSERT(obj->slotSpan() >= block->slotCount() + RESERVED_SLOTS);
 86483: 
 98921:     obj->setReservedSlot(SCOPE_CHAIN_SLOT, ObjectValue(*fp->scopeChain()));
 97353:     obj->setReservedSlot(DEPTH_SLOT, PrivateUint32Value(block->stackDepth()));
100006:     obj->setPrivate(js_FloatingFrameIfGenerator(cx, fp));
 86483: 
 86483:     if (obj->lastProperty()->extensibleParents() && !obj->generateOwnShape(cx))
 86483:         return NULL;
 86483: 
 99994:     return &obj->asClonedBlock();
 86483: }
 86483: 
 99991: void
100006: ClonedBlockObject::put(StackFrame *fp)
 99991: {
100006:     uint32_t count = slotCount();
100006:     uint32_t depth = stackDepth();
100006: 
100006:     /* See comments in CheckDestructuring in frontend/Parser.cpp. */
100006:     JS_ASSERT(count >= 1);
100006: 
100006:     copySlotRange(RESERVED_SLOTS, fp->base() + depth, count);
100006: 
100006:     /* We must clear the private slot even with errors. */
100006:     setPrivate(NULL);
 99991: }
100006: 
100006: static JSBool
100006: block_getProperty(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
100006: {
100006:     /*
100006:      * Block objects are never exposed to script, and the engine handles them
100006:      * with care. So unlike other getters, this one can assert (rather than
100006:      * check) certain invariants about obj.
100006:      */
100006:     ClonedBlockObject &block = obj->asClonedBlock();
100006:     unsigned index = (unsigned) JSID_TO_INT(id);
100006: 
100006:     JS_ASSERT_IF(!block.compartment()->debugMode(), block.staticBlock().isAliased(index));
100006: 
100006:     if (StackFrame *fp = block.maybeStackFrame()) {
100006:         fp = js_LiveFrameIfGenerator(fp);
100006:         index += fp->numFixed() + block.stackDepth();
100006:         JS_ASSERT(index < fp->numSlots());
100006:         *vp = fp->slots()[index];
100006:         return true;
100006:     }
100006: 
100006:     /* Values are in slots immediately following the class-reserved ones. */
100006:     JS_ASSERT(block.closedSlot(index) == *vp);
100006:     return true;
100006: }
100006: 
100006: static JSBool
100006: block_setProperty(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp)
100006: {
100006:     ClonedBlockObject &block = obj->asClonedBlock();
100006:     unsigned index = (unsigned) JSID_TO_INT(id);
100006: 
100006:     JS_ASSERT_IF(!block.compartment()->debugMode(), block.staticBlock().isAliased(index));
100006: 
100006:     if (StackFrame *fp = block.maybeStackFrame()) {
100006:         fp = js_LiveFrameIfGenerator(fp);
100006:         index += fp->numFixed() + block.stackDepth();
100006:         JS_ASSERT(index < fp->numSlots());
100006:         fp->slots()[index] = *vp;
100006:         return true;
100006:     }
100006: 
100006:     /*
100006:      * The value in *vp will be written back to the slot in obj that was
100006:      * allocated when this let binding was defined.
100006:      */
100006:     return true;
100006: }
100006: 
100006: bool
100006: ClonedBlockObject::containsVar(PropertyName *name, Value *vp, JSContext *cx)
100006: {
100006:     RootedObject self(cx, this);
100006: 
100006:     const Shape *shape = nativeLookup(cx, NameToId(name));
100006:     if (!shape)
100006:         return false;
100006: 
100006:     JS_ASSERT(shape->getterOp() == block_getProperty);
100006:     JS_ALWAYS_TRUE(block_getProperty(cx, self, RootedId(cx, INT_TO_JSID(shape->shortid())), vp));
100006:     return true;
 99991: }
 99991: 
 86483: StaticBlockObject *
 86483: StaticBlockObject::create(JSContext *cx)
 86483: {
 99421:     RootedTypeObject type(cx);
 86483:     type = cx->compartment->getEmptyType(cx);
 86483:     if (!type)
 86483:         return NULL;
 86483: 
 99421:     RootedShape emptyBlockShape(cx);
 86483:     emptyBlockShape = EmptyShape::getInitialShape(cx, &BlockClass, NULL, NULL, FINALIZE_KIND);
 86483:     if (!emptyBlockShape)
 86483:         return NULL;
 86483: 
 86483:     JSObject *obj = JSObject::create(cx, FINALIZE_KIND, emptyBlockShape, type, NULL);
 86483:     if (!obj)
 86483:         return NULL;
 86483: 
100006:     obj->setPrivate(NULL);
 86483:     return &obj->asStaticBlock();
 86483: }
 86483: 
 86483: const Shape *
 91237: StaticBlockObject::addVar(JSContext *cx, jsid id, int index, bool *redeclared)
 86483: {
 87188:     JS_ASSERT(JSID_IS_ATOM(id) || (JSID_IS_INT(id) && JSID_TO_INT(id) == index));
 87188: 
 86483:     *redeclared = false;
 86483: 
 86483:     /* Inline JSObject::addProperty in order to trap the redefinition case. */
 86483:     Shape **spp;
 86483:     if (Shape::search(cx, lastProperty(), id, &spp, true)) {
 86483:         *redeclared = true;
 86483:         return NULL;
 86483:     }
 86483: 
 86483:     /*
 86483:      * Don't convert this object to dictionary mode so that we can clone the
 86483:      * block's shape later.
 86483:      */
 86483:     uint32_t slot = JSSLOT_FREE(&BlockClass) + index;
100006:     return addPropertyInternal(cx, id, block_getProperty, block_setProperty,
 86483:                                slot, JSPROP_ENUMERATE | JSPROP_PERMANENT,
 86483:                                Shape::HAS_SHORTID, index, spp,
 86483:                                /* allowDictionary = */ false);
 86483: }
 86483: 
100006: static void
100006: block_trace(JSTracer *trc, JSObject *obj)
100006: {
100006:     if (obj->isStaticBlock())
100006:         return;
100006: 
100006:     /* XXX: this will be removed again with bug 659577. */
100006: #if JS_HAS_GENERATORS
100006:     StackFrame *fp = obj->asClonedBlock().maybeStackFrame();
100006:     if (fp && fp->isFloatingGenerator())
100006:         MarkObject(trc, &js_FloatingFrameToGenerator(fp)->obj, "generator object");
100006: #endif
100006: }
100006: 
 86483: Class js::BlockClass = {
 86483:     "Block",
100006:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS |
 86483:     JSCLASS_HAS_RESERVED_SLOTS(BlockObject::RESERVED_SLOTS) |
 86483:     JSCLASS_IS_ANONYMOUS,
 86483:     JS_PropertyStub,         /* addProperty */
 86483:     JS_PropertyStub,         /* delProperty */
 86483:     JS_PropertyStub,         /* getProperty */
 86483:     JS_StrictPropertyStub,   /* setProperty */
 86483:     JS_EnumerateStub,
 86483:     JS_ResolveStub,
100006:     JS_ConvertStub,
100006:     NULL,                    /* finalize */
100006:     NULL,                    /* checkAccess */
100006:     NULL,                    /* call        */
100006:     NULL,                    /* construct   */
100006:     NULL,                    /* hasInstance */
100006:     block_trace
 86483: };
 86483: 
 86483: #define NO_PARENT_INDEX UINT32_MAX
 86483: 
 97298: /*
 97298:  * If there's a parent id, then get the parent out of our script's object
 97298:  * array. We know that we clone block objects in outer-to-inner order, which
 97298:  * means that getting the parent now will work.
 97298:  */
 86483: static uint32_t
 97298: FindObjectIndex(JSScript *script, StaticBlockObject *maybeBlock)
 86483: {
 97839:     if (!maybeBlock || !script->hasObjects())
 97298:         return NO_PARENT_INDEX;
 86483: 
 97401:     ObjectArray *objects = script->objects();
 97298:     HeapPtrObject *vector = objects->vector;
 97298:     unsigned length = objects->length;
 97298:     for (unsigned i = 0; i < length; ++i) {
 97298:         if (vector[i] == maybeBlock)
 86483:             return i;
 86483:     }
 86483: 
 86483:     return NO_PARENT_INDEX;
 86483: }
 86483: 
 94006: template<XDRMode mode>
 86483: bool
 94006: js::XDRStaticBlockObject(XDRState<mode> *xdr, JSScript *script, StaticBlockObject **objp)
 86483: {
 97298:     /* NB: Keep this in sync with CloneStaticBlockObject. */
 97298: 
 94006:     JSContext *cx = xdr->cx();
 86483: 
 87187:     StaticBlockObject *obj = NULL;
 87187:     uint32_t parentId = 0;
 87187:     uint32_t count = 0;
 87187:     uint32_t depthAndCount = 0;
 94006:     if (mode == XDR_ENCODE) {
 86483:         obj = *objp;
 97298:         parentId = FindObjectIndex(script, obj->enclosingBlock());
 87187:         uint32_t depth = obj->stackDepth();
 87187:         JS_ASSERT(depth <= UINT16_MAX);
 87187:         count = obj->slotCount();
 87187:         JS_ASSERT(count <= UINT16_MAX);
 87187:         depthAndCount = (depth << 16) | uint16_t(count);
 86483:     }
 86483: 
 86483:     /* First, XDR the parent atomid. */
 94006:     if (!xdr->codeUint32(&parentId))
 87187:         return false;
 86483: 
 94006:     if (mode == XDR_DECODE) {
 86483:         obj = StaticBlockObject::create(cx);
 86483:         if (!obj)
 87187:             return false;
 86483:         *objp = obj;
 86483: 
 87187:         obj->setEnclosingBlock(parentId == NO_PARENT_INDEX
 87187:                                ? NULL
 90546:                                : &script->getObject(parentId)->asStaticBlock());
 86483:     }
 86483: 
 86483:     AutoObjectRooter tvr(cx, obj);
 86483: 
 94006:     if (!xdr->codeUint32(&depthAndCount))
 86483:         return false;
 86483: 
 94006:     if (mode == XDR_DECODE) {
 87187:         uint32_t depth = uint16_t(depthAndCount >> 16);
 86483:         count = uint16_t(depthAndCount);
 86483:         obj->setStackDepth(depth);
 86483: 
 86483:         /*
 86483:          * XDR the block object's properties. We know that there are 'count'
 86483:          * properties to XDR, stored as id/shortid pairs.
 86483:          */
 91237:         for (unsigned i = 0; i < count; i++) {
 86483:             JSAtom *atom;
 94006:             if (!XDRAtom(xdr, &atom))
 86483:                 return false;
 86483: 
 87188:             /* The empty string indicates an int id. */
 87188:             jsid id = atom != cx->runtime->emptyString
 97828:                       ? AtomToId(atom)
 87188:                       : INT_TO_JSID(i);
 87188: 
 86483:             bool redeclared;
 87188:             if (!obj->addVar(cx, id, i, &redeclared)) {
 86483:                 JS_ASSERT(!redeclared);
 86483:                 return false;
 86483:             }
 95099: 
 95099:             uint32_t aliased;
 95099:             if (!xdr->codeUint32(&aliased))
 95099:                 return false;
 95099: 
 95099:             JS_ASSERT(aliased == 0 || aliased == 1);
 95099:             obj->setAliased(i, !!aliased);
 86483:         }
 86483:     } else {
 86483:         AutoShapeVector shapes(cx);
 97298:         if (!shapes.growBy(count))
 97298:             return false;
 86483: 
 86483:         for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
 87187:             const Shape *shape = &r.front();
 86483:             shapes[shape->shortid()] = shape;
 86483:         }
 86483: 
 86483:         /*
 86483:          * XDR the block object's properties. We know that there are 'count'
 86483:          * properties to XDR, stored as id/shortid pairs.
 86483:          */
 91237:         for (unsigned i = 0; i < count; i++) {
 87187:             const Shape *shape = shapes[i];
100006:             JS_ASSERT(shape->getter() == block_getProperty);
 91237:             JS_ASSERT(unsigned(shape->shortid()) == i);
 86483: 
 86483:             jsid propid = shape->propid();
 87188:             JS_ASSERT(JSID_IS_ATOM(propid) || JSID_IS_INT(propid));
 86483: 
 87188:             /* The empty string indicates an int id. */
 87188:             JSAtom *atom = JSID_IS_ATOM(propid)
 87188:                            ? JSID_TO_ATOM(propid)
 87188:                            : cx->runtime->emptyString;
 87188: 
 94006:             if (!XDRAtom(xdr, &atom))
 86483:                 return false;
 95099: 
 95099:             uint32_t aliased = obj->isAliased(i);
 95099:             if (!xdr->codeUint32(&aliased))
 95099:                 return false;
 86483:         }
 86483:     }
 86483:     return true;
 86483: }
 86483: 
 94006: template bool
 94006: js::XDRStaticBlockObject(XDRState<XDR_ENCODE> *xdr, JSScript *script, StaticBlockObject **objp);
 94006: 
 94006: template bool
 94006: js::XDRStaticBlockObject(XDRState<XDR_DECODE> *xdr, JSScript *script, StaticBlockObject **objp);
 97298: 
 97298: JSObject *
 97298: js::CloneStaticBlockObject(JSContext *cx, StaticBlockObject &srcBlock,
 97298:                            const AutoObjectVector &objects, JSScript *src)
 97298: {
 97298:     /* NB: Keep this in sync with XDRStaticBlockObject. */
 97298: 
 97298:     StaticBlockObject *clone = StaticBlockObject::create(cx);
 97298:     if (!clone)
 97545:         return NULL;
 97298: 
 97298:     uint32_t parentId = FindObjectIndex(src, srcBlock.enclosingBlock());
 97298:     clone->setEnclosingBlock(parentId == NO_PARENT_INDEX
 97298:                              ? NULL
 97298:                              : &objects[parentId]->asStaticBlock());
 97298: 
 97298:     clone->setStackDepth(srcBlock.stackDepth());
 97298: 
 97298:     /* Shape::Range is reverse order, so build a list in forward order. */
 97298:     AutoShapeVector shapes(cx);
 97298:     if (!shapes.growBy(srcBlock.slotCount()))
 97545:         return NULL;
 97298:     for (Shape::Range r = srcBlock.lastProperty()->all(); !r.empty(); r.popFront())
 97298:         shapes[r.front().shortid()] = &r.front();
 97298: 
 97298:     for (const Shape **p = shapes.begin(); p != shapes.end(); ++p) {
 97298:         jsid id = (*p)->propid();
 97298:         unsigned i = (*p)->shortid();
 97298: 
 97298:         bool redeclared;
 97298:         if (!clone->addVar(cx, id, i, &redeclared)) {
 97298:             JS_ASSERT(!redeclared);
 97545:             return NULL;
 97298:         }
 97298: 
 97298:         clone->setAliased(i, srcBlock.isAliased(i));
 97298:     }
 97298: 
 97298:     return clone;
 97298: }
 98921: 
 98921: /*****************************************************************************/
 98921: 
 98921: ScopeIter::ScopeIter()
 98921:  : fp_(NULL),
 98921:    cur_(reinterpret_cast<JSObject *>(-1)),
 98921:    block_(reinterpret_cast<StaticBlockObject *>(-1)),
 98921:    type_(Type(-1))
 98921: {}
 98921: 
 98921: ScopeIter::ScopeIter(JSObject &enclosingScope)
 98921:   : fp_(NULL),
 98921:     cur_(&enclosingScope),
 98921:     block_(reinterpret_cast<StaticBlockObject *>(-1)),
 98921:     type_(Type(-1))
 98921: {}
 98921: 
 98921: ScopeIter::ScopeIter(StackFrame *fp)
 98921:   : fp_(fp),
 98921:     cur_(fp->scopeChain()),
 98921:     block_(fp->maybeBlockChain())
 98921: {
 98921:     settle();
 98921: }
 98921: 
 98921: ScopeIter::ScopeIter(ScopeIter si, StackFrame *fp)
 98921:   : fp_(fp),
 98921:     cur_(si.cur_),
 98921:     block_(si.block_),
 98921:     type_(si.type_),
 98921:     hasScopeObject_(si.hasScopeObject_)
 98921: {}
 98921: 
 98921: ScopeIter::ScopeIter(StackFrame *fp, ScopeObject &scope)
 98921:   : fp_(fp),
 98921:     cur_(&scope)
 98921: {
 98921:     /*
 98921:      * Find the appropriate static block for this iterator, given 'scope'. We
 98921:      * know that 'scope' is a (non-optimized) scope on fp's scope chain. We do
 98921:      * not, however, know whether fp->maybeScopeChain() encloses 'scope'. E.g.:
 98921:      *
 98921:      *   let (x = 1) {
 98921:      *     g = function() { eval('debugger') };
 98921:      *     let (y = 1) g();
 98921:      *   }
 98921:      *
 98921:      * g will have x's block in its enclosing scope but not y's. However, at
 98921:      * the debugger statement, both the x's and y's blocks will be on
 98921:      * fp->blockChain. Fortunately, we can compare scope object stack depths to
 98921:      * determine the block (if any) that encloses 'scope'.
 98921:      */
 98921:     if (cur_->isNestedScope()) {
 98921:         block_ = fp->maybeBlockChain();
 98921:         while (block_) {
 98921:             if (block_->stackDepth() <= cur_->asNestedScope().stackDepth())
 98921:                 break;
 98921:             block_ = block_->enclosingBlock();
 98921:         }
 98921:         JS_ASSERT_IF(cur_->isClonedBlock(), cur_->asClonedBlock().staticBlock() == *block_);
 98921:     } else {
 98921:         block_ = NULL;
 98921:     }
 98921:     settle();
 98921: }
 98921: 
 98921: ScopeObject &
 98921: ScopeIter::scope() const
 98921: {
 98921:     JS_ASSERT(hasScopeObject());
 98921:     return cur_->asScope();
 98921: }
 98921: 
 98921: ScopeIter
 98921: ScopeIter::enclosing() const
 98921: {
 98921:     JS_ASSERT(!done());
 98921:     ScopeIter si = *this;
 98921:     switch (type_) {
 98921:       case Call:
 98921:         if (hasScopeObject_) {
 98921:             si.cur_ = &cur_->asCall().enclosingScope();
 98921:             if (CallObjectLambdaName(si.fp_->fun()))
 98921:                 si.cur_ = &si.cur_->asDeclEnv().enclosingScope();
 98921:         }
 98921:         si.fp_ = NULL;
 98921:         break;
 98921:       case Block:
 98921:         si.block_ = block_->enclosingBlock();
 98921:         if (hasScopeObject_)
 98921:             si.cur_ = &cur_->asClonedBlock().enclosingScope();
 98921:         si.settle();
 98921:         break;
 98921:       case With:
 98921:         JS_ASSERT(hasScopeObject_);
 98921:         si.cur_ = &cur_->asWith().enclosingScope();
 98921:         si.settle();
 98921:         break;
 98921:       case StrictEvalScope:
 98921:         if (hasScopeObject_)
 98921:             si.cur_ = &cur_->asCall().enclosingScope();
 98921:         si.fp_ = NULL;
 98921:         break;
 98921:     }
 98921:     return si;
 98921: }
 98921: 
 98921: void
 98921: ScopeIter::settle()
 98921: {
 98921:     /*
 98921:      * Given an iterator state (cur_, block_), figure out which (potentially
 98921:      * optimized) scope the iterator should report. Thus, the result is a pair
 98921:      * (type_, hasScopeObject_) where hasScopeObject_ indicates whether the
 98921:      * scope object has been optimized away and does not exist on the scope
 98921:      * chain. Beware: while ScopeIter iterates over the scopes of a single
 98921:      * frame, the scope chain (pointed to by cur_) continues into the scopes of
 98921:      * enclosing frames. Thus, it is important not to look at cur_ until it is
 98921:      * certain that cur_ points to a scope object in the current frame. In
 99462:      * particular, there are three tricky corner cases:
 99462:      *  - non-heavyweight functions;
 98921:      *  - non-strict direct eval.
 99462:      *  - heavyweight functions observed before the prologue has finished;
 99462:      * In all cases, cur_ can already be pointing into an enclosing frame's
 99462:      * scope chain. Furthermore, in the first two cases: even if cur_ points
 99462:      * into an enclosing frame's scope chain, the current frame may still have
 99462:      * uncloned blocks. In the last case, since we haven't entered the
 99462:      * function, we simply return a ScopeIter where done() == true.
 98921:      *
 98921:      * Note: DebugScopeObject falls nicely into this plan: since they are only
 98921:      * ever introduced as the *enclosing* scope of a frame, they should never
 98921:      * show up in scope iteration and fall into the final non-scope case.
 98921:      */
 98921:     if (fp_->isNonEvalFunctionFrame() && !fp_->fun()->isHeavyweight()) {
 98921:         if (block_) {
 98921:             type_ = Block;
 98921:             hasScopeObject_ = block_->needsClone();
 98921:         } else {
 98921:             type_ = Call;
 98921:             hasScopeObject_ = false;
 98921:         }
 98921:     } else if (fp_->isNonStrictDirectEvalFrame() && cur_ == fp_->prev()->scopeChain()) {
 98921:         if (block_) {
 98921:             JS_ASSERT(!block_->needsClone());
 98921:             type_ = Block;
 98921:             hasScopeObject_ = false;
 98921:         } else {
 98921:             fp_ = NULL;
 98921:         }
100006:     } else if (fp_->isNonEvalFunctionFrame() && !fp_->hasCallObj()) {
 99462:         JS_ASSERT(cur_ == fp_->fun()->environment());
 99462:         fp_ = NULL;
 98921:     } else if (cur_->isWith()) {
 98921:         JS_ASSERT_IF(fp_->isFunctionFrame(), fp_->fun()->isHeavyweight());
 98921:         JS_ASSERT_IF(block_, block_->needsClone());
 98921:         JS_ASSERT_IF(block_, block_->stackDepth() < cur_->asWith().stackDepth());
 98921:         type_ = With;
 98921:         hasScopeObject_ = true;
 98921:     } else if (block_) {
 98921:         type_ = Block;
 98921:         hasScopeObject_ = block_->needsClone();
 98921:         JS_ASSERT_IF(hasScopeObject_, cur_->asClonedBlock().staticBlock() == *block_);
 98921:     } else if (cur_->isCall()) {
 98921:         CallObject &callobj = cur_->asCall();
 98921:         type_ = callobj.isForEval() ? StrictEvalScope : Call;
 98921:         hasScopeObject_ = true;
 98921:         JS_ASSERT_IF(type_ == Call, callobj.getCalleeFunction()->script() == fp_->script());
 98921:     } else {
 98921:         JS_ASSERT(!cur_->isScope());
 98921:         JS_ASSERT(fp_->isGlobalFrame() || fp_->isDebuggerFrame());
 98921:         fp_ = NULL;
 98921:     }
 98921: }
 98921: 
 98921: /* static */ HashNumber
 98921: ScopeIter::hash(ScopeIter si)
 98921: {
 98921:     /* hasScopeObject_ is determined by the other fields. */
 98921:     return size_t(si.fp_) ^ size_t(si.cur_) ^ size_t(si.block_) ^ si.type_;
 98921: }
 98921: 
 98921: /* static */ bool
 98921: ScopeIter::match(ScopeIter si1, ScopeIter si2)
 98921: {
 98921:     /* hasScopeObject_ is determined by the other fields. */
 98921:     return si1.fp_ == si2.fp_ &&
 98921:            (!si1.fp_ ||
 98921:             (si1.cur_   == si2.cur_   &&
 98921:              si1.block_ == si2.block_ &&
 98921:              si1.type_  == si2.type_));
 98921: }
 98921: 
 98921: /*****************************************************************************/
 98921: 
 98921: namespace js {
 98921: 
 98921: /*
 98921:  * DebugScopeProxy is the handler for DebugScopeObject proxy objects and mostly
 98921:  * just wraps ScopeObjects. Having a custom handler (rather than trying to
 98921:  * reuse js::Wrapper) gives us several important abilities:
 98921:  *  - We want to pass the ScopeObject as the receiver to forwarded scope
 98921:  *    property ops so that Call/Block/With ops do not all require a
 98921:  *    'normalization' step.
 98921:  *  - The engine has made certain assumptions about the possible reads/writes
 98921:  *    in a scope. DebugScopeProxy allows us to prevent the debugger from
 98921:  *    breaking those assumptions. Examples include adding shadowing variables
 98921:  *    or changing the property attributes of bindings.
 98921:  *  - The engine makes optimizations that are observable to the debugger. The
 98921:  *    proxy can either hide these optimizations or make the situation more
 98921:  *    clear to the debugger. An example is 'arguments'.
 98921:  */
 98922: class DebugScopeProxy : public BaseProxyHandler
 98921: {
 98922:     static bool isArguments(JSContext *cx, jsid id)
 98922:     {
 98922:         return id == NameToId(cx->runtime->atomState.argumentsAtom);
 98922:     }
 98922: 
 98922:     static bool isFunctionScope(ScopeObject &scope)
 98922:     {
 98922:         return scope.isCall() && !scope.asCall().isForEval();
 98922:     }
 98922: 
 98922:     /*
 98922:      * In theory, every function scope contains an 'arguments' bindings.
 98922:      * However, the engine only adds a binding if 'arguments' is used in the
 98922:      * function body. Thus, from the debugger's perspective, 'arguments' may be
 98922:      * missing from the list of bindings.
 98922:      */
 98922:     static bool isMissingArgumentsBinding(ScopeObject &scope)
 98922:     {
 98922:         return isFunctionScope(scope) &&
 98922:                !scope.asCall().getCalleeFunction()->script()->argumentsHasLocalBinding();
 98922:     }
 98922: 
 98922:     /*
 98922:      * This function creates an arguments object when the debugger requests
 98922:      * 'arguments' for a function scope where the arguments object has been
 98922:      * optimized away (either because the binding is missing altogether or
 98922:      * because !ScriptAnalysis::needsArgsObj).
 98922:      */
 98922:     static bool checkForMissingArguments(JSContext *cx, jsid id, ScopeObject &scope,
 98922:                                          ArgumentsObject **maybeArgsObj)
 98922:     {
 98922:         *maybeArgsObj = NULL;
 98922: 
 98922:         if (!isArguments(cx, id) || !isFunctionScope(scope))
 98922:             return true;
 98922: 
 98922:         JSScript *script = scope.asCall().getCalleeFunction()->script();
 98922:         if (script->needsArgsObj())
 98922:             return true;
 98922: 
100006:         StackFrame *fp = scope.maybeStackFrame();
100006:         if (!fp) {
 98922:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_LIVE,
 98922:                                  "Debugger scope");
 98922:             return false;
 98922:         }
 98922: 
100006:         *maybeArgsObj = ArgumentsObject::createUnexpected(cx, fp);
 98922:         return true;
 98922:     }
 98922: 
 98922:   public:
 98921:     static int family;
 98921:     static DebugScopeProxy singleton;
 98921: 
 98921:     DebugScopeProxy() : BaseProxyHandler(&family) {}
 98921: 
 98921:     bool getPropertyDescriptor(JSContext *cx, JSObject *proxy, jsid id, bool set,
 98921:                                PropertyDescriptor *desc) MOZ_OVERRIDE
 98921:     {
 98921:         return getOwnPropertyDescriptor(cx, proxy, id, set, desc);
 98921:     }
 98921: 
 98921:     bool getOwnPropertyDescriptor(JSContext *cx, JSObject *proxy, jsid id, bool set,
 98921:                                   PropertyDescriptor *desc) MOZ_OVERRIDE
 98921:     {
 98922:         ScopeObject &scope = proxy->asDebugScope().scope();
 98922: 
 98922:         ArgumentsObject *maybeArgsObj;
 98922:         if (!checkForMissingArguments(cx, id, scope, &maybeArgsObj))
 98922:             return false;
 98922: 
 98922:         if (maybeArgsObj) {
 98922:             PodZero(desc);
 98922:             desc->obj = proxy;
 98922:             desc->attrs = JSPROP_READONLY | JSPROP_ENUMERATE | JSPROP_PERMANENT;
 98922:             desc->value = ObjectValue(*maybeArgsObj);
 98922:             return true;
 98922:         }
 98922: 
100006:         AutoAllowUnaliasedVarAccess a(cx);
 98921:         return JS_GetPropertyDescriptorById(cx, &scope, id, JSRESOLVE_QUALIFIED, desc);
 98921:     }
 98921: 
 98921:     bool get(JSContext *cx, JSObject *proxy, JSObject *receiver, jsid id, Value *vp) MOZ_OVERRIDE
 98921:     {
 98922:         ScopeObject &scope = proxy->asDebugScope().scope();
 98922: 
 98922:         ArgumentsObject *maybeArgsObj;
 98922:         if (!checkForMissingArguments(cx, id, scope, &maybeArgsObj))
 98922:             return false;
 98922: 
 98922:         if (maybeArgsObj) {
 98922:             *vp = ObjectValue(*maybeArgsObj);
 98922:             return true;
 98922:         }
 98922: 
100006:         AutoAllowUnaliasedVarAccess a(cx);
 99421:         return scope.getGeneric(cx, RootedObject(cx, &scope), RootedId(cx, id), vp);
 98921:     }
 98921: 
 98921:     bool set(JSContext *cx, JSObject *proxy, JSObject *receiver, jsid id, bool strict,
 98921:                      Value *vp) MOZ_OVERRIDE
 98921:     {
100006:         AutoAllowUnaliasedVarAccess a(cx);
 98921:         ScopeObject &scope = proxy->asDebugScope().scope();
 99421:         return scope.setGeneric(cx, RootedId(cx, id), vp, strict);
 98921:     }
 98921: 
 98921:     bool defineProperty(JSContext *cx, JSObject *proxy, jsid id, PropertyDescriptor *desc) MOZ_OVERRIDE
 98921:     {
 99960:         bool found;
 99960:         if (!has(cx, proxy, id, &found))
 99960:             return false;
 99960:         if (found)
 98921:             return Throw(cx, id, JSMSG_CANT_REDEFINE_PROP);
 99960: 
 99960:         ScopeObject &scope = proxy->asDebugScope().scope();
 99960:         return JS_DefinePropertyById(cx, &scope, id, desc->value, desc->getter, desc->setter,
 99960:                                      desc->attrs);
 98921:     }
 98921: 
 98921:     bool getOwnPropertyNames(JSContext *cx, JSObject *proxy, AutoIdVector &props) MOZ_OVERRIDE
 98921:     {
 98921:         ScopeObject &scope = proxy->asDebugScope().scope();
 98922: 
 98922:         if (isMissingArgumentsBinding(scope) &&
 98922:             !props.append(NameToId(cx->runtime->atomState.argumentsAtom)))
 98922:         {
 98922:             return false;
 98922:         }
 98922: 
 98921:         return GetPropertyNames(cx, &scope, JSITER_OWNONLY, &props);
 98921:     }
 98921: 
 98921:     bool delete_(JSContext *cx, JSObject *proxy, jsid id, bool *bp) MOZ_OVERRIDE
 98921:     {
 98921:         return js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_CANT_DELETE,
 98921:                                         JSDVG_IGNORE_STACK, IdToValue(id), NULL,
 98921:                                         NULL, NULL);
 98921:     }
 98921: 
 98921:     bool enumerate(JSContext *cx, JSObject *proxy, AutoIdVector &props) MOZ_OVERRIDE
 98921:     {
 98921:         ScopeObject &scope = proxy->asDebugScope().scope();
 98922: 
 98922:         if (isMissingArgumentsBinding(scope) &&
 98922:             !props.append(NameToId(cx->runtime->atomState.argumentsAtom)))
 98922:         {
 98922:             return false;
 98922:         }
 98922: 
 98921:         return GetPropertyNames(cx, &scope, 0, &props);
 98921:     }
 98922: 
 98922:     bool has(JSContext *cx, JSObject *proxy, jsid id, bool *bp) MOZ_OVERRIDE
 98922:     {
 98922:         ScopeObject &scope = proxy->asDebugScope().scope();
 98922: 
 98922:         if (isArguments(cx, id) && isFunctionScope(scope)) {
 98922:             *bp = true;
 98922:             return true;
 98922:         }
 98922: 
 98922:         JSBool found;
 98922:         if (!JS_HasPropertyById(cx, &scope, id, &found))
 98922:             return false;
 98922: 
 98922:         *bp = found;
 98922:         return true;
 98922:     }
 98921: };
 98921: 
 98921: }  /* namespace js */
 98921: 
 98921: int DebugScopeProxy::family = 0;
 98921: DebugScopeProxy DebugScopeProxy::singleton;
 98921: 
 98921: /* static */ DebugScopeObject *
 98921: DebugScopeObject::create(JSContext *cx, ScopeObject &scope, JSObject &enclosing)
 98921: {
 98921:     JSObject *obj = NewProxyObject(cx, &DebugScopeProxy::singleton, ObjectValue(scope),
 98921:                                    NULL /* proto */, &scope.global(),
 98921:                                    NULL /* call */, NULL /* construct */);
 98921:     if (!obj)
 98921:         return NULL;
 98921: 
 98921:     JS_ASSERT(!enclosing.isScope());
 98921:     SetProxyExtra(obj, ENCLOSING_EXTRA, ObjectValue(enclosing));
 98921: 
 98921:     return &obj->asDebugScope();
 98921: }
 98921: 
 98921: ScopeObject &
 98921: DebugScopeObject::scope() const
 98921: {
 98921:     return Wrapper::wrappedObject(this)->asScope();
 98921: }
 98921: 
 98921: JSObject &
 98921: DebugScopeObject::enclosingScope() const
 98921: {
 98921:     return GetProxyExtra(this, ENCLOSING_EXTRA).toObject();
 98921: }
 98921: 
 98921: bool
 98921: DebugScopeObject::isForDeclarative() const
 98921: {
 98921:     ScopeObject &s = scope();
 98921:     return s.isCall() || s.isBlock() || s.isDeclEnv();
 98921: }
 98921: 
 98921: bool
 98921: js_IsDebugScopeSlow(const JSObject *obj)
 98921: {
 98921:     return obj->getClass() == &ObjectProxyClass &&
 98921:            GetProxyHandler(obj) == &DebugScopeProxy::singleton;
 98921: }
 98921: 
 98921: /*****************************************************************************/
 98921: 
 98921: DebugScopes::DebugScopes(JSRuntime *rt)
 98921:  : proxiedScopes(rt),
100006:    missingScopes(rt)
 98921: {}
 98921: 
 98921: DebugScopes::~DebugScopes()
 98921: {
 98921:     JS_ASSERT(missingScopes.empty());
 98921: }
 98921: 
 98921: bool
 98921: DebugScopes::init()
 98921: {
100006:     if (!proxiedScopes.init() ||
 98921:         !missingScopes.init())
 98921:     {
 98921:         return false;
 98921:     }
 98921:     return true;
 98921: }
 98921: 
 98921: void
 98921: DebugScopes::mark(JSTracer *trc)
 98921: {
 98921:     proxiedScopes.trace(trc);
 98921: }
 98921: 
 98921: void
100006: DebugScopes::sweep()
 98921: {
 98921:     /*
 98921:      * Note: missingScopes points to debug scopes weakly not just so that debug
 98921:      * scopes can be released more eagerly, but, more importantly, to avoid
 98921:      * creating an uncollectable cycle with suspended generator frames.
 98921:      */
 98921:     for (MissingScopeMap::Enum e(missingScopes); !e.empty(); e.popFront()) {
 99246:         if (!IsObjectMarked(&e.front().value))
 98921:             e.removeFront();
 98921:     }
 98921: }
 98921: 
 98921: /*
 98921:  * Unfortunately, GetDebugScopeForFrame needs to work even outside debug mode
 98921:  * (in particular, JS_GetFrameScopeChain does not require debug mode). Since
 98921:  * DebugScopes::onPop* are only called in debug mode, this means we cannot
 98921:  * use any of the maps in DebugScopes. This will produce debug scope chains
 98921:  * that do not obey the debugger invariants but that is just fine.
 98921:  */
 98921: static bool
 98921: CanUseDebugScopeMaps(JSContext *cx)
 98921: {
 98921:     return cx->compartment->debugMode();
 98921: }
 98921: 
 98921: DebugScopeObject *
 98921: DebugScopes::hasDebugScope(JSContext *cx, ScopeObject &scope) const
 98921: {
 98921:     if (ObjectWeakMap::Ptr p = proxiedScopes.lookup(&scope)) {
 98921:         JS_ASSERT(CanUseDebugScopeMaps(cx));
 98921:         return &p->value->asDebugScope();
 98921:     }
 98921:     return NULL;
 98921: }
 98921: 
 98921: bool
 98921: DebugScopes::addDebugScope(JSContext *cx, ScopeObject &scope, DebugScopeObject &debugScope)
 98921: {
 98921:     if (!CanUseDebugScopeMaps(cx))
 98921:         return true;
 98921:     JS_ASSERT(!proxiedScopes.has(&scope));
 98921:     if (!proxiedScopes.put(&scope, &debugScope)) {
 98921:         js_ReportOutOfMemory(cx);
 98921:         return false;
 98921:     }
 98921:     return true;
 98921: }
 98921: 
 98921: DebugScopeObject *
 98921: DebugScopes::hasDebugScope(JSContext *cx, ScopeIter si) const
 98921: {
 98921:     JS_ASSERT(!si.hasScopeObject());
 98921:     if (MissingScopeMap::Ptr p = missingScopes.lookup(si)) {
 98921:         JS_ASSERT(CanUseDebugScopeMaps(cx));
 98921:         return p->value;
 98921:     }
 98921:     return NULL;
 98921: }
 98921: 
 98921: bool
 98921: DebugScopes::addDebugScope(JSContext *cx, ScopeIter si, DebugScopeObject &debugScope)
 98921: {
 98921:     JS_ASSERT(!si.hasScopeObject());
 98921:     if (!CanUseDebugScopeMaps(cx))
 98921:         return true;
 98921:     JS_ASSERT(!missingScopes.has(si));
 98921:     if (!missingScopes.put(si, &debugScope)) {
 98921:         js_ReportOutOfMemory(cx);
 98921:         return false;
 98921:     }
 98921:     return true;
 98921: }
 98921: 
 98921: void
 98921: DebugScopes::onPopCall(StackFrame *fp)
 98921: {
100006:     if (fp->isYielding())
 98921:         return;
 98921: 
100006:     if (!fp->fun()->isHeavyweight()) {
100006:         JS_ASSERT(!fp->hasCallObj());
 98921:         if (MissingScopeMap::Ptr p = missingScopes.lookup(ScopeIter(fp))) {
100006:             js_PutCallObject(fp, p->value->scope().asCall());
 98921:             missingScopes.remove(p);
 98921:         }
 98921:     }
 98921: }
 98921: 
 98921: void
 98921: DebugScopes::onPopBlock(JSContext *cx, StackFrame *fp)
 98921: {
100006:     StaticBlockObject &block = *fp->maybeBlockChain();
100006:     if (!block.needsClone()) {
100006:         JS_ASSERT(!fp->scopeChain()->isBlock() ||
100006:                   fp->scopeChain()->asClonedBlock().staticBlock() != block);
 98921:         if (MissingScopeMap::Ptr p = missingScopes.lookup(ScopeIter(fp))) {
100006:             p->value->scope().asClonedBlock().put(fp);
 98921:             missingScopes.remove(p);
 98921:         }
 98921:     }
 98921: }
 98921: 
 98921: void
 98921: DebugScopes::onGeneratorFrameChange(StackFrame *from, StackFrame *to)
 98921: {
 98921:     for (ScopeIter toIter(to); !toIter.done(); toIter = toIter.enclosing()) {
100006:         if (!toIter.hasScopeObject()) {
 98921:             if (MissingScopeMap::Ptr p = missingScopes.lookup(ScopeIter(toIter, from))) {
 98921:                 DebugScopeObject &debugScope = *p->value;
100006:                 ScopeObject &scope = debugScope.scope();
100006:                 if (scope.isCall()) {
100006:                     JS_ASSERT(scope.maybeStackFrame() == from);
100006:                     scope.setStackFrame(to);
100006:                     if (scope.enclosingScope().isDeclEnv()) {
100006:                         JS_ASSERT(scope.enclosingScope().asDeclEnv().maybeStackFrame() == from);
100006:                         scope.enclosingScope().asDeclEnv().setStackFrame(to);
100006:                     }
100006:                 }
 98921:                 missingScopes.remove(p);
 98921:                 missingScopes.put(toIter, &debugScope);
 98921:             }
 98921:         }
 98921:     }
 98921: }
 98921: 
 98921: void
 98921: DebugScopes::onCompartmentLeaveDebugMode(JSCompartment *c)
 98921: {
 98921:     for (MissingScopeMap::Enum e(missingScopes); !e.empty(); e.popFront()) {
 98921:         if (e.front().key.fp()->compartment() == c)
 98921:             e.removeFront();
 98921:     }
 98921: }
 98921: 
 98921: /*****************************************************************************/
 98921: 
 98921: static JSObject *
 98921: GetDebugScope(JSContext *cx, ScopeIter si);
 98921: 
 98921: static DebugScopeObject *
 98921: GetDebugScopeForScope(JSContext *cx, ScopeObject &scope, ScopeIter enclosing)
 98921: {
 98921:     DebugScopes &debugScopes = *cx->runtime->debugScopes;
 98921:     if (DebugScopeObject *debugScope = debugScopes.hasDebugScope(cx, scope))
 98921:         return debugScope;
 98921: 
 98921:     JSObject *enclosingDebug = GetDebugScope(cx, enclosing);
 98921:     if (!enclosingDebug)
 98921:         return NULL;
 98921: 
 98921:     JSObject &maybeDecl = scope.enclosingScope();
 98921:     if (maybeDecl.isDeclEnv()) {
 98921:         JS_ASSERT(CallObjectLambdaName(scope.asCall().getCalleeFunction()));
 98921:         enclosingDebug = DebugScopeObject::create(cx, maybeDecl.asDeclEnv(), *enclosingDebug);
 98921:         if (!enclosingDebug)
 98921:             return NULL;
 98921:     }
 98921: 
 98921:     DebugScopeObject *debugScope = DebugScopeObject::create(cx, scope, *enclosingDebug);
 98921:     if (!debugScope)
 98921:         return NULL;
 98921: 
 98921:     if (!debugScopes.addDebugScope(cx, scope, *debugScope))
 98921:         return NULL;
 98921: 
 98921:     return debugScope;
 98921: }
 98921: 
 98921: static DebugScopeObject *
 98921: GetDebugScopeForMissing(JSContext *cx, ScopeIter si)
 98921: {
 98921:     DebugScopes &debugScopes = *cx->runtime->debugScopes;
 98921:     if (DebugScopeObject *debugScope = debugScopes.hasDebugScope(cx, si))
 98921:         return debugScope;
 98921: 
 98921:     JSObject *enclosingDebug = GetDebugScope(cx, si.enclosing());
 98921:     if (!enclosingDebug)
 98921:         return NULL;
 98921: 
 98921:     /*
 98921:      * Create the missing scope object. This takes care of storing variable
 98921:      * values after the StackFrame has been popped. To preserve scopeChain
 98921:      * depth invariants, these lazily-reified scopes must not be put on the
 98921:      * frame's scope chain; instead, they are maintained via DebugScopes hooks.
 98921:      */
 98921:     DebugScopeObject *debugScope = NULL;
 98921:     switch (si.type()) {
 98921:       case ScopeIter::Call: {
 98921:         CallObject *callobj = CallObject::createForFunction(cx, si.fp());
 98921:         if (!callobj)
 98921:             return NULL;
 98921: 
100006:         JSObject &maybeDecl = callobj->enclosingScope();
100006:         if (maybeDecl.isDeclEnv()) {
 98921:             JS_ASSERT(CallObjectLambdaName(callobj->getCalleeFunction()));
100006:             enclosingDebug = DebugScopeObject::create(cx, maybeDecl.asDeclEnv(), *enclosingDebug);
 98921:             if (!enclosingDebug)
 98921:                 return NULL;
 98921:         }
 98921: 
 98921:         debugScope = DebugScopeObject::create(cx, *callobj, *enclosingDebug);
100006:         if (!debugScope)
100006:             return NULL;
100006: 
100006:         if (!CanUseDebugScopeMaps(cx))
100006:             js_PutCallObject(si.fp(), *callobj);
 98921:         break;
 98921:       }
 98921:       case ScopeIter::Block: {
 99421:         Rooted<StaticBlockObject *> staticBlock(cx, &si.staticBlock());
 98921:         ClonedBlockObject *block = ClonedBlockObject::create(cx, staticBlock, si.fp());
 98921:         if (!block)
 98921:             return NULL;
 98921: 
 98921:         debugScope = DebugScopeObject::create(cx, *block, *enclosingDebug);
100006:         if (!debugScope)
100006:             return NULL;
100006: 
100006:         if (!CanUseDebugScopeMaps(cx))
100006:             block->put(si.fp());
 98921:         break;
 98921:       }
 98921:       case ScopeIter::With:
 98921:       case ScopeIter::StrictEvalScope:
 98921:         JS_NOT_REACHED("should already have a scope");
 98921:     }
 98921: 
 98921:     if (!debugScopes.addDebugScope(cx, si, *debugScope))
 98921:         return NULL;
 98921: 
 98921:     return debugScope;
 98921: }
 98921: 
 98921: static JSObject *
 98921: GetDebugScope(JSContext *cx, JSObject &obj)
 98921: {
 98921:     /*
 98921:      * As an engine invariant (maintained internally and asserted by Execute),
 98921:      * ScopeObjects and non-ScopeObjects cannot be interleaved on the scope
 98921:      * chain; every scope chain must start with zero or more ScopeObjects and
 98921:      * terminate with one or more non-ScopeObjects (viz., GlobalObject).
 98921:      */
 98921:     if (!obj.isScope()) {
 98921: #ifdef DEBUG
 98921:         JSObject *o = &obj;
 98921:         while ((o = o->enclosingScope()))
 98921:             JS_ASSERT(!o->isScope());
 98921: #endif
 98921:         return &obj;
 98921:     }
 98921: 
100006:     /*
100006:      * If 'scope' is a 'with' block, then the chain is fully reified from that
100006:      * point outwards, and there's no point in bothering with a ScopeIter. If
100006:      * |scope| has an associated stack frame, we can get more detailed scope
100006:      * chain information from that.
100006:      * Note: all this frame hackery will be removed by bug 659577.
100006:      */
 98921:     ScopeObject &scope = obj.asScope();
100006:     if (!scope.isWith() && scope.maybeStackFrame()) {
100006:         StackFrame *fp = scope.maybeStackFrame();
100006:         if (scope.isClonedBlock())
100006:             fp = js_LiveFrameIfGenerator(fp);
 98921:         return GetDebugScope(cx, ScopeIter(fp, scope));
100006:     }
 98921:     return GetDebugScopeForScope(cx, scope, ScopeIter(scope.enclosingScope()));
 98921: }
 98921: 
 98921: static JSObject *
 98921: GetDebugScope(JSContext *cx, ScopeIter si)
 98921: {
 98921:     JS_CHECK_RECURSION(cx, return NULL);
 98921: 
 98921:     if (si.done())
 98921:         return GetDebugScope(cx, si.enclosingScope());
 98921: 
 98921:     if (!si.hasScopeObject())
 98921:         return GetDebugScopeForMissing(cx, si);
 98921: 
 98921:     return GetDebugScopeForScope(cx, si.scope(), si.enclosing());
 98921: }
 98921: 
 98921: JSObject *
 98921: js::GetDebugScopeForFunction(JSContext *cx, JSFunction *fun)
 98921: {
 98921:     assertSameCompartment(cx, fun);
 98921:     JS_ASSERT(cx->compartment->debugMode());
 98921:     return GetDebugScope(cx, *fun->environment());
 98921: }
 98921: 
 98921: JSObject *
 98921: js::GetDebugScopeForFrame(JSContext *cx, StackFrame *fp)
 98921: {
 98921:     assertSameCompartment(cx, fp);
100006:     /* Unfortunately, we cannot JS_ASSERT(debugMode); see CanUseDebugScopeMaps. */
 98921:     return GetDebugScope(cx, ScopeIter(fp));
 98921: }
