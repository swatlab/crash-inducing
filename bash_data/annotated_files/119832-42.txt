 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  8754: 
  8754: #include "pk11func.h"
  8754: #include "nsCOMPtr.h"
119832: #include "nsAutoPtr.h"
 81305: #include "PSMRunnable.h"
  8754: #include "nsString.h"
  8754: #include "nsReadableUtils.h"
 10302: #include "nsPKCS11Slot.h"
  8754: #include "nsProtectedAuthThread.h"
  8754: 
 64576: using namespace mozilla;
 81305: using namespace mozilla::psm;
 64576: 
  8754: NS_IMPL_THREADSAFE_ISUPPORTS1(nsProtectedAuthThread, nsIProtectedAuthThread)
  8754: 
115027: static void nsProtectedAuthThreadRunner(void *arg)
  8754: {
101778:     PR_SetCurrentThreadName("Protected Auth");
101778: 
  8754:     nsProtectedAuthThread *self = static_cast<nsProtectedAuthThread *>(arg);
  8754:     self->Run();
  8754: }
  8754: 
  8754: nsProtectedAuthThread::nsProtectedAuthThread()
 64576: : mMutex("nsProtectedAuthThread.mMutex")
 80486: , mIAmRunning(false)
 80486: , mLoginReady(false)
106838: , mThreadHandle(nullptr)
  8754: , mSlot(0)
  8754: , mLoginResult(SECFailure)
  8754: {
  8754:     NS_INIT_ISUPPORTS();
  8754: }
  8754: 
  8754: nsProtectedAuthThread::~nsProtectedAuthThread()
  8754: {
  8754: }
  8754: 
 10302: NS_IMETHODIMP nsProtectedAuthThread::Login(nsIObserver *aObserver)
  8754: {
 10302:     NS_ENSURE_ARG(aObserver);
 10302:     
  8754:     if (!mSlot)
  8754:         // We need pointer to the slot
  8754:         return NS_ERROR_FAILURE;
  8754: 
 64576:     MutexAutoLock lock(mMutex);
  8754:     
  8754:     if (mIAmRunning || mLoginReady) {
  8754:         return NS_OK;
  8754:     }
  8754: 
 81305:     if (aObserver) {
 81305:       // We must AddRef aObserver here on the main thread, because it probably
 81305:       // does not implement a thread-safe AddRef.
 81305:       mNotifyObserver = new NotifyObserverRunnable(aObserver,
 81305:                                                    "operation-completed");
 81305:     }
 81305: 
 80486:     mIAmRunning = true;
  8754:     
  8754:     mThreadHandle = PR_CreateThread(PR_USER_THREAD, nsProtectedAuthThreadRunner, static_cast<void*>(this), 
  8754:         PR_PRIORITY_NORMAL, PR_LOCAL_THREAD, PR_JOINABLE_THREAD, 0);
  8754:     
106838:     // bool thread_started_ok = (threadHandle != nullptr);
  8754:     // we might want to return "thread started ok" to caller in the future
  8754:     NS_ASSERTION(mThreadHandle, "Could not create nsProtectedAuthThreadRunner thread\n");
  8754:     
  8754:     return NS_OK;
  8754: }
  8754: 
 10302: NS_IMETHODIMP nsProtectedAuthThread::GetTokenName(nsAString &_retval)
  8754: {
 64576:     MutexAutoLock lock(mMutex);
  8754: 
  8754:     // Get token name
 10302:     CopyUTF8toUTF16(nsDependentCString(PK11_GetTokenName(mSlot)), _retval);
  8754: 
  8754:     return NS_OK;
  8754: }
  8754: 
 10302: NS_IMETHODIMP nsProtectedAuthThread::GetSlot(nsIPKCS11Slot **_retval)
 10302: {
119832:     nsRefPtr<nsPKCS11Slot> slot;
 64576:     {
 64576:         MutexAutoLock lock(mMutex);
 64576:         slot = new nsPKCS11Slot(mSlot);
 64576:     }
119832:     if (!slot)
119832:       return NS_ERROR_OUT_OF_MEMORY;
 10302: 
 10302:     return CallQueryInterface (slot.get(), _retval);
 10302: }
  8754: 
  8754: void nsProtectedAuthThread::SetParams(PK11SlotInfo* aSlot)
  8754: {
 64576:     MutexAutoLock lock(mMutex);
  8754: 
  8754:     mSlot = (aSlot) ? PK11_ReferenceSlot(aSlot) : 0;
  8754: }
  8754: 
  8754: SECStatus nsProtectedAuthThread::GetResult()
  8754: {
  8754:     return mLoginResult;
  8754: }
  8754: 
  8754: void nsProtectedAuthThread::Run(void)
  8754: {
  8754:     // Login with null password. This call will also do C_Logout() but 
  8754:     // it is harmless here
  8754:     mLoginResult = PK11_CheckUserPassword(mSlot, 0);
  8754: 
 81305:     nsCOMPtr<nsIRunnable> notifyObserver;
 64576:     {
 64576:         MutexAutoLock lock(mMutex);
  8754: 
 80486:         mLoginReady = true;
 80486:         mIAmRunning = false;
  8754: 
  8754:         // Forget the slot
  8754:         if (mSlot)
  8754:         {
  8754:             PK11_FreeSlot(mSlot);
  8754:             mSlot = 0;
  8754:         }
  8754: 
 81305:         notifyObserver.swap(mNotifyObserver);
  8754:     }
  8754:     
 81305:     if (notifyObserver) {
 81305:         nsresult rv = NS_DispatchToMainThread(notifyObserver);
 81305: 	NS_ASSERTION(NS_SUCCEEDED(rv),
 81305: 		     "failed to dispatch protected auth observer to main thread");
 64576:     }
  8754: }
  8754: 
  8754: void nsProtectedAuthThread::Join()
  8754: {
  8754:     if (!mThreadHandle)
  8754:         return;
  8754:     
  8754:     PR_JoinThread(mThreadHandle);
106838:     mThreadHandle = nullptr;
  8754: }
