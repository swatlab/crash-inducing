    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set sw=2 ts=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *   Brendan Eich <brendan@mozilla.org>
    1:  *   David Hyatt (hyatt@netscape.com)
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Vidur Apparao <vidur@netscape.com>
    1:  *   Johnny Stenback <jst@netscape.com>
    1:  *   Mark Hammond <mhammond@skippinet.com.au>
    1:  *   Ryan Jones <sciguyryan@gmail.com>
10976:  *   Jeff Walden <jwalden+code@mit.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
46852: #ifdef MOZ_IPC
46852: #include "base/basictypes.h"
46852: #endif
46852: 
    1: // Local Includes
    1: #include "nsGlobalWindow.h"
    1: #include "nsScreen.h"
    1: #include "nsHistory.h"
    1: #include "nsBarProps.h"
    1: #include "nsDOMStorage.h"
 1938: #include "nsDOMOfflineResourceList.h"
    1: #include "nsDOMError.h"
    1: 
    1: // Helper Classes
    1: #include "nsXPIDLString.h"
    1: #include "nsJSUtils.h"
    1: #include "prmem.h"
    1: #include "jsapi.h"              // for JSAutoRequest
    1: #include "jsdbgapi.h"           // for JS_ClearWatchPointsForObject
    1: #include "nsReadableUtils.h"
    1: #include "nsDOMClassInfo.h"
29975: #include "nsContentUtils.h"
    1: 
    1: // Other Classes
    1: #include "nsIEventListenerManager.h"
    1: #include "nsEscape.h"
    1: #include "nsStyleCoord.h"
    1: #include "nsMimeTypeArray.h"
    1: #include "nsNetUtil.h"
 3239: #include "nsICachingChannel.h"
    1: #include "nsPluginArray.h"
    1: #include "nsIPluginHost.h"
15958: #include "nsGeolocation.h"
    1: #include "nsContentCID.h"
    1: #include "nsLayoutStatics.h"
    1: #include "nsCycleCollector.h"
 1353: #include "nsCCUncollectableMarker.h"
16753: #include "nsDOMThreadService.h"
37802: #include "nsAutoJSValHolder.h"
    1: 
    1: // Interfaces Needed
29018: #include "nsIFrame.h"
34149: #include "nsCanvasFrame.h"
    1: #include "nsIWidget.h"
    1: #include "nsIBaseWindow.h"
46218: #include "nsAccelerometer.h"
    1: #include "nsIContent.h"
    1: #include "nsIContentViewerEdit.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellLoadInfo.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeNode.h"
29018: #include "nsIEditorDocShell.h"
    1: #include "nsIDocCharset.h"
    1: #include "nsIDocument.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMCrypto.h"
    1: #include "nsIDOMDocument.h"
37608: #include "nsIDOM3Document.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMDocumentView.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocumentEvent.h"
    1: #include "nsIDOMEvent.h"
41071: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMKeyEvent.h"
10976: #include "nsIDOMMessageEvent.h"
    1: #include "nsIDOMPopupBlockedEvent.h"
37802: #include "nsIDOMPopStateEvent.h"
 1938: #include "nsIDOMOfflineResourceList.h"
16677: #include "nsIDOMGeoGeolocation.h"
37608: #include "nsPIDOMStorage.h"
    1: #include "nsDOMString.h"
    1: #include "nsIEmbeddingSiteWindow2.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIHttpProtocolHandler.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIProgrammingLanguage.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIScriptGlobalObjectOwner.h"
    1: #include "nsIScriptSecurityManager.h"
37063: #include "nsIScrollableFrame.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsISelectionController.h"
    1: #include "nsISelection.h"
    1: #include "nsIPrompt.h"
42304: #include "nsIPromptService.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIWebBrowser.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsIWebBrowserFind.h"  // For window.find()
    1: #include "nsIWebContentHandlerRegistrar.h"
    1: #include "nsIWindowMediator.h"  // For window.find()
30385: #include "nsComputedDOMStyle.h"
    1: #include "nsIEntropyCollector.h"
    1: #include "nsDOMCID.h"
    1: #include "nsDOMError.h"
    1: #include "nsDOMWindowUtils.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsPIWindowWatcher.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsDOMClassInfo.h"
    1: #include "nsIJSNativeInitializer.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIScriptEventManager.h" // For GetInterface()
    1: #include "nsIConsoleService.h"
 6910: #include "nsIControllers.h"
    1: #include "nsIControllerContext.h"
    1: #include "nsGlobalWindowCommands.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsContentUtils.h"
    1: #include "nsCSSProps.h"
    1: #include "nsIURIFixup.h"
41653: #include "mozilla/FunctionTimer.h"
    1: #include "nsCDefaultURIFixup.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsIObserverService.h"
 3041: #include "nsIXULAppInfo.h"
    1: #include "nsNetUtil.h"
29018: #include "nsFocusManager.h"
37802: #include "nsIJSON.h"
 3799: #ifdef MOZ_XUL
 3129: #include "nsXULPopupManager.h"
30327: #include "nsIDOMXULControlElement.h"
30327: #include "nsIFrame.h"
 3799: #endif
    1: 
    1: #include "plbase64.h"
    1: 
    1: #ifdef NS_PRINTING
    1: #include "nsIPrintSettings.h"
    1: #include "nsIPrintSettingsService.h"
    1: #include "nsIWebBrowserPrint.h"
    1: #endif
    1: 
    1: #include "nsWindowRoot.h"
    1: #include "nsNetCID.h"
    1: #include "nsIArray.h"
    1: #include "nsIScriptRuntime.h"
    1: 
    1: // XXX An unfortunate dependency exists here (two XUL files).
    1: #include "nsIDOMXULDocument.h"
    1: #include "nsIDOMXULCommandDispatcher.h"
    1: 
    1: #include "nsBindingManager.h"
    1: #include "nsIXBLService.h"
    1: 
    1: // used for popup blocking, needs to be converted to something
    1: // belonging to the back-end like nsIContentPolicy
    1: #include "nsIPopupWindowManager.h"
    1: 
13279: #include "nsIDragService.h"
41930: #include "mozilla/dom/Element.h"
42412: #include "nsFrameLoader.h"
42340: #include "nsISupportsPrimitives.h"
42340: #include "nsXPCOMCID.h"
10989: 
42480: #include "mozilla/FunctionTimer.h"
42480: 
    1: #ifdef MOZ_LOGGING
    1: // so we can get logging even in release builds
    1: #define FORCE_PR_LOG 1
    1: #endif
    1: #include "prlog.h"
    1: 
46347: #include "mozilla/dom/indexedDB/IDBFactory.h"
44204: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo* gDOMLeakPRLog;
    1: #endif
    1: 
41634: using namespace mozilla::dom;
41634: 
22689: nsIDOMStorageList *nsGlobalWindow::sGlobalStorageList  = nsnull;
    1: 
    1: static nsIEntropyCollector *gEntropyCollector          = nsnull;
    1: static PRInt32              gRefCnt                    = 0;
    1: static PRInt32              gOpenPopupSpamCount        = 0;
    1: static PopupControlState    gPopupControlState         = openAbused;
    1: static PRInt32              gRunningTimeoutDepth       = 0;
41071: static PRPackedBool         gMouseDown                 = PR_FALSE;
41071: static PRPackedBool         gDragServiceDisabled       = PR_FALSE;
27826: static FILE                *gDumpFile                  = nsnull;
42108: static PRUint64             gNextWindowID              = 0;
    1: 
11785: #ifdef DEBUG
11785: static PRUint32             gSerialCounter             = 0;
11785: #endif
11785: 
    1: #ifdef DEBUG_jst
    1: PRInt32 gTimeoutCnt                                    = 0;
    1: #endif
    1: 
21376: #if !(defined(NS_DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
21376: static PRBool               gDOMWindowDumpEnabled      = PR_FALSE;
21376: #endif
21376: 
    1: #if defined(DEBUG_bryner) || defined(DEBUG_chb)
    1: #define DEBUG_PAGE_CACHE
    1: #endif
    1: 
    1: // The shortest interval/timeout we permit
    1: #define DOM_MIN_TIMEOUT_VALUE 10 // 10ms
    1: 
34729: // The number of nested timeouts before we start clamping. HTML5 says 1, WebKit
34729: // uses 5.
34729: #define DOM_CLAMP_TIMEOUT_NESTING_LEVEL 5
34729: 
    1: // The longest interval (as PRIntervalTime) we permit, or that our
    1: // timer code can handle, really. See DELAY_INTERVAL_LIMIT in
    1: // nsTimerImpl.h for details.
    1: #define DOM_MAX_TIMEOUT_VALUE    PR_BIT(8 * sizeof(PRIntervalTime) - 1)
    1: 
    1: #define FORWARD_TO_OUTER(method, args, err_rval)                              \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsInnerWindow()) {                                                      \
    1:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
    1:     if (!outer) {                                                             \
    1:       NS_WARNING("No outer window available!");                               \
    1:       return err_rval;                                                        \
    1:     }                                                                         \
    1:     return outer->method args;                                                \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
    1: #define FORWARD_TO_OUTER_VOID(method, args)                                   \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsInnerWindow()) {                                                      \
    1:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
    1:     if (!outer) {                                                             \
    1:       NS_WARNING("No outer window available!");                               \
    1:       return;                                                                 \
    1:     }                                                                         \
    1:     outer->method args;                                                       \
    1:     return;                                                                   \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
    1: #define FORWARD_TO_OUTER_CHROME(method, args, err_rval)                       \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsInnerWindow()) {                                                      \
    1:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
    1:     if (!outer) {                                                             \
    1:       NS_WARNING("No outer window available!");                               \
    1:       return err_rval;                                                        \
    1:     }                                                                         \
    1:     return ((nsGlobalChromeWindow *)outer)->method args;                      \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
42412: #define FORWARD_TO_INNER_CHROME(method, args, err_rval)                       \
42412:   PR_BEGIN_MACRO                                                              \
42412:   if (IsOuterWindow()) {                                                      \
42412:     if (!mInnerWindow) {                                                      \
42412:       NS_WARNING("No inner window available!");                               \
42412:       return err_rval;                                                        \
42412:     }                                                                         \
42412:     return ((nsGlobalChromeWindow *)mInnerWindow)->method args;               \
42412:   }                                                                           \
42412:   PR_END_MACRO
42412: 
 4040: #define FORWARD_TO_OUTER_MODAL_CONTENT_WINDOW(method, args, err_rval)         \
 4040:   PR_BEGIN_MACRO                                                              \
 4040:   if (IsInnerWindow()) {                                                      \
 4040:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
 4040:     if (!outer) {                                                             \
 4040:       NS_WARNING("No outer window available!");                               \
 4040:       return err_rval;                                                        \
 4040:     }                                                                         \
 4040:     return ((nsGlobalModalWindow *)outer)->method args;                       \
 4040:   }                                                                           \
 4040:   PR_END_MACRO
 4040: 
    1: #define FORWARD_TO_INNER(method, args, err_rval)                              \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsOuterWindow()) {                                                      \
    1:     if (!mInnerWindow) {                                                      \
    1:       NS_WARNING("No inner window available!");                               \
    1:       return err_rval;                                                        \
    1:     }                                                                         \
    1:     return GetCurrentInnerWindowInternal()->method args;                      \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
 4040: #define FORWARD_TO_INNER_MODAL_CONTENT_WINDOW(method, args, err_rval)         \
 4040:   PR_BEGIN_MACRO                                                              \
 4040:   if (IsOuterWindow()) {                                                      \
 4040:     if (!mInnerWindow) {                                                      \
 4040:       NS_WARNING("No inner window available!");                               \
 4040:       return err_rval;                                                        \
 4040:     }                                                                         \
 4040:     return ((nsGlobalModalWindow*)GetCurrentInnerWindowInternal())->method args; \
 4040:   }                                                                           \
 4040:   PR_END_MACRO
 4040: 
    1: #define FORWARD_TO_INNER_VOID(method, args)                                   \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsOuterWindow()) {                                                      \
    1:     if (!mInnerWindow) {                                                      \
    1:       NS_WARNING("No inner window available!");                               \
    1:       return;                                                                 \
    1:     }                                                                         \
    1:     GetCurrentInnerWindowInternal()->method args;                             \
    1:     return;                                                                   \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
    1: // Same as FORWARD_TO_INNER, but this will create a fresh inner if an
    1: // inner doesn't already exists.
29474: #define FORWARD_TO_INNER_CREATE(method, args, err_rval)                       \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsOuterWindow()) {                                                      \
    1:     if (!mInnerWindow) {                                                      \
    1:       if (mIsClosed) {                                                        \
29474:         return err_rval;                                                      \
    1:       }                                                                       \
    1:       nsCOMPtr<nsIDOMDocument> doc;                                           \
    1:       nsresult fwdic_nr = GetDocument(getter_AddRefs(doc));                   \
29474:       NS_ENSURE_SUCCESS(fwdic_nr, err_rval);                                  \
    1:       if (!mInnerWindow) {                                                    \
29474:         return err_rval;                                                      \
    1:       }                                                                       \
    1:     }                                                                         \
    1:     return GetCurrentInnerWindowInternal()->method args;                      \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
    1: // CIDs
    1: static NS_DEFINE_CID(kXULControllersCID, NS_XULCONTROLLERS_CID);
    1: 
    1: static const char sJSStackContractID[] = "@mozilla.org/js/xpc/ContextStack;1";
    1: 
    1: static const char kCryptoContractID[] = NS_CRYPTO_CONTRACTID;
    1: static const char kPkcs11ContractID[] = NS_PKCS11_CONTRACTID;
    1: 
37802: static const char sPopStatePrefStr[] = "browser.history.allowPopState";
37802: 
    1: static PRBool
    1: IsAboutBlank(nsIURI* aURI)
    1: {
    1:   NS_PRECONDITION(aURI, "Must have URI");
    1:     
    1:   // GetSpec can be expensive for some URIs, so check the scheme first.
    1:   PRBool isAbout = PR_FALSE;
    1:   if (NS_FAILED(aURI->SchemeIs("about", &isAbout)) || !isAbout) {
    1:     return PR_FALSE;
    1:   }
    1:     
    1:   nsCAutoString str;
    1:   aURI->GetSpec(str);
    1:   return str.EqualsLiteral("about:blank");  
    1: }
    1: 
 6774: class nsDummyJavaPluginOwner : public nsIPluginInstanceOwner
 6774: {
 6774: public:
 6774:   nsDummyJavaPluginOwner(nsIDocument *aDocument)
 6774:     : mDocument(aDocument)
 6774:   {
 6774:   }
 6774: 
 6774:   void Destroy();
 6774: 
 6774:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 6774:   NS_DECL_NSIPLUGININSTANCEOWNER
 6774: 
36766:   NS_IMETHOD GetURL(const char *aURL, const char *aTarget,
36766:                     nsIInputStream *aPostStream,
36766:                     void *aHeadersData, PRUint32 aHeadersDataLen);
 6774:   NS_IMETHOD ShowStatus(const PRUnichar *aStatusMsg);
32799:   NPError ShowNativeContextMenu(NPMenu* menu, void* event);
32019:   NPBool ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
32019:                       double *destX, double *destY, NPCoordinateSpace destSpace);
36227:   void SendIdleEvent();
 6774: 
 6774:   NS_DECL_CYCLE_COLLECTION_CLASS(nsDummyJavaPluginOwner)
 6774: 
 6774: private:
 6774:   nsCOMPtr<nsIPluginInstance> mInstance;
 6774:   nsCOMPtr<nsIDocument> mDocument;
 6774: };
 6774: 
 6774: NS_IMPL_CYCLE_COLLECTION_2(nsDummyJavaPluginOwner, mDocument, mInstance)
 6774: 
 6774: // QueryInterface implementation for nsDummyJavaPluginOwner
 6774: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDummyJavaPluginOwner)
 6774:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 6774:   NS_INTERFACE_MAP_ENTRY(nsIPluginInstanceOwner)
 6774: NS_INTERFACE_MAP_END
 6774: 
 6774: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDummyJavaPluginOwner)
 6774: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDummyJavaPluginOwner)
 6774: 
 6774: 
 6774: void
 6774: nsDummyJavaPluginOwner::Destroy()
 6774: {
 6774:   // If we have a plugin instance, stop it and destroy it now.
 6774:   if (mInstance) {
 6774:     mInstance->Stop();
29834:     mInstance->InvalidateOwner();
 6774:     mInstance = nsnull;
 6774:   }
 6774: 
 6774:   mDocument = nsnull;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::SetInstance(nsIPluginInstance *aInstance)
 6774: {
 6774:   mInstance = aInstance;
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::GetInstance(nsIPluginInstance *&aInstance)
 6774: {
 6774:   NS_IF_ADDREF(aInstance = mInstance);
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
32799: nsDummyJavaPluginOwner::GetWindow(NPWindow *&aWindow)
 6774: {
 6774:   aWindow = nsnull;
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
32799: nsDummyJavaPluginOwner::GetMode(PRInt32 *aMode)
 6774: {
 6774:   // This is wrong, but there's no better alternative.
32799:   *aMode = NP_EMBED;
 6774: 
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::CreateWidget(void)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::GetURL(const char *aURL, const char *aTarget,
36766:                                nsIInputStream *aPostStream,
36766:                                void *aHeadersData, PRUint32 aHeadersDataLen)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::ShowStatus(const char *aStatusMsg)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::ShowStatus(const PRUnichar *aStatusMsg)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
32019: NPError
32799: nsDummyJavaPluginOwner::ShowNativeContextMenu(NPMenu* menu, void* event)
32019: {
34015:   return NPERR_GENERIC_ERROR;
32019: }
32019: 
32019: NPBool
32019: nsDummyJavaPluginOwner::ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
32019:                                      double *destX, double *destY, NPCoordinateSpace destSpace)
32019: {
32019:   return PR_FALSE;
32019: }
32019: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::GetDocument(nsIDocument **aDocument)
 6774: {
 6774:   NS_IF_ADDREF(*aDocument = mDocument);
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
32799: nsDummyJavaPluginOwner::InvalidateRect(NPRect *invalidRect)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
32799: nsDummyJavaPluginOwner::InvalidateRegion(NPRegion invalidRegion)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::ForceRedraw()
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
29834: nsDummyJavaPluginOwner::GetNetscapeWindow(void *value)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
34717: NS_IMETHODIMP
34717: nsDummyJavaPluginOwner::SetEventModel(PRInt32 eventModel)
34717: {
34717:   return NS_ERROR_NOT_IMPLEMENTED;
34717: }
34717: 
36227: void
36227: nsDummyJavaPluginOwner::SendIdleEvent()
36227: {
36227: }
36227: 
    1: /**
    1:  * An indirect observer object that means we don't have to implement nsIObserver
    1:  * on nsGlobalWindow, where any script could see it.
    1:  */
    1: class nsGlobalWindowObserver : public nsIObserver {
    1: public:
    1:   nsGlobalWindowObserver(nsGlobalWindow* aWindow) : mWindow(aWindow) {}
    1:   NS_DECL_ISUPPORTS
    1:   NS_IMETHOD Observe(nsISupports* aSubject, const char* aTopic, const PRUnichar* aData)
    1:   {
    1:     if (!mWindow)
    1:       return NS_OK;
    1:     return mWindow->Observe(aSubject, aTopic, aData);
    1:   }
    1:   void Forget() { mWindow = nsnull; }
    1: private:
    1:   nsGlobalWindow* mWindow;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(nsGlobalWindowObserver, nsIObserver)
    1: 
    1: nsTimeout::nsTimeout()
    1: {
    1: #ifdef DEBUG_jst
    1:   {
    1:     extern int gTimeoutCnt;
    1: 
    1:     ++gTimeoutCnt;
    1:   }
    1: #endif
    1: 
    1:   memset(this, 0, sizeof(*this));
    1: 
    1:   MOZ_COUNT_CTOR(nsTimeout);
    1: }
    1: 
    1: nsTimeout::~nsTimeout()
    1: {
    1: #ifdef DEBUG_jst
    1:   {
    1:     extern int gTimeoutCnt;
    1: 
    1:     --gTimeoutCnt;
    1:   }
    1: #endif
    1: 
    1:   MOZ_COUNT_DTOR(nsTimeout);
    1: }
    1: 
24195: NS_IMPL_CYCLE_COLLECTION_CLASS(nsTimeout)
24195: NS_IMPL_CYCLE_COLLECTION_UNLINK_NATIVE_0(nsTimeout)
24195: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsTimeout)
24195:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mWindow,
24195:                                                        nsIScriptGlobalObject)
24195:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrincipal)
24195:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptHandler)
24195: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
24195: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsTimeout, AddRef)
24195: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsTimeout, Release)
24195: 
41409: nsPIDOMWindow::nsPIDOMWindow(nsPIDOMWindow *aOuterWindow)
41409: : mFrameElement(nsnull), mDocShell(nsnull), mModalStateDepth(0),
41409:   mRunningTimeout(nsnull), mMutationBits(0), mIsDocumentLoaded(PR_FALSE),
41409:   mIsHandlingResizeEvent(PR_FALSE), mIsInnerWindow(aOuterWindow != nsnull),
41409:   mMayHavePaintEventListener(PR_FALSE),
41409:   mIsModalContentWindow(PR_FALSE), mIsActive(PR_FALSE),
41409:   mInnerWindow(nsnull), mOuterWindow(aOuterWindow) {}
41409: 
41409: nsPIDOMWindow::~nsPIDOMWindow() {}
    1: 
    1: //*****************************************************************************
    1: //***    nsGlobalWindow: Object Management
    1: //*****************************************************************************
    1: 
    1: nsGlobalWindow::nsGlobalWindow(nsGlobalWindow *aOuterWindow)
    1:   : nsPIDOMWindow(aOuterWindow),
    1:     mIsFrozen(PR_FALSE),
 6774:     mDidInitJavaProperties(PR_FALSE),
30004:     mFullScreen(PR_FALSE),
    1:     mIsClosed(PR_FALSE), 
    1:     mInClose(PR_FALSE), 
    1:     mHavePendingClose(PR_FALSE),
    1:     mHadOriginalOpener(PR_FALSE),
    1:     mIsPopupSpam(PR_FALSE),
    1:     mBlockScriptedClosingFlag(PR_FALSE),
    1:     mFireOfflineStatusChangeEventOnThaw(PR_FALSE),
    1:     mCreatingInnerWindow(PR_FALSE),
 4209:     mIsChrome(PR_FALSE),
29018:     mNeedsFocus(PR_TRUE),
29018:     mHasFocus(PR_FALSE),
41071: #if defined(XP_MAC) || defined(XP_MACOSX)
41071:     mShowAccelerators(PR_FALSE),
41071:     mShowFocusRings(PR_FALSE),
41071: #else
41071:     mShowAccelerators(PR_TRUE),
41071:     mShowFocusRings(PR_TRUE),
41071: #endif
41071:     mShowFocusRingForContent(PR_FALSE),
42263:     mFocusByKeyOccurred(PR_FALSE),
31738:     mHasAcceleration(PR_FALSE),
42340:     mNotifiedIDDestroyed(PR_FALSE),
    1:     mTimeoutInsertionPoint(nsnull),
    1:     mTimeoutPublicIdCounter(1),
    1:     mTimeoutFiringDepth(0),
    1:     mJSObject(nsnull),
37833:     mPendingStorageEventsObsolete(nsnull),
29018:     mTimeoutsSuspendDepth(0),
37833:     mFocusMethod(0)
    1: #ifdef DEBUG
    1:     , mSetOpenerWindowCalled(PR_FALSE)
    1: #endif
39378:     , mCleanedUp(PR_FALSE)
39378:     , mCallCleanUpAfterModalDialogCloses(PR_FALSE)
42108:     , mWindowID(gNextWindowID++)
    1: {
    1:   memset(mScriptGlobals, 0, sizeof(mScriptGlobals));
    1:   nsLayoutStatics::AddRef();
    1: 
    1:   // Initialize the PRCList (this).
    1:   PR_INIT_CLIST(this);
    1: 
    1:   // Initialize timeout storage
    1:   PR_INIT_CLIST(&mTimeouts);
    1: 
    1:   if (aOuterWindow) {
    1:     // |this| is an inner window, add this inner window to the outer
    1:     // window list of inners.
    1:     PR_INSERT_AFTER(this, aOuterWindow);
    1: 
    1:     mObserver = new nsGlobalWindowObserver(this);
    1:     if (mObserver) {
    1:       NS_ADDREF(mObserver);
41540:       nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
    1:       if (os) {
    1:         // Watch for online/offline status changes so we can fire events. Use
    1:         // a strong reference.
    1:         os->AddObserver(mObserver, NS_IOSERVICE_OFFLINE_STATUS_TOPIC,
    1:                         PR_FALSE);
    1: 
27004:         // Watch for dom-storage-changed so we can fire storage
    1:         // events. Use a strong reference.
37608:         os->AddObserver(mObserver, "dom-storage2-changed", PR_FALSE);
    1:         os->AddObserver(mObserver, "dom-storage-changed", PR_FALSE);
    1:       }
    1:     }
    1:   } else {
    1:     // |this| is an outer window. Outer windows start out frozen and
    1:     // remain frozen until they get an inner window, so freeze this
    1:     // outer window here.
    1:     Freeze();
    1: 
    1:     mObserver = nsnull;
    1:   }
    1: 
    1:   // We could have failed the first time through trying
    1:   // to create the entropy collector, so we should
    1:   // try to get one until we succeed.
21376: 
21376:   gRefCnt++;
21376: 
21376: #if !(defined(NS_DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
21376:   if (gRefCnt == 1) {
21376:     static const char* prefName = "browser.dom.window.dump.enabled";
21376:     nsContentUtils::AddBoolPrefVarCache(prefName, &gDOMWindowDumpEnabled);
21376:     gDOMWindowDumpEnabled = nsContentUtils::GetBoolPref(prefName);
21376:   }
21376: #endif
21376: 
27826:   if (gDumpFile == nsnull) {
27826:     const nsAdoptingCString& fname = 
27826:       nsContentUtils::GetCharPref("browser.dom.window.dump.file");
27826:     if (!fname.IsEmpty()) {
27826:       // if this fails to open, Dump() knows to just go to stdout
27826:       // on null.
27826:       gDumpFile = fopen(fname, "wb+");
27826:     } else {
27826:       gDumpFile = stdout;
27826:     }
27826:   }
27826: 
21376:   if (!gEntropyCollector) {
    1:     CallGetService(NS_ENTROPYCOLLECTOR_CONTRACTID, &gEntropyCollector);
    1:   }
21376: 
    1: #ifdef DEBUG
14743:   printf("++DOMWINDOW == %d (%p) [serial = %d] [outer = %p]\n", gRefCnt,
12416:          static_cast<void*>(static_cast<nsIScriptGlobalObject*>(this)),
12691:          ++gSerialCounter, static_cast<void*>(aOuterWindow));
11693:   mSerial = gSerialCounter;
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1:   if (!gDOMLeakPRLog)
    1:     gDOMLeakPRLog = PR_NewLogModule("DOMLeak");
    1: 
    1:   if (gDOMLeakPRLog)
    1:     PR_LOG(gDOMLeakPRLog, PR_LOG_DEBUG,
    1:            ("DOMWINDOW %p created outer=%p", this, aOuterWindow));
    1: #endif
    1: }
    1: 
    1: nsGlobalWindow::~nsGlobalWindow()
    1: {
    1:   if (!--gRefCnt) {
    1:     NS_IF_RELEASE(gEntropyCollector);
    1:   }
    1: #ifdef DEBUG
14743:   nsCAutoString url;
14743:   if (mLastOpenedURI) {
14743:     mLastOpenedURI->GetSpec(url);
14743:   }
14743: 
14743:   printf("--DOMWINDOW == %d (%p) [serial = %d] [outer = %p] [url = %s]\n",
12416:          gRefCnt, static_cast<void*>(static_cast<nsIScriptGlobalObject*>(this)),
14743:          mSerial, static_cast<void*>(mOuterWindow), url.get());
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1:   if (gDOMLeakPRLog)
    1:     PR_LOG(gDOMLeakPRLog, PR_LOG_DEBUG,
    1:            ("DOMWINDOW %p destroyed", this));
    1: #endif
    1: 
    1:   if (mObserver) {
41540:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
    1:     if (os) {
    1:       os->RemoveObserver(mObserver, NS_IOSERVICE_OFFLINE_STATUS_TOPIC);
37608:       os->RemoveObserver(mObserver, "dom-storage2-changed");
    1:       os->RemoveObserver(mObserver, "dom-storage-changed");
    1:     }
    1: 
    1:     // Drop its reference to this dying window, in case for some bogus reason
    1:     // the object stays around.
    1:     mObserver->Forget();
    1:     NS_RELEASE(mObserver);
    1:   }
    1: 
    1:   if (IsOuterWindow()) {
    1:     // An outer window is destroyed with inner windows still possibly
38439:     // alive, iterate through the inner windows and null out their
38439:     // back pointer to this outer, and pull them out of the list of
38439:     // inner windows.
    1: 
    1:     nsGlobalWindow *w;
    1:     while ((w = (nsGlobalWindow *)PR_LIST_HEAD(this)) != this) {
    1:       NS_ASSERTION(w->mOuterWindow == this, "Uh, bad outer window pointer?");
    1: 
    1:       w->mOuterWindow = nsnull;
    1: 
    1:       PR_REMOVE_AND_INIT_LINK(w);
    1:     }
    1:   } else {
    1:     if (mListenerManager) {
    1:       mListenerManager->Disconnect();
    1:       mListenerManager = nsnull;
    1:     }
    1: 
    1:     // An inner window is destroyed, pull it out of the outer window's
    1:     // list if inner windows.
    1: 
    1:     PR_REMOVE_LINK(this);
    1: 
    1:     // If our outer window's inner window is this window, null out the
    1:     // outer window's reference to this window that's being deleted.
    1:     nsGlobalWindow *outer = GetOuterWindowInternal();
    1:     if (outer && outer->mInnerWindow == this) {
    1:       outer->mInnerWindow = nsnull;
    1:     }
    1:   }
    1: 
    1:   mDocument = nsnull;           // Forces Release
    1:   mDoc = nsnull;
    1: 
    1:   NS_ASSERTION(!mArguments, "mArguments wasn't cleaned up properly!");
38439: 
39378:   CleanUp(PR_TRUE);
38439: 
38439: #ifdef DEBUG
38439:   nsCycleCollector_DEBUG_wasFreed(static_cast<nsIScriptGlobalObject*>(this));
38439: #endif
38439: 
38439:   delete mPendingStorageEventsObsolete;
38439: 
38439:   nsLayoutStatics::Release();
38439: }
38439: 
38439: // static
38439: void
38439: nsGlobalWindow::ShutDown()
38439: {
38439:   NS_IF_RELEASE(sGlobalStorageList);
38439: 
38439:   if (gDumpFile && gDumpFile != stdout) {
38439:     fclose(gDumpFile);
38439:   }
38439:   gDumpFile = nsnull;
38439: }
38439: 
38439: // static
38439: void
38439: nsGlobalWindow::CleanupCachedXBLHandlers(nsGlobalWindow* aWindow)
38439: {
38439:   if (aWindow->mCachedXBLPrototypeHandlers.IsInitialized() &&
38439:       aWindow->mCachedXBLPrototypeHandlers.Count() > 0) {
38439:     aWindow->mCachedXBLPrototypeHandlers.Clear();
38439: 
38439:     nsCOMPtr<nsISupports> supports;
38439:     aWindow->QueryInterface(NS_GET_IID(nsCycleCollectionISupports),
38439:                             getter_AddRefs(supports));
38439:     NS_ASSERTION(supports, "Failed to QI to nsCycleCollectionISupports?!");
38439: 
38439:     nsContentUtils::DropJSObjects(supports);
38439:   }
38439: }
38439: 
38439: void
39378: nsGlobalWindow::MaybeForgiveSpamCount()
39378: {
39378:   if (IsOuterWindow() &&
39378:       IsPopupSpamWindow())
39378:   {
39378:     SetPopupSpamWindow(PR_FALSE);
39378:     --gOpenPopupSpamCount;
39378:     NS_ASSERTION(gOpenPopupSpamCount >= 0,
39378:                  "Unbalanced decrement of gOpenPopupSpamCount");
39378:   }
39378: }
39378: 
39378: void
39378: nsGlobalWindow::CleanUp(PRBool aIgnoreModalDialog)
39378: {
39378:   if (IsOuterWindow() && !aIgnoreModalDialog) {
39378:     nsGlobalWindow* inner = GetCurrentInnerWindowInternal();
39378:     nsCOMPtr<nsIDOMModalContentWindow>
39378:       dlg(do_QueryInterface(static_cast<nsPIDOMWindow*>(inner)));
39378:     if (dlg) {
39378:       // The window we're trying to clean up is the outer window of a
39378:       // modal dialog.  Defer cleanup until the window closes, and let
39378:       // ShowModalDialog take care of calling CleanUp.
39378:       mCallCleanUpAfterModalDialogCloses = PR_TRUE;
39378:       return;
39378:     }
39378:   }
39378: 
39378:   // Guarantee idempotence.
39378:   if (mCleanedUp)
39378:     return;
39378:   mCleanedUp = PR_TRUE;
39378:     
    1:   mNavigator = nsnull;
    1:   mScreen = nsnull;
    1:   mHistory = nsnull;
    1:   mMenubar = nsnull;
    1:   mToolbar = nsnull;
    1:   mLocationbar = nsnull;
    1:   mPersonalbar = nsnull;
    1:   mStatusbar = nsnull;
    1:   mScrollbars = nsnull;
    1:   mLocation = nsnull;
    1:   mFrames = nsnull;
10340:   mApplicationCache = nsnull;
44204:   mIndexedDB = nsnull;
    1: 
    1:   ClearControllers();
    1: 
    1:   mOpener = nsnull;             // Forces Release
    1:   if (mContext) {
 6016: #ifdef DEBUG
 6016:     nsCycleCollector_DEBUG_shouldBeFreed(mContext);
 6016: #endif
    1:     mContext = nsnull;            // Forces Release
    1:   }
    1:   mChromeEventHandler = nsnull; // Forces Release
43679:   mParentTarget = nsnull;
    1: 
    1:   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
    1: 
    1:   if (inner) {
39378:     inner->CleanUp(aIgnoreModalDialog);
    1:   }
    1: 
31738:   if (mHasAcceleration) {
31738:     nsCOMPtr<nsIAccelerometer> ac = do_GetService(NS_ACCELEROMETER_CONTRACTID);
31738:     if (ac)
31738:       ac->RemoveWindowListener(this);
31738:   }
31738: 
43461:   if (mIsChrome && static_cast<nsGlobalChromeWindow*>(this)->mMessageManager) {
43461:     static_cast<nsFrameMessageManager*>(
43461:        static_cast<nsGlobalChromeWindow*>(
43461:          this)->mMessageManager.get())->Disconnect();
43461:   }
43461: 
    1:   PRUint32 scriptIndex;
    1:   NS_STID_FOR_INDEX(scriptIndex) {
    1:     mInnerWindowHolders[scriptIndex] = nsnull;
    1:   }
    1:   mArguments = nsnull;
    1:   mArgumentsLast = nsnull;
33525:   mArgumentsOrigin = nsnull;
    1: 
11622:   CleanupCachedXBLHandlers(this);
11622: 
    1: #ifdef DEBUG
 3233:   nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
    1: #endif
    1: }
    1: 
    1: void
    1: nsGlobalWindow::ClearControllers()
    1: {
    1:   if (mControllers) {
    1:     PRUint32 count;
    1:     mControllers->GetControllerCount(&count);
    1: 
    1:     while (count--) {
    1:       nsCOMPtr<nsIController> controller;
    1:       mControllers->GetControllerAt(count, getter_AddRefs(controller));
    1: 
    1:       nsCOMPtr<nsIControllerContext> context = do_QueryInterface(controller);
    1:       if (context)
    1:         context->SetCommandContext(nsnull);
    1:     }
    1: 
    1:     mControllers = nsnull;
    1:   }
    1: }
    1: 
35152: class ClearScopeEvent : public nsRunnable
35152: {
35152: public:
35152:   ClearScopeEvent(nsGlobalWindow *innerWindow)
35152:     : mInnerWindow(innerWindow) {
35152:   }
35152: 
35152:   NS_IMETHOD Run()
35152:   {
35152:     mInnerWindow->ReallyClearScope(this);
35152:     return NS_OK;
35152:   }
35152: 
35152: private:
35152:   nsRefPtr<nsGlobalWindow> mInnerWindow;
35152: };
35152: 
    1: void
35152: nsGlobalWindow::ReallyClearScope(nsRunnable *aRunnable)
35152: {
35152:   NS_ASSERTION(IsInnerWindow(), "Must be an inner window");
35152: 
35152:   nsIScriptContext *jsscx = GetContextInternal();
35152:   if (jsscx && jsscx->GetExecutingScript()) {
35152:     if (!aRunnable) {
35152:       aRunnable = new ClearScopeEvent(this);
35152:       if (!aRunnable) {
35152:         // The only reason that we clear scope here is to try to prevent
35152:         // leaks. Failing to clear scope might mean that we'll leak more
35152:         // but if we don't have enough memory to allocate a ClearScopeEvent
35152:         // we probably don't have to worry about this anyway.
35152:         return;
35152:       }
35152:     }
35152: 
35152:     NS_DispatchToMainThread(aRunnable);
35152:     return;
35152:   }
35152: 
42340:   NotifyWindowIDDestroyed("inner-window-destroyed");
42340: 
    1:   PRUint32 lang_id;
    1:   NS_STID_FOR_ID(lang_id) {
    1:     // Note that scx comes from the outer window.  If this is an inner
    1:     // window, it may not be the current inner for its outer.
    1:     nsIScriptContext *scx = GetScriptContextInternal(lang_id);
    1:     if (scx)
    1:       scx->ClearScope(mScriptGlobals[NS_STID_INDEX(lang_id)], PR_TRUE);
    1:   }
    1: }
    1: 
35152: void
35152: nsGlobalWindow::FreeInnerObjects(PRBool aClearScope)
35152: {
35152:   NS_ASSERTION(IsInnerWindow(), "Don't free inner objects on an outer window");
35152: 
35152:   // Kill all of the workers for this window.
35152:   nsDOMThreadService* dts = nsDOMThreadService::get();
35152:   if (dts) {
35152:     nsIScriptContext *scx = GetContextInternal();
35152: 
35152:     JSContext *cx = scx ? (JSContext *)scx->GetNativeContext() : nsnull;
35152: 
35152:     // Have to suspend this request here because CancelWorkersForGlobal will
35152:     // lock until the worker has died and that could cause a deadlock.
35152:     JSAutoSuspendRequest asr(cx);
35152: 
35152:     dts->CancelWorkersForGlobal(static_cast<nsIScriptGlobalObject*>(this));
35152:   }
35152: 
35152:   ClearAllTimeouts();
35152: 
35152:   mChromeEventHandler = nsnull;
35152: 
35152:   if (mListenerManager) {
35152:     mListenerManager->Disconnect();
35152:     mListenerManager = nsnull;
35152:   }
35152: 
35152:   if (mDocument) {
35152:     NS_ASSERTION(mDoc, "Why is mDoc null?");
35152: 
35152:     // Remember the document's principal.
35152:     mDocumentPrincipal = mDoc->NodePrincipal();
35152:   }
35152: 
35152: #ifdef DEBUG
35152:   if (mDocument)
35152:     nsCycleCollector_DEBUG_shouldBeFreed(nsCOMPtr<nsISupports>(do_QueryInterface(mDocument)));
35152: #endif
35152: 
35152:   // Make sure that this is called before we null out the document.
35152:   NotifyDOMWindowDestroyed(this);
35152: 
35152:   // Remove our reference to the document and the document principal.
35152:   mDocument = nsnull;
35152:   mDoc = nsnull;
35152: 
35152:   if (mApplicationCache) {
35152:     static_cast<nsDOMOfflineResourceList*>(mApplicationCache.get())->Disconnect();
35152:     mApplicationCache = nsnull;
35152:   }
35152: 
44204:   mIndexedDB = nsnull;
44204: 
35152:   if (aClearScope) {
35152:     // NB: This might not clear our scope, but fire an event to do so
35152:     // instead.
35152:     ReallyClearScope(nsnull);
35152:   }
35152: 
 6774:   if (mDummyJavaPluginOwner) {
 6774:     // Tear down the dummy java plugin.
 6774: 
 6774:     // XXXjst: On a general note, should windows with java stuff in
 6774:     // them ever even make it into the fast-back cache?
 6774: 
 6774:     mDummyJavaPluginOwner->Destroy();
 6774: 
 6774:     mDummyJavaPluginOwner = nsnull;
 6774:   }
 6774: 
11622:   CleanupCachedXBLHandlers(this);
11622: 
    1: #ifdef DEBUG
 3233:   nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
    1: #endif
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsISupports
    1: //*****************************************************************************
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalWindow)
    1: 
40490: DOMCI_DATA(Window, nsGlobalWindow)
40490: 
12033: // QueryInterface implementation for nsGlobalWindow
12033: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsGlobalWindow)
12033:   // Make sure this matches the cast in nsGlobalWindow::FromWrapper()
12033:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIScriptGlobalObject)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMWindowInternal)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMWindow)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMWindow2)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMJSWindow)
12033:   NS_INTERFACE_MAP_ENTRY(nsIScriptGlobalObject)
12033:   NS_INTERFACE_MAP_ENTRY(nsIScriptObjectPrincipal)
12033:   NS_INTERFACE_MAP_ENTRY(nsPIDOMEventTarget)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOM3EventTarget)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSEventTarget)
12033:   NS_INTERFACE_MAP_ENTRY(nsPIDOMWindow)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMViewCSS)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMAbstractView)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMStorageWindow)
12033:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
12033:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
12033:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Window)
12033: NS_INTERFACE_MAP_END
12033: 
12033: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsGlobalWindow, nsIScriptGlobalObject)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsGlobalWindow,
    1:                                            nsIScriptGlobalObject)
    1: 
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGlobalWindow)
 1353:   if (tmp->mDoc && nsCCUncollectableMarker::InGeneration(
30096:                      cb, tmp->mDoc->GetMarkedCCGeneration())) {
25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
 1353:   }
 1353: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mControllers)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mArguments)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mArgumentsLast)
    1: 
    1:   for (PRUint32 i = 0; i < NS_STID_ARRAY_UBOUND; ++i) {      
    1:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptContexts[i])
    1:   }
    1: 
    1:   for (PRUint32 i = 0; i < NS_STID_ARRAY_UBOUND; ++i) {      
    1:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInnerWindowHolders[i])
    1:   }
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOpenerScriptPrincipal)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mListenerManager)
24195: 
24195:   for (nsTimeout* timeout = tmp->FirstTimeout();
24195:        tmp->IsTimeout(timeout);
24195:        timeout = timeout->Next()) {
24195:     cb.NoteNativeChild(timeout, &NS_CYCLE_COLLECTION_NAME(nsTimeout));
24195:   }
24195: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSessionStorage)
10340:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mApplicationCache)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocumentPrincipal)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDoc)
    1: 
    1:   // Traverse stuff from nsPIDOMWindow
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChromeEventHandler)
43679:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mParentTarget)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument)
27191:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFrameElement)
 6774: 
 6774:   // Traverse mDummyJavaPluginOwner
 6774:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDummyJavaPluginOwner)
 6774: 
29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFocusedNode)
29018: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGlobalWindow)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContext)
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mControllers)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mArguments)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mArgumentsLast)
    1: 
    1:   for (PRUint32 i = 0; i < NS_STID_ARRAY_UBOUND; ++i) {      
    1:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mScriptContexts[i])
    1:   }
    1: 
    1:   for (PRUint32 i = 0; i < NS_STID_ARRAY_UBOUND; ++i) {      
    1:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mInnerWindowHolders[i])
    1:   }
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOpenerScriptPrincipal)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mListenerManager)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mSessionStorage)
10340:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mApplicationCache)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocumentPrincipal)
    1: 
    1:   // Unlink stuff from nsPIDOMWindow
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChromeEventHandler)
43679:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mParentTarget)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument)
27191:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFrameElement)
 6774: 
 6774:   // Unlink mDummyJavaPluginOwner
 6774:   if (tmp->mDummyJavaPluginOwner) {
 6774:     tmp->mDummyJavaPluginOwner->Destroy();
 6774:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDummyJavaPluginOwner)
 6774:   }
 6774: 
29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFocusedNode)
29018: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
11622: struct TraceData
11622: {
11622:   TraceData(TraceCallback& aCallback, void* aClosure) :
11622:     callback(aCallback), closure(aClosure) {}
11622: 
11622:   TraceCallback& callback;
11622:   void* closure;
11622: };
11622: 
20261: static PLDHashOperator
11622: TraceXBLHandlers(const void* aKey, void* aData, void* aClosure)
11622: {
11622:   TraceData* data = static_cast<TraceData*>(aClosure);
11622:   data->callback(nsIProgrammingLanguage::JAVASCRIPT, aData, data->closure);
11622:   return PL_DHASH_NEXT;
11622: }
11622: 
11622: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsGlobalWindow)
11622:   if (tmp->mCachedXBLPrototypeHandlers.IsInitialized()) {
11622:     TraceData data(aCallback, aClosure);
11622:     tmp->mCachedXBLPrototypeHandlers.EnumerateRead(TraceXBLHandlers, &data);
11622:   }
11622: NS_IMPL_CYCLE_COLLECTION_TRACE_END
11622: 
11622: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsGlobalWindow)
11622:   nsGlobalWindow::CleanupCachedXBLHandlers(tmp);
11622: NS_IMPL_CYCLE_COLLECTION_ROOT_END
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIScriptGlobalObject
    1: //*****************************************************************************
    1: 
    1: nsresult
    1: nsGlobalWindow::SetScriptContext(PRUint32 lang_id, nsIScriptContext *aScriptContext)
    1: {
    1:   nsresult rv;
    1:   
    1:   PRBool ok = NS_STID_VALID(lang_id);
    1:   NS_ASSERTION(ok, "Invalid programming language ID requested");
    1:   NS_ENSURE_TRUE(ok, NS_ERROR_INVALID_ARG);
    1:   PRUint32 lang_ndx = NS_STID_INDEX(lang_id);
    1: 
    1:   NS_ASSERTION(IsOuterWindow(), "Uh, SetScriptContext() called on inner window!");
    1: 
    1:   if (!aScriptContext)
    1:     NS_WARNING("Possibly early removal of script object, see bug #41608");
    1:   else {
    1:     // should probably assert the context is clean???
    1:     aScriptContext->WillInitializeContext();
    1:     // Bind the script context and the global object
    1:     rv = aScriptContext->InitContext(this);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   NS_ASSERTION(!aScriptContext || !mScriptContexts[lang_ndx],
    1:                "Bad call to SetContext()!");
    1: 
    1:   void *script_glob = nsnull;
    1: 
    1:   if (aScriptContext) {
    1:     if (IsFrame()) {
    1:       // This window is a [i]frame, don't bother GC'ing when the
    1:       // frame's context is destroyed since a GC will happen when the
    1:       // frameset or host document is destroyed anyway.
    1: 
    1:       aScriptContext->SetGCOnDestruction(PR_FALSE);
    1:     }
    1: 
    1:     aScriptContext->DidInitializeContext();
    1:     script_glob = aScriptContext->GetNativeGlobal();
    1:     NS_ASSERTION(script_glob, "GetNativeGlobal returned NULL!");
    1:   }
    1:   // for now, keep mContext real.
    1:   if (lang_id == nsIProgrammingLanguage::JAVASCRIPT) {
    1:     mContext = aScriptContext;
    1:     mJSObject = (JSObject *)script_glob;
    1:   }
    1:   mScriptContexts[lang_ndx] = aScriptContext;
    1:   mScriptGlobals[lang_ndx] = script_glob;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::EnsureScriptEnvironment(PRUint32 aLangID)
    1: {
    1:   FORWARD_TO_OUTER(EnsureScriptEnvironment, (aLangID), NS_ERROR_NOT_INITIALIZED);
    1:   nsresult rv;
    1:  
    1:   PRBool ok = NS_STID_VALID(aLangID);
    1:   NS_ASSERTION(ok, "Invalid programming language ID requested");
    1:   NS_ENSURE_TRUE(ok, NS_ERROR_INVALID_ARG);
    1:   PRUint32 lang_ndx = NS_STID_INDEX(aLangID);
    1: 
    1:   if (mScriptGlobals[lang_ndx])
    1:       return NS_OK; // already initialized for this language.
    1:   nsCOMPtr<nsIScriptRuntime> scriptRuntime;
    1:   rv = NS_GetScriptRuntimeByID(aLangID, getter_AddRefs(scriptRuntime));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIScriptContext> context;
    1:   rv = scriptRuntime->CreateContext(getter_AddRefs(context));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = SetScriptContext(aLangID, context);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // Note that SetScriptContext has taken a reference to the context.
    1:   // If we have arguments, tell the new language about it.
    1:   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
    1:   if (currentInner) {
    1:     // We are being initialized after the document has been setup.
    1:     // Do what would have been done in SetNewDocument had we been around then.
    1:     NS_ASSERTION(!mInnerWindowHolders[lang_ndx], "already have a holder?");
    1:     nsCOMPtr<nsISupports> &holder = mInnerWindowHolders[lang_ndx];
    1:     PRBool isChrome = PR_FALSE; // xxxmarkh - what about this??
    1:     void *&innerGlob = currentInner->mScriptGlobals[lang_ndx];
    1:     rv = context->CreateNativeGlobalForInner(this, isChrome,
    1:                                              &innerGlob,
    1:                                              getter_AddRefs(holder));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     NS_ASSERTION(innerGlob && holder, "Failed to get global and holder");
    1:     rv = context->ConnectToInner(currentInner, mScriptGlobals[lang_ndx]);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     nsCOMPtr<nsIDOMDocument> doc(do_QueryInterface(mDocument));
    1:     if (doc)
    1:       context->DidSetDocument(doc, innerGlob);
    1: 
    1:     if (mArgumentsLast != nsnull) {
    1:       context->SetProperty(innerGlob, "arguments", mArgumentsLast);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsIScriptContext *
    1: nsGlobalWindow::GetScriptContext(PRUint32 lang)
    1: {
    1:   FORWARD_TO_OUTER(GetScriptContext, (lang), nsnull);
    1: 
    1:   PRBool ok = NS_STID_VALID(lang);
    1:   NS_ASSERTION(ok, "Invalid programming language ID requested");
    1:   NS_ENSURE_TRUE(ok, nsnull);
    1: 
    1:   PRUint32 lang_ndx = NS_STID_INDEX(lang);
    1: 
    1:   // for now we are still storing the JS versions in members.  Check the
    1:   // JS elements of our array are still in sync.  Do this each time we are
    1:   // called, as much JS specific code still goes via GetContext
    1:   NS_ASSERTION(mScriptContexts[NS_STID_INDEX(nsIProgrammingLanguage::JAVASCRIPT)] == mContext &&
    1:                mScriptGlobals[NS_STID_INDEX(nsIProgrammingLanguage::JAVASCRIPT)] == mJSObject,
    1:                "JS language contexts are confused");
    1:   return mScriptContexts[lang_ndx];
    1: }
    1: 
    1: void *
    1: nsGlobalWindow::GetScriptGlobal(PRUint32 lang)
    1: {
    1:   PRBool ok = NS_STID_VALID(lang);
    1:   NS_ASSERTION(ok, "Invalid programming language ID requested");
    1:   NS_ENSURE_TRUE(ok, nsnull);
    1: 
    1:   PRUint32 lang_ndx = NS_STID_INDEX(lang);
    1: 
    1:   // for now we are still storing the JS versions in members.  Check the
    1:   // JS elements of our array are still in sync.  Do this each time we are
    1:   // called, as much JS specific code still goes via GetGlobalJSObject
    1:   NS_ASSERTION(mScriptContexts[NS_STID_INDEX(nsIProgrammingLanguage::JAVASCRIPT)] == mContext &&
    1:                mScriptGlobals[NS_STID_INDEX(nsIProgrammingLanguage::JAVASCRIPT)] == mJSObject,
    1:                "JS language contexts are confused");
    1:   return mScriptGlobals[lang_ndx];
    1: }
    1: 
    1: nsIScriptContext *
    1: nsGlobalWindow::GetContext()
    1: {
    1:   FORWARD_TO_OUTER(GetContext, (), nsnull);
    1: 
    1:   // check GetContext is indeed identical to GetScriptContext()
    1:   NS_ASSERTION(mContext == GetScriptContext(nsIProgrammingLanguage::JAVASCRIPT),
    1:                "GetContext confused?");
    1:   return mContext;
    1: }
    1: 
    1: JSObject *
    1: nsGlobalWindow::GetGlobalJSObject()
    1: {
    1:   NS_ASSERTION(mJSObject == GetScriptGlobal(nsIProgrammingLanguage::JAVASCRIPT),
    1:                "GetGlobalJSObject confused?");
    1:   return mJSObject;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsGlobalWindow::WouldReuseInnerWindow(nsIDocument *aNewDocument)
    1: {
    1:   // We reuse the inner window when:
    1:   // a. We are currently at our original document.
    1:   // b. At least one of the following conditions are true:
    1:   // -- We are not currently a content window (i.e., we're currently a chrome
    1:   //    window).
    1:   // -- The new document is the same as the old document. This means that we're
    1:   //    getting called from document.open().
    1:   // -- The new document has the same origin as what we have loaded right now.
    1: 
    1:   if (!mDoc || !aNewDocument) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   if (!mDoc->IsInitialDocument()) {
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   NS_ASSERTION(IsAboutBlank(mDoc->GetDocumentURI()),
    1:                "How'd this happen?");
    1:   
    1:   // Great, we're the original document, check for one of the other
    1:   // conditions.
    1:   if (mDoc == aNewDocument) {
    1:     // aClearScopeHint is false.
    1:     return PR_TRUE;
    1:   }
    1: 
 3286:   PRBool equal;
 3286:   if (NS_SUCCEEDED(mDoc->NodePrincipal()->Equals(aNewDocument->NodePrincipal(),
 3286:                                                  &equal)) &&
 3286:       equal) {
    1:     // The origin is the same.
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(mDocShell));
    1: 
    1:   if (treeItem) {
    1:     PRInt32 itemType = nsIDocShellTreeItem::typeContent;
    1:     treeItem->GetItemType(&itemType);
    1: 
    1:     // If we're a chrome window, then we want to reuse the inner window.
    1:     return itemType == nsIDocShellTreeItem::typeChrome;
    1:   }
    1: 
    1:   // No treeItem: don't reuse the current inner window.
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::SetOpenerScriptPrincipal(nsIPrincipal* aPrincipal)
    1: {
    1:   FORWARD_TO_OUTER_VOID(SetOpenerScriptPrincipal, (aPrincipal));
    1: 
    1:   if (mDoc) {
    1:     if (!mDoc->IsInitialDocument()) {
    1:       // We have a document already, and it's not the original one.  Bail out.
    1:       // Do NOT set mOpenerScriptPrincipal in this case, just to be safe.
    1:       return;
    1:     }
    1:     
    1: #ifdef DEBUG
    1:     // We better have an about:blank document loaded at this point.  Otherwise,
    1:     // something is really weird.
    1:     nsCOMPtr<nsIURI> uri;
    1:     mDoc->NodePrincipal()->GetURI(getter_AddRefs(uri));
    1:     NS_ASSERTION(uri && IsAboutBlank(uri) &&
    1:                  IsAboutBlank(mDoc->GetDocumentURI()),
    1:                  "Unexpected original document");
    1: #endif
    1:     
    1:     // Set the opener principal on our document; given the above check, this
    1:     // is safe.
    1:     mDoc->SetPrincipal(aPrincipal);
    1:   }
    1:     
    1:   mOpenerScriptPrincipal = aPrincipal;
    1: }
    1: 
    1: nsIPrincipal*
    1: nsGlobalWindow::GetOpenerScriptPrincipal()
    1: {
    1:   FORWARD_TO_OUTER(GetOpenerScriptPrincipal, (), nsnull);
    1: 
    1:   return mOpenerScriptPrincipal;
    1: }
    1: 
    1: PopupControlState
    1: PushPopupControlState(PopupControlState aState, PRBool aForce)
    1: {
    1:   PopupControlState oldState = gPopupControlState;
    1: 
    1:   if (aState < gPopupControlState || aForce) {
    1:     gPopupControlState = aState;
    1:   }
    1: 
    1:   return oldState;
    1: }
    1: 
    1: void
    1: PopPopupControlState(PopupControlState aState)
    1: {
    1:   gPopupControlState = aState;
    1: }
    1: 
    1: PopupControlState
    1: nsGlobalWindow::PushPopupControlState(PopupControlState aState,
    1:                                       PRBool aForce) const
    1: {
    1:   return ::PushPopupControlState(aState, aForce);
    1: }
    1: 
    1: void
    1: nsGlobalWindow::PopPopupControlState(PopupControlState aState) const
    1: {
    1:   ::PopPopupControlState(aState);
    1: }
    1: 
    1: PopupControlState
    1: nsGlobalWindow::GetPopupControlState() const
    1: {
    1:   return gPopupControlState;
    1: }
    1: 
    1: #define WINDOWSTATEHOLDER_IID \
    1: {0x0b917c3e, 0xbd50, 0x4683, {0xaf, 0xc9, 0xc7, 0x81, 0x07, 0xae, 0x33, 0x26}}
    1: 
    1: class WindowStateHolder : public nsISupports
    1: {
    1: public:
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(WINDOWSTATEHOLDER_IID)
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   WindowStateHolder(nsGlobalWindow *aWindow,
    1:                     nsCOMPtr<nsISupports> aHolders[],
    1:                     nsNavigator *aNavigator,
    1:                     nsLocation *aLocation,
    1:                     nsIXPConnectJSObjectHolder *aOuterProto);
    1: 
    1:   nsGlobalWindow* GetInnerWindow() { return mInnerWindow; }
    1:   nsISupports* GetInnerWindowHolder(PRUint32 aScriptTypeID)
    1:   { return mInnerWindowHolders[NS_STID_INDEX(aScriptTypeID)]; }
    1: 
    1:   nsNavigator* GetNavigator() { return mNavigator; }
    1:   nsLocation* GetLocation() { return mLocation; }
    1:   nsIXPConnectJSObjectHolder* GetOuterProto() { return mOuterProto; }
    1: 
    1:   void DidRestoreWindow()
    1:   {
    1:     PRUint32 lang_ndx;
    1:     mInnerWindow = nsnull;
    1: 
    1:     NS_STID_FOR_INDEX(lang_ndx) {
    1:         mInnerWindowHolders[lang_ndx] = nsnull;
    1:     }
    1:     mNavigator = nsnull;
    1:     mLocation = nsnull;
    1:     mOuterProto = nsnull;
    1:   }
    1: 
    1: protected:
    1:   ~WindowStateHolder();
    1: 
    1:   nsGlobalWindow *mInnerWindow;
    1:   // We hold onto this to make sure the inner window doesn't go away. The outer
    1:   // window ends up recalculating it anyway.
    1:   nsCOMPtr<nsISupports> mInnerWindowHolders[NS_STID_ARRAY_UBOUND];
    1:   nsRefPtr<nsNavigator> mNavigator;
    1:   nsRefPtr<nsLocation> mLocation;
    1:   nsCOMPtr<nsIXPConnectJSObjectHolder> mOuterProto;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(WindowStateHolder, WINDOWSTATEHOLDER_IID)
    1: 
    1: WindowStateHolder::WindowStateHolder(nsGlobalWindow *aWindow,
    1:                                      nsCOMPtr<nsISupports> aHolders[],
    1:                                      nsNavigator *aNavigator,
    1:                                      nsLocation *aLocation,
    1:                                      nsIXPConnectJSObjectHolder *aOuterProto)
    1:   : mInnerWindow(aWindow),
    1:     mNavigator(aNavigator),
    1:     mLocation(aLocation),
    1:     mOuterProto(aOuterProto)
    1: {
    1:   NS_PRECONDITION(aWindow, "null window");
    1:   NS_PRECONDITION(aWindow->IsInnerWindow(), "Saving an outer window");
    1: 
    1:   PRUint32 lang_ndx;
    1:   NS_STID_FOR_INDEX(lang_ndx) {
    1:     mInnerWindowHolders[lang_ndx] = aHolders[lang_ndx];
    1:   }
29018: 
    1:   aWindow->SuspendTimeouts();
    1: }
    1: 
    1: WindowStateHolder::~WindowStateHolder()
    1: {
    1:   if (mInnerWindow) {
    1:     // This window was left in the bfcache and is now going away. We need to
    1:     // free it up.
    1:     // Note that FreeInnerObjects may already have been called on the
    1:     // inner window if its outer has already had SetDocShell(null)
    1:     // called.  In this case the contexts will all be null and the
    1:     // PR_TRUE for aClearScope won't do anything; this is OK since
    1:     // SetDocShell(null) already did it.
    1:     mInnerWindow->FreeInnerObjects(PR_TRUE);
    1:   }
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(WindowStateHolder, WindowStateHolder)
    1: 
    1: nsresult
    1: nsGlobalWindow::SetNewDocument(nsIDocument* aDocument,
39376:                                nsISupports* aState)
39376: {
41653:   NS_TIME_FUNCTION;
41653: 
39376:   NS_PRECONDITION(mDocumentPrincipal == nsnull,
    1:                   "mDocumentPrincipal prematurely set!");
39376: 
39376:   if (!aDocument) {
39376:     NS_ERROR("SetNewDocument(null) called!");
39376: 
39376:     return NS_ERROR_INVALID_ARG;
39376:   }
39376: 
39376:   if (IsInnerWindow()) {
    1:     if (!mOuterWindow) {
    1:       return NS_ERROR_NOT_INITIALIZED;
    1:     }
    1: 
    1:     // Refuse to set a new document if the call came from an inner
    1:     // window that's not the current inner window.
    1:     if (mOuterWindow->GetCurrentInnerWindow() != this) {
    1:       return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1: 
39376:     return GetOuterWindowInternal()->SetNewDocument(aDocument, aState);
39376:   }
39376: 
39376:   NS_PRECONDITION(IsOuterWindow(), "Must only be called on outer windows");
39376: 
39376:   if (IsFrozen()) {
39376:     // This outer is now getting its first inner, thaw the outer now
39376:     // that it's ready and is getting an inner window.
39376:     Thaw();
    1:   }
    1: 
    1:   NS_ASSERTION(!GetCurrentInnerWindow() ||
    1:                GetCurrentInnerWindow()->GetExtantDocument() == mDocument,
    1:                "Uh, mDocument doesn't match the current inner window "
    1:                "document!");
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsCOMPtr<nsIDocument> oldDoc(do_QueryInterface(mDocument));
    1: 
    1:   nsIScriptContext *scx = GetContextInternal();
    1:   NS_ENSURE_TRUE(scx, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   JSContext *cx = (JSContext *)scx->GetNativeContext();
    1: 
    1:   // clear smartcard events, our document has gone away.
    1:   if (mCrypto) {
    1:     mCrypto->SetEnableSmartCardEvents(PR_FALSE);
    1:   }
    1: 
    1:   if (!mDocument) {
    1:     // First document load.
    1: 
    1:     // Get our private root. If it is equal to us, then we need to
    1:     // attach our global key bindings that handles browser scrolling
    1:     // and other browser commands.
    1:     nsIDOMWindowInternal *internal = nsGlobalWindow::GetPrivateRoot();
    1: 
 3233:     if (internal == static_cast<nsIDOMWindowInternal *>(this)) {
    1:       nsCOMPtr<nsIXBLService> xblService = do_GetService("@mozilla.org/xbl;1");
    1:       if (xblService) {
 1418:         nsCOMPtr<nsPIDOMEventTarget> piTarget =
    1:           do_QueryInterface(mChromeEventHandler);
 1418:         xblService->AttachGlobalKeyHandler(piTarget);
    1:       }
    1:     }
    1:   }
    1: 
42996:   /* No mDocShell means we're already been partially closed down.  When that
42996:      happens, setting status isn't a big requirement, so don't. (Doesn't happen
42996:      under normal circumstances, but bug 49615 describes a case.) */
42996: 
42996:   nsContentUtils::AddScriptRunner(
42996:     NS_NewRunnableMethod(this, &nsGlobalWindow::ClearStatus));
    1: 
    1:   PRBool reUseInnerWindow = WouldReuseInnerWindow(aDocument);
    1: 
    1:   // Remember the old document's principal.
    1:   nsIPrincipal *oldPrincipal = nsnull;
    1:   if (oldDoc) {
    1:     oldPrincipal = oldDoc->NodePrincipal();
    1:   }
    1: 
    1:   // Drop our reference to the navigator object unless we're reusing
    1:   // the existing inner window or the new document is from the same
    1:   // origin as the old document.
    1:   if (!reUseInnerWindow && mNavigator && oldPrincipal) {
 3286:     PRBool equal;
 3286:     rv = oldPrincipal->Equals(aDocument->NodePrincipal(), &equal);
 3286: 
 3286:     if (NS_FAILED(rv) || !equal) {
    1:       // Different origins.  Release the navigator object so it gets
    1:       // recreated for the new document.  The plugins or mime types
    1:       // arrays may have changed. See bug 150087.
    1:       mNavigator->SetDocShell(nsnull);
    1: 
    1:       mNavigator = nsnull;
    1:     }
    1:   }
    1: 
    1:   if (mNavigator && aDocument != oldDoc) {
    1:     // We didn't drop our reference to our old navigator object and
    1:     // we're loading a new document. Notify the navigator object about
    1:     // the new document load so that it can make sure it is ready for
    1:     // the new document.
    1: 
    1:     mNavigator->LoadingNewDocument();
    1:   }
    1: 
    1:   // Set mDocument even if this is an outer window to avoid
    1:   // having to *always* reach into the inner window to find the
    1:   // document.
    1:   mDocument = do_QueryInterface(aDocument);
    1:   mDoc = aDocument;
    1: 
14743: #ifdef DEBUG
14743:   mLastOpenedURI = aDocument->GetDocumentURI();
14743: #endif
14743: 
39376:   PRUint32 st_id; // we loop over all our context/globs lots!
    1:   NS_STID_FOR_ID(st_id) {
    1:     nsIScriptContext *langContext = GetScriptContextInternal(st_id);
    1:     if (langContext)
    1:         langContext->WillInitializeContext();
    1:   }
    1: 
    1:   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
    1: 
    1:   nsRefPtr<nsGlobalWindow> newInnerWindow;
    1: 
    1:   nsCOMPtr<nsIDOMChromeWindow> thisChrome =
 3233:     do_QueryInterface(static_cast<nsIDOMWindow *>(this));
    1:   nsCOMPtr<nsIXPConnectJSObjectHolder> navigatorHolder;
31981:   jsval nav;
    1: 
    1:   PRBool isChrome = PR_FALSE;
    1: 
21376:   nsCxPusher cxPusher;
21376:   if (!cxPusher.Push(cx)) {
21376:     return NS_ERROR_FAILURE;
21376:   }
21376: 
    1:   JSAutoRequest ar(cx);
    1: 
    1:   // Make sure to clear scope on the outer window *before* we
    1:   // initialize the new inner window. If we don't, things
    1:   // (Object.prototype etc) could leak from the old outer to the new
    1:   // inner scope.
    1:   NS_STID_FOR_ID(st_id) {
    1:     nsIScriptContext *langContext = GetScriptContextInternal(st_id);
    1:     if (langContext)
    1:       langContext->ClearScope(mScriptGlobals[NS_STID_INDEX(st_id)],
    1:                               PR_FALSE);
    1:   }
    1: 
    1:   if (reUseInnerWindow) {
    1:     // We're reusing the current inner window.
    1:     NS_ASSERTION(!currentInner->IsFrozen(),
    1:                  "We should never be reusing a shared inner window");
    1:     newInnerWindow = currentInner;
    1: 
    1:     if (aDocument != oldDoc) {
    1:       nsWindowSH::InvalidateGlobalScopePolluter(cx, currentInner->mJSObject);
    1:     }
    1:   } else {
    1:     if (aState) {
    1:       nsCOMPtr<WindowStateHolder> wsh = do_QueryInterface(aState);
    1:       NS_ASSERTION(wsh, "What kind of weird state are you giving me here?");
    1: 
    1:       newInnerWindow = wsh->GetInnerWindow();
    1:       NS_STID_FOR_ID(st_id) {
    1:           mInnerWindowHolders[NS_STID_INDEX(st_id)] = wsh->GetInnerWindowHolder(st_id);
    1:       }
    1: 
    1:       // These assignments addref.
    1:       mNavigator = wsh->GetNavigator();
    1:       mLocation = wsh->GetLocation();
    1: 
    1:       if (mNavigator) {
    1:         // Update mNavigator's docshell pointer now.
    1:         mNavigator->SetDocShell(mDocShell);
    1:         mNavigator->LoadingNewDocument();
    1:       }
    1:     } else {
    1:       if (thisChrome) {
    1:         newInnerWindow = new nsGlobalChromeWindow(this);
    1: 
    1:         isChrome = PR_TRUE;
    1:       } else {
 4040:         if (mIsModalContentWindow) {
 4040:           newInnerWindow = new nsGlobalModalWindow(this);
 4040:         } else {
    1:           newInnerWindow = new nsGlobalWindow(this);
    1:         }
 4040:       }
    1: 
    1:       mLocation = nsnull;
    1:     }
    1: 
    1:     if (!newInnerWindow) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
18754:     if (currentInner && currentInner->mJSObject) {
18754:       if (mNavigator && !aState) {
18754:         // Hold on to the navigator wrapper so that we can set
18754:         // window.navigator in the new window to point to the same
18754:         // object (assuming we didn't change origins etc). See bug
18754:         // 163645 for more on why we need this.
18754: 
18754:         nsIDOMNavigator* navigator =
18754:           static_cast<nsIDOMNavigator*>(mNavigator.get());
31981:         nsContentUtils::WrapNative(cx, currentInner->mJSObject, navigator,
31981:                                    &NS_GET_IID(nsIDOMNavigator), &nav,
18754:                                    getter_AddRefs(navigatorHolder));
18754:       }
18754:     }
18754: 
    1:     if (!aState) {
    1:       // This is redundant if we're restoring from a previous inner window.
    1:       nsIScriptGlobalObject *sgo =
    1:         (nsIScriptGlobalObject *)newInnerWindow.get();
    1: 
    1:       // Freeze the outer window and null out the inner window so
    1:       // that initializing classes on the new inner doesn't end up
    1:       // reaching into the old inner window for classes etc.
    1:       //
    1:       // [This happens with Object.prototype when XPConnect creates
    1:       // a temporary global while initializing classes; the reason
    1:       // being that xpconnect creates the temp global w/o a parent
    1:       // and proto, which makes the JS engine look up classes in
    1:       // cx->globalObject, i.e. this outer window].
    1: 
    1:       mInnerWindow = nsnull;
    1: 
    1:       Freeze();
    1:       mCreatingInnerWindow = PR_TRUE;
    1:       // Every script context we are initialized with must create a
    1:       // new global.
    1:       rv = NS_OK;
    1:       NS_STID_FOR_ID(st_id) {
39376:         PRUint32 st_ndx = NS_STID_INDEX(st_id);
    1:         nsIScriptContext *this_ctx = GetScriptContextInternal(st_id);
    1:         if (this_ctx) {
    1:           void *&newGlobal = newInnerWindow->mScriptGlobals[st_ndx];
    1:           nsCOMPtr<nsISupports> &holder = mInnerWindowHolders[st_ndx];
    1:           rv |= this_ctx->CreateNativeGlobalForInner(sgo, isChrome,
    1:                                                      &newGlobal,
    1:                                                      getter_AddRefs(holder));
    1:           NS_ASSERTION(NS_SUCCEEDED(rv) && newGlobal && holder, 
    1:                       "Failed to get script global and holder");
    1:           if (st_id == nsIProgrammingLanguage::JAVASCRIPT) {
    1:               newInnerWindow->mJSObject = (JSObject *)newGlobal;
    1:           }
    1:         }
    1:       }
    1:       mCreatingInnerWindow = PR_FALSE;
    1:       Thaw();
    1: 
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     if (currentInner && currentInner->mJSObject) {
    1:       PRBool termFuncSet = PR_FALSE;
    1: 
    1:       if (oldDoc == aDocument) {
23153:         // Suspend the current context's request before Pop() resumes the old
23153:         // context's request.
23153:         JSAutoSuspendRequest asr(cx);
23153: 
23153:         // Pop our context here so that we get the correct one for the
23153:         // termination function.
23153:         cxPusher.Pop();
23153: 
23153:         JSContext *oldCx = nsContentUtils::GetCurrentJSContext();
    1: 
    1:         nsIScriptContext *callerScx;
23153:         if (oldCx && (callerScx = GetScriptContextFromJSContext(oldCx))) {
    1:           // We're called from document.open() (and document.open() is
    1:           // called from JS), clear the scope etc in a termination
    1:           // function on the calling context to prevent clearing the
    1:           // calling scope.
    1:           NS_ASSERTION(!currentInner->IsFrozen(),
    1:               "How does this opened window get into session history");
    1: 
23153:           JSAutoRequest ar(oldCx);
    1: 
    1:           callerScx->SetTerminationFunction(ClearWindowScope,
 3233:                                             static_cast<nsIDOMWindow *>
 3233:                                                        (currentInner));
    1: 
    1:           termFuncSet = PR_TRUE;
    1:         }
23153: 
23153:         // Re-push our context.
23153:         cxPusher.Push(cx);
    1:       }
    1: 
    1:       // Don't clear scope on our current inner window if it's going to be
    1:       // held in the bfcache.
    1:       if (!currentInner->IsFrozen()) {
    1:         // Skip the ClearScope if we set a termination function to do
    1:         // it ourselves, later.
    1:         currentInner->FreeInnerObjects(!termFuncSet);
    1:       }
    1:     }
    1: 
    1:     mInnerWindow = newInnerWindow;
    1:   }
    1: 
    1:   if (!aState && !reUseInnerWindow) {
    1:     // Loading a new page and creating a new inner window, *not*
    1:     // restoring from session history.
    1: 
    1:     // InitClassesWithNewWrappedGlobal() (via CreateNativeGlobalForInner)
    1:     // for the new inner window
    1:     // sets the global object in cx to be the new wrapped global. We
    1:     // don't want that, but re-initializing the outer window will
    1:     // fix that for us. And perhaps more importantly, this will
    1:     // ensure that the outer window gets a new prototype so we don't
    1:     // leak prototype properties from the old inner window to the
    1:     // new one.
    1:     NS_STID_FOR_ID(st_id) {
    1:       nsIScriptContext *this_ctx = GetScriptContextInternal(st_id);
    1:       if (st_id == nsIProgrammingLanguage::JAVASCRIPT)
    1:           JS_BeginRequest((JSContext *)this_ctx->GetNativeContext());
    1:       if (this_ctx) {
    1:         this_ctx->InitContext(this);
    1:         // Now that both the the inner and outer windows are initialized
    1:         // let each script context do its magic to hook them together.
    1:         void *glob = mScriptGlobals[NS_STID_INDEX(st_id)];
    1:         this_ctx->ConnectToInner(newInnerWindow, glob);
    1:       }
    1:       if (st_id == nsIProgrammingLanguage::JAVASCRIPT)
    1:           JS_EndRequest((JSContext *)this_ctx->GetNativeContext());
    1:     }
25723: 
25723:     nsCOMPtr<nsIContent> frame = do_QueryInterface(GetFrameElementInternal());
25723:     if (frame && frame->GetOwnerDoc()) {
25723:       nsPIDOMWindow* parentWindow = frame->GetOwnerDoc()->GetWindow();
25723:       if (parentWindow && parentWindow->TimeoutSuspendCount()) {
25723:         SuspendTimeouts(parentWindow->TimeoutSuspendCount());
25723:       }
25723:     }
    1:   }
    1:   // Tell the contexts we have completed setting up the doc.
    1:   NS_STID_FOR_ID(st_id) {
    1:     // Add an extra ref in case we release mContext during GC.
    1:     nsCOMPtr<nsIScriptContext> this_ctx =
    1:                                   GetScriptContextInternal(st_id);
    1:     if (this_ctx) {
    1:       nsCOMPtr<nsIDOMDocument> dd(do_QueryInterface(aDocument));
    1:       this_ctx->DidSetDocument(dd, newInnerWindow->GetScriptGlobal(st_id));
    1:     }
    1:   }
    1: 
    1:   // Now that the prototype is all set up, install the global scope
    1:   // polluter. This must happen after the above prototype fixup. If
    1:   // the GSP was to be installed on the inner window's real
    1:   // prototype (as it would be if this was done before the prototype
    1:   // fixup above) we would end up holding the GSP alive (through
    1:   // XPConnect's internal marking of wrapper prototypes) as long as
    1:   // the inner window was around, and if the GSP had properties on
    1:   // it that held an element alive we'd hold the document alive,
    1:   // which could hold event handlers alive, which hold the context
    1:   // alive etc.
    1: 
    1:   if ((!reUseInnerWindow || aDocument != oldDoc) && !aState) {
    1:     nsCOMPtr<nsIHTMLDocument> html_doc(do_QueryInterface(mDocument));
    1:     nsWindowSH::InstallGlobalScopePolluter(cx, newInnerWindow->mJSObject,
    1:                                            html_doc);
    1:   }
    1: 
39376:   // This code should not be called during shutdown any more (now that
39376:   // we don't ever call SetNewDocument(nsnull), so no need to null
39376:   // check xpc here.
39376:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
39376: 
    1:   if (aState) {
    1:     // Restoring from session history.
    1: 
    1:     nsCOMPtr<WindowStateHolder> wsh = do_QueryInterface(aState);
    1:     NS_ASSERTION(wsh, "What kind of weird state are you giving me here?");
    1: 
    1:     // Restore the prototype for the Window/ChromeWindow class in
    1:     // the outer window scope.
    1:     nsCOMPtr<nsIClassInfo> ci =
    1:       do_QueryInterface((nsIScriptGlobalObject *)this);
    1: 
    1:     rv = xpc->RestoreWrappedNativePrototype(cx, mJSObject, ci,
    1:                                             wsh->GetOuterProto());
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Refresh the outer window's prototype to what it was when the
    1:     // window state was saved. This will make the outer window
    1:     // object (and wrapper) pick up the prototype it had when the
    1:     // window state was saved. This means Object.prototype etc from
    1:     // the old inner will again be on the outer window's prototype
    1:     // chain.
    1: 
    1:     nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
    1:     rv = xpc->GetWrappedNativeOfJSObject(cx, mJSObject,
    1:                                          getter_AddRefs(wrapper));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = wrapper->RefreshPrototype();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   if (aDocument) {
    1:     aDocument->SetScriptGlobalObject(newInnerWindow);
    1:   }
    1: 
    1:   if (!aState) {
    1:     if (reUseInnerWindow) {
    1:       if (newInnerWindow->mDoc != aDocument) {
    1:         newInnerWindow->mDocument = do_QueryInterface(aDocument);
    1:         newInnerWindow->mDoc = aDocument;
    1: 
    1:         // We're reusing the inner window for a new document. In this
    1:         // case we don't clear the inner window's scope, but we must
    1:         // make sure the cached document property gets updated.
    1: 
    1:         // XXXmarkh - tell other languages about this?
    1:         JSAutoRequest ar(cx);
    1:         ::JS_DeleteProperty(cx, currentInner->mJSObject, "document");
    1:       }
    1:     } else {
39402:       rv = newInnerWindow->InnerSetNewDocument(aDocument);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       NS_STID_FOR_ID(st_id) {
    1:         nsIScriptContext *this_ctx = GetScriptContextInternal(st_id);
    1:         if (this_ctx) {
    1:           // Initialize DOM classes etc on the inner window.
    1:           void *glob = newInnerWindow->mScriptGlobals[NS_STID_INDEX(st_id)];
    1:           rv = this_ctx->InitClasses(glob);
    1:           NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:           if (navigatorHolder &&
    1:               st_id == nsIProgrammingLanguage::JAVASCRIPT) {
    1:             // Restore window.navigator onto the new inner window.
    1:             JSAutoRequest ar(cx);
    1: 
    1:             ::JS_DefineProperty(cx, newInnerWindow->mJSObject, "navigator",
31981:                                 nav, nsnull, nsnull,
    1:                                 JSPROP_ENUMERATE | JSPROP_PERMANENT |
    1:                                 JSPROP_READONLY);
12416: 
12416:             // The Navigator's prototype object keeps a reference to the
12416:             // window in which it was first created and can thus cause that
12416:             // window to stay alive for too long. Reparenting it here allows
12416:             // the window to be collected sooner.
12416:             nsIDOMNavigator* navigator =
12416:               static_cast<nsIDOMNavigator*>(mNavigator);
12416: 
12416:             xpc->
31981:               ReparentWrappedNativeIfFound(cx, JSVAL_TO_OBJECT(nav),
31981:                                            newInnerWindow->mJSObject,
12416:                                            navigator,
12416:                                            getter_AddRefs(navigatorHolder));
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (mArguments) {
33525:       newInnerWindow->DefineArgumentsProperty(mArguments);
33525:       newInnerWindow->mArguments = mArguments;
33525:       newInnerWindow->mArgumentsOrigin = mArgumentsOrigin;
33525: 
    1:       mArguments = nsnull;
33525:       mArgumentsOrigin = nsnull;
    1:     }
    1: 
    1:     // Give the new inner window our chrome event handler (since it
    1:     // doesn't have one).
    1:     newInnerWindow->mChromeEventHandler = mChromeEventHandler;
    1:   }
    1: 
    1:   NS_STID_FOR_ID(st_id) {
    1:     // Add an extra ref in case we release mContext during GC.
    1:     nsCOMPtr<nsIScriptContext> this_ctx =
    1:                                   GetScriptContextInternal(st_id);
    1:     if (this_ctx) {
    1:       this_ctx->GC();
    1:       this_ctx->DidInitializeContext();
    1:     }
    1:   }
39376: 
43472:   nsContentUtils::AddScriptRunner(
43472:     NS_NewRunnableMethod(this, &nsGlobalWindow::DispatchDOMWindowCreated));
43472: 
43472:   return NS_OK;
43472: }
43472: 
43472: void
43472: nsGlobalWindow::DispatchDOMWindowCreated()
43472: {
47340:   if (!mDoc || !mDocument) {
47340:     return;
47340:   }
47340: 
43472:   // Fire DOMWindowCreated at chrome event listeners
43472:   nsContentUtils::DispatchChromeEvent(mDoc, mDocument, NS_LITERAL_STRING("DOMWindowCreated"),
43472:                                       PR_TRUE /* bubbles */,
43472:                                       PR_FALSE /* not cancellable */);
43472: 
39377:   nsCOMPtr<nsIObserverService> observerService =
41540:     mozilla::services::GetObserverService();
39377:   if (observerService) {
39377:     nsAutoString origin;
43472:     nsIPrincipal* principal = mDoc->NodePrincipal();
39377:     nsContentUtils::GetUTFOrigin(principal, origin);
39377:     observerService->
39377:       NotifyObservers(static_cast<nsIDOMWindow*>(this),
39377:                       nsContentUtils::IsSystemPrincipal(principal) ?
39377:                         "chrome-document-global-created" :
39377:                         "content-document-global-created",
39377:                       origin.get());
39377:   }
39376: }
39376: 
42996: void
42996: nsGlobalWindow::ClearStatus()
42996: {
42996:   SetStatus(EmptyString());
42996:   SetDefaultStatus(EmptyString());
42996: }
42996: 
39376: nsresult
39402: nsGlobalWindow::InnerSetNewDocument(nsIDocument* aDocument)
39376: {
39376:   NS_PRECONDITION(IsInnerWindow(), "Must only be called on inner windows");
39376: 
39376: #ifdef PR_LOGGING
39376:   if (aDocument && gDOMLeakPRLog &&
39376:       PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
39376:     nsIURI *uri = aDocument->GetDocumentURI();
39376:     nsCAutoString spec;
39376:     if (uri)
39376:       uri->GetSpec(spec);
39376:     PR_LogPrint("DOMWINDOW %p SetNewDocument %s", this, spec.get());
39376:   }
39376: #endif
39376: 
39376:   mDocument = do_QueryInterface(aDocument);
39376:   mDoc = aDocument;
39376:   mLocalStorage = nsnull;
39376:   mSessionStorage = nsnull;
39376: 
39376: #ifdef DEBUG
39376:   mLastOpenedURI = aDocument->GetDocumentURI();
39376: #endif
    1: 
    1:   // Clear our mutation bitfield.
    1:   mMutationBits = 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::SetDocShell(nsIDocShell* aDocShell)
    1: {
    1:   NS_ASSERTION(IsOuterWindow(), "Uh, SetDocShell() called on inner window!");
    1: 
    1:   if (aDocShell == mDocShell)
    1:     return;
    1: 
38439:   PRUint32 lang_id;
38439:   nsIScriptContext *langCtx;
38439:   // SetDocShell(nsnull) means the window is being torn down. Drop our
38439:   // reference to the script context, allowing it to be deleted
38439:   // later. Meanwhile, keep our weak reference to the script object
38439:   // (mJSObject) so that it can be retrieved later (until it is
38439:   // finalized by the JS GC).
38439: 
38439:   if (!aDocShell) {
38439:     NS_ASSERTION(PR_CLIST_IS_EMPTY(&mTimeouts),
38439:                  "Uh, outer window holds timeouts!");
38439: 
38439:     // Call FreeInnerObjects on all inner windows, not just the current
38439:     // one, since some could be held by WindowStateHolder objects that
38439:     // are GC-owned.
38439:     for (nsRefPtr<nsGlobalWindow> inner = (nsGlobalWindow *)PR_LIST_HEAD(this);
38439:          inner != this;
38439:          inner = (nsGlobalWindow*)PR_NEXT_LINK(inner)) {
38439:       NS_ASSERTION(inner->mOuterWindow == this, "bad outer window pointer");
38439:       inner->FreeInnerObjects(PR_TRUE);
38439:     }
38439: 
38439:     // Make sure that this is called before we null out the document.
38439:     NotifyDOMWindowDestroyed(this);
38439: 
42340:     NotifyWindowIDDestroyed("outer-window-destroyed");
42340: 
38439:     nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
38439: 
38439:     if (currentInner) {
38439:       NS_ASSERTION(mDoc, "Must have doc!");
38439:       
38439:       // Remember the document's principal.
38439:       mDocumentPrincipal = mDoc->NodePrincipal();
38439: 
38439:       // Release our document reference
38439:       mDocument = nsnull;
38439:       mDoc = nsnull;
38439:     }
38439: 
38439:     // clear all scopes
38439:     NS_STID_FOR_ID(lang_id) {
38439:       langCtx = mScriptContexts[NS_STID_INDEX(lang_id)];
38439:       if (langCtx)
38439:         langCtx->ClearScope(mScriptGlobals[NS_STID_INDEX(lang_id)], PR_TRUE);
38439:     }
38439: 
38439:     ClearControllers();
38439: 
38439:     mChromeEventHandler = nsnull; // force release now
38439: 
38439:     if (mArguments) { 
38439:       // We got no new document after someone called
38439:       // SetArguments(), drop our reference to the arguments.
38439:       mArguments = nsnull;
38439:       mArgumentsLast = nsnull;
38439:       mArgumentsOrigin = nsnull;
38439:     }
38439: 
38439:     PRUint32 st_ndx;
38439: 
38439:     // Drop holders and tell each context to cleanup and release them now.
38439:     NS_ASSERTION(mContext == mScriptContexts[NS_STID_INDEX(nsIProgrammingLanguage::JAVASCRIPT)],
38439:                  "Contexts confused");
38439:     NS_STID_FOR_INDEX(st_ndx) {
38439:       mInnerWindowHolders[st_ndx] = nsnull;
38439:       langCtx = mScriptContexts[st_ndx];
38439:       if (langCtx) {
38439:         langCtx->GC();
38439:         langCtx->FinalizeContext();
38439:         mScriptContexts[st_ndx] = nsnull;
38439:       }
38439:     }
38439: #ifdef DEBUG
38439:     nsCycleCollector_DEBUG_shouldBeFreed(mContext);
38439:     nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
38439: #endif
38439:     mContext = nsnull; // we nuked it above also
38439:   }
38439: 
    1:   mDocShell = aDocShell;        // Weak Reference
    1: 
    1:   if (mNavigator)
    1:     mNavigator->SetDocShell(aDocShell);
    1:   if (mLocation)
    1:     mLocation->SetDocShell(aDocShell);
    1:   if (mHistory)
    1:     mHistory->SetDocShell(aDocShell);
    1:   if (mFrames)
    1:     mFrames->SetDocShell(aDocShell);
    1:   if (mScreen)
    1:     mScreen->SetDocShell(aDocShell);
    1: 
39378:   if (!mDocShell) {
39378:     MaybeForgiveSpamCount();
39378:     CleanUp(PR_FALSE);
39378:   } else {
    1:     // tell our member elements about the new browserwindow
    1:     if (mMenubar) {
    1:       nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:       GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1:       mMenubar->SetWebBrowserChrome(browserChrome);
    1:     }
    1: 
    1:     // Get our enclosing chrome shell and retrieve its global window impl, so
    1:     // that we can do some forwarding to the chrome document.
    1:     nsCOMPtr<nsIDOMEventTarget> chromeEventHandler;
    1:     mDocShell->GetChromeEventHandler(getter_AddRefs(chromeEventHandler));
    1:     mChromeEventHandler = do_QueryInterface(chromeEventHandler);
    1:     if (!mChromeEventHandler) {
    1:       // We have no chrome event handler. If we have a parent,
    1:       // get our chrome event handler from the parent. If
    1:       // we don't have a parent, then we need to make a new
    1:       // window root object that will function as a chrome event
    1:       // handler and receive all events that occur anywhere inside
    1:       // our window.
    1:       nsCOMPtr<nsIDOMWindow> parentWindow;
    1:       GetParent(getter_AddRefs(parentWindow));
 3233:       if (parentWindow.get() != static_cast<nsIDOMWindow*>(this)) {
    1:         nsCOMPtr<nsPIDOMWindow> piWindow(do_QueryInterface(parentWindow));
    1:         mChromeEventHandler = piWindow->GetChromeEventHandler();
    1:       }
    1:       else NS_NewWindowRoot(this, getter_AddRefs(mChromeEventHandler));
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGlobalWindow::SetOpenerWindow(nsIDOMWindowInternal* aOpener,
    1:                                 PRBool aOriginalOpener)
    1: {
    1:   FORWARD_TO_OUTER_VOID(SetOpenerWindow, (aOpener, aOriginalOpener));
    1: 
    1:   NS_ASSERTION(!aOriginalOpener || !mSetOpenerWindowCalled,
    1:                "aOriginalOpener is true, but not first call to "
    1:                "SetOpenerWindow!");
    1:   NS_ASSERTION(aOpener || !aOriginalOpener,
    1:                "Shouldn't set mHadOriginalOpener if aOpener is null");
    1: 
11416:   mOpener = do_GetWeakReference(aOpener);
21853:   NS_ASSERTION(mOpener || !aOpener, "Opener must support weak references!");
11416: 
    1:   if (aOriginalOpener) {
    1:     mHadOriginalOpener = PR_TRUE;
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   mSetOpenerWindowCalled = PR_TRUE;
    1: #endif
    1: }
    1: 
43680: void
43680: nsGlobalWindow::UpdateParentTarget()
43680: {
43680:   nsCOMPtr<nsIFrameLoaderOwner> flo = do_QueryInterface(mChromeEventHandler);
43680:   if (flo) {
43680:     nsRefPtr<nsFrameLoader> fl = flo->GetFrameLoader();
43680:     if (fl) {
43680:       mParentTarget = fl->GetTabChildGlobalAsEventTarget();
43680:     }
43680:   }
43680:   if (!mParentTarget) {
43680:     mParentTarget = mChromeEventHandler;
43680:   }
43680: }
43680: 
    1: nsresult
    1: nsGlobalWindow::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
  588:   NS_PRECONDITION(IsInnerWindow(), "PreHandleEvent is used on outer window!?");
    1:   static PRUint32 count = 0;
    1:   PRUint32 msg = aVisitor.mEvent->message;
    1: 
    1:   aVisitor.mCanHandle = PR_TRUE;
    1:   aVisitor.mForceContentDispatch = PR_TRUE; //FIXME! Bug 329119
    1:   if ((msg == NS_MOUSE_MOVE) && gEntropyCollector) {
    1:     //Chances are this counter will overflow during the life of the
    1:     //process, but that's OK for our case. Means we get a little
    1:     //more entropy.
    1:     if (count++ % 100 == 0) {
    1:       //Since the high bits seem to be zero's most of the time,
    1:       //let's only take the lowest half of the point structure.
    1:       PRInt16 myCoord[2];
    1: 
    1:       myCoord[0] = aVisitor.mEvent->refPoint.x;
    1:       myCoord[1] = aVisitor.mEvent->refPoint.y;
    1:       gEntropyCollector->RandomUpdate((void*)myCoord, sizeof(myCoord));
    1:       gEntropyCollector->RandomUpdate((void*)&(aVisitor.mEvent->time),
    1:                                       sizeof(PRUint32));
    1:     }
    1:   } else if (msg == NS_RESIZE_EVENT) {
    1:     mIsHandlingResizeEvent = PR_TRUE;
13279:   } else if (msg == NS_MOUSE_BUTTON_DOWN &&
13279:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
13279:     gMouseDown = PR_TRUE;
13279:   } else if (msg == NS_MOUSE_BUTTON_UP &&
13279:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
13279:     gMouseDown = PR_FALSE;
13279:     if (gDragServiceDisabled) {
13279:       nsCOMPtr<nsIDragService> ds =
13279:         do_GetService("@mozilla.org/widget/dragservice;1");
13279:       if (ds) {
13279:         gDragServiceDisabled = PR_FALSE;
13279:         ds->Unsuppress();
13279:       }
13279:     }
    1:   }
    1: 
43680:   aVisitor.mParentTarget = GetParentTarget();
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
    1: {
  588:   NS_PRECONDITION(IsInnerWindow(), "PostHandleEvent is used on outer window!?");
29430: 
29430:   // Return early if there is nothing to do.
29430:   switch (aVisitor.mEvent->message) {
29430:     case NS_RESIZE_EVENT:
29430:     case NS_PAGE_UNLOAD:
29430:     case NS_LOAD:
29430:       break;
29430:     default:
29430:       return NS_OK;
29430:   }
29430: 
    1:   /* mChromeEventHandler and mContext go dangling in the middle of this
    1:    function under some circumstances (events that destroy the window)
    1:    without this addref. */
    1:   nsCOMPtr<nsPIDOMEventTarget> kungFuDeathGrip1(mChromeEventHandler);
    1:   nsCOMPtr<nsIScriptContext> kungFuDeathGrip2(GetContextInternal());
    1: 
    1:   if (aVisitor.mEvent->message == NS_RESIZE_EVENT) {
    1:     mIsHandlingResizeEvent = PR_FALSE;
    1:   } else if (aVisitor.mEvent->message == NS_PAGE_UNLOAD &&
    1:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
    1:     // Execute bindingdetached handlers before we tear ourselves
    1:     // down.
    1:     if (mDocument) {
    1:       NS_ASSERTION(mDoc, "Must have doc");
    1:       mDoc->BindingManager()->ExecuteDetachedHandlers();
    1:     }
    1:     mIsDocumentLoaded = PR_FALSE;
    1:   } else if (aVisitor.mEvent->message == NS_LOAD &&
    1:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
    1:     // This is page load event since load events don't propagate to |window|.
    1:     // @see nsDocument::PreHandleEvent.
    1:     mIsDocumentLoaded = PR_TRUE;
    1: 
    1:     nsCOMPtr<nsIContent> content(do_QueryInterface(GetFrameElementInternal()));
    1:     nsCOMPtr<nsIDocShellTreeItem> treeItem =
    1:       do_QueryInterface(GetDocShell());
    1: 
    1:     PRInt32 itemType = nsIDocShellTreeItem::typeChrome;
    1: 
    1:     if (treeItem) {
    1:       treeItem->GetItemType(&itemType);
    1:     }
    1: 
    1:     if (content && GetParentInternal() &&
    1:         itemType != nsIDocShellTreeItem::typeChrome) {
    1:       // If we're not in chrome, or at a chrome boundary, fire the
    1:       // onload event for the frame element.
    1: 
    1:       nsEventStatus status = nsEventStatus_eIgnore;
    1:       nsEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent), NS_LOAD);
    1:       event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
    1: 
    1:       // Most of the time we could get a pres context to pass in here,
    1:       // but not always (i.e. if this window is not shown there won't
    1:       // be a pres context available). Since we're not firing a GUI
    1:       // event we don't need a pres context anyway so we just pass
    1:       // null as the pres context all the time here.
    1: 
    1:       nsEventDispatcher::Dispatch(content, nsnull, &event, nsnull, &status);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::DispatchDOMEvent(nsEvent* aEvent,
    1:                                  nsIDOMEvent* aDOMEvent,
    1:                                  nsPresContext* aPresContext,
    1:                                  nsEventStatus* aEventStatus)
    1: {
    1:   return
 3233:     nsEventDispatcher::DispatchDOMEvent(static_cast<nsPIDOMWindow*>(this),
    1:                                        aEvent, aDOMEvent, aPresContext,
    1:                                        aEventStatus);
    1: }
    1: 
    1: void
    1: nsGlobalWindow::OnFinalize(PRUint32 aLangID, void *aObject)
    1: {
    1:   if (!NS_STID_VALID(aLangID)) {
    1:     NS_ERROR("Invalid language ID");
    1:     return;
    1:   }
    1:   PRUint32 lang_ndx = NS_STID_INDEX(aLangID);
    1:   if (aObject == mScriptGlobals[lang_ndx]) {
    1:     mScriptGlobals[lang_ndx] = nsnull;
    1:   } else if (mScriptGlobals[lang_ndx]) {
    1:     NS_ERROR("Huh? Script language created more than one wrapper for this global!");
    1:   } else {
    1:     NS_WARNING("Weird, we're finalized with a null language global?");
    1:   }
    1:   if (aLangID==nsIProgrammingLanguage::JAVASCRIPT)
    1:     mJSObject = nsnull; // all relevant assertions and nulling done above.
    1: }
    1: 
    1: void
    1: nsGlobalWindow::SetScriptsEnabled(PRBool aEnabled, PRBool aFireTimeouts)
    1: {
    1:   FORWARD_TO_INNER_VOID(SetScriptsEnabled, (aEnabled, aFireTimeouts));
    1: 
    1:   if (aEnabled && aFireTimeouts) {
    1:     // Scripts are enabled (again?) on this context, run timeouts that
    1:     // fired on this context while scripts were disabled.
41361:     void (nsGlobalWindow::*run)() = &nsGlobalWindow::RunTimeout;
41361:     NS_DispatchToCurrentThread(NS_NewRunnableMethod(this, run));
    1:   }
    1: }
    1: 
    1: nsresult
33525: nsGlobalWindow::SetArguments(nsIArray *aArguments, nsIPrincipal *aOrigin)
33525: {
33525:   FORWARD_TO_OUTER(SetArguments, (aArguments, aOrigin),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   // Hold on to the arguments so that we can re-set them once the next
    1:   // document is loaded.
    1:   mArguments = aArguments;
33525:   mArgumentsOrigin = aOrigin;
33525: 
33525:   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
33525: 
33525:   if (!mIsModalContentWindow) {
    1:     mArgumentsLast = aArguments;
33525:   } else if (currentInner) {
33525:     // SetArguments() is being called on a modal content window that
33525:     // already has an inner window. This can happen when loading
33525:     // javascript: URIs as modal content dialogs. In this case, we'll
33525:     // set up the dialog window, both inner and outer, before we call
33525:     // SetArguments() on the window, so to deal with that, make sure
33525:     // here that the arguments are propagated to the inner window.
33525: 
33525:     currentInner->mArguments = aArguments;
33525:     currentInner->mArgumentsOrigin = aOrigin;
33525:   }
33525: 
33525:   return currentInner ?
33525:     currentInner->DefineArgumentsProperty(aArguments) : NS_OK;
33525: }
33525: 
33525: nsresult
33525: nsGlobalWindow::DefineArgumentsProperty(nsIArray *aArguments)
33525: {
33525:   JSContext *cx;
33525:   nsIScriptContext *ctx = GetOuterWindowInternal()->mContext;
33525:   NS_ENSURE_TRUE(aArguments && ctx &&
33525:                  (cx = (JSContext *)ctx->GetNativeContext()),
33525:                  NS_ERROR_NOT_INITIALIZED);
33525: 
33525:   if (mIsModalContentWindow) {
33525:     // Modal content windows don't have an "arguments" property, they
33525:     // have a "dialogArguments" property which is handled
33525:     // separately. See nsWindowSH::NewResolve().
33525: 
33525:     return NS_OK;
33525:   }
33525: 
33525:   PRUint32 langID;
33525:   NS_STID_FOR_ID(langID) {
33525:     void *glob = GetScriptGlobal(langID);
33525:     ctx = GetScriptContext(langID);
33525:     if (glob && ctx) {
33525:       nsresult rv = ctx->SetProperty(glob, "arguments", aArguments);
33525:       NS_ENSURE_SUCCESS(rv, rv);
33525:     }
33525:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIScriptObjectPrincipal
    1: //*****************************************************************************
    1: 
    1: nsIPrincipal*
    1: nsGlobalWindow::GetPrincipal()
    1: {
    1:   if (mDoc) {
    1:     // If we have a document, get the principal from the document
    1:     return mDoc->NodePrincipal();
    1:   }
    1: 
    1:   if (mDocumentPrincipal) {
    1:     return mDocumentPrincipal;
    1:   }
    1: 
    1:   // If we don't have a principal and we don't have a document we
    1:   // ask the parent window for the principal. This can happen when
    1:   // loading a frameset that has a <frame src="javascript:xxx">, in
    1:   // that case the global window is used in JS before we've loaded
    1:   // a document into the window.
    1: 
    1:   nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
    1:     do_QueryInterface(GetParentInternal());
    1: 
    1:   if (objPrincipal) {
    1:     return objPrincipal->GetPrincipal();
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIDOMWindow
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetDocument(nsIDOMDocument** aDocument)
    1: {
    1:   // This method *should* forward calls to the outer window, but since
    1:   // there's nothing here that *depends* on anything in the outer
    1:   // (GetDocShell() eliminates that dependency), we won't do that to
    1:   // avoid the extra virtual function call.
    1: 
    1:   // lazily instantiate an about:blank document if necessary, and if
    1:   // we have what it takes to do so. Note that domdoc here is the same
    1:   // thing as our mDocument, but we don't have to explicitly set the
    1:   // member variable because the docshell has already called
    1:   // SetNewDocument().
    1:   nsIDocShell *docShell;
    1:   if (!mDocument && (docShell = GetDocShell()))
    1:     nsCOMPtr<nsIDOMDocument> domdoc(do_GetInterface(docShell));
    1: 
    1:   NS_IF_ADDREF(*aDocument = mDocument);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIDOMWindowInternal
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetWindow(nsIDOMWindowInternal** aWindow)
    1: {
    1:   FORWARD_TO_OUTER(GetWindow, (aWindow), NS_ERROR_NOT_INITIALIZED);
    1: 
 3233:   *aWindow = static_cast<nsIDOMWindowInternal *>(this);
    1:   NS_ADDREF(*aWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetSelf(nsIDOMWindowInternal** aWindow)
    1: {
    1:   FORWARD_TO_OUTER(GetSelf, (aWindow), NS_ERROR_NOT_INITIALIZED);
    1: 
 3233:   *aWindow = static_cast<nsIDOMWindowInternal *>(this);
    1:   NS_ADDREF(*aWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetNavigator(nsIDOMNavigator** aNavigator)
    1: {
    1:   FORWARD_TO_OUTER(GetNavigator, (aNavigator), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aNavigator = nsnull;
    1: 
    1:   if (!mNavigator) {
    1:     mNavigator = new nsNavigator(mDocShell);
    1:     if (!mNavigator) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aNavigator = mNavigator);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScreen(nsIDOMScreen** aScreen)
    1: {
    1:   FORWARD_TO_OUTER(GetScreen, (aScreen), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aScreen = nsnull;
    1: 
    1:   if (!mScreen && mDocShell) {
    1:     mScreen = new nsScreen(mDocShell);
    1:     if (!mScreen) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aScreen = mScreen);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetHistory(nsIDOMHistory** aHistory)
    1: {
    1:   FORWARD_TO_OUTER(GetHistory, (aHistory), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aHistory = nsnull;
    1: 
    1:   if (!mHistory && mDocShell) {
    1:     mHistory = new nsHistory(mDocShell);
    1:     if (!mHistory) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aHistory = mHistory);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetParent(nsIDOMWindow** aParent)
    1: {
    1:   FORWARD_TO_OUTER(GetParent, (aParent), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aParent = nsnull;
    1:   if (!mDocShell)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> parent;
    1:   docShellAsItem->GetSameTypeParent(getter_AddRefs(parent));
    1: 
    1:   if (parent) {
    1:     nsCOMPtr<nsIScriptGlobalObject> globalObject(do_GetInterface(parent));
    1:     NS_ENSURE_SUCCESS(CallQueryInterface(globalObject.get(), aParent),
    1:                       NS_ERROR_FAILURE);
    1:   }
    1:   else {
 3233:     *aParent = static_cast<nsIDOMWindowInternal *>(this);
    1:     NS_ADDREF(*aParent);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetTop(nsIDOMWindow** aTop)
    1: {
    1:   FORWARD_TO_OUTER(GetTop, (aTop), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult ret = NS_OK;
    1: 
    1:   *aTop = nsnull;
    1:   if (mDocShell) {
    1:     nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1:     docShellAsItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
    1: 
    1:     if (root) {
    1:       nsCOMPtr<nsIScriptGlobalObject> globalObject(do_GetInterface(root));
    1:       CallQueryInterface(globalObject.get(), aTop);
    1:     }
    1:   }
    1: 
    1:   return ret;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetContent(nsIDOMWindow** aContent)
    1: {
    1:   FORWARD_TO_OUTER(GetContent, (aContent), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aContent = nsnull;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> primaryContent;
    1: 
    1:   if (!nsContentUtils::IsCallerChrome()) {
    1:     // If we're called by non-chrome code, make sure we don't return
    1:     // the primary content window if the calling tab is hidden. In
    1:     // such a case we return the same-type root in the hidden tab,
    1:     // which is "good enough", for now.
    1:     nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(mDocShell));
    1: 
    1:     if (baseWin) {
    1:       PRBool visible = PR_FALSE;
    1:       baseWin->GetVisibility(&visible);
    1: 
    1:       if (!visible) {
    1:         nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(mDocShell));
    1: 
    1:         treeItem->GetSameTypeRootTreeItem(getter_AddRefs(primaryContent));
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (!primaryContent) {
    1:     nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:     GetTreeOwner(getter_AddRefs(treeOwner));
    1:     NS_ENSURE_TRUE(treeOwner, NS_ERROR_FAILURE);
    1: 
    1:     treeOwner->GetPrimaryContentShell(getter_AddRefs(primaryContent));
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMWindowInternal> domWindow(do_GetInterface(primaryContent));
    1:   NS_IF_ADDREF(*aContent = domWindow);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPrompter(nsIPrompt** aPrompt)
    1: {
    1:   FORWARD_TO_OUTER(GetPrompter, (aPrompt), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mDocShell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIPrompt> prompter(do_GetInterface(mDocShell));
    1:   NS_ENSURE_TRUE(prompter, NS_ERROR_NO_INTERFACE);
    1: 
    1:   NS_ADDREF(*aPrompt = prompter);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetMenubar(nsIDOMBarProp** aMenubar)
    1: {
    1:   FORWARD_TO_OUTER(GetMenubar, (aMenubar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aMenubar = nsnull;
    1: 
    1:   if (!mMenubar) {
    1:     mMenubar = new nsMenubarProp();
    1:     if (!mMenubar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:     GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1: 
    1:     mMenubar->SetWebBrowserChrome(browserChrome);
    1:   }
    1: 
    1:   NS_ADDREF(*aMenubar = mMenubar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetToolbar(nsIDOMBarProp** aToolbar)
    1: {
    1:   FORWARD_TO_OUTER(GetToolbar, (aToolbar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aToolbar = nsnull;
    1: 
    1:   if (!mToolbar) {
    1:     mToolbar = new nsToolbarProp();
    1:     if (!mToolbar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:     GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1: 
    1:     mToolbar->SetWebBrowserChrome(browserChrome);
    1:   }
    1: 
    1:   NS_ADDREF(*aToolbar = mToolbar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetLocationbar(nsIDOMBarProp** aLocationbar)
    1: {
    1:   FORWARD_TO_OUTER(GetLocationbar, (aLocationbar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aLocationbar = nsnull;
    1: 
    1:   if (!mLocationbar) {
    1:     mLocationbar = new nsLocationbarProp();
    1:     if (!mLocationbar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:     GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1: 
    1:     mLocationbar->SetWebBrowserChrome(browserChrome);
    1:   }
    1: 
    1:   NS_ADDREF(*aLocationbar = mLocationbar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPersonalbar(nsIDOMBarProp** aPersonalbar)
    1: {
    1:   FORWARD_TO_OUTER(GetPersonalbar, (aPersonalbar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aPersonalbar = nsnull;
    1: 
    1:   if (!mPersonalbar) {
    1:     mPersonalbar = new nsPersonalbarProp();
    1:     if (!mPersonalbar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:     GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1: 
    1:     mPersonalbar->SetWebBrowserChrome(browserChrome);
    1:   }
    1: 
    1:   NS_ADDREF(*aPersonalbar = mPersonalbar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetStatusbar(nsIDOMBarProp** aStatusbar)
    1: {
    1:   FORWARD_TO_OUTER(GetStatusbar, (aStatusbar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aStatusbar = nsnull;
    1: 
    1:   if (!mStatusbar) {
    1:     mStatusbar = new nsStatusbarProp();
    1:     if (!mStatusbar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:     GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1: 
    1:     mStatusbar->SetWebBrowserChrome(browserChrome);
    1:   }
    1: 
    1:   NS_ADDREF(*aStatusbar = mStatusbar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollbars(nsIDOMBarProp** aScrollbars)
    1: {
    1:   FORWARD_TO_OUTER(GetScrollbars, (aScrollbars), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aScrollbars = nsnull;
    1: 
    1:   if (!mScrollbars) {
    1:     mScrollbars = new nsScrollbarsProp(this);
    1:     if (!mScrollbars) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:     GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1: 
    1:     mScrollbars->SetWebBrowserChrome(browserChrome);
    1:   }
    1: 
    1:   NS_ADDREF(*aScrollbars = mScrollbars);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetClosed(PRBool* aClosed)
    1: {
    1:   FORWARD_TO_OUTER(GetClosed, (aClosed), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   // If someone called close(), or if we don't have a docshell, we're
    1:   // closed.
    1:   *aClosed = mIsClosed || !mDocShell;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetFrames(nsIDOMWindowCollection** aFrames)
    1: {
    1:   FORWARD_TO_OUTER(GetFrames, (aFrames), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aFrames = nsnull;
    1: 
    1:   if (!mFrames && mDocShell) {
    1:     mFrames = new nsDOMWindowList(mDocShell);
    1:     if (!mFrames) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
 3233:   *aFrames = static_cast<nsIDOMWindowCollection *>(mFrames);
    1:   NS_IF_ADDREF(*aFrames);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
10340: nsGlobalWindow::GetApplicationCache(nsIDOMOfflineResourceList **aApplicationCache)
10340: {
10340:   FORWARD_TO_INNER(GetApplicationCache, (aApplicationCache), NS_ERROR_UNEXPECTED);
10340: 
10340:   NS_ENSURE_ARG_POINTER(aApplicationCache);
10340: 
10340:   if (!mApplicationCache) {
10340:     nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(GetDocShell()));
10340:     if (!webNav) {
10340:       return NS_ERROR_FAILURE;
10340:     }
10340: 
10340:     nsCOMPtr<nsIURI> uri;
10340:     nsresult rv = webNav->GetCurrentURI(getter_AddRefs(uri));
10340:     NS_ENSURE_SUCCESS(rv, rv);
10340: 
21366:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
10340:     nsCOMPtr<nsIURI> manifestURI;
21366:     nsContentUtils::GetOfflineAppManifest(doc, getter_AddRefs(manifestURI));
10340: 
29226:     nsIScriptContext* scriptContext = GetContext();
29226:     NS_ENSURE_STATE(scriptContext);
29226: 
29226:     nsRefPtr<nsDOMOfflineResourceList> applicationCache =
29226:       new nsDOMOfflineResourceList(manifestURI, uri, this, scriptContext);
29226:     NS_ENSURE_TRUE(applicationCache, NS_ERROR_OUT_OF_MEMORY);
29226: 
29226:     applicationCache->Init();
10340: 
10340:     mApplicationCache = applicationCache;
10340:   }
10340: 
10340:   NS_IF_ADDREF(*aApplicationCache = mApplicationCache);
10340: 
10340:   return NS_OK;
10340: }
10340: 
10340: NS_IMETHODIMP
    1: nsGlobalWindow::GetCrypto(nsIDOMCrypto** aCrypto)
    1: {
    1:   FORWARD_TO_OUTER(GetCrypto, (aCrypto), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mCrypto) {
    1:     mCrypto = do_CreateInstance(kCryptoContractID);
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aCrypto = mCrypto);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPkcs11(nsIDOMPkcs11** aPkcs11)
    1: {
28823:   *aPkcs11 = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetControllers(nsIControllers** aResult)
    1: {
    1:   FORWARD_TO_OUTER(GetControllers, (aResult), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mControllers) {
    1:     nsresult rv;
    1:     mControllers = do_CreateInstance(kXULControllersCID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Add in the default controller
    1:     nsCOMPtr<nsIController> controller = do_CreateInstance(
    1:                                NS_WINDOWCONTROLLER_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     mControllers->InsertControllerAt(0, controller);
    1:     nsCOMPtr<nsIControllerContext> controllerContext = do_QueryInterface(controller);
    1:     if (!controllerContext) return NS_ERROR_FAILURE;
    1: 
 3233:     controllerContext->SetCommandContext(static_cast<nsIDOMWindow*>(this));
    1:   }
    1: 
    1:   *aResult = mControllers;
    1:   NS_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetOpener(nsIDOMWindowInternal** aOpener)
    1: {
    1:   FORWARD_TO_OUTER(GetOpener, (aOpener), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aOpener = nsnull;
11416: 
34496:   nsCOMPtr<nsPIDOMWindow> opener = do_QueryReferent(mOpener);
11416:   if (!opener) {
11416:     return NS_OK;
11416:   }
11416: 
    1:   // First, check if we were called from a privileged chrome script
    1:   if (nsContentUtils::IsCallerTrustedForRead()) {
11416:     NS_ADDREF(*aOpener = opener);
    1:     return NS_OK;
    1:   }
    1: 
34496:   nsCOMPtr<nsPIDOMWindow> openerPwin(do_QueryInterface(opener));
34496:   if (!openerPwin) {
34496:     return NS_OK;
34496:   }
34496: 
34496:   // First, ensure that we're not handing back a chrome window.
34496:   nsGlobalWindow *win = static_cast<nsGlobalWindow *>(openerPwin.get());
34496:   if (win->IsChromeWindow()) {
34496:     return NS_OK;
34496:   }
34496: 
    1:   // We don't want to reveal the opener if the opener is a mail window,
    1:   // because opener can be used to spoof the contents of a message (bug 105050).
    1:   // So, we look in the opener's root docshell to see if it's a mail window.
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
    1:     do_QueryInterface(openerPwin->GetDocShell());
    1: 
    1:   if (docShellAsItem) {
    1:     nsCOMPtr<nsIDocShellTreeItem> openerRootItem;
    1:     docShellAsItem->GetRootTreeItem(getter_AddRefs(openerRootItem));
    1:     nsCOMPtr<nsIDocShell> openerRootDocShell(do_QueryInterface(openerRootItem));
    1:     if (openerRootDocShell) {
    1:       PRUint32 appType;
    1:       nsresult rv = openerRootDocShell->GetAppType(&appType);
    1:       if (NS_SUCCEEDED(rv) && appType != nsIDocShell::APP_TYPE_MAIL) {
11416:         *aOpener = opener;
    1:       }
    1:     }
    1:   }
34496: 
    1:   NS_IF_ADDREF(*aOpener);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetOpener(nsIDOMWindowInternal* aOpener)
    1: {
    1:   // check if we were called from a privileged chrome script.
    1:   // If not, opener is settable only to null.
    1:   if (aOpener && !nsContentUtils::IsCallerTrustedForWrite()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   SetOpenerWindow(aOpener, PR_FALSE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetStatus(nsAString& aStatus)
    1: {
    1:   FORWARD_TO_OUTER(GetStatus, (aStatus), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   aStatus = mStatus;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetStatus(const nsAString& aStatus)
    1: {
    1:   FORWARD_TO_OUTER(SetStatus, (aStatus), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
    1:    * If caller is not chrome and dom.disable_window_status_change is true,
    1:    * prevent setting window.status by exiting early
    1:    */
    1: 
    1:   if (!CanSetProperty("dom.disable_window_status_change")) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   mStatus = aStatus;
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:   GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1:   if(browserChrome) {
    1:     browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_SCRIPT,
    1:                              PromiseFlatString(aStatus).get());
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetDefaultStatus(nsAString& aDefaultStatus)
    1: {
    1:   FORWARD_TO_OUTER(GetDefaultStatus, (aDefaultStatus),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   aDefaultStatus = mDefaultStatus;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetDefaultStatus(const nsAString& aDefaultStatus)
    1: {
    1:   FORWARD_TO_OUTER(SetDefaultStatus, (aDefaultStatus),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
    1:    * If caller is not chrome and dom.disable_window_status_change is true,
    1:    * prevent setting window.defaultStatus by exiting early
    1:    */
    1: 
    1:   if (!CanSetProperty("dom.disable_window_status_change")) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   mDefaultStatus = aDefaultStatus;
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:   GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1:   if (browserChrome) {
    1:     browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_SCRIPT_DEFAULT,
    1:                              PromiseFlatString(aDefaultStatus).get());
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetName(nsAString& aName)
    1: {
    1:   FORWARD_TO_OUTER(GetName, (aName), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsXPIDLString name;
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   if (docShellAsItem)
    1:     docShellAsItem->GetName(getter_Copies(name));
    1: 
    1:   aName.Assign(name);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetName(const nsAString& aName)
    1: {
    1:   FORWARD_TO_OUTER(SetName, (aName), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult result = NS_OK;
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   if (docShellAsItem)
    1:     result = docShellAsItem->SetName(PromiseFlatString(aName).get());
    1:   return result;
    1: }
    1: 
24816: // Helper functions used by many methods below.
24816: PRInt32
24816: nsGlobalWindow::DevToCSSIntPixels(PRInt32 px)
24816: {
24816:   if (!mDocShell)
24816:     return px; // assume 1:1
24816: 
39823:   nsRefPtr<nsPresContext> presContext;
24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
24816:   if (!presContext)
24816:     return px;
24816: 
29322:   return presContext->DevPixelsToIntCSSPixels(px);
24816: }
24816: 
24816: PRInt32
24816: nsGlobalWindow::CSSToDevIntPixels(PRInt32 px)
24816: {
24816:   if (!mDocShell)
24816:     return px; // assume 1:1
24816: 
39823:   nsRefPtr<nsPresContext> presContext;
24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
24816:   if (!presContext)
24816:     return px;
24816: 
29322:   return presContext->CSSPixelsToDevPixels(px);
24816: }
24816: 
24816: nsIntSize
24816: nsGlobalWindow::DevToCSSIntPixels(nsIntSize px)
24816: {
24816:   if (!mDocShell)
24816:     return px; // assume 1:1
24816: 
39823:   nsRefPtr<nsPresContext> presContext;
24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
24816:   if (!presContext)
24816:     return px;
24816: 
24816:   return nsIntSize(
29322:       presContext->DevPixelsToIntCSSPixels(px.width),
29322:       presContext->DevPixelsToIntCSSPixels(px.height));
24816: }
24816: 
24816: nsIntSize
24816: nsGlobalWindow::CSSToDevIntPixels(nsIntSize px)
24816: {
24816:   if (!mDocShell)
24816:     return px; // assume 1:1
24816: 
39823:   nsRefPtr<nsPresContext> presContext;
24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
24816:   if (!presContext)
24816:     return px;
24816: 
24816:   return nsIntSize(
29322:     presContext->CSSPixelsToDevPixels(px.width),
29322:     presContext->CSSPixelsToDevPixels(px.height));
24816: }
24816: 
24816: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetInnerWidth(PRInt32* aInnerWidth)
    1: {
    1:   FORWARD_TO_OUTER(GetInnerWidth, (aInnerWidth), NS_ERROR_NOT_INITIALIZED);
    1: 
  334:   NS_ENSURE_STATE(mDocShell);
  334: 
    1:   EnsureSizeUpToDate();
    1: 
    1:   nsCOMPtr<nsIBaseWindow> docShellWin(do_QueryInterface(mDocShell));
39823:   nsRefPtr<nsPresContext> presContext;
28807:   mDocShell->GetPresContext(getter_AddRefs(presContext));
28807: 
28807:   if (docShellWin && presContext) {
28807:     PRInt32 width, notused;
  334:     docShellWin->GetSize(&width, &notused);
28807:     *aInnerWidth = nsPresContext::
28807:       AppUnitsToIntCSSPixels(presContext->DevPixelsToAppUnits(width));
28807:   } else {
28807:     *aInnerWidth = 0;
28807:   }
28807: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetInnerWidth(PRInt32 aInnerWidth)
    1: {
    1:   FORWARD_TO_OUTER(SetInnerWidth, (aInnerWidth), NS_ERROR_NOT_INITIALIZED);
    1: 
  334:   NS_ENSURE_STATE(mDocShell);
  334: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.innerWidth by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:   NS_ENSURE_TRUE(treeOwner, NS_ERROR_FAILURE);
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(&aInnerWidth, nsnull),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   PRInt32 width = CSSToDevIntPixels(aInnerWidth);
  334: 
    1:   nsCOMPtr<nsIBaseWindow> docShellAsWin(do_QueryInterface(mDocShell));
    1:   PRInt32 notused, height = 0;
    1:   docShellAsWin->GetSize(&notused, &height);
  334: 
  334:   NS_ENSURE_SUCCESS(treeOwner->SizeShellTo(docShellAsItem, width, height),
    1:                     NS_ERROR_FAILURE);
 7838: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetInnerHeight(PRInt32* aInnerHeight)
    1: {
    1:   FORWARD_TO_OUTER(GetInnerHeight, (aInnerHeight), NS_ERROR_NOT_INITIALIZED);
    1: 
  334:   NS_ENSURE_STATE(mDocShell);
  334: 
    1:   EnsureSizeUpToDate();
    1: 
    1:   nsCOMPtr<nsIBaseWindow> docShellWin(do_QueryInterface(mDocShell));
39823:   nsRefPtr<nsPresContext> presContext;
28807:   mDocShell->GetPresContext(getter_AddRefs(presContext));
28807: 
28807:   if (docShellWin && presContext) {
28807:     PRInt32 height, notused;
  334:     docShellWin->GetSize(&notused, &height);
28807:     *aInnerHeight = nsPresContext::
28807:       AppUnitsToIntCSSPixels(presContext->DevPixelsToAppUnits(height));
28807:   } else {
28807:     *aInnerHeight = 0;
28807:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetInnerHeight(PRInt32 aInnerHeight)
    1: {
    1:   FORWARD_TO_OUTER(SetInnerHeight, (aInnerHeight), NS_ERROR_NOT_INITIALIZED);
    1: 
  334:   NS_ENSURE_STATE(mDocShell);
  334: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.innerHeight by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:   NS_ENSURE_TRUE(treeOwner, NS_ERROR_FAILURE);
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(nsnull, &aInnerHeight),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   PRInt32 height = CSSToDevIntPixels(aInnerHeight);
  334: 
    1:   nsCOMPtr<nsIBaseWindow> docShellAsWin(do_QueryInterface(mDocShell));
    1:   PRInt32 width = 0, notused;
    1:   docShellAsWin->GetSize(&width, &notused);
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwner->SizeShellTo(docShellAsItem, width, height),
    1:                     NS_ERROR_FAILURE);
 7838: 
    1:   return NS_OK;
    1: }
    1: 
13806: nsresult
13806: nsGlobalWindow::GetOuterSize(nsIntSize* aSizeCSSPixels)
13806: {
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   nsGlobalWindow* rootWindow =
 3233:     static_cast<nsGlobalWindow *>(GetPrivateRoot());
    1:   if (rootWindow) {
    1:     rootWindow->FlushPendingNotifications(Flush_Layout);
    1:   }
13806: 
13806:   nsIntSize sizeDevPixels;
13806:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetSize(&sizeDevPixels.width,
13806:                                             &sizeDevPixels.height),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   *aSizeCSSPixels = DevToCSSIntPixels(sizeDevPixels);
13806:   return NS_OK;
13806: }
13806: 
13806: NS_IMETHODIMP
13806: nsGlobalWindow::GetOuterWidth(PRInt32* aOuterWidth)
13806: {
13806:   FORWARD_TO_OUTER(GetOuterWidth, (aOuterWidth), NS_ERROR_NOT_INITIALIZED);
13806: 
13806:   nsIntSize sizeCSSPixels;
13806:   nsresult rv = GetOuterSize(&sizeCSSPixels);
13806:   NS_ENSURE_SUCCESS(rv, rv);
13806: 
13806:   *aOuterWidth = sizeCSSPixels.width;
13806:   return NS_OK;
13806: }
13806: 
13806: NS_IMETHODIMP
13806: nsGlobalWindow::GetOuterHeight(PRInt32* aOuterHeight)
13806: {
13806:   FORWARD_TO_OUTER(GetOuterHeight, (aOuterHeight), NS_ERROR_NOT_INITIALIZED);
13806: 
13806:   nsIntSize sizeCSSPixels;
13806:   nsresult rv = GetOuterSize(&sizeCSSPixels);
13806:   NS_ENSURE_SUCCESS(rv, rv);
13806: 
13806:   *aOuterHeight = sizeCSSPixels.height;
13806:   return NS_OK;
13806: }
13806: 
13806: nsresult
13806: nsGlobalWindow::SetOuterSize(PRInt32 aLengthCSSPixels, PRBool aIsWidth)
13806: {
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.outerWidth by exiting early
    1:    */
    1: 
30667:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
13806:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(
24816:                         aIsWidth ? &aLengthCSSPixels : nsnull,
24816:                         aIsWidth ? nsnull : &aLengthCSSPixels),
    1:                     NS_ERROR_FAILURE);
    1: 
13806:   PRInt32 width, height;
13806:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetSize(&width, &height), NS_ERROR_FAILURE);
13806: 
24816:   PRInt32 lengthDevPixels = CSSToDevIntPixels(aLengthCSSPixels);
13806:   if (aIsWidth) {
13806:     width = lengthDevPixels;
13806:   } else {
13806:     height = lengthDevPixels;
13806:   }
13806:   return treeOwnerAsWin->SetSize(width, height, PR_TRUE);    
13806: }
13806: 
13806: NS_IMETHODIMP
13806: nsGlobalWindow::SetOuterWidth(PRInt32 aOuterWidth)
13806: {
13806:   FORWARD_TO_OUTER(SetOuterWidth, (aOuterWidth), NS_ERROR_NOT_INITIALIZED);
13806: 
13806:   return SetOuterSize(aOuterWidth, PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetOuterHeight(PRInt32 aOuterHeight)
    1: {
    1:   FORWARD_TO_OUTER(SetOuterHeight, (aOuterHeight), NS_ERROR_NOT_INITIALIZED);
    1: 
13806:   return SetOuterSize(aOuterHeight, PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScreenX(PRInt32* aScreenX)
    1: {
    1:   FORWARD_TO_OUTER(GetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
24816:   PRInt32 x, y;
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   *aScreenX = DevToCSSIntPixels(x);
    1:   return NS_OK;
    1: }
    1: 
30882: nsRect
30882: nsGlobalWindow::GetInnerScreenRect()
30882: {
30882:   if (!mDocShell)
30882:     return nsRect();
30882: 
30882:   nsGlobalWindow* rootWindow =
30882:     static_cast<nsGlobalWindow*>(GetPrivateRoot());
30882:   if (rootWindow) {
30882:     rootWindow->FlushPendingNotifications(Flush_Layout);
30882:   }
30882: 
30882:   nsCOMPtr<nsIPresShell> presShell;
30882:   mDocShell->GetPresShell(getter_AddRefs(presShell));
30882:   if (!presShell)
30882:     return nsRect();
30882:   nsIFrame* rootFrame = presShell->GetRootFrame();
30882:   if (!rootFrame)
30882:     return nsRect();
30882: 
30882:   return rootFrame->GetScreenRectInAppUnits();
30882: }
30882: 
30882: NS_IMETHODIMP
30882: nsGlobalWindow::GetMozInnerScreenX(float* aScreenX)
30882: {
30882:   FORWARD_TO_OUTER(GetMozInnerScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
30882: 
30882:   nsRect r = GetInnerScreenRect();
30882:   *aScreenX = nsPresContext::AppUnitsToFloatCSSPixels(r.x);
30882:   return NS_OK;
30882: }
30882: 
30882: NS_IMETHODIMP
30882: nsGlobalWindow::GetMozInnerScreenY(float* aScreenY)
30882: {
30882:   FORWARD_TO_OUTER(GetMozInnerScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
30882: 
30882:   nsRect r = GetInnerScreenRect();
30882:   *aScreenY = nsPresContext::AppUnitsToFloatCSSPixels(r.y);
30882:   return NS_OK;
30882: }
30882: 
30882: NS_IMETHODIMP
42240: nsGlobalWindow::GetMozPaintCount(PRUint64* aResult)
42240: {
42240:   FORWARD_TO_OUTER(GetMozPaintCount, (aResult), NS_ERROR_NOT_INITIALIZED);
42240: 
42240:   *aResult = 0;
42240: 
42240:   if (!mDocShell)
42240:     return NS_OK;
42240: 
42240:   nsCOMPtr<nsIPresShell> presShell;
42240:   mDocShell->GetPresShell(getter_AddRefs(presShell));
42240:   if (!presShell)
42240:     return NS_OK;
42240: 
42240:   *aResult = presShell->GetPaintCount();
42240:   return NS_OK;
42240: }
42240: 
42240: NS_IMETHODIMP
    1: nsGlobalWindow::SetScreenX(PRInt32 aScreenX)
    1: {
    1:   FORWARD_TO_OUTER(SetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.screenX by exiting early
    1:    */
    1: 
30667:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aScreenX, nsnull),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 x, y;
    1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   x = CSSToDevIntPixels(aScreenX);
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScreenY(PRInt32* aScreenY)
    1: {
    1:   FORWARD_TO_OUTER(GetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
24816:   PRInt32 x, y;
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   *aScreenY = DevToCSSIntPixels(y);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetScreenY(PRInt32 aScreenY)
    1: {
    1:   FORWARD_TO_OUTER(SetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.screenY by exiting early
    1:    */
    1: 
30667:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(nsnull, &aScreenY),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 x, y;
    1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   y = CSSToDevIntPixels(aScreenY);
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
24816: // NOTE: Arguments to this function should have values scaled to
24816: // CSS pixels, not device pixels.
    1: nsresult
    1: nsGlobalWindow::CheckSecurityWidthAndHeight(PRInt32* aWidth, PRInt32* aHeight)
    1: {
 3799: #ifdef MOZ_XUL
  677:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
  677:     // if attempting to resize the window, hide any open popups
 3129:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
11414:     nsContentUtils::HidePopupsInDocument(doc);
  677:   }
 3799: #endif
  677: 
    1:   // This one is easy. Just ensure the variable is greater than 100;
    1:   if ((aWidth && *aWidth < 100) || (aHeight && *aHeight < 100)) {
    1:     // Check security state for use in determing window dimensions
    1: 
    1:     if (!nsContentUtils::IsCallerTrustedForWrite()) {
    1:       //sec check failed
    1:       if (aWidth && *aWidth < 100) {
    1:         *aWidth = 100;
    1:       }
    1:       if (aHeight && *aHeight < 100) {
    1:         *aHeight = 100;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
24816: // NOTE: Arguments to this function should have values scaled to
24816: // CSS pixels, not device pixels.
    1: nsresult
    1: nsGlobalWindow::CheckSecurityLeftAndTop(PRInt32* aLeft, PRInt32* aTop)
    1: {
    1:   // This one is harder. We have to get the screen size and window dimensions.
    1: 
    1:   // Check security state for use in determing window dimensions
    1: 
    1:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
 3799: #ifdef MOZ_XUL
  677:     // if attempting to move the window, hide any open popups
 3129:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
11414:     nsContentUtils::HidePopupsInDocument(doc);
 3799: #endif
  677: 
    1:     nsGlobalWindow* rootWindow =
 3233:       static_cast<nsGlobalWindow*>(GetPrivateRoot());
    1:     if (rootWindow) {
    1:       rootWindow->FlushPendingNotifications(Flush_Layout);
    1:     }
    1: 
    1:     nsCOMPtr<nsIBaseWindow> treeOwner;
    1:     GetTreeOwner(getter_AddRefs(treeOwner));
39648: 
39648:     nsCOMPtr<nsIDOMScreen> screen;
39648:     GetScreen(getter_AddRefs(screen));
39648: 
39648:     if (treeOwner && screen) {
39648:       PRInt32 screenLeft, screenTop, screenWidth, screenHeight;
39648:       PRInt32 winLeft, winTop, winWidth, winHeight;
39648: 
39648:       // Get the window size
    1:       treeOwner->GetPositionAndSize(&winLeft, &winTop, &winWidth, &winHeight);
    1: 
24816:       // convert those values to CSS pixels
24816:       // XXX four separate retrievals of the prescontext
24816:       winLeft   = DevToCSSIntPixels(winLeft);
24816:       winTop    = DevToCSSIntPixels(winTop);
24816:       winWidth  = DevToCSSIntPixels(winWidth);
24816:       winHeight = DevToCSSIntPixels(winHeight);
24816: 
    1:       // Get the screen dimensions
    1:       // XXX This should use nsIScreenManager once it's fully fleshed out.
    1:       screen->GetAvailLeft(&screenLeft);
    1:       screen->GetAvailWidth(&screenWidth);
    1:       screen->GetAvailHeight(&screenHeight);
    1: #if defined(XP_MAC) || defined(XP_MACOSX)
    1:       /* The mac's coordinate system is different from the assumed Windows'
    1:          system. It offsets by the height of the menubar so that a window
    1:          placed at (0,0) will be entirely visible. Unfortunately that
    1:          correction is made elsewhere (in Widget) and the meaning of
    1:          the Avail... coordinates is overloaded. Here we allow a window
    1:          to be placed at (0,0) because it does make sense to do so.
    1:       */
    1:       screen->GetTop(&screenTop);
    1: #else
    1:       screen->GetAvailTop(&screenTop);
    1: #endif
39648: 
    1:       if (aLeft) {
    1:         if (screenLeft+screenWidth < *aLeft+winWidth)
    1:           *aLeft = screenLeft+screenWidth - winWidth;
    1:         if (screenLeft > *aLeft)
    1:           *aLeft = screenLeft;
    1:       }
    1:       if (aTop) {
    1:         if (screenTop+screenHeight < *aTop+winHeight)
    1:           *aTop = screenTop+screenHeight - winHeight;
    1:         if (screenTop > *aTop)
    1:           *aTop = screenTop;
    1:       }
    1:     } else {
    1:       if (aLeft)
    1:         *aLeft = 0;
    1:       if (aTop)
    1:         *aTop = 0;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPageXOffset(PRInt32* aPageXOffset)
    1: {
    1:   return GetScrollX(aPageXOffset);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPageYOffset(PRInt32* aPageYOffset)
    1: {
    1:   return GetScrollY(aPageYOffset);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::GetScrollMaxXY(PRInt32* aScrollMaxX, PRInt32* aScrollMaxY)
    1: {
    1:   FORWARD_TO_OUTER(GetScrollMaxXY, (aScrollMaxX, aScrollMaxY),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063:   if (!sf)
37063:     return NS_OK;
37063: 
37063:   nsRect scrollRange = sf->GetScrollRange();
    1: 
    1:   if (aScrollMaxX)
38330:     *aScrollMaxX = NS_MAX(0,
37063:       (PRInt32)floor(nsPresContext::AppUnitsToFloatCSSPixels(scrollRange.XMost())));
    1:   if (aScrollMaxY)
38330:     *aScrollMaxY = NS_MAX(0,
37063:       (PRInt32)floor(nsPresContext::AppUnitsToFloatCSSPixels(scrollRange.YMost())));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollMaxX(PRInt32* aScrollMaxX)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScrollMaxX);
    1:   *aScrollMaxX = 0;
    1:   return GetScrollMaxXY(aScrollMaxX, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollMaxY(PRInt32* aScrollMaxY)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScrollMaxY);
    1:   *aScrollMaxY = 0;
    1:   return GetScrollMaxXY(nsnull, aScrollMaxY);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::GetScrollXY(PRInt32* aScrollX, PRInt32* aScrollY,
    1:                             PRBool aDoFlush)
    1: {
    1:   FORWARD_TO_OUTER(GetScrollXY, (aScrollX, aScrollY, aDoFlush),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (aDoFlush) {
    1:     FlushPendingNotifications(Flush_Layout);
    1:   } else {
    1:     EnsureSizeUpToDate();
    1:   }
    1: 
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063:   if (!sf)
37063:     return NS_OK;
37063: 
37063:   nsPoint scrollPos = sf->GetScrollPosition();
37063:   if (scrollPos != nsPoint(0,0) && !aDoFlush) {
    1:     // Oh, well.  This is the expensive case -- the window is scrolled and we
    1:     // didn't actually flush yet.  Repeat, but with a flush, since the content
    1:     // may get shorter and hence our scroll position may decrease.
    1:     return GetScrollXY(aScrollX, aScrollY, PR_TRUE);
    1:   }
    1: 
    1:   if (aScrollX)
37063:     *aScrollX = nsPresContext::AppUnitsToIntCSSPixels(scrollPos.x);
    1:   if (aScrollY)
37063:     *aScrollY = nsPresContext::AppUnitsToIntCSSPixels(scrollPos.y);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollX(PRInt32* aScrollX)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScrollX);
    1:   *aScrollX = 0;
    1:   return GetScrollXY(aScrollX, nsnull, PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollY(PRInt32* aScrollY)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScrollY);
    1:   *aScrollY = 0;
    1:   return GetScrollXY(nsnull, aScrollY, PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetLength(PRUint32* aLength)
    1: {
    1:   nsCOMPtr<nsIDOMWindowCollection> frames;
    1:   if (NS_SUCCEEDED(GetFrames(getter_AddRefs(frames))) && frames) {
    1:     return frames->GetLength(aLength);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: PRBool
    1: nsGlobalWindow::DispatchCustomEvent(const char *aEventName)
    1: {
    1:   PRBool defaultActionEnabled = PR_TRUE;
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
    1:   nsContentUtils::DispatchTrustedEvent(doc,
 3233:                                        static_cast<nsIScriptGlobalObject*>(this),
    1:                                        NS_ConvertASCIItoUTF16(aEventName),
    1:                                        PR_TRUE, PR_TRUE, &defaultActionEnabled);
    1: 
    1:   return defaultActionEnabled;
    1: }
    1: 
    1: static already_AddRefed<nsIDocShellTreeItem>
    1: GetCallerDocShellTreeItem()
    1: {
18868:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
    1:   nsIDocShellTreeItem *callerItem = nsnull;
    1: 
    1:   if (cx) {
    1:     nsCOMPtr<nsIWebNavigation> callerWebNav =
    1:       do_GetInterface(nsJSUtils::GetDynamicScriptGlobal(cx));
    1: 
    1:     if (callerWebNav) {
    1:       CallQueryInterface(callerWebNav, &callerItem);
    1:     }
    1:   }
    1: 
    1:   return callerItem;
    1: }
    1: 
    1: PRBool
    1: nsGlobalWindow::WindowExists(const nsAString& aName,
    1:                              PRBool aLookForCallerOnJSStack)
    1: {
    1:   NS_PRECONDITION(IsOuterWindow(), "Must be outer window");
    1:   NS_PRECONDITION(mDocShell, "Must have docshell");
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> caller;
    1:   if (aLookForCallerOnJSStack) {
    1:     caller = GetCallerDocShellTreeItem();
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShell = do_QueryInterface(mDocShell);
    1:   NS_ASSERTION(docShell,
    1:                "Docshell doesn't implement nsIDocShellTreeItem?");
    1: 
    1:   if (!caller) {
    1:     caller = docShell;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> namedItem;
    1:   docShell->FindItemWithName(PromiseFlatString(aName).get(), nsnull, caller,
    1:                              getter_AddRefs(namedItem));
    1:   return namedItem != nsnull;
    1: }
    1: 
    1: already_AddRefed<nsIWidget>
    1: nsGlobalWindow::GetMainWidget()
    1: {
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1: 
    1:   nsIWidget *widget = nsnull;
    1: 
    1:   if (treeOwnerAsWin) {
    1:     treeOwnerAsWin->GetMainWidget(&widget);
    1:   }
    1: 
    1:   return widget;
    1: }
    1: 
30327: nsIWidget*
30327: nsGlobalWindow::GetNearestWidget()
30327: {
30327:   nsIDocShell* docShell = GetDocShell();
30327:   NS_ENSURE_TRUE(docShell, nsnull);
30327:   nsCOMPtr<nsIPresShell> presShell;
30327:   docShell->GetPresShell(getter_AddRefs(presShell));
30327:   NS_ENSURE_TRUE(presShell, nsnull);
30327:   nsIFrame* rootFrame = presShell->GetRootFrame();
30327:   NS_ENSURE_TRUE(rootFrame, nsnull);
30327:   return rootFrame->GetView()->GetNearestWidget(nsnull);
30327: }
30327: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetFullScreen(PRBool aFullScreen)
    1: {
    1:   FORWARD_TO_OUTER(SetFullScreen, (aFullScreen), NS_ERROR_NOT_INITIALIZED);
    1: 
 8932:   NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
 8932: 
 2114:   PRBool rootWinFullScreen;
 2114:   GetFullScreen(&rootWinFullScreen);
    1:   // Only chrome can change our fullScreen mode.
 2114:   if (aFullScreen == rootWinFullScreen || 
    1:       !nsContentUtils::IsCallerTrustedForWrite()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // SetFullScreen needs to be called on the root window, so get that
    1:   // via the DocShell tree, and if we are not already the root,
    1:   // call SetFullScreen on that window instead.
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(mDocShell);
    1:   nsCOMPtr<nsIDocShellTreeItem> rootItem;
    1:   treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
    1:   nsCOMPtr<nsIDOMWindowInternal> window = do_GetInterface(rootItem);
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1:   if (rootItem != treeItem)
    1:     return window->SetFullScreen(aFullScreen);
    1: 
    1:   // make sure we don't try to set full screen on a non-chrome window,
    1:   // which might happen in embedding world
    1:   PRInt32 itemType;
    1:   treeItem->GetItemType(&itemType);
    1:   if (itemType != nsIDocShellTreeItem::typeChrome)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // dispatch a "fullscreen" DOM event so that XUL apps can
    1:   // respond visually if we are kicked into full screen mode
    1:   if (!DispatchCustomEvent("fullscreen")) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1:   if (widget)
    1:     widget->MakeFullScreen(aFullScreen);
    1: 
30004:   mFullScreen = aFullScreen;
30004: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetFullScreen(PRBool* aFullScreen)
    1: {
    1:   FORWARD_TO_OUTER(GetFullScreen, (aFullScreen), NS_ERROR_NOT_INITIALIZED);
    1: 
 2114:   // Get the fullscreen value of the root window, to always have the value
 2114:   // accurate, even when called from content.
 2114:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(mDocShell);
 8932:   if (treeItem) {
 2114:     nsCOMPtr<nsIDocShellTreeItem> rootItem;
 2114:     treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
 2114:     if (rootItem != treeItem) {
 2114:       nsCOMPtr<nsIDOMWindowInternal> window = do_GetInterface(rootItem);
 2114:       if (window)
 2114:         return window->GetFullScreen(aFullScreen);
 2114:     }
 8932:   }
 2114: 
30004:   // We are the root window, or something went wrong. Return our internal value.
30004:   *aFullScreen = mFullScreen;
    1:   return NS_OK;
    1: }
    1: 
21376: PRBool
21376: nsGlobalWindow::DOMWindowDumpEnabled()
    1: {
    1: #if !(defined(NS_DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
    1:   // In optimized builds we check a pref that controls if we should
    1:   // enable output from dump() or not, in debug builds it's always
    1:   // enabled.
21376:   return gDOMWindowDumpEnabled;
21376: #else
21376:   return PR_TRUE;
    1: #endif
21376: }
21376: 
21376: NS_IMETHODIMP
21376: nsGlobalWindow::Dump(const nsAString& aStr)
21376: {
21376:   if (!DOMWindowDumpEnabled()) {
21376:     return NS_OK;
21376:   }
    1: 
    1:   char *cstr = ToNewUTF8String(aStr);
    1: 
    1: #if defined(XP_MAC) || defined(XP_MACOSX)
    1:   // have to convert \r to \n so that printing to the console works
43423:   char *c = cstr, *cEnd = cstr + strlen(cstr);
    1:   while (c < cEnd) {
    1:     if (*c == '\r')
    1:       *c = '\n';
    1:     c++;
    1:   }
    1: #endif
    1: 
    1:   if (cstr) {
27826:     FILE *fp = gDumpFile ? gDumpFile : stdout;
27826:     fputs(cstr, fp);
27826:     fflush(fp);
    1:     nsMemory::Free(cstr);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::EnsureReflowFlushAndPaint()
    1: {
    1:   NS_ASSERTION(mDocShell, "EnsureReflowFlushAndPaint() called with no "
    1:                "docshell!");
    1: 
22792:   if (!mDocShell)
22792:     return;
22792: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   mDocShell->GetPresShell(getter_AddRefs(presShell));
    1: 
    1:   if (!presShell)
    1:     return;
    1: 
    1:   // Flush pending reflows.
    1:   if (mDoc) {
    1:     mDoc->FlushPendingNotifications(Flush_Layout);
    1:   }
    1: 
    1:   // Unsuppress painting.
    1:   presShell->UnsuppressPainting();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetTextZoom(float *aZoom)
    1: {
    1:   FORWARD_TO_OUTER(GetTextZoom, (aZoom), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (mDocShell) {
    1:     nsCOMPtr<nsIContentViewer> contentViewer;
    1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
    1:     nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(contentViewer));
    1: 
    1:     if (markupViewer) {
    1:       return markupViewer->GetTextZoom(aZoom);
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetTextZoom(float aZoom)
    1: {
    1:   FORWARD_TO_OUTER(SetTextZoom, (aZoom), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (mDocShell) {
    1:     nsCOMPtr<nsIContentViewer> contentViewer;
    1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
    1:     nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(contentViewer));
    1: 
    1:     if (markupViewer)
    1:       return markupViewer->SetTextZoom(aZoom);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::MakeScriptDialogTitle(nsAString &aOutTitle)
    1: {
    1:   aOutTitle.Truncate();
    1: 
    1:   // Try to get a host from the running principal -- this will do the
    1:   // right thing for javascript: and data: documents.
    1: 
    1:   nsresult rv = NS_OK;
    1:   NS_ASSERTION(nsContentUtils::GetSecurityManager(),
    1:     "Global Window has no security manager!");
    1:   if (nsContentUtils::GetSecurityManager()) {
    1:     nsCOMPtr<nsIPrincipal> principal;
    1:     rv = nsContentUtils::GetSecurityManager()->
    1:       GetSubjectPrincipal(getter_AddRefs(principal));
    1: 
    1:     if (NS_SUCCEEDED(rv) && principal) {
    1:       nsCOMPtr<nsIURI> uri;
    1:       rv = principal->GetURI(getter_AddRefs(uri));
    1: 
    1:       if (NS_SUCCEEDED(rv) && uri) {
    1:         // remove user:pass for privacy and spoof prevention
    1: 
    1:         nsCOMPtr<nsIURIFixup> fixup(do_GetService(NS_URIFIXUP_CONTRACTID));
    1:         if (fixup) {
    1:           nsCOMPtr<nsIURI> fixedURI;
    1:           rv = fixup->CreateExposableURI(uri, getter_AddRefs(fixedURI));
    1:           if (NS_SUCCEEDED(rv) && fixedURI) {
    1:             nsCAutoString host;
    1:             fixedURI->GetHost(host);
    1: 
    1:             if (!host.IsEmpty()) {
    1:               // if this URI has a host we'll show it. For other
    1:               // schemes (e.g. file:) we fall back to the localized
    1:               // generic string
    1: 
    1:               nsCAutoString prepath;
    1:               fixedURI->GetPrePath(prepath);
    1: 
    1:               NS_ConvertUTF8toUTF16 ucsPrePath(prepath);
    1:               const PRUnichar *formatStrings[] = { ucsPrePath.get() };
    1:               nsXPIDLString tempString;
    1:               nsContentUtils::FormatLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
    1:                                                     "ScriptDlgHeading",
    1:                                                     formatStrings, NS_ARRAY_LENGTH(formatStrings),
    1:                                                     tempString);
    1:               aOutTitle = tempString;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:     else { // failed to get subject principal
    1:       NS_WARNING("No script principal? Who is calling alert/confirm/prompt?!");
    1:     }
    1:   }
    1: 
    1:   if (aOutTitle.IsEmpty()) {
    1:     // We didn't find a host so use the generic heading
    1:     nsXPIDLString tempString;
    1:     nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
    1:                                        "ScriptDlgGenericHeading",
    1:                                        tempString);
    1:     aOutTitle = tempString;
    1:   }
    1: 
    1:   // Just in case
    1:   if (aOutTitle.IsEmpty()) {
    1:     NS_WARNING("could not get ScriptDlgGenericHeading string from string bundle");
    1:     aOutTitle.AssignLiteral("[Script]");
    1:   }
    1: }
    1: 
10989: // static
10989: PRBool
10989: nsGlobalWindow::CanMoveResizeWindows()
10989: {
13319:   if (!CanSetProperty("dom.disable_window_move_resize"))
10989:     return PR_FALSE;
10989: 
13279:   if (gMouseDown && !gDragServiceDisabled) {
13279:     nsCOMPtr<nsIDragService> ds =
13279:       do_GetService("@mozilla.org/widget/dragservice;1");
13279:     if (ds) {
13279:       gDragServiceDisabled = PR_TRUE;
13279:       ds->Suppress();
13279:     }
13279:   }
13279:   return PR_TRUE;
13279: }
10989: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Alert(const nsAString& aString)
    1: {
    1:   FORWARD_TO_OUTER(Alert, (aString), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   // Reset popup state while opening a modal dialog, and firing events
    1:   // about the dialog, to prevent the current state from being active
    1:   // the whole time a modal dialog is open.
    1:   nsAutoPopupStatePusher popupStatePusher(openAbused, PR_TRUE);
    1: 
    1:   // Special handling for alert(null) in JS for backwards
    1:   // compatibility.
    1: 
    1:   NS_NAMED_LITERAL_STRING(null_str, "null");
    1: 
    1:   const nsAString *str = DOMStringIsNull(aString) ? &null_str : &aString;
    1: 
    1:   // Before bringing up the window, unsuppress painting and flush
    1:   // pending reflows.
    1:   EnsureReflowFlushAndPaint();
    1: 
    1:   nsAutoString title;
    1:   MakeScriptDialogTitle(title);
    1: 
    1:   // Remove non-terminating null characters from the 
    1:   // string. See bug #310037. 
    1:   nsAutoString final;
38887:   nsContentUtils::StripNullChars(*str, final);
    1: 
42304:   nsresult rv;
42304:   nsCOMPtr<nsIPromptService> promptSvc = do_GetService("@mozilla.org/embedcomp/prompt-service;1", &rv);
42304:   NS_ENSURE_SUCCESS(rv, rv);
42304: 
42304:   return promptSvc->Alert(this, title.get(), final.get());
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Confirm(const nsAString& aString, PRBool* aReturn)
    1: {
    1:   FORWARD_TO_OUTER(Confirm, (aString, aReturn), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   // Reset popup state while opening a modal dialog, and firing events
    1:   // about the dialog, to prevent the current state from being active
    1:   // the whole time a modal dialog is open.
    1:   nsAutoPopupStatePusher popupStatePusher(openAbused, PR_TRUE);
    1: 
    1:   *aReturn = PR_FALSE;
    1: 
    1:   // Before bringing up the window, unsuppress painting and flush
    1:   // pending reflows.
    1:   EnsureReflowFlushAndPaint();
    1: 
    1:   nsAutoString title;
    1:   MakeScriptDialogTitle(title);
    1: 
    1:   // Remove non-terminating null characters from the 
    1:   // string. See bug #310037. 
    1:   nsAutoString final;
38887:   nsContentUtils::StripNullChars(aString, final);
    1: 
42304:   nsresult rv;
42304:   nsCOMPtr<nsIPromptService> promptSvc = do_GetService("@mozilla.org/embedcomp/prompt-service;1", &rv);
42304:   NS_ENSURE_SUCCESS(rv, rv);
42304: 
42304:   return promptSvc->Confirm(this, title.get(), final.get(), aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Prompt(const nsAString& aMessage, const nsAString& aInitial,
    1:                        nsAString& aReturn)
    1: {
    1:   SetDOMStringToNull(aReturn);
    1: 
    1:   // Reset popup state while opening a modal dialog, and firing events
    1:   // about the dialog, to prevent the current state from being active
    1:   // the whole time a modal dialog is open.
    1:   nsAutoPopupStatePusher popupStatePusher(openAbused, PR_TRUE);
    1: 
    1:   // Before bringing up the window, unsuppress painting and flush
    1:   // pending reflows.
    1:   EnsureReflowFlushAndPaint();
    1: 
    1:   nsAutoString title;
    1:   MakeScriptDialogTitle(title);
    1:   
    1:   // Remove non-terminating null characters from the 
    1:   // string. See bug #310037. 
    1:   nsAutoString fixedMessage, fixedInitial;
38887:   nsContentUtils::StripNullChars(aMessage, fixedMessage);
38887:   nsContentUtils::StripNullChars(aInitial, fixedInitial);
    1: 
42304:   nsresult rv;
42304:   nsCOMPtr<nsIPromptService> promptSvc = do_GetService("@mozilla.org/embedcomp/prompt-service;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
42304:   // Pass in the default value, if any.
42304:   PRUnichar *inoutValue = ToNewUnicode(fixedInitial);
42304: 
42304:   PRBool ok, dummy;
42304:   rv = promptSvc->Prompt(this, title.get(), fixedMessage.get(),
42304:                          &inoutValue, nsnull, &dummy, &ok);
42304:   NS_ENSURE_SUCCESS(rv, rv);
42304: 
42304:   nsAdoptingString outValue(inoutValue);
42304: 
42304:   if (ok && outValue) {
42304:     aReturn.Assign(outValue);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Focus()
    1: {
    1:   FORWARD_TO_OUTER(Focus, (), NS_ERROR_NOT_INITIALIZED);
    1: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm)
29018:     return NS_OK;
29018: 
    1:   nsCOMPtr<nsIBaseWindow> baseWin = do_QueryInterface(mDocShell);
    1: 
    1:   PRBool isVisible = PR_FALSE;
    1:   if (baseWin) {
    1:     baseWin->GetVisibility(&isVisible);
    1:   }
    1: 
    1:   if (!isVisible) {
    1:     // A hidden tab is being focused, ignore this call.
    1:     return NS_OK;
    1:   }
    1: 
    1:   /*
    1:    * If caller is not chrome and dom.disable_window_flip is true,
    1:    * prevent bringing a window to the front if the window is not the
    1:    * currently active window, but do change the currently focused
    1:    * window in the focus controller so that focus is in the right
    1:    * place when the window is activated again.
    1:    */
    1: 
    1:   PRBool canFocus =
    1:     CanSetProperty("dom.disable_window_flip") ||
34524:     RevisePopupAbuseLevel(gPopupControlState) < openAbused;
    1: 
29018:   nsCOMPtr<nsIDOMWindow> activeWindow;
29018:   fm->GetActiveWindow(getter_AddRefs(activeWindow));
29018: 
29018:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(mDocShell);
29018:   NS_ASSERTION(treeItem, "What happened?");
29018:   nsCOMPtr<nsIDocShellTreeItem> rootItem;
29018:   treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
29018:   nsCOMPtr<nsIDOMWindow> rootWin = do_GetInterface(rootItem);
29018:   PRBool isActive = (rootWin == activeWindow);
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   if (treeOwnerAsWin && (canFocus || isActive)) {
    1:     PRBool isEnabled = PR_TRUE;
    1:     if (NS_SUCCEEDED(treeOwnerAsWin->GetEnabled(&isEnabled)) && !isEnabled) {
    1:       NS_WARNING( "Should not try to set the focus on a disabled window" );
    1:       return NS_OK;
    1:     }
    1: 
29018:     // XXXndeakin not sure what this is for or if it should go somewhere else
    1:     nsCOMPtr<nsIEmbeddingSiteWindow> embeddingWin(do_GetInterface(treeOwnerAsWin));
    1:     if (embeddingWin)
    1:       embeddingWin->SetFocus();
    1:   }
    1: 
29018:   if (!mDocShell)
29018:     return NS_OK;
29018: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   // Don't look for a presshell if we're a root chrome window that's got
    1:   // about:blank loaded.  We don't want to focus our widget in that case.
    1:   // XXXbz should we really be checking for IsInitialDocument() instead?
    1:   PRBool lookForPresShell = PR_TRUE;
    1:   PRInt32 itemType = nsIDocShellTreeItem::typeContent;
    1:   treeItem->GetItemType(&itemType);
    1:   if (itemType == nsIDocShellTreeItem::typeChrome &&
 3233:       GetPrivateRoot() == static_cast<nsIDOMWindowInternal*>(this) &&
    1:       mDocument) {
    1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
    1:     NS_ASSERTION(doc, "Bogus doc?");
    1:     nsIURI* ourURI = doc->GetDocumentURI();
    1:     if (ourURI) {
    1:       lookForPresShell = !IsAboutBlank(ourURI);
    1:     }
    1:   }
    1: 
    1:   if (lookForPresShell) {
    1:     mDocShell->GetEldestPresShell(getter_AddRefs(presShell));
    1:   }
29018: 
29018:   nsCOMPtr<nsIDocShellTreeItem> parentDsti;
29018:   treeItem->GetParent(getter_AddRefs(parentDsti));
29018: 
29018:   // set the parent's current focus to the frame containing this window.
29018:   nsCOMPtr<nsIDOMWindow> parent(do_GetInterface(parentDsti));
29018:   if (parent) {
29018:     nsCOMPtr<nsIDOMDocument> parentdomdoc;
29018:     parent->GetDocument(getter_AddRefs(parentdomdoc));
29018: 
29018:     nsCOMPtr<nsIDocument> parentdoc = do_QueryInterface(parentdomdoc);
29018:     if (!parentdoc)
29018:       return NS_OK;
29018: 
29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
29018:     nsIContent* frame = parentdoc->FindContentForSubDocument(doc);
29018:     nsCOMPtr<nsIDOMElement> frameElement = do_QueryInterface(frame);
29018:     if (frameElement) {
29018:       PRUint32 flags = nsIFocusManager::FLAG_NOSCROLL;
29018:       if (canFocus)
29018:         flags |= nsIFocusManager::FLAG_RAISE;
29018:       return fm->SetFocus(frameElement, flags);
29018:     }
29018:   }
29018:   else if (canFocus) {
29018:     // if there is no parent, this must be a toplevel window, so raise the
29018:     // window if canFocus is true
29018:     return fm->SetActiveWindow(this);
29018:   }
29018: 
29018:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Blur()
    1: {
    1:   FORWARD_TO_OUTER(Blur, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   // If embedding apps don't implement nsIEmbeddingSiteWindow2, we
    1:   // shouldn't throw exceptions to web content.
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   GetTreeOwner(getter_AddRefs(treeOwner));
    1:   nsCOMPtr<nsIEmbeddingSiteWindow2> siteWindow(do_GetInterface(treeOwner));
    1:   if (siteWindow) {
    1:     // This method call may cause mDocShell to become nsnull.
    1:     rv = siteWindow->Blur();
    1: 
29018:     // if the root is focused, clear the focus
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
29018:     if (fm && mDocument) {
29018:       nsCOMPtr<nsIDOMElement> element;
29018:       fm->GetFocusedElementForWindow(this, PR_FALSE, nsnull, getter_AddRefs(element));
29018:       nsCOMPtr<nsIContent> content = do_QueryInterface(element);
41634:       if (content == doc->GetRootElement())
29018:         fm->ClearFocus(this);
29018:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Back()
    1: {
    1:   FORWARD_TO_OUTER(Back, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
    1: 
    1:   return webNav->GoBack();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Forward()
    1: {
    1:   FORWARD_TO_OUTER(Forward, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
    1: 
    1:   return webNav->GoForward();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Home()
    1: {
    1:   FORWARD_TO_OUTER(Home, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mDocShell)
    1:     return NS_OK;
    1: 
    1:   nsAdoptingString homeURL =
    1:     nsContentUtils::GetLocalizedStringPref(PREF_BROWSER_STARTUP_HOMEPAGE);
    1: 
    1:   if (homeURL.IsEmpty()) {
    1:     // if all else fails, use this
    1: #ifdef DEBUG_seth
    1:     printf("all else failed.  using %s as the home page\n", DEFAULT_HOME_PAGE);
    1: #endif
    1:     CopyASCIItoUTF16(DEFAULT_HOME_PAGE, homeURL);
    1:   }
    1: 
    1: #ifdef MOZ_PHOENIX
    1:   {
    1:     // Firefox lets the user specify multiple home pages to open in
    1:     // individual tabs by separating them with '|'. Since we don't
    1:     // have the machinery in place to easily open new tabs from here,
    1:     // simply truncate the homeURL at the first '|' character to
    1:     // prevent any possibilities of leaking the users list of home
    1:     // pages to the first home page.
    1:     //
    1:     // Once bug https://bugzilla.mozilla.org/show_bug.cgi?id=221445 is
    1:     // fixed we can revisit this.
    1:     PRInt32 firstPipe = homeURL.FindChar('|');
    1: 
    1:     if (firstPipe > 0) {
    1:       homeURL.Truncate(firstPipe);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
    1:   rv = webNav->LoadURI(homeURL.get(),
    1:                        nsIWebNavigation::LOAD_FLAGS_NONE,
    1:                        nsnull,
    1:                        nsnull,
    1:                        nsnull);
    1:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Stop()
    1: {
    1:   FORWARD_TO_OUTER(Stop, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:   if (!webNav)
    1:     return NS_OK;
    1: 
    1:   return webNav->Stop(nsIWebNavigation::STOP_ALL);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Print()
    1: {
    1: #ifdef NS_PRINTING
    1:   FORWARD_TO_OUTER(Print, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIWebBrowserPrint> webBrowserPrint;
    1:   if (NS_SUCCEEDED(GetInterface(NS_GET_IID(nsIWebBrowserPrint),
    1:                                 getter_AddRefs(webBrowserPrint)))) {
    1: 
    1:     nsCOMPtr<nsIPrintSettingsService> printSettingsService = 
    1:       do_GetService("@mozilla.org/gfx/printsettings-service;1");
    1: 
    1:     nsCOMPtr<nsIPrintSettings> printSettings;
    1:     if (printSettingsService) {
    1:       PRBool printSettingsAreGlobal =
    1:         nsContentUtils::GetBoolPref("print.use_global_printsettings", PR_FALSE);
    1: 
    1:       if (printSettingsAreGlobal) {
    1:         printSettingsService->GetGlobalPrintSettings(getter_AddRefs(printSettings));
    1: 
    1:         nsXPIDLString printerName;
42459:         printSettings->GetPrinterName(getter_Copies(printerName));
42459:         if (printerName.IsEmpty()) {
    1:           printSettingsService->GetDefaultPrinterName(getter_Copies(printerName));
42459:           printSettings->SetPrinterName(printerName);
42459:         }
    1:         printSettingsService->InitPrintSettingsFromPrinter(printerName, printSettings);
    1:         printSettingsService->InitPrintSettingsFromPrefs(printSettings, 
    1:                                                          PR_TRUE, 
    1:                                                          nsIPrintSettings::kInitSaveAll);
    1:       } else {
    1:         printSettingsService->GetNewPrintSettings(getter_AddRefs(printSettings));
    1:       }
    1: 
29105:       EnterModalState();
    1:       webBrowserPrint->Print(printSettings, nsnull);
29105:       LeaveModalState();
    1: 
    1:       PRBool savePrintSettings =
    1:         nsContentUtils::GetBoolPref("print.save_print_settings", PR_FALSE);
    1:       if (printSettingsAreGlobal && savePrintSettings) {
    1:         printSettingsService->
    1:           SavePrintSettingsToPrefs(printSettings,
    1:                                    PR_TRUE,
    1:                                    nsIPrintSettings::kInitSaveAll);
    1:         printSettingsService->
    1:           SavePrintSettingsToPrefs(printSettings,
    1:                                    PR_FALSE,
    1:                                    nsIPrintSettings::kInitSavePrinterName);
    1:       }
    1:     } else {
    1:       webBrowserPrint->GetGlobalPrintSettings(getter_AddRefs(printSettings));
    1:       webBrowserPrint->Print(printSettings, nsnull);
    1:     }
    1:   }
38377: #endif //NS_PRINTING
38377: 
38377:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::MoveTo(PRInt32 aXPos, PRInt32 aYPos)
    1: {
    1:   FORWARD_TO_OUTER(MoveTo, (aXPos, aYPos), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent window.moveTo() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aXPos, &aYPos),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   // mild abuse of a "size" object so we don't need more helper functions
24816:   nsIntSize devPos(CSSToDevIntPixels(nsIntSize(aXPos, aYPos)));
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(devPos.width, devPos.height),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::MoveBy(PRInt32 aXDif, PRInt32 aYDif)
    1: {
    1:   FORWARD_TO_OUTER(MoveBy, (aXDif, aYDif), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent window.moveBy() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
24816:   // To do this correctly we have to convert what we get from GetPosition
24816:   // into CSS pixels, add the arguments, do the security check, and
24816:   // then convert back to device pixels for the call to SetPosition.
24816: 
    1:   PRInt32 x, y;
    1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y), NS_ERROR_FAILURE);
    1: 
24816:   // mild abuse of a "size" object so we don't need more helper functions
24816:   nsIntSize cssPos(DevToCSSIntPixels(nsIntSize(x, y)));
24816: 
24816:   cssPos.width += aXDif;
24816:   cssPos.height += aYDif;
24816:   
24816:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&cssPos.width,
24816:                                             &cssPos.height),
24816:                     NS_ERROR_FAILURE);
24816: 
24816:   nsIntSize newDevPos(CSSToDevIntPixels(cssPos));
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(newDevPos.width,
24816:                                                 newDevPos.height),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ResizeTo(PRInt32 aWidth, PRInt32 aHeight)
    1: {
    1:   FORWARD_TO_OUTER(ResizeTo, (aWidth, aHeight), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent window.resizeTo() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1:   
    1:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(&aWidth, &aHeight),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   nsIntSize devSz(CSSToDevIntPixels(nsIntSize(aWidth, aHeight)));
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetSize(devSz.width, devSz.height, PR_TRUE),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ResizeBy(PRInt32 aWidthDif, PRInt32 aHeightDif)
    1: {
    1:   FORWARD_TO_OUTER(ResizeBy, (aWidthDif, aHeightDif), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent window.resizeBy() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 width, height;
    1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetSize(&width, &height), NS_ERROR_FAILURE);
    1: 
24816:   // To do this correctly we have to convert what we got from GetSize
24816:   // into CSS pixels, add the arguments, do the security check, and
24816:   // then convert back to device pixels for the call to SetSize.
24816: 
24816:   nsIntSize cssSize(DevToCSSIntPixels(nsIntSize(width, height)));
24816: 
24816:   cssSize.width += aWidthDif;
24816:   cssSize.height += aHeightDif;
24816: 
24816:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(&cssSize.width,
24816:                                                 &cssSize.height),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   nsIntSize newDevSize(CSSToDevIntPixels(cssSize));
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetSize(newDevSize.width,
24816:                                             newDevSize.height,
24816:                                             PR_TRUE),
24816:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SizeToContent()
    1: {
    1:   FORWARD_TO_OUTER(SizeToContent, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mDocShell) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
13308:    * prevent window.sizeToContent() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // The content viewer does a check to make sure that it's a content
    1:   // viewer for a toplevel docshell.
    1:   
    1:   nsCOMPtr<nsIContentViewer> cv;
    1:   mDocShell->GetContentViewer(getter_AddRefs(cv));
    1:   nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(cv));
    1:   NS_ENSURE_TRUE(markupViewer, NS_ERROR_FAILURE);
    1:   NS_ENSURE_SUCCESS(markupViewer->SizeToContent(), NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetWindowRoot(nsIDOMEventTarget **aWindowRoot)
    1: {
38336:   nsCOMPtr<nsPIWindowRoot> root = GetTopWindowRoot();
38336:   return CallQueryInterface(root, aWindowRoot);
38336: }
38336: 
38336: already_AddRefed<nsPIWindowRoot>
38336: nsGlobalWindow::GetTopWindowRoot()
38336: {
38336:   nsIDOMWindowInternal *rootWindow = GetPrivateRoot();
    1:   nsCOMPtr<nsPIDOMWindow> piWin(do_QueryInterface(rootWindow));
38336:   if (!piWin)
38336:     return nsnull;
38336: 
38336:   nsCOMPtr<nsPIWindowRoot> window = do_QueryInterface(piWin->GetChromeEventHandler());
38336:   return window.forget();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Scroll(PRInt32 aXScroll, PRInt32 aYScroll)
    1: {
    1:   return ScrollTo(aXScroll, aYScroll);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ScrollTo(PRInt32 aXScroll, PRInt32 aYScroll)
    1: {
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063: 
37063:   if (sf) {
    1:     // Here we calculate what the max pixel value is that we can
    1:     // scroll to, we do this by dividing maxint with the pixel to
    1:     // twips conversion factor, and substracting 4, the 4 comes from
    1:     // experimenting with this value, anything less makes the view
    1:     // code not scroll correctly, I have no idea why. -- jst
    1:     const PRInt32 maxpx = nsPresContext::AppUnitsToIntCSSPixels(0x7fffffff) - 4;
    1: 
    1:     if (aXScroll > maxpx) {
    1:       aXScroll = maxpx;
    1:     }
    1: 
    1:     if (aYScroll > maxpx) {
    1:       aYScroll = maxpx;
    1:     }
37063:     sf->ScrollTo(nsPoint(nsPresContext::CSSPixelsToAppUnits(aXScroll),
37063:                          nsPresContext::CSSPixelsToAppUnits(aYScroll)),
37063:                  nsIScrollableFrame::INSTANT);
37063:   }
37063: 
37063:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ScrollBy(PRInt32 aXScrollDif, PRInt32 aYScrollDif)
    1: {
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063: 
37063:   if (sf) {
37063:     nsPoint scrollPos = sf->GetScrollPosition();
37063:     // It seems like it would make more sense for ScrollBy to use
37063:     // SMOOTH mode, but tests seem to depend on the synchronous behaviour.
37063:     // Perhaps Web content does too.
37063:     return ScrollTo(nsPresContext::AppUnitsToIntCSSPixels(scrollPos.x) + aXScrollDif,
37063:                     nsPresContext::AppUnitsToIntCSSPixels(scrollPos.y) + aYScrollDif);
37063:   }
37063: 
37063:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ScrollByLines(PRInt32 numLines)
    1: {
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063:   if (sf) {
37063:     // It seems like it would make more sense for ScrollByLines to use
37063:     // SMOOTH mode, but tests seem to depend on the synchronous behaviour.
37063:     // Perhaps Web content does too.
37063:     sf->ScrollBy(nsIntPoint(0, numLines), nsIScrollableFrame::LINES,
37063:                  nsIScrollableFrame::INSTANT);
37063:   }
37063: 
37063:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ScrollByPages(PRInt32 numPages)
    1: {
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063:   if (sf) {
37063:     // It seems like it would make more sense for ScrollByPages to use
37063:     // SMOOTH mode, but tests seem to depend on the synchronous behaviour.
37063:     // Perhaps Web content does too.
37063:     sf->ScrollBy(nsIntPoint(0, numPages), nsIScrollableFrame::PAGES,
37063:                  nsIScrollableFrame::INSTANT);
37063:   }
37063: 
37063:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ClearTimeout()
    1: {
    1:   return ClearTimeoutOrInterval();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ClearInterval()
    1: {
    1:   return ClearTimeoutOrInterval();
    1: }
    1: 
    1: NS_IMETHODIMP
23272: nsGlobalWindow::SetTimeout(PRInt32 *_retval)
    1: {
    1:   return SetTimeoutOrInterval(PR_FALSE, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
23272: nsGlobalWindow::SetInterval(PRInt32 *_retval)
    1: {
    1:   return SetTimeoutOrInterval(PR_TRUE, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetResizable(PRBool aResizable)
    1: {
    1:   // nop
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: ReportUseOfDeprecatedMethod(nsGlobalWindow* aWindow, const char* aWarning)
    1: {
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(aWindow->GetExtantDocument());
    1:   nsContentUtils::ReportToConsole(nsContentUtils::eDOM_PROPERTIES,
    1:                                   aWarning,
    1:                                   nsnull, 0,
    1:                                   doc ? doc->GetDocumentURI() : nsnull,
    1:                                   EmptyString(), 0, 0,
    1:                                   nsIScriptError::warningFlag,
    1:                                   "DOM Events");
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::CaptureEvents(PRInt32 aEventFlags)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfCaptureEventsWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ReleaseEvents(PRInt32 aEventFlags)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfReleaseEventsWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::RouteEvent(nsIDOMEvent* aEvt)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfRouteEventWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::EnableExternalCapture()
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::DisableExternalCapture()
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: static
    1: PRBool IsPopupBlocked(nsIDOMDocument* aDoc)
    1: {
    1:   nsCOMPtr<nsIPopupWindowManager> pm =
    1:     do_GetService(NS_POPUPWINDOWMANAGER_CONTRACTID);
    1: 
    1:   if (!pm) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRBool blocked = PR_TRUE;
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(aDoc));
    1: 
    1:   if (doc) {
    1:     PRUint32 permission = nsIPopupWindowManager::ALLOW_POPUP;
    1:     pm->TestPermission(doc->GetDocumentURI(), &permission);
    1:     blocked = (permission == nsIPopupWindowManager::DENY_POPUP);
    1:   }
    1:   return blocked;
    1: }
    1: 
    1: static
    1: void FirePopupBlockedEvent(nsIDOMDocument* aDoc,
    1:                            nsIDOMWindow *aRequestingWindow, nsIURI *aPopupURI,
    1:                            const nsAString &aPopupWindowName,
    1:                            const nsAString &aPopupWindowFeatures)
    1: {
    1:   if (aDoc) {
    1:     // Fire a "DOMPopupBlocked" event so that the UI can hear about
    1:     // blocked popups.
    1:     nsCOMPtr<nsIDOMDocumentEvent> docEvent(do_QueryInterface(aDoc));
    1:     nsCOMPtr<nsIDOMEvent> event;
    1:     docEvent->CreateEvent(NS_LITERAL_STRING("PopupBlockedEvents"),
    1:                           getter_AddRefs(event));
    1:     if (event) {
    1:       nsCOMPtr<nsIDOMPopupBlockedEvent> pbev(do_QueryInterface(event));
    1:       pbev->InitPopupBlockedEvent(NS_LITERAL_STRING("DOMPopupBlocked"),
    1:                                   PR_TRUE, PR_TRUE, aRequestingWindow,
    1:                                   aPopupURI, aPopupWindowName,
    1:                                   aPopupWindowFeatures);
    1:       nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
    1:       privateEvent->SetTrusted(PR_TRUE);
    1: 
    1:       nsCOMPtr<nsIDOMEventTarget> targ(do_QueryInterface(aDoc));
    1:       PRBool defaultActionEnabled;
    1:       targ->DispatchEvent(event, &defaultActionEnabled);
    1:     }
    1:   }
    1: }
    1: 
    1: void FirePopupWindowEvent(nsIDOMDocument* aDoc)
    1: {
    1:   // Fire a "PopupWindow" event
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(aDoc));
    1:   nsContentUtils::DispatchTrustedEvent(doc, aDoc,
    1:                                        NS_LITERAL_STRING("PopupWindow"),
    1:                                        PR_TRUE, PR_TRUE);
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsGlobalWindow::CanSetProperty(const char *aPrefName)
    1: {
    1:   // Chrome can set any property.
    1:   if (nsContentUtils::IsCallerTrustedForWrite()) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // If the pref is set to true, we can not set the property
    1:   // and vice versa.
    1:   return !nsContentUtils::GetBoolPref(aPrefName, PR_TRUE);
    1: }
    1: 
34524: PRBool
34524: nsGlobalWindow::PopupWhitelisted()
34524: {
34524:   if (!IsPopupBlocked(mDocument))
34524:     return PR_TRUE;
34524: 
34524:   nsCOMPtr<nsIDOMWindow> parent;
34524: 
34524:   if (NS_FAILED(GetParent(getter_AddRefs(parent))) ||
34524:       parent == static_cast<nsIDOMWindow*>(this))
34524:   {
34524:     return PR_FALSE;
34524:   }
34524: 
34524:   return static_cast<nsGlobalWindow*>
34524:                     (static_cast<nsIDOMWindow*>
34524:                                 (parent.get()))->PopupWhitelisted();
34524: }
    1: 
    1: /*
    1:  * Examine the current document state to see if we're in a way that is
    1:  * typically abused by web designers. The window.open code uses this
    1:  * routine to determine whether to allow the new window.
34524:  * Returns a value from the PopupControlState enum.
    1:  */
    1: PopupControlState
34524: nsGlobalWindow::RevisePopupAbuseLevel(PopupControlState aControl)
34524: {
34524:   FORWARD_TO_OUTER(RevisePopupAbuseLevel, (aControl), aControl);
    1: 
    1:   NS_ASSERTION(mDocShell, "Must have docshell");
    1:   
    1:   nsCOMPtr<nsIDocShellTreeItem> item(do_QueryInterface(mDocShell));
    1: 
30709:   NS_ASSERTION(item, "Docshell doesn't implement nsIDocShellTreeItem?");
    1: 
    1:   PRInt32 type = nsIDocShellTreeItem::typeChrome;
    1:   item->GetItemType(&type);
    1:   if (type != nsIDocShellTreeItem::typeContent)
    1:     return openAllowed;
    1: 
34524:   PopupControlState abuse = aControl;
34524:   switch (abuse) {
34524:   case openControlled:
34524:   case openAbused:
34524:   case openOverridden:
34524:     if (PopupWhitelisted())
34524:       abuse = PopupControlState(abuse - 1);
34524:   case openAllowed: break;
34524:   default:
34524:     NS_WARNING("Strange PopupControlState!");
34524:   }
    1: 
    1:   // limit the number of simultaneously open popups
    1:   if (abuse == openAbused || abuse == openControlled) {
    1:     PRInt32 popupMax = nsContentUtils::GetIntPref("dom.popup_maximum", -1);
    1:     if (popupMax >= 0 && gOpenPopupSpamCount >= popupMax)
    1:       abuse = openOverridden;
    1:   }
    1: 
    1:   return abuse;
    1: }
    1: 
    1: /* If a window open is blocked, fire the appropriate DOM events.
    1:    aBlocked signifies we just blocked a popup.
    1:    aWindow signifies we just opened what is probably a popup.
    1: */
    1: void
    1: nsGlobalWindow::FireAbuseEvents(PRBool aBlocked, PRBool aWindow,
    1:                                 const nsAString &aPopupURL,
    1:                                 const nsAString &aPopupWindowName,
    1:                                 const nsAString &aPopupWindowFeatures)
    1: {
    1:   // fetch the URI of the window requesting the opened window
    1: 
    1:   nsCOMPtr<nsIDOMWindow> topWindow;
    1:   GetTop(getter_AddRefs(topWindow));
    1:   if (!topWindow)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIDOMDocument> topDoc;
    1:   topWindow->GetDocument(getter_AddRefs(topDoc));
    1: 
    1:   nsCOMPtr<nsIURI> popupURI;
    1: 
    1:   // build the URI of the would-have-been popup window
    1:   // (see nsWindowWatcher::URIfromURL)
    1: 
    1:   // first, fetch the opener's base URI
    1: 
    1:   nsIURI *baseURL = 0;
    1: 
18868:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
    1:   nsCOMPtr<nsIDOMWindow> contextWindow;
18868: 
    1:   if (cx) {
    1:     nsIScriptContext *currentCX = nsJSUtils::GetDynamicScriptContext(cx);
    1:     if (currentCX) {
    1:       contextWindow = do_QueryInterface(currentCX->GetGlobalObject());
    1:     }
    1:   }
    1:   if (!contextWindow)
 3233:     contextWindow = static_cast<nsIDOMWindow*>(this);
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domdoc;
    1:   contextWindow->GetDocument(getter_AddRefs(domdoc));
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(domdoc));
    1:   if (doc)
41900:     baseURL = doc->GetDocBaseURI();
    1: 
    1:   // use the base URI to build what would have been the popup's URI
    1:   nsCOMPtr<nsIIOService> ios(do_GetService(NS_IOSERVICE_CONTRACTID));
    1:   if (ios)
    1:     ios->NewURI(NS_ConvertUTF16toUTF8(aPopupURL), 0, baseURL,
    1:                 getter_AddRefs(popupURI));
    1: 
    1:   // fire an event chock full of informative URIs
    1:   if (aBlocked)
    1:     FirePopupBlockedEvent(topDoc, this, popupURI, aPopupWindowName,
    1:                           aPopupWindowFeatures);
    1:   if (aWindow)
    1:     FirePopupWindowEvent(topDoc);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Open(const nsAString& aUrl, const nsAString& aName,
    1:                      const nsAString& aOptions, nsIDOMWindow **_retval)
    1: {
    1:   return OpenInternal(aUrl, aName, aOptions,
    1:                       PR_FALSE,          // aDialog
 5814:                       PR_FALSE,          // aContentModal
    1:                       PR_TRUE,           // aCalledNoScript
    1:                       PR_FALSE,          // aDoJSFixups
    1:                       nsnull, nsnull,    // No args
    1:                       GetPrincipal(),    // aCalleePrincipal
    1:                       nsnull,            // aJSCallerContext
    1:                       _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
19026: nsGlobalWindow::OpenJS(const nsAString& aUrl, const nsAString& aName,
19026:                        const nsAString& aOptions, nsIDOMWindow **_retval)
19026: {
19026:   return OpenInternal(aUrl, aName, aOptions,
    1:                       PR_FALSE,          // aDialog
 5814:                       PR_FALSE,          // aContentModal
    1:                       PR_FALSE,          // aCalledNoScript
    1:                       PR_TRUE,           // aDoJSFixups
    1:                       nsnull, nsnull,    // No args
    1:                       GetPrincipal(),    // aCalleePrincipal
19026:                       nsContentUtils::GetCurrentJSContext(), // aJSCallerContext
    1:                       _retval);
    1: }
    1: 
    1: // like Open, but attaches to the new window any extra parameters past
    1: // [features] as a JS property named "arguments"
    1: NS_IMETHODIMP
    1: nsGlobalWindow::OpenDialog(const nsAString& aUrl, const nsAString& aName,
    1:                            const nsAString& aOptions,
    1:                            nsISupports* aExtraArgument, nsIDOMWindow** _retval)
    1: {
    1:   return OpenInternal(aUrl, aName, aOptions,
    1:                       PR_TRUE,                    // aDialog
 5814:                       PR_FALSE,                   // aContentModal
    1:                       PR_TRUE,                    // aCalledNoScript
    1:                       PR_FALSE,                   // aDoJSFixups
    1:                       nsnull, aExtraArgument,     // Arguments
    1:                       GetPrincipal(),             // aCalleePrincipal
    1:                       nsnull,                     // aJSCallerContext
    1:                       _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
19026: nsGlobalWindow::OpenDialog(const nsAString& aUrl, const nsAString& aName,
19026:                            const nsAString& aOptions, nsIDOMWindow** _retval)
    1: {
    1:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
    1:     return NS_ERROR_DOM_SECURITY_ERR;
    1:   }
    1: 
10286:   nsAXPCNativeCallContext *ncc = nsnull;
    1:   nsresult rv = nsContentUtils::XPConnect()->
10286:     GetCurrentNativeCallContext(&ncc);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!ncc)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   JSContext *cx = nsnull;
    1: 
    1:   rv = ncc->GetJSContext(&cx);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 argc;
    1:   jsval *argv = nsnull;
    1: 
    1:   // XXX - need to get this as nsISupports?
    1:   ncc->GetArgc(&argc);
    1:   ncc->GetArgvPtr(&argv);
    1: 
    1:   // Strip the url, name and options from the args seen by scripts.
    1:   PRUint32 argOffset = argc < 3 ? argc : 3;
    1:   nsCOMPtr<nsIArray> argvArray;
19026:   rv = NS_CreateJSArgv(cx, argc - argOffset, argv + argOffset,
19026:                        getter_AddRefs(argvArray));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
19026:   return OpenInternal(aUrl, aName, aOptions,
    1:                       PR_TRUE,             // aDialog
 5814:                       PR_FALSE,            // aContentModal
    1:                       PR_FALSE,            // aCalledNoScript
    1:                       PR_FALSE,            // aDoJSFixups
    1:                       argvArray, nsnull,   // Arguments
    1:                       GetPrincipal(),      // aCalleePrincipal
    1:                       cx,                  // aJSCallerContext
    1:                       _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetFrames(nsIDOMWindow** aFrames)
    1: {
    1:   FORWARD_TO_OUTER(GetFrames, (aFrames), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aFrames = this;
    1:   NS_ADDREF(*aFrames);
    1: 
    1:   FlushPendingNotifications(Flush_ContentAndNotify);
    1: 
    1:   return NS_OK;
    1: }
    1: 
11028: nsGlobalWindow*
11028: nsGlobalWindow::CallerInnerWindow()
10976: {
18868:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
18868:   if (!cx) {
18868:     NS_ERROR("Please don't call this method from C++!");
18868: 
10976:     return nsnull;
10976:   }
10976: 
10976:   JSObject *scope = ::JS_GetScopeChain(cx);
10976:   if (!scope)
10976:     return nsnull;
10976: 
10976:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
10976:   nsContentUtils::XPConnect()->
10976:     GetWrappedNativeOfJSObject(cx, ::JS_GetGlobalForObject(cx, scope),
10976:                                getter_AddRefs(wrapper));
10976:   if (!wrapper)
10976:     return nsnull;
10976: 
10976:   // The calling window must be holding a reference, so we can just return a
10976:   // raw pointer here and let the QI's addref be balanced by the nsCOMPtr
10976:   // destructor's release.
10976:   nsCOMPtr<nsPIDOMWindow> win = do_QueryWrappedNative(wrapper);
11028:   if (!win)
11028:     return GetCurrentInnerWindowInternal();
10976:   return static_cast<nsGlobalWindow*>(win.get());
10976: }
10976: 
14898: 
14898: /**
14898:  * Class used to represent events generated by calls to Window.postMessage,
14898:  * which asynchronously creates and dispatches events.
14898:  */
14898: class PostMessageEvent : public nsRunnable
14898: {
14898:   public:
14898:     NS_DECL_NSIRUNNABLE
14898: 
14898:     PostMessageEvent(nsGlobalWindow* aSource,
14898:                      const nsAString& aCallerOrigin,
14898:                      const nsAString& aMessage,
14898:                      nsGlobalWindow* aTargetWindow,
14898:                      nsIURI* aProvidedOrigin,
14898:                      PRBool aTrustedCaller)
14898:     : mSource(aSource),
14898:       mCallerOrigin(aCallerOrigin),
14898:       mMessage(aMessage),
14898:       mTargetWindow(aTargetWindow),
14898:       mProvidedOrigin(aProvidedOrigin),
14898:       mTrustedCaller(aTrustedCaller)
14898:     {
14898:       MOZ_COUNT_CTOR(PostMessageEvent);
14898:     }
14898:     
14898:     ~PostMessageEvent()
14898:     {
14898:       MOZ_COUNT_DTOR(PostMessageEvent);
14898:     }
14898: 
14898:   private:
14898:     nsRefPtr<nsGlobalWindow> mSource;
14898:     nsString mCallerOrigin;
14898:     nsString mMessage;
14898:     nsRefPtr<nsGlobalWindow> mTargetWindow;
14898:     nsCOMPtr<nsIURI> mProvidedOrigin;
14898:     PRBool mTrustedCaller;
14898: };
14898: 
14898: NS_IMETHODIMP
14898: PostMessageEvent::Run()
14898: {
14898:   NS_ABORT_IF_FALSE(mTargetWindow->IsOuterWindow(),
14898:                     "should have been passed an outer window!");
14898:   NS_ABORT_IF_FALSE(!mSource || mSource->IsOuterWindow(),
14898:                     "should have been passed an outer window!");
14898: 
39378:   nsRefPtr<nsGlobalWindow> targetWindow;
39378:   if (mTargetWindow->IsClosedOrClosing() ||
39378:       !(targetWindow = mTargetWindow->GetCurrentInnerWindowInternal()) ||
39378:       targetWindow->IsClosedOrClosing())
15240:     return NS_OK;
15240: 
14898:   NS_ABORT_IF_FALSE(targetWindow->IsInnerWindow(),
14898:                     "we ordered an inner window!");
14898: 
14898:   // Ensure that any origin which might have been provided is the origin of this
14898:   // window's document.  Note that we do this *now* instead of when postMessage
14898:   // is called because the target window might have been navigated to a
14898:   // different location between then and now.  If this check happened when
14898:   // postMessage was called, it would be fairly easy for a malicious webpage to
14898:   // intercept messages intended for another site by carefully timing navigation
14898:   // of the target window so it changed location after postMessage but before
14898:   // now.
14898:   if (mProvidedOrigin) {
14898:     // Get the target's origin either from its principal or, in the case the
14898:     // principal doesn't carry a URI (e.g. the system principal), the target's
14898:     // document.
14898:     nsIPrincipal* targetPrin = targetWindow->GetPrincipal();
14898:     if (!targetPrin)
14898:       return NS_OK;
14898:     nsCOMPtr<nsIURI> targetURI;
14898:     if (NS_FAILED(targetPrin->GetURI(getter_AddRefs(targetURI))))
14898:       return NS_OK;
14898:     if (!targetURI) {
14898:       targetURI = targetWindow->mDoc->GetDocumentURI();
14898:       if (!targetURI)
14898:         return NS_OK;
14898:     }
14898: 
14898:     // Note: This is contrary to the spec with respect to file: URLs, which
14898:     //       the spec groups into a single origin, but given we intentionally
14898:     //       don't do that in other places it seems better to hold the line for
14898:     //       now.  Long-term, we want HTML5 to address this so that we can
14898:     //       be compliant while being safer.
14898:     nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
14898:     nsresult rv =
14898:       ssm->CheckSameOriginURI(mProvidedOrigin, targetURI, PR_TRUE);
14898:     if (NS_FAILED(rv))
14898:       return NS_OK;
14898:   }
14898: 
14898: 
14898:   // Create the event
14898:   nsCOMPtr<nsIDOMDocumentEvent> docEvent =
14898:     do_QueryInterface(targetWindow->mDocument);
14898:   if (!docEvent)
14898:     return NS_OK;
14898:   nsCOMPtr<nsIDOMEvent> event;
14898:   docEvent->CreateEvent(NS_LITERAL_STRING("MessageEvent"),
14898:                         getter_AddRefs(event));
14898:   if (!event)
14898:     return NS_OK;
14898: 
14898:   nsCOMPtr<nsIDOMMessageEvent> message = do_QueryInterface(event);
14898:   nsresult rv = message->InitMessageEvent(NS_LITERAL_STRING("message"),
14898:                                           PR_FALSE /* non-bubbling */,
14898:                                           PR_TRUE /* cancelable */,
14898:                                           mMessage,
14898:                                           mCallerOrigin,
14898:                                           EmptyString(),
14898:                                           mSource);
14898:   if (NS_FAILED(rv))
14898:     return NS_OK;
14898: 
14898: 
14898:   // We can't simply call dispatchEvent on the window because doing so ends
14898:   // up flipping the trusted bit on the event, and we don't want that to
14898:   // happen because then untrusted content can call postMessage on a chrome
14898:   // window if it can get a reference to it.
14898: 
46225:   nsIPresShell *shell = targetWindow->mDoc->GetShell();
14898:   nsRefPtr<nsPresContext> presContext;
14898:   if (shell)
14898:     presContext = shell->GetPresContext();
14898: 
14898:   nsCOMPtr<nsIPrivateDOMEvent> privEvent = do_QueryInterface(message);
14898:   privEvent->SetTrusted(mTrustedCaller);
20234:   nsEvent *internalEvent = privEvent->GetInternalNSEvent();
14898: 
14898:   nsEventStatus status = nsEventStatus_eIgnore;
14898:   nsEventDispatcher::Dispatch(static_cast<nsPIDOMWindow*>(mTargetWindow),
14898:                               presContext,
14898:                               internalEvent,
14898:                               message,
14898:                               &status);
14898:   return NS_OK;
14898: }
14898: 
11363: NS_IMETHODIMP
12322: nsGlobalWindow::PostMessageMoz(const nsAString& aMessage, const nsAString& aOrigin)
12322: {
14898:   // NB: Since much of what this method does must happen at event dispatch time,
14898:   //     this method does not forward to the inner window, unlike most other
14898:   //     methods.  We do this because the only time we need to refer to this
14898:   //     window, we need a reference to the outer window (the PostMessageEvent
14898:   //     ctor call), and we don't want to pay the price of forwarding to the
14898:   //     inner window for no actual benefit.  Furthermore, this function must
14898:   //     only be called from script anyway, which should only have references to
14898:   //     outer windows (and if script has an inner window we've already lost).
14898:   NS_ABORT_IF_FALSE(IsOuterWindow(), "only call this method on outer windows");
10976: 
10976:   //
10976:   // Window.postMessage is an intentional subversion of the same-origin policy.
10976:   // As such, this code must be particularly careful in the information it
10976:   // exposes to calling code.
10976:   //
10976:   // http://www.whatwg.org/specs/web-apps/current-work/multipage/section-crossDocumentMessages.html
10976:   //
10976: 
10976:   // First, get the caller's window
10976:   nsRefPtr<nsGlobalWindow> callerInnerWin = CallerInnerWindow();
10976:   if (!callerInnerWin)
10976:     return NS_OK;
14898:   NS_ABORT_IF_FALSE(callerInnerWin->IsInnerWindow(),
14898:                     "should have gotten an inner window here");
10976: 
12322:   // Compute the caller's origin either from its principal or, in the case the
12322:   // principal doesn't carry a URI (e.g. the system principal), the caller's
14898:   // document.  We must get this now instead of when the event is created and
14898:   // dispatched, because ultimately it is the identity of the calling window
14898:   // *now* that determines who sent the message (and not an identity which might
14898:   // have changed due to intervening navigations).
10976:   nsIPrincipal* callerPrin = callerInnerWin->GetPrincipal();
10976:   if (!callerPrin)
10976:     return NS_OK;
24084:   
14898:   nsCOMPtr<nsIURI> callerOuterURI;
14898:   if (NS_FAILED(callerPrin->GetURI(getter_AddRefs(callerOuterURI))))
14898:     return NS_OK;
24084: 
24084:   nsAutoString origin;
24084:   if (callerOuterURI) {
24084:     // if the principal has a URI, use that to generate the origin
24084:     nsContentUtils::GetUTFOrigin(callerPrin, origin);
24084:   }
24084:   else {
24084:     // otherwise use the URI of the document to generate origin
10976:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(callerInnerWin->mDocument);
10976:     if (!doc)
10976:       return NS_OK;
14898:     callerOuterURI = doc->GetDocumentURI();
24084:     // if the principal has a URI, use that to generate the origin
24084:     nsContentUtils::GetUTFOrigin(callerOuterURI, origin);
24084:   }
12322: 
14898:   // Convert the provided origin string into a URI for comparison purposes.
14898:   // "*" indicates no specific origin is required.
12322:   nsCOMPtr<nsIURI> providedOrigin;
14898:   if (!aOrigin.EqualsASCII("*")) {
12322:     if (NS_FAILED(NS_NewURI(getter_AddRefs(providedOrigin), aOrigin)))
12322:       return NS_ERROR_DOM_SYNTAX_ERR;
24084:     if (NS_FAILED(providedOrigin->SetUserPass(EmptyCString())) ||
24084:         NS_FAILED(providedOrigin->SetPath(EmptyCString())))
24084:       return NS_OK;
24084:   }
10976: 
14898:   // Create and asynchronously dispatch a runnable which will handle actual DOM
14898:   // event creation and dispatch.
14898:   nsRefPtr<PostMessageEvent> event =
14898:     new PostMessageEvent(nsContentUtils::IsCallerChrome()
14898:                          ? nsnull
14898:                          : callerInnerWin->GetOuterWindowInternal(),
24084:                          origin,
10976:                          aMessage,
14898:                          this,
14898:                          providedOrigin,
14898:                          nsContentUtils::IsCallerTrustedForWrite());
14898:   return NS_DispatchToCurrentThread(event);
10976: }
10976: 
    1: class nsCloseEvent : public nsRunnable {
39378: 
39378:   nsRefPtr<nsGlobalWindow> mWindow;
39378: 
    1:   nsCloseEvent(nsGlobalWindow *aWindow)
    1:     : mWindow(aWindow)
39378:   {}
39378: 
39378: public:
39378: 
39378:   static nsresult
39378:   PostCloseEvent(nsGlobalWindow* aWindow) {
39378:     nsCOMPtr<nsIRunnable> ev = new nsCloseEvent(aWindow);
39378:     nsresult rv = NS_DispatchToCurrentThread(ev);
39378:     if (NS_SUCCEEDED(rv))
39378:       aWindow->MaybeForgiveSpamCount();
39378:     return rv;
    1:   }
    1: 
    1:   NS_IMETHOD Run() {
    1:     if (mWindow)
    1:       mWindow->ReallyCloseWindow();
    1:     return NS_OK;
    1:   }
    1: 
    1: };
    1: 
37611: PRBool
37611: nsGlobalWindow::CanClose()
37611: {
37611:   if (!mDocShell)
37611:     return PR_TRUE;
37611: 
37611:   // Ask the content viewer whether the toplevel window can close.
37611:   // If the content viewer returns false, it is responsible for calling
37611:   // Close() as soon as it is possible for the window to close.
37611:   // This allows us to not close the window while printing is happening.
37611: 
37611:   nsCOMPtr<nsIContentViewer> cv;
37611:   mDocShell->GetContentViewer(getter_AddRefs(cv));
37611:   if (cv) {
37611:     PRBool canClose;
37611:     nsresult rv = cv->PermitUnload(PR_FALSE, &canClose);
37611:     if (NS_SUCCEEDED(rv) && !canClose)
37611:       return PR_FALSE;
37611: 
37611:     rv = cv->RequestWindowClose(&canClose);
37611:     if (NS_SUCCEEDED(rv) && !canClose)
37611:       return PR_FALSE;
37611:   }
37611: 
37611:   return PR_TRUE;
37611: }
37611: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Close()
    1: {
    1:   FORWARD_TO_OUTER(Close, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (IsFrame() || !mDocShell || IsInModalState()) {
    1:     // window.close() is called on a frame in a frameset, on a window
    1:     // that's already closed, or on a window for which there's
    1:     // currently a modal dialog open. Ignore such calls.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mHavePendingClose) {
    1:     // We're going to be closed anyway; do nothing since we don't want
    1:     // to double-close
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mBlockScriptedClosingFlag)
    1:   {
    1:     // A script's popup has been blocked and we don't want
    1:     // the window to be closed directly after this event,
    1:     // so the user can see that there was a blocked popup.
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Don't allow scripts from content to close windows
    1:   // that were not opened by script
    1:   if (!mHadOriginalOpener && !nsContentUtils::IsCallerTrustedForWrite()) {
    1:     PRBool allowClose =
    1:       nsContentUtils::GetBoolPref("dom.allow_scripts_to_close_windows",
    1:                                   PR_TRUE);
    1:     if (!allowClose) {
    1:       // We're blocking the close operation
    1:       // report localized error msg in JS console
    1:       nsContentUtils::ReportToConsole(
    1:           nsContentUtils::eDOM_PROPERTIES,
    1:           "WindowCloseBlockedWarning",
    1:           nsnull, 0, // No params
    1:           nsnull, // No URI.  Not clear which URI we should be using
    1:                   // here anyway
    1:           EmptyString(), 0, 0, // No source, or column/line number
    1:           nsIScriptError::warningFlag,
    1:           "DOM Window");  // Better name for the category?
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
37611:   if (!mInClose && !mIsClosed && !CanClose())
37611:     return NS_OK;
    1: 
    1:   // Fire a DOM event notifying listeners that this window is about to
    1:   // be closed. The tab UI code may choose to cancel the default
    1:   // action for this event, if so, we won't actually close the window
    1:   // (since the tab UI code will close the tab in stead). Sure, this
    1:   // could be abused by content code, but do we care? I don't think
    1:   // so...
    1: 
    1:   PRBool wasInClose = mInClose;
    1:   mInClose = PR_TRUE;
    1: 
    1:   if (!DispatchCustomEvent("DOMWindowClose")) {
    1:     // Someone chose to prevent the default action for this event, if
    1:     // so, let's not close this window after all...
    1: 
    1:     mInClose = wasInClose;
    1:     return NS_OK;
    1:   }
    1: 
37611:   return FinalClose();
37611: }
37611: 
37611: nsresult
37611: nsGlobalWindow::ForceClose()
37611: {
37611:   if (IsFrame() || !mDocShell) {
37611:     // This may be a frame in a frameset, or a window that's already closed.
37611:     // Ignore such calls.
37611: 
37611:     return NS_OK;
37611:   }
37611: 
37611:   if (mHavePendingClose) {
37611:     // We're going to be closed anyway; do nothing since we don't want
37611:     // to double-close
37611:     return NS_OK;
37611:   }
37611: 
37611:   mInClose = PR_TRUE;
37611: 
37611:   DispatchCustomEvent("DOMWindowClose");
37611: 
37611:   return FinalClose();
37611: }
37611: 
37611: nsresult
37611: nsGlobalWindow::FinalClose()
37611: {
37611:   nsresult rv;
    1:   // Flag that we were closed.
    1:   mIsClosed = PR_TRUE;
    1: 
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:     do_GetService(sJSStackContractID);
    1: 
    1:   JSContext *cx = nsnull;
    1: 
    1:   if (stack) {
    1:     stack->Peek(&cx);
    1:   }
    1: 
    1:   if (cx) {
    1:     nsIScriptContext *currentCX = nsJSUtils::GetDynamicScriptContext(cx);
    1: 
    1:     if (currentCX && currentCX == mContext) {
    1:       // We ignore the return value here.  If setting the termination function
    1:       // fails, it's better to fail to close the window than it is to crash
    1:       // (which is what would tend to happen if we did this synchronously
    1:       // here).
    1:       rv = currentCX->SetTerminationFunction(CloseWindow,
 3233:                                              static_cast<nsIDOMWindow *>
 3233:                                                         (this));
    1:       if (NS_SUCCEEDED(rv)) {
    1:         mHavePendingClose = PR_TRUE;
    1:       }
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   
    1:   // We may have plugins on the page that have issued this close from their
    1:   // event loop and because we currently destroy the plugin window with
    1:   // frames, we crash. So, if we are called from Javascript, post an event
    1:   // to really close the window.
    1:   rv = NS_ERROR_FAILURE;
    1:   if (!nsContentUtils::IsCallerChrome()) {
39378:     rv = nsCloseEvent::PostCloseEvent(this);
    1:   }
    1:   
    1:   if (NS_FAILED(rv)) {
    1:     ReallyCloseWindow();
    1:     rv = NS_OK;
    1:   } else {
    1:     mHavePendingClose = PR_TRUE;
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: void
    1: nsGlobalWindow::ReallyCloseWindow()
    1: {
    1:   FORWARD_TO_OUTER_VOID(ReallyCloseWindow, ());
    1: 
    1:   // Make sure we never reenter this method.
    1:   mHavePendingClose = PR_TRUE;
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1: 
    1:   // If there's no treeOwnerAsWin, this window must already be closed.
    1: 
    1:   if (treeOwnerAsWin) {
    1: 
    1:     // but if we're a browser window we could be in some nasty
    1:     // self-destroying cascade that we should mostly ignore
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> docItem(do_QueryInterface(mDocShell));
    1:     if (docItem) {
    1:       nsCOMPtr<nsIBrowserDOMWindow> bwin;
    1:       nsCOMPtr<nsIDocShellTreeItem> rootItem;
    1:       docItem->GetRootTreeItem(getter_AddRefs(rootItem));
    1:       nsCOMPtr<nsIDOMWindow> rootWin(do_GetInterface(rootItem));
    1:       nsCOMPtr<nsIDOMChromeWindow> chromeWin(do_QueryInterface(rootWin));
    1:       if (chromeWin)
    1:         chromeWin->GetBrowserDOMWindow(getter_AddRefs(bwin));
    1: 
    1:       if (rootWin) {
    1:         /* Normally we destroy the entire window, but not if
    1:            this DOM window belongs to a tabbed browser and doesn't
    1:            correspond to a tab. This allows a well-behaved tab
    1:            to destroy the container as it should but is a final measure
    1:            to prevent an errant tab from doing so when it shouldn't.
    1:            This works because we reach this code when we shouldn't only
    1:            in the particular circumstance that we belong to a tab
    1:            that has just been closed (and is therefore already missing
    1:            from the list of browsers) (and has an unload handler
    1:            that closes the window). */
    1:         // XXXbz now that we have mHavePendingClose, is this needed?
    1:         PRBool isTab = PR_FALSE;
    1:         if (rootWin == this ||
    1:             !bwin || (bwin->IsTabContentWindow(GetOuterWindowInternal(),
    1:                                                &isTab), isTab))
    1:           treeOwnerAsWin->Destroy();
    1:       }
    1:     }
    1: 
39378:     CleanUp(PR_FALSE);
    1:   }
    1: }
    1: 
    1: void
    1: nsGlobalWindow::EnterModalState()
    1: {
    1:   nsCOMPtr<nsIDOMWindow> top;
    1:   GetTop(getter_AddRefs(top));
    1: 
    1:   if (!top) {
    1:     NS_ERROR("Uh, EnterModalState() called w/o a reachable top window?");
    1: 
    1:     return;
    1:   }
    1: 
25722:   nsGlobalWindow* topWin =
25722:     static_cast<nsGlobalWindow*>(static_cast<nsIDOMWindow *>(top.get()));
25722:   if (topWin->mModalStateDepth == 0) {
25722:     NS_ASSERTION(!mSuspendedDoc, "Shouldn't have mSuspendedDoc here!");
25722: 
25722:     mSuspendedDoc = do_QueryInterface(topWin->GetExtantDocument());
25724:     if (mSuspendedDoc && mSuspendedDoc->EventHandlingSuppressed()) {
25722:       mSuspendedDoc->SuppressEventHandling();
25724:     } else {
25724:       mSuspendedDoc = nsnull;
25722:     }
25722:   }
25722:   topWin->mModalStateDepth++;
29105: 
29105:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
29105: 
29105:   nsIScriptContext *scx;
29105:   if (cx && (scx = GetScriptContextFromJSContext(cx))) {
29105:     scx->EnterModalState();
29105:   }
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::RunPendingTimeoutsRecursive(nsGlobalWindow *aTopWindow,
    1:                                             nsGlobalWindow *aWindow)
    1: {
    1:   nsGlobalWindow *inner;
    1: 
    1:   // Return early if we're frozen or have no inner window.
    1:   if (!(inner = aWindow->GetCurrentInnerWindowInternal()) ||
    1:       inner->IsFrozen()) {
    1:     return;
    1:   }
    1: 
    1:   inner->RunTimeout(nsnull);
    1: 
    1:   // Check again if we're frozen since running pending timeouts
    1:   // could've frozen us.
    1:   if (inner->IsFrozen()) {
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMWindowCollection> frames;
    1:   aWindow->GetFrames(getter_AddRefs(frames));
    1: 
    1:   if (!frames) {
    1:     return;
    1:   }
    1: 
    1:   PRUint32 i, length;
    1:   if (NS_FAILED(frames->GetLength(&length)) || !length) {
    1:     return;
    1:   }
    1: 
    1:   for (i = 0; i < length && aTopWindow->mModalStateDepth == 0; i++) {
    1:     nsCOMPtr<nsIDOMWindow> child;
    1:     frames->Item(i, getter_AddRefs(child));
    1: 
    1:     if (!child) {
    1:       return;
    1:     }
    1: 
    1:     nsGlobalWindow *childWin =
 3233:       static_cast<nsGlobalWindow *>
 3233:                  (static_cast<nsIDOMWindow *>
 3233:                              (child.get()));
    1: 
    1:     RunPendingTimeoutsRecursive(aTopWindow, childWin);
    1:   }
    1: }
    1: 
    1: class nsPendingTimeoutRunner : public nsRunnable
    1: {
    1: public:
    1:   nsPendingTimeoutRunner(nsGlobalWindow *aWindow)
    1:     : mWindow(aWindow)
    1:   {
    1:     NS_ASSERTION(mWindow, "mWindow is null.");
    1:   }
    1: 
    1:   NS_IMETHOD Run()
    1:   {
    1:     nsGlobalWindow::RunPendingTimeoutsRecursive(mWindow, mWindow);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   nsRefPtr<nsGlobalWindow> mWindow;
    1: };
    1: 
    1: void
    1: nsGlobalWindow::LeaveModalState()
    1: {
    1:   nsCOMPtr<nsIDOMWindow> top;
    1:   GetTop(getter_AddRefs(top));
    1: 
    1:   if (!top) {
    1:     NS_ERROR("Uh, LeaveModalState() called w/o a reachable top window?");
    1: 
    1:     return;
    1:   }
    1: 
    1:   nsGlobalWindow *topWin =
 3233:     static_cast<nsGlobalWindow *>
 3233:                (static_cast<nsIDOMWindow *>
 3233:                            (top.get()));
    1: 
    1:   topWin->mModalStateDepth--;
    1: 
    1:   if (topWin->mModalStateDepth == 0) {
    1:     nsCOMPtr<nsIRunnable> runner = new nsPendingTimeoutRunner(topWin);
    1:     if (NS_FAILED(NS_DispatchToCurrentThread(runner)))
    1:       NS_WARNING("failed to dispatch pending timeout runnable");
25722: 
25722:     if (mSuspendedDoc) {
25722:       nsCOMPtr<nsIDocument> currentDoc =
25722:         do_QueryInterface(topWin->GetExtantDocument());
26591:       mSuspendedDoc->UnsuppressEventHandlingAndFireEvents(currentDoc == mSuspendedDoc);
25722:       mSuspendedDoc = nsnull;
25722:     }
    1:   }
29105: 
29105:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
29105: 
29105:   nsIScriptContext *scx;
29105:   if (cx && (scx = GetScriptContextFromJSContext(cx))) {
29105:     scx->LeaveModalState();
29105:   }
    1: }
    1: 
    1: PRBool
    1: nsGlobalWindow::IsInModalState()
    1: {
    1:   nsCOMPtr<nsIDOMWindow> top;
    1:   GetTop(getter_AddRefs(top));
    1: 
    1:   if (!top) {
    1:     NS_ERROR("Uh, IsInModalState() called w/o a reachable top window?");
    1: 
    1:     return PR_FALSE;
    1:   }
    1: 
 3233:   return static_cast<nsGlobalWindow *>
 3233:                     (static_cast<nsIDOMWindow *>
 3233:                                 (top.get()))->mModalStateDepth != 0;
    1: }
    1: 
11693: // static
11693: void
11693: nsGlobalWindow::NotifyDOMWindowDestroyed(nsGlobalWindow* aWindow) {
11693:   nsCOMPtr<nsIObserverService> observerService =
11693:     do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
11693:   if (observerService) {
11693:     observerService->
11693:       NotifyObservers(static_cast<nsIScriptGlobalObject*>(aWindow),
11693:                       DOM_WINDOW_DESTROYED_TOPIC, nsnull);
11693:   }
11693: }
11693: 
42340: class WindowDestroyedEvent : public nsRunnable
42340: {
42340: public:
42340:   WindowDestroyedEvent(PRUint64 aID, const char* aTopic) :
42340:     mID(aID), mTopic(aTopic) {}
42340: 
42340:   NS_IMETHOD Run()
42340:   {
42340:     nsCOMPtr<nsIObserverService> observerService =
42340:       do_GetService("@mozilla.org/observer-service;1");
42340:     if (observerService) {
42340:       nsCOMPtr<nsISupportsPRUint64> wrapper =
42340:         do_CreateInstance(NS_SUPPORTS_PRUINT64_CONTRACTID);
42340:       if (wrapper) {
42340:         wrapper->SetData(mID);
42340:         observerService->NotifyObservers(wrapper, mTopic.get(), nsnull);
42340:       }
42340:     }
42340:     return NS_OK;
42340:   }
42340: 
42340: private:
42340:   PRUint64 mID;
42340:   nsCString mTopic;
42340: };
42340: 
42340: void
42340: nsGlobalWindow::NotifyWindowIDDestroyed(const char* aTopic)
42340: {
42340:   nsRefPtr<nsIRunnable> runnable = new WindowDestroyedEvent(mWindowID, aTopic);
42340:   nsresult rv = NS_DispatchToCurrentThread(runnable);
42340:   if (NS_SUCCEEDED(rv)) {
42340:     mNotifiedIDDestroyed = PR_TRUE;
42340:   }
42340: }
42340: 
 6774: void
 6774: nsGlobalWindow::InitJavaProperties()
 6774: {
 6774:   nsIScriptContext *scx = GetContextInternal();
 6774: 
 6774:   if (mDidInitJavaProperties || IsOuterWindow() || !scx || !mJSObject) {
 6774:     return;
 6774:   }
 6774: 
 6774:   // Set mDidInitJavaProperties to true here even if initialization
 6774:   // can fail. If it fails, we won't try again...
 6774:   mDidInitJavaProperties = PR_TRUE;
 6774: 
 6774:   // Check whether the plugin supports NPRuntime, if so, init through
29923:   // it.
 6774: 
29919:   nsCOMPtr<nsIPluginHost> host(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
 6774:   if (!host) {
 6774:     return;
 6774:   }
 6774: 
 6774:   mDummyJavaPluginOwner = new nsDummyJavaPluginOwner(mDoc);
 6774:   if (!mDummyJavaPluginOwner) {
 6774:     return;
 6774:   }
 6774: 
 6774:   host->InstantiateDummyJavaPlugin(mDummyJavaPluginOwner);
 6774: 
28034:   // It's possible for us (or the Java plugin, rather) to process
28034:   // events during the above call, which can lead to this window being
28034:   // torn down or what not, so re-check that the dummy plugin is still
28034:   // around.
28034:   if (!mDummyJavaPluginOwner) {
28034:     return;
28034:   }
28034: 
 6774:   nsCOMPtr<nsIPluginInstance> dummyPlugin;
 6774:   mDummyJavaPluginOwner->GetInstance(*getter_AddRefs(dummyPlugin));
 6774: 
 6774:   if (dummyPlugin) {
 6774:     // A dummy plugin was instantiated. This means we have a Java
 6774:     // plugin that supports NPRuntime. For such a plugin, the plugin
 6774:     // instantiation code defines the Java properties for us, so we're
 6774:     // done here.
 6774: 
 6774:     return;
 6774:   }
 6774: 
 6774:   // No NPRuntime enabled Java plugin found, null out the owner we
 6774:   // would have used in that case as it's no longer needed.
 6774:   mDummyJavaPluginOwner = nsnull;
 7273: }
 6774: 
11622: void*
11622: nsGlobalWindow::GetCachedXBLPrototypeHandler(nsXBLPrototypeHandler* aKey)
11622: {
11622:   void* handler = nsnull;
11622:   if (mCachedXBLPrototypeHandlers.IsInitialized()) {
11622:     mCachedXBLPrototypeHandlers.Get(aKey, &handler);
11622:   }
11622:   return handler;
11622: }
11622: 
11622: void
11622: nsGlobalWindow::CacheXBLPrototypeHandler(nsXBLPrototypeHandler* aKey,
11622:                                          nsScriptObjectHolder& aHandler)
11622: {
11622:   if (!mCachedXBLPrototypeHandlers.IsInitialized() &&
11622:       !mCachedXBLPrototypeHandlers.Init()) {
11622:     NS_ERROR("Failed to initiailize hashtable!");
11622:     return;
11622:   }
11622: 
11622:   if (!mCachedXBLPrototypeHandlers.Count()) {
11622:     // Can't use macros to get the participant because nsGlobalChromeWindow also
11622:     // runs through this code. Use QueryInterface to get the correct objects.
11622:     nsXPCOMCycleCollectionParticipant* participant;
11622:     CallQueryInterface(this, &participant);
11622:     NS_ASSERTION(participant,
11622:                  "Failed to QI to nsXPCOMCycleCollectionParticipant!");
11622: 
11622:     nsCOMPtr<nsISupports> thisSupports;
11622:     QueryInterface(NS_GET_IID(nsCycleCollectionISupports),
11622:                    getter_AddRefs(thisSupports));
11622:     NS_ASSERTION(thisSupports, "Failed to QI to nsCycleCollectionISupports!");
11622: 
11622:     nsresult rv = nsContentUtils::HoldJSObjects(thisSupports, participant);
11622:     if (NS_FAILED(rv)) {
11622:       NS_ERROR("nsContentUtils::HoldJSObjects failed!");
11622:       return;
11622:     }
11622:   }
11622: 
11622:   mCachedXBLPrototypeHandlers.Put(aKey, aHandler);
11622: }
11622: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetFrameElement(nsIDOMElement** aFrameElement)
    1: {
    1:   FORWARD_TO_OUTER(GetFrameElement, (aFrameElement), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aFrameElement = nsnull;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellTI(do_QueryInterface(mDocShell));
    1: 
    1:   if (!docShellTI) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> parent;
    1:   docShellTI->GetSameTypeParent(getter_AddRefs(parent));
    1: 
    1:   if (!parent || parent == docShellTI) {
    1:     // We're at a chrome boundary, don't expose the chrome iframe
    1:     // element to content code.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aFrameElement = mFrameElement;
    1:   NS_IF_ADDREF(*aFrameElement);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 4422: // Helper for converting window.showModalDialog() options (list of ';'
 4422: // separated name (:|=) value pairs) to a format that's parsable by
 4422: // our normal window opening code.
 4422: 
 4040: void
 4040: ConvertDialogOptions(const nsAString& aOptions, nsAString& aResult)
 4040: {
 4040:   nsAString::const_iterator end;
 4040:   aOptions.EndReading(end);
 4040: 
 4040:   nsAString::const_iterator iter;
 4040:   aOptions.BeginReading(iter);
 4040: 
 4040:   while (iter != end) {
 4040:     // Skip whitespace.
 4040:     while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
 4040:       ++iter;
 4040:     }
 4040: 
 4040:     nsAString::const_iterator name_start = iter;
 4040: 
 4040:     // Skip characters until we find whitespace, ';', ':', or '='
 4040:     while (iter != end && !nsCRT::IsAsciiSpace(*iter) &&
 4040:            *iter != ';' &&
 4040:            *iter != ':' &&
 4040:            *iter != '=') {
 4040:       ++iter;
 4040:     }
 4040: 
 4040:     nsAString::const_iterator name_end = iter;
 4040: 
 4040:     // Skip whitespace.
 4040:     while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
 4040:       ++iter;
 4040:     }
 4040: 
 4040:     if (*iter == ';') {
 4040:       // No value found, skip the ';' and keep going.
 4040:       ++iter;
 4040: 
 4040:       continue;
 4040:     }
 4040: 
 4040:     nsAString::const_iterator value_start = iter;
 4040:     nsAString::const_iterator value_end = iter;
 4040: 
 4040:     if (*iter == ':' || *iter == '=') {
 4040:       // We found name followed by ':' or '='. Look for a value.
 4040: 
 4040:       iter++; // Skip the ':' or '='
 4040: 
 4040:       // Skip whitespace.
 4040:       while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
 4040:         ++iter;
 4040:       }
 4040: 
 4040:       value_start = iter;
 4040: 
 4040:       // Skip until we find whitespace, or ';'.
 4040:       while (iter != end && !nsCRT::IsAsciiSpace(*iter) &&
 4040:              *iter != ';') {
 4040:         ++iter;
 4040:       }
 4040: 
 4040:       value_end = iter;
 4040: 
 4040:       // Skip whitespace.
 4040:       while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
 4040:         ++iter;
 4040:       }
 4040:     }
 4040: 
 4040:     const nsDependentSubstring& name = Substring(name_start, name_end);
 4040:     const nsDependentSubstring& value = Substring(value_start, value_end);
 4040: 
 4040:     if (name.LowerCaseEqualsLiteral("center")) {
 4040:       if (value.LowerCaseEqualsLiteral("on")  ||
 4040:           value.LowerCaseEqualsLiteral("yes") ||
 4040:           value.LowerCaseEqualsLiteral("1")) {
 4040:         aResult.AppendLiteral(",centerscreen=1");
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("dialogwidth")) {
 4040:       if (!value.IsEmpty()) {
 4040:         aResult.AppendLiteral(",width=");
 4040:         aResult.Append(value);
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("dialogheight")) {
 4040:       if (!value.IsEmpty()) {
 4040:         aResult.AppendLiteral(",height=");
 4040:         aResult.Append(value);
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("dialogtop")) {
 4040:       if (!value.IsEmpty()) {
 4040:         aResult.AppendLiteral(",top=");
 4040:         aResult.Append(value);
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("dialogleft")) {
 4040:       if (!value.IsEmpty()) {
 4040:         aResult.AppendLiteral(",left=");
 4040:         aResult.Append(value);
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("resizable")) {
 4040:       if (value.LowerCaseEqualsLiteral("on")  ||
 4040:           value.LowerCaseEqualsLiteral("yes") ||
 4040:           value.LowerCaseEqualsLiteral("1")) {
 4040:         aResult.AppendLiteral(",resizable=1");
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("scroll")) {
 4040:       if (value.LowerCaseEqualsLiteral("off")  ||
 4040:           value.LowerCaseEqualsLiteral("no") ||
 4040:           value.LowerCaseEqualsLiteral("0")) {
 4040:         aResult.AppendLiteral(",scrollbars=0");
 4040:       }
 4040:     }
 4040: 
 4040:     if (iter == end) {
 4040:       break;
 4040:     }
 4040: 
 4040:     iter++;
 4040:   }
 4040: }
 4040: 
 4040: NS_IMETHODIMP
 4040: nsGlobalWindow::ShowModalDialog(const nsAString& aURI, nsIVariant *aArgs,
 4040:                                 const nsAString& aOptions,
 4040:                                 nsIVariant **aRetVal)
 4040: {
 4087:   *aRetVal = nsnull;
 4087: 
22792:   NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
22792: 
 4040:   nsCOMPtr<nsIDOMWindow> dlgWin;
13096:   nsAutoString options(NS_LITERAL_STRING("-moz-internal-modal=1,status=1"));
 4422: 
 4422:   ConvertDialogOptions(aOptions, options);
 4040: 
 4040:   options.AppendLiteral(",scrollbars=1,centerscreen=1,resizable=0");
 4040: 
 4422:   // Before bringing up the window, unsuppress painting and flush
 4422:   // pending reflows.
 4422:   EnsureReflowFlushAndPaint();
 4422: 
 4040:   nsresult rv = OpenInternal(aURI, EmptyString(), options,
 4040:                              PR_FALSE,          // aDialog
 5814:                              PR_TRUE,           // aContentModal
 4040:                              PR_TRUE,           // aCalledNoScript
16266:                              PR_TRUE,           // aDoJSFixups
 4040:                              nsnull, aArgs,     // args
 4040:                              GetPrincipal(),    // aCalleePrincipal
 4040:                              nsnull,            // aJSCallerContext
 4040:                              getter_AddRefs(dlgWin));
16266: 
16266:   NS_ENSURE_SUCCESS(rv, rv);
16266:   
16266:   if (dlgWin) {
33525:     nsCOMPtr<nsIPrincipal> subjectPrincipal;
33525:     rv = nsContentUtils::GetSecurityManager()->
33525:       GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
33525:     if (NS_FAILED(rv)) {
33525:       return rv;
33525:     }
33525: 
33525:     PRBool canAccess = PR_TRUE;
33525: 
33525:     if (subjectPrincipal) {
33525:       nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
33525:         do_QueryInterface(dlgWin);
33525:       nsCOMPtr<nsIPrincipal> dialogPrincipal;
33525: 
33525:       if (objPrincipal) {
33525:         dialogPrincipal = objPrincipal->GetPrincipal();
33525: 
33525:         rv = subjectPrincipal->Subsumes(dialogPrincipal, &canAccess);
33525:         NS_ENSURE_SUCCESS(rv, rv);
33525:       } else {
33525:         // Uh, not sure what kind of dialog this is. Prevent access to
33525:         // be on the safe side...
33525: 
33525:         canAccess = PR_FALSE;
33525:       }
33525:     }
33525: 
39378:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(dlgWin));
39378: 
38439:     if (canAccess) {
 4040:       nsPIDOMWindow *inner = win->GetCurrentInnerWindow();
 4040: 
 4040:       nsCOMPtr<nsIDOMModalContentWindow> dlgInner(do_QueryInterface(inner));
 4040: 
 4040:       if (dlgInner) {
 4040:         dlgInner->GetReturnValue(aRetVal);
 4040:       }
16266:     }
39378: 
39378:     nsRefPtr<nsGlobalWindow> winInternal =
39378:       static_cast<nsGlobalWindow*>(win.get());
39378:     if (winInternal->mCallCleanUpAfterModalDialogCloses) {
39378:       winInternal->mCallCleanUpAfterModalDialogCloses = PR_FALSE;
39378:       winInternal->CleanUp(PR_TRUE);
39378:     }
33525:   }
 4040:   
 4040:   return NS_OK;
 4040: }
 4040: 
36462: class CommandDispatcher : public nsRunnable
36462: {
36462: public:
36462:   CommandDispatcher(nsIDOMXULCommandDispatcher* aDispatcher,
36462:                     const nsAString& aAction)
36462:   : mDispatcher(aDispatcher), mAction(aAction) {}
36462: 
36462:   NS_IMETHOD Run()
36462:   {
36462:     return mDispatcher->UpdateCommands(mAction);
36462:   }
36462: 
36462:   nsCOMPtr<nsIDOMXULCommandDispatcher> mDispatcher;
36462:   nsString                             mAction;
36462: };
36462: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::UpdateCommands(const nsAString& anAction)
    1: {
    1:   nsPIDOMWindow *rootWindow = nsGlobalWindow::GetPrivateRoot();
    1:   if (!rootWindow)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDOMXULDocument> xulDoc =
    1:     do_QueryInterface(rootWindow->GetExtantDocument());
    1:   // See if we contain a XUL document.
    1:   if (xulDoc) {
    1:     // Retrieve the command dispatcher and call updateCommands on it.
    1:     nsCOMPtr<nsIDOMXULCommandDispatcher> xulCommandDispatcher;
    1:     xulDoc->GetCommandDispatcher(getter_AddRefs(xulCommandDispatcher));
36462:     if (xulCommandDispatcher) {
36462:       nsContentUtils::AddScriptRunner(new CommandDispatcher(xulCommandDispatcher,
36462:                                                             anAction));
36462:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsGlobalWindow::GetBlurSuppression()
    1: {
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   PRBool suppress = PR_FALSE;
    1:   if (treeOwnerAsWin)
    1:     treeOwnerAsWin->GetBlurSuppression(&suppress);
    1:   return suppress;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetSelection(nsISelection** aSelection)
    1: {
    1:   FORWARD_TO_OUTER(GetSelection, (aSelection), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   NS_ENSURE_ARG_POINTER(aSelection);
    1:   *aSelection = nsnull;
    1: 
    1:   if (!mDocShell)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   mDocShell->GetPresShell(getter_AddRefs(presShell));
    1: 
    1:   if (!presShell)
    1:     return NS_OK;
    1:     
    1:   *aSelection = presShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
    1:   
    1:   NS_IF_ADDREF(*aSelection);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Find(const nsAString& aStr, PRBool aCaseSensitive,
    1:                      PRBool aBackwards, PRBool aWrapAround, PRBool aWholeWord,
    1:                      PRBool aSearchInFrames, PRBool aShowDialog,
    1:                      PRBool *aDidFind)
    1: {
18869:   FORWARD_TO_OUTER(Find, (aStr, aCaseSensitive, aBackwards, aWrapAround,
18869:                           aWholeWord, aSearchInFrames, aShowDialog, aDidFind),
18869:                    NS_ERROR_NOT_INITIALIZED);
18869: 
    1:   nsresult rv = NS_OK;
    1:   *aDidFind = PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIWebBrowserFind> finder(do_GetInterface(mDocShell));
22792:   NS_ENSURE_TRUE(finder, NS_ERROR_FAILURE);
    1: 
    1:   // Set the options of the search
    1:   rv = finder->SetSearchString(PromiseFlatString(aStr).get());
    1:   NS_ENSURE_SUCCESS(rv, rv);
18869:   finder->SetMatchCase(aCaseSensitive);
18869:   finder->SetFindBackwards(aBackwards);
18869:   finder->SetWrapFind(aWrapAround);
18869:   finder->SetEntireWord(aWholeWord);
18869:   finder->SetSearchFrames(aSearchInFrames);
    1: 
    1:   // the nsIWebBrowserFind is initialized to use this window
    1:   // as the search root, but uses focus to set the current search
    1:   // frame. If we're being called from JS (as here), this window
    1:   // should be the current search frame.
    1:   nsCOMPtr<nsIWebBrowserFindInFrames> framesFinder(do_QueryInterface(finder));
    1:   if (framesFinder) {
    1:     framesFinder->SetRootSearchFrame(this);   // paranoia
    1:     framesFinder->SetCurrentSearchFrame(this);
    1:   }
    1:   
    1:   // The Find API does not accept empty strings. Launch the Find Dialog.
18869:   if (aStr.IsEmpty() || aShowDialog) {
    1:     // See if the find dialog is already up using nsIWindowMediator
    1:     nsCOMPtr<nsIWindowMediator> windowMediator =
    1:       do_GetService(NS_WINDOWMEDIATOR_CONTRACTID);
    1: 
    1:     nsCOMPtr<nsIDOMWindowInternal> findDialog;
    1: 
    1:     if (windowMediator) {
    1:       windowMediator->GetMostRecentWindow(NS_LITERAL_STRING("findInPage").get(),
    1:                                           getter_AddRefs(findDialog));
    1:     }
    1: 
    1:     if (findDialog) {
    1:       // The Find dialog is already open, bring it to the top.
    1:       rv = findDialog->Focus();
    1:     } else { // Open a Find dialog
    1:       if (finder) {
    1:         nsCOMPtr<nsIDOMWindow> dialog;
    1:         rv = OpenDialog(NS_LITERAL_STRING("chrome://global/content/finddialog.xul"),
    1:                         NS_LITERAL_STRING("_blank"),
    1:                         NS_LITERAL_STRING("chrome, resizable=no, dependent=yes"),
    1:                         finder, getter_AddRefs(dialog));
    1:       }
    1:     }
    1:   } else {
    1:     // Launch the search with the passed in search string
    1:     rv = finder->FindNext(aDidFind);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: static PRBool
    1: Is8bit(const nsAString& aString)
    1: {
    1:   static const PRUnichar EIGHT_BIT = PRUnichar(~0x00FF);
    1: 
    1:   nsAString::const_iterator done_reading;
    1:   aString.EndReading(done_reading);
    1: 
    1:   // for each chunk of |aString|...
    1:   PRUint32 fragmentLength = 0;
    1:   nsAString::const_iterator iter;
    1:   for (aString.BeginReading(iter); iter != done_reading;
    1:        iter.advance(PRInt32(fragmentLength))) {
    1:     fragmentLength = PRUint32(iter.size_forward());
    1:     const PRUnichar* c = iter.get();
    1:     const PRUnichar* fragmentEnd = c + fragmentLength;
    1: 
    1:     // for each character in this chunk...
    1:     while (c < fragmentEnd)
    1:       if (*c++ & EIGHT_BIT)
    1:         return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Atob(const nsAString& aAsciiBase64String,
    1:                      nsAString& aBinaryData)
    1: {
    1:   aBinaryData.Truncate();
    1: 
    1:   if (!Is8bit(aAsciiBase64String)) {
    1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
    1:   }
    1: 
    1:   PRUint32 dataLen = aAsciiBase64String.Length();
    1: 
    1:   NS_LossyConvertUTF16toASCII base64(aAsciiBase64String);
    1:   if (base64.Length() != dataLen) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   PRInt32 resultLen = dataLen;
    1:   if (!base64.IsEmpty() && base64[dataLen - 1] == '=') {
    1:     if (base64.Length() > 1 && base64[dataLen - 2] == '=') {
    1:       resultLen = dataLen - 2;
    1:     } else {
    1:       resultLen = dataLen - 1;
    1:     }
    1:   }
    1: 
    1:   resultLen = ((resultLen * 3) / 4);
    1:   // Add 4 extra bytes (one is needed for sure for null termination)
    1:   // to the malloc size just to make sure we don't end up writing past
    1:   // the allocated memory (the PL_Base64Decode API should really
    1:   // provide a guaranteed way to figure this out w/o needing to do the
    1:   // above yourself).
 3233:   char *dest = static_cast<char *>(nsMemory::Alloc(resultLen + 4));
    1:   if (!dest) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   char *bin_data = PL_Base64Decode(base64.get(), dataLen, dest);
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (bin_data) {
    1:     CopyASCIItoUTF16(Substring(bin_data, bin_data + resultLen), aBinaryData);
    1:   } else {
    1:     rv = NS_ERROR_DOM_INVALID_CHARACTER_ERR;
    1:   }
    1: 
    1:   nsMemory::Free(dest);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Btoa(const nsAString& aBinaryData,
    1:                      nsAString& aAsciiBase64String)
    1: {
    1:   aAsciiBase64String.Truncate();
    1: 
    1:   if (!Is8bit(aBinaryData)) {
    1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
    1:   }
    1: 
    1:   char *bin_data = ToNewCString(aBinaryData);
    1:   if (!bin_data) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   PRInt32 resultLen = ((aBinaryData.Length() + 2) / 3) * 4;
    1: 
    1:   char *base64 = PL_Base64Encode(bin_data, aBinaryData.Length(), nsnull);
    1:   if (!base64) {
    1:     nsMemory::Free(bin_data);
    1: 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   CopyASCIItoUTF16(nsDependentCString(base64, resultLen), aAsciiBase64String);
    1: 
    1:   PR_Free(base64);
    1:   nsMemory::Free(bin_data);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIDOMEventTarget
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::AddEventListener(const nsAString& aType,
    1:                                  nsIDOMEventListener* aListener,
    1:                                  PRBool aUseCapture)
    1: {
29474:   FORWARD_TO_INNER_CREATE(AddEventListener, (aType, aListener, aUseCapture),
29474:                           NS_ERROR_NOT_AVAILABLE);
    1: 
37183:   return AddEventListener(aType, aListener, aUseCapture, PR_FALSE, 0);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::RemoveEventListener(const nsAString& aType,
    1:                                     nsIDOMEventListener* aListener,
    1:                                     PRBool aUseCapture)
    1: {
    1:   return RemoveGroupedEventListener(aType, aListener, aUseCapture, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::DispatchEvent(nsIDOMEvent* aEvent, PRBool* _retval)
    1: {
    1:   FORWARD_TO_INNER(DispatchEvent, (aEvent, _retval), NS_OK);
    1: 
    1:   if (!mDoc) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Obtain a presentation shell
46225:   nsIPresShell *shell = mDoc->GetShell();
39823:   nsRefPtr<nsPresContext> presContext;
    1:   if (shell) {
    1:     // Retrieve the context
    1:     presContext = shell->GetPresContext();
    1:   }
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsresult rv =
    1:     nsEventDispatcher::DispatchDOMEvent(GetOuterWindow(), nsnull, aEvent,
    1:                                         presContext, &status);
    1: 
    1:   *_retval = (status != nsEventStatus_eConsumeNoDefault);
    1:   return rv;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIDOM3EventTarget
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::AddGroupedEventListener(const nsAString & aType,
    1:                                         nsIDOMEventListener *aListener,
    1:                                         PRBool aUseCapture,
    1:                                         nsIDOMEventGroup *aEvtGrp)
    1: {
    1:   FORWARD_TO_INNER_CREATE(AddGroupedEventListener,
29474:                           (aType, aListener, aUseCapture, aEvtGrp),
29474:                           NS_ERROR_NOT_AVAILABLE);
29474: 
29474:   nsIEventListenerManager* manager = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(manager);
    1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
29474:   return manager->AddEventListenerByType(aListener, aType, flags, aEvtGrp);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::RemoveGroupedEventListener(const nsAString & aType,
    1:                                            nsIDOMEventListener *aListener,
    1:                                            PRBool aUseCapture,
    1:                                            nsIDOMEventGroup *aEvtGrp)
    1: {
    1:   FORWARD_TO_INNER(RemoveGroupedEventListener,
    1:                    (aType, aListener, aUseCapture, aEvtGrp),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (mListenerManager) {
    1:     PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1: 
    1:     mListenerManager->RemoveEventListenerByType(aListener, aType, flags,
    1:                                                 aEvtGrp);
41928:   }
41928:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::CanTrigger(const nsAString & type, PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::IsRegisteredHere(const nsAString & type, PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::AddEventListener(const nsAString& aType,
    1:                                  nsIDOMEventListener *aListener,
37183:                                  PRBool aUseCapture, PRBool aWantsUntrusted,
37183:                                  PRUint8 optional_argc)
37183: {
37183:   NS_ASSERTION(!aWantsUntrusted || optional_argc > 0,
37183:                "Won't check if this is chrome, you want to set "
37183:                "aWantsUntrusted to PR_FALSE or make the aWantsUntrusted "
37183:                "explicit by making optional_argc non-zero.");
37183: 
37184:   if (IsOuterWindow() && mInnerWindow &&
37184:       !nsContentUtils::CanCallerAccess(mInnerWindow)) {
37184:     return NS_ERROR_DOM_SECURITY_ERR;
37184:   }
37184: 
29474:   nsIEventListenerManager* manager = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(manager);
    1: 
    1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1: 
37183:   if (aWantsUntrusted ||
37183:       (optional_argc == 0 && !nsContentUtils::IsChromeDoc(mDoc))) {
    1:     flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
    1:   }
    1: 
    1:   return manager->AddEventListenerByType(aListener, aType, flags, nsnull);
    1: }
    1: 
 1418: nsresult
    1: nsGlobalWindow::AddEventListenerByIID(nsIDOMEventListener* aListener,
    1:                                       const nsIID& aIID)
    1: {
29474:   nsIEventListenerManager* manager = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(manager);
29474:   return manager->AddEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE);
    1: }
    1: 
 1418: nsresult
    1: nsGlobalWindow::RemoveEventListenerByIID(nsIDOMEventListener* aListener,
    1:                                          const nsIID& aIID)
    1: {
    1:   FORWARD_TO_INNER(RemoveEventListenerByIID, (aListener, aIID),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (mListenerManager) {
    1:     mListenerManager->RemoveEventListenerByIID(aListener, aIID,
    1:                                                NS_EVENT_FLAG_BUBBLE);
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
29474: nsIEventListenerManager*
29474: nsGlobalWindow::GetListenerManager(PRBool aCreateIfNotFound)
29474: {
29474:   FORWARD_TO_INNER_CREATE(GetListenerManager, (aCreateIfNotFound), nsnull);
    1: 
    1:   if (!mListenerManager) {
    1:     if (!aCreateIfNotFound) {
29474:       return nsnull;
    1:     }
    1: 
    1:     static NS_DEFINE_CID(kEventListenerManagerCID,
    1:                          NS_EVENTLISTENERMANAGER_CID);
29474: 
29474:     mListenerManager = do_CreateInstance(kEventListenerManagerCID);
29474:     if (mListenerManager) {
    1:       mListenerManager->SetListenerTarget(
 3233:         static_cast<nsPIDOMEventTarget*>(this));
    1:     }
29474:   }
29474: 
29474:   return mListenerManager;
    1: }
    1: 
 1418: nsresult
    1: nsGlobalWindow::GetSystemEventGroup(nsIDOMEventGroup **aGroup)
    1: {
29474:   nsIEventListenerManager* manager = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(manager);
    1:   return manager->GetSystemEventGroupLM(aGroup);
    1: }
    1: 
27700: nsIScriptContext*
27700: nsGlobalWindow::GetContextForEventHandlers(nsresult* aRv)
27700: {
27700:   nsIScriptContext* scx = GetContext();
27700:   *aRv = scx ? NS_OK : NS_ERROR_UNEXPECTED;
27700:   return scx;
16056: }
16056: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsPIDOMWindow
    1: //*****************************************************************************
    1: 
    1: nsPIDOMWindow*
    1: nsGlobalWindow::GetPrivateParent()
    1: {
    1:   FORWARD_TO_OUTER(GetPrivateParent, (), nsnull);
    1: 
    1:   nsCOMPtr<nsIDOMWindow> parent;
    1:   GetParent(getter_AddRefs(parent));
    1: 
 3233:   if (static_cast<nsIDOMWindow *>(this) == parent.get()) {
    1:     nsCOMPtr<nsIContent> chromeElement(do_QueryInterface(mChromeEventHandler));
    1:     if (!chromeElement)
    1:       return nsnull;             // This is ok, just means a null parent.
    1: 
    1:     nsIDocument* doc = chromeElement->GetDocument();
    1:     if (!doc)
    1:       return nsnull;             // This is ok, just means a null parent.
    1: 
    1:     nsIScriptGlobalObject *globalObject = doc->GetScriptGlobalObject();
    1:     if (!globalObject)
    1:       return nsnull;             // This is ok, just means a null parent.
    1: 
    1:     parent = do_QueryInterface(globalObject);
    1:   }
    1: 
    1:   if (parent) {
 3233:     return static_cast<nsGlobalWindow *>
 3233:                       (static_cast<nsIDOMWindow*>(parent.get()));
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsPIDOMWindow*
    1: nsGlobalWindow::GetPrivateRoot()
    1: {
    1:   FORWARD_TO_OUTER(GetPrivateRoot, (), nsnull);
    1: 
    1:   nsCOMPtr<nsIDOMWindow> top;
    1:   GetTop(getter_AddRefs(top));
    1: 
    1:   nsCOMPtr<nsPIDOMWindow> ptop = do_QueryInterface(top);
    1:   NS_ASSERTION(ptop, "cannot get ptop");
    1:   if (!ptop)
    1:     return nsnull;
    1: 
    1:   nsIDocShell *docShell = ptop->GetDocShell();
    1: 
    1:   // Get the chrome event handler from the doc shell, since we only
    1:   // want to deal with XUL chrome handlers and not the new kind of
    1:   // window root handler.
    1:   nsCOMPtr<nsIDOMEventTarget> chromeEventHandler;
    1:   docShell->GetChromeEventHandler(getter_AddRefs(chromeEventHandler));
    1: 
    1:   nsCOMPtr<nsIContent> chromeElement(do_QueryInterface(mChromeEventHandler));
    1:   if (chromeElement) {
    1:     nsIDocument* doc = chromeElement->GetDocument();
    1:     if (doc) {
    1:       nsIDOMWindow *parent = doc->GetWindow();
    1:       if (parent) {
    1:         parent->GetTop(getter_AddRefs(top));
    1:       }
    1:     }
    1:   }
    1: 
 3233:   return static_cast<nsGlobalWindow *>
 3233:                     (static_cast<nsIDOMWindow *>(top));
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetLocation(nsIDOMLocation ** aLocation)
    1: {
    1:   FORWARD_TO_OUTER(GetLocation, (aLocation), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aLocation = nsnull;
    1: 
    1:   if (!mLocation && mDocShell) {
    1:     mLocation = new nsLocation(mDocShell);
    1:     if (!mLocation) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aLocation = mLocation);
    1: 
    1:   return NS_OK;
    1: }
    1: 
29018: void
29018: nsGlobalWindow::ActivateOrDeactivate(PRBool aActivate)
29018: {
39698:   // Set / unset mIsActive on the top level window, which is used for the
39698:   // :-moz-window-inactive pseudoclass.
29018:   nsCOMPtr<nsIWidget> mainWidget = GetMainWidget();
39698:   if (!mainWidget)
39698:     return;
39698: 
29018:   // Get the top level widget (if the main widget is a sheet, this will
29018:   // be the sheet's top (non-sheet) parent).
29018:   nsCOMPtr<nsIWidget> topLevelWidget = mainWidget->GetSheetWindowParent();
39698:   if (!topLevelWidget) {
29018:     topLevelWidget = mainWidget;
39698:   }
29018: 
29018:   // Get the top level widget's nsGlobalWindow
29018:   nsCOMPtr<nsIDOMWindowInternal> topLevelWindow;
29018:   if (topLevelWidget == mainWidget) {
29018:     topLevelWindow = static_cast<nsIDOMWindowInternal*>(this);
29018:   } else {
29018:     // This is a workaround for the following problem:
29018:     // When a window with an open sheet loses focus, only the sheet window
29018:     // receives the NS_DEACTIVATE event. However, it's not the sheet that
39698:     // should lose the active styling, but the containing top level window.
29018:     void* clientData;
29018:     topLevelWidget->GetClientData(clientData); // clientData is nsXULWindow
29018:     nsISupports* data = static_cast<nsISupports*>(clientData);
29018:     nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(data));
29018:     topLevelWindow = do_GetInterface(req);
29018:   }
29018:   if (topLevelWindow) {
39698:     nsCOMPtr<nsPIDOMWindow> piWin(do_QueryInterface(topLevelWindow));
39698:     piWin->SetActive(aActivate);
39698:   }
39698: }
39698: 
39698: static PRBool
39698: NotifyDocumentTree(nsIDocument* aDocument, void* aData)
39698: {
39698:   aDocument->EnumerateSubDocuments(NotifyDocumentTree, nsnull);
39698:   aDocument->DocumentStatesChanged(NS_DOCUMENT_STATE_WINDOW_INACTIVE);
39698:   return PR_TRUE;
39698: }
39698: 
39698: void
39698: nsGlobalWindow::SetActive(PRBool aActive)
39698: {
39698:   nsPIDOMWindow::SetActive(aActive);
39698:   NotifyDocumentTree(mDoc, nsnull);
29546: }
    1: 
16549: void
16549: nsGlobalWindow::SetChromeEventHandler(nsPIDOMEventTarget* aChromeEventHandler)
16549: {
16549:   SetChromeEventHandlerInternal(aChromeEventHandler);
16549:   if (IsOuterWindow()) {
16549:     // update the chrome event handler on all our inner windows
16549:     for (nsGlobalWindow *inner = (nsGlobalWindow *)PR_LIST_HEAD(this);
16549:          inner != this;
16549:          inner = (nsGlobalWindow*)PR_NEXT_LINK(inner)) {
16549:       NS_ASSERTION(inner->mOuterWindow == this, "bad outer window pointer");
16549:       inner->SetChromeEventHandlerInternal(aChromeEventHandler);
16549:     }
16549:   } else if (mOuterWindow) {
16549:     // Need the cast to be able to call the protected method on a
16549:     // superclass. We could make the method public instead, but it's really
16549:     // better this way.
16549:     static_cast<nsGlobalWindow*>(mOuterWindow)->
16549:       SetChromeEventHandlerInternal(aChromeEventHandler);
16549:   }
16549: }
16549: 
43884: static PRBool IsLink(nsIContent* aContent)
43884: {
43884:   nsCOMPtr<nsIDOMHTMLAnchorElement> anchor = do_QueryInterface(aContent);
43884:   return (anchor || (aContent &&
43884:                      aContent->AttrValueIs(kNameSpaceID_XLink, nsGkAtoms::type,
43884:                                            nsGkAtoms::simple, eCaseMatters)));
43884: }
43884: 
29018: void
29018: nsGlobalWindow::SetFocusedNode(nsIContent* aNode,
29018:                                PRUint32 aFocusMethod,
29018:                                PRBool aNeedsFocus)
29018: {
29018:   FORWARD_TO_INNER_VOID(SetFocusedNode, (aNode, aFocusMethod, aNeedsFocus));
29018: 
29018:   NS_ASSERTION(!aNode || aNode->GetCurrentDoc() == mDoc,
29018:                "setting focus to a node from the wrong document");
29018: 
29018:   if (mFocusedNode != aNode) {
29018:     UpdateCanvasFocus(PR_FALSE, aNode);
29018:     mFocusedNode = aNode;
41071:     mFocusMethod = aFocusMethod & FOCUSMETHOD_MASK;
41071:     mShowFocusRingForContent = PR_FALSE;
41071:   }
41071: 
41071:   if (mFocusedNode) {
41071:     // if a node was focused by a keypress, turn on focus rings for the
43884:     // window.
43884:     if (mFocusMethod & nsIFocusManager::FLAG_BYKEY) {
42263:       mFocusByKeyOccurred = PR_TRUE;
43884:     } else if (
43884:       // otherwise, we set mShowFocusRingForContent, as we don't want this to
43884:       // be permanent for the window. On Windows, focus rings are only shown
43884:       // when the FLAG_SHOWRING flag is used. On other platforms, focus rings
43884:       // are only hidden for clicks on links.
43884: #ifndef XP_WIN
43884:       !(mFocusMethod & nsIFocusManager::FLAG_BYMOUSE) || !IsLink(aNode) ||
41071: #endif
43884:       aFocusMethod & nsIFocusManager::FLAG_SHOWRING) {
41071:         mShowFocusRingForContent = PR_TRUE;
41071:     }
29018:   }
29018: 
29018:   if (aNeedsFocus)
29018:     mNeedsFocus = aNeedsFocus;
29018: }
29018: 
29018: PRUint32
29018: nsGlobalWindow::GetFocusMethod()
29018: {
29018:   FORWARD_TO_INNER(GetFocusMethod, (), 0);
29018: 
29018:   return mFocusMethod;
29018: }
29018: 
29018: PRBool
41071: nsGlobalWindow::ShouldShowFocusRing()
41071: {
41071:   FORWARD_TO_INNER(ShouldShowFocusRing, (), PR_FALSE);
41071: 
42263:   return mShowFocusRings || mShowFocusRingForContent || mFocusByKeyOccurred;
41071: }
41071: 
41071: void
41071: nsGlobalWindow::SetKeyboardIndicators(UIStateChangeType aShowAccelerators,
41071:                                       UIStateChangeType aShowFocusRings)
41071: {
41071:   FORWARD_TO_INNER_VOID(SetKeyboardIndicators, (aShowAccelerators, aShowFocusRings));
41071: 
41071:   // only change the flags that have been modified
41071:   if (aShowAccelerators != UIStateChangeType_NoChange)
41071:     mShowAccelerators = aShowAccelerators == UIStateChangeType_Set;
41071:   if (aShowFocusRings != UIStateChangeType_NoChange)
41071:     mShowFocusRings = aShowFocusRings == UIStateChangeType_Set;
41071: 
41071:   // propagate the indicators to child windows
41071:   nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(GetDocShell());
41071:   if (node) {
41071:     PRInt32 childCount = 0;
41071:     node->GetChildCount(&childCount);
41071: 
41071:     for (PRInt32 i = 0; i < childCount; ++i) {
41071:       nsCOMPtr<nsIDocShellTreeItem> childShell;
41071:       node->GetChildAt(i, getter_AddRefs(childShell));
41071:       nsCOMPtr<nsPIDOMWindow> childWindow = do_GetInterface(childShell);
41071:       if (childWindow) {
41071:         childWindow->SetKeyboardIndicators(aShowAccelerators, aShowFocusRings);
41071:       }
41071:     }
41071:   }
41071: 
41071:   if (mHasFocus) {
41071:     // send content state notifications
41071:     nsCOMPtr<nsPresContext> presContext;
41071:     if (mDocShell) {
41071:       mDocShell->GetPresContext(getter_AddRefs(presContext));
41071:       if (presContext) {
41071:         presContext->EventStateManager()->
41071:           SetContentState(mFocusedNode, NS_EVENT_STATE_FOCUS);
41071:       }
41071:     }
41071:   }
41071: }
41071: 
41071: void
41071: nsGlobalWindow::GetKeyboardIndicators(PRBool* aShowAccelerators,
41071:                                       PRBool* aShowFocusRings)
41071: {
41071:   FORWARD_TO_INNER_VOID(GetKeyboardIndicators, (aShowAccelerators, aShowFocusRings));
41071: 
41071:   *aShowAccelerators = mShowAccelerators;
41071:   *aShowFocusRings = mShowFocusRings;
41071: }
41071: 
41071: PRBool
29018: nsGlobalWindow::TakeFocus(PRBool aFocus, PRUint32 aFocusMethod)
29018: {
29018:   FORWARD_TO_INNER(TakeFocus, (aFocus, aFocusMethod), PR_FALSE);
29018: 
29018:   if (aFocus)
41071:     mFocusMethod = aFocusMethod & FOCUSMETHOD_MASK;
29018: 
29018:   if (mHasFocus != aFocus) {
29018:     mHasFocus = aFocus;
29018:     UpdateCanvasFocus(PR_TRUE, mFocusedNode);
29018:   }
29018: 
29018:   // if mNeedsFocus is true, then the document has not yet received a
29018:   // document-level focus event. If there is a root content node, then return
29018:   // true to tell the calling focus manager that a focus event is expected. If
29018:   // there is no root content node, the document hasn't loaded enough yet, or
29018:   // there isn't one and there is no point in firing a focus event.
41634:   if (aFocus && mNeedsFocus && mDoc && mDoc->GetRootElement() != nsnull) {
29018:     mNeedsFocus = PR_FALSE;
29018:     return PR_TRUE;
29018:   }
29018: 
29018:   mNeedsFocus = PR_FALSE;
29018:   return PR_FALSE;
29018: }
29018: 
29018: void
29018: nsGlobalWindow::SetReadyForFocus()
29018: {
29018:   FORWARD_TO_INNER_VOID(SetReadyForFocus, ());
29018: 
33917:   PRBool oldNeedsFocus = mNeedsFocus;
29018:   mNeedsFocus = PR_FALSE;
29018: 
41071:   // update whether focus rings need to be shown using the state from the
41071:   // root window
41071:   nsPIDOMWindow* root = GetPrivateRoot();
41071:   if (root) {
41071:     PRBool showAccelerators, showFocusRings;
41071:     root->GetKeyboardIndicators(&showAccelerators, &showFocusRings);
41071:     mShowFocusRings = showFocusRings;
41071:   }
41071: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm)
33917:     fm->WindowShown(this, oldNeedsFocus);
29018: }
29018: 
29018: void
29018: nsGlobalWindow::PageHidden()
29018: {
29018:   FORWARD_TO_INNER_VOID(PageHidden, ());
29018: 
29018:   // the window is being hidden, so tell the focus manager that the frame is
29018:   // no longer valid. Use the persisted field to determine if the document
29018:   // is being destroyed.
29018: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm)
29018:     fm->WindowHidden(this);
29018: 
29018:   mNeedsFocus = PR_TRUE;
29018: }
29018: 
29975: nsresult
37368: nsGlobalWindow::DispatchSyncHashchange()
37368: {
37368:   FORWARD_TO_INNER(DispatchSyncHashchange, (), NS_OK);
37368:   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
37368:                "Must be safe to run script here.");
29975: 
29975:   // Don't do anything if the window is frozen.
29975:   if (IsFrozen())
29975:     return NS_OK;
29975: 
29975:   // Dispatch the hashchange event, which doesn't bubble and isn't cancelable,
29975:   // to the outer window.
29975:   return nsContentUtils::DispatchTrustedEvent(mDoc, GetOuterWindow(),
29975:                                               NS_LITERAL_STRING("hashchange"),
29975:                                               PR_FALSE, PR_FALSE);
29975: }
29975: 
37802: nsresult
37802: nsGlobalWindow::DispatchSyncPopState()
37802: {
37802:   FORWARD_TO_INNER(DispatchSyncPopState, (), NS_OK);
37802: 
37802:   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
37802:                "Must be safe to run script here.");
37802: 
37802:   // Check that PopState hasn't been pref'ed off.
37802:   if (!nsContentUtils::GetBoolPref(sPopStatePrefStr, PR_FALSE))
37802:     return NS_OK;
37802: 
37802:   nsresult rv = NS_OK;
37802: 
37802:   // Bail if the window is frozen.
37802:   if (IsFrozen()) {
37802:     return NS_OK;
37802:   }
37802: 
37802:   // Bail if there's no document or the document's readystate isn't "complete".
37802:   if (!mDoc) {
37802:     return NS_OK;
37802:   }
37802: 
37802:   nsIDocument::ReadyState readyState = mDoc->GetReadyStateEnum();
37802:   if (readyState != nsIDocument::READYSTATE_COMPLETE) {
37802:     return NS_OK;
37802:   }
37802: 
37802:   // Get the document's pending state object -- it contains the data we're
37802:   // going to send along with the popstate event.  The object is serialized as
37802:   // JSON.
37802:   nsAString& stateObjJSON = mDoc->GetPendingStateObject();
37802: 
37802:   nsCOMPtr<nsIVariant> stateObj;
37802:   // Parse the JSON, if there's any to parse.
37802:   if (!stateObjJSON.IsEmpty()) {
37802:     // Get the JSContext associated with our document. We need this for
37802:     // deserialization.
37802:     nsCOMPtr<nsIDocument> document = do_QueryInterface(mDocument);
37802:     NS_ENSURE_TRUE(document, NS_ERROR_FAILURE);
37802: 
37802:     // Get the JSContext from the document, like we do in
37802:     // nsContentUtils::GetContextFromDocument().
37802:     nsIScriptGlobalObject *sgo = document->GetScopeObject();
37802:     NS_ENSURE_TRUE(sgo, NS_ERROR_FAILURE);
37802: 
37802:     nsIScriptContext *scx = sgo->GetContext();
37802:     NS_ENSURE_TRUE(scx, NS_ERROR_FAILURE);
37802: 
37802:     JSContext *cx = (JSContext*) scx->GetNativeContext();
37802: 
37802:     // If our json call triggers a JS-to-C++ call, we want that call to use cx
37802:     // as the context.  So we push cx onto the context stack.
37802:     nsCxPusher cxPusher;
37802: 
37802:     jsval jsStateObj = JSVAL_NULL;
37802:     // Root the container which will hold our decoded state object.
39874:     nsAutoGCRoot root(&jsStateObj, &rv);
37802:     NS_ENSURE_SUCCESS(rv, rv);
37802: 
37802:     // Deserialize the state object into an nsIVariant.
37802:     nsCOMPtr<nsIJSON> json = do_GetService("@mozilla.org/dom/json;1");
37802:     NS_ENSURE_TRUE(cxPusher.Push(cx), NS_ERROR_FAILURE);
37802:     rv = json->DecodeToJSVal(stateObjJSON, cx, &jsStateObj);
37802:     NS_ENSURE_SUCCESS(rv, rv);
37802:     cxPusher.Pop();
37802: 
37802:     nsCOMPtr<nsIXPConnect> xpconnect = do_GetService(nsIXPConnect::GetCID());
37802:     NS_ENSURE_TRUE(xpconnect, NS_ERROR_FAILURE);
37802:     rv = xpconnect->JSValToVariant(cx, &jsStateObj, getter_AddRefs(stateObj));
37802:     NS_ENSURE_SUCCESS(rv, rv);
37802:   }
37802: 
37802:   // Obtain a presentation shell for use in creating a popstate event.
46225:   nsIPresShell *shell = mDoc->GetShell();
39823:   nsRefPtr<nsPresContext> presContext;
37802:   if (shell) {
37802:     presContext = shell->GetPresContext();
37802:   }
37802: 
37802:   // Create a new popstate event
37802:   nsCOMPtr<nsIDOMEvent> domEvent;
37802:   rv = nsEventDispatcher::CreateEvent(presContext, nsnull,
37802:                                       NS_LITERAL_STRING("popstateevent"),
37802:                                       getter_AddRefs(domEvent));
37802:   NS_ENSURE_SUCCESS(rv, rv);
37802: 
37802:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(domEvent);
37802:   NS_ENSURE_TRUE(privateEvent, NS_ERROR_FAILURE);
37802: 
37802:   // Initialize the popstate event, which does bubble but isn't cancellable.
37802:   nsCOMPtr<nsIDOMPopStateEvent> popstateEvent = do_QueryInterface(domEvent);
37802:   rv = popstateEvent->InitPopStateEvent(NS_LITERAL_STRING("popstate"),
37802:                                         PR_TRUE, PR_FALSE,
37802:                                         stateObj);
37802:   NS_ENSURE_SUCCESS(rv, rv);
37802: 
37802:   rv = privateEvent->SetTrusted(PR_TRUE);
37802:   NS_ENSURE_SUCCESS(rv, rv);
37802: 
37802:   nsCOMPtr<nsIDOMEventTarget> outerWindow =
37802:     do_QueryInterface(GetOuterWindow());
37802:   NS_ENSURE_TRUE(outerWindow, NS_ERROR_UNEXPECTED);
37802: 
37802:   rv = privateEvent->SetTarget(outerWindow);
37802:   NS_ENSURE_SUCCESS(rv, rv);
37802: 
37802:   PRBool dummy; // default action
37802:   return DispatchEvent(popstateEvent, &dummy);
37802: }
37802: 
37802: // Find an nsICanvasFrame under aFrame.  Only search the principal
29018: // child lists.  aFrame must be non-null.
34149: static nsCanvasFrame* FindCanvasFrame(nsIFrame* aFrame)
34149: {
34149:     nsCanvasFrame* canvasFrame = do_QueryFrame(aFrame);
29018:     if (canvasFrame) {
29018:         return canvasFrame;
29018:     }
29018: 
29018:     nsIFrame* kid = aFrame->GetFirstChild(nsnull);
29018:     while (kid) {
29018:         canvasFrame = FindCanvasFrame(kid);
29018:         if (canvasFrame) {
29018:             return canvasFrame;
29018:         }
29018:         kid = kid->GetNextSibling();
29018:     }
29018: 
29018:     return nsnull;
29018: }
29018: 
29018: //-------------------------------------------------------
29018: // Tells the HTMLFrame/CanvasFrame that is now has focus
29018: void
29018: nsGlobalWindow::UpdateCanvasFocus(PRBool aFocusChanged, nsIContent* aNewContent)
29018: {
29018:   // this is called from the inner window so use GetDocShell
29018:   nsIDocShell* docShell = GetDocShell();
29018:   if (!docShell)
29018:     return;
29018: 
29018:   nsCOMPtr<nsIEditorDocShell> editorDocShell = do_QueryInterface(docShell);
29018:   if (editorDocShell) {
29018:     PRBool editable;
29018:     editorDocShell->GetEditable(&editable);
29018:     if (editable)
29018:       return;
29018:   }
29018: 
29018:   nsCOMPtr<nsIPresShell> presShell;
29018:   docShell->GetPresShell(getter_AddRefs(presShell));
29018:   if (!presShell || !mDocument)
29018:     return;
29018: 
29018:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
41634:   Element *rootElement = doc->GetRootElement();
41634:   if (rootElement) {
29018:       if ((mHasFocus || aFocusChanged) &&
41634:           (mFocusedNode == rootElement || aNewContent == rootElement)) {
41634:           nsIFrame* frame = rootElement->GetPrimaryFrame();
29018:           if (frame) {
29018:               frame = frame->GetParent();
34149:               nsCanvasFrame* canvasFrame = do_QueryFrame(frame);
29018:               if (canvasFrame) {
41634:                   canvasFrame->SetHasFocus(mHasFocus && rootElement == aNewContent);
29018:               }
29018:           }
29018:       }
29018:   } else {
29018:       // Look for the frame the hard way
29018:       nsIFrame* frame = presShell->GetRootFrame();
29018:       if (frame) {
34149:           nsCanvasFrame* canvasFrame = FindCanvasFrame(frame);
29018:           if (canvasFrame) {
29018:               canvasFrame->SetHasFocus(PR_FALSE);
29018:           }
29018:       }      
29018:   }
29018: }
29018: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIDOMViewCSS
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetComputedStyle(nsIDOMElement* aElt,
    1:                                  const nsAString& aPseudoElt,
    1:                                  nsIDOMCSSStyleDeclaration** aReturn)
    1: {
    1:   FORWARD_TO_OUTER(GetComputedStyle, (aElt, aPseudoElt, aReturn),
    1:                    NS_ERROR_NOT_INITIALIZED);
36884: 
36884:   NS_ENSURE_ARG_POINTER(aReturn);
36884:   *aReturn = nsnull;
36884: 
36884:   if (!aElt) {
36884:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
36884:   }
36884: 
36884:   if (!mDocShell) {
36884:     return NS_OK;
36884:   }
36884: 
36884:   nsCOMPtr<nsIPresShell> presShell;
36884:   mDocShell->GetPresShell(getter_AddRefs(presShell));
36884: 
36884:   if (!presShell) {
36884:     return NS_OK;
36884:   }
36884: 
30385:   nsRefPtr<nsComputedDOMStyle> compStyle;
36884:   nsresult rv = NS_NewComputedDOMStyle(aElt, aPseudoElt, presShell,
36884:                                        getter_AddRefs(compStyle));
    1:   NS_ENSURE_SUCCESS(rv, rv);
30385: 
30385:   *aReturn = compStyle.forget().get();
30385: 
30385:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIDOMAbstractView
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetDocument(nsIDOMDocumentView ** aDocumentView)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDocumentView);
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (mDocument) {
    1:     rv = CallQueryInterface(mDocument, aDocumentView);
    1:   }
    1:   else {
    1:     *aDocumentView = nsnull;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIDOMStorageWindow
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetSessionStorage(nsIDOMStorage ** aSessionStorage)
    1: {
    1:   FORWARD_TO_INNER(GetSessionStorage, (aSessionStorage), NS_ERROR_UNEXPECTED);
    1: 
    1:   nsIPrincipal *principal = GetPrincipal();
28676:   nsIDocShell* docShell = GetDocShell();
    1: 
    1:   if (!principal || !docShell) {
    1:     return NS_OK;
    1:   }
    1: 
37608:   if (mSessionStorage) {
37608: #ifdef PR_LOGGING
37608:     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
37608:       PR_LogPrint("nsGlobalWindow %p has %p sessionStorage", this, mSessionStorage.get());
37608:     }
37608: #endif
37608:     nsCOMPtr<nsPIDOMStorage> piStorage = do_QueryInterface(mSessionStorage);
37608:     if (piStorage) {
37608:       PRBool canAccess = piStorage->CanAccess(principal);
37608:       NS_ASSERTION(canAccess,
37608:                    "window %x owned sessionStorage "
37608:                    "that could not be accessed!");
37608:       if (!canAccess) {
37608:           mSessionStorage = nsnull;
37608:       }
37608:     }
37608:   }
37608: 
37608:   if (!mSessionStorage) {
37608:     *aSessionStorage = nsnull;
37608: 
37608:     nsString documentURI;
37608:     nsCOMPtr<nsIDOM3Document> document3 = do_QueryInterface(mDoc);
37608:     if (document3)
37608:         document3->GetDocumentURI(documentURI);
37608: 
23579:     nsresult rv = docShell->GetSessionStorageForPrincipal(principal,
37608:                                                           documentURI,
23579:                                                           PR_TRUE,
37608:                                                           getter_AddRefs(mSessionStorage));
23579:     NS_ENSURE_SUCCESS(rv, rv);
23579: 
37608: #ifdef PR_LOGGING
37608:     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
37608:       PR_LogPrint("nsGlobalWindow %p tried to get a new sessionStorage %p", this, mSessionStorage.get());
37608:     }
37608: #endif
37608: 
37608:     if (!mSessionStorage) {
23579:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
23579:     }
37608:   }
37608: 
37608: #ifdef PR_LOGGING
37608:     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
37608:       PR_LogPrint("nsGlobalWindow %p returns %p sessionStorage", this, mSessionStorage.get());
37608:     }
37608: #endif
37608: 
37608:   NS_ADDREF(*aSessionStorage = mSessionStorage);
23579:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetGlobalStorage(nsIDOMStorageList ** aGlobalStorage)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aGlobalStorage);
    1: 
    1: #ifdef MOZ_STORAGE
22689:   if (!sGlobalStorageList) {
22689:     nsresult rv = NS_NewDOMStorageList(&sGlobalStorageList);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
22689:   *aGlobalStorage = sGlobalStorageList;
    1:   NS_IF_ADDREF(*aGlobalStorage);
    1: 
    1:   return NS_OK;
    1: #else
    1:   return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1: #endif
    1: }
    1: 
26323: NS_IMETHODIMP
28438: nsGlobalWindow::GetLocalStorage(nsIDOMStorage ** aLocalStorage)
26323: {
26323:   FORWARD_TO_INNER(GetLocalStorage, (aLocalStorage), NS_ERROR_UNEXPECTED);
26323: 
26323:   NS_ENSURE_ARG(aLocalStorage);
26323: 
26323:   if (!mLocalStorage) {
26323:     *aLocalStorage = nsnull;
26323: 
26323:     nsresult rv;
26323: 
28495:     PRPackedBool unused;
28495:     if (!nsDOMStorage::CanUseStorage(&unused))
28495:       return NS_ERROR_DOM_SECURITY_ERR;
28495: 
26323:     nsIPrincipal *principal = GetPrincipal();
26323:     if (!principal)
26323:       return NS_OK;
26323: 
26323:     nsCOMPtr<nsIDOMStorageManager> storageManager =
26323:       do_GetService("@mozilla.org/dom/storagemanager;1", &rv);
26323:     NS_ENSURE_SUCCESS(rv, rv);
26323: 
37608:     nsString documentURI;
37608:     nsCOMPtr<nsIDOM3Document> document3 = do_QueryInterface(mDoc);
37608:     if (document3)
37608:         document3->GetDocumentURI(documentURI);
37608: 
37608:     rv = storageManager->GetLocalStorageForPrincipal(principal,
37608:                                                      documentURI,
37608:                                                      getter_AddRefs(mLocalStorage));
26323:     NS_ENSURE_SUCCESS(rv, rv);
26323:   }
26323: 
26323:   NS_ADDREF(*aLocalStorage = mLocalStorage);
26323:   return NS_OK;
26323: }
26323: 
44204: NS_IMETHODIMP
46347: nsGlobalWindow::GetMoz_indexedDB(nsIIDBFactory** _retval)
44204: {
44204:   if (!mIndexedDB) {
46347:     mIndexedDB = mozilla::dom::indexedDB::IDBFactory::Create();
44204:     NS_ENSURE_TRUE(mIndexedDB, NS_ERROR_FAILURE);
44204:   }
44204: 
46347:   nsCOMPtr<nsIIDBFactory> request(mIndexedDB);
44204:   request.forget(_retval);
44204:   return NS_OK;
44204: }
44204: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIInterfaceRequestor
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetInterface(const nsIID & aIID, void **aSink)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSink);
    1:   *aSink = nsnull;
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIDocCharset))) {
    1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     if (mDocShell) {
    1:       nsCOMPtr<nsIDocCharset> docCharset(do_QueryInterface(mDocShell));
    1:       if (docCharset) {
    1:         *aSink = docCharset;
    1:         NS_ADDREF(((nsISupports *) *aSink));
    1:       }
    1:     }
    1:   }
    1:   else if (aIID.Equals(NS_GET_IID(nsIWebNavigation))) {
    1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     if (mDocShell) {
    1:       nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:       if (webNav) {
    1:         *aSink = webNav;
    1:         NS_ADDREF(((nsISupports *) *aSink));
    1:       }
    1:     }
    1:   }
    1: #ifdef NS_PRINTING
    1:   else if (aIID.Equals(NS_GET_IID(nsIWebBrowserPrint))) {
    1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     if (mDocShell) {
    1:       nsCOMPtr<nsIContentViewer> viewer;
    1:       mDocShell->GetContentViewer(getter_AddRefs(viewer));
    1:       if (viewer) {
    1:         nsCOMPtr<nsIWebBrowserPrint> webBrowserPrint(do_QueryInterface(viewer));
    1:         if (webBrowserPrint) {
    1:           *aSink = webBrowserPrint;
    1:           NS_ADDREF(((nsISupports *) *aSink));
    1:         }
    1:       }
    1:     }
    1:   }
    1: #endif
    1:   else if (aIID.Equals(NS_GET_IID(nsIScriptEventManager))) {
    1:     if (mDoc) {
    1:       nsIScriptEventManager* mgr = mDoc->GetScriptEventManager();
    1:       if (mgr) {
    1:         *aSink = mgr;
    1:         NS_ADDREF(((nsISupports *) *aSink));
    1:       }
    1:     }
    1:   }
    1:   else if (aIID.Equals(NS_GET_IID(nsIDOMWindowUtils))) {
    1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     nsCOMPtr<nsISupports> utils(do_QueryReferent(mWindowUtils));
    1:     if (utils) {
    1:       *aSink = utils;
    1:       NS_ADDREF(((nsISupports *) *aSink));
    1:     } else {
    1:       nsDOMWindowUtils *utilObj = new nsDOMWindowUtils(this);
    1:       nsCOMPtr<nsISupports> utilsIfc =
    1:                               NS_ISUPPORTS_CAST(nsIDOMWindowUtils *, utilObj);
    1:       if (utilsIfc) {
    1:         mWindowUtils = do_GetWeakReference(utilsIfc);
    1:         *aSink = utilsIfc;
    1:         NS_ADDREF(((nsISupports *) *aSink));
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     return QueryInterface(aIID, aSink);
    1:   }
    1: 
    1:   return *aSink ? NS_OK : NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::FireOfflineStatusEvent()
    1: {
    1:   if (!mDoc)
    1:     return;
    1:   nsAutoString name;
    1:   if (NS_IsOffline()) {
    1:     name.AssignLiteral("offline");
    1:   } else {
    1:     name.AssignLiteral("online");
    1:   }
    1:   // The event is fired at the body element, or if there is no body element,
    1:   // at the document.
    1:   nsCOMPtr<nsISupports> eventTarget = mDoc.get();
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(mDoc);
    1:   if (htmlDoc) {
    1:     nsCOMPtr<nsIDOMHTMLElement> body;
    1:     htmlDoc->GetBody(getter_AddRefs(body));
    1:     if (body) {
    1:       eventTarget = body;
    1:     }
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIDOMElement> documentElement;
    1:     mDocument->GetDocumentElement(getter_AddRefs(documentElement));
    1:     if(documentElement) {        
    1:       eventTarget = documentElement;
    1:     }
    1:   }
    1:   nsContentUtils::DispatchTrustedEvent(mDoc, eventTarget, name, PR_TRUE, PR_FALSE);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::Observe(nsISupports* aSubject, const char* aTopic,
    1:                         const PRUnichar* aData)
    1: {
    1:   if (!nsCRT::strcmp(aTopic, NS_IOSERVICE_OFFLINE_STATUS_TOPIC)) {
    1:     if (IsFrozen()) {
    1:       // if an even number of notifications arrive while we're frozen,
    1:       // we don't need to fire.
    1:       mFireOfflineStatusChangeEventOnThaw = !mFireOfflineStatusChangeEventOnThaw;
    1:     } else {
    1:       FireOfflineStatusEvent();
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (IsInnerWindow() && !nsCRT::strcmp(aTopic, "dom-storage-changed")) {
    1:     nsIPrincipal *principal;
    1:     nsresult rv;
    1: 
23579:     principal = GetPrincipal();
37608:     if (principal) {
    1:       // A global storage object changed, check to see if it's one
    1:       // this window can access.
    1: 
    1:       nsCOMPtr<nsIURI> codebase;
    1:       principal->GetURI(getter_AddRefs(codebase));
    1: 
    1:       if (!codebase) {
    1:         return NS_OK;
    1:       }
    1: 
    1:       nsCAutoString currentDomain;
    1:       rv = codebase->GetAsciiHost(currentDomain);
    1:       if (NS_FAILED(rv)) {
    1:         return NS_OK;
    1:       }
    1: 
26323:       if (!nsDOMStorageList::CanAccessDomain(NS_ConvertUTF16toUTF8(aData),
26323:                                              currentDomain)) {
    1:         // This window can't reach the global storage object for the
    1:         // domain for which the change happened, so don't fire any
    1:         // events in this window.
    1: 
    1:         return NS_OK;
    1:       }
    1:     }
    1: 
    1:     nsAutoString domain(aData);
    1: 
    1:     if (IsFrozen()) {
    1:       // This window is frozen, rather than firing the events here,
    1:       // store the domain in which the change happened and fire the
    1:       // events if we're ever thawed.
    1: 
37608:       if (!mPendingStorageEventsObsolete) {
37608:         mPendingStorageEventsObsolete = new nsDataHashtable<nsStringHashKey, PRBool>;
37608:         NS_ENSURE_TRUE(mPendingStorageEventsObsolete, NS_ERROR_OUT_OF_MEMORY);
37608: 
37608:         rv = mPendingStorageEventsObsolete->Init();
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1: 
37608:       mPendingStorageEventsObsolete->Put(domain, PR_TRUE);
37608: 
37608:       return NS_OK;
37608:     }
37608: 
37608:     nsRefPtr<nsDOMStorageEventObsolete> event = new nsDOMStorageEventObsolete();
    1:     NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
    1: 
37608:     rv = event->InitStorageEvent(NS_LITERAL_STRING("storage"), PR_FALSE, PR_FALSE, domain);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(mDocument));
    1: 
    1:     nsCOMPtr<nsIDOMEventTarget> target;
    1: 
    1:     if (htmlDoc) {
    1:       nsCOMPtr<nsIDOMHTMLElement> body;
    1:       htmlDoc->GetBody(getter_AddRefs(body));
    1: 
    1:       target = do_QueryInterface(body);
    1:     }
    1: 
    1:     if (!target) {
    1:       target = this;
    1:     }
    1: 
    1:     PRBool defaultActionEnabled;
37608:     target->DispatchEvent((nsIDOMStorageEventObsolete *)event, &defaultActionEnabled);
37608: 
37608:     return NS_OK;
37608:   }
37608: 
37608:   if (IsInnerWindow() && !nsCRT::strcmp(aTopic, "dom-storage2-changed")) {
37608:     nsIPrincipal *principal;
37608:     nsresult rv;
37608: 
37608:     nsCOMPtr<nsIDOMStorageEvent> event = do_QueryInterface(aSubject, &rv);
37608:     NS_ENSURE_SUCCESS(rv, rv);
37608: 
37608:     nsCOMPtr<nsIDOMStorage> changingStorage;
37608:     rv = event->GetStorageArea(getter_AddRefs(changingStorage));
37608:     NS_ENSURE_SUCCESS(rv, rv);
37608: 
37608:     nsCOMPtr<nsPIDOMStorage> pistorage = do_QueryInterface(changingStorage);
37608:     nsPIDOMStorage::nsDOMStorageType storageType = pistorage->StorageType();
37608: 
37608:     principal = GetPrincipal();
37608:     switch (storageType)
37608:     {
37608:     case nsPIDOMStorage::SessionStorage:
37608:     {
37608:       if (SameCOMIdentity(mSessionStorage, changingStorage)) {
37608:         // Do not fire any events for the same storage object, it's not shared
37608:         // among windows, see nsGlobalWindow::GetSessionStoarge()
37608:         return NS_OK;
37608:       }
37608: 
37608:       nsCOMPtr<nsIDOMStorage> storage = mSessionStorage;
37608:       if (!storage) {
37608:         nsIDocShell* docShell = GetDocShell();
37608:         if (principal && docShell) {
37608:           // No need to pass documentURI here, it's only needed when we want
37608:           // to create a new storage, the third paramater would be PR_TRUE
37608:           docShell->GetSessionStorageForPrincipal(principal,
37608:                                                   EmptyString(),
37608:                                                   PR_FALSE,
37608:                                                   getter_AddRefs(storage));
37608:         }
37608:       }
37608: 
37608:       if (!pistorage->IsForkOf(storage)) {
37608:         // This storage event is coming from a different doc shell,
37608:         // i.e. it is a clone, ignore this event.
37608:         return NS_OK;
37608:       }
37608: 
37608: #ifdef PR_LOGGING
37608:       if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
37608:         PR_LogPrint("nsGlobalWindow %p with sessionStorage %p passing event from %p", this, mSessionStorage.get(), pistorage.get());
37608:       }
37608: #endif
37608: 
37608:       break;
37608:     }
37608:     case nsPIDOMStorage::LocalStorage:
37608:     {
37608:       if (SameCOMIdentity(mLocalStorage, changingStorage)) {
37608:         // Do not fire any events for the same storage object, it's not shared
37608:         // among windows, see nsGlobalWindow::GetLocalStoarge()
37608:         return NS_OK;
37608:       }
37608: 
37608:       // Allow event fire only for the same principal storages
37608:       // XXX We have to use EqualsIgnoreDomain after bug 495337 lands
37608:       nsIPrincipal *storagePrincipal = pistorage->Principal();
37608:       PRBool equals;
37608: 
37608:       rv = storagePrincipal->Equals(principal, &equals);
37608:       NS_ENSURE_SUCCESS(rv, rv);
37608: 
37608:       if (!equals)
37608:         return NS_OK;
37608: 
37608:       break;
37608:     }
37608:     default:
37608:       return NS_OK;
37608:     }
37608: 
37608:     if (IsFrozen()) {
37608:       // This window is frozen, rather than firing the events here,
37608:       // store the domain in which the change happened and fire the
37608:       // events if we're ever thawed.
37608: 
37608:       mPendingStorageEvents.AppendElement(event);
37608:       return NS_OK;
37608:     }
37608: 
37608:     PRBool defaultActionEnabled;
37608:     DispatchEvent((nsIDOMStorageEvent *)event, &defaultActionEnabled);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_WARNING("unrecognized topic in nsGlobalWindow::Observe");
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
20261: static PLDHashOperator
    1: FirePendingStorageEvents(const nsAString& aKey, PRBool aData, void *userArg)
    1: {
 3233:   nsGlobalWindow *win = static_cast<nsGlobalWindow *>(userArg);
    1: 
    1:   nsCOMPtr<nsIDOMStorage> storage;
    1:   win->GetSessionStorage(getter_AddRefs(storage));
    1: 
    1:   if (storage) {
    1:     win->Observe(storage, "dom-storage-changed",
    1:                  aKey.IsEmpty() ? nsnull : PromiseFlatString(aKey).get());
    1:   }
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::FireDelayedDOMEvents()
    1: {
    1:   FORWARD_TO_INNER(FireDelayedDOMEvents, (), NS_ERROR_UNEXPECTED);
    1: 
37608:   for (PRUint32 i = 0; i < mPendingStorageEvents.Length(); ++i) {
37608:     Observe(mPendingStorageEvents[i], "dom-storage2-changed", nsnull);
37608:   }
37608: 
37608:   if (mPendingStorageEventsObsolete) {
    1:     // Fire pending storage events.
37608:     mPendingStorageEventsObsolete->EnumerateRead(FirePendingStorageEvents, this);
37608: 
37608:     delete mPendingStorageEventsObsolete;
37608:     mPendingStorageEventsObsolete = nsnull;
    1:   }
    1: 
10340:   if (mApplicationCache) {
10340:     static_cast<nsDOMOfflineResourceList*>(mApplicationCache.get())->FirePendingEvents();
10340:   }
10340: 
    1:   if (mFireOfflineStatusChangeEventOnThaw) {
    1:     mFireOfflineStatusChangeEventOnThaw = PR_FALSE;
    1:     FireOfflineStatusEvent();
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeNode> node =
    1:     do_QueryInterface(GetDocShell());
    1:   if (node) {
    1:     PRInt32 childCount = 0;
    1:     node->GetChildCount(&childCount);
    1: 
    1:     for (PRInt32 i = 0; i < childCount; ++i) {
    1:       nsCOMPtr<nsIDocShellTreeItem> childShell;
    1:       node->GetChildAt(i, getter_AddRefs(childShell));
    1:       NS_ASSERTION(childShell, "null child shell");
    1: 
    1:       nsCOMPtr<nsPIDOMWindow> pWin = do_GetInterface(childShell);
    1:       if (pWin) {
    1:         nsGlobalWindow *win =
 3233:           static_cast<nsGlobalWindow*>
 3233:                      (static_cast<nsPIDOMWindow*>(pWin));
    1:         win->FireDelayedDOMEvents();
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow: Window Control Functions
    1: //*****************************************************************************
    1: 
    1: nsIDOMWindowInternal *
    1: nsGlobalWindow::GetParentInternal()
    1: {
    1:   FORWARD_TO_OUTER(GetParentInternal, (), nsnull);
    1: 
    1:   nsIDOMWindowInternal *parentInternal = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMWindow> parent;
    1:   GetParent(getter_AddRefs(parent));
    1: 
 3233:   if (parent && parent != static_cast<nsIDOMWindow *>(this)) {
    1:     nsCOMPtr<nsIDOMWindowInternal> tmp(do_QueryInterface(parent));
    1:     NS_ASSERTION(parent, "Huh, parent not an nsIDOMWindowInternal?");
    1: 
    1:     parentInternal = tmp;
    1:   }
    1: 
    1:   return parentInternal;
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::CloseBlockScriptTerminationFunc(nsISupports *aRef)
    1: {
 3233:   nsGlobalWindow* pwin = static_cast<nsGlobalWindow*>
 3233:                                     (static_cast<nsPIDOMWindow*>(aRef));
    1:   pwin->mBlockScriptedClosingFlag = PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::OpenInternal(const nsAString& aUrl, const nsAString& aName,
    1:                              const nsAString& aOptions, PRBool aDialog,
 5814:                              PRBool aContentModal, PRBool aCalledNoScript,
 5814:                              PRBool aDoJSFixups, nsIArray *argv,
    1:                              nsISupports *aExtraArgument,
    1:                              nsIPrincipal *aCalleePrincipal,
    1:                              JSContext *aJSCallerContext,
    1:                              nsIDOMWindow **aReturn)
    1: {
    1:   FORWARD_TO_OUTER(OpenInternal, (aUrl, aName, aOptions, aDialog,
 5814:                                   aContentModal, aCalledNoScript, aDoJSFixups,
    1:                                   argv, aExtraArgument, aCalleePrincipal,
    1:                                   aJSCallerContext, aReturn),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1: #ifdef NS_DEBUG
    1:   PRUint32 argc = 0;
    1:   if (argv)
    1:       argv->GetLength(&argc);
    1: #endif
    1:   NS_PRECONDITION(!aExtraArgument || (!argv && argc == 0),
    1:                   "Can't pass in arguments both ways");
    1:   NS_PRECONDITION(!aCalledNoScript || (!argv && argc == 0),
    1:                   "Can't pass JS args when called via the noscript methods");
    1:   NS_PRECONDITION(!aJSCallerContext || !aCalledNoScript,
    1:                   "Shouldn't have caller context when called noscript");
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> chrome;
    1:   GetWebBrowserChrome(getter_AddRefs(chrome));
    1:   if (!chrome) {
    1:     // No chrome means we don't want to go through with this open call
    1:     // -- see nsIWindowWatcher.idl
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   NS_ASSERTION(mDocShell, "Must have docshell here");
    1: 
    1:   const PRBool checkForPopup =
    1:     !aDialog && !WindowExists(aName, !aCalledNoScript);
    1: 
    1:   // Note: it's very important that this be an nsXPIDLCString, since we want
    1:   // .get() on it to return nsnull until we write stuff to it.  The window
    1:   // watcher expects a null URL string if there is no URL to load.
    1:   nsXPIDLCString url;
    1:   nsresult rv = NS_OK;
    1: 
    1:   // It's important to do this security check before determining whether this
    1:   // window opening should be blocked, to ensure that we don't FireAbuseEvents
    1:   // for a window opening that wouldn't have succeeded in the first place.
    1:   if (!aUrl.IsEmpty()) {
    1:     AppendUTF16toUTF8(aUrl, url);
    1: 
    1:     /* Check whether the URI is allowed, but not for dialogs --
    1:        see bug 56851. The security of this function depends on
    1:        window.openDialog being inaccessible from web scripts */
    1:     if (url.get() && !aDialog)
    1:       rv = SecurityCheckURL(url.get());
    1:   }
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
34524:   PopupControlState abuseLevel = gPopupControlState;
    1:   if (checkForPopup) {
34524:     abuseLevel = RevisePopupAbuseLevel(abuseLevel);
34524:     if (abuseLevel >= openAbused) {
    1:       if (aJSCallerContext) {
    1:         // If script in some other window is doing a window.open on us and
    1:         // it's being blocked, then it's OK to close us afterwards, probably.
    1:         // But if we're doing a window.open on ourselves and block the popup,
    1:         // prevent this window from closing until after this script terminates
    1:         // so that whatever popup blocker UI the app has will be visible.
    1:         if (mContext == GetScriptContextFromJSContext(aJSCallerContext)) {
    1:           mBlockScriptedClosingFlag = PR_TRUE;
    1:           mContext->SetTerminationFunction(CloseBlockScriptTerminationFunc,
 3233:                                            static_cast<nsPIDOMWindow*>
 3233:                                                       (this));
    1:         }
    1:       }
    1: 
    1:       FireAbuseEvents(PR_TRUE, PR_FALSE, aUrl, aName, aOptions);
    1:       return aDoJSFixups ? NS_OK : NS_ERROR_FAILURE;
    1:     }
    1:   }    
    1: 
    1:   nsCOMPtr<nsIDOMWindow> domReturn;
    1: 
    1:   nsCOMPtr<nsIWindowWatcher> wwatch =
    1:     do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1:   NS_ENSURE_TRUE(wwatch, rv);
    1: 
    1:   NS_ConvertUTF16toUTF8 options(aOptions);
    1:   NS_ConvertUTF16toUTF8 name(aName);
    1: 
    1:   const char *options_ptr = aOptions.IsEmpty() ? nsnull : options.get();
    1:   const char *name_ptr = aName.IsEmpty() ? nsnull : name.get();
    1: 
    1:   {
    1:     // Reset popup state while opening a window to prevent the
    1:     // current state from being active the whole time a modal
    1:     // dialog is open.
    1:     nsAutoPopupStatePusher popupStatePusher(openAbused, PR_TRUE);
    1: 
    1:     if (!aCalledNoScript) {
    1:       nsCOMPtr<nsPIWindowWatcher> pwwatch(do_QueryInterface(wwatch));
    1:       NS_ASSERTION(pwwatch,
    1:                    "Unable to open windows from JS because window watcher "
    1:                    "is broken");
    1:       NS_ENSURE_TRUE(pwwatch, NS_ERROR_UNEXPECTED);
    1:         
    1:       rv = pwwatch->OpenWindowJS(this, url.get(), name_ptr, options_ptr,
    1:                                  aDialog, argv,
    1:                                  getter_AddRefs(domReturn));
    1:     } else {
    1:       // Push a null JSContext here so that the window watcher won't screw us
    1:       // up.  We do NOT want this case looking at the JS context on the stack
    1:       // when searching.  Compare comments on
    1:       // nsIDOMWindowInternal::OpenWindow and nsIWindowWatcher::OpenWindow.
 5814:       nsCOMPtr<nsIJSContextStack> stack;
 5814: 
 5814:       if (!aContentModal) {
 5814:         stack = do_GetService(sJSStackContractID);
 5814:       }
    1: 
    1:       if (stack) {
    1:         rv = stack->Push(nsnull);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1:         
    1:       rv = wwatch->OpenWindow(this, url.get(), name_ptr, options_ptr,
    1:                               aExtraArgument, getter_AddRefs(domReturn));
    1: 
    1:       if (stack) {
    1:         JSContext* cx;
    1:         stack->Pop(&cx);
    1:         NS_ASSERTION(!cx, "Unexpected JSContext popped!");
    1:       }
    1:     }
    1:   }
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // success!
    1: 
    1:   domReturn.swap(*aReturn);
    1: 
    1:   if (aDoJSFixups) {      
    1:     nsCOMPtr<nsIDOMChromeWindow> chrome_win(do_QueryInterface(*aReturn));
    1:     if (!chrome_win) {
    1:       // A new non-chrome window was created from a call to
    1:       // window.open() from JavaScript, make sure there's a document in
    1:       // the new window. We do this by simply asking the new window for
    1:       // its document, this will synchronously create an empty document
    1:       // if there is no document in the window.
    1:       // XXXbz should this just use EnsureInnerWindow()?
    1: #ifdef DEBUG_jst
    1:       {
    1:         nsCOMPtr<nsPIDOMWindow> pidomwin(do_QueryInterface(*aReturn));
    1: 
    1:         nsIDOMDocument *temp = pidomwin->GetExtantDocument();
    1: 
    1:         NS_ASSERTION(temp, "No document in new window!!!");
    1:       }
    1: #endif
    1: 
    1:       nsCOMPtr<nsIDOMDocument> doc;
    1:       (*aReturn)->GetDocument(getter_AddRefs(doc));
    1:     }
    1:   }
    1:     
    1:   if (checkForPopup) {
    1:     if (abuseLevel >= openControlled) {
 3233:       nsGlobalWindow *opened = static_cast<nsGlobalWindow *>(*aReturn);
    1:       if (!opened->IsPopupSpamWindow()) {
    1:         opened->SetPopupSpamWindow(PR_TRUE);
    1:         ++gOpenPopupSpamCount;
    1:       }
    1:     }
    1:     if (abuseLevel >= openAbused)
    1:       FireAbuseEvents(PR_FALSE, PR_TRUE, aUrl, aName, aOptions);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::CloseWindow(nsISupports *aWindow)
    1: {
    1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aWindow));
    1: 
    1:   nsGlobalWindow* globalWin =
 3233:     static_cast<nsGlobalWindow *>
 3233:                (static_cast<nsPIDOMWindow*>(win));
    1: 
    1:   // Need to post an event for closing, otherwise window and 
    1:   // presshell etc. may get destroyed while creating frames, bug 338897.
39378:   nsCloseEvent::PostCloseEvent(globalWin);
38439:   // else if OOM, better not to close. That might cause a crash.
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::ClearWindowScope(nsISupports *aWindow)
    1: {
    1:   nsCOMPtr<nsIScriptGlobalObject> sgo(do_QueryInterface(aWindow));
    1:   PRUint32 lang_id;
    1:   NS_STID_FOR_ID(lang_id) {
    1:     nsIScriptContext *scx = sgo->GetScriptContext(lang_id);
    1:     if (scx) {
    1:       void *global = sgo->GetScriptGlobal(lang_id);
    1:       scx->ClearScope(global, PR_TRUE);
    1:     }
    1:   }
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow: Timeout Functions
    1: //*****************************************************************************
    1: 
34729: PRUint32 sNestingLevel;
34729: 
    1: nsresult
    1: nsGlobalWindow::SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
    1:                                      PRInt32 interval,
    1:                                      PRBool aIsInterval, PRInt32 *aReturn)
    1: {
    1:   FORWARD_TO_INNER(SetTimeoutOrInterval, (aHandler, interval, aIsInterval, aReturn),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
 3181:   // If we don't have a document (we could have been unloaded since
 3181:   // the call to setTimeout was made), do nothing.
 3181:   if (!mDocument) {
 3181:     return NS_OK;
 3181:   }
 3181: 
34729:   PRUint32 nestingLevel = sNestingLevel + 1;
35709:   if (interval < DOM_MIN_TIMEOUT_VALUE) {
35709:     if (aIsInterval || nestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
    1:       // Don't allow timeouts less than DOM_MIN_TIMEOUT_VALUE from
    1:       // now...
    1: 
    1:       interval = DOM_MIN_TIMEOUT_VALUE;
    1:     }
35709:     else if (interval < 0) {
35709:       // Clamp negative intervals to 0.
35709: 
35709:       interval = 0;
35709:     }
35709:   }
    1: 
    1:   NS_ASSERTION(interval >= 0, "DOM_MIN_TIMEOUT_VALUE lies");
    1:   PRUint32 realInterval = interval;
    1: 
    1:   // Make sure we don't proceed with a interval larger than our timer
    1:   // code can handle.
    1:   if (realInterval > PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE)) {
    1:     realInterval = PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE);
    1:   }
    1: 
    1:   nsTimeout *timeout = new nsTimeout();
    1:   if (!timeout)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // Increment the timeout's reference count to represent this function's hold
    1:   // on the timeout.
    1:   timeout->AddRef();
    1: 
    1:   if (aIsInterval) {
    1:     timeout->mInterval = realInterval;
    1:   }
    1:   timeout->mScriptHandler = aHandler;
    1: 
    1:   // Get principal of currently executing code, save for execution of timeout.
 3286:   // If our principals subsume the subject principal then use the subject
 3286:   // principal. Otherwise, use our principal to avoid running script in
 3286:   // elevated principals.
    1: 
    1:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
    1:   nsresult rv;
    1:   rv = nsContentUtils::GetSecurityManager()->
    1:     GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
    1:   if (NS_FAILED(rv)) {
    1:     timeout->Release();
    1: 
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   PRBool subsumes = PR_FALSE;
    1:   nsCOMPtr<nsIPrincipal> ourPrincipal = GetPrincipal();
    1: 
 3286:   // Note the direction of this test: We don't allow setTimeouts running with
 3286:   // chrome privileges on content windows, but we do allow setTimeouts running
 3286:   // with content privileges on chrome windows (where they can't do very much,
 3286:   // of course).
    1:   rv = ourPrincipal->Subsumes(subjectPrincipal, &subsumes);
    1:   if (NS_FAILED(rv)) {
    1:     timeout->Release();
    1: 
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (subsumes) {
    1:     timeout->mPrincipal = subjectPrincipal;
    1:   } else {
 3286:     timeout->mPrincipal = ourPrincipal;
    1:   }
    1: 
    1:   PRTime delta = (PRTime)realInterval * PR_USEC_PER_MSEC;
    1: 
25074:   if (!IsFrozen() && !mTimeoutsSuspendDepth) {
    1:     // If we're not currently frozen, then we set timeout->mWhen to be the
    1:     // actual firing time of the timer (i.e., now + delta). We also actually
    1:     // create a timer and fire it off.
    1: 
    1:     timeout->mWhen = PR_Now() + delta;
    1: 
    1:     timeout->mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
    1:     if (NS_FAILED(rv)) {
    1:       timeout->Release();
    1: 
    1:       return rv;
    1:     }
    1: 
    1:     rv = timeout->mTimer->InitWithFuncCallback(TimerCallback, timeout,
    1:                                                realInterval,
    1:                                                nsITimer::TYPE_ONE_SHOT);
    1:     if (NS_FAILED(rv)) {
    1:       timeout->Release();
    1: 
    1:       return rv;
    1:     }
    1: 
    1:     // The timeout is now also held in the timer's closure.
    1:     timeout->AddRef();
    1:   } else {
    1:     // If we are frozen, however, then we instead simply set timeout->mWhen to
    1:     // be the "time remaining" in the timeout (i.e., the interval itself). We
    1:     // don't create a timer for it, since that will happen when we are thawed
    1:     // and the timeout will then get a timer and run to completion.
    1: 
    1:     timeout->mWhen = delta;
    1:   }
    1: 
    1:   timeout->mWindow = this;
    1: 
34729:   if (!aIsInterval) {
34729:     timeout->mNestingLevel = nestingLevel;
34729:   }
34729: 
    1:   // No popups from timeouts by default
    1:   timeout->mPopupState = openAbused;
    1: 
    1:   if (gRunningTimeoutDepth == 0 && gPopupControlState < openAbused) {
    1:     // This timeout is *not* set from another timeout and it's set
    1:     // while popups are enabled. Propagate the state to the timeout if
    1:     // its delay (interval) is equal to or less than what
    1:     // "dom.disable_open_click_delay" is set to (in ms).
    1: 
    1:     PRInt32 delay =
    1:       nsContentUtils::GetIntPref("dom.disable_open_click_delay");
    1: 
    1:     if (interval <= delay) {
    1:       timeout->mPopupState = gPopupControlState;
    1:     }
    1:   }
    1: 
    1:   InsertTimeoutIntoList(timeout);
    1: 
    1:   timeout->mPublicId = ++mTimeoutPublicIdCounter;
    1:   *aReturn = timeout->mPublicId;
    1: 
    1:   // Our hold on the timeout is expiring. Note that this should not actually
    1:   // free the timeout (since the list should have taken ownership as well).
    1:   timeout->Release();
    1: 
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::SetTimeoutOrInterval(PRBool aIsInterval, PRInt32 *aReturn)
    1: {
 4427:   // This needs to forward to the inner window, but since the current
 4427:   // inner may not be the inner in the calling scope, we need to treat
 4427:   // this specially here as we don't want timeouts registered in a
 4427:   // dying inner window to get registered and run on the current inner
 4427:   // window. To get this right, we need to forward this call to the
 4427:   // inner window that's calling window.setTimeout().
 4427: 
 4427:   if (IsOuterWindow()) {
10976:     nsGlobalWindow* callerInner = CallerInnerWindow();
 4427:     NS_ENSURE_TRUE(callerInner, NS_ERROR_NOT_AVAILABLE);
 4427: 
 4427:     // If the caller and the callee share the same outer window,
 4427:     // forward to the callee inner. Else, we forward to the current
 4427:     // inner (e.g. someone is calling setTimeout() on a reference to
 4427:     // some other window).
 4427: 
 4433:     if (callerInner->GetOuterWindow() == this &&
 4433:         callerInner->IsInnerWindow()) {
 4427:       return callerInner->SetTimeoutOrInterval(aIsInterval, aReturn);
 4427:     }
 4427: 
    1:     FORWARD_TO_INNER(SetTimeoutOrInterval, (aIsInterval, aReturn),
    1:                      NS_ERROR_NOT_INITIALIZED);
 4427:   }
    1: 
    1:   PRInt32 interval = 0;
 3106:   PRBool isInterval = aIsInterval;
    1:   nsCOMPtr<nsIScriptTimeoutHandler> handler;
10986:   nsresult rv = NS_CreateJSTimeoutHandler(this,
 3106:                                           &isInterval,
    1:                                           &interval,
    1:                                           getter_AddRefs(handler));
    1:   if (NS_FAILED(rv))
    1:     return (rv == NS_ERROR_DOM_TYPE_ERR) ? NS_OK : rv;
    1: 
 3106:   return SetTimeoutOrInterval(handler, interval, isInterval, aReturn);
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
    1: {
    1:   // If a modal dialog is open for this window, return early. Pending
    1:   // timeouts will run when the modal dialog is dismissed.
25074:   if (IsInModalState() || mTimeoutsSuspendDepth) {
    1:     return;
    1:   }
    1: 
42480:   NS_TIME_FUNCTION;
42480: 
    1:   NS_ASSERTION(IsInnerWindow(), "Timeout running on outer window!");
    1:   NS_ASSERTION(!IsFrozen(), "Timeout running on a window in the bfcache!");
    1: 
    1:   nsTimeout *nextTimeout, *timeout;
    1:   nsTimeout *last_expired_timeout, *last_insertion_point;
    1:   nsTimeout dummy_timeout;
    1:   PRUint32 firingDepth = mTimeoutFiringDepth + 1;
    1: 
    1:   // Make sure that the window and the script context don't go away as
    1:   // a result of running timeouts
    1:   nsCOMPtr<nsIScriptGlobalObject> windowKungFuDeathGrip(this);
    1: 
    1:   // A native timer has gone off. See which of our timeouts need
    1:   // servicing
    1:   PRTime now = PR_Now();
    1:   PRTime deadline;
    1: 
    1:   if (aTimeout && aTimeout->mWhen > now) {
    1:     // The OS timer fired early (yikes!), and possibly out of order
    1:     // too. Set |deadline| to be the time when the OS timer *should*
    1:     // have fired so that any timers that *should* have fired before
    1:     // aTimeout *will* be fired now. This happens most of the time on
    1:     // Win2k.
    1: 
    1:     deadline = aTimeout->mWhen;
    1:   } else {
    1:     deadline = now;
    1:   }
    1: 
    1:   // The timeout list is kept in deadline order. Discover the latest
    1:   // timeout whose deadline has expired. On some platforms, native
    1:   // timeout events fire "early", so we need to test the timer as well
    1:   // as the deadline.
    1:   last_expired_timeout = nsnull;
    1:   for (timeout = FirstTimeout(); IsTimeout(timeout); timeout = timeout->Next()) {
    1:     if (((timeout == aTimeout) || (timeout->mWhen <= deadline)) &&
    1:         (timeout->mFiringDepth == 0)) {
    1:       // Mark any timeouts that are on the list to be fired with the
    1:       // firing depth so that we can reentrantly run timeouts
    1:       timeout->mFiringDepth = firingDepth;
    1:       last_expired_timeout = timeout;
    1:     }
    1:   }
    1: 
    1:   // Maybe the timeout that the event was fired for has been deleted
    1:   // and there are no others timeouts with deadlines that make them
    1:   // eligible for execution yet. Go away.
    1:   if (!last_expired_timeout) {
    1:     return;
    1:   }
    1: 
    1:   // Insert a dummy timeout into the list of timeouts between the
    1:   // portion of the list that we are about to process now and those
    1:   // timeouts that will be processed in a future call to
    1:   // win_run_timeout(). This dummy timeout serves as the head of the
    1:   // list for any timeouts inserted as a result of running a timeout.
    1:   dummy_timeout.mFiringDepth = firingDepth;
    1:   PR_INSERT_AFTER(&dummy_timeout, last_expired_timeout);
    1: 
    1:   // Don't let ClearWindowTimeouts throw away our stack-allocated
    1:   // dummy timeout.
    1:   dummy_timeout.AddRef();
    1:   dummy_timeout.AddRef();
    1: 
    1:   last_insertion_point = mTimeoutInsertionPoint;
    1:   mTimeoutInsertionPoint = &dummy_timeout;
    1: 
    1:   for (timeout = FirstTimeout();
27828:        timeout != &dummy_timeout && !IsFrozen();
    1:        timeout = nextTimeout) {
    1:     nextTimeout = timeout->Next();
    1: 
    1:     if (timeout->mFiringDepth != firingDepth) {
    1:       // We skip the timeout since it's on the list to run at another
    1:       // depth.
    1: 
    1:       continue;
    1:     }
    1: 
27828:     if (mTimeoutsSuspendDepth) {
27828:       // Some timer did suspend us. Make sure the
27828:       // rest of the timers get executed later.
27828:       timeout->mFiringDepth = 0;
27828:       continue;
27828:     }
27828: 
    1:     // The timeout is on the list to run at this depth, go ahead and
    1:     // process it.
    1: 
    1:     // Get the script context (a strong ref to prevent it going away)
    1:     // for this timeout and ensure the script language is enabled.
    1:     nsCOMPtr<nsIScriptContext> scx = GetScriptContextInternal(
    1:                                 timeout->mScriptHandler->GetScriptTypeID());
    1: 
    1:     if (!scx) {
    1:       // No context means this window was closed or never properly
    1:       // initialized for this language.
    1:       continue;
    1:     }
    1: 
    1:     // The "scripts disabled" concept is still a little vague wrt
    1:     // multiple languages.  Prepare for the day when languages can be
    1:     // disabled independently of the other languages...
    1:     if (!scx->GetScriptsEnabled()) {
    1:       // Scripts were enabled once in this window (unless aTimeout ==
    1:       // nsnull) but now scripts are disabled (we might be in
    1:       // print-preview, for instance), this means we shouldn't run any
    1:       // timeouts at this point.
    1:       //
    1:       // If scripts are enabled for this language in this window again
    1:       // we'll fire the timeouts that are due at that point.
    1:       continue;
    1:     }
    1: 
    1:     // This timeout is good to run
    1:     nsTimeout *last_running_timeout = mRunningTimeout;
    1:     mRunningTimeout = timeout;
    1:     timeout->mRunning = PR_TRUE;
    1: 
    1:     // Push this timeout's popup control state, which should only be
    1:     // eabled the first time a timeout fires that was created while
    1:     // popups were enabled and with a delay less than
    1:     // "dom.disable_open_click_delay".
    1:     nsAutoPopupStatePusher popupStatePusher(timeout->mPopupState);
    1: 
    1:     // Clear the timeout's popup state, if any, to prevent interval
    1:     // timeouts from repeatedly opening poups.
    1:     timeout->mPopupState = openAbused;
    1: 
    1:     // Hold on to the timeout in case mExpr or mFunObj releases its
    1:     // doc.
    1:     timeout->AddRef();
    1: 
    1:     ++gRunningTimeoutDepth;
    1:     ++mTimeoutFiringDepth;
    1: 
34729:     PRBool trackNestingLevel = !timeout->mInterval;
34729:     PRUint32 nestingLevel;
34729:     if (trackNestingLevel) {
34729:       nestingLevel = sNestingLevel;
34729:       sNestingLevel = timeout->mNestingLevel;
34729:     }
34729: 
    1:     nsCOMPtr<nsIScriptTimeoutHandler> handler(timeout->mScriptHandler);
    1:     void *scriptObject = handler->GetScriptObject();
    1:     if (!scriptObject) {
    1:       // Evaluate the timeout expression.
    1:       const PRUnichar *script = handler->GetHandlerText();
    1:       NS_ASSERTION(script, "timeout has no script nor handler text!");
    1: 
    1:       const char *filename = nsnull;
    1:       PRUint32 lineNo = 0;
    1:       handler->GetLocation(&filename, &lineNo);
    1: 
42480:       NS_TIME_FUNCTION_MARK("(file: %s, line: %d)", filename, lineNo);
42480: 
    1:       PRBool is_undefined;
    1:       scx->EvaluateString(nsDependentString(script), 
    1:                           GetScriptGlobal(handler->GetScriptTypeID()),
    1:                           timeout->mPrincipal, filename, lineNo,
    1:                           handler->GetScriptVersion(), nsnull,
    1:                           &is_undefined);
    1:     } else {
    1:       // Let the script handler know about the "secret" final argument that
    1:       // indicates timeout lateness in milliseconds
    1:       PRTime lateness = now - timeout->mWhen;
    1: 
    1:       // Make sure to cast the unsigned PR_USEC_PER_MSEC to signed
    1:       // PRTime to make the division do the right thing on 64-bit
    1:       // platforms whether lateness is positive or negative.
    1:       handler->SetLateness((PRIntervalTime)(lateness /
    1:                                             (PRTime)PR_USEC_PER_MSEC));
    1: 
    1:       nsCOMPtr<nsIVariant> dummy;
 3233:       nsCOMPtr<nsISupports> me(static_cast<nsIDOMWindow *>(this));
    1:       scx->CallEventHandler(me,
    1:                             GetScriptGlobal(handler->GetScriptTypeID()),
    1:                             scriptObject, handler->GetArgv(),
    1:                             // XXXmarkh - consider allowing CallEventHandler to
    1:                             // accept nsnull?
    1:                             getter_AddRefs(dummy));
    1: 
    1:     }
    1:     handler = nsnull; // drop reference before dropping timeout refs.
    1: 
34729:     if (trackNestingLevel) {
34729:       sNestingLevel = nestingLevel;
34729:     }
34729: 
    1:     --mTimeoutFiringDepth;
    1:     --gRunningTimeoutDepth;
    1: 
    1:     mRunningTimeout = last_running_timeout;
    1:     timeout->mRunning = PR_FALSE;
    1: 
    1:     // We ignore any failures from calling EvaluateString() or
    1:     // CallEventHandler() on the context here since we're in a loop
    1:     // where we're likely to be running timeouts whose OS timers
    1:     // didn't fire in time and we don't want to not fire those timers
    1:     // now just because execution of one timer failed. We can't
    1:     // propagate the error to anyone who cares about it from this
    1:     // point anyway, and the script context should have already reported
    1:     // the script error in the usual way - so we just drop it.
    1: 
    1:     // If all timeouts were cleared and |timeout != aTimeout| then
    1:     // |timeout| may be the last reference to the timeout so check if
    1:     // it was cleared before releasing it.
    1:     PRBool timeout_was_cleared = timeout->mCleared;
    1: 
    1:     timeout->Release();
    1: 
    1:     if (timeout_was_cleared) {
    1:       // The running timeout's window was cleared, this means that
    1:       // ClearAllTimeouts() was called from a *nested* call, possibly
    1:       // through a timeout that fired while a modal (to this window)
    1:       // dialog was open or through other non-obvious paths.
    1: 
    1:       mTimeoutInsertionPoint = last_insertion_point;
    1: 
    1:       return;
    1:     }
    1: 
    1:     PRBool isInterval = PR_FALSE;
    1: 
    1:     // If we have a regular interval timer, we re-schedule the
    1:     // timeout, accounting for clock drift.
    1:     if (timeout->mInterval) {
34804:       // Compute time to next timeout for interval timer.
 2033:       PRTime nextInterval = (PRTime)timeout->mInterval * PR_USEC_PER_MSEC;
34804: 
34804:       // Make sure nextInterval is at least DOM_MIN_TIMEOUT_VALUE.
34804:       // Note: We must cast the rhs expression to PRTime to work
34804:       // around what looks like a compiler bug on x86_64.
34804:       if (nextInterval < (PRTime)(DOM_MIN_TIMEOUT_VALUE * PR_USEC_PER_MSEC)) {
34804:          nextInterval = DOM_MIN_TIMEOUT_VALUE * PR_USEC_PER_MSEC;
34804:       }
34804: 
34804:       // If we're running pending timeouts because they've been temporarily
34804:       // disabled (!aTimeout), set the next interval to be relative to "now",
34804:       // and not to when the timeout that was pending should have fired.  Also
34804:       // check if the next interval timeout is overdue.  If so, then restart
34804:       // the interval from now.
 2033:       if (!aTimeout || nextInterval + timeout->mWhen <= now)
 2033:         nextInterval += now;
 2033:       else
 2033:         nextInterval += timeout->mWhen;
 2033: 
    1:       PRTime delay = nextInterval - PR_Now();
    1: 
34804:       // And make sure delay is nonnegative; that might happen if the timer
34804:       // thread is firing our timers somewhat early.
34804:       if (delay < 0) {
34804:         delay = 0;
    1:       }
    1: 
    1:       if (timeout->mTimer) {
    1:         timeout->mWhen = nextInterval;
    1: 
    1:         // Reschedule the OS timer. Don't bother returning any error
    1:         // codes if this fails since the callers of this method
    1:         // doesn't care about them nobody who cares about them
    1:         // anyways.
    1: 
    1:         // Make sure to cast the unsigned PR_USEC_PER_MSEC to signed
    1:         // PRTime to make the division do the right thing on 64-bit
    1:         // platforms whether delay is positive or negative (which we
    1:         // know is always positive here, but cast anyways for
    1:         // consistency).
    1:         nsresult rv = timeout->mTimer->
    1:           InitWithFuncCallback(TimerCallback, timeout,
    1:                                (PRInt32)(delay / (PRTime)PR_USEC_PER_MSEC),
    1:                                nsITimer::TYPE_ONE_SHOT);
    1: 
    1:         if (NS_FAILED(rv)) {
    1:           NS_ERROR("Error initializing timer for DOM timeout!");
    1: 
    1:           // We failed to initialize the new OS timer, this timer does
    1:           // us no good here so we just cancel it (just in case) and
    1:           // null out the pointer to the OS timer, this will release the
    1:           // OS timer. As we continue executing the code below we'll end
    1:           // up deleting the timeout since it's not an interval timeout
    1:           // any more (since timeout->mTimer == nsnull).
    1:           timeout->mTimer->Cancel();
    1:           timeout->mTimer = nsnull;
    1: 
    1:           // Now that the OS timer no longer has a reference to the
    1:           // timeout we need to drop that reference.
    1:           timeout->Release();
    1:         }
    1:       } else {
25721:         NS_ASSERTION(IsFrozen() || mTimeoutsSuspendDepth,
25721:                      "How'd our timer end up null if we're not frozen or "
25721:                      "suspended?");
    1: 
    1:         timeout->mWhen = delay;
    1:         isInterval = PR_TRUE;
    1:       }
    1:     }
    1: 
    1:     if (timeout->mTimer) {
    1:       if (timeout->mInterval) {
    1:         isInterval = PR_TRUE;
    1:       } else {
    1:         // The timeout still has an OS timer, and it's not an
    1:         // interval, that means that the OS timer could still fire (if
    1:         // it didn't already, i.e. aTimeout == timeout), cancel the OS
24114:         // timer and release its reference to the timeout.
    1:         timeout->mTimer->Cancel();
    1:         timeout->mTimer = nsnull;
    1: 
    1:         timeout->Release();
    1:       }
    1:     }
    1: 
    1:     // Running a timeout can cause another timeout to be deleted, so
    1:     // we need to reset the pointer to the following timeout.
    1:     nextTimeout = timeout->Next();
    1: 
    1:     PR_REMOVE_LINK(timeout);
    1: 
    1:     if (isInterval) {
    1:       // Reschedule an interval timeout. Insert interval timeout
    1:       // onto list sorted in deadline order.
25838:       // AddRefs timeout.
    1:       InsertTimeoutIntoList(timeout);
    1:     }
25838: 
25838:     // Release the timeout struct since it's possibly out of the list
25838:     timeout->Release();
    1:   }
    1: 
    1:   // Take the dummy timeout off the head of the list
    1:   PR_REMOVE_LINK(&dummy_timeout);
    1: 
    1:   mTimeoutInsertionPoint = last_insertion_point;
    1: }
    1: 
    1: nsrefcnt
    1: nsTimeout::Release()
    1: {
    1:   if (--mRefCnt > 0)
    1:     return mRefCnt;
    1: 
    1:   // language specific cleanup done as mScriptHandler destructs...
    1: 
    1:   // Kill the timer if it is still alive.
    1:   if (mTimer) {
    1:     mTimer->Cancel();
    1:     mTimer = nsnull;
    1:   }
    1: 
    1:   delete this;
    1:   return 0;
    1: }
    1: 
    1: nsrefcnt
    1: nsTimeout::AddRef()
    1: {
    1:   return ++mRefCnt;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsGlobalWindow::ClearTimeoutOrInterval(PRInt32 aTimerID)
    1: {
    1:   FORWARD_TO_INNER(ClearTimeoutOrInterval, (aTimerID), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   PRUint32 public_id = (PRUint32)aTimerID;
    1:   nsTimeout *timeout;
    1: 
    1:   for (timeout = FirstTimeout();
    1:        IsTimeout(timeout);
    1:        timeout = timeout->Next()) {
    1:     if (timeout->mPublicId == public_id) {
    1:       if (timeout->mRunning) {
    1:         /* We're running from inside the timeout. Mark this
    1:            timeout for deferred deletion by the code in
    1:            RunTimeout() */
    1:         timeout->mInterval = 0;
    1:       }
    1:       else {
    1:         /* Delete the timeout from the pending timeout list */
    1:         PR_REMOVE_LINK(timeout);
    1: 
    1:         if (timeout->mTimer) {
    1:           timeout->mTimer->Cancel();
    1:           timeout->mTimer = nsnull;
    1:           timeout->Release();
    1:         }
    1:         timeout->Release();
    1:       }
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // A JavaScript specific version.
    1: nsresult
    1: nsGlobalWindow::ClearTimeoutOrInterval()
    1: {
    1:   FORWARD_TO_INNER(ClearTimeoutOrInterval, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult rv = NS_OK;
10286:   nsAXPCNativeCallContext *ncc = nsnull;
    1: 
    1:   rv = nsContentUtils::XPConnect()->
10286:     GetCurrentNativeCallContext(&ncc);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!ncc)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   JSContext *cx = nsnull;
    1: 
    1:   rv = ncc->GetJSContext(&cx);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 argc;
    1: 
    1:   ncc->GetArgc(&argc);
    1: 
    1:   if (argc < 1) {
    1:     // No arguments, return early.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   jsval *argv = nsnull;
    1: 
    1:   ncc->GetArgvPtr(&argv);
    1: 
    1:   int32 timer_id;
    1: 
    1:   JSAutoRequest ar(cx);
    1: 
18869:   // XXXjst: Can we deal with this w/o using GetCurrentNativeCallContext()
    1:   if (argv[0] == JSVAL_VOID || !::JS_ValueToInt32(cx, argv[0], &timer_id) ||
    1:       timer_id <= 0) {
    1:     // Undefined or non-positive number passed as argument, return
    1:     // early. Make sure that JS_ValueToInt32 didn't set an exception.
    1: 
    1:     ::JS_ClearPendingException(cx);
    1:     return NS_OK;
    1:   }
    1: 
    1:   return ClearTimeoutOrInterval(timer_id);
    1: }
    1: 
    1: void
    1: nsGlobalWindow::ClearAllTimeouts()
    1: {
    1:   nsTimeout *timeout, *nextTimeout;
    1: 
    1:   for (timeout = FirstTimeout(); IsTimeout(timeout); timeout = nextTimeout) {
    1:     /* If RunTimeout() is higher up on the stack for this
    1:        window, e.g. as a result of document.write from a timeout,
    1:        then we need to reset the list insertion point for
    1:        newly-created timeouts in case the user adds a timeout,
    1:        before we pop the stack back to RunTimeout. */
    1:     if (mRunningTimeout == timeout)
    1:       mTimeoutInsertionPoint = nsnull;
    1: 
    1:     nextTimeout = timeout->Next();
    1: 
    1:     if (timeout->mTimer) {
    1:       timeout->mTimer->Cancel();
    1:       timeout->mTimer = nsnull;
    1: 
    1:       // Drop the count since the timer isn't going to hold on
    1:       // anymore.
    1:       timeout->Release();
    1:     }
    1: 
    1:     // Set timeout->mCleared to true to indicate that the timeout was
    1:     // cleared and taken out of the list of timeouts
    1:     timeout->mCleared = PR_TRUE;
    1: 
    1:     // Drop the count since we're removing it from the list.
    1:     timeout->Release();
    1:   }
    1: 
    1:   // Clear out our list
    1:   PR_INIT_CLIST(&mTimeouts);
    1: }
    1: 
    1: void
    1: nsGlobalWindow::InsertTimeoutIntoList(nsTimeout *aTimeout)
    1: {
    1:   NS_ASSERTION(IsInnerWindow(),
    1:                "InsertTimeoutIntoList() called on outer window!");
    1: 
    1:   // Start at mLastTimeout and go backwards.  Don't go further than
    1:   // mTimeoutInsertionPoint, though.  This optimizes for the common case of
    1:   // insertion at the end.
    1:   nsTimeout* prevSibling;
    1:   for (prevSibling = LastTimeout();
    1:        IsTimeout(prevSibling) && prevSibling != mTimeoutInsertionPoint &&
    1:          prevSibling->mWhen > aTimeout->mWhen;
    1:        prevSibling = prevSibling->Prev()) {
    1:     /* Do nothing; just searching */
    1:   }
    1: 
    1:   // Now link in aTimeout after prevSibling.
    1:   PR_INSERT_AFTER(aTimeout, prevSibling);
    1: 
    1:   aTimeout->mFiringDepth = 0;
    1: 
    1:   // Increment the timeout's reference count since it's now held on to
    1:   // by the list
    1:   aTimeout->AddRef();
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::TimerCallback(nsITimer *aTimer, void *aClosure)
    1: {
    1:   nsTimeout *timeout = (nsTimeout *)aClosure;
    1: 
    1:   // Hold on to the timeout to ensure it doesn't go away while it's
    1:   // being handled (aka kungFuDeathGrip).
    1:   timeout->AddRef();
    1: 
    1:   timeout->mWindow->RunTimeout(timeout);
    1: 
    1:   // Drop our reference to the timeout now that we're done with it.
    1:   timeout->Release();
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow: Helper Functions
    1: //*****************************************************************************
36884: 
    1: nsresult
    1: nsGlobalWindow::GetTreeOwner(nsIDocShellTreeOwner **aTreeOwner)
    1: {
    1:   FORWARD_TO_OUTER(GetTreeOwner, (aTreeOwner), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1: 
    1:   // If there's no docShellAsItem, this window must have been closed,
    1:   // in that case there is no tree owner.
    1: 
    1:   if (!docShellAsItem) {
    1:     *aTreeOwner = nsnull;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   return docShellAsItem->GetTreeOwner(aTreeOwner);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::GetTreeOwner(nsIBaseWindow **aTreeOwner)
    1: {
    1:   FORWARD_TO_OUTER(GetTreeOwner, (aTreeOwner), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1: 
    1:   // If there's no docShellAsItem, this window must have been closed,
    1:   // in that case there is no tree owner.
    1: 
    1:   if (docShellAsItem) {
    1:     docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:   }
    1: 
    1:   if (!treeOwner) {
    1:     *aTreeOwner = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
    1:   return CallQueryInterface(treeOwner, aTreeOwner);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::GetWebBrowserChrome(nsIWebBrowserChrome **aBrowserChrome)
    1: {
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   GetTreeOwner(getter_AddRefs(treeOwner));
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(treeOwner));
    1:   NS_IF_ADDREF(*aBrowserChrome = browserChrome);
    1: 
    1:   return NS_OK;
    1: }
    1: 
37063: nsIScrollableFrame *
37063: nsGlobalWindow::GetScrollFrame()
37063: {
37063:   FORWARD_TO_OUTER(GetScrollFrame, (), nsnull);
    1: 
    1:   if (!mDocShell) {
37063:     return nsnull;
    1:   }
    1: 
26050:   nsCOMPtr<nsIPresShell> presShell;
26050:   mDocShell->GetPresShell(getter_AddRefs(presShell));
26050:   if (presShell) {
37063:     return presShell->GetRootScrollFrameAsScrollable();
37063:   }
37063:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::BuildURIfromBase(const char *aURL, nsIURI **aBuiltURI,
    1:                                  PRBool *aFreeSecurityPass,
    1:                                  JSContext **aCXused)
    1: {
    1:   nsIScriptContext *scx = GetContextInternal();
    1:   JSContext *cx = nsnull;
    1: 
    1:   *aBuiltURI = nsnull;
    1:   *aFreeSecurityPass = PR_FALSE;
    1:   if (aCXused)
    1:     *aCXused = nsnull;
    1: 
    1:   // get JSContext
    1:   NS_ASSERTION(scx, "opening window missing its context");
    1:   NS_ASSERTION(mDocument, "opening window missing its document");
    1:   if (!scx || !mDocument)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMChromeWindow> chrome_win =
 3233:     do_QueryInterface(static_cast<nsIDOMWindow *>(this));
    1: 
    1:   if (nsContentUtils::IsCallerChrome() && !chrome_win) {
    1:     // If open() is called from chrome on a non-chrome window, we'll
    1:     // use the context from the window on which open() is being called
    1:     // to prevent giving chrome priveleges to new windows opened in
    1:     // such a way. This also makes us get the appropriate base URI for
    1:     // the below URI resolution code.
    1: 
    1:     cx = (JSContext *)scx->GetNativeContext();
    1:   } else {
    1:     // get the JSContext from the call stack
    1:     nsCOMPtr<nsIThreadJSContextStack> stack(do_GetService(sJSStackContractID));
    1:     if (stack)
    1:       stack->Peek(&cx);
    1:   }
    1: 
    1:   /* resolve the URI, which could be relative to the calling window
    1:      (note the algorithm to get the base URI should match the one
    1:      used to actually kick off the load in nsWindowWatcher.cpp). */
    1:   nsCAutoString charset(NS_LITERAL_CSTRING("UTF-8")); // default to utf-8
    1:   nsIURI* baseURI = nsnull;
    1:   nsCOMPtr<nsIURI> uriToLoad;
    1:   nsCOMPtr<nsIDOMWindow> sourceWindow;
    1: 
    1:   if (cx) {
    1:     nsIScriptContext *scriptcx = nsJSUtils::GetDynamicScriptContext(cx);
    1:     if (scriptcx)
    1:       sourceWindow = do_QueryInterface(scriptcx->GetGlobalObject());
    1:   }
    1: 
    1:   if (!sourceWindow) {
    1:     sourceWindow = do_QueryInterface(NS_ISUPPORTS_CAST(nsIDOMWindow *, this));
    1:     *aFreeSecurityPass = PR_TRUE;
    1:   }
    1: 
    1:   if (sourceWindow) {
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     sourceWindow->GetDocument(getter_AddRefs(domDoc));
    1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
    1:     if (doc) {
41900:       baseURI = doc->GetDocBaseURI();
    1:       charset = doc->GetDocumentCharacterSet();
    1:     }
    1:   }
    1: 
    1:   if (aCXused)
    1:     *aCXused = cx;
    1:   return NS_NewURI(aBuiltURI, nsDependentCString(aURL), charset.get(), baseURI);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::SecurityCheckURL(const char *aURL)
    1: {
    1:   JSContext       *cx;
    1:   PRBool           freePass;
    1:   nsCOMPtr<nsIURI> uri;
    1: 
    1:   if (NS_FAILED(BuildURIfromBase(aURL, getter_AddRefs(uri), &freePass, &cx)))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!freePass && NS_FAILED(nsContentUtils::GetSecurityManager()->
    1:         CheckLoadURIFromScript(cx, uri)))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::FlushPendingNotifications(mozFlushType aType)
    1: {
    1:   if (mDoc) {
    1:     mDoc->FlushPendingNotifications(aType);
    1:   }
    1: }
    1: 
    1: void
    1: nsGlobalWindow::EnsureSizeUpToDate()
    1: {
    1:   // If we're a subframe, make sure our size is up to date.  It's OK that this
    1:   // crosses the content/chrome boundary, since chrome can have pending reflows
    1:   // too.
    1:   nsGlobalWindow *parent =
 3233:     static_cast<nsGlobalWindow *>(GetPrivateParent());
    1:   if (parent) {
    1:     parent->FlushPendingNotifications(Flush_Layout);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::SaveWindowState(nsISupports **aState)
    1: {
    1:   NS_PRECONDITION(IsOuterWindow(), "Can't save the inner window's state");
    1: 
    1:   *aState = nsnull;
    1: 
    1:   if (!mContext || !mJSObject) {
    1:     // The window may be getting torn down; don't bother saving state.
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
    1:   NS_ASSERTION(inner, "No inner window to save");
    1: 
    1:   // Don't do anything else to this inner window! After this point, all
    1:   // calls to SetTimeoutOrInterval will create entries in the timeout
    1:   // list that will only run after this window has come out of the bfcache.
    1:   // Also, while we're frozen, we won't dispatch online/offline events
    1:   // to the page.
    1:   inner->Freeze();
    1: 
    1:   // Remember the outer window's XPConnect prototype.
    1:   nsCOMPtr<nsIClassInfo> ci =
    1:     do_QueryInterface((nsIScriptGlobalObject *)this);
    1:   nsCOMPtr<nsIXPConnectJSObjectHolder> proto;
    1:   nsresult rv = nsContentUtils::XPConnect()->
    1:     GetWrappedNativePrototype((JSContext *)mContext->GetNativeContext(),
    1:                               mJSObject, ci, getter_AddRefs(proto));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsISupports> state = new WindowStateHolder(inner,
    1:                                                       mInnerWindowHolders,
    1:                                                       mNavigator,
    1:                                                       mLocation,
    1:                                                       proto);
    1:   NS_ENSURE_TRUE(state, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:   printf("saving window state, state = %p\n", (void*)state);
    1: #endif
    1: 
    1:   state.swap(*aState);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::RestoreWindowState(nsISupports *aState)
    1: {
    1:   NS_ASSERTION(IsOuterWindow(), "Cannot restore an inner window");
    1: 
    1:   if (!mContext || !mJSObject) {
    1:     // The window may be getting torn down; don't bother restoring state.
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<WindowStateHolder> holder = do_QueryInterface(aState);
    1:   NS_ENSURE_TRUE(holder, NS_ERROR_FAILURE);
    1: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:   printf("restoring window state, state = %p\n", (void*)holder);
    1: #endif
    1: 
30602:   // And we're ready to go!
    1:   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
41071: 
41071:   // if a link is focused, refocus with the FLAG_SHOWRING flag set. This makes
41071:   // it easy to tell which link was last clicked when going back a page.
41071:   nsIContent* focusedNode = inner->GetFocusedNode();
43884:   if (IsLink(focusedNode)) {
41071:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
41071:     if (fm) {
41071:       nsCOMPtr<nsIDOMElement> focusedElement(do_QueryInterface(focusedNode));
41071:       fm->SetFocus(focusedElement, nsIFocusManager::FLAG_NOSCROLL |
41071:                                    nsIFocusManager::FLAG_SHOWRING);
41071:     }
41071:   }
41071: 
    1:   inner->Thaw();
    1: 
    1:   holder->DidRestoreWindow();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
25723: nsGlobalWindow::SuspendTimeouts(PRUint32 aIncrease,
25723:                                 PRBool aFreezeChildren)
25723: {
25723:   FORWARD_TO_INNER_VOID(SuspendTimeouts, (aIncrease, aFreezeChildren));
25723: 
25723:   PRBool suspended = (mTimeoutsSuspendDepth != 0);
25723:   mTimeoutsSuspendDepth += aIncrease;
25723: 
25723:   if (!suspended) {
16753:     nsDOMThreadService* dts = nsDOMThreadService::get();
16753:     if (dts) {
16753:       dts->SuspendWorkersForGlobal(static_cast<nsIScriptGlobalObject*>(this));
16753:     }
16753:   
    1:     PRTime now = PR_Now();
    1:     for (nsTimeout *t = FirstTimeout(); IsTimeout(t); t = t->Next()) {
    1:       // Change mWhen to be the time remaining for this timer.    
    1:       if (t->mWhen > now)
    1:         t->mWhen -= now;
    1:       else
    1:         t->mWhen = 0;
    1:   
    1:       // Drop the XPCOM timer; we'll reschedule when restoring the state.
    1:       if (t->mTimer) {
    1:         t->mTimer->Cancel();
    1:         t->mTimer = nsnull;
    1:   
    1:         // Drop the reference that the timer's closure had on this timeout, we'll
    1:         // add it back in ResumeTimeouts. Note that it shouldn't matter that we're
    1:         // passing null for the context, since this shouldn't actually release this
    1:         // timeout.
    1:         t->Release();
    1:       }
    1:     }
25723:   }
    1: 
    1:   // Suspend our children as well.
    1:   nsCOMPtr<nsIDocShellTreeNode> node(do_QueryInterface(GetDocShell()));
    1:   if (node) {
    1:     PRInt32 childCount = 0;
    1:     node->GetChildCount(&childCount);
    1: 
    1:     for (PRInt32 i = 0; i < childCount; ++i) {
    1:       nsCOMPtr<nsIDocShellTreeItem> childShell;
    1:       node->GetChildAt(i, getter_AddRefs(childShell));
    1:       NS_ASSERTION(childShell, "null child shell");
    1: 
    1:       nsCOMPtr<nsPIDOMWindow> pWin = do_GetInterface(childShell);
    1:       if (pWin) {
    1:         nsGlobalWindow *win =
 3233:           static_cast<nsGlobalWindow*>
 3233:                      (static_cast<nsPIDOMWindow*>(pWin));
    1:         NS_ASSERTION(win->IsOuterWindow(), "Expected outer window");
    1:         nsGlobalWindow* inner = win->GetCurrentInnerWindowInternal();
43465: 
43465:         // This is a bit hackish. Only freeze/suspend windows which are truly our
43465:         // subwindows.
43465:         nsCOMPtr<nsIContent> frame = do_QueryInterface(pWin->GetFrameElementInternal());
43465:         if (!mDoc || !frame || mDoc != frame->GetOwnerDoc() || !inner) {
43465:           continue;
43465:         }
43465: 
43465:         win->SuspendTimeouts(aIncrease, aFreezeChildren);
43465: 
25723:         if (inner && aFreezeChildren) {
    1:           inner->Freeze();
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
25723: nsGlobalWindow::ResumeTimeouts(PRBool aThawChildren)
    1: {
    1:   FORWARD_TO_INNER(ResumeTimeouts, (), NS_ERROR_NOT_INITIALIZED);
    1: 
25074:   NS_ASSERTION(mTimeoutsSuspendDepth, "Mismatched calls to ResumeTimeouts!");
25723:   --mTimeoutsSuspendDepth;
25723:   PRBool shouldResume = (mTimeoutsSuspendDepth == 0);
25723:   nsresult rv;
25723: 
25723:   if (shouldResume) {
16753:     nsDOMThreadService* dts = nsDOMThreadService::get();
16753:     if (dts) {
16753:       dts->ResumeWorkersForGlobal(static_cast<nsIScriptGlobalObject*>(this));
16753:     }
16753: 
    1:     // Restore all of the timeouts, using the stored time remaining
    1:     // (stored in timeout->mWhen).
    1: 
    1:     PRTime now = PR_Now();
    1: 
25170: #ifdef DEBUG
25170:     PRBool _seenDummyTimeout = PR_FALSE;
25170: #endif
25170: 
    1:     for (nsTimeout *t = FirstTimeout(); IsTimeout(t); t = t->Next()) {
25170:       // There's a chance we're being called with RunTimeout on the stack in which
25170:       // case we have a dummy timeout in the list that *must not* be resumed. It
25170:       // can be identified by a null mWindow.
25170:       if (!t->mWindow) {
25170: #ifdef DEBUG
25170:         NS_ASSERTION(!_seenDummyTimeout, "More than one dummy timeout?!");
25170:         _seenDummyTimeout = PR_TRUE;
25170: #endif
25170:         continue;
25170:       }
25170: 
    1:       // Make sure to cast the unsigned PR_USEC_PER_MSEC to signed
    1:       // PRTime to make the division do the right thing on 64-bit
    1:       // platforms whether t->mWhen is positive or negative (which is
    1:       // likely to always be positive here, but cast anyways for
    1:       // consistency).
    1:       PRUint32 delay =
38330:         NS_MAX(((PRUint32)(t->mWhen / (PRTime)PR_USEC_PER_MSEC)),
38330:                (PRUint32)DOM_MIN_TIMEOUT_VALUE);
    1: 
    1:       // Set mWhen back to the time when the timer is supposed to
    1:       // fire.
    1:       t->mWhen += now;
    1: 
    1:       t->mTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:       NS_ENSURE_TRUE(t->mTimer, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       rv = t->mTimer->InitWithFuncCallback(TimerCallback, t, delay,
    1:                                            nsITimer::TYPE_ONE_SHOT);
    1:       if (NS_FAILED(rv)) {
    1:         t->mTimer = nsnull;
    1:         return rv;
    1:       }
    1: 
    1:       // Add a reference for the new timer's closure.
    1:       t->AddRef();
    1:     }
25723:   }
    1: 
    1:   // Resume our children as well.
    1:   nsCOMPtr<nsIDocShellTreeNode> node =
    1:     do_QueryInterface(GetDocShell());
    1:   if (node) {
    1:     PRInt32 childCount = 0;
    1:     node->GetChildCount(&childCount);
    1: 
    1:     for (PRInt32 i = 0; i < childCount; ++i) {
    1:       nsCOMPtr<nsIDocShellTreeItem> childShell;
    1:       node->GetChildAt(i, getter_AddRefs(childShell));
    1:       NS_ASSERTION(childShell, "null child shell");
    1: 
    1:       nsCOMPtr<nsPIDOMWindow> pWin = do_GetInterface(childShell);
    1:       if (pWin) {
    1:         nsGlobalWindow *win =
 3233:           static_cast<nsGlobalWindow*>
 3233:                      (static_cast<nsPIDOMWindow*>(pWin));
    1: 
    1:         NS_ASSERTION(win->IsOuterWindow(), "Expected outer window");
    1:         nsGlobalWindow* inner = win->GetCurrentInnerWindowInternal();
43465: 
43465:         // This is a bit hackish. Only thaw/resume windows which are truly our
43465:         // subwindows.
43465:         nsCOMPtr<nsIContent> frame = do_QueryInterface(pWin->GetFrameElementInternal());
43465:         if (!mDoc || !frame || mDoc != frame->GetOwnerDoc() || !inner) {
43465:           continue;
43465:         }
43465: 
25723:         if (inner && aThawChildren) {
    1:           inner->Thaw();
    1:         }
    1: 
25723:         rv = win->ResumeTimeouts(aThawChildren);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
25723: PRUint32
25723: nsGlobalWindow::TimeoutSuspendCount()
25723: {
25723:   FORWARD_TO_INNER(TimeoutSuspendCount, (), 0);
25723:   return mTimeoutsSuspendDepth;
25723: }
25723: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScriptTypeID(PRUint32 *aScriptType)
    1: {
    1:   NS_ERROR("No default script type here - ask some element");
    1:   return nsIProgrammingLanguage::UNKNOWN;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetScriptTypeID(PRUint32 aScriptType)
    1: {
    1:   NS_ERROR("Can't change default script type for a document");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
31738: void
31738: nsGlobalWindow::SetHasOrientationEventListener()
31738: {
31738:   nsCOMPtr<nsIAccelerometer> ac = 
31738:     do_GetService(NS_ACCELEROMETER_CONTRACTID);
31738: 
31738:   if (ac) {
31738:     mHasAcceleration = PR_TRUE;
31738:     ac->AddWindowListener(this);
31738:   }
31738: }
31738: 
 4040: // nsGlobalChromeWindow implementation
 4040: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalChromeWindow)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsGlobalChromeWindow,
    1:                                                   nsGlobalWindow)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mBrowserDOMWindow)
42412:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mMessageManager)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
40490: DOMCI_DATA(ChromeWindow, nsGlobalChromeWindow)
40490: 
    1: // QueryInterface implementation for nsGlobalChromeWindow
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsGlobalChromeWindow)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMChromeWindow)
    1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ChromeWindow)
    1: NS_INTERFACE_MAP_END_INHERITING(nsGlobalWindow)
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsGlobalChromeWindow, nsGlobalWindow)
    1: NS_IMPL_RELEASE_INHERITED(nsGlobalChromeWindow, nsGlobalWindow)
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::GetWindowState(PRUint16* aWindowState)
    1: {
    1:   *aWindowState = nsIDOMChromeWindow::STATE_NORMAL;
    1: 
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1: 
    1:   PRInt32 aMode = 0;
    1: 
    1:   if (widget) {
    1:     nsresult rv = widget->GetSizeMode(&aMode);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   switch (aMode) {
    1:     case nsSizeMode_Minimized:
    1:       *aWindowState = nsIDOMChromeWindow::STATE_MINIMIZED;
    1:       break;
    1:     case nsSizeMode_Maximized:
    1:       *aWindowState = nsIDOMChromeWindow::STATE_MAXIMIZED;
    1:       break;
30075:     case nsSizeMode_Fullscreen:
30075:       *aWindowState = nsIDOMChromeWindow::STATE_FULLSCREEN;
30075:       break;
    1:     case nsSizeMode_Normal:
    1:       *aWindowState = nsIDOMChromeWindow::STATE_NORMAL;
    1:       break;
    1:     default:
    1:       NS_WARNING("Illegal window state for this chrome window");
    1:       break;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::Maximize()
    1: {
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (widget) {
    1:     rv = widget->SetSizeMode(nsSizeMode_Maximized);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::Minimize()
    1: {
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1:   nsresult rv = NS_OK;
    1: 
30075:   if (widget)
    1:     rv = widget->SetSizeMode(nsSizeMode_Minimized);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::Restore()
    1: {
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (widget) {
    1:     rv = widget->SetSizeMode(nsSizeMode_Normal);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::GetAttention()
    1: {
    1:   return GetAttentionWithCycleCount(-1);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::GetAttentionWithCycleCount(PRInt32 aCycleCount)
    1: {
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (widget) {
    1:     rv = widget->GetAttention(aCycleCount);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: //Note: This call will lock the cursor, it will not change as it moves.
    1: //To unlock, the cursor must be set back to CURSOR_AUTO.
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::SetCursor(const nsAString& aCursor)
    1: {
    1:   FORWARD_TO_OUTER_CHROME(SetCursor, (aCursor), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult rv = NS_OK;
    1:   PRInt32 cursor;
    1: 
    1:   // use C strings to keep the code/data size down
    1:   NS_ConvertUTF16toUTF8 cursorString(aCursor);
    1: 
    1:   if (cursorString.Equals("auto"))
    1:     cursor = NS_STYLE_CURSOR_AUTO;
    1:   else {
    1:     nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(aCursor);
    1:     if (eCSSKeyword_UNKNOWN == keyword ||
    1:         !nsCSSProps::FindKeyword(keyword, nsCSSProps::kCursorKTable, cursor)) {
    1:       // XXX remove the following three values (leave return NS_OK) after 1.8
    1:       // XXX since they should have been -moz- prefixed (covered by FindKeyword).
    1:       // XXX (also remove |cursorString| at that point?).
    1:       if (cursorString.Equals("grab"))
    1:         cursor = NS_STYLE_CURSOR_GRAB;
    1:       else if (cursorString.Equals("grabbing"))
    1:         cursor = NS_STYLE_CURSOR_GRABBING;
    1:       else if (cursorString.Equals("spinning"))
    1:         cursor = NS_STYLE_CURSOR_SPINNING;
    1:       else
    1:         return NS_OK;
    1:     }
    1:   }
    1: 
39823:   nsRefPtr<nsPresContext> presContext;
    1:   if (mDocShell) {
    1:     mDocShell->GetPresContext(getter_AddRefs(presContext));
    1:   }
    1: 
    1:   if (presContext) {
    1:     // Need root widget.
    1:     nsCOMPtr<nsIPresShell> presShell;
    1:     mDocShell->GetPresShell(getter_AddRefs(presShell));
    1:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1: 
    1:     nsIViewManager* vm = presShell->GetViewManager();
    1:     NS_ENSURE_TRUE(vm, NS_ERROR_FAILURE);
    1: 
    1:     nsIView *rootView;
    1:     vm->GetRootView(rootView);
    1:     NS_ENSURE_TRUE(rootView, NS_ERROR_FAILURE);
    1: 
30535:     nsIWidget* widget = rootView->GetNearestWidget(nsnull);
    1:     NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
    1: 
    1:     // Call esm and set cursor.
    1:     rv = presContext->EventStateManager()->SetCursor(cursor, nsnull,
    1:                                                      PR_FALSE, 0.0f, 0.0f,
    1:                                                      widget, PR_TRUE);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::GetBrowserDOMWindow(nsIBrowserDOMWindow **aBrowserWindow)
    1: {
    1:   FORWARD_TO_OUTER_CHROME(GetBrowserDOMWindow, (aBrowserWindow),
    1:                           NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   NS_ENSURE_ARG_POINTER(aBrowserWindow);
    1: 
    1:   *aBrowserWindow = mBrowserDOMWindow;
    1:   NS_IF_ADDREF(*aBrowserWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::SetBrowserDOMWindow(nsIBrowserDOMWindow *aBrowserWindow)
    1: {
    1:   FORWARD_TO_OUTER_CHROME(SetBrowserDOMWindow, (aBrowserWindow),
    1:                           NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   mBrowserDOMWindow = aBrowserWindow;
    1:   return NS_OK;
    1: }
    1: 
30327: NS_IMETHODIMP
30327: nsGlobalChromeWindow::NotifyDefaultButtonLoaded(nsIDOMElement* aDefaultButton)
30327: {
30327: #ifdef MOZ_XUL
30327:   NS_ENSURE_ARG(aDefaultButton);
30327: 
30327:   // Don't snap to a disabled button.
30327:   nsCOMPtr<nsIDOMXULControlElement> xulControl =
30327:                                       do_QueryInterface(aDefaultButton);
30327:   NS_ENSURE_TRUE(xulControl, NS_ERROR_FAILURE);
30327:   PRBool disabled;
30327:   nsresult rv = xulControl->GetDisabled(&disabled);
30327:   NS_ENSURE_SUCCESS(rv, rv);
30327:   if (disabled)
30327:     return NS_OK;
30327: 
30327:   // Get the button rect in screen coordinates.
30327:   nsCOMPtr<nsIContent> content(do_QueryInterface(aDefaultButton));
30327:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
36657:   nsIFrame *frame = content->GetPrimaryFrame();
30327:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30327:   nsIntRect buttonRect = frame->GetScreenRect();
30327: 
30327:   // Get the widget rect in screen coordinates.
30327:   nsIWidget *widget = GetNearestWidget();
30327:   NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
30327:   nsIntRect widgetRect;
30327:   rv = widget->GetScreenBounds(widgetRect);
30327:   NS_ENSURE_SUCCESS(rv, rv);
30327: 
30327:   // Convert the buttonRect coordinates from screen to the widget.
30327:   buttonRect -= widgetRect.TopLeft();
30327:   rv = widget->OnDefaultButtonLoaded(buttonRect);
30327:   if (rv == NS_ERROR_NOT_IMPLEMENTED)
30327:     return NS_OK;
30327:   return rv;
30327: #else
30327:   return NS_ERROR_NOT_IMPLEMENTED;
30327: #endif
30327: }
30327: 
42412: NS_IMETHODIMP
42412: nsGlobalChromeWindow::GetMessageManager(nsIChromeFrameMessageManager** aManager)
42412: {
42412:   FORWARD_TO_INNER_CHROME(GetMessageManager, (aManager), NS_ERROR_FAILURE);
42412:   if (!mMessageManager) {
42412:     nsIScriptContext* scx = GetContextInternal();
42412:     NS_ENSURE_STATE(scx);
42412:     JSContext* cx = (JSContext *)scx->GetNativeContext();
42412:     NS_ENSURE_STATE(cx);
43461:     nsCOMPtr<nsIChromeFrameMessageManager> globalMM =
43461:       do_GetService("@mozilla.org/globalmessagemanager;1");
43461:     mMessageManager =
43461:       new nsFrameMessageManager(PR_TRUE,
42412:                                 nsnull,
42412:                                 nsnull,
42412:                                 nsnull,
42412:                                 nsnull,
43461:                                 static_cast<nsFrameMessageManager*>(globalMM.get()),
42412:                                 cx);
42412:     NS_ENSURE_TRUE(mMessageManager, NS_ERROR_OUT_OF_MEMORY);
42412:   }
43461:   CallQueryInterface(mMessageManager, aManager);
42412:   return NS_OK;
42412: }
42412: 
 4040: // nsGlobalModalWindow implementation
 4040: 
 4040: // QueryInterface implementation for nsGlobalModalWindow
 4040: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalModalWindow)
 4040: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsGlobalModalWindow,
 4040:                                                   nsGlobalWindow)
31393:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mReturnValue)
 4040: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 4040: 
40490: DOMCI_DATA(ModalContentWindow, nsGlobalModalWindow)
40490: 
 4040: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsGlobalModalWindow)
 4040:   NS_INTERFACE_MAP_ENTRY(nsIDOMModalContentWindow)
 4040:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ModalContentWindow)
 4040: NS_INTERFACE_MAP_END_INHERITING(nsGlobalWindow)
 4040: 
 4040: NS_IMPL_ADDREF_INHERITED(nsGlobalModalWindow, nsGlobalWindow)
 4040: NS_IMPL_RELEASE_INHERITED(nsGlobalModalWindow, nsGlobalWindow)
 4040: 
 4040: 
 4040: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsGlobalModalWindow,
 4040:                                                 nsGlobalWindow)
 4040:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mReturnValue)
 4040: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 4040: 
 4040: 
 4040: NS_IMETHODIMP
 4040: nsGlobalModalWindow::GetDialogArguments(nsIArray **aArguments)
 4040: {
 4040:   FORWARD_TO_INNER_MODAL_CONTENT_WINDOW(GetDialogArguments, (aArguments),
 4040:                                         NS_ERROR_NOT_INITIALIZED);
 4040: 
33525:   PRBool subsumes = PR_FALSE;
33525:   nsIPrincipal *self = GetPrincipal();
33525:   if (self && NS_SUCCEEDED(self->Subsumes(mArgumentsOrigin, &subsumes)) &&
33525:       subsumes) {
33525:     NS_IF_ADDREF(*aArguments = mArguments);
33525:   } else {
33525:     *aArguments = nsnull;
33525:   }
 4040: 
 4040:   return NS_OK;
 4040: }
 4040: 
 4040: NS_IMETHODIMP
 4040: nsGlobalModalWindow::GetReturnValue(nsIVariant **aRetVal)
 4040: {
 4040:   FORWARD_TO_OUTER_MODAL_CONTENT_WINDOW(GetReturnValue, (aRetVal), NS_OK);
 4040: 
 4040:   NS_IF_ADDREF(*aRetVal = mReturnValue);
 4040: 
 4040:   return NS_OK;
 4040: }
 4040: 
 4040: NS_IMETHODIMP
 4040: nsGlobalModalWindow::SetReturnValue(nsIVariant *aRetVal)
 4040: {
 4040:   FORWARD_TO_OUTER_MODAL_CONTENT_WINDOW(SetReturnValue, (aRetVal), NS_OK);
 4040: 
 4040:   mReturnValue = aRetVal;
 4040: 
 4040:   return NS_OK;
 4040: }
 4040: 
33525: nsresult
33525: nsGlobalModalWindow::SetNewDocument(nsIDocument *aDocument,
39376:                                     nsISupports *aState)
33525: {
33525:   // If we're loading a new document into a modal dialog, clear the
33525:   // return value that was set, if any, by the current document.
33525:   if (aDocument) {
33525:     mReturnValue = nsnull;
33525:   }
33525: 
39376:   return nsGlobalWindow::SetNewDocument(aDocument, aState);
33525: }
33525: 
    1: //*****************************************************************************
    1: // nsGlobalWindow: Creator Function (This should go away)
    1: //*****************************************************************************
    1: 
    1: nsresult
 4040: NS_NewScriptGlobalObject(PRBool aIsChrome, PRBool aIsModalContentWindow,
 4040:                          nsIScriptGlobalObject **aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
    1:   nsGlobalWindow *global;
    1: 
    1:   if (aIsChrome) {
    1:     global = new nsGlobalChromeWindow(nsnull);
 4040:   } else if (aIsModalContentWindow) {
 4040:     global = new nsGlobalModalWindow(nsnull);
    1:   } else {
    1:     global = new nsGlobalWindow(nsnull);
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(global, NS_ERROR_OUT_OF_MEMORY);
    1: 
 4040:   NS_ADDREF(*aResult = global);
 4040: 
 4040:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: //***    nsNavigator: Object Management
    1: //*****************************************************************************
    1: 
    1: nsNavigator::nsNavigator(nsIDocShell *aDocShell)
    1:   : mDocShell(aDocShell)
    1: {
    1: }
    1: 
    1: nsNavigator::~nsNavigator()
    1: {
    1: }
    1: 
    1: //*****************************************************************************
    1: //    nsNavigator::nsISupports
    1: //*****************************************************************************
    1: 
    1: 
40490: DOMCI_DATA(Navigator, nsNavigator)
40490: 
    1: // QueryInterface implementation for nsNavigator
    1: NS_INTERFACE_MAP_BEGIN(nsNavigator)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNavigator)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigator)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMClientInformation)
16677:   NS_INTERFACE_MAP_ENTRY(nsIDOMNavigatorGeolocation)
    1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Navigator)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsNavigator)
    1: NS_IMPL_RELEASE(nsNavigator)
    1: 
    1: 
    1: void
    1: nsNavigator::SetDocShell(nsIDocShell *aDocShell)
    1: {
    1:   mDocShell = aDocShell;
    1:   if (mPlugins)
    1:     mPlugins->SetDocShell(aDocShell);
15958: 
15958:   // if there is a page transition, make sure delete the geolocation object
16677:   if (mGeolocation)
16677:   {
16677:     mGeolocation->Shutdown();
16677:     mGeolocation = nsnull;
15958:   }
    1: }
    1: 
    1: //*****************************************************************************
    1: //    nsNavigator::nsIDOMNavigator
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetUserAgent(nsAString& aUserAgent)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCAutoString ua;
    1:     rv = service->GetUserAgent(ua);
    1:     CopyASCIItoUTF16(ua, aUserAgent);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetAppCodeName(nsAString& aAppCodeName)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCAutoString appName;
    1:     rv = service->GetAppName(appName);
    1:     CopyASCIItoUTF16(appName, aAppCodeName);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetAppVersion(nsAString& aAppVersion)
    1: {
    1:   if (!nsContentUtils::IsCallerTrustedForRead()) {
    1:     const nsAdoptingCString& override = 
    1:       nsContentUtils::GetCharPref("general.appversion.override");
    1: 
    1:     if (override) {
    1:       CopyUTF8toUTF16(override, aAppVersion);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCAutoString str;
    1:     rv = service->GetAppVersion(str);
    1:     CopyASCIItoUTF16(str, aAppVersion);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     aAppVersion.AppendLiteral(" (");
    1: 
    1:     rv = service->GetPlatform(str);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     AppendASCIItoUTF16(str, aAppVersion);
    1: 
    1:     aAppVersion.AppendLiteral("; ");
    1: 
    1:     rv = service->GetLanguage(str);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     AppendASCIItoUTF16(str, aAppVersion);
    1: 
    1:     aAppVersion.Append(PRUnichar(')'));
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetAppName(nsAString& aAppName)
    1: {
    1:   if (!nsContentUtils::IsCallerTrustedForRead()) {
    1:     const nsAdoptingCString& override =
    1:       nsContentUtils::GetCharPref("general.appname.override");
    1: 
    1:     if (override) {
    1:       CopyUTF8toUTF16(override, aAppName);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   aAppName.AssignLiteral("Netscape");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetLanguage(nsAString& aLanguage)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCAutoString lang;
    1:     rv = service->GetLanguage(lang);
    1:     CopyASCIItoUTF16(lang, aLanguage);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetPlatform(nsAString& aPlatform)
    1: {
    1:   if (!nsContentUtils::IsCallerTrustedForRead()) {
    1:     const nsAdoptingCString& override =
    1:       nsContentUtils::GetCharPref("general.platform.override");
    1: 
    1:     if (override) {
    1:       CopyUTF8toUTF16(override, aPlatform);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // sorry for the #if platform ugliness, but Communicator is
    1:     // likewise hardcoded and we're seeking backward compatibility
    1:     // here (bug 47080)
28287: #if defined(_WIN64)
28287:     aPlatform.AssignLiteral("Win64");
28287: #elif defined(WIN32)
    1:     aPlatform.AssignLiteral("Win32");
    1: #elif defined(XP_MACOSX) && defined(__ppc__)
    1:     aPlatform.AssignLiteral("MacPPC");
    1: #elif defined(XP_MACOSX) && defined(__i386__)
    1:     aPlatform.AssignLiteral("MacIntel");
34805: #elif defined(XP_MACOSX) && defined(__x86_64__)
34805:     aPlatform.AssignLiteral("MacIntel");
    1: #elif defined(XP_OS2)
    1:     aPlatform.AssignLiteral("OS/2");
    1: #else
    1:     // XXX Communicator uses compiled-in build-time string defines
    1:     // to indicate the platform it was compiled *for*, not what it is
    1:     // currently running *on* which is what this does.
    1:     nsCAutoString plat;
    1:     rv = service->GetOscpu(plat);
    1:     CopyASCIItoUTF16(plat, aPlatform);
    1: #endif
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetOscpu(nsAString& aOSCPU)
    1: {
12788:   if (!nsContentUtils::IsCallerTrustedForRead()) {
12788:     const nsAdoptingCString& override =
12788:       nsContentUtils::GetCharPref("general.oscpu.override");
12788: 
12788:     if (override) {
12788:       CopyUTF8toUTF16(override, aOSCPU);
12788:       return NS_OK;
12788:     }
12788:   }
12788: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCAutoString oscpu;
    1:     rv = service->GetOscpu(oscpu);
    1:     CopyASCIItoUTF16(oscpu, aOSCPU);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetVendor(nsAString& aVendor)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCAutoString vendor;
    1:     rv = service->GetVendor(vendor);
    1:     CopyASCIItoUTF16(vendor, aVendor);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetVendorSub(nsAString& aVendorSub)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCAutoString vendor;
    1:     rv = service->GetVendorSub(vendor);
    1:     CopyASCIItoUTF16(vendor, aVendorSub);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetProduct(nsAString& aProduct)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCAutoString product;
    1:     rv = service->GetProduct(product);
    1:     CopyASCIItoUTF16(product, aProduct);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetProductSub(nsAString& aProductSub)
    1: {
12788:   if (!nsContentUtils::IsCallerTrustedForRead()) {
12788:     const nsAdoptingCString& override =
12788:       nsContentUtils::GetCharPref("general.productSub.override");
12788: 
12788:     if (override) {
12788:       CopyUTF8toUTF16(override, aProductSub);
12788:       return NS_OK;
12788:     } else {
12788:       // 'general.useragent.productSub' backwards compatible with 1.8 branch.
12788:       const nsAdoptingCString& override2 =
12788:         nsContentUtils::GetCharPref("general.useragent.productSub");
12788: 
12788:       if (override2) {
12788:         CopyUTF8toUTF16(override2, aProductSub);
12788:         return NS_OK;
12788:       }
12788:     }
12788:   }
12788: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIHttpProtocolHandler>
    1:     service(do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCAutoString productSub;
    1:     rv = service->GetProductSub(productSub);
    1:     CopyASCIItoUTF16(productSub, aProductSub);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetSecurityPolicy(nsAString& aSecurityPolicy)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetMimeTypes(nsIDOMMimeTypeArray **aMimeTypes)
    1: {
    1:   if (!mMimeTypes) {
    1:     mMimeTypes = new nsMimeTypeArray(this);
    1:     if (!mMimeTypes) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aMimeTypes = mMimeTypes);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetPlugins(nsIDOMPluginArray **aPlugins)
    1: {
    1:   if (!mPlugins) {
    1:     mPlugins = new nsPluginArray(this, mDocShell);
    1:     if (!mPlugins) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aPlugins = mPlugins);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // values for the network.cookie.cookieBehavior pref are documented in
    1: // nsCookieService.cpp.
    1: #define COOKIE_BEHAVIOR_REJECT 2
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetCookieEnabled(PRBool *aCookieEnabled)
    1: {
    1:   *aCookieEnabled =
    1:     (nsContentUtils::GetIntPref("network.cookie.cookieBehavior",
    1:                                 COOKIE_BEHAVIOR_REJECT) !=
    1:      COOKIE_BEHAVIOR_REJECT);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetOnLine(PRBool* aOnline)
    1: {
    1:   NS_PRECONDITION(aOnline, "Null out param");
    1:   
    1:   *aOnline = !NS_IsOffline();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::GetBuildID(nsAString& aBuildID)
    1: {
12788:   if (!nsContentUtils::IsCallerTrustedForRead()) {
12788:     const nsAdoptingCString& override =
12788:       nsContentUtils::GetCharPref("general.buildID.override");
12788: 
12788:     if (override) {
12788:       CopyUTF8toUTF16(override, aBuildID);
12788:       return NS_OK;
12788:     }
12788:   }
12788: 
 3041:   nsCOMPtr<nsIXULAppInfo> appInfo =
 3041:     do_GetService("@mozilla.org/xre/app-info;1");
 3041:   if (!appInfo)
 3041:     return NS_ERROR_NOT_IMPLEMENTED;
 3041: 
 3041:   nsCAutoString buildID;
 3041:   nsresult rv = appInfo->GetAppBuildID(buildID);
 3041:   if (NS_FAILED(rv))
 3041:     return rv;
 3041: 
 3041:   aBuildID.Truncate();
 3041:   AppendASCIItoUTF16(buildID, aBuildID);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::JavaEnabled(PRBool *aReturn)
    1: {
31800:   // Return true if we have a handler for "application/x-java-vm",
31800:   // otherwise return false.
31800:   *aReturn = PR_FALSE;
31800: 
31800:   if (!mMimeTypes) {
31800:     mMimeTypes = new nsMimeTypeArray(this);
31800:     if (!mMimeTypes)
31800:       return NS_ERROR_OUT_OF_MEMORY;
31800:   }
31800: 
31800:   RefreshMIMEArray();
31800: 
31800:   PRUint32 count;
31800:   mMimeTypes->GetLength(&count);
31800:   for (PRUint32 i = 0; i < count; i++) {
31800:     nsresult rv;
31800:     nsIDOMMimeType* type = mMimeTypes->GetItemAt(i, &rv);
31800:     nsAutoString mimeString;
31800:     if (type && NS_SUCCEEDED(type->GetType(mimeString))) {
31800:       if (mimeString.EqualsLiteral("application/x-java-vm")) {
31800:         *aReturn = PR_TRUE;
31800:         break;
31800:       }
31800:     }
31800:   }
    1: 
15819:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::TaintEnabled(PRBool *aReturn)
    1: {
    1:   *aReturn = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsNavigator::LoadingNewDocument()
    1: {
    1:   // Release these so that they will be recreated for the
    1:   // new document (if requested).  The plugins or mime types
    1:   // arrays may have changed.  See bug 150087.
    1:   mMimeTypes = nsnull;
    1:   mPlugins = nsnull;
15958: 
16677:   if (mGeolocation)
16677:   {
16677:     mGeolocation->Shutdown();
16677:     mGeolocation = nsnull;
15958:   }
    1: }
    1: 
    1: nsresult
    1: nsNavigator::RefreshMIMEArray()
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (mMimeTypes)
    1:     rv = mMimeTypes->Refresh();
    1:   return rv;
    1: }
    1: 
    1: //*****************************************************************************
    1: //    nsNavigator::nsIDOMClientInformation
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::RegisterContentHandler(const nsAString& aMIMEType, 
    1:                                     const nsAString& aURI, 
    1:                                     const nsAString& aTitle)
    1: {
    1:   nsCOMPtr<nsIWebContentHandlerRegistrar> registrar = 
    1:     do_GetService(NS_WEBCONTENTHANDLERREGISTRAR_CONTRACTID);
    1:   if (registrar && mDocShell) {
    1:     nsCOMPtr<nsIDOMWindow> contentDOMWindow(do_GetInterface(mDocShell));
    1:     if (contentDOMWindow)
    1:       return registrar->RegisterContentHandler(aMIMEType, aURI, aTitle,
    1:                                                contentDOMWindow);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavigator::RegisterProtocolHandler(const nsAString& aProtocol, 
    1:                                      const nsAString& aURI, 
    1:                                      const nsAString& aTitle)
    1: {
    1:   nsCOMPtr<nsIWebContentHandlerRegistrar> registrar = 
    1:     do_GetService(NS_WEBCONTENTHANDLERREGISTRAR_CONTRACTID);
    1:   if (registrar && mDocShell) {
    1:     nsCOMPtr<nsIDOMWindow> contentDOMWindow(do_GetInterface(mDocShell));
    1:     if (contentDOMWindow)
    1:       return registrar->RegisterProtocolHandler(aProtocol, aURI, aTitle,
    1:                                                 contentDOMWindow);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
 1938: 
 3239: 
 3239: NS_IMETHODIMP
11805: nsNavigator::MozIsLocallyAvailable(const nsAString &aURI,
 3239:                                    PRBool aWhenOffline,
 3239:                                    PRBool *aIsAvailable)
 3239: {
 3239:   nsCOMPtr<nsIURI> uri;
 3239:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURI);
 3239:   NS_ENSURE_SUCCESS(rv, rv);
 3239: 
 3239:   // This method of checking the cache will only work for http/https urls
 3239:   PRBool match;
 3239:   rv = uri->SchemeIs("http", &match);
 3239:   NS_ENSURE_SUCCESS(rv, rv);
 3239:   if (!match) {
 3239:     rv = uri->SchemeIs("https", &match);
 3239:     NS_ENSURE_SUCCESS(rv, rv);
 3239:     if (!match) return NS_ERROR_DOM_BAD_URI;
 3239:   }
 3239: 
 3239:   // Same origin check
 3239:   nsCOMPtr<nsIJSContextStack> stack = do_GetService(sJSStackContractID);
 3239:   NS_ENSURE_TRUE(stack, NS_ERROR_FAILURE);
 3239: 
 3239:   JSContext *cx = nsnull;
 3239:   rv = stack->Peek(&cx);
 3239:   NS_ENSURE_TRUE(cx, NS_ERROR_FAILURE);
 3239: 
 3239:   rv = nsContentUtils::GetSecurityManager()->CheckSameOrigin(cx, uri);
 3239:   NS_ENSURE_SUCCESS(rv, rv);
 3239: 
 3239:   // these load flags cause an error to be thrown if there is no
 3239:   // valid cache entry, and skip the load if there is.
 3239:   // if the cache is busy, assume that it is not yet available rather
 3239:   // than waiting for it to become available.
 3239:   PRUint32 loadFlags = nsIChannel::INHIBIT_CACHING |
 4063:                        nsICachingChannel::LOAD_NO_NETWORK_IO |
 3239:                        nsICachingChannel::LOAD_ONLY_IF_MODIFIED |
 3239:                        nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;
 3239: 
 3239:   if (aWhenOffline) {
 3239:     loadFlags |= nsICachingChannel::LOAD_CHECK_OFFLINE_CACHE |
22721:                  nsICachingChannel::LOAD_ONLY_FROM_CACHE |
22721:                  nsIRequest::LOAD_FROM_CACHE;
 3239:   }
 3239: 
 3239:   nsCOMPtr<nsIChannel> channel;
 3239:   rv = NS_NewChannel(getter_AddRefs(channel), uri,
 3239:                      nsnull, nsnull, nsnull, loadFlags);
 3239:   NS_ENSURE_SUCCESS(rv, rv);
 3239: 
 3239:   nsCOMPtr<nsIInputStream> stream;
 3239:   rv = channel->Open(getter_AddRefs(stream));
 3239:   NS_ENSURE_SUCCESS(rv, rv);
 3239: 
 3239:   stream->Close();
 3239: 
 3239:   nsresult status;
 3239:   rv = channel->GetStatus(&status);
 3239:   NS_ENSURE_SUCCESS(rv, rv);
 3239: 
 3239:   if (NS_SUCCEEDED(status)) {
 3239:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel);
 3239:     rv = httpChannel->GetRequestSucceeded(aIsAvailable);
 3239:     NS_ENSURE_SUCCESS(rv, rv);
 3239:   } else {
 3239:     *aIsAvailable = PR_FALSE;
 3239:   }
 3239: 
 3239:   return NS_OK;
 3239: }
 3239: 
15958: //*****************************************************************************
16677: //    nsNavigator::nsIDOMNavigatorGeolocation
15958: //*****************************************************************************
15958: 
16677: NS_IMETHODIMP nsNavigator::GetGeolocation(nsIDOMGeoGeolocation **_retval)
15958: {
15958:   NS_ENSURE_ARG_POINTER(_retval);
34794:   *_retval = nsnull;
34794: 
34794:   if (mGeolocation) {
34794:     NS_ADDREF(*_retval = mGeolocation);
34794:     return NS_OK;
34794:   }
34794: 
34794:   if (!mDocShell)
34794:     return NS_ERROR_FAILURE;
34794: 
15958:   nsCOMPtr<nsIDOMWindow> contentDOMWindow(do_GetInterface(mDocShell));
34794:   if (!contentDOMWindow)
34794:     return NS_ERROR_FAILURE;
34794:     
34794:   mGeolocation = new nsGeolocation();
34794:   if (!mGeolocation)
34794:     return NS_ERROR_FAILURE;
34794:   
34794:   if (NS_FAILED(mGeolocation->Init(contentDOMWindow)))
34794:     return NS_ERROR_FAILURE;
34794:   
34794:   NS_ADDREF(*_retval = mGeolocation);    
34794:   return NS_OK; 
34794: }
