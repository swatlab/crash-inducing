     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /**
     1:  * This class is called by the editor to handle spellchecking after various
     1:  * events. The main entrypoint is SpellCheckAfterEditorChange, which is called
     1:  * when the text is changed.
     1:  *
     1:  * It is VERY IMPORTANT that we do NOT do any operations that might cause DOM
     1:  * notifications to be flushed when we are called from the editor. This is
     1:  * because the call might originate from a frame, and flushing the
     1:  * notifications might cause that frame to be deleted.
     1:  *
     1:  * Using the WordUtil class to find words causes DOM notifications to be
     1:  * flushed because it asks for style information. As a result, we post an event
     1:  * and do all of the spellchecking in that event handler, which occurs later.
     1:  * We store all DOM pointers in ranges because they are kept up-to-date with
     1:  * DOM changes that may have happened while the event was on the queue.
     1:  *
     1:  * We also allow the spellcheck to be suspended and resumed later. This makes
     1:  * large pastes or initializations with a lot of text not hang the browser UI.
     1:  *
     1:  * An optimization is the mNeedsCheckAfterNavigation flag. This is set to
     1:  * true when we get any change, and false once there is no possibility
     1:  * something changed that we need to check on navigation. Navigation events
     1:  * tend to be a little tricky because we want to check the current word on
     1:  * exit if something has changed. If we navigate inside the word, we don't want
     1:  * to do anything. As a result, this flag is cleared in FinishNavigationEvent
     1:  * when we know that we are checking as a result of navigation.
     1:  */
     1: 
     1: #include "mozInlineSpellChecker.h"
     1: #include "mozInlineSpellWordUtil.h"
     1: #include "mozISpellI18NManager.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsCRT.h"
 75264: #include "nsIDOMNode.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMElement.h"
  1418: #include "nsIDOMEventTarget.h"
  6142: #include "nsIDOMMouseEvent.h"
     1: #include "nsIDOMKeyEvent.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIDOMNodeList.h"
 86939: #include "nsRange.h"
     1: #include "nsIPlaintextEditor.h"
     1: #include "nsIPrefBranch.h"
     1: #include "nsIPrefService.h"
     1: #include "nsIRunnable.h"
     1: #include "nsISelection.h"
 75112: #include "nsISelectionPrivate.h"
     1: #include "nsISelectionController.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsITextServicesFilter.h"
     1: #include "nsString.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsUnicharUtils.h"
  2896: #include "nsIContent.h"
 72328: #include "nsEventListenerManager.h"
  6346: #include "nsGUIEvent.h"
 81389: #include "nsRange.h"
 81389: #include "nsContentUtils.h"
106067: #include "nsEditor.h"
     1: 
     1: // Set to spew messages to the console about what is happening.
     1: //#define DEBUG_INLINESPELL
     1: 
     1: // the number of milliseconds that we will take at once to do spellchecking
     1: #define INLINESPELL_CHECK_TIMEOUT 50
     1: 
     1: // The number of words to check before we look at the time to see if
     1: // INLINESPELL_CHECK_TIMEOUT ms have elapsed. This prevents us from spending
     1: // too much time checking the clock. Note that misspelled words count for
     1: // more than one word in this calculation.
     1: #define INLINESPELL_TIMEOUT_CHECK_FREQUENCY 50
     1: 
     1: // This number is the number of checked words a misspelled word counts for
     1: // when we're checking the time to see if the alloted time is up for
     1: // spellchecking. Misspelled words take longer to process since we have to
     1: // create a range, so they count more. The exact number isn't very important
     1: // since this just controls how often we check the current time.
     1: #define MISSPELLED_WORD_COUNT_PENALTY 4
     1: 
     1: 
 79445: static bool ContentIsDescendantOf(nsINode* aPossibleDescendant,
     1:                                     nsINode* aPossibleAncestor);
     1: 
     1: static const char kMaxSpellCheckSelectionSize[] = "extensions.spellcheck.inline.max-misspellings";
     1: 
     1: mozInlineSpellStatus::mozInlineSpellStatus(mozInlineSpellChecker* aSpellChecker)
     1:     : mSpellChecker(aSpellChecker), mWordCount(0)
     1: {
     1: }
     1: 
     1: // mozInlineSpellStatus::InitForEditorChange
     1: //
     1: //    This is the most complicated case. For changes, we need to compute the
     1: //    range of stuff that changed based on the old and new caret positions,
     1: //    as well as use a range possibly provided by the editor (start and end,
     1: //    which are usually NULL) to get a range with the union of these.
     1: 
     1: nsresult
     1: mozInlineSpellStatus::InitForEditorChange(
108165:     EditAction aAction,
108991:     nsIDOMNode* aAnchorNode, int32_t aAnchorOffset,
108991:     nsIDOMNode* aPreviousNode, int32_t aPreviousOffset,
108991:     nsIDOMNode* aStartNode, int32_t aStartOffset,
108991:     nsIDOMNode* aEndNode, int32_t aEndOffset)
     1: {
     1:   nsresult rv;
     1: 
 69898:   nsCOMPtr<nsIDOMDocument> doc;
 69898:   rv = GetDocument(getter_AddRefs(doc));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // save the anchor point as a range so we can find the current word later
 69898:   rv = PositionToCollapsedRange(doc, aAnchorNode, aAnchorOffset,
     1:                                 getter_AddRefs(mAnchorRange));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
108165:   if (aAction == EditAction::deleteSelection) {
     1:     // Deletes are easy, the range is just the current anchor. We set the range
     1:     // to check to be empty, FinishInitOnEvent will fill in the range to be
     1:     // the current word.
     1:     mOp = eOpChangeDelete;
106838:     mRange = nullptr;
     1:     return NS_OK;
     1:   }
     1: 
     1:   mOp = eOpChange;
     1: 
     1:   // range to check
 81389:   mRange = new nsRange();
     1: 
     1:   // ...we need to put the start and end in the correct order
108991:   int16_t cmpResult;
 86938:   rv = mAnchorRange->ComparePoint(aPreviousNode, aPreviousOffset, &cmpResult);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   if (cmpResult < 0) {
     1:     // previous anchor node is before the current anchor
     1:     rv = mRange->SetStart(aPreviousNode, aPreviousOffset);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     rv = mRange->SetEnd(aAnchorNode, aAnchorOffset);
     1:   } else {
     1:     // previous anchor node is after (or the same as) the current anchor
     1:     rv = mRange->SetStart(aAnchorNode, aAnchorOffset);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     rv = mRange->SetEnd(aPreviousNode, aPreviousOffset);
     1:   }
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // On insert save this range: DoSpellCheck optimizes things in this range.
     1:   // Otherwise, just leave this NULL.
108165:   if (aAction == EditAction::insertText)
     1:     mCreatedRange = mRange;
     1: 
     1:   // if we were given a range, we need to expand our range to encompass it
     1:   if (aStartNode && aEndNode) {
 86938:     rv = mRange->ComparePoint(aStartNode, aStartOffset, &cmpResult);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     if (cmpResult < 0) { // given range starts before
     1:       rv = mRange->SetStart(aStartNode, aStartOffset);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1: 
 86938:     rv = mRange->ComparePoint(aEndNode, aEndOffset, &cmpResult);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     if (cmpResult > 0) { // given range ends after
     1:       rv = mRange->SetEnd(aEndNode, aEndOffset);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellStatis::InitForNavigation
     1: //
     1: //    For navigation events, we just need to store the new and old positions.
     1: //
     1: //    In some cases, we detect that we shouldn't check. If this event should
     1: //    not be processed, *aContinue will be false.
     1: 
     1: nsresult
     1: mozInlineSpellStatus::InitForNavigation(
108991:     bool aForceCheck, int32_t aNewPositionOffset,
108991:     nsIDOMNode* aOldAnchorNode, int32_t aOldAnchorOffset,
108991:     nsIDOMNode* aNewAnchorNode, int32_t aNewAnchorOffset,
 79445:     bool* aContinue)
     1: {
     1:   nsresult rv;
     1:   mOp = eOpNavigation;
     1: 
     1:   mForceNavigationWordCheck = aForceCheck;
     1:   mNewNavigationPositionOffset = aNewPositionOffset;
     1: 
     1:   // get the root node for checking
     1:   nsCOMPtr<nsIEditor> editor = do_QueryReferent(mSpellChecker->mEditor, &rv);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   nsCOMPtr<nsIDOMElement> rootElt;
     1:   rv = editor->GetRootElement(getter_AddRefs(rootElt));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // the anchor node might not be in the DOM anymore, check
     1:   nsCOMPtr<nsINode> root = do_QueryInterface(rootElt, &rv);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   nsCOMPtr<nsINode> currentAnchor = do_QueryInterface(aOldAnchorNode, &rv);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   if (root && currentAnchor && ! ContentIsDescendantOf(currentAnchor, root)) {
 80486:     *aContinue = false;
     1:     return NS_OK;
     1:   }
     1: 
 69898:   nsCOMPtr<nsIDOMDocument> doc;
 69898:   rv = GetDocument(getter_AddRefs(doc));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 69898:   rv = PositionToCollapsedRange(doc, aOldAnchorNode, aOldAnchorOffset,
     1:                                 getter_AddRefs(mOldNavigationAnchorRange));
     1:   NS_ENSURE_SUCCESS(rv, rv);
 69898:   rv = PositionToCollapsedRange(doc, aNewAnchorNode, aNewAnchorOffset,
     1:                                 getter_AddRefs(mAnchorRange));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 80486:   *aContinue = true;
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellStatus::InitForSelection
     1: //
     1: //    It is easy for selections since we always re-check the spellcheck
     1: //    selection.
     1: 
     1: nsresult
     1: mozInlineSpellStatus::InitForSelection()
     1: {
     1:   mOp = eOpSelection;
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellStatus::InitForRange
     1: //
     1: //    Called to cause the spellcheck of the given range. This will look like
     1: //    a change operation over the given range.
     1: 
     1: nsresult
 86939: mozInlineSpellStatus::InitForRange(nsRange* aRange)
     1: {
     1:   mOp = eOpChange;
     1:   mRange = aRange;
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellStatus::FinishInitOnEvent
     1: //
     1: //    Called when the event is triggered to complete initialization that
     1: //    might require the WordUtil. This calls to the operation-specific
     1: //    initializer, and also sets the range to be the entire element if it
     1: //    is NULL.
     1: //
     1: //    Watch out: the range might still be NULL if there is nothing to do,
     1: //    the caller will have to check for this.
     1: 
     1: nsresult
     1: mozInlineSpellStatus::FinishInitOnEvent(mozInlineSpellWordUtil& aWordUtil)
     1: {
     1:   nsresult rv;
     1:   if (! mRange) {
106838:     rv = mSpellChecker->MakeSpellCheckRange(nullptr, 0, nullptr, 0,
     1:                                             getter_AddRefs(mRange));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   switch (mOp) {
     1:     case eOpChange:
     1:       if (mAnchorRange)
     1:         return FillNoCheckRangeFromAnchor(aWordUtil);
     1:       break;
     1:     case eOpChangeDelete:
     1:       if (mAnchorRange) {
     1:         rv = FillNoCheckRangeFromAnchor(aWordUtil);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:       }
     1:       // Delete events will have no range for the changed text (because it was
     1:       // deleted), and InitForEditorChange will set it to NULL. Here, we select
     1:       // the entire word to cause any underlining to be removed.
     1:       mRange = mNoCheckRange;
     1:       break;
     1:     case eOpNavigation:
     1:       return FinishNavigationEvent(aWordUtil);
     1:     case eOpSelection:
     1:       // this gets special handling in ResumeCheck
     1:       break;
     1:     case eOpResume:
     1:       // everything should be initialized already in this case
     1:       break;
     1:     default:
     1:       NS_NOTREACHED("Bad operation");
     1:       return NS_ERROR_NOT_INITIALIZED;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellStatus::FinishNavigationEvent
     1: //
     1: //    This verifies that we need to check the word at the previous caret
     1: //    position. Now that we have the word util, we can find the word belonging
     1: //    to the previous caret position. If the new position is inside that word,
     1: //    we don't want to do anything. In this case, we'll NULL out mRange so
     1: //    that the caller will know not to continue.
     1: //
     1: //    Notice that we don't set mNoCheckRange. We check here whether the cursor
     1: //    is in the word that needs checking, so it isn't necessary. Plus, the
     1: //    spellchecker isn't guaranteed to only check the given word, and it could
     1: //    remove the underline from the new word under the cursor.
     1: 
     1: nsresult
     1: mozInlineSpellStatus::FinishNavigationEvent(mozInlineSpellWordUtil& aWordUtil)
     1: {
 13845:   nsCOMPtr<nsIEditor> editor = do_QueryReferent(mSpellChecker->mEditor);
 13845:   if (! editor)
 13845:     return NS_ERROR_FAILURE; // editor is gone
 13845: 
     1:   NS_ASSERTION(mAnchorRange, "No anchor for navigation!");
     1:   nsCOMPtr<nsIDOMNode> newAnchorNode, oldAnchorNode;
108991:   int32_t newAnchorOffset, oldAnchorOffset;
     1: 
     1:   // get the DOM position of the old caret, the range should be collapsed
     1:   nsresult rv = mOldNavigationAnchorRange->GetStartContainer(
     1:       getter_AddRefs(oldAnchorNode));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   rv = mOldNavigationAnchorRange->GetStartOffset(&oldAnchorOffset);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // find the word on the old caret position, this is the one that we MAY need
     1:   // to check
 86939:   nsRefPtr<nsRange> oldWord;
     1:   rv = aWordUtil.GetRangeForWord(oldAnchorNode, oldAnchorOffset,
     1:                                  getter_AddRefs(oldWord));
     1:   NS_ENSURE_SUCCESS(rv, rv);
 13845: 
 13845:   // aWordUtil.GetRangeForWord flushes pending notifications, check editor again.
 13845:   editor = do_QueryReferent(mSpellChecker->mEditor);
 13845:   if (! editor)
 13845:     return NS_ERROR_FAILURE; // editor is gone
 13845: 
     1:   // get the DOM position of the new caret, the range should be collapsed
     1:   rv = mAnchorRange->GetStartContainer(getter_AddRefs(newAnchorNode));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   rv = mAnchorRange->GetStartOffset(&newAnchorOffset);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // see if the new cursor position is in the word of the old cursor position
 79445:   bool isInRange = false;
     1:   if (! mForceNavigationWordCheck) {
 86938:     rv = oldWord->IsPointInRange(newAnchorNode,
     1:                                  newAnchorOffset + mNewNavigationPositionOffset,
     1:                                  &isInRange);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   if (isInRange) {
     1:     // caller should give up
106838:     mRange = nullptr;
     1:   } else {
     1:     // check the old word
     1:     mRange = oldWord;
     1: 
     1:     // Once we've spellchecked the current word, we don't need to spellcheck
     1:     // for any more navigation events.
 80486:     mSpellChecker->mNeedsCheckAfterNavigation = false;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellStatus::FillNoCheckRangeFromAnchor
     1: //
     1: //    Given the mAnchorRange object, computes the range of the word it is on
     1: //    (if any) and fills that range into mNoCheckRange. This is used for
     1: //    change and navigation events to know which word we should skip spell
     1: //    checking on
     1: 
     1: nsresult
     1: mozInlineSpellStatus::FillNoCheckRangeFromAnchor(
     1:     mozInlineSpellWordUtil& aWordUtil)
     1: {
     1:   nsCOMPtr<nsIDOMNode> anchorNode;
     1:   nsresult rv = mAnchorRange->GetStartContainer(getter_AddRefs(anchorNode));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
108991:   int32_t anchorOffset;
     1:   rv = mAnchorRange->GetStartOffset(&anchorOffset);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   return aWordUtil.GetRangeForWord(anchorNode, anchorOffset,
     1:                                    getter_AddRefs(mNoCheckRange));
     1: }
     1: 
 69898: // mozInlineSpellStatus::GetDocument
     1: //
 69898: //    Returns the nsIDOMDocument object for the document for the
     1: //    current spellchecker.
     1: 
     1: nsresult
 69898: mozInlineSpellStatus::GetDocument(nsIDOMDocument** aDocument)
     1: {
     1:   nsresult rv;
106838:   *aDocument = nullptr;
     1:   if (! mSpellChecker->mEditor)
     1:     return NS_ERROR_UNEXPECTED;
     1: 
     1:   nsCOMPtr<nsIEditor> editor = do_QueryReferent(mSpellChecker->mEditor, &rv);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsIDOMDocument> domDoc;
     1:   rv = editor->GetDocument(getter_AddRefs(domDoc));
     1:   NS_ENSURE_SUCCESS(rv, rv);
 69898:   NS_ENSURE_TRUE(domDoc, NS_ERROR_NULL_POINTER);
 69898:   domDoc.forget(aDocument);
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellStatus::PositionToCollapsedRange
     1: //
     1: //    Converts a given DOM position to a collapsed range covering that
     1: //    position. We use ranges to store DOM positions becuase they stay
     1: //    updated as the DOM is changed.
     1: 
     1: nsresult
 69898: mozInlineSpellStatus::PositionToCollapsedRange(nsIDOMDocument* aDocument,
108991:     nsIDOMNode* aNode, int32_t aOffset, nsIDOMRange** aRange)
     1: {
106838:   *aRange = nullptr;
     1:   nsCOMPtr<nsIDOMRange> range;
 69898:   nsresult rv = aDocument->CreateRange(getter_AddRefs(range));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   rv = range->SetStart(aNode, aOffset);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   rv = range->SetEnd(aNode, aOffset);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   range.swap(*aRange);
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellResume
     1: 
     1: class mozInlineSpellResume : public nsRunnable
     1: {
     1: public:
     1:   mozInlineSpellResume(const mozInlineSpellStatus& aStatus) : mStatus(aStatus) {}
     1:   mozInlineSpellStatus mStatus;
     1:   nsresult Post()
     1:   {
     1:     return NS_DispatchToMainThread(this);
     1:   }
     1: 
     1:   NS_IMETHOD Run()
     1:   {
     1:     mStatus.mSpellChecker->ResumeCheck(&mStatus);
     1:     return NS_OK;
     1:   }
     1: };
     1: 
     1: 
     1: NS_INTERFACE_MAP_BEGIN(mozInlineSpellChecker)
     1:   NS_INTERFACE_MAP_ENTRY(nsIInlineSpellChecker)
     1:   NS_INTERFACE_MAP_ENTRY(nsIEditActionListener)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 72645:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventListener)
 72645:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMEventListener)
 43054:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(mozInlineSpellChecker)
     1: NS_INTERFACE_MAP_END
     1: 
 43054: NS_IMPL_CYCLE_COLLECTING_ADDREF(mozInlineSpellChecker)
 43054: NS_IMPL_CYCLE_COLLECTING_RELEASE(mozInlineSpellChecker)
 43054: 
 43054: NS_IMPL_CYCLE_COLLECTION_5(mozInlineSpellChecker,
 43054:                            mSpellCheck,
 43054:                            mTextServicesDocument,
 43054:                            mTreeWalker,
 43054:                            mConverter,
 43054:                            mCurrentSelectionAnchorNode)
     1: 
     1: mozInlineSpellChecker::SpellCheckingState
     1:   mozInlineSpellChecker::gCanEnableSpellChecking =
     1:   mozInlineSpellChecker::SpellCheck_Uninitialized;
     1: 
     1: mozInlineSpellChecker::mozInlineSpellChecker() :
     1:     mNumWordsInSpellSelection(0),
     1:     mMaxNumWordsInSpellSelection(250),
 81390:     mNeedsCheckAfterNavigation(false),
 81390:     mFullSpellCheckScheduled(false)
     1: {
     1:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
     1:   if (prefs)
     1:     prefs->GetIntPref(kMaxSpellCheckSelectionSize, &mMaxNumWordsInSpellSelection); 
     1:   mMaxMisspellingsPerCheck = mMaxNumWordsInSpellSelection * 3 / 4;
     1: }
     1: 
     1: mozInlineSpellChecker::~mozInlineSpellChecker()
     1: {
     1: }
     1: 
     1: NS_IMETHODIMP
     1: mozInlineSpellChecker::GetSpellChecker(nsIEditorSpellCheck **aSpellCheck)
     1: {
     1:   *aSpellCheck = mSpellCheck;
     1:   NS_IF_ADDREF(*aSpellCheck);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: mozInlineSpellChecker::Init(nsIEditor *aEditor)
     1: {
     1:   mEditor = do_GetWeakReference(aEditor);
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::Cleanup
     1: //
     1: //    Called by the editor when the editor is going away. This is important
     1: //    because we remove listeners. We do NOT clean up anything else in this
     1: //    function, because it can get called while DoSpellCheck is running!
     1: //
     1: //    Getting the style information there can cause DOM notifications to be
     1: //    flushed, which can cause editors to go away which will bring us here.
     1: //    We can not do anything that will cause DoSpellCheck to freak out.
     1: 
 79445: nsresult mozInlineSpellChecker::Cleanup(bool aDestroyingFrames)
     1: {
     1:   mNumWordsInSpellSelection = 0;
 20728:   nsCOMPtr<nsISelection> spellCheckSelection;
 20728:   nsresult rv = GetSpellCheckSelection(getter_AddRefs(spellCheckSelection));
 20728:   if (NS_FAILED(rv)) {
 20728:     // Ensure we still unregister event listeners (but return a failure code)
 20728:     UnregisterEventListeners();
 20728:   } else {
 22729:     if (!aDestroyingFrames) {
 20728:       spellCheckSelection->RemoveAllRanges();
 22729:     }
 20728: 
 20728:     rv = UnregisterEventListeners();
 20728:   }
106838:   mEditor = nullptr;
 20728: 
 20728:   return rv;
     1: }
     1: 
     1: // mozInlineSpellChecker::CanEnableInlineSpellChecking
     1: //
     1: //    This function can be called to see if it seems likely that we can enable
     1: //    spellchecking before actually creating the InlineSpellChecking objects.
     1: //
     1: //    The problem is that we can't get the dictionary list without actually
     1: //    creating a whole bunch of spellchecking objects. This function tries to
     1: //    do that and caches the result so we don't have to keep allocating those
     1: //    objects if there are no dictionaries or spellchecking.
     1: //
 78229: //    Whenever dictionaries are added or removed at runtime, this value must be
 78229: //    updated before an observer notification is sent out about the change, to
 78229: //    avoid editors getting a wrong cached result.
     1: 
 79445: bool // static
     1: mozInlineSpellChecker::CanEnableInlineSpellChecking()
     1: {
     1:   nsresult rv;
     1:   if (gCanEnableSpellChecking == SpellCheck_Uninitialized) {
     1:     gCanEnableSpellChecking = SpellCheck_NotAvailable;
     1: 
     1:     nsCOMPtr<nsIEditorSpellCheck> spellchecker =
     1:       do_CreateInstance("@mozilla.org/editor/editorspellchecker;1", &rv);
 80486:     NS_ENSURE_SUCCESS(rv, false);
     1: 
 79445:     bool canSpellCheck = false;
     1:     rv = spellchecker->CanSpellCheck(&canSpellCheck);
 80486:     NS_ENSURE_SUCCESS(rv, false);
     1: 
     1:     if (canSpellCheck)
     1:       gCanEnableSpellChecking = SpellCheck_Available;
     1:   }
     1:   return (gCanEnableSpellChecking == SpellCheck_Available);
     1: }
     1: 
 78229: void // static
 78229: mozInlineSpellChecker::UpdateCanEnableInlineSpellChecking()
 78229: {
 78229:   gCanEnableSpellChecking = SpellCheck_Uninitialized;
 78229: }
 78229: 
     1: // mozInlineSpellChecker::RegisterEventListeners
     1: //
     1: //    The inline spell checker listens to mouse events and keyboard navigation+ //    events.
     1: 
     1: nsresult
     1: mozInlineSpellChecker::RegisterEventListeners()
     1: {
     1:   nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
     1:   NS_ENSURE_TRUE(editor, NS_ERROR_NULL_POINTER);
     1: 
     1:   editor->AddEditActionListener(this);
     1: 
     1:   nsCOMPtr<nsIDOMDocument> doc;
     1:   nsresult rv = editor->GetDocument(getter_AddRefs(doc));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 72326:   nsCOMPtr<nsIDOMEventTarget> piTarget = do_QueryInterface(doc, &rv);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 72645:   piTarget->AddEventListener(NS_LITERAL_STRING("blur"), this,
 80486:                              true, false);
 72645:   piTarget->AddEventListener(NS_LITERAL_STRING("click"), this,
 80486:                              false, false);
 72645:   piTarget->AddEventListener(NS_LITERAL_STRING("keypress"), this,
 80486:                              false, false);
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::UnregisterEventListeners
     1: 
     1: nsresult
     1: mozInlineSpellChecker::UnregisterEventListeners()
     1: {
     1:   nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
     1:   NS_ENSURE_TRUE(editor, NS_ERROR_NULL_POINTER);
     1: 
     1:   editor->RemoveEditActionListener(this);
     1: 
     1:   nsCOMPtr<nsIDOMDocument> doc;
     1:   editor->GetDocument(getter_AddRefs(doc));
     1:   NS_ENSURE_TRUE(doc, NS_ERROR_NULL_POINTER);
     1:   
 72326:   nsCOMPtr<nsIDOMEventTarget> piTarget = do_QueryInterface(doc);
  1418:   NS_ENSURE_TRUE(piTarget, NS_ERROR_NULL_POINTER);
     1: 
 80486:   piTarget->RemoveEventListener(NS_LITERAL_STRING("blur"), this, true);
 80486:   piTarget->RemoveEventListener(NS_LITERAL_STRING("click"), this, false);
 80486:   piTarget->RemoveEventListener(NS_LITERAL_STRING("keypress"), this, false);
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::GetEnableRealTimeSpell
     1: 
     1: NS_IMETHODIMP
 79445: mozInlineSpellChecker::GetEnableRealTimeSpell(bool* aEnabled)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aEnabled);
106838:   *aEnabled = mSpellCheck != nullptr;
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::SetEnableRealTimeSpell
     1: 
     1: NS_IMETHODIMP
 79445: mozInlineSpellChecker::SetEnableRealTimeSpell(bool aEnabled)
     1: {
     1:   if (!aEnabled) {
106838:     mSpellCheck = nullptr;
 80486:     return Cleanup(false);
     1:   }
     1: 
     1:   if (!mSpellCheck) {
     1:     nsresult res = NS_OK;
     1:     nsCOMPtr<nsIEditorSpellCheck> spellchecker = do_CreateInstance("@mozilla.org/editor/editorspellchecker;1", &res);
     1:     if (NS_SUCCEEDED(res) && spellchecker)
     1:     {
     1:       nsCOMPtr<nsITextServicesFilter> filter = do_CreateInstance("@mozilla.org/editor/txtsrvfiltermail;1", &res);
     1:       spellchecker->SetFilter(filter);
     1:       nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
 80486:       res = spellchecker->InitSpellChecker(editor, false);
     1:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       nsCOMPtr<nsITextServicesDocument> tsDoc = do_CreateInstance("@mozilla.org/textservices/textservicesdocument;1", &res);
     1:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       res = tsDoc->SetFilter(filter);
     1:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       res = tsDoc->InitWithEditor(editor);
     1:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       mTextServicesDocument = tsDoc;
     1:       mSpellCheck = spellchecker;
     1: 
     1:       // spell checking is enabled, register our event listeners to track navigation
     1:       RegisterEventListeners();
     1:     }
     1:   }
     1: 
     1:   // spellcheck the current contents. SpellCheckRange doesn't supply a created
     1:   // range to DoSpellCheck, which in our case is the entire range. But this
     1:   // optimization doesn't matter because there is nothing in the spellcheck
     1:   // selection when starting, which triggers a better optimization.
106838:   return SpellCheckRange(nullptr);
     1: }
     1: 
     1: // mozInlineSpellChecker::SpellCheckAfterEditorChange
     1: //
     1: //    Called by the editor when nearly anything happens to change the content.
     1: //
     1: //    The start and end positions specify a range for the thing that happened,
     1: //    but these are usually NULL, even when you'd think they would be useful
     1: //    because you want the range (for example, pasting). We ignore them in
     1: //    this case.
     1: 
     1: NS_IMETHODIMP
     1: mozInlineSpellChecker::SpellCheckAfterEditorChange(
108991:     int32_t aAction, nsISelection *aSelection,
108991:     nsIDOMNode *aPreviousSelectedNode, int32_t aPreviousSelectedOffset,
108991:     nsIDOMNode *aStartNode, int32_t aStartOffset,
108991:     nsIDOMNode *aEndNode, int32_t aEndOffset)
     1: {
     1:   nsresult rv;
     1:   NS_ENSURE_ARG_POINTER(aSelection);
     1:   if (!mSpellCheck)
     1:     return NS_OK; // disabling spell checking is not an error
     1: 
     1:   // this means something has changed, and we never check the current word,
     1:   // therefore, we should spellcheck for subsequent caret navigations
 80486:   mNeedsCheckAfterNavigation = true;
     1: 
     1:   // the anchor node is the position of the caret
     1:   nsCOMPtr<nsIDOMNode> anchorNode;
     1:   rv = aSelection->GetAnchorNode(getter_AddRefs(anchorNode));
     1:   NS_ENSURE_SUCCESS(rv, rv);
108991:   int32_t anchorOffset;
     1:   rv = aSelection->GetAnchorOffset(&anchorOffset);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   mozInlineSpellStatus status(this);
108165:   rv = status.InitForEditorChange((EditAction)aAction,
     1:                                   anchorNode, anchorOffset,
     1:                                   aPreviousSelectedNode, aPreviousSelectedOffset,
     1:                                   aStartNode, aStartOffset,
     1:                                   aEndNode, aEndOffset);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   rv = ScheduleSpellCheck(status);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // remember the current caret position after every change
     1:   SaveCurrentSelectionPosition();
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::SpellCheckRange
     1: //
     1: //    Spellchecks all the words in the given range.
     1: //    Supply a NULL range and this will check the entire editor.
     1: 
     1: nsresult
     1: mozInlineSpellChecker::SpellCheckRange(nsIDOMRange* aRange)
     1: {
     1:   NS_ENSURE_TRUE(mSpellCheck, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   mozInlineSpellStatus status(this);
 86939:   nsRange* range = static_cast<nsRange*>(aRange);
 81389:   nsresult rv = status.InitForRange(range);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   return ScheduleSpellCheck(status);
     1: }
     1: 
 30709: // mozInlineSpellChecker::GetMisspelledWord
     1: 
     1: NS_IMETHODIMP
108991: mozInlineSpellChecker::GetMisspelledWord(nsIDOMNode *aNode, int32_t aOffset,
     1:                                          nsIDOMRange **newword)
     1: {
  4729:   NS_ENSURE_ARG_POINTER(aNode);
     1:   nsCOMPtr<nsISelection> spellCheckSelection;
     1:   nsresult res = GetSpellCheckSelection(getter_AddRefs(spellCheckSelection));
     1:   NS_ENSURE_SUCCESS(res, res); 
     1: 
     1:   return IsPointInSelection(spellCheckSelection, aNode, aOffset, newword);
     1: }
     1: 
     1: // mozInlineSpellChecker::ReplaceWord
     1: 
     1: NS_IMETHODIMP
108991: mozInlineSpellChecker::ReplaceWord(nsIDOMNode *aNode, int32_t aOffset,
     1:                                    const nsAString &newword)
     1: {
     1:   nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
     1:   NS_ENSURE_TRUE(editor, NS_ERROR_NULL_POINTER);
     1:   NS_ENSURE_TRUE(newword.Length() != 0, NS_ERROR_FAILURE);
     1: 
     1:   nsCOMPtr<nsIDOMRange> range;
 30709:   nsresult res = GetMisspelledWord(aNode, aOffset, getter_AddRefs(range));
     1:   NS_ENSURE_SUCCESS(res, res); 
     1: 
     1:   if (range)
     1:   {
     1:     editor->BeginTransaction();
     1:   
     1:     nsCOMPtr<nsISelection> selection;
     1:     res = editor->GetSelection(getter_AddRefs(selection));
     1:     NS_ENSURE_SUCCESS(res, res);
     1:     selection->RemoveAllRanges();
     1:     selection->AddRange(range);
 98852:     editor->DeleteSelection(nsIEditor::eNone, nsIEditor::eStrip);
     1: 
     1:     nsCOMPtr<nsIPlaintextEditor> textEditor(do_QueryReferent(mEditor));
     1:     textEditor->InsertText(newword);
     1: 
     1:     editor->EndTransaction();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::AddWordToDictionary
     1: 
     1: NS_IMETHODIMP
     1: mozInlineSpellChecker::AddWordToDictionary(const nsAString &word)
     1: {
     1:   NS_ENSURE_TRUE(mSpellCheck, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsAutoString wordstr(word);
     1:   nsresult rv = mSpellCheck->AddWordToDictionary(wordstr.get());
     1:   NS_ENSURE_SUCCESS(rv, rv); 
     1: 
     1:   mozInlineSpellStatus status(this);
     1:   rv = status.InitForSelection();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   return ScheduleSpellCheck(status);
     1: }
     1: 
 86336: //  mozInlineSpellChecker::RemoveWordFromDictionary
 86336: 
 86336: NS_IMETHODIMP
 86336: mozInlineSpellChecker::RemoveWordFromDictionary(const nsAString &word)
 86336: {
 86336:   NS_ENSURE_TRUE(mSpellCheck, NS_ERROR_NOT_INITIALIZED);
 86336: 
 86336:   nsAutoString wordstr(word);
 86336:   nsresult rv = mSpellCheck->RemoveWordFromDictionary(wordstr.get());
 86336:   NS_ENSURE_SUCCESS(rv, rv); 
 86336:   
 86336:   mozInlineSpellStatus status(this);
106838:   rv = status.InitForRange(nullptr);
 86336:   NS_ENSURE_SUCCESS(rv, rv);
 86336:   return ScheduleSpellCheck(status);
 86336: }
 86336: 
     1: // mozInlineSpellChecker::IgnoreWord
     1: 
     1: NS_IMETHODIMP
     1: mozInlineSpellChecker::IgnoreWord(const nsAString &word)
     1: {
     1:   NS_ENSURE_TRUE(mSpellCheck, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsAutoString wordstr(word);
     1:   nsresult rv = mSpellCheck->IgnoreWordAllOccurrences(wordstr.get());
     1:   NS_ENSURE_SUCCESS(rv, rv); 
     1: 
     1:   mozInlineSpellStatus status(this);
     1:   rv = status.InitForSelection();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   return ScheduleSpellCheck(status);
     1: }
     1: 
     1: // mozInlineSpellChecker::IgnoreWords
     1: 
     1: NS_IMETHODIMP
     1: mozInlineSpellChecker::IgnoreWords(const PRUnichar **aWordsToIgnore,
108991:                                    uint32_t aCount)
     1: {
     1:   // add each word to the ignore list and then recheck the document
108991:   for (uint32_t index = 0; index < aCount; index++)
     1:     mSpellCheck->IgnoreWordAllOccurrences(aWordsToIgnore[index]);
     1: 
     1:   mozInlineSpellStatus status(this);
     1:   nsresult rv = status.InitForSelection();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   return ScheduleSpellCheck(status);
     1: }
     1: 
108991: NS_IMETHODIMP mozInlineSpellChecker::WillCreateNode(const nsAString & aTag, nsIDOMNode *aParent, int32_t aPosition)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::DidCreateNode(const nsAString & aTag, nsIDOMNode *aNode, nsIDOMNode *aParent,
108991:                                                    int32_t aPosition, nsresult aResult)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::WillInsertNode(nsIDOMNode *aNode, nsIDOMNode *aParent,
108991:                                                     int32_t aPosition)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::DidInsertNode(nsIDOMNode *aNode, nsIDOMNode *aParent,
108991:                                                    int32_t aPosition, nsresult aResult)
     1: {
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::WillDeleteNode(nsIDOMNode *aChild)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::DidDeleteNode(nsIDOMNode *aChild, nsresult aResult)
     1: {
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP mozInlineSpellChecker::WillSplitNode(nsIDOMNode *aExistingRightNode, int32_t aOffset)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: mozInlineSpellChecker::DidSplitNode(nsIDOMNode *aExistingRightNode,
108991:                                     int32_t aOffset,
     1:                                     nsIDOMNode *aNewLeftNode, nsresult aResult)
     1: {
     1:   return SpellCheckBetweenNodes(aNewLeftNode, 0, aNewLeftNode, 0);
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::WillJoinNodes(nsIDOMNode *aLeftNode, nsIDOMNode *aRightNode, nsIDOMNode *aParent)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::DidJoinNodes(nsIDOMNode *aLeftNode, nsIDOMNode *aRightNode, 
     1:                                                   nsIDOMNode *aParent, nsresult aResult)
     1: {
     1:   return SpellCheckBetweenNodes(aRightNode, 0, aRightNode, 0);
     1: }
     1: 
108991: NS_IMETHODIMP mozInlineSpellChecker::WillInsertText(nsIDOMCharacterData *aTextNode, int32_t aOffset, const nsAString & aString)
     1: {
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP mozInlineSpellChecker::DidInsertText(nsIDOMCharacterData *aTextNode, int32_t aOffset,
     1:                                                    const nsAString & aString, nsresult aResult)
     1: {
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP mozInlineSpellChecker::WillDeleteText(nsIDOMCharacterData *aTextNode, int32_t aOffset, int32_t aLength)
     1: {
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP mozInlineSpellChecker::DidDeleteText(nsIDOMCharacterData *aTextNode, int32_t aOffset, int32_t aLength, nsresult aResult)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::WillDeleteSelection(nsISelection *aSelection)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::DidDeleteSelection(nsISelection *aSelection)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::MakeSpellCheckRange
     1: //
     1: //    Given begin and end positions, this function constructs a range as
     1: //    required for ScheduleSpellCheck. If the start and end nodes are NULL,
     1: //    then the entire range will be selected, and you can supply -1 as the
     1: //    offset to the end range to select all of that node.
     1: //
     1: //    If the resulting range would be empty, NULL is put into *aRange and the
     1: //    function succeeds.
     1: 
     1: nsresult
     1: mozInlineSpellChecker::MakeSpellCheckRange(
108991:     nsIDOMNode* aStartNode, int32_t aStartOffset,
108991:     nsIDOMNode* aEndNode, int32_t aEndOffset,
 86939:     nsRange** aRange)
     1: {
     1:   nsresult rv;
106838:   *aRange = nullptr;
     1: 
     1:   nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
     1:   NS_ENSURE_TRUE(editor, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMDocument> doc;
     1:   rv = editor->GetDocument(getter_AddRefs(doc));
     1:   NS_ENSURE_SUCCESS(rv, rv);
 69898:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
     1: 
     1:   nsCOMPtr<nsIDOMRange> range;
 69898:   rv = doc->CreateRange(getter_AddRefs(range));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // possibly use full range of the editor
     1:   nsCOMPtr<nsIDOMElement> rootElem;
     1:   if (! aStartNode || ! aEndNode) {
     1:     rv = editor->GetRootElement(getter_AddRefs(rootElem));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     aStartNode = rootElem;
     1:     aStartOffset = 0;
     1: 
     1:     aEndNode = rootElem;
     1:     aEndOffset = -1;
     1:   }
     1: 
     1:   if (aEndOffset == -1) {
     1:     nsCOMPtr<nsIDOMNodeList> childNodes;
     1:     rv = aEndNode->GetChildNodes(getter_AddRefs(childNodes));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
108991:     uint32_t childCount;
     1:     rv = childNodes->GetLength(&childCount);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     aEndOffset = childCount;
     1:   }
     1: 
     1:   // sometimes we are are requested to check an empty range (possibly an empty
     1:   // document). This will result in assertions later.
     1:   if (aStartNode == aEndNode && aStartOffset == aEndOffset)
     1:     return NS_OK;
     1: 
     1:   rv = range->SetStart(aStartNode, aStartOffset);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   if (aEndOffset)
     1:     rv = range->SetEnd(aEndNode, aEndOffset);
     1:   else
     1:     rv = range->SetEndAfter(aEndNode);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 86939:   *aRange = static_cast<nsRange*>(range.forget().get());
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: mozInlineSpellChecker::SpellCheckBetweenNodes(nsIDOMNode *aStartNode,
108991:                                               int32_t aStartOffset,
     1:                                               nsIDOMNode *aEndNode,
108991:                                               int32_t aEndOffset)
     1: {
 86939:   nsRefPtr<nsRange> range;
     1:   nsresult rv = MakeSpellCheckRange(aStartNode, aStartOffset,
     1:                                     aEndNode, aEndOffset,
     1:                                     getter_AddRefs(range));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (! range)
     1:     return NS_OK; // range is empty: nothing to do
     1: 
     1:   mozInlineSpellStatus status(this);
     1:   rv = status.InitForRange(range);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   return ScheduleSpellCheck(status);
     1: }
     1: 
     1: // mozInlineSpellChecker::SkipSpellCheckForNode
     1: //
     1: //    There are certain conditions when we don't want to spell check a node. In
     1: //    particular quotations, moz signatures, etc. This routine returns false
     1: //    for these cases.
     1: 
     1: nsresult
     1: mozInlineSpellChecker::SkipSpellCheckForNode(nsIEditor* aEditor,
     1:                                              nsIDOMNode *aNode,
 79445:                                              bool *checkSpelling)
     1: {
 80486:   *checkSpelling = true;
     1:   NS_ENSURE_ARG_POINTER(aNode);
     1: 
108991:   uint32_t flags;
     1:   aEditor->GetFlags(&flags);
     1:   if (flags & nsIPlaintextEditor::eEditorMailMask)
     1:   {
     1:     nsCOMPtr<nsIDOMNode> parent;
     1:     aNode->GetParentNode(getter_AddRefs(parent));
     1: 
     1:     while (parent)
     1:     {
     1:       nsCOMPtr<nsIDOMElement> parentElement = do_QueryInterface(parent);
     1:       if (!parentElement)
     1:         break;
     1: 
     1:       nsAutoString parentTagName;
     1:       parentElement->GetTagName(parentTagName);
     1: 
     1:       if (parentTagName.Equals(NS_LITERAL_STRING("blockquote"), nsCaseInsensitiveStringComparator()))
     1:       {
 32048:         nsAutoString quotetype;
 32048:         parentElement->GetAttribute(NS_LITERAL_STRING("type"), quotetype);
 32048:         if (quotetype.Equals(NS_LITERAL_STRING("cite"), nsCaseInsensitiveStringComparator()))
 32048:         {
 80486:           *checkSpelling = false;
     1:           break;
     1:         }
 32048:       }
     1:       else if (parentTagName.Equals(NS_LITERAL_STRING("pre"), nsCaseInsensitiveStringComparator()))
     1:       {
     1:         nsAutoString classname;
     1:         parentElement->GetAttribute(NS_LITERAL_STRING("class"),classname);
     1:         if (classname.Equals(NS_LITERAL_STRING("moz-signature")))
 80486:           *checkSpelling = false;
     1:       }
     1: 
     1:       nsCOMPtr<nsIDOMNode> nextParent;
     1:       parent->GetParentNode(getter_AddRefs(nextParent));
     1:       parent = nextParent;
     1:     }
     1:   }
  2896:   else {
 63543:     // XXX Do we really want this for all editable content?
  2896:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 63543:     *checkSpelling = content->IsEditable();
  2896:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::ScheduleSpellCheck
     1: //
     1: //    This is called by code to do the actual spellchecking. We will set up
     1: //    the proper structures for calls to DoSpellCheck.
     1: 
     1: nsresult
     1: mozInlineSpellChecker::ScheduleSpellCheck(const mozInlineSpellStatus& aStatus)
     1: {
 81390:   if (mFullSpellCheckScheduled) {
 81390:     // Just ignore this; we're going to spell-check everything anyway
 81390:     return NS_OK;
 81390:   }
 81390: 
     1:   mozInlineSpellResume* resume = new mozInlineSpellResume(aStatus);
     1:   NS_ENSURE_TRUE(resume, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:   nsresult rv = resume->Post();
 81390:   if (NS_FAILED(rv)) {
     1:     delete resume;
 81390:   } else if (aStatus.IsFullSpellCheck()) {
 81390:     // We're going to check everything.  Suppress further spell-check attempts
 81390:     // until that happens.
 81390:     mFullSpellCheckScheduled = true;
 81390:   }
     1:   return rv;
     1: }
     1: 
     1: // mozInlineSpellChecker::DoSpellCheckSelection
     1: //
     1: //    Called to re-check all misspelled words. We iterate over all ranges in
     1: //    the selection and call DoSpellCheck on them. This is used when a word
     1: //    is ignored or added to the dictionary: all instances of that word should
     1: //    be removed from the selection.
     1: //
     1: //    FIXME-PERFORMANCE: This takes as long as it takes and is not resumable.
     1: //    Typically, checking this small amount of text is relatively fast, but
 32209: //    for large numbers of words, a lag may be noticeable.
     1: 
     1: nsresult
     1: mozInlineSpellChecker::DoSpellCheckSelection(mozInlineSpellWordUtil& aWordUtil,
     1:                                              nsISelection* aSpellCheckSelection,
     1:                                              mozInlineSpellStatus* aStatus)
     1: {
     1:   nsresult rv;
     1: 
     1:   // clear out mNumWordsInSpellSelection since we'll be rebuilding the ranges.
     1:   mNumWordsInSpellSelection = 0;
     1: 
     1:   // Since we could be modifying the ranges for the spellCheckSelection while
     1:   // looping on the spell check selection, keep a separate array of range
     1:   // elements inside the selection
     1:   nsCOMArray<nsIDOMRange> ranges;
     1: 
108991:   int32_t count;
     1:   aSpellCheckSelection->GetRangeCount(&count);
     1: 
108991:   int32_t idx;
     1:   nsCOMPtr<nsIDOMRange> checkRange;
     1:   for (idx = 0; idx < count; idx ++) {
     1:     aSpellCheckSelection->GetRangeAt(idx, getter_AddRefs(checkRange));
     1:     if (checkRange) {
     1:       if (! ranges.AppendObject(checkRange))
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   // We have saved the ranges above. Clearing the spellcheck selection here
     1:   // isn't necessary (rechecking each word will modify it as necessary) but
     1:   // provides better performance. By ensuring that no ranges need to be
     1:   // removed in DoSpellCheck, we can save checking range inclusion which is
     1:   // slow.
     1:   aSpellCheckSelection->RemoveAllRanges();
     1: 
     1:   // We use this state object for all calls, and just update its range. Note
     1:   // that we don't need to call FinishInit since we will be filling in the
     1:   // necessary information.
     1:   mozInlineSpellStatus status(this);
106838:   rv = status.InitForRange(nullptr);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 79445:   bool doneChecking;
     1:   for (idx = 0; idx < count; idx ++) {
     1:     checkRange = ranges[idx];
     1:     if (checkRange) {
     1:       // We can consider this word as "added" since we know it has no spell
     1:       // check range over it that needs to be deleted. All the old ranges
     1:       // were cleared above. We also need to clear the word count so that we
     1:       // check all words instead of stopping early.
 86939:       status.mRange = static_cast<nsRange*>(checkRange.get());
     1:       rv = DoSpellCheck(aWordUtil, aSpellCheckSelection, &status,
     1:                         &doneChecking);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:       NS_ASSERTION(doneChecking, "We gave the spellchecker one word, but it didn't finish checking?!?!");
     1: 
     1:       status.mWordCount = 0;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::DoSpellCheck
     1: //
     1: //    This function checks words intersecting the given range, excluding those
     1: //    inside mStatus->mNoCheckRange (can be NULL). Words inside aNoCheckRange
     1: //    will have any spell selection removed (this is used to hide the
     1: //    underlining for the word that the caret is in). aNoCheckRange should be
     1: //    on word boundaries.
     1: //
     1: //    mResume->mCreatedRange is a possibly NULL range of new text that was
     1: //    inserted.  Inside this range, we don't bother to check whether things are
     1: //    inside the spellcheck selection, which speeds up large paste operations
     1: //    considerably.
     1: //
     1: //    Normal case when editing text by typing
     1: //       h e l l o   w o r k d   h o w   a r e   y o u
     1: //                            ^ caret
     1: //                   [-------] mRange
     1: //                   [-------] mNoCheckRange
     1: //      -> does nothing (range is the same as the no check range)
     1: //
     1: //    Case when pasting:
     1: //             [---------- pasted text ----------]
     1: //       h e l l o   w o r k d   h o w   a r e   y o u
     1: //                                                ^ caret
     1: //                                               [---] aNoCheckRange
     1: //      -> recheck all words in range except those in aNoCheckRange
     1: //
     1: //    If checking is complete, *aDoneChecking will be set. If there is more
     1: //    but we ran out of time, this will be false and the range will be
     1: //    updated with the stuff that still needs checking.
     1: 
     1: nsresult mozInlineSpellChecker::DoSpellCheck(mozInlineSpellWordUtil& aWordUtil,
     1:                                              nsISelection *aSpellCheckSelection,
     1:                                              mozInlineSpellStatus* aStatus,
 79445:                                              bool* aDoneChecking)
     1: {
 80486:   *aDoneChecking = true;
     1: 
     1:   // get the editor for SkipSpellCheckForNode, this may fail in reasonable
     1:   // circumstances since the editor could have gone away
     1:   nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
     1:   if (! editor)
     1:     return NS_ERROR_FAILURE;
     1: 
 79445:   bool iscollapsed;
     1:   nsresult rv = aStatus->mRange->GetCollapsed(&iscollapsed);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   if (iscollapsed)
     1:     return NS_OK;
     1: 
 75112:   nsCOMPtr<nsISelectionPrivate> privSel = do_QueryInterface(aSpellCheckSelection);
     1: 
     1:   // see if the selection has any ranges, if not, then we can optimize checking
     1:   // range inclusion later (we have no ranges when we are initially checking or
     1:   // when there are no misspelled words yet).
108991:   int32_t originalRangeCount;
     1:   rv = aSpellCheckSelection->GetRangeCount(&originalRangeCount);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // set the starting DOM position to be the beginning of our range
 81389:   {
 81389:     // Scope for the node/offset pairs here so they don't get
 81389:     // accidentally used later
 81389:     nsINode* beginNode = aStatus->mRange->GetStartParent();
108991:     int32_t beginOffset = aStatus->mRange->StartOffset();
 81389:     nsINode* endNode = aStatus->mRange->GetEndParent();
108991:     int32_t endOffset = aStatus->mRange->EndOffset();
 81389: 
 81389:     // Now check that we're still looking at a range that's under
 81389:     // aWordUtil.GetRootNode()
 81389:     nsINode* rootNode = aWordUtil.GetRootNode();
 81389:     if (!nsContentUtils::ContentIsDescendantOf(beginNode, rootNode) ||
 81389:         !nsContentUtils::ContentIsDescendantOf(endNode, rootNode)) {
 81389:       // Just bail out and don't try to spell-check this
 81389:       return NS_OK;
 81389:     }
 81389:   
     1:     aWordUtil.SetEnd(endNode, endOffset);
     1:     aWordUtil.SetPosition(beginNode, beginOffset);
 81389:   }
     1: 
 13845:   // aWordUtil.SetPosition flushes pending notifications, check editor again.
 13845:   editor = do_QueryReferent(mEditor);
 13845:   if (! editor)
 13845:     return NS_ERROR_FAILURE;
 13845: 
108991:   int32_t wordsSinceTimeCheck = 0;
     1:   PRTime beginTime = PR_Now();
     1: 
     1:   nsAutoString wordText;
 86939:   nsRefPtr<nsRange> wordRange;
 79445:   bool dontCheckWord;
     1:   while (NS_SUCCEEDED(aWordUtil.GetNextWord(wordText,
     1:                                             getter_AddRefs(wordRange),
     1:                                             &dontCheckWord)) &&
     1:          wordRange) {
     1:     wordsSinceTimeCheck ++;
     1: 
 81389:     // get the range for the current word.
 81389:     // Not using nsINode here for now because we have to call into
 81389:     // selection APIs that use nsIDOMNode. :(
 81389:     nsCOMPtr<nsIDOMNode> beginNode, endNode;
108991:     int32_t beginOffset, endOffset;
     1:     wordRange->GetStartContainer(getter_AddRefs(beginNode));
     1:     wordRange->GetEndContainer(getter_AddRefs(endNode));
     1:     wordRange->GetStartOffset(&beginOffset);
     1:     wordRange->GetEndOffset(&endOffset);
     1: 
     1: #ifdef DEBUG_INLINESPELL
     1:     printf("->Got word \"%s\"", NS_ConvertUTF16toUTF8(wordText).get());
     1:     if (dontCheckWord)
     1:       printf(" (not checking)");
     1:     printf("\n");
     1: #endif
     1: 
     1:     // see if there is a spellcheck range that already intersects the word
     1:     // and remove it. We only need to remove old ranges, so don't bother if
     1:     // there were no ranges when we started out.
     1:     if (originalRangeCount > 0) {
     1:       // likewise, if this word is inside new text, we won't bother testing
 79445:       bool inCreatedRange = false;
 86938:       if (aStatus->mCreatedRange)
 86938:         aStatus->mCreatedRange->IsPointInRange(beginNode, beginOffset, &inCreatedRange);
     1:       if (! inCreatedRange) {
 86939:         nsTArray<nsRange*> ranges;
 86939:         nsCOMPtr<nsINode> firstNode = do_QueryInterface(beginNode);
 86939:         nsCOMPtr<nsINode> lastNode = do_QueryInterface(endNode);
 86939:         rv = privSel->GetRangesForIntervalArray(firstNode, beginOffset,
 86939:                                                 lastNode, endOffset,
 80486:                                                 true, &ranges);
     1:         NS_ENSURE_SUCCESS(rv, rv);
108991:         for (uint32_t i = 0; i < ranges.Length(); i++)
     1:           RemoveRange(aSpellCheckSelection, ranges[i]);
     1:       }
     1:     }
     1: 
     1:     // some words are special and don't need checking
     1:     if (dontCheckWord)
     1:       continue;
     1: 
     1:     // some nodes we don't spellcheck
 79445:     bool checkSpelling;
     1:     rv = SkipSpellCheckForNode(editor, beginNode, &checkSpelling);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     if (!checkSpelling)
     1:       continue;
     1: 
     1:     // Don't check spelling if we're inside the noCheckRange. This needs to
     1:     // be done after we clear any old selection because the excluded word
     1:     // might have been previously marked.
     1:     //
     1:     // We do a simple check to see if the beginning of our word is in the
     1:     // exclusion range. Because the exclusion range is a multiple of a word,
     1:     // this is sufficient.
 86938:     if (aStatus->mNoCheckRange) {
 79445:       bool inExclusion = false;
 86938:       aStatus->mNoCheckRange->IsPointInRange(beginNode, beginOffset,
 86938:                                              &inExclusion);
     1:       if (inExclusion)
     1:         continue;
     1:     }
     1: 
     1:     // check spelling and add to selection if misspelled
 79445:     bool isMisspelled;
     1:     aWordUtil.NormalizeWord(wordText);
     1:     rv = mSpellCheck->CheckCurrentWordNoSuggest(wordText.get(), &isMisspelled);
 75374:     if (NS_FAILED(rv))
 75374:       continue;
 75374: 
     1:     if (isMisspelled) {
     1:       // misspelled words count extra toward the max
     1:       wordsSinceTimeCheck += MISSPELLED_WORD_COUNT_PENALTY;
     1:       AddRange(aSpellCheckSelection, wordRange);
     1: 
     1:       aStatus->mWordCount ++;
     1:       if (aStatus->mWordCount >= mMaxMisspellingsPerCheck ||
     1:           SpellCheckSelectionIsFull())
     1:         break;
     1:     }
     1: 
     1:     // see if we've run out of time, only check every N words for perf
     1:     if (wordsSinceTimeCheck >= INLINESPELL_TIMEOUT_CHECK_FREQUENCY) {
     1:       wordsSinceTimeCheck = 0;
 13845:       if (PR_Now() > PRTime(beginTime + INLINESPELL_CHECK_TIMEOUT * PR_USEC_PER_MSEC)) {
     1:         // stop checking, our time limit has been exceeded
     1: 
     1:         // move the range to encompass the stuff that needs checking
     1:         rv = aStatus->mRange->SetStart(endNode, endOffset);
     1:         if (NS_FAILED(rv)) {
     1:           // The range might be unhappy because the beginning is after the
     1:           // end. This is possible when the requested end was in the middle
     1:           // of a word, just ignore this situation and assume we're done.
     1:           return NS_OK;
     1:         }
 80486:         *aDoneChecking = false;
     1:         return NS_OK;
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // mozInlineSpellChecker::ResumeCheck
     1: //
     1: //    Called by the resume event when it fires. We will try to pick up where
     1: //    the last resume left off.
     1: 
     1: nsresult
     1: mozInlineSpellChecker::ResumeCheck(mozInlineSpellStatus* aStatus)
     1: {
 81390:   if (aStatus->IsFullSpellCheck()) {
 81390:     // Allow posting new spellcheck resume events from inside
 81390:     // ResumeCheck, now that we're actually firing.
 81390:     NS_ASSERTION(mFullSpellCheckScheduled,
 81390:                  "How could this be false?  The full spell check is "
 81390:                  "calling us!!");
 81390:     mFullSpellCheckScheduled = false;
 81390:   }
 81390: 
     1:   if (! mSpellCheck)
     1:     return NS_OK; // spell checking has been turned off
     1: 
 13845:   nsCOMPtr<nsIEditor> editor = do_QueryReferent(mEditor);
 13845:   if (! editor)
 13845:     return NS_OK; // editor is gone
 13845: 
     1:   mozInlineSpellWordUtil wordUtil;
     1:   nsresult rv = wordUtil.Init(mEditor);
     1:   if (NS_FAILED(rv))
     1:     return NS_OK; // editor doesn't like us, don't assert
     1: 
     1:   nsCOMPtr<nsISelection> spellCheckSelection;
     1:   rv = GetSpellCheckSelection(getter_AddRefs(spellCheckSelection));
     1:   NS_ENSURE_SUCCESS(rv, rv);
 75374: 
 76316:   nsAutoString currentDictionary;
 76316:   rv = mSpellCheck->GetCurrentDictionary(currentDictionary);
 75374:   if (NS_FAILED(rv)) {
 75374:     // no active dictionary
108991:     int32_t count;
 75374:     spellCheckSelection->GetRangeCount(&count);
108991:     for (int32_t index = count - 1; index >= 0; index--) {
 75374:       nsCOMPtr<nsIDOMRange> checkRange;
 75374:       spellCheckSelection->GetRangeAt(index, getter_AddRefs(checkRange));
 75374:       if (checkRange) {
 75374:         RemoveRange(spellCheckSelection, checkRange);
 75374:       }
 75374:     }
 75374:     return NS_OK; 
 75374:   }
 75374:  
     1:   CleanupRangesInSelection(spellCheckSelection);
     1: 
     1:   rv = aStatus->FinishInitOnEvent(wordUtil);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   if (! aStatus->mRange)
     1:     return NS_OK; // empty range, nothing to do
     1: 
 79445:   bool doneChecking = true;
     1:   if (aStatus->mOp == mozInlineSpellStatus::eOpSelection)
     1:     rv = DoSpellCheckSelection(wordUtil, spellCheckSelection, aStatus);
     1:   else
     1:     rv = DoSpellCheck(wordUtil, spellCheckSelection, aStatus, &doneChecking);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (! doneChecking)
     1:     rv = ScheduleSpellCheck(*aStatus);
     1:   return rv;
     1: }
     1: 
     1: // mozInlineSpellChecker::IsPointInSelection
     1: //
     1: //    Determines if a given (node,offset) point is inside the given
     1: //    selection. If so, the specific range of the selection that
     1: //    intersects is places in *aRange. (There may be multiple disjoint
     1: //    ranges in a selection.)
     1: //
     1: //    If there is no intersection, *aRange will be NULL.
     1: 
     1: nsresult
     1: mozInlineSpellChecker::IsPointInSelection(nsISelection *aSelection,
     1:                                           nsIDOMNode *aNode,
108991:                                           int32_t aOffset,
     1:                                           nsIDOMRange **aRange)
     1: {
106838:   *aRange = nullptr;
     1: 
 75112:   nsCOMPtr<nsISelectionPrivate> privSel(do_QueryInterface(aSelection));
     1: 
 86939:   nsTArray<nsRange*> ranges;
 86939:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
 86939:   nsresult rv = privSel->GetRangesForIntervalArray(node, aOffset, node, aOffset,
 80486:                                                    true, &ranges);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 86939:   if (ranges.Length() == 0)
     1:     return NS_OK; // no matches
     1: 
     1:   // there may be more than one range returned, and we don't know what do
     1:   // do with that, so just get the first one
     1:   NS_ADDREF(*aRange = ranges[0]);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: mozInlineSpellChecker::CleanupRangesInSelection(nsISelection *aSelection)
     1: {
     1:   // integrity check - remove ranges that have collapsed to nothing. This
     1:   // can happen if the node containing a highlighted word was removed.
     1:   NS_ENSURE_ARG_POINTER(aSelection);
     1: 
108991:   int32_t count;
     1:   aSelection->GetRangeCount(&count);
     1: 
108991:   for (int32_t index = 0; index < count; index++)
     1:   {
     1:     nsCOMPtr<nsIDOMRange> checkRange;
     1:     aSelection->GetRangeAt(index, getter_AddRefs(checkRange));
     1: 
     1:     if (checkRange)
     1:     {
 79445:       bool collapsed;
     1:       checkRange->GetCollapsed(&collapsed);
     1:       if (collapsed)
     1:       {
     1:         RemoveRange(aSelection, checkRange);
     1:         index--;
     1:         count--;
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // mozInlineSpellChecker::RemoveRange
     1: //
     1: //    For performance reasons, we have an upper bound on the number of word
     1: //    ranges  in the spell check selection. When removing a range from the
     1: //    selection, we need to decrement mNumWordsInSpellSelection
     1: 
     1: nsresult
     1: mozInlineSpellChecker::RemoveRange(nsISelection* aSpellCheckSelection,
     1:                                    nsIDOMRange* aRange)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aSpellCheckSelection);
     1:   NS_ENSURE_ARG_POINTER(aRange);
     1: 
     1:   nsresult rv = aSpellCheckSelection->RemoveRange(aRange);
     1:   if (NS_SUCCEEDED(rv) && mNumWordsInSpellSelection)
     1:     mNumWordsInSpellSelection--;
     1: 
     1:   return rv;
     1: }
     1: 
     1: 
     1: // mozInlineSpellChecker::AddRange
     1: //
     1: //    For performance reasons, we have an upper bound on the number of word
     1: //    ranges we'll add to the spell check selection. Once we reach that upper
     1: //    bound, stop adding the ranges
     1: 
     1: nsresult
     1: mozInlineSpellChecker::AddRange(nsISelection* aSpellCheckSelection,
     1:                                 nsIDOMRange* aRange)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aSpellCheckSelection);
     1:   NS_ENSURE_ARG_POINTER(aRange);
     1: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   if (!SpellCheckSelectionIsFull())
     1:   {
     1:     rv = aSpellCheckSelection->AddRange(aRange);
     1:     if (NS_SUCCEEDED(rv))
     1:       mNumWordsInSpellSelection++;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult mozInlineSpellChecker::GetSpellCheckSelection(nsISelection ** aSpellCheckSelection)
     1: { 
     1:   nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
     1:   NS_ENSURE_TRUE(editor, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsISelectionController> selcon;
     1:   nsresult rv = editor->GetSelectionController(getter_AddRefs(selcon));
     1:   NS_ENSURE_SUCCESS(rv, rv); 
     1: 
     1:   nsCOMPtr<nsISelection> spellCheckSelection;
     1:   return selcon->GetSelection(nsISelectionController::SELECTION_SPELLCHECK, aSpellCheckSelection);
     1: }
     1: 
     1: nsresult mozInlineSpellChecker::SaveCurrentSelectionPosition()
     1: {
     1:   nsCOMPtr<nsIEditor> editor (do_QueryReferent(mEditor));
     1:   NS_ENSURE_TRUE(editor, NS_OK);
     1: 
     1:   // figure out the old caret position based on the current selection
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult rv = editor->GetSelection(getter_AddRefs(selection));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   rv = selection->GetFocusNode(getter_AddRefs(mCurrentSelectionAnchorNode));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   
     1:   selection->GetFocusOffset(&mCurrentSelectionOffset);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // This is a copy of nsContentUtils::ContentIsDescendantOf. Another crime
     1: // for XPCOM's rap sheet
 79445: bool // static
     1: ContentIsDescendantOf(nsINode* aPossibleDescendant,
     1:                       nsINode* aPossibleAncestor)
     1: {
     1:   NS_PRECONDITION(aPossibleDescendant, "The possible descendant is null!");
     1:   NS_PRECONDITION(aPossibleAncestor, "The possible ancestor is null!");
     1: 
     1:   do {
     1:     if (aPossibleDescendant == aPossibleAncestor)
 80486:       return true;
     1:     aPossibleDescendant = aPossibleDescendant->GetNodeParent();
     1:   } while (aPossibleDescendant);
     1: 
 80486:   return false;
     1: }
     1: 
     1: // mozInlineSpellChecker::HandleNavigationEvent
     1: //
     1: //    Acts upon mouse clicks and keyboard navigation changes, spell checking
     1: //    the previous word if the new navigation location moves us to another
     1: //    word.
     1: //
     1: //    This is complicated by the fact that our mouse events are happening after
     1: //    selection has been changed to account for the mouse click. But keyboard
     1: //    events are happening before the caret selection has changed. Working
     1: //    around this by letting keyboard events setting forceWordSpellCheck to
     1: //    true. aNewPositionOffset also tries to work around this for the
     1: //    DOM_VK_RIGHT and DOM_VK_LEFT cases.
     1: 
     1: nsresult
 79445: mozInlineSpellChecker::HandleNavigationEvent(bool aForceWordSpellCheck,
108991:                                              int32_t aNewPositionOffset)
     1: {
     1:   nsresult rv;
     1: 
     1:   // If we already handled the navigation event and there is no possibility
     1:   // anything has changed since then, we don't have to do anything. This
 32209:   // optimization makes a noticeable difference when you hold down a navigation
     1:   // key like Page Down.
     1:   if (! mNeedsCheckAfterNavigation)
     1:     return NS_OK;
     1: 
     1:   nsCOMPtr<nsIDOMNode> currentAnchorNode = mCurrentSelectionAnchorNode;
108991:   int32_t currentAnchorOffset = mCurrentSelectionOffset;
     1: 
     1:   // now remember the new focus position resulting from the event
     1:   rv = SaveCurrentSelectionPosition();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 79445:   bool shouldPost;
     1:   mozInlineSpellStatus status(this);
     1:   rv = status.InitForNavigation(aForceWordSpellCheck, aNewPositionOffset,
     1:                                 currentAnchorNode, currentAnchorOffset,
     1:                                 mCurrentSelectionAnchorNode, mCurrentSelectionOffset,
     1:                                 &shouldPost);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   if (shouldPost) {
     1:     rv = ScheduleSpellCheck(status);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP mozInlineSpellChecker::HandleEvent(nsIDOMEvent* aEvent)
     1: {
 72645:   nsAutoString eventType;
 72645:   aEvent->GetType(eventType);
 72645: 
 72645:   if (eventType.EqualsLiteral("blur")) {
 72645:     return Blur(aEvent);
 72645:   }
 72645:   if (eventType.EqualsLiteral("click")) {
 72645:     return MouseClick(aEvent);
 72645:   }
 72645:   if (eventType.EqualsLiteral("keypress")) {
 72645:     return KeyPress(aEvent);
 72645:   }
 72645: 
     1:   return NS_OK;
     1: }
     1: 
 72645: nsresult mozInlineSpellChecker::Blur(nsIDOMEvent* aEvent)
  6346: {
 72645:   // force spellcheck on blur, for instance when tabbing out of a textbox
 80486:   HandleNavigationEvent(true);
  6346:   return NS_OK;
  6346: }
  6346: 
 72645: nsresult mozInlineSpellChecker::MouseClick(nsIDOMEvent *aMouseEvent)
     1: {
  6142:   nsCOMPtr<nsIDOMMouseEvent>mouseEvent = do_QueryInterface(aMouseEvent);
  6142:   NS_ENSURE_TRUE(mouseEvent, NS_OK);
  6142: 
     1:   // ignore any errors from HandleNavigationEvent as we don't want to prevent 
     1:   // anyone else from seeing this event.
108991:   uint16_t button;
  6142:   mouseEvent->GetButton(&button);
 72645:   HandleNavigationEvent(button != 0);
     1:   return NS_OK;
     1: }
     1: 
 72645: nsresult mozInlineSpellChecker::KeyPress(nsIDOMEvent* aKeyEvent)
     1: {
     1:   nsCOMPtr<nsIDOMKeyEvent>keyEvent = do_QueryInterface(aKeyEvent);
     1:   NS_ENSURE_TRUE(keyEvent, NS_OK);
     1: 
108991:   uint32_t keyCode;
     1:   keyEvent->GetKeyCode(&keyCode);
     1: 
     1:   // we only care about navigation keys that moved selection 
     1:   switch (keyCode)
     1:   {
     1:     case nsIDOMKeyEvent::DOM_VK_RIGHT:
     1:     case nsIDOMKeyEvent::DOM_VK_LEFT:
 80486:       HandleNavigationEvent(false, keyCode == nsIDOMKeyEvent::DOM_VK_RIGHT ? 1 : -1);
     1:       break;
     1:     case nsIDOMKeyEvent::DOM_VK_UP:
     1:     case nsIDOMKeyEvent::DOM_VK_DOWN:
     1:     case nsIDOMKeyEvent::DOM_VK_HOME:
     1:     case nsIDOMKeyEvent::DOM_VK_END:
     1:     case nsIDOMKeyEvent::DOM_VK_PAGE_UP:
     1:     case nsIDOMKeyEvent::DOM_VK_PAGE_DOWN:
 80486:       HandleNavigationEvent(true /* force a spelling correction */);
     1:       break;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
 75374: 
 75374: NS_IMETHODIMP mozInlineSpellChecker::UpdateCurrentDictionary()
 75374: {
 75374:   if (!mSpellCheck) {
 75374:     return NS_OK;
 75374:   }
 75374: 
 76316:   nsAutoString previousDictionary;
 76316:   if (NS_FAILED(mSpellCheck->GetCurrentDictionary(previousDictionary))) {
 76316:     previousDictionary.Truncate();
 75374:   }
 75374: 
118494:   // This might set mSpellCheck to null (bug 793866)
 77070:   nsresult rv = mSpellCheck->UpdateCurrentDictionary();
 75374: 
 76316:   nsAutoString currentDictionary;
118494:   if (!mSpellCheck ||
118494:       NS_FAILED(mSpellCheck->GetCurrentDictionary(currentDictionary))) {
 76316:     currentDictionary.Truncate();
 75374:   }
 75374: 
 76316:   if (!previousDictionary.Equals(currentDictionary)) {
106838:       rv = SpellCheckRange(nullptr);
 75374:   }
 75374: 
 75374:   return rv;
 75374: }
