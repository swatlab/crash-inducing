    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla SVG project.
    1:  *
    1:  * The Initial Developer of the Original Code is IBM Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2004
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsSVGPathGeometryFrame.h"
    1: #include "imgIContainer.h"
    1: #include "nsStubImageDecoderObserver.h"
    1: #include "nsImageLoadingContent.h"
    1: #include "nsIDOMSVGImageElement.h"
26926: #include "nsLayoutUtils.h"
23313: #include "nsSVGImageElement.h"
    1: #include "nsSVGUtils.h"
    1: #include "gfxContext.h"
30596: #include "gfxMatrix.h"
    1: #include "nsIInterfaceRequestorUtils.h"
51039: #include "gfxPlatform.h"
59474: #include "nsSVGSVGElement.h"
    1: 
    1: class nsSVGImageFrame;
    1: 
    1: class nsSVGImageListener : public nsStubImageDecoderObserver
    1: {
    1: public:
    1:   nsSVGImageListener(nsSVGImageFrame *aFrame);
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   // imgIDecoderObserver (override nsStubImageDecoderObserver)
    1:   NS_IMETHOD OnStopDecode(imgIRequest *aRequest, nsresult status,
    1:                           const PRUnichar *statusArg);
    1:   // imgIContainerObserver (override nsStubImageDecoderObserver)
50544:   NS_IMETHOD FrameChanged(imgIContainer *aContainer,
50544:                           const nsIntRect *aDirtyRect);
    1:   // imgIContainerObserver (override nsStubImageDecoderObserver)
    1:   NS_IMETHOD OnStartContainer(imgIRequest *aRequest,
    1:                               imgIContainer *aContainer);
    1: 
    1:   void SetFrame(nsSVGImageFrame *frame) { mFrame = frame; }
    1: 
    1: private:
    1:   nsSVGImageFrame *mFrame;
    1: };
    1: 
    1: 
    1: class nsSVGImageFrame : public nsSVGPathGeometryFrame
    1: {
    1:   friend nsIFrame*
23953:   NS_NewSVGImageFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
 3440: protected:
 3440:   nsSVGImageFrame(nsStyleContext* aContext) : nsSVGPathGeometryFrame(aContext) {}
    1:   virtual ~nsSVGImageFrame();
    1: 
    1: public:
32423:   NS_DECL_FRAMEARENA_HELPERS
32423: 
    1:   // nsISVGChildFrame interface:
20652:   NS_IMETHOD PaintSVG(nsSVGRenderState *aContext, const nsIntRect *aDirtyRect);
18367:   NS_IMETHOD_(nsIFrame*) GetFrameForPoint(const nsPoint &aPoint);
    1: 
    1:   // nsSVGPathGeometryFrame methods:
32103:   NS_IMETHOD UpdateCoveredRegion();
    1:   virtual PRUint16 GetHittestMask();
    1: 
    1:   // nsIFrame interface:
    1:   NS_IMETHOD  AttributeChanged(PRInt32         aNameSpaceID,
    1:                                nsIAtom*        aAttribute,
    1:                                PRInt32         aModType);
 5468:   NS_IMETHOD Init(nsIContent*      aContent,
 5468:                   nsIFrame*        aParent,
 5468:                   nsIFrame*        aPrevInFlow);
    1: 
    1:   /**
    1:    * Get the "type" of the frame
    1:    *
    1:    * @see nsGkAtoms::svgImageFrame
    1:    */
    1:   virtual nsIAtom* GetType() const;
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const
    1:   {
    1:     return MakeFrameName(NS_LITERAL_STRING("SVGImage"), aResult);
    1:   }
    1: #endif
    1: 
    1: private:
59473:   gfxMatrix GetRasterImageTransform(PRInt32 aNativeWidth,
59473:                                     PRInt32 aNativeHeight);
59473:   gfxMatrix GetVectorImageTransform();
59473:   PRBool    TransformContextForPainting(gfxContext* aGfxContext);
    1: 
    1:   nsCOMPtr<imgIDecoderObserver> mListener;
    1: 
    1:   nsCOMPtr<imgIContainer> mImageContainer;
    1: 
    1:   friend class nsSVGImageListener;
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: // Implementation
    1: 
    1: nsIFrame*
23953: NS_NewSVGImageFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsSVGImageFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsSVGImageFrame)
32423: 
    1: nsSVGImageFrame::~nsSVGImageFrame()
    1: {
    1:   // set the frame to null so we don't send messages to a dead object.
    1:   if (mListener) {
    1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:     if (imageLoader) {
61720:       // Push a null JSContext on the stack so that code that runs
61720:       // within the below code doesn't think it's being called by
61720:       // JS. See bug 604262.
61720:       nsCxPusher pusher;
61720:       pusher.PushNull();
61720: 
    1:       imageLoader->RemoveObserver(mListener);
    1:     }
 3233:     reinterpret_cast<nsSVGImageListener*>(mListener.get())->SetFrame(nsnull);
    1:   }
    1:   mListener = nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
 5468: nsSVGImageFrame::Init(nsIContent* aContent,
 5468:                       nsIFrame* aParent,
 5468:                       nsIFrame* aPrevInFlow)
    1: {
23953: #ifdef DEBUG
23953:   nsCOMPtr<nsIDOMSVGImageElement> image = do_QueryInterface(aContent);
23953:   NS_ASSERTION(image, "Content is not an SVG image!");
23953: #endif
23953: 
 5468:   nsresult rv = nsSVGPathGeometryFrame::Init(aContent, aParent, aPrevInFlow);
    1:   if (NS_FAILED(rv)) return rv;
    1:   
    1:   mListener = new nsSVGImageListener(this);
    1:   if (!mListener) return NS_ERROR_OUT_OF_MEMORY;
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:   NS_ENSURE_TRUE(imageLoader, NS_ERROR_UNEXPECTED);
61720: 
61720:   // Push a null JSContext on the stack so that code that runs within
61720:   // the below code doesn't think it's being called by JS. See bug
61720:   // 604262.
61720:   nsCxPusher pusher;
61720:   pusher.PushNull();
61720: 
    1:   imageLoader->AddObserver(mListener);
    1: 
    1:   return NS_OK; 
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIFrame methods:
    1: 
    1: NS_IMETHODIMP
    1: nsSVGImageFrame::AttributeChanged(PRInt32         aNameSpaceID,
    1:                                   nsIAtom*        aAttribute,
    1:                                   PRInt32         aModType)
    1: {
    1:    if (aNameSpaceID == kNameSpaceID_None &&
    1:        (aAttribute == nsGkAtoms::x ||
    1:         aAttribute == nsGkAtoms::y ||
    1:         aAttribute == nsGkAtoms::width ||
    1:         aAttribute == nsGkAtoms::height ||
    1:         aAttribute == nsGkAtoms::preserveAspectRatio)) {
14042:      nsSVGUtils::UpdateGraphic(this);
    1:      return NS_OK;
    1:    }
    1: 
    1:    return nsSVGPathGeometryFrame::AttributeChanged(aNameSpaceID,
    1:                                                    aAttribute, aModType);
    1: }
    1: 
30596: gfxMatrix
59473: nsSVGImageFrame::GetRasterImageTransform(PRInt32 aNativeWidth, PRInt32 aNativeHeight)
    1: {
    1:   float x, y, width, height;
23313:   nsSVGImageElement *element = static_cast<nsSVGImageElement*>(mContent);
    1:   element->GetAnimatedLengthValues(&x, &y, &width, &height, nsnull);
    1: 
30596:   gfxMatrix viewBoxTM =
37974:     nsSVGUtils::GetViewBoxTransform(element,
37974:                                     width, height,
57013:                                     0, 0, aNativeWidth, aNativeHeight,
23313:                                     element->mPreserveAspectRatio);
    1: 
30596:   return viewBoxTM * gfxMatrix().Translate(gfxPoint(x, y)) * GetCanvasTM();
    1: }
    1: 
59473: gfxMatrix
59473: nsSVGImageFrame::GetVectorImageTransform()
59473: {
59473:   float x, y, width, height;
59473:   nsSVGImageElement *element = static_cast<nsSVGImageElement*>(mContent);
59473:   element->GetAnimatedLengthValues(&x, &y, &width, &height, nsnull);
59473: 
59473:   // No viewBoxTM needed here -- our height/width overrides any concept of
59473:   // "native size" that the SVG image has, and it will handle viewBox and
59473:   // preserveAspectRatio on its own once we give it a region to draw into.
59473: 
59473:   return gfxMatrix().Translate(gfxPoint(x, y)) * GetCanvasTM();
59473: }
59473: 
59473: PRBool
59473: nsSVGImageFrame::TransformContextForPainting(gfxContext* aGfxContext)
59473: {
59473:   gfxMatrix imageTransform;
59473:   if (mImageContainer->GetType() == imgIContainer::TYPE_VECTOR) {
59473:     imageTransform = GetVectorImageTransform();
59473:   } else {
59473:     PRInt32 nativeWidth, nativeHeight;
59473:     if (NS_FAILED(mImageContainer->GetWidth(&nativeWidth)) ||
59473:         NS_FAILED(mImageContainer->GetHeight(&nativeHeight)) ||
59473:         nativeWidth == 0 || nativeHeight == 0) {
59473:       return PR_FALSE;
59473:     }
59473:     imageTransform = GetRasterImageTransform(nativeWidth, nativeHeight);
59473:   }
59473: 
60272:   if (imageTransform.IsSingular()) {
60272:     return PR_FALSE;
60272:   }
60272: 
59473:   // NOTE: We need to cancel out the effects of Full-Page-Zoom, or else
59473:   // it'll get applied an extra time by DrawSingleUnscaledImage.
59473:   nscoord appUnitsPerDevPx = PresContext()->AppUnitsPerDevPixel();
59473:   gfxFloat pageZoomFactor =
59473:     nsPresContext::AppUnitsToFloatCSSPixels(appUnitsPerDevPx);
59473:   aGfxContext->Multiply(imageTransform.Scale(pageZoomFactor, pageZoomFactor));
59473: 
59473:   return PR_TRUE;
59473: }
59473: 
    1: //----------------------------------------------------------------------
    1: // nsISVGChildFrame methods:
    1: NS_IMETHODIMP
20652: nsSVGImageFrame::PaintSVG(nsSVGRenderState *aContext,
20652:                           const nsIntRect *aDirtyRect)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!GetStyleVisibility()->IsVisible())
    1:     return NS_OK;
    1: 
 3393:   float x, y, width, height;
59474:   nsSVGImageElement *imgElem = static_cast<nsSVGImageElement*>(mContent);
59474:   imgElem->GetAnimatedLengthValues(&x, &y, &width, &height, nsnull);
 3393:   if (width <= 0 || height <= 0)
 3393:     return NS_OK;
 3393: 
    1:   if (!mImageContainer) {
    1:     nsCOMPtr<imgIRequest> currentRequest;
    1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:     if (imageLoader)
    1:       imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                               getter_AddRefs(currentRequest));
    1: 
    1:     if (currentRequest)
    1:       currentRequest->GetImage(getter_AddRefs(mImageContainer));
    1:   }
    1: 
55323:   if (mImageContainer) {
55323:     gfxContext* ctx = aContext->GetGfxContext();
55323:     gfxContextAutoSaveRestore autoRestorer(ctx);
    1: 
  927:     if (GetStyleDisplay()->IsScrollableOverflow()) {
55323:       gfxRect clipRect = nsSVGUtils::GetClipRectForFrame(this, x, y,
55323:                                                          width, height);
55323:       nsSVGUtils::SetClipRect(ctx, GetCanvasTM(), clipRect);
55323:     }
  927: 
59473:     if (!TransformContextForPainting(ctx)) {
59473:       return NS_ERROR_FAILURE;
59473:     }
  927: 
    1:     // fill-opacity doesn't affect <image>, so if we're allowed to
    1:     // optimize group opacity, the opacity used for compositing the
    1:     // image into the current canvas is just the group opacity.
    1:     float opacity = 1.0f;
    1:     if (nsSVGUtils::CanOptimizeOpacity(this)) {
    1:       opacity = GetStyleDisplay()->mOpacity;
    1:     }
    1: 
55323:     if (opacity != 1.0f) {
55323:       ctx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
55323:     }
12949: 
59473:     nscoord appUnitsPerDevPx = PresContext()->AppUnitsPerDevPixel();
55323:     nsRect dirtyRect; // only used if aDirtyRect is non-null
55323:     if (aDirtyRect) {
56384:       dirtyRect = aDirtyRect->ToAppUnits(appUnitsPerDevPx);
56362:       // Adjust dirtyRect to match our local coordinate system.
56362:       dirtyRect.MoveBy(-mRect.TopLeft());
55323:     }
    1: 
55323:     // XXXbholley - I don't think huge images in SVGs are common enough to
55323:     // warrant worrying about the responsiveness impact of doing synchronous
55323:     // decodes. The extra code complexity of determinining when we want to
55323:     // force sync probably just isn't worth it, so always pass FLAG_SYNC_DECODE
59473:     PRUint32 drawFlags = imgIContainer::FLAG_SYNC_DECODE;
59473: 
59473:     if (mImageContainer->GetType() == imgIContainer::TYPE_VECTOR) {
59474:       nsIFrame* imgRootFrame = mImageContainer->GetRootLayoutFrame();
59474:       if (!imgRootFrame) {
59474:         // bad image (e.g. XML parse error in image's SVG file)
59474:         return NS_OK;
59474:       }
59474: 
59474:       // Grab root node (w/ sanity-check to make sure it exists & is <svg>)
59474:       nsSVGSVGElement* rootSVGElem =
59474:         static_cast<nsSVGSVGElement*>(imgRootFrame->GetContent());
59474:       if (!rootSVGElem || rootSVGElem->GetNameSpaceID() != kNameSpaceID_SVG ||
59474:           rootSVGElem->Tag() != nsGkAtoms::svg) {
59474:         NS_ABORT_IF_FALSE(PR_FALSE, "missing or non-<svg> root node!!");
59474:         return PR_FALSE;
59474:       }
59474: 
59474:       // Override preserveAspectRatio in our helper document
59474:       // XXXdholbert We should technically be overriding the helper doc's clip
59474:       // and overflow properties here, too. See bug 272288 comment 36.
59474:       rootSVGElem->SetImageOverridePreserveAspectRatio(
59474:         imgElem->mPreserveAspectRatio.GetAnimValue());
59473:       nsRect destRect(0, 0,
59473:                       appUnitsPerDevPx * width,
59473:                       appUnitsPerDevPx * height);
59473: 
59473:       // Note: Can't use DrawSingleUnscaledImage for the TYPE_VECTOR case.
59473:       // That method needs our image to have a fixed native width & height,
59473:       // and that's not always true for TYPE_VECTOR images.
59473:       nsLayoutUtils::DrawSingleImage(
59473:         aContext->GetRenderingContext(this),
59473:         mImageContainer,
59473:         nsLayoutUtils::GetGraphicsFilterForFrame(this),
59473:         destRect,
59473:         aDirtyRect ? dirtyRect : destRect,
59473:         drawFlags);
59474: 
59474:       rootSVGElem->ClearImageOverridePreserveAspectRatio();
59473:     } else { // mImageContainer->GetType() == TYPE_RASTER
55323:       nsLayoutUtils::DrawSingleUnscaledImage(
55323:         aContext->GetRenderingContext(this),
55323:         mImageContainer,
55323:         nsLayoutUtils::GetGraphicsFilterForFrame(this),
55323:         nsPoint(0, 0),
55323:         aDirtyRect ? &dirtyRect : nsnull,
59473:         drawFlags);
59473:     }
55323: 
55323:     if (opacity != 1.0f) {
55323:       ctx->PopGroupToSource();
55323:       ctx->SetOperator(gfxContext::OPERATOR_OVER);
55323:       ctx->Paint(opacity);
55323:     }
55323:     // gfxContextAutoSaveRestore goes out of scope & cleans up our gfxContext
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
18367: NS_IMETHODIMP_(nsIFrame*)
18367: nsSVGImageFrame::GetFrameForPoint(const nsPoint &aPoint)
    1: {
59473:   // Special case for raster images -- we only want to accept points that fall
59473:   // in the underlying image's (transformed) native bounds.  That region
59473:   // doesn't necessarily map to our <image> element's [x,y,width,height].  So,
59473:   // we have to look up the native image size & our image transform in order
59473:   // to filter out points that fall outside that area.
    1:   if (GetStyleDisplay()->IsScrollableOverflow() && mImageContainer) {
59473:     if (mImageContainer->GetType() == imgIContainer::TYPE_RASTER) {
    1:       PRInt32 nativeWidth, nativeHeight;
59473:       if (NS_FAILED(mImageContainer->GetWidth(&nativeWidth)) ||
59473:           NS_FAILED(mImageContainer->GetHeight(&nativeHeight)) ||
59473:           nativeWidth == 0 || nativeHeight == 0) {
57013:         return nsnull;
57013:       }
57013: 
59473:       if (!nsSVGUtils::HitTestRect(
59473:                GetRasterImageTransform(nativeWidth, nativeHeight),
    1:                0, 0, nativeWidth, nativeHeight,
18367:                PresContext()->AppUnitsToDevPixels(aPoint.x),
18367:                PresContext()->AppUnitsToDevPixels(aPoint.y))) {
18367:         return nsnull;
    1:       }
    1:     }
59473:     // The special case above doesn't apply to vector images, because they
59473:     // don't limit their drawing to explicit "native bounds" -- they have
59473:     // an infinite canvas on which to place content.  So it's reasonable to
59473:     // just fall back on our <image> element's own bounds here.
59473:   }
    1: 
18367:   return nsSVGPathGeometryFrame::GetFrameForPoint(aPoint);
    1: }
    1: 
    1: nsIAtom *
    1: nsSVGImageFrame::GetType() const
    1: {
    1:   return nsGkAtoms::svgImageFrame;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsSVGPathGeometryFrame methods:
    1: 
32103: // Lie about our fill/stroke so that covered region and hit detection work properly
32103: 
32103: NS_IMETHODIMP
32103: nsSVGImageFrame::UpdateCoveredRegion()
32103: {
32103:   mRect.Empty();
32103: 
51039:   gfxContext context(gfxPlatform::GetPlatform()->ScreenReferenceSurface());
32103: 
32103:   GeneratePath(&context);
32103:   context.IdentityMatrix();
32103: 
32103:   gfxRect extent = context.GetUserPathExtent();
32103: 
32103:   if (!extent.IsEmpty()) {
32103:     mRect = nsSVGUtils::ToAppPixelRect(PresContext(), extent);
32103:   }
32103: 
32103:   return NS_OK;
32103: }
    1: 
    1: PRUint16
    1: nsSVGImageFrame::GetHittestMask()
    1: {
    1:   PRUint16 mask = 0;
    1: 
32021:   switch(GetStyleVisibility()->mPointerEvents) {
    1:     case NS_STYLE_POINTER_EVENTS_NONE:
    1:       break;
    1:     case NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED:
32021:     case NS_STYLE_POINTER_EVENTS_AUTO:
    1:       if (GetStyleVisibility()->IsVisible()) {
    1:         /* XXX: should check pixel transparency */
    1:         mask |= HITTEST_MASK_FILL;
    1:       }
    1:       break;
    1:     case NS_STYLE_POINTER_EVENTS_VISIBLEFILL:
    1:     case NS_STYLE_POINTER_EVENTS_VISIBLESTROKE:
    1:     case NS_STYLE_POINTER_EVENTS_VISIBLE:
    1:       if (GetStyleVisibility()->IsVisible()) {
    1:         mask |= HITTEST_MASK_FILL;
    1:       }
    1:       break;
    1:     case NS_STYLE_POINTER_EVENTS_PAINTED:
    1:       /* XXX: should check pixel transparency */
    1:       mask |= HITTEST_MASK_FILL;
    1:       break;
    1:     case NS_STYLE_POINTER_EVENTS_FILL:
    1:     case NS_STYLE_POINTER_EVENTS_STROKE:
    1:     case NS_STYLE_POINTER_EVENTS_ALL:
    1:       mask |= HITTEST_MASK_FILL;
    1:       break;
    1:     default:
    1:       NS_ERROR("not reached");
    1:       break;
    1:   }
    1: 
    1:   return mask;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsSVGImageListener implementation
    1: 
    1: NS_IMPL_ISUPPORTS2(nsSVGImageListener,
    1:                    imgIDecoderObserver,
    1:                    imgIContainerObserver)
    1: 
    1: nsSVGImageListener::nsSVGImageListener(nsSVGImageFrame *aFrame) :  mFrame(aFrame)
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP nsSVGImageListener::OnStopDecode(imgIRequest *aRequest,
    1:                                                nsresult status,
    1:                                                const PRUnichar *statusArg)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
14042:   nsSVGUtils::UpdateGraphic(mFrame);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSVGImageListener::FrameChanged(imgIContainer *aContainer,
50544:                                                const nsIntRect *aDirtyRect)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
14042:   nsSVGUtils::UpdateGraphic(mFrame);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSVGImageListener::OnStartContainer(imgIRequest *aRequest,
    1:                                                    imgIContainer *aContainer)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mFrame->mImageContainer = aContainer;
14042:   nsSVGUtils::UpdateGraphic(mFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
