35795: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
19246: /* ***** BEGIN LICENSE BLOCK *****
19246:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19246:  *
19246:  * The contents of this file are subject to the Mozilla Public License Version
19246:  * 1.1 (the "License"); you may not use this file except in compliance with
19246:  * the License. You may obtain a copy of the License at
19246:  * http://www.mozilla.org/MPL/
19246:  *
19246:  * Software distributed under the License is distributed on an "AS IS" basis,
19246:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19246:  * for the specific language governing rights and limitations under the
19246:  * License.
19246:  *
19246:  * The Original Code is mozilla.org code.
19246:  *
19246:  * The Initial Developer of the Original Code is
19246:  * Netscape Communications Corporation.
19246:  * Portions created by the Initial Developer are Copyright (C) 1998
19246:  * the Initial Developer. All Rights Reserved.
19246:  *
19246:  * Contributor(s):
19246:  *   Tim Copperfield <timecop@network.email.ne.jp>
19246:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
19246:  *
19246:  * Alternatively, the contents of this file may be used under the terms of
19246:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19246:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19246:  * in which case the provisions of the GPL or the LGPL are applicable instead
19246:  * of those above. If you wish to allow use of your version of this file only
19246:  * under the terms of either the GPL or the LGPL, and not to allow others to
19246:  * use your version of this file under the terms of the MPL, indicate your
19246:  * decision by deleting the provisions above and replace them with the notice
19246:  * and other provisions required by the GPL or the LGPL. If you do not delete
19246:  * the provisions above, a recipient may use your version of this file under
19246:  * the terms of any one of the MPL, the GPL or the LGPL.
19246:  *
19246:  * ***** END LICENSE BLOCK ***** */
19246: 
19246: #ifndef nsNPAPIPluginInstance_h_
19246: #define nsNPAPIPluginInstance_h_
19246: 
19246: #include "nsCOMPtr.h"
26912: #include "nsTArray.h"
47353: #include "nsPIDOMWindow.h"
47353: #include "nsITimer.h"
29952: #include "nsIPluginTagInfo.h"
47965: #include "nsIURI.h"
60021: #include "nsIChannel.h"
60021: #include "nsInterfaceHashtable.h"
60021: #include "nsHashKeys.h"
47353: 
36355: #include "mozilla/TimeStamp.h"
36010: #include "mozilla/PluginLibrary.h"
19246: 
70007: struct JSObject;
70007: 
47865: class nsPluginStreamListenerPeer; // browser-initiated stream class
47865: class nsNPAPIPluginStreamListener; // plugin-initiated stream class
47353: class nsIPluginInstanceOwner;
70007: class nsIPluginStreamListener;
70007: class nsIOutputStream;
19246: 
29937: class nsNPAPITimer
29937: {
29937: public:
29937:   NPP npp;
29937:   uint32_t id;
29937:   nsCOMPtr<nsITimer> timer;
29937:   void (*callback)(NPP npp, uint32_t timerID);
78424:   PRBool inCallback;
29937: };
29937: 
70007: class nsNPAPIPluginInstance : public nsISupports
19246: {
36010: private:
36010:   typedef mozilla::PluginLibrary PluginLibrary;
36010: 
19246: public:
19246:   NS_DECL_ISUPPORTS
70007: 
70007:   nsresult Initialize(nsIPluginInstanceOwner* aOwner, const char* aMIMEType);
70007:   nsresult Start();
70007:   nsresult Stop();
70007:   nsresult SetWindow(NPWindow* window);
70007:   nsresult NewStreamToPlugin(nsIPluginStreamListener** listener);
70007:   nsresult NewStreamFromPlugin(const char* type, const char* target, nsIOutputStream* *result);
70007:   nsresult Print(NPPrint* platformPrint);
78424: #ifdef ANDROID
78424:   nsresult PostEvent(void* event) { return 0; };
78424: #endif
70007:   nsresult HandleEvent(void* event, PRInt16* result);
70007:   nsresult GetValueFromPlugin(NPPVariable variable, void* value);
70007:   nsresult GetDrawingModel(PRInt32* aModel);
70007:   nsresult IsRemoteDrawingCoreAnimation(PRBool* aDrawing);
70007:   nsresult GetJSObject(JSContext *cx, JSObject** outObject);
70007:   nsresult DefineJavaProperties();
79195:   PRBool ShouldCache();
70007:   nsresult IsWindowless(PRBool* isWindowless);
70007:   nsresult AsyncSetWindow(NPWindow* window);
70007:   nsresult GetImage(ImageContainer* aContainer, Image** aImage);
70007:   nsresult GetImageSize(nsIntSize* aSize);
70007:   nsresult NotifyPainted(void);
70007:   nsresult UseAsyncPainting(PRBool* aIsAsync);
70007:   nsresult SetBackgroundUnknown();
70007:   nsresult BeginUpdateBackground(nsIntRect* aRect, gfxContext** aContext);
70007:   nsresult EndUpdateBackground(gfxContext* aContext, nsIntRect* aRect);
70007:   nsresult IsTransparent(PRBool* isTransparent);
70007:   nsresult GetFormValue(nsAString& aValue);
70007:   nsresult PushPopupsEnabledState(PRBool aEnabled);
70007:   nsresult PopPopupsEnabledState();
70007:   nsresult GetPluginAPIVersion(PRUint16* version);
70007:   nsresult InvalidateRect(NPRect *invalidRect);
70007:   nsresult InvalidateRegion(NPRegion invalidRegion);
70007:   nsresult ForceRedraw();
70007:   nsresult GetMIMEType(const char* *result);
70007:   nsresult GetJSContext(JSContext* *outContext);
70007:   nsresult GetOwner(nsIPluginInstanceOwner **aOwner);
70007:   nsresult SetOwner(nsIPluginInstanceOwner *aOwner);
70007:   nsresult ShowStatus(const char* message);
70007:   nsresult InvalidateOwner();
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
77498:   nsresult HandleGUIEvent(const nsGUIEvent& anEvent, bool* handled);
77498: #endif
19246: 
47965:   nsNPAPIPlugin* GetPlugin();
47965: 
19246:   nsresult GetNPP(NPP * aNPP);
19246: 
47965:   void SetURI(nsIURI* uri);
47965:   nsIURI* GetURI();
19246: 
19246:   NPError SetWindowless(PRBool aWindowless);
19246: 
34217:   NPError SetWindowlessLocal(PRBool aWindowlessLocal);
34217: 
19246:   NPError SetTransparent(PRBool aTransparent);
19246: 
19246:   NPError SetWantsAllNetworkStreams(PRBool aWantsAllNetworkStreams);
19246: 
67677:   NPError SetUsesDOMForCursor(PRBool aUsesDOMForCursor);
67677:   PRBool UsesDOMForCursor();
67677: 
19246: #ifdef XP_MACOSX
19246:   void SetDrawingModel(NPDrawingModel aModel);
32019:   void SetEventModel(NPEventModel aModel);
19246: #endif
19246: 
78424: #ifdef ANDROID
78424:   void SetDrawingModel(PRUint32 aModel);
78424:   void* GetJavaSurface();
78424: #endif
78424: 
60021:   nsresult NewStreamListener(const char* aURL, void* notifyData,
60021:                              nsIPluginStreamListener** listener);
19246: 
47965:   nsNPAPIPluginInstance(nsNPAPIPlugin* plugin);
47965:   virtual ~nsNPAPIPluginInstance();
19246: 
47965:   // To be called when an instance becomes orphaned, when
47965:   // it's plugin is no longer guaranteed to be around.
47965:   void Destroy();
19246: 
39211:   // Indicates whether the plugin is running normally.
39211:   bool IsRunning() {
39211:     return RUNNING == mRunning;
39211:   }
59756:   bool HasStartedDestroying() {
59756:     return mRunning >= DESTROYING;
59756:   }
39211: 
39211:   // Indicates whether the plugin is running normally or being shut down
39211:   bool CanFireNotifications() {
39211:     return mRunning == RUNNING || mRunning == DESTROYING;
39211:   }
36355: 
79195:   // return is only valid when the plugin is not running
79195:   mozilla::TimeStamp StopTime();
79195: 
79195:   // cache this NPAPI plugin
79195:   nsresult SetCached(PRBool aCache);
79195: 
19246:   already_AddRefed<nsPIDOMWindow> GetDOMWindow();
19246: 
24475:   nsresult PrivateModeStateChanged();
29834: 
29834:   nsresult GetDOMElement(nsIDOMElement* *result);
29834: 
29937:   nsNPAPITimer* TimerWithID(uint32_t id, PRUint32* index);
29937:   uint32_t      ScheduleTimer(uint32_t interval, NPBool repeat, void (*timerFunc)(NPP npp, uint32_t timerID));
29937:   void          UnscheduleTimer(uint32_t timerID);
32019:   NPError       PopUpContextMenu(NPMenu* menu);
32019:   NPBool        ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace, double *destX, double *destY, NPCoordinateSpace destSpace);
47865: 
60021: 
60021:   nsTArray<nsNPAPIPluginStreamListener*> *StreamListeners();
60021: 
60021:   nsTArray<nsPluginStreamListenerPeer*> *FileCachedStreamListeners();
47865: 
52409:   nsresult AsyncSetWindow(NPWindow& window);
52409: 
60021:   void URLRedirectResponse(void* notifyData, NPBool allow);
60021: 
61864:   // Called when the instance fails to instantiate beceause the Carbon
61864:   // event model is not supported.
61864:   void CarbonNPAPIFailure();
61864: 
36173: protected:
29834:   nsresult InitializePlugin();
19246: 
29834:   nsresult GetTagType(nsPluginTagType *result);
29834:   nsresult GetAttributes(PRUint16& n, const char*const*& names,
29834:                          const char*const*& values);
29834:   nsresult GetParameters(PRUint16& n, const char*const*& names,
29834:                          const char*const*& values);
32799:   nsresult GetMode(PRInt32 *result);
19246: 
26260:   // The structure used to communicate between the plugin instance and
26260:   // the browser.
30212:   NPP_t mNPP;
19246: 
19246: #ifdef XP_MACOSX
19246:   NPDrawingModel mDrawingModel;
19246: #endif
19246: 
78424: #ifdef ANDROID
78424:   PRUint32 mDrawingModel;
78424: #endif
78424: 
39211:   enum {
39211:     NOT_STARTED,
39211:     RUNNING,
39211:     DESTROYING,
39211:     DESTROYED
39211:   } mRunning;
39211: 
19246:   // these are used to store the windowless properties
19246:   // which the browser will later query
19246:   PRPackedBool mWindowless;
34217:   PRPackedBool mWindowlessLocal;
19246:   PRPackedBool mTransparent;
79195:   PRPackedBool mCached;
67677:   PRPackedBool mUsesDOMForCursor;
19246: 
36173: public:
19246:   // True while creating the plugin, or calling NPP_SetWindow() on it.
19246:   PRPackedBool mInPluginInitCall;
19246: 
57925:   nsXPIDLCString mFakeURL;
57925: 
36173: private:
47965:   nsNPAPIPlugin* mPlugin;
47965: 
60021:   nsTArray<nsNPAPIPluginStreamListener*> mStreamListeners;
47865: 
60021:   nsTArray<nsPluginStreamListenerPeer*> mFileCachedStreamListeners;
47865: 
26912:   nsTArray<PopupControlState> mPopupStates;
29808: 
30101:   char* mMIMEType;
29834: 
29834:   // Weak pointer to the owner. The owner nulls this out (by calling
29834:   // InvalidateOwner()) when it's no longer our owner.
29834:   nsIPluginInstanceOwner *mOwner;
29937: 
29937:   nsTArray<nsNPAPITimer*> mTimers;
32019: 
32019:   // non-null during a HandleEvent call
32799:   void* mCurrentPluginEvent;
36355: 
79195:   // Timestamp for the last time this plugin was stopped.
79195:   // This is only valid when the plugin is actually stopped!
79195:   mozilla::TimeStamp mStopTime;
79195: 
47965:   nsCOMPtr<nsIURI> mURI;
54899: 
54899:   PRPackedBool mUsePluginLayersPref;
78424: #ifdef ANDROID
78424:   void* mSurface;
78424: #endif
19246: };
19246: 
19246: #endif // nsNPAPIPluginInstance_h_
