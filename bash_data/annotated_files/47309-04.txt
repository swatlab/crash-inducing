 9699: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 9699:  * ***** BEGIN LICENSE BLOCK *****
 9699:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 9699:  *
 9699:  * The contents of this file are subject to the Mozilla Public License Version
 9699:  * 1.1 (the "License"); you may not use this file except in compliance with
 9699:  * the License. You may obtain a copy of the License at
 9699:  * http://www.mozilla.org/MPL/
 9699:  *
 9699:  * Software distributed under the License is distributed on an "AS IS" basis,
 9699:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 9699:  * for the specific language governing rights and limitations under the
 9699:  * License.
 9699:  *
 9699:  * The Original Code is Mozilla Foundation code.
 9699:  *
 9699:  * The Initial Developer of the Original Code is Mozilla Foundation.
31590:  * Portions created by the Initial Developer are Copyright (C) 2005-2009
 9699:  * the Initial Developer. All Rights Reserved.
 9699:  *
 9699:  * Contributor(s):
 9699:  *   Stuart Parmenter <stuart@mozilla.com>
 9699:  *   John Daggett <jdaggett@mozilla.com>
31590:  *   Jonathan Kew <jfkthame@gmail.com>
 9699:  *
 9699:  * Alternatively, the contents of this file may be used under the terms of
 9699:  * either the GNU General Public License Version 2 or later (the "GPL"), or
 9699:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 9699:  * in which case the provisions of the GPL or the LGPL are applicable instead
 9699:  * of those above. If you wish to allow use of your version of this file only
 9699:  * under the terms of either the GPL or the LGPL, and not to allow others to
 9699:  * use your version of this file under the terms of the MPL, indicate your
 9699:  * decision by deleting the provisions above and replace them with the notice
 9699:  * and other provisions required by the GPL or the LGPL. If you do not delete
 9699:  * the provisions above, a recipient may use your version of this file under
 9699:  * the terms of any one of the MPL, the GPL or the LGPL.
 9699:  *
 9699:  * ***** END LICENSE BLOCK ***** */
 9699: 
 9699: #ifndef GFX_FONT_UTILS_H
 9699: #define GFX_FONT_UTILS_H
 9699: 
 9699: #include "gfxTypes.h"
 9699: 
 9699: #include "prtypes.h"
 9699: #include "prcpucfg.h"
 9699: 
 9699: #include "nsDataHashtable.h"
 9699: 
13877: #include "nsITimer.h"
13877: #include "nsCOMPtr.h"
13877: #include "nsIRunnable.h"
13877: #include "nsThreadUtils.h"
16418: #include "nsComponentManagerUtils.h"
16418: #include "nsTArray.h"
16418: #include "nsAutoPtr.h"
31590: #include "nsIStreamBufferAccess.h"
13877: 
 9699: /* Bug 341128 - w32api defines min/max which causes problems with <bitset> */
 9699: #ifdef __MINGW32__
 9699: #undef min
 9699: #undef max
 9699: #endif
 9699: 
 9699: class gfxSparseBitSet {
 9699: private:
11580:     enum { BLOCK_SIZE = 32 };   // ==> 256 codepoints per block
 9699:     enum { BLOCK_SIZE_BITS = BLOCK_SIZE * 8 };
11580:     enum { BLOCK_INDEX_SHIFT = 8 };
 9699: 
 9699:     struct Block {
13360:         Block(const Block& aBlock) { memcpy(mBits, aBlock.mBits, sizeof(mBits)); }
 9699:         Block(unsigned char memsetValue = 0) { memset(mBits, memsetValue, BLOCK_SIZE); }
 9699:         PRUint8 mBits[BLOCK_SIZE];
 9699:     };
 9699: 
 9699: public:
13360:     gfxSparseBitSet() { }
13360:     gfxSparseBitSet(const gfxSparseBitSet& aBitset) {
13360:         PRUint32 len = aBitset.mBlocks.Length();
13360:         mBlocks.AppendElements(len);
13360:         for (PRUint32 i = 0; i < len; ++i) {
13360:             Block *block = aBitset.mBlocks[i];
13360:             if (block)
13360:                 mBlocks[i] = new Block(*block);
13360:         }
13360:     }
37209:     PRBool test(PRUint32 aIndex) const {
24104:         NS_ASSERTION(mBlocks.DebugGetHeader(), "mHdr is null, this is bad");
 9699:         PRUint32 blockIndex = aIndex/BLOCK_SIZE_BITS;
 9699:         if (blockIndex >= mBlocks.Length())
 9699:             return PR_FALSE;
 9699:         Block *block = mBlocks[blockIndex];
 9699:         if (!block)
 9699:             return PR_FALSE;
11580:         return ((block->mBits[(aIndex>>3) & (BLOCK_SIZE - 1)]) & (1 << (aIndex & 0x7))) != 0;
11580:     }
11580: 
11580:     PRBool TestRange(PRUint32 aStart, PRUint32 aEnd) {
11580:         PRUint32 startBlock, endBlock, blockLen;
11580:         
11580:         // start point is beyond the end of the block array? return false immediately
11580:         startBlock = aStart >> BLOCK_INDEX_SHIFT;
11580:         blockLen = mBlocks.Length();
11580:         if (startBlock >= blockLen) return PR_FALSE;
11580:         
11580:         // check for blocks in range, if none, return false
11580:         PRUint32 blockIndex;
11580:         PRBool hasBlocksInRange = PR_FALSE;
11580: 
11580:         endBlock = aEnd >> BLOCK_INDEX_SHIFT;
11580:         blockIndex = startBlock;
11580:         for (blockIndex = startBlock; blockIndex <= endBlock; blockIndex++) {
11580:             if (blockIndex < blockLen && mBlocks[blockIndex])
11580:                 hasBlocksInRange = PR_TRUE;
11580:         }
11580:         if (!hasBlocksInRange) return PR_FALSE;
11580: 
11580:         Block *block;
11580:         PRUint32 i, start, end;
11580:         
11580:         // first block, check bits
11580:         if ((block = mBlocks[startBlock])) {
11580:             start = aStart;
11580:             end = PR_MIN(aEnd, ((startBlock+1) << BLOCK_INDEX_SHIFT) - 1);
11580:             for (i = start; i <= end; i++) {
11580:                 if ((block->mBits[(i>>3) & (BLOCK_SIZE - 1)]) & (1 << (i & 0x7)))
11580:                     return PR_TRUE;
11580:             }
11580:         }
11580:         if (endBlock == startBlock) return PR_FALSE;
11580: 
11580:         // [2..n-1] blocks check bytes
11580:         for (blockIndex = startBlock + 1; blockIndex < endBlock; blockIndex++) {
11580:             PRUint32 index;
11580:             
11580:             if (blockIndex >= blockLen || !(block = mBlocks[blockIndex])) continue;
11580:             for (index = 0; index < BLOCK_SIZE; index++) {
11580:                 if (block->mBits[index]) 
11580:                     return PR_TRUE;
11580:             }
11580:         }
11580:         
11580:         // last block, check bits
11580:         if (endBlock < blockLen && (block = mBlocks[endBlock])) {
11580:             start = endBlock << BLOCK_INDEX_SHIFT;
11580:             end = aEnd;
11580:             for (i = start; i <= end; i++) {
11580:                 if ((block->mBits[(i>>3) & (BLOCK_SIZE - 1)]) & (1 << (i & 0x7)))
11580:                     return PR_TRUE;
11580:             }
11580:         }
11580:         
11580:         return PR_FALSE;
 9699:     }
 9699:     
 9699:     void set(PRUint32 aIndex) {
 9699:         PRUint32 blockIndex = aIndex/BLOCK_SIZE_BITS;
 9699:         if (blockIndex >= mBlocks.Length()) {
 9699:             nsAutoPtr<Block> *blocks = mBlocks.AppendElements(blockIndex + 1 - mBlocks.Length());
 9699:             if (NS_UNLIKELY(!blocks)) // OOM
 9699:                 return;
 9699:         }
 9699:         Block *block = mBlocks[blockIndex];
 9699:         if (!block) {
 9699:             block = new Block;
 9699:             if (NS_UNLIKELY(!block)) // OOM
 9699:                 return;
 9699:             mBlocks[blockIndex] = block;
 9699:         }
11580:         block->mBits[(aIndex>>3) & (BLOCK_SIZE - 1)] |= 1 << (aIndex & 0x7);
 9699:     }
 9699: 
37209:     void set(PRUint32 aIndex, PRBool aValue) {
37209:         if (aValue)
37209:             set(aIndex);
37209:         else
37209:             clear(aIndex);
37209:     }
37209: 
 9699:     void SetRange(PRUint32 aStart, PRUint32 aEnd) {
 9699:         const PRUint32 startIndex = aStart/BLOCK_SIZE_BITS;
 9699:         const PRUint32 endIndex = aEnd/BLOCK_SIZE_BITS;
 9699: 
 9699:         if (endIndex >= mBlocks.Length()) {
 9699:             PRUint32 numNewBlocks = endIndex + 1 - mBlocks.Length();
 9699:             nsAutoPtr<Block> *blocks = mBlocks.AppendElements(numNewBlocks);
 9699:             if (NS_UNLIKELY(!blocks)) // OOM
 9699:                 return;
 9699:         }
 9699: 
 9699:         for (PRUint32 i = startIndex; i <= endIndex; ++i) {
 9699:             const PRUint32 blockFirstBit = i * BLOCK_SIZE_BITS;
 9699:             const PRUint32 blockLastBit = blockFirstBit + BLOCK_SIZE_BITS - 1;
 9699: 
 9699:             Block *block = mBlocks[i];
 9699:             if (!block) {
 9699:                 PRBool fullBlock = PR_FALSE;
 9699:                 if (aStart <= blockFirstBit && aEnd >= blockLastBit)
 9699:                     fullBlock = PR_TRUE;
 9699: 
 9699:                 block = new Block(fullBlock ? 0xFF : 0);
 9699: 
 9699:                 if (NS_UNLIKELY(!block)) // OOM
 9699:                     return;
 9699:                 mBlocks[i] = block;
 9699: 
 9699:                 if (fullBlock)
 9699:                     continue;
 9699:             }
 9699: 
 9699:             const PRUint32 start = aStart > blockFirstBit ? aStart - blockFirstBit : 0;
 9699:             const PRUint32 end = PR_MIN(aEnd - blockFirstBit, BLOCK_SIZE_BITS - 1);
 9699: 
 9699:             for (PRUint32 bit = start; bit <= end; ++bit) {
11580:                 block->mBits[bit>>3] |= 1 << (bit & 0x7);
11580:             }
11580:         }
11580:     }
11580: 
11580:     void clear(PRUint32 aIndex) {
11580:         PRUint32 blockIndex = aIndex/BLOCK_SIZE_BITS;
11580:         if (blockIndex >= mBlocks.Length()) {
11580:             nsAutoPtr<Block> *blocks = mBlocks.AppendElements(blockIndex + 1 - mBlocks.Length());
11580:             if (NS_UNLIKELY(!blocks)) // OOM
11580:                 return;
11580:         }
11580:         Block *block = mBlocks[blockIndex];
11580:         if (!block) {
11580:             block = new Block;
11580:             if (NS_UNLIKELY(!block)) // OOM
11580:                 return;
11580:             mBlocks[blockIndex] = block;
11580:         }
11580:         block->mBits[(aIndex>>3) & (BLOCK_SIZE - 1)] &= ~(1 << (aIndex & 0x7));
11580:     }
11580: 
11580:     void ClearRange(PRUint32 aStart, PRUint32 aEnd) {
11580:         const PRUint32 startIndex = aStart/BLOCK_SIZE_BITS;
11580:         const PRUint32 endIndex = aEnd/BLOCK_SIZE_BITS;
11580: 
11580:         if (endIndex >= mBlocks.Length()) {
11580:             PRUint32 numNewBlocks = endIndex + 1 - mBlocks.Length();
11580:             nsAutoPtr<Block> *blocks = mBlocks.AppendElements(numNewBlocks);
11580:             if (NS_UNLIKELY(!blocks)) // OOM
11580:                 return;
11580:         }
11580: 
11580:         for (PRUint32 i = startIndex; i <= endIndex; ++i) {
11580:             const PRUint32 blockFirstBit = i * BLOCK_SIZE_BITS;
11580:             const PRUint32 blockLastBit = blockFirstBit + BLOCK_SIZE_BITS - 1;
11580: 
11580:             Block *block = mBlocks[i];
11580:             if (!block) {
11580:                 PRBool fullBlock = PR_FALSE;
11580:                 if (aStart <= blockFirstBit && aEnd >= blockLastBit)
11580:                     fullBlock = PR_TRUE;
11580: 
11580:                 block = new Block(fullBlock ? 0xFF : 0);
11580: 
11580:                 if (NS_UNLIKELY(!block)) // OOM
11580:                     return;
11580:                 mBlocks[i] = block;
11580: 
11580:                 if (fullBlock)
11580:                     continue;
11580:             }
11580: 
11580:             const PRUint32 start = aStart > blockFirstBit ? aStart - blockFirstBit : 0;
11580:             const PRUint32 end = PR_MIN(aEnd - blockFirstBit, BLOCK_SIZE_BITS - 1);
11580: 
11580:             for (PRUint32 bit = start; bit <= end; ++bit) {
11580:                 block->mBits[bit>>3] &= ~(1 << (bit & 0x7));
 9699:             }
 9699:         }
 9699:     }
 9699: 
 9699:     PRUint32 GetSize() {
 9699:         PRUint32 size = 0;
13877:         for (PRUint32 i = 0; i < mBlocks.Length(); i++) {
 9699:             if (mBlocks[i])
 9699:                 size += sizeof(Block);
13877:             size += sizeof(nsAutoPtr<Block>);
13877:         }
 9699:         return size;
 9699:     }
 9699: 
11575:     // clear out all blocks in the array
11575:     void reset() {
11575:         PRUint32 i;
11575:         for (i = 0; i < mBlocks.Length(); i++)
11575:             mBlocks[i] = nsnull;    
11575:     }
 9699:     
 9699:     nsTArray< nsAutoPtr<Block> > mBlocks;
 9699: };
 9699: 
26852: #define TRUETYPE_TAG(a, b, c, d) ((a) << 24 | (b) << 16 | (c) << 8 | (d))
26852: 
31590: namespace mozilla {
31590: 
31590: // Byte-swapping types and name table structure definitions moved from
31590: // gfxFontUtils.cpp to .h file so that gfxFont.cpp can also refer to them
31590: #pragma pack(1)
31590: 
31590: struct AutoSwap_PRUint16 {
31590: #ifdef __SUNPRO_CC
31590:     AutoSwap_PRUint16& operator = (const PRUint16 aValue)
31590:       { this->value = NS_SWAP16(aValue); return *this; }
31590: #else
31590:     AutoSwap_PRUint16(PRUint16 aValue) { value = NS_SWAP16(aValue); }
31590: #endif
31590:     operator PRUint16() const { return NS_SWAP16(value); }
31590:     operator PRUint32() const { return NS_SWAP16(value); }
31590:     operator PRUint64() const { return NS_SWAP16(value); }
31590:     PRUint16 value;
31590: };
31590: 
31590: struct AutoSwap_PRInt16 {
31590: #ifdef __SUNPRO_CC
31590:     AutoSwap_PRInt16& operator = (const PRInt16 aValue)
31590:       { this->value = NS_SWAP16(aValue); return *this; }
31590: #else
31590:     AutoSwap_PRInt16(PRInt16 aValue) { value = NS_SWAP16(aValue); }
31590: #endif
31590:     operator PRInt16() const { return NS_SWAP16(value); }
31590:     operator PRUint32() const { return NS_SWAP16(value); }
31590:     PRInt16  value;
31590: };
31590: 
31590: struct AutoSwap_PRUint32 {
31590: #ifdef __SUNPRO_CC
31590:     AutoSwap_PRUint32& operator = (const PRUint32 aValue)
31590:       { this->value = NS_SWAP32(aValue); return *this; }
31590: #else
31590:     AutoSwap_PRUint32(PRUint32 aValue) { value = NS_SWAP32(aValue); }
31590: #endif
31590:     operator PRUint32() const { return NS_SWAP32(value); }
31590:     PRUint32  value;
31590: };
31590: 
47309: struct AutoSwap_PRInt32 {
47309: #ifdef __SUNPRO_CC
47309:     AutoSwap_PRInt32& operator = (const PRInt32 aValue)
47309:       { this->value = NS_SWAP32(aValue); return *this; }
47309: #else
47309:     AutoSwap_PRInt32(PRInt32 aValue) { value = NS_SWAP32(aValue); }
47309: #endif
47309:     operator PRInt32() const { return NS_SWAP32(value); }
47309:     PRInt32  value;
47309: };
47309: 
31590: struct AutoSwap_PRUint64 {
31590: #ifdef __SUNPRO_CC
31590:     AutoSwap_PRUint64& operator = (const PRUint64 aValue)
31590:       { this->value = NS_SWAP64(aValue); return *this; }
31590: #else
31590:     AutoSwap_PRUint64(PRUint64 aValue) { value = NS_SWAP64(aValue); }
31590: #endif
31590:     operator PRUint64() const { return NS_SWAP64(value); }
31590:     PRUint64  value;
31590: };
31590: 
42989: struct AutoSwap_PRUint24 {
42989:     operator PRUint32() const { return value[0] << 16 | value[1] << 8 | value[2]; }
42989: private:
42989:     AutoSwap_PRUint24() { }
42989:     PRUint8  value[3];
42989: };
42989: 
47309: struct HeadTable {
47309:     enum {
47309:         HEAD_MAGIC_NUMBER = 0x5F0F3CF5,
47309:         HEAD_CHECKSUM_CALC_CONST = 0xB1B0AFBA
47309:     };
47309: 
47309:     AutoSwap_PRUint32    tableVersionNumber;    // Fixed, 0x00010000 for version 1.0.
47309:     AutoSwap_PRUint32    fontRevision;          // Set by font manufacturer.
47309:     AutoSwap_PRUint32    checkSumAdjustment;    // To compute: set it to 0, sum the entire font as ULONG, then store 0xB1B0AFBA - sum.
47309:     AutoSwap_PRUint32    magicNumber;           // Set to 0x5F0F3CF5.
47309:     AutoSwap_PRUint16    flags;
47309:     AutoSwap_PRUint16    unitsPerEm;            // Valid range is from 16 to 16384. This value should be a power of 2 for fonts that have TrueType outlines.
47309:     AutoSwap_PRUint64    created;               // Number of seconds since 12:00 midnight, January 1, 1904. 64-bit integer
47309:     AutoSwap_PRUint64    modified;              // Number of seconds since 12:00 midnight, January 1, 1904. 64-bit integer
47309:     AutoSwap_PRInt16     xMin;                  // For all glyph bounding boxes.
47309:     AutoSwap_PRInt16     yMin;                  // For all glyph bounding boxes.
47309:     AutoSwap_PRInt16     xMax;                  // For all glyph bounding boxes.
47309:     AutoSwap_PRInt16     yMax;                  // For all glyph bounding boxes.
47309:     AutoSwap_PRUint16    macStyle;              // Bit 0: Bold (if set to 1);
47309:     AutoSwap_PRUint16    lowestRecPPEM;         // Smallest readable size in pixels.
47309:     AutoSwap_PRInt16     fontDirectionHint;
47309:     AutoSwap_PRInt16     indexToLocFormat;
47309:     AutoSwap_PRInt16     glyphDataFormat;
47309: };
47309: 
47309: struct OS2Table {
47309:     AutoSwap_PRUint16    version;                // 0004 = OpenType 1.5
47309:     AutoSwap_PRInt16     xAvgCharWidth;
47309:     AutoSwap_PRUint16    usWeightClass;
47309:     AutoSwap_PRUint16    usWidthClass;
47309:     AutoSwap_PRUint16    fsType;
47309:     AutoSwap_PRInt16     ySubscriptXSize;
47309:     AutoSwap_PRInt16     ySubscriptYSize;
47309:     AutoSwap_PRInt16     ySubscriptXOffset;
47309:     AutoSwap_PRInt16     ySubscriptYOffset;
47309:     AutoSwap_PRInt16     ySuperscriptXSize;
47309:     AutoSwap_PRInt16     ySuperscriptYSize;
47309:     AutoSwap_PRInt16     ySuperscriptXOffset;
47309:     AutoSwap_PRInt16     ySuperscriptYOffset;
47309:     AutoSwap_PRInt16     yStrikeoutSize;
47309:     AutoSwap_PRInt16     yStrikeoutPosition;
47309:     AutoSwap_PRInt16     sFamilyClass;
47309:     PRUint8              panose[10];
47309:     AutoSwap_PRUint32    unicodeRange1;
47309:     AutoSwap_PRUint32    unicodeRange2;
47309:     AutoSwap_PRUint32    unicodeRange3;
47309:     AutoSwap_PRUint32    unicodeRange4;
47309:     PRUint8              achVendID[4];
47309:     AutoSwap_PRUint16    fsSelection;
47309:     AutoSwap_PRUint16    usFirstCharIndex;
47309:     AutoSwap_PRUint16    usLastCharIndex;
47309:     AutoSwap_PRInt16     sTypoAscender;
47309:     AutoSwap_PRInt16     sTypoDescender;
47309:     AutoSwap_PRInt16     sTypoLineGap;
47309:     AutoSwap_PRUint16    usWinAscent;
47309:     AutoSwap_PRUint16    usWinDescent;
47309:     AutoSwap_PRUint32    codePageRange1;
47309:     AutoSwap_PRUint32    codePageRange2;
47309:     AutoSwap_PRInt16     sxHeight;
47309:     AutoSwap_PRInt16     sCapHeight;
47309:     AutoSwap_PRUint16    usDefaultChar;
47309:     AutoSwap_PRUint16    usBreakChar;
47309:     AutoSwap_PRUint16    usMaxContext;
47309: };
47309: 
47309: struct PostTable {
47309:     AutoSwap_PRUint32    version;
47309:     AutoSwap_PRInt32     italicAngle;
47309:     AutoSwap_PRInt16     underlinePosition;
47309:     AutoSwap_PRUint16    underlineThickness;
47309:     AutoSwap_PRUint32    isFixedPitch;
47309:     AutoSwap_PRUint32    minMemType42;
47309:     AutoSwap_PRUint32    maxMemType42;
47309:     AutoSwap_PRUint32    minMemType1;
47309:     AutoSwap_PRUint32    maxMemType1;
47309: };
47309: 
47309: struct HheaTable {
47309:     AutoSwap_PRUint32    version;
47309:     AutoSwap_PRInt16     ascender;
47309:     AutoSwap_PRInt16     descender;
47309:     AutoSwap_PRInt16     lineGap;
47309:     AutoSwap_PRUint16    advanceWidthMax;
47309:     AutoSwap_PRInt16     minLeftSideBearing;
47309:     AutoSwap_PRInt16     minRightSideBearing;
47309:     AutoSwap_PRInt16     xMaxExtent;
47309:     AutoSwap_PRInt16     caretSlopeRise;
47309:     AutoSwap_PRInt16     caretSlopeRun;
47309:     AutoSwap_PRInt16     caretOffset;
47309:     AutoSwap_PRInt16     reserved1;
47309:     AutoSwap_PRInt16     reserved2;
47309:     AutoSwap_PRInt16     reserved3;
47309:     AutoSwap_PRInt16     reserved4;
47309:     AutoSwap_PRInt16     metricDataFormat;
47309:     AutoSwap_PRUint16    numOfLongHorMetrics;
47309: };
47309: 
31590: #pragma pack()
31590: 
43523: // Return just the highest bit of the given value, i.e., the highest
43523: // power of 2 that is <= value, or zero if the input value is zero.
43523: inline PRUint32
43523: FindHighestBit(PRUint32 value)
43523: {
43523:     // propagate highest bit into all lower bits of the value
43523:     value |= (value >> 1);
43523:     value |= (value >> 2);
43523:     value |= (value >> 4);
43523:     value |= (value >> 8);
43523:     value |= (value >> 16);
43523:     // isolate the leftmost bit
43523:     return (value & ~(value >> 1));
43523: }
43523: 
31590: } // namespace mozilla
31590: 
30595: // used for overlaying name changes without touching original font data
30595: struct FontDataOverlay {
30595:     // overlaySrc != 0 ==> use overlay
30595:     PRUint32  overlaySrc;    // src offset from start of font data
30595:     PRUint32  overlaySrcLen; // src length
30595:     PRUint32  overlayDest;   // dest offset from start of font data
30595: };
30595:     
32808: enum gfxUserFontType {
32808:     GFX_USERFONT_UNKNOWN = 0,
32808:     GFX_USERFONT_OPENTYPE = 1,
32808:     GFX_USERFONT_SVG = 2,
32808:     GFX_USERFONT_WOFF = 3
32808: };
32808: 
 9699: class THEBES_API gfxFontUtils {
 9699: 
 9699: public:
31590:     // these are public because gfxFont.cpp also looks into the name table
31590:     enum {
31590:         NAME_ID_FAMILY = 1,
31590:         NAME_ID_STYLE = 2,
31590:         NAME_ID_UNIQUE = 3,
31590:         NAME_ID_FULL = 4,
31590:         NAME_ID_VERSION = 5,
31590:         NAME_ID_POSTSCRIPT = 6,
31590:         NAME_ID_PREFERRED_FAMILY = 16,
31590:         NAME_ID_PREFERRED_STYLE = 17,
31590: 
31590:         PLATFORM_ALL = -1,
31590:         PLATFORM_ID_UNICODE = 0,           // Mac OS uses this typically
31590:         PLATFORM_ID_MAC = 1,
31590:         PLATFORM_ID_ISO = 2,
31590:         PLATFORM_ID_MICROSOFT = 3,
31590: 
31590:         ENCODING_ID_MAC_ROMAN = 0,         // traditional Mac OS script manager encodings
31590:         ENCODING_ID_MAC_JAPANESE = 1,      // (there are others defined, but some were never
31590:         ENCODING_ID_MAC_TRAD_CHINESE = 2,  // implemented by Apple, and I have never seen them
31590:         ENCODING_ID_MAC_KOREAN = 3,        // used in font names)
31590:         ENCODING_ID_MAC_ARABIC = 4,
31590:         ENCODING_ID_MAC_HEBREW = 5,
31590:         ENCODING_ID_MAC_GREEK = 6,
31590:         ENCODING_ID_MAC_CYRILLIC = 7,
31590:         ENCODING_ID_MAC_DEVANAGARI = 9,
31590:         ENCODING_ID_MAC_GURMUKHI = 10,
31590:         ENCODING_ID_MAC_GUJARATI = 11,
31590:         ENCODING_ID_MAC_SIMP_CHINESE = 25,
31590: 
31590:         ENCODING_ID_MICROSOFT_SYMBOL = 0,  // Microsoft platform encoding IDs
31590:         ENCODING_ID_MICROSOFT_UNICODEBMP = 1,
31590:         ENCODING_ID_MICROSOFT_SHIFTJIS = 2,
31590:         ENCODING_ID_MICROSOFT_PRC = 3,
31590:         ENCODING_ID_MICROSOFT_BIG5 = 4,
31590:         ENCODING_ID_MICROSOFT_WANSUNG = 5,
31590:         ENCODING_ID_MICROSOFT_JOHAB  = 6,
31590:         ENCODING_ID_MICROSOFT_UNICODEFULL = 10,
31590: 
31590:         LANG_ALL = -1,
31590:         LANG_ID_MAC_ENGLISH = 0,      // many others are defined, but most don't affect
31590:         LANG_ID_MAC_HEBREW = 10,      // the charset; should check all the central/eastern
31590:         LANG_ID_MAC_JAPANESE = 11,    // european codes, though
31590:         LANG_ID_MAC_ARABIC = 12,
31590:         LANG_ID_MAC_ICELANDIC = 15,
31590:         LANG_ID_MAC_TURKISH = 17,
31590:         LANG_ID_MAC_TRAD_CHINESE = 19,
31590:         LANG_ID_MAC_URDU = 20,
31590:         LANG_ID_MAC_KOREAN = 23,
31590:         LANG_ID_MAC_POLISH = 25,
31590:         LANG_ID_MAC_FARSI = 31,
31590:         LANG_ID_MAC_SIMP_CHINESE = 33,
31590:         LANG_ID_MAC_ROMANIAN = 37,
31590:         LANG_ID_MAC_CZECH = 38,
31590:         LANG_ID_MAC_SLOVAK = 39,
31590: 
32826:         LANG_ID_MICROSOFT_EN_US = 0x0409,        // with Microsoft platformID, EN US lang code
32826:         
32826:         CMAP_MAX_CODEPOINT = 0x10ffff     // maximum possible Unicode codepoint 
32826:                                           // contained in a cmap
31590:     };
31590: 
31590:     // name table has a header, followed by name records, followed by string data
31590:     struct NameHeader {
31590:         mozilla::AutoSwap_PRUint16    format;       // Format selector (=0).
31590:         mozilla::AutoSwap_PRUint16    count;        // Number of name records.
31590:         mozilla::AutoSwap_PRUint16    stringOffset; // Offset to start of string storage
31590:                                                     // (from start of table)
31590:     };
31590: 
31590:     struct NameRecord {
31590:         mozilla::AutoSwap_PRUint16    platformID;   // Platform ID
31590:         mozilla::AutoSwap_PRUint16    encodingID;   // Platform-specific encoding ID
31590:         mozilla::AutoSwap_PRUint16    languageID;   // Language ID
31590:         mozilla::AutoSwap_PRUint16    nameID;       // Name ID.
31590:         mozilla::AutoSwap_PRUint16    length;       // String length (in bytes).
31590:         mozilla::AutoSwap_PRUint16    offset;       // String offset from start of storage
31590:                                                     // (in bytes).
31590:     };
 9699: 
 9699:     // for reading big-endian font data on either big or little-endian platforms
 9699: 
 9699:     static inline PRUint16
 9699:     ReadShortAt(const PRUint8 *aBuf, PRUint32 aIndex)
 9699:     {
 9699:         return (aBuf[aIndex] << 8) | aBuf[aIndex + 1];
 9699:     }
 9699: 
 9699:     static inline PRUint16
 9699:     ReadShortAt16(const PRUint16 *aBuf, PRUint32 aIndex)
 9699:     {
31590:         const PRUint8 *buf = reinterpret_cast<const PRUint8*>(aBuf);
 9699:         PRUint32 index = aIndex << 1;
 9699:         return (buf[index] << 8) | buf[index+1];
 9699:     }
 9699: 
 9699:     static inline PRUint32
42989:     ReadUint24At(const PRUint8 *aBuf, PRUint32 aIndex)
42989:     {
42989:         return ((aBuf[aIndex] << 16) | (aBuf[aIndex + 1] << 8) |
42989:                 (aBuf[aIndex + 2]));
42989:     }
42989: 
42989:     static inline PRUint32
 9699:     ReadLongAt(const PRUint8 *aBuf, PRUint32 aIndex)
 9699:     {
19962:         return ((aBuf[aIndex] << 24) | (aBuf[aIndex + 1] << 16) | 
19962:                 (aBuf[aIndex + 2] << 8) | (aBuf[aIndex + 3]));
 9699:     }
 9699: 
 9699:     static nsresult
43526:     ReadCMAPTableFormat12(const PRUint8 *aBuf, PRUint32 aLength, 
19962:                           gfxSparseBitSet& aCharacterMap);
 9699: 
 9699:     static nsresult 
43526:     ReadCMAPTableFormat4(const PRUint8 *aBuf, PRUint32 aLength, 
19962:                          gfxSparseBitSet& aCharacterMap);
 9699: 
42989:     static nsresult
43526:     ReadCMAPTableFormat14(const PRUint8 *aBuf, PRUint32 aLength, 
42989:                           PRUint8*& aTable);
42989: 
35526:     static PRUint32
43526:     FindPreferredSubtable(const PRUint8 *aBuf, PRUint32 aBufLength,
42989:                           PRUint32 *aTableOffset, PRUint32 *aUVSTableOffset,
42989:                           PRBool *aSymbolEncoding);
35526: 
 9699:     static nsresult
43526:     ReadCMAP(const PRUint8 *aBuf, PRUint32 aBufLength,
43526:              gfxSparseBitSet& aCharacterMap,
42989:              PRUint32& aUVSOffset,
13578:              PRPackedBool& aUnicodeFont, PRPackedBool& aSymbolFont);
 9699: 
35526:     static PRUint32
35526:     MapCharToGlyphFormat4(const PRUint8 *aBuf, PRUnichar aCh);
35526: 
43526:     static PRUint32
43526:     MapCharToGlyphFormat12(const PRUint8 *aBuf, PRUint32 aCh);
43526: 
42989:     static PRUint16
42989:     MapUVSToGlyphFormat14(const PRUint8 *aBuf, PRUint32 aCh, PRUint32 aVS);
42989: 
35526:     static PRUint32
43526:     MapCharToGlyph(const PRUint8 *aBuf, PRUint32 aBufLength, PRUnichar aCh);
35526: 
19962: #ifdef XP_WIN
30595: 
19962:     // given a TrueType/OpenType data file, produce a EOT-format header
19962:     // for use with Windows T2Embed API AddFontResource type API's
19962:     // effectively hide existing fonts with matching names aHeaderLen is
19962:     // the size of the header buffer on input, the actual size of the
22991:     // EOT header on output
19962:     static nsresult
21067:     MakeEOTHeader(const PRUint8 *aFontData, PRUint32 aFontDataLength,
30595:                   nsTArray<PRUint8> *aHeader, FontDataOverlay *aOverlay);
32808: 
32808:     // determine whether a font (which has already passed ValidateSFNTHeaders)
32808:     // is CFF format rather than TrueType
32808:     static PRBool
32808:     IsCffFont(const PRUint8* aFontData);
32808: 
19962: #endif
19962: 
32808:     // determine the format of font data
32808:     static gfxUserFontType
32808:     DetermineFontDataType(const PRUint8 *aFontData, PRUint32 aFontDataLength);
32808: 
21067:     // checks for valid SFNT table structure, returns true if valid
21067:     // does *not* guarantee that all font data is valid
21067:     static PRBool
32808:     ValidateSFNTHeaders(const PRUint8 *aFontData, PRUint32 aFontDataLength);
22991:     
22991:     // create a new name table and build a new font with that name table
22991:     // appended on the end, returns true on success
22991:     static nsresult
22991:     RenameFont(const nsAString& aName, const PRUint8 *aFontData, 
22991:                PRUint32 aFontDataLength, nsTArray<PRUint8> *aNewFont);
21067:     
26852:     // read all names matching aNameID, returning in aNames array
26852:     static nsresult
26852:     ReadNames(nsTArray<PRUint8>& aNameTable, PRUint32 aNameID, 
26852:               PRInt32 aPlatformID, nsTArray<nsString>& aNames);
26852:       
26852:     // reads English or first name matching aNameID, returning in aName
26852:     // platform based on OS
26852:     static nsresult
26852:     ReadCanonicalName(nsTArray<PRUint8>& aNameTable, PRUint32 aNameID, 
26852:                       nsString& aName);
26852:       
31590:     // convert a name from the raw name table data into an nsString,
31590:     // provided we know how; return PR_TRUE if successful, or PR_FALSE
31590:     // if we can't handle the encoding
31590:     static PRBool
31590:     DecodeFontName(const PRUint8 *aBuf, PRInt32 aLength, 
31590:                    PRUint32 aPlatformCode, PRUint32 aScriptCode,
31590:                    PRUint32 aLangCode, nsAString& dest);
31590: 
36291:     static inline bool IsJoinCauser(PRUint32 ch) {
36291:         return (ch == 0x200D);
 9699:     }
 9699: 
42989:     enum {
42989:         kUnicodeVS1 = 0xFE00,
42989:         kUnicodeVS16 = 0xFE0F,
42989:         kUnicodeVS17 = 0xE0100,
42989:         kUnicodeVS256 = 0xE01EF
42989:     };
42989: 
42989:     static inline bool IsVarSelector(PRUint32 ch) {
42989:         return (ch >= kUnicodeVS1 && ch <= kUnicodeVS16) ||
42989:                (ch >= kUnicodeVS17 && ch <= kUnicodeVS256);
42989:     }
42989: 
 9699:     static inline bool IsInvalid(PRUint32 ch) {
 9699:         return (ch == 0xFFFD);
 9699:     }
 9699: 
37211:     // Font code may want to know if there is the potential for bidi behavior
37211:     // to be triggered by any of the characters in a text run; this can be
37211:     // used to test that possibility.
37211:     enum {
37211:         kUnicodeBidiScriptsStart = 0x0590,
37211:         kUnicodeBidiScriptsEnd = 0x08FF,
37211:         kUnicodeBidiPresentationStart = 0xFB1D,
37211:         kUnicodeBidiPresentationEnd = 0xFEFC,
37211:         kUnicodeFirstHighSurrogateBlock = 0xD800,
37211:         kUnicodeRLM = 0x200F,
37211:         kUnicodeRLE = 0x202B,
37211:         kUnicodeRLO = 0x202E
37211:     };
37211: 
37211:     static inline PRBool PotentialRTLChar(PRUnichar aCh) {
37211:         if (aCh >= kUnicodeBidiScriptsStart && aCh <= kUnicodeBidiScriptsEnd)
37211:             // bidi scripts Hebrew, Arabic, Syriac, Thaana, N'Ko are all encoded together
37211:             return PR_TRUE;
37211: 
37211:         if (aCh == kUnicodeRLM || aCh == kUnicodeRLE || aCh == kUnicodeRLO)
37211:             // directional controls that trigger bidi layout
37211:             return PR_TRUE;
37211: 
37211:         if (aCh >= kUnicodeBidiPresentationStart &&
37211:             aCh <= kUnicodeBidiPresentationEnd)
37211:             // presentation forms of Arabic and Hebrew letters
37211:             return PR_TRUE;
37211: 
37211:         if ((aCh & 0xFF00) == kUnicodeFirstHighSurrogateBlock)
37211:             // surrogate that could be part of a bidi supplementary char
37211:             // (Cypriot, Aramaic, Phoenecian, etc)
37211:             return PR_TRUE;
37211: 
37211:         // otherwise we know this char cannot trigger bidi reordering
37211:         return PR_FALSE;
37211:     }
37211: 
 9699:     static PRUint8 CharRangeBit(PRUint32 ch);
 9699:     
12239:     // for a given font list pref name, set up a list of font names
19962:     static void GetPrefsFontList(const char *aPrefName, 
19962:                                  nsTArray<nsString>& aFontList);
12239: 
26027:     // generate a unique font name
26027:     static nsresult MakeUniqueUserFontName(nsAString& aName);
26027: 
26852: protected:
26852:     static nsresult
26852:     ReadNames(nsTArray<PRUint8>& aNameTable, PRUint32 aNameID, 
26852:               PRInt32 aLangID, PRInt32 aPlatformID, nsTArray<nsString>& aNames);
26852: 
31590:     // convert opentype name-table platform/encoding/language values to a charset name
31590:     // we can use to convert the name data to unicode, or "" if data is UTF16BE
31590:     static const char*
31590:     GetCharsetForFontName(PRUint16 aPlatform, PRUint16 aScript, PRUint16 aLanguage);
31590: 
31590:     struct MacFontNameCharsetMapping {
31590:         PRUint16    mEncoding;
31590:         PRUint16    mLanguage;
31590:         const char *mCharsetName;
31590: 
31590:         bool operator<(const MacFontNameCharsetMapping& rhs) const {
31590:             return (mEncoding < rhs.mEncoding) ||
31590:                    ((mEncoding == rhs.mEncoding) && (mLanguage < rhs.mLanguage));
31590:         }
31590:     };
31590:     static const MacFontNameCharsetMapping gMacFontNameCharsets[];
31590:     static const char* gISOFontNameCharsets[];
31590:     static const char* gMSFontNameCharsets[];
 9699: };
 9699: 
13877: // helper class for loading in font info spaced out at regular intervals
13877: 
13877: class gfxFontInfoLoader {
13877: public:
13877: 
13877:     // state transitions:
13877:     //   initial ---StartLoader with delay---> timer on delay
13877:     //   initial ---StartLoader without delay---> timer on interval
13877:     //   timer on delay ---LoaderTimerFire---> timer on interval
13877:     //   timer on delay ---CancelLoader---> timer off
13877:     //   timer on interval ---CancelLoader---> timer off
13877:     //   timer off ---StartLoader with delay---> timer on delay
13877:     //   timer off ---StartLoader without delay---> timer on interval
13877:     typedef enum {
13877:         stateInitial,
13877:         stateTimerOnDelay,
13877:         stateTimerOnInterval,
13877:         stateTimerOff
13877:     } TimerState;
13877: 
13877:     gfxFontInfoLoader() :
13877:         mInterval(0), mState(stateInitial)
13877:     {
13877:     }
13877: 
13877:     virtual ~gfxFontInfoLoader() {}
13877: 
13877:     // start timer with an initial delay, then call Run method at regular intervals
13877:     void StartLoader(PRUint32 aDelay, PRUint32 aInterval) {
13877:         mInterval = aInterval;
13877: 
13877:         // sanity check
13877:         if (mState != stateInitial && mState != stateTimerOff)
13877:             CancelLoader();
13877: 
13877:         // set up timer
13877:         if (!mTimer) {
13877:             mTimer = do_CreateInstance("@mozilla.org/timer;1");
13877:             if (!mTimer) {
13877:                 NS_WARNING("Failure to create font info loader timer");
13877:                 return;
13877:             }
13877:         }
13877: 
13877:         // need an initial delay?
13877:         PRUint32 timerInterval;
13877: 
13877:         if (aDelay) {
13877:             mState = stateTimerOnDelay;
13877:             timerInterval = aDelay;
13877:         } else {
13877:             mState = stateTimerOnInterval;
13877:             timerInterval = mInterval;
13877:         }
13877: 
13877:         InitLoader();
13877: 
13877:         // start timer
19962:         mTimer->InitWithFuncCallback(LoaderTimerCallback, this, aDelay, 
19962:                                      nsITimer::TYPE_REPEATING_SLACK);
13877:     }
13877: 
13877:     // cancel the timer and cleanup
13877:     void CancelLoader() {
13877:         if (mState == stateInitial)
13877:             return;
13877:         mState = stateTimerOff;
13877:         if (mTimer) {
13877:             mTimer->Cancel();
13877:         }
13877:         FinishLoader();
13877:     }
13877: 
13877: protected:
13877: 
13877:     // Init - initialization at start time after initial delay
13877:     virtual void InitLoader() = 0;
13877: 
13877:     // Run - called at intervals, return true to indicate done
13877:     virtual PRBool RunLoader() = 0;
13877: 
13877:     // Finish - cleanup after done
13877:     virtual void FinishLoader() = 0;
13877: 
13877:     static void LoaderTimerCallback(nsITimer *aTimer, void *aThis) {
31590:         gfxFontInfoLoader *loader = static_cast<gfxFontInfoLoader*>(aThis);
13877:         loader->LoaderTimerFire();
13877:     }
13877: 
13877:     // start the timer, interval callbacks
13877:     void LoaderTimerFire() {
13877:         if (mState == stateTimerOnDelay) {
13877:             mState = stateTimerOnInterval;
13877:             mTimer->SetDelay(mInterval);
13877:         }
13877: 
13877:         PRBool done = RunLoader();
13877:         if (done) {
13877:             CancelLoader();
13877:         }
13877:     }
13877: 
13877:     nsCOMPtr<nsITimer> mTimer;
13877:     PRUint32 mInterval;
13877:     TimerState mState;
13877: };
13877: 
 9699: #endif /* GFX_FONT_UTILS_H */
