     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsPrintEngine.h"
     1: 
     1: #include "nsIStringBundle.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsCRT.h"
     1: 
     1: #include "nsISelection.h"
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIDocShell.h"
 77154: #include "nsIFrame.h"
     1: #include "nsIURI.h"
 36876: #include "nsITextToSubURI.h"
108290: #include "nsError.h"
     1: 
127357: #include "nsView.h"
114469: #include "nsAsyncDOMEvent.h"
114469: 
     1: // Print Options
     1: #include "nsIPrintSettings.h"
     1: #include "nsIPrintSettingsService.h"
     1: #include "nsIPrintOptions.h"
     1: #include "nsIPrintSession.h"
     1: #include "nsGfxCIID.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsXPCOM.h"
     1: #include "nsISupportsPrimitives.h"
     1: 
     1: static const char sPrintSettingsServiceContractID[] = "@mozilla.org/gfx/printsettings-service;1";
     1: 
     1: // Printing Events
     1: #include "nsPrintPreviewListener.h"
     1: #include "nsThreadUtils.h"
     1: 
     1: // Printing
     1: #include "nsIWebBrowserPrint.h"
     1: #include "nsIDOMHTMLFrameElement.h"
     1: #include "nsIDOMHTMLFrameSetElement.h"
     1: #include "nsIDOMHTMLIFrameElement.h"
     1: #include "nsIDOMHTMLObjectElement.h"
     1: #include "nsIDOMHTMLEmbedElement.h"
     1: 
     1: // Print Preview
     1: #include "imgIContainer.h" // image animation mode constants
     1: #include "nsIWebBrowserPrint.h" // needed for PrintPreview Navigation constants
     1: 
     1: // Print Progress
     1: #include "nsIPrintProgress.h"
     1: #include "nsIPrintProgressParams.h"
     1: #include "nsIObserver.h"
     1: 
     1: // Print error dialog
     1: #include "nsIPrompt.h"
     1: #include "nsIWindowWatcher.h"
     1: 
     1: // Printing Prompts
     1: #include "nsIPrintingPromptService.h"
     1: static const char kPrintingPromptService[] = "@mozilla.org/embedcomp/printingprompt-service;1";
     1: 
     1: // Printing Timer
     1: #include "nsPagePrintTimer.h"
     1: 
     1: // FrameSet
     1: #include "nsIDocument.h"
     1: 
     1: // Focus
  1418: #include "nsIDOMEventTarget.h"
     1: #include "nsISelectionController.h"
     1: 
     1: // Misc
     1: #include "nsISupportsUtils.h"
     1: #include "nsIScriptContext.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsISelectionListener.h"
     1: #include "nsISelectionPrivate.h"
     1: #include "nsIDOMRange.h"
     1: #include "nsContentCID.h"
     1: #include "nsLayoutCID.h"
     1: #include "nsContentUtils.h"
     1: #include "nsIPresShell.h"
     1: #include "nsLayoutUtils.h"
 70840: #include "mozilla/Preferences.h"
     1: 
     1: #include "nsWidgetsCID.h"
     1: #include "nsIDeviceContextSpec.h"
127607: #include "nsViewManager.h"
127357: #include "nsView.h"
 68487: #include "nsRenderingContext.h"
     1: 
     1: #include "nsIPageSequenceFrame.h"
     1: #include "nsIURL.h"
     1: #include "nsIContentViewerEdit.h"
     1: #include "nsIContentViewerFile.h"
     1: #include "nsIMarkupDocumentViewer.h"
     1: #include "nsIInterfaceRequestor.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShellTreeNode.h"
     1: #include "nsIDocShellTreeOwner.h"
  7849: #include "nsIWebBrowserChrome.h"
     1: #include "nsIBaseWindow.h"
     1: #include "nsILayoutHistoryState.h"
     1: #include "nsFrameManager.h"
     1: #include "nsGUIEvent.h"
     1: #include "nsHTMLReflowState.h"
     1: #include "nsIDOMHTMLAnchorElement.h"
     1: #include "nsIDOMHTMLAreaElement.h"
     1: #include "nsIDOMHTMLLinkElement.h"
     1: #include "nsIDOMHTMLImageElement.h"
     1: #include "nsIContentViewerContainer.h"
     1: #include "nsIContentViewer.h"
     1: #include "nsIDocumentViewerPrint.h"
     1: 
 29018: #include "nsFocusManager.h"
 35581: #include "nsRange.h"
     1: #include "nsCDefaultURIFixup.h"
     1: #include "nsIURIFixup.h"
 41930: #include "mozilla/dom/Element.h"
114093: #include "nsContentList.h"
 41634: 
 70840: using namespace mozilla;
 41634: using namespace mozilla::dom;
     1: 
     1: //-----------------------------------------------------
     1: // PR LOGGING
     1: #ifdef MOZ_LOGGING
     1: #define FORCE_PR_LOG /* Allow logging in the release build */
     1: #endif
     1: 
     1: #include "prlog.h"
     1: 
     1: #ifdef PR_LOGGING
     1: 
102909: #ifdef DEBUG
     1: // PR_LOGGING is force to always be on (even in release builds)
     1: // but we only want some of it on,
     1: //#define EXTENDED_DEBUG_PRINTING 
     1: #endif
     1: 
     1: #define DUMP_LAYOUT_LEVEL 9 // this turns on the dumping of each doucment's layout info
     1: 
120415: static PRLogModuleInfo *
120415: GetPrintingLog()
120415: {
120415:   static PRLogModuleInfo *sLog;
120415:   if (!sLog)
120415:     sLog = PR_NewLogModule("printing");
120415:   return sLog;
120415: }
120415: #define PR_PL(_p1)  PR_LOG(GetPrintingLog(), PR_LOG_DEBUG, _p1);
     1: 
     1: #ifdef EXTENDED_DEBUG_PRINTING
108991: static uint32_t gDumpFileNameCnt   = 0;
108991: static uint32_t gDumpLOFileNameCnt = 0;
     1: #endif
     1: 
     1: #define PRT_YESNO(_p) ((_p)?"YES":"NO")
     1: static const char * gFrameTypesStr[]       = {"eDoc", "eFrame", "eIFrame", "eFrameSet"};
     1: static const char * gPrintFrameTypeStr[]   = {"kNoFrames", "kFramesAsIs", "kSelectedFrame", "kEachFrameSep"};
     1: static const char * gFrameHowToEnableStr[] = {"kFrameEnableNone", "kFrameEnableAll", "kFrameEnableAsIsAndEach"};
     1: static const char * gPrintRangeStr[]       = {"kRangeAllPages", "kRangeSpecifiedPageRange", "kRangeSelection", "kRangeFocusFrame"};
     1: #else
     1: #define PRT_YESNO(_p)
     1: #define PR_PL(_p1)
     1: #endif
     1: 
     1: #ifdef EXTENDED_DEBUG_PRINTING
     1: // Forward Declarations
 24551: static void DumpPrintObjectsListStart(const char * aStr, nsTArray<nsPrintObject*> * aDocList);
106838: static void DumpPrintObjectsTree(nsPrintObject * aPO, int aLevel= 0, FILE* aFD = nullptr);
106838: static void DumpPrintObjectsTreeLayout(nsPrintObject * aPO,nsDeviceContext * aDC, int aLevel= 0, FILE * aFD = nullptr);
     1: 
     1: #define DUMP_DOC_LIST(_title) DumpPrintObjectsListStart((_title), mPrt->mPrintDocList);
     1: #define DUMP_DOC_TREE DumpPrintObjectsTree(mPrt->mPrintObject);
     1: #define DUMP_DOC_TREELAYOUT DumpPrintObjectsTreeLayout(mPrt->mPrintObject, mPrt->mPrintDC);
     1: #else
     1: #define DUMP_DOC_LIST(_title)
     1: #define DUMP_DOC_TREE
     1: #define DUMP_DOC_TREELAYOUT
     1: #endif
     1: 
 25991: class nsScriptSuppressor
 25991: {
 25991: public:
 25991:   nsScriptSuppressor(nsPrintEngine* aPrintEngine)
 80486:   : mPrintEngine(aPrintEngine), mSuppressed(false) {}
 25991: 
 25991:   ~nsScriptSuppressor() { Unsuppress(); }
 25991: 
 25991:   void Suppress()
 25991:   {
 25991:     if (mPrintEngine) {
 80486:       mSuppressed = true;
 80486:       mPrintEngine->TurnScriptingOn(false);
 25991:     }
 25991:   }
 25991:   
 25991:   void Unsuppress()
 25991:   {
 25991:     if (mPrintEngine && mSuppressed) {
 80486:       mPrintEngine->TurnScriptingOn(true);
 80486:     }
 80486:     mSuppressed = false;
 25991:   }
 25991: 
106838:   void Disconnect() { mPrintEngine = nullptr; }
 25991: protected:
 25991:   nsRefPtr<nsPrintEngine> mPrintEngine;
 79445:   bool                    mSuppressed;
 25991: };
     1: 
114469: NS_IMPL_ISUPPORTS3(nsPrintEngine, nsIWebProgressListener,
114469:                    nsISupportsWeakReference, nsIObserver)
     1: 
     1: //---------------------------------------------------
     1: //-- nsPrintEngine Class Impl
     1: //---------------------------------------------------
     1: nsPrintEngine::nsPrintEngine() :
 80486:   mIsCreatingPrintPreview(false),
 80486:   mIsDoingPrinting(false),
 80486:   mIsDoingPrintPreview(false),
 80486:   mProgressDialogIsShown(false),
 31784:   mScreenDPI(115.0f),
106838:   mPrt(nullptr),
106838:   mPagePrintTimer(nullptr),
106838:   mPageSeqFrame(nullptr),
106838:   mPrtPreview(nullptr),
106838:   mOldPrtPreview(nullptr),
114469:   mDebugFile(nullptr),
114469:   mLoadCounter(0),
128003:   mDidLoadDataForPrinting(false),
128003:   mIsDestroying(false)
     1: {
     1: }
     1: 
     1: //-------------------------------------------------------
     1: nsPrintEngine::~nsPrintEngine()
     1: {
     1:   Destroy(); // for insurance
     1: }
     1: 
     1: //-------------------------------------------------------
     1: void nsPrintEngine::Destroy()
     1: {
128003:   if (mIsDestroying) {
128003:     return;
128003:   }
128003:   mIsDestroying = true;
128003: 
     1:   if (mPrt) {
     1:     delete mPrt;
106838:     mPrt = nullptr;
     1:   }
     1: 
     1: #ifdef NS_PRINT_PREVIEW
     1:   if (mPrtPreview) {
     1:     delete mPrtPreview;
106838:     mPrtPreview = nullptr;
     1:   }
     1: 
     1:   // This is insruance
     1:   if (mOldPrtPreview) {
     1:     delete mOldPrtPreview;
106838:     mOldPrtPreview = nullptr;
     1:   }
     1: 
     1: #endif
106838:   mDocViewerPrint = nullptr;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: void nsPrintEngine::DestroyPrintingData()
     1: {
     1:   if (mPrt) {
128004:     nsPrintData* data = mPrt;
106838:     mPrt = nullptr;
128004:     delete data;
     1:   }
     1: }
     1: 
     1: //---------------------------------------------------------------------------------
     1: //-- Section: Methods needed by the DocViewer
     1: //---------------------------------------------------------------------------------
     1: 
     1: //--------------------------------------------------------
     1: nsresult nsPrintEngine::Initialize(nsIDocumentViewerPrint* aDocViewerPrint, 
 69583:                                    nsIWeakReference*       aContainer,
     1:                                    nsIDocument*            aDocument,
 31784:                                    float                   aScreenDPI,
     1:                                    FILE*                   aDebugFile)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aDocViewerPrint);
     1:   NS_ENSURE_ARG_POINTER(aContainer);
     1:   NS_ENSURE_ARG_POINTER(aDocument);
     1: 
 19768:   mDocViewerPrint = aDocViewerPrint;
 69583:   mContainer      = aContainer;
     1:   mDocument       = aDocument;
 31784:   mScreenDPI      = aScreenDPI;
     1: 
     1:   mDebugFile      = aDebugFile;      // ok to be NULL
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------
 79445: bool
     1: nsPrintEngine::CheckBeforeDestroy()
     1: {
     1:   if (mPrt && mPrt->mPreparingForPrint) {
 80486:     mPrt->mDocWasToBeDestroyed = true;
 80486:     return true;
 80486:   }
 80486:   return false;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: nsresult
     1: nsPrintEngine::Cancelled()
     1: {
     1:   if (mPrt && mPrt->mPrintSettings) {
 80486:     return mPrt->mPrintSettings->SetIsCancelled(true);
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: // Install our event listeners on the document to prevent 
     1: // some events from being processed while in PrintPreview 
     1: //
     1: // No return code - if this fails, there isn't much we can do
     1: void
     1: nsPrintEngine::InstallPrintPreviewListener()
     1: {
     1:   if (!mPrt->mPPEventListeners) {
 69583:     nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mContainer);
 69583:     nsCOMPtr<nsPIDOMWindow> win(do_GetInterface(docShell));
 69583:     if (win) {
     1:       nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(win->GetFrameElementInternal()));
     1:       mPrt->mPPEventListeners = new nsPrintPreviewListener(target);
     1:       mPrt->mPPEventListeners->AddListeners();
     1:     }
     1:   }
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: nsresult 
     1: nsPrintEngine::GetSeqFrameAndCountPagesInternal(nsPrintObject*  aPO,
     1:                                                 nsIFrame*&    aSeqFrame,
108991:                                                 int32_t&      aCount)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPO);
     1: 
     1:   // Finds the SimplePageSequencer frame
 39668:   nsIPageSequenceFrame* seqFrame = aPO->mPresShell->GetPageSequenceFrame();
     1:   if (seqFrame) {
 23554:     aSeqFrame = do_QueryFrame(seqFrame);
     1:   } else {
106838:     aSeqFrame = nullptr;
106838:   }
106838:   if (aSeqFrame == nullptr) return NS_ERROR_FAILURE;
     1: 
     1:   // first count the total number of pages
     1:   aCount = 0;
 77154:   nsIFrame* pageFrame = aSeqFrame->GetFirstPrincipalChild();
106838:   while (pageFrame != nullptr) {
     1:     aCount++;
     1:     pageFrame = pageFrame->GetNextSibling();
     1:   }
     1: 
     1:   return NS_OK;
     1: 
     1: }
     1: 
     1: //-----------------------------------------------------------------
108991: nsresult nsPrintEngine::GetSeqFrameAndCountPages(nsIFrame*& aSeqFrame, int32_t& aCount)
     1: {
     1:   NS_ASSERTION(mPrtPreview, "mPrtPreview can't be null!");
     1:   return GetSeqFrameAndCountPagesInternal(mPrtPreview->mPrintObject, aSeqFrame, aCount);
     1: }
     1: //---------------------------------------------------------------------------------
     1: //-- Done: Methods needed by the DocViewer
     1: //---------------------------------------------------------------------------------
     1: 
     1: 
     1: //---------------------------------------------------------------------------------
     1: //-- Section: nsIWebBrowserPrint
     1: //---------------------------------------------------------------------------------
     1: 
     1: // Foward decl for Debug Helper Functions
     1: #ifdef EXTENDED_DEBUG_PRINTING
     1: static int RemoveFilesInDir(const char * aDir);
     1: static void GetDocTitleAndURL(nsPrintObject* aPO, char *& aDocStr, char *& aURLStr);
     1: static void DumpPrintObjectsTree(nsPrintObject * aPO, int aLevel, FILE* aFD);
 24551: static void DumpPrintObjectsList(nsTArray<nsPrintObject*> * aDocList);
108991: static void RootFrameList(nsPresContext* aPresContext, FILE* out, int32_t aIndent);
     1: static void DumpViews(nsIDocShell* aDocShell, FILE* out);
     1: static void DumpLayoutData(char* aTitleStr, char* aURLStr,
     1:                            nsPresContext* aPresContext,
 68668:                            nsDeviceContext * aDC, nsIFrame * aRootFrame,
     1:                            nsIDocShell * aDocShell, FILE* aFD);
     1: #endif
     1: 
     1: //--------------------------------------------------------------------------------
     1: 
     1: nsresult
 79445: nsPrintEngine::CommonPrint(bool                    aIsPrintPreview,
     1:                            nsIPrintSettings*       aPrintSettings,
 35581:                            nsIWebProgressListener* aWebProgressListener,
 35581:                            nsIDOMDocument* aDoc) {
127826:   nsRefPtr<nsPrintEngine> kungfuDeathGrip = this;
     1:   nsresult rv = DoCommonPrint(aIsPrintPreview, aPrintSettings,
 35581:                               aWebProgressListener, aDoc);
     1:   if (NS_FAILED(rv)) {
     1:     if (aIsPrintPreview) {
 80486:       SetIsCreatingPrintPreview(false);
 80486:       SetIsPrintPreview(false);
     1:     } else {
 80486:       SetIsPrinting(false);
     1:     }
     1:     if (mProgressDialogIsShown)
     1:       CloseProgressDialog(aWebProgressListener);
     1:     if (rv != NS_ERROR_ABORT && rv != NS_ERROR_OUT_OF_MEMORY)
     1:       ShowPrintErrorDialog(rv, !aIsPrintPreview);
     1:     delete mPrt;
106838:     mPrt = nullptr;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
 79445: nsPrintEngine::DoCommonPrint(bool                    aIsPrintPreview,
     1:                              nsIPrintSettings*       aPrintSettings,
 35581:                              nsIWebProgressListener* aWebProgressListener,
 35581:                              nsIDOMDocument*         aDoc)
     1: {
     1:   nsresult rv;
     1: 
     1:   if (aIsPrintPreview) {
     1:     // The WebProgressListener can be QI'ed to nsIPrintingPromptService
     1:     // then that means the progress dialog is already being shown.
     1:     nsCOMPtr<nsIPrintingPromptService> pps(do_QueryInterface(aWebProgressListener));
106838:     mProgressDialogIsShown = pps != nullptr;
     1: 
     1:     if (mIsDoingPrintPreview) {
     1:       mOldPrtPreview = mPrtPreview;
106838:       mPrtPreview = nullptr;
     1:     }
     1:   } else {
 80486:     mProgressDialogIsShown = false;
     1:   }
     1: 
     1:   mPrt = new nsPrintData(aIsPrintPreview ? nsPrintData::eIsPrintPreview :
     1:                                            nsPrintData::eIsPrinting);
     1:   NS_ENSURE_TRUE(mPrt, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:   // if they don't pass in a PrintSettings, then get the Global PS
     1:   mPrt->mPrintSettings = aPrintSettings;
     1:   if (!mPrt->mPrintSettings) {
     1:     rv = GetGlobalPrintSettings(getter_AddRefs(mPrt->mPrintSettings));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
  1155:   rv = CheckForPrinters(mPrt->mPrintSettings);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 80486:   mPrt->mPrintSettings->SetIsCancelled(false);
     1:   mPrt->mPrintSettings->GetShrinkToFit(&mPrt->mShrinkToFit);
     1: 
     1:   if (aIsPrintPreview) {
 80486:     SetIsCreatingPrintPreview(true);
 80486:     SetIsPrintPreview(true);
 71056:     nsCOMPtr<nsIMarkupDocumentViewer> viewer =
  7740:       do_QueryInterface(mDocViewerPrint);
  7740:     if (viewer) {
  7740:       viewer->SetTextZoom(1.0f);
  7740:       viewer->SetFullZoom(1.0f);
 63383:       viewer->SetMinFontSize(0);
  7740:     }
     1:   }
     1: 
     1:   // Create a print session and let the print settings know about it.
     1:   // The print settings hold an nsWeakPtr to the session so it does not
     1:   // need to be cleared from the settings at the end of the job.
     1:   // XXX What lifetime does the printSession need to have?
     1:   nsCOMPtr<nsIPrintSession> printSession;
     1:   if (!aIsPrintPreview) {
     1:     printSession = do_CreateInstance("@mozilla.org/gfx/printsession;1", &rv);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     mPrt->mPrintSettings->SetPrintSession(printSession);
     1:   }
     1: 
106838:   if (aWebProgressListener != nullptr) {
     1:     mPrt->mPrintProgressListeners.AppendObject(aWebProgressListener);
     1:   }
     1: 
     1:   // Get the currently focused window and cache it
     1:   // because the Print Dialog will "steal" focus and later when you try
     1:   // to get the currently focused windows it will be NULL
     1:   mPrt->mCurrentFocusWin = FindFocusedDOMWindow();
     1: 
     1:   // Check to see if there is a "regular" selection
 79445:   bool isSelection = IsThereARangeSelection(mPrt->mCurrentFocusWin);
     1: 
     1:   // Get the docshell for this documentviewer
 69583:   nsCOMPtr<nsIDocShell> webContainer(do_QueryReferent(mContainer, &rv));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   mPrt->mPrintObject = new nsPrintObject();
     1:   NS_ENSURE_TRUE(mPrt->mPrintObject, NS_ERROR_OUT_OF_MEMORY);
 35581:   rv = mPrt->mPrintObject->Init(webContainer, aDoc, aIsPrintPreview);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 24551:   NS_ENSURE_TRUE(mPrt->mPrintDocList.AppendElement(mPrt->mPrintObject),
     1:                  NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:   mPrt->mIsParentAFrameSet = IsParentAFrameSet(webContainer);
     1:   mPrt->mPrintObject->mFrameType = mPrt->mIsParentAFrameSet ? eFrameSet : eDoc;
     1: 
     1:   // Build the "tree" of PrintObjects
 35581:   nsCOMPtr<nsIDocShellTreeNode> parentAsNode =
 35581:     do_QueryInterface(mPrt->mPrintObject->mDocShell);
 24551:   BuildDocTree(parentAsNode, &mPrt->mPrintDocList, mPrt->mPrintObject);
     1: 
 63708:   if (!aIsPrintPreview) {
 80486:     SetIsPrinting(true);
 63708:   }
 63708: 
     1:   // XXX This isn't really correct...
 35581:   if (!mPrt->mPrintObject->mDocument ||
 41634:       !mPrt->mPrintObject->mDocument->GetRootElement())
     1:     return NS_ERROR_GFX_PRINTER_STARTDOC;
     1: 
     1:   // Create the linkage from the sub-docs back to the content element
     1:   // in the parent document
     1:   MapContentToWebShells(mPrt->mPrintObject, mPrt->mPrintObject);
     1: 
     1:   mPrt->mIsIFrameSelected = IsThereAnIFrameSelected(webContainer, mPrt->mCurrentFocusWin, mPrt->mIsParentAFrameSet);
     1: 
     1:   // Setup print options for UI
     1:   if (mPrt->mIsParentAFrameSet) {
     1:     if (mPrt->mCurrentFocusWin) {
     1:       mPrt->mPrintSettings->SetHowToEnableFrameUI(nsIPrintSettings::kFrameEnableAll);
     1:     } else {
     1:       mPrt->mPrintSettings->SetHowToEnableFrameUI(nsIPrintSettings::kFrameEnableAsIsAndEach);
     1:     }
     1:   } else {
     1:     mPrt->mPrintSettings->SetHowToEnableFrameUI(nsIPrintSettings::kFrameEnableNone);
     1:   }
     1:   // Now determine how to set up the Frame print UI
     1:   mPrt->mPrintSettings->SetPrintOptions(nsIPrintSettings::kEnableSelectionRB, isSelection || mPrt->mIsIFrameSelected);
     1: 
     1:   nsCOMPtr<nsIDeviceContextSpec> devspec
     1:     (do_CreateInstance("@mozilla.org/gfx/devicecontextspec;1", &rv));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 25991:   nsScriptSuppressor scriptSuppressor(this);
     1:   if (!aIsPrintPreview) {
102909: #ifdef DEBUG
     1:     mPrt->mDebugFilePtr = mDebugFile;
     1: #endif
     1: 
 25991:     scriptSuppressor.Suppress();
 79445:     bool printSilently;
     1:     mPrt->mPrintSettings->GetPrintSilent(&printSilently);
     1: 
     1:     // Check prefs for a default setting as to whether we should print silently
 70840:     printSilently =
 70840:       Preferences::GetBool("print.always_print_silent", printSilently);
     1: 
     1:     // Ask dialog to be Print Shown via the Plugable Printing Dialog Service
     1:     // This service is for the Print Dialog and the Print Progress Dialog
     1:     // If printing silently or you can't get the service continue on
     1:     if (!printSilently) {
     1:       nsCOMPtr<nsIPrintingPromptService> printPromptService(do_GetService(kPrintingPromptService));
     1:       if (printPromptService) {
     1:         nsIDOMWindow *domWin = mDocument->GetWindow(); 
     1:         NS_ENSURE_TRUE(domWin, NS_ERROR_FAILURE);
     1: 
     1:         // Platforms not implementing a given dialog for the service may
     1:         // return NS_ERROR_NOT_IMPLEMENTED or an error code.
     1:         //
     1:         // NS_ERROR_NOT_IMPLEMENTED indicates they want default behavior
     1:         // Any other error code means we must bail out
     1:         //
     1:         nsCOMPtr<nsIWebBrowserPrint> wbp(do_QueryInterface(mDocViewerPrint));
     1:         rv = printPromptService->ShowPrintDialog(domWin, wbp,
     1:                                                  mPrt->mPrintSettings);
 58621:         //
 58621:         // ShowPrintDialog triggers an event loop which means we can't assume
 58621:         // that the state of this->{anything} matches the state we've checked
 58621:         // above. Including that a given {thing} is non null.
 58621: 
 58621:         if (NS_SUCCEEDED(rv)) {
 58621:           // since we got the dialog and it worked then make sure we 
 58621:           // are telling GFX we want to print silent
 80486:           printSilently = true;
 58621: 
 58621:           if (mPrt && mPrt->mPrintSettings) {
 58621:             // The user might have changed shrink-to-fit in the print dialog, so update our copy of its state
 58621:             mPrt->mPrintSettings->GetShrinkToFit(&mPrt->mShrinkToFit);
 58621:           }
 58621:         } else if (rv == NS_ERROR_NOT_IMPLEMENTED) {
     1:           // This means the Dialog service was there,
     1:           // but they choose not to implement this dialog and
     1:           // are looking for default behavior from the toolkit
     1:           rv = NS_OK;
 58621:         }
     1:       } else {
     1:         rv = NS_ERROR_GFX_NO_PRINTROMPTSERVICE;
     1:       }
 10489:     } else {
 10489:       // Call any code that requires a run of the event loop.
 10489:       rv = mPrt->mPrintSettings->SetupSilentPrinting();
     1:     }
     1:     // Check explicitly for abort because it's expected
     1:     if (rv == NS_ERROR_ABORT) 
     1:       return rv;
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
106838:   rv = devspec->Init(nullptr, mPrt->mPrintSettings, aIsPrintPreview);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 68667:   mPrt->mPrintDC = new nsDeviceContext();
     1:   rv = mPrt->mPrintDC->InitForPrinting(devspec);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (aIsPrintPreview) {
     1:     mPrt->mPrintSettings->SetPrintFrameType(nsIPrintSettings::kFramesAsIs);
     1: 
     1:     // override any UI that wants to PrintPreview any selection or page range
     1:     // we want to view every page in PrintPreview each time
     1:     mPrt->mPrintSettings->SetPrintRange(nsIPrintSettings::kRangeAllPages);
     1:   } else {
     1:     // Always check and set the print settings first and then fall back
     1:     // onto the PrintService if there isn't a PrintSettings
     1:     //
     1:     // Posiible Usage values:
     1:     //   nsIPrintSettings::kUseInternalDefault
     1:     //   nsIPrintSettings::kUseSettingWhenPossible
     1:     //
     1:     // NOTE: The consts are the same for PrintSettings and PrintSettings
108991:     int16_t printFrameTypeUsage = nsIPrintSettings::kUseSettingWhenPossible;
     1:     mPrt->mPrintSettings->GetPrintFrameTypeUsage(&printFrameTypeUsage);
     1: 
     1:     // Ok, see if we are going to use our value and override the default
     1:     if (printFrameTypeUsage == nsIPrintSettings::kUseSettingWhenPossible) {
     1:       // Get the Print Options/Settings PrintFrameType to see what is preferred
108991:       int16_t printFrameType = nsIPrintSettings::kEachFrameSep;
     1:       mPrt->mPrintSettings->GetPrintFrameType(&printFrameType);
     1: 
     1:       // Don't let anybody do something stupid like try to set it to
     1:       // kNoFrames when we are printing a FrameSet
     1:       if (printFrameType == nsIPrintSettings::kNoFrames) {
     1:         mPrt->mPrintFrameType = nsIPrintSettings::kEachFrameSep;
     1:         mPrt->mPrintSettings->SetPrintFrameType(mPrt->mPrintFrameType);
     1:       } else {
     1:         // First find out from the PrinService what options are available
     1:         // to us for Printing FrameSets
108991:         int16_t howToEnableFrameUI;
     1:         mPrt->mPrintSettings->GetHowToEnableFrameUI(&howToEnableFrameUI);
     1:         if (howToEnableFrameUI != nsIPrintSettings::kFrameEnableNone) {
     1:           switch (howToEnableFrameUI) {
     1:           case nsIPrintSettings::kFrameEnableAll:
     1:             mPrt->mPrintFrameType = printFrameType;
     1:             break;
     1: 
     1:           case nsIPrintSettings::kFrameEnableAsIsAndEach:
     1:             if (printFrameType != nsIPrintSettings::kSelectedFrame) {
     1:               mPrt->mPrintFrameType = printFrameType;
     1:             } else { // revert back to a good value
     1:               mPrt->mPrintFrameType = nsIPrintSettings::kEachFrameSep;
     1:             }
     1:             break;
     1:           } // switch
     1:           mPrt->mPrintSettings->SetPrintFrameType(mPrt->mPrintFrameType);
     1:         }
     1:       }
     1:     } else {
     1:       mPrt->mPrintSettings->GetPrintFrameType(&mPrt->mPrintFrameType);
     1:     }
     1:   }
     1: 
114469:   if (mPrt->mPrintFrameType == nsIPrintSettings::kEachFrameSep) {
114469:     CheckForChildFrameSets(mPrt->mPrintObject);
114469:   }
114469: 
114469:   if (NS_FAILED(EnablePOsForPrinting())) {
114469:     return NS_ERROR_FAILURE;
114469:   }
114469: 
114469:   // Attach progressListener to catch network requests.
114469:   nsCOMPtr<nsIWebProgress> webProgress = do_QueryInterface(mPrt->mPrintObject->mDocShell);
114469:   webProgress->AddProgressListener(
114469:     static_cast<nsIWebProgressListener*>(this),
114469:     nsIWebProgress::NOTIFY_STATE_REQUEST);
114469: 
114469:   mLoadCounter = 0;
114469:   mDidLoadDataForPrinting = false;
114469: 
     1:   if (aIsPrintPreview) {
 79445:     bool notifyOnInit = false;
 80486:     ShowPrintProgress(false, notifyOnInit);
     1: 
     1:     // Very important! Turn Off scripting
 80486:     TurnScriptingOn(false);
     1: 
     1:     if (!notifyOnInit) {
114469:       InstallPrintPreviewListener();
114469:       rv = InitPrintDocConstruction(false);
     1:     } else {
     1:       rv = NS_OK;
     1:     }
     1:   } else {
 79445:     bool doNotify;
 80486:     ShowPrintProgress(true, doNotify);
     1:     if (!doNotify) {
     1:       // Print listener setup...
     1:       mPrt->OnStartPrinting();
114469: 
114469:       rv = InitPrintDocConstruction(false);
     1:     }
     1:   }
     1: 
 25991:   // We will enable scripting later after printing has finished.
 25991:   scriptSuppressor.Disconnect();
 25991: 
     1:   return NS_OK;
     1: }
     1: 
     1: //---------------------------------------------------------------------------------
     1: NS_IMETHODIMP
     1: nsPrintEngine::Print(nsIPrintSettings*       aPrintSettings,
     1:                      nsIWebProgressListener* aWebProgressListener)
     1: {
 37276:   // If we have a print preview document, use that instead of the original
 37276:   // mDocument. That way animated images etc. get printed using the same state
 37276:   // as in print preview.
 37276:   nsCOMPtr<nsIDOMDocument> doc =
 37276:     do_QueryInterface(mPrtPreview && mPrtPreview->mPrintObject ?
 37276:                         mPrtPreview->mPrintObject->mDocument : mDocument);
 37276: 
 80486:   return CommonPrint(false, aPrintSettings, aWebProgressListener, doc);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsPrintEngine::PrintPreview(nsIPrintSettings* aPrintSettings, 
     1:                                  nsIDOMWindow *aChildDOMWin, 
     1:                                  nsIWebProgressListener* aWebProgressListener)
     1: {
 13031:   // Get the DocShell and see if it is busy
 13031:   // (We can't Print Preview this document if it is still busy)
 69583:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
 69583:   NS_ENSURE_STATE(docShell);
 13031: 
108991:   uint32_t busyFlags = nsIDocShell::BUSY_FLAGS_NONE;
 13031:   if (NS_FAILED(docShell->GetBusyFlags(&busyFlags)) ||
 13031:       busyFlags != nsIDocShell::BUSY_FLAGS_NONE) {
 13031:     CloseProgressDialog(aWebProgressListener);
 80486:     ShowPrintErrorDialog(NS_ERROR_GFX_PRINTER_DOC_IS_BUSY_PP, false);
 13031:     return NS_ERROR_FAILURE;
 13031:   }
 13031: 
 35581:   NS_ENSURE_STATE(aChildDOMWin);
 35581:   nsCOMPtr<nsIDOMDocument> doc;
 35581:   aChildDOMWin->GetDocument(getter_AddRefs(doc));
 35581:   NS_ENSURE_STATE(doc);
 35581: 
 13031:   // Document is not busy -- go ahead with the Print Preview
 80486:   return CommonPrint(true, aPrintSettings, aWebProgressListener, doc);
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: /* readonly attribute boolean isFramesetDocument; */
     1: NS_IMETHODIMP
 79445: nsPrintEngine::GetIsFramesetDocument(bool *aIsFramesetDocument)
     1: {
 69583:   nsCOMPtr<nsIDocShell> webContainer(do_QueryReferent(mContainer));
     1:   *aIsFramesetDocument = IsParentAFrameSet(webContainer);
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: /* readonly attribute boolean isIFrameSelected; */
     1: NS_IMETHODIMP 
 79445: nsPrintEngine::GetIsIFrameSelected(bool *aIsIFrameSelected)
     1: {
 80486:   *aIsIFrameSelected = false;
     1: 
     1:   // Get the docshell for this documentviewer
 69583:   nsCOMPtr<nsIDocShell> webContainer(do_QueryReferent(mContainer));
     1:   // Get the currently focused window
     1:   nsCOMPtr<nsIDOMWindow> currentFocusWin = FindFocusedDOMWindow();
     1:   if (currentFocusWin && webContainer) {
     1:     // Get whether the doc contains a frameset 
     1:     // Also, check to see if the currently focus docshell
     1:     // is a child of this docshell
 79445:     bool isParentFrameSet;
     1:     *aIsIFrameSelected = IsThereAnIFrameSelected(webContainer, currentFocusWin, isParentFrameSet);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: /* readonly attribute boolean isRangeSelection; */
     1: NS_IMETHODIMP 
 79445: nsPrintEngine::GetIsRangeSelection(bool *aIsRangeSelection)
     1: {
     1:   // Get the currently focused window 
     1:   nsCOMPtr<nsIDOMWindow> currentFocusWin = FindFocusedDOMWindow();
     1:   *aIsRangeSelection = IsThereARangeSelection(currentFocusWin);
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: /* readonly attribute boolean isFramesetFrameSelected; */
     1: NS_IMETHODIMP 
 79445: nsPrintEngine::GetIsFramesetFrameSelected(bool *aIsFramesetFrameSelected)
     1: {
     1:   // Get the currently focused window 
     1:   nsCOMPtr<nsIDOMWindow> currentFocusWin = FindFocusedDOMWindow();
106838:   *aIsFramesetFrameSelected = currentFocusWin != nullptr;
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: /* readonly attribute long printPreviewNumPages; */
     1: NS_IMETHODIMP
108991: nsPrintEngine::GetPrintPreviewNumPages(int32_t *aPrintPreviewNumPages)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPrintPreviewNumPages);
     1: 
114469:   nsPrintData* prt = nullptr;
106838:   nsIFrame* seqFrame  = nullptr;
     1:   *aPrintPreviewNumPages = 0;
114469: 
114469:   // When calling this function, the FinishPrintPreview() function might not
114469:   // been called as there are still some 
114469:   if (mPrtPreview) {
114469:     prt = mPrtPreview;
114469:   } else {
114469:     prt = mPrt;
114469:   }
114469:   if ((!prt) ||
114469:       NS_FAILED(GetSeqFrameAndCountPagesInternal(prt->mPrintObject, seqFrame, *aPrintPreviewNumPages))) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: // Enumerate all the documents for their titles
     1: NS_IMETHODIMP
108991: nsPrintEngine::EnumerateDocumentNames(uint32_t* aCount,
     1:                                       PRUnichar*** aResult)
     1: {
     1:   NS_ENSURE_ARG(aCount);
     1:   NS_ENSURE_ARG_POINTER(aResult);
     1: 
     1:   *aCount = 0;
106838:   *aResult = nullptr;
     1: 
108991:   int32_t     numDocs = mPrt->mPrintDocList.Length();
     1:   PRUnichar** array   = (PRUnichar**) nsMemory::Alloc(numDocs * sizeof(PRUnichar*));
     1:   if (!array)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
108991:   for (int32_t i=0;i<numDocs;i++) {
 24551:     nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
     1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
     1:     PRUnichar * docTitleStr;
     1:     PRUnichar * docURLStr;
     1:     GetDocumentTitleAndURL(po->mDocument, &docTitleStr, &docURLStr);
     1: 
     1:     // Use the URL if the doc is empty
     1:     if (!docTitleStr || !*docTitleStr) {
     1:       if (docURLStr && *docURLStr) {
     1:         nsMemory::Free(docTitleStr);
     1:         docTitleStr = docURLStr;
     1:       } else {
     1:         nsMemory::Free(docURLStr);
     1:       }
106838:       docURLStr = nullptr;
     1:       if (!docTitleStr || !*docTitleStr) {
     1:         CleanupDocTitleArray(array, i);
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:       }
     1:     }
     1:     array[i] = docTitleStr;
     1:     if (docURLStr) nsMemory::Free(docURLStr);
     1:   }
     1:   *aCount  = numDocs;
     1:   *aResult = array;
     1: 
     1:   return NS_OK;
     1: 
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: /* readonly attribute nsIPrintSettings globalPrintSettings; */
     1: nsresult
     1: nsPrintEngine::GetGlobalPrintSettings(nsIPrintSettings **aGlobalPrintSettings)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aGlobalPrintSettings);
     1: 
     1:   nsresult rv = NS_ERROR_FAILURE;
     1:   nsCOMPtr<nsIPrintSettingsService> printSettingsService =
     1:     do_GetService(sPrintSettingsServiceContractID, &rv);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     rv = printSettingsService->GetGlobalPrintSettings(aGlobalPrintSettings);
     1:   }
     1:   return rv;
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: /* readonly attribute boolean doingPrint; */
     1: NS_IMETHODIMP
 79445: nsPrintEngine::GetDoingPrint(bool *aDoingPrint)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aDoingPrint);
     1:   *aDoingPrint = mIsDoingPrinting;
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: /* readonly attribute boolean doingPrintPreview; */
     1: NS_IMETHODIMP
 79445: nsPrintEngine::GetDoingPrintPreview(bool *aDoingPrintPreview)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aDoingPrintPreview);
     1:   *aDoingPrintPreview = mIsDoingPrintPreview;
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: /* readonly attribute nsIPrintSettings currentPrintSettings; */
     1: NS_IMETHODIMP
     1: nsPrintEngine::GetCurrentPrintSettings(nsIPrintSettings * *aCurrentPrintSettings)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aCurrentPrintSettings);
     1: 
     1:   if (mPrt) {
     1:     *aCurrentPrintSettings = mPrt->mPrintSettings;
     1: 
     1:   } else if (mPrtPreview) {
     1:     *aCurrentPrintSettings = mPrtPreview->mPrintSettings;
     1: 
     1:   } else {
106838:     *aCurrentPrintSettings = nullptr;
     1:   }
     1:   NS_IF_ADDREF(*aCurrentPrintSettings);
     1:   return NS_OK;
     1: }
     1: 
     1: //-----------------------------------------------------------------
     1: //-- Section: Pre-Reflow Methods
     1: //-----------------------------------------------------------------
     1: 
     1: //---------------------------------------------------------------------
     1: // This method checks to see if there is at least one printer defined
     1: // and if so, it sets the first printer in the list as the default name
     1: // in the PrintSettings which is then used for Printer Preview
     1: nsresult
  1155: nsPrintEngine::CheckForPrinters(nsIPrintSettings* aPrintSettings)
     1: {
 57613: #if defined(XP_MACOSX) || defined(ANDROID)
  1155:   // Mac doesn't support retrieving a printer list.
  1155:   return NS_OK;
  1155: #else
     1:   NS_ENSURE_ARG_POINTER(aPrintSettings);
     1: 
  1155:   // See if aPrintSettings already has a printer
  1155:   nsXPIDLString printerName;
  1155:   nsresult rv = aPrintSettings->GetPrinterName(getter_Copies(printerName));
  1155:   if (NS_SUCCEEDED(rv) && !printerName.IsEmpty()) {
  1155:     return NS_OK;
  1155:   }
  1155: 
  1155:   // aPrintSettings doesn't have a printer set. Try to fetch the default.
  1155:   nsCOMPtr<nsIPrintSettingsService> printSettingsService =
  1155:     do_GetService(sPrintSettingsServiceContractID, &rv);
  1155:   NS_ENSURE_SUCCESS(rv, rv);
  1155: 
  1155:   rv = printSettingsService->GetDefaultPrinterName(getter_Copies(printerName));
  1155:   if (NS_SUCCEEDED(rv) && !printerName.IsEmpty()) {
  1155:     rv = aPrintSettings->SetPrinterName(printerName.get());
  1155:   }
  1155:   return rv;
     1: #endif
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // Set up to use the "pluggable" Print Progress Dialog
     1: void
 79445: nsPrintEngine::ShowPrintProgress(bool aIsForPrinting, bool& aDoNotify)
     1: {
     1:   // default to not notifying, that if something here goes wrong
     1:   // or we aren't going to show the progress dialog we can straight into 
     1:   // reflowing the doc for printing.
 80486:   aDoNotify = false;
     1: 
     1:   // Assume we can't do progress and then see if we can
 79445:   bool showProgresssDialog = false;
     1: 
     1:   // if it is already being shown then don't bother to find out if it should be
     1:   // so skip this and leave mShowProgressDialog set to FALSE
     1:   if (!mProgressDialogIsShown) {
 70840:     showProgresssDialog = Preferences::GetBool("print.show_print_progress");
     1:   }
     1: 
     1:   // Turning off the showing of Print Progress in Prefs overrides
     1:   // whether the calling PS desire to have it on or off, so only check PS if 
     1:   // prefs says it's ok to be on.
     1:   if (showProgresssDialog) {
     1:     mPrt->mPrintSettings->GetShowPrintProgress(&showProgresssDialog);
     1:   }
     1: 
     1:   // Now open the service to get the progress dialog
     1:   // If we don't get a service, that's ok, then just don't show progress
     1:   if (showProgresssDialog) {
     1:     nsCOMPtr<nsIPrintingPromptService> printPromptService(do_GetService(kPrintingPromptService));
     1:     if (printPromptService) {
     1:       nsPIDOMWindow *domWin = mDocument->GetWindow(); 
     1:       if (!domWin) return;
     1: 
  7849:       nsCOMPtr<nsIDocShellTreeItem> docShellItem =
  7849:         do_QueryInterface(domWin->GetDocShell());
  7849:       if (!docShellItem) return;
  7849:       nsCOMPtr<nsIDocShellTreeOwner> owner;
  7849:       docShellItem->GetTreeOwner(getter_AddRefs(owner));
  7849:       nsCOMPtr<nsIWebBrowserChrome> browserChrome = do_GetInterface(owner);
  7849:       if (!browserChrome) return;
 79445:       bool isModal = true;
  7849:       browserChrome->IsWindowModal(&isModal);
  7849:       if (isModal) {
  7849:         // Showing a print progress dialog when printing a modal window
  7849:         // isn't supported. See bug 301560.
  7849:         return;
  7849:       }
  7849: 
     1:       nsCOMPtr<nsIWebProgressListener> printProgressListener;
     1: 
     1:       nsCOMPtr<nsIWebBrowserPrint> wbp(do_QueryInterface(mDocViewerPrint));
     1:       nsresult rv = printPromptService->ShowProgress(domWin, wbp, mPrt->mPrintSettings, this, aIsForPrinting,
     1:                                                      getter_AddRefs(printProgressListener), 
     1:                                                      getter_AddRefs(mPrt->mPrintProgressParams), 
     1:                                                      &aDoNotify);
     1:       if (NS_SUCCEEDED(rv)) {
     1:         if (printProgressListener && mPrt->mPrintProgressParams) {
     1:           mPrt->mPrintProgressListeners.AppendObject(printProgressListener);
     1:           SetDocAndURLIntoProgress(mPrt->mPrintObject, mPrt->mPrintProgressParams);
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: //---------------------------------------------------------------------
 79445: bool
     1: nsPrintEngine::IsThereARangeSelection(nsIDOMWindow* aDOMWin)
     1: {
     1:   nsCOMPtr<nsIPresShell> presShell;
     1:   if (aDOMWin) {
     1:     nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aDOMWin));
127381:     presShell = window->GetDocShell()->GetPresShell();
     1:   }
     1: 
     1:   if (!presShell)
 80486:     return false;
     1: 
     1:   // check here to see if there is a range selection
     1:   // so we know whether to turn on the "Selection" radio button
     1:   nsCOMPtr<nsISelection> selection;
     1:   selection = presShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
     1:   if (selection) {
108991:     int32_t count;
     1:     selection->GetRangeCount(&count);
     1:     if (count == 1) {
     1:       nsCOMPtr<nsIDOMRange> range;
     1:       if (NS_SUCCEEDED(selection->GetRangeAt(0, getter_AddRefs(range)))) {
     1:         // check to make sure it isn't an insertion selection
 79445:         bool isCollapsed;
     1:         selection->GetIsCollapsed(&isCollapsed);
     1:         return !isCollapsed;
     1:       }
     1:     }
 80486:     if (count > 1) return true;
 80486:   }
 80486:   return false;
     1: }
     1: 
     1: //---------------------------------------------------------------------
 79445: bool
     1: nsPrintEngine::IsParentAFrameSet(nsIDocShell * aParent)
     1: {
     1:   // See if the incoming doc is the root document
     1:   nsCOMPtr<nsIDocShellTreeItem> parentAsItem(do_QueryInterface(aParent));
 80486:   if (!parentAsItem) return false;
     1: 
     1:   // When it is the top level document we need to check
     1:   // to see if it contains a frameset. If it does, then
     1:   // we only want to print the doc's children and not the document itself
     1:   // For anything else we always print all the children and the document
     1:   // for example, if the doc contains an IFRAME we eant to print the child
     1:   // document (the IFRAME) and then the rest of the document.
     1:   //
     1:   // XXX we really need to search the frame tree, and not the content
     1:   // but there is no way to distinguish between IFRAMEs and FRAMEs
     1:   // with the GetFrameType call.
     1:   // Bug 53459 has been files so we can eventually distinguish
     1:   // between IFRAME frames and FRAME frames
 79445:   bool isFrameSet = false;
     1:   // only check to see if there is a frameset if there is
     1:   // NO parent doc for this doc. meaning this parent is the root doc
 35581:   nsCOMPtr<nsIDOMDocument> domDoc = do_GetInterface(aParent);
 35581:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
     1:   if (doc) {
 41634:     nsIContent *rootElement = doc->GetRootElement();
 41634:     if (rootElement) {
 41634:       isFrameSet = HasFramesetChild(rootElement);
     1:     }
     1:   }
     1:   return isFrameSet;
     1: }
     1: 
     1: 
     1: //---------------------------------------------------------------------
     1: // Recursively build a list of sub documents to be printed
     1: // that mirrors the document tree
     1: void
     1: nsPrintEngine::BuildDocTree(nsIDocShellTreeNode *      aParentNode,
 24551:                             nsTArray<nsPrintObject*> * aDocList,
     1:                             nsPrintObject *            aPO)
     1: {
     1:   NS_ASSERTION(aParentNode, "Pointer is null!");
     1:   NS_ASSERTION(aDocList, "Pointer is null!");
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1: 
108991:   int32_t childWebshellCount;
     1:   aParentNode->GetChildCount(&childWebshellCount);
     1:   if (childWebshellCount > 0) {
108991:     for (int32_t i=0;i<childWebshellCount;i++) {
     1:       nsCOMPtr<nsIDocShellTreeItem> child;
     1:       aParentNode->GetChildAt(i, getter_AddRefs(child));
     1:       nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
     1: 
     1:       nsCOMPtr<nsIContentViewer>  viewer;
     1:       childAsShell->GetContentViewer(getter_AddRefs(viewer));
     1:       if (viewer) {
     1:         nsCOMPtr<nsIContentViewerFile> viewerFile(do_QueryInterface(viewer));
     1:         if (viewerFile) {
     1:           nsCOMPtr<nsIDocShell> childDocShell(do_QueryInterface(child));
     1:           nsCOMPtr<nsIDocShellTreeNode> childNode(do_QueryInterface(child));
 35581:           nsCOMPtr<nsIDOMDocument> doc = do_GetInterface(childDocShell);
     1:           nsPrintObject * po = new nsPrintObject();
 35581:           po->mParent = aPO;
 35581:           nsresult rv = po->Init(childDocShell, doc, aPO->mPrintPreview);
     1:           if (NS_FAILED(rv))
     1:             NS_NOTREACHED("Init failed?");
     1:           aPO->mKids.AppendElement(po);
     1:           aDocList->AppendElement(po);
     1:           BuildDocTree(childNode, aDocList, po);
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: void
     1: nsPrintEngine::GetDocumentTitleAndURL(nsIDocument* aDoc,
     1:                                       PRUnichar**  aTitle,
     1:                                       PRUnichar**  aURLStr)
     1: {
     1:   NS_ASSERTION(aDoc,      "Pointer is null!");
     1:   NS_ASSERTION(aTitle,    "Pointer is null!");
     1:   NS_ASSERTION(aURLStr,   "Pointer is null!");
     1: 
106838:   *aTitle  = nullptr;
106838:   *aURLStr = nullptr;
     1: 
 16977:   nsAutoString docTitle;
 70983:   nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(aDoc);
 16977:   doc->GetTitle(docTitle);
     1:   if (!docTitle.IsEmpty()) {
     1:     *aTitle = ToNewUnicode(docTitle);
     1:   }
     1: 
     1:   nsIURI* url = aDoc->GetDocumentURI();
     1:   if (!url) return;
     1: 
     1:   nsCOMPtr<nsIURIFixup> urifixup(do_GetService(NS_URIFIXUP_CONTRACTID));
     1:   if (!urifixup) return;
     1: 
     1:   nsCOMPtr<nsIURI> exposableURI;
     1:   urifixup->CreateExposableURI(url, getter_AddRefs(exposableURI));
     1: 
     1:   if (!exposableURI) return;
     1: 
110974:   nsAutoCString urlCStr;
     1:   exposableURI->GetSpec(urlCStr);
 36876: 
 36876:   nsresult rv;
 36876:   nsCOMPtr<nsITextToSubURI> textToSubURI = 
 36876:     do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
 36876:   if (NS_FAILED(rv)) return;
 36876: 
 36876:   nsAutoString unescapedURI;
 36876:   rv = textToSubURI->UnEscapeURIForUI(NS_LITERAL_CSTRING("UTF-8"),
 36876:                                       urlCStr, unescapedURI);
 36876:   if (NS_FAILED(rv)) return;
 36876: 
 36876:   *aURLStr = ToNewUnicode(unescapedURI);
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: // The walks the PO tree and for each document it walks the content
     1: // tree looking for any content that are sub-shells
     1: //
     1: // It then sets the mContent pointer in the "found" PO object back to the
     1: // the document that contained it.
     1: void
     1: nsPrintEngine::MapContentToWebShells(nsPrintObject* aRootPO,
     1:                                      nsPrintObject* aPO)
     1: {
     1:   NS_ASSERTION(aRootPO, "Pointer is null!");
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1: 
     1:   // Recursively walk the content from the root item
     1:   // XXX Would be faster to enumerate the subdocuments, although right now
     1:   //     nsIDocument doesn't expose quite what would be needed.
 35581:   nsCOMPtr<nsIContentViewer> viewer;
 35581:   aPO->mDocShell->GetContentViewer(getter_AddRefs(viewer));
 35581:   if (!viewer) return;
 35581: 
 35581:   nsCOMPtr<nsIDOMDocument> domDoc;
 35581:   viewer->GetDOMDocument(getter_AddRefs(domDoc));
 35581:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
 35581:   if (!doc) return;
 35581: 
 41634:   Element* rootElement = doc->GetRootElement();
 41634:   if (rootElement) {
 41634:     MapContentForPO(aPO, rootElement);
 19021:   } else {
 19021:     NS_WARNING("Null root content on (sub)document.");
 19021:   }
     1: 
     1:   // Continue recursively walking the chilren of this PO
108991:   for (uint32_t i=0;i<aPO->mKids.Length();i++) {
 24551:     MapContentToWebShells(aRootPO, aPO->mKids[i]);
     1:   }
     1: 
     1: }
     1: 
     1: //-------------------------------------------------------
     1: // A Frame's sub-doc may contain content or a FrameSet
     1: // When it contains a FrameSet the mFrameType for the PrintObject
     1: // is always set to an eFrame. Which is fine when printing "AsIs"
     1: // but is incorrect when when printing "Each Frame Separately".
     1: // When printing "Each Frame Separately" the Frame really acts like
     1: // a frameset.
     1: //
     1: // This method walks the PO tree and checks to see if the PrintObject is
     1: // an eFrame and has children that are eFrames (meaning it's a Frame containing a FrameSet)
     1: // If so, then the mFrameType need to be changed to eFrameSet
     1: //
     1: // Also note: We only want to call this we are printing "Each Frame Separately"
     1: //            when printing "As Is" leave it as an eFrame
     1: void
     1: nsPrintEngine::CheckForChildFrameSets(nsPrintObject* aPO)
     1: {
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1: 
     1:   // Continue recursively walking the chilren of this PO
 79445:   bool hasChildFrames = false;
108991:   for (uint32_t i=0;i<aPO->mKids.Length();i++) {
 24551:     nsPrintObject* po = aPO->mKids[i];
     1:     if (po->mFrameType == eFrame) {
 80486:       hasChildFrames = true;
     1:       CheckForChildFrameSets(po);
     1:     }
     1:   }
     1: 
     1:   if (hasChildFrames && aPO->mFrameType == eFrame) {
     1:     aPO->mFrameType = eFrameSet;
     1:   }
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: // This method is key to the entire print mechanism.
     1: //
     1: // This "maps" or figures out which sub-doc represents a
     1: // given Frame or IFrame in its parent sub-doc.
     1: //
     1: // So the Mcontent pointer in the child sub-doc points to the
     1: // content in the its parent document, that caused it to be printed.
     1: // This is used later to (after reflow) to find the absolute location
     1: // of the sub-doc on its parent's page frame so it can be
     1: // printed in the correct location.
     1: //
     1: // This method recursvely "walks" the content for a document finding
     1: // all the Frames and IFrames, then sets the "mFrameType" data member
     1: // which tells us what type of PO we have
     1: void
     1: nsPrintEngine::MapContentForPO(nsPrintObject*   aPO,
     1:                                nsIContent*      aContent)
     1: {
     1:   NS_PRECONDITION(aPO && aContent, "Null argument");
     1: 
     1:   nsIDocument* doc = aContent->GetDocument();
     1: 
     1:   NS_ASSERTION(doc, "Content without a document from a document tree?");
     1: 
     1:   nsIDocument* subDoc = doc->GetSubDocumentFor(aContent);
     1: 
     1:   if (subDoc) {
     1:     nsCOMPtr<nsISupports> container = subDoc->GetContainer();
     1:     nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(container));
     1: 
     1:     if (docShell) {
106838:       nsPrintObject * po = nullptr;
108991:       int32_t cnt = aPO->mKids.Length();
108991:       for (int32_t i=0;i<cnt;i++) {
 24551:         nsPrintObject* kid = aPO->mKids.ElementAt(i);
     1:         if (kid->mDocument == subDoc) {
     1:           po = kid;
     1:           break;
     1:         }
     1:       }
     1: 
     1:       // XXX If a subdocument has no onscreen presentation, there will be no PO
     1:       //     This is even if there should be a print presentation
     1:       if (po) {
     1: 
     1:         nsCOMPtr<nsIDOMHTMLFrameElement> frame(do_QueryInterface(aContent));
 11294:         // "frame" elements not in a frameset context should be treated
 11294:         // as iframes
 11294:         if (frame && po->mParent->mFrameType == eFrameSet) {
     1:           po->mFrameType = eFrame;
     1:         } else {
     1:           // Assume something iframe-like, i.e. iframe, object, or embed
     1:           po->mFrameType = eIFrame;
 80486:           SetPrintAsIs(po, true);
     1:           NS_ASSERTION(po->mParent, "The root must be a parent");
 80486:           po->mParent->mPrintAsIs = true;
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   // walk children content
 88030:   for (nsIContent* child = aContent->GetFirstChild();
 88030:        child;
 88030:        child = child->GetNextSibling()) {
     1:     MapContentForPO(aPO, child);
     1:   }
     1: }
     1: 
     1: //---------------------------------------------------------------------
 79445: bool
     1: nsPrintEngine::IsThereAnIFrameSelected(nsIDocShell* aDocShell,
     1:                                        nsIDOMWindow* aDOMWin,
 79445:                                        bool& aIsParentFrameSet)
     1: {
     1:   aIsParentFrameSet = IsParentAFrameSet(aDocShell);
 79445:   bool iFrameIsSelected = false;
     1:   if (mPrt && mPrt->mPrintObject) {
     1:     nsPrintObject* po = FindPrintObjectByDOMWin(mPrt->mPrintObject, aDOMWin);
     1:     iFrameIsSelected = po && po->mFrameType == eIFrame;
     1:   } else {
     1:     // First, check to see if we are a frameset
     1:     if (!aIsParentFrameSet) {
     1:       // Check to see if there is a currenlt focused frame
     1:       // if so, it means the selected frame is either the main docshell
     1:       // or an IFRAME
     1:       if (aDOMWin) {
     1:         // Get the main docshell's DOMWin to see if it matches 
     1:         // the frame that is selected
     1:         nsCOMPtr<nsIDOMWindow> domWin = do_GetInterface(aDocShell);
     1:         if (domWin != aDOMWin) {
 80486:           iFrameIsSelected = true; // we have a selected IFRAME
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   return iFrameIsSelected;
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: // Recursively sets all the PO items to be printed
     1: // from the given item down into the tree
     1: void
 79445: nsPrintEngine::SetPrintPO(nsPrintObject* aPO, bool aPrint)
     1: {
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1: 
     1:   // Set whether to print flag
     1:   aPO->mDontPrint = !aPrint;
     1: 
108991:   for (uint32_t i=0;i<aPO->mKids.Length();i++) {
 24551:     SetPrintPO(aPO->mKids[i], aPrint);
     1:   } 
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: // This will first use a Title and/or URL from the PrintSettings
     1: // if one isn't set then it uses the one from the document
     1: // then if not title is there we will make sure we send something back
     1: // depending on the situation.
     1: void
     1: nsPrintEngine::GetDisplayTitleAndURL(nsPrintObject*    aPO,
     1:                                      PRUnichar**       aTitle, 
     1:                                      PRUnichar**       aURLStr,
     1:                                      eDocTitleDefault  aDefType)
     1: {
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1:   NS_ASSERTION(aTitle, "Pointer is null!");
     1:   NS_ASSERTION(aURLStr, "Pointer is null!");
     1: 
106838:   *aTitle  = nullptr;
106838:   *aURLStr = nullptr;
     1: 
     1:   if (!mPrt)
     1:     return;
     1: 
     1:   // First check to see if the PrintSettings has defined an alternate title
     1:   // and use that if it did
106838:   PRUnichar * docTitleStrPS = nullptr;
106838:   PRUnichar * docURLStrPS   = nullptr;
     1:   if (mPrt->mPrintSettings) {
     1:     mPrt->mPrintSettings->GetTitle(&docTitleStrPS);
     1:     mPrt->mPrintSettings->GetDocURL(&docURLStrPS);
     1: 
     1:     if (docTitleStrPS && *docTitleStrPS) {
     1:       *aTitle  = docTitleStrPS;
     1:     }
     1: 
     1:     if (docURLStrPS && *docURLStrPS) {
     1:       *aURLStr  = docURLStrPS;
     1:     }
     1: 
     1:     // short circut
     1:     if (docTitleStrPS && docURLStrPS) {
     1:       return;
     1:     }
     1:   }
     1: 
     1:   PRUnichar* docTitle;
     1:   PRUnichar* docUrl;
     1:   GetDocumentTitleAndURL(aPO->mDocument, &docTitle, &docUrl);
     1: 
     1:   if (docUrl) {
     1:     if (!docURLStrPS)
     1:       *aURLStr = docUrl;
     1:     else
     1:       nsMemory::Free(docUrl);
     1:   }
     1: 
     1:   if (docTitle) {
     1:     if (!docTitleStrPS)
     1:       *aTitle = docTitle;
     1:     else
     1:       nsMemory::Free(docTitle);
     1:   } else if (!docTitleStrPS) {
     1:     switch (aDefType) {
     1:       case eDocTitleDefBlank: *aTitle = ToNewUnicode(EmptyString());
     1:         break;
     1: 
     1:       case eDocTitleDefURLDoc:
     1:         if (*aURLStr) {
     1:           *aTitle = NS_strdup(*aURLStr);
     1:         } else if (mPrt->mBrandName) {
     1:           *aTitle = NS_strdup(mPrt->mBrandName);
     1:         }
     1:         break;
 19300:       case eDocTitleDefNone:
106838:         // *aTitle defaults to nullptr
 19300:         break;
     1:     }
     1:   }
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: nsresult nsPrintEngine::DocumentReadyForPrinting()
     1: {
     1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kEachFrameSep) {
     1:     CheckForChildFrameSets(mPrt->mPrintObject);
     1:   }
     1: 
     1:   //
     1:   // Send the document to the printer...
     1:   //
     1:   nsresult rv = SetupToPrintContent();
     1:   if (NS_FAILED(rv)) {
     1:     // The print job was canceled or there was a problem
     1:     // So remove all other documents from the print list
106838:     DonePrintingPages(nullptr, rv);
     1:   }
     1:   return rv;
     1: }
     1: 
     1: /** ---------------------------------------------------
     1:  *  Cleans up when an error occurred
     1:  */
 79445: nsresult nsPrintEngine::CleanupOnFailure(nsresult aResult, bool aIsPrinting)
     1: {
     1:   PR_PL(("****  Failed %s - rv 0x%X", aIsPrinting?"Printing":"Print Preview", aResult));
     1: 
     1:   /* cleanup... */
     1:   if (mPagePrintTimer) {
     1:     mPagePrintTimer->Stop();
     1:     NS_RELEASE(mPagePrintTimer);
     1:   }
     1:   
     1:   if (aIsPrinting) {
 80486:     SetIsPrinting(false);
     1:   } else {
 80486:     SetIsPrintPreview(false);
 80486:     SetIsCreatingPrintPreview(false);
     1:   }
     1: 
     1:   /* cleanup done, let's fire-up an error dialog to notify the user
     1:    * what went wrong... 
     1:    * 
     1:    * When rv == NS_ERROR_ABORT, it means we want out of the 
     1:    * print job without displaying any error messages
     1:    */
     1:   if (aResult != NS_ERROR_ABORT) {
     1:     ShowPrintErrorDialog(aResult, aIsPrinting);
     1:   }
     1: 
     1:   FirePrintCompletionEvent();
     1: 
     1:   return aResult;
     1: 
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: void
 79445: nsPrintEngine::ShowPrintErrorDialog(nsresult aPrintError, bool aIsPrinting)
     1: {
     1: 
 79445:   PR_PL(("nsPrintEngine::ShowPrintErrorDialog(nsresult aPrintError=%lx, bool aIsPrinting=%d)\n", (long)aPrintError, (int)aIsPrinting));
     1: 
110974:   nsAutoCString stringName;
     1: 
     1:   switch(aPrintError)
     1:   {
     1: #define NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(nserr) case nserr: stringName.AssignLiteral(#nserr); break;
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_CMD_NOT_FOUND)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_CMD_FAILURE)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_ACCESS_DENIED)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_INVALID_ATTRIBUTE)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PRINTER_NOT_READY)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_OUT_OF_PAPER)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PRINTER_IO_ERROR)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_FILE_IO_ERROR)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PRINTPREVIEW)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_UNEXPECTED)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_OUT_OF_MEMORY)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_NOT_IMPLEMENTED)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_NOT_AVAILABLE)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_ABORT)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_STARTDOC)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_ENDDOC)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_STARTPAGE)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_ENDPAGE)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PRINT_WHILE_PREVIEW)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PAPER_SIZE_NOT_SUPPORTED)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_ORIENTATION_NOT_SUPPORTED)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_COLORSPACE_NOT_SUPPORTED)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_TOO_MANY_COPIES)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_DRIVER_CONFIGURATION_ERROR)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_DOC_IS_BUSY_PP)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_DOC_WAS_DESTORYED)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_NO_PRINTDIALOG_IN_TOOLKIT)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_NO_PRINTROMPTSERVICE)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_NO_XUL)   // Temporary code for Bug 136185 / bug 240490
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PLEX_NOT_SUPPORTED)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_DOC_IS_BUSY)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTING_NOT_IMPLEMENTED)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_COULD_NOT_LOAD_PRINT_MODULE)
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_RESOLUTION_NOT_SUPPORTED)
     1: 
     1:     default:
     1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_FAILURE)
     1: #undef NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG
     1:   }
     1: 
     1:   PR_PL(("ShowPrintErrorDialog:  stringName='%s'\n", stringName.get()));
     1: 
     1:   nsXPIDLString msg, title;
     1:   nsresult rv =
     1:     nsContentUtils::GetLocalizedString(nsContentUtils::ePRINTING_PROPERTIES,
     1:                                        stringName.get(), msg);
     1:   if (NS_FAILED(rv)) {
     1:     PR_PL(("GetLocalizedString failed\n"));
     1:     return;
     1:   }
     1: 
     1:   rv = nsContentUtils::GetLocalizedString(nsContentUtils::ePRINTING_PROPERTIES,
     1:       aIsPrinting ? "print_error_dialog_title"
     1:                   : "printpreview_error_dialog_title",
     1:       title);
     1: 
     1:   nsCOMPtr<nsIWindowWatcher> wwatch = do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
     1:   if (NS_FAILED(rv)) {
106838:     PR_PL(("ShowPrintErrorDialog(): wwatch==nullptr\n"));
     1:     return;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMWindow> active;
     1:   wwatch->GetActiveWindow(getter_AddRefs(active));
     1: 
     1:   nsCOMPtr<nsIPrompt> dialog;
106838:   /* |GetNewPrompter| allows that |active| is |nullptr| 
     1:    * (see bug 234982 ("nsPrintEngine::ShowPrintErrorDialog() fails in many cases")) */
     1:   wwatch->GetNewPrompter(active, getter_AddRefs(dialog));
     1:   if (!dialog) {
106838:     PR_PL(("ShowPrintErrorDialog(): dialog==nullptr\n"));
     1:     return;
     1:   }
     1: 
     1:   dialog->Alert(title.get(), msg.get());
     1:   PR_PL(("ShowPrintErrorDialog(): alert displayed successfully.\n"));
     1: }
     1: 
     1: //-----------------------------------------------------------------
     1: //-- Section: Reflow Methods
     1: //-----------------------------------------------------------------
     1: 
114469: nsresult
114469: nsPrintEngine::ReconstructAndReflow(bool doSetPixelScale)
114469: {
114469: #if (defined(XP_WIN) || defined(XP_OS2)) && defined(EXTENDED_DEBUG_PRINTING)
114469:   // We need to clear all the output files here
114469:   // because they will be re-created with second reflow of the docs
114469:   if (kPrintingLogMod && kPrintingLogMod->level == DUMP_LAYOUT_LEVEL) {
114469:     RemoveFilesInDir(".\\");
114469:     gDumpFileNameCnt   = 0;
114469:     gDumpLOFileNameCnt = 0;
114469:   }
114469: #endif
114469: 
114469:   for (uint32_t i = 0; i < mPrt->mPrintDocList.Length(); ++i) {
114469:     nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
114469:     NS_ASSERTION(po, "nsPrintObject can't be null!");
114469: 
114469:     if (po->mDontPrint || po->mInvisible) {
114469:       continue;
114469:     }
114469: 
114469:     UpdateZoomRatio(po, doSetPixelScale);
114469: 
114469:     po->mPresContext->SetPageScale(po->mZoomRatio);
114469: 
114469:     // Calculate scale factor from printer to screen
114469:     float printDPI = float(mPrt->mPrintDC->AppUnitsPerCSSInch()) /
114469:                      float(mPrt->mPrintDC->AppUnitsPerDevPixel());
114469:     po->mPresContext->SetPrintPreviewScale(mScreenDPI / printDPI);
114469: 
114469:     po->mPresShell->ReconstructFrames();
114469: 
114469:     // For all views except the first one, setup the root view.
114469:     // ??? Can there be multiple po for the top-level-document?
114469:     bool documentIsTopLevel = true;
114469:     if (i != 0) {
114469:       nsSize adjSize;
114469:       bool doReturn; 
114469:       nsresult rv = SetRootView(po, doReturn, documentIsTopLevel, adjSize);
114469: 
114469:       MOZ_ASSERT(!documentIsTopLevel, "How could this happen?");
114469:       
114469:       if (NS_FAILED(rv) || doReturn) {
114469:         return rv; 
114469:       }
114469:     }
114469: 
114469:     po->mPresShell->FlushPendingNotifications(Flush_Layout);
114469: 
114469:     nsresult rv = UpdateSelectionAndShrinkPrintObject(po, documentIsTopLevel);
114469:     NS_ENSURE_SUCCESS(rv, rv);
114469:   }
114469:   return NS_OK;
114469: }
114469: 
     1: //-------------------------------------------------------
     1: nsresult
     1: nsPrintEngine::SetupToPrintContent()
     1: {
114469:   nsresult rv;
114469: 
114469:   bool didReconstruction = false;
114469:   
114469:   // If some new content got loaded since the initial reflow rebuild
114469:   // everything.
114469:   if (mDidLoadDataForPrinting) {
114469:     rv = ReconstructAndReflow(DoSetPixelScale());
114469:     didReconstruction = true;
114469:     NS_ENSURE_SUCCESS(rv, rv);
114469:   }
114469: 
114469:   // Here is where we figure out if extra reflow for shrinking the content
114469:   // is required.
114469:   // But skip this step if we are in PrintPreview
114469:   bool ppIsShrinkToFit = mPrtPreview && mPrtPreview->mShrinkToFit;
114469:   if (mPrt->mShrinkToFit && !ppIsShrinkToFit) {
114469:     // Now look for the PO that has the smallest percent for shrink to fit
114469:     if (mPrt->mPrintDocList.Length() > 1 && mPrt->mPrintObject->mFrameType == eFrameSet) {
114469:       nsPrintObject* smallestPO = FindSmallestSTF();
114469:       NS_ASSERTION(smallestPO, "There must always be an XMost PO!");
114469:       if (smallestPO) {
114469:         // Calc the shrinkage based on the entire content area
114469:         mPrt->mShrinkRatio = smallestPO->mShrinkRatio;
114469:       }
114469:     } else {
114469:       // Single document so use the Shrink as calculated for the PO
114469:       mPrt->mShrinkRatio = mPrt->mPrintObject->mShrinkRatio;
114469:     }
114469: 
114469:     if (mPrt->mShrinkRatio < 0.998f) {
114469:       rv = ReconstructAndReflow(true);
114469:       didReconstruction = true;
114469:       NS_ENSURE_SUCCESS(rv, rv);
114469:     }
114469: 
114469: #ifdef PR_LOGGING
114469:     float calcRatio = 0.0f;
114469:     if (mPrt->mPrintDocList.Length() > 1 && mPrt->mPrintObject->mFrameType == eFrameSet) {
114469:       nsPrintObject* smallestPO = FindSmallestSTF();
114469:       NS_ASSERTION(smallestPO, "There must always be an XMost PO!");
114469:       if (smallestPO) {
114469:         // Calc the shrinkage based on the entire content area
114469:         calcRatio = smallestPO->mShrinkRatio;
114469:       }
114469:     } else {
114469:       // Single document so use the Shrink as calculated for the PO
114469:       calcRatio = mPrt->mPrintObject->mShrinkRatio;
114469:     }
114469:     PR_PL(("**************************************************************************\n"));
114469:     PR_PL(("STF Ratio is: %8.5f Effective Ratio: %8.5f Diff: %8.5f\n", mPrt->mShrinkRatio, calcRatio,  mPrt->mShrinkRatio-calcRatio));
114469:     PR_PL(("**************************************************************************\n"));
114469: #endif
114469:   }
114469:   
114469:   // If the frames got reconstructed and reflowed the number of pages might
114469:   // has changed.
114469:   if (didReconstruction) {
114469:     FirePrintPreviewUpdateEvent();
114469:   }
114469:   
114469:   DUMP_DOC_LIST(("\nAfter Reflow------------------------------------------"));
114469:   PR_PL(("\n"));
114469:   PR_PL(("-------------------------------------------------------\n"));
114469:   PR_PL(("\n"));
114469: 
114469:   CalcNumPrintablePages(mPrt->mNumPrintablePages);
114469: 
114469:   PR_PL(("--- Printing %d pages\n", mPrt->mNumPrintablePages));
114469:   DUMP_DOC_TREELAYOUT;
114469: 
114469:   // Print listener setup...
114469:   if (mPrt != nullptr) {
114469:     mPrt->OnStartPrinting();    
114469:   }
114469: 
114469:   PRUnichar* fileName = nullptr;
114469:   // check to see if we are printing to a file
114469:   bool isPrintToFile = false;
114469:   mPrt->mPrintSettings->GetPrintToFile(&isPrintToFile);
114469:   if (isPrintToFile) {
114469:   // On some platforms The BeginDocument needs to know the name of the file
114469:   // and it uses the PrintService to get it, so we need to set it into the PrintService here
114469:     mPrt->mPrintSettings->GetToFileName(&fileName);
114469:   }
114469: 
114469:   PRUnichar * docTitleStr;
114469:   PRUnichar * docURLStr;
114469:   GetDisplayTitleAndURL(mPrt->mPrintObject, &docTitleStr, &docURLStr, eDocTitleDefURLDoc); 
114469: 
114469:   int32_t startPage = 1;
114469:   int32_t endPage   = mPrt->mNumPrintablePages;
114469: 
114469:   int16_t printRangeType = nsIPrintSettings::kRangeAllPages;
114469:   mPrt->mPrintSettings->GetPrintRange(&printRangeType);
114469:   if (printRangeType == nsIPrintSettings::kRangeSpecifiedPageRange) {
114469:     mPrt->mPrintSettings->GetStartPageRange(&startPage);
114469:     mPrt->mPrintSettings->GetEndPageRange(&endPage);
114469:     if (endPage > mPrt->mNumPrintablePages) {
114469:       endPage = mPrt->mNumPrintablePages;
114469:     }
114469:   }
114469: 
114469:   rv = NS_OK;
114469:   // BeginDocument may pass back a FAILURE code
114469:   // i.e. On Windows, if you are printing to a file and hit "Cancel" 
114469:   //      to the "File Name" dialog, this comes back as an error
114469:   // Don't start printing when regression test are executed  
114469:   if (!mPrt->mDebugFilePtr && mIsDoingPrinting) {
114469:     rv = mPrt->mPrintDC->BeginDocument(docTitleStr, fileName, startPage, endPage);
114469:   } 
114469: 
114469:   if (mIsCreatingPrintPreview) {
114469:     // Print Preview -- Pass ownership of docTitleStr and docURLStr
114469:     // to the pageSequenceFrame, to be displayed in the header
114469:     nsIPageSequenceFrame *seqFrame = mPrt->mPrintObject->mPresShell->GetPageSequenceFrame();
114469:     if (seqFrame) {
114469:       seqFrame->StartPrint(mPrt->mPrintObject->mPresContext, 
114469:                            mPrt->mPrintSettings, docTitleStr, docURLStr);
114469:       docTitleStr = nullptr;
114469:       docURLStr = nullptr;
114469:     }
114469:   }
114469:   if (docTitleStr) nsMemory::Free(docTitleStr);
114469:   if (docURLStr) nsMemory::Free(docURLStr);
114469: 
114469:   PR_PL(("****************** Begin Document ************************\n"));
114469: 
114469:   NS_ENSURE_SUCCESS(rv, rv);
114469: 
114469:   // This will print the docshell document
114469:   // when it completes asynchronously in the DonePrintingPages method
114469:   // it will check to see if there are more docshells to be printed and
114469:   // then PrintDocContent will be called again.
114469: 
114469:   if (mIsDoingPrinting) {
114469:     PrintDocContent(mPrt->mPrintObject, rv); // ignore return value
114469:   }
114469: 
114469:   return rv;
114469: }
114469: 
114469: //-------------------------------------------------------
114469: // Recursively reflow each sub-doc and then calc
114469: // all the frame locations of the sub-docs
114469: nsresult
114469: nsPrintEngine::ReflowDocList(nsPrintObject* aPO, bool aSetPixelScale)
114469: {
114469:   NS_ENSURE_ARG_POINTER(aPO);
114469: 
114469:   // Check to see if the subdocument's element has been hidden by the parent document
114469:   if (aPO->mParent && aPO->mParent->mPresShell) {
114469:     nsIFrame* frame = aPO->mContent ? aPO->mContent->GetPrimaryFrame() : nullptr;
114469:     if (!frame || !frame->GetStyleVisibility()->IsVisible()) {
114715:       SetPrintPO(aPO, false);
114469:       aPO->mInvisible = true;
114469:       return NS_OK;
114469:     }
114469:   }
114469: 
114469:   UpdateZoomRatio(aPO, aSetPixelScale);
114469: 
114469:   nsresult rv;
114469:   // Reflow the PO
114469:   rv = ReflowPrintObject(aPO);
114469:   NS_ENSURE_SUCCESS(rv, rv);
114469: 
114469:   int32_t cnt = aPO->mKids.Length();
114469:   for (int32_t i=0;i<cnt;i++) {
114469:     rv = ReflowDocList(aPO->mKids[i], aSetPixelScale);
114469:     NS_ENSURE_SUCCESS(rv, rv);
114469:   }
114469:   return NS_OK;
114469: }
114469: 
114469: void
114469: nsPrintEngine::FirePrintPreviewUpdateEvent()
114469: {
114469:   // Dispatch the event only while in PrintPreview. When printing, there is no
114469:   // listener bound to this event and therefore no need to dispatch it.
114469:   if (mIsDoingPrintPreview && !mIsDoingPrinting) {
114469:     nsCOMPtr<nsIContentViewer> cv = do_QueryInterface(mDocViewerPrint);
114469:     (new nsAsyncDOMEvent(
114469:        cv->GetDocument(), NS_LITERAL_STRING("printPreviewUpdate"), true, true)
114469:     )->RunDOMEventWhenSafe();
114469:   }
114469: }
114469: 
114469: nsresult
114469: nsPrintEngine::InitPrintDocConstruction(bool aHandleError)
114469: {
114469:   nsresult rv;
114469:   rv = ReflowDocList(mPrt->mPrintObject, DoSetPixelScale());
114469:   NS_ENSURE_SUCCESS(rv, rv);
114469: 
114469:   FirePrintPreviewUpdateEvent();
114469: 
114469:   if (mLoadCounter == 0) {
114469:     AfterNetworkPrint(aHandleError);
114469:   }
114469:   return rv;
114469: }
114469: 
114469: nsresult
114469: nsPrintEngine::AfterNetworkPrint(bool aHandleError)
114469: {
114469:   nsCOMPtr<nsIWebProgress> webProgress = do_QueryInterface(mPrt->mPrintObject->mDocShell);
114469: 
114469:   webProgress->RemoveProgressListener(
114469:     static_cast<nsIWebProgressListener*>(this));
114469: 
114469:   nsresult rv;
114469:   if (mIsDoingPrinting) {
114469:     rv = DocumentReadyForPrinting();
114469:   } else {
114469:     rv = FinishPrintPreview();
114469:   }
114469: 
114469:   /* cleaup on failure + notify user */
114469:   if (aHandleError && NS_FAILED(rv)) {
114469:     CleanupOnFailure(rv, !mIsDoingPrinting);
114469:   }
114469: 
114469:   return rv;
114469: }
114469: 
114469: ////////////////////////////////////////////////////////////////////////////////
114469: // nsIWebProgressListener
114469: 
114469: NS_IMETHODIMP
114469: nsPrintEngine::OnStateChange(nsIWebProgress* aWebProgress,
114469:                              nsIRequest* aRequest,
114469:                              uint32_t aStateFlags,
114469:                              nsresult aStatus)
114469: {
114469:   nsAutoCString name;
114469:   aRequest->GetName(name);
114469:   if (name.Equals("about:document-onload-blocker")) {
114469:     return NS_OK;
114469:   }
114469:   if (aStateFlags & STATE_START) {
114469:     nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
114469: 
114469:     ++mLoadCounter;
114469:   } else if (aStateFlags & STATE_STOP) {
114469:     mDidLoadDataForPrinting = true;
114469:     --mLoadCounter;
114469:    
114469:     // If all resources are loaded, then do a small timeout and if there
114469:     // are still no new requests, then another reflow.
114469:     if (mLoadCounter == 0) {
114469:       AfterNetworkPrint(true);
114469:     }
114469:   }
114469:   return NS_OK;
114469: }
114469: 
114469: 
114469: 
114469: NS_IMETHODIMP
114469: nsPrintEngine::OnProgressChange(nsIWebProgress* aWebProgress,
114469:                                  nsIRequest* aRequest,
114469:                                  int32_t aCurSelfProgress,
114469:                                  int32_t aMaxSelfProgress,
114469:                                  int32_t aCurTotalProgress,
114469:                                  int32_t aMaxTotalProgress)
114469: {
114469:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
114469:   return NS_OK;
114469: }
114469: 
114469: NS_IMETHODIMP
114469: nsPrintEngine::OnLocationChange(nsIWebProgress* aWebProgress,
114469:                                 nsIRequest* aRequest,
114469:                                 nsIURI* aLocation,
114469:                                 uint32_t aFlags)
114469: {
114469:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
114469:   return NS_OK;
114469: }
114469: 
114469: NS_IMETHODIMP
114469: nsPrintEngine::OnStatusChange(nsIWebProgress *aWebProgress,
114469:                               nsIRequest *aRequest,
114469:                               nsresult aStatus,
114469:                               const PRUnichar *aMessage)
114469: {
114469:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
114469:   return NS_OK;
114469: }
114469: 
114469: NS_IMETHODIMP
114469: nsPrintEngine::OnSecurityChange(nsIWebProgress *aWebProgress,
114469:                                   nsIRequest *aRequest,
114469:                                   uint32_t aState)
114469: {
114469:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
114469:   return NS_OK;
114469: }
114469: 
114469: //-------------------------------------------------------
114469: 
114469: void
114469: nsPrintEngine::UpdateZoomRatio(nsPrintObject* aPO, bool aSetPixelScale)
114469: {
114469:   // Here is where we set the shrinkage value into the DC
114469:   // and this is what actually makes it shrink
114469:   if (aSetPixelScale && aPO->mFrameType != eIFrame) {
114469:     float ratio;
114469:     if (mPrt->mPrintFrameType == nsIPrintSettings::kFramesAsIs || mPrt->mPrintFrameType == nsIPrintSettings::kNoFrames) {
114469:       ratio = mPrt->mShrinkRatio - 0.005f; // round down
114469:     } else {
114469:       ratio = aPO->mShrinkRatio - 0.005f; // round down
114469:     }
114469:     aPO->mZoomRatio = ratio;
114469:   } else if (!mPrt->mShrinkToFit) {
114469:     double scaling;
114469:     mPrt->mPrintSettings->GetScaling(&scaling);
114469:     aPO->mZoomRatio = float(scaling);
114469:   } 
114469: }
114469: 
114469: nsresult
114469: nsPrintEngine::UpdateSelectionAndShrinkPrintObject(nsPrintObject* aPO,
114469:                                                    bool aDocumentIsTopLevel)
114469: {
127381:   nsCOMPtr<nsIPresShell> displayShell = aPO->mDocShell->GetPresShell();
114469:   // Transfer Selection Ranges to the new Print PresShell
114469:   nsCOMPtr<nsISelection> selection, selectionPS;
114469:   // It's okay if there is no display shell, just skip copying the selection
114469:   if (displayShell) {
114469:     selection = displayShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
114469:   }
114469:   selectionPS = aPO->mPresShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
114469: 
114469:   // Reset all existing selection ranges that might have been added by calling
114469:   // this function before.
114469:   if (selectionPS) {
114469:     selectionPS->RemoveAllRanges();
114469:   }
114469:   if (selection && selectionPS) {
114469:     int32_t cnt;
114469:     selection->GetRangeCount(&cnt);
114469:     int32_t inx;
114469:     for (inx = 0; inx < cnt; ++inx) {
114469:       nsCOMPtr<nsIDOMRange> range;
114469:       if (NS_SUCCEEDED(selection->GetRangeAt(inx, getter_AddRefs(range))))
114469:         selectionPS->AddRange(range);
114469:     }
114469:   }
114469: 
114469:   // If we are trying to shrink the contents to fit on the page
114469:   // we must first locate the "pageContent" frame
114469:   // Then we walk the frame tree and look for the "xmost" frame
114469:   // this is the frame where the right-hand side of the frame extends
114469:   // the furthest
114469:   if (mPrt->mShrinkToFit && aDocumentIsTopLevel) {
114469:     nsIPageSequenceFrame* pageSequence = aPO->mPresShell->GetPageSequenceFrame();
114469:     NS_ENSURE_STATE(pageSequence);
114469:     pageSequence->GetSTFPercent(aPO->mShrinkRatio);
114469:   }
114469:   return NS_OK;
114469: }
114469: 
114469: bool
114469: nsPrintEngine::DoSetPixelScale()
114469: {
     1:   // This is an Optimization
     1:   // If we are in PP then we already know all the shrinkage information
     1:   // so just transfer it to the PrintData and we will skip the extra shrinkage reflow
     1:   //
     1:   // doSetPixelScale tells Reflow whether to set the shrinkage value into the DC
     1:   // The first time we do not want to do this, the second time through we do
 79445:   bool doSetPixelScale = false;
 79445:   bool ppIsShrinkToFit = mPrtPreview && mPrtPreview->mShrinkToFit;
     1:   if (ppIsShrinkToFit) {
     1:     mPrt->mShrinkRatio = mPrtPreview->mShrinkRatio;
 80486:     doSetPixelScale = true;
     1:   }
114469:   return doSetPixelScale;
114469: }
114469: 
127357: nsView*
114469: nsPrintEngine::GetParentViewForRoot()
     1: {
 13332:   if (mIsCreatingPrintPreview) {
114469:     nsCOMPtr<nsIContentViewer> cv = do_QueryInterface(mDocViewerPrint);
114469:     if (cv) {
114469:       return cv->FindContainerView();
114469:     }
114469:   }
114469:   return nullptr;
114469: }
114469: 
     1: nsresult
114469: nsPrintEngine::SetRootView(
114469:     nsPrintObject* aPO, 
114469:     bool& doReturn, 
114469:     bool& documentIsTopLevel, 
114469:     nsSize& adjSize
114469: )
     1: {
 79445:   bool canCreateScrollbars = true;
114469: 
127357:   nsView* rootView;
127357:   nsView* parentView = nullptr;
 51637: 
114469:   doReturn = false;
114469: 
     1:   if (aPO->mParent && aPO->mParent->IsPrintable()) {
106838:     nsIFrame* frame = aPO->mContent ? aPO->mContent->GetPrimaryFrame() : nullptr;
     1:     // Without a frame, this document can't be displayed; therefore, there is no
     1:     // point to reflowing it
 36236:     if (!frame) {
 80486:       SetPrintPO(aPO, false);
114469:       doReturn = true;
     1:       return NS_OK;
 36236:     }
     1: 
 47902:     //XXX If printing supported printing document hierarchies with non-constant
 47902:     // zoom this would be wrong as we use the same mPrt->mPrintDC for all
 47902:     // subdocuments.
     1:     adjSize = frame->GetContentRect().Size();
 80486:     documentIsTopLevel = false;
     1:     // presshell exists because parent is printable
 51637: 
 51637:     // the top nsPrintObject's widget will always have scrollbars
 51637:     if (frame && frame->GetType() == nsGkAtoms::subDocumentFrame) {
127357:       nsView* view = frame->GetView();
 51637:       NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
 51637:       view = view->GetFirstChild();
 51637:       NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
 51637:       parentView = view;
 80486:       canCreateScrollbars = false;
 51637:     }
     1:   } else {
  8247:     nscoord pageWidth, pageHeight;
     1:     mPrt->mPrintDC->GetDeviceSurfaceDimensions(pageWidth, pageHeight);
     1:     adjSize = nsSize(pageWidth, pageHeight);
 80486:     documentIsTopLevel = true;
114469:     parentView = GetParentViewForRoot();
114469:   }
114469: 
115817:   if (aPO->mViewManager->GetRootView()) {
114469:     // Reuse the root view that is already on the root frame.
115817:     rootView = aPO->mViewManager->GetRootView();
115817:     // Remove it from its existing parent if necessary
115817:     aPO->mViewManager->RemoveChild(rootView);
127349:     rootView->SetParent(parentView);
114469:   } else {
114469:     // Create a child window of the parent that is our "root view/window"
114469:     nsRect tbounds = nsRect(nsPoint(0, 0), adjSize);
114469:     rootView = aPO->mViewManager->CreateView(tbounds, parentView);
114469:     NS_ENSURE_TRUE(rootView, NS_ERROR_OUT_OF_MEMORY);
114469:   }
114469:     
114469:   if (mIsCreatingPrintPreview && documentIsTopLevel) {
114469:     aPO->mPresContext->SetPaginatedScrolling(canCreateScrollbars);
114469:   }
114469: 
114469:   // Setup hierarchical relationship in view manager
114469:   aPO->mViewManager->SetRootView(rootView);
114469: 
114469:   return NS_OK;
114469: }
114469: 
114469: // Reflow a nsPrintObject
114469: nsresult
114469: nsPrintEngine::ReflowPrintObject(nsPrintObject * aPO)
114469: {
114469:   NS_ENSURE_STATE(aPO);
114469: 
114469:   if (!aPO->IsPrintable()) {
114469:     return NS_OK;
 52043:   }
     1:   
 35581:   NS_ASSERTION(!aPO->mPresContext, "Recreating prescontext");
 35581: 
 23745:   // create the PresContext
114469:   nsPresContext::nsPresContextType type =
 30514:       mIsCreatingPrintPreview ? nsPresContext::eContext_PrintPreview:
114469:                                 nsPresContext::eContext_Print;
127357:   nsView* parentView =
114469:     aPO->mParent && aPO->mParent->IsPrintable() ? nullptr : GetParentViewForRoot();
114469:   aPO->mPresContext = parentView ?
114469:       new nsPresContext(aPO->mDocument, type) :
114469:       new nsRootPresContext(aPO->mDocument, type);
 23745:   NS_ENSURE_TRUE(aPO->mPresContext, NS_ERROR_OUT_OF_MEMORY);
 23745:   aPO->mPresContext->SetPrintSettings(mPrt->mPrintSettings);
 23745: 
 23745:   // set the presentation context to the value in the print settings
 79445:   bool printBGColors;
 23745:   mPrt->mPrintSettings->GetPrintBGColors(&printBGColors);
 23745:   aPO->mPresContext->SetBackgroundColorDraw(printBGColors);
 23745:   mPrt->mPrintSettings->GetPrintBGImages(&printBGColors);
 23745:   aPO->mPresContext->SetBackgroundImageDraw(printBGColors);
 23745: 
 23745:   // init it with the DC
 23745:   nsresult rv = aPO->mPresContext->Init(mPrt->mPrintDC);
 23745:   NS_ENSURE_SUCCESS(rv, rv);
 23745: 
127609:   aPO->mViewManager = new nsViewManager();
 23745: 
 23745:   rv = aPO->mViewManager->Init(mPrt->mPrintDC);
 23745:   NS_ENSURE_SUCCESS(rv,rv);
 23745: 
 23745:   nsStyleSet* styleSet;
 23745:   rv = mDocViewerPrint->CreateStyleSet(aPO->mDocument, &styleSet);
 23745:   NS_ENSURE_SUCCESS(rv, rv);
 23745: 
 23745:   rv = aPO->mDocument->CreateShell(aPO->mPresContext, aPO->mViewManager,
 23745:                                    styleSet, getter_AddRefs(aPO->mPresShell));
 23745:   if (NS_FAILED(rv)) {
 23745:     delete styleSet;
 23745:     return rv;
 23745:   }
 23745: 
 23745:   styleSet->EndUpdate();
 23745:   
 23745:   // The pres shell now owns the style set object.
 23745: 
114469: 
114469:   bool doReturn = false;;
114469:   bool documentIsTopLevel = false;
114469:   nsSize adjSize; 
114469: 
114469:   rv = SetRootView(aPO, doReturn, documentIsTopLevel, adjSize);
114469: 
114469:   if (NS_FAILED(rv) || doReturn) {
114469:     return rv; 
114469:   }
114469: 
114469:   PR_PL(("In DV::ReflowPrintObject PO: %p pS: %p (%9s) Setting w,h to %d,%d\n", aPO, aPO->mPresShell.get(),
 23745:          gFrameTypesStr[aPO->mFrameType], adjSize.width, adjSize.height));
 23745: 
     1: 
     1:   // This docshell stuff is weird; will go away when we stop having multiple
     1:   // presentations per document
     1:   nsCOMPtr<nsISupports> supps(do_QueryInterface(aPO->mDocShell));
     1:   aPO->mPresContext->SetContainer(supps);
     1: 
     1:   aPO->mPresShell->BeginObservingDocument();
     1: 
     1:   aPO->mPresContext->SetPageSize(adjSize);
     1:   aPO->mPresContext->SetIsRootPaginatedDocument(documentIsTopLevel);
     1:   aPO->mPresContext->SetPageScale(aPO->mZoomRatio);
     1:   // Calculate scale factor from printer to screen
 50791:   float printDPI = float(mPrt->mPrintDC->AppUnitsPerCSSInch()) /
  8247:                    float(mPrt->mPrintDC->AppUnitsPerDevPixel());
 31784:   aPO->mPresContext->SetPrintPreviewScale(mScreenDPI / printDPI);
     1: 
 35581:   if (mIsCreatingPrintPreview && documentIsTopLevel) {
 51637:     mDocViewerPrint->SetPrintPreviewPresentation(aPO->mViewManager,
 35581:                                                  aPO->mPresContext,
 35581:                                                  aPO->mPresShell);
 35581:   }
 35581: 
111413:   rv = aPO->mPresShell->Initialize(adjSize.width, adjSize.height);
     1: 
     1:   NS_ENSURE_SUCCESS(rv, rv);
  1416:   NS_ASSERTION(aPO->mPresShell, "Presshell should still be here");
     1: 
111413:   // Process the reflow event Initialize posted
  4886:   aPO->mPresShell->FlushPendingNotifications(Flush_Layout);
   967: 
114469:   rv = UpdateSelectionAndShrinkPrintObject(aPO, documentIsTopLevel);
114469:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1: #ifdef EXTENDED_DEBUG_PRINTING
     1:     if (kPrintingLogMod && kPrintingLogMod->level == DUMP_LAYOUT_LEVEL) {
     1:       char * docStr;
     1:       char * urlStr;
     1:       GetDocTitleAndURL(aPO, docStr, urlStr);
     1:       char filename[256];
     1:       sprintf(filename, "print_dump_%d.txt", gDumpFileNameCnt++);
     1:       // Dump all the frames and view to a a file
     1:       FILE * fd = fopen(filename, "w");
     1:       if (fd) {
     1:         nsIFrame *theRootFrame =
     1:           aPO->mPresShell->FrameManager()->GetRootFrame();
     1:         fprintf(fd, "Title: %s\n", docStr?docStr:"");
     1:         fprintf(fd, "URL:   %s\n", urlStr?urlStr:"");
     1:         fprintf(fd, "--------------- Frames ----------------\n");
 68481:         nsRefPtr<nsRenderingContext> renderingContext;
     1:         mPrt->mPrintDocDC->CreateRenderingContext(*getter_AddRefs(renderingContext));
     1:         RootFrameList(aPO->mPresContext, fd, 0);
     1:         //DumpFrames(fd, aPO->mPresContext, renderingContext, theRootFrame, 0);
     1:         fprintf(fd, "---------------------------------------\n\n");
     1:         fprintf(fd, "--------------- Views From Root Frame----------------\n");
127357:         nsView* v = theRootFrame->GetView();
     1:         if (v) {
     1:           v->List(fd);
     1:         } else {
     1:           printf("View is null!\n");
     1:         }
     1:         if (docShell) {
     1:           fprintf(fd, "--------------- All Views ----------------\n");
     1:           DumpViews(docShell, fd);
     1:           fprintf(fd, "---------------------------------------\n\n");
     1:         }
     1:         fclose(fd);
     1:       }
     1:       if (docStr) nsMemory::Free(docStr);
     1:       if (urlStr) nsMemory::Free(urlStr);
     1:     }
     1: #endif
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: // Figure out how many documents and how many total pages we are printing
     1: void
108991: nsPrintEngine::CalcNumPrintablePages(int32_t& aNumPages)
     1: {
     1:   aNumPages = 0;
     1:   // Count the number of printable documents
     1:   // and printable pages
108991:   for (uint32_t i=0; i<mPrt->mPrintDocList.Length(); i++) {
 24551:     nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
     1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
     1:     if (po->mPresContext && po->mPresContext->IsRootPaginatedDocument()) {
 39668:       nsIPageSequenceFrame* pageSequence = po->mPresShell->GetPageSequenceFrame();
 23554:       nsIFrame * seqFrame = do_QueryFrame(pageSequence);
 23554:       if (seqFrame) {
 77154:         nsIFrame* frame = seqFrame->GetFirstPrincipalChild();
     1:         while (frame) {
     1:           aNumPages++;
     1:           frame = frame->GetNextSibling();
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: //-----------------------------------------------------------------
     1: //-- Done: Reflow Methods
     1: //-----------------------------------------------------------------
     1: 
     1: //-----------------------------------------------------------------
     1: //-- Section: Printing Methods
     1: //-----------------------------------------------------------------
     1: 
     1: //-------------------------------------------------------
     1: // Called for each DocShell that needs to be printed
 79445: bool
     1: nsPrintEngine::PrintDocContent(nsPrintObject* aPO, nsresult& aStatus)
     1: {
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1:   aStatus = NS_OK;
     1: 
     1:   if (!aPO->mHasBeenPrinted && aPO->IsPrintable()) {
     1:     aStatus = DoPrint(aPO);
 80486:     return true;
     1:   }
     1: 
     1:   // If |aPO->mPrintAsIs| and |aPO->mHasBeenPrinted| are true,
     1:   // the kids frames are already processed in |PrintPage|.
     1:   if (!aPO->mInvisible && !(aPO->mPrintAsIs && aPO->mHasBeenPrinted)) {
108991:     for (uint32_t i=0;i<aPO->mKids.Length();i++) {
 24551:       nsPrintObject* po = aPO->mKids[i];
 79445:       bool printed = PrintDocContent(po, aStatus);
     1:       if (printed || NS_FAILED(aStatus)) {
 80486:         return true;
 80486:       }
 80486:     }
 80486:   }
 80486:   return false;
     1: }
     1: 
 35581: static already_AddRefed<nsIDOMNode>
 35581: GetEqualNodeInCloneTree(nsIDOMNode* aNode, nsIDocument* aDoc)
 35581: {
 35581:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 35581:   // Selections in anonymous subtrees aren't supported.
 35581:   if (content && content->IsInAnonymousSubtree()) {
106838:     return nullptr;
 35581:   }
 35581: 
 35581:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
106838:   NS_ENSURE_TRUE(node, nullptr);
 35581: 
108991:   nsTArray<int32_t> indexArray;
 35581:   nsINode* current = node;
106838:   NS_ENSURE_TRUE(current, nullptr);
 35581:   while (current) {
119415:     nsINode* parent = current->GetParentNode();
 35581:     if (!parent) {
 35581:      break;
 35581:     }
108991:     int32_t index = parent->IndexOf(current);
106838:     NS_ENSURE_TRUE(index >= 0, nullptr);
 35581:     indexArray.AppendElement(index);
 35581:     current = parent;
 35581:   }
106838:   NS_ENSURE_TRUE(current->IsNodeOfType(nsINode::eDOCUMENT), nullptr);
 35581: 
 35581:   current = aDoc;
108991:   for (int32_t i = indexArray.Length() - 1; i >= 0; --i) {
 35581:     current = current->GetChildAt(indexArray[i]);
106838:     NS_ENSURE_TRUE(current, nullptr);
 35581:   }
 35581:   nsCOMPtr<nsIDOMNode> result = do_QueryInterface(current);
 35581:   return result.forget();
 35581: }
 35581: 
 35581: static nsresult CloneRangeToSelection(nsIDOMRange* aRange,
 35581:                                       nsIDocument* aDoc,
 35581:                                       nsISelection* aSelection)
 35581: {
 79445:   bool collapsed = false;
 35581:   aRange->GetCollapsed(&collapsed);
 35581:   if (collapsed) {
 35581:     return NS_OK;
 35581:   }
 35581: 
 35581:   nsCOMPtr<nsIDOMNode> startContainer, endContainer;
108991:   int32_t startOffset = -1, endOffset = -1;
 35581:   aRange->GetStartContainer(getter_AddRefs(startContainer));
 35581:   aRange->GetStartOffset(&startOffset);
 35581:   aRange->GetEndContainer(getter_AddRefs(endContainer));
 35581:   aRange->GetEndOffset(&endOffset);
 35581:   NS_ENSURE_STATE(startContainer && endContainer);
 35581: 
 35581:   nsCOMPtr<nsIDOMNode> newStart = GetEqualNodeInCloneTree(startContainer, aDoc);
 35581:   nsCOMPtr<nsIDOMNode> newEnd = GetEqualNodeInCloneTree(endContainer, aDoc);
 35581:   NS_ENSURE_STATE(newStart && newEnd);
 35581: 
 86939:   nsRefPtr<nsRange> range = new nsRange();
 35581:   nsresult rv = range->SetStart(newStart, startOffset);
 35581:   NS_ENSURE_SUCCESS(rv, rv);
 35581:   rv = range->SetEnd(newEnd, endOffset);
 35581:   NS_ENSURE_SUCCESS(rv, rv);
 35581: 
 35581:   return aSelection->AddRange(range);
 35581: }
 35581: 
 35581: static nsresult CloneSelection(nsIDocument* aOrigDoc, nsIDocument* aDoc)
 35581: {
 46225:   nsIPresShell* origShell = aOrigDoc->GetShell();
 46225:   nsIPresShell* shell = aDoc->GetShell();
 35581:   NS_ENSURE_STATE(origShell && shell);
 35581: 
 35581:   nsCOMPtr<nsISelection> origSelection =
 35581:     origShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
 35581:   nsCOMPtr<nsISelection> selection =
 35581:     shell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
 35581:   NS_ENSURE_STATE(origSelection && selection);
 35581: 
108991:   int32_t rangeCount = 0;
 35581:   origSelection->GetRangeCount(&rangeCount);
108991:   for (int32_t i = 0; i < rangeCount; ++i) {
 35581:     nsCOMPtr<nsIDOMRange> range;
 35581:     origSelection->GetRangeAt(i, getter_AddRefs(range));
 35581:     if (range) {
 35581:       CloneRangeToSelection(range, aDoc, selection);
 35581:     }
 35581:   }
 35581:   return NS_OK;
 35581: }
 35581: 
     1: //-------------------------------------------------------
     1: nsresult
     1: nsPrintEngine::DoPrint(nsPrintObject * aPO)
     1: {
     1:   PR_PL(("\n"));
     1:   PR_PL(("**************************** %s ****************************\n", gFrameTypesStr[aPO->mFrameType]));
     1:   PR_PL(("****** In DV::DoPrint   PO: %p \n", aPO));
     1: 
     1:   nsIPresShell*   poPresShell   = aPO->mPresShell;
     1:   nsPresContext*  poPresContext = aPO->mPresContext;
     1: 
     1:   NS_ASSERTION(poPresContext, "PrintObject has not been reflowed");
     1:   NS_ASSERTION(poPresContext->Type() != nsPresContext::eContext_PrintPreview,
     1:                "How did this context end up here?");
     1: 
     1:   if (mPrt->mPrintProgressParams) {
     1:     SetDocAndURLIntoProgress(aPO, mPrt->mPrintProgressParams);
     1:   }
     1: 
     1:   {
108991:     int16_t printRangeType = nsIPrintSettings::kRangeAllPages;
     1:     nsresult rv;
106838:     if (mPrt->mPrintSettings != nullptr) {
     1:       mPrt->mPrintSettings->GetPrintRange(&printRangeType);
     1:     }
     1: 
     1:     // Ask the page sequence frame to print all the pages
 39668:     nsIPageSequenceFrame* pageSequence = poPresShell->GetPageSequenceFrame();
106838:     NS_ASSERTION(nullptr != pageSequence, "no page sequence frame");
     1: 
     1:     // We are done preparing for printing, so we can turn this off
 80486:     mPrt->mPreparingForPrint = false;
     1: 
     1:     // mPrt->mDebugFilePtr this is onlu non-null when compiled for debugging
106838:     if (nullptr != mPrt->mDebugFilePtr) {
102909: #ifdef DEBUG
     1:       // output the regression test
     1:       nsIFrame* root = poPresShell->FrameManager()->GetRootFrame();
 31709:       root->DumpRegressionData(poPresContext, mPrt->mDebugFilePtr, 0);
     1:       fclose(mPrt->mDebugFilePtr);
 80486:       SetIsPrinting(false);
     1: #endif
     1:     } else {
     1: #ifdef EXTENDED_DEBUG_PRINTING
     1:       nsIFrame* rootFrame = poPresShell->FrameManager()->GetRootFrame();
     1:       if (aPO->IsPrintable()) {
     1:         char * docStr;
     1:         char * urlStr;
     1:         GetDocTitleAndURL(aPO, docStr, urlStr);
106838:         DumpLayoutData(docStr, urlStr, poPresContext, mPrt->mPrintDocDC, rootFrame, docShell, nullptr);
     1:         if (docStr) nsMemory::Free(docStr);
     1:         if (urlStr) nsMemory::Free(urlStr);
     1:       }
     1: #endif
     1: 
 58623:       if (!mPrt->mPrintSettings) {
 58623:         // not sure what to do here!
 80486:         SetIsPrinting(false);
 58623:         return NS_ERROR_FAILURE;
 58623:       }
 58623: 
106838:       PRUnichar * docTitleStr = nullptr;
106838:       PRUnichar * docURLStr   = nullptr;
     1: 
     1:       GetDisplayTitleAndURL(aPO, &docTitleStr, &docURLStr, eDocTitleDefBlank);
     1: 
     1:       if (nsIPrintSettings::kRangeSelection == printRangeType) {
 35581:         CloneSelection(aPO->mDocument->GetOriginalDocument(), aPO->mDocument);
 35581: 
 80486:         poPresContext->SetIsRenderingOnlySelection(true);
     1:         // temporarily creating rendering context
 68487:         // which is needed to find the selection frames
 68481:         nsRefPtr<nsRenderingContext> rc;
     1:         mPrt->mPrintDC->CreateRenderingContext(*getter_AddRefs(rc));
     1: 
     1:         // find the starting and ending page numbers
     1:         // via the selection
     1:         nsIFrame* startFrame;
     1:         nsIFrame* endFrame;
108991:         int32_t   startPageNum;
108991:         int32_t   endPageNum;
     1:         nsRect    startRect;
     1:         nsRect    endRect;
     1: 
     1:         nsCOMPtr<nsISelection> selectionPS;
     1:         selectionPS = poPresShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
     1: 
     1:         rv = GetPageRangeForSelection(poPresShell, poPresContext, *rc, selectionPS, pageSequence,
     1:                                       &startFrame, startPageNum, startRect,
     1:                                       &endFrame, endPageNum, endRect);
     1:         if (NS_SUCCEEDED(rv)) {
     1:           mPrt->mPrintSettings->SetStartPageRange(startPageNum);
     1:           mPrt->mPrintSettings->SetEndPageRange(endPageNum);
 23738:           nsIntMargin marginTwips(0,0,0,0);
 23738:           nsIntMargin unwrtMarginTwips(0,0,0,0);
  8247:           mPrt->mPrintSettings->GetMarginInTwips(marginTwips);
 14567:           mPrt->mPrintSettings->GetUnwriteableMarginInTwips(unwrtMarginTwips);
 50791:           nsMargin totalMargin = poPresContext->CSSTwipsToAppUnits(marginTwips +
 14567:                                                                    unwrtMarginTwips);
     1:           if (startPageNum == endPageNum) {
 14567:             startRect.y -= totalMargin.top;
 14567:             endRect.y   -= totalMargin.top;
 14773: 
 14773:             // Clip out selection regions above the top of the first page
 14773:             if (startRect.y < 0) {
 14773:               // Reduce height to be the height of the positive-territory
 14773:               // region of original rect
 32531:               startRect.height = NS_MAX(0, startRect.YMost());
 14773:               startRect.y = 0;
 14773:             }
 14773:             if (endRect.y < 0) {
 14773:               // Reduce height to be the height of the positive-territory
 14773:               // region of original rect
 32531:               endRect.height = NS_MAX(0, endRect.YMost());
 14773:               endRect.y = 0;
 14773:             }
 14773:             NS_ASSERTION(endRect.y >= startRect.y,
 14773:                          "Selection end point should be after start point");
 14773:             NS_ASSERTION(startRect.height >= 0,
 14773:                          "rect should have non-negative height.");
 14773:             NS_ASSERTION(endRect.height >= 0,
 14773:                          "rect should have non-negative height.");
 14773: 
 14532:             nscoord selectionHgt = endRect.y + endRect.height - startRect.y;
     1:             // XXX This is temporary fix for printing more than one page of a selection
 14532:             pageSequence->SetSelectionHeight(startRect.y * aPO->mZoomRatio,
 14532:                                              selectionHgt * aPO->mZoomRatio);
     1: 
     1:             // calc total pages by getting calculating the selection's height
     1:             // and then dividing it by how page content frames will fit.
  8247:             nscoord pageWidth, pageHeight;
     1:             mPrt->mPrintDC->GetDeviceSurfaceDimensions(pageWidth, pageHeight);
 14567:             pageHeight -= totalMargin.top + totalMargin.bottom;
108991:             int32_t totalPages = NSToIntCeil(float(selectionHgt) * aPO->mZoomRatio / float(pageHeight));
     1:             pageSequence->SetTotalNumPages(totalPages);
     1:           }
     1:         }
     1:       }
     1: 
 23554:       nsIFrame * seqFrame = do_QueryFrame(pageSequence);
 23554:       if (!seqFrame) {
 80486:         SetIsPrinting(false);
 58623:         if (docTitleStr) nsMemory::Free(docTitleStr);
 58623:         if (docURLStr) nsMemory::Free(docURLStr);
     1:         return NS_ERROR_FAILURE;
     1:       }
     1: 
     1:       mPageSeqFrame = pageSequence;
     1:       mPageSeqFrame->StartPrint(poPresContext, mPrt->mPrintSettings, docTitleStr, docURLStr);
     1: 
     1:       // Schedule Page to Print
     1:       PR_PL(("Scheduling Print of PO: %p (%s) \n", aPO, gFrameTypesStr[aPO->mFrameType]));
     1:       StartPagePrintTimer(aPO);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: void
     1: nsPrintEngine::SetDocAndURLIntoProgress(nsPrintObject* aPO,
     1:                                         nsIPrintProgressParams* aParams)
     1: {
     1:   NS_ASSERTION(aPO, "Must have vaild nsPrintObject");
     1:   NS_ASSERTION(aParams, "Must have vaild nsIPrintProgressParams");
     1: 
     1:   if (!aPO || !aPO->mDocShell || !aParams) {
     1:     return;
     1:   }
108991:   const uint32_t kTitleLength = 64;
     1: 
     1:   PRUnichar * docTitleStr;
     1:   PRUnichar * docURLStr;
     1:   GetDisplayTitleAndURL(aPO, &docTitleStr, &docURLStr, eDocTitleDefURLDoc);
     1: 
     1:   // Make sure the Titles & URLS don't get too long for the progress dialog
 80486:   ElipseLongString(docTitleStr, kTitleLength, false);
 80486:   ElipseLongString(docURLStr, kTitleLength, true);
     1: 
     1:   aParams->SetDocTitle(docTitleStr);
     1:   aParams->SetDocURL(docURLStr);
     1: 
106838:   if (docTitleStr != nullptr) nsMemory::Free(docTitleStr);
106838:   if (docURLStr != nullptr) nsMemory::Free(docURLStr);
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: void
108991: nsPrintEngine::ElipseLongString(PRUnichar *& aStr, const uint32_t aLen, bool aDoFront)
     1: {
     1:   // Make sure the URLS don't get too long for the progress dialog
 99810:   if (aStr && NS_strlen(aStr) > aLen) {
     1:     if (aDoFront) {
 99810:       PRUnichar * ptr = &aStr[NS_strlen(aStr) - aLen + 3];
     1:       nsAutoString newStr;
     1:       newStr.AppendLiteral("...");
     1:       newStr += ptr;
     1:       nsMemory::Free(aStr);
     1:       aStr = ToNewUnicode(newStr);
     1:     } else {
     1:       nsAutoString newStr(aStr);
     1:       newStr.SetLength(aLen-3);
     1:       newStr.AppendLiteral("...");
     1:       nsMemory::Free(aStr);
     1:       aStr = ToNewUnicode(newStr);
     1:     }
     1:   }
     1: }
     1: 
111090: static bool
111090: DocHasPrintCallbackCanvas(nsIDocument* aDoc, void* aData)
111090: {
111090:   if (!aDoc) {
111090:     return true;
111090:   }
111090:   Element* root = aDoc->GetRootElement();
114989:   if (!root) {
114989:     return true;
114989:   }
111090:   nsRefPtr<nsContentList> canvases = NS_GetContentList(root,
111090:                                                        kNameSpaceID_XHTML,
111090:                                                        NS_LITERAL_STRING("canvas"));
111335:   uint32_t canvasCount = canvases->Length(true);
111335:   for (uint32_t i = 0; i < canvasCount; ++i) {
111090:     nsCOMPtr<nsIDOMHTMLCanvasElement> canvas = do_QueryInterface(canvases->Item(i, false));
111090:     nsCOMPtr<nsIPrintCallback> printCallback;
111090:     if (canvas && NS_SUCCEEDED(canvas->GetMozPrintCallback(getter_AddRefs(printCallback))) &&
111090:         printCallback) {
111090:       // This subdocument has a print callback. Set result and return false to
111090:       // stop iteration.
111090:       *static_cast<bool*>(aData) = true;
111090:       return false;
111090:     }
111090:   }
111090:   return true;
111090: }
111090: 
111090: static bool
111090: DocHasPrintCallbackCanvas(nsIDocument* aDoc)
111090: {
111090:   bool result = false;
111090:   aDoc->EnumerateSubDocuments(&DocHasPrintCallbackCanvas, static_cast<void*>(&result));
111090:   return result;
111090: }
111090: 
111090: /**
111090:  * Checks to see if the document this print engine is associated with has any
111090:  * canvases that have a mozPrintCallback.
111090:  */
111090: bool
111090: nsPrintEngine::HasPrintCallbackCanvas()
111090: {
111090:   if (!mDocument) {
111090:     return false;
111090:   }
111090:   // First check this mDocument.
111090:   bool result = false;
111090:   DocHasPrintCallbackCanvas(mDocument, static_cast<void*>(&result));
111090:   // Also check the sub documents.
111090:   return result || DocHasPrintCallbackCanvas(mDocument);
111090: }
111090: 
     1: //-------------------------------------------------------
 79445: bool
111090: nsPrintEngine::PrePrintPage()
111090: {
111090:   NS_ASSERTION(mPageSeqFrame,  "mPageSeqFrame is null!");
111090:   NS_ASSERTION(mPrt,           "mPrt is null!");
111090: 
111090:   // Although these should NEVER be NULL
111090:   // This is added insurance, to make sure we don't crash in optimized builds
111090:   if (!mPrt || !mPageSeqFrame) {
111090:     return true; // means we are done preparing the page.
111090:   }
111090: 
111090:   // Check setting to see if someone request it be cancelled
111090:   bool isCancelled = false;
111090:   mPrt->mPrintSettings->GetIsCancelled(&isCancelled);
111090:   if (isCancelled)
111090:     return true;
111090: 
111090:   // Ask mPageSeqFrame if the page is ready to be printed.
111090:   // If the page doesn't get printed at all, the |done| will be |true|.
111090:   bool done = false;
111090:   nsresult rv = mPageSeqFrame->PrePrintNextPage(mPagePrintTimer, &done);
111090:   if (NS_FAILED(rv)) {
111090:     // ??? ::PrintPage doesn't set |mPrt->mIsAborted = true| if rv != NS_ERROR_ABORT,
111090:     // but I don't really understand why this should be the right thing to do?
111090:     // Shouldn't |mPrt->mIsAborted| set to true all the time if something
111090:     // wents wrong?
111090:     if (rv != NS_ERROR_ABORT) {
111090:       ShowPrintErrorDialog(rv);
111090:       mPrt->mIsAborted = true;
111090:     }
111090:     done = true;
111090:   }
111090:   return done;
111090: }
111090: 
111090: bool
     1: nsPrintEngine::PrintPage(nsPrintObject*    aPO,
 79445:                          bool&           aInRange)
     1: {
     1:   NS_ASSERTION(aPO,            "aPO is null!");
     1:   NS_ASSERTION(mPageSeqFrame,  "mPageSeqFrame is null!");
     1:   NS_ASSERTION(mPrt,           "mPrt is null!");
     1: 
     1:   // Although these should NEVER be NULL
     1:   // This is added insurance, to make sure we don't crash in optimized builds
     1:   if (!mPrt || !aPO || !mPageSeqFrame) {
     1:     ShowPrintErrorDialog(NS_ERROR_FAILURE);
 80486:     return true; // means we are done printing
     1:   }
     1: 
     1:   PR_PL(("-----------------------------------\n"));
     1:   PR_PL(("------ In DV::PrintPage PO: %p (%s)\n", aPO, gFrameTypesStr[aPO->mFrameType]));
     1: 
     1:   // Check setting to see if someone request it be cancelled
 79445:   bool isCancelled = false;
     1:   mPrt->mPrintSettings->GetIsCancelled(&isCancelled);
111090:   if (isCancelled || mPrt->mIsAborted)
 80486:     return true;
     1: 
108991:   int32_t pageNum, numPages, endPage;
     1:   mPageSeqFrame->GetCurrentPageNum(&pageNum);
     1:   mPageSeqFrame->GetNumPages(&numPages);
     1: 
 79445:   bool donePrinting;
 79445:   bool isDoingPrintRange;
     1:   mPageSeqFrame->IsDoingPrintRange(&isDoingPrintRange);
     1:   if (isDoingPrintRange) {
108991:     int32_t fromPage;
108991:     int32_t toPage;
     1:     mPageSeqFrame->GetPrintRange(&fromPage, &toPage);
     1: 
     1:     if (fromPage > numPages) {
 80486:       return true;
     1:     }
     1:     if (toPage > numPages) {
     1:       toPage = numPages;
     1:     }
     1: 
     1:     PR_PL(("****** Printing Page %d printing from %d to page %d\n", pageNum, fromPage, toPage));
     1: 
     1:     donePrinting = pageNum >= toPage;
     1:     aInRange = pageNum >= fromPage && pageNum <= toPage;
     1:     endPage = (toPage - fromPage)+1;
     1:   } else {
     1:     PR_PL(("****** Printing Page %d of %d page(s)\n", pageNum, numPages));
     1: 
     1:     donePrinting = pageNum >= numPages;
     1:     endPage = numPages;
 80486:     aInRange = true;
     1:   }
     1: 
     1:   // XXX This is wrong, but the actual behavior in the presence of a print
     1:   // range sucks.
     1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kEachFrameSep)
     1:     endPage = mPrt->mNumPrintablePages;
     1:   
 80486:   mPrt->DoOnProgressChange(++mPrt->mNumPagesPrinted, endPage, false, 0);
     1: 
     1:   // Print the Page
     1:   // if a print job was cancelled externally, an EndPage or BeginPage may
     1:   // fail and the failure is passed back here.
 80486:   // Returning true means we are done printing.
     1:   //
     1:   // When rv == NS_ERROR_ABORT, it means we want out of the
     1:   // print job without displaying any error messages
     1:   nsresult rv = mPageSeqFrame->PrintNextPage();
     1:   if (NS_FAILED(rv)) {
     1:     if (rv != NS_ERROR_ABORT) {
     1:       ShowPrintErrorDialog(rv);
 80486:       mPrt->mIsAborted = true;
 80486:     }
 80486:     return true;
     1:   }
     1: 
     1:   mPageSeqFrame->DoPageEnd();
     1: 
     1:   return donePrinting;
     1: }
     1: 
     1: /** ---------------------------------------------------
     1:  *  Find by checking frames type
     1:  */
     1: nsresult 
     1: nsPrintEngine::FindSelectionBoundsWithList(nsPresContext* aPresContext,
 68481:                                            nsRenderingContext& aRC,
 77153:                                            nsFrameList::Enumerator& aChildFrames,
     1:                                            nsIFrame *      aParentFrame,
     1:                                            nsRect&         aRect,
     1:                                            nsIFrame *&     aStartFrame,
     1:                                            nsRect&         aStartRect,
     1:                                            nsIFrame *&     aEndFrame,
     1:                                            nsRect&         aEndRect)
     1: {
     1:   NS_ASSERTION(aPresContext, "Pointer is null!");
     1:   NS_ASSERTION(aParentFrame, "Pointer is null!");
     1: 
     1:   aRect += aParentFrame->GetPosition();
 77153:   for (; !aChildFrames.AtEnd(); aChildFrames.Next()) {
 77153:     nsIFrame* child = aChildFrames.get();
 85101:     if (child->IsSelected() && child->IsVisibleForPainting()) {
     1:       nsRect r = child->GetRect();
106838:       if (aStartFrame == nullptr) {
     1:         aStartFrame = child;
     1:         aStartRect.SetRect(aRect.x + r.x, aRect.y + r.y, r.width, r.height);
     1:       } else {
     1:         aEndFrame = child;
     1:         aEndRect.SetRect(aRect.x + r.x, aRect.y + r.y, r.width, r.height);
     1:       }
     1:     }
     1:     FindSelectionBounds(aPresContext, aRC, child, aRect, aStartFrame, aStartRect, aEndFrame, aEndRect);
     1:     child = child->GetNextSibling();
     1:   }
     1:   aRect -= aParentFrame->GetPosition();
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: // Find the Frame that is XMost
     1: nsresult 
     1: nsPrintEngine::FindSelectionBounds(nsPresContext* aPresContext,
 68481:                                    nsRenderingContext& aRC,
     1:                                    nsIFrame *      aParentFrame,
     1:                                    nsRect&         aRect,
     1:                                    nsIFrame *&     aStartFrame,
     1:                                    nsRect&         aStartRect,
     1:                                    nsIFrame *&     aEndFrame,
     1:                                    nsRect&         aEndRect)
     1: {
     1:   NS_ASSERTION(aPresContext, "Pointer is null!");
     1:   NS_ASSERTION(aParentFrame, "Pointer is null!");
     1: 
     1:   // loop through named child lists
 77153:   nsIFrame::ChildListIterator lists(aParentFrame);
 77153:   for (; !lists.IsDone(); lists.Next()) {
 77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:     nsresult rv = FindSelectionBoundsWithList(aPresContext, aRC, childFrames, aParentFrame, aRect, aStartFrame, aStartRect, aEndFrame, aEndRect);
     1:     NS_ENSURE_SUCCESS(rv, rv);
 77153:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /** ---------------------------------------------------
     1:  *  This method finds the starting and ending page numbers
     1:  *  of the selection and also returns rect for each where
     1:  *  the x,y of the rect is relative to the very top of the
     1:  *  frame tree (absolutely positioned)
     1:  */
     1: nsresult 
     1: nsPrintEngine::GetPageRangeForSelection(nsIPresShell *        aPresShell,
     1:                                         nsPresContext*       aPresContext,
 68481:                                         nsRenderingContext&  aRC,
     1:                                         nsISelection*         aSelection,
     1:                                         nsIPageSequenceFrame* aPageSeqFrame,
     1:                                         nsIFrame**            aStartFrame,
108991:                                         int32_t&              aStartPageNum,
     1:                                         nsRect&               aStartRect,
     1:                                         nsIFrame**            aEndFrame,
108991:                                         int32_t&              aEndPageNum,
     1:                                         nsRect&               aEndRect)
     1: {
     1:   NS_ASSERTION(aPresShell, "Pointer is null!");
     1:   NS_ASSERTION(aPresContext, "Pointer is null!");
     1:   NS_ASSERTION(aSelection, "Pointer is null!");
     1:   NS_ASSERTION(aPageSeqFrame, "Pointer is null!");
     1:   NS_ASSERTION(aStartFrame, "Pointer is null!");
     1:   NS_ASSERTION(aEndFrame, "Pointer is null!");
     1: 
 23554:   nsIFrame * seqFrame = do_QueryFrame(aPageSeqFrame);
 23554:   if (!seqFrame) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
106838:   nsIFrame * startFrame = nullptr;
106838:   nsIFrame * endFrame   = nullptr;
     1: 
     1:   // start out with the sequence frame and search the entire frame tree
     1:   // capturing the starting and ending child frames of the selection
     1:   // and their rects
     1:   nsRect r = seqFrame->GetRect();
     1:   FindSelectionBounds(aPresContext, aRC, seqFrame, r,
     1:                       startFrame, aStartRect, endFrame, aEndRect);
     1: 
     1: #ifdef DEBUG_rodsX
     1:   printf("Start Frame: %p\n", startFrame);
     1:   printf("End Frame:   %p\n", endFrame);
     1: #endif
     1: 
     1:   // initial the page numbers here
     1:   // in case we don't find and frames
     1:   aStartPageNum = -1;
     1:   aEndPageNum   = -1;
     1: 
     1:   nsIFrame * startPageFrame;
     1:   nsIFrame * endPageFrame;
     1: 
     1:   // check to make sure we found a starting frame
106838:   if (startFrame != nullptr) {
     1:     // Now search up the tree to find what page the
     1:     // start/ending selections frames are on
     1:     //
     1:     // Check to see if start should be same as end if
     1:     // the end frame comes back null
106838:     if (endFrame == nullptr) {
     1:       // XXX the "GetPageFrame" step could be integrated into
     1:       // the FindSelectionBounds step, but walking up to find
     1:       // the parent of a child frame isn't expensive and it makes
     1:       // FindSelectionBounds a little easier to understand
     1:       startPageFrame = nsLayoutUtils::GetPageFrame(startFrame);
     1:       endPageFrame   = startPageFrame;
     1:       aEndRect       = aStartRect;
     1:     } else {
     1:       startPageFrame = nsLayoutUtils::GetPageFrame(startFrame);
     1:       endPageFrame   = nsLayoutUtils::GetPageFrame(endFrame);
     1:     }
     1:   } else {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1: #ifdef DEBUG_rodsX
     1:   printf("Start Page: %p\n", startPageFrame);
     1:   printf("End Page:   %p\n", endPageFrame);
     1: 
     1:   // dump all the pages and their pointers
     1:   {
108991:   int32_t pageNum = 1;
 77154:   nsIFrame* child = seqFrame->GetFirstPrincipalChild();
106838:   while (child != nullptr) {
     1:     printf("Page: %d - %p\n", pageNum, child);
     1:     pageNum++;
     1:     child = child->GetNextSibling();
     1:   }
     1:   }
     1: #endif
     1: 
     1:   // Now that we have the page frames
     1:   // find out what the page numbers are for each frame
108991:   int32_t pageNum = 1;
 77154:   nsIFrame* page = seqFrame->GetFirstPrincipalChild();
106838:   while (page != nullptr) {
     1:     if (page == startPageFrame) {
     1:       aStartPageNum = pageNum;
     1:     }
     1:     if (page == endPageFrame) {
     1:       aEndPageNum = pageNum;
     1:     }
     1:     pageNum++;
     1:     page = page->GetNextSibling();
     1:   }
     1: 
     1: #ifdef DEBUG_rodsX
     1:   printf("Start Page No: %d\n", aStartPageNum);
     1:   printf("End Page No:   %d\n", aEndPageNum);
     1: #endif
     1: 
     1:   *aStartFrame = startPageFrame;
     1:   *aEndFrame   = endPageFrame;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //-----------------------------------------------------------------
     1: //-- Done: Printing Methods
     1: //-----------------------------------------------------------------
     1: 
     1: 
     1: //-----------------------------------------------------------------
     1: //-- Section: Misc Support Methods
     1: //-----------------------------------------------------------------
     1: 
     1: //---------------------------------------------------------------------
 79445: void nsPrintEngine::SetIsPrinting(bool aIsPrinting)
     1: { 
     1:   mIsDoingPrinting = aIsPrinting;
 24061:   // Calling SetIsPrinting while in print preview confuses the document viewer
 24061:   // This is safe because we prevent exiting print preview while printing
111090:   if (!mIsDoingPrintPreview && mDocViewerPrint) {
111090:     mDocViewerPrint->SetIsPrinting(aIsPrinting);
     1:   }
  5662:   if (mPrt && aIsPrinting) {
 80486:     mPrt->mPreparingForPrint = true;
  5662:   }
     1: }
     1: 
     1: //---------------------------------------------------------------------
 79445: void nsPrintEngine::SetIsPrintPreview(bool aIsPrintPreview) 
     1: { 
     1:   mIsDoingPrintPreview = aIsPrintPreview; 
     1: 
     1:   if (mDocViewerPrint) {
     1:     mDocViewerPrint->SetIsPrintPreview(aIsPrintPreview);
     1:   }
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: void
108991: nsPrintEngine::CleanupDocTitleArray(PRUnichar**& aArray, int32_t& aCount)
     1: {
108991:   for (int32_t i = aCount - 1; i >= 0; i--) {
     1:     nsMemory::Free(aArray[i]);
     1:   }
     1:   nsMemory::Free(aArray);
     1:   aArray = NULL;
     1:   aCount = 0;
     1: }
     1: 
     1: //---------------------------------------------------------------------
     1: // static
 79445: bool nsPrintEngine::HasFramesetChild(nsIContent* aContent)
     1: {
     1:   if (!aContent) {
 80486:     return false;
     1:   }
     1: 
     1:   // do a breadth search across all siblings
 88030:   for (nsIContent* child = aContent->GetFirstChild();
 88030:        child;
 88030:        child = child->GetNextSibling()) {
 88030:     if (child->IsHTML(nsGkAtoms::frameset)) {
 80486:       return true;
 80486:     }
 80486:   }
 80486: 
 80486:   return false;
     1: }
     1:  
     1: 
     1: 
     1: /** ---------------------------------------------------
     1:  *  Get the Focused Frame for a documentviewer
     1:  */
     1: already_AddRefed<nsIDOMWindow>
     1: nsPrintEngine::FindFocusedDOMWindow()
     1: {
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
106838:   NS_ENSURE_TRUE(fm, nullptr);
 41536: 
 41536:   nsCOMPtr<nsPIDOMWindow> window(mDocument->GetWindow());
106838:   NS_ENSURE_TRUE(window, nullptr);
 41536: 
 41536:   nsCOMPtr<nsPIDOMWindow> rootWindow = window->GetPrivateRoot();
106838:   NS_ENSURE_TRUE(rootWindow, nullptr);
 41536: 
 41536:   nsPIDOMWindow* focusedWindow;
 80486:   nsFocusManager::GetFocusedDescendant(rootWindow, true, &focusedWindow);
106838:   NS_ENSURE_TRUE(focusedWindow, nullptr);
 41536: 
 41536:   if (IsWindowsInOurSubTree(focusedWindow)) {
 41536:     return focusedWindow;
 41536:   }
 41536: 
 41536:   NS_IF_RELEASE(focusedWindow);
106838:   return nullptr;
     1: }
     1: 
     1: //---------------------------------------------------------------------
 79445: bool
 41536: nsPrintEngine::IsWindowsInOurSubTree(nsPIDOMWindow * window)
     1: {
 79445:   bool found = false;
     1: 
     1:   // now check to make sure it is in "our" tree of docshells
     1:   if (window) {
     1:     nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
     1:       do_QueryInterface(window->GetDocShell());
     1: 
     1:     if (docShellAsItem) {
     1:       // get this DocViewer docshell
 69583:       nsCOMPtr<nsIDocShell> thisDVDocShell(do_QueryReferent(mContainer));
     1:       while (!found) {
     1:         nsCOMPtr<nsIDocShell> parentDocshell(do_QueryInterface(docShellAsItem));
     1:         if (parentDocshell) {
     1:           if (parentDocshell == thisDVDocShell) {
 80486:             found = true;
     1:             break;
     1:           }
     1:         } else {
     1:           break; // at top of tree
     1:         }
     1:         nsCOMPtr<nsIDocShellTreeItem> docShellParent;
     1:         docShellAsItem->GetSameTypeParent(getter_AddRefs(docShellParent));
     1:         docShellAsItem = docShellParent;
     1:       } // while
     1:     }
     1:   } // scriptobj
     1: 
     1:   return found;
     1: }
     1: 
     1: //-------------------------------------------------------
 79445: bool
     1: nsPrintEngine::DonePrintingPages(nsPrintObject* aPO, nsresult aResult)
     1: {
     1:   //NS_ASSERTION(aPO, "Pointer is null!");
     1:   PR_PL(("****** In DV::DonePrintingPages PO: %p (%s)\n", aPO, aPO?gFrameTypesStr[aPO->mFrameType]:""));
     1: 
111090:   // If there is a pageSeqFrame, make sure there are no more printCanvas active
111090:   // that might call |Notify| on the pagePrintTimer after things are cleaned up
111090:   // and printing was marked as being done.
111090:   if (mPageSeqFrame) {
111090:     mPageSeqFrame->ResetPrintCanvasList();
111090:   }
111090: 
111090:   if (aPO && !mPrt->mIsAborted) {
 80486:     aPO->mHasBeenPrinted = true;
     1:     nsresult rv;
 79445:     bool didPrint = PrintDocContent(mPrt->mPrintObject, rv);
     1:     if (NS_SUCCEEDED(rv) && didPrint) {
     1:       PR_PL(("****** In DV::DonePrintingPages PO: %p (%s) didPrint:%s (Not Done Printing)\n", aPO, gFrameTypesStr[aPO->mFrameType], PRT_YESNO(didPrint)));
 80486:       return false;
     1:     }
     1:   }
     1: 
     1:   if (NS_SUCCEEDED(aResult)) {
     1:     FirePrintCompletionEvent();
     1:   }
     1: 
 80486:   TurnScriptingOn(true);
 80486:   SetIsPrinting(false);
     1: 
     1:   // Release reference to mPagePrintTimer; the timer object destroys itself
     1:   // after this returns true
     1:   NS_IF_RELEASE(mPagePrintTimer);
     1: 
 80486:   return true;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: // Recursively sets the PO items to be printed "As Is"
     1: // from the given item down into the tree
     1: void
 79445: nsPrintEngine::SetPrintAsIs(nsPrintObject* aPO, bool aAsIs)
     1: {
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1: 
     1:   aPO->mPrintAsIs = aAsIs;
108991:   for (uint32_t i=0;i<aPO->mKids.Length();i++) {
 24551:     SetPrintAsIs(aPO->mKids[i], aAsIs);
     1:   }
     1: }
     1: 
     1: //-------------------------------------------------------
     1: // Given a DOMWindow it recursively finds the PO object that matches
     1: nsPrintObject*
     1: nsPrintEngine::FindPrintObjectByDOMWin(nsPrintObject* aPO,
     1:                                        nsIDOMWindow* aDOMWin)
     1: {
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1: 
     1:   // Often the CurFocused DOMWindow is passed in
     1:   // andit is valid for it to be null, so short circut
     1:   if (!aDOMWin) {
106838:     return nullptr;
     1:   }
     1: 
 35581:   nsCOMPtr<nsIDOMDocument> domDoc;
 35581:   aDOMWin->GetDocument(getter_AddRefs(domDoc));
 35581:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
 35581:   if (aPO->mDocument && aPO->mDocument->GetOriginalDocument() == doc) {
     1:     return aPO;
     1:   }
     1: 
108991:   int32_t cnt = aPO->mKids.Length();
108991:   for (int32_t i = 0; i < cnt; ++i) {
 24551:     nsPrintObject* po = FindPrintObjectByDOMWin(aPO->mKids[i], aDOMWin);
     1:     if (po) {
     1:       return po;
     1:     }
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: nsresult
     1: nsPrintEngine::EnablePOsForPrinting()
     1: {
     1:   // NOTE: All POs have been "turned off" for printing
     1:   // this is where we decided which POs get printed.
106838:   mPrt->mSelectedPO = nullptr;
106838: 
106838:   if (mPrt->mPrintSettings == nullptr) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   mPrt->mPrintFrameType = nsIPrintSettings::kNoFrames;
     1:   mPrt->mPrintSettings->GetPrintFrameType(&mPrt->mPrintFrameType);
     1: 
108991:   int16_t printHowEnable = nsIPrintSettings::kFrameEnableNone;
     1:   mPrt->mPrintSettings->GetHowToEnableFrameUI(&printHowEnable);
     1: 
108991:   int16_t printRangeType = nsIPrintSettings::kRangeAllPages;
     1:   mPrt->mPrintSettings->GetPrintRange(&printRangeType);
     1: 
     1:   PR_PL(("\n"));
     1:   PR_PL(("********* nsPrintEngine::EnablePOsForPrinting *********\n"));
     1:   PR_PL(("PrintFrameType:     %s \n", gPrintFrameTypeStr[mPrt->mPrintFrameType]));
     1:   PR_PL(("HowToEnableFrameUI: %s \n", gFrameHowToEnableStr[printHowEnable]));
     1:   PR_PL(("PrintRange:         %s \n", gPrintRangeStr[printRangeType]));
     1:   PR_PL(("----\n"));
     1: 
     1:   // ***** This is the ultimate override *****
     1:   // if we are printing the selection (either an IFrame or selection range)
     1:   // then set the mPrintFrameType as if it were the selected frame
     1:   if (printRangeType == nsIPrintSettings::kRangeSelection) {
     1:     mPrt->mPrintFrameType = nsIPrintSettings::kSelectedFrame;
     1:     printHowEnable        = nsIPrintSettings::kFrameEnableNone;
     1:   }
     1: 
     1:   // This tells us that the "Frame" UI has turned off,
     1:   // so therefore there are no FrameSets/Frames/IFrames to be printed
     1:   //
     1:   // This means there are not FrameSets,
     1:   // but the document could contain an IFrame
     1:   if (printHowEnable == nsIPrintSettings::kFrameEnableNone) {
     1: 
     1:     // Print all the pages or a sub range of pages
     1:     if (printRangeType == nsIPrintSettings::kRangeAllPages ||
     1:         printRangeType == nsIPrintSettings::kRangeSpecifiedPageRange) {
 80486:       SetPrintPO(mPrt->mPrintObject, true);
     1: 
     1:       // Set the children so they are PrinAsIs
     1:       // In this case, the children are probably IFrames
 24551:       if (mPrt->mPrintObject->mKids.Length() > 0) {
108991:         for (uint32_t i=0;i<mPrt->mPrintObject->mKids.Length();i++) {
 24551:           nsPrintObject* po = mPrt->mPrintObject->mKids[i];
     1:           NS_ASSERTION(po, "nsPrintObject can't be null!");
     1:           SetPrintAsIs(po);
     1:         }
     1: 
     1:         // ***** Another override *****
     1:         mPrt->mPrintFrameType = nsIPrintSettings::kFramesAsIs;
     1:       }
     1:       PR_PL(("PrintFrameType:     %s \n", gPrintFrameTypeStr[mPrt->mPrintFrameType]));
     1:       PR_PL(("HowToEnableFrameUI: %s \n", gFrameHowToEnableStr[printHowEnable]));
     1:       PR_PL(("PrintRange:         %s \n", gPrintRangeStr[printRangeType]));
     1:       return NS_OK;
     1:     }
     1: 
     1:     // This means we are either printed a selected IFrame or
     1:     // we are printing the current selection
     1:     if (printRangeType == nsIPrintSettings::kRangeSelection) {
     1: 
     1:       // If the currentFocusDOMWin can'r be null if something is selected
     1:       if (mPrt->mCurrentFocusWin) {
     1:         // Find the selected IFrame
     1:         nsPrintObject * po = FindPrintObjectByDOMWin(mPrt->mPrintObject, mPrt->mCurrentFocusWin);
106838:         if (po != nullptr) {
     1:           mPrt->mSelectedPO = po;
     1:           // Makes sure all of its children are be printed "AsIs"
     1:           SetPrintAsIs(po);
     1: 
     1:           // Now, only enable this POs (the selected PO) and all of its children
 80486:           SetPrintPO(po, true);
     1: 
     1:           // check to see if we have a range selection,
     1:           // as oppose to a insert selection
     1:           // this means if the user just clicked on the IFrame then
     1:           // there will not be a selection so we want the entire page to print
     1:           //
     1:           // XXX this is sort of a hack right here to make the page
     1:           // not try to reposition itself when printing selection
 35581:           nsCOMPtr<nsIDOMWindow> domWin =
 35581:             do_QueryInterface(po->mDocument->GetOriginalDocument()->GetWindow());
     1:           if (!IsThereARangeSelection(domWin)) {
     1:             printRangeType = nsIPrintSettings::kRangeAllPages;
     1:             mPrt->mPrintSettings->SetPrintRange(printRangeType);
     1:           }
     1:           PR_PL(("PrintFrameType:     %s \n", gPrintFrameTypeStr[mPrt->mPrintFrameType]));
     1:           PR_PL(("HowToEnableFrameUI: %s \n", gFrameHowToEnableStr[printHowEnable]));
     1:           PR_PL(("PrintRange:         %s \n", gPrintRangeStr[printRangeType]));
     1:           return NS_OK;
     1:         }
     1:       } else {
108991:         for (uint32_t i=0;i<mPrt->mPrintDocList.Length();i++) {
 24551:           nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
     1:           NS_ASSERTION(po, "nsPrintObject can't be null!");
     1:           nsCOMPtr<nsIDOMWindow> domWin = do_GetInterface(po->mDocShell);
     1:           if (IsThereARangeSelection(domWin)) {
     1:             mPrt->mCurrentFocusWin = domWin;
 80486:             SetPrintPO(po, true);
     1:             break;
     1:           }
     1:         }
     1:         return NS_OK;
     1:       }
     1:     }
     1:   }
     1: 
     1:   // check to see if there is a selection when a FrameSet is present
     1:   if (printRangeType == nsIPrintSettings::kRangeSelection) {
     1:     // If the currentFocusDOMWin can'r be null if something is selected
     1:     if (mPrt->mCurrentFocusWin) {
     1:       // Find the selected IFrame
     1:       nsPrintObject * po = FindPrintObjectByDOMWin(mPrt->mPrintObject, mPrt->mCurrentFocusWin);
106838:       if (po != nullptr) {
     1:         mPrt->mSelectedPO = po;
     1:         // Makes sure all of its children are be printed "AsIs"
     1:         SetPrintAsIs(po);
     1: 
     1:         // Now, only enable this POs (the selected PO) and all of its children
 80486:         SetPrintPO(po, true);
     1: 
     1:         // check to see if we have a range selection,
     1:         // as oppose to a insert selection
     1:         // this means if the user just clicked on the IFrame then
     1:         // there will not be a selection so we want the entire page to print
     1:         //
     1:         // XXX this is sort of a hack right here to make the page
     1:         // not try to reposition itself when printing selection
 35581:         nsCOMPtr<nsIDOMWindow> domWin =
 35581:           do_QueryInterface(po->mDocument->GetOriginalDocument()->GetWindow());
     1:         if (!IsThereARangeSelection(domWin)) {
     1:           printRangeType = nsIPrintSettings::kRangeAllPages;
     1:           mPrt->mPrintSettings->SetPrintRange(printRangeType);
     1:         }
     1:         PR_PL(("PrintFrameType:     %s \n", gPrintFrameTypeStr[mPrt->mPrintFrameType]));
     1:         PR_PL(("HowToEnableFrameUI: %s \n", gFrameHowToEnableStr[printHowEnable]));
     1:         PR_PL(("PrintRange:         %s \n", gPrintRangeStr[printRangeType]));
     1:         return NS_OK;
     1:       }
     1:     }
     1:   }
     1: 
     1:   // If we are printing "AsIs" then sets all the POs to be printed as is
     1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kFramesAsIs) {
     1:     SetPrintAsIs(mPrt->mPrintObject);
 80486:     SetPrintPO(mPrt->mPrintObject, true);
     1:     return NS_OK;
     1:   }
     1: 
     1:   // If we are printing the selected Frame then
     1:   // find that PO for that selected DOMWin and set it all of its
     1:   // children to be printed
     1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kSelectedFrame) {
     1: 
     1:     if ((mPrt->mIsParentAFrameSet && mPrt->mCurrentFocusWin) || mPrt->mIsIFrameSelected) {
     1:       nsPrintObject * po = FindPrintObjectByDOMWin(mPrt->mPrintObject, mPrt->mCurrentFocusWin);
106838:       if (po != nullptr) {
     1:         mPrt->mSelectedPO = po;
     1:         // NOTE: Calling this sets the "po" and
     1:         // we don't want to do this for documents that have no children,
     1:         // because then the "DoEndPage" gets called and it shouldn't
 24551:         if (po->mKids.Length() > 0) {
     1:           // Makes sure that itself, and all of its children are printed "AsIs"
     1:           SetPrintAsIs(po);
     1:         }
     1: 
     1:         // Now, only enable this POs (the selected PO) and all of its children
 80486:         SetPrintPO(po, true);
     1:       }
     1:     }
     1:     return NS_OK;
     1:   }
     1: 
     1:   // If we are print each subdoc separately,
     1:   // then don't print any of the FraneSet Docs
     1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kEachFrameSep) {
 80486:     SetPrintPO(mPrt->mPrintObject, true);
108991:     int32_t cnt = mPrt->mPrintDocList.Length();
108991:     for (int32_t i=0;i<cnt;i++) {
 24551:       nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
     1:       NS_ASSERTION(po, "nsPrintObject can't be null!");
     1:       if (po->mFrameType == eFrameSet) {
 80486:         po->mDontPrint = true;
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: // Return the nsPrintObject with that is XMost (The widest frameset frame) AND
     1: // contains the XMost (widest) layout frame
     1: nsPrintObject*
     1: nsPrintEngine::FindSmallestSTF()
     1: {
     1:   float smallestRatio = 1.0f;
106838:   nsPrintObject* smallestPO = nullptr;
     1: 
108991:   for (uint32_t i=0;i<mPrt->mPrintDocList.Length();i++) {
 24551:     nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
     1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
     1:     if (po->mFrameType != eFrameSet && po->mFrameType != eIFrame) {
     1:       if (po->mShrinkRatio < smallestRatio) {
     1:         smallestRatio = po->mShrinkRatio;
     1:         smallestPO    = po;
     1:       }
     1:     }
     1:   }
     1: 
     1: #ifdef EXTENDED_DEBUG_PRINTING
     1:   if (smallestPO) printf("*PO: %p  Type: %d  %10.3f\n", smallestPO, smallestPO->mFrameType, smallestPO->mShrinkRatio);
     1: #endif
     1:   return smallestPO;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: void
 79445: nsPrintEngine::TurnScriptingOn(bool aDoTurnOn)
     1: {
 25991:   if (mIsDoingPrinting && aDoTurnOn && mDocViewerPrint &&
 25991:       mDocViewerPrint->GetIsPrintPreview()) {
 25991:     // We don't want to turn scripting on if print preview is shown still after
 25991:     // printing.
 25991:     return;
 25991:   }
 25991: 
     1:   nsPrintData* prt = mPrt;
     1: #ifdef NS_PRINT_PREVIEW
     1:   if (!prt) {
     1:     prt = mPrtPreview;
     1:   }
     1: #endif
     1:   if (!prt) {
     1:     return;
     1:   }
     1: 
     1:   NS_ASSERTION(mDocument, "We MUST have a document.");
     1:   // First, get the script global object from the document...
     1: 
108991:   for (uint32_t i=0;i<prt->mPrintDocList.Length();i++) {
 24551:     nsPrintObject* po = prt->mPrintDocList.ElementAt(i);
     1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
     1: 
     1:     nsIDocument* doc = po->mDocument;
 25991:     if (!doc) {
 25991:       continue;
 25991:     }
     1: 
     1:     // get the script global object
     1:     nsIScriptGlobalObject *scriptGlobalObj = doc->GetScriptGlobalObject();
     1: 
     1:     if (scriptGlobalObj) {
 25991:       nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(scriptGlobalObj);
 25991:       NS_ASSERTION(window, "Can't get nsPIDOMWindow");
     1:       nsIScriptContext *scx = scriptGlobalObj->GetContext();
 25991:       NS_WARN_IF_FALSE(scx, "Can't get nsIScriptContext");
 25991:       nsresult propThere = NS_PROPTABLE_PROP_NOT_THERE;
 25991:       doc->GetProperty(nsGkAtoms::scriptEnabledBeforePrintOrPreview,
 25991:                        &propThere);
     1:       if (aDoTurnOn) {
 25991:         if (propThere != NS_PROPTABLE_PROP_NOT_THERE) {
 25991:           doc->DeleteProperty(nsGkAtoms::scriptEnabledBeforePrintOrPreview);
 25991:           if (scx) {
 80486:             scx->SetScriptsEnabled(true, false);
 80486:           }
 80486:           window->ResumeTimeouts(false);
 25991:         }
     1:       } else {
     1:         // Have to be careful, because people call us over and over again with
 80486:         // aDoTurnOn == false.  So don't set the property if it's already
     1:         // set, since in that case we'd set it to the wrong value.
     1:         if (propThere == NS_PROPTABLE_PROP_NOT_THERE) {
     1:           // Stash the current value of IsScriptEnabled on the document, so
     1:           // that layout code running in print preview doesn't get confused.
 25991:           doc->SetProperty(nsGkAtoms::scriptEnabledBeforePrintOrPreview,
     1:                            NS_INT32_TO_PTR(doc->IsScriptEnabled()));
 25991:           if (scx) {
 80486:             scx->SetScriptsEnabled(false, false);
 80486:           }
 80486:           window->SuspendTimeouts(1, false);
 25991:         }
 25991:       }
     1:     }
     1:   }
     1: }
     1: 
     1: //-----------------------------------------------------------------
     1: //-- Done: Misc Support Methods
     1: //-----------------------------------------------------------------
     1: 
     1: 
     1: //-----------------------------------------------------------------
     1: //-- Section: Finishing up or Cleaning up
     1: //-----------------------------------------------------------------
     1: 
     1: //-----------------------------------------------------------------
     1: void
     1: nsPrintEngine::CloseProgressDialog(nsIWebProgressListener* aWebProgressListener)
     1: {
     1:   if (aWebProgressListener) {
106838:     aWebProgressListener->OnStateChange(nullptr, nullptr, nsIWebProgressListener::STATE_STOP|nsIWebProgressListener::STATE_IS_DOCUMENT, NS_OK);
     1:   }
     1: }
     1: 
     1: //-----------------------------------------------------------------
     1: nsresult
     1: nsPrintEngine::FinishPrintPreview()
     1: {
     1:   nsresult rv = NS_OK;
     1: 
     1: #ifdef NS_PRINT_PREVIEW
     1: 
 14111:   if (!mPrt) {
 14111:     /* we're already finished with print preview */
 14111:     return rv;
 14111:   }
 14111: 
     1:   rv = DocumentReadyForPrinting();
     1: 
 80486:   SetIsCreatingPrintPreview(false);
     1: 
     1:   /* cleaup on failure + notify user */
     1:   if (NS_FAILED(rv)) {
     1:     /* cleanup done, let's fire-up an error dialog to notify the user
     1:      * what went wrong...
     1:      */
     1:     mPrt->OnEndPrinting();
 80486:     TurnScriptingOn(true);
     1: 
  7782:     return rv;
     1:   }
     1: 
     1:   // At this point we are done preparing everything
     1:   // before it is to be created
     1: 
     1: 
     1:   if (mIsDoingPrintPreview && mOldPrtPreview) {
     1:     delete mOldPrtPreview;
106838:     mOldPrtPreview = nullptr;
     1:   }
     1: 
     1: 
     1:   mPrt->OnEndPrinting();
     1: 
     1:   // PrintPreview was built using the mPrt (code reuse)
     1:   // then we assign it over
     1:   mPrtPreview = mPrt;
106838:   mPrt        = nullptr;
     1: 
     1: #endif // NS_PRINT_PREVIEW
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //-----------------------------------------------------------------
     1: //-- Done: Finishing up or Cleaning up
     1: //-----------------------------------------------------------------
     1: 
     1: 
     1: /*=============== Timer Related Code ======================*/
     1: nsresult
     1: nsPrintEngine::StartPagePrintTimer(nsPrintObject* aPO)
     1: {
     1:   if (!mPagePrintTimer) {
     1:     // Get the delay time in between the printing of each page
     1:     // this gives the user more time to press cancel
108991:     int32_t printPageDelay = 50;
     1:     mPrt->mPrintSettings->GetPrintPageDelay(&printPageDelay);
     1: 
111241:     nsRefPtr<nsPagePrintTimer> timer =
111241:       new nsPagePrintTimer(this, mDocViewerPrint, printPageDelay);
111241:     timer.forget(&mPagePrintTimer);
     1:   }
     1: 
     1:   return mPagePrintTimer->Start(aPO);
     1: }
     1: 
     1: /*=============== nsIObserver Interface ======================*/
     1: NS_IMETHODIMP 
     1: nsPrintEngine::Observe(nsISupports *aSubject, const char *aTopic, const PRUnichar *aData)
     1: {
     1:   nsresult rv = NS_ERROR_FAILURE;
     1: 
114469:   rv = InitPrintDocConstruction(true);
114469:   if (!mIsDoingPrinting && mPrtPreview) {
     1:       mPrtPreview->OnEndPrinting();
     1:   }
     1: 
     1:   return rv;
     1: 
     1: }
     1: 
     1: //---------------------------------------------------------------
     1: //-- PLEvent Notification
     1: //---------------------------------------------------------------
     1: class nsPrintCompletionEvent : public nsRunnable {
     1: public:
     1:   nsPrintCompletionEvent(nsIDocumentViewerPrint *docViewerPrint)
     1:     : mDocViewerPrint(docViewerPrint) {
     1:     NS_ASSERTION(mDocViewerPrint, "mDocViewerPrint is null.");
     1:   }
     1: 
     1:   NS_IMETHOD Run() {
     1:     if (mDocViewerPrint)
     1:       mDocViewerPrint->OnDonePrinting();
     1:     return NS_OK;
     1:   }
     1: 
     1: private:
     1:   nsCOMPtr<nsIDocumentViewerPrint> mDocViewerPrint;
     1: };
     1: 
     1: //-----------------------------------------------------------
     1: void
     1: nsPrintEngine::FirePrintCompletionEvent()
     1: {
     1:   nsCOMPtr<nsIRunnable> event = new nsPrintCompletionEvent(mDocViewerPrint);
     1:   if (NS_FAILED(NS_DispatchToCurrentThread(event)))
     1:     NS_WARNING("failed to dispatch print completion event");
     1: }
     1: 
     1: //---------------------------------------------------------------
     1: //---------------------------------------------------------------
     1: //-- Debug helper routines
     1: //---------------------------------------------------------------
     1: //---------------------------------------------------------------
     1: #if (defined(XP_WIN) || defined(XP_OS2)) && defined(EXTENDED_DEBUG_PRINTING)
     1: #include "windows.h"
     1: #include "process.h"
     1: #include "direct.h"
     1: 
     1: #define MY_FINDFIRST(a,b) FindFirstFile(a,b)
     1: #define MY_FINDNEXT(a,b) FindNextFile(a,b)
     1: #define ISDIR(a) (a.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
     1: #define MY_FINDCLOSE(a) FindClose(a)
     1: #define MY_FILENAME(a) a.cFileName
     1: #define MY_FILESIZE(a) (a.nFileSizeHigh * MAXDWORD) + a.nFileSizeLow
     1: 
     1: int RemoveFilesInDir(const char * aDir)
     1: {
     1: 	WIN32_FIND_DATA data_ptr;
     1: 	HANDLE find_handle;
     1: 
     1:   char path[MAX_PATH];
     1: 
     1:   strcpy(path, aDir);
     1: 
     1: 	// Append slash to the end of the directory names if not there
     1: 	if (path[strlen(path)-1] != '\\')
     1:     strcat(path, "\\");
     1: 
     1:   char findPath[MAX_PATH];
     1:   strcpy(findPath, path);
     1:   strcat(findPath, "*.*");
     1: 
     1: 	find_handle = MY_FINDFIRST(findPath, &data_ptr);
     1: 
     1: 	if (find_handle != INVALID_HANDLE_VALUE) {
     1: 		do  {
     1: 			if (ISDIR(data_ptr)
     1: 				&& (stricmp(MY_FILENAME(data_ptr),"."))
     1: 				&& (stricmp(MY_FILENAME(data_ptr),".."))) {
     1: 					// skip
     1: 			}
     1: 			else if (!ISDIR(data_ptr)) {
     1:         if (!strncmp(MY_FILENAME(data_ptr), "print_dump", 10)) {
     1:           char fileName[MAX_PATH];
     1:           strcpy(fileName, aDir);
     1:           strcat(fileName, "\\");
     1:           strcat(fileName, MY_FILENAME(data_ptr));
     1: 				  printf("Removing %s\n", fileName);
     1:           remove(fileName);
     1:         }
     1: 			}
     1: 		} while(MY_FINDNEXT(find_handle,&data_ptr));
     1: 		MY_FINDCLOSE(find_handle);
     1: 	}
     1: 	return TRUE;
     1: }
     1: #endif
     1: 
     1: #ifdef EXTENDED_DEBUG_PRINTING
     1: 
     1: /** ---------------------------------------------------
     1:  *  Dumps Frames for Printing
     1:  */
108991: static void RootFrameList(nsPresContext* aPresContext, FILE* out, int32_t aIndent)
     1: {
     1:   if (!aPresContext || !out)
     1:     return;
     1: 
     1:   nsIPresShell *shell = aPresContext->GetPresShell();
     1:   if (shell) {
     1:     nsIFrame* frame = shell->FrameManager()->GetRootFrame();
     1:     if (frame) {
 31709:       frame->List(aPresContext, out, aIndent);
     1:     }
     1:   }
     1: }
     1: 
     1: /** ---------------------------------------------------
     1:  *  Dumps Frames for Printing
     1:  */
     1: static void DumpFrames(FILE*                 out,
     1:                        nsPresContext*       aPresContext,
 68481:                        nsRenderingContext * aRendContext,
     1:                        nsIFrame *            aFrame,
108991:                        int32_t               aLevel)
     1: {
     1:   NS_ASSERTION(out, "Pointer is null!");
     1:   NS_ASSERTION(aPresContext, "Pointer is null!");
     1:   NS_ASSERTION(aRendContext, "Pointer is null!");
     1:   NS_ASSERTION(aFrame, "Pointer is null!");
     1: 
 77154:   nsIFrame* child = aFrame->GetFirstPrincipalChild();
106838:   while (child != nullptr) {
108991:     for (int32_t i=0;i<aLevel;i++) {
     1:      fprintf(out, "  ");
     1:     }
     1:     nsAutoString tmp;
 31709:     child->GetFrameName(tmp);
     1:     fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
 79445:     bool isSelected;
 80486:     if (NS_SUCCEEDED(child->IsVisibleForPainting(aPresContext, *aRendContext, true, &isSelected))) {
     1:       fprintf(out, " %p %s", child, isSelected?"VIS":"UVS");
     1:       nsRect rect = child->GetRect();
     1:       fprintf(out, "[%d,%d,%d,%d] ", rect.x, rect.y, rect.width, rect.height);
     1:       fprintf(out, "v: %p ", (void*)child->GetView());
     1:       fprintf(out, "\n");
     1:       DumpFrames(out, aPresContext, aRendContext, child, aLevel+1);
     1:       child = child->GetNextSibling();
     1:     }
     1:   }
     1: }
     1: 
     1: 
     1: /** ---------------------------------------------------
     1:  *  Dumps the Views from the DocShell
     1:  */
     1: static void
     1: DumpViews(nsIDocShell* aDocShell, FILE* out)
     1: {
     1:   NS_ASSERTION(aDocShell, "Pointer is null!");
     1:   NS_ASSERTION(out, "Pointer is null!");
     1: 
106838:   if (nullptr != aDocShell) {
     1:     fprintf(out, "docshell=%p \n", aDocShell);
     1:     nsIPresShell* shell = nsPrintEngine::GetPresShellFor(aDocShell);
     1:     if (shell) {
127607:       nsViewManager* vm = shell->GetViewManager();
     1:       if (vm) {
127357:         nsView* root = vm->GetRootView();
 64435:         if (root) {
     1:           root->List(out);
     1:         }
     1:       }
     1:     }
     1:     else {
     1:       fputs("null pres shell\n", out);
     1:     }
     1: 
     1:     // dump the views of the sub documents
108991:     int32_t i, n;
     1:     nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
     1:     docShellAsNode->GetChildCount(&n);
     1:     for (i = 0; i < n; i++) {
     1:       nsCOMPtr<nsIDocShellTreeItem> child;
     1:       docShellAsNode->GetChildAt(i, getter_AddRefs(child));
     1:       nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
     1:       if (childAsShell) {
     1:         DumpViews(childAsShell, out);
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: /** ---------------------------------------------------
     1:  *  Dumps the Views and Frames
     1:  */
     1: void DumpLayoutData(char*              aTitleStr,
     1:                     char*              aURLStr,
     1:                     nsPresContext*    aPresContext,
 68668:                     nsDeviceContext * aDC,
     1:                     nsIFrame *         aRootFrame,
     1:                     nsIDocShekk *      aDocShell,
106838:                     FILE*              aFD = nullptr)
     1: {
     1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
     1: 
106838:   if (aPresContext == nullptr || aDC == nullptr) {
     1:     return;
     1:   }
     1: 
     1: #ifdef NS_PRINT_PREVIEW
     1:   if (aPresContext->Type() == nsPresContext::eContext_PrintPreview) {
     1:     return;
     1:   }
     1: #endif
     1: 
     1:   NS_ASSERTION(aRootFrame, "Pointer is null!");
     1:   NS_ASSERTION(aDocShell, "Pointer is null!");
     1: 
     1:   // Dump all the frames and view to a a file
     1:   char filename[256];
     1:   sprintf(filename, "print_dump_layout_%d.txt", gDumpLOFileNameCnt++);
     1:   FILE * fd = aFD?aFD:fopen(filename, "w");
     1:   if (fd) {
     1:     fprintf(fd, "Title: %s\n", aTitleStr?aTitleStr:"");
     1:     fprintf(fd, "URL:   %s\n", aURLStr?aURLStr:"");
     1:     fprintf(fd, "--------------- Frames ----------------\n");
     1:     fprintf(fd, "--------------- Frames ----------------\n");
 68481:     nsRefPtr<nsRenderingContext> renderingContext;
     1:     aDC->CreateRenderingContext(*getter_AddRefs(renderingContext));
     1:     RootFrameList(aPresContext, fd, 0);
     1:     //DumpFrames(fd, aPresContext, renderingContext, aRootFrame, 0);
     1:     fprintf(fd, "---------------------------------------\n\n");
     1:     fprintf(fd, "--------------- Views From Root Frame----------------\n");
127357:     nsView* v = aRootFrame->GetView();
     1:     if (v) {
     1:       v->List(fd);
     1:     } else {
     1:       printf("View is null!\n");
     1:     }
     1:     if (aDocShell) {
     1:       fprintf(fd, "--------------- All Views ----------------\n");
     1:       DumpViews(aDocShell, fd);
     1:       fprintf(fd, "---------------------------------------\n\n");
     1:     }
106838:     if (aFD == nullptr) {
     1:       fclose(fd);
     1:     }
     1:   }
     1: }
     1: 
     1: //-------------------------------------------------------------
 24551: static void DumpPrintObjectsList(nsTArray<nsPrintObject*> * aDocList)
     1: {
     1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
     1: 
     1:   NS_ASSERTION(aDocList, "Pointer is null!");
     1: 
     1:   const char types[][3] = {"DC", "FR", "IF", "FS"};
     1:   PR_PL(("Doc List\n***************************************************\n"));
     1:   PR_PL(("T  P A H    PO    DocShell   Seq     Page      Root     Page#    Rect\n"));
108991:   int32_t cnt = aDocList->Length();
108991:   for (int32_t i=0;i<cnt;i++) {
 24551:     nsPrintObject* po = aDocList->ElementAt(i);
     1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
106838:     nsIFrame* rootFrame = nullptr;
     1:     if (po->mPresShell) {
     1:       rootFrame = po->mPresShell->FrameManager()->GetRootFrame();
106838:       while (rootFrame != nullptr) {
 23554:         nsIPageSequenceFrame * sqf = do_QueryFrame(rootFrame);
 23554:         if (sqf) {
     1:           break;
     1:         }
 77154:         rootFrame = rootFrame->GetFirstPrincipalChild();
     1:       }
     1:     }
     1: 
     1:     PR_PL(("%s %d %d %d %p %p %p %p %p   %d   %d,%d,%d,%d\n", types[po->mFrameType],
     1:             po->IsPrintable(), po->mPrintAsIs, po->mHasBeenPrinted, po, po->mDocShell.get(), po->mSeqFrame,
     1:             po->mPageFrame, rootFrame, po->mPageNum, po->mRect.x, po->mRect.y, po->mRect.width, po->mRect.height));
     1:   }
     1: }
     1: 
     1: //-------------------------------------------------------------
     1: static void DumpPrintObjectsTree(nsPrintObject * aPO, int aLevel, FILE* aFD)
     1: {
     1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
     1: 
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1: 
     1:   FILE * fd = aFD?aFD:stdout;
     1:   const char types[][3] = {"DC", "FR", "IF", "FS"};
     1:   if (aLevel == 0) {
     1:     fprintf(fd, "DocTree\n***************************************************\n");
     1:     fprintf(fd, "T     PO    DocShell   Seq      Page     Page#    Rect\n");
     1:   }
108991:   int32_t cnt = aPO->mKids.Length();
108991:   for (int32_t i=0;i<cnt;i++) {
 24551:     nsPrintObject* po = aPO->mKids.ElementAt(i);
     1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
108991:     for (int32_t k=0;k<aLevel;k++) fprintf(fd, "  ");
     1:     fprintf(fd, "%s %p %p %p %p %d %d,%d,%d,%d\n", types[po->mFrameType], po, po->mDocShell.get(), po->mSeqFrame,
     1:            po->mPageFrame, po->mPageNum, po->mRect.x, po->mRect.y, po->mRect.width, po->mRect.height);
     1:   }
     1: }
     1: 
     1: //-------------------------------------------------------------
     1: static void GetDocTitleAndURL(nsPrintObject* aPO, char *& aDocStr, char *& aURLStr)
     1: {
106838:   aDocStr = nullptr;
106838:   aURLStr = nullptr;
     1: 
     1:   PRUnichar * docTitleStr;
     1:   PRUnichar * docURLStr;
     1:   nsPrintEngine::GetDisplayTitleAndURL(aPO,
     1:                                             &docTitleStr, &docURLStr,
     1:                                             nsPrintEngine::eDocTitleDefURLDoc); 
     1: 
     1:   if (docTitleStr) {
     1:     nsAutoString strDocTitle(docTitleStr);
     1:     aDocStr = ToNewCString(strDocTitle);
     1:     nsMemory::Free(docTitleStr);
     1:   }
     1: 
     1:   if (docURLStr) {
     1:     nsAutoString strURL(docURLStr);
     1:     aURLStr = ToNewCString(strURL);
     1:     nsMemory::Free(docURLStr);
     1:   }
     1: }
     1: 
     1: //-------------------------------------------------------------
     1: static void DumpPrintObjectsTreeLayout(nsPrintObject * aPO,
 68668:                                        nsDeviceContext * aDC,
     1:                                        int aLevel, FILE * aFD)
     1: {
     1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
     1: 
     1:   NS_ASSERTION(aPO, "Pointer is null!");
     1:   NS_ASSERTION(aDC, "Pointer is null!");
     1: 
     1:   const char types[][3] = {"DC", "FR", "IF", "FS"};
106838:   FILE * fd = nullptr;
     1:   if (aLevel == 0) {
     1:     fd = fopen("tree_layout.txt", "w");
     1:     fprintf(fd, "DocTree\n***************************************************\n");
     1:     fprintf(fd, "***************************************************\n");
     1:     fprintf(fd, "T     PO    DocShell   Seq      Page     Page#    Rect\n");
     1:   } else {
     1:     fd = aFD;
     1:   }
     1:   if (fd) {
106838:     nsIFrame* rootFrame = nullptr;
     1:     if (aPO->mPresShell) {
     1:       rootFrame = aPO->mPresShell->FrameManager()->GetRootFrame();
     1:     }
108991:     for (int32_t k=0;k<aLevel;k++) fprintf(fd, "  ");
     1:     fprintf(fd, "%s %p %p %p %p %d %d,%d,%d,%d\n", types[aPO->mFrameType], aPO, aPO->mDocShell.get(), aPO->mSeqFrame,
     1:            aPO->mPageFrame, aPO->mPageNum, aPO->mRect.x, aPO->mRect.y, aPO->mRect.width, aPO->mRect.height);
     1:     if (aPO->IsPrintable()) {
     1:       char * docStr;
     1:       char * urlStr;
     1:       GetDocTitleAndURL(aPO, docStr, urlStr);
     1:       DumpLayoutData(docStr, urlStr, aPO->mPresContext, aDC, rootFrame, aPO->mDocShell, fd);
     1:       if (docStr) nsMemory::Free(docStr);
     1:       if (urlStr) nsMemory::Free(urlStr);
     1:     }
     1:     fprintf(fd, "<***************************************************>\n");
     1: 
108991:     int32_t cnt = aPO->mKids.Length();
108991:     for (int32_t i=0;i<cnt;i++) {
 24551:       nsPrintObject* po = aPO->mKids.ElementAt(i);
     1:       NS_ASSERTION(po, "nsPrintObject can't be null!");
     1:       DumpPrintObjectsTreeLayout(po, aDC, aLevel+1, fd);
     1:     }
     1:   }
     1:   if (aLevel == 0 && fd) {
     1:     fclose(fd);
     1:   }
     1: }
     1: 
     1: //-------------------------------------------------------------
 24551: static void DumpPrintObjectsListStart(const char * aStr, nsTArray<nsPrintObject*> * aDocList)
     1: {
     1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
     1: 
     1:   NS_ASSERTION(aStr, "Pointer is null!");
     1:   NS_ASSERTION(aDocList, "Pointer is null!");
     1: 
     1:   PR_PL(("%s\n", aStr));
     1:   DumpPrintObjectsList(aDocList);
     1: }
     1: 
     1: #define DUMP_DOC_LIST(_title) DumpPrintObjectsListStart((_title), mPrt->mPrintDocList);
     1: #define DUMP_DOC_TREE DumpPrintObjectsTree(mPrt->mPrintObject);
     1: #define DUMP_DOC_TREELAYOUT DumpPrintObjectsTreeLayout(mPrt->mPrintObject, mPrt->mPrintDC);
     1: 
     1: #else
     1: #define DUMP_DOC_LIST(_title)
     1: #define DUMP_DOC_TREE
     1: #define DUMP_DOC_TREELAYOUT
     1: #endif
     1: 
     1: //---------------------------------------------------------------
     1: //---------------------------------------------------------------
     1: //-- End of debug helper routines
     1: //---------------------------------------------------------------
