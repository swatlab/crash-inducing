    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Benjamin Smedberg <benjamin@smedbergs.us>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsXPCOM_h__
    1: #define nsXPCOM_h__
    1: 
    1: /* Map frozen functions to private symbol names if not using strict API. */
    1: #ifdef MOZILLA_INTERNAL_API
    1: # define NS_InitXPCOM2               NS_InitXPCOM2_P
    1: # define NS_InitXPCOM3               NS_InitXPCOM3_P
    1: # define NS_ShutdownXPCOM            NS_ShutdownXPCOM_P
    1: # define NS_GetServiceManager        NS_GetServiceManager_P
    1: # define NS_GetComponentManager      NS_GetComponentManager_P
    1: # define NS_GetComponentRegistrar    NS_GetComponentRegistrar_P
    1: # define NS_GetMemoryManager         NS_GetMemoryManager_P
    1: # define NS_NewLocalFile             NS_NewLocalFile_P
    1: # define NS_NewNativeLocalFile       NS_NewNativeLocalFile_P
    1: # define NS_GetDebug                 NS_GetDebug_P
    1: # define NS_GetTraceRefcnt           NS_GetTraceRefcnt_P
    1: # define NS_Alloc                    NS_Alloc_P
    1: # define NS_Realloc                  NS_Realloc_P
    1: # define NS_Free                     NS_Free_P
    1: # define NS_DebugBreak               NS_DebugBreak_P
    1: # define NS_LogInit                  NS_LogInit_P
    1: # define NS_LogTerm                  NS_LogTerm_P
    1: # define NS_LogAddRef                NS_LogAddRef_P
    1: # define NS_LogRelease               NS_LogRelease_P
    1: # define NS_LogCtor                  NS_LogCtor_P
    1: # define NS_LogDtor                  NS_LogDtor_P
    1: # define NS_LogCOMPtrAddRef          NS_LogCOMPtrAddRef_P
    1: # define NS_LogCOMPtrRelease         NS_LogCOMPtrRelease_P
 4305: # define NS_CycleCollectorSuspect    NS_CycleCollectorSuspect_P
 4305: # define NS_CycleCollectorForget     NS_CycleCollectorForget_P
28049: # define NS_CycleCollectorSuspect2   NS_CycleCollectorSuspect2_P
28049: # define NS_CycleCollectorForget2    NS_CycleCollectorForget2_P
    1: #endif
    1: 
    1: #include "nscore.h"
    1: #include "nsXPCOMCID.h"
    1: 
    1: #ifdef __cplusplus
    1: #define DECL_CLASS(c) class c
28049: #define DECL_STRUCT(c) struct c
    1: #else
    1: #define DECL_CLASS(c) typedef struct c c
28049: #define DECL_STRUCT(c) typedef struct c c
    1: #endif
    1: 
    1: DECL_CLASS(nsAString);
    1: DECL_CLASS(nsACString);
    1: 
    1: DECL_CLASS(nsISupports);
    1: DECL_CLASS(nsIModule);
    1: DECL_CLASS(nsIComponentManager);
    1: DECL_CLASS(nsIComponentRegistrar);
    1: DECL_CLASS(nsIServiceManager);
    1: DECL_CLASS(nsIFile);
    1: DECL_CLASS(nsILocalFile);
    1: DECL_CLASS(nsIDirectoryServiceProvider);
    1: DECL_CLASS(nsIMemory);
    1: DECL_CLASS(nsIDebug);
    1: DECL_CLASS(nsITraceRefcnt);
28049: DECL_STRUCT(nsPurpleBufferEntry);
    1: 
    1: /**
    1:  * Every XPCOM component implements this function signature, which is the
    1:  * only entrypoint XPCOM uses to the function.
    1:  *
    1:  * @status FROZEN
    1:  */
20261: typedef nsresult (*nsGetModuleProc)(nsIComponentManager *aCompMgr,
    1:                                     nsIFile* location,
    1:                                     nsIModule** return_cobj);
    1: 
    1: /**
    1:  * Initialises XPCOM. You must call one of the NS_InitXPCOM methods
    1:  * before proceeding to use xpcom. The one exception is that you may
    1:  * call NS_NewLocalFile to create a nsIFile.
    1:  * 
    1:  * @status FROZEN
    1:  *
    1:  * @note Use <CODE>NS_NewLocalFile</CODE> or <CODE>NS_NewNativeLocalFile</CODE> 
    1:  *       to create the file object you supply as the bin directory path in this
    1:  *       call. The function may be safely called before the rest of XPCOM or 
    1:  *       embedding has been initialised.
    1:  *
    1:  * @param result           The service manager.  You may pass null.
    1:  *
    1:  * @param binDirectory     The directory containing the component
    1:  *                         registry and runtime libraries;
    1:  *                         or use <CODE>nsnull</CODE> to use the working
    1:  *                         directory.
    1:  *
    1:  * @param appFileLocationProvider The object to be used by Gecko that specifies
    1:  *                         to Gecko where to find profiles, the component
    1:  *                         registry preferences and so on; or use
    1:  *                         <CODE>nsnull</CODE> for the default behaviour.
    1:  *
    1:  * @see NS_NewLocalFile
    1:  * @see nsILocalFile
    1:  * @see nsIDirectoryServiceProvider
    1:  *
    1:  * @return NS_OK for success;
    1:  *         NS_ERROR_NOT_INITIALIZED if static globals were not initialized,
    1:  *         which can happen if XPCOM is reloaded, but did not completly
    1:  *         shutdown. Other error codes indicate a failure during
    1:  *         initialisation.
    1:  */
    1: XPCOM_API(nsresult)
    1: NS_InitXPCOM2(nsIServiceManager* *result, 
    1:               nsIFile* binDirectory,
    1:               nsIDirectoryServiceProvider* appFileLocationProvider);
    1: 
    1: /**
    1:  * Some clients of XPCOM have statically linked components (not dynamically
    1:  * loaded component DLLs), which can be passed to NS_InitXPCOM3 using this
    1:  * structure.
    1:  *
    1:  * @status FROZEN
    1:  */
    1: typedef struct nsStaticModuleInfo {
    1:   const char      *name;
    1:   nsGetModuleProc  getModule;
    1: } nsStaticModuleInfo;
    1: 
    1: /**
    1:  * Initialises XPCOM with static components. You must call one of the
    1:  * NS_InitXPCOM methods before proceeding to use xpcom. The one
    1:  * exception is that you may call NS_NewLocalFile to create a nsIFile.
    1:  * 
    1:  * @status FROZEN
    1:  *
    1:  * @note Use <CODE>NS_NewLocalFile</CODE> or <CODE>NS_NewNativeLocalFile</CODE> 
    1:  *       to create the file object you supply as the bin directory path in this
    1:  *       call. The function may be safely called before the rest of XPCOM or 
    1:  *       embedding has been initialised.
    1:  *
    1:  * @param result           The service manager.  You may pass null.
    1:  *
    1:  * @param binDirectory     The directory containing the component
    1:  *                         registry and runtime libraries;
    1:  *                         or use <CODE>nsnull</CODE> to use the working
    1:  *                         directory.
    1:  *
    1:  * @param appFileLocationProvider The object to be used by Gecko that specifies
    1:  *                         to Gecko where to find profiles, the component
    1:  *                         registry preferences and so on; or use
    1:  *                         <CODE>nsnull</CODE> for the default behaviour.
    1:  *
    1:  * @param staticComponents An array of static components. Passing null causes
    1:  *                         default (builtin) components to be registered, if
    1:  *                         present.
    1:  * @param componentCount   Number of elements in staticComponents
    1:  *
    1:  * @see NS_NewLocalFile
    1:  * @see nsILocalFile
    1:  * @see nsIDirectoryServiceProvider
    1:  * @see XRE_GetStaticComponents
    1:  *
    1:  * @return NS_OK for success;
    1:  *         NS_ERROR_NOT_INITIALIZED if static globals were not initialized,
    1:  *         which can happen if XPCOM is reloaded, but did not completly
    1:  *         shutdown. Other error codes indicate a failure during
    1:  *         initialisation.
    1:  */
    1: XPCOM_API(nsresult)
    1: NS_InitXPCOM3(nsIServiceManager* *result, 
    1:               nsIFile* binDirectory,
    1:               nsIDirectoryServiceProvider* appFileLocationProvider,
    1:               nsStaticModuleInfo const *staticComponents,
    1:               PRUint32 componentCount);
    1: 
    1: /**
    1:  * Shutdown XPCOM. You must call this method after you are finished
    1:  * using xpcom. 
    1:  *
    1:  * @status FROZEN
    1:  *
    1:  * @param servMgr           The service manager which was returned by NS_InitXPCOM.
    1:  *                          This will release servMgr.  You may pass null.
    1:  *
    1:  * @return NS_OK for success;
    1:  *         other error codes indicate a failure during initialisation.
    1:  *
    1:  */
    1: XPCOM_API(nsresult)
    1: NS_ShutdownXPCOM(nsIServiceManager* servMgr);
    1: 
    1: 
    1: /**
    1:  * Public Method to access to the service manager.
    1:  * 
    1:  * @status FROZEN
    1:  * @param result Interface pointer to the service manager 
    1:  *
    1:  * @return NS_OK for success;
    1:  *         other error codes indicate a failure during initialisation.
    1:  *
    1:  */
    1: XPCOM_API(nsresult)
    1: NS_GetServiceManager(nsIServiceManager* *result);
    1: 
    1: /**
    1:  * Public Method to access to the component manager.
    1:  * 
    1:  * @status FROZEN
    1:  * @param result Interface pointer to the service 
    1:  *
    1:  * @return NS_OK for success;
    1:  *         other error codes indicate a failure during initialisation.
    1:  *
    1:  */
    1: XPCOM_API(nsresult)
    1: NS_GetComponentManager(nsIComponentManager* *result);
    1: 
    1: /**
    1:  * Public Method to access to the component registration manager.
    1:  * 
    1:  * @status FROZEN
    1:  * @param result Interface pointer to the service 
    1:  *
    1:  * @return NS_OK for success;
    1:  *         other error codes indicate a failure during initialisation.
    1:  *
    1:  */
    1: XPCOM_API(nsresult)
    1: NS_GetComponentRegistrar(nsIComponentRegistrar* *result);
    1: 
    1: /**
    1:  * Public Method to access to the memory manager.  See nsIMemory
    1:  * 
    1:  * @status FROZEN
    1:  * @param result Interface pointer to the memory manager 
    1:  *
    1:  * @return NS_OK for success;
    1:  *         other error codes indicate a failure during initialisation.
    1:  *
    1:  */
    1: XPCOM_API(nsresult)
    1: NS_GetMemoryManager(nsIMemory* *result);
    1: 
    1: /**
    1:  * Public Method to create an instance of a nsILocalFile.  This function
    1:  * may be called prior to NS_InitXPCOM.
    1:  * 
    1:  * @status FROZEN
    1:  * 
    1:  *   @param path       
    1:  *       A string which specifies a full file path to a 
    1:  *       location.  Relative paths will be treated as an
    1:  *       error (NS_ERROR_FILE_UNRECOGNIZED_PATH).       
    1:  *       |NS_NewNativeLocalFile|'s path must be in the 
    1:  *       filesystem charset.
    1:  *   @param followLinks
    1:  *       This attribute will determine if the nsLocalFile will auto
    1:  *       resolve symbolic links.  By default, this value will be false
    1:  *       on all non unix systems.  On unix, this attribute is effectively
    1:  *       a noop.  
    1:  * @param result Interface pointer to a new instance of an nsILocalFile 
    1:  *
    1:  * @return NS_OK for success;
    1:  *         other error codes indicate a failure.
    1:  */
    1: 
    1: #ifdef __cplusplus
    1: 
    1: XPCOM_API(nsresult)
    1: NS_NewLocalFile(const nsAString &path, 
    1:                 PRBool followLinks, 
    1:                 nsILocalFile* *result);
    1: 
    1: XPCOM_API(nsresult)
    1: NS_NewNativeLocalFile(const nsACString &path, 
    1:                       PRBool followLinks, 
    1:                       nsILocalFile* *result);
    1: 
    1: #endif
    1: 
    1: /**
    1:  * Allocates a block of memory of a particular size. If the memory cannot
    1:  * be allocated (because of an out-of-memory condition), null is returned.
    1:  *
    1:  * @status FROZEN
    1:  *
    1:  * @param size   The size of the block to allocate
    1:  * @result       The block of memory
    1:  * @note         This function is thread-safe.
    1:  */
    1: XPCOM_API(void*)
    1: NS_Alloc(PRSize size);
    1: 
    1: /**
    1:  * Reallocates a block of memory to a new size.
    1:  *
    1:  * @status FROZEN
    1:  *
    1:  * @param ptr     The block of memory to reallocate. This block must originally
    1:                   have been allocated by NS_Alloc or NS_Realloc
    1:  * @param size    The new size. If 0, frees the block like NS_Free
    1:  * @result        The reallocated block of memory
    1:  * @note          This function is thread-safe.
    1:  *
    1:  * If ptr is null, this function behaves like NS_Alloc.
    1:  * If s is the size of the block to which ptr points, the first min(s, size)
    1:  * bytes of ptr's block are copied to the new block. If the allocation
    1:  * succeeds, ptr is freed and a pointer to the new block is returned. If the
    1:  * allocation fails, ptr is not freed and null is returned. The returned
    1:  * value may be the same as ptr.
    1:  */
    1: XPCOM_API(void*)
    1: NS_Realloc(void* ptr, PRSize size);
    1: 
    1: /**
    1:  * Frees a block of memory. Null is a permissible value, in which case no
    1:  * action is taken.
    1:  *
    1:  * @status FROZEN
    1:  *
    1:  * @param ptr   The block of memory to free. This block must originally have
    1:  *              been allocated by NS_Alloc or NS_Realloc
    1:  * @note        This function is thread-safe.
    1:  */
    1: XPCOM_API(void)
    1: NS_Free(void* ptr);
    1: 
    1: /**
    1:  * Support for warnings, assertions, and debugging breaks.
    1:  */
    1: 
    1: enum {
    1:     NS_DEBUG_WARNING = 0,
    1:     NS_DEBUG_ASSERTION = 1,
    1:     NS_DEBUG_BREAK = 2,
    1:     NS_DEBUG_ABORT = 3
    1: };
    1: 
    1: /**
    1:  * Print a runtime assertion. This function is available in both debug and
    1:  * release builds.
    1:  * 
    1:  * @note Based on the value of aSeverity and the XPCOM_DEBUG_BREAK
    1:  * environment variable, this function may cause the application to
    1:  * print the warning, print a stacktrace, break into a debugger, or abort
    1:  * immediately.
    1:  *
    1:  * @param aSeverity A NS_DEBUG_* value
    1:  * @param aStr   A readable error message (ASCII, may be null)
    1:  * @param aExpr  The expression evaluated (may be null)
    1:  * @param aFile  The source file containing the assertion (may be null)
    1:  * @param aLine  The source file line number (-1 indicates no line number)
    1:  */
    1: XPCOM_API(void)
    1: NS_DebugBreak(PRUint32 aSeverity,
    1:               const char *aStr, const char *aExpr,
    1:               const char *aFile, PRInt32 aLine);
    1: 
    1: /**
    1:  * Perform a stack-walk to a debugging log under various
    1:  * circumstances. Used to aid debugging of leaked object graphs.
    1:  *
    1:  * The NS_Log* functions are available in both debug and release
    1:  * builds of XPCOM, but the output will be useless unless binary
    1:  * debugging symbols for all modules in the stacktrace are available.
    1:  */
    1: 
    1: /**
    1:  * By default, refcount logging is enabled at NS_InitXPCOM and
    1:  * refcount statistics are printed at NS_ShutdownXPCOM. NS_LogInit and
    1:  * NS_LogTerm allow applications to enable logging earlier and delay
    1:  * printing of logging statistics. They should always be used as a
    1:  * matched pair.
    1:  */
    1: XPCOM_API(void)
    1: NS_LogInit();
    1: 
    1: XPCOM_API(void)
    1: NS_LogTerm();
    1: 
    1: /**
    1:  * Log construction and destruction of objects. Processing tools can use the
    1:  * stacktraces printed by these functions to identify objects that are being
    1:  * leaked.
    1:  *
    1:  * @param aPtr          A pointer to the concrete object.
    1:  * @param aTypeName     The class name of the type
    1:  * @param aInstanceSize The size of the type
    1:  */
    1: 
    1: XPCOM_API(void)
    1: NS_LogCtor(void *aPtr, const char *aTypeName, PRUint32 aInstanceSize);
    1: 
    1: XPCOM_API(void)
    1: NS_LogDtor(void *aPtr, const char *aTypeName, PRUint32 aInstanceSize);
    1: 
    1: /**
    1:  * Log a stacktrace when an XPCOM object's refcount is incremented or
    1:  * decremented. Processing tools can use the stacktraces printed by these
    1:  * functions to identify objects that were leaked due to XPCOM references.
    1:  *
    1:  * @param aPtr          A pointer to the concrete object
    1:  * @param aNewRefCnt    The new reference count.
    1:  * @param aTypeName     The class name of the type
    1:  * @param aInstanceSize The size of the type
    1:  */
    1: XPCOM_API(void)
    1: NS_LogAddRef(void *aPtr, nsrefcnt aNewRefCnt,
    1:              const char *aTypeName, PRUint32 aInstanceSize);
    1: 
    1: XPCOM_API(void)
    1: NS_LogRelease(void *aPtr, nsrefcnt aNewRefCnt, const char *aTypeName);
    1: 
    1: /**
    1:  * Log reference counting performed by COMPtrs. Processing tools can
    1:  * use the stacktraces printed by these functions to simplify reports
    1:  * about leaked objects generated from the data printed by
    1:  * NS_LogAddRef/NS_LogRelease.
    1:  *
    1:  * @param aCOMPtr the address of the COMPtr holding a strong reference
    1:  * @param aObject the object being referenced by the COMPtr
    1:  */
    1: 
    1: XPCOM_API(void)
    1: NS_LogCOMPtrAddRef(void *aCOMPtr, nsISupports *aObject);
    1: 
    1: XPCOM_API(void)
    1: NS_LogCOMPtrRelease(void *aCOMPtr, nsISupports *aObject);
    1: 
    1: /**
 4305:  * The XPCOM cycle collector analyzes and breaks reference cycles between
 4305:  * participating XPCOM objects. All objects in the cycle must implement
 4305:  * nsCycleCollectionParticipant to break cycles correctly.
28049:  *
28049:  * The first two functions below exist only to support binary components
28049:  * that were compiled for older XPCOM versions.
 4305:  */
 4305: XPCOM_API(PRBool)
 4305: NS_CycleCollectorSuspect(nsISupports *n);
 4305: 
 4305: XPCOM_API(PRBool)
 4305: NS_CycleCollectorForget(nsISupports *n);
 4305: 
28049: XPCOM_API(nsPurpleBufferEntry*)
28049: NS_CycleCollectorSuspect2(nsISupports *n);
28049: 
28049: XPCOM_API(PRBool)
28049: NS_CycleCollectorForget2(nsPurpleBufferEntry *e);
28049: 
 4305: /**
    1:  * Categories (in the category manager service) used by XPCOM:
    1:  */
    1: 
    1: /**
    1:  * A category which is read after component registration but before
    1:  * the "xpcom-startup" notifications. Each category entry is treated
    1:  * as the contract ID of a service which implements
    1:  * nsIDirectoryServiceProvider. Each directory service provider is
    1:  * installed in the global directory service.
    1:  *
    1:  * @status FROZEN
    1:  */
    1: #define XPCOM_DIRECTORY_PROVIDER_CATEGORY "xpcom-directory-providers"
    1: 
    1: /**
    1:  * A category which is read after component registration but before
    1:  * NS_InitXPCOM returns. Each category entry is treated as the contractID of
    1:  * a service: each service is instantiated, and if it implements nsIObserver
    1:  * the nsIObserver.observe method is called with the "xpcom-startup" topic.
    1:  *
    1:  * @status FROZEN
    1:  */
    1: #define NS_XPCOM_STARTUP_CATEGORY "xpcom-startup"
    1: 
    1: 
    1: /**
    1:  * Observer topics (in the observer service) used by XPCOM:
    1:  */
    1: 
    1: /**
    1:  * At XPCOM startup after component registration is complete, the
    1:  * following topic is notified. In order to receive this notification,
    1:  * component must register their contract ID in the category manager,
    1:  *
    1:  * @see NS_XPCOM_STARTUP_CATEGORY
    1:  * @status FROZEN
    1:  */
    1: #define NS_XPCOM_STARTUP_OBSERVER_ID "xpcom-startup"
    1: 
    1: /**
35179:  * At XPCOM shutdown, this topic is notified just before "xpcom-shutdown".
35179:  * Components should only use this to mark themselves as 'being destroyed'.
35179:  * Nothing should be dispatched to any event loop.
35179:  */
35179: #define NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID "xpcom-will-shutdown"
35179: 
35179: /**
    1:  * At XPCOM shutdown, this topic is notified. All components must
    1:  * release any interface references to objects in other modules when
    1:  * this topic is notified.
    1:  *
    1:  * @status FROZEN
    1:  */
    1: #define NS_XPCOM_SHUTDOWN_OBSERVER_ID "xpcom-shutdown"
    1: 
    1: /**
    1:  * This topic is notified when an entry was added to a category in the
    1:  * category manager. The subject of the notification will be the name of
    1:  * the added entry as an nsISupportsCString, and the data will be the
    1:  * name of the category. The notification will occur on the main thread.
    1:  *
    1:  * @status FROZEN
    1:  */
    1: #define NS_XPCOM_CATEGORY_ENTRY_ADDED_OBSERVER_ID \
    1:   "xpcom-category-entry-added"
    1: 
    1: /**
    1:  * This topic is notified when an entry was removed from a category in the
    1:  * category manager. The subject of the notification will be the name of
    1:  * the removed entry as an nsISupportsCString, and the data will be the
    1:  * name of the category. The notification will occur on the main thread.
    1:  *
    1:  * @status FROZEN
    1:  */
    1: #define NS_XPCOM_CATEGORY_ENTRY_REMOVED_OBSERVER_ID \
    1:   "xpcom-category-entry-removed"
    1: 
    1: /**
    1:  * This topic is notified when an a category was cleared in the category
    1:  * manager. The subject of the notification will be the category manager,
    1:  * and the data will be the name of the cleared category.
    1:  * The notification will occur on the main thread.
    1:  *
    1:  * @status FROZEN
    1:  */
    1: #define NS_XPCOM_CATEGORY_CLEARED_OBSERVER_ID "xpcom-category-cleared"
    1: 
    1: XPCOM_API(nsresult)
    1: NS_GetDebug(nsIDebug* *result);
    1: 
    1: XPCOM_API(nsresult)
    1: NS_GetTraceRefcnt(nsITraceRefcnt* *result);
    1: 
    1: #endif
