36949: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
36949:  * ***** BEGIN LICENSE BLOCK *****
36949:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
36949:  *
36949:  * The contents of this file are subject to the Mozilla Public License Version
36949:  * 1.1 (the "License"); you may not use this file except in compliance with
36949:  * the License. You may obtain a copy of the License at
36949:  * http://www.mozilla.org/MPL/
36949:  *
36949:  * Software distributed under the License is distributed on an "AS IS" basis,
36949:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
36949:  * for the specific language governing rights and limitations under the
36949:  * License.
36949:  *
36949:  * The Original Code is Mozilla Corporation code.
36949:  *
36949:  * The Initial Developer of the Original Code is Mozilla Corporation.
36949:  * Portions created by the Initial Developer are Copyright (C) 2009
36949:  * the Initial Developer. All Rights Reserved.
36949:  *
36949:  * Contributor(s):
36949:  *   Stuart Parmenter <stuart@mozilla.com>
36949:  *   Masayuki Nakano <masayuki@d-toybox.com>
36949:  *   John Daggett <jdaggett@mozilla.com>
36949:  *   Jonathan Kew <jfkthame@gmail.com>
36949:  *
36949:  * Alternatively, the contents of this file may be used under the terms of
36949:  * either the GNU General Public License Version 2 or later (the "GPL"), or
36949:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
36949:  * in which case the provisions of the GPL or the LGPL are applicable instead
36949:  * of those above. If you wish to allow use of your version of this file only
36949:  * under the terms of either the GPL or the LGPL, and not to allow others to
36949:  * use your version of this file under the terms of the MPL, indicate your
36949:  * decision by deleting the provisions above and replace them with the notice
36949:  * and other provisions required by the GPL or the LGPL. If you do not delete
36949:  * the provisions above, a recipient may use your version of this file under
36949:  * the terms of any one of the MPL, the GPL or the LGPL.
36949:  *
36949:  * ***** END LICENSE BLOCK ***** */
36949: 
36949: #ifndef GFX_GDIFONTLIST_H
36949: #define GFX_GDIFONTLIST_H
36949: 
36949: #include "gfxWindowsPlatform.h"
36949: #include "gfxPlatformFontList.h"
38716: #include "gfxAtoms.h"
36949: 
36949: #include <windows.h>
36949: 
36949: class AutoDC // get the global device context, and auto-release it on destruction
36949: {
36949: public:
36949:     AutoDC() {
36949:         mDC = ::GetDC(NULL);
36949:     }
36949: 
36949:     ~AutoDC() {
36949:         ::ReleaseDC(NULL, mDC);
36949:     }
36949: 
36949:     HDC GetDC() {
36949:         return mDC;
36949:     }
36949: 
36949: private:
36949:     HDC mDC;
36949: };
36949: 
36949: class AutoSelectFont // select a font into the given DC, and auto-restore
36949: {
36949: public:
39447:     AutoSelectFont(HDC aDC, LOGFONTW *aLogFont)
39447:         : mOwnsFont(PR_FALSE)
39447:     {
36949:         mFont = ::CreateFontIndirectW(aLogFont);
36949:         if (mFont) {
39447:             mOwnsFont = PR_TRUE;
36949:             mDC = aDC;
36949:             mOldFont = (HFONT)::SelectObject(aDC, mFont);
36949:         } else {
36949:             mOldFont = NULL;
36949:         }
36949:     }
36949: 
39447:     AutoSelectFont(HDC aDC, HFONT aFont)
39447:         : mOwnsFont(PR_FALSE)
39447:     {
36949:         mDC = aDC;
36949:         mFont = aFont;
36949:         mOldFont = (HFONT)::SelectObject(aDC, aFont);
36949:     }
36949: 
36949:     ~AutoSelectFont() {
36949:         if (mOldFont) {
36949:             ::SelectObject(mDC, mOldFont);
39447:             if (mOwnsFont) {
39447:                 ::DeleteObject(mFont);
39447:             }
36949:         }
36949:     }
36949: 
36949:     PRBool IsValid() const {
36949:         return mFont != NULL;
36949:     }
36949: 
36949:     HFONT GetFont() const {
36949:         return mFont;
36949:     }
36949: 
36949: private:
36949:     HDC    mDC;
36949:     HFONT  mFont;
36949:     HFONT  mOldFont;
39447:     PRBool mOwnsFont;
36949: };
36949: 
36949: /**
36949:  * List of different types of fonts we support on Windows.
36949:  * These can generally be lumped in to 3 categories where we have to
36949:  * do special things:  Really old fonts bitmap and vector fonts (device
36949:  * and raster), Type 1 fonts, and TrueType/OpenType fonts.
36949:  * 
36949:  * This list is sorted in order from least prefered to most prefered.
36949:  * We prefer Type1 fonts over OpenType fonts to avoid falling back to
36949:  * things like Arial (opentype) when you ask for Helvetica (type1)
36949:  **/
36949: enum gfxWindowsFontType {
36949:     GFX_FONT_TYPE_UNKNOWN = 0,
36949:     GFX_FONT_TYPE_DEVICE,
36949:     GFX_FONT_TYPE_RASTER,
36949:     GFX_FONT_TYPE_TRUETYPE,
36949:     GFX_FONT_TYPE_PS_OPENTYPE,
36949:     GFX_FONT_TYPE_TT_OPENTYPE,
36949:     GFX_FONT_TYPE_TYPE1
36949: };
36949: 
36949: // A single member of a font family (i.e. a single face, such as Times Italic)
36949: // represented as a LOGFONT that will resolve to the correct face.
36949: // This replaces FontEntry from gfxWindowsFonts.h/cpp.
36949: class GDIFontEntry : public gfxFontEntry
36949: {
36949: public:
36949:     LPLOGFONTW GetLogFont() { return &mLogFont; }
36949: 
36949:     nsresult ReadCMAP();
36949: 
36949:     void FillLogFont(LOGFONTW *aLogFont, PRBool aItalic,
42854:                      PRUint16 aWeight, gfxFloat aSize, PRBool aUseCleartype);
36949: 
36949:     static gfxWindowsFontType DetermineFontType(const NEWTEXTMETRICW& metrics, 
36949:                                                 DWORD fontType)
36949:     {
36949:         gfxWindowsFontType feType;
36949:         if (metrics.ntmFlags & NTM_TYPE1)
36949:             feType = GFX_FONT_TYPE_TYPE1;
36949:         else if (metrics.ntmFlags & NTM_PS_OPENTYPE)
36949:             feType = GFX_FONT_TYPE_PS_OPENTYPE;
36949:         else if (metrics.ntmFlags & NTM_TT_OPENTYPE)
36949:             feType = GFX_FONT_TYPE_TT_OPENTYPE;
36949:         else if (fontType == TRUETYPE_FONTTYPE)
36949:             feType = GFX_FONT_TYPE_TRUETYPE;
36949:         else if (fontType == RASTER_FONTTYPE)
36949:             feType = GFX_FONT_TYPE_RASTER;
36949:         else if (fontType == DEVICE_FONTTYPE)
36949:             feType = GFX_FONT_TYPE_DEVICE;
36949:         else
36949:             feType = GFX_FONT_TYPE_UNKNOWN;
36949:         
36949:         return feType;
36949:     }
36949: 
36949:     PRBool IsType1() const {
36949:         return (mFontType == GFX_FONT_TYPE_TYPE1);
36949:     }
36949: 
36949:     PRBool IsTrueType() const {
36949:         return (mFontType == GFX_FONT_TYPE_TRUETYPE ||
36949:                 mFontType == GFX_FONT_TYPE_PS_OPENTYPE ||
36949:                 mFontType == GFX_FONT_TYPE_TT_OPENTYPE);
36949:     }
36949: 
36949:     PRBool IsCrappyFont() const {
36949:         /* return if it is a bitmap not a unicode font */
36949:         return (!mUnicodeFont || IsSymbolFont() || IsType1());
36949:     }
36949: 
38716:     virtual PRBool MatchesGenericFamily(const nsACString& aGeneric) const {
38716:         if (aGeneric.IsEmpty()) {
36949:             return PR_TRUE;
38716:         }
36949: 
36949:         // Japanese 'Mincho' fonts do not belong to FF_MODERN even if
36949:         // they are fixed pitch because they have variable stroke width.
36949:         if (mWindowsFamily == FF_ROMAN && mWindowsPitch & FIXED_PITCH) {
36949:             return aGeneric.EqualsLiteral("monospace");
36949:         }
36949: 
36949:         // Japanese 'Gothic' fonts do not belong to FF_SWISS even if
36949:         // they are variable pitch because they have constant stroke width.
36949:         if (mWindowsFamily == FF_MODERN && mWindowsPitch & VARIABLE_PITCH) {
36949:             return aGeneric.EqualsLiteral("sans-serif");
36949:         }
36949: 
36949:         // All other fonts will be grouped correctly using family...
36949:         switch (mWindowsFamily) {
36949:         case FF_DONTCARE:
47308:             return PR_FALSE;
36949:         case FF_ROMAN:
36949:             return aGeneric.EqualsLiteral("serif");
36949:         case FF_SWISS:
36949:             return aGeneric.EqualsLiteral("sans-serif");
36949:         case FF_MODERN:
36949:             return aGeneric.EqualsLiteral("monospace");
36949:         case FF_SCRIPT:
36949:             return aGeneric.EqualsLiteral("cursive");
36949:         case FF_DECORATIVE:
36949:             return aGeneric.EqualsLiteral("fantasy");
36949:         }
36949: 
36949:         return PR_FALSE;
36949:     }
36949: 
38716:     virtual PRBool SupportsLangGroup(nsIAtom* aLangGroup) const {
47307:         if (!aLangGroup || aLangGroup == gfxAtoms::x_unicode) {
36949:             return PR_TRUE;
38716:         }
36949: 
36949:         PRInt16 bit = -1;
36949: 
36949:         /* map our langgroup names in to Windows charset bits */
38716:         if (aLangGroup == gfxAtoms::x_western) {
36949:             bit = ANSI_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::ja) {
36949:             bit = SHIFTJIS_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::ko) {
36949:             bit = HANGEUL_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::ko_xxx) {
36949:             bit = JOHAB_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::zh_cn) {
36949:             bit = GB2312_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::zh_tw) {
36949:             bit = CHINESEBIG5_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::el) {
36949:             bit = GREEK_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::tr) {
36949:             bit = TURKISH_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::he) {
36949:             bit = HEBREW_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::ar) {
36949:             bit = ARABIC_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::x_baltic) {
36949:             bit = BALTIC_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::x_cyrillic) {
36949:             bit = RUSSIAN_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::th) {
36949:             bit = THAI_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::x_central_euro) {
36949:             bit = EASTEUROPE_CHARSET;
38716:         } else if (aLangGroup == gfxAtoms::x_symbol) {
36949:             bit = SYMBOL_CHARSET;
36949:         }
36949: 
38716:         if (bit != -1) {
37209:             return mCharset.test(bit);
38716:         }
36949: 
36949:         return PR_FALSE;
36949:     }
36949: 
38716:     virtual PRBool SupportsRange(PRUint8 range) {
37209:         return mUnicodeRanges.test(range);
36949:     }
36949: 
46221:     virtual PRBool SkipDuringSystemFallback() { 
46221:         return !HasCmapTable(); // explicitly skip non-SFNT fonts
46221:     }
46221: 
38716:     virtual PRBool TestCharacterMap(PRUint32 aCh);
36949: 
36949:     // create a font entry for a font with a given name
36949:     static GDIFontEntry* CreateFontEntry(const nsAString& aName, 
36949:                                       gfxWindowsFontType aFontType, 
36949:                                       PRBool aItalic, PRUint16 aWeight, 
36949:                                       gfxUserFontData* aUserFontData);
36949: 
36949:     // create a font entry for a font referenced by its fullname
36949:     static GDIFontEntry* LoadLocalFont(const gfxProxyFontEntry &aProxyEntry,
36949:                                     const nsAString& aFullname);
36949: 
36949:     PRUint8 mWindowsFamily;
36949:     PRUint8 mWindowsPitch;
36949: 
36949:     gfxWindowsFontType mFontType;
36949:     PRPackedBool mForceGDI    : 1;
36949:     PRPackedBool mUnknownCMAP : 1;
36949:     PRPackedBool mUnicodeFont : 1;
36949: 
37209:     gfxSparseBitSet mCharset;
37209:     gfxSparseBitSet mUnicodeRanges;
36949: 
36949: protected:
36949:     friend class gfxWindowsFont;
36949: 
36949:     GDIFontEntry(const nsAString& aFaceName, gfxWindowsFontType aFontType,
36949:                      PRBool aItalic, PRUint16 aWeight, gfxUserFontData *aUserFontData);
36949: 
43347:     void InitLogFont(const nsAString& aName, gfxWindowsFontType aFontType);
36949: 
37211:     virtual gfxFont *CreateFontInstance(const gfxFontStyle *aFontStyle, PRBool aNeedsBold);
37211: 
36949:     virtual nsresult GetFontTable(PRUint32 aTableTag, nsTArray<PRUint8>& aBuffer);
36949: 
36949:     LOGFONTW mLogFont;
36949: };
36949: 
36949: // a single font family, referencing one or more faces
36949: class GDIFontFamily : public gfxFontFamily
36949: {
36949: public:
36949:     GDIFontFamily(nsAString &aName) :
36949:         gfxFontFamily(aName) {}
36949: 
36949:     virtual void FindStyleVariations();
36949: 
36949: private:
36949:     static int CALLBACK FamilyAddStylesProc(const ENUMLOGFONTEXW *lpelfe,
36949:                                             const NEWTEXTMETRICEXW *nmetrics,
36949:                                             DWORD fontType, LPARAM data);
36949: };
36949: 
36949: class gfxGDIFontList : public gfxPlatformFontList {
36949: public:
36949:     static gfxGDIFontList* PlatformFontList() {
36949:         return static_cast<gfxGDIFontList*>(sPlatformFontList);
36949:     }
36949: 
57104:     // initialize font lists
57104:     virtual nsresult InitFontList();
57104: 
36949:     virtual gfxFontEntry* GetDefaultFont(const gfxFontStyle* aStyle, PRBool& aNeedsBold);
36949: 
36949:     virtual gfxFontEntry* LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
36949:                                           const nsAString& aFontName);
36949: 
36949:     virtual gfxFontEntry* MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
36949:                                            const PRUint8 *aFontData, PRUint32 aLength);
36949: 
36949:     virtual PRBool ResolveFontName(const nsAString& aFontName,
36949:                                    nsAString& aResolvedFontName);
36949: 
36949: private:
36949:     friend class gfxWindowsPlatform;
36949: 
36949:     gfxGDIFontList();
36949: 
36949:     void InitializeFontEmbeddingProcs();
36949: 
36949:     nsresult GetFontSubstitutes();
36949: 
36949:     static int CALLBACK EnumFontFamExProc(ENUMLOGFONTEXW *lpelfe,
36949:                                           NEWTEXTMETRICEXW *lpntme,
36949:                                           DWORD fontType,
36949:                                           LPARAM lParam);
36949: 
36949:     typedef nsDataHashtable<nsStringHashKey, nsRefPtr<gfxFontFamily> > FontTable;
36949: 
36949:     FontTable mFontSubstitutes;
36949:     nsTArray<nsString> mNonExistingFonts;
36949: };
36949: 
36949: #endif /* GFX_GDIFONTLIST_H */
