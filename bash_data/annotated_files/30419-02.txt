16299: /*
16299:    Copyright (C) 2003 Commonwealth Scientific and Industrial Research
16299:    Organisation (CSIRO) Australia
16299: 
16299:    Redistribution and use in source and binary forms, with or without
16299:    modification, are permitted provided that the following conditions
16299:    are met:
16299: 
16299:    - Redistributions of source code must retain the above copyright
16299:    notice, this list of conditions and the following disclaimer.
16299: 
16299:    - Redistributions in binary form must reproduce the above copyright
16299:    notice, this list of conditions and the following disclaimer in the
16299:    documentation and/or other materials provided with the distribution.
16299: 
16299:    - Neither the name of CSIRO Australia nor the names of its
16299:    contributors may be used to endorse or promote products derived from
16299:    this software without specific prior written permission.
16299: 
16299:    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
16299:    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
16299:    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
16299:    PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ORGANISATION OR
16299:    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
16299:    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
16299:    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
16299:    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
16299:    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
16299:    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
16299:    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
16299: */
16299: 
16299: /*
16299:  * oggplay_data.c
16299:  *
16299:  * Shane Stephens <shane.stephens@annodex.net>
16299:  */
16299: 
16299: #include "oggplay_private.h"
26904: #include "oggplay/oggplay_callback_info.h"
16299: 
16299: #include <stdlib.h>
16299: #include <string.h>
16299: 
16299: #if HAVE_INTTYPES_H
16299: #include <inttypes.h>
16299: #else
16299: #if LONG_MAX==2147483647L
16299: #define PRId64 "lld"
16299: #else
16299: #define PRId64 "ld"
16299: #endif
16299: #endif
16299: 
16299: /*
16299:  * the normal lifecycle for a frame is:
16299:  *
16299:  * (1) frame gets decoded and added to list with a locking value of 1
16299:  * (2) frame gets delivered to user
16299:  * (3) frame becomes out-of-date (its presentation time expires) and its
16299:  *      lock is decremented
16299:  * (4) frame is removed from list and freed
16299:  *
16299:  * This can be modified by:
16299:  * (a) early consumption by user (user calls oggplay_mark_record_consumed)
16299:  * (b) frame locking by user (user calls oggplay_mark_record_locked) and
16299:  *     subsequent unlocking (user calls oggplay_mark_record_consumed)
16299:  */
16299: 
16299: void
16299: oggplay_data_initialise_list (OggPlayDecode *decode) {
16299: 
16299:   decode->data_list = decode->end_of_data_list = NULL;
16299:   decode->untimed_data_list = NULL;
16299: 
16299: }
16299: 
16299: /*
16299:  * helper function to append data packets to end of data_list
16299:  */
16299: void
16299: oggplay_data_add_to_list_end(OggPlayDecode *decode, OggPlayDataHeader *data) {
16299: 
16299:   data->next = NULL;
16299: 
16299:   if (decode->data_list == NULL) {
16299:     decode->data_list = data;
16299:     decode->end_of_data_list = data;
16299:   } else {
16299:     decode->end_of_data_list->next = data;
16299:     decode->end_of_data_list = data;
16299:   }
16299: 
16299: }
16299: 
16299: /*
16299:  * helper function to append data packets to front of data_list
16299:  */
16299: void
16299: oggplay_data_add_to_list_front(OggPlayDecode *decode, OggPlayDataHeader *data) {
16299:   if (decode->data_list == NULL) {
16299:     decode->data_list = decode->end_of_data_list = data;
16299:     data->next = NULL;
16299:   } else {
16299:     data->next = decode->data_list;
16299:     decode->data_list = data;
16299:   }
16299: }
16299: 
16299: void
16299: _print_list(char *name, OggPlayDataHeader *p) {
16299:     printf("%s: ", name);
16299:     for (; p != NULL; p = p->next) {
16299:       printf("%"PRId64"[%d]", p->presentation_time >> 32, p->lock);
16299:       if (p->next != NULL) printf("->");
16299:     }
16299:     printf("\n");
16299: }
16299: 
16299: 
16299: void
16299: oggplay_data_add_to_list (OggPlayDecode *decode, OggPlayDataHeader *data) {
16299: 
16299:   /*
16299:    * if this is a packet with an unknown display time, prepend it to
16299:    * the untimed_data_list for later timestamping.
16299:    */
16299: 
16299:   ogg_int64_t samples_in_next_in_list;
16299: 
16299:   //_print_list("before", decode->data_list);
16299:   //_print_list("untimed before", decode->untimed_data_list);
16299: 
16299:   if (data->presentation_time == -1) {
16299:     data->next = decode->untimed_data_list;
16299:     decode->untimed_data_list = data;
16299:   } else {
16299:     /*
16299:      * process the untimestamped data into the timestamped data list.
16299:      *
16299:      * First store any old data.
16299:      */
16299:     ogg_int64_t presentation_time         = data->presentation_time;
16299:     samples_in_next_in_list               = data->samples_in_record;
16299: 
16299: 
16299:     while (decode->untimed_data_list != NULL) {
16299:       OggPlayDataHeader *untimed = decode->untimed_data_list;
16299: 
16299:       presentation_time -=
16299:                 samples_in_next_in_list * decode->granuleperiod;
16299:       untimed->presentation_time = presentation_time;
16299:       decode->untimed_data_list = untimed->next;
16299:       samples_in_next_in_list = untimed->samples_in_record;
16299: 
16299:       if (untimed->presentation_time >= decode->player->presentation_time) {
16299:         oggplay_data_add_to_list_front(decode, untimed);
16299:       } else {
25830:         oggplay_free(untimed);
16299:       }
16299: 
16299:     }
16299: 
16299:     oggplay_data_add_to_list_end(decode, data);
16299: 
16299:     /*
16299:      * if the StreamInfo is still at uninitialised, then this is the first
16299:      * meaningful data packet!  StreamInfo will be updated to
16299:      * OGGPLAY_STREAM_INITIALISED in oggplay_callback_info.c as part of the
16299:      * callback process.
16299:      */
16299:     if (decode->stream_info == OGGPLAY_STREAM_UNINITIALISED) {
16299:       decode->stream_info = OGGPLAY_STREAM_FIRST_DATA;
16299:     }
16299: 
16299:   }
16299: 
16299:   //_print_list("after", decode->data_list);
16299:   //_print_list("untimed after", decode->untimed_data_list);
16299: 
16299: }
16299: 
16299: void
16299: oggplay_data_free_list(OggPlayDataHeader *list) {
16299:   OggPlayDataHeader *p;
16299: 
16299:   while (list != NULL) {
16299:     p = list;
16299:     list = list->next;
25830:     oggplay_free(p);
16299:   }
16299: }
16299: 
16299: void
16299: oggplay_data_shutdown_list (OggPlayDecode *decode) {
16299: 
16299:   oggplay_data_free_list(decode->data_list);
16299:   oggplay_data_free_list(decode->untimed_data_list);
16299: 
16299: }
16299: 
16299: /*
16299:  * this function removes any displayed, unlocked frames from the list.
16299:  *
16299:  * this function also removes any undisplayed frames that are before the
16299:  * global presentation time.
16299:  */
16299: void
16299: oggplay_data_clean_list (OggPlayDecode *decode) {
16299: 
16299:   ogg_int64_t         target = decode->player->target;
16299:   OggPlayDataHeader * header = decode->data_list;
16299:   OggPlayDataHeader * p      = NULL;
16299: 
16299:   while (header != NULL) {
16299:     if
16299:     (
16299:       header->lock == 0
16299:       &&
16299:       (
16299:         (
16299:           (header->presentation_time < (target + decode->offset))
16299:           &&
16299:           header->has_been_presented
16299:         )
16299:         ||
16299:         (
16299:           (header->presentation_time < decode->player->presentation_time)
16299:         )
16299:       )
16299: 
16299:     )
16299:     {
16299:       if (p == NULL) {
16299:         decode->data_list = decode->data_list->next;
16299:         if (decode->data_list == NULL)
16299:           decode->end_of_data_list = NULL;
25830:         oggplay_free (header);
16299:         header = decode->data_list;
16299:       } else {
16299:         if (header->next == NULL)
16299:           decode->end_of_data_list = p;
16299:         p->next = header->next;
25830:         oggplay_free (header);
16299:         header = p->next;
16299:       }
16299:     } else {
16299:       p = header;
16299:       header = header->next;
16299:     }
16299:   }
16299: }
16299: 
16299: void
16299: oggplay_data_initialise_header (OggPlayDecode *decode,
16299:                 OggPlayDataHeader *header) {
16299:   /*
16299:    * the frame is not cleaned until its presentation time has passed.  We'll
16299:    * check presentation times in oggplay_data_clean_list.
16299:    */
16299:   header->lock = 0;
16299:   header->next = NULL;
16299:   header->presentation_time = decode->current_loc;
16299:   header->has_been_presented = 0;
16299: 
16299: }
16299: 
16299: void
16299: oggplay_data_handle_audio_data (OggPlayDecode *decode, void *data,
16299:       int samples, int samplesize) {
16299: 
16299:   int                   num_channels;
25830:   OggPlayAudioRecord  * record = NULL;
16299: 
16299:   num_channels = ((OggPlayAudioDecode *)decode)->sound_info.channels;
25830:   record = (OggPlayAudioRecord*)oggplay_calloc(sizeof(OggPlayAudioRecord) +
16299:                   samples * samplesize * num_channels, 1);
16299: 
25830:   if (record == NULL)
25830:     return;
25830: 
16299:   oggplay_data_initialise_header(decode, &(record->header));
16299: 
16299:   record->header.samples_in_record = samples;
16299: 
16299:   record->data = (void *)(record + 1);
16299: 
16299:   memcpy(record->data, data, samples * samplesize * num_channels);
16299:   /*
16299:   printf("[%f%f%f]\n", ((float *)record->data)[0], ((float *)record->data)[1],
16299:                     ((float *)record->data)[2]);
16299:   */
16299:   oggplay_data_add_to_list(decode, &(record->header));
16299: }
16299: 
16299: void
16299: oggplay_data_handle_cmml_data(OggPlayDecode *decode, unsigned char *data,
16299:                 int size) {
16299: 
25830:   OggPlayTextRecord * record = NULL;
16299: 
16299:   record =
25830:       (OggPlayTextRecord*)oggplay_calloc (sizeof(OggPlayTextRecord) + size + 1, 1);
25830: 
25830:   if (record == NULL)
25830:     return;
25830: 
16299:   oggplay_data_initialise_header(decode, &(record->header));
16299: 
16299:   record->header.samples_in_record = 1;
16299:   record->data = (char *)(record + 1);
16299: 
16299:   memcpy(record->data, data, size);
16299:   record->data[size] = '\0';
16299: 
16299:   oggplay_data_add_to_list(decode, &(record->header));
16299: 
16299: }
16299: 
30419: static int
30419: get_uv_offset(OggPlayTheoraDecode *decode, yuv_buffer *buffer)
30419: {
30419:   int xo=0, yo = 0;
30419:   if (decode->y_width != 0 &&
30419:       decode->uv_width != 0 &&
30419:       decode->y_width/decode->uv_width != 0) {
30419:     xo = (decode->video_info.offset_x/(decode->y_width/decode->uv_width));
30419:   }
30419:   if (decode->y_height != 0 &&
30419:       decode->uv_height != 0 &&
30419:       decode->y_height/decode->uv_height != 0) {
30419:     yo = (buffer->uv_stride)*(decode->video_info.offset_y/(decode->y_height/decode->uv_height));
30419:   }
30419:   return xo + yo;
30419: }
30419: 
16299: void
16299: oggplay_data_handle_theora_frame (OggPlayTheoraDecode *decode,
16299:                                     yuv_buffer *buffer) {
16299: 
16299:   int                   size = sizeof (OggPlayVideoRecord);
16299:   int                   i;
28472:   int                   uv_offset;
16299:   unsigned char       * p;
16299:   unsigned char       * q;
16299:   unsigned char       * p2;
16299:   unsigned char       * q2;
16299:   OggPlayVideoRecord  * record;
16299:   OggPlayVideoData    * data;
16299: 
16299:   if (buffer->y_stride < 0) {
16299:     size -= buffer->y_stride * buffer->y_height;
16299:     size -= buffer->uv_stride * buffer->uv_height * 2;
16299:   } else {
16299:     size += buffer->y_stride * buffer->y_height;
16299:     size += buffer->uv_stride * buffer->uv_height * 2;
16299:   }
16299: 
16299:   /*
16299:    * we need to set the output strides to the input widths because we are
16299:    * trying not to pass negative output stride issues on to the poor user.
16299:    */
25830:   record = (OggPlayVideoRecord*)oggplay_malloc (size);
25830: 
25830:   if (record == NULL)
25830:     return;
25830: 
16299:   record->header.samples_in_record = 1;
16299:   data = &(record->data);
16299: 
16299:   data->y = (unsigned char *)(record + 1);
16299:   data->u = data->y + (decode->y_stride * decode->y_height);
16299:   data->v = data->u + (decode->uv_stride * decode->uv_height);
16299: 
16299:   /*
16299:    * *grumble* theora plays silly buggers with pointers so we need to do
16299:    * a row-by-row copy (stride may be negative)
16299:    */
16299:   p = data->y;
28472:   q = buffer->y + (decode->video_info.offset_x&~1)+buffer->y_stride*(decode->video_info.offset_y&~1);
16299:   for (i = 0; i < decode->y_height; i++) {
16299:     memcpy(p, q, decode->y_width);
16299:     p += decode->y_width;
16299:     q += buffer->y_stride;
16299:   }
16299: 
30419:   uv_offset = get_uv_offset(decode, buffer);
28472: 
16299:   p = data->u;
28472:   q = buffer->u + uv_offset;
16299:   p2 = data->v;
28472:   q2 = buffer->v + uv_offset;
16299:   for (i = 0; i < decode->uv_height; i++) {
16299:     memcpy(p, q, decode->uv_width);
16299:     memcpy(p2, q2, decode->uv_width);
16299:     p += decode->uv_width;
16299:     p2 += decode->uv_width;
16299:     q += buffer->uv_stride;
16299:     q2 += buffer->uv_stride;
16299:   }
16299: 
26904:   /* if we're to send RGB video, convert here */
26904:   if (decode->convert_to_rgb) {
26904:     OggPlayYUVChannels      yuv;
26904:     OggPlayRGBChannels      rgb;
26904:     OggPlayOverlayRecord  * orecord;
26904:     OggPlayOverlayData    * odata;
26904: 
26904:     yuv.ptry = data->y;
26904:     yuv.ptru = data->u;
26904:     yuv.ptrv = data->v;
26904:     yuv.y_width = decode->y_width;
26904:     yuv.y_height = decode->y_height;
26904:     yuv.uv_width = decode->uv_width;
26904:     yuv.uv_height = decode->uv_height;
26904: 
26904:     size = sizeof(OggPlayOverlayRecord) + decode->y_width * decode->y_height * 4;
26904:     orecord = (OggPlayOverlayRecord*) oggplay_malloc (size);
26904:     if (orecord) {
26904:       oggplay_data_initialise_header((OggPlayDecode *)decode, &(orecord->header));
26904:       orecord->header.samples_in_record = 1;
26904:       odata = &(orecord->data);
26904: 
26904:       rgb.ptro = (unsigned char*)(orecord+1);
26904:       rgb.rgb_width = yuv.y_width;
26904:       rgb.rgb_height = yuv.y_height;
26904: 
26904:       oggplay_yuv2rgba(&yuv, &rgb);
26904: 
26904: //      odata->rgb = NULL;
26904: //      odata->rgba = rgb.ptro;
26904:       odata->rgb = rgb.ptro;
26904:       odata->rgba = NULL;
26904:       odata->width = rgb.rgb_width;
26904:       odata->height = rgb.rgb_height;
26904:       odata->stride = rgb.rgb_width*4;
26904: 
26904:       oggplay_free(record);
26904:     
26904:       oggplay_data_add_to_list((OggPlayDecode *)decode, &(orecord->header));
26904:     }
26904:   }
26904:   else {
26904:     oggplay_data_initialise_header((OggPlayDecode *)decode, &(record->header));
16299:     oggplay_data_add_to_list((OggPlayDecode *)decode, &(record->header));
16299:   }
26904: }
16299: 
16299: #ifdef HAVE_KATE
16299: void
16299: oggplay_data_handle_kate_data(OggPlayKateDecode *decode, const kate_event *ev) {
16299: 
25830:   OggPlayTextRecord * record = NULL;
16299: 
26904: #ifdef HAVE_TIGER
26904:   tiger_renderer_add_event(decode->tr, ev->ki, ev);
26904: 
26904:   if (decode->use_tiger) {
26904:     /* if rendering with Tiger, we don't add an event, a synthetic one will be
26904:        generated each "tick" with an updated tracker state */
26904:   }
26904:   else
26904: #endif
26904:   {
25830:     record = (OggPlayTextRecord*)oggplay_calloc (sizeof(OggPlayTextRecord) + ev->len0, 1);
26904:     if (!record)
25830:       return;
25830: 
16299:     oggplay_data_initialise_header(&decode->decoder, &(record->header));
16299: 
16299:     //record->header.presentation_time = (ogg_int64_t)(ev->start_time*1000);
16299:     record->header.samples_in_record = (ev->end_time-ev->start_time)*1000;
16299:     record->data = (char *)(record + 1);
16299: 
16299:     memcpy(record->data, ev->text, ev->len0);
16299: 
16299:     oggplay_data_add_to_list(&decode->decoder, &(record->header));
16299:   }
26904: }
16299: #endif
16299: 
26904: #ifdef HAVE_TIGER
26904: void
26904: oggplay_data_update_tiger(OggPlayKateDecode *decode, int active, ogg_int64_t presentation_time, OggPlayCallbackInfo *info) {
26904: 
26904:   OggPlayOverlayRecord  * record = NULL;
26904:   OggPlayOverlayData    * data = NULL;
26904:   size_t                size = sizeof (OggPlayOverlayRecord);
26904:   int                   track = active && decode->use_tiger;
26904:   kate_float            t = OGGPLAY_TIME_FP_TO_INT(presentation_time) / 1000.0f;
26904: 
26904:   if (!decode->init) return;
26904: 
26904:   if (track) {
26904:     if (info) {
26904:       if (info->required_records>0) {
26904:         OggPlayDataHeader *header = info->records[0];
26904:         data = (OggPlayOverlayData*)(header+1);
26904:         if (decode->tr && data->rgb) {
26904:           tiger_renderer_set_buffer(decode->tr, data->rgb, data->width, data->height, data->stride, 1);
26904:         }
26904:         else {
26904:           /* we're supposed to overlay on a frame, but the available frame has no RGB buffer */
26904:           /* fprintf(stderr,"no RGB buffer found for video frame\n"); */
26904:           return;
26904:         }
26904:       }
26904:       else {
26904:         /* we're supposed to overlay on a frame, but there is no frame available */
26904:         /* fprintf(stderr,"no video frame to overlay on\n"); */
26904:         return;
26904:       }
26904:     }
26904:     else {
26904:       // TODO: some way of knowing the size of the video we'll be drawing onto, if any
26904:       int width = decode->k.ki->original_canvas_width;
26904:       int height = decode->k.ki->original_canvas_height;
26904:       if (width <= 0 || height <= 0) {
26904:         /* some default resolution if we're not overlaying onto a video and the canvas size is unknown */
26904:         width = 640;
26904:         height = 480;
26904:       }
26904:       size = sizeof (OggPlayOverlayRecord) + width*height*4;
26904:       record = (OggPlayOverlayRecord*)oggplay_calloc (1, size);
26904:       if (!record)
26904:         return;
26904: 
26904:       record->header.samples_in_record = 1;
26904:       data= &(record->data);
26904:       oggplay_data_initialise_header((OggPlayDecode *)decode, &(record->header));
26904: 
26904:       data->rgba = (unsigned char*)(record+1);
26904:       data->rgb = NULL;
26904:       data->width = width;
26904:       data->height = height;
26904:       data->stride = width*4;
26904: 
26904:       if (decode->tr && data->rgba) {
26904:         tiger_renderer_set_buffer(decode->tr, data->rgba, data->width, data->height, data->stride, 1);
26904:       }
26904: 
26904:       oggplay_data_add_to_list(&decode->decoder, &(record->header));
26904:       record->header.presentation_time=presentation_time;
26904:     }
26904:   }
26904: 
26904:   if (decode->tr) {
26904:     tiger_renderer_update(decode->tr, t, track);
26904:   }
26904: 
26904:   if (track) {
26904:     /* buffer was either calloced, so already cleared, or already filled with video, so no clearing */
26904:     if (decode->tr) {
26904:       tiger_renderer_render(decode->tr);
26904:     }
26904:   }
26904: }
26904: #endif
26904: 
