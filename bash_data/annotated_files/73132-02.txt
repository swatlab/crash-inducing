43129: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
43129: /* vim: set sw=2 ts=2 et tw=80: */
43129: /* ***** BEGIN LICENSE BLOCK *****
43129:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43129:  *
43129:  * The contents of this file are subject to the Mozilla Public License Version
43129:  * 1.1 (the "License"); you may not use this file except in compliance with
43129:  * the License. You may obtain a copy of the License at
43129:  * http://www.mozilla.org/MPL/
43129:  *
43129:  * Software distributed under the License is distributed on an "AS IS" basis,
43129:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43129:  * for the specific language governing rights and limitations under the
43129:  * License.
43129:  *
43129:  * The Original Code is Mozilla.org client code.
43129:  *
43129:  * The Initial Developer of the Original Code is Mozilla Foundation.
43129:  * Portions created by the Initial Developer are Copyright (C) 2009
43129:  * the Initial Developer. All Rights Reserved.
43129:  *
43129:  * Contributor(s):
43129:  *   Ehsan Akhgari <ehsan@mozilla.com> (Original Author)
43129:  *
43129:  * Alternatively, the contents of this file may be used under the terms of
43129:  * either of the GNU General Public License Version 2 or later (the "GPL"),
43129:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43129:  * in which case the provisions of the GPL or the LGPL are applicable instead
43129:  * of those above. If you wish to allow use of your version of this file only
43129:  * under the terms of either the GPL or the LGPL, and not to allow others to
43129:  * use your version of this file under the terms of the MPL, indicate your
43129:  * decision by deleting the provisions above and replace them with the notice
43129:  * and other provisions required by the GPL or the LGPL. If you do not delete
43129:  * the provisions above, a recipient may use your version of this file under
43129:  * the terms of any one of the MPL, the GPL or the LGPL.
43129:  *
43129:  * ***** END LICENSE BLOCK ***** */
43129: 
43129: #ifndef nsTextEditorState_h__
43129: #define nsTextEditorState_h__
43129: 
43129: #include "nsAutoPtr.h"
43129: #include "nsITextControlElement.h"
43129: #include "nsCycleCollectionParticipant.h"
43129: 
43129: class nsTextInputListener;
43129: class nsTextControlFrame;
43129: class nsTextInputSelectionImpl;
43129: class nsAnonDivObserver;
43129: class nsISelectionController;
43129: class nsFrameSelection;
43129: class nsIEditor;
43129: class nsITextControlElement;
55424: struct SelectionState;
43129: 
43129: /**
43129:  * nsTextEditorState is a class which is responsible for managing the state of
43129:  * plaintext controls.  This currently includes the following HTML elements:
43129:  *   <input type=text>
43129:  *   <input type=password>
43129:  *   <textarea>
43129:  * and also XUL controls such as <textbox> which use one of these elements behind
43129:  * the scenes.
43129:  *
43129:  * This class is held as a member of nsHTMLInputElement and nsHTMLTextAreaElement.
43129:  * The public functions in this class include the public APIs which content/ uses.
43129:  * Layout code uses the nsITextControlElement interface to invoke functions on this
43129:  * class.
43129:  *
43129:  * The design motivation behind this class is maintaining all of the things which
43129:  * collectively are considered the "state" of the text control in a single location.
43129:  * This state includes several things:
43129:  *
43129:  *  * The control's value.  This value is stored in the mValue member, and is only
43129:  *    used when there is no frame for the control, or when the editor object has
43129:  *    not been initialized yet.
43129:  *
43129:  *  * The control's associated frame.  This value is stored in the mBoundFrame member.
43129:  *    A text control might never have an associated frame during its life cycle,
43129:  *    or might have several different ones, but at any given moment in time there is
43129:  *    a maximum of 1 bound frame to each text control.
43129:  *
43129:  *  * The control's associated editor.  This value is stored in the mEditor member.
43129:  *    An editor is initilized for the control only when necessary (that is, when either
43129:  *    the user is about to interact with the text control, or when some other code
43129:  *    needs to access the editor object.  Without a frame bound to the control, an
43129:  *    editor is never initialzied.  Once initialized, the editor might outlive the frame,
43129:  *    in which case the same editor will be used if a new frame gets bound to the
43129:  *    text control.
43129:  *
43129:  *  * The anonymous content associated with the text control's frame, including the
43129:  *    value div (the DIV element responsible for holding the value of the text control)
43129:  *    and the placeholder div (the DIV element responsible for holding the placeholder
43129:  *    value of the text control.)  These values are stored in the mRootNode and
43129:  *    mPlaceholderDiv members, respectively.  They will be created when a
43129:  *    frame is bound to the text control.  They will be destroyed when the frame is
43129:  *    unbound from the object.  We could try and hold on to the anonymous content
43129:  *    between different frames, but unfortunately that is not currently possible
43129:  *    because they are not unbound from the document in time.
43129:  *
43129:  *  * The frame selection controller.  This value is stored in the mSelCon member.
43129:  *    The frame selection controller is responsible for maintaining the selection state
43129:  *    on a frame.  It is created when a frame is bound to the text control element,
43129:  *    and will be destroy when the frame is being unbound from the text control element.
43129:  *    It is created alongside with the frame selection object which is stored in the
43129:  *    mFrameSel member.
43129:  *
43129:  *  * The editor text listener.  This value is stored in the mTextListener member.
43129:  *    Its job is to listen to selection and keyboard events, and act accordingly.
43129:  *    It is created when an a frame is first bound to the control, and will be destroyed
43129:  *    when the frame is unbound from the text control element.
43129:  *
43129:  *  * The editor's cached value.  This value is stored in the mCachedValue member.
43129:  *    It is used to improve the performance of append operations to the text
63299:  *    control.  A mutation observer stored in the mMutationObserver has the job of
43129:  *    invalidating this cache when the anonymous contect containing the value is
43129:  *    changed.
43129:  *
43129:  *
43129:  * As a general rule, nsTextEditorState objects own the value of the text control, and any
43129:  * attempt to retrieve or set the value must be made through those objects.  Internally,
43129:  * the value can be represented in several different ways, based on the state the control is
43129:  * in.
43129:  *
43129:  *   * When the control is first initialized, its value is equal to the default value of
43129:  *     the DOM node.  For <input> text controls, this default value is the value of the
43129:  *     value attribute.  For <textarea> elements, this default value is the value of the
43129:  *     text node children of the element.
43129:  *
43129:  *   * If the value has been changed through the DOM node (before the editor for the object
43129:  *     is initialized), the value is stored as a simple string inside the mValue member of
43129:  *     the nsTextEditorState object.
43129:  *
43129:  *   * If an editor has been initialized for the control, the value is set and retrievd via
43129:  *     the nsIPlaintextEditor interface, and is internally managed by the editor as the
43129:  *     native anonymous content tree attached to the control's frame.
43129:  *
43129:  *   * If the text editor state object is unbound from the control's frame, the value is
43129:  *     transferred to the mValue member variable, and will be managed there until a new
43129:  *     frame is bound to the text editor state object.
43129:  */
43129: 
43129: class nsTextEditorState {
43129: public:
43129:   explicit nsTextEditorState(nsITextControlElement* aOwningElement);
43129:   ~nsTextEditorState();
43129: 
43129:   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(nsTextEditorState)
43129:   NS_INLINE_DECL_REFCOUNTING(nsTextEditorState)
43129: 
43129:   nsIEditor* GetEditor();
43129:   nsISelectionController* GetSelectionController() const;
43129:   nsFrameSelection* GetConstFrameSelection();
43129:   nsresult BindToFrame(nsTextControlFrame* aFrame);
43129:   void UnbindFromFrame(nsTextControlFrame* aFrame);
43129:   nsresult PrepareEditor(const nsAString *aValue = nsnull);
43129:   void InitializeKeyboardEventListeners();
43129: 
43129:   void SetValue(const nsAString& aValue, PRBool aUserInput);
43129:   void GetValue(nsAString& aValue, PRBool aIgnoreWrap) const;
63657:   void EmptyValue() { if (mValue) mValue->Truncate(); }
63657:   PRBool IsEmpty() const { return mValue ? mValue->IsEmpty() : PR_TRUE; }
43129: 
56086:   nsresult CreatePlaceholderNode();
56086: 
43129:   nsIContent* GetRootNode() {
43129:     if (!mRootNode)
43129:       CreateRootNode();
43129:     return mRootNode;
43129:   }
43129:   nsIContent* GetPlaceholderNode() {
43129:     return mPlaceholderDiv;
43129:   }
43129: 
43129:   PRBool IsSingleLineTextControl() const {
43129:     return mTextCtrlElement->IsSingleLineTextControl();
43129:   }
43129:   PRBool IsTextArea() const {
43129:     return mTextCtrlElement->IsTextArea();
43129:   }
43129:   PRBool IsPlainTextControl() const {
43129:     return mTextCtrlElement->IsPlainTextControl();
43129:   }
43129:   PRBool IsPasswordTextControl() const {
43129:     return mTextCtrlElement->IsPasswordTextControl();
43129:   }
43129:   PRInt32 GetCols() {
43129:     return mTextCtrlElement->GetCols();
43129:   }
43129:   PRInt32 GetWrapCols() {
43129:     return mTextCtrlElement->GetWrapCols();
43129:   }
43129:   PRInt32 GetRows() {
43129:     return mTextCtrlElement->GetRows();
43129:   }
43129: 
43129:   // placeholder methods
43129:   void SetPlaceholderClass(PRBool aVisible, PRBool aNotify);
43129:   void UpdatePlaceholderText(PRBool aNotify); 
43129: 
43129:   /**
43129:    * Get the maxlength attribute
43129:    * @param aMaxLength the value of the max length attr
43129:    * @returns PR_FALSE if attr not defined
43129:    */
43129:   PRBool GetMaxLength(PRInt32* aMaxLength);
43129: 
43129:   /* called to free up native keybinding services */
43129:   static NS_HIDDEN_(void) ShutDown();
43129: 
43129:   void ClearValueCache() { mCachedValue.Truncate(); }
43129: 
68438:   void HideSelectionIfBlurred();
68438: 
43129: private:
43129:   // not copy constructible
43129:   nsTextEditorState(const nsTextEditorState&);
43129:   // not assignable
43129:   void operator= (const nsTextEditorState&);
43129: 
43129:   nsresult CreateRootNode();
43129: 
43129:   void ValueWasChanged(PRBool aNotify);
43129: 
43129:   void DestroyEditor();
43129:   void Clear();
43129: 
48847:   class InitializationGuard {
48847:   public:
48847:     explicit InitializationGuard(nsTextEditorState& aState) :
48847:       mState(aState),
48847:       mGuardSet(PR_FALSE)
48847:     {
48847:       if (!mState.mInitializing) {
48847:         mGuardSet = PR_TRUE;
48847:         mState.mInitializing = PR_TRUE;
48847:       }
48847:     }
48847:     ~InitializationGuard() {
48847:       if (mGuardSet) {
48847:         mState.mInitializing = PR_FALSE;
48847:       }
48847:     }
48847:     PRBool IsInitializingRecursively() const {
48847:       return !mGuardSet;
48847:     }
48847:   private:
48847:     nsTextEditorState& mState;
48847:     PRBool mGuardSet;
48847:   };
48847:   friend class InitializationGuard;
48847: 
43129:   nsITextControlElement* const mTextCtrlElement;
43129:   nsRefPtr<nsTextInputSelectionImpl> mSelCon;
55424:   nsAutoPtr<SelectionState> mSelState;
43129:   nsCOMPtr<nsIEditor> mEditor;
43129:   nsCOMPtr<nsIContent> mRootNode;
43129:   nsCOMPtr<nsIContent> mPlaceholderDiv;
43129:   nsTextControlFrame* mBoundFrame;
43129:   nsTextInputListener* mTextListener;
43129:   nsAutoPtr<nsCString> mValue;
43129:   nsRefPtr<nsAnonDivObserver> mMutationObserver;
43129:   mutable nsString mCachedValue; // Caches non-hard-wrapped value on a multiline control.
43129:   PRPackedBool mEditorInitialized;
48847:   PRPackedBool mInitializing; // Whether we're in the process of initialization
43129: };
43129: 
43129: #endif
