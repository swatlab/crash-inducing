 71354: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
112731:  * vim: set ts=4 sw=4 tw=79 et:
 90129:  */
 90129: /* This Source Code Form is subject to the terms of the Mozilla Public
 90129:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 90129:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 68933: 
 68933: #include "jsprf.h"
 68933: #include "jsscope.h"
 68933: #include "jsstr.h"
 98644: #include "jsxml.h"
 68933: 
 97569: #include "gc/Marking.h"
 97569: #include "methodjit/MethodJIT.h"
 97569: 
 68933: #include "jsobjinlines.h"
 68933: #include "jsscopeinlines.h"
 68933: 
111793: #include "ion/IonCode.h"
 72107: #include "vm/String-inl.h"
 72107: 
123696: using namespace js;
123696: using namespace js::gc;
123696: 
121250: using mozilla::DebugOnly;
121250: 
103990: void * const js::NullPtr::constNullValue = NULL;
103990: 
 70288: /*
 70288:  * There are two mostly separate mark paths. The first is a fast path used
 70288:  * internally in the GC. The second is a slow path used for root marking and
 84719:  * for API consumers like the cycle collector or Class::trace implementations.
 70288:  *
 70288:  * The fast path uses explicit stacks. The basic marking process during a GC is
 70288:  * that all roots are pushed on to a mark stack, and then each item on the
 70288:  * stack is scanned (possibly pushing more stuff) until the stack is empty.
 70288:  *
 70288:  * PushMarkStack pushes a GC thing onto the mark stack. In some cases (shapes
 84719:  * or strings) it eagerly marks the object rather than pushing it. Popping and
 84719:  * scanning is done by the processMarkStackTop method. For efficiency reasons
 84719:  * like tail recursion elimination that method also implements the scanning of
 84719:  * objects. For other GC things it uses helper methods.
 70288:  *
 97569:  * Most of the marking code outside Marking.cpp uses functions like MarkObject,
 70288:  * MarkString, etc. These functions check if an object is in the compartment
 70288:  * currently being GCed. If it is, they call PushMarkStack. Roots are pushed
 70288:  * this way as well as pointers traversed inside trace hooks (for things like
105836:  * PropertyIteratorObjects). It is always valid to call a MarkX function
105836:  * instead of PushMarkStack, although it may be slower.
 70288:  *
 70288:  * The MarkX functions also handle non-GC object traversal. In this case, they
 70288:  * call a callback for each object visited. This is a recursive process; the
 70288:  * mark stacks are not involved. These callbacks may ask for the outgoing
 70288:  * pointers to be visited. Eventually, this leads to the MarkChildren functions
 70288:  * being called. These functions duplicate much of the functionality of
 84719:  * scanning functions, but they don't push onto an explicit stack.
 70288:  */
 70288: 
 98644: #if JS_HAS_XML_SUPPORT
 68933: static inline void
 68933: PushMarkStack(GCMarker *gcmarker, JSXML *thing);
 98644: #endif
 68933: 
 68933: static inline void
 68933: PushMarkStack(GCMarker *gcmarker, JSObject *thing);
 68933: 
 68933: static inline void
 68933: PushMarkStack(GCMarker *gcmarker, JSFunction *thing);
 68933: 
 68933: static inline void
 77659: PushMarkStack(GCMarker *gcmarker, JSScript *thing);
 77659: 
 77659: static inline void
 90419: PushMarkStack(GCMarker *gcmarker, Shape *thing);
 68933: 
 68933: static inline void
 68933: PushMarkStack(GCMarker *gcmarker, JSString *thing);
 68933: 
 77462: static inline void
 77462: PushMarkStack(GCMarker *gcmarker, types::TypeObject *thing);
 77462: 
123696: namespace js {
123696: namespace gc {
123696: 
123696: static void MarkChildren(JSTracer *trc, JSString *str);
123696: static void MarkChildren(JSTracer *trc, JSScript *script);
123696: static void MarkChildren(JSTracer *trc, Shape *shape);
123696: static void MarkChildren(JSTracer *trc, BaseShape *base);
123696: static void MarkChildren(JSTracer *trc, types::TypeObject *type);
123696: static void MarkChildren(JSTracer *trc, ion::IonCode *code);
123696: #if JS_HAS_XML_SUPPORT
123696: static void MarkChildren(JSTracer *trc, JSXML *xml);
123696: #endif
123696: 
123696: } /* namespace gc */
123696: } /* namespace js */
123696: 
 90129: /*** Object Marking ***/
 90129: 
 76766: template<typename T>
 77343: static inline void
 77343: CheckMarkedThing(JSTracer *trc, T *thing)
 76766: {
 90129:     JS_ASSERT(trc);
 76766:     JS_ASSERT(thing);
 94620:     JS_ASSERT(thing->compartment());
 94620:     JS_ASSERT(thing->compartment()->rt == trc->runtime);
121539:     JS_ASSERT_IF(IS_GC_MARKING_TRACER(trc), !thing->compartment()->scheduledForDestruction);
 76766:     JS_ASSERT(trc->debugPrinter || trc->debugPrintArg);
 94620: 
 94620:     DebugOnly<JSRuntime *> rt = trc->runtime;
 94620: 
124188: #ifdef DEBUG
124188:     rt->assertValidThread();
124188: #endif
124188: 
 94620:     JS_ASSERT_IF(thing->compartment()->requireGCTracer(), IS_GC_MARKING_TRACER(trc));
 76766: 
 76766:     JS_ASSERT(thing->isAligned());
 76766: 
 94620:     JS_ASSERT_IF(rt->gcStrictCompartmentChecking,
 94620:                  thing->compartment()->isCollecting() ||
 94620:                  thing->compartment() == rt->atomsCompartment);
124078: 
124078:     JS_ASSERT_IF(IS_GC_MARKING_TRACER(trc) && ((GCMarker *)trc)->getMarkColor() == GRAY,
124078:                  thing->compartment()->isGCMarkingGray() ||
124078:                  thing->compartment() == rt->atomsCompartment);
124078: }
124078: 
124078: static GCMarker *
124078: AsGCMarker(JSTracer *trc)
124078: {
124078:     JS_ASSERT(IS_GC_MARKING_TRACER(trc));
124078:     return static_cast<GCMarker *>(trc);
 77343: }
 77343: 
 68933: template<typename T>
123696: static void
 93352: MarkInternal(JSTracer *trc, T **thingp)
 68933: {
 93352:     JS_ASSERT(thingp);
 93352:     T *thing = *thingp;
 93352: 
 77343:     CheckMarkedThing(trc, thing);
 68933: 
 69246:     /*
 69246:      * Don't mark things outside a compartment if we are in a per-compartment
 69246:      * GC.
 69246:      */
 90410:     if (!trc->callback) {
124077:         if (thing->compartment()->isGCMarking()) {
124078:             PushMarkStack(AsGCMarker(trc), thing);
121539:             thing->compartment()->maybeAlive = true;
121539:         }
 90232:     } else {
 93352:         trc->callback(trc, (void **)thingp, GetGCThingTraceKind(thing));
111405:         JS_UNSET_TRACING_LOCATION(trc);
 90232:     }
 68933: 
 68933:     trc->debugPrinter = NULL;
 68933:     trc->debugPrintArg = NULL;
 68933: }
 68933: 
 90410: #define JS_ROOT_MARKING_ASSERT(trc)                                     \
 90410:     JS_ASSERT_IF(IS_GC_MARKING_TRACER(trc),                             \
 90410:                  trc->runtime->gcIncrementalState == NO_INCREMENTAL ||  \
 90410:                  trc->runtime->gcIncrementalState == MARK_ROOTS);
 90410: 
 90129: template <typename T>
 90129: static void
 91557: MarkUnbarriered(JSTracer *trc, T **thingp, const char *name)
 90129: {
 90129:     JS_SET_TRACING_NAME(trc, name);
 93352:     MarkInternal(trc, thingp);
 90129: }
 90129: 
123696: namespace js {
123696: namespace gc {
123696: 
 90129: template <typename T>
 90129: static void
109329: Mark(JSTracer *trc, EncapsulatedPtr<T> *thing, const char *name)
 90129: {
 90129:     JS_SET_TRACING_NAME(trc, name);
 93352:     MarkInternal(trc, thing->unsafeGet());
 90129: }
 90129: 
123696: } /* namespace gc */
123696: } /* namespace js */
123696: 
 90129: template <typename T>
 90129: static void
 90409: MarkRoot(JSTracer *trc, T **thingp, const char *name)
 90129: {
 90410:     JS_ROOT_MARKING_ASSERT(trc);
 90129:     JS_SET_TRACING_NAME(trc, name);
 93352:     MarkInternal(trc, thingp);
 90129: }
 90129: 
 90129: template <typename T>
 90129: static void
 90318: MarkRange(JSTracer *trc, size_t len, HeapPtr<T> *vec, const char *name)
 90318: {
 90129:     for (size_t i = 0; i < len; ++i) {
 93352:         if (vec[i].get()) {
 90129:             JS_SET_TRACING_INDEX(trc, name, i);
 93352:             MarkInternal(trc, vec[i].unsafeGet());
 90129:         }
 90129:     }
 90129: }
 90129: 
 90129: template <typename T>
 90129: static void
 90318: MarkRootRange(JSTracer *trc, size_t len, T **vec, const char *name)
 90318: {
 90410:     JS_ROOT_MARKING_ASSERT(trc);
 90129:     for (size_t i = 0; i < len; ++i) {
103320:         if (vec[i]) {
 90129:             JS_SET_TRACING_INDEX(trc, name, i);
 93352:             MarkInternal(trc, &vec[i]);
 90129:         }
 90129:     }
103320: }
 90129: 
123696: namespace js {
123696: namespace gc {
123696: 
 99246: template <typename T>
 99246: static bool
 99246: IsMarked(T **thingp)
 99246: {
 99246:     JS_ASSERT(thingp);
 99246:     JS_ASSERT(*thingp);
124077:     JSCompartment *c = (*thingp)->compartment();
124078:     if (!c->isCollecting() || c->isGCFinished())
 99246:         return true;
 99246:     return (*thingp)->isMarked();
 99246: }
 99246: 
124075: template <typename T>
124075: static bool
124075: IsAboutToBeFinalized(T **thingp)
124075: {
124075:     JS_ASSERT(thingp);
124075:     JS_ASSERT(*thingp);
124075:     if (!(*thingp)->compartment()->isGCSweeping())
124075:         return false;
124075:     return !(*thingp)->isMarked();
124075: }
124075: 
 90129: #define DeclMarkerImpl(base, type)                                                                \
 90129: void                                                                                              \
109329: Mark##base(JSTracer *trc, EncapsulatedPtr<type> *thing, const char *name)                         \
 90129: {                                                                                                 \
 90129:     Mark<type>(trc, thing, name);                                                                 \
 90129: }                                                                                                 \
 90129:                                                                                                   \
 90129: void                                                                                              \
 90409: Mark##base##Root(JSTracer *trc, type **thingp, const char *name)                                  \
 90129: {                                                                                                 \
 90409:     MarkRoot<type>(trc, thingp, name);                                                            \
 90129: }                                                                                                 \
 90129:                                                                                                   \
 90129: void                                                                                              \
 91557: Mark##base##Unbarriered(JSTracer *trc, type **thingp, const char *name)                           \
 90129: {                                                                                                 \
 91557:     MarkUnbarriered<type>(trc, thingp, name);                                                     \
 90129: }                                                                                                 \
 90129:                                                                                                   \
123696: void                                                                                              \
123696: Mark##base##Range(JSTracer *trc, size_t len, HeapPtr<type> *vec, const char *name)                \
 90129: {                                                                                                 \
 90129:     MarkRange<type>(trc, len, vec, name);                                                         \
 90129: }                                                                                                 \
 90129:                                                                                                   \
123696: void                                                                                              \
123696: Mark##base##RootRange(JSTracer *trc, size_t len, type **vec, const char *name)                    \
 90129: {                                                                                                 \
 90129:     MarkRootRange<type>(trc, len, vec, name);                                                     \
 90129: }                                                                                                 \
 99246:                                                                                                   \
123696: bool                                                                                              \
123696: Is##base##Marked(type **thingp)                                                                   \
 99246: {                                                                                                 \
 99246:     return IsMarked<type>(thingp);                                                                \
 99246: }                                                                                                 \
 99246:                                                                                                   \
123696: bool                                                                                              \
123696: Is##base##Marked(EncapsulatedPtr<type> *thingp)                                                   \
 99246: {                                                                                                 \
 99246:     return IsMarked<type>(thingp->unsafeGet());                                                   \
124075: }                                                                                                 \
124075:                                                                                                   \
124075: bool Is##base##AboutToBeFinalized(type **thingp)                                                  \
124075: {                                                                                                 \
124075:     return IsAboutToBeFinalized<type>(thingp);                                                    \
124075: }                                                                                                 \
124075:                                                                                                   \
124075: bool Is##base##AboutToBeFinalized(EncapsulatedPtr<type> *thingp)                                  \
124075: {                                                                                                 \
124075:     return IsAboutToBeFinalized<type>(thingp->unsafeGet());                                       \
 99246: }
 90129: 
 90129: DeclMarkerImpl(BaseShape, BaseShape)
 91557: DeclMarkerImpl(BaseShape, UnownedBaseShape)
113132: DeclMarkerImpl(IonCode, ion::IonCode)
 90129: DeclMarkerImpl(Object, ArgumentsObject)
 99246: DeclMarkerImpl(Object, DebugScopeObject)
 90129: DeclMarkerImpl(Object, GlobalObject)
 90129: DeclMarkerImpl(Object, JSObject)
 90129: DeclMarkerImpl(Object, JSFunction)
101995: DeclMarkerImpl(Object, ScopeObject)
 90129: DeclMarkerImpl(Script, JSScript)
 90129: DeclMarkerImpl(Shape, Shape)
 90129: DeclMarkerImpl(String, JSAtom)
 90129: DeclMarkerImpl(String, JSString)
 90129: DeclMarkerImpl(String, JSFlatString)
 90129: DeclMarkerImpl(String, JSLinearString)
108505: DeclMarkerImpl(String, PropertyName)
123696: DeclMarkerImpl(TypeObject, js::types::TypeObject)
 90129: #if JS_HAS_XML_SUPPORT
 90129: DeclMarkerImpl(XML, JSXML)
 90129: #endif
 90129: 
123696: } /* namespace gc */
123696: } /* namespace js */
123696: 
 90129: /*** Externally Typed Marking ***/
 90129: 
 68933: void
123696: gc::MarkKind(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 68933: {
 93352:     JS_ASSERT(thingp);
 93352:     JS_ASSERT(*thingp);
 93352:     JS_ASSERT(kind == GetGCThingTraceKind(*thingp));
 90129:     switch (kind) {
 90129:       case JSTRACE_OBJECT:
121675:         MarkInternal(trc, reinterpret_cast<JSObject **>(thingp));
 90129:         break;
 90129:       case JSTRACE_STRING:
121675:         MarkInternal(trc, reinterpret_cast<JSString **>(thingp));
 90129:         break;
 90129:       case JSTRACE_SCRIPT:
121675:         MarkInternal(trc, reinterpret_cast<JSScript **>(thingp));
 90129:         break;
 90129:       case JSTRACE_SHAPE:
 93352:         MarkInternal(trc, reinterpret_cast<Shape **>(thingp));
 90129:         break;
 90129:       case JSTRACE_BASE_SHAPE:
121675:         MarkInternal(trc, reinterpret_cast<BaseShape **>(thingp));
 90129:         break;
 90129:       case JSTRACE_TYPE_OBJECT:
 93352:         MarkInternal(trc, reinterpret_cast<types::TypeObject **>(thingp));
 90129:         break;
112701:       case JSTRACE_IONCODE:
112864:         MarkInternal(trc, reinterpret_cast<ion::IonCode **>(thingp));
112701:         break;
 90129: #if JS_HAS_XML_SUPPORT
 90129:       case JSTRACE_XML:
 93352:         MarkInternal(trc, reinterpret_cast<JSXML **>(thingp));
 90129:         break;
 90129: #endif
 90129:     }
 68933: }
 68933: 
123696: static void
113526: MarkGCThingInternal(JSTracer *trc, void **thingp, const char *name)
 68933: {
 90129:     JS_SET_TRACING_NAME(trc, name);
 93352:     JS_ASSERT(thingp);
 93352:     if (!*thingp)
 90129:         return;
 93352:     MarkKind(trc, thingp, GetGCThingTraceKind(*thingp));
 90129: }
 90129: 
113526: void
123696: gc::MarkGCThingRoot(JSTracer *trc, void **thingp, const char *name)
113526: {
113526:     JS_ROOT_MARKING_ASSERT(trc);
113526:     MarkGCThingInternal(trc, thingp, name);
113526: }
113526: 
113526: void
123696: gc::MarkGCThingUnbarriered(JSTracer *trc, void **thingp, const char *name)
113526: {
113526:     MarkGCThingInternal(trc, thingp, name);
113526: }
113526: 
 90129: /*** ID Marking ***/
 90129: 
 90129: static inline void
 90419: MarkIdInternal(JSTracer *trc, jsid *id)
 90129: {
 90419:     if (JSID_IS_STRING(*id)) {
 90419:         JSString *str = JSID_TO_STRING(*id);
109329:         JS_SET_TRACING_LOCATION(trc, (void *)id);
 93352:         MarkInternal(trc, &str);
 97828:         *id = NON_INTEGER_ATOM_TO_JSID(reinterpret_cast<JSAtom *>(str));
 90419:     } else if (JS_UNLIKELY(JSID_IS_OBJECT(*id))) {
 90419:         JSObject *obj = JSID_TO_OBJECT(*id);
109329:         JS_SET_TRACING_LOCATION(trc, (void *)id);
 93352:         MarkInternal(trc, &obj);
 90419:         *id = OBJECT_TO_JSID(obj);
109329:     } else {
109329:         /* Unset realLocation manually if we do not call MarkInternal. */
111405:         JS_UNSET_TRACING_LOCATION(trc);
 90419:     }
 68933: }
 68933: 
 68933: void
123696: gc::MarkId(JSTracer *trc, EncapsulatedId *id, const char *name)
 82129: {
 82129:     JS_SET_TRACING_NAME(trc, name);
 90419:     MarkIdInternal(trc, id->unsafeGet());
 82129: }
 82129: 
 82129: void
123696: gc::MarkIdRoot(JSTracer *trc, jsid *id, const char *name)
 82129: {
 90410:     JS_ROOT_MARKING_ASSERT(trc);
 90129:     JS_SET_TRACING_NAME(trc, name);
 90129:     MarkIdInternal(trc, id);
 82129: }
 82129: 
 82129: void
123696: gc::MarkIdUnbarriered(JSTracer *trc, jsid *id, const char *name)
 99246: {
 99246:     JS_SET_TRACING_NAME(trc, name);
 99246:     MarkIdInternal(trc, id);
 99246: }
 99246: 
 99246: void
123696: gc::MarkIdRange(JSTracer *trc, size_t len, HeapId *vec, const char *name)
 77659: {
 90129:     for (size_t i = 0; i < len; ++i) {
 90129:         JS_SET_TRACING_INDEX(trc, name, i);
 90419:         MarkIdInternal(trc, vec[i].unsafeGet());
 90129:     }
 77659: }
 77659: 
 77659: void
123696: gc::MarkIdRootRange(JSTracer *trc, size_t len, jsid *vec, const char *name)
 82129: {
 90410:     JS_ROOT_MARKING_ASSERT(trc);
 90129:     for (size_t i = 0; i < len; ++i) {
 90129:         JS_SET_TRACING_INDEX(trc, name, i);
 90419:         MarkIdInternal(trc, &vec[i]);
 90129:     }
 90129: }
 90129: 
 90129: /*** Value Marking ***/
 90129: 
 90129: static inline void
 90302: MarkValueInternal(JSTracer *trc, Value *v)
 90129: {
 90302:     if (v->isMarkable()) {
 90302:         JS_ASSERT(v->toGCThing());
 93352:         void *thing = v->toGCThing();
 98291:         JS_SET_TRACING_LOCATION(trc, (void *)v);
 93352:         MarkKind(trc, &thing, v->gcKind());
 93352:         if (v->isString())
 93352:             v->setString((JSString *)thing);
 93352:         else
 93352:             v->setObjectOrNull((JSObject *)thing);
 98291:     } else {
109329:         /* Unset realLocation manually if we do not call MarkInternal. */
111405:         JS_UNSET_TRACING_LOCATION(trc);
 90129:     }
 82129: }
 82129: 
 82129: void
123696: gc::MarkValue(JSTracer *trc, EncapsulatedValue *v, const char *name)
 90302: {
 90302:     JS_SET_TRACING_NAME(trc, name);
 90302:     MarkValueInternal(trc, v->unsafeGet());
 90302: }
 90302: 
 90302: void
123696: gc::MarkValueRoot(JSTracer *trc, Value *v, const char *name)
 68933: {
 90410:     JS_ROOT_MARKING_ASSERT(trc);
 68933:     JS_SET_TRACING_NAME(trc, name);
 90129:     MarkValueInternal(trc, v);
 68933: }
 68933: 
 77462: void
123696: gc::MarkTypeRoot(JSTracer *trc, types::Type *v, const char *name)
103321: {
103321:     JS_ROOT_MARKING_ASSERT(trc);
103321:     JS_SET_TRACING_NAME(trc, name);
103321:     if (v->isSingleObject()) {
103321:         JSObject *obj = v->singleObject();
103321:         MarkInternal(trc, &obj);
103321:         *v = types::Type::ObjectType(obj);
103321:     } else if (v->isTypeObject()) {
103321:         types::TypeObject *typeObj = v->typeObject();
103321:         MarkInternal(trc, &typeObj);
103321:         *v = types::Type::ObjectType(typeObj);
103321:     }
103321: }
103321: 
103321: void
123696: gc::MarkValueRange(JSTracer *trc, size_t len, EncapsulatedValue *vec, const char *name)
 82129: {
 90302:     for (size_t i = 0; i < len; ++i) {
 90302:         JS_SET_TRACING_INDEX(trc, name, i);
 90302:         MarkValueInternal(trc, vec[i].unsafeGet());
 90302:     }
 82129: }
 82129: 
 82129: void
123696: gc::MarkValueRootRange(JSTracer *trc, size_t len, Value *vec, const char *name)
 83221: {
 90410:     JS_ROOT_MARKING_ASSERT(trc);
 90129:     for (size_t i = 0; i < len; ++i) {
 90129:         JS_SET_TRACING_INDEX(trc, name, i);
 90302:         MarkValueInternal(trc, &vec[i]);
 90129:     }
 90129: }
 90129: 
 99246: bool
123696: gc::IsValueMarked(Value *v)
 99246: {
 99246:     JS_ASSERT(v->isMarkable());
 99246:     bool rv;
 99246:     if (v->isString()) {
 99246:         JSString *str = (JSString *)v->toGCThing();
 99246:         rv = IsMarked<JSString>(&str);
 99246:         v->setString(str);
 99246:     } else {
 99246:         JSObject *obj = (JSObject *)v->toGCThing();
 99246:         rv = IsMarked<JSObject>(&obj);
 99246:         v->setObject(*obj);
 99246:     }
 99246:     return rv;
 99246: }
 99246: 
124075: bool
124075: gc::IsValueAboutToBeFinalized(Value *v)
124075: {
124075:     JS_ASSERT(v->isMarkable());
124075:     bool rv;
124075:     if (v->isString()) {
124075:         JSString *str = (JSString *)v->toGCThing();
124075:         rv = IsAboutToBeFinalized<JSString>(&str);
124075:         v->setString(str);
124075:     } else {
124075:         JSObject *obj = (JSObject *)v->toGCThing();
124075:         rv = IsAboutToBeFinalized<JSObject>(&obj);
124075:         v->setObject(*obj);
124075:     }
124075:     return rv;
124075: }
124075: 
 91146: /*** Slot Marking ***/
 91146: 
 91146: void
123696: gc::MarkSlot(JSTracer *trc, HeapSlot *s, const char *name)
 91146: {
 91146:     JS_SET_TRACING_NAME(trc, name);
 91146:     MarkValueInternal(trc, s->unsafeGet());
 91146: }
 91146: 
 91146: void
123696: gc::MarkArraySlots(JSTracer *trc, size_t len, HeapSlot *vec, const char *name)
 91146: {
 91146:     for (size_t i = 0; i < len; ++i) {
 91146:         JS_SET_TRACING_INDEX(trc, name, i);
 91146:         MarkValueInternal(trc, vec[i].unsafeGet());
 91146:     }
 91146: }
 91146: 
 91146: void
123696: gc::MarkObjectSlots(JSTracer *trc, JSObject *obj, uint32_t start, uint32_t nslots)
 91557: {
 91557:     JS_ASSERT(obj->isNative());
 91557:     for (uint32_t i = start; i < (start + nslots); ++i) {
 98544:         JS_SET_TRACING_DETAILS(trc, js_GetObjectSlotName, obj, i);
 91557:         MarkValueInternal(trc, obj->nativeGetSlotRef(i).unsafeGet());
 91557:     }
 91557: }
 91557: 
124078: static bool
124078: ShouldMarkCrossCompartment(JSTracer *trc, RawObject src, Cell *cell)
 94620: {
124078:     if (!IS_GC_MARKING_TRACER(trc))
124078:         return true;
 94620: 
124078:     JSCompartment *c = cell->compartment();
124078:     uint32_t color = AsGCMarker(trc)->getMarkColor();
124078: 
124078:     JS_ASSERT(color == BLACK || color == GRAY);
124078:     if (color == BLACK) {
124078:         return c->isGCMarking();
124078:     } else {
124078:         if (c->isGCMarkingBlack()) {
124078:             /*
124078:              * The destination compartment is being not being marked gray now,
124078:              * but it will be later, so record the cell so it can be marked gray
124078:              * at the appropriate time.
124078:              */
124078:             if (!cell->isMarked())
124086:                 DelayCrossCompartmentGrayMarking(src);
124078:             return false;
124078:         }
124078:         return c->isGCMarkingGray();
124078:     }
 94620: }
 94620: 
 94620: void
124078: gc::MarkCrossCompartmentObjectUnbarriered(JSTracer *trc, RawObject src, JSObject **dst, const char *name)
 94620: {
124078:     if (ShouldMarkCrossCompartment(trc, src, *dst))
124078:         MarkObjectUnbarriered(trc, dst, name);
 94620: }
 94620: 
 94620: void
124078: gc::MarkCrossCompartmentScriptUnbarriered(JSTracer *trc, RawObject src, JSScript **dst,
124078:                                       const char *name)
 91146: {
124078:     if (ShouldMarkCrossCompartment(trc, src, *dst))
124078:         MarkScriptUnbarriered(trc, dst, name);
124078: }
 91146: 
124078: void
124078: gc::MarkCrossCompartmentSlot(JSTracer *trc, RawObject src, HeapSlot *dst, const char *name)
124078: {
124078:     if (dst->isMarkable() && ShouldMarkCrossCompartment(trc, src, (Cell *)dst->toGCThing()))
124078:         MarkSlot(trc, dst, name);
 91146: }
 91146: 
 90129: /*** Special Marking ***/
 90129: 
 91557: void
123696: gc::MarkObject(JSTracer *trc, HeapPtr<GlobalObject, JSScript *> *thingp, const char *name)
 90129: {
 90129:     JS_SET_TRACING_NAME(trc, name);
 93352:     MarkInternal(trc, thingp->unsafeGet());
 83301: }
 83301: 
 83301: void
123696: gc::MarkValueUnbarriered(JSTracer *trc, Value *v, const char *name)
 82129: {
 68933:     JS_SET_TRACING_NAME(trc, name);
 90129:     MarkValueInternal(trc, v);
 68933: }
 82129: 
 99246: bool
123696: gc::IsCellMarked(Cell **thingp)
 99246: {
 99246:     return IsMarked<Cell>(thingp);
 99246: }
 99246: 
124075: bool
124075: gc::IsCellAboutToBeFinalized(Cell **thingp)
124075: {
124075:     return IsAboutToBeFinalized<Cell>(thingp);
124075: }
124075: 
 90129: /*** Push Mark Stack ***/
 84456: 
 82602: #define JS_COMPARTMENT_ASSERT(rt, thing)                                \
124077:     JS_ASSERT((thing)->compartment()->isGCMarking())
 82602: 
 82602: #define JS_COMPARTMENT_ASSERT_STR(rt, thing)                            \
124077:     JS_ASSERT((thing)->compartment()->isGCMarking() ||                  \
 82602:               (thing)->compartment() == (rt)->atomsCompartment);
 82602: 
 98644: #if JS_HAS_XML_SUPPORT
 90129: static void
 68933: PushMarkStack(GCMarker *gcmarker, JSXML *thing)
 68933: {
 82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
 68933: 
 68933:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
 68933:         gcmarker->pushXML(thing);
 68933: }
 98644: #endif
 68933: 
 90129: static void
 68933: PushMarkStack(GCMarker *gcmarker, JSObject *thing)
 68933: {
 82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
 68933: 
 68933:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
 68933:         gcmarker->pushObject(thing);
 68933: }
 68933: 
 90129: static void
 68933: PushMarkStack(GCMarker *gcmarker, JSFunction *thing)
 68933: {
 82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
 68933: 
 68933:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
 68933:         gcmarker->pushObject(thing);
 68933: }
 68933: 
 90129: static void
 77462: PushMarkStack(GCMarker *gcmarker, types::TypeObject *thing)
 77462: {
 82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
 77462: 
 77462:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
 77462:         gcmarker->pushType(thing);
 77462: }
 77462: 
 90129: static void
 77659: PushMarkStack(GCMarker *gcmarker, JSScript *thing)
 77659: {
 82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
 77659: 
 77659:     /*
 77659:      * We mark scripts directly rather than pushing on the stack as they can
 77659:      * refer to other scripts only indirectly (like via nested functions) and
 77659:      * we cannot get to deep recursion.
 77659:      */
 77659:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
 77659:         MarkChildren(gcmarker, thing);
 77659: }
 77659: 
 68933: static void
 90419: ScanShape(GCMarker *gcmarker, Shape *shape);
 68933: 
 90129: static void
 90419: PushMarkStack(GCMarker *gcmarker, Shape *thing)
 68933: {
 82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
 68933: 
 68933:     /* We mark shapes directly rather than pushing on the stack. */
 68933:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
 68933:         ScanShape(gcmarker, thing);
 68933: }
 68933: 
123696: static void
112701: PushMarkStack(GCMarker *gcmarker, ion::IonCode *thing)
112701: {
112951:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
112701: 
112701:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
112701:         gcmarker->pushIonCode(thing);
112701: }
112701: 
 84456: static inline void
121675: ScanBaseShape(GCMarker *gcmarker, BaseShape *base);
 83221: 
 90129: static void
121675: PushMarkStack(GCMarker *gcmarker, BaseShape *thing)
 83221: {
 84456:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
 83221: 
 83221:     /* We mark base shapes directly rather than pushing on the stack. */
 83221:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
 83221:         ScanBaseShape(gcmarker, thing);
 83221: }
 83221: 
 83221: static void
 90419: ScanShape(GCMarker *gcmarker, Shape *shape)
 68933: {
 68933:   restart:
121675:     PushMarkStack(gcmarker, shape->base());
 68933: 
109329:     const EncapsulatedId &id = shape->propidRef();
 83221:     if (JSID_IS_STRING(id))
 83221:         PushMarkStack(gcmarker, JSID_TO_STRING(id));
 83221:     else if (JS_UNLIKELY(JSID_IS_OBJECT(id)))
 83221:         PushMarkStack(gcmarker, JSID_TO_OBJECT(id));
 68933: 
 68933:     shape = shape->previous();
 68933:     if (shape && shape->markIfUnmarked(gcmarker->getMarkColor()))
 68933:         goto restart;
 68933: }
 68933: 
 84456: static inline void
121675: ScanBaseShape(GCMarker *gcmarker, BaseShape *base)
 83221: {
 86163:     base->assertConsistency();
 86163: 
 83229:     if (base->hasGetterObject())
 83229:         PushMarkStack(gcmarker, base->getterObject());
 83221: 
 83229:     if (base->hasSetterObject())
 83229:         PushMarkStack(gcmarker, base->setterObject());
 83221: 
103784:     if (JSObject *parent = base->getObjectParent()) {
 83301:         PushMarkStack(gcmarker, parent);
103784:     } else if (GlobalObject *global = base->compartment()->maybeGlobal()) {
103784:         PushMarkStack(gcmarker, global);
103784:     }
 84456: 
 86163:     /*
 86163:      * All children of the owned base shape are consistent with its
 86163:      * unowned one, thus we do not need to trace through children of the
 86163:      * unowned base shape.
 86163:      */
 84456:     if (base->isOwned()) {
 84456:         UnownedBaseShape *unowned = base->baseUnowned();
 90129:         JS_ASSERT(base->compartment() == unowned->compartment());
 86163:         unowned->markIfUnmarked(gcmarker->getMarkColor());
 84456:     }
 83221: }
 83221: 
 68933: static inline void
 83415: ScanLinearString(GCMarker *gcmarker, JSLinearString *str)
 83415: {
 83415:     JS_COMPARTMENT_ASSERT_STR(gcmarker->runtime, str);
 83415:     JS_ASSERT(str->isMarked());
 83415: 
 83415:     /*
 83415:      * Add extra asserts to confirm the static type to detect incorrect string
 83415:      * mutations.
 83415:      */
 83415:     JS_ASSERT(str->JSString::isLinear());
102228:     while (str->hasBase()) {
102228:         str = str->base();
 83415:         JS_ASSERT(str->JSString::isLinear());
 83415:         JS_COMPARTMENT_ASSERT_STR(gcmarker->runtime, str);
 83415:         if (!str->markIfUnmarked())
 83415:             break;
 83415:     }
 83415: }
 83415: 
 84455: /*
 84455:  * The function tries to scan the whole rope tree using the marking stack as
 84455:  * temporary storage. If that becomes full, the unscanned ropes are added to
 84455:  * the delayed marking list. When the function returns, the marking stack is
 84456:  * at the same depth as it was on entry. This way we avoid using tags when
 84456:  * pushing ropes to the stack as ropes never leaks to other users of the
 84456:  * stack. This also assumes that a rope can only point to other ropes or
 84456:  * linear strings, it cannot refer to GC things of other types.
 84455:  */
 83415: static void
 71345: ScanRope(GCMarker *gcmarker, JSRope *rope)
 71345: {
 90410:     ptrdiff_t savedPos = gcmarker->stack.position();
 84455:     for (;;) {
 84455:         JS_ASSERT(GetGCThingTraceKind(rope) == JSTRACE_STRING);
 83415:         JS_ASSERT(rope->JSString::isRope());
 82602:         JS_COMPARTMENT_ASSERT_STR(gcmarker->runtime, rope);
 71345:         JS_ASSERT(rope->isMarked());
 83415:         JSRope *next = NULL;
 71345: 
 83415:         JSString *right = rope->rightChild();
 83415:         if (right->markIfUnmarked()) {
 83415:             if (right->isLinear())
 83415:                 ScanLinearString(gcmarker, &right->asLinear());
 83415:             else
 83415:                 next = &right->asRope();
 83415:         }
 71345: 
 83415:         JSString *left = rope->leftChild();
 83415:         if (left->markIfUnmarked()) {
 83415:             if (left->isLinear()) {
 83415:                 ScanLinearString(gcmarker, &left->asLinear());
 71345:             } else {
 83415:                 /*
 84455:                  * When both children are ropes, set aside the right one to
 84455:                  * scan it later.
 83415:                  */
 84456:                 if (next && !gcmarker->stack.push(reinterpret_cast<uintptr_t>(next)))
 84455:                     gcmarker->delayMarkingChildren(next);
 83415:                 next = &left->asRope();
 71345:             }
 71345:         }
 84455:         if (next) {
 83415:             rope = next;
 90410:         } else if (savedPos != gcmarker->stack.position()) {
 90410:             JS_ASSERT(savedPos < gcmarker->stack.position());
 84456:             rope = reinterpret_cast<JSRope *>(gcmarker->stack.pop());
 84455:         } else {
 84455:             break;
 84455:         }
 84455:     }
 90410:     JS_ASSERT(savedPos == gcmarker->stack.position());
 84455:  }
 84455: 
 84455: static inline void
 84455: ScanString(GCMarker *gcmarker, JSString *str)
 84455: {
 84455:     if (str->isLinear())
 84455:         ScanLinearString(gcmarker, &str->asLinear());
 84455:     else
 84455:         ScanRope(gcmarker, &str->asRope());
 71345: }
 71345: 
 71345: static inline void
 68933: PushMarkStack(GCMarker *gcmarker, JSString *str)
 68933: {
 82602:     JS_COMPARTMENT_ASSERT_STR(gcmarker->runtime, str);
 68933: 
 83415:     /*
 84455:      * As string can only refer to other strings we fully scan its GC graph
 84455:      * using the explicit stack when navigating the rope tree to avoid
 84455:      * dealing with strings on the stack in drainMarkStack.
 83415:      */
 84455:     if (str->markIfUnmarked())
 84455:         ScanString(gcmarker, str);
 68933: }
 68933: 
 68933: void
123696: gc::MarkChildren(JSTracer *trc, JSObject *obj)
 68933: {
 91557:     obj->markChildren(trc);
 68933: }
 68933: 
 90129: static void
123696: gc::MarkChildren(JSTracer *trc, JSString *str)
 68933: {
102228:     if (str->hasBase())
102228:         str->markBase(trc);
 91557:     else if (str->isRope())
 91557:         str->asRope().markChildren(trc);
 68933: }
 68933: 
 90129: static void
123696: gc::MarkChildren(JSTracer *trc, JSScript *script)
 77659: {
 91557:     script->markChildren(trc);
 77659: }
 77659: 
 90129: static void
123696: gc::MarkChildren(JSTracer *trc, Shape *shape)
 68933: {
 91557:     shape->markChildren(trc);
 85055: }
 85055: 
 90129: static void
123696: gc::MarkChildren(JSTracer *trc, BaseShape *base)
 83221: {
 91557:     base->markChildren(trc);
 83221: }
 83221: 
 85055: /*
 85055:  * This function is used by the cycle collector to trace through the
 85055:  * children of a BaseShape (and its baseUnowned(), if any). The cycle
 85055:  * collector does not directly care about BaseShapes, so only the
 85055:  * getter, setter, and parent are marked. Furthermore, the parent is
 85055:  * marked only if it isn't the same as prevParent, which will be
 85055:  * updated to the current shape's parent.
 85055:  */
123696: static inline void
121675: MarkCycleCollectorChildren(JSTracer *trc, BaseShape *base, JSObject **prevParent)
 85055: {
 85055:     JS_ASSERT(base);
 85055: 
 86163:     /*
 86163:      * The cycle collector does not need to trace unowned base shapes,
 86163:      * as they have the same getter, setter and parent as the original
 86163:      * base shape.
 86163:      */
 86163:     base->assertConsistency();
 86163: 
 91557:     if (base->hasGetterObject()) {
 91557:         JSObject *tmp = base->getterObject();
 91557:         MarkObjectUnbarriered(trc, &tmp, "getter");
 91557:         JS_ASSERT(tmp == base->getterObject());
 91557:     }
 91557: 
 91557:     if (base->hasSetterObject()) {
 91557:         JSObject *tmp = base->setterObject();
 91557:         MarkObjectUnbarriered(trc, &tmp, "setter");
 91557:         JS_ASSERT(tmp == base->setterObject());
 91557:     }
 85055: 
 85055:     JSObject *parent = base->getObjectParent();
 85055:     if (parent && parent != *prevParent) {
 91557:         MarkObjectUnbarriered(trc, &parent, "parent");
 91557:         JS_ASSERT(parent == base->getObjectParent());
 85055:         *prevParent = parent;
 85055:     }
 85055: }
 85055: 
 85055: /*
 85055:  * This function is used by the cycle collector to trace through a
 85055:  * shape. The cycle collector does not care about shapes or base
 85055:  * shapes, so those are not marked. Instead, any shapes or base shapes
 85055:  * that are encountered have their children marked. Stack space is
 85055:  * bounded. If two shapes in a row have the same parent pointer, the
 85055:  * parent pointer will only be marked once.
 85055:  */
 85055: void
123696: gc::MarkCycleCollectorChildren(JSTracer *trc, Shape *shape)
 85055: {
121675:     JSObject *prevParent = NULL;
 85055:     do {
121675:         MarkCycleCollectorChildren(trc, shape->base(), &prevParent);
 90419:         MarkId(trc, &shape->propidRef(), "propid");
 85055:         shape = shape->previous();
 85055:     } while (shape);
 85055: }
 85055: 
 77462: static void
 77462: ScanTypeObject(GCMarker *gcmarker, types::TypeObject *type)
 77462: {
 95294:     /* Don't mark properties for singletons. They'll be purged by the GC. */
 77462:     if (!type->singleton) {
 77462:         unsigned count = type->getPropertyCount();
 77462:         for (unsigned i = 0; i < count; i++) {
 77462:             types::Property *prop = type->getProperty(i);
 78537:             if (prop && JSID_IS_STRING(prop->id))
 78537:                 PushMarkStack(gcmarker, JSID_TO_STRING(prop->id));
 77462:         }
 77462:     }
 77462: 
115021:     if (TaggedProto(type->proto).isObject())
 77462:         PushMarkStack(gcmarker, type->proto);
 77462: 
 94704:     if (type->singleton && !type->lazy())
 94704:         PushMarkStack(gcmarker, type->singleton);
 94704: 
 77462:     if (type->newScript) {
 77884:         PushMarkStack(gcmarker, type->newScript->fun);
 77462:         PushMarkStack(gcmarker, type->newScript->shape);
 77462:     }
 77462: 
 83236:     if (type->interpretedFunction)
 83236:         PushMarkStack(gcmarker, type->interpretedFunction);
 77462: }
 77462: 
 90129: static void
123696: gc::MarkChildren(JSTracer *trc, types::TypeObject *type)
 77462: {
 77462:     unsigned count = type->getPropertyCount();
 77462:     for (unsigned i = 0; i < count; i++) {
 77462:         types::Property *prop = type->getProperty(i);
 77462:         if (prop)
 90419:             MarkId(trc, &prop->id, "type_prop");
 77462:     }
 77462: 
115021:     if (TaggedProto(type->proto).isObject())
 90409:         MarkObject(trc, &type->proto, "type_proto");
 77462: 
 83249:     if (type->singleton && !type->lazy())
 90409:         MarkObject(trc, &type->singleton, "type_singleton");
 77462: 
 77462:     if (type->newScript) {
 90409:         MarkObject(trc, &type->newScript->fun, "type_new_function");
 90409:         MarkShape(trc, &type->newScript->shape, "type_new_shape");
 77462:     }
 77462: 
 77884:     if (type->interpretedFunction)
 90409:         MarkObject(trc, &type->interpretedFunction, "type_function");
 77462: }
 77462: 
123696: static void
123696: gc::MarkChildren(JSTracer *trc, ion::IonCode *code)
111793: {
112298: #ifdef JS_ION
111865:     code->trace(trc);
112298: #endif
112297: }
111793: 
 98644: #if JS_HAS_XML_SUPPORT
 90129: static void
123696: gc::MarkChildren(JSTracer *trc, JSXML *xml)
 68933: {
 68933:     js_TraceXML(trc, xml);
 68933: }
 68933: #endif
 68933: 
 90410: template<typename T>
123696: static void
 90410: PushArenaTyped(GCMarker *gcmarker, ArenaHeader *aheader)
 90410: {
 90410:     for (CellIterUnderGC i(aheader); !i.done(); i.next())
 90410:         PushMarkStack(gcmarker, i.get<T>());
 90410: }
 90410: 
 90410: void
123696: gc::PushArena(GCMarker *gcmarker, ArenaHeader *aheader)
 90410: {
 90410:     switch (MapAllocToTraceKind(aheader->getAllocKind())) {
 90410:       case JSTRACE_OBJECT:
 90410:         PushArenaTyped<JSObject>(gcmarker, aheader);
 90410:         break;
 90410: 
 90410:       case JSTRACE_STRING:
 90410:         PushArenaTyped<JSString>(gcmarker, aheader);
 90410:         break;
 90410: 
 90410:       case JSTRACE_SCRIPT:
 90410:         PushArenaTyped<JSScript>(gcmarker, aheader);
 90410:         break;
 90410: 
 90410:       case JSTRACE_SHAPE:
 90410:         PushArenaTyped<js::Shape>(gcmarker, aheader);
 90410:         break;
 90410: 
 90410:       case JSTRACE_BASE_SHAPE:
 90410:         PushArenaTyped<js::BaseShape>(gcmarker, aheader);
 90410:         break;
 90410: 
 90410:       case JSTRACE_TYPE_OBJECT:
 90410:         PushArenaTyped<js::types::TypeObject>(gcmarker, aheader);
 90410:         break;
 90410: 
112731:       case JSTRACE_IONCODE:
112731:         PushArenaTyped<js::ion::IonCode>(gcmarker, aheader);
112731:         break;
112731: 
 90410: #if JS_HAS_XML_SUPPORT
 90410:       case JSTRACE_XML:
 90410:         PushArenaTyped<JSXML>(gcmarker, aheader);
 90410:         break;
 90410: #endif
 90410:     }
 90410: }
 90410: 
 91146: struct SlotArrayLayout
 90410: {
 90410:     union {
 91146:         HeapSlot *end;
 90410:         js::Class *clasp;
 90410:     };
 90410:     union {
 91146:         HeapSlot *start;
 90410:         uintptr_t index;
 90410:     };
 90410:     JSObject *obj;
 90410: 
 90410:     static void staticAsserts() {
 90410:         /* This should have the same layout as three mark stack items. */
 91146:         JS_STATIC_ASSERT(sizeof(SlotArrayLayout) == 3 * sizeof(uintptr_t));
 90410:     }
 90410: };
 90410: 
 90410: /*
 90410:  * During incremental GC, we return from drainMarkStack without having processed
 90410:  * the entire stack. At that point, JS code can run and reallocate slot arrays
 90410:  * that are stored on the stack. To prevent this from happening, we replace all
 90410:  * ValueArrayTag stack items with SavedValueArrayTag. In the latter, slots
 90410:  * pointers are replaced with slot indexes.
 90410:  *
 90410:  * We also replace the slot array end pointer (which can be derived from the obj
 90410:  * pointer) with the object's class. During JS executation, array slowification
 90410:  * can cause the layout of slots to change. We can observe that slowification
 90410:  * happened if the class changed; in that case, we completely rescan the array.
 90410:  */
 90410: void
 90410: GCMarker::saveValueRanges()
 90410: {
 90410:     for (uintptr_t *p = stack.tos; p > stack.stack; ) {
 90410:         uintptr_t tag = *--p & StackTagMask;
 90410:         if (tag == ValueArrayTag) {
 90410:             p -= 2;
 91146:             SlotArrayLayout *arr = reinterpret_cast<SlotArrayLayout *>(p);
 90410:             JSObject *obj = arr->obj;
 90410: 
 90410:             if (obj->getClass() == &ArrayClass) {
 91146:                 HeapSlot *vp = obj->getDenseArrayElements();
 90410:                 JS_ASSERT(arr->start >= vp &&
 90410:                           arr->end == vp + obj->getDenseArrayInitializedLength());
 90410:                 arr->index = arr->start - vp;
 90410:             } else {
 91146:                 HeapSlot *vp = obj->fixedSlots();
 90410:                 unsigned nfixed = obj->numFixedSlots();
 95634:                 if (arr->start == arr->end) {
 95634:                     arr->index = obj->slotSpan();
 95634:                 } else if (arr->start >= vp && arr->start < vp + nfixed) {
 90410:                     JS_ASSERT(arr->end == vp + Min(nfixed, obj->slotSpan()));
 90410:                     arr->index = arr->start - vp;
 90410:                 } else {
 90410:                     JS_ASSERT(arr->start >= obj->slots &&
 90410:                               arr->end == obj->slots + obj->slotSpan() - nfixed);
 90410:                     arr->index = (arr->start - obj->slots) + nfixed;
 90410:                 }
 90410:             }
 90410:             arr->clasp = obj->getClass();
 90410:             p[2] |= SavedValueArrayTag;
 90410:         } else if (tag == SavedValueArrayTag) {
 90410:             p -= 2;
 90410:         }
 90410:     }
 90410: }
 90410: 
 90410: bool
 90410: GCMarker::restoreValueArray(JSObject *obj, void **vpp, void **endp)
 90410: {
 90410:     uintptr_t start = stack.pop();
 90410:     js::Class *clasp = reinterpret_cast<js::Class *>(stack.pop());
 90410: 
 90410:     JS_ASSERT(obj->getClass() == clasp ||
 90410:               (clasp == &ArrayClass && obj->getClass() == &SlowArrayClass));
 90410: 
 90410:     if (clasp == &ArrayClass) {
 90410:         if (obj->getClass() != &ArrayClass)
 90410:             return false;
 90410: 
 90410:         uint32_t initlen = obj->getDenseArrayInitializedLength();
 91146:         HeapSlot *vp = obj->getDenseArrayElements();
 90410:         if (start < initlen) {
 90410:             *vpp = vp + start;
 90410:             *endp = vp + initlen;
 90410:         } else {
 90410:             /* The object shrunk, in which case no scanning is needed. */
 90410:             *vpp = *endp = vp;
 90410:         }
 90410:     } else {
 91146:         HeapSlot *vp = obj->fixedSlots();
 90410:         unsigned nfixed = obj->numFixedSlots();
 90410:         unsigned nslots = obj->slotSpan();
 97348:         if (start < nslots) {
 90410:             if (start < nfixed) {
 90410:                 *vpp = vp + start;
 90410:                 *endp = vp + Min(nfixed, nslots);
 97348:             } else {
 90410:                 *vpp = obj->slots + start - nfixed;
 90410:                 *endp = obj->slots + nslots - nfixed;
 97348:             }
 90410:         } else {
 90410:             /* The object shrunk, in which case no scanning is needed. */
 97348:             *vpp = *endp = vp;
 90410:         }
 90410:     }
 90410: 
 90410:     JS_ASSERT(*vpp <= *endp);
 90410:     return true;
 90410: }
 90410: 
 95634: void
 98898: GCMarker::processMarkStackOther(SliceBudget &budget, uintptr_t tag, uintptr_t addr)
 95634: {
 95634:     if (tag == TypeTag) {
 95634:         ScanTypeObject(this, reinterpret_cast<types::TypeObject *>(addr));
 95634:     } else if (tag == SavedValueArrayTag) {
124435:         JS_ASSERT(!(addr & CellMask));
 95634:         JSObject *obj = reinterpret_cast<JSObject *>(addr);
 95634:         HeapValue *vp, *end;
 95634:         if (restoreValueArray(obj, (void **)&vp, (void **)&end))
 95634:             pushValueArray(obj, vp, end);
 95634:         else
 95634:             pushObject(obj);
112999:     } else if (tag == IonCodeTag) {
112999:         MarkChildren(this, reinterpret_cast<ion::IonCode *>(addr));
 98898:     } else if (tag == ArenaTag) {
 98898:         ArenaHeader *aheader = reinterpret_cast<ArenaHeader *>(addr);
 98898:         AllocKind thingKind = aheader->getAllocKind();
 98898:         size_t thingSize = Arena::thingSize(thingKind);
 98898: 
 98898:         for ( ; aheader; aheader = aheader->next) {
 98898:             Arena *arena = aheader->getArena();
 98898:             FreeSpan firstSpan(aheader->getFirstFreeSpan());
 98898:             const FreeSpan *span = &firstSpan;
 98898: 
 98898:             for (uintptr_t thing = arena->thingsStart(thingKind); ; thing += thingSize) {
 98898:                 JS_ASSERT(thing <= arena->thingsEnd());
 98898:                 if (thing == span->first) {
 98898:                     if (!span->hasNext())
 98898:                         break;
 98898:                     thing = span->last;
 98898:                     span = span->nextSpan();
 98898:                 } else {
 98898:                     JSObject *object = reinterpret_cast<JSObject *>(thing);
 98965:                     if (object->hasSingletonType() && object->markIfUnmarked(getMarkColor()))
 98898:                         pushObject(object);
 98898:                     budget.step();
 98644:                 }
 98898:             }
 98898:             if (budget.isOverBudget()) {
 98898:                 pushArenaList(aheader);
 98898:                 return;
 98898:             }
 98898:         }
 98898:     }
 98898: 
 98644: #if JS_HAS_XML_SUPPORT
 98644:     else {
 95634:         JS_ASSERT(tag == XmlTag);
 95634:         MarkChildren(this, reinterpret_cast<JSXML *>(addr));
 95634:     }
 98644: #endif
 95634: }
 95634: 
 84456: inline void
 90410: GCMarker::processMarkStackTop(SliceBudget &budget)
 84456: {
 84456:     /*
 84719:      * The function uses explicit goto and implements the scanning of the
 84719:      * object directly. It allows to eliminate the tail recursion and
 84719:      * significantly improve the marking performance, see bug 641025.
 84456:      */
 91146:     HeapSlot *vp, *end;
 84456:     JSObject *obj;
 84456: 
 84456:     uintptr_t addr = stack.pop();
 84456:     uintptr_t tag = addr & StackTagMask;
 84719:     addr &= ~StackTagMask;
 84719: 
 84456:     if (tag == ValueArrayTag) {
 84456:         JS_STATIC_ASSERT(ValueArrayTag == 0);
124435:         JS_ASSERT(!(addr & CellMask));
 84719:         obj = reinterpret_cast<JSObject *>(addr);
 84456:         uintptr_t addr2 = stack.pop();
 84719:         uintptr_t addr3 = stack.pop();
 84719:         JS_ASSERT(addr2 <= addr3);
 84719:         JS_ASSERT((addr3 - addr2) % sizeof(Value) == 0);
 91146:         vp = reinterpret_cast<HeapSlot *>(addr2);
 91146:         end = reinterpret_cast<HeapSlot *>(addr3);
 84456:         goto scan_value_array;
 84456:     }
 84456: 
 84456:     if (tag == ObjectTag) {
 84456:         obj = reinterpret_cast<JSObject *>(addr);
 90410:         JS_COMPARTMENT_ASSERT(runtime, obj);
 84456:         goto scan_obj;
 84719:     }
 84719: 
 98898:     processMarkStackOther(budget, tag, addr);
 84456:     return;
 84456: 
 84456:   scan_value_array:
 84719:     JS_ASSERT(vp <= end);
 84719:     while (vp != end) {
 84456:         const Value &v = *vp++;
 84456:         if (v.isString()) {
 84456:             JSString *str = v.toString();
 90410:             JS_COMPARTMENT_ASSERT_STR(runtime, str);
109017:             JS_ASSERT(str->compartment() == runtime->atomsCompartment ||
109017:                       str->compartment() == obj->compartment());
 84456:             if (str->markIfUnmarked())
 84456:                 ScanString(this, str);
 84456:         } else if (v.isObject()) {
 84719:             JSObject *obj2 = &v.toObject();
 90410:             JS_COMPARTMENT_ASSERT(runtime, obj2);
109017:             JS_ASSERT(obj->compartment() == obj2->compartment());
 84719:             if (obj2->markIfUnmarked(getMarkColor())) {
 90410:                 pushValueArray(obj, vp, end);
 84719:                 obj = obj2;
 84456:                 goto scan_obj;
 84456:             }
 84456:         }
 84719:     }
 84456:     return;
 84456: 
 84456:   scan_obj:
 84719:     {
 90410:         JS_COMPARTMENT_ASSERT(runtime, obj);
 90410: 
 90410:         budget.step();
 90410:         if (budget.isOverBudget()) {
 90410:             pushObject(obj);
 90410:             return;
 90410:         }
 90410: 
 84719:         types::TypeObject *type = obj->typeFromGC();
 84719:         PushMarkStack(this, type);
 84719: 
 90302:         Shape *shape = obj->lastProperty();
 84719:         PushMarkStack(this, shape);
 84719: 
 84719:         /* Call the trace hook if necessary. */
 84719:         Class *clasp = shape->getObjectClass();
 84719:         if (clasp->trace) {
 84719:             if (clasp == &ArrayClass) {
 84719:                 JS_ASSERT(!shape->isNative());
 84719:                 vp = obj->getDenseArrayElements();
 84719:                 end = vp + obj->getDenseArrayInitializedLength();
 84719:                 goto scan_value_array;
 90410:             } else {
102694:                 JS_ASSERT_IF(runtime->gcMode == JSGC_MODE_INCREMENTAL &&
102694:                              runtime->gcIncrementalEnabled,
 90410:                              clasp->flags & JSCLASS_IMPLEMENTS_BARRIERS);
 84719:             }
 84719:             clasp->trace(this, obj);
 84719:         }
 84719: 
 84719:         if (!shape->isNative())
 84719:             return;
 84719: 
 84456:         unsigned nslots = obj->slotSpan();
 84456:         vp = obj->fixedSlots();
 84456:         if (obj->slots) {
 84456:             unsigned nfixed = obj->numFixedSlots();
 84456:             if (nslots > nfixed) {
 90410:                 pushValueArray(obj, vp, vp + nfixed);
 84456:                 vp = obj->slots;
 84456:                 end = vp + (nslots - nfixed);
 84456:                 goto scan_value_array;
 84456:             }
 84456:         }
 84719:         JS_ASSERT(nslots <= obj->numFixedSlots());
 84456:         end = vp + nslots;
 84456:         goto scan_value_array;
 84456:     }
 84456: }
 84456: 
 90410: bool
 90410: GCMarker::drainMarkStack(SliceBudget &budget)
 68933: {
 90410: #ifdef DEBUG
 82129:     JSRuntime *rt = runtime;
 90410: 
 90410:     struct AutoCheckCompartment {
 90410:         JSRuntime *runtime;
 90410:         AutoCheckCompartment(JSRuntime *rt) : runtime(rt) {
 94620:             JS_ASSERT(!rt->gcStrictCompartmentChecking);
 94620:             runtime->gcStrictCompartmentChecking = true;
 90410:         }
 94620:         ~AutoCheckCompartment() { runtime->gcStrictCompartmentChecking = false; }
 90410:     } acc(rt);
 90410: #endif
 90410: 
 90410:     if (budget.isOverBudget())
 90410:         return false;
 73561: 
 84456:     for (;;) {
 90410:         while (!stack.isEmpty()) {
 90410:             processMarkStackTop(budget);
 90410:             if (budget.isOverBudget()) {
 90410:                 saveValueRanges();
 90410:                 return false;
 90410:             }
 90410:         }
 90410: 
 84456:         if (!hasDelayedChildren())
 84456:             break;
 68933: 
 68933:         /*
 84456:          * Mark children of things that caused too deep recursion during the
 84456:          * above tracing. Don't do this until we're done with everything
 84456:          * else.
 68933:          */
 90410:         if (!markDelayedChildren(budget)) {
 90410:             saveValueRanges();
 90410:             return false;
 90410:         }
 68933:     }
 73561: 
 90410:     return true;
 68933: }
 68933: 
 82129: void
123696: js::TraceChildren(JSTracer *trc, void *thing, JSGCTraceKind kind)
 68933: {
 68933:     switch (kind) {
 77715:       case JSTRACE_OBJECT:
121675:         MarkChildren(trc, static_cast<JSObject *>(thing));
 68933:         break;
 68933: 
 68933:       case JSTRACE_STRING:
121675:         MarkChildren(trc, static_cast<JSString *>(thing));
 77659:         break;
 77659: 
 77659:       case JSTRACE_SCRIPT:
121675:         MarkChildren(trc, static_cast<JSScript *>(thing));
 68933:         break;
 68933: 
 68933:       case JSTRACE_SHAPE:
 77659:         MarkChildren(trc, static_cast<Shape *>(thing));
 68933:         break;
 68933: 
111793:       case JSTRACE_IONCODE:
111793:         MarkChildren(trc, (js::ion::IonCode *)thing);
111793:         break;
111793: 
 83221:       case JSTRACE_BASE_SHAPE:
121675:         MarkChildren(trc, static_cast<BaseShape *>(thing));
 83221:         break;
 83221: 
 77462:       case JSTRACE_TYPE_OBJECT:
 77462:         MarkChildren(trc, (types::TypeObject *)thing);
 77462:         break;
 77462: 
 68933: #if JS_HAS_XML_SUPPORT
 68933:       case JSTRACE_XML:
 77659:         MarkChildren(trc, static_cast<JSXML *>(thing));
 68933:         break;
 68933: #endif
 68933:     }
 68933: }
 77343: 
 82129: void
123696: js::CallTracer(JSTracer *trc, void *thing, JSGCTraceKind kind)
 82129: {
 82129:     JS_ASSERT(thing);
 93352:     void *tmp = thing;
 93352:     MarkKind(trc, &tmp, kind);
 93352:     JS_ASSERT(tmp == thing);
 82129: }
