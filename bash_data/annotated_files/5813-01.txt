   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 2001
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Peter Annema <jaggernaut@netscape.com> (original author)
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: #ifndef nsUTF8Utils_h_
   1: #define nsUTF8Utils_h_
   1: 
   1: #include "nsCharTraits.h"
   1: 
   1: class UTF8traits
   1:   {
   1:     public:
   1:       static PRBool isASCII(char c) { return (c & 0x80) == 0x00; }
   1:       static PRBool isInSeq(char c) { return (c & 0xC0) == 0x80; }
   1:       static PRBool is2byte(char c) { return (c & 0xE0) == 0xC0; }
   1:       static PRBool is3byte(char c) { return (c & 0xF0) == 0xE0; }
   1:       static PRBool is4byte(char c) { return (c & 0xF8) == 0xF0; }
   1:       static PRBool is5byte(char c) { return (c & 0xFC) == 0xF8; }
   1:       static PRBool is6byte(char c) { return (c & 0xFE) == 0xFC; }
   1:   };
   1: 
   1: #ifdef __GNUC__
   1: #define NS_ALWAYS_INLINE __attribute__((always_inline))
   1: #else
   1: #define NS_ALWAYS_INLINE
   1: #endif
   1: 
   1: /**
   1:  * Extract the next UCS-4 character from the buffer and return it.  The
   1:  * pointer passed in is advanced to the start of the next character in the
   1:  * buffer.  If non-null, the parameters err and overlong are filled in to
   1:  * indicate that the character was represented by an overlong sequence, or
   1:  * that an error occurred.
   1:  */
   1: 
   1: class UTF8CharEnumerator
   1: {
   1: public:
   1:   static PRUint32 NextChar(const char **buffer, const char *end,
   1:                            PRBool *err = nsnull, PRBool* overlong = nsnull)
   1:   {
   1:     NS_ASSERTION(buffer && *buffer, "null buffer!");
   1: 
   1:     const char *p = *buffer;
   1: 
   1:     if (p >= end)
   1:       {
   1:         if (err)
   1:           *err = PR_TRUE;
   1: 
   1:         return 0;
   1:       }
   1: 
   1:     char c = *p++;
   1: 
   1:     if ( UTF8traits::isASCII(c) )
   1:       {
   1:         if (err)
   1:           *err = PR_FALSE;
   1:         if (overlong)
   1:           *overlong = PR_FALSE;
   1:         *buffer = p;
   1:         return c;
   1:       }
   1: 
   1:     PRUint32 ucs4;
   1:     PRUint32 minUcs4;
   1:     PRInt32 state = 0;
   1: 
   1:     if (!CalcState(c, ucs4, minUcs4, state)) {
   1:         NS_ERROR("Not a UTF-8 string. This code should only be used for converting from known UTF-8 strings.");
   1:         if (err)
   1:           *err = PR_TRUE;
   1:         return 0;
   1:     }
   1: 
   1:     while ( state-- )
   1:       {
   1:         if (p == end)
   1:           {
   1:             if (err)
   1:               *err = PR_TRUE;
   1: 
   1:             return 0;
   1:           }
   1: 
   1:         c = *p++;
   1: 
   1:         if (!AddByte(c, state, ucs4))
   1:           {
   1:             NS_ERROR("not a UTF8 string");
   1:             if (err)
   1:               *err = PR_TRUE;
   1:             return 0;
   1:           }
   1:       }
   1: 
   1:     if (err)
   1:       *err = PR_FALSE;
   1:     if (overlong)
   1:       *overlong = ucs4 < minUcs4;
   1:     *buffer = p;
   1:     return ucs4;
   1:   }
   1: 
   1:   static PRUint32 NextChar(nsACString::const_iterator& iter,
   1:                            const nsACString::const_iterator& end,
   1:                            PRBool *err = nsnull, PRBool *overlong = nsnull)
   1:   {
   1:     if ( iter == end )
   1:       {
   1:         NS_ERROR("No input to work with");
   1:         if (err)
   1:           *err = PR_TRUE;
   1: 
   1:         return 0;
   1:       }
   1: 
   1:     char c = *iter++;
   1: 
   1:     if ( UTF8traits::isASCII(c) )
   1:       {
   1:         if (err)
   1:           *err = PR_FALSE;
   1:         if (overlong)
   1:           *overlong = PR_FALSE;
   1:         return c;
   1:       }
   1: 
   1:     PRUint32 ucs4;
   1:     PRUint32 minUcs4;
   1:     PRInt32 state = 0;
   1: 
   1:     if (!CalcState(c, ucs4, minUcs4, state)) {
   1:         NS_ERROR("Not a UTF-8 string. This code should only be used for converting from known UTF-8 strings.");
   1:         if (err)
   1:           *err = PR_TRUE;
   1:         return 0;
   1:     }
   1: 
   1:     while ( state-- )
   1:       {
   1:         if (iter == end)
   1:           {
   1:             NS_ERROR("Buffer ended in the middle of a multibyte sequence");
   1:             if (err)
   1:               *err = PR_TRUE;
   1: 
   1:             return 0;
   1:           }
   1: 
   1:         c = *iter++;
   1: 
   1:         if (!AddByte(c, state, ucs4))
   1:           {
   1:             NS_ERROR("not a UTF8 string");
   1:             if (err)
   1:               *err = PR_TRUE;
   1:             return 0;
   1:           }
   1:       }
   1: 
   1:     if (err)
   1:       *err = PR_FALSE;
   1:     if (overlong)
   1:       *overlong = ucs4 < minUcs4;
   1:     return ucs4;
   1:   }
   1: 
   1: private:
   1:   static PRBool CalcState(char c, PRUint32& ucs4, PRUint32& minUcs4,
   1:                           PRInt32& state)
   1:   {
   1:     if ( UTF8traits::is2byte(c) )
   1:       {
   1:         ucs4 = (PRUint32(c) << 6) & 0x000007C0L;
   1:         state = 1;
   1:         minUcs4 = 0x00000080;
   1:       }
   1:     else if ( UTF8traits::is3byte(c) )
   1:       {
   1:         ucs4 = (PRUint32(c) << 12) & 0x0000F000L;
   1:         state = 2;
   1:         minUcs4 = 0x00000800;
   1:       }
   1:     else if ( UTF8traits::is4byte(c) )
   1:       {
   1:         ucs4 = (PRUint32(c) << 18) & 0x001F0000L;
   1:         state = 3;
   1:         minUcs4 = 0x00010000;
   1:       }
   1:     else if ( UTF8traits::is5byte(c) )
   1:       {
   1:         ucs4 = (PRUint32(c) << 24) & 0x03000000L;
   1:         state = 4;
   1:         minUcs4 = 0x00200000;
   1:       }
   1:     else if ( UTF8traits::is6byte(c) )
   1:       {
   1:         ucs4 = (PRUint32(c) << 30) & 0x40000000L;
   1:         state = 5;
   1:         minUcs4 = 0x04000000;
   1:       }
   1:     else
   1:       {
   1:         return PR_FALSE;
   1:       }
   1: 
   1:     return PR_TRUE;
   1:   }
   1: 
   1:   static PRBool AddByte(char c, PRInt32 state, PRUint32& ucs4)
   1:   {
   1:     if ( UTF8traits::isInSeq(c) )
   1:       {
   1:         PRInt32 shift = state * 6;
   1:         ucs4 |= (PRUint32(c) & 0x3F) << shift;
   1:         return PR_TRUE;
   1:       }
   1: 
   1:     return PR_FALSE;
   1:   }
   1: };
   1: 
   1: 
   1: /**
   1:  * Extract the next UCS-4 character from the buffer and return it.  The
   1:  * pointer passed in is advanced to the start of the next character in the
   1:  * buffer.  If non-null, the err parameter is filled in if an error occurs.
   1:  */
   1: 
   1: 
   1: class UTF16CharEnumerator
   1: {
   1: public:
   1:   static PRUint32 NextChar(const PRUnichar **buffer, const PRUnichar *end,
   1:                            PRBool *err = nsnull)
   1:   {
   1:     NS_ASSERTION(buffer && *buffer, "null buffer!");
   1: 
   1:     const PRUnichar *p = *buffer;
   1: 
   1:     if (p >= end)
   1:       {
   1:         NS_ERROR("No input to work with");
   1:         if (err)
   1:           *err = PR_TRUE;
   1: 
   1:         return 0;
   1:       }
   1: 
   1:     PRUnichar c = *p++;
   1: 
   1:     if (!IS_SURROGATE(c)) // U+0000 - U+D7FF,U+E000 - U+FFFF
   1:       {
   1:         if (err)
   1:           *err = PR_FALSE;
   1:         *buffer = p;
   1:         return c;
   1:       }
   1:     else if (NS_IS_HIGH_SURROGATE(c)) // U+D800 - U+DBFF
   1:       {
   1:         if (*buffer == end)
   1:           {
   1:             NS_ERROR("Unexpected end of buffer after high surrogate");
   1:             if (err)
   1:               *err = PR_TRUE;
   1: 
   1:             return 0;
   1:           }
   1: 
   1:         // D800- DBFF - High Surrogate
   1:         PRUnichar h = c;
   1: 
   1:         c = *p++;
   1: 
   1:         if (NS_IS_LOW_SURROGATE(c))
   1:           {
   1:             // DC00- DFFF - Low Surrogate
   1:             // N = (H - D800) *400 + 10000 + (L - DC00)
   1:             PRUint32 ucs4 = SURROGATE_TO_UCS4(h, c);
   1:             if (err)
   1:               *err = PR_FALSE;
   1:             *buffer = p;
   1:             return ucs4;
   1:           }
   1:         else
   1:           {
   1:             NS_ERROR("got a High Surrogate but no low surrogate");
   1:             // output nothing.
   1:           }
   1:       }
   1:     else // U+DC00 - U+DFFF
   1:       {
   1:         // DC00- DFFF - Low Surrogate
   1:         NS_ERROR("got a low Surrogate but no high surrogate");
   1:         // output nothing.
   1:       }
   1: 
   1:     if (err)
   1:       *err = PR_TRUE;
   1:     return 0;
   1:   }
   1: 
   1:   static PRUint32 NextChar(nsAString::const_iterator& iter,
   1:                            const nsAString::const_iterator& end,
   1:                            PRBool *err = nsnull)
   1:   {
   1:     if (iter == end)
   1:       {
   1:         if (err)
   1:           *err = PR_TRUE;
   1: 
   1:         return 0;
   1:       }
   1: 
   1:     PRUnichar c = *iter++;
   1: 
   1:     if (!IS_SURROGATE(c)) // U+0000 - U+D7FF,U+E000 - U+FFFF
   1:       {
   1:         if (err)
   1:           *err = PR_FALSE;
   1:         return c;
   1:       }
   1:     else if (NS_IS_HIGH_SURROGATE(c)) // U+D800 - U+DBFF
   1:       {
   1:         if (iter == end)
   1:           {
   1:             if (err)
   1:               *err = PR_TRUE;
   1: 
   1:             return 0;
   1:           }
   1: 
   1:         // D800- DBFF - High Surrogate
   1:         PRUnichar h = c;
   1: 
   1:         c = *iter++;
   1: 
   1:         if (NS_IS_LOW_SURROGATE(c))
   1:           {
   1:             // DC00- DFFF - Low Surrogate
   1:             // N = (H - D800) *400 + 10000 + ( L - DC00 )
   1:             PRUint32 ucs4 = SURROGATE_TO_UCS4(h, c);
   1:             if (err)
   1:               *err = PR_FALSE;
   1:             return ucs4;
   1:           }
   1:         else
   1:           {
   1:             NS_ERROR("got a High Surrogate but no low surrogate");
   1:             // output nothing.
   1:           }
   1:       }
   1:     else // U+DC00 - U+DFFF
   1:       {
   1:         // DC00- DFFF - Low Surrogate
   1:         NS_ERROR("got a low Surrogate but no high surrogate");
   1:         // output nothing.
   1:       }
   1: 
   1:     if (err)
   1:       *err = PR_TRUE;
   1:     return 0;
   1:   }
   1: };
   1: 
   1: 
   1: /**
   1:  * A character sink (see |copy_string| in nsAlgorithm.h) for converting
   1:  * UTF-8 to UTF-16
   1:  */
   1: class ConvertUTF8toUTF16
   1:   {
   1:     public:
   1:       typedef nsACString::char_type value_type;
   1:       typedef nsAString::char_type  buffer_type;
   1: 
   1:     ConvertUTF8toUTF16( buffer_type* aBuffer )
   1:         : mStart(aBuffer), mBuffer(aBuffer), mErrorEncountered(PR_FALSE) {}
   1: 
   1:     size_t Length() const { return mBuffer - mStart; }
   1: 
   1:     PRUint32 NS_ALWAYS_INLINE write( const value_type* start, PRUint32 N )
   1:       {
   1:         if ( mErrorEncountered )
   1:           return N;
   1: 
   1:         // algorithm assumes utf8 units won't
   1:         // be spread across fragments
   1:         const value_type* p = start;
   1:         const value_type* end = start + N;
   1:         buffer_type* out = mBuffer;
   1:         for ( ; p != end /* && *p */; )
   1:           {
   1:             PRBool overlong, err;
   1:             PRUint32 ucs4 = UTF8CharEnumerator::NextChar(&p, end, &err,
   1:                                                          &overlong);
   1: 
   1:             if ( err )
   1:               {
   1:                 mErrorEncountered = PR_TRUE;
   1:                 mBuffer = out;
   1:                 return N;
   1:               }
   1: 
   1:             if ( overlong )
   1:               {
   1:                 // Overlong sequence
   1:                 *out++ = UCS2_REPLACEMENT_CHAR;
   1:               }
   1:             else if ( ucs4 <= 0xD7FF )
   1:               {
   1:                 *out++ = ucs4;
   1:               }
   1:             else if ( /* ucs4 >= 0xD800 && */ ucs4 <= 0xDFFF )
   1:               {
   1:                 // Surrogates
   1:                 *out++ = UCS2_REPLACEMENT_CHAR;
   1:               }
   1:             else if ( ucs4 == 0xFFFE || ucs4 == 0xFFFF )
   1:               {
   1:                 // Prohibited characters
   1:                 *out++ = UCS2_REPLACEMENT_CHAR;
   1:               }
   1:             else if ( ucs4 >= PLANE1_BASE )
   1:               {
   1:                 if ( ucs4 >= UCS_END )
   1:                   *out++ = UCS2_REPLACEMENT_CHAR;
   1:                 else {
   1:                   *out++ = (buffer_type)H_SURROGATE(ucs4);
   1:                   *out++ = (buffer_type)L_SURROGATE(ucs4);
   1:                 }
   1:               }
   1:             else
   1:               {
   1:                 *out++ = ucs4;
   1:               }
   1:           }
   1:         mBuffer = out;
   1:         return p - start;
   1:       }
   1: 
   1:     void write_terminator()
   1:       {
   1:         *mBuffer = buffer_type(0);
   1:       }
   1: 
   1:     private:
   1:       buffer_type* const mStart;
   1:       buffer_type* mBuffer;
   1:       PRBool mErrorEncountered;
   1:   };
   1: 
   1: /**
   1:  * A character sink (see |copy_string| in nsAlgorithm.h) for computing
   1:  * the length of the UTF-16 string equivalent to a UTF-8 string.
   1:  */
   1: class CalculateUTF8Length
   1:   {
   1:     public:
   1:       typedef nsACString::char_type value_type;
   1: 
   1:     CalculateUTF8Length() : mLength(0), mErrorEncountered(PR_FALSE) { }
   1: 
   1:     size_t Length() const { return mLength; }
   1: 
   1:     PRUint32 NS_ALWAYS_INLINE write( const value_type* start, PRUint32 N )
   1:       {
   1:           // ignore any further requests
   1:         if ( mErrorEncountered )
   1:             return N;
   1: 
   1:         // algorithm assumes utf8 units won't
   1:         // be spread across fragments
   1:         const value_type* p = start;
   1:         const value_type* end = start + N;
   1:         for ( ; p < end /* && *p */; ++mLength )
   1:           {
   1:             if ( UTF8traits::isASCII(*p) )
   1:                 p += 1;
   1:             else if ( UTF8traits::is2byte(*p) )
   1:                 p += 2;
   1:             else if ( UTF8traits::is3byte(*p) )
   1:                 p += 3;
   1:             else if ( UTF8traits::is4byte(*p) ) {
   1:                 p += 4;
   1:                 // Because a UTF-8 sequence of 4 bytes represents a codepoint
   1:                 // greater than 0xFFFF, it will become a surrogate pair in the
   1:                 // UTF-16 string, so add 1 more to mLength.
   1:                 // This doesn't happen with is5byte and is6byte because they
   1:                 // are illegal UTF-8 sequences (greater than 0x10FFFF) so get
   1:                 // converted to a single replacement character.
   1:                 //
   1:                 // XXX: if the 4-byte sequence is an illegal non-shortest form,
   1:                 //      it also gets converted to a replacement character, so
   1:                 //      mLength will be off by one in this case.
   1:                 ++mLength;
   1:             }
   1:             else if ( UTF8traits::is5byte(*p) )
   1:                 p += 5;
   1:             else if ( UTF8traits::is6byte(*p) )
   1:                 p += 6;
   1:             else
   1:               {
   1:                 break;
   1:               }
   1:           }
   1:         if ( p != end )
   1:           {
   1:             NS_ERROR("Not a UTF-8 string. This code should only be used for converting from known UTF-8 strings.");
   1:             mErrorEncountered = PR_TRUE;
   1:             return N;
   1:           }
   1:         return p - start;
   1:       }
   1: 
   1:     private:
   1:       size_t mLength;
   1:       PRBool mErrorEncountered;
   1:   };
   1: 
   1: /**
3351:  * A character sink (see |copy_string| in nsAlgorithm.h) for
3351:  * converting UTF-16 to UTF-8. Treats invalid UTF-16 data as 0xFFFD
3351:  * (0xEFBFBD in UTF-8).
   1:  */
   1: class ConvertUTF16toUTF8
   1:   {
   1:     public:
   1:       typedef nsAString::char_type  value_type;
   1:       typedef nsACString::char_type buffer_type;
   1: 
   1:     // The error handling here is more lenient than that in
   1:     // |ConvertUTF8toUTF16|, but it's that way for backwards
   1:     // compatibility.
   1: 
   1:     ConvertUTF16toUTF8( buffer_type* aBuffer )
   1:         : mStart(aBuffer), mBuffer(aBuffer) {}
   1: 
   1:     size_t Size() const { return mBuffer - mStart; }
   1: 
   1:     PRUint32 NS_ALWAYS_INLINE write( const value_type* start, PRUint32 N )
   1:       {
   1:         buffer_type *out = mBuffer; // gcc isn't smart enough to do this!
   1: 
   1:         for (const value_type *p = start, *end = start + N; p < end; ++p )
   1:           {
   1:             value_type c = *p;
   1:             if (! (c & 0xFF80)) // U+0000 - U+007F
   1:               {
   1:                 *out++ = (char)c;
   1:               }
   1:             else if (! (c & 0xF800)) // U+0100 - U+07FF
   1:               {
   1:                 *out++ = 0xC0 | (char)(c >> 6);
   1:                 *out++ = 0x80 | (char)(0x003F & c);
   1:               }
   1:             else if (!IS_SURROGATE(c)) // U+0800 - U+D7FF,U+E000 - U+FFFF
   1:               {
   1:                 *out++ = 0xE0 | (char)(c >> 12);
   1:                 *out++ = 0x80 | (char)(0x003F & (c >> 6));
   1:                 *out++ = 0x80 | (char)(0x003F & c );
   1:               }
   1:             else if (NS_IS_HIGH_SURROGATE(c)) // U+D800 - U+DBFF
   1:               {
   1:                 // D800- DBFF - High Surrogate
   1:                 value_type h = c;
   1: 
   1:                 ++p;
   1:                 if (p == end)
   1:                   {
5813:                     // Treat broken characters as the Unicode
5813:                     // replacement character 0xFFFD (0xEFBFBD in
5813:                     // UTF-8)
5813:                     *out++ = 0xEF;
5813:                     *out++ = 0xBF;
5813:                     *out++ = 0xBD;
5813: 
5813:                     NS_WARNING("String ending in half a surrogate pair!");
5813: 
5813:                     break;
   1:                   }
   1:                 c = *p;
   1: 
   1:                 if (NS_IS_LOW_SURROGATE(c))
   1:                   {
   1:                     // DC00- DFFF - Low Surrogate
   1:                     // N = (H - D800) *400 + 10000 + ( L - DC00 )
   1:                     PRUint32 ucs4 = SURROGATE_TO_UCS4(h, c);
   1: 
   1:                     // 0001 0000-001F FFFF
   1:                     *out++ = 0xF0 | (char)(ucs4 >> 18);
   1:                     *out++ = 0x80 | (char)(0x003F & (ucs4 >> 12));
   1:                     *out++ = 0x80 | (char)(0x003F & (ucs4 >> 6));
   1:                     *out++ = 0x80 | (char)(0x003F & ucs4);
   1:                   }
   1:                 else
   1:                   {
3351:                     // Treat broken characters as the Unicode
3351:                     // replacement character 0xFFFD (0xEFBFBD in
3351:                     // UTF-8)
3351:                     *out++ = 0xEF;
3351:                     *out++ = 0xBF;
3351:                     *out++ = 0xBD;
3351: 
3351:                     NS_WARNING("got a High Surrogate but no low surrogate");
   1:                   }
   1:               }
   1:             else // U+DC00 - U+DFFF
   1:               {
3351:                 // Treat broken characters as the Unicode replacement
3351:                 // character 0xFFFD (0xEFBFBD in UTF-8)
3351:                 *out++ = 0xEF;
3351:                 *out++ = 0xBF;
3351:                 *out++ = 0xBD;
3351: 
   1:                 // DC00- DFFF - Low Surrogate
3351:                 NS_WARNING("got a low Surrogate but no high surrogate");
   1:               }
   1:           }
   1: 
   1:         mBuffer = out;
   1:         return N;
   1:       }
   1: 
   1:     void write_terminator()
   1:       {
   1:         *mBuffer = buffer_type(0);
   1:       }
   1: 
   1:     private:
   1:       buffer_type* const mStart;
   1:       buffer_type* mBuffer;
   1:   };
   1: 
   1: /**
   1:  * A character sink (see |copy_string| in nsAlgorithm.h) for computing
3351:  * the number of bytes a UTF-16 would occupy in UTF-8. Treats invalid
3351:  * UTF-16 data as 0xFFFD (0xEFBFBD in UTF-8).
   1:  */
   1: class CalculateUTF8Size
   1:   {
   1:     public:
   1:       typedef nsAString::char_type value_type;
   1: 
   1:     CalculateUTF8Size()
   1:       : mSize(0) { }
   1: 
   1:     size_t Size() const { return mSize; }
   1: 
   1:     PRUint32 NS_ALWAYS_INLINE write( const value_type* start, PRUint32 N )
   1:       {
   1:         // Assume UCS2 surrogate pairs won't be spread across fragments.
   1:         for (const value_type *p = start, *end = start + N; p < end; ++p )
   1:           {
   1:             value_type c = *p;
   1:             if (! (c & 0xFF80)) // U+0000 - U+007F
   1:               mSize += 1;
   1:             else if (! (c & 0xF800)) // U+0100 - U+07FF
   1:               mSize += 2;
   1:             else if (0xD800 != (0xF800 & c)) // U+0800 - U+D7FF,U+E000 - U+FFFF
   1:               mSize += 3;
   1:             else if (0xD800 == (0xFC00 & c)) // U+D800 - U+DBFF
   1:               {
   1:                 ++p;
   1:                 if (p == end)
   1:                   {
5813:                     // Treat broken characters as the Unicode
5813:                     // replacement character 0xFFFD (0xEFBFBD in
5813:                     // UTF-8)
5813:                     mSize += 3;
5813: 
5813:                     NS_WARNING("String ending in half a surrogate pair!");
5813: 
5813:                     break;
   1:                   }
   1:                 c = *p;
   1: 
   1:                 if (0xDC00 == (0xFC00 & c))
   1:                   mSize += 4;
   1:                 else
3351:                   {
3351:                     // Treat broken characters as the Unicode
3351:                     // replacement character 0xFFFD (0xEFBFBD in
3351:                     // UTF-8)
3351:                     mSize += 3;
3351: 
3351:                     NS_WARNING("got a high Surrogate but no low surrogate");
3351:                   }
   1:               }
   1:             else // U+DC00 - U+DFFF
3351:               {
3351:                 // Treat broken characters as the Unicode replacement
3351:                 // character 0xFFFD (0xEFBFBD in UTF-8)
3351:                 mSize += 3;
3351: 
3351:                 NS_WARNING("got a low Surrogate but no high surrogate");
3351:               }
   1:           }
   1: 
   1:         return N;
   1:       }
   1: 
   1:     private:
   1:       size_t mSize;
   1:   };
   1: 
   1: /**
   1:  * A character sink that performs a |reinterpret_cast| style conversion
   1:  * between character types.
   1:  */
   1: template <class FromCharT, class ToCharT>
   1: class LossyConvertEncoding
   1:   {
   1:     public:
   1:       typedef FromCharT value_type;
   1:  
   1:       typedef FromCharT input_type;
   1:       typedef ToCharT   output_type;
   1: 
   1:       typedef typename nsCharTraits<FromCharT>::unsigned_char_type unsigned_input_type;
   1: 
   1:     public:
   1:       LossyConvertEncoding( output_type* aDestination ) : mDestination(aDestination) { }
   1: 
   1:       PRUint32
   1:       write( const input_type* aSource, PRUint32 aSourceLength )
   1:         {
   1:           const input_type* done_writing = aSource + aSourceLength;
   1:           while ( aSource < done_writing )
   1:             *mDestination++ = (output_type)(unsigned_input_type)(*aSource++);  // use old-style cast to mimic old |ns[C]String| behavior
   1:           return aSourceLength;
   1:         }
   1: 
   1:       void
   1:       write_terminator()
   1:         {
   1:           *mDestination = output_type(0);
   1:         }
   1: 
   1:     private:
   1:       output_type* mDestination;
   1:   };
   1: 
   1: #endif /* !defined(nsUTF8Utils_h_) */
