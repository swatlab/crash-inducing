    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim: set ts=2 sw=2 et tw=78:
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Novell code.
    1:  *
    1:  * The Initial Developer of the Original Code is Novell Corporation.
 6697:  * Portions created by the Initial Developer are Copyright (C) 2006
 6697:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *     robert@ocallahan.org
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  */
    1: 
    1: /*
    1:  * structures that represent things to be painted (ordered in z-order),
    1:  * used during painting and hit testing
    1:  */
    1: 
    1: #include "nsDisplayList.h"
    1: 
    1: #include "nsCSSRendering.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIPresShell.h"
    1: #include "nsRegion.h"
    1: #include "nsFrameManager.h"
    1: #include "gfxContext.h"
15992: #include "nsStyleStructInlines.h"
19214: #include "nsStyleTransformMatrix.h"
19214: #include "gfxMatrix.h"
19125: #ifdef MOZ_SVG
19125: #include "nsSVGIntegrationUtils.h"
19125: #endif
30519: #include "nsLayoutUtils.h"
47777: #include "nsIScrollableFrame.h"
48165: #include "nsThemeConstants.h"
    1: 
27153: #include "imgIContainer.h"
27153: #include "nsIInterfaceRequestorUtils.h"
38803: #include "BasicLayers.h"
38803: 
42593: using namespace mozilla;
38803: using namespace mozilla::layers;
27153: 
    1: nsDisplayListBuilder::nsDisplayListBuilder(nsIFrame* aReferenceFrame,
14202:     PRBool aIsForEvents, PRBool aBuildCaret)
    1:     : mReferenceFrame(aReferenceFrame),
    1:       mIgnoreScrollFrame(nsnull),
13961:       mCurrentTableItem(nsnull),
    1:       mBuildCaret(aBuildCaret),
    1:       mEventDelivery(aIsForEvents),
51851:       mIgnoreSuppression(PR_FALSE),
51851:       mHadToIgnoreSuppression(PR_FALSE),
    1:       mIsAtRootOfPseudoStackingContext(PR_FALSE),
47337:       mSelectedFramesOnly(PR_FALSE),
30541:       mAccurateVisibleRegions(PR_FALSE),
32424:       mInTransform(PR_FALSE),
42240:       mSyncDecodeImages(PR_FALSE),
42240:       mIsPaintingToWindow(PR_FALSE) {
43900:   MOZ_COUNT_CTOR(nsDisplayListBuilder);
47957:   PL_InitArenaPool(&mPool, "displayListArena", 1024,
47957:                    NS_MAX(NS_ALIGNMENT_OF(void*),NS_ALIGNMENT_OF(double))-1);
    1: 
  238:   nsPresContext* pc = aReferenceFrame->PresContext();
    1:   nsIPresShell *shell = pc->PresShell();
    1:   if (pc->IsRenderingOnlySelection()) {
    1:     nsCOMPtr<nsISelectionController> selcon(do_QueryInterface(shell));
    1:     if (selcon) {
    1:       selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:                            getter_AddRefs(mBoundingSelection));
    1:     }
    1:   }
    1: 
54261:   LayerBuilder()->Init(this);
54261: 
47768:   PR_STATIC_ASSERT(nsDisplayItem::TYPE_MAX < (1 << nsDisplayItem::TYPE_BITS));
    1: }
    1: 
    1: static void MarkFrameForDisplay(nsIFrame* aFrame, nsIFrame* aStopAtFrame) {
  238:   nsFrameManager* frameManager = aFrame->PresContext()->PresShell()->FrameManager();
    1: 
    1:   for (nsIFrame* f = aFrame; f;
    1:        f = nsLayoutUtils::GetParentOrPlaceholderFor(frameManager, f)) {
    1:     if (f->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO)
    1:       return;
    1:     f->AddStateBits(NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO);
    1:     if (f == aStopAtFrame) {
    1:       // we've reached a frame that we know will be painted, so we can stop.
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
    1: static void MarkOutOfFlowFrameForDisplay(nsIFrame* aDirtyFrame, nsIFrame* aFrame,
    1:                                          const nsRect& aDirtyRect) {
    1:   nsRect dirty = aDirtyRect - aFrame->GetOffsetTo(aDirtyFrame);
    1:   nsRect overflowRect = aFrame->GetOverflowRect();
    1:   if (!dirty.IntersectRect(dirty, overflowRect))
    1:     return;
39965:   aFrame->Properties().Set(nsDisplayListBuilder::OutOfFlowDirtyRectProperty(),
39965:                            new nsRect(dirty));
    1: 
    1:   MarkFrameForDisplay(aFrame, aDirtyFrame);
    1: }
    1: 
    1: static void UnmarkFrameForDisplay(nsIFrame* aFrame) {
39965:   nsPresContext* presContext = aFrame->PresContext();
39965:   presContext->PropertyTable()->
39965:     Delete(aFrame, nsDisplayListBuilder::OutOfFlowDirtyRectProperty());
    1: 
39965:   nsFrameManager* frameManager = presContext->PresShell()->FrameManager();
    1: 
    1:   for (nsIFrame* f = aFrame; f;
    1:        f = nsLayoutUtils::GetParentOrPlaceholderFor(frameManager, f)) {
    1:     if (!(f->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO))
    1:       return;
    1:     f->RemoveStateBits(NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO);
    1:   }
    1: }
    1: 
    1: nsDisplayListBuilder::~nsDisplayListBuilder() {
 9798:   NS_ASSERTION(mFramesMarkedForDisplay.Length() == 0,
 9798:                "All frames should have been unmarked");
 9798:   NS_ASSERTION(mPresShellStates.Length() == 0,
 9798:                "All presshells should have been exited");
13961:   NS_ASSERTION(!mCurrentTableItem, "No table item should be active");
    1: 
    1:   PL_FreeArenaPool(&mPool);
    1:   PL_FinishArenaPool(&mPool);
43900:   MOZ_COUNT_DTOR(nsDisplayListBuilder);
    1: }
    1: 
32425: PRUint32
32425: nsDisplayListBuilder::GetBackgroundPaintFlags() {
32425:   PRUint32 flags = 0;
32425:   if (mSyncDecodeImages) {
32425:     flags |= nsCSSRendering::PAINTBG_SYNC_DECODE_IMAGES;
32425:   }
32425:   return flags;
32425: }
32425: 
31544: void
31544: nsDisplayListBuilder::SubtractFromVisibleRegion(nsRegion* aVisibleRegion,
31544:                                                 const nsRegion& aRegion)
31544: {
32908:   nsRegion tmp;
32908:   tmp.Sub(*aVisibleRegion, aRegion);
32908:   // Don't let *aVisibleRegion get too complex, but don't let it fluff out
32908:   // to its bounds either, which can be very bad (see bug 516740).
32908:   if (GetAccurateVisibleRegions() || tmp.GetNumRects() <= 15) {
32908:     *aVisibleRegion = tmp;
31544:   }
31544: }
31544: 
15969: nsCaret *
    1: nsDisplayListBuilder::GetCaret() {
39960:   nsRefPtr<nsCaret> caret = CurrentPresShellState()->mPresShell->GetCaret();
    1:   return caret;
    1: }
    1: 
    1: void
    1: nsDisplayListBuilder::EnterPresShell(nsIFrame* aReferenceFrame,
    1:                                      const nsRect& aDirtyRect) {
 9798:   PresShellState* state = mPresShellStates.AppendElement();
 9798:   if (!state)
 9798:     return;
 9798:   state->mPresShell = aReferenceFrame->PresContext()->PresShell();
 9798:   state->mCaretFrame = nsnull;
 9798:   state->mFirstFrameMarkedForDisplay = mFramesMarkedForDisplay.Length();
 9798: 
27834:   state->mPresShell->UpdateCanvasBackground();
27834: 
42240:   if (mIsPaintingToWindow) {
42240:     state->mPresShell->IncrementPaintCount();
42240:   }
42240: 
51851:   PRBool buildCaret = mBuildCaret;
51851:   if (mIgnoreSuppression || !state->mPresShell->IsPaintingSuppressed()) {
51851:     if (state->mPresShell->IsPaintingSuppressed()) {
51851:       mHadToIgnoreSuppression = PR_TRUE;
51851:     }
51851:     state->mIsBackgroundOnly = PR_FALSE;
51851:   } else {
51851:     state->mIsBackgroundOnly = PR_TRUE;
51851:     buildCaret = PR_FALSE;
51851:   }
51851: 
51851:   if (!buildCaret)
    1:     return;
    1: 
39960:   nsRefPtr<nsCaret> caret = state->mPresShell->GetCaret();
 9798:   state->mCaretFrame = caret->GetCaretFrame();
    1: 
 9798:   if (state->mCaretFrame) {
    1:     // Check if the dirty rect intersects with the caret's dirty rect.
    1:     nsRect caretRect =
 9798:       caret->GetCaretRect() + state->mCaretFrame->GetOffsetTo(aReferenceFrame);
    1:     if (caretRect.Intersects(aDirtyRect)) {
    1:       // Okay, our rects intersect, let's mark the frame and all of its ancestors.
 9798:       mFramesMarkedForDisplay.AppendElement(state->mCaretFrame);
 9798:       MarkFrameForDisplay(state->mCaretFrame, nsnull);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsDisplayListBuilder::LeavePresShell(nsIFrame* aReferenceFrame,
27834:                                      const nsRect& aDirtyRect) {
 9798:   if (CurrentPresShellState()->mPresShell != aReferenceFrame->PresContext()->PresShell()) {
 9798:     // Must have not allocated a state for this presshell, presumably due
 9798:     // to OOM.
    1:     return;
 9798:   }
    1: 
 9798:   // Unmark and pop off the frames marked for display in this pres shell.
 9798:   PRUint32 firstFrameForShell = CurrentPresShellState()->mFirstFrameMarkedForDisplay;
 9798:   for (PRUint32 i = firstFrameForShell;
 9798:        i < mFramesMarkedForDisplay.Length(); ++i) {
 9798:     UnmarkFrameForDisplay(mFramesMarkedForDisplay[i]);
 9798:   }
 9798:   mFramesMarkedForDisplay.SetLength(firstFrameForShell);
 9798:   mPresShellStates.SetLength(mPresShellStates.Length() - 1);
    1: }
    1: 
    1: void
30782: nsDisplayListBuilder::MarkFramesForDisplayList(nsIFrame* aDirtyFrame,
30782:                                                const nsFrameList& aFrames,
    1:                                                const nsRect& aDirtyRect) {
30782:   for (nsFrameList::Enumerator e(aFrames); !e.AtEnd(); e.Next()) {
30782:     mFramesMarkedForDisplay.AppendElement(e.get());
30782:     MarkOutOfFlowFrameForDisplay(aDirtyFrame, e.get(), aDirtyRect);
    1:   }
    1: }
    1: 
    1: void*
    1: nsDisplayListBuilder::Allocate(size_t aSize) {
    1:   void *tmp;
    1:   PL_ARENA_ALLOCATE(tmp, &mPool, aSize);
    1:   return tmp;
    1: }
    1: 
    1: void nsDisplayListSet::MoveTo(const nsDisplayListSet& aDestination) const
    1: {
    1:   aDestination.BorderBackground()->AppendToTop(BorderBackground());
    1:   aDestination.BlockBorderBackgrounds()->AppendToTop(BlockBorderBackgrounds());
    1:   aDestination.Floats()->AppendToTop(Floats());
    1:   aDestination.Content()->AppendToTop(Content());
    1:   aDestination.PositionedDescendants()->AppendToTop(PositionedDescendants());
    1:   aDestination.Outlines()->AppendToTop(Outlines());
    1: }
    1: 
    1: void
 7819: nsDisplayList::FlattenTo(nsTArray<nsDisplayItem*>* aElements) {
    1:   nsDisplayItem* item;
    1:   while ((item = RemoveBottom()) != nsnull) {
47732:     if (item->GetType() == nsDisplayItem::TYPE_WRAP_LIST) {
    1:       item->GetList()->FlattenTo(aElements);
    1:       item->~nsDisplayItem();
    1:     } else {
    1:       aElements->AppendElement(item);
    1:     }
    1:   }
    1: }
    1: 
19125: nsRect
19125: nsDisplayList::GetBounds(nsDisplayListBuilder* aBuilder) const {
19125:   nsRect bounds;
19125:   for (nsDisplayItem* i = GetBottom(); i != nsnull; i = i->GetAbove()) {
19125:     bounds.UnionRect(bounds, i->GetBounds(aBuilder));
19125:   }
19125:   return bounds;
19125: }
19125: 
47763: PRBool
51633: nsDisplayList::ComputeVisibilityForRoot(nsDisplayListBuilder* aBuilder,
50393:                                         nsRegion* aVisibleRegion) {
51633:   nsRegion r;
51633:   r.And(*aVisibleRegion, GetBounds(aBuilder));
51633:   return ComputeVisibilityForSublist(aBuilder, aVisibleRegion, r.GetBounds());
51633: }
51633: 
51633: PRBool
51633: nsDisplayList::ComputeVisibilityForSublist(nsDisplayListBuilder* aBuilder,
51633:                                            nsRegion* aVisibleRegion,
51633:                                            const nsRect& aListVisibleBounds) {
51633: #ifdef DEBUG
51633:   nsRegion r;
51633:   r.And(*aVisibleRegion, GetBounds(aBuilder));
51633:   NS_ASSERTION(r.GetBounds() == aListVisibleBounds,
51633:                "bad aListVisibleBounds");
51633: #endif
51633:   mVisibleRect = aListVisibleBounds;
47763:   PRBool anyVisible = PR_FALSE;
42246: 
 7819:   nsAutoTArray<nsDisplayItem*, 512> elements;
    1:   FlattenTo(&elements);
    1: 
 7819:   for (PRInt32 i = elements.Length() - 1; i >= 0; --i) {
 7819:     nsDisplayItem* item = elements[i];
 7819:     nsDisplayItem* belowItem = i < 1 ? nsnull : elements[i - 1];
    1: 
    1:     if (belowItem && item->TryMerge(aBuilder, belowItem)) {
    1:       belowItem->~nsDisplayItem();
 7819:       elements.ReplaceElementsAt(i - 1, 1, item);
    1:       continue;
    1:     }
    1: 
33368:     nsRect bounds = item->GetBounds(aBuilder);
33368: 
33368:     nsRegion itemVisible;
33368:     itemVisible.And(*aVisibleRegion, bounds);
33368:     item->mVisibleRect = itemVisible.GetBounds();
33368: 
50393:     if (item->ComputeVisibility(aBuilder, aVisibleRegion)) {
47763:       anyVisible = PR_TRUE;
47742:       nsIFrame* f = item->GetUnderlyingFrame();
33368:       if (item->IsOpaque(aBuilder) && f) {
34210:         // Subtract opaque item from the visible region
34210:         aBuilder->SubtractFromVisibleRegion(aVisibleRegion, nsRegion(bounds));
33368:       }
    1:     }
47763:     AppendToBottom(item);
    1:   }
31544: 
51633:   mIsOpaque = !aVisibleRegion->Intersects(mVisibleRect);
33368: #ifdef DEBUG
33368:   mDidComputeVisibility = PR_TRUE;
33368: #endif
47763:   return anyVisible;
    1: }
    1: 
42246: void nsDisplayList::PaintRoot(nsDisplayListBuilder* aBuilder,
42246:                               nsIRenderingContext* aCtx,
42246:                               PRUint32 aFlags) const {
42246:   PaintForFrame(aBuilder, aCtx, aBuilder->ReferenceFrame(), aFlags);
42246: }
42246: 
38803: /**
38803:  * We paint by executing a layer manager transaction, constructing a
38803:  * single layer representing the display list, and then making it the
38803:  * root of the layer manager, drawing into the ThebesLayers.
38803:  */
42246: void nsDisplayList::PaintForFrame(nsDisplayListBuilder* aBuilder,
38805:                                   nsIRenderingContext* aCtx,
42246:                                   nsIFrame* aForFrame,
38805:                                   PRUint32 aFlags) const {
33368:   NS_ASSERTION(mDidComputeVisibility,
33368:                "Must call ComputeVisibility before calling Paint");
33368: 
38805:   nsRefPtr<LayerManager> layerManager;
38805:   if (aFlags & PAINT_USE_WIDGET_LAYERS) {
38805:     nsIFrame* referenceFrame = aBuilder->ReferenceFrame();
38805:     NS_ASSERTION(referenceFrame == nsLayoutUtils::GetDisplayRootFrame(referenceFrame),
38805:                  "Reference frame must be a display root for us to use the layer manager");
47148:     nsIWidget* window = referenceFrame->GetNearestWidget();
38805:     if (window) {
38805:       layerManager = window->GetLayerManager();
47738:       if (layerManager) {
47771:         aBuilder->LayerBuilder()->WillBeginRetainedLayerTransaction(layerManager);
47738:       }
38805:     }
38805:   }
38805:   if (!layerManager) {
38805:     if (!aCtx) {
38805:       NS_WARNING("Nowhere to paint into");
38805:       return;
38805:     }
47767:     layerManager = new BasicLayerManager();
38803:     if (!layerManager)
38803:       return;
38805:   }
38805: 
47739:   if (aFlags & PAINT_FLUSH_LAYERS) {
47739:     FrameLayerBuilder::InvalidateAllLayers(layerManager);
47739:   }
47739: 
38805:   if (aCtx) {
38803:     layerManager->BeginTransactionWithTarget(aCtx->ThebesContext());
38805:   } else {
38805:     layerManager->BeginTransaction();
38805:   }
38803: 
54078:   nsRefPtr<ContainerLayer> root = aBuilder->LayerBuilder()->
47736:     BuildContainerLayerFor(aBuilder, layerManager, aForFrame, nsnull, *this);
38803:   if (!root)
38803:     return;
38803: 
54080:   nsPresContext* presContext = aForFrame->PresContext();
54080:   nsIPresShell* presShell = presContext->GetPresShell();
54080: 
54080:   nsIntRect visible = mVisibleRect.ToNearestPixels(presContext->AppUnitsPerDevPixel());
42246:   root->SetVisibleRegion(nsIntRegion(visible));
42246: 
54080:   // Collect frame metrics with which to stamp the root layer.
54080:   FrameMetrics metrics;
54080: 
54080:   PRInt32 auPerCSSPixel = nsPresContext::AppUnitsPerCSSPixel();
54080:   metrics.mViewportSize =
54080:     presContext->GetVisibleArea().ToNearestPixels(auPerCSSPixel).Size();
54080:   if (presShell->UsingDisplayPort()) {
54080:     metrics.mDisplayPort =
54080:       presShell->GetDisplayPort().ToNearestPixels(auPerCSSPixel);
54080:   }
54080: 
54080:   nsIScrollableFrame* rootScrollableFrame =
54080:     presShell->GetRootScrollFrameAsScrollable();
54080:   if (rootScrollableFrame) {
54080:     metrics.mViewportScrollOffset =
54080:       rootScrollableFrame->GetScrollPosition().ToNearestPixels(auPerCSSPixel);
54080:   }
54080: 
54080:   root->SetFrameMetrics(metrics);
54080: 
54083:   // If the layer manager supports resolution scaling, set that up
54083:   if (LayerManager::LAYERS_BASIC == layerManager->GetBackendType()) {
54083:     BasicLayerManager* basicManager =
54083:       static_cast<BasicLayerManager*>(layerManager.get());
54083:     // This is free if both resolutions are 1.0, or neither resolution
54083:     // has changed since the last transaction
54083:     basicManager->SetResolution(presShell->GetXResolution(),
54083:                                 presShell->GetYResolution());
54083:   }
54083: 
38803:   layerManager->SetRoot(root);
47771:   aBuilder->LayerBuilder()->WillEndTransaction(layerManager);
42593:   layerManager->EndTransaction(FrameLayerBuilder::DrawThebesLayer,
42593:                                aBuilder);
47736:   aBuilder->LayerBuilder()->DidEndTransaction(layerManager);
38803: 
47739:   if (aFlags & PAINT_FLUSH_LAYERS) {
47739:     FrameLayerBuilder::InvalidateAllLayers(layerManager);
47739:   }
47739: 
38803:   nsCSSRendering::DidPaint();
    1: }
38803: 
    1: PRUint32 nsDisplayList::Count() const {
    1:   PRUint32 count = 0;
    1:   for (nsDisplayItem* i = GetBottom(); i; i = i->GetAbove()) {
    1:     ++count;
    1:   }
    1:   return count;
    1: }
    1: 
    1: nsDisplayItem* nsDisplayList::RemoveBottom() {
    1:   nsDisplayItem* item = mSentinel.mAbove;
    1:   if (!item)
    1:     return nsnull;
    1:   mSentinel.mAbove = item->mAbove;
    1:   if (item == mTop) {
    1:     // must have been the only item
    1:     mTop = &mSentinel;
    1:   }
    1:   item->mAbove = nsnull;
    1:   return item;
    1: }
    1: 
    1: void nsDisplayList::DeleteAll() {
    1:   nsDisplayItem* item;
    1:   while ((item = RemoveBottom()) != nsnull) {
    1:     item->~nsDisplayItem();
    1:   }
    1: }
    1: 
40570: void nsDisplayList::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                             nsDisplayItem::HitTestState* aState,
40570:                             nsTArray<nsIFrame*> *aOutFrames) const {
 9799:   PRInt32 itemBufferStart = aState->mItemBuffer.Length();
    1:   nsDisplayItem* item;
    1:   for (item = GetBottom(); item; item = item->GetAbove()) {
 9799:     aState->mItemBuffer.AppendElement(item);
    1:   }
 9799:   for (PRInt32 i = aState->mItemBuffer.Length() - 1; i >= itemBufferStart; --i) {
 9799:     // Pop element off the end of the buffer. We want to shorten the buffer
 9799:     // so that recursive calls to HitTest have more buffer space.
 9799:     item = aState->mItemBuffer[i];
 9799:     aState->mItemBuffer.SetLength(i);
 9799: 
40570:     if (aRect.Intersects(item->GetBounds(aBuilder))) {
40570:       nsTArray<nsIFrame*> outFrames;
40570:       item->HitTest(aBuilder, aRect, aState, &outFrames);
40570: 
40570:       for (PRUint32 j = 0; j < outFrames.Length(); j++) {
40570:         nsIFrame *f = outFrames.ElementAt(j);
32021:         // Handle the XUL 'mousethrough' feature and 'pointer-events'.
32021:         if (!f->GetMouseThrough() &&
32021:             f->GetStyleVisibility()->mPointerEvents != NS_STYLE_POINTER_EVENTS_NONE) {
40570:           aOutFrames->AppendElement(f);
    1:         }
    1:       }
40570: 
    1:     }
 9799:   }
19214:   NS_ASSERTION(aState->mItemBuffer.Length() == PRUint32(itemBufferStart),
 9799:                "How did we forget to pop some elements?");
    1: }
    1: 
    1: static void Sort(nsDisplayList* aList, PRInt32 aCount, nsDisplayList::SortLEQ aCmp,
    1:                  void* aClosure) {
    1:   if (aCount < 2)
    1:     return;
    1: 
    1:   nsDisplayList list1;
    1:   nsDisplayList list2;
    1:   int i;
    1:   PRInt32 half = aCount/2;
    1:   PRBool sorted = PR_TRUE;
    1:   nsDisplayItem* prev = nsnull;
    1:   for (i = 0; i < aCount; ++i) {
    1:     nsDisplayItem* item = aList->RemoveBottom();
    1:     (i < half ? &list1 : &list2)->AppendToTop(item);
    1:     if (sorted && prev && !aCmp(prev, item, aClosure)) {
    1:       sorted = PR_FALSE;
    1:     }
    1:     prev = item;
    1:   }
    1:   if (sorted) {
    1:     aList->AppendToTop(&list1);
    1:     aList->AppendToTop(&list2);
    1:     return;
    1:   }
    1:   
    1:   Sort(&list1, half, aCmp, aClosure);
    1:   Sort(&list2, aCount - half, aCmp, aClosure);
    1: 
    1:   for (i = 0; i < aCount; ++i) {
    1:     if (list1.GetBottom() &&
    1:         (!list2.GetBottom() ||
    1:          aCmp(list1.GetBottom(), list2.GetBottom(), aClosure))) {
    1:       aList->AppendToTop(list1.RemoveBottom());
    1:     } else {
    1:       aList->AppendToTop(list2.RemoveBottom());
    1:     }
    1:   }
    1: }
    1: 
    1: static PRBool IsContentLEQ(nsDisplayItem* aItem1, nsDisplayItem* aItem2,
    1:                            void* aClosure) {
    1:   // These GetUnderlyingFrame calls return non-null because we're only used
    1:   // in sorting
    1:   return nsLayoutUtils::CompareTreePosition(
    1:       aItem1->GetUnderlyingFrame()->GetContent(),
    1:       aItem2->GetUnderlyingFrame()->GetContent(),
 3233:       static_cast<nsIContent*>(aClosure)) <= 0;
    1: }
    1: 
    1: static PRBool IsZOrderLEQ(nsDisplayItem* aItem1, nsDisplayItem* aItem2,
    1:                           void* aClosure) {
    1:   // These GetUnderlyingFrame calls return non-null because we're only used
40129:   // in sorting.  Note that we can't just take the difference of the two
40129:   // z-indices here, because that might overflow a 32-bit int.
40129:   PRInt32 index1 = nsLayoutUtils::GetZIndex(aItem1->GetUnderlyingFrame());
40129:   PRInt32 index2 = nsLayoutUtils::GetZIndex(aItem2->GetUnderlyingFrame());
40129:   if (index1 == index2)
    1:     return IsContentLEQ(aItem1, aItem2, aClosure);
40129:   return index1 < index2;
    1: }
    1: 
    1: void nsDisplayList::ExplodeAnonymousChildLists(nsDisplayListBuilder* aBuilder) {
    1:   // See if there's anything to do
    1:   PRBool anyAnonymousItems = PR_FALSE;
    1:   nsDisplayItem* i;
    1:   for (i = GetBottom(); i != nsnull; i = i->GetAbove()) {
    1:     if (!i->GetUnderlyingFrame()) {
    1:       anyAnonymousItems = PR_TRUE;
    1:       break;
    1:     }
    1:   }
    1:   if (!anyAnonymousItems)
    1:     return;
    1: 
    1:   nsDisplayList tmp;
    1:   while ((i = RemoveBottom()) != nsnull) {
    1:     if (i->GetUnderlyingFrame()) {
    1:       tmp.AppendToTop(i);
    1:     } else {
    1:       nsDisplayList* list = i->GetList();
    1:       NS_ASSERTION(list, "leaf items can't be anonymous");
    1:       list->ExplodeAnonymousChildLists(aBuilder);
    1:       nsDisplayItem* j;
    1:       while ((j = list->RemoveBottom()) != nsnull) {
 3233:         tmp.AppendToTop(static_cast<nsDisplayWrapList*>(i)->
    1:             WrapWithClone(aBuilder, j));
    1:       }
    1:       i->~nsDisplayItem();
    1:     }
    1:   }
    1:   
    1:   AppendToTop(&tmp);
    1: }
    1: 
    1: void nsDisplayList::SortByZOrder(nsDisplayListBuilder* aBuilder,
    1:                                  nsIContent* aCommonAncestor) {
    1:   Sort(aBuilder, IsZOrderLEQ, aCommonAncestor);
    1: }
    1: 
    1: void nsDisplayList::SortByContentOrder(nsDisplayListBuilder* aBuilder,
    1:                                        nsIContent* aCommonAncestor) {
    1:   Sort(aBuilder, IsContentLEQ, aCommonAncestor);
    1: }
    1: 
    1: void nsDisplayList::Sort(nsDisplayListBuilder* aBuilder,
    1:                          SortLEQ aCmp, void* aClosure) {
    1:   ExplodeAnonymousChildLists(aBuilder);
    1:   ::Sort(this, Count(), aCmp, aClosure);
    1: }
    1: 
47736: PRBool nsDisplayItem::RecomputeVisibility(nsDisplayListBuilder* aBuilder,
47736:                                           nsRegion* aVisibleRegion) {
47736:   nsRect bounds = GetBounds(aBuilder);
47736: 
47736:   nsRegion itemVisible;
47736:   itemVisible.And(*aVisibleRegion, bounds);
47736:   mVisibleRect = itemVisible.GetBounds();
47736: 
50393:   if (!ComputeVisibility(aBuilder, aVisibleRegion))
47736:     return PR_FALSE;
47736: 
47736:   if (IsOpaque(aBuilder)) {
47736:     aVisibleRegion->Sub(*aVisibleRegion, bounds);
47736:   }
47736:   return PR_TRUE;
47736: }
47736: 
27834: void nsDisplaySolidColor::Paint(nsDisplayListBuilder* aBuilder,
33368:                                 nsIRenderingContext* aCtx) {
27834:   aCtx->SetColor(mColor);
33368:   aCtx->FillRect(mVisibleRect);
27834: }
27834: 
48165: static void
48165: RegisterThemeWidgetGeometry(nsIFrame* aFrame)
48165: {
48165:   nsPresContext* presContext = aFrame->PresContext();
48165:   nsITheme* theme = presContext->GetTheme();
48165:   if (!theme)
48165:     return;
48165: 
48165:   nsIFrame* displayRoot = nsLayoutUtils::GetDisplayRootFrame(aFrame);
48165:   nsIWidget* widget = displayRoot->GetNearestWidget();
48165:   // If the display root doesn't have a widget, just bail. Something
48165:   // weird is going on, maybe we're printing?
48165:   if (!widget)
48165:     return;
48165: 
48165:   for (nsIFrame* f = aFrame; f; f = f->GetParent()) {
48165:     // Bail out if we're in a transformed subtree
48165:     if (f->IsTransformed())
48165:       return;
48165:     // Bail out if we're not in the displayRoot's document
48165:     if (!f->GetParent() && f != displayRoot)
48165:       return;
48165:   }
48165: 
48165:   nsRect borderBox(aFrame->GetOffsetTo(displayRoot), aFrame->GetSize());
48165:   theme->RegisterWidgetGeometry(widget,
48165:       aFrame->GetStyleDisplay()->mAppearance,
48165:       borderBox.ToNearestPixels(presContext->AppUnitsPerDevPixel()));
48165: }
48165: 
51260: nsDisplayBackground::nsDisplayBackground(nsDisplayListBuilder* aBuilder,
51260:                                          nsIFrame* aFrame)
51260:   : nsDisplayItem(aBuilder, aFrame)
48165: {
48165:   MOZ_COUNT_CTOR(nsDisplayBackground);
48165:   const nsStyleDisplay* disp = mFrame->GetStyleDisplay();
48165:   mIsThemed = mFrame->IsThemed(disp, &mThemeTransparency);
48165: 
48165:   // Perform necessary RegisterWidgetGeometry
48165:   if (mIsThemed &&
48165:       (disp->mAppearance == NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR ||
48165:        disp->mAppearance == NS_THEME_TOOLBAR)) {
48165:     RegisterThemeWidgetGeometry(aFrame);
48165:   }
48165: }
48165: 
27703: // Returns TRUE if aContainedRect is guaranteed to be contained in
27703: // the rounded rect defined by aRoundedRect and aRadii. Complex cases are
27703: // handled conservatively by returning FALSE in some situations where
27703: // a more thorough analysis could return TRUE.
27703: static PRBool RoundedRectContainsRect(const nsRect& aRoundedRect,
27703:                                       const nscoord aRadii[8],
27703:                                       const nsRect& aContainedRect) {
27703:   // rectFullHeight and rectFullWidth together will approximately contain
27703:   // the total area of the frame minus the rounded corners.
27703:   nsRect rectFullHeight = aRoundedRect;
32531:   nscoord xDiff = NS_MAX(aRadii[NS_CORNER_TOP_LEFT_X], aRadii[NS_CORNER_BOTTOM_LEFT_X]);
27703:   rectFullHeight.x += xDiff;
32531:   rectFullHeight.width -= NS_MAX(aRadii[NS_CORNER_TOP_RIGHT_X],
27703:                                  aRadii[NS_CORNER_BOTTOM_RIGHT_X]) + xDiff;
27703:   if (rectFullHeight.Contains(aContainedRect))
27703:     return PR_TRUE;
27703: 
27703:   nsRect rectFullWidth = aRoundedRect;
32531:   nscoord yDiff = NS_MAX(aRadii[NS_CORNER_TOP_LEFT_Y], aRadii[NS_CORNER_TOP_RIGHT_Y]);
27703:   rectFullWidth.y += yDiff;
32531:   rectFullWidth.height -= NS_MAX(aRadii[NS_CORNER_BOTTOM_LEFT_Y],
27703:                                  aRadii[NS_CORNER_BOTTOM_RIGHT_Y]) + yDiff;
27703:   if (rectFullWidth.Contains(aContainedRect))
27703:     return PR_TRUE;
27703: 
27703:   return PR_FALSE;
27703: }
27703: 
    1: PRBool
47754: nsDisplayBackground::ComputeVisibility(nsDisplayListBuilder* aBuilder,
50393:                                        nsRegion* aVisibleRegion)
47754: {
50393:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion))
47763:     return PR_FALSE;
47763: 
47754:   // Return false if the background was propagated away from this
47754:   // frame. We don't want this display item to show up and confuse
47754:   // anything.
47754:   nsStyleContext* bgSC;
47754:   return mIsThemed ||
47754:     nsCSSRendering::FindBackground(mFrame->PresContext(), mFrame, &bgSC);
47754: }
47754: 
47754: PRBool
    1: nsDisplayBackground::IsOpaque(nsDisplayListBuilder* aBuilder) {
    1:   // theme background overrides any other background
 9369:   if (mIsThemed)
43487:     return mThemeTransparency == nsITheme::eOpaque;
    1: 
40177:   nsStyleContext* bgSC;
40177:   if (!nsCSSRendering::FindBackground(mFrame->PresContext(), mFrame, &bgSC))
27153:     return PR_FALSE;
40177:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
27153: 
27153:   const nsStyleBackground::Layer& bottomLayer = bg->BottomLayer();
27153: 
25276:   // bottom layer's clip is used for the color
27153:   if (bottomLayer.mClip != NS_STYLE_BG_CLIP_BORDER ||
27153:       nsLayoutUtils::HasNonZeroCorner(mFrame->GetStyleBorder()->mBorderRadius))
27153:     return PR_FALSE;
27153: 
29987:   if (NS_GET_A(bg->mBackgroundColor) == 255 &&
29987:       !nsCSSRendering::IsCanvasFrame(mFrame))
27153:     return PR_TRUE;
27153: 
31749:   return bottomLayer.mRepeat == NS_STYLE_BG_REPEAT_XY &&
31749:          bottomLayer.mImage.IsOpaque();
    1: }
    1: 
    1: PRBool
42436: nsDisplayBackground::IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) {
    1:   // theme background overrides any other background
 9369:   if (mIsThemed)
    1:     return PR_FALSE;
    1: 
40177:   nsStyleContext *bgSC;
    1:   PRBool hasBG =
40177:     nsCSSRendering::FindBackground(mFrame->PresContext(), mFrame, &bgSC);
42436:   if (!hasBG) {
42436:     *aColor = NS_RGBA(0,0,0,0);
    1:     return PR_TRUE;
42436:   }
40177:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
31749:   if (bg->BottomLayer().mImage.IsEmpty() &&
25276:       bg->mImageCount == 1 &&
20039:       !nsLayoutUtils::HasNonZeroCorner(mFrame->GetStyleBorder()->mBorderRadius) &&
42436:       bg->BottomLayer().mClip == NS_STYLE_BG_CLIP_BORDER) {
42436:     // Canvas frames don't actually render their background color, since that
42436:     // gets propagated to the solid color of the viewport
42436:     // (see nsCSSRendering::PaintBackgroundWithSC)
42436:     *aColor = nsCSSRendering::IsCanvasFrame(mFrame) ? NS_RGBA(0,0,0,0)
42436:         : bg->mBackgroundColor;
    1:     return PR_TRUE;
42436:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
50392: nsDisplayBackground::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
50392:                                                     nsIFrame* aFrame)
    1: {
47777:   // theme background overrides any other background and is never fixed
47777:   if (mIsThemed)
47777:     return PR_FALSE;
47777: 
14202:   nsPresContext* presContext = mFrame->PresContext();
40177:   nsStyleContext *bgSC;
    1:   PRBool hasBG =
47754:     nsCSSRendering::FindBackground(presContext, mFrame, &bgSC);
    1:   if (!hasBG)
    1:     return PR_FALSE;
40177:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
    1:   if (!bg->HasFixedBackground())
    1:     return PR_FALSE;
    1: 
50392:   // If aFrame is mFrame or an ancestor in this document, and aFrame is
50392:   // not the viewport frame, then moving aFrame will move mFrame
50392:   // relative to the viewport, so our fixed-pos background will change.
50392:   return aFrame->GetParent() &&
50392:     (aFrame == mFrame ||
50392:      nsLayoutUtils::IsProperAncestorFrame(aFrame, mFrame));
    1: }
    1: 
47777: PRBool
47777: nsDisplayBackground::IsFixedAndCoveringViewport(nsDisplayListBuilder* aBuilder)
47777: {
47777:   if (mIsThemed)
47777:     return PR_FALSE;
47777: 
47777:   nsPresContext* presContext = mFrame->PresContext();
47777:   nsStyleContext* bgSC;
47777:   PRBool hasBG =
47777:     nsCSSRendering::FindBackground(presContext, mFrame, &bgSC);
47777:   if (!hasBG)
47777:     return PR_FALSE;
47777: 
47777:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
47777:   if (!bg->HasFixedBackground())
47777:     return PR_FALSE;
47777: 
47777:   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, bg) {
47777:     const nsStyleBackground::Layer& layer = bg->mLayers[i];
47777:     if (layer.mAttachment != NS_STYLE_BG_ATTACHMENT_FIXED &&
47777:         !layer.mImage.IsEmpty()) {
47777:       return PR_FALSE;
47777:     }
47777:     if (layer.mClip != NS_STYLE_BG_CLIP_BORDER)
47777:       return PR_FALSE;
47777:   }
47777: 
47777:   if (nsLayoutUtils::HasNonZeroCorner(mFrame->GetStyleBorder()->mBorderRadius))
47777:     return PR_FALSE;
47777: 
47777:   nsRect bounds = GetBounds(aBuilder);
47777:   nsIFrame* rootScrollFrame = presContext->PresShell()->GetRootScrollFrame();
47777:   if (!rootScrollFrame)
47777:     return PR_FALSE;
47777:   nsIScrollableFrame* scrollable = do_QueryFrame(rootScrollFrame);
47777:   nsRect scrollport = scrollable->GetScrollPortRect() +
47777:     aBuilder->ToReferenceFrame(rootScrollFrame);
47777:   return bounds.Contains(scrollport);
47777: }
47777: 
    1: void
    1: nsDisplayBackground::Paint(nsDisplayListBuilder* aBuilder,
33368:                            nsIRenderingContext* aCtx) {
51261:   nsPoint offset = ToReferenceFrame();
32425:   PRUint32 flags = aBuilder->GetBackgroundPaintFlags();
28800:   nsDisplayItem* nextItem = GetAbove();
28800:   if (nextItem && nextItem->GetUnderlyingFrame() == mFrame &&
28800:       nextItem->GetType() == TYPE_BORDER) {
32425:     flags |= nsCSSRendering::PAINTBG_WILL_PAINT_BORDER;
28800:   }
  238:   nsCSSRendering::PaintBackground(mFrame->PresContext(), *aCtx, mFrame,
33368:                                   mVisibleRect,
33368:                                   nsRect(offset, mFrame->GetSize()),
28800:                                   flags);
    1: }
    1: 
    1: nsRect
 9369: nsDisplayBackground::GetBounds(nsDisplayListBuilder* aBuilder) {
51266:   if (mIsThemed) {
51266:     nsRect r(nsPoint(0,0), mFrame->GetSize());
51266:     nsPresContext* presContext = mFrame->PresContext();
51266:     presContext->GetTheme()->
51266:         GetWidgetOverflow(presContext->DeviceContext(), mFrame,
51266:                           mFrame->GetStyleDisplay()->mAppearance, &r);
51266:     return r + ToReferenceFrame();
51266:   }
 9369: 
51261:   return nsRect(ToReferenceFrame(), mFrame->GetSize());
 9369: }
 9369: 
 9369: nsRect
    1: nsDisplayOutline::GetBounds(nsDisplayListBuilder* aBuilder) {
51261:   return mFrame->GetOverflowRect() + ToReferenceFrame();
    1: }
    1: 
    1: void
    1: nsDisplayOutline::Paint(nsDisplayListBuilder* aBuilder,
33368:                         nsIRenderingContext* aCtx) {
    1:   // TODO join outlines together
51261:   nsPoint offset = ToReferenceFrame();
  238:   nsCSSRendering::PaintOutline(mFrame->PresContext(), *aCtx, mFrame,
33368:                                mVisibleRect,
33368:                                nsRect(offset, mFrame->GetSize()),
16424:                                mFrame->GetStyleContext());
    1: }
    1: 
    1: PRBool
33368: nsDisplayOutline::ComputeVisibility(nsDisplayListBuilder* aBuilder,
50393:                                     nsRegion* aVisibleRegion) {
50393:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion))
    1:     return PR_FALSE;
    1: 
    1:   const nsStyleOutline* outline = mFrame->GetStyleOutline();
51261:   nsRect borderBox(ToReferenceFrame(), mFrame->GetSize());
34210:   if (borderBox.Contains(aVisibleRegion->GetBounds()) &&
20039:       !nsLayoutUtils::HasNonZeroCorner(outline->mOutlineRadius)) {
19205:     if (outline->mOutlineOffset >= 0) {
    1:       // the visible region is entirely inside the border-rect, and the outline
    1:       // isn't rendered inside the border-rect, so the outline is not visible
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsDisplayCaret::Paint(nsDisplayListBuilder* aBuilder,
33368:                       nsIRenderingContext* aCtx) {
    1:   // Note: Because we exist, we know that the caret is visible, so we don't
    1:   // need to check for the caret's visibility.
51261:   mCaret->PaintCaret(aBuilder, aCtx, mFrame, ToReferenceFrame());
    1: }
    1: 
    1: PRBool
33368: nsDisplayBorder::ComputeVisibility(nsDisplayListBuilder* aBuilder,
50393:                                    nsRegion* aVisibleRegion) {
50393:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion))
    1:     return PR_FALSE;
    1: 
 6376:   nsRect paddingRect = mFrame->GetPaddingRect() - mFrame->GetPosition() +
51261:     ToReferenceFrame();
15992:   const nsStyleBorder *styleBorder;
 6376:   if (paddingRect.Contains(aVisibleRegion->GetBounds()) &&
15992:       !(styleBorder = mFrame->GetStyleBorder())->IsBorderImageLoaded() &&
20039:       !nsLayoutUtils::HasNonZeroCorner(styleBorder->mBorderRadius)) {
    1:     // the visible region is entirely inside the content rect, and no part
    1:     // of the border is rendered inside the content rect, so we are not
    1:     // visible
15992:     // Skip this if there's a border-image (which draws a background
15992:     // too) or if there is a border-radius (which makes the border draw
15992:     // further in).
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsDisplayBorder::Paint(nsDisplayListBuilder* aBuilder,
33368:                        nsIRenderingContext* aCtx) {
51261:   nsPoint offset = ToReferenceFrame();
  238:   nsCSSRendering::PaintBorder(mFrame->PresContext(), *aCtx, mFrame,
33368:                               mVisibleRect,
33368:                               nsRect(offset, mFrame->GetSize()),
16424:                               mFrame->GetStyleContext(),
16424:                               mFrame->GetSkipSides());
    1: }
    1: 
35288: // Given a region, compute a conservative approximation to it as a list
35288: // of rectangles that aren't vertically adjacent (i.e., vertically
35288: // adjacent or overlapping rectangles are combined).
35288: // Right now this is only approximate, some vertically overlapping rectangles
35288: // aren't guaranteed to be combined.
35288: static void
35288: ComputeDisjointRectangles(const nsRegion& aRegion,
35288:                           nsTArray<nsRect>* aRects) {
35288:   nscoord accumulationMargin = nsPresContext::CSSPixelsToAppUnits(25);
35288:   nsRect accumulated;
35288:   nsRegionRectIterator iter(aRegion);
35288:   while (PR_TRUE) {
35288:     const nsRect* r = iter.Next();
35288:     if (r && !accumulated.IsEmpty() &&
35288:         accumulated.YMost() >= r->y - accumulationMargin) {
35288:       accumulated.UnionRect(accumulated, *r);
35288:       continue;
35288:     }
35288: 
35288:     if (!accumulated.IsEmpty()) {
35288:       aRects->AppendElement(accumulated);
35288:       accumulated.Empty();
35288:     }
35288: 
35288:     if (!r)
35288:       break;
35288: 
35288:     accumulated = *r;
35288:   }
35288: }
35288: 
15700: void
24818: nsDisplayBoxShadowOuter::Paint(nsDisplayListBuilder* aBuilder,
33368:                                nsIRenderingContext* aCtx) {
51261:   nsPoint offset = ToReferenceFrame();
35288:   nsRect borderRect = nsRect(offset, mFrame->GetSize());
35288:   nsPresContext* presContext = mFrame->PresContext();
35288:   nsAutoTArray<nsRect,10> rects;
35288:   ComputeDisjointRectangles(mVisibleRegion, &rects);
35288: 
35288:   for (PRUint32 i = 0; i < rects.Length(); ++i) {
35288:     aCtx->PushState();
35288:     aCtx->SetClipRect(rects[i], nsClipCombine_kIntersect);
35288:     nsCSSRendering::PaintBoxShadowOuter(presContext, *aCtx, mFrame,
35288:                                         borderRect, rects[i]);
35288:     aCtx->PopState();
35288:   }
15700: }
15700: 
15700: nsRect
24818: nsDisplayBoxShadowOuter::GetBounds(nsDisplayListBuilder* aBuilder) {
51261:   return mFrame->GetOverflowRect() + ToReferenceFrame();
15700: }
15700: 
24439: PRBool
33368: nsDisplayBoxShadowOuter::ComputeVisibility(nsDisplayListBuilder* aBuilder,
50393:                                            nsRegion* aVisibleRegion) {
50393:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion))
24439:     return PR_FALSE;
24439: 
35288:   // Store the actual visible region
35288:   mVisibleRegion.And(*aVisibleRegion, mVisibleRect);
35288: 
51261:   nsPoint origin = ToReferenceFrame();
34210:   nsRect visibleBounds = aVisibleRegion->GetBounds();
27703:   nsRect frameRect(origin, mFrame->GetSize());
27703:   if (!frameRect.Contains(visibleBounds))
27703:     return PR_TRUE;
27703: 
24439:   // the visible region is entirely inside the border-rect, and box shadows
24439:   // never render within the border-rect (unless there's a border radius).
27703:   nscoord twipsRadii[8];
52132:   PRBool hasBorderRadii = mFrame->GetBorderRadii(twipsRadii);
27703:   if (!hasBorderRadii)
24439:     return PR_FALSE;
24439: 
27703:   return !RoundedRectContainsRect(frameRect, twipsRadii, visibleBounds);
24439: }
24439: 
24818: void
24818: nsDisplayBoxShadowInner::Paint(nsDisplayListBuilder* aBuilder,
33368:                                nsIRenderingContext* aCtx) {
51261:   nsPoint offset = ToReferenceFrame();
35288:   nsRect borderRect = nsRect(offset, mFrame->GetSize());
35288:   nsPresContext* presContext = mFrame->PresContext();
35288:   nsAutoTArray<nsRect,10> rects;
35288:   ComputeDisjointRectangles(mVisibleRegion, &rects);
35288: 
35288:   for (PRUint32 i = 0; i < rects.Length(); ++i) {
35288:     aCtx->PushState();
35288:     aCtx->SetClipRect(rects[i], nsClipCombine_kIntersect);
35288:     nsCSSRendering::PaintBoxShadowInner(presContext, *aCtx, mFrame,
35288:                                         borderRect, rects[i]);
35288:     aCtx->PopState();
35288:   }
35288: }
35288: 
35288: PRBool
35288: nsDisplayBoxShadowInner::ComputeVisibility(nsDisplayListBuilder* aBuilder,
50393:                                            nsRegion* aVisibleRegion) {
50393:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion))
35288:     return PR_FALSE;
35288: 
35288:   // Store the actual visible region
35288:   mVisibleRegion.And(*aVisibleRegion, mVisibleRect);
35288:   return PR_TRUE;
24818: }
24818: 
51260: nsDisplayWrapList::nsDisplayWrapList(nsDisplayListBuilder* aBuilder,
51260:                                      nsIFrame* aFrame, nsDisplayList* aList)
51260:   : nsDisplayItem(aBuilder, aFrame) {
    1:   mList.AppendToTop(aList);
    1: }
    1: 
51260: nsDisplayWrapList::nsDisplayWrapList(nsDisplayListBuilder* aBuilder,
51260:                                      nsIFrame* aFrame, nsDisplayItem* aItem)
51260:   : nsDisplayItem(aBuilder, aFrame) {
    1:   mList.AppendToTop(aItem);
    1: }
    1: 
    1: nsDisplayWrapList::~nsDisplayWrapList() {
    1:   mList.DeleteAll();
    1: }
    1: 
40570: void
40570: nsDisplayWrapList::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                            HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames) {
40570:   mList.HitTest(aBuilder, aRect, aState, aOutFrames);
    1: }
    1: 
    1: nsRect
    1: nsDisplayWrapList::GetBounds(nsDisplayListBuilder* aBuilder) {
19125:   return mList.GetBounds(aBuilder);
    1: }
    1: 
    1: PRBool
33368: nsDisplayWrapList::ComputeVisibility(nsDisplayListBuilder* aBuilder,
50393:                                      nsRegion* aVisibleRegion) {
51633:   return mList.ComputeVisibilityForSublist(aBuilder, aVisibleRegion,
51633:                                            mVisibleRect);
    1: }
    1: 
    1: PRBool
    1: nsDisplayWrapList::IsOpaque(nsDisplayListBuilder* aBuilder) {
51633:   return mList.IsOpaque();
    1: }
    1: 
42436: PRBool nsDisplayWrapList::IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) {
    1:   // We could try to do something but let's conservatively just return PR_FALSE.
    1:   return PR_FALSE;
    1: }
    1: 
50392: PRBool nsDisplayWrapList::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
50392:                                                          nsIFrame* aFrame) {
14202:   NS_WARNING("nsDisplayWrapList::IsVaryingRelativeToMovingFrame called unexpectedly");
14202:   // We could try to do something but let's conservatively just return PR_TRUE.
    1:   return PR_TRUE;
    1: }
    1: 
    1: void nsDisplayWrapList::Paint(nsDisplayListBuilder* aBuilder,
33368:                               nsIRenderingContext* aCtx) {
38803:   NS_ERROR("nsDisplayWrapList should have been flattened away for painting");
    1: }
    1: 
47751: PRBool nsDisplayWrapList::ChildrenCanBeInactive(nsDisplayListBuilder* aBuilder,
47751:                                                 LayerManager* aManager,
47751:                                                 const nsDisplayList& aList,
47751:                                                 nsIFrame* aActiveScrolledRoot) {
47751:   for (nsDisplayItem* i = aList.GetBottom(); i; i = i->GetAbove()) {
47751:     nsIFrame* f = i->GetUnderlyingFrame();
47751:     if (f) {
47751:       nsIFrame* activeScrolledRoot =
49156:         nsLayoutUtils::GetActiveScrolledRootFor(f, nsnull);
47751:       if (activeScrolledRoot != aActiveScrolledRoot)
47751:         return PR_FALSE;
47751:     }
47751: 
47751:     LayerState state = i->GetLayerState(aBuilder, aManager);
47751:     if (state == LAYER_ACTIVE)
47751:       return PR_FALSE;
47751:     if (state == LAYER_NONE) {
47751:       nsDisplayList* list = i->GetList();
47751:       if (list && !ChildrenCanBeInactive(aBuilder, aManager, *list, aActiveScrolledRoot))
47751:         return PR_FALSE;
47751:     }
47751:   }
47751:   return PR_TRUE;
47751: }
47751: 
    1: static nsresult
    1: WrapDisplayList(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
    1:                 nsDisplayList* aList, nsDisplayWrapper* aWrapper) {
50393:   if (!aList->GetTop())
    1:     return NS_OK;
    1:   nsDisplayItem* item = aWrapper->WrapList(aBuilder, aFrame, aList);
    1:   if (!item)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   // aList was emptied
    1:   aList->AppendToTop(item);
    1:   return NS_OK;
    1: }
    1: 
    1: static nsresult
    1: WrapEachDisplayItem(nsDisplayListBuilder* aBuilder,
    1:                     nsDisplayList* aList, nsDisplayWrapper* aWrapper) {
    1:   nsDisplayList newList;
    1:   nsDisplayItem* item;
    1:   while ((item = aList->RemoveBottom())) {
    1:     item = aWrapper->WrapItem(aBuilder, item);
    1:     if (!item)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     newList.AppendToTop(item);
    1:   }
    1:   // aList was emptied
    1:   aList->AppendToTop(&newList);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsDisplayWrapper::WrapLists(nsDisplayListBuilder* aBuilder,
    1:     nsIFrame* aFrame, const nsDisplayListSet& aIn, const nsDisplayListSet& aOut)
    1: {
    1:   nsresult rv = WrapListsInPlace(aBuilder, aFrame, aIn);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (&aOut == &aIn)
    1:     return NS_OK;
    1:   aOut.BorderBackground()->AppendToTop(aIn.BorderBackground());
    1:   aOut.BlockBorderBackgrounds()->AppendToTop(aIn.BlockBorderBackgrounds());
    1:   aOut.Floats()->AppendToTop(aIn.Floats());
    1:   aOut.Content()->AppendToTop(aIn.Content());
    1:   aOut.PositionedDescendants()->AppendToTop(aIn.PositionedDescendants());
    1:   aOut.Outlines()->AppendToTop(aIn.Outlines());
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsDisplayWrapper::WrapListsInPlace(nsDisplayListBuilder* aBuilder,
    1:     nsIFrame* aFrame, const nsDisplayListSet& aLists)
    1: {
    1:   nsresult rv;
    1:   if (WrapBorderBackground()) {
    1:     // Our border-backgrounds are in-flow
    1:     rv = WrapDisplayList(aBuilder, aFrame, aLists.BorderBackground(), this);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   // Our block border-backgrounds are in-flow
    1:   rv = WrapDisplayList(aBuilder, aFrame, aLists.BlockBorderBackgrounds(), this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // The floats are not in flow
    1:   rv = WrapEachDisplayItem(aBuilder, aLists.Floats(), this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // Our child content is in flow
    1:   rv = WrapDisplayList(aBuilder, aFrame, aLists.Content(), this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // The positioned descendants may not be in-flow
    1:   rv = WrapEachDisplayItem(aBuilder, aLists.PositionedDescendants(), this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // The outlines may not be in-flow
    1:   return WrapEachDisplayItem(aBuilder, aLists.Outlines(), this);
    1: }
    1: 
51260: nsDisplayOpacity::nsDisplayOpacity(nsDisplayListBuilder* aBuilder,
51260:                                    nsIFrame* aFrame, nsDisplayList* aList)
51260:     : nsDisplayWrapList(aBuilder, aFrame, aList) {
    1:   MOZ_COUNT_CTOR(nsDisplayOpacity);
    1: }
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1: nsDisplayOpacity::~nsDisplayOpacity() {
    1:   MOZ_COUNT_DTOR(nsDisplayOpacity);
    1: }
    1: #endif
    1: 
    1: PRBool nsDisplayOpacity::IsOpaque(nsDisplayListBuilder* aBuilder) {
    1:   // We are never opaque, if our opacity was < 1 then we wouldn't have
    1:   // been created.
    1:   return PR_FALSE;
    1: }
    1: 
38803: // nsDisplayOpacity uses layers for rendering
38803: already_AddRefed<Layer>
38803: nsDisplayOpacity::BuildLayer(nsDisplayListBuilder* aBuilder,
38803:                              LayerManager* aManager) {
42593:   nsRefPtr<Layer> layer = aBuilder->LayerBuilder()->
47736:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList);
38803:   if (!layer)
38803:     return nsnull;
    1: 
42246:   layer->SetOpacity(mFrame->GetStyleDisplay()->mOpacity);
38803:   return layer.forget();
38803: }
    1: 
47751: nsDisplayItem::LayerState
47751: nsDisplayOpacity::GetLayerState(nsDisplayListBuilder* aBuilder,
47751:                                 LayerManager* aManager) {
47753:   if (mFrame->AreLayersMarkedActive())
47753:     return LAYER_ACTIVE;
47751:   nsIFrame* activeScrolledRoot =
49156:     nsLayoutUtils::GetActiveScrolledRootFor(mFrame, nsnull);
47751:   return !ChildrenCanBeInactive(aBuilder, aManager, mList, activeScrolledRoot)
47751:       ? LAYER_ACTIVE : LAYER_INACTIVE;
47751: }
47751: 
33368: PRBool nsDisplayOpacity::ComputeVisibility(nsDisplayListBuilder* aBuilder,
50393:                                            nsRegion* aVisibleRegion) {
    1:   // Our children are translucent so we should not allow them to subtract
    1:   // area from aVisibleRegion. We do need to find out what is visible under
    1:   // our children in the temporary compositing buffer, because if our children
    1:   // paint our entire bounds opaquely then we don't need an alpha channel in
    1:   // the temporary compositing buffer.
38803:   nsRect bounds = GetBounds(aBuilder);
38803:   nsRegion visibleUnderChildren;
38803:   visibleUnderChildren.And(*aVisibleRegion, bounds);
38803:   return
50393:     nsDisplayWrapList::ComputeVisibility(aBuilder, &visibleUnderChildren);
    1: }
    1: 
    1: PRBool nsDisplayOpacity::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
    1:   if (aItem->GetType() != TYPE_OPACITY)
    1:     return PR_FALSE;
    1:   // items for the same content element should be merged into a single
    1:   // compositing group
    1:   // aItem->GetUnderlyingFrame() returns non-null because it's nsDisplayOpacity
    1:   if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
    1:     return PR_FALSE;
 3233:   mList.AppendToBottom(&static_cast<nsDisplayOpacity*>(aItem)->mList);
    1:   return PR_TRUE;
    1: }
    1: 
51260: nsDisplayOwnLayer::nsDisplayOwnLayer(nsDisplayListBuilder* aBuilder,
51260:                                      nsIFrame* aFrame, nsDisplayList* aList)
51260:     : nsDisplayWrapList(aBuilder, aFrame, aList) {
47744:   MOZ_COUNT_CTOR(nsDisplayOwnLayer);
47744: }
47744: 
47744: #ifdef NS_BUILD_REFCNT_LOGGING
47744: nsDisplayOwnLayer::~nsDisplayOwnLayer() {
47744:   MOZ_COUNT_DTOR(nsDisplayOwnLayer);
47744: }
47744: #endif
47744: 
47744: // nsDisplayOpacity uses layers for rendering
47744: already_AddRefed<Layer>
47744: nsDisplayOwnLayer::BuildLayer(nsDisplayListBuilder* aBuilder,
47744:                               LayerManager* aManager) {
47744:   nsRefPtr<Layer> layer = aBuilder->LayerBuilder()->
47744:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, mList);
47744:   return layer.forget();
47744: }
47744: 
51260: nsDisplayClip::nsDisplayClip(nsDisplayListBuilder* aBuilder,
52289:                              nsIFrame* aFrame, nsDisplayItem* aItem,
52289:                              const nsRect& aRect)
51260:    : nsDisplayWrapList(aBuilder, aFrame, aItem),
52289:      mClip(aRect) {
    1:   MOZ_COUNT_CTOR(nsDisplayClip);
    1: }
    1: 
51260: nsDisplayClip::nsDisplayClip(nsDisplayListBuilder* aBuilder,
52289:                              nsIFrame* aFrame, nsDisplayList* aList,
52289:                              const nsRect& aRect)
51260:    : nsDisplayWrapList(aBuilder, aFrame, aList),
52289:      mClip(aRect) {
    1:   MOZ_COUNT_CTOR(nsDisplayClip);
    1: }
    1: 
    1: nsRect nsDisplayClip::GetBounds(nsDisplayListBuilder* aBuilder) {
    1:   nsRect r = nsDisplayWrapList::GetBounds(aBuilder);
    1:   r.IntersectRect(mClip, r);
    1:   return r;
    1: }
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1: nsDisplayClip::~nsDisplayClip() {
    1:   MOZ_COUNT_DTOR(nsDisplayClip);
    1: }
    1: #endif
    1: 
    1: void nsDisplayClip::Paint(nsDisplayListBuilder* aBuilder,
33368:                           nsIRenderingContext* aCtx) {
38803:   NS_ERROR("nsDisplayClip should have been flattened away for painting");
    1: }
    1: 
33368: PRBool nsDisplayClip::ComputeVisibility(nsDisplayListBuilder* aBuilder,
50393:                                         nsRegion* aVisibleRegion) {
34210:   nsRegion clipped;
34210:   clipped.And(*aVisibleRegion, mClip);
34210: 
34210:   nsRegion finalClipped(clipped);
34210:   PRBool anyVisible =
50393:     nsDisplayWrapList::ComputeVisibility(aBuilder, &finalClipped);
34210: 
34210:   nsRegion removed;
34210:   removed.Sub(clipped, finalClipped);
34210:   aBuilder->SubtractFromVisibleRegion(aVisibleRegion, removed);
34210: 
    1:   return anyVisible;
    1: }
    1: 
    1: PRBool nsDisplayClip::TryMerge(nsDisplayListBuilder* aBuilder,
    1:                                nsDisplayItem* aItem) {
    1:   if (aItem->GetType() != TYPE_CLIP)
    1:     return PR_FALSE;
 3233:   nsDisplayClip* other = static_cast<nsDisplayClip*>(aItem);
52289:   if (other->mClip != mClip)
    1:     return PR_FALSE;
    1:   mList.AppendToBottom(&other->mList);
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsDisplayWrapList* nsDisplayClip::WrapWithClone(nsDisplayListBuilder* aBuilder,
    1:                                                 nsDisplayItem* aItem) {
14466:   return new (aBuilder)
52289:     nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(), aItem, mClip);
    1: }
19125: 
52292: nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
52292:                              nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
52292:                              nsDisplayItem* aItem,
52292:                              const nsRect& aRect, nscoord aRadii[8])
52292:     : nsDisplayClip(aBuilder, aFrame, aItem, aRect)
52292: {
52292:   MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
52292:   memcpy(mRadii, aRadii, sizeof(mRadii));
52292: }
52292: 
52292: nsDisplayClipRoundedRect::nsDisplayClipRoundedRect(
52292:                              nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
52292:                              nsDisplayList* aList,
52292:                              const nsRect& aRect, nscoord aRadii[8])
52292:     : nsDisplayClip(aBuilder, aFrame, aList, aRect)
52292: {
52292:   MOZ_COUNT_CTOR(nsDisplayClipRoundedRect);
52292:   memcpy(mRadii, aRadii, sizeof(mRadii));
52292: }
52292: 
52292: #ifdef NS_BUILD_REFCNT_LOGGING
52292: nsDisplayClipRoundedRect::~nsDisplayClipRoundedRect()
52292: {
52292:   MOZ_COUNT_DTOR(nsDisplayClipRoundedRect);
52292: }
52292: #endif
52292: 
52292: PRBool nsDisplayClipRoundedRect::IsOpaque(nsDisplayListBuilder* aBuilder)
52292: {
52292:   return PR_FALSE;
52292: }
52292: 
52292: void
52292: nsDisplayClipRoundedRect::HitTest(nsDisplayListBuilder* aBuilder,
52292:                                   const nsRect& aRect, HitTestState* aState,
52292:                                   nsTArray<nsIFrame*> *aOutFrames)
52292: {
52292:   // FIXME: Consider border-radius.
52292:   mList.HitTest(aBuilder, aRect, aState, aOutFrames);
52292: }
52292: 
52292: nsDisplayWrapList*
52292: nsDisplayClipRoundedRect::WrapWithClone(nsDisplayListBuilder* aBuilder,
52292:                                         nsDisplayItem* aItem) {
52292:   return new (aBuilder)
52292:     nsDisplayClipRoundedRect(aBuilder, aItem->GetUnderlyingFrame(), aItem,
52292:                              mClip, mRadii);
52292: }
52292: 
52292: PRBool nsDisplayClipRoundedRect::ComputeVisibility(
52292:                                     nsDisplayListBuilder* aBuilder,
52292:                                     nsRegion* aVisibleRegion)
52292: {
52292:   nsRegion clipped;
52292:   clipped.And(*aVisibleRegion, mClip);
52292: 
52292:   return nsDisplayWrapList::ComputeVisibility(aBuilder, &clipped);
52292:   // FIXME: Remove a *conservative* opaque region from aVisibleRegion
52292:   // (like in nsDisplayClip::ComputeVisibility).
52292: }
52292: 
52292: PRBool nsDisplayClipRoundedRect::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
52292: {
52292:   if (aItem->GetType() != TYPE_CLIP_ROUNDED_RECT)
52292:     return PR_FALSE;
52292:   nsDisplayClipRoundedRect* other =
52292:     static_cast<nsDisplayClipRoundedRect*>(aItem);
52292:   if (mClip != other->mClip || mRadii != other->mRadii)
52292:     return PR_FALSE;
52292:   mList.AppendToBottom(&other->mList);
52292:   return PR_TRUE;
52292: }
52292: 
51260: nsDisplayZoom::nsDisplayZoom(nsDisplayListBuilder* aBuilder,
51260:                              nsIFrame* aFrame, nsDisplayList* aList,
47900:                              PRInt32 aAPD, PRInt32 aParentAPD)
51260:     : nsDisplayOwnLayer(aBuilder, aFrame, aList), mAPD(aAPD),
51260:       mParentAPD(aParentAPD) {
47900:   MOZ_COUNT_CTOR(nsDisplayZoom);
47900: }
19214: 
47900: #ifdef NS_BUILD_REFCNT_LOGGING
47900: nsDisplayZoom::~nsDisplayZoom() {
47900:   MOZ_COUNT_DTOR(nsDisplayZoom);
47900: }
47900: #endif
47900: 
47900: nsRect nsDisplayZoom::GetBounds(nsDisplayListBuilder* aBuilder)
47900: {
47900:   nsRect bounds = nsDisplayWrapList::GetBounds(aBuilder);
47900:   return bounds.ConvertAppUnitsRoundOut(mAPD, mParentAPD);
47900: }
47900: 
47900: void nsDisplayZoom::HitTest(nsDisplayListBuilder *aBuilder,
47900:                             const nsRect& aRect,
47900:                             HitTestState *aState,
47900:                             nsTArray<nsIFrame*> *aOutFrames)
47900: {
47900:   nsRect rect;
47900:   // A 1x1 rect indicates we are just hit testing a point, so pass down a 1x1
47900:   // rect as well instead of possibly rounding the width or height to zero.
47900:   if (aRect.width == 1 && aRect.height == 1) {
47900:     rect.MoveTo(aRect.TopLeft().ConvertAppUnits(mParentAPD, mAPD));
47900:     rect.width = rect.height = 1;
47900:   } else {
47900:     rect = aRect.ConvertAppUnitsRoundOut(mParentAPD, mAPD);
47900:   }
47900:   mList.HitTest(aBuilder, rect, aState, aOutFrames);
47900: }
47900: 
47900: void nsDisplayZoom::Paint(nsDisplayListBuilder* aBuilder,
47900:                           nsIRenderingContext* aCtx)
47900: {
47900:   mList.PaintForFrame(aBuilder, aCtx, mFrame, nsDisplayList::PAINT_DEFAULT);
47900: }
47900: 
47900: PRBool nsDisplayZoom::ComputeVisibility(nsDisplayListBuilder *aBuilder,
50393:                                         nsRegion *aVisibleRegion)
47900: {
47900:   // Convert the passed in visible region to our appunits.
47900:   nsRegion visibleRegion =
47900:     aVisibleRegion->ConvertAppUnitsRoundOut(mParentAPD, mAPD);
47900:   nsRegion originalVisibleRegion = visibleRegion;
47900: 
51633:   nsRect transformedVisibleRect =
51633:     mVisibleRect.ConvertAppUnitsRoundOut(mParentAPD, mAPD);
47900:   PRBool retval =
51633:     mList.ComputeVisibilityForSublist(aBuilder, &visibleRegion,
51633:                                       transformedVisibleRect);
47900: 
47900:   nsRegion removed;
47900:   // removed = originalVisibleRegion - visibleRegion
47900:   removed.Sub(originalVisibleRegion, visibleRegion);
47900:   // Convert removed region to parent appunits.
47900:   removed = removed.ConvertAppUnitsRoundIn(mAPD, mParentAPD);
47900:   // aVisibleRegion = aVisibleRegion - removed (modulo any simplifications
47900:   // SubtractFromVisibleRegion does)
47900:   aBuilder->SubtractFromVisibleRegion(aVisibleRegion, removed);
47900: 
47900:   return retval;
47900: }
19214: 
19214: ///////////////////////////////////////////////////
19214: // nsDisplayTransform Implementation
19214: //
19214: 
19214: // Write #define UNIFIED_CONTINUATIONS here to have the transform property try
19214: // to transform content with continuations as one unified block instead of
19214: // several smaller ones.  This is currently disabled because it doesn't work
30710: // correctly, since when the frames are initially being reflowed, their
19214: // continuations all compute their bounding rects independently of each other
19214: // and consequently get the wrong value.  Write #define DEBUG_HIT here to have
19214: // the nsDisplayTransform class dump out a bunch of information about hit
19214: // detection.
19214: #undef  UNIFIED_CONTINUATIONS
19214: #undef  DEBUG_HIT
19214: 
19214: /* Returns the bounds of a frame as defined for transforms.  If
19214:  * UNIFIED_CONTINUATIONS is not defined, this is simply the frame's bounding
19214:  * rectangle, translated to the origin. Otherwise, returns the smallest
19214:  * rectangle containing a frame and all of its continuations.  For example, if
19214:  * there is a <span> element with several continuations split over several
19214:  * lines, this function will return the rectangle containing all of those
19214:  * continuations.  This rectangle is relative to the origin of the frame's local
19214:  * coordinate space.
19214:  */
19214: #ifndef UNIFIED_CONTINUATIONS
19214: 
19214: nsRect
19214: nsDisplayTransform::GetFrameBoundsForTransform(const nsIFrame* aFrame)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't get the bounds of a nonexistent frame!");
19214:   return nsRect(nsPoint(0, 0), aFrame->GetSize());
19214: }
19214: 
19214: #else
19214: 
19214: nsRect
19214: nsDisplayTransform::GetFrameBoundsForTransform(const nsIFrame* aFrame)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't get the bounds of a nonexistent frame!");
19214: 
19214:   nsRect result;
19214:   
19214:   /* Iterate through the continuation list, unioning together all the
19214:    * bounding rects.
19214:    */
19214:   for (const nsIFrame *currFrame = aFrame->GetFirstContinuation();
19214:        currFrame != nsnull;
19214:        currFrame = currFrame->GetNextContinuation())
19214:     {
19214:       /* Get the frame rect in local coordinates, then translate back to the
19214:        * original coordinates.
19214:        */
19214:       result.UnionRect(result, nsRect(currFrame->GetOffsetTo(aFrame),
19214:                                       currFrame->GetSize()));
19214:     }
19214: 
19214:   return result;
19214: }
19214: 
19214: #endif
19214: 
43138: /* Returns the delta specified by the -moz-transform-origin property.
19214:  * This is a positive delta, meaning that it indicates the direction to move
19214:  * to get from (0, 0) of the frame to the transform origin.
19214:  */
19214: static
19214: gfxPoint GetDeltaToMozTransformOrigin(const nsIFrame* aFrame,
19214:                                       float aFactor,
19214:                                       const nsRect* aBoundsOverride)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't get delta for a null frame!");
19214:   NS_PRECONDITION(aFrame->GetStyleDisplay()->HasTransform(),
19214:                   "Can't get a delta for an untransformed frame!");
19214: 
19214:   /* For both of the coordinates, if the value of -moz-transform is a
19214:    * percentage, it's relative to the size of the frame.  Otherwise, if it's
19214:    * a distance, it's already computed for us!
19214:    */
19214:   const nsStyleDisplay* display = aFrame->GetStyleDisplay();
19214:   nsRect boundingRect = (aBoundsOverride ? *aBoundsOverride :
19214:                          nsDisplayTransform::GetFrameBoundsForTransform(aFrame));
19214: 
19214:   /* Allows us to access named variables by index. */
19214:   gfxPoint result;
19214:   gfxFloat* coords[2] = {&result.x, &result.y};
19214:   const nscoord* dimensions[2] =
19214:     {&boundingRect.width, &boundingRect.height};
19214: 
19214:   for (PRUint8 index = 0; index < 2; ++index) {
19214:     /* If the -moz-transform-origin specifies a percentage, take the percentage
19214:      * of the size of the box.
19214:      */
53920:     const nsStyleCoord &coord = display->mTransformOrigin[index];
53920:     if (coord.GetUnit() == eStyleUnit_Calc) {
53920:       const nsStyleCoord::Calc *calc = coord.GetCalcValue();
19214:       *coords[index] = NSAppUnitsToFloatPixels(*dimensions[index], aFactor) *
53920:                          calc->mPercent +
53920:                        NSAppUnitsToFloatPixels(calc->mLength, aFactor);
53920:     } else if (coord.GetUnit() == eStyleUnit_Percent) {
53920:       *coords[index] = NSAppUnitsToFloatPixels(*dimensions[index], aFactor) *
53920:         coord.GetPercentValue();
53920:     } else {
53920:       NS_ABORT_IF_FALSE(coord.GetUnit() == eStyleUnit_Coord, "unexpected unit");
53920:       *coords[index] = NSAppUnitsToFloatPixels(coord.GetCoordValue(), aFactor);
53920:     }
19214:   }
19214:   
19214:   /* Adjust based on the origin of the rectangle. */
19214:   result.x += NSAppUnitsToFloatPixels(boundingRect.x, aFactor);
19214:   result.y += NSAppUnitsToFloatPixels(boundingRect.y, aFactor);
19214: 
19214:   return result;
19214: }
19214: 
19214: /* Wraps up the -moz-transform matrix in a change-of-basis matrix pair that
19214:  * translates from local coordinate space to transform coordinate space, then
19214:  * hands it back.
19214:  */
19214: gfxMatrix
19214: nsDisplayTransform::GetResultingTransformMatrix(const nsIFrame* aFrame,
19214:                                                 const nsPoint &aOrigin,
19214:                                                 float aFactor,
19214:                                                 const nsRect* aBoundsOverride)
19214: {
19214:   NS_PRECONDITION(aFrame, "Cannot get transform matrix for a null frame!");
19214:   NS_PRECONDITION(aFrame->GetStyleDisplay()->HasTransform(),
19214:                   "Cannot get transform matrix if frame isn't transformed!");
19214: 
19214:   /* Account for the -moz-transform-origin property by translating the
19214:    * coordinate space to the new origin.
19214:    */
19214:   gfxPoint toMozOrigin = GetDeltaToMozTransformOrigin(aFrame, aFactor, aBoundsOverride);
19214:   gfxPoint newOrigin = gfxPoint(NSAppUnitsToFloatPixels(aOrigin.x, aFactor),
19214:                                 NSAppUnitsToFloatPixels(aOrigin.y, aFactor));
19214: 
19214:   /* Get the underlying transform matrix.  This requires us to get the
19214:    * bounds of the frame.
19214:    */
19214:   const nsStyleDisplay* disp = aFrame->GetStyleDisplay();
19214:   nsRect bounds = (aBoundsOverride ? *aBoundsOverride :
19214:                    nsDisplayTransform::GetFrameBoundsForTransform(aFrame));
19214: 
19214:   /* Get the matrix, then change its basis to factor in the origin. */
19214:   return nsLayoutUtils::ChangeMatrixBasis
19214:     (newOrigin + toMozOrigin, disp->mTransform.GetThebesMatrix(bounds, aFactor));
19214: }
19214: 
48693: already_AddRefed<Layer> nsDisplayTransform::BuildLayer(nsDisplayListBuilder *aBuilder,
48693:                                                        LayerManager *aManager)
19214: {
19517:   gfxMatrix newTransformMatrix =
51261:     GetResultingTransformMatrix(mFrame, ToReferenceFrame(),
19517:                                  mFrame->PresContext()->AppUnitsPerDevPixel(),
19517:                                 nsnull);
19517:   if (newTransformMatrix.IsSingular())
48693:     return nsnull;
19517: 
48693:   nsRefPtr<Layer> layer = aBuilder->LayerBuilder()->
48693:     BuildContainerLayerFor(aBuilder, aManager, mFrame, this, *mStoredList.GetList());
48693:   if (!layer)
48693:     return nsnull;
19214:  
48693:   layer->SetTransform(gfx3DMatrix::From2D(newTransformMatrix));
48693:   return layer.forget();
48693: }
19214: 
48693: nsDisplayItem::LayerState
48693: nsDisplayTransform::GetLayerState(nsDisplayListBuilder* aBuilder,
48693:                                   LayerManager* aManager) {
48693:   if (mFrame->AreLayersMarkedActive())
48693:     return LAYER_ACTIVE;
48693:   nsIFrame* activeScrolledRoot =
49156:     nsLayoutUtils::GetActiveScrolledRootFor(mFrame, nsnull);
48693:   return !mStoredList.ChildrenCanBeInactive(aBuilder, 
48693:                                              aManager, 
48693:                                              *mStoredList.GetList(), 
48693:                                              activeScrolledRoot)
48693:       ? LAYER_ACTIVE : LAYER_INACTIVE;
19214: }
19214: 
33368: PRBool nsDisplayTransform::ComputeVisibility(nsDisplayListBuilder *aBuilder,
50393:                                              nsRegion *aVisibleRegion)
19214: {
33368:   /* As we do this, we need to be sure to
33368:    * untransform the visible rect, since we want everything that's painting to
33368:    * think that it's painting in its original rectangular coordinate space. */
33368:   nsRegion untransformedVisible =
51261:     UntransformRect(mVisibleRect, mFrame, ToReferenceFrame());
51633:   // Call RecomputeVisiblity instead of ComputeVisibilty since
51633:   // nsDisplayItem::ComputeVisibility should only be called from
51633:   // nsDisplayList::ComputeVisibility (which sets mVisibleRect on the item)
51633:   mStoredList.RecomputeVisibility(aBuilder, &untransformedVisible);
19214:   return PR_TRUE;
19214: }
19214: 
19214: #ifdef DEBUG_HIT
19214: #include <time.h>
19214: #endif
19214: 
19214: /* HitTest does some fun stuff with matrix transforms to obtain the answer. */
40570: void nsDisplayTransform::HitTest(nsDisplayListBuilder *aBuilder,
40570:                                  const nsRect& aRect,
40570:                                  HitTestState *aState,
40570:                                  nsTArray<nsIFrame*> *aOutFrames)
19214: {
19214:   /* Here's how this works:
19214:    * 1. Get the matrix.  If it's singular, abort (clearly we didn't hit
19214:    *    anything).
19214:    * 2. Invert the matrix.
40570:    * 3. Use it to transform the rect into the correct space.
40570:    * 4. Pass that rect down through to the list's version of HitTest.
19214:    */
19214:   float factor = nsPresContext::AppUnitsPerCSSPixel();
19214:   gfxMatrix matrix =
51261:     GetResultingTransformMatrix(mFrame, ToReferenceFrame(),
19214:                                 factor, nsnull);
19214:   if (matrix.IsSingular())
40570:     return;
19214: 
19214:   /* We want to go from transformed-space to regular space.
19214:    * Thus we have to invert the matrix, which normally does
19214:    * the reverse operation (e.g. regular->transformed)
19214:    */
19214:   matrix.Invert();
19214: 
19214:   /* Now, apply the transform and pass it down the channel. */
40570:   nsRect resultingRect;
40570:   if (aRect.width == 1 && aRect.height == 1) {
40570:     gfxPoint point = matrix.Transform(gfxPoint(NSAppUnitsToFloatPixels(aRect.x, factor),
40570:                                                NSAppUnitsToFloatPixels(aRect.y, factor)));
40570: 
40570:     resultingRect = nsRect(NSFloatPixelsToAppUnits(float(point.x), factor),
40570:                            NSFloatPixelsToAppUnits(float(point.y), factor),
40570:                            1, 1);
40570: 
40570:   } else {
40570:     gfxRect originalRect(NSAppUnitsToFloatPixels(aRect.x, factor),
40570:                          NSAppUnitsToFloatPixels(aRect.y, factor),
40570:                          NSAppUnitsToFloatPixels(aRect.width, factor),
40570:                          NSAppUnitsToFloatPixels(aRect.height, factor));
40570: 
40570:     gfxRect rect = matrix.TransformBounds(originalRect);
40570: 
40570:     resultingRect = nsRect(NSFloatPixelsToAppUnits(float(rect.X()), factor),
40570:                            NSFloatPixelsToAppUnits(float(rect.Y()), factor),
40570:                            NSFloatPixelsToAppUnits(float(rect.Width()), factor),
40570:                            NSFloatPixelsToAppUnits(float(rect.Height()), factor));
40570:   }
40570:   
19214: 
19214: #ifdef DEBUG_HIT
19214:   printf("Frame: %p\n", dynamic_cast<void *>(mFrame));
40570:   printf("  Untransformed point: (%f, %f)\n", resultingRect.X(), resultingRect.Y());
40570:   PRUint32 originalFrameCount = aOutFrames.Length();
19214: #endif
19214: 
40570:   mStoredList.HitTest(aBuilder, resultingRect, aState, aOutFrames);
19214: 
19214: #ifdef DEBUG_HIT
40570:   if (originalFrameCount != aOutFrames.Length())
40570:     printf("  Hit! Time: %f, first frame: %p\n", static_cast<double>(clock()),
40570:            dynamic_cast<void *>(aOutFrames.ElementAt(0)));
19214:   printf("=== end of hit test ===\n");
19214: #endif
19214: 
19214: }
19214: 
19214: /* The bounding rectangle for the object is the overflow rectangle translated
19214:  * by the reference point.
19214:  */
19214: nsRect nsDisplayTransform::GetBounds(nsDisplayListBuilder *aBuilder)
19214: {
51261:   return mFrame->GetOverflowRect() + ToReferenceFrame();
19214: }
19214: 
19214: /* The transform is opaque iff the transform consists solely of scales and
19214:  * transforms and if the underlying content is opaque.  Thus if the transform
19214:  * is of the form
19214:  *
19214:  * |a c e|
19214:  * |b d f|
19214:  * |0 0 1|
19214:  *
19214:  * We need b and c to be zero.
19214:  */
19214: PRBool nsDisplayTransform::IsOpaque(nsDisplayListBuilder *aBuilder)
19214: {
19214:   const nsStyleDisplay* disp = mFrame->GetStyleDisplay();
19214:   return disp->mTransform.GetMainMatrixEntry(1) == 0.0f &&
19214:     disp->mTransform.GetMainMatrixEntry(2) == 0.0f &&
19214:     mStoredList.IsOpaque(aBuilder);
19214: }
19214: 
19214: /* The transform is uniform if it fills the entire bounding rect and the
19214:  * wrapped list is uniform.  See IsOpaque for discussion of why this
19214:  * works.
19214:  */
42436: PRBool nsDisplayTransform::IsUniform(nsDisplayListBuilder *aBuilder, nscolor* aColor)
19214: {
19214:   const nsStyleDisplay* disp = mFrame->GetStyleDisplay();
19214:   return disp->mTransform.GetMainMatrixEntry(1) == 0.0f &&
19214:     disp->mTransform.GetMainMatrixEntry(2) == 0.0f &&
42436:     mStoredList.IsUniform(aBuilder, aColor);
19214: }
19214: 
19214: /* If UNIFIED_CONTINUATIONS is defined, we can merge two display lists that
19214:  * share the same underlying content.  Otherwise, doing so results in graphical
19214:  * glitches.
19214:  */
19214: #ifndef UNIFIED_CONTINUATIONS
19214: 
19214: PRBool
19214: nsDisplayTransform::TryMerge(nsDisplayListBuilder *aBuilder,
19214:                              nsDisplayItem *aItem)
19214: {
19214:   return PR_FALSE;
19214: }
19214: 
19214: #else
19214: 
19214: PRBool
19214: nsDisplayTransform::TryMerge(nsDisplayListBuilder *aBuilder,
19214:                              nsDisplayItem *aItem)
19214: {
19214:   NS_PRECONDITION(aItem, "Why did you try merging with a null item?");
19214:   NS_PRECONDITION(aBuilder, "Why did you try merging with a null builder?");
19214: 
19214:   /* Make sure that we're dealing with two transforms. */
19214:   if (aItem->GetType() != TYPE_TRANSFORM)
19214:     return PR_FALSE;
19214: 
19214:   /* Check to see that both frames are part of the same content. */
19214:   if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
19214:     return PR_FALSE;
19214: 
19214:   /* Now, move everything over to this frame and signal that
19214:    * we merged things!
19214:    */
19214:   mStoredList.GetList()->
19214:     AppendToBottom(&static_cast<nsDisplayTransform *>(aItem)->mStoredList);
19214:   return PR_TRUE;
19214: }
19214: 
19214: #endif
19214: 
19214: /* TransformRect takes in as parameters a rectangle (in app space) and returns
19214:  * the smallest rectangle (in app space) containing the transformed image of
19214:  * that rectangle.  That is, it takes the four corners of the rectangle,
19214:  * transforms them according to the matrix associated with the specified frame,
19214:  * then returns the smallest rectangle containing the four transformed points.
19214:  *
19214:  * @param aUntransformedBounds The rectangle (in app units) to transform.
19214:  * @param aFrame The frame whose transformation should be applied.
19214:  * @param aOrigin The delta from the frame origin to the coordinate space origin
19214:  * @param aBoundsOverride (optional) Force the frame bounds to be the
19214:  *        specified bounds.
19214:  * @return The smallest rectangle containing the image of the transformed
19214:  *         rectangle.
19214:  */
19214: nsRect nsDisplayTransform::TransformRect(const nsRect &aUntransformedBounds,
19214:                                          const nsIFrame* aFrame,
19214:                                          const nsPoint &aOrigin,
19214:                                          const nsRect* aBoundsOverride)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't take the transform based on a null frame!");
19214:   NS_PRECONDITION(aFrame->GetStyleDisplay()->HasTransform(),
19214:                   "Cannot transform a rectangle if there's no transformation!");
19214: 
19214:   float factor = nsPresContext::AppUnitsPerCSSPixel();
19214:   return nsLayoutUtils::MatrixTransformRect
19214:     (aUntransformedBounds,
19214:      GetResultingTransformMatrix(aFrame, aOrigin, factor, aBoundsOverride),
19214:      factor);
19214: }
19214: 
19214: nsRect nsDisplayTransform::UntransformRect(const nsRect &aUntransformedBounds,
19214:                                            const nsIFrame* aFrame,
19214:                                            const nsPoint &aOrigin)
19214: {
19214:   NS_PRECONDITION(aFrame, "Can't take the transform based on a null frame!");
19214:   NS_PRECONDITION(aFrame->GetStyleDisplay()->HasTransform(),
19214:                   "Cannot transform a rectangle if there's no transformation!");
19214: 
19214: 
19214:   /* Grab the matrix.  If the transform is degenerate, just hand back the
19214:    * empty rect.
19214:    */
19214:   float factor = nsPresContext::AppUnitsPerCSSPixel();
19214:   gfxMatrix matrix = GetResultingTransformMatrix(aFrame, aOrigin, factor, nsnull);
19214:   if (matrix.IsSingular())
19214:     return nsRect();
19214: 
19214:   /* We want to untransform the matrix, so invert the transformation first! */
19214:   matrix.Invert();
19214: 
19214:   return nsLayoutUtils::MatrixTransformRect(aUntransformedBounds, matrix,
19214:                                             factor);
19214: }
19214: 
19125: #ifdef MOZ_SVG
51260: nsDisplaySVGEffects::nsDisplaySVGEffects(nsDisplayListBuilder* aBuilder,
51260:                                          nsIFrame* aFrame, nsDisplayList* aList)
51260:     : nsDisplayWrapList(aBuilder, aFrame, aList), mEffectsFrame(aFrame),
19284:       mBounds(aFrame->GetOverflowRectRelativeToSelf())
19125: {
19125:   MOZ_COUNT_CTOR(nsDisplaySVGEffects);
19125: }
19125: 
19125: #ifdef NS_BUILD_REFCNT_LOGGING
19125: nsDisplaySVGEffects::~nsDisplaySVGEffects()
19125: {
19125:   MOZ_COUNT_DTOR(nsDisplaySVGEffects);
19125: }
19125: #endif
19125: 
19125: PRBool nsDisplaySVGEffects::IsOpaque(nsDisplayListBuilder* aBuilder)
19125: {
19125:   return PR_FALSE;
19125: }
19125: 
40570: void
40570: nsDisplaySVGEffects::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                              HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
19125: {
40570:   nsPoint rectCenter(aRect.x + aRect.width / 2, aRect.y + aRect.height / 2);
40570:   if (nsSVGIntegrationUtils::HitTestFrameForEffects(mEffectsFrame,
40570:       rectCenter - aBuilder->ToReferenceFrame(mEffectsFrame))) {
40570:     mList.HitTest(aBuilder, aRect, aState, aOutFrames);
40570:   }
19125: }
19125: 
19125: void nsDisplaySVGEffects::Paint(nsDisplayListBuilder* aBuilder,
33368:                                 nsIRenderingContext* aCtx)
19125: {
19125:   nsSVGIntegrationUtils::PaintFramesWithEffects(aCtx,
33368:           mEffectsFrame, mVisibleRect, aBuilder, &mList);
19125: }
19125: 
33368: PRBool nsDisplaySVGEffects::ComputeVisibility(nsDisplayListBuilder* aBuilder,
50393:                                               nsRegion* aVisibleRegion) {
19125:   nsPoint offset = aBuilder->ToReferenceFrame(mEffectsFrame);
34210:   nsRect dirtyRect =
34210:     nsSVGIntegrationUtils::GetRequiredSourceForInvalidArea(mEffectsFrame,
34210:                                                            mVisibleRect - offset) +
34210:     offset;
19125: 
34210:   // Our children may be made translucent or arbitrarily deformed so we should
34210:   // not allow them to subtract area from aVisibleRegion.
34210:   nsRegion childrenVisible(dirtyRect);
51633:   nsRect r;
51633:   r.IntersectRect(dirtyRect, mList.GetBounds(aBuilder));
51633:   mList.ComputeVisibilityForSublist(aBuilder, &childrenVisible, r);
33368:   return PR_TRUE;
19125: }
19125: 
19125: PRBool nsDisplaySVGEffects::TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
19125: {
19125:   if (aItem->GetType() != TYPE_SVG_EFFECTS)
19125:     return PR_FALSE;
19125:   // items for the same content element should be merged into a single
19125:   // compositing group
19125:   // aItem->GetUnderlyingFrame() returns non-null because it's nsDisplaySVGEffects
19125:   if (aItem->GetUnderlyingFrame()->GetContent() != mFrame->GetContent())
19125:     return PR_FALSE;
19125:   nsDisplaySVGEffects* other = static_cast<nsDisplaySVGEffects*>(aItem);
19125:   mList.AppendToBottom(&other->mList);
19125:   mBounds.UnionRect(mBounds,
19125:     other->mBounds + other->mEffectsFrame->GetOffsetTo(mEffectsFrame));
19125:   return PR_TRUE;
19125: }
19125: #endif
