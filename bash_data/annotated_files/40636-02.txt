37042: /* -*- Mode: c++; c-basic-offset: 4; tab-width: 40; indent-tabs-mode: nil -*- */
39911: /* vim: set ts=40 sw=4 et tw=99: */
37042: /* ***** BEGIN LICENSE BLOCK *****
37042:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
37042:  *
37042:  * The contents of this file are subject to the Mozilla Public License Version
37042:  * 1.1 (the "License"); you may not use this file except in compliance with
37042:  * the License. You may obtain a copy of the License at
37042:  * http://www.mozilla.org/MPL/
37042:  *
37042:  * Software distributed under the License is distributed on an "AS IS" basis,
37042:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
37042:  * for the specific language governing rights and limitations under the
37042:  * License.
37042:  *
37042:  * The Original Code is Mozilla WebGL impl
37042:  *
37042:  * The Initial Developer of the Original Code is
39422:  *   Mozilla Foundation
37042:  * Portions created by the Initial Developer are Copyright (C) 2009
37042:  * the Initial Developer. All Rights Reserved.
37042:  *
37042:  * Contributor(s):
37042:  *   Vladimir Vukicevic <vladimir@pobox.com>
37042:  *
37042:  * Alternatively, the contents of this file may be used under the terms of
37042:  * either of the GNU General Public License Version 2 or later (the "GPL"),
37042:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
37042:  * in which case the provisions of the GPL or the LGPL are applicable instead
37042:  * of those above. If you wish to allow use of your version of this file only
37042:  * under the terms of either the GPL or the LGPL, and not to allow others to
37042:  * use your version of this file under the terms of the MPL, indicate your
37042:  * decision by deleting the provisions above and replace them with the notice
37042:  * and other provisions required by the GPL or the LGPL. If you do not delete
37042:  * the provisions above, a recipient may use your version of this file under
37042:  * the terms of any one of the MPL, the GPL or the LGPL.
37042:  *
37042:  * ***** END LICENSE BLOCK ***** */
37042: 
37042: #ifndef jstypedarray_h
37042: #define jstypedarray_h
37042: 
37042: #include "jsapi.h"
37042: 
37042: typedef struct JSProperty JSProperty;
37042: 
37042: namespace js {
37042: 
37042: /*
37042:  * ArrayBuffer
37042:  *
37042:  * This class holds the underlying raw buffer that the TypedArray
37042:  * subclasses access.  It can be created explicitly and passed to a
37042:  * TypedArray subclass, or can be created implicitly by constructing a
37042:  * TypedArray with a size.
37042:  */
37042: struct JS_FRIEND_API(ArrayBuffer) {
37042:     static JSClass jsclass;
37042:     static JSPropertySpec jsprops[];
37042: 
37042:     static JSBool prop_getByteLength(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
37042:     static void class_finalize(JSContext *cx, JSObject *obj);
37042: 
37042:     static JSBool class_constructor(JSContext *cx, JSObject *obj,
37042:                                     uintN argc, jsval *argv, jsval *rval);
37042: 
40636:     static bool create(JSContext *cx, JSObject *obj, uintN argc,
40636:                        jsval *argv, jsval *rval);
40636: 
37042:     static ArrayBuffer *fromJSObject(JSObject *obj);
37042: 
37042:     ArrayBuffer()
37042:         : data(0), byteLength()
37042:     {
37042:     }
37042: 
37042:     ~ArrayBuffer();
37042: 
37042:     bool allocateStorage(JSContext *cx, uint32 bytes);
37042:     void freeStorage(JSContext *cx);
37042: 
37042:     void *offsetData(uint32 offs) {
37042:         return (void*) (((intptr_t)data) + offs);
37042:     }
37042: 
37042:     void *data;
37042:     uint32 byteLength;
37042: };
37042: 
37042: /*
37042:  * TypedArray
37042:  *
37042:  * The non-templated base class for the specific typed implementations.
37042:  * This class holds all the member variables that are used by
37042:  * the subclasses.
37042:  */
37042: 
37042: struct JS_FRIEND_API(TypedArray) {
37042:     enum {
37042:         TYPE_INT8 = 0,
37042:         TYPE_UINT8,
37042:         TYPE_INT16,
37042:         TYPE_UINT16,
37042:         TYPE_INT32,
37042:         TYPE_UINT32,
37042:         TYPE_FLOAT32,
38512:         TYPE_FLOAT64,
38514: 
38514:         /*
38514:          * Special type that's a uint8, but assignments are clamped to 0 .. 255.
38514:          * Treat the raw data type as a uint8.
38514:          */
38514:         TYPE_UINT8_CLAMPED,
38514: 
37042:         TYPE_MAX
37042:     };
37042: 
37042:     // and MUST NOT be used to construct new objects.
37042:     static JSClass fastClasses[TYPE_MAX];
37042: 
37042:     // These are the slow/original classes, used
37042:     // fo constructing new objects
37042:     static JSClass slowClasses[TYPE_MAX];
37042: 
37042:     static JSPropertySpec jsprops[];
37042: 
37042:     static TypedArray *fromJSObject(JSObject *obj);
37042: 
37042:     static JSBool prop_getBuffer(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
37042:     static JSBool prop_getByteOffset(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
37042:     static JSBool prop_getByteLength(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
37042:     static JSBool prop_getLength(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
37042: 
37042:     static JSBool obj_lookupProperty(JSContext *cx, JSObject *obj, jsid id,
37042:                                      JSObject **objp, JSProperty **propp);
37042: 
37042:     static void obj_dropProperty(JSContext *cx, JSObject *obj, JSProperty *prop);
37042: 
37042:     static void obj_trace(JSTracer *trc, JSObject *obj);
37042: 
37042:     static JSBool obj_getAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
37042:                                     uintN *attrsp);
37042: 
37042:     static JSBool obj_setAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
37042:                                     uintN *attrsp);
37042: 
37042:     static int32 lengthOffset() { return offsetof(TypedArray, length); }
37042:     static int32 dataOffset() { return offsetof(TypedArray, data); }
37042:     static int32 typeOffset() { return offsetof(TypedArray, type); }
37042: 
37042:   public:
37042:     TypedArray() : buffer(0) { }
37042: 
37042:     bool isArrayIndex(JSContext *cx, jsid id, jsuint *ip = NULL);
37042:     bool valid() { return buffer != 0; }
37042: 
37042:     ArrayBuffer *buffer;
37042:     JSObject *bufferJS;
37042:     uint32 byteOffset;
37042:     uint32 byteLength;
37042:     uint32 length;
37042:     uint32 type;
37042: 
37042:     void *data;
37042: };
37042: 
37042: } // namespace js
37042: 
37042: /* Friend API methods */
37042: 
37042: JS_BEGIN_EXTERN_C
37042: 
37416: JS_FRIEND_API(JSObject *)
37042: js_InitTypedArrayClasses(JSContext *cx, JSObject *obj);
37042: 
37042: JS_FRIEND_API(JSBool)
37042: js_IsTypedArray(JSObject *obj);
37042: 
37042: JS_FRIEND_API(JSBool)
37042: js_IsArrayBuffer(JSObject *obj);
37042: 
37042: JS_FRIEND_API(JSObject *)
37042: js_CreateArrayBuffer(JSContext *cx, jsuint nbytes);
37042: 
37042: /*
37042:  * Create a new typed array of type atype (one of the TypedArray
37042:  * enumerant values above), with nelements elements.
37042:  */
37042: JS_FRIEND_API(JSObject *)
37042: js_CreateTypedArray(JSContext *cx, jsint atype, jsuint nelements);
37042: 
37042: /*
37042:  * Create a new typed array of type atype (one of the TypedArray
37042:  * enumerant values above), and copy in values from the given JSObject,
37042:  * which must either be a typed array or an array-like object.
37042:  */
37042: JS_FRIEND_API(JSObject *)
37042: js_CreateTypedArrayWithArray(JSContext *cx, jsint atype, JSObject *arrayArg);
37042: 
37042: /*
37042:  * Create a new typed array of type atype (one of the TypedArray
37042:  * enumerant values above), using a given ArrayBuffer for storage.
37042:  * The byteoffset and length values are optional; if -1 is passed, an
37042:  * offset of 0 and enough elements to use up the remainder of the byte
37042:  * array are used as the default values.
37042:  */
37042: JS_FRIEND_API(JSObject *)
37042: js_CreateTypedArrayWithBuffer(JSContext *cx, jsint atype, JSObject *bufArg,
37042:                               jsint byteoffset, jsint length);
37042: 
40555: /*
40555:  * Reparent a typed array to a new scope. This should only be used to reparent
40555:  * a typed array that does not share its underlying ArrayBuffer with another
40555:  * typed array to avoid having a parent mismatch with the other typed array and
40555:  * its ArrayBuffer.
40555:  */
40555: JS_FRIEND_API(JSBool)
40555: js_ReparentTypedArrayToScope(JSContext *cx, JSObject *obj, JSObject *scope);
40555: 
37042: JS_END_EXTERN_C
37042: 
37042: #endif /* jstypedarray_h */
