 35778: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 35778:  * vim: sw=4 ts=4 et :
 35778:  */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 35778: 
 35778: #include "mozilla/ipc/AsyncChannel.h"
 37884: #include "mozilla/ipc/BrowserProcessSubThread.h"
 36140: #include "mozilla/ipc/ProtocolUtils.h"
 35778: 
 35778: #include "nsDebug.h"
 36081: #include "nsTraceRefcnt.h"
 35869: #include "nsXULAppAPI.h"
 35778: 
 69144: using mozilla::MonitorAutoLock;
 35882: 
 35778: template<>
 35778: struct RunnableMethodTraits<mozilla::ipc::AsyncChannel>
 35778: {
 35778:     static void RetainCallee(mozilla::ipc::AsyncChannel* obj) { }
 35778:     static void ReleaseCallee(mozilla::ipc::AsyncChannel* obj) { }
 35778: };
 35778: 
 83464: template<>
 83464: struct RunnableMethodTraits<mozilla::ipc::AsyncChannel::ProcessLink>
 83464: {
 83464:     static void RetainCallee(mozilla::ipc::AsyncChannel::ProcessLink* obj) { }
 83464:     static void ReleaseCallee(mozilla::ipc::AsyncChannel::ProcessLink* obj) { }
 83464: };
 83464: 
 41175: // We rely on invariants about the lifetime of the transport:
 41175: //
 41175: //  - outlives this AsyncChannel
 41175: //  - deleted on the IO thread
 41175: //
 41175: // These invariants allow us to send messages directly through the
 41175: // transport without having to worry about orphaned Send() tasks on
 41175: // the IO thread touching AsyncChannel memory after it's been deleted
 41175: // on the worker thread.  We also don't need to refcount the
 41175: // Transport, because whatever task triggers its deletion only runs on
 41175: // the IO thread, and only runs after this AsyncChannel is done with
 41175: // the Transport.
 41175: template<>
 41175: struct RunnableMethodTraits<mozilla::ipc::AsyncChannel::Transport>
 41175: {
 41175:     static void RetainCallee(mozilla::ipc::AsyncChannel::Transport* obj) { }
 41175:     static void ReleaseCallee(mozilla::ipc::AsyncChannel::Transport* obj) { }
 41175: };
 41175: 
 38099: namespace {
 38099: 
 38099: // This is an async message
 38099: class GoodbyeMessage : public IPC::Message
 38099: {
 38099: public:
 38099:     enum { ID = GOODBYE_MESSAGE_TYPE };
 38099:     GoodbyeMessage() :
 38099:         IPC::Message(MSG_ROUTING_NONE, ID, PRIORITY_NORMAL)
 38099:     {
 38099:     }
 38099:     // XXX not much point in implementing this; maybe could help with
 38099:     // debugging?
 38099:     static bool Read(const Message* msg)
 38099:     {
 38099:         return true;
 38099:     }
 38099:     void Log(const std::string& aPrefix,
 38099:              FILE* aOutf) const
 38099:     {
 38099:         fputs("(special `Goodbye' message)", aOutf);
 38099:     }
 38099: };
 38099: 
 38099: } // namespace <anon>
 38099: 
 35778: namespace mozilla {
 35778: namespace ipc {
 35778: 
 83464: AsyncChannel::Link::Link(AsyncChannel *aChan)
 83464:     : mChan(aChan)
 36078: {
 36078: }
 36078: 
 83464: AsyncChannel::Link::~Link()
 36078: {
 83464:     mChan = 0;
 36078: }
 36078: 
 83464: AsyncChannel::ProcessLink::ProcessLink(AsyncChannel *aChan)
 83464:     : Link(aChan)
 83464:     , mExistingListener(NULL)
 35778: {
 83464: }
 83464: 
 83464: AsyncChannel::ProcessLink::~ProcessLink()
 83464: {
 83464:     mIOLoop = 0;
 83464:     if (mTransport) {
 83464:         mTransport->set_listener(0);
 83464:         
 83464:         // we only hold a weak ref to the transport, which is "owned"
 83464:         // by GeckoChildProcess/GeckoThread
 83464:         mTransport = 0;
 83464:     }
 83464: }
 83464: 
 83464: void 
 83464: AsyncChannel::ProcessLink::Open(mozilla::ipc::Transport* aTransport,
 83464:                                 MessageLoop *aIOLoop,
 83464:                                 Side aSide)
 83464: {
 35778:     NS_PRECONDITION(aTransport, "need transport layer");
 35778: 
 35778:     // FIXME need to check for valid channel
 35778: 
 35778:     mTransport = aTransport;
 46795:     mExistingListener = mTransport->set_listener(this);
 35778: 
 35779:     // FIXME figure out whether we're in parent or child, grab IO loop
 35779:     // appropriately
 35778:     bool needOpen = true;
 71237:     if(aIOLoop) {
 71237:         // We're a child or using the new arguments.  Either way, we
 71237:         // need an open.
 71237:         needOpen = true;
 83464:         mChan->mChild = (aSide == AsyncChannel::Unknown) || (aSide == AsyncChannel::Child);
 71237:     } else {
 71237:         NS_PRECONDITION(aSide == Unknown, "expected default side arg");
 71237: 
 35779:         // parent
 83464:         mChan->mChild = false;
 35778:         needOpen = false;
 41060:         aIOLoop = XRE_GetIOMessageLoop();
 35779:         // FIXME assuming that the parent waits for the OnConnected event.
 35779:         // FIXME see GeckoChildProcessHost.cpp.  bad assumption!
 83464:         mChan->mChannelState = ChannelConnected;
 35778:     }
 35778: 
 35778:     mIOLoop = aIOLoop;
 35778: 
 35778:     NS_ASSERTION(mIOLoop, "need an IO loop");
 83464:     NS_ASSERTION(mChan->mWorkerLoop, "need a worker loop");
 35778: 
 35882:     if (needOpen) {             // child process
 83464:         MonitorAutoLock lock(*mChan->mMonitor);
 35882: 
 35778:         mIOLoop->PostTask(FROM_HERE, 
 83464:                           NewRunnableMethod(this, &ProcessLink::OnChannelOpened));
 35882: 
 35882:         // FIXME/cjones: handle errors
 83464:         while (mChan->mChannelState != ChannelConnected) {
 83464:             mChan->mMonitor->Wait();
 83464:         }
 35882:     }
 35778: }
 35778: 
 83464: void
 83464: AsyncChannel::ProcessLink::EchoMessage(Message *msg)
 83464: {
 83465:     mChan->AssertWorkerThread();
 83465:     mChan->mMonitor->AssertCurrentThreadOwns();
 83465: 
 83464:     // NB: Go through this OnMessageReceived indirection so that
 83464:     // echoing this message does the right thing for SyncChannel
 83464:     // and RPCChannel too
 83464:     mIOLoop->PostTask(
 83464:         FROM_HERE,
 83464:         NewRunnableMethod(this, &ProcessLink::OnEchoMessage, msg));
 83464:     // OnEchoMessage takes ownership of |msg|
 83464: }
 83464: 
 83464: void
 83464: AsyncChannel::ProcessLink::SendMessage(Message *msg)
 83464: {
 83464:     mChan->AssertWorkerThread();
 83465:     mChan->mMonitor->AssertCurrentThreadOwns();
 83465: 
 83464:     mIOLoop->PostTask(
 83464:         FROM_HERE,
 83464:         NewRunnableMethod(mTransport, &Transport::Send, msg));
 83464: }
 83464: 
 83464: void
 83464: AsyncChannel::ProcessLink::SendClose()
 83464: {
 83464:     mChan->AssertWorkerThread();
 83464:     mChan->mMonitor->AssertCurrentThreadOwns();
 83464: 
 83464:     mIOLoop->PostTask(
 83464:         FROM_HERE, NewRunnableMethod(this, &ProcessLink::OnCloseChannel));
 83464: }
 83464: 
 83465: AsyncChannel::ThreadLink::ThreadLink(AsyncChannel *aChan,
 83465:                                      AsyncChannel *aTargetChan)
 83465:     : Link(aChan),
 83465:       mTargetChan(aTargetChan)
 83465: {
 83465: }
 83465: 
 83465: AsyncChannel::ThreadLink::~ThreadLink()
 83465: {
 83465:     mTargetChan = 0;
 83465: }
 83465: 
 83465: void
 83465: AsyncChannel::ThreadLink::EchoMessage(Message *msg)
 83465: {
 83465:     mChan->AssertWorkerThread();
 83465:     mChan->mMonitor->AssertCurrentThreadOwns();
 83465: 
 83465:     mChan->OnMessageReceivedFromLink(*msg);
 83465:     delete msg;
 83465: }
 83465: 
 83465: void
 83465: AsyncChannel::ThreadLink::SendMessage(Message *msg)
 83465: {
 83465:     mChan->AssertWorkerThread();
 83465:     mChan->mMonitor->AssertCurrentThreadOwns();
 83465: 
 83465:     mTargetChan->OnMessageReceivedFromLink(*msg);
 83465:     delete msg;
 83465: }
 83465: 
 83465: void
 83465: AsyncChannel::ThreadLink::SendClose()
 83465: {
 83465:     mChan->AssertWorkerThread();
 83465:     mChan->mMonitor->AssertCurrentThreadOwns();
 83465: 
 83465:     mChan->mChannelState = ChannelClosed;
 83465: 
 83465:     // In a ProcessLink, we would close our half the channel.  This
 83465:     // would show up on the other side as an error on the I/O thread.
 83465:     // The I/O thread would then invoke OnChannelErrorFromLink().
 83465:     // As usual, we skip that process and just invoke the
 83465:     // OnChannelErrorFromLink() method directly.
 83465:     mTargetChan->OnChannelErrorFromLink();
 83465: }
 83465: 
 83464: AsyncChannel::AsyncChannel(AsyncListener* aListener)
 83464:   : mListener(aListener),
 83464:     mChannelState(ChannelClosed),
 83464:     mWorkerLoop(),
 83464:     mChild(false),
 83464:     mChannelErrorTask(NULL),
 83464:     mLink(NULL)
 83464: {
 83464:     MOZ_COUNT_CTOR(AsyncChannel);
 83464: }
 83464: 
 83464: AsyncChannel::~AsyncChannel()
 83464: {
 83464:     MOZ_COUNT_DTOR(AsyncChannel);
 83464:     Clear();
 83464: }
 83464: 
 83464: bool
 83464: AsyncChannel::Open(Transport* aTransport,
 83464:                    MessageLoop* aIOLoop,
 83464:                    AsyncChannel::Side aSide)
 83464: {
 83464:     ProcessLink *link;
 83464:     NS_PRECONDITION(!mLink, "Open() called > once");
 83464:     mMonitor = new RefCountedMonitor();
 83464:     mWorkerLoop = MessageLoop::current();
 83464:     mLink = link = new ProcessLink(this);
 83464:     link->Open(aTransport, aIOLoop, aSide); // n.b.: sets mChild
 35778:     return true;
 35778: }
 35778: 
 83465: /* Opens a connection to another thread in the same process.
 83465: 
 83465:    This handshake proceeds as follows:
 83465:    - Let A be the thread initiating the process (either child or parent)
 83465:      and B be the other thread.
 83465:    - A spawns thread for B, obtaining B's message loop
 83465:    - A creates ProtocolChild and ProtocolParent instances.
 83465:      Let PA be the one appropriate to A and PB the side for B.
 83465:    - A invokes PA->Open(PB, ...):
 83465:      - set state to mChannelOpening
 83465:      - this will place a work item in B's worker loop (see next bullet)
 83465:        and then spins until PB->mChannelState becomes mChannelConnected
 83465:      - meanwhile, on PB's worker loop, the work item is removed and:
 83465:        - invokes PB->SlaveOpen(PA, ...):
 83465:          - sets its state and that of PA to Connected
 83465:  */
 83465: bool
 83465: AsyncChannel::Open(AsyncChannel *aTargetChan, 
 83465:                    MessageLoop *aTargetLoop,
 83465:                    AsyncChannel::Side aSide)
 83465: {
 83465:     NS_PRECONDITION(aTargetChan, "Need a target channel");
 83465:     NS_PRECONDITION(ChannelClosed == mChannelState, "Not currently closed");
 83465: 
 83465:     CommonThreadOpenInit(aTargetChan, aSide);
 83465: 
 83465:     Side oppSide = Unknown;
 83465:     switch(aSide) {
 83465:       case Child: oppSide = Parent; break;
 83465:       case Parent: oppSide = Child; break;
 83465:       case Unknown: break;
 83465:     }
 83465: 
 83465:     mMonitor = new RefCountedMonitor();
 83465: 
 95832:     MonitorAutoLock lock(*mMonitor);
 95832:     mChannelState = ChannelOpening;
 83465:     aTargetLoop->PostTask(
 83465:         FROM_HERE,
 83465:         NewRunnableMethod(aTargetChan, &AsyncChannel::OnOpenAsSlave,
 83465:                           this, oppSide));
 83465: 
 83465:     while (ChannelOpening == mChannelState)
 83465:         mMonitor->Wait();
 83465:     NS_ASSERTION(ChannelConnected == mChannelState, "not connected when awoken");
 83465:     return (ChannelConnected == mChannelState);
 83465: }
 83465: 
 83465: void 
 83465: AsyncChannel::CommonThreadOpenInit(AsyncChannel *aTargetChan, Side aSide)
 83465: {
 83465:     mWorkerLoop = MessageLoop::current();
 83465:     mLink = new ThreadLink(this, aTargetChan);
 83465:     mChild = (aSide == Child); 
 83465: }
 83465: 
 83465: // Invoked when the other side has begun the open.
 83465: void
 83465: AsyncChannel::OnOpenAsSlave(AsyncChannel *aTargetChan, Side aSide)
 83465: {
 83465:     NS_PRECONDITION(ChannelClosed == mChannelState, 
 83465:                     "Not currently closed");
 83465:     NS_PRECONDITION(ChannelOpening == aTargetChan->mChannelState,
 83465:                     "Target channel not in the process of opening");
 83465:     
 83465:     CommonThreadOpenInit(aTargetChan, aSide);
 83465:     mMonitor = aTargetChan->mMonitor;
 83465: 
 83465:     MonitorAutoLock lock(*mMonitor);
 83465:     NS_ASSERTION(ChannelOpening == aTargetChan->mChannelState,
 83465:                  "Target channel not in the process of opening");
 83465:     mChannelState = ChannelConnected;
 83465:     aTargetChan->mChannelState = ChannelConnected;
 83465:     aTargetChan->mMonitor->Notify();
 83465: }
 83465: 
 35778: void
 35778: AsyncChannel::Close()
 35778: {
 38106:     AssertWorkerThread();
 38106: 
 36140:     {
 83464:         // n.b.: We increase the ref count of monitor temporarily
 83464:         //       for the duration of this block.  Otherwise, the
 83464:         //       function NotifyMaybeChannelError() will call
 83464:         //       ::Clear() which can free the monitor.
 83464:         nsRefPtr<RefCountedMonitor> monitor(mMonitor);
 83464:         MonitorAutoLock lock(*monitor);
 36063: 
 38106:         if (ChannelError == mChannelState ||
 38106:             ChannelTimeout == mChannelState) {
 37198:             // See bug 538586: if the listener gets deleted while the
 37198:             // IO thread's NotifyChannelError event is still enqueued
 37198:             // and subsequently deletes us, then the error event will
 37198:             // also be deleted and the listener will never be notified
 37198:             // of the channel error.
 37198:             if (mListener) {
 83464:                 MonitorAutoUnlock unlock(*monitor);
 37198:                 NotifyMaybeChannelError();
 37198:             }
 36607:             return;
 37198:         }
 36607: 
 36140:         if (ChannelConnected != mChannelState)
 36140:             // XXX be strict about this until there's a compelling reason
 36140:             // to relax
 36140:             NS_RUNTIMEABORT("Close() called on closed channel!");
 36140: 
 36063:         AssertWorkerThread();
 36063: 
 36140:         // notify the other side that we're about to close our socket
 38099:         SendSpecialMessage(new GoodbyeMessage());
 36140: 
 38106:         SynchronouslyClose();
 38106:     }
 36140: 
 38299:     NotifyChannelClosed();
 38106: }
 38106: 
 38106: void 
 38106: AsyncChannel::SynchronouslyClose()
 38106: {
 38106:     AssertWorkerThread();
 83464:     mMonitor->AssertCurrentThreadOwns();
 83464:     mLink->SendClose();
 38106:     while (ChannelClosed != mChannelState)
 83464:         mMonitor->Wait();
 35778: }
 35778: 
 35778: bool
 83006: AsyncChannel::Send(Message* _msg)
 35778: {
 83006:     nsAutoPtr<Message> msg(_msg);
 35971:     AssertWorkerThread();
 83464:     mMonitor->AssertNotCurrentThreadOwns();
 35940:     NS_ABORT_IF_FALSE(MSG_ROUTING_NONE != msg->routing_id(), "need a route");
 35940: 
 35977:     {
 83464:         MonitorAutoLock lock(*mMonitor);
 35977: 
 36015:         if (!Connected()) {
 36015:             ReportConnectionError("AsyncChannel");
 35940:             return false;
 36015:         }
 35779: 
 83464:         mLink->SendMessage(msg.forget());
 35977:     }
 35977: 
 35778:     return true;
 35778: }
 35778: 
 71251: bool
 83006: AsyncChannel::Echo(Message* _msg)
 71251: {
 83006:     nsAutoPtr<Message> msg(_msg);
 71251:     AssertWorkerThread();
 83464:     mMonitor->AssertNotCurrentThreadOwns();
 71251:     NS_ABORT_IF_FALSE(MSG_ROUTING_NONE != msg->routing_id(), "need a route");
 71251: 
 71251:     {
 83464:         MonitorAutoLock lock(*mMonitor);
 71251: 
 71251:         if (!Connected()) {
 71251:             ReportConnectionError("AsyncChannel");
 71251:             return false;
 71251:         }
 71251: 
 83464:         mLink->EchoMessage(msg.forget());
 71251:     }
 71251: 
 71251:     return true;
 71251: }
 71251: 
 35778: void
 35778: AsyncChannel::OnDispatchMessage(const Message& msg)
 35778: {
 35971:     AssertWorkerThread();
 35778:     NS_ASSERTION(!msg.is_reply(), "can't process replies here");
 35778:     NS_ASSERTION(!(msg.is_sync() || msg.is_rpc()), "async dispatch only");
 35778: 
 38099:     if (MSG_ROUTING_NONE == msg.routing_id()) {
 38099:         if (!OnSpecialMessage(msg.type(), msg))
 38099:             // XXX real error handling
 38099:             NS_RUNTIMEABORT("unhandled special message!");
 36140:         return;
 38099:     }
 36140: 
 36140:     // it's OK to dispatch messages if the channel is closed/error'd,
 36140:     // since we don't have a reply to send back
 36140: 
 36015:     (void)MaybeHandleError(mListener->OnMessageReceived(msg), "AsyncChannel");
 36015: }
 35778: 
 38099: bool
 38099: AsyncChannel::OnSpecialMessage(uint16 id, const Message& msg)
 36140: {
 38099:     return false;
 36140: }
 36140: 
 36140: void
 41379: AsyncChannel::SendSpecialMessage(Message* msg) const
 36140: {
 36140:     AssertWorkerThread();
 83464:     mLink->SendMessage(msg);
 36140: }
 36140: 
 36140: void
 39311: AsyncChannel::OnNotifyMaybeChannelError()
 39311: {
 39311:     AssertWorkerThread();
 83464:     mMonitor->AssertNotCurrentThreadOwns();
 39311: 
103778:     mChannelErrorTask = NULL;
103778: 
 69144:     // OnChannelError holds mMonitor when it posts this task and this
 39311:     // task cannot be allowed to run until OnChannelError has
 39311:     // exited. We enforce that order by grabbing the mutex here which
 39311:     // should only continue once OnChannelError has completed.
 39311:     {
 83464:         MonitorAutoLock lock(*mMonitor);
 39311:         // nothing to do here
 39311:     }
 39311: 
 39311:     if (ShouldDeferNotifyMaybeError()) {
 39311:         mChannelErrorTask =
 39311:             NewRunnableMethod(this, &AsyncChannel::OnNotifyMaybeChannelError);
 39311:         // 10 ms delay is completely arbitrary
 39311:         mWorkerLoop->PostDelayedTask(FROM_HERE, mChannelErrorTask, 10);
 39311:         return;
 39311:     }
 39311: 
 39311:     NotifyMaybeChannelError();
 39311: }
 39311: 
 39311: void
 36140: AsyncChannel::NotifyChannelClosed()
 36140: {
 83464:     mMonitor->AssertNotCurrentThreadOwns();
 38299: 
 36140:     if (ChannelClosed != mChannelState)
 36140:         NS_RUNTIMEABORT("channel should have been closed!");
 36140: 
 36140:     // OK, the IO thread just closed the channel normally.  Let the
 36140:     // listener know about it.
 36140:     mListener->OnChannelClose();
 38299: 
 36140:     Clear();
 36140: }
 36140: 
 36140: void
 36140: AsyncChannel::NotifyMaybeChannelError()
 36140: {
 83464:     mMonitor->AssertNotCurrentThreadOwns();
 38299: 
 36140:     // TODO sort out Close() on this side racing with Close() on the
 36140:     // other side
 36140:     if (ChannelClosing == mChannelState) {
 36140:         // the channel closed, but we received a "Goodbye" message
 36140:         // warning us about it. no worries
 36140:         mChannelState = ChannelClosed;
 38299:         NotifyChannelClosed();
 38299:         return;
 36140:     }
 36140: 
 36140:     // Oops, error!  Let the listener know about it.
 36140:     mChannelState = ChannelError;
 36140:     mListener->OnChannelError();
 36140: 
 36140:     Clear();
 36140: }
 36140: 
 36140: void
 36140: AsyncChannel::Clear()
 36140: {
 36140:     mListener = 0;
 36140:     mWorkerLoop = 0;
 36140: 
 83464:     delete mLink;
 83464:     mLink = 0;
 83464:     mMonitor = 0;
 36140: 
 36607:     if (mChannelErrorTask) {
 36607:         mChannelErrorTask->Cancel();
 36607:         mChannelErrorTask = NULL;
 36607:     }
 36140: }
 36140: 
 63003: static void
 63003: PrintErrorMessage(bool isChild, const char* channelName, const char* msg)
 63003: {
 63003: #ifdef DEBUG
 63003:     fprintf(stderr, "\n###!!! [%s][%s] Error: %s\n\n",
 63003:             isChild ? "Child" : "Parent", channelName, msg);
 63003: #endif
 63003: }
 63003: 
 36015: bool
 36015: AsyncChannel::MaybeHandleError(Result code, const char* channelName)
 36015: {
 36015:     if (MsgProcessed == code)
 36015:         return true;
 36015: 
 36015:     const char* errorMsg;
 36015:     switch (code) {
 35786:     case MsgNotKnown:
 36015:         errorMsg = "Unknown message: not processed";
 36015:         break;
 35786:     case MsgNotAllowed:
 36015:         errorMsg = "Message not allowed: cannot be sent/recvd in this state";
 36015:         break;
 35786:     case MsgPayloadError:
 36015:         errorMsg = "Payload error: message could not be deserialized";
 36015:         break;
 42559:     case MsgProcessingError:
 42559:         errorMsg = "Processing error: message was deserialized, but the handler returned false (indicating failure)";
 47262:         break;
 35786:     case MsgRouteError:
 36015:         errorMsg = "Route error: message sent to unknown actor ID";
 36015:         break;
 35786:     case MsgValueError:
 36015:         errorMsg = "Value error: message was deserialized, but contained an illegal value";
 36015:         break;
 35778: 
 35778:     default:
 36140:         NS_RUNTIMEABORT("unknown Result code");
 36015:         return false;
 35778:     }
 36015: 
 63003:     PrintErrorMessage(mChild, channelName, errorMsg);
 54001: 
 54001:     mListener->OnProcessingError(code);
 54001: 
 36015:     return false;
 36015: }
 36015: 
 36015: void
 41379: AsyncChannel::ReportConnectionError(const char* channelName) const
 36015: {
 36015:     const char* errorMsg;
 36015:     switch (mChannelState) {
 36015:     case ChannelClosed:
 36015:         errorMsg = "Closed channel: cannot send/recv";
 36015:         break;
 36015:     case ChannelOpening:
 36015:         errorMsg = "Opening channel: not yet ready for send/recv";
 36015:         break;
 38106:     case ChannelTimeout:
 38106:         errorMsg = "Channel timeout: cannot send/recv";
 47263:         break;
 42342:     case ChannelClosing:
 42342:         errorMsg = "Channel closing: too late to send/recv, messages will be lost";
 47263:         break;
 36015:     case ChannelError:
 36015:         errorMsg = "Channel error: cannot send/recv";
 36015:         break;
 36015: 
 36015:     default:
 42342:         NS_RUNTIMEABORT("unreached");
 36015:     }
 36015: 
 63003:     PrintErrorMessage(mChild, channelName, errorMsg);
 54001: 
 54001:     mListener->OnProcessingError(MsgDropped);
 35778: }
 35778: 
 83464: void
 83464: AsyncChannel::DispatchOnChannelConnected(int32 peer_pid)
 83464: {
 83464:     AssertWorkerThread();
 83464:     if (mListener)
 83464:         mListener->OnChannelConnected(peer_pid);
 83464: }
 83464: 
 35778: //
 36140: // The methods below run in the context of the IO thread
 35778: //
 35778: 
 35778: void
 83464: AsyncChannel::ProcessLink::OnMessageReceived(const Message& msg)
 35778: {
 35971:     AssertIOThread();
 83464:     NS_ASSERTION(mChan->mChannelState != ChannelError, "Shouldn't get here!");
 83464:     MonitorAutoLock lock(*mChan->mMonitor);
 83464:     mChan->OnMessageReceivedFromLink(msg);
 83464: }
 35869: 
 83464: void
 83464: AsyncChannel::ProcessLink::OnEchoMessage(Message* msg)
 83464: {
 83464:     AssertIOThread();
 83464:     OnMessageReceived(*msg);
 83464:     delete msg;
 83464: }
 83464: 
 83464: void
 83464: AsyncChannel::ProcessLink::OnChannelOpened()
 83464: {
 83464:     mChan->AssertLinkThread();
 83464:     {
 83464:         MonitorAutoLock lock(*mChan->mMonitor);
 83464:         mChan->mChannelState = ChannelOpening;
 83464:     }
 83464:     /*assert*/mTransport->Connect();
 83464: }
 83464: 
 83464: void
 83464: AsyncChannel::ProcessLink::OnChannelConnected(int32 peer_pid)
 83464: {
 83464:     AssertIOThread();
 83464: 
 83464:     {
 83464:         MonitorAutoLock lock(*mChan->mMonitor);
 83464:         mChan->mChannelState = ChannelConnected;
 83464:         mChan->mMonitor->Notify();
 83464:     }
 83464: 
 83464:     if(mExistingListener)
 83464:         mExistingListener->OnChannelConnected(peer_pid);
 83464: 
 83464:     mChan->mWorkerLoop->PostTask(
 83464:         FROM_HERE, 
 83464:         NewRunnableMethod(mChan, 
 83464:                           &AsyncChannel::DispatchOnChannelConnected, 
 83464:                           peer_pid));
 83464: }
 83464: 
 83464: void
 83464: AsyncChannel::ProcessLink::OnChannelError()
 83464: {
 83464:     AssertIOThread();
 83464:     MonitorAutoLock lock(*mChan->mMonitor);
 83464:     mChan->OnChannelErrorFromLink();
 83464: }
 83464: 
 83464: void
 83464: AsyncChannel::ProcessLink::OnCloseChannel()
 83464: {
 83464:     AssertIOThread();
 83464: 
 83464:     mTransport->Close();
 83464: 
 83464:     MonitorAutoLock lock(*mChan->mMonitor);
 83464:     mChan->mChannelState = ChannelClosed;
 83464:     mChan->mMonitor->Notify();
 83464: }
 83464: 
 83464: //
 83464: // The methods below run in the context of the link thread
 83464: //
 83464: 
 83464: void
 83464: AsyncChannel::OnMessageReceivedFromLink(const Message& msg)
 83464: {
 83464:     AssertLinkThread();
 83464:     mMonitor->AssertCurrentThreadOwns();
 39261: 
 39261:     if (!MaybeInterceptSpecialIOMessage(msg))
 35778:         // wake up the worker, there's work to do
 35977:         mWorkerLoop->PostTask(
 35977:             FROM_HERE,
 35977:             NewRunnableMethod(this, &AsyncChannel::OnDispatchMessage, msg));
 35778: }
 35778: 
 35778: void
 83464: AsyncChannel::OnChannelErrorFromLink()
 71251: {
 83464:     AssertLinkThread();
 83464:     mMonitor->AssertCurrentThreadOwns();
 36140: 
 36140:     if (ChannelClosing != mChannelState)
 35778:         mChannelState = ChannelError;
 35869: 
 39611:     PostErrorNotifyTask();
 39611: }
 39611: 
 39611: void
103778: AsyncChannel::CloseWithError()
103778: {
103778:     AssertWorkerThread();
103778: 
103778:     MonitorAutoLock lock(*mMonitor);
103778:     if (ChannelConnected != mChannelState) {
103778:         return;
103778:     }
103778:     SynchronouslyClose();
103778:     mChannelState = ChannelError;
103778:     PostErrorNotifyTask();
103778: }
103778: 
103778: void
 39611: AsyncChannel::PostErrorNotifyTask()
 39611: {
 83464:     mMonitor->AssertCurrentThreadOwns();
 39611: 
103778:     if (mChannelErrorTask)
103778:         return;
 36607: 
 38316:     // This must be the last code that runs on this thread!
 36607:     mChannelErrorTask =
 39311:         NewRunnableMethod(this, &AsyncChannel::OnNotifyMaybeChannelError);
 36607:     mWorkerLoop->PostTask(FROM_HERE, mChannelErrorTask);
 35778: }
 35778: 
 39261: bool
 39261: AsyncChannel::MaybeInterceptSpecialIOMessage(const Message& msg)
 39261: {
 83464:     AssertLinkThread();
 83464:     mMonitor->AssertCurrentThreadOwns();
 39261: 
 39261:     if (MSG_ROUTING_NONE == msg.routing_id()
 39261:         && GOODBYE_MESSAGE_TYPE == msg.type()) {
 39261:         ProcessGoodbyeMessage();
 39261:         return true;
 39261:     }
 39261:     return false;
 39261: }
 39261: 
 39261: void
 39261: AsyncChannel::ProcessGoodbyeMessage()
 39261: {
 83464:     AssertLinkThread();
 83464:     mMonitor->AssertCurrentThreadOwns();
 39261: 
 39261:     // TODO sort out Close() on this side racing with Close() on the
 39261:     // other side
 39261:     mChannelState = ChannelClosing;
 39261: 
 39261:     printf("NOTE: %s process received `Goodbye', closing down\n",
 39261:            mChild ? "child" : "parent");
 39261: }
 39261: 
 35778: 
 35778: } // namespace ipc
 35778: } // namespace mozilla
