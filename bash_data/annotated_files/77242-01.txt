36152: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
36152:  * vim: sw=2 ts=8 et :
36152:  */
36152: /* ***** BEGIN LICENSE BLOCK *****
36152:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
36152:  *
36152:  * The contents of this file are subject to the Mozilla Public License Version
36152:  * 1.1 (the "License"); you may not use this file except in compliance with
36152:  * the License. You may obtain a copy of the License at
36152:  * http://www.mozilla.org/MPL/
36152:  *
36152:  * Software distributed under the License is distributed on an "AS IS" basis,
36152:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
36152:  * for the specific language governing rights and limitations under the
36152:  * License.
36152:  *
36152:  * The Original Code is Mozilla IPC.
36152:  *
36152:  * The Initial Developer of the Original Code is
36152:  *   The Mozilla Foundation
36152:  * Portions created by the Initial Developer are Copyright (C) 2009
36152:  * the Initial Developer. All Rights Reserved.
36152:  *
36152:  * Contributor(s):
36152:  *   Chris Jones <jones.chris.g@gmail.com>
36152:  *
36152:  * Alternatively, the contents of this file may be used under the terms of
36152:  * either the GNU General Public License Version 2 or later (the "GPL"), or
36152:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
36152:  * in which case the provisions of the GPL or the LGPL are applicable instead
36152:  * of those above. If you wish to allow use of your version of this file only
36152:  * under the terms of either the GPL or the LGPL, and not to allow others to
36152:  * use your version of this file under the terms of the MPL, indicate your
36152:  * decision by deleting the provisions above and replace them with the notice
36152:  * and other provisions required by the GPL or the LGPL. If you do not delete
36152:  * the provisions above, a recipient may use your version of this file under
36152:  * the terms of any one of the MPL, the GPL or the LGPL.
36152:  *
36152:  * ***** END LICENSE BLOCK ***** */
36152: 
36152: #include "Shmem.h"
36152: 
40908: #include "ProtocolUtils.h"
40908: #include "SharedMemoryBasic.h"
40908: #include "SharedMemorySysV.h"
40908: 
36152: #include "nsAutoPtr.h"
72442: #include "mozilla/unused.h"
36152: 
36152: 
40908: namespace mozilla {
40908: namespace ipc {
40908: 
40908: class ShmemCreated : public IPC::Message
40908: {
40908: private:
40908:   typedef Shmem::id_t id_t;
40908: 
40908: public:
40908:   ShmemCreated(int32 routingId,
40908:                const id_t& aIPDLId,
40908:                const size_t& aSize,
40908:                const SharedMemoryBasic::Handle& aHandle) :
40908:     IPC::Message(routingId, SHMEM_CREATED_MESSAGE_TYPE, PRIORITY_NORMAL)
40908:   {
40908:     IPC::WriteParam(this, aIPDLId);
40908:     IPC::WriteParam(this, aSize);
40908:     IPC::WriteParam(this, int32(SharedMemory::TYPE_BASIC)),
40908:     IPC::WriteParam(this, aHandle);
40908:   }
40908: 
40908:   // Instead of a single Read() function, we have ReadInfo() and
40908:   // ReadHandle().  The reason is that the handle type is specific to
40908:   // the shmem type.  These functions should only be called in the
40908:   // order ReadInfo(); ReadHandle();, and only once each.
40908: 
40908:   static bool
40908:   ReadInfo(const Message* msg, void** iter,
40908:            id_t* aIPDLId,
40908:            size_t* aSize,
40908:            SharedMemory::SharedMemoryType* aType)
40908:   {
40908:     if (!IPC::ReadParam(msg, iter, aIPDLId) ||
40908:         !IPC::ReadParam(msg, iter, aSize) ||
40908:         !IPC::ReadParam(msg, iter, reinterpret_cast<int32*>(aType)))
40908:       return false;
40908:     return true;
40908:   }
40908: 
40908:   static bool
40908:   ReadHandle(const Message* msg, void** iter,
40908:              SharedMemoryBasic::Handle* aHandle)
40908:   {
40908:     if (!IPC::ReadParam(msg, iter, aHandle))
40908:       return false;
40908:     msg->EndRead(*iter);
40908:     return true;
40908:   }
40908: 
40908: #ifdef MOZ_HAVE_SHAREDMEMORYSYSV
40908:   ShmemCreated(int32 routingId,
40908:                const id_t& aIPDLId,
40908:                const size_t& aSize,
40908:                const SharedMemorySysV::Handle& aHandle) :
40908:     IPC::Message(routingId, SHMEM_CREATED_MESSAGE_TYPE, PRIORITY_NORMAL)
40908:   {
40908:     IPC::WriteParam(this, aIPDLId);
40908:     IPC::WriteParam(this, aSize);
40908:     IPC::WriteParam(this, int32(SharedMemory::TYPE_SYSV)),
40908:     IPC::WriteParam(this, aHandle);
40908:   }
40908: 
40908:   static bool
40908:   ReadHandle(const Message* msg, void** iter,
40908:              SharedMemorySysV::Handle* aHandle)
40908:   {
40908:     if (!IPC::ReadParam(msg, iter, aHandle))
40908:       return false;
40908:     msg->EndRead(*iter);
40908:     return true;
40908:   }
40908: #endif
40908: 
40908:   void Log(const std::string& aPrefix,
40908:            FILE* aOutf) const
40908:   {
40908:     fputs("(special ShmemCreated msg)", aOutf);
40908:   }
40908: };
40908: 
41362: class ShmemDestroyed : public IPC::Message
41362: {
41362: private:
41362:   typedef Shmem::id_t id_t;
41362: 
41362: public:
41362:   ShmemDestroyed(int32 routingId,
41362:                  const id_t& aIPDLId) :
41362:     IPC::Message(routingId, SHMEM_DESTROYED_MESSAGE_TYPE, PRIORITY_NORMAL)
41362:   {
41362:     IPC::WriteParam(this, aIPDLId);
41362:   }
41362: };
41362: 
41362: 
40908: #ifdef MOZ_HAVE_SHAREDMEMORYSYSV
40908: static Shmem::SharedMemory*
40908: CreateSegment(size_t aNBytes, SharedMemorySysV::Handle aHandle)
40908: {
40908:   nsAutoPtr<SharedMemory> segment;
40908: 
40908:   if (SharedMemorySysV::IsHandleValid(aHandle)) {
40908:     segment = new SharedMemorySysV(aHandle);
40908:   }
40908:   else {
40908:     segment = new SharedMemorySysV();
40908: 
40908:     if (!segment->Create(aNBytes))
40908:       return 0;
40908:   }
40908:   if (!segment->Map(aNBytes))
40908:     return 0;
42561: 
42561:   segment->AddRef();
40908:   return segment.forget();
40908: }
40908: #endif
40908: 
40908: static Shmem::SharedMemory*
40908: CreateSegment(size_t aNBytes, SharedMemoryBasic::Handle aHandle)
40908: {
40908:   nsAutoPtr<SharedMemory> segment;
40908: 
40908:   if (SharedMemoryBasic::IsHandleValid(aHandle)) {
40908:     segment = new SharedMemoryBasic(aHandle);
40908:   }
40908:   else {
40908:     segment = new SharedMemoryBasic();
40908: 
40908:     if (!segment->Create(aNBytes))
40908:       return 0;
40908:   }
40908:   if (!segment->Map(aNBytes))
40908:     return 0;
42561: 
42561:   segment->AddRef();
40908:   return segment.forget();
40908: }
40908: 
40908: static void
40908: DestroySegment(SharedMemory* aSegment)
40908: {
40908:   // the SharedMemory dtor closes and unmaps the actual OS shmem segment
42561:   if (aSegment)
42561:     aSegment->Release();
40908: }
40908: 
40908: 
36152: #if defined(DEBUG)
40908: 
36152: static const char sMagic[] =
36152:     "This little piggy went to market.\n"
36152:     "This little piggy stayed at home.\n"
36152:     "This little piggy has roast beef,\n"
36152:     "This little piggy had none.\n"
36152:     "And this little piggy cried \"Wee! Wee! Wee!\" all the way home";
36152: 
36152: 
40908: struct Header {
56895:   // Don't use size_t or bool here because their size depends on the
56895:   // architecture.
51791:   uint32 mSize;
56895:   uint32 mUnsafe;
36152:   char mMagic[sizeof(sMagic)];
36152: };
36152: 
40908: static void
36152: GetSections(Shmem::SharedMemory* aSegment,
56895:             Header** aHeader,
36152:             char** aFrontSentinel,
36152:             char** aData,
36152:             char** aBackSentinel)
36152: {
36152:   NS_ABORT_IF_FALSE(aSegment && aFrontSentinel && aData && aBackSentinel,
36152:                     "NULL param(s)");
36152: 
36152:   *aFrontSentinel = reinterpret_cast<char*>(aSegment->memory());
36152:   NS_ABORT_IF_FALSE(*aFrontSentinel, "NULL memory()");
36152: 
56895:   *aHeader = reinterpret_cast<Header*>(*aFrontSentinel);
56895: 
36152:   size_t pageSize = Shmem::SharedMemory::SystemPageSize();
36152:   *aData = *aFrontSentinel + pageSize;
36152: 
36152:   *aBackSentinel = *aFrontSentinel + aSegment->Size() - pageSize;
36152: }
36152: 
56895: static Header*
56895: GetHeader(Shmem::SharedMemory* aSegment)
56895: {
56895:   Header* header;
56895:   char* dontcare;
56895:   GetSections(aSegment, &header, &dontcare, &dontcare, &dontcare);
56895:   return header;
56895: }
56895: 
40908: static void
40908: Protect(SharedMemory* aSegment)
40908: {
40908:   NS_ABORT_IF_FALSE(aSegment, "NULL segment");
40908:   aSegment->Protect(reinterpret_cast<char*>(aSegment->memory()),
40908:                     aSegment->Size(),
40908:                     RightsNone);
40908: }
40908: 
40908: static void
40908: Unprotect(SharedMemory* aSegment)
40908: {
40908:   NS_ABORT_IF_FALSE(aSegment, "NULL segment");
40908:   aSegment->Protect(reinterpret_cast<char*>(aSegment->memory()),
40908:                     aSegment->Size(),
40908:                     RightsRead | RightsWrite);
40908: }
36152: 
36152: //
36152: // In debug builds, we specially allocate shmem segments.  The layout
36152: // is as follows
36152: //
36152: //   Page 0: "front sentinel"
36152: //     size of mapping
36152: //     magic bytes
36152: //   Page 1 through n-1:
36152: //     user data
36152: //   Page n: "back sentinel"
36152: //     [nothing]
36152: //
36152: // The mapping can be in one of the following states, wrt to the
36152: // current process.
36152: //
36152: //   State "unmapped": all pages are mapped with no access rights.
36152: //
36152: //   State "mapping": all pages are mapped with read/write access.
36152: //
36152: //   State "mapped": the front and back sentinels are mapped with no
36152: //     access rights, and all the other pages are mapped with
36152: //     read/write access.
36152: //
36152: // When a SharedMemory segment is first allocated, it starts out in
36152: // the "mapping" state for the process that allocates the segment, and
36152: // in the "unmapped" state for the other process.  The allocating
36152: // process will then create a Shmem, which takes the segment into the
36152: // "mapped" state, where it can be accessed by clients.
36152: //
36152: // When a Shmem is sent to another process in an IPDL message, the
36152: // segment transitions into the "unmapped" state for the sending
36152: // process, and into the "mapping" state for the receiving process.
36152: // The receiving process will then create a Shmem from the underlying
36152: // segment, and take the segment into the "mapped" state.
36152: //
36152: // In the "mapping" state, we use the front sentinel to verify the
36152: // integrity of the shmem segment.  If valid, it has a size_t
36152: // containing the number of bytes the user allocated followed by the
36152: // magic bytes above.
36152: //
36152: // In the "mapped" state, the front and back sentinels have no access
36152: // rights.  They act as guards against buffer overflows and underflows
36152: // in client code; if clients touch a sentinel, they die with SIGSEGV.
36152: //
36152: // The "unmapped" state is used to enforce single-owner semantics of
36152: // the shmem segment.  If a process other than the current owner tries
36152: // to touch the segment, it dies with SIGSEGV.
36152: //
36152: 
36152: Shmem::Shmem(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead,
36152:              SharedMemory* aSegment, id_t aId) :
36152:     mSegment(aSegment),
36152:     mData(0),
36152:     mSize(0)
36152: {
36152:   NS_ABORT_IF_FALSE(mSegment, "NULL segment");
36152:   NS_ABORT_IF_FALSE(aId != 0, "invalid ID");
36152: 
36152:   Unprotect(mSegment);
36152: 
56895:   Header* header;
36152:   char* frontSentinel;
36152:   char* data;
36152:   char* backSentinel;
56895:   GetSections(aSegment, &header, &frontSentinel, &data, &backSentinel);
36152: 
36152:   // do a quick validity check to avoid weird-looking crashes in libc
36152:   char check = *frontSentinel;
36152:   (void)check;
36152: 
36152:   NS_ABORT_IF_FALSE(!strncmp(header->mMagic, sMagic, sizeof(sMagic)),
36152:                       "invalid segment");
51791:   mSize = static_cast<size_t>(header->mSize);
36152: 
36152:   size_t pageSize = SharedMemory::SystemPageSize();
36152:   // transition into the "mapped" state by protecting the front and
36152:   // back sentinels (which guard against buffer under/overflows)
36152:   mSegment->Protect(frontSentinel, pageSize, RightsNone);
36152:   mSegment->Protect(backSentinel, pageSize, RightsNone);
36152: 
36152:   // don't set these until we know they're valid
36152:   mData = data;
36152:   mId = aId;
36152: }
36152: 
36152: void
36152: Shmem::AssertInvariants() const
36152: {
36152:   NS_ABORT_IF_FALSE(mSegment, "NULL segment");
36152:   NS_ABORT_IF_FALSE(mData, "NULL data pointer");
36152:   NS_ABORT_IF_FALSE(mSize > 0, "invalid size");
36152:   // if the segment isn't owned by the current process, these will
36152:   // trigger SIGSEGV
36152:   char checkMappingFront = *reinterpret_cast<char*>(mData);
36152:   char checkMappingBack = *(reinterpret_cast<char*>(mData) + mSize - 1);
72442: 
72442:   // avoid "unused" warnings for these variables:
72442:   unused << checkMappingFront;
72442:   unused << checkMappingBack;
36152: }
36152: 
36152: void
40908: Shmem::RevokeRights(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead)
36152: {
40908:   AssertInvariants();
56895: 
56895:   size_t pageSize = SharedMemory::SystemPageSize();
56895:   Header* header = GetHeader(mSegment);
56895: 
56895:   // Open this up for reading temporarily
56895:   mSegment->Protect(reinterpret_cast<char*>(header), pageSize, RightsRead);
56895: 
56895:   if (!header->mUnsafe) {
40908:     Protect(mSegment);
56895:   } else {
56895:     mSegment->Protect(reinterpret_cast<char*>(header), pageSize, RightsNone);
56895:   }
36152: }
36152: 
40908: // static
36152: Shmem::SharedMemory*
36152: Shmem::Alloc(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead,
36152:              size_t aNBytes,
40908:              SharedMemoryType aType,
56895:              bool aUnsafe,
36152:              bool aProtect)
36152: {
54612:   NS_ASSERTION(aNBytes <= PR_UINT32_MAX, "Will truncate shmem segment size!");
56895:   NS_ABORT_IF_FALSE(!aProtect || !aUnsafe, "protect => !unsafe");
54612: 
36152:   size_t pageSize = SharedMemory::SystemPageSize();
40908:   SharedMemory* segment = nsnull;
36152:   // |2*pageSize| is for the front and back sentinel
56906:   size_t segmentSize = SharedMemory::PageAlignedSize(aNBytes + 2*pageSize);
40908: 
40908:   if (aType == SharedMemory::TYPE_BASIC)
40908:     segment = CreateSegment(segmentSize, SharedMemoryBasic::NULLHandle());
40908: #ifdef MOZ_HAVE_SHAREDMEMORYSYSV
40908:   else if (aType == SharedMemory::TYPE_SYSV)
40908:     segment = CreateSegment(segmentSize, SharedMemorySysV::NULLHandle());
40908: #endif
40908:   else
40908:     NS_RUNTIMEABORT("unknown shmem type");
40908: 
36152:   if (!segment)
36152:     return 0;
36152: 
56895:   Header* header;
36152:   char *frontSentinel;
36152:   char *data;
36152:   char *backSentinel;
56895:   GetSections(segment, &header, &frontSentinel, &data, &backSentinel);
36152: 
36152:   // initialize the segment with Shmem-internal information
56895: 
56895:   // NB: this can't be a static assert because technically pageSize
56895:   // isn't known at compile time, event though in practice it's always
56895:   // going to be 4KiB
56895:   NS_ABORT_IF_FALSE(sizeof(Header) <= pageSize,
56895:                     "Shmem::Header has gotten too big");
36152:   memcpy(header->mMagic, sMagic, sizeof(sMagic));
51791:   header->mSize = static_cast<uint32>(aNBytes);
56895:   header->mUnsafe = aUnsafe;
36152: 
36152:   if (aProtect)
36152:     Protect(segment);
36152: 
36152:   return segment;
36152: }
36152: 
40908: // static
36152: Shmem::SharedMemory*
36152: Shmem::OpenExisting(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead,
40908:                     const IPC::Message& aDescriptor,
40908:                     id_t* aId,
36152:                     bool aProtect)
36152: {
40908:   if (SHMEM_CREATED_MESSAGE_TYPE != aDescriptor.type())
40908:     NS_RUNTIMEABORT("expected 'shmem created' message");
36152: 
40908:   void* iter = 0;
40908:   SharedMemory::SharedMemoryType type;
40908:   size_t size;
40908:   if (!ShmemCreated::ReadInfo(&aDescriptor, &iter, aId, &size, &type))
40908:     return 0;
40908: 
40908:   SharedMemory* segment = 0;
36152:   size_t pageSize = SharedMemory::SystemPageSize();
36152:   // |2*pageSize| is for the front and back sentinels
56906:   size_t segmentSize = SharedMemory::PageAlignedSize(size + 2*pageSize);
40908: 
40908:   if (SharedMemory::TYPE_BASIC == type) {
40908:     SharedMemoryBasic::Handle handle;
40908:     if (!ShmemCreated::ReadHandle(&aDescriptor, &iter, &handle))
40908:       return 0;
40908: 
40908:     if (!SharedMemoryBasic::IsHandleValid(handle))
40908:       NS_RUNTIMEABORT("trying to open invalid handle");
40908:     segment = CreateSegment(segmentSize, handle);
40908:   }
40908: #ifdef MOZ_HAVE_SHAREDMEMORYSYSV
40908:   else if (SharedMemory::TYPE_SYSV == type) {
40908:     SharedMemorySysV::Handle handle;
40908:     if (!ShmemCreated::ReadHandle(&aDescriptor, &iter, &handle))
40908:       return 0;
40908: 
40908:     if (!SharedMemorySysV::IsHandleValid(handle))
40908:       NS_RUNTIMEABORT("trying to open invalid handle");
40908:     segment = CreateSegment(segmentSize, handle);
40908:   }
40908: #endif
40908:   else {
40908:     NS_RUNTIMEABORT("unknown shmem type");
40908:   }
40908: 
36152:   if (!segment)
36152:     return 0;
36152: 
56895:   // The caller of this function may not know whether the segment is
56895:   // unsafe or not
56895:   Header* header = GetHeader(segment);
56895:   if (!header->mUnsafe && aProtect)
36152:     Protect(segment);
36152: 
36152:   return segment;
36152: }
36152: 
40908: // static
36152: void
36152: Shmem::Dealloc(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead,
36152:                SharedMemory* aSegment)
36152: {
36152:   if (!aSegment)
36152:     return;
36152: 
36152:   size_t pageSize = SharedMemory::SystemPageSize();
56895:   Header* header;
36152:   char *frontSentinel;
36152:   char *data;
36152:   char *backSentinel;
56895:   GetSections(aSegment, &header, &frontSentinel, &data, &backSentinel);
36152: 
36152:   aSegment->Protect(frontSentinel, pageSize, RightsWrite | RightsRead);
36152:   memset(header->mMagic, 0, sizeof(sMagic));
36152:   header->mSize = 0;
56895:   header->mUnsafe = false;          // make it "safe" so as to catch errors
36152: 
36152:   DestroySegment(aSegment);
36152: }
36152: 
36152: 
36152: #else  // !defined(DEBUG)
36152: 
40908: // static
36152: Shmem::SharedMemory*
36152: Shmem::Alloc(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead,
36152:              size_t aNBytes, 
40908:              SharedMemoryType aType,
56895:              bool /*unused*/,
36152:              bool /*unused*/)
36152: {
40908:   SharedMemory *segment = nsnull;
40908: 
40908:   if (aType == SharedMemory::TYPE_BASIC)
56906:     segment = CreateSegment(SharedMemory::PageAlignedSize(aNBytes + sizeof(uint32)),
40908:                             SharedMemoryBasic::NULLHandle());
40908: #ifdef MOZ_HAVE_SHAREDMEMORYSYSV
40908:   else if (aType == SharedMemory::TYPE_SYSV)
56906:     segment = CreateSegment(SharedMemory::PageAlignedSize(aNBytes + sizeof(uint32)),
40908:                             SharedMemorySysV::NULLHandle());
40908: #endif
40908:   else
40908:     // Unhandled!!
40908:     NS_ABORT();
40908: 
36152:   if (!segment)
36152:     return 0;
36152: 
54612:   *PtrToSize(segment) = static_cast<uint32>(aNBytes);
36152: 
36152:   return segment;
36152: }
36152: 
40908: // static
36152: Shmem::SharedMemory*
36152: Shmem::OpenExisting(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead,
40908:                     const IPC::Message& aDescriptor,
40908:                     id_t* aId,
36152:                     bool /*unused*/)
36152: {
40908:   if (SHMEM_CREATED_MESSAGE_TYPE != aDescriptor.type())
40908:     NS_RUNTIMEABORT("expected 'shmem created' message");
40908: 
40908:   SharedMemory::SharedMemoryType type;
40908:   void* iter = 0;
40908:   size_t size;
40908:   if (!ShmemCreated::ReadInfo(&aDescriptor, &iter, aId, &size, &type))
40908:     return 0;
40908: 
40908:   SharedMemory* segment = 0;
77242:   size_t segmentSize = SharedMemory::PageAlignedSize(size + sizeof(uint32));
40908: 
40908:   if (SharedMemory::TYPE_BASIC == type) {
40908:     SharedMemoryBasic::Handle handle;
40908:     if (!ShmemCreated::ReadHandle(&aDescriptor, &iter, &handle))
40908:       return 0;
40908: 
40908:     if (!SharedMemoryBasic::IsHandleValid(handle))
40908:       NS_RUNTIMEABORT("trying to open invalid handle");
40908: 
40908:     segment = CreateSegment(segmentSize, handle);
40908:   }
40908: #ifdef MOZ_HAVE_SHAREDMEMORYSYSV
40908:   else if (SharedMemory::TYPE_SYSV == type) {
40908:     SharedMemorySysV::Handle handle;
40908:     if (!ShmemCreated::ReadHandle(&aDescriptor, &iter, &handle))
40908:       return 0;
40908: 
40908:     if (!SharedMemorySysV::IsHandleValid(handle))
40908:       NS_RUNTIMEABORT("trying to open invalid handle");
40908:     segment = CreateSegment(segmentSize, handle);
40908:   }
40908: #endif
40908:   else {
40908:     NS_RUNTIMEABORT("unknown shmem type");
40908:   }
40908: 
36152:   if (!segment)
36152:     return 0;
36152: 
36152:   // this is the only validity check done OPT builds
54612:   if (size != static_cast<size_t>(*PtrToSize(segment)))
36152:     NS_RUNTIMEABORT("Alloc() segment size disagrees with OpenExisting()'s");
36152: 
36152:   return segment;
36152: }
36152: 
40908: // static
36152: void
36152: Shmem::Dealloc(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead,
36152:                SharedMemory* aSegment)
36152: {
36152:   DestroySegment(aSegment);
36152: }
36152: 
36152: #endif  // if defined(DEBUG)
36152: 
40908: int
40908: Shmem::GetSysVID() const
40908: {
40908: #ifdef MOZ_HAVE_SHAREDMEMORYSYSV
40908:   AssertInvariants();
36152: 
40908:   if (mSegment->Type() != SharedMemory::TYPE_SYSV)
40908:     NS_RUNTIMEABORT("Can't call GetSysVID() on a non-SysV Shmem!");
40908: 
40908:   SharedMemorySysV* seg = static_cast<SharedMemorySysV*>(mSegment);
40908:   return seg->GetHandle();
40908: #else
40908:   NS_RUNTIMEABORT("Can't call GetSysVID() with no support for SysV shared memory!");
40908:   return -1;                    // not reached
40908: #endif
40908: }
40908: 
40908: IPC::Message*
40908: Shmem::ShareTo(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead,
40908:                base::ProcessHandle aProcess,
40908:                int32 routingId)
36152: {
40908:   AssertInvariants();
36152: 
40908:   if (SharedMemory::TYPE_BASIC == mSegment->Type()) {
40908:     SharedMemoryBasic* seg = static_cast<SharedMemoryBasic*>(mSegment);
40908:     SharedMemoryBasic::Handle handle;
40908:     if (!seg->ShareToProcess(aProcess, &handle))
40908:       return 0;
40908: 
40908:     return new ShmemCreated(routingId, mId, mSize, handle);
36152:   }
40908: #ifdef MOZ_HAVE_SHAREDMEMORYSYSV
40908:   else if (SharedMemory::TYPE_SYSV == mSegment->Type()) {
40908:     SharedMemorySysV* seg = static_cast<SharedMemorySysV*>(mSegment);
40908:     return new ShmemCreated(routingId, mId, mSize, seg->GetHandle());
40908:   }
40908: #endif
36152:   else {
40908:     NS_RUNTIMEABORT("unknown shmem type (here?!)");
40908:   }
40908: 
36152:   return 0;
36152: }
36152: 
41362: IPC::Message*
41362: Shmem::UnshareFrom(IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead,
41362:                    base::ProcessHandle aProcess,
41362:                    int32 routingId)
41362: {
41362:   AssertInvariants();
41362:   return new ShmemDestroyed(routingId, mId);
41362: }
41362: 
36152: } // namespace ipc
36152: } // namespace mozilla
