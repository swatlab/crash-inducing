    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brian Ryner <bryner@brianryner.com>
    1:  *   Javier Delgadillo <javi@netscape.com>
    1:  *   Kai Engert <kengert@redhat.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsNSSComponent.h"
    1: #include "nsNSSIOLayer.h"
    1: #include "nsNSSCallbacks.h"
    1: 
    1: #include "prlog.h"
    1: #include "prnetdb.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIWebProgressListener.h"
    1: #include "nsIChannel.h"
    1: #include "nsNSSCertificate.h"
 6597: #include "nsIX509CertValidity.h"
    1: #include "nsIDateTimeFormat.h"
    1: #include "nsDateTimeFormatCID.h"
    1: #include "nsIClientAuthDialogs.h"
28675: #include "nsClientAuthRemember.h"
 6597: #include "nsICertOverrideService.h"
 6597: #include "nsIBadCertListener2.h"
10284: #include "nsISSLErrorListener.h"
 8463: #include "nsIObjectInputStream.h"
 8463: #include "nsIObjectOutputStream.h"
 7054: #include "nsRecentBadCerts.h"
51363: #include "nsIStrictTransportSecurityService.h"
    1: 
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsHashSets.h"
    1: #include "nsCRT.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsPrintfCString.h"
83083: #include "SSLServerCertVerification.h"
    1: #include "nsNSSShutDown.h"
 6597: #include "nsSSLStatus.h"
    1: #include "nsNSSCertHelper.h"
    1: #include "nsNSSCleaner.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsIDocShell.h"
13186: #include "nsIDocShellTreeItem.h"
    1: #include "nsISecureBrowserUI.h"
 8463: #include "nsIClassInfoImpl.h"
 8463: #include "nsIProgrammingLanguage.h"
33205: #include "nsIArray.h"
41763: #include "nsCharSeparatedTokenizer.h"
79873: #include "PSMRunnable.h"
    1: 
    1: #include "ssl.h"
    1: #include "secerr.h"
    1: #include "sslerr.h"
    1: #include "secder.h"
    1: #include "secasn1.h"
    1: #include "certdb.h"
    1: #include "cert.h"
    1: #include "keyhi.h"
 6597: #include "secport.h"
    1: 
80467: #include "mozilla/Util.h"
80467: 
64576: using namespace mozilla;
79873: using namespace mozilla::psm;
    1: 
    1: //#define DEBUG_SSL_VERBOSE //Enable this define to get minimal 
    1:                             //reports when doing SSL read/write
    1:                             
    1: //#define DUMP_BUFFER  //Enable this define along with
    1:                        //DEBUG_SSL_VERBOSE to dump SSL
    1:                        //read/write buffer to a log.
    1:                        //Uses PR_LOG except on Mac where
    1:                        //we always write out to our own
    1:                        //file.
    1: 
83083: 
    1: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
27356: NSSCleanupAutoPtrClass(void, PR_FREEIF)
80486: NSSCleanupAutoPtrClass_WithParam(PRArenaPool, PORT_FreeArena, FalseParam, false)
    1: 
69383: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
69383: 
    1: /* SSM_UserCertChoice: enum for cert choice info */
    1: typedef enum {ASK, AUTO} SSM_UserCertChoice;
    1: 
    1: #ifdef PR_LOGGING
    1: extern PRLogModuleInfo* gPIPNSSLog;
    1: #endif
    1: 
    1: #if defined(DEBUG_SSL_VERBOSE) && defined (XP_MAC)
    1: 
    1: #ifdef PR_LOG
    1: #undef PR_LOG
    1: #endif
    1: 
    1: static PRFileDesc *gMyLogFile = nsnull;
    1: #define MAC_LOG_FILE "MAC PIPNSS Log File"
    1: 
    1: void MyLogFunction(const char *fmt, ...)
    1: {
    1:   
    1:   va_list ap;
    1:   va_start(ap,fmt);
    1:   if (gMyLogFile == nsnull)
    1:     gMyLogFile = PR_Open(MAC_LOG_FILE, PR_WRONLY | PR_CREATE_FILE | PR_APPEND,
    1:                          0600);
    1:   if (!gMyLogFile)
    1:       return;
    1:   PR_vfprintf(gMyLogFile, fmt, ap);
    1:   va_end(ap);
    1: }
    1: 
    1: #define PR_LOG(module,level,args) MyLogFunction args
    1: #endif
    1: 
    1: nsNSSSocketInfo::nsNSSSocketInfo()
83081:   : mMutex("nsNSSSocketInfo::nsNSSSocketInfo"),
83081:     mFd(nsnull),
83083:     mCertVerificationState(before_cert_verification),
    1:     mSecurityState(nsIWebProgressListener::STATE_IS_INSECURE),
14244:     mSubRequestsHighSecurity(0),
14244:     mSubRequestsLowSecurity(0),
14244:     mSubRequestsBrokenSecurity(0),
14244:     mSubRequestsNoSecurity(0),
83081:     mErrorCode(0),
83081:     mErrorMessageType(PlainErrorMessage),
80486:     mForSTARTTLS(false),
80486:     mHandshakePending(true),
80486:     mHasCleartextPhase(false),
80486:     mHandshakeInProgress(false),
80486:     mAllowTLSIntoleranceTimeout(true),
80486:     mRememberClientAuthCertificate(false),
    1:     mHandshakeStartTime(0),
77514:     mPort(0),
84396:     mIsCertIssuerBlacklisted(false)
    1: {
    1: }
    1: 
    1: nsNSSSocketInfo::~nsNSSSocketInfo()
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (isAlreadyShutDown())
    1:     return;
    1: 
    1:   shutdown(calledFromObject);
    1: }
    1: 
    1: void nsNSSSocketInfo::virtualDestroyNSSReference()
    1: {
    1: }
    1: 
81084: NS_IMPL_THREADSAFE_ISUPPORTS8(nsNSSSocketInfo,
    1:                               nsITransportSecurityInfo,
    1:                               nsISSLSocketControl,
    1:                               nsIInterfaceRequestor,
 5220:                               nsISSLStatusProvider,
14244:                               nsIAssociatedContentSecurity,
 8463:                               nsISerializable,
28675:                               nsIClassInfo,
28675:                               nsIClientAuthUserDecision)
    1: 
    1: nsresult
79445: nsNSSSocketInfo::GetHandshakePending(bool *aHandshakePending)
    1: {
    1:   *aHandshakePending = mHandshakePending;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
79445: nsNSSSocketInfo::SetHandshakePending(bool aHandshakePending)
    1: {
    1:   mHandshakePending = aHandshakePending;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetHostName(const char* host)
    1: {
27356:   mHostName.Adopt(host ? NS_strdup(host) : 0);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::GetHostName(char **host)
    1: {
27356:   *host = (mHostName) ? NS_strdup(mHostName) : nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetPort(PRInt32 aPort)
    1: {
    1:   mPort = aPort;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::GetPort(PRInt32 *aPort)
    1: {
    1:   *aPort = mPort;
    1:   return NS_OK;
    1: }
    1: 
83081: PRErrorCode
83081: nsNSSSocketInfo::GetErrorCode() const
    1: {
83081:   MutexAutoLock lock(mMutex);
83081: 
83081:   return mErrorCode;
83081: }
83081: 
83081: void
83081: nsNSSSocketInfo::SetCanceled(PRErrorCode errorCode,
83083:                              SSLErrorMessageType errorMessageType)
    1: {
83081:   MutexAutoLock lock(mMutex);
83081: 
83081:   mErrorCode = errorCode;
83081:   mErrorMessageType = errorMessageType;
83081:   mErrorMessageCached.Truncate();
    1: }
    1: 
79445: NS_IMETHODIMP nsNSSSocketInfo::GetRememberClientAuthCertificate(bool *aRememberClientAuthCertificate)
28675: {
28675:   NS_ENSURE_ARG_POINTER(aRememberClientAuthCertificate);
28675:   *aRememberClientAuthCertificate = mRememberClientAuthCertificate;
28675:   return NS_OK;
28675: }
28675: 
79445: NS_IMETHODIMP nsNSSSocketInfo::SetRememberClientAuthCertificate(bool aRememberClientAuthCertificate)
28675: {
28675:   mRememberClientAuthCertificate = aRememberClientAuthCertificate;
28675:   return NS_OK;
28675: }
28675: 
79445: void nsNSSSocketInfo::SetHasCleartextPhase(bool aHasCleartextPhase)
    1: {
    1:   mHasCleartextPhase = aHasCleartextPhase;
    1: }
    1: 
79445: bool nsNSSSocketInfo::GetHasCleartextPhase()
    1: {
    1:   return mHasCleartextPhase;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::GetNotificationCallbacks(nsIInterfaceRequestor** aCallbacks)
    1: {
    1:   *aCallbacks = mCallbacks;
    1:   NS_IF_ADDREF(*aCallbacks);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::SetNotificationCallbacks(nsIInterfaceRequestor* aCallbacks)
    1: {
    1:   if (!aCallbacks) {
    1:     mCallbacks = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
14244:   mCallbacks = aCallbacks;
14244: 
14244:   return NS_OK;
14244: }
14244: 
81302: static void
81302: getSecureBrowserUI(nsIInterfaceRequestor * callbacks,
81302:                    nsISecureBrowserUI ** result)
14244: {
81302:   NS_ASSERTION(result != nsnull, "result parameter to getSecureBrowserUI is null");
81302:   *result = nsnull;
81302: 
81302:   NS_ASSERTION(NS_IsMainThread(),
81302:                "getSecureBrowserUI called off the main thread");
81302: 
81302:   if (!callbacks)
81302:     return;
81302: 
81302:   nsCOMPtr<nsISecureBrowserUI> secureUI = do_GetInterface(callbacks);
81302:   if (secureUI) {
81302:     secureUI.forget(result);
81302:     return;
81302:   }
81302: 
81302:   nsCOMPtr<nsIDocShellTreeItem> item = do_GetInterface(callbacks);
81302:   if (item) {
81302:     nsCOMPtr<nsIDocShellTreeItem> rootItem;
81302:     (void) item->GetSameTypeRootTreeItem(getter_AddRefs(rootItem));
81302:       
81302:     nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(rootItem);
81302:     if (docShell) {
81302:       (void) docShell->GetSecurityUI(result);
81302:     }
81302:   }
81302: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::GetSecurityState(PRUint32* state)
    1: {
    1:   *state = mSecurityState;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetSecurityState(PRUint32 aState)
    1: {
    1:   mSecurityState = aState;
    1:   return NS_OK;
    1: }
    1: 
14244: /* attribute unsigned long countSubRequestsHighSecurity; */
14244: NS_IMETHODIMP nsNSSSocketInfo::GetCountSubRequestsHighSecurity(PRInt32 *aSubRequestsHighSecurity)
14244: {
14244:   *aSubRequestsHighSecurity = mSubRequestsHighSecurity;
14244:   return NS_OK;
14244: }
14244: NS_IMETHODIMP nsNSSSocketInfo::SetCountSubRequestsHighSecurity(PRInt32 aSubRequestsHighSecurity)
14244: {
14244:   mSubRequestsHighSecurity = aSubRequestsHighSecurity;
14244:   return NS_ERROR_NOT_IMPLEMENTED;
14244: }
14244: 
14244: /* attribute unsigned long countSubRequestsLowSecurity; */
14244: NS_IMETHODIMP nsNSSSocketInfo::GetCountSubRequestsLowSecurity(PRInt32 *aSubRequestsLowSecurity)
14244: {
14244:   *aSubRequestsLowSecurity = mSubRequestsLowSecurity;
14244:   return NS_OK;
14244: }
14244: NS_IMETHODIMP nsNSSSocketInfo::SetCountSubRequestsLowSecurity(PRInt32 aSubRequestsLowSecurity)
14244: {
14244:   mSubRequestsLowSecurity = aSubRequestsLowSecurity;
14244:   return NS_OK;
14244: }
14244: 
14244: /* attribute unsigned long countSubRequestsBrokenSecurity; */
14244: NS_IMETHODIMP nsNSSSocketInfo::GetCountSubRequestsBrokenSecurity(PRInt32 *aSubRequestsBrokenSecurity)
14244: {
14244:   *aSubRequestsBrokenSecurity = mSubRequestsBrokenSecurity;
14244:   return NS_OK;
14244: }
14244: NS_IMETHODIMP nsNSSSocketInfo::SetCountSubRequestsBrokenSecurity(PRInt32 aSubRequestsBrokenSecurity)
14244: {
14244:   mSubRequestsBrokenSecurity = aSubRequestsBrokenSecurity;
14244:   return NS_OK;
14244: }
14244: 
14244: /* attribute unsigned long countSubRequestsNoSecurity; */
14244: NS_IMETHODIMP nsNSSSocketInfo::GetCountSubRequestsNoSecurity(PRInt32 *aSubRequestsNoSecurity)
14244: {
14244:   *aSubRequestsNoSecurity = mSubRequestsNoSecurity;
14244:   return NS_OK;
14244: }
14244: NS_IMETHODIMP nsNSSSocketInfo::SetCountSubRequestsNoSecurity(PRInt32 aSubRequestsNoSecurity)
14244: {
14244:   mSubRequestsNoSecurity = aSubRequestsNoSecurity;
14244:   return NS_OK;
14244: }
50566: NS_IMETHODIMP nsNSSSocketInfo::Flush()
50566: {
50566:   return NS_OK;
50566: }
14244: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::GetShortSecurityDescription(PRUnichar** aText) {
    1:   if (mShortDesc.IsEmpty())
    1:     *aText = nsnull;
    1:   else {
    1:     *aText = ToNewUnicode(mShortDesc);
    1:     NS_ENSURE_TRUE(*aText, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetShortSecurityDescription(const PRUnichar* aText) {
    1:   mShortDesc.Assign(aText);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
83081: nsNSSSocketInfo::GetErrorMessage(PRUnichar** aText)
83081: {
83081:   NS_ENSURE_ARG_POINTER(aText);
    1:   *aText = nsnull;
83081: 
83081:   if (!NS_IsMainThread()) {
83081:     NS_ERROR("nsNSSSocketInfo::GetErrorMessage called off the main thread");
83081:     return NS_ERROR_NOT_SAME_THREAD;
83081:   }
83081: 
83081:   MutexAutoLock lock(mMutex);
83081: 
83081:   nsresult rv = formatErrorMessage(lock);
83081:   NS_ENSURE_SUCCESS(rv, rv);
83081: 
83081:   *aText = ToNewUnicode(mErrorMessageCached);
83081:   return *aText != nsnull ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
83081: }
83081: 
83081: static nsresult
83081: formatPlainErrorMessage(nsXPIDLCString const & host, PRInt32 port,
83081:                         PRErrorCode err, nsString &returnedMessage);
83081: 
83081: static nsresult
83081: formatOverridableCertErrorMessage(nsISSLStatus & sslStatus,
83081:                                   PRErrorCode errorCodeToReport, 
83081:                                   const nsXPIDLCString & host, PRInt32 port,
83081:                                   nsString & returnedMessage);
83081: 
83081: // XXX: uses nsNSSComponent string bundles off the main thread when called by
83081: //      nsNSSSocketInfo::Write(). When we remove the error message from the
83081: //      serialization of nsNSSSocketInfo (bug 697781) we can inline
83081: //      formatErrorMessage into GetErrorMessage().
83081: nsresult
83081: nsNSSSocketInfo::formatErrorMessage(MutexAutoLock const & proofOfLock)
83081: {
83081:   if (mErrorCode == 0 || !mErrorMessageCached.IsEmpty()) {
    1:     return NS_OK;
    1:   }
    1: 
83081:   nsresult rv;
83081:   NS_ConvertASCIItoUTF16 hostNameU(mHostName);
83081:   NS_ASSERTION(mErrorMessageType != OverridableCertErrorMessage || 
83081:                 (mSSLStatus && mSSLStatus->mServerCert &&
83081:                  mSSLStatus->mHaveCertErrorBits),
83081:                 "GetErrorMessage called for cert error without cert");
83081:   if (mErrorMessageType == OverridableCertErrorMessage && 
83081:       mSSLStatus && mSSLStatus->mServerCert) {
83081:     rv = formatOverridableCertErrorMessage(*mSSLStatus, mErrorCode,
83081:                                            mHostName, mPort,
83081:                                            mErrorMessageCached);
83081:   } else {
83081:     rv = formatPlainErrorMessage(mHostName, mPort, mErrorCode,
83081:                                  mErrorMessageCached);
83081:   }
83081: 
83081:   if (NS_FAILED(rv)) {
83081:     mErrorMessageCached.Truncate();
83081:   }
83081: 
83081:   return rv;
    1: }
    1: 
    1: /* void getInterface (in nsIIDRef uuid, [iid_is (uuid), retval] out nsQIResult result); */
    1: NS_IMETHODIMP nsNSSSocketInfo::GetInterface(const nsIID & uuid, void * *result)
    1: {
81303:   if (!NS_IsMainThread()) {
81303:     NS_ERROR("nsNSSSocketInfo::GetInterface called off the main thread");
81303:     return NS_ERROR_NOT_SAME_THREAD;
81303:   }
81303: 
    1:   nsresult rv;
    1:   if (!mCallbacks) {
    1:     nsCOMPtr<nsIInterfaceRequestor> ir = new PipUIContext();
    1:     if (!ir)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     rv = ir->GetInterface(uuid, result);
    1:   } else {
81303:     rv = mCallbacks->GetInterface(uuid, result);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: nsresult
79445: nsNSSSocketInfo::GetForSTARTTLS(bool* aForSTARTTLS)
    1: {
    1:   *aForSTARTTLS = mForSTARTTLS;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
79445: nsNSSSocketInfo::SetForSTARTTLS(bool aForSTARTTLS)
    1: {
    1:   mForSTARTTLS = aForSTARTTLS;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::ProxyStartSSL()
    1: {
    1:   return ActivateSSL();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::StartTLS()
    1: {
    1:   return ActivateSSL();
    1: }
    1: 
50565: static NS_DEFINE_CID(kNSSCertificateCID, NS_X509CERT_CID);
50565: #define NSSSOCKETINFOMAGIC { 0xa9863a23, 0x26b8, 0x4a9c, \
50565:   { 0x83, 0xf1, 0xe9, 0xda, 0xdb, 0x36, 0xb8, 0x30 } }
50565: static NS_DEFINE_CID(kNSSSocketInfoMagic, NSSSOCKETINFOMAGIC);
50565: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::Write(nsIObjectOutputStream* stream) {
50565:   stream->WriteID(kNSSSocketInfoMagic);
50565: 
83081:   MutexAutoLock lock(mMutex);
83081: 
81084:   nsRefPtr<nsSSLStatus> status = mSSLStatus;
81084:   nsCOMPtr<nsISerializable> certSerializable;
81084: 
81084:   // Write a redundant copy of the certificate for backward compatibility
81084:   // with previous versions, which also unnecessarily wrote it.
81084:   //
50565:   // As we are reading the object our self, not using ReadObject, we have
50565:   // to store it here 'manually' as well, mimicking our object stream
50565:   // implementation.
81084: 
81084:   if (status) {
81084:     nsCOMPtr<nsIX509Cert> cert = status->mServerCert;
81084:     certSerializable = do_QueryInterface(cert);
81084: 
81084:     if (!certSerializable) {
81084:       NS_ERROR("certificate is missing or isn't serializable");
81084:       return NS_ERROR_UNEXPECTED;
81084:     }
81084:   } else {
81084:     NS_WARNING("Serializing nsNSSSocketInfo without mSSLStatus");
81084:   }
81084: 
81084:   // Store the flag if there is the certificate present
81084:   stream->WriteBoolean(certSerializable);
50565:   if (certSerializable) {
50565:     stream->WriteID(kNSSCertificateCID);
50565:     stream->WriteID(NS_GET_IID(nsISupports));
50565:     certSerializable->Write(stream);
50565:   }
29655: 
29655:   // Store the version number of the binary stream data format.
29655:   // The 0xFFFF0000 mask is included to the version number
29655:   // to distinguish version number from mSecurityState
29655:   // field stored in times before versioning has been introduced.
29655:   // This mask value has been chosen as mSecurityState could
29655:   // never be assigned such value.
50565:   PRUint32 version = 3;
29655:   stream->Write32(version | 0xFFFF0000);
 8463:   stream->Write32(mSecurityState);
 8463:   stream->WriteWStringZ(mShortDesc.get());
83081: 
83081:   // XXX: uses nsNSSComponent string bundles off the main thread
83081:   nsresult rv = formatErrorMessage(lock); 
83081:   NS_ENSURE_SUCCESS(rv, rv);
83081:   stream->WriteWStringZ(mErrorMessageCached.get());
 8463: 
81084:   stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsISSLStatus*, status),
80486:                               NS_GET_IID(nsISupports), true);
29655: 
29655:   stream->Write32((PRUint32)mSubRequestsHighSecurity);
29655:   stream->Write32((PRUint32)mSubRequestsLowSecurity);
29655:   stream->Write32((PRUint32)mSubRequestsBrokenSecurity);
29655:   stream->Write32((PRUint32)mSubRequestsNoSecurity);
 8463:   return NS_OK;
 8463: }
 8463: 
50565: static bool CheckUUIDEquals(PRUint32 m0,
50565:                             nsIObjectInputStream* stream,
50565:                             const nsCID& id)
50565: {
50565:   nsID tempID;
50565:   tempID.m0 = m0;
50565:   stream->Read16(&tempID.m1);
50565:   stream->Read16(&tempID.m2);
50565:   for (int i = 0; i < 8; ++i)
50565:     stream->Read8(&tempID.m3[i]);
50565:   return tempID.Equals(id);
50565: }
50565: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::Read(nsIObjectInputStream* stream) {
50565:   nsresult rv;
 8463: 
29655:   PRUint32 version;
79445:   bool certificatePresent;
50565: 
50565:   // Check what we have here...
50565:   PRUint32 UUID_0;
50565:   stream->Read32(&UUID_0);
50565:   if (UUID_0 == kNSSSocketInfoMagic.m0) {
50565:     // It seems this stream begins with our magic ID, check it really is there
50565:     if (!CheckUUIDEquals(UUID_0, stream, kNSSSocketInfoMagic))
50565:       return NS_ERROR_FAILURE;
50565: 
50565:     // OK, this seems to be our stream, now continue to check there is
50565:     // the certificate
50565:     stream->ReadBoolean(&certificatePresent);
50565:     stream->Read32(&UUID_0);
50565:   }
50565:   else {
50565:     // There is no magic, assume there is a certificate present as in versions
50565:     // prior to those with the magic didn't store that flag; we check the 
50565:     // certificate is present by cheking the CID then
80486:     certificatePresent = true;
50565:   }
50565: 
50565:   if (certificatePresent && UUID_0 == kNSSCertificateCID.m0) {
50565:     // It seems there is the certificate CID present, check it now; we only
50565:     // have this single certificate implementation at this time.
50565:     if (!CheckUUIDEquals(UUID_0, stream, kNSSCertificateCID))
50565:       return NS_ERROR_FAILURE;
50565: 
50565:     // OK, we have read the CID of the certificate, check the interface ID
50565:     nsID tempID;
50565:     stream->ReadID(&tempID);
50565:     if (!tempID.Equals(NS_GET_IID(nsISupports)))
50565:       return NS_ERROR_FAILURE;
50565: 
50565:     nsCOMPtr<nsISerializable> serializable =
50565:         do_CreateInstance(kNSSCertificateCID, &rv);
50565:     NS_ENSURE_SUCCESS(rv, rv);
50565: 
81084:     // This is the redundant copy of the certificate; just ignore it
50565:     serializable->Read(stream);
50565: 
50565:     // We are done with reading the certificate, now read the version
50565:     // as we did before.
29655:     stream->Read32(&version);
50565:   }
50565:   else {
50565:     // There seems not to be the certificate present in the stream.
50565:     version = UUID_0;
50565:   }
50565: 
83081:   MutexAutoLock lock(mMutex);
83081: 
29655:   // If the version field we have just read is not masked with 0xFFFF0000
29655:   // then it is stored mSecurityState field and this is version 1 of
29655:   // the binary data stream format.
29655:   if ((version & 0xFFFF0000) == 0xFFFF0000) {
29655:     version &= ~0xFFFF0000;
 8463:     stream->Read32(&mSecurityState);
29655:   }
29655:   else {
29655:     mSecurityState = version;
29655:     version = 1;
29655:   }
 8463:   stream->ReadString(mShortDesc);
83081:   stream->ReadString(mErrorMessageCached);
83081:   mErrorCode = 0;
 8463: 
50565:   nsCOMPtr<nsISupports> obj;
80486:   stream->ReadObject(true, getter_AddRefs(obj));
81084:   
 8463:   mSSLStatus = reinterpret_cast<nsSSLStatus*>(obj.get());
29655: 
81084:   if (!mSSLStatus) {
81084:     NS_WARNING("deserializing nsNSSSocketInfo without mSSLStatus");
81084:   }
81084: 
29655:   if (version >= 2) {
29655:     stream->Read32((PRUint32*)&mSubRequestsHighSecurity);
29655:     stream->Read32((PRUint32*)&mSubRequestsLowSecurity);
29655:     stream->Read32((PRUint32*)&mSubRequestsBrokenSecurity);
29655:     stream->Read32((PRUint32*)&mSubRequestsNoSecurity);
29655:   }
29655:   else {
29655:     mSubRequestsHighSecurity = 0;
29655:     mSubRequestsLowSecurity = 0;
29655:     mSubRequestsBrokenSecurity = 0;
29655:     mSubRequestsNoSecurity = 0;
29655:   }
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetInterfaces(PRUint32 *count, nsIID * **array)
 8463: {
 8463:   *count = 0;
 8463:   *array = nsnull;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetHelperForLanguage(PRUint32 language, nsISupports **_retval)
 8463: {
 8463:   *_retval = nsnull;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetContractID(char * *aContractID)
 8463: {
 8463:   *aContractID = nsnull;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetClassDescription(char * *aClassDescription)
 8463: {
 8463:   *aClassDescription = nsnull;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetClassID(nsCID * *aClassID)
 8463: {
 8463:   *aClassID = (nsCID*) nsMemory::Alloc(sizeof(nsCID));
 8463:   if (!*aClassID)
 8463:     return NS_ERROR_OUT_OF_MEMORY;
 8463:   return GetClassIDNoAlloc(*aClassID);
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
 8463: {
 8463:   *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetFlags(PRUint32 *aFlags)
 8463: {
 8463:   *aFlags = 0;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: static NS_DEFINE_CID(kNSSSocketInfoCID, NS_NSSSOCKETINFO_CID);
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 8463: {
 8463:   *aClassIDNoAlloc = kNSSSocketInfoCID;
 8463:   return NS_OK;
 8463: }
 8463: 
    1: nsresult nsNSSSocketInfo::ActivateSSL()
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (isAlreadyShutDown())
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
83083:   if (SECSuccess != SSL_OptionSet(mFd, SSL_SECURITY, true))
83083:     return NS_ERROR_FAILURE;		
83083:   if (SECSuccess != SSL_ResetHandshake(mFd, false))
83083:     return NS_ERROR_FAILURE;
    1: 
80486:   mHandshakePending = true;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsNSSSocketInfo::GetFileDescPtr(PRFileDesc** aFilePtr)
    1: {
    1:   *aFilePtr = mFd;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsNSSSocketInfo::SetFileDescPtr(PRFileDesc* aFilePtr)
    1: {
    1:   mFd = aFilePtr;
    1:   return NS_OK;
    1: }
    1: 
81302: class PreviousCertRunnable : public SyncRunnableBase
 5220: {
81302: public:
81302:   PreviousCertRunnable(nsIInterfaceRequestor * callbacks)
81302:     : mCallbacks(callbacks)
81302:   {
81302:   }
81302: 
81302:   virtual void RunOnTargetThread()
81302:   {
81302:     nsCOMPtr<nsISecureBrowserUI> secureUI;
81302:     getSecureBrowserUI(mCallbacks, getter_AddRefs(secureUI));
81302:     nsCOMPtr<nsISSLStatusProvider> statusProvider = do_QueryInterface(secureUI);
81302:     if (statusProvider) {
81302:       nsCOMPtr<nsISSLStatus> status;
81302:       (void) statusProvider->GetSSLStatus(getter_AddRefs(status));
81302:       if (status) {
81302:         (void) status->GetServerCert(getter_AddRefs(mPreviousCert));
81302:       }
81302:     }
81302:   }
81302: 
81302:   nsCOMPtr<nsIX509Cert> mPreviousCert; // out
81302: private:
81302:   nsCOMPtr<nsIInterfaceRequestor> mCallbacks; // in
81302: };
81302: 
81302: void nsNSSSocketInfo::GetPreviousCert(nsIX509Cert** _result)
81302: {
81302:   NS_ASSERTION(_result, "_result parameter to GetPreviousCert is null");
81302:   *_result = nsnull;
81302: 
81302:   if (NS_IsMainThread()) {
81302:     NS_ERROR("nsNSSSocketInfo::GetPreviousCert called on the main thread");
81302:     return;
81302:   }
81302: 
81302:   nsRefPtr<PreviousCertRunnable> runnable = new PreviousCertRunnable(mCallbacks);
81302:   nsresult rv = runnable->DispatchToMainThreadAndWait();
81302:   NS_ASSERTION(NS_SUCCEEDED(rv), "runnable->DispatchToMainThreadAndWait() failed");
81302:   runnable->mPreviousCert.forget(_result);
10258: }
10258: 
83083: void
83083: nsNSSSocketInfo::SetCertVerificationWaiting()
83083: {
83083:   // mCertVerificationState may be before_cert_verification for the first
83083:   // handshake on the connection, or after_cert_verification for subsequent
83083:   // renegotiation handshakes.
83083:   NS_ASSERTION(mCertVerificationState != waiting_for_cert_verification,
83083:                "Invalid state transition to waiting_for_cert_verification");
83083:   mCertVerificationState = waiting_for_cert_verification;
83083: }
83083: 
83083: void
83083: nsNSSSocketInfo::SetCertVerificationResult(PRErrorCode errorCode,
83083:                                            SSLErrorMessageType errorMessageType)
83083: {
83083:   NS_ASSERTION(mCertVerificationState == waiting_for_cert_verification,
83083:                "Invalid state transition to cert_verification_finished");
83083: 
83083:   if (errorCode != 0) {
83083:     SetCanceled(errorCode, errorMessageType);
83083:   } else if (mFd) {
83083:     // We haven't closed the connection already, so restart it
83083:     SECStatus rv = SSL_RestartHandshakeAfterAuthCertificate(mFd);
83083:     if (rv != SECSuccess) {
83083:       errorCode = PR_GetError();
83083:       if (errorCode == 0) {
83083:         NS_ERROR("SSL_RestartHandshakeAfterAuthCertificate didn't set error code");
83083:         errorCode = PR_INVALID_STATE_ERROR;
83083:       }
83083:       SetCanceled(errorCode, PlainErrorMessage);
83083:     }
83083:   } else {
83083:     // If we closed the connection alreay, we don't have anything to do
83083:   }
83083: 
83083:   mCertVerificationState = after_cert_verification;
83083: }
83083: 
81084: nsresult nsNSSSocketInfo::GetSSLStatus(nsISSLStatus** _result)
10258: {
10258:   NS_ENSURE_ARG_POINTER(_result);
10258: 
81084:   *_result = mSSLStatus;
    1:   NS_IF_ADDREF(*_result);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 8463: nsresult nsNSSSocketInfo::SetSSLStatus(nsSSLStatus *aSSLStatus)
    1: {
    1:   mSSLStatus = aSSLStatus;
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: void nsNSSSocketInfo::SetHandshakeInProgress(bool aIsIn)
    1: {
    1:   mHandshakeInProgress = aIsIn;
    1: 
    1:   if (mHandshakeInProgress && !mHandshakeStartTime)
    1:   {
    1:     mHandshakeStartTime = PR_IntervalNow();
    1:   }
    1: }
    1: 
79445: void nsNSSSocketInfo::SetAllowTLSIntoleranceTimeout(bool aAllow)
    1: {
    1:   mAllowTLSIntoleranceTimeout = aAllow;
    1: }
    1: 
    1: #define HANDSHAKE_TIMEOUT_SECONDS 25
    1: 
79445: bool nsNSSSocketInfo::HandshakeTimeout()
    1: {
 6597:   if (!mHandshakeInProgress || !mAllowTLSIntoleranceTimeout)
80486:     return false;
    1: 
    1:   return ((PRIntervalTime)(PR_IntervalNow() - mHandshakeStartTime)
    1:           > PR_SecondsToInterval(HANDSHAKE_TIMEOUT_SECONDS));
    1: }
    1: 
    1: void nsSSLIOLayerHelpers::Cleanup()
    1: {
    1:   if (mTLSIntolerantSites) {
    1:     delete mTLSIntolerantSites;
    1:     mTLSIntolerantSites = nsnull;
    1:   }
    1: 
30463:   if (mTLSTolerantSites) {
30463:     delete mTLSTolerantSites;
30463:     mTLSTolerantSites = nsnull;
30463:   }
30463: 
37963:   if (mRenegoUnrestrictedSites) {
37963:     delete mRenegoUnrestrictedSites;
37963:     mRenegoUnrestrictedSites = nsnull;
37963:   }
37963: 
25625:   if (mutex) {
64576:     delete mutex;
25625:     mutex = nsnull;
25625:   }
28629: 
28629:   if (mHostsWithCertErrors) {
28629:     delete mHostsWithCertErrors;
28629:     mHostsWithCertErrors = nsnull;
28629:   }
    1: }
    1: 
83081: /* Formats an error message for non-certificate-related SSL errors
83081:  * and non-overridable certificate errors (both are of type
83081:  * PlainErrormMessage). Use formatOverridableCertErrorMessage
83081:  * for overridable cert errors.
83081:  */
    1: static nsresult
83081: formatPlainErrorMessage(const nsXPIDLCString &host, PRInt32 port,
83081:                         PRErrorCode err, nsString &returnedMessage)
    1: {
    1:   const PRUnichar *params[1];
    1:   nsresult rv;
    1: 
83081:   nsCOMPtr<nsINSSComponent> component = do_GetService(kNSSComponentCID, &rv);
83081:   NS_ENSURE_SUCCESS(rv, rv);
83081: 
    1:   if (host.Length())
    1:   {
 7252:     nsString hostWithPort;
 7252: 
79869:     // For now, hide port when it's 443 and we're reporting the error.
79869:     // In the future a better mechanism should be used
 7252:     // to make a decision about showing the port number, possibly by requiring
 7252:     // the context object to implement a specific interface.
 7252:     // The motivation is that Mozilla browser would like to hide the port number
 7252:     // in error pages in the common case.
 7252: 
83081:     hostWithPort.AssignASCII(host);
83081:     if (port != 443) {
 7252:       hostWithPort.AppendLiteral(":");
 7252:       hostWithPort.AppendInt(port);
83081:     }
 7252:     params[0] = hostWithPort.get();
    1: 
    1:     nsString formattedString;
    1:     rv = component->PIPBundleFormatStringFromName("SSLConnectionErrorPrefix", 
    1:                                                   params, 1, 
    1:                                                   formattedString);
    1:     if (NS_SUCCEEDED(rv))
    1:     {
    1:       returnedMessage.Append(formattedString);
 7252:       returnedMessage.Append(NS_LITERAL_STRING("\n\n"));
    1:     }
    1:   }
    1: 
    1:   nsString explanation;
    1:   rv = nsNSSErrors::getErrorMessageFromCode(err, component, explanation);
    1:   if (NS_SUCCEEDED(rv))
    1:     returnedMessage.Append(explanation);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 7879: static void
 7879: AppendErrorTextUntrusted(PRErrorCode errTrust,
 6597:                          const nsString &host,
 6597:                          nsIX509Cert* ix509,
 6597:                          nsINSSComponent *component,
 6597:                          nsString &returnedMessage)
 6597: {
 7252:   const char *errorID = nsnull;
 7252:   nsCOMPtr<nsIX509Cert3> cert3 = do_QueryInterface(ix509);
 7252:   if (cert3) {
79445:     bool isSelfSigned;
 7252:     if (NS_SUCCEEDED(cert3->GetIsSelfSigned(&isSelfSigned))
 7252:         && isSelfSigned) {
 7252:       errorID = "certErrorTrust_SelfSigned";
 7252:     }
 7252:   }
 7252: 
 7252:   if (!errorID) {
 7252:     switch (errTrust) {
 7252:       case SEC_ERROR_UNKNOWN_ISSUER:
33205:       {
33205:         nsCOMPtr<nsIArray> chain;
33205:         ix509->GetChain(getter_AddRefs(chain));
33205:         PRUint32 length = 0;
33205:         if (chain && NS_FAILED(chain->GetLength(&length)))
33205:           length = 0;
33205:         if (length == 1)
33205:           errorID = "certErrorTrust_MissingChain";
33205:         else
 7252:           errorID = "certErrorTrust_UnknownIssuer";
 7252:         break;
33205:       }
13929:       case SEC_ERROR_INADEQUATE_KEY_USAGE:
13929:         // Should get an individual string in the future
13929:         // For now, use the same as CaInvalid
 7252:       case SEC_ERROR_CA_CERT_INVALID:
 7252:         errorID = "certErrorTrust_CaInvalid";
 7252:         break;
 7252:       case SEC_ERROR_UNTRUSTED_ISSUER:
 7252:         errorID = "certErrorTrust_Issuer";
 7252:         break;
 7252:       case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
 7252:         errorID = "certErrorTrust_ExpiredIssuer";
 7252:         break;
 7252:       case SEC_ERROR_UNTRUSTED_CERT:
 7252:       default:
 7252:         errorID = "certErrorTrust_Untrusted";
 7252:         break;
 7252:     }
 7252:   }
 7252: 
 6597:   nsString formattedString;
 7879:   nsresult rv = component->GetPIPNSSBundleString(errorID, 
 6597:                                                  formattedString);
 6597:   if (NS_SUCCEEDED(rv))
 6597:   {
 6597:     returnedMessage.Append(formattedString);
 6597:     returnedMessage.Append(NS_LITERAL_STRING("\n"));
 6597:   }
 6597: }
 6597: 
31588: // returns TRUE if SAN was used to produce names
31588: // return FALSE if nothing was produced
 7879: // names => a single name or a list of names
 7879: // multipleNames => whether multiple names were delivered
79445: static bool
 7879: GetSubjectAltNames(CERTCertificate *nssCert,
 7879:                    nsINSSComponent *component,
 7879:                    nsString &allNames,
14197:                    PRUint32 &nameCount)
 6597: {
 7879:   allNames.Truncate();
10259:   nameCount = 0;
 7252: 
 7252:   PRArenaPool *san_arena = nsnull;
 7252:   SECItem altNameExtension = {siBuffer, NULL, 0 };
 7252:   CERTGeneralName *sanNameList = nsnull;
 7252: 
 7879:   nsresult rv;
 7252:   rv = CERT_FindCertExtension(nssCert, SEC_OID_X509_SUBJECT_ALT_NAME,
 7252:                               &altNameExtension);
 7252:   if (rv != SECSuccess)
80486:     return false;
31588: 
31588:   san_arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
31588:   if (!san_arena)
80486:     return false;
 7879: 
 7252:   sanNameList = CERT_DecodeAltNameExtension(san_arena, &altNameExtension);
31588:   if (!sanNameList)
80486:     return false;
80486: 
80486:   SECITEM_FreeItem(&altNameExtension, false);
 7252: 
 7252:   CERTGeneralName *current = sanNameList;
 7252:   do {
 7252:     nsAutoString name;
 7252:     switch (current->type) {
 7252:       case certDNSName:
 7252:         name.AssignASCII((char*)current->name.other.data, current->name.other.len);
 7252:         if (!allNames.IsEmpty()) {
14197:           allNames.Append(NS_LITERAL_STRING(" , "));
14197:         }
10259:         ++nameCount;
 7252:         allNames.Append(name);
 7252:         break;
 7252: 
 7252:       case certIPAddress:
 7252:         {
 7252:           char buf[INET6_ADDRSTRLEN];
 7252:           PRNetAddr addr;
 7252:           if (current->name.other.len == 4) {
 7252:             addr.inet.family = PR_AF_INET;
 7252:             memcpy(&addr.inet.ip, current->name.other.data, current->name.other.len);
 7252:             PR_NetAddrToString(&addr, buf, sizeof(buf));
 7252:             name.AssignASCII(buf);
 7252:           } else if (current->name.other.len == 16) {
 7252:             addr.ipv6.family = PR_AF_INET6;
 7252:             memcpy(&addr.ipv6.ip, current->name.other.data, current->name.other.len);
 7252:             PR_NetAddrToString(&addr, buf, sizeof(buf));
 7252:             name.AssignASCII(buf);
 7252:           } else {
 7252:             /* invalid IP address */
 7252:           }
 7252:           if (!name.IsEmpty()) {
 7252:             if (!allNames.IsEmpty()) {
14197:               allNames.Append(NS_LITERAL_STRING(" , "));
14197:             }
10259:             ++nameCount;
 7252:             allNames.Append(name);
 7252:           }
 7252:           break;
 7252:         }
 7252: 
 7252:       default: // all other types of names are ignored
 7252:         break;
 7252:     }
 7252:     current = CERT_GetNextGeneralName(current);
 7252:   } while (current != sanNameList); // double linked
31588: 
80486:   PORT_FreeArena(san_arena, false);
80486:   return true;
 7252: }
 7879: 
 7879: static void
 7879: AppendErrorTextMismatch(const nsString &host,
 7879:                         nsIX509Cert* ix509,
 7879:                         nsINSSComponent *component,
 7879:                         nsString &returnedMessage)
 7879: {
 7879:   const PRUnichar *params[1];
 7879:   nsresult rv;
 7879: 
 7879:   CERTCertificate *nssCert = NULL;
 7879:   CERTCertificateCleaner nssCertCleaner(nssCert);
 7879: 
 7879:   nsCOMPtr<nsIX509Cert2> cert2 = do_QueryInterface(ix509, &rv);
 7879:   if (cert2)
 7879:     nssCert = cert2->GetCert();
 7879: 
 7879:   if (!nssCert) {
 7879:     // We are unable to extract the valid names, say "not valid for name".
 7879:     params[0] = host.get();
 7879:     nsString formattedString;
 7879:     rv = component->PIPBundleFormatStringFromName("certErrorMismatch", 
 7879:                                                   params, 1, 
 7879:                                                   formattedString);
 7879:     if (NS_SUCCEEDED(rv)) {
 7879:       returnedMessage.Append(formattedString);
 7879:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
 7879:     }
 7879:     return;
 7879:   }
 7879: 
 7879:   nsString allNames;
10259:   PRUint32 nameCount = 0;
79445:   bool useSAN = false;
 7879: 
 7879:   if (nssCert)
10259:     useSAN = GetSubjectAltNames(nssCert, component, allNames, nameCount);
 7252: 
 7252:   if (!useSAN) {
 7252:     char *certName = nsnull;
 7879:     // currently CERT_FindNSStringExtension is not being exported by NSS.
 7879:     // If it gets exported, enable the following line.
 7252:     //   certName = CERT_FindNSStringExtension(nssCert, SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME);
 7879:     // However, it has been discussed to treat the extension as obsolete and ignore it.
 7879:     if (!certName)
 7252:       certName = CERT_GetCommonName(&nssCert->subject);
 7879:     if (certName) {
10259:       ++nameCount;
 7252:       allNames.AssignASCII(certName);
 7252:       PORT_Free(certName);
 7252:     }
 7879:   }
 7252: 
10259:   if (nameCount > 1) {
 7252:     nsString message;
 7252:     rv = component->GetPIPNSSBundleString("certErrorMismatchMultiple", 
 7252:                                           message);
 7252:     if (NS_SUCCEEDED(rv)) {
 7252:       returnedMessage.Append(message);
 7252:       returnedMessage.Append(NS_LITERAL_STRING("\n  "));
 7252:       returnedMessage.Append(allNames);
 7252:       returnedMessage.Append(NS_LITERAL_STRING("  \n"));
 7252:     }
 7252:   }
10259:   else if (nameCount == 1) {
 7879:     const PRUnichar *params[1];
 7252:     params[0] = allNames.get();
 6597: 
 6597:     nsString formattedString;
79869:     rv = component->PIPBundleFormatStringFromName("certErrorMismatchSingle2", 
 6597:                                                   params, 1, 
 6597:                                                   formattedString);
 7252:     if (NS_SUCCEEDED(rv)) {
 6597:       returnedMessage.Append(formattedString);
 6597:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
 6597:     }
 6597:   }
10259:   else { // nameCount == 0
10259:     nsString message;
10259:     nsresult rv = component->GetPIPNSSBundleString("certErrorMismatchNoNames",
10259:                                                    message);
10259:     if (NS_SUCCEEDED(rv)) {
10259:       returnedMessage.Append(message);
10259:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
10259:     }
10259:   }
 7252: }
 6597: 
 7879: static void
 7879: GetDateBoundary(nsIX509Cert* ix509,
 7879:                 nsString &formattedDate,
33222:                 nsString &nowDate,
79445:                 bool &trueExpired_falseNotYetValid)
 6597: {
80486:   trueExpired_falseNotYetValid = true;
 7879:   formattedDate.Truncate();
 7879: 
 6597:   PRTime notAfter, notBefore, timeToUse;
 6597:   nsCOMPtr<nsIX509CertValidity> validity;
 7879:   nsresult rv;
 6597: 
 6597:   rv = ix509->GetValidity(getter_AddRefs(validity));
 6597:   if (NS_FAILED(rv))
 7879:     return;
 6597: 
 6597:   rv = validity->GetNotAfter(&notAfter);
 6597:   if (NS_FAILED(rv))
 7879:     return;
 6597: 
 6597:   rv = validity->GetNotBefore(&notBefore);
 6597:   if (NS_FAILED(rv))
 7879:     return;
 7879: 
33222:   PRTime now = PR_Now();
33222:   if (LL_CMP(now, >, notAfter)) {
 6597:     timeToUse = notAfter;
 6597:   } else {
 6597:     timeToUse = notBefore;
80486:     trueExpired_falseNotYetValid = false;
 6597:   }
 6597: 
33222:   nsCOMPtr<nsIDateTimeFormat> dateTimeFormat(do_CreateInstance(NS_DATETIMEFORMAT_CONTRACTID, &rv));
 6597:   if (NS_FAILED(rv))
 7879:     return;
 6597: 
33222:   dateTimeFormat->FormatPRTime(nsnull, kDateFormatShort, 
 6597:                                kTimeFormatNoSeconds, timeToUse, 
 6597:                                formattedDate);
33222:   dateTimeFormat->FormatPRTime(nsnull, kDateFormatShort,
33222:                                kTimeFormatNoSeconds, now,
33222:                                nowDate);
 7879: }
 7879: 
 7879: static void
 7879: AppendErrorTextTime(nsIX509Cert* ix509,
 7879:                     nsINSSComponent *component,
 7879:                     nsString &returnedMessage)
 7879: {
33222:   nsAutoString formattedDate, nowDate;
79445:   bool trueExpired_falseNotYetValid;
33222:   GetDateBoundary(ix509, formattedDate, nowDate, trueExpired_falseNotYetValid);
33222: 
33222:   const PRUnichar *params[2];
 7879:   params[0] = formattedDate.get(); // might be empty, if helper function had a problem 
33222:   params[1] = nowDate.get();
 7879: 
 7879:   const char *key = trueExpired_falseNotYetValid ? 
33222:                     "certErrorExpiredNow" : "certErrorNotYetValidNow";
 7879:   nsresult rv;
 6597:   nsString formattedString;
33222:   rv = component->PIPBundleFormatStringFromName(
33222:            key,
33222:            params, 
80467:            ArrayLength(params),
33222:            formattedString);
 6597:   if (NS_SUCCEEDED(rv))
 6597:   {
 6597:     returnedMessage.Append(formattedString);
 6597:     returnedMessage.Append(NS_LITERAL_STRING("\n"));
 6597:   }
 6597: }
 6597: 
 7879: static void
 7879: AppendErrorTextCode(PRErrorCode errorCodeToReport,
 7879:                     nsINSSComponent *component,
 7879:                     nsString &returnedMessage)
 7879: {
 6597:   const char *codeName = nsNSSErrors::getDefaultErrorStringName(errorCodeToReport);
 6597:   if (codeName)
 6597:   {
 6597:     nsCString error_id(codeName);
 6597:     ToLowerCase(error_id);
 6597:     NS_ConvertASCIItoUTF16 idU(error_id);
 6597: 
 7879:     const PRUnichar *params[1];
 7252:     params[0] = idU.get();
 7252: 
 7252:     nsString formattedString;
 7879:     nsresult rv;
 7252:     rv = component->PIPBundleFormatStringFromName("certErrorCodePrefix", 
 7252:                                                   params, 1, 
 7252:                                                   formattedString);
 7252:     if (NS_SUCCEEDED(rv)) {
 7252:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
 7252:       returnedMessage.Append(formattedString);
 7252:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
 7252:     }
 7252:     else {
 6597:       returnedMessage.Append(NS_LITERAL_STRING(" ("));
 6597:       returnedMessage.Append(idU);
 6597:       returnedMessage.Append(NS_LITERAL_STRING(")"));
 6597:     }
 7252:   }
 7879: }
 7879: 
83081: /* Formats an error message for overridable certificate errors (of type
83081:  * OverridableCertErrorMessage). Use formatPlainErrorMessage to format
83081:  * non-overridable cert errors and non-cert-related errors.
83081:  */
83081: static nsresult
83081: formatOverridableCertErrorMessage(nsISSLStatus & sslStatus,
 7879:                                   PRErrorCode errorCodeToReport, 
83081:                                   const nsXPIDLCString & host, PRInt32 port,
 7879:                                   nsString & returnedMessage)
 7879: {
 7879:   const PRUnichar *params[1];
 7879:   nsresult rv;
83081:   nsAutoString hostWithPort;
83081:   nsAutoString hostWithoutPort;
 7879: 
79869:   // For now, hide port when it's 443 and we're reporting the error.
79869:   // In the future a better mechanism should be used
 7879:   // to make a decision about showing the port number, possibly by requiring
 7879:   // the context object to implement a specific interface.
 7879:   // The motivation is that Mozilla browser would like to hide the port number
 7879:   // in error pages in the common case.
 7879:   
83081:   hostWithoutPort.AppendASCII(host);
83081:   if (port == 443) {
83081:     params[0] = hostWithoutPort.get();
83081:   } else {
83081:     hostWithPort.AppendASCII(host);
83081:     hostWithPort.Append(':');
83081:     hostWithPort.AppendInt(port);
 7879:     params[0] = hostWithPort.get();
83081:   }
 7879: 
79873:   nsCOMPtr<nsINSSComponent> component = do_GetService(kNSSComponentCID, &rv);
83081:   NS_ENSURE_SUCCESS(rv, rv);
83081: 
83081:   returnedMessage.Truncate();
79873:   rv = component->PIPBundleFormatStringFromName("certErrorIntro", params, 1,
83081:                                                 returnedMessage);
83081:   NS_ENSURE_SUCCESS(rv, rv);
83081: 
 7879:   returnedMessage.Append(NS_LITERAL_STRING("\n\n"));
83081: 
83081:   nsRefPtr<nsIX509Cert> ix509;
83081:   rv = sslStatus.GetServerCert(getter_AddRefs(ix509));
83081:   NS_ENSURE_SUCCESS(rv, rv);
83081: 
83081:   bool isUntrusted;
83081:   rv = sslStatus.GetIsUntrusted(&isUntrusted);
83081:   NS_ENSURE_SUCCESS(rv, rv);
83081:   if (isUntrusted) {
83081:     AppendErrorTextUntrusted(errorCodeToReport, hostWithoutPort, ix509, 
 7879:                              component, returnedMessage);
 7879:   }
 7879: 
83081:   bool isDomainMismatch;
83081:   rv = sslStatus.GetIsDomainMismatch(&isDomainMismatch);
83081:   NS_ENSURE_SUCCESS(rv, rv);
83081:   if (isDomainMismatch) {
83081:     AppendErrorTextMismatch(hostWithoutPort, ix509, component, returnedMessage);
83081:   }
83081: 
83081:   bool isNotValidAtThisTime;
83081:   rv = sslStatus.GetIsNotValidAtThisTime(&isNotValidAtThisTime);
83081:   NS_ENSURE_SUCCESS(rv, rv);
83081:   if (isNotValidAtThisTime) {
 7879:     AppendErrorTextTime(ix509, component, returnedMessage);
 7879:   }
 7879: 
 7879:   AppendErrorTextCode(errorCodeToReport, component, returnedMessage);
83081: 
83081:   return NS_OK;
 6597: }
 6597: 
79869: static void
83081: nsHandleSSLError(nsNSSSocketInfo *socketInfo, PRErrorCode err)
    1: {
79873:   if (!NS_IsMainThread()) {
79873:     NS_ERROR("nsHandleSSLError called off the main thread");
79873:     return;
79873:   }
79873: 
83083:   // SetCanceled is only called by the main thread or the socket transport
83083:   // thread. Whenever this function is called on the main thread, the SSL
83083:   // thread is blocked on it. So, no mutex is necessary for
83083:   // SetCanceled()/GetError*().
83081:   if (socketInfo->GetErrorCode()) {
    1:     // If the socket has been flagged as canceled,
83081:     // the code who did was responsible for setting the error code.
79869:     return;
    1:   }
    1: 
    1:   nsresult rv;
    1:   NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
    1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
    1:   if (NS_FAILED(rv))
79869:     return;
    1: 
    1:   nsXPIDLCString hostName;
    1:   socketInfo->GetHostName(getter_Copies(hostName));
    1: 
 7252:   PRInt32 port;
 7252:   socketInfo->GetPort(&port);
    1: 
10284:   // Try to get a nsISSLErrorListener implementation from the socket consumer.
14244:   nsCOMPtr<nsIInterfaceRequestor> cb;
14244:   socketInfo->GetNotificationCallbacks(getter_AddRefs(cb));
14244:   if (cb) {
79873:     nsCOMPtr<nsISSLErrorListener> sel = do_GetInterface(cb);
10284:     if (sel) {
10284:       nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(socketInfo);
10284:       nsCString hostWithPortString = hostName;
10284:       hostWithPortString.AppendLiteral(":");
10284:       hostWithPortString.AppendInt(port);
83081:     
83081:       bool suppressMessage = false; // obsolete, ignored
79873:       rv = sel->NotifySSLError(csi, err, hostWithPortString, &suppressMessage);
83081:     }
83081:   }
83081: 
83083:   socketInfo->SetCanceled(err, PlainErrorMessage);
83083: }
83083: 
83083: namespace {
83083: 
83083: nsNSSSocketInfo *
83083: getSocketInfoIfRunning(PRFileDesc * fd,
83083:                        const nsNSSShutDownPreventionLock & /*proofOfLock*/)
83083: {
83083:   if (!fd || !fd->lower || !fd->secret ||
83083:       fd->identity != nsSSLIOLayerHelpers::nsSSLIOLayerIdentity) {
83083:     NS_ERROR("bad file descriptor passed to getSocketInfoIfRunning");
83083:     PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);
83083:     return nsnull;
83083:   }
83083: 
83083:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
83083: 
83083:   if (socketInfo->isAlreadyShutDown() || socketInfo->isPK11LoggedOut()) {
83083:     PR_SetError(PR_SOCKET_SHUTDOWN_ERROR, 0);
83083:     return nsnull;
83083:   }
83083: 
83083:   if (socketInfo->GetErrorCode()) {
83083:     PRErrorCode err = socketInfo->GetErrorCode();
83083:     // If we get here, it is probably because cert verification failed and this
83083:     // is the first I/O attempt since that failure.
83083:     PR_SetError(err, 0);
83083:     return nsnull;
83083:   }
83083: 
83083:   return socketInfo;
83083: }
83083: 
83083: } // unnnamed namespace
 6597: 
    1: static PRStatus PR_CALLBACK
    1: nsSSLIOLayerConnect(PRFileDesc* fd, const PRNetAddr* addr,
    1:                     PRIntervalTime timeout)
    1: {
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] connecting SSL socket\n", (void*)fd));
    1:   nsNSSShutDownPreventionLock locker;
83083:   if (!getSocketInfoIfRunning(fd, locker))
    1:     return PR_FAILURE;
    1:   
83083:   PRStatus status = fd->lower->methods->connect(fd->lower, addr, timeout);
    1:   if (status != PR_SUCCESS) {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("[%p] Lower layer connect error: %d\n",
    1:                                       (void*)fd, PR_GetError()));
    1:     return status;
    1:   }
    1: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] Connect\n", (void*)fd));
    1:   return status;
    1: }
    1: 
28629: // nsPSMRememberCertErrorsTable
28629: 
28629: nsPSMRememberCertErrorsTable::nsPSMRememberCertErrorsTable()
28629: {
28629:   mErrorHosts.Init(16);
28629: }
28629: 
28629: nsresult
28629: nsPSMRememberCertErrorsTable::GetHostPortKey(nsNSSSocketInfo* infoObject,
28629:                                              nsCAutoString &result)
28629: {
28629:   nsresult rv;
28629: 
28629:   result.Truncate();
28629: 
28629:   nsXPIDLCString hostName;
28629:   rv = infoObject->GetHostName(getter_Copies(hostName));
28629:   NS_ENSURE_SUCCESS(rv, rv);
28629: 
28629:   PRInt32 port;
28629:   rv = infoObject->GetPort(&port);
28629:   NS_ENSURE_SUCCESS(rv, rv);
28629: 
28629:   result.Assign(hostName);
28629:   result.Append(':');
28629:   result.AppendInt(port);
28629: 
28629:   return NS_OK;
28629: }
28629: 
28629: void
28629: nsPSMRememberCertErrorsTable::RememberCertHasError(nsNSSSocketInfo* infoObject,
28629:                                                    nsSSLStatus* status,
28629:                                                    SECStatus certVerificationResult)
28629: {
28629:   nsresult rv;
28629: 
28629:   nsCAutoString hostPortKey;
28629:   rv = GetHostPortKey(infoObject, hostPortKey);
28629:   if (NS_FAILED(rv))
28629:     return;
28629: 
28629:   if (certVerificationResult != SECSuccess) {
28629:     NS_ASSERTION(status,
28629:         "Must have nsSSLStatus object when remembering flags");
28629: 
28629:     if (!status)
28629:       return;
28629: 
28629:     CertStateBits bits;
28629:     bits.mIsDomainMismatch = status->mIsDomainMismatch;
28629:     bits.mIsNotValidAtThisTime = status->mIsNotValidAtThisTime;
28629:     bits.mIsUntrusted = status->mIsUntrusted;
28629:     mErrorHosts.Put(hostPortKey, bits);
28629:   }
28629:   else {
28629:     mErrorHosts.Remove(hostPortKey);
28629:   }
28629: }
28629: 
28629: void
28629: nsPSMRememberCertErrorsTable::LookupCertErrorBits(nsNSSSocketInfo* infoObject,
28629:                                                   nsSSLStatus* status)
28629: {
28629:   // Get remembered error bits from our cache, because of SSL session caching
28629:   // the NSS library potentially hasn't notified us for this socket.
28629:   if (status->mHaveCertErrorBits)
28629:     // Rather do not modify bits if already set earlier
28629:     return;
28629: 
28629:   nsresult rv;
28629: 
28629:   nsCAutoString hostPortKey;
28629:   rv = GetHostPortKey(infoObject, hostPortKey);
28629:   if (NS_FAILED(rv))
28629:     return;
28629: 
28629:   CertStateBits bits;
28629:   if (!mErrorHosts.Get(hostPortKey, &bits))
28629:     // No record was found, this host had no cert errors
28629:     return;
28629: 
28629:   // This host had cert errors, update the bits correctly
80486:   status->mHaveCertErrorBits = true;
28629:   status->mIsDomainMismatch = bits.mIsDomainMismatch;
28629:   status->mIsNotValidAtThisTime = bits.mIsNotValidAtThisTime;
28629:   status->mIsUntrusted = bits.mIsUntrusted;
28629: }
28629: 
30463: void
30463: nsSSLIOLayerHelpers::getSiteKey(nsNSSSocketInfo *socketInfo, nsCSubstring &key)
30463: {
30463:   PRInt32 port;
30463:   socketInfo->GetPort(&port);
30463: 
30463:   nsXPIDLCString host;
30463:   socketInfo->GetHostName(getter_Copies(host));
30463: 
30463:   key = host + NS_LITERAL_CSTRING(":") + nsPrintfCString("%d", port);
30463: }
30463: 
    1: // Call this function to report a site that is possibly TLS intolerant.
    1: // This function will return true, if the given socket is currently using TLS.
79445: bool
    1: nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(PRFileDesc* ssl_layer_fd, nsNSSSocketInfo *socketInfo)
    1: {
80486:   PRBool currentlyUsesTLS = false;
    1: 
30463:   nsCAutoString key;
30463:   getSiteKey(socketInfo, key);
30463: 
    1:   SSL_OptionGet(ssl_layer_fd, SSL_ENABLE_TLS, &currentlyUsesTLS);
30463:   if (!currentlyUsesTLS) {
30463:     // We were not using TLS but failed with an intolerant error using
30463:     // a different protocol. To give TLS a try on next connection attempt again
30463:     // drop this site from the list of intolerant sites. TLS failure might be 
30463:     // caused only by a traffic congestion while the server is TLS tolerant.
30463:     removeIntolerantSite(key);
80486:     return false;
30463:   }
23777: 
79445:   PRBool enableSSL3 = false;
23777:   SSL_OptionGet(ssl_layer_fd, SSL_ENABLE_SSL3, &enableSSL3);
76375:   if (enableSSL3) {
30463:     // Add this site to the list of TLS intolerant sites.
30463:     addIntolerantSite(key);
30463:   }
30463:   
30463:   return currentlyUsesTLS;
30463: }
30463: 
30463: void
30463: nsSSLIOLayerHelpers::rememberTolerantSite(PRFileDesc* ssl_layer_fd, 
30463:                                           nsNSSSocketInfo *socketInfo)
23777: {
80486:   PRBool usingSecurity = false;
80486:   PRBool currentlyUsesTLS = false;
30463:   SSL_OptionGet(ssl_layer_fd, SSL_SECURITY, &usingSecurity);
30463:   SSL_OptionGet(ssl_layer_fd, SSL_ENABLE_TLS, &currentlyUsesTLS);
30463:   if (!usingSecurity || !currentlyUsesTLS) {
30463:     return;
30463:   }
30463: 
    1:   nsCAutoString key;
30463:   getSiteKey(socketInfo, key);
30463: 
64576:   MutexAutoLock lock(*mutex);
30463:   nsSSLIOLayerHelpers::mTLSTolerantSites->Put(key);
    1: }
    1: 
    1: static PRStatus PR_CALLBACK
    1: nsSSLIOLayerClose(PRFileDesc *fd)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd)
    1:     return PR_FAILURE;
    1: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] Shutting down socket\n", (void*)fd));
    1:   
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
83083:   return socketInfo->CloseSocketAndDestroy(locker);
83083: }
83083: 
83083: PRStatus nsNSSSocketInfo::CloseSocketAndDestroy(
83083:   const nsNSSShutDownPreventionLock & /*proofOfLock*/)
    1: {
    1:   nsNSSShutDownList::trackSSLSocketClose();
    1: 
    1:   PRFileDesc* popped = PR_PopIOLayer(mFd, PR_TOP_IO_LAYER);
    1: 
    1:   PRStatus status = mFd->methods->close(mFd);
83083:   
83083:   // the nsNSSSocketInfo instance can out-live the connection, so we need some
83083:   // indication that the connection has been closed. mFd == nsnull is that
83083:   // indication. This is needed, for example, when the connection is closed
83083:   // before we have finished validating the server's certificate.
83083:   mFd = nsnull;
83083:   
    1:   if (status != PR_SUCCESS) return status;
    1: 
    1:   popped->identity = PR_INVALID_IO_LAYER;
    1:   NS_RELEASE_THIS();
    1:   popped->dtor(popped);
    1: 
    1:   return PR_SUCCESS;
    1: }
    1: 
    1: #if defined(DEBUG_SSL_VERBOSE) && defined(DUMP_BUFFER)
    1: /* Dumps a (potentially binary) buffer using SSM_DEBUG. 
    1:    (We could have used the version in ssltrace.c, but that's
    1:    specifically tailored to SSLTRACE. Sigh. */
    1: #define DUMPBUF_LINESIZE 24
    1: static void
    1: nsDumpBuffer(unsigned char *buf, PRIntn len)
    1: {
    1:   char hexbuf[DUMPBUF_LINESIZE*3+1];
    1:   char chrbuf[DUMPBUF_LINESIZE+1];
    1:   static const char *hex = "0123456789abcdef";
    1:   PRIntn i = 0, l = 0;
    1:   char ch, *c, *h;
    1:   if (len == 0)
    1:     return;
    1:   hexbuf[DUMPBUF_LINESIZE*3] = '\0';
    1:   chrbuf[DUMPBUF_LINESIZE] = '\0';
    1:   (void) memset(hexbuf, 0x20, DUMPBUF_LINESIZE*3);
    1:   (void) memset(chrbuf, 0x20, DUMPBUF_LINESIZE);
    1:   h = hexbuf;
    1:   c = chrbuf;
    1: 
    1:   while (i < len)
    1:   {
    1:     ch = buf[i];
    1: 
    1:     if (l == DUMPBUF_LINESIZE)
    1:     {
    1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("%s%s\n", hexbuf, chrbuf));
    1:       (void) memset(hexbuf, 0x20, DUMPBUF_LINESIZE*3);
    1:       (void) memset(chrbuf, 0x20, DUMPBUF_LINESIZE);
    1:       h = hexbuf;
    1:       c = chrbuf;
    1:       l = 0;
    1:     }
    1: 
    1:     /* Convert a character to hex. */
    1:     *h++ = hex[(ch >> 4) & 0xf];
    1:     *h++ = hex[ch & 0xf];
    1:     h++;
    1:         
    1:     /* Put the character (if it's printable) into the character buffer. */
    1:     if ((ch >= 0x20) && (ch <= 0x7e))
    1:       *c++ = ch;
    1:     else
    1:       *c++ = '.';
    1:     i++; l++;
    1:   }
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("%s%s\n", hexbuf, chrbuf));
    1: }
    1: 
    1: #define DEBUG_DUMP_BUFFER(buf,len) nsDumpBuffer(buf,len)
    1: #else
    1: #define DEBUG_DUMP_BUFFER(buf,len)
    1: #endif
    1: 
79445: static bool
79445: isNonSSLErrorThatWeAllowToRetry(PRInt32 err, bool withInitialCleartext)
    1: {
    1:   switch (err)
    1:   {
    1:     case PR_CONNECT_RESET_ERROR:
    1:       if (!withInitialCleartext)
80486:         return true;
    1:       break;
    1:     
    1:     case PR_END_OF_FILE_ERROR:
80486:       return true;
80486:   }
80486: 
80486:   return false;
    1: }
    1: 
79445: static bool
79445: isTLSIntoleranceError(PRInt32 err, bool withInitialCleartext)
    1: {
    1:   // This function is supposed to decide, which error codes should
    1:   // be used to conclude server is TLS intolerant.
    1:   // Note this only happens during the initial SSL handshake.
    1:   // 
    1:   // When not using a proxy we'll see a connection reset error.
    1:   // When using a proxy, we'll see an end of file error.
    1:   // In addition check for some error codes where it is reasonable
    1:   // to retry without TLS.
    1: 
    1:   if (isNonSSLErrorThatWeAllowToRetry(err, withInitialCleartext))
80486:     return true;
    1: 
    1:   switch (err)
    1:   {
    1:     case SSL_ERROR_BAD_MAC_ALERT:
    1:     case SSL_ERROR_BAD_MAC_READ:
    1:     case SSL_ERROR_HANDSHAKE_FAILURE_ALERT:
    1:     case SSL_ERROR_HANDSHAKE_UNEXPECTED_ALERT:
    1:     case SSL_ERROR_CLIENT_KEY_EXCHANGE_FAILURE:
    1:     case SSL_ERROR_ILLEGAL_PARAMETER_ALERT:
    1:     case SSL_ERROR_NO_CYPHER_OVERLAP:
    1:     case SSL_ERROR_BAD_SERVER:
    1:     case SSL_ERROR_BAD_BLOCK_PADDING:
    1:     case SSL_ERROR_UNSUPPORTED_VERSION:
    1:     case SSL_ERROR_PROTOCOL_VERSION_ALERT:
    1:     case SSL_ERROR_RX_MALFORMED_FINISHED:
    1:     case SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE:
    1:     case SSL_ERROR_DECODE_ERROR_ALERT:
    1:     case SSL_ERROR_RX_UNKNOWN_ALERT:
80486:       return true;
80486:   }
80486:   
80486:   return false;
    1: }
    1: 
79873: class SSLErrorRunnable : public SyncRunnableBase
79873: {
79873:  public:
79873:   SSLErrorRunnable(nsNSSSocketInfo * infoObject, PRErrorCode errorCode)
79873:     : mInfoObject(infoObject), mErrorCode(errorCode)
79873:   {
79873:   }
79873: 
79873:   virtual void RunOnTargetThread()
79873:   {
79873:     nsHandleSSLError(mInfoObject, mErrorCode);
79873:   }
79873:   
79873:   nsRefPtr<nsNSSSocketInfo> mInfoObject;
79873:   const PRErrorCode mErrorCode;
79873: };
79873: 
83083: PRInt32 checkHandshake(PRInt32 bytesTransfered, bool wasReading,
    1:                        PRFileDesc* ssl_layer_fd,
    1:                        nsNSSSocketInfo *socketInfo)
    1: {
    1:   // This is where we work around all of those SSL servers that don't 
    1:   // conform to the SSL spec and shutdown a connection when we request
    1:   // SSL v3.1 (aka TLS).  The spec says the client says what version
    1:   // of the protocol we're willing to perform, in our case SSL v3.1
    1:   // In its response, the server says which version it wants to perform.
    1:   // Many servers out there only know how to do v3.0.  Next, we're supposed
    1:   // to send back the version of the protocol we requested (ie v3.1).  At
    1:   // this point many servers's implementations are broken and they shut
    1:   // down the connection when they don't see the version they sent back.
    1:   // This is supposed to prevent a man in the middle from forcing one
    1:   // side to dumb down to a lower level of the protocol.  Unfortunately,
    1:   // there are enough broken servers out there that such a gross work-around
    1:   // is necessary.  :(
    1: 
    1:   // Additional comment added in August 2006:
    1:   // When we begun to use TLS hello extensions, we encountered a new class of
    1:   // broken server, which simply stall for a very long time.
    1:   // We would like to shorten the timeout, but limit this shorter timeout 
    1:   // to the handshake phase.
    1:   // When we arrive here for the first time (for a given socket),
    1:   // we know the connection is established, and the application code
    1:   // tried the first read or write. This triggers the beginning of the
    1:   // SSL handshake phase at the SSL FD level.
    1:   // We'll make a note of the current time,
    1:   // and use this to measure the elapsed time since handshake begin.
    1: 
    1:   // Do NOT assume TLS intolerance on a closed connection after bad cert ui was shown.
    1:   // Simply retry.
    1:   // This depends on the fact that Cert UI will not be shown again,
    1:   // should the user override the bad cert.
    1: 
79445:   bool handleHandshakeResultNow;
    1:   socketInfo->GetHandshakePending(&handleHandshakeResultNow);
    1: 
79445:   bool wantRetry = false;
    1: 
    1:   if (0 > bytesTransfered) {
    1:     PRInt32 err = PR_GetError();
    1: 
    1:     if (handleHandshakeResultNow) {
    1:       if (PR_WOULD_BLOCK_ERROR == err) {
80486:         socketInfo->SetHandshakeInProgress(true);
    1:         return bytesTransfered;
    1:       }
    1: 
    1:       if (!wantRetry // no decision yet
    1:           && isTLSIntoleranceError(err, socketInfo->GetHasCleartextPhase()))
    1:       {
    1:         wantRetry = nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(ssl_layer_fd, socketInfo);
    1:       }
    1:     }
    1:     
83083:     // This is the common place where we trigger non-cert-errors on a SSL
83083:     // socket. This might be reached at any time of the connection.
83083:     //
83083:     // The socketInfo->GetErrorCode() check is here to ensure we don't try to
83083:     // do the synchronous dispatch to the main thread unnecessarily after we've
83083:     // already handled a certificate error. (SSLErrorRunnable calls
83083:     // nsHandleSSLError, which has logic to avoid replacing the error message,
83083:     // so without the !socketInfo->GetErrorCode(), it would just be an
83083:     // expensive no-op.)
83083:     if (!wantRetry && (IS_SSL_ERROR(err) || IS_SEC_ERROR(err)) &&
83083:         !socketInfo->GetErrorCode()) {
79873:       nsRefPtr<SyncRunnableBase> runnable = new SSLErrorRunnable(socketInfo,
79873:                                                                  err);
79873:       (void) runnable->DispatchToMainThreadAndWait();
    1:     }
    1:   }
    1:   else if (wasReading && 0 == bytesTransfered) // zero bytes on reading, socket closed
    1:   {
    1:     if (handleHandshakeResultNow)
    1:     {
    1:       if (!wantRetry // no decision yet
    1:           && !socketInfo->GetHasCleartextPhase()) // mirror PR_CONNECT_RESET_ERROR treament
    1:       {
    1:         wantRetry = 
    1:           nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(ssl_layer_fd, socketInfo);
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (wantRetry) {
    1:     // We want to cause the network layer to retry the connection.
    1:     PR_SetError(PR_CONNECT_RESET_ERROR, 0);
    1:     if (wasReading)
    1:       bytesTransfered = -1;
    1:   }
    1: 
    1:   // TLS intolerant servers only cause the first transfer to fail, so let's 
    1:   // set the HandshakePending attribute to false so that we don't try the logic
    1:   // above again in a subsequent transfer.
    1:   if (handleHandshakeResultNow) {
80486:     socketInfo->SetHandshakePending(false);
80486:     socketInfo->SetHandshakeInProgress(false);
    1:   }
    1:   
    1:   return bytesTransfered;
    1: }
    1: 
    1: static PRInt16 PR_CALLBACK
    1: nsSSLIOLayerPoll(PRFileDesc * fd, PRInt16 in_flags, PRInt16 *out_flags)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1: 
    1:   if (!out_flags)
    1:   {
    1:     NS_WARNING("nsSSLIOLayerPoll called with null out_flags");
    1:     return 0;
    1:   }
    1: 
    1:   *out_flags = 0;
    1: 
83083:   nsNSSSocketInfo * socketInfo = getSocketInfoIfRunning(fd, locker);
83083:   if (!socketInfo) {
83083:     // If we get here, it is probably because certificate validation failed
83083:     // and this is the first I/O operation after the failure. 
83083:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
83083:             ("[%p] polling SSL socket right after certificate verification failed "
83083:                   "or NSS shutdown or SDR logout %d\n",
83083:              fd, (int) in_flags));
83083: 
83083:     NS_ASSERTION(in_flags & PR_POLL_EXCEPT,
83083:                  "caller did not poll for EXCEPT (canceled)");
83083:     // Since this poll method cannot return errors, we want the caller to call
83083:     // PR_Send/PR_Recv right away to get the error, so we tell that we are
83083:     // ready for whatever I/O they are asking for. (See getSocketInfoIfRunning). 
83083:     *out_flags = in_flags | PR_POLL_EXCEPT; // see also bug 480619 
83083:     return in_flags;
83083:   }
83083: 
83083:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
83083:          (socketInfo->IsWaitingForCertVerification()
83083:             ?  "[%p] polling SSL socket during certificate verification using lower %d\n"
83083:             :  "[%p] poll SSL socket using lower %d\n",
83083:          fd, (int) in_flags));
83083: 
83083:   if (socketInfo->HandshakeTimeout()) {
83083:     NS_ASSERTION(in_flags & PR_POLL_EXCEPT,
83083:                  "caller did not poll for EXCEPT (handshake timeout)");
83083:     *out_flags = in_flags | PR_POLL_EXCEPT;
83083:     return in_flags;
83083:   }
83083: 
83083:   // We want the handshake to continue during certificate validation, so we
83083:   // don't need to do anything special here. libssl automatically blocks when
83083:   // it reaches any point that would be unsafe to send/receive something before
83083:   // cert validation is complete.
83083:   PRInt16 result = fd->lower->methods->poll(fd->lower, in_flags, out_flags);
83083:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] poll SSL socket returned %d\n",
83083:                                     (void*)fd, (int) result));
83083:   return result;
    1: }
    1: 
79445: bool nsSSLIOLayerHelpers::nsSSLIOLayerInitialized = false;
    1: PRDescIdentity nsSSLIOLayerHelpers::nsSSLIOLayerIdentity;
    1: PRIOMethods nsSSLIOLayerHelpers::nsSSLIOLayerMethods;
64576: Mutex *nsSSLIOLayerHelpers::mutex = nsnull;
    1: nsCStringHashSet *nsSSLIOLayerHelpers::mTLSIntolerantSites = nsnull;
30463: nsCStringHashSet *nsSSLIOLayerHelpers::mTLSTolerantSites = nsnull;
28629: nsPSMRememberCertErrorsTable *nsSSLIOLayerHelpers::mHostsWithCertErrors = nsnull;
37963: nsCStringHashSet *nsSSLIOLayerHelpers::mRenegoUnrestrictedSites = nsnull;
79445: bool nsSSLIOLayerHelpers::mTreatUnsafeNegotiationAsBroken = false;
41739: PRInt32 nsSSLIOLayerHelpers::mWarnLevelMissingRFC5746 = 1;
    1: 
    1: static PRIntn _PSM_InvalidInt(void)
    1: {
    1:     PR_ASSERT(!"I/O method is invalid");
    1:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
    1:     return -1;
    1: }
    1: 
    1: static PRInt64 _PSM_InvalidInt64(void)
    1: {
    1:     PR_ASSERT(!"I/O method is invalid");
    1:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
    1:     return -1;
    1: }
    1: 
    1: static PRStatus _PSM_InvalidStatus(void)
    1: {
    1:     PR_ASSERT(!"I/O method is invalid");
    1:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
    1:     return PR_FAILURE;
    1: }
    1: 
    1: static PRFileDesc *_PSM_InvalidDesc(void)
    1: {
    1:     PR_ASSERT(!"I/O method is invalid");
    1:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
    1:     return NULL;
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMGetsockname(PRFileDesc *fd, PRNetAddr *addr)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
83083:   if (!getSocketInfoIfRunning(fd, locker))
    1:     return PR_FAILURE;
83083: 
83083:   return fd->lower->methods->getsockname(fd->lower, addr);
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMGetpeername(PRFileDesc *fd, PRNetAddr *addr)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
83083:   if (!getSocketInfoIfRunning(fd, locker))
    1:     return PR_FAILURE;
83083: 
83083:   return fd->lower->methods->getpeername(fd->lower, addr);
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMGetsocketoption(PRFileDesc *fd, 
    1:                                         PRSocketOptionData *data)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
83083:   if (!getSocketInfoIfRunning(fd, locker))
    1:     return PR_FAILURE;
83083: 
83083:   return fd->lower->methods->getsocketoption(fd, data);
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMSetsocketoption(PRFileDesc *fd, 
    1:                                         const PRSocketOptionData *data)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
83083:   if (!getSocketInfoIfRunning(fd, locker))
    1:     return PR_FAILURE;
83083: 
83083:   return fd->lower->methods->setsocketoption(fd, data);
    1: }
    1: 
    1: static PRInt32 PR_CALLBACK PSMRecv(PRFileDesc *fd, void *buf, PRInt32 amount,
    1:     PRIntn flags, PRIntervalTime timeout)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
83083:   nsNSSSocketInfo *socketInfo = getSocketInfoIfRunning(fd, locker);
83083:   if (!socketInfo)
    1:     return -1;
83083: 
83083:   if (flags != PR_MSG_PEEK && flags != 0) {
    1:     PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
    1:     return -1;
    1:   }
    1: 
83083:   PRInt32 bytesRead = fd->lower->methods->recv(fd->lower, buf, amount, flags,
83083:                                                timeout);
83083: 
83083:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] read %d bytes\n", (void*)fd, bytesRead));
83083: 
83083: #ifdef DEBUG_SSL_VERBOSE
83083:   DEBUG_DUMP_BUFFER((unsigned char*)buf, bytesRead);
83083: #endif
83083: 
83083:   return checkHandshake(bytesRead, true, fd, socketInfo);
    1: }
    1: 
    1: static PRInt32 PR_CALLBACK PSMSend(PRFileDesc *fd, const void *buf, PRInt32 amount,
    1:     PRIntn flags, PRIntervalTime timeout)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
83083:   nsNSSSocketInfo *socketInfo = getSocketInfoIfRunning(fd, locker);
83083:   if (!socketInfo)
    1:     return -1;
    1: 
    1:   if (flags != 0) {
    1:     PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
    1:     return -1;
    1:   }
    1: 
83083: #ifdef DEBUG_SSL_VERBOSE
83083:   DEBUG_DUMP_BUFFER((unsigned char*)buf, amount);
83083: #endif
83083: 
83083:   PRInt32 bytesWritten = fd->lower->methods->send(fd->lower, buf, amount,
83083:                                                   flags, timeout);
83083: 
83083:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] wrote %d bytes\n",
83083:          fd, bytesWritten));
83083: 
83083:   return checkHandshake(bytesWritten, false, fd, socketInfo);
    1: }
    1: 
    1: static PRInt32 PR_CALLBACK
    1: nsSSLIOLayerRead(PRFileDesc* fd, void* buf, PRInt32 amount)
    1: {
    1:   return PSMRecv(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
    1: }
    1: 
    1: static PRInt32 PR_CALLBACK
    1: nsSSLIOLayerWrite(PRFileDesc* fd, const void* buf, PRInt32 amount)
    1: {
    1:   return PSMSend(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMConnectcontinue(PRFileDesc *fd, PRInt16 out_flags)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
83083:   if (!getSocketInfoIfRunning(fd, locker)) {
    1:     return PR_FAILURE;
    1:   }
    1: 
83083:   return fd->lower->methods->connectcontinue(fd, out_flags);
    1: }
    1: 
    1: nsresult nsSSLIOLayerHelpers::Init()
    1: {
25625:   if (!nsSSLIOLayerInitialized) {
80486:     nsSSLIOLayerInitialized = true;
    1:     nsSSLIOLayerIdentity = PR_GetUniqueIdentity("NSS layer");
    1:     nsSSLIOLayerMethods  = *PR_GetDefaultIOMethods();
    1: 
    1:     nsSSLIOLayerMethods.available = (PRAvailableFN)_PSM_InvalidInt;
    1:     nsSSLIOLayerMethods.available64 = (PRAvailable64FN)_PSM_InvalidInt64;
    1:     nsSSLIOLayerMethods.fsync = (PRFsyncFN)_PSM_InvalidStatus;
    1:     nsSSLIOLayerMethods.seek = (PRSeekFN)_PSM_InvalidInt;
    1:     nsSSLIOLayerMethods.seek64 = (PRSeek64FN)_PSM_InvalidInt64;
    1:     nsSSLIOLayerMethods.fileInfo = (PRFileInfoFN)_PSM_InvalidStatus;
    1:     nsSSLIOLayerMethods.fileInfo64 = (PRFileInfo64FN)_PSM_InvalidStatus;
    1:     nsSSLIOLayerMethods.writev = (PRWritevFN)_PSM_InvalidInt;
    1:     nsSSLIOLayerMethods.accept = (PRAcceptFN)_PSM_InvalidDesc;
    1:     nsSSLIOLayerMethods.bind = (PRBindFN)_PSM_InvalidStatus;
    1:     nsSSLIOLayerMethods.listen = (PRListenFN)_PSM_InvalidStatus;
    1:     nsSSLIOLayerMethods.shutdown = (PRShutdownFN)_PSM_InvalidStatus;
    1:     nsSSLIOLayerMethods.recvfrom = (PRRecvfromFN)_PSM_InvalidInt;
    1:     nsSSLIOLayerMethods.sendto = (PRSendtoFN)_PSM_InvalidInt;
    1:     nsSSLIOLayerMethods.acceptread = (PRAcceptreadFN)_PSM_InvalidInt;
    1:     nsSSLIOLayerMethods.transmitfile = (PRTransmitfileFN)_PSM_InvalidInt;
    1:     nsSSLIOLayerMethods.sendfile = (PRSendfileFN)_PSM_InvalidInt;
    1: 
    1:     nsSSLIOLayerMethods.getsockname = PSMGetsockname;
    1:     nsSSLIOLayerMethods.getpeername = PSMGetpeername;
    1:     nsSSLIOLayerMethods.getsocketoption = PSMGetsocketoption;
    1:     nsSSLIOLayerMethods.setsocketoption = PSMSetsocketoption;
    1:     nsSSLIOLayerMethods.recv = PSMRecv;
    1:     nsSSLIOLayerMethods.send = PSMSend;
    1:     nsSSLIOLayerMethods.connectcontinue = PSMConnectcontinue;
    1: 
    1:     nsSSLIOLayerMethods.connect = nsSSLIOLayerConnect;
    1:     nsSSLIOLayerMethods.close = nsSSLIOLayerClose;
    1:     nsSSLIOLayerMethods.write = nsSSLIOLayerWrite;
    1:     nsSSLIOLayerMethods.read = nsSSLIOLayerRead;
    1:     nsSSLIOLayerMethods.poll = nsSSLIOLayerPoll;
25625:   }
    1: 
64576:   mutex = new Mutex("nsSSLIOLayerHelpers.mutex");
    1: 
    1:   mTLSIntolerantSites = new nsCStringHashSet();
    1:   if (!mTLSIntolerantSites)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   mTLSIntolerantSites->Init(1);
    1: 
30463:   mTLSTolerantSites = new nsCStringHashSet();
30463:   if (!mTLSTolerantSites)
30463:     return NS_ERROR_OUT_OF_MEMORY;
30463: 
30463:   // Initialize the tolerant site hashtable to 16 items at the start seems
30463:   // reasonable as most servers are TLS tolerant. We just want to lower 
30463:   // the rate of hashtable array reallocation.
30463:   mTLSTolerantSites->Init(16);
30463: 
37963:   mRenegoUnrestrictedSites = new nsCStringHashSet();
37963:   if (!mRenegoUnrestrictedSites)
37963:     return NS_ERROR_OUT_OF_MEMORY;
37963: 
37963:   mRenegoUnrestrictedSites->Init(1);
37963: 
80486:   mTreatUnsafeNegotiationAsBroken = false;
37963:   
28629:   mHostsWithCertErrors = new nsPSMRememberCertErrorsTable();
28629:   if (!mHostsWithCertErrors || !mHostsWithCertErrors->mErrorHosts.IsInitialized())
28629:     return NS_ERROR_OUT_OF_MEMORY;
28629: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsSSLIOLayerHelpers::addIntolerantSite(const nsCString &str)
    1: {
64576:   MutexAutoLock lock(*mutex);
30463:   // Remember intolerant site only if it is not known as tolerant
30463:   if (!mTLSTolerantSites->Contains(str))
    1:     nsSSLIOLayerHelpers::mTLSIntolerantSites->Put(str);
    1: }
    1: 
30463: void nsSSLIOLayerHelpers::removeIntolerantSite(const nsCString &str)
30463: {
64576:   MutexAutoLock lock(*mutex);
30463:   nsSSLIOLayerHelpers::mTLSIntolerantSites->Remove(str);
30463: }
30463: 
79445: bool nsSSLIOLayerHelpers::isKnownAsIntolerantSite(const nsCString &str)
    1: {
64576:   MutexAutoLock lock(*mutex);
    1:   return mTLSIntolerantSites->Contains(str);
    1: }
    1: 
37963: void nsSSLIOLayerHelpers::setRenegoUnrestrictedSites(const nsCString &str)
37963: {
64576:   MutexAutoLock lock(*mutex);
37963:   
37963:   if (mRenegoUnrestrictedSites) {
37963:     delete mRenegoUnrestrictedSites;
37963:     mRenegoUnrestrictedSites = nsnull;
37963:   }
37963: 
37963:   mRenegoUnrestrictedSites = new nsCStringHashSet();
37963:   if (!mRenegoUnrestrictedSites)
37963:     return;
37963:   
37963:   mRenegoUnrestrictedSites->Init(1);
37963:   
41768:   nsCCharSeparatedTokenizer toker(str, ',');
37963: 
37963:   while (toker.hasMoreTokens()) {
37963:     const nsCSubstring &host = toker.nextToken();
37963:     if (!host.IsEmpty()) {
37963:       mRenegoUnrestrictedSites->Put(host);
37963:     }
37963:   }
37963: }
37963: 
79445: bool nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(const nsCString &str)
37963: {
64576:   MutexAutoLock lock(*mutex);
37963:   return mRenegoUnrestrictedSites->Contains(str);
37963: }
37963: 
79445: void nsSSLIOLayerHelpers::setTreatUnsafeNegotiationAsBroken(bool broken)
37963: {
64576:   MutexAutoLock lock(*mutex);
37963:   mTreatUnsafeNegotiationAsBroken = broken;
37963: }
37963: 
79445: bool nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()
37963: {
64576:   MutexAutoLock lock(*mutex);
37963:   return mTreatUnsafeNegotiationAsBroken;
37963: }
37963: 
41739: void nsSSLIOLayerHelpers::setWarnLevelMissingRFC5746(PRInt32 level)
41739: {
64576:   MutexAutoLock lock(*mutex);
41739:   mWarnLevelMissingRFC5746 = level;
41739: }
41739: 
41739: PRInt32 nsSSLIOLayerHelpers::getWarnLevelMissingRFC5746()
41739: {
64576:   MutexAutoLock lock(*mutex);
41739:   return mWarnLevelMissingRFC5746;
41739: }
41739: 
    1: nsresult
    1: nsSSLIOLayerNewSocket(PRInt32 family,
    1:                       const char *host,
    1:                       PRInt32 port,
    1:                       const char *proxyHost,
    1:                       PRInt32 proxyPort,
    1:                       PRFileDesc **fd,
    1:                       nsISupports** info,
79445:                       bool forSTARTTLS,
79445:                       bool anonymousLoad)
    1: {
    1: 
    1:   PRFileDesc* sock = PR_OpenTCPSocket(family);
    1:   if (!sock) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsresult rv = nsSSLIOLayerAddToSocket(family, host, port, proxyHost, proxyPort,
25076:                                         sock, info, forSTARTTLS, anonymousLoad);
    1:   if (NS_FAILED(rv)) {
    1:     PR_Close(sock);
    1:     return rv;
    1:   }
    1: 
    1:   *fd = sock;
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Function: SECStatus nsConvertCANamesToStrings()
    1:  * Purpose: creates CA names strings from (CERTDistNames* caNames)
    1:  *
    1:  * Arguments and return values
    1:  * - arena: arena to allocate strings on
    1:  * - caNameStrings: filled with CA names strings on return
    1:  * - caNames: CERTDistNames to extract strings from
    1:  * - return: SECSuccess if successful; error code otherwise
    1:  *
    1:  * Note: copied in its entirety from Nova code
    1:  */
    1: SECStatus nsConvertCANamesToStrings(PRArenaPool* arena, char** caNameStrings,
    1:                                       CERTDistNames* caNames)
    1: {
    1:     SECItem* dername;
    1:     SECStatus rv;
    1:     int headerlen;
 6838:     PRUint32 contentlen;
    1:     SECItem newitem;
    1:     int n;
    1:     char* namestring;
    1: 
    1:     for (n = 0; n < caNames->nnames; n++) {
    1:         newitem.data = NULL;
    1:         dername = &caNames->names[n];
    1: 
    1:         rv = DER_Lengths(dername, &headerlen, &contentlen);
    1: 
    1:         if (rv != SECSuccess) {
    1:             goto loser;
    1:         }
    1: 
    1:         if (headerlen + contentlen != dername->len) {
    1:             /* This must be from an enterprise 2.x server, which sent
    1:              * incorrectly formatted der without the outer wrapper of
    1:              * type and length.  Fix it up by adding the top level
    1:              * header.
    1:              */
    1:             if (dername->len <= 127) {
    1:                 newitem.data = (unsigned char *) PR_Malloc(dername->len + 2);
    1:                 if (newitem.data == NULL) {
    1:                     goto loser;
    1:                 }
    1:                 newitem.data[0] = (unsigned char)0x30;
    1:                 newitem.data[1] = (unsigned char)dername->len;
    1:                 (void)memcpy(&newitem.data[2], dername->data, dername->len);
    1:             }
    1:             else if (dername->len <= 255) {
    1:                 newitem.data = (unsigned char *) PR_Malloc(dername->len + 3);
    1:                 if (newitem.data == NULL) {
    1:                     goto loser;
    1:                 }
    1:                 newitem.data[0] = (unsigned char)0x30;
    1:                 newitem.data[1] = (unsigned char)0x81;
    1:                 newitem.data[2] = (unsigned char)dername->len;
    1:                 (void)memcpy(&newitem.data[3], dername->data, dername->len);
    1:             }
    1:             else {
    1:                 /* greater than 256, better be less than 64k */
    1:                 newitem.data = (unsigned char *) PR_Malloc(dername->len + 4);
    1:                 if (newitem.data == NULL) {
    1:                     goto loser;
    1:                 }
    1:                 newitem.data[0] = (unsigned char)0x30;
    1:                 newitem.data[1] = (unsigned char)0x82;
    1:                 newitem.data[2] = (unsigned char)((dername->len >> 8) & 0xff);
    1:                 newitem.data[3] = (unsigned char)(dername->len & 0xff);
    1:                 memcpy(&newitem.data[4], dername->data, dername->len);
    1:             }
    1:             dername = &newitem;
    1:         }
    1: 
    1:         namestring = CERT_DerNameToAscii(dername);
    1:         if (namestring == NULL) {
    1:             /* XXX - keep going until we fail to convert the name */
81085:             caNameStrings[n] = const_cast<char*>("");
    1:         }
    1:         else {
    1:             caNameStrings[n] = PORT_ArenaStrdup(arena, namestring);
    1:             PR_Free(namestring);
    1:             if (caNameStrings[n] == NULL) {
    1:                 goto loser;
    1:             }
    1:         }
    1: 
    1:         if (newitem.data != NULL) {
    1:             PR_Free(newitem.data);
    1:         }
    1:     }
    1: 
    1:     return SECSuccess;
    1: loser:
    1:     if (newitem.data != NULL) {
    1:         PR_Free(newitem.data);
    1:     }
    1:     return SECFailure;
    1: }
    1: 
    1: /*
    1:  * structs and ASN1 templates for the limited scope-of-use extension
    1:  *
    1:  * CertificateScopeEntry ::= SEQUENCE {
    1:  *     name GeneralName, -- pattern, as for NameConstraints
    1:  *     portNumber INTEGER OPTIONAL }
    1:  *
    1:  * CertificateScopeOfUse ::= SEQUENCE OF CertificateScopeEntry
    1:  */
    1: /*
    1:  * CERTCertificateScopeEntry: struct for scope entry that can be consumed by
    1:  *                            the code
    1:  * certCertificateScopeOfUse: struct that represents the decoded extension data
    1:  */
    1: typedef struct {
    1:     SECItem derConstraint;
    1:     SECItem derPort;
    1:     CERTGeneralName* constraint; /* decoded constraint */
    1:     PRIntn port; /* decoded port number */
    1: } CERTCertificateScopeEntry;
    1: 
    1: typedef struct {
    1:     CERTCertificateScopeEntry** entries;
    1: } certCertificateScopeOfUse;
    1: 
    1: /* corresponding ASN1 templates */
    1: static const SEC_ASN1Template cert_CertificateScopeEntryTemplate[] = {
    1:     { SEC_ASN1_SEQUENCE, 
    1:       0, NULL, sizeof(CERTCertificateScopeEntry) },
    1:     { SEC_ASN1_ANY,
    1:       offsetof(CERTCertificateScopeEntry, derConstraint) },
    1:     { SEC_ASN1_OPTIONAL | SEC_ASN1_INTEGER,
    1:       offsetof(CERTCertificateScopeEntry, derPort) },
    1:     { 0 }
    1: };
    1: 
    1: static const SEC_ASN1Template cert_CertificateScopeOfUseTemplate[] = {
    1:     { SEC_ASN1_SEQUENCE_OF, 0, cert_CertificateScopeEntryTemplate }
    1: };
    1: 
    1: #if 0
    1: /* 
    1:  * decodes the extension data and create CERTCertificateScopeEntry that can
    1:  * be consumed by the code
    1:  */
    1: static
    1: SECStatus cert_DecodeScopeOfUseEntries(PRArenaPool* arena, SECItem* extData,
    1:                                        CERTCertificateScopeEntry*** entries,
    1:                                        int* numEntries)
    1: {
    1:     certCertificateScopeOfUse* scope = NULL;
    1:     SECStatus rv = SECSuccess;
    1:     int i;
    1: 
    1:     *entries = NULL; /* in case of failure */
    1:     *numEntries = 0; /* ditto */
    1: 
    1:     scope = (certCertificateScopeOfUse*)
    1:         PORT_ArenaZAlloc(arena, sizeof(certCertificateScopeOfUse));
    1:     if (scope == NULL) {
    1:         goto loser;
    1:     }
    1: 
    1:     rv = SEC_ASN1DecodeItem(arena, (void*)scope, 
    1:                             cert_CertificateScopeOfUseTemplate, extData);
    1:     if (rv != SECSuccess) {
    1:         goto loser;
    1:     }
    1: 
    1:     *entries = scope->entries;
    1:     PR_ASSERT(*entries != NULL);
    1: 
    1:     /* first, let's count 'em. */
    1:     for (i = 0; (*entries)[i] != NULL; i++) ;
    1:     *numEntries = i;
    1: 
    1:     /* convert certCertificateScopeEntry sequence into what we can readily
    1:      * use
    1:      */
    1:     for (i = 0; i < *numEntries; i++) {
    1:         (*entries)[i]->constraint = 
    1:             CERT_DecodeGeneralName(arena, &((*entries)[i]->derConstraint), 
    1:                                    NULL);
    1:         if ((*entries)[i]->derPort.data != NULL) {
    1:             (*entries)[i]->port = 
    1:                 (int)DER_GetInteger(&((*entries)[i]->derPort));
    1:         }
    1:         else {
    1:             (*entries)[i]->port = 0;
    1:         }
    1:     }
    1: 
    1:     goto done;
    1: loser:
    1:     if (rv == SECSuccess) {
    1:         rv = SECFailure;
    1:     }
    1: done:
    1:     return rv;
    1: }
    1: 
    1: static SECStatus cert_DecodeCertIPAddress(SECItem* genname, 
    1:                                           PRUint32* constraint, PRUint32* mask)
    1: {
    1:     /* in case of failure */
    1:     *constraint = 0;
    1:     *mask = 0;
    1: 
    1:     PR_ASSERT(genname->data != NULL);
    1:     if (genname->data == NULL) {
    1:         return SECFailure;
    1:     }
    1:     if (genname->len != 8) {
    1:         /* the length must be 4 byte IP address with 4 byte subnet mask */
    1:         return SECFailure;
    1:     }
    1: 
    1:     /* get them in the right order */
    1:     *constraint = PR_ntohl((PRUint32)(*genname->data));
    1:     *mask = PR_ntohl((PRUint32)(*(genname->data + 4)));
    1: 
    1:     return SECSuccess;
    1: }
    1: 
    1: static char* _str_to_lower(char* string)
    1: {
    1: #ifdef XP_WIN
    1:     return _strlwr(string);
    1: #else
    1:     int i;
    1:     for (i = 0; string[i] != '\0'; i++) {
    1:         string[i] = tolower(string[i]);
    1:     }
    1:     return string;
    1: #endif
    1: }
    1: 
    1: /*
    1:  * Sees if the client certificate has a restriction in presenting the cert
80486:  * to the host: returns true if there is no restriction or if the hostname
80486:  * (and the port) satisfies the restriction, or false if the hostname (and
    1:  * the port) does not satisfy the restriction
    1:  */
79445: static bool CERT_MatchesScopeOfUse(CERTCertificate* cert, char* hostname,
    1:                                      char* hostIP, PRIntn port)
    1: {
79445:     bool rv = true; /* whether the cert can be presented */
    1:     SECStatus srv;
    1:     SECItem extData;
    1:     PRArenaPool* arena = NULL;
    1:     CERTCertificateScopeEntry** entries = NULL;
    1:     /* arrays of decoded scope entries */
    1:     int numEntries = 0;
    1:     int i;
    1:     char* hostLower = NULL;
    1:     PRUint32 hostIPAddr = 0;
    1: 
    1:     PR_ASSERT((cert != NULL) && (hostname != NULL) && (hostIP != NULL));
    1: 
    1:     /* find cert extension */
    1:     srv = CERT_FindCertExtension(cert, SEC_OID_NS_CERT_EXT_SCOPE_OF_USE,
    1:                                  &extData);
    1:     if (srv != SECSuccess) {
    1:         /* most of the time, this means the extension was not found: also,
    1:          * since this is not a critical extension (as of now) we may simply
80486:          * return true
    1:          */
    1:         goto done;
    1:     }
    1: 
    1:     arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    1:     if (arena == NULL) {
    1:         goto done;
    1:     }
    1: 
    1:     /* decode the scope of use entries into pairs of GeneralNames and
    1:      * an optional port numbers
    1:      */
    1:     srv = cert_DecodeScopeOfUseEntries(arena, &extData, &entries, &numEntries);
    1:     if (srv != SECSuccess) {
    1:         /* XXX What should we do when we failed to decode the extension?  This
    1:          *     may mean either the extension was malformed or some (unlikely)
    1:          *     fatal error on our part: my argument is that if the extension 
    1:          *     was malformed the extension "disqualifies" as a valid 
    1:          *     constraint and we may present the cert
    1:          */
    1:         goto done;
    1:     }
    1: 
    1:     /* loop over these structures */
    1:     for (i = 0; i < numEntries; i++) {
    1:         /* determine whether the GeneralName is a DNS pattern, an IP address 
    1:          * constraint, or else
    1:          */
    1:         CERTGeneralName* genname = entries[i]->constraint;
    1: 
    1:         /* if constraint is NULL, don't bother looking */
    1:         if (genname == NULL) {
    1:             /* this is not a failure: just continue */
    1:             continue;
    1:         }
    1: 
    1:         switch (genname->type) {
    1:         case certDNSName: {
    1:             /* we have a DNS name constraint; we should use only the host name
    1:              * information
    1:              */
    1:             char* pattern = NULL;
    1:             char* substring = NULL;
    1: 
    1:             /* null-terminate the string */
    1:             genname->name.other.data[genname->name.other.len] = '\0';
    1:             pattern = _str_to_lower((char*)genname->name.other.data);
    1: 
    1:             if (hostLower == NULL) {
    1:                 /* so that it's done only if necessary and only once */
    1:                 hostLower = _str_to_lower(PL_strdup(hostname));
    1:             }
    1: 
    1:             /* the hostname satisfies the constraint */
    1:             if (((substring = strstr(hostLower, pattern)) != NULL) &&
    1:                 /* the hostname contains the pattern */
    1:                 (strlen(substring) == strlen(pattern)) &&
    1:                 /* the hostname ends with the pattern */
    1:                 ((substring == hostLower) || (*(substring-1) == '.'))) {
    1:                 /* the hostname either is identical to the pattern or
    1:                  * belongs to a subdomain
    1:                  */
80486:                 rv = true;
    1:             }
    1:             else {
80486:                 rv = false;
    1:             }
    1:             /* clean up strings if necessary */
    1:             break;
    1:         }
    1:         case certIPAddress: {
    1:             PRUint32 constraint;
    1:             PRUint32 mask;
    1:             PRNetAddr addr;
    1:             
    1:             if (hostIPAddr == 0) {
    1:                 /* so that it's done only if necessary and only once */
    1:                 PR_StringToNetAddr(hostIP, &addr);
    1:                 hostIPAddr = addr.inet.ip;
    1:             }
    1: 
    1:             if (cert_DecodeCertIPAddress(&(genname->name.other), &constraint, 
    1:                                          &mask) != SECSuccess) {
    1:                 continue;
    1:             }
    1:             if ((hostIPAddr & mask) == (constraint & mask)) {
80486:                 rv = true;
    1:             }
    1:             else {
80486:                 rv = false;
    1:             }
    1:             break;
    1:         }
    1:         default:
    1:             /* ill-formed entry: abort */
    1:             continue; /* go to the next entry */
    1:         }
    1: 
    1:         if (!rv) {
    1:             /* we do not need to check the port: go to the next entry */
    1:             continue;
    1:         }
    1: 
    1:         /* finally, check the optional port number */
    1:         if ((entries[i]->port != 0) && (port != entries[i]->port)) {
    1:             /* port number does not match */
80486:             rv = false;
    1:             continue;
    1:         }
    1: 
    1:         /* we have a match */
    1:         PR_ASSERT(rv);
    1:         break;
    1:     }
    1: done:
    1:     /* clean up entries */
    1:     if (arena != NULL) {
80486:         PORT_FreeArena(arena, false);
    1:     }
    1:     if (hostLower != NULL) {
    1:         PR_Free(hostLower);
    1:     }
    1:     return rv;
    1: }
    1: #endif
    1: 
    1: /*
    1:  * Function: SSMStatus SSM_SetUserCertChoice()
    1: 
    1:  * Purpose: sets certChoice by reading the preference
    1:  *
    1:  * Arguments and return values
    1:  * - conn: SSMSSLDataConnection
    1:  * - returns: SSM_SUCCESS if successful; SSM_FAILURE otherwise
    1:  *
    1:  * Note: If done properly, this function will read the identifier strings
    1:  *		 for ASK and AUTO modes, read the selected strings from the
    1:  *		 preference, compare the strings, and determine in which mode it is
    1:  *		 in.
    1:  *       We currently use ASK mode for UI apps and AUTO mode for UI-less
    1:  *       apps without really asking for preferences.
    1:  */
    1: nsresult nsGetUserCertChoice(SSM_UserCertChoice* certChoice)
    1: {
    1: 	char *mode=NULL;
    1: 	nsresult ret;
    1: 
    1: 	NS_ENSURE_ARG_POINTER(certChoice);
    1: 
    1: 	nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1: 
    1: 	ret = pref->GetCharPref("security.default_personal_cert", &mode);
    1: 	if (NS_FAILED(ret)) {
    1: 		goto loser;
    1: 	}
    1: 
    1:     if (PL_strcmp(mode, "Select Automatically") == 0) {
    1: 		*certChoice = AUTO;
    1: 	}
    1:     else if (PL_strcmp(mode, "Ask Every Time") == 0) {
    1:         *certChoice = ASK;
    1:     }
    1:     else {
    1:       // Most likely we see a nickname from a migrated cert.
    1:       // We do not currently support that, ask the user which cert to use.
    1: 		  *certChoice = ASK;
    1: 	}
    1: 
    1: loser:
    1: 	if (mode) {
    1: 		nsMemory::Free(mode);
    1: 	}
    1: 	return ret;
    1: }
    1: 
79445: static bool hasExplicitKeyUsageNonRepudiation(CERTCertificate *cert)
    1: {
    1:   /* There is no extension, v1 or v2 certificate */
    1:   if (!cert->extensions)
80486:     return false;
    1: 
    1:   SECStatus srv;
    1:   SECItem keyUsageItem;
    1:   keyUsageItem.data = NULL;
    1: 
    1:   srv = CERT_FindKeyUsageExtension(cert, &keyUsageItem);
    1:   if (srv == SECFailure)
80486:     return false;
    1: 
    1:   unsigned char keyUsage = keyUsageItem.data[0];
    1:   PORT_Free (keyUsageItem.data);
    1: 
19743:   return !!(keyUsage & KU_NON_REPUDIATION);
    1: }
    1: 
81085: class ClientAuthDataRunnable : public SyncRunnableBase
81085: {
81085: public:
81085:   ClientAuthDataRunnable(CERTDistNames* caNames,
81085:                          CERTCertificate** pRetCert,
81085:                          SECKEYPrivateKey** pRetKey,
81085:                          nsNSSSocketInfo * info,
81085:                          CERTCertificate * serverCert) 
81085:     : mRV(SECFailure)
81085:     , mErrorCodeToReport(SEC_ERROR_NO_MEMORY)
84396:     , mCANames(caNames)
81085:     , mPRetCert(pRetCert)
81085:     , mPRetKey(pRetKey)
81085:     , mSocketInfo(info)
81085:     , mServerCert(serverCert)
81085:   {
81085:   }
81085: 
81085:   SECStatus mRV;                        // out
81085:   PRErrorCode mErrorCodeToReport;       // out
81085: protected:
81085:   virtual void RunOnTargetThread();
81085: private:
81085:   CERTDistNames* const mCANames;        // in
84396:   CERTCertificate** const mPRetCert;    // in/out
84396:   SECKEYPrivateKey** const mPRetKey;    // in/out
81085:   nsNSSSocketInfo * const mSocketInfo;  // in
81085:   CERTCertificate * const mServerCert;  // in
81085: };
81085: 
    1: /*
    1:  * Function: SECStatus SSM_SSLGetClientAuthData()
    1:  * Purpose: this callback function is used to pull client certificate
    1:  *			information upon server request
    1:  *
    1:  * Arguments and return values
    1:  * - arg: SSL data connection
    1:  * - socket: SSL socket we're dealing with
    1:  * - caNames: list of CA names
    1:  * - pRetCert: returns a pointer to a pointer to a valid certificate if
    1:  *			   successful; otherwise NULL
    1:  * - pRetKey: returns a pointer to a pointer to the corresponding key if
    1:  *			  successful; otherwise NULL
    1:  * - returns: SECSuccess if successful; error code otherwise
    1:  */
    1: SECStatus nsNSS_SSLGetClientAuthData(void* arg, PRFileDesc* socket,
    1: 								   CERTDistNames* caNames,
    1: 								   CERTCertificate** pRetCert,
    1: 								   SECKEYPrivateKey** pRetKey)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
81085: 
81085:   if (!socket || !caNames || !pRetCert || !pRetKey) {
81085:     PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
81085:     return SECFailure;
81085:   }
81085: 
81085:   nsRefPtr<nsNSSSocketInfo> info
81085:         = reinterpret_cast<nsNSSSocketInfo*>(socket->higher->secret);
81085: 
81085:   CERTCertificate* serverCert = SSL_PeerCertificate(socket);
81085:   if (!serverCert) {
81085:     NS_NOTREACHED("Missing server certificate should have been detected during "
81085:                   "server cert authentication.");
81085:     PR_SetError(SSL_ERROR_NO_CERTIFICATE, 0);
81085:     return SECFailure;
81085:   }
81085: 
81085:   // XXX: This should be done asynchronously; see bug 696976
81085:   nsRefPtr<ClientAuthDataRunnable> runnable =
81085:     new ClientAuthDataRunnable(caNames, pRetCert, pRetKey, info, serverCert);
81085:   nsresult rv = runnable->DispatchToMainThreadAndWait();
81085:   if (NS_FAILED(rv)) {
81085:     PR_SetError(SEC_ERROR_NO_MEMORY, 0);
81085:     return SECFailure;
81085:   }
81085:   
81085:   if (runnable->mRV != SECSuccess) {
83083:     PR_SetError(runnable->mErrorCodeToReport, 0);
81085:   }
81085: 
81085:   return runnable->mRV;
81085: }
81085: 
81085: void ClientAuthDataRunnable::RunOnTargetThread()
81085: {
    1:   PRArenaPool* arena = NULL;
    1:   char** caNameStrings;
    1:   CERTCertificate* cert = NULL;
    1:   SECKEYPrivateKey* privKey = NULL;
    1:   CERTCertList* certList = NULL;
    1:   CERTCertListNode* node;
    1:   CERTCertNicknames* nicknames = NULL;
    1:   char* extracted = NULL;
    1:   PRIntn keyError = 0; /* used for private key retrieval error */
    1:   SSM_UserCertChoice certChoice;
    1:   PRInt32 NumberOfCerts = 0;
81085:   void * wincx = mSocketInfo;
    1: 
    1:   /* create caNameStrings */
    1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    1:   if (arena == NULL) {
    1:     goto loser;
    1:   }
    1: 
    1:   caNameStrings = (char**)PORT_ArenaAlloc(arena, 
81085:                                           sizeof(char*)*(mCANames->nnames));
    1:   if (caNameStrings == NULL) {
    1:     goto loser;
    1:   }
    1: 
81085:   mRV = nsConvertCANamesToStrings(arena, caNameStrings, mCANames);
81085:   if (mRV != SECSuccess) {
    1:     goto loser;
    1:   }
    1: 
    1:   /* get the preference */
    1:   if (NS_FAILED(nsGetUserCertChoice(&certChoice))) {
    1:     goto loser;
    1:   }
    1: 
    1:   /* find valid user cert and key pair */	
    1:   if (certChoice == AUTO) {
    1:     /* automatically find the right cert */
    1: 
    1:     /* find all user certs that are valid and for SSL */
    1:     certList = CERT_FindUserCertsByUsage(CERT_GetDefaultCertDB(), 
80486:                                          certUsageSSLClient, false,
80486:                                          true, wincx);
    1:     if (certList == NULL) {
    1:       goto noCert;
    1:     }
    1: 
    1:     /* filter the list to those issued by CAs supported by the server */
81085:     mRV = CERT_FilterCertListByCANames(certList, mCANames->nnames,
    1:                                        caNameStrings, certUsageSSLClient);
81085:     if (mRV != SECSuccess) {
    1:       goto noCert;
    1:     }
    1: 
    1:     /* make sure the list is not empty */
    1:     node = CERT_LIST_HEAD(certList);
    1:     if (CERT_LIST_END(node, certList)) {
    1:       goto noCert;
    1:     }
    1: 
    1:     CERTCertificate* low_prio_nonrep_cert = NULL;
    1:     CERTCertificateCleaner low_prio_cleaner(low_prio_nonrep_cert);
    1: 
    1:     /* loop through the list until we find a cert with a key */
    1:     while (!CERT_LIST_END(node, certList)) {
    1:       /* if the certificate has restriction and we do not satisfy it
    1:        * we do not use it
    1:        */
    1: #if 0		/* XXX This must be re-enabled */
81085:       if (!CERT_MatchesScopeOfUse(node->cert, mSocketInfo->GetHostName,
    1:                                   info->GetHostIP, info->GetHostPort)) {
    1:           node = CERT_LIST_NEXT(node);
    1:           continue;
    1:       }
    1: #endif
    1: 
    1:       privKey = PK11_FindKeyByAnyCert(node->cert, wincx);
    1:       if (privKey != NULL) {
    1:         if (hasExplicitKeyUsageNonRepudiation(node->cert)) {
    1:           SECKEY_DestroyPrivateKey(privKey);
    1:           privKey = NULL;
    1:           // Not a prefered cert
    1:           if (!low_prio_nonrep_cert) // did not yet find a low prio cert
    1:             low_prio_nonrep_cert = CERT_DupCertificate(node->cert);
    1:         }
    1:         else {
    1:           // this is a good cert to present
    1:           cert = CERT_DupCertificate(node->cert);
    1:           break;
    1:         }
    1:       }
    1:       keyError = PR_GetError();
    1:       if (keyError == SEC_ERROR_BAD_PASSWORD) {
    1:           /* problem with password: bail */
    1:           goto loser;
    1:       }
    1: 
    1:       node = CERT_LIST_NEXT(node);
    1:     }
    1: 
    1:     if (!cert && low_prio_nonrep_cert) {
    1:       cert = low_prio_nonrep_cert;
    1:       low_prio_nonrep_cert = NULL; // take it away from the cleaner
    1:       privKey = PK11_FindKeyByAnyCert(cert, wincx);
    1:     }
    1: 
    1:     if (cert == NULL) {
    1:         goto noCert;
    1:     }
    1:   }
28675:   else { // Not Auto => ask
28675:     /* Get the SSL Certificate */
28675: 
28675:     nsXPIDLCString hostname;
81085:     mSocketInfo->GetHostName(getter_Copies(hostname));
28675: 
28675:     nsresult rv;
28675:     NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
28675:     nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
28675:     nsRefPtr<nsClientAuthRememberService> cars;
28675:     if (nssComponent) {
28675:       nssComponent->GetClientAuthRememberService(getter_AddRefs(cars));
28675:     }
28675: 
79445:     bool hasRemembered = false;
28675:     nsCString rememberedDBKey;
28675:     if (cars) {
79445:       bool found;
81085:       nsresult rv = cars->HasRememberedDecision(hostname, mServerCert,
28675:                                                 rememberedDBKey, &found);
28675:       if (NS_SUCCEEDED(rv) && found) {
80486:         hasRemembered = true;
28675:       }
28675:     }
28675: 
79445:     bool canceled = false;
28675: 
28675: if (hasRemembered)
28675: {
28675:     if (rememberedDBKey.IsEmpty())
28675:     {
80486:       canceled = true;
28675:     }
28675:     else
28675:     {
28675:       nsCOMPtr<nsIX509CertDB> certdb;
28675:       certdb = do_GetService(NS_X509CERTDB_CONTRACTID);
28675:       if (certdb)
28675:       {
28675:         nsCOMPtr<nsIX509Cert> found_cert;
28675:         nsresult find_rv = 
28675:           certdb->FindCertByDBKey(rememberedDBKey.get(), nsnull,
28675:                                   getter_AddRefs(found_cert));
28675:         if (NS_SUCCEEDED(find_rv) && found_cert) {
28675:           nsNSSCertificate *obj_cert = reinterpret_cast<nsNSSCertificate *>(found_cert.get());
28675:           if (obj_cert) {
28675:             cert = obj_cert->GetCert();
28675: 
28675: #ifdef DEBUG_kaie
28675:             nsAutoString nick, nickWithSerial, details;
28675:             if (NS_SUCCEEDED(obj_cert->FormatUIStrings(nick, 
28675:                                                        nickWithSerial, 
28675:                                                        details))) {
28675:               NS_LossyConvertUTF16toASCII asc(nickWithSerial);
28675:               fprintf(stderr, "====> remembered serial %s\n", asc.get());
28675:             }
28675: #endif
28675: 
28675:           }
28675:         }
28675:         
28675:         if (!cert) {
80486:           hasRemembered = false;
28675:         }
28675:       }
28675:     }
28675: }
28675: 
28675: if (!hasRemembered)
28675: {
    1:     /* user selects a cert to present */
    1:     nsIClientAuthDialogs *dialogs = NULL;
    1:     PRInt32 selectedIndex = -1;
    1:     PRUnichar **certNicknameList = NULL;
    1:     PRUnichar **certDetailsList = NULL;
    1: 
    1:     /* find all user certs that are for SSL */
    1:     /* note that we are allowing expired certs in this list */
    1:     certList = CERT_FindUserCertsByUsage(CERT_GetDefaultCertDB(), 
80486:                                          certUsageSSLClient, false, 
80486:                                          false, wincx);
    1:     if (certList == NULL) {
    1:       goto noCert;
    1:     }
    1: 
81085:     if (mCANames->nnames != 0) {
    1:       /* filter the list to those issued by CAs supported by the 
    1:        * server 
    1:        */
81085:       mRV = CERT_FilterCertListByCANames(certList, mCANames->nnames, 
    1:                                         caNameStrings, 
    1:                                         certUsageSSLClient);
81085:       if (mRV != SECSuccess) {
    1:         goto loser;
    1:       }
    1:     }
    1: 
    1:     if (CERT_LIST_END(CERT_LIST_HEAD(certList), certList)) {
    1:       /* list is empty - no matching certs */
    1:       goto noCert;
    1:     }
    1: 
    1:     /* filter it further for hostname restriction */
    1:     node = CERT_LIST_HEAD(certList);
    1:     while (!CERT_LIST_END(node, certList)) {
    1:       ++NumberOfCerts;
    1: #if 0 /* XXX Fix this */
    1:       if (!CERT_MatchesScopeOfUse(node->cert, conn->hostName,
    1:                                   conn->hostIP, conn->port)) {
    1:         CERTCertListNode* removed = node;
    1:         node = CERT_LIST_NEXT(removed);
    1:         CERT_RemoveCertListNode(removed);
    1:       }
    1:       else {
    1:         node = CERT_LIST_NEXT(node);
    1:       }
    1: #endif
    1:       node = CERT_LIST_NEXT(node);
    1:     }
    1:     if (CERT_LIST_END(CERT_LIST_HEAD(certList), certList)) {
    1:       goto noCert;
    1:     }
    1: 
    1:     nicknames = getNSSCertNicknamesFromCertList(certList);
    1: 
    1:     if (nicknames == NULL) {
    1:       goto loser;
    1:     }
    1: 
    1:     NS_ASSERTION(nicknames->numnicknames == NumberOfCerts, "nicknames->numnicknames != NumberOfCerts");
    1: 
    1:     /* Get CN and O of the subject and O of the issuer */
81085:     char *ccn = CERT_GetCommonName(&mServerCert->subject);
27356:     void *v = ccn;
27356:     voidCleaner ccnCleaner(v);
    1:     NS_ConvertUTF8toUTF16 cn(ccn);
10549: 
10549:     PRInt32 port;
81085:     mSocketInfo->GetPort(&port);
10549: 
10549:     nsString cn_host_port;
10549:     if (ccn && strcmp(ccn, hostname) == 0) {
10549:       cn_host_port.Append(cn);
10549:       cn_host_port.AppendLiteral(":");
10549:       cn_host_port.AppendInt(port);
10549:     }
10549:     else {
10549:       cn_host_port.Append(cn);
10549:       cn_host_port.AppendLiteral(" (");
10549:       cn_host_port.AppendLiteral(":");
10549:       cn_host_port.AppendInt(port);
10549:       cn_host_port.AppendLiteral(")");
10549:     }
    1: 
81085:     char *corg = CERT_GetOrgName(&mServerCert->subject);
    1:     NS_ConvertUTF8toUTF16 org(corg);
    1:     if (corg) PORT_Free(corg);
    1: 
81085:     char *cissuer = CERT_GetOrgName(&mServerCert->issuer);
    1:     NS_ConvertUTF8toUTF16 issuer(cissuer);
    1:     if (cissuer) PORT_Free(cissuer);
    1: 
    1:     certNicknameList = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * nicknames->numnicknames);
    1:     if (!certNicknameList)
    1:       goto loser;
    1:     certDetailsList = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * nicknames->numnicknames);
    1:     if (!certDetailsList) {
    1:       nsMemory::Free(certNicknameList);
    1:       goto loser;
    1:     }
    1: 
    1:     PRInt32 CertsToUse;
    1:     for (CertsToUse = 0, node = CERT_LIST_HEAD(certList);
    1:          !CERT_LIST_END(node, certList) && CertsToUse < nicknames->numnicknames;
    1:          node = CERT_LIST_NEXT(node)
    1:         )
    1:     {
56495:       nsRefPtr<nsNSSCertificate> tempCert = nsNSSCertificate::Create(node->cert);
    1: 
    1:       if (!tempCert)
    1:         continue;
    1:       
    1:       NS_ConvertUTF8toUTF16 i_nickname(nicknames->nicknames[CertsToUse]);
    1:       nsAutoString nickWithSerial, details;
    1:       
    1:       if (NS_FAILED(tempCert->FormatUIStrings(i_nickname, nickWithSerial, details)))
    1:         continue;
    1: 
    1:       certNicknameList[CertsToUse] = ToNewUnicode(nickWithSerial);
    1:       if (!certNicknameList[CertsToUse])
    1:         continue;
    1:       certDetailsList[CertsToUse] = ToNewUnicode(details);
    1:       if (!certDetailsList[CertsToUse]) {
    1:         nsMemory::Free(certNicknameList[CertsToUse]);
    1:         continue;
    1:       }
    1: 
    1:       ++CertsToUse;
    1:     }
    1: 
    1:     /* Throw up the client auth dialog and get back the index of the selected cert */
    1:     rv = getNSSDialogs((void**)&dialogs, 
    1:                        NS_GET_IID(nsIClientAuthDialogs),
    1:                        NS_CLIENTAUTHDIALOGS_CONTRACTID);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certNicknameList);
    1:       NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certDetailsList);
    1:       goto loser;
    1:     }
    1: 
    1:     {
    1:       nsPSMUITracker tracker;
    1:       if (tracker.isUIForbidden()) {
    1:         rv = NS_ERROR_NOT_AVAILABLE;
    1:       }
    1:       else {
81085:         rv = dialogs->ChooseCertificate(mSocketInfo, cn_host_port.get(),
81085:                                         org.get(), issuer.get(), 
81085:                                         (const PRUnichar**)certNicknameList,
81085:                                         (const PRUnichar**)certDetailsList,
    1:                                         CertsToUse, &selectedIndex, &canceled);
    1:       }
    1:     }
    1: 
    1:     NS_RELEASE(dialogs);
    1:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certNicknameList);
    1:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certDetailsList);
    1:     
    1:     if (NS_FAILED(rv)) goto loser;
    1: 
28675:     // even if the user has canceled, we want to remember that, to avoid repeating prompts
79445:     bool wantRemember = false;
81085:     mSocketInfo->GetRememberClientAuthCertificate(&wantRemember);
    1: 
    1:     int i;
28675:     if (!canceled)
    1:     for (i = 0, node = CERT_LIST_HEAD(certList);
    1:          !CERT_LIST_END(node, certList);
    1:          ++i, node = CERT_LIST_NEXT(node)) {
    1: 
    1:       if (i == selectedIndex) {
    1:         cert = CERT_DupCertificate(node->cert);
    1:         break;
    1:       }
    1:     }
    1: 
28675:     if (cars && wantRemember) {
81085:       cars->RememberDecision(hostname, mServerCert, canceled ? 0 : cert);
28675:     }
28675: }
28675: 
28675:     if (canceled) { rv = NS_ERROR_NOT_AVAILABLE; goto loser; }
28675: 
    1:     if (cert == NULL) {
    1:       goto loser;
    1:     }
    1: 
    1:     /* go get the private key */
    1:     privKey = PK11_FindKeyByAnyCert(cert, wincx);
    1:     if (privKey == NULL) {
    1:       keyError = PR_GetError();
    1:       if (keyError == SEC_ERROR_BAD_PASSWORD) {
    1:           /* problem with password: bail */
    1:           goto loser;
    1:       }
    1:       else {
    1:           goto noCert;
    1:       }
    1:     }
    1:   }
    1:   goto done;
    1: 
    1: noCert:
    1: loser:
81085:   if (mRV == SECSuccess) {
81085:     mRV = SECFailure;
    1:   }
    1:   if (cert != NULL) {
    1:     CERT_DestroyCertificate(cert);
    1:     cert = NULL;
    1:   }
    1: done:
81085:   int error = PR_GetError();
81085: 
    1:   if (extracted != NULL) {
    1:     PR_Free(extracted);
    1:   }
    1:   if (nicknames != NULL) {
    1:     CERT_FreeNicknames(nicknames);
    1:   }
    1:   if (certList != NULL) {
    1:     CERT_DestroyCertList(certList);
    1:   }
    1:   if (arena != NULL) {
80486:     PORT_FreeArena(arena, false);
    1:   }
    1: 
81085:   *mPRetCert = cert;
81085:   *mPRetKey = privKey;
81085: 
81085:   if (mRV == SECFailure) {
81085:     mErrorCodeToReport = error;
81085:   }
    1: }
    1: 
79873: class CertErrorRunnable : public SyncRunnableBase
79873: {
79873:  public:
79873:   CertErrorRunnable(const void * fdForLogging,
79873:                     nsIX509Cert * cert,
79873:                     nsNSSSocketInfo * infoObject,
83083:                     PRErrorCode defaultErrorCodeToReport,
83083:                     PRUint32 collectedErrors,
83083:                     PRErrorCode errorCodeTrust,
83083:                     PRErrorCode errorCodeMismatch,
83083:                     PRErrorCode errorCodeExpired)
79873:     : mFdForLogging(fdForLogging), mCert(cert), mInfoObject(infoObject),
83083:       mDefaultErrorCodeToReport(defaultErrorCodeToReport),
83083:       mCollectedErrors(collectedErrors),
83083:       mErrorCodeTrust(errorCodeTrust),
83083:       mErrorCodeMismatch(errorCodeMismatch),
83083:       mErrorCodeExpired(errorCodeExpired)
79873:   {
79873:   }
79873: 
83083:   NS_DECL_NSIRUNNABLE
79873:   virtual void RunOnTargetThread();
83083:   nsCOMPtr<nsIRunnable> mResult; // out
83083: private:
83083:   SSLServerCertVerificationResult* CheckCertOverrides();
83083:   
83083:   const void * const mFdForLogging; // may become an invalid pointer; do not dereference
83083:   const nsCOMPtr<nsIX509Cert> mCert;
83083:   const nsRefPtr<nsNSSSocketInfo> mInfoObject;
83083:   const PRErrorCode mDefaultErrorCodeToReport;
83083:   const PRUint32 mCollectedErrors;
83083:   const PRErrorCode mErrorCodeTrust;
83083:   const PRErrorCode mErrorCodeMismatch;
83083:   const PRErrorCode mErrorCodeExpired;
79873: };
79873: 
83083: namespace mozilla { namespace psm {
83083: 
83083: // Returns SECSuccess if it dispatched the CertErrorRunnable. In that case,
83083: // the caller should NOT dispatch its own SSLServerCertVerificationResult;
83083: // the CertErrorRunnable will do it instead.
83083: //
83083: // Returns SECFailure with the error code set if it does not dispatch the
83083: // CertErrorRunnable. In that case, the caller should dispatch its own 
83083: // SSLServerCertVerificationResult with the error code from PR_GetError().
83083: SECStatus
83083: HandleBadCertificate(PRErrorCode defaultErrorCodeToReport,
83083:                     nsNSSSocketInfo * socketInfo, CERTCertificate & cert,
83083:                     const void * fdForLogging,
83083:                     const nsNSSShutDownPreventionLock & /*proofOfLock*/)
    1: {
69349:   // cert was revoked, don't do anything else
83083:   if (defaultErrorCodeToReport == SEC_ERROR_REVOKED_CERTIFICATE) {
83083:     PR_SetError(SEC_ERROR_REVOKED_CERTIFICATE, 0);
69349:     return SECFailure;
83083:   }
69349: 
79873:   if (defaultErrorCodeToReport == 0) {
79873:     NS_ERROR("No error code set during certificate validation failure.");
83083:     PR_SetError(PR_INVALID_STATE_ERROR, 0);
 6597:     return SECFailure;
83083:   }
 6597: 
 6597:   nsRefPtr<nsNSSCertificate> nssCert;
83083:   nssCert = nsNSSCertificate::Create(&cert);
83083:   if (!nssCert) {
83083:     NS_ERROR("nsNSSCertificate::Create failed in DispatchCertErrorRunnable");
83083:     PR_SetError(SEC_ERROR_NO_MEMORY, 0);
83083:     return SECFailure;
83083:   }
 6597: 
 6597:   SECStatus srv;
 6597:   nsresult nsrv;
 6597: 
69383:   nsCOMPtr<nsINSSComponent> inss = do_GetService(kNSSComponentCID, &nsrv);
83083:   if (!inss) {
83083:     NS_ERROR("do_GetService(kNSSComponentCID) failed in DispatchCertErrorRunnable");
83083:     PR_SetError(defaultErrorCodeToReport, 0);
83083:     return SECFailure;
83083:   }
83083: 
69383:   nsRefPtr<nsCERTValInParamWrapper> survivingParams;
69383:   nsrv = inss->GetDefaultCERTValInParam(survivingParams);
83083:   if (NS_FAILED(nsrv)) {
83083:     NS_ERROR("GetDefaultCERTValInParam failed in DispatchCertErrorRunnable");
83083:     PR_SetError(defaultErrorCodeToReport, 0);
83083:     return SECFailure;
83083:   }
83083:   
 6597:   PRArenaPool *log_arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
 6597:   PRArenaPoolCleanerFalseParam log_arena_cleaner(log_arena);
83083:   if (!log_arena) {
83083:     NS_ERROR("PORT_NewArena failed in DispatchCertErrorRunnable");
83083:     return SECFailure; // PORT_NewArena set error code
83083:   }
 6597: 
 6597:   CERTVerifyLog *verify_log = PORT_ArenaZNew(log_arena, CERTVerifyLog);
83083:   if (!verify_log) {
83083:     NS_ERROR("PORT_ArenaZNew failed in DispatchCertErrorRunnable");
83083:     return SECFailure; // PORT_ArenaZNew set error code
83083:   }
 6597:   CERTVerifyLogContentsCleaner verify_log_cleaner(verify_log);
 6597:   verify_log->arena = log_arena;
 6597: 
69383:   if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
83083:     srv = CERT_VerifyCertificate(CERT_GetDefaultCertDB(), &cert,
79873:                                 true, certificateUsageSSLServer,
83083:                                 PR_Now(), static_cast<void*>(socketInfo),
 6597:                                 verify_log, NULL);
69383:   }
69383:   else {
69383:     CERTValOutParam cvout[2];
69383:     cvout[0].type = cert_po_errorLog;
69383:     cvout[0].value.pointer.log = verify_log;
69383:     cvout[1].type = cert_po_end;
69383: 
83083:     srv = CERT_PKIXVerifyCert(&cert, certificateUsageSSLServer,
69383:                               survivingParams->GetRawPointerForNSS(),
83083:                               cvout, static_cast<void*>(socketInfo));
69383:   }
 6597: 
 6597:   // We ignore the result code of the cert verification.
 6597:   // Either it is a failure, which is expected, and we'll process the
 6597:   //                         verify log below.
 6597:   // Or it is a success, then a domain mismatch is the only 
 6597:   //                     possible failure. 
 6597: 
79873:   PRErrorCode errorCodeMismatch = 0;
79873:   PRErrorCode errorCodeTrust = 0;
79873:   PRErrorCode errorCodeExpired = 0;
79873: 
79873:   PRUint32 collected_errors = 0;
79873: 
83083:   if (socketInfo->IsCertIssuerBlacklisted()) {
79873:     collected_errors |= nsICertOverrideService::ERROR_UNTRUSTED;
83083:     errorCodeTrust = defaultErrorCodeToReport;
83083:   }
83083: 
83083:   // Check the name field against the desired hostname.
83083:   if (CERT_VerifyCertName(&cert, socketInfo->GetHostName()) != SECSuccess) {
79873:     collected_errors |= nsICertOverrideService::ERROR_MISMATCH;
79873:     errorCodeMismatch = SSL_ERROR_BAD_CERT_DOMAIN;
79873:   }
79873: 
 6597:   CERTVerifyLogNode *i_node;
83083:   for (i_node = verify_log->head; i_node; i_node = i_node->next)
 6597:   {
 6597:     switch (i_node->error)
 6597:     {
 6597:       case SEC_ERROR_UNKNOWN_ISSUER:
 6597:       case SEC_ERROR_CA_CERT_INVALID:
 6597:       case SEC_ERROR_UNTRUSTED_ISSUER:
 6597:       case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
 6597:       case SEC_ERROR_UNTRUSTED_CERT:
13929:       case SEC_ERROR_INADEQUATE_KEY_USAGE:
 6597:         // We group all these errors as "cert not trusted"
 6597:         collected_errors |= nsICertOverrideService::ERROR_UNTRUSTED;
 7252:         if (errorCodeTrust == SECSuccess) {
 7252:           errorCodeTrust = i_node->error;
 7252:         }
 6597:         break;
 6597:       case SSL_ERROR_BAD_CERT_DOMAIN:
 6597:         collected_errors |= nsICertOverrideService::ERROR_MISMATCH;
 7252:         if (errorCodeMismatch == SECSuccess) {
 7252:           errorCodeMismatch = i_node->error;
 7252:         }
 6597:         break;
 6597:       case SEC_ERROR_EXPIRED_CERTIFICATE:
 6597:         collected_errors |= nsICertOverrideService::ERROR_TIME;
 7252:         if (errorCodeExpired == SECSuccess) {
 7252:           errorCodeExpired = i_node->error;
 7252:         }
 6597:         break;
 6597:       default:
83083:         PR_SetError(i_node->error, 0);
83083:         return SECFailure;
 6597:     }
 6597:   }
 6597: 
 6597:   if (!collected_errors)
 6597:   {
83083:     // This will happen when CERT_*Verify* only returned error(s) that are
83083:     // not on our whitelist of overridable certificate errors.
83083:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] !collected_errors: %d\n",
83083:            fdForLogging, static_cast<int>(defaultErrorCodeToReport)));
83083:     PR_SetError(defaultErrorCodeToReport, 0);
83083:     return SECFailure;
83083:   }
83083: 
83083:   socketInfo->SetStatusErrorBits(*nssCert, collected_errors);
83083: 
83083:   nsRefPtr<CertErrorRunnable> runnable =
83083:     new CertErrorRunnable(fdForLogging, 
83083:                           static_cast<nsIX509Cert*>(nssCert.get()),
83083:                           socketInfo, defaultErrorCodeToReport, 
83083:                           collected_errors, errorCodeTrust, 
83083:                           errorCodeMismatch, errorCodeExpired);
83083: 
83083:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
83083:           ("[%p][%p] Before dispatching CertErrorRunnable\n",
83083:           fdForLogging, runnable.get()));
83083: 
83083:   nsresult nrv;
83083:   nsCOMPtr<nsIEventTarget> stsTarget
83083:     = do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID, &nrv);
83083:   if (NS_SUCCEEDED(nrv)) {
83083:     nrv = stsTarget->Dispatch(runnable, NS_DISPATCH_NORMAL);
83083:   }
83083:   if (NS_FAILED(nrv)) {
83083:     NS_ERROR("Failed to dispatch CertErrorRunnable");
83083:     PR_SetError(defaultErrorCodeToReport, 0);
83083:     return SECFailure;
83083:   }
83083: 
83083:   return SECSuccess;
83083: }
83083: 
83083: } } // namespace mozilla::psm
83083: 
83083: void
83083: nsNSSSocketInfo::SetStatusErrorBits(nsIX509Cert & cert,
83083:                                     PRUint32 collected_errors)
83083: {
83083:   MutexAutoLock lock(mMutex);
83083: 
83083:   if (!mSSLStatus)
83083:     mSSLStatus = new nsSSLStatus();
83083: 
83083:   mSSLStatus->mServerCert = &cert;
83083: 
83083:   mSSLStatus->mHaveCertErrorBits = true;
83083:   mSSLStatus->mIsDomainMismatch = 
83083:     collected_errors & nsICertOverrideService::ERROR_MISMATCH;
83083:   mSSLStatus->mIsNotValidAtThisTime = 
83083:     collected_errors & nsICertOverrideService::ERROR_TIME;
83083:   mSSLStatus->mIsUntrusted = 
83083:     collected_errors & nsICertOverrideService::ERROR_UNTRUSTED;
83083: 
83083:   nsSSLIOLayerHelpers::mHostsWithCertErrors->RememberCertHasError(
83083:     this, mSSLStatus, SECFailure);
83083: }
83083: 
83083: SSLServerCertVerificationResult *
83083: CertErrorRunnable::CheckCertOverrides()
83083: {
83083:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p][%p] top of CertErrorRunnable::Run\n",
79873:                                     mFdForLogging, this));
83083: 
83083:   if (!NS_IsMainThread()) {
83083:     NS_ERROR("CertErrorRunnable::CheckCertOverrides called off main thread");
83083:     return new SSLServerCertVerificationResult(*mInfoObject,
83083:                                                mDefaultErrorCodeToReport);
83083:   }
79873: 
79873:   PRInt32 port;
79873:   mInfoObject->GetPort(&port);
79873: 
83083:   nsCString hostWithPortString;
83083:   hostWithPortString.AppendASCII(mInfoObject->GetHostName());
79873:   hostWithPortString.AppendLiteral(":");
79873:   hostWithPortString.AppendInt(port);
79873: 
83083:   PRUint32 remaining_display_errors = mCollectedErrors;
79873: 
79873:   nsresult nsrv;
 6597: 
51363:   // Enforce Strict-Transport-Security for hosts that are "STS" hosts:
51363:   // connections must be dropped when there are any certificate errors
51363:   // (STS Spec section 7.3).
79873:   bool strictTransportSecurityEnabled = false;
51363:   nsCOMPtr<nsIStrictTransportSecurityService> stss
79873:     = do_GetService(NS_STSSERVICE_CONTRACTID, &nsrv);
79873:   if (NS_SUCCEEDED(nsrv)) {
83083:     nsrv = stss->IsStsHost(mInfoObject->GetHostName(),
83083:                            &strictTransportSecurityEnabled);
83083:   }
83083:   if (NS_FAILED(nsrv)) {
83083:     return new SSLServerCertVerificationResult(*mInfoObject,
83083:                                                mDefaultErrorCodeToReport);
83083:   }
51363: 
51363:   if (!strictTransportSecurityEnabled) {
 6597:     nsCOMPtr<nsICertOverrideService> overrideService =
 6597:       do_GetService(NS_CERTOVERRIDE_CONTRACTID);
 6597:     // it is fine to continue without the nsICertOverrideService
 6597: 
 8176:     PRUint32 overrideBits = 0;
 6597: 
 6597:     if (overrideService)
 6597:     {
79445:       bool haveOverride;
79445:       bool isTemporaryOverride; // we don't care
83083:       nsCString hostString(mInfoObject->GetHostName());
14555:       nsrv = overrideService->HasMatchingOverride(hostString, port,
79873:                                                   mCert,
 8176:                                                   &overrideBits,
 8176:                                                   &isTemporaryOverride, 
 8176:                                                   &haveOverride);
 8176:       if (NS_SUCCEEDED(nsrv) && haveOverride) 
 6597:       {
 6597:        // remove the errors that are already overriden
 8176:         remaining_display_errors -= overrideBits;
 6597:       }
 6597:     }
 6597: 
 6597:     if (!remaining_display_errors) {
 6597:       // all errors are covered by override rules, so let's accept the cert
79873:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
79873:              ("[%p][%p] All errors covered by override rules\n",
79873:              mFdForLogging, this));
83083:       return new SSLServerCertVerificationResult(*mInfoObject, 0);
 6597:     }
51363:   } else {
79873:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
79873:            ("[%p][%p] Strict-Transport-Security is violated: untrusted "
79873:             "transport layer\n", mFdForLogging, this));
79873:   }
79873: 
79873:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
79873:          ("[%p][%p] Certificate error was not overridden\n",
79873:          mFdForLogging, this));
 6597: 
 6597:   // Ok, this is a full stop.
83081:   // First, deliver the technical details of the broken SSL status.
 6597: 
 6597:   // Try to get a nsIBadCertListener2 implementation from the socket consumer.
14244:   nsCOMPtr<nsIInterfaceRequestor> cb;
79873:   mInfoObject->GetNotificationCallbacks(getter_AddRefs(cb));
14244:   if (cb) {
79873:     nsCOMPtr<nsIBadCertListener2> bcl = do_GetInterface(cb);
76734:     if (bcl) {
79873:       nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(mInfoObject);
83081:       bool suppressMessage = false; // obsolete, ignored
83083:       nsrv = bcl->NotifyCertProblem(csi, mInfoObject->SSLStatus(),
83083:                                     hostWithPortString, &suppressMessage);
76734:     }
 6597:   }
 6597: 
 7054:   nsCOMPtr<nsIRecentBadCertsService> recentBadCertsService = 
 7054:     do_GetService(NS_RECENTBADCERTS_CONTRACTID);
 7054:  
 7054:   if (recentBadCertsService) {
83083:     NS_ConvertUTF8toUTF16 hostWithPortStringUTF16(hostWithPortString);
83083:     recentBadCertsService->AddBadCert(hostWithPortStringUTF16,
83083:                                       mInfoObject->SSLStatus());
 7054:   }
 7054: 
 7252:   // pick the error code to report by priority
83083:   PRErrorCode errorCodeToReport = mErrorCodeTrust    ? mErrorCodeTrust
83083:                                 : mErrorCodeMismatch ? mErrorCodeMismatch
83083:                                 : mErrorCodeExpired  ? mErrorCodeExpired
83083:                                 : mDefaultErrorCodeToReport;
83083: 
83083:   return new SSLServerCertVerificationResult(*mInfoObject, errorCodeToReport,
83083:                                              OverridableCertErrorMessage);
83083: }
83083: 
83083: NS_IMETHODIMP
83083: CertErrorRunnable::Run()
83083: {
83083:   // This code is confusing: First, Run() is called on the socket transport
83083:   // thread. Then we re-dispatch it to the main thread synchronously (step 1).
83083:   // On the main thread, we call CheckCertOverrides (step 2). Then we return
83083:   // from the main thread and are back on the socket transport thread. There,
83083:   // we run the result runnable directly (step 3).
83083:   if (!NS_IsMainThread()) {
83083:     // We are running on the socket transport thread. We need to re-dispatch
83083:     // ourselves synchronously to the main thread.
83083:     DispatchToMainThreadAndWait(); // step 1
83083: 
83083:     // step 3
83083:     if (!mResult) {
83083:       // Either the dispatch failed or CheckCertOverrides wrongly returned null
83083:       NS_ERROR("Did not create a SSLServerCertVerificationResult");
83083:       mResult = new SSLServerCertVerificationResult(*mInfoObject,
83083:                                                     PR_INVALID_STATE_ERROR);
83083:     }
83083:     return mResult->Run(); 
83083:   } else {
83083:     // block this thread (the socket transport thread) until RunOnTargetThread
83083:     // is complete.
83083:     return SyncRunnableBase::Run(); // step 2
83083:   }
83083: }
83083: 
83083: void 
83083: CertErrorRunnable::RunOnTargetThread()
83083: {
83083:   // Now we are running on the main thread, blocking the socket tranposrt
83083:   // thread. This is exactly the state we need to be in to call
83083:   // CheckCertOverrides; CheckCertOverrides must block events on both of
83083:   // these threads because it calls nsNSSSocketInfo::GetInterface(),
83083:   // which calls nsHttpConnection::GetInterface() through
83083:   // nsNSSSocketInfo::mCallbacks. nsHttpConnection::GetInterface must always
83083:   // execute on the main thread, with the socket transport thread blocked.
83083:   mResult = CheckCertOverrides(); 
    1: }
    1:  
    1: static PRFileDesc*
    1: nsSSLIOLayerImportFD(PRFileDesc *fd,
    1:                      nsNSSSocketInfo *infoObject,
25076:                      const char *host,
79445:                      bool anonymousLoad)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   PRFileDesc* sslSock = SSL_ImportFD(nsnull, fd);
    1:   if (!sslSock) {
80486:     NS_ASSERTION(false, "NSS: Error importing socket");
    1:     return nsnull;
    1:   }
    1:   SSL_SetPKCS11PinArg(sslSock, (nsIInterfaceRequestor*)infoObject);
    1:   SSL_HandshakeCallback(sslSock, HandshakeCallback, infoObject);
25076: 
25076:   // Disable this hook if we connect anonymously. See bug 466080.
25076:   if (anonymousLoad) {
25076:       SSL_GetClientAuthDataHook(sslSock, NULL, infoObject);
25076:   } else {
    1:       SSL_GetClientAuthDataHook(sslSock, 
    1:                             (SSLGetClientAuthData)nsNSS_SSLGetClientAuthData,
    1:                             infoObject);
25076:   }
83083:   if (SECSuccess != SSL_AuthCertificateHook(sslSock, AuthCertificateHook,
83083:                                             infoObject)) {
83083:     NS_NOTREACHED("failed to configure AuthCertificateHook");
83083:     goto loser;
83083:   }
83083: 
83083:   if (SECSuccess != SSL_SetURL(sslSock, host)) {
83083:     NS_NOTREACHED("SSL_SetURL failed");
    1:     goto loser;
    1:   }
    1:   return sslSock;
    1: loser:
    1:   if (sslSock) {
    1:     PR_Close(sslSock);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: static nsresult
79445: nsSSLIOLayerSetOptions(PRFileDesc *fd, bool forSTARTTLS, 
    1:                        const char *proxyHost, const char *host, PRInt32 port,
79445:                        bool anonymousLoad, nsNSSSocketInfo *infoObject)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (forSTARTTLS || proxyHost) {
80486:     if (SECSuccess != SSL_OptionSet(fd, SSL_SECURITY, false)) {
    1:       return NS_ERROR_FAILURE;
    1:     }
80486:     infoObject->SetHasCleartextPhase(true);
    1:   }
    1: 
    1:   // Let's see if we're trying to connect to a site we know is
    1:   // TLS intolerant.
    1:   nsCAutoString key;
    1:   key = nsDependentCString(host) + NS_LITERAL_CSTRING(":") + nsPrintfCString("%d", port);
    1: 
    1:   if (nsSSLIOLayerHelpers::isKnownAsIntolerantSite(key)) {
80486:     if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_TLS, false))
    1:       return NS_ERROR_FAILURE;
    1: 
80486:     infoObject->SetAllowTLSIntoleranceTimeout(false);
    1:       
    1:     // We assume that protocols that use the STARTTLS mechanism should support
    1:     // modern hellos. For other protocols, if we suspect a site 
    1:     // does not support TLS, let's also use V2 hellos.
    1:     // One advantage of this approach, if a site only supports the older
    1:     // hellos, it is more likely that we will get a reasonable error code
    1:     // on our single retry attempt.
    1:   }
    1: 
80486:   if (SECSuccess != SSL_OptionSet(fd, SSL_HANDSHAKE_AS_CLIENT, true)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   
37963:   if (nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(nsDependentCString(host))) {
80486:     if (SECSuccess != SSL_OptionSet(fd, SSL_REQUIRE_SAFE_NEGOTIATION, false)) {
37963:       return NS_ERROR_FAILURE;
37963:     }
37963:     if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_RENEGOTIATION, SSL_RENEGOTIATE_UNRESTRICTED)) {
37963:       return NS_ERROR_FAILURE;
37963:     }
37963:   }
37963: 
    1:   // Set the Peer ID so that SSL proxy connections work properly.
25076:   char *peerId;
25076:   if (anonymousLoad) {  // See bug #466080. Separate the caches.
25076:       peerId = PR_smprintf("anon:%s:%d", host, port);
25076:   } else {
25076:       peerId = PR_smprintf("%s:%d", host, port);
25076:   }
25076:   
    1:   if (SECSuccess != SSL_SetSockPeerID(fd, peerId)) {
    1:     PR_smprintf_free(peerId);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   PR_smprintf_free(peerId);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSSLIOLayerAddToSocket(PRInt32 family,
    1:                         const char* host,
    1:                         PRInt32 port,
    1:                         const char* proxyHost,
    1:                         PRInt32 proxyPort,
    1:                         PRFileDesc* fd,
    1:                         nsISupports** info,
79445:                         bool forSTARTTLS,
79445:                         bool anonymousLoad)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   PRFileDesc* layer = nsnull;
    1:   nsresult rv;
    1: 
    1:   nsNSSSocketInfo* infoObject = new nsNSSSocketInfo();
    1:   if (!infoObject) return NS_ERROR_FAILURE;
    1:   
    1:   NS_ADDREF(infoObject);
    1:   infoObject->SetForSTARTTLS(forSTARTTLS);
    1:   infoObject->SetHostName(host);
    1:   infoObject->SetPort(port);
    1: 
25076:   PRFileDesc *sslSock = nsSSLIOLayerImportFD(fd, infoObject, host, anonymousLoad);
    1:   if (!sslSock) {
80486:     NS_ASSERTION(false, "NSS: Error importing socket");
    1:     goto loser;
    1:   }
    1: 
    1:   infoObject->SetFileDescPtr(sslSock);
    1: 
25076:   rv = nsSSLIOLayerSetOptions(sslSock,
25076:                               forSTARTTLS, proxyHost, host, port, anonymousLoad,
    1:                               infoObject);
    1: 
    1:   if (NS_FAILED(rv))
    1:     goto loser;
    1: 
    1:   /* Now, layer ourselves on top of the SSL socket... */
    1:   layer = PR_CreateIOLayerStub(nsSSLIOLayerHelpers::nsSSLIOLayerIdentity,
    1:                                &nsSSLIOLayerHelpers::nsSSLIOLayerMethods);
    1:   if (!layer)
    1:     goto loser;
    1:   
    1:   layer->secret = (PRFilePrivate*) infoObject;
    1:   rv = PR_PushIOLayer(sslSock, PR_GetLayersIdentity(sslSock), layer);
    1:   
    1:   if (NS_FAILED(rv)) {
    1:     goto loser;
    1:   }
    1:   
    1:   nsNSSShutDownList::trackSSLSocketCreate();
    1: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] Socket set up\n", (void*)sslSock));
    1:   infoObject->QueryInterface(NS_GET_IID(nsISupports), (void**) (info));
    1: 
    1:   // We are going use a clear connection first //
    1:   if (forSTARTTLS || proxyHost) {
80486:     infoObject->SetHandshakePending(false);
    1:   }
    1: 
    1:   return NS_OK;
    1:  loser:
    1:   NS_IF_RELEASE(infoObject);
    1:   if (layer) {
    1:     layer->dtor(layer);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
