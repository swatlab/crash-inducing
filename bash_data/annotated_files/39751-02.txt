    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Kathleen Brade <brade@netscape.com>
    1:  *   David Gardiner <david.gardiner@unisa.edu.au>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCopySupport.h"
    1: #include "nsIDocumentEncoder.h"
    1: #include "nsISupports.h"
    1: #include "nsIContent.h"
    1: #include "nsIComponentManager.h" 
    1: #include "nsIServiceManager.h"
    1: #include "nsIClipboard.h"
    1: #include "nsISelection.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsIDOMRange.h"
30479: #include "imgIContainer.h"
39646: #include "nsIPresShell.h"
39646: #include "nsFocusManager.h"
39646: #include "nsEventDispatcher.h"
    1: 
    1: #include "nsIDocShell.h"
    1: #include "nsIContentViewerEdit.h"
    1: #include "nsIClipboardDragDropHooks.h"
    1: #include "nsIClipboardDragDropHookList.h"
39646: #include "nsIClipboardHelper.h"
39646: #include "nsISelectionController.h"
    1: 
39646: #include "nsPIDOMWindow.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsGkAtoms.h"
39646: #include "nsGUIEvent.h"
39646: #include "nsIFrame.h"
    1: 
    1: // image copy stuff
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsContentUtils.h"
    1: #include "nsContentCID.h"
    1: 
    1: static NS_DEFINE_CID(kCClipboardCID,           NS_CLIPBOARD_CID);
    1: static NS_DEFINE_CID(kCTransferableCID,        NS_TRANSFERABLE_CID);
    1: static NS_DEFINE_CID(kHTMLConverterCID,        NS_HTMLFORMATCONVERTER_CID);
    1: 
    1: // private clipboard data flavors for html copy, used by editor when pasting
    1: #define kHTMLContext   "text/_moz_htmlcontext"
    1: #define kHTMLInfo      "text/_moz_htmlinfo"
    1: 
    1: // copy string data onto the transferable
    1: static nsresult AppendString(nsITransferable *aTransferable,
    1:                              const nsAString& aString,
    1:                              const char* aFlavor);
    1: 
    1: // copy HTML node data
    1: static nsresult AppendDOMNode(nsITransferable *aTransferable,
    1:                               nsIDOMNode *aDOMNode);
    1: 
26757: // Helper used for HTMLCopy and GetTransferableForSelection since both routines
26757: // share common code.
26757: static nsresult
26757: SelectionCopyHelper(nsISelection *aSel, nsIDocument *aDoc,
26757:                     PRBool doPutOnClipboard, PRInt16 aClipboardID,
26757:                     nsITransferable ** aTransferable)
    1: {
26757:   // Clear the output parameter for the transferable, if provided.
26757:   if (aTransferable) {
26757:     *aTransferable = nsnull;
26757:   }
26757: 
    1:   nsresult rv = NS_OK;
    1:   
    1:   PRBool bIsPlainTextContext = PR_FALSE;
    1: 
26757:   rv = nsCopySupport::IsPlainTextContext(aSel, aDoc, &bIsPlainTextContext);
    1:   if (NS_FAILED(rv)) 
    1:     return rv;
    1: 
    1:   PRBool bIsHTMLCopy = !bIsPlainTextContext;
    1:   nsAutoString mimeType;
    1: 
    1:   nsCOMPtr<nsIDocumentEncoder> docEncoder;
    1: 
    1:   docEncoder = do_CreateInstance(NS_HTMLCOPY_ENCODER_CONTRACTID);
    1:   NS_ENSURE_TRUE(docEncoder, NS_ERROR_FAILURE);
    1: 
    1:   // We always require a plaintext version
34681:   
34681:   // note that we assign text/unicode as mime type, but in fact nsHTMLCopyEncoder
34681:   // ignore it and use text/html or text/plain depending where the selection
34681:   // is. if it is a selection into input/textarea element or in a html content
34681:   // with pre-wrap style : text/plain. Otherwise text/html.
34681:   // see nsHTMLCopyEncoder::SetSelection
    1:   mimeType.AssignLiteral(kUnicodeMime);
34681:   
34681:   // we want preformatted for the case where the selection is inside input/textarea
34681:   // and we don't want pretty printing for others cases, to not have additionnal
34681:   // line breaks which are then converted into spaces by the htmlConverter (see bug #524975)
34681:   PRUint32 flags = nsIDocumentEncoder::OutputPreformatted | nsIDocumentEncoder::OutputRaw;
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(aDoc);
    1:   NS_ASSERTION(domDoc, "Need a document");
    1: 
    1:   rv = docEncoder->Init(domDoc, mimeType, flags);
    1:   if (NS_FAILED(rv)) 
    1:     return rv;
26757: 
    1:   rv = docEncoder->SetSelection(aSel);
    1:   if (NS_FAILED(rv)) 
    1:     return rv;
    1: 
    1:   nsAutoString buffer, parents, info, textBuffer, plaintextBuffer;
    1: 
    1:   rv = docEncoder->EncodeToString(textBuffer);
    1:   if (NS_FAILED(rv)) 
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIFormatConverter> htmlConverter;
    1: 
    1:   // sometimes we also need the HTML version
    1:   if (bIsHTMLCopy) {
    1: 
    1:     // this string may still contain HTML formatting, so we need to remove that too.
    1:     htmlConverter = do_CreateInstance(kHTMLConverterCID);
    1:     NS_ENSURE_TRUE(htmlConverter, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsISupportsString> plainHTML = do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID);
    1:     NS_ENSURE_TRUE(plainHTML, NS_ERROR_FAILURE);
    1:     plainHTML->SetData(textBuffer);
    1: 
    1:     nsCOMPtr<nsISupportsString> ConvertedData;
    1:     PRUint32 ConvertedLen;
    1:     rv = htmlConverter->Convert(kHTMLMime, plainHTML, textBuffer.Length() * 2, kUnicodeMime, getter_AddRefs(ConvertedData), &ConvertedLen);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     ConvertedData->GetData(plaintextBuffer);
    1: 
    1:     mimeType.AssignLiteral(kHTMLMime);
    1: 
    1:     flags = 0;
    1: 
    1:     rv = docEncoder->Init(domDoc, mimeType, flags);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = docEncoder->SetSelection(aSel);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // encode the selection as html with contextual info
    1:     rv = docEncoder->EncodeToStringWithContext(parents, info, buffer);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   
    1:   // Get the Clipboard
26757:   nsCOMPtr<nsIClipboard> clipboard;
26757:   if (doPutOnClipboard) {
26757:     clipboard = do_GetService(kCClipboardCID, &rv);
    1:     if (NS_FAILED(rv))
    1:       return rv;
26757:   }
    1: 
26757:   if ((doPutOnClipboard && clipboard) || aTransferable != nsnull) {
    1:     // Create a transferable for putting data on the Clipboard
    1:     nsCOMPtr<nsITransferable> trans = do_CreateInstance(kCTransferableCID);
26757:     if (trans) {
26757:       if (bIsHTMLCopy) {
    1:         // set up the data converter
    1:         trans->SetConverter(htmlConverter);
    1: 
26757:         if (!buffer.IsEmpty()) {
    1:           // Add the html DataFlavor to the transferable
    1:           rv = AppendString(trans, buffer, kHTMLMime);
    1:           NS_ENSURE_SUCCESS(rv, rv);
    1:         }
26757: 
    1:         // Add the htmlcontext DataFlavor to the transferable
    1:         // Even if parents is empty string, this flavor should
    1:         // be attached to the transferable
    1:         rv = AppendString(trans, parents, kHTMLContext);
    1:         NS_ENSURE_SUCCESS(rv, rv);
26757: 
26757:         if (!info.IsEmpty()) {
    1:           // Add the htmlinfo DataFlavor to the transferable
    1:           rv = AppendString(trans, info, kHTMLInfo);
    1:           NS_ENSURE_SUCCESS(rv, rv);
    1:         }
26757: 
26757:         if (!plaintextBuffer.IsEmpty()) {
    1:           // unicode text
    1:           // Add the unicode DataFlavor to the transferable
    1:           // If we didn't have this, then nsDataObj::GetData matches text/unicode against
    1:           // the kURLMime flavour which is not desirable (eg. when pasting into Notepad)
    1:           rv = AppendString(trans, plaintextBuffer, kUnicodeMime);
    1:           NS_ENSURE_SUCCESS(rv, rv);
    1:         }
    1: 
    1:         // Try and get source URI of the items that are being dragged
    1:         nsIURI *uri = aDoc->GetDocumentURI();
    1:         if (uri) {
    1:           nsCAutoString spec;
    1:           uri->GetSpec(spec);
    1:           if (!spec.IsEmpty()) {
    1:             nsAutoString shortcut;
    1:             AppendUTF8toUTF16(spec, shortcut);
    1: 
    1:             // Add the URL DataFlavor to the transferable. Don't use kURLMime, as it will
    1:             // cause an unnecessary UniformResourceLocator to be added which confuses
    1:             // some apps eg. Outlook 2000 - (See Bug 315370). Don't use
    1:             // kURLDataMime, as it will cause a bogus 'url ' flavor to
    1:             // show up on the Mac clipboard, confusing other apps, like
    1:             // Terminal (see bug 336012).
    1:             rv = AppendString(trans, shortcut, kURLPrivateMime);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1:           }
    1:         }
26757:       } else {
26757:         if (!textBuffer.IsEmpty()) {
    1:           // Add the unicode DataFlavor to the transferable
    1:           rv = AppendString(trans, textBuffer, kUnicodeMime);
    1:           NS_ENSURE_SUCCESS(rv, rv);
    1:         }
    1:       }
    1: 
26757:       if (doPutOnClipboard && clipboard) {
26757:         PRBool actuallyPutOnClipboard = PR_TRUE;
26757:         nsCopySupport::DoHooks(aDoc, trans, &actuallyPutOnClipboard);
    1: 
    1:         // put the transferable on the clipboard
26757:         if (actuallyPutOnClipboard)
    1:           clipboard->SetData(trans, nsnull, aClipboardID);
    1:       }
26757: 
26757:       // Return the transferable to the caller if requested.
26757:       if (aTransferable != nsnull) {
26757:         trans.swap(*aTransferable);
26757:       }
26757:     }
    1:   }
    1:   return rv;
    1: }
    1: 
26757: nsresult nsCopySupport::HTMLCopy(nsISelection *aSel, nsIDocument *aDoc, PRInt16 aClipboardID)
26757: {
26757:   return SelectionCopyHelper(aSel, aDoc, PR_TRUE, aClipboardID, nsnull);
26757: }
26757: 
26757: nsresult
26757: nsCopySupport::GetTransferableForSelection(nsISelection * aSel,
26757:                                            nsIDocument * aDoc,
26757:                                            nsITransferable ** aTransferable)
26757: {
26757:   return SelectionCopyHelper(aSel, aDoc, PR_FALSE, 0, aTransferable);
26757: }
26757: 
    1: nsresult nsCopySupport::DoHooks(nsIDocument *aDoc, nsITransferable *aTrans,
    1:                                 PRBool *aDoPutOnClipboard)
    1: {
    1:   NS_ENSURE_ARG(aDoc);
    1: 
    1:   *aDoPutOnClipboard = PR_TRUE;
    1: 
    1:   nsCOMPtr<nsISupports> container = aDoc->GetContainer();
    1:   nsCOMPtr<nsIClipboardDragDropHookList> hookObj = do_GetInterface(container);
    1:   if (!hookObj) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> enumerator;
    1:   hookObj->GetHookEnumerator(getter_AddRefs(enumerator));
    1:   if (!enumerator) return NS_ERROR_FAILURE;
    1: 
    1:   // the logic here should follow the behavior specified in
    1:   // nsIClipboardDragDropHooks.h
    1: 
    1:   nsCOMPtr<nsIClipboardDragDropHooks> override;
    1:   nsCOMPtr<nsISupports> isupp;
    1:   PRBool hasMoreHooks = PR_FALSE;
    1:   nsresult rv = NS_OK;
    1:   while (NS_SUCCEEDED(enumerator->HasMoreElements(&hasMoreHooks))
    1:          && hasMoreHooks)
    1:   {
    1:     rv = enumerator->GetNext(getter_AddRefs(isupp));
    1:     if (NS_FAILED(rv)) break;
    1:     override = do_QueryInterface(isupp);
    1:     if (override)
    1:     {
    1: #ifdef DEBUG
    1:       nsresult hookResult =
    1: #endif
    1:       override->OnCopyOrDrag(nsnull, aTrans, aDoPutOnClipboard);
    1:       NS_ASSERTION(NS_SUCCEEDED(hookResult), "OnCopyOrDrag hook failed");
    1:       if (!*aDoPutOnClipboard)
    1:         break;
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult nsCopySupport::IsPlainTextContext(nsISelection *aSel, nsIDocument *aDoc, PRBool *aIsPlainTextContext)
    1: {
    1:   nsresult rv;
    1: 
    1:   if (!aSel || !aIsPlainTextContext)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aIsPlainTextContext = PR_FALSE;
    1:   
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   nsCOMPtr<nsIDOMNode> commonParent;
    1:   PRInt32 count = 0;
    1: 
    1:   rv = aSel->GetRangeCount(&count);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // if selection is uninitialized return
    1:   if (!count)
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   // we'll just use the common parent of the first range.  Implicit assumption
    1:   // here that multi-range selections are table cell selections, in which case
    1:   // the common parent is somewhere in the table and we don't really care where.
    1:   rv = aSel->GetRangeAt(0, getter_AddRefs(range));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!range)
    1:     return NS_ERROR_NULL_POINTER;
    1:   range->GetCommonAncestorContainer(getter_AddRefs(commonParent));
    1: 
    1:   for (nsCOMPtr<nsIContent> selContent(do_QueryInterface(commonParent));
    1:        selContent;
    1:        selContent = selContent->GetParent())
    1:   {
    1:     // checking for selection inside a plaintext form widget
    1: 
33329:     if (!selContent->IsHTML()) {
    1:       continue;
    1:     }
    1: 
    1:     nsIAtom *atom = selContent->Tag();
    1: 
    1:     if (atom == nsGkAtoms::input ||
    1:         atom == nsGkAtoms::textarea)
    1:     {
    1:       *aIsPlainTextContext = PR_TRUE;
    1:       break;
    1:     }
    1: 
    1:     if (atom == nsGkAtoms::body)
    1:     {
    1:       // check for moz prewrap style on body.  If it's there we are 
    1:       // in a plaintext editor.  This is pretty cheezy but I haven't 
    1:       // found a good way to tell if we are in a plaintext editor.
    1:       nsCOMPtr<nsIDOMElement> bodyElem = do_QueryInterface(selContent);
    1:       nsAutoString wsVal;
    1:       rv = bodyElem->GetAttribute(NS_LITERAL_STRING("style"), wsVal);
11894:       if (NS_SUCCEEDED(rv) && (kNotFound != wsVal.Find(NS_LITERAL_STRING("pre-wrap"))))
    1:       {
    1:         *aIsPlainTextContext = PR_TRUE;
    1:         break;
    1:       }
    1:     }
    1:   }
    1:   
    1:   // also consider ourselves in a text widget if we can't find an html
    1:   // document. Note that XHTML is not counted as HTML here, because we can't
    1:   // copy it properly (all the copy code for non-plaintext assumes using HTML
    1:   // serializers and parsers is OK, and those mess up XHTML).
    1:   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(aDoc);
31946:   if (!(htmlDoc && aDoc->IsHTML()))
    1:     *aIsPlainTextContext = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCopySupport::GetContents(const nsACString& aMimeType, PRUint32 aFlags, nsISelection *aSel, nsIDocument *aDoc, nsAString& outdata)
    1: {
    1:   nsresult rv = NS_OK;
    1:   
    1:   nsCOMPtr<nsIDocumentEncoder> docEncoder;
    1: 
    1:   nsCAutoString encoderContractID(NS_DOC_ENCODER_CONTRACTID_BASE);
    1:   encoderContractID.Append(aMimeType);
    1:     
    1:   docEncoder = do_CreateInstance(encoderContractID.get());
    1:   NS_ENSURE_TRUE(docEncoder, NS_ERROR_FAILURE);
    1: 
    1:   PRUint32 flags = aFlags;
    1:   
    1:   if (aMimeType.Equals("text/plain"))
    1:     flags |= nsIDocumentEncoder::OutputPreformatted;
    1: 
    1:   NS_ConvertASCIItoUTF16 unicodeMimeType(aMimeType);
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(aDoc);
    1:   NS_ASSERTION(domDoc, "Need a document");
    1: 
    1:   rv = docEncoder->Init(domDoc, unicodeMimeType, flags);
    1:   if (NS_FAILED(rv)) return rv;
    1:   
    1:   if (aSel)
    1:   {
    1:     rv = docEncoder->SetSelection(aSel);
    1:     if (NS_FAILED(rv)) return rv;
    1:   } 
    1:   
    1:   // encode the selection
    1:   return docEncoder->EncodeToString(outdata);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsCopySupport::ImageCopy(nsIImageLoadingContent* aImageElement,
    1:                          PRInt32 aCopyFlags)
    1: {
    1:   nsresult rv;
    1: 
    1:   // create a transferable for putting data on the Clipboard
    1:   nsCOMPtr<nsITransferable> trans(do_CreateInstance(kCTransferableCID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aCopyFlags & nsIContentViewerEdit::COPY_IMAGE_TEXT) {
    1:     // get the location from the element
    1:     nsCOMPtr<nsIURI> uri;
    1:     rv = aImageElement->GetCurrentURI(getter_AddRefs(uri));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     NS_ENSURE_TRUE(uri, NS_ERROR_FAILURE);
    1: 
    1:     nsCAutoString location;
    1:     rv = uri->GetSpec(location);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // append the string to the transferable
    1:     rv = AppendString(trans, NS_ConvertUTF8toUTF16(location), kUnicodeMime);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   if (aCopyFlags & nsIContentViewerEdit::COPY_IMAGE_HTML) {
    1:     // append HTML data to the transferable
    1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aImageElement, &rv));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = AppendDOMNode(trans, node);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   if (aCopyFlags & nsIContentViewerEdit::COPY_IMAGE_DATA) {
    1:     // get the image data from the element
30479:     nsCOMPtr<imgIContainer> image =
    1:       nsContentUtils::GetImageFromContent(aImageElement);
    1:     NS_ENSURE_TRUE(image, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsISupportsInterfacePointer>
    1:       imgPtr(do_CreateInstance(NS_SUPPORTS_INTERFACE_POINTER_CONTRACTID, &rv));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = imgPtr->SetData(image);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // copy the image data onto the transferable
    1:     rv = trans->SetTransferData(kNativeImageMime, imgPtr,
    1:                                 sizeof(nsISupports*));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // get clipboard
    1:   nsCOMPtr<nsIClipboard> clipboard(do_GetService(kCClipboardCID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // check whether the system supports the selection clipboard or not.
    1:   PRBool selectionSupported;
    1:   rv = clipboard->SupportsSelectionClipboard(&selectionSupported);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // put the transferable on the clipboard
    1:   if (selectionSupported) {
    1:     rv = clipboard->SetData(trans, nsnull, nsIClipboard::kSelectionClipboard);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return clipboard->SetData(trans, nsnull, nsIClipboard::kGlobalClipboard);
    1: }
    1: 
    1: static nsresult AppendString(nsITransferable *aTransferable,
    1:                              const nsAString& aString,
    1:                              const char* aFlavor)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsISupportsString>
    1:     data(do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = data->SetData(aString);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = aTransferable->AddDataFlavor(aFlavor);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return aTransferable->SetTransferData(aFlavor, data,
    1:                                         aString.Length() * sizeof(PRUnichar));
    1: }
    1: 
    1: static nsresult AppendDOMNode(nsITransferable *aTransferable,
    1:                               nsIDOMNode *aDOMNode)
    1: {
    1:   nsresult rv;
    1:   
    1:   // selializer
    1:   nsCOMPtr<nsIDocumentEncoder>
    1:     docEncoder(do_CreateInstance(NS_HTMLCOPY_ENCODER_CONTRACTID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // get document for the encoder
    1:   nsCOMPtr<nsIDOMDocument> domDocument;
    1:   rv = aDOMNode->GetOwnerDocument(getter_AddRefs(domDocument));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   nsCOMPtr<nsIDocument> document(do_QueryInterface(domDocument, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Note that XHTML is not counted as HTML here, because we can't copy it
    1:   // properly (all the copy code for non-plaintext assumes using HTML
    1:   // serializers and parsers is OK, and those mess up XHTML).
    1:   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(domDocument, &rv);
    1:   NS_ENSURE_SUCCESS(rv, NS_OK);
    1: 
31946:   NS_ENSURE_TRUE(document->IsHTML(), NS_OK);
    1: 
    1:   // init encoder with document and node
    1:   rv = docEncoder->Init(domDocument, NS_LITERAL_STRING(kHTMLMime),
    1:                         nsIDocumentEncoder::OutputAbsoluteLinks |
    1:                         nsIDocumentEncoder::OutputEncodeW3CEntities);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = docEncoder->SetNode(aDOMNode);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // serialize to string
    1:   nsAutoString html, context, info;
    1:   rv = docEncoder->EncodeToStringWithContext(context, info, html);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // copy them to the transferable
    1:   if (!html.IsEmpty()) {
    1:     rv = AppendString(aTransferable, html, kHTMLMime);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   if (!info.IsEmpty()) {
    1:     rv = AppendString(aTransferable, info, kHTMLInfo);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // add a special flavor, even if we don't have html context data
    1:   return AppendString(aTransferable, context, kHTMLContext);
    1: }
 4010: 
39646: nsIContent*
39646: nsCopySupport::GetSelectionForCopy(nsIDocument* aDocument, nsISelection** aSelection)
 4010: {
39646:   *aSelection = nsnull;
39646: 
39646:   nsIPresShell* presShell = aDocument->GetPrimaryShell();
39646:   if (!presShell)
39646:     return nsnull;
39646: 
39646:   // check if the focused node in the window has a selection
39646:   nsCOMPtr<nsPIDOMWindow> focusedWindow;
39646:   nsIContent* content =
39646:     nsFocusManager::GetFocusedDescendant(aDocument->GetWindow(), PR_FALSE,
39646:                                          getter_AddRefs(focusedWindow));
39646:   if (content) {
39646:     nsIFrame* frame = content->GetPrimaryFrame();
39646:     if (frame) {
39646:       nsCOMPtr<nsISelectionController> selCon;
39646:       frame->GetSelectionController(presShell->GetPresContext(), getter_AddRefs(selCon));
39646:       if (selCon) {
39646:         selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, aSelection);
39646:         return content;
39646:       }
39646:     }
39646:   }
39646: 
39646:   // if no selection was found, use the main selection for the window
39646:   NS_IF_ADDREF(*aSelection = presShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL));
39646:   return nsnull;
39646: }
39646: 
39646: PRBool
39646: nsCopySupport::CanCopy(nsIDocument* aDocument)
39646: {
39646:   if (!aDocument)
39646:     return PR_FALSE;
39646: 
39646:   nsCOMPtr<nsISelection> sel;
39646:   GetSelectionForCopy(aDocument, getter_AddRefs(sel));
39751:   NS_ENSURE_TRUE(sel, PR_FALSE);
39646: 
39646:   PRBool isCollapsed;
39646:   sel->GetIsCollapsed(&isCollapsed);
39646:   return !isCollapsed;
39646: }
39646: 
39646: PRBool
39646: nsCopySupport::FireClipboardEvent(PRInt32 aType, nsIPresShell* aPresShell, nsISelection* aSelection)
39646: {
39646:   NS_ASSERTION(aType == NS_CUT || aType == NS_COPY || aType == NS_PASTE,
39646:                "Invalid clipboard event type");
39646: 
39646:   nsCOMPtr<nsIPresShell> presShell = aPresShell;
39646:   if (!presShell)
39646:     return PR_FALSE;
39646: 
39646:   nsCOMPtr<nsIDocument> doc = presShell->GetDocument();
39646:   if (!doc)
39646:     return PR_FALSE;
39646: 
39646:   nsCOMPtr<nsPIDOMWindow> piWindow = doc->GetWindow();
39646:   if (!piWindow)
39646:     return PR_FALSE;
39646: 
39646:   // if a selection was not supplied, try to find it
39646:   nsCOMPtr<nsIContent> content;
39646:   nsCOMPtr<nsISelection> sel = aSelection;
39646:   if (!sel)
39646:     content = GetSelectionForCopy(doc, getter_AddRefs(sel));
39646: 
39646:   // retrieve the event target node from the start of the selection
39646:   if (sel) {
39646:     // Only cut or copy when there is an uncollapsed selection
39646:     if (aType == NS_CUT || aType == NS_COPY) {
39646:       PRBool isCollapsed;
39646:       sel->GetIsCollapsed(&isCollapsed);
39646:       if (isCollapsed)
39646:         return PR_FALSE;
39646:     }
 4010: 
 4010:     nsCOMPtr<nsIDOMRange> range;
39646:     nsresult rv = sel->GetRangeAt(0, getter_AddRefs(range));
39646:     if (NS_SUCCEEDED(rv) && range) {
39646:       nsCOMPtr<nsIDOMNode> startContainer;
39646:       range->GetStartContainer(getter_AddRefs(startContainer));
39646:       if (startContainer)
39646:         content = do_QueryInterface(startContainer);
39646:     }
39646:   }
 4010: 
39646:   // if no content node was set, just get the root
39646:   if (!content) {
39646:     content = doc->GetRootContent();
39646:     if (!content)
39646:       return PR_FALSE;
39646:   }
 4010: 
39646:   // It seems to be unsafe to fire an event handler during reflow (bug 393696)
39646:   if (!nsContentUtils::IsSafeToRunScript())
39646:     return PR_FALSE;
 4010: 
39646:   // next, fire the cut or copy event
39646:   nsEventStatus status = nsEventStatus_eIgnore;
39646:   nsEvent evt(PR_TRUE, aType);
39646:   nsEventDispatcher::Dispatch(content, presShell->GetPresContext(), &evt, nsnull,
39646:                               &status);
39646:   // if the event was cancelled, don't do the clipboard operation
39646:   if (status == nsEventStatus_eConsumeNoDefault)
39646:     return PR_FALSE;
39646: 
39646:   // no need to do anything special during a paste. Either an event listener
39646:   // took care of it and cancelled the event, or the caller will handle it.
39646:   // Return true to indicate the event wasn't cancelled.
39646:   if (aType == NS_PASTE)
39646:     return PR_TRUE;
39646: 
39646:   // call the copy code
39646:   if (NS_FAILED(nsCopySupport::HTMLCopy(sel, doc, nsIClipboard::kGlobalClipboard)))
39646:     return PR_FALSE;
39646: 
39646:   // Now that we have copied, update the clipboard commands. This should have
39646:   // the effect of updating the paste menu item.
39646:   piWindow->UpdateCommands(NS_LITERAL_STRING("clipboard"));
39646: 
39646:   return PR_TRUE;
 4010: }
