 1662: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
39447:  * Portions created by the Initial Developer are Copyright (C) 2005-2010
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
11789:  *   Mats Palmgren <mats.palmgren@bredband.net>
16418:  *   John Daggett <jdaggett@mozilla.com>
39447:  *   Jonathan Kew <jfkthame@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
39447: //#define FORCE_PR_LOG
    1: 
    1: #include "prtypes.h"
    1: #include "gfxTypes.h"
    1: 
    1: #include "gfxContext.h"
39447: #include "gfxUniscribeShaper.h"
    1: #include "gfxWindowsPlatform.h"
38493: #include "gfxAtoms.h"
    1: 
    1: #include "gfxFontTest.h"
    1: 
    1: #include "cairo.h"
    1: #include "cairo-win32.h"
    1: 
    1: #include <windows.h>
    1: 
 6076: #include "nsTArray.h"
    1: 
    1: #include "prlog.h"
14918: #include "prinit.h"
    1: static PRLogModuleInfo *gFontLog = PR_NewLogModule("winfonts");
    1: 
13578: /**********************************************************************
13578:  *
39447:  * class gfxUniscribeShaper
    1:  *
    1:  **********************************************************************/
    1: 
 7625: #define ESTIMATE_MAX_GLYPHS(L) (((3 * (L)) >> 1) + 16)
 7625: 
    1: class UniscribeItem
    1: {
    1: public:
    1:     UniscribeItem(gfxContext *aContext, HDC aDC,
39447:                   gfxUniscribeShaper *aShaper,
    1:                   const PRUnichar *aString, PRUint32 aLength,
42989:                   SCRIPT_ITEM *aItem, PRUint32 aIVS) :
39447:         mContext(aContext), mDC(aDC),
39447:         mShaper(aShaper),
 2252:         mItemString(aString), mItemLength(aLength), 
 2252:         mAlternativeString(nsnull), mScriptItem(aItem),
39447:         mScript(aItem->a.eScript),
 7625:         mNumGlyphs(0), mMaxGlyphs(ESTIMATE_MAX_GLYPHS(aLength)),
42989:         mFontSelected(PR_FALSE), mIVS(aIVS)
    1:     {
 7625:         NS_ASSERTION(mMaxGlyphs < 65535, "UniscribeItem is too big, ScriptShape() will fail!");
    1:     }
    1: 
    1:     ~UniscribeItem() {
    1:         free(mAlternativeString);
    1:     }
    1: 
39447:     PRBool AllocateBuffers() {
39447:         return (mGlyphs.SetLength(mMaxGlyphs) &&
39447:                 mClusters.SetLength(mItemLength + 1) &&
39447:                 mAttr.SetLength(mMaxGlyphs));
39447:     }
39447: 
    1:     /* possible return values:
 1959:      * S_OK - things succeeded
 1959:      * GDI_ERROR - things failed to shape.  Might want to try again after calling DisableShaping()
    1:      */
12992: 
39447:     HRESULT Shape() {
    1:         HRESULT rv;
    1:         HDC shapeDC = nsnull;
    1: 
39447:         const PRUnichar *str = mAlternativeString ? mAlternativeString : mItemString;
 1959: 
 6299:         mScriptItem->a.fLogicalOrder = PR_TRUE; 
 5308:         SCRIPT_ANALYSIS sa = mScriptItem->a;
 5308: 
    1:         while (PR_TRUE) {
  282: 
39447:             rv = ScriptShape(shapeDC, mShaper->ScriptCache(),
39447:                              str, mItemLength,
 5308:                              mMaxGlyphs, &sa,
 6076:                              mGlyphs.Elements(), mClusters.Elements(),
 6076:                              mAttr.Elements(), &mNumGlyphs);
    1: 
    1:             if (rv == E_OUTOFMEMORY) {
16654:                 mMaxGlyphs *= 2;
39447:                 if (!mGlyphs.SetLength(mMaxGlyphs) ||
39447:                     !mAttr.SetLength(mMaxGlyphs)) {
39447:                     return E_OUTOFMEMORY;
39447:                 }
    1:                 continue;
    1:             }
    1: 
22991:             // Uniscribe can't do shaping with some fonts, so it sets the 
22991:             // fNoGlyphIndex flag in the SCRIPT_ANALYSIS structure to indicate
22991:             // this.  This occurs with CFF fonts loaded with 
22991:             // AddFontMemResourceEx but it's not clear what the other cases
39447:             // are. We return an error so our caller can try fallback shaping.
22991:             // see http://msdn.microsoft.com/en-us/library/ms776520(VS.85).aspx
22991: 
22991:             if (sa.fNoGlyphIndex) {
39447:                 return GDI_ERROR;
22991:             }
22991: 
    1:             if (rv == E_PENDING) {
 4363:                 if (shapeDC == mDC) {
 4363:                     // we already tried this once, something failed, give up
14918:                     return E_PENDING;
 4363:                 }
 4363: 
    1:                 SelectFont();
    1: 
    1:                 shapeDC = mDC;
    1:                 continue;
    1:             }
12992: 
36949:             // http://msdn.microsoft.com/en-us/library/dd368564(VS.85).aspx:
36949:             // Uniscribe will return this if "the font corresponding to the
36949:             // DC does not support the script required by the run...".
36949:             // In this case, we'll set the script code to SCRIPT_UNDEFINED
36949:             // and try again, so that we'll at least get glyphs even though
36949:             // they won't necessarily have proper shaping.
36949:             // (We probably shouldn't have selected this font at all,
36949:             // but it's too late to fix that here.)
36949:             if (rv == USP_E_SCRIPT_NOT_IN_FONT) {
36949:                 sa.eScript = SCRIPT_UNDEFINED;
36949:                 NS_WARNING("Uniscribe says font does not support script needed");
36949:                 continue;
36949:             }
36949: 
42989:             // Prior to Windows 7, Uniscribe didn't support Ideographic Variation
42989:             // Selectors. Replace the UVS glyph manually.
42989:             if (mIVS) {
42989:                 PRUint32 lastChar = str[mItemLength - 1];
42989:                 if (NS_IS_LOW_SURROGATE(lastChar)
42989:                     && NS_IS_HIGH_SURROGATE(str[mItemLength - 2])) {
42989:                     lastChar = SURROGATE_TO_UCS4(str[mItemLength - 2], lastChar);
42989:                 }
42989:                 PRUint16 glyphId = mShaper->GetFont()->GetUVSGlyph(lastChar, mIVS);
42989:                 if (glyphId) {
42989:                     mGlyphs[mNumGlyphs - 1] = glyphId;
42989:                 }
42989:             }
42989: 
    1:             return rv;
    1:         }
    1:     }
    1: 
    1:     PRBool ShapingEnabled() {
    1:         return (mScriptItem->a.eScript != SCRIPT_UNDEFINED);
    1:     }
    1:     void DisableShaping() {
    1:         mScriptItem->a.eScript = SCRIPT_UNDEFINED;
    1:         // Note: If we disable the shaping by using SCRIPT_UNDEFINED and
    1:         // the string has the surrogate pair, ScriptShape API is
    1:         // *sometimes* crashed. Therefore, we should replace the surrogate
    1:         // pair to U+FFFD. See bug 341500.
    1:         GenerateAlternativeString();
    1:     }
 2252:     void EnableShaping() {
 2252:         mScriptItem->a.eScript = mScript;
 2252:         if (mAlternativeString) {
 2252:             free(mAlternativeString);
 2252:             mAlternativeString = nsnull;
 1959:         }
  282:     }
  282: 
  282:     PRBool IsGlyphMissing(SCRIPT_FONTPROPERTIES *aSFP, PRUint32 aGlyphIndex) {
39447:         return (mGlyphs[aGlyphIndex] == aSFP->wgDefault);
    1:     }
    1: 
11748: 
39447:     HRESULT Place() {
    1:         HRESULT rv;
    1:         HDC placeDC = nsnull;
    1: 
39447:         if (!mOffsets.SetLength(mNumGlyphs) ||
39447:             !mAdvances.SetLength(mNumGlyphs)) {
39447:             return E_OUTOFMEMORY;
39447:         }
39447: 
36949:         SCRIPT_ANALYSIS sa = mScriptItem->a;
36949: 
    1:         while (PR_TRUE) {
39447:             rv = ScriptPlace(placeDC, mShaper->ScriptCache(),
 6076:                              mGlyphs.Elements(), mNumGlyphs,
36949:                              mAttr.Elements(), &sa,
 6076:                              mAdvances.Elements(), mOffsets.Elements(), NULL);
    1: 
    1:             if (rv == E_PENDING) {
    1:                 SelectFont();
    1:                 placeDC = mDC;
    1:                 continue;
    1:             }
    1: 
36949:             if (rv == USP_E_SCRIPT_NOT_IN_FONT) {
36949:                 sa.eScript = SCRIPT_UNDEFINED;
36949:                 continue;
36949:             }
36949: 
    1:             break;
    1:         }
    1: 
    1:         return rv;
    1:     }
    1: 
    1:     void ScriptFontProperties(SCRIPT_FONTPROPERTIES *sfp) {
    1:         HRESULT rv;
    1: 
    1:         memset(sfp, 0, sizeof(SCRIPT_FONTPROPERTIES));
    1:         sfp->cBytes = sizeof(SCRIPT_FONTPROPERTIES);
39447:         rv = ScriptGetFontProperties(NULL, mShaper->ScriptCache(),
    1:                                      sfp);
    1:         if (rv == E_PENDING) {
    1:             SelectFont();
39447:             rv = ScriptGetFontProperties(mDC, mShaper->ScriptCache(),
    1:                                          sfp);
    1:         }
    1:     }
    1: 
39447:     void SaveGlyphs(gfxTextRun *aRun, PRUint32 aRunStart) {
39447:         PRUint32 offsetInRun = aRunStart + mScriptItem->iCharPos;
  132: 
    1:         // XXX We should store this in the item and only fetch it once
    1:         SCRIPT_FONTPROPERTIES sfp;
    1:         ScriptFontProperties(&sfp);
    1: 
    1:         PRUint32 offset = 0;
    1:         nsAutoTArray<gfxTextRun::DetailedGlyph,1> detailedGlyphs;
    1:         gfxTextRun::CompressedGlyph g;
    1:         const PRUint32 appUnitsPerDevUnit = aRun->GetAppUnitsPerDevUnit();
39447:         while (offset < mItemLength) {
    1:             PRUint32 runOffset = offsetInRun + offset;
    1:             if (offset > 0 && mClusters[offset] == mClusters[offset - 1]) {
 7715:                 g.SetComplex(aRun->IsClusterStart(runOffset), PR_FALSE, 0);
 7715:                 aRun->SetGlyphs(runOffset, g, nsnull);
    1:             } else {
    1:                 // Count glyphs for this character
    1:                 PRUint32 k = mClusters[offset];
    1:                 PRUint32 glyphCount = mNumGlyphs - k;
    1:                 PRUint32 nextClusterOffset;
  282:                 PRBool missing = IsGlyphMissing(&sfp, k);
39447:                 for (nextClusterOffset = offset + 1; nextClusterOffset < mItemLength; ++nextClusterOffset) {
    1:                     if (mClusters[nextClusterOffset] > k) {
    1:                         glyphCount = mClusters[nextClusterOffset] - k;
    1:                         break;
    1:                     }
    1:                 }
    1:                 PRUint32 j;
    1:                 for (j = 1; j < glyphCount; ++j) {
  282:                     if (IsGlyphMissing(&sfp, k + j)) {
    1:                         missing = PR_TRUE;
    1:                     }
    1:                 }
    1:                 PRInt32 advance = mAdvances[k]*appUnitsPerDevUnit;
    1:                 WORD glyph = mGlyphs[k];
39447:                 NS_ASSERTION(!gfxFontGroup::IsInvalidChar(mItemString[offset]),
 3119:                              "invalid character detected");
 3119:                 if (missing) {
39447:                     if (NS_IS_HIGH_SURROGATE(mItemString[offset]) &&
39447:                         offset + 1 < mItemLength &&
39447:                         NS_IS_LOW_SURROGATE(mItemString[offset + 1])) {
 6135:                         aRun->SetMissingGlyph(runOffset,
39447:                                               SURROGATE_TO_UCS4(mItemString[offset],
39447:                                                                 mItemString[offset + 1]));
 6135:                     } else {
39447:                         aRun->SetMissingGlyph(runOffset, mItemString[offset]);
 6135:                     }
    1:                 } else if (glyphCount == 1 && advance >= 0 &&
    1:                     mOffsets[k].dv == 0 && mOffsets[k].du == 0 &&
    1:                     gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
    1:                     gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyph)) {
 7715:                     aRun->SetSimpleGlyph(runOffset, g.SetSimpleGlyph(advance, glyph));
    1:                 } else {
    1:                     if (detailedGlyphs.Length() < glyphCount) {
    1:                         if (!detailedGlyphs.AppendElements(glyphCount - detailedGlyphs.Length()))
    1:                             return;
    1:                     }
    1:                     PRUint32 i;
    1:                     for (i = 0; i < glyphCount; ++i) {
    1:                         gfxTextRun::DetailedGlyph *details = &detailedGlyphs[i];
    1:                         details->mGlyphID = mGlyphs[k + i];
    1:                         details->mAdvance = mAdvances[k + i]*appUnitsPerDevUnit;
  780:                         details->mXOffset = float(mOffsets[k + i].du)*appUnitsPerDevUnit*aRun->GetDirection();
24333:                         details->mYOffset = - float(mOffsets[k + i].dv)*appUnitsPerDevUnit;
    1:                     }
 7715:                     aRun->SetGlyphs(runOffset,
 7715:                         g.SetComplex(PR_TRUE, PR_TRUE, glyphCount), detailedGlyphs.Elements());
    1:                 }
    1:             }
    1:             ++offset;
    1:         }
    1:     }
    1: 
    1:     void SelectFont() {
    1:         if (mFontSelected)
    1:             return;
    1: 
    1:         cairo_t *cr = mContext->GetCairo();
    1: 
39447:         cairo_set_font_face(cr, mShaper->GetFont()->CairoFontFace());
39447:         cairo_set_font_size(cr, mShaper->GetFont()->GetAdjustedSize());
39447:         cairo_scaled_font_t *scaledFont = mShaper->GetFont()->CairoScaledFont();
 4304:         cairo_win32_scaled_font_select_font(scaledFont, mDC);
    1: 
    1:         mFontSelected = PR_TRUE;
    1:     }
    1: 
    1: private:
    1: 
    1:     void GenerateAlternativeString() {
    1:         if (mAlternativeString)
    1:             free(mAlternativeString);
39447:         mAlternativeString = (PRUnichar *)malloc(mItemLength * sizeof(PRUnichar));
 7030:         if (!mAlternativeString)
 7030:             return;
39447:         memcpy((void *)mAlternativeString, (const void *)mItemString,
39447:                mItemLength * sizeof(PRUnichar));
39447:         for (PRUint32 i = 0; i < mItemLength; i++) {
39447:             if (NS_IS_HIGH_SURROGATE(mItemString[i]) || NS_IS_LOW_SURROGATE(mItemString[i]))
    1:                 mAlternativeString[i] = PRUnichar(0xFFFD);
    1:         }
    1:     }
 1959: 
    1: private:
    1:     nsRefPtr<gfxContext> mContext;
    1:     HDC mDC;
39447:     gfxUniscribeShaper *mShaper;
    1: 
    1:     SCRIPT_ITEM *mScriptItem;
    1:     WORD mScript;
    1: 
16418: public:
 2252:     // these point to the full string/length of the item
 2252:     const PRUnichar *mItemString;
 2252:     const PRUint32 mItemLength;
    1: 
16418: private:
    1:     PRUnichar *mAlternativeString;
    1: 
 5393: #define AVERAGE_ITEM_LENGTH 40
 5393: 
 7625:     nsAutoTArray<WORD, PRUint32(ESTIMATE_MAX_GLYPHS(AVERAGE_ITEM_LENGTH))> mGlyphs;
 6076:     nsAutoTArray<WORD, AVERAGE_ITEM_LENGTH + 1> mClusters;
 7625:     nsAutoTArray<SCRIPT_VISATTR, PRUint32(ESTIMATE_MAX_GLYPHS(AVERAGE_ITEM_LENGTH))> mAttr;
 5393:  
 6076:     nsAutoTArray<GOFFSET, 2 * AVERAGE_ITEM_LENGTH> mOffsets;
 6076:     nsAutoTArray<int, 2 * AVERAGE_ITEM_LENGTH> mAdvances;
 5393: 
 5393: #undef AVERAGE_ITEM_LENGTH
    1: 
    1:     int mMaxGlyphs;
    1:     int mNumGlyphs;
42989:     PRUint32 mIVS;
    1: 
    1:     PRPackedBool mFontSelected;
    1: };
    1: 
49394: #define MAX_ITEM_LENGTH 16384
 7625: 
    1: class Uniscribe
    1: {
    1: public:
49394:     Uniscribe(const PRUnichar *aString,
49394:               PRUint32 aLength,
49394:               gfxTextRun *aTextRun):
49394:         mString(aString), mLength(aLength), mTextRun(aTextRun)
39447:     {
    1:     }
  282:     ~Uniscribe() {
  282:     }
    1: 
    1:     void Init() {
    1:         memset(&mControl, 0, sizeof(SCRIPT_CONTROL));
    1:         memset(&mState, 0, sizeof(SCRIPT_STATE));
    1:         // Lock the direction. Don't allow the itemizer to change directions
    1:         // based on character type.
49394:         mState.uBidiLevel = mTextRun->IsRightToLeft() ? 1 : 0;
    1:         mState.fOverrideDirection = PR_TRUE;
    1:     }
    1: 
 7625: private:
 7625: 
49394: // We try to avoid calling Uniscribe with text runs that may generate
49394: // more than this many glyphs, because of the possibility of arithmetic
49394: // overflow of 16-bit variables. If long runs need to be split because
49394: // of this, we'll look for whitespace to break on so that shaping needed
49394: // (e.g. for complex scripts) should be unaffected.
49394: #define MAX_UNISCRIBE_GLYPHS 32767
49394: 
 7625:     // Append mItems[aIndex] to aDest, adding extra items to aDest to ensure
 7625:     // that no item is too long for ScriptShape() to handle. See bug 366643.
 7625:     nsresult CopyItemSplitOversize(int aIndex, nsTArray<SCRIPT_ITEM> &aDest) {
 7625:         aDest.AppendElement(mItems[aIndex]);
49394:         const int itemLength =
49394:             mItems[aIndex+1].iCharPos - mItems[aIndex].iCharPos;
49394:         if (ESTIMATE_MAX_GLYPHS(itemLength) > MAX_UNISCRIBE_GLYPHS) {
49394:             // This item's length would cause ScriptShape() to fail.
49394:             // We need to add extra items here so that no item's length
49394:             // could cause the fail.
 7625: 
49394:             // We break on whitespace or cluster boundaries if possible.
 7625:             const int nextItemStart = mItems[aIndex+1].iCharPos;
 7625:             int start = FindNextItemStart(mItems[aIndex].iCharPos,
49394:                                           nextItemStart);
 7625: 
 7625:             while (start < nextItemStart) {
 7625:                 SCRIPT_ITEM item = mItems[aIndex];
 7625:                 item.iCharPos = start;
 7625:                 aDest.AppendElement(item);
49394:                 start = FindNextItemStart(start, nextItemStart);
 7625:             }
 7625:         } 
 7625:         return NS_OK;
 7625:     }
 7625: 
49394:     PRUint32 FindNextItemStart(int aOffset, int aLimit) {
49394:         if (aOffset + MAX_ITEM_LENGTH >= aLimit) {
49394:             // The item starting at aOffset can't be longer than max length,
49394:             // so starting the next item at aLimit won't cause ScriptShape()
49394:             // to fail.
49394:             return aLimit;
49394:         }
49394:         // Try to start the next item before or after a space, since spaces
49394:         // don't kern or ligate.
49394:         PRInt32 off;
49394:         int boundary = -1;
49394:         for (off = MAX_ITEM_LENGTH; off > 1; --off) {
49394:             if (mTextRun->IsClusterStart(off)) {
49394:                 if (off > boundary) {
49394:                     boundary = off;
49394:                 }
49394:                 if (mString[aOffset+off] == ' ' ||
49394:                     mString[aOffset+off - 1] == ' ') {
49394:                     return aOffset+off;
49394:                 }
49394:             }
49394:         }
49394: 
49394:         // Try to start the next item at last cluster boundary in the range.
49394:         if (boundary > 0) {
49394:             return aOffset+boundary;
49394:         }
49394: 
49394:         // No nice cluster boundaries inside MAX_ITEM_LENGTH characters, break
49394:         // on the size limit. It won't be visually pleasing, but at least it
49394:         // won't cause ScriptShape() to fail.
49394:         return aOffset + MAX_ITEM_LENGTH;
49394:     }
49394: 
 7625: public:
 7625: 
    1:     int Itemize() {
    1:         HRESULT rv;
    1: 
    1:         int maxItems = 5;
    1: 
    1:         Init();
 7625: 
  808:         // Allocate space for one more item than expected, to handle a rare
  808:         // overflow in ScriptItemize (pre XP SP2). See bug 366643.
 7625:         if (!mItems.SetLength(maxItems + 1)) {
 7625:             return 0;
 7625:         }
    1:         while ((rv = ScriptItemize(mString, mLength, maxItems, &mControl, &mState,
 7625:                                    mItems.Elements(), &mNumItems)) == E_OUTOFMEMORY) {
    1:             maxItems *= 2;
 7625:             if (!mItems.SetLength(maxItems + 1)) {
 7625:                 return 0;
 7625:             }
    1:             Init();
    1:         }
    1: 
 7625:         if (ESTIMATE_MAX_GLYPHS(mLength) > 65535) {
 7625:             // Any item of length > 43680 will cause ScriptShape() to fail, as its
 7625:             // mMaxGlyphs value will be greater than 65535 (43680*1.5+16>65535). So we
 7625:             // need to break up items which are longer than that upon cluster boundaries.
 7625:             // See bug 394751 for details.
 7625:             nsTArray<SCRIPT_ITEM> items;
 7625:             for (int i=0; i<mNumItems; i++) {
 7625:                 nsresult nrs = CopyItemSplitOversize(i, items);
 7625:                 NS_ASSERTION(NS_SUCCEEDED(nrs), "CopyItemSplitOversize() failed");
 7625:             }
 7625:             items.AppendElement(mItems[mNumItems]); // copy terminator.
 7625: 
 7625:             mItems = items;
 7625:             mNumItems = items.Length() - 1; // Don't count the terminator.
 7625:         }
    1:         return mNumItems;
    1:     }
    1: 
    1:     PRUint32 ItemsLength() {
    1:         return mNumItems;
    1:     }
    1: 
39447:     SCRIPT_ITEM *ScriptItem(PRUint32 i) {
39447:         NS_ASSERTION(i <= (PRUint32)mNumItems, "Trying to get out of bounds item");
39447:         return &mItems[i];
    1:     }
    1: 
    1: private:
    1:     const PRUnichar *mString;
    1:     const PRUint32 mLength;
49394:     gfxTextRun *mTextRun;
    1: 
    1:     SCRIPT_CONTROL mControl;
    1:     SCRIPT_STATE   mState;
 7625:     nsTArray<SCRIPT_ITEM> mItems;
    1:     int mNumItems;
    1: };
    1: 
16418: 
39447: PRBool
39447: gfxUniscribeShaper::InitTextRun(gfxContext *aContext,
39447:                                 gfxTextRun *aTextRun,
39447:                                 const PRUnichar *aString,
39447:                                 PRUint32 aRunStart,
43525:                                 PRUint32 aRunLength,
43525:                                 PRInt32 aRunScript)
    1: {
 4363:     DCFromContext aDC(aContext);
    1:  
39447:     PRBool result = PR_TRUE;
    1:     HRESULT rv;
    1: 
39447:     gfxGDIFont *font = static_cast<gfxGDIFont*>(mFont);
39447:     AutoSelectFont fs(aDC, font->GetHFONT());
39447: 
49394:     Uniscribe us(aString + aRunStart, aRunLength, aTextRun);
    1: 
    1:     /* itemize the string */
    1:     int numItems = us.Itemize();
    1: 
39447:     SaveDC(aDC);
42989:     PRUint32 ivs = 0;
    1:     for (int i = 0; i < numItems; ++i) {
42989:         int iCharPos = us.ScriptItem(i)->iCharPos;
42989:         int iCharPosNext = us.ScriptItem(i+1)->iCharPos;
42989: 
42989:         if (ivs) {
42989:             iCharPos += 2;
42989:             if (iCharPos >= iCharPosNext) {
42989:                 ivs = 0;
42989:                 continue;
42989:             }
42989:         }
42989: 
42989:         if (i+1 < numItems && aRunStart + iCharPosNext <= aRunLength - 2
42989:             && aString[aRunStart + iCharPosNext] == H_SURROGATE(kUnicodeVS17)
42989:             && PRUint32(aString[aRunStart + iCharPosNext + 1]) - L_SURROGATE(kUnicodeVS17)
42989:             <= L_SURROGATE(kUnicodeVS256) - L_SURROGATE(kUnicodeVS17)) {
42989: 
42989:             ivs = SURROGATE_TO_UCS4(aString[aRunStart + iCharPosNext],
42989:                                     aString[aRunStart + iCharPosNext + 1]);
42989:         } else {
42989:             ivs = 0;
42989:         }
42989: 
39447:         UniscribeItem item(aContext, aDC, this,
42989:                            aString + aRunStart + iCharPos,
42989:                            iCharPosNext - iCharPos,
42989:                            us.ScriptItem(i), ivs);
39447:         if (!item.AllocateBuffers()) {
39447:             result = PR_FALSE;
39447:             break;
16418:         }
16418: 
39447:         if (!item.ShapingEnabled()) {
39447:             item.EnableShaping();
39447:         }
16418: 
39447:         rv = item.Shape();
 7625:         if (FAILED(rv)) {
 2252:             PR_LOG(gFontLog, PR_LOG_DEBUG, ("shaping failed"));
 1959:             // we know we have the glyphs to display this font already
 1959:             // so Uniscribe just doesn't know how to shape the script.
 1959:             // Render the glyphs without shaping.
39447:             item.DisableShaping();
39447:             rv = item.Shape();
 1959:         }
39447: #ifdef DEBUG
39447:         if (FAILED(rv)) {
39447:             NS_WARNING("Uniscribe failed to shape with font");
39447:         }
39447: #endif
    1: 
14918:         if (SUCCEEDED(rv)) {
39447:             rv = item.Place();
39447: #ifdef DEBUG
30595:             if (FAILED(rv)) {
30595:                 // crap fonts may fail when placing (e.g. funky free fonts)
39447:                 NS_WARNING("Uniscribe failed to place with font");
30595:             }
39447: #endif
14918:         }
    1: 
13439:         if (FAILED(rv)) {
39447:             aTextRun->ResetGlyphRuns();
39447:             // Uniscribe doesn't like this font for some reason.
39447:             // Returning FALSE will make the gfxGDIFont discard this
39447:             // shaper and replace it with a "dumb" GDI one.
39447:             result = PR_FALSE;
13439:             break;
13439:         }
13439: 
39447:         item.SaveGlyphs(aTextRun, aRunStart);
 2252:     }
 1959: 
13439:     RestoreDC(aDC, -1);
    1: 
39447:     return result;
    1: }
