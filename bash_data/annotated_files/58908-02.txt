    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim: set ts=2 sw=2 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Johnny Stenback <jst@netscape.com>
    1:  *   Christopher A. Aillon <christopher@aillon.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* A namespace class for static layout utilities. */
    1: 
39541: #include "jscntxt.h"
39541: 
    1: #include "nsJSUtils.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsAString.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIPrefService.h"
37975: #include "nsIPrefBranch2.h"
    1: #include "nsIPrefLocalizedString.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIDOMScriptObjectFactory.h"
    1: #include "nsDOMCID.h"
    1: #include "nsContentUtils.h"
41486: #include "nsIContentUtils.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIContent.h"
41930: #include "mozilla/dom/Element.h"
    1: #include "nsIDocument.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOM3Node.h"
    1: #include "nsIIOService.h"
    1: #include "nsNetCID.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsDOMError.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsParserCIID.h"
    1: #include "nsIParser.h"
    1: #include "nsIFragmentContentSink.h"
    1: #include "nsIContentSink.h"
11423: #include "nsIHTMLContentSink.h"
11423: #include "nsIXMLContentSink.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsIParserService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIAttribute.h"
    1: #include "nsContentList.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLCollection.h"
    1: #include "nsIDOMHTMLFormElement.h"
18985: #include "nsIDOMNSHTMLElement.h"
    1: #include "nsIForm.h"
    1: #include "nsIFormControl.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "imgIDecoderObserver.h"
    1: #include "imgIRequest.h"
    1: #include "imgIContainer.h"
    1: #include "imgILoader.h"
49060: #include "mozilla/IHistory.h"
38463: #include "nsDocShellCID.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsILoadGroup.h"
38651: #include "nsIObserver.h"
38651: #include "nsIObserverService.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsIXBLService.h"
    1: #include "nsCRT.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIDOMEventTarget.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDOMDocumentEvent.h"
    1: #ifdef MOZ_XTF
    1: #include "nsIXTFService.h"
    1: static NS_DEFINE_CID(kXTFServiceCID, NS_XTFSERVICE_CID);
    1: #endif
    1: #include "nsIMIMEService.h"
    1: #include "nsLWBrkCIID.h"
    1: #include "nsILineBreaker.h"
    1: #include "nsIWordBreaker.h"
    1: #include "jsdbgapi.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsIDOMDocumentXBL.h"
    1: #include "nsBindingManager.h"
    1: #include "nsIURI.h"
    1: #include "nsIURL.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsXBLPrototypeBinding.h"
    1: #include "nsEscape.h"
    1: #include "nsICharsetConverterManager.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsAttrName.h"
    1: #include "nsIDOMUserDataHandler.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsTPtrArray.h"
  265: #include "nsGUIEvent.h"
  265: #include "nsMutationEvent.h"
  998: #include "nsIMEStateManager.h"
 2324: #include "nsContentErrors.h"
 3049: #include "nsUnicharUtilCIID.h"
 7832: #include "nsCompressedCharMap.h"
 9377: #include "nsINativeKeyBindings.h"
 9377: #include "nsIDOMNSUIEvent.h"
 9377: #include "nsIDOMNSEvent.h"
 9377: #include "nsIPrivateDOMEvent.h"
11414: #include "nsXULPopupManager.h"
10340: #include "nsIPermissionManager.h"
51393: #include "nsIContentPrefService.h"
12313: #include "nsIScriptObjectPrincipal.h"
13098: #include "nsIRunnable.h"
13098: #include "nsDOMJSUtils.h"
15474: #include "nsGenericHTMLElement.h"
15474: #include "nsAttrValue.h"
15515: #include "nsReferencedElement.h"
15634: #include "nsIUGenCategory.h"
18445: #include "nsIDragService.h"
18942: #include "nsIChannelEventSink.h"
48889: #include "nsIAsyncVerifyRedirectCallback.h"
18942: #include "nsIInterfaceRequestor.h"
20651: #include "nsIOfflineCacheUpdate.h"
20651: #include "nsCPrefetchService.h"
21636: #include "nsIChromeRegistry.h"
22874: #include "nsIMIMEHeaderParam.h"
29844: #include "nsIDOMXULCommandEvent.h"
29844: #include "nsIDOMAbstractView.h"
29545: #include "nsIDOMDragEvent.h"
29545: #include "nsDOMDataTransfer.h"
29805: #include "nsHtml5Module.h"
30988: #include "nsPresContext.h"
31981: #include "nsLayoutStatics.h"
42402: #include "nsLayoutUtils.h"
42402: #include "nsFrameManager.h"
42402: #include "BasicLayers.h"
43129: #include "nsFocusManager.h"
43129: #include "nsTextEditorState.h"
43473: #include "nsIPluginHost.h"
43473: #include "nsICategoryManager.h"
57561: #include "nsAHtml5FragmentParser.h"
    1: 
    1: #ifdef IBMBIDI
    1: #include "nsIBidiKeyboard.h"
    1: #endif
    1: #include "nsCycleCollectionParticipant.h"
    1: 
    1: // for ReportToConsole
    1: #include "nsIStringBundle.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIConsoleService.h"
    1: 
14228: #include "mozAutoDocUpdate.h"
30065: #include "imgICache.h"
29802: #include "jsinterp.h"
39541: #include "jsarray.h"
39541: #include "jsdate.h"
39541: #include "jsregexp.h"
40555: #include "jstypedarray.h"
41899: #include "xpcprivate.h"
41899: #include "nsScriptSecurityManager.h"
42509: #include "nsIChannelPolicy.h"
42509: #include "nsChannelPolicy.h"
42509: #include "nsIContentSecurityPolicy.h"
43473: #include "nsContentDLF.h"
51229: #ifdef MOZ_MEDIA
46997: #include "nsHTMLMediaElement.h"
51229: #endif
14228: 
41634: using namespace mozilla::dom;
47767: using namespace mozilla::layers;
41634: 
    1: const char kLoadAsData[] = "loadAsData";
    1: 
    1: static const char kJSStackContractID[] = "@mozilla.org/js/xpc/ContextStack;1";
    1: static NS_DEFINE_CID(kParserServiceCID, NS_PARSERSERVICE_CID);
    1: static NS_DEFINE_CID(kCParserCID, NS_PARSER_CID);
    1: 
    1: nsIDOMScriptObjectFactory *nsContentUtils::sDOMScriptObjectFactory = nsnull;
    1: nsIXPConnect *nsContentUtils::sXPConnect;
    1: nsIScriptSecurityManager *nsContentUtils::sSecurityManager;
    1: nsIThreadJSContextStack *nsContentUtils::sThreadJSContextStack;
    1: nsIParserService *nsContentUtils::sParserService = nsnull;
    1: nsINameSpaceManager *nsContentUtils::sNameSpaceManager;
    1: nsIIOService *nsContentUtils::sIOService;
    1: #ifdef MOZ_XTF
    1: nsIXTFService *nsContentUtils::sXTFService = nsnull;
    1: #endif
37975: nsIPrefBranch2 *nsContentUtils::sPrefBranch = nsnull;
    1: imgILoader *nsContentUtils::sImgLoader;
30065: imgICache *nsContentUtils::sImgCache;
49060: mozilla::IHistory *nsContentUtils::sHistory;
    1: nsIConsoleService *nsContentUtils::sConsoleService;
44144: nsDataHashtable<nsISupportsHashKey, EventNameMapping>* nsContentUtils::sAtomEventTable = nsnull;
44144: nsDataHashtable<nsStringHashKey, EventNameMapping>* nsContentUtils::sStringEventTable = nsnull;
44144: nsCOMArray<nsIAtom>* nsContentUtils::sUserDefinedEvents = nsnull;
    1: nsIStringBundleService *nsContentUtils::sStringBundleService;
    1: nsIStringBundle *nsContentUtils::sStringBundles[PropertiesFile_COUNT];
    1: nsIContentPolicy *nsContentUtils::sContentPolicyService;
    1: PRBool nsContentUtils::sTriedToGetContentPolicy = PR_FALSE;
    1: nsILineBreaker *nsContentUtils::sLineBreaker;
    1: nsIWordBreaker *nsContentUtils::sWordBreaker;
15634: nsIUGenCategory *nsContentUtils::sGenCat;
26413: nsTArray<nsISupports**> *nsContentUtils::sPtrsToPtrsToRelease;
    1: nsIScriptRuntime *nsContentUtils::sScriptRuntimes[NS_STID_ARRAY_UBOUND];
    1: PRInt32 nsContentUtils::sScriptRootCount[NS_STID_ARRAY_UBOUND];
 7230: PRUint32 nsContentUtils::sJSGCThingRootCount;
    1: #ifdef IBMBIDI
    1: nsIBidiKeyboard *nsContentUtils::sBidiKeyboard = nsnull;
    1: #endif
13098: PRUint32 nsContentUtils::sScriptBlockerCount = 0;
14319: PRUint32 nsContentUtils::sRemovableScriptBlockerCount = 0;
13098: nsCOMArray<nsIRunnable>* nsContentUtils::sBlockedScriptRunners = nsnull;
13098: PRUint32 nsContentUtils::sRunnersCountAtFirstBlocker = 0;
37087: PRUint32 nsContentUtils::sScriptBlockerCountWhereRunnersPrevented = 0;
18942: nsIInterfaceRequestor* nsContentUtils::sSameOriginChecker = nsnull;
    1: 
 7230: nsIJSRuntimeService *nsAutoGCRoot::sJSRuntimeService;
 7230: JSRuntime *nsAutoGCRoot::sJSScriptRuntime;
    1: 
41239: PRBool nsContentUtils::sIsHandlingKeyBoardEvent = PR_FALSE;
58024: PRBool nsContentUtils::sAllowXULXBL_for_file = PR_FALSE;
41239: 
    1: PRBool nsContentUtils::sInitialized = PR_FALSE;
    1: 
48723: nsRefPtrHashtable<nsPrefObserverHashKey, nsPrefOldCallback>
48723:   *nsContentUtils::sPrefCallbackTable = nsnull;
37975: 
    1: static PLDHashTable sEventListenerManagersHash;
    1: 
    1: class EventListenerManagerMapEntry : public PLDHashEntryHdr
    1: {
    1: public:
    1:   EventListenerManagerMapEntry(const void *aKey)
    1:     : mKey(aKey)
    1:   {
    1:   }
    1: 
    1:   ~EventListenerManagerMapEntry()
    1:   {
    1:     NS_ASSERTION(!mListenerManager, "caller must release and disconnect ELM");
    1:   }
    1: 
    1: private:
    1:   const void *mKey; // must be first, to look like PLDHashEntryStub
    1: 
    1: public:
    1:   nsCOMPtr<nsIEventListenerManager> mListenerManager;
    1: };
    1: 
20261: static PRBool
    1: EventListenerManagerHashInitEntry(PLDHashTable *table, PLDHashEntryHdr *entry,
    1:                                   const void *key)
    1: {
    1:   // Initialize the entry with placement new
    1:   new (entry) EventListenerManagerMapEntry(key);
    1:   return PR_TRUE;
    1: }
    1: 
20261: static void
    1: EventListenerManagerHashClearEntry(PLDHashTable *table, PLDHashEntryHdr *entry)
    1: {
    1:   EventListenerManagerMapEntry *lm =
 3233:     static_cast<EventListenerManagerMapEntry *>(entry);
    1: 
    1:   // Let the EventListenerManagerMapEntry clean itself up...
    1:   lm->~EventListenerManagerMapEntry();
    1: }
    1: 
18942: class nsSameOriginChecker : public nsIChannelEventSink,
18942:                             public nsIInterfaceRequestor
18942: {
18942:   NS_DECL_ISUPPORTS
18942:   NS_DECL_NSICHANNELEVENTSINK
18942:   NS_DECL_NSIINTERFACEREQUESTOR
18942: };
18942: 
48723: class nsPrefObserverHashKey : public PLDHashEntryHdr {
48723: public:
48723:   typedef nsPrefObserverHashKey* KeyType;
48723:   typedef const nsPrefObserverHashKey* KeyTypePointer;
48723: 
48723:   static const nsPrefObserverHashKey* KeyToPointer(nsPrefObserverHashKey *aKey)
48723:   {
48723:     return aKey;
48723:   }
48723: 
48723:   static PLDHashNumber HashKey(const nsPrefObserverHashKey *aKey)
48723:   {
48723:     PRUint32 strHash = nsCRT::HashCode(aKey->mPref.BeginReading(),
48723:                                        aKey->mPref.Length());
48723:     return PR_ROTATE_LEFT32(strHash, 4) ^
48723:            NS_PTR_TO_UINT32(aKey->mCallback);
48723:   }
48723: 
48723:   nsPrefObserverHashKey(const char *aPref, PrefChangedFunc aCallback) :
48723:     mPref(aPref), mCallback(aCallback) { }
48723: 
48723:   nsPrefObserverHashKey(const nsPrefObserverHashKey *aOther) :
48723:     mPref(aOther->mPref), mCallback(aOther->mCallback)
48723:   { }
48723: 
48723:   PRBool KeyEquals(const nsPrefObserverHashKey *aOther) const
48723:   {
48723:     return mCallback == aOther->mCallback &&
48723:            mPref.Equals(aOther->mPref);
48723:   }
48723: 
48723:   nsPrefObserverHashKey *GetKey() const
48723:   {
48723:     return const_cast<nsPrefObserverHashKey*>(this);
48723:   }
48723: 
48723:   enum { ALLOW_MEMMOVE = PR_TRUE };
48723: 
48723: public:
48723:   nsCString mPref;
48723:   PrefChangedFunc mCallback;
48723: };
48723: 
48421: // For nsContentUtils::RegisterPrefCallback/UnregisterPrefCallback
48723: class nsPrefOldCallback : public nsIObserver,
48723:                           public nsPrefObserverHashKey
48421: {
48419: public:
48421:   NS_DECL_ISUPPORTS
48421:   NS_DECL_NSIOBSERVER
48421: 
48421: public:
48723:   nsPrefOldCallback(const char *aPref, PrefChangedFunc aCallback)
48723:     : nsPrefObserverHashKey(aPref, aCallback) { }
48723: 
48723:   ~nsPrefOldCallback() {
48723:     nsIPrefBranch2 *prefBranch = nsContentUtils::GetPrefBranch();
48723:     if(prefBranch)
48723:       prefBranch->RemoveObserver(mPref.get(), this);
48723:   }
48723: 
48723:   void AppendClosure(void *aClosure) {
48723:     mClosures.AppendElement(aClosure);
48723:   }
48723: 
48723:   void RemoveClosure(void *aClosure) {
48723:     mClosures.RemoveElement(aClosure);
48723:   }
48723: 
48723:   PRBool HasNoClosures() {
48723:     return mClosures.Length() == 0;
48421:   }
48419: 
48419: public:
48723:   nsTArray<void *>  mClosures;
37975: };
37975: 
37975: NS_IMPL_ISUPPORTS1(nsPrefOldCallback, nsIObserver)
37975: 
37975: NS_IMETHODIMP
37975: nsPrefOldCallback::Observe(nsISupports     *aSubject,
37975:                            const char      *aTopic,
37975:                            const PRUnichar *aData)
37975: {
37975:   NS_ASSERTION(!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID),
37975:                "invalid topic");
48723:   NS_LossyConvertUTF16toASCII data(aData);
48723:   for (PRUint32 i = 0; i < mClosures.Length(); i++) {
48723:     mCallback(data.get(), mClosures.ElementAt(i));
48723:   }
37975: 
37975:   return NS_OK;
37975: }
37975: 
41408: struct PrefCacheData {
41408:   void* cacheLocation;
41408:   union {
41408:     PRBool defaultValueBool;
41408:     PRInt32 defaultValueInt;
41408:   };
41408: };
41408: 
41408: nsTArray<nsAutoPtr<PrefCacheData> >* sPrefCacheData = nsnull;
41408: 
    1: // static
    1: nsresult
    1: nsContentUtils::Init()
    1: {
    1:   if (sInitialized) {
    1:     NS_WARNING("Init() called twice");
    1: 
    1:     return NS_OK;
    1:   }
    1: 
41408:   sPrefCacheData = new nsTArray<nsAutoPtr<PrefCacheData> >();
41408: 
    1:   // It's ok to not have a pref service.
    1:   CallGetService(NS_PREFSERVICE_CONTRACTID, &sPrefBranch);
    1: 
41899:   nsresult rv = NS_GetNameSpaceManager(&sNameSpaceManager);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
41899:   nsXPConnect* xpconnect = nsXPConnect::GetXPConnect();
41899:   NS_ENSURE_TRUE(xpconnect, NS_ERROR_FAILURE);
41899: 
41899:   sXPConnect = xpconnect;
41899:   sThreadJSContextStack = xpconnect;
41899: 
41899:   sSecurityManager = nsScriptSecurityManager::GetScriptSecurityManager();
41899:   if(!sSecurityManager)
41899:     return NS_ERROR_FAILURE;
41899:   NS_ADDREF(sSecurityManager);
    1: 
    1:   rv = CallGetService(NS_IOSERVICE_CONTRACTID, &sIOService);
    1:   if (NS_FAILED(rv)) {
    1:     // This makes life easier, but we can live without it.
    1: 
    1:     sIOService = nsnull;
    1:   }
    1: 
    1:   rv = CallGetService(NS_LBRK_CONTRACTID, &sLineBreaker);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   rv = CallGetService(NS_WBRK_CONTRACTID, &sWordBreaker);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
15634:   rv = CallGetService(NS_UNICHARCATEGORY_CONTRACTID, &sGenCat);
15634:   NS_ENSURE_SUCCESS(rv, rv);
15634: 
49060:   rv = CallGetService(NS_IHISTORY_CONTRACTID, &sHistory);
49060:   if (NS_FAILED(rv)) {
49060:     NS_RUNTIMEABORT("Cannot get the history service");
49060:     return rv;
49060:   }
49060: 
26413:   sPtrsToPtrsToRelease = new nsTArray<nsISupports**>();
    1:   if (!sPtrsToPtrsToRelease) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
  265:   if (!InitializeEventTable())
  265:     return NS_ERROR_FAILURE;
  265: 
    1:   if (!sEventListenerManagersHash.ops) {
    1:     static PLDHashTableOps hash_table_ops =
    1:     {
    1:       PL_DHashAllocTable,
    1:       PL_DHashFreeTable,
    1:       PL_DHashVoidPtrKeyStub,
    1:       PL_DHashMatchEntryStub,
    1:       PL_DHashMoveEntryStub,
    1:       EventListenerManagerHashClearEntry,
    1:       PL_DHashFinalizeStub,
    1:       EventListenerManagerHashInitEntry
    1:     };
    1: 
    1:     if (!PL_DHashTableInit(&sEventListenerManagersHash, &hash_table_ops,
    1:                            nsnull, sizeof(EventListenerManagerMapEntry), 16)) {
    1:       sEventListenerManagersHash.ops = nsnull;
    1: 
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
13098:   sBlockedScriptRunners = new nsCOMArray<nsIRunnable>;
13098:   NS_ENSURE_TRUE(sBlockedScriptRunners, NS_ERROR_OUT_OF_MEMORY);
13098: 
58024:   nsContentUtils::AddBoolPrefVarCache("dom.allow_XUL_XBL_for_file",
58024:                                       &sAllowXULXBL_for_file);
58024: 
    1:   sInitialized = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
47160: bool nsContentUtils::sImgLoaderInitialized;
47160: 
47160: void
47160: nsContentUtils::InitImgLoader()
47160: {
47160:   sImgLoaderInitialized = true;
47160: 
47160:   // Ignore failure and just don't load images
47160:   nsresult rv = CallGetService("@mozilla.org/image/loader;1", &sImgLoader);
47160:   if (NS_FAILED(rv)) {
47160:     // no image loading for us.  Oh, well.
47160:     sImgLoader = nsnull;
47160:     sImgCache = nsnull;
47160:   } else {
47160:     if (NS_FAILED(CallGetService("@mozilla.org/image/cache;1", &sImgCache )))
47160:       sImgCache = nsnull;
47160:   }
47160: }
47160: 
  265: PRBool
  265: nsContentUtils::InitializeEventTable() {
44144:   NS_ASSERTION(!sAtomEventTable, "EventTable already initialized!");
44144:   NS_ASSERTION(!sStringEventTable, "EventTable already initialized!");
44144: 
44144:   static const EventNameMapping eventArray[] = {
44144:     { nsGkAtoms::onmousedown,                   NS_MOUSE_BUTTON_DOWN, EventNameType_All, NS_MOUSE_EVENT },
44144:     { nsGkAtoms::onmouseup,                     NS_MOUSE_BUTTON_UP, EventNameType_All, NS_MOUSE_EVENT },
44144:     { nsGkAtoms::onclick,                       NS_MOUSE_CLICK, EventNameType_All, NS_MOUSE_EVENT },
44144:     { nsGkAtoms::ondblclick,                    NS_MOUSE_DOUBLECLICK, EventNameType_HTMLXUL, NS_MOUSE_EVENT },
44144:     { nsGkAtoms::onmouseover,                   NS_MOUSE_ENTER_SYNTH, EventNameType_All, NS_MOUSE_EVENT },
44144:     { nsGkAtoms::onmouseout,                    NS_MOUSE_EXIT_SYNTH, EventNameType_All, NS_MOUSE_EVENT },
46334:     { nsGkAtoms::onMozMouseHittest,             NS_MOUSE_MOZHITTEST, EventNameType_None, NS_MOUSE_EVENT },
44144:     { nsGkAtoms::onmousemove,                   NS_MOUSE_MOVE, EventNameType_All, NS_MOUSE_EVENT },
44144:     { nsGkAtoms::oncontextmenu,                 NS_CONTEXTMENU, EventNameType_HTMLXUL, NS_MOUSE_EVENT },
44144: 
44144:     { nsGkAtoms::onkeydown,                     NS_KEY_DOWN, EventNameType_HTMLXUL, NS_KEY_EVENT },
44144:     { nsGkAtoms::onkeyup,                       NS_KEY_UP, EventNameType_HTMLXUL, NS_KEY_EVENT },
44144:     { nsGkAtoms::onkeypress,                    NS_KEY_PRESS, EventNameType_HTMLXUL, NS_KEY_EVENT },
44144:                                                 
44144:     { nsGkAtoms::onfocus,                       NS_FOCUS_CONTENT, EventNameType_HTMLXUL, NS_FOCUS_EVENT },
44144:     { nsGkAtoms::onblur,                        NS_BLUR_CONTENT, EventNameType_HTMLXUL, NS_FOCUS_EVENT },
44144: 
44144:     { nsGkAtoms::onoffline,                     NS_OFFLINE, EventNameType_HTMLXUL, NS_EVENT },
44144:     { nsGkAtoms::ononline,                      NS_ONLINE, EventNameType_HTMLXUL, NS_EVENT },
44144:     { nsGkAtoms::onsubmit,                      NS_FORM_SUBMIT, EventNameType_HTMLXUL, NS_EVENT },
44144:     { nsGkAtoms::onreset,                       NS_FORM_RESET, EventNameType_HTMLXUL, NS_EVENT },
44144:     { nsGkAtoms::onchange,                      NS_FORM_CHANGE, EventNameType_HTMLXUL, NS_EVENT },
44144:     { nsGkAtoms::onselect,                      NS_FORM_SELECTED, EventNameType_HTMLXUL, NS_EVENT },
50904:     { nsGkAtoms::oninvalid,                     NS_FORM_INVALID, EventNameType_HTMLXUL, NS_EVENT },
44144:     { nsGkAtoms::onload,                        NS_LOAD, EventNameType_All, NS_EVENT },
44144:     { nsGkAtoms::onpopstate,                    NS_POPSTATE, EventNameType_HTMLXUL, NS_EVENT_NULL },
44144:     { nsGkAtoms::onunload,                      NS_PAGE_UNLOAD,
44144:                                                 (EventNameType_HTMLXUL | EventNameType_SVGSVG), NS_EVENT },
44144:     { nsGkAtoms::onhashchange,                  NS_HASHCHANGE, EventNameType_HTMLXUL, NS_EVENT },
46273:     { nsGkAtoms::onreadystatechange,            NS_READYSTATECHANGE, EventNameType_HTMLXUL },
44144:     { nsGkAtoms::onbeforeunload,                NS_BEFORE_PAGE_UNLOAD, EventNameType_HTMLXUL, NS_EVENT },
44144:     { nsGkAtoms::onabort,                       NS_IMAGE_ABORT,
44144:                                                 (EventNameType_HTMLXUL | EventNameType_SVGSVG), NS_EVENT },
44144:     { nsGkAtoms::onerror,                       NS_LOAD_ERROR,
44144:                                                 (EventNameType_HTMLXUL | EventNameType_SVGSVG), NS_EVENT },
54146:     { nsGkAtoms::onbeforescriptexecute,         NS_BEFORE_SCRIPT_EXECUTE, EventNameType_HTMLXUL, NS_EVENT },
54146:     { nsGkAtoms::onafterscriptexecute,          NS_AFTER_SCRIPT_EXECUTE, EventNameType_HTMLXUL, NS_EVENT },
44144: 
44144:     { nsGkAtoms::onDOMAttrModified,             NS_MUTATION_ATTRMODIFIED, EventNameType_HTMLXUL, NS_MUTATION_EVENT },
44144:     { nsGkAtoms::onDOMCharacterDataModified,    NS_MUTATION_CHARACTERDATAMODIFIED, EventNameType_HTMLXUL, NS_MUTATION_EVENT },
44144:     { nsGkAtoms::onDOMNodeInserted,             NS_MUTATION_NODEINSERTED, EventNameType_HTMLXUL, NS_MUTATION_EVENT },
44144:     { nsGkAtoms::onDOMNodeRemoved,              NS_MUTATION_NODEREMOVED, EventNameType_HTMLXUL, NS_MUTATION_EVENT },
44144:     { nsGkAtoms::onDOMNodeInsertedIntoDocument, NS_MUTATION_NODEINSERTEDINTODOCUMENT, EventNameType_HTMLXUL, NS_MUTATION_EVENT },
44144:     { nsGkAtoms::onDOMNodeRemovedFromDocument,  NS_MUTATION_NODEREMOVEDFROMDOCUMENT, EventNameType_HTMLXUL, NS_MUTATION_EVENT },
44144:     { nsGkAtoms::onDOMSubtreeModified,          NS_MUTATION_SUBTREEMODIFIED, EventNameType_HTMLXUL, NS_MUTATION_EVENT },
44144: 
44144:     { nsGkAtoms::onDOMActivate,                 NS_UI_ACTIVATE, EventNameType_HTMLXUL, NS_UI_EVENT },
44144:     { nsGkAtoms::onDOMFocusIn,                  NS_UI_FOCUSIN, EventNameType_HTMLXUL, NS_UI_EVENT },
44144:     { nsGkAtoms::onDOMFocusOut,                 NS_UI_FOCUSOUT, EventNameType_HTMLXUL, NS_UI_EVENT },
44144:     { nsGkAtoms::oninput,                       NS_FORM_INPUT, EventNameType_HTMLXUL, NS_UI_EVENT },
44144:                                                 
44144:     { nsGkAtoms::onDOMMouseScroll,              NS_MOUSE_SCROLL, EventNameType_HTMLXUL, NS_MOUSE_SCROLL_EVENT },
44144:     { nsGkAtoms::onMozMousePixelScroll,         NS_MOUSE_PIXEL_SCROLL, EventNameType_HTMLXUL, NS_MOUSE_SCROLL_EVENT },
44144:                                                 
44144:     { nsGkAtoms::onpageshow,                    NS_PAGE_SHOW, EventNameType_HTML, NS_EVENT },
44144:     { nsGkAtoms::onpagehide,                    NS_PAGE_HIDE, EventNameType_HTML, NS_EVENT },
57661:     { nsGkAtoms::onMozBeforeResize,             NS_BEFORERESIZE_EVENT, EventNameType_None, NS_EVENT },
44144:     { nsGkAtoms::onresize,                      NS_RESIZE_EVENT,
44144:                                                 (EventNameType_HTMLXUL | EventNameType_SVGSVG), NS_EVENT },
44144:     { nsGkAtoms::onscroll,                      NS_SCROLL_EVENT,
44144:                                                 (EventNameType_HTMLXUL | EventNameType_SVGSVG), NS_EVENT_NULL },
44144:     { nsGkAtoms::oncopy,                        NS_COPY, EventNameType_HTMLXUL, NS_EVENT },
44144:     { nsGkAtoms::oncut,                         NS_CUT, EventNameType_HTMLXUL, NS_EVENT },
44144:     { nsGkAtoms::onpaste,                       NS_PASTE, EventNameType_HTMLXUL, NS_EVENT },
  265:     // XUL specific events
44144:     { nsGkAtoms::ontext,                        NS_TEXT_TEXT, EventNameType_XUL, NS_EVENT_NULL },
44144: 
44144:     { nsGkAtoms::oncompositionstart,            NS_COMPOSITION_START, EventNameType_XUL, NS_COMPOSITION_EVENT },
44144:     { nsGkAtoms::oncompositionend,              NS_COMPOSITION_END, EventNameType_XUL, NS_COMPOSITION_EVENT },
44144: 
44144:     { nsGkAtoms::oncommand,                     NS_XUL_COMMAND, EventNameType_XUL, NS_INPUT_EVENT },
44144: 
44144:     { nsGkAtoms::onclose,                       NS_XUL_CLOSE, EventNameType_XUL, NS_EVENT_NULL},
44144:     { nsGkAtoms::onpopupshowing,                NS_XUL_POPUP_SHOWING, EventNameType_XUL, NS_EVENT_NULL},
44144:     { nsGkAtoms::onpopupshown,                  NS_XUL_POPUP_SHOWN, EventNameType_XUL, NS_EVENT_NULL},
44144:     { nsGkAtoms::onpopuphiding,                 NS_XUL_POPUP_HIDING, EventNameType_XUL, NS_EVENT_NULL},
44144:     { nsGkAtoms::onpopuphidden,                 NS_XUL_POPUP_HIDDEN, EventNameType_XUL, NS_EVENT_NULL},
44144:     { nsGkAtoms::onbroadcast,                   NS_XUL_BROADCAST, EventNameType_XUL, NS_EVENT_NULL},
44144:     { nsGkAtoms::oncommandupdate,               NS_XUL_COMMAND_UPDATE, EventNameType_XUL, NS_EVENT_NULL},
44144: 
44144:     { nsGkAtoms::ondragenter,                   NS_DRAGDROP_ENTER, EventNameType_HTMLXUL, NS_DRAG_EVENT },
44144:     { nsGkAtoms::ondragover,                    NS_DRAGDROP_OVER_SYNTH, EventNameType_HTMLXUL, NS_DRAG_EVENT },
44144:     { nsGkAtoms::ondragexit,                    NS_DRAGDROP_EXIT_SYNTH, EventNameType_XUL, NS_DRAG_EVENT },
44144:     { nsGkAtoms::ondragdrop,                    NS_DRAGDROP_DRAGDROP, EventNameType_XUL, NS_DRAG_EVENT },
44144:     { nsGkAtoms::ondraggesture,                 NS_DRAGDROP_GESTURE, EventNameType_XUL, NS_DRAG_EVENT },
44144:     { nsGkAtoms::ondrag,                        NS_DRAGDROP_DRAG, EventNameType_HTMLXUL, NS_DRAG_EVENT },
44144:     { nsGkAtoms::ondragend,                     NS_DRAGDROP_END, EventNameType_HTMLXUL, NS_DRAG_EVENT },
44144:     { nsGkAtoms::ondragstart,                   NS_DRAGDROP_START, EventNameType_HTMLXUL, NS_DRAG_EVENT },
44144:     { nsGkAtoms::ondragleave,                   NS_DRAGDROP_LEAVE_SYNTH, EventNameType_HTMLXUL, NS_DRAG_EVENT },
44144:     { nsGkAtoms::ondrop,                        NS_DRAGDROP_DROP, EventNameType_HTMLXUL, NS_DRAG_EVENT },
44144: 
44144:     { nsGkAtoms::onoverflow,                    NS_SCROLLPORT_OVERFLOW, EventNameType_XUL, NS_EVENT_NULL},
44144:     { nsGkAtoms::onunderflow,                   NS_SCROLLPORT_UNDERFLOW, EventNameType_XUL, NS_EVENT_NULL},
  265: #ifdef MOZ_SVG
44144:     { nsGkAtoms::onSVGLoad,                     NS_SVG_LOAD, EventNameType_None, NS_SVG_EVENT },
44144:     { nsGkAtoms::onSVGUnload,                   NS_SVG_UNLOAD, EventNameType_None, NS_SVG_EVENT },
44144:     { nsGkAtoms::onSVGAbort,                    NS_SVG_ABORT, EventNameType_None, NS_SVG_EVENT },
44144:     { nsGkAtoms::onSVGError,                    NS_SVG_ERROR, EventNameType_None, NS_SVG_EVENT },
44144:     { nsGkAtoms::onSVGResize,                   NS_SVG_RESIZE, EventNameType_None, NS_SVG_EVENT },
44144:     { nsGkAtoms::onSVGScroll,                   NS_SVG_SCROLL, EventNameType_None, NS_SVG_EVENT },
44144: 
44144:     { nsGkAtoms::onSVGZoom,                     NS_SVG_ZOOM, EventNameType_None, NS_SVGZOOM_EVENT },
44144: 
44144:     // This is a bit hackish, but SVG's event names are weird.
44144:     { nsGkAtoms::onzoom,                        NS_SVG_ZOOM, EventNameType_SVGSVG, NS_EVENT_NULL },
  265: #endif // MOZ_SVG
48450: #ifdef MOZ_SMIL
48450:     { nsGkAtoms::onbegin,                       NS_SMIL_BEGIN, EventNameType_SMIL, NS_EVENT_NULL },
48450:     { nsGkAtoms::onbeginEvent,                  NS_SMIL_BEGIN, EventNameType_None, NS_SMIL_TIME_EVENT },
48450:     { nsGkAtoms::onend,                         NS_SMIL_END, EventNameType_SMIL, NS_EVENT_NULL },
48450:     { nsGkAtoms::onendEvent,                    NS_SMIL_END, EventNameType_None, NS_SMIL_TIME_EVENT },
48450:     { nsGkAtoms::onrepeat,                      NS_SMIL_REPEAT, EventNameType_SMIL, NS_EVENT_NULL },
48450:     { nsGkAtoms::onrepeatEvent,                 NS_SMIL_REPEAT, EventNameType_None, NS_SMIL_TIME_EVENT },
48450: #endif // MOZ_SMIL
15751: #ifdef MOZ_MEDIA
44144:     { nsGkAtoms::onloadstart,                   NS_LOADSTART, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onprogress,                    NS_PROGRESS, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onsuspend,                     NS_SUSPEND, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onemptied,                     NS_EMPTIED, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onstalled,                     NS_STALLED, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onplay,                        NS_PLAY, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onpause,                       NS_PAUSE, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onloadedmetadata,              NS_LOADEDMETADATA, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onloadeddata,                  NS_LOADEDDATA, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onwaiting,                     NS_WAITING, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onplaying,                     NS_PLAYING, EventNameType_HTML,  NS_EVENT_NULL },
44144:     { nsGkAtoms::oncanplay,                     NS_CANPLAY, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::oncanplaythrough,              NS_CANPLAYTHROUGH, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onseeking,                     NS_SEEKING, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onseeked,                      NS_SEEKED, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::ontimeupdate,                  NS_TIMEUPDATE, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onended,                       NS_ENDED, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onratechange,                  NS_RATECHANGE, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::ondurationchange,              NS_DURATIONCHANGE, EventNameType_HTML, NS_EVENT_NULL },
44144:     { nsGkAtoms::onvolumechange,                NS_VOLUMECHANGE, EventNameType_HTML, NS_EVENT_NULL },
51477:     { nsGkAtoms::onMozAudioAvailable,           NS_MOZAUDIOAVAILABLE, EventNameType_None, NS_EVENT_NULL },
15751: #endif // MOZ_MEDIA
44144:     { nsGkAtoms::onMozAfterPaint,               NS_AFTERPAINT, EventNameType_None, NS_EVENT },
50367:     { nsGkAtoms::onMozBeforePaint,              NS_BEFOREPAINT, EventNameType_None, NS_EVENT_NULL },
44144: 
44144:     { nsGkAtoms::onMozScrolledAreaChanged,      NS_SCROLLEDAREACHANGED, EventNameType_None, NS_SCROLLAREA_EVENT },
20793: 
20793:     // Simple gesture events
44144:     { nsGkAtoms::onMozSwipeGesture,             NS_SIMPLE_GESTURE_SWIPE, EventNameType_None, NS_SIMPLE_GESTURE_EVENT },
44144:     { nsGkAtoms::onMozMagnifyGestureStart,      NS_SIMPLE_GESTURE_MAGNIFY_START, EventNameType_None, NS_SIMPLE_GESTURE_EVENT },
44144:     { nsGkAtoms::onMozMagnifyGestureUpdate,     NS_SIMPLE_GESTURE_MAGNIFY_UPDATE, EventNameType_None, NS_SIMPLE_GESTURE_EVENT },
44144:     { nsGkAtoms::onMozMagnifyGesture,           NS_SIMPLE_GESTURE_MAGNIFY, EventNameType_None, NS_SIMPLE_GESTURE_EVENT },
44144:     { nsGkAtoms::onMozRotateGestureStart,       NS_SIMPLE_GESTURE_ROTATE_START, EventNameType_None, NS_SIMPLE_GESTURE_EVENT },
44144:     { nsGkAtoms::onMozRotateGestureUpdate,      NS_SIMPLE_GESTURE_ROTATE_UPDATE, EventNameType_None, NS_SIMPLE_GESTURE_EVENT },
44144:     { nsGkAtoms::onMozRotateGesture,            NS_SIMPLE_GESTURE_ROTATE, EventNameType_None, NS_SIMPLE_GESTURE_EVENT },
44144:     { nsGkAtoms::onMozTapGesture,               NS_SIMPLE_GESTURE_TAP, EventNameType_None, NS_SIMPLE_GESTURE_EVENT },
44144:     { nsGkAtoms::onMozPressTapGesture,          NS_SIMPLE_GESTURE_PRESSTAP, EventNameType_None, NS_SIMPLE_GESTURE_EVENT },
44144: 
48711:     { nsGkAtoms::onMozTouchDown,                NS_MOZTOUCH_DOWN, EventNameType_None, NS_MOZTOUCH_EVENT },
48711:     { nsGkAtoms::onMozTouchMove,                NS_MOZTOUCH_MOVE, EventNameType_None, NS_MOZTOUCH_EVENT },
48711:     { nsGkAtoms::onMozTouchUp,                  NS_MOZTOUCH_UP, EventNameType_None, NS_MOZTOUCH_EVENT },
48711: 
44144:     { nsGkAtoms::ontransitionend,               NS_TRANSITION_END, EventNameType_None, NS_TRANSITION_EVENT }
  265:   };
  265: 
44144:   sAtomEventTable = new nsDataHashtable<nsISupportsHashKey, EventNameMapping>;
44144:   sStringEventTable = new nsDataHashtable<nsStringHashKey, EventNameMapping>;
44144:   sUserDefinedEvents = new nsCOMArray<nsIAtom>(64);
44144: 
44144:   if (!sAtomEventTable || !sStringEventTable || !sUserDefinedEvents ||
44144:       !sAtomEventTable->Init(int(NS_ARRAY_LENGTH(eventArray) / 0.75) + 1) ||
44144:       !sStringEventTable->Init(int(NS_ARRAY_LENGTH(eventArray) / 0.75) + 1)) {
44144:     delete sAtomEventTable;
44144:     sAtomEventTable = nsnull;
44144:     delete sStringEventTable;
44144:     sStringEventTable = nsnull;
44144:     delete sUserDefinedEvents;
44144:     sUserDefinedEvents = nsnull;
  265:     return PR_FALSE;
  265:   }
  265: 
  265:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(eventArray); ++i) {
44144:     if (!sAtomEventTable->Put(eventArray[i].mAtom, eventArray[i]) ||
44144:         !sStringEventTable->Put(Substring(nsDependentAtomString(eventArray[i].mAtom), 2),
44144:                                 eventArray[i])) {
44144:       delete sAtomEventTable;
44144:       sAtomEventTable = nsnull;
44144:       delete sStringEventTable;
44144:       sStringEventTable = nsnull;
  265:       return PR_FALSE;
  265:     }
  265:   }
  265: 
  265:   return PR_TRUE;
  265: }
  265: 
    1: /**
    1:  * Access a cached parser service. Don't addref. We need only one
    1:  * reference to it and this class has that one.
    1:  */
    1: /* static */
    1: nsIParserService*
    1: nsContentUtils::GetParserService()
    1: {
    1:   // XXX: This isn't accessed from several threads, is it?
    1:   if (!sParserService) {
    1:     // Lock, recheck sCachedParserService and aquire if this should be
    1:     // safe for multiple threads.
    1:     nsresult rv = CallGetService(kParserServiceCID, &sParserService);
    1:     if (NS_FAILED(rv)) {
    1:       sParserService = nsnull;
    1:     }
    1:   }
    1: 
    1:   return sParserService;
    1: }
    1: 
    1: #ifdef MOZ_XTF
    1: nsIXTFService*
    1: nsContentUtils::GetXTFService()
    1: {
    1:   if (!sXTFService) {
    1:     nsresult rv = CallGetService(kXTFServiceCID, &sXTFService);
    1:     if (NS_FAILED(rv)) {
    1:       sXTFService = nsnull;
    1:     }
    1:   }
    1: 
    1:   return sXTFService;
    1: }
    1: #endif
    1: 
    1: #ifdef IBMBIDI
    1: nsIBidiKeyboard*
    1: nsContentUtils::GetBidiKeyboard()
    1: {
    1:   if (!sBidiKeyboard) {
    1:     nsresult rv = CallGetService("@mozilla.org/widget/bidikeyboard;1", &sBidiKeyboard);
    1:     if (NS_FAILED(rv)) {
    1:       sBidiKeyboard = nsnull;
    1:     }
    1:   }
    1:   return sBidiKeyboard;
    1: }
    1: #endif
    1: 
    1: template <class OutputIterator>
    1: struct NormalizeNewlinesCharTraits {
    1:   public:
    1:     typedef typename OutputIterator::value_type value_type;
    1: 
    1:   public:
    1:     NormalizeNewlinesCharTraits(OutputIterator& aIterator) : mIterator(aIterator) { }
    1:     void writechar(typename OutputIterator::value_type aChar) {
    1:       *mIterator++ = aChar;
    1:     }
    1: 
    1:   private:
    1:     OutputIterator mIterator;
    1: };
    1: 
    1: #ifdef HAVE_CPP_PARTIAL_SPECIALIZATION
    1: 
    1: template <class CharT>
    1: struct NormalizeNewlinesCharTraits<CharT*> {
    1:   public:
    1:     typedef CharT value_type;
    1: 
    1:   public:
    1:     NormalizeNewlinesCharTraits(CharT* aCharPtr) : mCharPtr(aCharPtr) { }
    1:     void writechar(CharT aChar) {
    1:       *mCharPtr++ = aChar;
    1:     }
    1: 
    1:   private:
    1:     CharT* mCharPtr;
    1: };
    1: 
    1: #else
    1: 
    1: NS_SPECIALIZE_TEMPLATE
    1: struct NormalizeNewlinesCharTraits<char*> {
    1:   public:
    1:     typedef char value_type;
    1: 
    1:   public:
    1:     NormalizeNewlinesCharTraits(char* aCharPtr) : mCharPtr(aCharPtr) { }
    1:     void writechar(char aChar) {
    1:       *mCharPtr++ = aChar;
    1:     }
    1: 
    1:   private:
    1:     char* mCharPtr;
    1: };
    1: 
    1: NS_SPECIALIZE_TEMPLATE
    1: struct NormalizeNewlinesCharTraits<PRUnichar*> {
    1:   public:
    1:     typedef PRUnichar value_type;
    1: 
    1:   public:
    1:     NormalizeNewlinesCharTraits(PRUnichar* aCharPtr) : mCharPtr(aCharPtr) { }
    1:     void writechar(PRUnichar aChar) {
    1:       *mCharPtr++ = aChar;
    1:     }
    1: 
    1:   private:
    1:     PRUnichar* mCharPtr;
    1: };
    1: 
    1: #endif
    1: 
    1: template <class OutputIterator>
    1: class CopyNormalizeNewlines
    1: {
    1:   public:
    1:     typedef typename OutputIterator::value_type value_type;
    1: 
    1:   public:
    1:     CopyNormalizeNewlines(OutputIterator* aDestination,
    1:                           PRBool aLastCharCR=PR_FALSE) :
    1:       mLastCharCR(aLastCharCR),
    1:       mDestination(aDestination),
    1:       mWritten(0)
    1:     { }
    1: 
    1:     PRUint32 GetCharsWritten() {
    1:       return mWritten;
    1:     }
    1: 
    1:     PRBool IsLastCharCR() {
    1:       return mLastCharCR;
    1:     }
    1: 
 9792:     void write(const typename OutputIterator::value_type* aSource, PRUint32 aSourceLength) {
    1: 
    1:       const typename OutputIterator::value_type* done_writing = aSource + aSourceLength;
    1: 
    1:       // If the last source buffer ended with a CR...
    1:       if (mLastCharCR) {
    1:         // ..and if the next one is a LF, then skip it since
    1:         // we've already written out a newline
    1:         if (aSourceLength && (*aSource == value_type('\n'))) {
    1:           ++aSource;
    1:         }
    1:         mLastCharCR = PR_FALSE;
    1:       }
    1: 
    1:       PRUint32 num_written = 0;
    1:       while ( aSource < done_writing ) {
    1:         if (*aSource == value_type('\r')) {
    1:           mDestination->writechar('\n');
    1:           ++aSource;
    1:           // If we've reached the end of the buffer, record
    1:           // that we wrote out a CR
    1:           if (aSource == done_writing) {
    1:             mLastCharCR = PR_TRUE;
    1:           }
    1:           // If the next character is a LF, skip it
    1:           else if (*aSource == value_type('\n')) {
    1:             ++aSource;
    1:           }
    1:         }
    1:         else {
    1:           mDestination->writechar(*aSource++);
    1:         }
    1:         ++num_written;
    1:       }
    1: 
    1:       mWritten += num_written;
    1:     }
    1: 
    1:   private:
    1:     PRBool mLastCharCR;
    1:     OutputIterator* mDestination;
    1:     PRUint32 mWritten;
    1: };
    1: 
    1: // static
    1: PRUint32
    1: nsContentUtils::CopyNewlineNormalizedUnicodeTo(const nsAString& aSource,
    1:                                                PRUint32 aSrcOffset,
    1:                                                PRUnichar* aDest,
    1:                                                PRUint32 aLength,
    1:                                                PRBool& aLastCharCR)
    1: {
    1:   typedef NormalizeNewlinesCharTraits<PRUnichar*> sink_traits;
    1: 
    1:   sink_traits dest_traits(aDest);
    1:   CopyNormalizeNewlines<sink_traits> normalizer(&dest_traits,aLastCharCR);
    1:   nsReadingIterator<PRUnichar> fromBegin, fromEnd;
    1:   copy_string(aSource.BeginReading(fromBegin).advance( PRInt32(aSrcOffset) ),
    1:               aSource.BeginReading(fromEnd).advance( PRInt32(aSrcOffset+aLength) ),
    1:               normalizer);
    1:   aLastCharCR = normalizer.IsLastCharCR();
    1:   return normalizer.GetCharsWritten();
    1: }
    1: 
    1: // static
    1: PRUint32
    1: nsContentUtils::CopyNewlineNormalizedUnicodeTo(nsReadingIterator<PRUnichar>& aSrcStart, const nsReadingIterator<PRUnichar>& aSrcEnd, nsAString& aDest)
    1: {
    1:   typedef nsWritingIterator<PRUnichar> WritingIterator;
    1:   typedef NormalizeNewlinesCharTraits<WritingIterator> sink_traits;
    1: 
    1:   WritingIterator iter;
    1:   aDest.BeginWriting(iter);
    1:   sink_traits dest_traits(iter);
    1:   CopyNormalizeNewlines<sink_traits> normalizer(&dest_traits);
    1:   copy_string(aSrcStart, aSrcEnd, normalizer);
    1:   return normalizer.GetCharsWritten();
    1: }
    1: 
 7832: // Replaced by precompiled CCMap (see bug 180266). To update the list
 7832: // of characters, see one of files included below. As for the way
 7832: // the original list of characters was obtained by Frank Tang, see bug 54467.
 7832: // Updated to fix the regression (bug 263411). The list contains
 7832: // characters of the following Unicode character classes : Ps, Pi, Po, Pf, Pe.
 7832: // (ref.: http://www.w3.org/TR/2004/CR-CSS21-20040225/selector.html#first-letter)
15634: #include "punct_marks.x-ccmap"
15634: DEFINE_X_CCMAP(gPuncCharsCCMapExt, const);
 7832: 
 7832: // static
 7832: PRBool
15634: nsContentUtils::IsPunctuationMark(PRUint32 aChar)
 7832: {
15634:   return CCMAP_HAS_CHAR_EXT(gPuncCharsCCMapExt, aChar);
15634: }
15634: 
15634: // static
15634: PRBool
15634: nsContentUtils::IsPunctuationMarkAt(const nsTextFragment* aFrag, PRUint32 aOffset)
15634: {
15634:   PRUnichar h = aFrag->CharAt(aOffset);
15634:   if (!IS_SURROGATE(h)) {
15634:     return IsPunctuationMark(h);
15634:   }
15634:   if (NS_IS_HIGH_SURROGATE(h) && aOffset + 1 < aFrag->GetLength()) {
15634:     PRUnichar l = aFrag->CharAt(aOffset + 1);
15634:     if (NS_IS_LOW_SURROGATE(l)) {
15634:       return IsPunctuationMark(SURROGATE_TO_UCS4(h, l));
15634:     }
15634:   }
15634:   return PR_FALSE;
15634: }
15634: 
15634: // static
15634: PRBool nsContentUtils::IsAlphanumeric(PRUint32 aChar)
15634: {
15634:   nsIUGenCategory::nsUGenCategory cat = sGenCat->Get(aChar);
15634: 
15634:   return (cat == nsIUGenCategory::kLetter || cat == nsIUGenCategory::kNumber);
15634: }
15634:  
15634: // static
15634: PRBool nsContentUtils::IsAlphanumericAt(const nsTextFragment* aFrag, PRUint32 aOffset)
15634: {
15634:   PRUnichar h = aFrag->CharAt(aOffset);
15634:   if (!IS_SURROGATE(h)) {
15634:     return IsAlphanumeric(h);
15634:   }
15634:   if (NS_IS_HIGH_SURROGATE(h) && aOffset + 1 < aFrag->GetLength()) {
15634:     PRUnichar l = aFrag->CharAt(aOffset + 1);
15634:     if (NS_IS_LOW_SURROGATE(l)) {
15634:       return IsAlphanumeric(SURROGATE_TO_UCS4(h, l));
15634:     }
15634:   }
15634:   return PR_FALSE;
 7832: }
 7832: 
10340: /* static */
15303: PRBool
15303: nsContentUtils::IsHTMLWhitespace(PRUnichar aChar)
15303: {
15303:   return aChar == PRUnichar(0x0009) ||
15303:          aChar == PRUnichar(0x000A) ||
15303:          aChar == PRUnichar(0x000C) ||
15303:          aChar == PRUnichar(0x000D) ||
15303:          aChar == PRUnichar(0x0020);
15303: }
15303: 
46197: /* static */
46197: PRBool
46197: nsContentUtils::ParseIntMarginValue(const nsAString& aString, nsIntMargin& result)
46197: {
46197:   nsAutoString marginStr(aString);
46197:   marginStr.CompressWhitespace(PR_TRUE, PR_TRUE);
46197:   if (marginStr.IsEmpty()) {
46197:     return PR_FALSE;
46197:   }
46197: 
46197:   PRInt32 start = 0, end = 0;
46197:   for (int count = 0; count < 4; count++) {
49030:     if ((PRUint32)end >= marginStr.Length())
46197:       return PR_FALSE;
46197: 
46197:     // top, right, bottom, left
46197:     if (count < 3)
46197:       end = Substring(marginStr, start).FindChar(',');
46197:     else
46197:       end = Substring(marginStr, start).Length();
46197: 
46197:     if (end <= 0)
46197:       return PR_FALSE;
46197: 
46197:     PRInt32 ec, val = 
46197:       nsString(Substring(marginStr, start, end)).ToInteger(&ec);
46197:     if (NS_FAILED(ec))
46197:       return PR_FALSE;
46197: 
46197:     switch(count) {
46197:       case 0:
46197:         result.top = val;
46197:       break;
46197:       case 1:
46197:         result.right = val;
46197:       break;
46197:       case 2:
46197:         result.bottom = val;
46197:       break;
46197:       case 3:
46197:         result.left = val;
46197:       break;
46197:     }
46197:     start += end + 1;
46197:   }
46197:   return PR_TRUE;
46197: }
15303: 
15303: /* static */
10340: void
21366: nsContentUtils::GetOfflineAppManifest(nsIDocument *aDocument, nsIURI **aURI)
10340: {
41634:   Element* docElement = aDocument->GetRootElement();
10340:   if (!docElement) {
10340:     return;
10340:   }
10340: 
10340:   nsAutoString manifestSpec;
10340:   docElement->GetAttr(kNameSpaceID_None, nsGkAtoms::manifest, manifestSpec);
10340: 
10340:   // Manifest URIs can't have fragment identifiers.
10340:   if (manifestSpec.IsEmpty() ||
10340:       manifestSpec.FindChar('#') != kNotFound) {
10340:     return;
10340:   }
10340: 
10340:   nsContentUtils::NewURIWithDocumentCharset(aURI, manifestSpec,
41900:                                             aDocument,
41900:                                             aDocument->GetDocBaseURI());
10340: }
10340: 
10340: /* static */
10340: PRBool
10340: nsContentUtils::OfflineAppAllowed(nsIURI *aURI)
10340: {
20651:   nsCOMPtr<nsIOfflineCacheUpdateService> updateService =
20651:     do_GetService(NS_OFFLINECACHEUPDATESERVICE_CONTRACTID);
20651:   if (!updateService) {
20651:     return PR_FALSE;
20651:   }
20651: 
20651:   PRBool allowed;
20651:   nsresult rv = updateService->OfflineAppAllowedForURI(aURI,
20651:                                                        sPrefBranch,
20651:                                                        &allowed);
20651:   return NS_SUCCEEDED(rv) && allowed;
10340: }
10340: 
18488: /* static */
18488: PRBool
18488: nsContentUtils::OfflineAppAllowed(nsIPrincipal *aPrincipal)
18488: {
20651:   nsCOMPtr<nsIOfflineCacheUpdateService> updateService =
20651:     do_GetService(NS_OFFLINECACHEUPDATESERVICE_CONTRACTID);
20651:   if (!updateService) {
20651:     return PR_FALSE;
20651:   }
20651: 
20651:   PRBool allowed;
20651:   nsresult rv = updateService->OfflineAppAllowed(aPrincipal,
20651:                                                  sPrefBranch,
20651:                                                  &allowed);
20651:   return NS_SUCCEEDED(rv) && allowed;
18488: }
18488: 
    1: // static
    1: void
    1: nsContentUtils::Shutdown()
    1: {
    1:   sInitialized = PR_FALSE;
    1: 
    1:   NS_HTMLParanoidFragmentSinkShutdown();
    1:   NS_XHTMLParanoidFragmentSinkShutdown();
    1: 
    1:   NS_IF_RELEASE(sContentPolicyService);
    1:   sTriedToGetContentPolicy = PR_FALSE;
26413:   PRUint32 i;
26413:   for (i = 0; i < PropertiesFile_COUNT; ++i)
    1:     NS_IF_RELEASE(sStringBundles[i]);
37975: 
37975:   // Clean up c-style's observer 
48723:   if (sPrefCallbackTable) {
48723:     delete sPrefCallbackTable;
48723:     sPrefCallbackTable = nsnull;
37975:   }
37975: 
41408:   delete sPrefCacheData;
41408:   sPrefCacheData = nsnull;
41408: 
    1:   NS_IF_RELEASE(sStringBundleService);
    1:   NS_IF_RELEASE(sConsoleService);
    1:   NS_IF_RELEASE(sDOMScriptObjectFactory);
41899:   sXPConnect = nsnull;
41899:   sThreadJSContextStack = nsnull;
    1:   NS_IF_RELEASE(sSecurityManager);
    1:   NS_IF_RELEASE(sNameSpaceManager);
    1:   NS_IF_RELEASE(sParserService);
    1:   NS_IF_RELEASE(sIOService);
    1:   NS_IF_RELEASE(sLineBreaker);
    1:   NS_IF_RELEASE(sWordBreaker);
15634:   NS_IF_RELEASE(sGenCat);
    1: #ifdef MOZ_XTF
    1:   NS_IF_RELEASE(sXTFService);
    1: #endif
    1:   NS_IF_RELEASE(sImgLoader);
30065:   NS_IF_RELEASE(sImgCache);
49060:   NS_IF_RELEASE(sHistory);
    1:   NS_IF_RELEASE(sPrefBranch);
    1: #ifdef IBMBIDI
    1:   NS_IF_RELEASE(sBidiKeyboard);
    1: #endif
  265: 
44144:   delete sAtomEventTable;
44144:   sAtomEventTable = nsnull;
44144:   delete sStringEventTable;
44144:   sStringEventTable = nsnull;
44144:   delete sUserDefinedEvents;
44144:   sUserDefinedEvents = nsnull;
  265: 
    1:   if (sPtrsToPtrsToRelease) {
26413:     for (i = 0; i < sPtrsToPtrsToRelease->Length(); ++i) {
26413:       nsISupports** ptrToPtr = sPtrsToPtrsToRelease->ElementAt(i);
    1:       NS_RELEASE(*ptrToPtr);
    1:     }
    1:     delete sPtrsToPtrsToRelease;
    1:     sPtrsToPtrsToRelease = nsnull;
    1:   }
    1: 
    1:   if (sEventListenerManagersHash.ops) {
    1:     NS_ASSERTION(sEventListenerManagersHash.entryCount == 0,
    1:                  "Event listener manager hash not empty at shutdown!");
    1: 
    1:     // See comment above.
    1: 
    1:     // However, we have to handle this table differently.  If it still
    1:     // has entries, we want to leak it too, so that we can keep it alive
    1:     // in case any elements are destroyed.  Because if they are, we need
    1:     // their event listener managers to be destroyed too, or otherwise
    1:     // it could leave dangling references in DOMClassInfo's preserved
    1:     // wrapper table.
    1: 
    1:     if (sEventListenerManagersHash.entryCount == 0) {
    1:       PL_DHashTableFinish(&sEventListenerManagersHash);
    1:       sEventListenerManagersHash.ops = nsnull;
    1:     }
    1:   }
 7230: 
13098:   NS_ASSERTION(!sBlockedScriptRunners ||
13098:                sBlockedScriptRunners->Count() == 0,
13098:                "How'd this happen?");
13098:   delete sBlockedScriptRunners;
13098:   sBlockedScriptRunners = nsnull;
13098: 
18942:   NS_IF_RELEASE(sSameOriginChecker);
18942:   
 7230:   nsAutoGCRoot::Shutdown();
43129: 
43129:   nsTextEditorState::ShutDown();
    1: }
    1: 
 8008: // static
 8008: PRBool
 8008: nsContentUtils::IsCallerTrustedForCapability(const char* aCapability)
 3284: {
 3284:   // The secman really should handle UniversalXPConnect case, since that
 3284:   // should include UniversalBrowserRead... doesn't right now, though.
 3284:   PRBool hasCap;
 8008:   if (NS_FAILED(sSecurityManager->IsCapabilityEnabled(aCapability, &hasCap)))
 3284:     return PR_FALSE;
 3284:   if (hasCap)
 3284:     return PR_TRUE;
 3284:     
 8008:   if (NS_FAILED(sSecurityManager->IsCapabilityEnabled("UniversalXPConnect",
 8008:                                                       &hasCap)))
 3284:     return PR_FALSE;
 3284:   return hasCap;
 3284: }
 3284: 
    1: /**
    1:  * Checks whether two nodes come from the same origin. aTrustedNode is
    1:  * considered 'safe' in that a user can operate on it and that it isn't
    1:  * a js-object that implements nsIDOMNode.
    1:  * Never call this function with the first node provided by script, it
    1:  * must always be known to be a 'real' node!
    1:  */
    1: // static
    1: nsresult
37947: nsContentUtils::CheckSameOrigin(nsINode *aTrustedNode,
    1:                                 nsIDOMNode *aUnTrustedNode)
    1: {
    1:   NS_PRECONDITION(aTrustedNode, "There must be a trusted node");
    1: 
    1:   PRBool isSystem = PR_FALSE;
    1:   sSecurityManager->SubjectPrincipalIsSystem(&isSystem);
    1:   if (isSystem) {
    1:     // we're running as system, grant access to the node.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   /*
    1:    * Get hold of each node's principal
    1:    */
    1:   nsCOMPtr<nsINode> unTrustedNode = do_QueryInterface(aUnTrustedNode);
    1: 
    1:   // Make sure these are both real nodes
37947:   NS_ENSURE_TRUE(aTrustedNode && unTrustedNode, NS_ERROR_UNEXPECTED);
37947: 
37947:   nsIPrincipal* trustedPrincipal = aTrustedNode->NodePrincipal();
    1:   nsIPrincipal* unTrustedPrincipal = unTrustedNode->NodePrincipal();
    1: 
    1:   if (trustedPrincipal == unTrustedPrincipal) {
    1:     return NS_OK;
    1:   }
    1: 
 3284:   PRBool equal;
 3284:   // XXXbz should we actually have a Subsumes() check here instead?  Or perhaps
 3284:   // a separate method for that, with callers using one or the other?
 3284:   if (NS_FAILED(trustedPrincipal->Equals(unTrustedPrincipal, &equal)) ||
 3284:       !equal) {
 3284:     return NS_ERROR_DOM_PROP_ACCESS_DENIED;
 3284:   }
 3284: 
 3284:   return NS_OK;
    1: }
    1: 
    1: // static
    1: PRBool
12313: nsContentUtils::CanCallerAccess(nsIPrincipal* aSubjectPrincipal,
12313:                                 nsIPrincipal* aPrincipal)
12313: {
12313:   PRBool subsumes;
12313:   nsresult rv = aSubjectPrincipal->Subsumes(aPrincipal, &subsumes);
12313:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
12313: 
12313:   if (subsumes) {
12313:     return PR_TRUE;
12313:   }
12313: 
12313:   // The subject doesn't subsume aPrincipal.  Allow access only if the subject
12313:   // has either "UniversalXPConnect" (if aPrincipal is system principal) or
12313:   // "UniversalBrowserRead" (in all other cases).
12313:   PRBool isSystem;
12313:   rv = sSecurityManager->IsSystemPrincipal(aPrincipal, &isSystem);
12313:   isSystem = NS_FAILED(rv) || isSystem;
12313:   const char* capability =
12313:     NS_FAILED(rv) || isSystem ? "UniversalXPConnect" : "UniversalBrowserRead";
12313: 
12313:   return IsCallerTrustedForCapability(capability);
12313: }
12313: 
12313: // static
12313: PRBool
    1: nsContentUtils::CanCallerAccess(nsIDOMNode *aNode)
    1: {
    1:   // XXXbz why not check the IsCapabilityEnabled thing up front, and not bother
    1:   // with the system principal games?  But really, there should be a simpler
    1:   // API here, dammit.
    1:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
    1:   sSecurityManager->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
    1: 
    1:   if (!subjectPrincipal) {
    1:     // we're running as system, grant access to the node.
    1: 
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
    1:   NS_ENSURE_TRUE(node, PR_FALSE);
    1: 
12313:   return CanCallerAccess(subjectPrincipal, node->NodePrincipal());
12313: }
12313: 
12313: // static
12313: PRBool
12313: nsContentUtils::CanCallerAccess(nsPIDOMWindow* aWindow)
12313: {
12313:   // XXXbz why not check the IsCapabilityEnabled thing up front, and not bother
12313:   // with the system principal games?  But really, there should be a simpler
12313:   // API here, dammit.
12313:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
12313:   sSecurityManager->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
12313: 
12313:   if (!subjectPrincipal) {
12313:     // we're running as system, grant access to the node.
12313: 
    1:     return PR_TRUE;
    1:   }
    1: 
12313:   nsCOMPtr<nsIScriptObjectPrincipal> scriptObject =
12313:     do_QueryInterface(aWindow->IsOuterWindow() ?
12313:                       aWindow->GetCurrentInnerWindow() : aWindow);
12313:   NS_ENSURE_TRUE(scriptObject, PR_FALSE);
12313: 
12313:   return CanCallerAccess(subjectPrincipal, scriptObject->GetPrincipal());
    1: }
    1: 
    1: //static
    1: PRBool
    1: nsContentUtils::InProlog(nsINode *aNode)
    1: {
    1:   NS_PRECONDITION(aNode, "missing node to nsContentUtils::InProlog");
    1: 
    1:   nsINode* parent = aNode->GetNodeParent();
    1:   if (!parent || !parent->IsNodeOfType(nsINode::eDOCUMENT)) {
    1:     return PR_FALSE;
    1:   }
    1: 
 3233:   nsIDocument* doc = static_cast<nsIDocument*>(parent);
41634:   nsIContent* root = doc->GetRootElement();
    1: 
    1:   return !root || doc->IndexOf(aNode) < doc->IndexOf(root);
    1: }
    1: 
    1: static JSContext *
58908: GetContextFromDocument(nsIDocument *aDocument, JSObject** aGlobalObject)
    1: {
    1:   nsIScriptGlobalObject *sgo = aDocument->GetScopeObject();
    1:   if (!sgo) {
    1:     // No script global, no context.
58908: 
58908:     *aGlobalObject = nsnull;
58908: 
    1:     return nsnull;
    1:   }
    1: 
58908:   *aGlobalObject = sgo->GetGlobalJSObject();
58908: 
    1:   nsIScriptContext *scx = sgo->GetContext();
    1:   if (!scx) {
58908:     // No context left in the old scope...
    1: 
    1:     return nsnull;
    1:   }
    1: 
    1:   return (JSContext *)scx->GetNativeContext();
    1: }
    1: 
    1: // static
    1: nsresult
58908: nsContentUtils::GetContextAndScopes(nsIDocument *aOldDocument,
    1:                                     nsIDocument *aNewDocument, JSContext **aCx,
58908:                                     JSObject **aOldScope, JSObject **aNewScope)
    1: {
    1:   *aCx = nsnull;
58908:   *aOldScope = nsnull;
    1:   *aNewScope = nsnull;
    1: 
58908:   JSObject *newScope = nsnull;
    1:   nsIScriptGlobalObject *newSGO = aNewDocument->GetScopeObject();
58908:   if (!newSGO || !(newScope = newSGO->GetGlobalJSObject())) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(sXPConnect, NS_ERROR_NOT_INITIALIZED);
    1: 
58908:   // Make sure to get our hands on the right scope object, since
58908:   // GetWrappedNativeOfNativeObject doesn't call PreCreate and hence won't get
58908:   // the right scope if we pass in something bogus.  The right scope lives on
58908:   // the script global of the old document.
58908:   // XXXbz note that if GetWrappedNativeOfNativeObject did call PreCreate it
58908:   // would get the wrong scope (that of the _new_ document), so we should be
58908:   // glad it doesn't!
58908:   JSObject *oldScope = nsnull;
58908:   JSContext *cx = GetContextFromDocument(aOldDocument, &oldScope);
58908: 
58908:   if (!oldScope) {
58908:     return NS_OK;
58908:   }
58908: 
    1:   if (!cx) {
58908:     JSObject *dummy;
58908:     cx = GetContextFromDocument(aNewDocument, &dummy);
    1: 
    1:     if (!cx) {
    1:       // No context reachable from the old or new document, use the
    1:       // calling context, or the safe context if no caller can be
    1:       // found.
    1: 
    1:       sThreadJSContextStack->Peek(&cx);
    1: 
    1:       if (!cx) {
    1:         sThreadJSContextStack->GetSafeJSContext(&cx);
    1: 
    1:         if (!cx) {
    1:           // No safe context reachable, bail.
37946:           NS_WARNING("No context reachable in GetContextAndScopes()!");
    1: 
    1:           return NS_ERROR_NOT_AVAILABLE;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   *aCx = cx;
58908:   *aOldScope = oldScope;
    1:   *aNewScope = newScope;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsContentUtils::ReparentContentWrappersInScope(nsIScriptGlobalObject *aOldScope,
    1:                                                nsIScriptGlobalObject *aNewScope)
    1: {
    1:   JSContext *cx = nsnull;
    1: 
    1:   // Try really hard to find a context to work on.
    1:   nsIScriptContext *context = aOldScope->GetContext();
    1:   if (context) {
 3233:     cx = static_cast<JSContext *>(context->GetNativeContext());
    1:   }
    1: 
    1:   if (!cx) {
    1:     context = aNewScope->GetContext();
    1:     if (context) {
 3233:       cx = static_cast<JSContext *>(context->GetNativeContext());
    1:     }
    1: 
    1:     if (!cx) {
    1:       sThreadJSContextStack->Peek(&cx);
    1: 
    1:       if (!cx) {
    1:         sThreadJSContextStack->GetSafeJSContext(&cx);
    1: 
    1:         if (!cx) {
    1:           // Wow, this is really bad!
    1:           NS_WARNING("No context reachable in ReparentContentWrappers()!");
    1: 
    1:           return NS_ERROR_NOT_AVAILABLE;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Now that we have a context, let's get the global objects from the two
    1:   // scopes and ask XPConnect to do the rest of the work.
    1: 
    1:   JSObject *oldScopeObj = aOldScope->GetGlobalJSObject();
    1:   JSObject *newScopeObj = aNewScope->GetGlobalJSObject();
    1: 
    1:   if (!newScopeObj || !oldScopeObj) {
    1:     // We can't really do anything without the JSObjects.
    1: 
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
40041:   return sXPConnect->MoveWrappers(cx, oldScopeObj, newScopeObj);
    1: }
    1: 
    1: nsIDocShell *
    1: nsContentUtils::GetDocShellFromCaller()
    1: {
    1:   JSContext *cx = nsnull;
    1:   sThreadJSContextStack->Peek(&cx);
    1: 
    1:   if (cx) {
    1:     nsIScriptGlobalObject *sgo = nsJSUtils::GetDynamicScriptGlobal(cx);
    1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(sgo));
    1: 
    1:     if (win) {
    1:       return win->GetDocShell();
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
52309: nsPIDOMWindow *
52309: nsContentUtils::GetWindowFromCaller()
52309: {
52309:   JSContext *cx = nsnull;
52309:   sThreadJSContextStack->Peek(&cx);
52309: 
52309:   if (cx) {
52309:     nsCOMPtr<nsPIDOMWindow> win =
52309:       do_QueryInterface(nsJSUtils::GetDynamicScriptGlobal(cx));
52309:     return win;
52309:   }
52309: 
52309:   return nsnull;
52309: }
52309: 
    1: nsIDOMDocument *
    1: nsContentUtils::GetDocumentFromCaller()
    1: {
    1:   JSContext *cx = nsnull;
53556:   JSObject *obj = nsnull;
53556:   sXPConnect->GetCaller(&cx, &obj);
53556:   NS_ASSERTION(cx && obj, "Caller ensures something is running");
    1: 
    1:   nsCOMPtr<nsPIDOMWindow> win =
53556:     do_QueryInterface(nsJSUtils::GetStaticScriptGlobal(cx, obj));
53556:   if (!win) {
53556:     return nsnull;
53556:   }
53556: 
53556:   return win->GetExtantDocument();
    1: }
    1: 
    1: nsIDOMDocument *
    1: nsContentUtils::GetDocumentFromContext()
    1: {
    1:   JSContext *cx = nsnull;
    1:   sThreadJSContextStack->Peek(&cx);
    1: 
    1:   if (cx) {
    1:     nsIScriptGlobalObject *sgo = nsJSUtils::GetDynamicScriptGlobal(cx);
    1: 
    1:     if (sgo) {
    1:       nsCOMPtr<nsPIDOMWindow> pwin = do_QueryInterface(sgo);
    1:       if (pwin) {
    1:         return pwin->GetExtantDocument();
    1:       }
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsContentUtils::IsCallerChrome()
    1: {
    1:   PRBool is_caller_chrome = PR_FALSE;
    1:   nsresult rv = sSecurityManager->SubjectPrincipalIsSystem(&is_caller_chrome);
    1:   if (NS_FAILED(rv)) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   return is_caller_chrome;
    1: }
    1: 
    1: PRBool
    1: nsContentUtils::IsCallerTrustedForRead()
    1: {
    1:   return IsCallerTrustedForCapability("UniversalBrowserRead");
    1: }
    1: 
    1: PRBool
    1: nsContentUtils::IsCallerTrustedForWrite()
    1: {
    1:   return IsCallerTrustedForCapability("UniversalBrowserWrite");
    1: }
    1: 
    1: // static
47793: nsINode*
47793: nsContentUtils::GetCrossDocParentNode(nsINode* aChild)
47793: {
47793:   NS_PRECONDITION(aChild, "The child is null!");
47793: 
47793:   nsINode* parent = aChild->GetNodeParent();
47793:   if (parent || !aChild->IsNodeOfType(nsINode::eDOCUMENT))
47793:     return parent;
47793: 
47793:   nsIDocument* doc = static_cast<nsIDocument*>(aChild);
47793:   nsIDocument* parentDoc = doc->GetParentDocument();
47793:   return parentDoc ? parentDoc->FindContentForSubDocument(doc) : nsnull;
47793: }
47793: 
47793: // static
    1: PRBool
42105: nsContentUtils::ContentIsDescendantOf(const nsINode* aPossibleDescendant,
42105:                                       const nsINode* aPossibleAncestor)
    1: {
    1:   NS_PRECONDITION(aPossibleDescendant, "The possible descendant is null!");
    1:   NS_PRECONDITION(aPossibleAncestor, "The possible ancestor is null!");
    1: 
    1:   do {
    1:     if (aPossibleDescendant == aPossibleAncestor)
    1:       return PR_TRUE;
    1:     aPossibleDescendant = aPossibleDescendant->GetNodeParent();
    1:   } while (aPossibleDescendant);
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
32033: // static
32033: PRBool
32033: nsContentUtils::ContentIsCrossDocDescendantOf(nsINode* aPossibleDescendant,
32033:                                               nsINode* aPossibleAncestor)
32033: {
32033:   NS_PRECONDITION(aPossibleDescendant, "The possible descendant is null!");
32033:   NS_PRECONDITION(aPossibleAncestor, "The possible ancestor is null!");
32033: 
32033:   do {
32033:     if (aPossibleDescendant == aPossibleAncestor)
32033:       return PR_TRUE;
47793:     aPossibleDescendant = GetCrossDocParentNode(aPossibleDescendant);
32033:   } while (aPossibleDescendant);
32033: 
32033:   return PR_FALSE;
32033: }
32033: 
    1: 
    1: // static
    1: nsresult
41630: nsContentUtils::GetAncestors(nsINode* aNode,
41630:                              nsTArray<nsINode*>& aArray)
41630: {
41630:   while (aNode) {
41630:     aArray.AppendElement(aNode);
41630:     aNode = aNode->GetNodeParent();
41630:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // static
    1: nsresult
    1: nsContentUtils::GetAncestorsAndOffsets(nsIDOMNode* aNode,
    1:                                        PRInt32 aOffset,
26413:                                        nsTArray<nsIContent*>* aAncestorNodes,
26413:                                        nsTArray<PRInt32>* aAncestorOffsets)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNode);
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
    1: 
    1:   if (!content) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
26413:   if (!aAncestorNodes->IsEmpty()) {
    1:     NS_WARNING("aAncestorNodes is not empty");
    1:     aAncestorNodes->Clear();
    1:   }
    1: 
26413:   if (!aAncestorOffsets->IsEmpty()) {
    1:     NS_WARNING("aAncestorOffsets is not empty");
    1:     aAncestorOffsets->Clear();
    1:   }
    1: 
    1:   // insert the node itself
    1:   aAncestorNodes->AppendElement(content.get());
26413:   aAncestorOffsets->AppendElement(aOffset);
    1: 
    1:   // insert all the ancestors
    1:   nsIContent* child = content;
    1:   nsIContent* parent = child->GetParent();
    1:   while (parent) {
    1:     aAncestorNodes->AppendElement(parent);
26413:     aAncestorOffsets->AppendElement(parent->IndexOf(child));
    1:     child = parent;
    1:     parent = parent->GetParent();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // static
    1: nsresult
    1: nsContentUtils::GetCommonAncestor(nsIDOMNode *aNode,
    1:                                   nsIDOMNode *aOther,
    1:                                   nsIDOMNode** aCommonAncestor)
    1: {
    1:   *aCommonAncestor = nsnull;
    1: 
    1:   nsCOMPtr<nsINode> node1 = do_QueryInterface(aNode);
    1:   nsCOMPtr<nsINode> node2 = do_QueryInterface(aOther);
    1: 
    1:   NS_ENSURE_TRUE(node1 && node2, NS_ERROR_UNEXPECTED);
    1: 
    1:   nsINode* common = GetCommonAncestor(node1, node2);
    1:   NS_ENSURE_TRUE(common, NS_ERROR_NOT_AVAILABLE);
    1: 
    1:   return CallQueryInterface(common, aCommonAncestor);
    1: }
    1: 
    1: // static
    1: nsINode*
    1: nsContentUtils::GetCommonAncestor(nsINode* aNode1,
    1:                                   nsINode* aNode2)
    1: {
    1:   if (aNode1 == aNode2) {
    1:     return aNode1;
    1:   }
    1: 
    1:   // Build the chain of parents
    1:   nsAutoTPtrArray<nsINode, 30> parents1, parents2;
    1:   do {
    1:     parents1.AppendElement(aNode1);
    1:     aNode1 = aNode1->GetNodeParent();
    1:   } while (aNode1);
    1:   do {
    1:     parents2.AppendElement(aNode2);
    1:     aNode2 = aNode2->GetNodeParent();
    1:   } while (aNode2);
    1: 
    1:   // Find where the parent chain differs
    1:   PRUint32 pos1 = parents1.Length();
    1:   PRUint32 pos2 = parents2.Length();
    1:   nsINode* parent = nsnull;
    1:   PRUint32 len;
38390:   for (len = NS_MIN(pos1, pos2); len > 0; --len) {
    1:     nsINode* child1 = parents1.ElementAt(--pos1);
    1:     nsINode* child2 = parents2.ElementAt(--pos2);
    1:     if (child1 != child2) {
    1:       break;
    1:     }
    1:     parent = child1;
    1:   }
    1: 
    1:   return parent;
    1: }
    1: 
    1: /* static */
    1: PRInt32
    1: nsContentUtils::ComparePoints(nsINode* aParent1, PRInt32 aOffset1,
12178:                               nsINode* aParent2, PRInt32 aOffset2,
12178:                               PRBool* aDisconnected)
    1: {
    1:   if (aParent1 == aParent2) {
    1:     return aOffset1 < aOffset2 ? -1 :
    1:            aOffset1 > aOffset2 ? 1 :
    1:            0;
    1:   }
    1: 
 7820:   nsAutoTArray<nsINode*, 32> parents1, parents2;
    1:   nsINode* node1 = aParent1;
    1:   nsINode* node2 = aParent2;
    1:   do {
    1:     parents1.AppendElement(node1);
    1:     node1 = node1->GetNodeParent();
    1:   } while (node1);
    1:   do {
    1:     parents2.AppendElement(node2);
    1:     node2 = node2->GetNodeParent();
    1:   } while (node2);
    1: 
    1:   PRUint32 pos1 = parents1.Length() - 1;
    1:   PRUint32 pos2 = parents2.Length() - 1;
    1:   
21194:   PRBool disconnected = parents1.ElementAt(pos1) != parents2.ElementAt(pos2);
12178:   if (aDisconnected) {
21194:     *aDisconnected = disconnected;
21194:   }
21194:   if (disconnected) {
21194:     NS_ASSERTION(aDisconnected, "unexpected disconnected nodes");
21194:     return 1;
12178:   }
    1: 
    1:   // Find where the parent chains differ
    1:   nsINode* parent = parents1.ElementAt(pos1);
    1:   PRUint32 len;
38390:   for (len = NS_MIN(pos1, pos2); len > 0; --len) {
    1:     nsINode* child1 = parents1.ElementAt(--pos1);
    1:     nsINode* child2 = parents2.ElementAt(--pos2);
    1:     if (child1 != child2) {
    1:       return parent->IndexOf(child1) < parent->IndexOf(child2) ? -1 : 1;
    1:     }
    1:     parent = child1;
    1:   }
    1: 
    1:   
    1:   // The parent chains never differed, so one of the nodes is an ancestor of
    1:   // the other
    1: 
    1:   NS_ASSERTION(!pos1 || !pos2,
    1:                "should have run out of parent chain for one of the nodes");
    1: 
    1:   if (!pos1) {
    1:     nsINode* child2 = parents2.ElementAt(--pos2);
    1:     return aOffset1 <= parent->IndexOf(child2) ? -1 : 1;
    1:   }
    1: 
    1:   nsINode* child1 = parents1.ElementAt(--pos1);
    1:   return parent->IndexOf(child1) < aOffset2 ? -1 : 1;
    1: }
    1: 
    1: nsIContent*
    1: nsContentUtils::FindFirstChildWithResolvedTag(nsIContent* aParent,
    1:                                               PRInt32 aNamespace,
    1:                                               nsIAtom* aTag)
    1: {
    1:   nsIDocument* doc;
    1:   if (!aParent || !(doc = aParent->GetOwnerDoc())) {
    1:     return nsnull;
    1:   }
    1:   
    1:   nsBindingManager* bindingManager = doc->BindingManager();
    1: 
    1:   PRInt32 namespaceID;
    1:   PRUint32 count = aParent->GetChildCount();
    1: 
    1:   PRUint32 i;
    1: 
    1:   for (i = 0; i < count; i++) {
    1:     nsIContent *child = aParent->GetChildAt(i);
    1:     nsIAtom* tag =  bindingManager->ResolveTag(child, &namespaceID);
    1:     if (tag == aTag && namespaceID == aNamespace) {
    1:       return child;
    1:     }
    1:   }
    1: 
    1:   // now look for children in XBL
    1:   nsCOMPtr<nsIDOMNodeList> children;
    1:   bindingManager->GetXBLChildNodesFor(aParent, getter_AddRefs(children));
    1:   if (!children) {
    1:     return nsnull;
    1:   }
    1: 
    1:   PRUint32 length;
    1:   children->GetLength(&length);
    1:   for (i = 0; i < length; i++) {
    1:     nsCOMPtr<nsIDOMNode> childNode;
    1:     children->Item(i, getter_AddRefs(childNode));
    1:     nsCOMPtr<nsIContent> childContent = do_QueryInterface(childNode);
    1:     nsIAtom* tag = bindingManager->ResolveTag(childContent, &namespaceID);
    1:     if (tag == aTag && namespaceID == aNamespace) {
    1:       return childContent;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: inline PRBool
    1: IsCharInSet(const char* aSet,
    1:             const PRUnichar aChar)
    1: {
    1:   PRUnichar ch;
    1:   while ((ch = *aSet)) {
    1:     if (aChar == PRUnichar(ch)) {
    1:       return PR_TRUE;
    1:     }
    1:     ++aSet;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: /**
    1:  * This method strips leading/trailing chars, in given set, from string.
    1:  */
    1: 
    1: // static
    1: const nsDependentSubstring
    1: nsContentUtils::TrimCharsInSet(const char* aSet,
    1:                                const nsAString& aValue)
    1: {
    1:   nsAString::const_iterator valueCurrent, valueEnd;
    1: 
    1:   aValue.BeginReading(valueCurrent);
    1:   aValue.EndReading(valueEnd);
    1: 
    1:   // Skip characters in the beginning
    1:   while (valueCurrent != valueEnd) {
    1:     if (!IsCharInSet(aSet, *valueCurrent)) {
    1:       break;
    1:     }
    1:     ++valueCurrent;
    1:   }
    1: 
    1:   if (valueCurrent != valueEnd) {
    1:     for (;;) {
    1:       --valueEnd;
    1:       if (!IsCharInSet(aSet, *valueEnd)) {
    1:         break;
    1:       }
    1:     }
    1:     ++valueEnd; // Step beyond the last character we want in the value.
    1:   }
    1: 
    1:   // valueEnd should point to the char after the last to copy
    1:   return Substring(valueCurrent, valueEnd);
    1: }
    1: 
    1: /**
    1:  * This method strips leading and trailing whitespace from a string.
    1:  */
    1: 
    1: // static
50910: template<PRBool IsWhitespace(PRUnichar)>
    1: const nsDependentSubstring
    1: nsContentUtils::TrimWhitespace(const nsAString& aStr, PRBool aTrimTrailing)
    1: {
    1:   nsAString::const_iterator start, end;
    1: 
    1:   aStr.BeginReading(start);
    1:   aStr.EndReading(end);
    1: 
    1:   // Skip whitespace characters in the beginning
50910:   while (start != end && IsWhitespace(*start)) {
    1:     ++start;
    1:   }
    1: 
    1:   if (aTrimTrailing) {
    1:     // Skip whitespace characters in the end.
    1:     while (end != start) {
    1:       --end;
    1: 
50910:       if (!IsWhitespace(*end)) {
    1:         // Step back to the last non-whitespace character.
    1:         ++end;
    1: 
    1:         break;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Return a substring for the string w/o leading and/or trailing
    1:   // whitespace
    1: 
    1:   return Substring(start, end);
    1: }
    1: 
50910: // Declaring the templates we are going to use avoid linking issues without
50910: // inlining the method. Considering there is not so much spaces checking
50910: // methods we can consider this to be better than inlining.
50910: template
50910: const nsDependentSubstring
50910: nsContentUtils::TrimWhitespace<nsCRT::IsAsciiSpace>(const nsAString&, PRBool);
50910: template
50910: const nsDependentSubstring
50910: nsContentUtils::TrimWhitespace<nsContentUtils::IsHTMLWhitespace>(const nsAString&, PRBool);
50910: 
    1: static inline void KeyAppendSep(nsACString& aKey)
    1: {
    1:   if (!aKey.IsEmpty()) {
    1:     aKey.Append('>');
    1:   }
    1: }
    1: 
    1: static inline void KeyAppendString(const nsAString& aString, nsACString& aKey)
    1: {
    1:   KeyAppendSep(aKey);
    1: 
    1:   // Could escape separator here if collisions happen.  > is not a legal char
    1:   // for a name or type attribute, so we should be safe avoiding that extra work.
    1: 
    1:   AppendUTF16toUTF8(aString, aKey);
    1: }
    1: 
    1: static inline void KeyAppendString(const nsACString& aString, nsACString& aKey)
    1: {
    1:   KeyAppendSep(aKey);
    1: 
    1:   // Could escape separator here if collisions happen.  > is not a legal char
    1:   // for a name or type attribute, so we should be safe avoiding that extra work.
    1: 
    1:   aKey.Append(aString);
    1: }
    1: 
    1: static inline void KeyAppendInt(PRInt32 aInt, nsACString& aKey)
    1: {
    1:   KeyAppendSep(aKey);
    1: 
    1:   aKey.Append(nsPrintfCString("%d", aInt));
    1: }
    1: 
    1: static inline void KeyAppendAtom(nsIAtom* aAtom, nsACString& aKey)
    1: {
    1:   NS_PRECONDITION(aAtom, "KeyAppendAtom: aAtom can not be null!\n");
    1: 
39100:   KeyAppendString(nsAtomCString(aAtom), aKey);
    1: }
    1: 
55138: static inline PRBool IsAutocompleteOff(const nsIContent* aElement)
47801: {
47801:   return aElement->AttrValueIs(kNameSpaceID_None, nsGkAtoms::autocomplete,
47801:                                NS_LITERAL_STRING("off"), eIgnoreCase);
    1: }
    1: 
    1: /*static*/ nsresult
    1: nsContentUtils::GenerateStateKey(nsIContent* aContent,
55138:                                  const nsIDocument* aDocument,
    1:                                  nsIStatefulFrame::SpecialStateID aID,
    1:                                  nsACString& aKey)
    1: {
    1:   aKey.Truncate();
    1: 
    1:   PRUint32 partID = aDocument ? aDocument->GetPartID() : 0;
    1: 
    1:   // SpecialStateID case - e.g. scrollbars around the content window
    1:   // The key in this case is a special state id
    1:   if (nsIStatefulFrame::eNoID != aID) {
    1:     KeyAppendInt(partID, aKey);  // first append a partID
    1:     KeyAppendInt(aID, aKey);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // We must have content if we're not using a special state id
    1:   NS_ENSURE_TRUE(aContent, NS_ERROR_FAILURE);
    1: 
    1:   // Don't capture state for anonymous content
16126:   if (aContent->IsInAnonymousSubtree()) {
    1:     return NS_OK;
    1:   }
    1: 
47801:   if (IsAutocompleteOff(aContent)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIHTMLDocument> htmlDocument(do_QueryInterface(aContent->GetCurrentDoc()));
    1: 
    1:   KeyAppendInt(partID, aKey);  // first append a partID
    1:   // Make sure we can't possibly collide with an nsIStatefulFrame
    1:   // special id of some sort
    1:   KeyAppendInt(nsIStatefulFrame::eNoID, aKey);
    1:   PRBool generatedUniqueKey = PR_FALSE;
    1: 
    1:   if (htmlDocument) {
    1:     // Flush our content model so it'll be up to date
35590:     // If this becomes unnecessary and the following line is removed,
35590:     // please also remove the corresponding flush operation from
35590:     // nsHtml5TreeBuilderCppSupplement.h. (Look for "See bug 497861." there.)
    1:     aContent->GetCurrentDoc()->FlushPendingNotifications(Flush_Content);
    1: 
    1:     nsContentList *htmlForms = htmlDocument->GetForms();
    1:     nsContentList *htmlFormControls = htmlDocument->GetFormControls();
    1: 
    1:     NS_ENSURE_TRUE(htmlForms && htmlFormControls, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     // If we have a form control and can calculate form information, use that
    1:     // as the key - it is more reliable than just recording position in the
    1:     // DOM.
    1:     // XXXbz Is it, really?  We have bugs on this, I think...
    1:     // Important to have a unique key, and tag/type/name may not be.
    1:     //
    1:     // If the control has a form, the format of the key is:
    1:     // f>type>IndOfFormInDoc>IndOfControlInForm>FormName>name
    1:     // else:
    1:     // d>type>IndOfControlInDoc>name
    1:     //
    1:     // XXX We don't need to use index if name is there
    1:     // XXXbz We don't?  Why not?  I don't follow.
    1:     //
    1:     nsCOMPtr<nsIFormControl> control(do_QueryInterface(aContent));
    1:     if (control && htmlFormControls && htmlForms) {
    1: 
    1:       // Append the control type
    1:       KeyAppendInt(control->GetType(), aKey);
    1: 
    1:       // If in a form, add form name / index of form / index in form
    1:       PRInt32 index = -1;
47801:       Element *formElement = control->GetFormElement();
    1:       if (formElement) {
    1:         if (IsAutocompleteOff(formElement)) {
    1:           aKey.Truncate();
    1:           return NS_OK;
    1:         }
    1: 
    1:         KeyAppendString(NS_LITERAL_CSTRING("f"), aKey);
    1: 
    1:         // Append the index of the form in the document
47801:         index = htmlForms->IndexOf(formElement, PR_FALSE);
    1:         if (index <= -1) {
    1:           //
    1:           // XXX HACK this uses some state that was dumped into the document
    1:           // specifically to fix bug 138892.  What we are trying to do is *guess*
    1:           // which form this control's state is found in, with the highly likely
    1:           // guess that the highest form parsed so far is the one.
    1:           // This code should not be on trunk, only branch.
    1:           //
    1:           index = htmlDocument->GetNumFormsSynchronous() - 1;
    1:         }
    1:         if (index > -1) {
    1:           KeyAppendInt(index, aKey);
    1: 
    1:           // Append the index of the control in the form
    1:           nsCOMPtr<nsIForm> form(do_QueryInterface(formElement));
20237:           index = form->IndexOfControl(control);
    1: 
    1:           if (index > -1) {
    1:             KeyAppendInt(index, aKey);
    1:             generatedUniqueKey = PR_TRUE;
    1:           }
    1:         }
    1: 
    1:         // Append the form name
    1:         nsAutoString formName;
47801:         formElement->GetAttr(kNameSpaceID_None, nsGkAtoms::name, formName);
    1:         KeyAppendString(formName, aKey);
    1: 
    1:       } else {
    1: 
    1:         KeyAppendString(NS_LITERAL_CSTRING("d"), aKey);
    1: 
    1:         // If not in a form, add index of control in document
    1:         // Less desirable than indexing by form info.
    1: 
    1:         // Hash by index of control in doc (we are not in a form)
    1:         // These are important as they are unique, and type/name may not be.
    1: 
 6564:         // We have to flush sink notifications at this point to make
 6564:         // sure that htmlFormControls is up to date.
 6564:         index = htmlFormControls->IndexOf(aContent, PR_TRUE);
    1:         if (index > -1) {
    1:           KeyAppendInt(index, aKey);
    1:           generatedUniqueKey = PR_TRUE;
    1:         }
    1:       }
    1: 
    1:       // Append the control name
    1:       nsAutoString name;
    1:       aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::name, name);
    1:       KeyAppendString(name, aKey);
    1:     }
    1:   }
    1: 
    1:   if (!generatedUniqueKey) {
    1:     // Either we didn't have a form control or we aren't in an HTML document so
    1:     // we can't figure out form info.  First append a character that is not "d"
    1:     // or "f" to disambiguate from the case when we were a form control in an
    1:     // HTML document.
    1:     KeyAppendString(NS_LITERAL_CSTRING("o"), aKey);
    1:     
    1:     // Now start at aContent and append the indices of it and all its ancestors
    1:     // in their containers.  That should at least pin down its position in the
    1:     // DOM...
    1:     nsINode* parent = aContent->GetNodeParent();
    1:     nsINode* content = aContent;
    1:     while (parent) {
    1:       KeyAppendInt(parent->IndexOf(content), aKey);
    1:       content = parent;
    1:       parent = content->GetNodeParent();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // static
    1: nsresult
    1: nsContentUtils::NewURIWithDocumentCharset(nsIURI** aResult,
    1:                                           const nsAString& aSpec,
    1:                                           nsIDocument* aDocument,
    1:                                           nsIURI* aBaseURI)
    1: {
    1:   return NS_NewURI(aResult, aSpec,
    1:                    aDocument ? aDocument->GetDocumentCharacterSet().get() : nsnull,
    1:                    aBaseURI, sIOService);
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsContentUtils::BelongsInForm(nsIDOMHTMLFormElement *aForm,
    1:                               nsIContent *aContent)
    1: {
    1:   NS_PRECONDITION(aForm, "Must have a form");
    1:   NS_PRECONDITION(aContent, "Must have a content node");
    1: 
    1:   nsCOMPtr<nsIContent> form(do_QueryInterface(aForm));
    1: 
    1:   if (!form) {
    1:     NS_ERROR("This should not happen, form is not an nsIContent!");
    1: 
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (form == aContent) {
    1:     // A form does not belong inside itself, so we return false here
    1: 
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsIContent* content = aContent->GetParent();
    1: 
    1:   while (content) {
    1:     if (content == form) {
    1:       // aContent is contained within the form so we return true.
    1: 
    1:       return PR_TRUE;
    1:     }
    1: 
    1:     if (content->Tag() == nsGkAtoms::form &&
33329:         content->IsHTML()) {
    1:       // The child is contained within a form, but not the right form
    1:       // so we ignore it.
    1: 
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     content = content->GetParent();
    1:   }
    1: 
    1:   if (form->GetChildCount() > 0) {
    1:     // The form is a container but aContent wasn't inside the form,
    1:     // return false
    1: 
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // The form is a leaf and aContent wasn't inside any other form so
    1:   // we check whether the content comes after the form.  If it does,
    1:   // return true.  If it does not, then it couldn't have been inside
    1:   // the form in the HTML.
    1:   if (PositionIsBefore(form, aContent)) {
    1:     // We could be in this form!
    1:     // In the future, we may want to get document.forms, look at the
    1:     // form after aForm, and if aContent is after that form after
    1:     // aForm return false here....
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // static
    1: nsresult
    1: nsContentUtils::CheckQName(const nsAString& aQualifiedName,
    1:                            PRBool aNamespaceAware)
    1: {
    1:   nsIParserService *parserService = GetParserService();
    1:   NS_ENSURE_TRUE(parserService, NS_ERROR_FAILURE);
    1: 
    1:   const PRUnichar *colon;
    1:   return parserService->CheckQName(PromiseFlatString(aQualifiedName),
    1:                                    aNamespaceAware, &colon);
    1: }
    1: 
    1: //static
    1: nsresult
55138: nsContentUtils::SplitQName(const nsIContent* aNamespaceResolver,
    1:                            const nsAFlatString& aQName,
    1:                            PRInt32 *aNamespace, nsIAtom **aLocalName)
    1: {
    1:   nsIParserService* parserService = GetParserService();
    1:   NS_ENSURE_TRUE(parserService, NS_ERROR_FAILURE);
    1: 
    1:   const PRUnichar* colon;
    1:   nsresult rv = parserService->CheckQName(aQName, PR_TRUE, &colon);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (colon) {
    1:     const PRUnichar* end;
    1:     aQName.EndReading(end);
    1:     nsAutoString nameSpace;
41904:     rv = aNamespaceResolver->LookupNamespaceURI(Substring(aQName.get(), colon),
    1:                                                 nameSpace);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     *aNamespace = NameSpaceManager()->GetNameSpaceID(nameSpace);
    1:     if (*aNamespace == kNameSpaceID_Unknown)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     *aLocalName = NS_NewAtom(Substring(colon + 1, end));
    1:   }
    1:   else {
    1:     *aNamespace = kNameSpaceID_None;
    1:     *aLocalName = NS_NewAtom(aQName);
    1:   }
    1:   NS_ENSURE_TRUE(aLocalName, NS_ERROR_OUT_OF_MEMORY);
    1:   return NS_OK;
    1: }
    1: 
    1: // static
    1: nsresult
    1: nsContentUtils::GetNodeInfoFromQName(const nsAString& aNamespaceURI,
    1:                                      const nsAString& aQualifiedName,
    1:                                      nsNodeInfoManager* aNodeInfoManager,
    1:                                      nsINodeInfo** aNodeInfo)
    1: {
    1:   nsIParserService* parserService = GetParserService();
    1:   NS_ENSURE_TRUE(parserService, NS_ERROR_FAILURE);
    1: 
    1:   const nsAFlatString& qName = PromiseFlatString(aQualifiedName);
    1:   const PRUnichar* colon;
    1:   nsresult rv = parserService->CheckQName(qName, PR_TRUE, &colon);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt32 nsID;
    1:   sNameSpaceManager->RegisterNameSpace(aNamespaceURI, nsID);
    1:   if (colon) {
    1:     const PRUnichar* end;
    1:     qName.EndReading(end);
    1: 
    1:     nsCOMPtr<nsIAtom> prefix = do_GetAtom(Substring(qName.get(), colon));
    1: 
    1:     rv = aNodeInfoManager->GetNodeInfo(Substring(colon + 1, end), prefix,
    1:                                        nsID, aNodeInfo);
    1:   }
    1:   else {
    1:     rv = aNodeInfoManager->GetNodeInfo(aQualifiedName, nsnull, nsID,
    1:                                        aNodeInfo);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return nsContentUtils::IsValidNodeName((*aNodeInfo)->NameAtom(),
    1:                                          (*aNodeInfo)->GetPrefixAtom(),
    1:                                          (*aNodeInfo)->NamespaceID()) ?
    1:          NS_OK : NS_ERROR_DOM_NAMESPACE_ERR;
    1: }
    1: 
    1: // static
    1: void
    1: nsContentUtils::SplitExpatName(const PRUnichar *aExpatName, nsIAtom **aPrefix,
    1:                                nsIAtom **aLocalName, PRInt32* aNameSpaceID)
    1: {
    1:   /**
    1:    *  Expat can send the following:
    1:    *    localName
    1:    *    namespaceURI<separator>localName
    1:    *    namespaceURI<separator>localName<separator>prefix
    1:    *
    1:    *  and we use 0xFFFF for the <separator>.
    1:    *
    1:    */
    1: 
    1:   const PRUnichar *uriEnd = nsnull;
    1:   const PRUnichar *nameEnd = nsnull;
    1:   const PRUnichar *pos;
    1:   for (pos = aExpatName; *pos; ++pos) {
    1:     if (*pos == 0xFFFF) {
    1:       if (uriEnd) {
    1:         nameEnd = pos;
    1:       }
    1:       else {
    1:         uriEnd = pos;
    1:       }
    1:     }
    1:   }
    1: 
    1:   const PRUnichar *nameStart;
    1:   if (uriEnd) {
    1:     if (sNameSpaceManager) {
    1:       sNameSpaceManager->RegisterNameSpace(nsDependentSubstring(aExpatName,
    1:                                                                 uriEnd),
    1:                                            *aNameSpaceID);
    1:     }
    1:     else {
    1:       *aNameSpaceID = kNameSpaceID_Unknown;
    1:     }
    1: 
    1:     nameStart = (uriEnd + 1);
    1:     if (nameEnd)  {
    1:       const PRUnichar *prefixStart = nameEnd + 1;
43337:       *aPrefix = NS_NewAtom(Substring(prefixStart, pos));
    1:     }
    1:     else {
    1:       nameEnd = pos;
    1:       *aPrefix = nsnull;
    1:     }
    1:   }
    1:   else {
    1:     *aNameSpaceID = kNameSpaceID_None;
    1:     nameStart = aExpatName;
    1:     nameEnd = pos;
    1:     *aPrefix = nsnull;
    1:   }
43337:   *aLocalName = NS_NewAtom(Substring(nameStart, nameEnd));
    1: }
    1: 
    1: // static
 3439: nsPresContext*
55138: nsContentUtils::GetContextForContent(const nsIContent* aContent)
 3439: {
 3439:   nsIDocument* doc = aContent->GetCurrentDoc();
 3439:   if (doc) {
46225:     nsIPresShell *presShell = doc->GetShell();
 3439:     if (presShell) {
 3439:       return presShell->GetPresContext();
 3439:     }
 3439:   }
 3439:   return nsnull;
 3439: }
 3439: 
 3439: // static
    1: PRBool
    1: nsContentUtils::CanLoadImage(nsIURI* aURI, nsISupports* aContext,
    1:                              nsIDocument* aLoadingDocument,
 3088:                              nsIPrincipal* aLoadingPrincipal,
    1:                              PRInt16* aImageBlockingStatus)
    1: {
    1:   NS_PRECONDITION(aURI, "Must have a URI");
    1:   NS_PRECONDITION(aLoadingDocument, "Must have a document");
 3088:   NS_PRECONDITION(aLoadingPrincipal, "Must have a loading principal");
    1: 
    1:   nsresult rv;
    1: 
    1:   PRUint32 appType = nsIDocShell::APP_TYPE_UNKNOWN;
    1: 
    1:   {
    1:     nsCOMPtr<nsISupports> container = aLoadingDocument->GetContainer();
    1:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
    1:       do_QueryInterface(container);
    1: 
    1:     if (docShellTreeItem) {
    1:       nsCOMPtr<nsIDocShellTreeItem> root;
    1:       docShellTreeItem->GetRootTreeItem(getter_AddRefs(root));
    1: 
    1:       nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(root));
    1: 
    1:       if (!docShell || NS_FAILED(docShell->GetAppType(&appType))) {
    1:         appType = nsIDocShell::APP_TYPE_UNKNOWN;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (appType != nsIDocShell::APP_TYPE_EDITOR) {
    1:     // Editor apps get special treatment here, editors can load images
 3088:     // from anywhere.  This allows editor to insert images from file://
 3088:     // into documents that are being edited.
    1:     rv = sSecurityManager->
 3088:       CheckLoadURIWithPrincipal(aLoadingPrincipal, aURI,
    1:                                 nsIScriptSecurityManager::ALLOW_CHROME);
    1:     if (NS_FAILED(rv)) {
    1:       if (aImageBlockingStatus) {
    1:         // Reject the request itself, not all requests to the relevant
    1:         // server...
    1:         *aImageBlockingStatus = nsIContentPolicy::REJECT_REQUEST;
    1:       }
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   PRInt16 decision = nsIContentPolicy::ACCEPT;
    1: 
    1:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_IMAGE,
    1:                                  aURI,
 4367:                                  aLoadingPrincipal,
    1:                                  aContext,
    1:                                  EmptyCString(), //mime guess
    1:                                  nsnull,         //extra
    1:                                  &decision,
 4367:                                  GetContentPolicy(),
 4367:                                  sSecurityManager);
    1: 
    1:   if (aImageBlockingStatus) {
    1:     *aImageBlockingStatus =
    1:       NS_FAILED(rv) ? nsIContentPolicy::REJECT_REQUEST : decision;
    1:   }
    1:   return NS_FAILED(rv) ? PR_FALSE : NS_CP_ACCEPTED(decision);
    1: }
    1: 
    1: // static
30065: PRBool
30065: nsContentUtils::IsImageInCache(nsIURI* aURI)
30065: {
47160:     if (!sImgLoaderInitialized)
47160:         InitImgLoader();
47160: 
30065:     if (!sImgCache) return PR_FALSE;
30065: 
30065:     // If something unexpected happened we return false, otherwise if props
30065:     // is set, the image is cached and we return true
30065:     nsCOMPtr<nsIProperties> props;
30065:     nsresult rv = sImgCache->FindEntryProperties(aURI, getter_AddRefs(props));
30065:     return (NS_SUCCEEDED(rv) && props);
30065: }
30065: 
30065: // static
    1: nsresult
    1: nsContentUtils::LoadImage(nsIURI* aURI, nsIDocument* aLoadingDocument,
 3088:                           nsIPrincipal* aLoadingPrincipal, nsIURI* aReferrer,
 3088:                           imgIDecoderObserver* aObserver, PRInt32 aLoadFlags,
 3088:                           imgIRequest** aRequest)
    1: {
    1:   NS_PRECONDITION(aURI, "Must have a URI");
    1:   NS_PRECONDITION(aLoadingDocument, "Must have a document");
 3088:   NS_PRECONDITION(aLoadingPrincipal, "Must have a principal");
    1:   NS_PRECONDITION(aRequest, "Null out param");
    1: 
47288:   imgILoader* imgLoader = GetImgLoader();
47288:   if (!imgLoader) {
    1:     // nothing we can do here
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsILoadGroup> loadGroup = aLoadingDocument->GetDocumentLoadGroup();
    1:   NS_ASSERTION(loadGroup, "Could not get loadgroup; onload may fire too early");
    1: 
    1:   nsIURI *documentURI = aLoadingDocument->GetDocumentURI();
    1: 
42509:   // check for a Content Security Policy to pass down to the channel that
42509:   // will get created to load the image
42509:   nsCOMPtr<nsIChannelPolicy> channelPolicy;
42509:   nsCOMPtr<nsIContentSecurityPolicy> csp;
42509:   if (aLoadingPrincipal) {
42509:     nsresult rv = aLoadingPrincipal->GetCsp(getter_AddRefs(csp));
42509:     NS_ENSURE_SUCCESS(rv, rv);
42509:     if (csp) {
42509:       channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
42509:       channelPolicy->SetContentSecurityPolicy(csp);
42509:       channelPolicy->SetLoadType(nsIContentPolicy::TYPE_IMAGE);
42509:     }
42509:   }
42509:     
 7214:   // Make the URI immutable so people won't change it under us
 7214:   NS_TryToSetImmutable(aURI);
 7214: 
    1:   // XXXbz using "documentURI" for the initialDocumentURI is not quite
    1:   // right, but the best we can do here...
47288:   return imgLoader->LoadImage(aURI,                 /* uri to load */
    1:                               documentURI,          /* initialDocumentURI */
    1:                               aReferrer,            /* referrer */
    1:                               loadGroup,            /* loadgroup */
    1:                               aObserver,            /* imgIDecoderObserver */
    1:                               aLoadingDocument,     /* uniquification key */
    1:                               aLoadFlags,           /* load flags */
    1:                               nsnull,               /* cache key */
    1:                               nsnull,               /* existing request*/
42509:                               channelPolicy,        /* CSP info */
    1:                               aRequest);
    1: }
    1: 
    1: // static
30479: already_AddRefed<imgIContainer>
    1: nsContentUtils::GetImageFromContent(nsIImageLoadingContent* aContent,
    1:                                     imgIRequest **aRequest)
    1: {
    1:   if (aRequest) {
    1:     *aRequest = nsnull;
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(aContent, nsnull);
    1: 
    1:   nsCOMPtr<imgIRequest> imgRequest;
    1:   aContent->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                       getter_AddRefs(imgRequest));
    1:   if (!imgRequest) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsCOMPtr<imgIContainer> imgContainer;
    1:   imgRequest->GetImage(getter_AddRefs(imgContainer));
    1: 
    1:   if (!imgContainer) {
    1:     return nsnull;
    1:   }
    1: 
    1:   if (aRequest) {
    1:     imgRequest.swap(*aRequest);
    1:   }
    1: 
30479:   return imgContainer.forget();
    1: }
    1: 
    1: //static
35581: already_AddRefed<imgIRequest>
35581: nsContentUtils::GetStaticRequest(imgIRequest* aRequest)
35581: {
35581:   NS_ENSURE_TRUE(aRequest, nsnull);
35581:   nsCOMPtr<imgIRequest> retval;
35581:   aRequest->GetStaticRequest(getter_AddRefs(retval));
35581:   return retval.forget();
35581: }
35581: 
35581: // static
    1: PRBool
18985: nsContentUtils::ContentIsDraggable(nsIContent* aContent)
18985: {
18985:   nsCOMPtr<nsIDOMNSHTMLElement> htmlElement = do_QueryInterface(aContent);
18985:   if (htmlElement) {
18985:     PRBool draggable = PR_FALSE;
18985:     htmlElement->GetDraggable(&draggable);
18985:     if (draggable)
18985:       return PR_TRUE;
18985: 
18985:     if (aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::draggable,
18987:                               nsGkAtoms::_false, eIgnoreCase))
18985:       return PR_FALSE;
18985:   }
18985: 
18985:   // special handling for content area image and link dragging
18985:   return IsDraggableImage(aContent) || IsDraggableLink(aContent);
18985: }
18985: 
18985: // static
18985: PRBool
    1: nsContentUtils::IsDraggableImage(nsIContent* aContent)
    1: {
    1:   NS_PRECONDITION(aContent, "Must have content node to test");
    1: 
    1:   nsCOMPtr<nsIImageLoadingContent> imageContent(do_QueryInterface(aContent));
    1:   if (!imageContent) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<imgIRequest> imgRequest;
    1:   imageContent->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                            getter_AddRefs(imgRequest));
    1: 
    1:   // XXXbz It may be draggable even if the request resulted in an error.  Why?
    1:   // Not sure; that's what the old nsContentAreaDragDrop/nsFrame code did.
    1:   return imgRequest != nsnull;
    1: }
    1: 
    1: // static
    1: PRBool
55138: nsContentUtils::IsDraggableLink(const nsIContent* aContent) {
    1:   nsCOMPtr<nsIURI> absURI;
    1:   return aContent->IsLink(getter_AddRefs(absURI));
    1: }
    1: 
    1: // static
    1: nsAdoptingCString
    1: nsContentUtils::GetCharPref(const char *aPref)
    1: {
    1:   nsAdoptingCString result;
    1: 
    1:   if (sPrefBranch) {
    1:     sPrefBranch->GetCharPref(aPref, getter_Copies(result));
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: // static
    1: PRPackedBool
    1: nsContentUtils::GetBoolPref(const char *aPref, PRBool aDefault)
    1: {
    1:   PRBool result;
    1: 
    1:   if (!sPrefBranch ||
    1:       NS_FAILED(sPrefBranch->GetBoolPref(aPref, &result))) {
    1:     result = aDefault;
    1:   }
    1: 
    1:   return (PRPackedBool)result;
    1: }
    1: 
    1: // static
    1: PRInt32
    1: nsContentUtils::GetIntPref(const char *aPref, PRInt32 aDefault)
    1: {
    1:   PRInt32 result;
    1: 
    1:   if (!sPrefBranch ||
    1:       NS_FAILED(sPrefBranch->GetIntPref(aPref, &result))) {
    1:     result = aDefault;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: // static
    1: nsAdoptingString
    1: nsContentUtils::GetLocalizedStringPref(const char *aPref)
    1: {
    1:   nsAdoptingString result;
    1: 
    1:   if (sPrefBranch) {
    1:     nsCOMPtr<nsIPrefLocalizedString> prefLocalString;
    1:     sPrefBranch->GetComplexValue(aPref, NS_GET_IID(nsIPrefLocalizedString),
    1:                                  getter_AddRefs(prefLocalString));
    1:     if (prefLocalString) {
    1:       prefLocalString->GetData(getter_Copies(result));
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: // static
    1: nsAdoptingString
    1: nsContentUtils::GetStringPref(const char *aPref)
    1: {
    1:   nsAdoptingString result;
    1: 
    1:   if (sPrefBranch) {
    1:     nsCOMPtr<nsISupportsString> theString;
    1:     sPrefBranch->GetComplexValue(aPref, NS_GET_IID(nsISupportsString),
    1:                                  getter_AddRefs(theString));
    1:     if (theString) {
    1:       theString->ToString(getter_Copies(result));
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
48723: // RegisterPrefCallback/UnregisterPrefCallback are for backward compatiblity
48723: // with c-style observers.
37975: 
    1: // static
    1: void
    1: nsContentUtils::RegisterPrefCallback(const char *aPref,
    1:                                      PrefChangedFunc aCallback,
    1:                                      void * aClosure)
    1: {
37975:   if (sPrefBranch) {
48723:     if (!sPrefCallbackTable) {
48723:       sPrefCallbackTable = 
48723:         new nsRefPtrHashtable<nsPrefObserverHashKey, nsPrefOldCallback>();
48723:       sPrefCallbackTable->Init();
48723:     }
48723: 
48723:     nsPrefObserverHashKey hashKey(aPref, aCallback);
48723:     nsRefPtr<nsPrefOldCallback> callback;
48723:     sPrefCallbackTable->Get(&hashKey, getter_AddRefs(callback));
48723:     if (callback) {
48723:       callback->AppendClosure(aClosure);
48421:       return;
48421:     }
48421: 
48723:     callback = new nsPrefOldCallback(aPref, aCallback);
48723:     callback->AppendClosure(aClosure);
48421:     if (NS_SUCCEEDED(sPrefBranch->AddObserver(aPref, callback, PR_FALSE))) {
48723:       sPrefCallbackTable->Put(callback, callback);
37975:     }
37975:   }
    1: }
    1: 
    1: // static
    1: void
    1: nsContentUtils::UnregisterPrefCallback(const char *aPref,
    1:                                        PrefChangedFunc aCallback,
    1:                                        void * aClosure)
    1: {
37975:   if (sPrefBranch) {
48723:     if (!sPrefCallbackTable) {
37975:       return;
48723:     }
48723: 
48723:     nsPrefObserverHashKey hashKey(aPref, aCallback);
48723:     nsRefPtr<nsPrefOldCallback> callback;
48723:     sPrefCallbackTable->Get(&hashKey, getter_AddRefs(callback));
48723: 
48723:     if (callback) {
48723:       callback->RemoveClosure(aClosure);
48723:       if (callback->HasNoClosures()) {
48723:         // Delete the callback since its list of closures is empty.
48723:         sPrefCallbackTable->Remove(callback);
37975:       }
37975:     }
37975:   }
    1: }
    1: 
20261: static int
14747: BoolVarChanged(const char *aPref, void *aClosure)
14747: {
41408:   PrefCacheData* cache = static_cast<PrefCacheData*>(aClosure);
41408:   *((PRBool*)cache->cacheLocation) =
41408:     nsContentUtils::GetBoolPref(aPref, cache->defaultValueBool);
14747:   
14747:   return 0;
14747: }
14747: 
14747: void
14747: nsContentUtils::AddBoolPrefVarCache(const char *aPref,
41408:                                     PRBool* aCache,
41408:                                     PRBool aDefault)
41408: {
41408:   *aCache = GetBoolPref(aPref, aDefault);
41408:   PrefCacheData* data = new PrefCacheData;
41408:   data->cacheLocation = aCache;
41408:   data->defaultValueBool = aDefault;
41408:   sPrefCacheData->AppendElement(data);
41408:   RegisterPrefCallback(aPref, BoolVarChanged, data);
14747: }
    1: 
35593: static int
35593: IntVarChanged(const char *aPref, void *aClosure)
35593: {
41408:   PrefCacheData* cache = static_cast<PrefCacheData*>(aClosure);
41408:   *((PRInt32*)cache->cacheLocation) =
41408:     nsContentUtils::GetIntPref(aPref, cache->defaultValueInt);
35593:   
35593:   return 0;
35593: }
35593: 
35593: void
35593: nsContentUtils::AddIntPrefVarCache(const char *aPref,
41408:                                    PRInt32* aCache,
41408:                                    PRInt32 aDefault)
41408: {
41408:   *aCache = GetIntPref(aPref, aDefault);
41408:   PrefCacheData* data = new PrefCacheData;
41408:   data->cacheLocation = aCache;
41408:   data->defaultValueInt = aDefault;
41408:   sPrefCacheData->AppendElement(data);
41408:   RegisterPrefCallback(aPref, IntVarChanged, data);
35593: }
35593: 
51393: PRBool
51393: nsContentUtils::IsSitePermAllow(nsIURI* aURI, const char* aType)
51393: {
51393:   nsCOMPtr<nsIPermissionManager> permMgr =
51393:     do_GetService("@mozilla.org/permissionmanager;1");
51393:   NS_ENSURE_TRUE(permMgr, PR_FALSE);
51393: 
51393:   PRUint32 perm;
51393:   nsresult rv = permMgr->TestPermission(aURI, aType, &perm);
51393:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
51393:   
51393:   return perm == nsIPermissionManager::ALLOW_ACTION;
51393: }
51393: 
    1: static const char *gEventNames[] = {"event"};
    1: static const char *gSVGEventNames[] = {"evt"};
    1: // for b/w compat, the first name to onerror is still 'event', even though it
    1: // is actually the error message.  (pre this code, the other 2 were not avail.)
    1: // XXXmarkh - a quick lxr shows no affected code - should we correct this?
    1: static const char *gOnErrorNames[] = {"event", "source", "lineno"};
    1: 
    1: // static
    1: void
    1: nsContentUtils::GetEventArgNames(PRInt32 aNameSpaceID,
    1:                                  nsIAtom *aEventName,
    1:                                  PRUint32 *aArgCount,
    1:                                  const char*** aArgArray)
    1: {
    1: #define SET_EVENT_ARG_NAMES(names) \
    1:     *aArgCount = sizeof(names)/sizeof(names[0]); \
    1:     *aArgArray = names;
    1: 
    1:   // nsJSEventListener is what does the arg magic for onerror, and it does
    1:   // not seem to take the namespace into account.  So we let onerror in all
    1:   // namespaces get the 3 arg names.
    1:   if (aEventName == nsGkAtoms::onerror) {
    1:     SET_EVENT_ARG_NAMES(gOnErrorNames);
    1:   } else if (aNameSpaceID == kNameSpaceID_SVG) {
    1:     SET_EVENT_ARG_NAMES(gSVGEventNames);
    1:   } else {
    1:     SET_EVENT_ARG_NAMES(gEventNames);
    1:   }
    1: }
    1: 
 6475: nsCxPusher::nsCxPusher()
25038:     : mScriptIsRunning(PR_FALSE),
25038:       mPushedSomething(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsCxPusher::~nsCxPusher()
    1: {
    1:   Pop();
    1: }
    1: 
    1: static PRBool
    1: IsContextOnStack(nsIJSContextStack *aStack, JSContext *aContext)
    1: {
    1:   JSContext *ctx = nsnull;
    1:   aStack->Peek(&ctx);
    1:   if (!ctx)
    1:     return PR_FALSE;
    1:   if (ctx == aContext)
    1:     return PR_TRUE;
    1: 
    1:   nsCOMPtr<nsIJSContextStackIterator>
    1:     iterator(do_CreateInstance("@mozilla.org/js/xpc/ContextStackIterator;1"));
    1:   NS_ENSURE_TRUE(iterator, PR_FALSE);
    1: 
    1:   nsresult rv = iterator->Reset(aStack);
    1:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   PRBool done;
    1:   while (NS_SUCCEEDED(iterator->Done(&done)) && !done) {
    1:     rv = iterator->Prev(&ctx);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Broken iterator implementation");
    1: 
    1:     if (!ctx) {
    1:       continue;
    1:     }
    1: 
    1:     if (nsJSUtils::GetDynamicScriptContext(ctx) && ctx == aContext)
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
 6475: PRBool
20135: nsCxPusher::Push(nsPIDOMEventTarget *aCurrentTarget)
    1: {
25038:   if (mPushedSomething) {
    1:     NS_ERROR("Whaaa! No double pushing with nsCxPusher::Push()!");
    1: 
 6475:     return PR_FALSE;
    1:   }
    1: 
20135:   NS_ENSURE_TRUE(aCurrentTarget, PR_FALSE);
27700:   nsresult rv;
27700:   nsIScriptContext* scx =
27700:     aCurrentTarget->GetContextForEventHandlers(&rv);
16056:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
25047: 
25047:   if (!scx) {
42412:     // The target may have a special JS context for event handlers.
42412:     JSContext* cx = aCurrentTarget->GetJSContextForEventHandlers();
42412:     if (cx) {
42412:       DoPush(cx);
42412:     }
42412: 
25047:     // Nothing to do here, I guess.  Have to return true so that event firing
25047:     // will still work correctly even if there is no associated JSContext
25047:     return PR_TRUE;
25047:   }
25047: 
    1:   JSContext* cx = nsnull;
    1: 
13098:   if (scx) {
16056:     cx = static_cast<JSContext*>(scx->GetNativeContext());
16056:     // Bad, no JSContext from script context!
 6475:     NS_ENSURE_TRUE(cx, PR_FALSE);
    1:   }
    1: 
13098:   // If there's no native context in the script context it must be
13098:   // in the process or being torn down. We don't want to notify the
13098:   // script context about scripts having been evaluated in such a
13098:   // case, calling with a null cx is fine in that case.
13098:   return Push(cx);
13098: }
13098: 
13098: PRBool
28325: nsCxPusher::RePush(nsPIDOMEventTarget *aCurrentTarget)
28325: {
28325:   if (!mPushedSomething) {
28325:     return Push(aCurrentTarget);
28325:   }
28325: 
28325:   if (aCurrentTarget) {
28325:     nsresult rv;
28325:     nsIScriptContext* scx =
28325:       aCurrentTarget->GetContextForEventHandlers(&rv);
28325:     if (NS_FAILED(rv)) {
28325:       Pop();
28325:       return PR_FALSE;
28325:     }
28325: 
28325:     // If we have the same script context and native context is still
28325:     // alive, no need to Pop/Push.
28325:     if (scx && scx == mScx &&
28325:         scx->GetNativeContext()) {
28325:       return PR_TRUE;
28325:     }
28325:   }
28325: 
28325:   Pop();
28325:   return Push(aCurrentTarget);
28325: }
28325: 
28325: PRBool
42412: nsCxPusher::Push(JSContext *cx, PRBool aRequiresScriptContext)
13098: {
25038:   if (mPushedSomething) {
13098:     NS_ERROR("Whaaa! No double pushing with nsCxPusher::Push()!");
13098: 
13098:     return PR_FALSE;
13098:   }
13098: 
25038:   if (!cx) {
25038:     return PR_FALSE;
25038:   }
25038: 
25038:   // Hold a strong ref to the nsIScriptContext, just in case
25038:   // XXXbz do we really need to?  If we don't get one of these in Pop(), is
25038:   // that really a problem?  Or do we need to do this to effectively root |cx|?
13098:   mScx = GetScriptContextFromJSContext(cx);
42412:   if (!mScx && aRequiresScriptContext) {
13098:     // Should probably return PR_FALSE. See bug 416916.
13098:     return PR_TRUE;
13098:   }
13098: 
25038:   return DoPush(cx);
25038: }
25038: 
25038: PRBool
25038: nsCxPusher::DoPush(JSContext* cx)
25038: {
20135:   nsIThreadJSContextStack* stack = nsContentUtils::ThreadJSContextStack();
25038:   if (!stack) {
25038:     return PR_TRUE;
25038:   }
25038: 
25038:   if (cx && IsContextOnStack(stack, cx)) {
    1:     // If the context is on the stack, that means that a script
    1:     // is running at the moment in the context.
    1:     mScriptIsRunning = PR_TRUE;
    1:   }
    1: 
25038:   if (NS_FAILED(stack->Push(cx))) {
25038:     mScriptIsRunning = PR_FALSE;
25038:     mScx = nsnull;
25038:     return PR_FALSE;
25038:   }
25038: 
25038:   mPushedSomething = PR_TRUE;
25038: #ifdef DEBUG
25038:   mPushedContext = cx;
25038: #endif
 6475:   return PR_TRUE;
    1: }
    1: 
25038: PRBool
25038: nsCxPusher::PushNull()
25038: {
25038:   return DoPush(nsnull);
25038: }
25038: 
    1: void
    1: nsCxPusher::Pop()
    1: {
20135:   nsIThreadJSContextStack* stack = nsContentUtils::ThreadJSContextStack();
25038:   if (!mPushedSomething || !stack) {
    1:     mScx = nsnull;
25038:     mPushedSomething = PR_FALSE;
    1: 
    1:     NS_ASSERTION(!mScriptIsRunning, "Huh, this can't be happening, "
    1:                  "mScriptIsRunning can't be set here!");
    1: 
    1:     return;
    1:   }
    1: 
    1:   JSContext *unused;
20135:   stack->Pop(&unused);
    1: 
25038:   NS_ASSERTION(unused == mPushedContext, "Unexpected context popped");
25038: 
25038:   if (!mScriptIsRunning && mScx) {
    1:     // No JS is running in the context, but executing the event handler might have
    1:     // caused some JS to run. Tell the script context that it's done.
    1: 
    1:     mScx->ScriptEvaluated(PR_TRUE);
    1:   }
    1: 
    1:   mScx = nsnull;
    1:   mScriptIsRunning = PR_FALSE;
25038:   mPushedSomething = PR_FALSE;
    1: }
    1: 
    1: static const char gPropertiesFiles[nsContentUtils::PropertiesFile_COUNT][56] = {
    1:   // Must line up with the enum values in |PropertiesFile| enum.
    1:   "chrome://global/locale/css.properties",
    1:   "chrome://global/locale/xbl.properties",
    1:   "chrome://global/locale/xul.properties",
    1:   "chrome://global/locale/layout_errors.properties",
    1:   "chrome://global/locale/layout/HtmlForm.properties",
    1:   "chrome://global/locale/printing.properties",
    1:   "chrome://global/locale/dom/dom.properties",
    1: #ifdef MOZ_SVG
    1:   "chrome://global/locale/svg/svg.properties",
    1: #endif
    1:   "chrome://branding/locale/brand.properties",
    1:   "chrome://global/locale/commonDialogs.properties"
    1: };
    1: 
    1: /* static */ nsresult
    1: nsContentUtils::EnsureStringBundle(PropertiesFile aFile)
    1: {
    1:   if (!sStringBundles[aFile]) {
    1:     if (!sStringBundleService) {
    1:       nsresult rv =
    1:         CallGetService(NS_STRINGBUNDLE_CONTRACTID, &sStringBundleService);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     nsIStringBundle *bundle;
    1:     nsresult rv =
    1:       sStringBundleService->CreateBundle(gPropertiesFiles[aFile], &bundle);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     sStringBundles[aFile] = bundle; // transfer ownership
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult nsContentUtils::GetLocalizedString(PropertiesFile aFile,
    1:                                             const char* aKey,
    1:                                             nsXPIDLString& aResult)
    1: {
    1:   nsresult rv = EnsureStringBundle(aFile);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   nsIStringBundle *bundle = sStringBundles[aFile];
    1: 
    1:   return bundle->GetStringFromName(NS_ConvertASCIItoUTF16(aKey).get(),
    1:                                    getter_Copies(aResult));
    1: }
    1: 
    1: /* static */
    1: nsresult nsContentUtils::FormatLocalizedString(PropertiesFile aFile,
    1:                                                const char* aKey,
    1:                                                const PRUnichar **aParams,
    1:                                                PRUint32 aParamsLength,
    1:                                                nsXPIDLString& aResult)
    1: {
    1:   nsresult rv = EnsureStringBundle(aFile);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   nsIStringBundle *bundle = sStringBundles[aFile];
    1: 
    1:   return bundle->FormatStringFromName(NS_ConvertASCIItoUTF16(aKey).get(),
    1:                                       aParams, aParamsLength,
    1:                                       getter_Copies(aResult));
    1: }
    1: 
    1: /* static */ nsresult
    1: nsContentUtils::ReportToConsole(PropertiesFile aFile,
    1:                                 const char *aMessageName,
    1:                                 const PRUnichar **aParams,
    1:                                 PRUint32 aParamsLength,
    1:                                 nsIURI* aURI,
    1:                                 const nsAFlatString& aSourceLine,
    1:                                 PRUint32 aLineNumber,
    1:                                 PRUint32 aColumnNumber,
    1:                                 PRUint32 aErrorFlags,
    1:                                 const char *aCategory)
    1: {
    1:   NS_ASSERTION((aParams && aParamsLength) || (!aParams && !aParamsLength),
    1:                "Supply either both parameters and their number or no"
    1:                "parameters and 0.");
    1: 
    1:   nsresult rv;
    1:   if (!sConsoleService) { // only need to bother null-checking here
    1:     rv = CallGetService(NS_CONSOLESERVICE_CONTRACTID, &sConsoleService);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsXPIDLString errorText;
    1:   if (aParams) {
    1:     rv = FormatLocalizedString(aFile, aMessageName, aParams, aParamsLength,
    1:                                errorText);
    1:   }
    1:   else {
    1:     rv = GetLocalizedString(aFile, aMessageName, errorText);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCAutoString spec;
    1:   if (aURI)
    1:     aURI->GetSpec(spec);
    1: 
    1:   nsCOMPtr<nsIScriptError> errorObject =
    1:       do_CreateInstance(NS_SCRIPTERROR_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = errorObject->Init(errorText.get(),
    1:                          NS_ConvertUTF8toUTF16(spec).get(), // file name
    1:                          aSourceLine.get(),
    1:                          aLineNumber, aColumnNumber,
    1:                          aErrorFlags, aCategory);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return sConsoleService->LogMessage(errorObject);
    1: }
    1: 
    1: PRBool
    1: nsContentUtils::IsChromeDoc(nsIDocument *aDocument)
    1: {
    1:   if (!aDocument) {
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   nsCOMPtr<nsIPrincipal> systemPrincipal;
    1:   sSecurityManager->GetSystemPrincipal(getter_AddRefs(systemPrincipal));
    1: 
    1:   return aDocument->NodePrincipal() == systemPrincipal;
    1: }
    1: 
21636: PRBool
33860: nsContentUtils::IsChildOfSameType(nsIDocument* aDoc)
33860: {
33860:   nsCOMPtr<nsISupports> container = aDoc->GetContainer();
33860:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(container));
33860:   nsCOMPtr<nsIDocShellTreeItem> sameTypeParent;
33860:   if (docShellAsItem) {
33860:     docShellAsItem->GetSameTypeParent(getter_AddRefs(sameTypeParent));
33860:   }
33860:   return sameTypeParent != nsnull;
33860: }
33860: 
33860: PRBool
21636: nsContentUtils::GetWrapperSafeScriptFilename(nsIDocument *aDocument,
21636:                                              nsIURI *aURI,
21636:                                              nsACString& aScriptURI)
21636: {
21636:   PRBool scriptFileNameModified = PR_FALSE;
21636:   aURI->GetSpec(aScriptURI);
21636: 
21636:   if (IsChromeDoc(aDocument)) {
21636:     nsCOMPtr<nsIChromeRegistry> chromeReg =
42314:       mozilla::services::GetChromeRegistryService();
21636: 
21636:     if (!chromeReg) {
21636:       // If we're running w/o a chrome registry we won't modify any
21636:       // script file names.
21636: 
21636:       return scriptFileNameModified;
21636:     }
21636: 
21636:     PRBool docWrappersEnabled =
21636:       chromeReg->WrappersEnabled(aDocument->GetDocumentURI());
21636: 
21636:     PRBool uriWrappersEnabled = chromeReg->WrappersEnabled(aURI);
21636: 
21636:     nsIURI *docURI = aDocument->GetDocumentURI();
21636: 
21636:     if (docURI && docWrappersEnabled && !uriWrappersEnabled) {
21636:       // aURI is a script from a URL that doesn't get wrapper
21636:       // automation. aDocument is a chrome document that does get
21636:       // wrapper automation. Prepend the chrome document's URI
21636:       // followed by the string " -> " to the URI of the script we're
21636:       // loading here so that script in that URI gets the same wrapper
21636:       // automation that the chrome document expects.
21636:       nsCAutoString spec;
21636:       docURI->GetSpec(spec);
21636:       spec.AppendASCII(" -> ");
21636:       spec.Append(aScriptURI);
21636: 
21636:       aScriptURI = spec;
21636: 
21636:       scriptFileNameModified = PR_TRUE;
21636:     }
21636:   }
21636: 
21636:   return scriptFileNameModified;
21636: }
21636: 
    1: // static
19869: PRBool
19869: nsContentUtils::IsInChromeDocshell(nsIDocument *aDocument)
19869: {
19869:   if (!aDocument) {
19869:     return PR_FALSE;
19869:   }
19869: 
20078:   if (aDocument->GetDisplayDocument()) {
20078:     return IsInChromeDocshell(aDocument->GetDisplayDocument());
20078:   }
20078: 
19869:   nsCOMPtr<nsISupports> docContainer = aDocument->GetContainer();
19869:   nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryInterface(docContainer));
19869:   PRInt32 itemType = nsIDocShellTreeItem::typeContent;
19869:   if (docShell) {
19869:     docShell->GetItemType(&itemType);
19869:   }
19869: 
19869:   return itemType == nsIDocShellTreeItem::typeChrome;
19869: }
19869: 
19869: // static
    1: nsIContentPolicy*
    1: nsContentUtils::GetContentPolicy()
    1: {
    1:   if (!sTriedToGetContentPolicy) {
    1:     CallGetService(NS_CONTENTPOLICY_CONTRACTID, &sContentPolicyService);
    1:     // It's OK to not have a content policy service
    1:     sTriedToGetContentPolicy = PR_TRUE;
    1:   }
    1: 
    1:   return sContentPolicyService;
    1: }
    1: 
    1: // static
    1: nsresult
47403: nsAutoGCRoot::AddJSGCRoot(void* aPtr, RootType aRootType, const char* aName)
    1: {
    1:   if (!sJSScriptRuntime) {
    1:     nsresult rv = CallGetService("@mozilla.org/js/xpc/RuntimeService;1",
    1:                                  &sJSRuntimeService);
    1:     NS_ENSURE_TRUE(sJSRuntimeService, rv);
    1: 
    1:     sJSRuntimeService->GetRuntime(&sJSScriptRuntime);
    1:     if (!sJSScriptRuntime) {
    1:       NS_RELEASE(sJSRuntimeService);
    1:       NS_WARNING("Unable to get JS runtime from JS runtime service");
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1: 
    1:   PRBool ok;
47403:   if (aRootType == RootType_JSVal)
47403:     ok = ::js_AddRootRT(sJSScriptRuntime, (jsval *)aPtr, aName);
47403:   else
47403:     ok = ::js_AddGCThingRootRT(sJSScriptRuntime, (void **)aPtr, aName);
    1:   if (!ok) {
    1:     NS_WARNING("JS_AddNamedRootRT failed");
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult
47403: nsAutoGCRoot::RemoveJSGCRoot(void* aPtr, RootType aRootType)
    1: {
    1:   if (!sJSScriptRuntime) {
    1:     NS_NOTREACHED("Trying to remove a JS GC root when none were added");
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
47403:   if (aRootType == RootType_JSVal)
47403:     ::js_RemoveRoot(sJSScriptRuntime, (jsval *)aPtr);
47403:   else
47403:     ::js_RemoveRoot(sJSScriptRuntime, (JSObject **)aPtr);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // static
  265: PRBool
  265: nsContentUtils::IsEventAttributeName(nsIAtom* aName, PRInt32 aType)
  265: {
39100:   const PRUnichar* name = aName->GetUTF16String();
  265:   if (name[0] != 'o' || name[1] != 'n')
  265:     return PR_FALSE;
  265: 
  265:   EventNameMapping mapping;
44144:   return (sAtomEventTable->Get(aName, &mapping) && mapping.mType & aType);
  265: }
  265: 
  265: // static
  265: PRUint32
  265: nsContentUtils::GetEventId(nsIAtom* aName)
  265: {
  265:   EventNameMapping mapping;
44144:   if (sAtomEventTable->Get(aName, &mapping))
  265:     return mapping.mId;
  265: 
  265:   return NS_USER_DEFINED_EVENT;
  265: }
  265: 
44144: nsIAtom*
44144: nsContentUtils::GetEventIdAndAtom(const nsAString& aName,
44144:                                   PRUint32 aEventStruct,
44144:                                   PRUint32* aEventID)
44144: {
44144:   EventNameMapping mapping;
44144:   if (sStringEventTable->Get(aName, &mapping)) {
44144:     *aEventID =
44144:       mapping.mStructType == aEventStruct ? mapping.mId : NS_USER_DEFINED_EVENT;
44144:     return mapping.mAtom;
44144:   }
44144: 
44144:   // If we have cached lots of user defined event names, clear some of them.
44144:   if (sUserDefinedEvents->Count() > 127) {
44144:     while (sUserDefinedEvents->Count() > 64) {
44144:       nsIAtom* first = sUserDefinedEvents->ObjectAt(0);
44144:       sStringEventTable->Remove(Substring(nsDependentAtomString(first), 2));
44144:       sUserDefinedEvents->RemoveObjectAt(0);
44144:     }
44144:   }
44144: 
44144:   *aEventID = NS_USER_DEFINED_EVENT;
44144:   nsCOMPtr<nsIAtom> atom = do_GetAtom(NS_LITERAL_STRING("on") + aName);
44144:   sUserDefinedEvents->AppendObject(atom);
44144:   mapping.mAtom = atom;
44144:   mapping.mId = NS_USER_DEFINED_EVENT;
44144:   mapping.mType = EventNameType_None;
44144:   mapping.mStructType = NS_EVENT_NULL;
44144:   sStringEventTable->Put(aName, mapping);
44144:   return mapping.mAtom;
44144: }
44144: 
25812: static
25812: nsresult GetEventAndTarget(nsIDocument* aDoc, nsISupports* aTarget,
25812:                            const nsAString& aEventName,
25812:                            PRBool aCanBubble, PRBool aCancelable,
25812:                            nsIDOMEvent** aEvent,
25812:                            nsIDOMEventTarget** aTargetOut)
25812: {
25812:   nsCOMPtr<nsIDOMDocumentEvent> docEvent(do_QueryInterface(aDoc));
25812:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(aTarget));
25812:   NS_ENSURE_TRUE(docEvent && target, NS_ERROR_INVALID_ARG);
25812: 
25812:   nsCOMPtr<nsIDOMEvent> event;
25812:   nsresult rv =
25812:     docEvent->CreateEvent(NS_LITERAL_STRING("Events"), getter_AddRefs(event));
25812:   NS_ENSURE_SUCCESS(rv, rv);
25812: 
25812:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
25812:   NS_ENSURE_TRUE(privateEvent, NS_ERROR_FAILURE);
25812: 
25812:   rv = event->InitEvent(aEventName, aCanBubble, aCancelable);
25812:   NS_ENSURE_SUCCESS(rv, rv);
25812: 
25812:   rv = privateEvent->SetTrusted(PR_TRUE);
25812:   NS_ENSURE_SUCCESS(rv, rv);
25812: 
25812:   rv = privateEvent->SetTarget(target);
25812:   NS_ENSURE_SUCCESS(rv, rv);
25812: 
25812:   event.forget(aEvent);
25812:   target.forget(aTargetOut);
25812:   return NS_OK;
25812: }
25812: 
  265: // static
    1: nsresult
    1: nsContentUtils::DispatchTrustedEvent(nsIDocument* aDoc, nsISupports* aTarget,
    1:                                      const nsAString& aEventName,
    1:                                      PRBool aCanBubble, PRBool aCancelable,
    1:                                      PRBool *aDefaultAction)
    1: {
    1:   nsCOMPtr<nsIDOMEvent> event;
25812:   nsCOMPtr<nsIDOMEventTarget> target;
25812:   nsresult rv = GetEventAndTarget(aDoc, aTarget, aEventName, aCanBubble,
25812:                                   aCancelable, getter_AddRefs(event),
25812:                                   getter_AddRefs(target));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool dummy;
    1:   return target->DispatchEvent(event, aDefaultAction ? aDefaultAction : &dummy);
    1: }
    1: 
25379: nsresult
25379: nsContentUtils::DispatchChromeEvent(nsIDocument *aDoc,
25379:                                     nsISupports *aTarget,
25379:                                     const nsAString& aEventName,
25379:                                     PRBool aCanBubble, PRBool aCancelable,
25379:                                     PRBool *aDefaultAction)
25379: {
25379: 
25812:   nsCOMPtr<nsIDOMEvent> event;
25812:   nsCOMPtr<nsIDOMEventTarget> target;
25812:   nsresult rv = GetEventAndTarget(aDoc, aTarget, aEventName, aCanBubble,
25812:                                   aCancelable, getter_AddRefs(event),
25812:                                   getter_AddRefs(target));
25812:   NS_ENSURE_SUCCESS(rv, rv);
25812: 
25812:   NS_ASSERTION(aDoc, "GetEventAndTarget lied?");
26007:   if (!aDoc->GetWindow())
26007:     return NS_ERROR_INVALID_ARG;
42412: 
42412:   nsPIDOMEventTarget* piTarget = aDoc->GetWindow()->GetChromeEventHandler();
42412:   if (!piTarget)
26007:     return NS_ERROR_INVALID_ARG;
25379: 
42412:   nsCOMPtr<nsIFrameLoaderOwner> flo = do_QueryInterface(piTarget);
42412:   if (flo) {
42412:     nsRefPtr<nsFrameLoader> fl = flo->GetFrameLoader();
42412:     if (fl) {
42412:       nsPIDOMEventTarget* t = fl->GetTabChildGlobalAsEventTarget();
42412:       piTarget = t ? t : piTarget;
42412:     }
42412:   }
42412: 
25379:   nsEventStatus status = nsEventStatus_eIgnore;
42412:   rv = piTarget->DispatchDOMEvent(nsnull, event, nsnull, &status);
25379:   if (aDefaultAction) {
25379:     *aDefaultAction = (status != nsEventStatus_eConsumeNoDefault);
25379:   }
25379:   return rv;
25379: }
25379: 
    1: /* static */
42325: Element*
55138: nsContentUtils::MatchElementId(nsIContent *aContent, const nsIAtom* aId)
    1: {
42325:   for (nsIContent* cur = aContent;
42325:        cur;
42325:        cur = cur->GetNextNode(aContent)) {
42325:     if (aId == cur->GetID()) {
42325:       return cur->AsElement();
42325:     }
42325:   }
42325: 
42325:   return nsnull;
42325: }
42325: 
    1: /* static */
42325: Element *
    1: nsContentUtils::MatchElementId(nsIContent *aContent, const nsAString& aId)
    1: {
    1:   NS_PRECONDITION(!aId.IsEmpty(), "Will match random elements");
    1:   
    1:   // ID attrs are generally stored as atoms, so just atomize this up front
    1:   nsCOMPtr<nsIAtom> id(do_GetAtom(aId));
    1:   if (!id) {
    1:     // OOM, so just bail
    1:     return nsnull;
    1:   }
    1: 
    1:   return MatchElementId(aContent, id);
    1: }
    1: 
    1: // Convert the string from the given charset to Unicode.
    1: /* static */
    1: nsresult
    1: nsContentUtils::ConvertStringFromCharset(const nsACString& aCharset,
    1:                                          const nsACString& aInput,
    1:                                          nsAString& aOutput)
    1: {
    1:   if (aCharset.IsEmpty()) {
    1:     // Treat the string as UTF8
    1:     CopyUTF8toUTF16(aInput, aOutput);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsICharsetConverterManager> ccm =
    1:     do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIUnicodeDecoder> decoder;
    1:   rv = ccm->GetUnicodeDecoder(PromiseFlatCString(aCharset).get(),
    1:                               getter_AddRefs(decoder));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsPromiseFlatCString flatInput(aInput);
    1:   PRInt32 srcLen = flatInput.Length();
    1:   PRInt32 dstLen;
    1:   rv = decoder->GetMaxLength(flatInput.get(), srcLen, &dstLen);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   PRUnichar *ustr = (PRUnichar *)nsMemory::Alloc((dstLen + 1) *
    1:                                                  sizeof(PRUnichar));
    1:   if (!ustr)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   rv = decoder->Convert(flatInput.get(), &srcLen, ustr, &dstLen);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     ustr[dstLen] = 0;
    1:     aOutput.Assign(ustr, dstLen);
    1:   }
    1: 
    1:   nsMemory::Free(ustr);
    1:   return rv;
    1: }
    1: 
 9696: /* static */
 9696: PRBool
 9696: nsContentUtils::CheckForBOM(const unsigned char* aBuffer, PRUint32 aLength,
22438:                             nsACString& aCharset, PRBool *bigEndian)
 9696: {
 9696:   PRBool found = PR_TRUE;
 9696:   aCharset.Truncate();
 9696:   if (aLength >= 3 &&
 9696:       aBuffer[0] == 0xEF &&
 9696:       aBuffer[1] == 0xBB &&
 9696:       aBuffer[2] == 0xBF) {
 9696:     aCharset = "UTF-8";
 9696:   }
 9696:   else if (aLength >= 4 &&
 9696:            aBuffer[0] == 0x00 &&
 9696:            aBuffer[1] == 0x00 &&
 9696:            aBuffer[2] == 0xFE &&
 9696:            aBuffer[3] == 0xFF) {
22438:     aCharset = "UTF-32";
22438:     if (bigEndian)
22438:       *bigEndian = PR_TRUE;
 9696:   }
 9696:   else if (aLength >= 4 &&
 9696:            aBuffer[0] == 0xFF &&
 9696:            aBuffer[1] == 0xFE &&
 9696:            aBuffer[2] == 0x00 &&
 9696:            aBuffer[3] == 0x00) {
22438:     aCharset = "UTF-32";
22438:     if (bigEndian)
22438:       *bigEndian = PR_FALSE;
 9696:   }
 9696:   else if (aLength >= 2 &&
 9696:            aBuffer[0] == 0xFE && aBuffer[1] == 0xFF) {
22438:     aCharset = "UTF-16";
22438:     if (bigEndian)
22438:       *bigEndian = PR_TRUE;
 9696:   }
 9696:   else if (aLength >= 2 &&
 9696:            aBuffer[0] == 0xFF && aBuffer[1] == 0xFE) {
22438:     aCharset = "UTF-16";
22438:     if (bigEndian)
22438:       *bigEndian = PR_FALSE;
 9696:   } else {
 9696:     found = PR_FALSE;
 9696:   }
 9696: 
 9696:   return found;
 9696: }
 9696: 
    1: /* static */
    1: nsIContent*
    1: nsContentUtils::GetReferencedElement(nsIURI* aURI, nsIContent *aFromContent)
    1: {
15515:   nsReferencedElement ref;
15515:   ref.Reset(aFromContent, aURI);
15515:   return ref.get();
    1: }
    1: 
    1: /* static */
38651: void
38651: nsContentUtils::RegisterShutdownObserver(nsIObserver* aObserver)
38651: {
38651:   nsCOMPtr<nsIObserverService> observerService =
41540:     mozilla::services::GetObserverService();
38651:   if (observerService) {
38651:     observerService->AddObserver(aObserver, 
38651:                                  NS_XPCOM_SHUTDOWN_OBSERVER_ID, 
38651:                                  PR_FALSE);
38651:   }
38651: }
38651: 
38651: /* static */
38651: void
38651: nsContentUtils::UnregisterShutdownObserver(nsIObserver* aObserver)
38651: {
38651:   nsCOMPtr<nsIObserverService> observerService =
41540:     mozilla::services::GetObserverService();
38651:   if (observerService) {
38651:     observerService->RemoveObserver(aObserver, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
38651:   }
38651: }
38651: 
38651: /* static */
    1: PRBool
55138: nsContentUtils::HasNonEmptyAttr(const nsIContent* aContent, PRInt32 aNameSpaceID,
    1:                                 nsIAtom* aName)
    1: {
    1:   static nsIContent::AttrValuesArray strings[] = {&nsGkAtoms::_empty, nsnull};
    1:   return aContent->FindAttrValueIn(aNameSpaceID, aName, strings, eCaseMatters)
    1:     == nsIContent::ATTR_VALUE_NO_MATCH;
    1: }
    1: 
    1: /* static */
    1: PRBool
    1: nsContentUtils::HasMutationListeners(nsINode* aNode,
 3137:                                      PRUint32 aType,
 3137:                                      nsINode* aTargetForSubtreeModified)
    1: {
    1:   nsIDocument* doc = aNode->GetOwnerDoc();
    1:   if (!doc) {
    1:     return PR_FALSE;
    1:   }
    1: 
41743:   NS_ASSERTION((aNode->IsNodeOfType(nsINode::eCONTENT) &&
41743:                 static_cast<nsIContent*>(aNode)->
41743:                   IsInNativeAnonymousSubtree()) ||
41743:                sScriptBlockerCount == sRemovableScriptBlockerCount,
41743:                "Want to fire mutation events, but it's not safe");
41743: 
    1:   // global object will be null for documents that don't have windows.
22210:   nsPIDOMWindow* window = doc->GetInnerWindow();
14239:   // This relies on nsEventListenerManager::AddEventListener, which sets
14239:   // all mutation bits when there is a listener for DOMSubtreeModified event.
    1:   if (window && !window->HasMutationListeners(aType)) {
    1:     return PR_FALSE;
    1:   }
    1: 
14239:   if (aNode->IsNodeOfType(nsINode::eCONTENT) &&
14239:       static_cast<nsIContent*>(aNode)->IsInNativeAnonymousSubtree()) {
14239:     return PR_FALSE;
14239:   }
14239: 
14239:   doc->MayDispatchMutationEvent(aTargetForSubtreeModified);
14239: 
    1:   // If we have a window, we can check it for mutation listeners now.
24481:   if (aNode->IsInDoc()) {
 1418:     nsCOMPtr<nsPIDOMEventTarget> piTarget(do_QueryInterface(window));
 1418:     if (piTarget) {
29474:       nsIEventListenerManager* manager = piTarget->GetListenerManager(PR_FALSE);
    1:       if (manager) {
    1:         PRBool hasListeners = PR_FALSE;
    1:         manager->HasMutationListeners(&hasListeners);
    1:         if (hasListeners) {
    1:           return PR_TRUE;
    1:         }
    1:       }
    1:     }
24481:   }
    1: 
    1:   // If we have a window, we know a mutation listener is registered, but it
    1:   // might not be in our chain.  If we don't have a window, we might have a
    1:   // mutation listener.  Check quickly to see.
    1:   while (aNode) {
29474:     nsIEventListenerManager* manager = aNode->GetListenerManager(PR_FALSE);
    1:     if (manager) {
    1:       PRBool hasListeners = PR_FALSE;
    1:       manager->HasMutationListeners(&hasListeners);
    1:       if (hasListeners) {
    1:         return PR_TRUE;
    1:       }
    1:     }
 5141: 
 5141:     if (aNode->IsNodeOfType(nsINode::eCONTENT)) {
 5141:       nsIContent* content = static_cast<nsIContent*>(aNode);
 5141:       nsIContent* insertionParent =
 5141:         doc->BindingManager()->GetInsertionParent(content);
 5141:       if (insertionParent) {
 5141:         aNode = insertionParent;
 5141:         continue;
 5141:       }
 5141:     }
    1:     aNode = aNode->GetNodeParent();
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: /* static */
    1: void
    1: nsContentUtils::TraverseListenerManager(nsINode *aNode,
    1:                                         nsCycleCollectionTraversalCallback &cb)
    1: {
    1:   if (!sEventListenerManagersHash.ops) {
    1:     // We're already shut down, just return.
    1:     return;
    1:   }
    1: 
    1:   EventListenerManagerMapEntry *entry =
 3233:     static_cast<EventListenerManagerMapEntry *>
 3233:                (PL_DHashTableOperate(&sEventListenerManagersHash, aNode,
    1:                                         PL_DHASH_LOOKUP));
    1:   if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via hash] mListenerManager");
    1:     cb.NoteXPCOMChild(entry->mListenerManager);
    1:   }
    1: }
    1: 
29474: nsIEventListenerManager*
    1: nsContentUtils::GetListenerManager(nsINode *aNode,
29474:                                    PRBool aCreateIfNotFound)
    1: {
    1:   if (!aCreateIfNotFound && !aNode->HasFlag(NODE_HAS_LISTENERMANAGER)) {
29474:     return nsnull;
    1:   }
    1:   
    1:   if (!sEventListenerManagersHash.ops) {
    1:     // We're already shut down, don't bother creating an event listener
    1:     // manager.
    1: 
29474:     return nsnull;
    1:   }
    1: 
    1:   if (!aCreateIfNotFound) {
    1:     EventListenerManagerMapEntry *entry =
 3233:       static_cast<EventListenerManagerMapEntry *>
 3233:                  (PL_DHashTableOperate(&sEventListenerManagersHash, aNode,
    1:                                           PL_DHASH_LOOKUP));
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
29474:       return entry->mListenerManager;
29474:     }
29474:     return nsnull;
    1:   }
    1: 
    1:   EventListenerManagerMapEntry *entry =
 3233:     static_cast<EventListenerManagerMapEntry *>
 3233:                (PL_DHashTableOperate(&sEventListenerManagersHash, aNode,
    1:                                         PL_DHASH_ADD));
    1: 
    1:   if (!entry) {
29474:     return nsnull;
    1:   }
    1: 
    1:   if (!entry->mListenerManager) {
    1:     nsresult rv =
    1:       NS_NewEventListenerManager(getter_AddRefs(entry->mListenerManager));
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       PL_DHashTableRawRemove(&sEventListenerManagersHash, entry);
    1: 
29474:       return nsnull;
    1:     }
    1: 
    1:     entry->mListenerManager->SetListenerTarget(aNode);
    1: 
    1:     aNode->SetFlags(NODE_HAS_LISTENERMANAGER);
    1:   }
    1: 
29474:   return entry->mListenerManager;
    1: }
    1: 
    1: /* static */
    1: void
    1: nsContentUtils::RemoveListenerManager(nsINode *aNode)
    1: {
    1:   if (sEventListenerManagersHash.ops) {
    1:     EventListenerManagerMapEntry *entry =
 3233:       static_cast<EventListenerManagerMapEntry *>
 3233:                  (PL_DHashTableOperate(&sEventListenerManagersHash, aNode,
    1:                                           PL_DHASH_LOOKUP));
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:       nsCOMPtr<nsIEventListenerManager> listenerManager;
    1:       listenerManager.swap(entry->mListenerManager);
    1:       // Remove the entry and *then* do operations that could cause further
    1:       // modification of sEventListenerManagersHash.  See bug 334177.
    1:       PL_DHashTableRawRemove(&sEventListenerManagersHash, entry);
    1:       if (listenerManager) {
    1:         listenerManager->Disconnect();
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: /* static */
    1: PRBool
    1: nsContentUtils::IsValidNodeName(nsIAtom *aLocalName, nsIAtom *aPrefix,
    1:                                 PRInt32 aNamespaceID)
    1: {
    1:   if (aNamespaceID == kNameSpaceID_Unknown) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   if (!aPrefix) {
    1:     // If the prefix is null, then either the QName must be xmlns or the
    1:     // namespace must not be XMLNS.
    1:     return (aLocalName == nsGkAtoms::xmlns) ==
    1:            (aNamespaceID == kNameSpaceID_XMLNS);
    1:   }
    1: 
    1:   // If the prefix is non-null then the namespace must not be null.
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // If the namespace is the XMLNS namespace then the prefix must be xmlns,
    1:   // but the localname must not be xmlns.
    1:   if (aNamespaceID == kNameSpaceID_XMLNS) {
    1:     return aPrefix == nsGkAtoms::xmlns && aLocalName != nsGkAtoms::xmlns;
    1:   }
    1: 
    1:   // If the namespace is not the XMLNS namespace then the prefix must not be
    1:   // xmlns.
    1:   // If the namespace is the XML namespace then the prefix can be anything.
    1:   // If the namespace is not the XML namespace then the prefix must not be xml.
    1:   return aPrefix != nsGkAtoms::xmlns &&
    1:          (aNamespaceID == kNameSpaceID_XML || aPrefix != nsGkAtoms::xml);
    1: }
    1: 
    1: /* static */
    1: nsresult
41240: nsContentUtils::CreateContextualFragment(nsINode* aContextNode,
    1:                                          const nsAString& aFragment,
12676:                                          PRBool aWillOwnFragment,
    1:                                          nsIDOMDocumentFragment** aReturn)
    1: {
41240:   *aReturn = nsnull;
    1:   NS_ENSURE_ARG(aContextNode);
    1: 
    1:   nsresult rv;
    1: 
    1:   // If we don't have a document here, we can't get the right security context
    1:   // for compiling event handlers... so just bail out.
41240:   nsCOMPtr<nsIDocument> document = aContextNode->GetOwnerDoc();
    1:   NS_ENSURE_TRUE(document, NS_ERROR_NOT_AVAILABLE);
    1: 
41240:   PRBool isHTML = document->IsHTML();
41240: #ifdef DEBUG
41240:   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(document);
41240:   NS_ASSERTION(!isHTML || htmlDoc, "Should have HTMLDocument here!");
41240: #endif
30334: 
30334:   if (isHTML && nsHtml5Module::sEnabled) {
29805:     // See if the document has a cached fragment parser. nsHTMLDocument is the
29805:     // only one that should really have one at the moment.
29805:     nsCOMPtr<nsIParser> parser = document->GetFragmentParser();
29805:     if (parser) {
29805:       // Get the parser ready to use.
29805:       parser->Reset();
29805:     }
29805:     else {
29805:       // Create a new parser for this operation.
29805:       parser = nsHtml5Module::NewHtml5Parser();
29805:       if (!parser) {
29805:         return NS_ERROR_OUT_OF_MEMORY;
29805:       }
29805:     }
29805:     nsCOMPtr<nsIDOMDocumentFragment> frag;
29805:     rv = NS_NewDocumentFragment(getter_AddRefs(frag), document->NodeInfoManager());
29805:     NS_ENSURE_SUCCESS(rv, rv);
29805:     
29805:     nsCOMPtr<nsIContent> contextAsContent = do_QueryInterface(aContextNode);
41636:     if (contextAsContent && !contextAsContent->IsElement()) {
29805:       contextAsContent = contextAsContent->GetParent();
41636:       if (contextAsContent && !contextAsContent->IsElement()) {
29805:         // can this even happen?
29805:         contextAsContent = nsnull;
29805:       }
29805:     }
29805:     
57561:     nsAHtml5FragmentParser* asFragmentParser =
57561:         static_cast<nsAHtml5FragmentParser*> (parser.get());
48066:     nsCOMPtr<nsIContent> fragment = do_QueryInterface(frag);
52072:     if (contextAsContent &&
52072:         !(nsGkAtoms::html == contextAsContent->Tag() &&
52072:           contextAsContent->IsHTML())) {
57561:       asFragmentParser->ParseHtml5Fragment(aFragment,
48066:                                            fragment,
29805:                                            contextAsContent->Tag(),
29805:                                            contextAsContent->GetNameSpaceID(),
57561:                                            (document->GetCompatibilityMode() ==
57561:                                                eCompatibility_NavQuirks),
57328:                                            PR_FALSE);
29805:     } else {
57561:       asFragmentParser->ParseHtml5Fragment(aFragment,
48066:                                            fragment,
29805:                                            nsGkAtoms::body,
29805:                                            kNameSpaceID_XHTML,
57561:                                            (document->GetCompatibilityMode() ==
57561:                                                eCompatibility_NavQuirks),
57328:                                            PR_FALSE);
29805:     }
29805:   
41240:     frag.swap(*aReturn);
41066:     document->SetFragmentParser(parser);
29805:     return NS_OK;
29805:   }
29805: 
14205:   nsAutoTArray<nsString, 32> tagStack;
 7883:   nsAutoString uriStr, nameStr;
11350:   nsCOMPtr<nsIContent> content = do_QueryInterface(aContextNode);
 9429:   // just in case we have a text node
41636:   if (content && !content->IsElement())
 9429:     content = content->GetParent();
 9429: 
41636:   while (content && content->IsElement()) {
14205:     nsString& tagName = *tagStack.AppendElement();
 7883:     NS_ENSURE_TRUE(&tagName, NS_ERROR_OUT_OF_MEMORY);
 7883: 
 7883:     content->NodeInfo()->GetQualifiedName(tagName);
    1: 
    1:     // see if we need to add xmlns declarations
    1:     PRUint32 count = content->GetAttrCount();
    1:     PRBool setDefaultNamespace = PR_FALSE;
    1:     if (count > 0) {
    1:       PRUint32 index;
    1: 
    1:       for (index = 0; index < count; index++) {
    1:         const nsAttrName* name = content->GetAttrNameAt(index);
    1:         if (name->NamespaceEquals(kNameSpaceID_XMLNS)) {
    1:           content->GetAttr(kNameSpaceID_XMLNS, name->LocalName(), uriStr);
    1: 
    1:           // really want something like nsXMLContentSerializer::SerializeAttr
    1:           tagName.Append(NS_LITERAL_STRING(" xmlns")); // space important
    1:           if (name->GetPrefix()) {
    1:             tagName.Append(PRUnichar(':'));
    1:             name->LocalName()->ToString(nameStr);
    1:             tagName.Append(nameStr);
    1:           } else {
    1:             setDefaultNamespace = PR_TRUE;
    1:           }
    1:           tagName.Append(NS_LITERAL_STRING("=\"") + uriStr +
    1:             NS_LITERAL_STRING("\""));
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (!setDefaultNamespace) {
    1:       nsINodeInfo* info = content->NodeInfo();
    1:       if (!info->GetPrefixAtom() &&
    1:           info->NamespaceID() != kNameSpaceID_None) {
    1:         // We have no namespace prefix, but have a namespace ID.  Push
    1:         // default namespace attr in, so that our kids will be in our
    1:         // namespace.
 7883:         info->GetNamespaceURI(uriStr);
 7883:         tagName.Append(NS_LITERAL_STRING(" xmlns=\"") + uriStr +
    1:                        NS_LITERAL_STRING("\""));
    1:       }
    1:     }
    1: 
 7883:     content = content->GetParent();
 7883:   }
 7883: 
    1:   nsCAutoString contentType;
    1:   nsAutoString buf;
    1:   document->GetContentType(buf);
    1:   LossyCopyUTF16toASCII(buf, contentType);
11423: 
11423:   // See if the document has a cached fragment parser. nsHTMLDocument is the
11423:   // only one that should really have one at the moment.
11423:   nsCOMPtr<nsIParser> parser = document->GetFragmentParser();
11423:   if (parser) {
11423:     // Get the parser ready to use.
11423:     parser->Reset();
11423:   }
11423:   else {
11423:     // Create a new parser for this operation.
11423:     parser = do_CreateInstance(kCParserCID, &rv);
11423:     NS_ENSURE_SUCCESS(rv, rv);
11423:   }
11423: 
11423:   // See if the parser already has a content sink that we can reuse.
    1:   nsCOMPtr<nsIFragmentContentSink> sink;
11423:   nsCOMPtr<nsIContentSink> contentsink = parser->GetContentSink();
11423:   if (contentsink) {
11423:     // Make sure it's the correct type.
30334:     if (isHTML) {
11423:       nsCOMPtr<nsIHTMLContentSink> htmlsink = do_QueryInterface(contentsink);
11423:       sink = do_QueryInterface(htmlsink);
11423:     }
11423:     else {
11423:       nsCOMPtr<nsIXMLContentSink> xmlsink = do_QueryInterface(contentsink);
11423:       sink = do_QueryInterface(xmlsink);
11423:     }
11423:   }
11423: 
11423:   if (!sink) {
11423:     // Either there was no cached content sink or it was the wrong type. Make a
11423:     // new one.
30334:     if (isHTML) {
    1:       rv = NS_NewHTMLFragmentContentSink(getter_AddRefs(sink));
    1:     } else {
    1:       rv = NS_NewXMLFragmentContentSink(getter_AddRefs(sink));
    1:     }
 7883:     NS_ENSURE_SUCCESS(rv, rv);
 7883: 
11423:     contentsink = do_QueryInterface(sink);
11423:     NS_ASSERTION(contentsink, "Sink doesn't QI to nsIContentSink!");
11423: 
11423:     parser->SetContentSink(contentsink);
11423:   }
11423: 
    1:   sink->SetTargetDocument(document);
    1: 
    1:   nsDTDMode mode = eDTDMode_autodetect;
    1:   switch (document->GetCompatibilityMode()) {
    1:     case eCompatibility_NavQuirks:
    1:       mode = eDTDMode_quirks;
    1:       break;
    1:     case eCompatibility_AlmostStandards:
    1:       mode = eDTDMode_almost_standards;
    1:       break;
    1:     case eCompatibility_FullStandards:
    1:       mode = eDTDMode_full_standards;
    1:       break;
    1:     default:
    1:       NS_NOTREACHED("unknown mode");
    1:       break;
    1:   }
 7883: 
    1:   rv = parser->ParseFragment(aFragment, nsnull, tagStack,
30334:                              !isHTML, contentType, mode);
    1:   if (NS_SUCCEEDED(rv)) {
12676:     rv = sink->GetFragment(aWillOwnFragment, aReturn);
    1:   }
    1: 
11423:   document->SetFragmentParser(parser);
11423: 
23817:   return rv;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsContentUtils::CreateDocument(const nsAString& aNamespaceURI, 
    1:                                const nsAString& aQualifiedName, 
    1:                                nsIDOMDocumentType* aDoctype,
    1:                                nsIURI* aDocumentURI, nsIURI* aBaseURI,
    1:                                nsIPrincipal* aPrincipal,
 6475:                                nsIScriptGlobalObject* aEventObject,
    1:                                nsIDOMDocument** aResult)
    1: {
    1:   nsresult rv = NS_NewDOMDocument(aResult, aNamespaceURI, aQualifiedName,
 6475:                                   aDoctype, aDocumentURI, aBaseURI, aPrincipal,
 6475:                                   PR_TRUE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDocument> document = do_QueryInterface(*aResult);
 6475:   document->SetScriptHandlingObject(aEventObject);
23639:   
23639:   // created documents are immediately "complete" (ready to use)
23639:   document->SetReadyStateInternal(nsIDocument::READYSTATE_COMPLETE);
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsContentUtils::SetNodeTextContent(nsIContent* aContent,
    1:                                    const nsAString& aValue,
    1:                                    PRBool aTryReuse)
    1: {
    1:   // Might as well stick a batch around this since we're performing several
    1:   // mutations.
    1:   mozAutoDocUpdate updateBatch(aContent->GetCurrentDoc(),
    1:     UPDATE_CONTENT_MODEL, PR_TRUE);
    1: 
    1:   PRUint32 childCount = aContent->GetChildCount();
    1: 
    1:   if (aTryReuse && !aValue.IsEmpty()) {
    1:     PRUint32 removeIndex = 0;
    1: 
    1:     // i is unsigned, so i >= is always true
    1:     for (PRUint32 i = 0; i < childCount; ++i) {
    1:       nsIContent* child = aContent->GetChildAt(removeIndex);
28374:       if (removeIndex == 0 && child && child->IsNodeOfType(nsINode::eTEXT)) {
    1:         nsresult rv = child->SetText(aValue, PR_TRUE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         removeIndex = 1;
    1:       }
    1:       else {
    1:         aContent->RemoveChildAt(removeIndex, PR_TRUE);
    1:       }
    1:     }
    1:     
    1:     if (removeIndex == 1) {
    1:       return NS_OK;
    1:     }
    1:   }
    1:   else {
    1:     // i is unsigned, so i >= is always true
    1:     for (PRUint32 i = childCount; i-- != 0; ) {
    1:       aContent->RemoveChildAt(i, PR_TRUE);
    1:     }
    1:   }
    1: 
    1:   if (aValue.IsEmpty()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> textContent;
    1:   nsresult rv = NS_NewTextNode(getter_AddRefs(textContent),
    1:                                aContent->NodeInfo()->NodeInfoManager());
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   textContent->SetText(aValue, PR_TRUE);
    1: 
    1:   return aContent->AppendChildTo(textContent, PR_TRUE);
    1: }
    1: 
    1: static void AppendNodeTextContentsRecurse(nsINode* aNode, nsAString& aResult)
    1: {
    1:   nsIContent* child;
    1:   PRUint32 i;
    1:   for (i = 0; (child = aNode->GetChildAt(i)); ++i) {
41636:     if (child->IsElement()) {
    1:       AppendNodeTextContentsRecurse(child, aResult);
    1:     }
    1:     else if (child->IsNodeOfType(nsINode::eTEXT)) {
    1:       child->AppendTextTo(aResult);
    1:     }
    1:   }
    1: }
    1: 
    1: /* static */
    1: void
    1: nsContentUtils::AppendNodeTextContent(nsINode* aNode, PRBool aDeep,
    1:                                       nsAString& aResult)
    1: {
    1:   if (aNode->IsNodeOfType(nsINode::eTEXT)) {
 3233:     static_cast<nsIContent*>(aNode)->AppendTextTo(aResult);
    1:   }
    1:   else if (aDeep) {
    1:     AppendNodeTextContentsRecurse(aNode, aResult);
    1:   }
    1:   else {
    1:     nsIContent* child;
    1:     PRUint32 i;
    1:     for (i = 0; (child = aNode->GetChildAt(i)); ++i) {
    1:       if (child->IsNodeOfType(nsINode::eTEXT)) {
    1:         child->AppendTextTo(aResult);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsContentUtils::HasNonEmptyTextContent(nsINode* aNode)
    1: {
    1:   nsIContent* child;
    1:   PRUint32 i;
    1:   for (i = 0; (child = aNode->GetChildAt(i)); ++i) {
    1:     if (child->IsNodeOfType(nsINode::eTEXT) &&
    1:         child->TextLength() > 0) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: /* static */
    1: PRBool
55138: nsContentUtils::IsInSameAnonymousTree(const nsINode* aNode,
55138:                                       const nsIContent* aContent)
    1: {
    1:   NS_PRECONDITION(aNode,
    1:                   "Must have a node to work with");
    1:   NS_PRECONDITION(aContent,
    1:                   "Must have a content to work with");
    1:   
    1:   if (!aNode->IsNodeOfType(nsINode::eCONTENT)) {
    1:     /**
    1:      * The root isn't an nsIContent, so it's a document or attribute.  The only
    1:      * nodes in the same anonymous subtree as it will have a null
    1:      * bindingParent.
    1:      *
    1:      * XXXbz strictly speaking, that's not true for attribute nodes.
    1:      */
    1:     return aContent->GetBindingParent() == nsnull;
    1:   }
    1: 
55138:   return static_cast<const nsIContent*>(aNode)->GetBindingParent() ==
    1:          aContent->GetBindingParent();
    1:  
    1: }
    1: 
28469: class AnonymousContentDestroyer : public nsRunnable {
28469: public:
28469:   AnonymousContentDestroyer(nsCOMPtr<nsIContent>* aContent) {
28469:     mContent.swap(*aContent);
28469:     mParent = mContent->GetParent();
28469:     mDoc = mContent->GetOwnerDoc();
28469:   }
28469:   NS_IMETHOD Run() {
28469:     mContent->UnbindFromTree();
28469:     return NS_OK;
28469:   }
28469: private:
28469:   nsCOMPtr<nsIContent> mContent;
28469:   // Hold strong refs to the parent content and document so that they
28469:   // don't die unexpectedly
28469:   nsCOMPtr<nsIDocument> mDoc;
28469:   nsCOMPtr<nsIContent> mParent;
28469: };
28469: 
    1: /* static */
    1: void
    1: nsContentUtils::DestroyAnonymousContent(nsCOMPtr<nsIContent>* aContent)
    1: {
    1:   if (*aContent) {
28469:     AddScriptRunner(new AnonymousContentDestroyer(aContent));
    1:   }
    1: }
    1: 
    1: /* static */
    1: nsIDOMScriptObjectFactory*
    1: nsContentUtils::GetDOMScriptObjectFactory()
    1: {
    1:   if (!sDOMScriptObjectFactory) {
    1:     static NS_DEFINE_CID(kDOMScriptObjectFactoryCID,
    1:                          NS_DOM_SCRIPT_OBJECT_FACTORY_CID);
    1: 
    1:     CallGetService(kDOMScriptObjectFactoryCID, &sDOMScriptObjectFactory);
    1:   }
    1: 
    1:   return sDOMScriptObjectFactory;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsContentUtils::HoldScriptObject(PRUint32 aLangID, void *aObject)
    1: {
 2956:   NS_ASSERTION(aObject, "unexpected null object");
 7230:   NS_ASSERTION(aLangID != nsIProgrammingLanguage::JAVASCRIPT,
 7230:                "Should use HoldJSObjects.");
    1:   nsresult rv;
    1: 
    1:   PRUint32 langIndex = NS_STID_INDEX(aLangID);
    1:   nsIScriptRuntime *runtime = sScriptRuntimes[langIndex];
    1:   if (!runtime) {
    1:     nsIDOMScriptObjectFactory *factory = GetDOMScriptObjectFactory();
    1:     NS_ENSURE_TRUE(factory, NS_ERROR_FAILURE);
    1: 
    1:     rv = factory->GetScriptRuntimeByID(aLangID, &runtime);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // This makes sScriptRuntimes hold a strong ref.
    1:     sScriptRuntimes[langIndex] = runtime;
    1:   }
    1: 
    1:   rv = runtime->HoldScriptObject(aObject);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   ++sScriptRootCount[langIndex];
 2956:   NS_LOG_ADDREF(sScriptRuntimes[langIndex], sScriptRootCount[langIndex],
 2956:                 "HoldScriptObject", sizeof(void*));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
 7230: void
 7230: nsContentUtils::DropScriptObject(PRUint32 aLangID, void *aObject,
 7230:                                  void *aClosure)
    1: {
 2956:   NS_ASSERTION(aObject, "unexpected null object");
 7230:   NS_ASSERTION(aLangID != nsIProgrammingLanguage::JAVASCRIPT,
 7230:                "Should use DropJSObjects.");
    1:   PRUint32 langIndex = NS_STID_INDEX(aLangID);
 2956:   NS_LOG_RELEASE(sScriptRuntimes[langIndex], sScriptRootCount[langIndex] - 1,
 2956:                  "HoldScriptObject");
 7230:   sScriptRuntimes[langIndex]->DropScriptObject(aObject);
    1:   if (--sScriptRootCount[langIndex] == 0) {
    1:     NS_RELEASE(sScriptRuntimes[langIndex]);
    1:   }
 7230: }
 7230: 
 7230: /* static */
 7230: nsresult
 7230: nsContentUtils::HoldJSObjects(void* aScriptObjectHolder,
 7230:                               nsScriptObjectTracer* aTracer)
 7230: {
41899:   NS_ENSURE_TRUE(sXPConnect, NS_ERROR_UNEXPECTED);
41899: 
 7230:   nsresult rv = sXPConnect->AddJSHolder(aScriptObjectHolder, aTracer);
 7230:   NS_ENSURE_SUCCESS(rv, rv);
 7230: 
41899:   if (sJSGCThingRootCount++ == 0) {
41899:     nsLayoutStatics::AddRef();
41899:   }
 7230:   NS_LOG_ADDREF(sXPConnect, sJSGCThingRootCount, "HoldJSObjects",
 7230:                 sizeof(void*));
 7230: 
 7230:   return NS_OK;
 7230: }
 7230: 
 7230: /* static */
 7230: nsresult
 7230: nsContentUtils::DropJSObjects(void* aScriptObjectHolder)
 7230: {
 7230:   NS_LOG_RELEASE(sXPConnect, sJSGCThingRootCount - 1, "HoldJSObjects");
 7230:   nsresult rv = sXPConnect->RemoveJSHolder(aScriptObjectHolder);
41899:   if (--sJSGCThingRootCount == 0) {
41899:     nsLayoutStatics::Release();
 7230:   }
    1:   return rv;
    1: }
  539: 
  539: /* static */
  539: PRUint32
15919: nsContentUtils::GetWidgetStatusFromIMEStatus(PRUint32 aState)
  539: {
  539:   switch (aState & nsIContent::IME_STATUS_MASK_ENABLED) {
  539:     case nsIContent::IME_STATUS_DISABLE:
15919:       return nsIWidget::IME_STATUS_DISABLED;
  539:     case nsIContent::IME_STATUS_ENABLE:
15919:       return nsIWidget::IME_STATUS_ENABLED;
  539:     case nsIContent::IME_STATUS_PASSWORD:
15919:       return nsIWidget::IME_STATUS_PASSWORD;
22788:     case nsIContent::IME_STATUS_PLUGIN:
22788:       return nsIWidget::IME_STATUS_PLUGIN;
  539:     default:
  539:       NS_ERROR("The given state doesn't have valid enable state");
15919:       return nsIWidget::IME_STATUS_ENABLED;
  539:   }
  539: }
  998: 
  998: /* static */
  998: void
  998: nsContentUtils::NotifyInstalledMenuKeyboardListener(PRBool aInstalling)
  998: {
  998:   nsIMEStateManager::OnInstalledMenuKeyboardListener(aInstalling);
  998: }
 2324: 
 2324: static PRBool SchemeIs(nsIURI* aURI, const char* aScheme)
 2324: {
 2324:   nsCOMPtr<nsIURI> baseURI = NS_GetInnermostURI(aURI);
 2324:   NS_ENSURE_TRUE(baseURI, PR_FALSE);
 2324: 
 2324:   PRBool isScheme = PR_FALSE;
 2324:   return NS_SUCCEEDED(baseURI->SchemeIs(aScheme, &isScheme)) && isScheme;
 2324: }
 2324: 
 2324: /* static */
 2324: nsresult
 2324: nsContentUtils::CheckSecurityBeforeLoad(nsIURI* aURIToLoad,
 2324:                                         nsIPrincipal* aLoadingPrincipal,
 2324:                                         PRUint32 aCheckLoadFlags,
 2324:                                         PRBool aAllowData,
 2324:                                         PRUint32 aContentPolicyType,
 2324:                                         nsISupports* aContext,
 2324:                                         const nsACString& aMimeGuess,
 2324:                                         nsISupports* aExtra)
 2324: {
 4367:   NS_PRECONDITION(aLoadingPrincipal, "Must have a loading principal here");
 4367: 
14747:   PRBool isSystemPrin = PR_FALSE;
14747:   if (NS_SUCCEEDED(sSecurityManager->IsSystemPrincipal(aLoadingPrincipal,
14747:                                                        &isSystemPrin)) &&
14747:       isSystemPrin) {
14747:     return NS_OK;
14747:   }
14747:   
 3645:   // XXXbz do we want to fast-path skin stylesheets loading XBL here somehow?
 2324:   // CheckLoadURIWithPrincipal
 4367:   nsresult rv = sSecurityManager->
 2324:     CheckLoadURIWithPrincipal(aLoadingPrincipal, aURIToLoad, aCheckLoadFlags);
 2324:   NS_ENSURE_SUCCESS(rv, rv);
 2324: 
 2324:   // Content Policy
 2324:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
 2324:   rv = NS_CheckContentLoadPolicy(aContentPolicyType,
 2324:                                  aURIToLoad,
 4367:                                  aLoadingPrincipal,
 2324:                                  aContext,
 2324:                                  aMimeGuess,
 2324:                                  aExtra,
 2324:                                  &shouldLoad,
 4367:                                  GetContentPolicy(),
 4367:                                  sSecurityManager);
 2324:   NS_ENSURE_SUCCESS(rv, rv);
 2324:   if (NS_CP_REJECTED(shouldLoad)) {
 2324:     return NS_ERROR_CONTENT_BLOCKED;
 2324:   }
 2324: 
 2324:   // Same Origin
 2324:   if ((aAllowData && SchemeIs(aURIToLoad, "data")) ||
 2324:       ((aCheckLoadFlags & nsIScriptSecurityManager::ALLOW_CHROME) &&
 2324:        SchemeIs(aURIToLoad, "chrome"))) {
 2324:     return NS_OK;
 2324:   }
 4367: 
12321:   return aLoadingPrincipal->CheckMayLoad(aURIToLoad, PR_TRUE);
 2324: }
 3333: 
38847: PRBool
38847: nsContentUtils::IsSystemPrincipal(nsIPrincipal* aPrincipal)
38847: {
38847:   PRBool isSystem;
38847:   nsresult rv = sSecurityManager->IsSystemPrincipal(aPrincipal, &isSystem);
38847:   return NS_SUCCEEDED(rv) && isSystem;
38847: }
38847: 
 3333: /* static */
 3333: void
 3333: nsContentUtils::TriggerLink(nsIContent *aContent, nsPresContext *aPresContext,
 3333:                             nsIURI *aLinkURI, const nsString &aTargetSpec,
 3333:                             PRBool aClick, PRBool aIsUserTriggered)
 3333: {
 3333:   NS_ASSERTION(aPresContext, "Need a nsPresContext");
 3333:   NS_PRECONDITION(aLinkURI, "No link URI");
 3333: 
 3333:   if (aContent->IsEditable()) {
 3333:     return;
 3333:   }
 3333: 
 3333:   nsILinkHandler *handler = aPresContext->GetLinkHandler();
 3333:   if (!handler) {
 3333:     return;
 3333:   }
 3333: 
 3333:   if (!aClick) {
 3333:     handler->OnOverLink(aContent, aLinkURI, aTargetSpec.get());
 3333: 
 3333:     return;
 3333:   }
 3333: 
 3333:   // Check that this page is allowed to load this URI.
 3333:   nsresult proceed = NS_OK;
 3333: 
 3333:   if (sSecurityManager) {
 3333:     PRUint32 flag =
 3333:       aIsUserTriggered ?
 3333:       (PRUint32)nsIScriptSecurityManager::STANDARD :
 3333:       (PRUint32)nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT;
 3333:     proceed =
 3333:       sSecurityManager->CheckLoadURIWithPrincipal(aContent->NodePrincipal(),
 3333:                                                   aLinkURI, flag);
 3333:   }
 3333: 
 3333:   // Only pass off the click event if the script security manager says it's ok.
 3333:   if (NS_SUCCEEDED(proceed)) {
 3333:     handler->OnLinkClick(aContent, aLinkURI, aTargetSpec.get());
 3333:   }
 3333: }
 6876: 
 8092: /* static */
 8092: nsIWidget*
 8092: nsContentUtils::GetTopLevelWidget(nsIWidget* aWidget)
 8092: {
19295:   if (!aWidget)
 8092:     return nsnull;
19295: 
19295:   return aWidget->GetTopLevelWidget();
 8092: }
 8092: 
 8092: /* static */
 8167: const nsDependentString
 8167: nsContentUtils::GetLocalizedEllipsis()
 8167: {
 8167:   static PRUnichar sBuf[4] = { 0, 0, 0, 0 };
 8167:   if (!sBuf[0]) {
 8167:     nsAutoString tmp(GetLocalizedStringPref("intl.ellipsis"));
38393:     PRUint32 len = NS_MIN(PRUint32(tmp.Length()),
38393:                           PRUint32(NS_ARRAY_LENGTH(sBuf) - 1));
 8167:     CopyUnicodeTo(tmp, 0, sBuf, len);
 8167:     if (!sBuf[0])
 8167:       sBuf[0] = PRUnichar(0x2026);
 8167:   }
 8167:   return nsDependentString(sBuf);
 8167: }
 8167: 
 9377: //static
 9377: nsEvent*
 9377: nsContentUtils::GetNativeEvent(nsIDOMEvent* aDOMEvent)
 9377: {
 9377:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aDOMEvent));
 9377:   if (!privateEvent)
 9377:     return nsnull;
20234:   return privateEvent->GetInternalNSEvent();
 9377: }
 9377: 
 9377: //static
 9377: PRBool
20505: nsContentUtils::DOMEventToNativeKeyEvent(nsIDOMKeyEvent* aKeyEvent,
 9377:                                          nsNativeKeyEvent* aNativeEvent,
 9377:                                          PRBool aGetCharCode)
 9377: {
20505:   nsCOMPtr<nsIDOMNSUIEvent> uievent = do_QueryInterface(aKeyEvent);
 9377:   PRBool defaultPrevented;
 9377:   uievent->GetPreventDefault(&defaultPrevented);
 9377:   if (defaultPrevented)
 9377:     return PR_FALSE;
 9377: 
20505:   nsCOMPtr<nsIDOMNSEvent> nsevent = do_QueryInterface(aKeyEvent);
 9377:   PRBool trusted = PR_FALSE;
 9377:   nsevent->GetIsTrusted(&trusted);
 9377:   if (!trusted)
 9377:     return PR_FALSE;
 9377: 
 9377:   if (aGetCharCode) {
20505:     aKeyEvent->GetCharCode(&aNativeEvent->charCode);
 9377:   } else {
 9377:     aNativeEvent->charCode = 0;
 9377:   }
20505:   aKeyEvent->GetKeyCode(&aNativeEvent->keyCode);
20505:   aKeyEvent->GetAltKey(&aNativeEvent->altKey);
20505:   aKeyEvent->GetCtrlKey(&aNativeEvent->ctrlKey);
20505:   aKeyEvent->GetShiftKey(&aNativeEvent->shiftKey);
20505:   aKeyEvent->GetMetaKey(&aNativeEvent->metaKey);
20505: 
20505:   aNativeEvent->nativeEvent = GetNativeEvent(aKeyEvent);
 9377: 
 9377:   return PR_TRUE;
 9377: }
 9377: 
14889: static PRBool
14889: HasASCIIDigit(const nsTArray<nsShortcutCandidate>& aCandidates)
14889: {
14889:   for (PRUint32 i = 0; i < aCandidates.Length(); ++i) {
14889:     PRUint32 ch = aCandidates[i].mCharCode;
14889:     if (ch >= '0' && ch <= '9')
14889:       return PR_TRUE;
14889:   }
14889:   return PR_FALSE;
14889: }
14889: 
15112: static PRBool
15112: CharsCaseInsensitiveEqual(PRUint32 aChar1, PRUint32 aChar2)
15112: {
15112:   return aChar1 == aChar2 ||
15112:          (IS_IN_BMP(aChar1) && IS_IN_BMP(aChar2) &&
15112:           ToLowerCase(PRUnichar(aChar1)) == ToLowerCase(PRUnichar(aChar2)));
15112: }
15112: 
15112: static PRBool
15112: IsCaseChangeableChar(PRUint32 aChar)
15112: {
15112:   return IS_IN_BMP(aChar) &&
15112:          ToLowerCase(PRUnichar(aChar)) != ToUpperCase(PRUnichar(aChar));
15112: }
15112: 
 8167: /* static */
 7230: void
19283: nsContentUtils::GetAccelKeyCandidates(nsIDOMKeyEvent* aDOMKeyEvent,
14328:                   nsTArray<nsShortcutCandidate>& aCandidates)
14328: {
14328:   NS_PRECONDITION(aCandidates.IsEmpty(), "aCandidates must be empty");
14328: 
14328:   nsAutoString eventType;
19283:   aDOMKeyEvent->GetType(eventType);
19283:   // Don't process if aDOMKeyEvent is not a keypress event.
14328:   if (!eventType.EqualsLiteral("keypress"))
14328:     return;
14328: 
14328:   nsKeyEvent* nativeKeyEvent =
19283:     static_cast<nsKeyEvent*>(GetNativeEvent(aDOMKeyEvent));
14328:   if (nativeKeyEvent) {
19283:     NS_ASSERTION(nativeKeyEvent->eventStructType == NS_KEY_EVENT,
19283:                  "wrong type of native event");
14328:     // nsShortcutCandidate::mCharCode is a candidate charCode.
14328:     // nsShoftcutCandidate::mIgnoreShift means the mCharCode should be tried to
14328:     // execute a command with/without shift key state. If this is TRUE, the
14328:     // shifted key state should be ignored. Otherwise, don't ignore the state.
14328:     // the priority of the charCodes are (shift key is not pressed):
14328:     //   0: charCode/PR_FALSE,
14328:     //   1: unshiftedCharCodes[0]/PR_FALSE, 2: unshiftedCharCodes[1]/PR_FALSE...
14328:     // the priority of the charCodes are (shift key is pressed):
14328:     //   0: charCode/PR_FALSE,
14328:     //   1: shiftedCharCodes[0]/PR_FALSE, 2: shiftedCharCodes[0]/PR_TRUE,
14328:     //   3: shiftedCharCodes[1]/PR_FALSE, 4: shiftedCharCodes[1]/PR_TRUE...
14328:     if (nativeKeyEvent->charCode) {
14328:       nsShortcutCandidate key(nativeKeyEvent->charCode, PR_FALSE);
14328:       aCandidates.AppendElement(key);
14328:     }
14328: 
14889:     PRUint32 len = nativeKeyEvent->alternativeCharCodes.Length();
14328:     if (!nativeKeyEvent->isShift) {
14889:       for (PRUint32 i = 0; i < len; ++i) {
14328:         PRUint32 ch =
14423:           nativeKeyEvent->alternativeCharCodes[i].mUnshiftedCharCode;
14328:         if (!ch || ch == nativeKeyEvent->charCode)
14328:           continue;
14328: 
14328:         nsShortcutCandidate key(ch, PR_FALSE);
14328:         aCandidates.AppendElement(key);
14328:       }
14889:       // If unshiftedCharCodes doesn't have numeric but shiftedCharCode has it,
14889:       // this keyboard layout is AZERTY or similar layout, probably.
14889:       // In this case, Accel+[0-9] should be accessible without shift key.
14889:       // However, the priority should be lowest.
14889:       if (!HasASCIIDigit(aCandidates)) {
14889:         for (PRUint32 i = 0; i < len; ++i) {
14889:           PRUint32 ch =
14889:             nativeKeyEvent->alternativeCharCodes[i].mShiftedCharCode;
14889:           if (ch >= '0' && ch <= '9') {
14889:             nsShortcutCandidate key(ch, PR_FALSE);
14889:             aCandidates.AppendElement(key);
14889:             break;
14889:           }
14889:         }
14889:       }
14328:     } else {
14889:       for (PRUint32 i = 0; i < len; ++i) {
14328:         PRUint32 ch = nativeKeyEvent->alternativeCharCodes[i].mShiftedCharCode;
14328:         if (!ch)
14328:           continue;
14328: 
14328:         if (ch != nativeKeyEvent->charCode) {
14328:           nsShortcutCandidate key(ch, PR_FALSE);
14328:           aCandidates.AppendElement(key);
14328:         }
14328: 
14328:         // If the char is an alphabet, the shift key state should not be
14328:         // ignored. E.g., Ctrl+Shift+C should not execute Ctrl+C.
15112: 
14328:         // And checking the charCode is same as unshiftedCharCode too.
14328:         // E.g., for Ctrl+Shift+(Plus of Numpad) should not run Ctrl+Plus.
14328:         PRUint32 unshiftCh =
14328:           nativeKeyEvent->alternativeCharCodes[i].mUnshiftedCharCode;
15112:         if (CharsCaseInsensitiveEqual(ch, unshiftCh))
15112:           continue;
15112: 
15112:         // On the Hebrew keyboard layout on Windows, the unshifted char is a
15112:         // localized character but the shifted char is a Latin alphabet,
15112:         // then, we should not execute without the shift state. See bug 433192.
15112:         if (IsCaseChangeableChar(ch))
14328:           continue;
14328: 
14328:         // Setting the alternative charCode candidates for retry without shift
14328:         // key state only when the shift key is pressed.
14328:         nsShortcutCandidate key(ch, PR_TRUE);
14328:         aCandidates.AppendElement(key);
14328:       }
14328:     }
14328:   } else {
14328:     PRUint32 charCode;
19283:     aDOMKeyEvent->GetCharCode(&charCode);
14328:     if (charCode) {
14328:       nsShortcutCandidate key(charCode, PR_FALSE);
14328:       aCandidates.AppendElement(key);
14328:     }
14328:   }
14328: }
14328: 
14328: /* static */
14328: void
14328: nsContentUtils::GetAccessKeyCandidates(nsKeyEvent* aNativeKeyEvent,
14328:                                        nsTArray<PRUint32>& aCandidates)
14328: {
14328:   NS_PRECONDITION(aCandidates.IsEmpty(), "aCandidates must be empty");
14328: 
14328:   // return the lower cased charCode candidates for access keys.
14328:   // the priority of the charCodes are:
14328:   //   0: charCode, 1: unshiftedCharCodes[0], 2: shiftedCharCodes[0]
14328:   //   3: unshiftedCharCodes[1], 4: shiftedCharCodes[1],...
14328:   if (aNativeKeyEvent->charCode) {
14328:     PRUint32 ch = aNativeKeyEvent->charCode;
14328:     if (IS_IN_BMP(ch))
14328:       ch = ToLowerCase(PRUnichar(ch));
14328:     aCandidates.AppendElement(ch);
14328:   }
14328:   for (PRUint32 i = 0;
14328:        i < aNativeKeyEvent->alternativeCharCodes.Length(); ++i) {
14328:     PRUint32 ch[2] =
14328:       { aNativeKeyEvent->alternativeCharCodes[i].mUnshiftedCharCode,
14328:         aNativeKeyEvent->alternativeCharCodes[i].mShiftedCharCode };
14328:     for (PRUint32 j = 0; j < 2; ++j) {
14328:       if (!ch[j])
14328:         continue;
14328:       if (IS_IN_BMP(ch[j]))
14328:         ch[j] = ToLowerCase(PRUnichar(ch[j]));
14328:       // Don't append the charCode that was already appended.
14328:       if (aCandidates.IndexOf(ch[j]) == aCandidates.NoIndex)
14328:         aCandidates.AppendElement(ch[j]);
14328:     }
14328:   }
14328:   return;
14328: }
14328: 
14328: /* static */
14328: void
13098: nsContentUtils::AddScriptBlocker()
13098: {
13098:   if (!sScriptBlockerCount) {
13098:     NS_ASSERTION(sRunnersCountAtFirstBlocker == 0,
13098:                  "Should not already have a count");
13098:     sRunnersCountAtFirstBlocker = sBlockedScriptRunners->Count();
13098:   }
13098:   ++sScriptBlockerCount;
13098: }
13098: 
13098: /* static */
13098: void
37087: nsContentUtils::AddScriptBlockerAndPreventAddingRunners()
37087: {
37087:   AddScriptBlocker();
37087:   if (sScriptBlockerCountWhereRunnersPrevented == 0) {
37087:     sScriptBlockerCountWhereRunnersPrevented = sScriptBlockerCount;
37087:   }
37087: }
37087: 
37087: /* static */
37087: void
13098: nsContentUtils::RemoveScriptBlocker()
13098: {
14319:   NS_ASSERTION(sScriptBlockerCount != 0, "Negative script blockers");
13098:   --sScriptBlockerCount;
37087:   if (sScriptBlockerCount < sScriptBlockerCountWhereRunnersPrevented) {
37087:     sScriptBlockerCountWhereRunnersPrevented = 0;
37087:   }
13098:   if (sScriptBlockerCount) {
13098:     return;
13098:   }
13098: 
13098:   PRUint32 firstBlocker = sRunnersCountAtFirstBlocker;
39339:   PRUint32 lastBlocker = (PRUint32)sBlockedScriptRunners->Count();
13098:   sRunnersCountAtFirstBlocker = 0;
13098:   NS_ASSERTION(firstBlocker <= lastBlocker,
13098:                "bad sRunnersCountAtFirstBlocker");
13098: 
13098:   while (firstBlocker < lastBlocker) {
13098:     nsCOMPtr<nsIRunnable> runnable = (*sBlockedScriptRunners)[firstBlocker];
13098:     sBlockedScriptRunners->RemoveObjectAt(firstBlocker);
13098:     --lastBlocker;
13098: 
13098:     runnable->Run();
39341:     NS_ASSERTION(lastBlocker == (PRUint32)sBlockedScriptRunners->Count() &&
13098:                  sRunnersCountAtFirstBlocker == 0,
13098:                  "Bad count");
13098:     NS_ASSERTION(!sScriptBlockerCount, "This is really bad");
13098:   }
13098: }
13098: 
13098: /* static */
13098: PRBool
13098: nsContentUtils::AddScriptRunner(nsIRunnable* aRunnable)
13098: {
13098:   if (!aRunnable) {
13098:     return PR_FALSE;
13098:   }
13098: 
13098:   if (sScriptBlockerCount) {
37087:     if (sScriptBlockerCountWhereRunnersPrevented > 0) {
37087:       NS_ERROR("Adding a script runner when that is prevented!");
37087:       return PR_FALSE;
37087:     }
13098:     return sBlockedScriptRunners->AppendObject(aRunnable);
13098:   }
13098:   
13098:   nsCOMPtr<nsIRunnable> run = aRunnable;
13098:   run->Run();
13098: 
13098:   return PR_TRUE;
13098: }
13098: 
15988: /* 
15988:  * Helper function for nsContentUtils::ProcessViewportInfo.
15988:  *
15988:  * Handles a single key=value pair. If it corresponds to a valid viewport
15988:  * attribute, add it to the document header data. No validation is done on the
15988:  * value itself (this is done at display time).
15988:  */
15988: static void ProcessViewportToken(nsIDocument *aDocument, 
15988:                                  const nsAString &token) {
15988: 
15988:   /* Iterators. */
15988:   nsAString::const_iterator tip, tail, end;
15988:   token.BeginReading(tip);
15988:   tail = tip;
15988:   token.EndReading(end);
15988: 
15988:   /* Move tip to the '='. */
15988:   while ((tip != end) && (*tip != '='))
15988:     ++tip;
15988: 
15988:   /* If we didn't find an '=', punt. */
15988:   if (tip == end)
15988:     return;
15988: 
15988:   /* Extract the key and value. */
56941:   const nsAString &key =
56941:     nsContentUtils::TrimWhitespace<nsCRT::IsAsciiSpace>(Substring(tail, tip),
56941:                                                         PR_TRUE);
56941:   const nsAString &value =
56941:     nsContentUtils::TrimWhitespace<nsCRT::IsAsciiSpace>(Substring(++tip, end),
56941:                                                         PR_TRUE);
15988: 
15988:   /* Check for known keys. If we find a match, insert the appropriate
15988:    * information into the document header. */
15988:   nsCOMPtr<nsIAtom> key_atom = do_GetAtom(key);
15988:   if (key_atom == nsGkAtoms::height)
15988:     aDocument->SetHeaderData(nsGkAtoms::viewport_height, value);
15988:   else if (key_atom == nsGkAtoms::width)
15988:     aDocument->SetHeaderData(nsGkAtoms::viewport_width, value);
15988:   else if (key_atom == nsGkAtoms::initial_scale)
15988:     aDocument->SetHeaderData(nsGkAtoms::viewport_initial_scale, value);
15988:   else if (key_atom == nsGkAtoms::minimum_scale)
15988:     aDocument->SetHeaderData(nsGkAtoms::viewport_minimum_scale, value);
15988:   else if (key_atom == nsGkAtoms::maximum_scale)
15988:     aDocument->SetHeaderData(nsGkAtoms::viewport_maximum_scale, value);
15988:   else if (key_atom == nsGkAtoms::user_scalable)
15988:     aDocument->SetHeaderData(nsGkAtoms::viewport_user_scalable, value);
15988: }
15988: 
56941: #define IS_SEPARATOR(c) ((c == '=') || (c == ',') || (c == ';') || \
56941:                          (c == '\t') || (c == '\n') || (c == '\r'))
56941: 
15988: /* static */
15988: nsresult
15988: nsContentUtils::ProcessViewportInfo(nsIDocument *aDocument,
15988:                                     const nsAString &viewportInfo) {
15988: 
15988:   /* We never fail. */
15988:   nsresult rv = NS_OK;
15988: 
15988:   /* Iterators. */
15988:   nsAString::const_iterator tip, tail, end;
15988:   viewportInfo.BeginReading(tip);
15988:   tail = tip;
15988:   viewportInfo.EndReading(end);
15988: 
15988:   /* Read the tip to the first non-separator character. */
56941:   while ((tip != end) && (IS_SEPARATOR(*tip) || nsCRT::IsAsciiSpace(*tip)))
15988:     ++tip;
15988: 
42263:   /* Read through and find tokens separated by separators. */
15988:   while (tip != end) {
15988: 
15988:     /* Synchronize tip and tail. */
15988:     tail = tip;
15988: 
15988:     /* Advance tip past non-separator characters. */
15988:     while ((tip != end) && !IS_SEPARATOR(*tip))
15988:       ++tip;
15988: 
56941:     /* Allow white spaces that surround the '=' character */
56941:     if ((tip != end) && (*tip == '=')) {
56941:       ++tip;
56941: 
56941:       while ((tip != end) && nsCRT::IsAsciiSpace(*tip))
56941:         ++tip;
56941: 
56941:       while ((tip != end) && !(IS_SEPARATOR(*tip) || nsCRT::IsAsciiSpace(*tip)))
56941:         ++tip;
56941:     }
56941: 
15988:     /* Our token consists of the characters between tail and tip. */
15988:     ProcessViewportToken(aDocument, Substring(tail, tip));
15988: 
15988:     /* Skip separators. */
56941:     while ((tip != end) && (IS_SEPARATOR(*tip) || nsCRT::IsAsciiSpace(*tip)))
15988:       ++tip;
15988:   }
15988: 
15988:   return rv;
15988: 
15988: }
15988: 
15988: #undef IS_SEPARATOR
15988: 
13098: /* static */
13098: void
11414: nsContentUtils::HidePopupsInDocument(nsIDocument* aDocument)
11414: {
12171: #ifdef MOZ_XUL
11414:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
34139:   if (pm && aDocument) {
11414:     nsCOMPtr<nsISupports> container = aDocument->GetContainer();
11414:     nsCOMPtr<nsIDocShellTreeItem> docShellToHide = do_QueryInterface(container);
11414:     if (docShellToHide)
11414:       pm->HidePopupsInDocShell(docShellToHide);
11414:   }
12171: #endif
11414: }
11414: 
11414: /* static */
18445: already_AddRefed<nsIDragSession>
18445: nsContentUtils::GetDragSession()
18445: {
18445:   nsIDragSession* dragSession = nsnull;
18445:   nsCOMPtr<nsIDragService> dragService =
18445:     do_GetService("@mozilla.org/widget/dragservice;1");
18445:   if (dragService)
18445:     dragService->GetCurrentSession(&dragSession);
18445:   return dragSession;
18445: }
18445: 
18445: /* static */
29545: nsresult
29545: nsContentUtils::SetDataTransferInEvent(nsDragEvent* aDragEvent)
29545: {
29545:   if (aDragEvent->dataTransfer || !NS_IS_TRUSTED_EVENT(aDragEvent))
29545:     return NS_OK;
29545: 
29545:   // For draggesture and dragstart events, the data transfer object is
29545:   // created before the event fires, so it should already be set. For other
29545:   // drag events, get the object from the drag session.
29545:   NS_ASSERTION(aDragEvent->message != NS_DRAGDROP_GESTURE &&
29545:                aDragEvent->message != NS_DRAGDROP_START,
29545:                "draggesture event created without a dataTransfer");
29545: 
29545:   nsCOMPtr<nsIDragSession> dragSession = GetDragSession();
29545:   NS_ENSURE_TRUE(dragSession, NS_OK); // no drag in progress
29545: 
29545:   nsCOMPtr<nsIDOMDataTransfer> initialDataTransfer;
29545:   dragSession->GetDataTransfer(getter_AddRefs(initialDataTransfer));
29545:   if (!initialDataTransfer) {
29545:     // A dataTransfer won't exist when a drag was started by some other
29545:     // means, for instance calling the drag service directly, or a drag
29545:     // from another application. In either case, a new dataTransfer should
58174:     // be created that reflects the data.
29545:     initialDataTransfer =
58174:       new nsDOMDataTransfer(aDragEvent->message);
29545:     NS_ENSURE_TRUE(initialDataTransfer, NS_ERROR_OUT_OF_MEMORY);
29545: 
29545:     // now set it in the drag session so we don't need to create it again
29545:     dragSession->SetDataTransfer(initialDataTransfer);
29545:   }
29545: 
29545:   // each event should use a clone of the original dataTransfer.
29545:   nsCOMPtr<nsIDOMNSDataTransfer> initialDataTransferNS =
29545:     do_QueryInterface(initialDataTransfer);
29545:   NS_ENSURE_TRUE(initialDataTransferNS, NS_ERROR_FAILURE);
29545:   initialDataTransferNS->Clone(aDragEvent->message, aDragEvent->userCancelled,
29545:                                getter_AddRefs(aDragEvent->dataTransfer));
29545:   NS_ENSURE_TRUE(aDragEvent->dataTransfer, NS_ERROR_OUT_OF_MEMORY);
29545: 
29545:   // for the dragenter and dragover events, initialize the drop effect
29545:   // from the drop action, which platform specific widget code sets before
29545:   // the event is fired based on the keyboard state.
29545:   if (aDragEvent->message == NS_DRAGDROP_ENTER ||
29545:       aDragEvent->message == NS_DRAGDROP_OVER) {
29545:     nsCOMPtr<nsIDOMNSDataTransfer> newDataTransfer =
29545:       do_QueryInterface(aDragEvent->dataTransfer);
29545:     NS_ENSURE_TRUE(newDataTransfer, NS_ERROR_FAILURE);
29545: 
29545:     PRUint32 action, effectAllowed;
29545:     dragSession->GetDragAction(&action);
29545:     newDataTransfer->GetEffectAllowedInt(&effectAllowed);
29545:     newDataTransfer->SetDropEffectInt(FilterDropEffect(action, effectAllowed));
29545:   }
29545:   else if (aDragEvent->message == NS_DRAGDROP_DROP ||
29545:            aDragEvent->message == NS_DRAGDROP_DRAGDROP ||
29545:            aDragEvent->message == NS_DRAGDROP_END) {
29545:     // For the drop and dragend events, set the drop effect based on the
29545:     // last value that the dropEffect had. This will have been set in
29545:     // nsEventStateManager::PostHandleEvent for the last dragenter or
29545:     // dragover event.
29545:     nsCOMPtr<nsIDOMNSDataTransfer> newDataTransfer =
29545:       do_QueryInterface(aDragEvent->dataTransfer);
29545:     NS_ENSURE_TRUE(newDataTransfer, NS_ERROR_FAILURE);
29545: 
29545:     PRUint32 dropEffect;
29545:     initialDataTransferNS->GetDropEffectInt(&dropEffect);
29545:     newDataTransfer->SetDropEffectInt(dropEffect);
29545:   }
29545: 
29545:   return NS_OK;
29545: }
29545: 
29545: /* static */
29545: PRUint32
29545: nsContentUtils::FilterDropEffect(PRUint32 aAction, PRUint32 aEffectAllowed)
29545: {
29545:   // It is possible for the drag action to include more than one action, but
29545:   // the widget code which sets the action from the keyboard state should only
29545:   // be including one. If multiple actions were set, we just consider them in
29545:   //  the following order:
29545:   //   copy, link, move
29545:   if (aAction & nsIDragService::DRAGDROP_ACTION_COPY)
29545:     aAction = nsIDragService::DRAGDROP_ACTION_COPY;
29545:   else if (aAction & nsIDragService::DRAGDROP_ACTION_LINK)
29545:     aAction = nsIDragService::DRAGDROP_ACTION_LINK;
29545:   else if (aAction & nsIDragService::DRAGDROP_ACTION_MOVE)
29545:     aAction = nsIDragService::DRAGDROP_ACTION_MOVE;
29545: 
29545:   // Filter the action based on the effectAllowed. If the effectAllowed
29545:   // doesn't include the action, then that action cannot be done, so adjust
29545:   // the action to something that is allowed. For a copy, adjust to move or
29545:   // link. For a move, adjust to copy or link. For a link, adjust to move or
29545:   // link. Otherwise, use none.
29545:   if (aAction & aEffectAllowed ||
29545:       aEffectAllowed == nsIDragService::DRAGDROP_ACTION_UNINITIALIZED)
29545:     return aAction;
29545:   if (aEffectAllowed & nsIDragService::DRAGDROP_ACTION_MOVE)
29545:     return nsIDragService::DRAGDROP_ACTION_MOVE;
29545:   if (aEffectAllowed & nsIDragService::DRAGDROP_ACTION_COPY)
29545:     return nsIDragService::DRAGDROP_ACTION_COPY;
29545:   if (aEffectAllowed & nsIDragService::DRAGDROP_ACTION_LINK)
29545:     return nsIDragService::DRAGDROP_ACTION_LINK;
29545:   return nsIDragService::DRAGDROP_ACTION_NONE;
29545: }
29545: 
29545: /* static */
13471: PRBool
13471: nsContentUtils::URIIsLocalFile(nsIURI *aURI)
13471: {
13471:   PRBool isFile;
13471:   nsCOMPtr<nsINetUtil> util = do_QueryInterface(sIOService);
13471: 
13471:   return util && NS_SUCCEEDED(util->ProtocolHasFlags(aURI,
13471:                                 nsIProtocolHandler::URI_IS_LOCAL_FILE,
13471:                                 &isFile)) &&
13471:          isFile;
13471: }
13471: 
13471: /* static */
27700: nsIScriptContext*
16056: nsContentUtils::GetContextForEventHandlers(nsINode* aNode,
27700:                                            nsresult* aRv)
16056: {
27700:   *aRv = NS_OK;
16056:   nsIDocument* ownerDoc = aNode->GetOwnerDoc();
27700:   if (!ownerDoc) {
27700:     *aRv = NS_ERROR_UNEXPECTED;
27700:     return nsnull;
27700:   }
27700: 
16056:   PRBool hasHadScriptObject = PR_TRUE;
27700:   nsIScriptGlobalObject* sgo =
27700:     ownerDoc->GetScriptHandlingObject(hasHadScriptObject);
16056:   // It is bad if the document doesn't have event handling context,
16056:   // but it used to have one.
27700:   if (!sgo && hasHadScriptObject) {
27700:     *aRv = NS_ERROR_UNEXPECTED;
27700:     return nsnull;
27700:   }
27700: 
16056:   if (sgo) {
27700:     nsIScriptContext* scx = sgo->GetContext();
16056:     // Bad, no context from script global object!
27700:     if (!scx) {
27700:       *aRv = NS_ERROR_UNEXPECTED;
27700:       return nsnull;
27700:     }
27700:     return scx;
27700:   }
27700: 
27700:   return nsnull;
16056: }
16056: 
16056: /* static */
18868: JSContext *
18868: nsContentUtils::GetCurrentJSContext()
18868: {
18868:   JSContext *cx = nsnull;
18868: 
18868:   sThreadJSContextStack->Peek(&cx);
18868: 
18868:   return cx;
18868: }
18868: 
18868: /* static */
11414: void
48880: nsContentUtils::ASCIIToLower(nsAString& aStr)
48880: {
48880:   PRUnichar* iter = aStr.BeginWriting();
48880:   PRUnichar* end = aStr.EndWriting();
48880:   while (iter != end) {
48880:     PRUnichar c = *iter;
48880:     if (c >= 'A' && c <= 'Z') {
48880:       *iter = c + ('a' - 'A');
48880:     }
48880:     ++iter;
48880:   }
48880: }
48880: 
48880: /* static */
48880: void
38422: nsContentUtils::ASCIIToLower(const nsAString& aSource, nsAString& aDest)
38422: {
38422:   PRUint32 len = aSource.Length();
38422:   aDest.SetLength(len);
38422:   if (aDest.Length() == len) {
38422:     PRUnichar* dest = aDest.BeginWriting();
38422:     const PRUnichar* iter = aSource.BeginReading();
38422:     const PRUnichar* end = aSource.EndReading();
38422:     while (iter != end) {
38422:       PRUnichar c = *iter;
38422:       *dest = (c >= 'A' && c <= 'Z') ?
38422:          c + ('a' - 'A') : c;
38422:       ++iter;
38422:       ++dest;
38422:     }
38422:   }
38422: }
38422: 
38422: /* static */
38422: void
38422: nsContentUtils::ASCIIToUpper(nsAString& aStr)
38422: {
38422:   PRUnichar* iter = aStr.BeginWriting();
38422:   PRUnichar* end = aStr.EndWriting();
38422:   while (iter != end) {
38422:     PRUnichar c = *iter;
38422:     if (c >= 'a' && c <= 'z') {
38422:       *iter = c + ('A' - 'a');
38422:     }
38422:     ++iter;
38422:   }
38422: }
38422: 
48880: /* static */
48880: void
48880: nsContentUtils::ASCIIToUpper(const nsAString& aSource, nsAString& aDest)
48880: {
48880:   PRUint32 len = aSource.Length();
48880:   aDest.SetLength(len);
48880:   if (aDest.Length() == len) {
48880:     PRUnichar* dest = aDest.BeginWriting();
48880:     const PRUnichar* iter = aSource.BeginReading();
48880:     const PRUnichar* end = aSource.EndReading();
48880:     while (iter != end) {
48880:       PRUnichar c = *iter;
48880:       *dest = (c >= 'a' && c <= 'z') ?
48880:          c + ('A' - 'a') : c;
48880:       ++iter;
48880:       ++dest;
48880:     }
48880:   }
48880: }
48880: 
39100: PRBool
39100: nsContentUtils::EqualsIgnoreASCIICase(const nsAString& aStr1,
39100:                                       const nsAString& aStr2)
39100: {
39100:   PRUint32 len = aStr1.Length();
39100:   if (len != aStr2.Length()) {
39100:     return PR_FALSE;
39100:   }
39100: 
39100:   const PRUnichar* str1 = aStr1.BeginReading();
39100:   const PRUnichar* str2 = aStr2.BeginReading();
39100:   const PRUnichar* end = str1 + len;
39100: 
39100:   while (str1 < end) {
39100:     PRUnichar c1 = *str1++;
39100:     PRUnichar c2 = *str2++;
39100: 
39100:     // First check if any bits other than the 0x0020 differs
39100:     if ((c1 ^ c2) & 0xffdf) {
39100:       return PR_FALSE;
39100:     }
39100: 
39100:     // We know they only differ in the 0x0020 bit.
39100:     // Likely the two chars are the same, so check that first
39100:     if (c1 != c2) {
39100:       // They do differ, but since it's only in the 0x0020 bit, check if it's
39100:       // the same ascii char, but just differing in case
39100:       PRUnichar c1Upper = c1 & 0xffdf;
39100:       if (!('A' <= c1Upper && c1Upper <= 'Z')) {
39100:         return PR_FALSE;
39100:       }
39100:     }
39100:   }
39100: 
39100:   return PR_TRUE;
39100: }
39100: 
38422: /* static */
38422: void
 7230: nsAutoGCRoot::Shutdown()
 7230: {
 7230:   NS_IF_RELEASE(sJSRuntimeService);
 7230: }
15474: 
18942: /* static */
18942: nsIInterfaceRequestor*
18942: nsContentUtils::GetSameOriginChecker()
18942: {
18942:   if (!sSameOriginChecker) {
18942:     sSameOriginChecker = new nsSameOriginChecker();
18942:     NS_IF_ADDREF(sSameOriginChecker);
18942:   }
18942:   return sSameOriginChecker;
18942: }
18942: 
58548: /* static */
58548: nsresult
58548: nsContentUtils::CheckSameOrigin(nsIChannel *aOldChannel, nsIChannel *aNewChannel)
58548: {
58548:   if (!nsContentUtils::GetSecurityManager())
58548:     return NS_ERROR_NOT_AVAILABLE;
58548: 
58548:   nsCOMPtr<nsIPrincipal> oldPrincipal;
58548:   nsContentUtils::GetSecurityManager()->
58548:     GetChannelPrincipal(aOldChannel, getter_AddRefs(oldPrincipal));
58548: 
58548:   nsCOMPtr<nsIURI> newURI;
58548:   aNewChannel->GetURI(getter_AddRefs(newURI));
58548:   nsCOMPtr<nsIURI> newOriginalURI;
58548:   aNewChannel->GetOriginalURI(getter_AddRefs(newOriginalURI));
58548: 
58548:   NS_ENSURE_STATE(oldPrincipal && newURI && newOriginalURI);
58548: 
58548:   nsresult rv = oldPrincipal->CheckMayLoad(newURI, PR_FALSE);
58548:   if (NS_SUCCEEDED(rv) && newOriginalURI != newURI) {
58548:     rv = oldPrincipal->CheckMayLoad(newOriginalURI, PR_FALSE);
58548:   }
58548: 
58548:   return rv;
58548: }
18942: 
18942: NS_IMPL_ISUPPORTS2(nsSameOriginChecker,
18942:                    nsIChannelEventSink,
18942:                    nsIInterfaceRequestor)
18942: 
18942: NS_IMETHODIMP
48889: nsSameOriginChecker::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
18942:                                             nsIChannel *aNewChannel,
48889:                                             PRUint32 aFlags,
48889:                                             nsIAsyncVerifyRedirectCallback *cb)
18942: {
18942:   NS_PRECONDITION(aNewChannel, "Redirecting to null channel?");
58548: 
58548:   nsresult rv = nsContentUtils::CheckSameOrigin(aOldChannel, aNewChannel);
58548:   if (NS_SUCCEEDED(rv)) {
58548:     cb->OnRedirectVerifyCallback(NS_OK);
58548:   }
58548: 
21937:   return rv;
18942: }
18942: 
18942: NS_IMETHODIMP
18942: nsSameOriginChecker::GetInterface(const nsIID & aIID, void **aResult)
18942: {
18942:   return QueryInterface(aIID, aResult);
18942: }
18942: 
24084: /* static */
24084: nsresult
24084: nsContentUtils::GetASCIIOrigin(nsIPrincipal* aPrincipal, nsCString& aOrigin)
24084: {
24084:   NS_PRECONDITION(aPrincipal, "missing principal");
24084: 
24084:   aOrigin.Truncate();
24084: 
24084:   nsCOMPtr<nsIURI> uri;
24084:   nsresult rv = aPrincipal->GetURI(getter_AddRefs(uri));
24084:   NS_ENSURE_SUCCESS(rv, rv);
24084: 
24084:   if (uri) {
24084:     return GetASCIIOrigin(uri, aOrigin);
24084:   }
24084: 
24084:   aOrigin.AssignLiteral("null");
24084: 
24084:   return NS_OK;
24084: }
24084: 
24084: /* static */
24084: nsresult
24084: nsContentUtils::GetASCIIOrigin(nsIURI* aURI, nsCString& aOrigin)
24084: {
24084:   NS_PRECONDITION(aURI, "missing uri");
24084: 
24084:   aOrigin.Truncate();
24084: 
24084:   nsCOMPtr<nsIURI> uri = NS_GetInnermostURI(aURI);
24084:   NS_ENSURE_TRUE(uri, NS_ERROR_UNEXPECTED);
24084: 
24084:   nsCString host;
24084:   nsresult rv = uri->GetAsciiHost(host);
24084: 
24084:   if (NS_SUCCEEDED(rv) && !host.IsEmpty()) {
24084:     nsCString scheme;
24084:     rv = uri->GetScheme(scheme);
24084:     NS_ENSURE_SUCCESS(rv, rv);
24084: 
24084:     aOrigin = scheme + NS_LITERAL_CSTRING("://") + host;
24084: 
24084:     // If needed, append the port
24084:     PRInt32 port;
24084:     uri->GetPort(&port);
24084:     if (port != -1) {
24084:       PRInt32 defaultPort = NS_GetDefaultPort(scheme.get());
24084:       if (port != defaultPort) {
24084:         aOrigin.Append(':');
24084:         aOrigin.AppendInt(port);
24084:       }
24084:     }
24084:   }
24084:   else {
24084:     aOrigin.AssignLiteral("null");
24084:   }
24084: 
24084:   return NS_OK;
24084: }
24084: 
24084: /* static */
24084: nsresult
24084: nsContentUtils::GetUTFOrigin(nsIPrincipal* aPrincipal, nsString& aOrigin)
24084: {
24084:   NS_PRECONDITION(aPrincipal, "missing principal");
24084: 
24084:   aOrigin.Truncate();
24084: 
24084:   nsCOMPtr<nsIURI> uri;
24084:   nsresult rv = aPrincipal->GetURI(getter_AddRefs(uri));
24084:   NS_ENSURE_SUCCESS(rv, rv);
24084: 
24084:   if (uri) {
24084:     return GetUTFOrigin(uri, aOrigin);
24084:   }
24084: 
24084:   aOrigin.AssignLiteral("null");
24084: 
24084:   return NS_OK;
24084: }
24084: 
24084: /* static */
24084: nsresult
24084: nsContentUtils::GetUTFOrigin(nsIURI* aURI, nsString& aOrigin)
24084: {
24084:   NS_PRECONDITION(aURI, "missing uri");
24084: 
24084:   aOrigin.Truncate();
24084: 
24084:   nsCOMPtr<nsIURI> uri = NS_GetInnermostURI(aURI);
24084:   NS_ENSURE_TRUE(uri, NS_ERROR_UNEXPECTED);
24084: 
24084:   nsCString host;
24084:   nsresult rv = uri->GetHost(host);
24084: 
24084:   if (NS_SUCCEEDED(rv) && !host.IsEmpty()) {
24084:     nsCString scheme;
24084:     rv = uri->GetScheme(scheme);
24084:     NS_ENSURE_SUCCESS(rv, rv);
24084: 
24084:     aOrigin = NS_ConvertUTF8toUTF16(scheme + NS_LITERAL_CSTRING("://") + host);
24084: 
24084:     // If needed, append the port
24084:     PRInt32 port;
24084:     uri->GetPort(&port);
24084:     if (port != -1) {
24084:       PRInt32 defaultPort = NS_GetDefaultPort(scheme.get());
24084:       if (port != defaultPort) {
24084:         aOrigin.Append(':');
24084:         aOrigin.AppendInt(port);
24084:       }
24084:     }
24084:   }
24084:   else {
24084:     aOrigin.AssignLiteral("null");
24084:   }
24084:   
24084:   return NS_OK;
24084: }
29226: 
29226: /* static */
29226: already_AddRefed<nsIDocument>
29226: nsContentUtils::GetDocumentFromScriptContext(nsIScriptContext *aScriptContext)
29226: {
29226:   if (!aScriptContext)
29226:     return nsnull;
29226: 
29226:   nsCOMPtr<nsIDOMWindow> window =
29226:     do_QueryInterface(aScriptContext->GetGlobalObject());
29226:   nsIDocument *doc = nsnull;
29226:   if (window) {
29226:     nsCOMPtr<nsIDOMDocument> domdoc;
29226:     window->GetDocument(getter_AddRefs(domdoc));
29226:     if (domdoc) {
29226:       CallQueryInterface(domdoc, &doc);
29226:     }
29226:   }
29226:   return doc;
29226: }
29226: 
43831: /* static */
43831: PRBool
43831: nsContentUtils::CheckMayLoad(nsIPrincipal* aPrincipal, nsIChannel* aChannel)
43831: {
43831:   nsCOMPtr<nsIURI> channelURI;
43831:   nsresult rv = NS_GetFinalChannelURI(aChannel, getter_AddRefs(channelURI));
43831:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
43831: 
43831:   return NS_SUCCEEDED(aPrincipal->CheckMayLoad(channelURI, PR_FALSE));
43831: }
43831: 
22874: nsContentTypeParser::nsContentTypeParser(const nsAString& aString)
22874:   : mString(aString), mService(nsnull)
22874: {
22874:   CallGetService("@mozilla.org/network/mime-hdrparam;1", &mService);
22874: }
22874: 
22874: nsContentTypeParser::~nsContentTypeParser()
22874: {
22874:   NS_IF_RELEASE(mService);
22874: }
22874: 
22874: nsresult
22874: nsContentTypeParser::GetParameter(const char* aParameterName, nsAString& aResult)
22874: {
22874:   NS_ENSURE_TRUE(mService, NS_ERROR_FAILURE);
22874:   return mService->GetParameter(mString, aParameterName,
22874:                                 EmptyCString(), PR_FALSE, nsnull,
22874:                                 aResult);
22874: }
29802: 
29802: /* static */
29802: 
29802: // If you change this code, change also AllowedToAct() in
29802: // XPCSystemOnlyWrapper.cpp!
29802: PRBool
29802: nsContentUtils::CanAccessNativeAnon()
29802: {
29802:   JSContext* cx = nsnull;
29802:   sThreadJSContextStack->Peek(&cx);
29802:   if (!cx) {
29802:     return PR_TRUE;
29802:   }
29802:   JSStackFrame* fp;
29802:   nsIPrincipal* principal =
29802:     sSecurityManager->GetCxSubjectPrincipalAndFrame(cx, &fp);
29802:   NS_ENSURE_TRUE(principal, PR_FALSE);
29802: 
29802:   if (!fp) {
29802:     if (!JS_FrameIterator(cx, &fp)) {
29802:       // No code at all is running. So we must be arriving here as the result
29802:       // of C++ code asking us to do something. Allow access.
29802:       return PR_TRUE;
29802:     }
29802: 
29802:     // Some code is running, we can't make the assumption, as above, but we
29802:     // can't use a native frame, so clear fp.
29802:     fp = nsnull;
53840:   } else if (!JS_IsScriptFrame(cx, fp)) {
31321:     fp = nsnull;
29802:   }
29802: 
29802:   PRBool privileged;
34220:   if (NS_SUCCEEDED(sSecurityManager->IsSystemPrincipal(principal, &privileged)) &&
29802:       privileged) {
34220:     // Chrome things are allowed to touch us.
29802:     return PR_TRUE;
29802:   }
29802: 
29802:   // XXX HACK EWW! Allow chrome://global/ access to these things, even
29802:   // if they've been cloned into less privileged contexts.
29802:   static const char prefix[] = "chrome://global/";
29802:   const char *filename;
53840:   if (fp && JS_IsScriptFrame(cx, fp) &&
53840:       (filename = JS_GetFrameScript(cx, fp)->filename) &&
29802:       !strncmp(filename, prefix, NS_ARRAY_LENGTH(prefix) - 1)) {
29802:     return PR_TRUE;
29802:   }
29802: 
34220:   // Before we throw, check for UniversalXPConnect.
34220:   nsresult rv = sSecurityManager->IsCapabilityEnabled("UniversalXPConnect", &privileged);
34220:   if (NS_SUCCEEDED(rv) && privileged) {
34220:     return PR_TRUE;
34220:   }
34220: 
29802:   return PR_FALSE;
29802: }
29844: 
29844: /* static */ nsresult
29844: nsContentUtils::DispatchXULCommand(nsIContent* aTarget,
29844:                                    PRBool aTrusted,
29844:                                    nsIDOMEvent* aSourceEvent,
29844:                                    nsIPresShell* aShell,
29844:                                    PRBool aCtrl,
29844:                                    PRBool aAlt,
29844:                                    PRBool aShift,
29844:                                    PRBool aMeta)
29844: {
29844:   NS_ENSURE_STATE(aTarget);
29844:   nsIDocument* doc = aTarget->GetOwnerDoc();
29844:   nsCOMPtr<nsIDOMDocumentEvent> docEvent = do_QueryInterface(doc);
29844:   NS_ENSURE_STATE(docEvent);
29844:   nsCOMPtr<nsIDOMEvent> event;
29844:   docEvent->CreateEvent(NS_LITERAL_STRING("xulcommandevent"),
29844:                         getter_AddRefs(event));
29844:   nsCOMPtr<nsIDOMXULCommandEvent> xulCommand = do_QueryInterface(event);
29844:   nsCOMPtr<nsIPrivateDOMEvent> pEvent = do_QueryInterface(xulCommand);
29844:   NS_ENSURE_STATE(pEvent);
29844:   nsCOMPtr<nsIDOMAbstractView> view = do_QueryInterface(doc->GetWindow());
29844:   nsresult rv = xulCommand->InitCommandEvent(NS_LITERAL_STRING("command"),
29844:                                              PR_TRUE, PR_TRUE, view,
29844:                                              0, aCtrl, aAlt, aShift, aMeta,
29844:                                              aSourceEvent);
29844:   NS_ENSURE_SUCCESS(rv, rv);
29844: 
29844:   if (aShell) {
29844:     nsEventStatus status = nsEventStatus_eIgnore;
29844:     nsCOMPtr<nsIPresShell> kungFuDeathGrip = aShell;
29844:     return aShell->HandleDOMEventWithTarget(aTarget, event, &status);
29844:   }
29844: 
29844:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(aTarget);
29844:   NS_ENSURE_STATE(target);
29844:   PRBool dummy;
29844:   return target->DispatchEvent(event, &dummy);
29844: }
31981: 
31981: // static
31981: nsresult
53875: nsContentUtils::WrapNative(JSContext *cx, JSObject *scope, nsISupports *native,
53875:                            nsWrapperCache *cache, const nsIID* aIID, jsval *vp,
31981:                            nsIXPConnectJSObjectHolder **aHolder,
31981:                            PRBool aAllowWrapping)
31981: {
53875:   if (!native) {
53875:     NS_ASSERTION(!aHolder || !*aHolder, "*aHolder should be null!");
53875: 
53875:     *vp = JSVAL_NULL;
53875: 
53875:     return NS_OK;
53875:   }
53875: 
57854:   JSObject *wrapper = xpc_GetCachedSlimWrapper(cache, scope, vp);
57854:   if (wrapper) {
57854:     return NS_OK;
57854:   }
57854: 
31981:   NS_ENSURE_TRUE(sXPConnect && sThreadJSContextStack, NS_ERROR_UNEXPECTED);
31981: 
38447:   // Keep sXPConnect and sThreadJSContextStack alive. If we're on the main
38447:   // thread then this can be done simply and cheaply by adding a reference to
38447:   // nsLayoutStatics. If we're not on the main thread then we need to add a
38447:   // more expensive reference sXPConnect directly. We have to use manual
38447:   // AddRef and Release calls so don't early-exit from this function after we've
38447:   // added the reference!
38447:   PRBool isMainThread = NS_IsMainThread();
38447: 
38447:   if (isMainThread) {
38447:     nsLayoutStatics::AddRef();
38447:   }
38447:   else {
38447:     sXPConnect->AddRef();
38447:   }
31981: 
31981:   JSContext *topJSContext;
31981:   nsresult rv = sThreadJSContextStack->Peek(&topJSContext);
38447:   if (NS_SUCCEEDED(rv)) {
31981:     PRBool push = topJSContext != cx;
31981:     if (push) {
31981:       rv = sThreadJSContextStack->Push(cx);
38447:     }
38447:     if (NS_SUCCEEDED(rv)) {
48171:       rv = sXPConnect->WrapNativeToJSVal(cx, scope, native, cache, aIID,
38447:                                          aAllowWrapping, vp, aHolder);
31981:       if (push) {
31981:         sThreadJSContextStack->Pop(nsnull);
31981:       }
38447:     }
38447:   }
38447: 
38447:   if (isMainThread) {
38447:     nsLayoutStatics::Release();
38447:   }
38447:   else {
38447:     sXPConnect->Release();
38447:   }
31981: 
31981:   return rv;
31981: }
34394: 
38887: void
38887: nsContentUtils::StripNullChars(const nsAString& aInStr, nsAString& aOutStr)
38887: {
38887:   // In common cases where we don't have nulls in the
38887:   // string we can simple simply bypass the checking code.
38887:   PRInt32 firstNullPos = aInStr.FindChar('\0');
38887:   if (firstNullPos == kNotFound) {
38887:     aOutStr.Assign(aInStr);
38887:     return;
38887:   }
38887: 
38887:   aOutStr.SetCapacity(aInStr.Length() - 1);
38887:   nsAString::const_iterator start, end;
38887:   aInStr.BeginReading(start);
38887:   aInStr.EndReading(end);
38887:   while (start != end) {
38887:     if (*start != '\0')
38887:       aOutStr.Append(*start);
38887:     ++start;
38887:   }
38887: }
38887: 
39541: namespace {
39541: 
41512: const unsigned int kCloneStackFrameStackSize = 20;
39541: 
39541: class CloneStackFrame
39541: {
39541:   friend class CloneStack;
39541: 
39541: public:
39541:   // These three jsvals must all stick together as they're treated as a jsval
39541:   // array!
39541:   jsval source;
39541:   jsval clone;
39541:   jsval temp;
40415:   js::AutoIdArray ids;
39541:   jsuint index;
39541: 
39541: private:
39541:   // Only let CloneStack access these.
39541:   CloneStackFrame(JSContext* aCx, jsval aSource, jsval aClone, JSIdArray* aIds)
39541:   : source(aSource), clone(aClone), temp(JSVAL_NULL), ids(aCx, aIds), index(0),
39541:     prevFrame(nsnull),  tvrVals(aCx, 3, &source)
39541:   {
39541:     MOZ_COUNT_CTOR(CloneStackFrame);
39541:   }
39541: 
39541:   ~CloneStackFrame()
39541:   {
39541:     MOZ_COUNT_DTOR(CloneStackFrame);
39541:   }
39541: 
39541:   CloneStackFrame* prevFrame;
40415:   js::AutoArrayRooter tvrVals;
39541: };
39541: 
39541: class CloneStack
39541: {
39541: public:
39541:   CloneStack(JSContext* cx)
39541:   : mCx(cx), mLastFrame(nsnull) {
39541:     mObjectSet.Init();
39541:   }
39541: 
39541:   ~CloneStack() {
39541:     while (!IsEmpty()) {
39541:       Pop();
39541:     }
39541:   }
39541: 
39541:   PRBool
39541:   Push(jsval source, jsval clone, JSIdArray* ids) {
39541:     NS_ASSERTION(!JSVAL_IS_PRIMITIVE(source) && !JSVAL_IS_PRIMITIVE(clone),
39541:                  "Must be an object!");
39541:     if (!ids) {
39541:       return PR_FALSE;
39541:     }
39541: 
39541:     CloneStackFrame* newFrame;
39541:     if (mObjectSet.Count() < kCloneStackFrameStackSize) {
39541:       // If the object can fit in our stack space then use that.
39541:       CloneStackFrame* buf = reinterpret_cast<CloneStackFrame*>(mStackFrames);
39541:       newFrame = new (buf + mObjectSet.Count())
39541:                      CloneStackFrame(mCx, source, clone, ids);
39541:     }
39541:     else {
39541:       // Use the heap.
39541:       newFrame = new CloneStackFrame(mCx, source, clone, ids);
39541:     }
39541: 
39541:     mObjectSet.PutEntry(JSVAL_TO_OBJECT(source));
39541: 
39541:     newFrame->prevFrame = mLastFrame;
39541:     mLastFrame = newFrame;
39541: 
39541:     return PR_TRUE;
39541:   }
39541: 
39541:   CloneStackFrame*
39541:   Peek() {
39541:     return mLastFrame;
39541:   }
39541: 
39541:   void
39541:   Pop() {
39541:     if (IsEmpty()) {
39541:       NS_ERROR("Empty stack!");
39541:       return;
39541:     }
39541: 
39541:     CloneStackFrame* lastFrame = mLastFrame;
39541: 
39541:     mObjectSet.RemoveEntry(JSVAL_TO_OBJECT(lastFrame->source));
39541:     mLastFrame = lastFrame->prevFrame;
39541: 
39541:     if (mObjectSet.Count() >= kCloneStackFrameStackSize) {
39541:       // Only delete if this was a heap object.
39541:       delete lastFrame;
39541:     }
39541:     else {
39541:       // Otherwise just run the destructor.
39541:       lastFrame->~CloneStackFrame();
39541:     }
39541:   }
39541: 
39541:   PRBool
39541:   IsEmpty() {
39541:     NS_ASSERTION((!mLastFrame && !mObjectSet.Count()) ||
39541:                  (mLastFrame && mObjectSet.Count()),
39541:                  "Hashset is out of sync!");
39541:     return mObjectSet.Count() == 0;
39541:   }
39541: 
39541:   PRBool
39541:   Search(JSObject* obj) {
39541:     return !!mObjectSet.GetEntry(obj);
39541:   }
39541: 
39541: private:
39541:   JSContext* mCx;
39541:   CloneStackFrame* mLastFrame;
39541:   nsTHashtable<nsVoidPtrHashKey> mObjectSet;
39541: 
39541:   // Use a char array instead of CloneStackFrame array to prevent the JSAuto*
39541:   // helpers from running until we're ready for them.
39541:   char mStackFrames[kCloneStackFrameStackSize * sizeof(CloneStackFrame)];
39541: };
39541: 
39541: struct ReparentObjectData {
39541:   ReparentObjectData(JSContext* cx, JSObject* obj)
39541:   : cx(cx), obj(obj), ids(nsnull), index(0) { }
39541: 
39541:   ~ReparentObjectData() {
39541:     if (ids) {
39541:       JS_DestroyIdArray(cx, ids);
39541:     }
39541:   }
39541: 
39541:   JSContext* cx;
39541:   JSObject* obj;
39541:   JSIdArray* ids;
39541:   jsint index;
39541: };
39541: 
39541: inline nsresult
39541: SetPropertyOnValueOrObject(JSContext* cx,
39541:                            jsval val,
39541:                            jsval* rval,
39541:                            JSObject* obj,
39541:                            jsid id)
39541: {
39541:   NS_ASSERTION((rval && !obj) || (!rval && obj), "Can only clone to one dest!");
39541:   if (rval) {
39541:     *rval = val;
39541:     return NS_OK;
39541:   }
39541:   if (!JS_DefinePropertyById(cx, obj, id, val, nsnull, nsnull,
39541:                              JSPROP_ENUMERATE)) {
39541:     return NS_ERROR_FAILURE;
39541:   }
39541:   return NS_OK;
39541: }
39541: 
39541: inline JSObject*
39541: CreateEmptyObjectOrArray(JSContext* cx,
39541:                          JSObject* obj)
39541: {
39541:   if (JS_IsArrayObject(cx, obj)) {
39541:     jsuint length;
39541:     if (!JS_GetArrayLength(cx, obj, &length)) {
39541:       NS_ERROR("Failed to get array length?!");
39541:       return nsnull;
39541:     }
39541:     return JS_NewArrayObject(cx, length, NULL);
39541:   }
39541:   return JS_NewObject(cx, NULL, NULL, NULL);
39541: }
39541: 
39541: nsresult
39541: CloneSimpleValues(JSContext* cx,
39541:                   jsval val,
39541:                   jsval* rval,
39541:                   PRBool* wasCloned,
39541:                   JSObject* robj = nsnull,
39541:                   jsid rid = INT_TO_JSID(0))
39541: {
39541:   *wasCloned = PR_TRUE;
39541: 
39541:   // No cloning necessary for these non-GC'd jsvals.
39541:   if (!JSVAL_IS_GCTHING(val) || JSVAL_IS_NULL(val)) {
39541:     return SetPropertyOnValueOrObject(cx, val, rval, robj, rid);
39541:   }
39541: 
39541:   // We'll use immutable strings to prevent copying if we can.
39541:   if (JSVAL_IS_STRING(val)) {
39541:     if (!JS_MakeStringImmutable(cx, JSVAL_TO_STRING(val))) {
39541:       return NS_ERROR_FAILURE;
39541:     }
39541:     return SetPropertyOnValueOrObject(cx, val, rval, robj, rid);
39541:   }
39541: 
42516:   NS_ASSERTION(!JSVAL_IS_PRIMITIVE(val), "Not an object!");
39541:   JSObject* obj = JSVAL_TO_OBJECT(val);
39541: 
41513:   // Dense arrays of primitives can be cloned quickly.
41513:   JSObject* newArray;
41513:   if (!js_CloneDensePrimitiveArray(cx, obj, &newArray)) {
41513:     return NS_ERROR_FAILURE;
41513:   }
41513:   if (newArray) {
41513:     return SetPropertyOnValueOrObject(cx, OBJECT_TO_JSVAL(newArray), rval, robj,
41513:                                       rid);
41513:   }
41513: 
41513:   // Date objects.
41513:   if (js_DateIsValid(cx, obj)) {
41513:     jsdouble msec = js_DateGetMsecSinceEpoch(cx, obj);
41513:     JSObject* newDate;
41513:     if (!(msec  && (newDate = js_NewDateObjectMsec(cx, msec)))) {
41513:       return NS_ERROR_OUT_OF_MEMORY;
41513:     }
41513:     return SetPropertyOnValueOrObject(cx, OBJECT_TO_JSVAL(newDate), rval, robj,
41513:                                       rid);
41513:   }
41513: 
41513:   // RegExp objects.
41513:   if (js_ObjectIsRegExp(obj)) {
41513:     JSObject* proto;
41513:     if (!js_GetClassPrototype(cx, JS_GetScopeChain(cx), JSProto_RegExp,
41513:                               &proto)) {
41513:       return NS_ERROR_FAILURE;
41513:     }
41513:     JSObject* newRegExp = js_CloneRegExpObject(cx, obj, proto);
41513:     if (!newRegExp) {
41513:       return NS_ERROR_FAILURE;
41513:     }
41513:     return SetPropertyOnValueOrObject(cx, OBJECT_TO_JSVAL(newRegExp), rval,
41513:                                       robj, rid);
41513:   }
41513: 
41513:   // Typed array objects.
41513:   if (js_IsTypedArray(obj)) {
41513:     js::TypedArray* src = js::TypedArray::fromJSObject(obj);
41513:     JSObject* newTypedArray = js_CreateTypedArrayWithArray(cx, src->type, obj);
41513:     if (!newTypedArray) {
41513:       return NS_ERROR_FAILURE;
41513:     }
41513:     return SetPropertyOnValueOrObject(cx, OBJECT_TO_JSVAL(newTypedArray), rval,
41513:                                       robj, rid);
41513:   }
41513: 
41513:   // ArrayBuffer objects.
41513:   if (js_IsArrayBuffer(obj)) {
41513:     js::ArrayBuffer* src = js::ArrayBuffer::fromJSObject(obj);
50605:     if (!src) {
50605:       return NS_ERROR_FAILURE;
50605:     }
50605: 
41513:     JSObject* newBuffer = js_CreateArrayBuffer(cx, src->byteLength);
41513:     if (!newBuffer) {
41513:       return NS_ERROR_FAILURE;
41513:     }
41513:     memcpy(js::ArrayBuffer::fromJSObject(newBuffer)->data, src->data,
41513:            src->byteLength);
41513:     return SetPropertyOnValueOrObject(cx, OBJECT_TO_JSVAL(newBuffer), rval,
41513:                                       robj, rid);
41513:   }
41513: 
41513:   // Do we support File?
41513:   // Do we support Blob?
41513:   // Do we support FileList?
41513: 
41513:   // Function objects don't get cloned.
41513:   if (JS_ObjectIsFunction(cx, obj)) {
41513:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
41513:   }
41513: 
41513:   // Security wrapped objects are not allowed either.
56565:   if (obj->isWrapper() && !obj->getClass()->ext.innerObject)
41513:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
41513: 
39541:   // See if this JSObject is backed by some C++ object. If it is then we assume
39541:   // that it is inappropriate to clone.
39541:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
39541:   nsContentUtils::XPConnect()->
39541:     GetWrappedNativeOfJSObject(cx, obj, getter_AddRefs(wrapper));
39541:   if (wrapper) {
41513:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
41513:   }
39541: 
39541:   *wasCloned = PR_FALSE;
39541:   return NS_OK;
39541: }
39541: 
39541: } // anonymous namespace
39541: 
39541: // static
39541: nsresult
39541: nsContentUtils::CreateStructuredClone(JSContext* cx,
39541:                                       jsval val,
39541:                                       jsval* rval)
39541: {
39541:   JSAutoRequest ar(cx);
39541: 
39541:   nsCOMPtr<nsIXPConnect> xpconnect(sXPConnect);
39541:   NS_ENSURE_STATE(xpconnect);
39541: 
39541:   PRBool wasCloned;
39541:   nsresult rv = CloneSimpleValues(cx, val, rval, &wasCloned);
39541:   if (NS_FAILED(rv)) {
39541:     return rv;
39541:   }
39541: 
39541:   if (wasCloned) {
39541:     return NS_OK;
39541:   }
39541: 
39541:   NS_ASSERTION(JSVAL_IS_OBJECT(val), "Not an object?!");
39541:   JSObject* obj = CreateEmptyObjectOrArray(cx, JSVAL_TO_OBJECT(val));
39541:   if (!obj) {
39541:     return NS_ERROR_OUT_OF_MEMORY;
39541:   }
39541: 
39541:   jsval output = OBJECT_TO_JSVAL(obj);
40415:   js::AutoValueRooter tvr(cx, output);
39541: 
39541:   CloneStack stack(cx);
39541:   if (!stack.Push(val, OBJECT_TO_JSVAL(obj),
39541:                   JS_Enumerate(cx, JSVAL_TO_OBJECT(val)))) {
39541:     return NS_ERROR_OUT_OF_MEMORY;
39541:   }
39541: 
39541:   while (!stack.IsEmpty()) {
39541:     CloneStackFrame* frame = stack.Peek();
39541: 
39541:     NS_ASSERTION(!!frame->ids &&
39541:                  frame->ids.length() >= frame->index &&
39541:                  !JSVAL_IS_PRIMITIVE(frame->source) &&
39541:                  !JSVAL_IS_PRIMITIVE(frame->clone),
39541:                  "Bad frame state!");
39541: 
39541:     if (frame->index == frame->ids.length()) {
39541:       // Done cloning this object, pop the frame.
39541:       stack.Pop();
39541:       continue;
39541:     }
39541: 
39541:     // Get the current id and increment the index.
39541:     jsid id = frame->ids[frame->index++];
39541: 
39541:     if (!JS_GetPropertyById(cx, JSVAL_TO_OBJECT(frame->source), id,
39541:                             &frame->temp)) {
39541:       return NS_ERROR_FAILURE;
39541:     }
39541: 
39541:     if (!JSVAL_IS_PRIMITIVE(frame->temp) &&
39541:         stack.Search(JSVAL_TO_OBJECT(frame->temp))) {
39541:       // Spec says to throw this particular exception for cyclical references.
39541:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
39541:     }
39541: 
39541:     JSObject* clone = JSVAL_TO_OBJECT(frame->clone);
39541: 
39541:     PRBool wasCloned;
39541:     nsresult rv = CloneSimpleValues(cx, frame->temp, nsnull, &wasCloned, clone,
39541:                                     id);
39541:     if (NS_FAILED(rv)) {
39541:       return rv;
39541:     }
39541: 
39541:     if (!wasCloned) {
39541:       NS_ASSERTION(JSVAL_IS_OBJECT(frame->temp), "Not an object?!");
39541:       obj = CreateEmptyObjectOrArray(cx, JSVAL_TO_OBJECT(frame->temp));
39541:       if (!obj ||
39541:           !stack.Push(frame->temp, OBJECT_TO_JSVAL(obj),
39541:                       JS_Enumerate(cx, JSVAL_TO_OBJECT(frame->temp)))) {
39541:         return NS_ERROR_OUT_OF_MEMORY;
39541:       }
39541:       // Set the new object as a property of the clone. We'll fill it on the
39541:       // next iteration.
39541:       if (!JS_DefinePropertyById(cx, clone, id, OBJECT_TO_JSVAL(obj), nsnull,
39541:                                  nsnull, JSPROP_ENUMERATE)) {
39541:         return NS_ERROR_FAILURE;
39541:       }
39541:     }
39541:   }
39541: 
39541:   *rval = output;
39541:   return NS_OK;
39541: }
39541: 
39541: // static
39541: nsresult
39541: nsContentUtils::ReparentClonedObjectToScope(JSContext* cx,
39541:                                             JSObject* obj,
39541:                                             JSObject* scope)
39541: {
39541:   JSAutoRequest ar(cx);
39541: 
39541:   scope = JS_GetGlobalForObject(cx, scope);
39541: 
39541:   nsAutoTArray<ReparentObjectData, 20> objectData;
39541:   objectData.AppendElement(ReparentObjectData(cx, obj));
39541: 
39541:   while (!objectData.IsEmpty()) {
39541:     ReparentObjectData& data = objectData[objectData.Length() - 1];
39541: 
42280:     if (!data.ids) {
42280:       NS_ASSERTION(!data.index, "Shouldn't have index here");
42280: 
40555:       // Typed arrays are special and don't need to be enumerated.
40555:       if (js_IsTypedArray(data.obj)) {
40555:         if (!js_ReparentTypedArrayToScope(cx, data.obj, scope)) {
40555:           return NS_ERROR_FAILURE;
40555:         }
40555: 
40555:         // No need to enumerate anything here.
40555:         objectData.RemoveElementAt(objectData.Length() - 1);
40555:         continue;
40555:       }
40555: 
40555:       JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(JS_GET_CLASS(cx, data.obj));
40555:       if (!key) {
39541:         // We should never be reparenting an object that doesn't have a standard
39541:         // proto key.
39541:         return NS_ERROR_FAILURE;
39541:       }
39541: 
40555:       // Fix the prototype and parent first.
39541:       JSObject* proto;
40555:       if (!js_GetClassPrototype(cx, scope, key, &proto) ||
40555:           !JS_SetPrototype(cx, data.obj, proto) ||
40555:           !JS_SetParent(cx, data.obj, scope)) {
39541:         return NS_ERROR_FAILURE;
39541:       }
39541: 
41512:       // Primitive arrays don't need to be enumerated either but the proto and
41512:       // parent needed to be fixed above. Now we can just move on.
41512:       if (js_IsDensePrimitiveArray(data.obj)) {
41512:         objectData.RemoveElementAt(objectData.Length() - 1);
41512:         continue;
41512:       }
41512: 
39541:       // And now enumerate the object's properties.
39541:       if (!(data.ids = JS_Enumerate(cx, data.obj))) {
39541:         return NS_ERROR_FAILURE;
39541:       }
39541:     }
39541: 
39541:     // If we've gone through all the object's properties then we're done with
39541:     // this frame.
39541:     if (data.index == data.ids->length) {
39541:       objectData.RemoveElementAt(objectData.Length() - 1);
39541:       continue;
39541:     }
39541: 
39541:     // Get the id and increment!
39541:     jsid id = data.ids->vector[data.index++];
39541: 
39541:     jsval prop;
39541:     if (!JS_GetPropertyById(cx, data.obj, id, &prop)) {
39541:       return NS_ERROR_FAILURE;
39541:     }
39541: 
39541:     // Push a new frame if this property is an object.
39541:     if (!JSVAL_IS_PRIMITIVE(prop)) {
39541:       objectData.AppendElement(ReparentObjectData(cx, JSVAL_TO_OBJECT(prop)));
39541:     }
39541:   }
39541: 
39541:   return NS_OK;
39541: }
39541: 
41901: struct ClassMatchingInfo {
49575:   nsAttrValue::AtomArray mClasses;
41901:   nsCaseTreatment mCaseTreatment;
41901: };
41901: 
41910: static PRBool
41910: MatchClassNames(nsIContent* aContent, PRInt32 aNamespaceID, nsIAtom* aAtom,
41910:                 void* aData)
41901: {
41901:   // We can't match if there are no class names
41901:   const nsAttrValue* classAttr = aContent->GetClasses();
41901:   if (!classAttr) {
41901:     return PR_FALSE;
41901:   }
41901:   
41901:   // need to match *all* of the classes
41901:   ClassMatchingInfo* info = static_cast<ClassMatchingInfo*>(aData);
49575:   PRUint32 length = info->mClasses.Length();
43324:   if (!length) {
43324:     // If we actually had no classes, don't match.
43324:     return PR_FALSE;
43324:   }
49575:   PRUint32 i;
41901:   for (i = 0; i < length; ++i) {
49575:     if (!classAttr->Contains(info->mClasses[i],
41901:                              info->mCaseTreatment)) {
41901:       return PR_FALSE;
41901:     }
41901:   }
41901:   
41901:   return PR_TRUE;
41901: }
41901: 
41910: static void
41910: DestroyClassNameArray(void* aData)
41901: {
41901:   ClassMatchingInfo* info = static_cast<ClassMatchingInfo*>(aData);
41901:   delete info;
41901: }
41901: 
43324: static void*
43324: AllocClassMatchingInfo(nsINode* aRootNode,
43324:                        const nsString* aClasses)
43324: {
43324:   nsAttrValue attrValue;
43324:   attrValue.ParseAtomArray(*aClasses);
43324:   // nsAttrValue::Equals is sensitive to order, so we'll send an array
43324:   ClassMatchingInfo* info = new ClassMatchingInfo;
43324:   NS_ENSURE_TRUE(info, nsnull);
43324: 
43324:   if (attrValue.Type() == nsAttrValue::eAtomArray) {
49575:     info->mClasses.SwapElements(*(attrValue.GetAtomArrayValue()));
43324:   } else if (attrValue.Type() == nsAttrValue::eAtom) {
49575:     info->mClasses.AppendElement(attrValue.GetAtomValue());
43324:   }
43324: 
43324:   info->mCaseTreatment =
48100:     aRootNode->GetOwnerDoc() &&
43324:     aRootNode->GetOwnerDoc()->GetCompatibilityMode() == eCompatibility_NavQuirks ?
43324:     eIgnoreCase : eCaseMatters;
43324:   return info;
43324: }
43324: 
41910: // static
43324: 
41901: nsresult
41910: nsContentUtils::GetElementsByClassName(nsINode* aRootNode,
41901:                                        const nsAString& aClasses,
41901:                                        nsIDOMNodeList** aReturn)
41901: {
41901:   NS_PRECONDITION(aRootNode, "Must have root node");
41901:   
43324:   nsContentList* elements =
41901:     NS_GetFuncStringContentList(aRootNode, MatchClassNames,
43324:                                 DestroyClassNameArray,
43324:                                 AllocClassMatchingInfo,
41901:                                 aClasses).get();
43324:   NS_ENSURE_TRUE(elements, NS_ERROR_OUT_OF_MEMORY);
41901: 
41901:   // Transfer ownership
41901:   *aReturn = elements;
41901: 
41901:   return NS_OK;
41901: }
41901: 
35272: #ifdef DEBUG
35272: class DebugWrapperTraversalCallback : public nsCycleCollectionTraversalCallback
35272: {
35272: public:
35272:   DebugWrapperTraversalCallback(void* aWrapper) : mFound(PR_FALSE),
35272:                                                   mWrapper(aWrapper)
35272:   {
35272:     mFlags = WANT_ALL_TRACES;
35272:   }
35272: 
35272:   NS_IMETHOD_(void) DescribeNode(CCNodeType type,
35272:                                  nsrefcnt refcount,
35272:                                  size_t objsz,
35272:                                  const char* objname)
35272:   {
35272:   }
35272:   NS_IMETHOD_(void) NoteXPCOMRoot(nsISupports *root)
35272:   {
35272:   }
35272:   NS_IMETHOD_(void) NoteRoot(PRUint32 langID, void* root,
35272:                              nsCycleCollectionParticipant* helper)
35272:   {
35272:   }
35272:   NS_IMETHOD_(void) NoteScriptChild(PRUint32 langID, void* child)
35272:   {
35272:     if (langID == nsIProgrammingLanguage::JAVASCRIPT) {
35272:       mFound = child == mWrapper;
35272:     }
35272:   }
35272:   NS_IMETHOD_(void) NoteXPCOMChild(nsISupports *child)
35272:   {
35272:   }
35272:   NS_IMETHOD_(void) NoteNativeChild(void* child,
35272:                                     nsCycleCollectionParticipant* helper)
35272:   {
35272:   }
35272: 
35272:   NS_IMETHOD_(void) NoteNextEdgeName(const char* name)
35272:   {
35272:   }
35272: 
35272:   PRBool mFound;
35272: 
35272: private:
35272:   void* mWrapper;
35272: };
35272: 
35272: static void
35272: DebugWrapperTraceCallback(PRUint32 langID, void *p, void *closure)
35272: {
35272:   DebugWrapperTraversalCallback* callback =
35272:     static_cast<DebugWrapperTraversalCallback*>(closure);
35272:   callback->NoteScriptChild(langID, p);
35272: }
35272: 
35272: // static
35272: void
35272: nsContentUtils::CheckCCWrapperTraversal(nsISupports* aScriptObjectHolder,
35272:                                         nsWrapperCache* aCache)
35272: {
35272:   nsXPCOMCycleCollectionParticipant* participant;
35272:   CallQueryInterface(aScriptObjectHolder, &participant);
35272: 
35272:   DebugWrapperTraversalCallback callback(aCache->GetWrapper());
35272: 
35272:   participant->Traverse(aScriptObjectHolder, callback);
35272:   NS_ASSERTION(callback.mFound,
35272:                "Cycle collection participant didn't traverse to preserved "
35272:                "wrapper! This will probably crash.");
35272: 
35272:   callback.mFound = PR_FALSE;
35272:   participant->Trace(aScriptObjectHolder, DebugWrapperTraceCallback, &callback);
35272:   NS_ASSERTION(callback.mFound,
35272:                "Cycle collection participant didn't trace preserved wrapper! "
35272:                "This will probably crash.");
35272: }
35272: #endif
35272: 
40208: mozAutoRemovableBlockerRemover::mozAutoRemovableBlockerRemover(nsIDocument* aDocument MOZILLA_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL)
40208: {
40208:   MOZILLA_GUARD_OBJECT_NOTIFIER_INIT;
34394:   mNestingLevel = nsContentUtils::GetRemovableScriptBlockerLevel();
34394:   mDocument = aDocument;
34394:   nsISupports* sink = aDocument ? aDocument->GetCurrentContentSink() : nsnull;
34394:   mObserver = do_QueryInterface(sink);
34394:   for (PRUint32 i = 0; i < mNestingLevel; ++i) {
34394:     if (mObserver) {
34394:       mObserver->EndUpdate(mDocument, UPDATE_CONTENT_MODEL);
34394:     }
34394:     nsContentUtils::RemoveRemovableScriptBlocker();
34394:   }
34394: 
34394:   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(), "killing mutation events");
34394: }
34394: 
34394: mozAutoRemovableBlockerRemover::~mozAutoRemovableBlockerRemover()
34394: {
34394:   NS_ASSERTION(nsContentUtils::GetRemovableScriptBlockerLevel() == 0,
34394:                "Should have had none");
34394:   for (PRUint32 i = 0; i < mNestingLevel; ++i) {
34394:     nsContentUtils::AddRemovableScriptBlocker();
34394:     if (mObserver) {
34394:       mObserver->BeginUpdate(mDocument, UPDATE_CONTENT_MODEL);
34394:     }
34394:   }
34394: }
40694: 
43129: // static
43129: PRBool
55138: nsContentUtils::IsFocusedContent(const nsIContent* aContent)
43129: {
43129:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
43129: 
43129:   return fm && fm->GetFocusedContent() == aContent;
43129: }
43129: 
55189: bool
55189: nsContentUtils::IsSubDocumentTabbable(nsIContent* aContent)
55189: {
55189:   nsIDocument* doc = aContent->GetCurrentDoc();
55189:   if (!doc) {
55189:     return false;
55189:   }
55189: 
55189:   // XXXbz should this use GetOwnerDoc() for GetSubDocumentFor?
55189:   // sXBL/XBL2 issue!
55189:   nsIDocument* subDoc = doc->GetSubDocumentFor(aContent);
55189:   if (!subDoc) {
55189:     return false;
55189:   }
55189: 
55189:   nsCOMPtr<nsISupports> container = subDoc->GetContainer();
55189:   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(container);
55189:   if (!docShell) {
55189:     return false;
55189:   }
55189: 
55189:   nsCOMPtr<nsIContentViewer> contentViewer;
55189:   docShell->GetContentViewer(getter_AddRefs(contentViewer));
55189:   if (!contentViewer) {
55189:     return false;
55189:   }
55189: 
55189:   nsCOMPtr<nsIContentViewer> zombieViewer;
55189:   contentViewer->GetPreviousViewer(getter_AddRefs(zombieViewer));
55189: 
55189:   // If there are 2 viewers for the current docshell, that
55189:   // means the current document is a zombie document.
55189:   // Only navigate into the subdocument if it's not a zombie.
55189:   return !zombieViewer;
55189: }
55189: 
57129: void
57129: nsContentUtils::FlushLayoutForTree(nsIDOMWindow* aWindow)
57129: {
57129:     nsCOMPtr<nsPIDOMWindow> piWin = do_QueryInterface(aWindow);
57129:     if (!piWin)
57129:         return;
57129: 
57129:     // Note that because FlushPendingNotifications flushes parents, this
57129:     // is O(N^2) in docshell tree depth.  However, the docshell tree is
57129:     // usually pretty shallow.
57129: 
57129:     nsCOMPtr<nsIDOMDocument> domDoc;
57129:     aWindow->GetDocument(getter_AddRefs(domDoc));
57129:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
57129:     if (doc) {
57129:         doc->FlushPendingNotifications(Flush_Layout);
57129:     }
57129: 
57129:     nsCOMPtr<nsIDocShellTreeNode> node =
57129:         do_QueryInterface(piWin->GetDocShell());
57129:     if (node) {
57129:         PRInt32 i = 0, i_end;
57129:         node->GetChildCount(&i_end);
57129:         for (; i < i_end; ++i) {
57129:             nsCOMPtr<nsIDocShellTreeItem> item;
57129:             node->GetChildAt(i, getter_AddRefs(item));
57129:             nsCOMPtr<nsIDOMWindow> win = do_GetInterface(item);
57129:             if (win) {
57129:                 FlushLayoutForTree(win);
57129:             }
57129:         }
57129:     }
57129: }
57129: 
40694: void nsContentUtils::RemoveNewlines(nsString &aString)
40694: {
40694:   // strip CR/LF and null
40694:   static const char badChars[] = {'\r', '\n', 0};
40694:   aString.StripChars(badChars);
40694: }
40694: 
42402: void
42402: nsContentUtils::PlatformToDOMLineBreaks(nsString &aString)
40694: {
40694:   if (aString.FindChar(PRUnichar('\r')) != -1) {
40694:     // Windows linebreaks: Map CRLF to LF:
40694:     aString.ReplaceSubstring(NS_LITERAL_STRING("\r\n").get(),
40694:                              NS_LITERAL_STRING("\n").get());
40694: 
40694:     // Mac linebreaks: Map any remaining CR to LF:
40694:     aString.ReplaceSubstring(NS_LITERAL_STRING("\r").get(),
40694:                              NS_LITERAL_STRING("\n").get());
40694:   }
40694: }
40694: 
47767: already_AddRefed<LayerManager>
42402: nsContentUtils::LayerManagerForDocument(nsIDocument *aDoc)
42402: {
42402:   nsIDocument* doc = aDoc;
42402:   nsIDocument* displayDoc = doc->GetDisplayDocument();
42402:   if (displayDoc) {
42402:     doc = displayDoc;
42402:   }
42402: 
46225:   nsIPresShell* shell = doc->GetShell();
42402:   nsCOMPtr<nsISupports> container = doc->GetContainer();
42402:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem = do_QueryInterface(container);
42402:   while (!shell && docShellTreeItem) {
42402:     // We may be in a display:none subdocument, or we may not have a presshell
42402:     // created yet.
42402:     // Walk the docshell tree to find the nearest container that has a presshell,
42402:     // and find the root widget from that.
42402:     nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(docShellTreeItem);
42402:     nsCOMPtr<nsIPresShell> presShell;
42402:     docShell->GetPresShell(getter_AddRefs(presShell));
42402:     if (presShell) {
42402:       shell = presShell;
42402:     } else {
42402:       nsCOMPtr<nsIDocShellTreeItem> parent;
42402:       docShellTreeItem->GetParent(getter_AddRefs(parent));
42402:       docShellTreeItem = parent;
42402:     }
42402:   }
42402: 
42402:   if (shell) {
42402:     nsIFrame* rootFrame = shell->FrameManager()->GetRootFrame();
42402:     if (rootFrame) {
42402:       nsIWidget* widget =
47148:         nsLayoutUtils::GetDisplayRootFrame(rootFrame)->GetNearestWidget();
42402:       if (widget) {
47767:         nsRefPtr<LayerManager> manager = widget->GetLayerManager();
42402:         return manager.forget();
42402:       }
42402:     }
42402:   }
42402: 
47767:   nsRefPtr<LayerManager> manager = new BasicLayerManager();
42402:   return manager.forget();
42402: }
42402: 
58024: bool
58024: nsContentUtils::AllowXULXBLForPrincipal(nsIPrincipal* aPrincipal)
58024: {
58024:   if (IsSystemPrincipal(aPrincipal)) {
58024:     return true;
58024:   }
58024:   
58024:   nsCOMPtr<nsIURI> princURI;
58024:   aPrincipal->GetURI(getter_AddRefs(princURI));
58024:   
58024:   return princURI &&
58024:          ((sAllowXULXBL_for_file && SchemeIs(princURI, "file")) ||
58024:           IsSitePermAllow(princURI, "allowXULXBL"));
58024: }
42402: 
41486: NS_IMPL_ISUPPORTS1(nsIContentUtils, nsIContentUtils)
41486: 
41486: PRBool
41486: nsIContentUtils::IsSafeToRunScript()
41486: {
41486:   return nsContentUtils::IsSafeToRunScript();
41486: }
42402: 
46197: PRBool
46197: nsIContentUtils::ParseIntMarginValue(const nsAString& aString, nsIntMargin& result)
46197: {
46197:   return nsContentUtils::ParseIntMarginValue(aString, result);
46197: }
46197: 
43473: already_AddRefed<nsIDocumentLoaderFactory>
43473: nsIContentUtils::FindInternalContentViewer(const char* aType,
43473:                                            ContentViewerType* aLoaderType)
43473: {
43473:   if (aLoaderType) {
43473:     *aLoaderType = TYPE_UNSUPPORTED;
43473:   }
43473: 
43473:   // one helper factory, please
43473:   nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID));
43473:   if (!catMan)
43473:     return NULL;
43473: 
43473:   nsCOMPtr<nsIDocumentLoaderFactory> docFactory;
43473: 
43473:   nsXPIDLCString contractID;
43473:   nsresult rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", aType, getter_Copies(contractID));
43473:   if (NS_SUCCEEDED(rv)) {
43473:     docFactory = do_GetService(contractID);
43473:     if (docFactory && aLoaderType) {
46415:       if (contractID.EqualsLiteral(CONTENT_DLF_CONTRACTID))
46415:         *aLoaderType = TYPE_CONTENT;
46415:       else if (contractID.EqualsLiteral(PLUGIN_DLF_CONTRACTID))
46415:         *aLoaderType = TYPE_PLUGIN;
46415:       else
46415:       *aLoaderType = TYPE_UNKNOWN;
43473:     }   
43473:     return docFactory.forget();
43473:   }
43473: 
47009: #ifdef MOZ_MEDIA
47009: #ifdef MOZ_OGG
46997:   if (nsHTMLMediaElement::IsOggEnabled()) {
49030:     for (unsigned int i = 0; i < NS_ARRAY_LENGTH(nsHTMLMediaElement::gOggTypes); ++i) {
46997:       const char* type = nsHTMLMediaElement::gOggTypes[i];
46997:       if (!strcmp(aType, type)) {
46997:         docFactory = do_GetService("@mozilla.org/content/document-loader-factory;1");
46997:         if (docFactory && aLoaderType) {
46997:           *aLoaderType = TYPE_CONTENT;
46997:         }
46997:         return docFactory.forget();
46997:       }
46997:     }
46997:   }
47009: #endif
47009: 
47009: #ifdef MOZ_WEBM
47009:   if (nsHTMLMediaElement::IsWebMEnabled()) {
49030:     for (unsigned int i = 0; i < NS_ARRAY_LENGTH(nsHTMLMediaElement::gWebMTypes); ++i) {
47009:       const char* type = nsHTMLMediaElement::gWebMTypes[i];
47009:       if (!strcmp(aType, type)) {
47009:         docFactory = do_GetService("@mozilla.org/content/document-loader-factory;1");
47009:         if (docFactory && aLoaderType) {
47009:           *aLoaderType = TYPE_CONTENT;
47009:         }
47009:         return docFactory.forget();
47009:       }
47009:     }
47009:   }
47009: #endif
47009: #endif // MOZ_MEDIA
46997: 
43473:   return NULL;
43473: }
57651: 
57651: NS_IMPL_ISUPPORTS1(nsIContentUtils2, nsIContentUtils2)
57651: 
57651: nsIInterfaceRequestor*
57651: nsIContentUtils2::GetSameOriginChecker()
57651: {
57651:   return nsContentUtils::GetSameOriginChecker();
57651: }
58548: 
58548: nsresult
58548: nsIContentUtils2::CheckSameOrigin(nsIChannel *aOldChannel, nsIChannel *aNewChannel)
58548: {
58548:   return nsContentUtils::CheckSameOrigin(aOldChannel, aNewChannel);
58548: }
