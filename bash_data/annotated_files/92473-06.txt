    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef nsIHTMLContentSink_h___
    1: #define nsIHTMLContentSink_h___
    1: 
    1: /**
    1:  * This file declares the concrete HTMLContentSink class.
    1:  * This class is used during the parsing process as the
    1:  * primary interface between the parser and the content
    1:  * model.
    1:  *
    1:  * After the tokenizer completes, the parser iterates over
    1:  * the known token list. As the parser identifies valid 
    1:  * elements, it calls the contentsink interface to notify
    1:  * the content model that a new node or child node is being
    1:  * created and added to the content model.
    1:  *
    1:  * The HTMLContentSink interface assumes 4 underlying
    1:  * containers: HTML, HEAD, BODY and FRAMESET. Before 
    1:  * accessing any these, the parser will call the appropriate
    1:  * OpennsIHTMLContentSink method: OpenHTML,OpenHead,OpenBody,OpenFrameSet;
    1:  * likewise, the ClosensIHTMLContentSink version will be called when the
    1:  * parser is done with a given section.
    1:  *
    1:  * IMPORTANT: The parser may Open each container more than
    1:  * once! This is due to the irregular nature of HTML files.
    1:  * For example, it is possible to encounter plain text at
42263:  * the start of an HTML document (that precedes the HTML tag).
    1:  * Such text is treated as if it were part of the body.
    1:  * In such cases, the parser will Open the body, pass the text-
    1:  * node in and then Close the body. The body will likely be
    1:  * re-Opened later when the actual <BODY> tag has been seen.
    1:  *
    1:  * Containers within the body are Opened and Closed
    1:  * using the OpenContainer(...) and CloseContainer(...) calls.
    1:  * It is assumed that the document or contentSink is 
    1:  * maintaining its state to manage where new content should 
    1:  * be added to the underlying document.
    1:  *
    1:  * NOTE: OpenHTML() and OpenBody() may get called multiple times
    1:  *       in the same document. That's fine, and it doesn't mean
    1:  *       that we have multiple bodies or HTML's.
    1:  *
    1:  * NOTE: I haven't figured out how sub-documents (non-frames)
    1:  *       are going to be handled. Stay tuned.
    1:  */
    1: #include "nsIParserNode.h"
    1: #include "nsIContentSink.h"
    1: #include "nsHTMLTags.h"
    1: 
    1: #define NS_IHTML_CONTENT_SINK_IID \
92473: { 0x1cc778ae, 0xcc2b, 0x45e6, \
92473:   { 0x8a, 0x64, 0xa6, 0x80, 0x1a, 0x27, 0x12, 0x4a } }
    1: 
25287: #define MAX_REFLOW_DEPTH  200
    1: 
    1: class nsIHTMLContentSink : public nsIContentSink 
    1: {
    1: public:
    1: 
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IHTML_CONTENT_SINK_IID)
    1: 
    1:   /**
92473:    * Checks is this is an instance of HTMLContentSink.
92473:    */
92473:   virtual bool IsAboutBlank() { return false; }
92473: 
92473:   /**
    1:    * This method is used to open the HEAD container. It is useful if a tag
    1:    * is forcing us to open the head (probably again), like if we find a <meta>
    1:    * tag in the body.
    1:    */
    1:   NS_IMETHOD OpenHead() = 0;
    1: 
    1:   /**
    1:    * This gets called when handling illegal contents, especially
    1:    * in dealing with tables. This method creates a new context.
    1:    * 
    1:    * @update 04/04/99 harishd
    1:    * @param aPosition - The position from where the new context begins.
    1:    */
    1:   NS_IMETHOD BeginContext(PRInt32 aPosition) = 0;
    1:   
    1:   /**
    1:    * This method terminates any new context that got created by
    1:    * BeginContext and switches back to the main context.  
    1:    *
    1:    * @update 04/04/99 harishd
    1:    * @param aPosition - Validates the end of a context.
    1:    */
    1:   NS_IMETHOD EndContext(PRInt32 aPosition) = 0;
    1:   
    1:   /**
    1:    * @update 01/09/2003 harishd
    1:    * @param aTag - Check if this tag is enabled or not.
    1:    */
79445:   NS_IMETHOD IsEnabled(PRInt32 aTag, bool* aReturn) = 0;
    1: 
    1:   /**
    1:    * This method is called when parser has
    1:    * completed processing a chunk of tokens. The processing of the
    1:    * tokens may be interrupted by returning NS_ERROR_HTMLPARSER_INTERRUPTED from
    1:    * DidProcessAToken.
    1:    */
    1:   NS_IMETHOD DidProcessTokens() = 0;
    1: 
    1:   /**
    1:    * This method is called when parser is about to
    1:    * process a single token
    1:    */
    1:   NS_IMETHOD WillProcessAToken(void) = 0;
    1: 
    1:   /**
    1:    * This method is called when parser has completed
    1:    * the processing for a single token.
    1:    * @return NS_OK if processing should not be interrupted
    1:    *         NS_ERROR_HTMLPARSER_INTERRUPTED if the parsing should be interrupted
    1:    */
    1:   NS_IMETHOD DidProcessAToken(void) = 0;
    1: 
    1:     /**
    1:    * This method is used to open a generic container in the sink.
    1:    *
    1:    * @update 4/1/98 gess
    1:    * @param  nsIParserNode reference to parser node interface
    1:    */     
    1:   NS_IMETHOD OpenContainer(const nsIParserNode& aNode) = 0;
    1: 
    1:   /**
    1:    *  This method gets called by the parser when a close
    1:    *  container tag has been consumed and needs to be closed.
    1:    *
    1:    * @param  aTag - The tag to be closed.
    1:    */     
    1:   NS_IMETHOD CloseContainer(const nsHTMLTag aTag) = 0;
    1: 
    1:   /**
    1:    * This method is used when we're closing a tag that was malformed
    1:    * in some way. This way, the content sink can do special processing
    1:    * (e.g., not execute a malformed script tag).
    1:    *
    1:    * @param aTag The tag to be closed.
    1:    */
    1:   NS_IMETHOD CloseMalformedContainer(const nsHTMLTag aTag)
    1:   {
    1:     return CloseContainer(aTag);
    1:   }
    1: 
    1:   /**
    1:    * This gets called by the parser when you want to add
    1:    * a leaf node to the current container in the content
    1:    * model.
    1:    *
    1:    * @update 4/1/98 gess
    1:    * @param  nsIParserNode reference to parser node interface
    1:    */     
    1:   NS_IMETHOD AddLeaf(const nsIParserNode& aNode) = 0;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsIHTMLContentSink, NS_IHTML_CONTENT_SINK_IID)
    1: 
    1: #endif /* nsIHTMLContentSink_h___ */
    1: 
