58638: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
58638: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
31590:  * Portions created by the Initial Developer are Copyright (C) 2005-2009
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
16418:  *   John Daggett <jdaggett@mozilla.com>
31590:  *   Jonathan Kew <jfkthame@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
61084: #ifdef MOZ_LOGGING
61084: #define FORCE_PR_LOG /* Allow logging in the release build */
61084: #endif
61084: #include "prlog.h"
61084: 
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsReadableUtils.h"
  323: #include "nsExpirationTracker.h"
38492: #include "nsILanguageAtomService.h"
82849: #include "nsIMemoryReporter.h"
86698: #include "nsITimer.h"
    1: 
    1: #include "gfxFont.h"
    1: #include "gfxPlatform.h"
38493: #include "gfxAtoms.h"
    1: 
    1: #include "prtypes.h"
    1: #include "gfxTypes.h"
72496: #include "nsAlgorithm.h"
    1: #include "gfxContext.h"
  132: #include "gfxFontMissingGlyphs.h"
19962: #include "gfxUserFontSet.h"
31590: #include "gfxPlatformFontList.h"
43525: #include "gfxScriptItemizer.h"
90890: #include "nsUnicodeProperties.h"
 1295: #include "nsMathUtils.h"
19962: #include "nsBidiUtils.h"
37211: #include "nsUnicodeRange.h"
41493: #include "nsCompressedCharMap.h"
69311: #include "nsStyleConsts.h"
71640: #include "mozilla/Preferences.h"
87228: #include "mozilla/Services.h"
90151: #include "mozilla/Telemetry.h"
    1: 
    1: #include "cairo.h"
    1: #include "gfxFontTest.h"
    1: 
43526: #include "harfbuzz/hb-blob.h"
43526: 
    1: #include "nsCRT.h"
    1: 
86663: #include <algorithm>
86663: 
47309: using namespace mozilla;
86663: using namespace mozilla::gfx;
90890: using namespace mozilla::unicode;
87228: using mozilla::services::GetObserverService;
47309: 
  323: gfxFontCache *gfxFontCache::gGlobalCache = nsnull;
  323: 
 3011: #ifdef DEBUG_roc
 3011: #define DEBUG_TEXT_RUN_STORAGE_METRICS
 3011: #endif
 3011: 
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005: static PRUint32 gTextRunStorageHighWaterMark = 0;
 3005: static PRUint32 gTextRunStorage = 0;
 6513: static PRUint32 gFontCount = 0;
 6513: static PRUint32 gGlyphExtentsCount = 0;
 6513: static PRUint32 gGlyphExtentsWidthsTotalSize = 0;
 6513: static PRUint32 gGlyphExtentsSetupEagerSimple = 0;
 6513: static PRUint32 gGlyphExtentsSetupEagerTight = 0;
 6513: static PRUint32 gGlyphExtentsSetupLazyTight = 0;
 6513: static PRUint32 gGlyphExtentsSetupFallBackToTight = 0;
 3005: #endif
 3005: 
19962: gfxFontEntry::~gfxFontEntry() 
19962: {
19962:     delete mUserFontData;
16418: }
16418: 
79445: bool gfxFontEntry::IsSymbolFont() 
70100: {
70100:     return mSymbolFont;
70100: }
70100: 
79445: bool gfxFontEntry::TestCharacterMap(PRUint32 aCh)
31590: {
31590:     if (!mCmapInitialized) {
31590:         ReadCMAP();
31590:     }
16418:     return mCharacterMap.test(aCh);
16418: }
16418: 
42989: nsresult gfxFontEntry::InitializeUVSMap()
42989: {
42989:     // mUVSOffset will not be initialized
42989:     // until cmap is initialized.
42989:     if (!mCmapInitialized) {
42989:         ReadCMAP();
42989:     }
42989: 
42989:     if (!mUVSOffset) {
42989:         return NS_ERROR_FAILURE;
42989:     }
42989: 
42989:     if (!mUVSData) {
42989:         const PRUint32 kCmapTag = TRUETYPE_TAG('c','m','a','p');
60098:         AutoFallibleTArray<PRUint8,16384> buffer;
42989:         if (GetFontTable(kCmapTag, buffer) != NS_OK) {
42989:             mUVSOffset = 0; // don't bother to read the table again
42989:             return NS_ERROR_FAILURE;
42989:         }
42989: 
42989:         PRUint8* uvsData;
42989:         nsresult rv = gfxFontUtils::ReadCMAPTableFormat14(
42989:                           buffer.Elements() + mUVSOffset,
42989:                           buffer.Length() - mUVSOffset,
42989:                           uvsData);
42989:         if (NS_FAILED(rv)) {
42989:             mUVSOffset = 0; // don't bother to read the table again
42989:             return rv;
42989:         }
42989: 
42989:         mUVSData = uvsData;
42989:     }
42989: 
42989:     return NS_OK;
42989: }
42989: 
42989: PRUint16 gfxFontEntry::GetUVSGlyph(PRUint32 aCh, PRUint32 aVS)
42989: {
42989:     InitializeUVSMap();
42989: 
42989:     if (mUVSData) {
42989:         return gfxFontUtils::MapUVSToGlyphFormat14(mUVSData, aCh, aVS);
42989:     }
42989: 
42989:     return 0;
42989: }
42989: 
31590: nsresult gfxFontEntry::ReadCMAP()
16418: {
80486:     mCmapInitialized = true;
31590:     return NS_OK;
31590: }
31590: 
71910: nsString gfxFontEntry::FamilyName() const
31590: {
71910:     NS_ASSERTION(mFamily, "orphaned font entry");
71910:     if (mFamily) {
31590:         return mFamily->Name();
71910:     } else {
71910:         return nsString();
71910:     }
71867: }
71867: 
71914: nsString
71914: gfxFontEntry::RealFaceName()
71914: {
71914:     FallibleTArray<PRUint8> nameTable;
71914:     nsresult rv = GetFontTable(TRUETYPE_TAG('n','a','m','e'), nameTable);
71914:     if (NS_SUCCEEDED(rv)) {
71914:         nsAutoString name;
71914:         rv = gfxFontUtils::GetFullNameFromTable(nameTable, name);
71914:         if (NS_SUCCEEDED(rv)) {
71914:             return name;
71914:         }
71914:     }
71914:     return Name();
71914: }
71914: 
37211: already_AddRefed<gfxFont>
79445: gfxFontEntry::FindOrMakeFont(const gfxFontStyle *aStyle, bool aNeedsBold)
37211: {
37211:     // the font entry name is the psname, not the family name
47360:     nsRefPtr<gfxFont> font = gfxFontCache::GetCache()->Lookup(this, aStyle);
43347: 
37211:     if (!font) {
37211:         gfxFont *newFont = CreateFontInstance(aStyle, aNeedsBold);
37211:         if (!newFont)
37211:             return nsnull;
37211:         if (!newFont->Valid()) {
37211:             delete newFont;
37211:             return nsnull;
37211:         }
37211:         font = newFont;
37211:         gfxFontCache::GetCache()->AddNew(font);
37211:     }
37211:     gfxFont *f = nsnull;
37211:     font.swap(f);
37211:     return f;
37211: }
37211: 
58248: /**
58248:  * FontTableBlobData
58248:  *
58248:  * See FontTableHashEntry for the general strategy.
58248:  */
58248: 
58248: class gfxFontEntry::FontTableBlobData {
58248: public:
58248:     // Adopts the content of aBuffer.
58248:     // Pass a non-null aHashEntry only if it should be cleared if/when this
58248:     // FontTableBlobData is deleted.
60098:     FontTableBlobData(FallibleTArray<PRUint8>& aBuffer,
58248:                       FontTableHashEntry *aHashEntry)
58248:         : mHashEntry(aHashEntry), mHashtable()
43526:     {
58248:         MOZ_COUNT_CTOR(FontTableBlobData);
58248:         mTableData.SwapElements(aBuffer);
58248:     }
58248: 
58248:     ~FontTableBlobData() {
58248:         MOZ_COUNT_DTOR(FontTableBlobData);
58248:         if (mHashEntry) {
58248:             if (mHashtable) {
58248:                 mHashtable->RemoveEntry(mHashEntry->GetKey());
58248:             } else {
58248:                 mHashEntry->Clear();
58248:             }
58248:         }
58248:     }
58248: 
58248:     // Useful for creating blobs
58248:     const char *GetTable() const
58248:     {
58248:         return reinterpret_cast<const char*>(mTableData.Elements());
58248:     }
58248:     PRUint32 GetTableLength() const { return mTableData.Length(); }
58248: 
58248:     // Tell this FontTableBlobData to remove the HashEntry when this is
58248:     // destroyed.
58248:     void ManageHashEntry(nsTHashtable<FontTableHashEntry> *aHashtable)
58248:     {
58248:         mHashtable = aHashtable;
58248:     }
58248: 
58248:     // Disconnect from the HashEntry (because the blob has already been
58248:     // removed from the hashtable).
58248:     void ForgetHashEntry()
58248:     {
58248:         mHashEntry = nsnull;
58248:     }
58248: 
58248: private:
58248:     // The font table data block, owned (via adoption)
60098:     FallibleTArray<PRUint8> mTableData;
58248:     // The blob destroy function needs to know the hashtable entry,
58248:     FontTableHashEntry *mHashEntry;
58248:     // and the owning hashtable, so that it can remove the entry.
58248:     nsTHashtable<FontTableHashEntry> *mHashtable;
58248: 
58248:     // not implemented
58248:     FontTableBlobData(const FontTableBlobData&);
58248: };
58248: 
58248: void
60098: gfxFontEntry::FontTableHashEntry::SaveTable(FallibleTArray<PRUint8>& aTable)
58248: {
58248:     Clear();
58248:     // adopts elements of aTable
58248:     FontTableBlobData *data = new FontTableBlobData(aTable, nsnull);
58248:     mBlob = hb_blob_create(data->GetTable(), data->GetTableLength(),
43526:                            HB_MEMORY_MODE_READONLY,
90072:                            data, DeleteFontTableBlobData);    
58248: }
58248: 
58248: hb_blob_t *
58248: gfxFontEntry::FontTableHashEntry::
60098: ShareTableAndGetBlob(FallibleTArray<PRUint8>& aTable,
58248:                      nsTHashtable<FontTableHashEntry> *aHashtable)
58248: {
58248:     Clear();
58248:     // adopts elements of aTable
58248:     mSharedBlobData = new FontTableBlobData(aTable, this);
58248:     mBlob = hb_blob_create(mSharedBlobData->GetTable(),
58248:                            mSharedBlobData->GetTableLength(),
58248:                            HB_MEMORY_MODE_READONLY,
90072:                            mSharedBlobData, DeleteFontTableBlobData);
58248:     if (!mSharedBlobData) {
58248:         // The FontTableBlobData was destroyed during hb_blob_create().
58248:         // The (empty) blob is still be held in the hashtable with a strong
58248:         // reference.
58248:         return hb_blob_reference(mBlob);
58248:     }
58248: 
58248:     // Tell the FontTableBlobData to remove this hash entry when destroyed.
58248:     // The hashtable does not keep a strong reference.
58248:     mSharedBlobData->ManageHashEntry(aHashtable);
58248:     return mBlob;
58248: }
58248: 
58248: void
58248: gfxFontEntry::FontTableHashEntry::Clear()
58248: {
58248:     // If the FontTableBlobData is managing the hash entry, then the blob is
58248:     // not owned by this HashEntry; otherwise there is strong reference to the
58248:     // blob that must be removed.
58248:     if (mSharedBlobData) {
58248:         mSharedBlobData->ForgetHashEntry();
58248:         mSharedBlobData = nsnull;
58248:     } else if (mBlob) {
58248:         hb_blob_destroy(mBlob);
58248:     }
58248:     mBlob = nsnull;
58248: }
58248: 
58248: // a hb_destroy_func for hb_blob_create
43526: 
43526: /* static */ void
58248: gfxFontEntry::FontTableHashEntry::DeleteFontTableBlobData(void *aBlobData)
43526: {
58248:     delete static_cast<FontTableBlobData*>(aBlobData);
58248: }
58248: 
58248: hb_blob_t *
58248: gfxFontEntry::FontTableHashEntry::GetBlob() const
58248: {
58248:     return hb_blob_reference(mBlob);
43526: }
43526: 
79445: bool
58944: gfxFontEntry::GetExistingFontTable(PRUint32 aTag, hb_blob_t **aBlob)
43526: {
43526:     if (!mFontTableCache.IsInitialized()) {
43526:         // we do this here rather than on fontEntry construction
43526:         // because not all shapers will access the table cache at all
43526:         mFontTableCache.Init(10);
43526:     }
43526: 
58248:     FontTableHashEntry *entry = mFontTableCache.GetEntry(aTag);
58944:     if (!entry) {
80486:         return false;
58944:     }
58944: 
58944:     *aBlob = entry->GetBlob();
80486:     return true;
58944: }
58944: 
58944: hb_blob_t *
58944: gfxFontEntry::ShareFontTableAndGetBlob(PRUint32 aTag,
60098:                                        FallibleTArray<PRUint8>* aBuffer)
58944: {
58944:     if (NS_UNLIKELY(!mFontTableCache.IsInitialized())) {
58944:         // we do this here rather than on fontEntry construction
58944:         // because not all shapers will access the table cache at all
58944:         mFontTableCache.Init(10);
58944:     }
58944: 
58944:     FontTableHashEntry *entry = mFontTableCache.PutEntry(aTag);
58248:     if (NS_UNLIKELY(!entry)) { // OOM
58248:         return nsnull;
58248:     }
58248: 
58944:     if (!aBuffer) {
58944:         // ensure the entry is null
58944:         entry->Clear();
58944:         return nsnull;
58944:     }
58944: 
58944:     return entry->ShareTableAndGetBlob(*aBuffer, &mFontTableCache);
43526: }
43526: 
84392: #ifdef MOZ_GRAPHITE
84392: void
84392: gfxFontEntry::CheckForGraphiteTables()
84392: {
84392:     AutoFallibleTArray<PRUint8,16384> buffer;
84392:     mHasGraphiteTables =
84392:         NS_SUCCEEDED(GetFontTable(TRUETYPE_TAG('S','i','l','f'), buffer));
84392: }
84392: #endif
84392: 
43526: //////////////////////////////////////////////////////////////////////////////
43526: //
43526: // class gfxFontFamily
43526: //
43526: //////////////////////////////////////////////////////////////////////////////
43526: 
80486: // we consider faces with mStandardFace == true to be "greater than" those with false,
31590: // because during style matching, later entries will replace earlier ones
31590: class FontEntryStandardFaceComparator {
31590:   public:
79445:     bool Equals(const nsRefPtr<gfxFontEntry>& a, const nsRefPtr<gfxFontEntry>& b) const {
31590:         return a->mStandardFace == b->mStandardFace;
31590:     }
79445:     bool LessThan(const nsRefPtr<gfxFontEntry>& a, const nsRefPtr<gfxFontEntry>& b) const {
80486:         return (a->mStandardFace == false && b->mStandardFace == true);
31590:     }
31590: };
31590: 
31590: void
31590: gfxFontFamily::SortAvailableFonts()
31590: {
31590:     mAvailableFonts.Sort(FontEntryStandardFaceComparator());
31590: }
31590: 
79445: bool
31590: gfxFontFamily::HasOtherFamilyNames()
31590: {
31590:     // need to read in other family names to determine this
31590:     if (!mOtherFamilyNamesInitialized) {
37618:         ReadOtherFamilyNames(gfxPlatformFontList::PlatformFontList());  // sets mHasOtherFamilyNames
31590:     }
31590:     return mHasOtherFamilyNames;
31590: }
31590: 
31590: gfxFontEntry*
39307: gfxFontFamily::FindFontForStyle(const gfxFontStyle& aFontStyle, 
79445:                                 bool& aNeedsSyntheticBold)
31590: {
31590:     if (!mHasStyles)
31590:         FindStyleVariations(); // collect faces for the family, if not already done
31590: 
31590:     NS_ASSERTION(mAvailableFonts.Length() > 0, "font family with no faces!");
16418: 
80486:     aNeedsSyntheticBold = false;
16418: 
57239:     PRInt8 baseWeight = aFontStyle.ComputeWeight();
79445:     bool wantBold = baseWeight >= 6;
31590: 
31590:     // If the family has only one face, we simply return it; no further checking needed
31590:     if (mAvailableFonts.Length() == 1) {
31590:         gfxFontEntry *fe = mAvailableFonts[0];
39307:         aNeedsSyntheticBold = wantBold && !fe->IsBold();
31590:         return fe;
31590:     }
31590: 
79445:     bool wantItalic = (aFontStyle.style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0;
31590: 
31590:     // Most families are "simple", having just Regular/Bold/Italic/BoldItalic,
31590:     // or some subset of these. In this case, we have exactly 4 entries in mAvailableFonts,
31590:     // stored in the above order; note that some of the entries may be NULL.
31590:     // We can then pick the required entry based on whether the request is for
31590:     // bold or non-bold, italic or non-italic, without running the more complex
31590:     // matching algorithm used for larger families with many weights and/or widths.
31590: 
31590:     if (mIsSimpleFamily) {
31590:         // Family has no more than the "standard" 4 faces, at fixed indexes;
31590:         // calculate which one we want.
31590:         // Note that we cannot simply return it as not all 4 faces are necessarily present.
31590:         PRUint8 faceIndex = (wantItalic ? kItalicMask : 0) |
31590:                             (wantBold ? kBoldMask : 0);
31590: 
31590:         // if the desired style is available, return it directly
31590:         gfxFontEntry *fe = mAvailableFonts[faceIndex];
31590:         if (fe) {
39307:             // no need to set aNeedsSyntheticBold here as we matched the boldness request
31590:             return fe;
31590:         }
31590: 
31590:         // order to check fallback faces in a simple family, depending on requested style
31590:         static const PRUint8 simpleFallbacks[4][3] = {
31590:             { kBoldFaceIndex, kItalicFaceIndex, kBoldItalicFaceIndex },   // fallbacks for Regular
31590:             { kRegularFaceIndex, kBoldItalicFaceIndex, kItalicFaceIndex },// Bold
31590:             { kBoldItalicFaceIndex, kRegularFaceIndex, kBoldFaceIndex },  // Italic
31590:             { kItalicFaceIndex, kBoldFaceIndex, kRegularFaceIndex }       // BoldItalic
31590:         };
31590:         const PRUint8 *order = simpleFallbacks[faceIndex];
31590: 
31590:         for (PRUint8 trial = 0; trial < 3; ++trial) {
31590:             // check remaining faces in order of preference to find the first that actually exists
31590:             fe = mAvailableFonts[order[trial]];
31590:             if (fe) {
39307:                 aNeedsSyntheticBold = wantBold && !fe->IsBold();
31590:                 return fe;
31590:             }
31590:         }
31590: 
31590:         // this can't happen unless we have totally broken the font-list manager!
31590:         NS_NOTREACHED("no face found in simple font family!");
31590:         return nsnull;
31590:     }
31590: 
31590:     // This is a large/rich font family, so we do full style- and weight-matching:
31590:     // first collect a list of weights that are the best match for the requested
31590:     // font-stretch and font-style, then pick the best weight match among those
31590:     // available.
31590: 
31590:     gfxFontEntry *weightList[10] = { 0 };
79445:     bool foundWeights = FindWeightsForStyle(weightList, wantItalic, aFontStyle.stretch);
31590:     if (!foundWeights) {
31590:         return nsnull;
31590:     }
16418: 
48283:     // First find a match for the best weight
16418:     PRInt8 matchBaseWeight = 0;
48283:     PRInt8 i = baseWeight;
48283: 
48283:     // Need to special case when normal face doesn't exist but medium does.
48283:     // In that case, use medium otherwise weights < 400
48283:     if (baseWeight == 4 && !weightList[4]) {
48283:         i = 5; // medium
48283:     }
48283: 
48283:     // Loop through weights, since one exists loop will terminate
16418:     PRInt8 direction = (baseWeight > 5) ? 1 : -1;
48283:     for (; ; i += direction) {
16418:         if (weightList[i]) {
16418:             matchBaseWeight = i;
16418:             break;
16418:         }
16418: 
48283:         // If we've reached one side without finding a font,
48283:         // start over and go the other direction until we find a match
31590:         if (i == 1 || i == 9) {
48283:             i = baseWeight;
16418:             direction = -direction;
16418:         }
31590:     }
16418: 
48283:     NS_ASSERTION(matchBaseWeight != 0, 
48283:                  "weight mapping should always find at least one font in a family");
48283: 
48283:     gfxFontEntry *matchFE = weightList[matchBaseWeight];
48283: 
48283:     NS_ASSERTION(matchFE,
48283:                  "weight mapping should always find at least one font in a family");
39307: 
57239:     if (!matchFE->IsBold() && baseWeight >= 6)
39307:     {
80486:         aNeedsSyntheticBold = true;
16418:     }
16418: 
16418:     return matchFE;
16418: }
16418: 
31590: void
31590: gfxFontFamily::CheckForSimpleFamily()
31590: {
78722:     PRUint32 count = mAvailableFonts.Length();
78722:     if (count > 4 || count == 0) {
38059:         return; // can't be "simple" if there are >4 faces;
38059:                 // if none then the family is unusable anyway
31590:     }
31590: 
78722:     if (count == 1) {
80486:         mIsSimpleFamily = true;
78722:         return;
78722:     }
78722: 
31590:     PRInt16 firstStretch = mAvailableFonts[0]->Stretch();
31590: 
31590:     gfxFontEntry *faces[4] = { 0 };
78722:     for (PRUint8 i = 0; i < count; ++i) {
31590:         gfxFontEntry *fe = mAvailableFonts[i];
31590:         if (fe->Stretch() != firstStretch) {
31590:             return; // font-stretch doesn't match, don't treat as simple family
31590:         }
31590:         PRUint8 faceIndex = (fe->IsItalic() ? kItalicMask : 0) |
31590:                             (fe->Weight() >= 600 ? kBoldMask : 0);
31590:         if (faces[faceIndex]) {
31590:             return; // two faces resolve to the same slot; family isn't "simple"
31590:         }
31590:         faces[faceIndex] = fe;
31590:     }
31590: 
31590:     // we have successfully slotted the available faces into the standard
31590:     // 4-face framework
31590:     mAvailableFonts.SetLength(4);
31590:     for (PRUint8 i = 0; i < 4; ++i) {
31590:         if (mAvailableFonts[i].get() != faces[i]) {
31590:             mAvailableFonts[i].swap(faces[i]);
31590:         }
31590:     }
31590: 
80486:     mIsSimpleFamily = true;
31590: }
31590: 
31590: static inline PRUint32
31590: StyleDistance(gfxFontEntry *aFontEntry,
79445:               bool anItalic, PRInt16 aStretch)
31590: {
31590:     // Compute a measure of the "distance" between the requested style
31590:     // and the given fontEntry,
31590:     // considering italicness and font-stretch but not weight.
31590: 
77857:     PRInt32 distance = 0;
77857:     if (aStretch != aFontEntry->mStretch) {
77857:         // stretch values are in the range -4 .. +4
77857:         // if aStretch is positive, we prefer more-positive values;
77857:         // if zero or negative, prefer more-negative
77857:         if (aStretch > 0) {
77857:             distance = (aFontEntry->mStretch - aStretch) * 2;
77857:         } else {
77857:             distance = (aStretch - aFontEntry->mStretch) * 2;
77857:         }
77857:         // if the computed "distance" here is negative, it means that
77857:         // aFontEntry lies in the "non-preferred" direction from aStretch,
77857:         // so we treat that as larger than any preferred-direction distance
77857:         // (max possible is 8) by adding an extra 10 to the absolute value
77857:         if (distance < 0) {
77857:             distance = -distance + 10;
77857:         }
77857:     }
77857:     if (aFontEntry->IsItalic() != anItalic) {
77857:         distance += 1;
77857:     }
77857:     return PRUint32(distance);
31590: }
31590: 
79445: bool
31590: gfxFontFamily::FindWeightsForStyle(gfxFontEntry* aFontsForWeights[],
79445:                                    bool anItalic, PRInt16 aStretch)
31590: {
31590:     PRUint32 foundWeights = 0;
31590:     PRUint32 bestMatchDistance = 0xffffffff;
31590: 
31590:     for (PRUint32 i = 0; i < mAvailableFonts.Length(); i++) {
31590:         // this is not called for "simple" families, and therefore it does not
31590:         // need to check the mAvailableFonts entries for NULL
31590:         gfxFontEntry *fe = mAvailableFonts[i];
31590:         PRUint32 distance = StyleDistance(fe, anItalic, aStretch);
31590:         if (distance <= bestMatchDistance) {
31590:             PRInt8 wt = fe->mWeight / 100;
31590:             NS_ASSERTION(wt >= 1 && wt < 10, "invalid weight in fontEntry");
31590:             if (!aFontsForWeights[wt]) {
31590:                 // record this as a possible candidate for weight matching
31590:                 aFontsForWeights[wt] = fe;
31590:                 ++foundWeights;
31590:             } else {
77857:                 PRUint32 prevDistance =
77857:                     StyleDistance(aFontsForWeights[wt], anItalic, aStretch);
31590:                 if (prevDistance >= distance) {
77857:                     // replacing a weight we already found,
77857:                     // so don't increment foundWeights
31590:                     aFontsForWeights[wt] = fe;
31590:                 }
31590:             }
31590:             bestMatchDistance = distance;
31590:         }
31590:     }
31590: 
31590:     NS_ASSERTION(foundWeights > 0, "Font family containing no faces?");
31590: 
31590:     if (foundWeights == 1) {
31590:         // no need to cull entries if we only found one weight
80486:         return true;
31590:     }
31590: 
31590:     // we might have recorded some faces that were a partial style match, but later found
31590:     // others that were closer; in this case, we need to cull the poorer matches from the
31590:     // weight list we'll return
31590:     for (PRUint32 i = 0; i < 10; ++i) {
31590:         if (aFontsForWeights[i] &&
31590:             StyleDistance(aFontsForWeights[i], anItalic, aStretch) > bestMatchDistance)
31590:         {
31590:             aFontsForWeights[i] = 0;
31590:         }
31590:     }
31590: 
31590:     return (foundWeights > 0);
31590: }
31590: 
31590: 
31590: void gfxFontFamily::LocalizedName(nsAString& aLocalizedName)
31590: {
31590:     // just return the primary name; subclasses should override
31590:     aLocalizedName = mName;
31590: }
31590: 
91871: // metric for how close a given font matches a style
91871: static PRInt32
91871: CalcStyleMatch(gfxFontEntry *aFontEntry, const gfxFontStyle *aStyle)
91871: {
91871:     PRInt32 rank = 0;
91871:     if (aStyle) {
91871:          // italics
91871:          bool wantItalic =
91871:              ((aStyle->style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0);
91871:          if (aFontEntry->IsItalic() == wantItalic) {
91871:              rank += 10;
91871:          }
91871: 
91871:         // measure of closeness of weight to the desired value
91871:         rank += 9 - abs(aFontEntry->Weight() / 100 - aStyle->ComputeWeight());
91871:     } else {
91871:         // if no font to match, prefer non-bold, non-italic fonts
91871:         if (!aFontEntry->IsItalic()) {
91871:             rank += 3;
91871:         }
91871:         if (!aFontEntry->IsBold()) {
91871:             rank += 2;
91871:         }
91871:     }
91871: 
91871:     return rank;
91871: }
91871: 
91871: #define RANK_MATCHED_CMAP   20
31590: 
31590: void
91870: gfxFontFamily::FindFontForChar(GlobalFontMatch *aMatchData)
31590: {
91870:     if (mCharacterMapInitialized && !TestCharacterMap(aMatchData->mCh)) {
90084:         // none of the faces in the family support the required char,
90084:         // so bail out immediately
90084:         return;
90084:     }
31590: 
91870:     bool needsBold;
91870:     gfxFontStyle normal;
91870:     gfxFontEntry *fe = FindFontForStyle(
91870:                   (aMatchData->mStyle == nsnull) ? *aMatchData->mStyle : normal,
91870:                   needsBold);
91870: 
91870:     if (fe && !fe->SkipDuringSystemFallback()) {
31590:         PRInt32 rank = 0;
31590: 
31590:         if (fe->TestCharacterMap(aMatchData->mCh)) {
91871:             rank += RANK_MATCHED_CMAP;
61084:             aMatchData->mCount++;
61084: #ifdef PR_LOGGING
61084:             PRLogModuleInfo *log = gfxPlatform::GetLog(eGfxLog_textrun);
61084: 
61084:             if (NS_UNLIKELY(log)) {
61084:                 PRUint32 charRange = gfxFontUtils::CharRangeBit(aMatchData->mCh);
61084:                 PRUint32 unicodeRange = FindCharUnicodeRange(aMatchData->mCh);
90890:                 PRUint32 script = GetScriptCode(aMatchData->mCh);
61084:                 PR_LOG(log, PR_LOG_DEBUG,\
61084:                        ("(textrun-systemfallback-fonts) char: u+%6.6x "
61084:                         "char-range: %d unicode-range: %d script: %d match: [%s]\n",
61084:                         aMatchData->mCh,
90072:                         charRange, unicodeRange, script,
61084:                         NS_ConvertUTF16toUTF8(fe->Name()).get()));
61084:             }
61084: #endif
31590:         }
31590: 
91870:         aMatchData->mCmapsTested++;
91870:         if (rank == 0) {
91870:             return;
91870:         }
31590: 
31590:          // omitting from original windows code -- family name, lang group, pitch
31590:          // not available in current FontEntry implementation
91871:         rank += CalcStyleMatch(fe, aMatchData->mStyle);
31590: 
31590:         // xxx - add whether AAT font with morphing info for specific lang groups
31590: 
31590:         if (rank > aMatchData->mMatchRank
31590:             || (rank == aMatchData->mMatchRank &&
31590:                 Compare(fe->Name(), aMatchData->mBestMatch->Name()) > 0))
31590:         {
31590:             aMatchData->mBestMatch = fe;
31590:             aMatchData->mMatchRank = rank;
31590:         }
31590:     }
31590: }
31590: 
91871: void
91871: gfxFontFamily::SearchAllFontsForChar(GlobalFontMatch *aMatchData)
91871: {
91871:     PRUint32 i, numFonts = mAvailableFonts.Length();
91871:     for (i = 0; i < numFonts; i++) {
91871:         gfxFontEntry *fe = mAvailableFonts[i];
91871:         if (fe && fe->TestCharacterMap(aMatchData->mCh)) {
91871:             PRInt32 rank = RANK_MATCHED_CMAP;
91871:             rank += CalcStyleMatch(fe, aMatchData->mStyle);
91871:             if (rank > aMatchData->mMatchRank
91871:                 || (rank == aMatchData->mMatchRank &&
91871:                     Compare(fe->Name(), aMatchData->mBestMatch->Name()) > 0))
91871:             {
91871:                 aMatchData->mBestMatch = fe;
91871:                 aMatchData->mMatchRank = rank;
91871:             }
91871:         }
91871:     }
91871: }
91871: 
31590: // returns true if other names were found, false otherwise
79445: bool
37618: gfxFontFamily::ReadOtherFamilyNamesForFace(gfxPlatformFontList *aPlatformFontList,
60098:                                            FallibleTArray<PRUint8>& aNameTable,
79445:                                            bool useFullName)
31590: {
37618:     const PRUint8 *nameData = aNameTable.Elements();
37618:     PRUint32 dataLength = aNameTable.Length();
31590:     const gfxFontUtils::NameHeader *nameHeader =
31590:         reinterpret_cast<const gfxFontUtils::NameHeader*>(nameData);
31590: 
31590:     PRUint32 nameCount = nameHeader->count;
31590:     if (nameCount * sizeof(gfxFontUtils::NameRecord) > dataLength) {
31590:         NS_WARNING("invalid font (name records)");
80486:         return false;
31590:     }
31590:     
31590:     const gfxFontUtils::NameRecord *nameRecord =
31590:         reinterpret_cast<const gfxFontUtils::NameRecord*>(nameData + sizeof(gfxFontUtils::NameHeader));
31590:     PRUint32 stringsBase = PRUint32(nameHeader->stringOffset);
31590: 
79445:     bool foundNames = false;
31590:     for (PRUint32 i = 0; i < nameCount; i++, nameRecord++) {
31590:         PRUint32 nameLen = nameRecord->length;
31590:         PRUint32 nameOff = nameRecord->offset;  // offset from base of string storage
31590: 
31590:         if (stringsBase + nameOff + nameLen > dataLength) {
31590:             NS_WARNING("invalid font (name table strings)");
80486:             return false;
31590:         }
31590: 
31590:         PRUint16 nameID = nameRecord->nameID;
31590:         if ((useFullName && nameID == gfxFontUtils::NAME_ID_FULL) ||
31590:             (!useFullName && (nameID == gfxFontUtils::NAME_ID_FAMILY ||
31590:                               nameID == gfxFontUtils::NAME_ID_PREFERRED_FAMILY))) {
31590:             nsAutoString otherFamilyName;
79445:             bool ok = gfxFontUtils::DecodeFontName(nameData + stringsBase + nameOff,
31590:                                                      nameLen,
31590:                                                      PRUint32(nameRecord->platformID),
31590:                                                      PRUint32(nameRecord->encodingID),
31590:                                                      PRUint32(nameRecord->languageID),
31590:                                                      otherFamilyName);
31590:             // add if not same as canonical family name
31590:             if (ok && otherFamilyName != mName) {
37618:                 aPlatformFontList->AddOtherFamilyName(this, otherFamilyName);
80486:                 foundNames = true;
31590:             }
31590:         }
31590:     }
31590: 
31590:     return foundNames;
31590: }
31590: 
31590: 
31590: void
37618: gfxFontFamily::ReadOtherFamilyNames(gfxPlatformFontList *aPlatformFontList)
31590: {
31590:     if (mOtherFamilyNamesInitialized) 
31590:         return;
80486:     mOtherFamilyNamesInitialized = true;
31590: 
35525:     FindStyleVariations();
35525: 
31590:     // read in other family names for the first face in the list
37618:     PRUint32 i, numFonts = mAvailableFonts.Length();
37618:     const PRUint32 kNAME = TRUETYPE_TAG('n','a','m','e');
60098:     AutoFallibleTArray<PRUint8,8192> buffer;
37618: 
31590:     for (i = 0; i < numFonts; ++i) {
37618:         gfxFontEntry *fe = mAvailableFonts[i];
37618:         if (!fe)
31590:             continue;
37618: 
37618:         if (fe->GetFontTable(kNAME, buffer) != NS_OK)
37618:             continue;
37618: 
37618:         mHasOtherFamilyNames = ReadOtherFamilyNamesForFace(aPlatformFontList,
37618:                                                            buffer);
31590:         break;
31590:     }
31590: 
31590:     // read in other names for the first face in the list with the assumption
31590:     // that if extra names don't exist in that face then they don't exist in
31590:     // other faces for the same font
37618:     if (!mHasOtherFamilyNames) 
37618:         return;
37618: 
31590:     // read in names for all faces, needed to catch cases where fonts have
31590:     // family names for individual weights (e.g. Hiragino Kaku Gothic Pro W6)
31590:     for ( ; i < numFonts; i++) {
37618:         gfxFontEntry *fe = mAvailableFonts[i];
37618:         if (!fe)
31590:             continue;
37618: 
37618:         if (fe->GetFontTable(kNAME, buffer) != NS_OK)
37618:             continue;
37618: 
37618:         ReadOtherFamilyNamesForFace(aPlatformFontList, buffer);
37618:     }
37618: }
37618: 
37618: void
37618: gfxFontFamily::ReadFaceNames(gfxPlatformFontList *aPlatformFontList, 
79445:                              bool aNeedFullnamePostscriptNames)
37618: {
37618:     // if all needed names have already been read, skip
37618:     if (mOtherFamilyNamesInitialized &&
37618:         (mFaceNamesInitialized || !aNeedFullnamePostscriptNames))
37618:         return;
37618: 
37618:     FindStyleVariations();
37618: 
37618:     PRUint32 i, numFonts = mAvailableFonts.Length();
37618:     const PRUint32 kNAME = TRUETYPE_TAG('n','a','m','e');
60098:     AutoFallibleTArray<PRUint8,8192> buffer;
37618:     nsAutoString fullname, psname;
37618: 
79445:     bool firstTime = true, readAllFaces = false;
37618:     for (i = 0; i < numFonts; ++i) {
37618:         gfxFontEntry *fe = mAvailableFonts[i];
37618:         if (!fe)
37618:             continue;
37618: 
37618:         if (fe->GetFontTable(kNAME, buffer) != NS_OK)
37618:             continue;
37618: 
37618:         if (aNeedFullnamePostscriptNames) {
37618:             if (gfxFontUtils::ReadCanonicalName(
37618:                     buffer, gfxFontUtils::NAME_ID_FULL, fullname) == NS_OK)
37618:             {
37618:                 aPlatformFontList->AddFullname(fe, fullname);
37618:             }
37618: 
37618:             if (gfxFontUtils::ReadCanonicalName(
37618:                     buffer, gfxFontUtils::NAME_ID_POSTSCRIPT, psname) == NS_OK)
37618:             {
37618:                 aPlatformFontList->AddPostscriptName(fe, psname);
37618:             }
37618:         }
37618: 
37618:        if (!mOtherFamilyNamesInitialized && (firstTime || readAllFaces)) {
79445:            bool foundOtherName = ReadOtherFamilyNamesForFace(aPlatformFontList,
37618:                                                                buffer);
37618: 
37618:            // if the first face has a different name, scan all faces, otherwise
37618:            // assume the family doesn't have other names
37618:            if (firstTime && foundOtherName) {
80486:                mHasOtherFamilyNames = true;
80486:                readAllFaces = true;
80486:            }
80486:            firstTime = false;
37618:        }
37618: 
37618:        // if not reading in any more names, skip other faces
37618:        if (!readAllFaces && !aNeedFullnamePostscriptNames)
37618:            break;
37618:     }
37618: 
80486:     mFaceNamesInitialized = true;
80486:     mOtherFamilyNamesInitialized = true;
31590: }
31590: 
31590: 
31590: gfxFontEntry*
31590: gfxFontFamily::FindFont(const nsAString& aPostscriptName)
31590: {
31590:     // find the font using a simple linear search
31590:     PRUint32 numFonts = mAvailableFonts.Length();
31590:     for (PRUint32 i = 0; i < numFonts; i++) {
31590:         gfxFontEntry *fe = mAvailableFonts[i].get();
31590:         if (fe && fe->Name() == aPostscriptName)
31590:             return fe;
31590:     }
31590:     return nsnull;
31590: }
31590: 
87228: /*
87228:  * gfxFontCache - global cache of gfxFont instances.
87228:  * Expires unused fonts after a short interval;
87228:  * notifies fonts to age their cached shaped-word records;
87228:  * observes memory-pressure notification and tells fonts to clear their
87228:  * shaped-word caches to free up memory.
87228:  */
87228: 
87228: // Observer for the memory-pressure notification, to trigger
87228: // flushing of the shaped-word caches
87228: class MemoryPressureObserver : public nsIObserver,
87228:                                public nsSupportsWeakReference
87228: {
87228: public:
87228:     NS_DECL_ISUPPORTS
87228:     NS_DECL_NSIOBSERVER
87228: };
87228: 
87228: NS_IMPL_ISUPPORTS2(MemoryPressureObserver, nsIObserver, nsISupportsWeakReference)
87228: 
87228: NS_IMETHODIMP
87228: MemoryPressureObserver::Observe(nsISupports *aSubject,
87228:                                 const char *aTopic,
87228:                                 const PRUnichar *someData)
87228: {
87228:     if (!nsCRT::strcmp(aTopic, "memory-pressure")) {
87228:         gfxFontCache *fontCache = gfxFontCache::GetCache();
87228:         if (fontCache) {
87228:             fontCache->FlushShapedWordCaches();
87228:         }
87228:     }
87228:     return NS_OK;
87228: }
31590: 
  323: nsresult
  323: gfxFontCache::Init()
  323: {
  323:     NS_ASSERTION(!gGlobalCache, "Where did this come from?");
  323:     gGlobalCache = new gfxFontCache();
  323:     return gGlobalCache ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
  323: }
  323: 
  323: void
  323: gfxFontCache::Shutdown()
  323: {
  323:     delete gGlobalCache;
  323:     gGlobalCache = nsnull;
 3005: 
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005:     printf("Textrun storage high water mark=%d\n", gTextRunStorageHighWaterMark);
 6513:     printf("Total number of fonts=%d\n", gFontCount);
 6513:     printf("Total glyph extents allocated=%d (size %d)\n", gGlyphExtentsCount,
 6513:             int(gGlyphExtentsCount*sizeof(gfxGlyphExtents)));
 6513:     printf("Total glyph extents width-storage size allocated=%d\n", gGlyphExtentsWidthsTotalSize);
 6513:     printf("Number of simple glyph extents eagerly requested=%d\n", gGlyphExtentsSetupEagerSimple);
 6513:     printf("Number of tight glyph extents eagerly requested=%d\n", gGlyphExtentsSetupEagerTight);
 6513:     printf("Number of tight glyph extents lazily requested=%d\n", gGlyphExtentsSetupLazyTight);
 6513:     printf("Number of simple glyph extent setups that fell back to tight=%d\n", gGlyphExtentsSetupFallBackToTight);
 3005: #endif
  323: }
  323: 
86698: gfxFontCache::gfxFontCache()
86698:     : nsExpirationTracker<gfxFont,3>(FONT_TIMEOUT_SECONDS * 1000)
86698: {
86698:     mFonts.Init();
87228: 
87228:     nsCOMPtr<nsIObserverService> obs = GetObserverService();
87228:     if (obs) {
87228:         obs->AddObserver(new MemoryPressureObserver, "memory-pressure", false);
87228:     }
87228: 
92373: #if 0 // disabled due to crashiness, see bug 717175
86698:     mWordCacheExpirationTimer = do_CreateInstance("@mozilla.org/timer;1");
86698:     if (mWordCacheExpirationTimer) {
86698:         mWordCacheExpirationTimer->
86698:             InitWithFuncCallback(WordCacheExpirationTimerCallback, this,
86698:                                  SHAPED_WORD_TIMEOUT_SECONDS * 1000,
86698:                                  nsITimer::TYPE_REPEATING_SLACK);
86698:     }
92373: #endif
86698: }
86698: 
86698: gfxFontCache::~gfxFontCache()
86698: {
86698:     if (mWordCacheExpirationTimer) {
86698:         mWordCacheExpirationTimer->Cancel();
86698:         mWordCacheExpirationTimer = nsnull;
86698:     }
86698: 
86698:     // Expire everything that has a zero refcount, so we don't leak them.
86698:     AgeAllGenerations();
86698:     // All fonts should be gone.
86698:     NS_WARN_IF_FALSE(mFonts.Count() == 0,
86698:                      "Fonts still alive while shutting down gfxFontCache");
86698:     // Note that we have to delete everything through the expiration
86698:     // tracker, since there might be fonts not in the hashtable but in
86698:     // the tracker.
86698: }
86698: 
79445: bool
  323: gfxFontCache::HashEntry::KeyEquals(const KeyTypePointer aKey) const
  323: {
47360:     return aKey->mFontEntry == mFont->GetFontEntry() &&
  323:            aKey->mStyle->Equals(*mFont->GetStyle());
  323: }
  323: 
  323: already_AddRefed<gfxFont>
47360: gfxFontCache::Lookup(const gfxFontEntry *aFontEntry,
  323:                      const gfxFontStyle *aStyle)
  323: {
47360:     Key key(aFontEntry, aStyle);
  323:     HashEntry *entry = mFonts.GetEntry(key);
90158: 
90158:     Telemetry::Accumulate(Telemetry::FONT_CACHE_HIT, entry != nsnull);
  323:     if (!entry)
  323:         return nsnull;
  323: 
  323:     gfxFont *font = entry->mFont;
  323:     NS_ADDREF(font);
  323:     return font;
  323: }
  323: 
  323: void
  323: gfxFontCache::AddNew(gfxFont *aFont)
  323: {
47360:     Key key(aFont->GetFontEntry(), aFont->GetStyle());
  323:     HashEntry *entry = mFonts.PutEntry(key);
  323:     if (!entry)
  323:         return;
10514:     gfxFont *oldFont = entry->mFont;
10514:     entry->mFont = aFont;
10514:     // If someone's asked us to replace an existing font entry, then that's a
10514:     // bit weird, but let it happen, and expire the old font if it's not used.
10514:     if (oldFont && oldFont->GetExpirationState()->IsTracked()) {
10514:         // if oldFont == aFont, recount should be > 0,
10514:         // so we shouldn't be here.
10514:         NS_ASSERTION(aFont != oldFont, "new font is tracked for expiry!");
10514:         NotifyExpired(oldFont);
  323:     }
  323: }
  323: 
  323: void
  323: gfxFontCache::NotifyReleased(gfxFont *aFont)
  323: {
  323:     nsresult rv = AddObject(aFont);
  323:     if (NS_FAILED(rv)) {
  323:         // We couldn't track it for some reason. Kill it now.
  323:         DestroyFont(aFont);
  323:     }
  323:     // Note that we might have fonts that aren't in the hashtable, perhaps because
  323:     // of OOM adding to the hashtable or because someone did an AddNew where
  323:     // we already had a font. These fonts are added to the expiration tracker
  323:     // anyway, even though Lookup can't resurrect them. Eventually they will
  323:     // expire and be deleted.
  323: }
  323: 
  323: void
  323: gfxFontCache::NotifyExpired(gfxFont *aFont)
  323: {
90494:     aFont->ClearCachedWords();
  323:     RemoveObject(aFont);
  323:     DestroyFont(aFont);
  323: }
  323: 
  323: void
  323: gfxFontCache::DestroyFont(gfxFont *aFont)
  323: {
47360:     Key key(aFont->GetFontEntry(), aFont->GetStyle());
10514:     HashEntry *entry = mFonts.GetEntry(key);
10514:     if (entry && entry->mFont == aFont)
  323:         mFonts.RemoveEntry(key);
10514:     NS_ASSERTION(aFont->GetRefCount() == 0,
10514:                  "Destroying with non-zero ref count!");
  323:     delete aFont;
  323: }
  323: 
86698: /*static*/
86698: PLDHashOperator
86698: gfxFontCache::AgeCachedWordsForFont(HashEntry* aHashEntry, void* aUserData)
86698: {
86698:     aHashEntry->mFont->AgeCachedWords();
86698:     return PL_DHASH_NEXT;
86698: }
86698: 
86698: /*static*/
86698: void
86698: gfxFontCache::WordCacheExpirationTimerCallback(nsITimer* aTimer, void* aCache)
86698: {
86698:     gfxFontCache* cache = static_cast<gfxFontCache*>(aCache);
86698:     cache->mFonts.EnumerateEntries(AgeCachedWordsForFont, nsnull);
86698: }
86698: 
87228: /*static*/
87228: PLDHashOperator
87228: gfxFontCache::ClearCachedWordsForFont(HashEntry* aHashEntry, void* aUserData)
87228: {
87228:     aHashEntry->mFont->ClearCachedWords();
87228:     return PL_DHASH_NEXT;
87228: }
87228: 
16581: void
79445: gfxFont::RunMetrics::CombineWith(const RunMetrics& aOther, bool aOtherIsOnLeft)
16581: {
72496:     mAscent = NS_MAX(mAscent, aOther.mAscent);
72496:     mDescent = NS_MAX(mDescent, aOther.mDescent);
16581:     if (aOtherIsOnLeft) {
16581:         mBoundingBox =
16581:             (mBoundingBox + gfxPoint(aOther.mAdvanceWidth, 0)).Union(aOther.mBoundingBox);
16581:     } else {
16581:         mBoundingBox =
16581:             mBoundingBox.Union(aOther.mBoundingBox + gfxPoint(mAdvanceWidth, 0));
16581:     }
16581:     mAdvanceWidth += aOther.mAdvanceWidth;
16581: }
16581: 
39447: gfxFont::gfxFont(gfxFontEntry *aFontEntry, const gfxFontStyle *aFontStyle,
84651:                  AntialiasOption anAAOption, cairo_scaled_font_t *aScaledFont) :
84651:     mScaledFont(aScaledFont),
80486:     mFontEntry(aFontEntry), mIsValid(true),
80486:     mApplySyntheticBold(false),
43527:     mStyle(*aFontStyle),
43527:     mAdjustedSize(0.0),
43527:     mFUnitsConvFactor(0.0f),
84392:     mAntialiasOption(anAAOption)
    1: {
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:     ++gFontCount;
 6513: #endif
    1: }
    1: 
 6247: gfxFont::~gfxFont()
 6247: {
 6247:     PRUint32 i;
 6247:     // We destroy the contents of mGlyphExtentsArray explicitly instead of
 6247:     // using nsAutoPtr because VC++ can't deal with nsTArrays of nsAutoPtrs
 6247:     // of classes that lack a proper copy constructor
 6247:     for (i = 0; i < mGlyphExtentsArray.Length(); ++i) {
 6247:         delete mGlyphExtentsArray[i];
 6247:     }
 6247: }
 6247: 
86698: /*static*/
86698: PLDHashOperator
86698: gfxFont::AgeCacheEntry(CacheHashEntry *aEntry, void *aUserData)
86698: {
86698:     if (!aEntry->mShapedWord) {
86698:         NS_ASSERTION(aEntry->mShapedWord, "cache entry has no gfxShapedWord!");
86698:         return PL_DHASH_REMOVE;
86698:     }
86698:     if (aEntry->mShapedWord->IncrementAge() == kShapedWordCacheMaxAge) {
86698:         return PL_DHASH_REMOVE;
86698:     }
86698:     return PL_DHASH_NEXT;
86698: }
86698: 
58944: hb_blob_t *
58944: gfxFont::GetFontTable(PRUint32 aTag) {
58944:     hb_blob_t *blob;
58944:     if (mFontEntry->GetExistingFontTable(aTag, &blob))
58944:         return blob;
58944: 
60098:     FallibleTArray<PRUint8> buffer;
79445:     bool haveTable = NS_SUCCEEDED(mFontEntry->GetFontTable(aTag, buffer));
58944: 
58944:     return mFontEntry->ShareFontTableAndGetBlob(aTag,
58944:                                                 haveTable ? &buffer : nsnull);
58944: }
58944: 
    1: /**
    1:  * A helper function in case we need to do any rounding or other
    1:  * processing here.
    1:  */
18764: #define ToDeviceUnits(aAppUnits, aDevUnitsPerAppUnit) \
18764:     (double(aAppUnits)*double(aDevUnitsPerAppUnit))
    1: 
 3594: struct GlyphBuffer {
 3594: #define GLYPH_BUFFER_SIZE (2048/sizeof(cairo_glyph_t))
 3594:     cairo_glyph_t mGlyphBuffer[GLYPH_BUFFER_SIZE];
 3594:     unsigned int mNumGlyphs;
 3594: 
 3594:     GlyphBuffer()
 3594:         : mNumGlyphs(0) { }
 3594: 
 3594:     cairo_glyph_t *AppendGlyph() {
 3594:         return &mGlyphBuffer[mNumGlyphs++];
 3594:     }
 3594: 
89450:     void Flush(cairo_t *aCR, cairo_pattern_t *aStrokePattern,
89450:                gfxFont::DrawMode aDrawMode, bool aReverse,
79445:                bool aFinish = false) {
78197:         // Ensure there's enough room for a glyph to be added to the buffer
78197:         if (!aFinish && mNumGlyphs < GLYPH_BUFFER_SIZE) {
 3594:             return;
78197:         }
 3594: 
18764:         if (aReverse) {
18764:             for (PRUint32 i = 0; i < mNumGlyphs/2; ++i) {
18764:                 cairo_glyph_t tmp = mGlyphBuffer[i];
18764:                 mGlyphBuffer[i] = mGlyphBuffer[mNumGlyphs - 1 - i];
18764:                 mGlyphBuffer[mNumGlyphs - 1 - i] = tmp;
18764:             }
18764:         }
88295: 
88295:         if (aDrawMode == gfxFont::GLYPH_PATH) {
18764:             cairo_glyph_path(aCR, mGlyphBuffer, mNumGlyphs);
88295:         } else {
88295:             if (aDrawMode & gfxFont::GLYPH_FILL) {
18764:                 cairo_show_glyphs(aCR, mGlyphBuffer, mNumGlyphs);
88295:             }
88295: 
88295:             if (aDrawMode & gfxFont::GLYPH_STROKE) {
89450:                 if (aStrokePattern) {
89450:                     cairo_save(aCR);
89450:                     cairo_set_source(aCR, aStrokePattern);
89450:                 }
89450: 
88295:                 cairo_new_path(aCR);
88295:                 cairo_glyph_path(aCR, mGlyphBuffer, mNumGlyphs);
88295:                 cairo_stroke(aCR);
89450: 
89450:                 if (aStrokePattern) {
89450:                     cairo_restore(aCR);
89450:                 }
88295:             }
88295:         }
 3594: 
 3594:         mNumGlyphs = 0;
 3594:     }
 3594: #undef GLYPH_BUFFER_SIZE
 3594: };
 3594: 
86663: struct GlyphBufferAzure {
86663: #define GLYPH_BUFFER_SIZE (2048/sizeof(Glyph))
86663:     Glyph mGlyphBuffer[GLYPH_BUFFER_SIZE];
86663:     unsigned int mNumGlyphs;
86663: 
86663:     GlyphBufferAzure()
86663:         : mNumGlyphs(0) { }
86663: 
86663:     Glyph *AppendGlyph() {
86663:         return &mGlyphBuffer[mNumGlyphs++];
86663:     }
86663: 
86663:     void Flush(DrawTarget *aDT, Pattern &aPattern, ScaledFont *aFont,
88295:                gfxFont::DrawMode aDrawMode, bool aReverse, bool aFinish = false)
86663:     {
86663:         // Ensure there's enough room for a glyph to be added to the buffer
86663:         if (!aFinish && mNumGlyphs < GLYPH_BUFFER_SIZE || !mNumGlyphs) {
86663:             return;
86663:         }
86663: 
86663:         if (aReverse) {
86663:             Glyph *begin = &mGlyphBuffer[0];
86663:             Glyph *end = &mGlyphBuffer[mNumGlyphs];
86663:             std::reverse(begin, end);
86663:         }
86663:         
88295:         NS_ASSERTION(aDrawMode != gfxFont::GLYPH_FILL, "Not supported yet.");
86663:         
86663:         gfx::GlyphBuffer buf;
86663:         buf.mGlyphs = mGlyphBuffer;
86663:         buf.mNumGlyphs = mNumGlyphs;
86663: 
86663:         aDT->FillGlyphs(aFont, buf, aPattern);
86663: 
86663:         mNumGlyphs = 0;
86663:     }
86663: #undef GLYPH_BUFFER_SIZE
86663: };
86663: 
77795: // Bug 674909. When synthetic bolding text by drawing twice, need to
77795: // render using a pixel offset in device pixels, otherwise text
77795: // doesn't appear bolded, it appears as if a bad text shadow exists
77795: // when a non-identity transform exists.  Use an offset factor so that
77795: // the second draw occurs at a constant offset in device pixels.
77795: 
86696: double
86696: gfxFont::CalcXScale(gfxContext *aContext)
77795: {
77795:     // determine magnitude of a 1px x offset in device space
77795:     gfxSize t = aContext->UserToDevice(gfxSize(1.0, 0.0));
77795:     if (t.width == 1.0 && t.height == 0.0) {
77795:         // short-circuit the most common case to avoid sqrt() and division
77795:         return 1.0;
77795:     }
77795: 
77795:     double m = sqrt(t.width * t.width + t.height * t.height);
77795: 
77795:     NS_ASSERTION(m != 0.0, "degenerate transform while synthetic bolding");
77795:     if (m == 0.0) {
77795:         return 0.0; // effectively disables offset
77795:     }
77795: 
77795:     // scale factor so that offsets are 1px in device pixels
77795:     return 1.0 / m;
77795: }
77795: 
    1: void
    1: gfxFont::Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,
88295:               gfxContext *aContext, DrawMode aDrawMode, gfxPoint *aPt,
89450:               Spacing *aSpacing, gfxPattern *aStrokePattern)
    1: {
88295:     NS_ASSERTION(aDrawMode <= gfxFont::GLYPH_PATH, "GLYPH_PATH cannot be used with GLYPH_FILL or GLYPH_STROKE");
88295: 
89450:     // We have to multiply the stroke matrix by the context matrix as cairo
89450:     // multiplies by the inverse of the context matrix when the pattern is set
89450:     gfxMatrix strokeMatrix;
89450:     if (aStrokePattern) {
89450:         strokeMatrix = aStrokePattern->GetMatrix();
89450:         aStrokePattern->SetMatrix(aContext->CurrentMatrix().Multiply(strokeMatrix));
89450:     }
89450: 
    1:     if (aStart >= aEnd)
    1:         return;
    1: 
    1:     const gfxTextRun::CompressedGlyph *charGlyphs = aTextRun->GetCharacterGlyphs();
    1:     const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();
    1:     const double devUnitsPerAppUnit = 1.0/double(appUnitsPerDevUnit);
79445:     bool isRTL = aTextRun->IsRightToLeft();
    1:     double direction = aTextRun->GetDirection();
77795: 
77795:     // synthetic-bold strikes are each offset one device pixel in run direction
77795:     // (these values are only needed if IsSyntheticBold() is true)
82849:     double synBoldOnePixelOffset = 0;
82849:     PRInt32 strikes = 0;
77795:     if (IsSyntheticBold()) {
77795:         double xscale = CalcXScale(aContext);
77795:         synBoldOnePixelOffset = direction * xscale;
77795:         // use as many strikes as needed for the the increased advance
77795:         strikes = NS_lroundf(GetSyntheticBoldOffset() / xscale);
77795:     }
77795: 
    1:     PRUint32 i;
    1:     // Current position in appunits
    1:     double x = aPt->x;
    1:     double y = aPt->y;
    1: 
86663:     cairo_t *cr = aContext->GetCairo();
86663:     RefPtr<DrawTarget> dt = aContext->GetDrawTarget();
89450:     cairo_pattern_t *strokePattern = nsnull;
89450:     if (aStrokePattern) {
89450:         strokePattern = aStrokePattern->CairoPattern();
89450:     }
86663: 
86663:     RefPtr<ScaledFont> scaledFont;
86663: 
86663:     gfxRGBA color;
86663:     ColorPattern colPat(Color(0, 0, 0, 0));
86663: 
86663:     if (aContext->IsCairo()) {
79445:       bool success = SetupCairoFont(aContext);
 4304:       if (NS_UNLIKELY(!success))
 4304:           return;
 3594: 
86663:       ::GlyphBuffer glyphs;
 3594:       cairo_glyph_t *glyph;
 3594: 
    1:       if (aSpacing) {
    1:           x += direction*aSpacing[0].mBefore;
    1:       }
    1:       for (i = aStart; i < aEnd; ++i) {
    1:           const gfxTextRun::CompressedGlyph *glyphData = &charGlyphs[i];
    1:           if (glyphData->IsSimpleGlyph()) {
 3594:               glyph = glyphs.AppendGlyph();
    1:               glyph->index = glyphData->GetSimpleGlyph();
    1:               double advance = glyphData->GetSimpleAdvance();
    1:               // Perhaps we should put a scale in the cairo context instead of
    1:               // doing this scaling here...
    1:               // Multiplying by the reciprocal may introduce tiny error here,
    1:               // but we assume cairo is going to round coordinates at some stage
    1:               // and this is faster
18764:               double glyphX;
    1:               if (isRTL) {
    1:                   x -= advance;
18764:                   glyphX = x;
    1:               } else {
18764:                   glyphX = x;
    1:                   x += advance;
    1:               }
18764:               glyph->x = ToDeviceUnits(glyphX, devUnitsPerAppUnit);
18764:               glyph->y = ToDeviceUnits(y, devUnitsPerAppUnit);
89450:               glyphs.Flush(cr, strokePattern, aDrawMode, isRTL);
13339:             
77795:               // synthetic bolding by multi-striking with 1-pixel offsets
77795:               // at least once, more if there's room (large font sizes)
77795:               if (IsSyntheticBold()) {
77795:                   double strikeOffset = synBoldOnePixelOffset;
77795:                   PRInt32 strikeCount = strikes;
77795:                   do {
13339:                       cairo_glyph_t *doubleglyph;
13339:                       doubleglyph = glyphs.AppendGlyph();
13339:                       doubleglyph->index = glyph->index;
18764:                       doubleglyph->x =
77795:                           ToDeviceUnits(glyphX + strikeOffset * appUnitsPerDevUnit,
18764:                                         devUnitsPerAppUnit);
13339:                       doubleglyph->y = glyph->y;
77795:                       strikeOffset += synBoldOnePixelOffset;
89450:                       glyphs.Flush(cr, strokePattern, aDrawMode, isRTL);
77795:                   } while (--strikeCount > 0);
13339:               }
 7715:           } else {
 7715:               PRUint32 glyphCount = glyphData->GetGlyphCount();
62288:               if (glyphCount > 0) {
62288:                   const gfxTextRun::DetailedGlyph *details =
62288:                       aTextRun->GetDetailedGlyphs(i);
62288:                   NS_ASSERTION(details, "detailedGlyph should not be missing!");
62288:                   for (PRUint32 j = 0; j < glyphCount; ++j, ++details) {
    1:                       double advance = details->mAdvance;
 7715:                       if (glyphData->IsMissing()) {
41493:                           // default ignorable characters will have zero advance width.
41493:                           // we don't have to draw the hexbox for them
88295:                           if (aDrawMode != gfxFont::GLYPH_PATH && advance > 0) {
18764:                               double glyphX = x;
18764:                               if (isRTL) {
18764:                                   glyphX -= advance;
18764:                               }
18764:                               gfxPoint pt(ToDeviceUnits(glyphX, devUnitsPerAppUnit),
  132:                                           ToDeviceUnits(y, devUnitsPerAppUnit));
  132:                               gfxFloat advanceDevUnits = ToDeviceUnits(advance, devUnitsPerAppUnit);
  132:                               gfxFloat height = GetMetrics().maxAscent;
  132:                               gfxRect glyphRect(pt.x, pt.y - height, advanceDevUnits, height);
62288:                               gfxFontMissingGlyphs::DrawMissingGlyph(aContext,
62288:                                                                      glyphRect,
62288:                                                                      details->mGlyphID);
  132:                           }
 7715:                       } else {
 7715:                           glyph = glyphs.AppendGlyph();
 7715:                           glyph->index = details->mGlyphID;
18764:                           double glyphX = x + details->mXOffset;
18764:                           if (isRTL) {
18764:                               glyphX -= advance;
18764:                           }
18764:                           glyph->x = ToDeviceUnits(glyphX, devUnitsPerAppUnit);
 7715:                           glyph->y = ToDeviceUnits(y + details->mYOffset, devUnitsPerAppUnit);
89450:                           glyphs.Flush(cr, strokePattern, aDrawMode, isRTL);
13339: 
77795:                           if (IsSyntheticBold()) {
77795:                               double strikeOffset = synBoldOnePixelOffset;
77795:                               PRInt32 strikeCount = strikes;
77795:                               do {
13339:                                   cairo_glyph_t *doubleglyph;
13339:                                   doubleglyph = glyphs.AppendGlyph();
13339:                                   doubleglyph->index = glyph->index;
18764:                                   doubleglyph->x =
77795:                                       ToDeviceUnits(glyphX + strikeOffset *
77795:                                                         appUnitsPerDevUnit,
18764:                                                     devUnitsPerAppUnit);
13339:                                   doubleglyph->y = glyph->y;
77795:                                   strikeOffset += synBoldOnePixelOffset;
89450:                                   glyphs.Flush(cr, strokePattern, aDrawMode, isRTL);
77795:                               } while (--strikeCount > 0);
13339:                           }
 7715:                       }
  132:                       x += direction*advance;
  132:                   }
  132:               }
62288:           }
 7715: 
    1:           if (aSpacing) {
    1:               double space = aSpacing[i - aStart].mAfter;
    1:               if (i + 1 < aEnd) {
    1:                   space += aSpacing[i + 1 - aStart].mBefore;
    1:               }
    1:               x += direction*space;
    1:           }
    1:       }
    1: 
 3594:       if (gfxFontTestStore::CurrentStore()) {
 3594:           /* This assumes that the tests won't have anything that results
 3594:            * in more than GLYPH_BUFFER_SIZE glyphs.  Do this before we
 3594:            * flush, since that'll blow away the num_glyphs.
 3594:            */
67879:           gfxFontTestStore::CurrentStore()->AddItem(GetName(),
67879:                                                     glyphs.mGlyphBuffer,
67879:                                                     glyphs.mNumGlyphs);
    1:       }
    1: 
 3594:       // draw any remaining glyphs
89450:       glyphs.Flush(cr, strokePattern, aDrawMode, isRTL, true);
 3594: 
86663:     } else {
88295:       if (aDrawMode == gfxFont::GLYPH_PATH) {
86663:         // This should never be reached with azure!
86663:         NS_ERROR("Attempt at drawing to a Path to an Azure gfxContext.");
86663:         return;
86663:       }
86663: 
86663:       scaledFont =
86663:         gfxPlatform::GetPlatform()->GetScaledFontForFont(this);
86663:       
86663:       if (!scaledFont || !aContext->GetDeviceColor(color)) {
86663:         return;
86663:       }
86663: 
86663:       colPat.mColor = ToColor(color);
86663: 
86663:       GlyphBufferAzure glyphs;
86663:       Glyph *glyph;
86663: 
86663:       Matrix mat, matInv;
86663:       Matrix oldMat = dt->GetTransform();
86663: 
86663:       if (mScaledFont) {
86663:         cairo_matrix_t matrix;
86663:         cairo_scaled_font_get_font_matrix(mScaledFont, &matrix);
86663:         if (matrix.xy != 0) {
86663:           // If this matrix applies a skew, which can happen when drawing
86663:           // oblique fonts, we will set the DrawTarget matrix to apply the
86663:           // skew. We'll need to move the glyphs by the inverse of the skew to
86663:           // get the glyphs positioned correctly in the new device space
86663:           // though, since the font matrix should only be applied to drawing
86663:           // the glyphs, and not to their position.
86663:           mat = ToMatrix(*reinterpret_cast<gfxMatrix*>(&matrix));
86663: 
86663:           mat._11 = mat._22 = 1.0;
86663:           mat._21 /= mAdjustedSize;
86663: 
86663:           dt->SetTransform(mat * oldMat);
86663: 
86663:           matInv = mat;
86663:           matInv.Invert();
86663:         }
86663:       }
86663: 
86663:       if (aSpacing) {
86663:           x += direction*aSpacing[0].mBefore;
86663:       }
86663:       for (i = aStart; i < aEnd; ++i) {
86663:           const gfxTextRun::CompressedGlyph *glyphData = &charGlyphs[i];
86663:           if (glyphData->IsSimpleGlyph()) {
86663:               glyph = glyphs.AppendGlyph();
86663:               glyph->mIndex = glyphData->GetSimpleGlyph();
86663:               double advance = glyphData->GetSimpleAdvance();
86663:               // Perhaps we should put a scale in the cairo context instead of
86663:               // doing this scaling here...
86663:               // Multiplying by the reciprocal may introduce tiny error here,
86663:               // but we assume cairo is going to round coordinates at some stage
86663:               // and this is faster
86663:               double glyphX;
86663:               if (isRTL) {
86663:                   x -= advance;
86663:                   glyphX = x;
86663:               } else {
86663:                   glyphX = x;
86663:                   x += advance;
86663:               }
86663:               glyph->mPosition.x = ToDeviceUnits(glyphX, devUnitsPerAppUnit);
86663:               glyph->mPosition.y = ToDeviceUnits(y, devUnitsPerAppUnit);
86663:               glyph->mPosition = matInv * glyph->mPosition;
88295:               glyphs.Flush(dt, colPat, scaledFont, aDrawMode, isRTL);
86663:             
86663:               // synthetic bolding by multi-striking with 1-pixel offsets
86663:               // at least once, more if there's room (large font sizes)
86663:               if (IsSyntheticBold()) {
86663:                   double strikeOffset = synBoldOnePixelOffset;
86663:                   PRInt32 strikeCount = strikes;
86663:                   do {
86663:                       Glyph *doubleglyph;
86663:                       doubleglyph = glyphs.AppendGlyph();
86663:                       doubleglyph->mIndex = glyph->mIndex;
86663:                       doubleglyph->mPosition.x =
86663:                           ToDeviceUnits(glyphX + strikeOffset * appUnitsPerDevUnit,
86663:                                         devUnitsPerAppUnit);
86663:                       doubleglyph->mPosition.y = glyph->mPosition.y;
86663:                       doubleglyph->mPosition = matInv * doubleglyph->mPosition;
86663:                       strikeOffset += synBoldOnePixelOffset;
88295:                       glyphs.Flush(dt, colPat, scaledFont, aDrawMode, isRTL);
86663:                   } while (--strikeCount > 0);
86663:               }
86663:           } else {
86663:               PRUint32 glyphCount = glyphData->GetGlyphCount();
86663:               if (glyphCount > 0) {
86663:                   const gfxTextRun::DetailedGlyph *details =
86663:                       aTextRun->GetDetailedGlyphs(i);
86663:                   NS_ASSERTION(details, "detailedGlyph should not be missing!");
86663:                   for (PRUint32 j = 0; j < glyphCount; ++j, ++details) {
86663:                       double advance = details->mAdvance;
86663:                       if (glyphData->IsMissing()) {
86663:                           // default ignorable characters will have zero advance width.
86663:                           // we don't have to draw the hexbox for them
88295:                           if (aDrawMode != gfxFont::GLYPH_PATH && advance > 0) {
86663:                               double glyphX = x;
86663:                               if (isRTL) {
86663:                                   glyphX -= advance;
86663:                               }
86663:                               gfxPoint pt(ToDeviceUnits(glyphX, devUnitsPerAppUnit),
86663:                                           ToDeviceUnits(y, devUnitsPerAppUnit));
86663:                               gfxFloat advanceDevUnits = ToDeviceUnits(advance, devUnitsPerAppUnit);
86663:                               gfxFloat height = GetMetrics().maxAscent;
86663:                               gfxRect glyphRect(pt.x, pt.y - height, advanceDevUnits, height);
86663:                               gfxFontMissingGlyphs::DrawMissingGlyph(aContext,
86663:                                                                      glyphRect,
86663:                                                                      details->mGlyphID);
86663:                           }
86663:                       } else {
86663:                           glyph = glyphs.AppendGlyph();
86663:                           glyph->mIndex = details->mGlyphID;
86663:                           double glyphX = x + details->mXOffset;
86663:                           if (isRTL) {
86663:                               glyphX -= advance;
86663:                           }
86663:                           glyph->mPosition.x = ToDeviceUnits(glyphX, devUnitsPerAppUnit);
86663:                           glyph->mPosition.y = ToDeviceUnits(y + details->mYOffset, devUnitsPerAppUnit);
86663:                           glyph->mPosition = matInv * glyph->mPosition;
88295:                           glyphs.Flush(dt, colPat, scaledFont, aDrawMode, isRTL);
86663: 
86663:                           if (IsSyntheticBold()) {
86663:                               double strikeOffset = synBoldOnePixelOffset;
86663:                               PRInt32 strikeCount = strikes;
86663:                               do {
86663:                                   Glyph *doubleglyph;
86663:                                   doubleglyph = glyphs.AppendGlyph();
86663:                                   doubleglyph->mIndex = glyph->mIndex;
86663:                                   doubleglyph->mPosition.x =
86663:                                       ToDeviceUnits(glyphX + strikeOffset *
86663:                                                         appUnitsPerDevUnit,
86663:                                                     devUnitsPerAppUnit);
86663:                                   doubleglyph->mPosition.y = glyph->mPosition.y;
86663:                                   strikeOffset += synBoldOnePixelOffset;
86663:                                   doubleglyph->mPosition = matInv * doubleglyph->mPosition;
88295:                                   glyphs.Flush(dt, colPat, scaledFont, aDrawMode, isRTL);
86663:                               } while (--strikeCount > 0);
86663:                           }
86663:                       }
86663:                       x += direction*advance;
86663:                   }
86663:               }
86663:           }
86663: 
86663:           if (aSpacing) {
86663:               double space = aSpacing[i - aStart].mAfter;
86663:               if (i + 1 < aEnd) {
86663:                   space += aSpacing[i + 1 - aStart].mBefore;
86663:               }
86663:               x += direction*space;
86663:           }
86663:       }
86663: 
88295:       glyphs.Flush(dt, colPat, scaledFont, aDrawMode, isRTL, true);
86663: 
86663:       dt->SetTransform(oldMat);
86663:     }
86663: 
89450:     // Restore matrix for stroke pattern
89450:     if (aStrokePattern) {
89450:         aStrokePattern->SetMatrix(strokeMatrix);
89450:     }
89450: 
 3594:     *aPt = gfxPoint(x, y);
    1: }
    1: 
 6247: static void
16510: UnionRange(gfxFloat aX, gfxFloat* aDestMin, gfxFloat* aDestMax)
 6247: {
72496:     *aDestMin = NS_MIN(*aDestMin, aX);
72496:     *aDestMax = NS_MAX(*aDestMax, aX);
 6247: }
 6247: 
29527: // We get precise glyph extents if the textrun creator requested them, or
29527: // if the font is a user font --- in which case the author may be relying
29527: // on overflowing glyphs.
79445: static bool
29527: NeedsGlyphExtents(gfxFont *aFont, gfxTextRun *aTextRun)
29527: {
29527:     return (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX) ||
29527:         aFont->GetFontEntry()->IsUserFont();
29527: }
29527: 
79445: static bool
 6247: NeedsGlyphExtents(gfxTextRun *aTextRun)
 6247: {
29527:     if (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX)
80486:         return true;
29527:     PRUint32 numRuns;
29527:     const gfxTextRun::GlyphRun *glyphRuns = aTextRun->GetGlyphRuns(&numRuns);
29527:     for (PRUint32 i = 0; i < numRuns; ++i) {
29527:         if (glyphRuns[i].mFont->GetFontEntry()->IsUserFont())
80486:             return true;
80486:     }
80486:     return false;
 6247: }
 6247: 
    1: gfxFont::RunMetrics
    1: gfxFont::Measure(gfxTextRun *aTextRun,
    1:                  PRUint32 aStart, PRUint32 aEnd,
39447:                  BoundingBoxType aBoundingBoxType,
39447:                  gfxContext *aRefContext,
    1:                  Spacing *aSpacing)
    1: {
39447:     // If aBoundingBoxType is TIGHT_HINTED_OUTLINE_EXTENTS
39447:     // and the underlying cairo font may be antialiased,
39447:     // we need to create a copy in order to avoid getting cached extents.
42207:     // This is only used by MathML layout at present.
39447:     if (aBoundingBoxType == TIGHT_HINTED_OUTLINE_EXTENTS &&
39447:         mAntialiasOption != kAntialiasNone) {
42207:         if (!mNonAAFont) {
42207:             mNonAAFont = CopyWithAntialiasOption(kAntialiasNone);
42207:         }
39447:         // if font subclass doesn't implement CopyWithAntialiasOption(),
39447:         // it will return null and we'll proceed to use the existing font
42207:         if (mNonAAFont) {
42207:             return mNonAAFont->Measure(aTextRun, aStart, aEnd,
39447:                                        TIGHT_HINTED_OUTLINE_EXTENTS,
39447:                                        aRefContext, aSpacing);
39447:         }
39447:     }
39447: 
 6247:     const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();
 6247:     // Current position in appunits
 6247:     const gfxFont::Metrics& fontMetrics = GetMetrics();
 6247: 
 6247:     RunMetrics metrics;
 6247:     metrics.mAscent = fontMetrics.maxAscent*appUnitsPerDevUnit;
 6247:     metrics.mDescent = fontMetrics.maxDescent*appUnitsPerDevUnit;
 8499:     if (aStart == aEnd) {
 8499:         // exit now before we look at aSpacing[0], which is undefined
16510:         metrics.mBoundingBox = gfxRect(0, -metrics.mAscent, 0, metrics.mAscent + metrics.mDescent);
 8499:         return metrics;
 8499:     }
 6247: 
16510:     gfxFloat advanceMin = 0, advanceMax = 0;
 8499:     const gfxTextRun::CompressedGlyph *charGlyphs = aTextRun->GetCharacterGlyphs();
79445:     bool isRTL = aTextRun->IsRightToLeft();
 8499:     double direction = aTextRun->GetDirection();
79445:     bool needsGlyphExtents = NeedsGlyphExtents(this, aTextRun);
 6247:     gfxGlyphExtents *extents =
25417:         (aBoundingBoxType == LOOSE_INK_EXTENTS &&
29527:             !needsGlyphExtents &&
25417:             !aTextRun->HasDetailedGlyphs()) ? nsnull
 6247:         : GetOrCreateGlyphExtents(aTextRun->GetAppUnitsPerDevUnit());
 6247:     double x = 0;
 6247:     if (aSpacing) {
 6247:         x += direction*aSpacing[0].mBefore;
 6247:     }
 6225:     PRUint32 i;
    1:     for (i = aStart; i < aEnd; ++i) {
 6247:         const gfxTextRun::CompressedGlyph *glyphData = &charGlyphs[i];
 6247:         if (glyphData->IsSimpleGlyph()) {
 6247:             double advance = glyphData->GetSimpleAdvance();
 6247:             // Only get the real glyph horizontal extent if we were asked
 6247:             // for the tight bounding box or we're in quality mode
29527:             if ((aBoundingBoxType != LOOSE_INK_EXTENTS || needsGlyphExtents) &&
29527:                 extents) {
 6247:                 PRUint32 glyphIndex = glyphData->GetSimpleGlyph();
 6247:                 PRUint16 extentsWidth = extents->GetContainedGlyphWidthAppUnits(glyphIndex);
25417:                 if (extentsWidth != gfxGlyphExtents::INVALID_WIDTH &&
25417:                     aBoundingBoxType == LOOSE_INK_EXTENTS) {
16510:                     UnionRange(x, &advanceMin, &advanceMax);
16510:                     UnionRange(x + direction*extentsWidth, &advanceMin, &advanceMax);
 6247:                 } else {
 9576:                     gfxRect glyphRect;
 9576:                     if (!extents->GetTightGlyphExtentsAppUnits(this,
 9576:                             aRefContext, glyphIndex, &glyphRect)) {
 9576:                         glyphRect = gfxRect(0, metrics.mBoundingBox.Y(),
 9576:                             advance, metrics.mBoundingBox.Height());
 9576:                     }
 6247:                     if (isRTL) {
68632:                         glyphRect -= gfxPoint(advance, 0);
68632:                     }
68632:                     glyphRect += gfxPoint(x, 0);
 6247:                     metrics.mBoundingBox = metrics.mBoundingBox.Union(glyphRect);
 6247:                 }
 6247:             }
 6247:             x += direction*advance;
 7715:         } else {
 7715:             PRUint32 glyphCount = glyphData->GetGlyphCount();
62288:             if (glyphCount > 0) {
62288:                 const gfxTextRun::DetailedGlyph *details =
62288:                     aTextRun->GetDetailedGlyphs(i);
62288:                 NS_ASSERTION(details != nsnull,
62288:                              "detaiedGlyph record should not be missing!");
 7715:                 PRUint32 j;
 7715:                 for (j = 0; j < glyphCount; ++j, ++details) {
 6247:                     PRUint32 glyphIndex = details->mGlyphID;
 6247:                     gfxPoint glyphPt(x + details->mXOffset, details->mYOffset);
 6247:                     double advance = details->mAdvance;
 9576:                     gfxRect glyphRect;
 9576:                     if (glyphData->IsMissing() || !extents ||
 9576:                         !extents->GetTightGlyphExtentsAppUnits(this,
 9576:                                 aRefContext, glyphIndex, &glyphRect)) {
 9576:                         // We might have failed to get glyph extents due to
 9576:                         // OOM or something
16510:                         glyphRect = gfxRect(0, -metrics.mAscent,
16510:                             advance, metrics.mAscent + metrics.mDescent);
 9576:                     }
 6247:                     if (isRTL) {
68632:                         glyphRect -= gfxPoint(advance, 0);
68632:                     }
68632:                     glyphRect += gfxPoint(x, 0);
 6247:                     metrics.mBoundingBox = metrics.mBoundingBox.Union(glyphRect);
 6247:                     x += direction*advance;
 6247:                 }
 6247:             }
62288:         }
 6247:         // Every other glyph type is ignored
 6247:         if (aSpacing) {
 6247:             double space = aSpacing[i - aStart].mAfter;
 6247:             if (i + 1 < aEnd) {
 6247:                 space += aSpacing[i + 1 - aStart].mBefore;
 6247:             }
 6247:             x += direction*space;
    1:         }
    1:     }
    1: 
25417:     if (aBoundingBoxType == LOOSE_INK_EXTENTS) {
16510:         UnionRange(x, &advanceMin, &advanceMax);
16510:         gfxRect fontBox(advanceMin, -metrics.mAscent,
16510:                         advanceMax - advanceMin, metrics.mAscent + metrics.mDescent);
16510:         metrics.mBoundingBox = metrics.mBoundingBox.Union(fontBox);
    1:     }
 6247:     if (isRTL) {
68632:         metrics.mBoundingBox -= gfxPoint(x, 0);
    1:     }
 6247: 
 6247:     metrics.mAdvanceWidth = x*direction;
    1:     return metrics;
    1: }
    1: 
57397: #define MAX_SHAPING_LENGTH  32760 // slightly less than 32K, trying to avoid
57397:                                   // over-stressing platform shapers
57397: 
57397: #define BACKTRACK_LIMIT  1024 // If we can't find a space or a cluster start
57397:                               // within 1K chars, just chop arbitrarily.
57397:                               // Limiting backtrack here avoids pathological
57397:                               // behavior on long runs with no whitespace.
57397: 
86691: static bool
86697: IsBoundarySpace(PRUnichar aChar, PRUnichar aNextChar)
86697: {
86697:     return (aChar == ' ' || aChar == 0x00A0) && !IsClusterExtender(aNextChar);
86691: }
86691: 
86691: static inline PRUint32
86691: HashMix(PRUint32 aHash, PRUnichar aCh)
86691: {
86691:     return (aHash >> 28) ^ (aHash << 4) ^ aCh;
86691: }
86691: 
86691: template<typename T>
86691: gfxShapedWord*
86691: gfxFont::GetShapedWord(gfxContext *aContext,
86691:                        const T *aText,
86691:                        PRUint32 aLength,
86691:                        PRUint32 aHash,
86691:                        PRInt32 aRunScript,
86691:                        PRInt32 aAppUnitsPerDevUnit,
86691:                        PRUint32 aFlags)
86691: {
86691:     // if there's a cached entry for this word, just return it
86691:     CacheHashKey key(aText, aLength, aHash,
86691:                      aRunScript,
86691:                      aAppUnitsPerDevUnit,
86691:                      aFlags);
86691: 
86691:     CacheHashEntry *entry = mWordCache.PutEntry(key);
86698:     gfxShapedWord *sw = entry->mShapedWord;
90151:     Telemetry::Accumulate(Telemetry::WORD_CACHE_LOOKUP_LEN, aLength);
90151:     Telemetry::Accumulate(Telemetry::WORD_CACHE_LOOKUP_SCRIPT, aRunScript);
90151: 
86698:     if (sw) {
86698:         sw->ResetAge();
90151:         Telemetry::Accumulate(Telemetry::WORD_CACHE_HIT_LEN, aLength);
90151:         Telemetry::Accumulate(Telemetry::WORD_CACHE_HIT_SCRIPT, aRunScript);
86698:         return sw;
86698:     }
86698: 
86698:     sw = entry->mShapedWord = gfxShapedWord::Create(aText, aLength,
86691:                                                     aRunScript,
86691:                                                     aAppUnitsPerDevUnit,
86691:                                                     aFlags);
86698:     NS_ASSERTION(sw != nsnull,
86698:                  "failed to create gfxShapedWord - expect missing text");
86698:     if (!sw) {
86691:         return nsnull;
86691:     }
86691: 
86691:     bool ok;
86691:     if (sizeof(T) == sizeof(PRUnichar)) {
86698:         ok = ShapeWord(aContext, sw, (const PRUnichar*)aText);
86691:     } else {
86691:         nsAutoString utf16;
86703:         AppendASCIItoUTF16(nsDependentCSubstring((const char*)aText, aLength),
86703:                            utf16);
86698:         ok = ShapeWord(aContext, sw, utf16.BeginReading());
86691:     }
86691:     NS_WARN_IF_FALSE(ok, "failed to shape word - expect garbled text");
86691: 
86697:     for (PRUint32 i = 0; i < aLength; ++i) {
86697:         if (aText[i] == ' ') {
86698:             sw->SetIsSpace(i);
86697:         } else if (i > 0 &&
86697:                    NS_IS_HIGH_SURROGATE(aText[i - 1]) &&
86697:                    NS_IS_LOW_SURROGATE(aText[i])) {
86698:             sw->SetIsLowSurrogate(i);
86698:         }
86698:     }
86698: 
86698:     return sw;
86691: }
86691: 
86691: bool
86691: gfxFont::CacheHashEntry::KeyEquals(const KeyTypePointer aKey) const
86691: {
86691:     const gfxShapedWord *sw = mShapedWord;
86691:     if (!sw) {
86691:         return false;
86691:     }
86691:     if (sw->Length() != aKey->mLength ||
86691:         sw->Flags() != aKey->mFlags ||
86691:         sw->AppUnitsPerDevUnit() != aKey->mAppUnitsPerDevUnit ||
86691:         sw->Script() != aKey->mScript) {
86691:         return false;
86691:     }
86691:     if (sw->TextIs8Bit()) {
86691:         if (aKey->mTextIs8Bit) {
86691:             return (0 == memcmp(sw->Text8Bit(), aKey->mText.mSingle,
86691:                                 aKey->mLength * sizeof(PRUint8)));
86691:         }
86691:         // The key has 16-bit text, even though all the characters are < 256,
86691:         // so the TEXT_IS_8BIT flag was set and the cached ShapedWord we're
86691:         // comparing with will have 8-bit text.
86691:         const PRUint8   *s1 = sw->Text8Bit();
86691:         const PRUnichar *s2 = aKey->mText.mDouble;
86691:         const PRUnichar *s2end = s2 + aKey->mLength;
86691:         while (s2 < s2end) {
86691:             if (*s1++ != *s2++) {
86691:                 return false;
86691:             }
86691:         }
86691:         return true;
86691:     }
86691:     NS_ASSERTION((aKey->mFlags & gfxTextRunFactory::TEXT_IS_8BIT) == 0 &&
86691:                  !aKey->mTextIs8Bit, "didn't expect 8-bit text here");
86691:     return (0 == memcmp(sw->TextUnicode(), aKey->mText.mDouble,
86691:                         aKey->mLength * sizeof(PRUnichar)));
86691: }
86691: 
86691: bool
86691: gfxFont::ShapeWord(gfxContext *aContext,
86691:                    gfxShapedWord *aShapedWord,
86691:                    const PRUnichar *aText,
86691:                    bool aPreferPlatformShaping)
86691: {
86691:     bool ok = false;
86691: 
86691: #ifdef MOZ_GRAPHITE
86691:     if (mGraphiteShaper && gfxPlatform::GetPlatform()->UseGraphiteShaping()) {
86691:         ok = mGraphiteShaper->ShapeWord(aContext, aShapedWord, aText);
86691:     }
86691: #endif
86691: 
86691:     if (!ok && mHarfBuzzShaper && !aPreferPlatformShaping) {
86691:         if (gfxPlatform::GetPlatform()->UseHarfBuzzForScript(aShapedWord->Script())) {
86691:             ok = mHarfBuzzShaper->ShapeWord(aContext, aShapedWord, aText);
86691:         }
86691:     }
86691: 
86691:     if (!ok) {
86691:         if (!mPlatformShaper) {
86691:             CreatePlatformShaper();
86691:             NS_ASSERTION(mPlatformShaper, "no platform shaper available!");
86691:         }
86691:         if (mPlatformShaper) {
86691:             ok = mPlatformShaper->ShapeWord(aContext, aShapedWord, aText);
86691:         }
86691:     }
86691: 
86691:     if (ok && IsSyntheticBold()) {
86691:         float synBoldOffset =
86691:                 GetSyntheticBoldOffset() * CalcXScale(aContext);
86691:         aShapedWord->AdjustAdvancesForSyntheticBold(synBoldOffset);
86691:     }
86691: 
86691:     return ok;
86691: }
86691: 
86691: template<typename T>
79445: bool
60118: gfxFont::SplitAndInitTextRun(gfxContext *aContext,
39447:                              gfxTextRun *aTextRun,
86691:                              const T *aString,
39447:                              PRUint32 aRunStart,
43525:                              PRUint32 aRunLength,
60118:                              PRInt32 aRunScript)
39447: {
86697:     if (aRunLength == 0) {
86697:         return true;
86697:     }
86697: 
86691:     InitWordCache();
86691: 
86691:     // the only flags we care about for ShapedWord construction/caching
86691:     PRUint32 flags = aTextRun->GetFlags() &
86691:         (gfxTextRunFactory::TEXT_IS_RTL |
86691:          gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES);
86691:     if (sizeof(T) == sizeof(PRUint8)) {
86691:         flags |= gfxTextRunFactory::TEXT_IS_8BIT;
86691:     }
86691: 
86691:     const T *text = aString + aRunStart;
86691:     PRUint32 wordStart = 0;
86691:     PRUint32 hash = 0;
86691:     bool wordIs8Bit = true;
86691:     PRInt32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();
86691: 
86697:     T nextCh = text[0];
86691:     for (PRUint32 i = 0; i <= aRunLength; ++i) {
86697:         T ch = nextCh;
86697:         nextCh = (i < aRunLength - 1) ? text[i + 1] : '\n';
86697:         bool boundary = IsBoundarySpace(ch, nextCh);
86697:         bool invalid = !boundary && gfxFontGroup::IsInvalidChar(ch);
86691:         PRUint32 length = i - wordStart;
86691: 
86691:         // break into separate ShapedWords when we hit an invalid char,
86691:         // or a boundary space (always handled individually),
86691:         // or the first non-space after a space
86691:         bool breakHere = boundary || invalid;
86691: 
86691:         if (!breakHere) {
86691:             // if we're approaching the max ShapedWord length, break anyway...
86691:             if (sizeof(T) == sizeof(PRUint8)) {
86691:                 // in 8-bit text, no clusters or surrogates to worry about
86691:                 if (length >= gfxShapedWord::kMaxLength) {
86691:                     breakHere = true;
86691:                 }
57397:             } else {
86691:                 // try to avoid breaking before combining mark or low surrogate
86691:                 if (length >= gfxShapedWord::kMaxLength - 15) {
86691:                     if (!NS_IS_LOW_SURROGATE(ch)) {
86697:                         if (!IsClusterExtender(ch)) {
86691:                             breakHere = true;
86691:                         }
86691:                     }
86691:                     if (!breakHere && length >= gfxShapedWord::kMaxLength - 3) {
86691:                         if (!NS_IS_LOW_SURROGATE(ch)) {
86691:                             breakHere = true;
86691:                         }
86691:                     }
86691:                     if (!breakHere && length >= gfxShapedWord::kMaxLength) {
86691:                         breakHere = true;
86691:                     }
86691:                 }
86691:             }
86691:         }
86691: 
86691:         if (!breakHere) {
86691:             if (ch >= 0x100) {
86691:                 wordIs8Bit = false;
86691:             }
86691:             // include this character in the hash, and move on to next
86691:             hash = HashMix(hash, ch);
86691:             continue;
86691:         }
86691: 
86691:         // We've decided to break here (i.e. we're at the end of a "word",
86691:         // or the word is becoming excessively long): shape the word and
86691:         // add it to the textrun
86691:         if (length > 0) {
86691:             PRUint32 wordFlags = flags;
86691:             // in the 8-bit version of this method, TEXT_IS_8BIT was
86691:             // already set as part of |flags|, so no need for a per-word
86691:             // adjustment here
86691:             if (sizeof(T) == sizeof(PRUnichar)) {
86691:                 if (wordIs8Bit) {
86691:                     wordFlags |= gfxTextRunFactory::TEXT_IS_8BIT;
86691:                 }
86691:             }
86691:             gfxShapedWord *sw = GetShapedWord(aContext,
86691:                                               text + wordStart, length,
86691:                                               hash, aRunScript,
86691:                                               appUnitsPerDevUnit,
86691:                                               wordFlags);
86691:             if (sw) {
86691:                 aTextRun->CopyGlyphDataFrom(sw, aRunStart + wordStart);
86691:             } else {
86691:                 return false; // failed, presumably out of memory?
86691:             }
86691:         }
86691: 
86691:         if (boundary) {
86691:             // word was terminated by a space: add that to the textrun
86691:             if (!aTextRun->SetSpaceGlyphIfSimple(this, aContext,
86697:                                                  aRunStart + i, ch))
60118:             {
86691:                 static const PRUint8 space = ' ';
86691:                 gfxShapedWord *sw =
86691:                     GetShapedWord(aContext,
86691:                                   &space, 1,
86691:                                   HashMix(0, ' '), aRunScript,
86691:                                   appUnitsPerDevUnit,
86691:                                   flags | gfxTextRunFactory::TEXT_IS_8BIT);
86691:                 if (sw) {
86691:                     aTextRun->CopyGlyphDataFrom(sw, aRunStart + i);
86691:                 } else {
86691:                     return false;
86691:                 }
86691:             }
86691:             hash = 0;
86691:             wordStart = i + 1;
86691:             wordIs8Bit = true;
86691:             continue;
86691:         }
86691: 
86697:         if (i == aRunLength) {
86697:             break;
86697:         }
86697: 
86691:         if (invalid) {
86697:             // word was terminated by an invalid char: skip it,
86697:             // but record where TAB or NEWLINE occur
86697:             if (ch == '\t') {
86697:                 aTextRun->SetIsTab(aRunStart + i);
86697:             } else if (ch == '\n') {
86697:                 aTextRun->SetIsNewline(aRunStart + i);
86697:             }
86691:             hash = 0;
86691:             wordStart = i + 1;
86691:             wordIs8Bit = true;
86691:             continue;
86691:         }
86691: 
86691:         // word was forcibly broken, so current char will begin next word
86691:         hash = HashMix(0, ch);
86691:         wordStart = i;
86691:         wordIs8Bit = (ch < 0x100);
86691:     }
86691: 
86691:     return true;
39447: }
39447: 
 6247: gfxGlyphExtents *
 6247: gfxFont::GetOrCreateGlyphExtents(PRUint32 aAppUnitsPerDevUnit) {
 6247:     PRUint32 i;
 6247:     for (i = 0; i < mGlyphExtentsArray.Length(); ++i) {
 6247:         if (mGlyphExtentsArray[i]->GetAppUnitsPerDevUnit() == aAppUnitsPerDevUnit)
 6247:             return mGlyphExtentsArray[i];
 6247:     }
 6247:     gfxGlyphExtents *glyphExtents = new gfxGlyphExtents(aAppUnitsPerDevUnit);
 6247:     if (glyphExtents) {
 6247:         mGlyphExtentsArray.AppendElement(glyphExtents);
 6247:         // Initialize the extents of a space glyph, assuming that spaces don't
 6247:         // render anything!
 6247:         glyphExtents->SetContainedGlyphWidthAppUnits(GetSpaceGlyph(), 0);
 6247:     }
 6247:     return glyphExtents;
 6247: }
 6247: 
 6247: void
79445: gfxFont::SetupGlyphExtents(gfxContext *aContext, PRUint32 aGlyphID, bool aNeedTight,
 6247:                            gfxGlyphExtents *aExtents)
 6247: {
14044:     gfxMatrix matrix = aContext->CurrentMatrix();
14044:     aContext->IdentityMatrix();
 6247:     cairo_glyph_t glyph;
 6247:     glyph.index = aGlyphID;
 6247:     glyph.x = 0;
 6247:     glyph.y = 0;
 6247:     cairo_text_extents_t extents;
 6247:     cairo_glyph_extents(aContext->GetCairo(), &glyph, 1, &extents);
14044:     aContext->SetMatrix(matrix);
 6247: 
 6247:     const Metrics& fontMetrics = GetMetrics();
 6247:     PRUint32 appUnitsPerDevUnit = aExtents->GetAppUnitsPerDevUnit();
 6247:     if (!aNeedTight && extents.x_bearing >= 0 &&
 6247:         extents.y_bearing >= -fontMetrics.maxAscent &&
 6247:         extents.height + extents.y_bearing <= fontMetrics.maxDescent) {
 6247:         PRUint32 appUnitsWidth =
75359:             PRUint32(ceil((extents.x_bearing + extents.width)*appUnitsPerDevUnit));
 6247:         if (appUnitsWidth < gfxGlyphExtents::INVALID_WIDTH) {
 6247:             aExtents->SetContainedGlyphWidthAppUnits(aGlyphID, PRUint16(appUnitsWidth));
 6247:             return;
 6247:         }
 6247:     }
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:     if (!aNeedTight) {
 6513:         ++gGlyphExtentsSetupFallBackToTight;
 6513:     }
 6513: #endif
 6247: 
 6247:     double d2a = appUnitsPerDevUnit;
 6247:     gfxRect bounds(extents.x_bearing*d2a, extents.y_bearing*d2a,
 6247:                    extents.width*d2a, extents.height*d2a);
 6247:     aExtents->SetTightGlyphExtents(aGlyphID, bounds);
 6247: }
 6247: 
47309: // Try to initialize font metrics by reading sfnt tables directly;
47309: // set mIsValid=TRUE and return TRUE on success.
47309: // Return FALSE if the gfxFontEntry subclass does not
47309: // implement GetFontTable(), or for non-sfnt fonts where tables are
47309: // not available.
79445: bool
47309: gfxFont::InitMetricsFromSfntTables(Metrics& aMetrics)
47309: {
80486:     mIsValid = false; // font is NOT valid in case of early return
47309: 
47309:     const PRUint32 kHeadTableTag = TRUETYPE_TAG('h','e','a','d');
47309:     const PRUint32 kHheaTableTag = TRUETYPE_TAG('h','h','e','a');
47309:     const PRUint32 kPostTableTag = TRUETYPE_TAG('p','o','s','t');
47309:     const PRUint32 kOS_2TableTag = TRUETYPE_TAG('O','S','/','2');
47309: 
47309:     if (mFUnitsConvFactor == 0.0) {
47309:         // If the conversion factor from FUnits is not yet set,
47309:         // 'head' table is required; otherwise we cannot read any metrics
47309:         // because we don't know unitsPerEm
60098:         AutoFallibleTArray<PRUint8,sizeof(HeadTable)> headData;
47309:         if (NS_FAILED(mFontEntry->GetFontTable(kHeadTableTag, headData)) ||
47309:             headData.Length() < sizeof(HeadTable)) {
80486:             return false; // no 'head' table -> not an sfnt
47309:         }
47309:         HeadTable *head = reinterpret_cast<HeadTable*>(headData.Elements());
47309:         PRUint32 unitsPerEm = head->unitsPerEm;
47309:         if (!unitsPerEm) {
80486:             return true; // is an sfnt, but not valid
47309:         }
47309:         mFUnitsConvFactor = mAdjustedSize / unitsPerEm;
47309:     }
47309: 
47309:     // 'hhea' table is required to get vertical extents
60098:     AutoFallibleTArray<PRUint8,sizeof(HheaTable)> hheaData;
47309:     if (NS_FAILED(mFontEntry->GetFontTable(kHheaTableTag, hheaData)) ||
47309:         hheaData.Length() < sizeof(HheaTable)) {
80486:         return false; // no 'hhea' table -> not an sfnt
47309:     }
47309:     HheaTable *hhea = reinterpret_cast<HheaTable*>(hheaData.Elements());
47309: 
47309: #define SET_UNSIGNED(field,src) aMetrics.field = PRUint16(src) * mFUnitsConvFactor
47309: #define SET_SIGNED(field,src)   aMetrics.field = PRInt16(src) * mFUnitsConvFactor
47309: 
47309:     SET_UNSIGNED(maxAdvance, hhea->advanceWidthMax);
47309:     SET_SIGNED(maxAscent, hhea->ascender);
47309:     SET_SIGNED(maxDescent, -PRInt16(hhea->descender));
47309:     SET_SIGNED(externalLeading, hhea->lineGap);
47309: 
47309:     // 'post' table is required for underline metrics
60098:     AutoFallibleTArray<PRUint8,sizeof(PostTable)> postData;
47309:     if (NS_FAILED(mFontEntry->GetFontTable(kPostTableTag, postData))) {
80486:         return true; // no 'post' table -> sfnt is not valid
47309:     }
47309:     if (postData.Length() <
47309:         offsetof(PostTable, underlineThickness) + sizeof(PRUint16)) {
80486:         return true; // bad post table -> sfnt is not valid
47309:     }
47309:     PostTable *post = reinterpret_cast<PostTable*>(postData.Elements());
47309: 
47309:     SET_SIGNED(underlineOffset, post->underlinePosition);
47309:     SET_UNSIGNED(underlineSize, post->underlineThickness);
47309: 
47309:     // 'OS/2' table is optional, if not found we'll estimate xHeight
47309:     // and aveCharWidth by measuring glyphs
60098:     AutoFallibleTArray<PRUint8,sizeof(OS2Table)> os2data;
47309:     if (NS_SUCCEEDED(mFontEntry->GetFontTable(kOS_2TableTag, os2data))) {
47309:         OS2Table *os2 = reinterpret_cast<OS2Table*>(os2data.Elements());
47309: 
47309:         if (os2data.Length() >= offsetof(OS2Table, sxHeight) +
47309:                                 sizeof(PRInt16) &&
47309:             PRUint16(os2->version) >= 2) {
47309:             // version 2 and later includes the x-height field
47309:             SET_SIGNED(xHeight, os2->sxHeight);
72496:             // NS_ABS because of negative xHeight seen in Kokonor (Tibetan) font
72496:             aMetrics.xHeight = NS_ABS(aMetrics.xHeight);
47309:         }
47309:         // this should always be present
47309:         if (os2data.Length() >= offsetof(OS2Table, yStrikeoutPosition) +
47309:                                 sizeof(PRInt16)) {
47309:             SET_SIGNED(aveCharWidth, os2->xAvgCharWidth);
47309:             SET_SIGNED(subscriptOffset, os2->ySubscriptYOffset);
47309:             SET_SIGNED(superscriptOffset, os2->ySuperscriptYOffset);
47309:             SET_SIGNED(strikeoutSize, os2->yStrikeoutSize);
47309:             SET_SIGNED(strikeoutOffset, os2->yStrikeoutPosition);
47309:         }
47309:     }
47309: 
80486:     mIsValid = true;
80486: 
80486:     return true;
47309: }
47309: 
47309: static double
47309: RoundToNearestMultiple(double aValue, double aFraction)
47309: {
47309:     return floor(aValue/aFraction + 0.5) * aFraction;
47309: }
47309: 
47309: void gfxFont::CalculateDerivedMetrics(Metrics& aMetrics)
47309: {
47309:     aMetrics.maxAscent =
75359:         ceil(RoundToNearestMultiple(aMetrics.maxAscent, 1/1024.0));
47309:     aMetrics.maxDescent =
75359:         ceil(RoundToNearestMultiple(aMetrics.maxDescent, 1/1024.0));
47309: 
47309:     if (aMetrics.xHeight <= 0) {
47309:         // only happens if we couldn't find either font metrics
47309:         // or a char to measure;
47309:         // pick an arbitrary value that's better than zero
47309:         aMetrics.xHeight = aMetrics.maxAscent * DEFAULT_XHEIGHT_FACTOR;
47309:     }
47309: 
47309:     aMetrics.maxHeight = aMetrics.maxAscent + aMetrics.maxDescent;
47309: 
47309:     if (aMetrics.maxHeight - aMetrics.emHeight > 0.0) {
47309:         aMetrics.internalLeading = aMetrics.maxHeight - aMetrics.emHeight;
47309:     } else {
47309:         aMetrics.internalLeading = 0.0;
47309:     }
47309: 
47309:     aMetrics.emAscent = aMetrics.maxAscent * aMetrics.emHeight
47309:                             / aMetrics.maxHeight;
47309:     aMetrics.emDescent = aMetrics.emHeight - aMetrics.emAscent;
47309: 
47309:     if (GetFontEntry()->IsFixedPitch()) {
47309:         // Some Quartz fonts are fixed pitch, but there's some glyph with a bigger
47309:         // advance than the average character width... this forces
47309:         // those fonts to be recognized like fixed pitch fonts by layout.
47309:         aMetrics.maxAdvance = aMetrics.aveCharWidth;
47309:     }
47309: 
47309:     if (!aMetrics.subscriptOffset) {
47309:         aMetrics.subscriptOffset = aMetrics.xHeight;
47309:     }
47309:     if (!aMetrics.superscriptOffset) {
47309:         aMetrics.superscriptOffset = aMetrics.xHeight;
47309:     }
47309: 
47309:     if (!aMetrics.strikeoutOffset) {
47309:         aMetrics.strikeoutOffset = aMetrics.xHeight * 0.5;
47309:     }
47309:     if (!aMetrics.strikeoutSize) {
47309:         aMetrics.strikeoutSize = aMetrics.underlineSize;
47309:     }
47309: }
47309: 
11765: void
79445: gfxFont::SanitizeMetrics(gfxFont::Metrics *aMetrics, bool aIsBadUnderlineFont)
11765: {
13714:     // Even if this font size is zero, this font is created with non-zero size.
13714:     // However, for layout and others, we should return the metrics of zero size font.
84046:     if (mStyle.size == 0.0) {
13714:         memset(aMetrics, 0, sizeof(gfxFont::Metrics));
13714:         return;
13714:     }
13714: 
11765:     // MS (P)Gothic and MS (P)Mincho are not having suitable values in their super script offset.
11765:     // If the values are not suitable, we should use x-height instead of them.
11765:     // See https://bugzilla.mozilla.org/show_bug.cgi?id=353632
40042:     if (aMetrics->superscriptOffset <= 0 ||
11765:         aMetrics->superscriptOffset >= aMetrics->maxAscent) {
11765:         aMetrics->superscriptOffset = aMetrics->xHeight;
11765:     }
11765:     // And also checking the case of sub script offset. The old gfx for win has checked this too.
40042:     if (aMetrics->subscriptOffset <= 0 ||
11765:         aMetrics->subscriptOffset >= aMetrics->maxAscent) {
11765:         aMetrics->subscriptOffset = aMetrics->xHeight;
11765:     }
11765: 
72496:     aMetrics->underlineSize = NS_MAX(1.0, aMetrics->underlineSize);
72496:     aMetrics->strikeoutSize = NS_MAX(1.0, aMetrics->strikeoutSize);
72496: 
72496:     aMetrics->underlineOffset = NS_MIN(aMetrics->underlineOffset, -1.0);
11765: 
14253:     if (aMetrics->maxAscent < 1.0) {
14253:         // We cannot draw strikeout line and overline in the ascent...
14253:         aMetrics->underlineSize = 0;
14253:         aMetrics->underlineOffset = 0;
14253:         aMetrics->strikeoutSize = 0;
14253:         aMetrics->strikeoutOffset = 0;
14253:         return;
14253:     }
14253: 
12989:     /**
12989:      * Some CJK fonts have bad underline offset. Therefore, if this is such font,
12989:      * we need to lower the underline offset to bottom of *em* descent.
12989:      * However, if this is system font, we should not do this for the rendering compatibility with
12989:      * another application's UI on the platform.
14253:      * XXX Should not use this hack if the font size is too small?
14253:      *     Such text cannot be read, this might be used for tight CSS rendering? (E.g., Acid2)
12989:      */
12989:     if (!mStyle.systemFont && aIsBadUnderlineFont) {
12989:         // First, we need 2 pixels between baseline and underline at least. Because many CJK characters
12989:         // put their glyphs on the baseline, so, 1 pixel is too close for CJK characters.
72496:         aMetrics->underlineOffset = NS_MIN(aMetrics->underlineOffset, -2.0);
11765: 
12989:         // Next, we put the underline to bottom of below of the descent space.
12989:         if (aMetrics->internalLeading + aMetrics->externalLeading > aMetrics->underlineSize) {
72496:             aMetrics->underlineOffset = NS_MIN(aMetrics->underlineOffset, -aMetrics->emDescent);
12989:         } else {
72496:             aMetrics->underlineOffset = NS_MIN(aMetrics->underlineOffset,
12989:                                                aMetrics->underlineSize - aMetrics->emDescent);
12989:         }
12989:     }
11765:     // If underline positioned is too far from the text, descent position is preferred so that underline
11765:     // will stay within the boundary.
12989:     else if (aMetrics->underlineSize - aMetrics->underlineOffset > aMetrics->maxDescent) {
14253:         if (aMetrics->underlineSize > aMetrics->maxDescent)
72496:             aMetrics->underlineSize = NS_MAX(aMetrics->maxDescent, 1.0);
14253:         // The max underlineOffset is 1px (the min underlineSize is 1px, and min maxDescent is 0px.)
11765:         aMetrics->underlineOffset = aMetrics->underlineSize - aMetrics->maxDescent;
14253:     }
14253: 
14253:     // If strikeout line is overflowed from the ascent, the line should be resized and moved for
14253:     // that being in the ascent space.
14253:     // Note that the strikeoutOffset is *middle* of the strikeout line position.
75359:     gfxFloat halfOfStrikeoutSize = floor(aMetrics->strikeoutSize / 2.0 + 0.5);
14253:     if (halfOfStrikeoutSize + aMetrics->strikeoutOffset > aMetrics->maxAscent) {
14253:         if (aMetrics->strikeoutSize > aMetrics->maxAscent) {
72496:             aMetrics->strikeoutSize = NS_MAX(aMetrics->maxAscent, 1.0);
75359:             halfOfStrikeoutSize = floor(aMetrics->strikeoutSize / 2.0 + 0.5);
75359:         }
75359:         gfxFloat ascent = floor(aMetrics->maxAscent + 0.5);
72496:         aMetrics->strikeoutOffset = NS_MAX(halfOfStrikeoutSize, ascent / 2.0);
14253:     }
14253: 
14253:     // If overline is larger than the ascent, the line should be resized.
14253:     if (aMetrics->underlineSize > aMetrics->maxAscent) {
14253:         aMetrics->underlineSize = aMetrics->maxAscent;
12989:     }
11765: }
11765: 
69197: gfxFloat
69197: gfxFont::SynthesizeSpaceWidth(PRUint32 aCh)
69197: {
69197:     // return an appropriate width for various Unicode space characters
69197:     // that we "fake" if they're not actually present in the font;
69197:     // returns negative value if the char is not a known space.
69197:     switch (aCh) {
69197:     case 0x2000:                                 // en quad
69197:     case 0x2002: return GetAdjustedSize() / 2;   // en space
69197:     case 0x2001:                                 // em quad
69197:     case 0x2003: return GetAdjustedSize();       // em space
69197:     case 0x2004: return GetAdjustedSize() / 3;   // three-per-em space
69197:     case 0x2005: return GetAdjustedSize() / 4;   // four-per-em space
69197:     case 0x2006: return GetAdjustedSize() / 6;   // six-per-em space
69197:     case 0x2007: return GetMetrics().zeroOrAveCharWidth; // figure space
69197:     case 0x2008: return GetMetrics().spaceWidth; // punctuation space 
69197:     case 0x2009: return GetAdjustedSize() / 5;   // thin space
69197:     case 0x200a: return GetAdjustedSize() / 10;  // hair space
69197:     case 0x202f: return GetAdjustedSize() / 5;   // narrow no-break space
69197:     default: return -1.0;
69197:     }
69197: }
69197: 
 6513: gfxGlyphExtents::~gfxGlyphExtents()
 6513: {
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:     gGlyphExtentsWidthsTotalSize += mContainedGlyphWidths.ComputeSize();
 6513:     gGlyphExtentsCount++;
 6513: #endif
 6513:     MOZ_COUNT_DTOR(gfxGlyphExtents);
 6513: }
 6513: 
79445: bool
 6247: gfxGlyphExtents::GetTightGlyphExtentsAppUnits(gfxFont *aFont,
 9576:     gfxContext *aContext, PRUint32 aGlyphID, gfxRect *aExtents)
 6247: {
 6247:     HashEntry *entry = mTightGlyphExtents.GetEntry(aGlyphID);
 6247:     if (!entry) {
 9576:         if (!aContext) {
 9576:             NS_WARNING("Could not get glyph extents (no aContext)");
80486:             return false;
 9576:         }
 9576: 
 6247:         aFont->SetupCairoFont(aContext);
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:         ++gGlyphExtentsSetupLazyTight;
 6513: #endif
80486:         aFont->SetupGlyphExtents(aContext, aGlyphID, true, this);
 6247:         entry = mTightGlyphExtents.GetEntry(aGlyphID);
 6247:         if (!entry) {
 6247:             NS_WARNING("Could not get glyph extents");
80486:             return false;
 6247:         }
 6247:     }
 6247: 
 9576:     *aExtents = gfxRect(entry->x, entry->y, entry->width, entry->height);
80486:     return true;
 6247: }
 6247: 
 6513: gfxGlyphExtents::GlyphWidths::~GlyphWidths()
 6513: {
 6513:     PRUint32 i;
 6513:     for (i = 0; i < mBlocks.Length(); ++i) {
 6513:         PtrBits bits = mBlocks[i];
 6513:         if (bits && !(bits & 0x1)) {
 6513:             delete[] reinterpret_cast<PRUint16 *>(bits);
 6513:         }
 6513:     }
 6513: }
 6513: 
 6513: #ifdef DEBUG
 6513: PRUint32
 6513: gfxGlyphExtents::GlyphWidths::ComputeSize()
 6513: {
 6513:     PRUint32 i;
 6513:     PRUint32 size = mBlocks.Capacity()*sizeof(PtrBits);
 6513:     for (i = 0; i < mBlocks.Length(); ++i) {
 6513:         PtrBits bits = mBlocks[i];
 6513:         if (bits && !(bits & 0x1)) {
 6513:             size += BLOCK_SIZE*sizeof(PRUint16);
 6513:         }
 6513:     }
 6513:     return size;
 6513: }
 6513: #endif
 6513: 
 6496: void
 6513: gfxGlyphExtents::GlyphWidths::Set(PRUint32 aGlyphID, PRUint16 aWidth)
 6493: {
 6513:     PRUint32 block = aGlyphID >> BLOCK_SIZE_BITS;
 6513:     PRUint32 len = mBlocks.Length();
 6513:     if (block >= len) {
 6513:         PtrBits *elems = mBlocks.AppendElements(block + 1 - len);
 6247:         if (!elems)
 6247:             return;
 6513:         memset(elems, 0, sizeof(PtrBits)*(block + 1 - len));
 6513:     }
 6513: 
 6513:     PtrBits bits = mBlocks[block];
 6513:     PRUint32 glyphOffset = aGlyphID & (BLOCK_SIZE - 1);
 6513:     if (!bits) {
 6513:         mBlocks[block] = MakeSingle(glyphOffset, aWidth);
 6513:         return;
 6513:     }
 6513: 
 6513:     PRUint16 *newBlock;
 6513:     if (bits & 0x1) {
 6513:         // Expand the block to a real block. We could avoid this by checking
 6513:         // glyphOffset == GetGlyphOffset(bits), but that never happens so don't bother
 6513:         newBlock = new PRUint16[BLOCK_SIZE];
 6513:         if (!newBlock)
 6513:             return;
 6496:         PRUint32 i;
 6513:         for (i = 0; i < BLOCK_SIZE; ++i) {
 6513:             newBlock[i] = INVALID_WIDTH;
 6247:         }
 6513:         newBlock[GetGlyphOffset(bits)] = GetWidth(bits);
 6513:         mBlocks[block] = reinterpret_cast<PtrBits>(newBlock);
 6513:     } else {
 6513:         newBlock = reinterpret_cast<PRUint16 *>(bits);
 6247:     }
 6513:     newBlock[glyphOffset] = aWidth;
 6247: }
 6247: 
 6247: void
 6247: gfxGlyphExtents::SetTightGlyphExtents(PRUint32 aGlyphID, const gfxRect& aExtentsAppUnits)
 6247: {
 6247:     HashEntry *entry = mTightGlyphExtents.PutEntry(aGlyphID);
 6247:     if (!entry)
 6247:         return;
68632:     entry->x = aExtentsAppUnits.X();
68632:     entry->y = aExtentsAppUnits.Y();
68632:     entry->width = aExtentsAppUnits.Width();
68632:     entry->height = aExtentsAppUnits.Height();
 6247: }
 6247: 
19962: gfxFontGroup::gfxFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle, gfxUserFontSet *aUserFontSet)
14253:     : mFamilies(aFamilies), mStyle(*aStyle), mUnderlineOffset(UNDERLINE_OFFSET_NOT_SET)
    1: {
19962:     mUserFontSet = nsnull;
19962:     SetUserFontSet(aUserFontSet);
37211: 
80486:     mSkipDrawing = false;
62296: 
38493:     mPageLang = gfxPlatform::GetFontPrefLangFor(mStyle.language);
38461:     BuildFontList();
38461: }
38461: 
38461: void
38461: gfxFontGroup::BuildFontList()
38461: {
37211: // "#if" to be removed once all platforms are moved to gfxPlatformFontList interface
37211: // and subclasses of gfxFontGroup eliminated
71958: #if defined(XP_MACOSX) || defined(XP_WIN) || defined(ANDROID)
37211:     ForEachFont(FindPlatformFont, this);
37211: 
37211:     if (mFonts.Length() == 0) {
79445:         bool needsBold;
40680:         gfxPlatformFontList *pfl = gfxPlatformFontList::PlatformFontList();
40680:         gfxFontEntry *defaultFont = pfl->GetDefaultFont(&mStyle, needsBold);
37211:         NS_ASSERTION(defaultFont, "invalid default font returned by GetDefaultFont");
37211: 
40680:         if (defaultFont) {
40680:             nsRefPtr<gfxFont> font = defaultFont->FindOrMakeFont(&mStyle,
40680:                                                                  needsBold);
37211:             if (font) {
37211:                 mFonts.AppendElement(font);
37211:             }
37211:         }
37211: 
40680:         if (mFonts.Length() == 0) {
40680:             // Try for a "font of last resort...."
40680:             // Because an empty font list would be Really Bad for later code
40680:             // that assumes it will be able to get valid metrics for layout,
40680:             // just look for the first usable font and put in the list.
40680:             // (see bug 554544)
40680:             nsAutoTArray<nsRefPtr<gfxFontFamily>,200> families;
40680:             pfl->GetFontFamilyList(families);
40680:             for (PRUint32 i = 0; i < families.Length(); ++i) {
40680:                 gfxFontEntry *fe = families[i]->FindFontForStyle(mStyle,
40680:                                                                  needsBold);
40680:                 if (fe) {
40680:                     nsRefPtr<gfxFont> font = fe->FindOrMakeFont(&mStyle,
40680:                                                                 needsBold);
40680:                     if (font) {
40680:                         mFonts.AppendElement(font);
40680:                         break;
40680:                     }
40680:                 }
40680:             }
40680:         }
40680: 
40680:         if (mFonts.Length() == 0) {
40680:             // an empty font list at this point is fatal; we're not going to
40680:             // be able to do even the most basic layout operations
40680:             char msg[256]; // CHECK buffer length if revising message below
40680:             sprintf(msg, "unable to find a usable font (%.220s)",
40680:                     NS_ConvertUTF16toUTF8(mFamilies).get());
40680:             NS_RUNTIMEABORT(msg);
40680:         }
40680:     }
40680: 
37211:     if (!mStyle.systemFont) {
37211:         for (PRUint32 i = 0; i < mFonts.Length(); ++i) {
37211:             gfxFont* font = mFonts[i];
37211:             if (font->GetFontEntry()->mIsBadUnderlineFont) {
37211:                 gfxFloat first = mFonts[0]->GetMetrics().underlineOffset;
37211:                 gfxFloat bad = font->GetMetrics().underlineOffset;
72496:                 mUnderlineOffset = NS_MIN(first, bad);
37211:                 break;
37211:             }
37211:         }
37211:     }
37211: #endif
37211: }
37211: 
79445: bool
37211: gfxFontGroup::FindPlatformFont(const nsAString& aName,
37211:                                const nsACString& aGenericName,
79445:                                bool aUseFontSet,
37211:                                void *aClosure)
37211: {
37211:     gfxFontGroup *fontGroup = static_cast<gfxFontGroup*>(aClosure);
37211:     const gfxFontStyle *fontStyle = fontGroup->GetStyle();
37211: 
79445:     bool needsBold;
37211:     gfxFontEntry *fe = nsnull;
37211: 
79445:     bool foundFamily = false;
73730:     if (aUseFontSet) {
63802:         // First, look up in the user font set...
63802:         // If the fontSet matches the family, we must not look for a platform
63802:         // font of the same name, even if we fail to actually get a fontEntry
63802:         // here; we'll fall back to the next name in the CSS font-family list.
37211:         gfxUserFontSet *fs = fontGroup->GetUserFontSet();
37211:         if (fs) {
63802:             // If the fontSet matches the family, but the font has not yet finished
62296:             // loading (nor has its load timeout fired), the fontGroup should wait
63802:             // for the download, and not actually draw its text yet.
79445:             bool waitForUserFont = false;
63802:             fe = fs->FindFontEntry(aName, *fontStyle, foundFamily,
63802:                                    needsBold, waitForUserFont);
62296:             if (!fe && waitForUserFont) {
80486:                 fontGroup->mSkipDrawing = true;
62296:             }
37211:         }
73730:     }
37211: 
63802:     // Not known in the user font set ==> check system fonts
63802:     if (!foundFamily) {
37211:         fe = gfxPlatformFontList::PlatformFontList()->
37211:             FindFontForFamily(aName, fontStyle, needsBold);
37211:     }
37211: 
37211:     // add to the font group, unless it's already there
37211:     if (fe && !fontGroup->HasFont(fe)) {
38202:         nsRefPtr<gfxFont> font = fe->FindOrMakeFont(fontStyle, needsBold);
37211:         if (font) {
37211:             fontGroup->mFonts.AppendElement(font);
37211:         }
37211:     }
37211: 
80486:     return true;
37211: }
37211: 
79445: bool
37211: gfxFontGroup::HasFont(const gfxFontEntry *aFontEntry)
37211: {
37211:     for (PRUint32 i = 0; i < mFonts.Length(); ++i) {
37211:         if (mFonts.ElementAt(i)->GetFontEntry() == aFontEntry)
80486:             return true;
80486:     }
80486:     return false;
19962: }
    1: 
19962: gfxFontGroup::~gfxFontGroup() {
19962:     mFonts.Clear();
19962:     SetUserFontSet(nsnull);
19962: }
19962: 
37211: gfxFontGroup *
37211: gfxFontGroup::Copy(const gfxFontStyle *aStyle)
37211: {
37211:     return new gfxFontGroup(mFamilies, aStyle, mUserFontSet);
37211: }
19962: 
79445: bool 
86691: gfxFontGroup::IsInvalidChar(PRUint8 ch)
86691: {
86691:     return ((ch & 0x7f) < 0x20);
86691: }
86691: 
86691: bool 
86691: gfxFontGroup::IsInvalidChar(PRUnichar ch)
86691: {
86691:     // All printable 7-bit ASCII values are OK
86691:     if (ch >= ' ' && ch < 0x80) {
86691:         return false;
86691:     }
86691:     // No point in sending non-printing control chars through font shaping
86691:     if (ch <= 0x9f) {
86691:         return true;
86691:     }
86691:     return ((ch & 0xFF00) == 0x2000 /* Unicode control character */ &&
19962:          (ch == 0x200B/*ZWSP*/ || ch == 0x2028/*LSEP*/ || ch == 0x2029/*PSEP*/ ||
19962:           IS_BIDI_CONTROL_CHAR(ch)));
19962: }
    1: 
79445: bool
    1: gfxFontGroup::ForEachFont(FontCreationCallback fc,
    1:                           void *closure)
    1: {
38492:     return ForEachFontInternal(mFamilies, mStyle.language,
80486:                                true, true, true, fc, closure);
    1: }
    1: 
79445: bool
    1: gfxFontGroup::ForEachFont(const nsAString& aFamilies,
38493:                           nsIAtom *aLanguage,
    1:                           FontCreationCallback fc,
    1:                           void *closure)
    1: {
38492:     return ForEachFontInternal(aFamilies, aLanguage,
80486:                                false, true, true, fc, closure);
    1: }
    1: 
    1: struct ResolveData {
    1:     ResolveData(gfxFontGroup::FontCreationCallback aCallback,
    1:                 nsACString& aGenericFamily,
79445:                 bool aUseFontSet,
    1:                 void *aClosure) :
    1:         mCallback(aCallback),
    1:         mGenericFamily(aGenericFamily),
73730:         mUseFontSet(aUseFontSet),
    1:         mClosure(aClosure) {
  731:     }
    1:     gfxFontGroup::FontCreationCallback mCallback;
    1:     nsCString mGenericFamily;
79445:     bool mUseFontSet;
    1:     void *mClosure;
    1: };
    1: 
79445: bool
    1: gfxFontGroup::ForEachFontInternal(const nsAString& aFamilies,
38493:                                   nsIAtom *aLanguage,
79445:                                   bool aResolveGeneric,
79445:                                   bool aResolveFontName,
79445:                                   bool aUseFontSet,
    1:                                   FontCreationCallback fc,
    1:                                   void *closure)
    1: {
    1:     const PRUnichar kSingleQuote  = PRUnichar('\'');
    1:     const PRUnichar kDoubleQuote  = PRUnichar('\"');
    1:     const PRUnichar kComma        = PRUnichar(',');
    1: 
38493:     nsIAtom *groupAtom = nsnull;
38493:     nsCAutoString groupString;
38493:     if (aLanguage) {
38492:         if (!gLangService) {
38492:             CallGetService(NS_LANGUAGEATOMSERVICE_CONTRACTID, &gLangService);
38492:         }
38492:         if (gLangService) {
38492:             nsresult rv;
38493:             groupAtom = gLangService->GetLanguageGroup(aLanguage, &rv);
38493:         }
38493:     }
38493:     if (!groupAtom) {
38493:         groupAtom = gfxAtoms::x_unicode;
38493:     }
38493:     groupAtom->ToUTF8String(groupString);
38492: 
    1:     nsPromiseFlatString families(aFamilies);
    1:     const PRUnichar *p, *p_end;
    1:     families.BeginReading(p);
    1:     families.EndReading(p_end);
    1:     nsAutoString family;
    1:     nsCAutoString lcFamily;
    1:     nsAutoString genericFamily;
    1: 
    1:     while (p < p_end) {
40783:         while (nsCRT::IsAsciiSpace(*p) || *p == kComma)
    1:             if (++p == p_end)
80486:                 return true;
    1: 
79445:         bool generic;
    1:         if (*p == kSingleQuote || *p == kDoubleQuote) {
    1:             // quoted font family
    1:             PRUnichar quoteMark = *p;
    1:             if (++p == p_end)
80486:                 return true;
    1:             const PRUnichar *nameStart = p;
    1: 
    1:             // XXX What about CSS character escapes?
    1:             while (*p != quoteMark)
    1:                 if (++p == p_end)
80486:                     return true;
    1: 
    1:             family = Substring(nameStart, p);
80486:             generic = false;
80486:             genericFamily.SetIsVoid(true);
    1: 
    1:             while (++p != p_end && *p != kComma)
    1:                 /* nothing */ ;
    1: 
    1:         } else {
    1:             // unquoted font family
    1:             const PRUnichar *nameStart = p;
    1:             while (++p != p_end && *p != kComma)
    1:                 /* nothing */ ;
    1: 
    1:             family = Substring(nameStart, p);
80486:             family.CompressWhitespace(false, true);
    1: 
    1:             if (aResolveGeneric &&
    1:                 (family.LowerCaseEqualsLiteral("serif") ||
    1:                  family.LowerCaseEqualsLiteral("sans-serif") ||
    1:                  family.LowerCaseEqualsLiteral("monospace") ||
    1:                  family.LowerCaseEqualsLiteral("cursive") ||
    1:                  family.LowerCaseEqualsLiteral("fantasy")))
    1:             {
80486:                 generic = true;
    1: 
    1:                 ToLowerCase(NS_LossyConvertUTF16toASCII(family), lcFamily);
    1: 
    1:                 nsCAutoString prefName("font.name.");
    1:                 prefName.Append(lcFamily);
    1:                 prefName.AppendLiteral(".");
38493:                 prefName.Append(groupString);
    1: 
71640:                 nsAdoptingString value = Preferences::GetString(prefName.get());
71640:                 if (value) {
    1:                     CopyASCIItoUTF16(lcFamily, genericFamily);
71640:                     family = value;
    1:                 }
    1:             } else {
80486:                 generic = false;
80486:                 genericFamily.SetIsVoid(true);
    1:             }
    1:         }
    1: 
73730:         NS_LossyConvertUTF16toASCII gf(genericFamily);
73728:         if (generic) {
80486:             ForEachFontInternal(family, groupAtom, false,
80486:                                 aResolveFontName, false,
74352:                                 fc, closure);
73728:         } else if (!family.IsEmpty()) {
10774:             if (aResolveFontName) {
73730:                 ResolveData data(fc, gf, aUseFontSet, closure);
79445:                 bool aborted = false, needsBold;
63802:                 nsresult rv = NS_OK;
79445:                 bool foundFamily = false;
79445:                 bool waitForUserFont = false;
73730:                 if (aUseFontSet && mUserFontSet &&
63802:                     mUserFontSet->FindFontEntry(family, mStyle, foundFamily,
63802:                                                 needsBold, waitForUserFont))
62296:                 {
19962:                     gfxFontGroup::FontResolverProc(family, &data);
19962:                 } else {
62296:                     if (waitForUserFont) {
80486:                         mSkipDrawing = true;
62296:                     }
63802:                     if (!foundFamily) {
    1:                         gfxPlatform *pf = gfxPlatform::GetPlatform();
19962:                         rv = pf->ResolveFontName(family,
    1:                                                  gfxFontGroup::FontResolverProc,
    1:                                                  &data, aborted);
19962:                     }
63802:                 }
    1:                 if (NS_FAILED(rv) || aborted)
80486:                     return false;
    1:             }
10774:             else {
73730:                 if (!fc(family, gf, aUseFontSet, closure))
80486:                     return false;
10774:             }
10774:         }
    1: 
    1:         if (generic && aResolveGeneric) {
    1:             nsCAutoString prefName("font.name-list.");
    1:             prefName.Append(lcFamily);
    1:             prefName.AppendLiteral(".");
38493:             prefName.Append(groupString);
71640:             nsAdoptingString value = Preferences::GetString(prefName.get());
71640:             if (value) {
80486:                 ForEachFontInternal(value, groupAtom, false,
80486:                                     aResolveFontName, false,
10774:                                     fc, closure);
    1:             }
    1:         }
    1: 
    1:         ++p; // may advance past p_end
    1:     }
    1: 
80486:     return true;
    1: }
    1: 
79445: bool
    1: gfxFontGroup::FontResolverProc(const nsAString& aName, void *aClosure)
    1: {
    1:     ResolveData *data = reinterpret_cast<ResolveData*>(aClosure);
73730:     return (data->mCallback)(aName, data->mGenericFamily, data->mUseFontSet,
73730:                              data->mClosure);
    1: }
    1: 
    1: gfxTextRun *
 1295: gfxFontGroup::MakeEmptyTextRun(const Parameters *aParams, PRUint32 aFlags)
    1: {
 1295:     aFlags |= TEXT_IS_8BIT | TEXT_IS_ASCII | TEXT_IS_PERSISTENT;
 8081:     return gfxTextRun::Create(aParams, nsnull, 0, this, aFlags);
 1295: }
 1100: 
 1295: gfxTextRun *
 1295: gfxFontGroup::MakeSpaceTextRun(const Parameters *aParams, PRUint32 aFlags)
 1295: {
 1295:     aFlags |= TEXT_IS_8BIT | TEXT_IS_ASCII | TEXT_IS_PERSISTENT;
 1100:     static const PRUint8 space = ' ';
 1100: 
86690:     gfxTextRun *textRun = gfxTextRun::Create(aParams, &space, 1, this, aFlags);
86690:     if (!textRun) {
 1100:         return nsnull;
86690:     }
 2317: 
 2317:     gfxFont *font = GetFontAt(0);
10243:     if (NS_UNLIKELY(GetStyle()->size == 0)) {
10243:         // Short-circuit for size-0 fonts, as Windows and ATSUI can't handle
10243:         // them, and always create at least size 1 fonts, i.e. they still
10243:         // render something for size 0 fonts.
80486:         textRun->AddGlyphRun(font, gfxTextRange::kFontGroup, 0, false);
10243:     }
10243:     else {
 2317:         textRun->SetSpaceGlyph(font, aParams->mContext, 0);
10243:     }
86690: 
 6247:     // Note that the gfxGlyphExtents glyph bounds storage for the font will
 6247:     // always contain an entry for the font's space glyph, so we don't have
 6247:     // to call FetchGlyphExtents here.
86690:     return textRun;
86690: }
86690: 
86690: gfxTextRun *
86690: gfxFontGroup::MakeBlankTextRun(const void* aText, PRUint32 aLength,
86690:                                const Parameters *aParams, PRUint32 aFlags)
37211: {
86690:     gfxTextRun *textRun =
86690:         gfxTextRun::Create(aParams, aText, aLength, this, aFlags);
86690:     if (!textRun) {
86690:         return nsnull;
86690:     }
86690: 
86690:     textRun->AddGlyphRun(GetFontAt(0), gfxTextRange::kFontGroup, 0, false);
86690:     return textRun;
37211: }
37211: 
37211: gfxTextRun *
37211: gfxFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
37211:                           const Parameters *aParams, PRUint32 aFlags)
37211: {
86690:     if (aLength == 0) {
86690:         return MakeEmptyTextRun(aParams, aFlags);
86690:     }
86690:     if (aLength == 1 && aString[0] == ' ') {
86690:         return MakeSpaceTextRun(aParams, aFlags);
86690:     }
86690: 
86690:     aFlags |= TEXT_IS_8BIT;
86690: 
86690:     if (GetStyle()->size == 0) {
86690:         // Short-circuit for size-0 fonts, as Windows and ATSUI can't handle
86690:         // them, and always create at least size 1 fonts, i.e. they still
86690:         // render something for size 0 fonts.
86690:         return MakeBlankTextRun(aString, aLength, aParams, aFlags);
86690:     }
86690: 
86690:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength,
86690:                                              this, aFlags);
86690:     if (!textRun) {
37211:         return nsnull;
86690:     }
37211: 
86691:     InitTextRun(aParams->mContext, textRun, aString, aLength);
37211: 
37211:     textRun->FetchGlyphExtents(aParams->mContext);
37211: 
37211:     return textRun;
37211: }
37211: 
37211: gfxTextRun *
37211: gfxFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,
37211:                           const Parameters *aParams, PRUint32 aFlags)
37211: {
86690:     if (aLength == 0) {
86690:         return MakeEmptyTextRun(aParams, aFlags);
86690:     }
86690:     if (aLength == 1 && aString[0] == ' ') {
86690:         return MakeSpaceTextRun(aParams, aFlags);
86690:     }
86690:     if (GetStyle()->size == 0) {
86690:         return MakeBlankTextRun(aString, aLength, aParams, aFlags);
86690:     }
86690: 
86690:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength,
86690:                                              this, aFlags);
86690:     if (!textRun) {
37211:         return nsnull;
86690:     }
37211: 
39206:     InitTextRun(aParams->mContext, textRun, aString, aLength);
37211: 
37211:     textRun->FetchGlyphExtents(aParams->mContext);
37211: 
37211:     return textRun;
37211: }
37211: 
86691: template<typename T>
37211: void
39206: gfxFontGroup::InitTextRun(gfxContext *aContext,
39206:                           gfxTextRun *aTextRun,
86691:                           const T *aString,
37211:                           PRUint32 aLength)
37211: {
86691:     // we need to do numeral processing even on 8-bit text,
86691:     // in case we're converting Western to Hindi/Arabic digits
86691:     PRInt32 numOption = gfxPlatform::GetPlatform()->GetBidiNumeralOption();
86691:     nsAutoArrayPtr<PRUnichar> transformedString;
86691:     if (numOption != IBMBIDI_NUMERAL_NOMINAL) {
86691:         // scan the string for numerals that may need to be transformed;
86691:         // if we find any, we'll make a local copy here and use that for
86691:         // font matching and glyph generation/shaping
86691:         bool prevIsArabic =
86691:             (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_INCOMING_ARABICCHAR) != 0;
86691:         for (PRUint32 i = 0; i < aLength; ++i) {
86691:             PRUnichar origCh = aString[i];
86691:             PRUnichar newCh = HandleNumberInChar(origCh, prevIsArabic, numOption);
86691:             if (newCh != origCh) {
86691:                 if (!transformedString) {
86691:                     transformedString = new PRUnichar[aLength];
86691:                     if (sizeof(T) == sizeof(PRUnichar)) {
86691:                         memcpy(transformedString.get(), aString, i * sizeof(PRUnichar));
86691:                     } else {
86691:                         for (PRUint32 j = 0; j < i; ++j) {
86691:                             transformedString[j] = aString[j];
86691:                         }
86691:                     }
86691:                 }
86691:             }
86691:             if (transformedString) {
86691:                 transformedString[i] = newCh;
86691:             }
86691:             prevIsArabic = IS_ARABIC_CHAR(newCh);
86691:         }
86691:     }
86691: 
86691:     if (sizeof(T) == sizeof(PRUint8) && !transformedString) {
86691:         // the text is still purely 8-bit; bypass the script-run itemizer
86691:         // and treat it as a single Latin run
86691:         InitScriptRun(aContext, aTextRun, aString,
90072:                       0, aLength, MOZ_SCRIPT_LATIN);
86691:     } else {
86691:         const PRUnichar *textPtr;
86691:         if (transformedString) {
86691:             textPtr = transformedString.get();
86691:         } else {
86691:             // typecast to avoid compilation error for the 8-bit version,
86691:             // even though this is dead code in that case
86691:             textPtr = reinterpret_cast<const PRUnichar*>(aString);
86691:         }
86691: 
43525:         // split into script runs so that script can potentially influence
43525:         // the font matching process below
86691:         gfxScriptItemizer scriptRuns(textPtr, aLength);
43525: 
61084: #ifdef PR_LOGGING
61084:         PRLogModuleInfo *log = (mStyle.systemFont ?
61084:                                 gfxPlatform::GetLog(eGfxLog_textrunui) :
61084:                                 gfxPlatform::GetLog(eGfxLog_textrun));
61084: #endif
61084: 
43525:         PRUint32 runStart = 0, runLimit = aLength;
90072:         PRInt32 runScript = MOZ_SCRIPT_LATIN;
43525:         while (scriptRuns.Next(runStart, runLimit, runScript)) {
61084: 
61084: #ifdef PR_LOGGING
61084:             if (NS_UNLIKELY(log)) {
61084:                 nsCAutoString lang;
61084:                 mStyle.language->ToUTF8String(lang);
61084:                 PRUint32 runLen = runLimit - runStart;
91870:                 PR_LOG(log, PR_LOG_WARNING,\
61084:                        ("(%s) fontgroup: [%s] lang: %s script: %d len %d "
61084:                         "weight: %d width: %d style: %s "
61084:                         "TEXTRUN [%s] ENDTEXTRUN\n",
61084:                         (mStyle.systemFont ? "textrunui" : "textrun"),
61084:                         NS_ConvertUTF16toUTF8(mFamilies).get(),
61084:                         lang.get(), runScript, runLen,
61084:                         PRUint32(mStyle.weight), PRUint32(mStyle.stretch),
61084:                         (mStyle.style & FONT_STYLE_ITALIC ? "italic" :
61084:                         (mStyle.style & FONT_STYLE_OBLIQUE ? "oblique" :
61084:                                                                 "normal")),
86691:                         NS_ConvertUTF16toUTF8(textPtr + runStart, runLen).get()));
61084:             }
61084: #endif
61084: 
86691:             InitScriptRun(aContext, aTextRun, textPtr,
43525:                           runStart, runLimit, runScript);
43525:         }
86691:     }
86691: 
86691:     if (sizeof(T) == sizeof(PRUnichar) && aLength > 0) {
86691:         gfxTextRun::CompressedGlyph *glyph = aTextRun->GetCharacterGlyphs();
86691:         if (!glyph->IsSimpleGlyph()) {
86691:             glyph->SetClusterStart(true);
86691:         }
86691:     }
58936: 
77487:     // It's possible for CoreText to omit glyph runs if it decides they contain
77487:     // only invisibles (e.g., U+FEFF, see reftest 474417-1). In this case, we
77487:     // need to eliminate them from the glyph run array to avoid drawing "partial
77487:     // ligatures" with the wrong font.
77487:     // We don't do this during InitScriptRun (or gfxFont::InitTextRun) because
77487:     // it will iterate back over all glyphruns in the textrun, which leads to
77487:     // pathologically-bad perf in the case where a textrun contains many script
77487:     // changes (see bug 680402) - we'd end up re-sanitizing all the earlier runs
77487:     // every time a new script subrun is processed.
77487:     aTextRun->SanitizeGlyphRuns();
77487: 
58936:     aTextRun->SortGlyphRuns();
43525: }
43525: 
86691: template<typename T>
43525: void
60118: gfxFontGroup::InitScriptRun(gfxContext *aContext,
43525:                             gfxTextRun *aTextRun,
86691:                             const T *aString,
43525:                             PRUint32 aScriptRunStart,
43525:                             PRUint32 aScriptRunEnd,
43525:                             PRInt32 aRunScript)
43525: {
86691:     gfxFont *mainFont = GetFontAt(0);
37211: 
43525:     PRUint32 runStart = aScriptRunStart;
37211:     nsAutoTArray<gfxTextRange,3> fontRanges;
86691:     ComputeRanges(fontRanges, aString + aScriptRunStart,
86691:                   aScriptRunEnd - aScriptRunStart, aRunScript);
37211:     PRUint32 numRanges = fontRanges.Length();
37211: 
37211:     for (PRUint32 r = 0; r < numRanges; r++) {
37211:         const gfxTextRange& range = fontRanges[r];
37211:         PRUint32 matchedLength = range.Length();
37211:         gfxFont *matchedFont = (range.font ? range.font.get() : nsnull);
37211: 
49697:         // create the glyph run for this range
71910:         if (matchedFont) {
71910:             aTextRun->AddGlyphRun(matchedFont, range.matchType,
49697:                                   runStart, (matchedLength > 0));
39206:             // do glyph layout and record the resulting positioned glyphs
60118:             if (!matchedFont->SplitAndInitTextRun(aContext, aTextRun, aString,
49697:                                                   runStart, matchedLength,
49697:                                                   aRunScript)) {
49697:                 // glyph layout failed! treat as missing glyphs
49697:                 matchedFont = nsnull;
49697:             }
86697:         } else {
86697:             aTextRun->AddGlyphRun(mainFont, gfxTextRange::kFontGroup,
86697:                                   runStart, (matchedLength > 0));
86697:         }
86697: 
49697:         if (!matchedFont) {
86691:             // for PRUnichar text, we need to set cluster boundaries so that
86691:             // surrogate pairs, combining characters, etc behave properly,
86691:             // even if we don't have glyphs for them
86691:             if (sizeof(T) == sizeof(PRUnichar)) {
86691:                 gfxShapedWord::SetupClusterBoundaries(aTextRun->GetCharacterGlyphs() + runStart,
86691:                                                       reinterpret_cast<const PRUnichar*>(aString) + runStart,
86691:                                                       matchedLength);
86691:             }
86697: 
86697:             // various "missing" characters may need special handling,
86697:             // so we check for them here
86697:             PRUint32 runLimit = runStart + matchedLength;
86697:             for (PRUint32 index = runStart; index < runLimit; index++) {
86691:                 T ch = aString[index];
86697: 
86697:                 // tab and newline are not to be displayed as hexboxes,
86697:                 // but do need to be recorded in the textrun
86697:                 if (ch == '\n') {
86697:                     aTextRun->SetIsNewline(index);
86697:                     continue;
86697:                 }
86697:                 if (ch == '\t') {
86697:                     aTextRun->SetIsTab(index);
86697:                     continue;
86697:                 }
86697: 
86697:                 // for 16-bit textruns only, check for surrogate pairs and
86697:                 // special Unicode spaces; omit these checks in 8-bit runs
86697:                 if (sizeof(T) == sizeof(PRUnichar)) {
86697:                     if (NS_IS_HIGH_SURROGATE(ch) &&
43525:                         index + 1 < aScriptRunEnd &&
86697:                         NS_IS_LOW_SURROGATE(aString[index + 1]))
86697:                     {
37211:                         aTextRun->SetMissingGlyph(index,
86691:                                                   SURROGATE_TO_UCS4(ch,
37211:                                                                     aString[index + 1]));
37211:                         index++;
86697:                         aTextRun->SetIsLowSurrogate(index);
86697:                         continue;
86697:                     }
86697: 
86697:                     // check if this is a known Unicode whitespace character that
86697:                     // we can render using the space glyph with a custom width
69197:                     gfxFloat wid = mainFont->SynthesizeSpaceWidth(ch);
69197:                     if (wid >= 0.0) {
69197:                         nscoord advance =
75359:                             aTextRun->GetAppUnitsPerDevUnit() * floor(wid + 0.5);
69197:                         gfxTextRun::CompressedGlyph g;
69197:                         if (gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance)) {
69197:                             aTextRun->SetSimpleGlyph(index,
69197:                                                      g.SetSimpleGlyph(advance,
69197:                                                          mainFont->GetSpaceGlyph()));
69197:                         } else {
69197:                             gfxTextRun::DetailedGlyph detailedGlyph;
69197:                             detailedGlyph.mGlyphID = mainFont->GetSpaceGlyph();
69197:                             detailedGlyph.mAdvance = advance;
69197:                             detailedGlyph.mXOffset = detailedGlyph.mYOffset = 0;
80486:                             g.SetComplex(true, true, 1);
69197:                             aTextRun->SetGlyphs(index,
69197:                                                 g, &detailedGlyph);
69197:                         }
86697:                         continue;
86697:                     }
86697:                 }
86697: 
86697:                 if (IsInvalidChar(ch)) {
86697:                     // invalid chars are left as zero-width/invisible
86697:                     continue;
86697:                 }
86697: 
86697:                 // record char code so we can draw a box with the Unicode value
69197:                 aTextRun->SetMissingGlyph(index, ch);
69197:             }
37211:         }
37211: 
37211:         runStart += matchedLength;
37211:     }
47360: }
16418: 
16418: already_AddRefed<gfxFont>
57263: gfxFontGroup::FindFontForChar(PRUint32 aCh, PRUint32 aPrevCh,
71910:                               PRInt32 aRunScript, gfxFont *aPrevMatchedFont,
71910:                               PRUint8 *aMatchType)
16418: {
16418:     nsRefPtr<gfxFont>    selectedFont;
16418: 
86970:     if (aPrevMatchedFont) {
86970:         // Don't switch fonts for control characters, regardless of
86970:         // whether they are present in the current font, as they won't
86970:         // actually be rendered (see bug 716229)
90890:         PRUint8 category = GetGeneralCategory(aCh);
90072:         if (category == HB_UNICODE_GENERAL_CATEGORY_CONTROL) {
86970:             selectedFont = aPrevMatchedFont;
86970:             return selectedFont.forget();
86970:         }
86970: 
72825:         // if this character is a join-control or the previous is a join-causer,
36291:         // use the same font as the previous range if we can
86970:         if (gfxFontUtils::IsJoinControl(aCh) ||
86970:             gfxFontUtils::IsJoinCauser(aPrevCh)) {
86970:             if (aPrevMatchedFont->HasCharacter(aCh)) {
16418:                 selectedFont = aPrevMatchedFont;
16418:                 return selectedFont.forget();
16418:             }
16418:         }
86970:     }
16418: 
42989:     // if this character is a variation selector,
42989:     // use the previous font regardless of whether it supports VS or not.
42989:     // otherwise the text run will be divided.
42989:     if (gfxFontUtils::IsVarSelector(aCh)) {
42989:         if (aPrevMatchedFont) {
42989:             selectedFont = aPrevMatchedFont;
42989:             return selectedFont.forget();
42989:         }
42989:         // VS alone. it's meaningless to search different fonts
42989:         return nsnull;
42989:     }
42989: 
16418:     // 1. check fonts in the font group
16418:     for (PRUint32 i = 0; i < FontListLength(); i++) {
16418:         nsRefPtr<gfxFont> font = GetFontAt(i);
71910:         if (font->HasCharacter(aCh)) {
71910:             *aMatchType = gfxTextRange::kFontGroup;
16418:             return font.forget();
16418:         }
91870: 
90083:         // check other faces of the family
90083:         gfxFontFamily *family = font->GetFontEntry()->Family();
90084:         if (family && family->TestCharacterMap(aCh)) {
91871:             GlobalFontMatch matchData(aCh, aRunScript, &mStyle);
91871:             family->SearchAllFontsForChar(&matchData);
90083:             gfxFontEntry *fe = matchData.mBestMatch;
90083:             if (fe) {
90083:                 bool needsBold =
90083:                     font->GetStyle()->weight >= 600 && !fe->IsBold();
90083:                 selectedFont =
90083:                     fe->FindOrMakeFont(font->GetStyle(), needsBold);
90083:                 if (selectedFont) {
90083:                     return selectedFont.forget();
90083:                 }
90083:             }
90083:         }
71910:     }
16418: 
16418:     // if character is in Private Use Area, don't do matching against pref or system fonts
16418:     if ((aCh >= 0xE000  && aCh <= 0xF8FF) || (aCh >= 0xF0000 && aCh <= 0x10FFFD))
16418:         return nsnull;
16418: 
16418:     // 2. search pref fonts
16418:     if ((selectedFont = WhichPrefFontSupportsChar(aCh))) {
71910:         *aMatchType = gfxTextRange::kPrefsFallback;
16418:         return selectedFont.forget();
16418:     }
16418: 
16418:     // 3. use fallback fonts
16418:     // -- before searching for something else check the font used for the previous character
16418:     if (!selectedFont && aPrevMatchedFont && aPrevMatchedFont->HasCharacter(aCh)) {
71910:         *aMatchType = gfxTextRange::kSystemFallback;
16418:         selectedFont = aPrevMatchedFont;
16418:         return selectedFont.forget();
16418:     }
16418: 
91870:     // never fall back for characters from unknown scripts
91870:     if (aRunScript == HB_SCRIPT_UNKNOWN) {
91870:         return nsnull;
91870:     }
91870: 
69197:     // for known "space" characters, don't do a full system-fallback search;
69197:     // we'll synthesize appropriate-width spaces instead of missing-glyph boxes
90890:     if (GetGeneralCategory(aCh) ==
90072:             HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR &&
69197:         GetFontAt(0)->SynthesizeSpaceWidth(aCh) >= 0.0)
69197:     {
69197:         return nsnull;
69197:     }
69197: 
16418:     // -- otherwise look for other stuff
16418:     if (!selectedFont) {
71910:         *aMatchType = gfxTextRange::kSystemFallback;
91870:         selectedFont = WhichSystemFontSupportsChar(aCh, aRunScript);
16418:         return selectedFont.forget();
16418:     }
16418: 
16418:     return nsnull;
16418: }
16418: 
86691: template<typename T>
57263: void gfxFontGroup::ComputeRanges(nsTArray<gfxTextRange>& aRanges,
86691:                                  const T *aString, PRUint32 aLength,
57263:                                  PRInt32 aRunScript)
16418: {
16418:     aRanges.Clear();
16418: 
86691:     if (aLength == 0) {
27156:         return;
27156:     }
27156: 
16418:     PRUint32 prevCh = 0;
71910:     PRUint8 matchType = 0;
60435: 
87358:     // initialize prevFont to the group's primary font, so that this will be
87358:     // used for string-initial control chars, etc rather than risk hitting font
87358:     // fallback for these (bug 716229)
87358:     gfxFont *prevFont = GetFontAt(0);
87358: 
86691:     for (PRUint32 i = 0; i < aLength; i++) {
16418: 
16418:         const PRUint32 origI = i; // save off in case we increase for surrogate
16418: 
16418:         // set up current ch
86691:         PRUint32 ch = aString[i];
86691: 
86691:         // in 16-bit case only, check for surrogate pair
86691:         if (sizeof(T) == sizeof(PRUnichar)) {
86691:             if ((i + 1 < aLength) && NS_IS_HIGH_SURROGATE(ch) &&
86691:                                  NS_IS_LOW_SURROGATE(aString[i + 1])) {
16418:                 i++;
86691:                 ch = SURROGATE_TO_UCS4(ch, aString[i]);
86691:             }
86691:         }
86691: 
86691:         if (ch == 0xa0) {
86691:             ch = ' ';
16418:         }
16418: 
16418:         // find the font for this char
57263:         nsRefPtr<gfxFont> font =
71910:             FindFontForChar(ch, prevCh, aRunScript, prevFont, &matchType);
16418: 
16418:         prevCh = ch;
16418: 
16418:         if (aRanges.Length() == 0) {
16418:             // first char ==> make a new range
71910:             aRanges.AppendElement(gfxTextRange(0, 1, font, matchType));
60435:             prevFont = font;
16418:         } else {
16418:             // if font has changed, make a new range
16418:             gfxTextRange& prevRange = aRanges[aRanges.Length() - 1];
71910:             if (prevRange.font != font || prevRange.matchType != matchType) {
16418:                 // close out the previous range
16418:                 prevRange.end = origI;
86691:                 aRanges.AppendElement(gfxTextRange(origI, i + 1,
86691:                                                    font, matchType));
60435: 
60435:                 // update prevFont for the next match, *unless* we switched
60435:                 // fonts on a ZWJ, in which case propagating the changed font
60435:                 // is probably not a good idea (see bug 619511)
86691:                 if (sizeof(T) == sizeof(PRUint8) ||
86691:                     !gfxFontUtils::IsJoinCauser(ch))
86691:                 {
60435:                     prevFont = font;
60435:                 }
16418:             }
16418:         }
16418:     }
86691:     aRanges[aRanges.Length() - 1].end = aLength;
16418: }
16418: 
19962: gfxUserFontSet* 
19962: gfxFontGroup::GetUserFontSet()
19962: {
19962:     return mUserFontSet;
19962: }
19962: 
19962: void 
19962: gfxFontGroup::SetUserFontSet(gfxUserFontSet *aUserFontSet)
19962: {
19962:     NS_IF_RELEASE(mUserFontSet);
19962:     mUserFontSet = aUserFontSet;
19962:     NS_IF_ADDREF(mUserFontSet);
19962:     mCurrGeneration = GetGeneration();
19962: }
19962: 
19962: PRUint64
19962: gfxFontGroup::GetGeneration()
19962: {
19962:     if (!mUserFontSet)
19962:         return 0;
19962:     return mUserFontSet->GetGeneration();
19962: }
19962: 
37211: void
37211: gfxFontGroup::UpdateFontList()
37211: {
37211:     if (mUserFontSet && mCurrGeneration != GetGeneration()) {
37211:         // xxx - can probably improve this to detect when all fonts were found, so no need to update list
37211:         mFonts.Clear();
37211:         mUnderlineOffset = UNDERLINE_OFFSET_NOT_SET;
80486:         mSkipDrawing = false;
38461: 
38461:         // bug 548184 - need to clean up FT2, OS/2 platform code to use BuildFontList
71958: #if defined(XP_MACOSX) || defined(XP_WIN) || defined(ANDROID)
38461:         BuildFontList();
38461: #else
37211:         ForEachFont(FindPlatformFont, this);
38461: #endif
37211:         mCurrGeneration = GetGeneration();
37211:     }
37211: }
37211: 
37211: struct PrefFontCallbackData {
37211:     PrefFontCallbackData(nsTArray<nsRefPtr<gfxFontFamily> >& aFamiliesArray)
37211:         : mPrefFamilies(aFamiliesArray)
37211:     {}
37211: 
37211:     nsTArray<nsRefPtr<gfxFontFamily> >& mPrefFamilies;
37211: 
79445:     static bool AddFontFamilyEntry(eFontPrefLang aLang, const nsAString& aName, void *aClosure)
37211:     {
37211:         PrefFontCallbackData *prefFontData = static_cast<PrefFontCallbackData*>(aClosure);
37211: 
37211:         gfxFontFamily *family = gfxPlatformFontList::PlatformFontList()->FindFamily(aName);
37211:         if (family) {
37211:             prefFontData->mPrefFamilies.AppendElement(family);
37211:         }
80486:         return true;
37211:     }
37211: };
37211: 
37211: already_AddRefed<gfxFont>
37211: gfxFontGroup::WhichPrefFontSupportsChar(PRUint32 aCh)
37211: {
37211:     gfxFont *font;
37211: 
37211:     // get the pref font list if it hasn't been set up already
37211:     PRUint32 unicodeRange = FindCharUnicodeRange(aCh);
37211:     eFontPrefLang charLang = gfxPlatform::GetPlatform()->GetFontPrefLangFor(unicodeRange);
37211: 
37211:     // if the last pref font was the first family in the pref list, no need to recheck through a list of families
37211:     if (mLastPrefFont && charLang == mLastPrefLang &&
37211:         mLastPrefFirstFont && mLastPrefFont->HasCharacter(aCh)) {
37211:         font = mLastPrefFont;
37211:         NS_ADDREF(font);
37211:         return font;
37211:     }
37211: 
37211:     // based on char lang and page lang, set up list of pref lang fonts to check
37211:     eFontPrefLang prefLangs[kMaxLenPrefLangList];
37211:     PRUint32 i, numLangs = 0;
37211: 
37211:     gfxPlatform::GetPlatform()->GetLangPrefs(prefLangs, numLangs, charLang, mPageLang);
37211: 
37211:     for (i = 0; i < numLangs; i++) {
37211:         nsAutoTArray<nsRefPtr<gfxFontFamily>, 5> families;
37211:         eFontPrefLang currentLang = prefLangs[i];
37211: 
37211:         gfxPlatformFontList *fontList = gfxPlatformFontList::PlatformFontList();
37211: 
37211:         // get the pref families for a single pref lang
37211:         if (!fontList->GetPrefFontFamilyEntries(currentLang, &families)) {
37211:             eFontPrefLang prefLangsToSearch[1] = { currentLang };
37211:             PrefFontCallbackData prefFontData(families);
37211:             gfxPlatform::ForEachPrefFont(prefLangsToSearch, 1, PrefFontCallbackData::AddFontFamilyEntry,
37211:                                            &prefFontData);
37211:             fontList->SetPrefFontFamilyEntries(currentLang, families);
37211:         }
37211: 
37211:         // find the first pref font that includes the character
58654:         PRUint32  j, numPrefs;
37211:         numPrefs = families.Length();
58654:         for (j = 0; j < numPrefs; j++) {
37211:             // look up the appropriate face
58654:             gfxFontFamily *family = families[j];
37211:             if (!family) continue;
37211: 
37211:             // if a pref font is used, it's likely to be used again in the same text run.
37211:             // the style doesn't change so the face lookup can be cached rather than calling
38202:             // FindOrMakeFont repeatedly.  speeds up FindFontForChar lookup times for subsequent
37211:             // pref font lookups
37211:             if (family == mLastPrefFamily && mLastPrefFont->HasCharacter(aCh)) {
37211:                 font = mLastPrefFont;
37211:                 NS_ADDREF(font);
37211:                 return font;
37211:             }
37211: 
79445:             bool needsBold;
37211:             gfxFontEntry *fe = family->FindFontForStyle(mStyle, needsBold);
37211:             // if ch in cmap, create and return a gfxFont
37211:             if (fe && fe->TestCharacterMap(aCh)) {
38202:                 nsRefPtr<gfxFont> prefFont = fe->FindOrMakeFont(&mStyle, needsBold);
37211:                 if (!prefFont) continue;
37211:                 mLastPrefFamily = family;
37211:                 mLastPrefFont = prefFont;
37211:                 mLastPrefLang = charLang;
58654:                 mLastPrefFirstFont = (i == 0 && j == 0);
37211:                 return prefFont.forget();
37211:             }
37211: 
37211:         }
37211:     }
37211: 
37211:     return nsnull;
37211: }
37211: 
37211: already_AddRefed<gfxFont>
91870: gfxFontGroup::WhichSystemFontSupportsChar(PRUint32 aCh, PRInt32 aRunScript)
37211: {
37211:     gfxFontEntry *fe = 
91870:         gfxPlatformFontList::PlatformFontList()->
91870:             SystemFindFontForChar(aCh, aRunScript, &mStyle);
37211:     if (fe) {
91870:         // ignore bolder considerations in system fallback case...
91870:         nsRefPtr<gfxFont> font = fe->FindOrMakeFont(&mStyle, false);
37211:         return font.forget();
37211:     }
37211: 
37211:     return nsnull;
37211: }
16418: 
38492: /*static*/ void
38492: gfxFontGroup::Shutdown()
38492: {
38492:     NS_IF_RELEASE(gLangService);
38492: }
38492: 
38492: nsILanguageAtomService* gfxFontGroup::gLangService = nsnull;
38492: 
38492: 
12929: #define DEFAULT_PIXEL_FONT_SIZE 16.0f
12929: 
47360: /*static*/ void
47360: gfxFontStyle::ParseFontFeatureSettings(const nsString& aFeatureString,
47360:                                        nsTArray<gfxFontFeature>& aFeatures)
47360: {
47360:   aFeatures.Clear();
47360:   PRUint32 offset = 0;
47360:   while (offset < aFeatureString.Length()) {
47360:     // skip whitespace
47360:     while (offset < aFeatureString.Length() &&
47360:            nsCRT::IsAsciiSpace(aFeatureString[offset])) {
47360:       ++offset;
47360:     }
47360:     PRInt32 limit = aFeatureString.FindChar(',', offset);
47360:     if (limit < 0) {
47360:       limit = aFeatureString.Length();
47360:     }
47360:     // check that we have enough text for a 4-char tag,
47360:     // the '=' sign, and at least one digit
47360:     if (offset + 6 <= PRUint32(limit) &&
47360:       aFeatureString[offset+4] == '=') {
47360:       gfxFontFeature setting;
47360:       setting.mTag =
47360:         ((aFeatureString[offset] & 0xff) << 24) +
47360:         ((aFeatureString[offset+1] & 0xff) << 16) +
47360:         ((aFeatureString[offset+2] & 0xff) << 8) +
47360:          (aFeatureString[offset+3] & 0xff);
47360:       nsString valString;
47360:       aFeatureString.Mid(valString, offset+5, limit-offset-5);
47360:       PRInt32 rv;
47360:       setting.mValue = valString.ToInteger(&rv);
47360:       if (rv == NS_OK) {
92098:         PRUint32 i;
92098:         // could optimize this based on the fact that the features array
92098:         // is sorted, but it's unlikely to be more than a few entries
92098:         for (i = 0; i < aFeatures.Length(); i++) {
92098:           if (aFeatures[i].mTag == setting.mTag) {
92098:             aFeatures[i].mValue = setting.mValue;
92098:             break;
92098:           }
92098:         }
92098:         if (i == aFeatures.Length()) {
47360:           // we keep the features array sorted so that we can
47360:           // use nsTArray<>::Equals() to compare feature lists
47360:           aFeatures.InsertElementSorted(setting);
47360:         }
47360:       }
92098:     }
47360:     offset = limit + 1;
47360:   }
47360: }
47360: 
47360: /*static*/ PRUint32
47360: gfxFontStyle::ParseFontLanguageOverride(const nsString& aLangTag)
47360: {
47360:   if (!aLangTag.Length() || aLangTag.Length() > 4) {
47360:     return NO_FONT_LANGUAGE_OVERRIDE;
47360:   }
47360:   PRUint32 index, result = 0;
47360:   for (index = 0; index < aLangTag.Length(); ++index) {
47360:     PRUnichar ch = aLangTag[index];
47360:     if (!nsCRT::IsAscii(ch)) { // valid tags are pure ASCII
47360:       return NO_FONT_LANGUAGE_OVERRIDE;
47360:     }
47360:     result = (result << 8) + ch;
47360:   }
47360:   while (index++ < 4) {
47360:     result = (result << 8) + 0x20;
47360:   }
47360:   return result;
47360: }
47360: 
12929: gfxFontStyle::gfxFontStyle() :
80486:     style(FONT_STYLE_NORMAL), systemFont(true), printerFont(false), 
63567:     weight(FONT_WEIGHT_NORMAL),
24408:     stretch(NS_FONT_STRETCH_NORMAL), size(DEFAULT_PIXEL_FONT_SIZE),
47360:     sizeAdjust(0.0f),
47360:     language(gfxAtoms::x_western),
58968:     languageOverride(NO_FONT_LANGUAGE_OVERRIDE)
12929: {
12929: }
12929: 
24408: gfxFontStyle::gfxFontStyle(PRUint8 aStyle, PRUint16 aWeight, PRInt16 aStretch,
38493:                            gfxFloat aSize, nsIAtom *aLanguage,
79445:                            float aSizeAdjust, bool aSystemFont,
79445:                            bool aPrinterFont,
47360:                            const nsString& aFeatureSettings,
47360:                            const nsString& aLanguageOverride):
22866:     style(aStyle), systemFont(aSystemFont), printerFont(aPrinterFont),
63567:     weight(aWeight), stretch(aStretch),
47360:     size(aSize), sizeAdjust(aSizeAdjust),
47360:     language(aLanguage),
58968:     languageOverride(ParseFontLanguageOverride(aLanguageOverride))
    1: {
58968:     ParseFontFeatureSettings(aFeatureSettings, featureSettings);
47360: 
    1:     if (weight > 900)
    1:         weight = 900;
    1:     if (weight < 100)
    1:         weight = 100;
    1: 
 2210:     if (size >= FONT_MAX_SIZE) {
 2210:         size = FONT_MAX_SIZE;
 1985:         sizeAdjust = 0.0;
 1985:     } else if (size < 0.0) {
 1985:         NS_WARNING("negative font size");
 1985:         size = 0.0;
 1985:     }
 1985: 
38493:     if (!language) {
38493:         NS_WARNING("null language");
38493:         language = gfxAtoms::x_western;
    1:     }
    1: }
    1: 
  323: gfxFontStyle::gfxFontStyle(const gfxFontStyle& aStyle) :
22866:     style(aStyle.style), systemFont(aStyle.systemFont), printerFont(aStyle.printerFont),
63567:     weight(aStyle.weight),
47360:     stretch(aStyle.stretch), size(aStyle.size),
47360:     sizeAdjust(aStyle.sizeAdjust),
47360:     language(aStyle.language),
58968:     languageOverride(aStyle.languageOverride)
  323: {
58968:     featureSettings.AppendElements(aStyle.featureSettings);
  323: }
  323: 
57239: PRInt8
57239: gfxFontStyle::ComputeWeight() const
    1: {
    1:     PRInt8 baseWeight = (weight + 50) / 100;
    1: 
    1:     if (baseWeight < 0)
    1:         baseWeight = 0;
    1:     if (baseWeight > 9)
    1:         baseWeight = 9;
    1: 
57239:     return baseWeight;
    1: }
    1: 
86691: // This is not a member function of gfxShapedWord because it is also used
86691: // by gfxFontGroup on missing-glyph runs, where we don't actually "shape"
86691: // anything but still need to set cluster info.
86691: /*static*/ void
86691: gfxShapedWord::SetupClusterBoundaries(CompressedGlyph *aGlyphs,
86691:                                       const PRUnichar *aString, PRUint32 aLength)
86691: {
86691:     gfxTextRun::CompressedGlyph extendCluster;
86691:     extendCluster.SetComplex(false, true, 0);
86691: 
91215:     ClusterIterator iter(aString, aLength);
91215: 
91215:     // the ClusterIterator won't be able to tell us if the string
91215:     // _begins_ with a cluster-extender, so we handle that here
91215:     if (aLength && IsClusterExtender(*aString)) {
91215:         *aGlyphs = extendCluster;
91215:     }
91215: 
91215:     while (!iter.AtEnd()) {
91215:         // advance iter to the next cluster-start (or end of text)
91215:         iter.Next();
91215:         // step past the first char of the cluster
91215:         aString++;
91215:         aGlyphs++;
91215:         // mark all the rest as cluster-continuations
91215:         while (aString < iter) {
91215:             *aGlyphs++ = extendCluster;
91215:             aString++;
91215:         }
86691:     }
86691: }
86691: 
86691: gfxShapedWord::DetailedGlyph *
86691: gfxShapedWord::AllocateDetailedGlyphs(PRUint32 aIndex, PRUint32 aCount)
86691: {
86691:     NS_ASSERTION(aIndex < Length(), "Index out of range");
86691: 
86691:     if (!mDetailedGlyphs) {
86691:         mDetailedGlyphs = new DetailedGlyphStore();
86691:     }
86691: 
86691:     DetailedGlyph *details = mDetailedGlyphs->Allocate(aIndex, aCount);
86691:     if (!details) {
86691:         mCharacterGlyphs[aIndex].SetMissing(0);
86691:         return nsnull;
86691:     }
86691: 
86691:     return details;
86691: }
86691: 
86691: void
86691: gfxShapedWord::SetGlyphs(PRUint32 aIndex, CompressedGlyph aGlyph,
86691:                          const DetailedGlyph *aGlyphs)
86691: {
86691:     NS_ASSERTION(!aGlyph.IsSimpleGlyph(), "Simple glyphs not handled here");
86691:     NS_ASSERTION(aIndex > 0 || aGlyph.IsLigatureGroupStart(),
86691:                  "First character can't be a ligature continuation!");
86691: 
86691:     PRUint32 glyphCount = aGlyph.GetGlyphCount();
86691:     if (glyphCount > 0) {
86691:         DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, glyphCount);
86691:         if (!details) {
86691:             return;
86691:         }
86691:         memcpy(details, aGlyphs, sizeof(DetailedGlyph)*glyphCount);
86691:     }
86691:     mCharacterGlyphs[aIndex] = aGlyph;
86691: }
86691: 
86691: #include "ignorable.x-ccmap"
86691: DEFINE_X_CCMAP(gIgnorableCCMapExt, const);
86691: 
86691: static inline bool
86691: IsDefaultIgnorable(PRUint32 aChar)
86691: {
86691:     return CCMAP_HAS_CHAR_EXT(gIgnorableCCMapExt, aChar);
86691: }
86691: 
86691: void
86691: gfxShapedWord::SetMissingGlyph(PRUint32 aIndex, PRUint32 aChar, gfxFont *aFont)
86691: {
86691:     DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, 1);
86691:     if (!details) {
86691:         return;
86691:     }
86691: 
86691:     details->mGlyphID = aChar;
86691:     if (IsDefaultIgnorable(aChar)) {
86691:         // Setting advance width to zero will prevent drawing the hexbox
86691:         details->mAdvance = 0;
86691:     } else {
86691:         gfxFloat width = NS_MAX(aFont->GetMetrics().aveCharWidth,
86691:                                 gfxFontMissingGlyphs::GetDesiredMinWidth(aChar));
86691:         details->mAdvance = PRUint32(width * mAppUnitsPerDevUnit);
86691:     }
86691:     details->mXOffset = 0;
86691:     details->mYOffset = 0;
86691:     mCharacterGlyphs[aIndex].SetMissing(1);
86691: }
86691: 
86691: bool
86691: gfxShapedWord::FilterIfIgnorable(PRUint32 aIndex)
86691: {
86691:     PRUint32 ch = GetCharAt(aIndex);
86691:     if (IsDefaultIgnorable(ch)) {
86691:         DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, 1);
86691:         if (details) {
86691:             details->mGlyphID = ch;
86691:             details->mAdvance = 0;
86691:             details->mXOffset = 0;
86691:             details->mYOffset = 0;
86691:             mCharacterGlyphs[aIndex].SetMissing(1);
86691:             return true;
86691:         }
86691:     }
86691:     return false;
86691: }
86691: 
86691: void
86691: gfxShapedWord::AdjustAdvancesForSyntheticBold(float aSynBoldOffset)
86691: {
86691:     PRUint32 synAppUnitOffset = aSynBoldOffset * mAppUnitsPerDevUnit;
86691:     for (PRUint32 i = 0; i < Length(); ++i) {
86691:          CompressedGlyph *glyphData = &mCharacterGlyphs[i];
86691:          if (glyphData->IsSimpleGlyph()) {
86691:              // simple glyphs ==> just add the advance
86691:              PRInt32 advance = glyphData->GetSimpleAdvance() + synAppUnitOffset;
86691:              if (CompressedGlyph::IsSimpleAdvance(advance)) {
86691:                  glyphData->SetSimpleGlyph(advance, glyphData->GetSimpleGlyph());
86691:              } else {
86691:                  // rare case, tested by making this the default
86691:                  PRUint32 glyphIndex = glyphData->GetSimpleGlyph();
86691:                  glyphData->SetComplex(true, true, 1);
86691:                  DetailedGlyph detail = {glyphIndex, advance, 0, 0};
86691:                  SetGlyphs(i, *glyphData, &detail);
86691:              }
86691:          } else {
86691:              // complex glyphs ==> add offset at cluster/ligature boundaries
86691:              PRUint32 detailedLength = glyphData->GetGlyphCount();
86691:              if (detailedLength) {
86691:                  DetailedGlyph *details = GetDetailedGlyphs(i);
86691:                  if (!details) {
86691:                      continue;
86691:                  }
86691:                  if (IsRightToLeft()) {
86691:                      details[0].mAdvance += synAppUnitOffset;
86691:                  } else {
86691:                      details[detailedLength - 1].mAdvance += synAppUnitOffset;
86691:                  }
86691:              }
86691:          }
86691:     }
86691: }
86691: 
79445: bool
    1: gfxTextRun::GlyphRunIterator::NextRun()  {
    1:     if (mNextIndex >= mTextRun->mGlyphRuns.Length())
80486:         return false;
    1:     mGlyphRun = &mTextRun->mGlyphRuns[mNextIndex];
    1:     if (mGlyphRun->mCharacterOffset >= mEndOffset)
80486:         return false;
    1: 
72496:     mStringStart = NS_MAX(mStartOffset, mGlyphRun->mCharacterOffset);
    1:     PRUint32 last = mNextIndex + 1 < mTextRun->mGlyphRuns.Length()
    1:         ? mTextRun->mGlyphRuns[mNextIndex + 1].mCharacterOffset : mTextRun->mCharacterCount;
72496:     mStringEnd = NS_MIN(mEndOffset, last);
    1: 
    1:     ++mNextIndex;
80486:     return true;
    1: }
    1: 
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005: static void
 3005: AccountStorageForTextRun(gfxTextRun *aTextRun, PRInt32 aSign)
 3005: {
 3005:     // Ignores detailed glyphs... we don't know when those have been constructed
 3005:     // Also ignores gfxSkipChars dynamic storage (which won't be anything
 3005:     // for preformatted text)
 3005:     // Also ignores GlyphRun array, again because it hasn't been constructed
 3005:     // by the time this gets called. If there's only one glyphrun that's stored
 3005:     // directly in the textrun anyway so no additional overhead.
38204:     PRUint32 length = aTextRun->GetLength();
38204:     PRInt32 bytes = length * sizeof(gfxTextRun::CompressedGlyph);
38204:     bytes += sizeof(gfxTextRun);
 3005:     gTextRunStorage += bytes*aSign;
72496:     gTextRunStorageHighWaterMark = NS_MAX(gTextRunStorageHighWaterMark, gTextRunStorage);
 3005: }
 3005: #endif
 3005: 
86697: // Helper for textRun creation to preallocate storage for glyph records;
86697: // this function returns a pointer to the newly-allocated glyph storage.
38204: // Returns nsnull if allocation fails.
86699: void *
86699: gfxTextRun::AllocateStorageForTextRun(size_t aSize, PRUint32 aLength)
38204: {
86699:     // Allocate the storage we need, returning nsnull on failure rather than
86699:     // throwing an exception (because web content can create huge runs).
86699:     void *storage = moz_malloc(aSize + aLength * sizeof(CompressedGlyph));
38204:     if (!storage) {
86699:         NS_WARNING("failed to allocate storage for text run!");
38204:         return nsnull;
38204:     }
38204: 
86699:     // Initialize the glyph storage (beyond aSize) to zero
86699:     memset(reinterpret_cast<char*>(storage) + aSize, 0,
86699:            aLength * sizeof(CompressedGlyph));
86699: 
38204:     return storage;
38204: }
38204: 
 8081: gfxTextRun *
 8081: gfxTextRun::Create(const gfxTextRunFactory::Parameters *aParams, const void *aText,
 8081:                    PRUint32 aLength, gfxFontGroup *aFontGroup, PRUint32 aFlags)
 8081: {
86699:     void *storage = AllocateStorageForTextRun(sizeof(gfxTextRun), aLength);
86699:     if (!storage) {
38204:         return nsnull;
38204:     }
38204: 
86699:     return new (storage) gfxTextRun(aParams, aText, aLength, aFontGroup, aFlags);
 8081: }
 8081: 
 1295: gfxTextRun::gfxTextRun(const gfxTextRunFactory::Parameters *aParams, const void *aText,
86699:                        PRUint32 aLength, gfxFontGroup *aFontGroup, PRUint32 aFlags)
86699:   : mUserData(aParams->mUserData),
 1295:     mFontGroup(aFontGroup),
    1:     mAppUnitsPerDevUnit(aParams->mAppUnitsPerDevUnit),
86697:     mFlags(aFlags), mCharacterCount(aLength)
    1: {
 4304:     NS_ASSERTION(mAppUnitsPerDevUnit != 0, "Invalid app unit scale");
 2233:     MOZ_COUNT_CTOR(gfxTextRun);
 1295:     NS_ADDREF(mFontGroup);
86699: 
86699:     mCharacterGlyphs = reinterpret_cast<CompressedGlyph*>(this + 1);
86699: 
    1:     if (aParams->mSkipChars) {
    1:         mSkipChars.TakeFrom(aParams->mSkipChars);
    1:     }
 8081: 
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005:     AccountStorageForTextRun(this, 1);
 3005: #endif
19962: 
62296:     mSkipDrawing = mFontGroup->ShouldSkipDrawing();
 1295: }
 1295: 
 1295: gfxTextRun::~gfxTextRun()
 1295: {
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005:     AccountStorageForTextRun(this, -1);
 3005: #endif
23491: #ifdef DEBUG
23491:     // Make it easy to detect a dead text run
23491:     mFlags = 0xFFFFFFFF;
23491: #endif
38204: 
 1295:     NS_RELEASE(mFontGroup);
 2233:     MOZ_COUNT_DTOR(gfxTextRun);
 1295: }
 1295: 
79445: bool
    1: gfxTextRun::SetPotentialLineBreaks(PRUint32 aStart, PRUint32 aLength,
69311:                                    PRUint8 *aBreakBefore,
 2834:                                    gfxContext *aRefContext)
    1: {
    1:     NS_ASSERTION(aStart + aLength <= mCharacterCount, "Overflow");
    1: 
    1:     PRUint32 changed = 0;
    1:     PRUint32 i;
86699:     CompressedGlyph *charGlyphs = mCharacterGlyphs + aStart;
    1:     for (i = 0; i < aLength; ++i) {
69311:         PRUint8 canBreak = aBreakBefore[i];
86699:         if (canBreak && !charGlyphs[i].IsClusterStart()) {
 4434:             // This can happen ... there is no guarantee that our linebreaking rules
 4434:             // align with the platform's idea of what constitutes a cluster.
 4434:             NS_WARNING("Break suggested inside cluster!");
69311:             canBreak = CompressedGlyph::FLAG_BREAK_TYPE_NONE;
 4434:         }
86699:         changed |= charGlyphs[i].SetCanBreakBefore(canBreak);
    1:     }
    1:     return changed != 0;
    1: }
    1: 
    1: gfxTextRun::LigatureData
 4434: gfxTextRun::ComputeLigatureData(PRUint32 aPartStart, PRUint32 aPartEnd,
 4434:                                 PropertyProvider *aProvider)
    1: {
 4434:     NS_ASSERTION(aPartStart < aPartEnd, "Computing ligature data for empty range");
 4434:     NS_ASSERTION(aPartEnd <= mCharacterCount, "Character length overflow");
 4434:   
    1:     LigatureData result;
 4434:     CompressedGlyph *charGlyphs = mCharacterGlyphs;
    1: 
 4434:     PRUint32 i;
 7715:     for (i = aPartStart; !charGlyphs[i].IsLigatureGroupStart(); --i) {
 4434:         NS_ASSERTION(i > 0, "Ligature at the start of the run??");
    1:     }
 4434:     result.mLigatureStart = i;
 7715:     for (i = aPartStart + 1; i < mCharacterCount && !charGlyphs[i].IsLigatureGroupStart(); ++i) {
 4434:     }
 4434:     result.mLigatureEnd = i;
    1: 
 7715:     PRInt32 ligatureWidth =
62288:         GetAdvanceForGlyphs(result.mLigatureStart, result.mLigatureEnd);
    1:     // Count the number of started clusters we have seen
 4434:     PRUint32 totalClusterCount = 0;
 4434:     PRUint32 partClusterIndex = 0;
 4434:     PRUint32 partClusterCount = 0;
 4434:     for (i = result.mLigatureStart; i < result.mLigatureEnd; ++i) {
14568:         // Treat the first character of the ligature as the start of a
14568:         // cluster for our purposes of allocating ligature width to its
14568:         // characters.
14568:         if (i == result.mLigatureStart || charGlyphs[i].IsClusterStart()) {
 4434:             ++totalClusterCount;
 4434:             if (i < aPartStart) {
 4434:                 ++partClusterIndex;
 4434:             } else if (i < aPartEnd) {
 4434:                 ++partClusterCount;
    1:             }
    1:         }
    1:     }
26688:     NS_ASSERTION(totalClusterCount > 0, "Ligature involving no clusters??");
 4434:     result.mPartAdvance = ligatureWidth*partClusterIndex/totalClusterCount;
 4434:     result.mPartWidth = ligatureWidth*partClusterCount/totalClusterCount;
14568: 
14568:     if (partClusterCount == 0) {
14568:         // nothing to draw
80486:         result.mClipBeforePart = result.mClipAfterPart = true;
14568:     } else {
14568:         // Determine whether we should clip before or after this part when
14568:         // drawing its slice of the ligature.
14568:         // We need to clip before the part if any cluster is drawn before
14568:         // this part.
14568:         result.mClipBeforePart = partClusterIndex > 0;
14568:         // We need to clip after the part if any cluster is drawn after
14568:         // this part.
14568:         result.mClipAfterPart = partClusterIndex + partClusterCount < totalClusterCount;
14568:     }
    1: 
    1:     if (aProvider && (mFlags & gfxTextRunFactory::TEXT_ENABLE_SPACING)) {
 4434:         gfxFont::Spacing spacing;
 4434:         if (aPartStart == result.mLigatureStart) {
 4434:             aProvider->GetSpacing(aPartStart, 1, &spacing);
 4434:             result.mPartWidth += spacing.mBefore;
 4434:         }
 4434:         if (aPartEnd == result.mLigatureEnd) {
 4434:             aProvider->GetSpacing(aPartEnd - 1, 1, &spacing);
 4434:             result.mPartWidth += spacing.mAfter;
 4434:         }
    1:     }
    1: 
    1:     return result;
    1: }
    1: 
 4434: gfxFloat
 4434: gfxTextRun::ComputePartialLigatureWidth(PRUint32 aPartStart, PRUint32 aPartEnd,
 4434:                                         PropertyProvider *aProvider)
 4434: {
 4434:     if (aPartStart >= aPartEnd)
 4434:         return 0;
 4434:     LigatureData data = ComputeLigatureData(aPartStart, aPartEnd, aProvider);
 4434:     return data.mPartWidth;
 4434: }
 4434: 
62288: PRInt32
62288: gfxTextRun::GetAdvanceForGlyphs(PRUint32 aStart, PRUint32 aEnd)
62288: {
62288:     const CompressedGlyph *glyphData = mCharacterGlyphs + aStart;
62288:     PRInt32 advance = 0;
62288:     PRUint32 i;
62288:     for (i = aStart; i < aEnd; ++i, ++glyphData) {
62288:         if (glyphData->IsSimpleGlyph()) {
62288:             advance += glyphData->GetSimpleAdvance();   
62288:         } else {
62288:             PRUint32 glyphCount = glyphData->GetGlyphCount();
62288:             if (glyphCount == 0) {
62288:                 continue;
62288:             }
62288:             const DetailedGlyph *details = GetDetailedGlyphs(i);
62288:             if (details) {
62288:                 PRUint32 j;
62288:                 for (j = 0; j < glyphCount; ++j, ++details) {
62288:                     advance += details->mAdvance;
62288:                 }
62288:             }
62288:         }
62288:     }
62288:     return advance;
62288: }
62288: 
 7715: static void
 7715: GetAdjustedSpacing(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,
 7715:                    gfxTextRun::PropertyProvider *aProvider,
 7715:                    gfxTextRun::PropertyProvider::Spacing *aSpacing)
    1: {
    1:     if (aStart >= aEnd)
    1:         return;
    1: 
    1:     aProvider->GetSpacing(aStart, aEnd - aStart, aSpacing);
    1: 
 7715: #ifdef DEBUG
 7715:     // Check to see if we have spacing inside ligatures
 7715: 
 7715:     const gfxTextRun::CompressedGlyph *charGlyphs = aTextRun->GetCharacterGlyphs();
 7685:     PRUint32 i;
 7685: 
 7685:     for (i = aStart; i < aEnd; ++i) {
 7715:         if (!charGlyphs[i].IsLigatureGroupStart()) {
 2027:             NS_ASSERTION(i == aStart || aSpacing[i - aStart].mBefore == 0,
 2027:                          "Before-spacing inside a ligature!");
 2027:             NS_ASSERTION(i - 1 <= aStart || aSpacing[i - 1 - aStart].mAfter == 0,
 2027:                          "After-spacing inside a ligature!");
    1:         }
    1:     }
 2027: #endif
    1: }
    1: 
79445: bool
    1: gfxTextRun::GetAdjustedSpacingArray(PRUint32 aStart, PRUint32 aEnd,
    1:                                     PropertyProvider *aProvider,
 4434:                                     PRUint32 aSpacingStart, PRUint32 aSpacingEnd,
    1:                                     nsTArray<PropertyProvider::Spacing> *aSpacing)
    1: {
 1386:     if (!aProvider || !(mFlags & gfxTextRunFactory::TEXT_ENABLE_SPACING))
80486:         return false;
    1:     if (!aSpacing->AppendElements(aEnd - aStart))
80486:         return false;
 4434:     memset(aSpacing->Elements(), 0, sizeof(gfxFont::Spacing)*(aSpacingStart - aStart));
 7715:     GetAdjustedSpacing(this, aSpacingStart, aSpacingEnd, aProvider,
 4434:                        aSpacing->Elements() + aSpacingStart - aStart);
 4434:     memset(aSpacing->Elements() + aSpacingEnd - aStart, 0, sizeof(gfxFont::Spacing)*(aEnd - aSpacingEnd));
80486:     return true;
    1: }
    1: 
    1: void
    1: gfxTextRun::ShrinkToLigatureBoundaries(PRUint32 *aStart, PRUint32 *aEnd)
    1: {
    1:     if (*aStart >= *aEnd)
    1:         return;
    1:   
    1:     CompressedGlyph *charGlyphs = mCharacterGlyphs;
    1: 
 7715:     while (*aStart < *aEnd && !charGlyphs[*aStart].IsLigatureGroupStart()) {
 4434:         ++(*aStart);
    1:     }
 4434:     if (*aEnd < mCharacterCount) {
 7715:         while (*aEnd > *aStart && !charGlyphs[*aEnd].IsLigatureGroupStart()) {
 4434:             --(*aEnd);
 4434:         }
    1:     }
    1: }
    1: 
    1: void
    1: gfxTextRun::DrawGlyphs(gfxFont *aFont, gfxContext *aContext,
88295:                        gfxFont::DrawMode aDrawMode, gfxPoint *aPt,
89450:                        gfxPattern *aStrokePattern,
    1:                        PRUint32 aStart, PRUint32 aEnd,
 4434:                        PropertyProvider *aProvider,
 4434:                        PRUint32 aSpacingStart, PRUint32 aSpacingEnd)
    1: {
    1:     nsAutoTArray<PropertyProvider::Spacing,200> spacingBuffer;
79445:     bool haveSpacing = GetAdjustedSpacingArray(aStart, aEnd, aProvider,
 4434:         aSpacingStart, aSpacingEnd, &spacingBuffer);
88295:     aFont->Draw(this, aStart, aEnd, aContext, aDrawMode, aPt,
89450:                 haveSpacing ? spacingBuffer.Elements() : nsnull, aStrokePattern);
    1: }
    1: 
 4434: static void
 4434: ClipPartialLigature(gfxTextRun *aTextRun, gfxFloat *aLeft, gfxFloat *aRight,
 4434:                     gfxFloat aXOrigin, gfxTextRun::LigatureData *aLigature)
 4434: {
14568:     if (aLigature->mClipBeforePart) {
 4434:         if (aTextRun->IsRightToLeft()) {
72496:             *aRight = NS_MIN(*aRight, aXOrigin);
 4434:         } else {
72496:             *aLeft = NS_MAX(*aLeft, aXOrigin);
 4434:         }
 4434:     }
14568:     if (aLigature->mClipAfterPart) {
 4434:         gfxFloat endEdge = aXOrigin + aTextRun->GetDirection()*aLigature->mPartWidth;
 4434:         if (aTextRun->IsRightToLeft()) {
72496:             *aLeft = NS_MAX(*aLeft, endEdge);
 4434:         } else {
72496:             *aRight = NS_MIN(*aRight, endEdge);
 4434:         }
 4434:     }    
 4434: }
 4434: 
 4434: void
60285: gfxTextRun::DrawPartialLigature(gfxFont *aFont, gfxContext *aCtx,
60285:                                 PRUint32 aStart, PRUint32 aEnd,
60285:                                 gfxPoint *aPt,
    1:                                 PropertyProvider *aProvider)
    1: {
    1:     if (aStart >= aEnd)
 4434:         return;
60285: 
60285:     // Need to preserve the path, otherwise this can break canvas text-on-path;
60285:     // in general it seems like a good thing, as naive callers probably won't
60285:     // expect gfxTextRun::Draw to implicitly destroy the current path.
60285:     gfxContextPathAutoSaveRestore savePath(aCtx);
    1: 
    1:     // Draw partial ligature. We hack this by clipping the ligature.
 4434:     LigatureData data = ComputeLigatureData(aStart, aEnd, aProvider);
60285:     gfxRect clipExtents = aCtx->GetClipExtents();
60285:     gfxFloat left = clipExtents.X()*mAppUnitsPerDevUnit;
60285:     gfxFloat right = clipExtents.XMost()*mAppUnitsPerDevUnit;
 4434:     ClipPartialLigature(this, &left, &right, aPt->x, &data);
    1: 
    1:     aCtx->Save();
 1939:     aCtx->NewPath();
    1:     // use division here to ensure that when the rect is aligned on multiples
 1939:     // of mAppUnitsPerDevUnit, we clip to true device unit boundaries.
 1939:     // Also, make sure we snap the rectangle to device pixels.
 1939:     aCtx->Rectangle(gfxRect(left/mAppUnitsPerDevUnit,
60285:                             clipExtents.Y(),
    1:                             (right - left)/mAppUnitsPerDevUnit,
80486:                             clipExtents.Height()), true);
 1939:     aCtx->Clip();
 4434:     gfxFloat direction = GetDirection();
 4434:     gfxPoint pt(aPt->x - direction*data.mPartAdvance, aPt->y);
89450:     DrawGlyphs(aFont, aCtx, gfxFont::GLYPH_FILL, &pt, nsnull, data.mLigatureStart,
 4434:                data.mLigatureEnd, aProvider, aStart, aEnd);
    1:     aCtx->Restore();
    1: 
 4434:     aPt->x += direction*data.mPartWidth;
    1: }
    1: 
13339: // returns true if a glyph run is using a font with synthetic bolding enabled, false otherwise
79445: static bool
13339: HasSyntheticBold(gfxTextRun *aRun, PRUint32 aStart, PRUint32 aLength)
13339: {
13339:     gfxTextRun::GlyphRunIterator iter(aRun, aStart, aLength);
13339:     while (iter.NextRun()) {
13339:         gfxFont *font = iter.GetGlyphRun()->mFont;
13339:         if (font && font->IsSyntheticBold()) {
80486:             return true;
80486:         }
80486:     }
80486: 
80486:     return false;
13339: }
13339: 
13339: // returns true if color is non-opaque (i.e. alpha != 1.0) or completely transparent, false otherwise
13339: // if true, color is set on output
79445: static bool
13339: HasNonOpaqueColor(gfxContext *aContext, gfxRGBA& aCurrentColor)
13339: {
14741:     if (aContext->GetDeviceColor(aCurrentColor)) {
13339:         if (aCurrentColor.a < 1.0 && aCurrentColor.a > 0.0) {
80486:             return true;
80486:         }
80486:     }
80486:         
80486:     return false;
13339: }
13339: 
13339: // helper class for double-buffering drawing with non-opaque color
13339: struct BufferAlphaColor {
13339:     BufferAlphaColor(gfxContext *aContext)
13339:         : mContext(aContext)
13339:     {
13339: 
13339:     }
13339: 
13339:     ~BufferAlphaColor() {}
13339: 
13339:     void PushSolidColor(const gfxRect& aBounds, const gfxRGBA& aAlphaColor, PRUint32 appsPerDevUnit)
13339:     {
13339:         mContext->Save();
13339:         mContext->NewPath();
13339:         mContext->Rectangle(gfxRect(aBounds.X() / appsPerDevUnit,
13339:                     aBounds.Y() / appsPerDevUnit,
13339:                     aBounds.Width() / appsPerDevUnit,
80486:                     aBounds.Height() / appsPerDevUnit), true);
13339:         mContext->Clip();
13339:         mContext->SetColor(gfxRGBA(aAlphaColor.r, aAlphaColor.g, aAlphaColor.b));
13339:         mContext->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
13339:         mAlpha = aAlphaColor.a;
13339:     }
13339: 
13339:     void PopAlpha()
13339:     {
13339:         // pop the text, using the color alpha as the opacity
13339:         mContext->PopGroupToSource();
13339:         mContext->SetOperator(gfxContext::OPERATOR_OVER);
13339:         mContext->Paint(mAlpha);
13339:         mContext->Restore();
13339:     }
13339: 
13339:     gfxContext *mContext;
13339:     gfxFloat mAlpha;
13339: };
13339: 
13339: void
88295: gfxTextRun::Draw(gfxContext *aContext, gfxPoint aPt, gfxFont::DrawMode aDrawMode,
60285:                  PRUint32 aStart, PRUint32 aLength,
89450:                  PropertyProvider *aProvider, gfxFloat *aAdvanceWidth,
89450:                  gfxPattern *aStrokePattern)
    1: {
    1:     NS_ASSERTION(aStart + aLength <= mCharacterCount, "Substring out of range");
88295:     NS_ASSERTION(aDrawMode <= gfxFont::GLYPH_PATH, "GLYPH_PATH cannot be used with GLYPH_FILL or GLYPH_STROKE");
    1: 
    1:     gfxFloat direction = GetDirection();
62296: 
62296:     if (mSkipDrawing) {
62296:         // We're waiting for a user font to finish downloading;
62296:         // but if the caller wants advance width, we need to compute it here
62296:         if (aAdvanceWidth) {
62296:             gfxTextRun::Metrics metrics = MeasureText(aStart, aLength,
62296:                                                       gfxFont::LOOSE_INK_EXTENTS,
62296:                                                       aContext, aProvider);
62296:             *aAdvanceWidth = metrics.mAdvanceWidth * direction;
62296:         }
62296: 
62296:         // return without drawing
62296:         return;
62296:     }
62296: 
    1:     gfxPoint pt = aPt;
    1: 
13339:     // synthetic bolding draws glyphs twice ==> colors with opacity won't draw correctly unless first drawn without alpha
13339:     BufferAlphaColor syntheticBoldBuffer(aContext);
13339:     gfxRGBA currentColor;
79445:     bool needToRestore = false;
13339: 
88295:     if (aDrawMode == gfxFont::GLYPH_FILL && HasNonOpaqueColor(aContext, currentColor)
88295:                                          && HasSyntheticBold(this, aStart, aLength)) {
80486:         needToRestore = true;
13339:         // measure text, use the bounding box
25417:         gfxTextRun::Metrics metrics = MeasureText(aStart, aLength, gfxFont::LOOSE_INK_EXTENTS,
25417:                                                   aContext, aProvider);
13339:         metrics.mBoundingBox.MoveBy(aPt);
13339:         syntheticBoldBuffer.PushSolidColor(metrics.mBoundingBox, currentColor, GetAppUnitsPerDevUnit());
13339:     }
13339: 
    1:     GlyphRunIterator iter(this, aStart, aLength);
    1:     while (iter.NextRun()) {
    1:         gfxFont *font = iter.GetGlyphRun()->mFont;
    1:         PRUint32 start = iter.GetStringStart();
    1:         PRUint32 end = iter.GetStringEnd();
    1:         PRUint32 ligatureRunStart = start;
    1:         PRUint32 ligatureRunEnd = end;
    1:         ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);
    1:         
88295:         if (aDrawMode == gfxFont::GLYPH_FILL) {
60285:             DrawPartialLigature(font, aContext, start, ligatureRunStart, &pt, aProvider);
88295:         }
88295: 
89450:         DrawGlyphs(font, aContext, aDrawMode, &pt, aStrokePattern, ligatureRunStart,
 4434:                    ligatureRunEnd, aProvider, ligatureRunStart, ligatureRunEnd);
88295: 
88295:         if (aDrawMode == gfxFont::GLYPH_FILL) {
60285:             DrawPartialLigature(font, aContext, ligatureRunEnd, end, &pt, aProvider);
    1:         }
88295:     }
    1: 
13339:     // composite result when synthetic bolding used
13339:     if (needToRestore) {
13339:         syntheticBoldBuffer.PopAlpha();
13339:     }
13339: 
    1:     if (aAdvanceWidth) {
    1:         *aAdvanceWidth = (pt.x - aPt.x)*direction;
    1:     }
    1: }
    1: 
    1: void
 4434: gfxTextRun::AccumulateMetricsForRun(gfxFont *aFont,
 4434:                                     PRUint32 aStart, PRUint32 aEnd,
25417:                                     gfxFont::BoundingBoxType aBoundingBoxType,
25417:                                     gfxContext *aRefContext,
 6247:                                     PropertyProvider *aProvider,
 4434:                                     PRUint32 aSpacingStart, PRUint32 aSpacingEnd,
    1:                                     Metrics *aMetrics)
    1: {
    1:     nsAutoTArray<PropertyProvider::Spacing,200> spacingBuffer;
79445:     bool haveSpacing = GetAdjustedSpacingArray(aStart, aEnd, aProvider,
 4434:         aSpacingStart, aSpacingEnd, &spacingBuffer);
25417:     Metrics metrics = aFont->Measure(this, aStart, aEnd, aBoundingBoxType, aRefContext,
    1:                                      haveSpacing ? spacingBuffer.Elements() : nsnull);
16581:     aMetrics->CombineWith(metrics, IsRightToLeft());
    1: }
    1: 
    1: void
    1: gfxTextRun::AccumulatePartialLigatureMetrics(gfxFont *aFont,
25417:     PRUint32 aStart, PRUint32 aEnd,
25417:     gfxFont::BoundingBoxType aBoundingBoxType, gfxContext *aRefContext,
 4434:     PropertyProvider *aProvider, Metrics *aMetrics)
    1: {
 4434:     if (aStart >= aEnd)
    1:         return;
    1: 
    1:     // Measure partial ligature. We hack this by clipping the metrics in the
    1:     // same way we clip the drawing.
 4434:     LigatureData data = ComputeLigatureData(aStart, aEnd, aProvider);
    1: 
    1:     // First measure the complete ligature
    1:     Metrics metrics;
 4434:     AccumulateMetricsForRun(aFont, data.mLigatureStart, data.mLigatureEnd,
25417:                             aBoundingBoxType, aRefContext,
25417:                             aProvider, aStart, aEnd, &metrics);
    1: 
 4434:     // Clip the bounding box to the ligature part
 4434:     gfxFloat bboxLeft = metrics.mBoundingBox.X();
 4434:     gfxFloat bboxRight = metrics.mBoundingBox.XMost();
 4434:     // Where we are going to start "drawing" relative to our left baseline origin
 4434:     gfxFloat origin = IsRightToLeft() ? metrics.mAdvanceWidth - data.mPartAdvance : 0;
 4434:     ClipPartialLigature(this, &bboxLeft, &bboxRight, origin, &data);
68634:     metrics.mBoundingBox.x = bboxLeft;
68634:     metrics.mBoundingBox.width = bboxRight - bboxLeft;
    1: 
 4434:     // mBoundingBox is now relative to the left baseline origin for the entire
 4434:     // ligature. Shift it left.
68634:     metrics.mBoundingBox.x -=
 4434:         IsRightToLeft() ? metrics.mAdvanceWidth - (data.mPartAdvance + data.mPartWidth)
 4434:             : data.mPartAdvance;    
 4434:     metrics.mAdvanceWidth = data.mPartWidth;
    1: 
16581:     aMetrics->CombineWith(metrics, IsRightToLeft());
    1: }
    1: 
    1: gfxTextRun::Metrics
    1: gfxTextRun::MeasureText(PRUint32 aStart, PRUint32 aLength,
25417:                         gfxFont::BoundingBoxType aBoundingBoxType,
25417:                         gfxContext *aRefContext,
    1:                         PropertyProvider *aProvider)
    1: {
    1:     NS_ASSERTION(aStart + aLength <= mCharacterCount, "Substring out of range");
    1: 
    1:     Metrics accumulatedMetrics;
    1:     GlyphRunIterator iter(this, aStart, aLength);
    1:     while (iter.NextRun()) {
    1:         gfxFont *font = iter.GetGlyphRun()->mFont;
 4434:         PRUint32 start = iter.GetStringStart();
 4434:         PRUint32 end = iter.GetStringEnd();
 4434:         PRUint32 ligatureRunStart = start;
 4434:         PRUint32 ligatureRunEnd = end;
    1:         ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);
    1: 
 4434:         AccumulatePartialLigatureMetrics(font, start, ligatureRunStart,
25417:             aBoundingBoxType, aRefContext, aProvider, &accumulatedMetrics);
    1: 
    1:         // XXX This sucks. We have to get glyph extents just so we can detect
25417:         // glyphs outside the font box, even when aBoundingBoxType is LOOSE,
    1:         // even though in almost all cases we could get correct results just
    1:         // by getting some ascent/descent from the font and using our stored
    1:         // advance widths.
    1:         AccumulateMetricsForRun(font,
25417:             ligatureRunStart, ligatureRunEnd, aBoundingBoxType,
 6247:             aRefContext, aProvider, ligatureRunStart, ligatureRunEnd,
    1:             &accumulatedMetrics);
    1: 
 4434:         AccumulatePartialLigatureMetrics(font, ligatureRunEnd, end,
25417:             aBoundingBoxType, aRefContext, aProvider, &accumulatedMetrics);
    1:     }
    1: 
    1:     return accumulatedMetrics;
    1: }
    1: 
    1: #define MEASUREMENT_BUFFER_SIZE 100
    1: 
    1: PRUint32
    1: gfxTextRun::BreakAndMeasureText(PRUint32 aStart, PRUint32 aMaxLength,
79445:                                 bool aLineBreakBefore, gfxFloat aWidth,
    1:                                 PropertyProvider *aProvider,
79445:                                 bool aSuppressInitialBreak,
 1731:                                 gfxFloat *aTrimWhitespace,
25417:                                 Metrics *aMetrics,
25417:                                 gfxFont::BoundingBoxType aBoundingBoxType,
 6247:                                 gfxContext *aRefContext,
79445:                                 bool *aUsedHyphenation,
16166:                                 PRUint32 *aLastBreak,
79445:                                 bool aCanWordWrap,
16166:                                 gfxBreakPriority *aBreakPriority)
    1: {
72496:     aMaxLength = NS_MIN(aMaxLength, mCharacterCount - aStart);
    1: 
    1:     NS_ASSERTION(aStart + aMaxLength <= mCharacterCount, "Substring out of range");
    1: 
    1:     PRUint32 bufferStart = aStart;
72496:     PRUint32 bufferLength = NS_MIN<PRUint32>(aMaxLength, MEASUREMENT_BUFFER_SIZE);
    1:     PropertyProvider::Spacing spacingBuffer[MEASUREMENT_BUFFER_SIZE];
79445:     bool haveSpacing = aProvider && (mFlags & gfxTextRunFactory::TEXT_ENABLE_SPACING) != 0;
    1:     if (haveSpacing) {
 7715:         GetAdjustedSpacing(this, bufferStart, bufferStart + bufferLength, aProvider,
    1:                            spacingBuffer);
    1:     }
79445:     bool hyphenBuffer[MEASUREMENT_BUFFER_SIZE];
79445:     bool haveHyphenation = aProvider &&
69311:         (aProvider->GetHyphensOption() == NS_STYLE_HYPHENS_AUTO ||
69311:          (aProvider->GetHyphensOption() == NS_STYLE_HYPHENS_MANUAL &&
69311:           (mFlags & gfxTextRunFactory::TEXT_ENABLE_HYPHEN_BREAKS) != 0));
    1:     if (haveHyphenation) {
  319:         aProvider->GetHyphenationBreaks(bufferStart, bufferLength,
    1:                                         hyphenBuffer);
    1:     }
    1: 
    1:     gfxFloat width = 0;
    1:     gfxFloat advance = 0;
 2028:     // The number of space characters that can be trimmed
 2028:     PRUint32 trimmableChars = 0;
 2028:     // The amount of space removed by ignoring trimmableChars
 1731:     gfxFloat trimmableAdvance = 0;
    1:     PRInt32 lastBreak = -1;
 2028:     PRInt32 lastBreakTrimmableChars = -1;
 2028:     gfxFloat lastBreakTrimmableAdvance = -1;
79445:     bool aborted = false;
    1:     PRUint32 end = aStart + aMaxLength;
79445:     bool lastBreakUsedHyphenation = false;
    1: 
    1:     PRUint32 ligatureRunStart = aStart;
    1:     PRUint32 ligatureRunEnd = end;
    1:     ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);
    1: 
    1:     PRUint32 i;
    1:     for (i = aStart; i < end; ++i) {
    1:         if (i >= bufferStart + bufferLength) {
    1:             // Fetch more spacing and hyphenation data
    1:             bufferStart = i;
72496:             bufferLength = NS_MIN(aStart + aMaxLength, i + MEASUREMENT_BUFFER_SIZE) - i;
    1:             if (haveSpacing) {
 7715:                 GetAdjustedSpacing(this, bufferStart, bufferStart + bufferLength, aProvider,
    1:                                    spacingBuffer);
    1:             }
    1:             if (haveHyphenation) {
  319:                 aProvider->GetHyphenationBreaks(bufferStart, bufferLength,
    1:                                                 hyphenBuffer);
    1:             }
    1:         }
    1: 
16246:         // There can't be a word-wrap break opportunity at the beginning of the
16246:         // line: if the width is too small for even one character to fit, it 
16246:         // could be the first and last break opportunity on the line, and that
16246:         // would trigger an infinite loop.
16246:         if (!aSuppressInitialBreak || i > aStart) {
79445:             bool lineBreakHere = mCharacterGlyphs[i].CanBreakBefore() == 1;
79445:             bool hyphenation = haveHyphenation && hyphenBuffer[i - bufferStart];
79445:             bool wordWrapping = aCanWordWrap && *aBreakPriority <= eWordWrapBreak;
16246: 
16166:             if (lineBreakHere || hyphenation || wordWrapping) {
    1:                 gfxFloat hyphenatedAdvance = advance;
16166:                 if (!lineBreakHere && !wordWrapping) {
    1:                     hyphenatedAdvance += aProvider->GetHyphenWidth();
    1:                 }
    1:             
 1731:                 if (lastBreak < 0 || width + hyphenatedAdvance - trimmableAdvance <= aWidth) {
    1:                     // We can break here.
    1:                     lastBreak = i;
 2028:                     lastBreakTrimmableChars = trimmableChars;
 2028:                     lastBreakTrimmableAdvance = trimmableAdvance;
16166:                     lastBreakUsedHyphenation = !lineBreakHere && !wordWrapping;
16166:                     *aBreakPriority = hyphenation || lineBreakHere ?
16166:                         eNormalBreak : eWordWrapBreak;
    1:                 }
    1: 
    1:                 width += advance;
    1:                 advance = 0;
 1731:                 if (width - trimmableAdvance > aWidth) {
    1:                     // No more text fits. Abort
80486:                     aborted = true;
    1:                     break;
    1:                 }
    1:             }
16246:         }
    1:         
 7715:         gfxFloat charAdvance;
    1:         if (i >= ligatureRunStart && i < ligatureRunEnd) {
62288:             charAdvance = GetAdvanceForGlyphs(i, i + 1);
    1:             if (haveSpacing) {
    1:                 PropertyProvider::Spacing *space = &spacingBuffer[i - bufferStart];
 1731:                 charAdvance += space->mBefore + space->mAfter;
    1:             }
    1:         } else {
 7715:             charAdvance = ComputePartialLigatureWidth(i, i + 1, aProvider);
 1731:         }
 1731:         
 1731:         advance += charAdvance;
 1731:         if (aTrimWhitespace) {
86697:             if (mCharacterGlyphs[i].CharIsSpace()) {
 1731:                 ++trimmableChars;
 1731:                 trimmableAdvance += charAdvance;
 1731:             } else {
 1731:                 trimmableAdvance = 0;
 1731:                 trimmableChars = 0;
 1731:             }
    1:         }
    1:     }
    1: 
    1:     if (!aborted) {
    1:         width += advance;
    1:     }
    1: 
    1:     // There are three possibilities:
    1:     // 1) all the text fit (width <= aWidth)
    1:     // 2) some of the text fit up to a break opportunity (width > aWidth && lastBreak >= 0)
    1:     // 3) none of the text fits before a break opportunity (width > aWidth && lastBreak < 0)
    1:     PRUint32 charsFit;
79445:     bool usedHyphenation = false;
 1731:     if (width - trimmableAdvance <= aWidth) {
    1:         charsFit = aMaxLength;
    1:     } else if (lastBreak >= 0) {
    1:         charsFit = lastBreak - aStart;
 2028:         trimmableChars = lastBreakTrimmableChars;
 2028:         trimmableAdvance = lastBreakTrimmableAdvance;
 3005:         usedHyphenation = lastBreakUsedHyphenation;
    1:     } else {
    1:         charsFit = aMaxLength;
    1:     }
    1: 
    1:     if (aMetrics) {
 6247:         *aMetrics = MeasureText(aStart, charsFit - trimmableChars,
25417:             aBoundingBoxType, aRefContext, aProvider);
 1731:     }
 1731:     if (aTrimWhitespace) {
 1731:         *aTrimWhitespace = trimmableAdvance;
    1:     }
    1:     if (aUsedHyphenation) {
 3005:         *aUsedHyphenation = usedHyphenation;
    1:     }
    1:     if (aLastBreak && charsFit == aMaxLength) {
    1:         if (lastBreak < 0) {
    1:             *aLastBreak = PR_UINT32_MAX;
    1:         } else {
    1:             *aLastBreak = lastBreak - aStart;
    1:         }
    1:     }
    1: 
    1:     return charsFit;
    1: }
    1: 
    1: gfxFloat
    1: gfxTextRun::GetAdvanceWidth(PRUint32 aStart, PRUint32 aLength,
    1:                             PropertyProvider *aProvider)
    1: {
    1:     NS_ASSERTION(aStart + aLength <= mCharacterCount, "Substring out of range");
    1: 
 2027:     PRUint32 ligatureRunStart = aStart;
 2027:     PRUint32 ligatureRunEnd = aStart + aLength;
 2027:     ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);
    1: 
 4434:     gfxFloat result = ComputePartialLigatureWidth(aStart, ligatureRunStart, aProvider) +
 4434:                       ComputePartialLigatureWidth(ligatureRunEnd, aStart + aLength, aProvider);
 2027: 
 2027:     // Account for all remaining spacing here. This is more efficient than
 2027:     // processing it along with the glyphs.
 1386:     if (aProvider && (mFlags & gfxTextRunFactory::TEXT_ENABLE_SPACING)) {
    1:         PRUint32 i;
    1:         nsAutoTArray<PropertyProvider::Spacing,200> spacingBuffer;
    1:         if (spacingBuffer.AppendElements(aLength)) {
 7715:             GetAdjustedSpacing(this, ligatureRunStart, ligatureRunEnd, aProvider,
    1:                                spacingBuffer.Elements());
 2027:             for (i = 0; i < ligatureRunEnd - ligatureRunStart; ++i) {
    1:                 PropertyProvider::Spacing *space = &spacingBuffer[i];
    1:                 result += space->mBefore + space->mAfter;
    1:             }
    1:         }
    1:     }
    1: 
62288:     return result + GetAdvanceForGlyphs(ligatureRunStart, ligatureRunEnd);
    1: }
    1: 
79445: bool
    1: gfxTextRun::SetLineBreaks(PRUint32 aStart, PRUint32 aLength,
79445:                           bool aLineBreakBefore, bool aLineBreakAfter,
 2834:                           gfxFloat *aAdvanceWidthDelta,
 2834:                           gfxContext *aRefContext)
    1: {
    1:     // Do nothing because our shaping does not currently take linebreaks into
    1:     // account. There is no change in advance width.
    1:     if (aAdvanceWidthDelta) {
    1:         *aAdvanceWidthDelta = 0;
    1:     }
80486:     return false;
    1: }
    1: 
    1: PRUint32
    1: gfxTextRun::FindFirstGlyphRunContaining(PRUint32 aOffset)
    1: {
    1:     NS_ASSERTION(aOffset <= mCharacterCount, "Bad offset looking for glyphrun");
49696:     NS_ASSERTION(mCharacterCount == 0 || mGlyphRuns.Length() > 0,
49696:                  "non-empty text but no glyph runs present!");
    1:     if (aOffset == mCharacterCount)
    1:         return mGlyphRuns.Length();
    1:     PRUint32 start = 0;
    1:     PRUint32 end = mGlyphRuns.Length();
    1:     while (end - start > 1) {
    1:         PRUint32 mid = (start + end)/2;
    1:         if (mGlyphRuns[mid].mCharacterOffset <= aOffset) {
    1:             start = mid;
    1:         } else {
    1:             end = mid;
    1:         }
    1:     }
    1:     NS_ASSERTION(mGlyphRuns[start].mCharacterOffset <= aOffset,
    1:                  "Hmm, something went wrong, aOffset should have been found");
    1:     return start;
    1: }
    1: 
    1: nsresult
71910: gfxTextRun::AddGlyphRun(gfxFont *aFont, PRUint8 aMatchType,
79445:                         PRUint32 aUTF16Offset, bool aForceNewRun)
    1: {
86691:     NS_ASSERTION(aFont, "adding glyph run for null font!");
86691:     if (!aFont) {
86691:         return NS_OK;
86691:     }    
 2317:     PRUint32 numGlyphRuns = mGlyphRuns.Length();
71910:     if (!aForceNewRun && numGlyphRuns > 0) {
 2317:         GlyphRun *lastGlyphRun = &mGlyphRuns[numGlyphRuns - 1];
 2317: 
 2317:         NS_ASSERTION(lastGlyphRun->mCharacterOffset <= aUTF16Offset,
 3609:                      "Glyph runs out of order (and run not forced)");
 2317: 
58936:         // Don't append a run if the font is already the one we want
71910:         if (lastGlyphRun->mFont == aFont &&
71910:             lastGlyphRun->mMatchType == aMatchType)
71910:         {
 2317:             return NS_OK;
71910:         }
58936: 
58936:         // If the offset has not changed, avoid leaving a zero-length run
58936:         // by overwriting the last entry instead of appending...
 2317:         if (lastGlyphRun->mCharacterOffset == aUTF16Offset) {
58936: 
58936:             // ...except that if the run before the last entry had the same
58936:             // font as the new one wants, merge with it instead of creating
58936:             // adjacent runs with the same font
58936:             if (numGlyphRuns > 1 &&
71910:                 mGlyphRuns[numGlyphRuns - 2].mFont == aFont &&
71910:                 mGlyphRuns[numGlyphRuns - 2].mMatchType == aMatchType)
58936:             {
58936:                 mGlyphRuns.TruncateLength(numGlyphRuns - 1);
58936:                 return NS_OK;
58936:             }
58936: 
 2317:             lastGlyphRun->mFont = aFont;
71910:             lastGlyphRun->mMatchType = aMatchType;
 2317:             return NS_OK;
 2317:         }
 2317:     }
 2317: 
 3609:     NS_ASSERTION(aForceNewRun || numGlyphRuns > 0 || aUTF16Offset == 0,
 3609:                  "First run doesn't cover the first character (and run not forced)?");
 2317: 
    1:     GlyphRun *glyphRun = mGlyphRuns.AppendElement();
    1:     if (!glyphRun)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     glyphRun->mFont = aFont;
    1:     glyphRun->mCharacterOffset = aUTF16Offset;
71910:     glyphRun->mMatchType = aMatchType;
    1:     return NS_OK;
    1: }
    1: 
 3609: void
 3609: gfxTextRun::SortGlyphRuns()
 3609: {
 5320:     if (mGlyphRuns.Length() <= 1)
 5320:         return;
 5320: 
 5320:     nsTArray<GlyphRun> runs(mGlyphRuns);
 3609:     GlyphRunOffsetComparator comp;
 5320:     runs.Sort(comp);
 5320: 
 5320:     // Now copy back, coalescing adjacent glyph runs that have the same font
 5320:     mGlyphRuns.Clear();
 5320:     PRUint32 i;
 5320:     for (i = 0; i < runs.Length(); ++i) {
 5320:         // a GlyphRun with the same font as the previous GlyphRun can just
 5320:         // be skipped; the last GlyphRun will cover its character range.
 5320:         if (i == 0 || runs[i].mFont != runs[i - 1].mFont) {
 5320:             mGlyphRuns.AppendElement(runs[i]);
21055:             // If two fonts have the same character offset, Sort() will have
21055:             // randomized the order.
21055:             NS_ASSERTION(i == 0 ||
21055:                          runs[i].mCharacterOffset !=
21055:                          runs[i - 1].mCharacterOffset,
21055:                          "Two fonts for the same run, glyph indices may not match the font");
 5320:         }
 5320:     }
 3609: }
 3609: 
77487: // Note that SanitizeGlyphRuns scans all glyph runs in the textrun;
77487: // therefore we only call it once, at the end of textrun construction,
77487: // NOT incrementally as each glyph run is added (bug 680402).
26688: void
26688: gfxTextRun::SanitizeGlyphRuns()
26688: {
26688:     if (mGlyphRuns.Length() <= 1)
26688:         return;
26688: 
26688:     // If any glyph run starts with ligature-continuation characters, we need to advance it
26688:     // to the first "real" character to avoid drawing partial ligature glyphs from wrong font
26688:     // (seen with U+FEFF in reftest 474417-1, as Core Text eliminates the glyph, which makes
26688:     // it appear as if a ligature has been formed)
36923:     PRInt32 i, lastRunIndex = mGlyphRuns.Length() - 1;
86699:     const CompressedGlyph *charGlyphs = mCharacterGlyphs;
36923:     for (i = lastRunIndex; i >= 0; --i) {
26688:         GlyphRun& run = mGlyphRuns[i];
86699:         while (charGlyphs[run.mCharacterOffset].IsLigatureContinuation() &&
26688:                run.mCharacterOffset < mCharacterCount) {
26688:             run.mCharacterOffset++;
26688:         }
26688:         // if the run has become empty, eliminate it
36923:         if ((i < lastRunIndex &&
36923:              run.mCharacterOffset >= mGlyphRuns[i+1].mCharacterOffset) ||
36923:             (i == lastRunIndex && run.mCharacterOffset == mCharacterCount)) {
26688:             mGlyphRuns.RemoveElementAt(i);
36923:             --lastRunIndex;
26688:         }
26688:     }
26688: }
26688: 
    1: PRUint32
    1: gfxTextRun::CountMissingGlyphs()
    1: {
    1:     PRUint32 i;
    1:     PRUint32 count = 0;
    1:     for (i = 0; i < mCharacterCount; ++i) {
    1:         if (mCharacterGlyphs[i].IsMissing()) {
    1:             ++count;
    1:         }
    1:     }
    1:     return count;
    1: }
    1: 
  132: gfxTextRun::DetailedGlyph *
  132: gfxTextRun::AllocateDetailedGlyphs(PRUint32 aIndex, PRUint32 aCount)
  132: {
10106:     NS_ASSERTION(aIndex < mCharacterCount, "Index out of range");
10106: 
  132:     if (!mDetailedGlyphs) {
62288:         mDetailedGlyphs = new DetailedGlyphStore();
62288:     }
62288: 
62288:     DetailedGlyph *details = mDetailedGlyphs->Allocate(aIndex, aCount);
  132:     if (!details) {
 7715:         mCharacterGlyphs[aIndex].SetMissing(0);
  132:         return nsnull;
  132:     }
62288: 
  132:     return details;
  132: }
  132: 
    1: void
 7715: gfxTextRun::SetGlyphs(PRUint32 aIndex, CompressedGlyph aGlyph,
 7715:                       const DetailedGlyph *aGlyphs)
    1: {
 7715:     NS_ASSERTION(!aGlyph.IsSimpleGlyph(), "Simple glyphs not handled here");
86691:     NS_ASSERTION(aIndex > 0 || aGlyph.IsLigatureGroupStart(),
86691:                  "First character can't be a ligature continuation!");
    1: 
 7715:     PRUint32 glyphCount = aGlyph.GetGlyphCount();
 7715:     if (glyphCount > 0) {
 7715:         DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, glyphCount);
  132:         if (!details)
    1:             return;
 7715:         memcpy(details, aGlyphs, sizeof(DetailedGlyph)*glyphCount);
 7715:     }
 7715:     mCharacterGlyphs[aIndex] = aGlyph;
  132: }
  132: 
  132: void
 6135: gfxTextRun::SetMissingGlyph(PRUint32 aIndex, PRUint32 aChar)
  132: {
90890:     PRUint8 category = GetGeneralCategory(aChar);
90072:     if (category >= HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK &&
90072:         category <= HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)
86697:     {
86697:         mCharacterGlyphs[aIndex].SetComplex(false, true, 0);
86697:     }
86697: 
  132:     DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, 1);
  132:     if (!details)
  132:         return;
  132: 
  132:     details->mGlyphID = aChar;
  132:     GlyphRun *glyphRun = &mGlyphRuns[FindFirstGlyphRunContaining(aIndex)];
41493:     if (IsDefaultIgnorable(aChar)) {
41493:         // Setting advance width to zero will prevent drawing the hexbox
41493:         details->mAdvance = 0;
41493:     } else {
72496:         gfxFloat width = NS_MAX(glyphRun->mFont->GetMetrics().aveCharWidth,
 6135:                                 gfxFontMissingGlyphs::GetDesiredMinWidth(aChar));
  132:         details->mAdvance = PRUint32(width*GetAppUnitsPerDevUnit());
41493:     }
  132:     details->mXOffset = 0;
  132:     details->mYOffset = 0;
 7715:     mCharacterGlyphs[aIndex].SetMissing(1);
    1: }
    1: 
 2317: void
86691: gfxTextRun::CopyGlyphDataFrom(const gfxShapedWord *aShapedWord, PRUint32 aOffset)
86691: {
86691:     PRUint32 wordLen = aShapedWord->Length();
86691:     NS_ASSERTION(aOffset + wordLen <= GetLength(),
86691:                  "word overruns end of textrun!");
86691: 
86691:     const CompressedGlyph *wordGlyphs = aShapedWord->GetCharacterGlyphs();
86691:     if (aShapedWord->HasDetailedGlyphs()) {
86691:         for (PRUint32 i = 0; i < wordLen; ++i, ++aOffset) {
86691:             const CompressedGlyph& g = wordGlyphs[i];
86691:             if (g.IsSimpleGlyph()) {
86691:                 SetSimpleGlyph(aOffset, g);
86691:             } else {
86691:                 const DetailedGlyph *details =
86691:                     g.GetGlyphCount() > 0 ?
86691:                         aShapedWord->GetDetailedGlyphs(i) : nsnull;
86691:                 SetGlyphs(aOffset, g, details);
86691:             }
86691:         }
86691:     } else {
86691:         memcpy(GetCharacterGlyphs() + aOffset, wordGlyphs,
86691:                wordLen * sizeof(CompressedGlyph));
86691:     }
86691: }
86691: 
86691: void
 2317: gfxTextRun::CopyGlyphDataFrom(gfxTextRun *aSource, PRUint32 aStart,
62288:                               PRUint32 aLength, PRUint32 aDest)
 2317: {
 2317:     NS_ASSERTION(aStart + aLength <= aSource->GetLength(),
 2317:                  "Source substring out of range");
 2317:     NS_ASSERTION(aDest + aLength <= GetLength(),
 2317:                  "Destination substring out of range");
 2317: 
62296:     if (aSource->mSkipDrawing) {
80486:         mSkipDrawing = true;
62296:     }
62296: 
62288:     // Copy base glyph data, and DetailedGlyph data where present
86699:     const CompressedGlyph *srcGlyphs = aSource->mCharacterGlyphs + aStart;
86699:     CompressedGlyph *dstGlyphs = mCharacterGlyphs + aDest;
62288:     for (PRUint32 i = 0; i < aLength; ++i) {
86699:         CompressedGlyph g = srcGlyphs[i];
86699:         g.SetCanBreakBefore(dstGlyphs[i].CanBreakBefore());
62288:         if (!g.IsSimpleGlyph()) {
62288:             PRUint32 count = g.GetGlyphCount();
62288:             if (count > 0) {
62288:                 DetailedGlyph *dst = AllocateDetailedGlyphs(i + aDest, count);
62288:                 if (dst) {
62288:                     DetailedGlyph *src = aSource->GetDetailedGlyphs(i + aStart);
62288:                     if (src) {
62288:                         ::memcpy(dst, src, count * sizeof(DetailedGlyph));
62288:                     } else {
62288:                         g.SetMissing(0);
62288:                     }
62288:                 } else {
62288:                     g.SetMissing(0);
62288:                 }
62288:             }
62288:         }
86699:         dstGlyphs[i] = g;
 2317:     }
 2317: 
 7715:     // Copy glyph runs
 2317:     GlyphRunIterator iter(aSource, aStart, aLength);
 5320: #ifdef DEBUG
 5320:     gfxFont *lastFont = nsnull;
 5320: #endif
 2317:     while (iter.NextRun()) {
 2317:         gfxFont *font = iter.GetGlyphRun()->mFont;
 5320:         NS_ASSERTION(font != lastFont, "Glyphruns not coalesced?");
 5320: #ifdef DEBUG
 5320:         lastFont = font;
19254:         PRUint32 end = iter.GetStringEnd();
 5320: #endif
 2317:         PRUint32 start = iter.GetStringStart();
37649: 
37649:         // These used to be NS_ASSERTION()s, but WARNING is more appropriate.
37649:         // Although it's unusual (and not desirable), it's possible for us to assign
26688:         // different fonts to a base character and a following diacritic.
37649:         // Example on OSX 10.5/10.6 with default fonts installed:
37649:         //     data:text/html,<p style="font-family:helvetica, arial, sans-serif;">
70950:         //                    &%23x043E;&%23x0486;&%23x20;&%23x043E;&%23x0486;
37649:         // This means the rendering of the cluster will probably not be very good,
37649:         // but it's the best we can do for now if the specified font only covered the
37649:         // initial base character and not its applied marks.
37649:         NS_WARN_IF_FALSE(aSource->IsClusterStart(start),
37649:                          "Started font run in the middle of a cluster");
37649:         NS_WARN_IF_FALSE(end == aSource->GetLength() || aSource->IsClusterStart(end),
37649:                          "Ended font run in the middle of a cluster");
 2317: 
71910:         nsresult rv = AddGlyphRun(font, iter.GetGlyphRun()->mMatchType,
80486:                                   start - aStart + aDest, false);
 2317:         if (NS_FAILED(rv))
 2317:             return;
 2317:     }
 2317: }
 2317: 
 2317: void
86697: gfxTextRun::SetSpaceGlyph(gfxFont *aFont, gfxContext *aContext,
86697:                           PRUint32 aCharIndex)
 2317: {
86697:     if (SetSpaceGlyphIfSimple(aFont, aContext, aCharIndex, ' ')) {
86697:         return;
86697:     }
86697: 
86697:     aFont->InitWordCache();
 2317:     static const PRUint8 space = ' ';
86697:     gfxShapedWord *sw = aFont->GetShapedWord(aContext,
86697:                                              &space, 1,
86697:                                              HashMix(0, ' '), 
90072:                                              MOZ_SCRIPT_LATIN,
86697:                                              mAppUnitsPerDevUnit,
86697:                                              gfxTextRunFactory::TEXT_IS_8BIT |
86697:                                              gfxTextRunFactory::TEXT_IS_ASCII |
 2317:                                              gfxTextRunFactory::TEXT_IS_PERSISTENT);
86697:     if (sw) {
80486:         AddGlyphRun(aFont, gfxTextRange::kFontGroup, aCharIndex, false);
86697:         CopyGlyphDataFrom(sw, aCharIndex);
86697:     }
 2317: }
 6247: 
86691: bool
86691: gfxTextRun::SetSpaceGlyphIfSimple(gfxFont *aFont, gfxContext *aContext,
86697:                                   PRUint32 aCharIndex, PRUnichar aSpaceChar)
86691: {
86691:     PRUint32 spaceGlyph = aFont->GetSpaceGlyph();
86691:     if (!spaceGlyph || !CompressedGlyph::IsSimpleGlyphID(spaceGlyph)) {
86691:         return false;
86691:     }
86691: 
86691:     PRUint32 spaceWidthAppUnits =
86691:         NS_lroundf(aFont->GetMetrics().spaceWidth * mAppUnitsPerDevUnit);
86691:     if (!CompressedGlyph::IsSimpleAdvance(spaceWidthAppUnits)) {
86691:         return false;
86691:     }
86691: 
86691:     AddGlyphRun(aFont, gfxTextRange::kFontGroup, aCharIndex, false);
86691:     CompressedGlyph g;
86691:     g.SetSimpleGlyph(spaceWidthAppUnits, spaceGlyph);
86697:     if (aSpaceChar == ' ') {
86697:         g.SetIsSpace();
86697:     }
86691:     SetSimpleGlyph(aCharIndex, g);
86691:     return true;
86691: }
86691: 
 6247: void
 6247: gfxTextRun::FetchGlyphExtents(gfxContext *aRefContext)
 6247: {
79445:     bool needsGlyphExtents = NeedsGlyphExtents(this);
29527:     if (!needsGlyphExtents && !mDetailedGlyphs)
 6247:         return;
 6247: 
 6247:     PRUint32 i;
 6247:     CompressedGlyph *charGlyphs = mCharacterGlyphs;
 6247:     for (i = 0; i < mGlyphRuns.Length(); ++i) {
 6247:         gfxFont *font = mGlyphRuns[i].mFont;
 6247:         PRUint32 start = mGlyphRuns[i].mCharacterOffset;
 6247:         PRUint32 end = i + 1 < mGlyphRuns.Length()
 6247:             ? mGlyphRuns[i + 1].mCharacterOffset : GetLength();
79445:         bool fontIsSetup = false;
 6247:         PRUint32 j;
 6247:         gfxGlyphExtents *extents = font->GetOrCreateGlyphExtents(mAppUnitsPerDevUnit);
 6247:   
 6247:         for (j = start; j < end; ++j) {
 6247:             const gfxTextRun::CompressedGlyph *glyphData = &charGlyphs[j];
 6247:             if (glyphData->IsSimpleGlyph()) {
 6247:                 // If we're in speed mode, don't set up glyph extents here; we'll
 6247:                 // just return "optimistic" glyph bounds later
29527:                 if (needsGlyphExtents) {
 6247:                     PRUint32 glyphIndex = glyphData->GetSimpleGlyph();
 6247:                     if (!extents->IsGlyphKnown(glyphIndex)) {
 6247:                         if (!fontIsSetup) {
 6247:                             font->SetupCairoFont(aRefContext);
80486:                              fontIsSetup = true;
 6247:                         }
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:                         ++gGlyphExtentsSetupEagerSimple;
 6513: #endif
80486:                         font->SetupGlyphExtents(aRefContext, glyphIndex, false, extents);
 6247:                     }
 6247:                 }
 9576:             } else if (!glyphData->IsMissing()) {
 7715:                 PRUint32 glyphCount = glyphData->GetGlyphCount();
62288:                 if (glyphCount == 0) {
62288:                     continue;
62288:                 }
 7685:                 const gfxTextRun::DetailedGlyph *details = GetDetailedGlyphs(j);
62288:                 if (!details) {
62288:                     continue;
62288:                 }
62288:                 for (PRUint32 k = 0; k < glyphCount; ++k, ++details) {
 6247:                     PRUint32 glyphIndex = details->mGlyphID;
 6247:                     if (!extents->IsGlyphKnownWithTightExtents(glyphIndex)) {
 6247:                         if (!fontIsSetup) {
 6247:                             font->SetupCairoFont(aRefContext);
80486:                             fontIsSetup = true;
 6247:                         }
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:                         ++gGlyphExtentsSetupEagerTight;
 6513: #endif
80486:                         font->SetupGlyphExtents(aRefContext, glyphIndex, true, extents);
 6247:                     }
 6247:                 }
 6247:             }
 6247:         }
 6247:     }
 6247: }
10484: 
63634: 
63634: gfxTextRun::ClusterIterator::ClusterIterator(gfxTextRun *aTextRun)
63634:     : mTextRun(aTextRun), mCurrentChar(PRUint32(-1))
63634: {
63634: }
63634: 
63634: void
63634: gfxTextRun::ClusterIterator::Reset()
63634: {
63634:     mCurrentChar = PRUint32(-1);
63634: }
63634: 
79445: bool
63634: gfxTextRun::ClusterIterator::NextCluster()
63634: {
63634:     while (++mCurrentChar < mTextRun->GetLength()) {
63634:         if (mTextRun->IsClusterStart(mCurrentChar)) {
80486:             return true;
63634:         }
63634:     }
63634: 
63634:     mCurrentChar = PRUint32(-1);
80486:     return false;
63634: }
63634: 
63634: PRUint32
63634: gfxTextRun::ClusterIterator::ClusterLength() const
63634: {
63634:     if (mCurrentChar == PRUint32(-1)) {
63634:         return 0;
63634:     }
63634: 
63634:     PRUint32 i = mCurrentChar;
63634:     while (++i < mTextRun->GetLength()) {
63634:         if (mTextRun->IsClusterStart(i)) {
63634:             break;
63634:         }
63634:     }
63634: 
63634:     return i - mCurrentChar;
63634: }
63634: 
63634: gfxFloat
63634: gfxTextRun::ClusterIterator::ClusterAdvance(PropertyProvider *aProvider) const
63634: {
63634:     if (mCurrentChar == PRUint32(-1)) {
63634:         return 0;
63634:     }
63634: 
63634:     return mTextRun->GetAdvanceWidth(mCurrentChar, ClusterLength(), aProvider);
63634: }
63634: 
82849: size_t
82849: gfxTextRun::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf)
80375: {
82849:     // The second arg is how much gfxTextRun::AllocateStorage would have
82849:     // allocated.
86699:     size_t total = mGlyphRuns.SizeOfExcludingThis(aMallocSizeOf);
80375: 
80375:     if (mDetailedGlyphs) {
84923:         total += mDetailedGlyphs->SizeOfIncludingThis(aMallocSizeOf);
84923:     }
84923: 
80375:     return total;
80375: }
80375: 
82849: size_t
82849: gfxTextRun::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf)
82849: {
88300:     return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
82849: }
82849: 
63634: 
10484: #ifdef DEBUG
10484: void
10484: gfxTextRun::Dump(FILE* aOutput) {
10484:     if (!aOutput) {
10484:         aOutput = stdout;
10484:     }
10484: 
10484:     PRUint32 i;
86697:     fputc('[', aOutput);
10484:     for (i = 0; i < mGlyphRuns.Length(); ++i) {
10484:         if (i > 0) {
10484:             fputc(',', aOutput);
10484:         }
10484:         gfxFont* font = mGlyphRuns[i].mFont;
10484:         const gfxFontStyle* style = font->GetStyle();
10484:         NS_ConvertUTF16toUTF8 fontName(font->GetName());
38493:         nsCAutoString lang;
38493:         style->language->ToUTF8String(lang);
10484:         fprintf(aOutput, "%d: %s %f/%d/%d/%s", mGlyphRuns[i].mCharacterOffset,
10484:                 fontName.get(), style->size,
38493:                 style->weight, style->style, lang.get());
10484:     }
10484:     fputc(']', aOutput);
10484: }
10484: #endif
