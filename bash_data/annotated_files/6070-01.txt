   1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Kyle Yuan (kyle.yuan@sun.com)
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsCOMPtr.h"
   1: #include "nsHTMLSelectAccessible.h"
   1: #include "nsIAccessibilityService.h"
   1: #include "nsIAccessibleEvent.h"
   1: #include "nsIFrame.h"
   1: #include "nsIComboboxControlFrame.h"
   1: #include "nsIDocument.h"
   1: #include "nsIDOMHTMLInputElement.h"
   1: #include "nsIDOMHTMLOptGroupElement.h"
   1: #include "nsIDOMHTMLSelectElement.h"
   1: #include "nsIListControlFrame.h"
   1: #include "nsIServiceManager.h"
   1: #include "nsIMutableArray.h"
   1: 
   1: /**
   1:   * Selects, Listboxes and Comboboxes, are made up of a number of different
   1:   *  widgets, some of which are shared between the two. This file contains 
   1:   *  all of the widgets for both of the Selects, for HTML only.
   1:   *
   1:   *  Listbox:
   1:   *     - nsHTMLSelectListAccessible
   1:   *       - nsHTMLSelectOptionAccessible
   1:   *
   1:   *  Comboboxes:
   1:   *     - nsHTMLComboboxAccessible
   1:   *        - nsHTMLComboboxTextFieldAccessible  (#ifdef COMBO_BOX_WITH_THREE_CHILDREN)
   1:   *        - nsHTMLComboboxButtonAccessible     (#ifdef COMBO_BOX_WITH_THREE_CHILDREN)
   1:   *        - nsHTMLComboboxListAccessible        [ inserted in accessible tree ]
   1:   *           - nsHTMLSelectOptionAccessible(s)
   1:   *
   1:   * XXX COMBO_BOX_WITH_THREE_CHILDREN is not currently defined.
   1:   *     If we start using it again, we should pass the correct frame into those accessibles.
   1:   *     They share a DOM node with the parent combobox.
   1:   */
   1: 
   1: 
   1: /** ------------------------------------------------------ */
   1: /**  Impl. of nsHTMLSelectableAccessible                   */
   1: /** ------------------------------------------------------ */
   1: 
   1: // Helper class
   1: nsHTMLSelectableAccessible::iterator::iterator(nsHTMLSelectableAccessible *aParent, nsIWeakReference *aWeakShell): 
   1:   mWeakShell(aWeakShell), mParentSelect(aParent)
   1: {
   1:   mLength = mIndex = 0;
   1:   mSelCount = 0;
   1: 
   1:   nsCOMPtr<nsIDOMHTMLSelectElement> htmlSelect(do_QueryInterface(mParentSelect->mDOMNode));
   1:   if (htmlSelect) {
   1:     htmlSelect->GetOptions(getter_AddRefs(mOptions));
   1:     if (mOptions)
   1:       mOptions->GetLength(&mLength);
   1:   }
   1: }
   1: 
   1: PRBool nsHTMLSelectableAccessible::iterator::Advance() 
   1: {
   1:   if (mIndex < mLength) {
   1:     nsCOMPtr<nsIDOMNode> tempNode;
   1:     if (mOptions) {
   1:       mOptions->Item(mIndex, getter_AddRefs(tempNode));
   1:       mOption = do_QueryInterface(tempNode);
   1:     }
   1:     mIndex++;
   1:     return PR_TRUE;
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: void nsHTMLSelectableAccessible::iterator::CalcSelectionCount(PRInt32 *aSelectionCount)
   1: {
   1:   PRBool isSelected = PR_FALSE;
   1: 
   1:   if (mOption)
   1:     mOption->GetSelected(&isSelected);
   1: 
   1:   if (isSelected)
   1:     (*aSelectionCount)++;
   1: }
   1: 
   1: void nsHTMLSelectableAccessible::iterator::AddAccessibleIfSelected(nsIAccessibilityService *aAccService, 
   1:                                                                    nsIMutableArray *aSelectedAccessibles, 
   1:                                                                    nsPresContext *aContext)
   1: {
   1:   PRBool isSelected = PR_FALSE;
   1:   nsCOMPtr<nsIAccessible> tempAccess;
   1: 
   1:   if (mOption) {
   1:     mOption->GetSelected(&isSelected);
   1:     if (isSelected) {
   1:       nsCOMPtr<nsIDOMNode> optionNode(do_QueryInterface(mOption));
   1:       aAccService->GetAccessibleInWeakShell(optionNode, mWeakShell, getter_AddRefs(tempAccess));
   1:     }
   1:   }
   1: 
   1:   if (tempAccess)
3233:     aSelectedAccessibles->AppendElement(static_cast<nsISupports*>(tempAccess), PR_FALSE);
   1: }
   1: 
   1: PRBool nsHTMLSelectableAccessible::iterator::GetAccessibleIfSelected(PRInt32 aIndex, 
   1:                                                                      nsIAccessibilityService *aAccService, 
   1:                                                                      nsPresContext *aContext, 
   1:                                                                      nsIAccessible **aAccessible)
   1: {
   1:   PRBool isSelected = PR_FALSE;
   1: 
   1:   *aAccessible = nsnull;
   1: 
   1:   if (mOption) {
   1:     mOption->GetSelected(&isSelected);
   1:     if (isSelected) {
   1:       if (mSelCount == aIndex) {
   1:         nsCOMPtr<nsIDOMNode> optionNode(do_QueryInterface(mOption));
   1:         aAccService->GetAccessibleInWeakShell(optionNode, mWeakShell, aAccessible);
   1:         return PR_TRUE;
   1:       }
   1:       mSelCount++;
   1:     }
   1:   }
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
   1: void nsHTMLSelectableAccessible::iterator::Select(PRBool aSelect)
   1: {
   1:   if (mOption)
   1:     mOption->SetSelected(aSelect);
   1: }
   1: 
   1: nsHTMLSelectableAccessible::nsHTMLSelectableAccessible(nsIDOMNode* aDOMNode, 
   1:                                                        nsIWeakReference* aShell):
   1: nsAccessibleWrap(aDOMNode, aShell)
   1: {
   1: }
   1: 
   1: NS_IMPL_ISUPPORTS_INHERITED1(nsHTMLSelectableAccessible, nsAccessible, nsIAccessibleSelectable)
   1: 
   1: // Helper methods
   1: NS_IMETHODIMP nsHTMLSelectableAccessible::ChangeSelection(PRInt32 aIndex, PRUint8 aMethod, PRBool *aSelState)
   1: {
   1:   *aSelState = PR_FALSE;
   1: 
   1:   nsCOMPtr<nsIDOMHTMLSelectElement> htmlSelect(do_QueryInterface(mDOMNode));
   1:   if (!htmlSelect)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsCOMPtr<nsIDOMHTMLOptionsCollection> options;
   1:   htmlSelect->GetOptions(getter_AddRefs(options));
   1:   if (!options)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsCOMPtr<nsIDOMNode> tempNode;
   1:   options->Item(aIndex, getter_AddRefs(tempNode));
   1:   nsCOMPtr<nsIDOMHTMLOptionElement> tempOption(do_QueryInterface(tempNode));
   1:   if (!tempOption)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   tempOption->GetSelected(aSelState);
   1:   nsresult rv = NS_OK;
   1:   if (eSelection_Add == aMethod && !(*aSelState))
   1:     rv = tempOption->SetSelected(PR_TRUE);
   1:   else if (eSelection_Remove == aMethod && (*aSelState))
   1:     rv = tempOption->SetSelected(PR_FALSE);
   1:   return rv;
   1: }
   1: 
   1: // Interface methods
   1: NS_IMETHODIMP nsHTMLSelectableAccessible::GetSelectedChildren(nsIArray **_retval)
   1: {
   1:   *_retval = nsnull;
   1: 
   1:   nsCOMPtr<nsIAccessibilityService> accService(do_GetService("@mozilla.org/accessibilityService;1"));
   1:   if (!accService)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsCOMPtr<nsIMutableArray> selectedAccessibles =
   1:     do_CreateInstance(NS_ARRAY_CONTRACTID);
   1:   NS_ENSURE_STATE(selectedAccessibles);
   1:   
   1:   nsPresContext *context = GetPresContext();
   1:   if (!context)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsHTMLSelectableAccessible::iterator iter(this, mWeakShell);
   1:   while (iter.Advance())
   1:     iter.AddAccessibleIfSelected(accService, selectedAccessibles, context);
   1: 
   1:   PRUint32 uLength = 0;
   1:   selectedAccessibles->GetLength(&uLength); 
   1:   if (uLength != 0) { // length of nsIArray containing selected options
   1:     *_retval = selectedAccessibles;
   1:     NS_ADDREF(*_retval);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: // return the nth selected child's nsIAccessible object
   1: NS_IMETHODIMP nsHTMLSelectableAccessible::RefSelection(PRInt32 aIndex, nsIAccessible **_retval)
   1: {
   1:   *_retval = nsnull;
   1: 
   1:   nsCOMPtr<nsIAccessibilityService> accService(do_GetService("@mozilla.org/accessibilityService;1"));
   1:   if (!accService)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsPresContext *context = GetPresContext();
   1:   if (!context)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsHTMLSelectableAccessible::iterator iter(this, mWeakShell);
   1:   while (iter.Advance())
   1:     if (iter.GetAccessibleIfSelected(aIndex, accService, context, _retval))
   1:       return NS_OK;
   1:   
   1:   // No matched item found
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectableAccessible::GetSelectionCount(PRInt32 *aSelectionCount)
   1: {
   1:   *aSelectionCount = 0;
   1: 
   1:   nsHTMLSelectableAccessible::iterator iter(this, mWeakShell);
   1:   while (iter.Advance())
   1:     iter.CalcSelectionCount(aSelectionCount);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectableAccessible::AddChildToSelection(PRInt32 aIndex)
   1: {
   1:   PRBool isSelected;
   1:   return ChangeSelection(aIndex, eSelection_Add, &isSelected);
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectableAccessible::RemoveChildFromSelection(PRInt32 aIndex)
   1: {
   1:   PRBool isSelected;
   1:   return ChangeSelection(aIndex, eSelection_Remove, &isSelected);
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectableAccessible::IsChildSelected(PRInt32 aIndex, PRBool *_retval)
   1: {
   1:   *_retval = PR_FALSE;
   1:   return ChangeSelection(aIndex, eSelection_GetState, _retval);
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectableAccessible::ClearSelection()
   1: {
   1:   nsHTMLSelectableAccessible::iterator iter(this, mWeakShell);
   1:   while (iter.Advance())
   1:     iter.Select(PR_FALSE);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectableAccessible::SelectAllSelection(PRBool *_retval)
   1: {
   1:   *_retval = PR_FALSE;
   1:   
   1:   nsCOMPtr<nsIDOMHTMLSelectElement> htmlSelect(do_QueryInterface(mDOMNode));
   1:   if (!htmlSelect)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   htmlSelect->GetMultiple(_retval);
   1:   if (*_retval) {
   1:     nsHTMLSelectableAccessible::iterator iter(this, mWeakShell);
   1:     while (iter.Advance())
   1:       iter.Select(PR_TRUE);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: /** ------------------------------------------------------ */
   1: /**  First, the common widgets                             */
   1: /** ------------------------------------------------------ */
   1: 
   1: /** ----- nsHTMLSelectListAccessible ----- */
   1: 
   1: /** Default Constructor */
   1: nsHTMLSelectListAccessible::nsHTMLSelectListAccessible(nsIDOMNode* aDOMNode, 
   1:                                                        nsIWeakReference* aShell)
   1: :nsHTMLSelectableAccessible(aDOMNode, aShell)
   1: {
   1: }
   1: 
   1: /**
   1:   * As a nsHTMLSelectListAccessible we can have the following states:
   1:   *     nsIAccessibleStates::STATE_MULTISELECTABLE
   1:   *     nsIAccessibleStates::STATE_EXTSELECTABLE
   1:   */
 262: NS_IMETHODIMP
 262: nsHTMLSelectListAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
 262:   nsresult rv = nsHTMLSelectableAccessible::GetState(aState, aExtraState);
 262:   NS_ENSURE_SUCCESS(rv, rv);
 262: 
   1:   nsCOMPtr<nsIDOMHTMLSelectElement> select (do_QueryInterface(mDOMNode));
   1:   if (select) {
   1:     PRBool multiple;
   1:     select->GetMultiple(&multiple);
   1:     if ( multiple )
 262:       *aState |= nsIAccessibleStates::STATE_MULTISELECTABLE |
   1:                  nsIAccessibleStates::STATE_EXTSELECTABLE;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectListAccessible::GetRole(PRUint32 *aRole)
   1: {
   1:   if (mParent && Role(mParent) == nsIAccessibleRole::ROLE_COMBOBOX) {
   1:     *aRole = nsIAccessibleRole::ROLE_COMBOBOX_LIST;
   1:   }
   1:   else {
   1:     *aRole = nsIAccessibleRole::ROLE_LIST;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: already_AddRefed<nsIAccessible>
   1: nsHTMLSelectListAccessible::AccessibleForOption(nsIAccessibilityService *aAccService,
   1:                                                 nsIContent *aContent,
   1:                                                 nsIAccessible *aLastGoodAccessible,
   1:                                                 PRInt32 *aChildCount)
   1: {
   1:   nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(aContent));
   1:   NS_ASSERTION(domNode, "DOM node is null");
   1:   // Accessibility service will initialize & cache any accessibles created
   1:   nsCOMPtr<nsIAccessible> accessible;
   1:   aAccService->GetAccessibleInWeakShell(domNode, mWeakShell, getter_AddRefs(accessible));
   1:   nsCOMPtr<nsPIAccessible> privateAccessible(do_QueryInterface(accessible));
   1:   if (!privateAccessible) {
   1:     return nsnull;
   1:   }
   1: 
   1:   ++ *aChildCount;
   1:   privateAccessible->SetParent(this);
   1:   nsCOMPtr<nsPIAccessible> privatePrevAccessible(do_QueryInterface(aLastGoodAccessible));
   1:   if (privatePrevAccessible) {
   1:     privatePrevAccessible->SetNextSibling(accessible);
   1:   }
   1:   if (!mFirstChild) {
   1:     mFirstChild = accessible;
   1:   }
   1:   nsIAccessible *returnAccessible = accessible;
   1:   NS_ADDREF(returnAccessible);
   1:   return returnAccessible;
   1: }
   1: 
   1: already_AddRefed<nsIAccessible>
   1: nsHTMLSelectListAccessible::CacheOptSiblings(nsIAccessibilityService *aAccService,
   1:                                              nsIContent *aParentContent,
   1:                                              nsIAccessible *aLastGoodAccessible,
   1:                                              PRInt32 *aChildCount)
   1: {
   1:   // Recursive helper for CacheChildren()
   1: 
   1:   PRUint32 numChildren = aParentContent->GetChildCount();
   1:   nsCOMPtr<nsIAccessible> lastGoodAccessible(aLastGoodAccessible);
6070:   nsCOMPtr<nsIAccessible> newAccessible;
   1: 
   1:   for (PRUint32 count = 0; count < numChildren; count ++) {
   1:     nsIContent *childContent = aParentContent->GetChildAt(count);
   1:     if (!childContent->IsNodeOfType(nsINode::eHTML)) {
   1:       continue;
   1:     }
   1:     nsCOMPtr<nsIAtom> tag = childContent->Tag();
   1:     if (tag == nsAccessibilityAtoms::option || tag == nsAccessibilityAtoms::optgroup) {
6070:       newAccessible = AccessibleForOption(aAccService,
   1:                                            childContent,
   1:                                            lastGoodAccessible,
   1:                                            aChildCount);
6070:       if (newAccessible) {
6070:         lastGoodAccessible = newAccessible;
6070:       }
   1:       if (tag == nsAccessibilityAtoms::optgroup) {
6070:         newAccessible = CacheOptSiblings(aAccService, childContent,
6070:                                          lastGoodAccessible, aChildCount);
6070:         if (newAccessible) {
6070:           lastGoodAccessible = newAccessible;
6070:         }
   1:       }
   1:     }
   1:   }
   1:   if (lastGoodAccessible) {
   1:     nsCOMPtr<nsPIAccessible> privateLastAcc =
   1:       do_QueryInterface(lastGoodAccessible);
   1:     privateLastAcc->SetNextSibling(nsnull);
   1:     NS_ADDREF(aLastGoodAccessible = lastGoodAccessible);
   1:   }
   1:   return aLastGoodAccessible;
   1: }
   1: 
   1: /**
   1:   * Cache the children and child count of a Select List Accessible. We want to count 
   1:   *  all the <optgroup>s and <option>s as children because we want a 
   1:   *  flat tree under the Select List.
   1:   */
   1: 
   1: void nsHTMLSelectListAccessible::CacheChildren()
   1: {
   1:   // Cache the number of <optgroup> and <option> DOM decendents,
   1:   // as well as the accessibles for them. Avoid whitespace text nodes.
   1: 
   1:   nsCOMPtr<nsIContent> selectContent(do_QueryInterface(mDOMNode));
   1:   nsCOMPtr<nsIAccessibilityService> accService(do_GetService("@mozilla.org/accessibilityService;1"));
   1:   if (!selectContent || !accService) {
   1:     mAccChildCount = eChildCountUninitialized;
   1:     return;
   1:   }
   1: 
   1:   PRInt32 childCount = 0;
   1:   nsCOMPtr<nsIAccessible> lastGoodAccessible =
   1:     CacheOptSiblings(accService, selectContent, nsnull, &childCount);
   1:   mAccChildCount = childCount;
   1: }
   1: 
   1: /** ----- nsHTMLSelectOptionAccessible ----- */
   1: 
   1: /** Default Constructor */
   1: nsHTMLSelectOptionAccessible::nsHTMLSelectOptionAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell):
 966: nsHyperTextAccessibleWrap(aDOMNode, aShell)
   1: {
   1:   nsCOMPtr<nsIAccessibilityService> accService(do_GetService("@mozilla.org/accessibilityService;1"));
   1:   nsCOMPtr<nsIDOMNode> parentNode;
   1:   aDOMNode->GetParentNode(getter_AddRefs(parentNode));
   1:   nsCOMPtr<nsIAccessible> parentAccessible;
   1:   if (parentNode) {
   1:     // If the parent node is a Combobox, then the option's accessible parent
   1:     // is nsHTMLComboboxListAccessible, not the nsHTMLComboboxAccessible that
   1:     // GetParent would normally return. This is because the 
   1:     // nsHTMLComboboxListAccessible is inserted into the accessible hierarchy
   1:     // where there is no DOM node for it.
   1:     accService->GetAccessibleInWeakShell(parentNode, mWeakShell, getter_AddRefs(parentAccessible));
   1:     if (parentAccessible) {
   1:       PRUint32 role;
   1:       parentAccessible->GetRole(&role);
   1:       if (role == nsIAccessibleRole::ROLE_COMBOBOX) {
   1:         nsCOMPtr<nsIAccessible> comboAccessible(parentAccessible);
   1:         comboAccessible->GetLastChild(getter_AddRefs(parentAccessible));
   1:       }
   1:     }
   1:   }
   1:   SetParent(parentAccessible);
   1: }
   1: 
   1: /** We are a ListItem */
   1: NS_IMETHODIMP nsHTMLSelectOptionAccessible::GetRole(PRUint32 *aRole)
   1: {
   1:   if (mParent && Role(mParent) == nsIAccessibleRole::ROLE_COMBOBOX_LIST) {
1209:     *aRole = nsIAccessibleRole::ROLE_COMBOBOX_LISTITEM;
   1:   }
   1:   else {
1209:     *aRole = nsIAccessibleRole::ROLE_LISTITEM;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * Get our Name from our Content's subtree
   1:   */
   1: NS_IMETHODIMP nsHTMLSelectOptionAccessible::GetName(nsAString& aName)
   1: {
   1:   // CASE #1 -- great majority of the cases
   1:   // find the label attribute - this is what the W3C says we should use
   1:   nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(mDOMNode));
1559:   if (!domElement)
1559:     return NS_ERROR_FAILURE;
1559: 
   1:   nsresult rv = domElement->GetAttribute(NS_LITERAL_STRING("label"), aName) ;
   1:   if (NS_SUCCEEDED(rv) && !aName.IsEmpty()) {
   1:     return NS_OK;
   1:   }
   1:   
   1:   // CASE #2 -- no label parameter, get the first child, 
   1:   // use it if it is a text node
   1:   nsCOMPtr<nsIDOMNode> child;
   1:   mDOMNode->GetFirstChild(getter_AddRefs(child));
   1: 
   1:   if (child) {
   1:     nsCOMPtr<nsIContent> text = do_QueryInterface(child);
   1:     if (text && text->IsNodeOfType(nsINode::eTEXT)) {
   1:       nsAutoString txtValue;
   1:       rv = AppendFlatStringFromContentNode(text, &txtValue);
1559:       NS_ENSURE_SUCCESS(rv, rv);
1559: 
   1:       // Temp var (txtValue) needed until CompressWhitespace built for nsAString
   1:       txtValue.CompressWhitespace();
   1:       aName.Assign(txtValue);
   1:       return NS_OK;
   1:     }
   1:   }
   1:   
1559:   aName.Truncate();
1559:   return NS_OK;
   1: }
   1: 
 401: nsresult
 401: nsHTMLSelectOptionAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
 144: {
 144:   NS_ENSURE_ARG_POINTER(aAttributes);
 789:   if (!mDOMNode) {
 789:     return NS_ERROR_FAILURE;  // Accessible shut down
 789:   }
 144: 
 966:   nsresult rv = nsHyperTextAccessibleWrap::GetAttributesInternal(aAttributes);
 144:   NS_ENSURE_SUCCESS(rv, rv);
 144: 
 789:   nsCOMPtr<nsIDOMNode> parentNode;
 789:   mDOMNode->GetParentNode(getter_AddRefs(parentNode));
 789:   nsCOMPtr<nsIDOMElement> parentElement(do_QueryInterface(parentNode));
 789:   NS_ENSURE_TRUE(parentElement, NS_ERROR_FAILURE);
 789:   nsAutoString parentTagName;
 789:   parentNode->GetLocalName(parentTagName);
 144: 
 789:   PRInt32 level = parentTagName.LowerCaseEqualsLiteral("optgroup") ? 2 : 1;
 789:   if (level == 1 && Role(this) != nsIAccessibleRole::ROLE_HEADING) {
 789:     level = 0; // In a single level list, the level is irrelevant
 789:   }
 144: 
 789:   nsAutoString tagName;
 789:   mDOMNode->GetLocalName(tagName);  // Will be looking for similar DOM siblings
 789:   nsCOMPtr<nsIDOMNodeList> siblings;
 789:   parentElement->GetElementsByTagName(tagName, getter_AddRefs(siblings));
 789:   PRInt32 posInSet = 0;
 789:   PRUint32 setSize = 0;
 789:   if (siblings) {
 789:     siblings->GetLength(&setSize);
 789:     nsCOMPtr<nsIDOMNode> itemNode;
 789:     while (NS_SUCCEEDED(siblings->Item(posInSet ++, getter_AddRefs(itemNode))) &&
 789:            itemNode != mDOMNode) {
 789:       // Keep looping, to increment posInSet
 789:     }
 789:   }
 144: 
3146:   nsAccUtils::SetAccGroupAttrs(aAttributes, level, posInSet,
3233:                                static_cast<PRInt32>(setSize));
 144:   return  NS_OK;
 144: }
 144: 
   1: nsIFrame* nsHTMLSelectOptionAccessible::GetBoundsFrame()
   1: {
 432:   PRUint32 state;
 432:   nsCOMPtr<nsIContent> content = GetSelectState(&state);
   1:   if (state & nsIAccessibleStates::STATE_COLLAPSED) {
   1:     nsCOMPtr<nsIPresShell> presShell(GetPresShell());
   1:     if (!presShell) {
   1:       return nsnull;
   1:     }
 432:     return presShell->GetPrimaryFrameFor(content);
   1:   }
   1: 
   1:   return nsAccessible::GetBoundsFrame();
   1: }
   1: 
   1: /**
   1:   * As a nsHTMLSelectOptionAccessible we can have the following states:
   1:   *     STATE_SELECTABLE
   1:   *     STATE_SELECTED
   1:   *     STATE_FOCUSED
   1:   *     STATE_FOCUSABLE
1209:   *     STATE_OFFSCREEN
   1:   */
 262: NS_IMETHODIMP
 262: nsHTMLSelectOptionAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
1516:   // Upcall to nsAccessible, but skip nsHyperTextAccessible impl
1516:   // because we don't want EXT_STATE_EDITABLE or EXT_STATE_SELECTABLE_TEXT
1516:   nsresult rv = nsAccessible::GetState(aState, aExtraState);
1516:   if (NS_FAILED(rv)) {
1516:     return rv;
   1:   }
   1: 
2346:   PRUint32 selectState, selectExtState;
2346:   nsCOMPtr<nsIContent> selectContent = GetSelectState(&selectState,
2346:                                                       &selectExtState);
2146:   if (selectState & nsIAccessibleStates::STATE_INVISIBLE) {
2146:     return NS_OK;
2146:   }
2146: 
1209:   nsCOMPtr<nsIDOMNode> selectNode = do_QueryInterface(selectContent); 
1209:   NS_ENSURE_TRUE(selectNode, NS_ERROR_FAILURE);
1209: 
2346:   // Is disabled?
2346:   if (0 == (*aState & nsIAccessibleStates::STATE_UNAVAILABLE)) {
2346:     *aState |= (nsIAccessibleStates::STATE_FOCUSABLE |
2346:                 nsIAccessibleStates::STATE_SELECTABLE);
2346:   }
   1: 
   1:   // Are we selected?
2346:   PRBool isSelected = PR_FALSE;
   1:   nsCOMPtr<nsIDOMHTMLOptionElement> option (do_QueryInterface(mDOMNode));
2346:   if (option) {
   1:     option->GetSelected(&isSelected);
   1:     if ( isSelected ) 
 262:       *aState |= nsIAccessibleStates::STATE_SELECTED;
   1:   }
   1: 
2146:   if (selectState & nsIAccessibleStates::STATE_OFFSCREEN) {
 432:     *aState |= nsIAccessibleStates::STATE_OFFSCREEN;
 432:   }
2146:   else if (selectState & nsIAccessibleStates::STATE_COLLAPSED) {
2146:     // <select> is COLLAPSED: add STATE_OFFSCREEN, if not the currently
2146:     // visible option
2346:     if (!isSelected) {
2146:       *aState |= nsIAccessibleStates::STATE_OFFSCREEN;
2146:     }
2146:     else {
2146:       // Clear offscreen and invisible for currently showing option
2146:       *aState &= ~nsIAccessibleStates::STATE_OFFSCREEN;
2146:       *aState &= ~nsIAccessibleStates::STATE_INVISIBLE;
2346:        if (aExtraState) {
2346:          *aExtraState |= selectExtState & nsIAccessibleStates::EXT_STATE_OPAQUE;
2346:        }
2146:     }
2146:   }
1209:   else {
1516:     // XXX list frames are weird, don't rely on nsAccessible's general
1516:     // visibility implementation unless they get reimplemented in layout
1516:     *aState &= ~nsIAccessibleStates::STATE_OFFSCREEN;
1209:     // <select> is not collapsed: compare bounds to calculate STATE_OFFSCREEN
1209:     nsCOMPtr<nsIAccessible> listAccessible = GetParent();
1209:     if (listAccessible) {
1209:       PRInt32 optionX, optionY, optionWidth, optionHeight;
1209:       PRInt32 listX, listY, listWidth, listHeight;
1209:       GetBounds(&optionX, &optionY, &optionWidth, &optionHeight);
1209:       listAccessible->GetBounds(&listX, &listY, &listWidth, &listHeight);
1209:       if (optionY < listY || optionY + optionHeight > listY + listHeight) {
1209:         *aState |= nsIAccessibleStates::STATE_OFFSCREEN;
1209:       }
1209:     }
1209:   }
 432:  
   1:   return NS_OK;
   1: }
   1: 
   1: /** select us! close combo box if necessary*/
   1: NS_IMETHODIMP nsHTMLSelectOptionAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
   1: {
   1:   if (aIndex == eAction_Select) {
   1:     aName.AssignLiteral("select"); 
   1:     return NS_OK;
   1:   }
   1:   return NS_ERROR_INVALID_ARG;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectOptionAccessible::GetNumActions(PRUint8 *_retval)
   1: {
   1:   *_retval = 1;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectOptionAccessible::DoAction(PRUint8 index)
   1: {
   1:   if (index == eAction_Select) {   // default action
   1:     nsCOMPtr<nsIDOMHTMLOptionElement> newHTMLOption(do_QueryInterface(mDOMNode));
   1:     if (!newHTMLOption) 
   1:       return NS_ERROR_FAILURE;
   1:     // Clear old selection
   1:     nsCOMPtr<nsIDOMNode> oldHTMLOptionNode, selectNode;
   1:     nsCOMPtr<nsIAccessible> parent(GetParent());
   1:     nsCOMPtr<nsIAccessNode> accessNode(do_QueryInterface(parent));
   1:     NS_ASSERTION(accessNode, "Unable to QI to nsIAccessNode");
   1:     accessNode->GetDOMNode(getter_AddRefs(selectNode));
   1:     GetFocusedOptionNode(selectNode, getter_AddRefs(oldHTMLOptionNode));
   1:     nsCOMPtr<nsIDOMHTMLOptionElement> oldHTMLOption(do_QueryInterface(oldHTMLOptionNode));
   1:     if (oldHTMLOption)
   1:       oldHTMLOption->SetSelected(PR_FALSE);
   1:     // Set new selection
   1:     newHTMLOption->SetSelected(PR_TRUE);
   1: 
   1:     // If combo box, and open, close it
   1:     // First, get the <select> widgets list control frame
   1:     nsCOMPtr<nsIDOMNode> testSelectNode;
   1:     nsCOMPtr<nsIDOMNode> thisNode(do_QueryInterface(mDOMNode));
   1:     do {
   1:       thisNode->GetParentNode(getter_AddRefs(testSelectNode));
   1:       nsCOMPtr<nsIDOMHTMLSelectElement> selectControl(do_QueryInterface(testSelectNode));
   1:       if (selectControl)
   1:         break;
   1:       thisNode = testSelectNode;
   1:     } while (testSelectNode);
   1: 
   1:     nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
   1:     nsCOMPtr<nsIContent> selectContent(do_QueryInterface(testSelectNode));
   1:     nsCOMPtr<nsIDOMHTMLOptionElement> option(do_QueryInterface(mDOMNode));
   1: 
   1:     if (!testSelectNode || !selectContent || !presShell || !option) 
   1:       return NS_ERROR_FAILURE;
   1: 
   1:     nsIFrame *selectFrame = presShell->GetPrimaryFrameFor(selectContent);
   1:     nsIComboboxControlFrame *comboBoxFrame = nsnull;
   1:     CallQueryInterface(selectFrame, &comboBoxFrame);
   1:     if (comboBoxFrame) {
   1:       nsIFrame *listFrame = comboBoxFrame->GetDropDown();
   1:       if (comboBoxFrame->IsDroppedDown() && listFrame) {
   1:         // use this list control frame to roll up the list
   1:         nsIListControlFrame *listControlFrame = nsnull;
   1:         listFrame->QueryInterface(NS_GET_IID(nsIListControlFrame), (void**)&listControlFrame);
   1:         if (listControlFrame) {
   1:           PRInt32 newIndex = 0;
   1:           option->GetIndex(&newIndex);
   1:           listControlFrame->ComboboxFinish(newIndex);
   1:         }
   1:       }
   1:     }
   1:     return NS_OK;
   1:   }
   1: 
   1:   return NS_ERROR_INVALID_ARG;
   1: }
   1: 
   1: /**
   1:   * Helper method for getting the focused DOM Node from our parent(list) node. We
   1:   *  need to use the frame to get the focused option because for some reason we
   1:   *  weren't getting the proper notification when the focus changed using the DOM
   1:   */
   1: nsresult nsHTMLSelectOptionAccessible::GetFocusedOptionNode(nsIDOMNode *aListNode, 
   1:                                                             nsIDOMNode **aFocusedOptionNode)
   1: {
   1:   *aFocusedOptionNode = nsnull;
   1:   NS_ASSERTION(aListNode, "Called GetFocusedOptionNode without a valid list node");
   1: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aListNode));
   1:   nsCOMPtr<nsIDocument> document = content->GetDocument();
   1:   nsIPresShell *shell = nsnull;
   1:   if (document)
 981:     shell = document->GetPrimaryShell();
   1:   if (!shell)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsIFrame *frame = shell->GetPrimaryFrameFor(content);
   1:   if (!frame)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   PRInt32 focusedOptionIndex = 0;
   1: 
   1:   // Get options
   1:   nsCOMPtr<nsIDOMHTMLSelectElement> selectElement(do_QueryInterface(aListNode));
   1:   NS_ASSERTION(selectElement, "No select element where it should be");
   1: 
   1:   nsCOMPtr<nsIDOMHTMLOptionsCollection> options;
   1:   nsresult rv = selectElement->GetOptions(getter_AddRefs(options));
   1:   
   1:   if (NS_SUCCEEDED(rv)) {
   1:     nsIListControlFrame *listFrame = nsnull;
   1:     frame->QueryInterface(NS_GET_IID(nsIListControlFrame), (void**)&listFrame);
   1:     if (listFrame) {
   1:       // Get what's focused in listbox by asking frame for "selected item". 
   1:       // Can't use dom interface for this, because it will always return the first selected item
   1:       // when there is more than 1 item selected. We need the focused item, not
   1:       // the first selected item.
   1:       focusedOptionIndex = listFrame->GetSelectedIndex();
   1:     }
   1:     else  // Combo boxes can only have 1 selected option, so they can use the dom interface for this
   1:       rv = selectElement->GetSelectedIndex(&focusedOptionIndex);
   1:   }
   1: 
   1:   // Either use options and focused index, or default return null
   1:   if (NS_SUCCEEDED(rv) && options && focusedOptionIndex >= 0) {  // Something is focused
   1:     rv = options->Item(focusedOptionIndex, aFocusedOptionNode);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: void nsHTMLSelectOptionAccessible::SelectionChangedIfOption(nsIContent *aPossibleOption)
   1: {
   1:   if (!aPossibleOption || aPossibleOption->Tag() != nsAccessibilityAtoms::option ||
   1:       !aPossibleOption->IsNodeOfType(nsINode::eHTML)) {
   1:     return;
   1:   }
   1: 
   1:   nsCOMPtr<nsIDOMNode> optionNode(do_QueryInterface(aPossibleOption));
   1:   NS_ASSERTION(optionNode, "No option node for nsIContent with option tag!");
   1: 
   1:   nsCOMPtr<nsIAccessible> multiSelect = GetMultiSelectFor(optionNode);
   1:   nsCOMPtr<nsPIAccessible> privateMultiSelect = do_QueryInterface(multiSelect);
   1:   if (!privateMultiSelect) {
   1:     return;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessibilityService> accService = 
   1:     do_GetService("@mozilla.org/accessibilityService;1");
   1:   nsCOMPtr<nsIAccessible> optionAccessible;
   1:   accService->GetAccessibleFor(optionNode, getter_AddRefs(optionAccessible));
   1:   if (!optionAccessible) {
   1:     return;
   1:   }
   1: 
3152:   nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_SELECTION_WITHIN,
3152:                            multiSelect);
3152: 
 262:   PRUint32 state = State(optionAccessible);
2089:   PRUint32 eventType;
2089:   if (state & nsIAccessibleStates::STATE_SELECTED) {
2089:     eventType = nsIAccessibleEvent::EVENT_SELECTION_ADD;
2089:   }
2089:   else {
2089:     eventType = nsIAccessibleEvent::EVENT_SELECTION_REMOVE;
2089:   }
3152: 
3152:   nsAccUtils::FireAccEvent(eventType, optionAccessible);
   1: }
   1: 
2346: nsIContent* nsHTMLSelectOptionAccessible::GetSelectState(PRUint32* aState,
2346:                                                          PRUint32* aExtraState)
 432: {
 432:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
 432:   while (content && content->Tag() != nsAccessibilityAtoms::select) {
 432:     content = content->GetParent();
 432:   }
 432: 
 432:   nsCOMPtr<nsIDOMNode> selectNode(do_QueryInterface(content));
 432:   if (selectNode) {
 432:     nsCOMPtr<nsIAccessibilityService> accService = GetAccService();
 432:     if (accService) {
 432:       nsCOMPtr<nsIAccessible> selAcc;
 432:       accService->GetAccessibleFor(selectNode, getter_AddRefs(selAcc));
 432:       if (selAcc) {
2346:         selAcc->GetFinalState(aState, aExtraState);
 432:         return content;
 432:       }
 432:     }
 432:   }
 432:   return nsnull; 
 432: }
 432: 
   1: /** ----- nsHTMLSelectOptGroupAccessible ----- */
   1: 
   1: /** Default Constructor */
   1: nsHTMLSelectOptGroupAccessible::nsHTMLSelectOptGroupAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell):
   1: nsHTMLSelectOptionAccessible(aDOMNode, aShell)
   1: {
   1: }
   1: 
 789: NS_IMETHODIMP
 789: nsHTMLSelectOptGroupAccessible::GetRole(PRUint32 *aRole)
 789: {
 789:   *aRole = nsIAccessibleRole::ROLE_HEADING;
 789:   return NS_OK;
 789: }
   1: 
 262: NS_IMETHODIMP
 262: nsHTMLSelectOptGroupAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
 262:   nsresult rv = nsHTMLSelectOptionAccessible::GetState(aState, aExtraState);
 262:   NS_ENSURE_SUCCESS(rv, rv);
 262: 
 262:   *aState &= ~(nsIAccessibleStates::STATE_FOCUSABLE |
   1:                nsIAccessibleStates::STATE_SELECTABLE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectOptGroupAccessible::DoAction(PRUint8 index)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectOptGroupAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLSelectOptGroupAccessible::GetNumActions(PRUint8 *_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
 789: void nsHTMLSelectOptGroupAccessible::CacheChildren()
 789: {
 789:   if (!mWeakShell) {
 789:     // This node has been shut down
 789:     mAccChildCount = eChildCountUninitialized;
 789:     return;
 789:   }
 789: 
 789:   if (mAccChildCount == eChildCountUninitialized) {
 789:     // XXX To do (bug 378612) - create text child for the anonymous attribute content, so that
 789:     // nsIAccessibleText is supported for the <optgroup> as it is for an <option>
 789:     // Attribute content is what layout creates for the label="foo" on the <optgroup>
 789:     // See eStyleContentType_Attr and CreateAttributeContent() in nsCSSFrameConstructor
 789:     mAccChildCount = 0;
 789:     SetFirstChild(nsnull);
 789:   }
 789: }
 789: 
   1: /** ------------------------------------------------------ */
   1: /**  Finally, the Combobox widgets                         */
   1: /** ------------------------------------------------------ */
   1: 
   1: /** ----- nsHTMLComboboxAccessible ----- */
   1: 
   1: nsHTMLComboboxAccessible::nsHTMLComboboxAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aShell):
   1: nsAccessibleWrap(aDOMNode, aShell)
   1: {
   1: }
   1: 
   1: /** We are a combobox */
   1: NS_IMETHODIMP nsHTMLComboboxAccessible::GetRole(PRUint32 *_retval)
   1: {
   1:   *_retval = nsIAccessibleRole::ROLE_COMBOBOX;
   1:   return NS_OK;
   1: }
   1: 
   1: void nsHTMLComboboxAccessible::CacheChildren()
   1: {
   1:   if (!mWeakShell) {
   1:     // This node has been shut down
   1:     mAccChildCount = eChildCountUninitialized;
   1:     return;
   1:   }
   1: 
   1:   if (mAccChildCount == eChildCountUninitialized) {
   1:     mAccChildCount = 0;
   1: #ifdef COMBO_BOX_WITH_THREE_CHILDREN
   1:     // We no longer create textfield and button accessible, in order to have
   1:     // harmonization between IAccessible2, ATK/AT-SPI and OS X
   1:     nsHTMLComboboxTextFieldAccessible* textFieldAccessible = 
   1:       new nsHTMLComboboxTextFieldAccessible(this, mDOMNode, mWeakShell);
   1:     SetFirstChild(textFieldAccessible);
   1:     if (!textFieldAccessible) {
   1:       return;
   1:     }
   1:     textFieldAccessible->SetParent(this);
   1:     textFieldAccessible->Init();
   1:     mAccChildCount = 1;  // Textfield accessible child successfully added
   1: 
   1:     nsHTMLComboboxButtonAccessible* buttonAccessible =
   1:       new nsHTMLComboboxButtonAccessible(mParent, mDOMNode, mWeakShell);
   1:     textFieldAccessible->SetNextSibling(buttonAccessible);
   1:     if (!buttonAccessible) {
   1:       return;
   1:     }
   1: 
   1:     buttonAccessible->SetParent(this);
   1:     buttonAccessible->Init();
   1:     mAccChildCount = 2; // Button accessible child successfully added
   1: #endif
   1: 
   1:     nsIFrame *frame = GetFrame();
   1:     if (!frame) {
   1:       return;
   1:     }
   1:     nsIComboboxControlFrame *comboFrame = nsnull;
   1:     frame->QueryInterface(NS_GET_IID(nsIComboboxControlFrame), (void**)&comboFrame);
   1:     if (!comboFrame) {
   1:       return;
   1:     }
   1:     nsIFrame *listFrame = comboFrame->GetDropDown();
   1:     if (!listFrame) {
   1:       return;
   1:     }
   1: 
 621:     if (!mListAccessible) {
 621:       mListAccessible = 
 566:         new nsHTMLComboboxListAccessible(mParent, mDOMNode, mWeakShell);
 621:     }
   1: #ifdef COMBO_BOX_WITH_THREE_CHILDREN
 621:     buttonAccessible->SetNextSibling(mListAccessible);
   1: #else
 621:     SetFirstChild(mListAccessible);
   1: #endif
 621:     if (!mListAccessible) {
   1:       return;
   1:     }
   1: 
 621:     mListAccessible->SetParent(this);
 621:     mListAccessible->SetNextSibling(nsnull);
 621:     mListAccessible->Init();
   1: 
   1:     ++ mAccChildCount;  // List accessible child successfully added
   1:   }
   1: }
   1: 
 621: NS_IMETHODIMP nsHTMLComboboxAccessible::Shutdown()
 621: {
 621:   nsAccessibleWrap::Shutdown();
 621: 
 621:   if (mListAccessible) {
 621:     mListAccessible->Shutdown();
 621:     mListAccessible = nsnull;
 621:   }
 621:   return NS_OK;
 621: }
 621: 
   1: /**
   1:   * As a nsHTMLComboboxAccessible we can have the following states:
   1:   *     STATE_FOCUSED
   1:   *     STATE_READONLY
   1:   *     STATE_FOCUSABLE
   1:   *     STATE_HASPOPUP
   1:   *     STATE_EXPANDED
   1:   *     STATE_COLLAPSED
   1:   */
 262: NS_IMETHODIMP
 262: nsHTMLComboboxAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
   1:   // Get focus status from base class
 262:   nsresult rv = nsAccessible::GetState(aState, aExtraState);
 262:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsIFrame *frame = GetBoundsFrame();
   1:   nsIComboboxControlFrame *comboFrame = nsnull;
4855:   if (frame) {
   1:     frame->QueryInterface(NS_GET_IID(nsIComboboxControlFrame), (void**)&comboFrame);
4855:   }
   1: 
1209:   if (comboFrame && comboFrame->IsDroppedDown()) {
 262:     *aState |= nsIAccessibleStates::STATE_EXPANDED;
1209:   }
1209:   else {
1209:     *aState &= ~nsIAccessibleStates::STATE_FOCUSED; // Focus is on an option
 262:     *aState |= nsIAccessibleStates::STATE_COLLAPSED;
1209:   }
   1: 
 262:   *aState |= nsIAccessibleStates::STATE_HASPOPUP |
   1:              nsIAccessibleStates::STATE_READONLY |
   1:              nsIAccessibleStates::STATE_FOCUSABLE;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLComboboxAccessible::GetDescription(nsAString& aDescription)
   1: {
   1:   aDescription.Truncate();
   1:   // First check to see if combo box itself has a description, perhaps through
   1:   // tooltip (title attribute) or via aaa:describedby
   1:   nsAccessible::GetDescription(aDescription);
   1:   if (!aDescription.IsEmpty()) {
   1:     return NS_OK;
   1:   }
   1:   // Use description of currently focused option
   1:   nsCOMPtr<nsIAccessible> optionAccessible = GetFocusedOptionAccessible();
   1:   return optionAccessible ? optionAccessible->GetDescription(aDescription) : NS_OK;
   1: }
   1: 
   1: already_AddRefed<nsIAccessible>
   1: nsHTMLComboboxAccessible::GetFocusedOptionAccessible()
   1: {
   1:   if (!mWeakShell) {
   1:     return nsnull;  // Shut down
   1:   }
   1:   nsCOMPtr<nsIDOMNode> focusedOptionNode;
   1:   nsHTMLSelectOptionAccessible::GetFocusedOptionNode(mDOMNode, getter_AddRefs(focusedOptionNode));
   1:   nsIAccessibilityService *accService = GetAccService();
   1:   if (!focusedOptionNode || !accService) {
   1:     return nsnull;
   1:   }
   1: 
   1:   nsIAccessible *optionAccessible;
   1:   accService->GetAccessibleInWeakShell(focusedOptionNode, mWeakShell, 
   1:                                        &optionAccessible);
   1:   return optionAccessible;
   1: }
   1: 
   1: /**
   1:   * MSAA/ATK accessible value != HTML value, especially not in combo boxes.
   1:   * Our accessible value is the text label for of our ( first ) selected child.
   1:   * The easiest way to get this is from the first child which is the readonly textfield.
   1:   */
   1: NS_IMETHODIMP nsHTMLComboboxAccessible::GetValue(nsAString& aValue)
   1: {
   1:   // Use label of currently focused option
   1:   nsCOMPtr<nsIAccessible> optionAccessible = GetFocusedOptionAccessible();
   1:   NS_ENSURE_TRUE(optionAccessible, NS_ERROR_FAILURE);
   1:   return optionAccessible->GetName(aValue);
   1: }
   1: 
   1: /** Just one action ( click ). */
   1: NS_IMETHODIMP nsHTMLComboboxAccessible::GetNumActions(PRUint8 *aNumActions)
   1: {
   1:   *aNumActions = 1;
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * Programmaticaly toggle the combo box
   1:   */
   1: NS_IMETHODIMP nsHTMLComboboxAccessible::DoAction(PRUint8 aIndex)
   1: {
   1:   if (aIndex != nsHTMLComboboxAccessible::eAction_Click) {
   1:     return NS_ERROR_INVALID_ARG;
   1:   }
   1:   nsIFrame *frame = GetFrame();
   1:   if (!frame) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   nsIComboboxControlFrame *comboFrame = nsnull;
   1:   frame->QueryInterface(NS_GET_IID(nsIComboboxControlFrame), (void**)&comboFrame);
   1:   if (!comboFrame) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   // Reverse whether it's dropped down or not
   1:   comboFrame->ShowDropDown(!comboFrame->IsDroppedDown());
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * Our action name is the reverse of our state: 
   1:   *     if we are closed -> open is our name.
   1:   *     if we are open -> closed is our name.
   1:   * Uses the frame to get the state, updated on every click
   1:   */
   1: NS_IMETHODIMP nsHTMLComboboxAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
   1: {
   1:   if (aIndex != nsHTMLComboboxAccessible::eAction_Click) {
   1:     return NS_ERROR_INVALID_ARG;
   1:   }
   1:   nsIFrame *frame = GetFrame();
   1:   if (!frame) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   nsIComboboxControlFrame *comboFrame = nsnull;
   1:   frame->QueryInterface(NS_GET_IID(nsIComboboxControlFrame), (void**)&comboFrame);
   1:   if (!comboFrame) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   if (comboFrame->IsDroppedDown())
   1:     aName.AssignLiteral("close"); 
   1:   else
   1:     aName.AssignLiteral("open"); 
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: #ifdef COMBO_BOX_WITH_THREE_CHILDREN
   1: /** ----- nsHTMLComboboxTextFieldAccessible ----- */
   1: 
   1: /** Constructor */
   1: nsHTMLComboboxTextFieldAccessible::nsHTMLComboboxTextFieldAccessible(nsIAccessible* aParent, 
   1:                                                                      nsIDOMNode* aDOMNode, 
   1:                                                                      nsIWeakReference* aShell):
   1: nsHTMLTextFieldAccessible(aDOMNode, aShell)
   1: {
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLComboboxTextFieldAccessible::GetUniqueID(void **aUniqueID)
   1: {
   1:   // Since mDOMNode is same as for our parent, use |this| pointer as the unique Id
3233:   *aUniqueID = static_cast<void*>(this);
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * Gets the bounds for the BlockFrame.
   1:   *     Walks the Frame tree and checks for proper frames.
   1:   */
   1: void nsHTMLComboboxTextFieldAccessible::GetBoundsRect(nsRect& aBounds, nsIFrame** aBoundingFrame)
   1: {
   1:   // get our first child's frame
   1:   nsIFrame* frame = nsAccessible::GetBoundsFrame();
   1:   if (!frame)
   1:     return;
   1: 
   1:   frame = frame->GetFirstChild(nsnull);
   1:   *aBoundingFrame = frame;
   1: 
   1:   aBounds = frame->GetRect();
   1: }
   1: 
   1: void nsHTMLComboboxTextFieldAccessible::CacheChildren()
   1: {
   1:   // Allow single text anonymous child, so that nsHyperTextAccessible can operate correctly
   1:   // We must override this otherwise we get the dropdown button as a child of the textfield,
   1:   // and at least for now we want to keep it as a sibling
   1:   if (!mWeakShell) {
   1:     // This node has been shut down
   1:     mAccChildCount = eChildCountUninitialized;
   1:     return;
   1:   }
   1: 
   1:   // Allows only 1 child
   1:   if (mAccChildCount == eChildCountUninitialized) {
   1:     nsAccessibleTreeWalker walker(mWeakShell, mDOMNode, PR_TRUE);
   1:     // Seed the frame hint early while we're still on a container node.
   1:     // This is better than doing the GetPrimaryFrameFor() later on
   1:     // a text node, because text nodes aren't in the frame map.
   1:     walker.mState.frame = GetFrame();
   1: 
   1:     walker.GetFirstChild();
   1:     SetFirstChild(walker.mState.accessible);
   1:     nsCOMPtr<nsPIAccessible> privateChild = 
   1:       do_QueryInterface(walker.mState.accessible);
   1:     privateChild->SetParent(this);
   1:     privateChild->SetNextSibling(nsnull);
   1:     mAccChildCount = 1;
   1:   }
   1: }
   1: 
   1: /** -----ComboboxButtonAccessible ----- */
   1: 
   1: /** Constructor -- cache our parent */
   1: nsHTMLComboboxButtonAccessible::nsHTMLComboboxButtonAccessible(nsIAccessible* aParent, 
   1:                                                            nsIDOMNode* aDOMNode, 
   1:                                                            nsIWeakReference* aShell):
   1: nsLeafAccessible(aDOMNode, aShell)
   1: {
   1: }
   1: 
   1: /** Just one action ( click ). */
   1: NS_IMETHODIMP nsHTMLComboboxButtonAccessible::GetNumActions(PRUint8 *aNumActions)
   1: {
   1:   *aNumActions = 1;
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * Programmaticaly click on the button, causing either the display or
   1:   *     the hiding of the drop down box ( window ).
   1:   *     Walks the Frame tree and checks for proper frames.
   1:   */
   1: NS_IMETHODIMP nsHTMLComboboxButtonAccessible::DoAction(PRUint8 aIndex)
   1: {
   1:   nsIFrame* frame = nsAccessible::GetBoundsFrame();
   1:   nsPresContext *context = GetPresContext();
   1:   if (!frame || !context)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   frame = frame->GetFirstChild(nsnull)->GetNextSibling();
   1: 
   1:   // We only have one action, click. Any other index is meaningless(wrong)
   1:   if (aIndex == eAction_Click) {
   1:     nsCOMPtr<nsIDOMHTMLInputElement>
   1:       element(do_QueryInterface(frame->GetContent()));
   1:     if (element)
   1:     {
   1:        element->Click();
   1:        return NS_OK;
   1:     }
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   return NS_ERROR_INVALID_ARG;
   1: }
   1: 
   1: /**
   1:   * Our action name is the reverse of our state: 
   1:   *     if we are closed -> open is our name.
   1:   *     if we are open -> closed is our name.
   1:   * Uses the frame to get the state, updated on every click
   1:   */
   1: NS_IMETHODIMP nsHTMLComboboxButtonAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
   1: {
   1:   nsIFrame *boundsFrame = GetBoundsFrame();
   1:   nsIComboboxControlFrame* comboFrame;
   1:   boundsFrame->QueryInterface(NS_GET_IID(nsIComboboxControlFrame), (void**)&comboFrame);
   1:   if (!comboFrame)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   if (comboFrame->IsDroppedDown())
   1:     aName.AssignLiteral("close"); 
   1:   else
   1:     aName.AssignLiteral("open");
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLComboboxButtonAccessible::GetUniqueID(void **aUniqueID)
   1: {
   1:   // Since mDOMNode is same for all tree item, use |this| pointer as the unique Id
3233:   *aUniqueID = static_cast<void*>(this);
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * Gets the bounds for the gfxButtonControlFrame.
   1:   *     Walks the Frame tree and checks for proper frames.
   1:   */
   1: void nsHTMLComboboxButtonAccessible::GetBoundsRect(nsRect& aBounds, nsIFrame** aBoundingFrame)
   1: {
   1:   // get our second child's frame
   1:   // bounding frame is the ComboboxControlFrame
   1:   nsIFrame *frame = nsAccessible::GetBoundsFrame();
   1:   *aBoundingFrame = frame;
   1:   nsPresContext *context = GetPresContext();
   1:   if (!frame || !context)
   1:     return;
   1: 
   1:   aBounds = frame->GetFirstChild(nsnull)->GetNextSibling()->GetRect();
   1:     // sibling frame is for the button
   1: }
   1: 
   1: /** We are a button. */
   1: NS_IMETHODIMP nsHTMLComboboxButtonAccessible::GetRole(PRUint32 *_retval)
   1: {
   1:   *_retval = nsIAccessibleRole::ROLE_PUSHBUTTON;
   1:   return NS_OK;
   1: }
   1: 
   1: /** Return our cached parent */
   1: NS_IMETHODIMP nsHTMLComboboxButtonAccessible::GetParent(nsIAccessible **aParent)
   1: {   
   1:   NS_IF_ADDREF(*aParent = mParent);
   1:   return NS_OK;
   1: }
   1: 
   1: /** 
   1:   * Gets the name from GetActionName()
   1:   */
   1: NS_IMETHODIMP nsHTMLComboboxButtonAccessible::GetName(nsAString& aName)
   1: {
   1:   return GetActionName(eAction_Click, aName);
   1: }
   1: 
   1: /**
   1:   * As a nsHTMLComboboxButtonAccessible we can have the following states:
   1:   *     STATE_PRESSED
   1:   *     STATE_FOCUSED
   1:   *     STATE_FOCUSABLE
4855:   *     STATE_INVISIBLE
   1:   */
 262: NS_IMETHODIMP
 262: nsHTMLComboboxButtonAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
   1:   // Get focus status from base class
 262:   nsresult rv = nsAccessible::GetState(aState, aExtraState);
 262:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsIFrame *boundsFrame = GetBoundsFrame();
4855:   nsIComboboxControlFrame* comboFrame = nsnull;
4855:   if (boundsFrame)
   1:     boundsFrame->QueryInterface(NS_GET_IID(nsIComboboxControlFrame), (void**)&comboFrame);
   1: 
4855:   if (!comboFrame) {
4855:     *aState |= nsIAccessibleStates::STATE_INVISIBLE;
4855:   }
4855:   else {
4855:     *aState |= nsIAccessibleStates::STATE_FOCUSABLE;
4855:     if (comboFrame->IsDroppedDown()) {
 262:       *aState |= nsIAccessibleStates::STATE_PRESSED;
4855:     }
4855:   }
   1:  
   1:   return NS_OK;
   1: }
   1: #endif
   1: 
   1: /** ----- nsHTMLComboboxListAccessible ----- */
   1: 
   1: nsHTMLComboboxListAccessible::nsHTMLComboboxListAccessible(nsIAccessible *aParent,
   1:                                                            nsIDOMNode* aDOMNode,
   1:                                                            nsIWeakReference* aShell):
 566: nsHTMLSelectListAccessible(aDOMNode, aShell)
   1: {
   1: }
   1: 
   1: nsIFrame *nsHTMLComboboxListAccessible::GetFrame()
   1: {
 566:   nsIFrame* frame = nsHTMLSelectListAccessible::GetFrame();
 566: 
 566:   if (frame) {
 566:     nsIComboboxControlFrame* comboBox;
 566:     CallQueryInterface(frame, &comboBox);
 566:     if (comboBox) {
 566:       return comboBox->GetDropDown();
 566:     }
 566:   }
 566: 
 566:   return nsnull;
   1: }
   1: 
   1: /**
   1:   * As a nsHTMLComboboxListAccessible we can have the following states:
   1:   *     STATE_FOCUSED
   1:   *     STATE_FOCUSABLE
   1:   *     STATE_INVISIBLE
   1:   *     STATE_FLOATING
   1:   */
 262: NS_IMETHODIMP
 262: nsHTMLComboboxListAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
   1:   // Get focus status from base class
 262:   nsresult rv = nsAccessible::GetState(aState, aExtraState);
 262:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsIFrame *boundsFrame = GetBoundsFrame();
   1:   nsIComboboxControlFrame* comboFrame = nsnull;
4855:   if (boundsFrame)
   1:     boundsFrame->QueryInterface(NS_GET_IID(nsIComboboxControlFrame), (void**)&comboFrame);
   1: 
1209:   if (comboFrame && comboFrame->IsDroppedDown())
1209:     *aState |= nsIAccessibleStates::STATE_FLOATING;
   1:   else
1209:     *aState |= nsIAccessibleStates::STATE_INVISIBLE;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /** Return our cached parent */
   1: NS_IMETHODIMP nsHTMLComboboxListAccessible::GetParent(nsIAccessible **aParent)
   1: {
   1:   NS_IF_ADDREF(*aParent = mParent);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHTMLComboboxListAccessible::GetUniqueID(void **aUniqueID)
   1: {
   1:   // Since mDOMNode is same for all tree item, use |this| pointer as the unique Id
3233:   *aUniqueID = static_cast<void*>(this);
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * Gets the bounds for the areaFrame.
   1:   *     Walks the Frame tree and checks for proper frames.
   1:   */
   1: void nsHTMLComboboxListAccessible::GetBoundsRect(nsRect& aBounds, nsIFrame** aBoundingFrame)
   1: {
1209:   *aBoundingFrame = nsnull;
1209: 
1209:   nsCOMPtr<nsIAccessible> comboAccessible;
1209:   GetParent(getter_AddRefs(comboAccessible));
1209:   if (!comboAccessible) {
1209:     return;
1209:   }
1209:   if (0 == (State(comboAccessible) & nsIAccessibleStates::STATE_COLLAPSED)) {
1209:     nsHTMLSelectListAccessible::GetBoundsRect(aBounds, aBoundingFrame);
1209:     return;
1209:   }
   1:    // get our first option
   1:   nsCOMPtr<nsIDOMNode> child;
   1:   mDOMNode->GetFirstChild(getter_AddRefs(child));
   1: 
   1:   // now get its frame
1209:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
   1:   if (!shell) {
   1:     return;
   1:   }
   1: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(child));
1209:   if (!content) {
1209:     return;
1209:   }
   1:   nsIFrame* frame = shell->GetPrimaryFrameFor(content);
   1:   if (!frame) {
   1:     *aBoundingFrame = nsnull;
   1:     return;
   1:   }
   1: 
   1:   *aBoundingFrame = frame->GetParent();
   1:   aBounds = (*aBoundingFrame)->GetRect();
   1: }
