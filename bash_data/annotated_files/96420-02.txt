    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark <buster@netscape.com>
    1:  *   Dan Rosen <dr@netscape.com>
61031:  *   Mihai Sucan <mihai.sucan@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  *
    1:  * This Original Code has been modified by IBM Corporation.
    1:  * Modifications made by IBM described herein are
    1:  * Copyright (c) International Business Machines
    1:  * Corporation, 2000
    1:  *
    1:  * Modifications to Mozilla code or documentation
    1:  * identified per MPL Section 3.3
    1:  *
    1:  * Date         Modified by     Description of modification
    1:  * 05/03/2000   IBM Corp.       Observer related defines for reflow
    1:  */
    1: 
    1: /* a presentation of a document, part 2 */
    1: 
    1: #ifndef nsIPresShell_h___
    1: #define nsIPresShell_h___
    1: 
42982: #include "nsTHashtable.h"
42982: #include "nsHashKeys.h"
    1: #include "nsISupports.h"
32511: #include "nsQueryFrame.h"
    1: #include "nsCoord.h"
    1: #include "nsColor.h"
    1: #include "nsEvent.h"
    1: #include "nsCompatibility.h"
    1: #include "nsFrameManagerBase.h"
54080: #include "nsRect.h"
    1: #include "mozFlushType.h"
    1: #include "nsWeakReference.h"
    1: #include <stdio.h> // for FILE definition
46468: #include "nsChangeHint.h"
87650: #include "nsGUIEvent.h"
87650: #include "nsInterfaceHashtable.h"
89714: #include "nsEventStates.h"
    1: 
    1: class nsIContent;
    1: class nsIDocument;
    1: class nsIFrame;
    1: class nsPresContext;
    1: class nsStyleSet;
    1: class nsIViewManager;
49168: class nsIView;
68481: class nsRenderingContext;
    1: class nsIPageSequenceFrame;
    1: class nsAString;
15969: class nsCaret;
    1: class nsFrameSelection;
    1: class nsFrameManager;
    1: class nsILayoutHistoryState;
    1: class nsIReflowCallback;
    1: class nsIDOMNode;
43137: class nsIntRegion;
    1: class nsIStyleSheet;
    1: class nsCSSFrameConstructor;
    1: class nsISelection;
    1: template<class E> class nsCOMArray;
    1: class nsWeakFrame;
    1: class nsIScrollableFrame;
    1: class gfxASurface;
 1735: class gfxContext;
29844: class nsIDOMEvent;
29987: class nsDisplayList;
29987: class nsDisplayListBuilder;
47198: class nsPIDOMWindow;
47283: struct nsPoint;
47283: struct nsIntPoint;
47283: struct nsIntRect;
82568: class nsRegion;
50368: class nsRefreshDriver;
50368: class nsARefreshObserver;
61464: #ifdef ACCESSIBILITY
61464: class nsAccessibilityService;
61464: #endif
82568: class nsIWidget;
    1: 
    1: typedef short SelectionType;
43379: typedef PRUint64 nsFrameState;
    1: 
42327: namespace mozilla {
42327: namespace dom {
42327: class Element;
42327: } // namespace dom
48947: 
48947: namespace layers{
48947: class LayerManager;
48947: } // namespace layers
42327: } // namespace mozilla
42327: 
32435: // Flags to pass to SetCapturingContent
32435: //
32435: // when assigning capture, ignore whether capture is allowed or not
32435: #define CAPTURE_IGNOREALLOWED 1
32435: // true if events should be targeted at the capturing content or its children
32435: #define CAPTURE_RETARGETTOELEMENT 2
37876: // true if the current capture wants drags to be prevented
37876: #define CAPTURE_PREVENTDRAG 4
95203: // true when the mouse is pointer locked, and events are sent to locked elemnt
95203: #define CAPTURE_POINTERLOCK 8
32435: 
32435: typedef struct CapturingContentInfo {
32435:   // capture should only be allowed during a mousedown event
79445:   bool mAllowed;
95203:   bool mPointerLock;
79445:   bool mRetargetToElement;
79445:   bool mPreventDrag;
32435:   nsIContent* mContent;
32435: } CapturingContentInfo;
32435: 
    1: #define NS_IPRESSHELL_IID    \
91413:         { 0x4dc4db09, 0x03d4, 0x4427, \
91413:           { 0xbe, 0xfb, 0xc9, 0x29, 0xac, 0x5c, 0x62, 0xab } }
60746: 
    1: // debug VerifyReflow flags
    1: #define VERIFY_REFLOW_ON                    0x01
    1: #define VERIFY_REFLOW_NOISY                 0x02
    1: #define VERIFY_REFLOW_ALL                   0x04
    1: #define VERIFY_REFLOW_DUMP_COMMANDS         0x08
    1: #define VERIFY_REFLOW_NOISY_RC              0x10
    1: #define VERIFY_REFLOW_REALLY_NOISY_RC       0x20
23300: #define VERIFY_REFLOW_DURING_RESIZE_REFLOW  0x40
    1: 
27993: #undef NOISY_INTERRUPTIBLE_REFLOW
27993: 
37073: enum nsRectVisibility { 
37073:   nsRectVisibility_kVisible, 
37073:   nsRectVisibility_kAboveViewport, 
37073:   nsRectVisibility_kBelowViewport, 
37073:   nsRectVisibility_kLeftOfViewport, 
37073:   nsRectVisibility_kRightOfViewport
37073: };
37073: 
    1: /**
    1:  * Presentation shell interface. Presentation shells are the
    1:  * controlling point for managing the presentation of a document. The
    1:  * presentation shell holds a live reference to the document, the
    1:  * presentation context, the style manager, the style set and the root
    1:  * frame. <p>
    1:  *
    1:  * When this object is Release'd, it will release the document, the
    1:  * presentation context, the style manager, the style set and the root
    1:  * frame.
    1:  */
    1: 
    1: // hack to make egcs / gcc 2.95.2 happy
    1: class nsIPresShell_base : public nsISupports
    1: {
    1: public:
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IPRESSHELL_IID)
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsIPresShell_base, NS_IPRESSHELL_IID)
    1: 
    1: class nsIPresShell : public nsIPresShell_base
    1: {
48947: protected:
48947:   typedef mozilla::layers::LayerManager LayerManager;
48947: 
54080:   enum {
54080:     STATE_IGNORING_VIEWPORT_SCROLLING = 0x1,
54080:     STATE_USING_DISPLAYPORT = 0x2
54080:   };
54080: 
    1: public:
39668:   virtual NS_HIDDEN_(nsresult) Init(nsIDocument* aDocument,
    1:                                    nsPresContext* aPresContext,
    1:                                    nsIViewManager* aViewManager,
    1:                                    nsStyleSet* aStyleSet,
    1:                                    nsCompatibility aCompatMode) = 0;
    1: 
    1:   /**
    1:    * All callers are responsible for calling |Destroy| after calling
    1:    * |EndObservingDocument|.  It needs to be separate only because form
    1:    * controls incorrectly store their data in the frames rather than the
    1:    * content model and printing calls |EndObservingDocument| multiple
    1:    * times to make form controls behave nicely when printed.
    1:    */
39668:   virtual NS_HIDDEN_(void) Destroy() = 0;
    1: 
79445:   bool IsDestroying() { return mIsDestroying; }
19948: 
31620:   // All frames owned by the shell are allocated from an arena.  They
31620:   // are also recycled using free lists.  Separate free lists are
32511:   // maintained for each frame type (aCode), which must always
32511:   // correspond to the same aSize value. AllocateFrame clears the
32511:   // memory that it returns.
32511:   virtual void* AllocateFrame(nsQueryFrame::FrameIID aCode, size_t aSize) = 0;
32511:   virtual void  FreeFrame(nsQueryFrame::FrameIID aCode, void* aChunk) = 0;
31620: 
31620:   // Objects closely related to the frame tree, but that are not
31620:   // actual frames (subclasses of nsFrame) are also allocated from the
31620:   // arena, and recycled via a separate set of per-size free lists.
31620:   // AllocateMisc does *not* clear the memory that it returns.
31620:   virtual void* AllocateMisc(size_t aSize) = 0;
31620:   virtual void  FreeMisc(size_t aSize, void* aChunk) = 0;
    1: 
    1:   /**
    1:    * Stack memory allocation:
    1:    *
    1:    * Callers who wish to allocate memory whose lifetime corresponds to
    1:    * the lifetime of a stack-allocated object can use this API.  The
    1:    * caller must use a pair of calls to PushStackMemory and
    1:    * PopStackMemory, such that all stack object lifetimes are either
    1:    * entirely between the calls or containing both calls.
    1:    *
    1:    * Then, between the calls, the caller can call AllocateStackMemory to
    1:    * allocate memory from an arena pool that will be freed by the call
    1:    * to PopStackMemory.
    1:    *
    1:    * The allocations cannot be for more than 4044 bytes.
    1:    */
    1:   virtual void PushStackMemory() = 0;
    1:   virtual void PopStackMemory() = 0;
    1:   virtual void* AllocateStackMemory(size_t aSize) = 0;
    1: 
36656:   nsIDocument* GetDocument() const { return mDocument; }
    1: 
40044:   nsPresContext* GetPresContext() const { return mPresContext; }
    1: 
40044:   nsIViewManager* GetViewManager() const { return mViewManager; }
    1: 
    1: #ifdef _IMPL_NS_LAYOUT
40053:   nsStyleSet* StyleSet() const { return mStyleSet; }
    1: 
40053:   nsCSSFrameConstructor* FrameConstructor() const { return mFrameConstructor; }
    1: 
    1:   nsFrameManager* FrameManager() const {
89328:     // reinterpret_cast is valid since nsFrameManager does not add
89328:     // any members over nsFrameManagerBase.
 3233:     return reinterpret_cast<nsFrameManager*>
89328:                            (const_cast<nsIPresShell*>(this)->mFrameManager);
    1:   }
    1: 
    1: #endif
    1: 
    1:   /* Enable/disable author style level. Disabling author style disables the entire
    1:    * author level of the cascade, including the HTML preshint level.
    1:    */
    1:   // XXX these could easily be inlined, but there is a circular #include
    1:   // problem with nsStyleSet.
79445:   NS_HIDDEN_(void) SetAuthorStyleDisabled(bool aDisabled);
79445:   NS_HIDDEN_(bool) GetAuthorStyleDisabled() const;
    1: 
    1:   /*
    1:    * Called when stylesheets are added/removed/enabled/disabled to rebuild
    1:    * all style data for a given pres shell without necessarily reconstructing
    1:    * all of the frames.  This will not reconstruct style synchronously; if
    1:    * you need to do that, call FlushPendingNotifications to flush out style
    1:    * reresolves.
    1:    * // XXXbz why do we have this on the interface anyway?  The only consumer
    1:    * is calling AddOverrideStyleSheet/RemoveOverrideStyleSheet, and I think
    1:    * those should just handle reconstructing style data...
    1:    */
    1:   virtual NS_HIDDEN_(void) ReconstructStyleDataExternal();
    1:   NS_HIDDEN_(void) ReconstructStyleDataInternal();
    1: #ifdef _IMPL_NS_LAYOUT
    1:   void ReconstructStyleData() { ReconstructStyleDataInternal(); }
    1: #else
    1:   void ReconstructStyleData() { ReconstructStyleDataExternal(); }
    1: #endif
    1: 
    1:   /** Setup all style rules required to implement preferences
    1:    * - used for background/text/link colors and link underlining
    1:    *    may be extended for any prefs that are implemented via style rules
    1:    * - aForceReflow argument is used to force a full reframe to make the rules show
    1:    *   (only used when the current page needs to reflect changed pref rules)
    1:    *
    1:    * - initially created for bugs 31816, 20760, 22963
    1:    */
79445:   virtual NS_HIDDEN_(nsresult) SetPreferenceStyleRules(bool aForceReflow) = 0;
    1: 
    1:   /**
    1:    * FrameSelection will return the Frame based selection API.
    1:    * You cannot go back and forth anymore with QI between nsIDOM sel and
    1:    * nsIFrame sel.
    1:    */
 8295:   already_AddRefed<nsFrameSelection> FrameSelection();
 8295: 
 8295:   /**
 8295:    * ConstFrameSelection returns an object which methods are safe to use for
 8295:    * example in nsIFrame code.
 8295:    */
40053:   const nsFrameSelection* ConstFrameSelection() const { return mSelection; }
    1: 
 1416:   // Make shell be a document observer.  If called after Destroy() has
 1416:   // been called on the shell, this will be ignored.
39668:   virtual NS_HIDDEN_(void) BeginObservingDocument() = 0;
    1: 
    1:   // Make shell stop being a document observer
39668:   virtual NS_HIDDEN_(void) EndObservingDocument() = 0;
    1: 
    1:   /**
23164:    * Return whether InitialReflow() was previously called.
    1:    */
79445:   bool DidInitialReflow() const { return mDidInitialReflow; }
    1: 
    1:   /**
    1:    * Perform the initial reflow. Constructs the frame for the root content
    1:    * object and then reflows the frame model into the specified width and
    1:    * height.
    1:    *
 1416:    * The coordinates for aWidth and aHeight must be in standard nscoords.
 1416:    *
 1416:    * Callers of this method must hold a reference to this shell that
 1416:    * is guaranteed to survive through arbitrary script execution.
 1416:    * Calling InitialReflow can execute arbitrary script.
    1:    */
39668:   virtual NS_HIDDEN_(nsresult) InitialReflow(nscoord aWidth, nscoord aHeight) = 0;
    1: 
    1:   /**
    1:    * Reflow the frame model into a new width and height.  The
    1:    * coordinates for aWidth and aHeight must be in standard nscoord's.
    1:    */
39668:   virtual NS_HIDDEN_(nsresult) ResizeReflow(nscoord aWidth, nscoord aHeight) = 0;
54649:   /**
54649:    * Reflow, and also change presshell state so as to only permit
54649:    * reflowing off calls to ResizeReflowOverride() in the future.
54649:    * ResizeReflow() calls are ignored after ResizeReflowOverride().
54649:    */
54649:   virtual NS_HIDDEN_(nsresult) ResizeReflowOverride(nscoord aWidth, nscoord aHeight) = 0;
    1: 
    1:   /**
64531:    * Returns true if ResizeReflowOverride has been called.
64531:    */
79445:   virtual bool GetIsViewportOverridden() = 0;
64531: 
64531:   /**
64531:    * Return true if the presshell expects layout flush.
64531:    */
79445:   virtual bool IsLayoutFlushObserver() = 0;
64531: 
64531:   /**
    1:    * Reflow the frame model with a reflow reason of eReflowReason_StyleChange
    1:    */
39668:   virtual NS_HIDDEN_(void) StyleChangeReflow() = 0;
    1: 
    1:   /**
    1:    * This calls through to the frame manager to get the root frame.
    1:    */
40054:   virtual NS_HIDDEN_(nsIFrame*) GetRootFrameExternal() const;
40054:   nsIFrame* GetRootFrame() const {
40054: #ifdef _IMPL_NS_LAYOUT
89328:     return mFrameManager->GetRootFrame();
40054: #else
40054:     return GetRootFrameExternal();
40054: #endif
40054:   }
    1: 
    1:   /*
    1:    * Get root scroll frame from FrameManager()->GetRootFrame().
    1:    */
    1:   nsIFrame* GetRootScrollFrame() const;
    1: 
    1:   /*
    1:    * The same as GetRootScrollFrame, but returns an nsIScrollableFrame
    1:    */
    1:   nsIScrollableFrame* GetRootScrollFrameAsScrollable() const;
    1: 
34482:   /*
34482:    * The same as GetRootScrollFrame, but returns an nsIScrollableFrame.
34482:    * Can be called by code not linked into gklayout.
34482:    */
34482:   virtual nsIScrollableFrame* GetRootScrollFrameAsScrollableExternal() const;
34482: 
39248:   /*
39248:    * Gets nearest scrollable frame from current focused content or DOM
39248:    * selection if there is no focused content. The frame is scrollable with
39248:    * overflow:scroll or overflow:auto in some direction when aDirection is
39248:    * eEither.  Otherwise, this returns a nearest frame that is scrollable in
39248:    * the specified direction.
39248:    */
39248:   enum ScrollDirection { eHorizontal, eVertical, eEither };
39248:   nsIScrollableFrame* GetFrameToScrollAsScrollable(ScrollDirection aDirection);
39248: 
    1:   /**
    1:    * Returns the page sequence frame associated with the frame hierarchy.
    1:    * Returns NULL if not a paginated view.
    1:    */
39668:   virtual NS_HIDDEN_(nsIPageSequenceFrame*) GetPageSequenceFrame() const = 0;
    1: 
    1:   /**
10998:    * Gets the real primary frame associated with the content object.
10998:    *
10998:    * In the case of absolutely positioned elements and floated elements,
10998:    * the real primary frame is the frame that is out of the flow and not the
    1:    * placeholder frame.
    1:    */
10998:   virtual NS_HIDDEN_(nsIFrame*) GetRealPrimaryFrameFor(nsIContent* aContent) const = 0;
    1: 
    1:   /**
    1:    * Gets the placeholder frame associated with the specified frame. This is
    1:    * a helper frame that forwards the request to the frame manager.
    1:    */
39668:   virtual NS_HIDDEN_(nsIFrame*) GetPlaceholderFrameFor(nsIFrame* aFrame) const = 0;
    1: 
    1:   /**
 1158:    * Tell the pres shell that a frame needs to be marked dirty and needs
 1158:    * Reflow.  It's OK if this is an ancestor of the frame needing reflow as
 1158:    * long as the ancestor chain between them doesn't cross a reflow root.  The
 1205:    * bit to add should be either NS_FRAME_IS_DIRTY or
 1161:    * NS_FRAME_HAS_DIRTY_CHILDREN (but not both!).
    1:    */
    1:   enum IntrinsicDirty {
    1:     // XXXldb eResize should be renamed
    1:     eResize,     // don't mark any intrinsic widths dirty
    1:     eTreeChange, // mark intrinsic widths dirty on aFrame and its ancestors
    1:     eStyleChange // Do eTreeChange, plus all of aFrame's descendants
    1:   };
39668:   virtual NS_HIDDEN_(void) FrameNeedsReflow(nsIFrame *aFrame,
 1158:                                             IntrinsicDirty aIntrinsicDirty,
 1161:                                             nsFrameState aBitToAdd) = 0;
    1: 
27993:   /**
27993:    * Tell the presshell that the given frame's reflow was interrupted.  This
27993:    * will mark as having dirty children a path from the given frame (inclusive)
27993:    * to the nearest ancestor with a dirty subtree, or to the reflow root
27993:    * currently being reflowed if no such ancestor exists (inclusive).  This is
27993:    * to be done immediately after reflow of the current reflow root completes.
27993:    * This method must only be called during reflow, and the frame it's being
27993:    * called on must be in the process of being reflowed when it's called.  This
27993:    * method doesn't mark any intrinsic widths dirty and doesn't add any bits
27993:    * other than NS_FRAME_HAS_DIRTY_CHILDREN.
27993:    */
39668:   virtual NS_HIDDEN_(void) FrameNeedsToContinueReflow(nsIFrame *aFrame) = 0;
27993: 
39668:   virtual NS_HIDDEN_(void) CancelAllPendingReflows() = 0;
    1: 
    1:   /**
    1:    * Recreates the frames for a node
    1:    */
40046:   virtual NS_HIDDEN_(nsresult) RecreateFramesFor(nsIContent* aContent) = 0;
    1: 
42327:   void PostRecreateFramesFor(mozilla::dom::Element* aElement);
46468:   void RestyleForAnimation(mozilla::dom::Element* aElement,
46468:                            nsRestyleHint aHint);
15538: 
    1:   /**
    1:    * Determine if it is safe to flush all pending notifications
80486:    * @param aIsSafeToFlush true if it is safe, false otherwise.
    1:    * 
    1:    */
79445:   virtual NS_HIDDEN_(bool) IsSafeToFlush() const = 0;
    1: 
    1:   /**
    1:    * Flush pending notifications of the type specified.  This method
    1:    * will not affect the content model; it'll just affect style and
    1:    * frames. Callers that actually want up-to-date presentation (other
    1:    * than the document itself) should probably be calling
    1:    * nsIDocument::FlushPendingNotifications.
    1:    *
    1:    * @param aType the type of notifications to flush
    1:    */
39668:   virtual NS_HIDDEN_(void) FlushPendingNotifications(mozFlushType aType) = 0;
    1: 
    1:   /**
    1:    * Callbacks will be called even if reflow itself fails for
    1:    * some reason.
    1:    */
40046:   virtual NS_HIDDEN_(nsresult) PostReflowCallback(nsIReflowCallback* aCallback) = 0;
40046:   virtual NS_HIDDEN_(void) CancelReflowCallback(nsIReflowCallback* aCallback) = 0;
    1: 
40046:   virtual NS_HIDDEN_(void) ClearFrameRefs(nsIFrame* aFrame) = 0;
    1: 
    1:   /**
51038:    * Get a reference rendering context. This is a context that should not
51038:    * be rendered to, but is suitable for measuring text and performing
51038:    * other non-rendering operations.
    1:    */
68481:   virtual already_AddRefed<nsRenderingContext> GetReferenceRenderingContext() = 0;
    1: 
    1:   /**
    1:    * Informs the pres shell that the document is now at the anchor with
    1:    * the given name.  If |aScroll| is true, scrolls the view of the
    1:    * document so that the anchor with the specified name is displayed at
    1:    * the top of the window.  If |aAnchorName| is empty, then this informs
    1:    * the pres shell that there is no current target, and |aScroll| must
    1:    * be false.
    1:    */
79445:   virtual NS_HIDDEN_(nsresult) GoToAnchor(const nsAString& aAnchorName, bool aScroll) = 0;
    1: 
    1:   /**
12356:    * Tells the presshell to scroll again to the last anchor scrolled to by
12356:    * GoToAnchor, if any. This scroll only happens if the scroll
12356:    * position has not changed since the last GoToAnchor. This is called
12356:    * by nsDocumentViewer::LoadComplete. This clears the last anchor
12356:    * scrolled to by GoToAnchor (we don't want to keep it alive if it's
12356:    * removed from the DOM), so don't call this more than once.
12356:    */
40046:   virtual NS_HIDDEN_(nsresult) ScrollToAnchor() = 0;
12356: 
93554:   enum {
93554:     SCROLL_TOP     = 0,
93554:     SCROLL_BOTTOM  = 100,
93554:     SCROLL_LEFT    = 0,
93554:     SCROLL_RIGHT   = 100,
93554:     SCROLL_CENTER  = 50,
93554:     SCROLL_MINIMUM = -1
93554:   };
93554: 
93554:   enum WhenToScroll {
93554:     SCROLL_ALWAYS,
93554:     SCROLL_IF_NOT_VISIBLE,
93554:     SCROLL_IF_NOT_FULLY_VISIBLE
93554:   };
93554:   typedef struct ScrollAxis {
93554:     PRInt16 mWhereToScroll;
93554:     WhenToScroll mWhenToScroll;
93554:   /**
93554:    * @param aWhere: Either a percentage or a special value.
93554:    *                nsIPresShell defines:
93554:    *                * (Default) SCROLL_MINIMUM = -1: The visible area is
93554:    *                scrolled to show the entire frame. If the frame is too
93554:    *                large, the top and left edges are given precedence.
93554:    *                * SCROLL_TOP = 0: The frame's upper edge is aligned with the
93554:    *                top edge of the visible area.
93554:    *                * SCROLL_BOTTOM = 100: The frame's bottom edge is aligned
93554:    *                with the bottom edge of the visible area.
93554:    *                * SCROLL_LEFT = 0: The frame's left edge is aligned with the
93554:    *                left edge of the visible area.
93554:    *                * SCROLL_RIGHT = 100: The frame's right edge is aligned with
93554:    *                the right edge of the visible area.
93554:    *                * SCROLL_CENTER = 50: The frame is centered along the axis
93554:    *                the ScrollAxis is used for.
93554:    *
93554:    *                Other values are treated as a percentage, and the point
93554:    *                "percent" down the frame is placed at the point "percent"
93554:    *                down the visible area.
93554:    * @param aWhen:
93554:    *                * (Default) SCROLL_IF_NOT_FULLY_VISIBLE: Move the frame only
93554:    *                if it is not fully visible (including if it's not visible
93554:    *                at all). Note that in this case if the frame is too large to
93554:    *                fit in view, it will only be scrolled if more of it can fit
93554:    *                than is already in view.
93554:    *                * SCROLL_IF_NOT_VISIBLE: Move the frame only if none of it
93554:    *                is visible.
93554:    *                * SCROLL_ALWAYS: Move the frame regardless of its current
93554:    *                visibility.
93554:    */
93554:     ScrollAxis(PRInt16 aWhere = SCROLL_MINIMUM,
93554:                WhenToScroll aWhen = SCROLL_IF_NOT_FULLY_VISIBLE) :
93554:                  mWhereToScroll(aWhere), mWhenToScroll(aWhen) {}
93554:   } ScrollAxis;
12356:   /**
    1:    * Scrolls the view of the document so that the primary frame of the content
37077:    * is displayed in the window. Layout is flushed before scrolling.
    1:    *
    1:    * @param aContent  The content object of which primary frame should be
    1:    *                  scrolled into view.
93554:    * @param aVertical How to align the frame vertically and when to do so.
93554:    *                  This is a ScrollAxis of Where and When.
93554:    * @param aHorizontal How to align the frame horizontally and when to do so.
93554:    *                  This is a ScrollAxis of Where and When.
56647:    * @param aFlags    If SCROLL_FIRST_ANCESTOR_ONLY is set, only the nearest
56647:    *                  scrollable ancestor is scrolled, otherwise all
56647:    *                  scrollable ancestors may be scrolled if necessary.
56647:    *                  If SCROLL_OVERFLOW_HIDDEN is set then we may scroll in a
56647:    *                  direction even if overflow:hidden is specified in that
56647:    *                  direction; otherwise we will not scroll in that direction
56647:    *                  when overflow:hidden is set for that direction.
62343:    *                  If SCROLL_NO_PARENT_FRAMES is set then we only scroll
62343:    *                  nodes in this document, not in any parent documents which
62343:    *                  contain this document in a iframe or the like.
    1:    */
40046:   virtual NS_HIDDEN_(nsresult) ScrollContentIntoView(nsIContent* aContent,
93554:                                                      ScrollAxis  aVertical,
93554:                                                      ScrollAxis  aHorizontal,
56647:                                                      PRUint32    aFlags) = 0;
    1: 
37077:   enum {
37077:     SCROLL_FIRST_ANCESTOR_ONLY = 0x01,
62343:     SCROLL_OVERFLOW_HIDDEN = 0x02,
67816:     SCROLL_NO_PARENT_FRAMES = 0x04
37077:   };
37077:   /**
37077:    * Scrolls the view of the document so that the given area of a frame
37077:    * is visible, if possible. Layout is not flushed before scrolling.
37077:    * 
37077:    * @param aRect relative to aFrame
93554:    * @param aVertical see ScrollContentIntoView and ScrollAxis
93554:    * @param aHorizontal see ScrollContentIntoView and ScrollAxis
37077:    * @param aFlags if SCROLL_FIRST_ANCESTOR_ONLY is set, only the
37077:    * nearest scrollable ancestor is scrolled, otherwise all
37077:    * scrollable ancestors may be scrolled if necessary
37077:    * if SCROLL_OVERFLOW_HIDDEN is set then we may scroll in a direction
37077:    * even if overflow:hidden is specified in that direction; otherwise
37077:    * we will not scroll in that direction when overflow:hidden is
37077:    * set for that direction
62343:    * If SCROLL_NO_PARENT_FRAMES is set then we only scroll
62343:    * nodes in this document, not in any parent documents which
62343:    * contain this document in a iframe or the like.
37077:    * @return true if any scrolling happened, false if no scrolling happened
37077:    */
79445:   virtual bool ScrollFrameRectIntoView(nsIFrame*     aFrame,
37077:                                        const nsRect& aRect,
93554:                                        ScrollAxis    aVertical,
93554:                                        ScrollAxis    aHorizontal,
37077:                                        PRUint32      aFlags) = 0;
37077: 
    1:   /**
37073:    * Determine if a rectangle specified in the frame's coordinate system 
37073:    * intersects the viewport "enough" to be considered visible.
37073:    * @param aFrame frame that aRect coordinates are specified relative to
37073:    * @param aRect rectangle in twips to test for visibility 
37073:    * @param aMinTwips is the minimum distance in from the edge of the viewport
37073:    *                  that an object must be to be counted visible
37073:    * @return nsRectVisibility_kVisible if the rect is visible
37073:    *         nsRectVisibility_kAboveViewport
37073:    *         nsRectVisibility_kBelowViewport 
37073:    *         nsRectVisibility_kLeftOfViewport 
37073:    *         nsRectVisibility_kRightOfViewport rectangle is outside the viewport
37073:    *         in the specified direction 
37073:    */
37073:   virtual nsRectVisibility GetRectVisibility(nsIFrame *aFrame,
37073:                                              const nsRect &aRect,
40053:                                              nscoord aMinTwips) const = 0;
37073: 
37073:   /**
    1:    * Suppress notification of the frame manager that frames are
    1:    * being destroyed.
    1:    */
79445:   virtual NS_HIDDEN_(void) SetIgnoreFrameDestruction(bool aIgnore) = 0;
    1: 
    1:   /**
    1:    * Notification sent by a frame informing the pres shell that it is about to
    1:    * be destroyed.
    1:    * This allows any outstanding references to the frame to be cleaned up
    1:    */
40046:   virtual NS_HIDDEN_(void) NotifyDestroyingFrame(nsIFrame* aFrame) = 0;
    1: 
    1:   /**
    1:    * Get link location.
    1:    */
40053:   virtual NS_HIDDEN_(nsresult) GetLinkLocation(nsIDOMNode* aNode, nsAString& aLocation) const = 0;
    1: 
    1:   /**
    1:    * Get the caret, if it exists. AddRefs it.
    1:    */
40053:   virtual NS_HIDDEN_(already_AddRefed<nsCaret>) GetCaret() const = 0;
    1: 
    1:   /**
    1:    * Invalidate the caret's current position if it's outside of its frame's
    1:    * boundaries. This function is useful if you're batching selection
    1:    * notifications and might remove the caret's frame out from under it.
    1:    */
40045:   virtual NS_HIDDEN_(void) MaybeInvalidateCaretPosition() = 0;
    1: 
    1:   /**
 6232:    * Set the current caret to a new caret. To undo this, call RestoreCaret.
    1:    */
15969:   virtual void SetCaret(nsCaret *aNewCaret) = 0;
 6232: 
 6232:   /**
 6232:    * Restore the caret to the original caret that this pres shell was created
 6232:    * with.
 6232:    */
 6232:   virtual void RestoreCaret() = 0;
    1: 
    1:   /**
    1:    * Should the images have borders etc.  Actual visual effects are determined
    1:    * by the frames.  Visual effects may not effect layout, only display.
    1:    * Takes effect on next repaint, does not force a repaint itself.
    1:    *
80486:    * @param aInEnable  if true, visual selection effects are enabled
80486:    *                   if false visual selection effects are disabled
    1:    */
    1:   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable) = 0;
    1: 
    1:   /** 
    1:     * Gets the current state of non text selection effects
39668:     * @return   current state of non text selection,
    1:     *           as set by SetDisplayNonTextSelection
    1:     */
40051:   PRInt16 GetSelectionFlags() const { return mSelectionFlags; }
    1: 
    1:   virtual nsISelection* GetCurrentSelection(SelectionType aType) = 0;
    1: 
    1:   /**
    1:     * Interface to dispatch events via the presshell
   95:     * @note The caller must have a strong reference to the PresShell.
    1:     */
40055:   virtual NS_HIDDEN_(nsresult) HandleEventWithTarget(nsEvent* aEvent,
    1:                                                      nsIFrame* aFrame,
    1:                                                      nsIContent* aContent,
    1:                                                      nsEventStatus* aStatus) = 0;
    1: 
    1:   /**
    1:    * Dispatch event to content only (NOT full processing)
   95:    * @note The caller must have a strong reference to the PresShell.
    1:    */
40055:   virtual NS_HIDDEN_(nsresult) HandleDOMEventWithTarget(nsIContent* aTargetContent,
    1:                                                         nsEvent* aEvent,
    1:                                                         nsEventStatus* aStatus) = 0;
    1: 
    1:   /**
29844:    * Dispatch event to content only (NOT full processing)
29844:    * @note The caller must have a strong reference to the PresShell.
29844:    */
40055:   virtual NS_HIDDEN_(nsresult) HandleDOMEventWithTarget(nsIContent* aTargetContent,
29844:                                                         nsIDOMEvent* aEvent,
29844:                                                         nsEventStatus* aStatus) = 0;
29844: 
29844:   /**
    1:     * Gets the current target event frame from the PresShell
    1:     */
40047:   virtual NS_HIDDEN_(nsIFrame*) GetEventTargetFrame() = 0;
    1: 
    1:   /**
    1:     * Gets the current target event frame from the PresShell
    1:     */
40047:   virtual NS_HIDDEN_(already_AddRefed<nsIContent>) GetEventTargetContent(nsEvent* aEvent) = 0;
    1: 
    1:   /**
    1:    * Get and set the history state for the current document 
    1:    */
    1: 
79445:   virtual NS_HIDDEN_(nsresult) CaptureHistoryState(nsILayoutHistoryState** aLayoutHistoryState, bool aLeavingPage = false) = 0;
    1: 
    1:   /**
    1:    * Determine if reflow is currently locked
80486:    * returns true if reflow is locked, false otherwise
    1:    */
79445:   bool IsReflowLocked() const { return mIsReflowing; }
    1: 
    1:   /**
    1:    * Called to find out if painting is suppressed for this presshell.  If it is suppressd,
    1:    * we don't allow the painting of any layer but the background, and we don't
    1:    * recur into our children.
    1:    */
79445:   bool IsPaintingSuppressed() const { return mPaintingSuppressed; }
    1: 
    1:   /**
    1:    * Unsuppress painting.
    1:    */
40049:   virtual NS_HIDDEN_(void) UnsuppressPainting() = 0;
    1: 
    1:   /**
    1:    * Called to disable nsITheme support in a specific presshell.
    1:    */
40661:   void DisableThemeSupport()
40661:   {
40661:     // Doesn't have to be dynamic.  Just set the bool.
80486:     mIsThemeSupportDisabled = true;
40661:   }
    1: 
    1:   /**
    1:    * Indicates whether theme support is enabled.
    1:    */
79445:   bool IsThemeSupportEnabled() const { return !mIsThemeSupportDisabled; }
    1: 
    1:   /**
    1:    * Get the set of agent style sheets for this presentation
    1:    */
    1:   virtual nsresult GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets) = 0;
    1: 
    1:   /**
    1:    * Replace the set of agent style sheets
    1:    */
    1:   virtual nsresult SetAgentStyleSheets(const nsCOMArray<nsIStyleSheet>& aSheets) = 0;
    1: 
    1:   /**
    1:    * Add an override style sheet for this presentation
    1:    */
    1:   virtual nsresult AddOverrideStyleSheet(nsIStyleSheet *aSheet) = 0;
    1: 
    1:   /**
    1:    * Remove an override style sheet
    1:    */
    1:   virtual nsresult RemoveOverrideStyleSheet(nsIStyleSheet *aSheet) = 0;
    1: 
    1:   /**
    1:    * Reconstruct frames for all elements in the document
    1:    */
    1:   virtual nsresult ReconstructFrames() = 0;
    1: 
    1:   /**
89714:    * Notify that a content node's state has changed
89714:    */
89714:   virtual void ContentStateChanged(nsIDocument* aDocument,
89714:                                    nsIContent* aContent,
89714:                                    nsEventStates aStateMask) = 0;
89714: 
89714:   /**
 5680:    * Given aFrame, the root frame of a stacking context, find its descendant
 5680:    * frame under the point aPt that receives a mouse event at that location,
 5680:    * or nsnull if there is no such frame.
 5680:    * @param aPt the point, relative to the frame origin
 5680:    */
 5680:   virtual nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt) = 0;
 5680: 
 5680:   /**
    1:    * See if reflow verification is enabled. To enable reflow verification add
    1:    * "verifyreflow:1" to your NSPR_LOG_MODULES environment variable
    1:    * (any non-zero debug level will work). Or, call SetVerifyReflowEnable
80486:    * with true.
    1:    */
79445:   static bool GetVerifyReflowEnable();
    1: 
    1:   /**
    1:    * Set the verify-reflow enable flag.
    1:    */
79445:   static void SetVerifyReflowEnable(bool aEnabled);
    1: 
10522:   virtual nsIFrame* GetAbsoluteContainingBlock(nsIFrame* aFrame);
10522: 
    1: #ifdef MOZ_REFLOW_PERF
40052:   virtual NS_HIDDEN_(void) DumpReflows() = 0;
40052:   virtual NS_HIDDEN_(void) CountReflows(const char * aName, nsIFrame * aFrame) = 0;
40052:   virtual NS_HIDDEN_(void) PaintCount(const char * aName,
68481:                                       nsRenderingContext* aRenderingContext,
    1:                                       nsPresContext * aPresContext,
    1:                                       nsIFrame * aFrame,
68487:                                       const nsPoint& aOffset,
    1:                                       PRUint32 aColor) = 0;
79445:   virtual NS_HIDDEN_(void) SetPaintFrameCount(bool aOn) = 0;
79445:   virtual bool IsPaintingFrameCounts() = 0;
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:   // Debugging hooks
    1:   virtual void ListStyleContexts(nsIFrame *aRootFrame, FILE *out,
    1:                                  PRInt32 aIndent = 0) = 0;
    1: 
    1:   virtual void ListStyleSheets(FILE *out, PRInt32 aIndent = 0) = 0;
    1:   virtual void VerifyStyleTree() = 0;
    1: #endif
    1: 
74013: #ifdef ACCESSIBILITY
74013:   /**
74013:    * Return true if accessibility is active.
74013:    */
74013:   static bool IsAccessibilityActive();
    1: 
61464:   /**
61464:    * Return accessibility service if accessibility is active.
61464:    */
61464:   static nsAccessibilityService* AccService();
61464: #endif
61464: 
    1:   /**
    1:    * Stop all active elements (plugins and the caret) in this presentation and
    1:    * in the presentations of subdocuments.  Resets painting to a suppressed state.
    1:    * XXX this should include image animations
    1:    */
    1:   virtual void Freeze() = 0;
79445:   bool IsFrozen() { return mFrozen; }
    1: 
    1:   /**
    1:    * Restarts active elements (plugins) in this presentation and in the
    1:    * presentations of subdocuments, then do a full invalidate of the content area.
    1:    */
    1:   virtual void Thaw() = 0;
    1: 
79445:   virtual void FireOrClearDelayedEvents(bool aFireEvents) = 0;
25722: 
    1:   /**
    1:    * When this shell is disconnected from its containing docshell, we
    1:    * lose our container pointer.  However, we'd still like to be able to target
    1:    * user events at the docshell's parent.  This pointer allows us to do that.
    1:    * It should not be used for any other purpose.
    1:    */
    1:   void SetForwardingContainer(nsWeakPtr aContainer)
    1:   {
    1:     mForwardingContainer = aContainer;
    1:   }
    1:   
    1:   /**
 1735:    * Render the document into an arbitrary gfxContext
 1735:    * Designed for getting a picture of a document or a piece of a document
 1735:    * Note that callers will generally want to call FlushPendingNotifications
 1735:    * to get an up-to-date view of the document
    1:    * @param aRect is the region to capture into the offscreen buffer, in the
    1:    * root frame's coordinate system (if aIgnoreViewportScrolling is false)
    1:    * or in the root scrolled frame's coordinate system
 7683:    * (if aIgnoreViewportScrolling is true). The coordinates are in appunits.
22950:    * @param aFlags see below;
22950:    *   set RENDER_IS_UNTRUSTED if the contents may be passed to malicious
    1:    * agents. E.g. we might choose not to paint the contents of sensitive widgets
    1:    * such as the file name in a file upload widget, and we might choose not
    1:    * to paint themes.
22950:    *   set RENDER_IGNORE_VIEWPORT_SCROLLING to ignore
22950:    * clipping/scrolling/scrollbar painting due to scrolling in the viewport
22950:    *   set RENDER_CARET to draw the caret if one would be visible
22950:    * (by default the caret is never drawn)
38805:    *   set RENDER_USE_LAYER_MANAGER to force rendering to go through
38805:    * the layer manager for the window. This may be unexpectedly slow
38805:    * (if the layer manager must read back data from the GPU) or low-quality
38805:    * (if the layer manager reads back pixel data and scales it
38805:    * instead of rendering using the appropriate scaling). It may also
38805:    * slow everything down if the area rendered does not correspond to the
38805:    * normal visible area of the window.
48224:    *   set RENDER_ASYNC_DECODE_IMAGES to avoid having images synchronously
48224:    * decoded during rendering.
48224:    * (by default images decode synchronously with RenderDocument)
54079:    *   set RENDER_DOCUMENT_RELATIVE to interpret |aRect| relative to the
54079:    * document instead of the CSS viewport
    1:    * @param aBackgroundColor a background color to render onto
 7683:    * @param aRenderedContext the gfxContext to render to. We render so that
 7683:    * one CSS pixel in the source document is rendered to one unit in the current
 7683:    * transform.
    1:    */
22950:   enum {
22950:     RENDER_IS_UNTRUSTED = 0x01,
22950:     RENDER_IGNORE_VIEWPORT_SCROLLING = 0x02,
38805:     RENDER_CARET = 0x04,
48224:     RENDER_USE_WIDGET_LAYERS = 0x08,
54079:     RENDER_ASYNC_DECODE_IMAGES = 0x10,
54079:     RENDER_DOCUMENT_RELATIVE = 0x20
22950:   };
40052:   virtual NS_HIDDEN_(nsresult) RenderDocument(const nsRect& aRect, PRUint32 aFlags,
    1:                                               nscolor aBackgroundColor,
 1735:                                               gfxContext* aRenderedContext) = 0;
    1: 
    1:   /**
    1:    * Renders a node aNode to a surface and returns it. The aRegion may be used
43137:    * to clip the rendering. This region is measured in CSS pixels from the
    1:    * edge of the presshell area. The aPoint, aScreenRect and aSurface
    1:    * arguments function in a similar manner as RenderSelection.
    1:    */
    1:   virtual already_AddRefed<gfxASurface> RenderNode(nsIDOMNode* aNode,
43137:                                                    nsIntRegion* aRegion,
23738:                                                    nsIntPoint& aPoint,
23738:                                                    nsIntRect* aScreenRect) = 0;
    1: 
29987:   /**
    1:    * Renders a selection to a surface and returns it. This method is primarily
    1:    * intended to create the drag feedback when dragging a selection.
    1:    *
    1:    * aScreenRect will be filled in with the bounding rectangle of the
    1:    * selection area on screen.
    1:    *
    1:    * If the area of the selection is large, the image will be scaled down.
    1:    * The argument aPoint is used in this case as a reference point when
    1:    * determining the new screen rectangle after scaling. Typically, this
    1:    * will be the mouse position, so that the screen rectangle is positioned
    1:    * such that the mouse is over the same point in the scaled image as in
    1:    * the original. When scaling does not occur, the mouse point isn't used
    1:    * as the position can be determined from the displayed frames.
    1:    */
    1:   virtual already_AddRefed<gfxASurface> RenderSelection(nsISelection* aSelection,
23738:                                                         nsIntPoint& aPoint,
23738:                                                         nsIntRect* aScreenRect) = 0;
    1: 
34904:   void AddWeakFrameInternal(nsWeakFrame* aWeakFrame);
34904:   virtual void AddWeakFrameExternal(nsWeakFrame* aWeakFrame);
34904: 
34904:   void AddWeakFrame(nsWeakFrame* aWeakFrame)
34904:   {
34904: #ifdef _IMPL_NS_LAYOUT
34904:     AddWeakFrameInternal(aWeakFrame);
34904: #else
34904:     AddWeakFrameExternal(aWeakFrame);
34904: #endif
34904:   }
34904: 
34904:   void RemoveWeakFrameInternal(nsWeakFrame* aWeakFrame);
34904:   virtual void RemoveWeakFrameExternal(nsWeakFrame* aWeakFrame);
34904: 
34904:   void RemoveWeakFrame(nsWeakFrame* aWeakFrame)
34904:   {
34904: #ifdef _IMPL_NS_LAYOUT
34904:     RemoveWeakFrameInternal(aWeakFrame);
34904: #else
34904:     RemoveWeakFrameExternal(aWeakFrame);
34904: #endif
34904:   }
    1: 
    1: #ifdef NS_DEBUG
    1:   nsIFrame* GetDrawEventTargetFrame() { return mDrawEventTargetFrame; }
    1: #endif
    1: 
24947:   /**
24947:    * Stop or restart non synthetic test mouse event handling on *all*
24947:    * presShells.
24947:    *
25385:    * @param aDisable If true, disable all non synthetic test mouse
25385:    * events on all presShells.  Otherwise, enable them.
24947:    */
79445:   virtual NS_HIDDEN_(void) DisableNonTestMouseEvents(bool aDisable) = 0;
24947: 
29987:   /**
29987:    * Record the background color of the most recently drawn canvas. This color
29987:    * is composited on top of the user's default background color and then used
29987:    * to draw the background color of the canvas. See PresShell::Paint,
29987:    * PresShell::PaintDefaultBackground, and nsDocShell::SetupNewViewer;
29987:    * bug 488242, bug 476557 and other bugs mentioned there.
25385:    */
25385:   void SetCanvasBackground(nscolor aColor) { mCanvasBackgroundColor = aColor; }
25385:   nscolor GetCanvasBackground() { return mCanvasBackgroundColor; }
25385: 
29987:   /**
29987:    * Use the current frame tree (if it exists) to update the background
29987:    * color of the most recently drawn canvas.
27834:    */
27834:   virtual void UpdateCanvasBackground() = 0;
27834: 
29987:   /**
64531:    * Add a solid color item to the bottom of aList with frame aFrame and bounds
64531:    * aBounds. Checks first if this needs to be done by checking if aFrame is a
64531:    * canvas frame (if the FORCE_DRAW flag is passed then this check is skipped).
64531:    * aBackstopColor is composed behind the background color of the canvas, it is
69802:    * transparent by default.
29987:    */
64531:   enum {
69802:     FORCE_DRAW = 0x01
64531:   };
29987:   virtual nsresult AddCanvasBackgroundColorItem(nsDisplayListBuilder& aBuilder,
29987:                                                 nsDisplayList& aList,
29987:                                                 nsIFrame* aFrame,
47739:                                                 const nsRect& aBounds,
35428:                                                 nscolor aBackstopColor = NS_RGBA(0,0,0,0),
64531:                                                 PRUint32 aFlags = 0) = 0;
64531: 
29987: 
49166:   /**
49166:    * Add a solid color item to the bottom of aList with frame aFrame and
49166:    * bounds aBounds representing the dark grey background behind the page of a
49166:    * print preview presentation.
49166:    */
49166:   virtual nsresult AddPrintPreviewBackgroundItem(nsDisplayListBuilder& aBuilder,
49166:                                                  nsDisplayList& aList,
49166:                                                  nsIFrame* aFrame,
49166:                                                  const nsRect& aBounds) = 0;
49166: 
49168:   /**
49168:    * Computes the backstop color for the view: transparent if in a transparent
49168:    * widget, otherwise the PresContext default background color. This color is
49168:    * only visible if the contents of the view as a whole are translucent.
49168:    */
49168:   virtual nscolor ComputeBackstopColor(nsIView* aDisplayRoot) = 0;
49168: 
79445:   void ObserveNativeAnonMutationsForPrint(bool aObserve)
27606:   {
27606:     mObservesMutationsForPrint = aObserve;
27606:   }
79445:   bool ObservesNativeAnonMutationsForPrint()
27606:   {
27606:     return mObservesMutationsForPrint;
27606:   }
27606: 
79445:   virtual nsresult SetIsActive(bool aIsActive) = 0;
48937: 
79445:   bool IsActive()
48937:   {
48937:     return mIsActive;
48937:   }
48937: 
32435:   // mouse capturing
32435: 
32435:   static CapturingContentInfo gCaptureInfo;
32435: 
87650:   static nsInterfaceHashtable<nsUint32HashKey, nsIDOMTouch> gCaptureTouchList;
87650:   static bool gPreventMouseEvents;
87650: 
32435:   /**
32435:    * When capturing content is set, it traps all mouse events and retargets
32435:    * them at this content node. If capturing is not allowed
32435:    * (gCaptureInfo.mAllowed is false), then capturing is not set. However, if
32435:    * the CAPTURE_IGNOREALLOWED flag is set, the allowed state is ignored and
32435:    * capturing is set regardless. To disable capture, pass null for the value
32435:    * of aContent.
32435:    *
32435:    * If CAPTURE_RETARGETTOELEMENT is set, all mouse events are targeted at
32435:    * aContent only. Otherwise, mouse events are targeted at aContent or its
32435:    * descendants. That is, descendants of aContent receive mouse events as
32435:    * they normally would, but mouse events outside of aContent are retargeted
32435:    * to aContent.
37876:    *
37876:    * If CAPTURE_PREVENTDRAG is set then drags are prevented from starting while
37876:    * this capture is active.
95203:    *
95203:    * If CAPTURE_POINTERLOCK is set, similar to CAPTURE_RETARGETTOELEMENT, then
95203:    * events are targeted at aContent, but capturing is held more strongly (i.e.,
95203:    * calls to SetCapturingContent won't unlock unless CAPTURE_POINTERLOCK is
95203:    * set again).
32435:    */
32435:   static void SetCapturingContent(nsIContent* aContent, PRUint8 aFlags);
32435: 
32435:   /**
32435:    * Return the active content currently capturing the mouse if any.
32435:    */
32435:   static nsIContent* GetCapturingContent()
32435:   {
32435:     return gCaptureInfo.mContent;
32435:   }
32435: 
32435:   /**
32435:    * Allow or disallow mouse capturing.
32435:    */
79445:   static void AllowMouseCapture(bool aAllowed)
32435:   {
32435:     gCaptureInfo.mAllowed = aAllowed;
32435:   }
32435: 
37876:   /**
37876:    * Returns true if there is an active mouse capture that wants to prevent
37876:    * drags.
37876:    */
79445:   static bool IsMouseCapturePreventingDrag()
37876:   {
37876:     return gCaptureInfo.mPreventDrag && gCaptureInfo.mContent;
37876:   }
37876: 
42240:   /**
42240:    * Keep track of how many times this presshell has been rendered to
42240:    * a window.
42240:    */
42240:   PRUint64 GetPaintCount() { return mPaintCount; }
42240:   void IncrementPaintCount() { ++mPaintCount; }
42240: 
42982:   /**
47198:    * Get the root DOM window of this presShell.
47198:    */
47198:   virtual already_AddRefed<nsPIDOMWindow> GetRootWindow() = 0;
47198: 
47198:   /**
48947:    * Get the layer manager for the widget of the root view, if it has
48947:    * one.
48947:    */
48947:   virtual LayerManager* GetLayerManager() = 0;
48947: 
48947:   /**
54080:    * Track whether we're ignoring viewport scrolling for the purposes
54080:    * of painting.  If we are ignoring, then layers aren't clipped to
54080:    * the CSS viewport and scrollbars aren't drawn.
52492:    */
79445:   virtual void SetIgnoreViewportScrolling(bool aIgnore) = 0;
79445:   bool IgnoringViewportScrolling() const
54080:   { return mRenderFlags & STATE_IGNORING_VIEWPORT_SCROLLING; }
54080: 
54080:    /**
54081:    * Set a "resolution" for the document, which if not 1.0 will
54081:    * allocate more or fewer pixels for rescalable content by a factor
54081:    * of |resolution| in both dimensions.  Return NS_OK iff the
54081:    * resolution bounds are sane, and the resolution of this was
54081:    * actually updated.
54081:    *
54081:    * The resolution defaults to 1.0.
54081:    */
54081:   virtual nsresult SetResolution(float aXResolution, float aYResolution) = 0;
54081:   float GetXResolution() { return mXResolution; }
54081:   float GetYResolution() { return mYResolution; }
52492: 
52492:   /**
93057:    * Set the isFirstPaint flag.
93057:    */
93057:   void SetIsFirstPaint(bool aIsFirstPaint) { mIsFirstPaint = aIsFirstPaint; }
93057: 
93057:   /**
93057:    * Get the isFirstPaint flag.
93057:    */
93057:   bool GetIsFirstPaint() const { return mIsFirstPaint; }
93057: 
93057:   /**
54098:    * Dispatch a mouse move event based on the most recent mouse position if
54098:    * this PresShell is visible. This is used when the contents of the page
54098:    * moved (aFromScroll is false) or scrolled (aFromScroll is true).
54098:    */
79445:   virtual void SynthesizeMouseMove(bool aFromScroll) = 0;
54098: 
82568:   virtual void Paint(nsIView* aViewToPaint, nsIWidget* aWidget,
82568:                      const nsRegion& aDirtyRegion, const nsIntRegion& aIntDirtyRegion,
88468:                      bool aWillSendDidPaint) = 0;
82568:   virtual nsresult HandleEvent(nsIFrame*       aFrame,
82568:                                nsGUIEvent*     aEvent,
82568:                                bool            aDontRetargetEvents,
82568:                                nsEventStatus*  aEventStatus) = 0;
82568:   virtual bool ShouldIgnoreInvalidation() = 0;
88468:   /**
88468:    * Notify that the NS_WILL_PAINT event was received. Fires on every
88468:    * visible presshell in the document tree.
88468:    */
82568:   virtual void WillPaint(bool aWillSendDidPaint) = 0;
88468:   /**
88468:    * Notify that the NS_DID_PAINT event was received. Only fires on the
88468:    * root pres shell.
88468:    */
82568:   virtual void DidPaint() = 0;
87344:   virtual void ScheduleViewManagerFlush() = 0;
82568:   virtual void ClearMouseCaptureOnView(nsIView* aView) = 0;
82568:   virtual bool IsVisible() = 0;
82568:   virtual void DispatchSynthMouseMove(nsGUIEvent *aEvent, bool aFlushOnHoverChange) = 0;
82568: 
91413:   virtual void SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
91413:                                    size_t *aArenasSize,
91413:                                    size_t *aStyleSetsSize,
91413:                                    size_t *aTextRunsSize) const = 0;
91413: 
54098:   /**
96420:    * Methods that retrieve the cached font inflation preferences.
96420:    */
96420:   PRUint32 FontSizeInflationEmPerLine() const {
96420:     return mFontSizeInflationEmPerLine;
96420:   }
96420: 
96420:   PRUint32 FontSizeInflationMinTwips() const {
96420:     return mFontSizeInflationMinTwips;
96420:   }
96420: 
96420:   PRUint32 FontSizeInflationLineThreshold() const {
96420:     return mFontSizeInflationLineThreshold;
96420:   }
96420: 
96420:   /**
43799:    * Refresh observer management.
43799:    */
43799: protected:
79445:   virtual bool AddRefreshObserverExternal(nsARefreshObserver* aObserver,
43799:                                             mozFlushType aFlushType);
79445:   bool AddRefreshObserverInternal(nsARefreshObserver* aObserver,
43799:                                     mozFlushType aFlushType);
79445:   virtual bool RemoveRefreshObserverExternal(nsARefreshObserver* aObserver,
43799:                                                mozFlushType aFlushType);
79445:   bool RemoveRefreshObserverInternal(nsARefreshObserver* aObserver,
43799:                                        mozFlushType aFlushType);
43799: public:
79445:   bool AddRefreshObserver(nsARefreshObserver* aObserver,
43799:                             mozFlushType aFlushType) {
43799: #ifdef _IMPL_NS_LAYOUT
43799:     return AddRefreshObserverInternal(aObserver, aFlushType);
43799: #else
43799:     return AddRefreshObserverExternal(aObserver, aFlushType);
43799: #endif
43799:   }
43799: 
79445:   bool RemoveRefreshObserver(nsARefreshObserver* aObserver,
43799:                                mozFlushType aFlushType) {
43799: #ifdef _IMPL_NS_LAYOUT
43799:     return RemoveRefreshObserverInternal(aObserver, aFlushType);
43799: #else
43799:     return RemoveRefreshObserverExternal(aObserver, aFlushType);
43799: #endif
43799:   }
43799: 
43799:   /**
42982:    * Initialize and shut down static variables.
42982:    */
42982:   static void InitializeStatics();
42982:   static void ReleaseStatics();
42982: 
80851:   // If a frame in the subtree rooted at aFrame is capturing the mouse then
80851:   // clears that capture.
80851:   static void ClearMouseCapture(nsIFrame* aFrame);
80851: 
95977:   void SetScrollPositionClampingScrollPortSize(nscoord aWidth, nscoord aHeight);
95977:   bool IsScrollPositionClampingScrollPortSizeSet() {
95977:     return mScrollPositionClampingScrollPortSizeSet;
95977:   }
95977:   nsSize GetScrollPositionClampingScrollPortSize() {
95977:     NS_ASSERTION(mScrollPositionClampingScrollPortSizeSet, "asking for scroll port when its not set?");
95977:     return mScrollPositionClampingScrollPortSize;
95977:   }
95977: 
    1: protected:
50365:   friend class nsRefreshDriver;
50365: 
    1:   // IMPORTANT: The ownership implicit in the following member variables
    1:   // has been explicitly checked.  If you add any members to this class,
    1:   // please make the ownership explicit (pinkerton, scc).
    1: 
    1:   // these are the same Document and PresContext owned by the DocViewer.
    1:   // we must share ownership.
    1:   nsIDocument*              mDocument;      // [STRONG]
    1:   nsPresContext*            mPresContext;   // [STRONG]
    1:   nsStyleSet*               mStyleSet;      // [OWNS]
50365:   nsCSSFrameConstructor*    mFrameConstructor; // [OWNS]
    1:   nsIViewManager*           mViewManager;   // [WEAK] docViewer owns it so I don't have to
    1:   nsFrameSelection*         mSelection;
89328:   // Pointer into mFrameConstructor - this is purely so that FrameManager() and
89328:   // GetRootFrame() can be inlined:
89328:   nsFrameManagerBase*       mFrameManager;
    1:   nsWeakPtr                 mForwardingContainer;
    1: 
    1: #ifdef NS_DEBUG
    1:   nsIFrame*                 mDrawEventTargetFrame;
    1: #endif
    1: 
42240:   // Count of the number of times this presshell has been painted to
42240:   // a window
42240:   PRUint64                  mPaintCount;
42240: 
40051:   PRInt16                   mSelectionFlags;
40051: 
79445:   bool                      mStylesHaveChanged;
79445:   bool                      mDidInitialReflow;
79445:   bool                      mIsDestroying;
79445:   bool                      mIsReflowing;
79445:   bool                      mPaintingSuppressed;  // For all documents we initially lock down painting.
79445:   bool                      mIsThemeSupportDisabled;  // Whether or not form controls should use nsITheme in this shell.
79445:   bool                      mIsActive;
79445:   bool                      mFrozen;
    1: 
93057:   bool                      mIsFirstPaint;
93057: 
79445:   bool                      mObservesMutationsForPrint;
27606: 
79445:   bool                      mReflowScheduled; // If true, we have a reflow
50365:                                               // scheduled. Guaranteed to be
50365:                                               // false if mReflowContinueTimer
50365:                                               // is non-null.
50365: 
79445:   bool                      mSuppressInterruptibleReflows;
50365: 
95977:   bool                      mScrollPositionClampingScrollPortSizeSet;
95977: 
    1:   // A list of weak frames. This is a pointer to the last item in the list.
    1:   nsWeakFrame*              mWeakFrames;
25385: 
25385:   // Most recent canvas background color.
25385:   nscolor                   mCanvasBackgroundColor;
42982: 
54080:   // Flags controlling how our document is rendered.  These persist
54080:   // between paints and so are tied with retained layer pixels.
54080:   // PresShell flushes retained layers when the rendering state
54080:   // changes in a way that prevents us from being able to (usefully)
54080:   // re-use old pixels.
54080:   PRUint32                  mRenderFlags;
54080: 
54081:   // Used to force allocation and rendering of proportionally more or
54081:   // less pixels in the given dimension.
54081:   float                     mXResolution;
54081:   float                     mYResolution;
54081: 
95977:   nsSize                    mScrollPositionClampingScrollPortSize;
95977: 
50720:   static nsIContent* gKeyDownTarget;
    1: };
    1: 
    1: /**
96420: 
96420:   // Cached font inflation values. This is done to prevent changing of font
96420:   // inflation until a page is reloaded.
96420:   PRUint32 mFontSizeInflationEmPerLine;
96420:   PRUint32 mFontSizeInflationMinTwips;
96420:   PRUint32 mFontSizeInflationLineThreshold;
    1:  * Create a new empty presentation shell. Upon success, call Init
    1:  * before attempting to use the shell.
    1:  */
    1: nsresult
    1: NS_NewPresShell(nsIPresShell** aInstancePtrResult);
    1: 
    1: #endif /* nsIPresShell_h___ */
