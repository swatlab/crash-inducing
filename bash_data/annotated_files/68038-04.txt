    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Aaron Leventhal (aaronl@netscape.com)
    1:  *   Kyle Yuan (kyle.yuan@sun.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsHTMLTextAccessible.h"
39503: 
39503: #include "nsDocAccessible.h"
54466: #include "nsAccUtils.h"
54466: #include "nsRelUtils.h"
41384: #include "nsTextEquivUtils.h"
67790: #include "States.h"
39503: 
    1: #include "nsIFrame.h"
    1: #include "nsPresContext.h"
55763: #include "nsBlockFrame.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionController.h"
    1: #include "nsComponentManagerUtils.h"
    1: 
34092: ////////////////////////////////////////////////////////////////////////////////
34092: // nsHTMLTextAccessible
34092: ////////////////////////////////////////////////////////////////////////////////
34092: 
43504: nsHTMLTextAccessible::
43504:   nsHTMLTextAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsTextAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
34199: NS_IMPL_ISUPPORTS_INHERITED0(nsHTMLTextAccessible, nsTextAccessible)
34199: 
20246: NS_IMETHODIMP
20246: nsHTMLTextAccessible::GetName(nsAString& aName)
    1: {
20246:   // Text node, ARIA can't be used.
61682:   aName = mText;
61682:   return NS_OK;
    1: }
    1: 
52027: PRUint32
52027: nsHTMLTextAccessible::NativeRole()
    1: {
    1:   nsIFrame *frame = GetFrame();
 5395:   // Don't return on null frame -- we still return a role
 5395:   // after accessible is shutdown/DEFUNCT
 5395:   if (frame && frame->IsGeneratedContentFrame()) {
52027:     return nsIAccessibleRole::ROLE_STATICTEXT;
    1:   }
    1: 
52027:   return nsTextAccessible::NativeRole();
    1: }
    1: 
67790: PRUint64
67790: nsHTMLTextAccessible::NativeState()
    1: {
67790:   PRUint64 state = nsTextAccessible::NativeState();
    1: 
39503:   nsDocAccessible *docAccessible = GetDocAccessible();
    1:   if (docAccessible) {
67790:      PRUint64 docState = docAccessible->State();
67790:      if (0 == (docState & states::EDITABLE)) {
67790:        state |= states::READONLY; // Links not focusable in editor
    1:      }
    1:   }
    1: 
67790:   return state;
    1: }
    1: 
  401: nsresult
  401: nsHTMLTextAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
    1: {
52027:   if (NativeRole() == nsIAccessibleRole::ROLE_STATICTEXT) {
    1:     nsAutoString oldValueUnused;
19098:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("auto-generated"),
    1:                                   NS_LITERAL_STRING("true"), oldValueUnused);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
43504: 
34092: ////////////////////////////////////////////////////////////////////////////////
34092: // nsHTMLHRAccessible
34092: ////////////////////////////////////////////////////////////////////////////////
34092: 
43504: nsHTMLHRAccessible::
43504:   nsHTMLHRAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsLeafAccessible(aContent, aShell)
    1: {
    1: }
    1: 
52027: PRUint32
52027: nsHTMLHRAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_SEPARATOR;
    1: }
    1: 
43504: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsHTMLBRAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
43504: 
43504: nsHTMLBRAccessible::
43504:   nsHTMLBRAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsLeafAccessible(aContent, aShell)
    1: {
    1: }
    1: 
52027: PRUint32
52027: nsHTMLBRAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_WHITESPACE;
    1: }
    1: 
67790: PRUint64
67790: nsHTMLBRAccessible::NativeState()
    1: {
68037:   return IsDefunct() ? states::DEFUNCT : states::READONLY;
    1: }
    1: 
20246: nsresult
20246: nsHTMLBRAccessible::GetNameInternal(nsAString& aName)
    1: {
 3233:   aName = static_cast<PRUnichar>('\n');    // Newline char
    1:   return NS_OK;
    1: }
    1: 
34092: ////////////////////////////////////////////////////////////////////////////////
34092: // nsHTMLLabelAccessible
34092: ////////////////////////////////////////////////////////////////////////////////
12086: 
34092: nsHTMLLabelAccessible::
43504:   nsHTMLLabelAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
43504: NS_IMPL_ISUPPORTS_INHERITED0(nsHTMLLabelAccessible, nsHyperTextAccessible)
43504: 
20246: nsresult
25175: nsHTMLLabelAccessible::GetNameInternal(nsAString& aName)
    1: {
25175:   return nsTextEquivUtils::GetNameFromSubtree(this, aName);
    1: }
    1: 
52027: PRUint32
52027: nsHTMLLabelAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_LABEL;
    1: }
    1: 
34092: ////////////////////////////////////////////////////////////////////////////////
54466: // nsHTMLOuputAccessible
54466: ////////////////////////////////////////////////////////////////////////////////
54466: 
54466: nsHTMLOutputAccessible::
54466:   nsHTMLOutputAccessible(nsIContent* aContent, nsIWeakReference* aShell) :
54466:   nsHyperTextAccessibleWrap(aContent, aShell)
54466: {
54466: }
54466: 
54466: NS_IMPL_ISUPPORTS_INHERITED0(nsHTMLOutputAccessible, nsHyperTextAccessible)
54466: 
54466: NS_IMETHODIMP
54466: nsHTMLOutputAccessible::GetRelationByType(PRUint32 aRelationType,
54466:                                           nsIAccessibleRelation** aRelation)
54466: {
54466:   nsresult rv = nsAccessibleWrap::GetRelationByType(aRelationType, aRelation);
54466:   NS_ENSURE_SUCCESS(rv, rv);
54466: 
54466:   if (rv != NS_OK_NO_RELATION_TARGET)
54466:     return NS_OK; // XXX bug 381599, avoid performance problems
54466: 
54466:   if (aRelationType == nsIAccessibleRelation::RELATION_CONTROLLED_BY) {
54466:     return nsRelUtils::
54466:       AddTargetFromIDRefsAttr(aRelationType, aRelation, mContent,
54466:                               nsAccessibilityAtoms::_for);
54466:   }
54466: 
54466:   return NS_OK;
54466: }
54466: 
54466: PRUint32
54466: nsHTMLOutputAccessible::NativeRole()
54466: {
54466:   return nsIAccessibleRole::ROLE_SECTION;
54466: }
54466: 
54466: nsresult
54466: nsHTMLOutputAccessible::GetAttributesInternal(nsIPersistentProperties* aAttributes)
54466: {
54466:   nsresult rv = nsAccessibleWrap::GetAttributesInternal(aAttributes);
54466:   NS_ENSURE_SUCCESS(rv, rv);
54466: 
54466:   nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::live,
54466:                          NS_LITERAL_STRING("polite"));
54466:   
54466:   return NS_OK;
54466: }
54466: 
54466: 
54466: ////////////////////////////////////////////////////////////////////////////////
34092: // nsHTMLLIAccessible
34092: ////////////////////////////////////////////////////////////////////////////////
    1: 
34113: nsHTMLLIAccessible::
55763:   nsHTMLLIAccessible(nsIContent* aContent, nsIWeakReference* aShell) :
64006:   nsHyperTextAccessibleWrap(aContent, aShell), mBullet(nsnull)
    1: {
64006:   mFlags |= eHTMLListItemAccessible;
64006: 
55763:   nsBlockFrame* blockFrame = do_QueryFrame(GetFrame());
64006:   if (blockFrame && blockFrame->HasBullet()) {
64006:     mBullet = new nsHTMLListBulletAccessible(mContent, mWeakShell);
64006:     if (!GetDocAccessible()->BindToDocument(mBullet, nsnull))
64006:       mBullet = nsnull;
    1:   }
    1: }
    1: 
34113: NS_IMPL_ISUPPORTS_INHERITED0(nsHTMLLIAccessible, nsHyperTextAccessible)
34113: 
43538: void
21169: nsHTMLLIAccessible::Shutdown()
    1: {
64006:   mBullet = nsnull;
32878: 
43538:   nsHyperTextAccessibleWrap::Shutdown();
    1: }
    1: 
52027: PRUint32
52027: nsHTMLLIAccessible::NativeRole()
25822: {
52027:   return nsIAccessibleRole::ROLE_LISTITEM;
25822: }
25822: 
67790: PRUint64
67790: nsHTMLLIAccessible::NativeState()
 2735: {
67790:   return nsHyperTextAccessibleWrap::NativeState() | states::READONLY;
 2735: }
 2735: 
    1: NS_IMETHODIMP nsHTMLLIAccessible::GetBounds(PRInt32 *x, PRInt32 *y, PRInt32 *width, PRInt32 *height)
    1: {
    1:   nsresult rv = nsAccessibleWrap::GetBounds(x, y, width, height);
64006:   if (NS_FAILED(rv) || !mBullet)
    1:     return rv;
    1: 
    1:   PRInt32 bulletX, bulletY, bulletWidth, bulletHeight;
64006:   rv = mBullet->GetBounds(&bulletX, &bulletY, &bulletWidth, &bulletHeight);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *x = bulletX; // Move x coordinate of list item over to cover bullet as well
    1:   *width += bulletWidth;
    1:   return NS_OK;
    1: }
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
64006: // nsHTMLLIAccessible: public
64006: 
64006: void
64006: nsHTMLLIAccessible::UpdateBullet(bool aHasBullet)
64006: {
64006:   if (aHasBullet == !!mBullet) {
64006:     NS_NOTREACHED("Bullet and accessible are in sync already!");
64006:     return;
64006:   }
64006: 
64006:   nsDocAccessible* document = GetDocAccessible();
64006:   if (aHasBullet) {
64006:     mBullet = new nsHTMLListBulletAccessible(mContent, mWeakShell);
64006:     if (document->BindToDocument(mBullet, nsnull)) {
64006:       InsertChildAt(0, mBullet);
64006:     }
64006:   } else {
64006:     RemoveChild(mBullet);
64006:     document->UnbindFromDocument(mBullet);
64006:     mBullet = nsnull;
64006:   }
64006: 
64006:   // XXXtodo: fire show/hide and reorder events. That's hard to make it
64006:   // right now because coalescence happens by DOM node.
64006: }
64006: 
64006: ////////////////////////////////////////////////////////////////////////////////
35523: // nsHTMLLIAccessible: nsAccessible protected
35523: 
35523: void
35523: nsHTMLLIAccessible::CacheChildren()
    1: {
64006:   if (mBullet)
64006:     AppendChild(mBullet);
    1: 
35523:   // Cache children from subtree.
    1:   nsAccessibleWrap::CacheChildren();
    1: }
    1: 
34092: ////////////////////////////////////////////////////////////////////////////////
34092: // nsHTMLListBulletAccessible
34092: ////////////////////////////////////////////////////////////////////////////////
    1: 
  436: nsHTMLListBulletAccessible::
55763:   nsHTMLListBulletAccessible(nsIContent* aContent, nsIWeakReference* aShell) :
55763:     nsLeafAccessible(aContent, aShell)
    1: {
    1: }
    1: 
56292: ////////////////////////////////////////////////////////////////////////////////
56292: // nsHTMLListBulletAccessible: nsAccessNode
    1: 
56292: bool
56292: nsHTMLListBulletAccessible::IsPrimaryForNode() const
56292: {
56292:   return false;
56292: }
56292: 
56292: ////////////////////////////////////////////////////////////////////////////////
56292: // nsHTMLListBulletAccessible: nsAccessible
56292: 
  436: NS_IMETHODIMP
  436: nsHTMLListBulletAccessible::GetName(nsAString &aName)
    1: {
55763:   aName.Truncate();
55763: 
55763:   if (IsDefunct())
55763:     return NS_ERROR_FAILURE;
55763: 
55763:   // Native anonymous content, ARIA can't be used. Get list bullet text.
55763:   nsBlockFrame* blockFrame = do_QueryFrame(mContent->GetPrimaryFrame());
64006:   NS_ASSERTION(blockFrame, "No frame for list item!");
55763:   if (blockFrame) {
55763:     blockFrame->GetBulletText(aName);
55763: 
55763:     // Append space otherwise bullets are jammed up against list text.
55763:     aName.Append(' ');
55763:   }
55763: 
    1:   return NS_OK;
    1: }
  262: 
52027: PRUint32
52027: nsHTMLListBulletAccessible::NativeRole()
  436: {
52027:   return nsIAccessibleRole::ROLE_STATICTEXT;
  436: }
  436: 
67790: PRUint64
67790: nsHTMLListBulletAccessible::NativeState()
  262: {
67790:   PRUint64 state = nsLeafAccessible::NativeState();
  262: 
67790:   state &= ~states::FOCUSABLE;
67790:   state |= states::READONLY;
67790:   return state;
  262: }
  262: 
61682: void
 4261: nsHTMLListBulletAccessible::AppendTextTo(nsAString& aText, PRUint32 aStartOffset,
 4261:                                          PRUint32 aLength)
  460: {
64006:   nsAutoString bulletText;
55763:   nsBlockFrame* blockFrame = do_QueryFrame(mContent->GetPrimaryFrame());
64006:   NS_ASSERTION(blockFrame, "No frame for list item!");
64006:   if (blockFrame)
55763:     blockFrame->GetBulletText(bulletText);
55763: 
64006:   aText.Append(Substring(bulletText, aStartOffset, aLength));
  460: }
  460: 
25822: ////////////////////////////////////////////////////////////////////////////////
  262: // nsHTMLListAccessible
34092: ////////////////////////////////////////////////////////////////////////////////
  262: 
43504: nsHTMLListAccessible::
43504:   nsHTMLListAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
43504: {
43504: }
43504: 
34113: NS_IMPL_ISUPPORTS_INHERITED0(nsHTMLListAccessible, nsHyperTextAccessible)
34113: 
52027: PRUint32
52027: nsHTMLListAccessible::NativeRole()
25822: {
52027:   return nsIAccessibleRole::ROLE_LIST;
25822: }
25822: 
67790: PRUint64
67790: nsHTMLListAccessible::NativeState()
  262: {
67790:   return nsHyperTextAccessibleWrap::NativeState() | states::READONLY;
  262: }
  262: 
