     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
 30988:  * data structures passed to nsIStyleRuleProcessor methods (to pull loop
 30988:  * invariant computations out of the loop)
     1:  */
     1: 
 30988: #ifndef nsRuleProcessorData_h_
 30988: #define nsRuleProcessorData_h_
     1: 
 78018: #include "nsPresContext.h" // for nsCompatibility
     1: #include "nsString.h"
     1: #include "nsChangeHint.h"
 30307: #include "nsIContent.h"
 35555: #include "nsCSSPseudoElements.h"
 40193: #include "nsRuleWalker.h"
 64147: #include "nsNthIndexCache.h"
 94422: #include "nsILoadContext.h"
133735: #include "mozilla/AutoRestore.h"
 92180: #include "mozilla/BloomFilter.h"
 92180: #include "mozilla/GuardObjects.h"
     1: 
     1: class nsIStyleSheet;
     1: class nsIAtom;
     1: class nsICSSPseudoComparator;
     1: class nsAttrValue;
128828: struct TreeMatchContext;
     1: 
 64143: /**
 92180:  * An AncestorFilter is used to keep track of ancestors so that we can
 92180:  * quickly tell that a particular selector is not relevant to a given
 92180:  * element.
 92180:  */
 92180: class NS_STACK_CLASS AncestorFilter {
128828:   friend struct TreeMatchContext;
 92180:  public:
 92180:   /* Maintenance of our ancestor state */
 92180:   void PushAncestor(mozilla::dom::Element *aElement);
 92180:   void PopAncestor();
 92180: 
 92180:   /* Check whether we might have an ancestor matching one of the given
 92180:      atom hashes.  |hashes| must have length hashListLength */
 92180:   template<size_t hashListLength>
 92180:     bool MightHaveMatchingAncestor(const uint32_t* aHashes) const
 92180:   {
 92180:     MOZ_ASSERT(mFilter);
 92180:     for (size_t i = 0; i < hashListLength && aHashes[i]; ++i) {
 92180:       if (!mFilter->mightContain(aHashes[i])) {
 92180:         return false;
 92180:       }
 92180:     }
 92180: 
 92180:     return true;
 92180:   }
 92180: 
 92180:   bool HasFilter() const { return mFilter; }
 92180: 
 92180: #ifdef DEBUG
 92180:   void AssertHasAllAncestors(mozilla::dom::Element *aElement) const;
 92180: #endif
 92180:   
 92180:  private:
 92180:   // Using 2^12 slots makes the Bloom filter a nice round page in
 92180:   // size, so let's do that.  We get a false positive rate of 1% or
 92180:   // less even with several hundred things in the filter.  Note that
 92180:   // we allocate the filter lazily, because not all tree match
 92180:   // contexts can use one effectively.
 92180:   typedef mozilla::BloomFilter<12, nsIAtom> Filter;
 92180:   nsAutoPtr<Filter> mFilter;
 92180: 
 92180:   // Stack of indices to pop to.  These are indices into mHashes.
108991:   nsTArray<uint32_t> mPopTargets;
 92180: 
 92180:   // List of hashes; this is what we pop using mPopTargets.  We store
 92180:   // hashes of our ancestor element tag names, ids, and classes in
 92180:   // here.
 92180:   nsTArray<uint32_t> mHashes;
 92180: 
 92180:   // A debug-only stack of Elements for use in assertions
 92180: #ifdef DEBUG
 92180:   nsTArray<mozilla::dom::Element*> mElements;
 92180: #endif
 92180: };
 92180: 
 92180: /**
 64143:  * A |TreeMatchContext| has data about a matching operation.  The
 64143:  * data are not node-specific but are invariants of the DOM tree the
 64143:  * nodes being matched against are in.
 64143:  *
 64143:  * Most of the members are in parameters to selector matching.  The
 64143:  * one out parameter is mHaveRelevantLink.  Consumers that use a
 64157:  * TreeMatchContext for more than one matching operation and care
 64157:  * about :visited and mHaveRelevantLink need to
 64157:  * ResetForVisitedMatching() and ResetForUnvisitedMatching() as
 64157:  * needed.
 64143:  */
 64156: struct NS_STACK_CLASS TreeMatchContext {
 64157:   // Reset this context for matching for the style-if-:visited.
 64157:   void ResetForVisitedMatching() {
 64157:     NS_PRECONDITION(mForStyling, "Why is this being called?");
 80486:     mHaveRelevantLink = false;
 64157:     mVisitedHandling = nsRuleWalker::eRelevantLinkVisited;
 64157:   }
 64157:   
 64157:   void ResetForUnvisitedMatching() {
 64157:     NS_PRECONDITION(mForStyling, "Why is this being called?");
 80486:     mHaveRelevantLink = false;
 64157:     mVisitedHandling = nsRuleWalker::eRelevantLinkUnvisited;
 64157:   }
 64157: 
 80486:   void SetHaveRelevantLink() { mHaveRelevantLink = true; }
 79445:   bool HaveRelevantLink() const { return mHaveRelevantLink; }
 64157: 
 64157:   nsRuleWalker::VisitedHandlingType VisitedHandling() const
 64157:   {
 64157:     return mVisitedHandling;
 64157:   }
 64157: 
124867:   void AddScopeElement(mozilla::dom::Element* aElement) {
124867:     NS_PRECONDITION(mHaveSpecifiedScope,
124867:                     "Should be set before calling AddScopeElement()");
124867:     mScopes.AppendElement(aElement);
124867:   }
124867:   bool IsScopeElement(mozilla::dom::Element* aElement) const {
124867:     return mScopes.Contains(aElement);
124867:   }
124867:   void SetHasSpecifiedScope() {
124867:     mHaveSpecifiedScope = true;
124867:   }
124867:   bool HasSpecifiedScope() const {
124867:     return mHaveSpecifiedScope;
124867:   }
124867: 
128828:   /**
128828:    * Initialize the ancestor filter and list of style scopes.  If aElement is
128828:    * not null, it and all its ancestors will be passed to
128828:    * mAncestorFilter.PushAncestor and PushStyleScope, starting from the root and
128828:    * going down the tree.
128828:    */
128828:   void InitAncestors(mozilla::dom::Element *aElement);
128828: 
128828:   void PushStyleScope(mozilla::dom::Element* aElement)
128828:   {
128828:     NS_PRECONDITION(aElement, "aElement must not be null");
128828:     if (aElement->IsScopedStyleRoot()) {
128828:       mStyleScopes.AppendElement(aElement);
128828:     }
128828:   }
128828: 
128828:   void PopStyleScope(mozilla::dom::Element* aElement)
128828:   {
128828:     NS_PRECONDITION(aElement, "aElement must not be null");
128828:     if (mStyleScopes.SafeLastElement(nullptr) == aElement) {
128828:       mStyleScopes.TruncateLength(mStyleScopes.Length() - 1);
128828:     }
128828:   }
128828:  
128829:   bool PopStyleScopeForSelectorMatching(mozilla::dom::Element* aElement)
128829:   {
129672:     NS_ASSERTION(mForScopedStyle, "only call PopStyleScopeForSelectorMatching "
129672:                                   "when mForScopedStyle is true");
128829: 
128829:     if (!mCurrentStyleScope) {
128829:       return false;
128829:     }
128829:     if (mCurrentStyleScope == aElement) {
128829:       mCurrentStyleScope = nullptr;
128829:     }
128829:     return true;
128829:   }
128829: 
128829:   bool SetStyleScopeForSelectorMatching(mozilla::dom::Element* aSubject,
128829:                                         mozilla::dom::Element* aScope)
128829:   {
128829:     mForScopedStyle = !!aScope;
128829:     if (!aScope) {
128829:       // This is not for a scoped style sheet; return true, as we want
128829:       // selector matching to proceed.
128829:       mCurrentStyleScope = nullptr;
128829:       return true;
128829:     }
128829:     if (aScope == aSubject) {
128829:       // Although the subject is the same element as the scope, as soon
128829:       // as we continue with selector matching up the tree we don't want
128829:       // to match any more elements.  So we return true to indicate that
128829:       // we want to do the initial selector matching, but set
128829:       // mCurrentStyleScope to null so that no ancestor elements will match.
128829:       mCurrentStyleScope = nullptr;
128829:       return true;
128829:     }
128829:     if (mStyleScopes.Contains(aScope)) {
128829:       // mStyleScopes contains all of the scope elements that are ancestors of
128829:       // aSubject, so if aScope is in mStyleScopes, then we do want selector
128829:       // matching to proceed.
128829:       mCurrentStyleScope = aScope;
128829:       return true;
128829:     }
128829:     // Otherwise, we're not in the scope, and we don't want to proceed
128829:     // with selector matching.
128829:     mCurrentStyleScope = nullptr;
128829:     return false;
128829:   }
128829: 
128829:   bool IsWithinStyleScopeForSelectorMatching() const
128829:   {
128829:     NS_ASSERTION(mForScopedStyle, "only call IsWithinScopeForSelectorMatching "
128829:                                   "when mForScopedStyle is true");
128829:     return mCurrentStyleScope;
128829:   }
128721: 
128828:   /* Helper class for maintaining the ancestor state */
128828:   class NS_STACK_CLASS AutoAncestorPusher {
128828:   public:
128828:     AutoAncestorPusher(bool aDoPush,
128828:                        TreeMatchContext &aTreeMatchContext,
128828:                        mozilla::dom::Element *aElement
128828:                        MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
128828:       : mPushed(aDoPush && aElement),
128828:         mTreeMatchContext(aTreeMatchContext),
128828:         mElement(aElement)
128828:     {
128828:       MOZ_GUARD_OBJECT_NOTIFIER_INIT;
128828:       if (mPushed) {
128828:         mTreeMatchContext.mAncestorFilter.PushAncestor(aElement);
128828:         mTreeMatchContext.PushStyleScope(aElement);
128828:       }
128828:     }
128828:     ~AutoAncestorPusher() {
128828:       if (mPushed) {
128828:         mTreeMatchContext.mAncestorFilter.PopAncestor();
128828:         mTreeMatchContext.PopStyleScope(mElement);
128828:       }
128828:     }
128828: 
128828:   private:
128828:     bool mPushed;
128828:     TreeMatchContext& mTreeMatchContext;
128828:     mozilla::dom::Element* mElement;
128828:     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
128828:   };
128828: 
133735:   /* Helper class for tracking whether we're skipping the ApplyStyleFixups
133735:    * code for flex items. */
133735:   class NS_STACK_CLASS AutoFlexItemStyleFixupSkipper {
133735:   public:
133735:     AutoFlexItemStyleFixupSkipper(TreeMatchContext& aTreeMatchContext
133735:                                   MOZ_GUARD_OBJECT_NOTIFIER_PARAM)
133735:       : mAutoRestorer(aTreeMatchContext.mSkippingFlexItemStyleFixup)
133735:     {
133735:       MOZ_GUARD_OBJECT_NOTIFIER_INIT;
133735:       aTreeMatchContext.mSkippingFlexItemStyleFixup = true;
133735:     }
133735: 
133735:   private:
133735:     mozilla::AutoRestore<bool> mAutoRestorer;
133735:     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
133735:   };
133735: 
128829:   // Is this matching operation for the creation of a style context?
128829:   // (If it is, we need to set slow selector bits on nodes indicating
128829:   // that certain restyling needs to happen.)
128829:   const bool mForStyling;
128829: 
 64157:  private:
 64157:   // When mVisitedHandling is eRelevantLinkUnvisited, this is set to true if a
 64157:   // relevant link (see explanation in definition of VisitedHandling enum) was
 64157:   // encountered during the matching process, which means that matching needs
 64157:   // to be rerun with eRelevantLinkVisited.  Otherwise, its behavior is
 64157:   // undefined (it might get set appropriately, or might not).
 79445:   bool mHaveRelevantLink;
 64143: 
124867:   // If true, then our contextual reference element set is specified,
124867:   // and is given by mScopes.
124867:   bool mHaveSpecifiedScope;
124867: 
 64143:   // How matching should be performed.  See the documentation for
 64143:   // nsRuleWalker::VisitedHandlingType.
 64143:   nsRuleWalker::VisitedHandlingType mVisitedHandling;
 64143: 
124867:   // For matching :scope
124867:   nsAutoTArray<mozilla::dom::Element*, 1> mScopes;
 64157:  public:
 64147:   // The document we're working with.
 82209:   nsIDocument* const mDocument;
 64147: 
 64144:   // Root of scoped stylesheet (set and unset by the supplier of the
 64144:   // scoped stylesheet).
 64144:   nsIContent* mScopedRoot;
 64144: 
 64145:   // Whether our document is HTML (as opposed to XML of some sort,
 64145:   // including XHTML).
 64147:   // XXX XBL2 issue: Should we be caching this?  What should it be for XBL2?
 79445:   const bool mIsHTMLDocument;
 64145: 
 64146:   // Possibly remove use of mCompatMode in SelectorMatches?
 64147:   // XXX XBL2 issue: Should we be caching this?  What should it be for XBL2?
 64146:   const nsCompatibility mCompatMode;
 64146: 
 64147:   // The nth-index cache we should use
 64147:   nsNthIndexCache mNthIndexCache;
 64147: 
 92180:   // An ancestor filter
 92180:   AncestorFilter mAncestorFilter;
 92180: 
 94422:   // Whether this document is using PB mode
 94422:   bool mUsingPrivateBrowsing;
 94422: 
133735:   // Whether we're currently skipping the flex item chunk of ApplyStyleFixups
133735:   // when resolving style (e.g. for children of elements that have a mandatory
133735:   // frame-type and can't be flex containers despite having "display:flex").
133735:   bool mSkippingFlexItemStyleFixup;
133735: 
128829:   // Whether this TreeMatchContext is being used with an nsCSSRuleProcessor
128829:   // for an HTML5 scoped style sheet.
128829:   bool mForScopedStyle;
128829: 
101616:   enum MatchVisited {
101616:     eNeverMatchVisited,
101616:     eMatchVisitedDefault
101616:   };
101616: 
128828:   // List of ancestor elements that define a style scope (due to having a
128828:   // <style scoped> child).
128828:   nsAutoTArray<mozilla::dom::Element*, 1> mStyleScopes;
128828: 
128829:   // The current style scope element for selector matching.
128829:   mozilla::dom::Element* mCurrentStyleScope;
128829: 
 64157:   // Constructor to use when creating a tree match context for styling
 79445:   TreeMatchContext(bool aForStyling,
 64145:                    nsRuleWalker::VisitedHandlingType aVisitedHandling,
101616:                    nsIDocument* aDocument,
101616:                    MatchVisited aMatchVisited = eMatchVisitedDefault)
 64143:     : mForStyling(aForStyling)
 80486:     , mHaveRelevantLink(false)
124867:     , mHaveSpecifiedScope(false)
 64143:     , mVisitedHandling(aVisitedHandling)
 64147:     , mDocument(aDocument)
106838:     , mScopedRoot(nullptr)
 64146:     , mIsHTMLDocument(aDocument->IsHTML())
 64146:     , mCompatMode(aDocument->GetCompatibilityMode())
 94422:     , mUsingPrivateBrowsing(false)
133735:     , mSkippingFlexItemStyleFixup(false)
128829:     , mForScopedStyle(false)
128829:     , mCurrentStyleScope(nullptr)
 64143:   {
101616:     if (aMatchVisited != eNeverMatchVisited) {
 94422:       nsCOMPtr<nsISupports> container = mDocument->GetContainer();
 94422:       if (container) {
 94422:         nsCOMPtr<nsILoadContext> loadContext = do_QueryInterface(container);
 94422:         NS_ASSERTION(loadContext, "Couldn't get loadContext from container; assuming no private browsing.");
 94422:         if (loadContext) {
 94422:           mUsingPrivateBrowsing = loadContext->UsePrivateBrowsing();
 94422:         }
 94422:       }
 64143:     }
101616:   }
 64143: };
 64143: 
 64157: struct NS_STACK_CLASS RuleProcessorData {
     1:   RuleProcessorData(nsPresContext* aPresContext,
121909:                     nsRuleWalker* aRuleWalker)
121909:     : mPresContext(aPresContext),
128829:       mRuleWalker(aRuleWalker),
128829:       mScope(nullptr)
121909:   {
121909:     NS_PRECONDITION(mPresContext, "Must have prescontext");
121909:   }
121909: 
121909:   nsPresContext* const mPresContext;
121909:   nsRuleWalker* const mRuleWalker; // Used to add rules to our results.
128829:   mozilla::dom::Element* mScope;
121909: };
121909: 
121909: struct NS_STACK_CLASS ElementDependentRuleProcessorData :
121909:                           public RuleProcessorData {
121909:   ElementDependentRuleProcessorData(nsPresContext* aPresContext,
 41644:                                     mozilla::dom::Element* aElement,
     1:                                     nsRuleWalker* aRuleWalker,
 64157:                                     TreeMatchContext& aTreeMatchContext)
121909:     : RuleProcessorData(aPresContext, aRuleWalker)
 64156:     , mElement(aElement)
 64157:     , mTreeMatchContext(aTreeMatchContext)
 16106:   {
 64156:     NS_ASSERTION(aElement, "null element leaked into SelectorMatches");
 80526:     NS_ASSERTION(aElement->OwnerDoc(), "Document-less node here?");
 64157:     NS_PRECONDITION(aTreeMatchContext.mForStyling == !!aRuleWalker,
 64157:                     "Should be styling if and only if we have a rule walker");
 64143:   }
 64143:   
 64156:   mozilla::dom::Element* const mElement; // weak ref, must not be null
 64157:   TreeMatchContext& mTreeMatchContext;
     1: };
     1: 
121909: struct NS_STACK_CLASS ElementRuleProcessorData :
121909:                           public ElementDependentRuleProcessorData {
     1:   ElementRuleProcessorData(nsPresContext* aPresContext,
 41644:                            mozilla::dom::Element* aElement, 
 64157:                            nsRuleWalker* aRuleWalker,
 64157:                            TreeMatchContext& aTreeMatchContext)
121909:     : ElementDependentRuleProcessorData(aPresContext, aElement, aRuleWalker,
121909:                                         aTreeMatchContext)
     1:   {
 64157:     NS_PRECONDITION(aTreeMatchContext.mForStyling, "Styling here!");
121909:     NS_PRECONDITION(aRuleWalker, "Must have rule walker");
     1:   }
     1: };
     1: 
121909: struct NS_STACK_CLASS PseudoElementRuleProcessorData :
121909:                           public ElementDependentRuleProcessorData {
 35555:   PseudoElementRuleProcessorData(nsPresContext* aPresContext,
 41644:                                  mozilla::dom::Element* aParentElement,
 35555:                                  nsRuleWalker* aRuleWalker,
 64157:                                  nsCSSPseudoElements::Type aPseudoType,
 64157:                                  TreeMatchContext& aTreeMatchContext)
121909:     : ElementDependentRuleProcessorData(aPresContext, aParentElement, aRuleWalker,
 64157:                                         aTreeMatchContext),
 35555:       mPseudoType(aPseudoType)
 35555:   {
 35555:     NS_PRECONDITION(aPseudoType <
 35555:                       nsCSSPseudoElements::ePseudo_PseudoElementCount,
121909:                     "invalid aPseudoType value");
 64157:     NS_PRECONDITION(aTreeMatchContext.mForStyling, "Styling here!");
121909:     NS_PRECONDITION(aRuleWalker, "Must have rule walker");
 35555:   }
 35555: 
 35555:   nsCSSPseudoElements::Type mPseudoType;
 35555: };
 35555: 
121909: struct NS_STACK_CLASS AnonBoxRuleProcessorData : public RuleProcessorData {
 35556:   AnonBoxRuleProcessorData(nsPresContext* aPresContext,
 35556:                            nsIAtom* aPseudoTag,
 35556:                            nsRuleWalker* aRuleWalker)
121909:     : RuleProcessorData(aPresContext, aRuleWalker),
121909:       mPseudoTag(aPseudoTag)
 35556:   {
 35556:     NS_PRECONDITION(aPseudoTag, "Must have pseudo tag");
 35556:     NS_PRECONDITION(aRuleWalker, "Must have rule walker");
 35556:   }
 35556: 
 35556:   nsIAtom* mPseudoTag;
 35556: };
 35556: 
 35558: #ifdef MOZ_XUL
121909: struct NS_STACK_CLASS XULTreeRuleProcessorData :
121909:                           public ElementDependentRuleProcessorData {
 35558:   XULTreeRuleProcessorData(nsPresContext* aPresContext,
 41644:                            mozilla::dom::Element* aParentElement,
 35558:                            nsRuleWalker* aRuleWalker,
 35540:                            nsIAtom* aPseudoTag,
 64157:                            nsICSSPseudoComparator* aComparator,
 64157:                            TreeMatchContext& aTreeMatchContext)
121909:     : ElementDependentRuleProcessorData(aPresContext, aParentElement,
121909:                                         aRuleWalker, aTreeMatchContext),
 35558:       mPseudoTag(aPseudoTag),
 35558:       mComparator(aComparator)
     1:   {
     1:     NS_PRECONDITION(aPseudoTag, "null pointer");
121909:     NS_PRECONDITION(aRuleWalker, "Must have rule walker");
 35558:     NS_PRECONDITION(aComparator, "must have a comparator");
 64157:     NS_PRECONDITION(aTreeMatchContext.mForStyling, "Styling here!");
     1:   }
     1: 
     1:   nsIAtom*                 mPseudoTag;
     1:   nsICSSPseudoComparator*  mComparator;
     1: };
 35558: #endif
     1: 
121909: struct NS_STACK_CLASS StateRuleProcessorData :
121909:                           public ElementDependentRuleProcessorData {
     1:   StateRuleProcessorData(nsPresContext* aPresContext,
 41644:                          mozilla::dom::Element* aElement,
 64157:                          nsEventStates aStateMask,
 64157:                          TreeMatchContext& aTreeMatchContext)
121909:     : ElementDependentRuleProcessorData(aPresContext, aElement, nullptr,
121909:                                         aTreeMatchContext),
     1:       mStateMask(aStateMask)
     1:   {
 64157:     NS_PRECONDITION(!aTreeMatchContext.mForStyling, "Not styling here!");
     1:   }
 56168:   const nsEventStates mStateMask; // |HasStateDependentStyle| for which state(s)?
 56168:                                   //  Constants defined in nsEventStates.h .
     1: };
     1: 
121909: struct NS_STACK_CLASS AttributeRuleProcessorData :
121909:                           public ElementDependentRuleProcessorData {
     1:   AttributeRuleProcessorData(nsPresContext* aPresContext,
 41644:                              mozilla::dom::Element* aElement,
     1:                              nsIAtom* aAttribute,
108991:                              int32_t aModType,
 79445:                              bool aAttrHasChanged,
 64157:                              TreeMatchContext& aTreeMatchContext)
121909:     : ElementDependentRuleProcessorData(aPresContext, aElement, nullptr,
121909:                                         aTreeMatchContext),
     1:       mAttribute(aAttribute),
  3410:       mModType(aModType),
 35534:       mAttrHasChanged(aAttrHasChanged)
     1:   {
 64157:     NS_PRECONDITION(!aTreeMatchContext.mForStyling, "Not styling here!");
     1:   }
  4036:   nsIAtom* mAttribute; // |HasAttributeDependentStyle| for which attribute?
108991:   int32_t mModType;    // The type of modification (see nsIDOMMutationEvent).
 79445:   bool mAttrHasChanged; // Whether the attribute has already changed.
     1: };
     1: 
 30988: #endif /* !defined(nsRuleProcessorData_h_) */
