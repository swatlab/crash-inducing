48470: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
48470:  * vim: set ts=8 sw=4 et tw=99 ft=cpp:
48470:  *
48470:  * ***** BEGIN LICENSE BLOCK *****
48470:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
48470:  *
48470:  * The contents of this file are subject to the Mozilla Public License Version
48470:  * 1.1 (the "License"); you may not use this file except in compliance with
48470:  * the License. You may obtain a copy of the License at
48470:  * http://www.mozilla.org/MPL/
48470:  *
48470:  * Software distributed under the License is distributed on an "AS IS" basis,
48470:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
48470:  * for the specific language governing rights and limitations under the
48470:  * License.
48470:  *
48470:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
48470:  * June 30, 2010
48470:  *
48470:  * The Initial Developer of the Original Code is
48470:  *   the Mozilla Corporation.
48470:  *
48470:  * Contributor(s):
48470:  *   Luke Wagner <lw@mozilla.com>
48470:  *
48470:  * Alternatively, the contents of this file may be used under the terms of
48470:  * either of the GNU General Public License Version 2 or later (the "GPL"),
48470:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
48470:  * in which case the provisions of the GPL or the LGPL are applicable instead
48470:  * of those above. If you wish to allow use of your version of this file only
48470:  * under the terms of either the GPL or the LGPL, and not to allow others to
48470:  * use your version of this file under the terms of the MPL, indicate your
48470:  * decision by deleting the provisions above and replace them with the notice
48470:  * and other provisions required by the GPL or the LGPL. If you do not delete
48470:  * the provisions above, a recipient may use your version of this file under
48470:  * the terms of any one of the MPL, the GPL or the LGPL.
48470:  *
48470:  * ***** END LICENSE BLOCK ***** */
48470: 
48470: #ifndef jsvalimpl_h__
48470: #define jsvalimpl_h__
48470: /*
48470:  * JS value implementation details for operations on jsval and jsid.
48470:  * Embeddings should not rely on any of the definitions in this file. For a
48470:  * description of the value representation and the engine-internal C++ value
48470:  * interface, js::Value, see jsvalue.h.
48470:  */
48470: #include "jsutil.h"
48470: 
48470: JS_BEGIN_EXTERN_C
48470: 
48470: /*
48470:  * Try to get jsvals 64-bit aligned. We could almost assert that all values are
48470:  * aligned, but MSVC and GCC occasionally break alignment.
48470:  */
48470: #ifdef __GNUC__
48470: # define JSVAL_ALIGNMENT        __attribute__((aligned (8)))
48470: #elif defined(_MSC_VER)
48470:   /*
48470:    * Structs can be aligned with MSVC, but not if they are used as parameters,
48470:    * so we just don't try to align.
48470:    */
48470: # define JSVAL_ALIGNMENT
48470: #elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
48470: # define JSVAL_ALIGNMENT
48470: #endif
48470: 
48470: /*
48470:  * We try to use enums so that printing a jsval_layout in the debugger shows
48470:  * nice symbolic type tags, however we can only do this when we can force the
48470:  * underlying type of the enum to be the desired size.
48470:  */
48470: #ifdef __cplusplus
48470: 
48470: #if defined(_MSC_VER)
48470: # define JS_ENUM_HEADER(id, type)              enum id : type
48470: # define JS_ENUM_MEMBER(id, type, value)       id = (type)value,
48470: # define JS_LAST_ENUM_MEMBER(id, type, value)  id = (type)value
48470: # define JS_ENUM_FOOTER(id)
48470: #else
48470: # define JS_ENUM_HEADER(id, type)              enum id
48470: # define JS_ENUM_MEMBER(id, type, value)       id = (type)value,
48470: # define JS_LAST_ENUM_MEMBER(id, type, value)  id = (type)value
48470: # define JS_ENUM_FOOTER(id)                    __attribute__((packed))
48470: #endif
48470: 
48470: /* Remember to propagate changes to the C defines below. */
48470: JS_ENUM_HEADER(JSValueType, uint8)
48470: {
48470:     JSVAL_TYPE_DOUBLE              = 0x00,
48470:     JSVAL_TYPE_INT32               = 0x01,
48470:     JSVAL_TYPE_UNDEFINED           = 0x02,
48470:     JSVAL_TYPE_BOOLEAN             = 0x03,
48470:     JSVAL_TYPE_MAGIC               = 0x04,
48470:     JSVAL_TYPE_STRING              = 0x05,
48470:     JSVAL_TYPE_NULL                = 0x06,
48470:     JSVAL_TYPE_OBJECT              = 0x07,
48470: 
48470:     /* The below types never appear in a jsval; they are only used in tracing. */
48470: 
48470:     JSVAL_TYPE_NONFUNOBJ           = 0x57,
48470:     JSVAL_TYPE_FUNOBJ              = 0x67,
48470: 
48470:     JSVAL_TYPE_STRORNULL           = 0x97,
48470:     JSVAL_TYPE_OBJORNULL           = 0x98,
48470: 
48470:     JSVAL_TYPE_BOXED               = 0x99,
48470:     JSVAL_TYPE_UNINITIALIZED       = 0xcd
48470: } JS_ENUM_FOOTER(JSValueType);
48470: 
48488: JS_STATIC_ASSERT(sizeof(JSValueType) == 1);
48488: 
48470: #if JS_BITS_PER_WORD == 32
48470: 
48470: /* Remember to propagate changes to the C defines below. */
48470: JS_ENUM_HEADER(JSValueTag, uint32)
48470: {
48470:     JSVAL_TAG_CLEAR                = 0xFFFF0000,
48470:     JSVAL_TAG_INT32                = JSVAL_TAG_CLEAR | JSVAL_TYPE_INT32,
48470:     JSVAL_TAG_UNDEFINED            = JSVAL_TAG_CLEAR | JSVAL_TYPE_UNDEFINED,
48470:     JSVAL_TAG_STRING               = JSVAL_TAG_CLEAR | JSVAL_TYPE_STRING,
48470:     JSVAL_TAG_BOOLEAN              = JSVAL_TAG_CLEAR | JSVAL_TYPE_BOOLEAN,
48470:     JSVAL_TAG_MAGIC                = JSVAL_TAG_CLEAR | JSVAL_TYPE_MAGIC,
48470:     JSVAL_TAG_NULL                 = JSVAL_TAG_CLEAR | JSVAL_TYPE_NULL,
48470:     JSVAL_TAG_OBJECT               = JSVAL_TAG_CLEAR | JSVAL_TYPE_OBJECT
48470: } JS_ENUM_FOOTER(JSValueType);
48470: 
48488: JS_STATIC_ASSERT(sizeof(JSValueTag) == 4);
48488: 
48470: #elif JS_BITS_PER_WORD == 64
48470: 
48470: /* Remember to propagate changes to the C defines below. */
48470: JS_ENUM_HEADER(JSValueTag, uint32)
48470: {
48470:     JSVAL_TAG_MAX_DOUBLE           = 0x1FFF0,
48470:     JSVAL_TAG_INT32                = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_INT32,
48470:     JSVAL_TAG_UNDEFINED            = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_UNDEFINED,
48470:     JSVAL_TAG_STRING               = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_STRING,
48470:     JSVAL_TAG_BOOLEAN              = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_BOOLEAN,
48470:     JSVAL_TAG_MAGIC                = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_MAGIC,
48470:     JSVAL_TAG_NULL                 = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_NULL,
48470:     JSVAL_TAG_OBJECT               = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_OBJECT
48470: } JS_ENUM_FOOTER(JSValueType);
48470: 
48488: JS_STATIC_ASSERT(sizeof(JSValueTag) == 4);
48488: 
48470: #endif
48470: 
48470: #else  /* defined(__cplusplus) */
48470: 
48470: typedef uint8 JSValueType;
48470: #define JSVAL_TYPE_DOUBLE            ((uint8)0x00)
48470: #define JSVAL_TYPE_INT32             ((uint8)0x01)
48470: #define JSVAL_TYPE_UNDEFINED         ((uint8)0x02)
48470: #define JSVAL_TYPE_BOOLEAN           ((uint8)0x03)
48470: #define JSVAL_TYPE_MAGIC             ((uint8)0x04)
48470: #define JSVAL_TYPE_STRING            ((uint8)0x05)
48470: #define JSVAL_TYPE_NULL              ((uint8)0x06)
48470: #define JSVAL_TYPE_OBJECT            ((uint8)0x07)
48470: #define JSVAL_TYPE_NONFUNOBJ         ((uint8)0x57)
48470: #define JSVAL_TYPE_FUNOBJ            ((uint8)0x67)
48470: #define JSVAL_TYPE_STRORNULL         ((uint8)0x97)
48470: #define JSVAL_TYPE_OBJORNULL         ((uint8)0x98)
48470: #define JSVAL_TYPE_STRORNULL         ((uint8)0x97)
48470: #define JSVAL_TYPE_OBJORNULL         ((uint8)0x98)
48470: #define JSVAL_TYPE_BOXED             ((uint8)0x99)
48470: #define JSVAL_TYPE_UNINITIALIZED     ((uint8)0xcd)
48470: 
48470: #if JS_BITS_PER_WORD == 32
48470: 
48470: typedef uint32 JSValueTag;
48470: #define JSVAL_TAG_CLEAR              ((uint32)(0xFFFF0000))
48470: #define JSVAL_TAG_INT32              ((uint32)(JSVAL_TAG_CLEAR | JSVAL_TYPE_INT32))
48470: #define JSVAL_TAG_UNDEFINED          ((uint32)(JSVAL_TAG_CLEAR | JSVAL_TYPE_UNDEFINED))
48470: #define JSVAL_TAG_STRING             ((uint32)(JSVAL_TAG_CLEAR | JSVAL_TYPE_STRING))
48470: #define JSVAL_TAG_BOOLEAN            ((uint32)(JSVAL_TAG_CLEAR | JSVAL_TYPE_BOOLEAN))
48470: #define JSVAL_TAG_MAGIC              ((uint32)(JSVAL_TAG_CLEAR | JSVAL_TYPE_MAGIC))
48470: #define JSVAL_TAG_NULL               ((uint32)(JSVAL_TAG_CLEAR | JSVAL_TYPE_NULL))
48470: #define JSVAL_TAG_OBJECT             ((uint32)(JSVAL_TAG_CLEAR | JSVAL_TYPE_OBJECT))
48470: 
48470: #elif JS_BITS_PER_WORD == 64
48470: 
48470: typedef uint32 JSValueTag;
48470: #define JSVAL_TAG_MAX_DOUBLE         ((uint32)(0x1FFF0))
48470: #define JSVAL_TAG_INT32              (uint32)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_INT32)
48470: #define JSVAL_TAG_UNDEFINED          (uint32)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_UNDEFINED)
48470: #define JSVAL_TAG_STRING             (uint32)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_STRING)
48470: #define JSVAL_TAG_BOOLEAN            (uint32)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_BOOLEAN)
48470: #define JSVAL_TAG_MAGIC              (uint32)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_MAGIC)
48470: #define JSVAL_TAG_NULL               (uint32)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_NULL)
48470: #define JSVAL_TAG_OBJECT             (uint32)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_OBJECT)
48470: 
48470: #endif  /* JS_BITS_PER_WORD */
48470: #endif  /* defined(__cplusplus) */
48470: 
48470: #define JSVAL_LOWER_INCL_TYPE_OF_OBJ_OR_NULL_SET        JSVAL_TYPE_NULL
48470: #define JSVAL_UPPER_EXCL_TYPE_OF_PRIMITIVE_SET          JSVAL_TYPE_OBJECT
48470: #define JSVAL_UPPER_INCL_TYPE_OF_NUMBER_SET             JSVAL_TYPE_INT32
48470: #define JSVAL_LOWER_INCL_TYPE_OF_GCTHING_SET            JSVAL_TYPE_STRING
48470: #define JSVAL_UPPER_INCL_TYPE_OF_VALUE_SET              JSVAL_TYPE_OBJECT
48470: #define JSVAL_UPPER_INCL_TYPE_OF_BOXABLE_SET            JSVAL_TYPE_FUNOBJ
48470: 
48470: #if JS_BITS_PER_WORD == 32
48470: 
48470: #define JSVAL_TYPE_TO_TAG(type)      ((JSValueTag)(JSVAL_TAG_CLEAR | (type)))
48470: 
48470: #define JSVAL_LOWER_INCL_TAG_OF_OBJ_OR_NULL_SET         JSVAL_TAG_NULL
48470: #define JSVAL_UPPER_EXCL_TAG_OF_PRIMITIVE_SET           JSVAL_TAG_OBJECT
48470: #define JSVAL_UPPER_INCL_TAG_OF_NUMBER_SET              JSVAL_TAG_INT32
48470: #define JSVAL_LOWER_INCL_TAG_OF_GCTHING_SET             JSVAL_TAG_STRING
48470: 
48470: #elif JS_BITS_PER_WORD == 64
48470: 
48470: #define JSVAL_TAG_SHIFT              47
48470: #define JSVAL_PAYLOAD_MASK           0x00007FFFFFFFFFFFLL
48470: #define JSVAL_TYPE_TO_TAG(type)      ((JSValueTag)(JSVAL_TAG_MAX_DOUBLE | (type)))
48470: #define JSVAL_TYPE_TO_SHIFTED_TAG(type) (((uint64)JSVAL_TYPE_TO_TAG(type)) << JSVAL_TAG_SHIFT)
48470: 
48470: #define JSVAL_SHIFTED_TAG_MAX_DOUBLE (((uint64)JSVAL_TAG_MAX_DOUBLE) << JSVAL_TAG_SHIFT)
48470: #define JSVAL_SHIFTED_TAG_INT32      (((uint64)JSVAL_TAG_INT32)      << JSVAL_TAG_SHIFT)
48470: #define JSVAL_SHIFTED_TAG_UNDEFINED  (((uint64)JSVAL_TAG_UNDEFINED)  << JSVAL_TAG_SHIFT)
48470: #define JSVAL_SHIFTED_TAG_STRING     (((uint64)JSVAL_TAG_STRING)     << JSVAL_TAG_SHIFT)
48470: #define JSVAL_SHIFTED_TAG_BOOLEAN    (((uint64)JSVAL_TAG_BOOLEAN)    << JSVAL_TAG_SHIFT)
48470: #define JSVAL_SHIFTED_TAG_MAGIC      (((uint64)JSVAL_TAG_MAGIC)      << JSVAL_TAG_SHIFT)
48470: #define JSVAL_SHIFTED_TAG_NULL       (((uint64)JSVAL_TAG_NULL)       << JSVAL_TAG_SHIFT)
48470: #define JSVAL_SHIFTED_TAG_OBJECT     (((uint64)JSVAL_TAG_OBJECT)     << JSVAL_TAG_SHIFT)
48470: 
48470: #define JSVAL_LOWER_INCL_SHIFTED_TAG_OF_OBJ_OR_NULL_SET  JSVAL_SHIFTED_TAG_NULL
48470: #define JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_PRIMITIVE_SET    JSVAL_SHIFTED_TAG_OBJECT
48470: #define JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_NUMBER_SET       JSVAL_SHIFTED_TAG_UNDEFINED
48470: #define JSVAL_LOWER_INCL_SHIFTED_TAG_OF_GCTHING_SET      JSVAL_SHIFTED_TAG_STRING
48470: 
48470: #endif /* JS_BITS_PER_WORD */
48470: 
48470: typedef enum JSWhyMagic
48470: {
48470:     JS_ARRAY_HOLE,               /* a hole in a dense array */
48470:     JS_ARGS_HOLE,                /* a hole in the args object's array */
48470:     JS_NATIVE_ENUMERATE,         /* indicates that a custom enumerate hook forwarded
48470:                                   * to js_Enumerate, which really means the object can be
48470:                                   * enumerated like a native object. */
48470:     JS_NO_ITER_VALUE,            /* there is not a pending iterator value */
48470:     JS_GENERATOR_CLOSING,        /* exception value thrown when closing a generator */
48470:     JS_NO_CONSTANT,              /* compiler sentinel value */
48470:     JS_THIS_POISON,              /* used in debug builds to catch tracing errors */
48470:     JS_GENERIC_MAGIC             /* for local use */
48470: } JSWhyMagic;
48470: 
48470: typedef struct JSString JSString;
48470: typedef struct JSObject JSObject;
48470: 
48470: #if defined(IS_LITTLE_ENDIAN)
48470: # if JS_BITS_PER_WORD == 32
48470: typedef union jsval_layout
48470: {
48470:     uint64 asBits;
48470:     struct {
48470:         union {
48470:             int32          i32;
48470:             uint32         u32;
48470:             JSBool         boo;
48470:             JSString       *str;
48470:             JSObject       *obj;
48470:             void           *ptr;
48470:             JSWhyMagic     why;
48470:         } payload;
48470:         JSValueTag tag;
48470:     } s;
48470:     double asDouble;
48470: } jsval_layout;
48470: # elif JS_BITS_PER_WORD == 64
48470: typedef union jsval_layout
48470: {
48470:     uint64 asBits;
48470:     struct {
48470:         uint64             payload47 : 47;
48470:         JSValueTag         tag : 17;
48470:     } debugView;
48470:     struct {
48470:         union {
48470:             int32          i32;
48470:             uint32         u32;
48470:             JSWhyMagic     why;
48470:         } payload;
48470:     } s;
48470:     double asDouble;
48470: } jsval_layout;
48470: # endif  /* JS_BITS_PER_WORD */
48470: #else   /* defined(IS_LITTLE_ENDIAN) */
48470: # if JS_BITS_PER_WORD == 32
48470: typedef union jsval_layout
48470: {
48470:     uint64 asBits;
48470:     struct {
48470:         JSValueTag tag;
48470:         union {
48470:             int32          i32;
48470:             uint32         u32;
48470:             JSBool         boo;
48470:             JSString       *str;
48470:             JSObject       *obj;
48470:             void           *ptr;
48470:             JSWhyMagic     why;
48470:         } payload;
48470:     } s;
48470:     double asDouble;
48470: } jsval_layout;
48470: # endif /* JS_BITS_PER_WORD */
48470: #endif  /* defined(IS_LITTLE_ENDIAN) */
48470: 
48470: #if JS_BITS_PER_WORD == 32
48470: 
48488: /*
48488:  * N.B. GCC, in some but not all cases, chooses to emit signed comparison of
48488:  * JSValueTag even though its underlying type has been forced to be uint32.
48488:  * Thus, all comparisons should explicitly cast operands to uint32.
48488:  */
48488: 
48470: #define BUILD_JSVAL(tag, payload) \
48470:     ((((uint64)(uint32)(tag)) << 32) | (uint32)(payload))
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_DOUBLE_IMPL(jsval_layout l)
48470: {
48488:     return (uint32)l.s.tag < (uint32)JSVAL_TAG_CLEAR;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: DOUBLE_TO_JSVAL_IMPL(double d)
48470: {
48470:     jsval_layout l;
48470:     l.asDouble = d;
48488:     JS_ASSERT(JSVAL_IS_DOUBLE_IMPL(l));
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_INT32_IMPL(jsval_layout l)
48470: {
48470:     return l.s.tag == JSVAL_TAG_INT32;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE int32
48470: JSVAL_TO_INT32_IMPL(jsval_layout l)
48470: {
48470:     return l.s.payload.i32;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: INT32_TO_JSVAL_IMPL(int32 i)
48470: {
48470:     jsval_layout l;
48470:     l.s.tag = JSVAL_TAG_INT32;
48470:     l.s.payload.i32 = i;
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_NUMBER_IMPL(jsval_layout l)
48470: {
48470:     JSValueTag tag = l.s.tag;
48470:     JS_ASSERT(tag != JSVAL_TAG_CLEAR);
48488:     return (uint32)tag <= (uint32)JSVAL_UPPER_INCL_TAG_OF_NUMBER_SET;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_UNDEFINED_IMPL(jsval_layout l)
48470: {
48470:     return l.s.tag == JSVAL_TAG_UNDEFINED;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_STRING_IMPL(jsval_layout l)
48470: {
48470:     return l.s.tag == JSVAL_TAG_STRING;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: STRING_TO_JSVAL_IMPL(JSString *str)
48470: {
48470:     jsval_layout l;
48470:     l.s.tag = JSVAL_TAG_STRING;
48470:     l.s.payload.str = str;
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSString *
48470: JSVAL_TO_STRING_IMPL(jsval_layout l)
48470: {
48470:     return l.s.payload.str;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_BOOLEAN_IMPL(jsval_layout l)
48470: {
48470:     return l.s.tag == JSVAL_TAG_BOOLEAN;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_TO_BOOLEAN_IMPL(jsval_layout l)
48470: {
48470:     return l.s.payload.boo;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: BOOLEAN_TO_JSVAL_IMPL(JSBool b)
48470: {
48470:     jsval_layout l;
48470:     l.s.tag = JSVAL_TAG_BOOLEAN;
48470:     l.s.payload.boo = b;
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_OBJECT_IMPL(jsval_layout l)
48470: {
48470:     return l.s.tag == JSVAL_TAG_OBJECT;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_PRIMITIVE_IMPL(jsval_layout l)
48470: {
48488:     return (uint32)l.s.tag < (uint32)JSVAL_UPPER_EXCL_TAG_OF_PRIMITIVE_SET;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_OBJECT_OR_NULL_IMPL(jsval_layout l)
48470: {
48488:     JS_ASSERT((uint32)l.s.tag <= (uint32)JSVAL_TAG_OBJECT);
48488:     return (uint32)l.s.tag >= (uint32)JSVAL_LOWER_INCL_TAG_OF_OBJ_OR_NULL_SET;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSObject *
48470: JSVAL_TO_OBJECT_IMPL(jsval_layout l)
48470: {
48470:     return l.s.payload.obj;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: OBJECT_TO_JSVAL_IMPL(JSObject *obj)
48470: {
48470:     jsval_layout l;
48470:     l.s.tag = JSVAL_TAG_OBJECT;
48470:     l.s.payload.obj = obj;
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_NULL_IMPL(jsval_layout l)
48470: {
48470:     return l.s.tag == JSVAL_TAG_NULL;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: PRIVATE_PTR_TO_JSVAL_IMPL(void *ptr)
48470: {
48470:     jsval_layout l;
48470:     JS_ASSERT(((uint32)ptr & 1) == 0);
48470:     l.s.tag = (JSValueTag)0;
48470:     l.s.payload.ptr = ptr;
48470:     JS_ASSERT(JSVAL_IS_DOUBLE_IMPL(l));
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE void *
48470: JSVAL_TO_PRIVATE_PTR_IMPL(jsval_layout l)
48470: {
48470:     return l.s.payload.ptr;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_GCTHING_IMPL(jsval_layout l)
48470: {
48488:     /* gcc sometimes generates signed < without explicit casts. */
48488:     return (uint32)l.s.tag >= (uint32)JSVAL_LOWER_INCL_TAG_OF_GCTHING_SET;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE void *
48470: JSVAL_TO_GCTHING_IMPL(jsval_layout l)
48470: {
48470:     return l.s.payload.ptr;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_TRACEABLE_IMPL(jsval_layout l)
48470: {
48470:     return l.s.tag == JSVAL_TAG_STRING || l.s.tag == JSVAL_TAG_OBJECT;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE uint32
48470: JSVAL_TRACE_KIND_IMPL(jsval_layout l)
48470: {
48470:     return (uint32)(JSBool)JSVAL_IS_STRING_IMPL(l);
48470: }
48470: 
48470: #elif JS_BITS_PER_WORD == 64
48470: 
48470: #define BUILD_JSVAL(tag, payload) \
48470:     ((((uint64)(uint32)(tag)) << JSVAL_TAG_SHIFT) | (payload))
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_DOUBLE_IMPL(jsval_layout l)
48470: {
48470:     return l.asBits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: DOUBLE_TO_JSVAL_IMPL(double d)
48470: {
48470:     jsval_layout l;
48470:     l.asDouble = d;
48470:     JS_ASSERT(l.asBits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE);
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_INT32_IMPL(jsval_layout l)
48470: {
48470:     return (uint32)(l.asBits >> JSVAL_TAG_SHIFT) == JSVAL_TAG_INT32;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE int32
48470: JSVAL_TO_INT32_IMPL(jsval_layout l)
48470: {
48470:     return (int32)l.asBits;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: INT32_TO_JSVAL_IMPL(int32 i32)
48470: {
48470:     jsval_layout l;
48470:     l.asBits = ((uint64)(uint32)i32) | JSVAL_SHIFTED_TAG_INT32;
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_NUMBER_IMPL(jsval_layout l)
48470: {
48470:     return l.asBits < JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_NUMBER_SET;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_UNDEFINED_IMPL(jsval_layout l)
48470: {
48470:     return l.asBits == JSVAL_SHIFTED_TAG_UNDEFINED;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_STRING_IMPL(jsval_layout l)
48470: {
48470:     return (uint32)(l.asBits >> JSVAL_TAG_SHIFT) == JSVAL_TAG_STRING;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: STRING_TO_JSVAL_IMPL(JSString *str)
48470: {
48470:     jsval_layout l;
48470:     uint64 strBits = (uint64)str;
48470:     JS_ASSERT((strBits >> JSVAL_TAG_SHIFT) == 0);
48470:     l.asBits = strBits | JSVAL_SHIFTED_TAG_STRING;
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSString *
48470: JSVAL_TO_STRING_IMPL(jsval_layout l)
48470: {
48470:     return (JSString *)(l.asBits & JSVAL_PAYLOAD_MASK);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_BOOLEAN_IMPL(jsval_layout l)
48470: {
48470:     return (uint32)(l.asBits >> JSVAL_TAG_SHIFT) == JSVAL_TAG_BOOLEAN;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_TO_BOOLEAN_IMPL(jsval_layout l)
48470: {
48470:     return (JSBool)l.asBits;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: BOOLEAN_TO_JSVAL_IMPL(JSBool b)
48470: {
48470:     jsval_layout l;
48470:     l.asBits = ((uint64)(uint32)b) | JSVAL_SHIFTED_TAG_BOOLEAN;
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_PRIMITIVE_IMPL(jsval_layout l)
48470: {
48470:     return l.asBits < JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_PRIMITIVE_SET;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_OBJECT_IMPL(jsval_layout l)
48470: {
48470:     JS_ASSERT((l.asBits >> JSVAL_TAG_SHIFT) <= JSVAL_SHIFTED_TAG_OBJECT);
48470:     return l.asBits >= JSVAL_SHIFTED_TAG_OBJECT;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_OBJECT_OR_NULL_IMPL(jsval_layout l)
48470: {
48470:     JS_ASSERT((l.asBits >> JSVAL_TAG_SHIFT) <= JSVAL_TAG_OBJECT);
48470:     return l.asBits >= JSVAL_LOWER_INCL_SHIFTED_TAG_OF_OBJ_OR_NULL_SET;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSObject *
48470: JSVAL_TO_OBJECT_IMPL(jsval_layout l)
48470: {
48470:     uint64 ptrBits = l.asBits & JSVAL_PAYLOAD_MASK;
48470:     JS_ASSERT((ptrBits & 0x7) == 0);
48470:     return (JSObject *)ptrBits;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: OBJECT_TO_JSVAL_IMPL(JSObject *obj)
48470: {
48470:     jsval_layout l;
48470:     uint64 objBits = (uint64)obj;
48470:     JS_ASSERT((objBits >> JSVAL_TAG_SHIFT) == 0);
48470:     l.asBits = objBits | JSVAL_SHIFTED_TAG_OBJECT;
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_NULL_IMPL(jsval_layout l)
48470: {
48470:     return l.asBits == JSVAL_SHIFTED_TAG_NULL;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_GCTHING_IMPL(jsval_layout l)
48470: {
48470:     return l.asBits >= JSVAL_LOWER_INCL_SHIFTED_TAG_OF_GCTHING_SET;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE void *
48470: JSVAL_TO_GCTHING_IMPL(jsval_layout l)
48470: {
48470:     uint64 ptrBits = l.asBits & JSVAL_PAYLOAD_MASK;
48470:     JS_ASSERT((ptrBits & 0x7) == 0);
48470:     return (void *)ptrBits;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_TRACEABLE_IMPL(jsval_layout l)
48470: {
48470:     return JSVAL_IS_GCTHING_IMPL(l) && !JSVAL_IS_NULL_IMPL(l);
48470: }
48470: 
48470: static JS_ALWAYS_INLINE uint32
48470: JSVAL_TRACE_KIND_IMPL(jsval_layout l)
48470: {
48470:     return (uint32)(JSBool)!(JSVAL_IS_OBJECT_IMPL(l));
48470: }
48470: 
48470: static JS_ALWAYS_INLINE jsval_layout
48470: PRIVATE_PTR_TO_JSVAL_IMPL(void *ptr)
48470: {
48470:     jsval_layout l;
48470:     uint64 ptrBits = (uint64)ptr;
48470:     JS_ASSERT((ptrBits & 1) == 0);
48470:     l.asBits = ptrBits >> 1;
48470:     JS_ASSERT(JSVAL_IS_DOUBLE_IMPL(l));
48470:     return l;
48470: }
48470: 
48470: static JS_ALWAYS_INLINE void *
48470: JSVAL_TO_PRIVATE_PTR_IMPL(jsval_layout l)
48470: {
48470:     JS_ASSERT((l.asBits & 0x8000000000000000LL) == 0);
48470:     return (void *)(l.asBits << 1);
48470: }
48470: 
48470: #endif
48470: 
48470: static JS_ALWAYS_INLINE JSBool
48470: JSVAL_IS_UNDERLYING_TYPE_OF_PRIVATE_IMPL(jsval_layout l)
48470: {
48470:     return JSVAL_IS_DOUBLE_IMPL(l);
48470: }
48470: 
48470: /* See JS_USE_JSVAL_JSID_STRUCT_TYPES comment in jsapi.h. */
48470: #if defined(DEBUG) && !defined(JS_NO_JSVAL_JSID_STRUCT_TYPES)
48470: # define JS_USE_JSVAL_JSID_STRUCT_TYPES
48470: #endif
48470: 
48470: #ifdef JS_USE_JSVAL_JSID_STRUCT_TYPES
48470: 
48470: typedef JSVAL_ALIGNMENT jsval_layout   jsval;
48470: typedef struct jsid { size_t asBits; } jsid;
48470: 
48470: #if defined(__cplusplus)
48470: extern "C++"
48470: {
48470:     static JS_ALWAYS_INLINE bool
48470:     operator==(jsid lhs, jsid rhs)
48470:     {
48470:         return lhs.asBits == rhs.asBits;
48470:     }
48470: 
48470:     static JS_ALWAYS_INLINE bool
48470:     operator!=(jsid lhs, jsid rhs)
48470:     {
48470:         return lhs.asBits != rhs.asBits;
48470:     }
48470: 
48470:     static JS_ALWAYS_INLINE bool
48470:     operator==(jsval lhs, jsval rhs)
48470:     {
48470:         return lhs.asBits == rhs.asBits;
48470:     }
48470: 
48470:     static JS_ALWAYS_INLINE bool
48470:     operator!=(jsval lhs, jsval rhs)
48470:     {
48470:         return lhs.asBits != rhs.asBits;
48470:     }
48470: }
48470: # endif /* defined(__cplusplus) */
48470: 
48470: /* Internal helper macros */
48470: #define JSVAL_BITS(v)    (v.asBits)
48470: #define IMPL_TO_JSVAL(v) (v)
48470: #define JSID_BITS(id)    (id.asBits)
48470: 
48470: #else /* defined(JS_USE_JSVAL_JSID_STRUCT_TYPES) */
48470: 
48470: /* Use different primitive types so overloading works. */
48470: typedef JSVAL_ALIGNMENT uint64 jsval;
48470: typedef ptrdiff_t              jsid;
48470: 
48470: /* Internal helper macros */
48470: #define JSVAL_BITS(v)    (v)
48470: #define IMPL_TO_JSVAL(v) ((v).asBits)
48470: #define JSID_BITS(id)    (id)
48470: 
48470: #endif /* defined(JS_USE_JSVAL_JSID_STRUCT_TYPES) */
48470: 
48470: JS_END_EXTERN_C
48470: 
48470: #endif /* jsvalimpl_h__ */
