    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   IBM Corp.
    1:  *   Henry Sobotka
    1:  *   Benjamin Smedberg <benjamin@smedbergs.us>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsDebugImpl.h"
    1: #include "nsDebug.h"
61749: #ifdef MOZ_CRASHREPORTER
61749: # include "nsExceptionHandler.h"
61749: #endif
61749: #include "nsStringGlue.h"
    1: #include "prprf.h"
    1: #include "prlog.h"
    1: #include "prinit.h"
    1: #include "plstr.h"
    1: #include "nsError.h"
    1: #include "prerror.h"
    1: #include "prerr.h"
    1: #include "prenv.h"
23485: #include "pratom.h"
    1: 
42994: #ifdef ANDROID
42994: #include <android/log.h>
42994: #endif
42994: 
    1: #if defined(XP_BEOS)
    1: /* For DEBUGGER macros */
    1: #include <Debug.h>
    1: #endif
    1: 
    1: #if defined(XP_UNIX) || defined(_WIN32) || defined(XP_OS2) || defined(XP_BEOS)
    1: /* for abort() and getenv() */
    1: #include <stdlib.h>
    1: #endif
    1: 
    1: #include "nsTraceRefcntImpl.h"
    1: #include "nsISupportsUtils.h"
    1: 
    1: #if defined(XP_UNIX)
    1: #include <signal.h>
    1: #endif
    1: 
22235: #if defined(XP_WIN)
22235: #include <tchar.h>
22235: #include "nsString.h"
22235: #endif
22235: 
42433: #include "mozilla/mozalloc_abort.h"
42433: 
    1: static void
    1: Abort(const char *aMsg);
    1: 
    1: static void
36077: RealBreak();
36077: 
36077: static void
    1: Break(const char *aMsg);
    1: 
    1: #if defined(XP_OS2)
    1: #  define INCL_WINDIALOGS  // need for WinMessageBox
    1: #  include <os2.h>
    1: #  include <string.h>
    1: #endif /* XP_OS2 */
    1: 
    1: #if defined(_WIN32)
    1: #include <windows.h>
    1: #include <signal.h>
    1: #include <malloc.h> // for _alloca
    1: #elif defined(XP_UNIX)
    1: #include <stdlib.h>
    1: #endif
    1: 
23485: static PRInt32 gAssertionCount = 0;
23485: 
23485: NS_IMPL_QUERY_INTERFACE2(nsDebugImpl, nsIDebug, nsIDebug2)
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsDebugImpl::AddRef()
    1: {
    1:   return 2;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsDebugImpl::Release()
    1: {
    1:   return 1;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDebugImpl::Assertion(const char *aStr, const char *aExpr,
    1:                        const char *aFile, PRInt32 aLine)
    1: {
    1:   NS_DebugBreak(NS_DEBUG_ASSERTION, aStr, aExpr, aFile, aLine);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDebugImpl::Warning(const char *aStr, const char *aFile, PRInt32 aLine)
    1: {
    1:   NS_DebugBreak(NS_DEBUG_WARNING, aStr, nsnull, aFile, aLine);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDebugImpl::Break(const char *aFile, PRInt32 aLine)
    1: {
    1:   NS_DebugBreak(NS_DEBUG_BREAK, nsnull, nsnull, aFile, aLine);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDebugImpl::Abort(const char *aFile, PRInt32 aLine)
    1: {
    1:   NS_DebugBreak(NS_DEBUG_ABORT, nsnull, nsnull, aFile, aLine);
    1:   return NS_OK;
    1: }
    1: 
23485: NS_IMETHODIMP
23625: nsDebugImpl::GetIsDebugBuild(PRBool* aResult)
23625: {
23625: #ifdef DEBUG
23625:   *aResult = PR_TRUE;
23625: #else
23625:   *aResult = PR_FALSE;
23625: #endif
23625:   return NS_OK;
23625: }
23625: 
23625: NS_IMETHODIMP
23485: nsDebugImpl::GetAssertionCount(PRInt32* aResult)
23485: {
23485:   *aResult = gAssertionCount;
23485:   return NS_OK;
23485: }
23485: 
    1: /**
    1:  * Implementation of the nsDebug methods. Note that this code is
    1:  * always compiled in, in case some other module that uses it is
    1:  * compiled with debugging even if this library is not.
    1:  */
    1: static PRLogModuleInfo* gDebugLog;
    1: 
    1: static void InitLog(void)
    1: {
    1:   if (0 == gDebugLog) {
    1:     gDebugLog = PR_NewLogModule("nsDebug");
    1:     gDebugLog->level = PR_LOG_DEBUG;
    1:   }
    1: }
    1: 
    1: enum nsAssertBehavior {
    1:   NS_ASSERT_UNINITIALIZED,
    1:   NS_ASSERT_WARN,
    1:   NS_ASSERT_SUSPEND,
    1:   NS_ASSERT_STACK,
    1:   NS_ASSERT_TRAP,
 4473:   NS_ASSERT_ABORT,
 4473:   NS_ASSERT_STACK_AND_ABORT
    1: };
    1: 
    1: static nsAssertBehavior GetAssertBehavior()
    1: {
    1:   static nsAssertBehavior gAssertBehavior = NS_ASSERT_UNINITIALIZED;
    1:   if (gAssertBehavior != NS_ASSERT_UNINITIALIZED)
    1:     return gAssertBehavior;
    1: 
    1: #if defined(XP_WIN) || defined(XP_OS2)
    1:   gAssertBehavior = NS_ASSERT_TRAP;
    1: #else
    1:   gAssertBehavior = NS_ASSERT_WARN;
    1: #endif
    1: 
    1:   const char *assertString = PR_GetEnv("XPCOM_DEBUG_BREAK");
    1:   if (!assertString || !*assertString)
    1:     return gAssertBehavior;
    1: 
    1:    if (!strcmp(assertString, "warn"))
    1:      return gAssertBehavior = NS_ASSERT_WARN;
    1: 
    1:    if (!strcmp(assertString, "suspend"))
    1:      return gAssertBehavior = NS_ASSERT_SUSPEND;
    1: 
    1:    if (!strcmp(assertString, "stack"))
    1:      return gAssertBehavior = NS_ASSERT_STACK;
    1: 
    1:    if (!strcmp(assertString, "abort"))
    1:      return gAssertBehavior = NS_ASSERT_ABORT;
    1: 
    1:    if (!strcmp(assertString, "trap") || !strcmp(assertString, "break"))
    1:      return gAssertBehavior = NS_ASSERT_TRAP;
    1: 
 4473:    if (!strcmp(assertString, "stack-and-abort"))
 4473:      return gAssertBehavior = NS_ASSERT_STACK_AND_ABORT;
 4473: 
    1:    fprintf(stderr, "Unrecognized value of XPCOM_DEBUG_BREAK\n");
    1:    return gAssertBehavior;
    1: }
    1: 
    1: struct FixedBuffer
    1: {
    1:   FixedBuffer() : curlen(0) { buffer[0] = '\0'; }
    1: 
    1:   char buffer[1000];
    1:   PRUint32 curlen;
    1: };
    1: 
    1: static PRIntn
    1: StuffFixedBuffer(void *closure, const char *buf, PRUint32 len)
    1: {
    1:   if (!len)
    1:     return 0;
    1:   
    1:   FixedBuffer *fb = (FixedBuffer*) closure;
    1: 
    1:   // strip the trailing null, we add it again later
    1:   if (buf[len - 1] == '\0')
    1:     --len;
    1: 
    1:   if (fb->curlen + len >= sizeof(fb->buffer))
    1:     len = sizeof(fb->buffer) - fb->curlen - 1;
    1: 
    1:   if (len) {
    1:     memcpy(fb->buffer + fb->curlen, buf, len);
    1:     fb->curlen += len;
    1:     fb->buffer[fb->curlen] = '\0';
    1:   }
    1: 
    1:   return len;
    1: }
    1: 
    1: EXPORT_XPCOM_API(void)
    1: NS_DebugBreak(PRUint32 aSeverity, const char *aStr, const char *aExpr,
    1:               const char *aFile, PRInt32 aLine)
    1: {
    1:    InitLog();
    1: 
    1:    FixedBuffer buf;
    1:    PRLogModuleLevel ll = PR_LOG_WARNING;
    1:    const char *sevString = "WARNING";
    1: 
    1:    switch (aSeverity) {
    1:    case NS_DEBUG_ASSERTION:
    1:      sevString = "###!!! ASSERTION";
    1:      ll = PR_LOG_ERROR;
    1:      break;
    1: 
    1:    case NS_DEBUG_BREAK:
    1:      sevString = "###!!! BREAK";
    1:      ll = PR_LOG_ALWAYS;
    1:      break;
    1: 
    1:    case NS_DEBUG_ABORT:
    1:      sevString = "###!!! ABORT";
    1:      ll = PR_LOG_ALWAYS;
    1:      break;
    1: 
    1:    default:
    1:      aSeverity = NS_DEBUG_WARNING;
    1:    };
    1: 
    1:    PR_sxprintf(StuffFixedBuffer, &buf, "%s: ", sevString);
    1: 
    1:    if (aStr)
    1:      PR_sxprintf(StuffFixedBuffer, &buf, "%s: ", aStr);
    1: 
    1:    if (aExpr)
    1:      PR_sxprintf(StuffFixedBuffer, &buf, "'%s', ", aExpr);
    1: 
    1:    if (aFile)
    1:      PR_sxprintf(StuffFixedBuffer, &buf, "file %s, ", aFile);
    1: 
    1:    if (aLine != -1)
    1:      PR_sxprintf(StuffFixedBuffer, &buf, "line %d", aLine);
    1: 
    1:    // Write out the message to the debug log
    1:    PR_LOG(gDebugLog, ll, ("%s", buf.buffer));
    1:    PR_LogFlush();
    1: 
    1:    // errors on platforms without a debugdlg ring a bell on stderr
    1: #if !defined(XP_WIN) && !defined(XP_OS2)
    1:    if (ll != PR_LOG_WARNING)
    1:      fprintf(stderr, "\07");
    1: #endif
    1: 
42994: #ifdef ANDROID
42994:    __android_log_print(ANDROID_LOG_INFO, "Gecko", "%s", buf.buffer);
42994: #endif
42994: 
    1:    // Write the message to stderr
    1:    fprintf(stderr, "%s\n", buf.buffer);
    1:    fflush(stderr);
    1: 
    1:    switch (aSeverity) {
    1:    case NS_DEBUG_WARNING:
    1:      return;
    1: 
    1:    case NS_DEBUG_BREAK:
    1:      Break(buf.buffer);
    1:      return;
    1: 
61749:    case NS_DEBUG_ABORT: {
61834: #if defined(MOZ_CRASHREPORTER) && defined(MOZ_ENABLE_LIBXUL)
61749:      nsCString note("xpcom_runtime_abort(");
61749:      note += buf.buffer;
61749:      note += ")";
61749:      CrashReporter::AppendAppNotesToCrashReport(note);
61749: #endif  // MOZ_CRASHREPORTER
61749: 
39763: #if defined(DEBUG) && defined(_WIN32)
36077:      RealBreak();
36076: #endif
62521: #ifdef DEBUG
15206:      nsTraceRefcntImpl::WalkTheStack(stderr);
62521: #endif
    1:      Abort(buf.buffer);
    1:      return;
    1:    }
61749:    }
    1: 
    1:    // Now we deal with assertions
23485:    PR_AtomicIncrement(&gAssertionCount);
    1: 
    1:    switch (GetAssertBehavior()) {
    1:    case NS_ASSERT_WARN:
    1:      return;
    1: 
    1:    case NS_ASSERT_SUSPEND:
    1: #ifdef XP_UNIX
    1:       fprintf(stderr, "Suspending process; attach with the debugger.\n");
    1:       kill(0, SIGSTOP);
    1: #else
    1:       Break(buf.buffer);
    1: #endif
    1:       return;
    1: 
    1:    case NS_ASSERT_STACK:
    1:      nsTraceRefcntImpl::WalkTheStack(stderr);
    1:      return;
    1: 
 4473:    case NS_ASSERT_STACK_AND_ABORT:
 4473:      nsTraceRefcntImpl::WalkTheStack(stderr);
 4473:      // Fall through to abort
 4473: 
    1:    case NS_ASSERT_ABORT:
    1:      Abort(buf.buffer);
    1:      return;
    1: 
    1:    case NS_ASSERT_TRAP:
40604:    case NS_ASSERT_UNINITIALIZED: // Default to "trap" behavior
    1:      Break(buf.buffer);
40604:      return;
    1:    }   
    1: }
    1: 
    1: static void
    1: Abort(const char *aMsg)
    1: {
42433:   mozalloc_abort(aMsg);
    1: }
    1: 
36077: static void
36077: RealBreak()
36077: {
36077: #if defined(_WIN32)
36077: #ifndef WINCE
36077:   ::DebugBreak();
36077: #endif
36077: #elif defined(XP_OS2)
36077:    asm("int $3");
36077: #elif defined(XP_BEOS)
36077: #elif defined(XP_MACOSX)
36077:    raise(SIGTRAP);
36077: #elif defined(__GNUC__) && (defined(__i386__) || defined(__i386) || defined(__x86_64__))
36077:    asm("int $3");
49352: #elif defined(__arm__)
49352:    asm("BKPT #0");
50627: #elif defined(SOLARIS)
50627: #if defined(__i386__) || defined(__i386) || defined(__x86_64__)
50627:    asm("int $3");
50627: #else
50627:    raise(SIGTRAP);
50627: #endif
36077: #else
56947: #warning do not know how to break on this platform
36077: #endif
36077: }
36077: 
    1: // Abort() calls this function, don't call it!
    1: static void
    1: Break(const char *aMsg)
    1: {
    1: #if defined(_WIN32)
    1: #ifndef WINCE // we really just want to crash for now
    1:   static int ignoreDebugger;
    1:   if (!ignoreDebugger) {
    1:     const char *shouldIgnoreDebugger = getenv("XPCOM_DEBUG_DLG");
    1:     ignoreDebugger = 1 + (shouldIgnoreDebugger && !strcmp(shouldIgnoreDebugger, "1"));
    1:   }
22268:   if ((ignoreDebugger == 2) || !::IsDebuggerPresent()) {
    1:     DWORD code = IDRETRY;
    1: 
    1:     /* Create the debug dialog out of process to avoid the crashes caused by 
    1:      * Windows events leaking into our event loop from an in process dialog.
    1:      * We do this by launching windbgdlg.exe (built in xpcom/windbgdlg).
    1:      * See http://bugzilla.mozilla.org/show_bug.cgi?id=54792
    1:      */
    1:     PROCESS_INFORMATION pi;
22235:     STARTUPINFOW si;
22235:     PRUnichar executable[MAX_PATH];
22235:     PRUnichar* pName;
    1: 
    1:     memset(&pi, 0, sizeof(pi));
    1: 
    1:     memset(&si, 0, sizeof(si));
    1:     si.cb          = sizeof(si);
    1:     si.wShowWindow = SW_SHOW;
    1: 
    1:     // 2nd arg of CreateProcess is in/out
22235:     PRUnichar *msgCopy = (PRUnichar*) _alloca((strlen(aMsg) + 1)*sizeof(PRUnichar));
22235:     wcscpy(msgCopy  , (PRUnichar*)NS_ConvertUTF8toUTF16(aMsg).get());
    1: 
22235:     if(GetModuleFileNameW(GetModuleHandleW(L"xpcom.dll"), (LPWCH)executable, MAX_PATH) &&
22235:        NULL != (pName = wcsrchr(executable, '\\')) &&
22235:        NULL != 
22235:        wcscpy((WCHAR*)
22235:        pName+1, L"windbgdlg.exe") &&
22235:        CreateProcessW((LPCWSTR)executable, (LPWSTR)msgCopy, NULL, NULL, PR_FALSE,
    1:                      DETACHED_PROCESS | NORMAL_PRIORITY_CLASS,
    1:                      NULL, NULL, &si, &pi)) {
    1:       WaitForSingleObject(pi.hProcess, INFINITE);
    1:       GetExitCodeProcess(pi.hProcess, &code);
    1:       CloseHandle(pi.hProcess);
    1:       CloseHandle(pi.hThread);
    1:     }
    1: 
    1:     switch(code) {
    1:     case IDABORT:
    1:       //This should exit us
    1:       raise(SIGABRT);
    1:       //If we are ignored exit this way..
    1:       _exit(3);
    1:          
    1:     case IDIGNORE:
    1:       return;
    1:     }
    1:   }
    1: 
36077:   RealBreak();
    1: #endif // WINCE
    1: #elif defined(XP_OS2)
    1:    char msg[1200];
    1:    PR_snprintf(msg, sizeof(msg),
    1:                "%s\n\nClick Cancel to Debug Application.\n"
    1:                "Click Enter to continue running the Application.", aMsg);
    1:    ULONG code = MBID_ERROR;
    1:    code = WinMessageBox(HWND_DESKTOP, HWND_DESKTOP, msg, 
    1:                         "NSGlue_Assertion", 0,
    1:                         MB_ERROR | MB_ENTERCANCEL);
    1: 
    1:    /* It is possible that we are executing on a thread that doesn't have a
    1:     * message queue.  In that case, the message won't appear, and code will
    1:     * be 0xFFFF.  We'll give the user a chance to debug it by calling
    1:     * Break()
    1:     * Actually, that's a really bad idea since this happens a lot with threadsafe
    1:     * assertions and since it means that you can't actually run the debug build
    1:     * outside a debugger without it crashing constantly.
    1:     */
    1:    if (( code == MBID_ENTER ) || (code == MBID_ERROR))
    1:      return;
    1: 
36077:    RealBreak();
    1: #elif defined(XP_BEOS)
    1:    DEBUGGER(aMsg);
36077:    RealBreak();
    1: #elif defined(XP_MACOSX)
    1:    /* Note that we put this Mac OS X test above the GNUC/x86 test because the
    1:     * GNUC/x86 test is also true on Intel Mac OS X and we want the PPC/x86
    1:     * impls to be the same.
    1:     */
36077:    RealBreak();
    1: #elif defined(__GNUC__) && (defined(__i386__) || defined(__i386) || defined(__x86_64__))
36077:    RealBreak();
49352: #elif defined(__arm__)
49352:    RealBreak();
50627: #elif defined(SOLARIS)
50627:    RealBreak();
    1: #else
56947: #warning do not know how to break on this platform
    1: #endif
    1: }
    1: 
    1: static const nsDebugImpl kImpl;
    1: 
46997: nsresult
    1: nsDebugImpl::Create(nsISupports* outer, const nsIID& aIID, void* *aInstancePtr)
    1: {
    1:   NS_ENSURE_NO_AGGREGATION(outer);
    1: 
 3233:   return const_cast<nsDebugImpl*>(&kImpl)->
    1:     QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: 
    1: NS_COM nsresult
    1: NS_ErrorAccordingToNSPR()
    1: {
    1:     PRErrorCode err = PR_GetError();
    1:     switch (err) {
    1:       case PR_OUT_OF_MEMORY_ERROR:              return NS_ERROR_OUT_OF_MEMORY;
    1:       case PR_WOULD_BLOCK_ERROR:                return NS_BASE_STREAM_WOULD_BLOCK;
    1:       case PR_FILE_NOT_FOUND_ERROR:             return NS_ERROR_FILE_NOT_FOUND;
    1:       case PR_READ_ONLY_FILESYSTEM_ERROR:       return NS_ERROR_FILE_READ_ONLY;
    1:       case PR_NOT_DIRECTORY_ERROR:              return NS_ERROR_FILE_NOT_DIRECTORY;
    1:       case PR_IS_DIRECTORY_ERROR:               return NS_ERROR_FILE_IS_DIRECTORY;
    1:       case PR_LOOP_ERROR:                       return NS_ERROR_FILE_UNRESOLVABLE_SYMLINK;
    1:       case PR_FILE_EXISTS_ERROR:                return NS_ERROR_FILE_ALREADY_EXISTS;
    1:       case PR_FILE_IS_LOCKED_ERROR:             return NS_ERROR_FILE_IS_LOCKED;
    1:       case PR_FILE_TOO_BIG_ERROR:               return NS_ERROR_FILE_TOO_BIG;
    1:       case PR_NO_DEVICE_SPACE_ERROR:            return NS_ERROR_FILE_NO_DEVICE_SPACE;
    1:       case PR_NAME_TOO_LONG_ERROR:              return NS_ERROR_FILE_NAME_TOO_LONG;
    1:       case PR_DIRECTORY_NOT_EMPTY_ERROR:        return NS_ERROR_FILE_DIR_NOT_EMPTY;
    1:       case PR_NO_ACCESS_RIGHTS_ERROR:           return NS_ERROR_FILE_ACCESS_DENIED;
    1:       default:                                  return NS_ERROR_FAILURE;
    1:     }
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: 
36467: #ifdef XP_WIN
36467: NS_COM PRBool sXPCOMHasLoadedNewDLLs = PR_FALSE;
36467: 
36467: NS_EXPORT void
36467: NS_SetHasLoadedNewDLLs()
36467: {
36467:   sXPCOMHasLoadedNewDLLs = PR_TRUE;
36467: }
36467: #endif
