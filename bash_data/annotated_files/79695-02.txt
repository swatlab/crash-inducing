29835: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
29835: /* ***** BEGIN LICENSE BLOCK *****
29835:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
29835:  *
29835:  * The contents of this file are subject to the Mozilla Public License Version
29835:  * 1.1 (the "License"); you may not use this file except in compliance with
29835:  * the License. You may obtain a copy of the License at
29835:  * http://www.mozilla.org/MPL/
29835:  *
29835:  * Software distributed under the License is distributed on an "AS IS" basis,
29835:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
29835:  * for the specific language governing rights and limitations under the
29835:  * License.
29835:  *
29835:  * The Original Code is mozilla.org code.
29835:  *
29835:  * The Initial Developer of the Original Code is
29835:  * Mozilla Foundation.
29835:  * Portions created by the Initial Developer are Copyright (C) 2009
29835:  * the Initial Developer. All Rights Reserved.
29835:  *
29835:  * Contributor(s):
29835:  *
29835:  * Alternatively, the contents of this file may be used under the terms of
29835:  * either the GNU General Public License Version 2 or later (the "GPL"), or
29835:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
29835:  * in which case the provisions of the GPL or the LGPL are applicable instead
29835:  * of those above. If you wish to allow use of your version of this file only
29835:  * under the terms of either the GPL or the LGPL, and not to allow others to
29835:  * use your version of this file under the terms of the MPL, indicate your
29835:  * decision by deleting the provisions above and replace them with the notice
29835:  * and other provisions required by the GPL or the LGPL. If you do not delete
29835:  * the provisions above, a recipient may use your version of this file under
29835:  * the terms of any one of the MPL, the GPL or the LGPL.
29835:  *
29835:  * ***** END LICENSE BLOCK ***** */
29835: 
29841: /*
29841:  * nsWindowGfx - Painting and aceleration.
29841:  */
29841: 
29835: // XXX Future: this should really be a stand alone class stored as
29835: // a member of nsWindow with getters and setters for things like render
29835: // mode and methods for handling paint.
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Includes
29835:  **
29835:  ** Include headers.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
37613: #include "mozilla/plugins/PluginInstanceParent.h"
37613: using mozilla::plugins::PluginInstanceParent;
37613: 
29835: #include "nsWindowGfx.h"
29835: #include <windows.h>
29835: #include "gfxImageSurface.h"
29835: #include "gfxWindowsSurface.h"
30087: #include "gfxWindowsPlatform.h"
29835: #include "nsGfxCIID.h"
29835: #include "gfxContext.h"
68481: #include "nsRenderingContext.h"
30804: #include "prmem.h"
29835: 
40028: #include "LayerManagerOGL.h"
47746: #include "BasicLayers.h"
43174: #ifdef MOZ_ENABLE_D3D9_LAYER
42612: #include "LayerManagerD3D9.h"
42612: #endif
55790: #ifdef MOZ_ENABLE_D3D10_LAYER
55790: #include "LayerManagerD3D10.h"
55790: #endif
40028: 
29835: #include "nsUXThemeData.h"
29835: #include "nsUXThemeConstants.h"
29835: 
29835: extern "C" {
29835: #include "pixman.h"
29835: }
29835: 
47746: using namespace mozilla::layers;
47746: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: Variables
29835:  **
29835:  ** nsWindow Class static initializations and global variables.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
29835: /**************************************************************
29835:  *
29835:  * SECTION: nsWindow statics
29835:  * 
29835:  **************************************************************/
29835: 
34255: static nsAutoPtr<PRUint8>  sSharedSurfaceData;
34255: static gfxIntSize          sSharedSurfaceSize;
29835: 
79420: struct IconMetrics {
79420:   PRInt32 xMetric;
79420:   PRInt32 yMetric;
79420:   PRInt32 defaultSize;
79420: };
79420: 
79420: // Corresponds 1:1 to the IconSizeType enum
79420: static IconMetrics sIconMetrics[] = {
79420:   {SM_CXSMICON, SM_CYSMICON, 16}, // small icon
79420:   {SM_CXICON,   SM_CYICON,   32}  // regular icon
79420: };
79420: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: nsWindowGfx impl.
29835:  **
29835:  ** Misc. graphics related utilities.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
79445: static bool
30087: IsRenderMode(gfxWindowsPlatform::RenderMode rmode)
30087: {
30087:   return gfxWindowsPlatform::GetPlatform()->GetRenderMode() == rmode;
30087: }
30087: 
38805: nsIntRegion
29835: nsWindowGfx::ConvertHRGNToRegion(HRGN aRgn)
29835: {
29835:   NS_ASSERTION(aRgn, "Don't pass NULL region here");
29835: 
38805:   nsIntRegion rgn;
29835: 
29835:   DWORD size = ::GetRegionData(aRgn, 0, NULL);
29835:   nsAutoTArray<PRUint8,100> buffer;
29835:   if (!buffer.SetLength(size))
38805:     return rgn;
29835: 
29835:   RGNDATA* data = reinterpret_cast<RGNDATA*>(buffer.Elements());
29835:   if (!::GetRegionData(aRgn, size, data))
38805:     return rgn;
29835: 
29835:   if (data->rdh.nCount > MAX_RECTS_IN_REGION) {
38805:     rgn = ToIntRect(data->rdh.rcBound);
38805:     return rgn;
29835:   }
29835: 
29835:   RECT* rects = reinterpret_cast<RECT*>(data->Buffer);
29835:   for (PRUint32 i = 0; i < data->rdh.nCount; ++i) {
29835:     RECT* r = rects + i;
38805:     rgn.Or(rgn, ToIntRect(*r));
29835:   }
29835: 
38805:   return rgn;
29835: }
29835: 
29835: /**************************************************************
29835:  **************************************************************
29835:  **
29835:  ** BLOCK: nsWindow impl.
29835:  **
29835:  ** Paint related nsWindow methods.
29835:  **
29835:  **************************************************************
29835:  **************************************************************/
29835: 
32038: // GetRegionToPaint returns the invalidated region that needs to be painted
79445: nsIntRegion nsWindow::GetRegionToPaint(bool aForceFullRepaint,
32038:                                        PAINTSTRUCT ps, HDC aDC)
32038: {
32038:   if (aForceFullRepaint) {
32038:     RECT paintRect;
32038:     ::GetClientRect(mWnd, &paintRect);
56097:     return nsIntRegion(nsWindowGfx::ToIntRect(paintRect));
32038:   }
38805: 
38805:   HRGN paintRgn = ::CreateRectRgn(0, 0, 0, 0);
32038:   if (paintRgn != NULL) {
32038:     int result = GetRandomRgn(aDC, paintRgn, SYSRGN);
32038:     if (result == 1) {
32038:       POINT pt = {0,0};
32038:       ::MapWindowPoints(NULL, mWnd, &pt, 1);
32038:       ::OffsetRgn(paintRgn, pt.x, pt.y);
32038:     }
38805:     nsIntRegion rgn(nsWindowGfx::ConvertHRGNToRegion(paintRgn));
32038:     ::DeleteObject(paintRgn);
51610:     return rgn;
32038:   }
56097:   return nsIntRegion(nsWindowGfx::ToIntRect(ps.rcPaint));
32038: }
32038: 
34255: #define WORDSSIZE(x) ((x).width * (x).height)
79445: static bool
34255: EnsureSharedSurfaceSize(gfxIntSize size)
34255: {
34255:   gfxIntSize screenSize;
34255:   screenSize.height = GetSystemMetrics(SM_CYSCREEN);
34255:   screenSize.width = GetSystemMetrics(SM_CXSCREEN);
34255: 
34255:   if (WORDSSIZE(screenSize) > WORDSSIZE(size))
34255:     size = screenSize;
34255: 
34255:   if (WORDSSIZE(screenSize) < WORDSSIZE(size))
34255:     NS_WARNING("Trying to create a shared surface larger than the screen");
34255: 
34255:   if (!sSharedSurfaceData || (WORDSSIZE(size) > WORDSSIZE(sSharedSurfaceSize))) {
34255:     sSharedSurfaceSize = size;
34255:     sSharedSurfaceData = nsnull;
34255:     sSharedSurfaceData = (PRUint8 *)malloc(WORDSSIZE(sSharedSurfaceSize) * 4);
34255:   }
34255: 
34255:   return (sSharedSurfaceData != nsnull);
34255: }
34255: 
79445: bool nsWindow::OnPaint(HDC aDC, PRUint32 aNestingLevel)
29835: {
46644:   // We never have reentrant paint events, except when we're running our RPC
46644:   // windows event spin loop. If we don't trap for this, we'll try to paint,
46644:   // but view manager will refuse to paint the surface, resulting is black
46644:   // flashes on the plugin rendering surface.
46644:   if (mozilla::ipc::RPCChannel::IsSpinLoopActive() && mPainting)
79626:     return false;
46669: 
37613:   if (mWindowType == eWindowType_plugin) {
38068: 
38068:     /**
38068:      * After we CallUpdateWindow to the child, occasionally a WM_PAINT message
38139:      * is posted to the parent event loop with an empty update rect. Do a
38139:      * dummy paint so that Windows stops dispatching WM_PAINT in an inifinite
38068:      * loop. See bug 543788.
38068:      */
38068:     RECT updateRect;
38068:     if (!GetUpdateRect(mWnd, &updateRect, FALSE) ||
38068:         (updateRect.left == updateRect.right &&
38139:          updateRect.top == updateRect.bottom)) {
38139:       PAINTSTRUCT ps;
38139:       BeginPaint(mWnd, &ps);
38139:       EndPaint(mWnd, &ps);
79626:       return true;
38139:     }
38068: 
37613:     PluginInstanceParent* instance = reinterpret_cast<PluginInstanceParent*>(
37613:       ::GetPropW(mWnd, L"PluginInstanceParentProperty"));
37613:     if (instance) {
38068:       instance->CallUpdateWindow();
37613:       ValidateRect(mWnd, NULL);
79626:       return true;
37613:     }
37613:   }
37613: 
79626:   nsPaintEvent willPaintEvent(true, NS_WILL_PAINT, this);
79626:   willPaintEvent.willSendDidPaint = true;
34894:   DispatchWindowEvent(&willPaintEvent);
34894: 
79445:   bool result = true;
29835:   PAINTSTRUCT ps;
29835:   nsEventStatus eventStatus = nsEventStatus_eIgnore;
29835: 
29835: #ifdef MOZ_XUL
29835:   if (!aDC && (eTransparencyTransparent == mTransparencyMode))
29835:   {
29835:     // For layered translucent windows all drawing should go to memory DC and no
29835:     // WM_PAINT messages are normally generated. To support asynchronous painting
29835:     // we force generation of WM_PAINT messages by invalidating window areas with
29835:     // RedrawWindow, InvalidateRect or InvalidateRgn function calls.
29835:     // BeginPaint/EndPaint must be called to make Windows think that invalid area
29835:     // is painted. Otherwise it will continue sending the same message endlessly.
29835:     ::BeginPaint(mWnd, &ps);
29835:     ::EndPaint(mWnd, &ps);
29835: 
29835:     aDC = mMemoryDC;
29835:   }
29835: #endif
29835: 
79626:   mPainting = true;
29835: 
29835: #ifdef WIDGET_DEBUG_OUTPUT
29835:   HRGN debugPaintFlashRegion = NULL;
29835:   HDC debugPaintFlashDC = NULL;
29835: 
29835:   if (debug_WantPaintFlashing())
29835:   {
29835:     debugPaintFlashRegion = ::CreateRectRgn(0, 0, 0, 0);
29835:     ::GetUpdateRgn(mWnd, debugPaintFlashRegion, TRUE);
29835:     debugPaintFlashDC = ::GetDC(mWnd);
29835:   }
29835: #endif // WIDGET_DEBUG_OUTPUT
29835: 
29835:   HDC hDC = aDC ? aDC : (::BeginPaint(mWnd, &ps));
38727:   if (!IsRenderMode(gfxWindowsPlatform::RENDER_DIRECT2D)) {
29835:     mPaintDC = hDC;
38727:   }
29835: 
38805:   // generate the event and call the event callback
79626:   nsPaintEvent event(true, NS_PAINT, this);
38805:   InitEvent(event);
38805: 
29835: #ifdef MOZ_XUL
79445:   bool forceRepaint = aDC || (eTransparencyTransparent == mTransparencyMode);
29835: #else
79445:   bool forceRepaint = NULL != aDC;
29835: #endif
38805:   event.region = GetRegionToPaint(forceRepaint, ps, hDC);
79626:   event.willSendDidPaint = true;
29835: 
38805:   if (!event.region.IsEmpty() && mEventCallback)
29835:   {
29835:     // Should probably pass in a real region here, using GetRandomRgn
29835:     // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/clipping_4q0e.asp
29835: 
29835: #ifdef WIDGET_DEBUG_OUTPUT
29835:     debug_DumpPaintEvent(stdout,
29835:                          this,
29835:                          &event,
29835:                          nsCAutoString("noname"),
29835:                          (PRInt32) mWnd);
29835: #endif // WIDGET_DEBUG_OUTPUT
29835: 
40028:     switch (GetLayerManager()->GetBackendType()) {
40028:       case LayerManager::LAYERS_BASIC:
40028:         {
29835:           nsRefPtr<gfxASurface> targetSurface;
29835: 
29835: #if defined(MOZ_XUL)
29835:           // don't support transparency for non-GDI rendering, for now
43936:           if ((IsRenderMode(gfxWindowsPlatform::RENDER_GDI) ||
43936:                IsRenderMode(gfxWindowsPlatform::RENDER_DIRECT2D)) &&
43936:               eTransparencyTransparent == mTransparencyMode) {
29835:             if (mTransparentSurface == nsnull)
29835:               SetupTranslucentWindowMemoryBitmap(mTransparencyMode);
29835:             targetSurface = mTransparentSurface;
29835:           }
29835: #endif
29835: 
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:           if (!targetSurface &&
38727:               IsRenderMode(gfxWindowsPlatform::RENDER_DIRECT2D))
38727:           {
38727:             if (!mD2DWindowSurface) {
43397:               gfxASurface::gfxContentType content = gfxASurface::CONTENT_COLOR;
43397: #if defined(MOZ_XUL)
43397:               if (mTransparencyMode != eTransparencyOpaque) {
43397:                 content = gfxASurface::CONTENT_COLOR_ALPHA;
43397:               }
43397: #endif
43397:               mD2DWindowSurface = new gfxD2DSurface(mWnd, content);
38727:             }
79695:             if (!mD2DWindowSurface->CairoStatus()) {
38727:               targetSurface = mD2DWindowSurface;
79695:             } else {
79695:               mD2DWindowSurface = nsnull;
79695:             }
38727:           }
38727: #endif
79695: 
79695:           nsRefPtr<gfxWindowsSurface> targetSurfaceWin;
79695:           if (!targetSurface &&
79695:               (IsRenderMode(gfxWindowsPlatform::RENDER_GDI) ||
79695:                IsRenderMode(gfxWindowsPlatform::RENDER_DIRECT2D)))
79695:           {
79695:             PRUint32 flags = (mTransparencyMode == eTransparencyOpaque) ? 0 :
79695:                 gfxWindowsSurface::FLAG_IS_TRANSPARENT;
79695:             targetSurfaceWin = new gfxWindowsSurface(hDC, flags);
79695:             targetSurface = targetSurfaceWin;
79695:           }
79695: 
29835:           nsRefPtr<gfxImageSurface> targetSurfaceImage;
29835:           if (!targetSurface &&
30087:               (IsRenderMode(gfxWindowsPlatform::RENDER_IMAGE_STRETCH32) ||
30087:                IsRenderMode(gfxWindowsPlatform::RENDER_IMAGE_STRETCH24)))
29835:           {
29835:             gfxIntSize surfaceSize(ps.rcPaint.right - ps.rcPaint.left,
29835:                                    ps.rcPaint.bottom - ps.rcPaint.top);
29835: 
34255:             if (!EnsureSharedSurfaceSize(surfaceSize)) {
34255:               NS_ERROR("Couldn't allocate a shared image surface!");
34255:               return NS_ERROR_FAILURE;
34255:             }
34255: 
29835:             // don't use the shared surface directly; instead, create a new one
29835:             // that just reuses its buffer.
29835:             targetSurfaceImage = new gfxImageSurface(sSharedSurfaceData.get(),
29835:                                                      surfaceSize,
29835:                                                      surfaceSize.width * 4,
29835:                                                      gfxASurface::ImageFormatRGB24);
29835: 
29835:             if (targetSurfaceImage && !targetSurfaceImage->CairoStatus()) {
29835:               targetSurfaceImage->SetDeviceOffset(gfxPoint(-ps.rcPaint.left, -ps.rcPaint.top));
29835:               targetSurface = targetSurfaceImage;
29835:             }
29835:           }
29835: 
29835:           if (!targetSurface) {
30087:             NS_ERROR("Invalid RenderMode!");
29835:             return NS_ERROR_FAILURE;
29835:           }
29835: 
29835:           nsRefPtr<gfxContext> thebesContext = new gfxContext(targetSurface);
38806:           if (IsRenderMode(gfxWindowsPlatform::RENDER_DIRECT2D)) {
38806:             const nsIntRect* r;
38807:             for (nsIntRegionRectIterator iter(event.region);
38806:                  (r = iter.Next()) != nsnull;) {
79626:               thebesContext->Rectangle(gfxRect(r->x, r->y, r->width, r->height), true);
38727:             }
38727:             thebesContext->Clip();
43396:             thebesContext->SetOperator(gfxContext::OPERATOR_CLEAR);
43396:             thebesContext->Paint();
43396:             thebesContext->SetOperator(gfxContext::OPERATOR_OVER);
38727:           }
29835: 
29835:           // don't need to double buffer with anything but GDI
47746:           BasicLayerManager::BufferMode doubleBuffering =
47746:             BasicLayerManager::BUFFER_NONE;
30087:           if (IsRenderMode(gfxWindowsPlatform::RENDER_GDI)) {
68855: #ifdef MOZ_XUL
50770:             switch (mTransparencyMode) {
50770:               case eTransparencyGlass:
50770:               case eTransparencyBorderlessGlass:
50770:               default:
50770:                 // If we're not doing translucency, then double buffer
47746:                 doubleBuffering = BasicLayerManager::BUFFER_BUFFERED;
50770:                 break;
50770:               case eTransparencyTransparent:
29835:                 // If we're rendering with translucency, we're going to be
29835:                 // rendering the whole window; make sure we clear it first
29835:                 thebesContext->SetOperator(gfxContext::OPERATOR_CLEAR);
29835:                 thebesContext->Paint();
29835:                 thebesContext->SetOperator(gfxContext::OPERATOR_OVER);
50770:                 break;
50770:             }
50770: #else
50770:             doubleBuffering = BasicLayerManager::BUFFER_BUFFERED;
29835: #endif
29835:           }
29835: 
38805:           {
47746:             AutoLayerManagerSetup
47746:                 setupLayerManager(this, thebesContext, doubleBuffering);
38805:             result = DispatchWindowEvent(&event, eventStatus);
29835:           }
29835: 
29835: #ifdef MOZ_XUL
43936:           if ((IsRenderMode(gfxWindowsPlatform::RENDER_GDI) ||
43936:                IsRenderMode(gfxWindowsPlatform::RENDER_DIRECT2D))&&
29835:               eTransparencyTransparent == mTransparencyMode) {
29835:             // Data from offscreen drawing surface was copied to memory bitmap of transparent
29835:             // bitmap. Now it can be read from memory bitmap to apply alpha channel and after
29835:             // that displayed on the screen.
29835:             UpdateTranslucentWindow();
29835:           } else
29835: #endif
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:           if (result) {
38727:             if (mD2DWindowSurface) {
38727:               mD2DWindowSurface->Present();
38727:             }
38727:           }
38727: #endif
29835:           if (result) {
71589:             if (IsRenderMode(gfxWindowsPlatform::RENDER_IMAGE_STRETCH24) ||
30087:                 IsRenderMode(gfxWindowsPlatform::RENDER_IMAGE_STRETCH32))
29835:             {
29835:               gfxIntSize surfaceSize = targetSurfaceImage->GetSize();
29835: 
29835:               // Just blit this directly
29835:               BITMAPINFOHEADER bi;
29835:               memset(&bi, 0, sizeof(BITMAPINFOHEADER));
29835:               bi.biSize = sizeof(BITMAPINFOHEADER);
29835:               bi.biWidth = surfaceSize.width;
29835:               bi.biHeight = - surfaceSize.height;
29835:               bi.biPlanes = 1;
29835:               bi.biBitCount = 32;
29835:               bi.biCompression = BI_RGB;
29835: 
30087:               if (IsRenderMode(gfxWindowsPlatform::RENDER_IMAGE_STRETCH24)) {
29835:                 // On Windows CE/Windows Mobile, 24bpp packed-pixel sources
29835:                 // seem to be far faster to blit than 32bpp (see bug 484864).
29835:                 // So, convert the bits to 24bpp by stripping out the unused
29835:                 // alpha byte.  24bpp DIBs also have scanlines that are 4-byte
29835:                 // aligned though, so that must be taken into account.
29835:                 int srcstride = surfaceSize.width*4;
29835:                 int dststride = surfaceSize.width*3;
29835:                 dststride = (dststride + 3) & ~3;
29835: 
29835:                 // Convert in place
29835:                 for (int j = 0; j < surfaceSize.height; ++j) {
29835:                   unsigned int *src = (unsigned int*) (targetSurfaceImage->Data() + j*srcstride);
29835:                   unsigned int *dst = (unsigned int*) (targetSurfaceImage->Data() + j*dststride);
29835: 
29835:                   // go 4 pixels at a time, since each 4 pixels
29835:                   // turns into 3 DWORDs when converted into BGR:
29835:                   // BGRx BGRx BGRx BGRx -> BGRB GRBG RBGR
29835:                   //
29835:                   // However, since we're dealing with little-endian ints, this is actually:
29835:                   // xRGB xrgb xRGB xrgb -> bRGB GBrg rgbR
29835:                   int width_left = surfaceSize.width;
29835:                   while (width_left >= 4) {
29835:                     unsigned int a = *src++;
29835:                     unsigned int b = *src++;
29835:                     unsigned int c = *src++;
29835:                     unsigned int d = *src++;
29835: 
29835:                     *dst++ =  (a & 0x00ffffff)        | (b << 24);
29835:                     *dst++ = ((b & 0x00ffff00) >> 8)  | (c << 16);
29835:                     *dst++ = ((c & 0x00ff0000) >> 16) | (d << 8);
29835: 
29835:                     width_left -= 4;
29835:                   }
29835: 
29835:                   // then finish up whatever number of pixels are left,
29835:                   // using bytes.
29835:                   unsigned char *bsrc = (unsigned char*) src;
29835:                   unsigned char *bdst = (unsigned char*) dst;
29835:                   switch (width_left) {
29835:                     case 3:
29835:                       *bdst++ = *bsrc++;
29835:                       *bdst++ = *bsrc++;
29835:                       *bdst++ = *bsrc++;
29835:                       bsrc++;
29835:                     case 2:
29835:                       *bdst++ = *bsrc++;
29835:                       *bdst++ = *bsrc++;
29835:                       *bdst++ = *bsrc++;
29835:                       bsrc++;
29835:                     case 1:
29835:                       *bdst++ = *bsrc++;
29835:                       *bdst++ = *bsrc++;
29835:                       *bdst++ = *bsrc++;
29835:                       bsrc++;
29835:                     case 0:
29835:                       break;
29835:                   }
29835:                 }
29835: 
29835:                 bi.biBitCount = 24;
29835:               }
29835: 
29835:               StretchDIBits(hDC,
29835:                             ps.rcPaint.left, ps.rcPaint.top,
29835:                             surfaceSize.width, surfaceSize.height,
29835:                             0, 0,
29835:                             surfaceSize.width, surfaceSize.height,
29835:                             targetSurfaceImage->Data(),
29835:                             (BITMAPINFO*) &bi,
29835:                             DIB_RGB_COLORS,
29835:                             SRCCOPY);
29835:             }
29835:           }
29835:         }
40028:         break;
40028:       case LayerManager::LAYERS_OPENGL:
40028:         static_cast<mozilla::layers::LayerManagerOGL*>(GetLayerManager())->
40028:           SetClippingRegion(event.region);
40028:         result = DispatchWindowEvent(&event, eventStatus);
40028:         break;
43174: #ifdef MOZ_ENABLE_D3D9_LAYER
42612:       case LayerManager::LAYERS_D3D9:
53982:         {
53982:           LayerManagerD3D9 *layerManagerD3D9 =
53982:             static_cast<mozilla::layers::LayerManagerD3D9*>(GetLayerManager());
53982:           layerManagerD3D9->SetClippingRegion(event.region);
42612:           result = DispatchWindowEvent(&event, eventStatus);
53982:           if (layerManagerD3D9->DeviceWasRemoved()) {
58810:             mLayerManager->Destroy();
53982:             mLayerManager = nsnull;
53985:             // When our device was removed, we should have gfxWindowsPlatform
53985:             // check if its render mode is up to date!
53985:             gfxWindowsPlatform::GetPlatform()->UpdateRenderMode();
79626:             Invalidate(false);
53982:           }
53982:         }
42612:         break;
42612: #endif
54816: #ifdef MOZ_ENABLE_D3D10_LAYER
54816:       case LayerManager::LAYERS_D3D10:
55790:         {
55790:           gfxWindowsPlatform::GetPlatform()->UpdateRenderMode();
55790:           LayerManagerD3D10 *layerManagerD3D10 = static_cast<mozilla::layers::LayerManagerD3D10*>(GetLayerManager());
56335:           if (layerManagerD3D10->device() != gfxWindowsPlatform::GetPlatform()->GetD3D10Device()) {
79626:             Invalidate(false);
55790:           } else {
54816:             result = DispatchWindowEvent(&event, eventStatus);
55790:           }
55790:         }
54816:         break;
54816: #endif
40028:       default:
40028:         NS_ERROR("Unknown layers backend used!");
40028:         break;
40028:     }
40028:   }
29835: 
29835:   if (!aDC) {
29835:     ::EndPaint(mWnd, &ps);
29835:   }
29835: 
29835:   mPaintDC = nsnull;
29835: 
68855: #if defined(WIDGET_DEBUG_OUTPUT)
29835:   if (debug_WantPaintFlashing())
29835:   {
29835:     // Only flash paint events which have not ignored the paint message.
29835:     // Those that ignore the paint message aren't painting anything so there
29835:     // is only the overhead of the dispatching the paint event.
29835:     if (nsEventStatus_eIgnore != eventStatus) {
29835:       ::InvertRgn(debugPaintFlashDC, debugPaintFlashRegion);
29835:       PR_Sleep(PR_MillisecondsToInterval(30));
29835:       ::InvertRgn(debugPaintFlashDC, debugPaintFlashRegion);
29835:       PR_Sleep(PR_MillisecondsToInterval(30));
29835:     }
29835:     ::ReleaseDC(mWnd, debugPaintFlashDC);
29835:     ::DeleteObject(debugPaintFlashRegion);
29835:   }
68855: #endif // WIDGET_DEBUG_OUTPUT
29835: 
79626:   mPainting = false;
29835: 
79626:   nsPaintEvent didPaintEvent(true, NS_DID_PAINT, this);
47756:   DispatchWindowEvent(&didPaintEvent);
47756: 
79626:   if (aNestingLevel == 0 && ::GetUpdateRect(mWnd, NULL, false)) {
47756:     OnPaint(aDC, 1);
47756:   }
47756: 
29835:   return result;
29835: }
29835: 
79420: gfxIntSize nsWindowGfx::GetIconMetrics(IconSizeType aSizeType) {
79420:   PRInt32 width = ::GetSystemMetrics(sIconMetrics[aSizeType].xMetric);
79420:   PRInt32 height = ::GetSystemMetrics(sIconMetrics[aSizeType].yMetric);
79420: 
79420:   if (width == 0 || height == 0) {
79420:     width = height = sIconMetrics[aSizeType].defaultSize;
79420:   }
79420: 
79420:   return gfxIntSize(width, height);
79420: }
79420: 
30804: nsresult nsWindowGfx::CreateIcon(imgIContainer *aContainer,
79445:                                   bool aIsCursor,
30804:                                   PRUint32 aHotspotX,
30804:                                   PRUint32 aHotspotY,
79420:                                   gfxIntSize aScaledSize,
30804:                                   HICON *aIcon) {
30804: 
30804:   // Get the image data
30804:   nsRefPtr<gfxImageSurface> frame;
32424:   aContainer->CopyFrame(imgIContainer::FRAME_CURRENT,
32424:                         imgIContainer::FLAG_SYNC_DECODE,
32424:                         getter_AddRefs(frame));
30804:   if (!frame)
30804:     return NS_ERROR_NOT_AVAILABLE;
30804: 
30804:   PRInt32 width = frame->Width();
30804:   PRInt32 height = frame->Height();
79420:   if (!width || !height)
79420:     return NS_ERROR_FAILURE;
79420: 
79420:   PRUint8 *data;
79420:   if ((aScaledSize.width == 0 && aScaledSize.height == 0) ||
79420:       (aScaledSize.width == width && aScaledSize.height == height)) {
79420:     // We're not scaling the image. The data is simply what's in the frame.
79420:     data = frame->Data();
79420:   }
79420:   else {
79420:     NS_ENSURE_ARG(aScaledSize.width > 0);
79420:     NS_ENSURE_ARG(aScaledSize.height > 0);
79420:     // Draw a scaled version of the image to a temporary surface
79420:     nsRefPtr<gfxImageSurface> dest = new gfxImageSurface(aScaledSize,
79420:                                                          gfxASurface::ImageFormatARGB32);
79420:     if (!dest)
79420:       return NS_ERROR_OUT_OF_MEMORY;
79420: 
79420:     gfxContext ctx(dest);
79420: 
79420:     // Set scaling
79420:     gfxFloat sw = (double) aScaledSize.width / width;
79420:     gfxFloat sh = (double) aScaledSize.height / height;
79420:     ctx.Scale(sw, sh);
79420: 
79420:     // Paint a scaled image
79420:     ctx.SetOperator(gfxContext::OPERATOR_SOURCE);
79420:     ctx.SetSource(frame);
79420:     ctx.Paint();
79420: 
79420:     data = dest->Data();
79420:     width = aScaledSize.width;
79420:     height = aScaledSize.height;
79420:   }
30804: 
30804:   HBITMAP bmp = DataToBitmap(data, width, -height, 32);
30804:   PRUint8* a1data = Data32BitTo1Bit(data, width, height);
30804:   if (!a1data) {
30804:     return NS_ERROR_FAILURE;
30804:   }
30804: 
30804:   HBITMAP mbmp = DataToBitmap(a1data, width, -height, 1);
30804:   PR_Free(a1data);
30804: 
30804:   ICONINFO info = {0};
30804:   info.fIcon = !aIsCursor;
30804:   info.xHotspot = aHotspotX;
30804:   info.yHotspot = aHotspotY;
30804:   info.hbmMask = mbmp;
30804:   info.hbmColor = bmp;
30804: 
30804:   HCURSOR icon = ::CreateIconIndirect(&info);
30804:   ::DeleteObject(mbmp);
30804:   ::DeleteObject(bmp);
30804:   if (!icon)
30804:     return NS_ERROR_FAILURE;
30804:   *aIcon = icon;
30804:   return NS_OK;
30804: }
30804: 
30804: // Adjust cursor image data
30804: PRUint8* nsWindowGfx::Data32BitTo1Bit(PRUint8* aImageData,
30804:                                       PRUint32 aWidth, PRUint32 aHeight)
30804: {
30804:   // We need (aWidth + 7) / 8 bytes plus zero-padding up to a multiple of
30804:   // 4 bytes for each row (HBITMAP requirement). Bug 353553.
30804:   PRUint32 outBpr = ((aWidth + 31) / 8) & ~3;
30804: 
30804:   // Allocate and clear mask buffer
30804:   PRUint8* outData = (PRUint8*)PR_Calloc(outBpr, aHeight);
30804:   if (!outData)
30804:     return NULL;
30804: 
30804:   PRInt32 *imageRow = (PRInt32*)aImageData;
30804:   for (PRUint32 curRow = 0; curRow < aHeight; curRow++) {
30804:     PRUint8 *outRow = outData + curRow * outBpr;
30804:     PRUint8 mask = 0x80;
30804:     for (PRUint32 curCol = 0; curCol < aWidth; curCol++) {
30804:       // Use sign bit to test for transparency, as alpha byte is highest byte
30804:       if (*imageRow++ < 0)
30804:         *outRow |= mask;
30804: 
30804:       mask >>= 1;
30804:       if (!mask) {
30804:         outRow ++;
30804:         mask = 0x80;
30804:       }
30804:     }
30804:   }
30804: 
30804:   return outData;
30804: }
30804: 
79445: bool nsWindowGfx::IsCursorTranslucencySupported()
30804: {
79445:   static bool didCheck = false;
79445:   static bool isSupported = false;
30804:   if (!didCheck) {
79626:     didCheck = true;
30804:     // Cursor translucency is supported on Windows XP and newer
30804:     isSupported = nsWindow::GetWindowsVersion() >= 0x501;
30804:   }
30804: 
30804:   return isSupported;
30804: }
30804: 
30804: /**
30804:  * Convert the given image data to a HBITMAP. If the requested depth is
30804:  * 32 bit and the OS supports translucency, a bitmap with an alpha channel
30804:  * will be returned.
30804:  *
30804:  * @param aImageData The image data to convert. Must use the format accepted
30804:  *                   by CreateDIBitmap.
30804:  * @param aWidth     With of the bitmap, in pixels.
30804:  * @param aHeight    Height of the image, in pixels.
30804:  * @param aDepth     Image depth, in bits. Should be one of 1, 24 and 32.
30804:  *
30804:  * @return The HBITMAP representing the image. Caller should call
30804:  *         DeleteObject when done with the bitmap.
30804:  *         On failure, NULL will be returned.
30804:  */
30804: HBITMAP nsWindowGfx::DataToBitmap(PRUint8* aImageData,
30804:                                   PRUint32 aWidth,
30804:                                   PRUint32 aHeight,
30804:                                   PRUint32 aDepth)
30804: {
30804:   HDC dc = ::GetDC(NULL);
30804: 
30804:   if (aDepth == 32 && IsCursorTranslucencySupported()) {
30804:     // Alpha channel. We need the new header.
30804:     BITMAPV4HEADER head = { 0 };
30804:     head.bV4Size = sizeof(head);
30804:     head.bV4Width = aWidth;
30804:     head.bV4Height = aHeight;
30804:     head.bV4Planes = 1;
30804:     head.bV4BitCount = aDepth;
30804:     head.bV4V4Compression = BI_BITFIELDS;
30804:     head.bV4SizeImage = 0; // Uncompressed
30804:     head.bV4XPelsPerMeter = 0;
30804:     head.bV4YPelsPerMeter = 0;
30804:     head.bV4ClrUsed = 0;
30804:     head.bV4ClrImportant = 0;
30804: 
30804:     head.bV4RedMask   = 0x00FF0000;
30804:     head.bV4GreenMask = 0x0000FF00;
30804:     head.bV4BlueMask  = 0x000000FF;
30804:     head.bV4AlphaMask = 0xFF000000;
30804: 
30804:     HBITMAP bmp = ::CreateDIBitmap(dc,
30804:                                    reinterpret_cast<CONST BITMAPINFOHEADER*>(&head),
30804:                                    CBM_INIT,
30804:                                    aImageData,
30804:                                    reinterpret_cast<CONST BITMAPINFO*>(&head),
30804:                                    DIB_RGB_COLORS);
30804:     ::ReleaseDC(NULL, dc);
30804:     return bmp;
30804:   }
30804: 
30804:   char reserved_space[sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 2];
30804:   BITMAPINFOHEADER& head = *(BITMAPINFOHEADER*)reserved_space;
30804: 
30804:   head.biSize = sizeof(BITMAPINFOHEADER);
30804:   head.biWidth = aWidth;
30804:   head.biHeight = aHeight;
30804:   head.biPlanes = 1;
30804:   head.biBitCount = (WORD)aDepth;
30804:   head.biCompression = BI_RGB;
30804:   head.biSizeImage = 0; // Uncompressed
30804:   head.biXPelsPerMeter = 0;
30804:   head.biYPelsPerMeter = 0;
30804:   head.biClrUsed = 0;
30804:   head.biClrImportant = 0;
30804:   
30804:   BITMAPINFO& bi = *(BITMAPINFO*)reserved_space;
30804: 
30804:   if (aDepth == 1) {
30804:     RGBQUAD black = { 0, 0, 0, 0 };
30804:     RGBQUAD white = { 255, 255, 255, 0 };
30804: 
30804:     bi.bmiColors[0] = white;
30804:     bi.bmiColors[1] = black;
30804:   }
30804: 
30804:   HBITMAP bmp = ::CreateDIBitmap(dc, &head, CBM_INIT, aImageData, &bi, DIB_RGB_COLORS);
30804:   ::ReleaseDC(NULL, dc);
30804:   return bmp;
30804: }
