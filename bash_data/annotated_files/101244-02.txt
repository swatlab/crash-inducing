     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #include "nsCRT.h"
     1: 
     1: #include "nsUnicharUtils.h"
     1: 
     1: #include "nsHTMLEditor.h"
     1: #include "nsHTMLEditRules.h"
     1: #include "nsTextEditUtils.h"
     1: #include "nsHTMLEditUtils.h"
     1: 
 39014: #include "nsHTMLEditorEventListener.h"
     1: #include "TypeInState.h"
     1: 
     1: #include "nsHTMLURIRefObject.h"
     1: 
     1: #include "nsIDOMText.h"
     1: #include "nsIDOMNodeList.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMAttr.h"
     1: #include "nsIDocument.h"
  1418: #include "nsIDOMEventTarget.h" 
     1: #include "nsIDOMKeyEvent.h"
     1: #include "nsISelectionPrivate.h"
     1: #include "nsIDOMHTMLAnchorElement.h"
     1: #include "nsISelectionController.h"
 43713: #include "nsIDOMHTMLDocument.h"
     1: #include "nsILinkHandler.h"
     1: 
 47937: #include "mozilla/css/Loader.h"
 42163: #include "nsCSSStyleSheet.h"
     1: #include "nsIDOMStyleSheet.h"
     1: 
     1: #include "nsIEnumerator.h"
     1: #include "nsIContent.h"
     1: #include "nsIContentIterator.h"
     1: #include "nsIDOMRange.h"
     1: #include "nsISupportsArray.h"
     1: #include "nsContentUtils.h"
     1: #include "nsIDocumentEncoder.h"
     1: #include "nsIDOMDocumentFragment.h"
     1: #include "nsIPresShell.h"
     1: #include "nsPresContext.h"
     1: #include "SetDocTitleTxn.h"
 41886: #include "nsFocusManager.h"
 41886: #include "nsPIDOMWindow.h"
     1: 
     1: // netwerk
     1: #include "nsIURI.h"
     1: #include "nsNetUtil.h"
     1: 
     1: // Transactionas
     1: #include "nsStyleSheetTxns.h"
     1: 
     1: // Misc
     1: #include "TextEditorTest.h"
     1: #include "nsEditorUtils.h"
     1: #include "nsWSRunObject.h"
 13021: #include "nsGkAtoms.h"
 82843: #include "nsIWidget.h"
     1: 
     1: #include "nsIFrame.h"
     1: #include "nsIParserService.h"
 74131: #include "mozilla/dom/Element.h"
     1: 
 82307: using namespace mozilla;
 82843: using namespace mozilla::widget;
 82307: 
     1: // Some utilities to handle annoying overloading of "A" tag for link and named anchor
     1: static char hrefText[] = "href";
     1: static char anchorTxt[] = "anchor";
     1: static char namedanchorText[] = "namedanchor";
     1: 
     1: #define IsLinkTag(s) (s.EqualsIgnoreCase(hrefText))
     1: #define IsNamedAnchorTag(s) (s.EqualsIgnoreCase(anchorTxt) || s.EqualsIgnoreCase(namedanchorText))
     1: 
     1: nsHTMLEditor::nsHTMLEditor()
     1: : nsPlaintextEditor()
 80486: , mCRInParagraphCreatesParagraph(false)
     1: , mSelectedCellIndex(0)
 80486: , mIsObjectResizingEnabled(true)
 80486: , mIsResizing(false)
 80486: , mIsAbsolutelyPositioningEnabled(true)
 80486: , mResizedObjectIsAbsolutelyPositioned(false)
 80486: , mGrabberClicked(false)
 80486: , mIsMoving(false)
 80486: , mSnapToGridEnabled(false)
 80486: , mIsInlineTableEditingEnabled(true)
  5299: , mInfoXIncrement(20)
  5299: , mInfoYIncrement(20)
 11852: , mGridSize(0)
     1: {
     1: } 
     1: 
     1: nsHTMLEditor::~nsHTMLEditor()
     1: {
     1:   // remove the rules as an action listener.  Else we get a bad
     1:   // ownership loop later on.  it's ok if the rules aren't a listener;
     1:   // we ignore the error.
     1:   nsCOMPtr<nsIEditActionListener> mListener = do_QueryInterface(mRules);
     1:   RemoveEditActionListener(mListener);
     1: 
 62878:   //the autopointers will clear themselves up. 
 62878:   //but we need to also remove the listeners or we have a leak
 62878:   nsCOMPtr<nsISelection>selection;
 62878:   nsresult result = GetSelection(getter_AddRefs(selection));
 62878:   // if we don't get the selection, just skip this
 62878:   if (NS_SUCCEEDED(result) && selection) 
 62878:   {
 62878:     nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
 62878:     nsCOMPtr<nsISelectionListener>listener;
 62878:     listener = do_QueryInterface(mTypeInState);
 62878:     if (listener)
 62878:     {
 62878:       selPriv->RemoveSelectionListener(listener); 
 62878:     }
 62878:     listener = do_QueryInterface(mSelectionListenerP);
 62878:     if (listener)
 62878:     {
 62878:       selPriv->RemoveSelectionListener(listener); 
 62878:     }
 62878:   }
 62878: 
 62878:   mTypeInState = nsnull;
 62878:   mSelectionListenerP = nsnull;
 62878: 
 62878:   // free any default style propItems
 62878:   RemoveAllDefaultProperties();
 62878: 
 63587:   if (mLinkHandler && mDocWeak)
 63587:   {
 70236:     nsCOMPtr<nsIPresShell> ps = GetPresShell();
 62878: 
 62878:     if (ps && ps->GetPresContext())
 62878:     {
 62878:       ps->GetPresContext()->SetLinkHandler(mLinkHandler);
 62878:     }
 62878:   }
 62878: 
 62878:   RemoveEventListeners();
 62878: }
 62878: 
 62878: void
 62878: nsHTMLEditor::HideAnonymousEditingUIs()
 62878: {
     1:   if (mAbsolutelyPositionedObject)
     1:     HideGrabber();
     1:   if (mInlineEditedCell)
     1:     HideInlineTableEditingUI();
     1:   if (mResizedObject)
     1:     HideResizers();
     1: }
     1: 
 62825: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLEditor)
 62825: 
 62825: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsHTMLEditor, nsPlaintextEditor)
 62825:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTypeInState)
 62825:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTextServices)
 62825: 
 62878:   tmp->HideAnonymousEditingUIs();
 62825: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 62825: 
 62825: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLEditor, nsPlaintextEditor)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTypeInState)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTextServices)
 62825: 
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTopLeftHandle)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTopHandle)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTopRightHandle)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLeftHandle)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRightHandle)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mBottomLeftHandle)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mBottomHandle)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mBottomRightHandle)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mActivatedHandle)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mResizingShadow)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mResizingInfo)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mResizedObject)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mMouseMotionListenerP)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSelectionListenerP)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mResizeEventListenerP)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(objectResizeEventListeners)
 62825: 
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAbsolutelyPositionedObject)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mGrabber)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPositioningShadow)
 62825: 
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInlineEditedCell)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAddColumnBeforeButton)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRemoveColumnButton)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAddColumnAfterButton)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAddRowBeforeButton)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRemoveRowButton)
 62825:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAddRowAfterButton)
 62825: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 62825: 
     1: NS_IMPL_ADDREF_INHERITED(nsHTMLEditor, nsEditor)
     1: NS_IMPL_RELEASE_INHERITED(nsHTMLEditor, nsEditor)
     1: 
 62825: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsHTMLEditor)
     1:   NS_INTERFACE_MAP_ENTRY(nsIHTMLEditor)
     1:   NS_INTERFACE_MAP_ENTRY(nsIHTMLObjectResizer)
     1:   NS_INTERFACE_MAP_ENTRY(nsIHTMLAbsPosEditor)
     1:   NS_INTERFACE_MAP_ENTRY(nsIHTMLInlineTableEditor)
     1:   NS_INTERFACE_MAP_ENTRY(nsITableEditor)
     1:   NS_INTERFACE_MAP_ENTRY(nsIEditorStyleSheets)
     1:   NS_INTERFACE_MAP_ENTRY(nsICSSLoaderObserver)
 43716:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
     1: NS_INTERFACE_MAP_END_INHERITING(nsPlaintextEditor)
     1: 
     1: 
     1: NS_IMETHODIMP
 63592: nsHTMLEditor::Init(nsIDOMDocument *aDoc,
 63592:                    nsIContent *aRoot,
 63592:                    nsISelectionController *aSelCon,
     1:                    PRUint32 aFlags)
     1: {
 63592:   NS_PRECONDITION(aDoc && !aSelCon, "bad arg");
 63592:   NS_ENSURE_TRUE(aDoc, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsresult result = NS_OK, rulesRes = NS_OK;
     1:    
     1:   if (1)
     1:   {
     1:     // block to scope nsAutoEditInitRulesTrigger
  3233:     nsAutoEditInitRulesTrigger rulesTrigger(static_cast<nsPlaintextEditor*>(this), rulesRes);
     1: 
     1:     // Init the plaintext editor
 63592:     result = nsPlaintextEditor::Init(aDoc, aRoot, nsnull, aFlags);
     1:     if (NS_FAILED(result)) { return result; }
     1: 
 43716:     // Init mutation observer
 43716:     nsCOMPtr<nsINode> document = do_QueryInterface(aDoc);
 58923:     document->AddMutationObserverUnlessExists(this);
 43716: 
     1:     // disable Composer-only features
 40703:     if (IsMailEditor())
     1:     {
 80486:       SetAbsolutePositioningEnabled(false);
 80486:       SetSnapToGridEnabled(false);
     1:     }
     1: 
     1:     // Init the HTML-CSS utils
 69900:     mHTMLCSSUtils = new nsHTMLCSSUtils(this);
     1: 
     1:     // disable links
 70236:     nsCOMPtr<nsIPresShell> presShell = GetPresShell();
 63592:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
 63592:     nsPresContext *context = presShell->GetPresContext();
 43806:     NS_ENSURE_TRUE(context, NS_ERROR_NULL_POINTER);
 40703:     if (!IsPlaintextEditor() && !IsInteractionAllowed()) {
     1:       mLinkHandler = context->GetLinkHandler();
     1: 
     1:       context->SetLinkHandler(nsnull);
     1:     }
     1: 
     1:     // init the type-in state
     1:     mTypeInState = new TypeInState();
     1: 
     1:     // init the selection listener for image resizing
     1:     mSelectionListenerP = new ResizerSelectionListener(this);
     1: 
 40703:     if (!IsInteractionAllowed()) {
     1:       // ignore any errors from this in case the file is missing
  7269:       AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/EditorOverride.css"));
  2896:     }
     1: 
     1:     nsCOMPtr<nsISelection>selection;
     1:     result = GetSelection(getter_AddRefs(selection));
     1:     if (NS_FAILED(result)) { return result; }
     1:     if (selection) 
     1:     {
     1:       nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
     1:       nsCOMPtr<nsISelectionListener>listener;
     1:       listener = do_QueryInterface(mTypeInState);
     1:       if (listener) {
     1:         selPriv->AddSelectionListener(listener); 
     1:       }
     1:       listener = do_QueryInterface(mSelectionListenerP);
     1:       if (listener) {
     1:         selPriv->AddSelectionListener(listener); 
     1:       }
     1:     }
     1:   }
     1: 
 43805:   NS_ENSURE_SUCCESS(rulesRes, rulesRes);
     1:   return result;
     1: }
     1: 
 43713: NS_IMETHODIMP
 79445: nsHTMLEditor::PreDestroy(bool aDestroyingFrames)
 43716: {
 43716:   if (mDidPreDestroy) {
 43716:     return NS_OK;
 43716:   }
 43716: 
 43716:   nsCOMPtr<nsINode> document = do_QueryReferent(mDocWeak);
 43716:   if (document) {
 43716:     document->RemoveMutationObserver(this);
 43716:   }
 43716: 
 72434:   while (mStyleSheetURLs.Length())
 72434:   {
 72434:     RemoveOverrideStyleSheet(mStyleSheetURLs[0]);
 72434:   }
 72434: 
 95690:   // Clean up after our anonymous content -- we don't want these nodes to
 95690:   // stay around (which they would, since the frames have an owning reference).
 95690:   HideAnonymousEditingUIs();
 95690: 
 43716:   return nsPlaintextEditor::PreDestroy(aDestroyingFrames);
 43716: }
 43716: 
 43716: NS_IMETHODIMP
 43713: nsHTMLEditor::GetRootElement(nsIDOMElement **aRootElement)
 43713: {
 43713:   NS_ENSURE_ARG_POINTER(aRootElement);
 43713: 
 43713:   if (mRootElement) {
 43713:     return nsEditor::GetRootElement(aRootElement);
 43713:   }
 43713: 
 43713:   *aRootElement = nsnull;
 43713: 
 43713:   // Use the HTML documents body element as the editor root if we didn't
 43713:   // get a root element during initialization.
 43713: 
 83343:   nsCOMPtr<nsIDOMElement> rootElement; 
 43713:   nsCOMPtr<nsIDOMHTMLElement> bodyElement; 
 43713:   nsresult rv = GetBodyElement(getter_AddRefs(bodyElement));
 43713:   NS_ENSURE_SUCCESS(rv, rv);
 43713: 
 43713:   if (bodyElement) {
 83343:     rootElement = bodyElement;
 43713:   } else {
 43713:     // If there is no HTML body element,
 43713:     // we should use the document root element instead.
 43713:     nsCOMPtr<nsIDOMDocument> doc = do_QueryReferent(mDocWeak);
 43713:     NS_ENSURE_TRUE(doc, NS_ERROR_NOT_INITIALIZED);
 43713: 
 83343:     rv = doc->GetDocumentElement(getter_AddRefs(rootElement));
 43713:     NS_ENSURE_SUCCESS(rv, rv);
 43713:     // Document can have no elements
 83343:     if (!rootElement) {
 43713:       return NS_ERROR_NOT_AVAILABLE;
 43713:     }
 43713:   }
 43713: 
 83343:   mRootElement = do_QueryInterface(rootElement);
 83343:   rootElement.forget(aRootElement);
 43713: 
 43713:   return NS_OK;
 43713: }
 43713: 
 43715: already_AddRefed<nsIContent>
 43715: nsHTMLEditor::FindSelectionRoot(nsINode *aNode)
 43715: {
 43715:   NS_PRECONDITION(aNode->IsNodeOfType(nsINode::eDOCUMENT) ||
 43715:                   aNode->IsNodeOfType(nsINode::eCONTENT),
 43715:                   "aNode must be content or document node");
 43715: 
 43715:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 43715:   nsCOMPtr<nsIDocument> doc = aNode->GetCurrentDoc();
 43715:   if (!doc) {
 43715:     return nsnull;
 43715:   }
 43715: 
 43715:   if (doc->HasFlag(NODE_IS_EDITABLE) || !content) {
 43715:     content = doc->GetRootElement();
 43715:     return content.forget();
 43715:   }
 43715: 
 43715:   // XXX If we have readonly flag, shouldn't return the element which has
 43715:   // contenteditable="true"?  However, such case isn't there without chrome
 43715:   // permission script.
 43715:   if (IsReadonly()) {
 43715:     // We still want to allow selection in a readonly editor.
 43715:     content = do_QueryInterface(GetRoot());
 43715:     return content.forget();
 43715:   }
 43715: 
 43715:   if (!content->HasFlag(NODE_IS_EDITABLE)) {
 98127:     // If the content is in read-write state but is not editable itself,
 98127:     // return it as the selection root.
 98127:     if (content->IsElement() &&
 98127:         content->AsElement()->State().HasState(NS_EVENT_STATE_MOZ_READWRITE)) {
 98127:       return content.forget();
 98127:     }
 43715:     return nsnull;
 43715:   }
 43715: 
 43715:   // For non-readonly editors we want to find the root of the editable subtree
 43715:   // containing aContent.
 48083:   content = content->GetEditingHost();
 43715:   return content.forget();
 43715: }
 43715: 
 73869: /* virtual */
 73869: void
     1: nsHTMLEditor::CreateEventListeners()
     1: {
 57958:   // Don't create the handler twice
 72596:   if (!mEventListener) {
 72596:     mEventListener = new nsHTMLEditorEventListener();
 72596:   }
     1: }
     1: 
 40987: nsresult
 40987: nsHTMLEditor::InstallEventListeners()
 40987: {
 63587:   NS_ENSURE_TRUE(mDocWeak && mEventListener,
 40987:                  NS_ERROR_NOT_INITIALIZED);
 43714: 
 43714:   // NOTE: nsHTMLEditor doesn't need to initialize mEventTarget here because
 43714:   // the target must be document node and it must be referenced as weak pointer.
 43714: 
 40987:   nsHTMLEditorEventListener* listener =
 40987:     reinterpret_cast<nsHTMLEditorEventListener*>(mEventListener.get());
 40987:   return listener->Connect(this);
 40987: }
 40987: 
     1: void
     1: nsHTMLEditor::RemoveEventListeners()
     1: {
     1:   if (!mDocWeak)
     1:   {
     1:     return;
     1:   }
     1: 
 72327:   nsCOMPtr<nsIDOMEventTarget> target = GetDOMEventTarget();
 72327: 
 72327:   if (target)
     1:   {
     1:     // Both mMouseMotionListenerP and mResizeEventListenerP can be
     1:     // registerd with other targets than the DOM event receiver that
     1:     // we can reach from here. But nonetheless, unregister the event
     1:     // listeners with the DOM event reveiver (if it's registerd with
     1:     // other targets, it'll get unregisterd once the target goes
     1:     // away).
     1: 
     1:     if (mMouseMotionListenerP)
     1:     {
 72596:       // mMouseMotionListenerP might be registerd either as bubbling or
 72596:       // capturing, unregister by both.
 72596:       target->RemoveEventListener(NS_LITERAL_STRING("mousemove"),
 80486:                                   mMouseMotionListenerP, false);
  1418:       target->RemoveEventListener(NS_LITERAL_STRING("mousemove"),
 80486:                                   mMouseMotionListenerP, true);
     1:     }
     1: 
     1:     if (mResizeEventListenerP)
     1:     {
  1418:       target->RemoveEventListener(NS_LITERAL_STRING("resize"),
 80486:                                   mResizeEventListenerP, false);
     1:     }
     1:   }
     1: 
     1:   mMouseMotionListenerP = nsnull;
     1:   mResizeEventListenerP = nsnull;
     1: 
     1:   nsPlaintextEditor::RemoveEventListeners();
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SetFlags(PRUint32 aFlags)
     1: {
 40703:   nsresult rv = nsPlaintextEditor::SetFlags(aFlags);
 40703:   NS_ENSURE_SUCCESS(rv, rv);
 40703: 
 40703:   // Sets mCSSAware to correspond to aFlags. This toggles whether CSS is
 40703:   // used to style elements in the editor. Note that the editor is only CSS
 40703:   // aware by default in Composer and in the mail editor.
 40703:   mCSSAware = !NoCSS() && !IsMailEditor();
 40703: 
 40703:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::InitRules()
     1: {
     1:   // instantiate the rules for the html editor
 69901:   mRules = new nsHTMLEditRules();
 69901:   return mRules->Init(static_cast<nsPlaintextEditor*>(this));
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::BeginningOfDocument()
     1: {
 63587:   if (!mDocWeak) { return NS_ERROR_NOT_INITIALIZED; }
     1: 
     1:   // get the selection
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43808:   NS_ENSURE_SUCCESS(res, res);
 43807:   NS_ENSURE_TRUE(selection, NS_ERROR_NOT_INITIALIZED);
     1: 
 62327:   // Get the root element.
 83343:   nsCOMPtr<nsIDOMElement> rootElement = do_QueryInterface(GetRoot());
 62327:   if (!rootElement) {
 62327:     NS_WARNING("GetRoot() returned a null pointer (mRootElement is null)");
 62327:     return NS_OK;
 62327:   }
     1: 
     1:   // find first editable thingy
 79445:   bool done = false;
     1:   nsCOMPtr<nsIDOMNode> curNode(rootElement), selNode;
     1:   PRInt32 curOffset = 0, selOffset;
     1:   while (!done)
     1:   {
     1:     nsWSRunObject wsObj(this, curNode, curOffset);
     1:     nsCOMPtr<nsIDOMNode> visNode;
     1:     PRInt32 visOffset=0;
     1:     PRInt16 visType=0;
     1:     wsObj.NextVisibleNode(curNode, curOffset, address_of(visNode), &visOffset, &visType);
     1:     if ((visType==nsWSRunObject::eNormalWS) || 
     1:         (visType==nsWSRunObject::eText))
     1:     {
     1:       selNode = visNode;
     1:       selOffset = visOffset;
 80486:       done = true;
     1:     }
     1:     else if ((visType==nsWSRunObject::eBreak)    ||
     1:              (visType==nsWSRunObject::eSpecial))
     1:     {
     1:       res = GetNodeLocation(visNode, address_of(selNode), &selOffset);
 43805:       NS_ENSURE_SUCCESS(res, res); 
 80486:       done = true;
     1:     }
     1:     else if (visType==nsWSRunObject::eOtherBlock)
     1:     {
     1:       // By definition of nsWSRunObject, a block element terminates 
     1:       // a whitespace run. That is, although we are calling a method 
     1:       // that is named "NextVisibleNode", the node returned
     1:       // might not be visible/editable!
     1:       // If the given block does not contain any visible/editable items,
     1:       // we want to skip it and continue our search.
     1: 
     1:       if (!IsContainer(visNode))
     1:       {
     1:         // However, we were given a block that is not a container.
     1:         // Since the block can not contain anything that's visible,
     1:         // such a block only makes sense if it is visible by itself,
     1:         // like a <hr>
     1:         // We want to place the caret in front of that block.
     1: 
     1:         res = GetNodeLocation(visNode, address_of(selNode), &selOffset);
 43805:         NS_ENSURE_SUCCESS(res, res); 
 80486:         done = true;
     1:       }
     1:       else
     1:       {
 79445:         bool isEmptyBlock;
     1:         if (NS_SUCCEEDED(IsEmptyNode(visNode, &isEmptyBlock)) &&
     1:             isEmptyBlock)
     1:         {
     1:           // skip the empty block
     1:           res = GetNodeLocation(visNode, address_of(curNode), &curOffset);
 43805:           NS_ENSURE_SUCCESS(res, res); 
     1:           ++curOffset;
     1:         }
     1:         else
     1:         {
     1:           curNode = visNode;
     1:           curOffset = 0;
     1:         }
     1:         // keep looping
     1:       }
     1:     }
     1:     else
     1:     {
     1:       // else we found nothing useful
     1:       selNode = curNode;
     1:       selOffset = curOffset;
 80486:       done = true;
     1:     }
     1:   }
     1:   return selection->Collapse(selNode, selOffset);
     1: }
     1: 
 43438: nsresult
 43438: nsHTMLEditor::HandleKeyPressEvent(nsIDOMKeyEvent* aKeyEvent)
 43438: {
 43438:   // NOTE: When you change this method, you should also change:
 43438:   //   * editor/libeditor/html/tests/test_htmleditor_keyevent_handling.html
 43438: 
 43438:   if (IsReadonly() || IsDisabled()) {
 43438:     // When we're not editable, the events are handled on nsEditor, so, we can
 43438:     // bypass nsPlaintextEditor.
 43438:     return nsEditor::HandleKeyPressEvent(aKeyEvent);
 43438:   }
 43438: 
 43438:   nsKeyEvent* nativeKeyEvent = GetNativeKeyEvent(aKeyEvent);
 43438:   NS_ENSURE_TRUE(nativeKeyEvent, NS_ERROR_UNEXPECTED);
 43438:   NS_ASSERTION(nativeKeyEvent->message == NS_KEY_PRESS,
 43438:                "HandleKeyPressEvent gets non-keypress event");
 43438: 
 43438:   switch (nativeKeyEvent->keyCode) {
 43438:     case nsIDOMKeyEvent::DOM_VK_META:
 43438:     case nsIDOMKeyEvent::DOM_VK_SHIFT:
 43438:     case nsIDOMKeyEvent::DOM_VK_CONTROL:
 43438:     case nsIDOMKeyEvent::DOM_VK_ALT:
 43438:     case nsIDOMKeyEvent::DOM_VK_BACK_SPACE:
 43438:     case nsIDOMKeyEvent::DOM_VK_DELETE:
 43438:       // These keys are handled on nsEditor, so, we can bypass
 43438:       // nsPlaintextEditor.
 43438:       return nsEditor::HandleKeyPressEvent(aKeyEvent);
 43438:     case nsIDOMKeyEvent::DOM_VK_TAB: {
 43438:       if (IsPlaintextEditor()) {
 43438:         // If this works as plain text editor, e.g., mail editor for plain
 43438:         // text, should be handled on nsPlaintextEditor.
 43438:         return nsPlaintextEditor::HandleKeyPressEvent(aKeyEvent);
 43438:       }
 43438: 
 43438:       if (IsTabbable()) {
 43438:         return NS_OK; // let it be used for focus switching
 43438:       }
 43438: 
 96893:       if (nativeKeyEvent->IsControl() || nativeKeyEvent->IsAlt() ||
 96893:           nativeKeyEvent->IsMeta()) {
 43438:         return NS_OK;
 43438:       }
 43438: 
 43438:       nsCOMPtr<nsISelection> selection;
 43438:       nsresult rv = GetSelection(getter_AddRefs(selection));
 43438:       NS_ENSURE_SUCCESS(rv, rv);
 43438:       PRInt32 offset;
 43438:       nsCOMPtr<nsIDOMNode> node, blockParent;
 43518:       rv = GetStartNodeAndOffset(selection, getter_AddRefs(node), &offset);
 43438:       NS_ENSURE_SUCCESS(rv, rv);
 43438:       NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
 43438: 
 79445:       bool isBlock = false;
 43438:       NodeIsBlock(node, &isBlock);
 43438:       if (isBlock) {
 43438:         blockParent = node;
 43438:       } else {
 43438:         blockParent = GetBlockNodeParent(node);
 43438:       }
 43438: 
 43438:       if (!blockParent) {
 43438:         break;
 43438:       }
 43438: 
 79445:       bool handled = false;
 43438:       if (nsHTMLEditUtils::IsTableElement(blockParent)) {
 96893:         rv = TabInTable(nativeKeyEvent->IsShift(), &handled);
 43438:         if (handled) {
 80486:           ScrollSelectionIntoView(false);
 43438:         }
 43438:       } else if (nsHTMLEditUtils::IsListItem(blockParent)) {
 96893:         rv = Indent(nativeKeyEvent->IsShift() ?
 43438:                       NS_LITERAL_STRING("outdent") :
 43438:                       NS_LITERAL_STRING("indent"));
 80486:         handled = true;
 43438:       }
 43438:       NS_ENSURE_SUCCESS(rv, rv);
 43438:       if (handled) {
 43438:         return aKeyEvent->PreventDefault(); // consumed
 43438:       }
 96893:       if (nativeKeyEvent->IsShift()) {
 43438:         return NS_OK; // don't type text for shift tabs
 43438:       }
 43438:       aKeyEvent->PreventDefault();
 43438:       return TypedText(NS_LITERAL_STRING("\t"), eTypedText);
 43438:     }
 43438:     case nsIDOMKeyEvent::DOM_VK_RETURN:
 43438:     case nsIDOMKeyEvent::DOM_VK_ENTER:
 96893:       if (nativeKeyEvent->IsControl() || nativeKeyEvent->IsAlt() ||
 96893:           nativeKeyEvent->IsMeta()) {
 43438:         return NS_OK;
 43438:       }
 43438:       aKeyEvent->PreventDefault(); // consumed
 96893:       if (nativeKeyEvent->IsShift() && !IsPlaintextEditor()) {
 43438:         // only inserts a br node
 43438:         return TypedText(EmptyString(), eTypedBR);
 43438:       }
 43438:       // uses rules to figure out what to insert
 43438:       return TypedText(EmptyString(), eTypedBreak);
 43438:   }
 43438: 
 43438:   // NOTE: On some keyboard layout, some characters are inputted with Control
 43438:   // key or Alt key, but at that time, widget sets FALSE to these keys.
 96893:   if (nativeKeyEvent->charCode == 0 || nativeKeyEvent->IsControl() ||
 96893:       nativeKeyEvent->IsAlt() || nativeKeyEvent->IsMeta()) {
 43438:     // we don't PreventDefault() here or keybindings like control-x won't work
 43438:     return NS_OK;
 43438:   }
 43438:   aKeyEvent->PreventDefault();
 43438:   nsAutoString str(nativeKeyEvent->charCode);
 43438:   return TypedText(str, eTypedText);
 43438: }
 43438: 
     1: /**
     1:  * Returns true if the id represents an element of block type.
     1:  * Can be used to determine if a new paragraph should be started.
     1:  */
     1: nsresult
 79445: nsHTMLEditor::NodeIsBlockStatic(nsIDOMNode *aNode, bool *aIsBlock)
     1: {
     1:   if (!aNode || !aIsBlock) { return NS_ERROR_NULL_POINTER; }
     1: 
 80486:   *aIsBlock = false;
     1: 
     1: #define USE_PARSER_FOR_BLOCKNESS 1
     1: #ifdef USE_PARSER_FOR_BLOCKNESS
     1:   nsresult rv;
     1: 
     1:   nsCOMPtr<nsIDOMElement>element = do_QueryInterface(aNode);
     1:   if (!element)
     1:   {
     1:     // We don't have an element -- probably a text node
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsIAtom *tagAtom = GetTag(aNode);
 43806:   NS_ENSURE_TRUE(tagAtom, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Nodes we know we want to treat as block
     1:   // even though the parser says they're not:
     1:   if (tagAtom==nsEditProperty::body       ||
     1:       tagAtom==nsEditProperty::head       ||
     1:       tagAtom==nsEditProperty::tbody      ||
     1:       tagAtom==nsEditProperty::thead      ||
     1:       tagAtom==nsEditProperty::tfoot      ||
     1:       tagAtom==nsEditProperty::tr         ||
     1:       tagAtom==nsEditProperty::th         ||
     1:       tagAtom==nsEditProperty::td         ||
     1:       tagAtom==nsEditProperty::li         ||
     1:       tagAtom==nsEditProperty::dt         ||
     1:       tagAtom==nsEditProperty::dd         ||
     1:       tagAtom==nsEditProperty::pre)
     1:   {
 80486:     *aIsBlock = true;
     1:     return NS_OK;
     1:   }
     1: 
     1:   rv = nsContentUtils::GetParserService()->
     1:     IsBlock(nsContentUtils::GetParserService()->HTMLAtomTagToId(tagAtom),
     1:             *aIsBlock);
     1: 
     1: #ifdef DEBUG
     1:   // Check this against what we would have said with the old code:
     1:   if (tagAtom==nsEditProperty::p          ||
     1:       tagAtom==nsEditProperty::div        ||
     1:       tagAtom==nsEditProperty::blockquote ||
     1:       tagAtom==nsEditProperty::h1         ||
     1:       tagAtom==nsEditProperty::h2         ||
     1:       tagAtom==nsEditProperty::h3         ||
     1:       tagAtom==nsEditProperty::h4         ||
     1:       tagAtom==nsEditProperty::h5         ||
     1:       tagAtom==nsEditProperty::h6         ||
     1:       tagAtom==nsEditProperty::ul         ||
     1:       tagAtom==nsEditProperty::ol         ||
     1:       tagAtom==nsEditProperty::dl         ||
     1:       tagAtom==nsEditProperty::noscript   ||
     1:       tagAtom==nsEditProperty::form       ||
     1:       tagAtom==nsEditProperty::hr         ||
     1:       tagAtom==nsEditProperty::table      ||
     1:       tagAtom==nsEditProperty::fieldset   ||
     1:       tagAtom==nsEditProperty::address    ||
     1:       tagAtom==nsEditProperty::caption    ||
     1:       tagAtom==nsEditProperty::col        ||
     1:       tagAtom==nsEditProperty::colgroup   ||
     1:       tagAtom==nsEditProperty::li         ||
     1:       tagAtom==nsEditProperty::dt         ||
     1:       tagAtom==nsEditProperty::dd         ||
     1:       tagAtom==nsEditProperty::legend     )
     1:   {
     1:     if (!(*aIsBlock))
     1:     {
     1:       nsAutoString assertmsg (NS_LITERAL_STRING("Parser and editor disagree on blockness: "));
     1: 
     1:       nsAutoString tagName;
     1:       rv = element->GetTagName(tagName);
 43805:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:       assertmsg.Append(tagName);
     1:       char* assertstr = ToNewCString(assertmsg);
     1:       NS_ASSERTION(*aIsBlock, assertstr);
   241:       NS_Free(assertstr);
     1:     }
     1:   }
     1: #endif /* DEBUG */
     1: 
     1:   return rv;
     1: #else /* USE_PARSER_FOR_BLOCKNESS */
     1:   nsresult result = NS_ERROR_FAILURE;
 80486:   *aIsBlock = false;
     1:   nsCOMPtr<nsIDOMElement>element;
     1:   element = do_QueryInterface(aNode);
     1:   if (element)
     1:   {
     1:     nsAutoString tagName;
     1:     result = element->GetTagName(tagName);
     1:     if (NS_SUCCEEDED(result))
     1:     {
     1:       ToLowerCase(tagName);
     1:       nsCOMPtr<nsIAtom> tagAtom = do_GetAtom(tagName);
     1:       if (!tagAtom) { return NS_ERROR_NULL_POINTER; }
     1: 
     1:       if (tagAtom==nsEditProperty::p          ||
     1:           tagAtom==nsEditProperty::div        ||
     1:           tagAtom==nsEditProperty::blockquote ||
     1:           tagAtom==nsEditProperty::h1         ||
     1:           tagAtom==nsEditProperty::h2         ||
     1:           tagAtom==nsEditProperty::h3         ||
     1:           tagAtom==nsEditProperty::h4         ||
     1:           tagAtom==nsEditProperty::h5         ||
     1:           tagAtom==nsEditProperty::h6         ||
     1:           tagAtom==nsEditProperty::ul         ||
     1:           tagAtom==nsEditProperty::ol         ||
     1:           tagAtom==nsEditProperty::dl         ||
     1:           tagAtom==nsEditProperty::pre        ||
     1:           tagAtom==nsEditProperty::noscript   ||
     1:           tagAtom==nsEditProperty::form       ||
     1:           tagAtom==nsEditProperty::hr         ||
     1:           tagAtom==nsEditProperty::fieldset   ||
     1:           tagAtom==nsEditProperty::address    ||
     1:           tagAtom==nsEditProperty::body       ||
     1:           tagAtom==nsEditProperty::caption    ||
     1:           tagAtom==nsEditProperty::table      ||
     1:           tagAtom==nsEditProperty::tbody      ||
     1:           tagAtom==nsEditProperty::thead      ||
     1:           tagAtom==nsEditProperty::tfoot      ||
     1:           tagAtom==nsEditProperty::tr         ||
     1:           tagAtom==nsEditProperty::td         ||
     1:           tagAtom==nsEditProperty::th         ||
     1:           tagAtom==nsEditProperty::col        ||
     1:           tagAtom==nsEditProperty::colgroup   ||
     1:           tagAtom==nsEditProperty::li         ||
     1:           tagAtom==nsEditProperty::dt         ||
     1:           tagAtom==nsEditProperty::dd         ||
     1:           tagAtom==nsEditProperty::legend     )
     1:       {
 80486:         *aIsBlock = true;
     1:       }
     1:       result = NS_OK;
     1:     }
     1:   } else {
     1:     // We don't have an element -- probably a text node
     1:     nsCOMPtr<nsIDOMCharacterData>nodeAsText = do_QueryInterface(aNode);
     1:     if (nodeAsText)
     1:     {
 80486:       *aIsBlock = false;
     1:       result = NS_OK;
     1:     }
     1:   }
     1:   return result;
     1: 
     1: #endif /* USE_PARSER_FOR_BLOCKNESS */
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::NodeIsBlock(nsIDOMNode *aNode, bool *aIsBlock)
     1: {
     1:   return NodeIsBlockStatic(aNode, aIsBlock);
     1: }
     1: 
 79445: bool
     1: nsHTMLEditor::IsBlockNode(nsIDOMNode *aNode)
     1: {
 79445:   bool isBlock;
     1:   NodeIsBlockStatic(aNode, &isBlock);
     1:   return isBlock;
     1: }
     1: 
 82861: bool
 82861: nsHTMLEditor::IsBlockNode(nsINode *aNode)
 82861: {
 82861:   bool isBlock;
 82861:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aNode);
 82861:   NodeIsBlockStatic(node, &isBlock);
 82861:   return isBlock;
 82861: }
 82861: 
     1: // Non-static version for the nsIEditor interface and JavaScript
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SetDocumentTitle(const nsAString &aTitle)
     1: {
 27825:   nsRefPtr<SetDocTitleTxn> txn = new SetDocTitleTxn();
 43807:   NS_ENSURE_TRUE(txn, NS_ERROR_OUT_OF_MEMORY);
 27825: 
 27825:   nsresult result = txn->Init(this, &aTitle);
 43808:   NS_ENSURE_SUCCESS(result, result);
 27825: 
     1:   //Don't let Rules System change the selection
     1:   nsAutoTxnsConserveSelection dontChangeSelection(this);
 27825:   return nsEditor::DoTransaction(txn);  
     1: }
     1: 
     1: /* ------------ Block methods moved from nsEditor -------------- */
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetBlockNodeParent: returns enclosing block level ancestor, if any
     1: //
 75266: already_AddRefed<nsIDOMNode>
     1: nsHTMLEditor::GetBlockNodeParent(nsIDOMNode *aNode)
     1: {
     1:   if (!aNode)
     1:   {
     1:     NS_NOTREACHED("null node passed to GetBlockNodeParent()");
 84914:     return nsnull;
     1:   }
     1: 
 75266:   nsCOMPtr<nsIDOMNode> p;
     1:   if (NS_FAILED(aNode->GetParentNode(getter_AddRefs(p))))  // no parent, ran off top of tree
 75266:     return nsnull;
 75266: 
 75266:   nsCOMPtr<nsIDOMNode> tmp;
     1:   while (p)
     1:   {
 79445:     bool isBlock;
     1:     if (NS_FAILED(NodeIsBlockStatic(p, &isBlock)) || isBlock)
     1:       break;
     1:     if (NS_FAILED(p->GetParentNode(getter_AddRefs(tmp))) || !tmp) // no parent, ran off top of tree
 75266:       break;
     1: 
     1:     p = tmp;
     1:   }
 75266:   return p.forget();
     1: }
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // NextNodeInBlock: gets the next/prev node in the block, if any.  Next node
     1: //                  must be an element or text node, others are ignored
 75266: already_AddRefed<nsIDOMNode>
     1: nsHTMLEditor::NextNodeInBlock(nsIDOMNode *aNode, IterDirection aDir)
     1: {
 75266:   NS_ENSURE_TRUE(aNode, nsnull);
     1: 
     1:   nsresult rv;
     1:   nsCOMPtr<nsIContentIterator> iter =
     1:        do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &rv);
 75266:   NS_ENSURE_SUCCESS(rv, nsnull);
     1: 
     1:   // much gnashing of teeth as we twit back and forth between content and domnode types
 75266:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 75266:   nsCOMPtr<nsIDOMNode> blockParent;
 79445:   bool isBlock;
 75266:   if (NS_SUCCEEDED(NodeIsBlockStatic(aNode, &isBlock)) && isBlock) {
     1:     blockParent = aNode;
 75266:   } else {
     1:     blockParent = GetBlockNodeParent(aNode);
     1:   }
 75266:   NS_ENSURE_TRUE(blockParent, nsnull);
 75266:   nsCOMPtr<nsIContent> blockContent = do_QueryInterface(blockParent);
 75266:   NS_ENSURE_TRUE(blockContent, nsnull);
 75266:   
 75266:   if (NS_FAILED(iter->Init(blockContent))) {
 75266:     return nsnull;
 75266:   }
 75266:   if (NS_FAILED(iter->PositionAt(content))) {
 75266:     return nsnull;
 75266:   }
 75266:   
 75266:   while (!iter->IsDone()) {
     1:     // ignore nodes that aren't elements or text, or that are the
     1:     // block parent
 75266:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(iter->GetCurrentNode());
     1:     if (node && IsTextOrElementNode(node) && node != blockParent &&
     1:         node != aNode)
 75266:       return node.forget();
     1: 
     1:     if (aDir == kIterForward)
     1:       iter->Next();
     1:     else
     1:       iter->Prev();
     1:   }
     1:   
 75266:   return nsnull;
     1: }
     1: 
     1: static const PRUnichar nbsp = 160;
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // IsNextCharWhitespace: checks the adjacent content in the same block
     1: //                       to see if following selection is whitespace or nbsp
101070: void
     1: nsHTMLEditor::IsNextCharWhitespace(nsIDOMNode *aParentNode, 
     1:                                    PRInt32 aOffset,
 79445:                                    bool *outIsSpace,
 79445:                                    bool *outIsNBSP,
     1:                                    nsCOMPtr<nsIDOMNode> *outNode,
     1:                                    PRInt32 *outOffset)
     1: {
101070:   MOZ_ASSERT(outIsSpace && outIsNBSP);
 80486:   *outIsSpace = false;
 80486:   *outIsNBSP = false;
     1:   if (outNode) *outNode = nsnull;
     1:   if (outOffset) *outOffset = -1;
     1:   
     1:   nsAutoString tempString;
     1:   PRUint32 strLength;
     1:   nsCOMPtr<nsIDOMText> textNode = do_QueryInterface(aParentNode);
     1:   if (textNode)
     1:   {
     1:     textNode->GetLength(&strLength);
     1:     if ((PRUint32)aOffset < strLength)
     1:     {
     1:       // easy case: next char is in same node
     1:       textNode->SubstringData(aOffset,aOffset+1,tempString);
     1:       *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
     1:       *outIsNBSP = (tempString.First() == nbsp);
     1:       if (outNode) *outNode = do_QueryInterface(aParentNode);
     1:       if (outOffset) *outOffset = aOffset+1;  // yes, this is _past_ the character; 
101070:       return;
     1:     }
     1:   }
     1:   
     1:   // harder case: next char in next node.
     1:   nsCOMPtr<nsIDOMNode> node = NextNodeInBlock(aParentNode, kIterForward);
     1:   nsCOMPtr<nsIDOMNode> tmp;
     1:   while (node) 
     1:   {
 79445:     bool isBlock (false);
     1:     NodeIsBlock(node, &isBlock);
     1:     if (isBlock)  // skip over bold, italic, link, ect nodes
     1:     {
     1:       if (IsTextNode(node) && IsEditable(node))
     1:       {
     1:         textNode = do_QueryInterface(node);
     1:         textNode->GetLength(&strLength);
     1:         if (strLength)
     1:         {
     1:           textNode->SubstringData(0,1,tempString);
     1:           *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
     1:           *outIsNBSP = (tempString.First() == nbsp);
     1:           if (outNode) *outNode = do_QueryInterface(node);
     1:           if (outOffset) *outOffset = 1;  // yes, this is _past_ the character; 
101070:           return;
     1:         }
     1:         // else it's an empty text node, or not editable; skip it.
     1:       }
     1:       else  // node is an image or some other thingy that doesn't count as whitespace
     1:       {
     1:         break;
     1:       }
     1:     }
     1:     tmp = node;
     1:     node = NextNodeInBlock(tmp, kIterForward);
     1:   }
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // IsPrevCharWhitespace: checks the adjacent content in the same block
     1: //                       to see if following selection is whitespace
101070: void
     1: nsHTMLEditor::IsPrevCharWhitespace(nsIDOMNode *aParentNode, 
     1:                                    PRInt32 aOffset,
 79445:                                    bool *outIsSpace,
 79445:                                    bool *outIsNBSP,
     1:                                    nsCOMPtr<nsIDOMNode> *outNode,
     1:                                    PRInt32 *outOffset)
     1: {
101070:   MOZ_ASSERT(outIsSpace && outIsNBSP);
 80486:   *outIsSpace = false;
 80486:   *outIsNBSP = false;
     1:   if (outNode) *outNode = nsnull;
     1:   if (outOffset) *outOffset = -1;
     1:   
     1:   nsAutoString tempString;
     1:   PRUint32 strLength;
     1:   nsCOMPtr<nsIDOMText> textNode = do_QueryInterface(aParentNode);
     1:   if (textNode)
     1:   {
     1:     if (aOffset > 0)
     1:     {
     1:       // easy case: prev char is in same node
     1:       textNode->SubstringData(aOffset-1,aOffset,tempString);
     1:       *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
     1:       *outIsNBSP = (tempString.First() == nbsp);
     1:       if (outNode) *outNode = do_QueryInterface(aParentNode);
     1:       if (outOffset) *outOffset = aOffset-1;  
101070:       return;
     1:     }
     1:   }
     1:   
     1:   // harder case: prev char in next node
     1:   nsCOMPtr<nsIDOMNode> node = NextNodeInBlock(aParentNode, kIterBackward);
     1:   nsCOMPtr<nsIDOMNode> tmp;
     1:   while (node) 
     1:   {
 79445:     bool isBlock (false);
     1:     NodeIsBlock(node, &isBlock);
     1:     if (isBlock)  // skip over bold, italic, link, ect nodes
     1:     {
     1:       if (IsTextNode(node) && IsEditable(node))
     1:       {
     1:         textNode = do_QueryInterface(node);
     1:         textNode->GetLength(&strLength);
     1:         if (strLength)
     1:         {
     1:           // you could use nsIContent::TextIsOnlyWhitespace here
     1:           textNode->SubstringData(strLength-1,strLength,tempString);
     1:           *outIsSpace = nsCRT::IsAsciiSpace(tempString.First());
     1:           *outIsNBSP = (tempString.First() == nbsp);
     1:           if (outNode) *outNode = do_QueryInterface(aParentNode);
     1:           if (outOffset) *outOffset = strLength-1;  
101070:           return;
     1:         }
     1:         // else it's an empty text node, or not editable; skip it.
     1:       }
     1:       else  // node is an image or some other thingy that doesn't count as whitespace
     1:       {
     1:         break;
     1:       }
     1:     }
     1:     // otherwise we found a node we want to skip, keep going
     1:     tmp = node;
     1:     node = NextNodeInBlock(tmp, kIterBackward);
     1:   }
     1: }
     1: 
     1: 
     1: 
     1: /* ------------ End Block methods -------------- */
     1: 
     1: 
 79445: bool nsHTMLEditor::IsVisBreak(nsIDOMNode *aNode)
     1: {
 80486:   NS_ENSURE_TRUE(aNode, false);
     1:   if (!nsTextEditUtils::IsBreak(aNode)) 
 80486:     return false;
     1:   // check if there is a later node in block after br
     1:   nsCOMPtr<nsIDOMNode> priorNode, nextNode;
 80486:   GetPriorHTMLNode(aNode, address_of(priorNode), true); 
 80486:   GetNextHTMLNode(aNode, address_of(nextNode), true); 
     1:   // if we are next to another break, we are visible
     1:   if (priorNode && nsTextEditUtils::IsBreak(priorNode))
 80486:     return true;
     1:   if (nextNode && nsTextEditUtils::IsBreak(nextNode))
 80486:     return true;
     1:   
     1:   // if we are right before block boundary, then br not visible
 80486:   NS_ENSURE_TRUE(nextNode, false);  // this break is trailer in block, it's not visible
     1:   if (IsBlockNode(nextNode))
 80486:     return false; // break is right before a block, it's not visible
     1:     
     1:   // sigh.  We have to use expensive whitespace calculation code to 
     1:   // determine what is going on
     1:   nsCOMPtr<nsIDOMNode> selNode, tmp;
     1:   PRInt32 selOffset;
     1:   GetNodeLocation(aNode, address_of(selNode), &selOffset);
     1:   selOffset++; // lets look after the break
     1:   nsWSRunObject wsObj(this, selNode, selOffset);
     1:   nsCOMPtr<nsIDOMNode> visNode;
     1:   PRInt32 visOffset=0;
     1:   PRInt16 visType=0;
     1:   wsObj.NextVisibleNode(selNode, selOffset, address_of(visNode), &visOffset, &visType);
     1:   if (visType & nsWSRunObject::eBlock)
 80486:     return false;
 80486:   
 80486:   return true;
     1: }
     1: 
 57275: NS_IMETHODIMP
 79445: nsHTMLEditor::BreakIsVisible(nsIDOMNode *aNode, bool *aIsVisible)
 57275: {
 57275:   NS_ENSURE_ARG_POINTER(aNode && aIsVisible);
 57275: 
 57275:   *aIsVisible = IsVisBreak(aNode);
 57275: 
 57275:   return NS_OK;
 57275: }
 57275: 
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::GetIsDocumentEditable(bool *aIsDocumentEditable)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aIsDocumentEditable);
     1: 
 93880:   nsCOMPtr<nsIDOMDocument> doc = GetDOMDocument();
 93880:   *aIsDocumentEditable = doc && IsModifiable();
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool nsHTMLEditor::IsModifiable()
     1: {
 40703:   return !IsReadonly();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::UpdateBaseURL()
     1: {
 93880:   nsCOMPtr<nsIDOMDocument> domDoc = GetDOMDocument();
 43806:   NS_ENSURE_TRUE(domDoc, NS_ERROR_FAILURE);
     1: 
     1:   // Look for an HTML <base> tag
     1:   nsCOMPtr<nsIDOMNodeList> nodeList;
     1:   nsresult rv = domDoc->GetElementsByTagName(NS_LITERAL_STRING("base"), getter_AddRefs(nodeList));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsIDOMNode> baseNode;
     1:   if (nodeList)
     1:   {
     1:     PRUint32 count;
     1:     nodeList->GetLength(&count);
     1:     if (count >= 1)
     1:     {
     1:       rv = nodeList->Item(0, getter_AddRefs(baseNode));
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:   }
     1:   // If no base tag, then set baseURL to the document's URL
     1:   // This is very important, else relative URLs for links and images are wrong
     1:   if (!baseNode)
     1:   {
     1:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
 43806:     NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
     1: 
     1:     return doc->SetBaseURI(doc->GetDocumentURI());
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* This routine is needed to provide a bottleneck for typing for logging
     1:    purposes.  Can't use HandleKeyPress() (above) for that since it takes
     1:    a nsIDOMKeyEvent* parameter.  So instead we pass enough info through
     1:    to TypedText() to determine what action to take, but without passing
     1:    an event.
     1:    */
 99468: NS_IMETHODIMP
 99468: nsHTMLEditor::TypedText(const nsAString& aString, ETypingAction aAction)
     1: {
 13021:   nsAutoPlaceHolderBatch batch(this, nsGkAtoms::TypingTxnName);
     1: 
 99468:   if (aAction == eTypedBR) {
 99468:     // only inserts a br node
 99468:     nsCOMPtr<nsIDOMNode> brNode;
 99468:     return InsertBR(address_of(brNode));
 99468:   }
 99468: 
     1:   return nsPlaintextEditor::TypedText(aString, aAction);
     1: }
     1: 
 79445: NS_IMETHODIMP nsHTMLEditor::TabInTable(bool inIsShift, bool *outHandled)
     1: {
 43806:   NS_ENSURE_TRUE(outHandled, NS_ERROR_NULL_POINTER);
 80486:   *outHandled = false;
     1: 
     1:   // Find enclosing table cell from the selection (cell may be the selected element)
     1:   nsCOMPtr<nsIDOMElement> cellElement;
     1:     // can't use |NS_LITERAL_STRING| here until |GetElementOrParentByTagName| is fixed to accept readables
     1:   nsresult res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"), nsnull, getter_AddRefs(cellElement));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // Do nothing -- we didn't find a table cell
 43806:   NS_ENSURE_TRUE(cellElement, NS_OK);
     1: 
     1:   // find enclosing table
     1:   nsCOMPtr<nsIDOMNode> tbl = GetEnclosingTable(cellElement);
 43806:   NS_ENSURE_TRUE(tbl, res);
     1: 
     1:   // advance to next cell
     1:   // first create an iterator over the table
     1:   nsCOMPtr<nsIContentIterator> iter =
     1:       do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(iter, NS_ERROR_NULL_POINTER);
     1:   nsCOMPtr<nsIContent> cTbl = do_QueryInterface(tbl);
     1:   nsCOMPtr<nsIContent> cBlock = do_QueryInterface(cellElement);
     1:   res = iter->Init(cTbl);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   // position iter at block
     1:   res = iter->PositionAt(cBlock);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   do
     1:   {
     1:     if (inIsShift)
     1:       iter->Prev();
     1:     else
     1:       iter->Next();
     1: 
     1:     node = do_QueryInterface(iter->GetCurrentNode());
     1: 
     1:     if (node && nsHTMLEditUtils::IsTableCell(node) &&
     1:         GetEnclosingTable(node) == tbl)
     1:     {
     1:       res = CollapseSelectionToDeepestNonTableFirstChild(nsnull, node);
 43805:       NS_ENSURE_SUCCESS(res, res);
 80486:       *outHandled = true;
     1:       return NS_OK;
     1:     }
     1:   } while (!iter->IsDone());
     1:   
     1:   if (!(*outHandled) && !inIsShift)
     1:   {
     1:     // if we havent handled it yet then we must have run off the end of
     1:     // the table.  Insert a new row.
 80486:     res = InsertTableRow(1, true);
 80486:     NS_ENSURE_SUCCESS(res, res);
 80486:     *outHandled = true;
     1:     // put selection in right place
     1:     // Use table code to get selection and index to new row...
     1:     nsCOMPtr<nsISelection>selection;
     1:     nsCOMPtr<nsIDOMElement> tblElement;
     1:     nsCOMPtr<nsIDOMElement> cell;
     1:     PRInt32 row;
     1:     res = GetCellContext(getter_AddRefs(selection), 
     1:                          getter_AddRefs(tblElement),
     1:                          getter_AddRefs(cell), 
     1:                          nsnull, nsnull,
     1:                          &row, nsnull);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     // ...so that we can ask for first cell in that row...
     1:     res = GetCellAt(tblElement, row, 0, getter_AddRefs(cell));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     // ...and then set selection there.
     1:     // (Note that normally you should use CollapseSelectionToDeepestNonTableFirstChild(),
     1:     //  but we know cell is an empty new cell, so this works fine)
     1:     node = do_QueryInterface(cell);
     1:     if (node) selection->Collapse(node,0);
     1:     return NS_OK;
     1:   }
     1:   
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP nsHTMLEditor::CreateBR(nsIDOMNode *aNode, PRInt32 aOffset, nsCOMPtr<nsIDOMNode> *outBRNode, EDirection aSelect)
     1: {
     1:   nsCOMPtr<nsIDOMNode> parent = aNode;
     1:   PRInt32 offset = aOffset;
     1:   return CreateBRImpl(address_of(parent), &offset, outBRNode, aSelect);
     1: }
     1: 
     1: nsresult 
     1: nsHTMLEditor::CollapseSelectionToDeepestNonTableFirstChild(nsISelection *aSelection, nsIDOMNode *aNode)
     1: {
 43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
     1:   nsresult res;
     1: 
     1:   nsCOMPtr<nsISelection> selection;
     1:   if (aSelection)
     1:   {
     1:     selection = aSelection;
     1:   } else {
     1:     res = GetSelection(getter_AddRefs(selection));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
     1:   }
     1:   nsCOMPtr<nsIDOMNode> node = aNode;
     1:   nsCOMPtr<nsIDOMNode> child;
     1:   
     1:   do {
     1:     node->GetFirstChild(getter_AddRefs(child));
     1:     
     1:     if (child)
     1:     {
     1:       // Stop if we find a table
     1:       // don't want to go into nested tables
     1:       if (nsHTMLEditUtils::IsTable(child)) break;
     1:       // hey, it'g gotta be a container too!
     1:       if (!IsContainer(child)) break;
     1:       node = child;
     1:     }
     1:   }
     1:   while (child);
     1: 
     1:   selection->Collapse(node,0);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // This is mostly like InsertHTMLWithCharsetAndContext, 
     1: //  but we can't use that because it is selection-based and 
     1: //  the rules code won't let us edit under the <head> node
     1: NS_IMETHODIMP
     1: nsHTMLEditor::ReplaceHeadContentsWithHTML(const nsAString& aSourceToInsert)
     1: {
     1:   nsAutoRules beginRulesSniffing(this, kOpIgnore, nsIEditor::eNone); // don't do any post processing, rules get confused
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
     1:   ForceCompositionEnd();
     1: 
     1:   // Do not use nsAutoRules -- rules code won't let us insert in <head>
     1:   // Use the head node as a parent and delete/insert directly
     1:   nsCOMPtr<nsIDOMDocument> doc = do_QueryReferent(mDocWeak);
 43806:   NS_ENSURE_TRUE(doc, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIDOMNodeList>nodeList; 
     1:   res = doc->GetElementsByTagName(NS_LITERAL_STRING("head"), getter_AddRefs(nodeList));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(nodeList, NS_ERROR_NULL_POINTER);
     1: 
     1:   PRUint32 count; 
     1:   nodeList->GetLength(&count);
     1:   if (count < 1) return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIDOMNode> headNode;
     1:   res = nodeList->Item(0, getter_AddRefs(headNode)); 
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(headNode, NS_ERROR_NULL_POINTER);
     1: 
     1:   // First, make sure there are no return chars in the source.
     1:   // Bad things happen if you insert returns (instead of dom newlines, \n)
     1:   // into an editor document.
     1:   nsAutoString inputString (aSourceToInsert);  // hope this does copy-on-write
     1:  
     1:   // Windows linebreaks: Map CRLF to LF:
     1:   inputString.ReplaceSubstring(NS_LITERAL_STRING("\r\n").get(),
     1:                                NS_LITERAL_STRING("\n").get());
     1:  
     1:   // Mac linebreaks: Map any remaining CR to LF:
     1:   inputString.ReplaceSubstring(NS_LITERAL_STRING("\r").get(),
     1:                                NS_LITERAL_STRING("\n").get());
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1: 
     1:   res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Get the first range in the selection, for context:
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = selection->GetRangeAt(0, getter_AddRefs(range));
 43808:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMDocumentFragment> docfrag;
 86938:   res = range->CreateContextualFragment(inputString,
     1:                                         getter_AddRefs(docfrag));
     1: 
     1:   //XXXX BUG 50965: This is not returning the text between <title> ... </title>
     1:   // Special code is needed in JS to handle title anyway, so it really doesn't matter!
     1: 
     1:   if (NS_FAILED(res))
     1:   {
     1: #ifdef DEBUG
     1:     printf("Couldn't create contextual fragment: error was %d\n", res);
     1: #endif
     1:     return res;
     1:   }
 43806:   NS_ENSURE_TRUE(docfrag, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIDOMNode> child;
     1: 
     1:   // First delete all children in head
     1:   do {
     1:     res = headNode->GetFirstChild(getter_AddRefs(child));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if (child)
     1:     {
     1:       res = DeleteNode(child);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:   } while (child);
     1: 
     1:   // Now insert the new nodes
     1:   PRInt32 offsetOfNewNode = 0;
     1:   nsCOMPtr<nsIDOMNode> fragmentAsNode (do_QueryInterface(docfrag));
     1: 
     1:   // Loop over the contents of the fragment and move into the document
     1:   do {
     1:     res = fragmentAsNode->GetFirstChild(getter_AddRefs(child));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if (child)
     1:     {
     1:       res = InsertNode(child, headNode, offsetOfNewNode++);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:   } while (child);
     1: 
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::RebuildDocumentFromSource(const nsAString& aSourceString)
     1: {
     1:   ForceCompositionEnd();
     1: 
     1:   nsCOMPtr<nsISelection>selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
 83343:   nsCOMPtr<nsIDOMElement> bodyElement = do_QueryInterface(GetRoot());
 43806:   NS_ENSURE_TRUE(bodyElement, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Find where the <body> tag starts.
     1:   nsReadingIterator<PRUnichar> beginbody;
     1:   nsReadingIterator<PRUnichar> endbody;
     1:   aSourceString.BeginReading(beginbody);
     1:   aSourceString.EndReading(endbody);
 79445:   bool foundbody = CaseInsensitiveFindInReadable(NS_LITERAL_STRING("<body"),
     1:                                                    beginbody, endbody);
     1: 
     1:   nsReadingIterator<PRUnichar> beginhead;
     1:   nsReadingIterator<PRUnichar> endhead;
     1:   aSourceString.BeginReading(beginhead);
     1:   aSourceString.EndReading(endhead);
 79445:   bool foundhead = CaseInsensitiveFindInReadable(NS_LITERAL_STRING("<head"),
     1:                                                    beginhead, endhead);
     1: 
     1:   nsReadingIterator<PRUnichar> beginclosehead;
     1:   nsReadingIterator<PRUnichar> endclosehead;
     1:   aSourceString.BeginReading(beginclosehead);
     1:   aSourceString.EndReading(endclosehead);
     1: 
     1:   // Find the index after "<head>"
 79445:   bool foundclosehead = CaseInsensitiveFindInReadable(
     1:            NS_LITERAL_STRING("</head>"), beginclosehead, endclosehead);
     1:   
     1:   // Time to change the document
     1:   nsAutoEditBatch beginBatching(this);
     1: 
     1:   nsReadingIterator<PRUnichar> endtotal;
     1:   aSourceString.EndReading(endtotal);
     1: 
     1:   if (foundhead) {
     1:     if (foundclosehead)
     1:       res = ReplaceHeadContentsWithHTML(Substring(beginhead, beginclosehead));
     1:     else if (foundbody)
     1:       res = ReplaceHeadContentsWithHTML(Substring(beginhead, beginbody));
     1:     else
     1:       // XXX Without recourse to some parser/content sink/docshell hackery
     1:       // we don't really know where the head ends and the body begins
     1:       // so we assume that there is no body
     1:       res = ReplaceHeadContentsWithHTML(Substring(beginhead, endtotal));
     1:   } else {
     1:     nsReadingIterator<PRUnichar> begintotal;
     1:     aSourceString.BeginReading(begintotal);
     1:     NS_NAMED_LITERAL_STRING(head, "<head>");
     1:     if (foundclosehead)
     1:       res = ReplaceHeadContentsWithHTML(head + Substring(begintotal, beginclosehead));
     1:     else if (foundbody)
     1:       res = ReplaceHeadContentsWithHTML(head + Substring(begintotal, beginbody));
     1:     else
     1:       // XXX Without recourse to some parser/content sink/docshell hackery
     1:       // we don't really know where the head ends and the body begins
     1:       // so we assume that there is no head
     1:       res = ReplaceHeadContentsWithHTML(head);
     1:   }
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   res = SelectAll();
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   if (!foundbody) {
     1:     NS_NAMED_LITERAL_STRING(body, "<body>");
     1:     // XXX Without recourse to some parser/content sink/docshell hackery
     1:     // we don't really know where the head ends and the body begins
     1:     if (foundclosehead) // assume body starts after the head ends
     1:       res = LoadHTML(body + Substring(endclosehead, endtotal));
     1:     else if (foundhead) // assume there is no body
     1:       res = LoadHTML(body);
     1:     else // assume there is no head, the entire source is body
     1:       res = LoadHTML(body + aSourceString);
 43808:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     nsCOMPtr<nsIDOMElement> divElement;
     1:     res = CreateElementWithDefaults(NS_LITERAL_STRING("div"), getter_AddRefs(divElement));
 43808:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     res = CloneAttributes(bodyElement, divElement);
 43808:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     return BeginningOfDocument();
     1:   }
     1: 
     1:   res = LoadHTML(Substring(beginbody, endtotal));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // Now we must copy attributes user might have edited on the <body> tag
     1:   //  because InsertHTML (actually, CreateContextualFragment()) 
     1:   //  will never return a body node in the DOM fragment
     1:   
     1:   // We already know where "<body" begins
     1:   nsReadingIterator<PRUnichar> beginclosebody = beginbody;
     1:   nsReadingIterator<PRUnichar> endclosebody;
     1:   aSourceString.EndReading(endclosebody);
     1:   if (!FindInReadable(NS_LITERAL_STRING(">"),beginclosebody,endclosebody))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   // Truncate at the end of the body tag
     1:   // Kludge of the year: fool the parser by replacing "body" with "div" so we get a node
     1:   nsAutoString bodyTag;
     1:   bodyTag.AssignLiteral("<div ");
     1:   bodyTag.Append(Substring(endbody, endclosebody));
     1: 
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = selection->GetRangeAt(0, getter_AddRefs(range));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMDocumentFragment> docfrag;
 86938:   res = range->CreateContextualFragment(bodyTag, getter_AddRefs(docfrag));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMNode> fragmentAsNode (do_QueryInterface(docfrag));
 43806:   NS_ENSURE_TRUE(fragmentAsNode, NS_ERROR_NULL_POINTER);
     1:   
     1:   nsCOMPtr<nsIDOMNode> child;
     1:   res = fragmentAsNode->GetFirstChild(getter_AddRefs(child));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(child, NS_ERROR_NULL_POINTER);
     1:   
     1:   // Copy all attributes from the div child to current body element
     1:   res = CloneAttributes(bodyElement, child);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // place selection at first editable content
     1:   return BeginningOfDocument();
     1: }
     1: 
     1: void
     1: nsHTMLEditor::NormalizeEOLInsertPosition(nsIDOMNode *firstNodeToInsert,
     1:                                      nsCOMPtr<nsIDOMNode> *insertParentNode,
     1:                                      PRInt32 *insertOffset)
     1: {
     1:   /*
     1:     This function will either correct the position passed in,
     1:     or leave the position unchanged.
     1: 
     1:     When the (first) item to insert is a block level element, 
     1:     and our insertion position is after the last visible item in a line, 
     1:     i.e. the insertion position is just before a visible line break <br>, 
     1:     we want to skip to the position just after the line break (see bug 68767)
     1: 
     1:     However, our logic to detect whether we should skip or not
     1:     needs to be more clever.
     1:     We must not skip when the caret appears to be positioned at the beginning
     1:     of a block, in that case skipping the <br> would not insert the <br>
     1:     at the caret position, but after the current empty line.
     1:      
     1:     So we have several cases to test:
     1:      
     1:     1) We only ever want to skip, if the next visible thing after the current position is a break
     1:      
     1:     2) We do not want to skip if there is no previous visible thing at all
     1:        That is detected if the call to PriorVisibleNode gives us an offset of zero.
     1:        Because PriorVisibleNode always positions after the prior node, we would
     1:        see an offset > 0, if there were a prior node.
     1:      
     1:     3) We do not want to skip, if both the next and the previous visible things are breaks.
     1:     
     1:     4) We do not want to skip if the previous visible thing is in a different block
     1:        than the insertion position.
     1:   */
     1: 
     1:   if (!IsBlockNode(firstNodeToInsert))
     1:     return;
     1: 
     1:   nsWSRunObject wsObj(this, *insertParentNode, *insertOffset);
     1:   nsCOMPtr<nsIDOMNode> nextVisNode;
     1:   nsCOMPtr<nsIDOMNode> prevVisNode;
     1:   PRInt32 nextVisOffset=0;
     1:   PRInt16 nextVisType=0;
     1:   PRInt32 prevVisOffset=0;
     1:   PRInt16 prevVisType=0;
     1: 
     1:   wsObj.NextVisibleNode(*insertParentNode, *insertOffset, address_of(nextVisNode), &nextVisOffset, &nextVisType);
     1:   if (!nextVisNode)
     1:     return;
     1: 
     1:   if (! (nextVisType & nsWSRunObject::eBreak))
     1:     return;
     1: 
     1:   wsObj.PriorVisibleNode(*insertParentNode, *insertOffset, address_of(prevVisNode), &prevVisOffset, &prevVisType);
     1:   if (!prevVisNode)
     1:     return;
     1: 
     1:   if (prevVisType & nsWSRunObject::eBreak)
     1:     return;
     1: 
     1:   if (prevVisType & nsWSRunObject::eThisBlock)
     1:     return;
     1: 
     1:   nsCOMPtr<nsIDOMNode> brNode;
     1:   PRInt32 brOffset=0;
     1: 
     1:   GetNodeLocation(nextVisNode, address_of(brNode), &brOffset);
     1: 
     1:   *insertParentNode = brNode;
     1:   *insertOffset = brOffset + 1;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::InsertElementAtSelection(nsIDOMElement* aElement, bool aDeleteSelection)
     1: {
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
     1:   nsresult res = NS_ERROR_NOT_INITIALIZED;
     1:   
 43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
     1:   
     1:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aElement);
     1:   
     1:   ForceCompositionEnd();
     1:   nsAutoEditBatch beginBatching(this);
     1:   nsAutoRules beginRulesSniffing(this, kOpInsertElement, nsIEditor::eNext);
     1: 
 99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
 99469:   if (!selection) {
     1:     return NS_ERROR_FAILURE;
 99469:   }
     1: 
     1:   // hand off to the rules system, see if it has anything to say about this
 79445:   bool cancel, handled;
 97808:   nsTextRulesInfo ruleInfo(kOpInsertElement);
     1:   ruleInfo.insertElement = aElement;
     1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
     1:   if (cancel || (NS_FAILED(res))) return res;
     1: 
     1:   if (!handled)
     1:   {
     1:     if (aDeleteSelection)
     1:     {
 98852:       if (!IsBlockNode(aElement)) {
 98852:         // E.g., inserting an image.  In this case we don't need to delete any
 98852:         // inline wrappers before we do the insertion.  Otherwise we let
 98852:         // DeleteSelectionAndPrepareToCreateNode do the deletion for us, which
 98852:         // calls DeleteSelection with aStripWrappers = eStrip.
 98852:         res = DeleteSelection(nsIEditor::eNone, nsIEditor::eNoStrip);
 98852:         NS_ENSURE_SUCCESS(res, res);
 98852:       }
 98852: 
     1:       nsCOMPtr<nsIDOMNode> tempNode;
     1:       PRInt32 tempOffset;
     1:       nsresult result = DeleteSelectionAndPrepareToCreateNode(tempNode,tempOffset);
 43808:       NS_ENSURE_SUCCESS(result, result);
     1:     }
     1: 
     1:     // If deleting, selection will be collapsed.
     1:     // so if not, we collapse it
     1:     if (!aDeleteSelection)
     1:     {
     1:       // Named Anchor is a special case,
     1:       // We collapse to insert element BEFORE the selection
     1:       // For all other tags, we insert AFTER the selection
     1:       if (nsHTMLEditUtils::IsNamedAnchor(node))
     1:       {
     1:         selection->CollapseToStart();
     1:       } else {
     1:         selection->CollapseToEnd();
     1:       }
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMNode> parentSelectedNode;
     1:     PRInt32 offsetForInsert;
     1:     res = selection->GetAnchorNode(getter_AddRefs(parentSelectedNode));
     1:     // XXX: ERROR_HANDLING bad XPCOM usage
     1:     if (NS_SUCCEEDED(res) && NS_SUCCEEDED(selection->GetAnchorOffset(&offsetForInsert)) && parentSelectedNode)
     1:     {
     1: #ifdef DEBUG_cmanske
     1:       {
     1:       nsAutoString name;
     1:       parentSelectedNode->GetNodeName(name);
     1:       printf("InsertElement: Anchor node of selection: ");
     1:       wprintf(name.get());
     1:       printf(" Offset: %d\n", offsetForInsert);
     1:       }
     1: #endif
     1: 
     1:       // Adjust position based on the node we are going to insert.
     1:       NormalizeEOLInsertPosition(node, address_of(parentSelectedNode), &offsetForInsert);
     1: 
 80486:       res = InsertNodeAtPoint(node, address_of(parentSelectedNode), &offsetForInsert, false);
     1:       NS_ENSURE_SUCCESS(res, res);
     1:       // Set caret after element, but check for special case 
     1:       //  of inserting table-related elements: set in first cell instead
     1:       if (!SetCaretInTableCell(aElement))
     1:       {
     1:         res = SetCaretAfterElement(aElement);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:       // check for inserting a whole table at the end of a block. If so insert a br after it.
     1:       if (nsHTMLEditUtils::IsTable(node))
     1:       {
 79445:         bool isLast;
     1:         res = IsLastEditableChild(node, &isLast);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         if (isLast)
     1:         {
     1:           nsCOMPtr<nsIDOMNode> brNode;
     1:           res = CreateBR(parentSelectedNode, offsetForInsert+1, address_of(brNode));
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:           selection->Collapse(parentSelectedNode, offsetForInsert+1);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
     1:   return res;
     1: }
     1: 
     1: 
     1: /* 
     1:   InsertNodeAtPoint: attempts to insert aNode into the document, at a point specified by 
     1:       {*ioParent,*ioOffset}.  Checks with strict dtd to see if containment is allowed.  If not
 41545:       allowed, will attempt to find a parent in the parent hierarchy of *ioParent that will
     1:       accept aNode as a child.  If such a parent is found, will split the document tree from
     1:       {*ioParent,*ioOffset} up to parent, and then insert aNode.  ioParent & ioOffset are then
     1:       adjusted to point to the actual location that aNode was inserted at.  aNoEmptyNodes
     1:       specifies if the splitting process is allowed to reslt in empty nodes.
     1:               nsIDOMNode            *aNode           node to insert
     1:               nsCOMPtr<nsIDOMNode>  *ioParent        insertion parent
     1:               PRInt32               *ioOffset        insertion offset
 79445:               bool                  aNoEmptyNodes    splitting can result in empty nodes?
     1: */
     1: nsresult
     1: nsHTMLEditor::InsertNodeAtPoint(nsIDOMNode *aNode, 
     1:                                 nsCOMPtr<nsIDOMNode> *ioParent, 
     1:                                 PRInt32 *ioOffset, 
 79445:                                 bool aNoEmptyNodes)
     1: {
     1:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
     1:   NS_ENSURE_TRUE(ioParent, NS_ERROR_NULL_POINTER);
     1:   NS_ENSURE_TRUE(*ioParent, NS_ERROR_NULL_POINTER);
     1:   NS_ENSURE_TRUE(ioOffset, NS_ERROR_NULL_POINTER);
     1:   
     1:   nsresult res = NS_OK;
     1:   nsCOMPtr<nsIDOMNode> parent = *ioParent;
     1:   nsCOMPtr<nsIDOMNode> topChild = *ioParent;
     1:   nsCOMPtr<nsIDOMNode> tmp;
     1:   PRInt32 offsetOfInsert = *ioOffset;
     1:    
     1:   // Search up the parent chain to find a suitable container      
 97375:   while (!CanContain(parent, aNode)) {
     1:     // If the current parent is a root (body or table element)
     1:     // then go no further - we can't insert
     1:     if (nsTextEditUtils::IsBody(parent) || nsHTMLEditUtils::IsTableElement(parent))
     1:       return NS_ERROR_FAILURE;
     1:     // Get the next parent
     1:     parent->GetParentNode(getter_AddRefs(tmp));
     1:     NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
     1:     topChild = parent;
     1:     parent = tmp;
     1:   }
     1:   if (parent != topChild)
     1:   {
     1:     // we need to split some levels above the original selection parent
     1:     res = SplitNodeDeep(topChild, *ioParent, *ioOffset, &offsetOfInsert, aNoEmptyNodes);
 43808:     NS_ENSURE_SUCCESS(res, res);
     1:     *ioParent = parent;
     1:     *ioOffset = offsetOfInsert;
     1:   }
     1:   // Now we can insert the new node
     1:   res = InsertNode(aNode, parent, offsetOfInsert);
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::SelectElement(nsIDOMElement* aElement)
     1: {
     1:   nsresult res = NS_ERROR_NULL_POINTER;
     1: 
     1:   // Must be sure that element is contained in the document body
 97989:   if (IsDescendantOfEditorRoot(aElement)) {
     1:     nsCOMPtr<nsISelection> selection;
     1:     res = GetSelection(getter_AddRefs(selection));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1:     nsCOMPtr<nsIDOMNode>parent;
     1:     res = aElement->GetParentNode(getter_AddRefs(parent));
     1:     if (NS_SUCCEEDED(res) && parent)
     1:     {
     1:       PRInt32 offsetInParent;
     1:       res = GetChildOffset(aElement, parent, offsetInParent);
     1: 
     1:       if (NS_SUCCEEDED(res))
     1:       {
     1:         // Collapse selection to just before desired element,
     1:         res = selection->Collapse(parent, offsetInParent);
     1:         if (NS_SUCCEEDED(res)) {
     1:           //  then extend it to just after
     1:           res = selection->Extend(parent, offsetInParent+1);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::SetCaretAfterElement(nsIDOMElement* aElement)
     1: {
     1:   nsresult res = NS_ERROR_NULL_POINTER;
     1: 
     1:   // Be sure the element is contained in the document body
 97989:   if (aElement && IsDescendantOfEditorRoot(aElement)) {
     1:     nsCOMPtr<nsISelection> selection;
     1:     res = GetSelection(getter_AddRefs(selection));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1:     nsCOMPtr<nsIDOMNode>parent;
     1:     res = aElement->GetParentNode(getter_AddRefs(parent));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(parent, NS_ERROR_NULL_POINTER);
     1:     PRInt32 offsetInParent;
     1:     res = GetChildOffset(aElement, parent, offsetInParent);
     1:     if (NS_SUCCEEDED(res))
     1:     {
     1:       // Collapse selection to just after desired element,
     1:       res = selection->Collapse(parent, offsetInParent+1);
     1: #if 0 //def DEBUG_cmanske
     1:       {
     1:       nsAutoString name;
     1:       parent->GetNodeName(name);
     1:       printf("SetCaretAfterElement: Parent node: ");
     1:       wprintf(name.get());
     1:       printf(" Offset: %d\n\nHTML:\n", offsetInParent+1);
     1:       nsAutoString Format("text/html");
     1:       nsAutoString ContentsAs;
     1:       OutputToString(Format, 2, ContentsAs);
     1:       wprintf(ContentsAs.get());
     1:       }
     1: #endif
     1:     }
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SetParagraphFormat(const nsAString& aParagraphFormat)
     1: {
     1:   nsAutoString tag; tag.Assign(aParagraphFormat);
     1:   ToLowerCase(tag);
     1:   if (tag.EqualsLiteral("dd") || tag.EqualsLiteral("dt"))
     1:     return MakeDefinitionItem(tag);
     1:   else
     1:     return InsertBasicBlock(tag);
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: nsHTMLEditor::GetParagraphState(bool *aMixed, nsAString &outFormat)
     1: {
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
 43806:   NS_ENSURE_TRUE(aMixed, NS_ERROR_NULL_POINTER);
 69469:   nsHTMLEditRules* htmlRules = static_cast<nsHTMLEditRules*>(mRules.get());
 43806:   NS_ENSURE_TRUE(htmlRules, NS_ERROR_FAILURE);
     1:   
     1:   return htmlRules->GetParagraphState(aMixed, outFormat);
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::GetBackgroundColorState(bool *aMixed, nsAString &aOutColor)
     1: {
     1:   nsresult res;
 89175:   if (IsCSSEnabled()) {
     1:     // if we are in CSS mode, we have to check if the containing block defines
     1:     // a background color
 80486:     res = GetCSSBackgroundColorState(aMixed, aOutColor, true);
     1:   }
     1:   else {
     1:     // in HTML mode, we look only at page's background
     1:     res = GetHTMLBackgroundColorState(aMixed, aOutColor);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::GetHighlightColorState(bool *aMixed, nsAString &aOutColor)
     1: {
     1:   nsresult res = NS_OK;
 80486:   *aMixed = false;
     1:   aOutColor.AssignLiteral("transparent");
 89175:   if (IsCSSEnabled()) {
     1:     // in CSS mode, text background can be added by the Text Highlight button
     1:     // we need to query the background of the selection without looking for
     1:     // the block container of the ranges in the selection
 80486:     res = GetCSSBackgroundColorState(aMixed, aOutColor, false);
     1:   }
     1:   return res;
     1: }
     1: 
     1: nsresult
 79445: nsHTMLEditor::GetCSSBackgroundColorState(bool *aMixed, nsAString &aOutColor, bool aBlockLevel)
     1: {
 43806:   NS_ENSURE_TRUE(aMixed, NS_ERROR_NULL_POINTER);
 80486:   *aMixed = false;
     1:   // the default background color is transparent
     1:   aOutColor.AssignLiteral("transparent");
     1:   
     1:   // get selection
     1:   nsCOMPtr<nsISelection>selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // get selection location
     1:   nsCOMPtr<nsIDOMNode> parent;
     1:   PRInt32 offset;
 43518:   res = GetStartNodeAndOffset(selection, getter_AddRefs(parent), &offset);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(parent, NS_ERROR_NULL_POINTER);
     1: 
     1:   // is the selection collapsed?
     1:   nsCOMPtr<nsIDOMNode> nodeToExamine;
 98815:   if (selection->Collapsed() || IsTextNode(parent)) {
     1:     // we want to look at the parent and ancestors
     1:     nodeToExamine = parent;
 98815:   } else {
     1:     // otherwise we want to look at the first editable node after
 90153:     // {parent,offset} and its ancestors for divs with alignment on them
     1:     nodeToExamine = GetChildAt(parent, offset);
 80486:     //GetNextNode(parent, offset, true, address_of(nodeToExamine));
     1:   }
     1:   
 43806:   NS_ENSURE_TRUE(nodeToExamine, NS_ERROR_NULL_POINTER);
     1: 
     1:   // is the node to examine a block ?
 79445:   bool isBlock;
     1:   res = NodeIsBlockStatic(nodeToExamine, &isBlock);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMNode> tmp;
     1: 
     1:   if (aBlockLevel) {
     1:     // we are querying the block background (and not the text background), let's
     1:     // climb to the block container
     1:     nsCOMPtr<nsIDOMNode> blockParent = nodeToExamine;
     1:     if (!isBlock) {
     1:       blockParent = GetBlockNodeParent(nodeToExamine);
 43807:       NS_ENSURE_TRUE(blockParent, NS_OK);
     1:     }
     1: 
     1:     // Make sure to not walk off onto the Document node
     1:     nsCOMPtr<nsIDOMElement> element;
     1:     do {
     1:       // retrieve the computed style of background-color for blockParent
     1:       mHTMLCSSUtils->GetComputedProperty(blockParent,
     1:                                          nsEditProperty::cssBackgroundColor,
     1:                                          aOutColor);
     1:       tmp.swap(blockParent);
     1:       res = tmp->GetParentNode(getter_AddRefs(blockParent));
     1:       element = do_QueryInterface(blockParent);
     1:       // look at parent if the queried color is transparent and if the node to
     1:       // examine is not the root of the document
     1:     } while (aOutColor.EqualsLiteral("transparent") && element);
     1:     if (aOutColor.EqualsLiteral("transparent")) {
     1:       // we have hit the root of the document and the color is still transparent !
     1:       // Grumble... Let's look at the default background color because that's the
     1:       // color we are looking for
     1:       mHTMLCSSUtils->GetDefaultBackgroundColor(aOutColor);
     1:     }
     1:   }
     1:   else {
     1:     // no, we are querying the text background for the Text Highlight button
     1:     if (IsTextNode(nodeToExamine)) {
     1:       // if the node of interest is a text node, let's climb a level
     1:       res = nodeToExamine->GetParentNode(getter_AddRefs(parent));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       nodeToExamine = parent;
     1:     }
     1:     do {
     1:       // is the node to examine a block ?
     1:       res = NodeIsBlockStatic(nodeToExamine, &isBlock);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       if (isBlock) {
     1:         // yes it is a block; in that case, the text background color is transparent
     1:         aOutColor.AssignLiteral("transparent");
     1:         break;
     1:       }
     1:       else {
     1:         // no, it's not; let's retrieve the computed style of background-color for the
     1:         // node to examine
     1:         mHTMLCSSUtils->GetComputedProperty(nodeToExamine, nsEditProperty::cssBackgroundColor,
     1:                             aOutColor);
     1:         if (!aOutColor.EqualsLiteral("transparent")) {
     1:           break;
     1:         }
     1:       }
     1:       tmp.swap(nodeToExamine);
     1:       res = tmp->GetParentNode(getter_AddRefs(nodeToExamine));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     } while ( aOutColor.EqualsLiteral("transparent") && nodeToExamine );
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: nsHTMLEditor::GetHTMLBackgroundColorState(bool *aMixed, nsAString &aOutColor)
     1: {
     1:   //TODO: We don't handle "mixed" correctly!
 43806:   NS_ENSURE_TRUE(aMixed, NS_ERROR_NULL_POINTER);
 80486:   *aMixed = false;
     1:   aOutColor.Truncate();
     1:   
 89180:   nsCOMPtr<nsIDOMElement> domElement;
     1:   PRInt32 selectedCount;
     1:   nsAutoString tagName;
     1:   nsresult res = GetSelectedOrParentTableElement(tagName,
     1:                                                  &selectedCount,
 89180:                                                  getter_AddRefs(domElement));
 89180:   NS_ENSURE_SUCCESS(res, res);
 89180: 
101131:   nsCOMPtr<dom::Element> element = do_QueryInterface(domElement);
 89180: 
 89180:   while (element) {
     1:     // We are in a cell or selected table
101131:     element->GetAttr(kNameSpaceID_None, nsGkAtoms::bgcolor, aOutColor);
     1: 
     1:     // Done if we have a color explicitly set
 89180:     if (!aOutColor.IsEmpty()) {
     1:       return NS_OK;
 89180:     }
     1: 
     1:     // Once we hit the body, we're done
101131:     if (element->IsHTML(nsGkAtoms::body)) {
 89180:       return NS_OK;
 89180:     }
     1: 
     1:     // No color is set, but we need to report visible color inherited 
     1:     // from nested cells/tables, so search up parent chain
 89180:     element = element->GetElementParent();
     1:   }
     1: 
     1:   // If no table or cell found, get page body
 89180:   dom::Element* bodyElement = GetRoot();
 83343:   NS_ENSURE_TRUE(bodyElement, NS_ERROR_NULL_POINTER);
 83343: 
 89180:   bodyElement->GetAttr(kNameSpaceID_None, nsGkAtoms::bgcolor, aOutColor);
 89180:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: nsHTMLEditor::GetListState(bool *aMixed, bool *aOL, bool *aUL, bool *aDL)
     1: {
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
 43806:   NS_ENSURE_TRUE(aMixed && aOL && aUL && aDL, NS_ERROR_NULL_POINTER);
 69469:   nsHTMLEditRules* htmlRules = static_cast<nsHTMLEditRules*>(mRules.get());
 43806:   NS_ENSURE_TRUE(htmlRules, NS_ERROR_FAILURE);
     1:   
     1:   return htmlRules->GetListState(aMixed, aOL, aUL, aDL);
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: nsHTMLEditor::GetListItemState(bool *aMixed, bool *aLI, bool *aDT, bool *aDD)
     1: {
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
 43806:   NS_ENSURE_TRUE(aMixed && aLI && aDT && aDD, NS_ERROR_NULL_POINTER);
     1: 
 69469:   nsHTMLEditRules* htmlRules = static_cast<nsHTMLEditRules*>(mRules.get());
 43806:   NS_ENSURE_TRUE(htmlRules, NS_ERROR_FAILURE);
     1:   
     1:   return htmlRules->GetListItemState(aMixed, aLI, aDT, aDD);
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::GetAlignment(bool *aMixed, nsIHTMLEditor::EAlignment *aAlign)
     1: {
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
 43806:   NS_ENSURE_TRUE(aMixed && aAlign, NS_ERROR_NULL_POINTER);
 69469:   nsHTMLEditRules* htmlRules = static_cast<nsHTMLEditRules*>(mRules.get());
 43806:   NS_ENSURE_TRUE(htmlRules, NS_ERROR_FAILURE);
     1:   
     1:   return htmlRules->GetAlignment(aMixed, aAlign);
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
 79445: nsHTMLEditor::GetIndentState(bool *aCanIndent, bool *aCanOutdent)
     1: {
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
 43806:   NS_ENSURE_TRUE(aCanIndent && aCanOutdent, NS_ERROR_NULL_POINTER);
     1: 
 69469:   nsHTMLEditRules* htmlRules = static_cast<nsHTMLEditRules*>(mRules.get());
 43806:   NS_ENSURE_TRUE(htmlRules, NS_ERROR_FAILURE);
     1:   
     1:   return htmlRules->GetIndentState(aCanIndent, aCanOutdent);
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::MakeOrChangeList(const nsAString& aListType, bool entireList, const nsAString& aBulletType)
     1: {
     1:   nsresult res;
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
     1: 
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
 79445:   bool cancel, handled;
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   nsAutoRules beginRulesSniffing(this, kOpMakeList, nsIEditor::eNext);
     1:   
     1:   // pre-process
 99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
 97808:   nsTextRulesInfo ruleInfo(kOpMakeList);
     1:   ruleInfo.blockType = &aListType;
     1:   ruleInfo.entireList = entireList;
     1:   ruleInfo.bulletType = &aBulletType;
     1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
     1:   if (cancel || (NS_FAILED(res))) return res;
     1: 
     1:   if (!handled)
     1:   {
     1:     // Find out if the selection is collapsed:
 98815:     bool isCollapsed = selection->Collapsed();
     1: 
     1:     nsCOMPtr<nsIDOMNode> node;
     1:     PRInt32 offset;
 43518:     res = GetStartNodeAndOffset(selection, getter_AddRefs(node), &offset);
     1:     if (!node) res = NS_ERROR_FAILURE;
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   
     1:     if (isCollapsed)
     1:     {
     1:       // have to find a place to put the list
     1:       nsCOMPtr<nsIDOMNode> parent = node;
     1:       nsCOMPtr<nsIDOMNode> topChild = node;
     1:       nsCOMPtr<nsIDOMNode> tmp;
     1:     
 97376:       nsCOMPtr<nsIAtom> listAtom = do_GetAtom(aListType);
 97376:       while (!CanContainTag(parent, listAtom)) {
     1:         parent->GetParentNode(getter_AddRefs(tmp));
 43806:         NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
     1:         topChild = parent;
     1:         parent = tmp;
     1:       }
     1:     
     1:       if (parent != node)
     1:       {
     1:         // we need to split up to the child of parent
     1:         res = SplitNodeDeep(topChild, node, offset, &offset);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1: 
     1:       // make a list
     1:       nsCOMPtr<nsIDOMNode> newList;
     1:       res = CreateNode(aListType, parent, offset, getter_AddRefs(newList));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       // make a list item
     1:       nsCOMPtr<nsIDOMNode> newItem;
     1:       res = CreateNode(NS_LITERAL_STRING("li"), newList, 0, getter_AddRefs(newItem));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       res = selection->Collapse(newItem,0);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:   }
     1:   
     1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
     1:   return res;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::RemoveList(const nsAString& aListType)
     1: {
     1:   nsresult res;
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
     1: 
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
 79445:   bool cancel, handled;
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   nsAutoRules beginRulesSniffing(this, kOpRemoveList, nsIEditor::eNext);
     1:   
     1:   // pre-process
 99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
 97808:   nsTextRulesInfo ruleInfo(kOpRemoveList);
     1:   if (aListType.LowerCaseEqualsLiteral("ol"))
 80486:     ruleInfo.bOrdered = true;
 80486:   else  ruleInfo.bOrdered = false;
     1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
     1:   if (cancel || (NS_FAILED(res))) return res;
     1: 
     1:   // no default behavior for this yet.  what would it mean?
     1: 
     1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
     1:   return res;
     1: }
     1: 
     1: nsresult
     1: nsHTMLEditor::MakeDefinitionItem(const nsAString& aItemType)
     1: {
     1:   nsresult res;
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
     1: 
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
 79445:   bool cancel, handled;
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   nsAutoRules beginRulesSniffing(this, kOpMakeDefListItem, nsIEditor::eNext);
     1:   
     1:   // pre-process
 99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
 97808:   nsTextRulesInfo ruleInfo(kOpMakeDefListItem);
     1:   ruleInfo.blockType = &aItemType;
     1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
     1:   if (cancel || (NS_FAILED(res))) return res;
     1: 
     1:   if (!handled)
     1:   {
     1:     // todo: no default for now.  we count on rules to handle it.
     1:   }
     1: 
     1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
     1:   return res;
     1: }
     1: 
     1: nsresult
     1: nsHTMLEditor::InsertBasicBlock(const nsAString& aBlockType)
     1: {
     1:   nsresult res;
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
     1: 
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
 79445:   bool cancel, handled;
     1: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   nsAutoRules beginRulesSniffing(this, kOpMakeBasicBlock, nsIEditor::eNext);
     1:   
     1:   // pre-process
 99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
 97808:   nsTextRulesInfo ruleInfo(kOpMakeBasicBlock);
     1:   ruleInfo.blockType = &aBlockType;
     1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
     1:   if (cancel || (NS_FAILED(res))) return res;
     1: 
     1:   if (!handled)
     1:   {
     1:     // Find out if the selection is collapsed:
 98815:     bool isCollapsed = selection->Collapsed();
     1: 
     1:     nsCOMPtr<nsIDOMNode> node;
     1:     PRInt32 offset;
 43518:     res = GetStartNodeAndOffset(selection, getter_AddRefs(node), &offset);
     1:     if (!node) res = NS_ERROR_FAILURE;
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   
     1:     if (isCollapsed)
     1:     {
     1:       // have to find a place to put the block
     1:       nsCOMPtr<nsIDOMNode> parent = node;
     1:       nsCOMPtr<nsIDOMNode> topChild = node;
     1:       nsCOMPtr<nsIDOMNode> tmp;
     1:     
 97376:       nsCOMPtr<nsIAtom> blockAtom = do_GetAtom(aBlockType);
 97376:       while (!CanContainTag(parent, blockAtom)) {
     1:         parent->GetParentNode(getter_AddRefs(tmp));
 43806:         NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
     1:         topChild = parent;
     1:         parent = tmp;
     1:       }
     1:     
     1:       if (parent != node)
     1:       {
     1:         // we need to split up to the child of parent
     1:         res = SplitNodeDeep(topChild, node, offset, &offset);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1: 
     1:       // make a block
     1:       nsCOMPtr<nsIDOMNode> newBlock;
     1:       res = CreateNode(aBlockType, parent, offset, getter_AddRefs(newBlock));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     
     1:       // reposition selection to inside the block
     1:       res = selection->Collapse(newBlock,0);
 43805:       NS_ENSURE_SUCCESS(res, res);  
     1:     }
     1:   }
     1: 
     1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::Indent(const nsAString& aIndent)
     1: {
     1:   nsresult res;
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
     1: 
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
 79445:   bool cancel, handled;
 97808:   OperationID opID = kOpIndent;
     1:   if (aIndent.LowerCaseEqualsLiteral("outdent"))
     1:   {
     1:     opID = kOpOutdent;
     1:   }
     1:   nsAutoEditBatch beginBatching(this);
     1:   nsAutoRules beginRulesSniffing(this, opID, nsIEditor::eNext);
     1:   
     1:   // pre-process
 99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
 97808:   nsTextRulesInfo ruleInfo(opID);
     1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
     1:   if (cancel || (NS_FAILED(res))) return res;
     1:   
     1:   if (!handled)
     1:   {
     1:     // Do default - insert a blockquote node if selection collapsed
     1:     nsCOMPtr<nsIDOMNode> node;
     1:     PRInt32 offset;
 98815:     bool isCollapsed = selection->Collapsed();
     1: 
 43518:     res = GetStartNodeAndOffset(selection, getter_AddRefs(node), &offset);
     1:     if (!node) res = NS_ERROR_FAILURE;
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   
     1:     if (aIndent.EqualsLiteral("indent"))
     1:     {
     1:       if (isCollapsed)
     1:       {
     1:         // have to find a place to put the blockquote
     1:         nsCOMPtr<nsIDOMNode> parent = node;
     1:         nsCOMPtr<nsIDOMNode> topChild = node;
     1:         nsCOMPtr<nsIDOMNode> tmp;
 97376:         while (!CanContainTag(parent, nsGkAtoms::blockquote)) {
     1:           parent->GetParentNode(getter_AddRefs(tmp));
 43806:           NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
     1:           topChild = parent;
     1:           parent = tmp;
     1:         }
     1:     
     1:         if (parent != node)
     1:         {
     1:           // we need to split up to the child of parent
     1:           res = SplitNodeDeep(topChild, node, offset, &offset);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:         }
     1: 
     1:         // make a blockquote
     1:         nsCOMPtr<nsIDOMNode> newBQ;
 97376:         res = CreateNode(NS_LITERAL_STRING("blockquote"), parent, offset,
 97376:                          getter_AddRefs(newBQ));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         // put a space in it so layout will draw the list item
     1:         res = selection->Collapse(newBQ,0);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         res = InsertText(NS_LITERAL_STRING(" "));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         // reposition selection to before the space character
 43518:         res = GetStartNodeAndOffset(selection, getter_AddRefs(node), &offset);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         res = selection->Collapse(node,0);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:     }
     1:   }
     1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
     1:   return res;
     1: }
     1: 
     1: //TODO: IMPLEMENT ALIGNMENT!
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::Align(const nsAString& aAlignType)
     1: {
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
     1:   nsAutoEditBatch beginBatching(this);
     1:   nsAutoRules beginRulesSniffing(this, kOpAlign, nsIEditor::eNext);
     1: 
     1:   nsCOMPtr<nsIDOMNode> node;
 79445:   bool cancel, handled;
     1:   
     1:   // Find out if the selection is collapsed:
 99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
 97808:   nsTextRulesInfo ruleInfo(kOpAlign);
     1:   ruleInfo.alignType = &aAlignType;
 99469:   nsresult res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
     1:   if (cancel || NS_FAILED(res))
     1:     return res;
     1:   
     1:   res = mRules->DidDoAction(selection, &ruleInfo, res);
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetElementOrParentByTagName(const nsAString& aTagName, nsIDOMNode *aNode, nsIDOMElement** aReturn)
     1: {
     1:   if (aTagName.IsEmpty() || !aReturn )
     1:     return NS_ERROR_NULL_POINTER;
     1:   
     1:   nsresult res = NS_OK;
     1:   nsCOMPtr<nsIDOMNode> currentNode;
     1: 
     1:   if (aNode)
     1:     currentNode = aNode;
     1:   else
     1:   {
     1:     // If no node supplied, get it from anchor node of current selection
     1:     nsCOMPtr<nsISelection>selection;
     1:     res = GetSelection(getter_AddRefs(selection));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
     1:     nsCOMPtr<nsIDOMNode> anchorNode;
     1:     res = selection->GetAnchorNode(getter_AddRefs(anchorNode));
     1:     if(NS_FAILED(res)) return res;
 43806:     NS_ENSURE_TRUE(anchorNode, NS_ERROR_FAILURE);
     1: 
     1:     // Try to get the actual selected node
 79445:     bool hasChildren = false;
     1:     anchorNode->HasChildNodes(&hasChildren);
     1:     if (hasChildren)
     1:     {
     1:       PRInt32 offset;
     1:       res = selection->GetAnchorOffset(&offset);
     1:       if(NS_FAILED(res)) return res;
     1:       currentNode = nsEditor::GetChildAt(anchorNode, offset);
     1:     }
     1:     // anchor node is probably a text node - just use that
     1:     if (!currentNode)
     1:       currentNode = anchorNode;
     1:   }
     1:    
     1:   nsAutoString TagName(aTagName);
     1:   ToLowerCase(TagName);
 79445:   bool getLink = IsLinkTag(TagName);
 79445:   bool getNamedAnchor = IsNamedAnchorTag(TagName);
     1:   if ( getLink || getNamedAnchor)
     1:   {
     1:     TagName.AssignLiteral("a");  
     1:   }
 79445:   bool findTableCell = TagName.EqualsLiteral("td");
 79445:   bool findList = TagName.EqualsLiteral("list");
     1: 
     1:   // default is null - no element found
     1:   *aReturn = nsnull;
     1:   
     1:   nsCOMPtr<nsIDOMNode> parent;
 79445:   bool bNodeFound = false;
     1: 
 80486:   while (true)
     1:   {
     1:     nsAutoString currentTagName; 
     1:     // Test if we have a link (an anchor with href set)
     1:     if ( (getLink && nsHTMLEditUtils::IsLink(currentNode)) ||
     1:          (getNamedAnchor && nsHTMLEditUtils::IsNamedAnchor(currentNode)) )
     1:     {
 80486:       bNodeFound = true;
     1:       break;
     1:     } else {
     1:       if (findList)
     1:       {
     1:         // Match "ol", "ul", or "dl" for lists
     1:         if (nsHTMLEditUtils::IsList(currentNode))
     1:           goto NODE_FOUND;
     1: 
     1:       } else if (findTableCell)
     1:       {
     1:         // Table cells are another special case:
     1:         // Match either "td" or "th" for them
     1:         if (nsHTMLEditUtils::IsTableCell(currentNode))
     1:           goto NODE_FOUND;
     1: 
     1:       } else {
     1:         currentNode->GetNodeName(currentTagName);
     1:         if (currentTagName.Equals(TagName, nsCaseInsensitiveStringComparator()))
     1:         {
     1: NODE_FOUND:
 80486:           bNodeFound = true;
     1:           break;
     1:         } 
     1:       }
     1:     }
     1:     // Search up the parent chain
     1:     // We should never fail because of root test below, but lets be safe
     1:     // XXX: ERROR_HANDLING error return code lost
     1:     if (NS_FAILED(currentNode->GetParentNode(getter_AddRefs(parent))) || !parent)
     1:       break;
     1: 
     1:     // Stop searching if parent is a body tag
     1:     nsAutoString parentTagName;
     1:     parent->GetNodeName(parentTagName);
     1:     // Note: Originally used IsRoot to stop at table cells,
     1:     //  but that's too messy when you are trying to find the parent table
     1:     if(parentTagName.LowerCaseEqualsLiteral("body"))
     1:       break;
     1: 
     1:     currentNode = parent;
     1:   }
     1:   if (bNodeFound)
     1:   {
     1:     nsCOMPtr<nsIDOMElement> currentElement = do_QueryInterface(currentNode);
     1:     if (currentElement)
     1:     {
     1:       *aReturn = currentElement;
     1:       // Getters must addref
     1:       NS_ADDREF(*aReturn);
     1:     }
     1:   }
     1:   else res = NS_EDITOR_ELEMENT_NOT_FOUND;
     1: 
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetSelectedElement(const nsAString& aTagName, nsIDOMElement** aReturn)
     1: {
 43807:   NS_ENSURE_TRUE(aReturn , NS_ERROR_NULL_POINTER);
     1:   
     1:   // default is null - no element found
     1:   *aReturn = nsnull;
     1:   
     1:   // First look for a single element in selection
     1:   nsCOMPtr<nsISelection>selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
     1: 
 79445:   bool bNodeFound = false;
 98815:   bool isCollapsed = selection->Collapsed();
     1: 
     1:   nsAutoString domTagName;
     1:   nsAutoString TagName(aTagName);
     1:   ToLowerCase(TagName);
     1:   // Empty string indicates we should match any element tag
 79445:   bool anyTag = (TagName.IsEmpty());
 79445:   bool isLinkTag = IsLinkTag(TagName);
 79445:   bool isNamedAnchorTag = IsNamedAnchorTag(TagName);
     1:   
     1:   nsCOMPtr<nsIDOMElement> selectedElement;
     1:   nsCOMPtr<nsIDOMRange> range;
     1:   res = selection->GetRangeAt(0, getter_AddRefs(range));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMNode> startParent;
     1:   PRInt32 startOffset, endOffset;
     1:   res = range->GetStartContainer(getter_AddRefs(startParent));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   res = range->GetStartOffset(&startOffset);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   nsCOMPtr<nsIDOMNode> endParent;
     1:   res = range->GetEndContainer(getter_AddRefs(endParent));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   res = range->GetEndOffset(&endOffset);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // Optimization for a single selected element
     1:   if (startParent && startParent == endParent && (endOffset-startOffset) == 1)
     1:   {
     1:     nsCOMPtr<nsIDOMNode> selectedNode = GetChildAt(startParent, startOffset);
 43805:     NS_ENSURE_SUCCESS(res, NS_OK);
     1:     if (selectedNode)
     1:     {
     1:       selectedNode->GetNodeName(domTagName);
     1:       ToLowerCase(domTagName);
     1: 
     1:       // Test for appropriate node type requested
     1:       if (anyTag || (TagName == domTagName) ||
     1:           (isLinkTag && nsHTMLEditUtils::IsLink(selectedNode)) ||
     1:           (isNamedAnchorTag && nsHTMLEditUtils::IsNamedAnchor(selectedNode)))
     1:       {
 80486:         bNodeFound = true;
     1:         selectedElement = do_QueryInterface(selectedNode);
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (!bNodeFound)
     1:   {
     1:     if (isLinkTag)
     1:     {
     1:       // Link tag is a special case - we return the anchor node
     1:       //  found for any selection that is totally within a link,
     1:       //  included a collapsed selection (just a caret in a link)
     1:       nsCOMPtr<nsIDOMNode> anchorNode;
     1:       res = selection->GetAnchorNode(getter_AddRefs(anchorNode));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       PRInt32 anchorOffset = -1;
     1:       if (anchorNode)
     1:         selection->GetAnchorOffset(&anchorOffset);
     1:     
     1:       nsCOMPtr<nsIDOMNode> focusNode;
     1:       res = selection->GetFocusNode(getter_AddRefs(focusNode));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       PRInt32 focusOffset = -1;
     1:       if (focusNode)
     1:         selection->GetFocusOffset(&focusOffset);
     1: 
     1:       // Link node must be the same for both ends of selection
     1:       if (NS_SUCCEEDED(res) && anchorNode)
     1:       {
     1:   #ifdef DEBUG_cmanske
     1:         {
     1:         nsAutoString name;
     1:         anchorNode->GetNodeName(name);
     1:         printf("GetSelectedElement: Anchor node of selection: ");
     1:         wprintf(name.get());
     1:         printf(" Offset: %d\n", anchorOffset);
     1:         focusNode->GetNodeName(name);
     1:         printf("Focus node of selection: ");
     1:         wprintf(name.get());
     1:         printf(" Offset: %d\n", focusOffset);
     1:         }
     1:   #endif
     1:         nsCOMPtr<nsIDOMElement> parentLinkOfAnchor;
     1:         res = GetElementOrParentByTagName(NS_LITERAL_STRING("href"), anchorNode, getter_AddRefs(parentLinkOfAnchor));
     1:         // XXX: ERROR_HANDLING  can parentLinkOfAnchor be null?
     1:         if (NS_SUCCEEDED(res) && parentLinkOfAnchor)
     1:         {
     1:           if (isCollapsed)
     1:           {
     1:             // We have just a caret in the link
 80486:             bNodeFound = true;
     1:           } else if(focusNode) 
     1:           {  // Link node must be the same for both ends of selection
     1:             nsCOMPtr<nsIDOMElement> parentLinkOfFocus;
     1:             res = GetElementOrParentByTagName(NS_LITERAL_STRING("href"), focusNode, getter_AddRefs(parentLinkOfFocus));
     1:             if (NS_SUCCEEDED(res) && parentLinkOfFocus == parentLinkOfAnchor)
 80486:               bNodeFound = true;
     1:           }
     1:       
     1:           // We found a link node parent
     1:           if (bNodeFound) {
     1:             // GetElementOrParentByTagName addref'd this, so we don't need to do it here
     1:             *aReturn = parentLinkOfAnchor;
     1:             NS_IF_ADDREF(*aReturn);
     1:             return NS_OK;
     1:           }
     1:         }
     1:         else if (anchorOffset >= 0)  // Check if link node is the only thing selected
     1:         {
     1:           nsCOMPtr<nsIDOMNode> anchorChild;
     1:           anchorChild = GetChildAt(anchorNode,anchorOffset);
     1:           if (anchorChild && nsHTMLEditUtils::IsLink(anchorChild) && 
     1:               (anchorNode == focusNode) && focusOffset == (anchorOffset+1))
     1:           {
     1:             selectedElement = do_QueryInterface(anchorChild);
 80486:             bNodeFound = true;
     1:           }
     1:         }
     1:       }
     1:     } 
     1: 
     1:     if (!isCollapsed)   // Don't bother to examine selection if it is collapsed
     1:     {
     1:       nsCOMPtr<nsIEnumerator> enumerator;
     1:       res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
     1:       if (NS_SUCCEEDED(res))
     1:       {
     1:         if(!enumerator)
     1:           return NS_ERROR_NULL_POINTER;
     1: 
     1:         enumerator->First(); 
     1:         nsCOMPtr<nsISupports> currentItem;
     1:         res = enumerator->CurrentItem(getter_AddRefs(currentItem));
     1:         if ((NS_SUCCEEDED(res)) && currentItem)
     1:         {
     1:           nsCOMPtr<nsIDOMRange> currange( do_QueryInterface(currentItem) );
     1:           nsCOMPtr<nsIContentIterator> iter =
     1:             do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1: 
     1:           iter->Init(currange);
     1:           // loop through the content iterator for each content node
     1:           while (!iter->IsDone())
     1:           {
     1:             // Query interface to cast nsIContent to nsIDOMNode
     1:             //  then get tagType to compare to  aTagName
     1:             // Clone node of each desired type and append it to the aDomFrag
     1:             selectedElement = do_QueryInterface(iter->GetCurrentNode());
     1:             if (selectedElement)
     1:             {
     1:               // If we already found a node, then we have another element,
     1:               //  thus there's not just one element selected
     1:               if (bNodeFound)
     1:               {
 80486:                 bNodeFound = false;
     1:                 break;
     1:               }
     1: 
     1:               selectedElement->GetNodeName(domTagName);
     1:               ToLowerCase(domTagName);
     1: 
     1:               if (anyTag)
     1:               {
     1:                 // Get name of first selected element
     1:                 selectedElement->GetTagName(TagName);
     1:                 ToLowerCase(TagName);
 80486:                 anyTag = false;
     1:               }
     1: 
     1:               // The "A" tag is a pain,
     1:               //  used for both link(href is set) and "Named Anchor"
     1:               nsCOMPtr<nsIDOMNode> selectedNode = do_QueryInterface(selectedElement);
     1:               if ( (isLinkTag && nsHTMLEditUtils::IsLink(selectedNode)) ||
     1:                    (isNamedAnchorTag && nsHTMLEditUtils::IsNamedAnchor(selectedNode)) )
     1:               {
 80486:                 bNodeFound = true;
     1:               } else if (TagName == domTagName) { // All other tag names are handled here
 80486:                 bNodeFound = true;
     1:               }
     1:               if (!bNodeFound)
     1:               {
     1:                 // Check if node we have is really part of the selection???
     1:                 break;
     1:               }
     1:             }
     1:             iter->Next();
     1:           }
     1:         } else {
     1:           // Should never get here?
 80486:           isCollapsed = true;
     1:           printf("isCollapsed was FALSE, but no elements found in selection\n");
     1:         }
     1:       } else {
     1:         printf("Could not create enumerator for GetSelectionProperties\n");
     1:       }
     1:     }
     1:   }
     1:   if (bNodeFound)
     1:   {
     1:     
     1:     *aReturn = selectedElement;
     1:     if (selectedElement)
     1:     {  
     1:       // Getters must addref
     1:       NS_ADDREF(*aReturn);
     1:     }
     1:   } 
     1:   else res = NS_EDITOR_ELEMENT_NOT_FOUND;
     1: 
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::CreateElementWithDefaults(const nsAString& aTagName, nsIDOMElement** aReturn)
     1: {
     1:   nsresult res=NS_ERROR_NOT_INITIALIZED;
     1:   if (aReturn)
     1:     *aReturn = nsnull;
     1: 
 43807: //  NS_ENSURE_TRUE(aTagName && aReturn, NS_ERROR_NULL_POINTER);
 43807:   NS_ENSURE_TRUE(!aTagName.IsEmpty() && aReturn, NS_ERROR_NULL_POINTER);
     1:     
     1:   nsAutoString TagName(aTagName);
     1:   ToLowerCase(TagName);
     1:   nsAutoString realTagName;
     1: 
     1:   if (IsLinkTag(TagName) || IsNamedAnchorTag(TagName))
     1:   {
     1:     realTagName.AssignLiteral("a");
     1:   } else {
     1:     realTagName = TagName;
     1:   }
     1:   //We don't use editor's CreateElement because we don't want to 
     1:   //  go through the transaction system
     1: 
     1:   nsCOMPtr<nsIDOMElement>newElement;
101120:   nsCOMPtr<dom::Element> newContent;
     1:   nsCOMPtr<nsIDOMDocument> doc = do_QueryReferent(mDocWeak);
 43806:   NS_ENSURE_TRUE(doc, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   //new call to use instead to get proper HTML element, bug# 39919
     1:   res = CreateHTMLContent(realTagName, getter_AddRefs(newContent));
     1:   newElement = do_QueryInterface(newContent);
     1:   if (NS_FAILED(res) || !newElement)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   // Mark the new element dirty, so it will be formatted
     1:   newElement->SetAttribute(NS_LITERAL_STRING("_moz_dirty"), EmptyString());
     1: 
     1:   // Set default values for new elements
 94890:   if (TagName.EqualsLiteral("table")) {
     1:     res = newElement->SetAttribute(NS_LITERAL_STRING("cellpadding"),NS_LITERAL_STRING("2"));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     res = newElement->SetAttribute(NS_LITERAL_STRING("cellspacing"),NS_LITERAL_STRING("2"));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     res = newElement->SetAttribute(NS_LITERAL_STRING("border"),NS_LITERAL_STRING("1"));
     1:   } else if (TagName.EqualsLiteral("td"))
     1:   {
     1:     res = SetAttributeOrEquivalent(newElement, NS_LITERAL_STRING("valign"),
 80486:                                    NS_LITERAL_STRING("top"), true);
     1:   }
     1:   // ADD OTHER TAGS HERE
     1: 
     1:   if (NS_SUCCEEDED(res))
     1:   {
     1:     *aReturn = newElement;
     1:     // Getters must addref
     1:     NS_ADDREF(*aReturn);
     1:   }
     1: 
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::InsertLinkAroundSelection(nsIDOMElement* aAnchorElement)
     1: {
 98815:   NS_ENSURE_TRUE(aAnchorElement, NS_ERROR_NULL_POINTER);
 98815: 
 98815:   // We must have a real selection
     1:   nsCOMPtr<nsISelection> selection;
 98815:   nsresult res = GetSelection(getter_AddRefs(selection));
     1:   if (!selection)
     1:   {
     1:     res = NS_ERROR_NULL_POINTER;
     1:   }
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
 98815:   if (selection->Collapsed()) {
 98815:     NS_WARNING("InsertLinkAroundSelection called but there is no selection!!!");
 98815:     return NS_OK;
 98815:   }
 98815: 
     1:   // Be sure we were given an anchor element
     1:   nsCOMPtr<nsIDOMHTMLAnchorElement> anchor = do_QueryInterface(aAnchorElement);
 98815:   if (!anchor) {
 98815:     return NS_OK;
 98815:   }
 98815: 
     1:   nsAutoString href;
     1:   res = anchor->GetHref(href);
 43805:   NS_ENSURE_SUCCESS(res, res);
 98815:   if (href.IsEmpty()) {
 98815:     return NS_OK;
 98815:   }
 98815: 
     1:   nsAutoEditBatch beginBatching(this);
     1: 
     1:   // Set all attributes found on the supplied anchor element
     1:   nsCOMPtr<nsIDOMNamedNodeMap> attrMap;
     1:   aAnchorElement->GetAttributes(getter_AddRefs(attrMap));
 43807:   NS_ENSURE_TRUE(attrMap, NS_ERROR_FAILURE);
     1: 
 98815:   PRUint32 count;
     1:   attrMap->GetLength(&count);
     1:   nsAutoString name, value;
     1: 
 98815:   for (PRUint32 i = 0; i < count; ++i) {
     1:     nsCOMPtr<nsIDOMNode> attrNode;
     1:     res = attrMap->Item(i, getter_AddRefs(attrNode));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     nsCOMPtr<nsIDOMAttr> attribute = do_QueryInterface(attrNode);
 98815:     if (attribute) {
     1:       // We must clear the string buffers
     1:       //   because GetName, GetValue appends to previous string!
     1:       name.Truncate();
     1:       value.Truncate();
     1: 
     1:       res = attribute->GetName(name);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       res = attribute->GetValue(value);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       res = SetInlineProperty(nsEditProperty::a, name, value);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:   }
 98815:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::SetHTMLBackgroundColor(const nsAString& aColor)
     1: {
     1:   NS_PRECONDITION(mDocWeak, "Missing Editor DOM Document");
     1:   
     1:   // Find a selected or enclosing table element to set background on
     1:   nsCOMPtr<nsIDOMElement> element;
     1:   PRInt32 selectedCount;
     1:   nsAutoString tagName;
     1:   nsresult res = GetSelectedOrParentTableElement(tagName, &selectedCount,
     1:                                                  getter_AddRefs(element));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
 79445:   bool setColor = !aColor.IsEmpty();
     1: 
     1:   NS_NAMED_LITERAL_STRING(bgcolor, "bgcolor");
     1:   if (element)
     1:   {
     1:     if (selectedCount > 0)
     1:     {
     1:       // Traverse all selected cells
     1:       nsCOMPtr<nsIDOMElement> cell;
     1:       res = GetFirstSelectedCell(nsnull, getter_AddRefs(cell));
     1:       if (NS_SUCCEEDED(res) && cell)
     1:       {
     1:         while(cell)
     1:         {
     1:           if (setColor)
     1:             res = SetAttribute(cell, bgcolor, aColor);
     1:           else
     1:             res = RemoveAttribute(cell, bgcolor);
     1:           if (NS_FAILED(res)) break;
     1: 
     1:           GetNextSelectedCell(nsnull, getter_AddRefs(cell));
     1:         };
     1:         return res;
     1:       }
     1:     }
     1:     // If we failed to find a cell, fall through to use originally-found element
     1:   } else {
     1:     // No table element -- set the background color on the body tag
 83343:     element = do_QueryInterface(GetRoot());
 43806:     NS_ENSURE_TRUE(element, NS_ERROR_NULL_POINTER);
     1:   }
     1:   // Use the editor method that goes through the transaction system
     1:   if (setColor)
     1:     res = SetAttribute(element, bgcolor, aColor);
     1:   else
     1:     res = RemoveAttribute(element, bgcolor);
     1: 
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP nsHTMLEditor::SetBodyAttribute(const nsAString& aAttribute, const nsAString& aValue)
     1: {
     1:   // TODO: Check selection for Cell, Row, Column or table and do color on appropriate level
     1: 
     1:   NS_ASSERTION(mDocWeak, "Missing Editor DOM Document");
     1:   
     1:   // Set the background color attribute on the body tag
 83343:   nsCOMPtr<nsIDOMElement> bodyElement = do_QueryInterface(GetRoot());
 43807:   NS_ENSURE_TRUE(bodyElement, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Use the editor method that goes through the transaction system
     1:   return SetAttribute(bodyElement, aAttribute, aValue);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetLinkedObjects(nsISupportsArray** aNodeList)
     1: {
 43807:   NS_ENSURE_TRUE(aNodeList, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsresult res;
     1: 
     1:   res = NS_NewISupportsArray(aNodeList);
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(*aNodeList, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIContentIterator> iter =
     1:        do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
 43806:   NS_ENSURE_TRUE(iter, NS_ERROR_NULL_POINTER);
     1:   if ((NS_SUCCEEDED(res)))
     1:   {
 93880:     nsCOMPtr<nsIDocument> doc = GetDocument();
 43807:     NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
     1: 
 41634:     iter->Init(doc->GetRootElement());
     1: 
     1:     // loop through the content iterator for each content node
     1:     while (!iter->IsDone())
     1:     {
     1:       nsCOMPtr<nsIDOMNode> node (do_QueryInterface(iter->GetCurrentNode()));
     1:       if (node)
     1:       {
     1:         // Let nsURIRefObject make the hard decisions:
     1:         nsCOMPtr<nsIURIRefObject> refObject;
     1:         res = NS_NewHTMLURIRefObject(getter_AddRefs(refObject), node);
     1:         if (NS_SUCCEEDED(res))
     1:         {
     1:           nsCOMPtr<nsISupports> isupp (do_QueryInterface(refObject));
     1: 
     1:           (*aNodeList)->AppendElement(isupp);
     1:         }
     1:       }
     1:       iter->Next();
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::AddStyleSheet(const nsAString &aURL)
     1: {
     1:   // Enable existing sheet if already loaded.
     1:   if (EnableExistingStyleSheet(aURL))
     1:     return NS_OK;
     1: 
     1:   // Lose the previously-loaded sheet so there's nothing to replace
     1:   // This pattern is different from Override methods because
     1:   //  we must wait to remove mLastStyleSheetURL and add new sheet
     1:   //  at the same time (in StyleSheetLoaded callback) so they are undoable together
     1:   mLastStyleSheetURL.Truncate();
     1:   return ReplaceStyleSheet(aURL);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::ReplaceStyleSheet(const nsAString& aURL)
     1: {
     1:   // Enable existing sheet if already loaded.
     1:   if (EnableExistingStyleSheet(aURL))
     1:   {
     1:     // Disable last sheet if not the same as new one
 29614:     if (!mLastStyleSheetURL.IsEmpty() && !mLastStyleSheetURL.Equals(aURL))
 80486:       return EnableStyleSheet(mLastStyleSheetURL, false);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
 38851:   // Make sure the pres shell doesn't disappear during the load.
 63587:   NS_ENSURE_TRUE(mDocWeak, NS_ERROR_NOT_INITIALIZED);
 70236:   nsCOMPtr<nsIPresShell> ps = GetPresShell();
 43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIURI> uaURI;
 38851:   nsresult rv = NS_NewURI(getter_AddRefs(uaURI), aURL);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 38851:   return ps->GetDocument()->CSSLoader()->
 38851:     LoadSheet(uaURI, nsnull, EmptyCString(), this);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::RemoveStyleSheet(const nsAString &aURL)
     1: {
 42163:   nsRefPtr<nsCSSStyleSheet> sheet;
     1:   nsresult rv = GetStyleSheetForURL(aURL, getter_AddRefs(sheet));
     1:   NS_ENSURE_SUCCESS(rv, rv);
 43807:   NS_ENSURE_TRUE(sheet, NS_ERROR_UNEXPECTED);
     1: 
  3030:   nsRefPtr<RemoveStyleSheetTxn> txn;
  3030:   rv = CreateTxnForRemoveStyleSheet(sheet, getter_AddRefs(txn));
     1:   if (!txn) rv = NS_ERROR_NULL_POINTER;
     1:   if (NS_SUCCEEDED(rv))
     1:   {
     1:     rv = DoTransaction(txn);
     1:     if (NS_SUCCEEDED(rv))
     1:       mLastStyleSheetURL.Truncate();        // forget it
     1: 
     1:     // Remove it from our internal list
     1:     rv = RemoveStyleSheetFromList(aURL);
     1:   }
     1:   
     1:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::AddOverrideStyleSheet(const nsAString& aURL)
     1: {
     1:   // Enable existing sheet if already loaded.
     1:   if (EnableExistingStyleSheet(aURL))
     1:     return NS_OK;
     1: 
 38851:   // Make sure the pres shell doesn't disappear during the load.
 70236:   nsCOMPtr<nsIPresShell> ps = GetPresShell();
 43807:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIURI> uaURI;
 38851:   nsresult rv = NS_NewURI(getter_AddRefs(uaURI), aURL);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // We MUST ONLY load synchronous local files (no @import)
     1:   // XXXbz Except this will actually try to load remote files
     1:   // synchronously, of course..
 42163:   nsRefPtr<nsCSSStyleSheet> sheet;
     1:   // Editor override style sheets may want to style Gecko anonymous boxes
 38851:   rv = ps->GetDocument()->CSSLoader()->
 80486:     LoadSheetSync(uaURI, true, true, getter_AddRefs(sheet));
     1: 
     1:   // Synchronous loads should ALWAYS return completed
 43807:   NS_ENSURE_TRUE(sheet, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Add the override style sheet
     1:   // (This checks if already exists)
     1:   ps->AddOverrideStyleSheet(sheet);
     1: 
     1:   ps->ReconstructStyleData();
     1: 
     1:   // Save as the last-loaded sheet
     1:   mLastOverrideStyleSheetURL = aURL;
     1: 
     1:   //Add URL and style sheet to our lists
     1:   return AddNewStyleSheetToList(aURL, sheet);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::ReplaceOverrideStyleSheet(const nsAString& aURL)
     1: {
     1:   // Enable existing sheet if already loaded.
     1:   if (EnableExistingStyleSheet(aURL))
     1:   {
     1:     // Disable last sheet if not the same as new one
     1:     if (!mLastOverrideStyleSheetURL.IsEmpty() && !mLastOverrideStyleSheetURL.Equals(aURL))
 80486:       return EnableStyleSheet(mLastOverrideStyleSheetURL, false);
     1: 
     1:     return NS_OK;
     1:   }
     1:   // Remove the previous sheet
     1:   if (!mLastOverrideStyleSheetURL.IsEmpty())
     1:     RemoveOverrideStyleSheet(mLastOverrideStyleSheetURL);
     1: 
     1:   return AddOverrideStyleSheet(aURL);
     1: }
     1: 
     1: // Do NOT use transaction system for override style sheets
     1: NS_IMETHODIMP
     1: nsHTMLEditor::RemoveOverrideStyleSheet(const nsAString &aURL)
     1: {
 42163:   nsRefPtr<nsCSSStyleSheet> sheet;
     1:   GetStyleSheetForURL(aURL, getter_AddRefs(sheet));
     1: 
     1:   // Make sure we remove the stylesheet from our internal list in all
     1:   // cases.
     1:   nsresult rv = RemoveStyleSheetFromList(aURL);
     1: 
 43807:   NS_ENSURE_TRUE(sheet, NS_OK); /// Don't fail if sheet not found
     1: 
 63587:   NS_ENSURE_TRUE(mDocWeak, NS_ERROR_NOT_INITIALIZED);
 70236:   nsCOMPtr<nsIPresShell> ps = GetPresShell();
 43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   ps->RemoveOverrideStyleSheet(sheet);
     1:   ps->ReconstructStyleData();
     1: 
     1:   // Remove it from our internal list
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::EnableStyleSheet(const nsAString &aURL, bool aEnable)
     1: {
 42163:   nsRefPtr<nsCSSStyleSheet> sheet;
     1:   nsresult rv = GetStyleSheetForURL(aURL, getter_AddRefs(sheet));
     1:   NS_ENSURE_SUCCESS(rv, rv);
 43807:   NS_ENSURE_TRUE(sheet, NS_OK); // Don't fail if sheet not found
     1: 
 25180:   // Ensure the style sheet is owned by our document.
 32927:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 42232:   sheet->SetOwningDocument(doc);
 25180: 
 42163:   return sheet->SetDisabled(!aEnable);
     1: }
     1: 
 79445: bool
     1: nsHTMLEditor::EnableExistingStyleSheet(const nsAString &aURL)
     1: {
 42163:   nsRefPtr<nsCSSStyleSheet> sheet;
     1:   nsresult rv = GetStyleSheetForURL(aURL, getter_AddRefs(sheet));
 80486:   NS_ENSURE_SUCCESS(rv, false);
     1: 
     1:   // Enable sheet if already loaded.
     1:   if (sheet)
     1:   {
 25180:     // Ensure the style sheet is owned by our document.
 32927:     nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 42232:     sheet->SetOwningDocument(doc);
 25180: 
 80486:     sheet->SetDisabled(false);
 80486:     return true;
 80486:   }
 80486:   return false;
     1: }
     1: 
     1: nsresult
     1: nsHTMLEditor::AddNewStyleSheetToList(const nsAString &aURL,
 42163:                                      nsCSSStyleSheet *aStyleSheet)
 42163: {
 42163:   PRUint32 countSS = mStyleSheets.Length();
 23904:   PRUint32 countU = mStyleSheetURLs.Length();
     1: 
 56862:   if (countSS != countU)
     1:     return NS_ERROR_UNEXPECTED;
     1: 
 23904:   if (!mStyleSheetURLs.AppendElement(aURL))
     1:     return NS_ERROR_UNEXPECTED;
     1: 
 42163:   return mStyleSheets.AppendElement(aStyleSheet) ? NS_OK : NS_ERROR_UNEXPECTED;
     1: }
     1: 
     1: nsresult
     1: nsHTMLEditor::RemoveStyleSheetFromList(const nsAString &aURL)
     1: {
     1:   // is it already in the list?
 24835:   PRUint32 foundIndex;
     1:   foundIndex = mStyleSheetURLs.IndexOf(aURL);
 24835:   if (foundIndex == mStyleSheetURLs.NoIndex)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   // Attempt both removals; if one fails there's not much we can do.
 42163:   mStyleSheets.RemoveElementAt(foundIndex);
 23904:   mStyleSheetURLs.RemoveElementAt(foundIndex);
     1: 
 42163:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetStyleSheetForURL(const nsAString &aURL,
 42163:                                   nsCSSStyleSheet **aStyleSheet)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aStyleSheet);
     1:   *aStyleSheet = 0;
     1: 
     1:   // is it already in the list?
 24835:   PRUint32 foundIndex;
     1:   foundIndex = mStyleSheetURLs.IndexOf(aURL);
 24835:   if (foundIndex == mStyleSheetURLs.NoIndex)
     1:     return NS_OK; //No sheet -- don't fail!
     1: 
     1:   *aStyleSheet = mStyleSheets[foundIndex];
 43807:   NS_ENSURE_TRUE(*aStyleSheet, NS_ERROR_FAILURE);
     1: 
     1:   NS_ADDREF(*aStyleSheet);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 42163: nsHTMLEditor::GetURLForStyleSheet(nsCSSStyleSheet *aStyleSheet,
     1:                                   nsAString &aURL)
     1: {
     1:   // is it already in the list?
     1:   PRInt32 foundIndex = mStyleSheets.IndexOf(aStyleSheet);
     1: 
     1:   // Don't fail if we don't find it in our list
 24835:   // Note: mStyleSheets is nsCOMArray, so its IndexOf() method
 24835:   // returns -1 on failure.
     1:   if (foundIndex == -1)
     1:     return NS_OK;
     1: 
     1:   // Found it in the list!
 23904:   aURL = mStyleSheetURLs[foundIndex];
     1:   return NS_OK;
     1: }
     1: 
 38851: /*
 38851:  * nsIEditorMailSupport methods
 38851:  */
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetEmbeddedObjects(nsISupportsArray** aNodeList)
     1: {
 43807:   NS_ENSURE_TRUE(aNodeList, NS_ERROR_NULL_POINTER);
     1: 
 82307:   nsresult rv = NS_NewISupportsArray(aNodeList);
 82307:   NS_ENSURE_SUCCESS(rv, rv);
 43806:   NS_ENSURE_TRUE(*aNodeList, NS_ERROR_NULL_POINTER);
     1: 
     1:   nsCOMPtr<nsIContentIterator> iter =
 82307:       do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &rv);
 43806:   NS_ENSURE_TRUE(iter, NS_ERROR_NULL_POINTER);
 82307:   NS_ENSURE_SUCCESS(rv, rv);
 82307: 
 93880:   nsCOMPtr<nsIDocument> doc = GetDocument();
 43807:   NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
     1: 
 41634:   iter->Init(doc->GetRootElement());
     1: 
 82307:   // Loop through the content iterator for each content node.
 82307:   while (!iter->IsDone()) {
 82307:     nsINode* node = iter->GetCurrentNode();
 82307:     if (node->IsElement()) {
 82307:       dom::Element* element = node->AsElement();
     1: 
     1:       // See if it's an image or an embed and also include all links.
     1:       // Let mail decide which link to send or not
 82307:       if (element->IsHTML(nsGkAtoms::img) ||
 82307:           element->IsHTML(nsGkAtoms::embed) ||
 82307:           element->IsHTML(nsGkAtoms::a) ||
 82307:           (element->IsHTML(nsGkAtoms::body) &&
 82307:            element->HasAttr(kNameSpaceID_None, nsGkAtoms::background))) {
 82307:         nsCOMPtr<nsIDOMNode> domNode = do_QueryInterface(node);
 82307:         (*aNodeList)->AppendElement(domNode);
     1:       }
     1:     }
     1:     iter->Next();
     1:   }
 82307: 
 82307:   return rv;
     1: }
     1: 
     1: 
 89185: NS_IMETHODIMP
 98852: nsHTMLEditor::DeleteSelectionImpl(EDirection aAction,
 98852:                                   EStripWrappers aStripWrappers)
 98852: {
 98852:   MOZ_ASSERT(aStripWrappers == eStrip || aStripWrappers == eNoStrip);
 98852: 
 98852:   nsresult res = nsEditor::DeleteSelectionImpl(aAction, aStripWrappers);
 98852:   NS_ENSURE_SUCCESS(res, res);
 98852: 
 98852:   // If we weren't asked to strip any wrappers, we're done.
 98852:   if (aStripWrappers == eNoStrip) {
 98852:     return NS_OK;
 98852:   }
 98852: 
 98852:   nsRefPtr<nsTypedSelection> typedSel = GetTypedSelection();
 98852:   // Just checking that the selection itself is collapsed doesn't seem to work
 98852:   // right in the multi-range case
 98852:   NS_ENSURE_STATE(typedSel);
 98852:   NS_ENSURE_STATE(typedSel->GetAnchorFocusRange());
 98852:   NS_ENSURE_STATE(typedSel->GetAnchorFocusRange()->Collapsed());
 98852: 
 98852:   nsCOMPtr<nsIContent> content = do_QueryInterface(typedSel->GetAnchorNode());
 98852:   NS_ENSURE_STATE(content);
 98852: 
 98852:   // Don't strip wrappers if this is the only wrapper in the block.  Then we'll
 98852:   // add a <br> later, so it won't be an empty wrapper in the end.
 98852:   nsCOMPtr<nsIContent> blockParent = content;
101244:   while (blockParent && !IsBlockNode(blockParent)) {
 98852:     blockParent = blockParent->GetParent();
 98852:   }
101244:   if (!blockParent) {
101244:     return NS_OK;
101244:   }
 98852:   bool emptyBlockParent;
 98852:   res = IsEmptyNode(blockParent, &emptyBlockParent);
 98852:   NS_ENSURE_SUCCESS(res, res);
 98852:   if (emptyBlockParent) {
 98852:     return NS_OK;
 98852:   }
 98852: 
 98852:   if (content && !IsBlockNode(content) && !content->Length() &&
 98852:       content->IsEditable() && content != content->GetEditingHost()) {
 98852:     while (content->GetParent() && !IsBlockNode(content->GetParent()) &&
 98852:            content->GetParent()->Length() == 1 &&
 98852:            content->GetParent()->IsEditable() &&
 98852:            content->GetParent() != content->GetEditingHost()) {
 98852:       content = content->GetParent();
 98852:     }
 98852:     res = DeleteNode(content);
 98852:     NS_ENSURE_SUCCESS(res, res);
 98852:   }
 98852: 
 98852:   return NS_OK;
 98852: }
 98852: 
 98852: 
 98852: nsresult
 98852: nsHTMLEditor::DeleteNode(nsINode* aNode)
 98852: {
 98852:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aNode);
 98852:   return DeleteNode(node);
 98852: }
 98852: 
 98852: NS_IMETHODIMP
 89185: nsHTMLEditor::DeleteNode(nsIDOMNode* aNode)
     1: {
  2896:   // do nothing if the node is read-only
 89185:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 89185:   if (!IsModifiableNode(aNode) && !IsMozEditorBogusNode(content)) {
  2896:     return NS_ERROR_FAILURE;
  2896:   }
  2896: 
     1:   nsCOMPtr<nsIDOMNode> selectAllNode = FindUserSelectAllNode(aNode);
     1:   
     1:   if (selectAllNode)
     1:   {
     1:     return nsEditor::DeleteNode(selectAllNode);
     1:   }
     1:   return nsEditor::DeleteNode(aNode);
     1: }
     1: 
     1: NS_IMETHODIMP nsHTMLEditor::DeleteText(nsIDOMCharacterData *aTextNode,
     1:                                        PRUint32             aOffset,
     1:                                        PRUint32             aLength)
     1: {
  2896:   // do nothing if the node is read-only
  2896:   if (!IsModifiableNode(aTextNode)) {
  2896:     return NS_ERROR_FAILURE;
  2896:   }
  2896: 
     1:   nsCOMPtr<nsIDOMNode> selectAllNode = FindUserSelectAllNode(aTextNode);
     1:   
     1:   if (selectAllNode)
     1:   {
     1:     return nsEditor::DeleteNode(selectAllNode);
     1:   }
     1:   return nsEditor::DeleteText(aTextNode, aOffset, aLength);
     1: }
     1: 
  2896: NS_IMETHODIMP nsHTMLEditor::InsertTextImpl(const nsAString& aStringToInsert, 
  2896:                                            nsCOMPtr<nsIDOMNode> *aInOutNode, 
  2896:                                            PRInt32 *aInOutOffset,
  2896:                                            nsIDOMDocument *aDoc)
  2896: {
  2896:   // do nothing if the node is read-only
  2896:   if (!IsModifiableNode(*aInOutNode)) {
  2896:     return NS_ERROR_FAILURE;
  2896:   }
  2896: 
  2896:   return nsEditor::InsertTextImpl(aStringToInsert, aInOutNode, aInOutOffset, aDoc);
  2896: }
     1: 
 43716: void
 43716: nsHTMLEditor::ContentAppended(nsIDocument *aDocument, nsIContent* aContainer,
 43716:                               nsIContent* aFirstNewContent,
 96910:                               PRInt32 aIndexInContainer)
 96910: {
 96910:   ContentInserted(aDocument, aContainer, aFirstNewContent, aIndexInContainer);
 43716: }
 43716: 
 43716: void
 43716: nsHTMLEditor::ContentInserted(nsIDocument *aDocument, nsIContent* aContainer,
 96910:                               nsIContent* aChild, PRInt32 aIndexInContainer)
 43716: {
 57481:   if (!aChild) {
 43717:     return;
 43717:   }
 43717: 
 57959:   nsCOMPtr<nsIHTMLEditor> kungFuDeathGrip(this);
 57959: 
 43717:   if (ShouldReplaceRootElement()) {
 43717:     ResetRootElementAndEventTarget();
 43716:   }
 57481:   // We don't need to handle our own modifications
 57485:   else if (!mAction && (aContainer ? aContainer->IsEditable() : aDocument->IsEditable())) {
 89185:     if (IsMozEditorBogusNode(aChild)) {
 57597:       // Ignore insertion of the bogus node
 57597:       return;
 57597:     }
 57481:     mRules->DocumentModified();
 96910: 
 96910:     // Update spellcheck for only the newly-inserted node (bug 743819)
 96910:     if (mInlineSpellChecker) {
 96910:       nsRefPtr<nsRange> range = new nsRange();
 96910:       nsresult res = range->Set(aContainer, aIndexInContainer,
 96910:                                 aContainer, aIndexInContainer + 1);
 96910:       if (NS_SUCCEEDED(res)) {
 96910:         mInlineSpellChecker->SpellCheckRange(range);
 96910:       }
 96910:     }
 57481:   }
 43716: }
 43716: 
 43716: void
 43716: nsHTMLEditor::ContentRemoved(nsIDocument *aDocument, nsIContent* aContainer,
 48038:                              nsIContent* aChild, PRInt32 aIndexInContainer,
 48038:                              nsIContent* aPreviousSibling)
 43716: {
 57959:   nsCOMPtr<nsIHTMLEditor> kungFuDeathGrip(this);
 57959: 
 43717:   if (SameCOMIdentity(aChild, mRootElement)) {
 43717:     ResetRootElementAndEventTarget();
 43716:   }
 57481:   // We don't need to handle our own modifications
 57485:   else if (!mAction && (aContainer ? aContainer->IsEditable() : aDocument->IsEditable())) {
 89185:     if (aChild && IsMozEditorBogusNode(aChild)) {
 57597:       // Ignore removal of the bogus node
 57597:       return;
 57597:     }
 57481:     mRules->DocumentModified();
 57481:   }
 43716: }
 43716: 
     1: 
 90153: /* This routine examines aNode and its ancestors looking for any node which has the
     1:    -moz-user-select: all style lit.  Return the highest such ancestor.  */
 75266: already_AddRefed<nsIDOMNode>
 75266: nsHTMLEditor::FindUserSelectAllNode(nsIDOMNode* aNode)
 75266: {
     1:   nsCOMPtr<nsIDOMNode> node = aNode;
 83343:   nsCOMPtr<nsIDOMElement> root = do_QueryInterface(GetRoot());
     1:   if (!nsEditorUtils::IsDescendantOf(aNode, root))
     1:     return nsnull;
     1: 
 75266:   nsCOMPtr<nsIDOMNode> resultNode;  // starts out empty
     1:   nsAutoString mozUserSelectValue;
     1:   while (node)
     1:   {
 75266:     // retrieve the computed style of -moz-user-select for node
     1:     mHTMLCSSUtils->GetComputedProperty(node, nsEditProperty::cssMozUserSelect, mozUserSelectValue);
     1:     if (mozUserSelectValue.EqualsLiteral("all"))
     1:     {
     1:       resultNode = node;
     1:     }
     1:     if (node != root)
     1:     {
     1:       nsCOMPtr<nsIDOMNode> tmp;
     1:       node->GetParentNode(getter_AddRefs(tmp));
     1:       node = tmp;
     1:     }
     1:     else
     1:     {
     1:       node = nsnull;
     1:     }
     1:   } 
     1: 
 75266:   return resultNode.forget();
     1: }
     1: 
 79445: NS_IMETHODIMP_(bool)
  2896: nsHTMLEditor::IsModifiableNode(nsIDOMNode *aNode)
  2896: {
 82861:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
 82861:   return IsModifiableNode(node);
 82861: }
 82861: 
 82861: bool
 82861: nsHTMLEditor::IsModifiableNode(nsINode *aNode)
 82861: {
 82861:   return !aNode || aNode->IsEditable();
  2896: }
  2896: 
 98822: static nsresult
 98822: SetSelectionAroundHeadChildren(nsISelection* aSelection,
 98822:                                nsIWeakReference* aDocWeak)
 98822: {
     1:   // Set selection around <head> node
 98822:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(aDocWeak);
 43806:   NS_ENSURE_TRUE(doc, NS_ERROR_NOT_INITIALIZED);
     1: 
 98822:   dom::Element* headNode = doc->GetHeadElement();
 98822:   NS_ENSURE_STATE(headNode);
     1: 
     1:   // Collapse selection to before first child of the head,
 98822:   nsresult rv = aSelection->CollapseNative(headNode, 0);
 98822:   NS_ENSURE_SUCCESS(rv, rv);
 98822: 
 98822:   // Then extend it to just after.
 98822:   PRUint32 childCount = headNode->GetChildCount();
 98822:   return aSelection->ExtendNative(headNode, childCount + 1);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetHeadContentsAsHTML(nsAString& aOutputString)
     1: {
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
     1: 
     1:   // Save current selection
     1:   nsAutoSelectionReset selectionResetter(selection, this);
     1: 
     1:   res = SetSelectionAroundHeadChildren(selection, mDocWeak);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   res = OutputToString(NS_LITERAL_STRING("text/html"),
     1:                        nsIDocumentEncoder::OutputSelectionOnly,
     1:                        aOutputString);
     1:   if (NS_SUCCEEDED(res))
     1:   {
     1:     // Selection always includes <body></body>,
     1:     //  so terminate there
     1:     nsReadingIterator<PRUnichar> findIter,endFindIter;
     1:     aOutputString.BeginReading(findIter);
     1:     aOutputString.EndReading(endFindIter);
     1:     //counting on our parser to always lower case!!!
     1:     if (CaseInsensitiveFindInReadable(NS_LITERAL_STRING("<body"),
     1:                                       findIter, endFindIter))
     1:     {
     1:       nsReadingIterator<PRUnichar> beginIter;
     1:       aOutputString.BeginReading(beginIter);
     1:       PRInt32 offset = Distance(beginIter, findIter);//get the distance
     1: 
     1:       nsWritingIterator<PRUnichar> writeIter;
     1:       aOutputString.BeginWriting(writeIter);
     1:       // Ensure the string ends in a newline
     1:       PRUnichar newline ('\n');
     1:       findIter.advance(-1);
     1:       if (offset ==0 || (offset >0 &&  (*findIter) != newline)) //check for 0
     1:       {
     1:         writeIter.advance(offset);
     1:         *writeIter = newline;
     1:         aOutputString.Truncate(offset+1);
     1:       }
     1:     }
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::DebugUnitTests(PRInt32 *outNumTests, PRInt32 *outNumTestsFailed)
     1: {
     1: #ifdef DEBUG
 43807:   NS_ENSURE_TRUE(outNumTests && outNumTestsFailed, NS_ERROR_NULL_POINTER);
     1: 
     1:   TextEditorTest *tester = new TextEditorTest();
 43807:   NS_ENSURE_TRUE(tester, NS_ERROR_OUT_OF_MEMORY);
     1:    
     1:   tester->Run(this, outNumTests, outNumTestsFailed);
     1:   delete tester;
     1:   return NS_OK;
     1: #else
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: #endif
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
 79445: nsHTMLEditor::StyleSheetLoaded(nsCSSStyleSheet* aSheet, bool aWasAlternate,
     1:                                nsresult aStatus)
     1: {
     1:   nsresult rv = NS_OK;
     1:   nsAutoEditBatch batchIt(this);
     1: 
     1:   if (!mLastStyleSheetURL.IsEmpty())
     1:     RemoveStyleSheet(mLastStyleSheetURL);
     1: 
  3030:   nsRefPtr<AddStyleSheetTxn> txn;
  3030:   rv = CreateTxnForAddStyleSheet(aSheet, getter_AddRefs(txn));
     1:   if (!txn) rv = NS_ERROR_NULL_POINTER;
     1:   if (NS_SUCCEEDED(rv))
     1:   {
     1:     rv = DoTransaction(txn);
     1:     if (NS_SUCCEEDED(rv))
     1:     {
     1:       // Get the URI, then url spec from the sheet
     1:       nsCAutoString spec;
 42400:       rv = aSheet->GetSheetURI()->GetSpec(spec);
     1: 
     1:       if (NS_SUCCEEDED(rv))
     1:       {
     1:         // Save it so we can remove before applying the next one
     1:         mLastStyleSheetURL.AssignWithConversion(spec.get());
     1: 
     1:         // Also save in our arrays of urls and sheets
     1:         AddNewStyleSheetToList(mLastStyleSheetURL, aSheet);
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: /** All editor operations which alter the doc should be prefaced
     1:  *  with a call to StartOperation, naming the action and direction */
     1: NS_IMETHODIMP
 97808: nsHTMLEditor::StartOperation(OperationID opID,
 97808:                              nsIEditor::EDirection aDirection)
     1: {
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
     1:   nsEditor::StartOperation(opID, aDirection);  // will set mAction, mDirection
     1:   if (mRules) return mRules->BeforeEdit(mAction, mDirection);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: /** All editor operations which alter the doc should be followed
     1:  *  with a call to EndOperation */
     1: NS_IMETHODIMP
     1: nsHTMLEditor::EndOperation()
     1: {
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
     1:   // post processing
     1:   nsresult res = NS_OK;
     1:   if (mRules) res = mRules->AfterEdit(mAction, mDirection);
     1:   nsEditor::EndOperation();  // will clear mAction, mDirection
     1:   return res;
     1: }  
     1: 
 79445: bool 
 97376: nsHTMLEditor::TagCanContainTag(nsIAtom* aParentTag, nsIAtom* aChildTag)
 97376: {
 97376:   MOZ_ASSERT(aParentTag && aChildTag);
 97376: 
     1:   nsIParserService* parserService = nsContentUtils::GetParserService();
     1: 
     1:   PRInt32 childTagEnum;
     1:   // XXX Should this handle #cdata-section too?
 97376:   if (aChildTag == nsGkAtoms::textTagName) {
     1:     childTagEnum = eHTMLTag_text;
 97376:   } else {
 97376:     childTagEnum = parserService->HTMLAtomTagToId(aChildTag);
 97376:   }
 97376: 
 97376:   PRInt32 parentTagEnum = parserService->HTMLAtomTagToId(aParentTag);
     1:   NS_ASSERTION(parentTagEnum < NS_HTML_TAG_MAX,
     1:                "Fix the caller, this type of node can never contain children.");
     1: 
     1:   return nsHTMLEditUtils::CanContain(parentTagEnum, childTagEnum);
     1: }
     1: 
 79445: bool
     1: nsHTMLEditor::IsContainer(nsIDOMNode *aNode)
     1: {
     1:   if (!aNode) {
 80486:     return false;
     1:   }
     1: 
     1:   nsAutoString stringTag;
     1: 
     1:   nsresult rv = aNode->GetNodeName(stringTag);
 80486:   NS_ENSURE_SUCCESS(rv, false);
     1: 
     1:   PRInt32 tagEnum;
     1:   // XXX Should this handle #cdata-section too?
     1:   if (stringTag.EqualsLiteral("#text")) {
     1:     tagEnum = eHTMLTag_text;
     1:   }
     1:   else {
     1:     tagEnum = nsContentUtils::GetParserService()->HTMLStringTagToId(stringTag);
     1:   }
     1: 
     1:   return nsHTMLEditUtils::IsContainer(tagEnum);
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SelectEntireDocument(nsISelection *aSelection)
     1: {
     1:   if (!aSelection || !mRules) { return NS_ERROR_NULL_POINTER; }
     1:   
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
     1:   // get editor root node
 83343:   nsCOMPtr<nsIDOMElement> rootElement = do_QueryInterface(GetRoot());
     1:   
     1:   // is doc empty?
 79445:   bool bDocIsEmpty;
     1:   nsresult res = mRules->DocumentIsEmpty(&bDocIsEmpty);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:     
     1:   if (bDocIsEmpty)
     1:   {
     1:     // if its empty dont select entire doc - that would select the bogus node
     1:     return aSelection->Collapse(rootElement, 0);
     1:   }
     1: 
     1:   return nsEditor::SelectEntireDocument(aSelection);
     1: }
     1: 
  2896: NS_IMETHODIMP
  2896: nsHTMLEditor::SelectAll()
  2896: {
  2896:   ForceCompositionEnd();
  2896: 
  2896:   nsresult rv;
 63588:   nsCOMPtr<nsISelectionController> selCon;
 63588:   rv = GetSelectionController(getter_AddRefs(selCon));
  2896:   NS_ENSURE_SUCCESS(rv, rv);
  2896: 
  2896:   nsCOMPtr<nsISelection> selection;
  2896:   rv = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
  2896:                             getter_AddRefs(selection));
  2896:   NS_ENSURE_SUCCESS(rv, rv);
  2896: 
  2896:   nsCOMPtr<nsIDOMNode> anchorNode;
  2896:   rv = selection->GetAnchorNode(getter_AddRefs(anchorNode));
  2896:   NS_ENSURE_SUCCESS(rv, rv);
  2896: 
  2896:   nsCOMPtr<nsIContent> anchorContent = do_QueryInterface(anchorNode, &rv);
  2896:   NS_ENSURE_SUCCESS(rv, rv);
  2896:   
 47372:   // If the anchor content has independent selection, we never need to explicitly
 47372:   // select its children.
 48083:   if (anchorContent->HasIndependentSelection()) {
 47372:     nsCOMPtr<nsISelectionPrivate> selPriv = do_QueryInterface(selection);
 47372:     NS_ENSURE_TRUE(selPriv, NS_ERROR_UNEXPECTED);
 47372:     rv = selPriv->SetAncestorLimiter(nsnull);
 47372:     NS_ENSURE_SUCCESS(rv, rv);
 83343:     nsCOMPtr<nsIDOMNode> rootElement = do_QueryInterface(mRootElement, &rv);
 83343:     NS_ENSURE_SUCCESS(rv, rv);
 83343:     return selection->SelectAllChildren(rootElement);
 47372:   }
 47372: 
 70236:   nsCOMPtr<nsIPresShell> ps = GetPresShell();
 11914:   nsIContent *rootContent = anchorContent->GetSelectionRootContent(ps);
 37336:   NS_ENSURE_TRUE(rootContent, NS_ERROR_UNEXPECTED);
  2896: 
  2896:   nsCOMPtr<nsIDOMNode> rootElement = do_QueryInterface(rootContent, &rv);
  2896:   NS_ENSURE_SUCCESS(rv, rv);
  2896: 
  2896:   return selection->SelectAllChildren(rootElement);
  2896: }
     1: 
     1: 
     1: // this will NOT find aAttribute unless aAttribute has a non-null value
     1: // so singleton attributes like <Table border> will not be matched!
100183: bool nsHTMLEditor::IsTextPropertySetByContent(nsIContent*      aContent,
100183:                                               nsIAtom*         aProperty,
100183:                                               const nsAString* aAttribute,
100183:                                               const nsAString* aValue,
100183:                                               nsAString*       outValue)
100183: {
100183:   MOZ_ASSERT(aContent && aProperty);
100183:   MOZ_ASSERT_IF(aAttribute, aValue);
100183:   bool isSet;
100183:   IsTextPropertySetByContent(aContent->AsDOMNode(), aProperty, aAttribute,
100183:                              aValue, isSet, outValue);
100183:   return isSet;
100183: }
100183: 
     1: void nsHTMLEditor::IsTextPropertySetByContent(nsIDOMNode        *aNode,
     1:                                               nsIAtom           *aProperty, 
     1:                                               const nsAString   *aAttribute, 
     1:                                               const nsAString   *aValue, 
 79445:                                               bool              &aIsSet,
     1:                                               nsAString *outValue)
     1: {
     1:   nsresult result;
 80486:   aIsSet = false;  // must be initialized to false for code below to work
     1:   nsAutoString propName;
     1:   aProperty->ToString(propName);
     1:   nsCOMPtr<nsIDOMNode>node = aNode;
     1: 
     1:   while (node)
     1:   {
     1:     nsCOMPtr<nsIDOMElement>element;
     1:     element = do_QueryInterface(node);
     1:     if (element)
     1:     {
     1:       nsAutoString tag, value;
     1:       element->GetTagName(tag);
     1:       if (propName.Equals(tag, nsCaseInsensitiveStringComparator()))
     1:       {
 79445:         bool found = false;
     1:         if (aAttribute && 0!=aAttribute->Length())
     1:         {
     1:           element->GetAttribute(*aAttribute, value);
     1:           if (outValue) *outValue = value;
     1:           if (!value.IsEmpty())
     1:           {
     1:             if (!aValue) {
 80486:               found = true;
     1:             }
     1:             else
     1:             {
     1:               nsString tString(*aValue);
     1:               if (tString.Equals(value, nsCaseInsensitiveStringComparator())) {
 80486:                 found = true;
     1:               }
     1:               else {  // we found the prop with the attribute, but the value doesn't match
     1:                 break;
     1:               }
     1:             }
     1:           }
     1:         }
     1:         else { 
 80486:           found = true;
     1:         }
     1:         if (found)
     1:         {
 80486:           aIsSet = true;
     1:           break;
     1:         }
     1:       }
     1:     }
     1:     nsCOMPtr<nsIDOMNode>temp;
     1:     result = node->GetParentNode(getter_AddRefs(temp));
     1:     if (NS_SUCCEEDED(result) && temp) {
     1:       node = temp;
     1:     }
     1:     else {
     1:       node = nsnull;
     1:     }
     1:   }
     1: }
     1: 
     1: 
     1: //================================================================
     1: // HTML Editor methods
     1: //
     1: // Note: Table Editing methods are implemented in nsTableEditor.cpp
     1: //
     1: 
     1: 
 79445: bool
     1: nsHTMLEditor::SetCaretInTableCell(nsIDOMElement* aElement)
     1: {
 89174:   nsCOMPtr<dom::Element> element = do_QueryInterface(aElement);
 89779:   if (!element || !element->IsHTML() ||
 89779:       !nsHTMLEditUtils::IsTableElement(element) ||
 97989:       !IsDescendantOfEditorRoot(element)) {
 89174:     return false;
 89174:   }
 89174: 
 89174:   nsIContent* node = element;
 89174:   while (node->HasChildren()) {
 89174:     node = node->GetFirstChild();
 89174:   }
 89174: 
 89174:   // Set selection at beginning of the found node
     1:   nsCOMPtr<nsISelection> selection;
 89174:   nsresult rv = GetSelection(getter_AddRefs(selection));
 89174:   NS_ENSURE_SUCCESS(rv, false);
 89174:   NS_ENSURE_TRUE(selection, false);
 89174: 
 89174:   return NS_SUCCEEDED(selection->CollapseNative(node, 0));
     1: }            
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetEnclosingTable: find ancestor who is a table, if any
     1: //                  
     1: nsCOMPtr<nsIDOMNode> 
     1: nsHTMLEditor::GetEnclosingTable(nsIDOMNode *aNode)
     1: {
     1:   NS_PRECONDITION(aNode, "null node passed to nsHTMLEditor::GetEnclosingTable");
     1:   nsCOMPtr<nsIDOMNode> tbl, tmp, node = aNode;
     1: 
     1:   while (!tbl)
     1:   {
     1:     tmp = GetBlockNodeParent(node);
     1:     if (!tmp) break;
     1:     if (nsHTMLEditUtils::IsTable(tmp)) tbl = tmp;
     1:     node = tmp;
     1:   }
     1:   return tbl;
     1: }
     1: 
     1: 
     1: /* this method scans the selection for adjacent text nodes
     1:  * and collapses them into a single text node.
     1:  * "adjacent" means literally adjacent siblings of the same parent.
     1:  * Uses nsEditor::JoinNodes so action is undoable. 
     1:  * Should be called within the context of a batch transaction.
     1:  */
     1: NS_IMETHODIMP
     1: nsHTMLEditor::CollapseAdjacentTextNodes(nsIDOMRange *aInRange)
     1: {
 43806:   NS_ENSURE_TRUE(aInRange, NS_ERROR_NULL_POINTER);
     1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
 27986:   nsTArray<nsIDOMNode*> textNodes;
 27986:   // we can't actually do anything during iteration, so store the text nodes in an array
     1:   // don't bother ref counting them because we know we can hold them for the 
     1:   // lifetime of this method
     1: 
     1: 
     1:   // build a list of editable text nodes
     1:   nsresult result;
     1:   nsCOMPtr<nsIContentIterator> iter =
     1:     do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &result);
 43805:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   iter->Init(aInRange);
     1: 
     1:   while (!iter->IsDone())
     1:   {
 89778:     nsINode* node = iter->GetCurrentNode();
 89778:     if (node->NodeType() == nsIDOMNode::TEXT_NODE &&
 89778:         IsEditable(static_cast<nsIContent*>(node))) {
 89778:       nsCOMPtr<nsIDOMNode> domNode = do_QueryInterface(node);
 89778:       textNodes.AppendElement(domNode);
     1:     }
     1: 
     1:     iter->Next();
     1:   }
     1: 
     1:   // now that I have a list of text nodes, collapse adjacent text nodes
     1:   // NOTE: assumption that JoinNodes keeps the righthand node
 27986:   while (textNodes.Length() > 1)
     1:   {
     1:     // we assume a textNodes entry can't be nsnull
 27986:     nsIDOMNode *leftTextNode = textNodes[0];
 27986:     nsIDOMNode *rightTextNode = textNodes[1];
     1:     NS_ASSERTION(leftTextNode && rightTextNode,"left or rightTextNode null in CollapseAdjacentTextNodes");
     1: 
 90153:     // get the prev sibling of the right node, and see if its leftTextNode
     1:     nsCOMPtr<nsIDOMNode> prevSibOfRightNode;
 14819:     result =
 14819:       rightTextNode->GetPreviousSibling(getter_AddRefs(prevSibOfRightNode));
 43805:     NS_ENSURE_SUCCESS(result, result);
     1:     if (prevSibOfRightNode && (prevSibOfRightNode == leftTextNode))
     1:     {
     1:       nsCOMPtr<nsIDOMNode> parent;
     1:       result = rightTextNode->GetParentNode(getter_AddRefs(parent));
 43805:       NS_ENSURE_SUCCESS(result, result);
 43806:       NS_ENSURE_TRUE(parent, NS_ERROR_NULL_POINTER);
     1:       result = JoinNodes(leftTextNode, rightTextNode, parent);
 43805:       NS_ENSURE_SUCCESS(result, result);
     1:     }
     1: 
     1:     textNodes.RemoveElementAt(0); // remove the leftmost text node from the list
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsHTMLEditor::SetSelectionAtDocumentStart(nsISelection *aSelection)
     1: {
 89778:   dom::Element* rootElement = GetRoot();
 43807:   NS_ENSURE_TRUE(rootElement, NS_ERROR_NULL_POINTER);
     1: 
 89778:   return aSelection->CollapseNative(rootElement, 0);
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
 90153: // RemoveBlockContainer: remove inNode, reparenting its children into their
     1: //                  the parent of inNode.  In addition, INSERT ANY BR's NEEDED
     1: //                  TO PRESERVE IDENTITY OF REMOVED BLOCK.
     1: //
     1: nsresult
     1: nsHTMLEditor::RemoveBlockContainer(nsIDOMNode *inNode)
     1: {
 43807:   NS_ENSURE_TRUE(inNode, NS_ERROR_NULL_POINTER);
     1:   nsresult res;
     1:   nsCOMPtr<nsIDOMNode> sibling, child, unused;
     1:   
     1:   // Two possibilities: the container cold be empty of editable content.
     1:   // If that is the case, we need to compare what is before and after inNode
     1:   // to determine if we need a br.
     1:   // Or it could not be empty, in which case we have to compare previous
     1:   // sibling and first child to determine if we need a leading br,
     1:   // and compare following sibling and last child to determine if we need a
     1:   // trailing br.
     1:   
     1:   res = GetFirstEditableChild(inNode, address_of(child));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   if (child)  // the case of inNode not being empty
     1:   {
     1:     // we need a br at start unless:
     1:     // 1) previous sibling of inNode is a block, OR
     1:     // 2) previous sibling of inNode is a br, OR
     1:     // 3) first child of inNode is a block OR
     1:     // 4) either is null
     1:     
     1:     res = GetPriorHTMLSibling(inNode, address_of(sibling));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if (sibling && !IsBlockNode(sibling) && !nsTextEditUtils::IsBreak(sibling))
     1:     {
     1:       res = GetFirstEditableChild(inNode, address_of(child));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       if (child && !IsBlockNode(child))
     1:       {
     1:         // insert br node
     1:         res = CreateBR(inNode, 0, address_of(unused));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:     }
     1:     
     1:     // we need a br at end unless:
     1:     // 1) following sibling of inNode is a block, OR
     1:     // 2) last child of inNode is a block, OR
     1:     // 3) last child of inNode is a block OR
     1:     // 4) either is null
     1: 
     1:     res = GetNextHTMLSibling(inNode, address_of(sibling));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if (sibling && !IsBlockNode(sibling))
     1:     {
     1:       res = GetLastEditableChild(inNode, address_of(child));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       if (child && !IsBlockNode(child) && !nsTextEditUtils::IsBreak(child))
     1:       {
     1:         // insert br node
     1:         PRUint32 len;
     1:         res = GetLengthOfDOMNode(inNode, len);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         res = CreateBR(inNode, (PRInt32)len, address_of(unused));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:     }
     1:   }
     1:   else  // the case of inNode being empty
     1:   {
     1:     // we need a br at start unless:
     1:     // 1) previous sibling of inNode is a block, OR
     1:     // 2) previous sibling of inNode is a br, OR
     1:     // 3) following sibling of inNode is a block, OR
     1:     // 4) following sibling of inNode is a br OR
     1:     // 5) either is null
     1:     res = GetPriorHTMLSibling(inNode, address_of(sibling));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if (sibling && !IsBlockNode(sibling) && !nsTextEditUtils::IsBreak(sibling))
     1:     {
     1:       res = GetNextHTMLSibling(inNode, address_of(sibling));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       if (sibling && !IsBlockNode(sibling) && !nsTextEditUtils::IsBreak(sibling))
     1:       {
     1:         // insert br node
     1:         res = CreateBR(inNode, 0, address_of(unused));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:     }
     1:   }
     1:     
     1:   // now remove container
     1:   return RemoveContainer(inNode);
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetPriorHTMLSibling: returns the previous editable sibling, if there is
     1: //                   one within the parent
     1: //                       
 97758: nsIContent*
 95456: nsHTMLEditor::GetPriorHTMLSibling(nsINode* aNode)
 95456: {
 95456:   MOZ_ASSERT(aNode);
 95456: 
 95456:   nsIContent* node = aNode->GetPreviousSibling();
 95456:   while (node && !IsEditable(node)) {
 95456:     node = node->GetPreviousSibling();
 95456:   }
 95456: 
 95456:   return node;
 95456: }
 95456: 
     1: nsresult
     1: nsHTMLEditor::GetPriorHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode)
     1: {
 95456:   NS_ENSURE_TRUE(outNode, NS_ERROR_NULL_POINTER);
 95456:   *outNode = NULL;
 95456: 
 95456:   nsCOMPtr<nsINode> node = do_QueryInterface(inNode);
 95456:   NS_ENSURE_TRUE(node, NS_ERROR_NULL_POINTER);
 95456: 
 95456:   *outNode = do_QueryInterface(GetPriorHTMLSibling(node));
 73978:   return NS_OK;
 73978: }
     1: 
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetPriorHTMLSibling: returns the previous editable sibling, if there is
     1: //                   one within the parent.  just like above routine but
     1: //                   takes a parent/offset instead of a node.
     1: //                       
 97758: nsIContent*
 95456: nsHTMLEditor::GetPriorHTMLSibling(nsINode* aParent, PRInt32 aOffset)
 95456: {
 95456:   MOZ_ASSERT(aParent);
 95456: 
 95456:   nsIContent* node = aParent->GetChildAt(aOffset - 1);
 95456:   if (!node || IsEditable(node)) {
 95456:     return node;
 95456:   }
 95456: 
 95456:   return GetPriorHTMLSibling(node);
 95456: }
 95456: 
     1: nsresult
     1: nsHTMLEditor::GetPriorHTMLSibling(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode)
     1: {
 95456:   NS_ENSURE_TRUE(outNode, NS_ERROR_NULL_POINTER);
 95456:   *outNode = NULL;
 95456: 
 95456:   nsCOMPtr<nsINode> parent = do_QueryInterface(inParent);
 95456:   NS_ENSURE_TRUE(parent, NS_ERROR_NULL_POINTER);
 95456: 
 95456:   *outNode = do_QueryInterface(GetPriorHTMLSibling(parent, inOffset));
 73978:   return NS_OK;
 73978: }
     1: 
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetNextHTMLSibling: returns the next editable sibling, if there is
     1: //                   one within the parent
     1: //                       
 97758: nsIContent*
 95456: nsHTMLEditor::GetNextHTMLSibling(nsINode* aNode)
 95456: {
 95456:   MOZ_ASSERT(aNode);
 95456: 
 95456:   nsIContent* node = aNode->GetNextSibling();
 95456:   while (node && !IsEditable(node)) {
 95456:     node = node->GetNextSibling();
 95456:   }
 95456: 
 95456:   return node;
 95456: }
 95456: 
     1: nsresult
     1: nsHTMLEditor::GetNextHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode)
     1: {
 43806:   NS_ENSURE_TRUE(outNode, NS_ERROR_NULL_POINTER);
     1:   *outNode = nsnull;
 95456: 
 95456:   nsCOMPtr<nsINode> node = do_QueryInterface(inNode);
 95456:   NS_ENSURE_TRUE(node, NS_ERROR_NULL_POINTER);
 95456:   
 95456:   *outNode = do_QueryInterface(GetNextHTMLSibling(node));
 73978:   return NS_OK;
 73978: }
     1: 
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetNextHTMLSibling: returns the next editable sibling, if there is
     1: //                   one within the parent.  just like above routine but
     1: //                   takes a parent/offset instead of a node.
 97758: nsIContent*
 95456: nsHTMLEditor::GetNextHTMLSibling(nsINode* aParent, PRInt32 aOffset)
 95456: {
 95456:   MOZ_ASSERT(aParent);
 95456: 
 95456:   nsIContent* node = aParent->GetChildAt(aOffset + 1);
 95456:   if (!node || IsEditable(node)) {
 95456:     return node;
 95456:   }
 95456: 
 95456:   return GetNextHTMLSibling(node);
 95456: }
 95456: 
     1: nsresult
     1: nsHTMLEditor::GetNextHTMLSibling(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode)
     1: {
 95456:   NS_ENSURE_TRUE(outNode, NS_ERROR_NULL_POINTER);
 95456:   *outNode = NULL;
 95456: 
 95456:   nsCOMPtr<nsINode> parent = do_QueryInterface(inParent);
 95456:   NS_ENSURE_TRUE(parent, NS_ERROR_NULL_POINTER);
 95456: 
 95456:   *outNode = do_QueryInterface(GetNextHTMLSibling(parent, inOffset));
 73978:   return NS_OK;
 73978: }
     1: 
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetPriorHTMLNode: returns the previous editable leaf node, if there is
     1: //                   one within the <body>
     1: //
     1: nsresult
 79445: nsHTMLEditor::GetPriorHTMLNode(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode, bool bNoBlockCrossing)
     1: {
 43806:   NS_ENSURE_TRUE(outNode, NS_ERROR_NULL_POINTER);
 82864: 
 82864:   nsIContent* activeEditingHost = GetActiveEditingHost();
 82864:   if (!activeEditingHost) {
     1:     *outNode = nsnull;
 82864:     return NS_OK;
 82864:   }
 82864: 
 97988:   nsresult res = GetPriorNode(inNode, true, address_of(*outNode),
 97988:                               bNoBlockCrossing);
 82864:   NS_ENSURE_SUCCESS(res, res);
 82864:   
 97989:   NS_ASSERTION(!*outNode || IsDescendantOfEditorRoot(*outNode),
 82864:                "GetPriorNode screwed up");
     1:   return res;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetPriorHTMLNode: same as above but takes {parent,offset} instead of node
     1: //                       
     1: nsresult
 79445: nsHTMLEditor::GetPriorHTMLNode(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode, bool bNoBlockCrossing)
     1: {
 43806:   NS_ENSURE_TRUE(outNode, NS_ERROR_NULL_POINTER);
 82864: 
 82864:   nsIContent* activeEditingHost = GetActiveEditingHost();
 82864:   if (!activeEditingHost) {
     1:     *outNode = nsnull;
 82864:     return NS_OK;
 82864:   }
 82864: 
 97988:   nsresult res = GetPriorNode(inParent, inOffset, true, address_of(*outNode),
 97988:                               bNoBlockCrossing);
 82864:   NS_ENSURE_SUCCESS(res, res);
 82864:   
 97989:   NS_ASSERTION(!*outNode || IsDescendantOfEditorRoot(*outNode),
 82864:                "GetPriorNode screwed up");
     1:   return res;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetNextHTMLNode: returns the next editable leaf node, if there is
     1: //                   one within the <body>
     1: //                       
     1: nsresult
 79445: nsHTMLEditor::GetNextHTMLNode(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode, bool bNoBlockCrossing)
     1: {
 43806:   NS_ENSURE_TRUE(outNode, NS_ERROR_NULL_POINTER);
 80486:   nsresult res = GetNextNode(inNode, true, address_of(*outNode), bNoBlockCrossing);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // if it's not in the body, then zero it out
 97989:   if (*outNode && !IsDescendantOfEditorRoot(*outNode)) {
     1:     *outNode = nsnull;
     1:   }
     1:   return res;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // GetNHTMLextNode: same as above but takes {parent,offset} instead of node
     1: //                       
     1: nsresult
 79445: nsHTMLEditor::GetNextHTMLNode(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode, bool bNoBlockCrossing)
     1: {
 43806:   NS_ENSURE_TRUE(outNode, NS_ERROR_NULL_POINTER);
 80486:   nsresult res = GetNextNode(inParent, inOffset, true, address_of(*outNode), bNoBlockCrossing);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   // if it's not in the body, then zero it out
 97989:   if (*outNode && !IsDescendantOfEditorRoot(*outNode)) {
     1:     *outNode = nsnull;
     1:   }
     1:   return res;
     1: }
     1: 
     1: 
     1: nsresult 
 79445: nsHTMLEditor::IsFirstEditableChild( nsIDOMNode *aNode, bool *aOutIsFirst)
     1: {
     1:   // check parms
 43806:   NS_ENSURE_TRUE(aOutIsFirst && aNode, NS_ERROR_NULL_POINTER);
     1:   
     1:   // init out parms
 80486:   *aOutIsFirst = false;
     1:   
     1:   // find first editable child and compare it to aNode
     1:   nsCOMPtr<nsIDOMNode> parent, firstChild;
     1:   nsresult res = aNode->GetParentNode(getter_AddRefs(parent));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(parent, NS_ERROR_FAILURE);
     1:   res = GetFirstEditableChild(parent, address_of(firstChild));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   *aOutIsFirst = (firstChild.get() == aNode);
     1:   return res;
     1: }
     1: 
     1: 
     1: nsresult 
 79445: nsHTMLEditor::IsLastEditableChild( nsIDOMNode *aNode, bool *aOutIsLast)
     1: {
     1:   // check parms
 43806:   NS_ENSURE_TRUE(aOutIsLast && aNode, NS_ERROR_NULL_POINTER);
     1:   
     1:   // init out parms
 80486:   *aOutIsLast = false;
     1:   
     1:   // find last editable child and compare it to aNode
     1:   nsCOMPtr<nsIDOMNode> parent, lastChild;
     1:   nsresult res = aNode->GetParentNode(getter_AddRefs(parent));
 43805:   NS_ENSURE_SUCCESS(res, res);
 43806:   NS_ENSURE_TRUE(parent, NS_ERROR_FAILURE);
     1:   res = GetLastEditableChild(parent, address_of(lastChild));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   *aOutIsLast = (lastChild.get() == aNode);
     1:   return res;
     1: }
     1: 
     1: 
     1: nsresult 
     1: nsHTMLEditor::GetFirstEditableChild( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutFirstChild)
     1: {
     1:   // check parms
 43806:   NS_ENSURE_TRUE(aOutFirstChild && aNode, NS_ERROR_NULL_POINTER);
     1:   
     1:   // init out parms
     1:   *aOutFirstChild = nsnull;
     1:   
     1:   // find first editable child
     1:   nsCOMPtr<nsIDOMNode> child;
     1:   nsresult res = aNode->GetFirstChild(getter_AddRefs(child));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   while (child && !IsEditable(child))
     1:   {
     1:     nsCOMPtr<nsIDOMNode> tmp;
     1:     res = child->GetNextSibling(getter_AddRefs(tmp));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
     1:     child = tmp;
     1:   }
     1:   
     1:   *aOutFirstChild = child;
     1:   return res;
     1: }
     1: 
     1: 
     1: nsresult 
     1: nsHTMLEditor::GetLastEditableChild( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutLastChild)
     1: {
     1:   // check parms
 43806:   NS_ENSURE_TRUE(aOutLastChild && aNode, NS_ERROR_NULL_POINTER);
     1:   
     1:   // init out parms
     1:   *aOutLastChild = aNode;
     1:   
     1:   // find last editable child
     1:   nsCOMPtr<nsIDOMNode> child;
     1:   nsresult res = aNode->GetLastChild(getter_AddRefs(child));
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   
     1:   while (child && !IsEditable(child))
     1:   {
     1:     nsCOMPtr<nsIDOMNode> tmp;
     1:     res = child->GetPreviousSibling(getter_AddRefs(tmp));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
     1:     child = tmp;
     1:   }
     1:   
     1:   *aOutLastChild = child;
     1:   return res;
     1: }
     1: 
     1: nsresult 
     1: nsHTMLEditor::GetFirstEditableLeaf( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutFirstLeaf)
     1: {
     1:   // check parms
 43806:   NS_ENSURE_TRUE(aOutFirstLeaf && aNode, NS_ERROR_NULL_POINTER);
     1:   
     1:   // init out parms
     1:   *aOutFirstLeaf = aNode;
     1:   
     1:   // find leftmost leaf
     1:   nsCOMPtr<nsIDOMNode> child;
     1:   nsresult res = NS_OK;
     1:   child = GetLeftmostChild(aNode);  
     1:   while (child && (!IsEditable(child) || !nsEditorUtils::IsLeafNode(child)))
     1:   {
     1:     nsCOMPtr<nsIDOMNode> tmp;
     1:     res = GetNextHTMLNode(child, address_of(tmp));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
     1:     
     1:     // only accept nodes that are descendants of aNode
     1:     if (nsEditorUtils::IsDescendantOf(tmp, aNode))
     1:       child = tmp;
     1:     else
     1:     {
     1:       child = nsnull;  // this will abort the loop
     1:     }
     1:   }
     1:   
     1:   *aOutFirstLeaf = child;
     1:   return res;
     1: }
     1: 
     1: 
     1: nsresult 
     1: nsHTMLEditor::GetLastEditableLeaf(nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutLastLeaf)
     1: {
     1:   // check parms
 43806:   NS_ENSURE_TRUE(aOutLastLeaf && aNode, NS_ERROR_NULL_POINTER);
     1:   
     1:   // init out parms
     1:   *aOutLastLeaf = nsnull;
     1:   
     1:   // find rightmost leaf
 80486:   nsCOMPtr<nsIDOMNode> child = GetRightmostChild(aNode, false);
     1:   nsresult res = NS_OK;
     1:   while (child && (!IsEditable(child) || !nsEditorUtils::IsLeafNode(child)))
     1:   {
     1:     nsCOMPtr<nsIDOMNode> tmp;
     1:     res = GetPriorHTMLNode(child, address_of(tmp));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(tmp, NS_ERROR_FAILURE);
     1:     
     1:     // only accept nodes that are descendants of aNode
     1:     if (nsEditorUtils::IsDescendantOf(tmp, aNode))
     1:       child = tmp;
     1:     else
     1:     {
     1:       child = nsnull;
     1:     }
     1:   }
     1:   
     1:   *aOutLastLeaf = child;
     1:   return res;
     1: }
     1: 
 79445: bool
 82861: nsHTMLEditor::IsTextInDirtyFrameVisible(nsIContent *aNode)
     1: {
 97761:   MOZ_ASSERT(aNode);
 97761:   MOZ_ASSERT(aNode->NodeType() == nsIDOMNode::TEXT_NODE);
 97761: 
 79445:   bool isEmptyTextNode;
 88027:   nsresult rv = IsVisTextNode(aNode, &isEmptyTextNode, false);
 88027:   if (NS_FAILED(rv)) {
     1:     // We are following the historical decision:
     1:     //   if we don't know, we say it's visible...
 80486:     return true;
     1:   }
     1: 
     1:   return !isEmptyTextNode;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // IsVisTextNode: figure out if textnode aTextNode has any visible content.
     1: //                  
     1: nsresult
 88027: nsHTMLEditor::IsVisTextNode(nsIContent* aNode,
 88027:                             bool* outIsEmptyNode,
 88027:                             bool aSafeToAskFrames)
 88027: {
 97761:   MOZ_ASSERT(aNode);
 97761:   MOZ_ASSERT(aNode->NodeType() == nsIDOMNode::TEXT_NODE);
 97761:   MOZ_ASSERT(outIsEmptyNode);
 97761: 
 80486:   *outIsEmptyNode = true;
 88028: 
 88028:   PRUint32 length = aNode->TextLength();
     1:   if (aSafeToAskFrames)
     1:   {
     1:     nsCOMPtr<nsISelectionController> selCon;
 88028:     nsresult res = GetSelectionController(getter_AddRefs(selCon));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
 79445:     bool isVisible = false;
     1:     // ask the selection controller for information about whether any
     1:     // of the data in the node is really rendered.  This is really
     1:     // something that frames know about, but we aren't supposed to talk to frames.
     1:     // So we put a call in the selection controller interface, since it's already
     1:     // in bed with frames anyway.  (this is a fix for bug 22227, and a
     1:     // partial fix for bug 46209)
 88028:     res = selCon->CheckVisibilityContent(aNode, 0, length, &isVisible);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if (isVisible) 
     1:     {
 80486:       *outIsEmptyNode = false;
     1:     }
     1:   }
     1:   else if (length)
     1:   {
 88028:     if (aNode->TextIsOnlyWhitespace())
 88028:     {
 88028:       nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aNode);
 88028:       nsWSRunObject wsRunObj(this, node, 0);
     1:       nsCOMPtr<nsIDOMNode> visNode;
     1:       PRInt32 outVisOffset=0;
     1:       PRInt16 visType=0;
101070:       wsRunObj.NextVisibleNode(node, 0, address_of(visNode),
 88028:                                &outVisOffset, &visType);
     1:       if ( (visType == nsWSRunObject::eNormalWS) ||
     1:            (visType == nsWSRunObject::eText) )
     1:       {
 88028:         *outIsEmptyNode = (node != visNode);
     1:       }
     1:     }
     1:     else
     1:     {
 80486:       *outIsEmptyNode = false;
     1:     }
     1:   }
     1:   return NS_OK;  
     1: }
     1:   
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // IsEmptyNode: figure out if aNode is an empty node.
     1: //               A block can have children and still be considered empty,
     1: //               if the children are empty or non-editable.
     1: //                  
     1: nsresult
     1: nsHTMLEditor::IsEmptyNode( nsIDOMNode *aNode, 
 79445:                            bool *outIsEmptyNode, 
 79445:                            bool aSingleBRDoesntCount,
 79445:                            bool aListOrCellNotEmpty,
 79445:                            bool aSafeToAskFrames)
     1: {
 88027:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
 88029:   return IsEmptyNode(node, outIsEmptyNode, aSingleBRDoesntCount,
 88029:                      aListOrCellNotEmpty, aSafeToAskFrames);
 88029: }
 88029: 
 88029: nsresult
 88029: nsHTMLEditor::IsEmptyNode(nsINode* aNode,
 88029:                           bool* outIsEmptyNode,
 88029:                           bool aSingleBRDoesntCount,
 88029:                           bool aListOrCellNotEmpty,
 88029:                           bool aSafeToAskFrames)
 88029: {
 88029:   NS_ENSURE_TRUE(aNode && outIsEmptyNode, NS_ERROR_NULL_POINTER);
 80486:   *outIsEmptyNode = true;
 79445:   bool seenBR = false;
 88029:   return IsEmptyNodeImpl(aNode, outIsEmptyNode, aSingleBRDoesntCount,
     1:                          aListOrCellNotEmpty, aSafeToAskFrames, &seenBR);
     1: }
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // IsEmptyNodeImpl: workhorse for IsEmptyNode.
     1: //                  
     1: nsresult
 88027: nsHTMLEditor::IsEmptyNodeImpl(nsINode* aNode,
 79445:                               bool *outIsEmptyNode,
 79445:                               bool aSingleBRDoesntCount,
 79445:                               bool aListOrCellNotEmpty,
 79445:                               bool aSafeToAskFrames,
 79445:                               bool *aSeenBR)
     1: {
 43806:   NS_ENSURE_TRUE(aNode && outIsEmptyNode && aSeenBR, NS_ERROR_NULL_POINTER);
 88027: 
 88027:   if (aNode->NodeType() == nsIDOMNode::TEXT_NODE) {
 88027:     return IsVisTextNode(static_cast<nsIContent*>(aNode), outIsEmptyNode, aSafeToAskFrames);
     1:   }
     1: 
     1:   // if it's not a text node (handled above) and it's not a container,
     1:   // then we don't call it empty (it's an <hr>, or <br>, etc).
     1:   // Also, if it's an anchor then don't treat it as empty - even though
     1:   // anchors are containers, named anchors are "empty" but we don't
     1:   // want to treat them as such.  Also, don't call ListItems or table
     1:   // cells empty if caller desires.  Form Widgets not empty.
101122:   if (!IsContainer(aNode->AsDOMNode())                      ||
 88027:       (aNode->IsElement() &&
 88027:        (nsHTMLEditUtils::IsNamedAnchor(aNode->AsElement())  ||
 88027:         nsHTMLEditUtils::IsFormWidget(aNode->AsElement())   ||
 88027:         (aListOrCellNotEmpty &&
 88027:          (nsHTMLEditUtils::IsListItem(aNode->AsElement())   ||
 88027:           nsHTMLEditUtils::IsTableCell(aNode->AsElement()))))))  {
 80486:     *outIsEmptyNode = false;
     1:     return NS_OK;
     1:   }
     1:     
     1:   // need this for later
 88027:   bool isListItemOrCell = aNode->IsElement() &&
 88027:        (nsHTMLEditUtils::IsListItem(aNode->AsElement()) ||
 88027:         nsHTMLEditUtils::IsTableCell(aNode->AsElement()));
     1:        
     1:   // loop over children of node. if no children, or all children are either 
     1:   // empty text nodes or non-editable, then node qualifies as empty
 88027:   for (nsCOMPtr<nsIContent> child = aNode->GetFirstChild();
 88027:        child;
 88027:        child = child->GetNextSibling()) {
 88027:     // Is the child editable and non-empty?  if so, return false
 88027:     if (nsEditor::IsEditable(child)) {
 88027:       if (child->NodeType() == nsIDOMNode::TEXT_NODE) {
 88027:         nsresult rv = IsVisTextNode(child, outIsEmptyNode, aSafeToAskFrames);
 88027:         NS_ENSURE_SUCCESS(rv, rv);
 73913:         // break out if we find we aren't emtpy
 73913:         if (!*outIsEmptyNode) {
 73913:           return NS_OK;
 73913:         }
 88027:       } else {
 88027:         // An editable, non-text node. We need to check its content.
 88027:         // Is it the node we are iterating over?
 88027:         if (child == aNode) {
 88027:           break;
 88027:         }
 88027: 
 88027:         if (aSingleBRDoesntCount && !*aSeenBR && child->IsHTML(nsGkAtoms::br)) {
     1:           // the first br in a block doesn't count if the caller so indicated
 80486:           *aSeenBR = true;
 88027:         } else {
     1:           // is it an empty node of some sort?
     1:           // note: list items or table cells are not considered empty
     1:           // if they contain other lists or tables
 88027:           if (child->IsElement()) {
 88027:             if (isListItemOrCell) {
 88027:               if (nsHTMLEditUtils::IsList(child->AsElement()) || child->IsHTML(nsGkAtoms::table)) {
 88027:                 // break out if we find we aren't empty
 80486:                 *outIsEmptyNode = false;
     1:                 return NS_OK;
     1:               }
 88027:             } else if (nsHTMLEditUtils::IsFormWidget(child->AsElement())) {
     1:               // is it a form widget?
 88027:               // break out if we find we aren't empty
 80486:               *outIsEmptyNode = false;
     1:               return NS_OK;
     1:             }
 88027:           }
     1: 
 79445:           bool isEmptyNode = true;
 88027:           nsresult rv = IsEmptyNodeImpl(child, &isEmptyNode,
 88027:                                         aSingleBRDoesntCount,
 88027:                                         aListOrCellNotEmpty, aSafeToAskFrames,
 88027:                                         aSeenBR);
 88027:           NS_ENSURE_SUCCESS(rv, rv);
 88027:           if (!isEmptyNode) {
     1:             // otherwise it ain't empty
 80486:             *outIsEmptyNode = false;
     1:             return NS_OK;
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: // add to aElement the CSS inline styles corresponding to the HTML attribute
     1: // aAttribute with its value aValue
     1: nsresult
     1: nsHTMLEditor::SetAttributeOrEquivalent(nsIDOMElement * aElement,
     1:                                        const nsAString & aAttribute,
     1:                                        const nsAString & aValue,
 79445:                                        bool aSuppressTransaction)
 79445: {
     1:   nsresult res = NS_OK;
 89175:   if (IsCSSEnabled() && mHTMLCSSUtils) {
     1:     PRInt32 count;
     1:     res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(aElement, nsnull, &aAttribute, &aValue, &count,
     1:                                                      aSuppressTransaction);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     if (count) {
     1:       // we found an equivalence ; let's remove the HTML attribute itself if it is set
     1:       nsAutoString existingValue;
 79445:       bool wasSet = false;
     1:       res = GetAttributeValue(aElement, aAttribute, existingValue, &wasSet);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       if (wasSet) {
     1:         if (aSuppressTransaction)
     1:           res = aElement->RemoveAttribute(aAttribute);
     1:         else
     1:           res = RemoveAttribute(aElement, aAttribute);
     1:       }
     1:     }
     1:     else {
     1:       // count is an integer that represents the number of CSS declarations applied to the
     1:       // element. If it is zero, we found no equivalence in this implementation for the
     1:       // attribute
     1:       if (aAttribute.EqualsLiteral("style")) {
     1:         // if it is the style attribute, just add the new value to the existing style
     1:         // attribute's value
     1:         nsAutoString existingValue;
 79445:         bool wasSet = false;
     1:         res = GetAttributeValue(aElement, NS_LITERAL_STRING("style"), existingValue, &wasSet);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         existingValue.AppendLiteral(" ");
     1:         existingValue.Append(aValue);
     1:         if (aSuppressTransaction)
     1:           res = aElement->SetAttribute(aAttribute, existingValue);
     1:         else
     1:           res = SetAttribute(aElement, aAttribute, existingValue);
     1:       }
     1:       else {
     1:         // we have no CSS equivalence for this attribute and it is not the style
     1:         // attribute; let's set it the good'n'old HTML way
     1:         if (aSuppressTransaction)
     1:           res = aElement->SetAttribute(aAttribute, aValue);
     1:         else
     1:           res = SetAttribute(aElement, aAttribute, aValue);
     1:       }
     1:     }
     1:   }
     1:   else {
     1:     // we are not in an HTML+CSS editor; let's set the attribute the HTML way
     1:     if (aSuppressTransaction)
     1:       res = aElement->SetAttribute(aAttribute, aValue);
     1:     else
     1:       res = SetAttribute(aElement, aAttribute, aValue);
     1:   }  
     1:   return res;
     1: }
     1: 
     1: nsresult
     1: nsHTMLEditor::RemoveAttributeOrEquivalent(nsIDOMElement * aElement,
     1:                                           const nsAString & aAttribute,
 79445:                                           bool aSuppressTransaction)
 79445: {
     1:   nsresult res = NS_OK;
 89175:   if (IsCSSEnabled() && mHTMLCSSUtils) {
     1:     res = mHTMLCSSUtils->RemoveCSSEquivalentToHTMLStyle(aElement, nsnull, &aAttribute, nsnull,
     1:                                                         aSuppressTransaction);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
     1:   nsAutoString existingValue;
 79445:   bool wasSet = false;
     1:   res = GetAttributeValue(aElement, aAttribute, existingValue, &wasSet);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if (wasSet) {
     1:     if (aSuppressTransaction)
     1:       res = aElement->RemoveAttribute(aAttribute);
     1:     else
     1:       res = RemoveAttribute(aElement, aAttribute);
     1:   }
     1:   return res;
     1: }
     1: 
     1: nsresult
 79445: nsHTMLEditor::SetIsCSSEnabled(bool aIsCSSPrefChecked)
     1: {
 89778:   if (!mHTMLCSSUtils) {
 89778:     return NS_ERROR_NOT_INITIALIZED;
 89778:   }
 89778: 
101070:   mHTMLCSSUtils->SetCSSEnabled(aIsCSSPrefChecked);
 89778: 
  7921:   // Disable the eEditorNoCSSMask flag if we're enabling StyleWithCSS.
 40703:   PRUint32 flags = mFlags;
  7921:   if (aIsCSSPrefChecked) {
  7921:     // Turn off NoCSS as we're enabling CSS
 40703:     flags &= ~eEditorNoCSSMask;
 40703:   } else {
  7921:     // Turn on NoCSS, as we're disabling CSS.
 40703:     flags |= eEditorNoCSSMask;
  7921:   }
  7921: 
 89778:   return SetFlags(flags);
     1: }
     1: 
     1: // Set the block background color
     1: NS_IMETHODIMP
     1: nsHTMLEditor::SetCSSBackgroundColor(const nsAString& aColor)
     1: {
     1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
     1:   ForceCompositionEnd();
     1: 
 42937:   // Protect the edit rules object from dying
 42937:   nsCOMPtr<nsIEditRules> kungFuDeathGrip(mRules);
 42937: 
 99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
     1: 
 98815:   bool isCollapsed = selection->Collapsed();
     1: 
     1:   nsAutoEditBatch batchIt(this);
     1:   nsAutoRules beginRulesSniffing(this, kOpInsertElement, nsIEditor::eNext);
     1:   nsAutoSelectionReset selectionResetter(selection, this);
     1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
     1:   
 79445:   bool cancel, handled;
 97808:   nsTextRulesInfo ruleInfo(kOpSetTextProperty);
 99469:   nsresult res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
 43805:   NS_ENSURE_SUCCESS(res, res);
     1:   if (!cancel && !handled)
     1:   {
     1:     // get selection range enumerator
     1:     nsCOMPtr<nsIEnumerator> enumerator;
 99469:     res = selection->GetEnumerator(getter_AddRefs(enumerator));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(enumerator, NS_ERROR_FAILURE);
     1: 
     1:     // loop thru the ranges in the selection
     1:     enumerator->First(); 
     1:     nsCOMPtr<nsISupports> currentItem;
     1:     nsAutoString bgcolor; bgcolor.AssignLiteral("bgcolor");
     1:     nsCOMPtr<nsIDOMNode> cachedBlockParent = nsnull;
     1:     while ((NS_ENUMERATOR_FALSE == enumerator->IsDone()))
     1:     {
     1:       res = enumerator->CurrentItem(getter_AddRefs(currentItem));
 43805:       NS_ENSURE_SUCCESS(res, res);
 43806:       NS_ENSURE_TRUE(currentItem, NS_ERROR_FAILURE);
     1:       
     1:       nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
     1:       
     1:       // check for easy case: both range endpoints in same text node
     1:       nsCOMPtr<nsIDOMNode> startNode, endNode;
     1:       PRInt32 startOffset, endOffset;
     1:       res = range->GetStartContainer(getter_AddRefs(startNode));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       res = range->GetEndContainer(getter_AddRefs(endNode));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       res = range->GetStartOffset(&startOffset);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       res = range->GetEndOffset(&endOffset);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       if ((startNode == endNode) && IsTextNode(startNode))
     1:       {
     1:         // let's find the block container of the text node
     1:         nsCOMPtr<nsIDOMNode> blockParent;
     1:         blockParent = GetBlockNodeParent(startNode);
     1:         // and apply the background color to that block container
     1:         if (cachedBlockParent != blockParent)
     1:         {
     1:           cachedBlockParent = blockParent;
     1:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
     1:           PRInt32 count;
 80486:           res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, false);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:         }
     1:       }
     1:       else if ((startNode == endNode) && nsTextEditUtils::IsBody(startNode) && isCollapsed)
     1:       {
     1:         // we have no block in the document, let's apply the background to the body 
     1:         nsCOMPtr<nsIDOMElement> element = do_QueryInterface(startNode);
     1:         PRInt32 count;
 80486:         res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, false);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:       else if ((startNode == endNode) && (((endOffset-startOffset) == 1) || (!startOffset && !endOffset)))
     1:       {
     1:         // a unique node is selected, let's also apply the background color
     1:         // to the containing block, possibly the node itself
     1:         nsCOMPtr<nsIDOMNode> selectedNode = GetChildAt(startNode, startOffset);
 79445:         bool isBlock =false;
     1:         res = NodeIsBlockStatic(selectedNode, &isBlock);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         nsCOMPtr<nsIDOMNode> blockParent = selectedNode;
     1:         if (!isBlock) {
     1:           blockParent = GetBlockNodeParent(selectedNode);
     1:         }
     1:         if (cachedBlockParent != blockParent)
     1:         {
     1:           cachedBlockParent = blockParent;
     1:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
     1:           PRInt32 count;
 80486:           res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, false);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:         }
     1:       }
     1:       else
     1:       {
     1:         // not the easy case.  range not contained in single text node. 
     1:         // there are up to three phases here.  There are all the nodes
     1:         // reported by the subtree iterator to be processed.  And there
     1:         // are potentially a starting textnode and an ending textnode
     1:         // which are only partially contained by the range.
     1:         
     1:         // lets handle the nodes reported by the iterator.  These nodes
     1:         // are entirely contained in the selection range.  We build up
     1:         // a list of them (since doing operations on the document during
     1:         // iteration would perturb the iterator).
     1: 
     1:         nsCOMPtr<nsIContentIterator> iter =
     1:           do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &res);
 43805:         NS_ENSURE_SUCCESS(res, res);
 43806:         NS_ENSURE_TRUE(iter, NS_ERROR_FAILURE);
     1: 
     1:         nsCOMArray<nsIDOMNode> arrayOfNodes;
     1:         nsCOMPtr<nsIDOMNode> node;
     1:                 
     1:         // iterate range and build up array
     1:         res = iter->Init(range);
     1:         // init returns an error if no nodes in range.
     1:         // this can easily happen with the subtree 
     1:         // iterator if the selection doesn't contain
     1:         // any *whole* nodes.
     1:         if (NS_SUCCEEDED(res))
     1:         {
     1:           while (!iter->IsDone())
     1:           {
     1:             node = do_QueryInterface(iter->GetCurrentNode());
 43807:             NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
     1: 
     1:             if (IsEditable(node))
     1:             {
     1:               arrayOfNodes.AppendObject(node);
     1:             }
     1: 
     1:             iter->Next();
     1:           }
     1:         }
     1:         // first check the start parent of the range to see if it needs to 
     1:         // be separately handled (it does if it's a text node, due to how the
     1:         // subtree iterator works - it will not have reported it).
     1:         if (IsTextNode(startNode) && IsEditable(startNode))
     1:         {
     1:           nsCOMPtr<nsIDOMNode> blockParent;
     1:           blockParent = GetBlockNodeParent(startNode);
     1:           if (cachedBlockParent != blockParent)
     1:           {
     1:             cachedBlockParent = blockParent;
     1:             nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
     1:             PRInt32 count;
 80486:             res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, false);
 43805:             NS_ENSURE_SUCCESS(res, res);
     1:           }
     1:         }
     1:         
     1:         // then loop through the list, set the property on each node
     1:         PRInt32 listCount = arrayOfNodes.Count();
     1:         PRInt32 j;
     1:         for (j = 0; j < listCount; j++)
     1:         {
     1:           node = arrayOfNodes[j];
     1:           // do we have a block here ?
 79445:           bool isBlock =false;
     1:           res = NodeIsBlockStatic(node, &isBlock);
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:           nsCOMPtr<nsIDOMNode> blockParent = node;
     1:           if (!isBlock) {
     1:             // no we don't, let's find the block ancestor
     1:             blockParent = GetBlockNodeParent(node);
     1:           }
     1:           if (cachedBlockParent != blockParent)
     1:           {
     1:             cachedBlockParent = blockParent;
     1:             nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
     1:             PRInt32 count;
     1:             // and set the property on it
 80486:             res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, false);
 43805:             NS_ENSURE_SUCCESS(res, res);
     1:           }
     1:         }
     1:         arrayOfNodes.Clear();
     1:         
     1:         // last check the end parent of the range to see if it needs to 
     1:         // be separately handled (it does if it's a text node, due to how the
     1:         // subtree iterator works - it will not have reported it).
     1:         if (IsTextNode(endNode) && IsEditable(endNode))
     1:         {
     1:           nsCOMPtr<nsIDOMNode> blockParent;
     1:           blockParent = GetBlockNodeParent(endNode);
     1:           if (cachedBlockParent != blockParent)
     1:           {
     1:             cachedBlockParent = blockParent;
     1:             nsCOMPtr<nsIDOMElement> element = do_QueryInterface(blockParent);
     1:             PRInt32 count;
 80486:             res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, nsnull, &bgcolor, &aColor, &count, false);
 43805:             NS_ENSURE_SUCCESS(res, res);
     1:           }
     1:         }
     1:       }
     1:       enumerator->Next();
     1:     }
     1:   }
     1:   if (!cancel)
     1:   {
     1:     // post-process
     1:     res = mRules->DidDoAction(selection, &ruleInfo, res);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::SetBackgroundColor(const nsAString& aColor)
     1: {
     1:   nsresult res;
 89175:   if (IsCSSEnabled()) {
     1:     // if we are in CSS mode, we have to apply the background color to the
     1:     // containing block (or the body if we have no block-level element in
     1:     // the document)
     1:     res = SetCSSBackgroundColor(aColor);
     1:   }
     1:   else {
     1:     // but in HTML mode, we can only set the document's background color
     1:     res = SetHTMLBackgroundColor(aColor);
     1:   }
     1:   return res;
     1: }
     1: 
     1: ///////////////////////////////////////////////////////////////////////////
     1: // NodesSameType: do these nodes have the same tag?
     1: //                    
 98809: /* virtual */
 79445: bool
 98809: nsHTMLEditor::AreNodesSameType(nsIContent* aNode1, nsIContent* aNode2)
 98809: {
 98809:   MOZ_ASSERT(aNode1);
 98809:   MOZ_ASSERT(aNode2);
 98809: 
 98809:   if (aNode1->Tag() != aNode2->Tag()) {
 80486:     return false;
     1:   }
     1: 
 98809:   if (!IsCSSEnabled() || !aNode1->IsHTML(nsGkAtoms::span)) {
 80486:     return true;
     1:   }
 98809: 
 98809:   // If CSS is enabled, we are stricter about span nodes.
 98809:   return mHTMLCSSUtils->ElementsSameStyle(aNode1->AsDOMNode(),
 98809:                                           aNode2->AsDOMNode());
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::CopyLastEditableChildStyles(nsIDOMNode * aPreviousBlock, nsIDOMNode * aNewBlock,
     1:                                           nsIDOMNode **aOutBrNode)
     1: {
     1:   *aOutBrNode = nsnull;
     1:   nsCOMPtr<nsIDOMNode> child, tmp;
     1:   nsresult res;
     1:   // first, clear out aNewBlock.  Contract is that we want only the styles from previousBlock.
     1:   res = aNewBlock->GetFirstChild(getter_AddRefs(child));
     1:   while (NS_SUCCEEDED(res) && child)
     1:   {
     1:     res = DeleteNode(child);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     res = aNewBlock->GetFirstChild(getter_AddRefs(child));
     1:   }
     1:   // now find and clone the styles
     1:   child = aPreviousBlock;
     1:   tmp = aPreviousBlock;
     1:   while (tmp) {
     1:     child = tmp;
     1:     res = GetLastEditableChild(child, address_of(tmp));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1:   while (child && nsTextEditUtils::IsBreak(child)) {
     1:     nsCOMPtr<nsIDOMNode> priorNode;
     1:     res = GetPriorHTMLNode(child, address_of(priorNode));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     child = priorNode;
     1:   }
     1:   nsCOMPtr<nsIDOMNode> newStyles = nsnull, deepestStyle = nsnull;
     1:   while (child && (child != aPreviousBlock)) {
     1:     if (nsHTMLEditUtils::IsInlineStyle(child) ||
     1:         nsEditor::NodeIsType(child, nsEditProperty::span)) {
     1:       nsAutoString domTagName;
     1:       child->GetNodeName(domTagName);
     1:       ToLowerCase(domTagName);
     1:       if (newStyles) {
     1:         nsCOMPtr<nsIDOMNode> newContainer;
     1:         res = InsertContainerAbove(newStyles, address_of(newContainer), domTagName);
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         newStyles = newContainer;
     1:       }
     1:       else {
     1:         res = CreateNode(domTagName, aNewBlock, 0, getter_AddRefs(newStyles));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         deepestStyle = newStyles;
     1:       }
     1:       res = CloneAttributes(newStyles, child);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:     }
     1:     nsCOMPtr<nsIDOMNode> tmp;
     1:     res = child->GetParentNode(getter_AddRefs(tmp));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     child = tmp;
     1:   }
     1:   if (deepestStyle) {
     1:     nsCOMPtr<nsIDOMNode> outBRNode;
     1:     res = CreateBR(deepestStyle, 0, address_of(outBRNode));
 43805:     NS_ENSURE_SUCCESS(res, res);
     1:     // Getters must addref
 89778:     outBRNode.forget(aOutBrNode);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsHTMLEditor::GetElementOrigin(nsIDOMElement * aElement, PRInt32 & aX, PRInt32 & aY)
     1: {
 10522:   aX = 0;
 10522:   aY = 0;
 10522: 
 63587:   NS_ENSURE_TRUE(mDocWeak, NS_ERROR_NOT_INITIALIZED);
 70236:   nsCOMPtr<nsIPresShell> ps = GetPresShell();
 43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
 36657:   nsIFrame *frame = content->GetPrimaryFrame();
 51499:   NS_ENSURE_TRUE(frame, NS_OK);
 10522: 
 10522:   nsIFrame *container = ps->GetAbsoluteContainingBlock(frame);
 51499:   NS_ENSURE_TRUE(container, NS_OK);
 10522:   nsPoint off = frame->GetOffsetTo(container);
 10522:   aX = nsPresContext::AppUnitsToIntCSSPixels(off.x);
 10522:   aY = nsPresContext::AppUnitsToIntCSSPixels(off.y);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsHTMLEditor::EndUpdateViewBatch()
     1: {
     1:   nsresult res = nsEditor::EndUpdateViewBatch();
 43805:   NS_ENSURE_SUCCESS(res, res);
     1: 
     1:   // We may need to show resizing handles or update existing ones after
     1:   // all transactions are done. This way of doing is preferred to DOM
     1:   // mutation events listeners because all the changes the user can apply
     1:   // to a document may result in multiple events, some of them quite hard
     1:   // to listen too (in particular when an ancestor of the selection is
     1:   // changed but the selection itself is not changed).
     1:   if (mUpdateCount == 0) {
     1:     nsCOMPtr<nsISelection> selection;
     1:     res = GetSelection(getter_AddRefs(selection));
 43805:     NS_ENSURE_SUCCESS(res, res);
 43806:     NS_ENSURE_TRUE(selection, NS_ERROR_NOT_INITIALIZED);
     1:     res = CheckSelectionStateForAnonymousButtons(selection);
     1:   }
     1:   return res;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsHTMLEditor::GetSelectionContainer(nsIDOMElement ** aReturn)
     1: {
     1:   nsCOMPtr<nsISelection>selection;
     1:   nsresult res = GetSelection(getter_AddRefs(selection));
     1:   // if we don't get the selection, just skip this
     1:   if (NS_FAILED(res) || !selection) return res;
     1: 
     1:   nsCOMPtr<nsIDOMNode> focusNode;
     1: 
 98815:   if (selection->Collapsed()) {
     1:     res = selection->GetFocusNode(getter_AddRefs(focusNode));
 43805:     NS_ENSURE_SUCCESS(res, res);
 98815:   } else {
     1: 
     1:     PRInt32 rangeCount;
     1:     res = selection->GetRangeCount(&rangeCount);
 43805:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     if (rangeCount == 1) {
     1: 
     1:       nsCOMPtr<nsIDOMRange> range;
     1:       res = selection->GetRangeAt(0, getter_AddRefs(range));
 43805:       NS_ENSURE_SUCCESS(res, res);
 43806:       NS_ENSURE_TRUE(range, NS_ERROR_NULL_POINTER);
     1: 
     1:       nsCOMPtr<nsIDOMNode> startContainer, endContainer;
     1:       res = range->GetStartContainer(getter_AddRefs(startContainer));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       res = range->GetEndContainer(getter_AddRefs(endContainer));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       PRInt32 startOffset, endOffset;
     1:       res = range->GetStartOffset(&startOffset);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       res = range->GetEndOffset(&endOffset);
 43805:       NS_ENSURE_SUCCESS(res, res);
     1: 
     1:       nsCOMPtr<nsIDOMElement> focusElement;
     1:       if (startContainer == endContainer && startOffset + 1 == endOffset) {
     1:         res = GetSelectedElement(EmptyString(), getter_AddRefs(focusElement));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         if (focusElement)
     1:           focusNode = do_QueryInterface(focusElement);
     1:       }
     1:       if (!focusNode) {
     1:         res = range->GetCommonAncestorContainer(getter_AddRefs(focusNode));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:       }
     1:     }
     1:     else {
     1:       PRInt32 i;
     1:       nsCOMPtr<nsIDOMRange> range;
     1:       for (i = 0; i < rangeCount; i++)
     1:       {
     1:         res = selection->GetRangeAt(i, getter_AddRefs(range));
 43805:         NS_ENSURE_SUCCESS(res, res);
     1:         nsCOMPtr<nsIDOMNode> startContainer;
 26710:         res = range->GetStartContainer(getter_AddRefs(startContainer));
 26710:         if (NS_FAILED(res)) continue;
     1:         if (!focusNode)
     1:           focusNode = startContainer;
     1:         else if (focusNode != startContainer) {
     1:           res = startContainer->GetParentNode(getter_AddRefs(focusNode));
 43805:           NS_ENSURE_SUCCESS(res, res);
     1:           break;
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (focusNode) {
     1:     PRUint16 nodeType;
     1:     focusNode->GetNodeType(&nodeType);
     1:     if (nsIDOMNode::TEXT_NODE == nodeType) {
     1:       nsCOMPtr<nsIDOMNode> parent;
     1:       res = focusNode->GetParentNode(getter_AddRefs(parent));
 43805:       NS_ENSURE_SUCCESS(res, res);
     1:       focusNode = parent;
     1:     }
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMElement> focusElement = do_QueryInterface(focusNode);
 89778:   focusElement.forget(aReturn);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsHTMLEditor::IsAnonymousElement(nsIDOMElement * aElement, bool * aReturn)
     1: {
     1:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
 16126:   *aReturn = content->IsRootOfNativeAnonymousSubtree();
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 79445: nsHTMLEditor::SetReturnInParagraphCreatesNewParagraph(bool aCreatesNewParagraph)
     1: {
     1:   mCRInParagraphCreatesParagraph = aCreatesNewParagraph;
     1:   return NS_OK;
     1: }
     1: 
101070: bool
101070: nsHTMLEditor::GetReturnInParagraphCreatesNewParagraph()
101070: {
101070:   return mCRInParagraphCreatesParagraph;
101070: }
101070: 
     1: nsresult
 79445: nsHTMLEditor::GetReturnInParagraphCreatesNewParagraph(bool *aCreatesNewParagraph)
     1: {
     1:   *aCreatesNewParagraph = mCRInParagraphCreatesParagraph;
     1:   return NS_OK;
     1: }
 41886: 
 56870: already_AddRefed<nsIContent>
 56870: nsHTMLEditor::GetFocusedContent()
 56870: {
 56870:   NS_ENSURE_TRUE(mDocWeak, nsnull);
 41886: 
 41886:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
 56870:   NS_ENSURE_TRUE(fm, nsnull);
 41886: 
 41886:   nsCOMPtr<nsIContent> focusedContent = fm->GetFocusedContent();
 41886: 
 41886:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 79445:   bool inDesignMode = doc->HasFlag(NODE_IS_EDITABLE);
 41886:   if (!focusedContent) {
 41886:     // in designMode, nobody gets focus in most cases.
 56870:     if (inDesignMode && OurWindowHasFocus()) {
 56870:       nsCOMPtr<nsIContent> docRoot = doc->GetRootElement();
 56870:       return docRoot.forget();
 56870:     }
 56870:     return nsnull;
 41886:   }
 41886: 
 41886:   if (inDesignMode) {
 56870:     return OurWindowHasFocus() &&
 56870:       nsContentUtils::ContentIsDescendantOf(focusedContent, doc) ?
 56870:       focusedContent.forget() : nsnull;
 41886:   }
 41886: 
 41886:   // We're HTML editor for contenteditable
 41886: 
 41886:   // If the focused content isn't editable, or it has independent selection,
 41886:   // we don't have focus.
 41886:   if (!focusedContent->HasFlag(NODE_IS_EDITABLE) ||
 48083:       focusedContent->HasIndependentSelection()) {
 56870:     return nsnull;
 41886:   }
 42886:   // If our window is focused, we're focused.
 56870:   return OurWindowHasFocus() ? focusedContent.forget() : nsnull;
 41886: }
 41886: 
 79445: bool
 48083: nsHTMLEditor::IsActiveInDOMWindow()
 48083: {
 80486:   NS_ENSURE_TRUE(mDocWeak, false);
 48083: 
 48083:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
 80486:   NS_ENSURE_TRUE(fm, false);
 48083: 
 48083:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 79445:   bool inDesignMode = doc->HasFlag(NODE_IS_EDITABLE);
 48083: 
 48083:   // If we're in designMode, we're always active in the DOM window.
 48083:   if (inDesignMode) {
 80486:     return true;
 48083:   }
 48083: 
 48083:   nsPIDOMWindow* ourWindow = doc->GetWindow();
 48083:   nsCOMPtr<nsPIDOMWindow> win;
 48083:   nsIContent* content =
 80486:     nsFocusManager::GetFocusedDescendant(ourWindow, false,
 48083:                                          getter_AddRefs(win));
 48083:   if (!content) {
 80486:     return false;
 48083:   }
 48083: 
 48083:   // We're HTML editor for contenteditable
 48083: 
 48083:   // If the active content isn't editable, or it has independent selection,
 48083:   // we're not active).
 48083:   if (!content->HasFlag(NODE_IS_EDITABLE) ||
 48083:       content->HasIndependentSelection()) {
 80486:     return false;
 80486:   }
 80486:   return true;
 48083: }
 48083: 
 97987: dom::Element*
 73913: nsHTMLEditor::GetActiveEditingHost()
 73913: {
 84914:   NS_ENSURE_TRUE(mDocWeak, nsnull);
 73913: 
 73913:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 73913:   NS_ENSURE_TRUE(doc, nsnull);
 73913:   if (doc->HasFlag(NODE_IS_EDITABLE)) {
 73913:     return doc->GetBodyElement();
 73913:   }
 73913: 
 73913:   // We're HTML editor for contenteditable
 73913:   nsCOMPtr<nsISelection> selection;
 73913:   nsresult rv = GetSelection(getter_AddRefs(selection));
 73913:   NS_ENSURE_SUCCESS(rv, nsnull);
 73913:   nsCOMPtr<nsIDOMNode> focusNode;
 73913:   rv = selection->GetFocusNode(getter_AddRefs(focusNode));
 73913:   NS_ENSURE_SUCCESS(rv, nsnull);
 73913:   nsCOMPtr<nsIContent> content = do_QueryInterface(focusNode);
 73913:   if (!content) {
 73913:     return nsnull;
 73913:   }
 73913: 
 73913:   // If the active content isn't editable, or it has independent selection,
 73913:   // we're not active.
 73913:   if (!content->HasFlag(NODE_IS_EDITABLE) ||
 73913:       content->HasIndependentSelection()) {
 73913:     return nsnull;
 73913:   }
 73913:   return content->GetEditingHost();
 73913: }
 73913: 
 72326: already_AddRefed<nsIDOMEventTarget>
 72327: nsHTMLEditor::GetDOMEventTarget()
 43714: {
 43714:   // Don't use getDocument here, because we have no way of knowing
 43714:   // whether Init() was ever called.  So we need to get the document
 43714:   // ourselves, if it exists.
 43714:   NS_PRECONDITION(mDocWeak, "This editor has not been initialized yet");
 72327:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryReferent(mDocWeak.get());
 72327:   return target.forget();
 43714: }
 43714: 
 79445: bool
 43717: nsHTMLEditor::ShouldReplaceRootElement()
 43717: {
 43717:   if (!mRootElement) {
 43717:     // If we don't know what is our root element, we should find our root.
 80486:     return true;
 43717:   }
 43717: 
 43717:   // If we temporary set document root element to mRootElement, but there is
 43717:   // body element now, we should replace the root element by the body element.
 43717:   nsCOMPtr<nsIDOMHTMLElement> docBody;
 43717:   GetBodyElement(getter_AddRefs(docBody));
 43717:   return !SameCOMIdentity(docBody, mRootElement);
 43717: }
 43717: 
 43717: void
 43717: nsHTMLEditor::ResetRootElementAndEventTarget()
 43717: {
 48014:   nsCOMPtr<nsIMutationObserver> kungFuDeathGrip(this);
 48014: 
 43717:   // Need to remove the event listeners first because BeginningOfDocument
 43717:   // could set a new root (and event target is set by InstallEventListeners())
 43717:   // and we won't be able to remove them from the old event target then.
 43717:   RemoveEventListeners();
 43717:   mRootElement = nsnull;
 43717:   nsresult rv = InstallEventListeners();
 86974:   if (NS_FAILED(rv)) {
 86974:     return;
 86974:   }
 43843: 
 43843:   // We must have mRootElement now.
 43843:   nsCOMPtr<nsIDOMElement> root;
 43843:   rv = GetRootElement(getter_AddRefs(root));
 86974:   if (NS_FAILED(rv) || !mRootElement) {
 86974:     return;
 86974:   }
 43717: 
 43717:   rv = BeginningOfDocument();
 86974:   if (NS_FAILED(rv)) {
 86974:     return;
 86974:   }
 43717: 
 43717:   // When this editor has focus, we need to reset the selection limiter to
 43717:   // new root.  Otherwise, that is going to be done when this gets focus.
 43717:   nsCOMPtr<nsINode> node = GetFocusedNode();
 43717:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(node);
 43717:   if (target) {
 43717:     InitializeSelection(target);
 43717:   }
 43717: 
 43717:   SyncRealTimeSpell();
 43717: }
 43717: 
 43713: nsresult
 43713: nsHTMLEditor::GetBodyElement(nsIDOMHTMLElement** aBody)
 43713: {
 43713:   NS_PRECONDITION(mDocWeak, "bad state, null mDocWeak");
 43713:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryReferent(mDocWeak);
 43713:   if (!htmlDoc) {
 43713:     return NS_ERROR_NOT_INITIALIZED;
 43713:   }
 43713:   return htmlDoc->GetBody(aBody);
 43713: }
 43713: 
 43717: already_AddRefed<nsINode>
 43717: nsHTMLEditor::GetFocusedNode()
 43717: {
 56870:   nsCOMPtr<nsIContent> focusedContent = GetFocusedContent();
 56870:   if (!focusedContent) {
 43717:     return nsnull;
 43717:   }
 43717: 
 43717:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 43717:   NS_ASSERTION(fm, "Focus manager is null");
 43717:   nsCOMPtr<nsIDOMElement> focusedElement;
 43717:   fm->GetFocusedElement(getter_AddRefs(focusedElement));
 43717:   if (focusedElement) {
 43717:     nsCOMPtr<nsINode> node = do_QueryInterface(focusedElement);
 43717:     return node.forget();
 43717:   }
 43717: 
 43717:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 89778:   return doc.forget();
 43717: }
 43717: 
 79445: bool
 41886: nsHTMLEditor::OurWindowHasFocus()
 41886: {
 80486:   NS_ENSURE_TRUE(mDocWeak, false);
 41886:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 80486:   NS_ENSURE_TRUE(fm, false);
 41886:   nsCOMPtr<nsIDOMWindow> focusedWindow;
 41886:   fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
 41886:   if (!focusedWindow) {
 80486:     return false;
 41886:   }
 41886:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
 41886:   nsCOMPtr<nsIDOMWindow> ourWindow = do_QueryInterface(doc->GetWindow());
 41886:   return ourWindow == focusedWindow;
 41886: }
 41886: 
 79445: bool
 48083: nsHTMLEditor::IsAcceptableInputEvent(nsIDOMEvent* aEvent)
 48083: {
 48083:   if (!nsEditor::IsAcceptableInputEvent(aEvent)) {
 80486:     return false;
 80486:   }
 80486: 
 80486:   NS_ENSURE_TRUE(mDocWeak, false);
 48083: 
 48083:   nsCOMPtr<nsIDOMEventTarget> target;
 48083:   aEvent->GetTarget(getter_AddRefs(target));
 80486:   NS_ENSURE_TRUE(target, false);
 48083: 
 48083:   nsCOMPtr<nsIDocument> document = do_QueryReferent(mDocWeak);
 48083:   if (document->HasFlag(NODE_IS_EDITABLE)) {
 48083:     // If this editor is in designMode and the event target is the document,
 48083:     // the event is for this editor.
 48083:     nsCOMPtr<nsIDocument> targetDocument = do_QueryInterface(target);
 48083:     if (targetDocument) {
 48083:       return targetDocument == document;
 48083:     }
 48083:     // Otherwise, check whether the event target is in this document or not.
 48083:     nsCOMPtr<nsIContent> targetContent = do_QueryInterface(target);
 80486:     NS_ENSURE_TRUE(targetContent, false);
 48083:     return document == targetContent->GetCurrentDoc();
 48083:   }
 48083: 
 82789:   // This HTML editor is for contenteditable.  We need to check the validity of
 82789:   // the target.
 48083:   nsCOMPtr<nsIContent> targetContent = do_QueryInterface(target);
 80486:   NS_ENSURE_TRUE(targetContent, false);
 82789: 
 82789:   // If the event is a mouse event, we need to check if the target content is
 82789:   // the focused editing host or its descendant.
 82789:   nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
 82789:   if (mouseEvent) {
 82789:     nsIContent* editingHost = GetActiveEditingHost();
 82789:     // If there is no active editing host, we cannot handle the mouse event
 82789:     // correctly.
 82789:     if (!editingHost) {
 82789:       return false;
 82789:     }
 82789:     // If clicked on non-editable root element but the body element is the
 82789:     // active editing host, we should assume that the click event is targetted.
 82789:     if (targetContent == document->GetRootElement() &&
 82789:         !targetContent->HasFlag(NODE_IS_EDITABLE) &&
 82789:         editingHost == document->GetBodyElement()) {
 82789:       targetContent = editingHost;
 82789:     }
 82789:     // If the target element is neither the active editing host nor a descendant
 82789:     // of it, we may not be able to handle the event.
 82789:     if (!nsContentUtils::ContentIsDescendantOf(targetContent, editingHost)) {
 82789:       return false;
 82789:     }
 82789:     // If the clicked element has an independent selection, we shouldn't
 82789:     // handle this click event.
 82789:     if (targetContent->HasIndependentSelection()) {
 82789:       return false;
 82789:     }
 82789:     // If the target content is editable, we should handle this event.
 82789:     return targetContent->HasFlag(NODE_IS_EDITABLE);
 82789:   }
 82789: 
 82789:   // If the target of the other events which target focused element isn't
 82789:   // editable or has an independent selection, this editor shouldn't handle the
 82789:   // event.
 48083:   if (!targetContent->HasFlag(NODE_IS_EDITABLE) ||
 48083:       targetContent->HasIndependentSelection()) {
 80486:     return false;
 48083:   }
 48083: 
 48083:   // Finally, check whether we're actually focused or not.  When we're not
 48083:   // focused, we should ignore the dispatched event by script (or something)
 48083:   // because content editable element needs selection in itself for editing.
 48083:   // However, when we're not focused, it's not guaranteed.
 48083:   return IsActiveInDOMWindow();
 41886: }
 41886: 
 41886: NS_IMETHODIMP
 82843: nsHTMLEditor::GetPreferredIMEState(IMEState *aState)
 82843: {
 82843:   // HTML editor don't prefer the CSS ime-mode because IE didn't do so too.
 82843:   aState->mOpen = IMEState::DONT_CHANGE_OPEN_STATE;
 41886:   if (IsReadonly() || IsDisabled()) {
 82843:     aState->mEnabled = IMEState::DISABLED;
 82843:   } else {
 82843:     aState->mEnabled = IMEState::ENABLED;
 82843:   }
 41886:   return NS_OK;
 41886: }
 94119: 
 94119: already_AddRefed<nsIContent>
 94119: nsHTMLEditor::GetInputEventTargetContent()
 94119: {
 94119:   nsCOMPtr<nsIContent> target = GetActiveEditingHost();
 94119:   return target.forget();
 94119: }
 97988: 
 98127: bool
 98127: nsHTMLEditor::IsEditable(nsIContent* aNode) {
 98127:   if (!nsPlaintextEditor::IsEditable(aNode)) {
 98127:     return false;
 98127:   }
 98127:   if (aNode->IsElement()) {
 98127:     // If we're dealing with an element, then ask it whether it's editable.
 98127:     return aNode->IsEditable();
 98127:   }
 98127:   // We might be dealing with a text node for example, which we always consider
 98127:   // to be editable.
 98127:   return true;
 98127: }
 98127: 
 97988: // virtual MOZ_OVERRIDE
 97988: dom::Element*
 97988: nsHTMLEditor::GetEditorRoot()
 97988: {
 97988:   return GetActiveEditingHost();
 97988: }
