39447: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
39447:  * ***** BEGIN LICENSE BLOCK *****
39447:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
39447:  *
39447:  * The contents of this file are subject to the Mozilla Public License Version
39447:  * 1.1 (the "License"); you may not use this file except in compliance with
39447:  * the License. You may obtain a copy of the License at
39447:  * http://www.mozilla.org/MPL/
39447:  *
39447:  * Software distributed under the License is distributed on an "AS IS" basis,
39447:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
39447:  * for the specific language governing rights and limitations under the
39447:  * License.
39447:  *
39447:  * The Original Code is Mozilla Foundation code.
39447:  *
39447:  * The Initial Developer of the Original Code is Mozilla Foundation.
39447:  * Portions created by the Initial Developer are Copyright (C) 2005-2010
39447:  * the Initial Developer. All Rights Reserved.
39447:  *
39447:  * Contributor(s):
39447:  *   Stuart Parmenter <stuart@mozilla.com>
39447:  *   Masayuki Nakano <masayuki@d-toybox.com>
39447:  *   Mats Palmgren <mats.palmgren@bredband.net>
39447:  *   John Daggett <jdaggett@mozilla.com>
39447:  *   Jonathan Kew <jfkthame@gmail.com>
39447:  *
39447:  * Alternatively, the contents of this file may be used under the terms of
39447:  * either the GNU General Public License Version 2 or later (the "GPL"), or
39447:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
39447:  * in which case the provisions of the GPL or the LGPL are applicable instead
39447:  * of those above. If you wish to allow use of your version of this file only
39447:  * under the terms of either the GPL or the LGPL, and not to allow others to
39447:  * use your version of this file under the terms of the MPL, indicate your
39447:  * decision by deleting the provisions above and replace them with the notice
39447:  * and other provisions required by the GPL or the LGPL. If you do not delete
39447:  * the provisions above, a recipient may use your version of this file under
39447:  * the terms of any one of the MPL, the GPL or the LGPL.
39447:  *
39447:  * ***** END LICENSE BLOCK ***** */
39447: 
39447: #include "gfxGDIFont.h"
39447: #include "gfxGDIShaper.h"
39447: #include "gfxUniscribeShaper.h"
43527: #include "gfxHarfBuzzShaper.h"
39447: #include "gfxWindowsPlatform.h"
39447: #include "gfxContext.h"
46221: #include "gfxUnicodeProperties.h"
39447: 
39447: #include "cairo-win32.h"
39447: 
39447: #define ROUND(x) floor((x) + 0.5)
39447: 
39447: static inline cairo_antialias_t
39447: GetCairoAntialiasOption(gfxFont::AntialiasOption anAntialiasOption)
39447: {
39447:     switch (anAntialiasOption) {
39447:     default:
39447:     case gfxFont::kAntialiasDefault:
39447:         return CAIRO_ANTIALIAS_DEFAULT;
39447:     case gfxFont::kAntialiasNone:
39447:         return CAIRO_ANTIALIAS_NONE;
39447:     case gfxFont::kAntialiasGrayscale:
39447:         return CAIRO_ANTIALIAS_GRAY;
39447:     case gfxFont::kAntialiasSubpixel:
39447:         return CAIRO_ANTIALIAS_SUBPIXEL;
39447:     }
39447: }
39447: 
39447: gfxGDIFont::gfxGDIFont(GDIFontEntry *aFontEntry,
39447:                        const gfxFontStyle *aFontStyle,
39447:                        PRBool aNeedsBold,
39447:                        AntialiasOption anAAOption)
39447:     : gfxFont(aFontEntry, aFontStyle, anAAOption),
39447:       mFont(NULL),
39447:       mFontFace(nsnull),
39447:       mScaledFont(nsnull),
41898:       mMetrics(nsnull),
41898:       mSpaceGlyph(0),
41898:       mNeedsBold(aNeedsBold)
39447: {
43527:     if (FontCanSupportHarfBuzz()) {
43527:         mHarfBuzzShaper = new gfxHarfBuzzShaper(this);
43459:     }
39447: }
39447: 
39447: gfxGDIFont::~gfxGDIFont()
39447: {
39447:     if (mScaledFont) {
39447:         cairo_scaled_font_destroy(mScaledFont);
39447:     }
39447:     if (mFontFace) {
39447:         cairo_font_face_destroy(mFontFace);
39447:     }
39447:     if (mFont) {
39447:         ::DeleteObject(mFont);
39447:     }
41898:     delete mMetrics;
39447: }
39447: 
43527: void
43527: gfxGDIFont::CreatePlatformShaper()
43527: {
43527:     mPlatformShaper = new gfxGDIShaper(this);
43527: }
43527: 
39447: gfxFont*
39447: gfxGDIFont::CopyWithAntialiasOption(AntialiasOption anAAOption)
39447: {
39447:     return new gfxGDIFont(static_cast<GDIFontEntry*>(mFontEntry.get()),
39447:                           &mStyle, mNeedsBold, anAAOption);
39447: }
39447: 
46221: static PRBool
46221: UseUniscribe(gfxTextRun *aTextRun,
46221:              const PRUnichar *aString,
46221:              PRUint32 aRunStart,
46221:              PRUint32 aRunLength)
46221: {
46221:     PRUint32 flags = aTextRun->GetFlags();
46221:     PRBool useGDI;
46221: 
46221:     PRBool isXP = (gfxWindowsPlatform::WindowsOSVersion() 
46221:                        < gfxWindowsPlatform::kWindowsVista);
46221: 
46221:     // bug 561304 - Uniscribe bug produces bad positioning at certain
46221:     // font sizes on XP, so default to GDI on XP using logic of 3.6
46221: 
46221:     useGDI = isXP &&
46221:              (flags &
46221:                (gfxTextRunFactory::TEXT_OPTIMIZE_SPEED | 
46221:                 gfxTextRunFactory::TEXT_IS_RTL)
46221:              ) == gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
46221: 
46221:     return !useGDI ||
46221:         ScriptIsComplex(aString + aRunStart, aRunLength, SIC_COMPLEX) == S_OK;
46221: }
46221: 
43527: PRBool
39447: gfxGDIFont::InitTextRun(gfxContext *aContext,
39447:                         gfxTextRun *aTextRun,
39447:                         const PRUnichar *aString,
39447:                         PRUint32 aRunStart,
43525:                         PRUint32 aRunLength,
43525:                         PRInt32 aRunScript)
39447: {
41898:     if (!mMetrics) {
41898:         Initialize();
41898:     }
41898:     if (!mIsValid) {
41898:         NS_WARNING("invalid font! expect incorrect text rendering");
43527:         return PR_FALSE;
41898:     }
46221: 
46221:     PRBool ok = PR_FALSE;
46221: 
46221:     if (mHarfBuzzShaper) {
46221:         if (gfxPlatform::GetPlatform()->UseHarfBuzzLevel() >=
46221:             gfxUnicodeProperties::ScriptShapingLevel(aRunScript)) {
46221:             ok = mHarfBuzzShaper->InitTextRun(aContext, aTextRun, aString,
46221:                                               aRunStart, aRunLength, 
46221:                                               aRunScript);
46221:         }
46221:     }
46221: 
46221:     if (!ok) {
43440:         GDIFontEntry *fe = static_cast<GDIFontEntry*>(GetFontEntry());
46221: 
46221:         if (UseUniscribe(aTextRun, aString, aRunStart, aRunLength)
46221:             && !fe->mForceGDI)
46221:         {
46221:             // first try Uniscribe
46221:             if (!mUniscribeShaper) {
46221:                 mUniscribeShaper = new gfxUniscribeShaper(this);
46221:             }
46221: 
46221:             ok = mUniscribeShaper->InitTextRun(aContext, aTextRun, aString,
46221:                                                aRunStart, aRunLength, 
46221:                                                aRunScript);
46221:             if (ok) {
46221:                 return PR_TRUE;
46221:             }
46221: 
46221:             // fallback to GDI shaping
46221:             if (!mPlatformShaper) {
46221:                 CreatePlatformShaper();
46221:             }
46221: 
43527:             ok = mPlatformShaper->InitTextRun(aContext, aTextRun, aString,
43527:                                               aRunStart, aRunLength, 
43527:                                               aRunScript);
46221: 
46221:         } else {
46221:             // first use GDI
46221:             if (!mPlatformShaper) {
46221:                 CreatePlatformShaper();
43459:             }
46221: 
46221:             ok = mPlatformShaper->InitTextRun(aContext, aTextRun, aString,
46221:                                               aRunStart, aRunLength, 
46221:                                               aRunScript);
46221: 
46221:             if (ok) {
46221:                 return PR_TRUE;
46221:             }
46221: 
46221:             // first try Uniscribe
46221:             if (!mUniscribeShaper) {
46221:                 mUniscribeShaper = new gfxUniscribeShaper(this);
46221:             }
46221: 
46221:             // use Uniscribe shaping
46221:             ok = mUniscribeShaper->InitTextRun(aContext, aTextRun, aString,
46221:                                                aRunStart, aRunLength, 
46221:                                                aRunScript);
46221:         }
46221: 
46221: #if DEBUG
46221:         if (!ok) {
46221:             NS_ConvertUTF16toUTF8 name(GetName());
46221:             char msg[256];
46221: 
46221:             sprintf(msg, 
46221:                     "text shaping with both uniscribe and GDI failed for"
46221:                     " font: %s",
46221:                     name.get());
46221:             NS_WARNING(msg);
46221:         }
46221: #endif
43459:     }
43527: 
43527:     return ok;
39447: }
39447: 
39447: const gfxFont::Metrics&
39447: gfxGDIFont::GetMetrics()
39447: {
41898:     if (!mMetrics) {
41898:         Initialize();
41898:     }
41898:     return *mMetrics;
39447: }
39447: 
39447: PRUint32
39447: gfxGDIFont::GetSpaceGlyph()
39447: {
41898:     if (!mMetrics) {
41898:         Initialize();
41898:     }
39447:     return mSpaceGlyph;
39447: }
39447: 
39447: PRBool
39447: gfxGDIFont::SetupCairoFont(gfxContext *aContext)
39447: {
41898:     if (!mMetrics) {
41898:         Initialize();
41898:     }
39447:     if (cairo_scaled_font_status(mScaledFont) != CAIRO_STATUS_SUCCESS) {
39447:         // Don't cairo_set_scaled_font as that would propagate the error to
39447:         // the cairo_t, precluding any further drawing.
39447:         return PR_FALSE;
39447:     }
39447:     cairo_set_scaled_font(aContext->GetCairo(), mScaledFont);
43527:     cairo_win32_scaled_font_select_font(mScaledFont, DCFromContext(aContext));
39447:     return PR_TRUE;
39447: }
39447: 
39447: void
41898: gfxGDIFont::Initialize()
39447: {
41898:     NS_ASSERTION(!mMetrics, "re-creating metrics? this will leak");
41898: 
41898:     LOGFONTW logFont;
41898: 
39447:     if (mAdjustedSize == 0.0) {
39447:         mAdjustedSize = mStyle.size;
39447:         if (mStyle.sizeAdjust != 0.0 && mAdjustedSize > 0.0) {
39447:             // to implement font-size-adjust, we first create the "unadjusted" font
41898:             FillLogFont(logFont, mAdjustedSize);
41898:             mFont = ::CreateFontIndirectW(&logFont);
39447: 
41898:             // initialize its metrics so we can calculate size adjustment
41898:             Initialize();
41898: 
41898:             // calculate the properly adjusted size, and then proceed
41898:             // to recreate mFont and recalculate metrics
41898:             gfxFloat aspect = mMetrics->xHeight / mMetrics->emHeight;
41898:             mAdjustedSize = mStyle.GetAdjustedSize(aspect);
41898: 
41898:             // delete the temporary font and metrics
39447:             ::DeleteObject(mFont);
39447:             mFont = nsnull;
41898:             delete mMetrics;
41898:             mMetrics = nsnull;
39447:         }
39447:     }
39447: 
41898:     FillLogFont(logFont, mAdjustedSize);
41898:     mFont = ::CreateFontIndirectW(&logFont);
41898: 
41898:     mMetrics = new gfxFont::Metrics;
41898:     ::memset(mMetrics, 0, sizeof(*mMetrics));
39447: 
39447:     AutoDC dc;
39447:     SetGraphicsMode(dc.GetDC(), GM_ADVANCED);
39447:     AutoSelectFont selectFont(dc.GetDC(), mFont);
39447: 
39447:     // Get font metrics
39447:     OUTLINETEXTMETRIC oMetrics;
39447:     TEXTMETRIC& metrics = oMetrics.otmTextMetrics;
39447: 
39447:     if (0 < GetOutlineTextMetrics(dc.GetDC(), sizeof(oMetrics), &oMetrics)) {
41898:         mMetrics->superscriptOffset = (double)oMetrics.otmptSuperscriptOffset.y;
39447:         // Some fonts have wrong sign on their subscript offset, bug 410917.
41898:         mMetrics->subscriptOffset = fabs((double)oMetrics.otmptSubscriptOffset.y);
41898:         mMetrics->strikeoutSize = (double)oMetrics.otmsStrikeoutSize;
41898:         mMetrics->strikeoutOffset = (double)oMetrics.otmsStrikeoutPosition;
41898:         mMetrics->underlineSize = (double)oMetrics.otmsUnderscoreSize;
41898:         mMetrics->underlineOffset = (double)oMetrics.otmsUnderscorePosition;
39447: 
39447:         const MAT2 kIdentityMatrix = { {0, 1}, {0, 0}, {0, 0}, {0, 1} };
39447:         GLYPHMETRICS gm;
39447:         DWORD len = GetGlyphOutlineW(dc.GetDC(), PRUnichar('x'), GGO_METRICS, &gm, 0, nsnull, &kIdentityMatrix);
39447:         if (len == GDI_ERROR || gm.gmptGlyphOrigin.y <= 0) {
39447:             // 56% of ascent, best guess for true type
47309:             mMetrics->xHeight =
47309:                 ROUND((double)metrics.tmAscent * DEFAULT_XHEIGHT_FACTOR);
39447:         } else {
41898:             mMetrics->xHeight = gm.gmptGlyphOrigin.y;
39447:         }
41898:         mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
39447:         gfxFloat typEmHeight = (double)oMetrics.otmAscent - (double)oMetrics.otmDescent;
41898:         mMetrics->emAscent = ROUND(mMetrics->emHeight * (double)oMetrics.otmAscent / typEmHeight);
41898:         mMetrics->emDescent = mMetrics->emHeight - mMetrics->emAscent;
43527:         if (oMetrics.otmEMSquare > 0) {
43527:             mFUnitsConvFactor = GetAdjustedSize() / oMetrics.otmEMSquare;
43527:         }
39447:     } else {
39447:         // Make a best-effort guess at extended metrics
39447:         // this is based on general typographic guidelines
39447:         
39447:         // GetTextMetrics can fail if the font file has been removed
39447:         // or corrupted recently.
39447:         BOOL result = GetTextMetrics(dc.GetDC(), &metrics);
39447:         if (!result) {
39447:             NS_WARNING("Missing or corrupt font data, fasten your seatbelt");
39447:             mIsValid = PR_FALSE;
41898:             memset(mMetrics, 0, sizeof(*mMetrics));
39447:             return;
39447:         }
39447: 
47309:         mMetrics->xHeight =
47309:             ROUND((float)metrics.tmAscent * DEFAULT_XHEIGHT_FACTOR);
41898:         mMetrics->superscriptOffset = mMetrics->xHeight;
41898:         mMetrics->subscriptOffset = mMetrics->xHeight;
41898:         mMetrics->strikeoutSize = 1;
41898:         mMetrics->strikeoutOffset = ROUND(mMetrics->xHeight * 0.5f); // 50% of xHeight
41898:         mMetrics->underlineSize = 1;
41898:         mMetrics->underlineOffset = -ROUND((float)metrics.tmDescent * 0.30f); // 30% of descent
41898:         mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
41898:         mMetrics->emAscent = metrics.tmAscent - metrics.tmInternalLeading;
41898:         mMetrics->emDescent = metrics.tmDescent;
39447:     }
39447: 
41898:     mMetrics->internalLeading = metrics.tmInternalLeading;
41898:     mMetrics->externalLeading = metrics.tmExternalLeading;
41898:     mMetrics->maxHeight = metrics.tmHeight;
41898:     mMetrics->maxAscent = metrics.tmAscent;
41898:     mMetrics->maxDescent = metrics.tmDescent;
41898:     mMetrics->maxAdvance = metrics.tmMaxCharWidth;
41898:     mMetrics->aveCharWidth = PR_MAX(1, metrics.tmAveCharWidth);
39447:     // The font is monospace when TMPF_FIXED_PITCH is *not* set!
39447:     // See http://msdn2.microsoft.com/en-us/library/ms534202(VS.85).aspx
39447:     if (!(metrics.tmPitchAndFamily & TMPF_FIXED_PITCH)) {
41898:         mMetrics->maxAdvance = mMetrics->aveCharWidth;
39447:     }
39447: 
39447:     // Cache the width of a single space.
39447:     SIZE size;
39447:     GetTextExtentPoint32W(dc.GetDC(), L" ", 1, &size);
41898:     mMetrics->spaceWidth = ROUND(size.cx);
39447: 
39447:     // Cache the width of digit zero.
39447:     // XXX MSDN (http://msdn.microsoft.com/en-us/library/ms534223.aspx)
39447:     // does not say what the failure modes for GetTextExtentPoint32 are -
39447:     // is it safe to assume it will fail iff the font has no '0'?
41898:     if (GetTextExtentPoint32W(dc.GetDC(), L"0", 1, &size)) {
41898:         mMetrics->zeroOrAveCharWidth = ROUND(size.cx);
41898:     } else {
41898:         mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
41898:     }
39447: 
39447:     mSpaceGlyph = 0;
39447:     if (metrics.tmPitchAndFamily & TMPF_TRUETYPE) {
39447:         WORD glyph;
39447:         DWORD ret = GetGlyphIndicesW(dc.GetDC(), L" ", 1, &glyph,
39447:                                      GGI_MARK_NONEXISTING_GLYPHS);
39447:         if (ret != GDI_ERROR && glyph != 0xFFFF) {
39447:             mSpaceGlyph = glyph;
39447:         }
39447:     }
39447: 
41898:     SanitizeMetrics(mMetrics, GetFontEntry()->mIsBadUnderlineFont);
41898: 
41898:     mFontFace = cairo_win32_font_face_create_for_logfontw_hfont(&logFont,
41898:                                                                 mFont);
41898: 
41898:     cairo_matrix_t sizeMatrix, ctm;
41898:     cairo_matrix_init_identity(&ctm);
41898:     cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
41898: 
41898:     cairo_font_options_t *fontOptions = cairo_font_options_create();
41898:     if (mAntialiasOption != kAntialiasDefault) {
41898:         cairo_font_options_set_antialias(fontOptions,
41898:             GetCairoAntialiasOption(mAntialiasOption));
41898:     }
41898:     mScaledFont = cairo_scaled_font_create(mFontFace, &sizeMatrix,
41898:                                            &ctm, fontOptions);
41898:     cairo_font_options_destroy(fontOptions);
41898: 
41898:     cairo_status_t cairoerr = cairo_scaled_font_status(mScaledFont);
41898:     if (cairoerr != CAIRO_STATUS_SUCCESS) {
41898: #ifdef DEBUG
41898:         char warnBuf[1024];
41898:         sprintf(warnBuf, "Failed to create scaled font: %s status: %d",
41898:                 NS_ConvertUTF16toUTF8(mFontEntry->Name()).get(), cairoerr);
41898:         NS_WARNING(warnBuf);
41898: #endif
41898:     }
41898: 
39447:     mIsValid = PR_TRUE;
40042: 
40042: #if 0
40042:     printf("Font: %p (%s) size: %f\n", this,
40042:            NS_ConvertUTF16toUTF8(GetName()).get(), mStyle.size);
40042:     printf("    emHeight: %f emAscent: %f emDescent: %f\n", mMetrics.emHeight, mMetrics.emAscent, mMetrics.emDescent);
40042:     printf("    maxAscent: %f maxDescent: %f maxAdvance: %f\n", mMetrics.maxAscent, mMetrics.maxDescent, mMetrics.maxAdvance);
40042:     printf("    internalLeading: %f externalLeading: %f\n", mMetrics.internalLeading, mMetrics.externalLeading);
40042:     printf("    spaceWidth: %f aveCharWidth: %f xHeight: %f\n", mMetrics.spaceWidth, mMetrics.aveCharWidth, mMetrics.xHeight);
40042:     printf("    uOff: %f uSize: %f stOff: %f stSize: %f supOff: %f subOff: %f\n",
40042:            mMetrics.underlineOffset, mMetrics.underlineSize, mMetrics.strikeoutOffset, mMetrics.strikeoutSize,
40042:            mMetrics.superscriptOffset, mMetrics.subscriptOffset);
40042: #endif
39447: }
39447: 
39447: void
41898: gfxGDIFont::FillLogFont(LOGFONTW& aLogFont, gfxFloat aSize)
39447: {
39447:     GDIFontEntry *fe = static_cast<GDIFontEntry*>(GetFontEntry());
39447: 
39447:     PRUint16 weight = mNeedsBold ? 700 : fe->Weight();
39447:     PRBool italic = (mStyle.style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE));
39447: 
39447:     // if user font, disable italics/bold if defined to be italics/bold face
39447:     // this avoids unwanted synthetic italics/bold
39447:     if (fe->mIsUserFont) {
39447:         if (fe->IsItalic())
39447:             italic = PR_FALSE; // avoid synthetic italic
39447:         if (fe->IsBold()) {
39447:             weight = 400; // avoid synthetic bold
39447:         }
39447:     }
39447: 
42854:     fe->FillLogFont(&aLogFont, italic, weight, aSize, 
42854:                     (mAntialiasOption == kAntialiasSubpixel) ? PR_TRUE : PR_FALSE);
39447: }
39447: 
43527: PRInt32
43527: gfxGDIFont::GetHintedGlyphWidth(gfxContext *aCtx, PRUint16 aGID)
43527: {
43527:     if (!mGlyphWidths.IsInitialized()) {
43527:         mGlyphWidths.Init(200);
43527:     }
43527: 
43527:     PRInt32 width;
43527:     if (mGlyphWidths.Get(aGID, &width)) {
43527:         return width;
43527:     }
43527: 
43527:     int devWidth;
43527:     if (GetCharWidthI(DCFromContext(aCtx), aGID, 1, NULL, &devWidth)) {
43527:         // ensure width is positive, 16.16 fixed-point value
43527:         width = (devWidth & 0x7fff) << 16;
43527:         mGlyphWidths.Put(aGID, width);
43527:         return width;
43527:     }
43527: 
43527:     return -1;
43527: }
