    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef jslock_h__
    1: #define jslock_h__
    1: 
15974: #include "jstypes.h"
15974: #include "jsprvtd.h"    /* for JSScope, etc. */
15974: #include "jspubtd.h"    /* for JSRuntime, etc. */
15974: 
    1: #ifdef JS_THREADSAFE
    1: # include "pratom.h"
    1: # include "prlock.h"
    1: # include "prcvar.h"
    1: # include "prthread.h"
15974: #endif
    1: 
 4486: JS_BEGIN_EXTERN_C
 4486: 
15974: #ifdef JS_THREADSAFE
15974: 
15974: #if (defined(_WIN32) && defined(_M_IX86)) ||                                  \
30777:     (defined(_WIN64) && (defined(_M_AMD64) || defined(_M_X64))) ||            \
30633:     (defined(__i386) && (defined(__GNUC__) || defined(__SUNPRO_CC))) ||       \
30633:     (defined(__x86_64) && (defined(__GNUC__) || defined(__SUNPRO_CC))) ||     \
30633:     (defined(__sparc) && (defined(__GNUC__) || defined(__SUNPRO_CC))) ||      \
15974:     defined(AIX) ||                                                           \
16059:     defined(USE_ARM_KUSER)
15974: # define JS_HAS_NATIVE_COMPARE_AND_SWAP 1
15974: #else
15974: # define JS_HAS_NATIVE_COMPARE_AND_SWAP 0
15974: #endif
15974: 
15994: #if defined(JS_USE_ONLY_NSPR_LOCKS) || !JS_HAS_NATIVE_COMPARE_AND_SWAP
15994: # define NSPR_LOCK 1
15994: #else
15994: # undef NSPR_LOCK
15994: #endif
15994: 
    1: #define Thin_GetWait(W) ((jsword)(W) & 0x1)
    1: #define Thin_SetWait(W) ((jsword)(W) | 0x1)
    1: #define Thin_RemoveWait(W) ((jsword)(W) & ~0x1)
    1: 
    1: typedef struct JSFatLock JSFatLock;
    1: 
    1: typedef struct JSThinLock {
    1:     jsword      owner;
    1:     JSFatLock   *fat;
    1: } JSThinLock;
    1: 
    1: #define CX_THINLOCK_ID(cx)       ((jsword)(cx)->thread)
    1: #define CURRENT_THREAD_IS_ME(me) (((JSThread *)me)->id == js_CurrentThreadId())
    1: 
    1: typedef PRLock JSLock;
    1: 
11739: typedef struct JSTitle JSTitle;
11739: 
11739: struct JSTitle {
11739:     JSContext       *ownercx;           /* creating context, NULL if shared */
11739:     JSThinLock      lock;               /* binary semaphore protecting title */
11739:     union {                             /* union lockful and lock-free state: */
11739:         jsrefcount  count;              /* lock entry count for reentrancy */
11739:         JSTitle     *link;              /* next link in rt->titleSharingTodo */
11739:     } u;
11995: #ifdef JS_DEBUG_TITLE_LOCKS
11739:     const char      *file[4];           /* file where lock was (re-)taken */
11739:     unsigned int    line[4];            /* line where lock was (re-)taken */
11739: #endif
11739: };
11739: 
11739: /*
28353:  * Title structure is always allocated as a field of JSScope.
11739:  */
28353: #define TITLE_TO_SCOPE(title)                                                 \
28353:     ((JSScope *)((uint8 *) (title) - offsetof(JSScope, title)))
11739: 
    1: /*
    1:  * Atomic increment and decrement for a reference counter, given jsrefcount *p.
    1:  * NB: jsrefcount is int32, aka PRInt32, so that pratom.h functions work.
    1:  */
    1: #define JS_ATOMIC_INCREMENT(p)      PR_AtomicIncrement((PRInt32 *)(p))
    1: #define JS_ATOMIC_DECREMENT(p)      PR_AtomicDecrement((PRInt32 *)(p))
    1: #define JS_ATOMIC_ADD(p,v)          PR_AtomicAdd((PRInt32 *)(p), (PRInt32)(v))
25087: #define JS_ATOMIC_SET(p,v)          PR_AtomicSet((PRInt32 *)(p), (PRInt32)(v))
    1: 
    1: #define js_CurrentThreadId()        (jsword)PR_GetCurrentThread()
    1: #define JS_NEW_LOCK()               PR_NewLock()
    1: #define JS_DESTROY_LOCK(l)          PR_DestroyLock(l)
    1: #define JS_ACQUIRE_LOCK(l)          PR_Lock(l)
    1: #define JS_RELEASE_LOCK(l)          PR_Unlock(l)
    1: 
    1: #define JS_NEW_CONDVAR(l)           PR_NewCondVar(l)
    1: #define JS_DESTROY_CONDVAR(cv)      PR_DestroyCondVar(cv)
    1: #define JS_WAIT_CONDVAR(cv,to)      PR_WaitCondVar(cv,to)
    1: #define JS_NO_TIMEOUT               PR_INTERVAL_NO_TIMEOUT
    1: #define JS_NOTIFY_CONDVAR(cv)       PR_NotifyCondVar(cv)
    1: #define JS_NOTIFY_ALL_CONDVAR(cv)   PR_NotifyAllCondVar(cv)
    1: 
11739: #ifdef JS_DEBUG_TITLE_LOCKS
11377: 
26373: #define JS_SET_OBJ_INFO(obj_, file_, line_)                                   \
26373:     JS_SET_SCOPE_INFO(OBJ_SCOPE(obj_), file_, line_)
11377: 
26373: #define JS_SET_SCOPE_INFO(scope_, file_, line_)                               \
11995:     js_SetScopeInfo(scope_, file_, line_)
11377: 
11377: #endif
11377: 
15994: #define JS_LOCK(cx, tl)             js_Lock(cx, tl)
15994: #define JS_UNLOCK(cx, tl)           js_Unlock(cx, tl)
15994: 
    1: #define JS_LOCK_RUNTIME(rt)         js_LockRuntime(rt)
    1: #define JS_UNLOCK_RUNTIME(rt)       js_UnlockRuntime(rt)
    1: 
    1: /*
    1:  * NB: The JS_LOCK_OBJ and JS_UNLOCK_OBJ macros work *only* on native objects
    1:  * (objects for which OBJ_IS_NATIVE returns true).  All uses of these macros in
    1:  * the engine are predicated on OBJ_IS_NATIVE or equivalent checks.  These uses
    1:  * are for optimizations above the JSObjectOps layer, under which object locks
    1:  * normally hide.
    1:  */
11739: #define JS_LOCK_OBJ(cx,obj)       ((OBJ_SCOPE(obj)->title.ownercx == (cx))    \
    1:                                    ? (void)0                                  \
11377:                                    : (js_LockObj(cx, obj),                    \
26373:                                       JS_SET_OBJ_INFO(obj,__FILE__,__LINE__)))
11739: #define JS_UNLOCK_OBJ(cx,obj)     ((OBJ_SCOPE(obj)->title.ownercx == (cx))    \
    1:                                    ? (void)0 : js_UnlockObj(cx, obj))
    1: 
29378: /*
29378:  * Lock object only if its scope has the given shape.
29378:  */
29378: #define JS_LOCK_OBJ_IF_SHAPE(cx,obj,shape)                                    \
29378:     (OBJ_SHAPE(obj) == (shape)                                                \
29378:      ? (OBJ_SCOPE(obj)->title.ownercx == (cx)                                 \
29378:         ? true                                                                \
29378:         : js_LockObjIfShape(cx, obj, shape))                                  \
29378:      : false)
29378: 
11739: #define JS_LOCK_TITLE(cx,title)                                               \
11739:     ((title)->ownercx == (cx) ? (void)0                                       \
11739:      : (js_LockTitle(cx, (title)),                                            \
26373:         JS_SET_TITLE_INFO(title,__FILE__,__LINE__)))
11739: 
11739: #define JS_UNLOCK_TITLE(cx,title) ((title)->ownercx == (cx) ? (void)0         \
11739:                                    : js_UnlockTitle(cx, title))
11739: 
11739: #define JS_LOCK_SCOPE(cx,scope)   JS_LOCK_TITLE(cx,&(scope)->title)
11739: #define JS_UNLOCK_SCOPE(cx,scope) JS_UNLOCK_TITLE(cx,&(scope)->title)
11739: 
    1: #define JS_TRANSFER_SCOPE_LOCK(cx, scope, newscope)                           \
11739:     js_TransferTitle(cx, &scope->title, &newscope->title)
    1: 
15994: 
15994: extern void js_Lock(JSContext *cx, JSThinLock *tl);
15994: extern void js_Unlock(JSContext *cx, JSThinLock *tl);
    1: extern void js_LockRuntime(JSRuntime *rt);
    1: extern void js_UnlockRuntime(JSRuntime *rt);
    1: extern void js_LockObj(JSContext *cx, JSObject *obj);
    1: extern void js_UnlockObj(JSContext *cx, JSObject *obj);
29378: extern bool js_LockObjIfShape(JSContext *cx, JSObject *obj, uint32 shape);
11739: extern void js_InitTitle(JSContext *cx, JSTitle *title);
11739: extern void js_FinishTitle(JSContext *cx, JSTitle *title);
11739: extern void js_LockTitle(JSContext *cx, JSTitle *title);
11739: extern void js_UnlockTitle(JSContext *cx, JSTitle *title);
    1: extern int js_SetupLocks(int,int);
    1: extern void js_CleanupLocks();
11739: extern void js_TransferTitle(JSContext *, JSTitle *, JSTitle *);
    1: extern JS_FRIEND_API(jsval)
    1: js_GetSlotThreadSafe(JSContext *, JSObject *, uint32);
    1: extern void js_SetSlotThreadSafe(JSContext *, JSObject *, uint32, jsval);
    1: extern void js_InitLock(JSThinLock *);
    1: extern void js_FinishLock(JSThinLock *);
    1: 
27384: /*
27384:  * This function must be called with the GC lock held.
27384:  */
27384: extern void
27384: js_ShareWaitingTitles(JSContext *cx);
27384: 
27384: extern void
27384: js_NudgeOtherContexts(JSContext *cx);
25087: 
    1: #ifdef DEBUG
    1: 
    1: #define JS_IS_RUNTIME_LOCKED(rt)        js_IsRuntimeLocked(rt)
    1: #define JS_IS_OBJ_LOCKED(cx,obj)        js_IsObjLocked(cx,obj)
11739: #define JS_IS_TITLE_LOCKED(cx,title)    js_IsTitleLocked(cx,title)
    1: 
    1: extern JSBool js_IsRuntimeLocked(JSRuntime *rt);
    1: extern JSBool js_IsObjLocked(JSContext *cx, JSObject *obj);
11739: extern JSBool js_IsTitleLocked(JSContext *cx, JSTitle *title);
11995: #ifdef JS_DEBUG_TITLE_LOCKS
11995: extern void js_SetScopeInfo(JSScope *scope, const char *file, int line);
11995: #endif
    1: 
    1: #else
    1: 
    1: #define JS_IS_RUNTIME_LOCKED(rt)        0
    1: #define JS_IS_OBJ_LOCKED(cx,obj)        1
11739: #define JS_IS_TITLE_LOCKED(cx,title)    1
    1: 
    1: #endif /* DEBUG */
    1: 
    1: #else  /* !JS_THREADSAFE */
    1: 
    1: #define JS_ATOMIC_INCREMENT(p)      (++*(p))
    1: #define JS_ATOMIC_DECREMENT(p)      (--*(p))
    1: #define JS_ATOMIC_ADD(p,v)          (*(p) += (v))
25087: #define JS_ATOMIC_SET(p,v)          (*(p) = (v))
    1: 
    1: #define JS_CurrentThreadId() 0
    1: #define JS_NEW_LOCK()               NULL
    1: #define JS_DESTROY_LOCK(l)          ((void)0)
    1: #define JS_ACQUIRE_LOCK(l)          ((void)0)
    1: #define JS_RELEASE_LOCK(l)          ((void)0)
15994: #define JS_LOCK(cx, tl)             ((void)0)
15994: #define JS_UNLOCK(cx, tl)           ((void)0)
    1: 
    1: #define JS_NEW_CONDVAR(l)           NULL
    1: #define JS_DESTROY_CONDVAR(cv)      ((void)0)
    1: #define JS_WAIT_CONDVAR(cv,to)      ((void)0)
    1: #define JS_NOTIFY_CONDVAR(cv)       ((void)0)
    1: #define JS_NOTIFY_ALL_CONDVAR(cv)   ((void)0)
    1: 
    1: #define JS_LOCK_RUNTIME(rt)         ((void)0)
    1: #define JS_UNLOCK_RUNTIME(rt)       ((void)0)
    1: #define JS_LOCK_OBJ(cx,obj)         ((void)0)
    1: #define JS_UNLOCK_OBJ(cx,obj)       ((void)0)
29378: #define JS_LOCK_OBJ_IF_SHAPE(cx,obj,shape) (OBJ_SHAPE(obj) == (shape))
29378: 
    1: #define JS_LOCK_OBJ_VOID(cx,obj,e)  (e)
    1: #define JS_LOCK_SCOPE(cx,scope)     ((void)0)
    1: #define JS_UNLOCK_SCOPE(cx,scope)   ((void)0)
    1: #define JS_TRANSFER_SCOPE_LOCK(c,o,n) ((void)0)
    1: 
    1: #define JS_IS_RUNTIME_LOCKED(rt)        1
    1: #define JS_IS_OBJ_LOCKED(cx,obj)        1
11739: #define JS_IS_TITLE_LOCKED(cx,title)    1
    1: 
    1: #endif /* !JS_THREADSAFE */
    1: 
    1: #define JS_LOCK_RUNTIME_VOID(rt,e)                                            \
    1:     JS_BEGIN_MACRO                                                            \
    1:         JS_LOCK_RUNTIME(rt);                                                  \
    1:         e;                                                                    \
    1:         JS_UNLOCK_RUNTIME(rt);                                                \
    1:     JS_END_MACRO
    1: 
    1: #define JS_LOCK_GC(rt)              JS_ACQUIRE_LOCK((rt)->gcLock)
    1: #define JS_UNLOCK_GC(rt)            JS_RELEASE_LOCK((rt)->gcLock)
    1: #define JS_AWAIT_GC_DONE(rt)        JS_WAIT_CONDVAR((rt)->gcDone, JS_NO_TIMEOUT)
    1: #define JS_NOTIFY_GC_DONE(rt)       JS_NOTIFY_ALL_CONDVAR((rt)->gcDone)
    1: #define JS_AWAIT_REQUEST_DONE(rt)   JS_WAIT_CONDVAR((rt)->requestDone,        \
    1:                                                     JS_NO_TIMEOUT)
    1: #define JS_NOTIFY_REQUEST_DONE(rt)  JS_NOTIFY_CONDVAR((rt)->requestDone)
    1: 
26373: #ifndef JS_SET_OBJ_INFO
26373: #define JS_SET_OBJ_INFO(obj,f,l)        ((void)0)
11377: #endif
26373: #ifndef JS_SET_TITLE_INFO
26373: #define JS_SET_TITLE_INFO(title,f,l)    ((void)0)
11377: #endif
11377: 
17049: #ifdef JS_THREADSAFE
17049: 
17049: extern JSBool
17049: js_CompareAndSwap(jsword *w, jsword ov, jsword nv);
17049: 
27478: /* Atomically bitwise-or the mask into the word *w using compare and swap. */
27478: extern void
27478: js_AtomicSetMask(jsword *w, jsword mask);
27478: 
27478: #define JS_ATOMIC_SET_MASK(w, mask) js_AtomicSetMask(w, mask)
27478: 
17049: #else
17049: 
17049: static inline JSBool
17049: js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
17049: {
17049:     return (*w == ov) ? *w = nv, JS_TRUE : JS_FALSE;
17049: }
17049: 
27481: #define JS_ATOMIC_SET_MASK(w, mask) (*(w) |= (mask))
17049: 
27478: #endif /* JS_THREADSAFE */
27471: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jslock_h___ */
