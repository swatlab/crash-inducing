    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsTextFragment.h"
    1: #include "nsWSRunObject.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsHTMLEditor.h"
    1: #include "nsTextEditUtils.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsCRT.h"
    1: #include "nsIRangeUtils.h"
    1: 
    1: const PRUnichar nbsp = 160;
    1: 
    1: static PRBool IsBlockNode(nsIDOMNode* node)
    1: {
    1:   PRBool isBlock (PR_FALSE);
    1:   nsHTMLEditor::NodeIsBlockStatic(node, &isBlock);
    1:   return isBlock;
    1: }
    1: 
    1: //- constructor / destructor -----------------------------------------------
    1: nsWSRunObject::nsWSRunObject(nsHTMLEditor *aEd, nsIDOMNode *aNode, PRInt32 aOffset) :
    1: mNode(aNode)
    1: ,mOffset(aOffset)
    1: ,mPRE(PR_FALSE)
    1: ,mStartNode()
    1: ,mStartOffset(0)
    1: ,mStartReason(0)
    1: ,mStartReasonNode()
    1: ,mEndNode()
    1: ,mEndOffset(0)
    1: ,mEndReason(0)
    1: ,mEndReasonNode()
    1: ,mFirstNBSPNode()
    1: ,mFirstNBSPOffset(0)
    1: ,mLastNBSPNode()
    1: ,mLastNBSPOffset(0)
    1: ,mNodeArray()
    1: ,mStartRun(nsnull)
    1: ,mEndRun(nsnull)
    1: ,mHTMLEditor(aEd)
    1: {
    1:   GetWSNodes();
    1:   GetRuns();
    1: }
    1: 
    1: nsWSRunObject::~nsWSRunObject()
    1: {
    1:   ClearRuns();
    1: }
    1: 
    1: 
    1: 
    1: //--------------------------------------------------------------------------------------------
    1: //   public static methods
    1: //--------------------------------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsWSRunObject::ScrubBlockBoundary(nsHTMLEditor *aHTMLEd, 
    1:                                   nsCOMPtr<nsIDOMNode> *aBlock,
    1:                                   BlockBoundary aBoundary,
    1:                                   PRInt32 *aOffset)
    1: {
    1:   if (!aBlock || !aHTMLEd)
    1:     return NS_ERROR_NULL_POINTER;
    1:   if ((aBoundary == kBlockStart) || (aBoundary == kBlockEnd))
    1:     return ScrubBlockBoundaryInner(aHTMLEd, aBlock, aBoundary);
    1:   
    1:   // else we are scrubbing an outer boundary - just before or after
    1:   // a block element.
    1:   if (!aOffset) 
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsAutoTrackDOMPoint tracker(aHTMLEd->mRangeUpdater, aBlock, aOffset);
    1:   nsWSRunObject theWSObj(aHTMLEd, *aBlock, *aOffset);
    1:   return theWSObj.Scrub();
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::PrepareToJoinBlocks(nsHTMLEditor *aHTMLEd, 
    1:                                    nsIDOMNode *aLeftParent, 
    1:                                    nsIDOMNode *aRightParent)
    1: {
    1:   if (!aLeftParent || !aRightParent || !aHTMLEd)
    1:     return NS_ERROR_NULL_POINTER;
    1:   PRUint32 count;
    1:   aHTMLEd->GetLengthOfDOMNode(aLeftParent, count);
    1:   nsWSRunObject leftWSObj(aHTMLEd, aLeftParent, count);
    1:   nsWSRunObject rightWSObj(aHTMLEd, aRightParent, 0);
    1: 
    1:   return leftWSObj.PrepareToDeleteRangePriv(&rightWSObj);
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::PrepareToDeleteRange(nsHTMLEditor *aHTMLEd, 
    1:                                     nsCOMPtr<nsIDOMNode> *aStartNode,
    1:                                     PRInt32 *aStartOffset, 
    1:                                     nsCOMPtr<nsIDOMNode> *aEndNode,
    1:                                     PRInt32 *aEndOffset)
    1: {
    1:   if (!aStartNode || !aEndNode || !*aStartNode || !*aEndNode || !aStartOffset || !aEndOffset || !aHTMLEd)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsAutoTrackDOMPoint trackerStart(aHTMLEd->mRangeUpdater, aStartNode, aStartOffset);
    1:   nsAutoTrackDOMPoint trackerEnd(aHTMLEd->mRangeUpdater, aEndNode, aEndOffset);
    1:   
    1:   nsWSRunObject leftWSObj(aHTMLEd, *aStartNode, *aStartOffset);
    1:   nsWSRunObject rightWSObj(aHTMLEd, *aEndNode, *aEndOffset);
    1: 
    1:   return leftWSObj.PrepareToDeleteRangePriv(&rightWSObj);
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::PrepareToDeleteNode(nsHTMLEditor *aHTMLEd, 
    1:                                    nsIDOMNode *aNode)
    1: {
    1:   if (!aNode || !aHTMLEd)
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsresult res = NS_OK;
    1:   
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
    1:   res = aHTMLEd->GetNodeLocation(aNode, address_of(parent), &offset);
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   nsWSRunObject leftWSObj(aHTMLEd, parent, offset);
    1:   nsWSRunObject rightWSObj(aHTMLEd, parent, offset+1);
    1: 
    1:   return leftWSObj.PrepareToDeleteRangePriv(&rightWSObj);
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::PrepareToSplitAcrossBlocks(nsHTMLEditor *aHTMLEd, 
    1:                                           nsCOMPtr<nsIDOMNode> *aSplitNode, 
    1:                                           PRInt32 *aSplitOffset)
    1: {
    1:   if (!aSplitNode || !aSplitOffset || !*aSplitNode || !aHTMLEd)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsAutoTrackDOMPoint tracker(aHTMLEd->mRangeUpdater, aSplitNode, aSplitOffset);
    1:   
    1:   nsWSRunObject wsObj(aHTMLEd, *aSplitNode, *aSplitOffset);
    1: 
    1:   return wsObj.PrepareToSplitAcrossBlocksPriv();
    1: }
    1: 
    1: //--------------------------------------------------------------------------------------------
    1: //   public instance methods
    1: //--------------------------------------------------------------------------------------------
    1: 
    1: nsresult 
    1: nsWSRunObject::InsertBreak(nsCOMPtr<nsIDOMNode> *aInOutParent, 
    1:                            PRInt32 *aInOutOffset, 
    1:                            nsCOMPtr<nsIDOMNode> *outBRNode, 
    1:                            nsIEditor::EDirection aSelect)
    1: {
    1:   // MOOSE: for now, we always assume non-PRE formatting.  Fix this later.
    1:   // meanwhile, the pre case is handled in WillInsertText in nsHTMLEditRules.cpp
    1:   if (!aInOutParent || !aInOutOffset || !outBRNode)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsresult res = NS_OK;
    1:   WSFragment *beforeRun, *afterRun;
    1:   res = FindRun(*aInOutParent, *aInOutOffset, &beforeRun, PR_FALSE);
    1:   res = FindRun(*aInOutParent, *aInOutOffset, &afterRun, PR_TRUE);
    1:   
    1:   {
    1:     // some scoping for nsAutoTrackDOMPoint.  This will track our insertion point
    1:     // while we tweak any surrounding whitespace
    1:     nsAutoTrackDOMPoint tracker(mHTMLEditor->mRangeUpdater, aInOutParent, aInOutOffset);
    1: 
    1:     // handle any changes needed to ws run after inserted br
    1:     if (!afterRun)
    1:     {
    1:       // don't need to do anything.  just insert break.  ws won't change.
    1:     }
    1:     else if (afterRun->mType & eTrailingWS)
    1:     {
    1:       // don't need to do anything.  just insert break.  ws won't change.
    1:     }
    1:     else if (afterRun->mType & eLeadingWS)
    1:     {
    1:       // delete the leading ws that is after insertion point.  We don't
    1:       // have to (it would still not be significant after br), but it's 
    1:       // just more aesthetically pleasing to.
    1:       res = DeleteChars(*aInOutParent, *aInOutOffset, afterRun->mEndNode, afterRun->mEndOffset,
    1:                         eOutsideUserSelectAll);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else if (afterRun->mType == eNormalWS)
    1:     {
    1:       // need to determine if break at front of non-nbsp run.  if so
    1:       // convert run to nbsp.
    1:       WSPoint thePoint;
    1:       res = GetCharAfter(*aInOutParent, *aInOutOffset, &thePoint);
    1:       if ( (NS_SUCCEEDED(res)) && thePoint.mTextNode && (nsCRT::IsAsciiSpace(thePoint.mChar)) )
    1:       {
    1:         WSPoint prevPoint;
    1:         res = GetCharBefore(thePoint, &prevPoint);
    1:         if ( (NS_FAILED(res)) || (prevPoint.mTextNode && !nsCRT::IsAsciiSpace(prevPoint.mChar)) )
    1:         {
    1:           // we are at start of non-nbsps.  convert to a single nbsp.
    1:           res = ConvertToNBSP(thePoint);
    1:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:       }
    1:     }
    1:     
    1:     // handle any changes needed to ws run before inserted br
    1:     if (!beforeRun)
    1:     {
    1:       // don't need to do anything.  just insert break.  ws won't change.
    1:     }
    1:     else if (beforeRun->mType & eLeadingWS)
    1:     {
    1:       // don't need to do anything.  just insert break.  ws won't change.
    1:     }
    1:     else if (beforeRun->mType & eTrailingWS)
    1:     {
    1:       // need to delete the trailing ws that is before insertion point, because it 
    1:       // would become significant after break inserted.
    1:       res = DeleteChars(beforeRun->mStartNode, beforeRun->mStartOffset, *aInOutParent, *aInOutOffset,
    1:                         eOutsideUserSelectAll);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else if (beforeRun->mType == eNormalWS)
    1:     {
    1:       // try to change an nbsp to a space, if possible, just to prevent nbsp proliferation
    1:       res = CheckTrailingNBSP(beforeRun, *aInOutParent, *aInOutOffset);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   
    1:   // ready, aim, fire!
    1:   return mHTMLEditor->CreateBRImpl(aInOutParent, aInOutOffset, outBRNode, aSelect);
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::InsertText(const nsAString& aStringToInsert, 
    1:                           nsCOMPtr<nsIDOMNode> *aInOutParent, 
    1:                           PRInt32 *aInOutOffset,
    1:                           nsIDOMDocument *aDoc)
    1: {
    1:   // MOOSE: for now, we always assume non-PRE formatting.  Fix this later.
    1:   // meanwhile, the pre case is handled in WillInsertText in nsHTMLEditRules.cpp
    1: 
    1:   // MOOSE: for now, just getting the ws logic straight.  This implementation
    1:   // is very slow.  Will need to replace edit rules impl with a more efficient
    1:   // text sink here that does the minimal amount of searching/replacing/copying
    1: 
    1:   if (!aInOutParent || !aInOutOffset || !aDoc)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsresult res = NS_OK;
    1:   if (aStringToInsert.IsEmpty()) return res;
    1:   
    1:   // string copying sux.  
    1:   nsAutoString theString(aStringToInsert);
    1:   
    1:   WSFragment *beforeRun, *afterRun;
    1:   res = FindRun(*aInOutParent, *aInOutOffset, &beforeRun, PR_FALSE);
    1:   res = FindRun(*aInOutParent, *aInOutOffset, &afterRun, PR_TRUE);
    1:   
    1:   {
    1:     // some scoping for nsAutoTrackDOMPoint.  This will track our insertion point
    1:     // while we tweak any surrounding whitespace
    1:     nsAutoTrackDOMPoint tracker(mHTMLEditor->mRangeUpdater, aInOutParent, aInOutOffset);
    1: 
    1:     // handle any changes needed to ws run after inserted text
    1:     if (!afterRun)
    1:     {
    1:       // don't need to do anything.  just insert text.  ws won't change.
    1:     }
    1:     else if (afterRun->mType & eTrailingWS)
    1:     {
    1:       // don't need to do anything.  just insert text.  ws won't change.
    1:     }
    1:     else if (afterRun->mType & eLeadingWS)
    1:     {
    1:       // delete the leading ws that is after insertion point, because it 
    1:       // would become significant after text inserted.
    1:       res = DeleteChars(*aInOutParent, *aInOutOffset, afterRun->mEndNode, afterRun->mEndOffset,
    1:                          eOutsideUserSelectAll);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else if (afterRun->mType == eNormalWS)
    1:     {
    1:       // try to change an nbsp to a space, if possible, just to prevent nbsp proliferation
    1:       res = CheckLeadingNBSP(afterRun, *aInOutParent, *aInOutOffset);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     
    1:     // handle any changes needed to ws run before inserted text
    1:     if (!beforeRun)
    1:     {
    1:       // don't need to do anything.  just insert text.  ws won't change.
    1:     }
    1:     else if (beforeRun->mType & eLeadingWS)
    1:     {
    1:       // don't need to do anything.  just insert text.  ws won't change.
    1:     }
    1:     else if (beforeRun->mType & eTrailingWS)
    1:     {
    1:       // need to delete the trailing ws that is before insertion point, because it 
    1:       // would become significant after text inserted.
    1:       res = DeleteChars(beforeRun->mStartNode, beforeRun->mStartOffset, *aInOutParent, *aInOutOffset,
    1:                         eOutsideUserSelectAll);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else if (beforeRun->mType == eNormalWS)
    1:     {
    1:       // try to change an nbsp to a space, if possible, just to prevent nbsp proliferation
    1:       res = CheckTrailingNBSP(beforeRun, *aInOutParent, *aInOutOffset);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   
    1:   // next up, tweak head and tail of string as needed.
    1:   // first the head:
    1:   // there are a variety of circumstances that would require us to convert a 
    1:   // leading ws char into an nbsp:
    1:   
    1:   if (nsCRT::IsAsciiSpace(theString[0]))
    1:   {
    1:     // we have a leading space
    1:     if (beforeRun)
    1:     {
    1:       if (beforeRun->mType & eLeadingWS) 
    1:       {
    1:         theString.SetCharAt(nbsp, 0);
    1:       }
    1:       else if (beforeRun->mType & eNormalWS) 
    1:       {
    1:         WSPoint wspoint;
    1:         res = GetCharBefore(*aInOutParent, *aInOutOffset, &wspoint);
    1:         if (NS_SUCCEEDED(res) && wspoint.mTextNode && nsCRT::IsAsciiSpace(wspoint.mChar))
    1:         {
    1:           theString.SetCharAt(nbsp, 0);
    1:         }
    1:       }
    1:     }
    1:     else
    1:     {
    1:       if ((mStartReason & eBlock) || (mStartReason == eBreak))
    1:       {
    1:         theString.SetCharAt(nbsp, 0);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // then the tail
    1:   PRUint32 lastCharIndex = theString.Length()-1;
    1: 
    1:   if (nsCRT::IsAsciiSpace(theString[lastCharIndex]))
    1:   {
    1:     // we have a leading space
    1:     if (afterRun)
    1:     {
    1:       if (afterRun->mType & eTrailingWS)
    1:       {
    1:         theString.SetCharAt(nbsp, lastCharIndex);
    1:       }
    1:       else if (afterRun->mType & eNormalWS) 
    1:       {
    1:         WSPoint wspoint;
    1:         res = GetCharAfter(*aInOutParent, *aInOutOffset, &wspoint);
    1:         if (NS_SUCCEEDED(res) && wspoint.mTextNode && nsCRT::IsAsciiSpace(wspoint.mChar))
    1:         {
    1:           theString.SetCharAt(nbsp, lastCharIndex);
    1:         }
    1:       }
    1:     }
    1:     else
    1:     {
    1:       if ((mEndReason & eBlock))
    1:       {
    1:         theString.SetCharAt(nbsp, lastCharIndex);
    1:       }
    1:     }
    1:   }
    1:   
    1:   // next scan string for adjacent ws and convert to nbsp/space combos
    1:   // MOOSE: don't need to convert tabs here since that is done by WillInsertText() 
    1:   // before we are called.  Eventually, all that logic will be pushed down into
    1:   // here and made more efficient.
    1:   PRUint32 j;
    1:   PRBool prevWS = PR_FALSE;
    1:   for (j=0; j<=lastCharIndex; j++)
    1:   {
    1:     if (nsCRT::IsAsciiSpace(theString[j]))
    1:     {
    1:       if (prevWS)
    1:       {
    1:         theString.SetCharAt(nbsp, j-1);  // j-1 can't be negative because prevWS starts out false
    1:       }
    1:       else
    1:       {
    1:         prevWS = PR_TRUE;
    1:       }
    1:     }
    1:     else
    1:     {
    1:       prevWS = PR_FALSE;
    1:     }
    1:   }
    1:   
    1:   // ready, aim, fire!
    1:   res = mHTMLEditor->InsertTextImpl(theString, aInOutParent, aInOutOffset, aDoc);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::DeleteWSBackward()
    1: {
    1:   nsresult res = NS_OK;
    1:   WSPoint point;
    1:   res = GetCharBefore(mNode, mOffset, &point);  
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!point.mTextNode) return NS_OK;  // nothing to delete
    1:   
    1:   if (mPRE)  // easy case, preformatted ws
    1:   {
    1:     if (nsCRT::IsAsciiSpace(point.mChar) || (point.mChar == nbsp))
    1:     {
    1:       nsCOMPtr<nsIDOMNode> node(do_QueryInterface(point.mTextNode));
    1:       PRInt32 startOffset = point.mOffset;
    1:       PRInt32 endOffset = point.mOffset+1;
    1:       return DeleteChars(node, startOffset, node, endOffset);
    1:     }
    1:   }
    1:   
    1:   // callers job to insure that previous char is really ws.
    1:   // If it is normal ws, we need to delete the whole run
    1:   if (nsCRT::IsAsciiSpace(point.mChar))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> startNode, endNode, node(do_QueryInterface(point.mTextNode));
    1:     PRInt32 startOffset, endOffset;
    1:     res = GetAsciiWSBounds(eBoth, node, point.mOffset+1, address_of(startNode), 
    1:                          &startOffset, address_of(endNode), &endOffset);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // adjust surrounding ws
    1:     res = nsWSRunObject::PrepareToDeleteRange(mHTMLEditor, address_of(startNode), &startOffset, 
    1:                                               address_of(endNode), &endOffset);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // finally, delete that ws
    1:     return DeleteChars(startNode, startOffset, endNode, endOffset);
    1:   }
    1:   else if (point.mChar == nbsp)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(point.mTextNode));
    1:     // adjust surrounding ws
    1:     PRInt32 startOffset = point.mOffset;
    1:     PRInt32 endOffset = point.mOffset+1;
    1:     res = nsWSRunObject::PrepareToDeleteRange(mHTMLEditor, address_of(node), &startOffset, 
    1:                                               address_of(node), &endOffset);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // finally, delete that ws
    1:     return DeleteChars(node, startOffset, node, endOffset);
    1:   
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::DeleteWSForward()
    1: {
    1:   nsresult res = NS_OK;
    1:   WSPoint point;
    1:   res = GetCharAfter(mNode, mOffset, &point);  
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!point.mTextNode) return NS_OK;  // nothing to delete
    1:   
    1:   if (mPRE)  // easy case, preformatted ws
    1:   {
    1:     if (nsCRT::IsAsciiSpace(point.mChar) || (point.mChar == nbsp))
    1:     {
    1:       nsCOMPtr<nsIDOMNode> node(do_QueryInterface(point.mTextNode));
    1:       PRInt32 startOffset = point.mOffset;
    1:       PRInt32 endOffset = point.mOffset+1;
    1:       return DeleteChars(node, startOffset, node, endOffset);
    1:     }
    1:   }
    1:   
    1:   // callers job to insure that next char is really ws.
    1:   // If it is normal ws, we need to delete the whole run
    1:   if (nsCRT::IsAsciiSpace(point.mChar))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> startNode, endNode, node(do_QueryInterface(point.mTextNode));
    1:     PRInt32 startOffset, endOffset;
    1:     res = GetAsciiWSBounds(eBoth, node, point.mOffset+1, address_of(startNode), 
    1:                          &startOffset, address_of(endNode), &endOffset);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // adjust surrounding ws
    1:     res = nsWSRunObject::PrepareToDeleteRange(mHTMLEditor, address_of(startNode), &startOffset, 
    1:                                               address_of(endNode), &endOffset);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // finally, delete that ws
    1:     return DeleteChars(startNode, startOffset, endNode, endOffset);
    1:   }
    1:   else if (point.mChar == nbsp)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(point.mTextNode));
    1:     // adjust surrounding ws
    1:     PRInt32 startOffset = point.mOffset;
    1:     PRInt32 endOffset = point.mOffset+1;
    1:     res = nsWSRunObject::PrepareToDeleteRange(mHTMLEditor, address_of(node), &startOffset, 
    1:                                               address_of(node), &endOffset);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // finally, delete that ws
    1:     return DeleteChars(node, startOffset, node, endOffset);
    1:   
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::PriorVisibleNode(nsIDOMNode *aNode, 
    1:                                 PRInt32 aOffset, 
    1:                                 nsCOMPtr<nsIDOMNode> *outVisNode, 
    1:                                 PRInt32 *outVisOffset,
    1:                                 PRInt16 *outType)
    1: {
    1:   // Find first visible thing before the point.  position outVisNode/outVisOffset
    1:   // just _after_ that thing.  If we don't find anything return start of ws.
    1:   if (!aNode || !outVisNode || !outVisOffset || !outType)
    1:     return NS_ERROR_NULL_POINTER;
    1:     
    1:   *outType = eNone;
    1:   WSFragment *run;
    1:   FindRun(aNode, aOffset, &run, PR_FALSE);
    1:   
    1:   // is there a visible run there or earlier?
    1:   while (run)
    1:   {
    1:     if (run->mType == eNormalWS)
    1:     {
    1:       WSPoint point;
    1:       GetCharBefore(aNode, aOffset, &point);
    1:       if (point.mTextNode)
    1:       {
    1:         *outVisNode = do_QueryInterface(point.mTextNode);
    1:         *outVisOffset = point.mOffset+1;
    1:         if (nsCRT::IsAsciiSpace(point.mChar) || (point.mChar==nbsp))
    1:         {
    1:           *outType = eNormalWS;
    1:         }
    1:         else if (!point.mChar)
    1:         {
    1:           // MOOSE: not possible?
    1:           *outType = eNone;
    1:         }
    1:         else
    1:         {
    1:           *outType = eText;
    1:         }
    1:         return NS_OK;
    1:       }
    1:       // else if no text node then keep looking.  We should eventually fall out of loop
    1:     }
    1: 
    1:     run = run->mLeft;
    1:   }
    1:   
    1:   // if we get here then nothing in ws data to find.  return start reason
    1:   *outVisNode = mStartReasonNode;
    1:   *outVisOffset = mStartOffset;  // this really isn't meaningful if mStartReasonNode!=mStartNode
    1:   *outType = mStartReason;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsWSRunObject::NextVisibleNode (nsIDOMNode *aNode, 
    1:                                 PRInt32 aOffset, 
    1:                                 nsCOMPtr<nsIDOMNode> *outVisNode, 
    1:                                 PRInt32 *outVisOffset,
    1:                                 PRInt16 *outType)
    1: {
    1:   // Find first visible thing after the point.  position outVisNode/outVisOffset
    1:   // just _before_ that thing.  If we don't find anything return end of ws.
    1:   if (!aNode || !outVisNode || !outVisOffset || !outType)
    1:     return NS_ERROR_NULL_POINTER;
    1:     
    1:   WSFragment *run;
    1:   FindRun(aNode, aOffset, &run, PR_TRUE);
    1:   
    1:   // is there a visible run there or later?
    1:   while (run)
    1:   {
    1:     if (run->mType == eNormalWS)
    1:     {
    1:       WSPoint point;
    1:       GetCharAfter(aNode, aOffset, &point);
    1:       if (point.mTextNode)
    1:       {
    1:         *outVisNode = do_QueryInterface(point.mTextNode);
    1:         *outVisOffset = point.mOffset;
    1:         if (nsCRT::IsAsciiSpace(point.mChar) || (point.mChar==nbsp))
    1:         {
    1:           *outType = eNormalWS;
    1:         }
    1:         else if (!point.mChar)
    1:         {
    1:           // MOOSE: not possible?
    1:           *outType = eNone;
    1:         }
    1:         else
    1:         {
    1:           *outType = eText;
    1:         }
    1:         return NS_OK;
    1:       }
    1:       // else if no text node then keep looking.  We should eventually fall out of loop
    1:     }
    1: 
    1:     run = run->mRight;
    1:   }
    1:   
    1:   // if we get here then nothing in ws data to find.  return end reason
    1:   *outVisNode = mEndReasonNode;
    1:   *outVisOffset = mEndOffset; // this really isn't meaningful if mEndReasonNode!=mEndNode
    1:   *outType = mEndReason;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::AdjustWhitespace()
    1: {
    1:   // this routine examines a run of ws and tries to get rid of some unneeded nbsp's,
    1:   // replacing them with regualr ascii space if possible.  Keeping things simple
    1:   // for now and just trying to fix up the trailing ws in the run.
    1:   if (!mLastNBSPNode) return NS_OK; // nothing to do!
    1:   nsresult res = NS_OK;
    1:   WSFragment *curRun = mStartRun;
    1:   while (curRun)
    1:   {
    1:     // look for normal ws run
    1:     if (curRun->mType == eNormalWS)
    1:     {
    1:       res = CheckTrailingNBSPOfRun(curRun);
    1:       break;
    1:     }
    1:     curRun = curRun->mRight;
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: //--------------------------------------------------------------------------------------------
    1: //   protected methods
    1: //--------------------------------------------------------------------------------------------
    1: 
25345: already_AddRefed<nsIDOMNode>
25345: nsWSRunObject::GetWSBoundingParent()
25345: {
38285:   if (!mNode)
38285:     return nsnull;
25345:   nsCOMPtr<nsIDOMNode> wsBoundingParent = mNode;
25345:   while (!IsBlockNode(wsBoundingParent))
25345:   {
25345:     nsCOMPtr<nsIDOMNode> parent;
25345:     wsBoundingParent->GetParentNode(getter_AddRefs(parent));
25345:     if (!parent || !mHTMLEditor->IsEditable(parent))
25345:       break;
25345:     wsBoundingParent.swap(parent);
25345:   }
25345:   return wsBoundingParent.forget();
25345: }
25345: 
    1: nsresult
    1: nsWSRunObject::GetWSNodes()
    1: {
    1:   // collect up an array of nodes that are contiguous with the insertion point
    1:   // and which contain only whitespace.  Stop if you reach non-ws text or a new 
    1:   // block boundary.
    1:   nsresult res = NS_OK;
    1:   
    1:   DOMPoint start(mNode, mOffset), end(mNode, mOffset);
25345:   nsCOMPtr<nsIDOMNode> wsBoundingParent = GetWSBoundingParent();
    1: 
    1:   // first look backwards to find preceding ws nodes
    1:   if (mHTMLEditor->IsTextNode(mNode))
    1:   {
    1:     nsCOMPtr<nsIContent> textNode(do_QueryInterface(mNode));
    1:     const nsTextFragment *textFrag = textNode->GetText();
    1:     
    1:     res = PrependNodeToList(mNode);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     if (mOffset)
    1:     {
    1:       PRInt32 pos;
    1:       for (pos=mOffset-1; pos>=0; pos--)
    1:       {
    1:         // sanity bounds check the char position.  bug 136165
    1:         if (pos >= textFrag->GetLength())
    1:         {
    1:           NS_NOTREACHED("looking beyond end of text fragment");
    1:           continue;
    1:         }
    1:         PRUnichar theChar = textFrag->CharAt(pos);
    1:         if (!nsCRT::IsAsciiSpace(theChar))
    1:         {
    1:           if (theChar != nbsp)
    1:           {
    1:             mStartNode = mNode;
    1:             mStartOffset = pos+1;
    1:             mStartReason = eText;
    1:             mStartReasonNode = mNode;
    1:             break;
    1:           }
    1:           // as we look backwards update our earliest found nbsp
    1:           mFirstNBSPNode = mNode;
    1:           mFirstNBSPOffset = pos;
    1:           // also keep track of latest nbsp so far
    1:           if (!mLastNBSPNode)
    1:           {
    1:             mLastNBSPNode = mNode;
    1:             mLastNBSPOffset = pos;
    1:           }
    1:         }
    1:         start.SetPoint(mNode,pos);
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> priorNode;
    1:   while (!mStartNode)
    1:   {
    1:     // we haven't found the start of ws yet.  Keep looking
25345:     res = GetPreviousWSNode(start, wsBoundingParent, address_of(priorNode));
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     if (priorNode)
    1:     {
    1:       if (IsBlockNode(priorNode))
    1:       {
    1:         start.GetPoint(mStartNode, mStartOffset);
    1:         mStartReason = eOtherBlock;
    1:         mStartReasonNode = priorNode;
    1:       }
    1:       else if (mHTMLEditor->IsTextNode(priorNode))
    1:       {
    1:         res = PrependNodeToList(priorNode);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:         nsCOMPtr<nsIContent> textNode(do_QueryInterface(priorNode));
    1:         const nsTextFragment *textFrag;
    1:         if (!textNode || !(textFrag = textNode->GetText())) {
    1:           return NS_ERROR_NULL_POINTER;
    1:         }
    1:         PRUint32 len = textNode->TextLength();
    1: 
    1:         if (len < 1)
    1:         {
    1:           // Zero length text node. Set start point to it
    1:           // so we can get past it!
    1:           start.SetPoint(priorNode,0);
    1:         }
    1:         else
    1:         {
    1:           PRInt32 pos;
    1:           for (pos=len-1; pos>=0; pos--)
    1:           {
    1:             // sanity bounds check the char position.  bug 136165
    1:             if (pos >= textFrag->GetLength())
    1:             {
    1:               NS_NOTREACHED("looking beyond end of text fragment");
    1:               continue;
    1:             }
    1:             PRUnichar theChar = textFrag->CharAt(pos);
    1:             if (!nsCRT::IsAsciiSpace(theChar))
    1:             {
    1:               if (theChar != nbsp)
    1:               {
    1:                 mStartNode = priorNode;
    1:                 mStartOffset = pos+1;
    1:                 mStartReason = eText;
    1:                 mStartReasonNode = priorNode;
    1:                 break;
    1:               }
    1:               // as we look backwards update our earliest found nbsp
    1:               mFirstNBSPNode = priorNode;
    1:               mFirstNBSPOffset = pos;
    1:               // also keep track of latest nbsp so far
    1:               if (!mLastNBSPNode)
    1:               {
    1:                 mLastNBSPNode = priorNode;
    1:                 mLastNBSPOffset = pos;
    1:               }
    1:             }
    1:             start.SetPoint(priorNode,pos);
    1:           }
    1:         }
    1:       }
    1:       else
    1:       {
    1:         // it's a break or a special node, like <img>, that is not a block and not
    1:         // a break but still serves as a terminator to ws runs.
    1:         start.GetPoint(mStartNode, mStartOffset);
    1:         if (nsTextEditUtils::IsBreak(priorNode))
    1:           mStartReason = eBreak;
    1:         else
    1:           mStartReason = eSpecial;
    1:         mStartReasonNode = priorNode;
    1:       }
    1:     }
    1:     else
    1:     {
25345:       // no prior node means we exhausted wsBoundingParent
    1:       start.GetPoint(mStartNode, mStartOffset);
    1:       mStartReason = eThisBlock;
25345:       mStartReasonNode = wsBoundingParent;
    1:     } 
    1:   }
    1:   
    1:   // then look ahead to find following ws nodes
    1:   if (mHTMLEditor->IsTextNode(mNode))
    1:   {
    1:     // don't need to put it on list. it already is from code above
    1:     nsCOMPtr<nsIContent> textNode(do_QueryInterface(mNode));
    1:     const nsTextFragment *textFrag = textNode->GetText();
    1: 
    1:     PRUint32 len = textNode->TextLength();
    1:     if (mOffset<len)
    1:     {
    1:       PRInt32 pos;
    1:       for (pos=mOffset; pos<len; pos++)
    1:       {
    1:         // sanity bounds check the char position.  bug 136165
    1:         if ((pos<0) || (pos>=textFrag->GetLength()))
    1:         {
    1:           NS_NOTREACHED("looking beyond end of text fragment");
    1:           continue;
    1:         }
    1:         PRUnichar theChar = textFrag->CharAt(pos);
    1:         if (!nsCRT::IsAsciiSpace(theChar))
    1:         {
    1:           if (theChar != nbsp)
    1:           {
    1:             mEndNode = mNode;
    1:             mEndOffset = pos;
    1:             mEndReason = eText;
    1:             mEndReasonNode = mNode;
    1:             break;
    1:           }
    1:           // as we look forwards update our latest found nbsp
    1:           mLastNBSPNode = mNode;
    1:           mLastNBSPOffset = pos;
    1:           // also keep track of earliest nbsp so far
    1:           if (!mFirstNBSPNode)
    1:           {
    1:             mFirstNBSPNode = mNode;
    1:             mFirstNBSPOffset = pos;
    1:           }
    1:         }
 1827:         end.SetPoint(mNode,pos+1);
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> nextNode;
    1:   while (!mEndNode)
    1:   {
    1:     // we haven't found the end of ws yet.  Keep looking
25345:     res = GetNextWSNode(end, wsBoundingParent, address_of(nextNode));
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     if (nextNode)
    1:     {
    1:       if (IsBlockNode(nextNode))
    1:       {
    1:         // we encountered a new block.  therefore no more ws.
    1:         end.GetPoint(mEndNode, mEndOffset);
    1:         mEndReason = eOtherBlock;
    1:         mEndReasonNode = nextNode;
    1:       }
    1:       else if (mHTMLEditor->IsTextNode(nextNode))
    1:       {
    1:         res = AppendNodeToList(nextNode);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:         nsCOMPtr<nsIContent> textNode(do_QueryInterface(nextNode));
    1:         const nsTextFragment *textFrag;
    1:         if (!textNode || !(textFrag = textNode->GetText())) {
    1:           return NS_ERROR_NULL_POINTER;
    1:         }
    1:         PRUint32 len = textNode->TextLength();
    1: 
    1:         if (len < 1)
    1:         {
    1:           // Zero length text node. Set end point to it
    1:           // so we can get past it!
    1:           end.SetPoint(nextNode,0);
    1:         }
    1:         else
    1:         {
    1:           PRInt32 pos;
    1:           for (pos=0; pos<len; pos++)
    1:           {
    1:             // sanity bounds check the char position.  bug 136165
    1:             if (pos >= textFrag->GetLength())
    1:             {
    1:               NS_NOTREACHED("looking beyond end of text fragment");
    1:               continue;
    1:             }
    1:             PRUnichar theChar = textFrag->CharAt(pos);
    1:             if (!nsCRT::IsAsciiSpace(theChar))
    1:             {
    1:               if (theChar != nbsp)
    1:               {
    1:                 mEndNode = nextNode;
    1:                 mEndOffset = pos;
    1:                 mEndReason = eText;
    1:                 mEndReasonNode = nextNode;
    1:                 break;
    1:               }
    1:               // as we look forwards update our latest found nbsp
    1:               mLastNBSPNode = nextNode;
    1:               mLastNBSPOffset = pos;
    1:               // also keep track of earliest nbsp so far
    1:               if (!mFirstNBSPNode)
    1:               {
    1:                 mFirstNBSPNode = nextNode;
    1:                 mFirstNBSPOffset = pos;
    1:               }
    1:             }
    1:             end.SetPoint(nextNode,pos+1);
    1:           }
    1:         }
    1:       }
    1:       else
    1:       {
    1:         // we encountered a break or a special node, like <img>, 
    1:         // that is not a block and not a break but still 
    1:         // serves as a terminator to ws runs.
    1:         end.GetPoint(mEndNode, mEndOffset);
    1:         if (nsTextEditUtils::IsBreak(nextNode))
    1:           mEndReason = eBreak;
    1:         else
    1:           mEndReason = eSpecial;
    1:         mEndReasonNode = nextNode;
    1:       }
    1:     }
    1:     else
    1:     {
25345:       // no next node means we exhausted wsBoundingParent
    1:       end.GetPoint(mEndNode, mEndOffset);
    1:       mEndReason = eThisBlock;
25345:       mEndReasonNode = wsBoundingParent;
    1:     } 
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsWSRunObject::GetRuns()
    1: {
    1:   ClearRuns();
    1:   
    1:   // handle some easy cases first
    1:   mHTMLEditor->IsPreformatted(mNode, &mPRE);
    1:   // if it's preformatedd, or if we are surrounded by text or special, it's all one
    1:   // big normal ws run
    1:   if ( mPRE || (((mStartReason == eText) || (mStartReason == eSpecial)) &&
    1:        ((mEndReason == eText) || (mEndReason == eSpecial) || (mEndReason == eBreak))) )
    1:   {
    1:     return MakeSingleWSRun(eNormalWS);
    1:   }
    1: 
    1:   // if we are before or after a block (or after a break), and there are no nbsp's,
    1:   // then it's all non-rendering ws.
    1:   if ( !(mFirstNBSPNode || mLastNBSPNode) &&
    1:       ( (mStartReason & eBlock) || (mStartReason == eBreak) || (mEndReason & eBlock) ) )
    1:   {
    1:     PRInt16 wstype = eNone;
    1:     if ((mStartReason & eBlock) || (mStartReason == eBreak))
    1:       wstype = eLeadingWS;
    1:     if (mEndReason & eBlock) 
    1:       wstype |= eTrailingWS;
    1:     return MakeSingleWSRun(wstype);
    1:   }
    1:   
    1:   // otherwise a little trickier.  shucks.
    1:   mStartRun = new WSFragment();
    1:   if (!mStartRun) return NS_ERROR_NULL_POINTER;
    1:   mStartRun->mStartNode = mStartNode;
    1:   mStartRun->mStartOffset = mStartOffset;
    1:   
    1:   if ( (mStartReason & eBlock) || (mStartReason == eBreak) )
    1:   {
    1:     // set up mStartRun
    1:     mStartRun->mType = eLeadingWS;
    1:     mStartRun->mEndNode = mFirstNBSPNode;
    1:     mStartRun->mEndOffset = mFirstNBSPOffset;
    1:     mStartRun->mLeftType = mStartReason;
    1:     mStartRun->mRightType = eNormalWS;
    1:     
    1:     // set up next run
    1:     WSFragment *normalRun = new WSFragment();
    1:     if (!normalRun) return NS_ERROR_NULL_POINTER;
    1:     mStartRun->mRight = normalRun;
    1:     normalRun->mType = eNormalWS;
    1:     normalRun->mStartNode = mFirstNBSPNode;
    1:     normalRun->mStartOffset = mFirstNBSPOffset;
    1:     normalRun->mLeftType = eLeadingWS;
    1:     normalRun->mLeft = mStartRun;
    1:     if (mEndReason != eBlock)
    1:     {
    1:       // then no trailing ws.  this normal run ends the overall ws run.
    1:       normalRun->mRightType = mEndReason;
    1:       normalRun->mEndNode   = mEndNode;
    1:       normalRun->mEndOffset = mEndOffset;
    1:       mEndRun = normalRun;
    1:     }
    1:     else
    1:     {
    1:       // we might have trailing ws.
    1:       // it so happens that *if* there is an nbsp at end, {mEndNode,mEndOffset-1}
    1:       // will point to it, even though in general start/end points not
    1:       // guaranteed to be in text nodes.
    1:       if ((mLastNBSPNode == mEndNode) && (mLastNBSPOffset == (mEndOffset-1)))
    1:       {
    1:         // normal ws runs right up to adjacent block (nbsp next to block)
    1:         normalRun->mRightType = mEndReason;
    1:         normalRun->mEndNode   = mEndNode;
    1:         normalRun->mEndOffset = mEndOffset;
    1:         mEndRun = normalRun;
    1:       }
    1:       else
    1:       {
    1:         normalRun->mEndNode = mLastNBSPNode;
    1:         normalRun->mEndOffset = mLastNBSPOffset+1;
    1:         normalRun->mRightType = eTrailingWS;
    1:         
    1:         // set up next run
    1:         WSFragment *lastRun = new WSFragment();
    1:         if (!lastRun) return NS_ERROR_NULL_POINTER;
    1:         lastRun->mType = eTrailingWS;
    1:         lastRun->mStartNode = mLastNBSPNode;
    1:         lastRun->mStartOffset = mLastNBSPOffset+1;
    1:         lastRun->mEndNode = mEndNode;
    1:         lastRun->mEndOffset = mEndOffset;
    1:         lastRun->mLeftType = eNormalWS;
    1:         lastRun->mLeft = normalRun;
    1:         lastRun->mRightType = mEndReason;
    1:         mEndRun = lastRun;
    1:         normalRun->mRight = lastRun;
    1:       }
    1:     }
    1:   }
    1:   else // mStartReason is not eBlock or eBreak
    1:   {
    1:     // set up mStartRun
    1:     mStartRun->mType = eNormalWS;
    1:     mStartRun->mEndNode = mLastNBSPNode;
    1:     mStartRun->mEndOffset = mLastNBSPOffset+1;
    1:     mStartRun->mLeftType = mStartReason;
    1: 
    1:     // we might have trailing ws.
    1:     // it so happens that *if* there is an nbsp at end, {mEndNode,mEndOffset-1}
    1:     // will point to it, even though in general start/end points not
    1:     // guaranteed to be in text nodes.
    1:     if ((mLastNBSPNode == mEndNode) && (mLastNBSPOffset == (mEndOffset-1)))
    1:     {
    1:       mStartRun->mRightType = mEndReason;
    1:       mStartRun->mEndNode   = mEndNode;
    1:       mStartRun->mEndOffset = mEndOffset;
    1:       mEndRun = mStartRun;
    1:     }
    1:     else
    1:     {
    1:       // set up next run
    1:       WSFragment *lastRun = new WSFragment();
    1:       if (!lastRun) return NS_ERROR_NULL_POINTER;
    1:       lastRun->mType = eTrailingWS;
    1:       lastRun->mStartNode = mLastNBSPNode;
    1:       lastRun->mStartOffset = mLastNBSPOffset+1;
    1:       lastRun->mLeftType = eNormalWS;
    1:       lastRun->mLeft = mStartRun;
    1:       lastRun->mRightType = mEndReason;
    1:       mEndRun = lastRun;
    1:       mStartRun->mRight = lastRun;
    1:       mStartRun->mRightType = eTrailingWS;
    1:     }
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsWSRunObject::ClearRuns()
    1: {
    1:   WSFragment *tmp, *run;
    1:   run = mStartRun;
    1:   while (run)
    1:   {
    1:     tmp = run->mRight;
    1:     delete run;
    1:     run = tmp;
    1:   }
    1:   mStartRun = 0;
    1:   mEndRun = 0;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::MakeSingleWSRun(PRInt16 aType)
    1: {
    1:   mStartRun = new WSFragment();
    1:   if (!mStartRun) return NS_ERROR_NULL_POINTER;
    1: 
    1:   mStartRun->mStartNode   = mStartNode;
    1:   mStartRun->mStartOffset = mStartOffset;
    1:   mStartRun->mType        = aType;
    1:   mStartRun->mEndNode     = mEndNode;
    1:   mStartRun->mEndOffset   = mEndOffset;
    1:   mStartRun->mLeftType    = mStartReason;
    1:   mStartRun->mRightType   = mEndReason;
    1:   
    1:   mEndRun  = mStartRun;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::PrependNodeToList(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode) return NS_ERROR_NULL_POINTER;
    1:   if (!mNodeArray.InsertObjectAt(aNode, 0))
    1:     return NS_ERROR_FAILURE;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::AppendNodeToList(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode) return NS_ERROR_NULL_POINTER;
    1:   if (!mNodeArray.AppendObject(aNode))
    1:     return NS_ERROR_FAILURE;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetPreviousWSNode(nsIDOMNode *aStartNode, 
    1:                                  nsIDOMNode *aBlockParent, 
    1:                                  nsCOMPtr<nsIDOMNode> *aPriorNode)
    1: {
    1:   // can't really recycle various getnext/prior routines because we
    1:   // have special needs here.  Need to step into inline containers but
    1:   // not block containers.
    1:   if (!aStartNode || !aBlockParent || !aPriorNode) return NS_ERROR_NULL_POINTER;
    1:   
    1:   nsresult res = aStartNode->GetPreviousSibling(getter_AddRefs(*aPriorNode));
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   nsCOMPtr<nsIDOMNode> temp, curNode = aStartNode;
    1:   while (!*aPriorNode)
    1:   {
    1:     // we have exhausted nodes in parent of aStartNode.
    1:     res = curNode->GetParentNode(getter_AddRefs(temp));
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     if (!temp) return NS_ERROR_NULL_POINTER;
    1:     if (temp == aBlockParent)
    1:     {
    1:       // we have exhausted nodes in the block parent.  The convention here is to return null.
    1:       *aPriorNode = nsnull;
    1:       return NS_OK;
    1:     }
    1:     // we have a parent: look for previous sibling
    1:     res = temp->GetPreviousSibling(getter_AddRefs(*aPriorNode));
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     curNode = temp;
    1:   }
    1:   // we have a prior node.  If it's a block, return it.
    1:   if (IsBlockNode(*aPriorNode))
    1:     return NS_OK;
    1:   // else if it's a container, get deep rightmost child
    1:   else if (mHTMLEditor->IsContainer(*aPriorNode))
    1:   {
    1:     temp = mHTMLEditor->GetRightmostChild(*aPriorNode);
    1:     if (temp)
    1:       *aPriorNode = temp;
    1:     return NS_OK;
    1:   }
    1:   // else return the node itself
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetPreviousWSNode(DOMPoint aPoint,
    1:                                  nsIDOMNode *aBlockParent, 
    1:                                  nsCOMPtr<nsIDOMNode> *aPriorNode)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   PRInt32 offset;
    1:   aPoint.GetPoint(node, offset);
    1:   return GetPreviousWSNode(node,offset,aBlockParent,aPriorNode);
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetPreviousWSNode(nsIDOMNode *aStartNode,
    1:                                  PRInt16 aOffset, 
    1:                                  nsIDOMNode *aBlockParent, 
    1:                                  nsCOMPtr<nsIDOMNode> *aPriorNode)
    1: {
    1:   // can't really recycle various getnext/prior routines because we
    1:   // have special needs here.  Need to step into inline containers but
    1:   // not block containers.
    1:   if (!aStartNode || !aBlockParent || !aPriorNode)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aPriorNode = 0;
    1: 
    1:   if (mHTMLEditor->IsTextNode(aStartNode))
    1:     return GetPreviousWSNode(aStartNode, aBlockParent, aPriorNode);
    1:   if (!mHTMLEditor->IsContainer(aStartNode))
    1:     return GetPreviousWSNode(aStartNode, aBlockParent, aPriorNode);
    1:   
    1:   if (!aOffset)
    1:   {
    1:     if (aStartNode==aBlockParent)
    1:     {
    1:       // we are at start of the block.
    1:       return NS_OK;
    1:     }
    1: 
    1:     // we are at start of non-block container
    1:     return GetPreviousWSNode(aStartNode, aBlockParent, aPriorNode);
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> startContent( do_QueryInterface(aStartNode) );
28065:   NS_ENSURE_STATE(startContent);
    1:   nsIContent *priorContent = startContent->GetChildAt(aOffset - 1);
    1:   if (!priorContent) 
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aPriorNode = do_QueryInterface(priorContent);
    1:   // we have a prior node.  If it's a block, return it.
    1:   if (IsBlockNode(*aPriorNode))
    1:     return NS_OK;
    1:   // else if it's a container, get deep rightmost child
    1:   else if (mHTMLEditor->IsContainer(*aPriorNode))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> temp;
    1:     temp = mHTMLEditor->GetRightmostChild(*aPriorNode);
    1:     if (temp)
    1:       *aPriorNode = temp;
    1:     return NS_OK;
    1:   }
    1:   // else return the node itself
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetNextWSNode(nsIDOMNode *aStartNode, 
    1:                              nsIDOMNode *aBlockParent, 
    1:                              nsCOMPtr<nsIDOMNode> *aNextNode)
    1: {
    1:   // can't really recycle various getnext/prior routines because we
    1:   // have special needs here.  Need to step into inline containers but
    1:   // not block containers.
    1:   if (!aStartNode || !aBlockParent || !aNextNode)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   *aNextNode = 0;
    1:   nsresult res = aStartNode->GetNextSibling(getter_AddRefs(*aNextNode));
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   nsCOMPtr<nsIDOMNode> temp, curNode = aStartNode;
    1:   while (!*aNextNode)
    1:   {
    1:     // we have exhausted nodes in parent of aStartNode.
    1:     res = curNode->GetParentNode(getter_AddRefs(temp));
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     if (!temp) return NS_ERROR_NULL_POINTER;
    1:     if (temp == aBlockParent)
    1:     {
    1:       // we have exhausted nodes in the block parent.  The convention
    1:       // here is to return null.
    1:       *aNextNode = nsnull;
    1:       return NS_OK;
    1:     }
    1:     // we have a parent: look for next sibling
    1:     res = temp->GetNextSibling(getter_AddRefs(*aNextNode));
    1:     NS_ENSURE_SUCCESS(res, res);
    1:     curNode = temp;
    1:   }
    1:   // we have a next node.  If it's a block, return it.
    1:   if (IsBlockNode(*aNextNode))
    1:     return NS_OK;
    1:   // else if it's a container, get deep leftmost child
    1:   else if (mHTMLEditor->IsContainer(*aNextNode))
    1:   {
    1:     temp = mHTMLEditor->GetLeftmostChild(*aNextNode);
    1:     if (temp)
    1:       *aNextNode = temp;
    1:     return NS_OK;
    1:   }
    1:   // else return the node itself
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetNextWSNode(DOMPoint aPoint,
    1:                              nsIDOMNode *aBlockParent, 
    1:                              nsCOMPtr<nsIDOMNode> *aNextNode)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   PRInt32 offset;
    1:   aPoint.GetPoint(node, offset);
    1:   return GetNextWSNode(node,offset,aBlockParent,aNextNode);
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetNextWSNode(nsIDOMNode *aStartNode,
    1:                              PRInt16 aOffset, 
    1:                              nsIDOMNode *aBlockParent, 
    1:                              nsCOMPtr<nsIDOMNode> *aNextNode)
    1: {
    1:   // can't really recycle various getnext/prior routines because we have special needs
    1:   // here.  Need to step into inline containers but not block containers.
    1:   if (!aStartNode || !aBlockParent || !aNextNode)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aNextNode = 0;
    1: 
    1:   if (mHTMLEditor->IsTextNode(aStartNode))
    1:     return GetNextWSNode(aStartNode, aBlockParent, aNextNode);
    1:   if (!mHTMLEditor->IsContainer(aStartNode))
    1:     return GetNextWSNode(aStartNode, aBlockParent, aNextNode);
    1:   
    1:   nsCOMPtr<nsIContent> startContent( do_QueryInterface(aStartNode) );
27186:   NS_ENSURE_STATE(startContent);
    1:   nsIContent *nextContent = startContent->GetChildAt(aOffset);
    1:   if (!nextContent)
    1:   {
    1:     if (aStartNode==aBlockParent)
    1:     {
    1:       // we are at end of the block.
    1:       return NS_OK;
    1:     }
    1: 
    1:     // we are at end of non-block container
    1:     return GetNextWSNode(aStartNode, aBlockParent, aNextNode);
    1:   }
    1:   
    1:   *aNextNode = do_QueryInterface(nextContent);
    1:   // we have a next node.  If it's a block, return it.
    1:   if (IsBlockNode(*aNextNode))
    1:     return NS_OK;
    1:   // else if it's a container, get deep leftmost child
    1:   else if (mHTMLEditor->IsContainer(*aNextNode))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> temp;
    1:     temp = mHTMLEditor->GetLeftmostChild(*aNextNode);
    1:     if (temp)
    1:       *aNextNode = temp;
    1:     return NS_OK;
    1:   }
    1:   // else return the node itself
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::PrepareToDeleteRangePriv(nsWSRunObject* aEndObject)
    1: {
    1:   // this routine adjust whitespace before *this* and after aEndObject
    1:   // in preperation for the two areas to become adjacent after the 
    1:   // intervening content is deleted.  It's overly agressive right
    1:   // now.  There might be a block boundary remaining between them after
    1:   // the deletion, in which case these adjstments are unneeded (though
    1:   // I don't think they can ever be harmful?)
    1:   
    1:   if (!aEndObject)
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsresult res = NS_OK;
    1:   
    1:   // get the runs before and after selection
    1:   WSFragment *beforeRun, *afterRun;
    1:   res = FindRun(mNode, mOffset, &beforeRun, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   res = aEndObject->FindRun(aEndObject->mNode, aEndObject->mOffset, &afterRun, PR_TRUE);
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // trim after run of any leading ws
    1:   if (afterRun && (afterRun->mType & eLeadingWS))
    1:   {
    1:     res = aEndObject->DeleteChars(aEndObject->mNode, aEndObject->mOffset, afterRun->mEndNode, afterRun->mEndOffset,
    1:                                   eOutsideUserSelectAll);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   // adjust normal ws in afterRun if needed
    1:   if (afterRun && (afterRun->mType == eNormalWS) && !aEndObject->mPRE)
    1:   {
    1:     if ( (beforeRun && (beforeRun->mType & eLeadingWS)) ||
    1:          (!beforeRun && ((mStartReason & eBlock) || (mStartReason == eBreak))) )
    1:     {
    1:       // make sure leading char of following ws is an nbsp, so that it will show up
    1:       WSPoint point;
    1:       aEndObject->GetCharAfter(aEndObject->mNode, aEndObject->mOffset, &point);
    1:       if (point.mTextNode && nsCRT::IsAsciiSpace(point.mChar))
    1:       {
    1:         res = aEndObject->ConvertToNBSP(point, eOutsideUserSelectAll);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
    1:   // trim before run of any trailing ws
    1:   if (beforeRun && (beforeRun->mType & eTrailingWS))
    1:   {
    1:     res = DeleteChars(beforeRun->mStartNode, beforeRun->mStartOffset, mNode, mOffset,
    1:                       eOutsideUserSelectAll);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   else if (beforeRun && (beforeRun->mType == eNormalWS) && !mPRE)
    1:   {
    1:     if ( (afterRun && (afterRun->mType & eTrailingWS)) ||
    1:          (afterRun && (afterRun->mType == eNormalWS))   ||
    1:          (!afterRun && ((aEndObject->mEndReason & eBlock))) )
    1:     {
    1:       // make sure trailing char of starting ws is an nbsp, so that it will show up
    1:       WSPoint point;
    1:       GetCharBefore(mNode, mOffset, &point);
    1:       if (point.mTextNode && nsCRT::IsAsciiSpace(point.mChar))
    1:       {
    1:         nsCOMPtr<nsIDOMNode> wsStartNode, wsEndNode;
    1:         PRInt32 wsStartOffset, wsEndOffset;
    1:         res = GetAsciiWSBounds(eBoth, mNode, mOffset, 
    1:                                address_of(wsStartNode), &wsStartOffset, 
    1:                                address_of(wsEndNode), &wsEndOffset);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:         point.mTextNode = do_QueryInterface(wsStartNode);
    1:         if (!point.mTextNode->IsNodeOfType(nsINode::eDATA_NODE)) {
    1:           // Not sure if this is needed, but it'll maintain the same
    1:           // functionality
    1:           point.mTextNode = nsnull;
    1:         }
    1:         point.mOffset = wsStartOffset;
    1:         res = ConvertToNBSP(point, eOutsideUserSelectAll);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::PrepareToSplitAcrossBlocksPriv()
    1: {
    1:   // used to prepare ws to be split across two blocks.  The main issue 
    1:   // here is make sure normalWS doesn't end up becoming non-significant
    1:   // leading or trailing ws after the split.
    1:   nsresult res = NS_OK;
    1:   
    1:   // get the runs before and after selection
    1:   WSFragment *beforeRun, *afterRun;
    1:   res = FindRun(mNode, mOffset, &beforeRun, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   res = FindRun(mNode, mOffset, &afterRun, PR_TRUE);
    1:   
    1:   // adjust normal ws in afterRun if needed
    1:   if (afterRun && (afterRun->mType == eNormalWS))
    1:   {
    1:     // make sure leading char of following ws is an nbsp, so that it will show up
    1:     WSPoint point;
    1:     GetCharAfter(mNode, mOffset, &point);
    1:     if (point.mTextNode && nsCRT::IsAsciiSpace(point.mChar))
    1:     {
    1:       res = ConvertToNBSP(point);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1: 
    1:   // adjust normal ws in beforeRun if needed
    1:   if (beforeRun && (beforeRun->mType == eNormalWS))
    1:   {
    1:     // make sure trailing char of starting ws is an nbsp, so that it will show up
    1:     WSPoint point;
    1:     GetCharBefore(mNode, mOffset, &point);
    1:     if (point.mTextNode && nsCRT::IsAsciiSpace(point.mChar))
    1:     {
    1:       nsCOMPtr<nsIDOMNode> wsStartNode, wsEndNode;
    1:       PRInt32 wsStartOffset, wsEndOffset;
    1:       res = GetAsciiWSBounds(eBoth, mNode, mOffset, 
    1:                              address_of(wsStartNode), &wsStartOffset, 
    1:                              address_of(wsEndNode), &wsEndOffset);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:       point.mTextNode = do_QueryInterface(wsStartNode);
    1:       if (!point.mTextNode->IsNodeOfType(nsINode::eDATA_NODE)) {
    1:         // Not sure if this is needed, but it'll maintain the same
    1:         // functionality
    1:         point.mTextNode = nsnull;
    1:       }
    1:       point.mOffset = wsStartOffset;
    1:       res = ConvertToNBSP(point);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::DeleteChars(nsIDOMNode *aStartNode, PRInt32 aStartOffset, 
    1:                            nsIDOMNode *aEndNode, PRInt32 aEndOffset,
    1:                            AreaRestriction aAR)
    1: {
    1:   // MOOSE: this routine needs to be modified to preserve the integrity of the
    1:   // wsFragment info.
    1:   if (!aStartNode || !aEndNode)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   if (aAR == eOutsideUserSelectAll)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> san = mHTMLEditor->FindUserSelectAllNode(aStartNode);
    1:     if (san)
    1:       return NS_OK;
    1:     
    1:     if (aStartNode != aEndNode)
    1:     {
    1:       san = mHTMLEditor->FindUserSelectAllNode(aEndNode);
    1:       if (san)
    1:         return NS_OK;
    1:     }
    1:   }
    1: 
    1:   if ((aStartNode == aEndNode) && (aStartOffset == aEndOffset))
    1:     return NS_OK;  // nothing to delete
    1:   
    1:   nsresult res = NS_OK;
    1:   PRInt32 idx = mNodeArray.IndexOf(aStartNode);
    1:   if (idx==-1) idx = 0; // if our strarting point wasn't one of our ws text nodes,
    1:                         // then just go through them from the beginning.
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIDOMCharacterData> textnode;
    1:   nsCOMPtr<nsIDOMRange> range;
    1: 
    1:   if (aStartNode == aEndNode)
    1:   {
    1:     textnode = do_QueryInterface(aStartNode);
    1:     if (textnode)
    1:     {
    1:       return mHTMLEditor->DeleteText(textnode, (PRUint32)aStartOffset, 
    1:                                      (PRUint32)(aEndOffset-aStartOffset));
    1:     }
    1:   }
    1: 
    1:   PRInt32 count = mNodeArray.Count();
    1:   while (idx < count)
    1:   {
    1:     node = mNodeArray[idx];
    1:     if (!node)
    1:       break;  // we ran out of ws nodes; must have been deleting to end
    1:     if (node == aStartNode)
    1:     {
    1:       textnode = do_QueryInterface(node);
    1:       PRUint32 len;
    1:       textnode->GetLength(&len);
    1:       if (aStartOffset<len)
    1:       {
    1:         res = mHTMLEditor->DeleteText(textnode, (PRUint32)aStartOffset, len-aStartOffset);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     else if (node == aEndNode)
    1:     {
    1:       if (aEndOffset)
    1:       {
    1:         textnode = do_QueryInterface(node);
    1:         res = mHTMLEditor->DeleteText(textnode, 0, (PRUint32)aEndOffset);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       break;
    1:     }
    1:     else
    1:     {
    1:       if (!range)
    1:       {
    1:         range = do_CreateInstance("@mozilla.org/content/range;1");
    1:         if (!range) return NS_ERROR_OUT_OF_MEMORY;
    1:         res = range->SetStart(aStartNode, aStartOffset);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:         res = range->SetEnd(aEndNode, aEndOffset);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       PRBool nodeBefore, nodeAfter;
    1:       nsCOMPtr<nsIContent> content (do_QueryInterface(node));
    1:       res = mHTMLEditor->sRangeHelper->CompareNodeToRange(content, range, &nodeBefore, &nodeAfter);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:       if (nodeAfter)
    1:       {
    1:         break;
    1:       }
    1:       if (!nodeBefore)
    1:       {
    1:         res = mHTMLEditor->DeleteNode(node);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:         mNodeArray.RemoveObject(node);
    1:         --count;
    1:         --idx;
    1:       }
    1:     }
    1:     idx++;
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetCharAfter(nsIDOMNode *aNode, PRInt32 aOffset, WSPoint *outPoint)
    1: {
    1:   if (!aNode || !outPoint)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRInt32 idx = mNodeArray.IndexOf(aNode);
    1:   if (idx == -1) 
    1:   {
    1:     // use range comparisons to get right ws node
    1:     return GetWSPointAfter(aNode, aOffset, outPoint);
    1:   }
    1:   else
    1:   {
    1:     // use wspoint version of GetCharAfter()
    1:     WSPoint point(aNode,aOffset,0);
    1:     return GetCharAfter(point, outPoint);
    1:   }
    1:   
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetCharBefore(nsIDOMNode *aNode, PRInt32 aOffset, WSPoint *outPoint)
    1: {
    1:   if (!aNode || !outPoint)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRInt32 idx = mNodeArray.IndexOf(aNode);
    1:   if (idx == -1) 
    1:   {
    1:     // use range comparisons to get right ws node
    1:     return GetWSPointBefore(aNode, aOffset, outPoint);
    1:   }
    1:   else
    1:   {
    1:     // use wspoint version of GetCharBefore()
    1:     WSPoint point(aNode,aOffset,0);
    1:     return GetCharBefore(point, outPoint);
    1:   }
    1:   
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetCharAfter(WSPoint &aPoint, WSPoint *outPoint)
    1: {
    1:   if (!aPoint.mTextNode || !outPoint)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   outPoint->mTextNode = nsnull;
    1:   outPoint->mOffset = 0;
    1:   outPoint->mChar = 0;
    1: 
    1:   nsCOMPtr<nsIDOMNode> pointTextNode(do_QueryInterface(aPoint.mTextNode));
    1:   PRInt32 idx = mNodeArray.IndexOf(pointTextNode);
    1:   if (idx == -1) return NS_OK;  // can't find point, but it's not an error
    1:   PRInt32 numNodes = mNodeArray.Count();
    1:   
    1:   if (aPoint.mOffset < aPoint.mTextNode->TextLength())
    1:   {
    1:     *outPoint = aPoint;
    1:     outPoint->mChar = GetCharAt(aPoint.mTextNode, aPoint.mOffset);
    1:   }
    1:   else if (idx < (PRInt32)(numNodes-1))
    1:   {
    1:     nsIDOMNode* node = mNodeArray[idx+1];
    1:     if (!node) return NS_ERROR_FAILURE;
    1:     outPoint->mTextNode = do_QueryInterface(node);
    1:     if (!outPoint->mTextNode->IsNodeOfType(nsINode::eDATA_NODE)) {
    1:       // Not sure if this is needed, but it'll maintain the same
    1:       // functionality
    1:       outPoint->mTextNode = nsnull;
    1:     }
    1:     outPoint->mOffset = 0;
    1:     outPoint->mChar = GetCharAt(outPoint->mTextNode, 0);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetCharBefore(WSPoint &aPoint, WSPoint *outPoint)
    1: {
    1:   if (!aPoint.mTextNode || !outPoint)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
    1:   outPoint->mTextNode = nsnull;
    1:   outPoint->mOffset = 0;
    1:   outPoint->mChar = 0;
    1:   
    1:   nsCOMPtr<nsIDOMNode> pointTextNode(do_QueryInterface(aPoint.mTextNode));
    1:   PRInt32 idx = mNodeArray.IndexOf(pointTextNode);
    1:   if (idx == -1) return NS_OK;  // can't find point, but it's not an error
    1:   
    1:   if (aPoint.mOffset != 0)
    1:   {
    1:     *outPoint = aPoint;
    1:     outPoint->mOffset--;
    1:     outPoint->mChar = GetCharAt(aPoint.mTextNode, aPoint.mOffset-1);
    1:   }
    1:   else if (idx)
    1:   {
    1:     nsIDOMNode* node = mNodeArray[idx-1];
    1:     if (!node) return NS_ERROR_FAILURE;
    1:     outPoint->mTextNode = do_QueryInterface(node);
    1: 
    1:     PRUint32 len = outPoint->mTextNode->TextLength();
    1: 
    1:     if (len)
    1:     {
    1:       outPoint->mOffset = len-1;
    1:       outPoint->mChar = GetCharAt(outPoint->mTextNode, len-1);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::ConvertToNBSP(WSPoint aPoint, AreaRestriction aAR)
    1: {
    1:   // MOOSE: this routine needs to be modified to preserve the integrity of the
    1:   // wsFragment info.
    1:   if (!aPoint.mTextNode)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   if (aAR == eOutsideUserSelectAll)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> domnode = do_QueryInterface(aPoint.mTextNode);
    1:     if (domnode)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> san = mHTMLEditor->FindUserSelectAllNode(domnode);
    1:       if (san)
    1:         return NS_OK;
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMCharacterData> textNode(do_QueryInterface(aPoint.mTextNode));
    1:   if (!textNode)
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(textNode));
    1:   
    1:   // first, insert an nbsp
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:   nsAutoString nbspStr(nbsp);
    1:   nsresult res = mHTMLEditor->InsertTextIntoTextNodeImpl(nbspStr, textNode, aPoint.mOffset, PR_TRUE);
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // next, find range of ws it will replace
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:   PRInt32 startOffset=0, endOffset=0;
    1:   
    1:   res = GetAsciiWSBounds(eAfter, node, aPoint.mOffset+1, address_of(startNode), 
    1:                          &startOffset, address_of(endNode), &endOffset);
    1:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // finally, delete that replaced ws, if any
    1:   if (startNode)
    1:   {
    1:     res = DeleteChars(startNode, startOffset, endNode, endOffset);
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsWSRunObject::GetAsciiWSBounds(PRInt16 aDir, nsIDOMNode *aNode, PRInt32 aOffset,
    1:                                 nsCOMPtr<nsIDOMNode> *outStartNode, PRInt32 *outStartOffset,
    1:                                 nsCOMPtr<nsIDOMNode> *outEndNode, PRInt32 *outEndOffset)
    1: {
    1:   if (!aNode || !outStartNode || !outEndNode)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:   PRInt32 startOffset=0, endOffset=0;
    1:   
    1:   nsresult res = NS_OK;
    1:   
    1:   if (aDir & eAfter)
    1:   {
    1:     WSPoint point, tmp;
    1:     res = GetCharAfter(aNode, aOffset, &point);
    1:     if (NS_SUCCEEDED(res) && point.mTextNode)
    1:     {  // we found a text node, at least
    1:       endNode = do_QueryInterface(point.mTextNode);
    1:       endOffset = point.mOffset;
    1:       startNode = endNode;
    1:       startOffset = endOffset;
    1:       
    1:       // scan ahead to end of ascii ws
    1:       while (nsCRT::IsAsciiSpace(point.mChar))
    1:       {
    1:         endNode = do_QueryInterface(point.mTextNode);
    1:         point.mOffset++;  // endOffset is _after_ ws
    1:         endOffset = point.mOffset;
    1:         tmp = point;
    1:         res = GetCharAfter(tmp, &point);
    1:         if (NS_FAILED(res) || !point.mTextNode) break;
    1:       }
    1:     }
    1:   }
    1:   
    1:   if (aDir & eBefore)
    1:   {
    1:     WSPoint point, tmp;
    1:     res = GetCharBefore(aNode, aOffset, &point);
    1:     if (NS_SUCCEEDED(res) && point.mTextNode)
    1:     {  // we found a text node, at least
    1:       startNode = do_QueryInterface(point.mTextNode);
    1:       startOffset = point.mOffset+1;
    1:       if (!endNode)
    1:       {
    1:         endNode = startNode;
    1:         endOffset = startOffset;
    1:       }
    1:       
    1:       // scan back to start of ascii ws
    1:       while (nsCRT::IsAsciiSpace(point.mChar))
    1:       {
    1:         startNode = do_QueryInterface(point.mTextNode);
    1:         startOffset = point.mOffset;
    1:         tmp = point;
    1:         res = GetCharBefore(tmp, &point);
    1:         if (NS_FAILED(res) || !point.mTextNode) break;
    1:       }
    1:     }
    1:   }  
    1:   
    1:   *outStartNode = startNode;
    1:   *outStartOffset = startOffset;
    1:   *outEndNode = endNode;
    1:   *outEndOffset = endOffset;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsWSRunObject::FindRun(nsIDOMNode *aNode, PRInt32 aOffset, WSFragment **outRun, PRBool after)
    1: {
    1:   // given a dompoint, find the ws run that is before or after it, as caller needs
    1:   if (!aNode || !outRun)
    1:     return NS_ERROR_NULL_POINTER;
    1:     
    1:   nsresult res = NS_OK;
    1:   WSFragment *run = mStartRun;
    1:   while (run)
    1:   {
    1:     PRInt16 comp = mHTMLEditor->sRangeHelper->ComparePoints(aNode, aOffset, run->mStartNode, run->mStartOffset);
    1:     if (comp <= 0)
    1:     {
    1:       if (after)
    1:       {
    1:         *outRun = run;
    1:         return res;
    1:       }
    1:       else // before
    1:       {
    1:         *outRun = nsnull;
    1:         return res;
    1:       }
    1:     }
    1:     comp = mHTMLEditor->sRangeHelper->ComparePoints(aNode, aOffset, run->mEndNode, run->mEndOffset);
    1:     if (comp < 0)
    1:     {
    1:       *outRun = run;
    1:       return res;
    1:     }
    1:     else if (comp == 0)
    1:     {
    1:       if (after)
    1:       {
    1:         *outRun = run->mRight;
    1:         return res;
    1:       }
    1:       else // before
    1:       {
    1:         *outRun = run;
    1:         return res;
    1:       }
    1:     }
    1:     if (!run->mRight)
    1:     {
    1:       if (after)
    1:       {
    1:         *outRun = nsnull;
    1:         return res;
    1:       }
    1:       else // before
    1:       {
    1:         *outRun = run;
    1:         return res;
    1:       }
    1:     }
    1:     run = run->mRight;
    1:   }
    1:   return res;
    1: }
    1: 
    1: PRUnichar 
    1: nsWSRunObject::GetCharAt(nsIContent *aTextNode, PRInt32 aOffset)
    1: {
    1:   // return 0 if we can't get a char, for whatever reason
    1:   if (!aTextNode)
    1:     return 0;
    1: 
    1:   PRUint32 len = aTextNode->TextLength();
    1:   if (aOffset < 0 || aOffset >= len) 
    1:     return 0;
    1:     
    1:   return aTextNode->GetText()->CharAt(aOffset);
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetWSPointAfter(nsIDOMNode *aNode, PRInt32 aOffset, WSPoint *outPoint)
    1: {
    1:   // Note: only to be called if aNode is not a ws node.  
    1:   
    1:   // binary search on wsnodes
    1:   PRInt32 numNodes, firstNum, curNum, lastNum;
    1:   numNodes = mNodeArray.Count();
    1:   
    1:   if (!numNodes) 
    1:     return NS_OK; // do nothing if there are no nodes to search
    1: 
    1:   firstNum = 0;
    1:   curNum = numNodes/2;
    1:   lastNum = numNodes;
    1:   PRInt16 cmp=0;
    1:   nsCOMPtr<nsIDOMNode>  curNode;
    1:   
    1:   // begin binary search
    1:   // we do this because we need to minimize calls to ComparePoints(),
    1:   // which is mongo expensive
    1:   while (curNum != lastNum)
    1:   {
    1:     curNode = mNodeArray[curNum];
    1:     cmp = mHTMLEditor->sRangeHelper->ComparePoints(aNode, aOffset, curNode, 0);
    1:     if (cmp < 0)
    1:       lastNum = curNum;
    1:     else
    1:       firstNum = curNum + 1;
    1:     curNum = (lastNum - firstNum) / 2 + firstNum;
    1:     NS_ASSERTION(firstNum <= curNum && curNum <= lastNum, "Bad binary search");
    1:   }
    1: 
    1:   // When the binary search is complete, we always know that the current node
    1:   // is the same as the end node, which is always past our range. Therefore,
    1:   // we've found the node immediately after the point of interest.
    1:   if (curNum == mNodeArray.Count()) {
    1:     // they asked for past our range (it's after the last node). GetCharAfter
    1:     // will do the work for us when we pass it the last index of the last node.
    1:     nsCOMPtr<nsIContent> textNode(do_QueryInterface(mNodeArray[curNum-1]));
    1:     WSPoint point(textNode, textNode->TextLength(), 0);
    1:     return GetCharAfter(point, outPoint);
    1:   } else {
    1:     // The char after the point of interest is the first character of our range.
    1:     nsCOMPtr<nsIContent> textNode(do_QueryInterface(mNodeArray[curNum]));
    1:     WSPoint point(textNode, 0, 0);
    1:     return GetCharAfter(point, outPoint);
    1:   }
    1: }
    1: 
    1: nsresult 
    1: nsWSRunObject::GetWSPointBefore(nsIDOMNode *aNode, PRInt32 aOffset, WSPoint *outPoint)
    1: {
    1:   // Note: only to be called if aNode is not a ws node.  
    1:   
    1:   // binary search on wsnodes
    1:   PRInt32 numNodes, firstNum, curNum, lastNum;
    1:   numNodes = mNodeArray.Count();
    1:   
    1:   if (!numNodes) 
    1:     return NS_OK; // do nothing if there are no nodes to search
    1:   
    1:   firstNum = 0;
    1:   curNum = numNodes/2;
    1:   lastNum = numNodes;
    1:   PRInt16 cmp=0;
    1:   nsCOMPtr<nsIDOMNode>  curNode;
    1:   
    1:   // begin binary search
    1:   // we do this because we need to minimize calls to ComparePoints(),
    1:   // which is mongo expensive
    1:   while (curNum != lastNum)
    1:   {
    1:     curNode = mNodeArray[curNum];
    1:     cmp = mHTMLEditor->sRangeHelper->ComparePoints(aNode, aOffset, curNode, 0);
    1:     if (cmp < 0)
    1:       lastNum = curNum;
    1:     else
    1:       firstNum = curNum + 1;
    1:     curNum = (lastNum - firstNum) / 2 + firstNum;
    1:     NS_ASSERTION(firstNum <= curNum && curNum <= lastNum, "Bad binary search");
    1:   }
    1: 
    1:   // When the binary search is complete, we always know that the current node
    1:   // is the same as the end node, which is always past our range. Therefore,
    1:   // we've found the node immediately after the point of interest.
    1:   if (curNum == mNodeArray.Count()) {
    1:     // get the point before the end of the last node, we can pass the length
    1:     // of the node into GetCharBefore, and it will return the last character.
    1:     nsCOMPtr<nsIContent> textNode(do_QueryInterface(mNodeArray[curNum - 1]));
    1:     WSPoint point(textNode, textNode->TextLength(), 0);
    1:     return GetCharBefore(point, outPoint);
    1:   } else {
    1:     // we can just ask the current node for the point immediately before it,
    1:     // it will handle moving to the previous node (if any) and returning the
    1:     // appropriate character
    1:     nsCOMPtr<nsIContent> textNode(do_QueryInterface(mNodeArray[curNum]));
    1:     WSPoint point(textNode, 0, 0);
    1:     return GetCharBefore(point, outPoint);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsWSRunObject::CheckTrailingNBSPOfRun(WSFragment *aRun)
    1: {    
    1:   // try to change an nbsp to a space, if possible, just to prevent nbsp proliferation. 
    1:   // examine what is before and after the trailing nbsp, if any.
    1:   if (!aRun) return NS_ERROR_NULL_POINTER;
    1:   WSPoint thePoint;
    1:   PRBool leftCheck = PR_FALSE;
    1:   PRBool spaceNBSP = PR_FALSE;
    1:   PRBool rightCheck = PR_FALSE;
    1:   
    1:   // confirm run is normalWS
    1:   if (aRun->mType != eNormalWS) return NS_ERROR_FAILURE;
    1:   
    1:   // first check for trailing nbsp
    1:   nsresult res = GetCharBefore(aRun->mEndNode, aRun->mEndOffset, &thePoint);
    1:   if (NS_SUCCEEDED(res) && thePoint.mTextNode && thePoint.mChar == nbsp)
    1:   {
    1:     // now check that what is to the left of it is compatible with replacing nbsp with space
    1:     WSPoint prevPoint;
    1:     res = GetCharBefore(thePoint, &prevPoint);
    1:     if (NS_SUCCEEDED(res) && prevPoint.mTextNode)
    1:     {
    1:       if (!nsCRT::IsAsciiSpace(prevPoint.mChar)) leftCheck = PR_TRUE;
    1:       else spaceNBSP = PR_TRUE;
    1:     }
    1:     else if (aRun->mLeftType == eText)    leftCheck = PR_TRUE;
    1:     else if (aRun->mLeftType == eSpecial) leftCheck = PR_TRUE;
    1:     if (leftCheck || spaceNBSP)
    1:     {
    1:       // now check that what is to the right of it is compatible with replacing nbsp with space
    1:       if (aRun->mRightType == eText)    rightCheck = PR_TRUE;
    1:       if (aRun->mRightType == eSpecial) rightCheck = PR_TRUE;
    1:       if (aRun->mRightType == eBreak)   rightCheck = PR_TRUE;
25345:       if ((aRun->mRightType & eBlock) &&
25345:           IsBlockNode(nsCOMPtr<nsIDOMNode>(GetWSBoundingParent())))
    1:       {
    1:         // we are at a block boundary.  Insert a <br>.  Why?  Well, first note that
    1:         // the br will have no visible effect since it is up against a block boundary.
    1:         // |foo<br><p>bar|  renders like |foo<p>bar| and similarly
    1:         // |<p>foo<br></p>bar| renders like |<p>foo</p>bar|.  What this <br> addition
    1:         // gets us is the ability to convert a trailing nbsp to a space.  Consider:
    1:         // |<body>foo. '</body>|, where ' represents selection.  User types space attempting
    1:         // to put 2 spaces after the end of their sentence.  We used to do this as:
    1:         // |<body>foo. &nbsp</body>|  This caused problems with soft wrapping: the nbsp
    1:         // would wrap to the next line, which looked attrocious.  If you try to do:
    1:         // |<body>foo.&nbsp </body>| instead, the trailing space is invisible because it 
    1:         // is against a block boundary.  If you do: |<body>foo.&nbsp&nbsp</body>| then
    1:         // you get an even uglier soft wrapping problem, where foo is on one line until
    1:         // you type the final space, and then "foo  " jumps down to the next line.  Ugh.
    1:         // The best way I can find out of this is to throw in a harmless <br>
    1:         // here, which allows us to do: |<body>foo.&nbsp <br></body>|, which doesn't
    1:         // cause foo to jump lines, doesn't cause spaces to show up at the beginning of 
    1:         // soft wrapped lines, and lets the user see 2 spaces when they type 2 spaces.
    1: 
    1:         nsCOMPtr<nsIDOMNode> brNode;
    1:         res = mHTMLEditor->CreateBR(aRun->mEndNode, aRun->mEndOffset, address_of(brNode));
    1:         NS_ENSURE_SUCCESS(res, res);
    1: 
    1:         // refresh thePoint, prevPoint
    1:         res = GetCharBefore(aRun->mEndNode, aRun->mEndOffset, &thePoint);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:         res = GetCharBefore(thePoint, &prevPoint);
    1:         NS_ENSURE_SUCCESS(res, res);
    1:         rightCheck = PR_TRUE;
    1:       }
    1:     }
    1:     if (leftCheck && rightCheck)
    1:     {
    1:       // now replace nbsp with space
    1:       // first, insert a space
    1:       nsCOMPtr<nsIDOMCharacterData> textNode(do_QueryInterface(thePoint.mTextNode));
    1:       if (!textNode)
    1:         return NS_ERROR_NULL_POINTER;
    1:       nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:       nsAutoString spaceStr(PRUnichar(32));
    1:       res = mHTMLEditor->InsertTextIntoTextNodeImpl(spaceStr, textNode, thePoint.mOffset, PR_TRUE);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:   
    1:       // finally, delete that nbsp
    1:       nsCOMPtr<nsIDOMNode> delNode(do_QueryInterface(thePoint.mTextNode));
    1:       res = DeleteChars(delNode, thePoint.mOffset+1, delNode, thePoint.mOffset+2);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else if (!mPRE && spaceNBSP && rightCheck)  // don't mess with this preformatted for now.
    1:     {
    1:       // we have a run of ascii whitespace (which will render as one space)
    1:       // followed by an nbsp (which is at the end of the whitespace run).  Let's
    1:       // switch their order.  This will insure that if someone types two spaces
    1:       // after a sentence, and the editor softwraps at this point, the spaces wont
    1:       // be split across lines, which looks ugly and is bad for the moose.
    1:       
    1:       nsCOMPtr<nsIDOMNode> startNode, endNode, thenode(do_QueryInterface(prevPoint.mTextNode));
    1:       PRInt32 startOffset, endOffset;
    1:       res = GetAsciiWSBounds(eBoth, thenode, prevPoint.mOffset+1, address_of(startNode), 
    1:                            &startOffset, address_of(endNode), &endOffset);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:       
    1:       //  delete that nbsp
    1:       nsCOMPtr<nsIDOMNode> delNode(do_QueryInterface(thePoint.mTextNode));
    1:       res = DeleteChars(delNode, thePoint.mOffset, delNode, thePoint.mOffset+1);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:       
    1:       // finally, insert that nbsp before the ascii ws run
    1:       nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:       nsAutoString nbspStr(nbsp);
    1:       nsCOMPtr<nsIDOMCharacterData> textNode(do_QueryInterface(startNode));
    1:       res = mHTMLEditor->InsertTextIntoTextNodeImpl(nbspStr, textNode, startOffset, PR_TRUE);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsWSRunObject::CheckTrailingNBSP(WSFragment *aRun, nsIDOMNode *aNode, PRInt32 aOffset)
    1: {    
    1:   // try to change an nbsp to a space, if possible, just to prevent nbsp proliferation. 
    1:   // this routine is called when we about to make this point in the ws abut an inserted break
    1:   // or text, so we don't have to worry about what is after it.  What is after it now will 
    1:   // end up after the inserted object.   
    1:   if (!aRun || !aNode) return NS_ERROR_NULL_POINTER;
    1:   WSPoint thePoint;
    1:   PRBool canConvert = PR_FALSE;
    1:   nsresult res = GetCharBefore(aNode, aOffset, &thePoint);
    1:   if (NS_SUCCEEDED(res) && thePoint.mTextNode && thePoint.mChar == nbsp)
    1:   {
    1:     WSPoint prevPoint;
    1:     res = GetCharBefore(thePoint, &prevPoint);
    1:     if (NS_SUCCEEDED(res) && prevPoint.mTextNode)
    1:     {
    1:       if (!nsCRT::IsAsciiSpace(prevPoint.mChar)) canConvert = PR_TRUE;
    1:     }
    1:     else if (aRun->mLeftType == eText)    canConvert = PR_TRUE;
    1:     else if (aRun->mLeftType == eSpecial) canConvert = PR_TRUE;
    1:   }
    1:   if (canConvert)
    1:   {
    1:     // first, insert a space
    1:     nsCOMPtr<nsIDOMCharacterData> textNode(do_QueryInterface(thePoint.mTextNode));
    1:     if (!textNode)
    1:       return NS_ERROR_NULL_POINTER;
    1:     nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:     nsAutoString spaceStr(PRUnichar(32));
    1:     res = mHTMLEditor->InsertTextIntoTextNodeImpl(spaceStr, textNode, thePoint.mOffset, PR_TRUE);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:   
    1:     // finally, delete that nbsp
    1:     nsCOMPtr<nsIDOMNode> delNode(do_QueryInterface(thePoint.mTextNode));
    1:     res = DeleteChars(delNode, thePoint.mOffset+1, delNode, thePoint.mOffset+2);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsWSRunObject::CheckLeadingNBSP(WSFragment *aRun, nsIDOMNode *aNode, PRInt32 aOffset)
    1: {    
    1:   // try to change an nbsp to a space, if possible, just to prevent nbsp proliferation    
    1:   // this routine is called when we about to make this point in the ws abut an inserted
    1:   // text, so we don't have to worry about what is before it.  What is before it now will 
    1:   // end up before the inserted text.   
    1:   WSPoint thePoint;
    1:   PRBool canConvert = PR_FALSE;
    1:   nsresult res = GetCharAfter(aNode, aOffset, &thePoint);
    1:   if (NS_SUCCEEDED(res) && thePoint.mChar == nbsp)
    1:   {
    1:     WSPoint nextPoint, tmp=thePoint;
    1:     tmp.mOffset++; // we want to be after thePoint
    1:     res = GetCharAfter(tmp, &nextPoint);
    1:     if (NS_SUCCEEDED(res) && nextPoint.mTextNode)
    1:     {
    1:       if (!nsCRT::IsAsciiSpace(nextPoint.mChar)) canConvert = PR_TRUE;
    1:     }
    1:     else if (aRun->mRightType == eText)    canConvert = PR_TRUE;
    1:     else if (aRun->mRightType == eSpecial) canConvert = PR_TRUE;
    1:     else if (aRun->mRightType == eBreak)   canConvert = PR_TRUE;
    1:   }
    1:   if (canConvert)
    1:   {
    1:     // first, insert a space
    1:     nsCOMPtr<nsIDOMCharacterData> textNode(do_QueryInterface(thePoint.mTextNode));
    1:     if (!textNode)
    1:       return NS_ERROR_NULL_POINTER;
    1:     nsAutoTxnsConserveSelection dontSpazMySelection(mHTMLEditor);
    1:     nsAutoString spaceStr(PRUnichar(32));
    1:     res = mHTMLEditor->InsertTextIntoTextNodeImpl(spaceStr, textNode, thePoint.mOffset, PR_TRUE);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:   
    1:     // finally, delete that nbsp
    1:     nsCOMPtr<nsIDOMNode> delNode(do_QueryInterface(thePoint.mTextNode));
    1:     res = DeleteChars(delNode, thePoint.mOffset+1, delNode, thePoint.mOffset+2);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsWSRunObject::ScrubBlockBoundaryInner(nsHTMLEditor *aHTMLEd, 
    1:                                        nsCOMPtr<nsIDOMNode> *aBlock,
    1:                                        BlockBoundary aBoundary)
    1: {
    1:   if (!aBlock || !aHTMLEd)
    1:     return NS_ERROR_NULL_POINTER;
    1:   PRInt32 offset=0;
    1:   if (aBoundary == kBlockEnd)
    1:   {
    1:     PRUint32 uOffset;
    1:     aHTMLEd->GetLengthOfDOMNode(*aBlock, uOffset); 
    1:     offset = uOffset;
    1:   }
    1:   nsWSRunObject theWSObj(aHTMLEd, *aBlock, offset);
    1:   return theWSObj.Scrub();    
    1: }
    1: 
    1: 
    1: nsresult
    1: nsWSRunObject::Scrub()
    1: {
    1:   WSFragment *run = mStartRun;
    1:   while (run)
    1:   {
    1:     if (run->mType & (eLeadingWS|eTrailingWS) )
    1:     {
    1:       nsresult res = DeleteChars(run->mStartNode, run->mStartOffset, run->mEndNode, run->mEndOffset);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     run = run->mRight;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
