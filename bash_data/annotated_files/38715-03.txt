    1: /* vim: set sw=4 sts=4 et cin: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is OS/2 code in Thebes.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Peter Weilbacher <mozilla@Weilbacher.org>.
 1637:  * Portions created by the Initial Developer are Copyright (C) 2006-2007
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
 1637:  *   author of code taken from gfxPlatformGtk:
 1637:  *     Masayuki Nakano <masayuki@d-toybox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxOS2Platform.h"
    1: #include "gfxOS2Surface.h"
    1: #include "gfxImageSurface.h"
  270: #include "gfxOS2Fonts.h"
23904: #include "nsTArray.h"
    1: 
 1637: #include "gfxFontconfigUtils.h"
 1637: //#include <fontconfig/fontconfig.h>
 1637: 
    1: /**********************************************************************
    1:  * class gfxOS2Platform
    1:  **********************************************************************/
 1637: gfxFontconfigUtils *gfxOS2Platform::sFontconfigUtils = nsnull;
 1637: 
    1: gfxOS2Platform::gfxOS2Platform()
    1: {
    1: #ifdef DEBUG_thebes
    1:     printf("gfxOS2Platform::gfxOS2Platform()\n");
    1: #endif
    1:     // this seems to be reasonably early in the process and only once,
    1:     // so it's a good place to initialize OS/2 cairo stuff
    1:     cairo_os2_init();
    1: #ifdef DEBUG_thebes
    1:     printf("  cairo_os2_init() was called\n");
    1: #endif
 1637:     if (!sFontconfigUtils) {
 1637:         sFontconfigUtils = gfxFontconfigUtils::GetFontconfigUtils();
 1637:     }
    1: }
    1: 
    1: gfxOS2Platform::~gfxOS2Platform()
    1: {
    1: #ifdef DEBUG_thebes
    1:     printf("gfxOS2Platform::~gfxOS2Platform()\n");
    1: #endif
 1637:     gfxFontconfigUtils::Shutdown();
 1637:     sFontconfigUtils = nsnull;
    1: 
    1:     // clean up OS/2 cairo stuff
    1:     cairo_os2_fini();
    1: #ifdef DEBUG_thebes
    1:     printf("  cairo_os2_fini() was called\n");
    1: #endif
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: gfxOS2Platform::CreateOffscreenSurface(const gfxIntSize& aSize,
    1:                                        gfxASurface::gfxImageFormat aImageFormat)
    1: {
 1637: #ifdef DEBUG_thebes_2
    1:     printf("gfxOS2Platform::CreateOffscreenSurface(%d/%d, %d)\n",
    1:            aSize.width, aSize.height, aImageFormat);
    1: #endif
    1:     gfxASurface *newSurface = nsnull;
    1: 
 6062:     // we only ever seem to get aImageFormat=0 or ImageFormatARGB32 but
    1:     // I don't really know if we need to differ between ARGB32 and RGB24 here
    1:     if (aImageFormat == gfxASurface::ImageFormatARGB32 ||
    1:         aImageFormat == gfxASurface::ImageFormatRGB24)
    1:     {
 6062:         newSurface = new gfxOS2Surface(aSize, aImageFormat);
    1:     } else if (aImageFormat == gfxASurface::ImageFormatA8 ||
    1:                aImageFormat == gfxASurface::ImageFormatA1) {
    1:         newSurface = new gfxImageSurface(aSize, aImageFormat);
    1:     } else {
    1:         return nsnull;
    1:     }
    1: 
    1:     NS_IF_ADDREF(newSurface);
    1:     return newSurface;
    1: }
    1: 
    1: nsresult
38493: gfxOS2Platform::GetFontList(nsIAtom *aLangGroup,
    1:                             const nsACString& aGenericFamily,
23904:                             nsTArray<nsString>& aListOfFonts)
    1: {
    1: #ifdef DEBUG_thebes
38715:     const char *langgroup = "(null)";
38715:     if (aLangGroup) {
38493:         aLangGroup->GetUTF8String(&langgroup);
38715:     }
38493:     char *family = ToNewCString(aGenericFamily);
    1:     printf("gfxOS2Platform::GetFontList(%s, %s, ..)\n",
    1:            langgroup, family);
 1637:     free(family);
    1: #endif
 1637:     return sFontconfigUtils->GetFontList(aLangGroup, aGenericFamily,
 1637:                                          aListOfFonts);
 1637: }
 1637: 
 1637: nsresult gfxOS2Platform::UpdateFontList()
 1637: {
16071: #ifdef DEBUG_thebes
16071:     printf("gfxOS2Platform::UpdateFontList()\n");
16071: #endif
16071:     mCodepointsWithNoFonts.reset();
16071: 
16071:     nsresult rv = sFontconfigUtils->UpdateFontList();
16071: 
16071:     // initialize ranges of characters for which system-wide font search should be skipped
16071:     mCodepointsWithNoFonts.SetRange(0,0x1f);     // C0 controls
16071:     mCodepointsWithNoFonts.SetRange(0x7f,0x9f);  // C1 controls
16071:     return rv;
    1: }
    1: 
    1: nsresult
    1: gfxOS2Platform::ResolveFontName(const nsAString& aFontName,
    1:                                 FontResolverCallback aCallback,
    1:                                 void *aClosure, PRBool& aAborted)
    1: {
    1: #ifdef DEBUG_thebes
    1:     char *fontname = ToNewCString(aFontName);
    1:     printf("gfxOS2Platform::ResolveFontName(%s, ...)\n", fontname);
 1637:     free(fontname);
    1: #endif
 1637:     return sFontconfigUtils->ResolveFontName(aFontName, aCallback, aClosure,
 1637:                                              aAborted);
    1: }
  270: 
13003: nsresult
13003: gfxOS2Platform::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
13003: {
13003:     return sFontconfigUtils->GetStandardFamilyName(aFontName, aFamilyName);
13003: }
13003: 
  270: gfxFontGroup *
  270: gfxOS2Platform::CreateFontGroup(const nsAString &aFamilies,
19962:                 const gfxFontStyle *aStyle,
19962:                 gfxUserFontSet *aUserFontSet)
  270: {
19962:     return new gfxOS2FontGroup(aFamilies, aStyle, aUserFontSet);
  270: }
16071: 
16071: already_AddRefed<gfxOS2Font>
16071: gfxOS2Platform::FindFontForChar(PRUint32 aCh, gfxOS2Font *aFont)
16071: {
16071: #ifdef DEBUG_thebes
16071:     printf("gfxOS2Platform::FindFontForChar(%d, ...)\n", aCh);
16071: #endif
16071: 
16071:     // is codepoint with no matching font? return null immediately
16071:     if (mCodepointsWithNoFonts.test(aCh)) {
16071:         return nsnull;
16071:     }
16071: 
16071:     // the following is not very clever but it's a quick fix to search all fonts
16071:     // (one should instead cache the charmaps as done on Mac and Win)
16071: 
16071:     // just continue to append all fonts known to the system
23904:     nsTArray<nsString> fontList;
16071:     nsCAutoString generic;
16071:     nsresult rv = GetFontList(aFont->GetStyle()->langGroup, generic, fontList);
16071:     if (NS_SUCCEEDED(rv)) {
16071:         // start at 3 to skip over the generic entries
23904:         for (PRUint32 i = 3; i < fontList.Length(); i++) {
16071: #ifdef DEBUG_thebes
16071:             printf("searching in entry i=%d (%s)\n",
23904:                    i, NS_LossyConvertUTF16toASCII(fontList[i]).get());
16071: #endif
16071:             nsRefPtr<gfxOS2Font> font =
23904:                 gfxOS2Font::GetOrMakeFont(fontList[i], aFont->GetStyle());
16071:             if (!font)
16071:                 continue;
16071:             FT_Face face = cairo_ft_scaled_font_lock_face(font->CairoScaledFont());
16071:             if (!face || !face->charmap) {
16071:                 if (face)
16071:                     cairo_ft_scaled_font_unlock_face(font->CairoScaledFont());
16071:                 continue;
16071:             }
16071: 
16071:             FT_UInt gid = FT_Get_Char_Index(face, aCh); // find the glyph id
16071:             if (gid != 0) {
16071:                 // this is the font
16071:                 cairo_ft_scaled_font_unlock_face(font->CairoScaledFont());
16071:                 return font.forget();
16071:             }
16071:         }
16071:     }
16071: 
16071:     // no match found, so add to the set of non-matching codepoints
16071:     mCodepointsWithNoFonts.set(aCh);
16071:     return nsnull;
16071: }
32950: 
32950: void
32950: gfxOS2Platform::InitDisplayCaps()
32950: {
32950:     // create DC compatible with the screen
32950:     HDC dc = DevOpenDC((HAB)1, OD_MEMORY,"*",0L, NULL, NULLHANDLE);
32950:     if (dc > 0) {
32950:         // we do have a DC and we can query the DPI setting from it
32950:         LONG lDPI;
32950:         if (DevQueryCaps(dc, CAPS_VERTICAL_FONT_RES, 1, &lDPI))
32950:             gfxPlatform::sDPI = lDPI;
32950:         DevCloseDC(dc);
32950:     }
32950: 
32950:     if (gfxPlatform::sDPI <= 0) {
32950:         // Fall back to something sane
32950:         gfxPlatform::sDPI = 96;
32950:     }
32950: }
