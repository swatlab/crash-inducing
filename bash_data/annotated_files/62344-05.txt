    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for all element classes; this provides an implementation
    1:  * of DOM Core's nsIDOMElement, implements nsIContent, provides
    1:  * utility methods for subclasses, and so forth.
    1:  */
    1: 
    1: #ifndef nsGenericElement_h___
    1: #define nsGenericElement_h___
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
41930: #include "mozilla/dom/Element.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocumentFragment.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsIDOM3Node.h"
    1: #include "nsIDOMNSEventTarget.h"
    1: #include "nsIDOMNSElement.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsContentUtils.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsAttrAndChildArray.h"
    1: #include "mozFlushType.h"
    1: #include "nsDOMAttributeMap.h"
    1: #include "nsIWeakReference.h"
    1: #include "nsCycleCollectionParticipant.h"
13098: #include "nsIDocument.h"
16106: #include "nsIDOMNodeSelector.h"
29215: #include "nsIDOMXPathNSResolver.h"
41910: #include "nsPresContext.h"
    1: 
23697: #ifdef MOZ_SMIL
23697: #include "nsISMILAttr.h"
23697: #endif // MOZ_SMIL
23697: 
    1: class nsIDOMAttr;
    1: class nsIDOMEventListener;
    1: class nsIFrame;
    1: class nsIDOMNamedNodeMap;
47641: class nsICSSDeclaration;
    1: class nsIDOMCSSStyleDeclaration;
    1: class nsIURI;
    1: class nsINodeInfo;
    1: class nsIControllers;
    1: class nsIDOMNSFeatureFactory;
    1: class nsIEventListenerManager;
37060: class nsIScrollableFrame;
17074: class nsContentList;
31383: class nsDOMTokenList;
16722: struct nsRect;
    1: 
27256: typedef PRUptrdiff PtrBits;
    1: 
    1: /**
    1:  * Class that implements the nsIDOMNodeList interface (a list of children of
    1:  * the content), by holding a reference to the content and delegating GetLength
    1:  * and Item to its existing child list.
    1:  * @see nsIDOMNodeList
    1:  */
21618: class nsChildContentList : public nsINodeList,
21618:                            public nsWrapperCache
    1: {
    1: public:
    1:   nsChildContentList(nsINode* aNode)
    1:     : mNode(aNode)
    1:   {
    1:   }
20752: 
20752:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIDOMNodeList interface
20752:   NS_DECL_NSIDOMNODELIST
19130: 
19130:   // nsINodeList interface
24403:   virtual nsIContent* GetNodeAt(PRUint32 aIndex);
24403:   virtual PRInt32 IndexOf(nsIContent* aContent);
    1: 
    1:   void DropReference()
    1:   {
    1:     mNode = nsnull;
    1:   }
    1: 
33481:   nsINode* GetParentObject()
21618:   {
21618:     return mNode;
21618:   }
21618: 
21618:   static nsChildContentList* FromSupports(nsISupports* aSupports)
21618:   {
21618:     nsINodeList* list = static_cast<nsINodeList*>(aSupports);
21618: #ifdef DEBUG
21618:     {
21618:       nsCOMPtr<nsINodeList> list_qi = do_QueryInterface(aSupports);
21618: 
21618:       // If this assertion fires the QI implementation for the object in
21618:       // question doesn't use the nsINodeList pointer as the nsISupports
21618:       // pointer. That must be fixed, or we'll crash...
21618:       NS_ASSERTION(list_qi == list, "Uh, fix QI!");
21618:     }
21618: #endif
21618:     return static_cast<nsChildContentList*>(list);
21618:   }
21618: 
    1: private:
    1:   // The node whose children make up the list (weak reference)
    1:   nsINode* mNode;
    1: };
    1: 
    1: /**
    1:  * A tearoff class for nsGenericElement to implement additional interfaces
    1:  */
29215: class nsNode3Tearoff : public nsIDOM3Node, public nsIDOMXPathNSResolver
    1: {
    1: public:
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   NS_DECL_NSIDOM3NODE
    1: 
29215:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsNode3Tearoff, nsIDOM3Node)
    1: 
41908:   nsNode3Tearoff(nsINode *aNode) : mNode(aNode)
    1:   {
    1:   }
    1: 
    1: protected:
  731:   virtual ~nsNode3Tearoff() {}
    1: 
    1: private:
41908:   nsCOMPtr<nsINode> mNode;
    1: };
    1: 
    1: /**
    1:  * A class that implements nsIWeakReference
    1:  */
    1: 
    1: class nsNodeWeakReference : public nsIWeakReference
    1: {
    1: public:
    1:   nsNodeWeakReference(nsINode* aNode)
    1:     : mNode(aNode)
    1:   {
    1:   }
    1: 
    1:   ~nsNodeWeakReference();
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIWeakReference
    1:   NS_DECL_NSIWEAKREFERENCE
    1: 
    1:   void NoticeNodeDestruction()
    1:   {
    1:     mNode = nsnull;
    1:   }
    1: 
    1: private:
    1:   nsINode* mNode;
    1: };
    1: 
    1: /**
    1:  * Tearoff to use for nodes to implement nsISupportsWeakReference
    1:  */
    1: class nsNodeSupportsWeakRefTearoff : public nsISupportsWeakReference
    1: {
    1: public:
    1:   nsNodeSupportsWeakRefTearoff(nsINode* aNode)
    1:     : mNode(aNode)
    1:   {
    1:   }
    1: 
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   // nsISupportsWeakReference
    1:   NS_DECL_NSISUPPORTSWEAKREFERENCE
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNodeSupportsWeakRefTearoff)
    1: 
    1: private:
    1:   nsCOMPtr<nsINode> mNode;
    1: };
    1: 
    1: #define NS_EVENT_TEAROFF_CACHE_SIZE 4
    1: 
    1: /**
    1:  * nsDOMEventRTTearoff is a tearoff class used by nsGenericElement and
    1:  * nsGenericDOMDataNode classes for implementing the interfaces
 1475:  * nsIDOMEventTarget, nsIDOM3EventTarget and nsIDOMNSEventTarget.
    1:  *
    1:  * Use the method nsDOMEventRTTearoff::Create() to create one of these babies.
    1:  * @see nsDOMEventRTTearoff::Create
    1:  */
    1: 
 1418: class nsDOMEventRTTearoff : public nsIDOMEventTarget,
    1:                             public nsIDOM3EventTarget,
    1:                             public nsIDOMNSEventTarget
    1: {
    1: private:
    1:   // This class uses a caching scheme so we don't let users of this
    1:   // class create new instances with 'new', in stead the callers
    1:   // should use the static method
    1:   // nsDOMEventRTTearoff::Create(). That's why the constructor and
    1:   // destrucor of this class is private.
    1: 
28073:   nsDOMEventRTTearoff(nsINode *aNode);
    1: 
    1:   static nsDOMEventRTTearoff *mCachedEventTearoff[NS_EVENT_TEAROFF_CACHE_SIZE];
    1:   static PRUint32 mCachedEventTearoffCount;
    1: 
    1:   /**
    1:    * This method gets called by Release() when it's time to delete the
    1:    * this object, in stead of always deleting the object we'll put the
    1:    * object in the cache if unless the cache is already full.
    1:    */
    1:   void LastRelease();
    1: 
    1:   nsresult GetDOM3EventTarget(nsIDOM3EventTarget **aTarget);
    1: 
    1: public:
    1:   virtual ~nsDOMEventRTTearoff();
    1: 
    1:   /**
    1:    * Use this static method to create instances of nsDOMEventRTTearoff.
    1:    * @param aContent the content to create a tearoff for
    1:    */
28073:   static nsDOMEventRTTearoff *Create(nsINode *aNode);
    1: 
    1:   /**
    1:    * Call before shutdown to clear the cache and free memory for this class.
    1:    */
    1:   static void Shutdown();
    1: 
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   // nsIDOMEventTarget
    1:   NS_DECL_NSIDOMEVENTTARGET
    1: 
    1:   // nsIDOM3EventTarget
    1:   NS_DECL_NSIDOM3EVENTTARGET
    1: 
    1:   // nsIDOMNSEventTarget
    1:   NS_DECL_NSIDOMNSEVENTTARGET
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsDOMEventRTTearoff,
    1:                                            nsIDOMEventTarget)
    1: 
    1: private:
    1:   /**
    1:    * Strong reference back to the content object from where an instance of this
    1:    * class was 'torn off'
    1:    */
28073:   nsCOMPtr<nsINode> mNode;
    1: };
    1: 
    1: /**
16106:  * A tearoff class for nsGenericElement to implement NodeSelector
16106:  */
16106: class nsNodeSelectorTearoff : public nsIDOMNodeSelector
16106: {
16106: public:
16106:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
16106: 
16106:   NS_DECL_NSIDOMNODESELECTOR
16106: 
16106:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNodeSelectorTearoff)
16106: 
41909:   nsNodeSelectorTearoff(nsINode *aNode) : mNode(aNode)
16106:   {
16106:   }
16106: 
16106: private:
16106:   ~nsNodeSelectorTearoff() {}
16106: 
16106: private:
41909:   nsCOMPtr<nsINode> mNode;
16106: };
16106: 
17074: // Forward declare to allow being a friend
17074: class nsNSElementTearoff;
17074: 
    1: /**
    1:  * A generic base class for DOM elements, implementing many nsIContent,
    1:  * nsIDOMNode and nsIDOMElement methods.
    1:  */
41632: class nsGenericElement : public mozilla::dom::Element
    1: {
    1: public:
48124:   nsGenericElement(already_AddRefed<nsINodeInfo> aNodeInfo);
    1:   virtual ~nsGenericElement();
    1: 
16722:   friend class nsNSElementTearoff;
16722: 
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   /**
    1:    * Called during QueryInterface to give the binding manager a chance to
    1:    * get an interface for this element.
    1:    */
    1:   nsresult PostQueryInterface(REFNSIID aIID, void** aInstancePtr);
    1: 
    1:   // nsINode interface methods
    1:   virtual PRUint32 GetChildCount() const;
    1:   virtual nsIContent *GetChildAt(PRUint32 aIndex) const;
22251:   virtual nsIContent * const * GetChildArray(PRUint32* aChildCount) const;
    1:   virtual PRInt32 IndexOf(nsINode* aPossibleChild) const;
    1:   virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                                  PRBool aNotify);
29805:   virtual nsresult RemoveChildAt(PRUint32 aIndex, PRBool aNotify, PRBool aMutationEvent = PR_TRUE);
    1:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
    1:   virtual nsresult PostHandleEvent(nsEventChainPostVisitor& aVisitor);
    1:   virtual nsresult DispatchDOMEvent(nsEvent* aEvent, nsIDOMEvent* aDOMEvent,
    1:                                     nsPresContext* aPresContext,
    1:                                     nsEventStatus* aEventStatus);
29474:   virtual nsIEventListenerManager* GetListenerManager(PRBool aCreateIfNotFound);
 1418:   virtual nsresult AddEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                          const nsIID& aIID);
 1418:   virtual nsresult RemoveEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                             const nsIID& aIID);
 1418:   virtual nsresult GetSystemEventGroup(nsIDOMEventGroup** aGroup);
27700:   virtual nsIScriptContext* GetContextForEventHandlers(nsresult* aRv)
16056:   {
27700:     return nsContentUtils::GetContextForEventHandlers(this, aRv);
16056:   }
41907:   virtual void GetTextContent(nsAString &aTextContent)
41907:   {
41907:     nsContentUtils::GetNodeTextContent(this, PR_TRUE, aTextContent);
41907:   }
41907:   virtual nsresult SetTextContent(const nsAString& aTextContent)
41907:   {
41907:     // Batch possible DOMSubtreeModified events.
41907:     mozAutoSubtreeModified subtree(GetOwnerDoc(), nsnull);
41907:     return nsContentUtils::SetNodeTextContent(this, aTextContent, PR_FALSE);
41907:   }
    1: 
    1:   // nsIContent interface methods
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers);
    1:   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
    1:                               PRBool aNullParent = PR_TRUE);
55877:   virtual already_AddRefed<nsINodeList> GetChildren(PRUint32 aFilter);
    1:   virtual nsIAtom *GetClassAttributeName() const;
    1:   virtual already_AddRefed<nsINodeInfo> GetExistingAttrNameFromQName(const nsAString& aStr) const;
    1:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                    const nsAString& aValue, PRBool aNotify)
    1:   {
    1:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
    1:   }
61740:   /**
61740:    * Helper for SetAttr/SetParsedAttr. This method will return true if aNotify
61740:    * is true or there are mutation listeners that must be triggered, the
61740:    * attribute is currently set, and the new value that is about to be set is
61740:    * different to the current value. As a perf optimization the new and old
61740:    * values will not actually be compared if we aren't notifying and we don't
61740:    * have mutation listeners (in which case it's cheap to just return PR_FALSE
61740:    * and let the caller go ahead and set the value).
61740:    * @param aOldValue Set to the old value of the attribute, but only if there
61740:    *   are event listeners
61740:    * @param aModType Set to nsIDOMMutationEvent::MODIFICATION or to
61740:    *   nsIDOMMutationEvent::ADDITION, but only if this helper returns true
61740:    * @param aHasListeners Set to true if there are mutation event listeners
61740:    *   listening for NS_EVENT_BITS_MUTATION_ATTRMODIFIED
61740:    */
61740:   PRBool MaybeCheckSameAttrVal(PRInt32 aNamespaceID, nsIAtom* aName,
61740:                                nsIAtom* aPrefix, const nsAString& aValue,
61740:                                PRBool aNotify, nsAutoString* aOldValue,
61740:                                PRUint8* aModType, PRBool* aHasListeners);
    1:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName, nsIAtom* aPrefix,
    1:                            const nsAString& aValue, PRBool aNotify);
61740:   virtual nsresult SetParsedAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
61740:                                  nsIAtom* aPrefix, nsAttrValue& aParsedValue,
61740:                                  PRBool aNotify);
    1:   virtual PRBool GetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                          nsAString& aResult) const;
    1:   virtual PRBool HasAttr(PRInt32 aNameSpaceID, nsIAtom* aName) const;
    1:   virtual PRBool AttrValueIs(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                              const nsAString& aValue,
    1:                              nsCaseTreatment aCaseSensitive) const;
    1:   virtual PRBool AttrValueIs(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                              nsIAtom* aValue,
    1:                              nsCaseTreatment aCaseSensitive) const;
    1:   virtual PRInt32 FindAttrValueIn(PRInt32 aNameSpaceID,
    1:                                   nsIAtom* aName,
    1:                                   AttrValuesArray* aValues,
    1:                                   nsCaseTreatment aCaseSensitive) const;
    1:   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
    1:                              PRBool aNotify);
    1:   virtual const nsAttrName* GetAttrNameAt(PRUint32 aIndex) const;
    1:   virtual PRUint32 GetAttrCount() const;
    1:   virtual const nsTextFragment *GetText();
    1:   virtual PRUint32 TextLength();
    1:   virtual nsresult SetText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                            PRBool aNotify);
    1:   // Need to implement this here too to avoid hiding.
    1:   nsresult SetText(const nsAString& aStr, PRBool aNotify)
    1:   {
    1:     return SetText(aStr.BeginReading(), aStr.Length(), aNotify);
    1:   }
    1:   virtual nsresult AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                               PRBool aNotify);
    1:   virtual PRBool TextIsOnlyWhitespace();
    1:   virtual void AppendTextTo(nsAString& aResult);
    1:   virtual nsIContent *GetBindingParent() const;
    1:   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
    1:   virtual PRBool IsLink(nsIURI** aURI) const;
    1: 
    1:   virtual PRUint32 GetScriptTypeID() const;
28073:   NS_IMETHOD SetScriptTypeID(PRUint32 aLang);
    1: 
 8462:   virtual void DestroyContent();
14188:   virtual void SaveSubtreeState();
14188: 
23697: #ifdef MOZ_SMIL
55139:   virtual nsISMILAttr* GetAnimatedAttr(PRInt32 /*aNamespaceID*/, nsIAtom* /*aName*/)
23697:   {
23697:     return nsnull;
23697:   }
32193:   virtual nsresult GetSMILOverrideStyle(nsIDOMCSSStyleDeclaration** aStyle);
32193:   virtual nsICSSStyleRule* GetSMILOverrideStyleRule();
32193:   virtual nsresult SetSMILOverrideStyleRule(nsICSSStyleRule* aStyleRule,
32193:                                             PRBool aNotify);
23697: #endif // MOZ_SMIL
23697: 
    1: #ifdef DEBUG
    1:   virtual void List(FILE* out, PRInt32 aIndent) const
    1:   {
    1:     List(out, aIndent, EmptyCString());
    1:   }
    1:   virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
    1:   void List(FILE* out, PRInt32 aIndent, const nsCString& aPrefix) const;
    1:   void ListAttributes(FILE* out) const;
    1: #endif
    1: 
19132:   virtual const nsAttrValue* DoGetClasses() const;
    1:   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
    1:   virtual nsICSSStyleRule* GetInlineStyleRule();
    1:   NS_IMETHOD SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify);
    1:   NS_IMETHOD_(PRBool)
    1:     IsAttributeMapped(const nsIAtom* aAttribute) const;
    1:   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                               PRInt32 aModType) const;
    1:   /*
    1:    * Attribute Mapping Helpers
    1:    */
    1:   struct MappedAttributeEntry {
    1:     nsIAtom** attribute;
    1:   };
    1: 
    1:   /**
    1:    * A common method where you can just pass in a list of maps to check
    1:    * for attribute dependence. Most implementations of
    1:    * IsAttributeMapped should use this function as a default
    1:    * handler.
    1:    */
    1:   static PRBool
    1:   FindAttributeDependence(const nsIAtom* aAttribute,
    1:                           const MappedAttributeEntry* const aMaps[],
    1:                           PRUint32 aMapCount);
    1: 
    1:   // nsIDOMNode method implementation
    1:   NS_IMETHOD GetNodeName(nsAString& aNodeName);
    1:   NS_IMETHOD GetLocalName(nsAString& aLocalName);
    1:   NS_IMETHOD GetNodeValue(nsAString& aNodeValue);
    1:   NS_IMETHOD SetNodeValue(const nsAString& aNodeValue);
    1:   NS_IMETHOD GetNodeType(PRUint16* aNodeType);
    1:   NS_IMETHOD GetAttributes(nsIDOMNamedNodeMap** aAttributes);
    1:   NS_IMETHOD GetNamespaceURI(nsAString& aNamespaceURI);
    1:   NS_IMETHOD GetPrefix(nsAString& aPrefix);
    1:   NS_IMETHOD SetPrefix(const nsAString& aPrefix);
    1:   NS_IMETHOD Normalize();
    1:   NS_IMETHOD IsSupported(const nsAString& aFeature,
    1:                          const nsAString& aVersion, PRBool* aReturn);
    1:   NS_IMETHOD HasAttributes(PRBool* aHasAttributes);
    1:   NS_IMETHOD HasChildNodes(PRBool* aHasChildNodes);
39585:   nsresult InsertBefore(nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,
39585:                         nsIDOMNode** aReturn)
39585:   {
39585:     return ReplaceOrInsertBefore(PR_FALSE, aNewChild, aRefChild, aReturn);
39585:   }
39585:   nsresult ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
39585:                         nsIDOMNode** aReturn)
39585:   {
39585:     return ReplaceOrInsertBefore(PR_TRUE, aNewChild, aOldChild, aReturn);
39585:   }
39585:   nsresult RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
39585:   {
39585:     return nsINode::RemoveChild(aOldChild, aReturn);
39585:   }
39585:   nsresult AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
    1:   {
    1:     return InsertBefore(aNewChild, nsnull, aReturn);
    1:   }
    1: 
    1:   // nsIDOMElement method implementation
    1:   NS_IMETHOD GetTagName(nsAString& aTagName);
    1:   NS_IMETHOD GetAttribute(const nsAString& aName,
    1:                           nsAString& aReturn);
    1:   NS_IMETHOD SetAttribute(const nsAString& aName,
    1:                           const nsAString& aValue);
    1:   NS_IMETHOD RemoveAttribute(const nsAString& aName);
    1:   NS_IMETHOD GetAttributeNode(const nsAString& aName,
    1:                               nsIDOMAttr** aReturn);
    1:   NS_IMETHOD SetAttributeNode(nsIDOMAttr* aNewAttr, nsIDOMAttr** aReturn);
    1:   NS_IMETHOD RemoveAttributeNode(nsIDOMAttr* aOldAttr, nsIDOMAttr** aReturn);
    1:   NS_IMETHOD GetElementsByTagName(const nsAString& aTagname,
    1:                                   nsIDOMNodeList** aReturn);
    1:   NS_IMETHOD GetAttributeNS(const nsAString& aNamespaceURI,
    1:                             const nsAString& aLocalName,
    1:                             nsAString& aReturn);
    1:   NS_IMETHOD SetAttributeNS(const nsAString& aNamespaceURI,
    1:                             const nsAString& aQualifiedName,
    1:                             const nsAString& aValue);
    1:   NS_IMETHOD RemoveAttributeNS(const nsAString& aNamespaceURI,
    1:                                const nsAString& aLocalName);
    1:   NS_IMETHOD GetAttributeNodeNS(const nsAString& aNamespaceURI,
    1:                                 const nsAString& aLocalName,
    1:                                 nsIDOMAttr** aReturn);
    1:   NS_IMETHOD SetAttributeNodeNS(nsIDOMAttr* aNewAttr, nsIDOMAttr** aReturn);
    1:   NS_IMETHOD GetElementsByTagNameNS(const nsAString& aNamespaceURI,
    1:                                     const nsAString& aLocalName,
    1:                                     nsIDOMNodeList** aReturn);
    1:   NS_IMETHOD HasAttribute(const nsAString& aName, PRBool* aReturn);
    1:   NS_IMETHOD HasAttributeNS(const nsAString& aNamespaceURI,
    1:                             const nsAString& aLocalName,
    1:                             PRBool* aReturn);
    1:   nsresult CloneNode(PRBool aDeep, nsIDOMNode **aResult)
    1:   {
58904:     return nsNodeUtils::CloneNodeImpl(this, aDeep, PR_TRUE, aResult);
    1:   }
    1: 
    1:   //----------------------------------------
    1: 
    1:   /**
    1:    * Add a script event listener with the given event handler name
    1:    * (like onclick) and with the value as JS
    1:    * @param aEventName the event listener name
    1:    * @param aValue the JS to attach
    1:    * @param aDefer indicates if deferred execution is allowed
    1:    */
    1:   nsresult AddScriptEventListener(nsIAtom* aEventName,
    1:                                   const nsAString& aValue,
    1:                                   PRBool aDefer = PR_TRUE);
    1: 
    1:   /**
    1:    * Do whatever needs to be done when the mouse leaves a link
    1:    */
    1:   nsresult LeaveLink(nsPresContext* aPresContext);
    1: 
    1:   /**
    1:    * Take two text nodes and append the second to the first.
    1:    * @param aFirst the node which will contain first + second [INOUT]
    1:    * @param aSecond the node which will be appended
    1:    */
    1:   nsresult JoinTextNodes(nsIContent* aFirst,
    1:                          nsIContent* aSecond);
    1: 
    1:   /**
    1:    * Check whether a spec feature/version is supported.
    1:    * @param aObject the object, which should support the feature,
    1:    *        for example nsIDOMNode or nsIDOMDOMImplementation
    1:    * @param aFeature the feature ("Views", "Core", "HTML", "Range" ...)
    1:    * @param aVersion the version ("1.0", "2.0", ...)
    1:    * @param aReturn whether the feature is supported or not [OUT]
    1:    */
    1:   static nsresult InternalIsSupported(nsISupports* aObject,
    1:                                       const nsAString& aFeature,
    1:                                       const nsAString& aVersion,
    1:                                       PRBool* aReturn);
    1: 
    1:   static PRBool ShouldBlur(nsIContent *aContent);
    1: 
    1:   /**
41627:    * If there are listeners for DOMNodeInserted event, fires the event on all
41627:    * aNodes
41627:    */
41627:   static void FireNodeInserted(nsIDocument* aDoc,
41627:                                nsINode* aParent,
41627:                                nsCOMArray<nsIContent>& aNodes);
41627: 
41627:   /**
16106:    * Helper methods for implementing querySelector/querySelectorAll
16106:    */
41909:   static nsIContent* doQuerySelector(nsINode* aRoot, const nsAString& aSelector,
41909:                                      nsresult *aResult NS_OUTPARAM);
16106:   static nsresult doQuerySelectorAll(nsINode* aRoot,
16106:                                      const nsAString& aSelector,
16106:                                      nsIDOMNodeList **aReturn);
16106: 
16106:   /**
    1:    * Default event prehandling for content objects. Handles event retargeting.
    1:    */
    1:   static nsresult doPreHandleEvent(nsIContent* aContent,
    1:                                    nsEventChainPreVisitor& aVisitor);
    1: 
    1:   /**
    1:    * Method to create and dispatch a left-click event loosely based on
    1:    * aSourceEvent. If aFullDispatch is true, the event will be dispatched
    1:    * through the full dispatching of the presshell of the aPresContext; if it's
    1:    * false the event will be dispatched only as a DOM event.
    1:    * If aPresContext is nsnull, this does nothing.
    1:    */
    1:   static nsresult DispatchClickEvent(nsPresContext* aPresContext,
    1:                                      nsInputEvent* aSourceEvent,
    1:                                      nsIContent* aTarget,
    1:                                      PRBool aFullDispatch,
    1:                                      nsEventStatus* aStatus);
    1: 
    1:   /**
    1:    * Method to dispatch aEvent to aTarget. If aFullDispatch is true, the event
    1:    * will be dispatched through the full dispatching of the presshell of the
    1:    * aPresContext; if it's false the event will be dispatched only as a DOM
    1:    * event.
    1:    * If aPresContext is nsnull, this does nothing.
    1:    */
    1:   static nsresult DispatchEvent(nsPresContext* aPresContext,
    1:                                 nsEvent* aEvent,
    1:                                 nsIContent* aTarget,
    1:                                 PRBool aFullDispatch,
    1:                                 nsEventStatus* aStatus);
    1: 
    1:   /**
36655:    * Get the primary frame for this content with flushing
    1:    *
    1:    * @param aType the kind of flush to do, typically Flush_Frames or
    1:    *              Flush_Layout
    1:    * @return the primary frame
    1:    */
    1:   nsIFrame* GetPrimaryFrame(mozFlushType aType);
36655:   // Work around silly C++ name hiding stuff
36655:   nsIFrame* GetPrimaryFrame() const { return nsIContent::GetPrimaryFrame(); }
    1: 
    1:   /**
    1:    * Struct that stores info on an attribute.  The name and value must
    1:    * either both be null or both be non-null.
    1:    */
    1:   struct nsAttrInfo {
    1:     nsAttrInfo(const nsAttrName* aName, const nsAttrValue* aValue) :
    1:       mName(aName), mValue(aValue) {}
    1:     nsAttrInfo(const nsAttrInfo& aOther) :
    1:       mName(aOther.mName), mValue(aOther.mValue) {}
    1: 
    1:     const nsAttrName* mName;
    1:     const nsAttrValue* mValue;
    1:   };
    1: 
43573:   // Be careful when using this method. This does *NOT* handle
43573:   // XUL prototypes. You may want to use GetAttrInfo.
31383:   const nsAttrValue* GetParsedAttr(nsIAtom* aAttr) const
31383:   {
31383:     return mAttrsAndChildren.GetAttr(aAttr);
31383:   }
31383: 
    1:   /**
    1:    * Returns the attribute map, if there is one.
    1:    *
    1:    * @return existing attribute map or nsnull.
    1:    */
    1:   nsDOMAttributeMap *GetAttributeMap()
    1:   {
    1:     nsDOMSlots *slots = GetExistingDOMSlots();
    1: 
    1:     return slots ? slots->mAttributeMap.get() : nsnull;
    1:   }
    1: 
    1:   virtual void RecompileScriptEventListeners()
    1:   {
    1:   }
    1: 
41910:   // nsIDOMNSElement methods
41910:   nsresult GetElementsByClassName(const nsAString& aClasses,
41910:                                   nsIDOMNodeList** aReturn)
41910:   {
41910:     return nsContentUtils::GetElementsByClassName(this, aClasses, aReturn);
41910:   }
41910:   nsresult GetClientRects(nsIDOMClientRectList** aResult);
41910:   nsresult GetBoundingClientRect(nsIDOMClientRect** aResult);
41910:   PRInt32 GetScrollTop();
41910:   void SetScrollTop(PRInt32 aScrollTop);
41910:   PRInt32 GetScrollLeft();
41910:   void SetScrollLeft(PRInt32 aScrollLeft);
41910:   PRInt32 GetScrollHeight();
41910:   PRInt32 GetScrollWidth();
41910:   PRInt32 GetClientTop()
41910:   {
41910:     return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().y);
41910:   }
41910:   PRInt32 GetClientLeft()
41910:   {
41910:     return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().x);
41910:   }
41910:   PRInt32 GetClientHeight()
41910:   {
41910:     return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().height);
41910:   }
41910:   PRInt32 GetClientWidth()
41910:   {
41910:     return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().width);
41910:   }
41910:   nsIContent* GetFirstElementChild();
41910:   nsIContent* GetLastElementChild();
41910:   nsIContent* GetPreviousElementSibling();
41910:   nsIContent* GetNextElementSibling();
41910:   nsresult GetChildElementCount(PRUint32* aResult)
41910:   {
41910:     nsContentList* list = GetChildrenList();
41910:     if (!list) {
41910:       *aResult = 0;
41910: 
41910:       return NS_ERROR_OUT_OF_MEMORY;
41910:     }
41910: 
41910:     *aResult = list->Length(PR_TRUE);
41910: 
41910:     return NS_OK;
41910:   }
41910:   nsresult GetChildren(nsIDOMNodeList** aResult)
41910:   {
41910:     nsContentList* list = GetChildrenList();
41910:     if (!list) {
41910:       *aResult = nsnull;
41910: 
41910:       return NS_ERROR_OUT_OF_MEMORY;
41910:     }
41910: 
41910:     NS_ADDREF(*aResult = list);
41910: 
41910:     return NS_OK;
41910:   }
41910:   nsIDOMDOMTokenList* GetClassList(nsresult *aResult);
46968:   void SetCapture(PRBool aRetargetToElement);
46968:   void ReleaseCapture();
56306:   PRBool MozMatchesSelector(const nsAString& aSelector, nsresult* aResult);
41910: 
43572:   /**
43572:    * Get the attr info for the given namespace ID and attribute name.  The
43572:    * namespace ID must not be kNameSpaceID_Unknown and the name must not be
43572:    * null.  Note that this can only return info on attributes that actually
43572:    * live on this element (and is only virtual to handle XUL prototypes).  That
43572:    * is, this should only be called from methods that only care about attrs
43572:    * that effectively live in mAttrsAndChildren.
43572:    */
43572:   virtual nsAttrInfo GetAttrInfo(PRInt32 aNamespaceID, nsIAtom* aName) const;
43572: 
30001:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(nsGenericElement)
    1: 
51858:   virtual void NodeInfoChanged(nsINodeInfo* aOldNodeInfo)
51858:   {
51858:   }
51858: 
    1: protected:
    1:   /**
    1:    * Set attribute and (if needed) notify documentobservers and fire off
38453:    * mutation events.  This will send the AttributeChanged notification.
38453:    * Callers of this method are responsible for calling AttributeWillChange,
38453:    * since that needs to happen before the new attr value has been set, and
38453:    * in particular before it has been parsed.
    1:    *
    1:    * @param aNamespaceID  namespace of attribute
    1:    * @param aAttribute    local-name of attribute
    1:    * @param aPrefix       aPrefix of attribute
    1:    * @param aOldValue     previous value of attribute. Only needed if
    1:    *                      aFireMutation is true.
    1:    * @param aParsedValue  parsed new value of attribute
38453:    * @param aModType      nsIDOMMutationEvent::MODIFICATION or ADDITION.  Only
    1:    *                      needed if aFireMutation or aNotify is true.
    1:    * @param aFireMutation should mutation-events be fired?
    1:    * @param aNotify       should we notify document-observers?
22222:    * @param aValueForAfterSetAttr If not null, AfterSetAttr will be called
22222:    *                      with the value pointed by this parameter.
    1:    */
    1:   nsresult SetAttrAndNotify(PRInt32 aNamespaceID,
    1:                             nsIAtom* aName,
    1:                             nsIAtom* aPrefix,
    1:                             const nsAString& aOldValue,
    1:                             nsAttrValue& aParsedValue,
38453:                             PRUint8 aModType,
    1:                             PRBool aFireMutation,
22222:                             PRBool aNotify,
22222:                             const nsAString* aValueForAfterSetAttr);
    1: 
    1:   /**
    1:    * Convert an attribute string value to attribute type based on the type of
    1:    * attribute.  Called by SetAttr().  Note that at the moment we only do this
    1:    * for attributes in the null namespace (kNameSpaceID_None).
    1:    *
    1:    * @param aNamespaceID the namespace of the attribute to convert
    1:    * @param aAttribute the attribute to convert
    1:    * @param aValue the string value to convert
    1:    * @param aResult the nsAttrValue [OUT]
    1:    * @return PR_TRUE if the parsing was successful, PR_FALSE otherwise
    1:    */
    1:   virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
    1:                                 nsIAtom* aAttribute,
    1:                                 const nsAString& aValue,
    1:                                 nsAttrValue& aResult);
    1: 
    1:   /**
    1:    * Try to set the attribute as a mapped attribute, if applicable.  This will
    1:    * only be called for attributes that are in the null namespace and only on
    1:    * attributes that returned true when passed to IsAttributeMapped.  The
    1:    * caller will not try to set the attr in any other way if this method
    1:    * returns PR_TRUE (the value of aRetval does not matter for that purpose).
    1:    *
    1:    * @param aDocument the current document of this node (an optimization)
    1:    * @param aName the name of the attribute
    1:    * @param aValue the nsAttrValue to set
    1:    * @param [out] aRetval the nsresult status of the operation, if any.
    1:    * @return PR_TRUE if the setting was attempted, PR_FALSE otherwise.
    1:    */
    1:   virtual PRBool SetMappedAttribute(nsIDocument* aDocument,
    1:                                     nsIAtom* aName,
    1:                                     nsAttrValue& aValue,
    1:                                     nsresult* aRetval);
    1: 
    1:   /**
    1:    * Hook that is called by nsGenericElement::SetAttr to allow subclasses to
    1:    * deal with attribute sets.  This will only be called after we verify that
38453:    * we're actually doing an attr set and will be called before
38453:    * AttributeWillChange and before ParseAttribute and hence before we've set
38453:    * the new value.
    1:    *
    1:    * @param aNamespaceID the namespace of the attr being set
    1:    * @param aName the localname of the attribute being set
    1:    * @param aValue the value it's being set to.  If null, the attr is being
    1:    *        removed.
    1:    * @param aNotify Whether we plan to notify document observers.
    1:    */
    1:   // Note that this is inlined so that when subclasses call it it gets
    1:   // inlined.  Those calls don't go through a vtable.
    1:   virtual nsresult BeforeSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                                  const nsAString* aValue, PRBool aNotify)
    1:   {
    1:     return NS_OK;
    1:   }
    1: 
    1:   /**
    1:    * Hook that is called by nsGenericElement::SetAttr to allow subclasses to
    1:    * deal with attribute sets.  This will only be called after we have called
38453:    * SetAndTakeAttr and AttributeChanged (that is, after we have actually set
38453:    * the attr).
    1:    *
    1:    * @param aNamespaceID the namespace of the attr being set
    1:    * @param aName the localname of the attribute being set
    1:    * @param aValue the value it's being set to.  If null, the attr is being
    1:    *        removed.
    1:    * @param aNotify Whether we plan to notify document observers.
    1:    */
    1:   // Note that this is inlined so that when subclasses call it it gets
    1:   // inlined.  Those calls don't go through a vtable.
    1:   virtual nsresult AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                                 const nsAString* aValue, PRBool aNotify)
    1:   {
    1:     return NS_OK;
    1:   }
    1: 
    1:   /**
    1:    * Hook to allow subclasses to produce a different nsIEventListenerManager if
    1:    * needed for attachment of attribute-defined handlers
    1:    */
    1:   virtual nsresult
    1:     GetEventListenerManagerForAttr(nsIEventListenerManager** aManager,
    1:                                    nsISupports** aTarget,
    1:                                    PRBool* aDefer);
    1: 
    1:   /**
    1:    * Copy attributes and state to another element
    1:    * @param aDest the object to copy to
    1:    */
    1:   nsresult CopyInnerTo(nsGenericElement* aDest) const;
    1: 
    1:   /**
    1:    * Internal hook for converting an attribute name-string to an atomized name
    1:    */
    1:   virtual const nsAttrName* InternalGetExistingAttrNameFromQName(const nsAString& aStr) const;
    1: 
16722:   /**
16722:    * Retrieve the rectangle for the offsetX properties, which
16722:    * are coordinates relative to the returned aOffsetParent.
16722:    *
16722:    * @param aRect offset rectangle
16722:    * @param aOffsetParent offset parent
16722:    */
16722:   virtual void GetOffsetRect(nsRect& aRect, nsIContent** aOffsetParent);
16722: 
16722:   nsIFrame* GetStyledFrame();
16722: 
41904:   virtual mozilla::dom::Element* GetNameSpaceElement()
41904:   {
41904:     return this;
41904:   }
41904: 
    1: public:
    1:   // Because of a bug in MS C++ compiler nsDOMSlots must be declared public,
    1:   // otherwise nsXULElement::nsXULSlots doesn't compile.
    1:   /**
    1:    * There are a set of DOM- and scripting-specific instance variables
    1:    * that may only be instantiated when a content object is accessed
    1:    * through the DOM. Rather than burn actual slots in the content
    1:    * objects for each of these instance variables, we put them off
    1:    * in a side structure that's only allocated when the content is
    1:    * accessed through the DOM.
    1:    */
    1:   class nsDOMSlots : public nsINode::nsSlots
    1:   {
    1:   public:
    1:     nsDOMSlots(PtrBits aFlags);
    1:     virtual ~nsDOMSlots();
    1: 
    1:     /**
    1:      * The .style attribute (an interface that forwards to the actual
    1:      * style rules)
    1:      * @see nsGenericHTMLElement::GetStyle */
47641:     nsCOMPtr<nsICSSDeclaration> mStyle;
    1: 
    1:     /**
32193:      * SMIL Overridde style rules (for SMIL animation of CSS properties)
32193:      * @see nsIContent::GetSMILOverrideStyle
32193:      */
47641:     nsCOMPtr<nsICSSDeclaration> mSMILOverrideStyle;
32193: 
32193:     /**
32193:      * Holds any SMIL override style rules for this element.
32193:      */
32193:     nsCOMPtr<nsICSSStyleRule> mSMILOverrideStyleRule;
32193: 
32193:     /**
    1:      * An object implementing nsIDOMNamedNodeMap for this content (attributes)
    1:      * @see nsGenericElement::GetAttributes
    1:      */
    1:     nsRefPtr<nsDOMAttributeMap> mAttributeMap;
    1: 
    1:     union {
    1:       /**
    1:       * The nearest enclosing content node with a binding that created us.
    1:       * @see nsGenericElement::GetBindingParent
    1:       */
    1:       nsIContent* mBindingParent;  // [Weak]
    1: 
    1:       /**
    1:       * The controllers of the XUL Element.
    1:       */
    1:       nsIControllers* mControllers; // [OWNER]
    1:     };
    1: 
    1:     /**
17074:      * An object implementing the .children property for this element.
17074:      */
17074:     nsRefPtr<nsContentList> mChildrenList;
31383: 
31383:     /**
31383:      * An object implementing the .classList property for this element.
31383:      */
31383:     nsRefPtr<nsDOMTokenList> mClassList;
    1:   };
    1: 
    1: protected:
    1:   // Override from nsINode
    1:   virtual nsINode::nsSlots* CreateSlots();
    1: 
59659:   nsDOMSlots *DOMSlots()
    1:   {
 3233:     return static_cast<nsDOMSlots*>(GetSlots());
    1:   }
    1: 
    1:   nsDOMSlots *GetExistingDOMSlots() const
    1:   {
 3233:     return static_cast<nsDOMSlots*>(GetExistingSlots());
    1:   }
    1: 
28108:   void RegisterFreezableElement() {
28108:     nsIDocument* doc = GetOwnerDoc();
28108:     if (doc) {
28108:       doc->RegisterFreezableElement(this);
28108:     }
28108:   }
28108:   void UnregisterFreezableElement() {
28108:     nsIDocument* doc = GetOwnerDoc();
28108:     if (doc) {
28108:       doc->UnregisterFreezableElement(this);
28108:     }
28108:   }
28108: 
    1:   /**
43079:    * Add/remove this element to the documents id cache
    1:    */
43079:   void AddToIdTable(nsIAtom* aId) {
43079:     NS_ASSERTION(HasFlag(NODE_HAS_ID), "Node lacking NODE_HAS_ID flag");
43079:     nsIDocument* doc = GetCurrentDoc();
43079:     if (doc && (!IsInAnonymousSubtree() || doc->IsXUL())) {
43079:       doc->AddToIdTable(this, aId);
43079:     }
43079:   }
43079:   void RemoveFromIdTable() {
43079:     if (HasFlag(NODE_HAS_ID)) {
43079:       nsIDocument* doc = GetCurrentDoc();
43079:       if (doc) {
43079:         nsIAtom* id = DoGetID();
43079:         // id can be null during mutation events evilness. Also, XUL elements
43079:         // loose their proto attributes during cc-unlink, so this can happen
43079:         // during cc-unlink too.
43079:         if (id) {
43079:           doc->RemoveFromIdTable(this, DoGetID());
43079:         }
43079:       }
43079:     }
43079:   }
    1: 
    1:   /**
  723:    * Functions to carry out event default actions for links of all types
    1:    * (HTML links, XLinks, SVG "XLinks", etc.)
    1:    */
  723: 
  723:   /**
  723:    * Check that we meet the conditions to handle a link event
  723:    * and that we are actually on a link.
  723:    *
  723:    * @param aVisitor event visitor
  723:    * @param aURI the uri of the link, set only if the return value is PR_TRUE [OUT]
  723:    * @return PR_TRUE if we can handle the link event, PR_FALSE otherwise
  723:    */
  723:   PRBool CheckHandleEventForLinksPrecondition(nsEventChainVisitor& aVisitor,
  723:                                               nsIURI** aURI) const;
  723: 
  723:   /**
  723:    * Handle status bar updates before they can be cancelled.
  723:    */
  723:   nsresult PreHandleEventForLinks(nsEventChainPreVisitor& aVisitor);
  723: 
  723:   /**
  723:    * Handle default actions for link event if the event isn't consumed yet.
  723:    */
    1:   nsresult PostHandleEventForLinks(nsEventChainPostVisitor& aVisitor);
    1: 
    1:   /**
    1:    * Get the target of this link element. Consumers should established that
    1:    * this element is a link (probably using IsLink) before calling this
    1:    * function (or else why call it?)
    1:    *
    1:    * Note: for HTML this gets the value of the 'target' attribute; for XLink
    1:    * this gets the value of the xlink:_moz_target attribute, or failing that,
    1:    * the value of xlink:show, converted to a suitably equivalent named target
    1:    * (e.g. _blank).
    1:    */
    1:   virtual void GetLinkTarget(nsAString& aTarget);
    1: 
    1:   /**
    1:    * Array containing all attributes and children for this element
    1:    */
    1:   nsAttrAndChildArray mAttrsAndChildren;
41910: 
41910: private:
41910:   /**
41910:    * Get this element's client area rect in app units.
41910:    * @return the frame's client area
41910:    */
41910:   nsRect GetClientAreaRect();
41910: 
41910:   nsIScrollableFrame* GetScrollFrame(nsIFrame **aStyledFrame = nsnull);
41910: 
41910:   nsContentList* GetChildrenList();
    1: };
    1: 
    1: /**
    1:  * Macros to implement Clone(). _elementName is the class for which to implement
    1:  * Clone.
    1:  */
    1: #define NS_IMPL_ELEMENT_CLONE(_elementName)                                 \
    1: nsresult                                                                    \
    1: _elementName::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const        \
    1: {                                                                           \
    1:   *aResult = nsnull;                                                        \
48124:   nsCOMPtr<nsINodeInfo> ni = aNodeInfo;                                     \
48124:   _elementName *it = new _elementName(ni.forget());                         \
    1:   if (!it) {                                                                \
    1:     return NS_ERROR_OUT_OF_MEMORY;                                          \
    1:   }                                                                         \
    1:                                                                             \
    1:   nsCOMPtr<nsINode> kungFuDeathGrip = it;                                   \
    1:   nsresult rv = CopyInnerTo(it);                                            \
    1:   if (NS_SUCCEEDED(rv)) {                                                   \
    1:     kungFuDeathGrip.swap(*aResult);                                         \
    1:   }                                                                         \
    1:                                                                             \
    1:   return rv;                                                                \
    1: }
    1: 
    1: #define NS_IMPL_ELEMENT_CLONE_WITH_INIT(_elementName)                       \
    1: nsresult                                                                    \
    1: _elementName::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const        \
    1: {                                                                           \
    1:   *aResult = nsnull;                                                        \
48124:   nsCOMPtr<nsINodeInfo> ni = aNodeInfo;                                     \
48124:   _elementName *it = new _elementName(ni.forget());                         \
    1:   if (!it) {                                                                \
    1:     return NS_ERROR_OUT_OF_MEMORY;                                          \
    1:   }                                                                         \
    1:                                                                             \
    1:   nsCOMPtr<nsINode> kungFuDeathGrip = it;                                   \
    1:   nsresult rv = it->Init();                                                 \
    1:   rv |= CopyInnerTo(it);                                                    \
    1:   if (NS_SUCCEEDED(rv)) {                                                   \
    1:     kungFuDeathGrip.swap(*aResult);                                         \
    1:   }                                                                         \
    1:                                                                             \
    1:   return rv;                                                                \
    1: }
    1: 
48124: #define DOMCI_NODE_DATA(_interface, _class)                             \
48124:   DOMCI_DATA(_interface, _class)                                        \
48124:   nsXPCClassInfo* _class::GetClassInfo()                                \
48124:   {                                                                     \
48124:     return static_cast<nsXPCClassInfo*>(                                \
48124:       NS_GetDOMClassInfoInstance(eDOMClassInfo_##_interface##_id));     \
48124:   }
48124: 
 2014: /**
 2014:  * Yet another tearoff class for nsGenericElement
 2014:  * to implement additional interfaces
 2014:  */
 2014: class nsNSElementTearoff : public nsIDOMNSElement
 2014: {
 2014: public:
 5545:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 2014: 
 2014:   NS_DECL_NSIDOMNSELEMENT
 2014: 
 5545:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNSElementTearoff)
 5545: 
 2014:   nsNSElementTearoff(nsGenericElement *aContent) : mContent(aContent)
 2014:   {
 2014:   }
 2014: 
 2014: private:
 2014:   nsRefPtr<nsGenericElement> mContent;
 2014: };
 2014: 
21218: #define NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE                               \
21218:     rv = nsGenericElement::QueryInterface(aIID, aInstancePtr);                \
21218:     if (NS_SUCCEEDED(rv))                                                     \
21218:       return rv;                                                              \
21218:                                                                               \
21218:     NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: #define NS_ELEMENT_INTERFACE_MAP_END                                          \
21218:     {                                                                         \
21218:       return PostQueryInterface(aIID, aInstancePtr);                          \
21218:     }                                                                         \
21218:                                                                               \
21218:     NS_ADDREF(foundInterface);                                                \
21218:                                                                               \
21218:     *aInstancePtr = foundInterface;                                           \
21218:                                                                               \
21218:     return NS_OK;                                                             \
21218:   }
21218: 
    1: #endif /* nsGenericElement_h___ */
