    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
31590:  * Portions created by the Initial Developer are Copyright (C) 2005-2009
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
16418:  *   John Daggett <jdaggett@mozilla.com>
31590:  *   Jonathan Kew <jfkthame@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
26915: #include "nsIPrefService.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsReadableUtils.h"
  323: #include "nsExpirationTracker.h"
38492: #include "nsILanguageAtomService.h"
    1: 
    1: #include "gfxFont.h"
    1: #include "gfxPlatform.h"
38493: #include "gfxAtoms.h"
    1: 
    1: #include "prtypes.h"
    1: #include "gfxTypes.h"
    1: #include "gfxContext.h"
  132: #include "gfxFontMissingGlyphs.h"
19962: #include "gfxUserFontSet.h"
31590: #include "gfxPlatformFontList.h"
43525: #include "gfxScriptItemizer.h"
43527: #include "gfxUnicodeProperties.h"
 1295: #include "nsMathUtils.h"
19962: #include "nsBidiUtils.h"
37211: #include "nsUnicodeRange.h"
41493: #include "nsCompressedCharMap.h"
    1: 
    1: #include "cairo.h"
    1: #include "gfxFontTest.h"
    1: 
43526: #include "harfbuzz/hb-blob.h"
43526: 
    1: #include "nsCRT.h"
    1: 
47309: using namespace mozilla;
47309: 
  323: gfxFontCache *gfxFontCache::gGlobalCache = nsnull;
  323: 
31590: static PRLogModuleInfo *gFontSelection = PR_NewLogModule("fontSelectionLog");
31590: 
 3011: #ifdef DEBUG_roc
 3011: #define DEBUG_TEXT_RUN_STORAGE_METRICS
 3011: #endif
 3011: 
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005: static PRUint32 gTextRunStorageHighWaterMark = 0;
 3005: static PRUint32 gTextRunStorage = 0;
 6513: static PRUint32 gFontCount = 0;
 6513: static PRUint32 gGlyphExtentsCount = 0;
 6513: static PRUint32 gGlyphExtentsWidthsTotalSize = 0;
 6513: static PRUint32 gGlyphExtentsSetupEagerSimple = 0;
 6513: static PRUint32 gGlyphExtentsSetupEagerTight = 0;
 6513: static PRUint32 gGlyphExtentsSetupLazyTight = 0;
 6513: static PRUint32 gGlyphExtentsSetupFallBackToTight = 0;
 3005: #endif
 3005: 
19962: gfxFontEntry::~gfxFontEntry() 
19962: {
43526:     if (mUserFontData) {
19962:         delete mUserFontData;
16418:     }
47360:     if (mFeatureSettings) {
47360:         delete mFeatureSettings;
47360:     }
43526: }
16418: 
31590: PRBool gfxFontEntry::TestCharacterMap(PRUint32 aCh)
31590: {
31590:     if (!mCmapInitialized) {
31590:         ReadCMAP();
31590:     }
16418:     return mCharacterMap.test(aCh);
16418: }
16418: 
42989: nsresult gfxFontEntry::InitializeUVSMap()
42989: {
42989:     // mUVSOffset will not be initialized
42989:     // until cmap is initialized.
42989:     if (!mCmapInitialized) {
42989:         ReadCMAP();
42989:     }
42989: 
42989:     if (!mUVSOffset) {
42989:         return NS_ERROR_FAILURE;
42989:     }
42989: 
42989:     if (!mUVSData) {
42989:         const PRUint32 kCmapTag = TRUETYPE_TAG('c','m','a','p');
42989:         nsAutoTArray<PRUint8,16384> buffer;
42989:         if (GetFontTable(kCmapTag, buffer) != NS_OK) {
42989:             mUVSOffset = 0; // don't bother to read the table again
42989:             return NS_ERROR_FAILURE;
42989:         }
42989: 
42989:         PRUint8* uvsData;
42989:         nsresult rv = gfxFontUtils::ReadCMAPTableFormat14(
42989:                           buffer.Elements() + mUVSOffset,
42989:                           buffer.Length() - mUVSOffset,
42989:                           uvsData);
42989:         if (NS_FAILED(rv)) {
42989:             mUVSOffset = 0; // don't bother to read the table again
42989:             return rv;
42989:         }
42989: 
42989:         mUVSData = uvsData;
42989:     }
42989: 
42989:     return NS_OK;
42989: }
42989: 
42989: PRUint16 gfxFontEntry::GetUVSGlyph(PRUint32 aCh, PRUint32 aVS)
42989: {
42989:     InitializeUVSMap();
42989: 
42989:     if (mUVSData) {
42989:         return gfxFontUtils::MapUVSToGlyphFormat14(mUVSData, aCh, aVS);
42989:     }
42989: 
42989:     return 0;
42989: }
42989: 
31590: nsresult gfxFontEntry::ReadCMAP()
16418: {
31590:     mCmapInitialized = PR_TRUE;
31590:     return NS_OK;
31590: }
31590: 
47845: const nsString& gfxFontEntry::FamilyName() const
31590: {
31590:     NS_ASSERTION(mFamily, "gfxFontEntry is not a member of a family");
31590:     return mFamily->Name();
31590: }
31590: 
37211: already_AddRefed<gfxFont>
38202: gfxFontEntry::FindOrMakeFont(const gfxFontStyle *aStyle, PRBool aNeedsBold)
37211: {
37211:     // the font entry name is the psname, not the family name
47360:     nsRefPtr<gfxFont> font = gfxFontCache::GetCache()->Lookup(this, aStyle);
43347: 
37211:     if (!font) {
37211:         gfxFont *newFont = CreateFontInstance(aStyle, aNeedsBold);
37211:         if (!newFont)
37211:             return nsnull;
37211:         if (!newFont->Valid()) {
37211:             delete newFont;
37211:             return nsnull;
37211:         }
37211:         font = newFont;
37211:         gfxFontCache::GetCache()->AddNew(font);
37211:     }
37211:     gfxFont *f = nsnull;
37211:     font.swap(f);
37211:     return f;
37211: }
37211: 
43526: gfxFontEntry::FontTableCacheEntry::FontTableCacheEntry
43526:         (nsTArray<PRUint8>& aBuffer,
43526:          PRUint32 aTag,
43526:          nsClassHashtable<nsUint32HashKey,FontTableCacheEntry>& aCache)
43526:     : mTag(aTag), mCache(aCache)
43526: {
43526:     MOZ_COUNT_CTOR(FontTableCacheEntry);
43526:     mData.SwapElements(aBuffer);
43526:     mBlob = hb_blob_create((const char*)mData.Elements(), mData.Length(),
43526:                            HB_MEMORY_MODE_READONLY,
43526:                            gfxFontEntry::FontTableCacheEntry::Destroy,
43526:                            this);
43526: }
43526: 
43526: /* static */ void
43526: gfxFontEntry::FontTableCacheEntry::Destroy(void *aUserData)
43526: {
43526:     gfxFontEntry::FontTableCacheEntry *ftce =
43526:         static_cast<gfxFontEntry::FontTableCacheEntry*>(aUserData);
43526:     ftce->mCache.Remove(ftce->mTag);
43526: }
43526: 
43526: hb_blob_t *
43526: gfxFontEntry::GetFontTable(PRUint32 aTag)
43526: {
43526:     if (!mFontTableCache.IsInitialized()) {
43526:         // we do this here rather than on fontEntry construction
43526:         // because not all shapers will access the table cache at all
43526:         mFontTableCache.Init(10);
43526:     }
43526: 
43526:     FontTableCacheEntry *entry = nsnull;
43526:     if (!mFontTableCache.Get(aTag, &entry)) {
43526:         nsTArray<PRUint8> buffer;
43526:         if (NS_SUCCEEDED(GetFontTable(aTag, buffer))) {
43526:             entry = new FontTableCacheEntry(buffer, // adopts buffer elements
43526:                                             aTag, mFontTableCache);
43526:             if (mFontTableCache.Put(aTag, entry)) {
43526:                 return entry->GetBlob();
43526:             }
43526:             hb_blob_destroy(entry->GetBlob());
43526:             delete entry; // we failed to cache it!
43527:             return nsnull;
43526:         }
43526:     }
43526: 
43526:     if (entry) {
43526:         return hb_blob_reference(entry->GetBlob());
43526:     }
43526: 
43527:     return nsnull;
43526: }
43526: 
43526: 
43526: //////////////////////////////////////////////////////////////////////////////
43526: //
43526: // class gfxFontFamily
43526: //
43526: //////////////////////////////////////////////////////////////////////////////
43526: 
31590: // we consider faces with mStandardFace == PR_TRUE to be "greater than" those with PR_FALSE,
31590: // because during style matching, later entries will replace earlier ones
31590: class FontEntryStandardFaceComparator {
31590:   public:
31590:     PRBool Equals(const nsRefPtr<gfxFontEntry>& a, const nsRefPtr<gfxFontEntry>& b) const {
31590:         return a->mStandardFace == b->mStandardFace;
31590:     }
31590:     PRBool LessThan(const nsRefPtr<gfxFontEntry>& a, const nsRefPtr<gfxFontEntry>& b) const {
31590:         return (a->mStandardFace == PR_FALSE && b->mStandardFace == PR_TRUE);
31590:     }
31590: };
31590: 
31590: void
31590: gfxFontFamily::SortAvailableFonts()
31590: {
31590:     mAvailableFonts.Sort(FontEntryStandardFaceComparator());
31590: }
31590: 
31590: PRBool
31590: gfxFontFamily::HasOtherFamilyNames()
31590: {
31590:     // need to read in other family names to determine this
31590:     if (!mOtherFamilyNamesInitialized) {
37618:         ReadOtherFamilyNames(gfxPlatformFontList::PlatformFontList());  // sets mHasOtherFamilyNames
31590:     }
31590:     return mHasOtherFamilyNames;
31590: }
31590: 
31590: gfxFontEntry*
39307: gfxFontFamily::FindFontForStyle(const gfxFontStyle& aFontStyle, 
39307:                                 PRBool& aNeedsSyntheticBold)
31590: {
31590:     if (!mHasStyles)
31590:         FindStyleVariations(); // collect faces for the family, if not already done
31590: 
31590:     NS_ASSERTION(mAvailableFonts.Length() > 0, "font family with no faces!");
16418: 
39307:     aNeedsSyntheticBold = PR_FALSE;
16418: 
16418:     PRInt8 baseWeight, weightDistance;
16418:     aFontStyle.ComputeWeightAndOffset(&baseWeight, &weightDistance);
31590:     PRBool wantBold = baseWeight >= 6;
31590:     if ((wantBold && weightDistance < 0) || (!wantBold && weightDistance > 0)) {
31590:         wantBold = !wantBold;
31590:     }
31590: 
31590:     // If the family has only one face, we simply return it; no further checking needed
31590:     if (mAvailableFonts.Length() == 1) {
31590:         gfxFontEntry *fe = mAvailableFonts[0];
39307:         aNeedsSyntheticBold = wantBold && !fe->IsBold();
31590:         return fe;
31590:     }
31590: 
31590:     PRBool wantItalic = (aFontStyle.style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0;
31590: 
31590:     // Most families are "simple", having just Regular/Bold/Italic/BoldItalic,
31590:     // or some subset of these. In this case, we have exactly 4 entries in mAvailableFonts,
31590:     // stored in the above order; note that some of the entries may be NULL.
31590:     // We can then pick the required entry based on whether the request is for
31590:     // bold or non-bold, italic or non-italic, without running the more complex
31590:     // matching algorithm used for larger families with many weights and/or widths.
31590: 
31590:     if (mIsSimpleFamily) {
31590:         // Family has no more than the "standard" 4 faces, at fixed indexes;
31590:         // calculate which one we want.
31590:         // Note that we cannot simply return it as not all 4 faces are necessarily present.
31590:         PRUint8 faceIndex = (wantItalic ? kItalicMask : 0) |
31590:                             (wantBold ? kBoldMask : 0);
31590: 
31590:         // if the desired style is available, return it directly
31590:         gfxFontEntry *fe = mAvailableFonts[faceIndex];
31590:         if (fe) {
39307:             // no need to set aNeedsSyntheticBold here as we matched the boldness request
31590:             return fe;
31590:         }
31590: 
31590:         // order to check fallback faces in a simple family, depending on requested style
31590:         static const PRUint8 simpleFallbacks[4][3] = {
31590:             { kBoldFaceIndex, kItalicFaceIndex, kBoldItalicFaceIndex },   // fallbacks for Regular
31590:             { kRegularFaceIndex, kBoldItalicFaceIndex, kItalicFaceIndex },// Bold
31590:             { kBoldItalicFaceIndex, kRegularFaceIndex, kBoldFaceIndex },  // Italic
31590:             { kItalicFaceIndex, kBoldFaceIndex, kRegularFaceIndex }       // BoldItalic
31590:         };
31590:         const PRUint8 *order = simpleFallbacks[faceIndex];
31590: 
31590:         for (PRUint8 trial = 0; trial < 3; ++trial) {
31590:             // check remaining faces in order of preference to find the first that actually exists
31590:             fe = mAvailableFonts[order[trial]];
31590:             if (fe) {
31590:                 PR_LOG(gFontSelection, PR_LOG_DEBUG,
31590:                        ("(FindFontForStyle) name: %s, sty: %02x, wt: %d, sz: %.1f -> %s (trial %d)\n", 
31590:                         NS_ConvertUTF16toUTF8(mName).get(),
31590:                         aFontStyle.style, aFontStyle.weight, aFontStyle.size,
31590:                         NS_ConvertUTF16toUTF8(fe->Name()).get(), trial));
39307:                 aNeedsSyntheticBold = wantBold && !fe->IsBold();
31590:                 return fe;
31590:             }
31590:         }
31590: 
31590:         // this can't happen unless we have totally broken the font-list manager!
31590:         NS_NOTREACHED("no face found in simple font family!");
31590:         return nsnull;
31590:     }
31590: 
31590:     // This is a large/rich font family, so we do full style- and weight-matching:
31590:     // first collect a list of weights that are the best match for the requested
31590:     // font-stretch and font-style, then pick the best weight match among those
31590:     // available.
31590: 
31590:     gfxFontEntry *weightList[10] = { 0 };
31590:     PRBool foundWeights = FindWeightsForStyle(weightList, wantItalic, aFontStyle.stretch);
31590:     if (!foundWeights) {
31590:         PR_LOG(gFontSelection, PR_LOG_DEBUG,
31590:                ("(FindFontForStyle) name: %s, sty: %02x, wt: %d, sz: %.1f -> null\n", 
31590:                 NS_ConvertUTF16toUTF8(mName).get(),
31590:                 aFontStyle.style, aFontStyle.weight, aFontStyle.size));
31590:         return nsnull;
31590:     }
16418: 
48283:     // First find a match for the best weight
16418:     PRInt8 matchBaseWeight = 0;
48283:     PRInt8 i = baseWeight;
48283: 
48283:     // Need to special case when normal face doesn't exist but medium does.
48283:     // In that case, use medium otherwise weights < 400
48283:     if (baseWeight == 4 && !weightList[4]) {
48283:         i = 5; // medium
48283:     }
48283: 
48283:     // Loop through weights, since one exists loop will terminate
16418:     PRInt8 direction = (baseWeight > 5) ? 1 : -1;
48283:     for (; ; i += direction) {
16418:         if (weightList[i]) {
16418:             matchBaseWeight = i;
16418:             break;
16418:         }
16418: 
48283:         // If we've reached one side without finding a font,
48283:         // start over and go the other direction until we find a match
31590:         if (i == 1 || i == 9) {
48283:             i = baseWeight;
16418:             direction = -direction;
16418:         }
31590:     }
16418: 
48283:     NS_ASSERTION(matchBaseWeight != 0, 
48283:                  "weight mapping should always find at least one font in a family");
48283: 
48283:     gfxFontEntry *matchFE = weightList[matchBaseWeight];
16418:     const PRInt8 absDistance = abs(weightDistance);
48283:     PRInt8 wghtSteps;
48283: 
48283:     if (weightDistance != 0) {
48283:         direction = (weightDistance > 0) ? 1 : -1;
48283:         PRInt8 j;
48283: 
48283:         // Synthetic bolding occurs when font itself is not a bold-face and
39307:         // either the absolute weight is at least 600 or the relative weight
39307:         // (e.g. 402) implies a darker face than the ones available.
39307:         // note: this means that (1) lighter styles *never* synthetic bold and
39307:         // (2) synthetic bolding always occurs at the first bolder step beyond
39307:         // available faces, no matter how light the boldest face
39307: 
48283:         // Account for synthetic bold in lighter case
30622:         // if lighter is applied with an inherited bold weight,
30622:         // and no actual bold faces exist, synthetic bold is used
30622:         // so the matched weight above is actually one step down already
48283: 
48283:         wghtSteps = 1; // account for initial mapped weight
48283: 
30622:         if (weightDistance < 0 && baseWeight > 5 && matchBaseWeight < 6) {
48283:             wghtSteps++; // if no faces [600, 900] then synthetic bold at 700
48283:         }
48283: 
48283:         for (j = matchBaseWeight + direction;
48283:              j < 10 && j > 0 && wghtSteps <= absDistance;
48283:              j += direction) {
48283:             if (weightList[j]) {
48283:                 matchFE = weightList[j];
30622:                 wghtSteps++;
16418:             }
48283:         }
48283:     }
48283: 
48283:     NS_ASSERTION(matchFE,
48283:                  "weight mapping should always find at least one font in a family");
39307: 
39307:     if (!matchFE->IsBold() &&
39307:         ((weightDistance == 0 && baseWeight >= 6) ||
39307:          (weightDistance > 0 && wghtSteps <= absDistance)))
39307:     {
39307:         aNeedsSyntheticBold = PR_TRUE;
16418:     }
16418: 
31590:     PR_LOG(gFontSelection, PR_LOG_DEBUG,
31590:            ("(FindFontForStyle) name: %s, sty: %02x, wt: %d, sz: %.1f -> %s\n", 
31590:             NS_ConvertUTF16toUTF8(mName).get(),
31590:             aFontStyle.style, aFontStyle.weight, aFontStyle.size,
31590:             NS_ConvertUTF16toUTF8(matchFE->Name()).get()));
16418:     return matchFE;
16418: }
16418: 
31590: void
31590: gfxFontFamily::CheckForSimpleFamily()
31590: {
38059:     if (mAvailableFonts.Length() > 4 || mAvailableFonts.Length() == 0) {
38059:         return; // can't be "simple" if there are >4 faces;
38059:                 // if none then the family is unusable anyway
31590:     }
31590: 
31590:     PRInt16 firstStretch = mAvailableFonts[0]->Stretch();
31590: 
31590:     gfxFontEntry *faces[4] = { 0 };
31590:     for (PRUint8 i = 0; i < mAvailableFonts.Length(); ++i) {
31590:         gfxFontEntry *fe = mAvailableFonts[i];
31590:         if (fe->Stretch() != firstStretch) {
31590:             return; // font-stretch doesn't match, don't treat as simple family
31590:         }
31590:         PRUint8 faceIndex = (fe->IsItalic() ? kItalicMask : 0) |
31590:                             (fe->Weight() >= 600 ? kBoldMask : 0);
31590:         if (faces[faceIndex]) {
31590:             return; // two faces resolve to the same slot; family isn't "simple"
31590:         }
31590:         faces[faceIndex] = fe;
31590:     }
31590: 
31590:     // we have successfully slotted the available faces into the standard
31590:     // 4-face framework
31590:     mAvailableFonts.SetLength(4);
31590:     for (PRUint8 i = 0; i < 4; ++i) {
31590:         if (mAvailableFonts[i].get() != faces[i]) {
31590:             mAvailableFonts[i].swap(faces[i]);
31590:         }
31590:     }
31590: 
31590:     mIsSimpleFamily = PR_TRUE;
31590: }
31590: 
31590: static inline PRUint32
31590: StyleDistance(gfxFontEntry *aFontEntry,
31590:               PRBool anItalic, PRInt16 aStretch)
31590: {
31590:     // Compute a measure of the "distance" between the requested style
31590:     // and the given fontEntry,
31590:     // considering italicness and font-stretch but not weight.
31590: 
31590:     // TODO (refine CSS spec...): discuss priority of italic vs stretch;
31590:     // whether penalty for stretch mismatch should depend on actual difference in values;
31590:     // whether a sign mismatch in stretch should increase the effective distance
31590: 
31590:     return (aFontEntry->IsItalic() != anItalic ? 1 : 0) +
31590:            (aFontEntry->mStretch != aStretch ? 10 : 0);
31590: }
31590: 
31590: PRBool
31590: gfxFontFamily::FindWeightsForStyle(gfxFontEntry* aFontsForWeights[],
31590:                                    PRBool anItalic, PRInt16 aStretch)
31590: {
31590:     PRUint32 foundWeights = 0;
31590:     PRUint32 bestMatchDistance = 0xffffffff;
31590: 
31590:     for (PRUint32 i = 0; i < mAvailableFonts.Length(); i++) {
31590:         // this is not called for "simple" families, and therefore it does not
31590:         // need to check the mAvailableFonts entries for NULL
31590:         gfxFontEntry *fe = mAvailableFonts[i];
31590:         PRUint32 distance = StyleDistance(fe, anItalic, aStretch);
31590:         if (distance <= bestMatchDistance) {
31590:             PRInt8 wt = fe->mWeight / 100;
31590:             NS_ASSERTION(wt >= 1 && wt < 10, "invalid weight in fontEntry");
31590:             if (!aFontsForWeights[wt]) {
31590:                 // record this as a possible candidate for weight matching
31590:                 aFontsForWeights[wt] = fe;
31590:                 ++foundWeights;
31590:             } else {
31590:                 PRUint32 prevDistance = StyleDistance(aFontsForWeights[wt], anItalic, aStretch);
31590:                 if (prevDistance >= distance) {
31590:                     // replacing a weight we already found, so don't increment foundWeights
31590:                     aFontsForWeights[wt] = fe;
31590:                 }
31590:             }
31590:             bestMatchDistance = distance;
31590:         }
31590:     }
31590: 
31590:     NS_ASSERTION(foundWeights > 0, "Font family containing no faces?");
31590: 
31590:     if (foundWeights == 1) {
31590:         // no need to cull entries if we only found one weight
31590:         return PR_TRUE;
31590:     }
31590: 
31590:     // we might have recorded some faces that were a partial style match, but later found
31590:     // others that were closer; in this case, we need to cull the poorer matches from the
31590:     // weight list we'll return
31590:     for (PRUint32 i = 0; i < 10; ++i) {
31590:         if (aFontsForWeights[i] &&
31590:             StyleDistance(aFontsForWeights[i], anItalic, aStretch) > bestMatchDistance)
31590:         {
31590:             aFontsForWeights[i] = 0;
31590:         }
31590:     }
31590: 
31590:     return (foundWeights > 0);
31590: }
31590: 
31590: 
31590: void gfxFontFamily::LocalizedName(nsAString& aLocalizedName)
31590: {
31590:     // just return the primary name; subclasses should override
31590:     aLocalizedName = mName;
31590: }
31590: 
31590: 
31590: void
31590: gfxFontFamily::FindFontForChar(FontSearch *aMatchData)
31590: {
35525:     if (!mHasStyles)
35525:         FindStyleVariations();
35525: 
31590:     // xxx - optimization point - keep a bit vector with the union of supported unicode ranges
31590:     // by all fonts for this family and bail immediately if the character is not in any of
31590:     // this family's cmaps
31590: 
31590:     // iterate over fonts
31590:     PRUint32 numFonts = mAvailableFonts.Length();
31590:     for (PRUint32 i = 0; i < numFonts; i++) {
31590:         gfxFontEntry *fe = mAvailableFonts[i];
46221: 
46221:         // skip certain fonts during system fallback
46221:         if (!fe || fe->SkipDuringSystemFallback())
31590:             continue;
31590: 
31590:         PRInt32 rank = 0;
31590: 
31590:         if (fe->TestCharacterMap(aMatchData->mCh)) {
31590:             rank += 20;
31590:         }
31590: 
31590:         // if we didn't match any characters don't bother wasting more time with this face.
31590:         if (rank == 0)
31590:             continue;
31590:             
31590:         // omitting from original windows code -- family name, lang group, pitch
31590:         // not available in current FontEntry implementation
31590: 
31590:         if (aMatchData->mFontToMatch) { 
31590:             const gfxFontStyle *style = aMatchData->mFontToMatch->GetStyle();
31590:             
31590:             // italics
31590:             if (fe->IsItalic() && 
31590:                     (style->style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0) {
31590:                 rank += 5;
31590:             }
31590:             
31590:             // weight
31590:             PRInt8 baseWeight, weightDistance;
31590:             style->ComputeWeightAndOffset(&baseWeight, &weightDistance);
31590: 
31590:             // xxx - not entirely correct, the one unit of weight distance reflects 
31590:             // the "next bolder/lighter face"
31590:             PRInt32 targetWeight = (baseWeight * 100) + (weightDistance * 100);
31590: 
31590:             PRInt32 entryWeight = fe->Weight();
31590:             if (entryWeight == targetWeight) {
31590:                 rank += 5;
31590:             } else {
31590:                 PRUint32 diffWeight = abs(entryWeight - targetWeight);
31590:                 if (diffWeight <= 100)  // favor faces close in weight
31590:                     rank += 2;
31590:             }
31590:         } else {
31590:             // if no font to match, prefer non-bold, non-italic fonts
31590:             if (!fe->IsItalic() && !fe->IsBold())
31590:                 rank += 5;
31590:         }
31590:         
31590:         // xxx - add whether AAT font with morphing info for specific lang groups
31590:         
31590:         if (rank > aMatchData->mMatchRank
31590:             || (rank == aMatchData->mMatchRank &&
31590:                 Compare(fe->Name(), aMatchData->mBestMatch->Name()) > 0)) 
31590:         {
31590:             aMatchData->mBestMatch = fe;
31590:             aMatchData->mMatchRank = rank;
31590:         }
31590:     }
31590: }
31590: 
31590: // returns true if other names were found, false otherwise
31590: PRBool
37618: gfxFontFamily::ReadOtherFamilyNamesForFace(gfxPlatformFontList *aPlatformFontList,
37618:                                            nsTArray<PRUint8>& aNameTable,
33382:                                            PRBool useFullName)
31590: {
37618:     const PRUint8 *nameData = aNameTable.Elements();
37618:     PRUint32 dataLength = aNameTable.Length();
31590:     const gfxFontUtils::NameHeader *nameHeader =
31590:         reinterpret_cast<const gfxFontUtils::NameHeader*>(nameData);
31590: 
31590:     PRUint32 nameCount = nameHeader->count;
31590:     if (nameCount * sizeof(gfxFontUtils::NameRecord) > dataLength) {
31590:         NS_WARNING("invalid font (name records)");
31590:         return PR_FALSE;
31590:     }
31590:     
31590:     const gfxFontUtils::NameRecord *nameRecord =
31590:         reinterpret_cast<const gfxFontUtils::NameRecord*>(nameData + sizeof(gfxFontUtils::NameHeader));
31590:     PRUint32 stringsBase = PRUint32(nameHeader->stringOffset);
31590: 
31590:     PRBool foundNames = PR_FALSE;
31590:     for (PRUint32 i = 0; i < nameCount; i++, nameRecord++) {
31590:         PRUint32 nameLen = nameRecord->length;
31590:         PRUint32 nameOff = nameRecord->offset;  // offset from base of string storage
31590: 
31590:         if (stringsBase + nameOff + nameLen > dataLength) {
31590:             NS_WARNING("invalid font (name table strings)");
31590:             return PR_FALSE;
31590:         }
31590: 
31590:         PRUint16 nameID = nameRecord->nameID;
31590:         if ((useFullName && nameID == gfxFontUtils::NAME_ID_FULL) ||
31590:             (!useFullName && (nameID == gfxFontUtils::NAME_ID_FAMILY ||
31590:                               nameID == gfxFontUtils::NAME_ID_PREFERRED_FAMILY))) {
31590:             nsAutoString otherFamilyName;
31590:             PRBool ok = gfxFontUtils::DecodeFontName(nameData + stringsBase + nameOff,
31590:                                                      nameLen,
31590:                                                      PRUint32(nameRecord->platformID),
31590:                                                      PRUint32(nameRecord->encodingID),
31590:                                                      PRUint32(nameRecord->languageID),
31590:                                                      otherFamilyName);
31590:             // add if not same as canonical family name
31590:             if (ok && otherFamilyName != mName) {
37618:                 aPlatformFontList->AddOtherFamilyName(this, otherFamilyName);
31590:                 foundNames = PR_TRUE;
31590:             }
31590:         }
31590:     }
31590: 
31590:     return foundNames;
31590: }
31590: 
31590: 
31590: void
37618: gfxFontFamily::ReadOtherFamilyNames(gfxPlatformFontList *aPlatformFontList)
31590: {
31590:     if (mOtherFamilyNamesInitialized) 
31590:         return;
31590:     mOtherFamilyNamesInitialized = PR_TRUE;
31590: 
35525:     FindStyleVariations();
35525: 
31590:     // read in other family names for the first face in the list
37618:     PRUint32 i, numFonts = mAvailableFonts.Length();
37618:     const PRUint32 kNAME = TRUETYPE_TAG('n','a','m','e');
37618:     nsAutoTArray<PRUint8,8192> buffer;
37618: 
31590:     for (i = 0; i < numFonts; ++i) {
37618:         gfxFontEntry *fe = mAvailableFonts[i];
37618:         if (!fe)
31590:             continue;
37618: 
37618:         if (fe->GetFontTable(kNAME, buffer) != NS_OK)
37618:             continue;
37618: 
37618:         mHasOtherFamilyNames = ReadOtherFamilyNamesForFace(aPlatformFontList,
37618:                                                            buffer);
31590:         break;
31590:     }
31590: 
31590:     // read in other names for the first face in the list with the assumption
31590:     // that if extra names don't exist in that face then they don't exist in
31590:     // other faces for the same font
37618:     if (!mHasOtherFamilyNames) 
37618:         return;
37618: 
31590:     // read in names for all faces, needed to catch cases where fonts have
31590:     // family names for individual weights (e.g. Hiragino Kaku Gothic Pro W6)
31590:     for ( ; i < numFonts; i++) {
37618:         gfxFontEntry *fe = mAvailableFonts[i];
37618:         if (!fe)
31590:             continue;
37618: 
37618:         if (fe->GetFontTable(kNAME, buffer) != NS_OK)
37618:             continue;
37618: 
37618:         ReadOtherFamilyNamesForFace(aPlatformFontList, buffer);
37618:     }
37618: }
37618: 
37618: void
37618: gfxFontFamily::ReadFaceNames(gfxPlatformFontList *aPlatformFontList, 
37618:                              PRBool aNeedFullnamePostscriptNames)
37618: {
37618:     // if all needed names have already been read, skip
37618:     if (mOtherFamilyNamesInitialized &&
37618:         (mFaceNamesInitialized || !aNeedFullnamePostscriptNames))
37618:         return;
37618: 
37618:     FindStyleVariations();
37618: 
37618:     PRUint32 i, numFonts = mAvailableFonts.Length();
37618:     const PRUint32 kNAME = TRUETYPE_TAG('n','a','m','e');
37618:     nsAutoTArray<PRUint8,8192> buffer;
37618:     nsAutoString fullname, psname;
37618: 
37618:     PRBool firstTime = PR_TRUE, readAllFaces = PR_FALSE;
37618:     for (i = 0; i < numFonts; ++i) {
37618:         gfxFontEntry *fe = mAvailableFonts[i];
37618:         if (!fe)
37618:             continue;
37618: 
37618:         if (fe->GetFontTable(kNAME, buffer) != NS_OK)
37618:             continue;
37618: 
37618:         if (aNeedFullnamePostscriptNames) {
37618:             if (gfxFontUtils::ReadCanonicalName(
37618:                     buffer, gfxFontUtils::NAME_ID_FULL, fullname) == NS_OK)
37618:             {
37618:                 aPlatformFontList->AddFullname(fe, fullname);
37618:             }
37618: 
37618:             if (gfxFontUtils::ReadCanonicalName(
37618:                     buffer, gfxFontUtils::NAME_ID_POSTSCRIPT, psname) == NS_OK)
37618:             {
37618:                 aPlatformFontList->AddPostscriptName(fe, psname);
37618:             }
37618:         }
37618: 
37618:        if (!mOtherFamilyNamesInitialized && (firstTime || readAllFaces)) {
37618:            PRBool foundOtherName = ReadOtherFamilyNamesForFace(aPlatformFontList,
37618:                                                                buffer);
37618: 
37618:            // if the first face has a different name, scan all faces, otherwise
37618:            // assume the family doesn't have other names
37618:            if (firstTime && foundOtherName) {
37618:                mHasOtherFamilyNames = PR_TRUE;
37618:                readAllFaces = PR_TRUE;
37618:            }
37618:            firstTime = PR_FALSE;
37618:        }
37618: 
37618:        // if not reading in any more names, skip other faces
37618:        if (!readAllFaces && !aNeedFullnamePostscriptNames)
37618:            break;
37618:     }
37618: 
37618:     mFaceNamesInitialized = PR_TRUE;
37618:     mOtherFamilyNamesInitialized = PR_TRUE;
31590: }
31590: 
31590: 
31590: gfxFontEntry*
31590: gfxFontFamily::FindFont(const nsAString& aPostscriptName)
31590: {
31590:     // find the font using a simple linear search
31590:     PRUint32 numFonts = mAvailableFonts.Length();
31590:     for (PRUint32 i = 0; i < numFonts; i++) {
31590:         gfxFontEntry *fe = mAvailableFonts[i].get();
31590:         if (fe && fe->Name() == aPostscriptName)
31590:             return fe;
31590:     }
31590:     return nsnull;
31590: }
31590: 
31590: 
  323: nsresult
  323: gfxFontCache::Init()
  323: {
  323:     NS_ASSERTION(!gGlobalCache, "Where did this come from?");
  323:     gGlobalCache = new gfxFontCache();
  323:     return gGlobalCache ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
  323: }
  323: 
  323: void
  323: gfxFontCache::Shutdown()
  323: {
  323:     delete gGlobalCache;
  323:     gGlobalCache = nsnull;
 3005: 
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005:     printf("Textrun storage high water mark=%d\n", gTextRunStorageHighWaterMark);
 6513:     printf("Total number of fonts=%d\n", gFontCount);
 6513:     printf("Total glyph extents allocated=%d (size %d)\n", gGlyphExtentsCount,
 6513:             int(gGlyphExtentsCount*sizeof(gfxGlyphExtents)));
 6513:     printf("Total glyph extents width-storage size allocated=%d\n", gGlyphExtentsWidthsTotalSize);
 6513:     printf("Number of simple glyph extents eagerly requested=%d\n", gGlyphExtentsSetupEagerSimple);
 6513:     printf("Number of tight glyph extents eagerly requested=%d\n", gGlyphExtentsSetupEagerTight);
 6513:     printf("Number of tight glyph extents lazily requested=%d\n", gGlyphExtentsSetupLazyTight);
 6513:     printf("Number of simple glyph extent setups that fell back to tight=%d\n", gGlyphExtentsSetupFallBackToTight);
 3005: #endif
  323: }
  323: 
  323: PRBool
  323: gfxFontCache::HashEntry::KeyEquals(const KeyTypePointer aKey) const
  323: {
47360:     return aKey->mFontEntry == mFont->GetFontEntry() &&
  323:            aKey->mStyle->Equals(*mFont->GetStyle());
  323: }
  323: 
  323: already_AddRefed<gfxFont>
47360: gfxFontCache::Lookup(const gfxFontEntry *aFontEntry,
  323:                      const gfxFontStyle *aStyle)
  323: {
47360:     Key key(aFontEntry, aStyle);
  323:     HashEntry *entry = mFonts.GetEntry(key);
  323:     if (!entry)
  323:         return nsnull;
  323: 
  323:     gfxFont *font = entry->mFont;
  323:     NS_ADDREF(font);
  323:     return font;
  323: }
  323: 
  323: void
  323: gfxFontCache::AddNew(gfxFont *aFont)
  323: {
47360:     Key key(aFont->GetFontEntry(), aFont->GetStyle());
  323:     HashEntry *entry = mFonts.PutEntry(key);
  323:     if (!entry)
  323:         return;
10514:     gfxFont *oldFont = entry->mFont;
10514:     entry->mFont = aFont;
10514:     // If someone's asked us to replace an existing font entry, then that's a
10514:     // bit weird, but let it happen, and expire the old font if it's not used.
10514:     if (oldFont && oldFont->GetExpirationState()->IsTracked()) {
10514:         // if oldFont == aFont, recount should be > 0,
10514:         // so we shouldn't be here.
10514:         NS_ASSERTION(aFont != oldFont, "new font is tracked for expiry!");
10514:         NotifyExpired(oldFont);
  323:     }
  323: }
  323: 
  323: void
  323: gfxFontCache::NotifyReleased(gfxFont *aFont)
  323: {
  323:     nsresult rv = AddObject(aFont);
  323:     if (NS_FAILED(rv)) {
  323:         // We couldn't track it for some reason. Kill it now.
  323:         DestroyFont(aFont);
  323:     }
  323:     // Note that we might have fonts that aren't in the hashtable, perhaps because
  323:     // of OOM adding to the hashtable or because someone did an AddNew where
  323:     // we already had a font. These fonts are added to the expiration tracker
  323:     // anyway, even though Lookup can't resurrect them. Eventually they will
  323:     // expire and be deleted.
  323: }
  323: 
  323: void
  323: gfxFontCache::NotifyExpired(gfxFont *aFont)
  323: {
  323:     RemoveObject(aFont);
  323:     DestroyFont(aFont);
  323: }
  323: 
  323: void
  323: gfxFontCache::DestroyFont(gfxFont *aFont)
  323: {
47360:     Key key(aFont->GetFontEntry(), aFont->GetStyle());
10514:     HashEntry *entry = mFonts.GetEntry(key);
10514:     if (entry && entry->mFont == aFont)
  323:         mFonts.RemoveEntry(key);
10514:     NS_ASSERTION(aFont->GetRefCount() == 0,
10514:                  "Destroying with non-zero ref count!");
  323:     delete aFont;
  323: }
  323: 
16581: void
16581: gfxFont::RunMetrics::CombineWith(const RunMetrics& aOther, PRBool aOtherIsOnLeft)
16581: {
16581:     mAscent = PR_MAX(mAscent, aOther.mAscent);
16581:     mDescent = PR_MAX(mDescent, aOther.mDescent);
16581:     if (aOtherIsOnLeft) {
16581:         mBoundingBox =
16581:             (mBoundingBox + gfxPoint(aOther.mAdvanceWidth, 0)).Union(aOther.mBoundingBox);
16581:     } else {
16581:         mBoundingBox =
16581:             mBoundingBox.Union(aOther.mBoundingBox + gfxPoint(mAdvanceWidth, 0));
16581:     }
16581:     mAdvanceWidth += aOther.mAdvanceWidth;
16581: }
16581: 
39447: gfxFont::gfxFont(gfxFontEntry *aFontEntry, const gfxFontStyle *aFontStyle,
39447:                  AntialiasOption anAAOption) :
39206:     mFontEntry(aFontEntry), mIsValid(PR_TRUE),
43527:     mStyle(*aFontStyle),
43527:     mAdjustedSize(0.0),
43527:     mFUnitsConvFactor(0.0f),
43527:     mSyntheticBoldOffset(0),
39447:     mAntialiasOption(anAAOption),
43527:     mPlatformShaper(nsnull),
43527:     mHarfBuzzShaper(nsnull)
    1: {
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:     ++gFontCount;
 6513: #endif
    1: }
    1: 
 6247: gfxFont::~gfxFont()
 6247: {
 6247:     PRUint32 i;
 6247:     // We destroy the contents of mGlyphExtentsArray explicitly instead of
 6247:     // using nsAutoPtr because VC++ can't deal with nsTArrays of nsAutoPtrs
 6247:     // of classes that lack a proper copy constructor
 6247:     for (i = 0; i < mGlyphExtentsArray.Length(); ++i) {
 6247:         delete mGlyphExtentsArray[i];
 6247:     }
 6247: }
 6247: 
    1: /**
    1:  * A helper function in case we need to do any rounding or other
    1:  * processing here.
    1:  */
18764: #define ToDeviceUnits(aAppUnits, aDevUnitsPerAppUnit) \
18764:     (double(aAppUnits)*double(aDevUnitsPerAppUnit))
    1: 
 3594: struct GlyphBuffer {
 3594: #define GLYPH_BUFFER_SIZE (2048/sizeof(cairo_glyph_t))
 3594:     cairo_glyph_t mGlyphBuffer[GLYPH_BUFFER_SIZE];
 3594:     unsigned int mNumGlyphs;
 3594: 
 3594:     GlyphBuffer()
 3594:         : mNumGlyphs(0) { }
 3594: 
 3594:     cairo_glyph_t *AppendGlyph() {
 3594:         return &mGlyphBuffer[mNumGlyphs++];
 3594:     }
 3594: 
18764:     void Flush(cairo_t *aCR, PRBool aDrawToPath, PRBool aReverse,
18764:                PRBool aFinish = PR_FALSE) {
18764:         // Ensure there's enough room for at least two glyphs in the
18764:         // buffer (because we may allocate two glyphs between flushes)
18764:         if (!aFinish && mNumGlyphs + 2 <= GLYPH_BUFFER_SIZE)
 3594:             return;
 3594: 
18764:         if (aReverse) {
18764:             for (PRUint32 i = 0; i < mNumGlyphs/2; ++i) {
18764:                 cairo_glyph_t tmp = mGlyphBuffer[i];
18764:                 mGlyphBuffer[i] = mGlyphBuffer[mNumGlyphs - 1 - i];
18764:                 mGlyphBuffer[mNumGlyphs - 1 - i] = tmp;
18764:             }
18764:         }
18764:         if (aDrawToPath)
18764:             cairo_glyph_path(aCR, mGlyphBuffer, mNumGlyphs);
 3594:         else
18764:             cairo_show_glyphs(aCR, mGlyphBuffer, mNumGlyphs);
 3594: 
 3594:         mNumGlyphs = 0;
 3594:     }
 3594: #undef GLYPH_BUFFER_SIZE
 3594: };
 3594: 
    1: void
    1: gfxFont::Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,
    1:               gfxContext *aContext, PRBool aDrawToPath, gfxPoint *aPt,
    1:               Spacing *aSpacing)
    1: {
    1:     if (aStart >= aEnd)
    1:         return;
    1: 
    1:     const gfxTextRun::CompressedGlyph *charGlyphs = aTextRun->GetCharacterGlyphs();
    1:     const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();
    1:     const double devUnitsPerAppUnit = 1.0/double(appUnitsPerDevUnit);
    1:     PRBool isRTL = aTextRun->IsRightToLeft();
    1:     double direction = aTextRun->GetDirection();
18764:     // double-strike in direction of run
18764:     double synBoldDevUnitOffsetAppUnits =
18764:       direction * (double) mSyntheticBoldOffset * appUnitsPerDevUnit;
    1:     PRUint32 i;
    1:     // Current position in appunits
    1:     double x = aPt->x;
    1:     double y = aPt->y;
    1: 
 6247:     PRBool success = SetupCairoFont(aContext);
 4304:     if (NS_UNLIKELY(!success))
 4304:         return;
 3594: 
 3594:     GlyphBuffer glyphs;
 3594:     cairo_glyph_t *glyph;
 6247:     cairo_t *cr = aContext->GetCairo();
 3594: 
    1:     if (aSpacing) {
    1:         x += direction*aSpacing[0].mBefore;
    1:     }
    1:     for (i = aStart; i < aEnd; ++i) {
    1:         const gfxTextRun::CompressedGlyph *glyphData = &charGlyphs[i];
    1:         if (glyphData->IsSimpleGlyph()) {
 3594:             glyph = glyphs.AppendGlyph();
    1:             glyph->index = glyphData->GetSimpleGlyph();
    1:             double advance = glyphData->GetSimpleAdvance();
    1:             // Perhaps we should put a scale in the cairo context instead of
    1:             // doing this scaling here...
    1:             // Multiplying by the reciprocal may introduce tiny error here,
    1:             // but we assume cairo is going to round coordinates at some stage
    1:             // and this is faster
18764:             double glyphX;
    1:             if (isRTL) {
    1:                 x -= advance;
18764:                 glyphX = x;
    1:             } else {
18764:                 glyphX = x;
    1:                 x += advance;
    1:             }
18764:             glyph->x = ToDeviceUnits(glyphX, devUnitsPerAppUnit);
18764:             glyph->y = ToDeviceUnits(y, devUnitsPerAppUnit);
13339:             
13339:             // synthetic bolding by drawing with a one-pixel offset
13339:             if (mSyntheticBoldOffset) {
13339:                 cairo_glyph_t *doubleglyph;
13339:                 doubleglyph = glyphs.AppendGlyph();
13339:                 doubleglyph->index = glyph->index;
18764:                 doubleglyph->x =
18764:                   ToDeviceUnits(glyphX + synBoldDevUnitOffsetAppUnits,
18764:                                 devUnitsPerAppUnit);
13339:                 doubleglyph->y = glyph->y;
13339:             }
13339:             
18764:             glyphs.Flush(cr, aDrawToPath, isRTL);
 7715:         } else {
 7715:             PRUint32 j;
 7715:             PRUint32 glyphCount = glyphData->GetGlyphCount();
    1:             const gfxTextRun::DetailedGlyph *details = aTextRun->GetDetailedGlyphs(i);
 7715:             for (j = 0; j < glyphCount; ++j, ++details) {
    1:                 double advance = details->mAdvance;
 7715:                 if (glyphData->IsMissing()) {
41493:                     // default ignorable characters will have zero advance width.
41493:                     // we don't have to draw the hexbox for them
41493:                     if (!aDrawToPath && advance > 0) {
18764:                         double glyphX = x;
18764:                         if (isRTL) {
18764:                             glyphX -= advance;
18764:                         }
18764:                         gfxPoint pt(ToDeviceUnits(glyphX, devUnitsPerAppUnit),
  132:                                     ToDeviceUnits(y, devUnitsPerAppUnit));
  132:                         gfxFloat advanceDevUnits = ToDeviceUnits(advance, devUnitsPerAppUnit);
  132:                         gfxFloat height = GetMetrics().maxAscent;
  132:                         gfxRect glyphRect(pt.x, pt.y - height, advanceDevUnits, height);
  132:                         gfxFontMissingGlyphs::DrawMissingGlyph(aContext, glyphRect, details->mGlyphID);
  132:                     }
 7715:                 } else {
 7715:                     glyph = glyphs.AppendGlyph();
 7715:                     glyph->index = details->mGlyphID;
18764:                     double glyphX = x + details->mXOffset;
18764:                     if (isRTL) {
18764:                         glyphX -= advance;
18764:                     }
18764:                     glyph->x = ToDeviceUnits(glyphX, devUnitsPerAppUnit);
 7715:                     glyph->y = ToDeviceUnits(y + details->mYOffset, devUnitsPerAppUnit);
13339: 
13339:                     // synthetic bolding by drawing with a one-pixel offset
13339:                     if (mSyntheticBoldOffset) {
13339:                         cairo_glyph_t *doubleglyph;
13339:                         doubleglyph = glyphs.AppendGlyph();
13339:                         doubleglyph->index = glyph->index;
18764:                         doubleglyph->x =
18764:                             ToDeviceUnits(glyphX + synBoldDevUnitOffsetAppUnits,
18764:                                           devUnitsPerAppUnit);
13339:                         doubleglyph->y = glyph->y;
13339:                     }
13339: 
18764:                     glyphs.Flush(cr, aDrawToPath, isRTL);
 7715:                 }
  132:                 x += direction*advance;
  132:             }
  132:         }
 7715: 
    1:         if (aSpacing) {
    1:             double space = aSpacing[i - aStart].mAfter;
    1:             if (i + 1 < aEnd) {
    1:                 space += aSpacing[i + 1 - aStart].mBefore;
    1:             }
    1:             x += direction*space;
    1:         }
    1:     }
    1: 
 3594:     if (gfxFontTestStore::CurrentStore()) {
 3594:         /* This assumes that the tests won't have anything that results
 3594:          * in more than GLYPH_BUFFER_SIZE glyphs.  Do this before we
 3594:          * flush, since that'll blow away the num_glyphs.
 3594:          */
 3594:         gfxFontTestStore::CurrentStore()->AddItem(GetUniqueName(),
 3594:                                                   glyphs.mGlyphBuffer, glyphs.mNumGlyphs);
    1:     }
    1: 
 3594:     // draw any remaining glyphs
18764:     glyphs.Flush(cr, aDrawToPath, isRTL, PR_TRUE);
 3594: 
 3594:     *aPt = gfxPoint(x, y);
    1: }
    1: 
 7715: static PRInt32
 7715: GetAdvanceForGlyphs(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd)
 7715: {
 7715:     const gfxTextRun::CompressedGlyph *glyphData = aTextRun->GetCharacterGlyphs() + aStart;
 7715:     PRInt32 advance = 0;
 7715:     PRUint32 i;
 7715:     for (i = aStart; i < aEnd; ++i, ++glyphData) {
 7715:         if (glyphData->IsSimpleGlyph()) {
 7715:             advance += glyphData->GetSimpleAdvance();   
 7715:         } else {
 7715:             PRUint32 glyphCount = glyphData->GetGlyphCount();
 7715:             const gfxTextRun::DetailedGlyph *details = aTextRun->GetDetailedGlyphs(i);
 7715:             PRUint32 j;
 7715:             for (j = 0; j < glyphCount; ++j, ++details) {
 7715:                 advance += details->mAdvance;
 7715:             }
 7715:         }
 7715:     }
 7715:     return advance;
 7715: }
 7715: 
 6247: static void
16510: UnionRange(gfxFloat aX, gfxFloat* aDestMin, gfxFloat* aDestMax)
 6247: {
16510:     *aDestMin = PR_MIN(*aDestMin, aX);
16510:     *aDestMax = PR_MAX(*aDestMax, aX);
 6247: }
 6247: 
29527: // We get precise glyph extents if the textrun creator requested them, or
29527: // if the font is a user font --- in which case the author may be relying
29527: // on overflowing glyphs.
29527: static PRBool
29527: NeedsGlyphExtents(gfxFont *aFont, gfxTextRun *aTextRun)
29527: {
29527:     return (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX) ||
29527:         aFont->GetFontEntry()->IsUserFont();
29527: }
29527: 
 6247: static PRBool
 6247: NeedsGlyphExtents(gfxTextRun *aTextRun)
 6247: {
29527:     if (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX)
29527:         return PR_TRUE;
29527:     PRUint32 numRuns;
29527:     const gfxTextRun::GlyphRun *glyphRuns = aTextRun->GetGlyphRuns(&numRuns);
29527:     for (PRUint32 i = 0; i < numRuns; ++i) {
29527:         if (glyphRuns[i].mFont->GetFontEntry()->IsUserFont())
29527:             return PR_TRUE;
29527:     }
29527:     return PR_FALSE;
 6247: }
 6247: 
    1: gfxFont::RunMetrics
    1: gfxFont::Measure(gfxTextRun *aTextRun,
    1:                  PRUint32 aStart, PRUint32 aEnd,
39447:                  BoundingBoxType aBoundingBoxType,
39447:                  gfxContext *aRefContext,
    1:                  Spacing *aSpacing)
    1: {
39447:     // If aBoundingBoxType is TIGHT_HINTED_OUTLINE_EXTENTS
39447:     // and the underlying cairo font may be antialiased,
39447:     // we need to create a copy in order to avoid getting cached extents.
42207:     // This is only used by MathML layout at present.
39447:     if (aBoundingBoxType == TIGHT_HINTED_OUTLINE_EXTENTS &&
39447:         mAntialiasOption != kAntialiasNone) {
42207:         if (!mNonAAFont) {
42207:             mNonAAFont = CopyWithAntialiasOption(kAntialiasNone);
42207:         }
39447:         // if font subclass doesn't implement CopyWithAntialiasOption(),
39447:         // it will return null and we'll proceed to use the existing font
42207:         if (mNonAAFont) {
42207:             return mNonAAFont->Measure(aTextRun, aStart, aEnd,
39447:                                        TIGHT_HINTED_OUTLINE_EXTENTS,
39447:                                        aRefContext, aSpacing);
39447:         }
39447:     }
39447: 
 6247:     const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();
 6247:     // Current position in appunits
 6247:     const gfxFont::Metrics& fontMetrics = GetMetrics();
 6247: 
 6247:     RunMetrics metrics;
 6247:     metrics.mAscent = fontMetrics.maxAscent*appUnitsPerDevUnit;
 6247:     metrics.mDescent = fontMetrics.maxDescent*appUnitsPerDevUnit;
 8499:     if (aStart == aEnd) {
 8499:         // exit now before we look at aSpacing[0], which is undefined
16510:         metrics.mBoundingBox = gfxRect(0, -metrics.mAscent, 0, metrics.mAscent + metrics.mDescent);
 8499:         return metrics;
 8499:     }
 6247: 
16510:     gfxFloat advanceMin = 0, advanceMax = 0;
 8499:     const gfxTextRun::CompressedGlyph *charGlyphs = aTextRun->GetCharacterGlyphs();
 8499:     PRBool isRTL = aTextRun->IsRightToLeft();
 8499:     double direction = aTextRun->GetDirection();
29527:     PRBool needsGlyphExtents = NeedsGlyphExtents(this, aTextRun);
 6247:     gfxGlyphExtents *extents =
25417:         (aBoundingBoxType == LOOSE_INK_EXTENTS &&
29527:             !needsGlyphExtents &&
25417:             !aTextRun->HasDetailedGlyphs()) ? nsnull
 6247:         : GetOrCreateGlyphExtents(aTextRun->GetAppUnitsPerDevUnit());
 6247:     double x = 0;
 6247:     if (aSpacing) {
 6247:         x += direction*aSpacing[0].mBefore;
 6247:     }
 6225:     PRUint32 i;
    1:     for (i = aStart; i < aEnd; ++i) {
 6247:         const gfxTextRun::CompressedGlyph *glyphData = &charGlyphs[i];
 6247:         if (glyphData->IsSimpleGlyph()) {
 6247:             double advance = glyphData->GetSimpleAdvance();
 6247:             // Only get the real glyph horizontal extent if we were asked
 6247:             // for the tight bounding box or we're in quality mode
29527:             if ((aBoundingBoxType != LOOSE_INK_EXTENTS || needsGlyphExtents) &&
29527:                 extents) {
 6247:                 PRUint32 glyphIndex = glyphData->GetSimpleGlyph();
 6247:                 PRUint16 extentsWidth = extents->GetContainedGlyphWidthAppUnits(glyphIndex);
25417:                 if (extentsWidth != gfxGlyphExtents::INVALID_WIDTH &&
25417:                     aBoundingBoxType == LOOSE_INK_EXTENTS) {
16510:                     UnionRange(x, &advanceMin, &advanceMax);
16510:                     UnionRange(x + direction*extentsWidth, &advanceMin, &advanceMax);
 6247:                 } else {
 9576:                     gfxRect glyphRect;
 9576:                     if (!extents->GetTightGlyphExtentsAppUnits(this,
 9576:                             aRefContext, glyphIndex, &glyphRect)) {
 9576:                         glyphRect = gfxRect(0, metrics.mBoundingBox.Y(),
 9576:                             advance, metrics.mBoundingBox.Height());
 9576:                     }
 6247:                     if (isRTL) {
 6247:                         glyphRect.pos.x -= advance;
 6247:                     }
 6247:                     glyphRect.pos.x += x;
 6247:                     metrics.mBoundingBox = metrics.mBoundingBox.Union(glyphRect);
 6247:                 }
 6247:             }
 6247:             x += direction*advance;
 7715:         } else {
 7715:             PRUint32 glyphCount = glyphData->GetGlyphCount();
    1:             const gfxTextRun::DetailedGlyph *details = aTextRun->GetDetailedGlyphs(i);
 7715:             PRUint32 j;
 7715:             for (j = 0; j < glyphCount; ++j, ++details) {
 6247:                 PRUint32 glyphIndex = details->mGlyphID;
 6247:                 gfxPoint glyphPt(x + details->mXOffset, details->mYOffset);
 6247:                 double advance = details->mAdvance;
 9576:                 gfxRect glyphRect;
 9576:                 if (glyphData->IsMissing() || !extents ||
 9576:                     !extents->GetTightGlyphExtentsAppUnits(this,
 9576:                             aRefContext, glyphIndex, &glyphRect)) {
 9576:                     // We might have failed to get glyph extents due to
 9576:                     // OOM or something
16510:                     glyphRect = gfxRect(0, -metrics.mAscent,
16510:                         advance, metrics.mAscent + metrics.mDescent);
 9576:                 }
 6247:                 if (isRTL) {
 6247:                     glyphRect.pos.x -= advance;
 6247:                 }
 6247:                 glyphRect.pos.x += x;
 6247:                 metrics.mBoundingBox = metrics.mBoundingBox.Union(glyphRect);
 6247:                 x += direction*advance;
 6247:             }
 6247:         }
 6247:         // Every other glyph type is ignored
 6247:         if (aSpacing) {
 6247:             double space = aSpacing[i - aStart].mAfter;
 6247:             if (i + 1 < aEnd) {
 6247:                 space += aSpacing[i + 1 - aStart].mBefore;
 6247:             }
 6247:             x += direction*space;
    1:         }
    1:     }
    1: 
25417:     if (aBoundingBoxType == LOOSE_INK_EXTENTS) {
16510:         UnionRange(x, &advanceMin, &advanceMax);
16510:         gfxRect fontBox(advanceMin, -metrics.mAscent,
16510:                         advanceMax - advanceMin, metrics.mAscent + metrics.mDescent);
16510:         metrics.mBoundingBox = metrics.mBoundingBox.Union(fontBox);
    1:     }
 6247:     if (isRTL) {
 6247:         metrics.mBoundingBox.pos.x -= x;
    1:     }
 6247: 
 6247:     metrics.mAdvanceWidth = x*direction;
    1:     return metrics;
    1: }
    1: 
43527: PRBool
39447: gfxFont::InitTextRun(gfxContext *aContext,
39447:                      gfxTextRun *aTextRun,
39447:                      const PRUnichar *aString,
39447:                      PRUint32 aRunStart,
43525:                      PRUint32 aRunLength,
43525:                      PRInt32 aRunScript)
39447: {
43527:     PRBool ok = PR_FALSE;
43527: 
43527:     if (mHarfBuzzShaper) {
43527:         if (gfxPlatform::GetPlatform()->UseHarfBuzzLevel() >=
43527:             gfxUnicodeProperties::ScriptShapingLevel(aRunScript)) {
43527:             ok = mHarfBuzzShaper->InitTextRun(aContext, aTextRun, aString,
43525:                                               aRunStart, aRunLength, aRunScript);
43527:         }
43527:     }
43527: 
43527:     if (!ok) {
43527:         if (!mPlatformShaper) {
43527:             CreatePlatformShaper();
43527:             NS_ASSERTION(mPlatformShaper, "no platform shaper available!");
43527:         }
43527:         if (mPlatformShaper) {
43527:             ok = mPlatformShaper->InitTextRun(aContext, aTextRun, aString,
43527:                                               aRunStart, aRunLength, aRunScript);
43527:         }
43527:     }
43527: 
39447:     NS_WARN_IF_FALSE(ok, "shaper failed, expect scrambled or missing text");
43527:     return ok;
39447: }
39447: 
 6247: gfxGlyphExtents *
 6247: gfxFont::GetOrCreateGlyphExtents(PRUint32 aAppUnitsPerDevUnit) {
 6247:     PRUint32 i;
 6247:     for (i = 0; i < mGlyphExtentsArray.Length(); ++i) {
 6247:         if (mGlyphExtentsArray[i]->GetAppUnitsPerDevUnit() == aAppUnitsPerDevUnit)
 6247:             return mGlyphExtentsArray[i];
 6247:     }
 6247:     gfxGlyphExtents *glyphExtents = new gfxGlyphExtents(aAppUnitsPerDevUnit);
 6247:     if (glyphExtents) {
 6247:         mGlyphExtentsArray.AppendElement(glyphExtents);
 6247:         // Initialize the extents of a space glyph, assuming that spaces don't
 6247:         // render anything!
 6247:         glyphExtents->SetContainedGlyphWidthAppUnits(GetSpaceGlyph(), 0);
 6247:     }
 6247:     return glyphExtents;
 6247: }
 6247: 
 6247: void
 6247: gfxFont::SetupGlyphExtents(gfxContext *aContext, PRUint32 aGlyphID, PRBool aNeedTight,
 6247:                            gfxGlyphExtents *aExtents)
 6247: {
14044:     gfxMatrix matrix = aContext->CurrentMatrix();
14044:     aContext->IdentityMatrix();
 6247:     cairo_glyph_t glyph;
 6247:     glyph.index = aGlyphID;
 6247:     glyph.x = 0;
 6247:     glyph.y = 0;
 6247:     cairo_text_extents_t extents;
 6247:     cairo_glyph_extents(aContext->GetCairo(), &glyph, 1, &extents);
14044:     aContext->SetMatrix(matrix);
 6247: 
 6247:     const Metrics& fontMetrics = GetMetrics();
 6247:     PRUint32 appUnitsPerDevUnit = aExtents->GetAppUnitsPerDevUnit();
 6247:     if (!aNeedTight && extents.x_bearing >= 0 &&
 6247:         extents.y_bearing >= -fontMetrics.maxAscent &&
 6247:         extents.height + extents.y_bearing <= fontMetrics.maxDescent) {
 6247:         PRUint32 appUnitsWidth =
 6247:             PRUint32(NS_ceil((extents.x_bearing + extents.width)*appUnitsPerDevUnit));
 6247:         if (appUnitsWidth < gfxGlyphExtents::INVALID_WIDTH) {
 6247:             aExtents->SetContainedGlyphWidthAppUnits(aGlyphID, PRUint16(appUnitsWidth));
 6247:             return;
 6247:         }
 6247:     }
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:     if (!aNeedTight) {
 6513:         ++gGlyphExtentsSetupFallBackToTight;
 6513:     }
 6513: #endif
 6247: 
 6247:     double d2a = appUnitsPerDevUnit;
 6247:     gfxRect bounds(extents.x_bearing*d2a, extents.y_bearing*d2a,
 6247:                    extents.width*d2a, extents.height*d2a);
 6247:     aExtents->SetTightGlyphExtents(aGlyphID, bounds);
 6247: }
 6247: 
47309: // Try to initialize font metrics by reading sfnt tables directly;
47309: // set mIsValid=TRUE and return TRUE on success.
47309: // Return FALSE if the gfxFontEntry subclass does not
47309: // implement GetFontTable(), or for non-sfnt fonts where tables are
47309: // not available.
47309: PRBool
47309: gfxFont::InitMetricsFromSfntTables(Metrics& aMetrics)
47309: {
47309:     mIsValid = PR_FALSE; // font is NOT valid in case of early return
47309: 
47309:     const PRUint32 kHeadTableTag = TRUETYPE_TAG('h','e','a','d');
47309:     const PRUint32 kHheaTableTag = TRUETYPE_TAG('h','h','e','a');
47309:     const PRUint32 kPostTableTag = TRUETYPE_TAG('p','o','s','t');
47309:     const PRUint32 kOS_2TableTag = TRUETYPE_TAG('O','S','/','2');
47309: 
47309:     if (mFUnitsConvFactor == 0.0) {
47309:         // If the conversion factor from FUnits is not yet set,
47309:         // 'head' table is required; otherwise we cannot read any metrics
47309:         // because we don't know unitsPerEm
47309:         nsAutoTArray<PRUint8,sizeof(HeadTable)> headData;
47309:         if (NS_FAILED(mFontEntry->GetFontTable(kHeadTableTag, headData)) ||
47309:             headData.Length() < sizeof(HeadTable)) {
47309:             return PR_FALSE; // no 'head' table -> not an sfnt
47309:         }
47309:         HeadTable *head = reinterpret_cast<HeadTable*>(headData.Elements());
47309:         PRUint32 unitsPerEm = head->unitsPerEm;
47309:         if (!unitsPerEm) {
47309:             return PR_TRUE; // is an sfnt, but not valid
47309:         }
47309:         mFUnitsConvFactor = mAdjustedSize / unitsPerEm;
47309:     }
47309: 
47309:     // 'hhea' table is required to get vertical extents
47309:     nsAutoTArray<PRUint8,sizeof(HheaTable)> hheaData;
47309:     if (NS_FAILED(mFontEntry->GetFontTable(kHheaTableTag, hheaData)) ||
47309:         hheaData.Length() < sizeof(HheaTable)) {
47309:         return PR_FALSE; // no 'hhea' table -> not an sfnt
47309:     }
47309:     HheaTable *hhea = reinterpret_cast<HheaTable*>(hheaData.Elements());
47309: 
47309: #define SET_UNSIGNED(field,src) aMetrics.field = PRUint16(src) * mFUnitsConvFactor
47309: #define SET_SIGNED(field,src)   aMetrics.field = PRInt16(src) * mFUnitsConvFactor
47309: 
47309:     SET_UNSIGNED(maxAdvance, hhea->advanceWidthMax);
47309:     SET_SIGNED(maxAscent, hhea->ascender);
47309:     SET_SIGNED(maxDescent, -PRInt16(hhea->descender));
47309:     SET_SIGNED(externalLeading, hhea->lineGap);
47309: 
47309:     // 'post' table is required for underline metrics
47309:     nsAutoTArray<PRUint8,sizeof(PostTable)> postData;
47309:     if (NS_FAILED(mFontEntry->GetFontTable(kPostTableTag, postData))) {
47309:         return PR_TRUE; // no 'post' table -> sfnt is not valid
47309:     }
47309:     if (postData.Length() <
47309:         offsetof(PostTable, underlineThickness) + sizeof(PRUint16)) {
47309:         return PR_TRUE; // bad post table -> sfnt is not valid
47309:     }
47309:     PostTable *post = reinterpret_cast<PostTable*>(postData.Elements());
47309: 
47309:     SET_SIGNED(underlineOffset, post->underlinePosition);
47309:     SET_UNSIGNED(underlineSize, post->underlineThickness);
47309: 
47309:     // 'OS/2' table is optional, if not found we'll estimate xHeight
47309:     // and aveCharWidth by measuring glyphs
47309:     nsAutoTArray<PRUint8,sizeof(OS2Table)> os2data;
47309:     if (NS_SUCCEEDED(mFontEntry->GetFontTable(kOS_2TableTag, os2data))) {
47309:         OS2Table *os2 = reinterpret_cast<OS2Table*>(os2data.Elements());
47309: 
47309:         if (os2data.Length() >= offsetof(OS2Table, sxHeight) +
47309:                                 sizeof(PRInt16) &&
47309:             PRUint16(os2->version) >= 2) {
47309:             // version 2 and later includes the x-height field
47309:             SET_SIGNED(xHeight, os2->sxHeight);
47309:             // PR_ABS because of negative xHeight seen in Kokonor (Tibetan) font
47309:             aMetrics.xHeight = PR_ABS(aMetrics.xHeight);
47309:         }
47309:         // this should always be present
47309:         if (os2data.Length() >= offsetof(OS2Table, yStrikeoutPosition) +
47309:                                 sizeof(PRInt16)) {
47309:             SET_SIGNED(aveCharWidth, os2->xAvgCharWidth);
47309:             SET_SIGNED(subscriptOffset, os2->ySubscriptYOffset);
47309:             SET_SIGNED(superscriptOffset, os2->ySuperscriptYOffset);
47309:             SET_SIGNED(strikeoutSize, os2->yStrikeoutSize);
47309:             SET_SIGNED(strikeoutOffset, os2->yStrikeoutPosition);
47309:         }
47309:     }
47309: 
47309:     mIsValid = PR_TRUE;
47309: 
47309:     return PR_TRUE;
47309: }
47309: 
47309: static double
47309: RoundToNearestMultiple(double aValue, double aFraction)
47309: {
47309:     return floor(aValue/aFraction + 0.5) * aFraction;
47309: }
47309: 
47309: void gfxFont::CalculateDerivedMetrics(Metrics& aMetrics)
47309: {
47309:     aMetrics.maxAscent =
47309:         NS_ceil(RoundToNearestMultiple(aMetrics.maxAscent, 1/1024.0));
47309:     aMetrics.maxDescent =
47309:         NS_ceil(RoundToNearestMultiple(aMetrics.maxDescent, 1/1024.0));
47309: 
47309:     if (aMetrics.xHeight <= 0) {
47309:         // only happens if we couldn't find either font metrics
47309:         // or a char to measure;
47309:         // pick an arbitrary value that's better than zero
47309:         aMetrics.xHeight = aMetrics.maxAscent * DEFAULT_XHEIGHT_FACTOR;
47309:     }
47309: 
47309:     aMetrics.maxHeight = aMetrics.maxAscent + aMetrics.maxDescent;
47309: 
47309:     if (aMetrics.maxHeight - aMetrics.emHeight > 0.0) {
47309:         aMetrics.internalLeading = aMetrics.maxHeight - aMetrics.emHeight;
47309:     } else {
47309:         aMetrics.internalLeading = 0.0;
47309:     }
47309: 
47309:     aMetrics.emAscent = aMetrics.maxAscent * aMetrics.emHeight
47309:                             / aMetrics.maxHeight;
47309:     aMetrics.emDescent = aMetrics.emHeight - aMetrics.emAscent;
47309: 
47309:     if (GetFontEntry()->IsFixedPitch()) {
47309:         // Some Quartz fonts are fixed pitch, but there's some glyph with a bigger
47309:         // advance than the average character width... this forces
47309:         // those fonts to be recognized like fixed pitch fonts by layout.
47309:         aMetrics.maxAdvance = aMetrics.aveCharWidth;
47309:     }
47309: 
47309:     if (!aMetrics.subscriptOffset) {
47309:         aMetrics.subscriptOffset = aMetrics.xHeight;
47309:     }
47309:     if (!aMetrics.superscriptOffset) {
47309:         aMetrics.superscriptOffset = aMetrics.xHeight;
47309:     }
47309: 
47309:     if (!aMetrics.strikeoutOffset) {
47309:         aMetrics.strikeoutOffset = aMetrics.xHeight * 0.5;
47309:     }
47309:     if (!aMetrics.strikeoutSize) {
47309:         aMetrics.strikeoutSize = aMetrics.underlineSize;
47309:     }
47309: }
47309: 
11765: void
12989: gfxFont::SanitizeMetrics(gfxFont::Metrics *aMetrics, PRBool aIsBadUnderlineFont)
11765: {
13714:     // Even if this font size is zero, this font is created with non-zero size.
13714:     // However, for layout and others, we should return the metrics of zero size font.
13714:     if (mStyle.size == 0) {
13714:         memset(aMetrics, 0, sizeof(gfxFont::Metrics));
13714:         return;
13714:     }
13714: 
11765:     // MS (P)Gothic and MS (P)Mincho are not having suitable values in their super script offset.
11765:     // If the values are not suitable, we should use x-height instead of them.
11765:     // See https://bugzilla.mozilla.org/show_bug.cgi?id=353632
40042:     if (aMetrics->superscriptOffset <= 0 ||
11765:         aMetrics->superscriptOffset >= aMetrics->maxAscent) {
11765:         aMetrics->superscriptOffset = aMetrics->xHeight;
11765:     }
11765:     // And also checking the case of sub script offset. The old gfx for win has checked this too.
40042:     if (aMetrics->subscriptOffset <= 0 ||
11765:         aMetrics->subscriptOffset >= aMetrics->maxAscent) {
11765:         aMetrics->subscriptOffset = aMetrics->xHeight;
11765:     }
11765: 
11765:     aMetrics->underlineSize = PR_MAX(1.0, aMetrics->underlineSize);
11765:     aMetrics->strikeoutSize = PR_MAX(1.0, aMetrics->strikeoutSize);
11765: 
11765:     aMetrics->underlineOffset = PR_MIN(aMetrics->underlineOffset, -1.0);
11765: 
14253:     if (aMetrics->maxAscent < 1.0) {
14253:         // We cannot draw strikeout line and overline in the ascent...
14253:         aMetrics->underlineSize = 0;
14253:         aMetrics->underlineOffset = 0;
14253:         aMetrics->strikeoutSize = 0;
14253:         aMetrics->strikeoutOffset = 0;
14253:         return;
14253:     }
14253: 
12989:     /**
12989:      * Some CJK fonts have bad underline offset. Therefore, if this is such font,
12989:      * we need to lower the underline offset to bottom of *em* descent.
12989:      * However, if this is system font, we should not do this for the rendering compatibility with
12989:      * another application's UI on the platform.
14253:      * XXX Should not use this hack if the font size is too small?
14253:      *     Such text cannot be read, this might be used for tight CSS rendering? (E.g., Acid2)
12989:      */
12989:     if (!mStyle.systemFont && aIsBadUnderlineFont) {
12989:         // First, we need 2 pixels between baseline and underline at least. Because many CJK characters
12989:         // put their glyphs on the baseline, so, 1 pixel is too close for CJK characters.
12989:         aMetrics->underlineOffset = PR_MIN(aMetrics->underlineOffset, -2.0);
11765: 
12989:         // Next, we put the underline to bottom of below of the descent space.
12989:         if (aMetrics->internalLeading + aMetrics->externalLeading > aMetrics->underlineSize) {
12989:             aMetrics->underlineOffset = PR_MIN(aMetrics->underlineOffset, -aMetrics->emDescent);
12989:         } else {
12989:             aMetrics->underlineOffset = PR_MIN(aMetrics->underlineOffset,
12989:                                                aMetrics->underlineSize - aMetrics->emDescent);
12989:         }
12989:     }
11765:     // If underline positioned is too far from the text, descent position is preferred so that underline
11765:     // will stay within the boundary.
12989:     else if (aMetrics->underlineSize - aMetrics->underlineOffset > aMetrics->maxDescent) {
14253:         if (aMetrics->underlineSize > aMetrics->maxDescent)
14253:             aMetrics->underlineSize = PR_MAX(aMetrics->maxDescent, 1.0);
14253:         // The max underlineOffset is 1px (the min underlineSize is 1px, and min maxDescent is 0px.)
11765:         aMetrics->underlineOffset = aMetrics->underlineSize - aMetrics->maxDescent;
14253:     }
14253: 
14253:     // If strikeout line is overflowed from the ascent, the line should be resized and moved for
14253:     // that being in the ascent space.
14253:     // Note that the strikeoutOffset is *middle* of the strikeout line position.
14253:     gfxFloat halfOfStrikeoutSize = NS_floor(aMetrics->strikeoutSize / 2.0 + 0.5);
14253:     if (halfOfStrikeoutSize + aMetrics->strikeoutOffset > aMetrics->maxAscent) {
14253:         if (aMetrics->strikeoutSize > aMetrics->maxAscent) {
14253:             aMetrics->strikeoutSize = PR_MAX(aMetrics->maxAscent, 1.0);
14253:             halfOfStrikeoutSize = NS_floor(aMetrics->strikeoutSize / 2.0 + 0.5);
14253:         }
14253:         gfxFloat ascent = NS_floor(aMetrics->maxAscent + 0.5);
14253:         aMetrics->strikeoutOffset = PR_MAX(halfOfStrikeoutSize, ascent / 2.0);
14253:     }
14253: 
14253:     // If overline is larger than the ascent, the line should be resized.
14253:     if (aMetrics->underlineSize > aMetrics->maxAscent) {
14253:         aMetrics->underlineSize = aMetrics->maxAscent;
12989:     }
11765: }
11765: 
 6513: gfxGlyphExtents::~gfxGlyphExtents()
 6513: {
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:     gGlyphExtentsWidthsTotalSize += mContainedGlyphWidths.ComputeSize();
 6513:     gGlyphExtentsCount++;
 6513: #endif
 6513:     MOZ_COUNT_DTOR(gfxGlyphExtents);
 6513: }
 6513: 
 9576: PRBool
 6247: gfxGlyphExtents::GetTightGlyphExtentsAppUnits(gfxFont *aFont,
 9576:     gfxContext *aContext, PRUint32 aGlyphID, gfxRect *aExtents)
 6247: {
 6247:     HashEntry *entry = mTightGlyphExtents.GetEntry(aGlyphID);
 6247:     if (!entry) {
 9576:         if (!aContext) {
 9576:             NS_WARNING("Could not get glyph extents (no aContext)");
 9576:             return PR_FALSE;
 9576:         }
 9576: 
 6247:         aFont->SetupCairoFont(aContext);
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:         ++gGlyphExtentsSetupLazyTight;
 6513: #endif
 6247:         aFont->SetupGlyphExtents(aContext, aGlyphID, PR_TRUE, this);
 6247:         entry = mTightGlyphExtents.GetEntry(aGlyphID);
 6247:         if (!entry) {
 6247:             NS_WARNING("Could not get glyph extents");
 9576:             return PR_FALSE;
 6247:         }
 6247:     }
 6247: 
 9576:     *aExtents = gfxRect(entry->x, entry->y, entry->width, entry->height);
 9576:     return PR_TRUE;
 6247: }
 6247: 
 6513: gfxGlyphExtents::GlyphWidths::~GlyphWidths()
 6513: {
 6513:     PRUint32 i;
 6513:     for (i = 0; i < mBlocks.Length(); ++i) {
 6513:         PtrBits bits = mBlocks[i];
 6513:         if (bits && !(bits & 0x1)) {
 6513:             delete[] reinterpret_cast<PRUint16 *>(bits);
 6513:         }
 6513:     }
 6513: }
 6513: 
 6513: #ifdef DEBUG
 6513: PRUint32
 6513: gfxGlyphExtents::GlyphWidths::ComputeSize()
 6513: {
 6513:     PRUint32 i;
 6513:     PRUint32 size = mBlocks.Capacity()*sizeof(PtrBits);
 6513:     for (i = 0; i < mBlocks.Length(); ++i) {
 6513:         PtrBits bits = mBlocks[i];
 6513:         if (bits && !(bits & 0x1)) {
 6513:             size += BLOCK_SIZE*sizeof(PRUint16);
 6513:         }
 6513:     }
 6513:     return size;
 6513: }
 6513: #endif
 6513: 
 6496: void
 6513: gfxGlyphExtents::GlyphWidths::Set(PRUint32 aGlyphID, PRUint16 aWidth)
 6493: {
 6513:     PRUint32 block = aGlyphID >> BLOCK_SIZE_BITS;
 6513:     PRUint32 len = mBlocks.Length();
 6513:     if (block >= len) {
 6513:         PtrBits *elems = mBlocks.AppendElements(block + 1 - len);
 6247:         if (!elems)
 6247:             return;
 6513:         memset(elems, 0, sizeof(PtrBits)*(block + 1 - len));
 6513:     }
 6513: 
 6513:     PtrBits bits = mBlocks[block];
 6513:     PRUint32 glyphOffset = aGlyphID & (BLOCK_SIZE - 1);
 6513:     if (!bits) {
 6513:         mBlocks[block] = MakeSingle(glyphOffset, aWidth);
 6513:         return;
 6513:     }
 6513: 
 6513:     PRUint16 *newBlock;
 6513:     if (bits & 0x1) {
 6513:         // Expand the block to a real block. We could avoid this by checking
 6513:         // glyphOffset == GetGlyphOffset(bits), but that never happens so don't bother
 6513:         newBlock = new PRUint16[BLOCK_SIZE];
 6513:         if (!newBlock)
 6513:             return;
 6496:         PRUint32 i;
 6513:         for (i = 0; i < BLOCK_SIZE; ++i) {
 6513:             newBlock[i] = INVALID_WIDTH;
 6247:         }
 6513:         newBlock[GetGlyphOffset(bits)] = GetWidth(bits);
 6513:         mBlocks[block] = reinterpret_cast<PtrBits>(newBlock);
 6513:     } else {
 6513:         newBlock = reinterpret_cast<PRUint16 *>(bits);
 6247:     }
 6513:     newBlock[glyphOffset] = aWidth;
 6247: }
 6247: 
 6247: void
 6247: gfxGlyphExtents::SetTightGlyphExtents(PRUint32 aGlyphID, const gfxRect& aExtentsAppUnits)
 6247: {
 6247:     HashEntry *entry = mTightGlyphExtents.PutEntry(aGlyphID);
 6247:     if (!entry)
 6247:         return;
 6247:     entry->x = aExtentsAppUnits.pos.x;
 6247:     entry->y = aExtentsAppUnits.pos.y;
 6247:     entry->width = aExtentsAppUnits.size.width;
 6247:     entry->height = aExtentsAppUnits.size.height;
 6247: }
 6247: 
19962: gfxFontGroup::gfxFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle, gfxUserFontSet *aUserFontSet)
14253:     : mFamilies(aFamilies), mStyle(*aStyle), mUnderlineOffset(UNDERLINE_OFFSET_NOT_SET)
    1: {
19962:     mUserFontSet = nsnull;
19962:     SetUserFontSet(aUserFontSet);
37211: 
38493:     mPageLang = gfxPlatform::GetFontPrefLangFor(mStyle.language);
38461:     BuildFontList();
38461: }
38461: 
38461: void
38461: gfxFontGroup::BuildFontList()
38461: {
37211: // "#if" to be removed once all platforms are moved to gfxPlatformFontList interface
37211: // and subclasses of gfxFontGroup eliminated
48022: #if defined(XP_MACOSX) || (defined(XP_WIN) && !defined(WINCE)) || defined(ANDROID)
37211:     ForEachFont(FindPlatformFont, this);
37211: 
37211:     if (mFonts.Length() == 0) {
37211:         PRBool needsBold;
40680:         gfxPlatformFontList *pfl = gfxPlatformFontList::PlatformFontList();
40680:         gfxFontEntry *defaultFont = pfl->GetDefaultFont(&mStyle, needsBold);
37211:         NS_ASSERTION(defaultFont, "invalid default font returned by GetDefaultFont");
37211: 
40680:         if (defaultFont) {
40680:             nsRefPtr<gfxFont> font = defaultFont->FindOrMakeFont(&mStyle,
40680:                                                                  needsBold);
37211:             if (font) {
37211:                 mFonts.AppendElement(font);
37211:             }
37211:         }
37211: 
40680:         if (mFonts.Length() == 0) {
40680:             // Try for a "font of last resort...."
40680:             // Because an empty font list would be Really Bad for later code
40680:             // that assumes it will be able to get valid metrics for layout,
40680:             // just look for the first usable font and put in the list.
40680:             // (see bug 554544)
40680:             nsAutoTArray<nsRefPtr<gfxFontFamily>,200> families;
40680:             pfl->GetFontFamilyList(families);
40680:             for (PRUint32 i = 0; i < families.Length(); ++i) {
40680:                 gfxFontEntry *fe = families[i]->FindFontForStyle(mStyle,
40680:                                                                  needsBold);
40680:                 if (fe) {
40680:                     nsRefPtr<gfxFont> font = fe->FindOrMakeFont(&mStyle,
40680:                                                                 needsBold);
40680:                     if (font) {
40680:                         mFonts.AppendElement(font);
40680:                         break;
40680:                     }
40680:                 }
40680:             }
40680:         }
40680: 
40680:         if (mFonts.Length() == 0) {
40680:             // an empty font list at this point is fatal; we're not going to
40680:             // be able to do even the most basic layout operations
40680:             char msg[256]; // CHECK buffer length if revising message below
40680:             sprintf(msg, "unable to find a usable font (%.220s)",
40680:                     NS_ConvertUTF16toUTF8(mFamilies).get());
40680:             NS_RUNTIMEABORT(msg);
40680:         }
40680:     }
40680: 
37211:     if (!mStyle.systemFont) {
37211:         for (PRUint32 i = 0; i < mFonts.Length(); ++i) {
37211:             gfxFont* font = mFonts[i];
37211:             if (font->GetFontEntry()->mIsBadUnderlineFont) {
37211:                 gfxFloat first = mFonts[0]->GetMetrics().underlineOffset;
37211:                 gfxFloat bad = font->GetMetrics().underlineOffset;
37211:                 mUnderlineOffset = PR_MIN(first, bad);
37211:                 break;
37211:             }
37211:         }
37211:     }
37211: #endif
37211: }
37211: 
37211: PRBool
37211: gfxFontGroup::FindPlatformFont(const nsAString& aName,
37211:                                const nsACString& aGenericName,
37211:                                void *aClosure)
37211: {
37211:     gfxFontGroup *fontGroup = static_cast<gfxFontGroup*>(aClosure);
37211:     const gfxFontStyle *fontStyle = fontGroup->GetStyle();
37211: 
37211: 
37211:     PRBool needsBold;
37211:     gfxFontEntry *fe = nsnull;
37211: 
37211:     // first, look up in the user font set
37211:     gfxUserFontSet *fs = fontGroup->GetUserFontSet();
37211:     if (fs) {
37211:         fe = fs->FindFontEntry(aName, *fontStyle, needsBold);
37211:     }
37211: 
37211:     // nothing in the user font set ==> check system fonts
37211:     if (!fe) {
37211:         fe = gfxPlatformFontList::PlatformFontList()->
37211:             FindFontForFamily(aName, fontStyle, needsBold);
37211:     }
37211: 
37211:     // add to the font group, unless it's already there
37211:     if (fe && !fontGroup->HasFont(fe)) {
38202:         nsRefPtr<gfxFont> font = fe->FindOrMakeFont(fontStyle, needsBold);
37211:         if (font) {
37211:             fontGroup->mFonts.AppendElement(font);
37211:         }
37211:     }
37211: 
37211:     return PR_TRUE;
37211: }
37211: 
37211: PRBool
37211: gfxFontGroup::HasFont(const gfxFontEntry *aFontEntry)
37211: {
37211:     for (PRUint32 i = 0; i < mFonts.Length(); ++i) {
37211:         if (mFonts.ElementAt(i)->GetFontEntry() == aFontEntry)
37211:             return PR_TRUE;
37211:     }
37211:     return PR_FALSE;
19962: }
    1: 
19962: gfxFontGroup::~gfxFontGroup() {
19962:     mFonts.Clear();
19962:     SetUserFontSet(nsnull);
19962: }
19962: 
37211: gfxFontGroup *
37211: gfxFontGroup::Copy(const gfxFontStyle *aStyle)
37211: {
37211:     return new gfxFontGroup(mFamilies, aStyle, mUserFontSet);
37211: }
19962: 
19962: PRBool 
19962: gfxFontGroup::IsInvalidChar(PRUnichar ch) {
19962:     if (ch >= 32) {
19962:         return ch == 0x0085/*NEL*/ ||
19962:             ((ch & 0xFF00) == 0x2000 /* Unicode control character */ &&
19962:              (ch == 0x200B/*ZWSP*/ || ch == 0x2028/*LSEP*/ || ch == 0x2029/*PSEP*/ ||
19962:               IS_BIDI_CONTROL_CHAR(ch)));
19962:     }
19962:     // We could just blacklist all control characters, but it seems better
19962:     // to only blacklist the ones we know cause problems for native font
19962:     // engines.
19962:     return ch == 0x0B || ch == '\t' || ch == '\r' || ch == '\n' || ch == '\f' ||
19962:         (ch >= 0x1c && ch <= 0x1f);
    1: }
    1: 
    1: PRBool
    1: gfxFontGroup::ForEachFont(FontCreationCallback fc,
    1:                           void *closure)
    1: {
38492:     return ForEachFontInternal(mFamilies, mStyle.language,
10774:                                PR_TRUE, PR_TRUE, fc, closure);
    1: }
    1: 
    1: PRBool
    1: gfxFontGroup::ForEachFont(const nsAString& aFamilies,
38493:                           nsIAtom *aLanguage,
    1:                           FontCreationCallback fc,
    1:                           void *closure)
    1: {
38492:     return ForEachFontInternal(aFamilies, aLanguage,
10774:                                PR_FALSE, PR_TRUE, fc, closure);
    1: }
    1: 
    1: struct ResolveData {
    1:     ResolveData(gfxFontGroup::FontCreationCallback aCallback,
    1:                 nsACString& aGenericFamily,
    1:                 void *aClosure) :
    1:         mCallback(aCallback),
    1:         mGenericFamily(aGenericFamily),
    1:         mClosure(aClosure) {
  731:     }
    1:     gfxFontGroup::FontCreationCallback mCallback;
    1:     nsCString mGenericFamily;
    1:     void *mClosure;
    1: };
    1: 
    1: PRBool
    1: gfxFontGroup::ForEachFontInternal(const nsAString& aFamilies,
38493:                                   nsIAtom *aLanguage,
    1:                                   PRBool aResolveGeneric,
10774:                                   PRBool aResolveFontName,
    1:                                   FontCreationCallback fc,
    1:                                   void *closure)
    1: {
    1:     const PRUnichar kSingleQuote  = PRUnichar('\'');
    1:     const PRUnichar kDoubleQuote  = PRUnichar('\"');
    1:     const PRUnichar kComma        = PRUnichar(',');
    1: 
38493:     nsIAtom *groupAtom = nsnull;
38493:     nsCAutoString groupString;
38493:     if (aLanguage) {
38492:         if (!gLangService) {
38492:             CallGetService(NS_LANGUAGEATOMSERVICE_CONTRACTID, &gLangService);
38492:         }
38492:         if (gLangService) {
38492:             nsresult rv;
38493:             groupAtom = gLangService->GetLanguageGroup(aLanguage, &rv);
38493:         }
38493:     }
38493:     if (!groupAtom) {
38493:         groupAtom = gfxAtoms::x_unicode;
38493:     }
38493:     groupAtom->ToUTF8String(groupString);
38492: 
26915:     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1: 
    1:     nsPromiseFlatString families(aFamilies);
    1:     const PRUnichar *p, *p_end;
    1:     families.BeginReading(p);
    1:     families.EndReading(p_end);
    1:     nsAutoString family;
    1:     nsCAutoString lcFamily;
    1:     nsAutoString genericFamily;
26915:     nsXPIDLCString value;
    1: 
    1:     while (p < p_end) {
40783:         while (nsCRT::IsAsciiSpace(*p) || *p == kComma)
    1:             if (++p == p_end)
    1:                 return PR_TRUE;
    1: 
    1:         PRBool generic;
    1:         if (*p == kSingleQuote || *p == kDoubleQuote) {
    1:             // quoted font family
    1:             PRUnichar quoteMark = *p;
    1:             if (++p == p_end)
    1:                 return PR_TRUE;
    1:             const PRUnichar *nameStart = p;
    1: 
    1:             // XXX What about CSS character escapes?
    1:             while (*p != quoteMark)
    1:                 if (++p == p_end)
    1:                     return PR_TRUE;
    1: 
    1:             family = Substring(nameStart, p);
    1:             generic = PR_FALSE;
    1:             genericFamily.SetIsVoid(PR_TRUE);
    1: 
    1:             while (++p != p_end && *p != kComma)
    1:                 /* nothing */ ;
    1: 
    1:         } else {
    1:             // unquoted font family
    1:             const PRUnichar *nameStart = p;
    1:             while (++p != p_end && *p != kComma)
    1:                 /* nothing */ ;
    1: 
    1:             family = Substring(nameStart, p);
    1:             family.CompressWhitespace(PR_FALSE, PR_TRUE);
    1: 
    1:             if (aResolveGeneric &&
    1:                 (family.LowerCaseEqualsLiteral("serif") ||
    1:                  family.LowerCaseEqualsLiteral("sans-serif") ||
    1:                  family.LowerCaseEqualsLiteral("monospace") ||
    1:                  family.LowerCaseEqualsLiteral("cursive") ||
    1:                  family.LowerCaseEqualsLiteral("fantasy")))
    1:             {
    1:                 generic = PR_TRUE;
    1: 
    1:                 ToLowerCase(NS_LossyConvertUTF16toASCII(family), lcFamily);
    1: 
    1:                 nsCAutoString prefName("font.name.");
    1:                 prefName.Append(lcFamily);
    1:                 prefName.AppendLiteral(".");
38493:                 prefName.Append(groupString);
    1: 
    1:                 // prefs file always uses (must use) UTF-8 so that we can use
    1:                 // |GetCharPref| and treat the result as a UTF-8 string.
26915:                 nsresult rv = prefs->GetCharPref(prefName.get(), getter_Copies(value));
    1:                 if (NS_SUCCEEDED(rv)) {
    1:                     CopyASCIItoUTF16(lcFamily, genericFamily);
26915:                     CopyUTF8toUTF16(value, family);
    1:                 }
    1:             } else {
    1:                 generic = PR_FALSE;
    1:                 genericFamily.SetIsVoid(PR_TRUE);
    1:             }
    1:         }
    1: 
16897:         if (generic) {
38493:             ForEachFontInternal(family, groupAtom, PR_FALSE,
38492:                                 aResolveFontName, fc, closure);
16897:         } else if (!family.IsEmpty()) {
    1:             NS_LossyConvertUTF16toASCII gf(genericFamily);
10774:             if (aResolveFontName) {
    1:                 ResolveData data(fc, gf, closure);
21955:                 PRBool aborted = PR_FALSE, needsBold;
19962:                 nsresult rv;
19962: 
19962:                 if (mUserFontSet && mUserFontSet->FindFontEntry(family, mStyle, needsBold)) {
19962:                     gfxFontGroup::FontResolverProc(family, &data);
19962:                     rv = NS_OK;
19962:                 } else {
    1:                     gfxPlatform *pf = gfxPlatform::GetPlatform();
19962:                     rv = pf->ResolveFontName(family,
    1:                                                   gfxFontGroup::FontResolverProc,
    1:                                                   &data, aborted);
19962:                 }
    1:                 if (NS_FAILED(rv) || aborted)
    1:                     return PR_FALSE;
    1:             }
10774:             else {
10774:                 if (!fc(family, gf, closure))
10774:                     return PR_FALSE;
10774:             }
10774:         }
    1: 
    1:         if (generic && aResolveGeneric) {
    1:             nsCAutoString prefName("font.name-list.");
    1:             prefName.Append(lcFamily);
    1:             prefName.AppendLiteral(".");
38493:             prefName.Append(groupString);
26915:             nsresult rv = prefs->GetCharPref(prefName.get(), getter_Copies(value));
    1:             if (NS_SUCCEEDED(rv)) {
26915:                 ForEachFontInternal(NS_ConvertUTF8toUTF16(value),
38493:                                     groupAtom, PR_FALSE, aResolveFontName,
10774:                                     fc, closure);
    1:             }
    1:         }
    1: 
    1:         ++p; // may advance past p_end
    1:     }
    1: 
    1:     return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: gfxFontGroup::FontResolverProc(const nsAString& aName, void *aClosure)
    1: {
    1:     ResolveData *data = reinterpret_cast<ResolveData*>(aClosure);
    1:     return (data->mCallback)(aName, data->mGenericFamily, data->mClosure);
    1: }
    1: 
    1: gfxTextRun *
 1295: gfxFontGroup::MakeEmptyTextRun(const Parameters *aParams, PRUint32 aFlags)
    1: {
 1295:     aFlags |= TEXT_IS_8BIT | TEXT_IS_ASCII | TEXT_IS_PERSISTENT;
 8081:     return gfxTextRun::Create(aParams, nsnull, 0, this, aFlags);
 1295: }
 1100: 
 1295: gfxTextRun *
 1295: gfxFontGroup::MakeSpaceTextRun(const Parameters *aParams, PRUint32 aFlags)
 1295: {
 1295:     aFlags |= TEXT_IS_8BIT | TEXT_IS_ASCII | TEXT_IS_PERSISTENT;
 1100:     static const PRUint8 space = ' ';
 1100: 
 1295:     nsAutoPtr<gfxTextRun> textRun;
 8081:     textRun = gfxTextRun::Create(aParams, &space, 1, this, aFlags);
 8081:     if (!textRun)
 1100:         return nsnull;
 2317: 
 2317:     gfxFont *font = GetFontAt(0);
10243:     if (NS_UNLIKELY(GetStyle()->size == 0)) {
10243:         // Short-circuit for size-0 fonts, as Windows and ATSUI can't handle
10243:         // them, and always create at least size 1 fonts, i.e. they still
10243:         // render something for size 0 fonts.
10243:         textRun->AddGlyphRun(font, 0);
10243:     }
10243:     else {
 2317:         textRun->SetSpaceGlyph(font, aParams->mContext, 0);
10243:     }
 6247:     // Note that the gfxGlyphExtents glyph bounds storage for the font will
 6247:     // always contain an entry for the font's space glyph, so we don't have
 6247:     // to call FetchGlyphExtents here.
 1295:     return textRun.forget();
    1: }
    1: 
37211: #define UNICODE_LRO 0x202d
37211: #define UNICODE_RLO 0x202e
37211: #define UNICODE_PDF 0x202c
37211: 
37211: inline void
37211: AppendDirectionalIndicatorStart(PRUint32 aFlags, nsAString& aString)
37211: {
37211:     static const PRUnichar overrides[2] = { UNICODE_LRO, UNICODE_RLO };
37211:     aString.Append(overrides[(aFlags & gfxTextRunFactory::TEXT_IS_RTL) != 0]);    
37211:     aString.Append(' ');
37211: }
37211: 
37211: inline void
37211: AppendDirectionalIndicatorEnd(PRBool aNeedDirection, nsAString& aString)
37211: {
37211:     // append a space (always, for consistent treatment of last char,
37211:     // and a direction control if required (we skip this for 8-bit text,
37211:     // which is known to be unidirectional LTR, unless the direction was
37211:     // forced RTL via overrides)
37211:     aString.Append(' ');
37211:     if (!aNeedDirection)
37211:         return;
37211: 
37211:     aString.Append('.');
37211:     aString.Append(UNICODE_PDF);
37211: }
37211: 
37211: gfxTextRun *
37211: gfxFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
37211:                           const Parameters *aParams, PRUint32 aFlags)
37211: {
37211:     NS_ASSERTION(aLength > 0, "should use MakeEmptyTextRun for zero-length text");
37211:     NS_ASSERTION(aFlags & TEXT_IS_8BIT, "should be marked 8bit");
37211:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
37211:     if (!textRun)
37211:         return nsnull;
37211: 
37211:     nsDependentCSubstring cString(reinterpret_cast<const char*>(aString),
37211:                                   reinterpret_cast<const char*>(aString) + aLength);
37211: 
37211:     nsAutoString utf16;
37211:     AppendASCIItoUTF16(cString, utf16);
37211: 
39206:     InitTextRun(aParams->mContext, textRun, utf16.get(), utf16.Length());
37211: 
37211:     textRun->FetchGlyphExtents(aParams->mContext);
37211: 
37211:     return textRun;
37211: }
37211: 
37211: gfxTextRun *
37211: gfxFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,
37211:                           const Parameters *aParams, PRUint32 aFlags)
37211: {
37211:     NS_ASSERTION(aLength > 0, "should use MakeEmptyTextRun for zero-length text");
37211:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
37211:     if (!textRun)
37211:         return nsnull;
37211: 
37211:     gfxPlatform::GetPlatform()->SetupClusterBoundaries(textRun, aString);
37211: 
39206:     InitTextRun(aParams->mContext, textRun, aString, aLength);
37211: 
37211:     textRun->FetchGlyphExtents(aParams->mContext);
37211: 
37211:     return textRun;
37211: }
37211: 
37211: #define SMALL_GLYPH_RUN 128 // preallocated size of our auto arrays for per-glyph data;
37211:                             // some testing indicates that 90%+ of glyph runs will fit
37211:                             // without requiring a separate allocation
37211: 
37211: void
39206: gfxFontGroup::InitTextRun(gfxContext *aContext,
39206:                           gfxTextRun *aTextRun,
37211:                           const PRUnichar *aString,
37211:                           PRUint32 aLength)
37211: {
43525:     // split into script runs so that script can potentially influence
43525:     // the font matching process below
43525:     gfxScriptItemizer scriptRuns(aString, aLength);
43525: 
43525:     PRUint32 runStart = 0, runLimit = aLength;
43525:     PRInt32 runScript = HB_SCRIPT_LATIN;
43525:     while (scriptRuns.Next(runStart, runLimit, runScript)) {
43525:         InitTextRun(aContext, aTextRun, aString, aLength,
43525:                     runStart, runLimit, runScript);
43525:     }
43525: }
43525: 
43525: void
43525: gfxFontGroup::InitTextRun(gfxContext *aContext,
43525:                           gfxTextRun *aTextRun,
43525:                           const PRUnichar *aString,
43525:                           PRUint32 aTotalLength,
43525:                           PRUint32 aScriptRunStart,
43525:                           PRUint32 aScriptRunEnd,
43525:                           PRInt32 aRunScript)
43525: {
37211:     gfxFont *mainFont = mFonts[0].get();
37211: 
43525:     PRUint32 runStart = aScriptRunStart;
37211:     nsAutoTArray<gfxTextRange,3> fontRanges;
43525:     ComputeRanges(fontRanges, aString, aScriptRunStart, aScriptRunEnd);
37211:     PRUint32 numRanges = fontRanges.Length();
37211: 
37211:     for (PRUint32 r = 0; r < numRanges; r++) {
37211:         const gfxTextRange& range = fontRanges[r];
37211:         PRUint32 matchedLength = range.Length();
37211:         gfxFont *matchedFont = (range.font ? range.font.get() : nsnull);
37211: 
49395:         // create the glyph run for this range
49395:         aTextRun->AddGlyphRun(matchedFont ? matchedFont : mainFont,
49395:                               runStart, (matchedLength > 0));
37211:         if (matchedFont) {
39206:             // do glyph layout and record the resulting positioned glyphs
49395:             if (!matchedFont->InitTextRun(aContext, aTextRun, aString,
49395:                                           runStart, matchedLength,
49395:                                           aRunScript)) {
49395:                 // glyph layout failed! treat as missing glyphs
49395:                 matchedFont = nsnull;
49395:             }
49395:         }
49395:         if (!matchedFont) {
37211:             for (PRUint32 index = runStart; index < runStart + matchedLength; index++) {
37211:                 // Record the char code so we can draw a box with the Unicode value
37211:                 if (NS_IS_HIGH_SURROGATE(aString[index]) &&
43525:                     index + 1 < aScriptRunEnd &&
37211:                     NS_IS_LOW_SURROGATE(aString[index+1])) {
37211:                     aTextRun->SetMissingGlyph(index,
37211:                                               SURROGATE_TO_UCS4(aString[index],
37211:                                                                 aString[index+1]));
37211:                     index++;
37211:                 } else {
37211:                     aTextRun->SetMissingGlyph(index, aString[index]);
37211:                 }
37211:             }
37211:         }
37211: 
37211:         runStart += matchedLength;
37211:     }
37211: 
37211:     // It's possible for CoreText to omit glyph runs if it decides they contain
37211:     // only invisibles (e.g., U+FEFF, see reftest 474417-1). In this case, we
37211:     // need to eliminate them from the glyph run array to avoid drawing "partial
37211:     // ligatures" with the wrong font.
37211:     aTextRun->SanitizeGlyphRuns();
37211: 
37211:     // Is this actually necessary? Without it, gfxTextRun::CopyGlyphDataFrom may assert
37211:     // "Glyphruns not coalesced", but does that matter?
37211:     aTextRun->SortGlyphRuns();
47360: 
47360: #ifdef DUMP_TEXT_RUNS
47360:     nsCAutoString lang;
47360:     style->language->ToUTF8String(lang);
47360:     PR_LOG(gFontSelection, PR_LOG_DEBUG,\
47360:            ("InitTextRun %p fontgroup %p (%s) lang: %s len %d features: %s "
47360:             "TEXTRUN \"%s\" ENDTEXTRUN\n",
47360:             aTextRun, this,
47360:             NS_ConvertUTF16toUTF8(mFamilies).get(),
47360:             lang.get(), aLength,
47360:             NS_ConvertUTF16toUTF8(mStyle.featureSettings).get(),
47360:             NS_ConvertUTF16toUTF8(aString, aLength).get()) );
47360: #endif
47360: }
16418: 
16418: 
16418: already_AddRefed<gfxFont>
16418: gfxFontGroup::FindFontForChar(PRUint32 aCh, PRUint32 aPrevCh, PRUint32 aNextCh, gfxFont *aPrevMatchedFont)
16418: {
16418:     nsRefPtr<gfxFont>    selectedFont;
16418: 
36291:     // if this character or the previous one is a join-causer,
36291:     // use the same font as the previous range if we can
36291:     if (gfxFontUtils::IsJoinCauser(aCh) || gfxFontUtils::IsJoinCauser(aPrevCh)) {
16418:         if (aPrevMatchedFont && aPrevMatchedFont->HasCharacter(aCh)) {
16418:             selectedFont = aPrevMatchedFont;
16418:             return selectedFont.forget();
16418:         }
16418:     }
16418: 
42989:     // if this character is a variation selector,
42989:     // use the previous font regardless of whether it supports VS or not.
42989:     // otherwise the text run will be divided.
42989:     if (gfxFontUtils::IsVarSelector(aCh)) {
42989:         if (aPrevMatchedFont) {
42989:             selectedFont = aPrevMatchedFont;
42989:             return selectedFont.forget();
42989:         }
42989:         // VS alone. it's meaningless to search different fonts
42989:         return nsnull;
42989:     }
42989: 
16418:     // 1. check fonts in the font group
16418:     for (PRUint32 i = 0; i < FontListLength(); i++) {
16418:         nsRefPtr<gfxFont> font = GetFontAt(i);
16418:         if (font->HasCharacter(aCh))
16418:             return font.forget();
16418:     }
16418: 
16418:     // if character is in Private Use Area, don't do matching against pref or system fonts
16418:     if ((aCh >= 0xE000  && aCh <= 0xF8FF) || (aCh >= 0xF0000 && aCh <= 0x10FFFD))
16418:         return nsnull;
16418: 
16418:     // 2. search pref fonts
16418:     if ((selectedFont = WhichPrefFontSupportsChar(aCh))) {
16418:         return selectedFont.forget();
16418:     }
16418: 
16418:     // 3. use fallback fonts
16418:     // -- before searching for something else check the font used for the previous character
16418:     if (!selectedFont && aPrevMatchedFont && aPrevMatchedFont->HasCharacter(aCh)) {
16418:         selectedFont = aPrevMatchedFont;
16418:         return selectedFont.forget();
16418:     }
16418: 
16418:     // -- otherwise look for other stuff
16418:     if (!selectedFont) {
16418:         selectedFont = WhichSystemFontSupportsChar(aCh);
16418:         return selectedFont.forget();
16418:     }
16418: 
16418:     return nsnull;
16418: }
16418: 
16418: 
16418: void gfxFontGroup::ComputeRanges(nsTArray<gfxTextRange>& aRanges, const PRUnichar *aString, PRUint32 begin, PRUint32 end)
16418: {
16418:     const PRUnichar *str = aString + begin;
16418:     PRUint32 len = end - begin;
16418: 
16418:     aRanges.Clear();
16418: 
27156:     if (len == 0) {
27156:         return;
27156:     }
27156: 
16418:     PRUint32 prevCh = 0;
16418:     for (PRUint32 i = 0; i < len; i++) {
16418: 
16418:         const PRUint32 origI = i; // save off in case we increase for surrogate
16418: 
16418:         // set up current ch
16418:         PRUint32 ch = str[i];
16418:         if ((i+1 < len) && NS_IS_HIGH_SURROGATE(ch) && NS_IS_LOW_SURROGATE(str[i+1])) {
16418:             i++;
16418:             ch = SURROGATE_TO_UCS4(ch, str[i]);
16418:         }
16418: 
16418:         // set up next ch
16418:         PRUint32 nextCh = 0;
16418:         if (i+1 < len) {
16418:             nextCh = str[i+1];
16418:             if ((i+2 < len) && NS_IS_HIGH_SURROGATE(nextCh) && NS_IS_LOW_SURROGATE(str[i+2]))
16418:                 nextCh = SURROGATE_TO_UCS4(nextCh, str[i+2]);
16418:         }
16418:         
16418:         // find the font for this char
16984:         nsRefPtr<gfxFont> font = FindFontForChar(ch, prevCh, nextCh, (aRanges.Length() == 0) ? nsnull : aRanges[aRanges.Length() - 1].font.get());
16418: 
16418:         prevCh = ch;
16418: 
16418:         if (aRanges.Length() == 0) {
16418:             // first char ==> make a new range
16418:             gfxTextRange r(0,1);
16418:             r.font = font;
16418:             aRanges.AppendElement(r);
16418:         } else {
16418:             // if font has changed, make a new range
16418:             gfxTextRange& prevRange = aRanges[aRanges.Length() - 1];
16418:             if (prevRange.font != font) {
16418:                 // close out the previous range
16418:                 prevRange.end = origI;
16418: 
16418:                 gfxTextRange r(origI, i+1);
16418:                 r.font = font;
16418:                 aRanges.AppendElement(r);
16418:             }
16418:         }
16418:     }
16418:     aRanges[aRanges.Length()-1].end = len;
16418: }
16418: 
19962: gfxUserFontSet* 
19962: gfxFontGroup::GetUserFontSet()
19962: {
19962:     return mUserFontSet;
19962: }
19962: 
19962: void 
19962: gfxFontGroup::SetUserFontSet(gfxUserFontSet *aUserFontSet)
19962: {
19962:     NS_IF_RELEASE(mUserFontSet);
19962:     mUserFontSet = aUserFontSet;
19962:     NS_IF_ADDREF(mUserFontSet);
19962:     mCurrGeneration = GetGeneration();
19962: }
19962: 
19962: PRUint64
19962: gfxFontGroup::GetGeneration()
19962: {
19962:     if (!mUserFontSet)
19962:         return 0;
19962:     return mUserFontSet->GetGeneration();
19962: }
19962: 
37211: void
37211: gfxFontGroup::UpdateFontList()
37211: {
37211:     // if user font set is set, check to see if font list needs updating
37211:     if (mUserFontSet && mCurrGeneration != GetGeneration()) {
37211:         // xxx - can probably improve this to detect when all fonts were found, so no need to update list
37211:         mFonts.Clear();
37211:         mUnderlineOffset = UNDERLINE_OFFSET_NOT_SET;
38461: 
38461:         // bug 548184 - need to clean up FT2, OS/2 platform code to use BuildFontList
38461: #if defined(XP_MACOSX) || defined(XP_WIN)
38461:         BuildFontList();
38461: #else
37211:         ForEachFont(FindPlatformFont, this);
38461: #endif
37211:         mCurrGeneration = GetGeneration();
37211:     }
37211: }
37211: 
37211: struct PrefFontCallbackData {
37211:     PrefFontCallbackData(nsTArray<nsRefPtr<gfxFontFamily> >& aFamiliesArray)
37211:         : mPrefFamilies(aFamiliesArray)
37211:     {}
37211: 
37211:     nsTArray<nsRefPtr<gfxFontFamily> >& mPrefFamilies;
37211: 
37211:     static PRBool AddFontFamilyEntry(eFontPrefLang aLang, const nsAString& aName, void *aClosure)
37211:     {
37211:         PrefFontCallbackData *prefFontData = static_cast<PrefFontCallbackData*>(aClosure);
37211: 
37211:         gfxFontFamily *family = gfxPlatformFontList::PlatformFontList()->FindFamily(aName);
37211:         if (family) {
37211:             prefFontData->mPrefFamilies.AppendElement(family);
37211:         }
37211:         return PR_TRUE;
37211:     }
37211: };
37211: 
37211: already_AddRefed<gfxFont>
37211: gfxFontGroup::WhichPrefFontSupportsChar(PRUint32 aCh)
37211: {
37211:     gfxFont *font;
37211: 
37211:     // FindCharUnicodeRange only supports BMP character points and there are no non-BMP fonts in prefs
37211:     if (aCh > 0xFFFF)
37211:         return nsnull;
37211: 
37211:     // get the pref font list if it hasn't been set up already
37211:     PRUint32 unicodeRange = FindCharUnicodeRange(aCh);
37211:     eFontPrefLang charLang = gfxPlatform::GetPlatform()->GetFontPrefLangFor(unicodeRange);
37211: 
37211:     // if the last pref font was the first family in the pref list, no need to recheck through a list of families
37211:     if (mLastPrefFont && charLang == mLastPrefLang &&
37211:         mLastPrefFirstFont && mLastPrefFont->HasCharacter(aCh)) {
37211:         font = mLastPrefFont;
37211:         NS_ADDREF(font);
37211:         return font;
37211:     }
37211: 
37211:     // based on char lang and page lang, set up list of pref lang fonts to check
37211:     eFontPrefLang prefLangs[kMaxLenPrefLangList];
37211:     PRUint32 i, numLangs = 0;
37211: 
37211:     gfxPlatform::GetPlatform()->GetLangPrefs(prefLangs, numLangs, charLang, mPageLang);
37211: 
37211:     for (i = 0; i < numLangs; i++) {
37211:         nsAutoTArray<nsRefPtr<gfxFontFamily>, 5> families;
37211:         eFontPrefLang currentLang = prefLangs[i];
37211: 
37211:         gfxPlatformFontList *fontList = gfxPlatformFontList::PlatformFontList();
37211: 
37211:         // get the pref families for a single pref lang
37211:         if (!fontList->GetPrefFontFamilyEntries(currentLang, &families)) {
37211:             eFontPrefLang prefLangsToSearch[1] = { currentLang };
37211:             PrefFontCallbackData prefFontData(families);
37211:             gfxPlatform::ForEachPrefFont(prefLangsToSearch, 1, PrefFontCallbackData::AddFontFamilyEntry,
37211:                                            &prefFontData);
37211:             fontList->SetPrefFontFamilyEntries(currentLang, families);
37211:         }
37211: 
37211:         // find the first pref font that includes the character
37211:         PRUint32  i, numPrefs;
37211:         numPrefs = families.Length();
37211:         for (i = 0; i < numPrefs; i++) {
37211:             // look up the appropriate face
37211:             gfxFontFamily *family = families[i];
37211:             if (!family) continue;
37211: 
37211:             // if a pref font is used, it's likely to be used again in the same text run.
37211:             // the style doesn't change so the face lookup can be cached rather than calling
38202:             // FindOrMakeFont repeatedly.  speeds up FindFontForChar lookup times for subsequent
37211:             // pref font lookups
37211:             if (family == mLastPrefFamily && mLastPrefFont->HasCharacter(aCh)) {
37211:                 font = mLastPrefFont;
37211:                 NS_ADDREF(font);
37211:                 return font;
37211:             }
37211: 
37211:             PRBool needsBold;
37211:             gfxFontEntry *fe = family->FindFontForStyle(mStyle, needsBold);
37211:             // if ch in cmap, create and return a gfxFont
37211:             if (fe && fe->TestCharacterMap(aCh)) {
38202:                 nsRefPtr<gfxFont> prefFont = fe->FindOrMakeFont(&mStyle, needsBold);
37211:                 if (!prefFont) continue;
37211:                 mLastPrefFamily = family;
37211:                 mLastPrefFont = prefFont;
37211:                 mLastPrefLang = charLang;
37211:                 mLastPrefFirstFont = (i == 0);
37211:                 return prefFont.forget();
37211:             }
37211: 
37211:         }
37211:     }
37211: 
37211:     return nsnull;
37211: }
37211: 
37211: already_AddRefed<gfxFont>
37211: gfxFontGroup::WhichSystemFontSupportsChar(PRUint32 aCh)
37211: {
37211:     gfxFontEntry *fe = 
37211:         gfxPlatformFontList::PlatformFontList()->FindFontForChar(aCh, GetFontAt(0));
37211:     if (fe) {
38202:         nsRefPtr<gfxFont> font = fe->FindOrMakeFont(&mStyle, PR_FALSE); // ignore bolder considerations in system fallback case...
37211:         return font.forget();
37211:     }
37211: 
37211:     return nsnull;
37211: }
16418: 
38492: /*static*/ void
38492: gfxFontGroup::Shutdown()
38492: {
38492:     NS_IF_RELEASE(gLangService);
38492: }
38492: 
38492: nsILanguageAtomService* gfxFontGroup::gLangService = nsnull;
38492: 
38492: 
12929: #define DEFAULT_PIXEL_FONT_SIZE 16.0f
12929: 
47360: /*static*/ void
47360: gfxFontStyle::ParseFontFeatureSettings(const nsString& aFeatureString,
47360:                                        nsTArray<gfxFontFeature>& aFeatures)
47360: {
47360:   aFeatures.Clear();
47360:   PRUint32 offset = 0;
47360:   while (offset < aFeatureString.Length()) {
47360:     // skip whitespace
47360:     while (offset < aFeatureString.Length() &&
47360:            nsCRT::IsAsciiSpace(aFeatureString[offset])) {
47360:       ++offset;
47360:     }
47360:     PRInt32 limit = aFeatureString.FindChar(',', offset);
47360:     if (limit < 0) {
47360:       limit = aFeatureString.Length();
47360:     }
47360:     // check that we have enough text for a 4-char tag,
47360:     // the '=' sign, and at least one digit
47360:     if (offset + 6 <= PRUint32(limit) &&
47360:       aFeatureString[offset+4] == '=') {
47360:       gfxFontFeature setting;
47360:       setting.mTag =
47360:         ((aFeatureString[offset] & 0xff) << 24) +
47360:         ((aFeatureString[offset+1] & 0xff) << 16) +
47360:         ((aFeatureString[offset+2] & 0xff) << 8) +
47360:          (aFeatureString[offset+3] & 0xff);
47360:       nsString valString;
47360:       aFeatureString.Mid(valString, offset+5, limit-offset-5);
47360:       PRInt32 rv;
47360:       setting.mValue = valString.ToInteger(&rv);
47360:       if (rv == NS_OK) {
47360:         // we keep the features array sorted so that we can
47360:         // use nsTArray<>::Equals() to compare feature lists
47360:         aFeatures.InsertElementSorted(setting);
47360:       }
47360:     }
47360:     offset = limit + 1;
47360:   }
47360: }
47360: 
47360: /*static*/ PRUint32
47360: gfxFontStyle::ParseFontLanguageOverride(const nsString& aLangTag)
47360: {
47360:   if (!aLangTag.Length() || aLangTag.Length() > 4) {
47360:     return NO_FONT_LANGUAGE_OVERRIDE;
47360:   }
47360:   PRUint32 index, result = 0;
47360:   for (index = 0; index < aLangTag.Length(); ++index) {
47360:     PRUnichar ch = aLangTag[index];
47360:     if (!nsCRT::IsAscii(ch)) { // valid tags are pure ASCII
47360:       return NO_FONT_LANGUAGE_OVERRIDE;
47360:     }
47360:     result = (result << 8) + ch;
47360:   }
47360:   while (index++ < 4) {
47360:     result = (result << 8) + 0x20;
47360:   }
47360:   return result;
47360: }
47360: 
12929: gfxFontStyle::gfxFontStyle() :
22866:     style(FONT_STYLE_NORMAL), systemFont(PR_TRUE), printerFont(PR_FALSE), 
24408:     familyNameQuirks(PR_FALSE), weight(FONT_WEIGHT_NORMAL),
24408:     stretch(NS_FONT_STRETCH_NORMAL), size(DEFAULT_PIXEL_FONT_SIZE),
47360:     sizeAdjust(0.0f),
47360:     language(gfxAtoms::x_western),
47360:     languageOverride(NO_FONT_LANGUAGE_OVERRIDE),
47360:     featureSettings(nsnull)
12929: {
12929: }
12929: 
24408: gfxFontStyle::gfxFontStyle(PRUint8 aStyle, PRUint16 aWeight, PRInt16 aStretch,
38493:                            gfxFloat aSize, nsIAtom *aLanguage,
    1:                            float aSizeAdjust, PRPackedBool aSystemFont,
22866:                            PRPackedBool aFamilyNameQuirks,
47360:                            PRPackedBool aPrinterFont,
47360:                            const nsString& aFeatureSettings,
47360:                            const nsString& aLanguageOverride):
22866:     style(aStyle), systemFont(aSystemFont), printerFont(aPrinterFont),
24408:     familyNameQuirks(aFamilyNameQuirks), weight(aWeight), stretch(aStretch),
47360:     size(aSize), sizeAdjust(aSizeAdjust),
47360:     language(aLanguage),
47360:     languageOverride(ParseFontLanguageOverride(aLanguageOverride)),
47360:     featureSettings(nsnull)
    1: {
47360:     if (!aFeatureSettings.IsEmpty()) {
47360:         featureSettings = new nsTArray<gfxFontFeature>;
47360:         ParseFontFeatureSettings(aFeatureSettings, *featureSettings);
47360:         if (featureSettings->Length() == 0) {
47360:             delete featureSettings;
47360:             featureSettings = nsnull;
47360:         }
47360:     }
47360: 
    1:     if (weight > 900)
    1:         weight = 900;
    1:     if (weight < 100)
    1:         weight = 100;
    1: 
 2210:     if (size >= FONT_MAX_SIZE) {
 2210:         size = FONT_MAX_SIZE;
 1985:         sizeAdjust = 0.0;
 1985:     } else if (size < 0.0) {
 1985:         NS_WARNING("negative font size");
 1985:         size = 0.0;
 1985:     }
 1985: 
38493:     if (!language) {
38493:         NS_WARNING("null language");
38493:         language = gfxAtoms::x_western;
    1:     }
    1: }
    1: 
  323: gfxFontStyle::gfxFontStyle(const gfxFontStyle& aStyle) :
22866:     style(aStyle.style), systemFont(aStyle.systemFont), printerFont(aStyle.printerFont),
  323:     familyNameQuirks(aStyle.familyNameQuirks), weight(aStyle.weight),
47360:     stretch(aStyle.stretch), size(aStyle.size),
47360:     sizeAdjust(aStyle.sizeAdjust),
47360:     language(aStyle.language),
47360:     languageOverride(aStyle.languageOverride),
47360:     featureSettings(nsnull)
  323: {
47360:     if (aStyle.featureSettings) {
47360:         featureSettings = new nsTArray<gfxFontFeature>;
47360:         featureSettings->AppendElements(*aStyle.featureSettings);
47360:     }
  323: }
  323: 
    1: void
    1: gfxFontStyle::ComputeWeightAndOffset(PRInt8 *outBaseWeight, PRInt8 *outOffset) const
    1: {
    1:     PRInt8 baseWeight = (weight + 50) / 100;
    1:     PRInt8 offset = weight - baseWeight * 100;
    1: 
    1:     if (baseWeight < 0)
    1:         baseWeight = 0;
    1:     if (baseWeight > 9)
    1:         baseWeight = 9;
    1: 
    1:     if (outBaseWeight)
    1:         *outBaseWeight = baseWeight;
    1:     if (outOffset)
    1:         *outOffset = offset;
    1: }
    1: 
    1: PRBool
    1: gfxTextRun::GlyphRunIterator::NextRun()  {
    1:     if (mNextIndex >= mTextRun->mGlyphRuns.Length())
    1:         return PR_FALSE;
    1:     mGlyphRun = &mTextRun->mGlyphRuns[mNextIndex];
    1:     if (mGlyphRun->mCharacterOffset >= mEndOffset)
    1:         return PR_FALSE;
    1: 
    1:     mStringStart = PR_MAX(mStartOffset, mGlyphRun->mCharacterOffset);
    1:     PRUint32 last = mNextIndex + 1 < mTextRun->mGlyphRuns.Length()
    1:         ? mTextRun->mGlyphRuns[mNextIndex + 1].mCharacterOffset : mTextRun->mCharacterCount;
    1:     mStringEnd = PR_MIN(mEndOffset, last);
    1: 
    1:     ++mNextIndex;
    1:     return PR_TRUE;
    1: }
    1: 
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005: static void
 3005: AccountStorageForTextRun(gfxTextRun *aTextRun, PRInt32 aSign)
 3005: {
 3005:     // Ignores detailed glyphs... we don't know when those have been constructed
 3005:     // Also ignores gfxSkipChars dynamic storage (which won't be anything
 3005:     // for preformatted text)
 3005:     // Also ignores GlyphRun array, again because it hasn't been constructed
 3005:     // by the time this gets called. If there's only one glyphrun that's stored
 3005:     // directly in the textrun anyway so no additional overhead.
38204:     PRUint32 length = aTextRun->GetLength();
38204:     PRInt32 bytes = length * sizeof(gfxTextRun::CompressedGlyph);
 3005:     if (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_IS_PERSISTENT) {
38204:       bytes += length * ((aTextRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT) ? 1 : 2);
38204:       bytes += sizeof(gfxTextRun::CompressedGlyph) - 1;
38204:       bytes &= ~(sizeof(gfxTextRun::CompressedGlyph) - 1);
38204:     }
38204:     bytes += sizeof(gfxTextRun);
 3005:     gTextRunStorage += bytes*aSign;
 3005:     gTextRunStorageHighWaterMark = PR_MAX(gTextRunStorageHighWaterMark, gTextRunStorage);
 3005: }
 3005: #endif
 3005: 
38204: // Helper for textRun creation to preallocate storage for glyphs and text;
38204: // this function returns a pointer to the newly-allocated glyph storage,
38204: // AND modifies the aText parameter if TEXT_IS_PERSISTENT was not set.
38204: // In that case, the text is appended to the glyph storage, so a single
38204: // delete[] operation in the textRun destructor will free both.
38204: // Returns nsnull if allocation fails.
38204: gfxTextRun::CompressedGlyph *
38204: gfxTextRun::AllocateStorage(const void*& aText, PRUint32 aLength, PRUint32 aFlags)
38204: {
38204:     // Here, we rely on CompressedGlyph being the largest unit we care about for
38204:     // allocation/alignment of either glyph data or text, so we allocate an array
38204:     // of CompressedGlyphs, then take the last chunk of that and cast a pointer to
38204:     // PRUint8* or PRUnichar* for text storage.
38204: 
38204:     // always need to allocate storage for the glyph data
38204:     PRUint64 allocCount = aLength;
38204: 
38204:     // if the text is not persistent, we also need space for a copy
38204:     if (!(aFlags & gfxTextRunFactory::TEXT_IS_PERSISTENT)) {
38204:         // figure out number of extra CompressedGlyph elements we need to
38204:         // get sufficient space for the text
38204:         if (aFlags & gfxTextRunFactory::TEXT_IS_8BIT) {
38204:             allocCount += (aLength + sizeof(CompressedGlyph)-1)
38204:                           / sizeof(CompressedGlyph);
38204:         } else {
38204:             allocCount += (aLength*sizeof(PRUnichar) + sizeof(CompressedGlyph)-1)
38204:                           / sizeof(CompressedGlyph);
38204:         }
38204:     }
38204: 
38204:     // allocate the storage we need, returning nsnull on failure rather than
38204:     // throwing an exception (because web content can create huge runs)
38204:     CompressedGlyph *storage = new (std::nothrow) CompressedGlyph[allocCount];
38204:     if (!storage) {
38204:         NS_WARNING("failed to allocate glyph/text storage for text run!");
38204:         return nsnull;
38204:     }
38204: 
38204:     // copy the text if we need to keep a copy in the textrun
38204:     if (!(aFlags & gfxTextRunFactory::TEXT_IS_PERSISTENT)) {
38204:         if (aFlags & gfxTextRunFactory::TEXT_IS_8BIT) {
38204:             PRUint8 *newText = reinterpret_cast<PRUint8*>(storage + aLength);
38204:             memcpy(newText, aText, aLength);
38204:             aText = newText;
38204:         } else {
38204:             PRUnichar *newText = reinterpret_cast<PRUnichar*>(storage + aLength);
38204:             memcpy(newText, aText, aLength*sizeof(PRUnichar));
38204:             aText = newText;
38204:         }
38204:     }
38204: 
38204:     return storage;
38204: }
38204: 
 8081: gfxTextRun *
 8081: gfxTextRun::Create(const gfxTextRunFactory::Parameters *aParams, const void *aText,
 8081:                    PRUint32 aLength, gfxFontGroup *aFontGroup, PRUint32 aFlags)
 8081: {
38204:     CompressedGlyph *glyphStorage = AllocateStorage(aText, aLength, aFlags);
38204:     if (!glyphStorage) {
38204:         return nsnull;
38204:     }
38204: 
38204:     return new gfxTextRun(aParams, aText, aLength, aFontGroup, aFlags, glyphStorage);
 8081: }
 8081: 
 1295: gfxTextRun::gfxTextRun(const gfxTextRunFactory::Parameters *aParams, const void *aText,
 8081:                        PRUint32 aLength, gfxFontGroup *aFontGroup, PRUint32 aFlags,
38204:                        CompressedGlyph *aGlyphStorage)
38204:   : mCharacterGlyphs(aGlyphStorage),
38204:     mUserData(aParams->mUserData),
 1295:     mFontGroup(aFontGroup),
    1:     mAppUnitsPerDevUnit(aParams->mAppUnitsPerDevUnit),
 1384:     mFlags(aFlags), mCharacterCount(aLength), mHashCode(0)
    1: {
 4304:     NS_ASSERTION(mAppUnitsPerDevUnit != 0, "Invalid app unit scale");
 2233:     MOZ_COUNT_CTOR(gfxTextRun);
 1295:     NS_ADDREF(mFontGroup);
    1:     if (aParams->mSkipChars) {
    1:         mSkipChars.TakeFrom(aParams->mSkipChars);
    1:     }
 8081: 
 1295:     if (mFlags & gfxTextRunFactory::TEXT_IS_8BIT) {
 3233:         mText.mSingle = static_cast<const PRUint8 *>(aText);
 1295:     } else {
 3233:         mText.mDouble = static_cast<const PRUnichar *>(aText);
 1295:     }
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005:     AccountStorageForTextRun(this, 1);
 3005: #endif
19962: 
19962:     mUserFontSetGeneration = mFontGroup->GetGeneration();
 1295: }
 1295: 
 1295: gfxTextRun::~gfxTextRun()
 1295: {
 3011: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 3005:     AccountStorageForTextRun(this, -1);
 3005: #endif
23491: #ifdef DEBUG
23491:     // Make it easy to detect a dead text run
23491:     mFlags = 0xFFFFFFFF;
23491: #endif
38204: 
38204:     // this will also delete the text, if it is owned by the run,
38204:     // because we merge the storage allocations
38204:     delete [] mCharacterGlyphs;
38204: 
 1295:     NS_RELEASE(mFontGroup);
 2233:     MOZ_COUNT_DTOR(gfxTextRun);
 1295: }
 1295: 
 1295: gfxTextRun *
 1295: gfxTextRun::Clone(const gfxTextRunFactory::Parameters *aParams, const void *aText,
 1295:                   PRUint32 aLength, gfxFontGroup *aFontGroup, PRUint32 aFlags)
 1295: {
 1295:     if (!mCharacterGlyphs)
 1295:         return nsnull;
 1295: 
 1295:     nsAutoPtr<gfxTextRun> textRun;
 8081:     textRun = gfxTextRun::Create(aParams, aText, aLength, aFontGroup, aFlags);
 8081:     if (!textRun)
 1295:         return nsnull;
 1295: 
 2317:     textRun->CopyGlyphDataFrom(this, 0, mCharacterCount, 0, PR_FALSE);
 1295:     return textRun.forget();
 1295: }
    1: 
    1: PRBool
    1: gfxTextRun::SetPotentialLineBreaks(PRUint32 aStart, PRUint32 aLength,
 2834:                                    PRPackedBool *aBreakBefore,
 2834:                                    gfxContext *aRefContext)
    1: {
    1:     NS_ASSERTION(aStart + aLength <= mCharacterCount, "Overflow");
    1: 
    1:     if (!mCharacterGlyphs)
    1:         return PR_TRUE;
    1:     PRUint32 changed = 0;
    1:     PRUint32 i;
    1:     for (i = 0; i < aLength; ++i) {
 4434:         PRBool canBreak = aBreakBefore[i];
 4434:         if (canBreak && !mCharacterGlyphs[aStart + i].IsClusterStart()) {
 4434:             // This can happen ... there is no guarantee that our linebreaking rules
 4434:             // align with the platform's idea of what constitutes a cluster.
 4434:             NS_WARNING("Break suggested inside cluster!");
 4434:             canBreak = PR_FALSE;
 4434:         }
 4434:         changed |= mCharacterGlyphs[aStart + i].SetCanBreakBefore(canBreak);
    1:     }
    1:     return changed != 0;
    1: }
    1: 
    1: gfxTextRun::LigatureData
 4434: gfxTextRun::ComputeLigatureData(PRUint32 aPartStart, PRUint32 aPartEnd,
 4434:                                 PropertyProvider *aProvider)
    1: {
 4434:     NS_ASSERTION(aPartStart < aPartEnd, "Computing ligature data for empty range");
 4434:     NS_ASSERTION(aPartEnd <= mCharacterCount, "Character length overflow");
 4434:   
    1:     LigatureData result;
 4434:     CompressedGlyph *charGlyphs = mCharacterGlyphs;
    1: 
 4434:     PRUint32 i;
 7715:     for (i = aPartStart; !charGlyphs[i].IsLigatureGroupStart(); --i) {
 4434:         NS_ASSERTION(i > 0, "Ligature at the start of the run??");
    1:     }
 4434:     result.mLigatureStart = i;
 7715:     for (i = aPartStart + 1; i < mCharacterCount && !charGlyphs[i].IsLigatureGroupStart(); ++i) {
 4434:     }
 4434:     result.mLigatureEnd = i;
    1: 
 7715:     PRInt32 ligatureWidth =
 7715:         GetAdvanceForGlyphs(this, result.mLigatureStart, result.mLigatureEnd);
    1:     // Count the number of started clusters we have seen
 4434:     PRUint32 totalClusterCount = 0;
 4434:     PRUint32 partClusterIndex = 0;
 4434:     PRUint32 partClusterCount = 0;
 4434:     for (i = result.mLigatureStart; i < result.mLigatureEnd; ++i) {
14568:         // Treat the first character of the ligature as the start of a
14568:         // cluster for our purposes of allocating ligature width to its
14568:         // characters.
14568:         if (i == result.mLigatureStart || charGlyphs[i].IsClusterStart()) {
 4434:             ++totalClusterCount;
 4434:             if (i < aPartStart) {
 4434:                 ++partClusterIndex;
 4434:             } else if (i < aPartEnd) {
 4434:                 ++partClusterCount;
    1:             }
    1:         }
    1:     }
26688:     NS_ASSERTION(totalClusterCount > 0, "Ligature involving no clusters??");
 4434:     result.mPartAdvance = ligatureWidth*partClusterIndex/totalClusterCount;
 4434:     result.mPartWidth = ligatureWidth*partClusterCount/totalClusterCount;
14568: 
14568:     if (partClusterCount == 0) {
14568:         // nothing to draw
14568:         result.mClipBeforePart = result.mClipAfterPart = PR_TRUE;
14568:     } else {
14568:         // Determine whether we should clip before or after this part when
14568:         // drawing its slice of the ligature.
14568:         // We need to clip before the part if any cluster is drawn before
14568:         // this part.
14568:         result.mClipBeforePart = partClusterIndex > 0;
14568:         // We need to clip after the part if any cluster is drawn after
14568:         // this part.
14568:         result.mClipAfterPart = partClusterIndex + partClusterCount < totalClusterCount;
14568:     }
    1: 
    1:     if (aProvider && (mFlags & gfxTextRunFactory::TEXT_ENABLE_SPACING)) {
 4434:         gfxFont::Spacing spacing;
 4434:         if (aPartStart == result.mLigatureStart) {
 4434:             aProvider->GetSpacing(aPartStart, 1, &spacing);
 4434:             result.mPartWidth += spacing.mBefore;
 4434:         }
 4434:         if (aPartEnd == result.mLigatureEnd) {
 4434:             aProvider->GetSpacing(aPartEnd - 1, 1, &spacing);
 4434:             result.mPartWidth += spacing.mAfter;
 4434:         }
    1:     }
    1: 
    1:     return result;
    1: }
    1: 
 4434: gfxFloat
 4434: gfxTextRun::ComputePartialLigatureWidth(PRUint32 aPartStart, PRUint32 aPartEnd,
 4434:                                         PropertyProvider *aProvider)
 4434: {
 4434:     if (aPartStart >= aPartEnd)
 4434:         return 0;
 4434:     LigatureData data = ComputeLigatureData(aPartStart, aPartEnd, aProvider);
 4434:     return data.mPartWidth;
 4434: }
 4434: 
 7715: static void
 7715: GetAdjustedSpacing(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,
 7715:                    gfxTextRun::PropertyProvider *aProvider,
 7715:                    gfxTextRun::PropertyProvider::Spacing *aSpacing)
    1: {
    1:     if (aStart >= aEnd)
    1:         return;
    1: 
    1:     aProvider->GetSpacing(aStart, aEnd - aStart, aSpacing);
    1: 
 7715: #ifdef DEBUG
 7715:     // Check to see if we have spacing inside ligatures
 7715: 
 7715:     const gfxTextRun::CompressedGlyph *charGlyphs = aTextRun->GetCharacterGlyphs();
 7685:     PRUint32 i;
 7685: 
 7685:     for (i = aStart; i < aEnd; ++i) {
 7715:         if (!charGlyphs[i].IsLigatureGroupStart()) {
 2027:             NS_ASSERTION(i == aStart || aSpacing[i - aStart].mBefore == 0,
 2027:                          "Before-spacing inside a ligature!");
 2027:             NS_ASSERTION(i - 1 <= aStart || aSpacing[i - 1 - aStart].mAfter == 0,
 2027:                          "After-spacing inside a ligature!");
    1:         }
    1:     }
 2027: #endif
    1: }
    1: 
    1: PRBool
    1: gfxTextRun::GetAdjustedSpacingArray(PRUint32 aStart, PRUint32 aEnd,
    1:                                     PropertyProvider *aProvider,
 4434:                                     PRUint32 aSpacingStart, PRUint32 aSpacingEnd,
    1:                                     nsTArray<PropertyProvider::Spacing> *aSpacing)
    1: {
 1386:     if (!aProvider || !(mFlags & gfxTextRunFactory::TEXT_ENABLE_SPACING))
    1:         return PR_FALSE;
    1:     if (!aSpacing->AppendElements(aEnd - aStart))
    1:         return PR_FALSE;
 4434:     memset(aSpacing->Elements(), 0, sizeof(gfxFont::Spacing)*(aSpacingStart - aStart));
 7715:     GetAdjustedSpacing(this, aSpacingStart, aSpacingEnd, aProvider,
 4434:                        aSpacing->Elements() + aSpacingStart - aStart);
 4434:     memset(aSpacing->Elements() + aSpacingEnd - aStart, 0, sizeof(gfxFont::Spacing)*(aEnd - aSpacingEnd));
    1:     return PR_TRUE;
    1: }
    1: 
    1: void
    1: gfxTextRun::ShrinkToLigatureBoundaries(PRUint32 *aStart, PRUint32 *aEnd)
    1: {
    1:     if (*aStart >= *aEnd)
    1:         return;
    1:   
    1:     CompressedGlyph *charGlyphs = mCharacterGlyphs;
    1: 
 7715:     while (*aStart < *aEnd && !charGlyphs[*aStart].IsLigatureGroupStart()) {
 4434:         ++(*aStart);
    1:     }
 4434:     if (*aEnd < mCharacterCount) {
 7715:         while (*aEnd > *aStart && !charGlyphs[*aEnd].IsLigatureGroupStart()) {
 4434:             --(*aEnd);
 4434:         }
    1:     }
    1: }
    1: 
    1: void
    1: gfxTextRun::DrawGlyphs(gfxFont *aFont, gfxContext *aContext,
    1:                        PRBool aDrawToPath, gfxPoint *aPt,
    1:                        PRUint32 aStart, PRUint32 aEnd,
 4434:                        PropertyProvider *aProvider,
 4434:                        PRUint32 aSpacingStart, PRUint32 aSpacingEnd)
    1: {
    1:     nsAutoTArray<PropertyProvider::Spacing,200> spacingBuffer;
 4434:     PRBool haveSpacing = GetAdjustedSpacingArray(aStart, aEnd, aProvider,
 4434:         aSpacingStart, aSpacingEnd, &spacingBuffer);
    1:     aFont->Draw(this, aStart, aEnd, aContext, aDrawToPath, aPt,
    1:                 haveSpacing ? spacingBuffer.Elements() : nsnull);
    1: }
    1: 
 4434: static void
 4434: ClipPartialLigature(gfxTextRun *aTextRun, gfxFloat *aLeft, gfxFloat *aRight,
 4434:                     gfxFloat aXOrigin, gfxTextRun::LigatureData *aLigature)
 4434: {
14568:     if (aLigature->mClipBeforePart) {
 4434:         if (aTextRun->IsRightToLeft()) {
 4434:             *aRight = PR_MIN(*aRight, aXOrigin);
 4434:         } else {
 4434:             *aLeft = PR_MAX(*aLeft, aXOrigin);
 4434:         }
 4434:     }
14568:     if (aLigature->mClipAfterPart) {
 4434:         gfxFloat endEdge = aXOrigin + aTextRun->GetDirection()*aLigature->mPartWidth;
 4434:         if (aTextRun->IsRightToLeft()) {
 4434:             *aLeft = PR_MAX(*aLeft, endEdge);
 4434:         } else {
 4434:             *aRight = PR_MIN(*aRight, endEdge);
 4434:         }
 4434:     }    
 4434: }
 4434: 
 4434: void
 4434: gfxTextRun::DrawPartialLigature(gfxFont *aFont, gfxContext *aCtx, PRUint32 aStart,
 4434:                                 PRUint32 aEnd,
 4434:                                 const gfxRect *aDirtyRect, gfxPoint *aPt,
    1:                                 PropertyProvider *aProvider)
    1: {
    1:     if (aStart >= aEnd)
 4434:         return;
 4434:     if (!aDirtyRect) {
 4434:         NS_ERROR("Cannot draw partial ligatures without a dirty rect");
 4434:         return;
    1:     }
    1: 
    1:     // Draw partial ligature. We hack this by clipping the ligature.
 4434:     LigatureData data = ComputeLigatureData(aStart, aEnd, aProvider);
    1:     gfxFloat left = aDirtyRect->X();
    1:     gfxFloat right = aDirtyRect->XMost();
 4434:     ClipPartialLigature(this, &left, &right, aPt->x, &data);
    1: 
    1:     aCtx->Save();
 1939:     aCtx->NewPath();
    1:     // use division here to ensure that when the rect is aligned on multiples
 1939:     // of mAppUnitsPerDevUnit, we clip to true device unit boundaries.
 1939:     // Also, make sure we snap the rectangle to device pixels.
 1939:     aCtx->Rectangle(gfxRect(left/mAppUnitsPerDevUnit,
    1:                             aDirtyRect->Y()/mAppUnitsPerDevUnit,
    1:                             (right - left)/mAppUnitsPerDevUnit,
 1939:                             aDirtyRect->Height()/mAppUnitsPerDevUnit), PR_TRUE);
 1939:     aCtx->Clip();
 4434:     gfxFloat direction = GetDirection();
 4434:     gfxPoint pt(aPt->x - direction*data.mPartAdvance, aPt->y);
 4434:     DrawGlyphs(aFont, aCtx, PR_FALSE, &pt, data.mLigatureStart,
 4434:                data.mLigatureEnd, aProvider, aStart, aEnd);
    1:     aCtx->Restore();
    1: 
 4434:     aPt->x += direction*data.mPartWidth;
    1: }
    1: 
13339: // returns true if a glyph run is using a font with synthetic bolding enabled, false otherwise
13339: static PRBool
13339: HasSyntheticBold(gfxTextRun *aRun, PRUint32 aStart, PRUint32 aLength)
13339: {
13339:     gfxTextRun::GlyphRunIterator iter(aRun, aStart, aLength);
13339:     while (iter.NextRun()) {
13339:         gfxFont *font = iter.GetGlyphRun()->mFont;
13339:         if (font && font->IsSyntheticBold()) {
13339:             return PR_TRUE;
13339:         }
13339:     }
13339: 
13339:     return PR_FALSE;
13339: }
13339: 
13339: // returns true if color is non-opaque (i.e. alpha != 1.0) or completely transparent, false otherwise
13339: // if true, color is set on output
13339: static PRBool
13339: HasNonOpaqueColor(gfxContext *aContext, gfxRGBA& aCurrentColor)
13339: {
14741:     if (aContext->GetDeviceColor(aCurrentColor)) {
13339:         if (aCurrentColor.a < 1.0 && aCurrentColor.a > 0.0) {
13339:             return PR_TRUE;
13339:         }
13339:     }
13339:         
13339:     return PR_FALSE;
13339: }
13339: 
13339: // helper class for double-buffering drawing with non-opaque color
13339: struct BufferAlphaColor {
13339:     BufferAlphaColor(gfxContext *aContext)
13339:         : mContext(aContext)
13339:     {
13339: 
13339:     }
13339: 
13339:     ~BufferAlphaColor() {}
13339: 
13339:     void PushSolidColor(const gfxRect& aBounds, const gfxRGBA& aAlphaColor, PRUint32 appsPerDevUnit)
13339:     {
13339:         mContext->Save();
13339:         mContext->NewPath();
13339:         mContext->Rectangle(gfxRect(aBounds.X() / appsPerDevUnit,
13339:                     aBounds.Y() / appsPerDevUnit,
13339:                     aBounds.Width() / appsPerDevUnit,
13339:                     aBounds.Height() / appsPerDevUnit), PR_TRUE);
13339:         mContext->Clip();
13339:         mContext->SetColor(gfxRGBA(aAlphaColor.r, aAlphaColor.g, aAlphaColor.b));
13339:         mContext->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
13339:         mAlpha = aAlphaColor.a;
13339:     }
13339: 
13339:     void PopAlpha()
13339:     {
13339:         // pop the text, using the color alpha as the opacity
13339:         mContext->PopGroupToSource();
13339:         mContext->SetOperator(gfxContext::OPERATOR_OVER);
13339:         mContext->Paint(mAlpha);
13339:         mContext->Restore();
13339:     }
13339: 
13339:     gfxContext *mContext;
13339:     gfxFloat mAlpha;
13339: };
13339: 
13339: void
13339: gfxTextRun::AdjustAdvancesForSyntheticBold(PRUint32 aStart, PRUint32 aLength)
13339: {
13339:     const PRUint32 appUnitsPerDevUnit = GetAppUnitsPerDevUnit();
13339:     PRBool isRTL = IsRightToLeft();
13339: 
13339:     GlyphRunIterator iter(this, aStart, aLength);
13339:     while (iter.NextRun()) {
13339:         gfxFont *font = iter.GetGlyphRun()->mFont;
13339:         if (font->IsSyntheticBold()) {
13339:             PRUint32 synAppUnitOffset = font->GetSyntheticBoldOffset() * appUnitsPerDevUnit;
13339:             PRUint32 start = iter.GetStringStart();
13339:             PRUint32 end = iter.GetStringEnd();
13339:             PRUint32 i;
13339:             
13339:             // iterate over glyphs, start to end
13339:             for (i = start; i < end; ++i) {
13339:                 gfxTextRun::CompressedGlyph *glyphData = &mCharacterGlyphs[i];
13339:                 
13339:                 if (glyphData->IsSimpleGlyph()) {
13339:                     // simple glyphs ==> just add the advance
13339:                     PRUint32 advance = glyphData->GetSimpleAdvance() + synAppUnitOffset;
13339:                     if (CompressedGlyph::IsSimpleAdvance(advance)) {
13339:                         glyphData->SetSimpleGlyph(advance, glyphData->GetSimpleGlyph());
13339:                     } else {
13339:                         // rare case, tested by making this the default
13339:                         PRUint32 glyphIndex = glyphData->GetSimpleGlyph();
13339:                         glyphData->SetComplex(PR_TRUE, PR_TRUE, 1);
13339:                         DetailedGlyph detail = {glyphIndex, advance, 0, 0};
13339:                         SetGlyphs(i, *glyphData, &detail);
13339:                     }
13339:                 } else {
13339:                     // complex glyphs ==> add offset at cluster/ligature boundaries
13339:                     PRUint32 detailedLength = glyphData->GetGlyphCount();
13339:                     if (detailedLength && mDetailedGlyphs) {
13339:                         gfxTextRun::DetailedGlyph *details = mDetailedGlyphs[i].get();
13339:                         if (!details) continue;
13339:                         if (isRTL)
13339:                             details[0].mAdvance += synAppUnitOffset;
13339:                         else
13339:                             details[detailedLength - 1].mAdvance += synAppUnitOffset;
13339:                     }
13339:                 }
13339:             }
13339:         }
13339:     }
13339: }
13339: 
    1: void
    1: gfxTextRun::Draw(gfxContext *aContext, gfxPoint aPt,
    1:                  PRUint32 aStart, PRUint32 aLength, const gfxRect *aDirtyRect,
    1:                  PropertyProvider *aProvider, gfxFloat *aAdvanceWidth)
    1: {
    1:     NS_ASSERTION(aStart + aLength <= mCharacterCount, "Substring out of range");
    1: 
    1:     gfxFloat direction = GetDirection();
    1:     gfxPoint pt = aPt;
    1: 
13339:     // synthetic bolding draws glyphs twice ==> colors with opacity won't draw correctly unless first drawn without alpha
13339:     BufferAlphaColor syntheticBoldBuffer(aContext);
13339:     gfxRGBA currentColor;
13339:     PRBool needToRestore = PR_FALSE;
13339: 
13339:     if (HasNonOpaqueColor(aContext, currentColor) && HasSyntheticBold(this, aStart, aLength)) {
13339:         needToRestore = PR_TRUE;
13339:         // measure text, use the bounding box
25417:         gfxTextRun::Metrics metrics = MeasureText(aStart, aLength, gfxFont::LOOSE_INK_EXTENTS,
25417:                                                   aContext, aProvider);
13339:         metrics.mBoundingBox.MoveBy(aPt);
13339:         syntheticBoldBuffer.PushSolidColor(metrics.mBoundingBox, currentColor, GetAppUnitsPerDevUnit());
13339:     }
13339: 
    1:     GlyphRunIterator iter(this, aStart, aLength);
    1:     while (iter.NextRun()) {
    1:         gfxFont *font = iter.GetGlyphRun()->mFont;
    1:         PRUint32 start = iter.GetStringStart();
    1:         PRUint32 end = iter.GetStringEnd();
    1:         PRUint32 ligatureRunStart = start;
    1:         PRUint32 ligatureRunEnd = end;
    1:         ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);
    1:         
 4434:         DrawPartialLigature(font, aContext, start, ligatureRunStart, aDirtyRect, &pt, aProvider);
    1:         DrawGlyphs(font, aContext, PR_FALSE, &pt, ligatureRunStart,
 4434:                    ligatureRunEnd, aProvider, ligatureRunStart, ligatureRunEnd);
 4434:         DrawPartialLigature(font, aContext, ligatureRunEnd, end, aDirtyRect, &pt, aProvider);
    1:     }
    1: 
13339:     // composite result when synthetic bolding used
13339:     if (needToRestore) {
13339:         syntheticBoldBuffer.PopAlpha();
13339:     }
13339: 
    1:     if (aAdvanceWidth) {
    1:         *aAdvanceWidth = (pt.x - aPt.x)*direction;
    1:     }
    1: }
    1: 
    1: void
    1: gfxTextRun::DrawToPath(gfxContext *aContext, gfxPoint aPt,
    1:                        PRUint32 aStart, PRUint32 aLength,
    1:                        PropertyProvider *aProvider, gfxFloat *aAdvanceWidth)
    1: {
    1:     NS_ASSERTION(aStart + aLength <= mCharacterCount, "Substring out of range");
    1: 
    1:     gfxFloat direction = GetDirection();
    1:     gfxPoint pt = aPt;
    1: 
    1:     GlyphRunIterator iter(this, aStart, aLength);
    1:     while (iter.NextRun()) {
    1:         gfxFont *font = iter.GetGlyphRun()->mFont;
    1:         PRUint32 start = iter.GetStringStart();
    1:         PRUint32 end = iter.GetStringEnd();
 4434:         PRUint32 ligatureRunStart = start;
 4434:         PRUint32 ligatureRunEnd = end;
 4434:         ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);
 4434:         NS_ASSERTION(ligatureRunStart == start,
    1:                      "Can't draw path starting inside ligature");
 4434:         NS_ASSERTION(ligatureRunEnd == end,
    1:                      "Can't end drawing path inside ligature");
    1: 
 4434:         DrawGlyphs(font, aContext, PR_TRUE, &pt, ligatureRunStart, ligatureRunEnd, aProvider,
 4434:             ligatureRunStart, ligatureRunEnd);
    1:     }
    1: 
    1:     if (aAdvanceWidth) {
    1:         *aAdvanceWidth = (pt.x - aPt.x)*direction;
    1:     }
    1: }
    1: 
    1: void
 4434: gfxTextRun::AccumulateMetricsForRun(gfxFont *aFont,
 4434:                                     PRUint32 aStart, PRUint32 aEnd,
25417:                                     gfxFont::BoundingBoxType aBoundingBoxType,
25417:                                     gfxContext *aRefContext,
 6247:                                     PropertyProvider *aProvider,
 4434:                                     PRUint32 aSpacingStart, PRUint32 aSpacingEnd,
    1:                                     Metrics *aMetrics)
    1: {
    1:     nsAutoTArray<PropertyProvider::Spacing,200> spacingBuffer;
 4434:     PRBool haveSpacing = GetAdjustedSpacingArray(aStart, aEnd, aProvider,
 4434:         aSpacingStart, aSpacingEnd, &spacingBuffer);
25417:     Metrics metrics = aFont->Measure(this, aStart, aEnd, aBoundingBoxType, aRefContext,
    1:                                      haveSpacing ? spacingBuffer.Elements() : nsnull);
16581:     aMetrics->CombineWith(metrics, IsRightToLeft());
    1: }
    1: 
    1: void
    1: gfxTextRun::AccumulatePartialLigatureMetrics(gfxFont *aFont,
25417:     PRUint32 aStart, PRUint32 aEnd,
25417:     gfxFont::BoundingBoxType aBoundingBoxType, gfxContext *aRefContext,
 4434:     PropertyProvider *aProvider, Metrics *aMetrics)
    1: {
 4434:     if (aStart >= aEnd)
    1:         return;
    1: 
    1:     // Measure partial ligature. We hack this by clipping the metrics in the
    1:     // same way we clip the drawing.
 4434:     LigatureData data = ComputeLigatureData(aStart, aEnd, aProvider);
    1: 
    1:     // First measure the complete ligature
    1:     Metrics metrics;
 4434:     AccumulateMetricsForRun(aFont, data.mLigatureStart, data.mLigatureEnd,
25417:                             aBoundingBoxType, aRefContext,
25417:                             aProvider, aStart, aEnd, &metrics);
    1: 
 4434:     // Clip the bounding box to the ligature part
 4434:     gfxFloat bboxLeft = metrics.mBoundingBox.X();
 4434:     gfxFloat bboxRight = metrics.mBoundingBox.XMost();
 4434:     // Where we are going to start "drawing" relative to our left baseline origin
 4434:     gfxFloat origin = IsRightToLeft() ? metrics.mAdvanceWidth - data.mPartAdvance : 0;
 4434:     ClipPartialLigature(this, &bboxLeft, &bboxRight, origin, &data);
 4434:     metrics.mBoundingBox.pos.x = bboxLeft;
 4434:     metrics.mBoundingBox.size.width = bboxRight - bboxLeft;
    1: 
 4434:     // mBoundingBox is now relative to the left baseline origin for the entire
 4434:     // ligature. Shift it left.
 4434:     metrics.mBoundingBox.pos.x -=
 4434:         IsRightToLeft() ? metrics.mAdvanceWidth - (data.mPartAdvance + data.mPartWidth)
 4434:             : data.mPartAdvance;    
 4434:     metrics.mAdvanceWidth = data.mPartWidth;
    1: 
16581:     aMetrics->CombineWith(metrics, IsRightToLeft());
    1: }
    1: 
    1: gfxTextRun::Metrics
    1: gfxTextRun::MeasureText(PRUint32 aStart, PRUint32 aLength,
25417:                         gfxFont::BoundingBoxType aBoundingBoxType,
25417:                         gfxContext *aRefContext,
    1:                         PropertyProvider *aProvider)
    1: {
    1:     NS_ASSERTION(aStart + aLength <= mCharacterCount, "Substring out of range");
    1: 
    1:     Metrics accumulatedMetrics;
    1:     GlyphRunIterator iter(this, aStart, aLength);
    1:     while (iter.NextRun()) {
    1:         gfxFont *font = iter.GetGlyphRun()->mFont;
 4434:         PRUint32 start = iter.GetStringStart();
 4434:         PRUint32 end = iter.GetStringEnd();
 4434:         PRUint32 ligatureRunStart = start;
 4434:         PRUint32 ligatureRunEnd = end;
    1:         ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);
    1: 
 4434:         AccumulatePartialLigatureMetrics(font, start, ligatureRunStart,
25417:             aBoundingBoxType, aRefContext, aProvider, &accumulatedMetrics);
    1: 
    1:         // XXX This sucks. We have to get glyph extents just so we can detect
25417:         // glyphs outside the font box, even when aBoundingBoxType is LOOSE,
    1:         // even though in almost all cases we could get correct results just
    1:         // by getting some ascent/descent from the font and using our stored
    1:         // advance widths.
    1:         AccumulateMetricsForRun(font,
25417:             ligatureRunStart, ligatureRunEnd, aBoundingBoxType,
 6247:             aRefContext, aProvider, ligatureRunStart, ligatureRunEnd,
    1:             &accumulatedMetrics);
    1: 
 4434:         AccumulatePartialLigatureMetrics(font, ligatureRunEnd, end,
25417:             aBoundingBoxType, aRefContext, aProvider, &accumulatedMetrics);
    1:     }
    1: 
    1:     return accumulatedMetrics;
    1: }
    1: 
    1: #define MEASUREMENT_BUFFER_SIZE 100
    1: 
    1: PRUint32
    1: gfxTextRun::BreakAndMeasureText(PRUint32 aStart, PRUint32 aMaxLength,
    1:                                 PRBool aLineBreakBefore, gfxFloat aWidth,
    1:                                 PropertyProvider *aProvider,
    1:                                 PRBool aSuppressInitialBreak,
 1731:                                 gfxFloat *aTrimWhitespace,
25417:                                 Metrics *aMetrics,
25417:                                 gfxFont::BoundingBoxType aBoundingBoxType,
 6247:                                 gfxContext *aRefContext,
    1:                                 PRBool *aUsedHyphenation,
16166:                                 PRUint32 *aLastBreak,
16166:                                 PRBool aCanWordWrap,
16166:                                 gfxBreakPriority *aBreakPriority)
    1: {
    1:     aMaxLength = PR_MIN(aMaxLength, mCharacterCount - aStart);
    1: 
    1:     NS_ASSERTION(aStart + aMaxLength <= mCharacterCount, "Substring out of range");
    1: 
    1:     PRUint32 bufferStart = aStart;
    1:     PRUint32 bufferLength = PR_MIN(aMaxLength, MEASUREMENT_BUFFER_SIZE);
    1:     PropertyProvider::Spacing spacingBuffer[MEASUREMENT_BUFFER_SIZE];
 1386:     PRBool haveSpacing = aProvider && (mFlags & gfxTextRunFactory::TEXT_ENABLE_SPACING) != 0;
    1:     if (haveSpacing) {
 7715:         GetAdjustedSpacing(this, bufferStart, bufferStart + bufferLength, aProvider,
    1:                            spacingBuffer);
    1:     }
    1:     PRPackedBool hyphenBuffer[MEASUREMENT_BUFFER_SIZE];
    1:     PRBool haveHyphenation = (mFlags & gfxTextRunFactory::TEXT_ENABLE_HYPHEN_BREAKS) != 0;
    1:     if (haveHyphenation) {
  319:         aProvider->GetHyphenationBreaks(bufferStart, bufferLength,
    1:                                         hyphenBuffer);
    1:     }
    1: 
    1:     gfxFloat width = 0;
    1:     gfxFloat advance = 0;
 2028:     // The number of space characters that can be trimmed
 2028:     PRUint32 trimmableChars = 0;
 2028:     // The amount of space removed by ignoring trimmableChars
 1731:     gfxFloat trimmableAdvance = 0;
    1:     PRInt32 lastBreak = -1;
 2028:     PRInt32 lastBreakTrimmableChars = -1;
 2028:     gfxFloat lastBreakTrimmableAdvance = -1;
    1:     PRBool aborted = PR_FALSE;
    1:     PRUint32 end = aStart + aMaxLength;
    1:     PRBool lastBreakUsedHyphenation = PR_FALSE;
    1: 
    1:     PRUint32 ligatureRunStart = aStart;
    1:     PRUint32 ligatureRunEnd = end;
    1:     ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);
    1: 
    1:     PRUint32 i;
    1:     for (i = aStart; i < end; ++i) {
    1:         if (i >= bufferStart + bufferLength) {
    1:             // Fetch more spacing and hyphenation data
    1:             bufferStart = i;
    1:             bufferLength = PR_MIN(aStart + aMaxLength, i + MEASUREMENT_BUFFER_SIZE) - i;
    1:             if (haveSpacing) {
 7715:                 GetAdjustedSpacing(this, bufferStart, bufferStart + bufferLength, aProvider,
    1:                                    spacingBuffer);
    1:             }
    1:             if (haveHyphenation) {
  319:                 aProvider->GetHyphenationBreaks(bufferStart, bufferLength,
    1:                                                 hyphenBuffer);
    1:             }
    1:         }
    1: 
16246:         // There can't be a word-wrap break opportunity at the beginning of the
16246:         // line: if the width is too small for even one character to fit, it 
16246:         // could be the first and last break opportunity on the line, and that
16246:         // would trigger an infinite loop.
16246:         if (!aSuppressInitialBreak || i > aStart) {
16246:             PRBool lineBreakHere = mCharacterGlyphs[i].CanBreakBefore();
16166:             PRBool hyphenation = haveHyphenation && hyphenBuffer[i - bufferStart];
16166:             PRBool wordWrapping = aCanWordWrap && *aBreakPriority <= eWordWrapBreak;
16246: 
16166:             if (lineBreakHere || hyphenation || wordWrapping) {
    1:                 gfxFloat hyphenatedAdvance = advance;
16166:                 if (!lineBreakHere && !wordWrapping) {
    1:                     hyphenatedAdvance += aProvider->GetHyphenWidth();
    1:                 }
    1:             
 1731:                 if (lastBreak < 0 || width + hyphenatedAdvance - trimmableAdvance <= aWidth) {
    1:                     // We can break here.
    1:                     lastBreak = i;
 2028:                     lastBreakTrimmableChars = trimmableChars;
 2028:                     lastBreakTrimmableAdvance = trimmableAdvance;
16166:                     lastBreakUsedHyphenation = !lineBreakHere && !wordWrapping;
16166:                     *aBreakPriority = hyphenation || lineBreakHere ?
16166:                         eNormalBreak : eWordWrapBreak;
    1:                 }
    1: 
    1:                 width += advance;
    1:                 advance = 0;
 1731:                 if (width - trimmableAdvance > aWidth) {
    1:                     // No more text fits. Abort
    1:                     aborted = PR_TRUE;
    1:                     break;
    1:                 }
    1:             }
16246:         }
    1:         
 7715:         gfxFloat charAdvance;
    1:         if (i >= ligatureRunStart && i < ligatureRunEnd) {
 7715:             charAdvance = GetAdvanceForGlyphs(this, i, i + 1);
    1:             if (haveSpacing) {
    1:                 PropertyProvider::Spacing *space = &spacingBuffer[i - bufferStart];
 1731:                 charAdvance += space->mBefore + space->mAfter;
    1:             }
    1:         } else {
 7715:             charAdvance = ComputePartialLigatureWidth(i, i + 1, aProvider);
 1731:         }
 1731:         
 1731:         advance += charAdvance;
 1731:         if (aTrimWhitespace) {
 1731:             if (GetChar(i) == ' ') {
 1731:                 ++trimmableChars;
 1731:                 trimmableAdvance += charAdvance;
 1731:             } else {
 1731:                 trimmableAdvance = 0;
 1731:                 trimmableChars = 0;
 1731:             }
    1:         }
    1:     }
    1: 
    1:     if (!aborted) {
    1:         width += advance;
    1:     }
    1: 
    1:     // There are three possibilities:
    1:     // 1) all the text fit (width <= aWidth)
    1:     // 2) some of the text fit up to a break opportunity (width > aWidth && lastBreak >= 0)
    1:     // 3) none of the text fits before a break opportunity (width > aWidth && lastBreak < 0)
    1:     PRUint32 charsFit;
 3005:     PRBool usedHyphenation = PR_FALSE;
 1731:     if (width - trimmableAdvance <= aWidth) {
    1:         charsFit = aMaxLength;
    1:     } else if (lastBreak >= 0) {
    1:         charsFit = lastBreak - aStart;
 2028:         trimmableChars = lastBreakTrimmableChars;
 2028:         trimmableAdvance = lastBreakTrimmableAdvance;
 3005:         usedHyphenation = lastBreakUsedHyphenation;
    1:     } else {
    1:         charsFit = aMaxLength;
    1:     }
    1: 
    1:     if (aMetrics) {
 6247:         *aMetrics = MeasureText(aStart, charsFit - trimmableChars,
25417:             aBoundingBoxType, aRefContext, aProvider);
 1731:     }
 1731:     if (aTrimWhitespace) {
 1731:         *aTrimWhitespace = trimmableAdvance;
    1:     }
    1:     if (aUsedHyphenation) {
 3005:         *aUsedHyphenation = usedHyphenation;
    1:     }
    1:     if (aLastBreak && charsFit == aMaxLength) {
    1:         if (lastBreak < 0) {
    1:             *aLastBreak = PR_UINT32_MAX;
    1:         } else {
    1:             *aLastBreak = lastBreak - aStart;
    1:         }
    1:     }
    1: 
    1:     return charsFit;
    1: }
    1: 
    1: gfxFloat
    1: gfxTextRun::GetAdvanceWidth(PRUint32 aStart, PRUint32 aLength,
    1:                             PropertyProvider *aProvider)
    1: {
    1:     NS_ASSERTION(aStart + aLength <= mCharacterCount, "Substring out of range");
    1: 
 2027:     PRUint32 ligatureRunStart = aStart;
 2027:     PRUint32 ligatureRunEnd = aStart + aLength;
 2027:     ShrinkToLigatureBoundaries(&ligatureRunStart, &ligatureRunEnd);
    1: 
 4434:     gfxFloat result = ComputePartialLigatureWidth(aStart, ligatureRunStart, aProvider) +
 4434:                       ComputePartialLigatureWidth(ligatureRunEnd, aStart + aLength, aProvider);
 2027: 
 2027:     // Account for all remaining spacing here. This is more efficient than
 2027:     // processing it along with the glyphs.
 1386:     if (aProvider && (mFlags & gfxTextRunFactory::TEXT_ENABLE_SPACING)) {
    1:         PRUint32 i;
    1:         nsAutoTArray<PropertyProvider::Spacing,200> spacingBuffer;
    1:         if (spacingBuffer.AppendElements(aLength)) {
 7715:             GetAdjustedSpacing(this, ligatureRunStart, ligatureRunEnd, aProvider,
    1:                                spacingBuffer.Elements());
 2027:             for (i = 0; i < ligatureRunEnd - ligatureRunStart; ++i) {
    1:                 PropertyProvider::Spacing *space = &spacingBuffer[i];
    1:                 result += space->mBefore + space->mAfter;
    1:             }
    1:         }
    1:     }
    1: 
 7715:     return result + GetAdvanceForGlyphs(this, ligatureRunStart, ligatureRunEnd);
    1: }
    1: 
    6: PRBool
    1: gfxTextRun::SetLineBreaks(PRUint32 aStart, PRUint32 aLength,
    1:                           PRBool aLineBreakBefore, PRBool aLineBreakAfter,
 2834:                           gfxFloat *aAdvanceWidthDelta,
 2834:                           gfxContext *aRefContext)
    1: {
    1:     // Do nothing because our shaping does not currently take linebreaks into
    1:     // account. There is no change in advance width.
    1:     if (aAdvanceWidthDelta) {
    1:         *aAdvanceWidthDelta = 0;
    1:     }
    6:     return PR_FALSE;
    1: }
    1: 
    1: PRUint32
    1: gfxTextRun::FindFirstGlyphRunContaining(PRUint32 aOffset)
    1: {
    1:     NS_ASSERTION(aOffset <= mCharacterCount, "Bad offset looking for glyphrun");
    1:     if (aOffset == mCharacterCount)
    1:         return mGlyphRuns.Length();
    1:     PRUint32 start = 0;
    1:     PRUint32 end = mGlyphRuns.Length();
    1:     while (end - start > 1) {
    1:         PRUint32 mid = (start + end)/2;
    1:         if (mGlyphRuns[mid].mCharacterOffset <= aOffset) {
    1:             start = mid;
    1:         } else {
    1:             end = mid;
    1:         }
    1:     }
    1:     NS_ASSERTION(mGlyphRuns[start].mCharacterOffset <= aOffset,
    1:                  "Hmm, something went wrong, aOffset should have been found");
    1:     return start;
    1: }
    1: 
    1: nsresult
 3609: gfxTextRun::AddGlyphRun(gfxFont *aFont, PRUint32 aUTF16Offset, PRBool aForceNewRun)
    1: {
 2317:     PRUint32 numGlyphRuns = mGlyphRuns.Length();
 3609:     if (!aForceNewRun &&
 3609:         numGlyphRuns > 0)
 3609:     {
 2317:         GlyphRun *lastGlyphRun = &mGlyphRuns[numGlyphRuns - 1];
 2317: 
 2317:         NS_ASSERTION(lastGlyphRun->mCharacterOffset <= aUTF16Offset,
 3609:                      "Glyph runs out of order (and run not forced)");
 2317: 
 2317:         if (lastGlyphRun->mFont == aFont)
 2317:             return NS_OK;
 2317:         if (lastGlyphRun->mCharacterOffset == aUTF16Offset) {
 2317:             lastGlyphRun->mFont = aFont;
 2317:             return NS_OK;
 2317:         }
 2317:     }
 2317: 
 3609:     NS_ASSERTION(aForceNewRun || numGlyphRuns > 0 || aUTF16Offset == 0,
 3609:                  "First run doesn't cover the first character (and run not forced)?");
 2317: 
    1:     GlyphRun *glyphRun = mGlyphRuns.AppendElement();
    1:     if (!glyphRun)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     glyphRun->mFont = aFont;
    1:     glyphRun->mCharacterOffset = aUTF16Offset;
    1:     return NS_OK;
    1: }
    1: 
 3609: void
 3609: gfxTextRun::SortGlyphRuns()
 3609: {
 5320:     if (mGlyphRuns.Length() <= 1)
 5320:         return;
 5320: 
 5320:     nsTArray<GlyphRun> runs(mGlyphRuns);
 3609:     GlyphRunOffsetComparator comp;
 5320:     runs.Sort(comp);
 5320: 
 5320:     // Now copy back, coalescing adjacent glyph runs that have the same font
 5320:     mGlyphRuns.Clear();
 5320:     PRUint32 i;
 5320:     for (i = 0; i < runs.Length(); ++i) {
 5320:         // a GlyphRun with the same font as the previous GlyphRun can just
 5320:         // be skipped; the last GlyphRun will cover its character range.
 5320:         if (i == 0 || runs[i].mFont != runs[i - 1].mFont) {
 5320:             mGlyphRuns.AppendElement(runs[i]);
21055:             // If two fonts have the same character offset, Sort() will have
21055:             // randomized the order.
21055:             NS_ASSERTION(i == 0 ||
21055:                          runs[i].mCharacterOffset !=
21055:                          runs[i - 1].mCharacterOffset,
21055:                          "Two fonts for the same run, glyph indices may not match the font");
 5320:         }
 5320:     }
 3609: }
 3609: 
26688: void
26688: gfxTextRun::SanitizeGlyphRuns()
26688: {
26688:     if (mGlyphRuns.Length() <= 1)
26688:         return;
26688: 
26688:     // If any glyph run starts with ligature-continuation characters, we need to advance it
26688:     // to the first "real" character to avoid drawing partial ligature glyphs from wrong font
26688:     // (seen with U+FEFF in reftest 474417-1, as Core Text eliminates the glyph, which makes
26688:     // it appear as if a ligature has been formed)
36923:     PRInt32 i, lastRunIndex = mGlyphRuns.Length() - 1;
36923:     for (i = lastRunIndex; i >= 0; --i) {
26688:         GlyphRun& run = mGlyphRuns[i];
26688:         while (mCharacterGlyphs[run.mCharacterOffset].IsLigatureContinuation() &&
26688:                run.mCharacterOffset < mCharacterCount) {
26688:             run.mCharacterOffset++;
26688:         }
26688:         // if the run has become empty, eliminate it
36923:         if ((i < lastRunIndex &&
36923:              run.mCharacterOffset >= mGlyphRuns[i+1].mCharacterOffset) ||
36923:             (i == lastRunIndex && run.mCharacterOffset == mCharacterCount)) {
26688:             mGlyphRuns.RemoveElementAt(i);
36923:             --lastRunIndex;
26688:         }
26688:     }
26688: }
26688: 
    1: PRUint32
    1: gfxTextRun::CountMissingGlyphs()
    1: {
    1:     PRUint32 i;
    1:     PRUint32 count = 0;
    1:     for (i = 0; i < mCharacterCount; ++i) {
    1:         if (mCharacterGlyphs[i].IsMissing()) {
    1:             ++count;
    1:         }
    1:     }
    1:     return count;
    1: }
    1: 
  132: gfxTextRun::DetailedGlyph *
  132: gfxTextRun::AllocateDetailedGlyphs(PRUint32 aIndex, PRUint32 aCount)
  132: {
10106:     NS_ASSERTION(aIndex < mCharacterCount, "Index out of range");
10106: 
  132:     if (!mCharacterGlyphs)
  132:         return nsnull;
  132: 
  132:     if (!mDetailedGlyphs) {
  132:         mDetailedGlyphs = new nsAutoArrayPtr<DetailedGlyph>[mCharacterCount];
  132:         if (!mDetailedGlyphs) {
 7715:             mCharacterGlyphs[aIndex].SetMissing(0);
  132:             return nsnull;
  132:         }
  132:     }
  132:     DetailedGlyph *details = new DetailedGlyph[aCount];
  132:     if (!details) {
 7715:         mCharacterGlyphs[aIndex].SetMissing(0);
  132:         return nsnull;
  132:     }
  132:     mDetailedGlyphs[aIndex] = details;
  132:     return details;
  132: }
  132: 
    1: void
 7715: gfxTextRun::SetGlyphs(PRUint32 aIndex, CompressedGlyph aGlyph,
 7715:                       const DetailedGlyph *aGlyphs)
    1: {
 7715:     NS_ASSERTION(!aGlyph.IsSimpleGlyph(), "Simple glyphs not handled here");
 7715:     NS_ASSERTION(aIndex > 0 ||
 7715:                  (aGlyph.IsClusterStart() && aGlyph.IsLigatureGroupStart()),
 7715:                  "First character must be the start of a cluster and can't be a ligature continuation!");
    1: 
 7715:     PRUint32 glyphCount = aGlyph.GetGlyphCount();
 7715:     if (glyphCount > 0) {
 7715:         DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, glyphCount);
  132:         if (!details)
    1:             return;
 7715:         memcpy(details, aGlyphs, sizeof(DetailedGlyph)*glyphCount);
 7715:     }
 7715:     mCharacterGlyphs[aIndex] = aGlyph;
  132: }
  132: 
41493: #include "ignorable.x-ccmap"
41493: DEFINE_X_CCMAP(gIgnorableCCMapExt, const);
41493: 
41493: static inline PRBool
41493: IsDefaultIgnorable(PRUint32 aChar)
41493: {
41493:     return CCMAP_HAS_CHAR_EXT(gIgnorableCCMapExt, aChar);
41493: }
41493: 
  132: void
 6135: gfxTextRun::SetMissingGlyph(PRUint32 aIndex, PRUint32 aChar)
  132: {
  132:     DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, 1);
  132:     if (!details)
  132:         return;
  132: 
  132:     details->mGlyphID = aChar;
  132:     GlyphRun *glyphRun = &mGlyphRuns[FindFirstGlyphRunContaining(aIndex)];
41493:     if (IsDefaultIgnorable(aChar)) {
41493:         // Setting advance width to zero will prevent drawing the hexbox
41493:         details->mAdvance = 0;
41493:     } else {
  132:         gfxFloat width = PR_MAX(glyphRun->mFont->GetMetrics().aveCharWidth,
 6135:                                 gfxFontMissingGlyphs::GetDesiredMinWidth(aChar));
  132:         details->mAdvance = PRUint32(width*GetAppUnitsPerDevUnit());
41493:     }
  132:     details->mXOffset = 0;
  132:     details->mYOffset = 0;
 7715:     mCharacterGlyphs[aIndex].SetMissing(1);
    1: }
    1: 
43527: PRBool
43527: gfxTextRun::FilterIfIgnorable(PRUint32 aIndex)
43527: {
43527:     PRUint32 ch = GetChar(aIndex);
43527:     if (IsDefaultIgnorable(ch)) {
43527:         DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, 1);
43527:         if (details) {
43527:             details->mGlyphID = ch;
43527:             details->mAdvance = 0;
43527:             details->mXOffset = 0;
43527:             details->mYOffset = 0;
43527:             mCharacterGlyphs[aIndex].SetMissing(1);
43527:             return PR_TRUE;
43527:         }
43527:     }
43527:     return PR_FALSE;
43527: }
43527: 
 2317: static void
 2317: ClearCharacters(gfxTextRun::CompressedGlyph *aGlyphs, PRUint32 aLength)
 2317: {
 7715:     memset(aGlyphs, 0, sizeof(gfxTextRun::CompressedGlyph)*aLength);
 2317: }
 2317: 
 2317: void
 2317: gfxTextRun::CopyGlyphDataFrom(gfxTextRun *aSource, PRUint32 aStart,
 2317:                               PRUint32 aLength, PRUint32 aDest,
 2317:                               PRBool aStealData)
 2317: {
 2317:     NS_ASSERTION(aStart + aLength <= aSource->GetLength(),
 2317:                  "Source substring out of range");
 2317:     NS_ASSERTION(aDest + aLength <= GetLength(),
 2317:                  "Destination substring out of range");
 2317: 
 2317:     PRUint32 i;
 7715:     // Copy base character data
 2317:     for (i = 0; i < aLength; ++i) {
 2317:         CompressedGlyph g = aSource->mCharacterGlyphs[i + aStart];
 3537:         g.SetCanBreakBefore(mCharacterGlyphs[i + aDest].CanBreakBefore());
 2317:         mCharacterGlyphs[i + aDest] = g;
 2317:         if (aStealData) {
 7715:             aSource->mCharacterGlyphs[i + aStart].SetMissing(0);
 2317:         }
 2317:     }
 2317: 
 7715:     // Copy detailed glyphs
 2317:     if (aSource->mDetailedGlyphs) {
 2317:         for (i = 0; i < aLength; ++i) {
 2317:             DetailedGlyph *details = aSource->mDetailedGlyphs[i + aStart];
 2317:             if (details) {
 2317:                 if (aStealData) {
 2317:                     if (!mDetailedGlyphs) {
 2317:                         mDetailedGlyphs = new nsAutoArrayPtr<DetailedGlyph>[mCharacterCount];
 2317:                         if (!mDetailedGlyphs) {
 2317:                             ClearCharacters(&mCharacterGlyphs[aDest], aLength);
 2317:                             return;
 2317:                         }
 2317:                     }        
 2317:                     mDetailedGlyphs[i + aDest] = details;
 2317:                     aSource->mDetailedGlyphs[i + aStart].forget();
 2317:                 } else {
 7715:                     PRUint32 glyphCount = mCharacterGlyphs[i + aDest].GetGlyphCount();
 2317:                     DetailedGlyph *dest = AllocateDetailedGlyphs(i + aDest, glyphCount);
 2317:                     if (!dest) {
 2317:                         ClearCharacters(&mCharacterGlyphs[aDest], aLength);
 2317:                         return;
 2317:                     }
 2317:                     memcpy(dest, details, sizeof(DetailedGlyph)*glyphCount);
 2317:                 }
 2317:             } else if (mDetailedGlyphs) {
 2317:                 mDetailedGlyphs[i + aDest] = nsnull;
 2317:             }
 2317:         }
 2317:     } else if (mDetailedGlyphs) {
 2317:         for (i = 0; i < aLength; ++i) {
 2317:             mDetailedGlyphs[i + aDest] = nsnull;
 2317:         }
 2317:     }
 2317: 
 7715:     // Copy glyph runs
 2317:     GlyphRunIterator iter(aSource, aStart, aLength);
 5320: #ifdef DEBUG
 5320:     gfxFont *lastFont = nsnull;
 5320: #endif
 2317:     while (iter.NextRun()) {
 2317:         gfxFont *font = iter.GetGlyphRun()->mFont;
 5320:         NS_ASSERTION(font != lastFont, "Glyphruns not coalesced?");
 5320: #ifdef DEBUG
 5320:         lastFont = font;
19254:         PRUint32 end = iter.GetStringEnd();
 5320: #endif
 2317:         PRUint32 start = iter.GetStringStart();
37649: 
37649:         // These used to be NS_ASSERTION()s, but WARNING is more appropriate.
37649:         // Although it's unusual (and not desirable), it's possible for us to assign
26688:         // different fonts to a base character and a following diacritic.
37649:         // Example on OSX 10.5/10.6 with default fonts installed:
37649:         //     data:text/html,<p style="font-family:helvetica, arial, sans-serif;">
37649:         //                    &#x043E;&#x0486;&#x20;&#x043E;&#x0486;
37649:         // This means the rendering of the cluster will probably not be very good,
37649:         // but it's the best we can do for now if the specified font only covered the
37649:         // initial base character and not its applied marks.
37649:         NS_WARN_IF_FALSE(aSource->IsClusterStart(start),
37649:                          "Started font run in the middle of a cluster");
37649:         NS_WARN_IF_FALSE(end == aSource->GetLength() || aSource->IsClusterStart(end),
37649:                          "Ended font run in the middle of a cluster");
 2317: 
 2317:         nsresult rv = AddGlyphRun(font, start - aStart + aDest);
 2317:         if (NS_FAILED(rv))
 2317:             return;
 2317:     }
 2317: }
 2317: 
 2317: void
 2317: gfxTextRun::SetSpaceGlyph(gfxFont *aFont, gfxContext *aContext, PRUint32 aCharIndex)
 2317: {
 2317:     PRUint32 spaceGlyph = aFont->GetSpaceGlyph();
 2317:     float spaceWidth = aFont->GetMetrics().spaceWidth;
 2317:     PRUint32 spaceWidthAppUnits = NS_lroundf(spaceWidth*mAppUnitsPerDevUnit);
 2317:     if (!spaceGlyph ||
 2317:         !CompressedGlyph::IsSimpleGlyphID(spaceGlyph) ||
 2317:         !CompressedGlyph::IsSimpleAdvance(spaceWidthAppUnits)) {
 2317:         gfxTextRunFactory::Parameters params = {
 2317:             aContext, nsnull, nsnull, nsnull, 0, mAppUnitsPerDevUnit
 2317:         };
 2317:         static const PRUint8 space = ' ';
 2317:         nsAutoPtr<gfxTextRun> textRun;
 2317:         textRun = mFontGroup->MakeTextRun(&space, 1, &params,
 2317:             gfxTextRunFactory::TEXT_IS_8BIT | gfxTextRunFactory::TEXT_IS_ASCII |
 2317:             gfxTextRunFactory::TEXT_IS_PERSISTENT);
 2317:         if (!textRun || !textRun->mCharacterGlyphs)
 2317:             return;
 2317:         CopyGlyphDataFrom(textRun, 0, 1, aCharIndex, PR_TRUE);
 2317:         return;
 2317:     }
 2317: 
 2317:     AddGlyphRun(aFont, aCharIndex);
 2317:     CompressedGlyph g;
 2317:     g.SetSimpleGlyph(spaceWidthAppUnits, spaceGlyph);
 7715:     SetSimpleGlyph(aCharIndex, g);
 2317: }
 6247: 
 6247: void
 6247: gfxTextRun::FetchGlyphExtents(gfxContext *aRefContext)
 6247: {
29527:     PRBool needsGlyphExtents = NeedsGlyphExtents(this);
29527:     if (!needsGlyphExtents && !mDetailedGlyphs)
 6247:         return;
 6247: 
 6247:     PRUint32 i;
 6247:     CompressedGlyph *charGlyphs = mCharacterGlyphs;
 6247:     for (i = 0; i < mGlyphRuns.Length(); ++i) {
 6247:         gfxFont *font = mGlyphRuns[i].mFont;
 6247:         PRUint32 start = mGlyphRuns[i].mCharacterOffset;
 6247:         PRUint32 end = i + 1 < mGlyphRuns.Length()
 6247:             ? mGlyphRuns[i + 1].mCharacterOffset : GetLength();
 6247:         PRBool fontIsSetup = PR_FALSE;
 6247:         PRUint32 j;
 6247:         gfxGlyphExtents *extents = font->GetOrCreateGlyphExtents(mAppUnitsPerDevUnit);
 6247:   
 6247:         for (j = start; j < end; ++j) {
 6247:             const gfxTextRun::CompressedGlyph *glyphData = &charGlyphs[j];
 6247:             if (glyphData->IsSimpleGlyph()) {
 6247:                 // If we're in speed mode, don't set up glyph extents here; we'll
 6247:                 // just return "optimistic" glyph bounds later
29527:                 if (needsGlyphExtents) {
 6247:                     PRUint32 glyphIndex = glyphData->GetSimpleGlyph();
 6247:                     if (!extents->IsGlyphKnown(glyphIndex)) {
 6247:                         if (!fontIsSetup) {
 6247:                             font->SetupCairoFont(aRefContext);
 6247:                              fontIsSetup = PR_TRUE;
 6247:                         }
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:                         ++gGlyphExtentsSetupEagerSimple;
 6513: #endif
 6247:                         font->SetupGlyphExtents(aRefContext, glyphIndex, PR_FALSE, extents);
 6247:                     }
 6247:                 }
 9576:             } else if (!glyphData->IsMissing()) {
 7715:                 PRUint32 k;
 7715:                 PRUint32 glyphCount = glyphData->GetGlyphCount();
 7685:                 const gfxTextRun::DetailedGlyph *details = GetDetailedGlyphs(j);
 7715:                 for (k = 0; k < glyphCount; ++k, ++details) {
 6247:                     PRUint32 glyphIndex = details->mGlyphID;
 6247:                     if (!extents->IsGlyphKnownWithTightExtents(glyphIndex)) {
 6247:                         if (!fontIsSetup) {
 6247:                             font->SetupCairoFont(aRefContext);
 6247:                             fontIsSetup = PR_TRUE;
 6247:                         }
 6513: #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
 6513:                         ++gGlyphExtentsSetupEagerTight;
 6513: #endif
 6247:                         font->SetupGlyphExtents(aRefContext, glyphIndex, PR_TRUE, extents);
 6247:                     }
 6247:                 }
 6247:             }
 6247:         }
 6247:     }
 6247: }
10484: 
10484: #ifdef DEBUG
10484: void
10484: gfxTextRun::Dump(FILE* aOutput) {
10484:     if (!aOutput) {
10484:         aOutput = stdout;
10484:     }
10484: 
10484:     PRUint32 i;
10484:     fputc('"', aOutput);
10484:     for (i = 0; i < mCharacterCount; ++i) {
10484:         PRUnichar ch = GetChar(i);
10484:         if (ch >= 32 && ch < 128) {
10484:             fputc(ch, aOutput);
10484:         } else {
10484:             fprintf(aOutput, "\\u%4x", ch);
10484:         }
10484:     }
10484:     fputs("\" [", aOutput);
10484:     for (i = 0; i < mGlyphRuns.Length(); ++i) {
10484:         if (i > 0) {
10484:             fputc(',', aOutput);
10484:         }
10484:         gfxFont* font = mGlyphRuns[i].mFont;
10484:         const gfxFontStyle* style = font->GetStyle();
10484:         NS_ConvertUTF16toUTF8 fontName(font->GetName());
38493:         nsCAutoString lang;
38493:         style->language->ToUTF8String(lang);
10484:         fprintf(aOutput, "%d: %s %f/%d/%d/%s", mGlyphRuns[i].mCharacterOffset,
10484:                 fontName.get(), style->size,
38493:                 style->weight, style->style, lang.get());
10484:     }
10484:     fputc(']', aOutput);
10484: }
10484: #endif
