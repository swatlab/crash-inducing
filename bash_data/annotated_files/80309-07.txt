    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
72272:  *   Ms2ger <ms2ger@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef nsIDocument_h___
    1: #define nsIDocument_h___
    1: 
    1: #include "nsINode.h"
    1: #include "nsStringGlue.h"
    1: #include "nsIDocumentObserver.h" // for nsUpdateType
    1: #include "nsCOMPtr.h"
 5684: #include "nsCOMArray.h"
    1: #include "nsIURI.h"
    1: #include "nsWeakPtr.h"
    1: #include "nsIWeakReferenceUtils.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsCRT.h"
    1: #include "mozFlushType.h"
    1: #include "nsIAtom.h"
    1: #include "nsCompatibility.h"
 1722: #include "nsTObserverArray.h"
28108: #include "nsTHashtable.h"
28108: #include "nsHashKeys.h"
13669: #include "nsNodeInfoManager.h"
20078: #include "nsIStreamListener.h"
62765: #include "nsIVariant.h"
20078: #include "nsIObserver.h"
37059: #include "nsGkAtoms.h"
28108: #include "nsAutoPtr.h"
41409: #include "nsPIDOMWindow.h"
23697: #ifdef MOZ_SMIL
38869: #include "nsSMILAnimationController.h"
23697: #endif // MOZ_SMIL
42823: #include "nsIScriptGlobalObject.h"
46309: #include "nsIDocumentEncoder.h"
52255: #include "nsIAnimationFrameListener.h"
56168: #include "nsEventStates.h"
69563: #include "nsIStructuredCloneContainer.h"
74267: #include "nsDOMMemoryReporter.h"
    1: 
    1: class nsIContent;
    1: class nsPresContext;
    1: class nsIPresShell;
14660: class nsIDocShell;
    1: class nsStyleSet;
    1: class nsIStyleSheet;
    1: class nsIStyleRule;
42163: class nsCSSStyleSheet;
    1: class nsIViewManager;
    1: class nsIDOMEvent;
25572: class nsIDOMEventTarget;
68668: class nsDeviceContext;
    1: class nsIParser;
    1: class nsIDOMNode;
21333: class nsIDOMElement;
    1: class nsIDOMDocumentFragment;
    1: class nsILineBreaker;
    1: class nsIWordBreaker;
    1: class nsISelection;
    1: class nsIChannel;
    1: class nsIPrincipal;
    1: class nsIDOMDocument;
    1: class nsIDOMDocumentType;
    1: class nsScriptLoader;
    1: class nsIContentSink;
    1: class nsHTMLStyleSheet;
36782: class nsHTMLCSSStyleSheet;
    1: class nsILayoutHistoryState;
    1: class nsIVariant;
    1: class nsIDOMUserDataHandler;
    1: template<class E> class nsCOMArray;
    1: class nsIDocumentObserver;
    1: class nsBindingManager;
    1: class nsIDOMNodeList;
   62: class mozAutoSubtreeModified;
 8635: struct JSObject;
12256: class nsFrameLoader;
26701: class nsIBoxObject;
50815: class imgIRequest;
58185: class nsISHEntry;
72298: class nsDOMNavigationTiming;
    1: 
38488: namespace mozilla {
38851: namespace css {
38851: class Loader;
38851: } // namespace css
38851: 
38488: namespace dom {
38488: class Link;
41634: class Element;
38488: } // namespace dom
38488: } // namespace mozilla
38488: 
    1: #define NS_IDOCUMENT_IID      \
80309: { 0x4114a7c7, 0xb2f4, 0x4dea, \
80309:  { 0xac, 0x78, 0x20, 0xab, 0xda, 0x6f, 0xb2, 0xaf } }
    1: 
    1: // Flag for AddStyleSheet().
    1: #define NS_STYLESHEET_FROM_CATALOG                (1 << 0)
    1: 
39698: // Document states
39698: 
39698: // RTL locale: specific to the XUL localedir attribute
56168: #define NS_DOCUMENT_STATE_RTL_LOCALE              NS_DEFINE_EVENT_STATE_MACRO(0)
39698: // Window activation status
56168: #define NS_DOCUMENT_STATE_WINDOW_INACTIVE         NS_DEFINE_EVENT_STATE_MACRO(1)
39698: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Document interface.  This is implemented by all document objects in
    1: // Gecko.
    1: class nsIDocument : public nsINode
    1: {
    1: public:
42325:   typedef mozilla::dom::Element Element;
42325: 
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IDOCUMENT_IID)
    1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
74267:   NS_DECL_DOM_MEMORY_REPORTER_SIZEOF
    1: 
    1: #ifdef MOZILLA_INTERNAL_API
    1:   nsIDocument()
    1:     : nsINode(nsnull),
    1:       mCharacterSet(NS_LITERAL_CSTRING("ISO-8859-1")),
    1:       mNodeInfoManager(nsnull),
    1:       mCompatMode(eCompatibility_FullStandards),
    1:       mIsInitialDocumentInWindow(PR_FALSE),
10474:       mMayStartLayout(PR_TRUE),
34205:       mVisible(PR_TRUE),
34205:       mRemovedFromDocShell(PR_FALSE),
28460:       // mAllowDNSPrefetch starts true, so that we can always reliably && it
28460:       // with various values that might disable it.  Since we never prefetch
28460:       // unless we get a window, and in that case the docshell value will get
28460:       // &&-ed in, this is safe.
28460:       mAllowDNSPrefetch(PR_TRUE),
52207:       mIsBeingUsedAsImage(PR_FALSE),
26412:       mPartID(0)
    1:   {
67605:     SetInDocument();
    1:   }
    1: #endif
    1:   
    1:   /**
    1:    * Let the document know that we're starting to load data into it.
    1:    * @param aCommand The parser command
    1:    *                 XXXbz It's odd to have that here.
    1:    * @param aChannel The channel the data will come from
    1:    * @param aLoadGroup The loadgroup this document should use from now on.
    1:    *                   Note that the document might not be the only thing using
    1:    *                   this loadgroup.
    1:    * @param aContainer The container this document is in.  This may be null.
    1:    *                   XXXbz maybe we should make it more explicit (eg make the
    1:    *                   container an nsIWebNavigation or nsIDocShell or
    1:    *                   something)?
    1:    * @param [out] aDocListener the listener to pump data from the channel into.
    1:    *                           Generally this will be the parser this document
    1:    *                           sets up, or some sort of data-handler for media
    1:    *                           documents.
    1:    * @param aReset whether the document should call Reset() on itself.  If this
    1:    *               is false, the document will NOT set its principal to the
    1:    *               channel's owner, will not clear any event listeners that are
    1:    *               already set on it, etc.
    1:    * @param aSink The content sink to use for the data.  If this is null and
    1:    *              the document needs a content sink, it will create one based
    1:    *              on whatever it knows about the data it's going to load.
10474:    *
10474:    * Once this has been called, the document will return false for
10474:    * MayStartLayout() until SetMayStartLayout(PR_TRUE) is called on it.  Making
10474:    * sure this happens is the responsibility of the caller of
10474:    * StartDocumentLoad().
    1:    */  
    1:   virtual nsresult StartDocumentLoad(const char* aCommand,
    1:                                      nsIChannel* aChannel,
    1:                                      nsILoadGroup* aLoadGroup,
    1:                                      nsISupports* aContainer,
    1:                                      nsIStreamListener **aDocListener,
79445:                                      bool aReset,
    1:                                      nsIContentSink* aSink = nsnull) = 0;
    1:   virtual void StopDocumentLoad() = 0;
    1: 
    1:   /**
16977:    * Signal that the document title may have changed
16977:    * (see nsDocument::GetTitle).
16977:    * @param aBoundTitleElement true if an HTML or SVG <title> element
16977:    * has just been bound to the document.
    1:    */
79445:   virtual void NotifyPossibleTitleChange(bool aBoundTitleElement) = 0;
    1: 
    1:   /**
    1:    * Return the URI for the document. May return null.
59194:    *
59194:    * The value returned corresponds to the "document's current address" in
59194:    * HTML5.  As such, it may change over the lifetime of the document, for
59194:    * instance as a result of a call to pushState() or replaceState().
    1:    */
    1:   nsIURI* GetDocumentURI() const
    1:   {
    1:     return mDocumentURI;
    1:   }
    1: 
    1:   /**
59194:    * Return the original URI of the document.  This is the same as the
59194:    * document's URI unless history.pushState() or replaceState() is invoked on
59194:    * the document.
59194:    *
59194:    * This method corresponds to the "document's address" in HTML5 and, once
59194:    * set, doesn't change over the lifetime of the document.
59194:    */
59194:   nsIURI* GetOriginalURI() const
59194:   {
59194:     return mOriginalURI;
59194:   }
59194: 
59194:   /**
59194:    * Set the URI for the document.  This also sets the document's original URI,
59194:    * if it's null.
    1:    */
    1:   virtual void SetDocumentURI(nsIURI* aURI) = 0;
    1: 
    1:   /**
    1:    * Set the principal responsible for this document.
    1:    */
    1:   virtual void SetPrincipal(nsIPrincipal *aPrincipal) = 0;
    1: 
    1:   /**
    1:    * Return the LoadGroup for the document. May return null.
    1:    */
    1:   already_AddRefed<nsILoadGroup> GetDocumentLoadGroup() const
    1:   {
    1:     nsILoadGroup *group = nsnull;
    1:     if (mDocumentLoadGroup)
    1:       CallQueryReferent(mDocumentLoadGroup.get(), &group);
    1: 
    1:     return group;
    1:   }
    1: 
    1:   /**
    1:    * Return the base URI for relative URIs in the document (the document uri
    1:    * unless it's overridden by SetBaseURI, HTML <base> tags, etc.).  The
    1:    * returned URI could be null if there is no document URI.
    1:    */
41900:   nsIURI* GetDocBaseURI() const
    1:   {
    1:     return mDocumentBaseURI ? mDocumentBaseURI : mDocumentURI;
    1:   }
41900:   virtual already_AddRefed<nsIURI> GetBaseURI() const
41900:   {
41900:     nsCOMPtr<nsIURI> uri = GetDocBaseURI();
41900: 
41900:     return uri.forget();
41900:   }
41900: 
    1:   virtual nsresult SetBaseURI(nsIURI* aURI) = 0;
    1: 
    1:   /**
    1:    * Get/Set the base target of a link in a document.
    1:    */
41221:   virtual void GetBaseTarget(nsAString &aBaseTarget) = 0;
60507:   void SetBaseTarget(const nsString& aBaseTarget) {
60507:     mBaseTarget = aBaseTarget;
60507:   }
    1: 
    1:   /**
16447:    * Return a standard name for the document's character set.
    1:    */
    1:   const nsCString& GetDocumentCharacterSet() const
    1:   {
    1:     return mCharacterSet;
    1:   }
    1: 
    1:   /**
    1:    * Set the document's character encoding. |aCharSetID| should be canonical. 
    1:    * That is, callers are responsible for the charset alias resolution. 
    1:    */
    1:   virtual void SetDocumentCharacterSet(const nsACString& aCharSetID) = 0;
    1: 
    1:   PRInt32 GetDocumentCharacterSetSource() const
    1:   {
    1:     return mCharacterSetSource;
    1:   }
    1: 
 1300:   // This method MUST be called before SetDocumentCharacterSet if
 1300:   // you're planning to call both.
    1:   void SetDocumentCharacterSetSource(PRInt32 aCharsetSource)
    1:   {
    1:     mCharacterSetSource = aCharsetSource;
    1:   }
    1: 
    1:   /**
    1:    * Add an observer that gets notified whenever the charset changes.
    1:    */
    1:   virtual nsresult AddCharSetObserver(nsIObserver* aObserver) = 0;
    1: 
    1:   /**
    1:    * Remove a charset observer.
    1:    */
    1:   virtual void RemoveCharSetObserver(nsIObserver* aObserver) = 0;
    1: 
    1:   /**
15515:    * This gets fired when the element that an id refers to changes.
15515:    * This fires at difficult times. It is generally not safe to do anything
15515:    * which could modify the DOM in any way. Use
15515:    * nsContentUtils::AddScriptRunner.
15515:    * @return PR_TRUE to keep the callback in the callback set, PR_FALSE
15515:    * to remove it.
15515:    */
79445:   typedef bool (* IDTargetObserver)(Element* aOldElement,
42325:                                       Element* aNewelement, void* aData);
15515: 
15515:   /**
15515:    * Add an IDTargetObserver for a specific ID. The IDTargetObserver
15515:    * will be fired whenever the content associated with the ID changes
50428:    * in the future. If aForImage is true, mozSetImageElement can override
50428:    * what content is associated with the ID. In that case the IDTargetObserver
50428:    * will be notified at those times when the result of LookupImageElement
50428:    * changes.
50428:    * At most one (aObserver, aData, aForImage) triple can be
50428:    * registered for each ID.
15515:    * @return the content currently associated with the ID.
15515:    */
42325:   virtual Element* AddIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
79445:                                        void* aData, bool aForImage) = 0;
15515:   /**
50428:    * Remove the (aObserver, aData, aForImage) triple for a specific ID, if
50428:    * registered.
15515:    */
50428:   virtual void RemoveIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
79445:                                       void* aData, bool aForImage) = 0;
15515: 
15515:   /**
    1:    * Get the Content-Type of this document.
    1:    * (This will always return NS_OK, but has this signature to be compatible
70983:    *  with nsIDOMDocument::GetContentType())
    1:    */
    1:   NS_IMETHOD GetContentType(nsAString& aContentType) = 0;
    1: 
    1:   /**
    1:    * Set the Content-Type of this document.
    1:    */
    1:   virtual void SetContentType(const nsAString& aContentType) = 0;
    1: 
    1:   /**
    1:    * Return the language of this document.
    1:    */
    1:   void GetContentLanguage(nsAString& aContentLanguage) const
    1:   {
    1:     CopyASCIItoUTF16(mContentLanguage, aContentLanguage);
    1:   }
    1: 
10073:   // The states BidiEnabled and MathMLEnabled should persist across multiple views
    1:   // (screen, print) of the same document.
    1: 
    1:   /**
    1:    * Check if the document contains bidi data.
    1:    * If so, we have to apply the Unicode Bidi Algorithm.
    1:    */
79445:   bool GetBidiEnabled() const
    1:   {
    1:     return mBidiEnabled;
    1:   }
    1: 
    1:   /**
    1:    * Indicate the document contains bidi data.
    1:    * Currently, we cannot disable bidi, because once bidi is enabled,
    1:    * it affects a frame model irreversibly, and plays even though
    1:    * the document no longer contains bidi data.
    1:    */
15376:   void SetBidiEnabled()
    1:   {
15376:     mBidiEnabled = PR_TRUE;
    1:   }
    1:   
    1:   /**
10073:    * Check if the document contains (or has contained) any MathML elements.
10073:    */
79445:   bool GetMathMLEnabled() const
10073:   {
10073:     return mMathMLEnabled;
10073:   }
10073:   
10073:   void SetMathMLEnabled()
10073:   {
10073:     mMathMLEnabled = PR_TRUE;
10073:   }
10073: 
10073:   /**
    1:    * Ask this document whether it's the initial document in its window.
    1:    */
79445:   bool IsInitialDocument() const
    1:   {
    1:     return mIsInitialDocumentInWindow;
    1:   }
    1:   
    1:   /**
    1:    * Tell this document that it's the initial document in its window.  See
    1:    * comments on mIsInitialDocumentInWindow for when this should be called.
    1:    */
79445:   void SetIsInitialDocument(bool aIsInitialDocument)
    1:   {
    1:     mIsInitialDocumentInWindow = aIsInitialDocument;
    1:   }
    1:   
    1: 
    1:   /**
    1:    * Get the bidi options for this document.
    1:    * @see nsBidiUtils.h
    1:    */
    1:   PRUint32 GetBidiOptions() const
    1:   {
    1:     return mBidiOptions;
    1:   }
    1: 
    1:   /**
    1:    * Set the bidi options for this document.  This just sets the bits;
    1:    * callers are expected to take action as needed if they want this
    1:    * change to actually change anything immediately.
    1:    * @see nsBidiUtils.h
    1:    */
    1:   void SetBidiOptions(PRUint32 aBidiOptions)
    1:   {
    1:     mBidiOptions = aBidiOptions;
    1:   }
    1:   
    1:   /**
    1:    * Access HTTP header data (this may also get set from other
    1:    * sources, like HTML META tags).
    1:    */
    1:   virtual void GetHeaderData(nsIAtom* aHeaderField, nsAString& aData) const = 0;
    1:   virtual void SetHeaderData(nsIAtom* aheaderField, const nsAString& aData) = 0;
    1: 
    1:   /**
    1:    * Create a new presentation shell that will use aContext for its
    1:    * presentation context (presentation contexts <b>must not</b> be
10474:    * shared among multiple presentation shells). The caller of this
10474:    * method is responsible for calling BeginObservingDocument() on the
10474:    * presshell if the presshell should observe document mutations.
    1:    */
    1:   virtual nsresult CreateShell(nsPresContext* aContext,
    1:                                nsIViewManager* aViewManager,
    1:                                nsStyleSet* aStyleSet,
    1:                                nsIPresShell** aInstancePtrResult) = 0;
49570:   virtual void DeleteShell() = 0;
36917: 
46225:   nsIPresShell* GetShell() const
36917:   {
58185:     return GetBFCacheEntry() ? nsnull : mPresShell;
36917:   }
36917: 
80309:   void SetBFCacheEntry(nsISHEntry* aSHEntry) {
80309:     mSHEntry = aSHEntry;
58185:   }
58185: 
80309:   nsISHEntry* GetBFCacheEntry() const { return mSHEntry; }
    1: 
    1:   /**
    1:    * Return the parent document of this document. Will return null
    1:    * unless this document is within a compound document and has a
    1:    * parent. Note that this parent chain may cross chrome boundaries.
    1:    */
    1:   nsIDocument *GetParentDocument() const
    1:   {
    1:     return mParentDocument;
    1:   }
    1: 
    1:   /**
    1:    * Set the parent document of this document.
    1:    */
    1:   void SetParentDocument(nsIDocument* aParent)
    1:   {
    1:     mParentDocument = aParent;
    1:   }
    1: 
    1:   /**
    1:    * Set the sub document for aContent to aSubDoc.
    1:    */
    1:   virtual nsresult SetSubDocumentFor(nsIContent *aContent,
    1:                                      nsIDocument* aSubDoc) = 0;
    1: 
    1:   /**
    1:    * Get the sub document for aContent
    1:    */
    1:   virtual nsIDocument *GetSubDocumentFor(nsIContent *aContent) const = 0;
    1: 
    1:   /**
    1:    * Find the content node for which aDocument is a sub document.
    1:    */
    1:   virtual nsIContent *FindContentForSubDocument(nsIDocument *aDocument) const = 0;
    1: 
    1:   /**
41634:    * Return the root element for this document.
    1:    */
79452:   Element *GetRootElement() const;
79452: 
41634: protected:
42325:   virtual Element *GetRootElementInternal() const = 0;
    1: 
41634: public:
37059:   // Get the root <html> element, or return null if there isn't one (e.g.
37059:   // if the root isn't <html>)
42325:   Element* GetHtmlElement();
37059:   // Returns the first child of GetHtmlContent which has the given tag,
37059:   // or nsnull if that doesn't exist.
42325:   Element* GetHtmlChildElement(nsIAtom* aTag);
37059:   // Get the canonical <body> element, or return null if there isn't one (e.g.
37059:   // if the root isn't <html> or if the <body> isn't there)
42325:   Element* GetBodyElement() {
41634:     return GetHtmlChildElement(nsGkAtoms::body);
37059:   }
37059:   // Get the canonical <head> element, or return null if there isn't one (e.g.
37059:   // if the root isn't <html> or if the <head> isn't there)
42325:   Element* GetHeadElement() {
41634:     return GetHtmlChildElement(nsGkAtoms::head);
37059:   }
37059:   
    1:   /**
    1:    * Accessors to the collection of stylesheets owned by this document.
    1:    * Style sheets are ordered, most significant last.
    1:    */
    1: 
    1:   /**
    1:    * Get the number of stylesheets
    1:    *
    1:    * @return the number of stylesheets
    1:    * @throws no exceptions
    1:    */
    1:   virtual PRInt32 GetNumberOfStyleSheets() const = 0;
    1:   
    1:   /**
    1:    * Get a particular stylesheet
    1:    * @param aIndex the index the stylesheet lives at.  This is zero-based
    1:    * @return the stylesheet at aIndex.  Null if aIndex is out of range.
    1:    * @throws no exceptions
    1:    */
    1:   virtual nsIStyleSheet* GetStyleSheetAt(PRInt32 aIndex) const = 0;
    1:   
    1:   /**
    1:    * Insert a sheet at a particular spot in the stylesheet list (zero-based)
    1:    * @param aSheet the sheet to insert
    1:    * @param aIndex the index to insert at.  This index will be
    1:    *   adjusted for the "special" sheets.
    1:    * @throws no exceptions
    1:    */
    1:   virtual void InsertStyleSheetAt(nsIStyleSheet* aSheet, PRInt32 aIndex) = 0;
    1: 
    1:   /**
    1:    * Get the index of a particular stylesheet.  This will _always_
    1:    * consider the "special" sheets as part of the sheet list.
    1:    * @param aSheet the sheet to get the index of
    1:    * @return aIndex the index of the sheet in the full list
    1:    */
    1:   virtual PRInt32 GetIndexOfStyleSheet(nsIStyleSheet* aSheet) const = 0;
    1: 
    1:   /**
    1:    * Replace the stylesheets in aOldSheets with the stylesheets in
    1:    * aNewSheets. The two lists must have equal length, and the sheet
    1:    * at positon J in the first list will be replaced by the sheet at
    1:    * position J in the second list.  Some sheets in the second list
    1:    * may be null; if so the corresponding sheets in the first list
    1:    * will simply be removed.
    1:    */
    1:   virtual void UpdateStyleSheets(nsCOMArray<nsIStyleSheet>& aOldSheets,
    1:                                  nsCOMArray<nsIStyleSheet>& aNewSheets) = 0;
    1: 
    1:   /**
    1:    * Add a stylesheet to the document
    1:    */
    1:   virtual void AddStyleSheet(nsIStyleSheet* aSheet) = 0;
    1: 
    1:   /**
    1:    * Remove a stylesheet from the document
    1:    */
    1:   virtual void RemoveStyleSheet(nsIStyleSheet* aSheet) = 0;
    1: 
    1:   /**
    1:    * Notify the document that the applicable state of the sheet changed
    1:    * and that observers should be notified and style sets updated
    1:    */
    1:   virtual void SetStyleSheetApplicableState(nsIStyleSheet* aSheet,
79445:                                             bool aApplicable) = 0;  
    1: 
    1:   /**
    1:    * Just like the style sheet API, but for "catalog" sheets,
    1:    * extra sheets inserted at the UA level.
    1:    */
    1:   virtual PRInt32 GetNumberOfCatalogStyleSheets() const = 0;
    1:   virtual nsIStyleSheet* GetCatalogStyleSheetAt(PRInt32 aIndex) const = 0;
    1:   virtual void AddCatalogStyleSheet(nsIStyleSheet* aSheet) = 0;
    1:   virtual void EnsureCatalogStyleSheet(const char *aStyleSheetURI) = 0;
    1: 
    1:   /**
    1:    * Get this document's CSSLoader.  This is guaranteed to not return null.
    1:    */
38851:   mozilla::css::Loader* CSSLoader() const {
    1:     return mCSSLoader;
    1:   }
    1: 
    1:   /**
    1:    * Get the channel that was passed to StartDocumentLoad or Reset for this
    1:    * document.  Note that this may be null in some cases (eg if
    1:    * StartDocumentLoad or Reset were never called)
    1:    */
    1:   virtual nsIChannel* GetChannel() const = 0;
    1: 
    1:   /**
    1:    * Get this document's attribute stylesheet.  May return null if
    1:    * there isn't one.
    1:    */
    1:   virtual nsHTMLStyleSheet* GetAttributeStyleSheet() const = 0;
    1: 
    1:   /**
    1:    * Get this document's inline style sheet.  May return null if there
    1:    * isn't one
    1:    */
36782:   virtual nsHTMLCSSStyleSheet* GetInlineStyleSheet() const = 0;
    1: 
    1:   /**
    1:    * Get/set the object from which a document can get a script context
    1:    * and scope. This is the context within which all scripts (during
    1:    * document creation and during event handling) will run. Note that
    1:    * this is the *inner* window object.
    1:    */
    1:   virtual nsIScriptGlobalObject* GetScriptGlobalObject() const = 0;
    1:   virtual void SetScriptGlobalObject(nsIScriptGlobalObject* aGlobalObject) = 0;
    1: 
    1:   /**
 6475:    * Get/set the object from which the context for the event/script handling can
 6475:    * be got. Normally GetScriptHandlingObject() returns the same object as
 6475:    * GetScriptGlobalObject(), but if the document is loaded as data,
 6475:    * non-null may be returned, even if GetScriptGlobalObject() returns null.
 6475:    * aHasHadScriptHandlingObject is set PR_TRUE if document has had the object
 6475:    * for event/script handling. Do not process any events/script if the method
 6475:    * returns null, but aHasHadScriptHandlingObject is true.
 6475:    */
42823:   nsIScriptGlobalObject*
79445:     GetScriptHandlingObject(bool& aHasHadScriptHandlingObject) const
42823:   {
42823:     aHasHadScriptHandlingObject = mHasHadScriptHandlingObject;
42823:     return mScriptGlobalObject ? mScriptGlobalObject.get() :
42823:                                  GetScriptHandlingObjectInternal();
42823:   }
 6475:   virtual void SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject) = 0;
 6475: 
 6475:   /**
    1:    * Get the object that is used as the scope for all of the content
    1:    * wrappers whose owner document is this document. Unlike the script global
    1:    * object, this will only return null when the global object for this
    1:    * document is truly gone. Use this object when you're trying to find a
    1:    * content wrapper in XPConnect.
    1:    */
    1:   virtual nsIScriptGlobalObject* GetScopeObject() = 0;
    1: 
    1:   /**
    1:    * Return the window containing the document (the outer window).
    1:    */
63954:   nsPIDOMWindow *GetWindow() const
41409:   {
41409:     return mWindow ? mWindow->GetOuterWindow() : GetWindowInternal();
41409:   }
    1: 
    1:   /**
    1:    * Return the inner window used as the script compilation scope for
    1:    * this document. If you're not absolutely sure you need this, use
    1:    * GetWindow().
    1:    */
40925:   nsPIDOMWindow* GetInnerWindow()
40925:   {
40925:     return mRemovedFromDocShell ? GetInnerWindowInternal() : mWindow;
40925:   }
    1: 
    1:   /**
59512:    * Return the outer window ID.
59512:    */
63954:   PRUint64 OuterWindowID() const
59512:   {
59512:     nsPIDOMWindow *window = GetWindow();
59512:     return window ? window->WindowID() : 0;
59512:   }
59512: 
59512:   /**
77330:    * Return the inner window ID.
77330:    */
77330:   PRUint64 InnerWindowID()
77330:   {
77330:     nsPIDOMWindow *window = GetInnerWindow();
77330:     return window ? window->WindowID() : 0;
77330:   }
77330: 
77330:   /**
    1:    * Get the script loader for this document
    1:    */ 
 2007:   virtual nsScriptLoader* ScriptLoader() = 0;
    1: 
43079:   /**
43079:    * Add/Remove an element to the document's id and name hashes
43079:    */
50428:   virtual void AddToIdTable(Element* aElement, nsIAtom* aId) = 0;
50428:   virtual void RemoveFromIdTable(Element* aElement, nsIAtom* aId) = 0;
50428:   virtual void AddToNameTable(Element* aElement, nsIAtom* aName) = 0;
50428:   virtual void RemoveFromNameTable(Element* aElement, nsIAtom* aName) = 0;
43079: 
77843:   /**
77843:    * Resets the current full-screen element to nsnull.
77843:    */
77843:   virtual void ResetFullScreenElement() = 0;
77843: 
77843:   /**
77843:    * Returns the element which either is the full-screen element, or
77843:    * contains the full-screen element if a child of this document contains
77843:    * the fullscreen element.
77843:    */
77843:   virtual Element* GetFullScreenElement() = 0;
77843: 
77843:   /**
77843:    * Requests that the document make aElement the full-screen element,
77843:    * and move into full-screen mode.
77843:    */
77843:   virtual void RequestFullScreen(Element* aElement) = 0;
77843: 
77843:   /**
77849:    * Requests that the document, and all documents in its hierarchy exit
77849:    * from DOM full-screen mode.
77849:    */
77849:   virtual void CancelFullScreen() = 0;
77849: 
77849:   /**
77843:    * Updates the full-screen status on this document, setting the full-screen
77843:    * mode to aIsFullScreen. This doesn't affect the window's full-screen mode,
77843:    * this updates the document's internal state which determines whether the
77843:    * document reports as being in full-screen mode.
77843:    */
79445:   virtual void UpdateFullScreenStatus(bool aIsFullScreen) = 0;
77843: 
77843:   /**
77843:    * Returns PR_TRUE if this document is in full-screen mode.
77843:    */
79445:   virtual bool IsFullScreenDoc() = 0;
77843: 
    1:   //----------------------------------------------------------------------
    1: 
    1:   // Document notification API's
    1: 
    1:   /**
    1:    * Add a new observer of document change notifications. Whenever
    1:    * content is changed, appended, inserted or removed the observers are
41925:    * informed.  An observer that is already observing the document must
41925:    * not be added without being removed first.
    1:    */
    1:   virtual void AddObserver(nsIDocumentObserver* aObserver) = 0;
    1: 
    1:   /**
    1:    * Remove an observer of document change notifications. This will
    1:    * return false if the observer cannot be found.
    1:    */
79445:   virtual bool RemoveObserver(nsIDocumentObserver* aObserver) = 0;
    1: 
    1:   // Observation hooks used to propagate notifications to document observers.
    1:   // BeginUpdate must be called before any batch of modifications of the
    1:   // content model or of style data, EndUpdate must be called afterward.
    1:   // To make this easy and painless, use the mozAutoDocUpdate helper class.
    1:   virtual void BeginUpdate(nsUpdateType aUpdateType) = 0;
    1:   virtual void EndUpdate(nsUpdateType aUpdateType) = 0;
    1:   virtual void BeginLoad() = 0;
    1:   virtual void EndLoad() = 0;
23639: 
23639:   enum ReadyState { READYSTATE_UNINITIALIZED = 0, READYSTATE_LOADING = 1, READYSTATE_INTERACTIVE = 3, READYSTATE_COMPLETE = 4};
23639:   virtual void SetReadyStateInternal(ReadyState rs) = 0;
29975:   virtual ReadyState GetReadyStateEnum() = 0;
23639: 
71103:   // notify that a content node changed state.  This must happen under
71103:   // a scriptblocker but NOT within a begin/end update.
64120:   virtual void ContentStateChanged(nsIContent* aContent,
56168:                                    nsEventStates aStateMask) = 0;
    1: 
39698:   // Notify that a document state has changed.
39698:   // This should only be called by callers whose state is also reflected in the
39698:   // implementation of nsDocument::GetDocumentState.
56168:   virtual void DocumentStatesChanged(nsEventStates aStateMask) = 0;
39698: 
    1:   // Observation hooks for style data to propagate notifications
    1:   // to document observers
    1:   virtual void StyleRuleChanged(nsIStyleSheet* aStyleSheet,
    1:                                 nsIStyleRule* aOldStyleRule,
    1:                                 nsIStyleRule* aNewStyleRule) = 0;
    1:   virtual void StyleRuleAdded(nsIStyleSheet* aStyleSheet,
    1:                               nsIStyleRule* aStyleRule) = 0;
    1:   virtual void StyleRuleRemoved(nsIStyleSheet* aStyleSheet,
    1:                                 nsIStyleRule* aStyleRule) = 0;
    1: 
    1:   /**
    1:    * Flush notifications for this document and its parent documents
    1:    * (since those may affect the layout of this one).
    1:    */
    1:   virtual void FlushPendingNotifications(mozFlushType aType) = 0;
    1: 
40701:   /**
40701:    * Calls FlushPendingNotifications on any external resources this document
40701:    * has. If this document has no external resources or is an external resource
40701:    * itself this does nothing. This should only be called with
40701:    * aType >= Flush_Style.
40701:    */
40701:   virtual void FlushExternalResources(mozFlushType aType) = 0;
40701: 
    1:   nsBindingManager* BindingManager() const
    1:   {
13669:     return mNodeInfoManager->GetBindingManager();
    1:   }
    1: 
    1:   /**
    1:    * Only to be used inside Gecko, you can't really do anything with the
    1:    * pointer outside Gecko anyway.
    1:    */
    1:   nsNodeInfoManager* NodeInfoManager() const
    1:   {
    1:     return mNodeInfoManager;
    1:   }
    1: 
    1:   /**
    1:    * Reset the document using the given channel and loadgroup.  This works
    1:    * like ResetToURI, but also sets the document's channel to aChannel.
    1:    * The principal of the document will be set from the channel.
    1:    */
    1:   virtual void Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup) = 0;
    1: 
    1:   /**
    1:    * Reset this document to aURI, aLoadGroup, and aPrincipal.  aURI must not be
    1:    * null.  If aPrincipal is null, a codebase principal based on aURI will be
    1:    * used.
    1:    */
    1:   virtual void ResetToURI(nsIURI *aURI, nsILoadGroup* aLoadGroup,
    1:                           nsIPrincipal* aPrincipal) = 0;
    1: 
    1:   /**
34207:    * Set the container (docshell) for this document. Virtual so that
34207:    * docshell can call it.
    1:    */
34207:   virtual void SetContainer(nsISupports *aContainer);
    1: 
    1:   /**
    1:    * Get the container (docshell) for this document.
    1:    */
    1:   already_AddRefed<nsISupports> GetContainer() const
    1:   {
    1:     nsISupports* container = nsnull;
    1:     if (mDocumentContainer)
    1:       CallQueryReferent(mDocumentContainer.get(), &container);
    1: 
    1:     return container;
    1:   }
    1: 
    1:   /**
    1:    * Set and get XML declaration. If aVersion is null there is no declaration.
    1:    * aStandalone takes values -1, 0 and 1 indicating respectively that there
    1:    * was no standalone parameter in the declaration, that it was given as no,
    1:    * or that it was given as yes.
    1:    */
    1:   virtual void SetXMLDeclaration(const PRUnichar *aVersion,
    1:                                  const PRUnichar *aEncoding,
    1:                                  const PRInt32 aStandalone) = 0;
    1:   virtual void GetXMLDeclaration(nsAString& aVersion,
    1:                                  nsAString& aEncoding,
    1:                                  nsAString& Standalone) = 0;
    1: 
79445:   bool IsHTML() const
    1:   {
31946:     return mIsRegularHTML;
    1:   }
79445:   bool IsXUL() const
43079:   {
43079:     return mIsXUL;
43079:   }
    1: 
79445:   virtual bool IsScriptEnabled() = 0;
    1: 
72956:   virtual void AddXMLEventsContent(nsIContent * aXMLEventsElement) = 0;
    1: 
    1:   /**
    1:    * Create an element with the specified name, prefix and namespace ID.
    1:    * If aDocumentDefaultType is true we create an element of the default type
    1:    * for that document (currently XHTML in HTML documents and XUL in XUL
    1:    * documents), otherwise we use the type specified by the namespace ID.
    1:    */
48124:   virtual nsresult CreateElem(const nsAString& aName, nsIAtom *aPrefix,
    1:                               PRInt32 aNamespaceID,
79445:                               bool aDocumentDefaultType,
    1:                               nsIContent** aResult) = 0;
    1: 
    1:   /**
    1:    * Get the security info (i.e. SSL state etc) that the document got
    1:    * from the channel/document that created the content of the
    1:    * document.
    1:    *
    1:    * @see nsIChannel
    1:    */
    1:   nsISupports *GetSecurityInfo()
    1:   {
    1:     return mSecurityInfo;
    1:   }
    1: 
    1:   /**
    1:    * Returns the default namespace ID used for elements created in this
    1:    * document.
    1:    */
    1:   virtual PRInt32 GetDefaultNamespaceID() const = 0;
    1: 
41182:   void DeleteAllProperties();
41182:   void DeleteAllPropertiesFor(nsINode* aNode);
41182: 
41182:   nsPropertyTable* PropertyTable(PRUint16 aCategory) {
41182:     if (aCategory == 0)
41182:       return &mPropertyTable;
41182:     return GetExtraPropertyTable(aCategory);
41182:   }
41182:   PRUint32 GetPropertyTableCount()
41182:   { return mExtraPropertyTables.Length() + 1; }
    1: 
    1:   /**
    1:    * Sets the ID used to identify this part of the multipart document
    1:    */
    1:   void SetPartID(PRUint32 aID) {
    1:     mPartID = aID;
    1:   }
    1: 
    1:   /**
    1:    * Return the ID used to identify this part of the multipart document
    1:    */
    1:   PRUint32 GetPartID() const {
    1:     return mPartID;
    1:   }
    1: 
    1:   /**
    1:    * Sanitize the document by resetting all input elements and forms that have
    1:    * autocomplete=off to their default values.
    1:    */
    1:   virtual nsresult Sanitize() = 0;
    1: 
    1:   /**
    1:    * Enumerate all subdocuments.
    1:    * The enumerator callback should return PR_TRUE to continue enumerating, or
20463:    * PR_FALSE to stop.  This will never get passed a null aDocument.
    1:    */
79445:   typedef bool (*nsSubDocEnumFunc)(nsIDocument *aDocument, void *aData);
    1:   virtual void EnumerateSubDocuments(nsSubDocEnumFunc aCallback,
    1:                                      void *aData) = 0;
    1: 
    1:   /**
    1:    * Check whether it is safe to cache the presentation of this document
    1:    * and all of its subdocuments. This method checks the following conditions
    1:    * recursively:
    1:    *  - Some document types, such as plugin documents, cannot be safely cached.
    1:    *  - If there are any pending requests, we don't allow the presentation
    1:    *    to be cached.  Ideally these requests would be suspended and resumed,
    1:    *    but that is difficult in some cases, such as XMLHttpRequest.
    1:    *  - If there are any beforeunload or unload listeners, we must fire them
    1:    *    for correctness, but this likely puts the document into a state where
    1:    *    it would not function correctly if restored.
    1:    *
    1:    * |aNewRequest| should be the request for a new document which will
    1:    * replace this document in the docshell.  The new document's request
    1:    * will be ignored when checking for active requests.  If there is no
    1:    * request associated with the new document, this parameter may be null.
    1:    */
79445:   virtual bool CanSavePresentation(nsIRequest *aNewRequest) = 0;
    1: 
    1:   /**
    1:    * Notify the document that its associated ContentViewer is being destroyed.
    1:    * This releases circular references so that the document can go away.
    1:    * Destroy() is only called on documents that have a content viewer.
    1:    */
    1:   virtual void Destroy() = 0;
    1: 
14469:   /**
14469:    * Notify the document that its associated ContentViewer is no longer
14469:    * the current viewer for the docshell. The document might still
14469:    * be rendered in "zombie state" until the next document is ready.
14469:    * The document should save form control state.
14469:    */
14469:   virtual void RemovedFromDocShell() = 0;
14188:   
    1:   /**
    1:    * Get the layout history state that should be used to save and restore state
    1:    * for nodes in this document.  This may return null; if that happens state
    1:    * saving and restoration is not possible.
    1:    */
    1:   virtual already_AddRefed<nsILayoutHistoryState> GetLayoutHistoryState() const = 0;
    1: 
    1:   /**
    1:    * Methods that can be used to prevent onload firing while an event that
    1:    * should block onload is posted.  onload is guaranteed to not fire until
    1:    * either all calls to BlockOnload() have been matched by calls to
    1:    * UnblockOnload() or the load has been stopped altogether (by the user
    1:    * pressing the Stop button, say).
    1:    */
    1:   virtual void BlockOnload() = 0;
    1:   /**
    1:    * @param aFireSync whether to fire onload synchronously.  If false,
    1:    * onload will fire asynchronously after all onload blocks have been
    1:    * removed.  It will NOT fire from inside UnblockOnload.  If true,
    1:    * onload may fire from inside UnblockOnload.
    1:    */
79445:   virtual void UnblockOnload(bool aFireSync) = 0;
    1: 
    1:   /**
    1:    * Notification that the page has been shown, for documents which are loaded
    1:    * into a DOM window.  This corresponds to the completion of document load,
    1:    * or to the page's presentation being restored into an existing DOM window.
    1:    * This notification fires applicable DOM events to the content window.  See
    1:    * nsIDOMPageTransitionEvent.idl for a description of the |aPersisted|
25572:    * parameter. If aDispatchStartTarget is null, the pageshow event is
25572:    * dispatched on the ScriptGlobalObject for this document, otherwise it's
25572:    * dispatched on aDispatchStartTarget.
25572:    * Note: if aDispatchStartTarget isn't null, the showing state of the
25572:    * document won't be altered.
    1:    */
79445:   virtual void OnPageShow(bool aPersisted,
25572:                           nsIDOMEventTarget* aDispatchStartTarget) = 0;
    1: 
    1:   /**
    1:    * Notification that the page has been hidden, for documents which are loaded
    1:    * into a DOM window.  This corresponds to the unloading of the document, or
    1:    * to the document's presentation being saved but removed from an existing
    1:    * DOM window.  This notification fires applicable DOM events to the content
    1:    * window.  See nsIDOMPageTransitionEvent.idl for a description of the
25572:    * |aPersisted| parameter. If aDispatchStartTarget is null, the pagehide
25572:    * event is dispatched on the ScriptGlobalObject for this document,
25572:    * otherwise it's dispatched on aDispatchStartTarget.
25572:    * Note: if aDispatchStartTarget isn't null, the showing state of the
25572:    * document won't be altered.
    1:    */
79445:   virtual void OnPageHide(bool aPersisted,
25572:                           nsIDOMEventTarget* aDispatchStartTarget) = 0;
    1:   
    1:   /*
    1:    * We record the set of links in the document that are relevant to
    1:    * style.
    1:    */
    1:   /**
38488:    * Notification that an element is a link that is relevant to style.
    1:    */
38488:   virtual void AddStyleRelevantLink(mozilla::dom::Link* aLink) = 0;
    1:   /**
    1:    * Notification that an element is a link and its URI might have been
    1:    * changed or the element removed. If the element is still a link relevant
    1:    * to style, then someone must ensure that AddStyleRelevantLink is
    1:    * (eventually) called on it again.
    1:    */
38488:   virtual void ForgetLink(mozilla::dom::Link* aLink) = 0;
    1: 
    1:   /**
    1:    * Resets and removes a box object from the document's box object cache
    1:    *
    1:    * @param aElement canonical nsIContent pointer of the box object's element
    1:    */
    1:   virtual void ClearBoxObjectFor(nsIContent *aContent) = 0;
    1: 
    1:   /**
26701:    * Get the box object for an element. This is not exposed through a
26701:    * scriptable interface except for XUL documents.
26701:    */
26701:   NS_IMETHOD GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult) = 0;
26701: 
26701:   /**
    1:    * Get the compatibility mode for this document
    1:    */
    1:   nsCompatibility GetCompatibilityMode() const {
    1:     return mCompatMode;
    1:   }
    1:   
    1:   /**
18363:    * Check whether we've ever fired a DOMTitleChanged event for this
18363:    * document.
18363:    */
79445:   bool HaveFiredDOMTitleChange() const {
18363:     return mHaveFiredTitleChange;
18363:   }
18363: 
18363:   /**
    1:    * See GetXBLChildNodesFor on nsBindingManager
    1:    */
    1:   virtual nsresult GetXBLChildNodesFor(nsIContent* aContent,
    1:                                        nsIDOMNodeList** aResult) = 0;
    1: 
    1:   /**
    1:    * See GetContentListFor on nsBindingManager
    1:    */
    1:   virtual nsresult GetContentListFor(nsIContent* aContent,
    1:                                      nsIDOMNodeList** aResult) = 0;
    1: 
    1:   /**
70983:    * Helper for nsIDOMDocument::elementFromPoint implementation that allows
21333:    * ignoring the scroll frame and/or avoiding layout flushes.
21333:    *
21333:    * @see nsIDOMWindowUtils::elementFromPoint
21333:    */
40200:   virtual nsresult ElementFromPointHelper(float aX, float aY,
79445:                                           bool aIgnoreRootScrollFrame,
79445:                                           bool aFlushLayout,
21333:                                           nsIDOMElement** aReturn) = 0;
21333: 
40568:   virtual nsresult NodesFromRectHelper(float aX, float aY,
40568:                                        float aTopSize, float aRightSize,
40568:                                        float aBottomSize, float aLeftSize,
79445:                                        bool aIgnoreRootScrollFrame,
79445:                                        bool aFlushLayout,
40568:                                        nsIDOMNodeList** aReturn) = 0;
40568: 
21333:   /**
    1:    * See FlushSkinBindings on nsBindingManager
    1:    */
    1:   virtual void FlushSkinBindings() = 0;
    1: 
   62:   /**
 3137:    * To batch DOMSubtreeModified, document needs to be informed when
 3137:    * a mutation event might be dispatched, even if the event isn't actually
 3137:    * created because there are no listeners for it.
 3137:    *
 3137:    * @param aTarget is the target for the mutation event.
   62:    */
 5684:   void MayDispatchMutationEvent(nsINode* aTarget)
 5684:   {
 5684:     if (mSubtreeModifiedDepth > 0) {
 5684:       mSubtreeModifiedTargets.AppendObject(aTarget);
 5684:     }
 5684:   }
   62: 
 1353:   /**
 1353:    * Marks as not-going-to-be-collected for the given generation of
 1353:    * cycle collection.
 1353:    */
 1353:   void MarkUncollectableForCCGeneration(PRUint32 aGeneration)
 1353:   {
 1353:     mMarkedCCGeneration = aGeneration;
 1353:   }
 1353: 
 1353:   /**
 1353:    * Gets the cycle collector generation this document is marked for.
 1353:    */
 1353:   PRUint32 GetMarkedCCGeneration()
 1353:   {
 1353:     return mMarkedCCGeneration;
 1353:   }
 1353: 
79445:   bool IsLoadedAsData()
 4064:   {
 4064:     return mLoadedAsData;
 4064:   }
 1353: 
79445:   bool MayStartLayout()
10474:   {
10474:     return mMayStartLayout;
10474:   }
10474: 
79445:   void SetMayStartLayout(bool aMayStartLayout)
10474:   {
10474:     mMayStartLayout = aMayStartLayout;
10474:   }
10474: 
46309:   already_AddRefed<nsIDocumentEncoder> GetCachedEncoder()
46309:   {
46309:     return mCachedEncoder.forget();
46309:   }
46309: 
47922:   void SetCachedEncoder(already_AddRefed<nsIDocumentEncoder> aEncoder)
46309:   {
46309:     mCachedEncoder = aEncoder;
46309:   }
46309: 
13433:   // In case of failure, the document really can't initialize the frame loader.
13433:   virtual nsresult InitializeFrameLoader(nsFrameLoader* aLoader) = 0;
13433:   // In case of failure, the caller must handle the error, for example by
13433:   // finalizing frame loader asynchronously.
12256:   virtual nsresult FinalizeFrameLoader(nsFrameLoader* aLoader) = 0;
14757:   // Removes the frame loader of aShell from the initialization list.
14660:   virtual void TryCancelFrameLoaderInitialization(nsIDocShell* aShell) = 0;
14757:   //  Returns true if the frame loader of aShell is in the finalization list.
79445:   virtual bool FrameLoaderScheduledToBeFinalized(nsIDocShell* aShell) = 0;
20078: 
20078:   /**
20078:    * Check whether this document is a root document that is not an
20078:    * external resource.
20078:    */
79445:   bool IsRootDisplayDocument() const
20078:   {
20078:     return !mParentDocument && !mDisplayDocument;
20078:   }
20078: 
79445:   bool IsBeingUsedAsImage() const {
52207:     return mIsBeingUsedAsImage;
52207:   }
52207: 
52207:   void SetIsBeingUsedAsImage() {
52207:     mIsBeingUsedAsImage = PR_TRUE;
52207:   }
52207: 
79445:   bool IsResourceDoc() const {
52209:     return IsBeingUsedAsImage() || // Are we a helper-doc for an SVG image?
52209:       !!mDisplayDocument;          // Are we an external resource doc?
52209:   }
52209: 
20078:   /**
20078:    * Get the document for which this document is an external resource.  This
20078:    * will be null if this document is not an external resource.  Otherwise,
20078:    * GetDisplayDocument() will return a non-null document, and
20078:    * GetDisplayDocument()->GetDisplayDocument() is guaranteed to be null.
20078:    */
20078:   nsIDocument* GetDisplayDocument() const
20078:   {
20078:     return mDisplayDocument;
20078:   }
20078:   
20078:   /**
20078:    * Set the display document for this document.  aDisplayDocument must not be
20078:    * null.
20078:    */
20078:   void SetDisplayDocument(nsIDocument* aDisplayDocument)
20078:   {
46225:     NS_PRECONDITION(!GetShell() &&
20078:                     !nsCOMPtr<nsISupports>(GetContainer()) &&
20078:                     !GetWindow() &&
20078:                     !GetScriptGlobalObject(),
20078:                     "Shouldn't set mDisplayDocument on documents that already "
20078:                     "have a presentation or a docshell or a window");
20078:     NS_PRECONDITION(aDisplayDocument != this, "Should be different document");
20078:     NS_PRECONDITION(!aDisplayDocument->GetDisplayDocument(),
20078:                     "Display documents should not nest");
20078:     mDisplayDocument = aDisplayDocument;
20078:   }
20078: 
20078:   /**
20078:    * A class that represents an external resource load that has begun but
20078:    * doesn't have a document yet.  Observers can be registered on this object,
20078:    * and will be notified after the document is created.  Observers registered
20078:    * after the document has been created will NOT be notified.  When observers
20078:    * are notified, the subject will be the newly-created document, the topic
20078:    * will be "external-resource-document-created", and the data will be null.
20078:    * If document creation fails for some reason, observers will still be
20078:    * notified, with a null document pointer.
20078:    */
20078:   class ExternalResourceLoad : public nsISupports
20078:   {
20078:   public:
20078:     virtual ~ExternalResourceLoad() {}
20078: 
20078:     void AddObserver(nsIObserver* aObserver) {
20078:       NS_PRECONDITION(aObserver, "Must have observer");
20078:       mObservers.AppendElement(aObserver);
20078:     }
20078: 
20078:     const nsTArray< nsCOMPtr<nsIObserver> > & Observers() {
20078:       return mObservers;
20078:     }
20078:   protected:
20078:     nsAutoTArray< nsCOMPtr<nsIObserver>, 8 > mObservers;    
20078:   };
20078: 
20078:   /**
20078:    * Request an external resource document for aURI.  This will return the
20078:    * resource document if available.  If one is not available yet, it will
20078:    * start loading as needed, and the pending load object will be returned in
20078:    * aPendingLoad so that the caller can register an observer to wait for the
20078:    * load.  If this function returns null and doesn't return a pending load,
20078:    * that means that there is no resource document for this URI and won't be
20078:    * one in the future.
20078:    *
20078:    * @param aURI the URI to get
20078:    * @param aRequestingNode the node making the request
20078:    * @param aPendingLoad the pending load for this request, if any
20078:    */
20078:   virtual nsIDocument*
20078:     RequestExternalResource(nsIURI* aURI,
20078:                             nsINode* aRequestingNode,
20078:                             ExternalResourceLoad** aPendingLoad) = 0;
20078: 
20078:   /**
20078:    * Enumerate the external resource documents associated with this document.
20078:    * The enumerator callback should return PR_TRUE to continue enumerating, or
20463:    * PR_FALSE to stop.  This callback will never get passed a null aDocument.
20078:    */
20078:   virtual void EnumerateExternalResources(nsSubDocEnumFunc aCallback,
20078:                                           void* aData) = 0;
20078: 
23147:   /**
23147:    * Return whether the document is currently showing (in the sense of
23147:    * OnPageShow() having been called already and OnPageHide() not having been
23147:    * called yet.
23147:    */
80229:   bool IsShowing() const { return mIsShowing; }
34205:   /**
34205:    * Return whether the document is currently visible (in the sense of
34205:    * OnPageHide having been called and OnPageShow not yet having been called)
34205:    */
80229:   bool IsVisible() const { return mVisible; }
34205:   /**
34205:    * Return true when this document is active, i.e., the active document
34205:    * in a content viewer.
34205:    */
80229:   bool IsActive() const { return mDocumentContainer && !mRemovedFromDocShell; }
23147: 
28108:   void RegisterFreezableElement(nsIContent* aContent);
79445:   bool UnregisterFreezableElement(nsIContent* aContent);
28108:   typedef void (* FreezableElementEnumerator)(nsIContent*, void*);
28108:   void EnumerateFreezableElements(FreezableElementEnumerator aEnumerator,
28108:                                   void* aData);
28108: 
23697: #ifdef MOZ_SMIL
38869:   // Indicates whether mAnimationController has been (lazily) initialized.
38869:   // If this returns PR_TRUE, we're promising that GetAnimationController()
38869:   // will have a non-null return value.
79445:   bool HasAnimationController()  { return !!mAnimationController; }
38869: 
38869:   // Getter for this document's SMIL Animation Controller. Performs lazy
38869:   // initialization, if this document supports animation and if
38869:   // mAnimationController isn't yet initialized.
23697:   virtual nsSMILAnimationController* GetAnimationController() = 0;
23697: #endif // MOZ_SMIL
23697: 
57023:   // Makes the images on this document capable of having their animation
57023:   // active or suspended. An Image will animate as long as at least one of its
57023:   // owning Documents needs it to animate; otherwise it can suspend.
79445:   virtual void SetImagesNeedAnimating(bool aAnimating) = 0;
57023: 
25722:   /**
25722:    * Prevents user initiated events from being dispatched to the document and
25722:    * subdocuments.
25722:    */
25722:   virtual void SuppressEventHandling(PRUint32 aIncrease = 1) = 0;
25722: 
26591:   /**
26591:    * Unsuppress event handling.
26591:    * @param aFireEvents If PR_TRUE, delayed events (focus/blur) will be fired
26591:    *                    asynchronously.
26591:    */
79445:   virtual void UnsuppressEventHandlingAndFireEvents(bool aFireEvents) = 0;
25722: 
28460:   PRUint32 EventHandlingSuppressed() const { return mEventsSuppressed; }
28460: 
75000:   bool IsEventHandlingEnabled() {
75000:     return !EventHandlingSuppressed() && mScriptGlobalObject;
75000:   }
75000: 
47680:   /**
47680:    * Increment the number of external scripts being evaluated.
47680:    */
47680:   void BeginEvaluatingExternalScript() { ++mExternalScriptsBeingEvaluated; }
47680: 
47680:   /**
47680:    * Decrement the number of external scripts being evaluated.
47680:    */
47680:   void EndEvaluatingExternalScript() { --mExternalScriptsBeingEvaluated; }
47680: 
79445:   bool IsDNSPrefetchAllowed() const { return mAllowDNSPrefetch; }
30065: 
30065:   /**
51393:    * Returns PR_TRUE if this document is allowed to contain XUL element and
51393:    * use non-builtin XBL bindings.
51393:    */
79445:   bool AllowXULXBL() {
51393:     return mAllowXULXBL == eTriTrue ? PR_TRUE :
51393:            mAllowXULXBL == eTriFalse ? PR_FALSE :
51393:            InternalAllowXULXBL();
51393:   }
51393: 
51393:   void ForceEnableXULXBL() {
51393:     mAllowXULXBL = eTriTrue;
51393:   }
51393: 
51393:   /**
35581:    * PR_TRUE when this document is a static clone of a normal document.
35581:    * For example print preview and printing use static documents.
35581:    */
79445:   bool IsStaticDocument() { return mIsStaticDocument; }
35581: 
35581:   /**
35581:    * Clones the document and subdocuments and stylesheet etc.
35581:    * @param aCloneContainer The container for the clone document.
35581:    */
35581:   virtual already_AddRefed<nsIDocument>
35581:   CreateStaticClone(nsISupports* aCloneContainer);
35581: 
35581:   /**
35581:    * If this document is a static clone, this returns the original
35581:    * document.
35581:    */
35581:   nsIDocument* GetOriginalDocument() { return mOriginalDocument; }
35581: 
35581:   /**
30065:    * Called by nsParser to preload images. Can be removed and code moved
30065:    * to nsPreloadURIs::PreloadURIs() in file nsParser.cpp whenever the
30065:    * parser-module is linked with gklayout-module.
30065:    */
74594:   virtual void MaybePreLoadImage(nsIURI* uri,
74594:                                  const nsAString& aCrossOriginAttr) = 0;
30065: 
30836:   /**
38850:    * Called by nsParser to preload style sheets.  Can also be merged into
38850:    * the parser if and when the parser is merged with libgklayout.
38850:    */
38850:   virtual void PreloadStyle(nsIURI* aURI, const nsAString& aCharset) = 0;
38850: 
38850:   /**
38850:    * Called by the chrome registry to load style sheets.  Can be put
38850:    * back there if and when when that module is merged with libgklayout.
38850:    *
38850:    * This always does a synchronous load.  If aIsAgentSheet is true,
38850:    * it also uses the system principal and enables unsafe rules.
38850:    * DO NOT USE FOR UNTRUSTED CONTENT.
38850:    */
79445:   virtual nsresult LoadChromeSheetSync(nsIURI* aURI, bool aIsAgentSheet,
42163:                                        nsCSSStyleSheet** aSheet) = 0;
38850: 
38850:   /**
30836:    * Returns true if the locale used for the document specifies a direction of
30836:    * right to left. For chrome documents, this comes from the chrome registry.
30836:    * This is used to determine the current state for the :-moz-locale-dir pseudoclass
30836:    * so once can know whether a document is expected to be rendered left-to-right
30836:    * or right-to-left.
30836:    */
79445:   virtual bool IsDocumentRightToLeft() { return false; }
30836: 
33380:   enum DocumentTheme {
33380:     Doc_Theme_Uninitialized, // not determined yet
33380:     Doc_Theme_None,
34899:     Doc_Theme_Neutral,
33380:     Doc_Theme_Dark,
33380:     Doc_Theme_Bright
33380:   };
33380: 
33380:   /**
69563:    * Set the document's pending state object (as serialized using structured
69563:    * clone).
37802:    */
69563:   void SetStateObject(nsIStructuredCloneContainer *scContainer)
37802:   {
69563:     mStateObjectContainer = scContainer;
69563:     mStateObjectCached = nsnull;
37802:   }
37802: 
37802:   /**
34899:    * Returns Doc_Theme_None if there is no lightweight theme specified,
34899:    * Doc_Theme_Dark for a dark theme, Doc_Theme_Bright for a light theme, and
34899:    * Doc_Theme_Neutral for any other theme. This is used to determine the state
34899:    * of the pseudoclasses :-moz-lwtheme and :-moz-lwtheme-text.
33380:    */
33380:   virtual int GetDocumentLWTheme() { return Doc_Theme_None; }
33380: 
33055:   /**
39698:    * Returns the document state.
39698:    * Document state bits have the form NS_DOCUMENT_STATE_* and are declared in
39698:    * nsIDocument.h.
39698:    */
56168:   virtual nsEventStates GetDocumentState() = 0;
39698: 
34394:   virtual nsISupports* GetCurrentContentSink() = 0;
34394: 
38871:   /**
53994:    * Register/Unregister a filedata uri as being "owned" by this document. 
53994:    * I.e. that its lifetime is connected with this document. When the document
53994:    * goes away it should "kill" the uri by calling
38871:    * nsFileDataProtocolHandler::RemoveFileDataEntry
38871:    */
53994:   virtual void RegisterFileDataUri(const nsACString& aUri) = 0;
53994:   virtual void UnregisterFileDataUri(const nsACString& aUri) = 0;
38871: 
69754:   virtual void SetScrollToRef(nsIURI *aDocumentURI) = 0;
42357:   virtual void ScrollToRef() = 0;
69754:   virtual void ResetScrolledToRefAlready() = 0;
79445:   virtual void SetChangeScrollPosWhenScrollingToRef(bool aValue) = 0;
42357: 
42487:   /**
42487:    * This method is similar to GetElementById() from nsIDOMDocument but it
42487:    * returns a mozilla::dom::Element instead of a nsIDOMElement.
42487:    * It prevents converting nsIDOMElement to mozill:dom::Element which is
42487:    * already converted from mozilla::dom::Element.
42487:    */
50428:   virtual Element* GetElementById(const nsAString& aElementId) = 0;
50428: 
50428:   /**
50428:    * Lookup an image element using its associated ID, which is usually provided
50428:    * by |-moz-element()|. Similar to GetElementById, with the difference that
50428:    * elements set using mozSetImageElement have higher priority.
50428:    * @param aId the ID associated the element we want to lookup
50428:    * @return the element associated with |aId|
50428:    */
50428:   virtual Element* LookupImageElement(const nsAString& aElementId) = 0;
42487: 
52255:   void ScheduleBeforePaintEvent(nsIAnimationFrameListener* aListener);
50368:   void BeforePaintEventFiring()
50368:   {
50368:     mHavePendingPaint = PR_FALSE;
50368:   }
50368: 
52255:   typedef nsTArray< nsCOMPtr<nsIAnimationFrameListener> > AnimationListenerList;
52255:   /**
52255:    * Put this documents animation frame listeners into the provided
52255:    * list, and forget about them.
52255:    */
52255:   void TakeAnimationFrameListeners(AnimationListenerList& aListeners);
52255: 
50721:   // This returns true when the document tree is being teared down.
79445:   bool InUnlinkOrDeletion() { return mInUnlinkOrDeletion; }
50815: 
50815:   /*
50815:    * Image Tracking
50815:    *
50815:    * Style and content images register their imgIRequests with their document
50815:    * so that the document can efficiently tell all descendant images when they
50815:    * are and are not visible. When an image is on-screen, we want to call
50815:    * LockImage() on it so that it doesn't do things like discarding frame data
50815:    * to save memory. The PresShell informs the document whether its images
50815:    * should be locked or not via SetImageLockingState().
50815:    *
50815:    * See bug 512260.
50815:    */
50815: 
50815:   // Add/Remove images from the document image tracker
50815:   virtual nsresult AddImage(imgIRequest* aImage) = 0;
50815:   virtual nsresult RemoveImage(imgIRequest* aImage) = 0;
50815: 
50815:   // Makes the images on this document locked/unlocked. By default, the locking
50815:   // state is unlocked/false.
79445:   virtual nsresult SetImageLockingState(bool aLocked) = 0;
50815: 
69563:   virtual nsresult GetStateObject(nsIVariant** aResult) = 0;
63882: 
72298:   virtual nsDOMNavigationTiming* GetNavigationTiming() const = 0;
72298: 
72298:   virtual nsresult SetNavigationTiming(nsDOMNavigationTiming* aTiming) = 0;
72298: 
71030:   virtual Element* FindImageMap(const nsAString& aNormalizedMapName) = 0;
71030: 
72662: #define DEPRECATED_OPERATION(_op) e##_op,
72272:   enum DeprecatedOperations {
72662: #include "nsDeprecatedOperationList.h"
72664:     eDeprecatedOperationCount
72272:   };
72662: #undef DEPRECATED_OPERATION
72272:   void WarnOnceAbout(DeprecatedOperations aOperation);
72272: 
80229:   virtual void PostVisibilityUpdateEvent() = 0;
80229: 
72272: private:
79005:   PRUint64 mWarnedAbout;
72272: 
    1: protected:
    1:   ~nsIDocument()
    1:   {
    1:     // XXX The cleanup of mNodeInfoManager (calling DropDocumentReference and
    1:     //     releasing it) happens in the nsDocument destructor. We'd prefer to
    1:     //     do it here but nsNodeInfoManager is a concrete class that we don't
    1:     //     want to expose to users of the nsIDocument API outside of Gecko.
    1:   }
    1: 
41182:   nsPropertyTable* GetExtraPropertyTable(PRUint16 aCategory);
41182: 
41409:   // Never ever call this. Only call GetWindow!
63954:   virtual nsPIDOMWindow *GetWindowInternal() const = 0;
41409: 
40925:   // Never ever call this. Only call GetInnerWindow!
40925:   virtual nsPIDOMWindow *GetInnerWindowInternal() = 0;
40925: 
42823:   // Never ever call this. Only call GetScriptHandlingObject!
42823:   virtual nsIScriptGlobalObject* GetScriptHandlingObjectInternal() const = 0;
42823: 
51393:   // Never ever call this. Only call AllowXULXBL!
79445:   virtual bool InternalAllowXULXBL() = 0;
51393: 
   62:   /**
   62:    * These methods should be called before and after dispatching
   62:    * a mutation event.
   62:    * To make this easy and painless, use the mozAutoSubtreeModified helper class.
   62:    */
   62:   virtual void WillDispatchMutationEvent(nsINode* aTarget) = 0;
   62:   virtual void MutationEventDispatched(nsINode* aTarget) = 0;
   62:   friend class mozAutoSubtreeModified;
   62: 
42325:   virtual Element* GetNameSpaceElement()
41904:   {
41904:     return GetRootElement();
41904:   }
41904: 
46309:   void SetContentTypeInternal(const nsACString& aType)
46309:   {
46309:     mCachedEncoder = nsnull;
46309:     mContentType = aType;
46309:   }
46309: 
46309:   nsCString GetContentTypeInternal() const
46309:   {
46309:     return mContentType;
46309:   }
46309: 
    1:   nsCOMPtr<nsIURI> mDocumentURI;
59194:   nsCOMPtr<nsIURI> mOriginalURI;
    1:   nsCOMPtr<nsIURI> mDocumentBaseURI;
    1: 
    1:   nsWeakPtr mDocumentLoadGroup;
    1: 
    1:   nsWeakPtr mDocumentContainer;
    1: 
    1:   nsCString mCharacterSet;
    1:   PRInt32 mCharacterSetSource;
    1: 
    1:   // This is just a weak pointer; the parent document owns its children.
    1:   nsIDocument* mParentDocument;
    1: 
41634:   // A reference to the element last returned from GetRootElement().
79452:   mozilla::dom::Element* mCachedRootElement;
    1: 
    1:   // We'd like these to be nsRefPtrs, but that'd require us to include
    1:   // additional headers that we don't want to expose.
    1:   // The cleanup is handled by the nsDocument destructor.
    1:   nsNodeInfoManager* mNodeInfoManager; // [STRONG]
38851:   mozilla::css::Loader* mCSSLoader; // [STRONG]
    1: 
28108:   // The set of all object, embed, applet, video and audio elements for
28108:   // which this is the owner document. (They might not be in the document.)
28108:   // These are non-owning pointers, the elements are responsible for removing
28108:   // themselves when they go away.
28108:   nsAutoPtr<nsTHashtable<nsPtrHashKey<nsIContent> > > mFreezableElements;
28108: 
38869: #ifdef MOZ_SMIL
38869:   // SMIL Animation Controller, lazily-initialized in GetAnimationController
39626:   nsRefPtr<nsSMILAnimationController> mAnimationController;
38869: #endif // MOZ_SMIL
38869: 
    1:   // Table of element properties for this document.
    1:   nsPropertyTable mPropertyTable;
41182:   nsTArray<nsAutoPtr<nsPropertyTable> > mExtraPropertyTables;
    1: 
    1:   // Compatibility mode
    1:   nsCompatibility mCompatMode;
    1: 
    1:   // True if BIDI is enabled.
79445:   bool mBidiEnabled;
10073:   // True if a MathML element has ever been owned by this document.
79445:   bool mMathMLEnabled;
    1: 
    1:   // True if this document is the initial document for a window.  This should
    1:   // basically be true only for documents that exist in newly-opened windows or
    1:   // documents created to satisfy a GetDocument() on a window when there's no
    1:   // document in it.
79445:   bool mIsInitialDocumentInWindow;
    1: 
79445:   bool mIsRegularHTML;
79445:   bool mIsXUL;
31946: 
51393:   enum {
51393:     eTriUnset = 0,
51393:     eTriFalse,
51393:     eTriTrue
51393:   } mAllowXULXBL;
51393: 
 4064:   // True if we're loaded as data and therefor has any dangerous stuff, such
 4064:   // as scripts and plugins, disabled.
79445:   bool mLoadedAsData;
 4064: 
10474:   // If true, whoever is creating the document has gotten it to the
10474:   // point where it's safe to start layout on it.
79445:   bool mMayStartLayout;
10474:   
18363:   // True iff we've ever fired a DOMTitleChanged event for this document
79445:   bool mHaveFiredTitleChange;
18363: 
23147:   // True iff IsShowing() should be returning true
79445:   bool mIsShowing;
23147: 
34205:   // True iff the document "page" is not hidden (i.e. currently in the
34205:   // bfcache)
79445:   bool mVisible;
34205: 
34205:   // True if our content viewer has been removed from the docshell
34205:   // (it may still be displayed, but in zombie state). Form control data
34205:   // has been saved.
79445:   bool mRemovedFromDocShell;
34205: 
28460:   // True iff DNS prefetch is allowed for this document.  Note that if the
28460:   // document has no window, DNS prefetch won't be performed no matter what.
79445:   bool mAllowDNSPrefetch;
28460:   
35581:   // True when this document is a static clone of a normal document
79445:   bool mIsStaticDocument;
35581: 
35581:   // True while this document is being cloned to a static document.
79445:   bool mCreatingStaticClone;
35581: 
50721:   // True iff the document is being unlinked or deleted.
79445:   bool mInUnlinkOrDeletion;
50721: 
42823:   // True if document has ever had script handling object.
79445:   bool mHasHadScriptHandlingObject;
42823: 
50368:   // True if we're waiting for a before-paint event.
79445:   bool mHavePendingPaint;
50368: 
52207:   // True if we're an SVG document being used as an image.
79445:   bool mIsBeingUsedAsImage;
52207: 
75189:   // True is this document is synthetic : stand alone image, video, audio
75189:   // file, etc.
79445:   bool mIsSyntheticDocument;
75189: 
42823:   // The document's script global object, the object from which the
42823:   // document can get its script context and scope. This is the
42823:   // *inner* window object.
42823:   nsCOMPtr<nsIScriptGlobalObject> mScriptGlobalObject;
42823: 
35581:   // If mIsStaticDocument is true, mOriginalDocument points to the original
35581:   // document.
35581:   nsCOMPtr<nsIDocument> mOriginalDocument;
35581: 
    1:   // The bidi options for this document.  What this bitfield means is
    1:   // defined in nsBidiUtils.h
    1:   PRUint32 mBidiOptions;
    1: 
    1:   nsCString mContentLanguage;
46309: private:
    1:   nsCString mContentType;
46309: protected:
    1: 
    1:   // The document's security info
    1:   nsCOMPtr<nsISupports> mSecurityInfo;
    1: 
    1:   // if this document is part of a multipart document,
    1:   // the ID can be used to distinguish it from the other parts.
    1:   PRUint32 mPartID;
 1353:   
 1353:   // Cycle collector generation in which we're certain that this document
 1353:   // won't be collected
 1353:   PRUint32 mMarkedCCGeneration;
 1722: 
36917:   nsIPresShell* mPresShell;
 5684: 
 5684:   nsCOMArray<nsINode> mSubtreeModifiedTargets;
 5684:   PRUint32            mSubtreeModifiedDepth;
 8635: 
20078:   // If we're an external resource document, this will be non-null and will
20078:   // point to our "display document": the one that all resource lookups should
20078:   // go to.
20078:   nsCOMPtr<nsIDocument> mDisplayDocument;
20078: 
25722:   PRUint32 mEventsSuppressed;
37802: 
47680:   /**
47680:    * The number number of external scripts (ones with the src attribute) that
47680:    * have this document as their owner and that are being evaluated right now.
47680:    */
47680:   PRUint32 mExternalScriptsBeingEvaluated;
47680: 
40925:   // Weak reference to mScriptGlobalObject QI:d to nsPIDOMWindow,
40925:   // updated on every set of mSecriptGlobalObject.
40925:   nsPIDOMWindow *mWindow;
46309: 
46309:   nsCOMPtr<nsIDocumentEncoder> mCachedEncoder;
52255: 
52255:   AnimationListenerList mAnimationFrameListeners;
58185: 
80309:   // The session history entry in which we're currently bf-cached. Non-null
80309:   // if and only if we're currently in the bfcache.
80309:   nsISHEntry* mSHEntry;
60507: 
60507:   // Our base target.
60507:   nsString mBaseTarget;
62765: 
69563:   nsCOMPtr<nsIStructuredCloneContainer> mStateObjectContainer;
69563:   nsCOMPtr<nsIVariant> mStateObjectCached;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsIDocument, NS_IDOCUMENT_IID)
    1: 
    1: /**
   62:  * mozAutoSubtreeModified batches DOM mutations so that a DOMSubtreeModified
   62:  * event is dispatched, if necessary, when the outermost mozAutoSubtreeModified
   62:  * object is deleted.
   62:  */
15594: class NS_STACK_CLASS mozAutoSubtreeModified
   62: {
   62: public:
   62:   /**
   62:    * @param aSubTreeOwner The document in which a subtree will be modified.
   62:    * @param aTarget       The target of the possible DOMSubtreeModified event.
   62:    *                      Can be nsnull, in which case mozAutoSubtreeModified
   62:    *                      is just used to batch DOM mutations.
   62:    */
   62:   mozAutoSubtreeModified(nsIDocument* aSubtreeOwner, nsINode* aTarget)
   62:   {
   62:     UpdateTarget(aSubtreeOwner, aTarget);
   62:   }
   62: 
   62:   ~mozAutoSubtreeModified()
   62:   {
   62:     UpdateTarget(nsnull, nsnull);
   62:   }
   62: 
   62:   void UpdateTarget(nsIDocument* aSubtreeOwner, nsINode* aTarget)
   62:   {
   62:     if (mSubtreeOwner) {
   62:       mSubtreeOwner->MutationEventDispatched(mTarget);
   62:     }
   62: 
   62:     mTarget = aTarget;
   62:     mSubtreeOwner = aSubtreeOwner;
   62:     if (mSubtreeOwner) {
   62:       mSubtreeOwner->WillDispatchMutationEvent(mTarget);
   62:     }
   62:   }
   62: 
   62: private:
   62:   nsCOMPtr<nsINode>     mTarget;
   62:   nsCOMPtr<nsIDocument> mSubtreeOwner;
   62: };
   62: 
    1: // XXX These belong somewhere else
    1: nsresult
    1: NS_NewHTMLDocument(nsIDocument** aInstancePtrResult);
    1: 
    1: nsresult
    1: NS_NewXMLDocument(nsIDocument** aInstancePtrResult);
    1: 
    1: nsresult
    1: NS_NewSVGDocument(nsIDocument** aInstancePtrResult);
    1: 
    1: nsresult
    1: NS_NewImageDocument(nsIDocument** aInstancePtrResult);
    1: 
21079: #ifdef MOZ_MEDIA
21079: nsresult
21079: NS_NewVideoDocument(nsIDocument** aInstancePtrResult);
21079: #endif
21079: 
    1: nsresult
    1: NS_NewDocumentFragment(nsIDOMDocumentFragment** aInstancePtrResult,
    1:                        nsNodeInfoManager *aNodeInfoManager);
    1: 
    1: // Note: it's the caller's responsibility to create or get aPrincipal as needed
    1: // -- this method will not attempt to get a principal based on aDocumentURI.
    1: // Also, both aDocumentURI and aBaseURI must not be null.
    1: nsresult
    1: NS_NewDOMDocument(nsIDOMDocument** aInstancePtrResult,
    1:                   const nsAString& aNamespaceURI, 
    1:                   const nsAString& aQualifiedName, 
    1:                   nsIDOMDocumentType* aDoctype,
    1:                   nsIURI* aDocumentURI,
    1:                   nsIURI* aBaseURI,
 6475:                   nsIPrincipal* aPrincipal,
79445:                   bool aLoadedAsData,
78421:                   nsIScriptGlobalObject* aEventObject);
    1: nsresult
    1: NS_NewPluginDocument(nsIDocument** aInstancePtrResult);
    1: 
23258: inline nsIDocument*
23258: nsINode::GetOwnerDocument() const
23258: {
23258:   nsIDocument* ownerDoc = GetOwnerDoc();
23258: 
23258:   return ownerDoc != this ? ownerDoc : nsnull;
23258: }
23258: 
    1: #endif /* nsIDocument_h___ */
