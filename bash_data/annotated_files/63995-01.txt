58638: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
58638: /* ***** BEGIN LICENSE BLOCK *****
43628:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43628:  *
43628:  * The contents of this file are subject to the Mozilla Public License Version
43628:  * 1.1 (the "License"); you may not use this file except in compliance with
43628:  * the License. You may obtain a copy of the License at
43628:  * http://www.mozilla.org/MPL/
43628:  *
43628:  * Software distributed under the License is distributed on an "AS IS" basis,
43628:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43628:  * for the specific language governing rights and limitations under the
43628:  * License.
43628:  *
43628:  * The Initial Developer of the Original Code is Mozilla Foundation.
43628:  * Portions created by the Initial Developer are Copyright (C) 2010
43628:  * the Initial Developer. All Rights Reserved.
43628:  *
43628:  * Contributor(s):
43628:  *   Matt Woodrow <mwoodrow@mozilla.com>
43628:  *   Bas Schouten <bschouten@mozilla.com>
43628:  *
43628:  * Alternatively, the contents of this file may be used under the terms of
43628:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43628:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43628:  * in which case the provisions of the GPL or the LGPL are applicable instead
43628:  * of those above. If you wish to allow use of your version of this file only
43628:  * under the terms of either the GPL or the LGPL, and not to allow others to
43628:  * use your version of this file under the terms of the MPL, indicate your
43628:  * decision by deleting the provisions above and replace them with the notice
43628:  * and other provisions required by the GPL or the LGPL. If you do not delete
43628:  * the provisions above, a recipient may use your version of this file under
43628:  * the terms of any one of the MPL, the GPL or the LGPL.
43628:  *
43628:  * ***** END LICENSE BLOCK ***** */
43628: 
43628: #ifdef MOZ_WIDGET_GTK2
43628: #include <gdk/gdk.h>
43628: #include <gdk/gdkx.h>
43628: #define GET_NATIVE_WINDOW(aWidget) GDK_WINDOW_XID((GdkWindow *) aWidget->GetNativeData(NS_NATIVE_WINDOW))
43628: #elif defined(MOZ_WIDGET_QT)
43628: #include <QWidget>
43628: #include <QX11Info>
43628: #define GET_NATIVE_WINDOW(aWidget) static_cast<QWidget*>(aWidget->GetNativeData(NS_NATIVE_SHELLWIDGET))->handle()
43628: #endif
43628: 
43628: #include <X11/Xlib.h>
43628: #include <X11/Xutil.h>
43628: 
46140: #include "mozilla/X11Util.h"
46140: 
60261: #include "prenv.h"
43628: #include "GLContextProvider.h"
43628: #include "nsDebug.h"
43628: #include "nsIWidget.h"
43628: #include "GLXLibrary.h"
47908: #include "gfxXlibSurface.h"
46979: #include "gfxContext.h"
46979: #include "gfxImageSurface.h"
46979: #include "gfxPlatform.h"
57246: #include "GLContext.h"
43628: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
43628: namespace mozilla {
43628: namespace gl {
43628: 
47908: static PRBool gIsATI = PR_FALSE;
47908: static PRBool gIsChromium = PR_FALSE;
57247: static int gGLXMajorVersion = 0, gGLXMinorVersion = 0;
57247: 
57247: // Check that we have at least version aMajor.aMinor .
57247: static inline bool
57247: GLXVersionCheck(int aMajor, int aMinor)
57247: {
57247:     return aMajor < gGLXMajorVersion ||
57247:            (aMajor == gGLXMajorVersion && aMinor <= gGLXMinorVersion);
57247: }
47908: 
57246: static inline bool
57246: HasExtension(const char* aExtensions, const char* aRequiredExtension)
57246: {
57246:     return GLContext::ListHasExtension(
57246:         reinterpret_cast<const GLubyte*>(aExtensions), aRequiredExtension);
57246: }
57246: 
43628: PRBool
43628: GLXLibrary::EnsureInitialized()
43628: {
43628:     if (mInitialized) {
43628:         return PR_TRUE;
43628:     }
43628: 
57245:     // Don't repeatedly try to initialize.
57245:     if (mTriedInitializing) {
57245:         return PR_FALSE;
57245:     }
57245:     mTriedInitializing = PR_TRUE;
57245: 
43628:     if (!mOGLLibrary) {
63285:         // see e.g. bug 608526: it is intrinsically interesting to know whether we have dynamically linked to libGL.so.1
63285:         // because at least the NVIDIA implementation requires an executable stack, which causes mprotect calls,
63285:         // which trigger glibc bug http://sourceware.org/bugzilla/show_bug.cgi?id=12225
63285:         const char *libGLfilename = "libGL.so.1";
63285:         ScopedGfxFeatureReporter reporter(libGLfilename);
63285:         mOGLLibrary = PR_LoadLibrary(libGLfilename);
43628:         if (!mOGLLibrary) {
43628:             NS_WARNING("Couldn't load OpenGL shared library.");
43628:             return PR_FALSE;
43628:         }
63285:         reporter.SetSuccessful();
43628:     }
43628: 
43628:     LibrarySymbolLoader::SymLoadStruct symbols[] = {
57246:         /* functions that were in GLX 1.0 */
57241:         { (PRFuncPtr*) &xDestroyContext, { "glXDestroyContext", NULL } },
43628:         { (PRFuncPtr*) &xMakeCurrent, { "glXMakeCurrent", NULL } },
44139:         { (PRFuncPtr*) &xSwapBuffers, { "glXSwapBuffers", NULL } },
57247:         { (PRFuncPtr*) &xQueryVersion, { "glXQueryVersion", NULL } },
57246:         { (PRFuncPtr*) &xGetCurrentContext, { "glXGetCurrentContext", NULL } },
57246:         /* functions introduced in GLX 1.1 */
57244:         { (PRFuncPtr*) &xQueryExtensionsString, { "glXQueryExtensionsString", NULL } },
63995:         { (PRFuncPtr*) &xGetClientString, { "glXGetClientString", NULL } },
44139:         { (PRFuncPtr*) &xQueryServerString, { "glXQueryServerString", NULL } },
57246:         { NULL, { NULL } }
57246:     };
57246: 
57246:     LibrarySymbolLoader::SymLoadStruct symbols13[] = {
57246:         /* functions introduced in GLX 1.3 */
57246:         { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfig", NULL } },
57246:         { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttrib", NULL } },
57246:         // WARNING: xGetFBConfigs not set in symbols13_ext
57246:         { (PRFuncPtr*) &xGetFBConfigs, { "glXGetFBConfigs", NULL } },
57246:         { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
57246:         // WARNING: symbols13_ext sets xCreateGLXPixmapWithConfig instead
47908:         { (PRFuncPtr*) &xCreatePixmap, { "glXCreatePixmap", NULL } },
47908:         { (PRFuncPtr*) &xDestroyPixmap, { "glXDestroyPixmap", NULL } },
57246:         { (PRFuncPtr*) &xCreateNewContext, { "glXCreateNewContext", NULL } },
57246:         { NULL, { NULL } }
57246:     };
57246: 
57246:     LibrarySymbolLoader::SymLoadStruct symbols13_ext[] = {
57246:         /* extension equivalents for functions introduced in GLX 1.3 */
57246:         // GLX_SGIX_fbconfig extension
57246:         { (PRFuncPtr*) &xChooseFBConfig, { "glXChooseFBConfigSGIX", NULL } },
57246:         { (PRFuncPtr*) &xGetFBConfigAttrib, { "glXGetFBConfigAttribSGIX", NULL } },
57246:         // WARNING: no xGetFBConfigs equivalent in extensions
57246:         { (PRFuncPtr*) &xGetVisualFromFBConfig, { "glXGetVisualFromFBConfig", NULL } },
57246:         // WARNING: different from symbols13:
57246:         { (PRFuncPtr*) &xCreateGLXPixmapWithConfig, { "glXCreateGLXPixmapWithConfigSGIX", NULL } },
57246:         { (PRFuncPtr*) &xDestroyPixmap, { "glXDestroyGLXPixmap", NULL } }, // not from ext
57246:         { (PRFuncPtr*) &xCreateNewContext, { "glXCreateContextWithConfigSGIX", NULL } },
57246:         { NULL, { NULL } }
57246:     };
57246: 
57246:     LibrarySymbolLoader::SymLoadStruct symbols14[] = {
57246:         /* functions introduced in GLX 1.4 */
57246:         { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddress", NULL } },
57246:         { NULL, { NULL } }
57246:     };
57246: 
57246:     LibrarySymbolLoader::SymLoadStruct symbols14_ext[] = {
57246:         /* extension equivalents for functions introduced in GLX 1.4 */
57246:         // GLX_ARB_get_proc_address extension
57246:         { (PRFuncPtr*) &xGetProcAddress, { "glXGetProcAddressARB", NULL } },
43628:         { NULL, { NULL } }
43628:     };
43628: 
43628:     if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, &symbols[0])) {
43628:         NS_WARNING("Couldn't find required entry point in OpenGL shared library");
43628:         return PR_FALSE;
43628:     }
43628: 
57246:     Display *display = DefaultXDisplay();
63995:     PRBool ignoreBlacklist = PR_GetEnv("MOZ_GLX_IGNORE_BLACKLIST") != nsnull;
63995:     if (!ignoreBlacklist) {
63995:         // ATI's libGL (at least the one provided with 11.2 drivers) segfaults
63995:         // when querying server info if the server does not have the
63995:         // ATIFGLEXTENSION extension.
63995:         const char *clientVendor = xGetClientString(display, GLX_VENDOR);
63995:         if (clientVendor && strcmp(clientVendor, "ATI") == 0) {
63995:             printf("[GLX] The ATI proprietary libGL.so.1 is currently "
63995:                    "blacklisted to avoid crashes that happen in some "
63995:                    "situations. If you would like to bypass this, set the "
63995:                    "MOZ_GLX_IGNORE_BLACKLIST environment variable.\n");
63995:             return PR_FALSE;
63995:         }
63995:     }
63995: 
57246:     int screen = DefaultScreen(display);
63995:     const char *serverVendor;
62486:     const char *serverVersionStr;
62486:     const char *extensionsStr;
62486: 
63995:     // This scope is covered by a ScopedXErrorHandler to catch X errors in GLX
63995:     // calls.  See bug 632867 comment 3: Mesa versions up to 7.10 cause a
63995:     // BadLength error during the first GLX call that communicates with the
63995:     // server when the server GLX version < 1.3.
62486:     {
62486:         ScopedXErrorHandler xErrorHandler;
62486: 
57247:         if (!xQueryVersion(display, &gGLXMajorVersion, &gGLXMinorVersion)) {
57247:             gGLXMajorVersion = 0;
57247:             gGLXMinorVersion = 0;
57247:             return PR_FALSE;
57247:         }
57247: 
63995:         serverVendor = xQueryServerString(display, screen, GLX_VENDOR);
62486:         serverVersionStr = xQueryServerString(display, screen, GLX_VERSION);
62486: 
63995:         PRBool IsDriverBlacklisted = !serverVendor ||   // it's been reported that a VNC X server was returning serverVendor=null
63065:                                      !serverVersionStr ||
63995:                                      strcmp(serverVendor, "NVIDIA Corporation");
63065: 
63995:         if (IsDriverBlacklisted && !ignoreBlacklist)
62486:         {
62486:           printf("[GLX] your GL driver is currently blocked. If you would like to bypass this, "
62486:                   "define the MOZ_GLX_IGNORE_BLACKLIST environment variable.\n");
63065:           return PR_FALSE;
62486:         }
47908: 
57247:         if (!GLXVersionCheck(1, 1))
57246:             // Not possible to query for extensions.
47908:             return PR_FALSE;
47908: 
62486:         extensionsStr = xQueryExtensionsString(display, screen);
62486: 
62486:         if (xErrorHandler.GetError())
62486:           return PR_FALSE;
62486:     }
57246: 
57246:     LibrarySymbolLoader::SymLoadStruct *sym13;
57247:     if (!GLXVersionCheck(1, 3)) {
57246:         // Even if we don't have 1.3, we might have equivalent extensions
57246:         // (as on the Intel X server).
57246:         if (!HasExtension(extensionsStr, "GLX_SGIX_fbconfig")) {
57246:             return PR_FALSE;
57246:         }
57246:         sym13 = symbols13_ext;
57246:     } else {
57246:         sym13 = symbols13;
57246:     }
57246:     if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, sym13)) {
57246:         NS_WARNING("Couldn't find required entry point in OpenGL shared library");
57246:         return PR_FALSE;
57246:     }
57246: 
57246:     LibrarySymbolLoader::SymLoadStruct *sym14;
57247:     if (!GLXVersionCheck(1, 4)) {
57246:         // Even if we don't have 1.4, we might have equivalent extensions
57246:         // (as on the Intel X server).
57246:         if (!HasExtension(extensionsStr, "GLX_ARB_get_proc_address")) {
57246:             return PR_FALSE;
57246:         }
57246:         sym14 = symbols14_ext;
57246:     } else {
57246:         sym14 = symbols14;
57246:     }
57246:     if (!LibrarySymbolLoader::LoadSymbols(mOGLLibrary, sym14)) {
57246:         NS_WARNING("Couldn't find required entry point in OpenGL shared library");
57246:         return PR_FALSE;
57246:     }
57246: 
63995:     gIsATI = serverVendor && DoesVendorStringMatch(serverVendor, "ATI");
63995:     gIsChromium = (serverVendor &&
63995:                    DoesVendorStringMatch(serverVendor, "Chromium")) ||
63995:         (serverVersionStr &&
63995:          DoesVendorStringMatch(serverVersionStr, "Chromium"));
47908: 
43628:     mInitialized = PR_TRUE;
43628:     return PR_TRUE;
43628: }
43628: 
43628: GLXLibrary sGLXLibrary;
43628: 
43628: class GLContextGLX : public GLContext
43628: {
43628: public:
46140:     static already_AddRefed<GLContextGLX>
47908:     CreateGLContext(const ContextFormat& format,
47908:                     Display *display,
47908:                     GLXDrawable drawable,
47908:                     GLXFBConfig cfg,
47908:                     XVisualInfo *vinfo,
47908:                     GLContextGLX *shareContext,
47908:                     PRBool deleteDrawable,
47908:                     gfxXlibSurface *pixmap = nsnull)
43628:     {
44139:         int db = 0, err;
44139:         err = sGLXLibrary.xGetFBConfigAttrib(display, cfg,
44139:                                              GLX_DOUBLEBUFFER, &db);
44139:         if (GLX_BAD_ATTRIBUTE != err) {
44139: #ifdef DEBUG
44139:             printf("[GLX] FBConfig is %sdouble-buffered\n", db ? "" : "not ");
44139: #endif
44139:         }
44139: 
47908:         GLXContext context;
58663:         nsRefPtr<GLContextGLX> glContext;
62483:         bool error;
58663: 
58663:         ScopedXErrorHandler xErrorHandler;
43628: 
47908: TRY_AGAIN_NO_SHARING:
47908: 
62483:         error = false;
62483: 
47908:         context = sGLXLibrary.xCreateNewContext(display,
43628:                                                 cfg,
43628:                                                 GLX_RGBA_TYPE,
47908:                                                 shareContext ? shareContext->mContext : NULL,
43628:                                                 True);
43628: 
58663:         if (context) {
58663:             glContext = new GLContextGLX(format,
47908:                                         shareContext,
47908:                                         display,
43628:                                         drawable,
43628:                                         context,
47908:                                         deleteDrawable,
47908:                                         db,
58663:                                         pixmap);
58663:             if (!glContext->Init())
58663:                 error = true;
58663:         } else {
58663:             error = true;
58663:         }
58663: 
62485:         error |= xErrorHandler.SyncAndGetError(display);
62485: 
62485:         if (error) {
58663:             if (shareContext) {
58663:                 shareContext = nsnull;
58663:                 goto TRY_AGAIN_NO_SHARING;
58663:             }
58663: 
58663:             NS_WARNING("Failed to create GLXContext!");
58663:             glContext = nsnull; // note: this must be done while the graceful X error handler is set,
58663:                                 // because glxMakeCurrent can give a GLXBadDrawable error
58663:         }
43628: 
46140:         return glContext.forget();
43628:     }
43628: 
43628:     ~GLContextGLX()
43628:     {
54505:         MarkDestroyed();
49071: 
57241:         sGLXLibrary.xDestroyContext(mDisplay, mContext);
47908: 
47908:         if (mDeleteDrawable) {
47908:             sGLXLibrary.xDestroyPixmap(mDisplay, mDrawable);
47908:         }
43628:     }
43628: 
47908:     GLContextType GetContextType() {
47908:         return ContextTypeGLX;
43628:     }
43628: 
43628:     PRBool Init()
43628:     {
43628:         MakeCurrent();
43628:         SetupLookupFunction();
43628:         if (!InitWithPrefix("gl", PR_TRUE)) {
43628:             return PR_FALSE;
43628:         }
43628: 
43628:         return IsExtensionSupported("GL_EXT_framebuffer_object");
43628:     }
43628: 
55380:     PRBool MakeCurrentImpl(PRBool aForce = PR_FALSE)
43628:     {
54359:         PRBool succeeded = PR_TRUE;
54359: 
54359:         // With the ATI FGLRX driver, glxMakeCurrent is very slow even when the context doesn't change.
54359:         // (This is not the case with other drivers such as NVIDIA).
54359:         // So avoid calling it more than necessary. Since GLX documentation says that:
54359:         //     "glXGetCurrentContext returns client-side information.
54359:         //      It does not make a round trip to the server."
54359:         // I assume that it's not worth using our own TLS slot here.
54359:         if (aForce || sGLXLibrary.xGetCurrentContext() != mContext) {
54359:             succeeded = sGLXLibrary.xMakeCurrent(mDisplay, mDrawable, mContext);
43628:             NS_ASSERTION(succeeded, "Failed to make GL context current!");
54359:         }
54359: 
43628:         return succeeded;
43628:     }
43628: 
43628:     PRBool SetupLookupFunction()
43628:     {
43628:         mLookupFunc = (PlatformLookupFunction)sGLXLibrary.xGetProcAddress;
43628:         return PR_TRUE;
43628:     }
43628: 
43628:     void *GetNativeData(NativeDataType aType)
43628:     {
43628:         switch(aType) {
43628:         case NativeGLContext:
43628:             return mContext;
43628:  
47908:         case NativeThebesSurface:
47908:             return mPixmap;
43628: 
43628:         default:
43628:             return nsnull;
43628:         }
43628:     }
43628: 
47908:     PRBool IsDoubleBuffered()
44139:     {
47908:         return mDoubleBuffered;
47908:     }
47908: 
47908:     PRBool SwapBuffers()
47908:     {
47908:         if (!mDoubleBuffered)
44139:             return PR_FALSE;
47908:         sGLXLibrary.xSwapBuffers(mDisplay, mDrawable);
44139:         return PR_TRUE;
44139:     }
44139: 
43628: private:
47908:     friend class GLContextProviderGLX;
47908: 
47908:     GLContextGLX(const ContextFormat& aFormat,
47908:                  GLContext *aShareContext,
47908:                  Display *aDisplay,
47908:                  GLXDrawable aDrawable,
47908:                  GLXContext aContext,
47908:                  PRBool aDeleteDrawable,
47908:                  PRBool aDoubleBuffered,
47908:                  gfxXlibSurface *aPixmap)
47908:         : GLContext(aFormat, aDeleteDrawable ? PR_TRUE : PR_FALSE, aShareContext),
47908:           mContext(aContext),
43628:           mDisplay(aDisplay),
47908:           mDrawable(aDrawable),
47908:           mDeleteDrawable(aDeleteDrawable),
47908:           mDoubleBuffered(aDoubleBuffered),
47908:           mPixmap(aPixmap)
47908:     { }
43628: 
43628:     GLXContext mContext;
43628:     Display *mDisplay;
47908:     GLXDrawable mDrawable;
47908:     PRPackedBool mDeleteDrawable;
47908:     PRPackedBool mDoubleBuffered;
47908: 
47908:     nsRefPtr<gfxXlibSurface> mPixmap;
43628: };
43628: 
47908: static GLContextGLX *
47908: GetGlobalContextGLX()
47908: {
47908:     return static_cast<GLContextGLX*>(GLContextProviderGLX::GetGlobalContext());
47908: }
47908: 
47908: static PRBool
47908: AreCompatibleVisuals(XVisualInfo *one, XVisualInfo *two)
44139: {
44139:     if (one->c_class != two->c_class) {
44139:         return PR_FALSE;
44139:     }
44139: 
44139:     if (one->depth != two->depth) {
44139:         return PR_FALSE;
44139:     }	
44139: 
44139:     if (one->red_mask != two->red_mask ||
44139:         one->green_mask != two->green_mask ||
44139:         one->blue_mask != two->blue_mask) {
44139:         return PR_FALSE;
44139:     }
44139: 
44139:     if (one->bits_per_rgb != two->bits_per_rgb) {
44139:         return PR_FALSE;
44139:     }
44139: 
44139:     return PR_TRUE;
44139: }
44139: 
43628: already_AddRefed<GLContext>
47907: GLContextProviderGLX::CreateForWindow(nsIWidget *aWidget)
43628: {
44139:     if (!sGLXLibrary.EnsureInitialized()) {
43628:         return nsnull;
43628:     }
43628: 
44139:     // Currently, we take whatever Visual the window already has, and
44139:     // try to create an fbconfig for that visual.  This isn't
44139:     // necessarily what we want in the long run; an fbconfig may not
44139:     // be available for the existing visual, or if it is, the GL
44139:     // performance might be suboptimal.  But using the existing visual
44139:     // is a relatively safe intermediate step.
44139: 
44139:     Display *display = (Display*)aWidget->GetNativeData(NS_NATIVE_DISPLAY); 
44139:     int xscreen = DefaultScreen(display);
44139:     Window window = GET_NATIVE_WINDOW(aWidget);
44139: 
44139:     int numConfigs;
46140:     ScopedXFree<GLXFBConfig> cfgs;
57247:     if (gIsATI || !GLXVersionCheck(1, 3)) {
44139:         const int attribs[] = {
44139:             GLX_DOUBLEBUFFER, False,
44139:             0
44139:         };
44139:         cfgs = sGLXLibrary.xChooseFBConfig(display,
44139:                                            xscreen,
44139:                                            attribs,
44139:                                            &numConfigs);
44139:     } else {
44139:         cfgs = sGLXLibrary.xGetFBConfigs(display,
44139:                                          xscreen,
44139:                                          &numConfigs);
44139:     }
44139: 
44139:     if (!cfgs) {
44139:         NS_WARNING("[GLX] glXGetFBConfigs() failed");
44139:         return nsnull;
44139:     }
44139:     NS_ASSERTION(numConfigs > 0, "No FBConfigs found!");
44139: 
44139:     // XXX the visual ID is almost certainly the GLX_FBCONFIG_ID, so
44139:     // we could probably do this first and replace the glXGetFBConfigs
44139:     // with glXChooseConfigs.  Docs are sparklingly clear as always.
44139:     XWindowAttributes widgetAttrs;
44139:     if (!XGetWindowAttributes(display, window, &widgetAttrs)) {
44139:         NS_WARNING("[GLX] XGetWindowAttributes() failed");
44139:         return nsnull;
44139:     }
44139:     const VisualID widgetVisualID = XVisualIDFromVisual(widgetAttrs.visual);
44139: #ifdef DEBUG
44139:     printf("[GLX] widget has VisualID 0x%lx\n", widgetVisualID);
44139: #endif
44139: 
46140:     ScopedXFree<XVisualInfo> vi;
47908:     if (gIsATI) {
44139:         XVisualInfo vinfo_template;
44139:         int nvisuals;
44139:         vinfo_template.visual   = widgetAttrs.visual;
44139:         vinfo_template.visualid = XVisualIDFromVisual(vinfo_template.visual);
44139:         vinfo_template.depth    = widgetAttrs.depth;
44139:         vinfo_template.screen   = xscreen;
44139:         vi = XGetVisualInfo(display, VisualIDMask|VisualDepthMask|VisualScreenMask,
44139:                             &vinfo_template, &nvisuals);
44139:         NS_ASSERTION(vi && nvisuals == 1, "Could not locate unique matching XVisualInfo for Visual");
44139:     }
44139: 
44139:     int matchIndex = -1;
47908:     ScopedXFree<XVisualInfo> vinfo;
47908: 
44139:     for (int i = 0; i < numConfigs; i++) {
47908:         vinfo = sGLXLibrary.xGetVisualFromFBConfig(display, cfgs[i]);
47908:         if (!vinfo) {
44160:             continue;
44160:         }
47908:         if (gIsATI) {
47908:             if (AreCompatibleVisuals(vi, vinfo)) {
44139:                 matchIndex = i;
44139:                 break;
44139:             }
44139:         } else {
47908:             if (widgetVisualID == vinfo->visualid) {
44139:                 matchIndex = i;
44139:                 break;
44139:             }
44139:         }
44139:     }
44139: 
44139:     if (matchIndex == -1) {
44139:         NS_WARNING("[GLX] Couldn't find a FBConfig matching widget visual");
44139:         return nsnull;
44139:     }
44139: 
47908:     GLContextGLX *shareContext = GetGlobalContextGLX();
47908: 
47908:     nsRefPtr<GLContextGLX> glContext = GLContextGLX::CreateGLContext(ContextFormat(ContextFormat::BasicRGB24),
47908:                                                                      display,
44139:                                                                      window,
44139:                                                                      cfgs[matchIndex],
47908:                                                                      vinfo,
47908:                                                                      shareContext,
44139:                                                                      PR_FALSE);
46140:     return glContext.forget();
44139: }
44139: 
47908: static already_AddRefed<GLContextGLX>
47908: CreateOffscreenPixmapContext(const gfxIntSize& aSize,
47908:                              const ContextFormat& aFormat,
47908:                              PRBool aShare)
43628: {
43628:     if (!sGLXLibrary.EnsureInitialized()) {
43628:         return nsnull;
43628:     }
43628: 
47908:     Display *display = DefaultXDisplay();
47908:     int xscreen = DefaultScreen(display);
47908: 
47908:     int attribs[] = {
47908:         GLX_DOUBLEBUFFER, False,
47908:         GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
47908:         GLX_X_RENDERABLE, True,
47908:         GLX_RED_SIZE, 1,
47908:         GLX_GREEN_SIZE, 1,
47908:         GLX_BLUE_SIZE, 1,
47908:         GLX_ALPHA_SIZE, 0,
47908:         GLX_DEPTH_SIZE, 0,
47908:         0
47908:     };
47908:     int numConfigs = 0;
47908: 
47908:     ScopedXFree<GLXFBConfig> cfgs;
47908:     cfgs = sGLXLibrary.xChooseFBConfig(display,
47908:                                        xscreen,
47908:                                        attribs,
47908:                                        &numConfigs);
47908:     if (!cfgs) {
47908:         return nsnull;
47908:     }
47908: 
47908:     NS_ASSERTION(numConfigs > 0,
47908:                  "glXChooseFBConfig() failed to match our requested format and violated its spec (!)");
47908: 
47908:     ScopedXFree<XVisualInfo> vinfo;
58638:     int chosenIndex = 0;
47908: 
47908:     for (int i = 0; i < numConfigs; ++i) {
47908:         int dtype, visid;
47908: 
47908:         if (sGLXLibrary.xGetFBConfigAttrib(display, cfgs[i], GLX_DRAWABLE_TYPE, &dtype) != Success
47908:             || !(dtype & GLX_PIXMAP_BIT))
47908:         {
47908:             continue;
47908:         }
47908:         if (sGLXLibrary.xGetFBConfigAttrib(display, cfgs[i], GLX_VISUAL_ID, &visid) != Success
47908:             || visid == 0)
47908:         {
47908:             continue;
47908:         }
47908: 
47908:         vinfo = sGLXLibrary.xGetVisualFromFBConfig(display, cfgs[i]);
47908: 
47908:         if (vinfo) {
47908:             chosenIndex = i;
47908:             break;
47908:         }
47908:     }
47908: 
47908:     if (!vinfo) {
47908:         NS_WARNING("glXChooseFBConfig() didn't give us any configs with visuals!");
47908:         return nsnull;
47908:     }
47908: 
58663:     ScopedXErrorHandler xErrorHandler;
60113:     GLXPixmap glxpixmap = 0;
58663:     bool error = false;
58663: 
47908:     nsRefPtr<gfxXlibSurface> xsurface = gfxXlibSurface::Create(DefaultScreenOfDisplay(display),
47908:                                                                vinfo->visual,
47908:                                                                gfxIntSize(16, 16));
47908:     if (xsurface->CairoStatus() != 0) {
58663:         error = true;
58663:         goto DONE_CREATING_PIXMAP;
47908:     }
47908: 
57246:     // Handle slightly different signature between glXCreatePixmap and
57246:     // its pre-GLX-1.3 extension equivalent (though given the ABI, we
57246:     // might not need to).
57247:     if (GLXVersionCheck(1, 3)) {
57246:         glxpixmap = sGLXLibrary.xCreatePixmap(display,
47908:                                               cfgs[chosenIndex],
47908:                                               xsurface->XDrawable(),
47908:                                               NULL);
57246:     } else {
57246:         glxpixmap = sGLXLibrary.xCreateGLXPixmapWithConfig(display,
57246:                                                            cfgs[chosenIndex],
57246:                                                            xsurface->
57246:                                                              XDrawable());
57246:     }
47908:     if (glxpixmap == 0) {
58663:         error = true;
47908:     }
47908: 
58663: DONE_CREATING_PIXMAP:
47908: 
58663:     nsRefPtr<GLContextGLX> glContext;
58663:     bool serverError = xErrorHandler.SyncAndGetError(display);
58663: 
58663:     if (!error && // earlier recorded error
58663:         !serverError)
58663:     {
58663:         glContext = GLContextGLX::CreateGLContext(
58663:                         aFormat,
47908:                         display,
47908:                         glxpixmap,
47908:                         cfgs[chosenIndex],
47908:                         vinfo,
58663:                         aShare ? GetGlobalContextGLX() : nsnull,
47908:                         PR_TRUE,
47908:                         xsurface);
58663:     }
47908: 
47908:     return glContext.forget();
47908: }
47908: 
47908: already_AddRefed<GLContext>
47908: GLContextProviderGLX::CreateOffscreen(const gfxIntSize& aSize,
47908:                                       const ContextFormat& aFormat)
47908: {
47908: 
47908:     nsRefPtr<GLContextGLX> glContext =
47908:         CreateOffscreenPixmapContext(aSize, aFormat, PR_TRUE);
47908: 
47908:     if (!glContext) {
47908:         return nsnull;
47908:     }
47908: 
47908:     if (!glContext->GetSharedContext()) {
47908:         // no point in returning anything if sharing failed, we can't
47908:         // render from this
47908:         return nsnull;
47908:     }
47908: 
47908:     if (!glContext->ResizeOffscreenFBO(aSize)) {
47908:         // we weren't able to create the initial
47908:         // offscreen FBO, so this is dead
47908:         return nsnull;
47908:     }
47908: 
47908:     return glContext.forget();
47908: }
47908: 
47908: already_AddRefed<GLContext>
47908: GLContextProviderGLX::CreateForNativePixmapSurface(gfxASurface *aSurface)
47908: {
47908:     if (!sGLXLibrary.EnsureInitialized()) {
47908:         return nsnull;
47908:     }
47908: 
47908:     if (aSurface->GetType() != gfxASurface::SurfaceTypeXlib) {
47908:         NS_WARNING("GLContextProviderGLX::CreateForNativePixmapSurface called with non-Xlib surface");
47908:         return nsnull;
47908:     }
47908: 
47908:     nsAutoTArray<int, 20> attribs;
43628: 
43628: #define A1_(_x)  do { attribs.AppendElement(_x); } while(0)
43628: #define A2_(_x,_y)  do {                                                \
43628:         attribs.AppendElement(_x);                                      \
43628:         attribs.AppendElement(_y);                                      \
43628:     } while(0)
43628: 
47908:     A2_(GLX_DOUBLEBUFFER, False);
47908:     A2_(GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT);
47908:     A1_(0);
47908: 
43628:     int numFormats;
46140:     Display *display = DefaultXDisplay();
43628:     int xscreen = DefaultScreen(display);
43628: 
46140:     ScopedXFree<GLXFBConfig> cfg(sGLXLibrary.xChooseFBConfig(display,
43628:                                                              xscreen,
43628:                                                              attribs.Elements(),
46140:                                                              &numFormats));
43628:     if (!cfg) {
43628:         return nsnull;
43628:     }
46140:     NS_ASSERTION(numFormats > 0,
46140:                  "glXChooseFBConfig() failed to match our requested format and violated its spec (!)");
43628: 
47908:     gfxXlibSurface *xs = static_cast<gfxXlibSurface*>(aSurface);
43628: 
47908:     GLXPixmap glxpixmap = sGLXLibrary.xCreatePixmap(display,
43628:                                                     cfg[0],
47908:                                                     xs->XDrawable(),
47908:                                                     NULL);
43628: 
47908:     nsRefPtr<GLContextGLX> glContext = GLContextGLX::CreateGLContext(ContextFormat(ContextFormat::BasicRGB24),
47908:                                                                      display,
47908:                                                                      glxpixmap,
47908:                                                                      cfg[0],
47908:                                                                      NULL,
47908:                                                                      NULL,
47908:                                                                      PR_FALSE,
47908:                                                                      xs);
47908: 
46140:     return glContext.forget();
43628: }
43628: 
47908: static nsRefPtr<GLContext> gGlobalContext;
47908: 
47908: GLContext *
47908: GLContextProviderGLX::GetGlobalContext()
44173: {
47908:     static bool triedToCreateContext = false;
47908:     if (!triedToCreateContext && !gGlobalContext) {
47908:         triedToCreateContext = true;
47908:         gGlobalContext = CreateOffscreenPixmapContext(gfxIntSize(1, 1),
47908:                                                       ContextFormat(ContextFormat::BasicRGB24),
47908:                                                       PR_FALSE);
49071:         if (gGlobalContext)
49071:             gGlobalContext->SetIsGlobalSharedContext(PR_TRUE);
47908:     }
47908: 
47908:     return gGlobalContext;
44173: }
44173: 
47967: void
47967: GLContextProviderGLX::Shutdown()
47967: {
47967:     gGlobalContext = nsnull;
47967: }
47967: 
43628: } /* namespace gl */
43628: } /* namespace mozilla */
