    1: /* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
    1:    See the file COPYING for copying permission.
    1: */
    1: 
    1: #include <stddef.h>
    1: #include <string.h>                     /* memset(), memcpy() */
    1: #include <assert.h>
    1: 
    1: #define XML_BUILDING_EXPAT 1
    1: 
    1: #ifdef COMPILED_FROM_DSP
    1: #include "winconfig.h"
    1: #elif defined(MACOS_CLASSIC)
    1: #include "macconfig.h"
    1: #elif defined(__amigaos4__)
    1: #include "amigaconfig.h"
    1: #elif defined(HAVE_EXPAT_CONFIG_H)
    1: #include <expat_config.h>
    1: #endif /* ndef COMPILED_FROM_DSP */
    1: 
    1: #include "expat.h"
    1: 
    1: #ifdef XML_UNICODE
    1: #define XML_ENCODE_MAX XML_UTF16_ENCODE_MAX
    1: #define XmlConvert XmlUtf16Convert
    1: #define XmlGetInternalEncoding XmlGetUtf16InternalEncoding
    1: #define XmlGetInternalEncodingNS XmlGetUtf16InternalEncodingNS
    1: #define XmlEncode XmlUtf16Encode
    1: #define MUST_CONVERT(enc, s) (!(enc)->isUtf16 || (((unsigned long)s) & 1))
    1: typedef unsigned short ICHAR;
    1: #else
    1: #define XML_ENCODE_MAX XML_UTF8_ENCODE_MAX
    1: #define XmlConvert XmlUtf8Convert
    1: #define XmlGetInternalEncoding XmlGetUtf8InternalEncoding
    1: #define XmlGetInternalEncodingNS XmlGetUtf8InternalEncodingNS
    1: #define XmlEncode XmlUtf8Encode
    1: #define MUST_CONVERT(enc, s) (!(enc)->isUtf8)
    1: typedef char ICHAR;
    1: #endif
    1: 
    1: 
    1: #ifndef XML_NS
    1: 
    1: #define XmlInitEncodingNS XmlInitEncoding
    1: #define XmlInitUnknownEncodingNS XmlInitUnknownEncoding
    1: #undef XmlGetInternalEncodingNS
    1: #define XmlGetInternalEncodingNS XmlGetInternalEncoding
    1: #define XmlParseXmlDeclNS XmlParseXmlDecl
    1: 
    1: #endif
    1: 
    1: /* BEGIN MOZILLA CHANGE (typedef XML_Char to PRUnichar) */
    1: #if 0
    1: 
    1: #ifdef XML_UNICODE
    1: 
    1: #ifdef XML_UNICODE_WCHAR_T
    1: #define XML_T(x) (const wchar_t)x
    1: #define XML_L(x) L ## x
    1: #else
    1: #define XML_T(x) (const unsigned short)x
    1: #define XML_L(x) x
    1: #endif
    1: 
    1: #else
    1: 
    1: #define XML_T(x) x
    1: #define XML_L(x) x
    1: 
    1: #endif
    1: 
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: /* Round up n to be a multiple of sz, where sz is a power of 2. */
    1: #define ROUND_UP(n, sz) (((n) + ((sz) - 1)) & ~((sz) - 1))
    1: 
    1: /* Handle the case where memmove() doesn't exist. */
    1: #ifndef HAVE_MEMMOVE
    1: #ifdef HAVE_BCOPY
    1: #define memmove(d,s,l) bcopy((s),(d),(l))
    1: #else
    1: #error memmove does not exist on this platform, nor is a substitute available
    1: #endif /* HAVE_BCOPY */
    1: #endif /* HAVE_MEMMOVE */
    1: 
    1: #include "internal.h"
    1: #include "xmltok.h"
    1: #include "xmlrole.h"
    1: 
    1: typedef const XML_Char *KEY;
    1: 
    1: typedef struct {
    1:   KEY name;
    1: } NAMED;
    1: 
    1: typedef struct {
    1:   NAMED **v;
    1:   unsigned char power;
    1:   size_t size;
    1:   size_t used;
    1:   const XML_Memory_Handling_Suite *mem;
    1: } HASH_TABLE;
    1: 
    1: /* Basic character hash algorithm, taken from Python's string hash:
    1:    h = h * 1000003 ^ character, the constant being a prime number.
    1: 
    1: */
    1: #ifdef XML_UNICODE
    1: #define CHAR_HASH(h, c) \
    1:   (((h) * 0xF4243) ^ (unsigned short)(c))
    1: #else
    1: #define CHAR_HASH(h, c) \
    1:   (((h) * 0xF4243) ^ (unsigned char)(c))
    1: #endif
    1: 
    1: /* For probing (after a collision) we need a step size relative prime
    1:    to the hash table size, which is a power of 2. We use double-hashing,
    1:    since we can calculate a second hash value cheaply by taking those bits
    1:    of the first hash value that were discarded (masked out) when the table
    1:    index was calculated: index = hash & mask, where mask = table->size - 1.
    1:    We limit the maximum step size to table->size / 4 (mask >> 2) and make
    1:    it odd, since odd numbers are always relative prime to a power of 2.
    1: */
    1: #define SECOND_HASH(hash, mask, power) \
    1:   ((((hash) & ~(mask)) >> ((power) - 1)) & ((mask) >> 2))
    1: #define PROBE_STEP(hash, mask, power) \
    1:   ((unsigned char)((SECOND_HASH(hash, mask, power)) | 1))
    1: 
    1: typedef struct {
    1:   NAMED **p;
    1:   NAMED **end;
    1: } HASH_TABLE_ITER;
    1: 
    1: #define INIT_TAG_BUF_SIZE 32  /* must be a multiple of sizeof(XML_Char) */
    1: #define INIT_DATA_BUF_SIZE 1024
    1: #define INIT_ATTS_SIZE 16
    1: #define INIT_ATTS_VERSION 0xFFFFFFFF
    1: #define INIT_BLOCK_SIZE 1024
    1: #define INIT_BUFFER_SIZE 1024
    1: 
    1: #define EXPAND_SPARE 24
    1: 
    1: typedef struct binding {
    1:   struct prefix *prefix;
    1:   struct binding *nextTagBinding;
    1:   struct binding *prevPrefixBinding;
    1:   const struct attribute_id *attId;
    1:   XML_Char *uri;
    1:   int uriLen;
    1:   int uriAlloc;
    1: } BINDING;
    1: 
    1: typedef struct prefix {
    1:   const XML_Char *name;
    1:   BINDING *binding;
    1: } PREFIX;
    1: 
    1: typedef struct {
    1:   const XML_Char *str;
    1:   const XML_Char *localPart;
    1:   const XML_Char *prefix;
    1:   int strLen;
    1:   int uriLen;
    1:   int prefixLen;
    1: } TAG_NAME;
    1: 
    1: /* TAG represents an open element.
    1:    The name of the element is stored in both the document and API
    1:    encodings.  The memory buffer 'buf' is a separately-allocated
    1:    memory area which stores the name.  During the XML_Parse()/
    1:    XMLParseBuffer() when the element is open, the memory for the 'raw'
    1:    version of the name (in the document encoding) is shared with the
    1:    document buffer.  If the element is open across calls to
    1:    XML_Parse()/XML_ParseBuffer(), the buffer is re-allocated to
    1:    contain the 'raw' name as well.
    1: 
    1:    A parser re-uses these structures, maintaining a list of allocated
    1:    TAG objects in a free list.
    1: */
    1: typedef struct tag {
    1:   struct tag *parent;           /* parent of this element */
    1:   const char *rawName;          /* tagName in the original encoding */
    1:   int rawNameLength;
    1:   TAG_NAME name;                /* tagName in the API encoding */
    1:   char *buf;                    /* buffer for name components */
    1:   char *bufEnd;                 /* end of the buffer */
    1:   BINDING *bindings;
    1: } TAG;
    1: 
    1: typedef struct {
    1:   const XML_Char *name;
    1:   const XML_Char *textPtr;
    1:   int textLen;                  /* length in XML_Chars */
    1:   int processed;                /* # of processed bytes - when suspended */
    1:   const XML_Char *systemId;
    1:   const XML_Char *base;
    1:   const XML_Char *publicId;
    1:   const XML_Char *notation;
    1:   XML_Bool open;
    1:   XML_Bool is_param;
    1:   XML_Bool is_internal; /* true if declared in internal subset outside PE */
    1: } ENTITY;
    1: 
    1: typedef struct {
    1:   enum XML_Content_Type         type;
    1:   enum XML_Content_Quant        quant;
    1:   const XML_Char *              name;
    1:   int                           firstchild;
    1:   int                           lastchild;
    1:   int                           childcnt;
    1:   int                           nextsib;
    1: } CONTENT_SCAFFOLD;
    1: 
    1: #define INIT_SCAFFOLD_ELEMENTS 32
    1: 
    1: typedef struct block {
    1:   struct block *next;
    1:   int size;
    1:   XML_Char s[1];
    1: } BLOCK;
    1: 
    1: typedef struct {
    1:   BLOCK *blocks;
    1:   BLOCK *freeBlocks;
    1:   const XML_Char *end;
    1:   XML_Char *ptr;
    1:   XML_Char *start;
    1:   const XML_Memory_Handling_Suite *mem;
    1: } STRING_POOL;
    1: 
    1: /* The XML_Char before the name is used to determine whether
    1:    an attribute has been specified. */
    1: typedef struct attribute_id {
    1:   XML_Char *name;
    1:   PREFIX *prefix;
    1:   XML_Bool maybeTokenized;
    1:   XML_Bool xmlns;
    1: } ATTRIBUTE_ID;
    1: 
    1: typedef struct {
    1:   const ATTRIBUTE_ID *id;
    1:   XML_Bool isCdata;
    1:   const XML_Char *value;
    1: } DEFAULT_ATTRIBUTE;
    1: 
    1: typedef struct {
    1:   unsigned long version;
    1:   unsigned long hash;
    1:   const XML_Char *uriName;
    1: } NS_ATT;
    1: 
    1: typedef struct {
    1:   const XML_Char *name;
    1:   PREFIX *prefix;
    1:   const ATTRIBUTE_ID *idAtt;
    1:   int nDefaultAtts;
    1:   int allocDefaultAtts;
    1:   DEFAULT_ATTRIBUTE *defaultAtts;
    1: } ELEMENT_TYPE;
    1: 
    1: typedef struct {
    1:   HASH_TABLE generalEntities;
    1:   HASH_TABLE elementTypes;
    1:   HASH_TABLE attributeIds;
    1:   HASH_TABLE prefixes;
    1:   STRING_POOL pool;
    1:   STRING_POOL entityValuePool;
    1:   /* false once a parameter entity reference has been skipped */
    1:   XML_Bool keepProcessing;
    1:   /* true once an internal or external PE reference has been encountered;
    1:      this includes the reference to an external subset */
    1:   XML_Bool hasParamEntityRefs;
    1:   XML_Bool standalone;
    1: #ifdef XML_DTD
    1:   /* indicates if external PE has been read */
    1:   XML_Bool paramEntityRead;
    1:   HASH_TABLE paramEntities;
    1: #endif /* XML_DTD */
    1:   PREFIX defaultPrefix;
    1:   /* === scaffolding for building content model === */
    1:   XML_Bool in_eldecl;
    1:   CONTENT_SCAFFOLD *scaffold;
    1:   unsigned contentStringLen;
    1:   unsigned scaffSize;
    1:   unsigned scaffCount;
    1:   int scaffLevel;
    1:   int *scaffIndex;
    1: } DTD;
    1: 
    1: typedef struct open_internal_entity {
    1:   const char *internalEventPtr;
    1:   const char *internalEventEndPtr;
    1:   struct open_internal_entity *next;
    1:   ENTITY *entity;
    1:   int startTagLevel;
    1:   XML_Bool betweenDecl; /* WFC: PE Between Declarations */
    1: } OPEN_INTERNAL_ENTITY;
    1: 
    1: typedef enum XML_Error PTRCALL Processor(XML_Parser parser,
    1:                                          const char *start,
    1:                                          const char *end,
    1:                                          const char **endPtr);
    1: 
    1: static Processor prologProcessor;
    1: static Processor prologInitProcessor;
    1: static Processor contentProcessor;
    1: static Processor cdataSectionProcessor;
    1: #ifdef XML_DTD
    1: static Processor ignoreSectionProcessor;
    1: static Processor externalParEntProcessor;
    1: static Processor externalParEntInitProcessor;
    1: static Processor entityValueProcessor;
    1: static Processor entityValueInitProcessor;
    1: #endif /* XML_DTD */
    1: static Processor epilogProcessor;
    1: static Processor errorProcessor;
    1: static Processor externalEntityInitProcessor;
    1: static Processor externalEntityInitProcessor2;
    1: static Processor externalEntityInitProcessor3;
    1: static Processor externalEntityContentProcessor;
    1: static Processor internalEntityProcessor;
    1: 
    1: static enum XML_Error
    1: handleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName);
    1: static enum XML_Error
    1: processXmlDecl(XML_Parser parser, int isGeneralTextEntity,
    1:                const char *s, const char *next);
    1: static enum XML_Error
    1: initializeEncoding(XML_Parser parser);
    1: static enum XML_Error
    1: doProlog(XML_Parser parser, const ENCODING *enc, const char *s, 
    1:          const char *end, int tok, const char *next, const char **nextPtr, 
    1:          XML_Bool haveMore);
    1: static enum XML_Error
    1: processInternalEntity(XML_Parser parser, ENTITY *entity, 
    1:                       XML_Bool betweenDecl);
    1: static enum XML_Error
    1: doContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,
    1:           const char *start, const char *end, const char **endPtr, 
    1:           XML_Bool haveMore);
    1: static enum XML_Error
    1: doCdataSection(XML_Parser parser, const ENCODING *, const char **startPtr,
    1:                const char *end, const char **nextPtr, XML_Bool haveMore);
    1: #ifdef XML_DTD
    1: static enum XML_Error
    1: doIgnoreSection(XML_Parser parser, const ENCODING *, const char **startPtr,
    1:                 const char *end, const char **nextPtr, XML_Bool haveMore);
    1: #endif /* XML_DTD */
    1: 
    1: static enum XML_Error
    1: storeAtts(XML_Parser parser, const ENCODING *, const char *s,
    1:           TAG_NAME *tagNamePtr, BINDING **bindingsPtr);
    1: static enum XML_Error
    1: addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
    1:            const XML_Char *uri, BINDING **bindingsPtr);
    1: static int
    1: defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *, XML_Bool isCdata, 
    1:                 XML_Bool isId, const XML_Char *dfltValue, XML_Parser parser);
    1: static enum XML_Error
    1: storeAttributeValue(XML_Parser parser, const ENCODING *, XML_Bool isCdata,
    1:                     const char *, const char *, STRING_POOL *);
    1: static enum XML_Error
    1: appendAttributeValue(XML_Parser parser, const ENCODING *, XML_Bool isCdata,
    1:                      const char *, const char *, STRING_POOL *);
    1: static ATTRIBUTE_ID *
    1: getAttributeId(XML_Parser parser, const ENCODING *enc, const char *start,
    1:                const char *end);
    1: static int
    1: setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *);
    1: static enum XML_Error
    1: storeEntityValue(XML_Parser parser, const ENCODING *enc, const char *start,
    1:                  const char *end);
    1: static int
    1: reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,
    1:                             const char *start, const char *end);
    1: static int
    1: reportComment(XML_Parser parser, const ENCODING *enc, const char *start,
    1:               const char *end);
    1: static void
    1: reportDefault(XML_Parser parser, const ENCODING *enc, const char *start,
    1:               const char *end);
    1: 
    1: static const XML_Char * getContext(XML_Parser parser);
    1: static XML_Bool
    1: setContext(XML_Parser parser, const XML_Char *context);
    1: 
    1: static void FASTCALL normalizePublicId(XML_Char *s);
    1: 
    1: static DTD * dtdCreate(const XML_Memory_Handling_Suite *ms);
    1: /* do not call if parentParser != NULL */
    1: static void dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms);
    1: static void
    1: dtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms);
    1: static int
    1: dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms);
    1: static int
    1: copyEntityTable(HASH_TABLE *, STRING_POOL *, const HASH_TABLE *);
    1: 
    1: static NAMED *
    1: lookup(HASH_TABLE *table, KEY name, size_t createSize);
    1: static void FASTCALL
    1: hashTableInit(HASH_TABLE *, const XML_Memory_Handling_Suite *ms);
    1: static void FASTCALL hashTableClear(HASH_TABLE *);
    1: static void FASTCALL hashTableDestroy(HASH_TABLE *);
    1: static void FASTCALL
    1: hashTableIterInit(HASH_TABLE_ITER *, const HASH_TABLE *);
    1: static NAMED * FASTCALL hashTableIterNext(HASH_TABLE_ITER *);
    1: 
    1: static void FASTCALL
    1: poolInit(STRING_POOL *, const XML_Memory_Handling_Suite *ms);
    1: static void FASTCALL poolClear(STRING_POOL *);
    1: static void FASTCALL poolDestroy(STRING_POOL *);
    1: static XML_Char *
    1: poolAppend(STRING_POOL *pool, const ENCODING *enc,
    1:            const char *ptr, const char *end);
    1: static XML_Char *
    1: poolStoreString(STRING_POOL *pool, const ENCODING *enc,
    1:                 const char *ptr, const char *end);
    1: static XML_Bool FASTCALL poolGrow(STRING_POOL *pool);
    1: static const XML_Char * FASTCALL
    1: poolCopyString(STRING_POOL *pool, const XML_Char *s);
    1: static const XML_Char *
    1: poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n);
    1: static const XML_Char * FASTCALL
    1: poolAppendString(STRING_POOL *pool, const XML_Char *s);
    1: 
    1: static int FASTCALL nextScaffoldPart(XML_Parser parser);
    1: static XML_Content * build_model(XML_Parser parser);
    1: static ELEMENT_TYPE *
    1: getElementType(XML_Parser parser, const ENCODING *enc,
    1:                const char *ptr, const char *end);
    1: 
    1: static XML_Parser
    1: parserCreate(const XML_Char *encodingName,
    1:              const XML_Memory_Handling_Suite *memsuite,
    1:              const XML_Char *nameSep,
    1:              DTD *dtd);
    1: static void
    1: parserInit(XML_Parser parser, const XML_Char *encodingName);
    1: 
    1: #define poolStart(pool) ((pool)->start)
    1: #define poolEnd(pool) ((pool)->ptr)
    1: #define poolLength(pool) ((pool)->ptr - (pool)->start)
    1: #define poolChop(pool) ((void)--(pool->ptr))
    1: #define poolLastChar(pool) (((pool)->ptr)[-1])
    1: #define poolDiscard(pool) ((pool)->ptr = (pool)->start)
    1: #define poolFinish(pool) ((pool)->start = (pool)->ptr)
    1: #define poolAppendChar(pool, c) \
    1:   (((pool)->ptr == (pool)->end && !poolGrow(pool)) \
    1:    ? 0 \
    1:    : ((*((pool)->ptr)++ = c), 1))
    1: 
    1: struct XML_ParserStruct {
    1:   /* The first member must be userData so that the XML_GetUserData
    1:      macro works. */
    1:   void *m_userData;
    1:   void *m_handlerArg;
    1:   char *m_buffer;
    1:   const XML_Memory_Handling_Suite m_mem;
    1:   /* first character to be parsed */
    1:   const char *m_bufferPtr;
    1:   /* past last character to be parsed */
    1:   char *m_bufferEnd;
    1:   /* allocated end of buffer */
    1:   const char *m_bufferLim;
    1:   XML_Index m_parseEndByteIndex;
    1:   const char *m_parseEndPtr;
    1:   XML_Char *m_dataBuf;
    1:   XML_Char *m_dataBufEnd;
    1:   XML_StartElementHandler m_startElementHandler;
    1:   XML_EndElementHandler m_endElementHandler;
    1:   XML_CharacterDataHandler m_characterDataHandler;
    1:   XML_ProcessingInstructionHandler m_processingInstructionHandler;
    1:   XML_CommentHandler m_commentHandler;
    1:   XML_StartCdataSectionHandler m_startCdataSectionHandler;
    1:   XML_EndCdataSectionHandler m_endCdataSectionHandler;
    1:   XML_DefaultHandler m_defaultHandler;
    1:   XML_StartDoctypeDeclHandler m_startDoctypeDeclHandler;
    1:   XML_EndDoctypeDeclHandler m_endDoctypeDeclHandler;
    1:   XML_UnparsedEntityDeclHandler m_unparsedEntityDeclHandler;
    1:   XML_NotationDeclHandler m_notationDeclHandler;
    1:   XML_StartNamespaceDeclHandler m_startNamespaceDeclHandler;
    1:   XML_EndNamespaceDeclHandler m_endNamespaceDeclHandler;
    1:   XML_NotStandaloneHandler m_notStandaloneHandler;
    1:   XML_ExternalEntityRefHandler m_externalEntityRefHandler;
    1:   XML_Parser m_externalEntityRefHandlerArg;
    1:   XML_SkippedEntityHandler m_skippedEntityHandler;
    1:   XML_UnknownEncodingHandler m_unknownEncodingHandler;
    1:   XML_ElementDeclHandler m_elementDeclHandler;
    1:   XML_AttlistDeclHandler m_attlistDeclHandler;
    1:   XML_EntityDeclHandler m_entityDeclHandler;
    1:   XML_XmlDeclHandler m_xmlDeclHandler;
    1:   const ENCODING *m_encoding;
    1:   INIT_ENCODING m_initEncoding;
    1:   const ENCODING *m_internalEncoding;
    1:   const XML_Char *m_protocolEncodingName;
    1:   XML_Bool m_ns;
    1:   XML_Bool m_ns_triplets;
    1:   void *m_unknownEncodingMem;
    1:   void *m_unknownEncodingData;
    1:   void *m_unknownEncodingHandlerData;
    1:   void (XMLCALL *m_unknownEncodingRelease)(void *);
    1:   PROLOG_STATE m_prologState;
    1:   Processor *m_processor;
    1:   enum XML_Error m_errorCode;
    1:   const char *m_eventPtr;
    1:   const char *m_eventEndPtr;
    1:   const char *m_positionPtr;
    1:   OPEN_INTERNAL_ENTITY *m_openInternalEntities;
    1:   OPEN_INTERNAL_ENTITY *m_freeInternalEntities;
    1:   XML_Bool m_defaultExpandInternalEntities;
    1:   int m_tagLevel;
    1:   ENTITY *m_declEntity;
    1:   const XML_Char *m_doctypeName;
    1:   const XML_Char *m_doctypeSysid;
    1:   const XML_Char *m_doctypePubid;
    1:   const XML_Char *m_declAttributeType;
    1:   const XML_Char *m_declNotationName;
    1:   const XML_Char *m_declNotationPublicId;
    1:   ELEMENT_TYPE *m_declElementType;
    1:   ATTRIBUTE_ID *m_declAttributeId;
    1:   XML_Bool m_declAttributeIsCdata;
    1:   XML_Bool m_declAttributeIsId;
    1:   DTD *m_dtd;
    1:   const XML_Char *m_curBase;
    1:   TAG *m_tagStack;
    1:   TAG *m_freeTagList;
    1:   BINDING *m_inheritedBindings;
    1:   BINDING *m_freeBindingList;
    1:   int m_attsSize;
    1:   int m_nSpecifiedAtts;
    1:   int m_idAttIndex;
    1:   ATTRIBUTE *m_atts;
    1:   NS_ATT *m_nsAtts;
    1:   unsigned long m_nsAttsVersion;
    1:   unsigned char m_nsAttsPower;
    1:   POSITION m_position;
    1:   STRING_POOL m_tempPool;
    1:   STRING_POOL m_temp2Pool;
    1:   char *m_groupConnector;
    1:   unsigned int m_groupSize;
    1:   XML_Char m_namespaceSeparator;
    1:   XML_Parser m_parentParser;
    1:   XML_ParsingStatus m_parsingStatus;
    1: #ifdef XML_DTD
    1:   XML_Bool m_isParamEntity;
    1:   XML_Bool m_useForeignDTD;
    1:   enum XML_ParamEntityParsing m_paramEntityParsing;
    1: #endif
    1: /* BEGIN MOZILLA CHANGE (Report opening tag of mismatched closing tag) */
    1:   const XML_Char* m_mismatch;
    1: /* END MOZILLA CHANGE */
    1: };
    1: 
    1: #define MALLOC(s) (parser->m_mem.malloc_fcn((s)))
    1: #define REALLOC(p,s) (parser->m_mem.realloc_fcn((p),(s)))
    1: #define FREE(p) (parser->m_mem.free_fcn((p)))
    1: 
    1: #define userData (parser->m_userData)
    1: #define handlerArg (parser->m_handlerArg)
    1: #define startElementHandler (parser->m_startElementHandler)
    1: #define endElementHandler (parser->m_endElementHandler)
    1: #define characterDataHandler (parser->m_characterDataHandler)
    1: #define processingInstructionHandler \
    1:         (parser->m_processingInstructionHandler)
    1: #define commentHandler (parser->m_commentHandler)
    1: #define startCdataSectionHandler \
    1:         (parser->m_startCdataSectionHandler)
    1: #define endCdataSectionHandler (parser->m_endCdataSectionHandler)
    1: #define defaultHandler (parser->m_defaultHandler)
    1: #define startDoctypeDeclHandler (parser->m_startDoctypeDeclHandler)
    1: #define endDoctypeDeclHandler (parser->m_endDoctypeDeclHandler)
    1: #define unparsedEntityDeclHandler \
    1:         (parser->m_unparsedEntityDeclHandler)
    1: #define notationDeclHandler (parser->m_notationDeclHandler)
    1: #define startNamespaceDeclHandler \
    1:         (parser->m_startNamespaceDeclHandler)
    1: #define endNamespaceDeclHandler (parser->m_endNamespaceDeclHandler)
    1: #define notStandaloneHandler (parser->m_notStandaloneHandler)
    1: #define externalEntityRefHandler \
    1:         (parser->m_externalEntityRefHandler)
    1: #define externalEntityRefHandlerArg \
    1:         (parser->m_externalEntityRefHandlerArg)
    1: #define internalEntityRefHandler \
    1:         (parser->m_internalEntityRefHandler)
    1: #define skippedEntityHandler (parser->m_skippedEntityHandler)
    1: #define unknownEncodingHandler (parser->m_unknownEncodingHandler)
    1: #define elementDeclHandler (parser->m_elementDeclHandler)
    1: #define attlistDeclHandler (parser->m_attlistDeclHandler)
    1: #define entityDeclHandler (parser->m_entityDeclHandler)
    1: #define xmlDeclHandler (parser->m_xmlDeclHandler)
    1: #define encoding (parser->m_encoding)
    1: #define initEncoding (parser->m_initEncoding)
    1: #define internalEncoding (parser->m_internalEncoding)
    1: #define unknownEncodingMem (parser->m_unknownEncodingMem)
    1: #define unknownEncodingData (parser->m_unknownEncodingData)
    1: #define unknownEncodingHandlerData \
    1:   (parser->m_unknownEncodingHandlerData)
    1: #define unknownEncodingRelease (parser->m_unknownEncodingRelease)
    1: #define protocolEncodingName (parser->m_protocolEncodingName)
    1: #define ns (parser->m_ns)
    1: #define ns_triplets (parser->m_ns_triplets)
    1: #define prologState (parser->m_prologState)
    1: #define processor (parser->m_processor)
    1: #define errorCode (parser->m_errorCode)
    1: #define eventPtr (parser->m_eventPtr)
    1: #define eventEndPtr (parser->m_eventEndPtr)
    1: #define positionPtr (parser->m_positionPtr)
    1: #define position (parser->m_position)
    1: #define openInternalEntities (parser->m_openInternalEntities)
    1: #define freeInternalEntities (parser->m_freeInternalEntities)
    1: #define defaultExpandInternalEntities \
    1:         (parser->m_defaultExpandInternalEntities)
    1: #define tagLevel (parser->m_tagLevel)
    1: #define buffer (parser->m_buffer)
    1: #define bufferPtr (parser->m_bufferPtr)
    1: #define bufferEnd (parser->m_bufferEnd)
    1: #define parseEndByteIndex (parser->m_parseEndByteIndex)
    1: #define parseEndPtr (parser->m_parseEndPtr)
    1: #define bufferLim (parser->m_bufferLim)
    1: #define dataBuf (parser->m_dataBuf)
    1: #define dataBufEnd (parser->m_dataBufEnd)
    1: #define _dtd (parser->m_dtd)
    1: #define curBase (parser->m_curBase)
    1: #define declEntity (parser->m_declEntity)
    1: #define doctypeName (parser->m_doctypeName)
    1: #define doctypeSysid (parser->m_doctypeSysid)
    1: #define doctypePubid (parser->m_doctypePubid)
    1: #define declAttributeType (parser->m_declAttributeType)
    1: #define declNotationName (parser->m_declNotationName)
    1: #define declNotationPublicId (parser->m_declNotationPublicId)
    1: #define declElementType (parser->m_declElementType)
    1: #define declAttributeId (parser->m_declAttributeId)
    1: #define declAttributeIsCdata (parser->m_declAttributeIsCdata)
    1: #define declAttributeIsId (parser->m_declAttributeIsId)
    1: #define freeTagList (parser->m_freeTagList)
    1: #define freeBindingList (parser->m_freeBindingList)
    1: #define inheritedBindings (parser->m_inheritedBindings)
    1: #define tagStack (parser->m_tagStack)
    1: #define atts (parser->m_atts)
    1: #define attsSize (parser->m_attsSize)
    1: #define nSpecifiedAtts (parser->m_nSpecifiedAtts)
    1: #define idAttIndex (parser->m_idAttIndex)
    1: #define nsAtts (parser->m_nsAtts)
    1: #define nsAttsVersion (parser->m_nsAttsVersion)
    1: #define nsAttsPower (parser->m_nsAttsPower)
    1: #define tempPool (parser->m_tempPool)
    1: #define temp2Pool (parser->m_temp2Pool)
    1: #define groupConnector (parser->m_groupConnector)
    1: #define groupSize (parser->m_groupSize)
    1: #define namespaceSeparator (parser->m_namespaceSeparator)
    1: #define parentParser (parser->m_parentParser)
    1: #define ps_parsing (parser->m_parsingStatus.parsing)
    1: #define ps_finalBuffer (parser->m_parsingStatus.finalBuffer)
    1: #ifdef XML_DTD
    1: #define isParamEntity (parser->m_isParamEntity)
    1: #define useForeignDTD (parser->m_useForeignDTD)
    1: #define paramEntityParsing (parser->m_paramEntityParsing)
    1: #endif /* XML_DTD */
    1: /* BEGIN MOZILLA CHANGE (Report opening tag of mismatched closing tag) */
    1: #define mismatch (parser->m_mismatch)
    1: /* END MOZILLA CHANGE */
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #ifdef TX_EXE
    1: XML_Parser XMLCALL
    1: XML_ParserCreate(const XML_Char *encodingName)
    1: {
    1:   return XML_ParserCreate_MM(encodingName, NULL, NULL);
    1: }
    1: #endif
    1: 
    1: #if 0
    1: XML_Parser XMLCALL
    1: XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
    1: {
    1:   XML_Char tmp[2];
    1:   *tmp = nsSep;
    1:   return XML_ParserCreate_MM(encodingName, NULL, tmp);
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: static const XML_Char implicitContext[] = {
    1:   'x', 'm', 'l', '=', 'h', 't', 't', 'p', ':', '/', '/',
    1:   'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/',
    1:   'X', 'M', 'L', '/', '1', '9', '9', '8', '/',
    1:   'n', 'a', 'm', 'e', 's', 'p', 'a', 'c', 'e', '\0'
    1: };
    1: 
    1: XML_Parser XMLCALL
    1: XML_ParserCreate_MM(const XML_Char *encodingName,
    1:                     const XML_Memory_Handling_Suite *memsuite,
    1:                     const XML_Char *nameSep)
    1: {
    1:   XML_Parser parser = parserCreate(encodingName, memsuite, nameSep, NULL);
    1:   if (parser != NULL && ns) {
    1:     /* implicit context only set for root parser, since child
    1:        parsers (i.e. external entity parsers) will inherit it
    1:     */
    1:     if (!setContext(parser, implicitContext)) {
    1:       XML_ParserFree(parser);
    1:       return NULL;
    1:     }
    1:   }
    1:   return parser;
    1: }
    1: 
    1: static XML_Parser
    1: parserCreate(const XML_Char *encodingName,
    1:              const XML_Memory_Handling_Suite *memsuite,
    1:              const XML_Char *nameSep,
    1:              DTD *dtd)
    1: {
    1:   XML_Parser parser;
    1: 
    1:   if (memsuite) {
    1:     XML_Memory_Handling_Suite *mtemp;
    1:     parser = (XML_Parser)
    1:       memsuite->malloc_fcn(sizeof(struct XML_ParserStruct));
    1:     if (parser != NULL) {
    1:       mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);
    1:       mtemp->malloc_fcn = memsuite->malloc_fcn;
    1:       mtemp->realloc_fcn = memsuite->realloc_fcn;
    1:       mtemp->free_fcn = memsuite->free_fcn;
    1:     }
    1:   }
    1:   else {
    1:     XML_Memory_Handling_Suite *mtemp;
    1:     parser = (XML_Parser)malloc(sizeof(struct XML_ParserStruct));
    1:     if (parser != NULL) {
    1:       mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);
    1:       mtemp->malloc_fcn = malloc;
    1:       mtemp->realloc_fcn = realloc;
    1:       mtemp->free_fcn = free;
    1:     }
    1:   }
    1: 
    1:   if (!parser)
    1:     return parser;
    1: 
    1:   buffer = NULL;
    1:   bufferLim = NULL;
    1: 
    1:   attsSize = INIT_ATTS_SIZE;
    1:   atts = (ATTRIBUTE *)MALLOC(attsSize * sizeof(ATTRIBUTE));
    1:   if (atts == NULL) {
    1:     FREE(parser);
    1:     return NULL;
    1:   }
    1:   dataBuf = (XML_Char *)MALLOC(INIT_DATA_BUF_SIZE * sizeof(XML_Char));
    1:   if (dataBuf == NULL) {
    1:     FREE(atts);
    1:     FREE(parser);
    1:     return NULL;
    1:   }
    1:   dataBufEnd = dataBuf + INIT_DATA_BUF_SIZE;
    1: 
    1:   if (dtd)
    1:     _dtd = dtd;
    1:   else {
    1:     _dtd = dtdCreate(&parser->m_mem);
    1:     if (_dtd == NULL) {
    1:       FREE(dataBuf);
    1:       FREE(atts);
    1:       FREE(parser);
    1:       return NULL;
    1:     }
    1:   }
    1: 
    1:   freeBindingList = NULL;
    1:   freeTagList = NULL;
    1:   freeInternalEntities = NULL;
    1: 
    1:   groupSize = 0;
    1:   groupConnector = NULL;
    1: 
    1:   unknownEncodingHandler = NULL;
    1:   unknownEncodingHandlerData = NULL;
    1: 
    1:   namespaceSeparator = '!';
    1:   ns = XML_FALSE;
    1:   ns_triplets = XML_FALSE;
    1: 
    1:   nsAtts = NULL;
    1:   nsAttsVersion = 0;
    1:   nsAttsPower = 0;
    1: 
    1:   poolInit(&tempPool, &(parser->m_mem));
    1:   poolInit(&temp2Pool, &(parser->m_mem));
    1:   parserInit(parser, encodingName);
    1: 
    1:   if (encodingName && !protocolEncodingName) {
    1:     XML_ParserFree(parser);
    1:     return NULL;
    1:   }
    1: 
    1:   if (nameSep) {
    1:     ns = XML_TRUE;
    1:     internalEncoding = XmlGetInternalEncodingNS();
    1:     namespaceSeparator = *nameSep;
    1:   }
    1:   else {
    1:     internalEncoding = XmlGetInternalEncoding();
    1:   }
    1: 
    1: /* BEGIN MOZILLA CHANGE (Report opening tag of mismatched closing tag) */
    1:   mismatch = NULL;
    1: /* END MOZILLA CHANGE */
    1: 
    1:   return parser;
    1: }
    1: 
    1: static void
    1: parserInit(XML_Parser parser, const XML_Char *encodingName)
    1: {
    1:   processor = prologInitProcessor;
    1:   XmlPrologStateInit(&prologState);
    1:   protocolEncodingName = (encodingName != NULL
    1:                           ? poolCopyString(&tempPool, encodingName)
    1:                           : NULL);
    1:   curBase = NULL;
    1:   XmlInitEncoding(&initEncoding, &encoding, 0);
    1:   userData = NULL;
    1:   handlerArg = NULL;
    1:   startElementHandler = NULL;
    1:   endElementHandler = NULL;
    1:   characterDataHandler = NULL;
    1:   processingInstructionHandler = NULL;
    1:   commentHandler = NULL;
    1:   startCdataSectionHandler = NULL;
    1:   endCdataSectionHandler = NULL;
    1:   defaultHandler = NULL;
    1:   startDoctypeDeclHandler = NULL;
    1:   endDoctypeDeclHandler = NULL;
    1:   unparsedEntityDeclHandler = NULL;
    1:   notationDeclHandler = NULL;
    1:   startNamespaceDeclHandler = NULL;
    1:   endNamespaceDeclHandler = NULL;
    1:   notStandaloneHandler = NULL;
    1:   externalEntityRefHandler = NULL;
    1:   externalEntityRefHandlerArg = parser;
    1:   skippedEntityHandler = NULL;
    1:   elementDeclHandler = NULL;
    1:   attlistDeclHandler = NULL;
    1:   entityDeclHandler = NULL;
    1:   xmlDeclHandler = NULL;
    1:   bufferPtr = buffer;
    1:   bufferEnd = buffer;
    1:   parseEndByteIndex = 0;
    1:   parseEndPtr = NULL;
    1:   declElementType = NULL;
    1:   declAttributeId = NULL;
    1:   declEntity = NULL;
    1:   doctypeName = NULL;
    1:   doctypeSysid = NULL;
    1:   doctypePubid = NULL;
    1:   declAttributeType = NULL;
    1:   declNotationName = NULL;
    1:   declNotationPublicId = NULL;
    1:   declAttributeIsCdata = XML_FALSE;
    1:   declAttributeIsId = XML_FALSE;
    1:   memset(&position, 0, sizeof(POSITION));
    1:   errorCode = XML_ERROR_NONE;
    1:   eventPtr = NULL;
    1:   eventEndPtr = NULL;
    1:   positionPtr = NULL;
    1:   openInternalEntities = NULL;
    1:   defaultExpandInternalEntities = XML_TRUE;
    1:   tagLevel = 0;
    1:   tagStack = NULL;
    1:   inheritedBindings = NULL;
    1:   nSpecifiedAtts = 0;
    1:   unknownEncodingMem = NULL;
    1:   unknownEncodingRelease = NULL;
    1:   unknownEncodingData = NULL;
    1:   parentParser = NULL;
    1:   ps_parsing = XML_INITIALIZED;
    1: #ifdef XML_DTD
    1:   isParamEntity = XML_FALSE;
    1:   useForeignDTD = XML_FALSE;
    1:   paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
    1: #endif
    1: }
    1: 
    1: /* moves list of bindings to freeBindingList */
    1: static void FASTCALL
    1: moveToFreeBindingList(XML_Parser parser, BINDING *bindings)
    1: {
    1:   while (bindings) {
    1:     BINDING *b = bindings;
    1:     bindings = bindings->nextTagBinding;
    1:     b->nextTagBinding = freeBindingList;
    1:     freeBindingList = b;
    1:   }
    1: }
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #if 0
    1: XML_Bool XMLCALL
    1: XML_ParserReset(XML_Parser parser, const XML_Char *encodingName)
    1: {
    1:   TAG *tStk;
    1:   OPEN_INTERNAL_ENTITY *openEntityList;
    1:   if (parentParser)
    1:     return XML_FALSE;
    1:   /* move tagStack to freeTagList */
    1:   tStk = tagStack;
    1:   while (tStk) {
    1:     TAG *tag = tStk;
    1:     tStk = tStk->parent;
    1:     tag->parent = freeTagList;
    1:     moveToFreeBindingList(parser, tag->bindings);
    1:     tag->bindings = NULL;
    1:     freeTagList = tag;
    1:   }
    1:   /* move openInternalEntities to freeInternalEntities */
    1:   openEntityList = openInternalEntities;
    1:   while (openEntityList) {
    1:     OPEN_INTERNAL_ENTITY *openEntity = openEntityList;
    1:     openEntityList = openEntity->next;
    1:     openEntity->next = freeInternalEntities;
    1:     freeInternalEntities = openEntity;
    1:   }
    1:   moveToFreeBindingList(parser, inheritedBindings);
    1:   FREE(unknownEncodingMem);
    1:   if (unknownEncodingRelease)
    1:     unknownEncodingRelease(unknownEncodingData);
    1:   poolClear(&tempPool);
    1:   poolClear(&temp2Pool);
    1:   parserInit(parser, encodingName);
    1:   dtdReset(_dtd, &parser->m_mem);
    1:   return setContext(parser, implicitContext);
    1: }
    1: 
    1: enum XML_Status XMLCALL
    1: XML_SetEncoding(XML_Parser parser, const XML_Char *encodingName)
    1: {
    1:   /* Block after XML_Parse()/XML_ParseBuffer() has been called.
    1:      XXX There's no way for the caller to determine which of the
    1:      XXX possible error cases caused the XML_STATUS_ERROR return.
    1:   */
    1:   if (ps_parsing == XML_PARSING || ps_parsing == XML_SUSPENDED)
    1:     return XML_STATUS_ERROR;
    1:   if (encodingName == NULL)
    1:     protocolEncodingName = NULL;
    1:   else {
    1:     protocolEncodingName = poolCopyString(&tempPool, encodingName);
    1:     if (!protocolEncodingName)
    1:       return XML_STATUS_ERROR;
    1:   }
    1:   return XML_STATUS_OK;
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: XML_Parser XMLCALL
    1: XML_ExternalEntityParserCreate(XML_Parser oldParser,
    1:                                const XML_Char *context,
    1:                                const XML_Char *encodingName)
    1: {
    1:   XML_Parser parser = oldParser;
    1:   DTD *newDtd = NULL;
    1:   DTD *oldDtd = _dtd;
    1:   XML_StartElementHandler oldStartElementHandler = startElementHandler;
    1:   XML_EndElementHandler oldEndElementHandler = endElementHandler;
    1:   XML_CharacterDataHandler oldCharacterDataHandler = characterDataHandler;
    1:   XML_ProcessingInstructionHandler oldProcessingInstructionHandler
    1:       = processingInstructionHandler;
    1:   XML_CommentHandler oldCommentHandler = commentHandler;
    1:   XML_StartCdataSectionHandler oldStartCdataSectionHandler
    1:       = startCdataSectionHandler;
    1:   XML_EndCdataSectionHandler oldEndCdataSectionHandler
    1:       = endCdataSectionHandler;
    1:   XML_DefaultHandler oldDefaultHandler = defaultHandler;
    1:   XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler
    1:       = unparsedEntityDeclHandler;
    1:   XML_NotationDeclHandler oldNotationDeclHandler = notationDeclHandler;
    1:   XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler
    1:       = startNamespaceDeclHandler;
    1:   XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler
    1:       = endNamespaceDeclHandler;
    1:   XML_NotStandaloneHandler oldNotStandaloneHandler = notStandaloneHandler;
    1:   XML_ExternalEntityRefHandler oldExternalEntityRefHandler
    1:       = externalEntityRefHandler;
    1:   XML_SkippedEntityHandler oldSkippedEntityHandler = skippedEntityHandler;
    1:   XML_UnknownEncodingHandler oldUnknownEncodingHandler
    1:       = unknownEncodingHandler;
    1:   XML_ElementDeclHandler oldElementDeclHandler = elementDeclHandler;
    1:   XML_AttlistDeclHandler oldAttlistDeclHandler = attlistDeclHandler;
    1:   XML_EntityDeclHandler oldEntityDeclHandler = entityDeclHandler;
    1:   XML_XmlDeclHandler oldXmlDeclHandler = xmlDeclHandler;
    1:   ELEMENT_TYPE * oldDeclElementType = declElementType;
    1: 
    1:   void *oldUserData = userData;
    1:   void *oldHandlerArg = handlerArg;
    1:   XML_Bool oldDefaultExpandInternalEntities = defaultExpandInternalEntities;
    1:   XML_Parser oldExternalEntityRefHandlerArg = externalEntityRefHandlerArg;
    1: #ifdef XML_DTD
    1:   enum XML_ParamEntityParsing oldParamEntityParsing = paramEntityParsing;
    1:   int oldInEntityValue = prologState.inEntityValue;
    1: #endif
    1:   XML_Bool oldns_triplets = ns_triplets;
    1: 
    1: #ifdef XML_DTD
    1:   if (!context)
    1:     newDtd = oldDtd;
    1: #endif /* XML_DTD */
    1: 
    1:   /* Note that the magical uses of the pre-processor to make field
    1:      access look more like C++ require that `parser' be overwritten
    1:      here.  This makes this function more painful to follow than it
    1:      would be otherwise.
    1:   */
    1:   if (ns) {
    1:     XML_Char tmp[2];
    1:     *tmp = namespaceSeparator;
    1:     parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);
    1:   }
    1:   else {
    1:     parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);
    1:   }
    1: 
    1:   if (!parser)
    1:     return NULL;
    1: 
    1:   startElementHandler = oldStartElementHandler;
    1:   endElementHandler = oldEndElementHandler;
    1:   characterDataHandler = oldCharacterDataHandler;
    1:   processingInstructionHandler = oldProcessingInstructionHandler;
    1:   commentHandler = oldCommentHandler;
    1:   startCdataSectionHandler = oldStartCdataSectionHandler;
    1:   endCdataSectionHandler = oldEndCdataSectionHandler;
    1:   defaultHandler = oldDefaultHandler;
    1:   unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;
    1:   notationDeclHandler = oldNotationDeclHandler;
    1:   startNamespaceDeclHandler = oldStartNamespaceDeclHandler;
    1:   endNamespaceDeclHandler = oldEndNamespaceDeclHandler;
    1:   notStandaloneHandler = oldNotStandaloneHandler;
    1:   externalEntityRefHandler = oldExternalEntityRefHandler;
    1:   skippedEntityHandler = oldSkippedEntityHandler;
    1:   unknownEncodingHandler = oldUnknownEncodingHandler;
    1:   elementDeclHandler = oldElementDeclHandler;
    1:   attlistDeclHandler = oldAttlistDeclHandler;
    1:   entityDeclHandler = oldEntityDeclHandler;
    1:   xmlDeclHandler = oldXmlDeclHandler;
    1:   declElementType = oldDeclElementType;
    1:   userData = oldUserData;
    1:   if (oldUserData == oldHandlerArg)
    1:     handlerArg = userData;
    1:   else
    1:     handlerArg = parser;
    1:   if (oldExternalEntityRefHandlerArg != oldParser)
    1:     externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;
    1:   defaultExpandInternalEntities = oldDefaultExpandInternalEntities;
    1:   ns_triplets = oldns_triplets;
    1:   parentParser = oldParser;
    1: #ifdef XML_DTD
    1:   paramEntityParsing = oldParamEntityParsing;
    1:   prologState.inEntityValue = oldInEntityValue;
    1:   if (context) {
    1: #endif /* XML_DTD */
    1:     if (!dtdCopy(_dtd, oldDtd, &parser->m_mem)
    1:       || !setContext(parser, context)) {
    1:       XML_ParserFree(parser);
    1:       return NULL;
    1:     }
    1:     processor = externalEntityInitProcessor;
    1: #ifdef XML_DTD
    1:   }
    1:   else {
    1:     /* The DTD instance referenced by _dtd is shared between the document's
    1:        root parser and external PE parsers, therefore one does not need to
    1:        call setContext. In addition, one also *must* not call setContext,
    1:        because this would overwrite existing prefix->binding pointers in
    1:        _dtd with ones that get destroyed with the external PE parser.
    1:        This would leave those prefixes with dangling pointers.
    1:     */
    1:     isParamEntity = XML_TRUE;
    1:     XmlPrologStateInitExternalEntity(&prologState);
    1:     processor = externalParEntInitProcessor;
    1:   }
    1: #endif /* XML_DTD */
    1:   return parser;
    1: }
    1: 
    1: static void FASTCALL
    1: destroyBindings(BINDING *bindings, XML_Parser parser)
    1: {
    1:   for (;;) {
    1:     BINDING *b = bindings;
    1:     if (!b)
    1:       break;
    1:     bindings = b->nextTagBinding;
    1:     FREE(b->uri);
    1:     FREE(b);
    1:   }
    1: }
    1: 
    1: void XMLCALL
    1: XML_ParserFree(XML_Parser parser)
    1: {
    1:   TAG *tagList;
    1:   OPEN_INTERNAL_ENTITY *entityList;
    1:   if (parser == NULL)
    1:     return;
    1:   /* free tagStack and freeTagList */
    1:   tagList = tagStack;
    1:   for (;;) {
    1:     TAG *p;
    1:     if (tagList == NULL) {
    1:       if (freeTagList == NULL)
    1:         break;
    1:       tagList = freeTagList;
    1:       freeTagList = NULL;
    1:     }
    1:     p = tagList;
    1:     tagList = tagList->parent;
    1:     FREE(p->buf);
    1:     destroyBindings(p->bindings, parser);
    1:     FREE(p);
    1:   }
    1:   /* free openInternalEntities and freeInternalEntities */
    1:   entityList = openInternalEntities;
    1:   for (;;) {
    1:     OPEN_INTERNAL_ENTITY *openEntity;
    1:     if (entityList == NULL) {
    1:       if (freeInternalEntities == NULL)
    1:         break;
    1:       entityList = freeInternalEntities;
    1:       freeInternalEntities = NULL;
    1:     }
    1:     openEntity = entityList;
    1:     entityList = entityList->next;
    1:     FREE(openEntity);
    1:   }
    1: 
    1:   destroyBindings(freeBindingList, parser);
    1:   destroyBindings(inheritedBindings, parser);
    1:   poolDestroy(&tempPool);
    1:   poolDestroy(&temp2Pool);
    1: #ifdef XML_DTD
    1:   /* external parameter entity parsers share the DTD structure
    1:      parser->m_dtd with the root parser, so we must not destroy it
    1:   */
    1:   if (!isParamEntity && _dtd)
    1: #else
    1:   if (_dtd)
    1: #endif /* XML_DTD */
    1:     dtdDestroy(_dtd, (XML_Bool)!parentParser, &parser->m_mem);
    1:   FREE((void *)atts);
    1:   FREE(groupConnector);
    1:   FREE(buffer);
    1:   FREE(dataBuf);
    1:   FREE(nsAtts);
    1:   FREE(unknownEncodingMem);
    1:   if (unknownEncodingRelease)
    1:     unknownEncodingRelease(unknownEncodingData);
    1:   FREE(parser);
    1: }
    1: 
    1: void XMLCALL
    1: XML_UseParserAsHandlerArg(XML_Parser parser)
    1: {
    1:   handlerArg = parser;
    1: }
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #if 0
    1: enum XML_Error XMLCALL
    1: XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD)
    1: {
    1: #ifdef XML_DTD
    1:   /* block after XML_Parse()/XML_ParseBuffer() has been called */
    1:   if (ps_parsing == XML_PARSING || ps_parsing == XML_SUSPENDED)
    1:     return XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING;
    1:   useForeignDTD = useDTD;
    1:   return XML_ERROR_NONE;
    1: #else
    1:   return XML_ERROR_FEATURE_REQUIRES_XML_DTD;
    1: #endif
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: void XMLCALL
    1: XML_SetReturnNSTriplet(XML_Parser parser, int do_nst)
    1: {
    1:   /* block after XML_Parse()/XML_ParseBuffer() has been called */
    1:   if (ps_parsing == XML_PARSING || ps_parsing == XML_SUSPENDED)
    1:     return;
    1:   ns_triplets = do_nst ? XML_TRUE : XML_FALSE;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetUserData(XML_Parser parser, void *p)
    1: {
    1:   if (handlerArg == userData)
    1:     handlerArg = userData = p;
    1:   else
    1:     userData = p;
    1: }
    1: 
    1: enum XML_Status XMLCALL
    1: XML_SetBase(XML_Parser parser, const XML_Char *p)
    1: {
    1:   if (p) {
    1:     p = poolCopyString(&_dtd->pool, p);
    1:     if (!p)
    1:       return XML_STATUS_ERROR;
    1:     curBase = p;
    1:   }
    1:   else
    1:     curBase = NULL;
    1:   return XML_STATUS_OK;
    1: }
    1: 
    1: const XML_Char * XMLCALL
    1: XML_GetBase(XML_Parser parser)
    1: {
    1:   return curBase;
    1: }
    1: 
    1: int XMLCALL
    1: XML_GetSpecifiedAttributeCount(XML_Parser parser)
    1: {
    1:   return nSpecifiedAtts;
    1: }
    1: 
    1: int XMLCALL
    1: XML_GetIdAttributeIndex(XML_Parser parser)
    1: {
    1:   return idAttIndex;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetElementHandler(XML_Parser parser,
    1:                       XML_StartElementHandler start,
    1:                       XML_EndElementHandler end)
    1: {
    1:   startElementHandler = start;
    1:   endElementHandler = end;
    1: }
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #if 0
    1: void XMLCALL
    1: XML_SetStartElementHandler(XML_Parser parser,
    1:                            XML_StartElementHandler start) {
    1:   startElementHandler = start;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetEndElementHandler(XML_Parser parser,
    1:                          XML_EndElementHandler end) {
    1:   endElementHandler = end;
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: void XMLCALL
    1: XML_SetCharacterDataHandler(XML_Parser parser,
    1:                             XML_CharacterDataHandler handler)
    1: {
    1:   characterDataHandler = handler;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetProcessingInstructionHandler(XML_Parser parser,
    1:                                     XML_ProcessingInstructionHandler handler)
    1: {
    1:   processingInstructionHandler = handler;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetCommentHandler(XML_Parser parser,
    1:                       XML_CommentHandler handler)
    1: {
    1:   commentHandler = handler;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetCdataSectionHandler(XML_Parser parser,
    1:                            XML_StartCdataSectionHandler start,
    1:                            XML_EndCdataSectionHandler end)
    1: {
    1:   startCdataSectionHandler = start;
    1:   endCdataSectionHandler = end;
    1: }
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #if 0
    1: void XMLCALL
    1: XML_SetStartCdataSectionHandler(XML_Parser parser,
    1:                                 XML_StartCdataSectionHandler start) {
    1:   startCdataSectionHandler = start;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetEndCdataSectionHandler(XML_Parser parser,
    1:                               XML_EndCdataSectionHandler end) {
    1:   endCdataSectionHandler = end;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetDefaultHandler(XML_Parser parser,
    1:                       XML_DefaultHandler handler)
    1: {
    1:   defaultHandler = handler;
    1:   defaultExpandInternalEntities = XML_FALSE;
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: void XMLCALL
    1: XML_SetDefaultHandlerExpand(XML_Parser parser,
    1:                             XML_DefaultHandler handler)
    1: {
    1:   defaultHandler = handler;
    1:   defaultExpandInternalEntities = XML_TRUE;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetDoctypeDeclHandler(XML_Parser parser,
    1:                           XML_StartDoctypeDeclHandler start,
    1:                           XML_EndDoctypeDeclHandler end)
    1: {
    1:   startDoctypeDeclHandler = start;
    1:   endDoctypeDeclHandler = end;
    1: }
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #if 0
    1: void XMLCALL
    1: XML_SetStartDoctypeDeclHandler(XML_Parser parser,
    1:                                XML_StartDoctypeDeclHandler start) {
    1:   startDoctypeDeclHandler = start;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetEndDoctypeDeclHandler(XML_Parser parser,
    1:                              XML_EndDoctypeDeclHandler end) {
    1:   endDoctypeDeclHandler = end;
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: void XMLCALL
    1: XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
    1:                                  XML_UnparsedEntityDeclHandler handler)
    1: {
    1:   unparsedEntityDeclHandler = handler;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetNotationDeclHandler(XML_Parser parser,
    1:                            XML_NotationDeclHandler handler)
    1: {
    1:   notationDeclHandler = handler;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetNamespaceDeclHandler(XML_Parser parser,
    1:                             XML_StartNamespaceDeclHandler start,
    1:                             XML_EndNamespaceDeclHandler end)
    1: {
    1:   startNamespaceDeclHandler = start;
    1:   endNamespaceDeclHandler = end;
    1: }
    1: 
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #if 0
    1: void XMLCALL
    1: XML_SetStartNamespaceDeclHandler(XML_Parser parser,
    1:                                  XML_StartNamespaceDeclHandler start) {
    1:   startNamespaceDeclHandler = start;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetEndNamespaceDeclHandler(XML_Parser parser,
    1:                                XML_EndNamespaceDeclHandler end) {
    1:   endNamespaceDeclHandler = end;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetNotStandaloneHandler(XML_Parser parser,
    1:                             XML_NotStandaloneHandler handler)
    1: {
    1:   notStandaloneHandler = handler;
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: void XMLCALL
    1: XML_SetExternalEntityRefHandler(XML_Parser parser,
    1:                                 XML_ExternalEntityRefHandler handler)
    1: {
    1:   externalEntityRefHandler = handler;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg)
    1: {
    1:   if (arg)
    1:     externalEntityRefHandlerArg = (XML_Parser)arg;
    1:   else
    1:     externalEntityRefHandlerArg = parser;
    1: }
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #if 0
    1: void XMLCALL
    1: XML_SetSkippedEntityHandler(XML_Parser parser,
    1:                             XML_SkippedEntityHandler handler)
    1: {
    1:   skippedEntityHandler = handler;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetUnknownEncodingHandler(XML_Parser parser,
    1:                               XML_UnknownEncodingHandler handler,
    1:                               void *data)
    1: {
    1:   unknownEncodingHandler = handler;
    1:   unknownEncodingHandlerData = data;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetElementDeclHandler(XML_Parser parser,
    1:                           XML_ElementDeclHandler eldecl)
    1: {
    1:   elementDeclHandler = eldecl;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetAttlistDeclHandler(XML_Parser parser,
    1:                           XML_AttlistDeclHandler attdecl)
    1: {
    1:   attlistDeclHandler = attdecl;
    1: }
    1: 
    1: void XMLCALL
    1: XML_SetEntityDeclHandler(XML_Parser parser,
    1:                          XML_EntityDeclHandler handler)
    1: {
    1:   entityDeclHandler = handler;
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: void XMLCALL
    1: XML_SetXmlDeclHandler(XML_Parser parser,
    1:                       XML_XmlDeclHandler handler) {
    1:   xmlDeclHandler = handler;
    1: }
    1: 
    1: int XMLCALL
    1: XML_SetParamEntityParsing(XML_Parser parser,
    1:                           enum XML_ParamEntityParsing peParsing)
    1: {
    1:   /* block after XML_Parse()/XML_ParseBuffer() has been called */
    1:   if (ps_parsing == XML_PARSING || ps_parsing == XML_SUSPENDED)
    1:     return 0;
    1: #ifdef XML_DTD
    1:   paramEntityParsing = peParsing;
    1:   return 1;
    1: #else
    1:   return peParsing == XML_PARAM_ENTITY_PARSING_NEVER;
    1: #endif
    1: }
    1: 
    1: enum XML_Status XMLCALL
    1: XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)
    1: {
    1:   switch (ps_parsing) {
    1:   case XML_SUSPENDED:
    1:     errorCode = XML_ERROR_SUSPENDED;
    1:     return XML_STATUS_ERROR;
    1:   case XML_FINISHED:
    1:     errorCode = XML_ERROR_FINISHED;
    1:     return XML_STATUS_ERROR;
    1:   default:
    1:     ps_parsing = XML_PARSING;
    1:   }
    1: 
    1:   if (len == 0) {
    1:     ps_finalBuffer = (XML_Bool)isFinal;
    1:     if (!isFinal)
    1:       return XML_STATUS_OK;
    1:     positionPtr = bufferPtr;
    1:     parseEndPtr = bufferEnd;
    1: 
    1:     /* If data are left over from last buffer, and we now know that these
    1:        data are the final chunk of input, then we have to check them again
    1:        to detect errors based on that fact.
    1:     */
    1:     errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);
    1: 
    1:     if (errorCode == XML_ERROR_NONE) {
    1:       switch (ps_parsing) {
    1:       case XML_SUSPENDED:
    1:         XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
    1:         positionPtr = bufferPtr;
    1:         return XML_STATUS_SUSPENDED;
    1:       case XML_INITIALIZED: 
    1:       case XML_PARSING:
    1:         ps_parsing = XML_FINISHED;
    1:         /* fall through */
    1:       default:
    1:         return XML_STATUS_OK;
    1:       }
    1:     }
    1:     eventEndPtr = eventPtr;
    1:     processor = errorProcessor;
    1:     return XML_STATUS_ERROR;
    1:   }
    1: #ifndef XML_CONTEXT_BYTES
    1:   else if (bufferPtr == bufferEnd) {
    1:     const char *end;
    1:     int nLeftOver;
    1:     enum XML_Error result;
    1:     parseEndByteIndex += len;
    1:     positionPtr = s;
    1:     ps_finalBuffer = (XML_Bool)isFinal;
    1: 
    1:     errorCode = processor(parser, s, parseEndPtr = s + len, &end);
    1: 
    1:     if (errorCode != XML_ERROR_NONE) {
    1:       eventEndPtr = eventPtr;
    1:       processor = errorProcessor;
    1:       return XML_STATUS_ERROR;
    1:     }
    1:     else {
    1:       switch (ps_parsing) {
    1:       case XML_SUSPENDED:
    1:         result = XML_STATUS_SUSPENDED;
    1:         break;
    1:       case XML_INITIALIZED:
    1:       case XML_PARSING:
64565: /* BEGIN MOZILLA CHANGE (always initialize result) */
64565: #if 0
    1:         result = XML_STATUS_OK;
    1:         if (isFinal) {
    1:           ps_parsing = XML_FINISHED;
    1:           return result;
    1:         }
64565: #else
64565:         if (isFinal) {
64565:           ps_parsing = XML_FINISHED;
64565:           return XML_STATUS_OK;
64565:         }
64565:       /* fall through */
64565:       default:
64565:         result = XML_STATUS_OK;
64565: #endif
64565: /* END MOZILLA CHANGE */
    1:       }
    1:     }
    1: 
    1:     XmlUpdatePosition(encoding, positionPtr, end, &position);
    1:     nLeftOver = s + len - end;
    1:     if (nLeftOver) {
    1:       if (buffer == NULL || nLeftOver > bufferLim - buffer) {
    1:         /* FIXME avoid integer overflow */
    1:         char *temp;
    1:         temp = (buffer == NULL
    1:                 ? (char *)MALLOC(len * 2)
    1:                 : (char *)REALLOC(buffer, len * 2));
    1:         if (temp == NULL) {
    1:           errorCode = XML_ERROR_NO_MEMORY;
    1:           return XML_STATUS_ERROR;
    1:         }
    1:         buffer = temp;
    1:         if (!buffer) {
    1:           errorCode = XML_ERROR_NO_MEMORY;
    1:           eventPtr = eventEndPtr = NULL;
    1:           processor = errorProcessor;
    1:           return XML_STATUS_ERROR;
    1:         }
    1:         bufferLim = buffer + len * 2;
    1:       }
    1:       memcpy(buffer, end, nLeftOver);
    1:     }
    1:     bufferPtr = buffer;
    1:     bufferEnd = buffer + nLeftOver;
    1:     positionPtr = bufferPtr;
    1:     parseEndPtr = bufferEnd;
    1:     eventPtr = bufferPtr;
    1:     eventEndPtr = bufferPtr;
    1:     return result;
    1:   }
    1: #endif  /* not defined XML_CONTEXT_BYTES */
    1:   else {
    1:     void *buff = XML_GetBuffer(parser, len);
    1:     if (buff == NULL)
    1:       return XML_STATUS_ERROR;
    1:     else {
    1:       memcpy(buff, s, len);
    1:       return XML_ParseBuffer(parser, len, isFinal);
    1:     }
    1:   }
    1: }
    1: 
    1: enum XML_Status XMLCALL
    1: XML_ParseBuffer(XML_Parser parser, int len, int isFinal)
    1: {
    1:   const char *start;
    1:   enum XML_Status result = XML_STATUS_OK;
    1: 
    1:   switch (ps_parsing) {
    1:   case XML_SUSPENDED:
    1:     errorCode = XML_ERROR_SUSPENDED;
    1:     return XML_STATUS_ERROR;
    1:   case XML_FINISHED:
    1:     errorCode = XML_ERROR_FINISHED;
    1:     return XML_STATUS_ERROR;
    1:   default:
    1:     ps_parsing = XML_PARSING;
    1:   }
    1: 
    1:   start = bufferPtr;
    1:   positionPtr = start;
    1:   bufferEnd += len;
    1:   parseEndPtr = bufferEnd;
    1:   parseEndByteIndex += len;
    1:   ps_finalBuffer = (XML_Bool)isFinal;
    1: 
    1:   errorCode = processor(parser, start, parseEndPtr, &bufferPtr);
    1: 
    1:   if (errorCode != XML_ERROR_NONE) {
    1:     eventEndPtr = eventPtr;
    1:     processor = errorProcessor;
    1:     return XML_STATUS_ERROR;
    1:   }
    1:   else {
    1:     switch (ps_parsing) {
    1:     case XML_SUSPENDED:
    1:       result = XML_STATUS_SUSPENDED;
    1:       break;
    1:     case XML_INITIALIZED: 
    1:     case XML_PARSING:
    1:       if (isFinal) {
    1:         ps_parsing = XML_FINISHED;
    1:         return result;
    1:       }
    1:     default: ;  /* should not happen */
    1:     }
    1:   }
    1: 
    1:   XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
    1:   positionPtr = bufferPtr;
    1:   return result;
    1: }
    1: 
    1: void * XMLCALL
    1: XML_GetBuffer(XML_Parser parser, int len)
    1: {
    1:   switch (ps_parsing) {
    1:   case XML_SUSPENDED:
    1:     errorCode = XML_ERROR_SUSPENDED;
    1:     return NULL;
    1:   case XML_FINISHED:
    1:     errorCode = XML_ERROR_FINISHED;
    1:     return NULL;
    1:   default: ;
    1:   }
    1: 
    1:   if (len > bufferLim - bufferEnd) {
    1:     /* FIXME avoid integer overflow */
    1:     int neededSize = len + (int)(bufferEnd - bufferPtr);
    1: #ifdef XML_CONTEXT_BYTES
    1:     int keep = (int)(bufferPtr - buffer);
    1: 
    1:     if (keep > XML_CONTEXT_BYTES)
    1:       keep = XML_CONTEXT_BYTES;
    1:     neededSize += keep;
    1: #endif  /* defined XML_CONTEXT_BYTES */
    1:     if (neededSize  <= bufferLim - buffer) {
    1: #ifdef XML_CONTEXT_BYTES
    1:       if (keep < bufferPtr - buffer) {
    1:         int offset = (int)(bufferPtr - buffer) - keep;
    1:         memmove(buffer, &buffer[offset], bufferEnd - bufferPtr + keep);
    1:         bufferEnd -= offset;
    1:         bufferPtr -= offset;
    1:       }
    1: #else
    1:       memmove(buffer, bufferPtr, bufferEnd - bufferPtr);
    1:       bufferEnd = buffer + (bufferEnd - bufferPtr);
    1:       bufferPtr = buffer;
    1: #endif  /* not defined XML_CONTEXT_BYTES */
    1:     }
    1:     else {
    1:       char *newBuf;
    1:       int bufferSize = (int)(bufferLim - bufferPtr);
    1:       if (bufferSize == 0)
    1:         bufferSize = INIT_BUFFER_SIZE;
    1:       do {
    1:         bufferSize *= 2;
    1:       } while (bufferSize < neededSize);
    1:       newBuf = (char *)MALLOC(bufferSize);
    1:       if (newBuf == 0) {
    1:         errorCode = XML_ERROR_NO_MEMORY;
    1:         return NULL;
    1:       }
    1:       bufferLim = newBuf + bufferSize;
    1: #ifdef XML_CONTEXT_BYTES
    1:       if (bufferPtr) {
    1:         int keep = (int)(bufferPtr - buffer);
    1:         if (keep > XML_CONTEXT_BYTES)
    1:           keep = XML_CONTEXT_BYTES;
    1:         memcpy(newBuf, &bufferPtr[-keep], bufferEnd - bufferPtr + keep);
    1:         FREE(buffer);
    1:         buffer = newBuf;
    1:         bufferEnd = buffer + (bufferEnd - bufferPtr) + keep;
    1:         bufferPtr = buffer + keep;
    1:       }
    1:       else {
    1:         bufferEnd = newBuf + (bufferEnd - bufferPtr);
    1:         bufferPtr = buffer = newBuf;
    1:       }
    1: #else
    1:       if (bufferPtr) {
    1:         memcpy(newBuf, bufferPtr, bufferEnd - bufferPtr);
    1:         FREE(buffer);
    1:       }
    1:       bufferEnd = newBuf + (bufferEnd - bufferPtr);
    1:       bufferPtr = buffer = newBuf;
    1: #endif  /* not defined XML_CONTEXT_BYTES */
    1:     }
    1:   }
    1:   return bufferEnd;
    1: }
    1: 
    1: enum XML_Status XMLCALL
    1: XML_StopParser(XML_Parser parser, XML_Bool resumable)
    1: {
    1:   switch (ps_parsing) {
    1:   case XML_SUSPENDED:
    1:     if (resumable) {
    1:       errorCode = XML_ERROR_SUSPENDED;
    1:       return XML_STATUS_ERROR;
    1:     }
    1:     ps_parsing = XML_FINISHED;
    1:     break;
    1:   case XML_FINISHED:
    1:     errorCode = XML_ERROR_FINISHED;
    1:     return XML_STATUS_ERROR;
    1:   default:
    1:     if (resumable) {
    1: #ifdef XML_DTD
    1:       if (isParamEntity) {
    1:         errorCode = XML_ERROR_SUSPEND_PE;
    1:         return XML_STATUS_ERROR;
    1:       }
    1: #endif
    1:       ps_parsing = XML_SUSPENDED;
    1:     }
    1:     else
    1:       ps_parsing = XML_FINISHED;
    1:   }
    1:   return XML_STATUS_OK;
    1: }
    1: 
    1: enum XML_Status XMLCALL
    1: XML_ResumeParser(XML_Parser parser)
    1: {
    1:   enum XML_Status result = XML_STATUS_OK;
    1: 
    1:   if (ps_parsing != XML_SUSPENDED) {
    1:     errorCode = XML_ERROR_NOT_SUSPENDED;
    1:     return XML_STATUS_ERROR;
    1:   }
    1:   ps_parsing = XML_PARSING;
    1: 
    1:   errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);
    1: 
    1:   if (errorCode != XML_ERROR_NONE) {
    1:     eventEndPtr = eventPtr;
    1:     processor = errorProcessor;
    1:     return XML_STATUS_ERROR;
    1:   }
    1:   else {
    1:     switch (ps_parsing) {
    1:     case XML_SUSPENDED:
    1:       result = XML_STATUS_SUSPENDED;
    1:       break;
    1:     case XML_INITIALIZED: 
    1:     case XML_PARSING:
    1:       if (ps_finalBuffer) {
    1:         ps_parsing = XML_FINISHED;
    1:         return result;
    1:       }
    1:     default: ;
    1:     }
    1:   }
    1: 
    1:   XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
    1:   positionPtr = bufferPtr;
    1: /* BEGIN MOZILLA CHANGE (always set eventPtr/eventEndPtr) */
    1:   eventPtr = bufferPtr;
    1:   eventEndPtr = bufferPtr;
    1: /* END MOZILLA CHANGE */
    1:   return result;
    1: }
    1: 
    1: void XMLCALL
    1: XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
    1: {
    1:   assert(status != NULL);
    1:   *status = parser->m_parsingStatus;
    1: }
    1: 
    1: enum XML_Error XMLCALL
    1: XML_GetErrorCode(XML_Parser parser)
    1: {
    1:   return errorCode;
    1: }
    1: 
    1: XML_Index XMLCALL
    1: XML_GetCurrentByteIndex(XML_Parser parser)
    1: {
    1:   if (eventPtr)
    1:     return parseEndByteIndex - (parseEndPtr - eventPtr);
    1: /* BEGIN MOZILLA CHANGE (fix XML_GetCurrentByteIndex) */
    1: #if 0
    1:   return -1;
    1: #else
    1:   return parseEndByteIndex;
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: }
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #if 0
    1: int XMLCALL
    1: XML_GetCurrentByteCount(XML_Parser parser)
    1: {
    1:   if (eventEndPtr && eventPtr)
    1:     return (int)(eventEndPtr - eventPtr);
    1:   return 0;
    1: }
    1: 
    1: const char * XMLCALL
    1: XML_GetInputContext(XML_Parser parser, int *offset, int *size)
    1: {
    1: #ifdef XML_CONTEXT_BYTES
    1:   if (eventPtr && buffer) {
    1:     *offset = (int)(eventPtr - buffer);
    1:     *size   = (int)(bufferEnd - buffer);
    1:     return buffer;
    1:   }
    1: #endif /* defined XML_CONTEXT_BYTES */
    1:   return (char *) 0;
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: XML_Size XMLCALL
    1: XML_GetCurrentLineNumber(XML_Parser parser)
    1: {
    1:   if (eventPtr && eventPtr >= positionPtr) {
    1:     XmlUpdatePosition(encoding, positionPtr, eventPtr, &position);
    1:     positionPtr = eventPtr;
    1:   }
    1:   return position.lineNumber + 1;
    1: }
    1: 
    1: XML_Size XMLCALL
    1: XML_GetCurrentColumnNumber(XML_Parser parser)
    1: {
    1:   if (eventPtr && eventPtr >= positionPtr) {
    1:     XmlUpdatePosition(encoding, positionPtr, eventPtr, &position);
    1:     positionPtr = eventPtr;
    1:   }
    1:   return position.columnNumber;
    1: }
    1: 
    1: /* BEGIN MOZILLA CHANGE (unused API) */
    1: #if 0
    1: void XMLCALL
    1: XML_FreeContentModel(XML_Parser parser, XML_Content *model)
    1: {
    1:   FREE(model);
    1: }
    1: 
    1: void * XMLCALL
    1: XML_MemMalloc(XML_Parser parser, size_t size)
    1: {
    1:   return MALLOC(size);
    1: }
    1: 
    1: void * XMLCALL
    1: XML_MemRealloc(XML_Parser parser, void *ptr, size_t size)
    1: {
    1:   return REALLOC(ptr, size);
    1: }
    1: 
    1: void XMLCALL
    1: XML_MemFree(XML_Parser parser, void *ptr)
    1: {
    1:   FREE(ptr);
    1: }
    1: 
    1: void XMLCALL
    1: XML_DefaultCurrent(XML_Parser parser)
    1: {
    1:   if (defaultHandler) {
    1:     if (openInternalEntities)
    1:       reportDefault(parser,
    1:                     internalEncoding,
    1:                     openInternalEntities->internalEventPtr,
    1:                     openInternalEntities->internalEventEndPtr);
    1:     else
    1:       reportDefault(parser, encoding, eventPtr, eventEndPtr);
    1:   }
    1: }
    1: #endif
    1: 
    1: #ifdef TX_EXE
    1: const XML_LChar * XMLCALL
    1: XML_ErrorString(enum XML_Error code)
    1: {
    1:   static const XML_LChar* const message[] = {
    1:     0,
    1:     XML_L("out of memory"),
    1:     XML_L("syntax error"),
    1:     XML_L("no element found"),
    1:     XML_L("not well-formed (invalid token)"),
    1:     XML_L("unclosed token"),
    1:     XML_L("partial character"),
    1:     XML_L("mismatched tag"),
    1:     XML_L("duplicate attribute"),
    1:     XML_L("junk after document element"),
    1:     XML_L("illegal parameter entity reference"),
    1:     XML_L("undefined entity"),
    1:     XML_L("recursive entity reference"),
    1:     XML_L("asynchronous entity"),
    1:     XML_L("reference to invalid character number"),
    1:     XML_L("reference to binary entity"),
    1:     XML_L("reference to external entity in attribute"),
    1:     XML_L("XML or text declaration not at start of entity"),
    1:     XML_L("unknown encoding"),
    1:     XML_L("encoding specified in XML declaration is incorrect"),
    1:     XML_L("unclosed CDATA section"),
    1:     XML_L("error in processing external entity reference"),
    1:     XML_L("document is not standalone"),
    1:     XML_L("unexpected parser state - please send a bug report"),
    1:     XML_L("entity declared in parameter entity"),
    1:     XML_L("requested feature requires XML_DTD support in Expat"),
    1:     XML_L("cannot change setting once parsing has begun"),
    1:     XML_L("unbound prefix"),
    1:     XML_L("must not undeclare prefix"),
    1:     XML_L("incomplete markup in parameter entity"),
    1:     XML_L("XML declaration not well-formed"),
    1:     XML_L("text declaration not well-formed"),
    1:     XML_L("illegal character(s) in public id"),
    1:     XML_L("parser suspended"),
    1:     XML_L("parser not suspended"),
    1:     XML_L("parsing aborted"),
    1:     XML_L("parsing finished"),
    1:     XML_L("cannot suspend in external parameter entity"),
    1:     XML_L("reserved prefix (xml) must not be undeclared or bound to another namespace name"),
    1:     XML_L("reserved prefix (xmlns) must not be declared or undeclared"),
    1:     XML_L("prefix must not be bound to one of the reserved namespace names")
    1:   };
    1:   if (code > 0 && code < sizeof(message)/sizeof(message[0]))
    1:     return message[code];
    1:   return NULL;
    1: }
    1: #endif
    1: 
    1: #if 0
    1: const XML_LChar * XMLCALL
    1: XML_ExpatVersion(void) {
    1: 
    1:   /* V1 is used to string-ize the version number. However, it would
    1:      string-ize the actual version macro *names* unless we get them
    1:      substituted before being passed to V1. CPP is defined to expand
    1:      a macro, then rescan for more expansions. Thus, we use V2 to expand
    1:      the version macros, then CPP will expand the resulting V1() macro
    1:      with the correct numerals. */
    1:   /* ### I'm assuming cpp is portable in this respect... */
    1: 
    1: #define V1(a,b,c) XML_L(#a)XML_L(".")XML_L(#b)XML_L(".")XML_L(#c)
    1: #define V2(a,b,c) XML_L("expat_")V1(a,b,c)
    1: 
    1:   return V2(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION);
    1: 
    1: #undef V1
    1: #undef V2
    1: }
    1: 
    1: XML_Expat_Version XMLCALL
    1: XML_ExpatVersionInfo(void)
    1: {
    1:   XML_Expat_Version version;
    1: 
    1:   version.major = XML_MAJOR_VERSION;
    1:   version.minor = XML_MINOR_VERSION;
    1:   version.micro = XML_MICRO_VERSION;
    1: 
    1:   return version;
    1: }
    1: 
    1: const XML_Feature * XMLCALL
    1: XML_GetFeatureList(void)
    1: {
    1:   static const XML_Feature features[] = {
    1:     {XML_FEATURE_SIZEOF_XML_CHAR,  XML_L("sizeof(XML_Char)"),
    1:      sizeof(XML_Char)},
    1:     {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L("sizeof(XML_LChar)"),
    1:      sizeof(XML_LChar)},
    1: #ifdef XML_UNICODE
    1:     {XML_FEATURE_UNICODE,          XML_L("XML_UNICODE"), 0},
    1: #endif
    1: #ifdef XML_UNICODE_WCHAR_T
    1:     {XML_FEATURE_UNICODE_WCHAR_T,  XML_L("XML_UNICODE_WCHAR_T"), 0},
    1: #endif
    1: #ifdef XML_DTD
    1:     {XML_FEATURE_DTD,              XML_L("XML_DTD"), 0},
    1: #endif
    1: #ifdef XML_CONTEXT_BYTES
    1:     {XML_FEATURE_CONTEXT_BYTES,    XML_L("XML_CONTEXT_BYTES"),
    1:      XML_CONTEXT_BYTES},
    1: #endif
    1: #ifdef XML_MIN_SIZE
    1:     {XML_FEATURE_MIN_SIZE,         XML_L("XML_MIN_SIZE"), 0},
    1: #endif
    1: #ifdef XML_NS
    1:     {XML_FEATURE_NS,               XML_L("XML_NS"), 0},
    1: #endif
    1:     {XML_FEATURE_END,              NULL, 0}
    1:   };
    1: 
    1:   return features;
    1: }
    1: #endif
    1: /* END MOZILLA CHANGE */
    1: 
    1: /* BEGIN MOZILLA CHANGE (Report opening tag of mismatched closing tag) */
    1: const XML_Char * XMLCALL
    1: MOZ_XML_GetMismatchedTag(XML_Parser parser)
    1: {
    1:   return mismatch;
    1: }
    1: /* END MOZILLA CHANGE */
    1: 
    1: /* Initially tag->rawName always points into the parse buffer;
    1:    for those TAG instances opened while the current parse buffer was
    1:    processed, and not yet closed, we need to store tag->rawName in a more
    1:    permanent location, since the parse buffer is about to be discarded.
    1: */
    1: static XML_Bool
    1: storeRawNames(XML_Parser parser)
    1: {
    1:   TAG *tag = tagStack;
    1:   while (tag) {
    1:     int bufSize;
    1:     int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);
    1:     char *rawNameBuf = tag->buf + nameLen;
    1:     /* Stop if already stored.  Since tagStack is a stack, we can stop
    1:        at the first entry that has already been copied; everything
    1:        below it in the stack is already been accounted for in a
    1:        previous call to this function.
    1:     */
    1:     if (tag->rawName == rawNameBuf)
    1:       break;
    1:     /* For re-use purposes we need to ensure that the
    1:        size of tag->buf is a multiple of sizeof(XML_Char).
    1:     */
    1:     bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char));
    1:     if (bufSize > tag->bufEnd - tag->buf) {
    1:       char *temp = (char *)REALLOC(tag->buf, bufSize);
    1:       if (temp == NULL)
    1:         return XML_FALSE;
    1:       /* if tag->name.str points to tag->buf (only when namespace
    1:          processing is off) then we have to update it
    1:       */
    1:       if (tag->name.str == (XML_Char *)tag->buf)
    1:         tag->name.str = (XML_Char *)temp;
    1:       /* if tag->name.localPart is set (when namespace processing is on)
    1:          then update it as well, since it will always point into tag->buf
    1:       */
    1:       if (tag->name.localPart)
    1:         tag->name.localPart = (XML_Char *)temp + (tag->name.localPart -
    1:                                                   (XML_Char *)tag->buf);
    1:       tag->buf = temp;
    1:       tag->bufEnd = temp + bufSize;
    1:       rawNameBuf = temp + nameLen;
    1:     }
    1:     memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);
    1:     tag->rawName = rawNameBuf;
    1:     tag = tag->parent;
    1:   }
    1:   return XML_TRUE;
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: contentProcessor(XML_Parser parser,
    1:                  const char *start,
    1:                  const char *end,
    1:                  const char **endPtr)
    1: {
    1:   enum XML_Error result = doContent(parser, 0, encoding, start, end, 
    1:                                     endPtr, (XML_Bool)!ps_finalBuffer);
    1:   if (result == XML_ERROR_NONE) {
    1:     if (!storeRawNames(parser))
    1:       return XML_ERROR_NO_MEMORY;
    1:   }
    1:   return result;
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: externalEntityInitProcessor(XML_Parser parser,
    1:                             const char *start,
    1:                             const char *end,
    1:                             const char **endPtr)
    1: {
    1:   enum XML_Error result = initializeEncoding(parser);
    1:   if (result != XML_ERROR_NONE)
    1:     return result;
    1:   processor = externalEntityInitProcessor2;
    1:   return externalEntityInitProcessor2(parser, start, end, endPtr);
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: externalEntityInitProcessor2(XML_Parser parser,
    1:                              const char *start,
    1:                              const char *end,
    1:                              const char **endPtr)
    1: {
    1:   const char *next = start; /* XmlContentTok doesn't always set the last arg */
    1:   int tok = XmlContentTok(encoding, start, end, &next);
    1:   switch (tok) {
    1:   case XML_TOK_BOM:
    1:     /* If we are at the end of the buffer, this would cause the next stage,
    1:        i.e. externalEntityInitProcessor3, to pass control directly to
    1:        doContent (by detecting XML_TOK_NONE) without processing any xml text
    1:        declaration - causing the error XML_ERROR_MISPLACED_XML_PI in doContent.
    1:     */
    1:     if (next == end && !ps_finalBuffer) {
    1:       *endPtr = next;
    1:       return XML_ERROR_NONE;
    1:     }
    1:     start = next;
    1:     break;
    1:   case XML_TOK_PARTIAL:
    1:     if (!ps_finalBuffer) {
    1:       *endPtr = start;
    1:       return XML_ERROR_NONE;
    1:     }
    1:     eventPtr = start;
    1:     return XML_ERROR_UNCLOSED_TOKEN;
    1:   case XML_TOK_PARTIAL_CHAR:
    1:     if (!ps_finalBuffer) {
    1:       *endPtr = start;
    1:       return XML_ERROR_NONE;
    1:     }
    1:     eventPtr = start;
    1:     return XML_ERROR_PARTIAL_CHAR;
    1:   }
    1:   processor = externalEntityInitProcessor3;
    1:   return externalEntityInitProcessor3(parser, start, end, endPtr);
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: externalEntityInitProcessor3(XML_Parser parser,
    1:                              const char *start,
    1:                              const char *end,
    1:                              const char **endPtr)
    1: {
    1:   int tok;
    1:   const char *next = start; /* XmlContentTok doesn't always set the last arg */
    1:   eventPtr = start;
    1:   tok = XmlContentTok(encoding, start, end, &next);
    1:   eventEndPtr = next;
    1: 
    1:   switch (tok) {
    1:   case XML_TOK_XML_DECL:
    1:     {
    1:       enum XML_Error result;
    1:       result = processXmlDecl(parser, 1, start, next);
    1:       if (result != XML_ERROR_NONE)
    1:         return result;
    1:       switch (ps_parsing) {
    1:       case XML_SUSPENDED: 
    1:         *endPtr = next;
    1:         return XML_ERROR_NONE;
    1:       case XML_FINISHED:
    1:         return XML_ERROR_ABORTED;
    1:       default:
    1:         start = next;
    1:       }
    1:     }
    1:     break;
    1:   case XML_TOK_PARTIAL:
    1:     if (!ps_finalBuffer) {
    1:       *endPtr = start;
    1:       return XML_ERROR_NONE;
    1:     }
    1:     return XML_ERROR_UNCLOSED_TOKEN;
    1:   case XML_TOK_PARTIAL_CHAR:
    1:     if (!ps_finalBuffer) {
    1:       *endPtr = start;
    1:       return XML_ERROR_NONE;
    1:     }
    1:     return XML_ERROR_PARTIAL_CHAR;
    1:   }
    1:   processor = externalEntityContentProcessor;
    1:   tagLevel = 1;
    1:   return externalEntityContentProcessor(parser, start, end, endPtr);
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: externalEntityContentProcessor(XML_Parser parser,
    1:                                const char *start,
    1:                                const char *end,
    1:                                const char **endPtr)
    1: {
    1:   enum XML_Error result = doContent(parser, 1, encoding, start, end, 
    1:                                     endPtr, (XML_Bool)!ps_finalBuffer);
    1:   if (result == XML_ERROR_NONE) {
    1:     if (!storeRawNames(parser))
    1:       return XML_ERROR_NO_MEMORY;
    1:   }
    1:   return result;
    1: }
    1: 
    1: static enum XML_Error
    1: doContent(XML_Parser parser,
    1:           int startTagLevel,
    1:           const ENCODING *enc,
    1:           const char *s,
    1:           const char *end,
    1:           const char **nextPtr,
    1:           XML_Bool haveMore)
    1: {
    1:   /* save one level of indirection */
    1:   DTD * const dtd = _dtd;  
    1: 
    1:   const char **eventPP;
    1:   const char **eventEndPP;
    1:   if (enc == encoding) {
    1:     eventPP = &eventPtr;
    1:     eventEndPP = &eventEndPtr;
    1:   }
    1:   else {
    1:     eventPP = &(openInternalEntities->internalEventPtr);
    1:     eventEndPP = &(openInternalEntities->internalEventEndPtr);
    1:   }
    1:   *eventPP = s;
    1: 
    1:   for (;;) {
    1:     const char *next = s; /* XmlContentTok doesn't always set the last arg */
    1:     int tok = XmlContentTok(enc, s, end, &next);
    1:     *eventEndPP = next;
    1:     switch (tok) {
    1:     case XML_TOK_TRAILING_CR:
    1:       if (haveMore) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       *eventEndPP = end;
    1:       if (characterDataHandler) {
    1:         XML_Char c = 0xA;
    1:         characterDataHandler(handlerArg, &c, 1);
    1:       }
    1:       else if (defaultHandler)
    1:         reportDefault(parser, enc, s, end);
    1:       /* We are at the end of the final buffer, should we check for 
    1:          XML_SUSPENDED, XML_FINISHED? 
    1:       */
    1:       if (startTagLevel == 0)
    1:         return XML_ERROR_NO_ELEMENTS;
    1:       if (tagLevel != startTagLevel)
    1:         return XML_ERROR_ASYNC_ENTITY;
    1:       *nextPtr = end;
    1:       return XML_ERROR_NONE;
    1:     case XML_TOK_NONE:
    1:       if (haveMore) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       if (startTagLevel > 0) {
    1:         if (tagLevel != startTagLevel)
    1:           return XML_ERROR_ASYNC_ENTITY;
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       return XML_ERROR_NO_ELEMENTS;
    1:     case XML_TOK_INVALID:
    1:       *eventPP = next;
    1:       return XML_ERROR_INVALID_TOKEN;
    1:     case XML_TOK_PARTIAL:
    1:       if (haveMore) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       return XML_ERROR_UNCLOSED_TOKEN;
    1:     case XML_TOK_PARTIAL_CHAR:
    1:       if (haveMore) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       return XML_ERROR_PARTIAL_CHAR;
    1:     case XML_TOK_ENTITY_REF:
    1:       {
    1:         const XML_Char *name;
    1:         ENTITY *entity;
    1:         XML_Char ch = (XML_Char) XmlPredefinedEntityName(enc,
    1:                                               s + enc->minBytesPerChar,
    1:                                               next - enc->minBytesPerChar);
    1:         if (ch) {
    1:           if (characterDataHandler)
    1:             characterDataHandler(handlerArg, &ch, 1);
    1:           else if (defaultHandler)
    1:             reportDefault(parser, enc, s, next);
    1:           break;
    1:         }
    1:         name = poolStoreString(&dtd->pool, enc,
    1:                                 s + enc->minBytesPerChar,
    1:                                 next - enc->minBytesPerChar);
    1:         if (!name)
    1:           return XML_ERROR_NO_MEMORY;
    1:         entity = (ENTITY *)lookup(&dtd->generalEntities, name, 0);
    1:         poolDiscard(&dtd->pool);
    1:         /* First, determine if a check for an existing declaration is needed;
    1:            if yes, check that the entity exists, and that it is internal,
    1:            otherwise call the skipped entity or default handler.
    1:         */
    1:         if (!dtd->hasParamEntityRefs || dtd->standalone) {
    1:           if (!entity)
    1:             return XML_ERROR_UNDEFINED_ENTITY;
    1:           else if (!entity->is_internal)
    1:             return XML_ERROR_ENTITY_DECLARED_IN_PE;
    1:         }
    1:         else if (!entity) {
    1:           if (skippedEntityHandler)
    1:             skippedEntityHandler(handlerArg, name, 0);
    1: /* BEGIN MOZILLA CHANGE (http://bugzilla.mozilla.org/show_bug.cgi?id=35984) */
    1: #if 0
    1:           else if (defaultHandler)
    1:             reportDefault(parser, enc, s, next);
    1:           break;
    1: #else
    1:           return XML_ERROR_UNDEFINED_ENTITY;
    1: #endif
    1: /* END MOZILLA CHANGE */
    1:         }
    1:         if (entity->open)
    1:           return XML_ERROR_RECURSIVE_ENTITY_REF;
    1:         if (entity->notation)
    1:           return XML_ERROR_BINARY_ENTITY_REF;
    1:         if (entity->textPtr) {
    1:           enum XML_Error result;
    1:           if (!defaultExpandInternalEntities) {
    1:             if (skippedEntityHandler)
    1:               skippedEntityHandler(handlerArg, entity->name, 0);
    1:             else if (defaultHandler)
    1:               reportDefault(parser, enc, s, next);
    1:             break;
    1:           }
    1:           result = processInternalEntity(parser, entity, XML_FALSE);
    1:           if (result != XML_ERROR_NONE)
    1:             return result;
    1:         }
    1:         else if (externalEntityRefHandler) {
    1:           const XML_Char *context;
    1:           entity->open = XML_TRUE;
    1:           context = getContext(parser);
    1:           entity->open = XML_FALSE;
    1:           if (!context)
    1:             return XML_ERROR_NO_MEMORY;
    1:           if (!externalEntityRefHandler(externalEntityRefHandlerArg,
    1:                                         context,
    1:                                         entity->base,
    1:                                         entity->systemId,
    1:                                         entity->publicId))
    1:             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
    1:           poolDiscard(&tempPool);
    1:         }
    1:         else if (defaultHandler)
    1:           reportDefault(parser, enc, s, next);
    1:         break;
    1:       }
    1:     case XML_TOK_START_TAG_NO_ATTS:
    1:       /* fall through */
    1:     case XML_TOK_START_TAG_WITH_ATTS:
    1:       {
    1:         TAG *tag;
    1:         enum XML_Error result;
    1:         XML_Char *toPtr;
    1:         if (freeTagList) {
    1:           tag = freeTagList;
    1:           freeTagList = freeTagList->parent;
    1:         }
    1:         else {
    1:           tag = (TAG *)MALLOC(sizeof(TAG));
    1:           if (!tag)
    1:             return XML_ERROR_NO_MEMORY;
    1:           tag->buf = (char *)MALLOC(INIT_TAG_BUF_SIZE);
    1:           if (!tag->buf) {
    1:             FREE(tag);
    1:             return XML_ERROR_NO_MEMORY;
    1:           }
    1:           tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;
    1:         }
    1:         tag->bindings = NULL;
    1:         tag->parent = tagStack;
    1:         tagStack = tag;
    1:         tag->name.localPart = NULL;
    1:         tag->name.prefix = NULL;
    1:         tag->rawName = s + enc->minBytesPerChar;
    1:         tag->rawNameLength = XmlNameLength(enc, tag->rawName);
    1:         ++tagLevel;
    1:         {
    1:           const char *rawNameEnd = tag->rawName + tag->rawNameLength;
    1:           const char *fromPtr = tag->rawName;
    1:           toPtr = (XML_Char *)tag->buf;
    1:           for (;;) {
    1:             int bufSize;
    1:             int convLen;
    1:             XmlConvert(enc,
    1:                        &fromPtr, rawNameEnd,
    1:                        (ICHAR **)&toPtr, (ICHAR *)tag->bufEnd - 1);
    1:             convLen = (int)(toPtr - (XML_Char *)tag->buf);
    1:             if (fromPtr == rawNameEnd) {
    1:               tag->name.strLen = convLen;
    1:               break;
    1:             }
    1:             bufSize = (int)(tag->bufEnd - tag->buf) << 1;
    1:             {
    1:               char *temp = (char *)REALLOC(tag->buf, bufSize);
    1:               if (temp == NULL)
    1:                 return XML_ERROR_NO_MEMORY;
    1:               tag->buf = temp;
    1:               tag->bufEnd = temp + bufSize;
    1:               toPtr = (XML_Char *)temp + convLen;
    1:             }
    1:           }
    1:         }
    1:         tag->name.str = (XML_Char *)tag->buf;
    1:         *toPtr = XML_T('\0');
    1:         result = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings));
    1:         if (result)
    1:           return result;
    1:         if (startElementHandler)
    1:           startElementHandler(handlerArg, tag->name.str,
    1:                               (const XML_Char **)atts);
    1:         else if (defaultHandler)
    1:           reportDefault(parser, enc, s, next);
    1:         poolClear(&tempPool);
    1:         break;
    1:       }
    1:     case XML_TOK_EMPTY_ELEMENT_NO_ATTS:
    1:       /* fall through */
    1:     case XML_TOK_EMPTY_ELEMENT_WITH_ATTS:
    1:       {
    1:         const char *rawName = s + enc->minBytesPerChar;
    1:         enum XML_Error result;
    1:         BINDING *bindings = NULL;
    1:         XML_Bool noElmHandlers = XML_TRUE;
    1:         TAG_NAME name;
    1:         name.str = poolStoreString(&tempPool, enc, rawName,
    1:                                    rawName + XmlNameLength(enc, rawName));
    1:         if (!name.str)
    1:           return XML_ERROR_NO_MEMORY;
    1:         poolFinish(&tempPool);
    1:         result = storeAtts(parser, enc, s, &name, &bindings);
    1:         if (result)
    1:           return result;
    1:         poolFinish(&tempPool);
    1:         if (startElementHandler) {
    1:           startElementHandler(handlerArg, name.str, (const XML_Char **)atts);
    1:           noElmHandlers = XML_FALSE;
    1:         }
    1:         if (endElementHandler) {
    1:           if (startElementHandler)
    1:             *eventPP = *eventEndPP;
    1:           endElementHandler(handlerArg, name.str);
    1:           noElmHandlers = XML_FALSE;
    1:         }
    1:         if (noElmHandlers && defaultHandler)
    1:           reportDefault(parser, enc, s, next);
    1:         poolClear(&tempPool);
    1:         while (bindings) {
    1:           BINDING *b = bindings;
    1:           if (endNamespaceDeclHandler)
    1:             endNamespaceDeclHandler(handlerArg, b->prefix->name);
    1:           bindings = bindings->nextTagBinding;
    1:           b->nextTagBinding = freeBindingList;
    1:           freeBindingList = b;
    1:           b->prefix->binding = b->prevPrefixBinding;
    1:         }
    1:       }
    1:       if (tagLevel == 0)
    1:         return epilogProcessor(parser, next, end, nextPtr);
    1:       break;
    1:     case XML_TOK_END_TAG:
    1:       if (tagLevel == startTagLevel)
    1:         return XML_ERROR_ASYNC_ENTITY;
    1:       else {
    1:         int len;
    1:         const char *rawName;
    1:         TAG *tag = tagStack;
    1:         tagStack = tag->parent;
    1:         tag->parent = freeTagList;
    1:         freeTagList = tag;
    1:         rawName = s + enc->minBytesPerChar*2;
    1:         len = XmlNameLength(enc, rawName);
    1:         if (len != tag->rawNameLength
    1:             || memcmp(tag->rawName, rawName, len) != 0) {
    1: /* BEGIN MOZILLA CHANGE (Report opening tag of mismatched closing tag) */
    1: 	  /* This code is copied from the |if (endElementHandler)| block below */
    1:           const XML_Char *localPart;
    1:           const XML_Char *prefix;
    1:           XML_Char *uri;
    1:           localPart = tag->name.localPart;
    1:           if (ns && localPart) {
    1:             /* localPart and prefix may have been overwritten in
    1:                tag->name.str, since this points to the binding->uri
    1:                buffer which gets re-used; so we have to add them again
    1:             */
    1:             uri = (XML_Char *)tag->name.str + tag->name.uriLen;
    1:             /* don't need to check for space - already done in storeAtts() */
    1:             while (*localPart) *uri++ = *localPart++;
    1:             prefix = (XML_Char *)tag->name.prefix;
    1:             if (ns_triplets && prefix) {
    1:               *uri++ = namespaceSeparator;
    1:               while (*prefix) *uri++ = *prefix++;
    1:              }
    1:             *uri = XML_T('\0');
    1:           }
    1:           mismatch = tag->name.str;
    1: /* END MOZILLA CHANGE */
    1:           *eventPP = rawName;
    1:           return XML_ERROR_TAG_MISMATCH;
    1:         }
    1:         --tagLevel;
    1:         if (endElementHandler) {
    1:           const XML_Char *localPart;
    1:           const XML_Char *prefix;
    1:           XML_Char *uri;
    1:           localPart = tag->name.localPart;
    1:           if (ns && localPart) {
    1:             /* localPart and prefix may have been overwritten in
    1:                tag->name.str, since this points to the binding->uri
    1:                buffer which gets re-used; so we have to add them again
    1:             */
    1:             uri = (XML_Char *)tag->name.str + tag->name.uriLen;
    1:             /* don't need to check for space - already done in storeAtts() */
    1:             while (*localPart) *uri++ = *localPart++;
    1:             prefix = (XML_Char *)tag->name.prefix;
    1:             if (ns_triplets && prefix) {
    1:               *uri++ = namespaceSeparator;
    1:               while (*prefix) *uri++ = *prefix++;
    1:              }
    1:             *uri = XML_T('\0');
    1:           }
    1:           endElementHandler(handlerArg, tag->name.str);
    1:         }
    1:         else if (defaultHandler)
    1:           reportDefault(parser, enc, s, next);
    1:         while (tag->bindings) {
    1:           BINDING *b = tag->bindings;
    1:           if (endNamespaceDeclHandler)
    1:             endNamespaceDeclHandler(handlerArg, b->prefix->name);
    1:           tag->bindings = tag->bindings->nextTagBinding;
    1:           b->nextTagBinding = freeBindingList;
    1:           freeBindingList = b;
    1:           b->prefix->binding = b->prevPrefixBinding;
    1:         }
    1:         if (tagLevel == 0)
    1:           return epilogProcessor(parser, next, end, nextPtr);
    1:       }
    1:       break;
    1:     case XML_TOK_CHAR_REF:
    1:       {
    1:         int n = XmlCharRefNumber(enc, s);
    1:         if (n < 0)
    1:           return XML_ERROR_BAD_CHAR_REF;
    1:         if (characterDataHandler) {
    1:           XML_Char buf[XML_ENCODE_MAX];
    1:           characterDataHandler(handlerArg, buf, XmlEncode(n, (ICHAR *)buf));
    1:         }
    1:         else if (defaultHandler)
    1:           reportDefault(parser, enc, s, next);
    1:       }
    1:       break;
    1:     case XML_TOK_XML_DECL:
    1:       return XML_ERROR_MISPLACED_XML_PI;
    1:     case XML_TOK_DATA_NEWLINE:
    1:       if (characterDataHandler) {
    1:         XML_Char c = 0xA;
    1:         characterDataHandler(handlerArg, &c, 1);
    1:       }
    1:       else if (defaultHandler)
    1:         reportDefault(parser, enc, s, next);
    1:       break;
    1:     case XML_TOK_CDATA_SECT_OPEN:
    1:       {
    1:         enum XML_Error result;
    1:         if (startCdataSectionHandler)
    1:           startCdataSectionHandler(handlerArg);
    1: #if 0
    1:         /* Suppose you doing a transformation on a document that involves
    1:            changing only the character data.  You set up a defaultHandler
    1:            and a characterDataHandler.  The defaultHandler simply copies
    1:            characters through.  The characterDataHandler does the
    1:            transformation and writes the characters out escaping them as
    1:            necessary.  This case will fail to work if we leave out the
    1:            following two lines (because & and < inside CDATA sections will
    1:            be incorrectly escaped).
    1: 
    1:            However, now we have a start/endCdataSectionHandler, so it seems
    1:            easier to let the user deal with this.
    1:         */
    1:         else if (characterDataHandler)
    1:           characterDataHandler(handlerArg, dataBuf, 0);
    1: #endif
    1:         else if (defaultHandler)
    1:           reportDefault(parser, enc, s, next);
    1:         result = doCdataSection(parser, enc, &next, end, nextPtr, haveMore);
    1:         if (result != XML_ERROR_NONE)
    1:           return result;
    1:         else if (!next) {
    1:           processor = cdataSectionProcessor;
    1:           return result;
    1:         }
    1:       }
    1:       break;
    1:     case XML_TOK_TRAILING_RSQB:
    1:       if (haveMore) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       if (characterDataHandler) {
    1:         if (MUST_CONVERT(enc, s)) {
    1:           ICHAR *dataPtr = (ICHAR *)dataBuf;
    1:           XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
    1:           characterDataHandler(handlerArg, dataBuf,
    1:                                (int)(dataPtr - (ICHAR *)dataBuf));
    1:         }
    1:         else
    1:           characterDataHandler(handlerArg,
    1:                                (XML_Char *)s,
    1:                                (int)((XML_Char *)end - (XML_Char *)s));
    1:       }
    1:       else if (defaultHandler)
    1:         reportDefault(parser, enc, s, end);
    1:       /* We are at the end of the final buffer, should we check for 
    1:          XML_SUSPENDED, XML_FINISHED? 
    1:       */
    1:       if (startTagLevel == 0) {
    1:         *eventPP = end;
    1:         return XML_ERROR_NO_ELEMENTS;
    1:       }
    1:       if (tagLevel != startTagLevel) {
    1:         *eventPP = end;
    1:         return XML_ERROR_ASYNC_ENTITY;
    1:       }
    1:       *nextPtr = end;
    1:       return XML_ERROR_NONE;
    1:     case XML_TOK_DATA_CHARS:
    1:       if (characterDataHandler) {
    1:         if (MUST_CONVERT(enc, s)) {
    1:           for (;;) {
    1:             ICHAR *dataPtr = (ICHAR *)dataBuf;
    1:             XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
    1:             *eventEndPP = s;
    1:             characterDataHandler(handlerArg, dataBuf,
    1:                                  (int)(dataPtr - (ICHAR *)dataBuf));
    1:             if (s == next)
    1:               break;
    1:             *eventPP = s;
    1:           }
    1:         }
    1:         else
    1:           characterDataHandler(handlerArg,
    1:                                (XML_Char *)s,
    1:                                (int)((XML_Char *)next - (XML_Char *)s));
    1:       }
    1:       else if (defaultHandler)
    1:         reportDefault(parser, enc, s, next);
    1:       break;
    1:     case XML_TOK_PI:
    1:       if (!reportProcessingInstruction(parser, enc, s, next))
    1:         return XML_ERROR_NO_MEMORY;
    1:       break;
    1:     case XML_TOK_COMMENT:
    1:       if (!reportComment(parser, enc, s, next))
    1:         return XML_ERROR_NO_MEMORY;
    1:       break;
    1:     default:
    1:       if (defaultHandler)
    1:         reportDefault(parser, enc, s, next);
    1:       break;
    1:     }
    1:     *eventPP = s = next;
    1:     switch (ps_parsing) {
    1:     case XML_SUSPENDED: 
    1:       *nextPtr = next;
    1:       return XML_ERROR_NONE;
    1:     case XML_FINISHED:
    1:       return XML_ERROR_ABORTED;
    1:     default: ;
    1:     }
    1:   }
    1:   /* not reached */
    1: }
    1: 
    1: /* Precondition: all arguments must be non-NULL;
    1:    Purpose:
    1:    - normalize attributes
    1:    - check attributes for well-formedness
    1:    - generate namespace aware attribute names (URI, prefix)
    1:    - build list of attributes for startElementHandler
    1:    - default attributes
    1:    - process namespace declarations (check and report them)
    1:    - generate namespace aware element name (URI, prefix)
    1: */
    1: static enum XML_Error
    1: storeAtts(XML_Parser parser, const ENCODING *enc,
    1:           const char *attStr, TAG_NAME *tagNamePtr,
    1:           BINDING **bindingsPtr)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   ELEMENT_TYPE *elementType;
    1:   int nDefaultAtts;
    1:   const XML_Char **appAtts;   /* the attribute list for the application */
    1:   int attIndex = 0;
    1:   int prefixLen;
    1:   int i;
    1:   int n;
    1:   XML_Char *uri;
    1:   int nPrefixes = 0;
    1: /* BEGIN MOZILLA CHANGE (Include xmlns attributes in attributes array) */
    1:   int nXMLNSDeclarations = 0;
    1: /* END MOZILLA CHANGE */
    1:   BINDING *binding;
    1:   const XML_Char *localPart;
    1: 
    1:   /* lookup the element type name */
    1:   elementType = (ELEMENT_TYPE *)lookup(&dtd->elementTypes, tagNamePtr->str,0);
    1:   if (!elementType) {
    1:     const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);
    1:     if (!name)
    1:       return XML_ERROR_NO_MEMORY;
    1:     elementType = (ELEMENT_TYPE *)lookup(&dtd->elementTypes, name,
    1:                                          sizeof(ELEMENT_TYPE));
    1:     if (!elementType)
    1:       return XML_ERROR_NO_MEMORY;
    1:     if (ns && !setElementTypePrefix(parser, elementType))
    1:       return XML_ERROR_NO_MEMORY;
    1:   }
    1:   nDefaultAtts = elementType->nDefaultAtts;
    1: 
    1:   /* get the attributes from the tokenizer */
    1:   n = XmlGetAttributes(enc, attStr, attsSize, atts);
    1:   if (n + nDefaultAtts > attsSize) {
    1:     int oldAttsSize = attsSize;
    1:     ATTRIBUTE *temp;
    1:     attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;
    1:     temp = (ATTRIBUTE *)REALLOC((void *)atts, attsSize * sizeof(ATTRIBUTE));
    1:     if (temp == NULL)
    1:       return XML_ERROR_NO_MEMORY;
    1:     atts = temp;
    1:     if (n > oldAttsSize)
    1:       XmlGetAttributes(enc, attStr, n, atts);
    1:   }
    1: 
    1:   appAtts = (const XML_Char **)atts;
    1:   for (i = 0; i < n; i++) {
    1:     /* add the name and value to the attribute list */
    1:     ATTRIBUTE_ID *attId = getAttributeId(parser, enc, atts[i].name,
    1:                                          atts[i].name
    1:                                          + XmlNameLength(enc, atts[i].name));
    1:     if (!attId)
    1:       return XML_ERROR_NO_MEMORY;
    1:     /* Detect duplicate attributes by their QNames. This does not work when
    1:        namespace processing is turned on and different prefixes for the same
    1:        namespace are used. For this case we have a check further down.
    1:     */
    1:     if ((attId->name)[-1]) {
    1:       if (enc == encoding)
    1:         eventPtr = atts[i].name;
    1:       return XML_ERROR_DUPLICATE_ATTRIBUTE;
    1:     }
    1:     (attId->name)[-1] = 1;
    1:     appAtts[attIndex++] = attId->name;
    1:     if (!atts[i].normalized) {
    1:       enum XML_Error result;
    1:       XML_Bool isCdata = XML_TRUE;
    1: 
    1:       /* figure out whether declared as other than CDATA */
    1:       if (attId->maybeTokenized) {
    1:         int j;
    1:         for (j = 0; j < nDefaultAtts; j++) {
    1:           if (attId == elementType->defaultAtts[j].id) {
    1:             isCdata = elementType->defaultAtts[j].isCdata;
    1:             break;
    1:           }
    1:         }
    1:       }
    1: 
    1:       /* normalize the attribute value */
    1:       result = storeAttributeValue(parser, enc, isCdata,
    1:                                    atts[i].valuePtr, atts[i].valueEnd,
    1:                                    &tempPool);
    1:       if (result)
    1:         return result;
    1:       appAtts[attIndex] = poolStart(&tempPool);
    1:       poolFinish(&tempPool);
    1:     }
    1:     else {
    1:       /* the value did not need normalizing */
    1:       appAtts[attIndex] = poolStoreString(&tempPool, enc, atts[i].valuePtr,
    1:                                           atts[i].valueEnd);
    1:       if (appAtts[attIndex] == 0)
    1:         return XML_ERROR_NO_MEMORY;
    1:       poolFinish(&tempPool);
    1:     }
    1:     /* handle prefixed attribute names */
    1:     if (attId->prefix) {
    1:       if (attId->xmlns) {
    1:         /* deal with namespace declarations here */
    1:         enum XML_Error result = addBinding(parser, attId->prefix, attId,
    1:                                            appAtts[attIndex], bindingsPtr);
    1:         if (result)
    1:           return result;
    1: /* BEGIN MOZILLA CHANGE (Include xmlns attributes in attributes array) */
    1: #if 0
    1:         --attIndex;
    1: #else
    1:         attIndex++;
    1:         nXMLNSDeclarations++;
    1:         (attId->name)[-1] = 3;
    1: #endif
    1: /* END MOZILLA CHANGE */
    1:       }
    1:       else {
    1:         /* deal with other prefixed names later */
    1:         attIndex++;
    1:         nPrefixes++;
    1:         (attId->name)[-1] = 2;
    1:       }
    1:     }
    1:     else
    1:       attIndex++;
    1:   }
    1: 
    1:   /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */
    1:   nSpecifiedAtts = attIndex;
    1:   if (elementType->idAtt && (elementType->idAtt->name)[-1]) {
    1:     for (i = 0; i < attIndex; i += 2)
    1:       if (appAtts[i] == elementType->idAtt->name) {
    1:         idAttIndex = i;
    1:         break;
    1:       }
    1:   }
    1:   else
    1:     idAttIndex = -1;
    1: 
    1:   /* do attribute defaulting */
    1:   for (i = 0; i < nDefaultAtts; i++) {
    1:     const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;
    1:     if (!(da->id->name)[-1] && da->value) {
    1:       if (da->id->prefix) {
    1:         if (da->id->xmlns) {
    1:           enum XML_Error result = addBinding(parser, da->id->prefix, da->id,
    1:                                              da->value, bindingsPtr);
    1:           if (result)
    1:             return result;
    1: /* BEGIN MOZILLA CHANGE (Include xmlns attributes in attributes array) */
    1:           (da->id->name)[-1] = 3;
    1:           nXMLNSDeclarations++;
    1:           appAtts[attIndex++] = da->id->name;
    1:           appAtts[attIndex++] = da->value;
    1: /* END MOZILLA CHANGE */
    1:         }
    1:         else {
    1:           (da->id->name)[-1] = 2;
    1:           nPrefixes++;
    1:           appAtts[attIndex++] = da->id->name;
    1:           appAtts[attIndex++] = da->value;
    1:         }
    1:       }
    1:       else {
    1:         (da->id->name)[-1] = 1;
    1:         appAtts[attIndex++] = da->id->name;
    1:         appAtts[attIndex++] = da->value;
    1:       }
    1:     }
    1:   }
    1:   appAtts[attIndex] = 0;
    1: 
    1:   /* expand prefixed attribute names, check for duplicates,
    1:      and clear flags that say whether attributes were specified */
    1:   i = 0;
    1: /* BEGIN MOZILLA CHANGE (Include xmlns attributes in attributes array) */
    1: #if 0
    1:   if (nPrefixes) {
    1: #else
    1:   if (nPrefixes || nXMLNSDeclarations) {
    1: #endif
    1: /* END MOZILLA CHANGE */
    1:     int j;  /* hash table index */
    1:     unsigned long version = nsAttsVersion;
    1:     int nsAttsSize = (int)1 << nsAttsPower;
    1: /* BEGIN MOZILLA CHANGE (Include xmlns attributes in attributes array) */
    1:     if (nPrefixes) {
    1: /* END MOZILLA CHANGE */
    1:     /* size of hash table must be at least 2 * (# of prefixed attributes) */
    1:     if ((nPrefixes << 1) >> nsAttsPower) {  /* true for nsAttsPower = 0 */
    1:       NS_ATT *temp;
    1:       /* hash table size must also be a power of 2 and >= 8 */
    1:       while (nPrefixes >> nsAttsPower++);
    1:       if (nsAttsPower < 3)
    1:         nsAttsPower = 3;
    1:       nsAttsSize = (int)1 << nsAttsPower;
    1:       temp = (NS_ATT *)REALLOC(nsAtts, nsAttsSize * sizeof(NS_ATT));
    1:       if (!temp)
    1:         return XML_ERROR_NO_MEMORY;
    1:       nsAtts = temp;
    1:       version = 0;  /* force re-initialization of nsAtts hash table */
    1:     }
    1:     /* using a version flag saves us from initializing nsAtts every time */
    1:     if (!version) {  /* initialize version flags when version wraps around */
    1:       version = INIT_ATTS_VERSION;
    1:       for (j = nsAttsSize; j != 0; )
    1:         nsAtts[--j].version = version;
    1:     }
    1:     nsAttsVersion = --version;
    1: /* BEGIN MOZILLA CHANGE (Include xmlns attributes in attributes array) */
    1:     }
    1: /* END MOZILLA CHANGE */
    1: 
    1:     /* expand prefixed names and check for duplicates */
    1:     for (; i < attIndex; i += 2) {
    1:       const XML_Char *s = appAtts[i];
    1:       if (s[-1] == 2) {  /* prefixed */
    1:         ATTRIBUTE_ID *id;
    1:         const BINDING *b;
    1:         unsigned long uriHash = 0;
    1:         ((XML_Char *)s)[-1] = 0;  /* clear flag */
    1:         id = (ATTRIBUTE_ID *)lookup(&dtd->attributeIds, s, 0);
    1:         b = id->prefix->binding;
    1:         if (!b)
    1:           return XML_ERROR_UNBOUND_PREFIX;
    1: 
    1:         /* as we expand the name we also calculate its hash value */
    1:         for (j = 0; j < b->uriLen; j++) {
    1:           const XML_Char c = b->uri[j];
    1:           if (!poolAppendChar(&tempPool, c))
    1:             return XML_ERROR_NO_MEMORY;
    1:           uriHash = CHAR_HASH(uriHash, c);
    1:         }
    1:         while (*s++ != XML_T(':'))
    1:           ;
    1:         do {  /* copies null terminator */
    1:           const XML_Char c = *s;
    1:           if (!poolAppendChar(&tempPool, *s))
    1:             return XML_ERROR_NO_MEMORY;
    1:           uriHash = CHAR_HASH(uriHash, c);
    1:         } while (*s++);
    1: 
    1:         { /* Check hash table for duplicate of expanded name (uriName).
    1:              Derived from code in lookup(HASH_TABLE *table, ...).
    1:           */
    1:           unsigned char step = 0;
    1:           unsigned long mask = nsAttsSize - 1;
    1:           j = uriHash & mask;  /* index into hash table */
    1:           while (nsAtts[j].version == version) {
    1:             /* for speed we compare stored hash values first */
    1:             if (uriHash == nsAtts[j].hash) {
    1:               const XML_Char *s1 = poolStart(&tempPool);
    1:               const XML_Char *s2 = nsAtts[j].uriName;
    1:               /* s1 is null terminated, but not s2 */
    1:               for (; *s1 == *s2 && *s1 != 0; s1++, s2++);
    1:               if (*s1 == 0)
    1:                 return XML_ERROR_DUPLICATE_ATTRIBUTE;
    1:             }
    1:             if (!step)
    1:               step = PROBE_STEP(uriHash, mask, nsAttsPower);
    1:             j < step ? (j += nsAttsSize - step) : (j -= step);
    1:           }
    1:         }
    1: 
    1:         if (ns_triplets) {  /* append namespace separator and prefix */
    1:           tempPool.ptr[-1] = namespaceSeparator;
    1:           s = b->prefix->name;
    1:           do {
    1:             if (!poolAppendChar(&tempPool, *s))
    1:               return XML_ERROR_NO_MEMORY;
    1:           } while (*s++);
    1:         }
    1: 
    1:         /* store expanded name in attribute list */
    1:         s = poolStart(&tempPool);
    1:         poolFinish(&tempPool);
    1:         appAtts[i] = s;
    1: 
    1:         /* fill empty slot with new version, uriName and hash value */
    1:         nsAtts[j].version = version;
    1:         nsAtts[j].hash = uriHash;
    1:         nsAtts[j].uriName = s;
    1: 
    1: /* BEGIN MOZILLA CHANGE (Include xmlns attributes in attributes array) */
    1: #if 0
    1:         if (!--nPrefixes)
    1: #else
    1:         if (!--nPrefixes && !nXMLNSDeclarations) {
    1: #endif
    1: /* END MOZILLA CHANGE */
    1:           i += 2;
    1:           break;
    1:         }
    1:       }
    1: /* BEGIN MOZILLA CHANGE (Include xmlns attributes in attributes array) */
    1:       else if (s[-1] == 3) { /* xmlns attribute */
    1:         static const XML_Char xmlnsNamespace[] = {
    1:           'h', 't', 't', 'p', ':', '/', '/',
    1:           'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/',
    1:           '2', '0', '0', '0', '/', 'x', 'm', 'l', 'n', 's', '/', '\0'
    1:         };
    1:         static const XML_Char xmlnsPrefix[] = {
    1:           'x', 'm', 'l', 'n', 's', '\0'
    1:         };
    1:         XML_Bool appendXMLNS = XML_TRUE;
    1: 
    1:         ((XML_Char *)s)[-1] = 0;  /* clear flag */
    1:         if (!poolAppendString(&tempPool, xmlnsNamespace)
    1:             || !poolAppendChar(&tempPool, namespaceSeparator))
    1:           return XML_ERROR_NO_MEMORY;
    1:         s += sizeof(xmlnsPrefix) / sizeof(xmlnsPrefix[0]) - 1;
    1:         if (*s == XML_T(':')) {
    1:           ++s;
    1:           do {  /* copies null terminator */
    1:             if (!poolAppendChar(&tempPool, *s))
    1:               return XML_ERROR_NO_MEMORY;
    1:           } while (*s++);
    1:           if (ns_triplets) { /* append namespace separator and prefix */
    1:             tempPool.ptr[-1] = namespaceSeparator;
    1:             if (!poolAppendString(&tempPool, xmlnsPrefix)
    1:                 || !poolAppendChar(&tempPool, '\0'))
    1:               return XML_ERROR_NO_MEMORY;
    1:           }
    1:         }
    1:         else {
    1:           /* xlmns attribute without a prefix. */
    1:           if (!poolAppendString(&tempPool, xmlnsPrefix)
    1:               || !poolAppendChar(&tempPool, '\0'))
    1:             return XML_ERROR_NO_MEMORY;
    1:         }
    1: 
    1:         /* store expanded name in attribute list */
    1:         s = poolStart(&tempPool);
    1:         poolFinish(&tempPool);
    1:         appAtts[i] = s;
    1: 
    1:         if (!--nXMLNSDeclarations && !nPrefixes) {
    1:           i += 2;
    1:           break;
    1:         }
    1:       }
    1: /* END MOZILLA CHANGE */
    1:       else  /* not prefixed */
    1:         ((XML_Char *)s)[-1] = 0;  /* clear flag */
    1:     }
    1:   }
    1:   /* clear flags for the remaining attributes */
    1:   for (; i < attIndex; i += 2)
    1:     ((XML_Char *)(appAtts[i]))[-1] = 0;
    1:   for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)
    1:     binding->attId->name[-1] = 0;
    1: 
    1:   if (!ns)
    1:     return XML_ERROR_NONE;
    1: 
    1:   /* expand the element type name */
    1:   if (elementType->prefix) {
    1:     binding = elementType->prefix->binding;
    1:     if (!binding)
    1:       return XML_ERROR_UNBOUND_PREFIX;
    1:     localPart = tagNamePtr->str;
    1:     while (*localPart++ != XML_T(':'))
    1:       ;
    1:   }
    1:   else if (dtd->defaultPrefix.binding) {
    1:     binding = dtd->defaultPrefix.binding;
    1:     localPart = tagNamePtr->str;
    1:   }
    1:   else
    1:     return XML_ERROR_NONE;
    1:   prefixLen = 0;
    1:   if (ns_triplets && binding->prefix->name) {
    1:     for (; binding->prefix->name[prefixLen++];)
    1:       ;  /* prefixLen includes null terminator */
    1:   }
    1:   tagNamePtr->localPart = localPart;
    1:   tagNamePtr->uriLen = binding->uriLen;
    1:   tagNamePtr->prefix = binding->prefix->name;
    1:   tagNamePtr->prefixLen = prefixLen;
    1:   for (i = 0; localPart[i++];)
    1:     ;  /* i includes null terminator */
    1:   n = i + binding->uriLen + prefixLen;
    1:   if (n > binding->uriAlloc) {
    1:     TAG *p;
    1:     uri = (XML_Char *)MALLOC((n + EXPAND_SPARE) * sizeof(XML_Char));
    1:     if (!uri)
    1:       return XML_ERROR_NO_MEMORY;
    1:     binding->uriAlloc = n + EXPAND_SPARE;
    1:     memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));
    1:     for (p = tagStack; p; p = p->parent)
    1:       if (p->name.str == binding->uri)
    1:         p->name.str = uri;
    1:     FREE(binding->uri);
    1:     binding->uri = uri;
    1:   }
    1:   /* if namespaceSeparator != '\0' then uri includes it already */
    1:   uri = binding->uri + binding->uriLen;
    1:   memcpy(uri, localPart, i * sizeof(XML_Char));
    1:   /* we always have a namespace separator between localPart and prefix */
    1:   if (prefixLen) {
    1:     uri += i - 1;
    1:     *uri = namespaceSeparator;  /* replace null terminator */
    1:     memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));
    1:   }
    1:   tagNamePtr->str = binding->uri;
    1:   return XML_ERROR_NONE;
    1: }
    1: 
    1: /* addBinding() overwrites the value of prefix->binding without checking.
    1:    Therefore one must keep track of the old value outside of addBinding().
    1: */
    1: static enum XML_Error
    1: addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
    1:            const XML_Char *uri, BINDING **bindingsPtr)
    1: {
    1:   static const XML_Char xmlNamespace[] = {
    1:     'h', 't', 't', 'p', ':', '/', '/',
    1:     'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/',
    1:     'X', 'M', 'L', '/', '1', '9', '9', '8', '/',
    1:     'n', 'a', 'm', 'e', 's', 'p', 'a', 'c', 'e', '\0'
    1:   };
    1:   static const int xmlLen = 
    1:     (int)sizeof(xmlNamespace)/sizeof(XML_Char) - 1;
    1:   static const XML_Char xmlnsNamespace[] = {
    1:     'h', 't', 't', 'p', ':', '/', '/',
    1:     'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/',
    1:     '2', '0', '0', '0', '/', 'x', 'm', 'l', 'n', 's', '/', '\0'
    1:   };
    1:   static const int xmlnsLen = 
    1:     (int)sizeof(xmlnsNamespace)/sizeof(XML_Char) - 1;
    1: 
    1:   XML_Bool mustBeXML = XML_FALSE;
    1:   XML_Bool isXML = XML_TRUE;
    1:   XML_Bool isXMLNS = XML_TRUE;
    1:   
    1:   BINDING *b;
    1:   int len;
    1: 
    1:   /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */
    1:   if (*uri == XML_T('\0') && prefix->name)
    1:     return XML_ERROR_UNDECLARING_PREFIX;
    1: 
    1:   if (prefix->name
    1:       && prefix->name[0] == XML_T('x')
    1:       && prefix->name[1] == XML_T('m')
    1:       && prefix->name[2] == XML_T('l')) {
    1: 
    1:     /* Not allowed to bind xmlns */
    1:     if (prefix->name[3] == XML_T('n')
    1:         && prefix->name[4] == XML_T('s')
    1:         && prefix->name[5] == XML_T('\0'))
    1:       return XML_ERROR_RESERVED_PREFIX_XMLNS;
    1: 
    1:     if (prefix->name[3] == XML_T('\0'))
    1:       mustBeXML = XML_TRUE;
    1:   }
    1: 
    1:   for (len = 0; uri[len]; len++) {
    1:     if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))
    1:       isXML = XML_FALSE;
    1: 
    1:     if (!mustBeXML && isXMLNS 
    1:         && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))
    1:       isXMLNS = XML_FALSE;
    1:   }
    1:   isXML = isXML && len == xmlLen;
    1:   isXMLNS = isXMLNS && len == xmlnsLen;
    1: 
    1:   if (mustBeXML != isXML)
    1:     return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML
    1:                      : XML_ERROR_RESERVED_NAMESPACE_URI;
    1: 
    1:   if (isXMLNS)
    1:     return XML_ERROR_RESERVED_NAMESPACE_URI;
    1: 
    1:   if (namespaceSeparator)
    1:     len++;
    1:   if (freeBindingList) {
    1:     b = freeBindingList;
    1:     if (len > b->uriAlloc) {
    1:       XML_Char *temp = (XML_Char *)REALLOC(b->uri,
    1:                           sizeof(XML_Char) * (len + EXPAND_SPARE));
    1:       if (temp == NULL)
    1:         return XML_ERROR_NO_MEMORY;
    1:       b->uri = temp;
    1:       b->uriAlloc = len + EXPAND_SPARE;
    1:     }
    1:     freeBindingList = b->nextTagBinding;
    1:   }
    1:   else {
    1:     b = (BINDING *)MALLOC(sizeof(BINDING));
    1:     if (!b)
    1:       return XML_ERROR_NO_MEMORY;
    1:     b->uri = (XML_Char *)MALLOC(sizeof(XML_Char) * (len + EXPAND_SPARE));
    1:     if (!b->uri) {
    1:       FREE(b);
    1:       return XML_ERROR_NO_MEMORY;
    1:     }
    1:     b->uriAlloc = len + EXPAND_SPARE;
    1:   }
    1:   b->uriLen = len;
    1:   memcpy(b->uri, uri, len * sizeof(XML_Char));
    1:   if (namespaceSeparator)
    1:     b->uri[len - 1] = namespaceSeparator;
    1:   b->prefix = prefix;
    1:   b->attId = attId;
    1:   b->prevPrefixBinding = prefix->binding;
    1:   /* NULL binding when default namespace undeclared */
    1:   if (*uri == XML_T('\0') && prefix == &_dtd->defaultPrefix)
    1:     prefix->binding = NULL;
    1:   else
    1:     prefix->binding = b;
    1:   b->nextTagBinding = *bindingsPtr;
    1:   *bindingsPtr = b;
    1:   /* if attId == NULL then we are not starting a namespace scope */
    1:   if (attId && startNamespaceDeclHandler)
    1:     startNamespaceDeclHandler(handlerArg, prefix->name,
    1:                               prefix->binding ? uri : 0);
    1:   return XML_ERROR_NONE;
    1: }
    1: 
    1: /* The idea here is to avoid using stack for each CDATA section when
    1:    the whole file is parsed with one call.
    1: */
    1: static enum XML_Error PTRCALL
    1: cdataSectionProcessor(XML_Parser parser,
    1:                       const char *start,
    1:                       const char *end,
    1:                       const char **endPtr)
    1: {
    1:   enum XML_Error result = doCdataSection(parser, encoding, &start, end,
    1:                                          endPtr, (XML_Bool)!ps_finalBuffer);
    1:   if (result != XML_ERROR_NONE)
    1:     return result;
    1:   if (start) {
    1:     if (parentParser) {  /* we are parsing an external entity */
    1:       processor = externalEntityContentProcessor;
    1:       return externalEntityContentProcessor(parser, start, end, endPtr);
    1:     }
    1:     else {
    1:       processor = contentProcessor;
    1:       return contentProcessor(parser, start, end, endPtr);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: /* startPtr gets set to non-null if the section is closed, and to null if
    1:    the section is not yet closed.
    1: */
    1: static enum XML_Error
    1: doCdataSection(XML_Parser parser,
    1:                const ENCODING *enc,
    1:                const char **startPtr,
    1:                const char *end,
    1:                const char **nextPtr,
    1:                XML_Bool haveMore)
    1: {
    1:   const char *s = *startPtr;
    1:   const char **eventPP;
    1:   const char **eventEndPP;
    1:   if (enc == encoding) {
    1:     eventPP = &eventPtr;
    1:     *eventPP = s;
    1:     eventEndPP = &eventEndPtr;
    1:   }
    1:   else {
    1:     eventPP = &(openInternalEntities->internalEventPtr);
    1:     eventEndPP = &(openInternalEntities->internalEventEndPtr);
    1:   }
    1:   *eventPP = s;
    1:   *startPtr = NULL;
    1: 
    1:   for (;;) {
    1:     const char *next;
    1:     int tok = XmlCdataSectionTok(enc, s, end, &next);
    1:     *eventEndPP = next;
    1:     switch (tok) {
    1:     case XML_TOK_CDATA_SECT_CLOSE:
    1:       if (endCdataSectionHandler)
    1:         endCdataSectionHandler(handlerArg);
    1: #if 0
    1:       /* see comment under XML_TOK_CDATA_SECT_OPEN */
    1:       else if (characterDataHandler)
    1:         characterDataHandler(handlerArg, dataBuf, 0);
    1: #endif
    1:       else if (defaultHandler)
    1:         reportDefault(parser, enc, s, next);
    1:       *startPtr = next;
    1:       *nextPtr = next;
    1:       if (ps_parsing == XML_FINISHED)
    1:         return XML_ERROR_ABORTED;
    1:       else
    1:         return XML_ERROR_NONE;
    1:     case XML_TOK_DATA_NEWLINE:
    1:       if (characterDataHandler) {
    1:         XML_Char c = 0xA;
    1:         characterDataHandler(handlerArg, &c, 1);
    1:       }
    1:       else if (defaultHandler)
    1:         reportDefault(parser, enc, s, next);
    1:       break;
    1:     case XML_TOK_DATA_CHARS:
    1:       if (characterDataHandler) {
    1:         if (MUST_CONVERT(enc, s)) {
    1:           for (;;) {
    1:             ICHAR *dataPtr = (ICHAR *)dataBuf;
    1:             XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
    1:             *eventEndPP = next;
    1:             characterDataHandler(handlerArg, dataBuf,
    1:                                  (int)(dataPtr - (ICHAR *)dataBuf));
    1:             if (s == next)
    1:               break;
    1:             *eventPP = s;
    1:           }
    1:         }
    1:         else
    1:           characterDataHandler(handlerArg,
    1:                                (XML_Char *)s,
    1:                                (int)((XML_Char *)next - (XML_Char *)s));
    1:       }
    1:       else if (defaultHandler)
    1:         reportDefault(parser, enc, s, next);
    1:       break;
    1:     case XML_TOK_INVALID:
    1:       *eventPP = next;
    1:       return XML_ERROR_INVALID_TOKEN;
    1:     case XML_TOK_PARTIAL_CHAR:
    1:       if (haveMore) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       return XML_ERROR_PARTIAL_CHAR;
    1:     case XML_TOK_PARTIAL:
    1:     case XML_TOK_NONE:
    1:       if (haveMore) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       return XML_ERROR_UNCLOSED_CDATA_SECTION;
    1:     default:
    1:       *eventPP = next;
    1:       return XML_ERROR_UNEXPECTED_STATE;
    1:     }
    1: 
    1:     *eventPP = s = next;
    1:     switch (ps_parsing) {
    1:     case XML_SUSPENDED:
    1:       *nextPtr = next;
    1:       return XML_ERROR_NONE;
    1:     case XML_FINISHED:
    1:       return XML_ERROR_ABORTED;
    1:     default: ;
    1:     }
    1:   }
    1:   /* not reached */
    1: }
    1: 
    1: #ifdef XML_DTD
    1: 
    1: /* The idea here is to avoid using stack for each IGNORE section when
    1:    the whole file is parsed with one call.
    1: */
    1: static enum XML_Error PTRCALL
    1: ignoreSectionProcessor(XML_Parser parser,
    1:                        const char *start,
    1:                        const char *end,
    1:                        const char **endPtr)
    1: {
    1:   enum XML_Error result = doIgnoreSection(parser, encoding, &start, end, 
    1:                                           endPtr, (XML_Bool)!ps_finalBuffer);
    1:   if (result != XML_ERROR_NONE)
    1:     return result;
    1:   if (start) {
    1:     processor = prologProcessor;
    1:     return prologProcessor(parser, start, end, endPtr);
    1:   }
    1:   return result;
    1: }
    1: 
    1: /* startPtr gets set to non-null is the section is closed, and to null
    1:    if the section is not yet closed.
    1: */
    1: static enum XML_Error
    1: doIgnoreSection(XML_Parser parser,
    1:                 const ENCODING *enc,
    1:                 const char **startPtr,
    1:                 const char *end,
    1:                 const char **nextPtr,
    1:                 XML_Bool haveMore)
    1: {
    1:   const char *next;
    1:   int tok;
    1:   const char *s = *startPtr;
    1:   const char **eventPP;
    1:   const char **eventEndPP;
    1:   if (enc == encoding) {
    1:     eventPP = &eventPtr;
    1:     *eventPP = s;
    1:     eventEndPP = &eventEndPtr;
    1:   }
    1:   else {
    1:     eventPP = &(openInternalEntities->internalEventPtr);
    1:     eventEndPP = &(openInternalEntities->internalEventEndPtr);
    1:   }
    1:   *eventPP = s;
    1:   *startPtr = NULL;
    1:   tok = XmlIgnoreSectionTok(enc, s, end, &next);
    1:   *eventEndPP = next;
    1:   switch (tok) {
    1:   case XML_TOK_IGNORE_SECT:
    1:     if (defaultHandler)
    1:       reportDefault(parser, enc, s, next);
    1:     *startPtr = next;
    1:     *nextPtr = next;
    1:     if (ps_parsing == XML_FINISHED)
    1:       return XML_ERROR_ABORTED;
    1:     else
    1:       return XML_ERROR_NONE;
    1:   case XML_TOK_INVALID:
    1:     *eventPP = next;
    1:     return XML_ERROR_INVALID_TOKEN;
    1:   case XML_TOK_PARTIAL_CHAR:
    1:     if (haveMore) {
    1:       *nextPtr = s;
    1:       return XML_ERROR_NONE;
    1:     }
    1:     return XML_ERROR_PARTIAL_CHAR;
    1:   case XML_TOK_PARTIAL:
    1:   case XML_TOK_NONE:
    1:     if (haveMore) {
    1:       *nextPtr = s;
    1:       return XML_ERROR_NONE;
    1:     }
    1:     return XML_ERROR_SYNTAX; /* XML_ERROR_UNCLOSED_IGNORE_SECTION */
    1:   default:
    1:     *eventPP = next;
    1:     return XML_ERROR_UNEXPECTED_STATE;
    1:   }
    1:   /* not reached */
    1: }
    1: 
    1: #endif /* XML_DTD */
    1: 
    1: static enum XML_Error
    1: initializeEncoding(XML_Parser parser)
    1: {
    1:   const char *s;
    1: #ifdef XML_UNICODE
    1:   char encodingBuf[128];
    1:   if (!protocolEncodingName)
    1:     s = NULL;
    1:   else {
    1:     int i;
    1:     for (i = 0; protocolEncodingName[i]; i++) {
    1:       if (i == sizeof(encodingBuf) - 1
    1:           || (protocolEncodingName[i] & ~0x7f) != 0) {
    1:         encodingBuf[0] = '\0';
    1:         break;
    1:       }
    1:       encodingBuf[i] = (char)protocolEncodingName[i];
    1:     }
    1:     encodingBuf[i] = '\0';
    1:     s = encodingBuf;
    1:   }
    1: #else
    1:   s = protocolEncodingName;
    1: #endif
    1:   if ((ns ? XmlInitEncodingNS : XmlInitEncoding)(&initEncoding, &encoding, s))
    1:     return XML_ERROR_NONE;
    1:   return handleUnknownEncoding(parser, protocolEncodingName);
    1: }
    1: 
    1: static enum XML_Error
    1: processXmlDecl(XML_Parser parser, int isGeneralTextEntity,
    1:                const char *s, const char *next)
    1: {
    1:   const char *encodingName = NULL;
    1:   const XML_Char *storedEncName = NULL;
    1:   const ENCODING *newEncoding = NULL;
    1:   const char *version = NULL;
    1:   const char *versionend;
    1:   const XML_Char *storedversion = NULL;
    1:   int standalone = -1;
    1:   if (!(ns
    1:         ? XmlParseXmlDeclNS
    1:         : XmlParseXmlDecl)(isGeneralTextEntity,
    1:                            encoding,
    1:                            s,
    1:                            next,
    1:                            &eventPtr,
    1:                            &version,
    1:                            &versionend,
    1:                            &encodingName,
    1:                            &newEncoding,
    1:                            &standalone)) {
    1:     if (isGeneralTextEntity)
    1:       return XML_ERROR_TEXT_DECL;
    1:     else
    1:       return XML_ERROR_XML_DECL;
    1:   }
    1:   if (!isGeneralTextEntity && standalone == 1) {
    1:     _dtd->standalone = XML_TRUE;
    1: #ifdef XML_DTD
    1:     if (paramEntityParsing == XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)
    1:       paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
    1: #endif /* XML_DTD */
    1:   }
    1:   if (xmlDeclHandler) {
    1:     if (encodingName != NULL) {
    1:       storedEncName = poolStoreString(&temp2Pool,
    1:                                       encoding,
    1:                                       encodingName,
    1:                                       encodingName
    1:                                       + XmlNameLength(encoding, encodingName));
    1:       if (!storedEncName)
    1:               return XML_ERROR_NO_MEMORY;
    1:       poolFinish(&temp2Pool);
    1:     }
    1:     if (version) {
    1:       storedversion = poolStoreString(&temp2Pool,
    1:                                       encoding,
    1:                                       version,
    1:                                       versionend - encoding->minBytesPerChar);
    1:       if (!storedversion)
    1:         return XML_ERROR_NO_MEMORY;
    1:     }
    1:     xmlDeclHandler(handlerArg, storedversion, storedEncName, standalone);
    1:   }
    1:   else if (defaultHandler)
    1:     reportDefault(parser, encoding, s, next);
    1:   if (protocolEncodingName == NULL) {
    1:     if (newEncoding) {
    1:       if (newEncoding->minBytesPerChar != encoding->minBytesPerChar) {
    1:         eventPtr = encodingName;
    1:         return XML_ERROR_INCORRECT_ENCODING;
    1:       }
    1:       encoding = newEncoding;
    1:     }
    1:     else if (encodingName) {
    1:       enum XML_Error result;
    1:       if (!storedEncName) {
    1:         storedEncName = poolStoreString(
    1:           &temp2Pool, encoding, encodingName,
    1:           encodingName + XmlNameLength(encoding, encodingName));
    1:         if (!storedEncName)
    1:           return XML_ERROR_NO_MEMORY;
    1:       }
    1:       result = handleUnknownEncoding(parser, storedEncName);
    1:       poolClear(&temp2Pool);
    1:       if (result == XML_ERROR_UNKNOWN_ENCODING)
    1:         eventPtr = encodingName;
    1:       return result;
    1:     }
    1:   }
    1: 
    1:   if (storedEncName || storedversion)
    1:     poolClear(&temp2Pool);
    1: 
    1:   return XML_ERROR_NONE;
    1: }
    1: 
    1: static enum XML_Error
    1: handleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName)
    1: {
    1:   if (unknownEncodingHandler) {
    1:     XML_Encoding info;
    1:     int i;
    1:     for (i = 0; i < 256; i++)
    1:       info.map[i] = -1;
    1:     info.convert = NULL;
    1:     info.data = NULL;
    1:     info.release = NULL;
    1:     if (unknownEncodingHandler(unknownEncodingHandlerData, encodingName,
    1:                                &info)) {
    1:       ENCODING *enc;
    1:       unknownEncodingMem = MALLOC(XmlSizeOfUnknownEncoding());
    1:       if (!unknownEncodingMem) {
    1:         if (info.release)
    1:           info.release(info.data);
    1:         return XML_ERROR_NO_MEMORY;
    1:       }
    1:       enc = (ns
    1:              ? XmlInitUnknownEncodingNS
    1:              : XmlInitUnknownEncoding)(unknownEncodingMem,
    1:                                        info.map,
    1:                                        info.convert,
    1:                                        info.data);
    1:       if (enc) {
    1:         unknownEncodingData = info.data;
    1:         unknownEncodingRelease = info.release;
    1:         encoding = enc;
    1:         return XML_ERROR_NONE;
    1:       }
    1:     }
    1:     if (info.release != NULL)
    1:       info.release(info.data);
    1:   }
    1:   return XML_ERROR_UNKNOWN_ENCODING;
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: prologInitProcessor(XML_Parser parser,
    1:                     const char *s,
    1:                     const char *end,
    1:                     const char **nextPtr)
    1: {
    1:   enum XML_Error result = initializeEncoding(parser);
    1:   if (result != XML_ERROR_NONE)
    1:     return result;
    1:   processor = prologProcessor;
    1:   return prologProcessor(parser, s, end, nextPtr);
    1: }
    1: 
    1: #ifdef XML_DTD
    1: 
    1: static enum XML_Error PTRCALL
    1: externalParEntInitProcessor(XML_Parser parser,
    1:                             const char *s,
    1:                             const char *end,
    1:                             const char **nextPtr)
    1: {
    1:   enum XML_Error result = initializeEncoding(parser);
    1:   if (result != XML_ERROR_NONE)
    1:     return result;
    1: 
    1:   /* we know now that XML_Parse(Buffer) has been called,
    1:      so we consider the external parameter entity read */
    1:   _dtd->paramEntityRead = XML_TRUE;
    1: 
    1:   if (prologState.inEntityValue) {
    1:     processor = entityValueInitProcessor;
    1:     return entityValueInitProcessor(parser, s, end, nextPtr);
    1:   }
    1:   else {
    1:     processor = externalParEntProcessor;
    1:     return externalParEntProcessor(parser, s, end, nextPtr);
    1:   }
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: entityValueInitProcessor(XML_Parser parser,
    1:                          const char *s,
    1:                          const char *end,
    1:                          const char **nextPtr)
    1: {
    1:   int tok;
    1:   const char *start = s;
    1:   const char *next = start;
    1:   eventPtr = start;
    1: 
    1:   for (;;) {  
    1:     tok = XmlPrologTok(encoding, start, end, &next);
    1:     eventEndPtr = next;
    1:     if (tok <= 0) {
    1:       if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       switch (tok) {
    1:       case XML_TOK_INVALID:
    1:         return XML_ERROR_INVALID_TOKEN;
    1:       case XML_TOK_PARTIAL:
    1:         return XML_ERROR_UNCLOSED_TOKEN;
    1:       case XML_TOK_PARTIAL_CHAR:
    1:         return XML_ERROR_PARTIAL_CHAR;
    1:       case XML_TOK_NONE:   /* start == end */
    1:       default:
    1:         break;
    1:       }
    1:       /* found end of entity value - can store it now */
    1:       return storeEntityValue(parser, encoding, s, end);
    1:     }
    1:     else if (tok == XML_TOK_XML_DECL) {
    1:       enum XML_Error result;
    1:       result = processXmlDecl(parser, 0, start, next);
    1:       if (result != XML_ERROR_NONE)
    1:         return result;
    1:       switch (ps_parsing) {
    1:       case XML_SUSPENDED: 
    1:         *nextPtr = next;
    1:         return XML_ERROR_NONE;
    1:       case XML_FINISHED:
    1:         return XML_ERROR_ABORTED;
    1:       default:
    1:         *nextPtr = next;
    1:       }
    1:       /* stop scanning for text declaration - we found one */
    1:       processor = entityValueProcessor;
    1:       return entityValueProcessor(parser, next, end, nextPtr);
    1:     }
    1:     /* If we are at the end of the buffer, this would cause XmlPrologTok to
    1:        return XML_TOK_NONE on the next call, which would then cause the
    1:        function to exit with *nextPtr set to s - that is what we want for other
    1:        tokens, but not for the BOM - we would rather like to skip it;
    1:        then, when this routine is entered the next time, XmlPrologTok will
    1:        return XML_TOK_INVALID, since the BOM is still in the buffer
    1:     */
    1:     else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {
    1:       *nextPtr = next;
    1:       return XML_ERROR_NONE;
    1:     }
    1:     start = next;
    1:     eventPtr = start;
    1:   }
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: externalParEntProcessor(XML_Parser parser,
    1:                         const char *s,
    1:                         const char *end,
    1:                         const char **nextPtr)
    1: {
    1:   const char *next = s;
    1:   int tok;
    1: 
    1:   tok = XmlPrologTok(encoding, s, end, &next);
    1:   if (tok <= 0) {
    1:     if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
    1:       *nextPtr = s;
    1:       return XML_ERROR_NONE;
    1:     }
    1:     switch (tok) {
    1:     case XML_TOK_INVALID:
    1:       return XML_ERROR_INVALID_TOKEN;
    1:     case XML_TOK_PARTIAL:
    1:       return XML_ERROR_UNCLOSED_TOKEN;
    1:     case XML_TOK_PARTIAL_CHAR:
    1:       return XML_ERROR_PARTIAL_CHAR;
    1:     case XML_TOK_NONE:   /* start == end */
    1:     default:
    1:       break;
    1:     }
    1:   }
    1:   /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.
    1:      However, when parsing an external subset, doProlog will not accept a BOM
    1:      as valid, and report a syntax error, so we have to skip the BOM
    1:   */
    1:   else if (tok == XML_TOK_BOM) {
    1:     s = next;
    1:     tok = XmlPrologTok(encoding, s, end, &next);
    1:   }
    1: 
    1:   processor = prologProcessor;
    1:   return doProlog(parser, encoding, s, end, tok, next, 
    1:                   nextPtr, (XML_Bool)!ps_finalBuffer);
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: entityValueProcessor(XML_Parser parser,
    1:                      const char *s,
    1:                      const char *end,
    1:                      const char **nextPtr)
    1: {
    1:   const char *start = s;
    1:   const char *next = s;
    1:   const ENCODING *enc = encoding;
    1:   int tok;
    1: 
    1:   for (;;) {
    1:     tok = XmlPrologTok(enc, start, end, &next);
    1:     if (tok <= 0) {
    1:       if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       switch (tok) {
    1:       case XML_TOK_INVALID:
    1:         return XML_ERROR_INVALID_TOKEN;
    1:       case XML_TOK_PARTIAL:
    1:         return XML_ERROR_UNCLOSED_TOKEN;
    1:       case XML_TOK_PARTIAL_CHAR:
    1:         return XML_ERROR_PARTIAL_CHAR;
    1:       case XML_TOK_NONE:   /* start == end */
    1:       default:
    1:         break;
    1:       }
    1:       /* found end of entity value - can store it now */
    1:       return storeEntityValue(parser, enc, s, end);
    1:     }
    1:     start = next;
    1:   }
    1: }
    1: 
    1: #endif /* XML_DTD */
    1: 
    1: static enum XML_Error PTRCALL
    1: prologProcessor(XML_Parser parser,
    1:                 const char *s,
    1:                 const char *end,
    1:                 const char **nextPtr)
    1: {
    1:   const char *next = s;
    1:   int tok = XmlPrologTok(encoding, s, end, &next);
    1:   return doProlog(parser, encoding, s, end, tok, next, 
    1:                   nextPtr, (XML_Bool)!ps_finalBuffer);
    1: }
    1: 
    1: static enum XML_Error
    1: doProlog(XML_Parser parser,
    1:          const ENCODING *enc,
    1:          const char *s,
    1:          const char *end,
    1:          int tok,
    1:          const char *next,
    1:          const char **nextPtr,
    1:          XML_Bool haveMore)
    1: {
    1: #ifdef XML_DTD
    1:   static const XML_Char externalSubsetName[] = { '#' , '\0' };
    1: #endif /* XML_DTD */
    1:   static const XML_Char atypeCDATA[] = { 'C', 'D', 'A', 'T', 'A', '\0' };
    1:   static const XML_Char atypeID[] = { 'I', 'D', '\0' };
    1:   static const XML_Char atypeIDREF[] = { 'I', 'D', 'R', 'E', 'F', '\0' };
    1:   static const XML_Char atypeIDREFS[] = { 'I', 'D', 'R', 'E', 'F', 'S', '\0' };
    1:   static const XML_Char atypeENTITY[] = { 'E', 'N', 'T', 'I', 'T', 'Y', '\0' };
    1:   static const XML_Char atypeENTITIES[] =
    1:       { 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S', '\0' };
    1:   static const XML_Char atypeNMTOKEN[] = {
    1:       'N', 'M', 'T', 'O', 'K', 'E', 'N', '\0' };
    1:   static const XML_Char atypeNMTOKENS[] = {
    1:       'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S', '\0' };
    1:   static const XML_Char notationPrefix[] = {
    1:       'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N', '(', '\0' };
    1:   static const XML_Char enumValueSep[] = { '|', '\0' };
    1:   static const XML_Char enumValueStart[] = { '(', '\0' };
    1: 
    1:   /* save one level of indirection */
    1:   DTD * const dtd = _dtd; 
    1: 
    1:   const char **eventPP;
    1:   const char **eventEndPP;
    1:   enum XML_Content_Quant quant;
    1: 
    1:   if (enc == encoding) {
    1:     eventPP = &eventPtr;
    1:     eventEndPP = &eventEndPtr;
    1:   }
    1:   else {
    1:     eventPP = &(openInternalEntities->internalEventPtr);
    1:     eventEndPP = &(openInternalEntities->internalEventEndPtr);
    1:   }
    1: 
    1:   for (;;) {
    1:     int role;
    1:     XML_Bool handleDefault = XML_TRUE;
    1:     *eventPP = s;
    1:     *eventEndPP = next;
    1:     if (tok <= 0) {
    1:       if (haveMore && tok != XML_TOK_INVALID) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       switch (tok) {
    1:       case XML_TOK_INVALID:
    1:         *eventPP = next;
    1:         return XML_ERROR_INVALID_TOKEN;
    1:       case XML_TOK_PARTIAL:
    1:         return XML_ERROR_UNCLOSED_TOKEN;
    1:       case XML_TOK_PARTIAL_CHAR:
    1:         return XML_ERROR_PARTIAL_CHAR;
    1:       case XML_TOK_NONE:
    1: #ifdef XML_DTD
    1:         /* for internal PE NOT referenced between declarations */
    1:         if (enc != encoding && !openInternalEntities->betweenDecl) {
    1:           *nextPtr = s;
    1:           return XML_ERROR_NONE;
    1:         }
    1:         /* WFC: PE Between Declarations - must check that PE contains
    1:            complete markup, not only for external PEs, but also for
    1:            internal PEs if the reference occurs between declarations.
    1:         */
    1:         if (isParamEntity || enc != encoding) {
    1:           if (XmlTokenRole(&prologState, XML_TOK_NONE, end, end, enc)
    1:               == XML_ROLE_ERROR)
    1:             return XML_ERROR_INCOMPLETE_PE;
    1:           *nextPtr = s;
    1:           return XML_ERROR_NONE;
    1:         }
    1: #endif /* XML_DTD */
    1:         return XML_ERROR_NO_ELEMENTS;
    1:       default:
    1:         tok = -tok;
    1:         next = end;
    1:         break;
    1:       }
    1:     }
    1:     role = XmlTokenRole(&prologState, tok, s, next, enc);
    1:     switch (role) {
    1:     case XML_ROLE_XML_DECL:
    1:       {
    1:         enum XML_Error result = processXmlDecl(parser, 0, s, next);
    1:         if (result != XML_ERROR_NONE)
    1:           return result;
    1:         enc = encoding;
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1:     case XML_ROLE_DOCTYPE_NAME:
    1:       if (startDoctypeDeclHandler) {
    1:         doctypeName = poolStoreString(&tempPool, enc, s, next);
    1:         if (!doctypeName)
    1:           return XML_ERROR_NO_MEMORY;
    1:         poolFinish(&tempPool);
    1:         doctypePubid = NULL;
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       doctypeSysid = NULL; /* always initialize to NULL */
    1:       break;
    1:     case XML_ROLE_DOCTYPE_INTERNAL_SUBSET:
    1:       if (startDoctypeDeclHandler) {
    1:         startDoctypeDeclHandler(handlerArg, doctypeName, doctypeSysid,
    1:                                 doctypePubid, 1);
    1:         doctypeName = NULL;
    1:         poolClear(&tempPool);
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1: #ifdef XML_DTD
    1:     case XML_ROLE_TEXT_DECL:
    1:       {
    1:         enum XML_Error result = processXmlDecl(parser, 1, s, next);
    1:         if (result != XML_ERROR_NONE)
    1:           return result;
    1:         enc = encoding;
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1: #endif /* XML_DTD */
    1:     case XML_ROLE_DOCTYPE_PUBLIC_ID:
    1: #ifdef XML_DTD
    1:       useForeignDTD = XML_FALSE;
    1:       declEntity = (ENTITY *)lookup(&dtd->paramEntities,
    1:                                     externalSubsetName,
    1:                                     sizeof(ENTITY));
    1:       if (!declEntity)
    1:         return XML_ERROR_NO_MEMORY;
    1: #endif /* XML_DTD */
    1:       dtd->hasParamEntityRefs = XML_TRUE;
    1:       if (startDoctypeDeclHandler) {
    1:         if (!XmlIsPublicId(enc, s, next, eventPP))
    1:           return XML_ERROR_PUBLICID;
    1:         doctypePubid = poolStoreString(&tempPool, enc,
    1:                                        s + enc->minBytesPerChar,
    1:                                        next - enc->minBytesPerChar);
    1:         if (!doctypePubid)
    1:           return XML_ERROR_NO_MEMORY;
    1:         normalizePublicId((XML_Char *)doctypePubid);
    1:         poolFinish(&tempPool);
    1:         handleDefault = XML_FALSE;
    1:         goto alreadyChecked;
    1:       }
    1:       /* fall through */
    1:     case XML_ROLE_ENTITY_PUBLIC_ID:
    1:       if (!XmlIsPublicId(enc, s, next, eventPP))
    1:         return XML_ERROR_PUBLICID;
    1:     alreadyChecked:
    1:       if (dtd->keepProcessing && declEntity) {
    1:         XML_Char *tem = poolStoreString(&dtd->pool,
    1:                                         enc,
    1:                                         s + enc->minBytesPerChar,
    1:                                         next - enc->minBytesPerChar);
    1:         if (!tem)
    1:           return XML_ERROR_NO_MEMORY;
    1:         normalizePublicId(tem);
    1:         declEntity->publicId = tem;
    1:         poolFinish(&dtd->pool);
    1:         if (entityDeclHandler)
    1:           handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1:     case XML_ROLE_DOCTYPE_CLOSE:
    1:       if (doctypeName) {
    1:         startDoctypeDeclHandler(handlerArg, doctypeName,
    1:                                 doctypeSysid, doctypePubid, 0);
    1:         poolClear(&tempPool);
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       /* doctypeSysid will be non-NULL in the case of a previous
    1:          XML_ROLE_DOCTYPE_SYSTEM_ID, even if startDoctypeDeclHandler
    1:          was not set, indicating an external subset
    1:       */
    1: #ifdef XML_DTD
    1:       if (doctypeSysid || useForeignDTD) {
    1:         XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;
    1:         dtd->hasParamEntityRefs = XML_TRUE;
    1:         if (paramEntityParsing && externalEntityRefHandler) {
    1:           ENTITY *entity = (ENTITY *)lookup(&dtd->paramEntities,
    1:                                             externalSubsetName,
    1:                                             sizeof(ENTITY));
    1:           if (!entity)
    1:             return XML_ERROR_NO_MEMORY;
    1:           if (useForeignDTD)
    1:             entity->base = curBase;
    1:           dtd->paramEntityRead = XML_FALSE;
    1:           if (!externalEntityRefHandler(externalEntityRefHandlerArg,
    1:                                         0,
    1:                                         entity->base,
    1:                                         entity->systemId,
    1:                                         entity->publicId))
    1:             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
    1:           if (dtd->paramEntityRead) {
    1:             if (!dtd->standalone && 
    1:                 notStandaloneHandler && 
    1:                 !notStandaloneHandler(handlerArg))
    1:               return XML_ERROR_NOT_STANDALONE;
    1:           }
    1:           /* if we didn't read the foreign DTD then this means that there
    1:              is no external subset and we must reset dtd->hasParamEntityRefs
    1:           */
    1:           else if (!doctypeSysid)
    1:             dtd->hasParamEntityRefs = hadParamEntityRefs;
    1:           /* end of DTD - no need to update dtd->keepProcessing */
    1:         }
    1:         useForeignDTD = XML_FALSE;
    1:       }
    1: #endif /* XML_DTD */
    1:       if (endDoctypeDeclHandler) {
    1:         endDoctypeDeclHandler(handlerArg);
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1:     case XML_ROLE_INSTANCE_START:
    1: #ifdef XML_DTD
    1:       /* if there is no DOCTYPE declaration then now is the
    1:          last chance to read the foreign DTD
    1:       */
    1:       if (useForeignDTD) {
    1:         XML_Bool hadParamEntityRefs = dtd->hasParamEntityRefs;
    1:         dtd->hasParamEntityRefs = XML_TRUE;
    1:         if (paramEntityParsing && externalEntityRefHandler) {
    1:           ENTITY *entity = (ENTITY *)lookup(&dtd->paramEntities,
    1:                                             externalSubsetName,
    1:                                             sizeof(ENTITY));
    1:           if (!entity)
    1:             return XML_ERROR_NO_MEMORY;
    1:           entity->base = curBase;
    1:           dtd->paramEntityRead = XML_FALSE;
    1:           if (!externalEntityRefHandler(externalEntityRefHandlerArg,
    1:                                         0,
    1:                                         entity->base,
    1:                                         entity->systemId,
    1:                                         entity->publicId))
    1:             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
    1:           if (dtd->paramEntityRead) {
    1:             if (!dtd->standalone &&
    1:                 notStandaloneHandler &&
    1:                 !notStandaloneHandler(handlerArg))
    1:               return XML_ERROR_NOT_STANDALONE;
    1:           }
    1:           /* if we didn't read the foreign DTD then this means that there
    1:              is no external subset and we must reset dtd->hasParamEntityRefs
    1:           */
    1:           else
    1:             dtd->hasParamEntityRefs = hadParamEntityRefs;
    1:           /* end of DTD - no need to update dtd->keepProcessing */
    1:         }
    1:       }
    1: #endif /* XML_DTD */
    1:       processor = contentProcessor;
    1:       return contentProcessor(parser, s, end, nextPtr);
    1:     case XML_ROLE_ATTLIST_ELEMENT_NAME:
    1:       declElementType = getElementType(parser, enc, s, next);
    1:       if (!declElementType)
    1:         return XML_ERROR_NO_MEMORY;
    1:       goto checkAttListDeclHandler;
    1:     case XML_ROLE_ATTRIBUTE_NAME:
    1:       declAttributeId = getAttributeId(parser, enc, s, next);
    1:       if (!declAttributeId)
    1:         return XML_ERROR_NO_MEMORY;
    1:       declAttributeIsCdata = XML_FALSE;
    1:       declAttributeType = NULL;
    1:       declAttributeIsId = XML_FALSE;
    1:       goto checkAttListDeclHandler;
    1:     case XML_ROLE_ATTRIBUTE_TYPE_CDATA:
    1:       declAttributeIsCdata = XML_TRUE;
    1:       declAttributeType = atypeCDATA;
    1:       goto checkAttListDeclHandler;
    1:     case XML_ROLE_ATTRIBUTE_TYPE_ID:
    1:       declAttributeIsId = XML_TRUE;
    1:       declAttributeType = atypeID;
    1:       goto checkAttListDeclHandler;
    1:     case XML_ROLE_ATTRIBUTE_TYPE_IDREF:
    1:       declAttributeType = atypeIDREF;
    1:       goto checkAttListDeclHandler;
    1:     case XML_ROLE_ATTRIBUTE_TYPE_IDREFS:
    1:       declAttributeType = atypeIDREFS;
    1:       goto checkAttListDeclHandler;
    1:     case XML_ROLE_ATTRIBUTE_TYPE_ENTITY:
    1:       declAttributeType = atypeENTITY;
    1:       goto checkAttListDeclHandler;
    1:     case XML_ROLE_ATTRIBUTE_TYPE_ENTITIES:
    1:       declAttributeType = atypeENTITIES;
    1:       goto checkAttListDeclHandler;
    1:     case XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN:
    1:       declAttributeType = atypeNMTOKEN;
    1:       goto checkAttListDeclHandler;
    1:     case XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS:
    1:       declAttributeType = atypeNMTOKENS;
    1:     checkAttListDeclHandler:
    1:       if (dtd->keepProcessing && attlistDeclHandler)
    1:         handleDefault = XML_FALSE;
    1:       break;
    1:     case XML_ROLE_ATTRIBUTE_ENUM_VALUE:
    1:     case XML_ROLE_ATTRIBUTE_NOTATION_VALUE:
    1:       if (dtd->keepProcessing && attlistDeclHandler) {
    1:         const XML_Char *prefix;
    1:         if (declAttributeType) {
    1:           prefix = enumValueSep;
    1:         }
    1:         else {
    1:           prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE
    1:                     ? notationPrefix
    1:                     : enumValueStart);
    1:         }
    1:         if (!poolAppendString(&tempPool, prefix))
    1:           return XML_ERROR_NO_MEMORY;
    1:         if (!poolAppend(&tempPool, enc, s, next))
    1:           return XML_ERROR_NO_MEMORY;
    1:         declAttributeType = tempPool.start;
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1:     case XML_ROLE_IMPLIED_ATTRIBUTE_VALUE:
    1:     case XML_ROLE_REQUIRED_ATTRIBUTE_VALUE:
    1:       if (dtd->keepProcessing) {
    1:         if (!defineAttribute(declElementType, declAttributeId,
    1:                              declAttributeIsCdata, declAttributeIsId,
    1:                              0, parser))
    1:           return XML_ERROR_NO_MEMORY;
    1:         if (attlistDeclHandler && declAttributeType) {
    1:           if (*declAttributeType == XML_T('(')
    1:               || (*declAttributeType == XML_T('N')
    1:                   && declAttributeType[1] == XML_T('O'))) {
    1:             /* Enumerated or Notation type */
    1:             if (!poolAppendChar(&tempPool, XML_T(')'))
    1:                 || !poolAppendChar(&tempPool, XML_T('\0')))
    1:               return XML_ERROR_NO_MEMORY;
    1:             declAttributeType = tempPool.start;
    1:             poolFinish(&tempPool);
    1:           }
    1:           *eventEndPP = s;
    1:           attlistDeclHandler(handlerArg, declElementType->name,
    1:                              declAttributeId->name, declAttributeType,
    1:                              0, role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);
    1:           poolClear(&tempPool);
    1:           handleDefault = XML_FALSE;
    1:         }
    1:       }
    1:       break;
    1:     case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:
    1:     case XML_ROLE_FIXED_ATTRIBUTE_VALUE:
    1:       if (dtd->keepProcessing) {
    1:         const XML_Char *attVal;
    1:         enum XML_Error result =
    1:           storeAttributeValue(parser, enc, declAttributeIsCdata,
    1:                               s + enc->minBytesPerChar,
    1:                               next - enc->minBytesPerChar,
    1:                               &dtd->pool);
    1:         if (result)
    1:           return result;
    1:         attVal = poolStart(&dtd->pool);
    1:         poolFinish(&dtd->pool);
    1:         /* ID attributes aren't allowed to have a default */
    1:         if (!defineAttribute(declElementType, declAttributeId,
    1:                              declAttributeIsCdata, XML_FALSE, attVal, parser))
    1:           return XML_ERROR_NO_MEMORY;
    1:         if (attlistDeclHandler && declAttributeType) {
    1:           if (*declAttributeType == XML_T('(')
    1:               || (*declAttributeType == XML_T('N')
    1:                   && declAttributeType[1] == XML_T('O'))) {
    1:             /* Enumerated or Notation type */
    1:             if (!poolAppendChar(&tempPool, XML_T(')'))
    1:                 || !poolAppendChar(&tempPool, XML_T('\0')))
    1:               return XML_ERROR_NO_MEMORY;
    1:             declAttributeType = tempPool.start;
    1:             poolFinish(&tempPool);
    1:           }
    1:           *eventEndPP = s;
    1:           attlistDeclHandler(handlerArg, declElementType->name,
    1:                              declAttributeId->name, declAttributeType,
    1:                              attVal,
    1:                              role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);
    1:           poolClear(&tempPool);
    1:           handleDefault = XML_FALSE;
    1:         }
    1:       }
    1:       break;
    1:     case XML_ROLE_ENTITY_VALUE:
    1:       if (dtd->keepProcessing) {
    1:         enum XML_Error result = storeEntityValue(parser, enc,
    1:                                             s + enc->minBytesPerChar,
    1:                                             next - enc->minBytesPerChar);
    1:         if (declEntity) {
    1:           declEntity->textPtr = poolStart(&dtd->entityValuePool);
    1:           declEntity->textLen = (int)(poolLength(&dtd->entityValuePool));
    1:           poolFinish(&dtd->entityValuePool);
    1:           if (entityDeclHandler) {
    1:             *eventEndPP = s;
    1:             entityDeclHandler(handlerArg,
    1:                               declEntity->name,
    1:                               declEntity->is_param,
    1:                               declEntity->textPtr,
    1:                               declEntity->textLen,
    1:                               curBase, 0, 0, 0);
    1:             handleDefault = XML_FALSE;
    1:           }
    1:         }
    1:         else
    1:           poolDiscard(&dtd->entityValuePool);
    1:         if (result != XML_ERROR_NONE)
    1:           return result;
    1:       }
    1:       break;
    1:     case XML_ROLE_DOCTYPE_SYSTEM_ID:
    1: #ifdef XML_DTD
    1:       useForeignDTD = XML_FALSE;
    1: #endif /* XML_DTD */
    1:       dtd->hasParamEntityRefs = XML_TRUE;
    1:       if (startDoctypeDeclHandler) {
    1:         doctypeSysid = poolStoreString(&tempPool, enc,
    1:                                        s + enc->minBytesPerChar,
    1:                                        next - enc->minBytesPerChar);
    1:         if (doctypeSysid == NULL)
    1:           return XML_ERROR_NO_MEMORY;
    1:         poolFinish(&tempPool);
    1:         handleDefault = XML_FALSE;
    1:       }
    1: #ifdef XML_DTD
    1:       else
    1:         /* use externalSubsetName to make doctypeSysid non-NULL
    1:            for the case where no startDoctypeDeclHandler is set */
    1:         doctypeSysid = externalSubsetName;
    1: #endif /* XML_DTD */
    1:       if (!dtd->standalone
    1: #ifdef XML_DTD
    1:           && !paramEntityParsing
    1: #endif /* XML_DTD */
    1:           && notStandaloneHandler
    1:           && !notStandaloneHandler(handlerArg))
    1:         return XML_ERROR_NOT_STANDALONE;
    1: #ifndef XML_DTD
    1:       break;
    1: #else /* XML_DTD */
    1:       if (!declEntity) {
    1:         declEntity = (ENTITY *)lookup(&dtd->paramEntities,
    1:                                       externalSubsetName,
    1:                                       sizeof(ENTITY));
    1:         if (!declEntity)
    1:           return XML_ERROR_NO_MEMORY;
    1:         declEntity->publicId = NULL;
    1:       }
    1:       /* fall through */
    1: #endif /* XML_DTD */
    1:     case XML_ROLE_ENTITY_SYSTEM_ID:
    1:       if (dtd->keepProcessing && declEntity) {
    1:         declEntity->systemId = poolStoreString(&dtd->pool, enc,
    1:                                                s + enc->minBytesPerChar,
    1:                                                next - enc->minBytesPerChar);
    1:         if (!declEntity->systemId)
    1:           return XML_ERROR_NO_MEMORY;
    1:         declEntity->base = curBase;
    1:         poolFinish(&dtd->pool);
    1:         if (entityDeclHandler)
    1:           handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1:     case XML_ROLE_ENTITY_COMPLETE:
    1:       if (dtd->keepProcessing && declEntity && entityDeclHandler) {
    1:         *eventEndPP = s;
    1:         entityDeclHandler(handlerArg,
    1:                           declEntity->name,
    1:                           declEntity->is_param,
    1:                           0,0,
    1:                           declEntity->base,
    1:                           declEntity->systemId,
    1:                           declEntity->publicId,
    1:                           0);
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1:     case XML_ROLE_ENTITY_NOTATION_NAME:
    1:       if (dtd->keepProcessing && declEntity) {
    1:         declEntity->notation = poolStoreString(&dtd->pool, enc, s, next);
    1:         if (!declEntity->notation)
    1:           return XML_ERROR_NO_MEMORY;
    1:         poolFinish(&dtd->pool);
    1:         if (unparsedEntityDeclHandler) {
    1:           *eventEndPP = s;
    1:           unparsedEntityDeclHandler(handlerArg,
    1:                                     declEntity->name,
    1:                                     declEntity->base,
    1:                                     declEntity->systemId,
    1:                                     declEntity->publicId,
    1:                                     declEntity->notation);
    1:           handleDefault = XML_FALSE;
    1:         }
    1:         else if (entityDeclHandler) {
    1:           *eventEndPP = s;
    1:           entityDeclHandler(handlerArg,
    1:                             declEntity->name,
    1:                             0,0,0,
    1:                             declEntity->base,
    1:                             declEntity->systemId,
    1:                             declEntity->publicId,
    1:                             declEntity->notation);
    1:           handleDefault = XML_FALSE;
    1:         }
    1:       }
    1:       break;
    1:     case XML_ROLE_GENERAL_ENTITY_NAME:
    1:       {
    1:         if (XmlPredefinedEntityName(enc, s, next)) {
    1:           declEntity = NULL;
    1:           break;
    1:         }
    1:         if (dtd->keepProcessing) {
    1:           const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
    1:           if (!name)
    1:             return XML_ERROR_NO_MEMORY;
    1:           declEntity = (ENTITY *)lookup(&dtd->generalEntities, name,
    1:                                         sizeof(ENTITY));
    1:           if (!declEntity)
    1:             return XML_ERROR_NO_MEMORY;
    1:           if (declEntity->name != name) {
    1:             poolDiscard(&dtd->pool);
    1:             declEntity = NULL;
    1:           }
    1:           else {
    1:             poolFinish(&dtd->pool);
    1:             declEntity->publicId = NULL;
    1:             declEntity->is_param = XML_FALSE;
    1:             /* if we have a parent parser or are reading an internal parameter
    1:                entity, then the entity declaration is not considered "internal"
    1:             */
    1:             declEntity->is_internal = !(parentParser || openInternalEntities);
    1:             if (entityDeclHandler)
    1:               handleDefault = XML_FALSE;
    1:           }
    1:         }
    1:         else {
    1:           poolDiscard(&dtd->pool);
    1:           declEntity = NULL;
    1:         }
    1:       }
    1:       break;
    1:     case XML_ROLE_PARAM_ENTITY_NAME:
    1: #ifdef XML_DTD
    1:       if (dtd->keepProcessing) {
    1:         const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
    1:         if (!name)
    1:           return XML_ERROR_NO_MEMORY;
    1:         declEntity = (ENTITY *)lookup(&dtd->paramEntities,
    1:                                            name, sizeof(ENTITY));
    1:         if (!declEntity)
    1:           return XML_ERROR_NO_MEMORY;
    1:         if (declEntity->name != name) {
    1:           poolDiscard(&dtd->pool);
    1:           declEntity = NULL;
    1:         }
    1:         else {
    1:           poolFinish(&dtd->pool);
    1:           declEntity->publicId = NULL;
    1:           declEntity->is_param = XML_TRUE;
    1:           /* if we have a parent parser or are reading an internal parameter
    1:              entity, then the entity declaration is not considered "internal"
    1:           */
    1:           declEntity->is_internal = !(parentParser || openInternalEntities);
    1:           if (entityDeclHandler)
    1:             handleDefault = XML_FALSE;
    1:         }
    1:       }
    1:       else {
    1:         poolDiscard(&dtd->pool);
    1:         declEntity = NULL;
    1:       }
    1: #else /* not XML_DTD */
    1:       declEntity = NULL;
    1: #endif /* XML_DTD */
    1:       break;
    1:     case XML_ROLE_NOTATION_NAME:
    1:       declNotationPublicId = NULL;
    1:       declNotationName = NULL;
    1:       if (notationDeclHandler) {
    1:         declNotationName = poolStoreString(&tempPool, enc, s, next);
    1:         if (!declNotationName)
    1:           return XML_ERROR_NO_MEMORY;
    1:         poolFinish(&tempPool);
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1:     case XML_ROLE_NOTATION_PUBLIC_ID:
    1:       if (!XmlIsPublicId(enc, s, next, eventPP))
    1:         return XML_ERROR_PUBLICID;
    1:       if (declNotationName) {  /* means notationDeclHandler != NULL */
    1:         XML_Char *tem = poolStoreString(&tempPool,
    1:                                         enc,
    1:                                         s + enc->minBytesPerChar,
    1:                                         next - enc->minBytesPerChar);
    1:         if (!tem)
    1:           return XML_ERROR_NO_MEMORY;
    1:         normalizePublicId(tem);
    1:         declNotationPublicId = tem;
    1:         poolFinish(&tempPool);
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1:     case XML_ROLE_NOTATION_SYSTEM_ID:
    1:       if (declNotationName && notationDeclHandler) {
    1:         const XML_Char *systemId
    1:           = poolStoreString(&tempPool, enc,
    1:                             s + enc->minBytesPerChar,
    1:                             next - enc->minBytesPerChar);
    1:         if (!systemId)
    1:           return XML_ERROR_NO_MEMORY;
    1:         *eventEndPP = s;
    1:         notationDeclHandler(handlerArg,
    1:                             declNotationName,
    1:                             curBase,
    1:                             systemId,
    1:                             declNotationPublicId);
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       poolClear(&tempPool);
    1:       break;
    1:     case XML_ROLE_NOTATION_NO_SYSTEM_ID:
    1:       if (declNotationPublicId && notationDeclHandler) {
    1:         *eventEndPP = s;
    1:         notationDeclHandler(handlerArg,
    1:                             declNotationName,
    1:                             curBase,
    1:                             0,
    1:                             declNotationPublicId);
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       poolClear(&tempPool);
    1:       break;
    1:     case XML_ROLE_ERROR:
    1:       switch (tok) {
    1:       case XML_TOK_PARAM_ENTITY_REF:
    1:         /* PE references in internal subset are
    1:            not allowed within declarations. */  
    1:         return XML_ERROR_PARAM_ENTITY_REF;
    1:       case XML_TOK_XML_DECL:
    1:         return XML_ERROR_MISPLACED_XML_PI;
    1:       default:
    1:         return XML_ERROR_SYNTAX;
    1:       }
    1: #ifdef XML_DTD
    1:     case XML_ROLE_IGNORE_SECT:
    1:       {
    1:         enum XML_Error result;
    1:         if (defaultHandler)
    1:           reportDefault(parser, enc, s, next);
    1:         handleDefault = XML_FALSE;
    1:         result = doIgnoreSection(parser, enc, &next, end, nextPtr, haveMore);
    1:         if (result != XML_ERROR_NONE)
    1:           return result;
    1:         else if (!next) {
    1:           processor = ignoreSectionProcessor;
    1:           return result;
    1:         }
    1:       }
    1:       break;
    1: #endif /* XML_DTD */
    1:     case XML_ROLE_GROUP_OPEN:
    1:       if (prologState.level >= groupSize) {
    1:         if (groupSize) {
    1:           char *temp = (char *)REALLOC(groupConnector, groupSize *= 2);
    1:           if (temp == NULL)
    1:             return XML_ERROR_NO_MEMORY;
    1:           groupConnector = temp;
    1:           if (dtd->scaffIndex) {
    1:             int *temp = (int *)REALLOC(dtd->scaffIndex,
    1:                           groupSize * sizeof(int));
    1:             if (temp == NULL)
    1:               return XML_ERROR_NO_MEMORY;
    1:             dtd->scaffIndex = temp;
    1:           }
    1:         }
    1:         else {
    1:           groupConnector = (char *)MALLOC(groupSize = 32);
    1:           if (!groupConnector)
    1:             return XML_ERROR_NO_MEMORY;
    1:         }
    1:       }
    1:       groupConnector[prologState.level] = 0;
    1:       if (dtd->in_eldecl) {
    1:         int myindex = nextScaffoldPart(parser);
    1:         if (myindex < 0)
    1:           return XML_ERROR_NO_MEMORY;
    1:         dtd->scaffIndex[dtd->scaffLevel] = myindex;
    1:         dtd->scaffLevel++;
    1:         dtd->scaffold[myindex].type = XML_CTYPE_SEQ;
    1:         if (elementDeclHandler)
    1:           handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1:     case XML_ROLE_GROUP_SEQUENCE:
    1:       if (groupConnector[prologState.level] == '|')
    1:         return XML_ERROR_SYNTAX;
    1:       groupConnector[prologState.level] = ',';
    1:       if (dtd->in_eldecl && elementDeclHandler)
    1:         handleDefault = XML_FALSE;
    1:       break;
    1:     case XML_ROLE_GROUP_CHOICE:
    1:       if (groupConnector[prologState.level] == ',')
    1:         return XML_ERROR_SYNTAX;
    1:       if (dtd->in_eldecl
    1:           && !groupConnector[prologState.level]
    1:           && (dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
    1:               != XML_CTYPE_MIXED)
    1:           ) {
    1:         dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
    1:             = XML_CTYPE_CHOICE;
    1:         if (elementDeclHandler)
    1:           handleDefault = XML_FALSE;
    1:       }
    1:       groupConnector[prologState.level] = '|';
    1:       break;
    1:     case XML_ROLE_PARAM_ENTITY_REF:
    1: #ifdef XML_DTD
    1:     case XML_ROLE_INNER_PARAM_ENTITY_REF:
    1:       dtd->hasParamEntityRefs = XML_TRUE;
    1:       if (!paramEntityParsing)
    1:         dtd->keepProcessing = dtd->standalone;
    1:       else {
    1:         const XML_Char *name;
    1:         ENTITY *entity;
    1:         name = poolStoreString(&dtd->pool, enc,
    1:                                 s + enc->minBytesPerChar,
    1:                                 next - enc->minBytesPerChar);
    1:         if (!name)
    1:           return XML_ERROR_NO_MEMORY;
    1:         entity = (ENTITY *)lookup(&dtd->paramEntities, name, 0);
    1:         poolDiscard(&dtd->pool);
    1:         /* first, determine if a check for an existing declaration is needed;
    1:            if yes, check that the entity exists, and that it is internal,
    1:            otherwise call the skipped entity handler
    1:         */
    1:         if (prologState.documentEntity &&
    1:             (dtd->standalone
    1:              ? !openInternalEntities
    1:              : !dtd->hasParamEntityRefs)) {
    1:           if (!entity)
    1:             return XML_ERROR_UNDEFINED_ENTITY;
    1:           else if (!entity->is_internal)
    1:             return XML_ERROR_ENTITY_DECLARED_IN_PE;
    1:         }
    1:         else if (!entity) {
    1:           dtd->keepProcessing = dtd->standalone;
    1:           /* cannot report skipped entities in declarations */
    1:           if ((role == XML_ROLE_PARAM_ENTITY_REF) && skippedEntityHandler) {
    1:             skippedEntityHandler(handlerArg, name, 1);
    1:             handleDefault = XML_FALSE;
    1:           }
    1:           break;
    1:         }
    1:         if (entity->open)
    1:           return XML_ERROR_RECURSIVE_ENTITY_REF;
    1:         if (entity->textPtr) {
    1:           enum XML_Error result;
    1:           XML_Bool betweenDecl = 
    1:             (role == XML_ROLE_PARAM_ENTITY_REF ? XML_TRUE : XML_FALSE);
    1:           result = processInternalEntity(parser, entity, betweenDecl);
    1:           if (result != XML_ERROR_NONE)
    1:             return result;
    1:           handleDefault = XML_FALSE;
    1:           break;
    1:         }
    1:         if (externalEntityRefHandler) {
    1:           dtd->paramEntityRead = XML_FALSE;
    1:           entity->open = XML_TRUE;
    1:           if (!externalEntityRefHandler(externalEntityRefHandlerArg,
    1: /* BEGIN MOZILLA CHANGE (http://bugzilla.mozilla.org/show_bug.cgi?id=191482) */
    1: #if 0
    1:                                         0,
    1: #else
    1:                                         entity->name,
    1: #endif
    1: /* END MOZILLA CHANGE */
    1:                                         entity->base,
    1:                                         entity->systemId,
    1:                                         entity->publicId)) {
    1:             entity->open = XML_FALSE;
    1:             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
    1:           }
    1:           entity->open = XML_FALSE;
    1:           handleDefault = XML_FALSE;
    1:           if (!dtd->paramEntityRead) {
    1:             dtd->keepProcessing = dtd->standalone;
    1:             break;
    1:           }
    1:         }
    1:         else {
    1:           dtd->keepProcessing = dtd->standalone;
    1:           break;
    1:         }
    1:       }
    1: #endif /* XML_DTD */
    1:       if (!dtd->standalone &&
    1:           notStandaloneHandler &&
    1:           !notStandaloneHandler(handlerArg))
    1:         return XML_ERROR_NOT_STANDALONE;
    1:       break;
    1: 
    1:     /* Element declaration stuff */
    1: 
    1:     case XML_ROLE_ELEMENT_NAME:
    1:       if (elementDeclHandler) {
    1:         declElementType = getElementType(parser, enc, s, next);
    1:         if (!declElementType)
    1:           return XML_ERROR_NO_MEMORY;
    1:         dtd->scaffLevel = 0;
    1:         dtd->scaffCount = 0;
    1:         dtd->in_eldecl = XML_TRUE;
    1:         handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1: 
    1:     case XML_ROLE_CONTENT_ANY:
    1:     case XML_ROLE_CONTENT_EMPTY:
    1:       if (dtd->in_eldecl) {
    1:         if (elementDeclHandler) {
    1:           XML_Content * content = (XML_Content *) MALLOC(sizeof(XML_Content));
    1:           if (!content)
    1:             return XML_ERROR_NO_MEMORY;
    1:           content->quant = XML_CQUANT_NONE;
    1:           content->name = NULL;
    1:           content->numchildren = 0;
    1:           content->children = NULL;
    1:           content->type = ((role == XML_ROLE_CONTENT_ANY) ?
    1:                            XML_CTYPE_ANY :
    1:                            XML_CTYPE_EMPTY);
    1:           *eventEndPP = s;
    1:           elementDeclHandler(handlerArg, declElementType->name, content);
    1:           handleDefault = XML_FALSE;
    1:         }
    1:         dtd->in_eldecl = XML_FALSE;
    1:       }
    1:       break;
    1: 
    1:     case XML_ROLE_CONTENT_PCDATA:
    1:       if (dtd->in_eldecl) {
    1:         dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
    1:             = XML_CTYPE_MIXED;
    1:         if (elementDeclHandler)
    1:           handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1: 
    1:     case XML_ROLE_CONTENT_ELEMENT:
    1:       quant = XML_CQUANT_NONE;
    1:       goto elementContent;
    1:     case XML_ROLE_CONTENT_ELEMENT_OPT:
    1:       quant = XML_CQUANT_OPT;
    1:       goto elementContent;
    1:     case XML_ROLE_CONTENT_ELEMENT_REP:
    1:       quant = XML_CQUANT_REP;
    1:       goto elementContent;
    1:     case XML_ROLE_CONTENT_ELEMENT_PLUS:
    1:       quant = XML_CQUANT_PLUS;
    1:     elementContent:
    1:       if (dtd->in_eldecl) {
    1:         ELEMENT_TYPE *el;
    1:         const XML_Char *name;
    1:         int nameLen;
    1:         const char *nxt = (quant == XML_CQUANT_NONE
    1:                            ? next
    1:                            : next - enc->minBytesPerChar);
    1:         int myindex = nextScaffoldPart(parser);
    1:         if (myindex < 0)
    1:           return XML_ERROR_NO_MEMORY;
    1:         dtd->scaffold[myindex].type = XML_CTYPE_NAME;
    1:         dtd->scaffold[myindex].quant = quant;
    1:         el = getElementType(parser, enc, s, nxt);
    1:         if (!el)
    1:           return XML_ERROR_NO_MEMORY;
    1:         name = el->name;
    1:         dtd->scaffold[myindex].name = name;
    1:         nameLen = 0;
    1:         for (; name[nameLen++]; );
    1:         dtd->contentStringLen +=  nameLen;
    1:         if (elementDeclHandler)
    1:           handleDefault = XML_FALSE;
    1:       }
    1:       break;
    1: 
    1:     case XML_ROLE_GROUP_CLOSE:
    1:       quant = XML_CQUANT_NONE;
    1:       goto closeGroup;
    1:     case XML_ROLE_GROUP_CLOSE_OPT:
    1:       quant = XML_CQUANT_OPT;
    1:       goto closeGroup;
    1:     case XML_ROLE_GROUP_CLOSE_REP:
    1:       quant = XML_CQUANT_REP;
    1:       goto closeGroup;
    1:     case XML_ROLE_GROUP_CLOSE_PLUS:
    1:       quant = XML_CQUANT_PLUS;
    1:     closeGroup:
    1:       if (dtd->in_eldecl) {
    1:         if (elementDeclHandler)
    1:           handleDefault = XML_FALSE;
    1:         dtd->scaffLevel--;
    1:         dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel]].quant = quant;
    1:         if (dtd->scaffLevel == 0) {
    1:           if (!handleDefault) {
    1:             XML_Content *model = build_model(parser);
    1:             if (!model)
    1:               return XML_ERROR_NO_MEMORY;
    1:             *eventEndPP = s;
    1:             elementDeclHandler(handlerArg, declElementType->name, model);
    1:           }
    1:           dtd->in_eldecl = XML_FALSE;
    1:           dtd->contentStringLen = 0;
    1:         }
    1:       }
    1:       break;
    1:       /* End element declaration stuff */
    1: 
    1:     case XML_ROLE_PI:
    1:       if (!reportProcessingInstruction(parser, enc, s, next))
    1:         return XML_ERROR_NO_MEMORY;
    1:       handleDefault = XML_FALSE;
    1:       break;
    1:     case XML_ROLE_COMMENT:
    1:       if (!reportComment(parser, enc, s, next))
    1:         return XML_ERROR_NO_MEMORY;
    1:       handleDefault = XML_FALSE;
    1:       break;
    1:     case XML_ROLE_NONE:
    1:       switch (tok) {
    1:       case XML_TOK_BOM:
    1:         handleDefault = XML_FALSE;
    1:         break;
    1:       }
    1:       break;
    1:     case XML_ROLE_DOCTYPE_NONE:
    1:       if (startDoctypeDeclHandler)
    1:         handleDefault = XML_FALSE;
    1:       break;
    1:     case XML_ROLE_ENTITY_NONE:
    1:       if (dtd->keepProcessing && entityDeclHandler)
    1:         handleDefault = XML_FALSE;
    1:       break;
    1:     case XML_ROLE_NOTATION_NONE:
    1:       if (notationDeclHandler)
    1:         handleDefault = XML_FALSE;
    1:       break;
    1:     case XML_ROLE_ATTLIST_NONE:
    1:       if (dtd->keepProcessing && attlistDeclHandler)
    1:         handleDefault = XML_FALSE;
    1:       break;
    1:     case XML_ROLE_ELEMENT_NONE:
    1:       if (elementDeclHandler)
    1:         handleDefault = XML_FALSE;
    1:       break;
    1:     } /* end of big switch */
    1: 
    1:     if (handleDefault && defaultHandler)
    1:       reportDefault(parser, enc, s, next);
    1: 
    1:     switch (ps_parsing) {
    1:     case XML_SUSPENDED: 
    1:       *nextPtr = next;
    1:       return XML_ERROR_NONE;
    1:     case XML_FINISHED:
    1:       return XML_ERROR_ABORTED;
    1:     default:
    1:       s = next;
    1:       tok = XmlPrologTok(enc, s, end, &next);
    1:     }
    1:   }
    1:   /* not reached */
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: epilogProcessor(XML_Parser parser,
    1:                 const char *s,
    1:                 const char *end,
    1:                 const char **nextPtr)
    1: {
    1:   processor = epilogProcessor;
    1:   eventPtr = s;
    1:   for (;;) {
    1:     const char *next = NULL;
    1:     int tok = XmlPrologTok(encoding, s, end, &next);
    1:     eventEndPtr = next;
    1:     switch (tok) {
    1:     /* report partial linebreak - it might be the last token */
    1:     case -XML_TOK_PROLOG_S:
    1:       if (defaultHandler) {
    1:         reportDefault(parser, encoding, s, next);
    1:         if (ps_parsing == XML_FINISHED)
    1:           return XML_ERROR_ABORTED;
    1:       }
    1:       *nextPtr = next;
    1:       return XML_ERROR_NONE;
    1:     case XML_TOK_NONE:
    1:       *nextPtr = s;
    1:       return XML_ERROR_NONE;
    1:     case XML_TOK_PROLOG_S:
    1:       if (defaultHandler)
    1:         reportDefault(parser, encoding, s, next);
    1:       break;
    1:     case XML_TOK_PI:
    1:       if (!reportProcessingInstruction(parser, encoding, s, next))
    1:         return XML_ERROR_NO_MEMORY;
    1:       break;
    1:     case XML_TOK_COMMENT:
    1:       if (!reportComment(parser, encoding, s, next))
    1:         return XML_ERROR_NO_MEMORY;
    1:       break;
    1:     case XML_TOK_INVALID:
    1:       eventPtr = next;
    1:       return XML_ERROR_INVALID_TOKEN;
    1:     case XML_TOK_PARTIAL:
    1:       if (!ps_finalBuffer) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       return XML_ERROR_UNCLOSED_TOKEN;
    1:     case XML_TOK_PARTIAL_CHAR:
    1:       if (!ps_finalBuffer) {
    1:         *nextPtr = s;
    1:         return XML_ERROR_NONE;
    1:       }
    1:       return XML_ERROR_PARTIAL_CHAR;
    1:     default:
    1:       return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;
    1:     }
    1:     eventPtr = s = next;
    1:     switch (ps_parsing) {
    1:     case XML_SUSPENDED: 
    1:       *nextPtr = next;
    1:       return XML_ERROR_NONE;
    1:     case XML_FINISHED:
    1:       return XML_ERROR_ABORTED;
    1:     default: ;
    1:     }
    1:   }
    1: }
    1: 
    1: static enum XML_Error
    1: processInternalEntity(XML_Parser parser, ENTITY *entity,
    1:                       XML_Bool betweenDecl)
    1: {
    1:   const char *textStart, *textEnd;
    1:   const char *next;
    1:   enum XML_Error result;
    1:   OPEN_INTERNAL_ENTITY *openEntity;
    1: 
    1:   if (freeInternalEntities) {
    1:     openEntity = freeInternalEntities;
    1:     freeInternalEntities = openEntity->next;
    1:   }
    1:   else {
    1:     openEntity = (OPEN_INTERNAL_ENTITY *)MALLOC(sizeof(OPEN_INTERNAL_ENTITY));
    1:     if (!openEntity)
    1:       return XML_ERROR_NO_MEMORY;
    1:   }
    1:   entity->open = XML_TRUE;
    1:   entity->processed = 0;
    1:   openEntity->next = openInternalEntities;
    1:   openInternalEntities = openEntity;
    1:   openEntity->entity = entity;
    1:   openEntity->startTagLevel = tagLevel;
    1:   openEntity->betweenDecl = betweenDecl;
    1:   openEntity->internalEventPtr = NULL;
    1:   openEntity->internalEventEndPtr = NULL;
    1:   textStart = (char *)entity->textPtr;
    1:   textEnd = (char *)(entity->textPtr + entity->textLen);
    1: 
    1: #ifdef XML_DTD
    1:   if (entity->is_param) {
    1:     int tok = XmlPrologTok(internalEncoding, textStart, textEnd, &next);
    1:     result = doProlog(parser, internalEncoding, textStart, textEnd, tok, 
    1:                       next, &next, XML_FALSE);
    1:   }
    1:   else 
    1: #endif /* XML_DTD */
    1:     result = doContent(parser, tagLevel, internalEncoding, textStart, 
    1:                        textEnd, &next, XML_FALSE);
    1: 
    1:   if (result == XML_ERROR_NONE) {
    1:     if (textEnd != next && ps_parsing == XML_SUSPENDED) {
    1:       entity->processed = (int)(next - textStart);
    1:       processor = internalEntityProcessor;
    1:     }
    1:     else {
    1:       entity->open = XML_FALSE;
    1:       openInternalEntities = openEntity->next;
    1:       /* put openEntity back in list of free instances */
    1:       openEntity->next = freeInternalEntities;
    1:       freeInternalEntities = openEntity;
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: internalEntityProcessor(XML_Parser parser,
    1:                         const char *s,
    1:                         const char *end,
    1:                         const char **nextPtr)
    1: {
    1:   ENTITY *entity;
    1:   const char *textStart, *textEnd;
    1:   const char *next;
    1:   enum XML_Error result;
    1:   OPEN_INTERNAL_ENTITY *openEntity = openInternalEntities;
    1:   if (!openEntity)
    1:     return XML_ERROR_UNEXPECTED_STATE;
    1: 
    1:   entity = openEntity->entity;
    1:   textStart = ((char *)entity->textPtr) + entity->processed;
    1:   textEnd = (char *)(entity->textPtr + entity->textLen);
    1: 
    1: #ifdef XML_DTD
    1:   if (entity->is_param) {
    1:     int tok = XmlPrologTok(internalEncoding, textStart, textEnd, &next);
    1:     result = doProlog(parser, internalEncoding, textStart, textEnd, tok, 
    1:                       next, &next, XML_FALSE);
    1:   }
    1:   else
    1: #endif /* XML_DTD */
    1:     result = doContent(parser, openEntity->startTagLevel, internalEncoding, 
    1:                        textStart, textEnd, &next, XML_FALSE);  
    1: 
    1:   if (result != XML_ERROR_NONE)
    1:     return result;
    1:   else if (textEnd != next && ps_parsing == XML_SUSPENDED) {
    1:     entity->processed = (int)(next - (char *)entity->textPtr);
    1:     return result;
    1:   }
    1:   else {
    1:     entity->open = XML_FALSE;
    1:     openInternalEntities = openEntity->next;
    1:     /* put openEntity back in list of free instances */
    1:     openEntity->next = freeInternalEntities;
    1:     freeInternalEntities = openEntity;
    1:   }
    1: 
    1: #ifdef XML_DTD
    1:   if (entity->is_param) {
    1:     int tok;
    1:     processor = prologProcessor;
    1:     tok = XmlPrologTok(encoding, s, end, &next);
    1:     return doProlog(parser, encoding, s, end, tok, next, nextPtr, 
    1:                     (XML_Bool)!ps_finalBuffer);
    1:   }
    1:   else
    1: #endif /* XML_DTD */
    1:   {
    1:     processor = contentProcessor;
    1:     /* see externalEntityContentProcessor vs contentProcessor */
    1:     return doContent(parser, parentParser ? 1 : 0, encoding, s, end,
    1:                      nextPtr, (XML_Bool)!ps_finalBuffer); 
    1:   }  
    1: }
    1: 
    1: static enum XML_Error PTRCALL
    1: errorProcessor(XML_Parser parser,
    1:                const char *s,
    1:                const char *end,
    1:                const char **nextPtr)
    1: {
    1:   return errorCode;
    1: }
    1: 
    1: static enum XML_Error
    1: storeAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,
    1:                     const char *ptr, const char *end,
    1:                     STRING_POOL *pool)
    1: {
    1:   enum XML_Error result = appendAttributeValue(parser, enc, isCdata, ptr,
    1:                                                end, pool);
    1:   if (result)
    1:     return result;
    1:   if (!isCdata && poolLength(pool) && poolLastChar(pool) == 0x20)
    1:     poolChop(pool);
    1:   if (!poolAppendChar(pool, XML_T('\0')))
    1:     return XML_ERROR_NO_MEMORY;
    1:   return XML_ERROR_NONE;
    1: }
    1: 
    1: static enum XML_Error
    1: appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,
    1:                      const char *ptr, const char *end,
    1:                      STRING_POOL *pool)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   for (;;) {
    1:     const char *next;
    1:     int tok = XmlAttributeValueTok(enc, ptr, end, &next);
    1:     switch (tok) {
    1:     case XML_TOK_NONE:
    1:       return XML_ERROR_NONE;
    1:     case XML_TOK_INVALID:
    1:       if (enc == encoding)
    1:         eventPtr = next;
    1:       return XML_ERROR_INVALID_TOKEN;
    1:     case XML_TOK_PARTIAL:
    1:       if (enc == encoding)
    1:         eventPtr = ptr;
    1:       return XML_ERROR_INVALID_TOKEN;
    1:     case XML_TOK_CHAR_REF:
    1:       {
    1:         XML_Char buf[XML_ENCODE_MAX];
    1:         int i;
    1:         int n = XmlCharRefNumber(enc, ptr);
    1:         if (n < 0) {
    1:           if (enc == encoding)
    1:             eventPtr = ptr;
    1:           return XML_ERROR_BAD_CHAR_REF;
    1:         }
    1:         if (!isCdata
    1:             && n == 0x20 /* space */
    1:             && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
    1:           break;
    1:         n = XmlEncode(n, (ICHAR *)buf);
    1:         if (!n) {
    1:           if (enc == encoding)
    1:             eventPtr = ptr;
    1:           return XML_ERROR_BAD_CHAR_REF;
    1:         }
    1:         for (i = 0; i < n; i++) {
    1:           if (!poolAppendChar(pool, buf[i]))
    1:             return XML_ERROR_NO_MEMORY;
    1:         }
    1:       }
    1:       break;
    1:     case XML_TOK_DATA_CHARS:
    1:       if (!poolAppend(pool, enc, ptr, next))
    1:         return XML_ERROR_NO_MEMORY;
    1:       break;
    1:     case XML_TOK_TRAILING_CR:
    1:       next = ptr + enc->minBytesPerChar;
    1:       /* fall through */
    1:     case XML_TOK_ATTRIBUTE_VALUE_S:
    1:     case XML_TOK_DATA_NEWLINE:
    1:       if (!isCdata && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
    1:         break;
    1:       if (!poolAppendChar(pool, 0x20))
    1:         return XML_ERROR_NO_MEMORY;
    1:       break;
    1:     case XML_TOK_ENTITY_REF:
    1:       {
    1:         const XML_Char *name;
    1:         ENTITY *entity;
    1:         char checkEntityDecl;
    1:         XML_Char ch = (XML_Char) XmlPredefinedEntityName(enc,
    1:                                               ptr + enc->minBytesPerChar,
    1:                                               next - enc->minBytesPerChar);
    1:         if (ch) {
    1:           if (!poolAppendChar(pool, ch))
    1:                 return XML_ERROR_NO_MEMORY;
    1:           break;
    1:         }
    1:         name = poolStoreString(&temp2Pool, enc,
    1:                                ptr + enc->minBytesPerChar,
    1:                                next - enc->minBytesPerChar);
    1:         if (!name)
    1:           return XML_ERROR_NO_MEMORY;
    1:         entity = (ENTITY *)lookup(&dtd->generalEntities, name, 0);
    1:         poolDiscard(&temp2Pool);
    1:         /* First, determine if a check for an existing declaration is needed;
    1:            if yes, check that the entity exists, and that it is internal.
    1:         */
    1:         if (pool == &dtd->pool)  /* are we called from prolog? */
    1:           checkEntityDecl =
    1: #ifdef XML_DTD
    1:               prologState.documentEntity &&
    1: #endif /* XML_DTD */
    1:               (dtd->standalone
    1:                ? !openInternalEntities
    1:                : !dtd->hasParamEntityRefs);
    1:         else /* if (pool == &tempPool): we are called from content */
    1:           checkEntityDecl = !dtd->hasParamEntityRefs || dtd->standalone;
    1:         if (checkEntityDecl) {
    1:           if (!entity)
    1:             return XML_ERROR_UNDEFINED_ENTITY;
    1:           else if (!entity->is_internal)
    1:             return XML_ERROR_ENTITY_DECLARED_IN_PE;
    1:         }
    1:         else if (!entity) {
    1:           /* Cannot report skipped entity here - see comments on
    1:              skippedEntityHandler.
    1:           if (skippedEntityHandler)
    1:             skippedEntityHandler(handlerArg, name, 0);
    1:           */
    1:           /* Cannot call the default handler because this would be
    1:              out of sync with the call to the startElementHandler.
    1:           if ((pool == &tempPool) && defaultHandler)
    1:             reportDefault(parser, enc, ptr, next);
    1:           */
    1: /* BEGIN MOZILLA CHANGE (http://bugzilla.mozilla.org/show_bug.cgi?id=35984) */
    1: #if 0
    1:           break;
    1: #else
    1:           return XML_ERROR_UNDEFINED_ENTITY;
    1: #endif
    1: /* END MOZILLA CHANGE */
    1:         }
    1:         if (entity->open) {
    1:           if (enc == encoding)
    1:             eventPtr = ptr;
    1:           return XML_ERROR_RECURSIVE_ENTITY_REF;
    1:         }
    1:         if (entity->notation) {
    1:           if (enc == encoding)
    1:             eventPtr = ptr;
    1:           return XML_ERROR_BINARY_ENTITY_REF;
    1:         }
    1:         if (!entity->textPtr) {
    1:           if (enc == encoding)
    1:             eventPtr = ptr;
    1:               return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;
    1:         }
    1:         else {
    1:           enum XML_Error result;
    1:           const XML_Char *textEnd = entity->textPtr + entity->textLen;
    1:           entity->open = XML_TRUE;
    1:           result = appendAttributeValue(parser, internalEncoding, isCdata,
    1:                                         (char *)entity->textPtr,
    1:                                         (char *)textEnd, pool);
    1:           entity->open = XML_FALSE;
    1:           if (result)
    1:             return result;
    1:         }
    1:       }
    1:       break;
    1:     default:
    1:       if (enc == encoding)
    1:         eventPtr = ptr;
    1:       return XML_ERROR_UNEXPECTED_STATE;
    1:     }
    1:     ptr = next;
    1:   }
    1:   /* not reached */
    1: }
    1: 
    1: static enum XML_Error
    1: storeEntityValue(XML_Parser parser,
    1:                  const ENCODING *enc,
    1:                  const char *entityTextPtr,
    1:                  const char *entityTextEnd)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   STRING_POOL *pool = &(dtd->entityValuePool);
    1:   enum XML_Error result = XML_ERROR_NONE;
    1: #ifdef XML_DTD
    1:   int oldInEntityValue = prologState.inEntityValue;
    1:   prologState.inEntityValue = 1;
    1: #endif /* XML_DTD */
    1:   /* never return Null for the value argument in EntityDeclHandler,
    1:      since this would indicate an external entity; therefore we
    1:      have to make sure that entityValuePool.start is not null */
    1:   if (!pool->blocks) {
    1:     if (!poolGrow(pool))
    1:       return XML_ERROR_NO_MEMORY;
    1:   }
    1: 
    1:   for (;;) {
    1:     const char *next;
    1:     int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);
    1:     switch (tok) {
    1:     case XML_TOK_PARAM_ENTITY_REF:
    1: #ifdef XML_DTD
    1:       if (isParamEntity || enc != encoding) {
    1:         const XML_Char *name;
    1:         ENTITY *entity;
    1:         name = poolStoreString(&tempPool, enc,
    1:                                entityTextPtr + enc->minBytesPerChar,
    1:                                next - enc->minBytesPerChar);
    1:         if (!name) {
    1:           result = XML_ERROR_NO_MEMORY;
    1:           goto endEntityValue;
    1:         }
    1:         entity = (ENTITY *)lookup(&dtd->paramEntities, name, 0);
    1:         poolDiscard(&tempPool);
    1:         if (!entity) {
    1:           /* not a well-formedness error - see XML 1.0: WFC Entity Declared */
    1:           /* cannot report skipped entity here - see comments on
    1:              skippedEntityHandler
    1:           if (skippedEntityHandler)
    1:             skippedEntityHandler(handlerArg, name, 0);
    1:           */
    1:           dtd->keepProcessing = dtd->standalone;
    1:           goto endEntityValue;
    1:         }
    1:         if (entity->open) {
    1:           if (enc == encoding)
    1:             eventPtr = entityTextPtr;
    1:           result = XML_ERROR_RECURSIVE_ENTITY_REF;
    1:           goto endEntityValue;
    1:         }
    1:         if (entity->systemId) {
    1:           if (externalEntityRefHandler) {
    1:             dtd->paramEntityRead = XML_FALSE;
    1:             entity->open = XML_TRUE;
    1:             if (!externalEntityRefHandler(externalEntityRefHandlerArg,
    1:                                           0,
    1:                                           entity->base,
    1:                                           entity->systemId,
    1:                                           entity->publicId)) {
    1:               entity->open = XML_FALSE;
    1:               result = XML_ERROR_EXTERNAL_ENTITY_HANDLING;
    1:               goto endEntityValue;
    1:             }
    1:             entity->open = XML_FALSE;
    1:             if (!dtd->paramEntityRead)
    1:               dtd->keepProcessing = dtd->standalone;
    1:           }
    1:           else
    1:             dtd->keepProcessing = dtd->standalone;
    1:         }
    1:         else {
    1:           entity->open = XML_TRUE;
    1:           result = storeEntityValue(parser,
    1:                                     internalEncoding,
    1:                                     (char *)entity->textPtr,
    1:                                     (char *)(entity->textPtr
    1:                                              + entity->textLen));
    1:           entity->open = XML_FALSE;
    1:           if (result)
    1:             goto endEntityValue;
    1:         }
    1:         break;
    1:       }
    1: #endif /* XML_DTD */
    1:       /* In the internal subset, PE references are not legal
    1:          within markup declarations, e.g entity values in this case. */
    1:       eventPtr = entityTextPtr;
    1:       result = XML_ERROR_PARAM_ENTITY_REF;
    1:       goto endEntityValue;
    1:     case XML_TOK_NONE:
    1:       result = XML_ERROR_NONE;
    1:       goto endEntityValue;
    1:     case XML_TOK_ENTITY_REF:
    1:     case XML_TOK_DATA_CHARS:
    1:       if (!poolAppend(pool, enc, entityTextPtr, next)) {
    1:         result = XML_ERROR_NO_MEMORY;
    1:         goto endEntityValue;
    1:       }
    1:       break;
    1:     case XML_TOK_TRAILING_CR:
    1:       next = entityTextPtr + enc->minBytesPerChar;
    1:       /* fall through */
    1:     case XML_TOK_DATA_NEWLINE:
    1:       if (pool->end == pool->ptr && !poolGrow(pool)) {
    1:               result = XML_ERROR_NO_MEMORY;
    1:         goto endEntityValue;
    1:       }
    1:       *(pool->ptr)++ = 0xA;
    1:       break;
    1:     case XML_TOK_CHAR_REF:
    1:       {
    1:         XML_Char buf[XML_ENCODE_MAX];
    1:         int i;
    1:         int n = XmlCharRefNumber(enc, entityTextPtr);
    1:         if (n < 0) {
    1:           if (enc == encoding)
    1:             eventPtr = entityTextPtr;
    1:           result = XML_ERROR_BAD_CHAR_REF;
    1:           goto endEntityValue;
    1:         }
    1:         n = XmlEncode(n, (ICHAR *)buf);
    1:         if (!n) {
    1:           if (enc == encoding)
    1:             eventPtr = entityTextPtr;
    1:           result = XML_ERROR_BAD_CHAR_REF;
    1:           goto endEntityValue;
    1:         }
    1:         for (i = 0; i < n; i++) {
    1:           if (pool->end == pool->ptr && !poolGrow(pool)) {
    1:             result = XML_ERROR_NO_MEMORY;
    1:             goto endEntityValue;
    1:           }
    1:           *(pool->ptr)++ = buf[i];
    1:         }
    1:       }
    1:       break;
    1:     case XML_TOK_PARTIAL:
    1:       if (enc == encoding)
    1:         eventPtr = entityTextPtr;
    1:       result = XML_ERROR_INVALID_TOKEN;
    1:       goto endEntityValue;
    1:     case XML_TOK_INVALID:
    1:       if (enc == encoding)
    1:         eventPtr = next;
    1:       result = XML_ERROR_INVALID_TOKEN;
    1:       goto endEntityValue;
    1:     default:
    1:       if (enc == encoding)
    1:         eventPtr = entityTextPtr;
    1:       result = XML_ERROR_UNEXPECTED_STATE;
    1:       goto endEntityValue;
    1:     }
    1:     entityTextPtr = next;
    1:   }
    1: endEntityValue:
    1: #ifdef XML_DTD
    1:   prologState.inEntityValue = oldInEntityValue;
    1: #endif /* XML_DTD */
    1:   return result;
    1: }
    1: 
    1: static void FASTCALL
    1: normalizeLines(XML_Char *s)
    1: {
    1:   XML_Char *p;
    1:   for (;; s++) {
    1:     if (*s == XML_T('\0'))
    1:       return;
    1:     if (*s == 0xD)
    1:       break;
    1:   }
    1:   p = s;
    1:   do {
    1:     if (*s == 0xD) {
    1:       *p++ = 0xA;
    1:       if (*++s == 0xA)
    1:         s++;
    1:     }
    1:     else
    1:       *p++ = *s++;
    1:   } while (*s);
    1:   *p = XML_T('\0');
    1: }
    1: 
    1: static int
    1: reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,
    1:                             const char *start, const char *end)
    1: {
    1:   const XML_Char *target;
    1:   XML_Char *data;
    1:   const char *tem;
    1:   if (!processingInstructionHandler) {
    1:     if (defaultHandler)
    1:       reportDefault(parser, enc, start, end);
    1:     return 1;
    1:   }
    1:   start += enc->minBytesPerChar * 2;
    1:   tem = start + XmlNameLength(enc, start);
    1:   target = poolStoreString(&tempPool, enc, start, tem);
    1:   if (!target)
    1:     return 0;
    1:   poolFinish(&tempPool);
    1:   data = poolStoreString(&tempPool, enc,
    1:                         XmlSkipS(enc, tem),
    1:                         end - enc->minBytesPerChar*2);
    1:   if (!data)
    1:     return 0;
    1:   normalizeLines(data);
    1:   processingInstructionHandler(handlerArg, target, data);
    1:   poolClear(&tempPool);
    1:   return 1;
    1: }
    1: 
    1: static int
    1: reportComment(XML_Parser parser, const ENCODING *enc,
    1:               const char *start, const char *end)
    1: {
    1:   XML_Char *data;
    1:   if (!commentHandler) {
    1:     if (defaultHandler)
    1:       reportDefault(parser, enc, start, end);
    1:     return 1;
    1:   }
    1:   data = poolStoreString(&tempPool,
    1:                          enc,
    1:                          start + enc->minBytesPerChar * 4,
    1:                          end - enc->minBytesPerChar * 3);
    1:   if (!data)
    1:     return 0;
    1:   normalizeLines(data);
    1:   commentHandler(handlerArg, data);
    1:   poolClear(&tempPool);
    1:   return 1;
    1: }
    1: 
    1: static void
    1: reportDefault(XML_Parser parser, const ENCODING *enc,
    1:               const char *s, const char *end)
    1: {
    1:   if (MUST_CONVERT(enc, s)) {
    1:     const char **eventPP;
    1:     const char **eventEndPP;
    1:     if (enc == encoding) {
    1:       eventPP = &eventPtr;
    1:       eventEndPP = &eventEndPtr;
    1:     }
    1:     else {
    1:       eventPP = &(openInternalEntities->internalEventPtr);
    1:       eventEndPP = &(openInternalEntities->internalEventEndPtr);
    1:     }
    1:     do {
    1:       ICHAR *dataPtr = (ICHAR *)dataBuf;
    1:       XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
    1:       *eventEndPP = s;
    1:       defaultHandler(handlerArg, dataBuf, (int)(dataPtr - (ICHAR *)dataBuf));
    1:       *eventPP = s;
    1:     } while (s != end);
    1:   }
    1:   else
    1:     defaultHandler(handlerArg, (XML_Char *)s, (int)((XML_Char *)end - (XML_Char *)s));
    1: }
    1: 
    1: 
    1: static int
    1: defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, XML_Bool isCdata,
    1:                 XML_Bool isId, const XML_Char *value, XML_Parser parser)
    1: {
    1:   DEFAULT_ATTRIBUTE *att;
    1:   if (value || isId) {
    1:     /* The handling of default attributes gets messed up if we have
    1:        a default which duplicates a non-default. */
    1:     int i;
    1:     for (i = 0; i < type->nDefaultAtts; i++)
    1:       if (attId == type->defaultAtts[i].id)
    1:         return 1;
    1:     if (isId && !type->idAtt && !attId->xmlns)
    1:       type->idAtt = attId;
    1:   }
    1:   if (type->nDefaultAtts == type->allocDefaultAtts) {
    1:     if (type->allocDefaultAtts == 0) {
    1:       type->allocDefaultAtts = 8;
    1:       type->defaultAtts = (DEFAULT_ATTRIBUTE *)MALLOC(type->allocDefaultAtts
    1:                             * sizeof(DEFAULT_ATTRIBUTE));
    1:       if (!type->defaultAtts)
    1:         return 0;
    1:     }
    1:     else {
    1:       DEFAULT_ATTRIBUTE *temp;
    1:       int count = type->allocDefaultAtts * 2;
    1:       temp = (DEFAULT_ATTRIBUTE *)
    1:         REALLOC(type->defaultAtts, (count * sizeof(DEFAULT_ATTRIBUTE)));
    1:       if (temp == NULL)
    1:         return 0;
    1:       type->allocDefaultAtts = count;
    1:       type->defaultAtts = temp;
    1:     }
    1:   }
    1:   att = type->defaultAtts + type->nDefaultAtts;
    1:   att->id = attId;
    1:   att->value = value;
    1:   att->isCdata = isCdata;
    1:   if (!isCdata)
    1:     attId->maybeTokenized = XML_TRUE;
    1:   type->nDefaultAtts += 1;
    1:   return 1;
    1: }
    1: 
    1: static int
    1: setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   const XML_Char *name;
    1:   for (name = elementType->name; *name; name++) {
    1:     if (*name == XML_T(':')) {
    1:       PREFIX *prefix;
    1:       const XML_Char *s;
    1:       for (s = elementType->name; s != name; s++) {
    1:         if (!poolAppendChar(&dtd->pool, *s))
    1:           return 0;
    1:       }
    1:       if (!poolAppendChar(&dtd->pool, XML_T('\0')))
    1:         return 0;
    1:       prefix = (PREFIX *)lookup(&dtd->prefixes, poolStart(&dtd->pool),
    1:                                 sizeof(PREFIX));
    1:       if (!prefix)
    1:         return 0;
    1:       if (prefix->name == poolStart(&dtd->pool))
    1:         poolFinish(&dtd->pool);
    1:       else
    1:         poolDiscard(&dtd->pool);
    1:       elementType->prefix = prefix;
    1: 
    1:     }
    1:   }
    1:   return 1;
    1: }
    1: 
    1: static ATTRIBUTE_ID *
    1: getAttributeId(XML_Parser parser, const ENCODING *enc,
    1:                const char *start, const char *end)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   ATTRIBUTE_ID *id;
    1:   const XML_Char *name;
    1:   if (!poolAppendChar(&dtd->pool, XML_T('\0')))
    1:     return NULL;
    1:   name = poolStoreString(&dtd->pool, enc, start, end);
    1:   if (!name)
    1:     return NULL;
    1:   /* skip quotation mark - its storage will be re-used (like in name[-1]) */
    1:   ++name;
    1:   id = (ATTRIBUTE_ID *)lookup(&dtd->attributeIds, name, sizeof(ATTRIBUTE_ID));
    1:   if (!id)
    1:     return NULL;
    1:   if (id->name != name)
    1:     poolDiscard(&dtd->pool);
    1:   else {
    1:     poolFinish(&dtd->pool);
    1:     if (!ns)
    1:       ;
    1:     else if (name[0] == XML_T('x')
    1:         && name[1] == XML_T('m')
    1:         && name[2] == XML_T('l')
    1:         && name[3] == XML_T('n')
    1:         && name[4] == XML_T('s')
    1:         && (name[5] == XML_T('\0') || name[5] == XML_T(':'))) {
    1:       if (name[5] == XML_T('\0'))
    1:         id->prefix = &dtd->defaultPrefix;
    1:       else
    1:         id->prefix = (PREFIX *)lookup(&dtd->prefixes, name + 6, sizeof(PREFIX));
    1:       id->xmlns = XML_TRUE;
    1:     }
    1:     else {
    1:       int i;
    1:       for (i = 0; name[i]; i++) {
    1:         /* attributes without prefix are *not* in the default namespace */
    1:         if (name[i] == XML_T(':')) {
    1:           int j;
    1:           for (j = 0; j < i; j++) {
    1:             if (!poolAppendChar(&dtd->pool, name[j]))
    1:               return NULL;
    1:           }
    1:           if (!poolAppendChar(&dtd->pool, XML_T('\0')))
    1:             return NULL;
    1:           id->prefix = (PREFIX *)lookup(&dtd->prefixes, poolStart(&dtd->pool),
    1:                                         sizeof(PREFIX));
    1:           if (id->prefix->name == poolStart(&dtd->pool))
    1:             poolFinish(&dtd->pool);
    1:           else
    1:             poolDiscard(&dtd->pool);
    1:           break;
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return id;
    1: }
    1: 
    1: #define CONTEXT_SEP XML_T('\f')
    1: 
    1: static const XML_Char *
    1: getContext(XML_Parser parser)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   HASH_TABLE_ITER iter;
    1:   XML_Bool needSep = XML_FALSE;
    1: 
    1:   if (dtd->defaultPrefix.binding) {
    1:     int i;
    1:     int len;
    1:     if (!poolAppendChar(&tempPool, XML_T('=')))
    1:       return NULL;
    1:     len = dtd->defaultPrefix.binding->uriLen;
    1:     if (namespaceSeparator)
    1:       len--;
    1:     for (i = 0; i < len; i++)
    1:       if (!poolAppendChar(&tempPool, dtd->defaultPrefix.binding->uri[i]))
    1:         return NULL;
    1:     needSep = XML_TRUE;
    1:   }
    1: 
    1:   hashTableIterInit(&iter, &(dtd->prefixes));
    1:   for (;;) {
    1:     int i;
    1:     int len;
    1:     const XML_Char *s;
    1:     PREFIX *prefix = (PREFIX *)hashTableIterNext(&iter);
    1:     if (!prefix)
    1:       break;
    1:     if (!prefix->binding)
    1:       continue;
    1:     if (needSep && !poolAppendChar(&tempPool, CONTEXT_SEP))
    1:       return NULL;
    1:     for (s = prefix->name; *s; s++)
    1:       if (!poolAppendChar(&tempPool, *s))
    1:         return NULL;
    1:     if (!poolAppendChar(&tempPool, XML_T('=')))
    1:       return NULL;
    1:     len = prefix->binding->uriLen;
    1:     if (namespaceSeparator)
    1:       len--;
    1:     for (i = 0; i < len; i++)
    1:       if (!poolAppendChar(&tempPool, prefix->binding->uri[i]))
    1:         return NULL;
    1:     needSep = XML_TRUE;
    1:   }
    1: 
    1: 
    1:   hashTableIterInit(&iter, &(dtd->generalEntities));
    1:   for (;;) {
    1:     const XML_Char *s;
    1:     ENTITY *e = (ENTITY *)hashTableIterNext(&iter);
    1:     if (!e)
    1:       break;
    1:     if (!e->open)
    1:       continue;
    1:     if (needSep && !poolAppendChar(&tempPool, CONTEXT_SEP))
    1:       return NULL;
    1:     for (s = e->name; *s; s++)
    1:       if (!poolAppendChar(&tempPool, *s))
    1:         return 0;
    1:     needSep = XML_TRUE;
    1:   }
    1: 
    1:   if (!poolAppendChar(&tempPool, XML_T('\0')))
    1:     return NULL;
    1:   return tempPool.start;
    1: }
    1: 
    1: static XML_Bool
    1: setContext(XML_Parser parser, const XML_Char *context)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   const XML_Char *s = context;
    1: 
    1:   while (*context != XML_T('\0')) {
    1:     if (*s == CONTEXT_SEP || *s == XML_T('\0')) {
    1:       ENTITY *e;
    1:       if (!poolAppendChar(&tempPool, XML_T('\0')))
    1:         return XML_FALSE;
    1:       e = (ENTITY *)lookup(&dtd->generalEntities, poolStart(&tempPool), 0);
    1:       if (e)
    1:         e->open = XML_TRUE;
    1:       if (*s != XML_T('\0'))
    1:         s++;
    1:       context = s;
    1:       poolDiscard(&tempPool);
    1:     }
    1:     else if (*s == XML_T('=')) {
    1:       PREFIX *prefix;
    1:       if (poolLength(&tempPool) == 0)
    1:         prefix = &dtd->defaultPrefix;
    1:       else {
    1:         if (!poolAppendChar(&tempPool, XML_T('\0')))
    1:           return XML_FALSE;
    1:         prefix = (PREFIX *)lookup(&dtd->prefixes, poolStart(&tempPool),
    1:                                   sizeof(PREFIX));
    1:         if (!prefix)
    1:           return XML_FALSE;
    1:         if (prefix->name == poolStart(&tempPool)) {
    1:           prefix->name = poolCopyString(&dtd->pool, prefix->name);
    1:           if (!prefix->name)
    1:             return XML_FALSE;
    1:         }
    1:         poolDiscard(&tempPool);
    1:       }
    1:       for (context = s + 1;
    1:            *context != CONTEXT_SEP && *context != XML_T('\0');
    1:            context++)
    1:         if (!poolAppendChar(&tempPool, *context))
    1:           return XML_FALSE;
    1:       if (!poolAppendChar(&tempPool, XML_T('\0')))
    1:         return XML_FALSE;
    1:       if (addBinding(parser, prefix, NULL, poolStart(&tempPool),
    1:                      &inheritedBindings) != XML_ERROR_NONE)
    1:         return XML_FALSE;
    1:       poolDiscard(&tempPool);
    1:       if (*context != XML_T('\0'))
    1:         ++context;
    1:       s = context;
    1:     }
    1:     else {
    1:       if (!poolAppendChar(&tempPool, *s))
    1:         return XML_FALSE;
    1:       s++;
    1:     }
    1:   }
    1:   return XML_TRUE;
    1: }
    1: 
    1: static void FASTCALL
    1: normalizePublicId(XML_Char *publicId)
    1: {
    1:   XML_Char *p = publicId;
    1:   XML_Char *s;
    1:   for (s = publicId; *s; s++) {
    1:     switch (*s) {
    1:     case 0x20:
    1:     case 0xD:
    1:     case 0xA:
    1:       if (p != publicId && p[-1] != 0x20)
    1:         *p++ = 0x20;
    1:       break;
    1:     default:
    1:       *p++ = *s;
    1:     }
    1:   }
    1:   if (p != publicId && p[-1] == 0x20)
    1:     --p;
    1:   *p = XML_T('\0');
    1: }
    1: 
    1: static DTD *
    1: dtdCreate(const XML_Memory_Handling_Suite *ms)
    1: {
    1:   DTD *p = (DTD *)ms->malloc_fcn(sizeof(DTD));
    1:   if (p == NULL)
    1:     return p;
    1:   poolInit(&(p->pool), ms);
    1:   poolInit(&(p->entityValuePool), ms);
    1:   hashTableInit(&(p->generalEntities), ms);
    1:   hashTableInit(&(p->elementTypes), ms);
    1:   hashTableInit(&(p->attributeIds), ms);
    1:   hashTableInit(&(p->prefixes), ms);
    1: #ifdef XML_DTD
    1:   p->paramEntityRead = XML_FALSE;
    1:   hashTableInit(&(p->paramEntities), ms);
    1: #endif /* XML_DTD */
    1:   p->defaultPrefix.name = NULL;
    1:   p->defaultPrefix.binding = NULL;
    1: 
    1:   p->in_eldecl = XML_FALSE;
    1:   p->scaffIndex = NULL;
    1:   p->scaffold = NULL;
    1:   p->scaffLevel = 0;
    1:   p->scaffSize = 0;
    1:   p->scaffCount = 0;
    1:   p->contentStringLen = 0;
    1: 
    1:   p->keepProcessing = XML_TRUE;
    1:   p->hasParamEntityRefs = XML_FALSE;
    1:   p->standalone = XML_FALSE;
    1:   return p;
    1: }
    1: 
    1: static void
    1: dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms)
    1: {
    1:   HASH_TABLE_ITER iter;
    1:   hashTableIterInit(&iter, &(p->elementTypes));
    1:   for (;;) {
    1:     ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);
    1:     if (!e)
    1:       break;
    1:     if (e->allocDefaultAtts != 0)
    1:       ms->free_fcn(e->defaultAtts);
    1:   }
    1:   hashTableClear(&(p->generalEntities));
    1: #ifdef XML_DTD
    1:   p->paramEntityRead = XML_FALSE;
    1:   hashTableClear(&(p->paramEntities));
    1: #endif /* XML_DTD */
    1:   hashTableClear(&(p->elementTypes));
    1:   hashTableClear(&(p->attributeIds));
    1:   hashTableClear(&(p->prefixes));
    1:   poolClear(&(p->pool));
    1:   poolClear(&(p->entityValuePool));
    1:   p->defaultPrefix.name = NULL;
    1:   p->defaultPrefix.binding = NULL;
    1: 
    1:   p->in_eldecl = XML_FALSE;
    1: 
    1:   ms->free_fcn(p->scaffIndex);
    1:   p->scaffIndex = NULL;
    1:   ms->free_fcn(p->scaffold);
    1:   p->scaffold = NULL;
    1: 
    1:   p->scaffLevel = 0;
    1:   p->scaffSize = 0;
    1:   p->scaffCount = 0;
    1:   p->contentStringLen = 0;
    1: 
    1:   p->keepProcessing = XML_TRUE;
    1:   p->hasParamEntityRefs = XML_FALSE;
    1:   p->standalone = XML_FALSE;
    1: }
    1: 
    1: static void
    1: dtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms)
    1: {
    1:   HASH_TABLE_ITER iter;
    1:   hashTableIterInit(&iter, &(p->elementTypes));
    1:   for (;;) {
    1:     ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);
    1:     if (!e)
    1:       break;
    1:     if (e->allocDefaultAtts != 0)
    1:       ms->free_fcn(e->defaultAtts);
    1:   }
    1:   hashTableDestroy(&(p->generalEntities));
    1: #ifdef XML_DTD
    1:   hashTableDestroy(&(p->paramEntities));
    1: #endif /* XML_DTD */
    1:   hashTableDestroy(&(p->elementTypes));
    1:   hashTableDestroy(&(p->attributeIds));
    1:   hashTableDestroy(&(p->prefixes));
    1:   poolDestroy(&(p->pool));
    1:   poolDestroy(&(p->entityValuePool));
    1:   if (isDocEntity) {
    1:     ms->free_fcn(p->scaffIndex);
    1:     ms->free_fcn(p->scaffold);
    1:   }
    1:   ms->free_fcn(p);
    1: }
    1: 
    1: /* Do a deep copy of the DTD. Return 0 for out of memory, non-zero otherwise.
    1:    The new DTD has already been initialized.
    1: */
    1: static int
    1: dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms)
    1: {
    1:   HASH_TABLE_ITER iter;
    1: 
    1:   /* Copy the prefix table. */
    1: 
    1:   hashTableIterInit(&iter, &(oldDtd->prefixes));
    1:   for (;;) {
    1:     const XML_Char *name;
    1:     const PREFIX *oldP = (PREFIX *)hashTableIterNext(&iter);
    1:     if (!oldP)
    1:       break;
    1:     name = poolCopyString(&(newDtd->pool), oldP->name);
    1:     if (!name)
    1:       return 0;
    1:     if (!lookup(&(newDtd->prefixes), name, sizeof(PREFIX)))
    1:       return 0;
    1:   }
    1: 
    1:   hashTableIterInit(&iter, &(oldDtd->attributeIds));
    1: 
    1:   /* Copy the attribute id table. */
    1: 
    1:   for (;;) {
    1:     ATTRIBUTE_ID *newA;
    1:     const XML_Char *name;
    1:     const ATTRIBUTE_ID *oldA = (ATTRIBUTE_ID *)hashTableIterNext(&iter);
    1: 
    1:     if (!oldA)
    1:       break;
    1:     /* Remember to allocate the scratch byte before the name. */
    1:     if (!poolAppendChar(&(newDtd->pool), XML_T('\0')))
    1:       return 0;
    1:     name = poolCopyString(&(newDtd->pool), oldA->name);
    1:     if (!name)
    1:       return 0;
    1:     ++name;
    1:     newA = (ATTRIBUTE_ID *)lookup(&(newDtd->attributeIds), name,
    1:                                   sizeof(ATTRIBUTE_ID));
    1:     if (!newA)
    1:       return 0;
    1:     newA->maybeTokenized = oldA->maybeTokenized;
    1:     if (oldA->prefix) {
    1:       newA->xmlns = oldA->xmlns;
    1:       if (oldA->prefix == &oldDtd->defaultPrefix)
    1:         newA->prefix = &newDtd->defaultPrefix;
    1:       else
    1:         newA->prefix = (PREFIX *)lookup(&(newDtd->prefixes),
    1:                                         oldA->prefix->name, 0);
    1:     }
    1:   }
    1: 
    1:   /* Copy the element type table. */
    1: 
    1:   hashTableIterInit(&iter, &(oldDtd->elementTypes));
    1: 
    1:   for (;;) {
    1:     int i;
    1:     ELEMENT_TYPE *newE;
    1:     const XML_Char *name;
    1:     const ELEMENT_TYPE *oldE = (ELEMENT_TYPE *)hashTableIterNext(&iter);
    1:     if (!oldE)
    1:       break;
    1:     name = poolCopyString(&(newDtd->pool), oldE->name);
    1:     if (!name)
    1:       return 0;
    1:     newE = (ELEMENT_TYPE *)lookup(&(newDtd->elementTypes), name,
    1:                                   sizeof(ELEMENT_TYPE));
    1:     if (!newE)
    1:       return 0;
    1:     if (oldE->nDefaultAtts) {
    1:       newE->defaultAtts = (DEFAULT_ATTRIBUTE *)
    1:           ms->malloc_fcn(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));
    1:       if (!newE->defaultAtts) {
    1:         ms->free_fcn(newE);
    1:         return 0;
    1:       }
    1:     }
    1:     if (oldE->idAtt)
    1:       newE->idAtt = (ATTRIBUTE_ID *)
    1:           lookup(&(newDtd->attributeIds), oldE->idAtt->name, 0);
    1:     newE->allocDefaultAtts = newE->nDefaultAtts = oldE->nDefaultAtts;
    1:     if (oldE->prefix)
    1:       newE->prefix = (PREFIX *)lookup(&(newDtd->prefixes),
    1:                                       oldE->prefix->name, 0);
    1:     for (i = 0; i < newE->nDefaultAtts; i++) {
    1:       newE->defaultAtts[i].id = (ATTRIBUTE_ID *)
    1:           lookup(&(newDtd->attributeIds), oldE->defaultAtts[i].id->name, 0);
    1:       newE->defaultAtts[i].isCdata = oldE->defaultAtts[i].isCdata;
    1:       if (oldE->defaultAtts[i].value) {
    1:         newE->defaultAtts[i].value
    1:             = poolCopyString(&(newDtd->pool), oldE->defaultAtts[i].value);
    1:         if (!newE->defaultAtts[i].value)
    1:           return 0;
    1:       }
    1:       else
    1:         newE->defaultAtts[i].value = NULL;
    1:     }
    1:   }
    1: 
    1:   /* Copy the entity tables. */
    1:   if (!copyEntityTable(&(newDtd->generalEntities),
    1:                        &(newDtd->pool),
    1:                        &(oldDtd->generalEntities)))
    1:       return 0;
    1: 
    1: #ifdef XML_DTD
    1:   if (!copyEntityTable(&(newDtd->paramEntities),
    1:                        &(newDtd->pool),
    1:                        &(oldDtd->paramEntities)))
    1:       return 0;
    1:   newDtd->paramEntityRead = oldDtd->paramEntityRead;
    1: #endif /* XML_DTD */
    1: 
    1:   newDtd->keepProcessing = oldDtd->keepProcessing;
    1:   newDtd->hasParamEntityRefs = oldDtd->hasParamEntityRefs;
    1:   newDtd->standalone = oldDtd->standalone;
    1: 
    1:   /* Don't want deep copying for scaffolding */
    1:   newDtd->in_eldecl = oldDtd->in_eldecl;
    1:   newDtd->scaffold = oldDtd->scaffold;
    1:   newDtd->contentStringLen = oldDtd->contentStringLen;
    1:   newDtd->scaffSize = oldDtd->scaffSize;
    1:   newDtd->scaffLevel = oldDtd->scaffLevel;
    1:   newDtd->scaffIndex = oldDtd->scaffIndex;
    1: 
    1:   return 1;
    1: }  /* End dtdCopy */
    1: 
    1: static int
    1: copyEntityTable(HASH_TABLE *newTable,
    1:                 STRING_POOL *newPool,
    1:                 const HASH_TABLE *oldTable)
    1: {
    1:   HASH_TABLE_ITER iter;
    1:   const XML_Char *cachedOldBase = NULL;
    1:   const XML_Char *cachedNewBase = NULL;
    1: 
    1:   hashTableIterInit(&iter, oldTable);
    1: 
    1:   for (;;) {
    1:     ENTITY *newE;
    1:     const XML_Char *name;
    1:     const ENTITY *oldE = (ENTITY *)hashTableIterNext(&iter);
    1:     if (!oldE)
    1:       break;
    1:     name = poolCopyString(newPool, oldE->name);
    1:     if (!name)
    1:       return 0;
    1:     newE = (ENTITY *)lookup(newTable, name, sizeof(ENTITY));
    1:     if (!newE)
    1:       return 0;
    1:     if (oldE->systemId) {
    1:       const XML_Char *tem = poolCopyString(newPool, oldE->systemId);
    1:       if (!tem)
    1:         return 0;
    1:       newE->systemId = tem;
    1:       if (oldE->base) {
    1:         if (oldE->base == cachedOldBase)
    1:           newE->base = cachedNewBase;
    1:         else {
    1:           cachedOldBase = oldE->base;
    1:           tem = poolCopyString(newPool, cachedOldBase);
    1:           if (!tem)
    1:             return 0;
    1:           cachedNewBase = newE->base = tem;
    1:         }
    1:       }
    1:       if (oldE->publicId) {
    1:         tem = poolCopyString(newPool, oldE->publicId);
    1:         if (!tem)
    1:           return 0;
    1:         newE->publicId = tem;
    1:       }
    1:     }
    1:     else {
    1:       const XML_Char *tem = poolCopyStringN(newPool, oldE->textPtr,
    1:                                             oldE->textLen);
    1:       if (!tem)
    1:         return 0;
    1:       newE->textPtr = tem;
    1:       newE->textLen = oldE->textLen;
    1:     }
    1:     if (oldE->notation) {
    1:       const XML_Char *tem = poolCopyString(newPool, oldE->notation);
    1:       if (!tem)
    1:         return 0;
    1:       newE->notation = tem;
    1:     }
    1:     newE->is_param = oldE->is_param;
    1:     newE->is_internal = oldE->is_internal;
    1:   }
    1:   return 1;
    1: }
    1: 
    1: #define INIT_POWER 6
    1: 
    1: static XML_Bool FASTCALL
    1: keyeq(KEY s1, KEY s2)
    1: {
    1:   for (; *s1 == *s2; s1++, s2++)
    1:     if (*s1 == 0)
    1:       return XML_TRUE;
    1:   return XML_FALSE;
    1: }
    1: 
    1: static unsigned long FASTCALL
    1: hash(KEY s)
    1: {
    1:   unsigned long h = 0;
    1:   while (*s)
    1:     h = CHAR_HASH(h, *s++);
    1:   return h;
    1: }
    1: 
    1: static NAMED *
    1: lookup(HASH_TABLE *table, KEY name, size_t createSize)
    1: {
    1:   size_t i;
    1:   if (table->size == 0) {
    1:     size_t tsize;
    1:     if (!createSize)
    1:       return NULL;
    1:     table->power = INIT_POWER;
    1:     /* table->size is a power of 2 */
    1:     table->size = (size_t)1 << INIT_POWER;
    1:     tsize = table->size * sizeof(NAMED *);
    1:     table->v = (NAMED **)table->mem->malloc_fcn(tsize);
    1:     if (!table->v) {
    1:       table->size = 0;
    1:       return NULL;
    1:     }
    1:     memset(table->v, 0, tsize);
    1:     i = hash(name) & ((unsigned long)table->size - 1);
    1:   }
    1:   else {
    1:     unsigned long h = hash(name);
    1:     unsigned long mask = (unsigned long)table->size - 1;
    1:     unsigned char step = 0;
    1:     i = h & mask;
    1:     while (table->v[i]) {
    1:       if (keyeq(name, table->v[i]->name))
    1:         return table->v[i];
    1:       if (!step)
    1:         step = PROBE_STEP(h, mask, table->power);
    1:       i < step ? (i += table->size - step) : (i -= step);
    1:     }
    1:     if (!createSize)
    1:       return NULL;
    1: 
    1:     /* check for overflow (table is half full) */
    1:     if (table->used >> (table->power - 1)) {
    1:       unsigned char newPower = table->power + 1;
    1:       size_t newSize = (size_t)1 << newPower;
    1:       unsigned long newMask = (unsigned long)newSize - 1;
    1:       size_t tsize = newSize * sizeof(NAMED *);
    1:       NAMED **newV = (NAMED **)table->mem->malloc_fcn(tsize);
    1:       if (!newV)
    1:         return NULL;
    1:       memset(newV, 0, tsize);
    1:       for (i = 0; i < table->size; i++)
    1:         if (table->v[i]) {
    1:           unsigned long newHash = hash(table->v[i]->name);
    1:           size_t j = newHash & newMask;
    1:           step = 0;
    1:           while (newV[j]) {
    1:             if (!step)
    1:               step = PROBE_STEP(newHash, newMask, newPower);
    1:             j < step ? (j += newSize - step) : (j -= step);
    1:           }
    1:           newV[j] = table->v[i];
    1:         }
    1:       table->mem->free_fcn(table->v);
    1:       table->v = newV;
    1:       table->power = newPower;
    1:       table->size = newSize;
    1:       i = h & newMask;
    1:       step = 0;
    1:       while (table->v[i]) {
    1:         if (!step)
    1:           step = PROBE_STEP(h, newMask, newPower);
    1:         i < step ? (i += newSize - step) : (i -= step);
    1:       }
    1:     }
    1:   }
    1:   table->v[i] = (NAMED *)table->mem->malloc_fcn(createSize);
    1:   if (!table->v[i])
    1:     return NULL;
    1:   memset(table->v[i], 0, createSize);
    1:   table->v[i]->name = name;
    1:   (table->used)++;
    1:   return table->v[i];
    1: }
    1: 
    1: static void FASTCALL
    1: hashTableClear(HASH_TABLE *table)
    1: {
    1:   size_t i;
    1:   for (i = 0; i < table->size; i++) {
    1:     table->mem->free_fcn(table->v[i]);
    1:     table->v[i] = NULL;
    1:   }
    1:   table->used = 0;
    1: }
    1: 
    1: static void FASTCALL
    1: hashTableDestroy(HASH_TABLE *table)
    1: {
    1:   size_t i;
    1:   for (i = 0; i < table->size; i++)
    1:     table->mem->free_fcn(table->v[i]);
    1:   table->mem->free_fcn(table->v);
    1: }
    1: 
    1: static void FASTCALL
    1: hashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms)
    1: {
    1:   p->power = 0;
    1:   p->size = 0;
    1:   p->used = 0;
    1:   p->v = NULL;
    1:   p->mem = ms;
    1: }
    1: 
    1: static void FASTCALL
    1: hashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table)
    1: {
    1:   iter->p = table->v;
    1:   iter->end = iter->p + table->size;
    1: }
    1: 
    1: static NAMED * FASTCALL
    1: hashTableIterNext(HASH_TABLE_ITER *iter)
    1: {
    1:   while (iter->p != iter->end) {
    1:     NAMED *tem = *(iter->p)++;
    1:     if (tem)
    1:       return tem;
    1:   }
    1:   return NULL;
    1: }
    1: 
    1: static void FASTCALL
    1: poolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms)
    1: {
    1:   pool->blocks = NULL;
    1:   pool->freeBlocks = NULL;
    1:   pool->start = NULL;
    1:   pool->ptr = NULL;
    1:   pool->end = NULL;
    1:   pool->mem = ms;
    1: }
    1: 
    1: static void FASTCALL
    1: poolClear(STRING_POOL *pool)
    1: {
    1:   if (!pool->freeBlocks)
    1:     pool->freeBlocks = pool->blocks;
    1:   else {
    1:     BLOCK *p = pool->blocks;
    1:     while (p) {
    1:       BLOCK *tem = p->next;
    1:       p->next = pool->freeBlocks;
    1:       pool->freeBlocks = p;
    1:       p = tem;
    1:     }
    1:   }
    1:   pool->blocks = NULL;
    1:   pool->start = NULL;
    1:   pool->ptr = NULL;
    1:   pool->end = NULL;
    1: }
    1: 
    1: static void FASTCALL
    1: poolDestroy(STRING_POOL *pool)
    1: {
    1:   BLOCK *p = pool->blocks;
    1:   while (p) {
    1:     BLOCK *tem = p->next;
    1:     pool->mem->free_fcn(p);
    1:     p = tem;
    1:   }
    1:   p = pool->freeBlocks;
    1:   while (p) {
    1:     BLOCK *tem = p->next;
    1:     pool->mem->free_fcn(p);
    1:     p = tem;
    1:   }
    1: }
    1: 
    1: static XML_Char *
    1: poolAppend(STRING_POOL *pool, const ENCODING *enc,
    1:            const char *ptr, const char *end)
    1: {
    1:   if (!pool->ptr && !poolGrow(pool))
    1:     return NULL;
    1:   for (;;) {
    1:     XmlConvert(enc, &ptr, end, (ICHAR **)&(pool->ptr), (ICHAR *)pool->end);
    1:     if (ptr == end)
    1:       break;
    1:     if (!poolGrow(pool))
    1:       return NULL;
    1:   }
    1:   return pool->start;
    1: }
    1: 
    1: static const XML_Char * FASTCALL
    1: poolCopyString(STRING_POOL *pool, const XML_Char *s)
    1: {
    1:   do {
    1:     if (!poolAppendChar(pool, *s))
    1:       return NULL;
    1:   } while (*s++);
    1:   s = pool->start;
    1:   poolFinish(pool);
    1:   return s;
    1: }
    1: 
    1: static const XML_Char *
    1: poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n)
    1: {
    1:   if (!pool->ptr && !poolGrow(pool))
    1:     return NULL;
    1:   for (; n > 0; --n, s++) {
    1:     if (!poolAppendChar(pool, *s))
    1:       return NULL;
    1:   }
    1:   s = pool->start;
    1:   poolFinish(pool);
    1:   return s;
    1: }
    1: 
    1: static const XML_Char * FASTCALL
    1: poolAppendString(STRING_POOL *pool, const XML_Char *s)
    1: {
    1:   while (*s) {
    1:     if (!poolAppendChar(pool, *s))
    1:       return NULL;
    1:     s++;
    1:   }
    1:   return pool->start;
    1: }
    1: 
    1: static XML_Char *
    1: poolStoreString(STRING_POOL *pool, const ENCODING *enc,
    1:                 const char *ptr, const char *end)
    1: {
    1:   if (!poolAppend(pool, enc, ptr, end))
    1:     return NULL;
    1:   if (pool->ptr == pool->end && !poolGrow(pool))
    1:     return NULL;
    1:   *(pool->ptr)++ = 0;
    1:   return pool->start;
    1: }
    1: 
    1: static XML_Bool FASTCALL
    1: poolGrow(STRING_POOL *pool)
    1: {
    1:   if (pool->freeBlocks) {
    1:     if (pool->start == 0) {
    1:       pool->blocks = pool->freeBlocks;
    1:       pool->freeBlocks = pool->freeBlocks->next;
    1:       pool->blocks->next = NULL;
    1:       pool->start = pool->blocks->s;
    1:       pool->end = pool->start + pool->blocks->size;
    1:       pool->ptr = pool->start;
    1:       return XML_TRUE;
    1:     }
    1:     if (pool->end - pool->start < pool->freeBlocks->size) {
    1:       BLOCK *tem = pool->freeBlocks->next;
    1:       pool->freeBlocks->next = pool->blocks;
    1:       pool->blocks = pool->freeBlocks;
    1:       pool->freeBlocks = tem;
    1:       memcpy(pool->blocks->s, pool->start,
    1:              (pool->end - pool->start) * sizeof(XML_Char));
    1:       pool->ptr = pool->blocks->s + (pool->ptr - pool->start);
    1:       pool->start = pool->blocks->s;
    1:       pool->end = pool->start + pool->blocks->size;
    1:       return XML_TRUE;
    1:     }
    1:   }
    1:   if (pool->blocks && pool->start == pool->blocks->s) {
    1:     int blockSize = (int)(pool->end - pool->start)*2;
    1:     pool->blocks = (BLOCK *)
    1:       pool->mem->realloc_fcn(pool->blocks,
    1:                              (offsetof(BLOCK, s)
    1:                               + blockSize * sizeof(XML_Char)));
    1:     if (pool->blocks == NULL)
    1:       return XML_FALSE;
    1:     pool->blocks->size = blockSize;
    1:     pool->ptr = pool->blocks->s + (pool->ptr - pool->start);
    1:     pool->start = pool->blocks->s;
    1:     pool->end = pool->start + blockSize;
    1:   }
    1:   else {
    1:     BLOCK *tem;
    1:     int blockSize = (int)(pool->end - pool->start);
    1:     if (blockSize < INIT_BLOCK_SIZE)
    1:       blockSize = INIT_BLOCK_SIZE;
    1:     else
    1:       blockSize *= 2;
    1:     tem = (BLOCK *)pool->mem->malloc_fcn(offsetof(BLOCK, s)
    1:                                         + blockSize * sizeof(XML_Char));
    1:     if (!tem)
    1:       return XML_FALSE;
    1:     tem->size = blockSize;
    1:     tem->next = pool->blocks;
    1:     pool->blocks = tem;
    1:     if (pool->ptr != pool->start)
    1:       memcpy(tem->s, pool->start,
    1:              (pool->ptr - pool->start) * sizeof(XML_Char));
    1:     pool->ptr = tem->s + (pool->ptr - pool->start);
    1:     pool->start = tem->s;
    1:     pool->end = tem->s + blockSize;
    1:   }
    1:   return XML_TRUE;
    1: }
    1: 
    1: static int FASTCALL
    1: nextScaffoldPart(XML_Parser parser)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   CONTENT_SCAFFOLD * me;
    1:   int next;
    1: 
    1:   if (!dtd->scaffIndex) {
    1:     dtd->scaffIndex = (int *)MALLOC(groupSize * sizeof(int));
    1:     if (!dtd->scaffIndex)
    1:       return -1;
    1:     dtd->scaffIndex[0] = 0;
    1:   }
    1: 
    1:   if (dtd->scaffCount >= dtd->scaffSize) {
    1:     CONTENT_SCAFFOLD *temp;
    1:     if (dtd->scaffold) {
    1:       temp = (CONTENT_SCAFFOLD *)
    1:         REALLOC(dtd->scaffold, dtd->scaffSize * 2 * sizeof(CONTENT_SCAFFOLD));
    1:       if (temp == NULL)
    1:         return -1;
    1:       dtd->scaffSize *= 2;
    1:     }
    1:     else {
    1:       temp = (CONTENT_SCAFFOLD *)MALLOC(INIT_SCAFFOLD_ELEMENTS
    1:                                         * sizeof(CONTENT_SCAFFOLD));
    1:       if (temp == NULL)
    1:         return -1;
    1:       dtd->scaffSize = INIT_SCAFFOLD_ELEMENTS;
    1:     }
    1:     dtd->scaffold = temp;
    1:   }
    1:   next = dtd->scaffCount++;
    1:   me = &dtd->scaffold[next];
    1:   if (dtd->scaffLevel) {
    1:     CONTENT_SCAFFOLD *parent = &dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel-1]];
    1:     if (parent->lastchild) {
    1:       dtd->scaffold[parent->lastchild].nextsib = next;
    1:     }
    1:     if (!parent->childcnt)
    1:       parent->firstchild = next;
    1:     parent->lastchild = next;
    1:     parent->childcnt++;
    1:   }
    1:   me->firstchild = me->lastchild = me->childcnt = me->nextsib = 0;
    1:   return next;
    1: }
    1: 
    1: static void
    1: build_node(XML_Parser parser,
    1:            int src_node,
    1:            XML_Content *dest,
    1:            XML_Content **contpos,
    1:            XML_Char **strpos)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   dest->type = dtd->scaffold[src_node].type;
    1:   dest->quant = dtd->scaffold[src_node].quant;
    1:   if (dest->type == XML_CTYPE_NAME) {
    1:     const XML_Char *src;
    1:     dest->name = *strpos;
    1:     src = dtd->scaffold[src_node].name;
    1:     for (;;) {
    1:       *(*strpos)++ = *src;
    1:       if (!*src)
    1:         break;
    1:       src++;
    1:     }
    1:     dest->numchildren = 0;
    1:     dest->children = NULL;
    1:   }
    1:   else {
    1:     unsigned int i;
    1:     int cn;
    1:     dest->numchildren = dtd->scaffold[src_node].childcnt;
    1:     dest->children = *contpos;
    1:     *contpos += dest->numchildren;
    1:     for (i = 0, cn = dtd->scaffold[src_node].firstchild;
    1:          i < dest->numchildren;
    1:          i++, cn = dtd->scaffold[cn].nextsib) {
    1:       build_node(parser, cn, &(dest->children[i]), contpos, strpos);
    1:     }
    1:     dest->name = NULL;
    1:   }
    1: }
    1: 
    1: static XML_Content *
    1: build_model (XML_Parser parser)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   XML_Content *ret;
    1:   XML_Content *cpos;
    1:   XML_Char * str;
    1:   int allocsize = (dtd->scaffCount * sizeof(XML_Content)
    1:                    + (dtd->contentStringLen * sizeof(XML_Char)));
    1: 
    1:   ret = (XML_Content *)MALLOC(allocsize);
    1:   if (!ret)
    1:     return NULL;
    1: 
    1:   str =  (XML_Char *) (&ret[dtd->scaffCount]);
    1:   cpos = &ret[1];
    1: 
    1:   build_node(parser, 0, ret, &cpos, &str);
    1:   return ret;
    1: }
    1: 
    1: static ELEMENT_TYPE *
    1: getElementType(XML_Parser parser,
    1:                const ENCODING *enc,
    1:                const char *ptr,
    1:                const char *end)
    1: {
    1:   DTD * const dtd = _dtd;  /* save one level of indirection */
    1:   const XML_Char *name = poolStoreString(&dtd->pool, enc, ptr, end);
    1:   ELEMENT_TYPE *ret;
    1: 
    1:   if (!name)
    1:     return NULL;
    1:   ret = (ELEMENT_TYPE *) lookup(&dtd->elementTypes, name, sizeof(ELEMENT_TYPE));
    1:   if (!ret)
    1:     return NULL;
    1:   if (ret->name != name)
    1:     poolDiscard(&dtd->pool);
    1:   else {
    1:     poolFinish(&dtd->pool);
    1:     if (!setElementTypePrefix(parser, ret))
    1:       return NULL;
    1:   }
    1:   return ret;
    1: }
