    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brian Ryner <bryner@brianryner.com>
    1:  *   Javier Delgadillo <javi@netscape.com>
    1:  *   Kai Engert <kengert@redhat.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsNSSComponent.h"
    1: #include "nsNSSIOLayer.h"
    1: #include "nsNSSCallbacks.h"
    1: 
    1: #include "prlog.h"
    1: #include "prnetdb.h"
    1: #include "nsIPrompt.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIWebProgressListener.h"
    1: #include "nsIChannel.h"
    1: #include "nsNSSCertificate.h"
 6597: #include "nsIX509CertValidity.h"
    1: #include "nsIProxyObjectManager.h"
    1: #include "nsProxiedService.h"
    1: #include "nsIDateTimeFormat.h"
    1: #include "nsDateTimeFormatCID.h"
    1: #include "nsIClientAuthDialogs.h"
 6597: #include "nsICertOverrideService.h"
 6597: #include "nsIBadCertListener2.h"
10284: #include "nsISSLErrorListener.h"
 8463: #include "nsIObjectInputStream.h"
 8463: #include "nsIObjectOutputStream.h"
 7054: #include "nsRecentBadCerts.h"
18398: #include "nsISSLCertErrorDialog.h"
    1: 
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsHashSets.h"
    1: #include "nsCRT.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsAutoLock.h"
    1: #include "nsSSLThread.h"
    1: #include "nsNSSShutDown.h"
 6597: #include "nsSSLStatus.h"
    1: #include "nsNSSCertHelper.h"
    1: #include "nsNSSCleaner.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsIDocShell.h"
13186: #include "nsIDocShellTreeItem.h"
    1: #include "nsISecureBrowserUI.h"
 2772: #include "nsProxyRelease.h"
 8463: #include "nsIClassInfoImpl.h"
 8463: #include "nsIProgrammingLanguage.h"
    1: 
    1: #include "ssl.h"
    1: #include "secerr.h"
    1: #include "sslerr.h"
    1: #include "secder.h"
    1: #include "secasn1.h"
    1: #include "certdb.h"
    1: #include "cert.h"
    1: #include "keyhi.h"
 6597: #include "secport.h"
    1: 
    1: 
    1: //#define DEBUG_SSL_VERBOSE //Enable this define to get minimal 
    1:                             //reports when doing SSL read/write
    1:                             
    1: //#define DUMP_BUFFER  //Enable this define along with
    1:                        //DEBUG_SSL_VERBOSE to dump SSL
    1:                        //read/write buffer to a log.
    1:                        //Uses PR_LOG except on Mac where
    1:                        //we always write out to our own
    1:                        //file.
    1: 
    1: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
 6597: NSSCleanupAutoPtrClass(char, PR_FREEIF)
 6597: NSSCleanupAutoPtrClass_WithParam(PRArenaPool, PORT_FreeArena, FalseParam, PR_FALSE)
    1: 
    1: /* SSM_UserCertChoice: enum for cert choice info */
    1: typedef enum {ASK, AUTO} SSM_UserCertChoice;
    1: 
    1: 
    1: static SECStatus PR_CALLBACK
    1: nsNSS_SSLGetClientAuthData(void *arg, PRFileDesc *socket,
    1: 						   CERTDistNames *caNames,
    1: 						   CERTCertificate **pRetCert,
    1: 						   SECKEYPrivateKey **pRetKey);
    1: static SECStatus PR_CALLBACK
    1: nsNSS_SSLGetClientAuthData(void *arg, PRFileDesc *socket,
    1: 						   CERTDistNames *caNames,
    1: 						   CERTCertificate **pRetCert,
    1: 						   SECKEYPrivateKey **pRetKey);
    1: #ifdef PR_LOGGING
    1: extern PRLogModuleInfo* gPIPNSSLog;
    1: #endif
    1: 
    1: #if defined(DEBUG_SSL_VERBOSE) && defined (XP_MAC)
    1: 
    1: #ifdef PR_LOG
    1: #undef PR_LOG
    1: #endif
    1: 
    1: static PRFileDesc *gMyLogFile = nsnull;
    1: #define MAC_LOG_FILE "MAC PIPNSS Log File"
    1: 
    1: void MyLogFunction(const char *fmt, ...)
    1: {
    1:   
    1:   va_list ap;
    1:   va_start(ap,fmt);
    1:   if (gMyLogFile == nsnull)
    1:     gMyLogFile = PR_Open(MAC_LOG_FILE, PR_WRONLY | PR_CREATE_FILE | PR_APPEND,
    1:                          0600);
    1:   if (!gMyLogFile)
    1:       return;
    1:   PR_vfprintf(gMyLogFile, fmt, ap);
    1:   va_end(ap);
    1: }
    1: 
    1: #define PR_LOG(module,level,args) MyLogFunction args
    1: #endif
    1: 
    1: 
    1: nsSSLSocketThreadData::nsSSLSocketThreadData()
    1: : mSSLState(ssl_idle)
    1: , mPRErrorCode(PR_SUCCESS)
    1: , mSSLDataBuffer(nsnull)
    1: , mSSLDataBufferAllocatedSize(0)
    1: , mSSLRequestedTransferAmount(0)
    1: , mSSLRemainingReadResultData(nsnull)
    1: , mSSLResultRemainingBytes(0)
    1: , mReplacedSSLFileDesc(nsnull)
 2237: , mOneBytePendingFromEarlierWrite(PR_FALSE)
 2237: , mThePendingByte(0)
 2237: , mOriginalRequestedTransferAmount(0)
    1: {
    1: }
    1: 
    1: nsSSLSocketThreadData::~nsSSLSocketThreadData()
    1: {
    1:   NS_ASSERTION(mSSLState != ssl_pending_write
    1:                &&
    1:                mSSLState != ssl_pending_read, 
    1:                "oops??? ssl socket is not idle at the time it is being destroyed");
12060:   if (mSSLDataBuffer) {
12060:     nsMemory::Free(mSSLDataBuffer);
12060:   }
    1: }
    1: 
    1: PRBool nsSSLSocketThreadData::ensure_buffer_size(PRInt32 amount)
    1: {
    1:   if (amount > mSSLDataBufferAllocatedSize) {
    1:     if (mSSLDataBuffer) {
    1:       mSSLDataBuffer = (char*)nsMemory::Realloc(mSSLDataBuffer, amount);
    1:     }
    1:     else {
    1:       mSSLDataBuffer = (char*)nsMemory::Alloc(amount);
    1:     }
    1:     
    1:     if (!mSSLDataBuffer)
    1:       return PR_FALSE;
    1: 
    1:     mSSLDataBufferAllocatedSize = amount;
    1:   }
    1:   
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsNSSSocketInfo::nsNSSSocketInfo()
    1:   : mFd(nsnull),
    1:     mBlockingState(blocking_state_unknown),
    1:     mSecurityState(nsIWebProgressListener::STATE_IS_INSECURE),
14244:     mSubRequestsHighSecurity(0),
14244:     mSubRequestsLowSecurity(0),
14244:     mSubRequestsBrokenSecurity(0),
14244:     mSubRequestsNoSecurity(0),
14244:     mDocShellDependentStuffKnown(PR_FALSE),
    1:     mExternalErrorReporting(PR_FALSE),
    1:     mForSTARTTLS(PR_FALSE),
    1:     mHandshakePending(PR_TRUE),
    1:     mCanceled(PR_FALSE),
    1:     mHasCleartextPhase(PR_FALSE),
    1:     mHandshakeInProgress(PR_FALSE),
    1:     mAllowTLSIntoleranceTimeout(PR_TRUE),
    1:     mHandshakeStartTime(0),
 8463:     mPort(0)
    1: {
    1:   mThreadData = new nsSSLSocketThreadData;
    1: }
    1: 
    1: nsNSSSocketInfo::~nsNSSSocketInfo()
    1: {
    1:   delete mThreadData;
    1: 
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (isAlreadyShutDown())
    1:     return;
    1: 
    1:   shutdown(calledFromObject);
    1: }
    1: 
    1: void nsNSSSocketInfo::virtualDestroyNSSReference()
    1: {
    1: }
    1: 
20054: NS_IMPL_THREADSAFE_ISUPPORTS8(nsNSSSocketInfo,
    1:                               nsITransportSecurityInfo,
    1:                               nsISSLSocketControl,
    1:                               nsIInterfaceRequestor,
 5220:                               nsISSLStatusProvider,
 8463:                               nsIIdentityInfo,
14244:                               nsIAssociatedContentSecurity,
 8463:                               nsISerializable,
20054:                               nsIClassInfo)
    1: 
    1: nsresult
    1: nsNSSSocketInfo::GetHandshakePending(PRBool *aHandshakePending)
    1: {
    1:   *aHandshakePending = mHandshakePending;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetHandshakePending(PRBool aHandshakePending)
    1: {
    1:   mHandshakePending = aHandshakePending;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetHostName(const char* host)
    1: {
    1:   mHostName.Adopt(host ? nsCRT::strdup(host) : 0);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::GetHostName(char **host)
    1: {
    1:   *host = (mHostName) ? nsCRT::strdup(mHostName) : nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetPort(PRInt32 aPort)
    1: {
    1:   mPort = aPort;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::GetPort(PRInt32 *aPort)
    1: {
    1:   *aPort = mPort;
    1:   return NS_OK;
    1: }
    1: 
    1: void nsNSSSocketInfo::SetCanceled(PRBool aCanceled)
    1: {
    1:   mCanceled = aCanceled;
    1: }
    1: 
    1: PRBool nsNSSSocketInfo::GetCanceled()
    1: {
    1:   return mCanceled;
    1: }
    1: 
    1: void nsNSSSocketInfo::SetHasCleartextPhase(PRBool aHasCleartextPhase)
    1: {
    1:   mHasCleartextPhase = aHasCleartextPhase;
    1: }
    1: 
    1: PRBool nsNSSSocketInfo::GetHasCleartextPhase()
    1: {
    1:   return mHasCleartextPhase;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::GetNotificationCallbacks(nsIInterfaceRequestor** aCallbacks)
    1: {
    1:   *aCallbacks = mCallbacks;
    1:   NS_IF_ADDREF(*aCallbacks);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::SetNotificationCallbacks(nsIInterfaceRequestor* aCallbacks)
    1: {
    1:   if (!aCallbacks) {
    1:     mCallbacks = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
14244:   mCallbacks = aCallbacks;
14244:   mDocShellDependentStuffKnown = PR_FALSE;
14244: 
14244:   return NS_OK;
14244: }
14244: 
14244: nsresult
14244: nsNSSSocketInfo::EnsureDocShellDependentStuffKnown()
14244: {
14244:   if (mDocShellDependentStuffKnown)
14244:     return NS_OK;
14244: 
14244:   if (!mCallbacks || nsSSLThread::exitRequested())
14244:     return NS_ERROR_FAILURE;
14244: 
14244:   mDocShellDependentStuffKnown = PR_TRUE;
14244: 
    1:   nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
    1:   NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                        NS_GET_IID(nsIInterfaceRequestor),
14244:                        static_cast<nsIInterfaceRequestor*>(mCallbacks),
    1:                        NS_PROXY_SYNC,
    1:                        getter_AddRefs(proxiedCallbacks));
    1: 
    1:   // Are we running within a context that wants external SSL error reporting?
    1:   // We'll look at the presence of a security UI object inside docshell.
    1:   // If the docshell wants the lock icon, you'll get the ssl error pages, too.
    1:   // This is helpful to distinguish from all other contexts, like mail windows,
    1:   // or any other SSL connections running in the background.
    1:   // We must query it now and remember, because fatal SSL errors will come 
    1:   // with a socket close, and the socket transport might detach the callbacks 
    1:   // instance prior to our error reporting.
    1: 
13186:   nsCOMPtr<nsIDocShell> docshell;
13186: 
14244:   nsCOMPtr<nsIDocShellTreeItem> item(do_GetInterface(proxiedCallbacks));
13186:   if (item)
13186:   {
13186:     nsCOMPtr<nsIDocShellTreeItem> proxiedItem;
13186:     nsCOMPtr<nsIDocShellTreeItem> rootItem;
13186:     NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
13186:                          NS_GET_IID(nsIDocShellTreeItem),
13186:                          item.get(),
13186:                          NS_PROXY_SYNC,
13186:                          getter_AddRefs(proxiedItem));
13186: 
13186:     proxiedItem->GetSameTypeRootTreeItem(getter_AddRefs(rootItem));
13186:     docshell = do_QueryInterface(rootItem);
13186:     NS_ASSERTION(docshell, "rootItem do_QI is null");
13186:   }
13186: 
    1:   if (docshell)
    1:   {
 2772:     nsCOMPtr<nsIDocShell> proxiedDocShell;
 2772:     NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
 2772:                          NS_GET_IID(nsIDocShell),
 2772:                          docshell.get(),
 2772:                          NS_PROXY_SYNC,
 2772:                          getter_AddRefs(proxiedDocShell));
 2772:     nsISecureBrowserUI* secureUI;
 2772:     proxiedDocShell->GetSecurityUI(&secureUI);
    1:     if (secureUI)
    1:     {
 2772:       nsCOMPtr<nsIThread> mainThread(do_GetMainThread());
 2772:       NS_ProxyRelease(mainThread, secureUI, PR_FALSE);
    1:       mExternalErrorReporting = PR_TRUE;
10258: 
10258:       // If this socket is associated to a docshell, let's try to remember
10258:       // the currently used cert. If this socket gets a notification from NSS
10258:       // having the same raw socket, we can keep the PSM wrapper object
10258:       // and all the data it has cached (like verification results).
10258:       nsCOMPtr<nsISSLStatusProvider> statprov = do_QueryInterface(secureUI);
10258:       if (statprov) {
10258:         nsCOMPtr<nsISupports> isup_stat;
10258:         statprov->GetSSLStatus(getter_AddRefs(isup_stat));
10258:         if (isup_stat) {
10258:           nsCOMPtr<nsISSLStatus> sslstat = do_QueryInterface(isup_stat);
10258:           if (sslstat) {
10258:             sslstat->GetServerCert(getter_AddRefs(mPreviousCert));
10258:           }
10258:         }
10258:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::GetExternalErrorReporting(PRBool* state)
    1: {
14244:   nsresult rv = EnsureDocShellDependentStuffKnown();
14244:   NS_ENSURE_SUCCESS(rv, rv);
    1:   *state = mExternalErrorReporting;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetExternalErrorReporting(PRBool aState)
    1: {
    1:   mExternalErrorReporting = aState;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::GetSecurityState(PRUint32* state)
    1: {
    1:   *state = mSecurityState;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetSecurityState(PRUint32 aState)
    1: {
    1:   mSecurityState = aState;
    1:   return NS_OK;
    1: }
    1: 
14244: /* attribute unsigned long countSubRequestsHighSecurity; */
14244: NS_IMETHODIMP nsNSSSocketInfo::GetCountSubRequestsHighSecurity(PRInt32 *aSubRequestsHighSecurity)
14244: {
14244:   *aSubRequestsHighSecurity = mSubRequestsHighSecurity;
14244:   return NS_OK;
14244: }
14244: NS_IMETHODIMP nsNSSSocketInfo::SetCountSubRequestsHighSecurity(PRInt32 aSubRequestsHighSecurity)
14244: {
14244:   mSubRequestsHighSecurity = aSubRequestsHighSecurity;
14244:   return NS_ERROR_NOT_IMPLEMENTED;
14244: }
14244: 
14244: /* attribute unsigned long countSubRequestsLowSecurity; */
14244: NS_IMETHODIMP nsNSSSocketInfo::GetCountSubRequestsLowSecurity(PRInt32 *aSubRequestsLowSecurity)
14244: {
14244:   *aSubRequestsLowSecurity = mSubRequestsLowSecurity;
14244:   return NS_OK;
14244: }
14244: NS_IMETHODIMP nsNSSSocketInfo::SetCountSubRequestsLowSecurity(PRInt32 aSubRequestsLowSecurity)
14244: {
14244:   mSubRequestsLowSecurity = aSubRequestsLowSecurity;
14244:   return NS_OK;
14244: }
14244: 
14244: /* attribute unsigned long countSubRequestsBrokenSecurity; */
14244: NS_IMETHODIMP nsNSSSocketInfo::GetCountSubRequestsBrokenSecurity(PRInt32 *aSubRequestsBrokenSecurity)
14244: {
14244:   *aSubRequestsBrokenSecurity = mSubRequestsBrokenSecurity;
14244:   return NS_OK;
14244: }
14244: NS_IMETHODIMP nsNSSSocketInfo::SetCountSubRequestsBrokenSecurity(PRInt32 aSubRequestsBrokenSecurity)
14244: {
14244:   mSubRequestsBrokenSecurity = aSubRequestsBrokenSecurity;
14244:   return NS_OK;
14244: }
14244: 
14244: /* attribute unsigned long countSubRequestsNoSecurity; */
14244: NS_IMETHODIMP nsNSSSocketInfo::GetCountSubRequestsNoSecurity(PRInt32 *aSubRequestsNoSecurity)
14244: {
14244:   *aSubRequestsNoSecurity = mSubRequestsNoSecurity;
14244:   return NS_OK;
14244: }
14244: NS_IMETHODIMP nsNSSSocketInfo::SetCountSubRequestsNoSecurity(PRInt32 aSubRequestsNoSecurity)
14244: {
14244:   mSubRequestsNoSecurity = aSubRequestsNoSecurity;
14244:   return NS_OK;
14244: }
14244: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::GetShortSecurityDescription(PRUnichar** aText) {
    1:   if (mShortDesc.IsEmpty())
    1:     *aText = nsnull;
    1:   else {
    1:     *aText = ToNewUnicode(mShortDesc);
    1:     NS_ENSURE_TRUE(*aText, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetShortSecurityDescription(const PRUnichar* aText) {
    1:   mShortDesc.Assign(aText);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::GetErrorMessage(PRUnichar** aText) {
    1:   if (mErrorMessage.IsEmpty())
    1:     *aText = nsnull;
    1:   else {
    1:     *aText = ToNewUnicode(mErrorMessage);
    1:     NS_ENSURE_TRUE(*aText, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetErrorMessage(const PRUnichar* aText) {
    1:   mErrorMessage.Assign(aText);
    1:   return NS_OK;
    1: }
    1: 
    1: /* void getInterface (in nsIIDRef uuid, [iid_is (uuid), retval] out nsQIResult result); */
    1: NS_IMETHODIMP nsNSSSocketInfo::GetInterface(const nsIID & uuid, void * *result)
    1: {
    1:   nsresult rv;
    1:   if (!mCallbacks) {
    1:     nsCOMPtr<nsIInterfaceRequestor> ir = new PipUIContext();
    1:     if (!ir)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     rv = ir->GetInterface(uuid, result);
    1:   } else {
14244:     if (nsSSLThread::exitRequested())
14244:       return NS_ERROR_FAILURE;
14244: 
14244:     nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
14244:     NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
14244:                          NS_GET_IID(nsIInterfaceRequestor),
14244:                          mCallbacks,
14244:                          NS_PROXY_SYNC,
14244:                          getter_AddRefs(proxiedCallbacks));
14244: 
14244:     rv = proxiedCallbacks->GetInterface(uuid, result);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::GetForSTARTTLS(PRBool* aForSTARTTLS)
    1: {
    1:   *aForSTARTTLS = mForSTARTTLS;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNSSSocketInfo::SetForSTARTTLS(PRBool aForSTARTTLS)
    1: {
    1:   mForSTARTTLS = aForSTARTTLS;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::ProxyStartSSL()
    1: {
    1:   return ActivateSSL();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNSSSocketInfo::StartTLS()
    1: {
    1:   return ActivateSSL();
    1: }
    1: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::Write(nsIObjectOutputStream* stream) {
 8463:   stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsIX509Cert*, mCert),
 8463:                               NS_GET_IID(nsISupports), PR_TRUE);
 8463:   stream->Write32(mSecurityState);
 8463:   stream->WriteWStringZ(mShortDesc.get());
 8463:   stream->WriteWStringZ(mErrorMessage.get());
 8463: 
 8463:   stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsISSLStatus*, mSSLStatus),
 8463:                               NS_GET_IID(nsISupports), PR_TRUE);
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::Read(nsIObjectInputStream* stream) {
 8463:   nsCOMPtr<nsISupports> obj;
 8463:   stream->ReadObject(PR_TRUE, getter_AddRefs(obj));
 8463:   mCert = reinterpret_cast<nsNSSCertificate*>(obj.get());
 8463: 
 8463:   stream->Read32(&mSecurityState);
 8463:   stream->ReadString(mShortDesc);
 8463:   stream->ReadString(mErrorMessage);
 8463: 
 8463:   stream->ReadObject(PR_TRUE, getter_AddRefs(obj));
 8463:   mSSLStatus = reinterpret_cast<nsSSLStatus*>(obj.get());
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetInterfaces(PRUint32 *count, nsIID * **array)
 8463: {
 8463:   *count = 0;
 8463:   *array = nsnull;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetHelperForLanguage(PRUint32 language, nsISupports **_retval)
 8463: {
 8463:   *_retval = nsnull;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetContractID(char * *aContractID)
 8463: {
 8463:   *aContractID = nsnull;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetClassDescription(char * *aClassDescription)
 8463: {
 8463:   *aClassDescription = nsnull;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetClassID(nsCID * *aClassID)
 8463: {
 8463:   *aClassID = (nsCID*) nsMemory::Alloc(sizeof(nsCID));
 8463:   if (!*aClassID)
 8463:     return NS_ERROR_OUT_OF_MEMORY;
 8463:   return GetClassIDNoAlloc(*aClassID);
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
 8463: {
 8463:   *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetFlags(PRUint32 *aFlags)
 8463: {
 8463:   *aFlags = 0;
 8463:   return NS_OK;
 8463: }
 8463: 
 8463: static NS_DEFINE_CID(kNSSSocketInfoCID, NS_NSSSOCKETINFO_CID);
 8463: 
 8463: NS_IMETHODIMP
 8463: nsNSSSocketInfo::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
 8463: {
 8463:   *aClassIDNoAlloc = kNSSSocketInfoCID;
 8463:   return NS_OK;
 8463: }
 8463: 
    1: nsresult nsNSSSocketInfo::ActivateSSL()
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (isAlreadyShutDown())
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   nsresult rv = nsSSLThread::requestActivateSSL(this);
    1:   
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   mHandshakePending = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsNSSSocketInfo::GetFileDescPtr(PRFileDesc** aFilePtr)
    1: {
    1:   *aFilePtr = mFd;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsNSSSocketInfo::SetFileDescPtr(PRFileDesc* aFilePtr)
    1: {
    1:   mFd = aFilePtr;
    1:   return NS_OK;
    1: }
    1: 
10258: nsresult nsNSSSocketInfo::GetPreviousCert(nsIX509Cert** _result)
 5220: {
 5220:   NS_ENSURE_ARG_POINTER(_result);
14244:   nsresult rv = EnsureDocShellDependentStuffKnown();
14244:   NS_ENSURE_SUCCESS(rv, rv);
 5220: 
10258:   *_result = mPreviousCert;
10258:   NS_IF_ADDREF(*_result);
10258: 
10258:   return NS_OK;
10258: }
10258: 
10258: nsresult nsNSSSocketInfo::GetCert(nsIX509Cert** _result)
10258: {
10258:   NS_ENSURE_ARG_POINTER(_result);
10258: 
 5220:   *_result = mCert;
 5220:   NS_IF_ADDREF(*_result);
 5220: 
 5220:   return NS_OK;
 5220: }
 5220: 
10258: nsresult nsNSSSocketInfo::SetCert(nsIX509Cert *aCert)
 5220: {
 5220:   mCert = aCert;
 5220: 
 5220:   return NS_OK;
 5220: }
 5220: 
    1: nsresult nsNSSSocketInfo::GetSSLStatus(nsISupports** _result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_result);
    1: 
 8463:   *_result = NS_ISUPPORTS_CAST(nsISSLStatus*, mSSLStatus);
    1:   NS_IF_ADDREF(*_result);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 8463: nsresult nsNSSSocketInfo::SetSSLStatus(nsSSLStatus *aSSLStatus)
    1: {
    1:   mSSLStatus = aSSLStatus;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsNSSSocketInfo::SetHandshakeInProgress(PRBool aIsIn)
    1: {
    1:   mHandshakeInProgress = aIsIn;
    1: 
    1:   if (mHandshakeInProgress && !mHandshakeStartTime)
    1:   {
    1:     mHandshakeStartTime = PR_IntervalNow();
    1:   }
    1: }
    1: 
    1: void nsNSSSocketInfo::SetAllowTLSIntoleranceTimeout(PRBool aAllow)
    1: {
    1:   mAllowTLSIntoleranceTimeout = aAllow;
    1: }
    1: 
    1: #define HANDSHAKE_TIMEOUT_SECONDS 25
    1: 
    1: PRBool nsNSSSocketInfo::HandshakeTimeout()
    1: {
 6597:   if (!mHandshakeInProgress || !mAllowTLSIntoleranceTimeout)
    1:     return PR_FALSE;
    1: 
    1:   return ((PRIntervalTime)(PR_IntervalNow() - mHandshakeStartTime)
    1:           > PR_SecondsToInterval(HANDSHAKE_TIMEOUT_SECONDS));
    1: }
    1: 
    1: void nsSSLIOLayerHelpers::Cleanup()
    1: {
    1:   if (mTLSIntolerantSites) {
    1:     delete mTLSIntolerantSites;
    1:     mTLSIntolerantSites = nsnull;
    1:   }
    1: 
    1:   if (mSharedPollableEvent)
    1:     PR_DestroyPollableEvent(mSharedPollableEvent);
    1: 
25141:   if (mutex)
    1:     PR_DestroyLock(mutex);
    1: }
    1: 
    1: static nsresult
 7252: getErrorMessage(PRInt32 err, 
 7252:                 const nsString &host,
 7252:                 PRInt32 port,
 7252:                 PRBool externalErrorReporting,
    1:                 nsINSSComponent *component,
    1:                 nsString &returnedMessage)
    1: {
    1:   NS_ENSURE_ARG_POINTER(component);
    1: 
    1:   const PRUnichar *params[1];
    1:   nsresult rv;
    1: 
    1:   if (host.Length())
    1:   {
 7252:     nsString hostWithPort;
 7252: 
 7252:     // For now, hide port when it's 443 and we're reporting the error using
 7252:     // external reporting. In the future a better mechanism should be used
 7252:     // to make a decision about showing the port number, possibly by requiring
 7252:     // the context object to implement a specific interface.
 7252:     // The motivation is that Mozilla browser would like to hide the port number
 7252:     // in error pages in the common case.
 7252: 
 7252:     if (externalErrorReporting && port == 443) {
    1:       params[0] = host.get();
 7252:     }
 7252:     else {
 7252:       hostWithPort = host;
 7252:       hostWithPort.AppendLiteral(":");
 7252:       hostWithPort.AppendInt(port);
 7252:       params[0] = hostWithPort.get();
 7252:     }
    1: 
    1:     nsString formattedString;
    1:     rv = component->PIPBundleFormatStringFromName("SSLConnectionErrorPrefix", 
    1:                                                   params, 1, 
    1:                                                   formattedString);
    1:     if (NS_SUCCEEDED(rv))
    1:     {
    1:       returnedMessage.Append(formattedString);
 7252:       returnedMessage.Append(NS_LITERAL_STRING("\n\n"));
    1:     }
    1:   }
    1: 
    1:   nsString explanation;
    1:   rv = nsNSSErrors::getErrorMessageFromCode(err, component, explanation);
    1:   if (NS_SUCCEEDED(rv))
    1:     returnedMessage.Append(explanation);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 7879: static void
 7879: AppendErrorTextUntrusted(PRErrorCode errTrust,
 6597:                          const nsString &host,
 6597:                          nsIX509Cert* ix509,
 6597:                          nsINSSComponent *component,
 6597:                          nsString &returnedMessage)
 6597: {
 7252:   const char *errorID = nsnull;
 7252:   nsCOMPtr<nsIX509Cert3> cert3 = do_QueryInterface(ix509);
 7252:   if (cert3) {
 7252:     PRBool isSelfSigned;
 7252:     if (NS_SUCCEEDED(cert3->GetIsSelfSigned(&isSelfSigned))
 7252:         && isSelfSigned) {
 7252:       errorID = "certErrorTrust_SelfSigned";
 7252:     }
 7252:   }
 7252: 
 7252:   if (!errorID) {
 7252:     switch (errTrust) {
 7252:       case SEC_ERROR_UNKNOWN_ISSUER:
 7252:         errorID = "certErrorTrust_UnknownIssuer";
 7252:         break;
13929:       case SEC_ERROR_INADEQUATE_KEY_USAGE:
13929:         // Should get an individual string in the future
13929:         // For now, use the same as CaInvalid
 7252:       case SEC_ERROR_CA_CERT_INVALID:
 7252:         errorID = "certErrorTrust_CaInvalid";
 7252:         break;
 7252:       case SEC_ERROR_UNTRUSTED_ISSUER:
 7252:         errorID = "certErrorTrust_Issuer";
 7252:         break;
 7252:       case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
 7252:         errorID = "certErrorTrust_ExpiredIssuer";
 7252:         break;
 7252:       case SEC_ERROR_UNTRUSTED_CERT:
 7252:       default:
 7252:         errorID = "certErrorTrust_Untrusted";
 7252:         break;
 7252:     }
 7252:   }
 7252: 
 6597:   nsString formattedString;
 7879:   nsresult rv = component->GetPIPNSSBundleString(errorID, 
 6597:                                                  formattedString);
 6597:   if (NS_SUCCEEDED(rv))
 6597:   {
 6597:     returnedMessage.Append(formattedString);
 6597:     returnedMessage.Append(NS_LITERAL_STRING("\n"));
 6597:   }
 6597: }
 6597: 
 7879: // returns TRUE if SAN was used to produce names
 7879: // return FALSE if nothing was produced
 7879: // names => a single name or a list of names
 7879: // multipleNames => whether multiple names were delivered
 7879: static PRBool
 7879: GetSubjectAltNames(CERTCertificate *nssCert,
 7879:                    nsINSSComponent *component,
 7879:                    nsString &allNames,
14197:                    PRUint32 &nameCount)
 6597: {
 7879:   allNames.Truncate();
10259:   nameCount = 0;
 7252: 
 7252:   PRArenaPool *san_arena = nsnull;
 7252:   SECItem altNameExtension = {siBuffer, NULL, 0 };
 7252:   CERTGeneralName *sanNameList = nsnull;
 7252: 
 7879:   nsresult rv;
 7252:   rv = CERT_FindCertExtension(nssCert, SEC_OID_X509_SUBJECT_ALT_NAME,
 7252:                               &altNameExtension);
 7252:   if (rv != SECSuccess)
 7879:     return PR_FALSE;
 7879: 
 7252:   san_arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
 7252:   if (!san_arena)
 7879:     return PR_FALSE;
 7879: 
 7252:   sanNameList = CERT_DecodeAltNameExtension(san_arena, &altNameExtension);
 7252:   if (!sanNameList)
 7879:     return PR_FALSE;
 7252: 
 7252:   SECITEM_FreeItem(&altNameExtension, PR_FALSE);
 7252: 
 7252:   CERTGeneralName *current = sanNameList;
 7252:   do {
 7252:     nsAutoString name;
 7252:     switch (current->type) {
 7252:       case certDNSName:
 7252:         name.AssignASCII((char*)current->name.other.data, current->name.other.len);
 7252:         if (!allNames.IsEmpty()) {
14197:           allNames.Append(NS_LITERAL_STRING(" , "));
14197:         }
10259:         ++nameCount;
 7252:         allNames.Append(name);
 7252:         break;
 7252: 
 7252:       case certIPAddress:
 7252:         {
 7252:           char buf[INET6_ADDRSTRLEN];
 7252:           PRNetAddr addr;
 7252:           if (current->name.other.len == 4) {
 7252:             addr.inet.family = PR_AF_INET;
 7252:             memcpy(&addr.inet.ip, current->name.other.data, current->name.other.len);
 7252:             PR_NetAddrToString(&addr, buf, sizeof(buf));
 7252:             name.AssignASCII(buf);
 7252:           } else if (current->name.other.len == 16) {
 7252:             addr.ipv6.family = PR_AF_INET6;
 7252:             memcpy(&addr.ipv6.ip, current->name.other.data, current->name.other.len);
 7252:             PR_NetAddrToString(&addr, buf, sizeof(buf));
 7252:             name.AssignASCII(buf);
 7252:           } else {
 7252:             /* invalid IP address */
 7252:           }
 7252:           if (!name.IsEmpty()) {
 7252:             if (!allNames.IsEmpty()) {
14197:               allNames.Append(NS_LITERAL_STRING(" , "));
14197:             }
10259:             ++nameCount;
 7252:             allNames.Append(name);
 7252:           }
 7252:           break;
 7252:         }
 7252: 
 7252:       default: // all other types of names are ignored
 7252:         break;
 7252:     }
 7252:     current = CERT_GetNextGeneralName(current);
 7252:   } while (current != sanNameList); // double linked
 7879: 
 7879:   PORT_FreeArena(san_arena, PR_FALSE);
 7879:   return PR_TRUE;
 7252: }
 7879: 
 7879: static void
 7879: AppendErrorTextMismatch(const nsString &host,
 7879:                         nsIX509Cert* ix509,
 7879:                         nsINSSComponent *component,
20523:                         PRBool wantsHtml,
 7879:                         nsString &returnedMessage)
 7879: {
 7879:   const PRUnichar *params[1];
 7879:   nsresult rv;
 7879: 
 7879:   CERTCertificate *nssCert = NULL;
 7879:   CERTCertificateCleaner nssCertCleaner(nssCert);
 7879: 
 7879:   nsCOMPtr<nsIX509Cert2> cert2 = do_QueryInterface(ix509, &rv);
 7879:   if (cert2)
 7879:     nssCert = cert2->GetCert();
 7879: 
 7879:   if (!nssCert) {
 7879:     // We are unable to extract the valid names, say "not valid for name".
 7879:     params[0] = host.get();
 7879:     nsString formattedString;
 7879:     rv = component->PIPBundleFormatStringFromName("certErrorMismatch", 
 7879:                                                   params, 1, 
 7879:                                                   formattedString);
 7879:     if (NS_SUCCEEDED(rv)) {
 7879:       returnedMessage.Append(formattedString);
 7879:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
 7879:     }
 7879:     return;
 7879:   }
 7879: 
 7879:   nsString allNames;
10259:   PRUint32 nameCount = 0;
 7879:   PRBool useSAN = PR_FALSE;
 7879: 
 7879:   if (nssCert)
10259:     useSAN = GetSubjectAltNames(nssCert, component, allNames, nameCount);
 7252: 
 7252:   if (!useSAN) {
 7252:     char *certName = nsnull;
 7879:     // currently CERT_FindNSStringExtension is not being exported by NSS.
 7879:     // If it gets exported, enable the following line.
 7252:     //   certName = CERT_FindNSStringExtension(nssCert, SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME);
 7879:     // However, it has been discussed to treat the extension as obsolete and ignore it.
 7879:     if (!certName)
 7252:       certName = CERT_GetCommonName(&nssCert->subject);
 7879:     if (certName) {
10259:       ++nameCount;
 7252:       allNames.AssignASCII(certName);
 7252:       PORT_Free(certName);
 7252:     }
 7879:   }
 7252: 
10259:   if (nameCount > 1) {
 7252:     nsString message;
 7252:     rv = component->GetPIPNSSBundleString("certErrorMismatchMultiple", 
 7252:                                           message);
 7252:     if (NS_SUCCEEDED(rv)) {
 7252:       returnedMessage.Append(message);
 7252:       returnedMessage.Append(NS_LITERAL_STRING("\n  "));
 7252:       returnedMessage.Append(allNames);
 7252:       returnedMessage.Append(NS_LITERAL_STRING("  \n"));
 7252:     }
 7252:   }
10259:   else if (nameCount == 1) {
 7879:     const PRUnichar *params[1];
 7252:     params[0] = allNames.get();
 6597: 
20523:     const char *stringID;
20523:     if (wantsHtml)
20523:       stringID = "certErrorMismatchSingle2";
20523:     else
20523:       stringID = "certErrorMismatchSinglePlain";
20523: 
 6597:     nsString formattedString;
20523:     rv = component->PIPBundleFormatStringFromName(stringID, 
 6597:                                                   params, 1, 
 6597:                                                   formattedString);
 7252:     if (NS_SUCCEEDED(rv)) {
 6597:       returnedMessage.Append(formattedString);
 6597:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
 6597:     }
 6597:   }
10259:   else { // nameCount == 0
10259:     nsString message;
10259:     nsresult rv = component->GetPIPNSSBundleString("certErrorMismatchNoNames",
10259:                                                    message);
10259:     if (NS_SUCCEEDED(rv)) {
10259:       returnedMessage.Append(message);
10259:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
10259:     }
10259:   }
 7252: }
 6597: 
 7879: static void
 7879: GetDateBoundary(nsIX509Cert* ix509,
 7879:                 nsString &formattedDate,
 8222:                 PRBool &trueExpired_falseNotYetValid)
 6597: {
 7879:   trueExpired_falseNotYetValid = PR_TRUE;
 7879:   formattedDate.Truncate();
 7879: 
 6597:   PRTime notAfter, notBefore, timeToUse;
 6597:   nsCOMPtr<nsIX509CertValidity> validity;
 7879:   nsresult rv;
 6597: 
 6597:   rv = ix509->GetValidity(getter_AddRefs(validity));
 6597:   if (NS_FAILED(rv))
 7879:     return;
 6597: 
 6597:   rv = validity->GetNotAfter(&notAfter);
 6597:   if (NS_FAILED(rv))
 7879:     return;
 6597: 
 6597:   rv = validity->GetNotBefore(&notBefore);
 6597:   if (NS_FAILED(rv))
 7879:     return;
 7879: 
 7879:   if (LL_CMP(PR_Now(), >, notAfter)) {
 6597:     timeToUse = notAfter;
 6597:   } else {
 6597:     timeToUse = notBefore;
 7879:     trueExpired_falseNotYetValid = PR_FALSE;
 6597:   }
 6597: 
 6597:   nsIDateTimeFormat* aDateTimeFormat;
 6597:   rv = CallCreateInstance(NS_DATETIMEFORMAT_CONTRACTID, &aDateTimeFormat);
 6597:   if (NS_FAILED(rv))
 7879:     return;
 6597: 
 6597:   aDateTimeFormat->FormatPRTime(nsnull, kDateFormatShort, 
 6597:                                 kTimeFormatNoSeconds, timeToUse, 
 6597:                                 formattedDate);
 6597:   NS_IF_RELEASE(aDateTimeFormat);
 7879: }
 7879: 
 7879: static void
 7879: AppendErrorTextTime(nsIX509Cert* ix509,
 7879:                     nsINSSComponent *component,
 7879:                     nsString &returnedMessage)
 7879: {
 7879:   nsAutoString formattedDate;
 7879:   PRBool trueExpired_falseNotYetValid;
 7879:   GetDateBoundary(ix509, formattedDate, trueExpired_falseNotYetValid);
 7879: 
 7879:   const PRUnichar *params[1];
 7879:   params[0] = formattedDate.get(); // might be empty, if helper function had a problem 
 7879: 
 7879:   const char *key = trueExpired_falseNotYetValid ? 
 7879:                     "certErrorExpired" : "certErrorNotYetValid";
 7879:   nsresult rv;
 6597:   nsString formattedString;
 6597:   rv = component->PIPBundleFormatStringFromName(key, params, 
 6597:                                                 1, formattedString);
 6597:   if (NS_SUCCEEDED(rv))
 6597:   {
 6597:     returnedMessage.Append(formattedString);
 6597:     returnedMessage.Append(NS_LITERAL_STRING("\n"));
 6597:   }
 6597: }
 6597: 
 7879: static void
 7879: AppendErrorTextCode(PRErrorCode errorCodeToReport,
 7879:                     nsINSSComponent *component,
 7879:                     nsString &returnedMessage)
 7879: {
 6597:   const char *codeName = nsNSSErrors::getDefaultErrorStringName(errorCodeToReport);
 6597:   if (codeName)
 6597:   {
 6597:     nsCString error_id(codeName);
 6597:     ToLowerCase(error_id);
 6597:     NS_ConvertASCIItoUTF16 idU(error_id);
 6597: 
 7879:     const PRUnichar *params[1];
 7252:     params[0] = idU.get();
 7252: 
 7252:     nsString formattedString;
 7879:     nsresult rv;
 7252:     rv = component->PIPBundleFormatStringFromName("certErrorCodePrefix", 
 7252:                                                   params, 1, 
 7252:                                                   formattedString);
 7252:     if (NS_SUCCEEDED(rv)) {
 7252:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
 7252:       returnedMessage.Append(formattedString);
 7252:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
 7252:     }
 7252:     else {
 6597:       returnedMessage.Append(NS_LITERAL_STRING(" ("));
 6597:       returnedMessage.Append(idU);
 6597:       returnedMessage.Append(NS_LITERAL_STRING(")"));
 6597:     }
 7252:   }
 7879: }
 7879: 
 7879: static nsresult
 7879: getInvalidCertErrorMessage(PRUint32 multipleCollectedErrors, 
 7879:                            PRErrorCode errorCodeToReport, 
 7879:                            PRErrorCode errTrust, 
 7879:                            PRErrorCode errMismatch, 
 7879:                            PRErrorCode errExpired,
 7879:                            const nsString &host,
 7879:                            const nsString &hostWithPort,
 7879:                            PRInt32 port,
 7879:                            nsIX509Cert* ix509,
 7879:                            PRBool externalErrorReporting,
20523:                            PRBool wantsHtml,
 7879:                            nsINSSComponent *component,
 7879:                            nsString &returnedMessage)
 7879: {
 7879:   NS_ENSURE_ARG_POINTER(component);
 7879: 
 7879:   const PRUnichar *params[1];
 7879:   nsresult rv;
 7879: 
 7879:   // For now, hide port when it's 443 and we're reporting the error using
 7879:   // external reporting. In the future a better mechanism should be used
 7879:   // to make a decision about showing the port number, possibly by requiring
 7879:   // the context object to implement a specific interface.
 7879:   // The motivation is that Mozilla browser would like to hide the port number
 7879:   // in error pages in the common case.
 7879:   
 7879:   if (externalErrorReporting && port == 443)
 7879:     params[0] = host.get();
 7879:   else
 7879:     params[0] = hostWithPort.get();
 7879: 
 7879:   nsString formattedString;
 7879:   rv = component->PIPBundleFormatStringFromName("certErrorIntro", 
 7879:                                                 params, 1, 
 7879:                                                 formattedString);
 7879:   if (NS_SUCCEEDED(rv))
 7879:   {
 7879:     returnedMessage.Append(formattedString);
 7879:     returnedMessage.Append(NS_LITERAL_STRING("\n\n"));
 7879:   }
 7879: 
 7879:   if (multipleCollectedErrors & nsICertOverrideService::ERROR_UNTRUSTED)
 7879:   {
 7879:     AppendErrorTextUntrusted(errTrust, host, ix509, 
 7879:                              component, returnedMessage);
 7879:   }
 7879: 
 7879:   if (multipleCollectedErrors & nsICertOverrideService::ERROR_MISMATCH)
 7879:   {
20523:     AppendErrorTextMismatch(host, ix509, component, wantsHtml, returnedMessage);
 7879:   }
 7879: 
 7879:   if (multipleCollectedErrors & nsICertOverrideService::ERROR_TIME)
 7879:   {
 7879:     AppendErrorTextTime(ix509, component, returnedMessage);
 7879:   }
 7879: 
 7879:   AppendErrorTextCode(errorCodeToReport, component, returnedMessage);
 6597: 
 6597:   return NS_OK;
 6597: }
 6597: 
 6597: static nsresult
    1: displayAlert(nsAFlatString &formattedString, nsNSSSocketInfo *infoObject)
    1: {
    1:   // The interface requestor object may not be safe, so proxy the call to get
    1:   // the nsIPrompt.
    1: 
14244:   if (nsSSLThread::exitRequested())
14244:     return NS_ERROR_FAILURE;
14244: 
    1:   nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
    1:   NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                        NS_GET_IID(nsIInterfaceRequestor),
 3233:                        static_cast<nsIInterfaceRequestor*>(infoObject),
    1:                        NS_PROXY_SYNC,
    1:                        getter_AddRefs(proxiedCallbacks));
    1: 
    1:   nsCOMPtr<nsIPrompt> prompt (do_GetInterface(proxiedCallbacks));
    1:   if (!prompt)
    1:     return NS_ERROR_NO_INTERFACE;
    1: 
    1:   // Finally, get a proxy for the nsIPrompt
    1: 
    1:   nsCOMPtr<nsIPrompt> proxyPrompt;
    1:   NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                        NS_GET_IID(nsIPrompt),
    1:                        prompt,
    1:                        NS_PROXY_SYNC,
    1:                        getter_AddRefs(proxyPrompt));
    1: 
    1:   proxyPrompt->Alert(nsnull, formattedString.get());
    1:   return NS_OK;
    1: }
    1: 
    1: static nsresult
    1: nsHandleSSLError(nsNSSSocketInfo *socketInfo, PRInt32 err)
    1: {
    1:   if (socketInfo->GetCanceled()) {
    1:     // If the socket has been flagged as canceled,
    1:     // the code who did was responsible for showing
    1:     // an error message (if desired).
    1:     return NS_OK;
    1:   }
    1: 
14244:   if (nsSSLThread::exitRequested()) {
14244:     return NS_ERROR_FAILURE;
14244:   }
14244: 
    1:   nsresult rv;
    1:   NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
    1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsXPIDLCString hostName;
    1:   socketInfo->GetHostName(getter_Copies(hostName));
    1:   NS_ConvertASCIItoUTF16 hostNameU(hostName);
    1: 
 7252:   PRInt32 port;
 7252:   socketInfo->GetPort(&port);
    1: 
10284:   // Try to get a nsISSLErrorListener implementation from the socket consumer.
14244:   nsCOMPtr<nsIInterfaceRequestor> cb;
14244:   socketInfo->GetNotificationCallbacks(getter_AddRefs(cb));
14244:   if (cb) {
10284:     nsCOMPtr<nsIInterfaceRequestor> callbacks;
14244:     NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
14244:                          NS_GET_IID(nsIInterfaceRequestor),
14244:                          cb,
14244:                          NS_PROXY_SYNC,
14244:                          getter_AddRefs(callbacks));
14244: 
10284:     nsCOMPtr<nsISSLErrorListener> sel = do_GetInterface(callbacks);
10284:     if (sel) {
10284:       nsISSLErrorListener *proxy_sel = nsnull;
10284:       NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
10284:                            NS_GET_IID(nsISSLErrorListener),
10284:                            sel,
10284:                            NS_PROXY_SYNC,
10284:                            (void**)&proxy_sel);
10284:       if (proxy_sel) {
10284:         nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(socketInfo);
10284:         PRBool suppressMessage = PR_FALSE;
10284:         nsCString hostWithPortString = hostName;
10284:         hostWithPortString.AppendLiteral(":");
10284:         hostWithPortString.AppendInt(port);
10284:         rv = proxy_sel->NotifySSLError(csi, err, hostWithPortString, 
10284:                                        &suppressMessage);
10284:         if (NS_SUCCEEDED(rv) && suppressMessage)
10284:           return NS_OK;
10284:       }
10284:     }
10284:   }
10284: 
    1:   PRBool external = PR_FALSE;
    1:   socketInfo->GetExternalErrorReporting(&external);
    1:   
 7252:   nsString formattedString;
 7252:   rv = getErrorMessage(err, hostNameU, port, external, nssComponent, formattedString);
 7252: 
    1:   if (external)
    1:   {
    1:     socketInfo->SetErrorMessage(formattedString.get());
    1:   }
    1:   else
    1:   {
    1:     nsPSMUITracker tracker;
    1:     if (tracker.isUIForbidden()) {
    1:       rv = NS_ERROR_NOT_AVAILABLE;
    1:     }
    1:     else {
    1:       rv = displayAlert(formattedString, socketInfo);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
 6597: static nsresult
 6597: nsHandleInvalidCertError(nsNSSSocketInfo *socketInfo, 
 6597:                          PRUint32 multipleCollectedErrors, 
 6597:                          const nsACString &host, 
 6597:                          const nsACString &hostWithPort,
 7252:                          PRInt32 port,
 7252:                          PRErrorCode errorCodeToReport,
 7252:                          PRErrorCode errTrust, 
 7252:                          PRErrorCode errMismatch, 
 7252:                          PRErrorCode errExpired,
20523:                          PRBool wantsHtml,
 6597:                          nsIX509Cert* ix509)
 6597: {
 6597:   nsresult rv;
 6597:   NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
 6597:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
 6597:   if (NS_FAILED(rv))
 6597:     return rv;
 6597: 
 6597:   NS_ConvertASCIItoUTF16 hostU(host);
 6597:   NS_ConvertASCIItoUTF16 hostWithPortU(hostWithPort);
 6597: 
 6597:   // What mechanism is used to inform the user?
 6597:   // The highest priority has the "external error reporting" feature,
 6597:   // if set, we'll provide the strings to be used by the nsINSSErrorsService
 6597: 
 6597:   PRBool external = PR_FALSE;
 6597:   socketInfo->GetExternalErrorReporting(&external);
 6597:   
 7252:   nsString formattedString;
 7252:   rv = getInvalidCertErrorMessage(multipleCollectedErrors, errorCodeToReport,
10284:                                   errTrust, errMismatch, errExpired,
 7252:                                   hostU, hostWithPortU, port, 
20523:                                   ix509, external, wantsHtml,
20523:                                   nssComponent, formattedString);
 7252: 
 6597:   if (external)
 6597:   {
 6597:     socketInfo->SetErrorMessage(formattedString.get());
 6597:   }
 6597:   else
 6597:   {
 6597:     nsPSMUITracker tracker;
 6597:     if (tracker.isUIForbidden()) {
 6597:       rv = NS_ERROR_NOT_AVAILABLE;
 6597:     }
 6597:     else {
18398:       nsISSLCertErrorDialog *dialogs = nsnull;
18398:       rv = getNSSDialogs((void**)&dialogs, 
18398:         NS_GET_IID(nsISSLCertErrorDialog), 
18398:         NS_SSLCERTERRORDIALOG_CONTRACTID);
18398:   
18398:       if (NS_SUCCEEDED(rv)) {
18398:         nsPSMUITracker tracker;
18398:         if (tracker.isUIForbidden()) {
18398:           rv = NS_ERROR_NOT_AVAILABLE;
18398:         }
18398:         else {
18398:           nsCOMPtr<nsISSLStatus> status;
18398:           socketInfo->GetSSLStatus(getter_AddRefs(status));
18398: 
18398:           nsString empty;
18398: 
18398:           rv = dialogs->ShowCertError(nsnull, status, ix509, 
18398:                                       formattedString, 
18398:                                       empty, host, port);
18398:         }
18398:   
18398:         NS_RELEASE(dialogs);
18398:       }
 6597:     }
 6597:   }
 6597:   return rv;
 6597: }
 6597: 
    1: static PRStatus PR_CALLBACK
    1: nsSSLIOLayerConnect(PRFileDesc* fd, const PRNetAddr* addr,
    1:                     PRIntervalTime timeout)
    1: {
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] connecting SSL socket\n", (void*)fd));
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd || !fd->lower)
    1:     return PR_FAILURE;
    1:   
    1:   PRStatus status = PR_SUCCESS;
    1: 
    1: #if defined(XP_BEOS)
    1:   // Due to BeOS net_server's lack of support for nonblocking sockets,
    1:   // we must execute this entire connect as a blocking operation - bug 70217
    1:  
    1:   PRSocketOptionData sockopt;
    1:   sockopt.option = PR_SockOpt_Nonblocking;
    1:   PR_GetSocketOption(fd, &sockopt);
    1:   PRBool oldBlockVal = sockopt.value.non_blocking;
    1:   sockopt.option = PR_SockOpt_Nonblocking;
    1:   sockopt.value.non_blocking = PR_FALSE;
    1:   PR_SetSocketOption(fd, &sockopt);
    1: #endif
    1:   
    1:   status = fd->lower->methods->connect(fd->lower, addr, 
    1: #if defined(XP_BEOS)  // bug 70217
    1:                                        PR_INTERVAL_NO_TIMEOUT);
    1: #else
    1:                                        timeout);
    1: #endif
    1:   if (status != PR_SUCCESS) {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("[%p] Lower layer connect error: %d\n",
    1:                                       (void*)fd, PR_GetError()));
    1: #if defined(XP_BEOS)  // bug 70217
    1:     goto loser;
    1: #else
    1:     return status;
    1: #endif
    1:   }
    1:   
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] Connect\n", (void*)fd));
    1: 
    1: #if defined(XP_BEOS)  // bug 70217
    1:  loser:
    1:   // We put the Nonblocking bit back to the value it was when 
    1:   // we entered this function.
    1:   NS_ASSERTION(sockopt.option == PR_SockOpt_Nonblocking,
    1:                "sockopt.option was re-set to an unexpected value");
    1:   sockopt.value.non_blocking = oldBlockVal;
    1:   PR_SetSocketOption(fd, &sockopt);
    1: #endif
    1: 
    1:   return status;
    1: }
    1: 
    1: // Call this function to report a site that is possibly TLS intolerant.
    1: // This function will return true, if the given socket is currently using TLS.
    1: PRBool
    1: nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(PRFileDesc* ssl_layer_fd, nsNSSSocketInfo *socketInfo)
    1: {
    1:   PRBool currentlyUsesTLS = PR_FALSE;
    1: 
    1:   SSL_OptionGet(ssl_layer_fd, SSL_ENABLE_TLS, &currentlyUsesTLS);
23777:   if (!currentlyUsesTLS)
23777:     return PR_FALSE;
23777: 
23777:   PRBool enableSSL3 = PR_FALSE;
23777:   SSL_OptionGet(ssl_layer_fd, SSL_ENABLE_SSL3, &enableSSL3);
23777:   PRBool enableSSL2 = PR_FALSE;
23777:   SSL_OptionGet(ssl_layer_fd, SSL_ENABLE_SSL2, &enableSSL2);
23777:   if (enableSSL3 || enableSSL2)
23777:   {
    1:     // Add this site to the list of TLS intolerant sites.
    1:     PRInt32 port;
    1:     nsXPIDLCString host;
    1:     socketInfo->GetPort(&port);
    1:     socketInfo->GetHostName(getter_Copies(host));
    1:     nsCAutoString key;
    1:     key = host + NS_LITERAL_CSTRING(":") + nsPrintfCString("%d", port);
    1: 
    1:     addIntolerantSite(key);
    1:   }
    1:   
    1:   return currentlyUsesTLS;
    1: }
    1: 
    1: static PRStatus PR_CALLBACK
    1: nsSSLIOLayerClose(PRFileDesc *fd)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd)
    1:     return PR_FAILURE;
    1: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] Shutting down socket\n", (void*)fd));
    1:   
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
    1:   return nsSSLThread::requestClose(socketInfo);
    1: }
    1: 
    1: PRStatus nsNSSSocketInfo::CloseSocketAndDestroy()
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1: 
    1:   nsNSSShutDownList::trackSSLSocketClose();
    1: 
    1:   PRFileDesc* popped = PR_PopIOLayer(mFd, PR_TOP_IO_LAYER);
    1: 
    1:   if (GetHandshakeInProgress()) {
    1:     nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(mFd->lower, this);
    1:   }
    1: 
    1:   PRStatus status = mFd->methods->close(mFd);
    1:   if (status != PR_SUCCESS) return status;
    1: 
    1:   popped->identity = PR_INVALID_IO_LAYER;
    1:   NS_RELEASE_THIS();
    1:   popped->dtor(popped);
    1: 
    1:   return PR_SUCCESS;
    1: }
    1: 
    1: #if defined(DEBUG_SSL_VERBOSE) && defined(DUMP_BUFFER)
    1: /* Dumps a (potentially binary) buffer using SSM_DEBUG. 
    1:    (We could have used the version in ssltrace.c, but that's
    1:    specifically tailored to SSLTRACE. Sigh. */
    1: #define DUMPBUF_LINESIZE 24
    1: static void
    1: nsDumpBuffer(unsigned char *buf, PRIntn len)
    1: {
    1:   char hexbuf[DUMPBUF_LINESIZE*3+1];
    1:   char chrbuf[DUMPBUF_LINESIZE+1];
    1:   static const char *hex = "0123456789abcdef";
    1:   PRIntn i = 0, l = 0;
    1:   char ch, *c, *h;
    1:   if (len == 0)
    1:     return;
    1:   hexbuf[DUMPBUF_LINESIZE*3] = '\0';
    1:   chrbuf[DUMPBUF_LINESIZE] = '\0';
    1:   (void) memset(hexbuf, 0x20, DUMPBUF_LINESIZE*3);
    1:   (void) memset(chrbuf, 0x20, DUMPBUF_LINESIZE);
    1:   h = hexbuf;
    1:   c = chrbuf;
    1: 
    1:   while (i < len)
    1:   {
    1:     ch = buf[i];
    1: 
    1:     if (l == DUMPBUF_LINESIZE)
    1:     {
    1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("%s%s\n", hexbuf, chrbuf));
    1:       (void) memset(hexbuf, 0x20, DUMPBUF_LINESIZE*3);
    1:       (void) memset(chrbuf, 0x20, DUMPBUF_LINESIZE);
    1:       h = hexbuf;
    1:       c = chrbuf;
    1:       l = 0;
    1:     }
    1: 
    1:     /* Convert a character to hex. */
    1:     *h++ = hex[(ch >> 4) & 0xf];
    1:     *h++ = hex[ch & 0xf];
    1:     h++;
    1:         
    1:     /* Put the character (if it's printable) into the character buffer. */
    1:     if ((ch >= 0x20) && (ch <= 0x7e))
    1:       *c++ = ch;
    1:     else
    1:       *c++ = '.';
    1:     i++; l++;
    1:   }
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("%s%s\n", hexbuf, chrbuf));
    1: }
    1: 
    1: #define DEBUG_DUMP_BUFFER(buf,len) nsDumpBuffer(buf,len)
    1: #else
    1: #define DEBUG_DUMP_BUFFER(buf,len)
    1: #endif
    1: 
    1: static PRBool
    1: isNonSSLErrorThatWeAllowToRetry(PRInt32 err, PRBool withInitialCleartext)
    1: {
    1:   switch (err)
    1:   {
    1:     case PR_CONNECT_RESET_ERROR:
    1:       if (!withInitialCleartext)
    1:         return PR_TRUE;
    1:       break;
    1:     
    1:     case PR_END_OF_FILE_ERROR:
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: static PRBool
    1: isTLSIntoleranceError(PRInt32 err, PRBool withInitialCleartext)
    1: {
    1:   // This function is supposed to decide, which error codes should
    1:   // be used to conclude server is TLS intolerant.
    1:   // Note this only happens during the initial SSL handshake.
    1:   // 
    1:   // When not using a proxy we'll see a connection reset error.
    1:   // When using a proxy, we'll see an end of file error.
    1:   // In addition check for some error codes where it is reasonable
    1:   // to retry without TLS.
    1: 
    1:   if (isNonSSLErrorThatWeAllowToRetry(err, withInitialCleartext))
    1:     return PR_TRUE;
    1: 
    1:   switch (err)
    1:   {
    1:     case SSL_ERROR_BAD_MAC_ALERT:
    1:     case SSL_ERROR_BAD_MAC_READ:
    1:     case SSL_ERROR_HANDSHAKE_FAILURE_ALERT:
    1:     case SSL_ERROR_HANDSHAKE_UNEXPECTED_ALERT:
    1:     case SSL_ERROR_CLIENT_KEY_EXCHANGE_FAILURE:
    1:     case SSL_ERROR_ILLEGAL_PARAMETER_ALERT:
    1:     case SSL_ERROR_NO_CYPHER_OVERLAP:
    1:     case SSL_ERROR_BAD_SERVER:
    1:     case SSL_ERROR_BAD_BLOCK_PADDING:
    1:     case SSL_ERROR_UNSUPPORTED_VERSION:
    1:     case SSL_ERROR_PROTOCOL_VERSION_ALERT:
    1:     case SSL_ERROR_RX_MALFORMED_FINISHED:
    1:     case SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE:
    1:     case SSL_ERROR_DECODE_ERROR_ALERT:
    1:     case SSL_ERROR_RX_UNKNOWN_ALERT:
    1:       return PR_TRUE;
    1:   }
    1:   
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRInt32
    1: nsSSLThread::checkHandshake(PRInt32 bytesTransfered, 
    1:                             PRBool wasReading,
    1:                             PRFileDesc* ssl_layer_fd, 
    1:                             nsNSSSocketInfo *socketInfo)
    1: {
    1:   // This is where we work around all of those SSL servers that don't 
    1:   // conform to the SSL spec and shutdown a connection when we request
    1:   // SSL v3.1 (aka TLS).  The spec says the client says what version
    1:   // of the protocol we're willing to perform, in our case SSL v3.1
    1:   // In its response, the server says which version it wants to perform.
    1:   // Many servers out there only know how to do v3.0.  Next, we're supposed
    1:   // to send back the version of the protocol we requested (ie v3.1).  At
    1:   // this point many servers's implementations are broken and they shut
    1:   // down the connection when they don't see the version they sent back.
    1:   // This is supposed to prevent a man in the middle from forcing one
    1:   // side to dumb down to a lower level of the protocol.  Unfortunately,
    1:   // there are enough broken servers out there that such a gross work-around
    1:   // is necessary.  :(
    1: 
    1:   // Additional comment added in August 2006:
    1:   // When we begun to use TLS hello extensions, we encountered a new class of
    1:   // broken server, which simply stall for a very long time.
    1:   // We would like to shorten the timeout, but limit this shorter timeout 
    1:   // to the handshake phase.
    1:   // When we arrive here for the first time (for a given socket),
    1:   // we know the connection is established, and the application code
    1:   // tried the first read or write. This triggers the beginning of the
    1:   // SSL handshake phase at the SSL FD level.
    1:   // We'll make a note of the current time,
    1:   // and use this to measure the elapsed time since handshake begin.
    1: 
    1:   // Do NOT assume TLS intolerance on a closed connection after bad cert ui was shown.
    1:   // Simply retry.
    1:   // This depends on the fact that Cert UI will not be shown again,
    1:   // should the user override the bad cert.
    1: 
    1:   PRBool handleHandshakeResultNow;
    1:   socketInfo->GetHandshakePending(&handleHandshakeResultNow);
    1: 
    1:   PRBool wantRetry = PR_FALSE;
    1: 
    1:   if (0 > bytesTransfered) {
    1:     PRInt32 err = PR_GetError();
    1: 
    1:     if (handleHandshakeResultNow) {
    1:       if (PR_WOULD_BLOCK_ERROR == err) {
    1:         socketInfo->SetHandshakeInProgress(PR_TRUE);
    1:         return bytesTransfered;
    1:       }
    1: 
    1:       if (!wantRetry // no decision yet
    1:           && isTLSIntoleranceError(err, socketInfo->GetHasCleartextPhase()))
    1:       {
    1:         wantRetry = nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(ssl_layer_fd, socketInfo);
    1:       }
    1:     }
    1:     
    1:     // This is the common place where we trigger an error message on a SSL socket.
    1:     // This might be reached at any time of the connection.
    1:     if (!wantRetry && (IS_SSL_ERROR(err) || IS_SEC_ERROR(err))) {
    1:       nsHandleSSLError(socketInfo, err);
    1:     }
    1:   }
    1:   else if (wasReading && 0 == bytesTransfered) // zero bytes on reading, socket closed
    1:   {
    1:     if (handleHandshakeResultNow)
    1:     {
    1:       if (!wantRetry // no decision yet
    1:           && !socketInfo->GetHasCleartextPhase()) // mirror PR_CONNECT_RESET_ERROR treament
    1:       {
    1:         wantRetry = 
    1:           nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(ssl_layer_fd, socketInfo);
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (wantRetry) {
    1:     // We want to cause the network layer to retry the connection.
    1:     PR_SetError(PR_CONNECT_RESET_ERROR, 0);
    1:     if (wasReading)
    1:       bytesTransfered = -1;
    1:   }
    1: 
    1:   // TLS intolerant servers only cause the first transfer to fail, so let's 
    1:   // set the HandshakePending attribute to false so that we don't try the logic
    1:   // above again in a subsequent transfer.
    1:   if (handleHandshakeResultNow) {
    1:     socketInfo->SetHandshakePending(PR_FALSE);
    1:     socketInfo->SetHandshakeInProgress(PR_FALSE);
    1:   }
    1:   
    1:   return bytesTransfered;
    1: }
    1: 
    1: static PRInt16 PR_CALLBACK
    1: nsSSLIOLayerPoll(PRFileDesc *fd, PRInt16 in_flags, PRInt16 *out_flags)
    1: {
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] polling SSL socket\n", (void*)fd));
    1:   nsNSSShutDownPreventionLock locker;
    1: 
    1:   if (!out_flags)
    1:   {
    1:     NS_WARNING("nsSSLIOLayerPoll called with null out_flags");
    1:     return 0;
    1:   }
    1: 
    1:   *out_flags = 0;
    1: 
    1:   if (!fd)
    1:   {
    1:     NS_WARNING("nsSSLIOLayerPoll called with null fd");
    1:     return 0;
    1:   }
    1: 
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
    1:   return nsSSLThread::requestPoll(socketInfo, in_flags, out_flags);
    1: }
    1: 
    1: PRDescIdentity nsSSLIOLayerHelpers::nsSSLIOLayerIdentity;
    1: PRIOMethods nsSSLIOLayerHelpers::nsSSLIOLayerMethods;
    1: PRLock *nsSSLIOLayerHelpers::mutex = nsnull;
    1: nsCStringHashSet *nsSSLIOLayerHelpers::mTLSIntolerantSites = nsnull;
    1: PRFileDesc *nsSSLIOLayerHelpers::mSharedPollableEvent = nsnull;
    1: nsNSSSocketInfo *nsSSLIOLayerHelpers::mSocketOwningPollableEvent = nsnull;
    1: PRBool nsSSLIOLayerHelpers::mPollableEventCurrentlySet = PR_FALSE;
    1: 
    1: static PRIntn _PSM_InvalidInt(void)
    1: {
    1:     PR_ASSERT(!"I/O method is invalid");
    1:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
    1:     return -1;
    1: }
    1: 
    1: static PRInt64 _PSM_InvalidInt64(void)
    1: {
    1:     PR_ASSERT(!"I/O method is invalid");
    1:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
    1:     return -1;
    1: }
    1: 
    1: static PRStatus _PSM_InvalidStatus(void)
    1: {
    1:     PR_ASSERT(!"I/O method is invalid");
    1:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
    1:     return PR_FAILURE;
    1: }
    1: 
    1: static PRFileDesc *_PSM_InvalidDesc(void)
    1: {
    1:     PR_ASSERT(!"I/O method is invalid");
    1:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
    1:     return NULL;
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMGetsockname(PRFileDesc *fd, PRNetAddr *addr)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd || !fd->lower) {
    1:     return PR_FAILURE;
    1:   }
    1: 
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
    1:   return nsSSLThread::requestGetsockname(socketInfo, addr);
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMGetpeername(PRFileDesc *fd, PRNetAddr *addr)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd || !fd->lower) {
    1:     return PR_FAILURE;
    1:   }
    1: 
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
    1:   return nsSSLThread::requestGetpeername(socketInfo, addr);
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMGetsocketoption(PRFileDesc *fd, 
    1:                                         PRSocketOptionData *data)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd || !fd->lower) {
    1:     return PR_FAILURE;
    1:   }
    1: 
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
    1:   return nsSSLThread::requestGetsocketoption(socketInfo, data);
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMSetsocketoption(PRFileDesc *fd, 
    1:                                         const PRSocketOptionData *data)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd || !fd->lower) {
    1:     return PR_FAILURE;
    1:   }
    1: 
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
    1:   return nsSSLThread::requestSetsocketoption(socketInfo, data);
    1: }
    1: 
    1: static PRInt32 PR_CALLBACK PSMRecv(PRFileDesc *fd, void *buf, PRInt32 amount,
    1:     PRIntn flags, PRIntervalTime timeout)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd || !fd->lower) {
    1:     PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);
    1:     return -1;
    1:   }
    1: 
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
    1:   if (flags == PR_MSG_PEEK) {
    1:     return nsSSLThread::requestRecvMsgPeek(socketInfo, buf, amount, flags, timeout);
    1:   }
    1: 
    1:   if (flags != 0) {
    1:     PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
    1:     return -1;
    1:   }
    1: 
    1:   return nsSSLThread::requestRead(socketInfo, buf, amount, timeout);
    1: }
    1: 
    1: static PRInt32 PR_CALLBACK PSMSend(PRFileDesc *fd, const void *buf, PRInt32 amount,
    1:     PRIntn flags, PRIntervalTime timeout)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd || !fd->lower) {
    1:     PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);
    1:     return -1;
    1:   }
    1: 
    1:   if (flags != 0) {
    1:     PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
    1:     return -1;
    1:   }
    1: 
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
    1:   return nsSSLThread::requestWrite(socketInfo, buf, amount, timeout);
    1: }
    1: 
    1: static PRInt32 PR_CALLBACK
    1: nsSSLIOLayerRead(PRFileDesc* fd, void* buf, PRInt32 amount)
    1: {
    1:   return PSMRecv(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
    1: }
    1: 
    1: static PRInt32 PR_CALLBACK
    1: nsSSLIOLayerWrite(PRFileDesc* fd, const void* buf, PRInt32 amount)
    1: {
    1:   return PSMSend(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
    1: }
    1: 
    1: static PRStatus PR_CALLBACK PSMConnectcontinue(PRFileDesc *fd, PRInt16 out_flags)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (!fd || !fd->lower) {
    1:     return PR_FAILURE;
    1:   }
    1: 
    1:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
    1:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
    1: 
    1:   return nsSSLThread::requestConnectcontinue(socketInfo, out_flags);
    1: }
    1: 
    1: nsresult nsSSLIOLayerHelpers::Init()
    1: {
    1:   nsSSLIOLayerIdentity = PR_GetUniqueIdentity("NSS layer");
    1:   nsSSLIOLayerMethods  = *PR_GetDefaultIOMethods();
    1: 
    1:   nsSSLIOLayerMethods.available = (PRAvailableFN)_PSM_InvalidInt;
    1:   nsSSLIOLayerMethods.available64 = (PRAvailable64FN)_PSM_InvalidInt64;
    1:   nsSSLIOLayerMethods.fsync = (PRFsyncFN)_PSM_InvalidStatus;
    1:   nsSSLIOLayerMethods.seek = (PRSeekFN)_PSM_InvalidInt;
    1:   nsSSLIOLayerMethods.seek64 = (PRSeek64FN)_PSM_InvalidInt64;
    1:   nsSSLIOLayerMethods.fileInfo = (PRFileInfoFN)_PSM_InvalidStatus;
    1:   nsSSLIOLayerMethods.fileInfo64 = (PRFileInfo64FN)_PSM_InvalidStatus;
    1:   nsSSLIOLayerMethods.writev = (PRWritevFN)_PSM_InvalidInt;
    1:   nsSSLIOLayerMethods.accept = (PRAcceptFN)_PSM_InvalidDesc;
    1:   nsSSLIOLayerMethods.bind = (PRBindFN)_PSM_InvalidStatus;
    1:   nsSSLIOLayerMethods.listen = (PRListenFN)_PSM_InvalidStatus;
    1:   nsSSLIOLayerMethods.shutdown = (PRShutdownFN)_PSM_InvalidStatus;
    1:   nsSSLIOLayerMethods.recvfrom = (PRRecvfromFN)_PSM_InvalidInt;
    1:   nsSSLIOLayerMethods.sendto = (PRSendtoFN)_PSM_InvalidInt;
    1:   nsSSLIOLayerMethods.acceptread = (PRAcceptreadFN)_PSM_InvalidInt;
    1:   nsSSLIOLayerMethods.transmitfile = (PRTransmitfileFN)_PSM_InvalidInt;
    1:   nsSSLIOLayerMethods.sendfile = (PRSendfileFN)_PSM_InvalidInt;
    1: 
    1:   nsSSLIOLayerMethods.getsockname = PSMGetsockname;
    1:   nsSSLIOLayerMethods.getpeername = PSMGetpeername;
    1:   nsSSLIOLayerMethods.getsocketoption = PSMGetsocketoption;
    1:   nsSSLIOLayerMethods.setsocketoption = PSMSetsocketoption;
    1:   nsSSLIOLayerMethods.recv = PSMRecv;
    1:   nsSSLIOLayerMethods.send = PSMSend;
    1:   nsSSLIOLayerMethods.connectcontinue = PSMConnectcontinue;
    1: 
    1:   nsSSLIOLayerMethods.connect = nsSSLIOLayerConnect;
    1:   nsSSLIOLayerMethods.close = nsSSLIOLayerClose;
    1:   nsSSLIOLayerMethods.write = nsSSLIOLayerWrite;
    1:   nsSSLIOLayerMethods.read = nsSSLIOLayerRead;
    1:   nsSSLIOLayerMethods.poll = nsSSLIOLayerPoll;
    1: 
    1:   mutex = PR_NewLock();
    1:   if (!mutex)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   mSharedPollableEvent = PR_NewPollableEvent();
    1: 
    1:   // if we can not get a pollable event, we'll have to do busy waiting
    1: 
    1:   mTLSIntolerantSites = new nsCStringHashSet();
    1:   if (!mTLSIntolerantSites)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   mTLSIntolerantSites->Init(1);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsSSLIOLayerHelpers::addIntolerantSite(const nsCString &str)
    1: {
    1:   nsAutoLock lock(mutex);
    1:   nsSSLIOLayerHelpers::mTLSIntolerantSites->Put(str);
    1: }
    1: 
    1: PRBool nsSSLIOLayerHelpers::isKnownAsIntolerantSite(const nsCString &str)
    1: {
    1:   nsAutoLock lock(mutex);
    1:   return mTLSIntolerantSites->Contains(str);
    1: }
    1: 
    1: nsresult
    1: nsSSLIOLayerNewSocket(PRInt32 family,
    1:                       const char *host,
    1:                       PRInt32 port,
    1:                       const char *proxyHost,
    1:                       PRInt32 proxyPort,
    1:                       PRFileDesc **fd,
    1:                       nsISupports** info,
25076:                       PRBool forSTARTTLS,
25076:                       PRBool anonymousLoad)
    1: {
    1: 
    1:   PRFileDesc* sock = PR_OpenTCPSocket(family);
    1:   if (!sock) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsresult rv = nsSSLIOLayerAddToSocket(family, host, port, proxyHost, proxyPort,
25076:                                         sock, info, forSTARTTLS, anonymousLoad);
    1:   if (NS_FAILED(rv)) {
    1:     PR_Close(sock);
    1:     return rv;
    1:   }
    1: 
    1:   *fd = sock;
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Function: SECStatus nsConvertCANamesToStrings()
    1:  * Purpose: creates CA names strings from (CERTDistNames* caNames)
    1:  *
    1:  * Arguments and return values
    1:  * - arena: arena to allocate strings on
    1:  * - caNameStrings: filled with CA names strings on return
    1:  * - caNames: CERTDistNames to extract strings from
    1:  * - return: SECSuccess if successful; error code otherwise
    1:  *
    1:  * Note: copied in its entirety from Nova code
    1:  */
    1: SECStatus nsConvertCANamesToStrings(PRArenaPool* arena, char** caNameStrings,
    1:                                       CERTDistNames* caNames)
    1: {
    1:     SECItem* dername;
    1:     SECStatus rv;
    1:     int headerlen;
 6838:     PRUint32 contentlen;
    1:     SECItem newitem;
    1:     int n;
    1:     char* namestring;
    1: 
    1:     for (n = 0; n < caNames->nnames; n++) {
    1:         newitem.data = NULL;
    1:         dername = &caNames->names[n];
    1: 
    1:         rv = DER_Lengths(dername, &headerlen, &contentlen);
    1: 
    1:         if (rv != SECSuccess) {
    1:             goto loser;
    1:         }
    1: 
    1:         if (headerlen + contentlen != dername->len) {
    1:             /* This must be from an enterprise 2.x server, which sent
    1:              * incorrectly formatted der without the outer wrapper of
    1:              * type and length.  Fix it up by adding the top level
    1:              * header.
    1:              */
    1:             if (dername->len <= 127) {
    1:                 newitem.data = (unsigned char *) PR_Malloc(dername->len + 2);
    1:                 if (newitem.data == NULL) {
    1:                     goto loser;
    1:                 }
    1:                 newitem.data[0] = (unsigned char)0x30;
    1:                 newitem.data[1] = (unsigned char)dername->len;
    1:                 (void)memcpy(&newitem.data[2], dername->data, dername->len);
    1:             }
    1:             else if (dername->len <= 255) {
    1:                 newitem.data = (unsigned char *) PR_Malloc(dername->len + 3);
    1:                 if (newitem.data == NULL) {
    1:                     goto loser;
    1:                 }
    1:                 newitem.data[0] = (unsigned char)0x30;
    1:                 newitem.data[1] = (unsigned char)0x81;
    1:                 newitem.data[2] = (unsigned char)dername->len;
    1:                 (void)memcpy(&newitem.data[3], dername->data, dername->len);
    1:             }
    1:             else {
    1:                 /* greater than 256, better be less than 64k */
    1:                 newitem.data = (unsigned char *) PR_Malloc(dername->len + 4);
    1:                 if (newitem.data == NULL) {
    1:                     goto loser;
    1:                 }
    1:                 newitem.data[0] = (unsigned char)0x30;
    1:                 newitem.data[1] = (unsigned char)0x82;
    1:                 newitem.data[2] = (unsigned char)((dername->len >> 8) & 0xff);
    1:                 newitem.data[3] = (unsigned char)(dername->len & 0xff);
    1:                 memcpy(&newitem.data[4], dername->data, dername->len);
    1:             }
    1:             dername = &newitem;
    1:         }
    1: 
    1:         namestring = CERT_DerNameToAscii(dername);
    1:         if (namestring == NULL) {
    1:             /* XXX - keep going until we fail to convert the name */
    1:             caNameStrings[n] = "";
    1:         }
    1:         else {
    1:             caNameStrings[n] = PORT_ArenaStrdup(arena, namestring);
    1:             PR_Free(namestring);
    1:             if (caNameStrings[n] == NULL) {
    1:                 goto loser;
    1:             }
    1:         }
    1: 
    1:         if (newitem.data != NULL) {
    1:             PR_Free(newitem.data);
    1:         }
    1:     }
    1: 
    1:     return SECSuccess;
    1: loser:
    1:     if (newitem.data != NULL) {
    1:         PR_Free(newitem.data);
    1:     }
    1:     return SECFailure;
    1: }
    1: 
    1: /*
    1:  * structs and ASN1 templates for the limited scope-of-use extension
    1:  *
    1:  * CertificateScopeEntry ::= SEQUENCE {
    1:  *     name GeneralName, -- pattern, as for NameConstraints
    1:  *     portNumber INTEGER OPTIONAL }
    1:  *
    1:  * CertificateScopeOfUse ::= SEQUENCE OF CertificateScopeEntry
    1:  */
    1: /*
    1:  * CERTCertificateScopeEntry: struct for scope entry that can be consumed by
    1:  *                            the code
    1:  * certCertificateScopeOfUse: struct that represents the decoded extension data
    1:  */
    1: typedef struct {
    1:     SECItem derConstraint;
    1:     SECItem derPort;
    1:     CERTGeneralName* constraint; /* decoded constraint */
    1:     PRIntn port; /* decoded port number */
    1: } CERTCertificateScopeEntry;
    1: 
    1: typedef struct {
    1:     CERTCertificateScopeEntry** entries;
    1: } certCertificateScopeOfUse;
    1: 
    1: /* corresponding ASN1 templates */
    1: static const SEC_ASN1Template cert_CertificateScopeEntryTemplate[] = {
    1:     { SEC_ASN1_SEQUENCE, 
    1:       0, NULL, sizeof(CERTCertificateScopeEntry) },
    1:     { SEC_ASN1_ANY,
    1:       offsetof(CERTCertificateScopeEntry, derConstraint) },
    1:     { SEC_ASN1_OPTIONAL | SEC_ASN1_INTEGER,
    1:       offsetof(CERTCertificateScopeEntry, derPort) },
    1:     { 0 }
    1: };
    1: 
    1: static const SEC_ASN1Template cert_CertificateScopeOfUseTemplate[] = {
    1:     { SEC_ASN1_SEQUENCE_OF, 0, cert_CertificateScopeEntryTemplate }
    1: };
    1: 
    1: #if 0
    1: /* 
    1:  * decodes the extension data and create CERTCertificateScopeEntry that can
    1:  * be consumed by the code
    1:  */
    1: static
    1: SECStatus cert_DecodeScopeOfUseEntries(PRArenaPool* arena, SECItem* extData,
    1:                                        CERTCertificateScopeEntry*** entries,
    1:                                        int* numEntries)
    1: {
    1:     certCertificateScopeOfUse* scope = NULL;
    1:     SECStatus rv = SECSuccess;
    1:     int i;
    1: 
    1:     *entries = NULL; /* in case of failure */
    1:     *numEntries = 0; /* ditto */
    1: 
    1:     scope = (certCertificateScopeOfUse*)
    1:         PORT_ArenaZAlloc(arena, sizeof(certCertificateScopeOfUse));
    1:     if (scope == NULL) {
    1:         goto loser;
    1:     }
    1: 
    1:     rv = SEC_ASN1DecodeItem(arena, (void*)scope, 
    1:                             cert_CertificateScopeOfUseTemplate, extData);
    1:     if (rv != SECSuccess) {
    1:         goto loser;
    1:     }
    1: 
    1:     *entries = scope->entries;
    1:     PR_ASSERT(*entries != NULL);
    1: 
    1:     /* first, let's count 'em. */
    1:     for (i = 0; (*entries)[i] != NULL; i++) ;
    1:     *numEntries = i;
    1: 
    1:     /* convert certCertificateScopeEntry sequence into what we can readily
    1:      * use
    1:      */
    1:     for (i = 0; i < *numEntries; i++) {
    1:         (*entries)[i]->constraint = 
    1:             CERT_DecodeGeneralName(arena, &((*entries)[i]->derConstraint), 
    1:                                    NULL);
    1:         if ((*entries)[i]->derPort.data != NULL) {
    1:             (*entries)[i]->port = 
    1:                 (int)DER_GetInteger(&((*entries)[i]->derPort));
    1:         }
    1:         else {
    1:             (*entries)[i]->port = 0;
    1:         }
    1:     }
    1: 
    1:     goto done;
    1: loser:
    1:     if (rv == SECSuccess) {
    1:         rv = SECFailure;
    1:     }
    1: done:
    1:     return rv;
    1: }
    1: 
    1: static SECStatus cert_DecodeCertIPAddress(SECItem* genname, 
    1:                                           PRUint32* constraint, PRUint32* mask)
    1: {
    1:     /* in case of failure */
    1:     *constraint = 0;
    1:     *mask = 0;
    1: 
    1:     PR_ASSERT(genname->data != NULL);
    1:     if (genname->data == NULL) {
    1:         return SECFailure;
    1:     }
    1:     if (genname->len != 8) {
    1:         /* the length must be 4 byte IP address with 4 byte subnet mask */
    1:         return SECFailure;
    1:     }
    1: 
    1:     /* get them in the right order */
    1:     *constraint = PR_ntohl((PRUint32)(*genname->data));
    1:     *mask = PR_ntohl((PRUint32)(*(genname->data + 4)));
    1: 
    1:     return SECSuccess;
    1: }
    1: 
    1: static char* _str_to_lower(char* string)
    1: {
    1: #ifdef XP_WIN
    1:     return _strlwr(string);
    1: #else
    1:     int i;
    1:     for (i = 0; string[i] != '\0'; i++) {
    1:         string[i] = tolower(string[i]);
    1:     }
    1:     return string;
    1: #endif
    1: }
    1: 
    1: /*
    1:  * Sees if the client certificate has a restriction in presenting the cert
    1:  * to the host: returns PR_TRUE if there is no restriction or if the hostname
    1:  * (and the port) satisfies the restriction, or PR_FALSE if the hostname (and
    1:  * the port) does not satisfy the restriction
    1:  */
    1: static PRBool CERT_MatchesScopeOfUse(CERTCertificate* cert, char* hostname,
    1:                                      char* hostIP, PRIntn port)
    1: {
    1:     PRBool rv = PR_TRUE; /* whether the cert can be presented */
    1:     SECStatus srv;
    1:     SECItem extData;
    1:     PRArenaPool* arena = NULL;
    1:     CERTCertificateScopeEntry** entries = NULL;
    1:     /* arrays of decoded scope entries */
    1:     int numEntries = 0;
    1:     int i;
    1:     char* hostLower = NULL;
    1:     PRUint32 hostIPAddr = 0;
    1: 
    1:     PR_ASSERT((cert != NULL) && (hostname != NULL) && (hostIP != NULL));
    1: 
    1:     /* find cert extension */
    1:     srv = CERT_FindCertExtension(cert, SEC_OID_NS_CERT_EXT_SCOPE_OF_USE,
    1:                                  &extData);
    1:     if (srv != SECSuccess) {
    1:         /* most of the time, this means the extension was not found: also,
    1:          * since this is not a critical extension (as of now) we may simply
    1:          * return PR_TRUE
    1:          */
    1:         goto done;
    1:     }
    1: 
    1:     arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    1:     if (arena == NULL) {
    1:         goto done;
    1:     }
    1: 
    1:     /* decode the scope of use entries into pairs of GeneralNames and
    1:      * an optional port numbers
    1:      */
    1:     srv = cert_DecodeScopeOfUseEntries(arena, &extData, &entries, &numEntries);
    1:     if (srv != SECSuccess) {
    1:         /* XXX What should we do when we failed to decode the extension?  This
    1:          *     may mean either the extension was malformed or some (unlikely)
    1:          *     fatal error on our part: my argument is that if the extension 
    1:          *     was malformed the extension "disqualifies" as a valid 
    1:          *     constraint and we may present the cert
    1:          */
    1:         goto done;
    1:     }
    1: 
    1:     /* loop over these structures */
    1:     for (i = 0; i < numEntries; i++) {
    1:         /* determine whether the GeneralName is a DNS pattern, an IP address 
    1:          * constraint, or else
    1:          */
    1:         CERTGeneralName* genname = entries[i]->constraint;
    1: 
    1:         /* if constraint is NULL, don't bother looking */
    1:         if (genname == NULL) {
    1:             /* this is not a failure: just continue */
    1:             continue;
    1:         }
    1: 
    1:         switch (genname->type) {
    1:         case certDNSName: {
    1:             /* we have a DNS name constraint; we should use only the host name
    1:              * information
    1:              */
    1:             char* pattern = NULL;
    1:             char* substring = NULL;
    1: 
    1:             /* null-terminate the string */
    1:             genname->name.other.data[genname->name.other.len] = '\0';
    1:             pattern = _str_to_lower((char*)genname->name.other.data);
    1: 
    1:             if (hostLower == NULL) {
    1:                 /* so that it's done only if necessary and only once */
    1:                 hostLower = _str_to_lower(PL_strdup(hostname));
    1:             }
    1: 
    1:             /* the hostname satisfies the constraint */
    1:             if (((substring = strstr(hostLower, pattern)) != NULL) &&
    1:                 /* the hostname contains the pattern */
    1:                 (strlen(substring) == strlen(pattern)) &&
    1:                 /* the hostname ends with the pattern */
    1:                 ((substring == hostLower) || (*(substring-1) == '.'))) {
    1:                 /* the hostname either is identical to the pattern or
    1:                  * belongs to a subdomain
    1:                  */
    1:                 rv = PR_TRUE;
    1:             }
    1:             else {
    1:                 rv = PR_FALSE;
    1:             }
    1:             /* clean up strings if necessary */
    1:             break;
    1:         }
    1:         case certIPAddress: {
    1:             PRUint32 constraint;
    1:             PRUint32 mask;
    1:             PRNetAddr addr;
    1:             
    1:             if (hostIPAddr == 0) {
    1:                 /* so that it's done only if necessary and only once */
    1:                 PR_StringToNetAddr(hostIP, &addr);
    1:                 hostIPAddr = addr.inet.ip;
    1:             }
    1: 
    1:             if (cert_DecodeCertIPAddress(&(genname->name.other), &constraint, 
    1:                                          &mask) != SECSuccess) {
    1:                 continue;
    1:             }
    1:             if ((hostIPAddr & mask) == (constraint & mask)) {
    1:                 rv = PR_TRUE;
    1:             }
    1:             else {
    1:                 rv = PR_FALSE;
    1:             }
    1:             break;
    1:         }
    1:         default:
    1:             /* ill-formed entry: abort */
    1:             continue; /* go to the next entry */
    1:         }
    1: 
    1:         if (!rv) {
    1:             /* we do not need to check the port: go to the next entry */
    1:             continue;
    1:         }
    1: 
    1:         /* finally, check the optional port number */
    1:         if ((entries[i]->port != 0) && (port != entries[i]->port)) {
    1:             /* port number does not match */
    1:             rv = PR_FALSE;
    1:             continue;
    1:         }
    1: 
    1:         /* we have a match */
    1:         PR_ASSERT(rv);
    1:         break;
    1:     }
    1: done:
    1:     /* clean up entries */
    1:     if (arena != NULL) {
    1:         PORT_FreeArena(arena, PR_FALSE);
    1:     }
    1:     if (hostLower != NULL) {
    1:         PR_Free(hostLower);
    1:     }
    1:     return rv;
    1: }
    1: #endif
    1: 
    1: /*
    1:  * Function: SSMStatus SSM_SetUserCertChoice()
    1: 
    1:  * Purpose: sets certChoice by reading the preference
    1:  *
    1:  * Arguments and return values
    1:  * - conn: SSMSSLDataConnection
    1:  * - returns: SSM_SUCCESS if successful; SSM_FAILURE otherwise
    1:  *
    1:  * Note: If done properly, this function will read the identifier strings
    1:  *		 for ASK and AUTO modes, read the selected strings from the
    1:  *		 preference, compare the strings, and determine in which mode it is
    1:  *		 in.
    1:  *       We currently use ASK mode for UI apps and AUTO mode for UI-less
    1:  *       apps without really asking for preferences.
    1:  */
    1: nsresult nsGetUserCertChoice(SSM_UserCertChoice* certChoice)
    1: {
    1: 	char *mode=NULL;
    1: 	nsresult ret;
    1: 
    1: 	NS_ENSURE_ARG_POINTER(certChoice);
    1: 
    1: 	nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1: 
    1: 	ret = pref->GetCharPref("security.default_personal_cert", &mode);
    1: 	if (NS_FAILED(ret)) {
    1: 		goto loser;
    1: 	}
    1: 
    1:     if (PL_strcmp(mode, "Select Automatically") == 0) {
    1: 		*certChoice = AUTO;
    1: 	}
    1:     else if (PL_strcmp(mode, "Ask Every Time") == 0) {
    1:         *certChoice = ASK;
    1:     }
    1:     else {
    1:       // Most likely we see a nickname from a migrated cert.
    1:       // We do not currently support that, ask the user which cert to use.
    1: 		  *certChoice = ASK;
    1: 	}
    1: 
    1: loser:
    1: 	if (mode) {
    1: 		nsMemory::Free(mode);
    1: 	}
    1: 	return ret;
    1: }
    1: 
    1: static PRBool hasExplicitKeyUsageNonRepudiation(CERTCertificate *cert)
    1: {
    1:   /* There is no extension, v1 or v2 certificate */
    1:   if (!cert->extensions)
    1:     return PR_FALSE;
    1: 
    1:   SECStatus srv;
    1:   SECItem keyUsageItem;
    1:   keyUsageItem.data = NULL;
    1: 
    1:   srv = CERT_FindKeyUsageExtension(cert, &keyUsageItem);
    1:   if (srv == SECFailure)
    1:     return PR_FALSE;
    1: 
    1:   unsigned char keyUsage = keyUsageItem.data[0];
    1:   PORT_Free (keyUsageItem.data);
    1: 
19743:   return !!(keyUsage & KU_NON_REPUDIATION);
    1: }
    1: 
    1: /*
    1:  * Function: SECStatus SSM_SSLGetClientAuthData()
    1:  * Purpose: this callback function is used to pull client certificate
    1:  *			information upon server request
    1:  *
    1:  * Arguments and return values
    1:  * - arg: SSL data connection
    1:  * - socket: SSL socket we're dealing with
    1:  * - caNames: list of CA names
    1:  * - pRetCert: returns a pointer to a pointer to a valid certificate if
    1:  *			   successful; otherwise NULL
    1:  * - pRetKey: returns a pointer to a pointer to the corresponding key if
    1:  *			  successful; otherwise NULL
    1:  * - returns: SECSuccess if successful; error code otherwise
    1:  */
    1: SECStatus nsNSS_SSLGetClientAuthData(void* arg, PRFileDesc* socket,
    1: 								   CERTDistNames* caNames,
    1: 								   CERTCertificate** pRetCert,
    1: 								   SECKEYPrivateKey** pRetKey)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   void* wincx = NULL;
    1:   SECStatus ret = SECFailure;
20054:   nsresult rv;
    1:   nsNSSSocketInfo* info = NULL;
    1:   PRArenaPool* arena = NULL;
    1:   char** caNameStrings;
    1:   CERTCertificate* cert = NULL;
20054:   CERTCertificate* serverCert = NULL;
    1:   SECKEYPrivateKey* privKey = NULL;
    1:   CERTCertList* certList = NULL;
    1:   CERTCertListNode* node;
    1:   CERTCertNicknames* nicknames = NULL;
    1:   char* extracted = NULL;
    1:   PRIntn keyError = 0; /* used for private key retrieval error */
    1:   SSM_UserCertChoice certChoice;
    1:   PRInt32 NumberOfCerts = 0;
    1: 	
    1:   /* do some argument checking */
    1:   if (socket == NULL || caNames == NULL || pRetCert == NULL ||
    1:       pRetKey == NULL) {
    1:     PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
    1:     return SECFailure;
    1:   }
    1: 
    1:   /* get PKCS11 pin argument */
    1:   wincx = SSL_RevealPinArg(socket);
    1:   if (wincx == NULL) {
    1:     return SECFailure;
    1:   }
    1: 
    1:   /* get the socket info */
    1:   info = (nsNSSSocketInfo*)socket->higher->secret;
    1: 
    1:   /* create caNameStrings */
    1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    1:   if (arena == NULL) {
    1:     goto loser;
    1:   }
    1: 
    1:   caNameStrings = (char**)PORT_ArenaAlloc(arena, 
    1:                                           sizeof(char*)*(caNames->nnames));
    1:   if (caNameStrings == NULL) {
    1:     goto loser;
    1:   }
    1: 
    1: 
    1:   ret = nsConvertCANamesToStrings(arena, caNameStrings, caNames);
    1:   if (ret != SECSuccess) {
    1:     goto loser;
    1:   }
    1: 
    1:   /* get the preference */
    1:   if (NS_FAILED(nsGetUserCertChoice(&certChoice))) {
    1:     goto loser;
    1:   }
    1: 
    1:   /* find valid user cert and key pair */	
    1:   if (certChoice == AUTO) {
    1:     /* automatically find the right cert */
    1: 
    1:     /* find all user certs that are valid and for SSL */
    1:     certList = CERT_FindUserCertsByUsage(CERT_GetDefaultCertDB(), 
    1:                                          certUsageSSLClient, PR_FALSE,
    1:                                          PR_TRUE, wincx);
    1:     if (certList == NULL) {
    1:       goto noCert;
    1:     }
    1: 
    1:     /* filter the list to those issued by CAs supported by the server */
    1:     ret = CERT_FilterCertListByCANames(certList, caNames->nnames,
    1:                                        caNameStrings, certUsageSSLClient);
    1:     if (ret != SECSuccess) {
    1:       goto noCert;
    1:     }
    1: 
    1:     /* make sure the list is not empty */
    1:     node = CERT_LIST_HEAD(certList);
    1:     if (CERT_LIST_END(node, certList)) {
    1:       goto noCert;
    1:     }
    1: 
    1:     CERTCertificate* low_prio_nonrep_cert = NULL;
    1:     CERTCertificateCleaner low_prio_cleaner(low_prio_nonrep_cert);
    1: 
    1:     /* loop through the list until we find a cert with a key */
    1:     while (!CERT_LIST_END(node, certList)) {
    1:       /* if the certificate has restriction and we do not satisfy it
    1:        * we do not use it
    1:        */
    1: #if 0		/* XXX This must be re-enabled */
    1:       if (!CERT_MatchesScopeOfUse(node->cert, info->GetHostName,
    1:                                   info->GetHostIP, info->GetHostPort)) {
    1:           node = CERT_LIST_NEXT(node);
    1:           continue;
    1:       }
    1: #endif
    1: 
    1:       privKey = PK11_FindKeyByAnyCert(node->cert, wincx);
    1:       if (privKey != NULL) {
    1:         if (hasExplicitKeyUsageNonRepudiation(node->cert)) {
    1:           SECKEY_DestroyPrivateKey(privKey);
    1:           privKey = NULL;
    1:           // Not a prefered cert
    1:           if (!low_prio_nonrep_cert) // did not yet find a low prio cert
    1:             low_prio_nonrep_cert = CERT_DupCertificate(node->cert);
    1:         }
    1:         else {
    1:           // this is a good cert to present
    1:           cert = CERT_DupCertificate(node->cert);
    1:           break;
    1:         }
    1:       }
    1:       keyError = PR_GetError();
    1:       if (keyError == SEC_ERROR_BAD_PASSWORD) {
    1:           /* problem with password: bail */
    1:           goto loser;
    1:       }
    1: 
    1:       node = CERT_LIST_NEXT(node);
    1:     }
    1: 
    1:     if (!cert && low_prio_nonrep_cert) {
    1:       cert = low_prio_nonrep_cert;
    1:       low_prio_nonrep_cert = NULL; // take it away from the cleaner
    1:       privKey = PK11_FindKeyByAnyCert(cert, wincx);
    1:     }
    1: 
    1:     if (cert == NULL) {
    1:         goto noCert;
    1:     }
    1:   }
    1:   else {
    1:     /* user selects a cert to present */
    1:     nsIClientAuthDialogs *dialogs = NULL;
    1:     PRInt32 selectedIndex = -1;
    1:     PRUnichar **certNicknameList = NULL;
    1:     PRUnichar **certDetailsList = NULL;
20054:     PRBool canceled;
    1: 
    1:     /* find all user certs that are for SSL */
    1:     /* note that we are allowing expired certs in this list */
    1:     certList = CERT_FindUserCertsByUsage(CERT_GetDefaultCertDB(), 
    1:                                          certUsageSSLClient, PR_FALSE, 
    1:                                          PR_FALSE, wincx);
    1:     if (certList == NULL) {
    1:       goto noCert;
    1:     }
    1: 
    1:     if (caNames->nnames != 0) {
    1:       /* filter the list to those issued by CAs supported by the 
    1:        * server 
    1:        */
    1:       ret = CERT_FilterCertListByCANames(certList, caNames->nnames, 
    1:                                         caNameStrings, 
    1:                                         certUsageSSLClient);
    1:       if (ret != SECSuccess) {
    1:         goto loser;
    1:       }
    1:     }
    1: 
    1:     if (CERT_LIST_END(CERT_LIST_HEAD(certList), certList)) {
    1:       /* list is empty - no matching certs */
    1:       goto noCert;
    1:     }
    1: 
    1:     /* filter it further for hostname restriction */
    1:     node = CERT_LIST_HEAD(certList);
    1:     while (!CERT_LIST_END(node, certList)) {
    1:       ++NumberOfCerts;
    1: #if 0 /* XXX Fix this */
    1:       if (!CERT_MatchesScopeOfUse(node->cert, conn->hostName,
    1:                                   conn->hostIP, conn->port)) {
    1:         CERTCertListNode* removed = node;
    1:         node = CERT_LIST_NEXT(removed);
    1:         CERT_RemoveCertListNode(removed);
    1:       }
    1:       else {
    1:         node = CERT_LIST_NEXT(node);
    1:       }
    1: #endif
    1:       node = CERT_LIST_NEXT(node);
    1:     }
    1:     if (CERT_LIST_END(CERT_LIST_HEAD(certList), certList)) {
    1:       goto noCert;
    1:     }
    1: 
    1:     nicknames = getNSSCertNicknamesFromCertList(certList);
    1: 
    1:     if (nicknames == NULL) {
    1:       goto loser;
    1:     }
    1: 
    1:     NS_ASSERTION(nicknames->numnicknames == NumberOfCerts, "nicknames->numnicknames != NumberOfCerts");
    1: 
20054:     /* Get the SSL Certificate */
20054:     serverCert = SSL_PeerCertificate(socket);
20054:     if (serverCert == NULL) {
20054:       /* couldn't get the server cert: what do I do? */
20054:       goto loser;
20054:     }
20054: 
    1:     /* Get CN and O of the subject and O of the issuer */
    1:     char *ccn = CERT_GetCommonName(&serverCert->subject);
10549:     charCleaner ccnCleaner(ccn);
    1:     NS_ConvertUTF8toUTF16 cn(ccn);
10549: 
10549:     PRInt32 port;
10549:     info->GetPort(&port);
20054:     char *hostname = SSL_RevealURL(socket);
20054:     charCleaner hostnameCleaner(hostname);
10549: 
10549:     nsString cn_host_port;
10549:     if (ccn && strcmp(ccn, hostname) == 0) {
10549:       cn_host_port.Append(cn);
10549:       cn_host_port.AppendLiteral(":");
10549:       cn_host_port.AppendInt(port);
10549:     }
10549:     else {
10549:       cn_host_port.Append(cn);
10549:       cn_host_port.AppendLiteral(" (");
10549:       cn_host_port.AppendLiteral(":");
10549:       cn_host_port.AppendInt(port);
10549:       cn_host_port.AppendLiteral(")");
10549:     }
    1: 
    1:     char *corg = CERT_GetOrgName(&serverCert->subject);
    1:     NS_ConvertUTF8toUTF16 org(corg);
    1:     if (corg) PORT_Free(corg);
    1: 
    1:     char *cissuer = CERT_GetOrgName(&serverCert->issuer);
    1:     NS_ConvertUTF8toUTF16 issuer(cissuer);
    1:     if (cissuer) PORT_Free(cissuer);
    1: 
20054:     CERT_DestroyCertificate(serverCert);
20054: 
    1:     certNicknameList = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * nicknames->numnicknames);
    1:     if (!certNicknameList)
    1:       goto loser;
    1:     certDetailsList = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * nicknames->numnicknames);
    1:     if (!certDetailsList) {
    1:       nsMemory::Free(certNicknameList);
    1:       goto loser;
    1:     }
    1: 
    1:     PRInt32 CertsToUse;
    1:     for (CertsToUse = 0, node = CERT_LIST_HEAD(certList);
    1:          !CERT_LIST_END(node, certList) && CertsToUse < nicknames->numnicknames;
    1:          node = CERT_LIST_NEXT(node)
    1:         )
    1:     {
    1:       nsRefPtr<nsNSSCertificate> tempCert = new nsNSSCertificate(node->cert);
    1: 
    1:       if (!tempCert)
    1:         continue;
    1:       
    1:       NS_ConvertUTF8toUTF16 i_nickname(nicknames->nicknames[CertsToUse]);
    1:       nsAutoString nickWithSerial, details;
    1:       
    1:       if (NS_FAILED(tempCert->FormatUIStrings(i_nickname, nickWithSerial, details)))
    1:         continue;
    1: 
    1:       certNicknameList[CertsToUse] = ToNewUnicode(nickWithSerial);
    1:       if (!certNicknameList[CertsToUse])
    1:         continue;
    1:       certDetailsList[CertsToUse] = ToNewUnicode(details);
    1:       if (!certDetailsList[CertsToUse]) {
    1:         nsMemory::Free(certNicknameList[CertsToUse]);
    1:         continue;
    1:       }
    1: 
    1:       ++CertsToUse;
    1:     }
    1: 
    1:     /* Throw up the client auth dialog and get back the index of the selected cert */
    1:     rv = getNSSDialogs((void**)&dialogs, 
    1:                        NS_GET_IID(nsIClientAuthDialogs),
    1:                        NS_CLIENTAUTHDIALOGS_CONTRACTID);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certNicknameList);
    1:       NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certDetailsList);
    1:       goto loser;
    1:     }
    1: 
    1:     {
    1:       nsPSMUITracker tracker;
    1:       if (tracker.isUIForbidden()) {
    1:         rv = NS_ERROR_NOT_AVAILABLE;
    1:       }
    1:       else {
10549:         rv = dialogs->ChooseCertificate(info, cn_host_port.get(), org.get(), issuer.get(), 
    1:           (const PRUnichar**)certNicknameList, (const PRUnichar**)certDetailsList,
    1:           CertsToUse, &selectedIndex, &canceled);
    1:       }
    1:     }
    1: 
    1:     NS_RELEASE(dialogs);
    1:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certNicknameList);
    1:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certDetailsList);
    1:     
    1:     if (NS_FAILED(rv)) goto loser;
    1: 
20054:     if (canceled) { rv = NS_ERROR_NOT_AVAILABLE; goto loser; }
    1: 
    1:     int i;
    1:     for (i = 0, node = CERT_LIST_HEAD(certList);
    1:          !CERT_LIST_END(node, certList);
    1:          ++i, node = CERT_LIST_NEXT(node)) {
    1: 
    1:       if (i == selectedIndex) {
    1:         cert = CERT_DupCertificate(node->cert);
    1:         break;
    1:       }
    1:     }
    1: 
    1:     if (cert == NULL) {
    1:       goto loser;
    1:     }
    1: 
    1:     /* go get the private key */
    1:     privKey = PK11_FindKeyByAnyCert(cert, wincx);
    1:     if (privKey == NULL) {
    1:       keyError = PR_GetError();
    1:       if (keyError == SEC_ERROR_BAD_PASSWORD) {
    1:           /* problem with password: bail */
    1:           goto loser;
    1:       }
    1:       else {
    1:           goto noCert;
    1:       }
    1:     }
    1:   }
    1:   goto done;
    1: 
    1: noCert:
    1: loser:
    1:   if (ret == SECSuccess) {
    1:     ret = SECFailure;
    1:   }
    1:   if (cert != NULL) {
    1:     CERT_DestroyCertificate(cert);
    1:     cert = NULL;
    1:   }
    1: done:
    1:   if (extracted != NULL) {
    1:     PR_Free(extracted);
    1:   }
    1:   if (nicknames != NULL) {
    1:     CERT_FreeNicknames(nicknames);
    1:   }
    1:   if (certList != NULL) {
    1:     CERT_DestroyCertList(certList);
    1:   }
    1:   if (arena != NULL) {
    1:     PORT_FreeArena(arena, PR_FALSE);
    1:   }
    1: 
    1:   *pRetCert = cert;
    1:   *pRetKey = privKey;
    1: 
    1:   return ret;
    1: }
    1: 
    1: static SECStatus
 6597: cancel_and_failure(nsNSSSocketInfo* infoObject)
 6597: {
 6597:   infoObject->SetCanceled(PR_TRUE);
 6597:   return SECFailure;
 6597: }
 6597: 
 6597: static SECStatus
    1: nsNSSBadCertHandler(void *arg, PRFileDesc *sslSocket)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   nsNSSSocketInfo* infoObject = (nsNSSSocketInfo *)arg;
 6597:   if (!infoObject)
 6597:     return SECFailure;
 6597: 
14244:   if (nsSSLThread::exitRequested())
14244:     return cancel_and_failure(infoObject);
14244: 
 6597:   CERTCertificate *peerCert = nsnull;
 6597:   CERTCertificateCleaner peerCertCleaner(peerCert);
    1:   peerCert = SSL_PeerCertificate(sslSocket);
 6597:   if (!peerCert)
 6597:     return cancel_and_failure(infoObject);
 6597: 
 6597:   nsRefPtr<nsNSSCertificate> nssCert;
    1:   nssCert = new nsNSSCertificate(peerCert);
 6597:   if (!nssCert)
 6597:     return cancel_and_failure(infoObject);
 6597: 
 6597:   nsCOMPtr<nsIX509Cert> ix509 = static_cast<nsIX509Cert*>(nssCert.get());
 6597: 
 6597:   SECStatus srv;
 6597:   nsresult nsrv;
 6597:   PRUint32 collected_errors = 0;
 6597:   PRUint32 remaining_display_errors = 0;
 6597: 
 7252:   PRErrorCode errorCodeTrust = SECSuccess;
 7252:   PRErrorCode errorCodeMismatch = SECSuccess;
 7252:   PRErrorCode errorCodeExpired = SECSuccess;
 6597:   
 6597:   char *hostname = SSL_RevealURL(sslSocket);
 6597:   charCleaner hostnameCleaner(hostname); 
 6597:   nsDependentCString hostString(hostname);
 6597: 
 6597:   PRInt32 port;
 6597:   infoObject->GetPort(&port);
 6597: 
 6597:   nsCString hostWithPortString = hostString;
 6597:   hostWithPortString.AppendLiteral(":");
 6597:   hostWithPortString.AppendInt(port);
 6597: 
 7054:   NS_ConvertUTF8toUTF16 hostWithPortStringUTF16(hostWithPortString);
 6597: 
 6597:   // Check the name field against the desired hostname.
 6597:   if (hostname && hostname[0] &&
 6597:       CERT_VerifyCertName(peerCert, hostname) != SECSuccess) {
 6597:     collected_errors |= nsICertOverrideService::ERROR_MISMATCH;
 7252:     errorCodeMismatch = SSL_ERROR_BAD_CERT_DOMAIN;
 6597:   }
 6597: 
 6597:   {
 6597:     PRArenaPool *log_arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
 6597:     if (!log_arena)    
 6597:       return cancel_and_failure(infoObject);
 6597: 
 6597:     PRArenaPoolCleanerFalseParam log_arena_cleaner(log_arena);
 6597: 
 6597:     CERTVerifyLog *verify_log = PORT_ArenaZNew(log_arena, CERTVerifyLog);
 6597:     if (!verify_log)
 6597:       return cancel_and_failure(infoObject);
 6597: 
 6597:     CERTVerifyLogContentsCleaner verify_log_cleaner(verify_log);
 6597: 
 6597:     verify_log->arena = log_arena;
 6597: 
 6597:     srv = CERT_VerifyCertificate(CERT_GetDefaultCertDB(), peerCert,
 6597:                                  PR_TRUE, certificateUsageSSLServer,
 6597:                                  PR_Now(), (void*)infoObject, 
 6597:                                  verify_log, NULL);
 6597: 
 6597:     // We ignore the result code of the cert verification.
 6597:     // Either it is a failure, which is expected, and we'll process the
 6597:     //                         verify log below.
 6597:     // Or it is a success, then a domain mismatch is the only 
 6597:     //                     possible failure. 
 6597: 
 6597:     CERTVerifyLogNode *i_node;
 6597:     for (i_node = verify_log->head; i_node; i_node = i_node->next)
 6597:     {
 6597:       switch (i_node->error)
 6597:       {
 6597:         case SEC_ERROR_UNKNOWN_ISSUER:
 6597:         case SEC_ERROR_CA_CERT_INVALID:
 6597:         case SEC_ERROR_UNTRUSTED_ISSUER:
 6597:         case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
 6597:         case SEC_ERROR_UNTRUSTED_CERT:
13929:         case SEC_ERROR_INADEQUATE_KEY_USAGE:
 6597:           // We group all these errors as "cert not trusted"
 6597:           collected_errors |= nsICertOverrideService::ERROR_UNTRUSTED;
 7252:           if (errorCodeTrust == SECSuccess) {
 7252:             errorCodeTrust = i_node->error;
 7252:           }
 6597:           break;
 6597:         case SSL_ERROR_BAD_CERT_DOMAIN:
 6597:           collected_errors |= nsICertOverrideService::ERROR_MISMATCH;
 7252:           if (errorCodeMismatch == SECSuccess) {
 7252:             errorCodeMismatch = i_node->error;
 7252:           }
 6597:           break;
 6597:         case SEC_ERROR_EXPIRED_CERTIFICATE:
 6597:           collected_errors |= nsICertOverrideService::ERROR_TIME;
 7252:           if (errorCodeExpired == SECSuccess) {
 7252:             errorCodeExpired = i_node->error;
 7252:           }
 6597:           break;
 6597:         default:
 6597:           // we are not willing to continue on any other error
 6597:           nsHandleSSLError(infoObject, i_node->error);
10294:           // this error is our stop condition, so let's make sure
10294:           // this error code will be reported to the external world.
10294:           PR_SetError(i_node->error, 0);
 6597:           return cancel_and_failure(infoObject);
 6597:       }
 6597:     }
 6597:   }
 6597: 
 6597:   if (!collected_errors)
 6597:   {
 6597:     NS_NOTREACHED("why did NSS call our bad cert handler if all looks good? Let's cancel the connection");
    1:     return SECFailure;
    1:   }
 6597: 
 8463:   nsRefPtr<nsSSLStatus> status = infoObject->SSLStatus();
 6597:   if (!status) {
 6597:     status = new nsSSLStatus();
 6597:     infoObject->SetSSLStatus(status);
    1:   }
 6597: 
 6597:   if (status) {
 6597:     if (!status->mServerCert) {
 6597:       status->mServerCert = nssCert;
    1:     }
 6597: 
10546:     status->mHaveCertErrorBits = PR_TRUE;
 6597:     status->mIsDomainMismatch = collected_errors & nsICertOverrideService::ERROR_MISMATCH;
 6597:     status->mIsNotValidAtThisTime = collected_errors & nsICertOverrideService::ERROR_TIME;
 6597:     status->mIsUntrusted = collected_errors & nsICertOverrideService::ERROR_UNTRUSTED;
    1:   }
 6597: 
 6597:   remaining_display_errors = collected_errors;
 6597: 
 6597:   nsCOMPtr<nsICertOverrideService> overrideService = 
 6597:     do_GetService(NS_CERTOVERRIDE_CONTRACTID);
 6597:   // it is fine to continue without the nsICertOverrideService
 6597: 
 8176:   PRUint32 overrideBits = 0; 
 6597: 
 6597:   if (overrideService)
 6597:   {
 8176:     PRBool haveOverride;
 8176:     PRBool isTemporaryOverride; // we don't care
 6597:   
14555:     nsrv = overrideService->HasMatchingOverride(hostString, port,
 6597:                                                 ix509, 
 8176:                                                 &overrideBits,
 8176:                                                 &isTemporaryOverride, 
 8176:                                                 &haveOverride);
 8176:     if (NS_SUCCEEDED(nsrv) && haveOverride) 
 6597:     {
 6597:       // remove the errors that are already overriden
 8176:       remaining_display_errors -= overrideBits;
 6597:     }
 6597:   }
 6597: 
 6597:   if (!remaining_display_errors) {
 6597:     // all errors are covered by override rules, so let's accept the cert
 6597:     return SECSuccess;
 6597:   }
 6597: 
 6597:   // Ok, this is a full stop.
 6597:   // First, deliver the technical details of the broken SSL status,
 6597:   // giving the caller a chance to suppress the error messages.
 6597: 
 6597:   PRBool suppressMessage = PR_FALSE;
 6597:   nsresult rv;
 6597: 
 6597:   // Try to get a nsIBadCertListener2 implementation from the socket consumer.
14244:   nsCOMPtr<nsIInterfaceRequestor> cb;
14244:   infoObject->GetNotificationCallbacks(getter_AddRefs(cb));
14244:   if (cb) {
 6597:     nsCOMPtr<nsIInterfaceRequestor> callbacks;
14244:     NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
14244:                          NS_GET_IID(nsIInterfaceRequestor),
14244:                          cb,
14244:                          NS_PROXY_SYNC,
14244:                          getter_AddRefs(callbacks));
14244: 
 6597:     nsCOMPtr<nsIBadCertListener2> bcl = do_GetInterface(callbacks);
 6597:     if (bcl) {
24953:       nsCOMPtr<nsIBadCertListener2> proxy_bcl;
 6597:       NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
 6597:                            NS_GET_IID(nsIBadCertListener2),
 6597:                            bcl,
 6597:                            NS_PROXY_SYNC,
24953:                            getter_AddRefs(proxy_bcl));
 6597:       if (proxy_bcl) {
 6597:         nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(infoObject);
 6597:         rv = proxy_bcl->NotifyCertProblem(csi, status, hostWithPortString, 
 6597:                                           &suppressMessage);
 6597:       }
 6597:     }
 6597:   }
 6597: 
 7054:   nsCOMPtr<nsIRecentBadCertsService> recentBadCertsService = 
 7054:     do_GetService(NS_RECENTBADCERTS_CONTRACTID);
 7054: 
 7054:   if (recentBadCertsService) {
 7054:     recentBadCertsService->AddBadCert(hostWithPortStringUTF16, status);
 7054:   }
 7054: 
 7252:   // pick the error code to report by priority
 7252:   PRErrorCode errorCodeToReport = SECSuccess;
 7252:   if (remaining_display_errors & nsICertOverrideService::ERROR_UNTRUSTED)
 7252:     errorCodeToReport = errorCodeTrust;
 7252:   else if (remaining_display_errors & nsICertOverrideService::ERROR_MISMATCH)
 7252:     errorCodeToReport = errorCodeMismatch;
 7252:   else if (remaining_display_errors & nsICertOverrideService::ERROR_TIME)
 7252:     errorCodeToReport = errorCodeExpired;
 7252: 
 6597:   if (!suppressMessage) {
20523:     PRBool external = PR_FALSE;
20523:     infoObject->GetExternalErrorReporting(&external);
20523: 
 6597:     nsHandleInvalidCertError(infoObject,
 6597:                              remaining_display_errors,
 6597:                              hostString,
 6597:                              hostWithPortString,
 7252:                              port,
 6597:                              errorCodeToReport,
 7252:                              errorCodeTrust,
 7252:                              errorCodeMismatch,
 7252:                              errorCodeExpired,
20523:                              external, // wantsHtml
 6597:                              ix509);
 6597:   }
 7054: 
 7875:   PR_SetError(errorCodeToReport, 0);
 6597:   return cancel_and_failure(infoObject);
    1: }
    1: 
    1: static PRFileDesc*
    1: nsSSLIOLayerImportFD(PRFileDesc *fd,
    1:                      nsNSSSocketInfo *infoObject,
25076:                      const char *host,
25076:                      PRBool anonymousLoad)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   PRFileDesc* sslSock = SSL_ImportFD(nsnull, fd);
    1:   if (!sslSock) {
    1:     NS_ASSERTION(PR_FALSE, "NSS: Error importing socket");
    1:     return nsnull;
    1:   }
    1:   SSL_SetPKCS11PinArg(sslSock, (nsIInterfaceRequestor*)infoObject);
    1:   SSL_HandshakeCallback(sslSock, HandshakeCallback, infoObject);
25076: 
25076:   // Disable this hook if we connect anonymously. See bug 466080.
25076:   if (anonymousLoad) {
25076:       SSL_GetClientAuthDataHook(sslSock, NULL, infoObject);
25076:   } else {
    1:       SSL_GetClientAuthDataHook(sslSock, 
    1:                             (SSLGetClientAuthData)nsNSS_SSLGetClientAuthData,
    1:                             infoObject);
25076:   }
    1:   SSL_AuthCertificateHook(sslSock, AuthCertificateCallback, 0);
    1: 
    1:   PRInt32 ret = SSL_SetURL(sslSock, host);
    1:   if (ret == -1) {
    1:     NS_ASSERTION(PR_FALSE, "NSS: Error setting server name");
    1:     goto loser;
    1:   }
    1:   return sslSock;
    1: loser:
    1:   if (sslSock) {
    1:     PR_Close(sslSock);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: static nsresult
    1: nsSSLIOLayerSetOptions(PRFileDesc *fd, PRBool forSTARTTLS, 
    1:                        const char *proxyHost, const char *host, PRInt32 port,
25076:                        PRBool anonymousLoad, nsNSSSocketInfo *infoObject)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   if (forSTARTTLS || proxyHost) {
    1:     if (SECSuccess != SSL_OptionSet(fd, SSL_SECURITY, PR_FALSE)) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     infoObject->SetHasCleartextPhase(PR_TRUE);
    1:   }
    1: 
    1:   if (forSTARTTLS) {
    1:     if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_SSL2, PR_FALSE)) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     if (SECSuccess != SSL_OptionSet(fd, SSL_V2_COMPATIBLE_HELLO, PR_FALSE)) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1: 
    1:   // Let's see if we're trying to connect to a site we know is
    1:   // TLS intolerant.
    1:   nsCAutoString key;
    1:   key = nsDependentCString(host) + NS_LITERAL_CSTRING(":") + nsPrintfCString("%d", port);
    1: 
    1:   if (nsSSLIOLayerHelpers::isKnownAsIntolerantSite(key)) {
    1:     if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_TLS, PR_FALSE))
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     infoObject->SetAllowTLSIntoleranceTimeout(PR_FALSE);
    1:       
    1:     // We assume that protocols that use the STARTTLS mechanism should support
    1:     // modern hellos. For other protocols, if we suspect a site 
    1:     // does not support TLS, let's also use V2 hellos.
    1:     // One advantage of this approach, if a site only supports the older
    1:     // hellos, it is more likely that we will get a reasonable error code
    1:     // on our single retry attempt.
    1:     
    1:     if (!forSTARTTLS &&
    1:         SECSuccess != SSL_OptionSet(fd, SSL_V2_COMPATIBLE_HELLO, PR_TRUE))
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (SECSuccess != SSL_OptionSet(fd, SSL_HANDSHAKE_AS_CLIENT, PR_TRUE)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   if (SECSuccess != SSL_BadCertHook(fd, (SSLBadCertHandler) nsNSSBadCertHandler,
    1:                                     infoObject)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Set the Peer ID so that SSL proxy connections work properly.
25076:   char *peerId;
25076:   if (anonymousLoad) {  // See bug #466080. Separate the caches.
25076:       peerId = PR_smprintf("anon:%s:%d", host, port);
25076:   } else {
25076:       peerId = PR_smprintf("%s:%d", host, port);
25076:   }
25076:   
    1:   if (SECSuccess != SSL_SetSockPeerID(fd, peerId)) {
    1:     PR_smprintf_free(peerId);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   PR_smprintf_free(peerId);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSSLIOLayerAddToSocket(PRInt32 family,
    1:                         const char* host,
    1:                         PRInt32 port,
    1:                         const char* proxyHost,
    1:                         PRInt32 proxyPort,
    1:                         PRFileDesc* fd,
    1:                         nsISupports** info,
25076:                         PRBool forSTARTTLS,
25076:                         PRBool anonymousLoad)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   PRFileDesc* layer = nsnull;
    1:   nsresult rv;
    1: 
    1:   nsNSSSocketInfo* infoObject = new nsNSSSocketInfo();
    1:   if (!infoObject) return NS_ERROR_FAILURE;
    1:   
    1:   NS_ADDREF(infoObject);
    1:   infoObject->SetForSTARTTLS(forSTARTTLS);
    1:   infoObject->SetHostName(host);
    1:   infoObject->SetPort(port);
    1: 
25076:   PRFileDesc *sslSock = nsSSLIOLayerImportFD(fd, infoObject, host, anonymousLoad);
    1:   if (!sslSock) {
    1:     NS_ASSERTION(PR_FALSE, "NSS: Error importing socket");
    1:     goto loser;
    1:   }
    1: 
    1:   infoObject->SetFileDescPtr(sslSock);
    1: 
25076:   rv = nsSSLIOLayerSetOptions(sslSock,
25076:                               forSTARTTLS, proxyHost, host, port, anonymousLoad,
    1:                               infoObject);
    1: 
    1:   if (NS_FAILED(rv))
    1:     goto loser;
    1: 
    1:   /* Now, layer ourselves on top of the SSL socket... */
    1:   layer = PR_CreateIOLayerStub(nsSSLIOLayerHelpers::nsSSLIOLayerIdentity,
    1:                                &nsSSLIOLayerHelpers::nsSSLIOLayerMethods);
    1:   if (!layer)
    1:     goto loser;
    1:   
    1:   layer->secret = (PRFilePrivate*) infoObject;
    1:   rv = PR_PushIOLayer(sslSock, PR_GetLayersIdentity(sslSock), layer);
    1:   
    1:   if (NS_FAILED(rv)) {
    1:     goto loser;
    1:   }
    1:   
    1:   nsNSSShutDownList::trackSSLSocketCreate();
    1: 
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] Socket set up\n", (void*)sslSock));
    1:   infoObject->QueryInterface(NS_GET_IID(nsISupports), (void**) (info));
    1: 
    1:   // We are going use a clear connection first //
    1:   if (forSTARTTLS || proxyHost) {
    1:     infoObject->SetHandshakePending(PR_FALSE);
    1:   }
    1: 
    1:   return NS_OK;
    1:  loser:
    1:   NS_IF_RELEASE(infoObject);
    1:   if (layer) {
    1:     layer->dtor(layer);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
