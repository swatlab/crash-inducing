    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* the caret is the text cursor used, e.g., when editing */
    1: 
    1: #include "nsCOMPtr.h"
    1: 
    1: #include "nsITimer.h"
    1: 
    1: #include "nsIComponentManager.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsIFrame.h"
 4578: #include "nsIScrollableFrame.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIContent.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsPresContext.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsISelectionController.h"
    1: #include "nsDisplayList.h"
    1: #include "nsCaret.h"
 7677: #include "nsTextFrame.h"
13787: #include "nsXULPopupManager.h"
13787: #include "nsMenuPopupFrame.h"
14572: #include "nsTextFragment.h"
15481: #include "nsThemeConstants.h"
    1: 
    1: // The bidi indicator hangs off the caret to one side, to show which
    1: // direction the typing is in. It needs to be at least 2x2 to avoid looking like 
    1: // an insignificant dot
14311: static const PRInt32 kMinBidiIndicatorPixels = 2;
    1: 
    1: #ifdef IBMBIDI
    1: #include "nsIBidiKeyboard.h"
    1: #include "nsContentUtils.h"
    1: #endif //IBMBIDI
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsCaret::nsCaret()
    1: : mPresShell(nsnull)
    1: , mBlinkRate(500)
    1: , mVisible(PR_FALSE)
    1: , mDrawn(PR_FALSE)
33905: , mPendingDraw(PR_FALSE)
    1: , mReadOnly(PR_FALSE)
    1: , mShowDuringSelection(PR_FALSE)
23142: , mIgnoreUserModify(PR_TRUE)
23142: #ifdef IBMBIDI
23142: , mKeyboardRTL(PR_FALSE)
23142: , mLastBidiLevel(0)
23142: #endif
    1: , mLastContentOffset(0)
    1: , mLastHint(nsFrameSelection::HINTLEFT)
    1: {
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: nsCaret::~nsCaret()
    1: {
    1:   KillTimer();
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
15969: nsresult nsCaret::Init(nsIPresShell *inPresShell)
    1: {
    1:   NS_ENSURE_ARG(inPresShell);
    1: 
    1:   mPresShell = do_GetWeakReference(inPresShell);    // the presshell owns us, so no addref
    1:   NS_ASSERTION(mPresShell, "Hey, pres shell should support weak refs");
    1: 
    1:   // get nsILookAndFeel from the pres context, which has one cached.
    1:   nsILookAndFeel *lookAndFeel = nsnull;
    1:   nsPresContext *presContext = inPresShell->GetPresContext();
    1:   
14311:   // XXX we should just do this nsILookAndFeel consultation every time
14311:   // we need these values.
14311:   mCaretWidthCSSPx = 1;
15481:   mCaretAspectRatio = 0;
    1:   if (presContext && (lookAndFeel = presContext->LookAndFeel())) {
    1:     PRInt32 tempInt;
15481:     float tempFloat;
    1:     if (NS_SUCCEEDED(lookAndFeel->GetMetric(nsILookAndFeel::eMetric_CaretWidth, tempInt)))
14311:       mCaretWidthCSSPx = (nscoord)tempInt;
15481:     if (NS_SUCCEEDED(lookAndFeel->GetMetric(nsILookAndFeel::eMetricFloat_CaretAspectRatio, tempFloat)))
15481:       mCaretAspectRatio = tempFloat;
    1:     if (NS_SUCCEEDED(lookAndFeel->GetMetric(nsILookAndFeel::eMetric_CaretBlinkTime, tempInt)))
    1:       mBlinkRate = (PRUint32)tempInt;
    1:     if (NS_SUCCEEDED(lookAndFeel->GetMetric(nsILookAndFeel::eMetric_ShowCaretDuringSelection, tempInt)))
    1:       mShowDuringSelection = tempInt ? PR_TRUE : PR_FALSE;
    1:   }
    1:   
    1:   // get the selection from the pres shell, and set ourselves up as a selection
    1:   // listener
    1: 
    1:   nsCOMPtr<nsISelectionController> selCon = do_QueryReferent(mPresShell);
    1:   if (!selCon)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsISelection> domSelection;
    1:   nsresult rv = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:                                      getter_AddRefs(domSelection));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   if (!domSelection)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsISelectionPrivate> privateSelection = do_QueryInterface(domSelection);
    1:   if (privateSelection)
    1:     privateSelection->AddSelectionListener(this);
    1:   mDomSelectionWeak = do_GetWeakReference(domSelection);
    1:   
    1:   // set up the blink timer
    1:   if (mVisible)
    1:   {
15969:     StartBlinking();
    1:   }
22779: #ifdef IBMBIDI
22779:   mBidiUI = nsContentUtils::GetBoolPref("bidi.browser.ui");
22779: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
14572: static PRBool
14572: DrawCJKCaret(nsIFrame* aFrame, PRInt32 aOffset)
14572: {
14572:   nsIContent* content = aFrame->GetContent();
14572:   const nsTextFragment* frag = content->GetText();
14572:   if (!frag)
14572:     return PR_FALSE;
23142:   if (aOffset < 0 || PRUint32(aOffset) >= frag->GetLength())
14572:     return PR_FALSE;
14572:   PRUnichar ch = frag->CharAt(aOffset);
14572:   return 0x2e80 <= ch && ch <= 0xd7ff;
14572: }
14572: 
15481: nsCaret::Metrics nsCaret::ComputeMetrics(nsIFrame* aFrame, PRInt32 aOffset, nscoord aCaretHeight)
14311: {
14311:   // Compute nominal sizes in appunits
15481:   nscoord caretWidth = (aCaretHeight * mCaretAspectRatio) +
15481:                        nsPresContext::CSSPixelsToAppUnits(mCaretWidthCSSPx);
15481: 
14572:   if (DrawCJKCaret(aFrame, aOffset)) {
14572:     caretWidth += nsPresContext::CSSPixelsToAppUnits(1);
14572:   }
14311:   nscoord bidiIndicatorSize = nsPresContext::CSSPixelsToAppUnits(kMinBidiIndicatorPixels);
32531:   bidiIndicatorSize = NS_MAX(caretWidth, bidiIndicatorSize);
14311: 
14311:   // Round them to device pixels. Always round down, except that anything
14311:   // between 0 and 1 goes up to 1 so we don't let the caret disappear.
14572:   PRUint32 tpp = aFrame->PresContext()->AppUnitsPerDevPixel();
14311:   Metrics result;
14311:   result.mCaretWidth = NS_ROUND_BORDER_TO_PIXELS(caretWidth, tpp);
14311:   result.mBidiIndicatorSize = NS_ROUND_BORDER_TO_PIXELS(bidiIndicatorSize, tpp);
14311:   return result;
14311: }
    1: 
    1: //-----------------------------------------------------------------------------
15969: void nsCaret::Terminate()
    1: {
    1:   // this doesn't erase the caret if it's drawn. Should it? We might not have
    1:   // a good drawing environment during teardown.
    1:   
    1:   KillTimer();
    1:   mBlinkTimer = nsnull;
    1: 
    1:   // unregiser ourselves as a selection listener
    1:   nsCOMPtr<nsISelection> domSelection = do_QueryReferent(mDomSelectionWeak);
    1:   nsCOMPtr<nsISelectionPrivate> privateSelection(do_QueryInterface(domSelection));
    1:   if (privateSelection)
    1:     privateSelection->RemoveSelectionListener(this);
    1:   mDomSelectionWeak = nsnull;
    1:   mPresShell = nsnull;
    1: 
    1:   mLastContent = nsnull;
    1: }
    1: 
15969: //-----------------------------------------------------------------------------
15969: NS_IMPL_ISUPPORTS1(nsCaret, nsISelectionListener)
    1: 
    1: //-----------------------------------------------------------------------------
15969: nsISelection* nsCaret::GetCaretDOMSelection()
15969: {
15969:   nsCOMPtr<nsISelection> sel(do_QueryReferent(mDomSelectionWeak));
15969:   return sel;  
15969: }
    1: 
    1: //-----------------------------------------------------------------------------
15969: nsresult nsCaret::SetCaretDOMSelection(nsISelection *aDOMSel)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDOMSel);
    1:   mDomSelectionWeak = do_GetWeakReference(aDOMSel);   // weak reference to pres shell
    1:   if (mVisible)
    1:   {
    1:     // Stop the caret from blinking in its previous location.
    1:     StopBlinking();
    1:     // Start the caret blinking in the new location.
    1:     StartBlinking();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
15969: void nsCaret::SetCaretVisible(PRBool inMakeVisible)
    1: {
    1:   mVisible = inMakeVisible;
12305:   if (mVisible) {
15969:     StartBlinking();
12305:     SetIgnoreUserModify(PR_TRUE);
12305:   } else {
15969:     StopBlinking();
12305:     SetIgnoreUserModify(PR_FALSE);
12305:   }
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
15969: nsresult nsCaret::GetCaretVisible(PRBool *outMakeVisible)
    1: {
    1:   NS_ENSURE_ARG_POINTER(outMakeVisible);
14068:   *outMakeVisible = (mVisible && MustDrawCaret(PR_TRUE));
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
15969: void nsCaret::SetCaretReadOnly(PRBool inMakeReadonly)
    1: {
    1:   mReadOnly = inMakeReadonly;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
15969: nsresult nsCaret::GetCaretCoordinates(EViewCoordinates aRelativeToType,
    1:                                       nsISelection *aDOMSel,
    1:                                       nsRect *outCoordinates,
    1:                                       PRBool *outIsCollapsed,
    1:                                       nsIView **outView)
    1: {
    1:   if (!mPresShell)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1:   if (!outCoordinates || !outIsCollapsed)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsISelection> domSelection = aDOMSel;
    1: 
    1:   if (outView)
    1:     *outView = nsnull;
    1: 
    1:   // fill in defaults for failure
    1:   outCoordinates->x = -1;
    1:   outCoordinates->y = -1;
    1:   outCoordinates->width = -1;
    1:   outCoordinates->height = -1;
    1:   *outIsCollapsed = PR_FALSE;
    1:   
    1:   nsresult err = domSelection->GetIsCollapsed(outIsCollapsed);
    1:   if (NS_FAILED(err)) 
    1:     return err;
    1:     
    1:   nsCOMPtr<nsIDOMNode>  focusNode;
    1:   
    1:   err = domSelection->GetFocusNode(getter_AddRefs(focusNode));
    1:   if (NS_FAILED(err))
    1:     return err;
    1:   if (!focusNode)
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   PRInt32 focusOffset;
    1:   err = domSelection->GetFocusOffset(&focusOffset);
    1:   if (NS_FAILED(err))
    1:     return err;
    1:     
    1:   nsCOMPtr<nsIContent> contentNode = do_QueryInterface(focusNode);
    1:   if (!contentNode)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // find the frame that contains the content node that has focus
    1:   nsIFrame*       theFrame = nsnull;
    1:   PRInt32         theFrameOffset = 0;
    1: 
 8295:   nsCOMPtr<nsFrameSelection> frameSelection = GetFrameSelection();
    1:   if (!frameSelection)
    1:     return NS_ERROR_FAILURE;
    1:   PRUint8 bidiLevel = frameSelection->GetCaretBidiLevel();
    1:   
    1:   err = GetCaretFrameForNodeOffset(contentNode, focusOffset,
    1:                                    frameSelection->GetHint(), bidiLevel,
    1:                                    &theFrame, &theFrameOffset);
    1:   if (NS_FAILED(err) || !theFrame)
    1:     return err;
    1:   
    1:   nsPoint   viewOffset(0, 0);
    1:   nsIView   *drawingView;     // views are not refcounted
    1: 
    1:   GetViewForRendering(theFrame, aRelativeToType, viewOffset, &drawingView, outView);
    1:   if (!drawingView)
    1:     return NS_ERROR_UNEXPECTED;
    1:  
    1:   nsPoint   framePos(0, 0);
 4741:   err = theFrame->GetPointFromOffset(theFrameOffset, &framePos);
    1:   if (NS_FAILED(err))
    1:     return err;
    1: 
    1:   // we don't need drawingView anymore so reuse that; reset viewOffset values for our purposes
    1:   if (aRelativeToType == eClosestViewCoordinates)
    1:   {
    1:     theFrame->GetOffsetFromView(viewOffset, &drawingView);
    1:     if (outView)
    1:       *outView = drawingView;
    1:   }
    1:   // now add the frame offset to the view offset, and we're done
    1:   viewOffset += framePos;
    1:   outCoordinates->x = viewOffset.x;
    1:   outCoordinates->y = viewOffset.y;
    1:   outCoordinates->height = theFrame->GetSize().height;
15481:   outCoordinates->width = ComputeMetrics(theFrame, theFrameOffset, outCoordinates->height).mCaretWidth;
    1:   
    1:   return NS_OK;
    1: }
    1: 
37076: nsIFrame* nsCaret::GetGeometry(nsISelection* aSelection, nsRect* aRect)
37076: {
37076:   nsCOMPtr<nsIDOMNode> focusNode;
37076:   nsresult rv = aSelection->GetFocusNode(getter_AddRefs(focusNode));
37076:   if (NS_FAILED(rv) || !focusNode)
37076:     return nsnull;
37076: 
37076:   PRInt32 focusOffset;
37076:   rv = aSelection->GetFocusOffset(&focusOffset);
37076:   if (NS_FAILED(rv))
37076:     return nsnull;
37076:     
37076:   nsCOMPtr<nsIContent> contentNode = do_QueryInterface(focusNode);
37076:   if (!contentNode)
37076:     return nsnull;
37076: 
37076:   // find the frame that contains the content node that has focus
37076:   nsIFrame* theFrame = nsnull;
37076:   PRInt32   theFrameOffset = 0;
37076: 
37076:   nsCOMPtr<nsFrameSelection> frameSelection = GetFrameSelection();
37076:   if (!frameSelection)
37076:     return nsnull;
37076:   PRUint8 bidiLevel = frameSelection->GetCaretBidiLevel();
37076:   rv = GetCaretFrameForNodeOffset(contentNode, focusOffset,
37076:                                   frameSelection->GetHint(), bidiLevel,
37076:                                   &theFrame, &theFrameOffset);
37076:   if (NS_FAILED(rv) || !theFrame)
37076:     return nsnull;
37076:   
37076:   nsPoint framePos(0, 0);
37076:   rv = theFrame->GetPointFromOffset(theFrameOffset, &framePos);
37076:   if (NS_FAILED(rv))
37076:     return nsnull;
37076: 
37076:   // now add the frame offset to the view offset, and we're done
37076:   nscoord height = theFrame->GetSize().height;
37076:   nscoord width = ComputeMetrics(theFrame, theFrameOffset, height).mCaretWidth;
37076:   *aRect = nsRect(framePos.x, 0, width, height);
37076:   return theFrame;
37076: }
37076: 
    1: void nsCaret::DrawCaretAfterBriefDelay()
    1: {
    1:   // Make sure readonly caret gets drawn again if it needs to be
    1:   if (!mBlinkTimer) {
    1:     nsresult  err;
    1:     mBlinkTimer = do_CreateInstance("@mozilla.org/timer;1", &err);    
    1:     if (NS_FAILED(err))
    1:       return;
    1:   }    
    1: 
    1:   mBlinkTimer->InitWithFuncCallback(CaretBlinkCallback, this, 0,
    1:                                     nsITimer::TYPE_ONE_SHOT);
    1: }
    1: 
15969: void nsCaret::EraseCaret()
    1: {
    1:   if (mDrawn) {
    1:     DrawCaret(PR_TRUE);
 4580:     if (mReadOnly && mBlinkRate) {
    1:       // If readonly we don't have a blink timer set, so caret won't
    1:       // be redrawn automatically. We need to force the caret to get
    1:       // redrawn right after the paint
    1:       DrawCaretAfterBriefDelay();
    1:     }
    1:   }
    1: }
    1: 
15969: void nsCaret::SetVisibilityDuringSelection(PRBool aVisibility) 
    1: {
    1:   mShowDuringSelection = aVisibility;
    1: }
    1: 
15969: nsresult nsCaret::DrawAtPosition(nsIDOMNode* aNode, PRInt32 aOffset)
    1: {
    1:   NS_ENSURE_ARG(aNode);
    1: 
    1:   PRUint8 bidiLevel;
 8295:   nsCOMPtr<nsFrameSelection> frameSelection = GetFrameSelection();
    1:   if (!frameSelection)
    1:     return NS_ERROR_FAILURE;
    1:   bidiLevel = frameSelection->GetCaretBidiLevel();
    1: 
 4580:   // DrawAtPosition is used by consumers who want us to stay drawn where they
 4580:   // tell us. Setting mBlinkRate to 0 tells us to not set a timer to erase
 4580:   // ourselves, our consumer will take care of that.
 4580:   mBlinkRate = 0;
 4580: 
    1:   // XXX we need to do more work here to get the correct hint.
    1:   nsresult rv = DrawAtPositionWithHint(aNode, aOffset,
    1:                                        nsFrameSelection::HINTLEFT,
    1:                                        bidiLevel, PR_TRUE)
    1:     ?  NS_OK : NS_ERROR_FAILURE;
    1:   ToggleDrawnStatus();
    1:   return rv;
    1: }
    1: 
    1: nsIFrame * nsCaret::GetCaretFrame()
    1: {
    1:   // Return null if we're not drawn to prevent anybody from trying to draw us.
    1:   if (!mDrawn)
    1:     return nsnull;
    1: 
    1:   // Recompute the frame that we're supposed to draw in to guarantee that
    1:   // we're not going to try to draw into a stale (dead) frame.
    1:   PRInt32 unused;
    1:   nsIFrame *frame = nsnull;
    1:   nsresult rv = GetCaretFrameForNodeOffset(mLastContent, mLastContentOffset,
    1:                                            mLastHint, mLastBidiLevel, &frame,
    1:                                            &unused);
    1:   if (NS_FAILED(rv))
    1:     return nsnull;
    1: 
    1:   return frame;
    1: }
    1: 
    1: void nsCaret::InvalidateOutsideCaret()
    1: {
    1:   nsIFrame *frame = GetCaretFrame();
    1: 
    1:   // Only invalidate if we are not fully contained by our frame's rect.
    1:   if (frame && !frame->GetOverflowRect().Contains(GetCaretRect()))
    1:     InvalidateRects(mCaretRect, GetHookRect(), frame);
    1: }
    1: 
    1: void nsCaret::UpdateCaretPosition()
    1: {
    1:   // We'll recalculate anyway if we're not drawn right now.
    1:   if (!mDrawn)
    1:     return;
    1: 
    1:   // A trick! Make the DrawCaret code recalculate the caret's current
    1:   // position.
    1:   mDrawn = PR_FALSE;
    1:   DrawCaret(PR_FALSE);
    1: }
    1: 
    1: void nsCaret::PaintCaret(nsDisplayListBuilder *aBuilder,
    1:                          nsIRenderingContext *aCtx,
15481:                          nsIFrame* aForFrame,
15481:                          const nsPoint &aOffset)
    1: {
    1:   NS_ASSERTION(mDrawn, "The caret shouldn't be drawing");
    1: 
15481:   const nsRect drawCaretRect = mCaretRect + aOffset;
15481:   nscolor cssColor = aForFrame->GetStyleColor()->mColor;
15481: 
15481:   // Only draw the native caret if the foreground color matches that of
15481:   // -moz-fieldtext (the color of the text in a textbox). If it doesn't match
15481:   // we are likely in contenteditable or a custom widget and we risk being hard to see
15481:   // against the background. In that case, fall back to the CSS color.
15481:   nsPresContext* presContext = aForFrame->PresContext();
15481: 
15481:   if (GetHookRect().IsEmpty() && presContext) {
15481:     nsITheme *theme = presContext->GetTheme();
15481:     if (theme && theme->ThemeSupportsWidget(presContext, aForFrame, NS_THEME_TEXTFIELD_CARET)) {
15481:       nsILookAndFeel* lookAndFeel = presContext->LookAndFeel();
15481:       nscolor fieldText;
15481:       if (NS_SUCCEEDED(lookAndFeel->GetColor(nsILookAndFeel::eColor__moz_fieldtext, fieldText)) &&
15481:           fieldText == cssColor) {
15481:         theme->DrawWidgetBackground(aCtx, aForFrame, NS_THEME_TEXTFIELD_CARET,
15481:                                     drawCaretRect, drawCaretRect);
15481:         return;
15481:       }
15481:     }
15481:   }
15481: 
15481:   aCtx->SetColor(cssColor);
15481:   aCtx->FillRect(drawCaretRect);
    1:   if (!GetHookRect().IsEmpty())
    1:     aCtx->FillRect(GetHookRect() + aOffset);
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: NS_IMETHODIMP nsCaret::NotifySelectionChanged(nsIDOMDocument *, nsISelection *aDomSel, PRInt16 aReason)
    1: {
    1:   if (aReason & nsISelectionListener::MOUSEUP_REASON)//this wont do
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsISelection> domSel(do_QueryReferent(mDomSelectionWeak));
    1: 
    1:   // The same caret is shared amongst the document and any text widgets it
    1:   // may contain. This means that the caret could get notifications from
    1:   // multiple selections.
    1:   //
    1:   // If this notification is for a selection that is not the one the
    1:   // the caret is currently interested in (mDomSelectionWeak), then there
    1:   // is nothing to do!
    1: 
    1:   if (domSel != aDomSel)
    1:     return NS_OK;
    1: 
    1:   if (mVisible)
    1:   {
    1:     // Stop the caret from blinking in its previous location.
    1:     StopBlinking();
    1: 
    1:     // Start the caret blinking in the new location.
    1:     StartBlinking();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: void nsCaret::KillTimer()
    1: {
    1:   if (mBlinkTimer)
    1:   {
    1:     mBlinkTimer->Cancel();
    1:   }
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: nsresult nsCaret::PrimeTimer()
    1: {
    1:   // set up the blink timer
    1:   if (!mReadOnly && mBlinkRate > 0)
    1:   {
    1:     if (!mBlinkTimer) {
    1:       nsresult  err;
    1:       mBlinkTimer = do_CreateInstance("@mozilla.org/timer;1", &err);    
    1:       if (NS_FAILED(err))
    1:         return err;
    1:     }    
    1: 
    1:     mBlinkTimer->InitWithFuncCallback(CaretBlinkCallback, this, mBlinkRate,
    1:                                       nsITimer::TYPE_REPEATING_SLACK);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
15969: void nsCaret::StartBlinking()
    1: {
    1:   if (mReadOnly) {
    1:     // Make sure the one draw command we use for a readonly caret isn't
    1:     // done until the selection is set
    1:     DrawCaretAfterBriefDelay();
15969:     return;
    1:   }
    1:   PrimeTimer();
    1: 
    1:   // If we are currently drawn, then the second call to DrawCaret below will
    1:   // actually erase the caret. That would cause the caret to spend an "off"
    1:   // cycle before it appears, which is not really what we want. This first
    1:   // call to DrawCaret makes sure that the first cycle after a call to
    1:   // StartBlinking is an "on" cycle.
    1:   if (mDrawn)
    1:     DrawCaret(PR_TRUE);
    1: 
    1:   DrawCaret(PR_TRUE);    // draw it right away
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
15969: void nsCaret::StopBlinking()
    1: {
    1:   if (mDrawn)     // erase the caret if necessary
    1:     DrawCaret(PR_TRUE);
    1: 
12305:   NS_ASSERTION(!mDrawn, "Caret still drawn after StopBlinking().");
    1:   KillTimer();
    1: }
    1: 
    1: PRBool
    1: nsCaret::DrawAtPositionWithHint(nsIDOMNode*             aNode,
    1:                                 PRInt32                 aOffset,
    1:                                 nsFrameSelection::HINT  aFrameHint,
    1:                                 PRUint8                 aBidiLevel,
    1:                                 PRBool                  aInvalidate)
    1: {
    1:   nsCOMPtr<nsIContent> contentNode = do_QueryInterface(aNode);
    1:   if (!contentNode)
    1:     return PR_FALSE;
    1: 
    1:   nsIFrame* theFrame = nsnull;
    1:   PRInt32   theFrameOffset = 0;
    1: 
    1:   nsresult rv = GetCaretFrameForNodeOffset(contentNode, aOffset, aFrameHint, aBidiLevel,
    1:                                            &theFrame, &theFrameOffset);
    1:   if (NS_FAILED(rv) || !theFrame)
    1:     return PR_FALSE;
    1: 
    1:   // now we have a frame, check whether it's appropriate to show the caret here
    1:   const nsStyleUserInterface* userinterface = theFrame->GetStyleUserInterface();
 4452:   if ((!mIgnoreUserModify &&
 4452:        userinterface->mUserModify == NS_STYLE_USER_MODIFY_READ_ONLY) ||
    1:       (userinterface->mUserInput == NS_STYLE_USER_INPUT_NONE) ||
    1:       (userinterface->mUserInput == NS_STYLE_USER_INPUT_DISABLED))
    1:   {
    1:     return PR_FALSE;
    1:   }  
    1: 
    1:   if (!mDrawn)
    1:   {
    1:     // save stuff so we can figure out what frame we're in later.
    1:     mLastContent = contentNode;
    1:     mLastContentOffset = aOffset;
    1:     mLastHint = aFrameHint;
    1:     mLastBidiLevel = aBidiLevel;
    1: 
    1:     // If there has been a reflow, set the caret Bidi level to the level of the current frame
    1:     if (aBidiLevel & BIDI_LEVEL_UNDEFINED) {
 8295:       nsCOMPtr<nsFrameSelection> frameSelection = GetFrameSelection();
    1:       if (!frameSelection)
 6770:         return PR_FALSE;
    1:       frameSelection->SetCaretBidiLevel(NS_GET_EMBEDDING_LEVEL(theFrame));
    1:     }
    1: 
    1:     // Only update the caret's rect when we're not currently drawn.
    1:     rv = UpdateCaretRects(theFrame, theFrameOffset);
    1:     if (NS_FAILED(rv))
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   if (aInvalidate)
    1:     InvalidateRects(mCaretRect, mHookRect, theFrame);
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
 7677: /**
 7677:  * Find the first frame in an in-order traversal of the frame subtree rooted
 7677:  * at aFrame which is either a text frame logically at the end of a line,
 7677:  * or which is aStopAtFrame. Return null if no such frame is found. We don't
 7677:  * descend into the children of non-eLineParticipant frames.
 7677:  */
 7677: static nsIFrame*
 7677: CheckForTrailingTextFrameRecursive(nsIFrame* aFrame, nsIFrame* aStopAtFrame)
 7677: {
 7677:   if (aFrame == aStopAtFrame ||
 7677:       ((aFrame->GetType() == nsGkAtoms::textFrame &&
 7677:        (static_cast<nsTextFrame*>(aFrame))->IsAtEndOfLine())))
 7677:     return aFrame;
 7677:   if (!aFrame->IsFrameOfType(nsIFrame::eLineParticipant))
 7677:     return nsnull;
 7677: 
 7677:   for (nsIFrame* f = aFrame->GetFirstChild(nsnull); f; f = f->GetNextSibling())
 7677:   {
 7677:     nsIFrame* r = CheckForTrailingTextFrameRecursive(f, aStopAtFrame);
 7677:     if (r)
 7677:       return r;
 7677:   }
 7677:   return nsnull;
 7677: }
 7677: 
 7696: static nsLineBox*
 7696: FindContainingLine(nsIFrame* aFrame)
 7696: {
 7696:   while (aFrame && aFrame->IsFrameOfType(nsIFrame::eLineParticipant))
 7696:   {
 7696:     nsIFrame* parent = aFrame->GetParent();
15909:     nsBlockFrame* blockParent = nsLayoutUtils::GetAsBlock(parent);
15909:     if (blockParent)
 7696:     {
12355:       PRBool isValid;
12355:       nsBlockInFlowLineIterator iter(blockParent, aFrame, &isValid);
12355:       return isValid ? iter.GetLine().get() : nsnull;
 7696:     }
 7696:     aFrame = parent;
 7696:   }
 7696:   return nsnull;
 7696: }
 7696: 
 7677: static void
 7677: AdjustCaretFrameForLineEnd(nsIFrame** aFrame, PRInt32* aOffset)
 7677: {
 7696:   nsLineBox* line = FindContainingLine(*aFrame);
 7696:   if (!line)
 7677:     return;
 7677:   PRInt32 count = line->GetChildCount();
 7677:   for (nsIFrame* f = line->mFirstChild; count > 0; --count, f = f->GetNextSibling())
 7677:   {
 7677:     nsIFrame* r = CheckForTrailingTextFrameRecursive(f, *aFrame);
 7677:     if (r == *aFrame)
 7677:       return;
 7677:     if (r)
 7677:     {
 7677:       *aFrame = r;
 7677:       NS_ASSERTION(r->GetType() == nsGkAtoms::textFrame, "Expected text frame");
 7677:       *aOffset = (static_cast<nsTextFrame*>(r))->GetContentEnd();
 7677:       return;
 7677:     }
 7677:   }
 7677: }
 7677: 
15969: nsresult 
    1: nsCaret::GetCaretFrameForNodeOffset(nsIContent*             aContentNode,
    1:                                     PRInt32                 aOffset,
    1:                                     nsFrameSelection::HINT aFrameHint,
    1:                                     PRUint8                 aBidiLevel,
    1:                                     nsIFrame**              aReturnFrame,
    1:                                     PRInt32*                aReturnOffset)
    1: {
    1: 
    1:   //get frame selection and find out what frame to use...
    1:   nsCOMPtr<nsIPresShell> presShell = do_QueryReferent(mPresShell);
    1:   if (!presShell)
    1:     return NS_ERROR_FAILURE;
    1: 
 8295:   nsCOMPtr<nsFrameSelection> frameSelection = GetFrameSelection();
    1:   if (!frameSelection)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIFrame* theFrame = nsnull;
    1:   PRInt32   theFrameOffset = 0;
    1: 
    1:   theFrame = frameSelection->GetFrameForNodeOffset(aContentNode, aOffset,
    1:                                                    aFrameHint, &theFrameOffset);
    1:   if (!theFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
 7677:   // if theFrame is after a text frame that's logically at the end of the line
 7677:   // (e.g. if theFrame is a <br> frame), then put the caret at the end of
 7677:   // that text frame instead. This way, the caret will be positioned as if
 7677:   // trailing whitespace was not trimmed.
 7677:   AdjustCaretFrameForLineEnd(&theFrame, &theFrameOffset);
 7677:   
    1:   // Mamdouh : modification of the caret to work at rtl and ltr with Bidi
    1:   //
    1:   // Direction Style from this->GetStyleData()
    1:   // now in (visibility->mDirection)
    1:   // ------------------
    1:   // NS_STYLE_DIRECTION_LTR : LTR or Default
    1:   // NS_STYLE_DIRECTION_RTL
    1:   // NS_STYLE_DIRECTION_INHERIT
22779:   if (mBidiUI)
    1:   {
    1:     // If there has been a reflow, take the caret Bidi level to be the level of the current frame
    1:     if (aBidiLevel & BIDI_LEVEL_UNDEFINED)
    1:       aBidiLevel = NS_GET_EMBEDDING_LEVEL(theFrame);
    1: 
    1:     PRInt32 start;
    1:     PRInt32 end;
    1:     nsIFrame* frameBefore;
    1:     nsIFrame* frameAfter;
    1:     PRUint8 levelBefore;     // Bidi level of the character before the caret
    1:     PRUint8 levelAfter;      // Bidi level of the character after the caret
    1: 
    1:     theFrame->GetOffsets(start, end);
    1:     if (start == 0 || end == 0 || start == theFrameOffset || end == theFrameOffset)
    1:     {
    1:       nsPrevNextBidiLevels levels = frameSelection->
    1:         GetPrevNextBidiLevels(aContentNode, aOffset, PR_FALSE);
    1:     
    1:       /* Boundary condition, we need to know the Bidi levels of the characters before and after the caret */
    1:       if (levels.mFrameBefore || levels.mFrameAfter)
    1:       {
    1:         frameBefore = levels.mFrameBefore;
    1:         frameAfter = levels.mFrameAfter;
    1:         levelBefore = levels.mLevelBefore;
    1:         levelAfter = levels.mLevelAfter;
    1: 
    1:         if ((levelBefore != levelAfter) || (aBidiLevel != levelBefore))
    1:         {
32531:           aBidiLevel = NS_MAX(aBidiLevel, NS_MIN(levelBefore, levelAfter));                                  // rule c3
32531:           aBidiLevel = NS_MIN(aBidiLevel, NS_MAX(levelBefore, levelAfter));                                  // rule c4
    1:           if (aBidiLevel == levelBefore                                                                      // rule c1
19264:               || (aBidiLevel > levelBefore && aBidiLevel < levelAfter && !((aBidiLevel ^ levelBefore) & 1))    // rule c5
19264:               || (aBidiLevel < levelBefore && aBidiLevel > levelAfter && !((aBidiLevel ^ levelBefore) & 1)))  // rule c9
    1:           {
    1:             if (theFrame != frameBefore)
    1:             {
    1:               if (frameBefore) // if there is a frameBefore, move into it
    1:               {
    1:                 theFrame = frameBefore;
    1:                 theFrame->GetOffsets(start, end);
    1:                 theFrameOffset = end;
    1:               }
    1:               else 
    1:               {
    1:                 // if there is no frameBefore, we must be at the beginning of the line
    1:                 // so we stay with the current frame.
    1:                 // Exception: when the first frame on the line has a different Bidi level from the paragraph level, there is no
    1:                 // real frame for the caret to be in. We have to find the visually first frame on the line.
    1:                 PRUint8 baseLevel = NS_GET_BASE_LEVEL(frameAfter);
    1:                 if (baseLevel != levelAfter)
    1:                 {
    1:                   nsPeekOffsetStruct pos;
    1:                   pos.SetData(eSelectBeginLine, eDirPrevious, 0, 0, PR_FALSE, PR_TRUE, PR_FALSE, PR_TRUE);
    1:                   if (NS_SUCCEEDED(frameAfter->PeekOffset(&pos))) {
    1:                     theFrame = pos.mResultFrame;
    1:                     theFrameOffset = pos.mContentOffset;
    1:                   }
    1:                 }
    1:               }
    1:             }
    1:           }
    1:           else if (aBidiLevel == levelAfter                                                                     // rule c2
19264:                    || (aBidiLevel > levelBefore && aBidiLevel < levelAfter && !((aBidiLevel ^ levelAfter) & 1))   // rule c6
19264:                    || (aBidiLevel < levelBefore && aBidiLevel > levelAfter && !((aBidiLevel ^ levelAfter) & 1)))  // rule c10
    1:           {
    1:             if (theFrame != frameAfter)
    1:             {
    1:               if (frameAfter)
    1:               {
    1:                 // if there is a frameAfter, move into it
    1:                 theFrame = frameAfter;
    1:                 theFrame->GetOffsets(start, end);
    1:                 theFrameOffset = start;
    1:               }
    1:               else 
    1:               {
    1:                 // if there is no frameAfter, we must be at the end of the line
    1:                 // so we stay with the current frame.
    1:                 // Exception: when the last frame on the line has a different Bidi level from the paragraph level, there is no
    1:                 // real frame for the caret to be in. We have to find the visually last frame on the line.
    1:                 PRUint8 baseLevel = NS_GET_BASE_LEVEL(frameBefore);
    1:                 if (baseLevel != levelBefore)
    1:                 {
    1:                   nsPeekOffsetStruct pos;
    1:                   pos.SetData(eSelectEndLine, eDirNext, 0, 0, PR_FALSE, PR_TRUE, PR_FALSE, PR_TRUE);
    1:                   if (NS_SUCCEEDED(frameBefore->PeekOffset(&pos))) {
    1:                     theFrame = pos.mResultFrame;
    1:                     theFrameOffset = pos.mContentOffset;
    1:                   }
    1:                 }
    1:               }
    1:             }
    1:           }
    1:           else if (aBidiLevel > levelBefore && aBidiLevel < levelAfter  // rule c7/8
    1:                    && !((levelBefore ^ levelAfter) & 1)                 // before and after have the same parity
    1:                    && ((aBidiLevel ^ levelAfter) & 1))                  // caret has different parity
    1:           {
    1:             if (NS_SUCCEEDED(frameSelection->GetFrameFromLevel(frameAfter, eDirNext, aBidiLevel, &theFrame)))
    1:             {
    1:               theFrame->GetOffsets(start, end);
    1:               levelAfter = NS_GET_EMBEDDING_LEVEL(theFrame);
    1:               if (aBidiLevel & 1) // c8: caret to the right of the rightmost character
    1:                 theFrameOffset = (levelAfter & 1) ? start : end;
    1:               else               // c7: caret to the left of the leftmost character
    1:                 theFrameOffset = (levelAfter & 1) ? end : start;
    1:             }
    1:           }
    1:           else if (aBidiLevel < levelBefore && aBidiLevel > levelAfter  // rule c11/12
    1:                    && !((levelBefore ^ levelAfter) & 1)                 // before and after have the same parity
    1:                    && ((aBidiLevel ^ levelAfter) & 1))                  // caret has different parity
    1:           {
    1:             if (NS_SUCCEEDED(frameSelection->GetFrameFromLevel(frameBefore, eDirPrevious, aBidiLevel, &theFrame)))
    1:             {
    1:               theFrame->GetOffsets(start, end);
    1:               levelBefore = NS_GET_EMBEDDING_LEVEL(theFrame);
    1:               if (aBidiLevel & 1) // c12: caret to the left of the leftmost character
    1:                 theFrameOffset = (levelBefore & 1) ? end : start;
    1:               else               // c11: caret to the right of the rightmost character
    1:                 theFrameOffset = (levelBefore & 1) ? start : end;
    1:             }
    1:           }   
    1:         }
    1:       }
    1:     }
    1:   }
    1:   *aReturnFrame = theFrame;
    1:   *aReturnOffset = theFrameOffset;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: void nsCaret::GetViewForRendering(nsIFrame *caretFrame,
    1:                                   EViewCoordinates coordType,
    1:                                   nsPoint &viewOffset,
    1:                                   nsIView **outRenderingView,
    1:                                   nsIView **outRelativeView)
    1: {
    1:   if (!caretFrame || !outRenderingView)
    1:     return;
    1: 
    1:   *outRenderingView = nsnull;
    1:   if (outRelativeView)
    1:     *outRelativeView = nsnull;
    1:   
    1:   NS_ASSERTION(caretFrame, "Should have a frame here");
    1:  
    1:   viewOffset.x = 0;
    1:   viewOffset.y = 0;
    1:   
    1:   nsPoint withinViewOffset(0, 0);
    1:   // get the offset of this frame from its parent view (walks up frame hierarchy)
    1:   nsIView* theView = nsnull;
    1:   caretFrame->GetOffsetFromView(withinViewOffset, &theView);
    1:   if (!theView)
    1:       return;
    1: 
    1:   if (outRelativeView && coordType == eClosestViewCoordinates)
    1:     *outRelativeView = theView;
    1: 
    1:   // Note: views are not refcounted.
    1:   nsIView* returnView = nsIView::GetViewFor(theView->GetNearestWidget(nsnull));
    1:   
    1:   // This gets uses the first view with a widget
    1:   if (coordType == eRenderingViewCoordinates) {
    1:     if (returnView) {
    1:       // Now adjust the view offset for this view.
    1:       withinViewOffset += theView->GetOffsetTo(returnView);
    1:       
    1:       // Account for the view's origin not lining up with the widget's
    1:       // (bug 190290)
    1:       withinViewOffset += returnView->GetPosition() -
    1:                           returnView->GetBounds().TopLeft();
    1:       viewOffset = withinViewOffset;
    1: 
    1:       if (outRelativeView)
    1:         *outRelativeView = returnView;
    1:     }
    1:   }
    1:   else {
    1:     // window-relative coordinates. Done for us by the view.
    1:     withinViewOffset += theView->GetOffsetTo(nsnull);
    1:     viewOffset = withinViewOffset;
    1: 
    1:     // Get the relative view for top level window coordinates
    1:     if (outRelativeView && coordType == eTopLevelWindowCoordinates) {
    1:       nsCOMPtr<nsIPresShell> presShell = do_QueryReferent(mPresShell);
    1:       if (presShell) {
37502:         nsRootPresContext* rootPC =
37502:           presShell->GetPresContext()->GetRootPresContext();
37502:         if (rootPC) {
37502:           nsIViewManager* vm = rootPC->PresShell()->GetViewManager();
    1:           if (vm) {
    1:             vm->GetRootView(*outRelativeView);
    1:           }
    1:         }
    1:       }
    1:     }
37502:   }
    1: 
    1:   *outRenderingView = returnView;
    1: }
    1: 
13787: nsresult nsCaret::CheckCaretDrawingState()
13787: {
33905:   if (mDrawn) {
33905:     // The caret is drawn; if it shouldn't be, erase it.
33905:     if (!mVisible || !MustDrawCaret(PR_TRUE))
13787:       EraseCaret();
33905:   }
33905:   else
33905:   {
33905:     // The caret is not drawn; if it should be, draw it.
33905:     if (mPendingDraw && (mVisible && MustDrawCaret(PR_TRUE)))
33905:       DrawCaret(PR_TRUE);
33905:   }
13787:   return NS_OK;
13787: }
    1: 
    1: /*-----------------------------------------------------------------------------
    1: 
    1:   MustDrawCaret
    1:   
13787:   Find out if we need to do any caret drawing. This returns true if
13787:   either:
13787:   a) The caret has been drawn, and we need to erase it.
13787:   b) The caret is not drawn, and the selection is collapsed.
13787:   c) The caret is not hidden due to open XUL popups
13787:      (see IsMenuPopupHidingCaret()).
    1:   
    1: ----------------------------------------------------------------------------- */
13787: PRBool nsCaret::MustDrawCaret(PRBool aIgnoreDrawnState)
    1: {
13787:   if (!aIgnoreDrawnState && mDrawn)
    1:     return PR_TRUE;
    1: 
    1:   nsCOMPtr<nsISelection> domSelection = do_QueryReferent(mDomSelectionWeak);
    1:   if (!domSelection)
    1:     return PR_FALSE;
33905: 
    1:   PRBool isCollapsed;
    1:   if (NS_FAILED(domSelection->GetIsCollapsed(&isCollapsed)))
    1:     return PR_FALSE;
    1: 
    1:   if (mShowDuringSelection)
    1:     return PR_TRUE;      // show the caret even in selections
    1: 
13787:   if (IsMenuPopupHidingCaret())
13787:     return PR_FALSE;
13787: 
    1:   return isCollapsed;
    1: }
    1: 
13787: PRBool nsCaret::IsMenuPopupHidingCaret()
13787: {
18969: #ifdef MOZ_XUL
13787:   // Check if there are open popups.
13787:   nsXULPopupManager *popMgr = nsXULPopupManager::GetInstance();
25413:   nsTArray<nsIFrame*> popups = popMgr->GetVisiblePopups();
13787: 
13787:   if (popups.Length() == 0)
13787:     return PR_FALSE; // No popups, so caret can't be hidden by them.
13787: 
13787:   // Get the selection focus content, that's where the caret would 
13787:   // go if it was drawn.
13787:   nsCOMPtr<nsIDOMNode> node;
13787:   nsCOMPtr<nsISelection> domSelection = do_QueryReferent(mDomSelectionWeak);
13787:   if (!domSelection)
13787:     return PR_TRUE; // No selection/caret to draw.
13787:   domSelection->GetFocusNode(getter_AddRefs(node));
13787:   if (!node)
13787:     return PR_TRUE; // No selection/caret to draw.
13787:   nsCOMPtr<nsIContent> caretContent = do_QueryInterface(node);
14120:   if (!caretContent)
14120:     return PR_TRUE; // No selection/caret to draw.
13787: 
13787:   // If there's a menu popup open before the popup with
13787:   // the caret, don't show the caret.
13787:   for (PRUint32 i=0; i<popups.Length(); i++) {
13787:     nsMenuPopupFrame* popupFrame = static_cast<nsMenuPopupFrame*>(popups[i]);
13787:     nsIContent* popupContent = popupFrame->GetContent();
13787: 
13787:     if (nsContentUtils::ContentIsDescendantOf(caretContent, popupContent)) {
13787:       // The caret is in this popup. There were no menu popups before this
13787:       // popup, so don't hide the caret.
13787:       return PR_FALSE;
13787:     }
13787: 
14808:     if (popupFrame->PopupType() == ePopupTypeMenu && !popupFrame->IsContextMenu()) {
13787:       // This is an open menu popup. It does not contain the caret (else we'd
13787:       // have returned above). Even if the caret is in a subsequent popup,
13787:       // or another document/frame, it should be hidden.
13787:       return PR_TRUE;
13787:     }
13787:   }
18969: #endif
13787: 
13787:   // There are no open menu popups, no need to hide the caret.
13787:   return PR_FALSE;
13787: }
    1: 
    1: void nsCaret::DrawCaret(PRBool aInvalidate)
    1: {
33905:   // Do we need to draw the caret at all?
13787:   if (!MustDrawCaret(PR_FALSE))
    1:     return;
    1:   
33905:   // Can we draw the caret now?
33905:   nsCOMPtr<nsIPresShell> presShell = do_QueryReferent(mPresShell);
33905:   NS_ENSURE_TRUE(presShell, /**/);
33905:   {
33905:     PRBool isPaintingSuppressed;
33905:     presShell->IsPaintingSuppressed(&isPaintingSuppressed);
33905:     if (isPaintingSuppressed)
33905:     {
33905:       if (!mDrawn)
33905:         mPendingDraw = PR_TRUE;
33905: 
33905:       // PresShell::UnsuppressAndInvalidate() will call CheckCaretDrawingState()
33905:       // to get us drawn.
33905:       return;
33905:     }
33905:   }
33905: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   PRInt32 offset;
    1:   nsFrameSelection::HINT hint;
    1:   PRUint8 bidiLevel;
    1: 
    1:   if (!mDrawn)
    1:   {
    1:     nsCOMPtr<nsISelection> domSelection = do_QueryReferent(mDomSelectionWeak);
    1:     nsCOMPtr<nsISelectionPrivate> privateSelection(do_QueryInterface(domSelection));
    1:     if (!privateSelection) return;
    1:     
    1:     PRBool isCollapsed = PR_FALSE;
    1:     domSelection->GetIsCollapsed(&isCollapsed);
    1:     if (!mShowDuringSelection && !isCollapsed)
    1:       return;
    1: 
    1:     PRBool hintRight;
    1:     privateSelection->GetInterlinePosition(&hintRight);//translate hint.
    1:     hint = hintRight ? nsFrameSelection::HINTRIGHT : nsFrameSelection::HINTLEFT;
    1: 
    1:     // get the node and offset, which is where we want the caret to draw
    1:     domSelection->GetFocusNode(getter_AddRefs(node));
    1:     if (!node)
    1:       return;
    1:     
    1:     if (NS_FAILED(domSelection->GetFocusOffset(&offset)))
    1:       return;
    1: 
 8295:     nsCOMPtr<nsFrameSelection> frameSelection = GetFrameSelection();
    1:     if (!frameSelection)
    1:       return;
33905: 
    1:     bidiLevel = frameSelection->GetCaretBidiLevel();
33905:     mPendingDraw = PR_FALSE;
    1:   }
    1:   else
    1:   {
    1:     if (!mLastContent)
    1:     {
    1:       mDrawn = PR_FALSE;
    1:       return;
    1:     }
    1:     if (!mLastContent->IsInDoc())
    1:     {
    1:       mLastContent = nsnull;
    1:       mDrawn = PR_FALSE;
    1:       return;
    1:     }
    1:     node = do_QueryInterface(mLastContent);
    1:     offset = mLastContentOffset;
    1:     hint = mLastHint;
    1:     bidiLevel = mLastBidiLevel;
    1:   }
    1: 
    1:   DrawAtPositionWithHint(node, offset, hint, bidiLevel, aInvalidate);
    1:   ToggleDrawnStatus();
    1: }
    1: 
33278: static PRBool
33278: FramesOnSameLineHaveZeroHeight(nsIFrame* aFrame)
33278: {
33278:   nsLineBox* line = FindContainingLine(aFrame);
33278:   if (!line)
33278:     return aFrame->GetRect().height == 0;
33278:   PRInt32 count = line->GetChildCount();
33278:   for (nsIFrame* f = line->mFirstChild; count > 0; --count, f = f->GetNextSibling())
33278:   {
33278:    if (f->GetRect().height != 0)
33278:      return PR_FALSE;
33278:   }
33278:   return PR_TRUE;
33278: }
33278: 
    1: nsresult nsCaret::UpdateCaretRects(nsIFrame* aFrame, PRInt32 aFrameOffset)
    1: {
    1:   NS_ASSERTION(aFrame, "Should have a frame here");
    1: 
    1:   nsRect frameRect = aFrame->GetRect();
    1:   frameRect.x = 0;
    1:   frameRect.y = 0;
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell = do_QueryReferent(mPresShell);
    1:   if (!presShell) return NS_ERROR_FAILURE;
    1: 
29421:   // If we got a zero-height frame we should figure out a height. We have to do
29421:   // this after we've got an RC.
    1:   if (frameRect.height == 0)
    1:   {
 4353:     nsCOMPtr<nsIFontMetrics> fm;
 4353:     nsLayoutUtils::GetFontMetricsForFrame(aFrame, getter_AddRefs(fm));
    1: 
    1:     if (fm)
    1:     {
    1:       nscoord ascent, descent;
    1:       fm->GetMaxAscent(ascent);
    1:       fm->GetMaxDescent(descent);
    1:       frameRect.height = ascent + descent;
29421: 
33278:       // Place the caret on the baseline for inline frames, except when there is
33278:       // a frame on the line with non-zero height.  XXXmats why the exception? --
33278:       // I don't know but it seems to be necessary, see bug 503531.
33278:       if (aFrame->GetStyleDisplay()->IsInlineOutside() &&
33278:           !FramesOnSameLineHaveZeroHeight(aFrame))
29421:         frameRect.y -= ascent;
    1:     }
    1:   }
    1: 
    1:   mCaretRect = frameRect;
    1:   nsCOMPtr<nsISelection> domSelection = do_QueryReferent(mDomSelectionWeak);
    1:   nsCOMPtr<nsISelectionPrivate> privateSelection = do_QueryInterface(domSelection);
    1: 
    1:   nsPoint framePos;
    1: 
    1:   // if cache in selection is available, apply it, else refresh it
    1:   nsresult rv = privateSelection->GetCachedFrameOffset(aFrame, aFrameOffset,
    1:                                                        framePos);
    1:   if (NS_FAILED(rv))
    1:   {
    1:     mCaretRect.Empty();
    1:     return rv;
    1:   }
    1: 
    1:   mCaretRect += framePos;
15481:   Metrics metrics = ComputeMetrics(aFrame, aFrameOffset, mCaretRect.height);
14311:   mCaretRect.width = metrics.mCaretWidth;
    1: 
 4578:   // Clamp our position to be within our scroll frame. If we don't, then it
 4578:   // clips us, and we don't appear at all. See bug 335560.
 4578:   nsIFrame *scrollFrame =
 4578:     nsLayoutUtils::GetClosestFrameOfType(aFrame, nsGkAtoms::scrollFrame);
 4578:   if (scrollFrame)
 4578:   {
 4578:     // First, use the scrollFrame to get at the scrollable view that we're in.
37072:     nsIScrollableFrame *sf = do_QueryFrame(scrollFrame);
37072:     nsIFrame *scrolled = sf->GetScrolledFrame();
37072:     nsRect caretInScroll = mCaretRect + aFrame->GetOffsetTo(scrolled);
 4578: 
 4578:     // Now see if thet caret extends beyond the view's bounds. If it does,
 4578:     // then snap it back, put it as close to the edge as it can.
37072:     nscoord overflow = caretInScroll.XMost() -
37072:       scrolled->GetOverflowRectRelativeToSelf().width;
 4578:     if (overflow > 0)
 4578:       mCaretRect.x -= overflow;
 4578:   }
 4578: 
    1:   // on RTL frames the right edge of mCaretRect must be equal to framePos
    1:   const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
    1:   if (NS_STYLE_DIRECTION_RTL == vis->mDirection)
    1:     mCaretRect.x -= mCaretRect.width;
    1: 
33278:   return UpdateHookRect(presShell->GetPresContext(), metrics);
    1: }
    1: 
14311: nsresult nsCaret::UpdateHookRect(nsPresContext* aPresContext,
14311:                                  const Metrics& aMetrics)
    1: {
    1:   mHookRect.Empty();
    1: 
    1: #ifdef IBMBIDI
    1:   // Simon -- make a hook to draw to the left or right of the caret to show keyboard language direction
    1:   PRBool isCaretRTL=PR_FALSE;
    1:   nsIBidiKeyboard* bidiKeyboard = nsContentUtils::GetBidiKeyboard();
    1:   if (!bidiKeyboard || NS_FAILED(bidiKeyboard->IsLangRTL(&isCaretRTL)))
    1:     // if bidiKeyboard->IsLangRTL() failed, there is no way to tell the
    1:     // keyboard direction, or the user has no right-to-left keyboard
    1:     // installed, so we  never draw the hook.
    1:     return NS_OK;
22779:   if (mBidiUI)
    1:   {
    1:     if (isCaretRTL != mKeyboardRTL)
    1:     {
    1:       /* if the caret bidi level and the keyboard language direction are not in
    1:        * synch, the keyboard language must have been changed by the
    1:        * user, and if the caret is in a boundary condition (between left-to-right and
    1:        * right-to-left characters) it may have to change position to
    1:        * reflect the location in which the next character typed will
    1:        * appear. We will call |SelectionLanguageChange| and exit
    1:        * without drawing the caret in the old position.
    1:        */ 
    1:       mKeyboardRTL = isCaretRTL;
    1:       nsCOMPtr<nsISelection> domSelection = do_QueryReferent(mDomSelectionWeak);
    1:       if (domSelection)
    1:       {
    1:         if (NS_SUCCEEDED(domSelection->SelectionLanguageChange(mKeyboardRTL)))
    1:         {
    1:           return NS_ERROR_FAILURE;
    1:         }
    1:       }
    1:     }
    1:     // If keyboard language is RTL, draw the hook on the left; if LTR, to the right
    1:     // The height of the hook rectangle is the same as the width of the caret
    1:     // rectangle.
14311:     nscoord bidiIndicatorSize = aMetrics.mBidiIndicatorSize;
    1:     mHookRect.SetRect(mCaretRect.x + ((isCaretRTL) ?
14311:                       bidiIndicatorSize * -1 :
    1:                       mCaretRect.width),
14311:                       mCaretRect.y + bidiIndicatorSize,
14311:                       bidiIndicatorSize,
    1:                       mCaretRect.width);
    1:   }
    1: #endif //IBMBIDI
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // static
    1: void nsCaret::InvalidateRects(const nsRect &aRect, const nsRect &aHook,
    1:                               nsIFrame *aFrame)
    1: {
    1:   NS_ASSERTION(aFrame, "Must have a frame to invalidate");
    1:   nsRect rect;
    1:   rect.UnionRect(aRect, aHook);
19380:   aFrame->Invalidate(rect);
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: /* static */
    1: void nsCaret::CaretBlinkCallback(nsITimer *aTimer, void *aClosure)
    1: {
 3233:   nsCaret   *theCaret = reinterpret_cast<nsCaret*>(aClosure);
    1:   if (!theCaret) return;
    1:   
    1:   theCaret->DrawCaret(PR_TRUE);
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
 8295: already_AddRefed<nsFrameSelection>
 8295: nsCaret::GetFrameSelection()
 8295: {
    1:   nsCOMPtr<nsISelectionPrivate> privateSelection(do_QueryReferent(mDomSelectionWeak));
    1:   if (!privateSelection)
    1:     return nsnull;
 8295:   nsFrameSelection* frameSelection = nsnull;
 8295:   privateSelection->GetFrameSelection(&frameSelection);
    1:   return frameSelection;
    1: }
    1: 
 4452: void
 4452: nsCaret::SetIgnoreUserModify(PRBool aIgnoreUserModify)
 4452: {
12305:   if (!aIgnoreUserModify && mIgnoreUserModify && mDrawn) {
12305:     // We're turning off mIgnoreUserModify. If the caret's drawn
12305:     // in a read-only node we must erase it, else the next call
12305:     // to DrawCaret() won't erase the old caret, due to the new
12305:     // mIgnoreUserModify value.
12305:     nsIFrame *frame = GetCaretFrame();
12305:     if (frame) {
12305:       const nsStyleUserInterface* userinterface = frame->GetStyleUserInterface();
12305:       if (userinterface->mUserModify == NS_STYLE_USER_MODIFY_READ_ONLY) {
12305:         StopBlinking();
12305:       }
12305:     }
12305:   }
 4452:   mIgnoreUserModify = aIgnoreUserModify;
 4452: }
    1: 
    1: //-----------------------------------------------------------------------------
15969: nsresult NS_NewCaret(nsCaret** aInstancePtrResult)
    1: {
    1:   NS_PRECONDITION(aInstancePtrResult, "null ptr");
    1:   
    1:   nsCaret* caret = new nsCaret();
    1:   if (nsnull == caret)
    1:       return NS_ERROR_OUT_OF_MEMORY;
15969:   NS_ADDREF(caret);
15969:   *aInstancePtrResult = caret;
15969:   return NS_OK;
    1: }
    1: 
