    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:set et cin sw=2 sts=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla <object> loading code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Christian Biesinger <cbiesinger@web.de>.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
 3642:  * A base class implementing nsIObjectLoadingContent for use by
    1:  * various content nodes that want to provide plugin/document/image
    1:  * loading functionality (eg <embed>, <object>, <applet>, etc).
    1:  */
    1: 
    1: // Interface headers
    1: #include "imgILoader.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocument.h"
    1: #include "nsIExternalProtocolHandler.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIObjectFrame.h"
    1: #include "nsIPluginDocument.h"
    1: #include "nsIPluginHost.h"
29840: #include "nsIPluginInstance.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIStreamConverterService.h"
    1: #include "nsIURILoader.h"
    1: #include "nsIURL.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIWebNavigationInfo.h"
 8608: #include "nsIScriptChannel.h"
33384: #include "nsIBlocklistService.h"
    1: 
    1: #include "nsPluginError.h"
    1: 
    1: // Util headers
    1: #include "prlog.h"
    1: 
    1: #include "nsAutoPtr.h"
    1: #include "nsCURILoader.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDocShellCID.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsNetUtil.h"
 1722: #include "nsPresShellIterator.h"
 4849: #include "nsMimeTypes.h"
13583: #include "nsStyleUtil.h"
    1: 
    1: // Concrete classes
    1: #include "nsFrameLoader.h"
    1: 
    1: #include "nsObjectLoadingContent.h"
14228: #include "mozAutoDocUpdate.h"
    1: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo* gObjectLog = PR_NewLogModule("objlc");
    1: #endif
    1: 
    1: #define LOG(args) PR_LOG(gObjectLog, PR_LOG_DEBUG, args)
    1: #define LOG_ENABLED() PR_LOG_TEST(gObjectLog, PR_LOG_DEBUG)
    1: 
    1: class nsAsyncInstantiateEvent : public nsRunnable {
    1: public:
    1:   // This stores both the content and the frame so that Instantiate calls can be
    1:   // avoided if the frame changed in the meantime.
    1:   nsObjectLoadingContent *mContent;
22223:   nsWeakFrame             mFrame;
    1:   nsCString               mContentType;
    1:   nsCOMPtr<nsIURI>        mURI;
    1: 
    1:   nsAsyncInstantiateEvent(nsObjectLoadingContent* aContent,
22223:                           nsIFrame* aFrame,
    1:                           const nsCString& aType,
    1:                           nsIURI* aURI)
    1:     : mContent(aContent), mFrame(aFrame), mContentType(aType), mURI(aURI)
    1:   {
 3233:     static_cast<nsIObjectLoadingContent *>(mContent)->AddRef();
    1:   }
    1: 
    1:   ~nsAsyncInstantiateEvent()
    1:   {
 3233:     static_cast<nsIObjectLoadingContent *>(mContent)->Release();
    1:   }
    1: 
    1:   NS_IMETHOD Run();
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsAsyncInstantiateEvent::Run()
    1: {
    1:   // Check if we've been "revoked"
    1:   if (mContent->mPendingInstantiateEvent != this)
    1:     return NS_OK;
    1:   mContent->mPendingInstantiateEvent = nsnull;
    1: 
    1:   // Make sure that we still have the right frame (NOTE: we don't need to check
13098:   // the type here - GetExistingFrame() only returns object frames, and that
13098:   // means we're a plugin)
    1:   // Also make sure that we still refer to the same data.
13098:   nsIObjectFrame* frame = mContent->
13098:     GetExistingFrame(nsObjectLoadingContent::eFlushContent);
27827: 
27827:   nsIFrame* objectFrame = nsnull;
27827:   if (frame) {
27827:     objectFrame = do_QueryFrame(frame);
27079:   }
27827: 
27827:   if (objectFrame &&
27827:       mFrame.GetFrame() == objectFrame &&
    1:       mContent->mURI == mURI &&
    1:       mContent->mContentType.Equals(mContentType)) {
    1:     if (LOG_ENABLED()) {
    1:       nsCAutoString spec;
    1:       if (mURI) {
    1:         mURI->GetSpec(spec);
    1:       }
    1:       LOG(("OBJLC [%p]: Handling Instantiate event: Type=<%s> URI=%p<%s>\n",
    1:            mContent, mContentType.get(), mURI.get(), spec.get()));
    1:     }
    1: 
 4329:     nsresult rv = mContent->Instantiate(frame, mContentType, mURI);
    1:     if (NS_FAILED(rv)) {
    1:       mContent->Fallback(PR_TRUE);
    1:     }
    1:   } else {
    1:     LOG(("OBJLC [%p]: Discarding event, data changed\n", mContent));
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
 3464:  * A task for firing PluginNotFound and PluginBlocklisted DOM Events.
    1:  */
 3464: class nsPluginErrorEvent : public nsRunnable {
    1: public:
    1:   nsCOMPtr<nsIContent> mContent;
19014:   PluginSupportState mState;
    1: 
19014:   nsPluginErrorEvent(nsIContent* aContent, PluginSupportState aState)
 3464:     : mContent(aContent),
19014:       mState(aState)
    1:   {}
    1: 
 3464:   ~nsPluginErrorEvent() {}
    1: 
    1:   NS_IMETHOD Run();
    1: };
    1: 
    1: NS_IMETHODIMP
 3464: nsPluginErrorEvent::Run()
    1: {
    1:   LOG(("OBJLC []: Firing plugin not found event for content %p\n",
    1:        mContent.get()));
19014:   nsString type;
19014:   switch (mState) {
19014:     case ePluginUnsupported:
19014:       type = NS_LITERAL_STRING("PluginNotFound");
19014:       break;
19014:     case ePluginDisabled:
19014:       type = NS_LITERAL_STRING("PluginDisabled");
19014:       break;
19014:     case ePluginBlocklisted:
19014:       type = NS_LITERAL_STRING("PluginBlocklisted");
19014:       break;
33384:     case ePluginOutdated:
33384:       type = NS_LITERAL_STRING("PluginOutdated");
33384:       break;
19014:     default:
19014:       return NS_OK;
19014:   }
 3464:   nsContentUtils::DispatchTrustedEvent(mContent->GetDocument(), mContent,
19014:                                        type, PR_TRUE, PR_TRUE);
 3464: 
    1:   return NS_OK;
    1: }
    1: 
    1: class AutoNotifier {
    1:   public:
    1:     AutoNotifier(nsObjectLoadingContent* aContent, PRBool aNotify) :
    1:       mContent(aContent), mNotify(aNotify) {
    1:         mOldType = aContent->Type();
    1:         mOldState = aContent->ObjectState();
    1:     }
    1:     ~AutoNotifier() {
    1:       if (mNotify) {
    1:         mContent->NotifyStateChanged(mOldType, mOldState, PR_FALSE);
    1:       }
    1:     }
    1: 
    1:     /**
    1:      * Send notifications now, ignoring the value of mNotify. The new type and
    1:      * state is saved, and the destructor will notify again if mNotify is true
    1:      * and the values changed.
    1:      */
    1:     void Notify() {
    1:       NS_ASSERTION(mNotify, "Should not notify when notify=false");
    1: 
    1:       mContent->NotifyStateChanged(mOldType, mOldState, PR_TRUE);
    1:       mOldType = mContent->Type();
    1:       mOldState = mContent->ObjectState();
    1:     }
    1: 
    1:   private:
    1:     nsObjectLoadingContent*            mContent;
    1:     PRBool                             mNotify;
    1:     nsObjectLoadingContent::ObjectType mOldType;
    1:     PRInt32                            mOldState;
    1: };
    1: 
    1: /**
    1:  * A class that will automatically fall back if a |rv| variable has a failure
    1:  * code when this class is destroyed. It does not notify.
    1:  */
    1: class AutoFallback {
    1:   public:
    1:     AutoFallback(nsObjectLoadingContent* aContent, const nsresult* rv)
19014:       : mContent(aContent), mResult(rv), mPluginState(ePluginOtherState) {}
    1:     ~AutoFallback() {
    1:       if (NS_FAILED(*mResult)) {
    1:         LOG(("OBJLC [%p]: rv=%08x, falling back\n", mContent, *mResult));
    1:         mContent->Fallback(PR_FALSE);
19014:         if (mPluginState != ePluginOtherState) {
19014:           mContent->mPluginState = mPluginState;
    1:         }
    1:       }
    1:     }
    1: 
    1:     /**
19014:      * This should be set to something other than ePluginOtherState to indicate
19014:      * a specific failure that should be passed on.
    1:      */
19014:      void SetPluginState(PluginSupportState aState) {
19014:        NS_ASSERTION(aState != ePluginOtherState, "Should not be setting ePluginOtherState");
19014:        mPluginState = aState;
    1:      }
    1:   private:
    1:     nsObjectLoadingContent* mContent;
    1:     const nsresult* mResult;
19014:     PluginSupportState mPluginState;
    1: };
    1: 
    1: /**
    1:  * A class that automatically sets mInstantiating to false when it goes
    1:  * out of scope.
    1:  */
    1: class AutoSetInstantiatingToFalse {
    1:   public:
    1:     AutoSetInstantiatingToFalse(nsObjectLoadingContent* objlc) : mContent(objlc) {}
    1:     ~AutoSetInstantiatingToFalse() { mContent->mInstantiating = PR_FALSE; }
    1:   private:
    1:     nsObjectLoadingContent* mContent;
    1: };
    1: 
    1: // helper functions
    1: static PRBool
    1: IsSupportedImage(const nsCString& aMimeType)
    1: {
    1:   imgILoader* loader = nsContentUtils::GetImgLoader();
    1:   if (!loader) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRBool supported;
    1:   nsresult rv = loader->SupportImageWithMimeType(aMimeType.get(), &supported);
    1:   return NS_SUCCEEDED(rv) && supported;
    1: }
    1: 
    1: static PRBool
    1: IsSupportedPlugin(const nsCString& aMIMEType)
    1: {
29574:   nsCOMPtr<nsIPluginHost> host(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
    1:   if (!host) {
    1:     return PR_FALSE;
    1:   }
    1:   nsresult rv = host->IsPluginEnabledForType(aMIMEType.get());
    1:   return NS_SUCCEEDED(rv);
    1: }
    1: 
 3642: static void
 3642: GetExtensionFromURI(nsIURI* uri, nsCString& ext)
 3642: {
 3642:   nsCOMPtr<nsIURL> url(do_QueryInterface(uri));
 3642:   if (url) {
 3642:     url->GetFileExtension(ext);
 3642:   } else {
 3642:     nsCString spec;
 3642:     uri->GetSpec(spec);
 3642: 
 3642:     PRInt32 offset = spec.RFindChar('.');
 3642:     if (offset != kNotFound) {
 3642:       ext = Substring(spec, offset + 1, spec.Length());
 3642:     }
 3642:   }
 3642: }
 3642: 
 3642: /**
 3642:  * Checks whether a plugin exists and is enabled for the extension
 3642:  * in the given URI. The MIME type is returned in the mimeType out parameter.
 3642:  */
 3642: static PRBool
 3642: IsPluginEnabledByExtension(nsIURI* uri, nsCString& mimeType)
 3642: {
 3642:   nsCAutoString ext;
 3642:   GetExtensionFromURI(uri, ext);
 3642: 
 4315:   if (ext.IsEmpty())
 4315:     return PR_FALSE;
 4315: 
29574:   nsCOMPtr<nsIPluginHost> host(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
 3642:   const char* typeFromExt;
 3642:   if (host &&
 3642:       NS_SUCCEEDED(host->IsPluginEnabledForExtension(ext.get(), typeFromExt))) {
 3642:     mimeType = typeFromExt;
 3642:     return PR_TRUE;
 3642:   }
 3642:   return PR_FALSE;
 3642: }
 3642: 
    1: nsObjectLoadingContent::nsObjectLoadingContent()
 3176:   : mPendingInstantiateEvent(nsnull)
 3176:   , mChannel(nsnull)
    1:   , mType(eType_Loading)
    1:   , mInstantiating(PR_FALSE)
    1:   , mUserDisabled(PR_FALSE)
    1:   , mSuppressed(PR_FALSE)
19014:   , mPluginState(ePluginOtherState)
    1: {
    1: }
    1: 
    1: nsObjectLoadingContent::~nsObjectLoadingContent()
    1: {
    1:   DestroyImageLoadingContent();
    1:   if (mFrameLoader) {
    1:     mFrameLoader->Destroy();
    1:   }
    1: }
    1: 
    1: // nsIRequestObserver
    1: NS_IMETHODIMP
13648: nsObjectLoadingContent::OnStartRequest(nsIRequest *aRequest,
13648:                                        nsISupports *aContext)
    1: {
    1:   if (aRequest != mChannel) {
    1:     // This is a bit of an edge case - happens when a new load starts before the
    1:     // previous one got here
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
12968:   // We're done with the classifier
12968:   mClassifier = nsnull;
12968: 
    1:   AutoNotifier notifier(this, PR_TRUE);
    1: 
    1:   if (!IsSuccessfulRequest(aRequest)) {
    1:     LOG(("OBJLC [%p]: OnStartRequest: Request failed\n", this));
    1:     Fallback(PR_FALSE);
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
    1:   NS_ASSERTION(chan, "Why is our request not a channel?");
    1: 
    1:   nsresult rv = NS_ERROR_UNEXPECTED;
    1:   // This fallback variable MUST be declared after the notifier variable. Do NOT
    1:   // change the order of the declarations!
    1:   AutoFallback fallback(this, &rv);
    1: 
 4849:   nsCString channelType;
 4849:   rv = chan->GetContentType(channelType);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 4849:   if (channelType.EqualsASCII(APPLICATION_GUESS_FROM_EXT)) {
 4849:     channelType = APPLICATION_OCTET_STREAM;
 4849:     chan->SetContentType(channelType);
 4849:   }
 4849: 
13204:   // We want to use the channel type unless one of the following is
13204:   // true:
13204:   //
13204:   // 1) The channel type is application/octet-stream and we have a
35425:   //    type hint and the type hint is not a document type.
13204:   // 2) Our type hint is a type that we support with a plugin.
13204: 
13204:   if ((channelType.EqualsASCII(APPLICATION_OCTET_STREAM) && 
35425:        !mContentType.IsEmpty() &&
35425:        GetTypeOfContent(mContentType) != eType_Document) ||
35425:       // Need to check IsSupportedPlugin() in addition to GetTypeOfContent()
35425:       // because otherwise the default plug-in's catch-all behavior would
35425:       // confuse things.
13204:       (IsSupportedPlugin(mContentType) && 
13204:        GetTypeOfContent(mContentType) == eType_Plugin)) {
 4849:     // Set the type we'll use for dispatch on the channel.  Otherwise we could
 4849:     // end up trying to dispatch to a nsFrameLoader, which will complain that
 4849:     // it couldn't find a way to handle application/octet-stream
13204: 
 4849:     chan->SetContentType(mContentType);
13204:   } else {
13204:     mContentType = channelType;
 4849:   }
 4849: 
13648:   nsCOMPtr<nsIURI> uri;
13648:   chan->GetURI(getter_AddRefs(uri));
13648: 
13648:   if (mContentType.EqualsASCII(APPLICATION_OCTET_STREAM)) {
13648:     nsCAutoString extType;
13648:     if (IsPluginEnabledByExtension(uri, extType)) {
13648:       mContentType = extType;
13648:       chan->SetContentType(extType);
13648:     }
13648:   }
13648: 
    1:   // Now find out what type the content is
    1:   // UnloadContent will set our type to null; need to be sure to only set it to
    1:   // the real value on success
    1:   ObjectType newType = GetTypeOfContent(mContentType);
    1:   LOG(("OBJLC [%p]: OnStartRequest: Content Type=<%s> Old type=%u New Type=%u\n",
    1:        this, mContentType.get(), mType, newType));
 5870: 
 5870:   // Now do a content policy check
 5870:   // XXXbz this duplicates some code in nsContentBlocker::ShouldLoad  
 5870:   PRInt32 contentPolicyType;
 5870:   switch (newType) {
 5870:     case eType_Image:
 5870:       contentPolicyType = nsIContentPolicy::TYPE_IMAGE;
 5870:       break;
 5870:     case eType_Document:
 5870:       contentPolicyType = nsIContentPolicy::TYPE_SUBDOCUMENT;
 5870:       break;
 5870:     default:
 5870:       contentPolicyType = nsIContentPolicy::TYPE_OBJECT;
 5870:       break;
 5870:   }
 5870:   nsCOMPtr<nsIContent> thisContent = 
 5870:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
 5870:   NS_ASSERTION(thisContent, "must be a content");
 5870: 
 5870:   nsIDocument* doc = thisContent->GetOwnerDoc();
 5870:   if (!doc) {
 5870:     Fallback(PR_FALSE);
 5870:     return NS_BINDING_ABORTED;    
 5870:   }
 5870: 
 5870:   PRInt16 shouldProcess = nsIContentPolicy::ACCEPT;
 5870:   rv =
 5870:     NS_CheckContentProcessPolicy(contentPolicyType,
 5870:                                  uri,
 5870:                                  doc->NodePrincipal(),
 5870:                                  static_cast<nsIImageLoadingContent*>(this),
 5870:                                  mContentType,
 5870:                                  nsnull, //extra
 5870:                                  &shouldProcess,
 5870:                                  nsContentUtils::GetContentPolicy(),
 5870:                                  nsContentUtils::GetSecurityManager());
 5870:   if (NS_FAILED(rv) || NS_CP_REJECTED(shouldProcess)) {
 5870:     HandleBeingBlockedByContentPolicy(rv, shouldProcess);
 5870:     rv = NS_OK; // otherwise, the AutoFallback will make us fall back
 5870:     return NS_BINDING_ABORTED;
 5870:   }  
 5870:   
    1:   if (mType != newType) {
    1:     UnloadContent();
    1:   }
    1: 
    1:   switch (newType) {
    1:     case eType_Image:
    1:       rv = LoadImageWithChannel(chan, getter_AddRefs(mFinalListener));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       // If we have a success result but no final listener, then the image is
    1:       // cached. In that case, we can just return: No need to try to call the
    1:       // final listener.
    1:       if (!mFinalListener) {
    1:         mType = newType;
    1:         return NS_BINDING_ABORTED;
    1:       }
    1:       break;
    1:     case eType_Document: {
    1:       if (!mFrameLoader) {
31661:         mFrameLoader = nsFrameLoader::Create(thisContent);
31661:         if (!mFrameLoader) {
    1:           Fallback(PR_FALSE);
    1:           return NS_ERROR_UNEXPECTED;
    1:         }
    1:       }
    1: 
 3556:       rv = mFrameLoader->CheckForRecursiveLoad(uri);
 3556:       if (NS_FAILED(rv)) {
 3556:         Fallback(PR_FALSE);
 3556:         return rv;
 3556:       }
 3556: 
    1:       if (mType != newType) {
    1:         // XXX We must call this before getting the docshell to work around
    1:         // bug 300540; when that's fixed, this if statement can be removed.
    1:         mType = newType;
    1:         notifier.Notify();
33385: 
33385:         if (!mFrameLoader) {
33385:           // mFrameLoader got nulled out when we notified, which most
33385:           // likely means the node was removed from the
33385:           // document. Abort the load that just started.
33385:           return NS_BINDING_ABORTED;
33385:         }
    1:       }
    1: 
 2708:       // We're loading a document, so we have to set LOAD_DOCUMENT_URI
 2708:       // (especially important for firing onload)
 2708:       nsLoadFlags flags = 0;
 2708:       chan->GetLoadFlags(&flags);
 2708:       flags |= nsIChannel::LOAD_DOCUMENT_URI;
 2708:       chan->SetLoadFlags(flags);
 2708: 
    1:       nsCOMPtr<nsIDocShell> docShell;
    1:       rv = mFrameLoader->GetDocShell(getter_AddRefs(docShell));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(docShell));
    1:       NS_ASSERTION(req, "Docshell must be an ifreq");
    1: 
    1:       nsCOMPtr<nsIURILoader>
    1:         uriLoader(do_GetService(NS_URI_LOADER_CONTRACTID, &rv));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:       rv = uriLoader->OpenChannel(chan, nsIURILoader::DONT_RETARGET, req,
    1:                                   getter_AddRefs(mFinalListener));
    1:       break;
    1:     }
    1:     case eType_Plugin:
    1:       mInstantiating = PR_TRUE;
    1:       if (mType != newType) {
    1:         // This can go away once plugin loading moves to content (bug 90268)
    1:         mType = newType;
    1:         notifier.Notify();
    1:       }
    1:       nsIObjectFrame* frame;
13098:       frame = GetExistingFrame(eFlushLayout);
    1:       if (!frame) {
    1:         // Do nothing in this case: This is probably due to a display:none
    1:         // frame. If we ever get a frame, HasNewFrame will do the right thing.
    1:         // Abort the load though, we have no use for the data.
    1:         mInstantiating = PR_FALSE;
    1:         return NS_BINDING_ABORTED;
    1:       }
12417: 
12417:       {
23554:         nsIFrame *nsiframe = do_QueryFrame(frame);
12417: 
12417:         nsWeakFrame weakFrame(nsiframe);
12417: 
    1:         rv = frame->Instantiate(chan, getter_AddRefs(mFinalListener));
12417: 
    1:         mInstantiating = PR_FALSE;
12417: 
12417:         if (!weakFrame.IsAlive()) {
12417:           // The frame was destroyed while instantiating. Abort the load.
12417:           return NS_BINDING_ABORTED;
12417:         }
12417:       }
12417: 
    1:       break;
    1:     case eType_Loading:
    1:       NS_NOTREACHED("Should not have a loading type here!");
    1:     case eType_Null:
    1:       LOG(("OBJLC [%p]: Unsupported type, falling back\n", this));
    1:       // Need to fallback here (instead of using the case below), so that we can
19014:       // set mPluginState without it being overwritten. This is also why we
    1:       // return early.
    1:       Fallback(PR_FALSE);
    1: 
    1:       PluginSupportState pluginState = GetPluginSupportState(thisContent,
    1:                                                              mContentType);
    1:       // Do nothing, but fire the plugin not found event if needed
19014:       if (pluginState != ePluginOtherState) {
19014:         FirePluginError(thisContent, pluginState);
19014:         mPluginState = pluginState;
    1:       }
    1:       return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   if (mFinalListener) {
    1:     mType = newType;
    1:     rv = mFinalListener->OnStartRequest(aRequest, aContext);
    1:     if (NS_FAILED(rv)) {
    1:       LOG(("OBJLC [%p]: mFinalListener->OnStartRequest failed (%08x), falling back\n",
    1:            this, rv));
 4178: #ifdef XP_MACOSX
 4178:       // Shockwave on Mac is special and returns an error here even when it
 4178:       // handles the content
 4178:       if (mContentType.EqualsLiteral("application/x-director")) {
 4178:         LOG(("OBJLC [%p]: (ignoring)\n", this));
 4178:         rv = NS_OK; // otherwise, the AutoFallback will make us fall back
 4178:         return NS_BINDING_ABORTED;
 4178:       }
 4178: #endif
    1:       Fallback(PR_FALSE);
 4189:     } else if (mType == eType_Plugin) {
13098:       nsIObjectFrame* frame = GetExistingFrame(eFlushContent);
 4189:       if (frame) {
 4189:         // We have to notify the wrapper here instead of right after
 4189:         // Instantiate because the plugin only gets instantiated by
 4189:         // OnStartRequest, not by Instantiate.
 4189:         frame->TryNotifyContentObjectWrapper();
 4189:       }
    1:     }
    1:     return rv;
    1:   }
    1: 
    1:   LOG(("OBJLC [%p]: Found no listener, falling back\n", this));
    1:   Fallback(PR_FALSE);
    1:   return NS_BINDING_ABORTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::OnStopRequest(nsIRequest *aRequest,
    1:                                       nsISupports *aContext,
    1:                                       nsresult aStatusCode)
    1: {
    1:   if (aRequest != mChannel) {
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   mChannel = nsnull;
    1: 
    1:   if (mFinalListener) {
    1:     mFinalListener->OnStopRequest(aRequest, aContext, aStatusCode);
    1:     mFinalListener = nsnull;
    1:   }
    1: 
    1:   // Return value doesn't matter
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsIStreamListener
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::OnDataAvailable(nsIRequest *aRequest, nsISupports *aContext, nsIInputStream *aInputStream, PRUint32 aOffset, PRUint32 aCount)
    1: {
    1:   if (aRequest != mChannel) {
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   if (mFinalListener) {
    1:     return mFinalListener->OnDataAvailable(aRequest, aContext, aInputStream, aOffset, aCount);
    1:   }
    1: 
    1:   // Abort this load if we have no listener here
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: // nsIFrameLoaderOwner
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetFrameLoader(nsIFrameLoader** aFrameLoader)
    1: {
    1:   *aFrameLoader = mFrameLoader;
    1:   NS_IF_ADDREF(*aFrameLoader);
    1:   return NS_OK;
    1: }
    1: 
34076: NS_IMETHODIMP_(already_AddRefed<nsFrameLoader>)
34076: nsObjectLoadingContent::GetFrameLoader()
34076: {
34076:   nsFrameLoader* loader = mFrameLoader;
34076:   NS_IF_ADDREF(loader);
34076:   return loader;
34076: }
34076: 
16549: NS_IMETHODIMP
16549: nsObjectLoadingContent::SwapFrameLoaders(nsIFrameLoaderOwner* aOtherLoader)
16549: {
16549:   return NS_ERROR_NOT_IMPLEMENTED;
16549: }
16549: 
    1: // nsIObjectLoadingContent
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetActualType(nsACString& aType)
    1: {
    1:   aType = mContentType;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetDisplayedType(PRUint32* aType)
    1: {
    1:   *aType = mType;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::EnsureInstantiation(nsIPluginInstance** aInstance)
    1: {
    1:   // Must set our out parameter to null as we have various early returns with
    1:   // an NS_OK result.
    1:   *aInstance = nsnull;
    1: 
    1:   if (mType != eType_Plugin) {
    1:     return NS_OK;
    1:   }
    1: 
13098:   nsIObjectFrame* frame = GetExistingFrame(eFlushContent);
    1:   if (frame) {
    1:     // If we have a frame, we may have pending instantiate events; revoke
    1:     // them.
    1:     if (mPendingInstantiateEvent) {
    1:       LOG(("OBJLC [%p]: Revoking pending instantiate event\n", this));
    1:       mPendingInstantiateEvent = nsnull;
    1:     }
    1:   } else {
    1:     // mInstantiating is true if we're in LoadObject; we shouldn't
    1:     // recreate frames in that case, we'd confuse that function.
    1:     if (mInstantiating) {
    1:       return NS_OK;
    1:     }
    1: 
    1:     // Trigger frame construction
    1:     mInstantiating = PR_TRUE;
    1: 
    1:     nsCOMPtr<nsIContent> thisContent = 
 3233:       do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:     NS_ASSERTION(thisContent, "must be a content");
    1: 
    1:     nsIDocument* doc = thisContent->GetCurrentDoc();
    1:     if (!doc) {
    1:       // Nothing we can do while plugin loading is done in layout...
 3651:       mInstantiating = PR_FALSE;
    1:       return NS_OK;
    1:     }
    1: 
 1722:     nsPresShellIterator iter(doc);
 1722:     nsCOMPtr<nsIPresShell> shell;
 1722:     while ((shell = iter.GetNextShell())) {
    1:       shell->RecreateFramesFor(thisContent);
    1:     }
    1: 
    1:     mInstantiating = PR_FALSE;
    1: 
13098:     frame = GetExistingFrame(eFlushContent);
    1:     if (!frame) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
23554:   nsIFrame *nsiframe = do_QueryFrame(frame);
24544: 
24544:   if (nsiframe->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
24544:     // A frame for this plugin element already exists now, but it has
30709:     // not been reflowed yet. Force a reflow now so that we don't end
24544:     // up initializing a plugin before knowing its size. Also re-fetch
24544:     // the frame, as flushing can cause the frame to be deleted.
24544:     frame = GetExistingFrame(eFlushLayout);
24544: 
24544:     if (!frame) {
24544:       return NS_OK;
24544:     }
24544: 
24544:     nsiframe = do_QueryFrame(frame);
24544:   }
24544: 
12417:   nsWeakFrame weakFrame(nsiframe);
12417: 
    1:   // We may have a plugin instance already; if so, do nothing
    1:   nsresult rv = frame->GetPluginInstance(*aInstance);
12417:   if (!*aInstance && weakFrame.IsAlive()) {
 4329:     rv = Instantiate(frame, mContentType, mURI);
12417:     if (NS_SUCCEEDED(rv) && weakFrame.IsAlive()) {
    1:       rv = frame->GetPluginInstance(*aInstance);
    1:     } else {
    1:       Fallback(PR_TRUE);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::HasNewFrame(nsIObjectFrame* aFrame)
    1: {
    1:   LOG(("OBJLC [%p]: Got frame %p (mInstantiating=%i)\n", this, aFrame,
    1:        mInstantiating));
15571: 
35581:   nsCOMPtr<nsIContent> thisContent = 
35581:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
35581:   NS_ASSERTION(thisContent, "must be a content");
35581:   nsIDocument* doc = thisContent->GetOwnerDoc();
35581:   if (!doc || doc->IsStaticDocument()) {
35581:     return NS_OK;
35581:   }
35581:   
15571:   // "revoke" any existing instantiate event as it likely has out of
15571:   // date data (frame pointer etc).
15571:   mPendingInstantiateEvent = nsnull;
15571: 
15571:   nsCOMPtr<nsIPluginInstance> instance;
15571:   aFrame->GetPluginInstance(*getter_AddRefs(instance));
15571: 
15571:   if (instance) {
15571:     // The frame already has a plugin instance, that means the plugin
15571:     // has already been instantiated.
15571: 
15571:     return NS_OK;
15571:   }
15571: 
15571:   if (!mInstantiating && mType == eType_Plugin) {
    1:     // Asynchronously call Instantiate
    1:     // This can go away once plugin loading moves to content
    1:     // This must be done asynchronously to ensure that the frame is correctly
    1:     // initialized (has a view etc)
    1: 
    1:     // When in a plugin document, the document will take care of calling
    1:     // instantiate
    1:     nsCOMPtr<nsIPluginDocument> pDoc (do_QueryInterface(GetOurDocument()));
    1:     if (pDoc) {
20110:       PRBool willHandleInstantiation;
20110:       pDoc->GetWillHandleInstantiation(&willHandleInstantiation);
20110:       if (willHandleInstantiation) {
    1:         return NS_OK;
    1:       }
20110:     }
    1: 
23554:     nsIFrame* frame = do_QueryFrame(aFrame);
    1:     nsCOMPtr<nsIRunnable> event =
22223:       new nsAsyncInstantiateEvent(this, frame, mContentType, mURI);
    1:     if (!event) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     LOG(("                 dispatching event\n"));
    1:     nsresult rv = NS_DispatchToCurrentThread(event);
    1:     if (NS_FAILED(rv)) {
    1:       NS_ERROR("failed to dispatch nsAsyncInstantiateEvent");
    1:     } else {
    1:       // Remember this event.  This is a weak reference that will be cleared
    1:       // when the event runs.
    1:       mPendingInstantiateEvent = event;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
13098: nsObjectLoadingContent::GetPluginInstance(nsIPluginInstance** aInstance)
13098: {
13098:   *aInstance = nsnull;
13098: 
13098:   nsIObjectFrame* objFrame = GetExistingFrame(eDontFlush);
13098:   if (!objFrame) {
13098:     return NS_OK;
13098:   }
13098: 
13098:   return objFrame->GetPluginInstance(*aInstance);
13098: }
13098: 
13098: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetContentTypeForMIMEType(const nsACString& aMIMEType,
    1:                                                   PRUint32* aType)
    1: {
    1:   *aType = GetTypeOfContent(PromiseFlatCString(aMIMEType));
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIInterfaceRequestor
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetInterface(const nsIID & aIID, void **aResult)
    1: {
    1:   if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
    1:     nsIChannelEventSink* sink = this;
    1:     *aResult = sink;
    1:     NS_ADDREF(sink);
    1:     return NS_OK;
    1:   }
    1:   return NS_NOINTERFACE;
    1: }
    1: 
    1: // nsIChannelEventSink
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::OnChannelRedirect(nsIChannel *aOldChannel,
    1:                                           nsIChannel *aNewChannel,
    1:                                           PRUint32    aFlags)
    1: {
    1:   // If we're already busy with a new load, cancel the redirect
    1:   if (aOldChannel != mChannel) {
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
12968:   if (mClassifier) {
12968:     mClassifier->OnRedirect(aOldChannel, aNewChannel);
12968:   }
12968: 
    1:   mChannel = aNewChannel;
    1:   return NS_OK;
    1: }
    1: 
    1: // <public>
    1: PRInt32
    1: nsObjectLoadingContent::ObjectState() const
    1: {
    1:   switch (mType) {
    1:     case eType_Loading:
    1:       return NS_EVENT_STATE_LOADING;
    1:     case eType_Image:
    1:       return ImageState();
    1:     case eType_Plugin:
    1:     case eType_Document:
    1:       // These are OK. If documents start to load successfully, they display
    1:       // something, and are thus not broken in this sense. The same goes for
    1:       // plugins.
    1:       return 0;
    1:     case eType_Null:
    1:       if (mSuppressed)
    1:         return NS_EVENT_STATE_SUPPRESSED;
    1:       if (mUserDisabled)
    1:         return NS_EVENT_STATE_USERDISABLED;
    1: 
    1:       // Otherwise, broken
    1:       PRInt32 state = NS_EVENT_STATE_BROKEN;
19014:       switch (mPluginState) {
19014:         case ePluginDisabled:
19014:           state |= NS_EVENT_STATE_HANDLER_DISABLED;
19014:           break;
19014:         case ePluginBlocklisted:
19014:           state |= NS_EVENT_STATE_HANDLER_BLOCKED;
19014:           break;
19014:         case ePluginUnsupported:
    1:           state |= NS_EVENT_STATE_TYPE_UNSUPPORTED;
19014:           break;
    1:       }
    1:       return state;
    1:   };
    1:   NS_NOTREACHED("unknown type?");
    1:   // this return statement only exists to avoid a compile warning
    1:   return 0;
    1: }
    1: 
    1: // <protected>
    1: nsresult
    1: nsObjectLoadingContent::LoadObject(const nsAString& aURI,
    1:                                    PRBool aNotify,
    1:                                    const nsCString& aTypeHint,
    1:                                    PRBool aForceLoad)
    1: {
    1:   LOG(("OBJLC [%p]: Loading object: URI string=<%s> notify=%i type=<%s> forceload=%i\n",
    1:        this, NS_ConvertUTF16toUTF8(aURI).get(), aNotify, aTypeHint.get(), aForceLoad));
    1: 
    1:   NS_ASSERTION(!mInstantiating, "LoadObject was reentered?");
    1: 
    1:   // Avoid StringToURI in order to use the codebase attribute as base URI
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
    1:   nsIDocument* doc = thisContent->GetOwnerDoc();
    1:   nsCOMPtr<nsIURI> baseURI;
    1:   GetObjectBaseURI(thisContent, getter_AddRefs(baseURI));
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(uri),
    1:                                             aURI, doc,
    1:                                             baseURI);
    1:   // If URI creation failed, fallback immediately - this only happens for
    1:   // malformed URIs
    1:   if (!uri) {
    1:     Fallback(aNotify);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_TryToSetImmutable(uri);
    1: 
    1:   return LoadObject(uri, aNotify, aTypeHint, aForceLoad);
    1: }
    1: 
 8608: static PRBool
 8608: IsAboutBlank(nsIURI* aURI)
 8608: {
 8608:   // XXXbz this duplicates an nsDocShell function, sadly
 8608:   NS_PRECONDITION(aURI, "Must have URI");
 8608:     
 8608:   // GetSpec can be expensive for some URIs, so check the scheme first.
 8608:   PRBool isAbout = PR_FALSE;
 8608:   if (NS_FAILED(aURI->SchemeIs("about", &isAbout)) || !isAbout) {
 8608:     return PR_FALSE;
 8608:   }
 8608:     
 8608:   nsCAutoString str;
 8608:   aURI->GetSpec(str);
 8608:   return str.EqualsLiteral("about:blank");  
 8608: }
 8608: 
12297: void
12297: nsObjectLoadingContent::UpdateFallbackState(nsIContent* aContent,
12297:                                             AutoFallback& fallback,
12297:                                             const nsCString& aTypeHint)
12297: {
19014:   // Notify the UI and update the fallback state
19014:   PluginSupportState state = GetPluginSupportState(aContent, aTypeHint);
19014:   if (state != ePluginOtherState) {
19014:     fallback.SetPluginState(state);
19014:     FirePluginError(aContent, state);
12297:   }
12297: }
12297: 
    1: nsresult
    1: nsObjectLoadingContent::LoadObject(nsIURI* aURI,
    1:                                    PRBool aNotify,
    1:                                    const nsCString& aTypeHint,
    1:                                    PRBool aForceLoad)
    1: {
    1:   LOG(("OBJLC [%p]: Loading object: URI=<%p> notify=%i type=<%s> forceload=%i\n",
    1:        this, aURI, aNotify, aTypeHint.get(), aForceLoad));
    1: 
    1:   if (mURI && aURI && !aForceLoad) {
    1:     PRBool equal;
    1:     nsresult rv = mURI->Equals(aURI, &equal);
    1:     if (NS_SUCCEEDED(rv) && equal) {
    1:       // URI didn't change, do nothing
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   // Need to revoke any potentially pending instantiate events
    1:   if (mType == eType_Plugin && mPendingInstantiateEvent) {
    1:     LOG(("OBJLC [%p]: Revoking pending instantiate event\n", this));
    1:     mPendingInstantiateEvent = nsnull;
    1:   }
    1: 
    1:   AutoNotifier notifier(this, aNotify);
    1: 
    1:   // AutoSetInstantiatingToFalse is instantiated after AutoNotifier, so that if
    1:   // the AutoNotifier triggers frame construction, events can be posted as
    1:   // appropriate.
    1:   NS_ASSERTION(!mInstantiating, "LoadObject was reentered?");
    1:   mInstantiating = PR_TRUE;
    1:   AutoSetInstantiatingToFalse autoset(this);
    1: 
    1:   mUserDisabled = mSuppressed = PR_FALSE;
    1: 
    1:   mURI = aURI;
    1:   mContentType = aTypeHint;
    1: 
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
    1:   nsIDocument* doc = thisContent->GetOwnerDoc();
    1:   if (!doc) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // From here on, we will always change the content. This means that a
    1:   // possibly-loading channel should be aborted.
    1:   if (mChannel) {
    1:     LOG(("OBJLC [%p]: Cancelling existing load\n", this));
12968: 
12968:     if (mClassifier) {
12968:       mClassifier->Cancel();
12968:       mClassifier = nsnull;
12968:     }
12968: 
    1:     // These three statements are carefully ordered:
    1:     // - onStopRequest should get a channel whose status is the same as the
    1:     //   status argument
    1:     // - onStopRequest must get a non-null channel
    1:     mChannel->Cancel(NS_BINDING_ABORTED);
    1:     if (mFinalListener) {
    1:       // NOTE: Since mFinalListener is only set in onStartRequest, which takes
    1:       // care of calling mFinalListener->OnStartRequest, mFinalListener is only
    1:       // non-null here if onStartRequest was already called.
    1:       mFinalListener->OnStopRequest(mChannel, nsnull, NS_BINDING_ABORTED);
    1:       mFinalListener = nsnull;
    1:     }
    1:     mChannel = nsnull;
    1:   }
    1: 
    1:   // Security checks
 4064:   if (doc->IsLoadedAsData()) {
35581:     if (!doc->IsStaticDocument()) {
 4064:       Fallback(PR_FALSE);
35581:     }
 4064:     return NS_OK;
 4064:   }
 4064: 
    1:   // Can't do security checks without a URI - hopefully the plugin will take
    1:   // care of that
    1:   // Null URIs happen when the URL to load is specified via other means than the
    1:   // data/src attribute, for example via custom <param> elements.
    1:   if (aURI) {
    1:     nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
    1:     NS_ASSERTION(secMan, "No security manager!?");
    1:     nsresult rv =
    1:       secMan->CheckLoadURIWithPrincipal(thisContent->NodePrincipal(), aURI, 0);
    1:     if (NS_FAILED(rv)) {
    1:       Fallback(PR_FALSE);
    1:       return NS_OK;
    1:     }
    1: 
    1:     PRInt16 shouldLoad = nsIContentPolicy::ACCEPT; // default permit
    1:     rv =
    1:       NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT,
    1:                                 aURI,
 4367:                                 doc->NodePrincipal(),
 3233:                                 static_cast<nsIImageLoadingContent*>(this),
    1:                                 aTypeHint,
    1:                                 nsnull, //extra
    1:                                 &shouldLoad,
 4367:                                 nsContentUtils::GetContentPolicy(),
 5870:                                 secMan);
    1:     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
 5870:       HandleBeingBlockedByContentPolicy(rv, shouldLoad);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   nsresult rv = NS_ERROR_UNEXPECTED;
    1:   // This fallback variable MUST be declared after the notifier variable. Do NOT
    1:   // change the order of the declarations!
    1:   AutoFallback fallback(this, &rv);
    1: 
    1:   PRUint32 caps = GetCapabilities();
    1:   LOG(("OBJLC [%p]: Capabilities: %04x\n", this, caps));
    1: 
 3642:   nsCAutoString overrideType;
 3642:   if ((caps & eOverrideServerType) &&
14864:       ((!aTypeHint.IsEmpty() && IsSupportedPlugin(aTypeHint)) ||
 3642:        (aURI && IsPluginEnabledByExtension(aURI, overrideType)))) {
 3642:     ObjectType newType;
 3642:     if (overrideType.IsEmpty()) {
 3642:       newType = GetTypeOfContent(aTypeHint);
 3642:     } else {
 4329:       mContentType = overrideType;
 3642:       newType = eType_Plugin;
 3642:     }
 3642: 
    1:     if (newType != mType) {
    1:       LOG(("OBJLC [%p]: (eOverrideServerType) Changing type from %u to %u\n", this, mType, newType));
    1: 
    1:       UnloadContent();
    1: 
    1:       // Must have a frameloader before creating a frame, or the frame will
    1:       // create its own.
    1:       if (!mFrameLoader && newType == eType_Document) {
31661:         mFrameLoader = nsFrameLoader::Create(thisContent);
31661:         if (!mFrameLoader) {
    1:           mURI = nsnull;
    1:           return NS_OK;
    1:         }
    1:       }
    1: 
    1:       // Must notify here for plugins
    1:       // If aNotify is false, we'll just wait until we get a frame and use the
    1:       // async instantiate path.
 4329:       // XXX is this still needed? (for documents?)
    1:       mType = newType;
    1:       if (aNotify)
    1:         notifier.Notify();
    1:     }
    1:     switch (newType) {
    1:       case eType_Image:
    1:         // Don't notify, because we will take care of that ourselves.
 7660:         if (aURI) {
    1:           rv = LoadImage(aURI, aForceLoad, PR_FALSE);
 7660:         } else {
 7660:           rv = NS_ERROR_NOT_AVAILABLE;
 7660:         }
    1:         break;
    1:       case eType_Plugin:
 4329:         rv = TryInstantiate(mContentType, mURI);
    1:         break;
    1:       case eType_Document:
 7660:         if (aURI) {
    1:           rv = mFrameLoader->LoadURI(aURI);
 7660:         } else {
 7660:           rv = NS_ERROR_NOT_AVAILABLE;
 7660:         }
    1:         break;
    1:       case eType_Loading:
    1:         NS_NOTREACHED("Should not have a loading type here!");
    1:       case eType_Null:
12297:         // No need to load anything, notify of the failure.
12297:         UpdateFallbackState(thisContent, fallback, aTypeHint);
    1:         break;
    1:     };
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If the class ID specifies a supported plugin, or if we have no explicit URI
    1:   // but a type, immediately instantiate the plugin.
    1:   PRBool isSupportedClassID = PR_FALSE;
    1:   nsCAutoString typeForID; // Will be set iff isSupportedClassID == PR_TRUE
    1:   PRBool hasID = PR_FALSE;
    1:   if (caps & eSupportClassID) {
    1:     nsAutoString classid;
    1:     thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::classid, classid);
    1:     if (!classid.IsEmpty()) {
    1:       hasID = PR_TRUE;
    1:       isSupportedClassID = NS_SUCCEEDED(TypeForClassID(classid, typeForID));
    1:     }
    1:   }
    1: 
    1:   if (hasID && !isSupportedClassID) {
    1:     // We have a class ID and it's unsupported.  Fallback in that case.
    1:     LOG(("OBJLC [%p]: invalid classid\n", this));
    1:     rv = NS_ERROR_NOT_AVAILABLE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (isSupportedClassID ||
    1:       (!aURI && !aTypeHint.IsEmpty() &&
    1:        GetTypeOfContent(aTypeHint) == eType_Plugin)) {
    1:     // No URI, but we have a type. The plugin will handle the load.
    1:     // Or: supported class id, plugin will handle the load.
    1:     LOG(("OBJLC [%p]: (classid) Changing type from %u to eType_Plugin\n", this, mType));
    1:     mType = eType_Plugin;
    1: 
    1:     // At this point, the stored content type
    1:     // must be equal to our type hint. Similar,
    1:     // our URI must be the requested URI.
    1:     // (->Equals would suffice, but == is cheaper
    1:     // and handles NULL)
    1:     NS_ASSERTION(mContentType.Equals(aTypeHint), "mContentType wrong!");
    1:     NS_ASSERTION(mURI == aURI, "mURI wrong!");
    1: 
    1:     if (isSupportedClassID) {
    1:       // Use the classid's type
    1:       NS_ASSERTION(!typeForID.IsEmpty(), "Must have a real type!");
    1:       mContentType = typeForID;
    1:       // XXX(biesi). The plugin instantiation code used to pass the base URI
    1:       // here instead of the plugin URI for instantiation via class ID, so I
    1:       // continue to do so. Why that is, no idea...
    1:       GetObjectBaseURI(thisContent, getter_AddRefs(mURI));
    1:       if (!mURI) {
    1:         mURI = aURI;
    1:       }
    1:     }
    1: 
 4329:     rv = TryInstantiate(mContentType, mURI);
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!aURI) {
12297:     // No URI and if we have got this far no enabled plugin supports the type
    1:     LOG(("OBJLC [%p]: no URI\n", this));
    1:     rv = NS_ERROR_NOT_AVAILABLE;
12297: 
12297:     // We should only notify the UI if there is at least a type to go on for
14391:     // finding a plugin to use, unless it's a supported image or document type.
14391:     if (!aTypeHint.IsEmpty() && GetTypeOfContent(aTypeHint) == eType_Null) {
12297:       UpdateFallbackState(thisContent, fallback, aTypeHint);
12297:     }
12297: 
    1:     return NS_OK;
    1:   }
    1: 
12297:   // E.g. mms://
    1:   if (!CanHandleURI(aURI)) {
    1:     LOG(("OBJLC [%p]: can't handle URI\n", this));
 4315:     if (aTypeHint.IsEmpty()) {
 4315:       rv = NS_ERROR_NOT_AVAILABLE;
 4315:       return NS_OK;
 4315:     }
12297: 
12297:     if (IsSupportedPlugin(aTypeHint)) {
    1:       mType = eType_Plugin;
    1: 
 4329:       rv = TryInstantiate(aTypeHint, aURI);
12297:     } else {
12297:       rv = NS_ERROR_NOT_AVAILABLE;
12297:       // No plugin to load, notify of the failure.
12297:       UpdateFallbackState(thisContent, fallback, aTypeHint);
12297:     }
12297: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsILoadGroup> group = doc->GetDocumentLoadGroup();
    1:   nsCOMPtr<nsIChannel> chan;
 4849:   rv = NS_NewChannel(getter_AddRefs(chan), aURI, nsnull, group, this,
 4849:                      nsIChannel::LOAD_CALL_CONTENT_SNIFFERS);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Referrer
    1:   nsCOMPtr<nsIHttpChannel> httpChan(do_QueryInterface(chan));
    1:   if (httpChan) {
    1:     httpChan->SetReferrer(doc->GetDocumentURI());
    1:   }
    1: 
    1:   // MIME Type hint
    1:   if (!aTypeHint.IsEmpty()) {
    1:     chan->SetContentType(aTypeHint);
    1:   }
    1: 
 8608:   // Set up the channel's principal and such, like nsDocShell::DoURILoad does
 8608:   PRBool inheritPrincipal;
 8608:   rv = NS_URIChainHasFlags(aURI,
 8608:                            nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
 8608:                            &inheritPrincipal);
 8608:   NS_ENSURE_SUCCESS(rv, rv);
13471:   if (inheritPrincipal || IsAboutBlank(aURI) ||
13471:       (nsContentUtils::URIIsLocalFile(aURI) &&
13471:        NS_SUCCEEDED(thisContent->NodePrincipal()->CheckMayLoad(aURI,
13471:                                                                PR_FALSE)))) {
 8608:     chan->SetOwner(thisContent->NodePrincipal());
 8608:   }
 8608: 
 8608:   nsCOMPtr<nsIScriptChannel> scriptChannel = do_QueryInterface(chan);
 8608:   if (scriptChannel) {
 8608:     // Allow execution against our context if the principals match
 8608:     scriptChannel->
 8608:       SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
 8608:   }
 8608: 
    1:   // AsyncOpen can fail if a file does not exist.
    1:   // Show fallback content in that case.
    1:   rv = chan->AsyncOpen(this, nsnull);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     LOG(("OBJLC [%p]: Channel opened.\n", this));
12968: 
12968:     rv = CheckClassifier(chan);
12968:     if (NS_FAILED(rv)) {
12968:       chan->Cancel(rv);
12968:       return rv;
12968:     }
12968: 
    1:     mChannel = chan;
    1:     mType = eType_Loading;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: PRUint32
    1: nsObjectLoadingContent::GetCapabilities() const
    1: {
    1:   return eSupportImages |
    1:          eSupportPlugins |
    1:          eSupportDocuments
    1: #ifdef MOZ_SVG
    1:          | eSupportSVG
    1: #endif
    1:          ;
    1: }
    1: 
    1: void
    1: nsObjectLoadingContent::Fallback(PRBool aNotify)
    1: {
    1:   LOG(("OBJLC [%p]: Falling back (Notify=%i)\n", this, aNotify));
    1: 
    1:   AutoNotifier notifier(this, aNotify);
    1: 
    1:   UnloadContent();
    1: }
    1: 
    1: void
    1: nsObjectLoadingContent::RemovedFromDocument()
    1: {
    1:   LOG(("OBJLC [%p]: Removed from doc\n", this));
    1:   if (mFrameLoader) {
    1:     // XXX This is very temporary and must go away
    1:     mFrameLoader->Destroy();
    1:     mFrameLoader = nsnull;
    1: 
    1:     // Clear the current URI, so that LoadObject doesn't think that we
    1:     // have already loaded the content.
    1:     mURI = nsnull;
    1:   }
    1: }
    1: 
    1: void
    1: nsObjectLoadingContent::Traverse(nsCycleCollectionTraversalCallback &cb)
    1: {
    1:   cb.NoteXPCOMChild(mFrameLoader);
    1: }
    1: 
    1: // <private>
    1: /* static */ PRBool
    1: nsObjectLoadingContent::IsSuccessfulRequest(nsIRequest* aRequest)
    1: {
    1:   nsresult status;
    1:   nsresult rv = aRequest->GetStatus(&status);
    1:   if (NS_FAILED(rv) || NS_FAILED(status)) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // This may still be an error page or somesuch
    1:   nsCOMPtr<nsIHttpChannel> httpChan(do_QueryInterface(aRequest));
    1:   if (httpChan) {
    1:     PRBool success;
    1:     rv = httpChan->GetRequestSucceeded(&success);
    1:     if (NS_FAILED(rv) || !success) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   // Otherwise, the request is successful
    1:   return PR_TRUE;
    1: }
    1: 
    1: /* static */ PRBool
    1: nsObjectLoadingContent::CanHandleURI(nsIURI* aURI)
    1: {
    1:   nsCAutoString scheme;
    1:   if (NS_FAILED(aURI->GetScheme(scheme))) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsIIOService* ios = nsContentUtils::GetIOService();
    1:   if (!ios)
    1:     return PR_FALSE;
    1:   
    1:   nsCOMPtr<nsIProtocolHandler> handler;
    1:   ios->GetProtocolHandler(scheme.get(), getter_AddRefs(handler));
    1:   if (!handler) {
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   nsCOMPtr<nsIExternalProtocolHandler> extHandler =
    1:     do_QueryInterface(handler);
    1:   // We can handle this URI if its protocol handler is not the external one
    1:   return extHandler == nsnull;
    1: }
    1: 
    1: PRBool
    1: nsObjectLoadingContent::IsSupportedDocument(const nsCString& aMimeType)
    1: {
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIWebNavigationInfo> info(
    1:     do_GetService(NS_WEBNAVIGATION_INFO_CONTRACTID, &rv));
    1:   PRUint32 supported;
    1:   if (info) {
    1:     nsCOMPtr<nsIWebNavigation> webNav;
    1:     nsIDocument* currentDoc = thisContent->GetCurrentDoc();
    1:     if (currentDoc) {
    1:       webNav = do_GetInterface(currentDoc->GetScriptGlobalObject());
    1:     }
    1:     rv = info->IsTypeSupported(aMimeType, webNav, &supported);
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     if (supported == nsIWebNavigationInfo::UNSUPPORTED) {
    1:       // Try a stream converter
    1:       // NOTE: We treat any type we can convert from as a supported type. If a
    1:       // type is not actually supported, the URI loader will detect that and
    1:       // return an error, and we'll fallback.
    1:       nsCOMPtr<nsIStreamConverterService> convServ =
    1:         do_GetService("@mozilla.org/streamConverters;1");
    1:       PRBool canConvert = PR_FALSE;
    1:       if (convServ) {
    1:         rv = convServ->CanConvert(aMimeType.get(), "*/*", &canConvert);
    1:       }
    1: 
    1:       return NS_SUCCEEDED(rv) && canConvert;
    1:     }
    1: 
    1:     // Don't want to support plugins as documents
    1:     return supported != nsIWebNavigationInfo::PLUGIN;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsObjectLoadingContent::UnloadContent()
    1: {
    1:   // Don't notify in CancelImageRequests. We do it ourselves.
    1:   CancelImageRequests(PR_FALSE);
    1:   if (mFrameLoader) {
    1:     mFrameLoader->Destroy();
    1:     mFrameLoader = nsnull;
    1:   }
    1:   mType = eType_Null;
19014:   mUserDisabled = mSuppressed = PR_FALSE;
19014:   mPluginState = ePluginOtherState;
    1: }
    1: 
    1: void
    1: nsObjectLoadingContent::NotifyStateChanged(ObjectType aOldType,
    1:                                           PRInt32 aOldState,
    1:                                           PRBool aSync)
    1: {
    1:   LOG(("OBJLC [%p]: Notifying about state change: (%u, %x) -> (%u, %x) (sync=%i)\n",
    1:        this, aOldType, aOldState, mType, ObjectState(), aSync));
    1: 
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
    1:   nsIDocument* doc = thisContent->GetCurrentDoc();
    1:   if (!doc) {
    1:     return; // Nothing to do
    1:   }
    1: 
    1:   PRInt32 newState = ObjectState();
    1: 
    1:   if (newState != aOldState) {
    1:     // This will trigger frame construction
    1:     NS_ASSERTION(thisContent->IsInDoc(), "Something is confused");
    1:     PRInt32 changedBits = aOldState ^ newState;
    1: 
    1:     {
    1:       mozAutoDocUpdate upd(doc, UPDATE_CONTENT_STATE, PR_TRUE);
    1:       doc->ContentStatesChanged(thisContent, nsnull, changedBits);
    1:     }
    1:     if (aSync) {
    1:       // Make sure that frames are actually constructed, and do it after
    1:       // EndUpdate was called.
    1:       doc->FlushPendingNotifications(Flush_Frames);
    1:     }
    1:   } else if (aOldType != mType) {
    1:     // If our state changed, then we already recreated frames
    1:     // Otherwise, need to do that here
    1: 
 1722:     nsPresShellIterator iter(doc);
 1722:     nsCOMPtr<nsIPresShell> shell;
 1722:     while ((shell = iter.GetNextShell())) {
    1:       shell->RecreateFramesFor(thisContent);
    1:     }
    1:   }
    1: }
    1: 
    1: /* static */ void
 3464: nsObjectLoadingContent::FirePluginError(nsIContent* thisContent,
19014:                                         PluginSupportState state)
    1: {
 3464:   LOG(("OBJLC []: Dispatching nsPluginErrorEvent for content %p\n",
    1:        thisContent));
    1: 
19014:   nsCOMPtr<nsIRunnable> ev = new nsPluginErrorEvent(thisContent, state);
    1:   nsresult rv = NS_DispatchToCurrentThread(ev);
    1:   if (NS_FAILED(rv)) {
 3464:     NS_WARNING("failed to dispatch nsPluginErrorEvent");
    1:   }
    1: }
    1: 
    1: nsObjectLoadingContent::ObjectType
    1: nsObjectLoadingContent::GetTypeOfContent(const nsCString& aMIMEType)
    1: {
    1:   PRUint32 caps = GetCapabilities();
    1: 
    1:   if ((caps & eSupportImages) && IsSupportedImage(aMIMEType)) {
    1:     return eType_Image;
    1:   }
    1: 
    1: #ifdef MOZ_SVG
    1:   PRBool isSVG = aMIMEType.LowerCaseEqualsLiteral("image/svg+xml");
    1:   PRBool supportedSVG = isSVG && (caps & eSupportSVG);
    1: #else
    1:   PRBool supportedSVG = PR_FALSE;
    1: #endif
    1:   if (((caps & eSupportDocuments) || supportedSVG) &&
    1:       IsSupportedDocument(aMIMEType)) {
    1:     return eType_Document;
    1:   }
    1: 
    1:   if ((caps & eSupportPlugins) && IsSupportedPlugin(aMIMEType)) {
    1:     return eType_Plugin;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
    1:   if (ShouldShowDefaultPlugin(thisContent, aMIMEType)) {
    1:     return eType_Plugin;
    1:   }
    1: 
    1:   return eType_Null;
    1: }
    1: 
    1: nsresult
    1: nsObjectLoadingContent::TypeForClassID(const nsAString& aClassID,
    1:                                        nsACString& aType)
    1: {
    1:   // Need a plugin host for any class id support
29574:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
    1:   if (!pluginHost) {
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   if (StringBeginsWith(aClassID, NS_LITERAL_STRING("java:"))) {
    1:     // Supported if we have a java plugin
    1:     aType.AssignLiteral("application/x-java-vm");
    1:     nsresult rv = pluginHost->IsPluginEnabledForType("application/x-java-vm");
    1:     return NS_SUCCEEDED(rv) ? NS_OK : NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   // If it starts with "clsid:", this is ActiveX content
    1:   if (StringBeginsWith(aClassID, NS_LITERAL_STRING("clsid:"))) {
    1:     // Check if we have a plugin for that
    1: 
    1:     if (NS_SUCCEEDED(pluginHost->IsPluginEnabledForType("application/x-oleobject"))) {
    1:       aType.AssignLiteral("application/x-oleobject");
    1:       return NS_OK;
    1:     }
    1:     if (NS_SUCCEEDED(pluginHost->IsPluginEnabledForType("application/oleobject"))) {
    1:       aType.AssignLiteral("application/oleobject");
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: void
    1: nsObjectLoadingContent::GetObjectBaseURI(nsIContent* thisContent, nsIURI** aURI)
    1: {
    1:   // We want to use swap(); since this is just called from this file,
    1:   // we can assert this (callers use comptrs)
    1:   NS_PRECONDITION(*aURI == nsnull, "URI must be inited to zero");
    1: 
    1:   // For plugins, the codebase attribute is the base URI
    1:   nsCOMPtr<nsIURI> baseURI = thisContent->GetBaseURI();
    1:   nsAutoString codebase;
    1:   thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::codebase,
    1:                        codebase);
    1:   if (!codebase.IsEmpty()) {
    1:     nsContentUtils::NewURIWithDocumentCharset(aURI, codebase,
    1:                                               thisContent->GetOwnerDoc(),
    1:                                               baseURI);
    1:   } else {
    1:     baseURI.swap(*aURI);
    1:   }
    1: }
    1: 
    1: nsIObjectFrame*
13098: nsObjectLoadingContent::GetExistingFrame(FlushType aFlushType)
    1: {
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
 1792:   nsIFrame* frame;
 1792:   do {
    1:     nsIDocument* doc = thisContent->GetCurrentDoc();
    1:     if (!doc) {
    1:       return nsnull; // No current doc -> no frame
    1:     }
    1: 
  981:     nsIPresShell* shell = doc->GetPrimaryShell();
    1:     if (!shell) {
    1:       return nsnull; // No presentation -> no frame
    1:     }
    1: 
 1792:     frame = shell->GetPrimaryFrameFor(thisContent);
    1:     if (!frame) {
    1:       return nsnull;
    1:     }
    1: 
13098:     if (aFlushType == eDontFlush) {
 1792:       break;
 1792:     }
 1792:     
 1792:     // OK, let's flush out and try again.  Note that we want to reget
 1792:     // the document, etc, since flushing might run script.
 4164:     mozFlushType flushType =
13098:       aFlushType == eFlushLayout ? Flush_Layout : Flush_ContentAndNotify;
 4164:     doc->FlushPendingNotifications(flushType);
 1792: 
13098:     aFlushType = eDontFlush;
 1792:   } while (1);
 1792: 
23554:   nsIObjectFrame* objFrame = do_QueryFrame(frame);
    1:   return objFrame;
    1: }
    1: 
 5870: void
 5870: nsObjectLoadingContent::HandleBeingBlockedByContentPolicy(nsresult aStatus,
 5870:                                                           PRInt16 aRetval)
 5870: {
 5870:   // Must call UnloadContent first, as it overwrites
 5870:   // mSuppressed/mUserDisabled. It also takes care of setting the type to
 5870:   // eType_Null.
 5870:   UnloadContent();
 5870:   if (NS_SUCCEEDED(aStatus)) {
 5870:     if (aRetval == nsIContentPolicy::REJECT_TYPE) {
 5870:       mUserDisabled = PR_TRUE;
 5870:     } else if (aRetval == nsIContentPolicy::REJECT_SERVER) {
 5870:       mSuppressed = PR_TRUE;
 5870:     }
 5870:   }
 5870: }
 5870: 
    1: nsresult
 4329: nsObjectLoadingContent::TryInstantiate(const nsACString& aMIMEType,
 4329:                                        nsIURI* aURI)
    1: {
13098:   nsIObjectFrame* frame = GetExistingFrame(eFlushContent);
    1:   if (!frame) {
 4329:     LOG(("OBJLC [%p]: No frame yet\n", this));
    1:     return NS_OK; // Not a failure to have no frame
    1:   }
16715: 
16715:   nsCOMPtr<nsIPluginInstance> instance;
19629:   frame->GetPluginInstance(*getter_AddRefs(instance));
16715: 
16715:   if (!instance) {
16715:     // The frame has no plugin instance yet. If the frame hasn't been
30709:     // reflowed yet, do nothing as once the reflow happens we'll end up
16715:     // instantiating the plugin with the correct size n' all (which
16715:     // isn't known until we've done the first reflow). But if the
16715:     // frame does have a plugin instance already, be sure to
16715:     // re-instantiate the plugin as its source or whatnot might have
16715:     // chanced since it was instantiated.
23554:     nsIFrame* iframe = do_QueryFrame(frame);
 4329:     if (iframe->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
30709:       LOG(("OBJLC [%p]: Frame hasn't been reflowed yet\n", this));
 4329:       return NS_OK; // Not a failure to have no frame
 4329:     }
16715:   }
16715: 
 4329:   return Instantiate(frame, aMIMEType, aURI);
 4329: }
 4329: 
 4329: nsresult
 4329: nsObjectLoadingContent::Instantiate(nsIObjectFrame* aFrame,
 4329:                                     const nsACString& aMIMEType,
 4329:                                     nsIURI* aURI)
 4329: {
 4329:   NS_ASSERTION(aFrame, "Must have a frame here");
    1: 
14982:   // We're instantiating now, invalidate any pending async instantiate
14982:   // calls.
14982:   mPendingInstantiateEvent = nsnull;
14982: 
14982:   // Mark that we're instantiating now so that we don't end up
14982:   // re-entering instantiation code.
14982:   PRBool oldInstantiatingValue = mInstantiating;
14982:   mInstantiating = PR_TRUE;
14982: 
    1:   nsCString typeToUse(aMIMEType);
    1:   if (typeToUse.IsEmpty() && aURI) {
 3642:     IsPluginEnabledByExtension(aURI, typeToUse);
    1:   }
    1: 
33384:   nsCOMPtr<nsIContent> thisContent = 
33384:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
33384:   NS_ASSERTION(thisContent, "must be a content");
33384:   
    1:   nsCOMPtr<nsIURI> baseURI;
    1:   if (!aURI) {
    1:     // We need some URI. If we have nothing else, use the base URI.
    1:     // XXX(biesi): The code used to do this. Not sure why this is correct...
    1:     GetObjectBaseURI(thisContent, getter_AddRefs(baseURI));
    1:     aURI = baseURI;
    1:   }
    1: 
35644:   nsIFrame *nsiframe = do_QueryFrame(aFrame);
35644:   nsWeakFrame weakFrame(nsiframe);
35644: 
    1:   // We'll always have a type or a URI by the time we get here
    1:   NS_ASSERTION(aURI || !typeToUse.IsEmpty(), "Need a URI or a type");
 4329:   LOG(("OBJLC [%p]: Calling [%p]->Instantiate(<%s>, %p)\n", this, aFrame,
    1:        typeToUse.get(), aURI));
14982:   nsresult rv = aFrame->Instantiate(typeToUse.get(), aURI);
14982: 
14982:   mInstantiating = oldInstantiatingValue;
14982: 
33384:   nsCOMPtr<nsIPluginInstance> pluginInstance;
35644:   if (weakFrame.IsAlive()) {
33384:     aFrame->GetPluginInstance(*getter_AddRefs(pluginInstance));
35644:   }
33384:   if (pluginInstance) {
33384:     nsCOMPtr<nsIPluginTag> pluginTag;
33384:     nsCOMPtr<nsIPluginHost> host(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
33384:     host->GetPluginTagForInstance(pluginInstance, getter_AddRefs(pluginTag));
33384: 
33384:     nsCOMPtr<nsIBlocklistService> blocklist =
33384:       do_GetService("@mozilla.org/extensions/blocklist;1");
33384:     if (blocklist) {
33384:       PRUint32 blockState = nsIBlocklistService::STATE_NOT_BLOCKED;
33384:       blocklist->GetPluginBlocklistState(pluginTag, EmptyString(),
33384:                                          EmptyString(), &blockState);
33384:       if (blockState == nsIBlocklistService::STATE_OUTDATED)
33384:         FirePluginError(thisContent, ePluginOutdated);
33384:     }
33384:   }
33384: 
14982:   return rv;
    1: }
    1: 
12968: nsresult
12968: nsObjectLoadingContent::CheckClassifier(nsIChannel *aChannel)
12968: {
12968:   nsresult rv;
12968:   nsCOMPtr<nsIChannelClassifier> classifier =
12968:     do_CreateInstance(NS_CHANNELCLASSIFIER_CONTRACTID, &rv);
12968:   NS_ENSURE_SUCCESS(rv, rv);
12968: 
23790:   rv = classifier->Start(aChannel, PR_FALSE);
12968:   NS_ENSURE_SUCCESS(rv, rv);
12968: 
12968:   mClassifier = classifier;
12968: 
12968:   return NS_OK;
12968: }
12968: 
    1: /* static */ PRBool
    1: nsObjectLoadingContent::ShouldShowDefaultPlugin(nsIContent* aContent,
    1:                                                 const nsCString& aContentType)
    1: {
    1:   if (nsContentUtils::GetBoolPref("plugin.default_plugin_disabled", PR_FALSE)) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   return GetPluginSupportState(aContent, aContentType) == ePluginUnsupported;
    1: }
    1: 
19014: /* static */ PluginSupportState
    1: nsObjectLoadingContent::GetPluginSupportState(nsIContent* aContent,
    1:                                               const nsCString& aContentType)
    1: {
33329:   if (!aContent->IsHTML()) {
    1:     return ePluginOtherState;
    1:   }
    1: 
    1:   if (aContent->Tag() == nsGkAtoms::embed ||
    1:       aContent->Tag() == nsGkAtoms::applet) {
    1:     return GetPluginDisabledState(aContentType);
    1:   }
    1: 
13583:   PRBool hasAlternateContent = PR_FALSE;
13583: 
    1:   // Search for a child <param> with a pluginurl name
    1:   PRUint32 count = aContent->GetChildCount();
    1:   for (PRUint32 i = 0; i < count; ++i) {
    1:     nsIContent* child = aContent->GetChildAt(i);
    1:     NS_ASSERTION(child, "GetChildCount lied!");
    1: 
33329:     if (child->IsHTML() &&
13583:         child->Tag() == nsGkAtoms::param) {
13583:       if (child->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
    1:                              NS_LITERAL_STRING("pluginurl"), eIgnoreCase)) {
    1:         return GetPluginDisabledState(aContentType);
    1:       }
13583:     } else if (!hasAlternateContent) {
13583:       hasAlternateContent =
13583:         nsStyleUtil::IsSignificantChild(child, PR_TRUE, PR_FALSE);
    1:     }
13583:   }
13583: 
13583:   return hasAlternateContent ? ePluginOtherState :
13583:     GetPluginDisabledState(aContentType);
    1: }
    1: 
19014: /* static */ PluginSupportState
    1: nsObjectLoadingContent::GetPluginDisabledState(const nsCString& aContentType)
    1: {
29574:   nsCOMPtr<nsIPluginHost> host(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
    1:   if (!host) {
    1:     return ePluginUnsupported;
    1:   }
    1:   nsresult rv = host->IsPluginEnabledForType(aContentType.get());
 3464:   if (rv == NS_ERROR_PLUGIN_DISABLED)
 3464:     return ePluginDisabled;
 3464:   if (rv == NS_ERROR_PLUGIN_BLOCKLISTED)
 3464:     return ePluginBlocklisted;
 3464:   return ePluginUnsupported;
    1: }
35171: 
35581: void
35581: nsObjectLoadingContent::CreateStaticClone(nsObjectLoadingContent* aDest) const
35581: {
35581:   nsImageLoadingContent::CreateStaticImageClone(aDest);
35581: 
35581:   aDest->mType = mType;
35581:   nsObjectLoadingContent* thisObj = const_cast<nsObjectLoadingContent*>(this);
35581:   if (thisObj->mPrintFrame.IsAlive()) {
35581:     aDest->mPrintFrame = thisObj->mPrintFrame;
35581:   } else {
35581:     nsIObjectFrame* frame =
35581:       const_cast<nsObjectLoadingContent*>(this)->GetExistingFrame(eDontFlush);
35581:     nsIFrame* f = do_QueryFrame(frame);
35581:     aDest->mPrintFrame = f;
35581:   }
35581: 
35581:   if (mFrameLoader) {
35581:     nsCOMPtr<nsIContent> content =
35581:       do_QueryInterface(static_cast<nsIImageLoadingContent*>((aDest)));
35581:     nsFrameLoader* fl = nsFrameLoader::Create(content);
35581:     if (fl) {
35581:       aDest->mFrameLoader = fl;
35581:       mFrameLoader->CreateStaticClone(fl);
35581:     }
35581:   }
35581: }
35581: 
35581: NS_IMETHODIMP
35581: nsObjectLoadingContent::GetPrintFrame(nsIFrame** aFrame)
35581: {
35581:   *aFrame = mPrintFrame.GetFrame();
35581:   return NS_OK;
35581: }
35581: 
35171: NS_IMETHODIMP
35171: nsObjectLoadingContent::SetAbsoluteScreenPosition(nsIDOMElement* element,
35171:                                                   nsIDOMClientRect* position,
35171:                                                   nsIDOMClientRect* clip)
35171: {
35171:   nsIObjectFrame* frame = GetExistingFrame(eFlushLayout);
35171:   if (!frame)
35171:     return NS_ERROR_NOT_AVAILABLE;
35171: 
35171:   return frame->SetAbsoluteScreenPosition(element, position, clip);
35171: }
35171: 
35171: 
