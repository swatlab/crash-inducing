53414: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53414:  * vim: set ts=8 sw=4 et tw=79:
53414:  *
53414:  * ***** BEGIN LICENSE BLOCK *****
50491:  * Copyright (C) 2008 Apple Inc. All rights reserved.
50491:  *
50491:  * Redistribution and use in source and binary forms, with or without
50491:  * modification, are permitted provided that the following conditions
50491:  * are met:
50491:  * 1. Redistributions of source code must retain the above copyright
50491:  *    notice, this list of conditions and the following disclaimer.
50491:  * 2. Redistributions in binary form must reproduce the above copyright
50491:  *    notice, this list of conditions and the following disclaimer in the
50491:  *    documentation and/or other materials provided with the distribution.
50491:  *
50491:  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
50491:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
50491:  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
50491:  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
50491:  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
50491:  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
50491:  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
50491:  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
50491:  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
50491:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
50491:  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
53414:  * 
53414:  * ***** END LICENSE BLOCK ***** */
50491: 
50491: #ifndef X86Assembler_h
50491: #define X86Assembler_h
50491: 
50491: #include "assembler/wtf/Platform.h"
50491: 
50491: #if ENABLE_ASSEMBLER && (WTF_CPU_X86 || WTF_CPU_X86_64)
50491: 
50491: #include "AssemblerBuffer.h"
50491: #include "jsstdint.h"
50491: #include "assembler/wtf/Assertions.h"
50491: #include "jsvector.h"
50491: 
50491: #include "methodjit/Logging.h"
50491: #define IPFX  "        %s"
50491: #define ISPFX "        "
50491: #ifdef JS_METHODJIT_SPEW
50491: # define MAYBE_PAD (isOOLPath ? ">  " : "")
50491: # define PRETTY_PRINT_OFFSET(os) (((os)<0)?"-":""), (((os)<0)?-(os):(os))
50491: # define FIXME_INSN_PRINTING                                \
50491:     do {                                                    \
50491:         js::JaegerSpew(js::JSpew_Insns,                     \
50491:                        ISPFX "FIXME insn printing %s:%d\n", \
50491:                        __FILE__, __LINE__);                 \
50491:     } while (0)
50491: #else
50491: # define MAYBE_PAD ""
50491: # define FIXME_INSN_PRINTING ((void) 0)
50491: # define PRETTY_PRINT_OFFSET(os) "", 0
50491: #endif
50491: 
50491: 
50491: namespace JSC {
50491: 
50491: inline bool CAN_SIGN_EXTEND_8_32(int32_t value) { return value == (int32_t)(signed char)value; }
50491: 
50491: namespace X86Registers {
50491:     typedef enum {
50491:         eax,
50491:         ecx,
50491:         edx,
50491:         ebx,
50491:         esp,
50491:         ebp,
50491:         esi,
50491:         edi
50491: 
50491: #if WTF_CPU_X86_64
50491:        ,r8,
50491:         r9,
50491:         r10,
50491:         r11,
50491:         r12,
50491:         r13,
50491:         r14,
50491:         r15
50491: #endif
50491:     } RegisterID;
50491: 
50491:     typedef enum {
50491:         xmm0,
50491:         xmm1,
50491:         xmm2,
50491:         xmm3,
50491:         xmm4,
50491:         xmm5,
50491:         xmm6,
50491:         xmm7
50491:     } XMMRegisterID;
50491: 
50491:     static const char* nameFPReg(XMMRegisterID fpreg)
50491:     {
50491:         static const char* xmmnames[8]
50491:           = { "%xmm0", "%xmm1", "%xmm2", "%xmm3",
50491:               "%xmm4", "%xmm5", "%xmm6", "%xmm7" };
50491:         int off = (XMMRegisterID)fpreg - (XMMRegisterID)xmm0;
50491:         return (off < 0 || off > 7) ? "%xmm?" : xmmnames[off];
50491:     }
50491: 
50491:     static const char* nameIReg(int szB, RegisterID reg)
50491:     {
50491:         static const char* r64names[16]
50491:           = { "%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi",
50491:               "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15" };
50491:         static const char* r32names[16]
50491:           = { "%eax", "%ecx", "%edx", "%ebx", "%esp", "%ebp", "%esi", "%edi",
50491:               "%r8d", "%r9d", "%r10d", "%r11d", "%r12d", "%r13d", "%r14d", "%r15d" };
50491:         static const char* r16names[16]
50491:           = { "%ax", "%cx", "%dx", "%bx", "%sp", "%bp", "%si", "%di",
50491:               "%r8w", "%r9w", "%r10w", "%r11w", "%r12w", "%r13w", "%r14w", "%r15w" };
50491:         static const char* r8names[16]
50491:           = { "%al", "%cl", "%dl", "%bl", "%ah/spl", "%ch/bpl", "%dh/sil", "%bh/dil",
50491:               "%r8b", "%r9b", "%r10b", "%r11b", "%r12b", "%r13b", "%r14b", "%r15b" };
50491:         int          off = (RegisterID)reg - (RegisterID)eax;
50491:         const char** tab = r64names;
50491:         switch (szB) {
50491:             case 1: tab = r8names; break;
50491:             case 2: tab = r16names; break;
50491:             case 4: tab = r32names; break;
50491:         }
50491:         return (off < 0 || off > 15) ? "%r???" : tab[off];
50491:     }
50491: 
50491:     static const char* nameIReg(RegisterID reg)
50491:     {
50491: #       if WTF_CPU_X86_64
50491:         return nameIReg(8, reg);
50491: #       else
50491:         return nameIReg(4, reg);
50491: #       endif
50491:     }
50491: 
50491: } /* namespace X86Registers */
50491: 
50491: 
50491: class X86Assembler {
50491: public:
50491:     typedef X86Registers::RegisterID RegisterID;
50491:     typedef X86Registers::XMMRegisterID XMMRegisterID;
50491:     typedef XMMRegisterID FPRegisterID;
50491: 
50491:     typedef enum {
50491:         ConditionO,
50491:         ConditionNO,
50491:         ConditionB,
50491:         ConditionAE,
50491:         ConditionE,
50491:         ConditionNE,
50491:         ConditionBE,
50491:         ConditionA,
50491:         ConditionS,
50491:         ConditionNS,
50491:         ConditionP,
50491:         ConditionNP,
50491:         ConditionL,
50491:         ConditionGE,
50491:         ConditionLE,
50491:         ConditionG,
50491: 
50491:         ConditionC  = ConditionB,
50491:         ConditionNC = ConditionAE
50491:     } Condition;
50491: 
50491:     static const char* nameCC(Condition cc)
50491:     {
50491:         static const char* names[16]
50491:           = { "o ", "no", "b ", "ae", "e ", "ne", "be", "a ",
50491:               "s ", "ns", "p ", "np", "l ", "ge", "le", "g " };
50491:         int ix = (int)cc;
50491:         return (ix < 0 || ix > 15) ? "??" : names[ix];
50491:     }
50491: 
50491: private:
50491:     typedef enum {
50491:         OP_ADD_EvGv                     = 0x01,
50491:         OP_ADD_GvEv                     = 0x03,
50491:         OP_OR_EvGv                      = 0x09,
50491:         OP_OR_GvEv                      = 0x0B,
50491:         OP_2BYTE_ESCAPE                 = 0x0F,
53412:         OP_3BYTE_ESCAPE                 = 0x3A,
50491:         OP_AND_EvGv                     = 0x21,
50491:         OP_AND_GvEv                     = 0x23,
50491:         OP_SUB_EvGv                     = 0x29,
50491:         OP_SUB_GvEv                     = 0x2B,
50491:         PRE_PREDICT_BRANCH_NOT_TAKEN    = 0x2E,
50491:         OP_XOR_EvGv                     = 0x31,
50491:         OP_XOR_GvEv                     = 0x33,
50491:         OP_CMP_EvGv                     = 0x39,
50491:         OP_CMP_GvEv                     = 0x3B,
50491: #if WTF_CPU_X86_64
50491:         PRE_REX                         = 0x40,
50491: #endif
50491:         OP_PUSH_EAX                     = 0x50,
50491:         OP_POP_EAX                      = 0x58,
50491: #if WTF_CPU_X86
50491:         OP_PUSHA                        = 0x60,
50491:         OP_POPA                         = 0x61,
50491: #endif
50491: #if WTF_CPU_X86_64
50491:         OP_MOVSXD_GvEv                  = 0x63,
50491: #endif
50491:         PRE_OPERAND_SIZE                = 0x66,
50491:         PRE_SSE_66                      = 0x66,
50491:         OP_PUSH_Iz                      = 0x68,
50491:         OP_IMUL_GvEvIz                  = 0x69,
50491:         OP_GROUP1_EbIb                  = 0x80,
50491:         OP_GROUP1_EvIz                  = 0x81,
50491:         OP_GROUP1_EvIb                  = 0x83,
50491:         OP_TEST_EvGv                    = 0x85,
50491:         OP_XCHG_EvGv                    = 0x87,
50491:         OP_MOV_EvGv                     = 0x89,
50491:         OP_MOV_GvEv                     = 0x8B,
50491:         OP_LEA                          = 0x8D,
50491:         OP_GROUP1A_Ev                   = 0x8F,
50491:         OP_CDQ                          = 0x99,
50491:         OP_MOV_EAXOv                    = 0xA1,
50491:         OP_MOV_OvEAX                    = 0xA3,
50491:         OP_MOV_EAXIv                    = 0xB8,
50491:         OP_GROUP2_EvIb                  = 0xC1,
50491:         OP_RET                          = 0xC3,
50491:         OP_GROUP11_EvIz                 = 0xC7,
50491:         OP_INT3                         = 0xCC,
50491:         OP_GROUP2_Ev1                   = 0xD1,
50491:         OP_GROUP2_EvCL                  = 0xD3,
50491:         OP_CALL_rel32                   = 0xE8,
50491:         OP_JMP_rel32                    = 0xE9,
50491:         PRE_SSE_F2                      = 0xF2,
50491:         OP_HLT                          = 0xF4,
50491:         OP_GROUP3_EbIb                  = 0xF6,
50491:         OP_GROUP3_Ev                    = 0xF7,
50491:         OP_GROUP3_EvIz                  = 0xF7, // OP_GROUP3_Ev has an immediate, when instruction is a test. 
50491:         OP_GROUP5_Ev                    = 0xFF
50491:     } OneByteOpcodeID;
50491: 
50491:     typedef enum {
50491:         OP2_MOVSD_VsdWsd    = 0x10,
50491:         OP2_MOVSD_WsdVsd    = 0x11,
50491:         OP2_UNPCKLPS_VsdWsd = 0x14,
50491:         OP2_CVTSI2SD_VsdEd  = 0x2A,
50491:         OP2_CVTTSD2SI_GdWsd = 0x2C,
50491:         OP2_UCOMISD_VsdWsd  = 0x2E,
50491:         OP2_ADDSD_VsdWsd    = 0x58,
50491:         OP2_MULSD_VsdWsd    = 0x59,
50491:         OP2_SUBSD_VsdWsd    = 0x5C,
50491:         OP2_DIVSD_VsdWsd    = 0x5E,
50491:         OP2_SQRTSD_VsdWsd   = 0x51,
50491:         OP2_XORPD_VpdWpd    = 0x57,
50491:         OP2_MOVD_VdEd       = 0x6E,
50491:         OP2_MOVD_EdVd       = 0x7E,
50491:         OP2_JCC_rel32       = 0x80,
50491:         OP_SETCC            = 0x90,
50491:         OP2_IMUL_GvEv       = 0xAF,
50491:         OP2_MOVZX_GvEb      = 0xB6,
50491:         OP2_MOVZX_GvEw      = 0xB7,
50491:         OP2_PEXTRW_GdUdIb   = 0xC5
50491:     } TwoByteOpcodeID;
50491: 
53412:     typedef enum {
53412:         OP3_PINSRD_VsdWsd   = 0x22
53412:     } ThreeByteOpcodeID;
53412: 
50491:     TwoByteOpcodeID jccRel32(Condition cond)
50491:     {
50491:         return (TwoByteOpcodeID)(OP2_JCC_rel32 + cond);
50491:     }
50491: 
50491:     TwoByteOpcodeID setccOpcode(Condition cond)
50491:     {
50491:         return (TwoByteOpcodeID)(OP_SETCC + cond);
50491:     }
50491: 
50491:     typedef enum {
50491:         GROUP1_OP_ADD = 0,
50491:         GROUP1_OP_OR  = 1,
50491:         GROUP1_OP_ADC = 2,
50491:         GROUP1_OP_AND = 4,
50491:         GROUP1_OP_SUB = 5,
50491:         GROUP1_OP_XOR = 6,
50491:         GROUP1_OP_CMP = 7,
50491: 
50491:         GROUP1A_OP_POP = 0,
50491: 
50491:         GROUP2_OP_SHL = 4,
50491:         GROUP2_OP_SHR = 5,
50491:         GROUP2_OP_SAR = 7,
50491: 
50491:         GROUP3_OP_TEST = 0,
50491:         GROUP3_OP_NOT  = 2,
50491:         GROUP3_OP_NEG  = 3,
50491:         GROUP3_OP_IDIV = 7,
50491: 
50491:         GROUP5_OP_CALLN = 2,
50491:         GROUP5_OP_JMPN  = 4,
50491:         GROUP5_OP_PUSH  = 6,
50491: 
50491:         GROUP11_MOV = 0
50491:     } GroupOpcodeID;
50491:     
50491:     class X86InstructionFormatter;
50491: public:
50491: 
55524: #ifdef JS_METHODJIT_SPEW
50491:     bool isOOLPath;
50491: #endif
50491: 
50491:     class JmpSrc {
50491:         friend class X86Assembler;
50491:         friend class X86InstructionFormatter;
50491:     public:
50491:         JmpSrc()
50491:             : m_offset(-1)
50491:         {
50491:         }
50491: 
50491:     private:
50491:         JmpSrc(int offset)
50491:             : m_offset(offset)
50491:         {
50491:         }
50491: 
50491:         int m_offset;
50491:     };
50491:     
50491:     class JmpDst {
50491:         friend class X86Assembler;
50491:         friend class X86InstructionFormatter;
50491:     public:
50491:         JmpDst()
50491:             : m_offset(-1)
50491:             , m_used(false)
50491:         {
50491:         }
50491: 
50491:         bool isUsed() const { return m_used; }
50491:         void used() { m_used = true; }
50491:         bool isValid() const { return m_offset != -1; }
50491:     private:
50491:         JmpDst(int offset)
50491:             : m_offset(offset)
50491:             , m_used(false)
50491:         {
50491:             ASSERT(m_offset == offset);
50491:         }
50491: 
50491:         signed int m_offset : 31;
50491:         bool m_used : 1;
50491:     };
50491: 
50491:     X86Assembler()
55524: #ifdef JS_METHODJIT_SPEW
50491:       : isOOLPath(false)
50491: #endif
50491:     {
50491:     }
50491: 
50491:     size_t size() const { return m_formatter.size(); }
50491:     unsigned char *buffer() const { return m_formatter.buffer(); }
56037:     bool oom() const { return m_formatter.oom(); }
50491: 
50491:     // Stack operations:
50491: 
50491:     void push_r(RegisterID reg)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "push       %s\n", MAYBE_PAD, nameIReg(reg));
50491:         m_formatter.oneByteOp(OP_PUSH_EAX, reg);
50491:     }
50491: 
50491:     void pop_r(RegisterID reg)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "pop        %s\n", MAYBE_PAD, nameIReg(reg));
50491:         m_formatter.oneByteOp(OP_POP_EAX, reg);
50491:     }
50491: 
50491:     void push_i32(int imm)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_PUSH_Iz);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491:     void push_m(int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "push       %s0x%x(%s)\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_PUSH, base, offset);
50491:     }
50491: 
50491:     void pop_m(int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_GROUP1A_Ev, GROUP1A_OP_POP, base, offset);
50491:     }
50491: 
50491:     // Arithmetic operations:
50491: 
50491: #if !WTF_CPU_X86_64
50491:     void adcl_im(int imm, void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_ADC, addr);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_ADC, addr);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #endif
50491: 
50491:     void addl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "addl       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4,src), nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_ADD_EvGv, src, dst);
50491:     }
50491: 
50491:     void addl_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_ADD_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void addl_rm(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_ADD_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void addl_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "addl       $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(4,dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_ADD, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_ADD, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void addl_im(int imm, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "addl       %d, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        imm, PRETTY_PRINT_OFFSET(offset), nameIReg(8,base));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_ADD, base, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_ADD, base, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void addq_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp64(OP_ADD_EvGv, src, dst);
50491:     }
50491: 
50491:     void addq_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "addq       $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(8,dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_ADD, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_ADD, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void addq_im(int imm, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "addq       $0x%x, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        imm, PRETTY_PRINT_OFFSET(offset), nameIReg(8,base));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_ADD, base, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_ADD, base, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #else
50491:     void addl_im(int imm, void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_ADD, addr);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_ADD, addr);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #endif
50491: 
50491:     void andl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "andl       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4,src), nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_AND_EvGv, src, dst);
50491:     }
50491: 
50491:     void andl_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_AND_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void andl_rm(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_AND_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void andl_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "andl       $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(4,dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_AND, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_AND, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void andl_im(int imm, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_AND, base, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_AND, base, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void andq_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "andq       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(8,src), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_AND_EvGv, src, dst);
50491:     }
50491: 
50491:     void andq_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "andq       %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(8,base), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_AND_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void orq_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "orq        %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(8,base), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_OR_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void andq_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "andq       $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(8,dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_AND, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_AND, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #else
50491:     void andl_im(int imm, void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_AND, addr);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_AND, addr);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #endif
50491: 
50491:     void negl_r(RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "negl       %s\n", MAYBE_PAD, nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_NEG, dst);
50491:     }
50491: 
50491:     void negl_m(int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_NEG, base, offset);
50491:     }
50491: 
50491:     void notl_r(RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "notl       %s\n", MAYBE_PAD, nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_NOT, dst);
50491:     }
50491: 
50491:     void notl_m(int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_NOT, base, offset);
50491:     }
50491: 
50491:     void orl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "orl        %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4,src), nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_OR_EvGv, src, dst);
50491:     }
50491: 
50491:     void orl_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_OR_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void orl_rm(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_OR_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void orl_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "orl        $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(4,dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_OR, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_OR, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void orl_im(int imm, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_OR, base, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_OR, base, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void orq_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "orq        %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(8,src), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_OR_EvGv, src, dst);
50491:     }
50491: 
50491:     void orq_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "orq        $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(8,dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_OR, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_OR, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void notq_r(RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "notq       %s\n", MAYBE_PAD, nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_GROUP3_Ev, GROUP3_OP_NOT, dst);
50491:     }
50491: #else
50491:     void orl_im(int imm, void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_OR, addr);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_OR, addr);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #endif
50491: 
50491:     void subl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "subl       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4,src), nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_SUB_EvGv, src, dst);
50491:     }
50491: 
50491:     void subl_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_SUB_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void subl_rm(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_SUB_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void subl_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "subl       $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(4, dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_SUB, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_SUB, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491:     
50491:     void subl_im(int imm, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "subl       $0x%x, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        imm, PRETTY_PRINT_OFFSET(offset), nameIReg(4, base));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_SUB, base, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_SUB, base, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void subq_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp64(OP_SUB_EvGv, src, dst);
50491:     }
50491: 
50491:     void subq_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "subq       $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(8,dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_SUB, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_SUB, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #else
50491:     void subl_im(int imm, void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_SUB, addr);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_SUB, addr);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #endif
50491: 
50491:     void xorl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "xorl       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4,src), nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_XOR_EvGv, src, dst);
50491:     }
50491: 
50491:     void xorl_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_XOR_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void xorl_rm(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_XOR_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void xorl_im(int imm, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_XOR, base, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_XOR, base, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void xorl_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "xorl       %d, %s\n", MAYBE_PAD,
50491:                        imm, nameIReg(4,dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_XOR, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_XOR, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void xorq_rr(RegisterID src, RegisterID dst)
50491:     {
53477:         js::JaegerSpew(js::JSpew_Insns,
53477:                        IPFX "xorq       %s, %s\n", MAYBE_PAD,
56231:                        nameIReg(8,src), nameIReg(8, dst));
50491:         m_formatter.oneByteOp64(OP_XOR_EvGv, src, dst);
50491:     }
50491: 
50491:     void xorq_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "xorq       %d, %s\n", MAYBE_PAD,
50491:                        imm, nameIReg(8,dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_XOR, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_XOR, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #endif
50491: 
50491:     void sarl_i8r(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "sarl       $%d, %s\n", MAYBE_PAD, imm, nameIReg(4, dst));
50491:         if (imm == 1)
50491:             m_formatter.oneByteOp(OP_GROUP2_Ev1, GROUP2_OP_SAR, dst);
50491:         else {
50491:             m_formatter.oneByteOp(OP_GROUP2_EvIb, GROUP2_OP_SAR, dst);
50491:             m_formatter.immediate8(imm);
50491:         }
50491:     }
50491: 
50491:     void sarl_CLr(RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "sarl       %%cl, %s\n", MAYBE_PAD, nameIReg(4, dst));
50491:         m_formatter.oneByteOp(OP_GROUP2_EvCL, GROUP2_OP_SAR, dst);
50491:     }
50491:     
50491:     void shrl_i8r(int imm, RegisterID dst)
50491:     {
50491:         if (imm == 1)
50491:             m_formatter.oneByteOp(OP_GROUP2_Ev1, GROUP2_OP_SHR, dst);
50491:         else {
50491:             m_formatter.oneByteOp(OP_GROUP2_EvIb, GROUP2_OP_SHR, dst);
50491:             m_formatter.immediate8(imm);
50491:         }
50491:     }
50491:     
50491:     void shrl_CLr(RegisterID dst)
50491:     {
50491:         m_formatter.oneByteOp(OP_GROUP2_EvCL, GROUP2_OP_SHR, dst);
50491:     }
50491: 
50491:     void shll_i8r(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "shll       $%d, %s\n", MAYBE_PAD, imm, nameIReg(4, dst));
50491:         if (imm == 1)
50491:             m_formatter.oneByteOp(OP_GROUP2_Ev1, GROUP2_OP_SHL, dst);
50491:         else {
50491:             m_formatter.oneByteOp(OP_GROUP2_EvIb, GROUP2_OP_SHL, dst);
50491:             m_formatter.immediate8(imm);
50491:         }
50491:     }
50491: 
50491:     void shll_CLr(RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "shll       %%cl, %s\n", MAYBE_PAD, nameIReg(4, dst));
50491:         m_formatter.oneByteOp(OP_GROUP2_EvCL, GROUP2_OP_SHL, dst);
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void sarq_CLr(RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp64(OP_GROUP2_EvCL, GROUP2_OP_SAR, dst);
50491:     }
50491: 
50491:     void sarq_i8r(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "sarq       $%d, %s\n", MAYBE_PAD, imm, nameIReg(8, dst));
50491:         if (imm == 1)
50491:             m_formatter.oneByteOp64(OP_GROUP2_Ev1, GROUP2_OP_SAR, dst);
50491:         else {
50491:             m_formatter.oneByteOp64(OP_GROUP2_EvIb, GROUP2_OP_SAR, dst);
50491:             m_formatter.immediate8(imm);
50491:         }
50491:     }
50491: 
50491:     void shlq_i8r(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "shlq       $%d, %s\n", MAYBE_PAD, imm, nameIReg(8, dst));
50491:         if (imm == 1)
50491:             m_formatter.oneByteOp64(OP_GROUP2_Ev1, GROUP2_OP_SHL, dst);
50491:         else {
50491:             m_formatter.oneByteOp64(OP_GROUP2_EvIb, GROUP2_OP_SHL, dst);
50491:             m_formatter.immediate8(imm);
50491:         }
50491:     }
50491: #endif
50491: 
50491:     void imull_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "imull       %s, %s\n", MAYBE_PAD, nameIReg(4,src), nameIReg(4, dst));
50491:         m_formatter.twoByteOp(OP2_IMUL_GvEv, dst, src);
50491:     }
50491: 
50491:     void imull_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(OP2_IMUL_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void imull_i32r(RegisterID src, int32_t value, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_IMUL_GvEvIz, dst, src);
50491:         m_formatter.immediate32(value);
50491:     }
50491: 
50491:     void idivl_r(RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "idivl      %s\n", MAYBE_PAD, 
50491:                        nameIReg(4, dst));
50491:         m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_IDIV, dst);
50491:     }
50491: 
50491:     // Comparisons:
50491: 
50491:     void cmpl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpl       %s, %s\n", MAYBE_PAD, 
50491:                        nameIReg(4, src), nameIReg(4, dst));
50491:         m_formatter.oneByteOp(OP_CMP_EvGv, src, dst);
50491:     }
50491: 
50491:     void cmpl_rm(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpl       %s, %s0x%x(%s)\n", MAYBE_PAD, 
50491:                        nameIReg(4, src), PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp(OP_CMP_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void cmpl_mr(int offset, RegisterID base, RegisterID src)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpl       %s0x%x(%s), %s\n", MAYBE_PAD, 
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(4, base), nameIReg(src));
50491:         m_formatter.oneByteOp(OP_CMP_GvEv, src, base, offset);
50491:     }
50491: 
50491:     void cmpl_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpl       $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(4, dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void cmpl_ir_force32(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpl       $0x%x, %s\n", MAYBE_PAD, imm, nameIReg(4, dst));
50491:         m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, dst);
50491:         m_formatter.immediate32(imm);
50491:     }
50491:     
50491:     void cmpl_im(int imm, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpl       $0x%x, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        imm, PRETTY_PRINT_OFFSET(offset), nameIReg(4,base));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491:     
50491:     void cmpb_im(int imm, int offset, RegisterID base)
50491:     {
50491:         m_formatter.oneByteOp(OP_GROUP1_EbIb, GROUP1_OP_CMP, base, offset);
50491:         m_formatter.immediate8(imm);
50491:     }
50491:     
50491:     void cmpb_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         m_formatter.oneByteOp(OP_GROUP1_EbIb, GROUP1_OP_CMP, base, index, scale, offset);
50491:         m_formatter.immediate8(imm);
50491:     }
50491: 
50491:     void cmpl_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpl       %d, %d(%s,%s,%d)\n", MAYBE_PAD,
50491:                        imm, offset, nameIReg(4,base), nameIReg(4,index), scale);
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, index, scale, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, index, scale, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void cmpl_im_force32(int imm, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, offset);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void cmpq_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpq       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(8, src), nameIReg(8, dst));
50491:         m_formatter.oneByteOp64(OP_CMP_EvGv, src, dst);
50491:     }
50491: 
50491:     void cmpq_rm(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpq       %s, %d(%s)\n", MAYBE_PAD,
50491:                        nameIReg(8, src), offset, nameIReg(8, base));
50491:         m_formatter.oneByteOp64(OP_CMP_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void cmpq_mr(int offset, RegisterID base, RegisterID src)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpq       %d(%s), %s\n", MAYBE_PAD,
50491:                        offset, nameIReg(8, base), nameIReg(8, src));
50491:         m_formatter.oneByteOp64(OP_CMP_GvEv, src, base, offset);
50491:     }
50491: 
50491:     void cmpq_ir(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cmpq       %d, %s\n", MAYBE_PAD,
50491:                        imm, nameIReg(8, dst));
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_CMP, dst);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_CMP, dst);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void cmpq_im(int imm, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: 
50491:     void cmpq_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, index, scale, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, index, scale, offset);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #else
50491:     void cmpl_rm(RegisterID reg, void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_CMP_EvGv, reg, addr);
50491:     }
50491: 
50491:     void cmpl_im(int imm, void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, addr);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, addr);
50491:             m_formatter.immediate32(imm);
50491:         }
50491:     }
50491: #endif
50491: 
50491:     void cmpw_rm(RegisterID src, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.prefix(PRE_OPERAND_SIZE);
50491:         m_formatter.oneByteOp(OP_CMP_EvGv, src, base, index, scale, offset);
50491:     }
50491: 
50491:     void cmpw_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (CAN_SIGN_EXTEND_8_32(imm)) {
50491:             m_formatter.prefix(PRE_OPERAND_SIZE);
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, index, scale, offset);
50491:             m_formatter.immediate8(imm);
50491:         } else {
50491:             m_formatter.prefix(PRE_OPERAND_SIZE);
50491:             m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, index, scale, offset);
50491:             m_formatter.immediate16(imm);
50491:         }
50491:     }
50491: 
50491:     void testl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "testl      %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4,src), nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_TEST_EvGv, src, dst);
50491:     }
50491:     
50491:     void testl_i32r(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "testl      $0x%x, %s\n", MAYBE_PAD,
50491:                        imm, nameIReg(dst));
50491:         m_formatter.oneByteOp(OP_GROUP3_EvIz, GROUP3_OP_TEST, dst);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491:     void testl_i32m(int imm, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "testl      $0x%x, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        imm, PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp(OP_GROUP3_EvIz, GROUP3_OP_TEST, base, offset);
50491:         m_formatter.immediate32(imm);
50491:     }
50491:     
50491:     void testb_im(int imm, int offset, RegisterID base)
50491:     {
50491:         m_formatter.oneByteOp(OP_GROUP3_EbIb, GROUP3_OP_TEST, base, offset);
50491:         m_formatter.immediate8(imm);
50491:     }
50491:     
50491:     void testb_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         m_formatter.oneByteOp(OP_GROUP3_EbIb, GROUP3_OP_TEST, base, index, scale, offset);
50491:         m_formatter.immediate8(imm);
50491:     }
50491: 
50491:     void testl_i32m(int imm, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_GROUP3_EvIz, GROUP3_OP_TEST, base, index, scale, offset);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void testq_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "testq      %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(8,src), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_TEST_EvGv, src, dst);
50491:     }
50491: 
50491:     void testq_i32r(int imm, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp64(OP_GROUP3_EvIz, GROUP3_OP_TEST, dst);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491:     void testq_i32m(int imm, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "testq      $0x%x, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        imm, PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp64(OP_GROUP3_EvIz, GROUP3_OP_TEST, base, offset);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491:     void testq_i32m(int imm, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp64(OP_GROUP3_EvIz, GROUP3_OP_TEST, base, index, scale, offset);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: #endif 
50491: 
50491:     void testw_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.prefix(PRE_OPERAND_SIZE);
50491:         m_formatter.oneByteOp(OP_TEST_EvGv, src, dst);
50491:     }
50491:     
50491:     void testb_i8r(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "testb      $0x%x, %s\n", MAYBE_PAD,
50491:                        imm, nameIReg(1,dst));
50491:         m_formatter.oneByteOp8(OP_GROUP3_EbIb, GROUP3_OP_TEST, dst);
50491:         m_formatter.immediate8(imm);
50491:     }
50491: 
50491:     void setCC_r(Condition cond, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "set%s      %s\n", MAYBE_PAD,
50491:                        nameCC(cond), nameIReg(1,dst));
50491:         m_formatter.twoByteOp8(setccOpcode(cond), (GroupOpcodeID)0, dst);
50491:     }
50491: 
50491:     void sete_r(RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp8(setccOpcode(ConditionE), (GroupOpcodeID)0, dst);
50491:     }
50491: 
50491:     void setz_r(RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         sete_r(dst);
50491:     }
50491: 
50491:     void setne_r(RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp8(setccOpcode(ConditionNE), (GroupOpcodeID)0, dst);
50491:     }
50491: 
50491:     void setnz_r(RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         setne_r(dst);
50491:     }
50491: 
50491:     // Various move ops:
50491: 
50491:     void cdq()
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cdq              \n", MAYBE_PAD);
50491:         m_formatter.oneByteOp(OP_CDQ);
50491:     }
50491: 
50491:     void xchgl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "xchgl      %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4,src), nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_XCHG_EvGv, src, dst);
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void xchgq_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "xchgq      %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(8,src), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_XCHG_EvGv, src, dst);
50491:     }
50491: #endif
50491: 
50491:     void movl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movl       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4,src), nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_MOV_EvGv, src, dst);
50491:     }
50491:     
50491:     void movl_rm(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movl       %s, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        nameIReg(4,src), PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp(OP_MOV_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void movl_rm_disp32(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp_disp32(OP_MOV_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void movl_rm(RegisterID src, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movl       %s, %d(%s,%s,%d)\n", MAYBE_PAD, 
50491:                        nameIReg(4, src), offset, nameIReg(base), nameIReg(index), scale);
50491:         m_formatter.oneByteOp(OP_MOV_EvGv, src, base, index, scale, offset);
50491:     }
50491:     
50491:     void movl_mEAX(void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_MOV_EAXOv);
50491: #if WTF_CPU_X86_64
50491:         m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
50491: #else
50491:         m_formatter.immediate32(reinterpret_cast<int>(addr));
50491: #endif
50491:     }
50491: 
50491:     void movl_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movl       %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameIReg(4, dst));
50491:         m_formatter.oneByteOp(OP_MOV_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void movl_mr_disp32(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp_disp32(OP_MOV_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void movl_mr(int offset, RegisterID base, RegisterID index, int scale, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movl       %d(%s,%s,%d), %s\n", MAYBE_PAD,
50491:                        offset, nameIReg(base), nameIReg(index), scale, nameIReg(4, dst));
50491:         m_formatter.oneByteOp(OP_MOV_GvEv, dst, base, index, scale, offset);
50491:     }
50491: 
50491:     void movl_i32r(int imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movl       $0x%x, %s\n", MAYBE_PAD,
50491:                        imm, nameIReg(dst));
50491:         m_formatter.oneByteOp(OP_MOV_EAXIv, dst);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491:     void movl_i32m(int imm, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movl       $0x%x, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        imm, PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp(OP_GROUP11_EvIz, GROUP11_MOV, base, offset);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491:     void movl_i32m(int imm, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movl       $0x%x, %d(%s,%s,%d)\n", MAYBE_PAD,
50491:                        imm, offset, nameIReg(base), nameIReg(index), scale);
50491:         m_formatter.oneByteOp(OP_GROUP11_EvIz, GROUP11_MOV, base, index, scale, offset);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491:     void movl_EAXm(void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_MOV_OvEAX);
50491: #if WTF_CPU_X86_64
50491:         m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
50491: #else
50491:         m_formatter.immediate32(reinterpret_cast<int>(addr));
50491: #endif
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void movq_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movq       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(8,src), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_MOV_EvGv, src, dst);
50491:     }
50491: 
50491:     void movq_rm(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movq       %s, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        nameIReg(8,src), PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp64(OP_MOV_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void movq_rm_disp32(RegisterID src, int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp64_disp32(OP_MOV_EvGv, src, base, offset);
50491:     }
50491: 
50491:     void movq_rm(RegisterID src, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movq       %s, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        nameIReg(8,src), PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp64(OP_MOV_EvGv, src, base, index, scale, offset);
50491:     }
50491: 
50491:     void movq_mEAX(void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp64(OP_MOV_EAXOv);
50491:         m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
50491:     }
50491: 
50491:     void movq_EAXm(void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp64(OP_MOV_OvEAX);
50491:         m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
50491:     }
50491: 
50491:     void movq_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX  "movq       %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_MOV_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void movq_mr_disp32(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp64_disp32(OP_MOV_GvEv, dst, base, offset);
50491:     }
50491: 
50491:     void movq_mr(int offset, RegisterID base, RegisterID index, int scale, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movq       %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_MOV_GvEv, dst, base, index, scale, offset);
50491:     }
50491: 
50491:     void leaq_mr(int offset, RegisterID base, RegisterID index, int scale, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "leaq       %d(%s,%s,%d), %s\n", MAYBE_PAD,
50491:                        offset, nameIReg(base), nameIReg(index), scale, nameIReg(8,dst)),
50491:         m_formatter.oneByteOp64(OP_LEA, dst, base, index, scale, offset);
50491:     }
50491: 
50491:     void movq_i32m(int imm, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX  "movq       $%d, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        imm, PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp64(OP_GROUP11_EvIz, GROUP11_MOV, base, offset);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491:     void movq_i32m(int imm, int offset, RegisterID base, RegisterID index, int scale)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX  "movq       $%d, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        imm, PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.oneByteOp64(OP_GROUP11_EvIz, GROUP11_MOV, base, index, scale, offset);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: 
50491:     void movq_i64r(int64_t imm, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movabsq    $0x%llx, %s\n", MAYBE_PAD,
50491:                        (unsigned long long int)imm, nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_MOV_EAXIv, dst);
50491:         m_formatter.immediate64(imm);
50491:     }
50491:     
50491:     void movsxd_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movsxd     %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4, src), nameIReg(8, dst));
50491:         m_formatter.oneByteOp64(OP_MOVSXD_GvEv, dst, src);
50491:     }
50491:     
50491:     
50491: #else
50491:     void movl_rm(RegisterID src, void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         if (src == X86Registers::eax)
50491:             movl_EAXm(addr);
50491:         else 
50491:             m_formatter.oneByteOp(OP_MOV_EvGv, src, addr);
50491:     }
50491:     
50491:     void movl_mr(void* addr, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movl       0(%p), %s\n", MAYBE_PAD,
50491:                        addr, nameIReg(4, dst));
50491:         if (dst == X86Registers::eax)
50491:             movl_mEAX(addr);
50491:         else
50491:             m_formatter.oneByteOp(OP_MOV_GvEv, dst, addr);
50491:     }
50491: 
50491:     void movl_i32m(int imm, void* addr)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_GROUP11_EvIz, GROUP11_MOV, addr);
50491:         m_formatter.immediate32(imm);
50491:     }
50491: #endif
50491: 
50491:     void movzwl_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movzwl     %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameIReg(4, dst));
50491:         m_formatter.twoByteOp(OP2_MOVZX_GvEw, dst, base, offset);
50491:     }
50491: 
50491:     void movzwl_mr(int offset, RegisterID base, RegisterID index, int scale, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(OP2_MOVZX_GvEw, dst, base, index, scale, offset);
50491:     }
50491: 
50491:     void movzbl_rr(RegisterID src, RegisterID dst)
50491:     {
50491:         // In 64-bit, this may cause an unnecessary REX to be planted (if the dst register
50491:         // is in the range ESP-EDI, and the src would not have required a REX).  Unneeded
50491:         // REX prefixes are defined to be silently ignored by the processor.
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movzbl      %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(4,src), nameIReg(4,dst));
50491:         m_formatter.twoByteOp8(OP2_MOVZX_GvEb, dst, src);
50491:     }
50491: 
50491:     void leal_mr(int offset, RegisterID base, RegisterID index, int scale, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "leal       %d(%s,%s,%d), %s\n", MAYBE_PAD,
50491:                        offset, nameIReg(base), nameIReg(index), scale, nameIReg(dst));
50491:         m_formatter.oneByteOp(OP_LEA, dst, base, index, scale, offset);
50491:     }
50491: 
50491:     void leal_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "leal       %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameIReg(4,dst));
50491:         m_formatter.oneByteOp(OP_LEA, dst, base, offset);
50491:     }
50491: #if WTF_CPU_X86_64
50491:     void leaq_mr(int offset, RegisterID base, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "leaq       %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameIReg(8,dst));
50491:         m_formatter.oneByteOp64(OP_LEA, dst, base, offset);
50491:     }
50491: #endif
50491: 
50491:     // Flow control:
50491: 
50491:     JmpSrc call()
50491:     {
50491:         m_formatter.oneByteOp(OP_CALL_rel32);
50491:         JmpSrc r = m_formatter.immediateRel32();
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "call       ((%d))\n", MAYBE_PAD, r.m_offset);
50491:         return r;
50491:     }
50491:     
50491:     JmpSrc call(RegisterID dst)
50491:     {
50491:         m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_CALLN, dst);
50491:         JmpSrc r = JmpSrc(m_formatter.size());
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "call       *%s\n", MAYBE_PAD, nameIReg(dst));
50491:         return r;
50491:     }
50491:     
50491:     void call_m(int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_CALLN, base, offset);
50491:     }
50491: 
50491:     JmpSrc jmp()
50491:     {
50491:         m_formatter.oneByteOp(OP_JMP_rel32);
50491:         JmpSrc r = m_formatter.immediateRel32();
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "jmp        ((%d))\n", MAYBE_PAD, r.m_offset);
50491:         return r;
50491:     }
50491:     
50491:     // Return a JmpSrc so we have a label to the jump, so we can use this
50491:     // To make a tail recursive call on x86-64.  The MacroAssembler
50491:     // really shouldn't wrap this as a Jump, since it can't be linked. :-/
50491:     JmpSrc jmp_r(RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "jmp        ((%s))\n", MAYBE_PAD,
50491:            nameIReg(dst));
50491:         m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_JMPN, dst);
50491:         return JmpSrc(m_formatter.size());
50491:     }
50491:     
50491:     void jmp_m(int offset, RegisterID base)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_JMPN, base, offset);
50491:     }
50491: 
50491:     JmpSrc jne()
50491:     {
50491:         return jCC(ConditionNE);
50491:     }
50491:     
50491:     JmpSrc jnz()
50491:     {
50491:         // printing done by jne()
50491:         return jne();
50491:     }
50491: 
50491:     JmpSrc je()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionE));
50491:         return m_formatter.immediateRel32();
50491:     }
50491:     
50491:     JmpSrc jz()
50491:     {
50491:         // printing done by je()
50491:         return je();
50491:     }
50491: 
50491:     JmpSrc jl()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionL));
50491:         return m_formatter.immediateRel32();
50491:     }
50491:     
50491:     JmpSrc jb()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionB));
50491:         return m_formatter.immediateRel32();
50491:     }
50491:     
50491:     JmpSrc jle()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionLE));
50491:         return m_formatter.immediateRel32();
50491:     }
50491:     
50491:     JmpSrc jbe()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionBE));
50491:         return m_formatter.immediateRel32();
50491:     }
50491:     
50491:     JmpSrc jge()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionGE));
50491:         return m_formatter.immediateRel32();
50491:     }
50491: 
50491:     JmpSrc jg()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionG));
50491:         return m_formatter.immediateRel32();
50491:     }
50491: 
50491:     JmpSrc ja()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionA));
50491:         return m_formatter.immediateRel32();
50491:     }
50491:     
50491:     JmpSrc jae()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionAE));
50491:         return m_formatter.immediateRel32();
50491:     }
50491:     
50491:     JmpSrc jo()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionO));
50491:         return m_formatter.immediateRel32();
50491:     }
50491: 
50491:     JmpSrc jp()
50491:     {
50491:         return jCC(ConditionP);
50491:     }
50491:     
50491:     JmpSrc js()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.twoByteOp(jccRel32(ConditionS));
50491:         return m_formatter.immediateRel32();
50491:     }
50491: 
50491:     JmpSrc jCC(Condition cond)
50491:     {
50491:         m_formatter.twoByteOp(jccRel32(cond));
50491:         JmpSrc r = m_formatter.immediateRel32();
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "j%s        ((%d))\n", MAYBE_PAD,
50491:                        nameCC(cond), r.m_offset);
50491:         return r;
50491:     }
50491: 
50491:     // SSE operations:
50491: 
50491:     void addsd_rr(XMMRegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "addsd      %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_ADDSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
50491:     }
50491: 
50491:     void addsd_mr(int offset, RegisterID base, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "addsd      %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_ADDSD_VsdWsd, (RegisterID)dst, base, offset);
50491:     }
50491: 
50491:     void cvtsi2sd_rr(RegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cvtsi2sd   %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_CVTSI2SD_VsdEd, (RegisterID)dst, src);
50491:     }
50491: 
50491:     void cvtsi2sd_mr(int offset, RegisterID base, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cvtsi2sd   %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_CVTSI2SD_VsdEd, (RegisterID)dst, base, offset);
50491:     }
50491: 
50491: #if !WTF_CPU_X86_64
50491:     void cvtsi2sd_mr(void* address, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cvtsi2sd   %p, %s\n", MAYBE_PAD,
50491:                        address, nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_CVTSI2SD_VsdEd, (RegisterID)dst, address);
50491:     }
50491: #endif
50491: 
50491:     void cvttsd2si_rr(XMMRegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "cvttsd2si  %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameIReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_CVTTSD2SI_GdWsd, dst, (RegisterID)src);
50491:     }
50491: 
50491:     void unpcklps_rr(XMMRegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "unpcklps   %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameFPReg(dst));
50491:         m_formatter.twoByteOp(OP2_UNPCKLPS_VsdWsd, (RegisterID)dst, (RegisterID)src);
50491:     }
50491: 
50491:     void movd_rr(RegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movd       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_66);
50491:         m_formatter.twoByteOp(OP2_MOVD_VdEd, (RegisterID)dst, src);
50491:     }
50491: 
50491: #if WTF_CPU_X86_64
50491:     void movq_rr(XMMRegisterID src, RegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movq       %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameIReg(dst));
50491:         m_formatter.prefix(PRE_SSE_66);
50491:         m_formatter.twoByteOp64(OP2_MOVD_EdVd, (RegisterID)src, dst);
50491:     }
50491: 
50491:     void movq_rr(RegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movq       %s, %s\n", MAYBE_PAD,
50491:                        nameIReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_66);
50491:         m_formatter.twoByteOp64(OP2_MOVD_VdEd, (RegisterID)dst, src);
50491:     }
50491: #endif
50491: 
50491:     void movsd_rm(XMMRegisterID src, int offset, RegisterID base)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movsd      %s, %s0x%x(%s)\n", MAYBE_PAD,
50491:                        nameFPReg(src), PRETTY_PRINT_OFFSET(offset), nameIReg(base));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_MOVSD_WsdVsd, (RegisterID)src, base, offset);
50491:     }
50491: 
50491:     void movsd_mr(int offset, RegisterID base, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movsd      %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_MOVSD_VsdWsd, (RegisterID)dst, base, offset);
50491:     }
50491: 
50491:     void movsd_rr(XMMRegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movsd      %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_MOVSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
50491:     }
50491: 
50491: #if !WTF_CPU_X86_64
50491:     void movsd_mr(const void* address, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "movsd      %p, %s\n", MAYBE_PAD,
50491:                        address, nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_MOVSD_VsdWsd, (RegisterID)dst, address);
50491:     }
50491: #endif
50491: 
50491:     void mulsd_rr(XMMRegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "mulsd      %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_MULSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
50491:     }
50491: 
50491:     void mulsd_mr(int offset, RegisterID base, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "mulsd      %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_MULSD_VsdWsd, (RegisterID)dst, base, offset);
50491:     }
50491: 
50491:     void pextrw_irr(int whichWord, XMMRegisterID src, RegisterID dst)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.prefix(PRE_SSE_66);
50491:         m_formatter.twoByteOp(OP2_PEXTRW_GdUdIb, (RegisterID)dst, (RegisterID)src);
50491:         m_formatter.immediate8(whichWord);
50491:     }
50491: 
50491:     void subsd_rr(XMMRegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "subsd      %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_SUBSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
50491:     }
50491: 
50491:     void subsd_mr(int offset, RegisterID base, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "subsd      %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_SUBSD_VsdWsd, (RegisterID)dst, base, offset);
50491:     }
50491: 
50491:     void ucomisd_rr(XMMRegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "ucomisd    %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_66);
50491:         m_formatter.twoByteOp(OP2_UCOMISD_VsdWsd, (RegisterID)dst, (RegisterID)src);
50491:     }
50491: 
50491:     void ucomisd_mr(int offset, RegisterID base, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "ucomisd    %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_66);
50491:         m_formatter.twoByteOp(OP2_UCOMISD_VsdWsd, (RegisterID)dst, base, offset);
50491:     }
50491: 
50491:     void divsd_rr(XMMRegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "divsd      %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_DIVSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
50491:     }
50491: 
50491:     void divsd_mr(int offset, RegisterID base, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "divsd      %s0x%x(%s), %s\n", MAYBE_PAD,
50491:                        PRETTY_PRINT_OFFSET(offset), nameIReg(base), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_DIVSD_VsdWsd, (RegisterID)dst, base, offset);
50491:     }
50491: 
50491:     void xorpd_rr(XMMRegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "xorpd      %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_66);
50491:         m_formatter.twoByteOp(OP2_XORPD_VpdWpd, (RegisterID)dst, (RegisterID)src);
50491:     }
50491: 
50491:     void sqrtsd_rr(XMMRegisterID src, XMMRegisterID dst)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "sqrtsd     %s, %s\n", MAYBE_PAD,
50491:                        nameFPReg(src), nameFPReg(dst));
50491:         m_formatter.prefix(PRE_SSE_F2);
50491:         m_formatter.twoByteOp(OP2_SQRTSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
50491:     }
50491: 
53412:     void pinsrd_rr(RegisterID src, XMMRegisterID dst)
53412:     {
53412:         js::JaegerSpew(js::JSpew_Insns,
53412:                        IPFX "pinsrd     $1, %s, %s\n", MAYBE_PAD,
53412:                        nameIReg(src), nameFPReg(dst));
53412:         m_formatter.prefix(PRE_SSE_66);
53412:         m_formatter.threeByteOp(OP3_PINSRD_VsdWsd, (RegisterID)dst, (RegisterID)src);
53412:         m_formatter.immediate8(0x01); // the $1
53412:     }
53412: 
50491:     // Misc instructions:
50491: 
50491:     void int3()
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns, IPFX "int3\n", MAYBE_PAD);
50491:         m_formatter.oneByteOp(OP_INT3);
50491:     }
50491:     
50491:     void ret()
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns, IPFX "ret\n", MAYBE_PAD);
50491:         m_formatter.oneByteOp(OP_RET);
50491:     }
50491: 
50491:     void predictNotTaken()
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         m_formatter.prefix(PRE_PREDICT_BRANCH_NOT_TAKEN);
50491:     }
50491: 
50491: #if WTF_CPU_X86
50491:     void pusha()
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns, IPFX "pusha\n", MAYBE_PAD);
50491:         m_formatter.oneByteOp(OP_PUSHA);
50491:     }
50491: 
50491:     void popa()
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns, IPFX "popa\n", MAYBE_PAD);
50491:         m_formatter.oneByteOp(OP_POPA);
50491:     }
50491: #endif
50491: 
50491:     // Assembler admin methods:
50491: 
50491:     JmpDst label()
50491:     {
50491:         JmpDst r = JmpDst(m_formatter.size());
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "#label     ((%d))\n", MAYBE_PAD, r.m_offset);
50491:         return r;
50491:     }
50491:     
50491:     static JmpDst labelFor(JmpSrc jump, intptr_t offset = 0)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         return JmpDst(jump.m_offset + offset);
50491:     }
50491:     
50491:     JmpDst align(int alignment)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         while (!m_formatter.isAligned(alignment))
50491:             m_formatter.oneByteOp(OP_HLT);
50491: 
50491:         return label();
50491:     }
50491: 
50491:     // Linking & patching:
50491:     //
50491:     // 'link' and 'patch' methods are for use on unprotected code - such as the code
50491:     // within the AssemblerBuffer, and code being patched by the patch buffer.  Once
50491:     // code has been finalized it is (platform support permitting) within a non-
50491:     // writable region of memory; to modify the code in an execute-only execuable
50491:     // pool the 'repatch' and 'relink' methods should be used.
50491: 
50491:     void linkJump(JmpSrc from, JmpDst to)
50491:     {
50491:         ASSERT(from.m_offset != -1);
50491:         ASSERT(to.m_offset != -1);
50491: 
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        IPFX "##link     ((%d)) jumps to ((%d))\n", MAYBE_PAD,
50491:                        from.m_offset, to.m_offset);
50491:         char* code = reinterpret_cast<char*>(m_formatter.data());
50491:         setRel32(code + from.m_offset, code + to.m_offset);
50491:     }
50491:     
50491:     static void linkJump(void* code, JmpSrc from, void* to)
50491:     {
50491:         ASSERT(from.m_offset != -1);
50491: 
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        ISPFX "##link     ((%d)) jumps to ((%p))\n",
50491:                        from.m_offset, to);
50491:         setRel32(reinterpret_cast<char*>(code) + from.m_offset, to);
50491:     }
50491: 
50491:     static void linkCall(void* code, JmpSrc from, void* to)
50491:     {
50491:         ASSERT(from.m_offset != -1);
50491: 
50491:         FIXME_INSN_PRINTING;
50491:         setRel32(reinterpret_cast<char*>(code) + from.m_offset, to);
50491:     }
50491: 
50491:     static void linkPointer(void* code, JmpDst where, void* value)
50491:     {
50491:         ASSERT(where.m_offset != -1);
50491: 
50491:         FIXME_INSN_PRINTING;
50491:         setPointer(reinterpret_cast<char*>(code) + where.m_offset, value);
50491:     }
50491: 
50491:     static void relinkJump(void* from, void* to)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491:         setRel32(from, to);
50491:     }
50491:     
50491:     static void relinkCall(void* from, void* to)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        ISPFX "##relinkCall ((from=%p)) ((to=%p))\n",
50491:                        from, to);
50491:         setRel32(from, to);
50491:     }
50491: 
50491:     static void repatchInt32(void* where, int32_t value)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        ISPFX "##relinkInt32 ((where=%p)) ((value=%d))\n",
50491:                        where, value);
50491:         setInt32(where, value);
50491:     }
50491: 
50491:     static void repatchPointer(void* where, void* value)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        ISPFX "##repatchPtr ((where=%p)) ((value=%p))\n",
50491:                        where, value);
50491:         setPointer(where, value);
50491:     }
50491: 
50491:     static void repatchLoadPtrToLEA(void* where)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491: #if WTF_CPU_X86_64
50491:         // On x86-64 pointer memory accesses require a 64-bit operand, and as such a REX prefix.
50491:         // Skip over the prefix byte.
50491:         where = reinterpret_cast<char*>(where) + 1;
50491: #endif
50491:         *reinterpret_cast<unsigned char*>(where) = static_cast<unsigned char>(OP_LEA);
50491:     }
50491:     
50491:     static void repatchLEAToLoadPtr(void* where)
50491:     {
50491:         FIXME_INSN_PRINTING;
50491: #if WTF_CPU_X86_64
50491:         // On x86-64 pointer memory accesses require a 64-bit operand, and as such a REX prefix.
50491:         // Skip over the prefix byte.
50491:         where = reinterpret_cast<char*>(where) + 1;
50491: #endif
50491:         *reinterpret_cast<unsigned char*>(where) = static_cast<unsigned char>(OP_MOV_GvEv);
50491:     }
50491: 
50491:     static unsigned getCallReturnOffset(JmpSrc call)
50491:     {
50491:         ASSERT(call.m_offset >= 0);
50491:         return call.m_offset;
50491:     }
50491: 
50491:     static void* getRelocatedAddress(void* code, JmpSrc jump)
50491:     {
50491:         ASSERT(jump.m_offset != -1);
50491: 
50491:         return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(code) + jump.m_offset);
50491:     }
50491:     
50491:     static void* getRelocatedAddress(void* code, JmpDst destination)
50491:     {
50491:         ASSERT(destination.m_offset != -1);
50491: 
50491:         return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(code) + destination.m_offset);
50491:     }
50491:     
50491:     static int getDifferenceBetweenLabels(JmpDst src, JmpDst dst)
50491:     {
50491:         return dst.m_offset - src.m_offset;
50491:     }
50491:     
50491:     static int getDifferenceBetweenLabels(JmpDst src, JmpSrc dst)
50491:     {
50491:         return dst.m_offset - src.m_offset;
50491:     }
50491:     
50491:     static int getDifferenceBetweenLabels(JmpSrc src, JmpDst dst)
50491:     {
50491:         return dst.m_offset - src.m_offset;
50491:     }
50491:     
50491:     void* executableCopy(ExecutablePool* allocator)
50491:     {
50491:         void* copy = m_formatter.executableCopy(allocator);
50491:         return copy;
50491:     }
50491: 
50491:     void* executableCopy(void* buffer)
50491:     {
56037:         if (m_formatter.oom())
56037:             return NULL;
50491:         return memcpy(buffer, m_formatter.buffer(), size());
50491:     }
50491: 
50491: private:
50491: 
50491:     static void setPointer(void* where, void* value)
50491:     {
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        ISPFX "##setPtr     ((where=%p)) ((value=%p))\n", where, value);
50491:         reinterpret_cast<void**>(where)[-1] = value;
50491:     }
50491: 
50491:     static void setInt32(void* where, int32_t value)
50491:     {
50491:         reinterpret_cast<int32_t*>(where)[-1] = value;
50491:     }
50491: 
50491:     static void setRel32(void* from, void* to)
50491:     {
50491:         intptr_t offset = reinterpret_cast<intptr_t>(to) - reinterpret_cast<intptr_t>(from);
50491:         ASSERT(offset == static_cast<int32_t>(offset));
50491: 
50491:         js::JaegerSpew(js::JSpew_Insns,
50491:                        ISPFX "##setRel32 ((from=%p)) ((to=%p))\n", from, to);
50491:         setInt32(from, offset);
50491:     }
50491: 
50491:     class X86InstructionFormatter {
50491: 
50491:         static const int maxInstructionSize = 16;
50491: 
50491:     public:
50491: 
50491:         // Legacy prefix bytes:
50491:         //
50491:         // These are emmitted prior to the instruction.
50491: 
50491:         void prefix(OneByteOpcodeID pre)
50491:         {
50491:             m_buffer.putByte(pre);
50491:         }
50491: 
50491:         // Word-sized operands / no operand instruction formatters.
50491:         //
50491:         // In addition to the opcode, the following operand permutations are supported:
50491:         //   * None - instruction takes no operands.
50491:         //   * One register - the low three bits of the RegisterID are added into the opcode.
50491:         //   * Two registers - encode a register form ModRm (for all ModRm formats, the reg field is passed first, and a GroupOpcodeID may be passed in its place).
50491:         //   * Three argument ModRM - a register, and a register and an offset describing a memory operand.
50491:         //   * Five argument ModRM - a register, and a base register, an index, scale, and offset describing a memory operand.
50491:         //
50491:         // For 32-bit x86 targets, the address operand may also be provided as a void*.
50491:         // On 64-bit targets REX prefixes will be planted as necessary, where high numbered registers are used.
50491:         //
50491:         // The twoByteOp methods plant two-byte Intel instructions sequences (first opcode byte 0x0F).
50491: 
50491:         void oneByteOp(OneByteOpcodeID opcode)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             m_buffer.putByteUnchecked(opcode);
50491:         }
50491: 
50491:         void oneByteOp(OneByteOpcodeID opcode, RegisterID reg)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIfNeeded(0, 0, reg);
50491:             m_buffer.putByteUnchecked(opcode + (reg & 7));
50491:         }
50491: 
50491:         void oneByteOp(OneByteOpcodeID opcode, int reg, RegisterID rm)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIfNeeded(reg, 0, rm);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             registerModRM(reg, rm);
50491:         }
50491: 
50491:         void oneByteOp(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIfNeeded(reg, 0, base);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM(reg, base, offset);
50491:         }
50491: 
50491:         void oneByteOp_disp32(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIfNeeded(reg, 0, base);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM_disp32(reg, base, offset);
50491:         }
50491: 
50491:         void oneByteOp(OneByteOpcodeID opcode, int reg, RegisterID base, RegisterID index, int scale, int offset)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIfNeeded(reg, index, base);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM(reg, base, index, scale, offset);
50491:         }
50491: 
50491: #if !WTF_CPU_X86_64
50491:         void oneByteOp(OneByteOpcodeID opcode, int reg, void* address)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM(reg, address);
50491:         }
50491: #endif
50491: 
50491:         void twoByteOp(TwoByteOpcodeID opcode)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
50491:             m_buffer.putByteUnchecked(opcode);
50491:         }
50491: 
50491:         void twoByteOp(TwoByteOpcodeID opcode, int reg, RegisterID rm)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIfNeeded(reg, 0, rm);
50491:             m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             registerModRM(reg, rm);
50491:         }
50491: 
50491:         void twoByteOp(TwoByteOpcodeID opcode, int reg, RegisterID base, int offset)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIfNeeded(reg, 0, base);
50491:             m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM(reg, base, offset);
50491:         }
50491: 
50491:         void twoByteOp(TwoByteOpcodeID opcode, int reg, RegisterID base, RegisterID index, int scale, int offset)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIfNeeded(reg, index, base);
50491:             m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM(reg, base, index, scale, offset);
50491:         }
50491: 
50491: #if !WTF_CPU_X86_64
50491:         void twoByteOp(TwoByteOpcodeID opcode, int reg, const void* address)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM(reg, address);
50491:         }
50491: #endif
50491: 
53412:         void threeByteOp(ThreeByteOpcodeID opcode, int reg, RegisterID rm)
53412:         {
53412:             m_buffer.ensureSpace(maxInstructionSize);
53412:             emitRexIfNeeded(reg, 0, rm);
53412:             m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
53412:             m_buffer.putByteUnchecked(OP_3BYTE_ESCAPE);
53412:             m_buffer.putByteUnchecked(opcode);
53412:             registerModRM(reg, rm);
53412:         }
53412: 
50491: #if WTF_CPU_X86_64
50491:         // Quad-word-sized operands:
50491:         //
50491:         // Used to format 64-bit operantions, planting a REX.w prefix.
50491:         // When planting d64 or f64 instructions, not requiring a REX.w prefix,
50491:         // the normal (non-'64'-postfixed) formatters should be used.
50491: 
50491:         void oneByteOp64(OneByteOpcodeID opcode)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexW(0, 0, 0);
50491:             m_buffer.putByteUnchecked(opcode);
50491:         }
50491: 
50491:         void oneByteOp64(OneByteOpcodeID opcode, RegisterID reg)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexW(0, 0, reg);
50491:             m_buffer.putByteUnchecked(opcode + (reg & 7));
50491:         }
50491: 
50491:         void oneByteOp64(OneByteOpcodeID opcode, int reg, RegisterID rm)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexW(reg, 0, rm);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             registerModRM(reg, rm);
50491:         }
50491: 
50491:         void oneByteOp64(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexW(reg, 0, base);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM(reg, base, offset);
50491:         }
50491: 
50491:         void oneByteOp64_disp32(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexW(reg, 0, base);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM_disp32(reg, base, offset);
50491:         }
50491: 
50491:         void oneByteOp64(OneByteOpcodeID opcode, int reg, RegisterID base, RegisterID index, int scale, int offset)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexW(reg, index, base);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             memoryModRM(reg, base, index, scale, offset);
50491:         }
50491: 
50491:         void twoByteOp64(TwoByteOpcodeID opcode, int reg, RegisterID rm)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexW(reg, 0, rm);
50491:             m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             registerModRM(reg, rm);
50491:         }
50491: #endif
50491: 
50491:         // Byte-operands:
50491:         //
50491:         // These methods format byte operations.  Byte operations differ from the normal
50491:         // formatters in the circumstances under which they will decide to emit REX prefixes.
50491:         // These should be used where any register operand signifies a byte register.
50491:         //
50491:         // The disctinction is due to the handling of register numbers in the range 4..7 on
50491:         // x86-64.  These register numbers may either represent the second byte of the first
50491:         // four registers (ah..bh) or the first byte of the second four registers (spl..dil).
50491:         //
50491:         // Since ah..bh cannot be used in all permutations of operands (specifically cannot
50491:         // be accessed where a REX prefix is present), these are likely best treated as
50491:         // deprecated.  In order to ensure the correct registers spl..dil are selected a
50491:         // REX prefix will be emitted for any byte register operand in the range 4..15.
50491:         //
50491:         // These formatters may be used in instructions where a mix of operand sizes, in which
50491:         // case an unnecessary REX will be emitted, for example:
50491:         //     movzbl %al, %edi
50491:         // In this case a REX will be planted since edi is 7 (and were this a byte operand
50491:         // a REX would be required to specify dil instead of bh).  Unneeded REX prefixes will
50491:         // be silently ignored by the processor.
50491:         //
50491:         // Address operands should still be checked using regRequiresRex(), while byteRegRequiresRex()
50491:         // is provided to check byte register operands.
50491: 
50491:         void oneByteOp8(OneByteOpcodeID opcode, GroupOpcodeID groupOp, RegisterID rm)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIf(byteRegRequiresRex(rm), 0, 0, rm);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             registerModRM(groupOp, rm);
50491:         }
50491: 
50491:         void twoByteOp8(TwoByteOpcodeID opcode, RegisterID reg, RegisterID rm)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIf(byteRegRequiresRex(reg)|byteRegRequiresRex(rm), reg, 0, rm);
50491:             m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             registerModRM(reg, rm);
50491:         }
50491: 
50491:         void twoByteOp8(TwoByteOpcodeID opcode, GroupOpcodeID groupOp, RegisterID rm)
50491:         {
50491:             m_buffer.ensureSpace(maxInstructionSize);
50491:             emitRexIf(byteRegRequiresRex(rm), 0, 0, rm);
50491:             m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
50491:             m_buffer.putByteUnchecked(opcode);
50491:             registerModRM(groupOp, rm);
50491:         }
50491: 
50491:         // Immediates:
50491:         //
50491:         // An immedaite should be appended where appropriate after an op has been emitted.
50491:         // The writes are unchecked since the opcode formatters above will have ensured space.
50491: 
50491:         void immediate8(int imm)
50491:         {
50491:             m_buffer.putByteUnchecked(imm);
50491:         }
50491: 
50491:         void immediate16(int imm)
50491:         {
50491:             m_buffer.putShortUnchecked(imm);
50491:         }
50491: 
50491:         void immediate32(int imm)
50491:         {
50491:             m_buffer.putIntUnchecked(imm);
50491:         }
50491: 
50491:         void immediate64(int64_t imm)
50491:         {
50491:             m_buffer.putInt64Unchecked(imm);
50491:         }
50491: 
50491:         JmpSrc immediateRel32()
50491:         {
50491:             m_buffer.putIntUnchecked(0);
50491:             return JmpSrc(m_buffer.size());
50491:         }
50491: 
50491:         // Administrative methods:
50491: 
50491:         size_t size() const { return m_buffer.size(); }
50491:         unsigned char *buffer() const { return m_buffer.buffer(); }
56037:         bool oom() const { return m_buffer.oom(); }
50491:         bool isAligned(int alignment) const { return m_buffer.isAligned(alignment); }
50491:         void* data() const { return m_buffer.data(); }
50491:         void* executableCopy(ExecutablePool* allocator) { return m_buffer.executableCopy(allocator); }
50491: 
50491:     private:
50491: 
50491:         // Internals; ModRm and REX formatters.
50491: 
50491:         static const RegisterID noBase = X86Registers::ebp;
50491:         static const RegisterID hasSib = X86Registers::esp;
50491:         static const RegisterID noIndex = X86Registers::esp;
50491: #if WTF_CPU_X86_64
50491:         static const RegisterID noBase2 = X86Registers::r13;
50491:         static const RegisterID hasSib2 = X86Registers::r12;
50491: 
50491:         // Registers r8 & above require a REX prefixe.
50491:         inline bool regRequiresRex(int reg)
50491:         {
50491:             return (reg >= X86Registers::r8);
50491:         }
50491: 
50491:         // Byte operand register spl & above require a REX prefix (to prevent the 'H' registers be accessed).
50491:         inline bool byteRegRequiresRex(int reg)
50491:         {
50491:             return (reg >= X86Registers::esp);
50491:         }
50491: 
50491:         // Format a REX prefix byte.
50491:         inline void emitRex(bool w, int r, int x, int b)
50491:         {
50491:             m_buffer.putByteUnchecked(PRE_REX | ((int)w << 3) | ((r>>3)<<2) | ((x>>3)<<1) | (b>>3));
50491:         }
50491: 
50491:         // Used to plant a REX byte with REX.w set (for 64-bit operations).
50491:         inline void emitRexW(int r, int x, int b)
50491:         {
50491:             emitRex(true, r, x, b);
50491:         }
50491: 
50491:         // Used for operations with byte operands - use byteRegRequiresRex() to check register operands,
50491:         // regRequiresRex() to check other registers (i.e. address base & index).
50491:         inline void emitRexIf(bool condition, int r, int x, int b)
50491:         {
50491:             if (condition) emitRex(false, r, x, b);
50491:         }
50491: 
50491:         // Used for word sized operations, will plant a REX prefix if necessary (if any register is r8 or above).
50491:         inline void emitRexIfNeeded(int r, int x, int b)
50491:         {
50491:             emitRexIf(regRequiresRex(r) || regRequiresRex(x) || regRequiresRex(b), r, x, b);
50491:         }
50491: #else
50491:         // No REX prefix bytes on 32-bit x86.
50491:         inline bool regRequiresRex(int) { return false; }
50491:         inline bool byteRegRequiresRex(int) { return false; }
50491:         inline void emitRexIf(bool, int, int, int) {}
50491:         inline void emitRexIfNeeded(int, int, int) {}
50491: #endif
50491: 
50491:         enum ModRmMode {
50491:             ModRmMemoryNoDisp,
50491:             ModRmMemoryDisp8,
50491:             ModRmMemoryDisp32,
50491:             ModRmRegister
50491:         };
50491: 
50491:         void putModRm(ModRmMode mode, int reg, RegisterID rm)
50491:         {
50491:             m_buffer.putByteUnchecked((mode << 6) | ((reg & 7) << 3) | (rm & 7));
50491:         }
50491: 
50491:         void putModRmSib(ModRmMode mode, int reg, RegisterID base, RegisterID index, int scale)
50491:         {
50491:             ASSERT(mode != ModRmRegister);
50491: 
50491:             putModRm(mode, reg, hasSib);
50491:             m_buffer.putByteUnchecked((scale << 6) | ((index & 7) << 3) | (base & 7));
50491:         }
50491: 
50491:         void registerModRM(int reg, RegisterID rm)
50491:         {
50491:             putModRm(ModRmRegister, reg, rm);
50491:         }
50491: 
50491:         void memoryModRM(int reg, RegisterID base, int offset)
50491:         {
50491:             // A base of esp or r12 would be interpreted as a sib, so force a sib with no index & put the base in there.
50491: #if WTF_CPU_X86_64
50491:             if ((base == hasSib) || (base == hasSib2)) {
50491: #else
50491:             if (base == hasSib) {
50491: #endif
50491:                 if (!offset) // No need to check if the base is noBase, since we know it is hasSib!
50491:                     putModRmSib(ModRmMemoryNoDisp, reg, base, noIndex, 0);
50491:                 else if (CAN_SIGN_EXTEND_8_32(offset)) {
50491:                     putModRmSib(ModRmMemoryDisp8, reg, base, noIndex, 0);
50491:                     m_buffer.putByteUnchecked(offset);
50491:                 } else {
50491:                     putModRmSib(ModRmMemoryDisp32, reg, base, noIndex, 0);
50491:                     m_buffer.putIntUnchecked(offset);
50491:                 }
50491:             } else {
50491: #if WTF_CPU_X86_64
50491:                 if (!offset && (base != noBase) && (base != noBase2))
50491: #else
50491:                 if (!offset && (base != noBase))
50491: #endif
50491:                     putModRm(ModRmMemoryNoDisp, reg, base);
50491:                 else if (CAN_SIGN_EXTEND_8_32(offset)) {
50491:                     putModRm(ModRmMemoryDisp8, reg, base);
50491:                     m_buffer.putByteUnchecked(offset);
50491:                 } else {
50491:                     putModRm(ModRmMemoryDisp32, reg, base);
50491:                     m_buffer.putIntUnchecked(offset);
50491:                 }
50491:             }
50491:         }
50491:     
50491:         void memoryModRM_disp32(int reg, RegisterID base, int offset)
50491:         {
50491:             // A base of esp or r12 would be interpreted as a sib, so force a sib with no index & put the base in there.
50491: #if WTF_CPU_X86_64
50491:             if ((base == hasSib) || (base == hasSib2)) {
50491: #else
50491:             if (base == hasSib) {
50491: #endif
50491:                 putModRmSib(ModRmMemoryDisp32, reg, base, noIndex, 0);
50491:                 m_buffer.putIntUnchecked(offset);
50491:             } else {
50491:                 putModRm(ModRmMemoryDisp32, reg, base);
50491:                 m_buffer.putIntUnchecked(offset);
50491:             }
50491:         }
50491:     
50491:         void memoryModRM(int reg, RegisterID base, RegisterID index, int scale, int offset)
50491:         {
50491:             ASSERT(index != noIndex);
50491: 
50491: #if WTF_CPU_X86_64
50491:             if (!offset && (base != noBase) && (base != noBase2))
50491: #else
50491:             if (!offset && (base != noBase))
50491: #endif
50491:                 putModRmSib(ModRmMemoryNoDisp, reg, base, index, scale);
50491:             else if (CAN_SIGN_EXTEND_8_32(offset)) {
50491:                 putModRmSib(ModRmMemoryDisp8, reg, base, index, scale);
50491:                 m_buffer.putByteUnchecked(offset);
50491:             } else {
50491:                 putModRmSib(ModRmMemoryDisp32, reg, base, index, scale);
50491:                 m_buffer.putIntUnchecked(offset);
50491:             }
50491:         }
50491: 
50491: #if !WTF_CPU_X86_64
50491:         void memoryModRM(int reg, const void* address)
50491:         {
50491:             // noBase + ModRmMemoryNoDisp means noBase + ModRmMemoryDisp32!
50491:             putModRm(ModRmMemoryNoDisp, reg, noBase);
50491:             m_buffer.putIntUnchecked(reinterpret_cast<int32_t>(address));
50491:         }
50491: #endif
50491: 
50491:         AssemblerBuffer m_buffer;
50491:     } m_formatter;
50491: };
50491: 
50491: } // namespace JSC
50491: 
50491: #endif // ENABLE(ASSEMBLER) && CPU(X86)
50491: 
50491: #endif // X86Assembler_h
