51215: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
51215:  *
51215:  * ***** BEGIN LICENSE BLOCK *****
51215:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
51215:  *
51215:  * The contents of this file are subject to the Mozilla Public License Version
51215:  * 1.1 (the "License"); you may not use this file except in compliance with
51215:  * the License. You may obtain a copy of the License at
51215:  * http://www.mozilla.org/MPL/
51215:  *
51215:  * Software distributed under the License is distributed on an "AS IS" basis,
51215:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
51215:  * for the specific language governing rights and limitations under the
51215:  * License.
51215:  *
51215:  * The Original Code is mozilla.org code.
51215:  *
51215:  * The Initial Developer of the Original Code is
51215:  * Netscape Communications Corporation.
51215:  * Portions created by the Initial Developer are Copyright (C) 2001
51215:  * the Initial Developer. All Rights Reserved.
51215:  *
51215:  * Contributor(s):
51215:  *   Chris Saari <saari@netscape.com>
51215:  *   Bobby Holley <bobbyholley@gmail.com>
51215:  *
51215:  * Alternatively, the contents of this file may be used under the terms of
51215:  * either the GNU General Public License Version 2 or later (the "GPL"), or
51215:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
51215:  * in which case the provisions of the GPL or the LGPL are applicable instead
51215:  * of those above. If you wish to allow use of your version of this file only
51215:  * under the terms of either the GPL or the LGPL, and not to allow others to
51215:  * use your version of this file under the terms of the MPL, indicate your
51215:  * decision by deleting the provisions above and replace them with the notice
51215:  * and other provisions required by the GPL or the LGPL. If you do not delete
51215:  * the provisions above, a recipient may use your version of this file under
51215:  * the terms of any one of the MPL, the GPL or the LGPL.
51215:  *
51215:  * ***** END LICENSE BLOCK ***** */
51215: /*
51215: The Graphics Interchange Format(c) is the copyright property of CompuServe
51215: Incorporated. Only CompuServe Incorporated is authorized to define, redefine,
51215: enhance, alter, modify or change in any way the definition of the format.
51215: 
51215: CompuServe Incorporated hereby grants a limited, non-exclusive, royalty-free
51215: license for the use of the Graphics Interchange Format(sm) in computer
51215: software; computer software utilizing GIF(sm) must acknowledge ownership of the
51215: Graphics Interchange Format and its Service Mark by CompuServe Incorporated, in
51215: User and Technical Documentation. Computer software utilizing GIF, which is
51215: distributed or may be distributed without User or Technical Documentation must
51215: display to the screen or printer a message acknowledging ownership of the
51215: Graphics Interchange Format and the Service Mark by CompuServe Incorporated; in
51215: this case, the acknowledgement may be displayed in an opening screen or leading
51215: banner, or a closing screen or trailing banner. A message such as the following
51215: may be used:
51215: 
51215:     "The Graphics Interchange Format(c) is the Copyright property of
51215:     CompuServe Incorporated. GIF(sm) is a Service Mark property of
51215:     CompuServe Incorporated."
51215: 
51215: For further information, please contact :
51215: 
51215:     CompuServe Incorporated
51215:     Graphics Technology Department
51215:     5000 Arlington Center Boulevard
51215:     Columbus, Ohio  43220
51215:     U. S. A.
51215: 
51215: CompuServe Incorporated maintains a mailing list with all those individuals and
51215: organizations who wish to receive copies of this document when it is corrected
51215: or revised. This service is offered free of charge; please provide us with your
51215: mailing address.
51215: */
51215: 
51215: #include <stddef.h>
51215: #include "prmem.h"
51215: 
51215: #include "nsGIFDecoder2.h"
51215: #include "nsIInputStream.h"
51215: #include "imgIContainerObserver.h"
51215: #include "RasterImage.h"
51215: 
51215: #include "gfxColor.h"
51215: #include "gfxPlatform.h"
51215: #include "qcms.h"
51215: 
51241: namespace mozilla {
51241: namespace imagelib {
51241: 
51215: /*
51215:  * GETN(n, s) requests at least 'n' bytes available from 'q', at start of state 's'
51215:  *
51215:  * Note, the hold will never need to be bigger than 256 bytes to gather up in the hold,
51215:  * as each GIF block (except colormaps) can never be bigger than 256 bytes.
51215:  * Colormaps are directly copied in the resp. global_colormap or the local_colormap of the PAL image frame
51215:  * So a fixed buffer in gif_struct is good enough.
51215:  * This buffer is only needed to copy left-over data from one GifWrite call to the next
51215:  */
51215: #define GETN(n,s)                      \
51215:   PR_BEGIN_MACRO                       \
51215:     mGIFStruct.bytes_to_consume = (n); \
51215:     mGIFStruct.state = (s);            \
51215:   PR_END_MACRO
51215: 
51215: /* Get a 16-bit value stored in little-endian format */
51215: #define GETINT16(p)   ((p)[1]<<8|(p)[0])
51215: //////////////////////////////////////////////////////////////////////
51215: // GIF Decoder Implementation
51215: 
51215: nsGIFDecoder2::nsGIFDecoder2()
51215:   : mCurrentRow(-1)
51215:   , mLastFlushedRow(-1)
51215:   , mImageData(nsnull)
51215:   , mOldColor(0)
51215:   , mCurrentFrame(-1)
51215:   , mCurrentPass(0)
51215:   , mLastFlushedPass(0)
51215:   , mGIFOpen(PR_FALSE)
51215:   , mSawTransparency(PR_FALSE)
51215: {
51215:   // Clear out the structure, excluding the arrays
51215:   memset(&mGIFStruct, 0, sizeof(mGIFStruct));
53665: 
61163:   // Initialize as "animate once" in case no NETSCAPE2.0 extension is found
61163:   mGIFStruct.loop_count = 1;
61163: 
53665:   // Start with the version (GIF89a|GIF87a)
53665:   mGIFStruct.state = gif_type;
53665:   mGIFStruct.bytes_to_consume = 6;
51215: }
51215: 
51215: nsGIFDecoder2::~nsGIFDecoder2()
51215: {
55875:   if (mGIFStruct.local_colormap) {
55875:     moz_free(mGIFStruct.local_colormap);
55875:   }
51215: }
51215: 
53664: void
51247: nsGIFDecoder2::FinishInternal()
51215: {
53675:   NS_ABORT_IF_FALSE(!HasError(), "Shouldn't call FinishInternal after error!");
53673: 
53668:   // If the GIF got cut off, handle it anyway
53673:   if (!IsSizeDecode() && mGIFOpen) {
51215:     if (mCurrentFrame == mGIFStruct.images_decoded)
51215:       EndImageFrame();
53669:     PostDecodeDone();
53669:     mGIFOpen = PR_FALSE;
51215:   }
53668: 
61111:   mImage->SetLoopCount(mGIFStruct.loop_count - 1);
51215: }
51215: 
51215: // Push any new rows according to mCurrentPass/mLastFlushedPass and
51215: // mCurrentRow/mLastFlushedRow.  Note: caller is responsible for
51215: // updating mlastFlushed{Row,Pass}.
53664: void
51215: nsGIFDecoder2::FlushImageData(PRUint32 fromRow, PRUint32 rows)
51215: {
51215:   nsIntRect r(mGIFStruct.x_offset, mGIFStruct.y_offset + fromRow, mGIFStruct.width, rows);
51592:   PostInvalidation(r);
51215: }
51215: 
53664: void
51215: nsGIFDecoder2::FlushImageData()
51215: {
51215:   switch (mCurrentPass - mLastFlushedPass) {
51215:     case 0:  // same pass
51215:       if (mCurrentRow - mLastFlushedRow)
53664:         FlushImageData(mLastFlushedRow + 1, mCurrentRow - mLastFlushedRow);
51215:       break;
51215:   
51215:     case 1:  // one pass on - need to handle bottom & top rects
53664:       FlushImageData(0, mCurrentRow + 1);
53664:       FlushImageData(mLastFlushedRow + 1, mGIFStruct.height - (mLastFlushedRow + 1));
51215:       break;
51215: 
51215:     default:   // more than one pass on - push the whole frame
53664:       FlushImageData(0, mGIFStruct.height);
51215:   }
51215: }
51215: 
51215: //******************************************************************************
51215: // GIF decoder callback methods. Part of public API for GIF2
51215: //******************************************************************************
51215: 
51215: //******************************************************************************
51215: void nsGIFDecoder2::BeginGIF()
51215: {
51215:   if (mGIFOpen)
51215:     return;
51215: 
51215:   mGIFOpen = PR_TRUE;
51215: 
51245:   PostSize(mGIFStruct.screen_width, mGIFStruct.screen_height);
51215: 
51244:   // If we're doing a size decode, we have what we came for
51244:   if (IsSizeDecode())
51215:     return;
51215: }
51215: 
51215: //******************************************************************************
51215: nsresult nsGIFDecoder2::BeginImageFrame(gfx_depth aDepth)
51215: {
51215:   PRUint32 imageDataLength;
51215:   nsresult rv;
51215:   gfxASurface::gfxImageFormat format;
51215:   if (mGIFStruct.is_transparent)
51215:     format = gfxASurface::ImageFormatARGB32;
51215:   else
51215:     format = gfxASurface::ImageFormatRGB24;
51215: 
51215:   // Use correct format, RGB for first frame, PAL for following frames
51215:   // and include transparency to allow for optimization of opaque images
51215:   if (mGIFStruct.images_decoded) {
51215:     // Image data is stored with original depth and palette
51238:     rv = mImage->AppendPalettedFrame(mGIFStruct.x_offset, mGIFStruct.y_offset,
51215:                                      mGIFStruct.width, mGIFStruct.height,
51215:                                      format, aDepth, &mImageData, &imageDataLength,
51215:                                      &mColormap, &mColormapSize);
51215:   } else {
51215:     // Regardless of depth of input, image is decoded into 24bit RGB
51238:     rv = mImage->AppendFrame(mGIFStruct.x_offset, mGIFStruct.y_offset,
51215:                              mGIFStruct.width, mGIFStruct.height,
51215:                              format, &mImageData, &imageDataLength);
51215:   }
51215: 
51215:   if (NS_FAILED(rv))
51215:     return rv;
51215: 
51238:   mImage->SetFrameDisposalMethod(mGIFStruct.images_decoded,
51215:                                  mGIFStruct.disposal_method);
51215: 
51246:   // Tell the superclass we're starting a frame
51246:   PostFrameStart();
51215: 
51592:   if (!mGIFStruct.images_decoded) {
51592:     // Send a onetime invalidation for the first frame if it has a y-axis offset. 
51592:     // Otherwise, the area may never be refreshed and the placeholder will remain
51592:     // on the screen. (Bug 37589)
51592:     if (mGIFStruct.y_offset > 0) {
51592:       PRInt32 imgWidth;
51592:       mImage->GetWidth(&imgWidth);
51592:       nsIntRect r(0, 0, imgWidth, mGIFStruct.y_offset);
51592:       PostInvalidation(r);
51592:     }
51592:   }
51592: 
51215:   mCurrentFrame = mGIFStruct.images_decoded;
51215:   return NS_OK;
51215: }
51215: 
51215: 
51215: //******************************************************************************
51215: void nsGIFDecoder2::EndImageFrame()
51215: {
51215:   // First flush all pending image data 
51215:   if (!mGIFStruct.images_decoded) {
51215:     // Only need to flush first frame
53664:     FlushImageData();
51215: 
51592:     // If the first frame is smaller in height than the entire image, send an
51592:     // invalidation for the area it does not have data for.
51215:     // This will clear the remaining bits of the placeholder. (Bug 37589)
51215:     const PRUint32 realFrameHeight = mGIFStruct.height + mGIFStruct.y_offset;
51215:     if (realFrameHeight < mGIFStruct.screen_height) {
51215:       nsIntRect r(0, realFrameHeight,
51215:                   mGIFStruct.screen_width,
51215:                   mGIFStruct.screen_height - realFrameHeight);
51592:       PostInvalidation(r);
51215:     }
51215:     // This transparency check is only valid for first frame
51215:     if (mGIFStruct.is_transparent && !mSawTransparency) {
51238:       mImage->SetFrameHasNoAlpha(mGIFStruct.images_decoded);
51215:     }
51215:   }
51215:   mCurrentRow = mLastFlushedRow = -1;
51215:   mCurrentPass = mLastFlushedPass = 0;
51215: 
51215:   // Only add frame if we have any rows at all
51215:   if (mGIFStruct.rows_remaining != mGIFStruct.height) {
51215:     if (mGIFStruct.rows_remaining && mGIFStruct.images_decoded) {
51215:       // Clear the remaining rows (only needed for the animation frames)
51215:       PRUint8 *rowp = mImageData + ((mGIFStruct.height - mGIFStruct.rows_remaining) * mGIFStruct.width);
51215:       memset(rowp, 0, mGIFStruct.rows_remaining * mGIFStruct.width);
51215:     }
51215: 
51215:     // We actually have the timeout information before we get the lzw encoded 
51215:     // image data, at least according to the spec, but we delay in setting the 
51215:     // timeout for the image until here to help ensure that we have the whole 
51215:     // image frame decoded before we go off and try to display another frame.
51238:     mImage->SetFrameTimeout(mGIFStruct.images_decoded, mGIFStruct.delay_time);
51215:   }
51215: 
51215:   // Unconditionally increment images_decoded, because we unconditionally
51215:   // append frames in BeginImageFrame(). This ensures that images_decoded
51238:   // always refers to the frame in mImage we're currently decoding,
51215:   // even if some of them weren't decoded properly and thus are blank.
51215:   mGIFStruct.images_decoded++;
51215: 
51246:   // Tell the superclass we finished a frame
51246:   PostFrameStop();
51215: 
51215:   // Reset the transparent pixel
51215:   if (mOldColor) {
51215:     mColormap[mGIFStruct.tpixel] = mOldColor;
51215:     mOldColor = 0;
51215:   }
51215: 
51215:   mCurrentFrame = -1;
51215: }
51215: 
51215: 
51215: //******************************************************************************
51215: // Send the data to the display front-end.
51215: PRUint32 nsGIFDecoder2::OutputRow()
51215: {
51215:   int drow_start, drow_end;
51215:   drow_start = drow_end = mGIFStruct.irow;
51215: 
51215:   /* Protect against too much image data */
51215:   if ((PRUintn)drow_start >= mGIFStruct.height) {
51215:     NS_WARNING("GIF2.cpp::OutputRow - too much image data");
51215:     return 0;
51215:   }
51215: 
51215:   if (!mGIFStruct.images_decoded) {
51215:     /*
51215:      * Haeberli-inspired hack for interlaced GIFs: Replicate lines while
51215:      * displaying to diminish the "venetian-blind" effect as the image is
51215:      * loaded. Adjust pixel vertical positions to avoid the appearance of the
51215:      * image crawling up the screen as successive passes are drawn.
51215:      */
51215:     if (mGIFStruct.progressive_display && mGIFStruct.interlaced && (mGIFStruct.ipass < 4)) {
51215:       /* ipass = 1,2,3 results in resp. row_dup = 7,3,1 and row_shift = 3,1,0 */
51215:       const PRUint32 row_dup = 15 >> mGIFStruct.ipass;
51215:       const PRUint32 row_shift = row_dup >> 1;
51215:   
51215:       drow_start -= row_shift;
51215:       drow_end = drow_start + row_dup;
51215:   
51215:       /* Extend if bottom edge isn't covered because of the shift upward. */
51215:       if (((mGIFStruct.height - 1) - drow_end) <= row_shift)
51215:         drow_end = mGIFStruct.height - 1;
51215:   
51215:       /* Clamp first and last rows to upper and lower edge of image. */
51215:       if (drow_start < 0)
51215:         drow_start = 0;
51215:       if ((PRUintn)drow_end >= mGIFStruct.height)
51215:         drow_end = mGIFStruct.height - 1;
51215:     }
51215: 
51215:     // Row to process
51215:     const PRUint32 bpr = sizeof(PRUint32) * mGIFStruct.width; 
51215:     PRUint8 *rowp = mImageData + (mGIFStruct.irow * bpr);
51215: 
51215:     // Convert color indices to Cairo pixels
51215:     PRUint8 *from = rowp + mGIFStruct.width;
51215:     PRUint32 *to = ((PRUint32*)rowp) + mGIFStruct.width;
51215:     PRUint32 *cmap = mColormap;
51215:     if (mColorMask == 0xFF) {
51215:       for (PRUint32 c = mGIFStruct.width; c > 0; c--) {
51215:         *--to = cmap[*--from];
51215:       }
51215:     } else {
51215:       // Make sure that pixels within range of colormap.
51215:       PRUint8 mask = mColorMask;
51215:       for (PRUint32 c = mGIFStruct.width; c > 0; c--) {
51215:         *--to = cmap[(*--from) & mask];
51215:       }
51215:     }
51215:   
51215:     // check for alpha (only for first frame)
51215:     if (mGIFStruct.is_transparent && !mSawTransparency) {
51215:       const PRUint32 *rgb = (PRUint32*)rowp;
51215:       for (PRUint32 i = mGIFStruct.width; i > 0; i--) {
51215:         if (*rgb++ == 0) {
51215:           mSawTransparency = PR_TRUE;
51215:           break;
51215:         }
51215:       }
51215:     }
51215: 
51215:     // Duplicate rows
51215:     if (drow_end > drow_start) {
51215:       // irow is the current row filled
51215:       for (int r = drow_start; r <= drow_end; r++) {
51215:         if (r != int(mGIFStruct.irow)) {
51215:           memcpy(mImageData + (r * bpr), rowp, bpr);
51215:         }
51215:       }
51215:     }
51215:   }
51215: 
51215:   mCurrentRow = drow_end;
51215:   mCurrentPass = mGIFStruct.ipass;
51215:   if (mGIFStruct.ipass == 1)
51215:     mLastFlushedPass = mGIFStruct.ipass;   // interlaced starts at 1
51215: 
51215:   if (!mGIFStruct.interlaced) {
51215:     mGIFStruct.irow++;
51215:   } else {
51215:     static const PRUint8 kjump[5] = { 1, 8, 8, 4, 2 };
51215:     do {
51215:       // Row increments resp. per 8,8,4,2 rows
51215:       mGIFStruct.irow += kjump[mGIFStruct.ipass];
51215:       if (mGIFStruct.irow >= mGIFStruct.height) {
51215:         // Next pass starts resp. at row 4,2,1,0
51215:         mGIFStruct.irow = 8 >> mGIFStruct.ipass;
51215:         mGIFStruct.ipass++;
51215:       }
51215:     } while (mGIFStruct.irow >= mGIFStruct.height);
51215:   }
51215: 
51215:   return --mGIFStruct.rows_remaining;
51215: }
51215: 
51215: //******************************************************************************
51215: /* Perform Lempel-Ziv-Welch decoding */
51215: PRBool
51215: nsGIFDecoder2::DoLzw(const PRUint8 *q)
51215: {
51215:   if (!mGIFStruct.rows_remaining)
51215:     return PR_TRUE;
51215: 
51215:   /* Copy all the decoder state variables into locals so the compiler
51215:    * won't worry about them being aliased.  The locals will be homed
51215:    * back into the GIF decoder structure when we exit.
51215:    */
51215:   int avail       = mGIFStruct.avail;
51215:   int bits        = mGIFStruct.bits;
51215:   int codesize    = mGIFStruct.codesize;
51215:   int codemask    = mGIFStruct.codemask;
51215:   int count       = mGIFStruct.count;
51215:   int oldcode     = mGIFStruct.oldcode;
51215:   const int clear_code = ClearCode();
51215:   PRUint8 firstchar = mGIFStruct.firstchar;
51215:   PRInt32 datum     = mGIFStruct.datum;
51215:   PRUint16 *prefix  = mGIFStruct.prefix;
51215:   PRUint8 *stackp   = mGIFStruct.stackp;
51215:   PRUint8 *suffix   = mGIFStruct.suffix;
51215:   PRUint8 *stack    = mGIFStruct.stack;
51215:   PRUint8 *rowp     = mGIFStruct.rowp;
51215: 
51215:   PRUint32 bpr = mGIFStruct.width;
51215:   if (!mGIFStruct.images_decoded) 
51215:     bpr *= sizeof(PRUint32);
51215:   PRUint8 *rowend   = mImageData + (bpr * mGIFStruct.irow) + mGIFStruct.width;
51215: 
51215: #define OUTPUT_ROW()                                        \
51215:   PR_BEGIN_MACRO                                            \
51215:     if (!OutputRow())                                       \
51215:       goto END;                                             \
51215:     rowp = mImageData + mGIFStruct.irow * bpr;              \
51215:     rowend = rowp + mGIFStruct.width;                       \
51215:   PR_END_MACRO
51215: 
51215:   for (const PRUint8* ch = q; count-- > 0; ch++)
51215:   {
51215:     /* Feed the next byte into the decoder's 32-bit input buffer. */
51215:     datum += ((int32) *ch) << bits;
51215:     bits += 8;
51215: 
51215:     /* Check for underflow of decoder's 32-bit input buffer. */
51215:     while (bits >= codesize)
51215:     {
51215:       /* Get the leading variable-length symbol from the data stream */
51215:       int code = datum & codemask;
51215:       datum >>= codesize;
51215:       bits -= codesize;
51215: 
51215:       /* Reset the dictionary to its original state, if requested */
51215:       if (code == clear_code) {
51215:         codesize = mGIFStruct.datasize + 1;
51215:         codemask = (1 << codesize) - 1;
51215:         avail = clear_code + 2;
51215:         oldcode = -1;
51215:         continue;
51215:       }
51215: 
51215:       /* Check for explicit end-of-stream code */
51215:       if (code == (clear_code + 1)) {
51215:         /* end-of-stream should only appear after all image data */
51215:         return (mGIFStruct.rows_remaining == 0);
51215:       }
51215: 
51215:       if (oldcode == -1) {
51215:         if (code >= MAX_BITS)
51215:           return PR_FALSE;
51215:         *rowp++ = suffix[code];
51215:         if (rowp == rowend)
51215:           OUTPUT_ROW();
51215: 
51215:         firstchar = oldcode = code;
51215:         continue;
51215:       }
51215: 
51215:       int incode = code;
51215:       if (code >= avail) {
51215:         *stackp++ = firstchar;
51215:         code = oldcode;
51215: 
51215:         if (stackp >= stack + MAX_BITS)
51215:           return PR_FALSE;
51215:       }
51215: 
51215:       while (code >= clear_code)
51215:       {
51215:         if ((code >= MAX_BITS) || (code == prefix[code]))
51215:           return PR_FALSE;
51215: 
51215:         *stackp++ = suffix[code];
51215:         code = prefix[code];
51215: 
51215:         if (stackp == stack + MAX_BITS)
51215:           return PR_FALSE;
51215:       }
51215: 
51215:       *stackp++ = firstchar = suffix[code];
51215: 
51215:       /* Define a new codeword in the dictionary. */
51215:       if (avail < 4096) {
51215:         prefix[avail] = oldcode;
51215:         suffix[avail] = firstchar;
51215:         avail++;
51215: 
51215:         /* If we've used up all the codewords of a given length
51215:          * increase the length of codewords by one bit, but don't
51215:          * exceed the specified maximum codeword size of 12 bits.
51215:          */
51215:         if (((avail & codemask) == 0) && (avail < 4096)) {
51215:           codesize++;
51215:           codemask += avail;
51215:         }
51215:       }
51215:       oldcode = incode;
51215: 
51215:       /* Copy the decoded data out to the scanline buffer. */
51215:       do {
51215:         *rowp++ = *--stackp;
51215:         if (rowp == rowend)
51215:           OUTPUT_ROW();
51215:       } while (stackp > stack);
51215:     }
51215:   }
51215: 
51215:   END:
51215: 
51215:   /* Home the local copies of the GIF decoder state variables */
51215:   mGIFStruct.avail = avail;
51215:   mGIFStruct.bits = bits;
51215:   mGIFStruct.codesize = codesize;
51215:   mGIFStruct.codemask = codemask;
51215:   mGIFStruct.count = count;
51215:   mGIFStruct.oldcode = oldcode;
51215:   mGIFStruct.firstchar = firstchar;
51215:   mGIFStruct.datum = datum;
51215:   mGIFStruct.stackp = stackp;
51215:   mGIFStruct.rowp = rowp;
51215: 
51215:   return PR_TRUE;
51215: }
51215: 
51215: /** 
51215:  * Expand the colormap from RGB to Packed ARGB as needed by Cairo.
51215:  * And apply any LCMS transformation.
51215:  */
51215: static void ConvertColormap(PRUint32 *aColormap, PRUint32 aColors)
51215: {
51215:   // Apply CMS transformation if enabled and available
51215:   if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
51215:     qcms_transform *transform = gfxPlatform::GetCMSRGBTransform();
51215:     if (transform)
51215:       qcms_transform_data(transform, aColormap, aColormap, aColors);
51215:   }
51215:   // Convert from the GIF's RGB format to the Cairo format.
51215:   // Work from end to begin, because of the in-place expansion
51215:   PRUint8 *from = ((PRUint8 *)aColormap) + 3 * aColors;
51215:   PRUint32 *to = aColormap + aColors;
51215: 
51215:   // Convert color entries to Cairo format
51215: 
51215:   // set up for loops below
51215:   if (!aColors) return;
51215:   PRUint32 c = aColors;
51215: 
51215:   // copy as bytes until source pointer is 32-bit-aligned
51215:   // NB: can't use 32-bit reads, they might read off the end of the buffer
51215:   for (; (NS_PTR_TO_UINT32(from) & 0x3) && c; --c) {
51215:     from -= 3;
51215:     *--to = GFX_PACKED_PIXEL(0xFF, from[0], from[1], from[2]);
51215:   }
51215: 
51215:   // bulk copy of pixels.
51215:   while (c >= 4) {
51215:     from -= 12;
51215:     to   -=  4;
51215:     c    -=  4;
51215:     GFX_BLOCK_RGB_TO_FRGB(from,to);
51215:   }
51215: 
51215:   // copy remaining pixel(s)
51215:   // NB: can't use 32-bit reads, they might read off the end of the buffer
51215:   while (c--) {
51215:     from -= 3;
51215:     *--to = GFX_PACKED_PIXEL(0xFF, from[0], from[1], from[2]);
51215:   }
51215: }
51215: 
53668: void
53668: nsGIFDecoder2::WriteInternal(const char *aBuffer, PRUint32 aCount)
53668: {
53675:   NS_ABORT_IF_FALSE(!HasError(), "Shouldn't call WriteInternal after error!");
51215: 
53668:   // These variables changed names, and renaming would make a much bigger patch :(
53668:   const PRUint8 *buf = (const PRUint8 *)aBuffer;
53668:   PRUint32 len = aCount;
51215: 
51215:   const PRUint8 *q = buf;
51215: 
51215:   // Add what we have sofar to the block
51215:   // If previous call to me left something in the hold first complete current block
51215:   // Or if we are filling the colormaps, first complete the colormap
51215:   PRUint8* p = (mGIFStruct.state == gif_global_colormap) ? (PRUint8*)mGIFStruct.global_colormap :
51215:                (mGIFStruct.state == gif_image_colormap) ? (PRUint8*)mColormap :
51215:                (mGIFStruct.bytes_in_hold) ? mGIFStruct.hold : nsnull;
51215:   if (p) {
51215:     // Add what we have sofar to the block
51215:     PRUint32 l = PR_MIN(len, mGIFStruct.bytes_to_consume);
51215:     memcpy(p+mGIFStruct.bytes_in_hold, buf, l);
51215: 
51215:     if (l < mGIFStruct.bytes_to_consume) {
51215:       // Not enough in 'buf' to complete current block, get more
51215:       mGIFStruct.bytes_in_hold += l;
51215:       mGIFStruct.bytes_to_consume -= l;
53668:       return;
51215:     }
51215:     // Reset hold buffer count
51215:     mGIFStruct.bytes_in_hold = 0;
51215:     // Point 'q' to complete block in hold (or in colormap)
51215:     q = p;
51215:   }
51215: 
51215:   // Invariant:
51215:   //    'q' is start of current to be processed block (hold, colormap or buf)
51215:   //    'bytes_to_consume' is number of bytes to consume from 'buf'
51215:   //    'buf' points to the bytes to be consumed from the input buffer
51215:   //    'len' is number of bytes left in input buffer from position 'buf'.
51215:   //    At entrance of the for loop will 'buf' will be moved 'bytes_to_consume'
51215:   //    to point to next buffer, 'len' is adjusted accordingly.
51215:   //    So that next round in for loop, q gets pointed to the next buffer.
51215: 
51215:   for (;len >= mGIFStruct.bytes_to_consume; q=buf) {
51215:     // Eat the current block from the buffer, q keeps pointed at current block
51215:     buf += mGIFStruct.bytes_to_consume;
51215:     len -= mGIFStruct.bytes_to_consume;
51215: 
51215:     switch (mGIFStruct.state)
51215:     {
51215:     case gif_lzw:
51215:       if (!DoLzw(q)) {
51215:         mGIFStruct.state = gif_error;
51215:         break;
51215:       }
51215:       GETN(1, gif_sub_block);
51215:       break;
51215: 
51215:     case gif_lzw_start:
51215:     {
51215:       // Make sure the transparent pixel is transparent in the colormap
51215:       if (mGIFStruct.is_transparent) {
51215:         // Save old value so we can restore it later
51215:         if (mColormap == mGIFStruct.global_colormap)
51215:             mOldColor = mColormap[mGIFStruct.tpixel];
51215:         mColormap[mGIFStruct.tpixel] = 0;
51215:       }
51215: 
51215:       /* Initialize LZW parser/decoder */
51215:       mGIFStruct.datasize = *q;
51215:       const int clear_code = ClearCode();
51215:       if (mGIFStruct.datasize > MAX_LZW_BITS ||
51215:           clear_code >= MAX_BITS) {
51215:         mGIFStruct.state = gif_error;
51215:         break;
51215:       }
51215: 
51215:       mGIFStruct.avail = clear_code + 2;
51215:       mGIFStruct.oldcode = -1;
51215:       mGIFStruct.codesize = mGIFStruct.datasize + 1;
51215:       mGIFStruct.codemask = (1 << mGIFStruct.codesize) - 1;
51215:       mGIFStruct.datum = mGIFStruct.bits = 0;
51215: 
51215:       /* init the tables */
51215:       for (int i = 0; i < clear_code; i++)
51215:         mGIFStruct.suffix[i] = i;
51215: 
51215:       mGIFStruct.stackp = mGIFStruct.stack;
51215: 
51215:       GETN(1, gif_sub_block);
51215:     }
51215:     break;
51215: 
51215:     /* All GIF files begin with "GIF87a" or "GIF89a" */
51215:     case gif_type:
51215:       if (!strncmp((char*)q, "GIF89a", 6)) {
51215:         mGIFStruct.version = 89;
51215:       } else if (!strncmp((char*)q, "GIF87a", 6)) {
51215:         mGIFStruct.version = 87;
51215:       } else {
51215:         mGIFStruct.state = gif_error;
51215:         break;
51215:       }
51215:       GETN(7, gif_global_header);
51215:       break;
51215: 
51215:     case gif_global_header:
51215:       /* This is the height and width of the "screen" or
51215:        * frame into which images are rendered.  The
51215:        * individual images can be smaller than the
51215:        * screen size and located with an origin anywhere
51215:        * within the screen.
51215:        */
51215: 
51215:       mGIFStruct.screen_width = GETINT16(q);
51215:       mGIFStruct.screen_height = GETINT16(q + 2);
51215:       mGIFStruct.global_colormap_depth = (q[4]&0x07) + 1;
51215: 
51215:       // screen_bgcolor is not used
51215:       //mGIFStruct.screen_bgcolor = q[5];
51215:       // q[6] = Pixel Aspect Ratio
51215:       //   Not used
51215:       //   float aspect = (float)((q[6] + 15) / 64.0);
51215: 
51215:       if (q[4] & 0x80) { /* global map */
51215:         // Get the global colormap
51215:         const PRUint32 size = (3 << mGIFStruct.global_colormap_depth);
51215:         if (len < size) {
51215:           // Use 'hold' pattern to get the global colormap
51215:           GETN(size, gif_global_colormap);
51215:           break;
51215:         }
51215:         // Copy everything, go to colormap state to do CMS correction
51215:         memcpy(mGIFStruct.global_colormap, buf, size);
51215:         buf += size;
51215:         len -= size;
51215:         GETN(0, gif_global_colormap);
51215:         break;
51215:       }
51215: 
51215:       GETN(1, gif_image_start);
51215:       break;
51215: 
51215:     case gif_global_colormap:
51215:       // Everything is already copied into global_colormap
51215:       // Convert into Cairo colors including CMS transformation
51215:       ConvertColormap(mGIFStruct.global_colormap, 1<<mGIFStruct.global_colormap_depth);
51215:       GETN(1, gif_image_start);
51215:       break;
51215: 
51215:     case gif_image_start:
51215:       switch (*q) {
51215:         case GIF_TRAILER:
51215:           mGIFStruct.state = gif_done;
51215:           break;
51215: 
51215:         case GIF_EXTENSION_INTRODUCER:
51215:           GETN(2, gif_extension);
51215:           break;
51215: 
51215:         case GIF_IMAGE_SEPARATOR:
51215:           GETN(9, gif_image_header);
51215:           break;
51215: 
51215:         default:
51215:           /* If we get anything other than GIF_IMAGE_SEPARATOR, 
51215:            * GIF_EXTENSION_INTRODUCER, or GIF_TRAILER, there is extraneous data
51215:            * between blocks. The GIF87a spec tells us to keep reading
51215:            * until we find an image separator, but GIF89a says such
51215:            * a file is corrupt. We follow GIF89a and bail out. */
51215:           if (mGIFStruct.images_decoded > 0) {
51215:             /* The file is corrupt, but one or more images have
51215:              * been decoded correctly. In this case, we proceed
51215:              * as if the file were correctly terminated and set
51215:              * the state to gif_done, so the GIF will display.
51215:              */
51215:             mGIFStruct.state = gif_done;
51215:           } else {
51215:             /* No images decoded, there is nothing to display. */
51215:             mGIFStruct.state = gif_error;
51215:           }
51215:       }
51215:       break;
51215: 
51215:     case gif_extension:
51215:       mGIFStruct.bytes_to_consume = q[1];
51215:       if (mGIFStruct.bytes_to_consume) {
51215:         switch (*q) {
51215:         case GIF_GRAPHIC_CONTROL_LABEL:
51215:           mGIFStruct.state = gif_control_extension;
51215:           break;
51215:   
51215:         case GIF_APPLICATION_EXTENSION_LABEL:
51215:           mGIFStruct.state = gif_application_extension;
51215:           break;
51215:   
51215:         case GIF_COMMENT_LABEL:
51215:           mGIFStruct.state = gif_consume_comment;
51215:           break;
51215:   
51215:         default:
51215:           mGIFStruct.state = gif_skip_block;
51215:         }
51215:       } else {
51215:         GETN(1, gif_image_start);
51215:       }
51215:       break;
51215: 
51215:     case gif_consume_block:
51215:       if (!*q)
51215:         GETN(1, gif_image_start);
51215:       else
51215:         GETN(*q, gif_skip_block);
51215:       break;
51215: 
51215:     case gif_skip_block:
51215:       GETN(1, gif_consume_block);
51215:       break;
51215: 
51215:     case gif_control_extension:
51215:       mGIFStruct.is_transparent = *q & 0x1;
51215:       mGIFStruct.tpixel = q[3];
51215:       mGIFStruct.disposal_method = ((*q) >> 2) & 0x7;
51215:       // Some specs say 3rd bit (value 4), other specs say value 3
51215:       // Let's choose 3 (the more popular)
51215:       if (mGIFStruct.disposal_method == 4)
51215:         mGIFStruct.disposal_method = 3;
51215:       mGIFStruct.delay_time = GETINT16(q + 1) * 10;
51215:       GETN(1, gif_consume_block);
51215:       break;
51215: 
51215:     case gif_comment_extension:
51215:       if (*q)
51215:         GETN(*q, gif_consume_comment);
51215:       else
51215:         GETN(1, gif_image_start);
51215:       break;
51215: 
51215:     case gif_consume_comment:
51215:       GETN(1, gif_comment_extension);
51215:       break;
51215: 
51215:     case gif_application_extension:
51215:       /* Check for netscape application extension */
51215:       if (!strncmp((char*)q, "NETSCAPE2.0", 11) ||
51215:         !strncmp((char*)q, "ANIMEXTS1.0", 11))
51215:         GETN(1, gif_netscape_extension_block);
51215:       else
51215:         GETN(1, gif_consume_block);
51215:       break;
51215: 
51215:     /* Netscape-specific GIF extension: animation looping */
51215:     case gif_netscape_extension_block:
51215:       if (*q)
51215:         GETN(*q, gif_consume_netscape_extension);
51215:       else
51215:         GETN(1, gif_image_start);
51215:       break;
51215: 
51215:     /* Parse netscape-specific application extensions */
51215:     case gif_consume_netscape_extension:
51215:       switch (q[0] & 7) {
51215:         case 1:
51215:           /* Loop entire animation specified # of times.  Only read the
51215:              loop count during the first iteration. */
51215:           mGIFStruct.loop_count = GETINT16(q + 1);
51215:           GETN(1, gif_netscape_extension_block);
51215:           break;
51215:         
51215:         case 2:
51215:           /* Wait for specified # of bytes to enter buffer */
51215:           // Don't do this, this extension doesn't exist (isn't used at all) 
51215:           // and doesn't do anything, as our streaming/buffering takes care of it all...
51215:           // See: http://semmix.pl/color/exgraf/eeg24.htm
51215:           GETN(1, gif_netscape_extension_block);
51215:           break;
51215:   
51215:         default:
51215:           // 0,3-7 are yet to be defined netscape extension codes
51215:           mGIFStruct.state = gif_error;
51215:       }
51215:       break;
51215: 
51215:     case gif_image_header:
51215:     {
51215:       /* Get image offsets, with respect to the screen origin */
51215:       mGIFStruct.x_offset = GETINT16(q);
51215:       mGIFStruct.y_offset = GETINT16(q + 2);
51215: 
51215:       /* Get image width and height. */
51215:       mGIFStruct.width  = GETINT16(q + 4);
51215:       mGIFStruct.height = GETINT16(q + 6);
51215: 
51215:       if (!mGIFStruct.images_decoded) {
51215:         /* Work around broken GIF files where the logical screen
51215:          * size has weird width or height.  We assume that GIF87a
51215:          * files don't contain animations.
51215:          */
51215:         if ((mGIFStruct.screen_height < mGIFStruct.height) ||
51215:             (mGIFStruct.screen_width < mGIFStruct.width) ||
51215:             (mGIFStruct.version == 87)) {
51215:           mGIFStruct.screen_height = mGIFStruct.height;
51215:           mGIFStruct.screen_width = mGIFStruct.width;
51215:           mGIFStruct.x_offset = 0;
51215:           mGIFStruct.y_offset = 0;
51215:         }    
51215:         // Create the image container with the right size.
51215:         BeginGIF();
68123:         if (HasError()) {
68123:           // Setting the size lead to an error; this can happen when for example
68123:           // a multipart channel sends an image of a different size.
68123:           mGIFStruct.state = gif_error;
68123:           return;
68123:         }
51215: 
51244:         // If we were doing a size decode, we're done
51244:         if (IsSizeDecode())
53668:           return;
51215:       }
51215: 
51215:       /* Work around more broken GIF files that have zero image
51215:          width or height */
51215:       if (!mGIFStruct.height || !mGIFStruct.width) {
51215:         mGIFStruct.height = mGIFStruct.screen_height;
51215:         mGIFStruct.width = mGIFStruct.screen_width;
51215:         if (!mGIFStruct.height || !mGIFStruct.width) {
51215:           mGIFStruct.state = gif_error;
51215:           break;
51215:         }
51215:       }
51215: 
51215:       /* Depth of colors is determined by colormap */
51215:       /* (q[8] & 0x80) indicates local colormap */
51215:       /* bits per pixel is (q[8]&0x07 + 1) when local colormap is set */
51215:       PRUint32 depth = mGIFStruct.global_colormap_depth;
51215:       if (q[8] & 0x80)
51215:         depth = (q[8]&0x07) + 1;
51215:       PRUint32 realDepth = depth;
51215:       while (mGIFStruct.tpixel >= (1 << realDepth) && (realDepth < 8)) {
51215:         realDepth++;
51215:       } 
51215:       // Mask to limit the color values within the colormap
51215:       mColorMask = 0xFF >> (8 - realDepth);
51215:       nsresult rv = BeginImageFrame(realDepth);
51215:       if (NS_FAILED(rv) || !mImageData) {
51215:         mGIFStruct.state = gif_error;
51215:         break;
51215:       }
51215: 
51215:       if (q[8] & 0x40) {
51215:         mGIFStruct.interlaced = PR_TRUE;
51215:         mGIFStruct.ipass = 1;
51215:       } else {
51215:         mGIFStruct.interlaced = PR_FALSE;
51215:         mGIFStruct.ipass = 0;
51215:       }
51215: 
51215:       /* Only apply the Haeberli display hack on the first frame */
51215:       mGIFStruct.progressive_display = (mGIFStruct.images_decoded == 0);
51215: 
51215:       /* Clear state from last image */
51215:       mGIFStruct.irow = 0;
51215:       mGIFStruct.rows_remaining = mGIFStruct.height;
51215:       mGIFStruct.rowp = mImageData;
51215: 
51215:       /* bits per pixel is q[8]&0x07 */
51215: 
51215:       if (q[8] & 0x80) /* has a local colormap? */
51215:       {
51215:         mGIFStruct.local_colormap_size = 1 << depth;
51215:         if (!mGIFStruct.images_decoded) {
51215:           // First frame has local colormap, allocate space for it
51215:           // as the image frame doesn't have its own palette
51215:           mColormapSize = sizeof(PRUint32) << realDepth;
51215:           if (!mGIFStruct.local_colormap) {
53676:             mGIFStruct.local_colormap = (PRUint32*)moz_xmalloc(mColormapSize);
51215:           }
51215:           mColormap = mGIFStruct.local_colormap;
51215:         }
51215:         const PRUint32 size = 3 << depth;
51215:         if (mColormapSize > size) {
51215:           // Clear the notfilled part of the colormap
51215:           memset(((PRUint8*)mColormap) + size, 0, mColormapSize - size);
51215:         }
51215:         if (len < size) {
51215:           // Use 'hold' pattern to get the image colormap
51215:           GETN(size, gif_image_colormap);
51215:           break;
51215:         }
51215:         // Copy everything, go to colormap state to do CMS correction
51215:         memcpy(mColormap, buf, size);
51215:         buf += size;
51215:         len -= size;
51215:         GETN(0, gif_image_colormap);
51215:         break;
51215:       } else {
51215:         /* Switch back to the global palette */
51215:         if (mGIFStruct.images_decoded) {
51215:           // Copy global colormap into the palette of current frame
51215:           memcpy(mColormap, mGIFStruct.global_colormap, mColormapSize);
51215:         } else {
51215:           mColormap = mGIFStruct.global_colormap;
51215:         }
51215:       }
51215:       GETN(1, gif_lzw_start);
51215:     }
51215:     break;
51215: 
51215:     case gif_image_colormap:
51215:       // Everything is already copied into local_colormap
51215:       // Convert into Cairo colors including CMS transformation
51215:       ConvertColormap(mColormap, mGIFStruct.local_colormap_size);
51215:       GETN(1, gif_lzw_start);
51215:       break;
51215: 
51215:     case gif_sub_block:
51215:       mGIFStruct.count = *q;
51215:       if (mGIFStruct.count) {
51215:         /* Still working on the same image: Process next LZW data block */
51215:         /* Make sure there are still rows left. If the GIF data */
51215:         /* is corrupt, we may not get an explicit terminator.   */
51215:         if (!mGIFStruct.rows_remaining) {
51215: #ifdef DONT_TOLERATE_BROKEN_GIFS
51215:           mGIFStruct.state = gif_error;
51215:           break;
51215: #else
51215:           /* This is an illegal GIF, but we remain tolerant. */
51215:           GETN(1, gif_sub_block);
51215: #endif
51215:           if (mGIFStruct.count == GIF_TRAILER) {
51215:             /* Found a terminator anyway, so consider the image done */
51215:             GETN(1, gif_done);
51215:             break;
51215:           }
51215:         }
51215:         GETN(mGIFStruct.count, gif_lzw);
51215:       } else {
51215:         /* See if there are any more images in this sequence. */
51215:         EndImageFrame();
51215:         GETN(1, gif_image_start);
51215:       }
51215:       break;
51215: 
51215:     case gif_done:
53669:       PostDecodeDone();
53669:       mGIFOpen = PR_FALSE;
53668:       goto done;
51215: 
51215:     case gif_error:
53668:       PostDataError();
53668:       return;
51215: 
51215:     // We shouldn't ever get here.
51215:     default:
51215:       break;
51215:     }
51215:   }
51215: 
51215:   // if an error state is set but no data remains, code flow reaches here
51215:   if (mGIFStruct.state == gif_error) {
53668:       PostDataError();
53668:       return;
51215:   }
51215:   
51215:   // Copy the leftover into mGIFStruct.hold
51215:   mGIFStruct.bytes_in_hold = len;
51215:   if (len) {
51215:     // Add what we have sofar to the block
51215:     PRUint8* p = (mGIFStruct.state == gif_global_colormap) ? (PRUint8*)mGIFStruct.global_colormap :
51215:                  (mGIFStruct.state == gif_image_colormap) ? (PRUint8*)mColormap :
51215:                  mGIFStruct.hold;
51215:     memcpy(p, buf, len);
51215:     mGIFStruct.bytes_to_consume -= len;
51215:   }
51215: 
53668: // We want to flush before returning if we're on the first frame
53668: done:
53668:   if (!mGIFStruct.images_decoded) {
53668:     FlushImageData();
53668:     mLastFlushedRow = mCurrentRow;
53668:     mLastFlushedPass = mCurrentPass;
53668:   }
53668: 
53668:   return;
51215: }
51241: 
51241: } // namespace imagelib
51241: } // namespace mozilla
