86265: /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
86265: /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
86265: /* ***** BEGIN LICENSE BLOCK *****
86265:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
86265:  *
86265:  * The contents of this file are subject to the Mozilla Public License Version
86265:  * 1.1 (the "License"); you may not use this file except in compliance with
86265:  * the License. You may obtain a copy of the License at
86265:  * http://www.mozilla.org/MPL/
86265:  *
86265:  * Software distributed under the License is distributed on an "AS IS" basis,
86265:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
86265:  * for the specific language governing rights and limitations under the
86265:  * License.
86265:  *
86265:  * The Original Code is Telephony.
86265:  *
86265:  * The Initial Developer of the Original Code is
86265:  *   The Mozilla Foundation.
86265:  * Portions created by the Initial Developer are Copyright (C) 2011
86265:  * the Initial Developer. All Rights Reserved.
86265:  *
86265:  * Contributor(s):
86265:  *   Andreas Gal <gal@mozilla.com>
86265:  *   Blake Kaplan <mrbkap@gmail.com>
86265:  *
86265:  * Alternatively, the contents of this file may be used under the terms of
86265:  * either the GNU General Public License Version 2 or later (the "GPL"), or
86265:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
86265:  * in which case the provisions of the GPL or the LGPL are applicable instead
86265:  * of those above. If you wish to allow use of your version of this file only
86265:  * under the terms of either the GPL or the LGPL, and not to allow others to
86265:  * use your version of this file under the terms of the MPL, indicate your
86265:  * decision by deleting the provisions above and replace them with the notice
86265:  * and other provisions required by the GPL or the LGPL. If you do not delete
86265:  * the provisions above, a recipient may use your version of this file under
86265:  * the terms of any one of the MPL, the GPL or the LGPL.
86265:  *
86265:  * ***** END LICENSE BLOCK ***** */
86265: 
86265: "use strict";
86265: 
86265: const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
86265: 
86265: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
86265: 
86265: const DEBUG = true; // set to false to suppress debug messages
86265: 
86265: const WIFIWORKER_CONTRACTID = "@mozilla.org/wifi/worker;1";
86265: const WIFIWORKER_CID        = Components.ID("{a14e8977-d259-433a-a88d-58dd44657e5b}");
86265: 
86265: const WIFIWORKER_WORKER     = "resource://gre/modules/network_worker.js";
86265: 
87412: // A note about errors and error handling in this file:
87412: // The libraries that we use in this file are intended for C code. For
87412: // C code, it is natural to return -1 for errors and 0 for success.
87412: // Therefore, the code that interacts directly with the worker uses this
87412: // convention (note: command functions do get boolean results since the
87412: // command always succeeds and we do a string/boolean check for the
87412: // expected results).
86265: var WifiManager = (function() {
86265:   var controlWorker = new ChromeWorker(WIFIWORKER_WORKER);
86265:   var eventWorker = new ChromeWorker(WIFIWORKER_WORKER);
86265: 
86265:   // Callbacks to invoke when a reply arrives from the controlWorker.
86265:   var controlCallbacks = Object.create(null);
86265:   var idgen = 0;
86265: 
86265:   function controlMessage(obj, callback) {
86265:     var id = idgen++;
86265:     obj.id = id;
86265:     if (callback)
86265:       controlCallbacks[id] = callback;
86265:     controlWorker.postMessage(obj);
86265:   }
86265: 
86265:   function onerror(e) {
86265:     // It is very important to call preventDefault on the event here.
86265:     // If an exception is thrown on the worker, it bubbles out to the
86265:     // component that created it. If that component doesn't have an
86265:     // onerror handler, the worker will try to call the error reporter
86265:     // on the context it was created on. However, That doesn't work
86265:     // for component contexts and can result in crashes. This onerror
86265:     // handler has to make sure that it calls preventDefault on the
86265:     // incoming event.
86265:     e.preventDefault();
86265: 
86265:     var worker = (this === controlWorker) ? "control" : "event";
86265: 
86265:     debug("Got an error from the " + worker + " worker: " + e.filename +
86265:           ":" + e.lineno + ": " + e.message + "\n");
86265:   }
86265: 
86265:   controlWorker.onerror = onerror;
86265:   eventWorker.onerror = onerror;
86265: 
86265:   controlWorker.onmessage = function(e) {
86265:     var data = e.data;
86265:     var id = data.id;
86265:     var callback = controlCallbacks[id];
86265:     if (callback) {
86265:       callback(data);
86265:       delete controlCallbacks[id];
86265:     }
86265:   };
86265: 
86265:   // Polling the status worker
86265:   var recvErrors = 0;
86265:   eventWorker.onmessage = function(e) {
86265:     // process the event and tell the event worker to listen for more events
86265:     if (handleEvent(e.data.event))
86265:       waitForEvent();
86265:   };
86265: 
86265:   function waitForEvent() {
86265:     eventWorker.postMessage({ cmd: "wait_for_event" });
86265:   }
86265: 
86265:   // Commands to the control worker
86265: 
86265:   function voidControlMessage(cmd, callback) {
86265:     controlMessage({ cmd: cmd }, function (data) {
86265:       callback(data.status);
86265:     });
86265:   }
86265: 
86265:   function loadDriver(callback) {
86265:     voidControlMessage("load_driver", callback);
86265:   }
86265: 
86265:   function unloadDriver(callback) {
86265:     voidControlMessage("unload_driver", callback);
86265:   }
86265: 
86265:   function startSupplicant(callback) {
86265:     voidControlMessage("start_supplicant", callback);
86265:   }
86265: 
86265:   function stopSupplicant(callback) {
86265:     voidControlMessage("stop_supplicant", callback);
86265:   }
86265: 
86265:   function connectToSupplicant(callback) {
86265:     voidControlMessage("connect_to_supplicant", callback);
86265:   }
86265: 
86265:   function closeSupplicantConnection(callback) {
86265:     voidControlMessage("close_supplicant_connection", callback);
86265:   }
86265: 
86265:   function doCommand(request, callback) {
86265:     controlMessage({ cmd: "command", request: request }, callback);
86265:   }
86265: 
86265:   function doIntCommand(request, callback) {
86265:     doCommand(request, function(data) {
86265:       callback(data.status ? -1 : (data.reply|0));
86265:     });
86265:   }
86265: 
86265:   function doBooleanCommand(request, expected, callback) {
86265:     doCommand(request, function(data) {
86265:       callback(data.status ? false : (data.reply == expected));
86265:     });
86265:   }
86265: 
86265:   function doStringCommand(request, callback) {
86265:     doCommand(request, function(data) {
86265:       callback(data.status ? null : data.reply);
86265:     });
86265:   }
86265: 
86265:   function listNetworksCommand(callback) {
86265:     doStringCommand("LIST_NETWORKS", callback);
86265:   }
86265: 
86265:   function addNetworkCommand(callback) {
86265:     doIntCommand("ADD_NETWORK", callback);
86265:   }
86265: 
86265:   function setNetworkVariableCommand(netId, name, value, callback) {
86265:     doBooleanCommand("SET_NETWORK " + netId + " " + name + " " + value, "OK", callback);
86265:   }
86265: 
86265:   function getNetworkVariableCommand(netId, name, callback) {
86265:     doStringCommand("GET_NETWORK " + netId + " " + name, callback);
86265:   }
86265: 
86265:   function removeNetworkCommand(netId, callback) {
86265:     doBooleanCommand("REMOVE_NETWORK " + netId, callback);
86265:   }
86265: 
86265:   function enableNetworkCommand(netId, disableOthers, callback) {
86265:     doBooleanCommand((disableOthers ? "SELECT_NETWORK " : "ENABLE_NETWORK ") + netId, "OK", callback);
86265:   }
86265: 
86265:   function disableNetworkCommand(netId, callback) {
86265:     doBooleanCommand("DISABLE_NETWORK " + netId, "OK", callback);
86265:   }
86265: 
86265:   function statusCommand(callback) {
86265:     doStringCommand("STATUS", callback);
86265:   }
86265: 
86265:   function pingCommand(callback) {
86265:     doBooleanCommand("PING", "PONG", callback);
86265:   }
86265: 
86265:   function scanResultsCommand(callback) {
86265:     doStringCommand("SCAN_RESULTS", callback);
86265:   }
86265: 
86265:   function disconnectCommand(callback) {
86265:     doBooleanCommand("DISCONNECT", "OK", callback);
86265:   }
86265: 
86265:   function reconnectCommand(callback) {
86265:     doBooleanCommand("RECONNECT", "OK", callback);
86265:   }
86265: 
86265:   function reassociateCommand(callback) {
86265:     doBooleanCommand("REASSOCIATE", "OK", callback);
86265:   }
86265: 
86265:   var scanModeActive = false;
86265: 
86265:   function doSetScanModeCommand(setActive, callback) {
86265:     doBooleanCommand(setActive ? "DRIVER SCAN-ACTIVE" : "DRIVER SCAN-PASSIVE", "OK", callback);
86265:   }
86265: 
86265:   function scanCommand(forceActive, callback) {
86265:     if (forceActive && !scanModeActive) {
86265:       doSetScanModeCommand(true, function(ok) {
86265:         ok && doBooleanCommand("SCAN", "OK", function(ok) {
86265:           ok && doSetScanModeCommand(false, callback);
86265:         });
86265:       });
86265:       return;
86265:     }
86265:     doBooleanCommand("SCAN", "OK", callback);
86265:   }
86265: 
86265:   function setScanModeCommand(setActive, callback) {
86265:     sScanModeActive = setActive;
86265:     doSetScanModeCommand(setActive, callback);
86265:   }
86265: 
86265:   function startDriverCommand(callback) {
86265:     doBooleanCommand("DRIVER START", "OK");
86265:   }
86265: 
86265:   function stopDriverCommand(callback) {
86265:     doBooleanCommand("DRIVER STOP", "OK");
86265:   }
86265: 
86265:   function startPacketFiltering(callback) {
86265:     doBooleanCommand("DRIVER RXFILTER-ADD 0", "OK", function(ok) {
86265:       ok && doBooleanCommand("DRIVER RXFILTER-ADD 1", "OK", function(ok) {
86265:         ok && doBooleanCommand("DRIVER RXFILTER-ADD 3", "OK", function(ok) {
86265:           ok && doBooleanCommand("DRIVER RXFILTER-START", "OK", callback)
86265:         });
86265:       });
86265:     });
86265:   }
86265: 
86265:   function stopPacketFiltering(callback) {
86265:     doBooleanCommand("DRIVER RXFILTER-STOP", "OK", function(ok) {
86265:       ok && doBooleanCommand("DRIVER RXFILTER-REMOVE 3", "OK", function(ok) {
86265:         ok && doBooleanCommand("DRIVER RXFILTER-REMOVE 1", "OK", function(ok) {
86265:           ok && doBooleanCommand("DRIVER RXFILTER-REMOVE 0", "OK", callback)
86265:         });
86265:       });
86265:     });
86265:   }
86265: 
86265:   function doGetRssiCommand(cmd, callback) {
86265:     doCommand(cmd, function(data) {
86265:       var rssi = -200;
86265: 
86265:       if (!data.status) {
86265:         // If we are associating, the reply is "OK".
86265:         var reply = data.reply;
86265:         if (reply != "OK") {
86265:           // Format is: <SSID> rssi XX". SSID can contain spaces.
86265:           var offset = reply.lastIndexOf("rssi ");
86265:           if (offset != -1)
86265:             rssi = reply.substr(offset + 5) | 0;
86265:         }
86265:       }
86265:       callback(rssi);
86265:     });
86265:   }
86265: 
86265:   function getRssiCommand(callback) {
86265:     doGetRssiCommand("DRIVER RSSI", callback);
86265:   }
86265: 
86265:   function getRssiApproxCommand(callback) {
86265:     doGetRssiCommand("DRIVER RSSI-APPROX", callback);
86265:   }
86265: 
86265:   function getLinkSpeedCommand(callback) {
86265:     doStringCommand("DRIVER LINKSPEED", function(reply) {
86265:       if (reply)
86265:         reply = reply.split()[1] | 0; // Format: LinkSpeed XX
86265:       callback(reply);
86265:     });
86265:   }
86265: 
86265:   function getMacAddressCommand(callback) {
86265:     doStringCommand("DRIVER MACADDR", function(reply) {
86265:       if (reply)
86265:         reply = reply.split(" ")[2]; // Format: Macaddr = XX.XX.XX.XX.XX.XX
86265:       callback(reply);
86265:     });
86265:   }
86265: 
86265:   function setPowerModeCommand(mode, callback) {
86265:     doBooleanCommand("DRIVER POWERMODE " + mode, "OK", callback);
86265:   }
86265: 
86265:   function getPowerModeCommand(callback) {
86265:     doStringCommand("DRIVER GETPOWER", function(reply) {
86265:       if (reply)
86265:         reply = (reply.split()[2]|0); // Format: powermode = XX
86265:       callback(reply);
86265:     });
86265:   }
86265: 
86265:   function setNumAllowedChannelsCommand(numChannels, callback) {
86265:     doBooleanCommand("DRIVER SCAN-CHANNELS " + numChannels, "OK", callback);
86265:   }
86265: 
86265:   function getNumAllowedChannelsCommand(callback) {
86265:     doStringCommand("DRIVER SCAN-CHANNELS", function(reply) {
86265:       if (reply)
86265:         reply = (reply.split()[2]|0); // Format: Scan-Channels = X
86265:       callback(reply);
86265:     });
86265:   }
86265: 
86265:   function setBluetoothCoexistenceModeCommand(mode, callback) {
86265:     doBooleanCommand("DRIVER BTCOEXMODE " + mode, "OK", callback);
86265:   }
86265: 
86265:   function setBluetoothCoexistenceScanModeCommand(mode, callback) {
86265:     doBooleanCommand("DRIVER BTCOEXSCAN-" + (mode ? "START" : "STOP"), "OK", callback);
86265:   }
86265: 
86265:   function saveConfigCommand(callback) {
86265:     // Make sure we never write out a value for AP_SCAN other than 1
86265:     doBooleanCommand("AP_SCAN 1", "OK", function(ok) {
86265:       doBooleanCommand("SAVE_CONFIG", "OK", callback);
86265:     });
86265:   }
86265: 
86265:   function reloadConfigCommand(callback) {
86265:     doBooleanCommand("RECONFIGURE", "OK", callback);
86265:   }
86265: 
86265:   function setScanResultHandlingCommand(mode, callback) {
86265:     doBooleanCommand("AP_SCAN " + mode, "OK", callback);
86265:   }
86265: 
86265:   function addToBlacklistCommand(bssid, callback) {
86265:     doBooleanCommand("BLACKLIST " + bssid, "OK", callback);
86265:   }
86265: 
86265:   function clearBlacklistCommand(callback) {
86265:     doBooleanCommand("BLACKLIST clear", "OK", callback);
86265:   }
86265: 
86265:   function setSuspendOptimizationsCommand(enabled, callback) {
86265:     doBooleanCommand("DRIVER SETSUSPENDOPT " + (enabled ? 0 : 1), "OK", callback);
86265:   }
86265: 
86265:   function getProperty(key, defaultValue, callback) {
86265:     controlMessage({ cmd: "property_get", key: key, defaultValue: defaultValue }, function(data) {
86265:       callback(data.status < 0 ? null : data.value);
86265:     });
86265:   }
86265: 
86265:   function setProperty(key, value, callback) {
86265:     controlMessage({ cmd: "property_set", key: key, value: value }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function enableInterface(ifname, callback) {
86265:     controlMessage({ cmd: "ifc_enable", ifname: ifname }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function disableInterface(ifname, callback) {
86265:     controlMessage({ cmd: "ifc_disable", ifname: ifname }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function addHostRoute(ifname, route, callback) {
86265:     controlMessage({ cmd: "ifc_add_host_route", ifname: ifname, route: route }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function removeHostRoutes(ifname, callback) {
86265:     controlMessage({ cmd: "ifc_remove_host_routes", ifname: ifname }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function setDefaultRoute(ifname, route, callback) {
86265:     controlMessage({ cmd: "ifc_set_default_route", ifname: ifname, route: route }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function getDefaultRoute(ifname, callback) {
86265:     controlMessage({ cmd: "ifc_get_default_route", ifname: ifname }, function(data) {
86265:       callback(!data.route);
86265:     });
86265:   }
86265: 
86265:   function removeDefaultRoute(ifname, callback) {
86265:     controlMessage({ cmd: "ifc_remove_default_route", ifname: ifname }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function resetConnections(ifname, callback) {
86265:     controlMessage({ cmd: "ifc_reset_connections", ifname: ifname }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function runDhcp(ifname, callback) {
86265:     controlMessage({ cmd: "dhcp_do_request", ifname: ifname }, function(data) {
86265:       callback(data.status ? null : data);
86265:     });
86265:   }
86265: 
86265:   function stopDhcp(ifname, callback) {
86265:     controlMessage({ cmd: "dhcp_stop", ifname: ifname }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function releaseDhcpLease(ifname, callback) {
86265:     controlMessage({ cmd: "dhcp_release_lease", ifname: ifname }, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function getDhcpError(callback) {
86265:     controlMessage({ cmd: "dhcp_get_errmsg" }, function(data) {
86265:       callback(data.error);
86265:     });
86265:   }
86265: 
86265:   function configureInterface(ifname, ipaddr, mask, gateway, dns1, dns2, callback) {
86265:     controlMessage({ cmd: "ifc_configure", ifname: ifname,
86265:                      ipaddr: ipaddr, mask: mask, gateway: gateway,
86265:                      dns1: dns1, dns2: dns2}, function(data) {
86265:       callback(!data.status);
86265:     });
86265:   }
86265: 
86265:   function runDhcpRenew(ifname, callback) {
86265:     controlMessage({ cmd: "dhcp_do_request", ifname: ifname }, function(data) {
86265:       callback(data.status ? null : data);
86265:     });
86265:   }
86265: 
86265:   var manager = {};
86265: 
86265:   function notify(eventName, eventObject) {
86265:     var handler = manager["on" + eventName];
86265:     if (handler) {
86265:       if (!eventObject)
86265:         eventObject = ({});
86265:       handler.call(eventObject);
86265:     }
86265:   }
86265: 
86265:   // try to connect to the supplicant
86265:   var connectTries = 0;
86265:   var retryTimer = null;
86265:   function connectCallback(ok) {
86265:     if (ok === 0) {
86265:       // tell the event worker to start waiting for events
86265:       retryTimer = null;
86265:       waitForEvent();
86265:       notify("supplicantconnection");
86265:       return;
86265:     }
86265:     if (connectTries++ < 3) {
86265:       // try again in 5 seconds
86265:       if (!retryTimer)
86265:         retryTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
86265: 
86265:       retryTimer.initWithCallback(function(timer) {
86265:           connectToSupplicant(connectCallback);
86265:         }, 5000, Ci.nsITimer.TYPE_ONE_SHOT);
86265:       return;
86265:     }
86265: 
86265:     retryTimer = null;
86265:     notify("supplicantlost");
86265:   }
86265: 
86265:   manager.start = function() {
86265:     connectToSupplicant(connectCallback);
86265:   }
86265: 
87412:   function onconnected() {
87412:     runDhcp(manager.ifname, function (data) {
87412:       if (!data) {
87412:         debug("DHCP failed to run");
87412:         return;
87412:       }
87412:       setProperty("net.dns1", ipToString(data.dns1), function(ok) {
87412:         if (!ok) {
87412:           debug("Unable to set net.dns1");
87412:           return;
87412:         }
87412:         setProperty("net.dns2", ipToString(data.dns2), function(ok) {
87412:           if (!ok) {
87412:             debug("Unable to set net.dns2");
87412:             return;
87412:           }
87412:           getProperty("net.dnschange", "0", function(value) {
87412:             if (value === null) {
87412:               debug("Unable to get net.dnschange");
87412:               return;
87412:             }
87412:             setProperty("net.dnschange", String(Number(value) + 1), function(ok) {
87412:               if (!ok)
87412:                 debug("Unable to set net.dnschange");
87412:             });
87412:           });
87412:         });
87412:       });
87412:     });
87412:   }
87412: 
86265:   var supplicantStatesMap = ["DISCONNECTED", "INACTIVE", "SCANNING", "ASSOCIATING",
86265:                              "FOUR_WAY_HANDSHAKE", "GROUP_HANDSHAKE", "COMPLETED",
86265:                              "DORMANT", "UNINITIALIZED"];
86265:   var driverEventMap = { STOPPED: "driverstopped", STARTED: "driverstarted", HANGED: "driverhung" };
86265: 
86265:   // handle events sent to us by the event worker
86265:   function handleEvent(event) {
86265:     debug("Event coming in: " + event);
86265:     if (event.indexOf("CTRL-EVENT-") !== 0) {
86265:       debug("Got weird event, possibly not doing anything.");
86265:       if (event.indexOf("WPA:") == 0 &&
86265:           event.indexOf("pre-shared key may be incorrect") != -1) {
86265:         notify("passwordmaybeincorrect");
86265:       }
86265:       return true;
86265:     }
86265: 
86265:     var eventData = event.substr(0, event.indexOf(" ") + 1);
86265:     if (eventData.indexOf("CTRL-EVENT-STATE-CHANGE") === 0) {
86265:       // Parse the event data
86265:       var fields = {};
86265:       var tokens = eventData.split(" ");
86265:       for (var n = 0; n < tokens.length; ++n) {
86265:         var kv = tokens[n].split("=");
86265:         if (kv.length === 2)
86265:           fields[kv[0]] = kv[1];
86265:       }
86265:       if (!("state" in fields))
86265:         return true;
86265:       fields.state = supplicantStatesMap[fields.state];
86265:       notify("statechange", fields);
86265:       return true;
86265:     }
86265:     if (eventData.indexOf("CTRL-EVENT-DRIVER-STATE") === 0) {
86265:       var handlerName = driverEventMap[eventData];
86265:       if (handlerName)
86265:         notify(handlerName);
86265:       return true;
86265:     }
86265:     if (eventData.indexOf("CTRL-EVENT-TERMINATING") === 0) {
86265:       // If the monitor socket is closed, we have already stopped the
86265:       // supplicant and we can stop waiting for more events and
86265:       // simply exit here (we don't have to notify).
86265:       if (eventData.indexOf("connection closed") !== -1)
86265:         return false;
86265: 
86265:       // As long we haven't seen too many recv errors yet, we
86265:       // will keep going for a bit longer
86265:       if (eventData.indexOf("recv error") !== -1 && ++recvErrors < 10)
86265:         return true;
86265: 
86265:       notify("supplicantlost");
86265:       return false;
86265:     }
86265:     if (eventData.indexOf("CTRL-EVENT-DISCONNECTED") === 0) {
86265:       notify("statechange", { state: "DISCONNECTED" });
86265:       return true;
86265:     }
86265:     if (eventData.indexOf("CTRL-EVENT-CONNECTED") === 0) {
86265:       // Format: CTRL-EVENT-CONNECTED - Connection to 00:1e:58:ec:d5:6d completed (reauth) [id=1 id_str=]
86265:       var bssid = eventData.split(" ")[4];
86265:       var id = eventData.substr(eventData.indexOf("id=")).split(" ")[0];
86265:       notify("statechange", { state: "CONNECTED", BSSID: bssid, id: id });
87412:       onconnected();
86265:       return true;
86265:     }
86265:     if (eventData.indexOf("CTRL-EVENT-SCAN-RESULTS") === 0) {
86265:       debug("Notifying of scn results available");
86265:       notify("scanresultsavailable");
86265:       return true;
86265:     }
86265:     // unknown event
86265:     return true;
86265:   }
86265: 
86265:   // Initial state
86265:   var airplaneMode = false;
86265: 
86265:   // Public interface of the wifi service
86265:   manager.setWifiEnabled = function(enable, callback) {
86265:     var targetState = enable ? "ENABLED" : "DISABLED";
86265:     if (enable == targetState)
86265:       return true;
86265:     if (enable && airplaneMode)
86265:       return false;
86265:     if (enable) {
87412:       loadDriver(function (status) {
87412:         if (status < 0) {
87412:           callback(status);
87412:           return;
87412:         }
87412:         startSupplicant(function (status) {
87412:           if (status < 0) {
87412:             callback(status);
87412:             return;
87412:           }
87412:           getProperty("wifi.interface", "tiwlan0", function (ifname) {
87412:             if (!ifname) {
87412:               callback(-1);
87412:               return;
87412:             }
87412:             manager.ifname = ifname;
87412:             enableInterface(ifname, function (ok) {
87412:               callback(ok ? 0 : -1);
87412:             });
87412:           });
87412:         });
86265:       });
86265:     } else {
87412:       stopSupplicant(function (status) {
87412:         if (ok < 0) {
87412:           callback(-1);
87412:           return;
87412:         }
87412:         disableInterface(manager.ifname, function (ok) {
87412:           unloadDriver(callback);
87412:         });
86265:       });
86265:     }
86265:   }
86265: 
86265:   manager.disconnect = disconnectCommand;
86265:   manager.reconnect = reconnectCommand;
86265:   manager.reassociate = reassociateCommand;
86265: 
86265:   var networkConfigurationFields = ["ssid", "bssid", "psk", "wep_key0", "wep_key1", "wep_key2", "wep_key3",
86265:                                     "wep_tx_keyidx", "priority", "key_mgmt", "scan_ssid"];
86265: 
86265:   manager.getNetworkConfiguration = function(config, callback) {
86265:     var netId = config.netId;
86265:     var done = 0;
86265:     for (var n = 0; n < networkConfigurationFields; ++n) {
86265:       var fieldName = networkConfigurationFields[n];
86265:       getNetworkVariableCommand(netId, fieldName, function(value) {
86265:         config[fieldName] = value;
86265:         if (++done == networkConfigurationFields.length)
86265:           callback(config);
86265:       });
86265:     }
86265:   }
86265:   manager.setNetworkConfiguration = function(config, callback) {
86265:     var netId = config.netId;
86265:     var done = 0;
86265:     var errors = 0;
86265:     for (var n = 0; n < networkConfigurationFields.length; ++n) {
86265:       var fieldName = networkConfigurationFields[n];
86265:       if (!(fieldName in config)) {
86265:         ++done;
86265:       } else {
86265:         setNetworkVariableCommand(netId, fieldName, config[fieldName], function(ok) {
86265:           if (!ok)
86265:             ++errors;
86265:           if (++done == networkConfigurationFields.length)
86265:             callback(errors == 0);
86265:         });
86265:       }
86265:     }
86265:     // If config didn't contain any of the fields we want, don't lose the error callback
86265:     if (done == networkConfigurationFields.length)
86265:       callback(false);
86265:   }
86265:   manager.getConfiguredNetworks = function(callback) {
86265:     listNetworksCommand(function (reply) {
86265:       var networks = {};
86265:       var done = 0;
86265:       var errors = 0;
86265:       var lines = reply.split("\n");
86265:       for (var n = 1; n < lines.length; ++n) {
86265:         var result = lines[n].split("\t");
86265:         var netId = result[0];
86265:         var config = networks[netId] = { netId: netId };
86265:         switch (result[3]) {
86265:         case "[CURRENT]":
86265:           config.status = "CURRENT";
86265:           break;
86265:         case "[DISABLED]":
86265:           config.status = "DISABLED";
86265:           break;
86265:         default:
86265:           config.status = "ENABLED";
86265:           break;
86265:         }
86265:         manager.getNetworkConfiguration(config, function (ok) {
86265:             if (!ok)
86265:               ++errors;
86265:             if (++done == lines.length - 1) {
86265:               if (errors) {
86265:                 // If an error occured, delete the new netId
86265:                 removeNetworkCommand(netId, function() {
86265:                   callback(null);
86265:                 });
86265:               } else {
86265:                 callback(networks);
86265:               }
86265:             }
86265:         });
86265:       }
86265:     });
86265:   }
86265:   manager.addNetwork = function(config, callback) {
86265:     addNetworkCommand(function (netId) {
86265:       config.netId = netId;
86265:       manager.setNetworkConfiguration(config, callback);
86265:     });
86265:   }
86265:   manager.updateNetwork = function(config, callback) {
86265:     manager.setNetworkConfiguration(config, callback);
86265:   }
86265:   manager.removeNetwork = function(netId, callback) {
86265:     removeNetworkCommand(netId, callback);
86265:   }
86265: 
86265:   function ipToString(n) {
87642:     return String((n >>  0) & 0xFF) + "." +
87642:                  ((n >>  8) & 0xFF) + "." +
87642:                  ((n >> 16) & 0xFF) + "." +
87642:                  ((n >> 24) & 0xFF);
86265:   }
86265: 
86265:   manager.enableNetwork = function(netId, disableOthers, callback) {
87412:     enableNetworkCommand(netId, disableOthers, callback);
86265:   }
86265:   manager.disableNetwork = function(netId, callback) {
86265:     disableNetworkCommand(netId, callback);
86265:   }
86265:   manager.getMacAddress = getMacAddressCommand;
86265:   manager.getScanResults = scanResultsCommand;
86265:   return manager;
86265: })();
86265: 
86265: function nsWifiWorker() {
86265:   WifiManager.onsupplicantconnection = function() {
86265:     debug("Connected to supplicant");
86265:     WifiManager.getMacAddress(function (mac) {
86265:       debug("Got mac: " + mac);
86265:     });
86265:   }
86265:   WifiManager.onsupplicantlost = function() {
86265:     debug("Couldn't connect to supplicant");
86265:   }
86265: 
86265:   var networks = Object.create(null);
86265:   WifiManager.onscanresultsavailable = function() {
86265:     debug("Scan results are available! Asking for them.");
86265:     if (networks["Mozilla Guest"])
86265:       return;
86265:     WifiManager.getScanResults(function(r) {
86265:       let lines = r.split("\n");
86265:       // NB: Skip the header line.
86265:       let added = !("Mozilla Guest" in networks);
86265:       for (let i = 1; i < lines.length; ++i) {
86265:         // bssid / frequency / signal level / flags / ssid
86265:         var match = /([\S]+)\s+([\S]+)\s+([\S]+)\s+(\[[\S]+\])?\s+(.*)/.exec(lines[i])
86265:         if (match)
86265:           networks[match[5]] = match[1];
86265:         else
86265:           debug("Match didn't find anything for: " + lines[i]);
86265:       }
86265: 
86265:       if (("Mozilla Guest" in networks) && added) {
86265:         debug("Mozilla Guest exists in networks, trying to connect!");
86265:         var config = Object.create(null);
86265:         config["ssid"] = '"Mozilla Guest"';
86265:         //config["bssid"] = '"' + networks["Mozilla Guest"] + '"';
86265:         config["key_mgmt"] = "NONE";
86265:         config["scan_ssid"] = 1;
86265:         WifiManager.addNetwork(config, function (ok) {
86265:           if (ok) {
86265:             WifiManager.enableNetwork(config.netId, false, function (ok) {
86265:               if (ok)
86265:                 debug("Enabled the network!");
86265:               else
86265:                 debug("Failed to enable the network :(");
86265:             });
86265:           } else {
86265:             debug("Failed to add the network :(");
86265:           }
86265:         });
86265:       }
86265:     });
86265:   }
86265: 
86265:   WifiManager.setWifiEnabled(true, function (ok) {
86265:       if (ok === 0)
86265:         WifiManager.start();
86265:       else
86265:         debug("Couldn't start Wifi");
86265:     });
86265: 
86265:   debug("Wifi starting");
86265: }
86265: 
86265: nsWifiWorker.prototype = {
86265:   classID:   WIFIWORKER_CID,
86265:   classInfo: XPCOMUtils.generateCI({classID: WIFIWORKER_CID,
86265:                                     contractID: WIFIWORKER_CONTRACTID,
86265:                                     classDescription: "WifiWorker",
86883:                                     interfaces: [Ci.nsIWorkerHolder,
86265:                                                  Ci.nsIWifi]}),
86265: 
86883:   QueryInterface: XPCOMUtils.generateQI([Ci.nsIWorkerHolder,
86265:                                          Ci.nsIWifi]),
86265: 
86265:   setWifiEnabled: function(enable) {
86265:     WifiManager.setWifiEnabled(enable, function (ok) {
86265:       debug(ok);
86265:     });
86265:   },
86265: 
86265:   // This is a bit ugly, but works. In particular, this depends on the fact
86265:   // that RadioManager never actually tries to get the worker from us.
86265:   get worker() { throw "Not implemented"; },
86265: 
86265:   shutdown: function() {
86265:     this.setWifiEnabled(false);
86265:   }
86265: };
86265: 
86265: const NSGetFactory = XPCOMUtils.generateNSGetFactory([nsWifiWorker]);
86265: 
86265: let debug;
86265: if (DEBUG) {
86265:   debug = function (s) {
86265:     dump("-*- nsWifiWorker component: " + s + "\n");
86265:   };
86265: } else {
86265:   debug = function (s) {};
86265: }
