32195: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
32836: /* ***** BEGIN LICENSE BLOCK *****
32836:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32836:  *
32836:  * The contents of this file are subject to the Mozilla Public License Version
32836:  * 1.1 (the "License"); you may not use this file except in compliance with
32836:  * the License. You may obtain a copy of the License at
32836:  * http://www.mozilla.org/MPL/
32836:  *
32836:  * Software distributed under the License is distributed on an "AS IS" basis,
32836:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32836:  * for the specific language governing rights and limitations under the
32836:  * License.
32836:  *
32836:  * The Original Code is mozilla.org code.
32836:  *
32836:  * The Initial Developer of the Original Code is
32836:  *   Mozilla Corporation.
32836:  * Portions created by the Initial Developer are Copyright (C) 2009
32836:  * the Initial Developer. All Rights Reserved.
32836:  *
32836:  * Contributor(s):
32836:  *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
32836:  *   Mark Steele <mwsteele@gmail.com>
42477:  *   Cedric Vivier <cedricv@neonux.com>
32836:  *
32836:  * Alternatively, the contents of this file may be used under the terms of
32836:  * either the GNU General Public License Version 2 or later (the "GPL"), or
32836:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32836:  * in which case the provisions of the GPL or the LGPL are applicable instead
32836:  * of those above. If you wish to allow use of your version of this file only
32836:  * under the terms of either the GPL or the LGPL, and not to allow others to
32836:  * use your version of this file under the terms of the MPL, indicate your
32836:  * decision by deleting the provisions above and replace them with the notice
32836:  * and other provisions required by the GPL or the LGPL. If you do not delete
32836:  * the provisions above, a recipient may use your version of this file under
32836:  * the terms of any one of the MPL, the GPL or the LGPL.
32836:  *
32836:  * ***** END LICENSE BLOCK ***** */
32836: 
32195: #include "WebGLContext.h"
32195: 
32195: #include "nsString.h"
32195: 
32195: #include "gfxImageSurface.h"
32195: #include "gfxContext.h"
32195: #include "gfxPlatform.h"
32195: //#include "nsIDOMHTMLCanvasElement.h"
32195: 
32195: #include "nsContentUtils.h"
32195: #include "nsDOMError.h"
32195: #include "nsLayoutUtils.h"
32195: 
32195: #include "CanvasUtils.h"
32195: 
37417: #include "jstypedarray.h"
37417: 
49256: #if defined(USE_ANGLE)
47653: // shader translator
47653: #include "angle/ShaderLang.h"
47653: #endif
47653: 
55904: #include "WebGLTexelConversions.h"
55904: 
32195: using namespace mozilla;
32195: 
42916: static PRBool BaseTypeAndSizeFromUniformType(WebGLenum uType, WebGLenum *baseType, WebGLint *unitSize);
32195: 
32195: /* Helper macros for when we're just wrapping a gl method, so that
32195:  * we can avoid having to type this 500 times.  Note that these MUST
32195:  * NOT BE USED if we need to check any of the parameters.
32195:  */
32195: 
32195: #define GL_SAME_METHOD_0(glname, name)                          \
32195: NS_IMETHODIMP WebGLContext::name() {                            \
32195:     MakeContextCurrent(); gl->f##glname(); return NS_OK;        \
32195: }
32195: 
32195: #define GL_SAME_METHOD_1(glname, name, t1)          \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1) {           \
32195:     MakeContextCurrent(); gl->f##glname(a1); return NS_OK;  \
32195: }
32195: 
32195: #define GL_SAME_METHOD_2(glname, name, t1, t2)        \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2) {      \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2); return NS_OK;           \
32195: }
32195: 
32195: #define GL_SAME_METHOD_3(glname, name, t1, t2, t3)      \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3); return NS_OK;        \
32195: }
32195: 
32195: #define GL_SAME_METHOD_4(glname, name, t1, t2, t3, t4)         \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4); return NS_OK;     \
32195: }
32195: 
32195: #define GL_SAME_METHOD_5(glname, name, t1, t2, t3, t4, t5)            \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5); return NS_OK;  \
32195: }
32195: 
32195: #define GL_SAME_METHOD_6(glname, name, t1, t2, t3, t4, t5, t6)          \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5,a6); return NS_OK; \
32195: }
32195: 
51747: already_AddRefed<WebGLUniformLocation>
51747: WebGLProgram::GetUniformLocationObject(GLint glLocation)
43331: {
43331:     WebGLUniformLocation *existingLocationObject;
43331:     if (mMapUniformLocations.Get(glLocation, &existingLocationObject)) {
43331:         return existingLocationObject;
51747:     }
51747: 
51747:     if (glLocation < 0) {
51747:         return nsnull;
51747:     }
51747: 
43331:     nsRefPtr<WebGLUniformLocation> loc = new WebGLUniformLocation(mContext, this, glLocation);
43331:     mMapUniformLocations.Put(glLocation, loc);
43331:     return loc.forget();
43331: }
43331: 
32195: //
32195: //  WebGL API
32195: //
32195: 
32835: 
32835: /* void present (); */
32835: NS_IMETHODIMP
32835: WebGLContext::Present()
32835: {
32835:     return NS_ERROR_NOT_IMPLEMENTED;
32835: }
32835: 
42916: /* void GlActiveTexture (in GLenum texture); */
32195: NS_IMETHODIMP
42916: WebGLContext::ActiveTexture(WebGLenum texture)
32195: {
32195:     if (texture < LOCAL_GL_TEXTURE0 || texture >= LOCAL_GL_TEXTURE0+mBound2DTextures.Length())
42477:         return ErrorInvalidEnum("ActiveTexture: texture unit %d out of range (0..%d)",
42477:                                 texture, mBound2DTextures.Length()-1);
32195: 
32195:     MakeContextCurrent();
32195:     mActiveTexture = texture - LOCAL_GL_TEXTURE0;
32195:     gl->fActiveTexture(texture);
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::AttachShader(nsIWebGLProgram *pobj, nsIWebGLShader *shobj)
32195: {
53701:     // if pobj or shobj are null/not specified, it's an error
53701:     if (pobj == nsnull || shobj == nsnull)
53701:         return ErrorInvalidValue("attachShader");
53701: 
42916:     WebGLuint progname, shadername;
43098:     WebGLProgram *program;
43098:     WebGLShader *shader;
47811:     if (!GetConcreteObjectAndGLName("attachShader: program", pobj, &program, &progname) ||
47811:         !GetConcreteObjectAndGLName("attachShader: shader", shobj, &shader, &shadername))
47811:         return NS_OK;
32195: 
43098:     if (!program->AttachShader(shader))
43098:         return ErrorInvalidOperation("AttachShader: shader is already attached");
43098: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fAttachShader(progname, shadername);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindAttribLocation(nsIWebGLProgram *pobj, WebGLuint location, const nsAString& name)
32195: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("bindAttribLocation: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     if (name.IsEmpty())
42477:         return ErrorInvalidValue("BindAttribLocation: name can't be null or empty");
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fBindAttribLocation(progname, location, NS_LossyConvertUTF16toASCII(name).get());
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindBuffer(WebGLenum target, nsIWebGLBuffer *bobj)
32195: {
42916:     WebGLuint bufname;
42472:     WebGLBuffer* buf;
42472:     PRBool isNull;
47811:     if (!GetConcreteObjectAndGLName("bindBuffer", bobj, &buf, &bufname, &isNull))
47811:         return NS_OK;
35488: 
32195:     if (target == LOCAL_GL_ARRAY_BUFFER) {
42472:         mBoundArrayBuffer = buf;
32195:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
42472:         mBoundElementArrayBuffer = buf;
32195:     } else {
47813:         return ErrorInvalidEnumInfo("BindBuffer: target", target);
32195:     }
32195: 
43009:     if (!isNull) {
43009:         if ((buf->Target() != LOCAL_GL_NONE) && (target != buf->Target()))
43009:             return ErrorInvalidOperation("BindBuffer: buffer already bound to a different target");
43009:         buf->SetTarget(target);
43009:     }
43009: 
42472:     MakeContextCurrent();
42472: 
42472:     gl->fBindBuffer(target, bufname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindFramebuffer(WebGLenum target, nsIWebGLFramebuffer *fbobj)
32195: {
42916:     WebGLuint framebuffername;
42472:     PRBool isNull;
42473:     WebGLFramebuffer *wfb;
42473: 
42473:     if (target != LOCAL_GL_FRAMEBUFFER)
51899:         return ErrorInvalidEnum("BindFramebuffer: target must be GL_FRAMEBUFFER");
42473: 
47811:     if (!GetConcreteObjectAndGLName("bindFramebuffer", fbobj, &wfb, &framebuffername, &isNull))
47811:         return NS_OK;
32195: 
42472:     MakeContextCurrent();
42472: 
47910:     if (isNull) {
47910:         gl->fBindFramebuffer(target, gl->GetOffscreenFBO());
47910:     } else {
42472:         gl->fBindFramebuffer(target, framebuffername);
47910:     }
32195: 
42473:     mBoundFramebuffer = wfb;
42473: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindRenderbuffer(WebGLenum target, nsIWebGLRenderbuffer *rbobj)
32195: {
42916:     WebGLuint renderbuffername;
42472:     PRBool isNull;
42473:     WebGLRenderbuffer *wrb;
42473: 
42477:     if (target != LOCAL_GL_RENDERBUFFER)
47813:         return ErrorInvalidEnumInfo("bindRenderbuffer: target", target);
42477: 
47811:     if (!GetConcreteObjectAndGLName("bindRenderBuffer", rbobj, &wrb, &renderbuffername, &isNull))
47811:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fBindRenderbuffer(target, renderbuffername);
32195: 
42473:     mBoundRenderbuffer = wrb;
42473: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BindTexture(WebGLenum target, nsIWebGLTexture *tobj)
32195: {
42916:     WebGLuint texturename;
42472:     WebGLTexture *tex;
51422:     PRBool isNull; // allow null object
47811:     if (!GetConcreteObjectAndGLName("bindTexture", tobj, &tex, &texturename, &isNull))
47811:         return NS_OK;
32195: 
32195:     if (target == LOCAL_GL_TEXTURE_2D) {
42472:         mBound2DTextures[mActiveTexture] = tex;
32195:     } else if (target == LOCAL_GL_TEXTURE_CUBE_MAP) {
42472:         mBoundCubeMapTextures[mActiveTexture] = tex;
32195:     } else {
47813:         return ErrorInvalidEnumInfo("bindTexture: target", target);
32195:     }
32195: 
42472:     MakeContextCurrent();
42472: 
51422:     if (tex)
51422:         tex->Bind(target);
51422:     else
51422:         gl->fBindTexture(target, 0 /* == texturename */);
32195: 
32195:     return NS_OK;
32195: }
32195: 
47205: GL_SAME_METHOD_4(BlendColor, BlendColor, WebGLfloat, WebGLfloat, WebGLfloat, WebGLfloat)
32195: 
43855: NS_IMETHODIMP WebGLContext::BlendEquation(WebGLenum mode)
43855: {
46443:     if (!ValidateBlendEquationEnum(mode, "blendEquation: mode"))
46443:         return NS_OK;
43855: 
43855:     MakeContextCurrent();
43855:     gl->fBlendEquation(mode);
43855:     return NS_OK;
43855: }
43855: 
43855: NS_IMETHODIMP WebGLContext::BlendEquationSeparate(WebGLenum modeRGB, WebGLenum modeAlpha)
43855: {
46443:     if (!ValidateBlendEquationEnum(modeRGB, "blendEquationSeparate: modeRGB") ||
46443:         !ValidateBlendEquationEnum(modeAlpha, "blendEquationSeparate: modeAlpha"))
46443:         return NS_OK;
43855: 
43855:     MakeContextCurrent();
43855:     gl->fBlendEquationSeparate(modeRGB, modeAlpha);
43855:     return NS_OK;
43855: }
43855: 
43855: NS_IMETHODIMP WebGLContext::BlendFunc(WebGLenum sfactor, WebGLenum dfactor)
43855: {
46443:     if (!ValidateBlendFuncSrcEnum(sfactor, "blendFunc: sfactor") ||
46443:         !ValidateBlendFuncDstEnum(dfactor, "blendFunc: dfactor"))
46443:         return NS_OK;
43855: 
43855:     MakeContextCurrent();
43855:     gl->fBlendFunc(sfactor, dfactor);
43855:     return NS_OK;
43855: }
43855: 
43855: NS_IMETHODIMP
43855: WebGLContext::BlendFuncSeparate(WebGLenum srcRGB, WebGLenum dstRGB,
43855:                                 WebGLenum srcAlpha, WebGLenum dstAlpha)
43855: {
46443:     if (!ValidateBlendFuncSrcEnum(srcRGB, "blendFuncSeparate: srcRGB") ||
46443:         !ValidateBlendFuncSrcEnum(srcAlpha, "blendFuncSeparate: srcAlpha") ||
46443:         !ValidateBlendFuncDstEnum(dstRGB, "blendFuncSeparate: dstRGB") ||
46443:         !ValidateBlendFuncDstEnum(dstAlpha, "blendFuncSeparate: dstAlpha"))
46443:         return NS_OK;
43855: 
43855:     MakeContextCurrent();
43855:     gl->fBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
43855:     return NS_OK;
43855: }
32195: 
32195: NS_IMETHODIMP
37417: WebGLContext::BufferData(PRInt32 dummy)
32195: {
37417:     // this should never be called
56955:     LogMessageIfVerbose("BufferData");
37417:     return NS_ERROR_FAILURE;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::BufferData_size(WebGLenum target, WebGLsizei size, WebGLenum usage)
32195: {
32195:     WebGLBuffer *boundBuffer = NULL;
32195: 
32195:     if (target == LOCAL_GL_ARRAY_BUFFER) {
32195:         boundBuffer = mBoundArrayBuffer;
32195:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
32195:         boundBuffer = mBoundElementArrayBuffer;
32195:     } else {
47813:         return ErrorInvalidEnumInfo("bufferData: target", target);
32195:     }
32195: 
47206:     if (size < 0)
47206:         return ErrorInvalidValue("bufferData: negative size");
47206: 
47206:     if (!ValidateBufferUsageEnum(usage, "bufferData: usage"))
47206:         return NS_OK;
47206: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     boundBuffer->SetByteLength(size);
43009:     boundBuffer->ZeroDataIfElementArray();
43009: 
37417:     gl->fBufferData(target, size, 0, usage);
37417: 
37417:     return NS_OK;
32195: }
32195: 
37417: NS_IMETHODIMP
42916: WebGLContext::BufferData_buf(WebGLenum target, js::ArrayBuffer *wb, WebGLenum usage)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
37417:     } else {
47813:         return ErrorInvalidEnumInfo("bufferData: target", target);
37417:     }
37417: 
47206:     if (!ValidateBufferUsageEnum(usage, "bufferData: usage"))
47206:         return NS_OK;
47206: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     boundBuffer->SetByteLength(wb->byteLength);
43009:     boundBuffer->CopyDataIfElementArray(wb->data);
43009: 
37417:     gl->fBufferData(target, wb->byteLength, wb->data, usage);
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
42916: WebGLContext::BufferData_array(WebGLenum target, js::TypedArray *wa, WebGLenum usage)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
37417:     } else {
47813:         return ErrorInvalidEnumInfo("bufferData: target", target);
37417:     }
37417: 
47206:     if (!ValidateBufferUsageEnum(usage, "bufferData: usage"))
47206:         return NS_OK;
47206: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     boundBuffer->SetByteLength(wa->byteLength);
43009:     boundBuffer->CopyDataIfElementArray(wa->data);
43009: 
37417:     gl->fBufferData(target, wa->byteLength, wa->data, usage);
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::BufferSubData(PRInt32 dummy)
37417: {
32195:     return NS_ERROR_FAILURE;
32195: }
37417: 
37417: NS_IMETHODIMP
43009: WebGLContext::BufferSubData_buf(GLenum target, WebGLsizei byteOffset, js::ArrayBuffer *wb)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
37417:     } else {
47813:         return ErrorInvalidEnumInfo("bufferSubData: target", target);
32195:     }
37417: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
47204:     CheckedUint32 checked_neededByteLength = CheckedUint32(byteOffset) + wb->byteLength;
47204:     if (!checked_neededByteLength.valid())
47204:         return ErrorInvalidOperation("bufferSubData: integer overflow computing the needed byte length");
47204: 
47204:     if (checked_neededByteLength.value() > boundBuffer->ByteLength())
42477:         return ErrorInvalidOperation("BufferSubData: not enough data - operation requires %d bytes, but buffer only has %d bytes",
43009:                                      byteOffset, wb->byteLength, boundBuffer->ByteLength());
32195: 
32195:     MakeContextCurrent();
32195: 
43009:     boundBuffer->CopySubDataIfElementArray(byteOffset, wb->byteLength, wb->data);
43009: 
43009:     gl->fBufferSubData(target, byteOffset, wb->byteLength, wb->data);
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
43009: WebGLContext::BufferSubData_array(WebGLenum target, WebGLsizei byteOffset, js::TypedArray *wa)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
34453:     } else {
47813:         return ErrorInvalidEnumInfo("bufferSubData: target", target);
34453:     }
37417: 
42477:     if (!boundBuffer)
42477:         return ErrorInvalidOperation("BufferData: no buffer bound!");
37417: 
47204:     CheckedUint32 checked_neededByteLength = CheckedUint32(byteOffset) + wa->byteLength;
47204:     if (!checked_neededByteLength.valid())
47204:         return ErrorInvalidOperation("bufferSubData: integer overflow computing the needed byte length");
47204: 
47204:     if (checked_neededByteLength.value() > boundBuffer->ByteLength())
42477:         return ErrorInvalidOperation("BufferSubData: not enough data -- operation requires %d bytes, but buffer only has %d bytes",
43009:                                      byteOffset, wa->byteLength, boundBuffer->ByteLength());
34453: 
34453:     MakeContextCurrent();
34453: 
43009:     boundBuffer->CopySubDataIfElementArray(byteOffset, wa->byteLength, wa->data);
43009: 
43009:     gl->fBufferSubData(target, byteOffset, wa->byteLength, wa->data);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::CheckFramebufferStatus(WebGLenum target, WebGLenum *retval)
32195: {
51424:     *retval = 0;
51424: 
32195:     MakeContextCurrent();
47910:     if (target != LOCAL_GL_FRAMEBUFFER)
56959:         return ErrorInvalidEnum("checkFramebufferStatus: target must be FRAMEBUFFER");
56959: 
56959:     if (mBoundFramebuffer && mBoundFramebuffer->HasConflictingAttachments())
56959:         *retval = LOCAL_GL_FRAMEBUFFER_UNSUPPORTED;
56959:     else
32195:         *retval = gl->fCheckFramebufferStatus(target);
56959: 
32195:     return NS_OK;
32195: }
32195: 
34453: NS_IMETHODIMP
34453: WebGLContext::Clear(PRUint32 mask)
34453: {
34453:     MakeContextCurrent();
56959: 
56959:     if (mBoundFramebuffer && !mBoundFramebuffer->CheckAndInitializeRenderbuffers())
56959:         return NS_OK;
56959: 
34453:     gl->fClear(mask);
34453:     Invalidate();
34453: 
34453:     return NS_OK;
34453: }
32195: 
47205: GL_SAME_METHOD_4(ClearColor, ClearColor, WebGLfloat, WebGLfloat, WebGLfloat, WebGLfloat)
32195: 
47205: GL_SAME_METHOD_1(ClearDepth, ClearDepth, WebGLfloat)
32195: 
47205: GL_SAME_METHOD_1(ClearStencil, ClearStencil, WebGLint)
32195: 
42916: GL_SAME_METHOD_4(ColorMask, ColorMask, WebGLboolean, WebGLboolean, WebGLboolean, WebGLboolean)
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::CopyTexImage2D(WebGLenum target,
42916:                              WebGLint level,
42916:                              WebGLenum internalformat,
42916:                              WebGLint x,
42916:                              WebGLint y,
42916:                              WebGLsizei width,
42916:                              WebGLsizei height,
42916:                              WebGLint border)
32195: {
32195:     switch (target) {
32195:         case LOCAL_GL_TEXTURE_2D:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("copyTexImage2D: target", target);
32195:     }
32195: 
32195:     switch (internalformat) {
32195:         case LOCAL_GL_RGB:
32195:         case LOCAL_GL_RGBA:
32195:         case LOCAL_GL_ALPHA:
32195:         case LOCAL_GL_LUMINANCE:
32195:         case LOCAL_GL_LUMINANCE_ALPHA:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("CopyTexImage2D: internal format", internalformat);
32195:     }
32195: 
51422:     if (border != 0)
51422:         return ErrorInvalidValue("copyTexImage2D: border must be 0");
51422: 
51422:     if (level < 0)
51422:         return ErrorInvalidValue("copyTexImage2D: level may not be negative");
32195: 
51894:     if (level >= 1) {
51894:         if (!(is_pot_assuming_nonnegative(width) &&
51894:               is_pot_assuming_nonnegative(height)))
51894:             return ErrorInvalidValue("copyTexImage2D: with level > 0, width and height must be powers of two");
51894:     }
51894: 
42477:     if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight))
42477:         return ErrorInvalidOperation("CopyTexImage2D: copied rectangle out of bounds");
32195: 
51422:     WebGLTexture *tex = activeBoundTextureForTarget(target);
51422:     if (!tex)
51418:         return ErrorInvalidOperation("copyTexImage2D: no texture bound to this target");
51418: 
51422:     tex->SetImageInfo(target, level, width, height);
51422: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::CopyTexSubImage2D(WebGLenum target,
42916:                                 WebGLint level,
42916:                                 WebGLint xoffset,
42916:                                 WebGLint yoffset,
42916:                                 WebGLint x,
42916:                                 WebGLint y,
42916:                                 WebGLsizei width,
42916:                                 WebGLsizei height)
32195: {
32195:     switch (target) {
32195:         case LOCAL_GL_TEXTURE_2D:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("CopyTexSubImage2D: target", target);
32195:     }
32195: 
42477:     if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight))
42477:         return ErrorInvalidOperation("CopyTexSubImage2D: copied rectangle out of bounds");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::CreateProgram(nsIWebGLProgram **retval)
32195: {
51424:     *retval = nsnull;
51424: 
32195:     MakeContextCurrent();
32195: 
42916:     WebGLuint name = gl->fCreateProgram();
32195: 
43099:     WebGLProgram *prog = new WebGLProgram(this, name);
32195:     NS_ADDREF(*retval = prog);
32195:     mMapPrograms.Put(name, prog);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::CreateShader(WebGLenum type, nsIWebGLShader **retval)
32195: {
51424:     *retval = nsnull;
51424: 
43098:     if (type != LOCAL_GL_VERTEX_SHADER &&
43098:         type != LOCAL_GL_FRAGMENT_SHADER)
43098:     {
47813:         return ErrorInvalidEnumInfo("createShader: type", type);
43098:     }
43098: 
32195:     MakeContextCurrent();
32195: 
42916:     WebGLuint name = gl->fCreateShader(type);
32195: 
43099:     WebGLShader *shader = new WebGLShader(this, name, type);
32195:     NS_ADDREF(*retval = shader);
32195:     mMapShaders.Put(name, shader);
32195: 
32195:     return NS_OK;
32195: }
32195: 
47205: NS_IMETHODIMP
47205: WebGLContext::CullFace(WebGLenum face)
47205: {
47205:     if (!ValidateFaceEnum(face, "cullFace"))
47205:         return NS_OK;
47205: 
47205:     MakeContextCurrent();
47205:     gl->fCullFace(face);
47205:     return NS_OK;
47205: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteBuffer(nsIWebGLBuffer *bobj)
32195: {
42916:     WebGLuint bufname;
42472:     WebGLBuffer *buf;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteBuffer", bobj, &buf, &bufname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteBuffers(1, &bufname);
42472:     buf->Delete();
42472:     mMapBuffers.Remove(bufname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteFramebuffer(nsIWebGLFramebuffer *fbobj)
32195: {
42916:     WebGLuint fbufname;
42472:     WebGLFramebuffer *fbuf;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteFramebuffer", fbobj, &fbuf, &fbufname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteFramebuffers(1, &fbufname);
42472:     fbuf->Delete();
42472:     mMapFramebuffers.Remove(fbufname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteRenderbuffer(nsIWebGLRenderbuffer *rbobj)
32195: {
42916:     WebGLuint rbufname;
42472:     WebGLRenderbuffer *rbuf;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteRenderbuffer", rbobj, &rbuf, &rbufname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     // XXX we need to track renderbuffer attachments; from glDeleteRenderbuffers man page:
32195: 
32195:     /*
32195:             If a renderbuffer object that is currently bound is deleted, the binding reverts
32195:             to 0 (the absence of any renderbuffer object). Additionally, special care
32195:             must be taken when deleting a renderbuffer object if the image of the renderbuffer
32195:             is attached to a framebuffer object. In this case, if the deleted renderbuffer object is
32195:             attached to the currently bound framebuffer object, it is 
32195:             automatically detached.  However, attachments to any other framebuffer objects are the
32195:             responsibility of the application.
32195:     */
32195: 
42472:     gl->fDeleteRenderbuffers(1, &rbufname);
56959: 
42472:     rbuf->Delete();
42472:     mMapRenderbuffers.Remove(rbufname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteTexture(nsIWebGLTexture *tobj)
32195: {
42916:     WebGLuint texname;
42472:     WebGLTexture *tex;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteTexture", tobj, &tex, &texname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteTextures(1, &texname);
42472:     tex->Delete();
42472:     mMapTextures.Remove(texname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteProgram(nsIWebGLProgram *pobj)
32195: {
42916:     WebGLuint progname;
42472:     WebGLProgram *prog;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteProgram", pobj, &prog, &progname, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteProgram(progname);
42472:     prog->Delete();
42472:     mMapPrograms.Remove(progname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::DeleteShader(nsIWebGLShader *sobj)
32195: {
42916:     WebGLuint shadername;
42472:     WebGLShader *shader;
42472:     PRBool isNull, isDeleted;
47811:     if (!GetConcreteObjectAndGLName("deleteShader", sobj, &shader, &shadername, &isNull, &isDeleted))
47811:         return NS_OK;
42477: 
42477:     if (isNull || isDeleted)
32195:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
42472:     gl->fDeleteShader(shadername);
42472:     shader->Delete();
42472:     mMapShaders.Remove(shadername);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::DetachShader(nsIWebGLProgram *pobj, nsIWebGLShader *shobj)
32195: {
43098:     WebGLuint progname, shadername;
43098:     WebGLProgram *program;
43098:     WebGLShader *shader;
47811:     if (!GetConcreteObjectAndGLName("detachShader: program", pobj, &program, &progname) ||
47811:         !GetConcreteObjectAndGLName("detachShader: shader", shobj, &shader, &shadername))
47811:         return NS_OK;
32195: 
43098:     if (!program->DetachShader(shader))
43098:         return ErrorInvalidOperation("DetachShader: shader is not attached");
43098: 
32195:     MakeContextCurrent();
32195: 
43098:     gl->fDetachShader(progname, shadername);
32195: 
32195:     return NS_OK;
32195: }
32195: 
46442: NS_IMETHODIMP
46442: WebGLContext::DepthFunc(WebGLenum func)
46442: {
46443:     if (!ValidateComparisonEnum(func, "depthFunc"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fDepthFunc(func);
46442:     return NS_OK;
46442: }
42916: 
42916: GL_SAME_METHOD_1(DepthMask, DepthMask, WebGLboolean)
32195: 
47205: GL_SAME_METHOD_2(DepthRange, DepthRange, WebGLfloat, WebGLfloat)
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::DisableVertexAttribArray(WebGLuint index)
32195: {
32195:     if (index > mAttribBuffers.Length())
42477:         return ErrorInvalidValue("DisableVertexAttribArray: index out of range");
32195: 
32195:     MakeContextCurrent();
32195: 
51898:     if (index || gl->IsGLES2())
32195:         gl->fDisableVertexAttribArray(index);
51898: 
32195:     mAttribBuffers[index].enabled = PR_FALSE;
32195: 
32195:     return NS_OK;
32195: }
32195: 
51422: PRBool
51898: WebGLContext::NeedFakeVertexAttrib0()
51898: {
51898:     return !gl->IsGLES2() &&
51898:            !mAttribBuffers[0].enabled;
51898: }
51898: 
51898: void
51898: WebGLContext::DoFakeVertexAttrib0(WebGLuint vertexCount)
51898: {
51898:     if (!NeedFakeVertexAttrib0())
51898:         return;
51898: 
51898:     mFakeVertexAttrib0Array = new WebGLfloat[4 * vertexCount];
51898: 
51898:     for(size_t i = 0; i < vertexCount; ++i) {
51898:         mFakeVertexAttrib0Array[4 * i + 0] = mVertexAttrib0Vector[0];
51898:         mFakeVertexAttrib0Array[4 * i + 1] = mVertexAttrib0Vector[1];
51898:         mFakeVertexAttrib0Array[4 * i + 2] = mVertexAttrib0Vector[2];
51898:         mFakeVertexAttrib0Array[4 * i + 3] = mVertexAttrib0Vector[3];
51898:     }
51898: 
52048:     gl->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
51898:     gl->fVertexAttribPointer(0, 4, LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0, mFakeVertexAttrib0Array);
51898: }
51898: 
51898: void
51898: WebGLContext::UndoFakeVertexAttrib0()
51898: {
51898:     if (!NeedFakeVertexAttrib0())
51898:         return;
51898: 
51898:     mFakeVertexAttrib0Array = nsnull;
51898: 
52048:     // first set the bound buffer as needed for subsequent gl->fVertexAttribPointer call.
52048:     // since in DoFakeVertexAttrib0() we called bindBuffer on buffer zero, we only need to do that if
52048:     // we have a nonzero buffer binding for this attrib.
52048:     if (mAttribBuffers[0].buf)
52048:         gl->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, mAttribBuffers[0].buf->GLName());
52048: 
51898:     gl->fVertexAttribPointer(0,
51898:                              mAttribBuffers[0].size,
51898:                              mAttribBuffers[0].type,
51898:                              mAttribBuffers[0].normalized,
51898:                              mAttribBuffers[0].stride,
51898:                              (const GLvoid *) mAttribBuffers[0].byteOffset);
52048: 
52048:     // now restore the bound buffer to its state before we did this whole draw call business
52048:     gl->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, mBoundArrayBuffer ? mBoundArrayBuffer->GLName() : 0);
51898: }
51898: 
51898: PRBool
51422: WebGLContext::NeedFakeBlack()
51422: {
51422:     // handle this case first, it's the generic case
51422:     if (mFakeBlackStatus == DoNotNeedFakeBlack)
51422:         return PR_FALSE;
51422: 
51422:     if (mFakeBlackStatus == DontKnowIfNeedFakeBlack) {
51422:         for (PRInt32 i = 0; i < mGLMaxTextureImageUnits; ++i) {
51422:             if ((mBound2DTextures[i] && mBound2DTextures[i]->NeedFakeBlack()) ||
51422:                 (mBoundCubeMapTextures[i] && mBoundCubeMapTextures[i]->NeedFakeBlack()))
51422:             {
51422:                 mFakeBlackStatus = DoNeedFakeBlack;
51422:                 break;
51422:             }
51422:         }
51422: 
51422:         // we have exhausted all cases where we do need fakeblack, so if the status is still unknown,
51422:         // that means that we do NOT need it.
51422:         if (mFakeBlackStatus == DontKnowIfNeedFakeBlack)
51422:             mFakeBlackStatus = DoNotNeedFakeBlack;
51422:     }
51422: 
51422:     return mFakeBlackStatus == DoNeedFakeBlack;
51422: }
51422: 
51422: void
51422: WebGLContext::BindFakeBlackTextures()
51422: {
51422:     // this is the generic case: try to return early
51422:     if (!NeedFakeBlack())
51422:         return;
51422: 
51422:     if (!mBlackTexturesAreInitialized) {
51422:         const PRUint8 black[] = {0, 0, 0, 255};
51422: 
51422:         gl->fGenTextures(1, &mBlackTexture2D);
51422:         gl->fBindTexture(LOCAL_GL_TEXTURE_2D, mBlackTexture2D);
51422:         gl->fTexImage2D(LOCAL_GL_TEXTURE_2D, 0, LOCAL_GL_RGBA, 1, 1,
51422:                         0, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, &black);
51422: 
51422:         gl->fGenTextures(1, &mBlackTextureCubeMap);
51422:         gl->fBindTexture(LOCAL_GL_TEXTURE_CUBE_MAP, mBlackTextureCubeMap);
51422:         for (WebGLuint i = 0; i < 6; ++i) {
51422:             gl->fTexImage2D(LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, LOCAL_GL_RGBA, 1, 1,
51422:                             0, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, &black);
51422:         }
51422: 
51422:         // return the texture bindings to the 0 texture to prevent the user from modifying our black textures
51422:         gl->fBindTexture(LOCAL_GL_TEXTURE_2D, 0);
51422:         gl->fBindTexture(LOCAL_GL_TEXTURE_CUBE_MAP, 0);
51422: 
51422:         mBlackTexturesAreInitialized = PR_TRUE;
51422:     }
51422: 
51422:     for (PRInt32 i = 0; i < mGLMaxTextureImageUnits; ++i) {
51422:         if (mBound2DTextures[i] && mBound2DTextures[i]->NeedFakeBlack()) {
51422:             gl->fActiveTexture(LOCAL_GL_TEXTURE0 + i);
51422:             gl->fBindTexture(LOCAL_GL_TEXTURE_2D, mBlackTexture2D);
51422:         }
51422:         if (mBoundCubeMapTextures[i] && mBoundCubeMapTextures[i]->NeedFakeBlack()) {
51422:             gl->fActiveTexture(LOCAL_GL_TEXTURE0 + i);
51422:             gl->fBindTexture(LOCAL_GL_TEXTURE_CUBE_MAP, mBlackTextureCubeMap);
51422:         }
51422:     }
51422: }
51422: 
51422: void
51422: WebGLContext::UnbindFakeBlackTextures()
51422: {
51422:     // this is the generic case: try to return early
51422:     if (!NeedFakeBlack())
51422:         return;
51422: 
51422:     for (PRInt32 i = 0; i < mGLMaxTextureImageUnits; ++i) {
51422:         if (mBound2DTextures[i] && mBound2DTextures[i]->NeedFakeBlack()) {
51422:             gl->fActiveTexture(LOCAL_GL_TEXTURE0 + i);
51422:             gl->fBindTexture(LOCAL_GL_TEXTURE_2D, mBound2DTextures[i]->GLName());
51422:         }
51422:         if (mBoundCubeMapTextures[i] && mBoundCubeMapTextures[i]->NeedFakeBlack()) {
51422:             gl->fActiveTexture(LOCAL_GL_TEXTURE0 + i);
51422:             gl->fBindTexture(LOCAL_GL_TEXTURE_CUBE_MAP, mBoundCubeMapTextures[i]->GLName());
51422:         }
51422:     }
51422: 
51422:     gl->fActiveTexture(LOCAL_GL_TEXTURE0 + mActiveTexture);
51422: }
51422: 
32195: NS_IMETHODIMP
43009: WebGLContext::DrawArrays(GLenum mode, WebGLint first, WebGLsizei count)
32195: {
47813:     if (!ValidateDrawModeEnum(mode, "drawArrays: mode"))
47813:         return NS_OK;
32195: 
43333:     if (first < 0 || count < 0)
43333:         return ErrorInvalidValue("DrawArrays: negative first or count");
43333: 
43098:     // If there is no current program, this is silently ignored.
43098:     // Any checks below this depend on a program being available.
43098:     if (!mCurrentProgram)
43098:         return NS_OK;
43098: 
47204:     CheckedInt32 checked_firstPlusCount = CheckedInt32(first) + count;
47204: 
47204:     if (!checked_firstPlusCount.valid())
47204:         return ErrorInvalidOperation("drawArrays: overflow in first+count");
47204: 
47204:     if (!ValidateBuffers(checked_firstPlusCount.value()))
47809:         return ErrorInvalidOperation("DrawArrays: bound vertex attribute buffers do not have sufficient size for given first and count");
47809: 
47809:     // If count is 0, there's nothing to do.
47809:     if (count == 0)
47809:         return NS_OK;
32195: 
32195:     MakeContextCurrent();
32195: 
56959:     if (mBoundFramebuffer && !mBoundFramebuffer->CheckAndInitializeRenderbuffers())
56959:         return NS_OK;
56959: 
51422:     BindFakeBlackTextures();
51898:     DoFakeVertexAttrib0(checked_firstPlusCount.value());
51898: 
43009:     gl->fDrawArrays(mode, first, count);
51898: 
51898:     UndoFakeVertexAttrib0();
51422:     UnbindFakeBlackTextures();
32195: 
32195:     Invalidate();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43333: WebGLContext::DrawElements(WebGLenum mode, WebGLsizei count, WebGLenum type, WebGLint byteOffset)
32195: {
47813:     if (!ValidateDrawModeEnum(mode, "drawElements: mode"))
47813:         return NS_OK;
32195: 
43333:     if (count < 0 || byteOffset < 0)
43333:         return ErrorInvalidValue("DrawElements: negative count or offset");
43333: 
47204:     CheckedUint32 checked_byteCount;
47204: 
43333:     if (type == LOCAL_GL_UNSIGNED_SHORT) {
47204:         checked_byteCount = 2 * CheckedUint32(count);
43009:         if (byteOffset % 2 != 0)
43009:             return ErrorInvalidValue("DrawElements: invalid byteOffset for UNSIGNED_SHORT (must be a multiple of 2)");
43333:     } else if (type == LOCAL_GL_UNSIGNED_BYTE) {
47204:         checked_byteCount = count;
43333:     } else {
42477:         return ErrorInvalidEnum("DrawElements: type must be UNSIGNED_SHORT or UNSIGNED_BYTE");
32195:     }
32195: 
47204:     if (!checked_byteCount.valid())
47204:         return ErrorInvalidValue("DrawElements: overflow in byteCount");
47204: 
43098:     // If there is no current program, this is silently ignored.
43098:     // Any checks below this depend on a program being available.
43098:     if (!mCurrentProgram)
43098:         return NS_OK;
43098: 
43333:     if (!mBoundElementArrayBuffer)
43333:         return ErrorInvalidOperation("DrawElements: must have element array buffer binding");
43333: 
57469:     if (!mBoundElementArrayBuffer->Data())
57469:         return ErrorInvalidOperation("drawElements: bound element array buffer doesn't have any data");
57469: 
47204:     CheckedUint32 checked_neededByteCount = checked_byteCount + byteOffset;
47204: 
47204:     if (!checked_neededByteCount.valid())
43333:         return ErrorInvalidOperation("DrawElements: overflow in byteOffset+byteCount");
43333: 
47204:     if (checked_neededByteCount.value() > mBoundElementArrayBuffer->ByteLength())
43333:         return ErrorInvalidOperation("DrawElements: bound element array buffer is too small for given count and offset");
43333: 
43009:     WebGLuint maxIndex = 0;
43333:     if (type == LOCAL_GL_UNSIGNED_SHORT) {
43009:         maxIndex = mBoundElementArrayBuffer->FindMaximum<GLushort>(count, byteOffset);
43333:     } else if (type == LOCAL_GL_UNSIGNED_BYTE) {
43009:         maxIndex = mBoundElementArrayBuffer->FindMaximum<GLubyte>(count, byteOffset);
43333:     }
43009: 
47204:     // maxIndex+1 because ValidateBuffers expects the number of elements needed.
47204:     // it is very important here to check tha maxIndex+1 doesn't overflow, otherwise the buffer validation is bypassed !!!
47204:     // maxIndex is a WebGLuint, ValidateBuffers takes a PRUint32, we validate maxIndex+1 as a PRUint32.
47204:     CheckedUint32 checked_neededCount = CheckedUint32(maxIndex) + 1;
47204:     if (!checked_neededCount.valid())
47204:         return ErrorInvalidOperation("drawElements: overflow in maxIndex+1");
47204:     if (!ValidateBuffers(checked_neededCount.value())) {
43009:         return ErrorInvalidOperation("DrawElements: bound vertex attribute buffers do not have sufficient "
47809:                                      "size for given indices from the bound element array");
43009:     }
43009: 
47809:     // If count is 0, there's nothing to do.
47809:     if (count == 0)
47809:         return NS_OK;
47809: 
32195:     MakeContextCurrent();
32195: 
56959:     if (mBoundFramebuffer && !mBoundFramebuffer->CheckAndInitializeRenderbuffers())
56959:         return NS_OK;
56959: 
51422:     BindFakeBlackTextures();
51898:     DoFakeVertexAttrib0(checked_neededCount.value());
51898: 
43009:     gl->fDrawElements(mode, count, type, (GLvoid*) (byteOffset));
51898: 
51898:     UndoFakeVertexAttrib0();
51422:     UnbindFakeBlackTextures();
32195: 
32195:     Invalidate();
32195: 
32195:     return NS_OK;
32195: }
32195: 
43317: NS_IMETHODIMP WebGLContext::Enable(WebGLenum cap)
43317: {
46443:     if (!ValidateCapabilityEnum(cap, "enable"))
46443:         return NS_OK;
43317: 
43317:     MakeContextCurrent();
43317:     gl->fEnable(cap);
43317:     return NS_OK;
43317: }
43317: 
43317: NS_IMETHODIMP WebGLContext::Disable(WebGLenum cap)
43317: {
46443:     if (!ValidateCapabilityEnum(cap, "disable"))
46443:         return NS_OK;
43317: 
43317:     MakeContextCurrent();
43317:     gl->fDisable(cap);
43317:     return NS_OK;
43317: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::EnableVertexAttribArray(WebGLuint index)
32195: {
32195:     if (index > mAttribBuffers.Length())
42477:         return ErrorInvalidValue("EnableVertexAttribArray: index out of range");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fEnableVertexAttribArray(index);
32195:     mAttribBuffers[index].enabled = PR_TRUE;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::FramebufferRenderbuffer(WebGLenum target, WebGLenum attachment, WebGLenum rbtarget, nsIWebGLRenderbuffer *rbobj)
32195: {
56959:     if (mBoundFramebuffer)
56959:         return mBoundFramebuffer->FramebufferRenderbuffer(target, attachment, rbtarget, rbobj);
56959:     else
56959:         return ErrorInvalidOperation("framebufferRenderbuffer: cannot modify framebuffer 0");
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::FramebufferTexture2D(WebGLenum target,
42916:                                    WebGLenum attachment,
42916:                                    WebGLenum textarget,
42472:                                    nsIWebGLTexture *tobj,
42916:                                    WebGLint level)
32195: {
56959:     if (mBoundFramebuffer)
56959:         return mBoundFramebuffer->FramebufferTexture2D(target, attachment, textarget, tobj, level);
56959:     else
56959:         return ErrorInvalidOperation("framebufferTexture2D: cannot modify framebuffer 0");
32195: }
32195: 
32195: GL_SAME_METHOD_0(Flush, Flush)
32195: 
32195: GL_SAME_METHOD_0(Finish, Finish)
32195: 
46442: NS_IMETHODIMP
46442: WebGLContext::FrontFace(WebGLenum mode)
46442: {
46442:     switch (mode) {
46442:         case LOCAL_GL_CW:
46442:         case LOCAL_GL_CCW:
46442:             break;
46442:         default:
47813:             return ErrorInvalidEnumInfo("frontFace: mode", mode);
46442:     }
46442: 
46442:     MakeContextCurrent();
46442:     gl->fFrontFace(mode);
46442:     return NS_OK;
46442: }
32195: 
32195: // returns an object: { size: ..., type: ..., name: ... }
32195: NS_IMETHODIMP
42471: WebGLContext::GetActiveAttrib(nsIWebGLProgram *pobj, PRUint32 index, nsIWebGLActiveInfo **retval)
32195: {
51424:     *retval = nsnull;
51424: 
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getActiveAttrib: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
32195: 
32195:     GLint len = 0;
42472:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &len);
51424:     if (len == 0)
43333:         return NS_OK;
32195: 
43474:     nsAutoArrayPtr<char> name(new char[len]);
32195:     PRInt32 attrsize = 0;
32195:     PRUint32 attrtype = 0;
32195: 
43474:     gl->fGetActiveAttrib(progname, index, len, &len, (GLint*) &attrsize, (WebGLuint*) &attrtype, name);
43333:     if (attrsize == 0 || attrtype == 0) {
43333:         *retval = nsnull;
43333:         return NS_OK;
43333:     }
32195: 
51421:     WebGLActiveInfo *retActiveInfo = new WebGLActiveInfo(attrsize, attrtype, name.get(), len);
51421:     NS_ADDREF(*retval = retActiveInfo);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
46442: WebGLContext::GenerateMipmap(WebGLenum target)
46442: {
46443:     if (!ValidateTextureTargetEnum(target, "generateMipmap"))
46443:         return NS_OK;
46442: 
51418:     WebGLTexture *tex = activeBoundTextureForTarget(target);
51418: 
51422:     if (!tex)
51422:         return ErrorInvalidOperation("generateMipmap: no texture is bound to this target");
51422: 
51895:     if (!tex->IsFirstImagePowerOfTwo()) {
51895:         return ErrorInvalidOperation("generateMipmap: the width or height of this texture is not a power of two");
51895:     }
51895: 
51895:     if (!tex->AreAllLevel0ImageInfosEqual()) {
51895:         return ErrorInvalidOperation("generateMipmap: the six faces of this cube map have different dimensions, format, or type.");
51418:     }
51418: 
51422:     tex->SetGeneratedMipmap();
51422: 
46442:     MakeContextCurrent();
46442:     gl->fGenerateMipmap(target);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
42471: WebGLContext::GetActiveUniform(nsIWebGLProgram *pobj, PRUint32 index, nsIWebGLActiveInfo **retval)
32195: {
51424:     *retval = nsnull;
51424: 
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getActiveUniform: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
32195: 
32195:     GLint len = 0;
42472:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &len);
51424:     if (len == 0)
43474:         *retval = nsnull;
43474: 
47814:     nsAutoArrayPtr<char> name(new char[len + 3]); // +3 because we might have to append "[0]", see below
47814: 
32195:     PRInt32 attrsize = 0;
32195:     PRUint32 attrtype = 0;
32195: 
43474:     gl->fGetActiveUniform(progname, index, len, &len, (GLint*) &attrsize, (WebGLenum*) &attrtype, name);
43474:     if (len == 0 || attrsize == 0 || attrtype == 0) {
43474:         *retval = nsnull;
43474:         return NS_OK;
43474:     }
32195: 
47814:     // OpenGL ES 2.0 specifies that if foo is a uniform array, GetActiveUniform returns its name as "foo[0]".
47814:     // See section 2.10 page 35 in the OpenGL ES 2.0.24 specification:
47814:     //
47814:     // > If the active uniform is an array, the uniform name returned in name will always
47814:     // > be the name of the uniform array appended with "[0]".
47814:     //
47814:     // There is no such requirement in the OpenGL (non-ES) spec and indeed we have OpenGL implementations returning
47814:     // "foo" instead of "foo[0]". So, when implementing WebGL on top of desktop OpenGL, we must check if the
47814:     // returned name ends in [0], and if it doesn't, append that.
47814:     //
47814:     // In principle we don't need to do that on OpenGL ES, but this is such a tricky difference between the ES and non-ES
47814:     // specs that it seems probable that some ES implementers will overlook it. Since the work-around is quite cheap,
47814:     // we do it unconditionally.
47814:     if (attrsize > 1 && name[len-1] != ']') {
47814:         name[len++] = '[';
47814:         name[len++] = '0';
47814:         name[len++] = ']';
47814:     }
47814: 
51421:     WebGLActiveInfo *retActiveInfo = new WebGLActiveInfo(attrsize, attrtype, name.get(), len);
51421: 
51421:     NS_ADDREF(*retval = retActiveInfo);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43637: WebGLContext::GetAttachedShaders(nsIWebGLProgram *pobj, nsIVariant **retval)
32195: {
51424:     *retval = nsnull;
51424: 
43637:     WebGLProgram *prog;
53696:     PRBool isNull;
53696:     if (!GetConcreteObject("getAttachedShaders", pobj, &prog, &isNull)) 
47811:         return NS_OK;
43637: 
43637:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43637:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
32195:     MakeContextCurrent();
32195: 
53696:     if (isNull) {
53696:         wrval->SetAsVoid();
53696:         // note no return, we still want to return the variant
53696:         ErrorInvalidValue("getAttachedShaders: invalid program");
53696:     } else if (prog->AttachedShaders().Length() == 0) {
43637:         wrval->SetAsEmptyArray();
53696:     } else {
43637:         wrval->SetAsArray(nsIDataType::VTYPE_INTERFACE,
43637:                         &NS_GET_IID(nsIWebGLShader),
43637:                         prog->AttachedShaders().Length(),
43637:                         const_cast<void*>( // @#$% SetAsArray doesn't accept a const void*
43637:                             static_cast<const void*>(
43637:                                 prog->AttachedShaders().Elements()
43637:                             )
43637:                         )
43637:                         );
43637:     }
43637: 
43637:     *retval = wrval.forget().get();
43637: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::GetAttribLocation(nsIWebGLProgram *pobj,
32195:                                 const nsAString& name,
32195:                                 PRInt32 *retval)
32195: {
51424:     *retval = 0;
51424: 
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getAttribLocation: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
42472:     *retval = gl->fGetAttribLocation(progname, NS_LossyConvertUTF16toASCII(name).get());
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43533: WebGLContext::GetParameter(PRUint32 pname, nsIVariant **retval)
32195: {
51424:     *retval = nsnull;
51424: 
43533:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43533:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         //
32195:         // String params
32195:         //
32195: 
32195:         case LOCAL_GL_VENDOR:
43534:             wrval->SetAsDOMString(NS_LITERAL_STRING("Mozilla"));
43534:             break;
32195:         case LOCAL_GL_RENDERER:
43534:             wrval->SetAsDOMString(NS_LITERAL_STRING("Mozilla"));
43534:             break;
32195:         case LOCAL_GL_VERSION:
43534:             wrval->SetAsDOMString(NS_LITERAL_STRING("WebGL 1.0"));
43534:             break;
32195:         case LOCAL_GL_SHADING_LANGUAGE_VERSION:
43534:             wrval->SetAsDOMString(NS_LITERAL_STRING("WebGL GLSL ES 1.0"));
32195:             break;
32195: 
32195:         //
32195:         // Single-value params
32195:         //
32195: 
32195: // int
32195:         case LOCAL_GL_CULL_FACE_MODE:
32195:         case LOCAL_GL_FRONT_FACE:
32195:         case LOCAL_GL_ACTIVE_TEXTURE:
32195:         case LOCAL_GL_DEPTH_CLEAR_VALUE:
32195:         case LOCAL_GL_STENCIL_CLEAR_VALUE:
32195:         case LOCAL_GL_STENCIL_FUNC:
32195:         case LOCAL_GL_STENCIL_REF:
32195:         case LOCAL_GL_STENCIL_FAIL:
32195:         case LOCAL_GL_STENCIL_PASS_DEPTH_FAIL:
32195:         case LOCAL_GL_STENCIL_PASS_DEPTH_PASS:
32195:         case LOCAL_GL_STENCIL_BACK_FUNC:
32195:         case LOCAL_GL_STENCIL_BACK_REF:
32195:         case LOCAL_GL_STENCIL_BACK_FAIL:
32195:         case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_FAIL:
32195:         case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_PASS:
32195:         case LOCAL_GL_DEPTH_FUNC:
32195:         case LOCAL_GL_BLEND_SRC_RGB:
32195:         case LOCAL_GL_BLEND_SRC_ALPHA:
32195:         case LOCAL_GL_BLEND_DST_RGB:
32195:         case LOCAL_GL_BLEND_DST_ALPHA:
32195:         case LOCAL_GL_BLEND_EQUATION_RGB:
32195:         case LOCAL_GL_BLEND_EQUATION_ALPHA:
46442:         case LOCAL_GL_UNPACK_ALIGNMENT:
46442:         case LOCAL_GL_PACK_ALIGNMENT:
32195:         case LOCAL_GL_GENERATE_MIPMAP_HINT:
32195:         case LOCAL_GL_SUBPIXEL_BITS:
32195:         case LOCAL_GL_MAX_TEXTURE_SIZE:
32195:         case LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE:
32195:         case LOCAL_GL_SAMPLE_BUFFERS:
32195:         case LOCAL_GL_SAMPLES:
32195:         case LOCAL_GL_MAX_VERTEX_ATTRIBS:
32195:         case LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
32195:         case LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
32195:         case LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS:
32195:         case LOCAL_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:
32195:         case LOCAL_GL_MAX_RENDERBUFFER_SIZE:
32195:         case LOCAL_GL_RED_BITS:
32195:         case LOCAL_GL_GREEN_BITS:
32195:         case LOCAL_GL_BLUE_BITS:
32195:         case LOCAL_GL_ALPHA_BITS:
32195:         case LOCAL_GL_DEPTH_BITS:
32195:         case LOCAL_GL_STENCIL_BITS:
46442:         case LOCAL_GL_IMPLEMENTATION_COLOR_READ_TYPE:
46442:         case LOCAL_GL_IMPLEMENTATION_COLOR_READ_FORMAT:
32195:         {
43305:             GLint i = 0;
43305:             gl->fGetIntegerv(pname, &i);
43533:             wrval->SetAsInt32(i);
43305:         }
43305:             break;
43305: 
46442:         case LOCAL_GL_MAX_VARYING_VECTORS:
46442:         {
48309:             if (gl->IsGLES2()) {
46442:                 GLint i = 0;
46442:                 gl->fGetIntegerv(pname, &i);
46442:                 wrval->SetAsInt32(i);
48309:             } else {
46442:                 // since this pname is absent from desktop OpenGL, we have to implement it by hand.
46442:                 // The formula below comes from the public_webgl list, "problematic GetParameter pnames" thread
46442:                 GLint i = 0, j = 0;
46442:                 gl->fGetIntegerv(LOCAL_GL_MAX_VERTEX_OUTPUT_COMPONENTS, &i);
46442:                 gl->fGetIntegerv(LOCAL_GL_MAX_FRAGMENT_INPUT_COMPONENTS, &j);
46442:                 wrval->SetAsInt32(PR_MIN(i,j)/4);
48309:             }
46442:         }
46442:             break;
46442: 
43533:         case LOCAL_GL_NUM_COMPRESSED_TEXTURE_FORMATS:
43533:             wrval->SetAsInt32(0);
43533:             break;
46442:         case LOCAL_GL_COMPRESSED_TEXTURE_FORMATS:
46442:             wrval->SetAsVoid(); // the spec says we must return null
46442:             break;
43533: 
43305: // unsigned int. here we may have to return very large values like 2^32-1 that can't be represented as
43533: // javascript integer values. We just return them as doubles and javascript doesn't care.
43305:         case LOCAL_GL_STENCIL_BACK_VALUE_MASK:
43305:         case LOCAL_GL_STENCIL_BACK_WRITEMASK:
43305:         case LOCAL_GL_STENCIL_VALUE_MASK:
43305:         case LOCAL_GL_STENCIL_WRITEMASK:
43305:         {
43305:             GLint i = 0; // the GL api (glGetIntegerv) only does signed ints
43305:             gl->fGetIntegerv(pname, &i);
43305:             GLuint i_unsigned(i); // this is where -1 becomes 2^32-1
43533:             double i_double(i_unsigned); // pass as FP value to allow large values such as 2^32-1.
43533:             wrval->SetAsDouble(i_double);
32195:         }
32195:             break;
32195: 
32195: // float
32195:         case LOCAL_GL_LINE_WIDTH:
32195:         case LOCAL_GL_POLYGON_OFFSET_FACTOR:
32195:         case LOCAL_GL_POLYGON_OFFSET_UNITS:
32195:         case LOCAL_GL_SAMPLE_COVERAGE_VALUE:
32195:         {
43533:             GLfloat f = 0.f;
43533:             gl->fGetFloatv(pname, &f);
43533:             wrval->SetAsFloat(f);
32195:         }
32195:             break;
43305: 
32195: // bool
43305:         case LOCAL_GL_BLEND:
43305:         case LOCAL_GL_DEPTH_TEST:
43305:         case LOCAL_GL_STENCIL_TEST:
43305:         case LOCAL_GL_CULL_FACE:
43305:         case LOCAL_GL_DITHER:
43305:         case LOCAL_GL_POLYGON_OFFSET_FILL:
43305:         case LOCAL_GL_SCISSOR_TEST:
32195:         case LOCAL_GL_SAMPLE_COVERAGE_INVERT:
32195:         case LOCAL_GL_DEPTH_WRITEMASK:
32195:         {
43533:             realGLboolean b = 0;
43533:             gl->fGetBooleanv(pname, &b);
43533:             wrval->SetAsBool(PRBool(b));
32195:         }
32195:             break;
32195: 
46442: // bool, WebGL-specific
46442:         case UNPACK_FLIP_Y_WEBGL:
46442:             wrval->SetAsBool(mPixelStoreFlipY);
46442:             break;
46442:         case UNPACK_PREMULTIPLY_ALPHA_WEBGL:
46442:             wrval->SetAsBool(mPixelStorePremultiplyAlpha);
46442:             break;
46442: 
32195:         //
32195:         // Complex values
32195:         //
32195:         case LOCAL_GL_DEPTH_RANGE: // 2 floats
32195:         case LOCAL_GL_ALIASED_POINT_SIZE_RANGE: // 2 floats
32195:         case LOCAL_GL_ALIASED_LINE_WIDTH_RANGE: // 2 floats
32195:         {
43533:             GLfloat fv[2] = { 0 };
43533:             gl->fGetFloatv(pname, fv);
43533:             wrval->SetAsArray(nsIDataType::VTYPE_FLOAT, nsnull,
43533:                               2, static_cast<void*>(fv));
32195:         }
32195:             break;
32195:         
32195:         case LOCAL_GL_COLOR_CLEAR_VALUE: // 4 floats
32195:         case LOCAL_GL_BLEND_COLOR: // 4 floats
32195:         {
43533:             GLfloat fv[4] = { 0 };
43533:             gl->fGetFloatv(pname, fv);
43533:             wrval->SetAsArray(nsIDataType::VTYPE_FLOAT, nsnull,
43533:                               4, static_cast<void*>(fv));
32195:         }
32195:             break;
32195: 
32195:         case LOCAL_GL_MAX_VIEWPORT_DIMS: // 2 ints
32195:         {
43533:             GLint iv[2] = { 0 };
43533:             gl->fGetIntegerv(pname, iv);
43533:             wrval->SetAsArray(nsIDataType::VTYPE_INT32, nsnull,
43533:                               2, static_cast<void*>(iv));
32195:         }
32195:             break;
32195: 
32195:         case LOCAL_GL_SCISSOR_BOX: // 4 ints
32195:         case LOCAL_GL_VIEWPORT: // 4 ints
32195:         {
56811:             GLint iv[4] = { 0 };
43533:             gl->fGetIntegerv(pname, iv);
43533:             wrval->SetAsArray(nsIDataType::VTYPE_INT32, nsnull,
43533:                               4, static_cast<void*>(iv));
32195:         }
32195:             break;
32195: 
43305:         case LOCAL_GL_COLOR_WRITEMASK: // 4 bools
43305:         {
43533:             realGLboolean gl_bv[4] = { 0 };
43533:             gl->fGetBooleanv(pname, gl_bv);
43533:             PRBool pr_bv[4] = { gl_bv[0], gl_bv[1], gl_bv[2], gl_bv[3] };
43533:             wrval->SetAsArray(nsIDataType::VTYPE_BOOL, nsnull,
43533:                               4, static_cast<void*>(pr_bv));
43305:         }
43305:             break;
43305: 
43533:         case LOCAL_GL_ARRAY_BUFFER_BINDING:
43533:             wrval->SetAsISupports(mBoundArrayBuffer);
43305:             break;
43305: 
43533:         case LOCAL_GL_ELEMENT_ARRAY_BUFFER_BINDING:
43533:             wrval->SetAsISupports(mBoundElementArrayBuffer);
43533:             break;
43533: 
43533:         case LOCAL_GL_RENDERBUFFER_BINDING:
43533:             wrval->SetAsISupports(mBoundRenderbuffer);
43533:             break;
43533: 
43533:         case LOCAL_GL_FRAMEBUFFER_BINDING:
43533:             wrval->SetAsISupports(mBoundFramebuffer);
43533:             break;
43533: 
43533:         case LOCAL_GL_CURRENT_PROGRAM:
43533:             wrval->SetAsISupports(mCurrentProgram);
43533:             break;
43533: 
43533:         case LOCAL_GL_TEXTURE_BINDING_2D:
43533:             wrval->SetAsISupports(mBound2DTextures[mActiveTexture]);
43533:             break;
43533: 
43533:         case LOCAL_GL_TEXTURE_BINDING_CUBE_MAP:
43533:             wrval->SetAsISupports(mBoundCubeMapTextures[mActiveTexture]);
43533:             break;
43305: 
32195:         default:
47813:             return ErrorInvalidEnumInfo("getParameter: parameter", pname);
32195:     }
32195: 
43533:     *retval = wrval.forget().get();
43533: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetBufferParameter(WebGLenum target, WebGLenum pname, nsIVariant **retval)
32195: {
51424:     *retval = nsnull;
51424: 
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
42477:     if (target != LOCAL_GL_ARRAY_BUFFER && target != LOCAL_GL_ELEMENT_ARRAY_BUFFER)
47813:         return ErrorInvalidEnumInfo("getBufferParameter: target", target);
42477: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         case LOCAL_GL_BUFFER_SIZE:
32195:         case LOCAL_GL_BUFFER_USAGE:
32195:         case LOCAL_GL_BUFFER_ACCESS:
32195:         case LOCAL_GL_BUFFER_MAPPED:
32195:         {
43851:             GLint i = 0;
43851:             gl->fGetBufferParameteriv(target, pname, &i);
43851:             wrval->SetAsInt32(i);
32195:         }
32195:             break;
32195: 
32195:         default:
47813:             return ErrorInvalidEnumInfo("getBufferParameter: parameter", pname);
32195:     }
32195: 
43851:     *retval = wrval.forget().get();
43851: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetFramebufferAttachmentParameter(WebGLenum target, WebGLenum attachment, WebGLenum pname, nsIVariant **retval)
32195: {
51424:     *retval = nsnull;
51424: 
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
42477:     if (target != LOCAL_GL_FRAMEBUFFER)
47813:         return ErrorInvalidEnumInfo("getFramebufferAttachmentParameter: target", target);
32195: 
32195:     switch (attachment) {
32195:         case LOCAL_GL_COLOR_ATTACHMENT0:
32195:         case LOCAL_GL_DEPTH_ATTACHMENT:
32195:         case LOCAL_GL_STENCIL_ATTACHMENT:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("GetFramebufferAttachmentParameter: attachment", attachment);
32195:     }
32195: 
47910:     if (!mBoundFramebuffer)
47910:         return ErrorInvalidOperation("GetFramebufferAttachmentParameter: cannot query framebuffer 0");
47910: 
42477:     MakeContextCurrent();
42477: 
47910:     GLint atype = 0;
47910:     gl->fGetFramebufferAttachmentParameteriv(target, attachment, LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &atype);
47910: 
47910:     if (atype == LOCAL_GL_RENDERBUFFER) {
32195:         switch (pname) {
32195:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
47910:                 wrval->SetAsInt32(atype);
47910:                 break;
47910: 
47910:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: {
47910:                 GLint i = 0;
47910:                 gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, &i);
47910:                 WebGLRenderbuffer *rb = mMapRenderbuffers.GetWeak(PRUint32(i));
47910:                 NS_ASSERTION(rb, "Expected to find renderbuffer in table, but it's not there?");
47910:                 wrval->SetAsISupports(rb);
47910:             }
47910:                 break;
47910: 
47910:             default:
51899:                 return ErrorInvalidEnumInfo("GetFramebufferAttachmentParameter: pname", pname);
47910:         }
47910:     } else if (atype == LOCAL_GL_TEXTURE) {
47910:         switch (pname) {
47910:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
47910:                 wrval->SetAsInt32(atype);
47910:                 break;
47910: 
47910:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: {
47910:                 GLint i = 0;
47910:                 gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, &i);
47910:                 WebGLTexture *tex = mMapTextures.GetWeak(PRUint32(i));
47910:                 NS_ASSERTION(tex, "Expected to find texture in table, but it's not there?");
47910:                 wrval->SetAsISupports(tex);
47910:             }
47910:                 break;
47910: 
32195:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
47910:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: {
43851:                 GLint i = 0;
43851:                 gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, &i);
43851:                 wrval->SetAsInt32(i);
32195:             }
32195:                 break;
32195: 
32195:             default:
51899:                 return ErrorInvalidEnumInfo("GetFramebufferAttachmentParameter: pname", pname);
51899:         }
51899:     } else if (atype == LOCAL_GL_NONE) {
51899:         switch (pname) {
51899:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
51899:                 wrval->SetAsInt32(atype);
51899:                 break;
51899: 
53696:             case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
53696:                 wrval->SetAsEmpty();
53696:                 break;
53696: 
51899:             default:
51899:                 return ErrorInvalidEnumInfo("GetFramebufferAttachmentParameter: pname", pname);
51899:         }
51899:     } else { // GL bug? should never happen
47910:         return NS_ERROR_FAILURE;
32195:     }
32195: 
43851:     *retval = wrval.forget().get();
43851: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetRenderbufferParameter(WebGLenum target, WebGLenum pname, nsIVariant **retval)
32195: {
51424:     *retval = nsnull;
51424: 
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
42477:     if (target != LOCAL_GL_RENDERBUFFER)
47813:         return ErrorInvalidEnumInfo("GetRenderbufferParameter: target", target);
42477: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         case LOCAL_GL_RENDERBUFFER_WIDTH:
32195:         case LOCAL_GL_RENDERBUFFER_HEIGHT:
32195:         case LOCAL_GL_RENDERBUFFER_INTERNAL_FORMAT:
32195:         case LOCAL_GL_RENDERBUFFER_RED_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_GREEN_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_BLUE_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_ALPHA_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_DEPTH_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_STENCIL_SIZE:
32195:         {
43851:             GLint i = 0;
43851:             gl->fGetRenderbufferParameteriv(target, pname, &i);
43851:             wrval->SetAsInt32(i);
32195:         }
32195:             break;
32195: 
32195:         default:
47813:             return ErrorInvalidEnumInfo("GetRenderbufferParameter: parameter", pname);
32195:     }
32195: 
43851:     *retval = wrval.forget().get();
43851: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateBuffer(nsIWebGLBuffer **retval)
32195: {
51424:     *retval = nsnull;
51424: 
32195:     MakeContextCurrent();
32195: 
42916:     WebGLuint name;
32195:     gl->fGenBuffers(1, &name);
32195: 
43099:     WebGLBuffer *globj = new WebGLBuffer(this, name);
32195:     NS_ADDREF(*retval = globj);
32195:     mMapBuffers.Put(name, globj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateTexture(nsIWebGLTexture **retval)
32195: {
51424:     *retval = nsnull;
51424: 
32195:     MakeContextCurrent();
32195: 
42916:     WebGLuint name;
32195:     gl->fGenTextures(1, &name);
32195: 
43099:     WebGLTexture *globj = new WebGLTexture(this, name);
32195:     NS_ADDREF(*retval = globj);
32195:     mMapTextures.Put(name, globj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::GetError(WebGLenum *_retval)
32195: {
32195:     MakeContextCurrent();
42477: 
42477:     // Always call glGetError to clear any pending
42477:     // real GL error.
42916:     WebGLenum err = gl->fGetError();
42477: 
42477:     // mSynthesizedGLError has the first error that occurred,
42477:     // whether synthesized or real; if it's not NO_ERROR, use it.
42477:     if (mSynthesizedGLError != LOCAL_GL_NO_ERROR) {
42477:         err = mSynthesizedGLError;
42477:         mSynthesizedGLError = LOCAL_GL_NO_ERROR;
42477:     }
42477: 
42477:     *_retval = err;
42477: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetProgramParameter(nsIWebGLProgram *pobj, PRUint32 pname, nsIVariant **retval)
35013: {
51424:     *retval = nsnull;
51424: 
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getProgramParameter: program", pobj, &progname))
47811:         return NS_OK;
42471: 
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
35013: 
35013:     MakeContextCurrent();
35013: 
35013:     switch (pname) {
35013:         case LOCAL_GL_CURRENT_PROGRAM:
35013:         case LOCAL_GL_ATTACHED_SHADERS:
35013:         case LOCAL_GL_INFO_LOG_LENGTH:
35013:         case LOCAL_GL_ACTIVE_UNIFORMS:
35013:         case LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH:
35013:         case LOCAL_GL_ACTIVE_ATTRIBUTES:
35013:         case LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
35013:         {
43851:             GLint i = 0;
43851:             gl->fGetProgramiv(progname, pname, &i);
43851:             wrval->SetAsInt32(i);
35013:         }
35013:             break;
43011:         case LOCAL_GL_DELETE_STATUS:
43011:         case LOCAL_GL_LINK_STATUS:
43011:         case LOCAL_GL_VALIDATE_STATUS:
43011:         {
43851:             GLint i = 0;
43851:             gl->fGetProgramiv(progname, pname, &i);
43851:             wrval->SetAsBool(PRBool(i));
43011:         }
43011:             break;
35013: 
35013:         default:
47813:             return ErrorInvalidEnumInfo("GetProgramParameter: parameter", pname);
35013:     }
35013: 
43851:     *retval = wrval.forget().get();
43851: 
35013:     return NS_OK;
35013: }
35013: 
35013: NS_IMETHODIMP
42471: WebGLContext::GetProgramInfoLog(nsIWebGLProgram *pobj, nsAString& retval)
32195: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("getProgramInfoLog: program", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
32195: 
32195:     PRInt32 k = -1;
42472:     gl->fGetProgramiv(progname, LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &k);
32195:     if (k == -1)
42477:         return NS_ERROR_FAILURE; // XXX GL error? shouldn't happen!
32195: 
32195:     if (k == 0) {
32195:         retval.Truncate();
32195:         return NS_OK;
32195:     }
32195: 
32195:     nsCAutoString log;
32195:     log.SetCapacity(k);
32195: 
42472:     gl->fGetProgramInfoLog(progname, k, (GLint*) &k, (char*) log.BeginWriting());
32195: 
32195:     log.SetLength(k);
32195: 
32195:     CopyASCIItoUTF16(log, retval);
32195: 
32195:     return NS_OK;
32195: }
32195: 
51420: // here we have to support all pnames with both int and float params.
51420: // See this discussion:
51420: //  https://www.khronos.org/webgl/public-mailing-list/archives/1008/msg00014.html
51420: nsresult WebGLContext::TexParameter_base(WebGLenum target, WebGLenum pname,
51420:                                          WebGLint *intParamPtr, WebGLfloat *floatParamPtr)
51420: {
51420:     NS_ENSURE_TRUE(intParamPtr || floatParamPtr, NS_ERROR_FAILURE);
51420: 
51420:     WebGLint intParam = intParamPtr ? *intParamPtr : WebGLint(*floatParamPtr);
55267:     WebGLfloat floatParam = floatParamPtr ? *floatParamPtr : WebGLfloat(*intParamPtr);
51420: 
51420:     if (!ValidateTextureTargetEnum(target, "texParameter: target"))
51420:         return NS_OK;
51420: 
51422:     WebGLTexture *tex = activeBoundTextureForTarget(target);
51422:     if (!tex)
51422:         return ErrorInvalidOperation("texParameter: no texture is bound to this target");
51422: 
51420:     PRBool pnameAndParamAreIncompatible = PR_FALSE;
51420: 
51420:     switch (pname) {
51420:         case LOCAL_GL_TEXTURE_MIN_FILTER:
51420:             switch (intParam) {
51420:                 case LOCAL_GL_NEAREST:
51420:                 case LOCAL_GL_LINEAR:
51420:                 case LOCAL_GL_NEAREST_MIPMAP_NEAREST:
51420:                 case LOCAL_GL_LINEAR_MIPMAP_NEAREST:
51420:                 case LOCAL_GL_NEAREST_MIPMAP_LINEAR:
51420:                 case LOCAL_GL_LINEAR_MIPMAP_LINEAR:
51422:                     tex->SetMinFilter(intParam);
51420:                     break;
51420:                 default:
51420:                     pnameAndParamAreIncompatible = PR_TRUE;
51420:             }
51420:             break;
51420:         case LOCAL_GL_TEXTURE_MAG_FILTER:
51420:             switch (intParam) {
51420:                 case LOCAL_GL_NEAREST:
51420:                 case LOCAL_GL_LINEAR:
51422:                     tex->SetMagFilter(intParam);
51420:                     break;
51420:                 default:
51420:                     pnameAndParamAreIncompatible = PR_TRUE;
51420:             }
51420:             break;
51420:         case LOCAL_GL_TEXTURE_WRAP_S:
51422:             switch (intParam) {
51422:                 case LOCAL_GL_CLAMP_TO_EDGE:
51422:                 case LOCAL_GL_MIRRORED_REPEAT:
51422:                 case LOCAL_GL_REPEAT:
51422:                     tex->SetWrapS(intParam);
51422:                     break;
51422:                 default:
51422:                     pnameAndParamAreIncompatible = PR_TRUE;
51422:             }
51422:             break;
51420:         case LOCAL_GL_TEXTURE_WRAP_T:
51420:             switch (intParam) {
51420:                 case LOCAL_GL_CLAMP_TO_EDGE:
51420:                 case LOCAL_GL_MIRRORED_REPEAT:
51420:                 case LOCAL_GL_REPEAT:
51422:                     tex->SetWrapT(intParam);
51420:                     break;
51420:                 default:
51420:                     pnameAndParamAreIncompatible = PR_TRUE;
51420:             }
51420:             break;
51420:         default:
51420:             return ErrorInvalidEnumInfo("texParameter: pname", pname);
51420:     }
51420: 
51420:     if (pnameAndParamAreIncompatible) {
51420:         if (intParamPtr)
51420:             return ErrorInvalidEnum("texParameteri: pname %x and param %x (decimal %d) are mutually incompatible",
51420:                                     pname, intParam, intParam);
51420:         else
51420:             return ErrorInvalidValue("texParameterf: pname %x and floating-point param %e are mutually incompatible",
51420:                                     pname, floatParam);
51420:     }
51420: 
51420:     MakeContextCurrent();
51420:     if (intParamPtr)
51420:         gl->fTexParameteri(target, pname, intParam);
51420:     else
51420:         gl->fTexParameterf(target, pname, floatParam);
51420: 
51420:     return NS_OK;
51420: }
51420: 
32195: NS_IMETHODIMP
42916: WebGLContext::TexParameterf(WebGLenum target, WebGLenum pname, WebGLfloat param)
32835: {
51420:     return TexParameter_base(target, pname, nsnull, &param);
32835: }
51420: 
32835: NS_IMETHODIMP
42916: WebGLContext::TexParameteri(WebGLenum target, WebGLenum pname, WebGLint param)
32835: {
51420:     return TexParameter_base(target, pname, &param, nsnull);
32835: }
32835: 
32835: NS_IMETHODIMP
43851: WebGLContext::GetTexParameter(WebGLenum target, WebGLenum pname, nsIVariant **retval)
32835: {
51424:     *retval = nsnull;
51424: 
53701:     MakeContextCurrent();
53701: 
53701:     if (!ValidateTextureTargetEnum(target, "getTexParameter: target"))
53701:         return NS_OK;
53701: 
53701:     if (!activeBoundTextureForTarget(target))
53701:         return ErrorInvalidOperation("getTexParameter: no texture bound");
53701: 
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32835: 
32835:     switch (pname) {
32835:         case LOCAL_GL_TEXTURE_MIN_FILTER:
32835:         case LOCAL_GL_TEXTURE_MAG_FILTER:
32835:         case LOCAL_GL_TEXTURE_WRAP_S:
32835:         case LOCAL_GL_TEXTURE_WRAP_T:
32835:         {
43851:             GLint i = 0;
43011:             gl->fGetTexParameteriv(target, pname, &i);
43851:             wrval->SetAsInt32(i);
32835:         }
32835:             break;
32835: 
32835:         default:
47813:             return ErrorInvalidEnumInfo("getTexParameter: parameter", pname);
32835:     }
32835: 
43851:     *retval = wrval.forget().get();
43851: 
32835:     return NS_OK;
32835: }
32835: 
35013: /* any getUniform(in WebGLProgram program, in WebGLUniformLocation location) raises(DOMException); */
32195: NS_IMETHODIMP
43852: WebGLContext::GetUniform(nsIWebGLProgram *pobj, nsIWebGLUniformLocation *ploc, nsIVariant **retval)
32195: {
51424:     *retval = nsnull;
51424: 
42916:     WebGLuint progname;
43010:     WebGLProgram *prog;
47811:     if (!GetConcreteObjectAndGLName("getUniform: program", pobj, &prog, &progname))
47811:         return NS_OK;
42471: 
43010:     WebGLUniformLocation *location;
47811:     if (!GetConcreteObject("getUniform: location", ploc, &location))
47811:         return NS_OK;
43010: 
43010:     if (location->Program() != prog)
43010:         return ErrorInvalidValue("GetUniform: this uniform location corresponds to another program");
43010: 
43331:     if (location->ProgramGeneration() != prog->Generation())
43331:         return ErrorInvalidValue("GetUniform: this uniform location is obsolete since the program has been relinked");
43331: 
43852:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43852:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
32195:     MakeContextCurrent();
32195: 
43010:     GLint uniforms = 0;
43474:     GLint uniformNameMaxLength = 0;
43010:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORMS, &uniforms);
43474:     gl->fGetProgramiv(progname, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &uniformNameMaxLength);
43010: 
43010:     // we now need the type info to switch between fGetUniformfv and fGetUniformiv
43010:     // the only way to get that is to iterate through all active uniforms by index until
43010:     // one matches the given uniform location.
43010:     GLenum uniformType = 0;
43474:     nsAutoArrayPtr<GLchar> uniformName(new GLchar[uniformNameMaxLength]);
47814:     // this buffer has 16 more bytes to be able to store [index] at the end.
47814:     nsAutoArrayPtr<GLchar> uniformNameBracketIndex(new GLchar[uniformNameMaxLength + 16]);
47814: 
43010:     GLint index;
43010:     for (index = 0; index < uniforms; ++index) {
47814:         GLsizei length;
47814:         GLint size;
47814:         gl->fGetActiveUniform(progname, index, uniformNameMaxLength, &length,
47814:                               &size, &uniformType, uniformName);
43010:         if (gl->fGetUniformLocation(progname, uniformName) == location->Location())
43010:             break;
47814: 
47814:         // now we handle the case of array uniforms. In that case, fGetActiveUniform returned as 'size'
47814:         // the biggest index used plus one, so we need to loop over that. The 0 index has already been handled above,
47814:         // so we can start at one. For each index, we construct the string uniformName + "[" + index + "]".
47814:         if (size > 1) {
47814:             bool found_it = false;
47814:             if (uniformName[length - 1] == ']') { // if uniformName ends in [0]
47814:                 // remove the [0] at the end
47814:                 length -= 3;
47814:                 uniformName[length] = 0;
47814:             }
47814:             for (GLint arrayIndex = 1; arrayIndex < size; arrayIndex++) {
47814:                 sprintf(uniformNameBracketIndex.get(), "%s[%d]", uniformName.get(), arrayIndex);
47814:                 if (gl->fGetUniformLocation(progname, uniformNameBracketIndex) == location->Location()) {
47814:                     found_it = true;
47814:                     break;
47814:                 }
47814:             }
47814:             if (found_it) break;
47814:         }
43010:     }
43010: 
43010:     if (index == uniforms)
42477:         return NS_ERROR_FAILURE; // XXX GL error? shouldn't happen.
32195: 
32195:     GLenum baseType;
32195:     GLint unitSize;
43010:     if (!BaseTypeAndSizeFromUniformType(uniformType, &baseType, &unitSize))
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     // this should never happen
32195:     if (unitSize > 16)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (baseType == LOCAL_GL_FLOAT) {
51424:         GLfloat fv[16] = { GLfloat(0) };
43010:         gl->fGetUniformfv(progname, location->Location(), fv);
43852:         if (unitSize == 1) {
43852:             wrval->SetAsFloat(fv[0]);
43852:         } else {
43852:             wrval->SetAsArray(nsIDataType::VTYPE_FLOAT, nsnull,
43852:                               unitSize, static_cast<void*>(fv));
43852:         }
32195:     } else if (baseType == LOCAL_GL_INT) {
51424:         GLint iv[16] = { 0 };
43010:         gl->fGetUniformiv(progname, location->Location(), iv);
43852:         if (unitSize == 1) {
43852:             wrval->SetAsInt32(iv[0]);
32195:         } else {
43852:             wrval->SetAsArray(nsIDataType::VTYPE_INT32, nsnull,
43852:                               unitSize, static_cast<void*>(iv));
32195:         }
43852:     } else if (baseType == LOCAL_GL_BOOL) {
51424:         GLint iv[16] = { 0 };
43852:         gl->fGetUniformiv(progname, location->Location(), iv);
43852:         if (unitSize == 1) {
43852:             wrval->SetAsBool(PRBool(iv[0]));
43852:         } else {
51424:             PRUint8 uv[16] = { 0 };
43852:             for (int k = 0; k < unitSize; k++)
43852:                 uv[k] = PRUint8(iv[k]);
43852:             wrval->SetAsArray(nsIDataType::VTYPE_UINT8, nsnull,
43852:                               unitSize, static_cast<void*>(uv));
43852:         }
43852:     } else {
43852:         wrval->SetAsVoid();
43852:     }
43852: 
43852:     *retval = wrval.forget().get();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43010: WebGLContext::GetUniformLocation(nsIWebGLProgram *pobj, const nsAString& name, nsIWebGLUniformLocation **retval)
32195: {
51424:     *retval = nsnull;
51424: 
42916:     WebGLuint progname;
43010:     WebGLProgram *prog;
47811:     if (!GetConcreteObjectAndGLName("getUniformLocation: program", pobj, &prog, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
43010: 
43010:     GLint intlocation = gl->fGetUniformLocation(progname, NS_LossyConvertUTF16toASCII(name).get());
43010: 
43331:     nsRefPtr<nsIWebGLUniformLocation> loc = prog->GetUniformLocationObject(intlocation);
43331:     *retval = loc.forget().get();
43010: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
51421: WebGLContext::GetVertexAttrib(WebGLuint index, WebGLenum pname, nsIVariant **retval)
32195: {
51424:     *retval = nsnull;
51424: 
53696:     if (index >= mAttribBuffers.Length())
53696:         return ErrorInvalidValue("getVertexAttrib: invalid index");
53696: 
51421:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
51421:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
53696:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
53696:             wrval->SetAsISupports(mAttribBuffers[index].buf);
53696:             break;
53696: 
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_SIZE:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_STRIDE:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_TYPE:
32195:         {
43011:             PRInt32 i = 0;
43011:             gl->fGetVertexAttribiv(index, pname, (GLint*) &i);
51421:             wrval->SetAsInt32(i);
32195:         }
32195:             break;
32195: 
32195:         case LOCAL_GL_CURRENT_VERTEX_ATTRIB:
32195:         {
51898:             WebGLfloat vec[4] = {0, 0, 0, 1};
51898:             if (index) {
51898:                 gl->fGetVertexAttribfv(index, LOCAL_GL_CURRENT_VERTEX_ATTRIB, &vec[0]);
51898:             } else {
51898:                 vec[0] = mVertexAttrib0Vector[0];
51898:                 vec[1] = mVertexAttrib0Vector[1];
51898:                 vec[2] = mVertexAttrib0Vector[2];
51898:                 vec[3] = mVertexAttrib0Vector[3];
51898:             }
51421:             wrval->SetAsArray(nsIDataType::VTYPE_FLOAT, nsnull,
51898:                               4, vec);
32195:         }
32195:             break;
53696: 
43011:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_ENABLED:
43011:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
43011:         {
43011:             PRInt32 i = 0;
43011:             gl->fGetVertexAttribiv(index, pname, (GLint*) &i);
51421:             wrval->SetAsBool(PRBool(i));
43011:         }
43011:             break;
32195: 
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER:
53696:             wrval->SetAsUint32(mAttribBuffers[index].byteOffset);
53696:             break;
53696: 
32195:         default:
47813:             return ErrorInvalidEnumInfo("getVertexAttrib: parameter", pname);
32195:     }
32195: 
51421:     *retval = wrval.forget().get();
51421: 
32195:     return NS_OK;
32195: }
32195: 
32835: /* GLuint getVertexAttribOffset (in GLuint index, in GLenum pname); */
32835: NS_IMETHODIMP
42916: WebGLContext::GetVertexAttribOffset(WebGLuint index, WebGLenum pname, WebGLuint *retval)
32835: {
53696:     *retval = 0;
53696: 
53696:     if (index >= mAttribBuffers.Length())
53696:         return ErrorInvalidValue("getVertexAttribOffset: invalid index");
53696: 
53696:     if (pname != LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER)
53696:         return ErrorInvalidEnum("getVertexAttribOffset: bad parameter");
53696: 
53696:     *retval = mAttribBuffers[index].byteOffset;
53696:     return NS_OK;
32835: }
32835: 
32835: NS_IMETHODIMP
42916: WebGLContext::Hint(WebGLenum target, WebGLenum mode)
32195: {
55263:     return ErrorInvalidEnum("hint: invalid hint");
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::IsBuffer(nsIWebGLBuffer *bobj, WebGLboolean *retval)
32195: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLBuffer>("isBuffer", bobj, 0, &isDeleted) && !isDeleted;
42472: 
42471:     return NS_OK;
42471: }
42471: 
42472: NS_IMETHODIMP
42916: WebGLContext::IsFramebuffer(nsIWebGLFramebuffer *fbobj, WebGLboolean *retval)
42472: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLFramebuffer>("isFramebuffer", fbobj, 0, &isDeleted) && !isDeleted;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::IsProgram(nsIWebGLProgram *pobj, WebGLboolean *retval)
32195: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLProgram>("isProgram", pobj, 0, &isDeleted) && !isDeleted;
42472: 
42471:     return NS_OK;
42471: }
42471: 
42472: NS_IMETHODIMP
42916: WebGLContext::IsRenderbuffer(nsIWebGLRenderbuffer *rbobj, WebGLboolean *retval)
42472: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLRenderbuffer>("isRenderBuffer", rbobj, 0, &isDeleted) && !isDeleted;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::IsShader(nsIWebGLShader *sobj, WebGLboolean *retval)
32195: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLShader>("isShader", sobj, 0, &isDeleted) && !isDeleted;
42472: 
42471:     return NS_OK;
42471: }
42471: 
32195: NS_IMETHODIMP
42916: WebGLContext::IsTexture(nsIWebGLTexture *tobj, WebGLboolean *retval)
32195: {
42472:     PRBool isDeleted;
47811:     *retval = CanGetConcreteObject<WebGLTexture>("isTexture", tobj, 0, &isDeleted) && !isDeleted;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
43317: WebGLContext::IsEnabled(WebGLenum cap, WebGLboolean *retval)
32195: {
51424:     *retval = 0;
51424: 
51424:     if (!ValidateCapabilityEnum(cap, "isEnabled"))
46443:         return NS_OK;
43317: 
32195:     MakeContextCurrent();
43317:     *retval = gl->fIsEnabled(cap);
32195:     return NS_OK;
32195: }
32195: 
47205: GL_SAME_METHOD_1(LineWidth, LineWidth, WebGLfloat)
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::LinkProgram(nsIWebGLProgram *pobj)
32195: {
42472:     GLuint progname;
43098:     WebGLProgram *program;
47811:     if (!GetConcreteObjectAndGLName("linkProgram", pobj, &program, &progname))
47811:         return NS_OK;
42471: 
43331:     if (!program->NextGeneration())
43331:         return NS_ERROR_FAILURE;
32195: 
43637:     if (!program->HasBothShaderTypesAttached()) {
43637:         program->SetLinkStatus(PR_FALSE);
43637:         return NS_OK;
43637:     }
43637: 
43637:     MakeContextCurrent();
43637: 
43637:     gl->fLinkProgram(progname);
43637: 
43098:     GLint ok;
43098:     gl->fGetProgramiv(progname, LOCAL_GL_LINK_STATUS, &ok);
43474:     if (ok) {
43474:         program->SetLinkStatus(PR_TRUE);
43474:         program->UpdateInfo(gl);
43474:     } else {
43474:         program->SetLinkStatus(PR_FALSE);
43474:     }
43098: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::PixelStorei(WebGLenum pname, WebGLint param)
32195: {
43639:     switch (pname) {
43639:         case UNPACK_FLIP_Y_WEBGL:
43639:             mPixelStoreFlipY = (param != 0);
43639:             break;
43639:         case UNPACK_PREMULTIPLY_ALPHA_WEBGL:
43639:             mPixelStorePremultiplyAlpha = (param != 0);
43639:             break;
43639:         case LOCAL_GL_PACK_ALIGNMENT:
43639:         case LOCAL_GL_UNPACK_ALIGNMENT:
43639:             if (param != 1 &&
43639:                 param != 2 &&
43639:                 param != 4 &&
43639:                 param != 8)
43639:                 return ErrorInvalidValue("PixelStorei: invalid pack/unpack alignment value");
55904:             if (pname == LOCAL_GL_PACK_ALIGNMENT)
55904:                 mPixelStorePackAlignment = param;
55904:             else if (pname == LOCAL_GL_UNPACK_ALIGNMENT)
55904:                 mPixelStoreUnpackAlignment = param;
32195:             MakeContextCurrent();
32195:             gl->fPixelStorei(pname, param);
43639:             break;
43639:         default:
47813:             return ErrorInvalidEnumInfo("PixelStorei: parameter", pname);
43639:     }
32195: 
32195:     return NS_OK;
32195: }
43639: 
32195: 
47205: GL_SAME_METHOD_2(PolygonOffset, PolygonOffset, WebGLfloat, WebGLfloat)
32195: 
32195: NS_IMETHODIMP
43853: WebGLContext::ReadPixels(PRInt32 dummy)
32195: {
43853:     return NS_ERROR_FAILURE;
43853: }
43853: 
43856: nsresult
43853: WebGLContext::ReadPixels_base(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height,
43853:                               WebGLenum format, WebGLenum type, void *data, PRUint32 byteLength)
43853: {
43655:     if (HTMLCanvasElement()->IsWriteOnly() && !nsContentUtils::IsCallerTrustedForRead()) {
55908:         LogMessageIfVerbose("ReadPixels: Not allowed");
32195:         return NS_ERROR_DOM_SECURITY_ERR;
32195:     }
32195: 
43853:     if (width < 0 || height < 0)
43853:         return ErrorInvalidValue("ReadPixels: negative size passed");
43853: 
42916:     WebGLsizei boundWidth = mBoundFramebuffer ? mBoundFramebuffer->width() : mWidth;
42916:     WebGLsizei boundHeight = mBoundFramebuffer ? mBoundFramebuffer->height() : mHeight;
32195: 
32195:     PRUint32 size = 0;
32195:     switch (format) {
32195:       case LOCAL_GL_ALPHA:
32195:         size = 1;
32195:         break;
32195:       case LOCAL_GL_RGB:
32195:         size = 3;
32195:         break;
32195:       case LOCAL_GL_RGBA:
32195:         size = 4;
32195:         break;
32195:       default:
47813:         return ErrorInvalidEnumInfo("readPixels: format", format);
32195:     }
42477: 
32195:     switch (type) {
32195: //         case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
32195: //         case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
32195: //         case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
32195:       case LOCAL_GL_UNSIGNED_BYTE:
32195:         break;
32195:       default:
47813:         return ErrorInvalidEnumInfo("ReadPixels: type", type);
32195:     }
32195: 
47204:     CheckedUint32 checked_plainRowSize = CheckedUint32(width) * size;
47204: 
55904:     PRUint32 packAlignment = mPixelStorePackAlignment;
55904: 
47204:     // alignedRowSize = row size rounded up to next multiple of packAlignment
47204:     CheckedUint32 checked_alignedRowSize
47204:         = ((checked_plainRowSize + packAlignment-1) / packAlignment) * packAlignment;
47204: 
47204:     CheckedUint32 checked_neededByteLength
47204:         = (height-1) * checked_alignedRowSize + checked_plainRowSize;
47204: 
47204:     if (!checked_neededByteLength.valid())
47204:         return ErrorInvalidOperation("ReadPixels: integer overflow computing the needed buffer size");
47204: 
47204:     if (checked_neededByteLength.value() > byteLength)
43853:         return ErrorInvalidOperation("ReadPixels: buffer too small");
43853: 
56959:     MakeContextCurrent();
56959: 
56959:     // prevent readback of arbitrary video memory through uninitialized renderbuffers!
56959:     if (mBoundFramebuffer && !mBoundFramebuffer->CheckAndInitializeRenderbuffers())
56959:         return NS_OK;
56959: 
43853:     if (CanvasUtils::CheckSaneSubrectSize(x, y, width, height, boundWidth, boundHeight)) {
43853:         // the easy case: we're not reading out-of-range pixels
43853:         gl->fReadPixels(x, y, width, height, format, type, data);
43853:     } else {
43853:         // the rectangle doesn't fit entirely in the bound buffer. We then have to set to zero the part
43853:         // of the buffer that correspond to out-of-range pixels. We don't want to rely on system OpenGL
43853:         // to do that for us, because passing out of range parameters to a buggy OpenGL implementation
43853:         // could conceivably allow to read memory we shouldn't be allowed to read. So we manually initialize
43853:         // the buffer to zero and compute the parameters to pass to OpenGL. We have to use an intermediate buffer
43853:         // to accomodate the potentially different strides (widths).
43853: 
43853:         // zero the whole destination buffer. Too bad for the part that's going to be overwritten, we're not
43853:         // 100% efficient here, but in practice this is a quite rare case anyway.
43853:         memset(data, 0, byteLength);
43853: 
43853:         if (   x >= boundWidth
43853:             || x+width <= 0
43853:             || y >= boundHeight
43853:             || y+height <= 0)
43853:         {
43853:             // we are completely outside of range, can exit now with buffer filled with zeros
43853:             return NS_OK;
43853:         }
43853: 
43853:         // compute the parameters of the subrect we're actually going to call glReadPixels on
43853:         GLint   subrect_x      = PR_MAX(x, 0);
43853:         GLint   subrect_end_x  = PR_MIN(x+width, boundWidth);
43853:         GLsizei subrect_width  = subrect_end_x - subrect_x;
43853: 
43853:         GLint   subrect_y      = PR_MAX(y, 0);
43853:         GLint   subrect_end_y  = PR_MIN(y+height, boundHeight);
43853:         GLsizei subrect_height = subrect_end_y - subrect_y;
43853: 
47204:         if (subrect_width < 0 || subrect_height < 0 ||
51423:             subrect_width > width || subrect_height > height)
47204:             return ErrorInvalidOperation("ReadPixels: integer overflow computing clipped rect size");
47204: 
47204:         // now we know that subrect_width is in the [0..width] interval, and same for heights.
47204: 
43853:         // now, same computation as above to find the size of the intermediate buffer to allocate for the subrect
47204:         // no need to check again for integer overflow here, since we already know the sizes aren't greater than before
43853:         PRUint32 subrect_plainRowSize = subrect_width * size;
43853:         PRUint32 subrect_alignedRowSize = (subrect_plainRowSize + packAlignment-1) &
43853:             ~PRUint32(packAlignment-1);
43853:         PRUint32 subrect_byteLength = (subrect_height-1)*subrect_alignedRowSize + subrect_plainRowSize;
43853: 
43853:         // create subrect buffer, call glReadPixels, copy pixels into destination buffer, delete subrect buffer
43853:         GLubyte *subrect_data = new GLubyte[subrect_byteLength];
43853:         gl->fReadPixels(subrect_x, subrect_y, subrect_width, subrect_height, format, type, subrect_data);
47204: 
47204:         // notice that this for loop terminates because we already checked that subrect_height is at most height
43853:         for (GLint y_inside_subrect = 0; y_inside_subrect < subrect_height; ++y_inside_subrect) {
43853:             GLint subrect_x_in_dest_buffer = subrect_x - x;
43853:             GLint subrect_y_in_dest_buffer = subrect_y - y;
43853:             memcpy(static_cast<GLubyte*>(data)
47204:                      + checked_alignedRowSize.value() * (subrect_y_in_dest_buffer + y_inside_subrect)
43853:                      + size * subrect_x_in_dest_buffer, // destination
43853:                    subrect_data + subrect_alignedRowSize * y_inside_subrect, // source
43853:                    subrect_plainRowSize); // size
43853:         }
43853:         delete [] subrect_data;
43853:     }
43853:     return NS_OK;
43853: }
43853: 
43853: NS_IMETHODIMP
43853: WebGLContext::ReadPixels_array(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height,
43853:                                WebGLenum format, WebGLenum type, js::TypedArray *pixels)
43853: {
43853:     return ReadPixels_base(x, y, width, height, format, type,
43853:                            pixels ? pixels->data : 0,
43853:                            pixels ? pixels->byteLength : 0);
43853: }
43853: 
43853: NS_IMETHODIMP
43853: WebGLContext::ReadPixels_buf(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height,
43853:                              WebGLenum format, WebGLenum type, js::ArrayBuffer *pixels)
43853: {
43853:     return ReadPixels_base(x, y, width, height, format, type,
43853:                            pixels ? pixels->data : 0,
43853:                            pixels ? pixels->byteLength : 0);
43853: }
43853: 
43853: NS_IMETHODIMP
42916: WebGLContext::RenderbufferStorage(WebGLenum target, WebGLenum internalformat, WebGLsizei width, WebGLsizei height)
42473: {
56959: 
56959:     if (!mBoundRenderbuffer || !mBoundRenderbuffer->GLName())
56959:         return ErrorInvalidOperation("renderbufferStorage called on renderbuffer 0");
56959: 
42477:     if (target != LOCAL_GL_RENDERBUFFER)
56959:         return ErrorInvalidEnumInfo("renderbufferStorage: target", target);
56959: 
56959:     if (width <= 0 || height <= 0)
56959:         return ErrorInvalidValue("renderbufferStorage: width and height must be > 0");
56959: 
56959:     if (!mBoundRenderbuffer || !mBoundRenderbuffer->GLName())
56959:         return ErrorInvalidOperation("renderbufferStorage called on renderbuffer 0");
56959: 
56959:     MakeContextCurrent();
56959: 
56959:     // certain OpenGL ES renderbuffer formats may not exist on desktop OpenGL
56959:     WebGLenum internalformatForGL = internalformat;
42477: 
42477:     switch (internalformat) {
42477:     case LOCAL_GL_RGBA4:
42477:     case LOCAL_GL_RGB5_A1:
56959:         // 16-bit RGBA formats are not supported on desktop GL
56959:         if (!gl->IsGLES2()) internalformatForGL = LOCAL_GL_RGBA8;
56959:         break;
56959:     case LOCAL_GL_RGB565:
56959:         // the RGB565 format is not supported on desktop GL
56959:         if (!gl->IsGLES2()) internalformatForGL = LOCAL_GL_RGB8;
56959:         break;
42477:     case LOCAL_GL_DEPTH_COMPONENT16:
42477:     case LOCAL_GL_STENCIL_INDEX8:
56959:         // nothing to do for these ones
56959:         break;
56959:     case LOCAL_GL_DEPTH_STENCIL:
56959:         // this one is available in newer OpenGL (at least since 3.1); will probably become available
56959:         // in OpenGL ES 3 (at least it will have some DEPTH_STENCIL) and is the same value that
56959:         // is otherwise provided by EXT_packed_depth_stencil and OES_packed_depth_stencil extensions
56959:         // which means it's supported on most GL and GL ES systems already.
56959:         //
56959:         // So we just use it hoping that it's available (perhaps as an extension) and if it's not available,
56959:         // we just let the GL generate an error and don't do anything about it ourselves.
56959:         internalformatForGL = LOCAL_GL_DEPTH24_STENCIL8;
42477:         break;
42477:     default:
56959:         ErrorInvalidEnumInfo("renderbufferStorage: internalformat", internalformat);
56959:     }
56959: 
56959:     gl->fRenderbufferStorage(target, internalformatForGL, width, height);
56959: 
56959:     mBoundRenderbuffer->SetInternalFormat(internalformat);
42473:     mBoundRenderbuffer->setDimensions(width, height);
56959:     mBoundRenderbuffer->SetInitialized(PR_FALSE);
51896: 
42473:     return NS_OK;
42473: }
32195: 
47205: GL_SAME_METHOD_2(SampleCoverage, SampleCoverage, WebGLfloat, WebGLboolean)
42916: 
46442: NS_IMETHODIMP
46442: WebGLContext::Scissor(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height)
46442: {
46442:     if (width < 0 || height < 0)
46442:         return ErrorInvalidValue("Scissor: negative size");
46442: 
46442:     MakeContextCurrent();
46442:     gl->fScissor(x, y, width, height);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilFunc(WebGLenum func, WebGLint ref, WebGLuint mask)
46442: {
46443:     if (!ValidateComparisonEnum(func, "stencilFunc: func"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilFunc(func, ref, mask);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilFuncSeparate(WebGLenum face, WebGLenum func, WebGLint ref, WebGLuint mask)
46442: {
46443:     if (!ValidateFaceEnum(face, "stencilFuncSeparate: face") ||
46443:         !ValidateComparisonEnum(func, "stencilFuncSeparate: func"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilFuncSeparate(face, func, ref, mask);
46442:     return NS_OK;
46442: }
42916: 
42916: GL_SAME_METHOD_1(StencilMask, StencilMask, WebGLuint)
42916: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilMaskSeparate(WebGLenum face, WebGLuint mask)
46442: {
46443:     if (!ValidateFaceEnum(face, "stencilMaskSeparate: face"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilMaskSeparate(face, mask);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilOp(WebGLenum sfail, WebGLenum dpfail, WebGLenum dppass)
46442: {
46443:     if (!ValidateStencilOpEnum(sfail, "stencilOp: sfail") ||
46443:         !ValidateStencilOpEnum(dpfail, "stencilOp: dpfail") ||
46443:         !ValidateStencilOpEnum(dppass, "stencilOp: dppass"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilOp(sfail, dpfail, dppass);
46442:     return NS_OK;
46442: }
46442: 
46442: NS_IMETHODIMP
46442: WebGLContext::StencilOpSeparate(WebGLenum face, WebGLenum sfail, WebGLenum dpfail, WebGLenum dppass)
46442: {
46443:     if (!ValidateFaceEnum(face, "stencilOpSeparate: face") ||
46443:         !ValidateStencilOpEnum(sfail, "stencilOpSeparate: sfail") ||
46443:         !ValidateStencilOpEnum(dpfail, "stencilOpSeparate: dpfail") ||
46443:         !ValidateStencilOpEnum(dppass, "stencilOpSeparate: dppass"))
46443:         return NS_OK;
46442: 
46442:     MakeContextCurrent();
46442:     gl->fStencilOpSeparate(face, sfail, dpfail, dppass);
46442:     return NS_OK;
46442: }
32195: 
55904: struct WebGLImageConverter
43854: {
55904:     PRBool flip;
55904:     size_t width, height, srcStride, dstStride, srcTexelSize, dstTexelSize;
55904:     const PRUint8 *src;
55904:     PRUint8 *dst;
55904: 
55904:     WebGLImageConverter()
55904:     {
55904:         memset(this, 0, sizeof(WebGLImageConverter));
55904:     }
55904: 
55904:     template<typename SrcType, typename DstType,
55904:          void unpackingFunc(const SrcType*, PRUint8*),
55904:          void packingFunc(const PRUint8*, DstType*)>
55904:     void run()
55904:     {
55904:         for (size_t src_row = 0; src_row < height; ++src_row) {
55904:             size_t dst_row = flip ? (height - 1 - src_row) : src_row;
55904:             PRUint8 *dst_row_ptr = dst + dst_row * dstStride;
55904:             const PRUint8 *src_row_ptr = src + src_row * srcStride;
55904:             const PRUint8 *src_row_end = src_row_ptr + width * srcTexelSize; // != src_row_ptr + byteStride
55904:             while (src_row_ptr != src_row_end) {
55904:                 PRUint8 tmp[4];
55904:                 unpackingFunc(reinterpret_cast<const SrcType*>(src_row_ptr), tmp);
55904:                 packingFunc(tmp, reinterpret_cast<DstType*>(dst_row_ptr));
55904:                 src_row_ptr += srcTexelSize;
55904:                 dst_row_ptr += dstTexelSize;
55904:             }
55904:         }
55904:     }
55904: };
55904: 
55904: void
55906: WebGLContext::ConvertImage(size_t width, size_t height, size_t srcStride, size_t dstStride,
55904:                            const PRUint8*src, PRUint8 *dst,
55904:                            int srcFormat, PRBool srcPremultiplied,
55904:                            int dstFormat, PRBool dstPremultiplied,
55904:                            size_t dstTexelSize)
55904: {
55904:     if (width <= 0 || height <= 0)
55904:         return;
55904: 
55906:     if (srcFormat == dstFormat &&
55906:         srcPremultiplied == dstPremultiplied)
55906:     {
55906:         // fast exit path: we just have to memcpy all the rows.
55906:         //
55906:         // The case where absolutely nothing needs to be done is supposed to have
55906:         // been handled earlier (in TexImage2D_base, etc).
55906:         //
55906:         // So the case we're handling here is when even though no format conversion is needed,
55906:         // we still might have to flip vertically and/or to adjust to a different stride.
55906: 
55906:         size_t row_size = width * dstTexelSize; // doesn't matter, src and dst formats agree
55906:         const PRUint8* src_row = src;
55906:         const PRUint8* src_end = src + height * srcStride;
55906: 
55906:         PRUint8* dst_row = mPixelStoreFlipY ? dst + (height-1) * dstStride : dst;
55906:         ptrdiff_t dst_delta = mPixelStoreFlipY ? -dstStride : dstStride;
55906: 
55906:         while(src_row != src_end) {
55906:             memcpy(dst_row, src_row, row_size);
55906:             src_row += srcStride;
55906:             dst_row += dst_delta;
55906:         }
55906:         return;
55906:     }
55904: 
55904:     WebGLImageConverter converter;
55904:     converter.flip = mPixelStoreFlipY;
55904:     converter.width = width;
55904:     converter.height = height;
55904:     converter.srcStride = srcStride;
55904:     converter.dstStride = dstStride;
55904:     converter.dstTexelSize = dstTexelSize;
55904:     converter.src = src;
55904:     converter.dst = dst;
55904: 
55904:     int premultiplicationOp = (!srcPremultiplied && dstPremultiplied) ? WebGLTexelPremultiplicationOp::Premultiply
55904:                             : (srcPremultiplied && !dstPremultiplied) ? WebGLTexelPremultiplicationOp::Unmultiply
55904:                             : WebGLTexelPremultiplicationOp::None;
55904: 
55904: #define HANDLE_DSTFORMAT(format, SrcType, DstType, unpackFunc, packFunc) \
55904:         case WebGLTexelFormat::format: \
55904:             switch (premultiplicationOp) { \
55904:                 case WebGLTexelPremultiplicationOp::Premultiply: \
55904:                     converter.run<SrcType, DstType, \
55904:                                   WebGLTexelConversions::unpackFunc, \
55904:                                   WebGLTexelConversions::packFunc##Premultiply>(); \
55904:                 break; \
55904:                 case WebGLTexelPremultiplicationOp::Unmultiply: \
55904:                     converter.run<SrcType, DstType, \
55904:                                   WebGLTexelConversions::unpackFunc, \
55904:                                   WebGLTexelConversions::packFunc##Unmultiply>(); \
55904:                 break; \
55904:                 default: \
55904:                     converter.run<SrcType, DstType, \
55904:                                   WebGLTexelConversions::unpackFunc, \
55904:                                   WebGLTexelConversions::packFunc>(); \
55904:                 break; \
55904:             } \
55904:             break;
55904: 
55904: #define HANDLE_SRCFORMAT(format, size, SrcType, unpackFunc) \
55904:         case WebGLTexelFormat::format: \
55904:             converter.srcTexelSize = size; \
55904:             switch (dstFormat) { \
55904:                 HANDLE_DSTFORMAT(RGBA8,    SrcType, PRUint8,  unpackFunc, packRGBA8ToRGBA8) \
55904:                 HANDLE_DSTFORMAT(RGB8,     SrcType, PRUint8,  unpackFunc, packRGBA8ToRGB8) \
55904:                 HANDLE_DSTFORMAT(R8,       SrcType, PRUint8,  unpackFunc, packRGBA8ToR8) \
55904:                 HANDLE_DSTFORMAT(RA8,      SrcType, PRUint8,  unpackFunc, packRGBA8ToRA8) \
55904:                 HANDLE_DSTFORMAT(RGBA5551, SrcType, PRUint16, unpackFunc, packRGBA8ToUnsignedShort5551) \
55904:                 HANDLE_DSTFORMAT(RGBA4444, SrcType, PRUint16, unpackFunc, packRGBA8ToUnsignedShort4444) \
55904:                 HANDLE_DSTFORMAT(RGB565,   SrcType, PRUint16, unpackFunc, packRGBA8ToUnsignedShort565) \
55904:                 /* A8 needs to be special-cased as it doesn't have color channels to premultiply */ \
55904:                 case WebGLTexelFormat::A8: \
55904:                     converter.run<SrcType, PRUint8, \
55904:                                   WebGLTexelConversions::unpackFunc, \
55904:                                   WebGLTexelConversions::packRGBA8ToA8>(); \
55904:                     break; \
55904:                 default: \
55904:                     NS_ASSERTION(PR_FALSE, "Coding error?! Should never reach this point."); \
55904:                     return; \
55904:             } \
55904:             break;
55904: 
55904:     switch (srcFormat) {
55904:         HANDLE_SRCFORMAT(RGBA8,    4, PRUint8,  unpackRGBA8ToRGBA8)
55904:         HANDLE_SRCFORMAT(RGBX8,    4, PRUint8,  unpackRGB8ToRGBA8)
55904:         HANDLE_SRCFORMAT(RGB8,     3, PRUint8,  unpackRGB8ToRGBA8)
55904:         HANDLE_SRCFORMAT(BGRA8,    4, PRUint8,  unpackBGRA8ToRGBA8)
55904:         HANDLE_SRCFORMAT(BGRX8,    4, PRUint8,  unpackBGR8ToRGBA8)
55904:         HANDLE_SRCFORMAT(BGR8,     3, PRUint8,  unpackBGR8ToRGBA8)
55904:         HANDLE_SRCFORMAT(R8,       1, PRUint8,  unpackR8ToRGBA8)
55904:         HANDLE_SRCFORMAT(A8,       1, PRUint8,  unpackA8ToRGBA8)
55904:         HANDLE_SRCFORMAT(RA8,      2, PRUint8,  unpackRA8ToRGBA8)
55904:         HANDLE_SRCFORMAT(RGBA5551, 2, PRUint16, unpackRGBA5551ToRGBA8)
55904:         HANDLE_SRCFORMAT(RGBA4444, 2, PRUint16, unpackRGBA4444ToRGBA8)
55904:         HANDLE_SRCFORMAT(RGB565,   2, PRUint16, unpackRGB565ToRGBA8)
55904:         default:
55904:             NS_ASSERTION(PR_FALSE, "Coding error?! Should never reach this point.");
55904:             return;
55904:     }
43854: }
32195: 
32195: nsresult
37417: WebGLContext::DOMElementToImageSurface(nsIDOMElement *imageOrCanvas,
55904:                                        gfxImageSurface **imageOut, int *format)
32195: {
32195:     gfxImageSurface *surf = nsnull;
32195: 
32195:     nsLayoutUtils::SurfaceFromElementResult res =
32195:         nsLayoutUtils::SurfaceFromElement(imageOrCanvas,
32195:                                           nsLayoutUtils::SFE_WANT_NEW_SURFACE | nsLayoutUtils::SFE_WANT_IMAGE_SURFACE);
32195:     if (!res.mSurface)
32195:         return NS_ERROR_FAILURE;
32195: 
43655:     CanvasUtils::DoDrawImageSecurityCheck(HTMLCanvasElement(), res.mPrincipal, res.mIsWriteOnly);
32195: 
32195:     if (res.mSurface->GetType() != gfxASurface::SurfaceTypeImage) {
32195:         // SurfaceFromElement lied!
32195:         return NS_ERROR_FAILURE;
32195:     }
32195: 
32195:     surf = static_cast<gfxImageSurface*>(res.mSurface.get());
32195: 
32195:     res.mSurface.forget();
32195:     *imageOut = surf;
32195: 
55904:     switch (surf->Format()) {
55904:         case gfxASurface::ImageFormatARGB32:
55904:             *format = WebGLTexelFormat::BGRA8; // careful, our ARGB means BGRA
55904:             break;
55904:         case gfxASurface::ImageFormatRGB24:
55904:             *format = WebGLTexelFormat::BGRX8; // careful, our RGB24 is not tightly packed. Whence BGRX8.
55904:             break;
55904:         case gfxASurface::ImageFormatA8:
55904:             *format = WebGLTexelFormat::A8;
55904:             break;
55904:         case gfxASurface::ImageFormatRGB16_565:
55904:             *format = WebGLTexelFormat::RGB565;
55904:             break;
55904:         default:
55904:             NS_ASSERTION(PR_FALSE, "Unsupported image format. Unimplemented.");
55904:             return NS_ERROR_NOT_IMPLEMENTED;
55904:     }
55904: 
32195:     return NS_OK;
32195: }
32195: 
47811: #define OBTAIN_UNIFORM_LOCATION(info)                                   \
43010:     WebGLUniformLocation *location_object;                              \
53699:     PRBool isNull;                                                      \
53699:     if (!GetConcreteObject(info, ploc, &location_object, &isNull))      \
53699:         return NS_OK;                                                   \
53699:     if (isNull)                                                         \
47811:         return NS_OK;                                                   \
43010:     if (mCurrentProgram != location_object->Program())                  \
47814:         return ErrorInvalidOperation("%s: this uniform location doesn't correspond to the current program", info); \
43331:     if (mCurrentProgram->Generation() != location_object->ProgramGeneration())            \
47814:         return ErrorInvalidOperation("%s: This uniform location is obsolete since the program has been relinked", info); \
43010:     GLint location = location_object->Location();
43010: 
43010: #define SIMPLE_ARRAY_METHOD_UNIFORM(name, cnt, arrayType, ptrType)      \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name(PRInt32 dummy) {                                     \
37417:      return NS_ERROR_NOT_IMPLEMENTED;                                   \
37417: }                                                                       \
37417: NS_IMETHODIMP                                                           \
43010: WebGLContext::name##_array(nsIWebGLUniformLocation *ploc, js::TypedArray *wa) \
37417: {                                                                       \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location")                         \
37417:     if (!wa || wa->type != js::TypedArray::arrayType)                   \
47812:         return ErrorInvalidOperation(#name ": array must be " #arrayType);      \
37417:     if (wa->length == 0 || wa->length % cnt != 0)                       \
53698:         return ErrorInvalidValue(#name ": array must be > 0 elements and have a length multiple of %d", cnt); \
37417:     MakeContextCurrent();                                               \
43010:     gl->f##name(location, wa->length / cnt, (ptrType *)wa->data);            \
37417:     return NS_OK;                                                       \
37417: }
37417: 
43010: #define SIMPLE_MATRIX_METHOD_UNIFORM(name, dim, arrayType, ptrType)     \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name(PRInt32 dummy) {                                     \
37417:      return NS_ERROR_NOT_IMPLEMENTED;                                   \
37417: }                                                                       \
37417: NS_IMETHODIMP                                                           \
43010: WebGLContext::name##_array(nsIWebGLUniformLocation *ploc, WebGLboolean transpose, js::TypedArray *wa)  \
37417: {                                                                       \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location")                         \
37417:     if (!wa || wa->type != js::TypedArray::arrayType)                   \
48925:         return ErrorInvalidValue(#name ": array must be " #arrayType);      \
37417:     if (wa->length == 0 || wa->length % (dim*dim) != 0)                 \
48925:         return ErrorInvalidValue(#name ": array length must be >0 and multiple of %d", dim*dim); \
47812:     if (transpose)                                                      \
47812:         return ErrorInvalidValue(#name ": transpose must be FALSE as per the OpenGL ES 2.0 spec"); \
37417:     MakeContextCurrent();                                               \
43010:     gl->f##name(location, wa->length / (dim*dim), transpose, (ptrType *)wa->data); \
37417:     return NS_OK;                                                       \
37417: }
37417: 
43010: #define SIMPLE_METHOD_UNIFORM_1(glname, name, t1)        \
43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1) {      \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location") \
43010:     MakeContextCurrent(); gl->f##glname(location, a1); return NS_OK; \
43010: }
43010: 
43010: #define SIMPLE_METHOD_UNIFORM_2(glname, name, t1, t2)        \
43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1, t2 a2) {      \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location") \
43010:     MakeContextCurrent(); gl->f##glname(location, a1, a2); return NS_OK; \
43010: }
43010: 
43010: #define SIMPLE_METHOD_UNIFORM_3(glname, name, t1, t2, t3)        \
43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1, t2 a2, t3 a3) {      \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location") \
43010:     MakeContextCurrent(); gl->f##glname(location, a1, a2, a3); return NS_OK; \
43010: }
43010: 
43010: #define SIMPLE_METHOD_UNIFORM_4(glname, name, t1, t2, t3, t4)        \
43010: NS_IMETHODIMP WebGLContext::name(nsIWebGLUniformLocation *ploc, t1 a1, t2 a2, t3 a3, t4 a4) {      \
47811:     OBTAIN_UNIFORM_LOCATION(#name ": location") \
43010:     MakeContextCurrent(); gl->f##glname(location, a1, a2, a3, a4); return NS_OK; \
43010: }
43010: 
43010: SIMPLE_METHOD_UNIFORM_1(Uniform1i, Uniform1i, WebGLint)
43010: SIMPLE_METHOD_UNIFORM_2(Uniform2i, Uniform2i, WebGLint, WebGLint)
43010: SIMPLE_METHOD_UNIFORM_3(Uniform3i, Uniform3i, WebGLint, WebGLint, WebGLint)
43010: SIMPLE_METHOD_UNIFORM_4(Uniform4i, Uniform4i, WebGLint, WebGLint, WebGLint, WebGLint)
43010: 
43010: SIMPLE_METHOD_UNIFORM_1(Uniform1f, Uniform1f, WebGLfloat)
43010: SIMPLE_METHOD_UNIFORM_2(Uniform2f, Uniform2f, WebGLfloat, WebGLfloat)
43010: SIMPLE_METHOD_UNIFORM_3(Uniform3f, Uniform3f, WebGLfloat, WebGLfloat, WebGLfloat)
43010: SIMPLE_METHOD_UNIFORM_4(Uniform4f, Uniform4f, WebGLfloat, WebGLfloat, WebGLfloat, WebGLfloat)
43010: 
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform1iv, 1, TYPE_INT32, WebGLint)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform2iv, 2, TYPE_INT32, WebGLint)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform3iv, 3, TYPE_INT32, WebGLint)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform4iv, 4, TYPE_INT32, WebGLint)
43010: 
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform1fv, 1, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform2fv, 2, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform3fv, 3, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_UNIFORM(Uniform4fv, 4, TYPE_FLOAT32, WebGLfloat)
43010: 
43010: SIMPLE_MATRIX_METHOD_UNIFORM(UniformMatrix2fv, 2, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_MATRIX_METHOD_UNIFORM(UniformMatrix3fv, 3, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_MATRIX_METHOD_UNIFORM(UniformMatrix4fv, 4, TYPE_FLOAT32, WebGLfloat)
42916: 
51898: NS_IMETHODIMP
51898: WebGLContext::VertexAttrib1f(PRUint32 index, WebGLfloat x0)
51898: {
51898:     MakeContextCurrent();
51898: 
51898:     if (index) {
51898:         gl->fVertexAttrib1f(index, x0);
51898:     } else {
51898:         mVertexAttrib0Vector[0] = x0;
51898:         mVertexAttrib0Vector[1] = 0;
51898:         mVertexAttrib0Vector[2] = 0;
51898:         mVertexAttrib0Vector[3] = 1;
51898:         if (gl->IsGLES2())
51898:             gl->fVertexAttrib1f(index, x0);
51898:     }
51898: 
51898:     return NS_OK;
51898: }
51898: 
51898: NS_IMETHODIMP
51898: WebGLContext::VertexAttrib2f(PRUint32 index, WebGLfloat x0, WebGLfloat x1)
51898: {
51898:     MakeContextCurrent();
51898: 
51898:     if (index) {
51898:         gl->fVertexAttrib2f(index, x0, x1);
51898:     } else {
51898:         mVertexAttrib0Vector[0] = x0;
51898:         mVertexAttrib0Vector[1] = x1;
51898:         mVertexAttrib0Vector[2] = 0;
51898:         mVertexAttrib0Vector[3] = 1;
51898:         if (gl->IsGLES2())
51898:             gl->fVertexAttrib2f(index, x0, x1);
51898:     }
51898: 
51898:     return NS_OK;
51898: }
51898: 
51898: NS_IMETHODIMP
51898: WebGLContext::VertexAttrib3f(PRUint32 index, WebGLfloat x0, WebGLfloat x1, WebGLfloat x2)
51898: {
51898:     MakeContextCurrent();
51898: 
51898:     if (index) {
51898:         gl->fVertexAttrib3f(index, x0, x1, x2);
51898:     } else {
51898:         mVertexAttrib0Vector[0] = x0;
51898:         mVertexAttrib0Vector[1] = x1;
51898:         mVertexAttrib0Vector[2] = x2;
51898:         mVertexAttrib0Vector[3] = 1;
51898:         if (gl->IsGLES2())
51898:             gl->fVertexAttrib3f(index, x0, x1, x2);
51898:     }
51898: 
51898:     return NS_OK;
51898: }
51898: 
51898: NS_IMETHODIMP
51898: WebGLContext::VertexAttrib4f(PRUint32 index, WebGLfloat x0, WebGLfloat x1,
51898:                                              WebGLfloat x2, WebGLfloat x3)
51898: {
51898:     MakeContextCurrent();
51898: 
51898:     if (index) {
51898:         gl->fVertexAttrib4f(index, x0, x1, x2, x3);
51898:     } else {
51898:         mVertexAttrib0Vector[0] = x0;
51898:         mVertexAttrib0Vector[1] = x1;
51898:         mVertexAttrib0Vector[2] = x2;
51898:         mVertexAttrib0Vector[3] = x3;
51898:         if (gl->IsGLES2())
51898:             gl->fVertexAttrib4f(index, x0, x1, x2, x3);
51898:     }
51898: 
51898:     return NS_OK;
51898: }
51898: 
51898: #define SIMPLE_ARRAY_METHOD_NO_COUNT(name, cnt, arrayType, ptrType)  \
51898: NS_IMETHODIMP                                                           \
51898: WebGLContext::name(PRInt32 dummy) {                                     \
51898:      return NS_ERROR_NOT_IMPLEMENTED;                                   \
51898: }                                                                       \
51898: NS_IMETHODIMP                                                           \
51898: WebGLContext::name##_array(WebGLuint idx, js::TypedArray *wa)           \
51898: {                                                                       \
51898:     if (!wa || wa->type != js::TypedArray::arrayType)                   \
51898:         return ErrorInvalidOperation(#name ": array must be " #arrayType); \
51898:     if (wa->length < cnt)                                               \
51898:         return ErrorInvalidOperation(#name ": array must be >= %d elements", cnt); \
51898:     MakeContextCurrent();                                               \
51898:     ptrType *ptr = (ptrType *)wa->data;                                  \
51898:     if (idx) {                                                        \
51898:         gl->f##name(idx, ptr);                                          \
51898:     } else {                                                            \
51898:         mVertexAttrib0Vector[0] = ptr[0];                               \
51898:         mVertexAttrib0Vector[1] = cnt > 1 ? ptr[1] : ptrType(0);        \
51898:         mVertexAttrib0Vector[2] = cnt > 2 ? ptr[2] : ptrType(0);        \
51898:         mVertexAttrib0Vector[3] = cnt > 3 ? ptr[3] : ptrType(1);        \
51898:         if (gl->IsGLES2())                                              \
51898:             gl->f##name(idx, ptr);                                      \
51898:     }                                                                   \
51898:     return NS_OK;                                                       \
51898: }
42916: 
43010: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib1fv, 1, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib2fv, 2, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib3fv, 3, TYPE_FLOAT32, WebGLfloat)
43010: SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib4fv, 4, TYPE_FLOAT32, WebGLfloat)
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::UseProgram(nsIWebGLProgram *pobj)
32195: {
42472:     WebGLProgram *prog;
42916:     WebGLuint progname;
43098:     PRBool isNull;
47811:     if (!GetConcreteObjectAndGLName("useProgram", pobj, &prog, &progname, &isNull))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
32195: 
43098:     if (isNull) {
43098:         gl->fUseProgram(0);
43098:         mCurrentProgram = nsnull;
43098:     } else {
43098:         if (!prog->LinkStatus())
43098:             return ErrorInvalidOperation("UseProgram: program was not linked successfully");
42472:         gl->fUseProgram(progname);
42472:         mCurrentProgram = prog;
43098:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42471: WebGLContext::ValidateProgram(nsIWebGLProgram *pobj)
32195: {
42916:     WebGLuint progname;
47811:     if (!GetGLName<WebGLProgram>("validateProgram", pobj, &progname))
47811:         return NS_OK;
42471: 
32195:     MakeContextCurrent();
32195: 
56958: #ifdef XP_MACOSX
56958:     if (gl->Vendor() == gl::GLContext::VendorNVIDIA) {
56958:         LogMessageIfVerbose("validateProgram: implemented as a no-operation "
56958:                             "on Mac/NVIDIA to work around a driver crash");
56958:         return NS_OK;
56958:     }
56958: #endif
56958: 
42472:     gl->fValidateProgram(progname);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateFramebuffer(nsIWebGLFramebuffer **retval)
32195: {
51424:     *retval = 0;
51424: 
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name;
32195:     gl->fGenFramebuffers(1, &name);
32195: 
43099:     WebGLFramebuffer *globj = new WebGLFramebuffer(this, name);
32195:     NS_ADDREF(*retval = globj);
32195:     mMapFramebuffers.Put(name, globj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateRenderbuffer(nsIWebGLRenderbuffer **retval)
32195: {
51424:     *retval = 0;
51424: 
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name;
32195:     gl->fGenRenderbuffers(1, &name);
32195: 
43099:     WebGLRenderbuffer *globj = new WebGLRenderbuffer(this, name);
32195:     NS_ADDREF(*retval = globj);
32195:     mMapRenderbuffers.Put(name, globj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
46442: NS_IMETHODIMP
46442: WebGLContext::Viewport(WebGLint x, WebGLint y, WebGLsizei width, WebGLsizei height)
46442: {
46442:     if (width < 0 || height < 0)
46442:         return ErrorInvalidOperation("Viewport: negative size");
46442: 
46442:     MakeContextCurrent();
46442:     gl->fViewport(x, y, width, height);
46442:     return NS_OK;
46442: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::CompileShader(nsIWebGLShader *sobj)
32195: {
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47833:     if (!GetConcreteObjectAndGLName("compileShader", sobj, &shader, &shadername))
47811:         return NS_OK;
32195:     MakeContextCurrent();
32195: 
49256: #if defined(USE_ANGLE)
47653:     if (shader->NeedsTranslation() && mShaderValidation) {
47653:         ShHandle compiler = 0;
55267:         ShBuiltInResources resources;
55267:         memset(&resources, 0, sizeof(ShBuiltInResources));
55267: 
55267:         resources.MaxVertexAttribs = mGLMaxVertexAttribs;
55267:         resources.MaxVertexUniformVectors = mGLMaxVertexUniformVectors;
55267:         resources.MaxVaryingVectors = mGLMaxVaryingVectors;
55267:         resources.MaxVertexTextureImageUnits = mGLMaxVertexTextureImageUnits;
55267:         resources.MaxCombinedTextureImageUnits = mGLMaxTextureUnits;
55267:         resources.MaxTextureImageUnits = mGLMaxTextureImageUnits;
55267:         resources.MaxFragmentUniformVectors = mGLMaxFragmentUniformVectors;
55267:         resources.MaxDrawBuffers = 1;
55267: 
55267:         compiler = ShConstructCompiler((ShShaderType) shader->ShaderType(),
55267:                                        SH_WEBGL_SPEC,
55267:                                        &resources);
47653: 
50606:         nsPromiseFlatCString src(shader->Source());
47653:         const char *s = src.get();
47653: 
55267:         if (!ShCompile(compiler, &s, 1, SH_OBJECT_CODE)) {
55267:             int len = 0;
55267:             ShGetInfo(compiler, SH_INFO_LOG_LENGTH, &len);
55267: 
55267:             if (len) {
55299:                 nsCAutoString info;
55299:                 info.SetLength(len);
55267:                 ShGetInfoLog(compiler, info.BeginWriting());
55267:                 shader->SetTranslationFailure(info);
49256:             } else {
49256:                 shader->SetTranslationFailure(NS_LITERAL_CSTRING("Internal error: failed to get shader info log"));
49256:             }
47653:             ShDestruct(compiler);
47653:             return NS_OK;
47653:         }
47653: 
51748:         /* If the GL context is really GLES2, we want to use the original provided code,
51748:          * since it's actually GLES2.  We still need to validate it however, which is
51748:          * why we ran it through the above, but we don't want the desktop GLSL.
51748:          */
51748:         if (!gl->IsGLES2()) {
55267:             int len = 0;
55267:             ShGetInfo(compiler, SH_OBJECT_CODE_LENGTH, &len);
55267: 
55299:             nsCAutoString translatedSrc;
55299:             translatedSrc.SetLength(len);
55267:             ShGetObjectCode(compiler, translatedSrc.BeginWriting());
55267: 
55267:             nsPromiseFlatCString translatedSrc2(translatedSrc);
55267:             const char *ts = translatedSrc2.get();
55267: 
55267:             gl->fShaderSource(shadername, 1, &ts, NULL);
55267:         } else {
47653:             gl->fShaderSource(shadername, 1, &s, NULL);
55267:         }
55267: 
47653:         shader->SetTranslationSuccess();
47653: 
47653:         ShDestruct(compiler);
47653:     } else
47653: #endif
47653:     {
47653:         const char *s = nsDependentCString(shader->Source()).get();
47653:         gl->fShaderSource(shadername, 1, &s, NULL);
47653:         shader->SetTranslationSuccess();
47653:     }
47653: 
42472:     gl->fCompileShader(shadername);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: NS_IMETHODIMP
43851: WebGLContext::GetShaderParameter(nsIWebGLShader *sobj, WebGLenum pname, nsIVariant **retval)
32835: {
51424:     *retval = nsnull;
51424: 
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47833:     if (!GetConcreteObjectAndGLName("getShaderParameter: shader", sobj, &shader, &shadername))
47811:         return NS_OK;
42471: 
43851:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
43851:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
35013: 
35013:     MakeContextCurrent();
35013: 
35013:     switch (pname) {
35013:         case LOCAL_GL_SHADER_TYPE:
35013:         case LOCAL_GL_INFO_LOG_LENGTH:
35013:         {
43851:             GLint i = 0;
43851:             gl->fGetShaderiv(shadername, pname, &i);
43851:             wrval->SetAsInt32(i);
35013:         }
35013:             break;
47653:         case LOCAL_GL_SHADER_SOURCE_LENGTH:
47653:         {
47653:             wrval->SetAsInt32(PRInt32(shader->Source().Length()) + 1);
47653:         }
47653:             break;
43011:         case LOCAL_GL_DELETE_STATUS:
43011:         case LOCAL_GL_COMPILE_STATUS:
43011:         {
43851:             GLint i = 0;
43851:             gl->fGetShaderiv(shadername, pname, &i);
43851:             wrval->SetAsBool(PRBool(i));
43011:         }
43011:             break;
35013: 
35013:         default:
32835:             return NS_ERROR_NOT_IMPLEMENTED;
32835:     }
32835: 
43851:     *retval = wrval.forget().get();
43851: 
35013:     return NS_OK;
35013: }
35013: 
32195: NS_IMETHODIMP
42472: WebGLContext::GetShaderInfoLog(nsIWebGLShader *sobj, nsAString& retval)
32195: {
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47833:     if (!GetConcreteObjectAndGLName("getShaderInfoLog: shader", sobj, &shader, &shadername))
47811:         return NS_OK;
42471: 
47653:     const nsCString& tlog = shader->TranslationLog();
47653:     if (!tlog.IsVoid()) {
47653:         CopyASCIItoUTF16(tlog, retval);
47653:         return NS_OK;
47653:     }
47653: 
32195:     MakeContextCurrent();
32195: 
32195:     PRInt32 k = -1;
42472:     gl->fGetShaderiv(shadername, LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &k);
32195:     if (k == -1)
42477:         return NS_ERROR_FAILURE; // XXX GL Error? should never happen.
32195: 
32195:     if (k == 0) {
32195:         retval.Truncate();
32195:         return NS_OK;
32195:     }
32195: 
32195:     nsCAutoString log;
32195:     log.SetCapacity(k);
32195: 
42472:     gl->fGetShaderInfoLog(shadername, k, (GLint*) &k, (char*) log.BeginWriting());
32195: 
32195:     log.SetLength(k);
32195: 
32195:     CopyASCIItoUTF16(log, retval);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::GetShaderSource(nsIWebGLShader *sobj, nsAString& retval)
32195: {
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47833:     if (!GetConcreteObjectAndGLName("getShaderSource: shader", sobj, &shader, &shadername))
47811:         return NS_OK;
42471: 
47653:     CopyASCIItoUTF16(shader->Source(), retval);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42472: WebGLContext::ShaderSource(nsIWebGLShader *sobj, const nsAString& source)
32195: {
47653:     WebGLShader *shader;
42916:     WebGLuint shadername;
47833:     if (!GetConcreteObjectAndGLName("shaderSource: shader", sobj, &shader, &shadername))
47811:         return NS_OK;
42471: 
47653:     shader->SetSource(NS_LossyConvertUTF16toASCII(source));
47653: 
47653:     shader->SetNeedsTranslation();
47653: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::VertexAttribPointer(WebGLuint index, WebGLint size, WebGLenum type,
51899:                                   WebGLboolean normalized, WebGLsizei stride,
51899:                                   WebGLsizeiptr byteOffset)
32195: {
32195:     if (mBoundArrayBuffer == nsnull)
42477:         return ErrorInvalidOperation("VertexAttribPointer: must have valid GL_ARRAY_BUFFER binding");
42477: 
51899:     WebGLsizei requiredAlignment = 1;
42477:     switch (type) {
42477:       case LOCAL_GL_BYTE:
42477:       case LOCAL_GL_UNSIGNED_BYTE:
51899:           requiredAlignment = 1;
51899:           break;
42477:       case LOCAL_GL_SHORT:
42477:       case LOCAL_GL_UNSIGNED_SHORT:
51899:           requiredAlignment = 2;
51899:           break;
42477:       // XXX case LOCAL_GL_FIXED:
42477:       case LOCAL_GL_FLOAT:
51899:           requiredAlignment = 4;
42477:           break;
42477:       default:
47813:           return ErrorInvalidEnumInfo("VertexAttribPointer: type", type);
42477:     }
32195: 
51899:     // requiredAlignment should always be a power of two.
51899:     WebGLsizei requiredAlignmentMask = requiredAlignment - 1;
51899: 
32195:     if (index >= mAttribBuffers.Length())
42477:         return ErrorInvalidValue("VertexAttribPointer: index out of range - %d >= %d", index, mAttribBuffers.Length());
32195: 
32195:     if (size < 1 || size > 4)
42477:         return ErrorInvalidValue("VertexAttribPointer: invalid element size");
42477: 
51899:     if (stride < 0 || stride > 255) // see WebGL spec section 6.6 "Vertex Attribute Data Stride"
51899:         return ErrorInvalidValue("VertexAttribPointer: negative stride");
51899: 
51899:     if (byteOffset < 0)
51899:         return ErrorInvalidValue("VertexAttribPointer: negative offset");
51899: 
51899:     if (stride & requiredAlignmentMask) {
51899:         return ErrorInvalidValue("VertexAttribPointer: stride doesn't satisfy the alignment "
51899:                                  "requirement of given type");
51899:     }
51899: 
51899:     if (byteOffset & requiredAlignmentMask) {
51899:         return ErrorInvalidValue("VertexAttribPointer: byteOffset doesn't satisfy the alignment "
51899:                                  "requirement of given type");
51899: 
51899:     }
51899:     
34453:     /* XXX make work with bufferSubData & heterogeneous types 
32195:     if (type != mBoundArrayBuffer->GLType())
42477:         return ErrorInvalidOperation("VertexAttribPointer: type must match bound VBO type: %d != %d", type, mBoundArrayBuffer->GLType());
34453:     */
32195: 
32195:     WebGLVertexAttribData &vd = mAttribBuffers[index];
32195: 
32195:     vd.buf = mBoundArrayBuffer;
32195:     vd.stride = stride;
32195:     vd.size = size;
43009:     vd.byteOffset = byteOffset;
43009:     vd.type = type;
51898:     vd.normalized = normalized;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fVertexAttribPointer(index, size, type, normalized,
34453:                              stride,
43009:                              (void*) (byteOffset));
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
37417: WebGLContext::TexImage2D(PRInt32 dummy)
32195: {
37417:     return NS_ERROR_FAILURE;
32195: }
32195: 
37417: nsresult
42916: WebGLContext::TexImage2D_base(WebGLenum target, WebGLint level, WebGLenum internalformat,
55904:                               WebGLsizei width, WebGLsizei height, WebGLsizei srcStrideOrZero,
55904:                               WebGLint border,
42916:                               WebGLenum format, WebGLenum type,
55904:                               void *data, PRUint32 byteLength,
55904:                               int srcFormat, PRBool srcPremultiplied)
34454: {
37417:     switch (target) {
37417:         case LOCAL_GL_TEXTURE_2D:
51418:             break;
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
51418:             if (width != height)
51418:                 return ErrorInvalidValue("texImage2D: with cube map targets, width and height must be equal");
37417:             break;
37417:         default:
47813:             return ErrorInvalidEnumInfo("texImage2D: target", target);
34454:     }
37417: 
37417:     switch (internalformat) {
37417:         case LOCAL_GL_RGB:
37417:         case LOCAL_GL_RGBA:
37417:         case LOCAL_GL_ALPHA:
37417:         case LOCAL_GL_LUMINANCE:
37417:         case LOCAL_GL_LUMINANCE_ALPHA:
37417:             break;
37417:         default:
51418:             return ErrorInvalidEnumInfo("texImage2D: internal format", internalformat);
37417:     }
37417: 
51418:     if (format != internalformat)
51418:         return ErrorInvalidOperation("texImage2D: format does not match internalformat");
51418: 
51418:     WebGLsizei maxTextureSize = target == LOCAL_GL_TEXTURE_2D ? mGLMaxTextureSize : mGLMaxCubeMapTextureSize;
51418: 
51418:     if (level < 0)
51418:         return ErrorInvalidValue("texImage2D: level must be >= 0");
51418: 
51418:     if ((1 << level) > maxTextureSize)
51418:         return ErrorInvalidValue("texImage2D: 2^level exceeds maximum texture size");
51418: 
42470:     if (width < 0 || height < 0)
51418:         return ErrorInvalidValue("texImage2D: width and height must be >= 0");
51418: 
51418:     if (width > maxTextureSize || height > maxTextureSize)
51418:         return ErrorInvalidValue("texImage2D: width or height exceeds maximum texture size");
51418: 
51418:     if (level >= 1) {
51422:         if (!(is_pot_assuming_nonnegative(width) &&
51422:               is_pot_assuming_nonnegative(height)))
51418:             return ErrorInvalidValue("texImage2D: with level > 0, width and height must be powers of two");
51418:     }
37417: 
37417:     if (border != 0)
42477:         return ErrorInvalidValue("TexImage2D: border must be 0");
37417: 
46443:     PRUint32 texelSize = 0;
46443:     if (!ValidateTexFormatAndType(format, type, &texelSize, "texImage2D"))
46443:         return NS_OK;
37417: 
55904:     CheckedUint32 checked_plainRowSize = CheckedUint32(width) * texelSize;
55904: 
55904:     PRUint32 unpackAlignment = mPixelStoreUnpackAlignment;
55904: 
55904:     // alignedRowSize = row size rounded up to next multiple of packAlignment
55904:     CheckedUint32 checked_alignedRowSize
55904:         = ((checked_plainRowSize + unpackAlignment-1) / unpackAlignment) * unpackAlignment;
55904: 
55904:     CheckedUint32 checked_neededByteLength
55904:         = (height-1) * checked_alignedRowSize + checked_plainRowSize;
55904: 
55904:     if (!checked_neededByteLength.valid())
47204:         return ErrorInvalidOperation("texImage2D: integer overflow computing the needed buffer size");
47204: 
55904:     PRUint32 bytesNeeded = checked_neededByteLength.value();
37417: 
37417:     if (byteLength && byteLength < bytesNeeded)
47204:         return ErrorInvalidOperation("TexImage2D: not enough data for operation (need %d, have %d)",
42477:                                  bytesNeeded, byteLength);
37417: 
51418:     WebGLTexture *tex = activeBoundTextureForTarget(target);
51418: 
51418:     if (!tex)
51418:         return ErrorInvalidOperation("texImage2D: no texture is bound to this target");
51418: 
51422:     tex->SetImageInfo(target, level, width, height, format, type);
51422: 
37417:     MakeContextCurrent();
37417: 
37417:     if (byteLength) {
55904:         int dstFormat = GetWebGLTexelFormat(format, type);
55904:         int actualSrcFormat = srcFormat == WebGLTexelFormat::Auto ? dstFormat : srcFormat;
55906:         size_t srcStride = srcStrideOrZero ? srcStrideOrZero : checked_alignedRowSize.value();
55906: 
55906:         size_t dstPlainRowSize = texelSize * width;
55906:         size_t unpackAlignment = mPixelStoreUnpackAlignment;
55906:         size_t dstStride = ((dstPlainRowSize + unpackAlignment-1) / unpackAlignment) * unpackAlignment;
55906: 
55906:         if (actualSrcFormat == dstFormat &&
55906:             srcPremultiplied == mPixelStorePremultiplyAlpha &&
55906:             srcStride == dstStride &&
55906:             !mPixelStoreFlipY)
55906:         {
55906:             // no conversion, no flipping, so we avoid copying anything and just pass the source pointer
55906:             gl->fTexImage2D(target, level, internalformat, width, height, border, format, type, data);
55906:         }
55906:         else
55906:         {
55906:             nsAutoArrayPtr<PRUint8> convertedData(new PRUint8[bytesNeeded]);
55906:             ConvertImage(width, height, srcStride, dstStride,
55904:                          (PRUint8*)data, convertedData,
55904:                          actualSrcFormat, srcPremultiplied,
55904:                          dstFormat, mPixelStorePremultiplyAlpha, texelSize);
55904:             gl->fTexImage2D(target, level, internalformat, width, height, border, format, type, convertedData);
55906:         }
37417:     } else {
42476:         // We need some zero pages, because GL doesn't guarantee the
42476:         // contents of a texture allocated with NULL data.
42476:         // Hopefully calloc will just mmap zero pages here.
42476:         void *tempZeroData = calloc(1, bytesNeeded);
42476:         if (!tempZeroData)
42477:             return SynthesizeGLError(LOCAL_GL_OUT_OF_MEMORY, "texImage2D: could not allocate %d bytes (for zero fill)", bytesNeeded);
42476: 
42476:         gl->fTexImage2D(target, level, internalformat, width, height, border, format, type, tempZeroData);
42476: 
42476:         free(tempZeroData);
37417:     }
37417: 
51418:     tex->setDimensions(width, height);
42473: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
42916: WebGLContext::TexImage2D_buf(WebGLenum target, WebGLint level, WebGLenum internalformat,
42916:                              WebGLsizei width, WebGLsizei height, WebGLint border,
42916:                              WebGLenum format, WebGLenum type,
37417:                              js::ArrayBuffer *pixels)
37417: {
55904:     return TexImage2D_base(target, level, internalformat, width, height, 0, border, format, type,
37417:                            pixels ? pixels->data : 0,
55904:                            pixels ? pixels->byteLength : 0,
55904:                            WebGLTexelFormat::Auto, PR_FALSE);
37417: }
37417: 
37417: NS_IMETHODIMP
42916: WebGLContext::TexImage2D_array(WebGLenum target, WebGLint level, WebGLenum internalformat,
42916:                                WebGLsizei width, WebGLsizei height, WebGLint border,
42916:                                WebGLenum format, WebGLenum type,
37417:                                js::TypedArray *pixels)
37417: {
55904:     return TexImage2D_base(target, level, internalformat, width, height, 0, border, format, type,
37417:                            pixels ? pixels->data : 0,
55904:                            pixels ? pixels->byteLength : 0,
55904:                            WebGLTexelFormat::Auto, PR_FALSE);
55904: }
55904: 
55904: NS_IMETHODIMP
55904: WebGLContext::TexImage2D_imageData(WebGLenum target, WebGLint level, WebGLenum internalformat,
55904:                                WebGLsizei width, WebGLsizei height, WebGLint border,
55904:                                WebGLenum format, WebGLenum type,
55904:                                js::TypedArray *pixels)
55904: {
55904:     return TexImage2D_base(target, level, internalformat, width, height, 4*width, border, format, type,
55904:                            pixels ? pixels->data : 0,
55904:                            pixels ? pixels->byteLength : 0,
55904:                            WebGLTexelFormat::RGBA8, PR_FALSE);
37417: }
37417: 
37417: NS_IMETHODIMP
43638: WebGLContext::TexImage2D_dom(WebGLenum target, WebGLint level, WebGLenum internalformat,
43638:                              WebGLenum format, GLenum type, nsIDOMElement *elt)
37417: {
34454:     nsRefPtr<gfxImageSurface> isurf;
34454: 
55904:     int srcFormat;
55904:     nsresult rv = DOMElementToImageSurface(elt, getter_AddRefs(isurf), &srcFormat);
43638:     if (NS_FAILED(rv))
43638:         return rv;
43638: 
43638:     PRUint32 byteLength = isurf->Stride() * isurf->Height();
43638: 
43638:     return TexImage2D_base(target, level, internalformat,
55904:                            isurf->Width(), isurf->Height(), isurf->Stride(), 0,
43638:                            format, type,
55904:                            isurf->Data(), byteLength,
55904:                            srcFormat, PR_TRUE);
43638: }
43638: 
43638: NS_IMETHODIMP
37417: WebGLContext::TexSubImage2D(PRInt32 dummy)
32195: {
37417:     return NS_ERROR_FAILURE;
32195: }
32195: 
37417: nsresult
42916: WebGLContext::TexSubImage2D_base(WebGLenum target, WebGLint level,
42916:                                  WebGLint xoffset, WebGLint yoffset,
55904:                                  WebGLsizei width, WebGLsizei height, WebGLsizei srcStrideOrZero,
42916:                                  WebGLenum format, WebGLenum type,
55904:                                  void *pixels, PRUint32 byteLength,
55904:                                  int srcFormat, PRBool srcPremultiplied)
37417: {
37417:     switch (target) {
32195:         case LOCAL_GL_TEXTURE_2D:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
32195:             break;
32195:         default:
47813:             return ErrorInvalidEnumInfo("texSubImage2D: target", target);
32195:     }
32195: 
51418:     WebGLsizei maxTextureSize = target == LOCAL_GL_TEXTURE_2D ? mGLMaxTextureSize : mGLMaxCubeMapTextureSize;
51418: 
37417:     if (level < 0)
51418:         return ErrorInvalidValue("texSubImage2D: level must be >= 0");
51418: 
51418:     if ((1 << level) > maxTextureSize)
51418:         return ErrorInvalidValue("texSubImage2D: 2^level exceeds maximum texture size");
42477: 
42477:     if (width < 0 || height < 0)
51418:         return ErrorInvalidValue("texSubImage2D: width and height must be >= 0");
51418: 
51418:     if (width > maxTextureSize || height > maxTextureSize)
51418:         return ErrorInvalidValue("texSubImage2D: width or height exceeds maximum texture size");
51418: 
51418:     if (level >= 1) {
51422:         if (!(is_pot_assuming_nonnegative(width) &&
51422:               is_pot_assuming_nonnegative(height)))
51418:             return ErrorInvalidValue("texSubImage2D: with level > 0, width and height must be powers of two");
51418:     }
42477: 
46443:     PRUint32 texelSize = 0;
46443:     if (!ValidateTexFormatAndType(format, type, &texelSize, "texSubImage2D"))
46443:         return NS_OK;
46443: 
42477:     if (width == 0 || height == 0)
42477:         return NS_OK; // ES 2.0 says it has no effect, we better return right now
37417: 
55904:     CheckedUint32 checked_plainRowSize = CheckedUint32(width) * texelSize;
55904: 
55904:     PRUint32 unpackAlignment = mPixelStoreUnpackAlignment;
55904: 
55904:     // alignedRowSize = row size rounded up to next multiple of packAlignment
55904:     CheckedUint32 checked_alignedRowSize
55904:         = ((checked_plainRowSize + unpackAlignment-1) / unpackAlignment) * unpackAlignment;
55904: 
55904:     CheckedUint32 checked_neededByteLength
55904:         = (height-1) * checked_alignedRowSize + checked_plainRowSize;
55904: 
55904:     if (!checked_neededByteLength.valid())
47204:         return ErrorInvalidOperation("texSubImage2D: integer overflow computing the needed buffer size");
47204: 
55904:     PRUint32 bytesNeeded = checked_neededByteLength.value();
47204:  
37417:     if (byteLength < bytesNeeded)
51418:         return ErrorInvalidValue("texSubImage2D: not enough data for operation (need %d, have %d)", bytesNeeded, byteLength);
51418: 
51418:     WebGLTexture *tex = activeBoundTextureForTarget(target);
51418: 
51418:     if (!tex)
51418:         return ErrorInvalidOperation("texSubImage2D: no texture is bound to this target");
51418: 
51418:     if (!CanvasUtils::CheckSaneSubrectSize(xoffset, yoffset, width, height, tex->width(), tex->height()))
51418:         return ErrorInvalidValue("texSubImage2D: subtexture rectangle out of bounds");
35422: 
55904: 
32195:     MakeContextCurrent();
37417: 
55904:     int dstFormat = GetWebGLTexelFormat(format, type);
55904:     int actualSrcFormat = srcFormat == WebGLTexelFormat::Auto ? dstFormat : srcFormat;
55906:     size_t srcStride = srcStrideOrZero ? srcStrideOrZero : checked_alignedRowSize.value();
55906: 
55906:     size_t dstPlainRowSize = texelSize * width;
55906:     size_t dstStride = ((dstPlainRowSize + unpackAlignment-1) / unpackAlignment) * unpackAlignment;
55906: 
55906:     if (actualSrcFormat == dstFormat &&
55906:         srcPremultiplied == mPixelStorePremultiplyAlpha &&
55906:         srcStride == dstStride &&
55906:         !mPixelStoreFlipY)
55906:     {
55906:         // no conversion, no flipping, so we avoid copying anything and just pass the source pointer
55906:         gl->fTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
55906:     }
55906:     else
55906:     {
55906:         nsAutoArrayPtr<PRUint8> convertedData(new PRUint8[bytesNeeded]);
55906:         ConvertImage(width, height, srcStride, dstStride,
55906:                     (const PRUint8*)pixels, convertedData,
55904:                     actualSrcFormat, srcPremultiplied,
55904:                     dstFormat, mPixelStorePremultiplyAlpha, texelSize);
55904: 
55904:         gl->fTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, convertedData);
55906:     }
37417: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
42916: WebGLContext::TexSubImage2D_buf(WebGLenum target, WebGLint level,
42916:                                 WebGLint xoffset, WebGLint yoffset,
42916:                                 WebGLsizei width, WebGLsizei height,
42916:                                 WebGLenum format, WebGLenum type,
37417:                                 js::ArrayBuffer *pixels)
32195: {
37417:     if (!pixels)
42477:         return ErrorInvalidValue("TexSubImage2D: pixels must not be null!");
37417: 
37417:     return TexSubImage2D_base(target, level, xoffset, yoffset,
55904:                               width, height, 0, format, type,
55904:                               pixels->data, pixels->byteLength,
55904:                               WebGLTexelFormat::Auto, PR_FALSE);
32195: }
32195: 
37417: NS_IMETHODIMP
42916: WebGLContext::TexSubImage2D_array(WebGLenum target, WebGLint level,
42916:                                   WebGLint xoffset, WebGLint yoffset,
42916:                                   WebGLsizei width, WebGLsizei height,
42916:                                   WebGLenum format, WebGLenum type,
37417:                                   js::TypedArray *pixels)
32195: {
37417:     if (!pixels)
42477:         return ErrorInvalidValue("TexSubImage2D: pixels must not be null!");
37417: 
37417:     return TexSubImage2D_base(target, level, xoffset, yoffset,
55904:                               width, height, 0, format, type,
55904:                               pixels->data, pixels->byteLength,
55904:                               WebGLTexelFormat::Auto, PR_FALSE);
55904: }
55904: 
55904: NS_IMETHODIMP
55904: WebGLContext::TexSubImage2D_imageData(WebGLenum target, WebGLint level,
55904:                                       WebGLint xoffset, WebGLint yoffset,
55904:                                       WebGLsizei width, WebGLsizei height,
55904:                                       WebGLenum format, WebGLenum type,
55904:                                       js::TypedArray *pixels)
55904: {
55904:     if (!pixels)
55904:         return ErrorInvalidValue("TexSubImage2D: pixels must not be null!");
55904: 
55904:     return TexSubImage2D_base(target, level, xoffset, yoffset,
55904:                               width, height, 4*width, format, type,
55904:                               pixels->data, pixels->byteLength,
55904:                               WebGLTexelFormat::RGBA8, PR_FALSE);
32195: }
37417: 
37417: NS_IMETHODIMP
42916: WebGLContext::TexSubImage2D_dom(WebGLenum target, WebGLint level,
42916:                                 WebGLint xoffset, WebGLint yoffset,
43638:                                 WebGLenum format, WebGLenum type,
43638:                                 nsIDOMElement *elt)
37417: {
32195:     nsRefPtr<gfxImageSurface> isurf;
32195: 
55904:     int srcFormat;
55904:     nsresult rv = DOMElementToImageSurface(elt, getter_AddRefs(isurf), &srcFormat);
32195:     if (NS_FAILED(rv))
37417:         return rv;
37417: 
43638:     PRUint32 byteLength = isurf->Stride() * isurf->Height();
43638: 
37417:     return TexSubImage2D_base(target, level,
37417:                               xoffset, yoffset,
55904:                               isurf->Width(), isurf->Height(), isurf->Stride(),
55904:                               format, type,
55904:                               isurf->Data(), byteLength,
55904:                               srcFormat, PR_TRUE);
32195: }
32195: 
32195: #if 0
32195: // ImageData getImageData (in float x, in float y, in float width, in float height);
32195: NS_IMETHODIMP
32195: WebGLContext::GetImageData(PRUint32 x, PRUint32 y, PRUint32 w, PRUint32 h)
32195: {
32195:     // disabled due to win32 linkage issues with thebes symbols and NS_RELEASE
32195:     return NS_ERROR_FAILURE;
32195: 
32195: #if 0
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     if (js.argc != 4) return NS_ERROR_INVALID_ARG;
32195:     
32195:     if (!mGLPbuffer ||
32195:         !mGLPbuffer->ThebesSurface())
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (!mCanvasElement)
32195:         return NS_ERROR_FAILURE;
32195: 
43655:     if (HTMLCanvasElement()->IsWriteOnly() && !IsCallerTrustedForRead()) {
32195:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
32195:         return NS_ERROR_DOM_SECURITY_ERR;
32195:     }
32195: 
32195:     JSContext *ctx = js.ctx;
32195: 
32195:     if (!CanvasUtils::CheckSaneSubrectSize (x, y, w, h, mWidth, mHeight))
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195: 
32195:     nsAutoArrayPtr<PRUint8> surfaceData (new (std::nothrow) PRUint8[w * h * 4]);
32195:     int surfaceDataStride = w*4;
32195:     int surfaceDataOffset = 0;
32195: 
32195:     if (!surfaceData)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     nsRefPtr<gfxImageSurface> tmpsurf = new gfxImageSurface(surfaceData,
32195:                                                             gfxIntSize(w, h),
32195:                                                             w * 4,
32195:                                                             gfxASurface::ImageFormatARGB32);
32195:     if (!tmpsurf || tmpsurf->CairoStatus())
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     nsRefPtr<gfxContext> tmpctx = new gfxContext(tmpsurf);
32195: 
32195:     if (!tmpctx || tmpctx->HasError())
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
32195:     nsRefPtr<gfxPattern> pat = CanvasGLThebes::CreatePattern(surf);
32195:     gfxMatrix m;
32195:     m.Translate(gfxPoint(x, mGLPbuffer->Height()-y));
32195:     m.Scale(1.0, -1.0);
32195:     pat->SetMatrix(m);
32195: 
32195:     // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
32195:     // pixel alignment for this stuff!
32195:     tmpctx->NewPath();
32195:     tmpctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, w, h), pat);
32195:     tmpctx->SetOperator(gfxContext::OPERATOR_SOURCE);
32195:     tmpctx->Fill();
32195: 
32195:     tmpctx = nsnull;
32195:     tmpsurf = nsnull;
32195: 
32195:     PRUint32 len = w * h * 4;
32195:     if (len > (((PRUint32)0xfff00000)/sizeof(jsval)))
32195:         return NS_ERROR_INVALID_ARG;
32195: 
32195:     nsAutoArrayPtr<jsval> jsvector(new (std::nothrow) jsval[w * h * 4]);
32195:     if (!jsvector)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195:     jsval *dest = jsvector.get();
32195:     PRUint8 *row;
32195:     for (PRUint32 j = 0; j < h; j++) {
32195:         row = surfaceData + surfaceDataOffset + (surfaceDataStride * j);
32195:         for (PRUint32 i = 0; i < w; i++) {
32195:             // XXX Is there some useful swizzle MMX we can use here?
32195:             // I guess we have to INT_TO_JSVAL still
32195: #ifdef IS_LITTLE_ENDIAN
32195:             PRUint8 b = *row++;
32195:             PRUint8 g = *row++;
32195:             PRUint8 r = *row++;
32195:             PRUint8 a = *row++;
32195: #else
32195:             PRUint8 a = *row++;
32195:             PRUint8 r = *row++;
32195:             PRUint8 g = *row++;
32195:             PRUint8 b = *row++;
32195: #endif
32195:             // Convert to non-premultiplied color
32195:             if (a != 0) {
32195:                 r = (r * 255) / a;
32195:                 g = (g * 255) / a;
32195:                 b = (b * 255) / a;
32195:             }
32195: 
32195:             *dest++ = INT_TO_JSVAL(r);
32195:             *dest++ = INT_TO_JSVAL(g);
32195:             *dest++ = INT_TO_JSVAL(b);
32195:             *dest++ = INT_TO_JSVAL(a);
32195:         }
32195:     }
32195: 
32195:     JSObject *dataArray = JS_NewArrayObject(ctx, w*h*4, jsvector);
32195:     if (!dataArray)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     JSObjectHelper retobj(&js);
32195:     retobj.DefineProperty("width", w);
32195:     retobj.DefineProperty("height", h);
32195:     retobj.DefineProperty("data", dataArray);
32195: 
32195:     js.SetRetVal(retobj);
32195: 
32195:     return NS_OK;
32195: #endif
32195: }
32195: #endif
32195: 
32195: PRBool
42916: BaseTypeAndSizeFromUniformType(WebGLenum uType, WebGLenum *baseType, WebGLint *unitSize)
32195: {
32195:     switch (uType) {
32195:         case LOCAL_GL_INT:
32195:         case LOCAL_GL_INT_VEC2:
32195:         case LOCAL_GL_INT_VEC3:
32195:         case LOCAL_GL_INT_VEC4:
32195:         case LOCAL_GL_SAMPLER_2D:
32195:         case LOCAL_GL_SAMPLER_CUBE:
32195:             *baseType = LOCAL_GL_INT;
32195:             break;
32195:         case LOCAL_GL_FLOAT:
32195:         case LOCAL_GL_FLOAT_VEC2:
32195:         case LOCAL_GL_FLOAT_VEC3:
32195:         case LOCAL_GL_FLOAT_VEC4:
32195:         case LOCAL_GL_FLOAT_MAT2:
32195:         case LOCAL_GL_FLOAT_MAT3:
32195:         case LOCAL_GL_FLOAT_MAT4:
32195:             *baseType = LOCAL_GL_FLOAT;
32195:             break;
32195:         case LOCAL_GL_BOOL:
32195:         case LOCAL_GL_BOOL_VEC2:
32195:         case LOCAL_GL_BOOL_VEC3:
32195:         case LOCAL_GL_BOOL_VEC4:
43852:             *baseType = LOCAL_GL_BOOL; // pretend these are int
32195:             break;
32195:         default:
32195:             return PR_FALSE;
32195:     }
32195: 
32195:     switch (uType) {
32195:         case LOCAL_GL_INT:
32195:         case LOCAL_GL_FLOAT:
32195:         case LOCAL_GL_BOOL:
32195:         case LOCAL_GL_SAMPLER_2D:
32195:         case LOCAL_GL_SAMPLER_CUBE:
32195:             *unitSize = 1;
32195:             break;
32195:         case LOCAL_GL_INT_VEC2:
32195:         case LOCAL_GL_FLOAT_VEC2:
32195:         case LOCAL_GL_BOOL_VEC2:
32195:             *unitSize = 2;
32195:             break;
32195:         case LOCAL_GL_INT_VEC3:
32195:         case LOCAL_GL_FLOAT_VEC3:
32195:         case LOCAL_GL_BOOL_VEC3:
32195:             *unitSize = 3;
32195:             break;
32195:         case LOCAL_GL_INT_VEC4:
32195:         case LOCAL_GL_FLOAT_VEC4:
32195:         case LOCAL_GL_BOOL_VEC4:
32195:             *unitSize = 4;
32195:             break;
32195:         case LOCAL_GL_FLOAT_MAT2:
32195:             *unitSize = 4;
32195:             break;
32195:         case LOCAL_GL_FLOAT_MAT3:
32195:             *unitSize = 9;
32195:             break;
32195:         case LOCAL_GL_FLOAT_MAT4:
32195:             *unitSize = 16;
32195:             break;
32195:         default:
32195:             return PR_FALSE;
32195:     }
32195: 
32195:     return PR_TRUE;
32195: }
55904: 
55904: 
55904: int mozilla::GetWebGLTexelFormat(GLenum format, GLenum type)
55904: {
55904:     if (type == LOCAL_GL_UNSIGNED_BYTE)
55904:     {
55904:         switch (format) {
55904:             case LOCAL_GL_RGBA:
55904:                 return WebGLTexelFormat::RGBA8;
55904:             case LOCAL_GL_RGB:
55904:                 return WebGLTexelFormat::RGB8;
55904:             case LOCAL_GL_ALPHA:
55904:                 return WebGLTexelFormat::A8;
55904:             case LOCAL_GL_LUMINANCE:
55904:                 return WebGLTexelFormat::R8;
55904:             case LOCAL_GL_LUMINANCE_ALPHA:
55904:                 return WebGLTexelFormat::RA8;
55904:             default:
55904:                 NS_ASSERTION(PR_FALSE, "Coding mistake?! Should never reach this point.");
55904:                 return WebGLTexelFormat::Generic;
55904:         }
55904:     } else {
55904:         switch (type) {
55904:             case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
55904:                 return WebGLTexelFormat::RGBA4444;
55904:             case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
55904:                 return WebGLTexelFormat::RGBA5551;
55904:             case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
55904:                 return WebGLTexelFormat::RGB565;
55904:             default:
55904:                 NS_ASSERTION(PR_FALSE, "Coding mistake?! Should never reach this point.");
55904:                 return WebGLTexelFormat::Generic;
55904:         }
55904:     }
55904: }
