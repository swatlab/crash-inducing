    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* A namespace class for static content utilities. */
    1: 
    1: #ifndef nsContentUtils_h___
    1: #define nsContentUtils_h___
    1: 
30023: #include "jsprvtd.h"
14038: #include "jsnum.h"
    1: #include "nsAString.h"
    1: #include "nsIStatefulFrame.h"
34185: #include "nsIPref.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentList.h"
    1: #include "nsDOMClassInfoID.h"
    1: #include "nsIClassInfo.h"
    1: #include "nsIDOM3Node.h"
  265: #include "nsDataHashtable.h"
    1: #include "nsIScriptRuntime.h"
    1: #include "nsIScriptGlobalObject.h"
 9377: #include "nsIDOMEvent.h"
14328: #include "nsTArray.h"
15634: #include "nsTextFragment.h"
22874: #include "nsReadableUtils.h"
 9377: 
 9377: struct nsNativeKeyEvent; // Don't include nsINativeKeyBindings.h here: it will force strange compilation error!
    1: 
    1: class nsIDOMScriptObjectFactory;
    1: class nsIXPConnect;
    1: class nsINode;
    1: class nsIContent;
    1: class nsIDOMNode;
19283: class nsIDOMKeyEvent;
    1: class nsIDocument;
34394: class nsIDocumentObserver;
    1: class nsIDocShell;
    1: class nsINameSpaceManager;
    1: class nsIScriptSecurityManager;
    1: class nsIJSContextStack;
    1: class nsIThreadJSContextStack;
    1: class nsIParserService;
    1: class nsIIOService;
    1: class nsIURI;
30479: class imgIContainer;
    1: class imgIDecoderObserver;
    1: class imgIRequest;
    1: class imgILoader;
30065: class imgICache;
    1: class nsIPrefBranch;
    1: class nsIImageLoadingContent;
    1: class nsIDOMHTMLFormElement;
    1: class nsIDOMDocument;
    1: class nsIConsoleService;
    1: class nsIStringBundleService;
    1: class nsIStringBundle;
    1: class nsIContentPolicy;
    1: class nsILineBreaker;
    1: class nsIWordBreaker;
    1: class nsIJSRuntimeService;
    1: class nsIEventListenerManager;
    1: class nsIScriptContext;
13098: class nsIRunnable;
18942: class nsIInterfaceRequestor;
    1: template<class E> class nsCOMArray;
34185: class nsIPref;
    1: struct JSRuntime;
 3049: class nsICaseConversion;
15634: class nsIUGenCategory;
 8092: class nsIWidget;
18445: class nsIDragSession;
12313: class nsPIDOMWindow;
20135: class nsPIDOMEventTarget;
29844: class nsIPresShell;
31981: class nsIXPConnectJSObjectHolder;
    1: #ifdef MOZ_XTF
    1: class nsIXTFService;
    1: #endif
    1: #ifdef IBMBIDI
    1: class nsIBidiKeyboard;
    1: #endif
22874: class nsIMIMEHeaderParam;
    1: 
    1: extern const char kLoadAsData[];
    1: 
  265: enum EventNameType {
  265:   EventNameType_None = 0x0000,
  265:   EventNameType_HTML = 0x0001,
  265:   EventNameType_XUL = 0x0002,
  265:   EventNameType_SVGGraphic = 0x0004, // svg graphic elements
  265:   EventNameType_SVGSVG = 0x0008, // the svg element
  265: 
  265:   EventNameType_HTMLXUL = 0x0003,
  265:   EventNameType_All = 0xFFFF
  265: };
  265: 
  265: struct EventNameMapping {
  265:   PRUint32  mId;
  265:   PRInt32 mType;
  265: };
  265: 
14328: struct nsShortcutCandidate {
14328:   nsShortcutCandidate(PRUint32 aCharCode, PRBool aIgnoreShift) :
14328:     mCharCode(aCharCode), mIgnoreShift(aIgnoreShift)
14328:   {
14328:   }
14328:   PRUint32 mCharCode;
14328:   PRBool   mIgnoreShift;
14328: };
14328: 
    1: class nsContentUtils
    1: {
    1: public:
    1:   static nsresult Init();
    1: 
    1:   // You MUST pass the old ownerDocument of aContent in as aOldDocument and the
    1:   // new one as aNewDocument.  aNewParent is allowed to be null; in that case
    1:   // aNewDocument will be assumed to be the parent.  Note that at this point
    1:   // the actual ownerDocument of aContent may not yet be aNewDocument.
    1:   // XXXbz but then if it gets wrapped after we do this call but before its
    1:   // ownerDocument actually changes, things will break...
    1:   static nsresult ReparentContentWrapper(nsIContent *aNode,
    1:                                          nsIContent *aNewParent,
    1:                                          nsIDocument *aNewDocument,
    1:                                          nsIDocument *aOldDocument);
    1: 
    1:   /**
    1:    * Get a scope from aOldDocument and one from aNewDocument. Also get a
    1:    * context through one of the scopes, from the stack or the safe context.
    1:    *
    1:    * @param aOldDocument The document to get aOldScope from.
    1:    * @param aNewDocument The document to get aNewScope from.
    1:    * @param aCx [out] Context gotten through one of the scopes, from the stack
    1:    *                  or the safe context.
    1:    * @param aOldScope [out] Scope gotten from aOldDocument.
    1:    * @param aNewScope [out] Scope gotten from aNewDocument.
    1:    */
    1:   static nsresult GetContextAndScopes(nsIDocument *aOldDocument,
    1:                                       nsIDocument *aNewDocument,
    1:                                       JSContext **aCx, JSObject **aOldScope,
    1:                                       JSObject **aNewScope);
    1: 
    1:   /**
    1:    * When a document's scope changes (e.g., from document.open(), call this
    1:    * function to move all content wrappers from the old scope to the new one.
    1:    */
    1:   static nsresult ReparentContentWrappersInScope(nsIScriptGlobalObject *aOldScope,
    1:                                                  nsIScriptGlobalObject *aNewScope);
    1: 
    1:   static PRBool   IsCallerChrome();
    1: 
    1:   static PRBool   IsCallerTrustedForRead();
    1: 
    1:   static PRBool   IsCallerTrustedForWrite();
    1: 
    1:   /**
 8008:    * Check whether a caller is trusted to have aCapability.  This also
 8008:    * checks for UniversalXPConnect in addition to aCapability.
 8008:    */
 8008:   static PRBool   IsCallerTrustedForCapability(const char* aCapability);
 8008: 
 8008:   /**
    1:    * Do not ever pass null pointers to this method.  If one of your
    1:    * nsIContents is null, you have to decide for yourself what
    1:    * "IsDescendantOf" really means.
    1:    *
    1:    * @param  aPossibleDescendant node to test for being a descendant of
    1:    *         aPossibleAncestor
    1:    * @param  aPossibleAncestor node to test for being an ancestor of
    1:    *         aPossibleDescendant
    1:    * @return PR_TRUE if aPossibleDescendant is a descendant of
    1:    *         aPossibleAncestor (or is aPossibleAncestor).  PR_FALSE
    1:    *         otherwise.
    1:    */
    1:   static PRBool ContentIsDescendantOf(nsINode* aPossibleDescendant,
    1:                                       nsINode* aPossibleAncestor);
    1: 
32033:   /**
32033:    * Similar to ContentIsDescendantOf except it crosses document boundaries.
32033:    */
32033:   static PRBool ContentIsCrossDocDescendantOf(nsINode* aPossibleDescendant,
32033:                                               nsINode* aPossibleAncestor);
32033: 
    1:   /*
    1:    * This method fills the |aArray| with all ancestor nodes of |aNode|
    1:    * including |aNode| at the zero index.
    1:    */
    1:   static nsresult GetAncestors(nsIDOMNode* aNode,
26413:                                nsTArray<nsIDOMNode*>* aArray);
    1: 
    1:   /*
    1:    * This method fills |aAncestorNodes| with all ancestor nodes of |aNode|
    1:    * including |aNode| (QI'd to nsIContent) at the zero index.
    1:    * For each ancestor, there is a corresponding element in |aAncestorOffsets|
    1:    * which is the IndexOf the child in relation to its parent.
    1:    *
    1:    * This method just sucks.
    1:    */
    1:   static nsresult GetAncestorsAndOffsets(nsIDOMNode* aNode,
    1:                                          PRInt32 aOffset,
26413:                                          nsTArray<nsIContent*>* aAncestorNodes,
26413:                                          nsTArray<PRInt32>* aAncestorOffsets);
    1: 
    1:   /*
    1:    * The out parameter, |aCommonAncestor| will be the closest node, if any,
    1:    * to both |aNode| and |aOther| which is also an ancestor of each.
    1:    * Returns an error if the two nodes are disconnected and don't have
    1:    * a common ancestor.
    1:    */
    1:   static nsresult GetCommonAncestor(nsIDOMNode *aNode,
    1:                                     nsIDOMNode *aOther,
    1:                                     nsIDOMNode** aCommonAncestor);
    1: 
    1:   /**
    1:    * Returns the common ancestor, if any, for two nodes. Returns null if the
    1:    * nodes are disconnected.
    1:    */
    1:   static nsINode* GetCommonAncestor(nsINode* aNode1,
    1:                                     nsINode* aNode2);
    1: 
    1:   /**
    1:    * Compares the document position of nodes.
    1:    *
    1:    * @param aNode1 The node whose position is being compared to the reference
    1:    *               node
    1:    * @param aNode2 The reference node
    1:    *
    1:    * @return  The document position flags of the nodes. aNode1 is compared to
    1:    *          aNode2, i.e. if aNode1 is before aNode2 then
    1:    *          DOCUMENT_POSITION_PRECEDING will be set.
    1:    *
    1:    * @see nsIDOMNode
    1:    * @see nsIDOM3Node
    1:    */
    1:   static PRUint16 ComparePosition(nsINode* aNode1,
    1:                                   nsINode* aNode2);
    1: 
    1:   /**
    1:    * Returns true if aNode1 is before aNode2 in the same connected
    1:    * tree.
    1:    */
    1:   static PRBool PositionIsBefore(nsINode* aNode1,
    1:                                  nsINode* aNode2)
    1:   {
    1:     return (ComparePosition(aNode1, aNode2) &
    1:       (nsIDOM3Node::DOCUMENT_POSITION_PRECEDING |
    1:        nsIDOM3Node::DOCUMENT_POSITION_DISCONNECTED)) ==
    1:       nsIDOM3Node::DOCUMENT_POSITION_PRECEDING;
    1:   }
    1: 
    1:   /**
    1:    *  Utility routine to compare two "points", where a point is a
    1:    *  node/offset pair
    1:    *  Returns -1 if point1 < point2, 1, if point1 > point2,
    1:    *  0 if error or if point1 == point2.
12178:    *  NOTE! If the two nodes aren't in the same connected subtree,
12178:    *  the result is undefined, but the optional aDisconnected parameter
12178:    *  is set to PR_TRUE.
    1:    */
    1:   static PRInt32 ComparePoints(nsINode* aParent1, PRInt32 aOffset1,
12178:                                nsINode* aParent2, PRInt32 aOffset2,
12178:                                PRBool* aDisconnected = nsnull);
    1: 
    1:   /**
    1:    * Find the first child of aParent with a resolved tag matching
    1:    * aNamespace and aTag. Both the explicit and anonymous children of
    1:    * aParent are examined. The return value is not addrefed.
    1:    *
    1:    * XXXndeakin this should return the first child whether in anonymous or
    1:    * explicit children, but currently XBL doesn't tell us the relative
    1:    * ordering of anonymous vs explicit children, so instead it searches
    1:    * the explicit children first then the anonymous children.
    1:    */
    1:   static nsIContent* FindFirstChildWithResolvedTag(nsIContent* aParent,
    1:                                                    PRInt32 aNamespace,
    1:                                                    nsIAtom* aTag);
    1: 
    1:   /**
    1:    * Brute-force search of the element subtree rooted at aContent for
    1:    * an element with the given id.  aId must be nonempty, otherwise
    1:    * this method may return nodes even if they have no id!
    1:    */
    1:   static nsIContent* MatchElementId(nsIContent *aContent,
    1:                                     const nsAString& aId);
    1: 
    1:   /**
    1:    * Similar to above, but to be used if one already has an atom for the ID
    1:    */
    1:   static nsIContent* MatchElementId(nsIContent *aContent,
    1:                                     nsIAtom* aId);
    1: 
    1:   /**
    1:    * Given a URI containing an element reference (#whatever),
    1:    * resolve it to the target content element with the given ID.
    1:    *
    1:    * If aFromContent is anonymous XBL content then the URI
    1:    * must refer to its binding document and we will return
    1:    * a node in the same anonymous content subtree as aFromContent,
    1:    * if one exists with the correct ID.
    1:    *
    1:    * @param aFromContent the context of the reference;
    1:    *   currently we only support references to elements in the
    1:    *   same document as the context, so this must be non-null
    1:    *
    1:    * @return the element, or nsnull on failure
    1:    */
    1:   static nsIContent* GetReferencedElement(nsIURI* aURI,
    1:                                           nsIContent *aFromContent);
    1: 
    1:   /**
    1:    * Reverses the document position flags passed in.
    1:    *
    1:    * @param   aDocumentPosition   The document position flags to be reversed.
    1:    *
    1:    * @return  The reversed document position flags.
    1:    *
    1:    * @see nsIDOMNode
    1:    * @see nsIDOM3Node
    1:    */
    1:   static PRUint16 ReverseDocumentPosition(PRUint16 aDocumentPosition);
    1: 
    1:   static PRUint32 CopyNewlineNormalizedUnicodeTo(const nsAString& aSource,
    1:                                                  PRUint32 aSrcOffset,
    1:                                                  PRUnichar* aDest,
    1:                                                  PRUint32 aLength,
    1:                                                  PRBool& aLastCharCR);
    1: 
    1:   static PRUint32 CopyNewlineNormalizedUnicodeTo(nsReadingIterator<PRUnichar>& aSrcStart, const nsReadingIterator<PRUnichar>& aSrcEnd, nsAString& aDest);
    1: 
    1:   static nsISupports *
    1:   GetClassInfoInstance(nsDOMClassInfoID aID);
    1: 
    1:   static const nsDependentSubstring TrimCharsInSet(const char* aSet,
    1:                                                    const nsAString& aValue);
    1: 
    1:   static const nsDependentSubstring TrimWhitespace(const nsAString& aStr,
    1:                                                    PRBool aTrimTrailing = PR_TRUE);
    1: 
 7832:   /**
15634:    * Returns true if aChar is of class Ps, Pi, Po, Pf, or Pe.
 7832:    */
15634:   static PRBool IsPunctuationMark(PRUint32 aChar);
15634:   static PRBool IsPunctuationMarkAt(const nsTextFragment* aFrag, PRUint32 aOffset);
15634:  
15634:   /**
15634:    * Returns true if aChar is of class Lu, Ll, Lt, Lm, Lo, Nd, Nl or No
15634:    */
15634:   static PRBool IsAlphanumeric(PRUint32 aChar);
15634:   static PRBool IsAlphanumericAt(const nsTextFragment* aFrag, PRUint32 aOffset);
 7832: 
15303:   /*
15303:    * Is the character an HTML whitespace character?
15303:    *
15303:    * We define whitespace using the list in HTML5 and css3-selectors:
15303:    * U+0009, U+000A, U+000C, U+000D, U+0020
15303:    *
15303:    * HTML 4.01 also lists U+200B (zero-width space).
15303:    */
15303:   static PRBool IsHTMLWhitespace(PRUnichar aChar);
15303: 
    1:   static void Shutdown();
    1: 
    1:   /**
    1:    * Checks whether two nodes come from the same origin. aTrustedNode is
    1:    * considered 'safe' in that a user can operate on it and that it isn't
    1:    * a js-object that implements nsIDOMNode.
    1:    * Never call this function with the first node provided by script, it
    1:    * must always be known to be a 'real' node!
    1:    */
    1:   static nsresult CheckSameOrigin(nsIDOMNode* aTrustedNode,
    1:                                   nsIDOMNode* aUnTrustedNode);
    1: 
    1:   // Check if the (JS) caller can access aNode.
    1:   static PRBool CanCallerAccess(nsIDOMNode *aNode);
    1: 
12313:   // Check if the (JS) caller can access aWindow.
12313:   // aWindow can be either outer or inner window.
12313:   static PRBool CanCallerAccess(nsPIDOMWindow* aWindow);
12313: 
    1:   /**
    1:    * Get the docshell through the JS context that's currently on the stack.
    1:    * If there's no JS context currently on the stack aDocShell will be null.
    1:    *
    1:    * @param aDocShell The docshell or null if no JS context
    1:    */
    1:   static nsIDocShell *GetDocShellFromCaller();
    1: 
    1:   /**
    1:    * The two GetDocumentFrom* functions below allow a caller to get at a
    1:    * document that is relevant to the currently executing script.
    1:    *
    1:    * GetDocumentFromCaller gets its document by looking at the last called
    1:    * function and finding the document that the function itself relates to.
    1:    * For example, consider two windows A and B in the same origin. B has a
    1:    * function which does something that ends up needing the current document.
    1:    * If a script in window A were to call B's function, GetDocumentFromCaller
    1:    * would find that function (in B) and return B's document.
    1:    *
    1:    * GetDocumentFromContext gets its document by looking at the currently
    1:    * executing context's global object and returning its document. Thus,
    1:    * given the example above, GetDocumentFromCaller would see that the
    1:    * currently executing script was in window A, and return A's document.
    1:    */
    1:   /**
    1:    * Get the document from the currently executing function. This will return
    1:    * the document that the currently executing function is in/from.
    1:    *
    1:    * @return The document or null if no JS Context.
    1:    */
    1:   static nsIDOMDocument *GetDocumentFromCaller();
    1: 
    1:   /**
    1:    * Get the document through the JS context that's currently on the stack.
    1:    * If there's no JS context currently on the stack it will return null.
    1:    * This will return the document of the calling script.
    1:    *
    1:    * @return The document or null if no JS context
    1:    */
    1:   static nsIDOMDocument *GetDocumentFromContext();
    1: 
    1:   // Check if a node is in the document prolog, i.e. before the document
    1:   // element.
    1:   static PRBool InProlog(nsINode *aNode);
    1: 
    1:   static nsIParserService* GetParserService();
    1: 
    1:   static nsINameSpaceManager* NameSpaceManager()
    1:   {
    1:     return sNameSpaceManager;
    1:   }
    1: 
    1:   static nsIIOService* GetIOService()
    1:   {
    1:     return sIOService;
    1:   }
    1: 
    1:   static imgILoader* GetImgLoader()
    1:   {
    1:     return sImgLoader;
    1:   }
    1: 
    1: #ifdef MOZ_XTF
    1:   static nsIXTFService* GetXTFService();
    1: #endif
    1: 
    1: #ifdef IBMBIDI
    1:   static nsIBidiKeyboard* GetBidiKeyboard();
    1: #endif
    1:   
    1:   /**
    1:    * Get the cache security manager service. Can return null if the layout
    1:    * module has been shut down.
    1:    */
    1:   static nsIScriptSecurityManager* GetSecurityManager()
    1:   {
    1:     return sSecurityManager;
    1:   }
    1: 
    1:   static nsresult GenerateStateKey(nsIContent* aContent,
    1:                                    nsIDocument* aDocument,
    1:                                    nsIStatefulFrame::SpecialStateID aID,
    1:                                    nsACString& aKey);
    1: 
    1:   /**
    1:    * Create a new nsIURI from aSpec, using aBaseURI as the base.  The
    1:    * origin charset of the new nsIURI will be the document charset of
    1:    * aDocument.
    1:    */
    1:   static nsresult NewURIWithDocumentCharset(nsIURI** aResult,
    1:                                             const nsAString& aSpec,
    1:                                             nsIDocument* aDocument,
    1:                                             nsIURI* aBaseURI);
    1: 
    1:   /**
    1:    * Convert aInput (in charset aCharset) to UTF16 in aOutput.
    1:    *
    1:    * @param aCharset the name of the charset; if empty, we assume UTF8
    1:    */
    1:   static nsresult ConvertStringFromCharset(const nsACString& aCharset,
    1:                                            const nsACString& aInput,
    1:                                            nsAString& aOutput);
    1: 
    1:   /**
 9696:    * Determine whether a buffer begins with a BOM for UTF-8, UTF-16LE,
 9696:    * UTF-16BE, UTF-32LE, UTF-32BE.
 9696:    *
 9696:    * @param aBuffer the buffer to check
 9696:    * @param aLength the length of the buffer
 9696:    * @param aCharset empty if not found
 9696:    * @return boolean indicating whether a BOM was detected.
 9696:    */
 9696:   static PRBool CheckForBOM(const unsigned char* aBuffer, PRUint32 aLength,
22438:                             nsACString& aCharset, PRBool *bigEndian = nsnull);
 9696: 
 9696: 
 9696:   /**
    1:    * Determine whether aContent is in some way associated with aForm.  If the
    1:    * form is a container the only elements that are considered to be associated
    1:    * with a form are the elements that are contained within the form. If the
    1:    * form is a leaf element then all elements will be accepted into this list,
    1:    * since this can happen due to content fixup when a form spans table rows or
    1:    * table cells.
    1:    */
    1:   static PRBool BelongsInForm(nsIDOMHTMLFormElement *aForm,
    1:                               nsIContent *aContent);
    1: 
    1:   static nsresult CheckQName(const nsAString& aQualifiedName,
    1:                              PRBool aNamespaceAware = PR_TRUE);
    1: 
    1:   static nsresult SplitQName(nsIContent* aNamespaceResolver,
    1:                              const nsAFlatString& aQName,
    1:                              PRInt32 *aNamespace, nsIAtom **aLocalName);
    1: 
    1:   static nsresult LookupNamespaceURI(nsIContent* aNamespaceResolver,
    1:                                      const nsAString& aNamespacePrefix,
    1:                                      nsAString& aNamespaceURI);
    1: 
    1:   static nsresult GetNodeInfoFromQName(const nsAString& aNamespaceURI,
    1:                                        const nsAString& aQualifiedName,
    1:                                        nsNodeInfoManager* aNodeInfoManager,
    1:                                        nsINodeInfo** aNodeInfo);
    1: 
    1:   static void SplitExpatName(const PRUnichar *aExpatName, nsIAtom **aPrefix,
    1:                              nsIAtom **aTagName, PRInt32 *aNameSpaceID);
    1: 
    1:   static nsAdoptingCString GetCharPref(const char *aPref);
    1:   static PRPackedBool GetBoolPref(const char *aPref,
    1:                                   PRBool aDefault = PR_FALSE);
    1:   static PRInt32 GetIntPref(const char *aPref, PRInt32 aDefault = 0);
    1:   static nsAdoptingString GetLocalizedStringPref(const char *aPref);
    1:   static nsAdoptingString GetStringPref(const char *aPref);
    1:   static void RegisterPrefCallback(const char *aPref,
    1:                                    PrefChangedFunc aCallback,
    1:                                    void * aClosure);
    1:   static void UnregisterPrefCallback(const char *aPref,
    1:                                      PrefChangedFunc aCallback,
    1:                                      void * aClosure);
14747:   static void AddBoolPrefVarCache(const char* aPref, PRBool* aVariable);
    1:   static nsIPrefBranch *GetPrefBranch()
    1:   {
    1:     return sPrefBranch;
    1:   }
    1: 
    1:   static nsILineBreaker* LineBreaker()
    1:   {
    1:     return sLineBreaker;
    1:   }
    1: 
    1:   static nsIWordBreaker* WordBreaker()
    1:   {
    1:     return sWordBreaker;
    1:   }
    1:   
 3049:   static nsICaseConversion* GetCaseConv()
 3049:   {
 3049:     return sCaseConv;
 3049:   }
 3049: 
15634:   static nsIUGenCategory* GetGenCat()
15634:   {
15634:     return sGenCat;
15634:   }
15634: 
    1:   /**
    1:    * @return PR_TRUE if aContent has an attribute aName in namespace aNameSpaceID,
    1:    * and the attribute value is non-empty.
    1:    */
    1:   static PRBool HasNonEmptyAttr(nsIContent* aContent, PRInt32 aNameSpaceID,
    1:                                 nsIAtom* aName);
    1: 
    1:   /**
 3439:    * Method that gets the primary presContext for the node.
 3439:    * 
 3439:    * @param aContent The content node.
 3439:    * @return the presContext, or nsnull if the content is not in a document
 3439:    *         (if GetCurrentDoc returns nsnull)
 3439:    */
 3439:   static nsPresContext* GetContextForContent(nsIContent* aContent);
 3439: 
 3439:   /**
    1:    * Method to do security and content policy checks on the image URI
    1:    *
    1:    * @param aURI uri of the image to be loaded
    1:    * @param aContext the context the image is loaded in (eg an element)
    1:    * @param aLoadingDocument the document we belong to
 3088:    * @param aLoadingPrincipal the principal doing the load
    1:    * @param aImageBlockingStatus the nsIContentPolicy blocking status for this
    1:    *        image.  This will be set even if a security check fails for the
    1:    *        image, to some reasonable REJECT_* value.  This out param will only
    1:    *        be set if it's non-null.
    1:    * @return PR_TRUE if the load can proceed, or PR_FALSE if it is blocked.
    1:    *         Note that aImageBlockingStatus, if set will always be an ACCEPT
    1:    *         status if PR_TRUE is returned and always be a REJECT_* status if
    1:    *         PR_FALSE is returned.
    1:    */
    1:   static PRBool CanLoadImage(nsIURI* aURI,
    1:                              nsISupports* aContext,
    1:                              nsIDocument* aLoadingDocument,
 3088:                              nsIPrincipal* aLoadingPrincipal,
    1:                              PRInt16* aImageBlockingStatus = nsnull);
    1:   /**
    1:    * Method to start an image load.  This does not do any security checks.
 7214:    * This method will attempt to make aURI immutable; a caller that wants to
 7214:    * keep a mutable version around should pass in a clone.
    1:    *
    1:    * @param aURI uri of the image to be loaded
    1:    * @param aLoadingDocument the document we belong to
 3088:    * @param aLoadingPrincipal the principal doing the load
 3088:    * @param aReferrer the referrer URI
    1:    * @param aObserver the observer for the image load
    1:    * @param aLoadFlags the load flags to use.  See nsIRequest
    1:    * @return the imgIRequest for the image load
    1:    */
    1:   static nsresult LoadImage(nsIURI* aURI,
    1:                             nsIDocument* aLoadingDocument,
 3088:                             nsIPrincipal* aLoadingPrincipal,
    1:                             nsIURI* aReferrer,
    1:                             imgIDecoderObserver* aObserver,
    1:                             PRInt32 aLoadFlags,
    1:                             imgIRequest** aRequest);
    1: 
    1:   /**
30065:    * Returns whether the given URI is in the image cache.
30065:    */
30065:   static PRBool IsImageInCache(nsIURI* aURI);
30065: 
30065:   /**
30479:    * Method to get an imgIContainer from an image loading content
    1:    *
    1:    * @param aContent The image loading content.  Must not be null.
    1:    * @param aRequest The image request [out]
30479:    * @return the imgIContainer corresponding to the first frame of the image
    1:    */
30479:   static already_AddRefed<imgIContainer> GetImageFromContent(nsIImageLoadingContent* aContent, imgIRequest **aRequest = nsnull);
    1: 
    1:   /**
    1:    * Method that decides whether a content node is draggable
    1:    *
    1:    * @param aContent The content node to test.
    1:    * @return whether it's draggable
    1:    */
18985:   static PRBool ContentIsDraggable(nsIContent* aContent);
    1: 
    1:   /**
    1:    * Method that decides whether a content node is a draggable image
    1:    *
    1:    * @param aContent The content node to test.
    1:    * @return whether it's a draggable image
    1:    */
    1:   static PRBool IsDraggableImage(nsIContent* aContent);
    1: 
    1:   /**
    1:    * Method that decides whether a content node is a draggable link
    1:    *
    1:    * @param aContent The content node to test.
    1:    * @return whether it's a draggable link
    1:    */
    1:   static PRBool IsDraggableLink(nsIContent* aContent);
    1: 
    1:   /**
    1:    * Convenience method to create a new nodeinfo that differs only by name
    1:    * from aNodeInfo.
    1:    */
    1:   static nsresult NameChanged(nsINodeInfo *aNodeInfo, nsIAtom *aName,
    1:                               nsINodeInfo** aResult)
    1:   {
    1:     nsNodeInfoManager *niMgr = aNodeInfo->NodeInfoManager();
    1: 
19197:     *aResult = niMgr->GetNodeInfo(aName, aNodeInfo->GetPrefixAtom(),
19197:                                   aNodeInfo->NamespaceID()).get();
19747:     return *aResult ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   /**
    1:    * Convenience method to create a new nodeinfo that differs only by prefix
    1:    * from aNodeInfo.
    1:    */
    1:   static nsresult PrefixChanged(nsINodeInfo *aNodeInfo, nsIAtom *aPrefix,
    1:                                 nsINodeInfo** aResult)
    1:   {
    1:     nsNodeInfoManager *niMgr = aNodeInfo->NodeInfoManager();
    1: 
19197:     *aResult = niMgr->GetNodeInfo(aNodeInfo->NameAtom(), aPrefix,
19197:                                   aNodeInfo->NamespaceID()).get();
19747:     return *aResult ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   /**
    1:    * Returns the appropriate event argument names for the specified
    1:    * namespace and event name.  Added because we need to switch between
    1:    * SVG's "evt" and the rest of the world's "event", and because onerror
    1:    * takes 3 args.
    1:    */
    1:   static void GetEventArgNames(PRInt32 aNameSpaceID, nsIAtom *aEventName,
    1:                                PRUint32 *aArgCount, const char*** aArgNames);
    1: 
    1:   /**
    1:    * If aNode is not an element, return true exactly when aContent's binding
    1:    * parent is null.
    1:    *
    1:    * If aNode is an element, return true exactly when aContent's binding parent
    1:    * is the same as aNode's.
    1:    *
    1:    * This method is particularly useful for callers who are trying to ensure
    1:    * that they are working with a non-anonymous descendant of a given node.  If
    1:    * aContent is a descendant of aNode, a return value of PR_FALSE from this
    1:    * method means that it's an anonymous descendant from aNode's point of view.
    1:    *
    1:    * Both arguments to this method must be non-null.
    1:    */
    1:   static PRBool IsInSameAnonymousTree(nsINode* aNode, nsIContent* aContent);
    1: 
    1:   /**
    1:    * Return the nsIXPConnect service.
    1:    */
    1:   static nsIXPConnect *XPConnect()
    1:   {
    1:     return sXPConnect;
    1:   }
    1: 
    1:   /**
    1:    * Report a localized error message to the error console.
    1:    *   @param aFile Properties file containing localized message.
    1:    *   @param aMessageName Name of localized message.
    1:    *   @param aParams Parameters to be substituted into localized message.
    1:    *   @param aParamsLength Length of aParams.
    1:    *   @param aURI URI of resource containing error (may be null).
    1:    *   @param aSourceLine The text of the line that contains the error (may be
    1:               empty).
    1:    *   @param aLineNumber Line number within resource containing error.
    1:    *   @param aColumnNumber Column number within resource containing error.
    1:    *   @param aErrorFlags See nsIScriptError.
    1:    *   @param aCategory Name of module reporting error.
    1:    */
    1:   enum PropertiesFile {
    1:     eCSS_PROPERTIES,
    1:     eXBL_PROPERTIES,
    1:     eXUL_PROPERTIES,
    1:     eLAYOUT_PROPERTIES,
    1:     eFORMS_PROPERTIES,
    1:     ePRINTING_PROPERTIES,
    1:     eDOM_PROPERTIES,
    1: #ifdef MOZ_SVG
    1:     eSVG_PROPERTIES,
    1: #endif
    1:     eBRAND_PROPERTIES,
    1:     eCOMMON_DIALOG_PROPERTIES,
    1:     PropertiesFile_COUNT
    1:   };
    1:   static nsresult ReportToConsole(PropertiesFile aFile,
    1:                                   const char *aMessageName,
    1:                                   const PRUnichar **aParams,
    1:                                   PRUint32 aParamsLength,
    1:                                   nsIURI* aURI,
    1:                                   const nsAFlatString& aSourceLine,
    1:                                   PRUint32 aLineNumber,
    1:                                   PRUint32 aColumnNumber,
    1:                                   PRUint32 aErrorFlags,
    1:                                   const char *aCategory);
    1: 
    1:   /**
    1:    * Get the localized string named |aKey| in properties file |aFile|.
    1:    */
    1:   static nsresult GetLocalizedString(PropertiesFile aFile,
    1:                                      const char* aKey,
    1:                                      nsXPIDLString& aResult);
    1: 
    1:   /**
    1:    * Fill (with the parameters given) the localized string named |aKey| in
    1:    * properties file |aFile|.
    1:    */
    1:   static nsresult FormatLocalizedString(PropertiesFile aFile,
    1:                                         const char* aKey,
    1:                                         const PRUnichar **aParams,
    1:                                         PRUint32 aParamsLength,
    1:                                         nsXPIDLString& aResult);
    1: 
    1:   /**
    1:    * Returns true if aDocument is a chrome document
    1:    */
    1:   static PRBool IsChromeDoc(nsIDocument *aDocument);
    1: 
    1:   /**
33860:    * Returns true if aDocument is in a docshell whose parent is the same type
33860:    */
33860:   static PRBool IsChildOfSameType(nsIDocument* aDoc);
33860: 
33860:   /**
21636:    * Get the script file name to use when compiling the script
21636:    * referenced by aURI. In cases where there's no need for any extra
21636:    * security wrapper automation the script file name that's returned
21636:    * will be the spec in aURI, else it will be the spec in aDocument's
21636:    * URI followed by aURI's spec, separated by " -> ". Returns PR_TRUE
21636:    * if the script file name was modified, PR_FALSE if it's aURI's
21636:    * spec.
21636:    */
21636:   static PRBool GetWrapperSafeScriptFilename(nsIDocument *aDocument,
21636:                                              nsIURI *aURI,
21636:                                              nsACString& aScriptURI);
21636: 
21636: 
21636:   /**
19869:    * Returns true if aDocument belongs to a chrome docshell for
19869:    * display purposes.  Returns false for null documents or documents
19869:    * which do not belong to a docshell.
19869:    */
19869:   static PRBool IsInChromeDocshell(nsIDocument *aDocument);
19869: 
19869:   /**
    1:    * Release *aSupportsPtr when the shutdown notification is received
    1:    */
    1:   static nsresult ReleasePtrOnShutdown(nsISupports** aSupportsPtr) {
    1:     NS_ASSERTION(aSupportsPtr, "Expect to crash!");
    1:     NS_ASSERTION(*aSupportsPtr, "Expect to crash!");
26413:     return sPtrsToPtrsToRelease->AppendElement(aSupportsPtr) != nsnull ? NS_OK :
    1:       NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   /**
    1:    * Return the content policy service
    1:    */
    1:   static nsIContentPolicy *GetContentPolicy();
    1: 
    1:   /**
    1:    * Quick helper to determine whether there are any mutation listeners
    1:    * of a given type that apply to this content or any of its ancestors.
 3137:    * The method has the side effect to call document's MayDispatchMutationEvent
 3137:    * using aTargetForSubtreeModified as the parameter.
    1:    *
    1:    * @param aNode  The node to search for listeners
    1:    * @param aType  The type of listener (NS_EVENT_BITS_MUTATION_*)
 3137:    * @param aTargetForSubtreeModified The node which is the target of the
 3137:    *                                  possible DOMSubtreeModified event.
    1:    *
    1:    * @return true if there are mutation listeners of the specified type
    1:    */
    1:   static PRBool HasMutationListeners(nsINode* aNode,
 3137:                                      PRUint32 aType,
 3137:                                      nsINode* aTargetForSubtreeModified);
    1: 
    1:   /**
    1:    * This method creates and dispatches a trusted event.
    1:    * Works only with events which can be created by calling
    1:    * nsIDOMDocumentEvent::CreateEvent() with parameter "Events".
    1:    * @param aDoc           The document which will be used to create the event.
    1:    * @param aTarget        The target of the event, should be QIable to
    1:    *                       nsIDOMEventTarget.
    1:    * @param aEventName     The name of the event.
    1:    * @param aCanBubble     Whether the event can bubble.
    1:    * @param aCancelable    Is the event cancelable.
    1:    * @param aDefaultAction Set to true if default action should be taken,
    1:    *                       see nsIDOMEventTarget::DispatchEvent.
    1:    */
    1:   static nsresult DispatchTrustedEvent(nsIDocument* aDoc,
    1:                                        nsISupports* aTarget,
    1:                                        const nsAString& aEventName,
    1:                                        PRBool aCanBubble,
    1:                                        PRBool aCancelable,
    1:                                        PRBool *aDefaultAction = nsnull);
    1: 
    1:   /**
25379:    * This method creates and dispatches a trusted event to the chrome
25379:    * event handler.
25379:    * Works only with events which can be created by calling
25379:    * nsIDOMDocumentEvent::CreateEvent() with parameter "Events".
25379:    * @param aDocument      The document which will be used to create the event,
25379:    *                       and whose window's chrome handler will be used to
25379:    *                       dispatch the event.
25379:    * @param aTarget        The target of the event, used for event->SetTarget()
25379:    * @param aEventName     The name of the event.
25379:    * @param aCanBubble     Whether the event can bubble.
25379:    * @param aCancelable    Is the event cancelable.
25379:    * @param aDefaultAction Set to true if default action should be taken,
25379:    *                       see nsIDOMEventTarget::DispatchEvent.
25379:    */
25379:   static nsresult DispatchChromeEvent(nsIDocument* aDoc,
25379:                                       nsISupports* aTarget,
25379:                                       const nsAString& aEventName,
25379:                                       PRBool aCanBubble,
25379:                                       PRBool aCancelable,
25379:                                       PRBool *aDefaultAction = nsnull);
25379: 
25379:   /**
  265:    * Determines if an event attribute name (such as onclick) is valid for
  265:    * a given element type. Types are from the EventNameType enumeration
  265:    * defined above.
  265:    *
  265:    * @param aName the event name to look up
  265:    * @param aType the type of content
  265:    */
  265:   static PRBool IsEventAttributeName(nsIAtom* aName, PRInt32 aType);
  265: 
  265:   /**
  265:    * Return the event id for the event with the given name. The name is the
  265:    * event name with the 'on' prefix. Returns NS_USER_DEFINED_EVENT if the
  265:    * event doesn't match a known event name.
  265:    *
  265:    * @param aName the event name to look up
  265:    */
  265:   static PRUint32 GetEventId(nsIAtom* aName);
  265: 
  265:   /**
    1:    * Used only during traversal of the XPCOM graph by the cycle
    1:    * collector: push a pointer to the listener manager onto the
    1:    * children deque, if it exists. Do nothing if there is no listener
    1:    * manager.
    1:    *
    1:    * Crucially: does not perform any refcounting operations.
    1:    *
    1:    * @param aNode The node to traverse.
    1:    * @param children The buffer to push a listener manager pointer into.
    1:    */
    1:   static void TraverseListenerManager(nsINode *aNode,
    1:                                       nsCycleCollectionTraversalCallback &cb);
    1: 
    1:   /**
    1:    * Get the eventlistener manager for aNode. If a new eventlistener manager
    1:    * was created, aCreated is set to PR_TRUE.
    1:    *
    1:    * @param aNode The node for which to get the eventlistener manager.
    1:    * @param aCreateIfNotFound If PR_FALSE, returns a listener manager only if
    1:    *                          one already exists.
    1:    */
29474:   static nsIEventListenerManager* GetListenerManager(nsINode* aNode,
29474:                                                      PRBool aCreateIfNotFound);
    1: 
    1:   /**
    1:    * Remove the eventlistener manager for aNode.
    1:    *
    1:    * @param aNode The node for which to remove the eventlistener manager.
    1:    */
    1:   static void RemoveListenerManager(nsINode *aNode);
    1: 
    1:   static PRBool IsInitialized()
    1:   {
    1:     return sInitialized;
    1:   }
    1: 
    1:   /**
    1:    * Checks if the localname/prefix/namespace triple is valid wrt prefix
    1:    * and namespace according to the Namespaces in XML and DOM Code
    1:    * specfications.
    1:    *
    1:    * @param aLocalname localname of the node
    1:    * @param aPrefix prefix of the node
    1:    * @param aNamespaceID namespace of the node
    1:    */
    1:   static PRBool IsValidNodeName(nsIAtom *aLocalName, nsIAtom *aPrefix,
    1:                                 PRInt32 aNamespaceID);
    1: 
    1:   /**
    1:    * Creates a DocumentFragment from text using a context node to resolve
    1:    * namespaces.
    1:    *
    1:    * @param aContextNode the node which is used to resolve namespaces
    1:    * @param aFragment the string which is parsed to a DocumentFragment
12676:    * @param aWillOwnFragment is PR_TRUE if ownership of the fragment should be
12676:    *                         transferred to the caller.
    1:    * @param aReturn [out] the created DocumentFragment
    1:    */
    1:   static nsresult CreateContextualFragment(nsIDOMNode* aContextNode,
    1:                                            const nsAString& aFragment,
12676:                                            PRBool aWillOwnFragment,
    1:                                            nsIDOMDocumentFragment** aReturn);
    1: 
    1:   /**
 6475:    * Creates a new XML document, which is marked to be loaded as data.
    1:    *
    1:    * @param aNamespaceURI Namespace for the root element to create and insert in
    1:    *                      the document. Only used if aQualifiedName is not
    1:    *                      empty.
    1:    * @param aQualifiedName Qualified name for the root element to create and
    1:    *                       insert in the document. If empty no root element will
    1:    *                       be created.
    1:    * @param aDoctype Doctype node to insert in the document.
    1:    * @param aDocumentURI URI of the document. Must not be null.
    1:    * @param aBaseURI Base URI of the document. Must not be null.
    1:    * @param aPrincipal Prinicpal of the document. Must not be null.
 6475:    * @param aScriptObject The object from which the context for event handling
 6475:    *                      can be got.
    1:    * @param aResult [out] The document that was created.
    1:    */
    1:   static nsresult CreateDocument(const nsAString& aNamespaceURI, 
    1:                                  const nsAString& aQualifiedName, 
    1:                                  nsIDOMDocumentType* aDoctype,
    1:                                  nsIURI* aDocumentURI,
    1:                                  nsIURI* aBaseURI,
    1:                                  nsIPrincipal* aPrincipal,
 6475:                                  nsIScriptGlobalObject* aScriptObject,
    1:                                  nsIDOMDocument** aResult);
    1: 
    1:   /**
    1:    * Sets the text contents of a node by replacing all existing children
    1:    * with a single text child.
    1:    *
    1:    * The function always notifies.
    1:    *
    1:    * Will reuse the first text child if one is available. Will not reuse
    1:    * existing cdata children.
    1:    *
    1:    * @param aContent Node to set contents of.
    1:    * @param aValue   Value to set contents to.
    1:    * @param aTryReuse When true, the function will try to reuse an existing
    1:    *                  textnodes rather than always creating a new one.
    1:    */
    1:   static nsresult SetNodeTextContent(nsIContent* aContent,
    1:                                      const nsAString& aValue,
    1:                                      PRBool aTryReuse);
    1: 
    1:   /**
 7244:    * Get the textual contents of a node. This is a concatenation of all
    1:    * textnodes that are direct or (depending on aDeep) indirect children
    1:    * of the node.
    1:    *
    1:    * NOTE! No serialization takes place and <br> elements
    1:    * are not converted into newlines. Only textnodes and cdata nodes are
    1:    * added to the result.
    1:    *
    1:    * @param aNode Node to get textual contents of.
    1:    * @param aDeep If true child elements of aNode are recursivly descended
    1:    *              into to find text children.
    1:    * @param aResult the result. Out param.
    1:    */
    1:   static void GetNodeTextContent(nsINode* aNode, PRBool aDeep,
    1:                                  nsAString& aResult)
    1:   {
    1:     aResult.Truncate();
    1:     AppendNodeTextContent(aNode, aDeep, aResult);
    1:   }
    1: 
    1:   /**
    1:    * Same as GetNodeTextContents but appends the result rather than sets it.
    1:    */
    1:   static void AppendNodeTextContent(nsINode* aNode, PRBool aDeep,
    1:                                     nsAString& aResult);
    1: 
    1:   /**
    1:    * Utility method that checks if a given node has any non-empty
    1:    * children.
    1:    * NOTE! This method does not descend recursivly into elements.
    1:    * Though it would be easy to make it so if needed
    1:    */
    1:   static PRBool HasNonEmptyTextContent(nsINode* aNode);
    1: 
    1:   /**
    1:    * Delete strings allocated for nsContentList matches
    1:    */
    1:   static void DestroyMatchString(void* aData)
    1:   {
    1:     if (aData) {
 3233:       nsString* matchString = static_cast<nsString*>(aData);
    1:       delete matchString;
    1:     }
    1:   }
    1: 
    1:   /**
    1:    * Unbinds the content from the tree and nulls it out if it's not null.
    1:    */
    1:   static void DestroyAnonymousContent(nsCOMPtr<nsIContent>* aContent);
    1: 
 7230:   /**
 7230:    * Keep script object aNewObject, held by aScriptObjectHolder, alive.
 7230:    *
 7230:    * NOTE: This currently only supports objects that hold script objects of one
 7230:    *       scripting language.
 7230:    *
 7230:    * @param aLangID script language ID of aNewObject
 7230:    * @param aScriptObjectHolder the object that holds aNewObject
 7230:    * @param aTracer the tracer for aScriptObject
 7230:    * @param aNewObject the script object to hold
 7230:    * @param aWasHoldingObjects whether aScriptObjectHolder was already holding
 7230:    *                           script objects (ie. HoldScriptObject was called
 7230:    *                           on it before, without a corresponding call to
 7230:    *                           DropScriptObjects)
 7230:    */
 7230:   static nsresult HoldScriptObject(PRUint32 aLangID, void* aScriptObjectHolder,
 7230:                                    nsScriptObjectTracer* aTracer,
 7230:                                    void* aNewObject, PRBool aWasHoldingObjects)
 7230:   {
 7230:     if (aLangID == nsIProgrammingLanguage::JAVASCRIPT) {
 7230:       return aWasHoldingObjects ? NS_OK :
 7230:                                   HoldJSObjects(aScriptObjectHolder, aTracer);
 7230:     }
 7227: 
 7230:     return HoldScriptObject(aLangID, aNewObject);
 7230:   }
 7230: 
 7230:   /**
 7230:    * Drop any script objects that aScriptObjectHolder is holding.
 7230:    *
 7230:    * NOTE: This currently only supports objects that hold script objects of one
 7230:    *       scripting language.
 7230:    *
 7230:    * @param aLangID script language ID of the objects that 
 7230:    * @param aScriptObjectHolder the object that holds script object that we want
 7230:    *                            to drop
 7230:    * @param aTracer the tracer for aScriptObject
 7230:    */
 7230:   static nsresult DropScriptObjects(PRUint32 aLangID, void* aScriptObjectHolder,
 7230:                                     nsScriptObjectTracer* aTracer)
 7226:   {
 7230:     if (aLangID == nsIProgrammingLanguage::JAVASCRIPT) {
 7230:       return DropJSObjects(aScriptObjectHolder);
 7226:     }
 7230: 
 7230:     aTracer->Trace(aScriptObjectHolder, DropScriptObject, nsnull);
 7230: 
 7230:     return NS_OK;
 7226:   }
 7230: 
 7230:   /**
 7230:    * Keep the JS objects held by aScriptObjectHolder alive.
 7230:    *
 7230:    * @param aScriptObjectHolder the object that holds JS objects that we want to
 7230:    *                            keep alive
 7230:    * @param aTracer the tracer for aScriptObject
 7230:    */
 7230:   static nsresult HoldJSObjects(void* aScriptObjectHolder,
 7230:                                 nsScriptObjectTracer* aTracer);
 7230: 
 7230:   /**
 7230:    * Drop the JS objects held by aScriptObjectHolder.
 7230:    *
 7230:    * @param aScriptObjectHolder the object that holds JS objects that we want to
 7230:    *                            drop
 7230:    */
 7230:   static nsresult DropJSObjects(void* aScriptObjectHolder);
    1: 
30001:   static void PreserveWrapper(nsISupports* aScriptObjectHolder,
30001:                               nsWrapperCache* aCache)
30001:   {
30001:     if (!aCache->PreservingWrapper()) {
30001:       nsXPCOMCycleCollectionParticipant* participant;
30001:       CallQueryInterface(aScriptObjectHolder, &participant);
30001:       HoldJSObjects(aScriptObjectHolder, participant);
30001:       aCache->SetPreservingWrapper(PR_TRUE);
30001:     }
30001:   }
30001:   static void ReleaseWrapper(nsISupports* aScriptObjectHolder,
30001:                              nsWrapperCache* aCache)
30001:   {
30001:     if (aCache->PreservingWrapper()) {
30001:       DropJSObjects(aScriptObjectHolder);
30001:       aCache->SetPreservingWrapper(PR_FALSE);
30001:     }
30001:   }
30001:   static void TraceWrapper(nsWrapperCache* aCache, TraceCallback aCallback,
30001:                            void *aClosure)
30001:   {
30001:     if (aCache->PreservingWrapper()) {
30001:       aCallback(nsIProgrammingLanguage::JAVASCRIPT, aCache->GetWrapper(),
30001:                 aClosure);
30001:     }
30001:   }
30001: 
  539:   /**
15919:    * Convert nsIContent::IME_STATUS_* to nsIWidget::IME_STATUS_*
  539:    */
15919:   static PRUint32 GetWidgetStatusFromIMEStatus(PRUint32 aState);
  998: 
  998:   /*
  998:    * Notify when the first XUL menu is opened and when the all XUL menus are
  998:    * closed. At opening, aInstalling should be TRUE, otherwise, it should be
  998:    * FALSE.
  998:    */
  998:   static void NotifyInstalledMenuKeyboardListener(PRBool aInstalling);
 2324: 
 2324:   /**
 2324:    * Do security checks before loading a resource. Does the following checks:
 2324:    *   nsIScriptSecurityManager::CheckLoadURIWithPrincipal
 2324:    *   NS_CheckContentLoadPolicy
 2324:    *   nsIScriptSecurityManager::CheckSameOriginURI
 2324:    *
 2324:    * You will still need to do at least SameOrigin checks before on redirects.
 2324:    *
 2324:    * @param aURIToLoad         URI that is getting loaded.
 2324:    * @param aLoadingPrincipal  Principal of the resource that is initiating
 2324:    *                           the load
 2324:    * @param aCheckLoadFlags    Flags to be passed to
 2324:    *                           nsIScriptSecurityManager::CheckLoadURIWithPrincipal
 2324:    *                           NOTE: If this contains ALLOW_CHROME the
 2324:    *                                 CheckSameOriginURI check will be skipped if
 2324:    *                                 aURIToLoad is a chrome uri.
 2324:    * @param aAllowData         Set to true to skip CheckSameOriginURI check when
 2324:                                aURIToLoad is a data uri.
 2324:    * @param aContentPolicyType Type     \
 2324:    * @param aContext           Context   |- to be passed to
 2324:    * @param aMimeGuess         Mimetype  |      NS_CheckContentLoadPolicy
 2324:    * @param aExtra             Extra    /
 2324:    */
 2324:   static nsresult CheckSecurityBeforeLoad(nsIURI* aURIToLoad,
 2324:                                           nsIPrincipal* aLoadingPrincipal,
 2324:                                           PRUint32 aCheckLoadFlags,
 2324:                                           PRBool aAllowData,
 2324:                                           PRUint32 aContentPolicyType,
 2324:                                           nsISupports* aContext,
 2324:                                           const nsACString& aMimeGuess = EmptyCString(),
 2324:                                           nsISupports* aExtra = nsnull);
 2324: 
 3333:   /**
 3333:    * Trigger a link with uri aLinkURI. If aClick is false, this triggers a
 3333:    * mouseover on the link, otherwise it triggers a load after doing a
 3333:    * security check using aContent's principal.
 3333:    *
 3333:    * @param aContent the node on which a link was triggered.
 3333:    * @param aPresContext the pres context, must be non-null.
 3333:    * @param aLinkURI the URI of the link, must be non-null.
 3333:    * @param aTargetSpec the target (like target=, may be empty).
 3333:    * @param aClick whether this was a click or not (if false, this method
 3333:    *               assumes you just hovered over the link).
 3333:    * @param aIsUserTriggered whether the user triggered the link. This would be
 3333:    *                         false for loads from auto XLinks or from the
 3333:    *                         click() method if we ever implement it.
 3333:    */
 3333:   static void TriggerLink(nsIContent *aContent, nsPresContext *aPresContext,
 3333:                           nsIURI *aLinkURI, const nsString& aTargetSpec,
 3333:                           PRBool aClick, PRBool aIsUserTriggered);
 3333: 
 6876:   /**
 8092:    * Return top-level widget in the parent chain.
 8092:    */
 8092:   static nsIWidget* GetTopLevelWidget(nsIWidget* aWidget);
 6876: 
 8167:   /**
 8167:    * Return the localized ellipsis for UI.
 8167:    */
 8167:   static const nsDependentString GetLocalizedEllipsis();
 8167: 
 9377:   /**
20505:    * The routine GetNativeEvent is used to fill nsNativeKeyEvent.
20505:    * It's also used in DOMEventToNativeKeyEvent.
 9377:    * See bug 406407 for details.
 9377:    */
 9377:   static nsEvent* GetNativeEvent(nsIDOMEvent* aDOMEvent);
20505:   static PRBool DOMEventToNativeKeyEvent(nsIDOMKeyEvent* aKeyEvent,
 9377:                                          nsNativeKeyEvent* aNativeEvent,
 9377:                                          PRBool aGetCharCode);
 9377: 
10340:   /**
19283:    * Get the candidates for accelkeys for aDOMKeyEvent.
14328:    *
19283:    * @param aDOMKeyEvent [in] the key event for accelkey handling.
14328:    * @param aCandidates [out] the candidate shortcut key combination list.
14328:    *                          the first item is most preferred.
14328:    */
19283:   static void GetAccelKeyCandidates(nsIDOMKeyEvent* aDOMKeyEvent,
14328:                                     nsTArray<nsShortcutCandidate>& aCandidates);
14328: 
14328:   /**
19283:    * Get the candidates for accesskeys for aNativeKeyEvent.
14328:    *
19283:    * @param aNativeKeyEvent [in] the key event for accesskey handling.
14328:    * @param aCandidates [out] the candidate access key list.
14328:    *                          the first item is most preferred.
14328:    */
14328:   static void GetAccessKeyCandidates(nsKeyEvent* aNativeKeyEvent,
14328:                                      nsTArray<PRUint32>& aCandidates);
14328: 
14328:   /**
11414:    * Hide any XUL popups associated with aDocument, including any documents
34139:    * displayed in child frames. Does nothing if aDocument is null.
11414:    */
11414:   static void HidePopupsInDocument(nsIDocument* aDocument);
11414: 
11414:   /**
18445:    * Retrieve the current drag session, or null if no drag is currently occuring
18445:    */
18445:   static already_AddRefed<nsIDragSession> GetDragSession();
18445: 
29545:   /*
29545:    * Initialize and set the dataTransfer field of an nsDragEvent.
29545:    */
29545:   static nsresult SetDataTransferInEvent(nsDragEvent* aDragEvent);
29545: 
29545:   // filters the drag and drop action to fit within the effects allowed and
29545:   // returns it.
29545:   static PRUint32 FilterDropEffect(PRUint32 aAction, PRUint32 aEffectAllowed);
29545: 
18445:   /**
13471:    * Return true if aURI is a local file URI (i.e. file://).
13471:    */
13471:   static PRBool URIIsLocalFile(nsIURI *aURI);
13471: 
13471:   /**
15474:    * If aContent is an HTML element with a DOM level 0 'name', then
15474:    * return the name. Otherwise return null.
15474:    */
15474:   static nsIAtom* IsNamedItem(nsIContent* aContent);
15474: 
15474:   /**
21366:    * Get the application manifest URI for this document.  The manifest URI
10340:    * is specified in the manifest= attribute of the root element of the
21366:    * document.
10340:    *
21366:    * @param aDocument The document that lists the manifest.
10340:    * @param aURI The manifest URI.
10340:    */
21366:   static void GetOfflineAppManifest(nsIDocument *aDocument, nsIURI **aURI);
10340: 
10340:   /**
10340:    * Check whether an application should be allowed to use offline APIs.
10340:    */
10340:   static PRBool OfflineAppAllowed(nsIURI *aURI);
10340: 
13098:   /**
18488:    * Check whether an application should be allowed to use offline APIs.
18488:    */
18488:   static PRBool OfflineAppAllowed(nsIPrincipal *aPrincipal);
18488: 
18488:   /**
13098:    * Increases the count of blockers preventing scripts from running.
13098:    * NOTE: You might want to use nsAutoScriptBlocker rather than calling
13098:    * this directly
13098:    */
13098:   static void AddScriptBlocker();
13098: 
13098:   /**
13098:    * Decreases the count of blockers preventing scripts from running.
13098:    * NOTE: You might want to use nsAutoScriptBlocker rather than calling
13098:    * this directly
13098:    *
13098:    * WARNING! Calling this function could synchronously execute scripts.
13098:    */
13098:   static void RemoveScriptBlocker();
13098: 
13098:   /**
13098:    * Add a runnable that is to be executed as soon as it's safe to execute
13098:    * scripts.
13098:    * NOTE: If it's currently safe to execute scripts, aRunnable will be run
13098:    *       synchronously before the function returns.
13098:    *
13098:    * @param aRunnable  The nsIRunnable to run as soon as it's safe to execute
13098:    *                   scripts. Passing null is allowed and results in nothing
13098:    *                   happening. It is also allowed to pass an object that
13098:    *                   has not yet been AddRefed.
24402:    * @return false on out of memory, true otherwise.
13098:    */
13098:   static PRBool AddScriptRunner(nsIRunnable* aRunnable);
13098: 
13098:   /**
13098:    * Returns true if it's safe to execute content script and false otherwise.
13098:    *
13098:    * The only known case where this lies is mutation events. They run, and can
13098:    * run anything else, when this function returns false, but this is ok.
13098:    */
13098:   static PRBool IsSafeToRunScript() {
13098:     return sScriptBlockerCount == 0;
13098:   }
13098: 
14319:   /**
14319:    * Get/Set the current number of removable updates. Currently only
14319:    * UPDATE_CONTENT_MODEL updates are removable, and only when firing mutation
14319:    * events. These functions should only be called by mozAutoDocUpdateRemover.
14319:    * The count is also adjusted by the normal calls to BeginUpdate/EndUpdate.
14319:    */
14319:   static void AddRemovableScriptBlocker()
14319:   {
14319:     AddScriptBlocker();
14319:     ++sRemovableScriptBlockerCount;
14319:   }
14319:   static void RemoveRemovableScriptBlocker()
14319:   {
14319:     NS_ASSERTION(sRemovableScriptBlockerCount != 0,
14319:                 "Number of removable blockers should never go below zero");
14319:     --sRemovableScriptBlockerCount;
14319:     RemoveScriptBlocker();
14319:   }
14319:   static PRUint32 GetRemovableScriptBlockerLevel()
14319:   {
14319:     return sRemovableScriptBlockerCount;
14319:   }
14319: 
15988:   /* Process viewport META data. This gives us information for the scale
15988:    * and zoom of a page on mobile devices. We stick the information in
15988:    * the document header and use it later on after rendering.
15988:    *
15988:    * See Bug #436083
15988:    */
15988:   static nsresult ProcessViewportInfo(nsIDocument *aDocument,
15988:                                       const nsAString &viewportInfo);
15988: 
27700:   static nsIScriptContext* GetContextForEventHandlers(nsINode* aNode,
27700:                                                       nsresult* aRv);
18868: 
18868:   static JSContext *GetCurrentJSContext();
18868: 
18942:                                              
18942:   static nsIInterfaceRequestor* GetSameOriginChecker();
18942: 
20135:   static nsIThreadJSContextStack* ThreadJSContextStack()
20135:   {
20135:     return sThreadJSContextStack;
20135:   }
24084:   
24084: 
24084:   /**
24084:    * Get the Origin of the passed in nsIPrincipal or nsIURI. If the passed in
24084:    * nsIURI or the URI of the passed in nsIPrincipal does not have a host, the
24084:    * origin is set to 'null'.
24084:    *
24084:    * The ASCII versions return a ASCII strings that are puny-code encoded,
24084:    * suitable for for example header values. The UTF versions return strings
24084:    * containing international characters.
24084:    *
24084:    * aPrincipal/aOrigin must not be null.
24084:    */
24084:   static nsresult GetASCIIOrigin(nsIPrincipal* aPrincipal,
24084:                                  nsCString& aOrigin);
24084:   static nsresult GetASCIIOrigin(nsIURI* aURI, nsCString& aOrigin);
24084:   static nsresult GetUTFOrigin(nsIPrincipal* aPrincipal,
24084:                                nsString& aOrigin);
24084:   static nsresult GetUTFOrigin(nsIURI* aURI, nsString& aOrigin);
24084: 
29226:   /**
29844:    * This method creates and dispatches "command" event, which implements
29844:    * nsIDOMXULCommandEvent.
29844:    * If aShell is not null, dispatching goes via
29844:    * nsIPresShell::HandleDOMEventWithTarget.
29844:    */
29844:   static nsresult DispatchXULCommand(nsIContent* aTarget,
29844:                                      PRBool aTrusted,
29844:                                      nsIDOMEvent* aSourceEvent = nsnull,
29844:                                      nsIPresShell* aShell = nsnull,
29844:                                      PRBool aCtrl = PR_FALSE,
29844:                                      PRBool aAlt = PR_FALSE,
29844:                                      PRBool aShift = PR_FALSE,
29844:                                      PRBool aMeta = PR_FALSE);
29844: 
29844:   /**
29226:    * Gets the nsIDocument given the script context. Will return nsnull on failure.
29226:    *
29226:    * @param aScriptContext the script context to get the document for; can be null
29226:    *
29226:    * @return the document associated with the script context
29226:    */
29226:   static already_AddRefed<nsIDocument>
29226:   GetDocumentFromScriptContext(nsIScriptContext *aScriptContext);
29226: 
29802:   /**
29802:    * The method checks whether the caller can access native anonymous content.
29802:    * If there is no JS in the stack or privileged JS is running, this
29802:    * method returns PR_TRUE, otherwise PR_FALSE.
29802:    */
29802:   static PRBool CanAccessNativeAnon();
31981: 
31981:   static nsresult WrapNative(JSContext *cx, JSObject *scope,
31981:                              nsISupports *native, const nsIID* aIID, jsval *vp,
31981:                              // If non-null aHolder will keep the jsval alive
31981:                              // while there's a ref to it
31981:                              nsIXPConnectJSObjectHolder** aHolder = nsnull,
31981:                              PRBool aAllowWrapping = PR_FALSE);
31981: 
31981:   // Same as the WrapNative above, but use this one if aIID is nsISupports' IID.
31981:   static nsresult WrapNative(JSContext *cx, JSObject *scope,
31981:                              nsISupports *native,  jsval *vp,
31981:                              // If non-null aHolder will keep the jsval alive
31981:                              // while there's a ref to it
31981:                              nsIXPConnectJSObjectHolder** aHolder = nsnull,
31981:                              PRBool aAllowWrapping = PR_FALSE)
31981:   {
31981:     return WrapNative(cx, scope, native, nsnull, vp, aHolder, aAllowWrapping);
31981:   }
31981: 
    1: private:
  265: 
  265:   static PRBool InitializeEventTable();
  265: 
    1:   static nsresult doReparentContentWrapper(nsIContent *aChild,
    1:                                            JSContext *cx,
    1:                                            JSObject *aOldGlobal,
    1:                                            JSObject *aNewGlobal,
    1:                                            nsIDocument *aOldDocument,
    1:                                            nsIDocument *aNewDocument);
    1: 
    1:   static nsresult EnsureStringBundle(PropertiesFile aFile);
    1: 
    1:   static nsIDOMScriptObjectFactory *GetDOMScriptObjectFactory();
    1: 
 7230:   static nsresult HoldScriptObject(PRUint32 aLangID, void* aObject);
20261:   static void DropScriptObject(PRUint32 aLangID, void *aObject, void *aClosure);
 7230: 
12313:   static PRBool CanCallerAccess(nsIPrincipal* aSubjectPrincipal,
12313:                                 nsIPrincipal* aPrincipal);
12313: 
    1:   static nsIDOMScriptObjectFactory *sDOMScriptObjectFactory;
    1: 
    1:   static nsIXPConnect *sXPConnect;
    1: 
    1:   static nsIScriptSecurityManager *sSecurityManager;
    1: 
    1:   static nsIThreadJSContextStack *sThreadJSContextStack;
    1: 
    1:   static nsIParserService *sParserService;
    1: 
    1:   static nsINameSpaceManager *sNameSpaceManager;
    1: 
    1:   static nsIIOService *sIOService;
    1: 
    1: #ifdef MOZ_XTF
    1:   static nsIXTFService *sXTFService;
    1: #endif
    1: 
    1:   static nsIPrefBranch *sPrefBranch;
34185: 
34185:   static nsIPref *sPref;
    1: 
    1:   static imgILoader* sImgLoader;
30065:   static imgICache* sImgCache;
    1: 
    1:   static nsIConsoleService* sConsoleService;
    1: 
  265:   static nsDataHashtable<nsISupportsHashKey, EventNameMapping>* sEventTable;
  265: 
    1:   static nsIStringBundleService* sStringBundleService;
    1:   static nsIStringBundle* sStringBundles[PropertiesFile_COUNT];
    1: 
    1:   static nsIContentPolicy* sContentPolicyService;
    1:   static PRBool sTriedToGetContentPolicy;
    1: 
    1:   static nsILineBreaker* sLineBreaker;
    1:   static nsIWordBreaker* sWordBreaker;
 3049:   static nsICaseConversion* sCaseConv;
15634:   static nsIUGenCategory* sGenCat;
    1: 
    1:   // Holds pointers to nsISupports* that should be released at shutdown
26413:   static nsTArray<nsISupports**>* sPtrsToPtrsToRelease;
    1: 
    1:   static nsIScriptRuntime* sScriptRuntimes[NS_STID_ARRAY_UBOUND];
    1:   static PRInt32 sScriptRootCount[NS_STID_ARRAY_UBOUND];
 7230:   static PRUint32 sJSGCThingRootCount;
    1: 
    1: #ifdef IBMBIDI
    1:   static nsIBidiKeyboard* sBidiKeyboard;
    1: #endif
    1: 
    1:   static PRBool sInitialized;
13098:   static PRUint32 sScriptBlockerCount;
14319:   static PRUint32 sRemovableScriptBlockerCount;
13098:   static nsCOMArray<nsIRunnable>* sBlockedScriptRunners;
13098:   static PRUint32 sRunnersCountAtFirstBlocker;
18942: 
18942:   static nsIInterfaceRequestor* sSameOriginChecker;
    1: };
    1: 
 7230: #define NS_HOLD_JS_OBJECTS(obj, clazz)                                         \
 7230:   nsContentUtils::HoldJSObjects(NS_CYCLE_COLLECTION_UPCAST(obj, clazz),        \
 7230:                                 &NS_CYCLE_COLLECTION_NAME(clazz))
 7230: 
 7230: #define NS_DROP_JS_OBJECTS(obj, clazz)                                         \
 7230:   nsContentUtils::DropJSObjects(NS_CYCLE_COLLECTION_UPCAST(obj, clazz))
 7230: 
 7230: 
15594: class NS_STACK_CLASS nsCxPusher
    1: {
    1: public:
 6475:   nsCxPusher();
 6475:   ~nsCxPusher(); // Calls Pop();
    1: 
 6475:   // Returns PR_FALSE if something erroneous happened.
20135:   PRBool Push(nsPIDOMEventTarget *aCurrentTarget);
28325:   // If nothing has been pushed to stack, this works like Push.
28325:   // Otherwise if context will change, Pop and Push will be called.
28325:   PRBool RePush(nsPIDOMEventTarget *aCurrentTarget);
25038:   // If a null JSContext is passed to Push(), that will cause no
25047:   // push to happen and false to be returned.
13098:   PRBool Push(JSContext *cx);
25038:   // Explicitly push a null JSContext on the the stack
25038:   PRBool PushNull();
25038: 
25038:   // Pop() will be a no-op if Push() or PushNull() fail
    1:   void Pop();
    1: 
34158:   nsIScriptContext* GetCurrentScriptContext() { return mScx; }
    1: private:
25038:   // Combined code for PushNull() and Push(JSContext*)
25038:   PRBool DoPush(JSContext* cx);
25038: 
    1:   nsCOMPtr<nsIScriptContext> mScx;
    1:   PRBool mScriptIsRunning;
25038:   PRBool mPushedSomething;
25038: #ifdef DEBUG
25038:   JSContext* mPushedContext;
25038: #endif
    1: };
    1: 
    1: class nsAutoGCRoot {
    1: public:
    1:   // aPtr should be the pointer to the jsval we want to protect
    1:   nsAutoGCRoot(jsval* aPtr, nsresult* aResult) :
    1:     mPtr(aPtr)
    1:   {
 7230:     mResult = *aResult = AddJSGCRoot(aPtr, "nsAutoGCRoot");
    1:   }
    1: 
    1:   // aPtr should be the pointer to the JSObject* we want to protect
    1:   nsAutoGCRoot(JSObject** aPtr, nsresult* aResult) :
    1:     mPtr(aPtr)
    1:   {
 7230:     mResult = *aResult = AddJSGCRoot(aPtr, "nsAutoGCRoot");
    1:   }
    1: 
    1:   // aPtr should be the pointer to the thing we want to protect
    1:   nsAutoGCRoot(void* aPtr, nsresult* aResult) :
    1:     mPtr(aPtr)
    1:   {
 7230:     mResult = *aResult = AddJSGCRoot(aPtr, "nsAutoGCRoot");
    1:   }
    1: 
    1:   ~nsAutoGCRoot() {
    1:     if (NS_SUCCEEDED(mResult)) {
 7230:       RemoveJSGCRoot(mPtr);
    1:     }
    1:   }
    1: 
 7230:   static void Shutdown();
 7230: 
    1: private:
 7230:   static nsresult AddJSGCRoot(void *aPtr, const char* aName);
 7230:   static nsresult RemoveJSGCRoot(void *aPtr);
 7230: 
 7230:   static nsIJSRuntimeService* sJSRuntimeService;
 7230:   static JSRuntime* sJSScriptRuntime;
 7230: 
    1:   void* mPtr;
    1:   nsresult mResult;
    1: };
    1: 
13098: class nsAutoScriptBlocker {
13098: public:
13098:   nsAutoScriptBlocker() {
13098:     nsContentUtils::AddScriptBlocker();
13098:   }
13098:   ~nsAutoScriptBlocker() {
13098:     nsContentUtils::RemoveScriptBlocker();
13098:   }
13098: };
13098: 
14319: class mozAutoRemovableBlockerRemover
14319: {
14319: public:
34394:   mozAutoRemovableBlockerRemover(nsIDocument* aDocument);
34394:   ~mozAutoRemovableBlockerRemover();
14319: 
14319: private:
14319:   PRUint32 mNestingLevel;
34394:   nsCOMPtr<nsIDocument> mDocument;
34394:   nsCOMPtr<nsIDocumentObserver> mObserver;
14319: };
14319: 
    1: #define NS_AUTO_GCROOT_PASTE2(tok,line) tok##line
    1: #define NS_AUTO_GCROOT_PASTE(tok,line) \
    1:   NS_AUTO_GCROOT_PASTE2(tok,line)
    1: #define NS_AUTO_GCROOT(ptr, result) \ \
    1:   nsAutoGCRoot NS_AUTO_GCROOT_PASTE(_autoGCRoot_, __LINE__) \
    1:   (ptr, result)
    1: 
    1: #define NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(_class)                      \
    1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(_class)
    1: 
    1: #define NS_INTERFACE_MAP_ENTRY_TEAROFF(_interface, _allocator)                \
    1:   if (aIID.Equals(NS_GET_IID(_interface))) {                                  \
 3233:     foundInterface = static_cast<_interface *>(_allocator);                   \
    1:     if (!foundInterface) {                                                    \
    1:       *aInstancePtr = nsnull;                                                 \
    1:       return NS_ERROR_OUT_OF_MEMORY;                                          \
    1:     }                                                                         \
    1:   } else
    1: 
14038: /*
14038:  * Check whether a floating point number is finite (not +/-infinity and not a
14038:  * NaN value). We wrap JSDOUBLE_IS_FINITE in a function because it expects to
14038:  * take the address of its argument, and because the argument must be of type
14038:  * jsdouble to have the right size and layout of bits.
14038:  *
14038:  * Note: we could try to exploit the fact that |infinity - infinity == NaN|
14038:  * instead of using JSDOUBLE_IS_FINITE. This would produce more compact code
14038:  * and perform better by avoiding type conversions and bit twiddling.
14038:  * Unfortunately, some architectures don't guarantee that |f == f| evaluates
14038:  * to true (where f is any *finite* floating point number). See
14038:  * https://bugzilla.mozilla.org/show_bug.cgi?id=369418#c63 . To play it safe
14038:  * for gecko 1.9, we just reuse JSDOUBLE_IS_FINITE.
14038:  */
14038: inline NS_HIDDEN_(PRBool) NS_FloatIsFinite(jsdouble f) {
14038:   return JSDOUBLE_IS_FINITE(f);
14038: }
14038: 
14038: /*
14038:  * In the following helper macros we exploit the fact that the result of a
14038:  * series of additions will not be finite if any one of the operands in the
14038:  * series is not finite.
14038:  */
14038: #define NS_ENSURE_FINITE(f, rv)                                               \
14038:   if (!NS_FloatIsFinite(f)) {                                                 \
14038:     return (rv);                                                              \
14038:   }
14038: 
14038: #define NS_ENSURE_FINITE2(f1, f2, rv)                                         \
14038:   if (!NS_FloatIsFinite((f1)+(f2))) {                                         \
14038:     return (rv);                                                              \
14038:   }
14038: 
14038: #define NS_ENSURE_FINITE3(f1, f2, f3, rv)                                     \
14038:   if (!NS_FloatIsFinite((f1)+(f2)+(f3))) {                                    \
14038:     return (rv);                                                              \
14038:   }
14038: 
14038: #define NS_ENSURE_FINITE4(f1, f2, f3, f4, rv)                                 \
14038:   if (!NS_FloatIsFinite((f1)+(f2)+(f3)+(f4))) {                               \
14038:     return (rv);                                                              \
14038:   }
14038: 
14038: #define NS_ENSURE_FINITE5(f1, f2, f3, f4, f5, rv)                             \
14038:   if (!NS_FloatIsFinite((f1)+(f2)+(f3)+(f4)+(f5))) {                          \
14038:     return (rv);                                                              \
14038:   }
14038: 
14038: #define NS_ENSURE_FINITE6(f1, f2, f3, f4, f5, f6, rv)                         \
14038:   if (!NS_FloatIsFinite((f1)+(f2)+(f3)+(f4)+(f5)+(f6))) {                     \
14038:     return (rv);                                                              \
14038:   }
14038: 
22801: // Deletes a linked list iteratively to avoid blowing up the stack (bug 460444).
22801: #define NS_CONTENT_DELETE_LIST_MEMBER(type_, ptr_, member_)                   \
22801:   {                                                                           \
22801:     type_ *cur = (ptr_)->member_;                                             \
22801:     (ptr_)->member_ = nsnull;                                                 \
22801:     while (cur) {                                                             \
22801:       type_ *next = cur->member_;                                             \
22801:       cur->member_ = nsnull;                                                  \
22801:       delete cur;                                                             \
22801:       cur = next;                                                             \
22801:     }                                                                         \
22801:   }
22801: 
22874: class nsContentTypeParser {
22874: public:
22874:   nsContentTypeParser(const nsAString& aString);
22874:   ~nsContentTypeParser();
22874: 
22874:   nsresult GetParameter(const char* aParameterName, nsAString& aResult);
22874:   nsresult GetType(nsAString& aResult)
22874:   {
22874:     return GetParameter(nsnull, aResult);
22874:   }
22874: 
22874: private:
22874:   NS_ConvertUTF16toUTF8 mString;
22874:   nsIMIMEHeaderParam*   mService;
22874: };
22874: 
    1: #endif /* nsContentUtils_h___ */
