    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
77154:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsCOMPtr.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsComboboxControlFrame.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsFrameManager.h"
    1: #include "nsFormControlFrame.h"
    1: #include "nsGfxButtonControlFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsIFormControl.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIListControlFrame.h"
    1: #include "nsIDOMHTMLCollection.h" 
    1: #include "nsIDOMHTMLSelectElement.h" 
    1: #include "nsIDOMHTMLOptionElement.h" 
    1: #include "nsIDOMNSHTMLOptionCollectn.h" 
41071: #include "nsPIDOMWindow.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsEventDispatcher.h"
72328: #include "nsEventListenerManager.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsISelectControlFrame.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsContentUtils.h"
    1: #include "nsTextFragment.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsIDocument.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsListControlFrame.h"
    1: #include "nsContentCID.h"
    1: #ifdef ACCESSIBILITY
61464: #include "nsAccessibilityService.h"
    1: #endif
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsStyleSet.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsDisplayList.h"
    1: #include "nsITheme.h"
    1: #include "nsThemeConstants.h"
36462: #include "nsPLDOMEvent.h"
68487: #include "nsRenderingContext.h"
70840: #include "mozilla/Preferences.h"
    1: 
70840: using namespace mozilla;
56805: 
    1: NS_IMETHODIMP
    1: nsComboboxControlFrame::RedisplayTextEvent::Run()
    1: {
    1:   if (mControlFrame)
    1:     mControlFrame->HandleRedisplayTextEvent();
    1:   return NS_OK;
    1: }
    1: 
    1: class nsPresState;
    1: 
    1: #define FIX_FOR_BUG_53259
    1: 
    1: // Drop down list event management.
    1: // The combo box uses the following strategy for managing the drop-down list.
    1: // If the combo box or it's arrow button is clicked on the drop-down list is displayed
    1: // If mouse exit's the combo box with the drop-down list displayed the drop-down list
    1: // is asked to capture events
    1: // The drop-down list will capture all events including mouse down and up and will always
    1: // return with ListWasSelected method call regardless of whether an item in the list was
    1: // actually selected.
    1: // The ListWasSelected code will turn off mouse-capture for the drop-down list.
    1: // The drop-down list does not explicitly set capture when it is in the drop-down mode.
    1: 
    1: 
    1: //XXX: This is temporary. It simulates pseudo states by using a attribute selector on 
    1: 
    1: const PRInt32 kSizeNotSet = -1;
    1: 
    1: /**
    1:  * Helper class that listens to the combo boxes button. If the button is pressed the 
    1:  * combo box is toggled to open or close. this is used by Accessibility which presses
    1:  * that button Programmatically.
    1:  */
72700: class nsComboButtonListener : public nsIDOMEventListener
    1: {
    1: public:
72700:   NS_DECL_ISUPPORTS
    1: 
72700:   NS_IMETHOD HandleEvent(nsIDOMEvent*)
    1:   {
    1:     mComboBox->ShowDropDown(!mComboBox->IsDroppedDown());
 1564:     return NS_OK; 
    1:   }
    1: 
    1:   nsComboButtonListener(nsComboboxControlFrame* aCombobox) 
    1:   { 
    1:     mComboBox = aCombobox; 
    1:   }
    1: 
    1:   virtual ~nsComboButtonListener() {}
    1: 
    1:   nsComboboxControlFrame* mComboBox;
    1: };
    1: 
72700: NS_IMPL_ISUPPORTS1(nsComboButtonListener,
13964:                    nsIDOMEventListener)
    1: 
    1: // static class data member for Bug 32920
    1: nsComboboxControlFrame * nsComboboxControlFrame::mFocused = nsnull;
    1: 
    1: nsIFrame*
    1: NS_NewComboboxControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aStateFlags)
    1: {
    1:   nsComboboxControlFrame* it = new (aPresShell) nsComboboxControlFrame(aContext);
    1: 
    1:   if (it) {
    1:     // set the state flags (if any are provided)
    1:     it->AddStateBits(aStateFlags);
    1:   }
    1: 
    1:   return it;
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsComboboxControlFrame)
32423: 
78103: namespace {
78103: 
78103: class DestroyWidgetRunnable : public nsRunnable {
78103: public:
78103:   NS_DECL_NSIRUNNABLE
78103: 
78103:   explicit DestroyWidgetRunnable(nsIContent* aCombobox) :
78103:     mCombobox(aCombobox),
78103:     mWidget(GetWidget())
78103:   {
78103:   }
78103: 
78103: private:
78103:   nsIWidget* GetWidget(nsIView** aOutView = nsnull) const;
78103: 
78103: private:
78103:   nsCOMPtr<nsIContent> mCombobox;
78103:   nsIWidget* mWidget;
78103: };
78103: 
78103: NS_IMETHODIMP DestroyWidgetRunnable::Run()
78103: {
78103:   nsIView* view = nsnull;
78103:   nsIWidget* currentWidget = GetWidget(&view);
78103:   // Make sure that we are destroying the same widget as what was requested
78103:   // when the event was fired.
78103:   if (view && mWidget && mWidget == currentWidget) {
78103:     view->DestroyWidget();
78103:   }
78103: }
78103: 
78103: nsIWidget* DestroyWidgetRunnable::GetWidget(nsIView** aOutView) const
78103: {
78103:   nsIFrame* primaryFrame = mCombobox->GetPrimaryFrame();
78103:   nsIComboboxControlFrame* comboboxFrame = do_QueryFrame(primaryFrame);
78103:   if (comboboxFrame) {
78103:     nsIFrame* dropdown = comboboxFrame->GetDropDown();
78103:     if (dropdown) {
78103:       nsIView* view = dropdown->GetView();
78103:       NS_ASSERTION(view, "nsComboboxControlFrame view is null");
78103:       if (aOutView) {
78103:         *aOutView = view;
78103:       }
78103:       if (view) {
78103:         return view->GetWidget();
78103:       }
78103:     }
78103:   }
78103:   return nsnull;
78103: }
78103: 
78103: }
78103: 
    1: //-----------------------------------------------------------
    1: // Reflow Debugging Macros
    1: // These let us "see" how many reflow counts are happening
    1: //-----------------------------------------------------------
    1: #ifdef DO_REFLOW_COUNTER
    1: 
    1: #define MAX_REFLOW_CNT 1024
    1: static PRInt32 gTotalReqs    = 0;;
    1: static PRInt32 gTotalReflows = 0;;
    1: static PRInt32 gReflowControlCntRQ[MAX_REFLOW_CNT];
    1: static PRInt32 gReflowControlCnt[MAX_REFLOW_CNT];
    1: static PRInt32 gReflowInx = -1;
    1: 
    1: #define REFLOW_COUNTER() \
    1:   if (mReflowId > -1) \
    1:     gReflowControlCnt[mReflowId]++;
    1: 
    1: #define REFLOW_COUNTER_REQUEST() \
    1:   if (mReflowId > -1) \
    1:     gReflowControlCntRQ[mReflowId]++;
    1: 
    1: #define REFLOW_COUNTER_DUMP(__desc) \
    1:   if (mReflowId > -1) {\
    1:     gTotalReqs    += gReflowControlCntRQ[mReflowId];\
    1:     gTotalReflows += gReflowControlCnt[mReflowId];\
    1:     printf("** Id:%5d %s RF: %d RQ: %d   %d/%d  %5.2f\n", \
    1:            mReflowId, (__desc), \
    1:            gReflowControlCnt[mReflowId], \
    1:            gReflowControlCntRQ[mReflowId],\
    1:            gTotalReflows, gTotalReqs, float(gTotalReflows)/float(gTotalReqs)*100.0f);\
    1:   }
    1: 
    1: #define REFLOW_COUNTER_INIT() \
    1:   if (gReflowInx < MAX_REFLOW_CNT) { \
    1:     gReflowInx++; \
    1:     mReflowId = gReflowInx; \
    1:     gReflowControlCnt[mReflowId] = 0; \
    1:     gReflowControlCntRQ[mReflowId] = 0; \
    1:   } else { \
    1:     mReflowId = -1; \
    1:   }
    1: 
    1: // reflow messages
    1: #define REFLOW_DEBUG_MSG(_msg1) printf((_msg1))
    1: #define REFLOW_DEBUG_MSG2(_msg1, _msg2) printf((_msg1), (_msg2))
    1: #define REFLOW_DEBUG_MSG3(_msg1, _msg2, _msg3) printf((_msg1), (_msg2), (_msg3))
    1: #define REFLOW_DEBUG_MSG4(_msg1, _msg2, _msg3, _msg4) printf((_msg1), (_msg2), (_msg3), (_msg4))
    1: 
    1: #else //-------------
    1: 
    1: #define REFLOW_COUNTER_REQUEST() 
    1: #define REFLOW_COUNTER() 
    1: #define REFLOW_COUNTER_DUMP(__desc) 
    1: #define REFLOW_COUNTER_INIT() 
    1: 
    1: #define REFLOW_DEBUG_MSG(_msg) 
    1: #define REFLOW_DEBUG_MSG2(_msg1, _msg2) 
    1: #define REFLOW_DEBUG_MSG3(_msg1, _msg2, _msg3) 
    1: #define REFLOW_DEBUG_MSG4(_msg1, _msg2, _msg3, _msg4) 
    1: 
    1: 
    1: #endif
    1: 
    1: //------------------------------------------
    1: // This is for being VERY noisy
    1: //------------------------------------------
    1: #ifdef DO_VERY_NOISY
    1: #define REFLOW_NOISY_MSG(_msg1) printf((_msg1))
    1: #define REFLOW_NOISY_MSG2(_msg1, _msg2) printf((_msg1), (_msg2))
    1: #define REFLOW_NOISY_MSG3(_msg1, _msg2, _msg3) printf((_msg1), (_msg2), (_msg3))
    1: #define REFLOW_NOISY_MSG4(_msg1, _msg2, _msg3, _msg4) printf((_msg1), (_msg2), (_msg3), (_msg4))
    1: #else
    1: #define REFLOW_NOISY_MSG(_msg) 
    1: #define REFLOW_NOISY_MSG2(_msg1, _msg2) 
    1: #define REFLOW_NOISY_MSG3(_msg1, _msg2, _msg3) 
    1: #define REFLOW_NOISY_MSG4(_msg1, _msg2, _msg3, _msg4) 
    1: #endif
    1: 
    1: //------------------------------------------
    1: // Displays value in pixels or twips
    1: //------------------------------------------
    1: #ifdef DO_PIXELS
    1: #define PX(__v) __v / 15
    1: #else
    1: #define PX(__v) __v 
    1: #endif
    1: 
    1: //------------------------------------------------------
    1: //-- Done with macros
    1: //------------------------------------------------------
    1: 
    1: nsComboboxControlFrame::nsComboboxControlFrame(nsStyleContext* aContext)
23176:   : nsBlockFrame(aContext),
    1:     mDisplayWidth(0)
    1: {
    1:   mListControlFrame            = nsnull;
    1:   mDroppedDown                 = PR_FALSE;
    1:   mDisplayFrame                = nsnull;
    1:   mButtonFrame                 = nsnull;
    1:   mDropdownFrame               = nsnull;
    1: 
    1:   mInRedisplayText = PR_FALSE;
    1: 
    1:   mRecentSelectedIndex = NS_SKIP_NOTIFY_INDEX;
    1: 
    1:   REFLOW_COUNTER_INIT()
    1: }
    1: 
    1: //--------------------------------------------------------------
    1: nsComboboxControlFrame::~nsComboboxControlFrame()
    1: {
    1:   REFLOW_COUNTER_DUMP("nsCCF");
    1: }
    1: 
    1: //--------------------------------------------------------------
23554: 
23554: NS_QUERYFRAME_HEAD(nsComboboxControlFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIComboboxControlFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIFormControlFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
23554:   NS_QUERYFRAME_ENTRY(nsISelectControlFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIStatefulFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsBlockFrame)
23554: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsComboboxControlFrame::CreateAccessible()
    1: {
61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
    1:   if (accService) {
46338:     return accService->CreateHTMLComboboxAccessible(mContent,
46338:                                                     PresContext()->PresShell());
    1:   }
    1: 
46338:   return nsnull;
    1: }
    1: #endif
    1: 
    1: void 
    1: nsComboboxControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)
    1: {
    1:   nsWeakFrame weakFrame(this);
    1:   if (aOn) {
    1:     nsListControlFrame::ComboboxFocusSet();
    1:     mFocused = this;
    1:   } else {
    1:     mFocused = nsnull;
    1:     if (mDroppedDown) {
 1564:       mListControlFrame->ComboboxFinish(mDisplayedIndex); // might destroy us
 1564:       if (!weakFrame.IsAlive()) {
 1564:         return;
 1564:       }
    1:     }
    1:     // May delete |this|.
    1:     mListControlFrame->FireOnChange();
    1:   }
    1: 
    1:   if (!weakFrame.IsAlive()) {
    1:     return;
    1:   }
    1: 
    1:   // This is needed on a temporary basis. It causes the focus
    1:   // rect to be drawn. This is much faster than ReResolvingStyle
    1:   // Bug 32920
19380:   Invalidate(nsRect(0,0,mRect.width,mRect.height));
    1: 
    1:   // Make sure the content area gets updated for where the dropdown was
    1:   // This is only needed for embedding, the focus may go to 
    1:   // the chrome that is not part of the Gecko system (Bug 83493)
    1:   // XXX this is rather inefficient
26050:   nsIViewManager* vm = PresContext()->GetPresShell()->GetViewManager();
    1:   if (vm) {
    1:     vm->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
    1:   }
    1: }
    1: 
    1: void
    1: nsComboboxControlFrame::ShowPopup(PRBool aShowPopup)
    1: {
    1:   nsIView* view = mDropdownFrame->GetView();
    1:   nsIViewManager* viewManager = view->GetViewManager();
    1: 
    1:   if (aShowPopup) {
    1:     nsRect rect = mDropdownFrame->GetRect();
    1:     rect.x = rect.y = 0;
    1:     viewManager->ResizeView(view, rect);
    1:     viewManager->SetViewVisibility(view, nsViewVisibility_kShow);
    1:   } else {
    1:     viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
    1:     nsRect emptyRect(0, 0, 0, 0);
    1:     viewManager->ResizeView(view, emptyRect);
    1:   }
    1: 
    1:   // fire a popup dom event
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsMouseEvent event(PR_TRUE, aShowPopup ?
    1:                      NS_XUL_POPUP_SHOWING : NS_XUL_POPUP_HIDING, nsnull,
    1:                      nsMouseEvent::eReal);
    1: 
  238:   nsCOMPtr<nsIPresShell> shell = PresContext()->GetPresShell();
    1:   if (shell) 
    1:     shell->HandleDOMEventWithTarget(mContent, &event, &status);
    1: }
    1: 
 1564: PRBool
32187: nsComboboxControlFrame::ShowList(PRBool aShowList)
    1: {
 1564:   nsCOMPtr<nsIPresShell> shell = PresContext()->GetPresShell();
    1: 
 1564:   nsWeakFrame weakFrame(this);
63824: 
63824:   if (aShowList) {
63824:     nsIView* view = mDropdownFrame->GetView();
63824:     NS_ASSERTION(!view->HasWidget(),
63824:                  "We shoudldn't have a widget before we need to display the popup");
63824: 
63824:     // Create the widget for the drop-down list
63824:     view->GetViewManager()->SetViewFloating(view, PR_TRUE);
63824: 
63824:     nsWidgetInitData widgetData;
63824:     widgetData.mWindowType  = eWindowType_popup;
63824:     widgetData.mBorderStyle = eBorderStyle_default;
63824:     view->CreateWidgetForPopup(&widgetData);
63824:   }
63824: 
 1564:   ShowPopup(aShowList);  // might destroy us
 1564:   if (!weakFrame.IsAlive()) {
 1564:     return PR_FALSE;
 1564:   }
 1564: 
 1564:   mDroppedDown = aShowList;
 1564:   if (mDroppedDown) {
 1564:     // The listcontrol frame will call back to the nsComboboxControlFrame's
 1564:     // ListWasSelected which will stop the capture.
 1564:     mListControlFrame->AboutToDropDown();
 1564:     mListControlFrame->CaptureMouseEvents(PR_TRUE);
 1564:   }
 1564: 
 4886:   // XXXbz so why do we need to flush here, exactly?
 4886:   shell->GetDocument()->FlushPendingNotifications(Flush_Layout);
 1564:   if (!weakFrame.IsAlive()) {
 1564:     return PR_FALSE;
 1564:   }
 1564: 
23554:   nsIFrame* listFrame = do_QueryFrame(mListControlFrame);
 1564:   if (listFrame) {
    1:     nsIView* view = listFrame->GetView();
    1:     NS_ASSERTION(view, "nsComboboxControlFrame view is null");
    1:     if (view) {
 1564:       nsIWidget* widget = view->GetWidget();
63824:       if (widget) {
36806:         widget->CaptureRollupEvents(this, nsnull, mDroppedDown, mDroppedDown);
63824: 
63824:         if (!aShowList) {
78103:           nsCOMPtr<nsIRunnable> widgetDestroyer =
78103:             new DestroyWidgetRunnable(GetContent());
78103:           NS_DispatchToMainThread(widgetDestroyer);
63824:         }
63824:       }
    1:     }
    1:   }
    1: 
 1564:   return weakFrame.IsAlive();
    1: }
    1: 
    1: nsresult
    1: nsComboboxControlFrame::ReflowDropdown(nsPresContext*  aPresContext, 
    1:                                        const nsHTMLReflowState& aReflowState)
    1: {
    1:   // All we want out of it later on, really, is the height of a row, so we
    1:   // don't even need to cache mDropdownFrame's ascent or anything.  If we don't
    1:   // need to reflow it, just bail out here.
    1:   if (!aReflowState.ShouldReflowAllKids() &&
 1158:       !NS_SUBTREE_DIRTY(mDropdownFrame)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // XXXbz this will, for small-height dropdowns, have extra space on the right
    1:   // edge for the scrollbar we don't show... but that's the best we can do here
    1:   // for now.
    1:   nsSize availSize(aReflowState.availableWidth, NS_UNCONSTRAINEDSIZE);
    1:   nsHTMLReflowState kidReflowState(aPresContext, aReflowState, mDropdownFrame,
    1:                                    availSize);
    1: 
    1:   // If the dropdown's intrinsic width is narrower than our specified width,
    1:   // then expand it out.  We want our border-box width to end up the same as
    1:   // the dropdown's so account for both sets of mComputedBorderPadding.
    1:   nscoord forcedWidth = aReflowState.ComputedWidth() +
    1:     aReflowState.mComputedBorderPadding.LeftRight() -
    1:     kidReflowState.mComputedBorderPadding.LeftRight();
32531:   kidReflowState.SetComputedWidth(NS_MAX(kidReflowState.ComputedWidth(),
    1:                                          forcedWidth));
    1: 
    1:   // ensure we start off hidden
    1:   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
    1:     nsIView* view = mDropdownFrame->GetView();
    1:     nsIViewManager* viewManager = view->GetViewManager();
    1:     viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
    1:     nsRect emptyRect(0, 0, 0, 0);
    1:     viewManager->ResizeView(view, emptyRect);
    1:   }
    1:   
    1:   // Allow the child to move/size/change-visibility its view if it's currently
    1:   // dropped down
18884:   PRInt32 flags = NS_FRAME_NO_MOVE_FRAME | NS_FRAME_NO_VISIBILITY | NS_FRAME_NO_SIZE_VIEW;
    1:   if (mDroppedDown) {
    1:     flags = 0;
    1:   }
    1:   nsRect rect = mDropdownFrame->GetRect();
    1:   nsHTMLReflowMetrics desiredSize;
    1:   nsReflowStatus ignoredStatus;
    1:   nsresult rv = ReflowChild(mDropdownFrame, aPresContext, desiredSize,
    1:                             kidReflowState, rect.x, rect.y, flags,
    1:                             ignoredStatus);
    1:  
    1:    // Set the child's width and height to it's desired size
    1:   FinishReflowChild(mDropdownFrame, aPresContext, &kidReflowState,
    1:                     desiredSize, rect.x, rect.y, flags);
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsComboboxControlFrame::AbsolutelyPositionDropDown()
    1: {
    1:    // Position the dropdown list. It is positioned below the display frame if there is enough
    1:    // room on the screen to display the entire list. Otherwise it is placed above the display
    1:    // frame.
    1: 
    1:    // Note: As first glance, it appears that you could simply get the absolute bounding box for the
    1:    // dropdown list by first getting its view, then getting the view's nsIWidget, then asking the nsIWidget
    1:    // for it's AbsoluteBounds. The problem with this approach, is that the dropdown lists y location can
    1:    // change based on whether the dropdown is placed below or above the display frame.
    1:    // The approach, taken here is to get use the absolute position of the display frame and use it's location
    1:    // to determine if the dropdown will go offscreen.
    1: 
    1:    // Use the height calculated for the area frame so it includes both
    1:    // the display and button heights.
    1:   nscoord dropdownYOffset = GetRect().height;
    1:   nsSize dropdownSize = mDropdownFrame->GetSize();
    1: 
31622:   nsRect screen = nsFormControlFrame::GetUsableScreenRect(PresContext());
31622: 
    1:   // Check to see if the drop-down list will go offscreen
31622:   if (GetScreenRectInAppUnits().YMost() + dropdownSize.height > screen.YMost()) {
    1:     // move the dropdown list up
    1:     dropdownYOffset = - (dropdownSize.height);
    1:   }
    1: 
    1:   nsPoint dropdownPosition;
    1:   const nsStyleVisibility* vis = GetStyleVisibility();
    1:   if (vis->mDirection == NS_STYLE_DIRECTION_RTL) {
    1:     // Align the right edge of the drop-down with the right edge of the control.
    1:     dropdownPosition.x = GetRect().width - dropdownSize.width;
    1:   } else {
    1:     dropdownPosition.x = 0;
    1:   }
    1:   dropdownPosition.y = dropdownYOffset; 
    1: 
    1:   mDropdownFrame->SetPosition(dropdownPosition);
    1: }
    1: 
    1: //----------------------------------------------------------
    1: // 
    1: //----------------------------------------------------------
    1: #ifdef DO_REFLOW_DEBUG
    1: static int myCounter = 0;
    1: 
    1: static void printSize(char * aDesc, nscoord aSize) 
    1: {
    1:   printf(" %s: ", aDesc);
    1:   if (aSize == NS_UNCONSTRAINEDSIZE) {
    1:     printf("UC");
    1:   } else {
    1:     printf("%d", PX(aSize));
    1:   }
    1: }
    1: #endif
    1: 
    1: //-------------------------------------------------------------------
    1: //-- Main Reflow for the Combobox
    1: //-------------------------------------------------------------------
    1: 
    1: nscoord
68481: nsComboboxControlFrame::GetIntrinsicWidth(nsRenderingContext* aRenderingContext,
 8566:                                           nsLayoutUtils::IntrinsicWidthType aType)
    1: {
 1934:   // get the scrollbar width, we'll use this later
 1934:   nscoord scrollbarWidth = 0;
 1790:   nsPresContext* presContext = PresContext();
 1934:   if (mListControlFrame) {
23554:     nsIScrollableFrame* scrollable = do_QueryFrame(mListControlFrame);
 1108:     NS_ASSERTION(scrollable, "List must be a scrollable frame");
14159:     scrollbarWidth =
14159:       scrollable->GetDesiredScrollbarSizes(presContext, aRenderingContext).LeftRight();
 1108:   }
 1108: 
 8566:   nscoord displayWidth = 0;
 1934:   if (NS_LIKELY(mDisplayFrame)) {
 8566:     displayWidth = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
 8566:                                                         mDisplayFrame,
 8566:                                                         aType);
 1934:   }
 1934: 
 1934:   if (mDropdownFrame) {
 8566:     nscoord dropdownContentWidth;
 8566:     if (aType == nsLayoutUtils::MIN_WIDTH) {
 8566:       dropdownContentWidth = mDropdownFrame->GetMinWidth(aRenderingContext);
 8566:     } else {
 8566:       NS_ASSERTION(aType == nsLayoutUtils::PREF_WIDTH, "Unexpected type");
 8566:       dropdownContentWidth = mDropdownFrame->GetPrefWidth(aRenderingContext);
 8566:     }
 9423:     dropdownContentWidth = NSCoordSaturatingSubtract(dropdownContentWidth, 
 9423:                                                      scrollbarWidth,
 9423:                                                      nscoord_MAX);
 8566:   
32531:     displayWidth = NS_MAX(dropdownContentWidth, displayWidth);
 1934:   }
 1934: 
 1934:   // add room for the dropmarker button if there is one
 1934:   if (!IsThemed() || presContext->GetTheme()->ThemeNeedsComboboxDropmarker())
 8566:     displayWidth += scrollbarWidth;
 1934: 
 8566:   return displayWidth;
 8566: 
 8566: }
 8566: 
 8566: nscoord
68481: nsComboboxControlFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
 8566: {
 8566:   nscoord minWidth;
 8566:   DISPLAY_MIN_WIDTH(this, minWidth);
 8566:   minWidth = GetIntrinsicWidth(aRenderingContext, nsLayoutUtils::MIN_WIDTH);
 8566:   return minWidth;
 8566: }
 8566: 
 8566: nscoord
68481: nsComboboxControlFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
 8566: {
 8566:   nscoord prefWidth;
 8566:   DISPLAY_PREF_WIDTH(this, prefWidth);
 8566:   prefWidth = GetIntrinsicWidth(aRenderingContext, nsLayoutUtils::PREF_WIDTH);
 8566:   return prefWidth;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsComboboxControlFrame::Reflow(nsPresContext*          aPresContext, 
    1:                                nsHTMLReflowMetrics&     aDesiredSize,
    1:                                const nsHTMLReflowState& aReflowState, 
    1:                                nsReflowStatus&          aStatus)
    1: {
    1:   // Constraints we try to satisfy:
    1: 
    1:   // 1) Default width of button is the vertical scrollbar size
    1:   // 2) If the width of button is bigger than our width, set width of
    1:   //    button to 0.
    1:   // 3) Default height of button is height of display area
    1:   // 4) Width of display area is whatever is left over from our width after
    1:   //    allocating width for the button.
    1:   // 5) Height of display area is GetHeightOfARow() on the
    1:   //    mListControlFrame.
    1: 
    1:   if (!mDisplayFrame || !mButtonFrame || !mDropdownFrame) {
    1:     NS_ERROR("Why did the frame constructor allow this to happen?  Fix it!!");
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   // Make sure the displayed text is the same as the selected option, bug 297389.
    1:   PRInt32 selectedIndex;
    1:   nsAutoString selectedOptionText;
    1:   if (!mDroppedDown) {
    1:     selectedIndex = mListControlFrame->GetSelectedIndex();
    1:   }
    1:   else {
    1:     // In dropped down mode the "selected index" is the hovered menu item,
    1:     // we want the last selected item which is |mDisplayedIndex| in this case.
    1:     selectedIndex = mDisplayedIndex;
    1:   }
    1:   if (selectedIndex != -1) {
    1:     mListControlFrame->GetOptionText(selectedIndex, selectedOptionText);
    1:   }
    1:   if (mDisplayedOptionText != selectedOptionText) {
    1:     RedisplayText(selectedIndex);
    1:   }
    1: 
    1:   // First reflow our dropdown so that we know how tall we should be.
    1:   ReflowDropdown(aPresContext, aReflowState);
    1: 
    1:   // Get the width of the vertical scrollbar.  That will be the width of the
    1:   // dropdown button.
 1582:   nscoord buttonWidth;
 1582:   const nsStyleDisplay *disp = GetStyleDisplay();
 1582:   if (IsThemed(disp) && !aPresContext->GetTheme()->ThemeNeedsComboboxDropmarker()) {
 1582:     buttonWidth = 0;
 1582:   }
 1582:   else {
23554:     nsIScrollableFrame* scrollable = do_QueryFrame(mListControlFrame);
    1:     NS_ASSERTION(scrollable, "List must be a scrollable frame");
14159:     buttonWidth =
14159:       scrollable->GetDesiredScrollbarSizes(PresContext(), 
14159:                                            aReflowState.rendContext).LeftRight();
    1:     if (buttonWidth > aReflowState.ComputedWidth()) {
    1:       buttonWidth = 0;
    1:     }
 1582:   }
    1: 
    1:   mDisplayWidth = aReflowState.ComputedWidth() - buttonWidth;
    1: 
23176:   nsresult rv = nsBlockFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
    1:                                     aStatus);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Now set the correct width and height on our button.  The width we need to
    1:   // set always, the height only if we had an auto height.
    1:   nsRect buttonRect = mButtonFrame->GetRect();
    1:   // If we have a non-intrinsic computed height, our kids should have sized
    1:   // themselves properly on their own.
 4166:   if (aReflowState.ComputedHeight() == NS_INTRINSICSIZE) {
    1:     // The display frame is going to be the right height and width at this
    1:     // point. Use its height as the button height.
    1:     nsRect displayRect = mDisplayFrame->GetRect();
    1:     buttonRect.height = displayRect.height;
    1:     buttonRect.y = displayRect.y;
    1:   }
    1: #ifdef DEBUG
    1:   else {
  820:     nscoord buttonHeight = mButtonFrame->GetSize().height;
  820:     nscoord displayHeight = mDisplayFrame->GetSize().height;
  820: 
  820:     // The button and display area should be equal heights, unless the computed
  820:     // height on the combobox is too small to fit their borders and padding.
  820:     NS_ASSERTION(buttonHeight == displayHeight ||
 4166:                  (aReflowState.ComputedHeight() < buttonHeight &&
  820:                   buttonHeight ==
  820:                     mButtonFrame->GetUsedBorderAndPadding().TopBottom()) ||
 4166:                  (aReflowState.ComputedHeight() < displayHeight &&
  820:                   displayHeight ==
  820:                     mDisplayFrame->GetUsedBorderAndPadding().TopBottom()),
    1:                  "Different heights?");
    1:   }
    1: #endif
    1:   
    1:   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
    1:     // Make sure the right edge of the button frame stays where it is now
    1:     buttonRect.x -= buttonWidth - buttonRect.width;
    1:   }
    1:   buttonRect.width = buttonWidth;
    1:   mButtonFrame->SetRect(buttonRect);
    1:   
    1:   return rv;
    1: }
    1: 
    1: //--------------------------------------------------------------
    1: 
    1: nsIAtom*
    1: nsComboboxControlFrame::GetType() const
    1: {
    1:   return nsGkAtoms::comboboxControlFrame; 
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
    1: nsComboboxControlFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("ComboboxControl"), aResult);
    1: }
    1: #endif
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIComboboxControlFrame
    1: //----------------------------------------------------------------------
    1: void
    1: nsComboboxControlFrame::ShowDropDown(PRBool aDoDropDown) 
    1: {
71116:   nsEventStates eventStates = mContent->AsElement()->State();
56168:   if (eventStates.HasState(NS_EVENT_STATE_DISABLED)) {
    1:     return;
    1:   }
    1: 
    1:   if (!mDroppedDown && aDoDropDown) {
    1:     if (mListControlFrame) {
    1:       mListControlFrame->SyncViewWithFrame();
    1:     }
32187:     ShowList(aDoDropDown); // might destroy us
    1:   } else if (mDroppedDown && !aDoDropDown) {
32187:     ShowList(aDoDropDown); // might destroy us
    1:   }
    1: }
    1: 
    1: void
    1: nsComboboxControlFrame::SetDropDown(nsIFrame* aDropDownFrame)
    1: {
    1:   mDropdownFrame = aDropDownFrame;
23554:   mListControlFrame = do_QueryFrame(mDropdownFrame);
    1: }
    1: 
    1: nsIFrame*
    1: nsComboboxControlFrame::GetDropDown() 
    1: {
    1:   return mDropdownFrame;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////
    1: 
    1: NS_IMETHODIMP
    1: nsComboboxControlFrame::RedisplaySelectedText()
    1: {
25115:   nsAutoScriptBlocker scriptBlocker;
    1:   return RedisplayText(mListControlFrame->GetSelectedIndex());
    1: }
    1: 
    1: nsresult
    1: nsComboboxControlFrame::RedisplayText(PRInt32 aIndex)
    1: {
    1:   // Get the text to display
    1:   if (aIndex != -1) {
    1:     mListControlFrame->GetOptionText(aIndex, mDisplayedOptionText);
    1:   } else {
    1:     mDisplayedOptionText.Truncate();
    1:   }
    1:   mDisplayedIndex = aIndex;
    1: 
    1:   REFLOW_DEBUG_MSG2("RedisplayText \"%s\"\n",
    1:                     NS_LossyConvertUTF16toASCII(mDisplayedOptionText).get());
    1: 
    1:   // Send reflow command because the new text maybe larger
    1:   nsresult rv = NS_OK;
    1:   if (mDisplayContent) {
    1:     // Don't call ActuallyDisplayText(PR_TRUE) directly here since that
    1:     // could cause recursive frame construction. See bug 283117 and the comment in
    1:     // HandleRedisplayTextEvent() below.
    1: 
    1:     // Revoke outstanding events to avoid out-of-order events which could mean
    1:     // displaying the wrong text.
    1:     mRedisplayTextEvent.Revoke();
    1: 
25115:     NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
25115:                  "If we happen to run our redisplay event now, we might kill "
25115:                  "ourselves!");
25115: 
    1:     nsRefPtr<RedisplayTextEvent> event = new RedisplayTextEvent(this);
    1:     mRedisplayTextEvent = event;
25115:     if (!nsContentUtils::AddScriptRunner(event))
25115:       mRedisplayTextEvent.Forget();
    1:   }
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsComboboxControlFrame::HandleRedisplayTextEvent()
    1: {
    1:   // First, make sure that the content model is up to date and we've
    1:   // constructed the frames for all our content in the right places.
    1:   // Otherwise they'll end up under the wrong insertion frame when we
    1:   // ActuallyDisplayText, since that flushes out the content sink by
    1:   // calling SetText on a DOM node with aNotify set to true.  See bug
    1:   // 289730.
34150:   nsWeakFrame weakThis(this);
  238:   PresContext()->Document()->
    1:     FlushPendingNotifications(Flush_ContentAndNotify);
34150:   if (!weakThis.IsAlive())
34150:     return;
    1: 
    1:   // Redirect frame insertions during this method (see GetContentInsertionFrame())
    1:   // so that any reframing that the frame constructor forces upon us is inserted
    1:   // into the correct parent (mDisplayFrame). See bug 282607.
    1:   NS_PRECONDITION(!mInRedisplayText, "Nested RedisplayText");
    1:   mInRedisplayText = PR_TRUE;
    1:   mRedisplayTextEvent.Forget();
    1: 
    1:   ActuallyDisplayText(PR_TRUE);
    1:   // XXXbz This should perhaps be eResize.  Check.
  238:   PresContext()->PresShell()->FrameNeedsReflow(mDisplayFrame,
 1158:                                                nsIPresShell::eStyleChange,
 1158:                                                NS_FRAME_IS_DIRTY);
    1: 
    1:   mInRedisplayText = PR_FALSE;
    1: }
    1: 
    1: void
    1: nsComboboxControlFrame::ActuallyDisplayText(PRBool aNotify)
    1: {
    1:   if (mDisplayedOptionText.IsEmpty()) {
    1:     // Have to use a non-breaking space for line-height calculations
    1:     // to be right
    1:     static const PRUnichar space = 0xA0;
    1:     mDisplayContent->SetText(&space, 1, aNotify);
    1:   } else {
    1:     mDisplayContent->SetText(mDisplayedOptionText, aNotify);
    1:   }
    1: }
    1: 
    1: PRInt32
    1: nsComboboxControlFrame::GetIndexOfDisplayArea()
    1: {
    1:   return mDisplayedIndex;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsISelectControlFrame
    1: //----------------------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsComboboxControlFrame::DoneAddingChildren(PRBool aIsDone)
    1: {
23554:   nsISelectControlFrame* listFrame = do_QueryFrame(mDropdownFrame);
23554:   if (!listFrame)
23554:     return NS_ERROR_FAILURE;
23554: 
23554:   return listFrame->DoneAddingChildren(aIsDone);
    1: }
    1: 
    1: NS_IMETHODIMP
25115: nsComboboxControlFrame::AddOption(PRInt32 aIndex)
    1: {
    1:   if (aIndex <= mDisplayedIndex) {
    1:     ++mDisplayedIndex;
    1:   }
    1: 
 3233:   nsListControlFrame* lcf = static_cast<nsListControlFrame*>(mDropdownFrame);
25115:   return lcf->AddOption(aIndex);
    1: }
    1:   
    1: 
    1: NS_IMETHODIMP
25115: nsComboboxControlFrame::RemoveOption(PRInt32 aIndex)
    1: {
34150:   nsWeakFrame weakThis(this);
    1:   if (mListControlFrame->GetNumberOfOptions() > 0) {
    1:     if (aIndex < mDisplayedIndex) {
    1:       --mDisplayedIndex;
    1:     } else if (aIndex == mDisplayedIndex) {
    1:       mDisplayedIndex = 0; // IE6 compat
    1:       RedisplayText(mDisplayedIndex);
    1:     }
    1:   }
    1:   else {
    1:     // If we removed the last option, we need to blank things out
    1:     RedisplayText(-1);
    1:   }
    1: 
34150:   if (!weakThis.IsAlive())
34150:     return NS_OK;
34150: 
 3233:   nsListControlFrame* lcf = static_cast<nsListControlFrame*>(mDropdownFrame);
25115:   return lcf->RemoveOption(aIndex);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsComboboxControlFrame::OnSetSelectedIndex(PRInt32 aOldIndex, PRInt32 aNewIndex)
    1: {
25115:   nsAutoScriptBlocker scriptBlocker;
 4890:   RedisplayText(aNewIndex);
    1:   NS_ASSERTION(mDropdownFrame, "No dropdown frame!");
    1:   
23554:   nsISelectControlFrame* listFrame = do_QueryFrame(mDropdownFrame);
    1:   NS_ASSERTION(listFrame, "No list frame!");
    1: 
    1:   return listFrame->OnSetSelectedIndex(aOldIndex, aNewIndex);
    1: }
    1: 
    1: // End nsISelectControlFrame
    1: //----------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP 
    1: nsComboboxControlFrame::HandleEvent(nsPresContext* aPresContext, 
    1:                                        nsGUIEvent*     aEvent,
    1:                                        nsEventStatus*  aEventStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
    1: 
    1:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus) {
    1:     return NS_OK;
    1:   }
54343: 
71116:   nsEventStates eventStates = mContent->AsElement()->State();
56168:   if (eventStates.HasState(NS_EVENT_STATE_DISABLED)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If we have style that affects how we are selected, feed event down to
    1:   // nsFrame::HandleEvent so that selection takes place when appropriate.
    1:   const nsStyleUserInterface* uiStyle = GetStyleUserInterface();
    1:   if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE || uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED)
23176:     return nsBlockFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
    1:     
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsComboboxControlFrame::SetFormProperty(nsIAtom* aName, const nsAString& aValue)
    1: {
23554:   nsIFormControlFrame* fcFrame = do_QueryFrame(mDropdownFrame);
23554:   if (!fcFrame) {
23554:     return NS_NOINTERFACE;
    1:   }
23554: 
    1:   return fcFrame->SetFormProperty(aName, aValue);
    1: }
    1: 
    1: nsresult 
    1: nsComboboxControlFrame::GetFormProperty(nsIAtom* aName, nsAString& aValue) const
    1: {
23554:   nsIFormControlFrame* fcFrame = do_QueryFrame(mDropdownFrame);
23554:   if (!fcFrame) {
23554:     return NS_ERROR_FAILURE;
    1:   }
23554: 
    1:   return fcFrame->GetFormProperty(aName, aValue);
    1: }
    1: 
    1: nsIFrame*
    1: nsComboboxControlFrame::GetContentInsertionFrame() {
    1:   return mInRedisplayText ? mDisplayFrame : mDropdownFrame->GetContentInsertionFrame();
    1: }
    1: 
    1: nsresult
69438: nsComboboxControlFrame::CreateAnonymousContent(nsTArray<ContentInfo>& aElements)
    1: {
    1:   // The frames used to display the combo box and the button used to popup the dropdown list
    1:   // are created through anonymous content. The dropdown list is not created through anonymous
    1:   // content because it's frame is initialized specifically for the drop-down case and it is placed
    1:   // a special list referenced through NS_COMBO_FRAME_POPUP_LIST_INDEX to keep separate from the
    1:   // layout of the display and button. 
    1:   //
    1:   // Note: The value attribute of the display content is set when an item is selected in the dropdown list.
    1:   // If the content specified below does not honor the value attribute than nothing will be displayed.
    1: 
    1:   // For now the content that is created corresponds to two input buttons. It would be better to create the
    1:   // tag as something other than input, but then there isn't any way to create a button frame since it
    1:   // isn't possible to set the display type in CSS2 to create a button frame.
    1: 
    1:     // create content used for display
    1:   //nsIAtom* tag = NS_NewAtom("mozcombodisplay");
    1: 
    1:   // Add a child text content node for the label
    1: 
    1:   nsNodeInfoManager *nimgr = mContent->NodeInfo()->NodeInfoManager();
    1: 
    1:   NS_NewTextNode(getter_AddRefs(mDisplayContent), nimgr);
    1:   if (!mDisplayContent)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // set the value of the text node
    1:   mDisplayedIndex = mListControlFrame->GetSelectedIndex();
    1:   if (mDisplayedIndex != -1) {
    1:     mListControlFrame->GetOptionText(mDisplayedIndex, mDisplayedOptionText);
    1:   }
    1:   ActuallyDisplayText(PR_FALSE);
    1: 
    1:   if (!aElements.AppendElement(mDisplayContent))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
71770:   nodeInfo = nimgr->GetNodeInfo(nsGkAtoms::button, nsnull, kNameSpaceID_XHTML,
71770:                                 nsIDOMNode::ELEMENT_NODE);
    1: 
    1:   // create button which drops the list down
48124:   NS_NewHTMLElement(getter_AddRefs(mButtonContent), nodeInfo.forget(),
56805:                     dom::NOT_FROM_PARSER);
    1:   if (!mButtonContent)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // make someone to listen to the button. If its pressed by someone like Accessibility
    1:   // then open or close the combo box.
    1:   mButtonListener = new nsComboButtonListener(this);
72700:   mButtonContent->AddEventListener(NS_LITERAL_STRING("click"), mButtonListener,
72700:                                    PR_FALSE, PR_FALSE);
    1: 
    1:   mButtonContent->SetAttr(kNameSpaceID_None, nsGkAtoms::type,
    1:                           NS_LITERAL_STRING("button"), PR_FALSE);
    1:   // Set tabindex="-1" so that the button is not tabbable
    1:   mButtonContent->SetAttr(kNameSpaceID_None, nsGkAtoms::tabindex,
    1:                           NS_LITERAL_STRING("-1"), PR_FALSE);
    1: 
    1:   if (!aElements.AppendElement(mButtonContent))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   return NS_OK;
    1: }
    1: 
38069: void
55877: nsComboboxControlFrame::AppendAnonymousContentTo(nsBaseContentList& aElements,
55877:                                                  PRUint32 aFilter)
38069: {
38069:   aElements.MaybeAppendElement(mDisplayContent);
38069:   aElements.MaybeAppendElement(mButtonContent);
38069: }
38069: 
    1: // XXXbz this is a for-now hack.  Now that display:inline-block works,
    1: // need to revisit this.
    1: class nsComboboxDisplayFrame : public nsBlockFrame {
    1: public:
32423:   NS_DECL_FRAMEARENA_HELPERS
32423: 
    1:   nsComboboxDisplayFrame (nsStyleContext* aContext,
    1:                           nsComboboxControlFrame* aComboBox)
    1:     : nsBlockFrame(aContext),
    1:       mComboBox(aComboBox)
    1:   {}
    1: 
    1:   // Need this so that line layout knows that this block's width
    1:   // depends on the available width.
    1:   virtual nsIAtom* GetType() const;
    1: 
    1:   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
    1:   {
    1:     return nsBlockFrame::IsFrameOfType(aFlags &
    1:       ~(nsIFrame::eReplacedContainsBlock));
    1:   }
    1: 
    1:   NS_IMETHOD Reflow(nsPresContext*           aPresContext,
    1:                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus);
    1: 
 1710:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
 1710:                               const nsRect&           aDirtyRect,
 1710:                               const nsDisplayListSet& aLists);
 1710: 
    1: protected:
    1:   nsComboboxControlFrame* mComboBox;
    1: };
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsComboboxDisplayFrame)
32423: 
    1: nsIAtom*
    1: nsComboboxDisplayFrame::GetType() const
    1: {
    1:   return nsGkAtoms::comboboxDisplayFrame;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsComboboxDisplayFrame::Reflow(nsPresContext*           aPresContext,
    1:                                nsHTMLReflowMetrics&     aDesiredSize,
    1:                                const nsHTMLReflowState& aReflowState,
    1:                                nsReflowStatus&          aStatus)
    1: {
    1:   nsHTMLReflowState state(aReflowState);
 4166:   if (state.ComputedHeight() == NS_INTRINSICSIZE) {
    1:     // Note that the only way we can have a computed height here is if the
    1:     // combobox had a specified height.  If it didn't, size based on what our
    1:     // rows look like, for lack of anything better.
 4166:     state.SetComputedHeight(mComboBox->mListControlFrame->GetHeightOfARow());
    1:   }
    1:   nscoord computedWidth = mComboBox->mDisplayWidth -
    1:     state.mComputedBorderPadding.LeftRight(); 
    1:   if (computedWidth < 0) {
    1:     computedWidth = 0;
    1:   }
    1:   state.SetComputedWidth(computedWidth);
    1: 
    1:   return nsBlockFrame::Reflow(aPresContext, aDesiredSize, state, aStatus);
    1: }
    1: 
 1710: NS_IMETHODIMP
 1710: nsComboboxDisplayFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
 1710:                                          const nsRect&           aDirtyRect,
 1710:                                          const nsDisplayListSet& aLists)
 1710: {
 1710:   nsDisplayListCollection set;
 1710:   nsresult rv = nsBlockFrame::BuildDisplayList(aBuilder, aDirtyRect, set);
 1710:   if (NS_FAILED(rv))
 1710:     return rv;
 1710: 
 1710:   // remove background items if parent frame is themed
 1710:   if (mComboBox->IsThemed()) {
 1710:     set.BorderBackground()->DeleteAll();
 1710:   }
 1710: 
 1710:   set.MoveTo(aLists);
 1710: 
 1710:   return NS_OK;
 1710: }
 1710: 
    1: nsIFrame*
    1: nsComboboxControlFrame::CreateFrameFor(nsIContent*      aContent)
    1: { 
    1:   NS_PRECONDITION(nsnull != aContent, "null ptr");
    1: 
    1:   NS_ASSERTION(mDisplayContent, "mDisplayContent can't be null!");
    1: 
    1:   if (mDisplayContent != aContent) {
    1:     // We only handle the frames for mDisplayContent here
    1:     return nsnull;
    1:   }
    1:   
    1:   // Get PresShell
  238:   nsIPresShell *shell = PresContext()->PresShell();
    1:   nsStyleSet *styleSet = shell->StyleSet();
    1: 
    1:   // create the style contexts for the anonymous block frame and text frame
    1:   nsRefPtr<nsStyleContext> styleContext;
    1:   styleContext = styleSet->
35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::mozDisplayComboboxControlFrame,
    1:                              mStyleContext);
    1:   if (NS_UNLIKELY(!styleContext)) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsRefPtr<nsStyleContext> textStyleContext;
 2471:   textStyleContext = styleSet->ResolveStyleForNonElement(mStyleContext);
    1:   if (NS_UNLIKELY(!textStyleContext)) {
    1:     return nsnull;
    1:   }
    1: 
    1:   // Start by by creating our anonymous block frame
    1:   mDisplayFrame = new (shell) nsComboboxDisplayFrame(styleContext, this);
    1:   if (NS_UNLIKELY(!mDisplayFrame)) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsresult rv = mDisplayFrame->Init(mContent, this, nsnull);
    1:   if (NS_FAILED(rv)) {
    1:     mDisplayFrame->Destroy();
    1:     mDisplayFrame = nsnull;
    1:     return nsnull;
    1:   }
    1: 
    1:   // Create a text frame and put it inside the block frame
42251:   nsIFrame* textFrame = NS_NewTextFrame(shell, textStyleContext);
42251:   if (NS_UNLIKELY(!textFrame)) {
    1:     return nsnull;
    1:   }
    1: 
    1:   // initialize the text frame
42251:   rv = textFrame->Init(aContent, mDisplayFrame, nsnull);
    1:   if (NS_FAILED(rv)) {
    1:     mDisplayFrame->Destroy();
    1:     mDisplayFrame = nsnull;
42251:     textFrame->Destroy();
42251:     textFrame = nsnull;
    1:     return nsnull;
    1:   }
42251:   mDisplayContent->SetPrimaryFrame(textFrame);
    1: 
42251:   nsFrameList textList(textFrame, textFrame);
77154:   mDisplayFrame->SetInitialChildList(kPrincipalList, textList);
    1:   return mDisplayFrame;
    1: }
    1: 
    1: void
36647: nsComboboxControlFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:   // Revoke any pending RedisplayTextEvent
    1:   mRedisplayTextEvent.Revoke();
    1: 
 3233:   nsFormControlFrame::RegUnRegAccessKey(static_cast<nsIFrame*>(this), PR_FALSE);
    1: 
    1:   if (mDroppedDown) {
    1:     // Get parent view
23554:     nsIFrame * listFrame = do_QueryFrame(mListControlFrame);
23554:     if (listFrame) {
    1:       nsIView* view = listFrame->GetView();
    1:       NS_ASSERTION(view, "nsComboboxControlFrame view is null");
    1:       if (view) {
    1:         nsIWidget* widget = view->GetWidget();
    1:         if (widget)
36806:           widget->CaptureRollupEvents(this, nsnull, PR_FALSE, PR_TRUE);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Cleanup frames in popup child list
36647:   mPopupFrames.DestroyFramesFrom(aDestructRoot);
    1:   nsContentUtils::DestroyAnonymousContent(&mDisplayContent);
    1:   nsContentUtils::DestroyAnonymousContent(&mButtonContent);
36647:   nsBlockFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
30783: nsFrameList
77152: nsComboboxControlFrame::GetChildList(ChildListID aListID) const
    1: {
77152:   if (kSelectPopupList == aListID) {
30783:     return mPopupFrames;
    1:   }
77152:   return nsBlockFrame::GetChildList(aListID);
77152: }
77152: 
77152: void
77152: nsComboboxControlFrame::GetChildLists(nsTArray<ChildList>* aLists) const
77152: {
77152:   nsBlockFrame::GetChildLists(aLists);
77152:   mPopupFrames.AppendIfNonempty(aLists, kSelectPopupList);
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsComboboxControlFrame::SetInitialChildList(ChildListID     aListID,
30790:                                             nsFrameList&    aChildList)
    1: {
    1:   nsresult rv = NS_OK;
77154:   if (kSelectPopupList == aListID) {
    1:     mPopupFrames.SetFrames(aChildList);
    1:   } else {
30790:     for (nsFrameList::Enumerator e(aChildList); !e.AtEnd(); e.Next()) {
30790:       nsCOMPtr<nsIFormControl> formControl =
30790:         do_QueryInterface(e.get()->GetContent());
63940:       if (formControl && formControl->GetType() == NS_FORM_BUTTON_BUTTON) {
30790:         mButtonFrame = e.get();
    1:         break;
    1:       }
    1:     }
    1:     NS_ASSERTION(mButtonFrame, "missing button frame in initial child list");
77154:     rv = nsBlockFrame::SetInitialChildList(aListID, aChildList);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1:   //nsIRollupListener
    1: //----------------------------------------------------------------------
    1: NS_IMETHODIMP 
29148: nsComboboxControlFrame::Rollup(PRUint32 aCount,
29148:                                nsIContent** aLastRolledUp)
    1: {
 8591:   if (aLastRolledUp)
 8591:     *aLastRolledUp = nsnull;
 8591: 
    1:   if (mDroppedDown) {
 1564:     nsWeakFrame weakFrame(this);
 1564:     mListControlFrame->AboutToRollup(); // might destroy us
 1564:     if (!weakFrame.IsAlive())
 1564:       return NS_OK;
 1564:     ShowDropDown(PR_FALSE); // might destroy us
 1564:     if (!weakFrame.IsAlive())
 1564:       return NS_OK;
    1:     mListControlFrame->CaptureMouseEvents(PR_FALSE);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsComboboxControlFrame::RollupFromList()
    1: {
32187:   if (ShowList(PR_FALSE))
    1:     mListControlFrame->CaptureMouseEvents(PR_FALSE);
    1: }
    1: 
    1: PRInt32
    1: nsComboboxControlFrame::UpdateRecentIndex(PRInt32 aIndex)
    1: {
    1:   PRInt32 index = mRecentSelectedIndex;
    1:   if (mRecentSelectedIndex == NS_SKIP_NOTIFY_INDEX || aIndex == NS_SKIP_NOTIFY_INDEX)
    1:     mRecentSelectedIndex = aIndex;
    1:   return index;
    1: }
    1: 
    1: class nsDisplayComboboxFocus : public nsDisplayItem {
    1: public:
51260:   nsDisplayComboboxFocus(nsDisplayListBuilder* aBuilder,
51260:                          nsComboboxControlFrame* aFrame)
51260:     : nsDisplayItem(aBuilder, aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayComboboxFocus);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayComboboxFocus() {
    1:     MOZ_COUNT_DTOR(nsDisplayComboboxFocus);
    1:   }
    1: #endif
    1: 
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
68481:                      nsRenderingContext* aCtx);
47732:   NS_DISPLAY_DECL_NAME("ComboboxFocus", TYPE_COMBOBOX_FOCUS)
    1: };
    1: 
    1: void nsDisplayComboboxFocus::Paint(nsDisplayListBuilder* aBuilder,
68481:                                    nsRenderingContext* aCtx)
    1: {
 3233:   static_cast<nsComboboxControlFrame*>(mFrame)
51261:     ->PaintFocus(*aCtx, ToReferenceFrame());
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsComboboxControlFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                          const nsRect&           aDirtyRect,
    1:                                          const nsDisplayListSet& aLists)
    1: {
    1: #ifdef NOISY
    1:   printf("%p paint at (%d, %d, %d, %d)\n", this,
    1:     aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height);
    1: #endif
    1: 
    1:   if (aBuilder->IsForEventDelivery()) {
    1:     // Don't allow children to receive events.
    1:     // REVIEW: following old GetFrameForPoint
    1:     nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } else {
    1:     // REVIEW: Our in-flow child frames are inline-level so they will paint in our
    1:     // content list, so we don't need to mess with layers.
23176:     nsresult rv = nsBlockFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
41071:   // draw a focus indicator only when focus rings should be drawn
41071:   nsIDocument* doc = mContent->GetCurrentDoc();
41071:   if (doc) {
41071:     nsPIDOMWindow* window = doc->GetWindow();
41071:     if (window && window->ShouldShowFocusRing()) {
  238:       nsPresContext *presContext = PresContext();
    1:       const nsStyleDisplay *disp = GetStyleDisplay();
    1:       if ((!IsThemed(disp) ||
    1:            !presContext->GetTheme()->ThemeDrawsFocusForWidget(presContext, this, disp->mAppearance)) &&
    1:           mDisplayFrame && IsVisibleForPainting(aBuilder)) {
51260:         nsresult rv = aLists.Content()->AppendNewToTop(
51260:             new (aBuilder) nsDisplayComboboxFocus(aBuilder, this));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
41071:     }
41071:   }
    1: 
52291:   return DisplaySelectionOverlay(aBuilder, aLists.Content());
    1: }
    1: 
68481: void nsComboboxControlFrame::PaintFocus(nsRenderingContext& aRenderingContext,
14751:                                         nsPoint aPt)
14751: {
14751:   /* Do we need to do anything? */
71116:   nsEventStates eventStates = mContent->AsElement()->State();
56168:   if (eventStates.HasState(NS_EVENT_STATE_DISABLED) || mFocused != this)
14751:     return;
14751: 
    1:   aRenderingContext.PushState();
    1:   nsRect clipRect = mDisplayFrame->GetRect() + aPt;
68485:   aRenderingContext.IntersectClip(clipRect);
    1: 
    1:   // REVIEW: Why does the old code paint mDisplayFrame again? We've
    1:   // already painted it in the children above. So clipping it here won't do
    1:   // us much good.
    1: 
    1:   /////////////////////
    1:   // draw focus
14751: 
    1:   aRenderingContext.SetLineStyle(nsLineStyle_kDotted);
    1:   aRenderingContext.SetColor(GetStyleColor()->mColor);
14751: 
    1:   //aRenderingContext.DrawRect(clipRect);
14751: 
    1:   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
    1:   clipRect.width -= onePixel;
    1:   clipRect.height -= onePixel;
68479:   aRenderingContext.DrawLine(clipRect.TopLeft(), clipRect.TopRight());
68479:   aRenderingContext.DrawLine(clipRect.TopRight(), clipRect.BottomRight());
68479:   aRenderingContext.DrawLine(clipRect.BottomRight(), clipRect.BottomLeft());
68479:   aRenderingContext.DrawLine(clipRect.BottomLeft(), clipRect.TopLeft());
    1: 
    1:   aRenderingContext.PopState();
    1: }
    1: 
    1: //---------------------------------------------------------
    1: // gets the content (an option) by index and then set it as
    1: // being selected or not selected
    1: //---------------------------------------------------------
    1: NS_IMETHODIMP
25115: nsComboboxControlFrame::OnOptionSelected(PRInt32 aIndex, PRBool aSelected)
    1: {
    1:   if (mDroppedDown) {
23554:     nsISelectControlFrame *selectFrame = do_QueryFrame(mListControlFrame);
    1:     if (selectFrame) {
25115:       selectFrame->OnOptionSelected(aIndex, aSelected);
    1:     }
    1:   } else {
    1:     if (aSelected) {
25115:       nsAutoScriptBlocker blocker;
    1:       RedisplayText(aIndex);
    1:     } else {
25115:       nsWeakFrame weakFrame(this);
    1:       RedisplaySelectedText();
25115:       if (weakFrame.IsAlive()) {
    1:         FireValueChangeEvent(); // Fire after old option is unselected
    1:       }
    1:     }
25115:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsComboboxControlFrame::FireValueChangeEvent()
    1: {
    1:   // Fire ValueChange event to indicate data value of combo box has changed
38663:   nsContentUtils::AddScriptRunner(
38663:     new nsPLDOMEvent(mContent, NS_LITERAL_STRING("ValueChange"), PR_TRUE,
38663:                      PR_FALSE));
    1: }
    1: 
    1: void
    1: nsComboboxControlFrame::OnContentReset()
    1: {
    1:   if (mListControlFrame) {
    1:     mListControlFrame->OnContentReset();
    1:   }
    1: }
    1: 
    1: 
    1: //--------------------------------------------------------
    1: // nsIStatefulFrame
    1: //--------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsComboboxControlFrame::SaveState(SpecialStateID aStateID,
    1:                                   nsPresState** aState)
    1: {
    1:   if (!mListControlFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
23554:   nsIStatefulFrame* stateful = do_QueryFrame(mListControlFrame);
    1:   return stateful->SaveState(aStateID, aState);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsComboboxControlFrame::RestoreState(nsPresState* aState)
    1: {
    1:   if (!mListControlFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
23554:   nsIStatefulFrame* stateful = do_QueryFrame(mListControlFrame);
23554:   NS_ASSERTION(stateful, "Must implement nsIStatefulFrame");
23554:   return stateful->RestoreState(aState);
    1: }
    1: 
    1: 
    1: //
    1: // Camino uses a native widget for the combobox
    1: // popup, which affects drawing and event
    1: // handling here and in nsListControlFrame.
    1: //
30008: // Also, Fennec use a custom combobox built-in widget
30008: // 
    1: 
    1: /* static */
    1: PRBool
    1: nsComboboxControlFrame::ToolkitHasNativePopup()
    1: {
72208: #ifdef MOZ_USE_NATIVE_POPUP_WINDOWS
72208:   return PR_TRUE;
72208: #else
72208:   return PR_FALSE;
72208: #endif /* MOZ_USE_NATIVE_POPUP_WINDOWS */
    1: }
    1: 
