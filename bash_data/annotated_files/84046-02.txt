39447: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
39447:  * ***** BEGIN LICENSE BLOCK *****
39447:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
39447:  *
39447:  * The contents of this file are subject to the Mozilla Public License Version
39447:  * 1.1 (the "License"); you may not use this file except in compliance with
39447:  * the License. You may obtain a copy of the License at
39447:  * http://www.mozilla.org/MPL/
39447:  *
39447:  * Software distributed under the License is distributed on an "AS IS" basis,
39447:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
39447:  * for the specific language governing rights and limitations under the
39447:  * License.
39447:  *
39447:  * The Original Code is Mozilla Foundation code.
39447:  *
39447:  * The Initial Developer of the Original Code is Mozilla Foundation.
39447:  * Portions created by the Initial Developer are Copyright (C) 2005-2010
39447:  * the Initial Developer. All Rights Reserved.
39447:  *
39447:  * Contributor(s):
39447:  *   Stuart Parmenter <stuart@mozilla.com>
39447:  *   Masayuki Nakano <masayuki@d-toybox.com>
39447:  *   Mats Palmgren <mats.palmgren@bredband.net>
39447:  *   John Daggett <jdaggett@mozilla.com>
39447:  *   Jonathan Kew <jfkthame@gmail.com>
39447:  *
39447:  * Alternatively, the contents of this file may be used under the terms of
39447:  * either the GNU General Public License Version 2 or later (the "GPL"), or
39447:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
39447:  * in which case the provisions of the GPL or the LGPL are applicable instead
39447:  * of those above. If you wish to allow use of your version of this file only
39447:  * under the terms of either the GPL or the LGPL, and not to allow others to
39447:  * use your version of this file under the terms of the MPL, indicate your
39447:  * decision by deleting the provisions above and replace them with the notice
39447:  * and other provisions required by the GPL or the LGPL. If you do not delete
39447:  * the provisions above, a recipient may use your version of this file under
39447:  * the terms of any one of the MPL, the GPL or the LGPL.
39447:  *
39447:  * ***** END LICENSE BLOCK ***** */
39447: 
39447: #include "gfxGDIFont.h"
39447: #include "gfxGDIShaper.h"
39447: #include "gfxUniscribeShaper.h"
43527: #include "gfxHarfBuzzShaper.h"
39447: #include "gfxWindowsPlatform.h"
39447: #include "gfxContext.h"
46221: #include "gfxUnicodeProperties.h"
39447: 
39447: #include "cairo-win32.h"
39447: 
39447: #define ROUND(x) floor((x) + 0.5)
39447: 
39447: static inline cairo_antialias_t
39447: GetCairoAntialiasOption(gfxFont::AntialiasOption anAntialiasOption)
39447: {
39447:     switch (anAntialiasOption) {
39447:     default:
39447:     case gfxFont::kAntialiasDefault:
39447:         return CAIRO_ANTIALIAS_DEFAULT;
39447:     case gfxFont::kAntialiasNone:
39447:         return CAIRO_ANTIALIAS_NONE;
39447:     case gfxFont::kAntialiasGrayscale:
39447:         return CAIRO_ANTIALIAS_GRAY;
39447:     case gfxFont::kAntialiasSubpixel:
39447:         return CAIRO_ANTIALIAS_SUBPIXEL;
39447:     }
39447: }
39447: 
39447: gfxGDIFont::gfxGDIFont(GDIFontEntry *aFontEntry,
39447:                        const gfxFontStyle *aFontStyle,
79445:                        bool aNeedsBold,
39447:                        AntialiasOption anAAOption)
39447:     : gfxFont(aFontEntry, aFontStyle, anAAOption),
39447:       mFont(NULL),
39447:       mFontFace(nsnull),
39447:       mScaledFont(nsnull),
41898:       mMetrics(nsnull),
41898:       mSpaceGlyph(0),
41898:       mNeedsBold(aNeedsBold)
39447: {
43527:     if (FontCanSupportHarfBuzz()) {
43527:         mHarfBuzzShaper = new gfxHarfBuzzShaper(this);
43459:     }
39447: }
39447: 
39447: gfxGDIFont::~gfxGDIFont()
39447: {
39447:     if (mScaledFont) {
39447:         cairo_scaled_font_destroy(mScaledFont);
39447:     }
39447:     if (mFontFace) {
39447:         cairo_font_face_destroy(mFontFace);
39447:     }
39447:     if (mFont) {
39447:         ::DeleteObject(mFont);
39447:     }
41898:     delete mMetrics;
39447: }
39447: 
43527: void
43527: gfxGDIFont::CreatePlatformShaper()
43527: {
43527:     mPlatformShaper = new gfxGDIShaper(this);
43527: }
43527: 
39447: gfxFont*
39447: gfxGDIFont::CopyWithAntialiasOption(AntialiasOption anAAOption)
39447: {
39447:     return new gfxGDIFont(static_cast<GDIFontEntry*>(mFontEntry.get()),
39447:                           &mStyle, mNeedsBold, anAAOption);
39447: }
39447: 
79445: static bool
46221: UseUniscribe(gfxTextRun *aTextRun,
46221:              const PRUnichar *aString,
46221:              PRUint32 aRunStart,
46221:              PRUint32 aRunLength)
46221: {
46221:     PRUint32 flags = aTextRun->GetFlags();
79445:     bool useGDI;
46221: 
79445:     bool isXP = (gfxWindowsPlatform::WindowsOSVersion() 
46221:                        < gfxWindowsPlatform::kWindowsVista);
46221: 
46221:     // bug 561304 - Uniscribe bug produces bad positioning at certain
46221:     // font sizes on XP, so default to GDI on XP using logic of 3.6
46221: 
46221:     useGDI = isXP &&
46221:              (flags &
46221:                (gfxTextRunFactory::TEXT_OPTIMIZE_SPEED | 
46221:                 gfxTextRunFactory::TEXT_IS_RTL)
46221:              ) == gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
46221: 
46221:     return !useGDI ||
46221:         ScriptIsComplex(aString + aRunStart, aRunLength, SIC_COMPLEX) == S_OK;
46221: }
46221: 
79445: bool
39447: gfxGDIFont::InitTextRun(gfxContext *aContext,
39447:                         gfxTextRun *aTextRun,
39447:                         const PRUnichar *aString,
39447:                         PRUint32 aRunStart,
43525:                         PRUint32 aRunLength,
57397:                         PRInt32 aRunScript,
79445:                         bool aPreferPlatformShaping)
39447: {
41898:     if (!mMetrics) {
41898:         Initialize();
41898:     }
41898:     if (!mIsValid) {
41898:         NS_WARNING("invalid font! expect incorrect text rendering");
80486:         return false;
41898:     }
46221: 
79445:     bool ok = false;
46221: 
63896:     // ensure the cairo font is set up, so there's no risk it'll fall back to
63896:     // creating a "toy" font internally (see bug 544617)
63896:     SetupCairoFont(aContext);
63896: 
46221:     if (mHarfBuzzShaper) {
67838:         if (gfxPlatform::GetPlatform()->UseHarfBuzzForScript(aRunScript)) {
46221:             ok = mHarfBuzzShaper->InitTextRun(aContext, aTextRun, aString,
46221:                                               aRunStart, aRunLength, 
46221:                                               aRunScript);
46221:         }
46221:     }
46221: 
46221:     if (!ok) {
43440:         GDIFontEntry *fe = static_cast<GDIFontEntry*>(GetFontEntry());
79445:         bool preferUniscribe =
61531:             (!fe->IsTrueType() || fe->IsSymbolFont()) && !fe->mForceGDI;
46221: 
61531:         if (preferUniscribe ||
61531:             UseUniscribe(aTextRun, aString, aRunStart, aRunLength))
46221:         {
46221:             // first try Uniscribe
46221:             if (!mUniscribeShaper) {
46221:                 mUniscribeShaper = new gfxUniscribeShaper(this);
46221:             }
46221: 
46221:             ok = mUniscribeShaper->InitTextRun(aContext, aTextRun, aString,
46221:                                                aRunStart, aRunLength, 
46221:                                                aRunScript);
46221:             if (ok) {
80486:                 return true;
46221:             }
46221: 
46221:             // fallback to GDI shaping
46221:             if (!mPlatformShaper) {
46221:                 CreatePlatformShaper();
46221:             }
46221: 
43527:             ok = mPlatformShaper->InitTextRun(aContext, aTextRun, aString,
43527:                                               aRunStart, aRunLength, 
43527:                                               aRunScript);
46221:         } else {
46221:             // first use GDI
46221:             if (!mPlatformShaper) {
46221:                 CreatePlatformShaper();
43459:             }
46221: 
46221:             ok = mPlatformShaper->InitTextRun(aContext, aTextRun, aString,
46221:                                               aRunStart, aRunLength, 
46221:                                               aRunScript);
46221: 
46221:             if (ok) {
80486:                 return true;
46221:             }
46221: 
61531:             // try Uniscribe if GDI failed
46221:             if (!mUniscribeShaper) {
46221:                 mUniscribeShaper = new gfxUniscribeShaper(this);
46221:             }
46221: 
46221:             // use Uniscribe shaping
46221:             ok = mUniscribeShaper->InitTextRun(aContext, aTextRun, aString,
46221:                                                aRunStart, aRunLength, 
46221:                                                aRunScript);
46221:         }
46221: 
46221: #if DEBUG
46221:         if (!ok) {
46221:             NS_ConvertUTF16toUTF8 name(GetName());
46221:             char msg[256];
46221: 
46221:             sprintf(msg, 
46221:                     "text shaping with both uniscribe and GDI failed for"
46221:                     " font: %s",
46221:                     name.get());
46221:             NS_WARNING(msg);
46221:         }
46221: #endif
43459:     }
43527: 
43527:     return ok;
39447: }
39447: 
39447: const gfxFont::Metrics&
39447: gfxGDIFont::GetMetrics()
39447: {
41898:     if (!mMetrics) {
41898:         Initialize();
41898:     }
41898:     return *mMetrics;
39447: }
39447: 
39447: PRUint32
39447: gfxGDIFont::GetSpaceGlyph()
39447: {
41898:     if (!mMetrics) {
41898:         Initialize();
41898:     }
39447:     return mSpaceGlyph;
39447: }
39447: 
79445: bool
39447: gfxGDIFont::SetupCairoFont(gfxContext *aContext)
39447: {
41898:     if (!mMetrics) {
41898:         Initialize();
41898:     }
51561:     if (!mScaledFont ||
51561:         cairo_scaled_font_status(mScaledFont) != CAIRO_STATUS_SUCCESS) {
39447:         // Don't cairo_set_scaled_font as that would propagate the error to
39447:         // the cairo_t, precluding any further drawing.
80486:         return false;
39447:     }
39447:     cairo_set_scaled_font(aContext->GetCairo(), mScaledFont);
80486:     return true;
39447: }
39447: 
72200: gfxFont::RunMetrics
72200: gfxGDIFont::Measure(gfxTextRun *aTextRun,
72200:                     PRUint32 aStart, PRUint32 aEnd,
72200:                     BoundingBoxType aBoundingBoxType,
72200:                     gfxContext *aRefContext,
72200:                     Spacing *aSpacing)
72200: {
72200:     gfxFont::RunMetrics metrics =
72200:         gfxFont::Measure(aTextRun, aStart, aEnd,
72200:                          aBoundingBoxType, aRefContext, aSpacing);
72200: 
72200:     // if aBoundingBoxType is LOOSE_INK_EXTENTS
72200:     // and the underlying cairo font may be antialiased,
72200:     // we can't trust Windows to have considered all the pixels
72200:     // so we need to add "padding" to the bounds.
72200:     // (see bugs 475968, 439831, compare also bug 445087)
72200:     if (aBoundingBoxType == LOOSE_INK_EXTENTS &&
72200:         mAntialiasOption != kAntialiasNone &&
72200:         metrics.mBoundingBox.width > 0) {
72200:         metrics.mBoundingBox.x -= aTextRun->GetAppUnitsPerDevUnit();
72200:         metrics.mBoundingBox.width += aTextRun->GetAppUnitsPerDevUnit() * 3;
72200:     }
72200: 
72200:     return metrics;
72200: }
72200: 
39447: void
41898: gfxGDIFont::Initialize()
39447: {
41898:     NS_ASSERTION(!mMetrics, "re-creating metrics? this will leak");
41898: 
41898:     LOGFONTW logFont;
41898: 
39447:     if (mAdjustedSize == 0.0) {
39447:         mAdjustedSize = mStyle.size;
39447:         if (mStyle.sizeAdjust != 0.0 && mAdjustedSize > 0.0) {
39447:             // to implement font-size-adjust, we first create the "unadjusted" font
41898:             FillLogFont(logFont, mAdjustedSize);
41898:             mFont = ::CreateFontIndirectW(&logFont);
39447: 
41898:             // initialize its metrics so we can calculate size adjustment
41898:             Initialize();
41898: 
41898:             // calculate the properly adjusted size, and then proceed
41898:             // to recreate mFont and recalculate metrics
41898:             gfxFloat aspect = mMetrics->xHeight / mMetrics->emHeight;
41898:             mAdjustedSize = mStyle.GetAdjustedSize(aspect);
41898: 
41898:             // delete the temporary font and metrics
39447:             ::DeleteObject(mFont);
39447:             mFont = nsnull;
41898:             delete mMetrics;
41898:             mMetrics = nsnull;
39447:         }
39447:     }
39447: 
84046:     // this may end up being zero
73915:     mAdjustedSize = ROUND(mAdjustedSize);
41898:     FillLogFont(logFont, mAdjustedSize);
41898:     mFont = ::CreateFontIndirectW(&logFont);
41898: 
41898:     mMetrics = new gfxFont::Metrics;
41898:     ::memset(mMetrics, 0, sizeof(*mMetrics));
39447: 
39447:     AutoDC dc;
39447:     SetGraphicsMode(dc.GetDC(), GM_ADVANCED);
39447:     AutoSelectFont selectFont(dc.GetDC(), mFont);
39447: 
84046:     // Get font metrics if size > 0
84046:     if (mAdjustedSize > 0.0) {
84046: 
39447:         OUTLINETEXTMETRIC oMetrics;
39447:         TEXTMETRIC& metrics = oMetrics.otmTextMetrics;
39447: 
39447:         if (0 < GetOutlineTextMetrics(dc.GetDC(), sizeof(oMetrics), &oMetrics)) {
41898:             mMetrics->superscriptOffset = (double)oMetrics.otmptSuperscriptOffset.y;
39447:             // Some fonts have wrong sign on their subscript offset, bug 410917.
41898:             mMetrics->subscriptOffset = fabs((double)oMetrics.otmptSubscriptOffset.y);
41898:             mMetrics->strikeoutSize = (double)oMetrics.otmsStrikeoutSize;
41898:             mMetrics->strikeoutOffset = (double)oMetrics.otmsStrikeoutPosition;
41898:             mMetrics->underlineSize = (double)oMetrics.otmsUnderscoreSize;
41898:             mMetrics->underlineOffset = (double)oMetrics.otmsUnderscorePosition;
39447: 
39447:             const MAT2 kIdentityMatrix = { {0, 1}, {0, 0}, {0, 0}, {0, 1} };
39447:             GLYPHMETRICS gm;
39447:             DWORD len = GetGlyphOutlineW(dc.GetDC(), PRUnichar('x'), GGO_METRICS, &gm, 0, nsnull, &kIdentityMatrix);
39447:             if (len == GDI_ERROR || gm.gmptGlyphOrigin.y <= 0) {
39447:                 // 56% of ascent, best guess for true type
47309:                 mMetrics->xHeight =
47309:                     ROUND((double)metrics.tmAscent * DEFAULT_XHEIGHT_FACTOR);
39447:             } else {
41898:                 mMetrics->xHeight = gm.gmptGlyphOrigin.y;
39447:             }
41898:             mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
39447:             gfxFloat typEmHeight = (double)oMetrics.otmAscent - (double)oMetrics.otmDescent;
41898:             mMetrics->emAscent = ROUND(mMetrics->emHeight * (double)oMetrics.otmAscent / typEmHeight);
41898:             mMetrics->emDescent = mMetrics->emHeight - mMetrics->emAscent;
43527:             if (oMetrics.otmEMSquare > 0) {
61083:                 mFUnitsConvFactor = float(mAdjustedSize / oMetrics.otmEMSquare);
43527:             }
39447:         } else {
39447:             // Make a best-effort guess at extended metrics
39447:             // this is based on general typographic guidelines
39447:             
39447:             // GetTextMetrics can fail if the font file has been removed
39447:             // or corrupted recently.
39447:             BOOL result = GetTextMetrics(dc.GetDC(), &metrics);
39447:             if (!result) {
39447:                 NS_WARNING("Missing or corrupt font data, fasten your seatbelt");
80486:                 mIsValid = false;
41898:                 memset(mMetrics, 0, sizeof(*mMetrics));
39447:                 return;
39447:             }
39447: 
47309:             mMetrics->xHeight =
47309:                 ROUND((float)metrics.tmAscent * DEFAULT_XHEIGHT_FACTOR);
41898:             mMetrics->superscriptOffset = mMetrics->xHeight;
41898:             mMetrics->subscriptOffset = mMetrics->xHeight;
41898:             mMetrics->strikeoutSize = 1;
41898:             mMetrics->strikeoutOffset = ROUND(mMetrics->xHeight * 0.5f); // 50% of xHeight
41898:             mMetrics->underlineSize = 1;
41898:             mMetrics->underlineOffset = -ROUND((float)metrics.tmDescent * 0.30f); // 30% of descent
41898:             mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
41898:             mMetrics->emAscent = metrics.tmAscent - metrics.tmInternalLeading;
41898:             mMetrics->emDescent = metrics.tmDescent;
39447:         }
39447: 
41898:         mMetrics->internalLeading = metrics.tmInternalLeading;
41898:         mMetrics->externalLeading = metrics.tmExternalLeading;
41898:         mMetrics->maxHeight = metrics.tmHeight;
41898:         mMetrics->maxAscent = metrics.tmAscent;
41898:         mMetrics->maxDescent = metrics.tmDescent;
41898:         mMetrics->maxAdvance = metrics.tmMaxCharWidth;
71173:         mMetrics->aveCharWidth = NS_MAX<gfxFloat>(1, metrics.tmAveCharWidth);
39447:         // The font is monospace when TMPF_FIXED_PITCH is *not* set!
39447:         // See http://msdn2.microsoft.com/en-us/library/ms534202(VS.85).aspx
39447:         if (!(metrics.tmPitchAndFamily & TMPF_FIXED_PITCH)) {
41898:             mMetrics->maxAdvance = mMetrics->aveCharWidth;
39447:         }
39447: 
39447:         // Cache the width of a single space.
39447:         SIZE size;
39447:         GetTextExtentPoint32W(dc.GetDC(), L" ", 1, &size);
41898:         mMetrics->spaceWidth = ROUND(size.cx);
39447: 
39447:         // Cache the width of digit zero.
39447:         // XXX MSDN (http://msdn.microsoft.com/en-us/library/ms534223.aspx)
39447:         // does not say what the failure modes for GetTextExtentPoint32 are -
39447:         // is it safe to assume it will fail iff the font has no '0'?
41898:         if (GetTextExtentPoint32W(dc.GetDC(), L"0", 1, &size)) {
41898:             mMetrics->zeroOrAveCharWidth = ROUND(size.cx);
41898:         } else {
41898:             mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
41898:         }
39447: 
39447:         mSpaceGlyph = 0;
39447:         if (metrics.tmPitchAndFamily & TMPF_TRUETYPE) {
39447:             WORD glyph;
39447:             DWORD ret = GetGlyphIndicesW(dc.GetDC(), L" ", 1, &glyph,
39447:                                          GGI_MARK_NONEXISTING_GLYPHS);
39447:             if (ret != GDI_ERROR && glyph != 0xFFFF) {
39447:                 mSpaceGlyph = glyph;
39447:             }
39447:         }
39447: 
41898:         SanitizeMetrics(mMetrics, GetFontEntry()->mIsBadUnderlineFont);
84046:     }
41898: 
41898:     mFontFace = cairo_win32_font_face_create_for_logfontw_hfont(&logFont,
41898:                                                                 mFont);
41898: 
41898:     cairo_matrix_t sizeMatrix, ctm;
41898:     cairo_matrix_init_identity(&ctm);
41898:     cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
41898: 
41898:     cairo_font_options_t *fontOptions = cairo_font_options_create();
41898:     if (mAntialiasOption != kAntialiasDefault) {
41898:         cairo_font_options_set_antialias(fontOptions,
41898:             GetCairoAntialiasOption(mAntialiasOption));
41898:     }
41898:     mScaledFont = cairo_scaled_font_create(mFontFace, &sizeMatrix,
41898:                                            &ctm, fontOptions);
41898:     cairo_font_options_destroy(fontOptions);
41898: 
51561:     if (!mScaledFont ||
51561:         cairo_scaled_font_status(mScaledFont) != CAIRO_STATUS_SUCCESS) {
41898: #ifdef DEBUG
41898:         char warnBuf[1024];
41898:         sprintf(warnBuf, "Failed to create scaled font: %s status: %d",
51561:                 NS_ConvertUTF16toUTF8(mFontEntry->Name()).get(),
51561:                 mScaledFont ? cairo_scaled_font_status(mScaledFont) : 0);
41898:         NS_WARNING(warnBuf);
41898: #endif
84046:         mIsValid = false;
84046:     } else {
84046:         mIsValid = true;
41898:     }
41898: 
40042: #if 0
84046:     printf("Font: %p (%s) size: %f adjusted size: %f valid: %s\n", this,
84046:            NS_ConvertUTF16toUTF8(GetName()).get(), mStyle.size, mAdjustedSize, (mIsValid ? "yes" : "no"));
84046:     printf("    emHeight: %f emAscent: %f emDescent: %f\n", mMetrics->emHeight, mMetrics->emAscent, mMetrics->emDescent);
84046:     printf("    maxAscent: %f maxDescent: %f maxAdvance: %f\n", mMetrics->maxAscent, mMetrics->maxDescent, mMetrics->maxAdvance);
84046:     printf("    internalLeading: %f externalLeading: %f\n", mMetrics->internalLeading, mMetrics->externalLeading);
84046:     printf("    spaceWidth: %f aveCharWidth: %f xHeight: %f\n", mMetrics->spaceWidth, mMetrics->aveCharWidth, mMetrics->xHeight);
40042:     printf("    uOff: %f uSize: %f stOff: %f stSize: %f supOff: %f subOff: %f\n",
84046:            mMetrics->underlineOffset, mMetrics->underlineSize, mMetrics->strikeoutOffset, mMetrics->strikeoutSize,
84046:            mMetrics->superscriptOffset, mMetrics->subscriptOffset);
40042: #endif
39447: }
39447: 
39447: void
41898: gfxGDIFont::FillLogFont(LOGFONTW& aLogFont, gfxFloat aSize)
39447: {
39447:     GDIFontEntry *fe = static_cast<GDIFontEntry*>(GetFontEntry());
39447: 
39447:     PRUint16 weight = mNeedsBold ? 700 : fe->Weight();
79445:     bool italic = (mStyle.style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE));
39447: 
39447:     // if user font, disable italics/bold if defined to be italics/bold face
39447:     // this avoids unwanted synthetic italics/bold
39447:     if (fe->mIsUserFont) {
39447:         if (fe->IsItalic())
80486:             italic = false; // avoid synthetic italic
48283:         if (fe->IsBold() || !mNeedsBold) {
48283:             // avoid GDI synthetic bold which occurs when weight
48283:             // specified is >= font data weight + 200
48283:             weight = 200; 
39447:         }
39447:     }
39447: 
42854:     fe->FillLogFont(&aLogFont, italic, weight, aSize, 
80486:                     (mAntialiasOption == kAntialiasSubpixel) ? true : false);
39447: }
39447: 
43527: PRInt32
61073: gfxGDIFont::GetGlyphWidth(gfxContext *aCtx, PRUint16 aGID)
43527: {
43527:     if (!mGlyphWidths.IsInitialized()) {
43527:         mGlyphWidths.Init(200);
43527:     }
43527: 
43527:     PRInt32 width;
43527:     if (mGlyphWidths.Get(aGID, &width)) {
43527:         return width;
43527:     }
43527: 
62991:     DCFromContext dc(aCtx);
62991:     AutoSelectFont fs(dc, GetHFONT());
62991: 
43527:     int devWidth;
62991:     if (GetCharWidthI(dc, aGID, 1, NULL, &devWidth)) {
43527:         // ensure width is positive, 16.16 fixed-point value
43527:         width = (devWidth & 0x7fff) << 16;
43527:         mGlyphWidths.Put(aGID, width);
43527:         return width;
43527:     }
43527: 
43527:     return -1;
43527: }
