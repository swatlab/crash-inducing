 48320: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 48320:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 48320: 
 48320: #include "imgStatusTracker.h"
 48320: 
 48320: #include "imgRequest.h"
 48320: #include "imgIContainer.h"
 48320: #include "imgRequestProxy.h"
 50546: #include "Image.h"
 48322: #include "ImageLogging.h"
 51295: #include "RasterImage.h"
118748: #include "nsIObserverService.h"
118661: 
118741: #include "mozilla/Util.h"
118741: #include "mozilla/Assertions.h"
118748: #include "mozilla/Services.h"
118741: 
 87852: using namespace mozilla::image;
 50554: 
118748: NS_IMPL_ISUPPORTS3(imgStatusTrackerObserver,
118748:                    imgIDecoderObserver,
118748:                    imgIContainerObserver,
118748:                    nsISupportsWeakReference)
118748: 
118748: /** imgIContainerObserver methods **/
118748: 
118757: /* [noscript] void frameChanged (in nsIntRect dirtyRect); */
118757: NS_IMETHODIMP imgStatusTrackerObserver::FrameChanged(const nsIntRect *dirtyRect)
118748: {
118748:   LOG_SCOPE(gImgLog, "imgStatusTrackerObserver::FrameChanged");
118748:   NS_ABORT_IF_FALSE(mTracker->GetImage(),
118748:                     "FrameChanged callback before we've created our image");
118748: 
118757:   mTracker->RecordFrameChanged(dirtyRect);
118748: 
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
118748:   while (iter.HasMore()) {
118757:     mTracker->SendFrameChanged(iter.GetNext(), dirtyRect);
118748:   }
118748: 
118748:   return NS_OK;
118748: }
118748: 
118748: /** imgIDecoderObserver methods **/
118748: 
118757: NS_IMETHODIMP imgStatusTrackerObserver::OnStartDecode()
118748: {
118748:   LOG_SCOPE(gImgLog, "imgStatusTrackerObserver::OnStartDecode");
118748:   NS_ABORT_IF_FALSE(mTracker->GetImage(),
118748:                     "OnStartDecode callback before we've created our image");
118748: 
118969:   if (mTracker->GetRequest() && !mTracker->GetRequest()->GetMultipart()) {
118748:     MOZ_ASSERT(!mTracker->mBlockingOnload);
118748:     mTracker->mBlockingOnload = true;
118748: 
118748:     mTracker->RecordBlockOnload();
118748: 
118749:     nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
118748:     while (iter.HasMore()) {
118748:       mTracker->SendBlockOnload(iter.GetNext());
118748:     }
118748:   }
118748: 
118748:   /* In the case of streaming jpegs, it is possible to get multiple OnStartDecodes which
118748:      indicates the beginning of a new decode.
118748:      The cache entry's size therefore needs to be reset to 0 here.  If we do not do this,
118748:      the code in imgStatusTrackerObserver::OnStopFrame will continue to increase the data size cumulatively.
118748:   */
118969:   if (mTracker->GetRequest()) {
118748:     mTracker->GetRequest()->ResetCacheEntry();
118969:   }
118748: 
118748:   return NS_OK;
118748: }
118748: 
118757: NS_IMETHODIMP imgStatusTrackerObserver::OnStartRequest()
118748: {
118748:   NS_NOTREACHED("imgRequest(imgIDecoderObserver)::OnStartRequest");
118748:   return NS_OK;
118748: }
118748: 
118757: /* void onStartContainer (); */
118757: NS_IMETHODIMP imgStatusTrackerObserver::OnStartContainer()
118748: {
118748:   LOG_SCOPE(gImgLog, "imgStatusTrackerObserver::OnStartContainer");
118748: 
118748:   NS_ABORT_IF_FALSE(mTracker->GetImage(),
118748:                     "OnStartContainer callback before we've created our image");
118757:   mTracker->RecordStartContainer(mTracker->GetImage());
118748: 
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
118748:   while (iter.HasMore()) {
118757:     mTracker->SendStartContainer(iter.GetNext());
118748:   }
118748: 
118748:   return NS_OK;
118748: }
118748: 
118757: /* [noscript] void onDataAvailable ([const] in nsIntRect rect); */
118757: NS_IMETHODIMP imgStatusTrackerObserver::OnDataAvailable(const nsIntRect * rect)
118748: {
118748:   LOG_SCOPE(gImgLog, "imgStatusTrackerObserver::OnDataAvailable");
118748:   NS_ABORT_IF_FALSE(mTracker->GetImage(),
118748:                     "OnDataAvailable callback before we've created our image");
118748: 
118757:   mTracker->RecordDataAvailable();
118748: 
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
118748:   while (iter.HasMore()) {
118757:     mTracker->SendDataAvailable(iter.GetNext(), rect);
118748:   }
118748: 
118748:   return NS_OK;
118748: }
118748: 
118757: /* void onStopFrame (); */
118757: NS_IMETHODIMP imgStatusTrackerObserver::OnStopFrame()
118748: {
118748:   LOG_SCOPE(gImgLog, "imgStatusTrackerObserver::OnStopFrame");
118748:   NS_ABORT_IF_FALSE(mTracker->GetImage(),
118748:                     "OnStopFrame callback before we've created our image");
118748: 
118757:   mTracker->RecordStopFrame();
118748: 
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
118748:   while (iter.HasMore()) {
118757:     mTracker->SendStopFrame(iter.GetNext());
118748:   }
118748: 
118748:   mTracker->MaybeUnblockOnload();
118748: 
118748:   return NS_OK;
118748: }
118748: 
118756: static void
118756: FireFailureNotification(imgRequest* aRequest)
118756: {
118756:   // Some kind of problem has happened with image decoding.
118756:   // Report the URI to net:failed-to-process-uri-conent observers.
118756: 
118756:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
118756:   if (os) {
118756:     nsCOMPtr<nsIURI> uri;
118756:     aRequest->GetURI(getter_AddRefs(uri));
118756:     os->NotifyObservers(uri, "net:failed-to-process-uri-content", nullptr);
118756:   }
118756: }
118756: 
118757: /* void onStopDecode (in nsresult status); */
118757: NS_IMETHODIMP imgStatusTrackerObserver::OnStopDecode(nsresult aStatus)
118748: {
118748:   LOG_SCOPE(gImgLog, "imgStatusTrackerObserver::OnStopDecode");
118748:   NS_ABORT_IF_FALSE(mTracker->GetImage(),
118752:                     "OnStopDecode callback before we've created our image");
118748: 
118748:   // We finished the decode, and thus have the decoded frames. Update the cache
118748:   // entry size to take this into account.
118969:   if (mTracker->GetRequest()) {
118748:     mTracker->GetRequest()->UpdateCacheEntrySize();
118969:   }
118748: 
118756:   bool preexistingError = mTracker->GetImageStatus() == imgIRequest::STATUS_ERROR;
118756: 
118752:   mTracker->RecordStopDecode(aStatus);
118748: 
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
118748:   while (iter.HasMore()) {
118752:     mTracker->SendStopDecode(iter.GetNext(), aStatus);
118748:   }
118748: 
118752:   // This is really hacky. We need to handle the case where we start decoding,
118752:   // block onload, but then hit an error before we get to our first frame.
118752:   mTracker->MaybeUnblockOnload();
118752: 
118969:   if (NS_FAILED(aStatus) && !preexistingError && mTracker->GetRequest()) {
118756:     FireFailureNotification(mTracker->GetRequest());
118748:   }
118748: 
118748:   return NS_OK;
118748: }
118748: 
118757: NS_IMETHODIMP imgStatusTrackerObserver::OnStopRequest(bool aLastPart)
118748: {
118748:   NS_NOTREACHED("imgRequest(imgIDecoderObserver)::OnStopRequest");
118748:   return NS_OK;
118748: }
118748: 
118757: /* void onDiscard (); */
118757: NS_IMETHODIMP imgStatusTrackerObserver::OnDiscard()
118748: {
118748:   NS_ABORT_IF_FALSE(mTracker->GetImage(),
118748:                     "OnDiscard callback before we've created our image");
118748: 
118748:   mTracker->RecordDiscard();
118748: 
118748:   // Update the cache entry size, since we just got rid of frame data
118969:   if (mTracker->GetRequest()) {
118748:     mTracker->GetRequest()->UpdateCacheEntrySize();
118969:   }
118748: 
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
118748:   while (iter.HasMore()) {
118748:     mTracker->SendDiscard(iter.GetNext());
118748:   }
118748: 
118748:   return NS_OK;
118748: }
118748: 
118757: NS_IMETHODIMP imgStatusTrackerObserver::OnImageIsAnimated()
118748: {
118748:   NS_ABORT_IF_FALSE(mTracker->GetImage(),
118748:                     "OnImageIsAnimated callback before we've created our image");
118748:   mTracker->RecordImageIsAnimated();
118748: 
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
118748:   while (iter.HasMore()) {
118748:     mTracker->SendImageIsAnimated(iter.GetNext());
118748:   }
118748: 
118748:   return NS_OK;
118748: }
118748: 
118748: // imgStatusTracker methods
118748: 
118744: imgStatusTracker::imgStatusTracker(Image* aImage, imgRequest* aRequest)
 48320:   : mImage(aImage),
118744:     mRequest(aRequest),
 48320:     mState(0),
 48320:     mImageStatus(imgIRequest::STATUS_NONE),
118748:     mHadLastPart(false),
118748:     mBlockingOnload(false),
118748:     mTrackerObserver(new imgStatusTrackerObserver(this))
 48320: {}
 48320: 
 49699: imgStatusTracker::imgStatusTracker(const imgStatusTracker& aOther)
 49699:   : mImage(aOther.mImage),
118744:     mRequest(aOther.mRequest),
 49699:     mState(aOther.mState),
 49699:     mImageStatus(aOther.mImageStatus),
118748:     mHadLastPart(aOther.mHadLastPart),
118748:     mBlockingOnload(aOther.mBlockingOnload)
 49699:     // Note: we explicitly don't copy mRequestRunnable, because it won't be
 49699:     // nulled out when the mRequestRunnable's Run function eventually gets
 49699:     // called.
 49699: {}
 49699: 
 51296: void
 51296: imgStatusTracker::SetImage(Image* aImage)
 51296: {
 51296:   NS_ABORT_IF_FALSE(aImage, "Setting null image");
 51296:   NS_ABORT_IF_FALSE(!mImage, "Setting image when we already have one");
 51296:   mImage = aImage;
 51296: }
 51296: 
 79445: bool
 48320: imgStatusTracker::IsLoading() const
 48320: {
 48320:   // Checking for whether OnStopRequest has fired allows us to say we're
 48320:   // loading before OnStartRequest gets called, letting the request properly
 48320:   // get removed from the cache in certain cases.
 48320:   return !(mState & stateRequestStopped);
 48320: }
 48320: 
108991: uint32_t
 48320: imgStatusTracker::GetImageStatus() const
 48320: {
 48320:   return mImageStatus;
 48320: }
 48320: 
 48321: // A helper class to allow us to call SyncNotify asynchronously.
 48321: class imgRequestNotifyRunnable : public nsRunnable
 48321: {
 48321:   public:
 48321:     imgRequestNotifyRunnable(imgRequest* request, imgRequestProxy* requestproxy)
 49699:       : mRequest(request)
 49699:     {
 49699:       mProxies.AppendElement(requestproxy);
 49699:     }
 48321: 
 48321:     NS_IMETHOD Run()
 48321:     {
 51297:       imgStatusTracker& statusTracker = mRequest->GetStatusTracker();
 51297: 
108991:       for (uint32_t i = 0; i < mProxies.Length(); ++i) {
 80486:         mProxies[i]->SetNotificationsDeferred(false);
 51297:         statusTracker.SyncNotify(mProxies[i]);
 49699:       }
 48321: 
106838:       statusTracker.mRequestRunnable = nullptr;
 48321:       return NS_OK;
 48321:     }
 48321: 
 49699:     void AddProxy(imgRequestProxy* aRequestProxy)
 49699:     {
 49699:       mProxies.AppendElement(aRequestProxy);
 49699:     }
 49699: 
 48321:   private:
 49699:     friend class imgStatusTracker;
 49699: 
 48321:     nsRefPtr<imgRequest> mRequest;
 49699:     nsTArray<nsRefPtr<imgRequestProxy> > mProxies;
 48321: };
 48321: 
 48320: void
 48321: imgStatusTracker::Notify(imgRequest* request, imgRequestProxy* proxy)
 48320: {
 48322: #ifdef PR_LOGGING
 48322:   nsCOMPtr<nsIURI> uri;
 48322:   request->GetURI(getter_AddRefs(uri));
110974:   nsAutoCString spec;
 48322:   uri->GetSpec(spec);
 48322:   LOG_FUNC_WITH_PARAM(gImgLog, "imgStatusTracker::Notify async", "uri", spec.get());
 48322: #endif
 48322: 
 80486:   proxy->SetNotificationsDeferred(true);
 48321: 
 49699:   // If we have an existing runnable that we can use, we just append this proxy
 49699:   // to its list of proxies to be notified. This ensures we don't unnecessarily
 49699:   // delay onload.
 49699:   imgRequestNotifyRunnable* runnable = static_cast<imgRequestNotifyRunnable*>(mRequestRunnable.get());
 49699:   if (runnable && runnable->mRequest == request) {
 49699:     runnable->AddProxy(proxy);
 49699:   } else {
 49699:     // It's okay to overwrite an existing mRequestRunnable, because adding a
 49699:     // new proxy is strictly a performance optimization. The notification will
 49699:     // always happen, regardless of whether we hold a reference to a runnable.
 49699:     mRequestRunnable = new imgRequestNotifyRunnable(request, proxy);
 49699:     NS_DispatchToCurrentThread(mRequestRunnable);
 49699:   }
 48321: }
 48321: 
 48321: // A helper class to allow us to call SyncNotify asynchronously for a given,
 48321: // fixed, state.
 48321: class imgStatusNotifyRunnable : public nsRunnable
 48321: {
 48321:   public:
 49699:     imgStatusNotifyRunnable(imgStatusTracker& status,
 48321:                             imgRequestProxy* requestproxy)
 48321:       : mStatus(status), mImage(status.mImage), mProxy(requestproxy)
 48321:     {}
 48321: 
 48321:     NS_IMETHOD Run()
 48321:     {
 80486:       mProxy->SetNotificationsDeferred(false);
 48321: 
 48321:       mStatus.SyncNotify(mProxy);
 48321:       return NS_OK;
 48321:     }
 48321: 
 48321:   private:
 48321:     imgStatusTracker mStatus;
 48321:     // We have to hold on to a reference to the tracker's image, just in case
 48321:     // it goes away while we're in the event queue.
 50554:     nsRefPtr<Image> mImage;
 48321:     nsRefPtr<imgRequestProxy> mProxy;
 48321: };
 48321: 
 48321: void
 48321: imgStatusTracker::NotifyCurrentState(imgRequestProxy* proxy)
 48321: {
 48322: #ifdef PR_LOGGING
 48322:   nsCOMPtr<nsIURI> uri;
 48322:   proxy->GetURI(getter_AddRefs(uri));
110974:   nsAutoCString spec;
 48322:   uri->GetSpec(spec);
 48322:   LOG_FUNC_WITH_PARAM(gImgLog, "imgStatusTracker::NotifyCurrentState", "uri", spec.get());
 48322: #endif
 48322: 
 80486:   proxy->SetNotificationsDeferred(true);
 48321: 
 49699:   // We don't keep track of 
 48321:   nsCOMPtr<nsIRunnable> ev = new imgStatusNotifyRunnable(*this, proxy);
 48321:   NS_DispatchToCurrentThread(ev);
 48321: }
 48321: 
 48321: void
 48321: imgStatusTracker::SyncNotify(imgRequestProxy* proxy)
 48321: {
 48321:   NS_ABORT_IF_FALSE(!proxy->NotificationsDeferred(),
 48321:     "Calling imgStatusTracker::Notify() on a proxy that doesn't want notifications!");
 48321: 
 48322: #ifdef PR_LOGGING
 48322:   nsCOMPtr<nsIURI> uri;
 48322:   proxy->GetURI(getter_AddRefs(uri));
110974:   nsAutoCString spec;
 48322:   uri->GetSpec(spec);
 48322:   LOG_SCOPE_WITH_PARAM(gImgLog, "imgStatusTracker::SyncNotify", "uri", spec.get());
 48322: #endif
 48322: 
 48320:   nsCOMPtr<imgIRequest> kungFuDeathGrip(proxy);
 48320: 
 48320:   // OnStartRequest
 48320:   if (mState & stateRequestStarted)
 48320:     proxy->OnStartRequest();
 48320: 
 48320:   // OnStartContainer
 48320:   if (mState & stateHasSize)
118757:     proxy->OnStartContainer();
118684: 
108324:   // BlockOnload
108324:   if (mState & stateBlockingOnload)
108324:     proxy->BlockOnload();
108324: 
 51297:   if (mImage) {
108991:     int16_t imageType = mImage->GetType();
118758:     // Send frame messages (OnDataAvailable, OnStopFrame)
 51295:     if (imageType == imgIContainer::TYPE_VECTOR ||
 51295:         static_cast<RasterImage*>(mImage)->GetNumFrames() > 0) {
 51295: 
 48320:       // OnDataAvailable
 48320:       // XXX - Should only send partial rects here, but that needs to
 48320:       // wait until we fix up the observer interface
 48320:       nsIntRect r;
 48320:       mImage->GetCurrentFrameRect(r);
118758:       proxy->OnFrameUpdate(&r);
 48320: 
 48320:       if (mState & stateFrameStopped)
118757:         proxy->OnStopFrame();
 48320:     }
 82096: 
 82096:     // OnImageIsAnimated
 82096:     bool isAnimated = false;
 82096: 
 82096:     nsresult rv = mImage->GetAnimated(&isAnimated);
 82096:     if (NS_SUCCEEDED(rv) && isAnimated) {
 82096:       proxy->OnImageIsAnimated();
 82096:     }
 51297:   }
 48320: 
 51297:   if (mState & stateDecodeStopped) {
 51297:     NS_ABORT_IF_FALSE(mImage, "stopped decoding without ever having an image?");
118752:     proxy->OnStopDecode();
 51297:   }
 48320: 
 48320:   if (mState & stateRequestStopped) {
 48320:     proxy->OnStopRequest(mHadLastPart);
 48320:   }
 48320: }
 48320: 
 48320: void
118608: imgStatusTracker::EmulateRequestFinished(imgRequestProxy* aProxy,
118608:                                          nsresult aStatus)
 48320: {
 48320:   nsCOMPtr<imgIRequest> kungFuDeathGrip(aProxy);
 48320: 
118757:   // In certain cases the request might not have started yet.
118757:   // We still need to fulfill the contract.
118754:   if (!(mState & stateRequestStarted)) {
118754:     aProxy->OnStartRequest();
118754:   }
118754: 
118406:   if (mState & stateBlockingOnload) {
118406:     aProxy->UnblockOnload();
118406:   }
118406: 
 48320:   if (!(mState & stateRequestStopped)) {
 80486:     aProxy->OnStopRequest(true);
 48320:   }
 48320: }
 48320: 
 48320: void
118741: imgStatusTracker::AddConsumer(imgRequestProxy* aConsumer)
118741: {
118741:   mConsumers.AppendElementUnlessExists(aConsumer);
118741: }
118741: 
118757: // XXX - The last argument should go away.
118741: bool
118741: imgStatusTracker::RemoveConsumer(imgRequestProxy* aConsumer, nsresult aStatus)
118741: {
118741:   // Remove the proxy from the list.
118741:   bool removed = mConsumers.RemoveElement(aConsumer);
118741: 
118741:   // Consumers can get confused if they don't get all the proper teardown
118741:   // notifications. Part ways on good terms.
118741:   if (removed)
118741:     EmulateRequestFinished(aConsumer, aStatus);
118741:   return removed;
118741: }
118741: 
118741: void
 48320: imgStatusTracker::RecordCancel()
 48320: {
 48320:   if (!(mImageStatus & imgIRequest::STATUS_LOAD_PARTIAL))
 48320:     mImageStatus |= imgIRequest::STATUS_ERROR;
 48320: }
 48320: 
 48320: void
 48320: imgStatusTracker::RecordLoaded()
 48320: {
 51298:   NS_ABORT_IF_FALSE(mImage, "RecordLoaded called before we have an Image");
 48320:   mState |= stateRequestStarted | stateHasSize | stateRequestStopped;
 48320:   mImageStatus |= imgIRequest::STATUS_SIZE_AVAILABLE | imgIRequest::STATUS_LOAD_COMPLETE;
 80486:   mHadLastPart = true;
 48320: }
 48320: 
 48320: void
 48320: imgStatusTracker::RecordDecoded()
 48320: {
 51298:   NS_ABORT_IF_FALSE(mImage, "RecordDecoded called before we have an Image");
118758:   mState |= stateDecodeStopped | stateFrameStopped;
 48320:   mImageStatus |= imgIRequest::STATUS_FRAME_COMPLETE | imgIRequest::STATUS_DECODE_COMPLETE;
 48320: }
 48320: 
 48320: void
 48320: imgStatusTracker::RecordStartContainer(imgIContainer* aContainer)
 48320: {
 51298:   NS_ABORT_IF_FALSE(mImage,
 51298:                     "RecordStartContainer called before we have an Image");
 51298:   NS_ABORT_IF_FALSE(mImage == aContainer,
 51298:                     "RecordStartContainer called with wrong Image");
 48320:   mState |= stateHasSize;
 48320:   mImageStatus |= imgIRequest::STATUS_SIZE_AVAILABLE;
 48320: }
 48320: 
 48320: void
118757: imgStatusTracker::SendStartContainer(imgRequestProxy* aProxy)
 48320: {
 49700:   if (!aProxy->NotificationsDeferred())
118757:     aProxy->OnStartContainer();
 48320: }
 48320: 
 48320: void
118757: imgStatusTracker::RecordDataAvailable()
 48320: {
 51298:   NS_ABORT_IF_FALSE(mImage,
 51298:                     "RecordDataAvailable called before we have an Image");
 48320:   // no bookkeeping necessary here - this is implied by imgIContainer's
 48320:   // number of frames and frame rect
 48320: }
 48320: 
 48320: void
118757: imgStatusTracker::SendDataAvailable(imgRequestProxy* aProxy,
 48320:                                     const nsIntRect* aRect)
 48320: {
 48321:   if (!aProxy->NotificationsDeferred())
118758:     aProxy->OnFrameUpdate(aRect);
 48320: }
 48320: 
 48320: 
 48320: void
118757: imgStatusTracker::RecordStopFrame()
 48320: {
 51298:   NS_ABORT_IF_FALSE(mImage, "RecordStopFrame called before we have an Image");
 48320:   mState |= stateFrameStopped;
 48320:   mImageStatus |= imgIRequest::STATUS_FRAME_COMPLETE;
 48320: }
 48320: 
 48320: void
118757: imgStatusTracker::SendStopFrame(imgRequestProxy* aProxy)
 48320: {
 48321:   if (!aProxy->NotificationsDeferred())
118757:     aProxy->OnStopFrame();
 48320: }
 48320: 
 48320: void
118752: imgStatusTracker::RecordStopDecode(nsresult aStatus)
 48320: {
 51298:   NS_ABORT_IF_FALSE(mImage,
 51298:                     "RecordStopDecode called before we have an Image");
 48320:   mState |= stateDecodeStopped;
 48320: 
118753:   if (NS_SUCCEEDED(aStatus) && mImageStatus != imgIRequest::STATUS_ERROR)
 48320:     mImageStatus |= imgIRequest::STATUS_DECODE_COMPLETE;
 48320:   // If we weren't successful, clear all success status bits and set error.
 48320:   else
 48320:     mImageStatus = imgIRequest::STATUS_ERROR;
 48320: }
 48320: 
 48320: void
118757: imgStatusTracker::SendStopDecode(imgRequestProxy* aProxy,
118757:                                  nsresult aStatus)
 48320: {
 48321:   if (!aProxy->NotificationsDeferred())
118752:     aProxy->OnStopDecode();
 48320: }
 48320: 
 48320: void
 48320: imgStatusTracker::RecordDiscard()
 48320: {
 51298:   NS_ABORT_IF_FALSE(mImage,
 51298:                     "RecordDiscard called before we have an Image");
 48320:   // Clear the state bits we no longer deserve.
118758:   uint32_t stateBitsToClear = stateDecodeStopped;
 48320:   mState &= ~stateBitsToClear;
 48320: 
 48320:   // Clear the status bits we no longer deserve.
108991:   uint32_t statusBitsToClear = imgIRequest::STATUS_FRAME_COMPLETE
 48320:                                | imgIRequest::STATUS_DECODE_COMPLETE;
 48320:   mImageStatus &= ~statusBitsToClear;
 48320: }
 48320: 
 48320: void
 82096: imgStatusTracker::SendImageIsAnimated(imgRequestProxy* aProxy)
 82096: {
 82096:   if (!aProxy->NotificationsDeferred())
 82096:     aProxy->OnImageIsAnimated();
 82096: }
 82096: 
 82096: void
 82096: imgStatusTracker::RecordImageIsAnimated()
 82096: {
 82096:   NS_ABORT_IF_FALSE(mImage,
 82096:                     "RecordImageIsAnimated called before we have an Image");
 82096:   // No bookkeeping necessary here - once decoding is complete, GetAnimated()
 82096:   // will accurately return that this is an animated image. Until that time,
 82096:   // the OnImageIsAnimated notification is the only indication an observer
 82096:   // will have that an image has more than 1 frame.
 82096: }
 82096: 
 82096: void
 48320: imgStatusTracker::SendDiscard(imgRequestProxy* aProxy)
 48320: {
 48321:   if (!aProxy->NotificationsDeferred())
 48320:     aProxy->OnDiscard();
 48320: }
 48320: 
 48320: /* non-virtual imgIContainerObserver methods */
 48320: void
118757: imgStatusTracker::RecordFrameChanged(const nsIntRect* aDirtyRect)
 48320: {
 51298:   NS_ABORT_IF_FALSE(mImage,
 51298:                     "RecordFrameChanged called before we have an Image");
 48320:   // no bookkeeping necessary here - this is only for in-frame updates, which we
 48320:   // don't fire while we're recording
 48320: }
 48320: 
 48320: void
118757: imgStatusTracker::SendFrameChanged(imgRequestProxy* aProxy,
 50543:                                    const nsIntRect* aDirtyRect)
 48320: {
 48321:   if (!aProxy->NotificationsDeferred())
118758:     aProxy->OnFrameUpdate(aDirtyRect);
 48320: }
 48320: 
 48320: /* non-virtual sort-of-nsIRequestObserver methods */
 48320: void
 48320: imgStatusTracker::RecordStartRequest()
 48320: {
 48320:   // We're starting a new load, so clear any status and state bits indicating
 48320:   // load/decode
 48320:   mImageStatus &= ~imgIRequest::STATUS_LOAD_PARTIAL;
 48320:   mImageStatus &= ~imgIRequest::STATUS_LOAD_COMPLETE;
 48320:   mImageStatus &= ~imgIRequest::STATUS_FRAME_COMPLETE;
 48320:   mState &= ~stateRequestStarted;
 48320:   mState &= ~stateDecodeStopped;
 48320:   mState &= ~stateRequestStopped;
108324:   mState &= ~stateBlockingOnload;
 48320: 
 48320:   mState |= stateRequestStarted;
 48320: }
 48320: 
 48320: void
 48320: imgStatusTracker::SendStartRequest(imgRequestProxy* aProxy)
 48320: {
 48321:   if (!aProxy->NotificationsDeferred())
 48320:     aProxy->OnStartRequest();
 48320: }
 48320: 
 48320: void
118749: imgStatusTracker::OnStartRequest()
118749: {
118749:   RecordStartRequest();
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
118749:   while (iter.HasMore()) {
118749:     SendStartRequest(iter.GetNext());
118749:   }
118749: }
118749: 
118749: void
118757: imgStatusTracker::RecordStopRequest(bool aLastPart,
118757:                                     nsresult aStatus)
 48320: {
 48320:   mHadLastPart = aLastPart;
 48320:   mState |= stateRequestStopped;
 48320: 
 48320:   // If we were successful in loading, note that the image is complete.
118753:   if (NS_SUCCEEDED(aStatus) && mImageStatus != imgIRequest::STATUS_ERROR)
 48320:     mImageStatus |= imgIRequest::STATUS_LOAD_COMPLETE;
118753:   else
118753:     mImageStatus = imgIRequest::STATUS_ERROR;
 48320: }
 48320: 
 48320: void
118757: imgStatusTracker::SendStopRequest(imgRequestProxy* aProxy,
118757:                                   bool aLastPart,
118757:                                   nsresult aStatus)
 48320: {
 48321:   if (!aProxy->NotificationsDeferred()) {
 48320:     aProxy->OnStopRequest(aLastPart);
 48320:   }
 48321: }
108324: 
108324: void
118757: imgStatusTracker::OnStopRequest(bool aLastPart,
118757:                                 nsresult aStatus)
118749: {
118756:   bool preexistingError = mImageStatus == imgIRequest::STATUS_ERROR;
118756: 
118749:   RecordStopRequest(aLastPart, aStatus);
118749:   /* notify the kids */
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator srIter(mConsumers);
118749:   while (srIter.HasMore()) {
118749:     SendStopRequest(srIter.GetNext(), aLastPart, aStatus);
118749:   }
118753: 
118969:   if (NS_FAILED(aStatus) && !preexistingError && GetRequest()) {
118756:     FireFailureNotification(GetRequest());
118753:   }
118749: }
118749: 
118749: void
118749: imgStatusTracker::OnDataAvailable()
118749: {
118749:   // Notify any imgRequestProxys that are observing us that we have an Image.
118749:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
118749:   while (iter.HasMore()) {
118749:     iter.GetNext()->SetHasImage();
118749:   }
118749: }
118749: 
118749: void
108324: imgStatusTracker::RecordBlockOnload()
108324: {
108324:   MOZ_ASSERT(!(mState & stateBlockingOnload));
108324:   mState |= stateBlockingOnload;
108324: }
108324: 
108324: void
108324: imgStatusTracker::SendBlockOnload(imgRequestProxy* aProxy)
108324: {
108324:   if (!aProxy->NotificationsDeferred()) {
108324:     aProxy->BlockOnload();
108324:   }
108324: }
108324: 
108324: void
108324: imgStatusTracker::RecordUnblockOnload()
108324: {
108324:   MOZ_ASSERT(mState & stateBlockingOnload);
108324:   mState &= ~stateBlockingOnload;
108324: }
108324: 
108324: void
108324: imgStatusTracker::SendUnblockOnload(imgRequestProxy* aProxy)
108324: {
108324:   if (!aProxy->NotificationsDeferred()) {
108324:     aProxy->UnblockOnload();
108324:   }
108324: }
118748: 
118748: void
118748: imgStatusTracker::MaybeUnblockOnload()
118748: {
118748:   if (!mBlockingOnload) {
118748:     return;
118748:   }
118748: 
118748:   mBlockingOnload = false;
118748: 
118748:   RecordUnblockOnload();
118748: 
118748:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
118748:   while (iter.HasMore()) {
118748:     SendUnblockOnload(iter.GetNext());
118748:   }
118748: }
