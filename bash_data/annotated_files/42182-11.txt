    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object for HTML <frameset> elements */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsFrameSetFrame.h"
    1: #include "nsContentUtils.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsLeafFrame.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsIURL.h"
    1: #include "nsIDocument.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsStyleCoord.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsStyleContext.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsStyleSet.h"
    1: #include "nsIContent.h"
    1: #include "nsDisplayList.h"
    1: #include "nsNodeUtils.h"
14228: #include "mozAutoDocUpdate.h"
    1: 
    1: // masks for mEdgeVisibility
    1: #define LEFT_VIS   0x0001
    1: #define RIGHT_VIS  0x0002
    1: #define TOP_VIS    0x0004
    1: #define BOTTOM_VIS 0x0008
    1: #define ALL_VIS    0x000F
    1: #define NONE_VIS   0x0000
    1: 
    1: static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
    1: 
    1: /*******************************************************************************
    1:  * nsFramesetDrag
    1:  ******************************************************************************/
    1: nsFramesetDrag::nsFramesetDrag() 
    1: {
    1:   UnSet();
    1: }
    1: 
    1: void nsFramesetDrag::Reset(PRBool               aVertical, 
    1:                            PRInt32              aIndex, 
    1:                            PRInt32              aChange, 
    1:                            nsHTMLFramesetFrame* aSource) 
    1: {
    1:   mVertical = aVertical;
    1:   mIndex    = aIndex;
    1:   mChange   = aChange;
    1:   mSource   = aSource;
    1:   mActive   = PR_TRUE;
    1: }
    1: 
    1: void nsFramesetDrag::UnSet()
    1: {
    1:   mVertical = PR_TRUE;
    1:   mIndex    = -1;
    1:   mChange   = 0;
    1:   mSource   = nsnull;
    1:   mActive   = PR_FALSE;
    1: }
    1: 
    1: /*******************************************************************************
    1:  * nsHTMLFramesetBorderFrame
    1:  ******************************************************************************/
32423: class nsHTMLFramesetBorderFrame : public nsLeafFrame
32423: {
32423: public:
32423:   NS_DECL_FRAMEARENA_HELPERS
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
    1: #endif
    1: 
    1:   NS_IMETHOD HandleEvent(nsPresContext* aPresContext, 
    1:                          nsGUIEvent* aEvent,
    1:                          nsEventStatus* aEventStatus);
    1: 
    1:   NS_IMETHOD GetCursor(const nsPoint&    aPoint,
    1:                        nsIFrame::Cursor& aCursor);
    1:   
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists);
    1: 
    1:   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
    1:                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus);
    1: 
    1:   PRBool GetVisibility() { return mVisibility || mVisibilityOverride; }
    1:   void SetVisibility(PRBool aVisibility);
    1:   void SetColor(nscolor aColor);
    1: 
    1:   void PaintBorder(nsIRenderingContext& aRenderingContext, nsPoint aPt);
    1: 
    1: protected:
    1:   nsHTMLFramesetBorderFrame(nsStyleContext* aContext, PRInt32 aWidth, PRBool aVertical, PRBool aVisible);
    1:   virtual ~nsHTMLFramesetBorderFrame();
    1:   virtual nscoord GetIntrinsicWidth();
21104:   virtual nscoord GetIntrinsicHeight();
    1: 
28285:   // the prev and next neighbors are indexes into the row (for a horizontal border) or col (for
28285:   // a vertical border) of nsHTMLFramesetFrames or nsHTMLFrames
28285:   PRInt32 mPrevNeighbor;
28285:   PRInt32 mNextNeighbor;
28285:   nscolor mColor;
    1:   PRInt32 mWidth;
    1:   PRPackedBool mVertical;
    1:   PRPackedBool mVisibility;
    1:   PRPackedBool mVisibilityOverride;
28285:   PRPackedBool mCanResize;
    1:   friend class nsHTMLFramesetFrame;
    1: };
    1: /*******************************************************************************
    1:  * nsHTMLFramesetBlankFrame
    1:  ******************************************************************************/
32423: class nsHTMLFramesetBlankFrame : public nsLeafFrame
32423: {
32423: public:
32423:   NS_DECL_FRAMEARENA_HELPERS
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
    1: #endif
    1: 
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists);
    1: 
    1:   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
    1:                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus);
    1: 
    1: protected:
    1:   nsHTMLFramesetBlankFrame(nsStyleContext* aContext) : nsLeafFrame(aContext) {}
    1:   virtual ~nsHTMLFramesetBlankFrame();
    1:   virtual nscoord GetIntrinsicWidth();
21104:   virtual nscoord GetIntrinsicHeight();
    1: 
    1:   friend class nsHTMLFramesetFrame;
    1:   friend class nsHTMLFrameset;
    1: };
    1: 
    1: /*******************************************************************************
    1:  * nsHTMLFramesetFrame
    1:  ******************************************************************************/
    1: PRBool  nsHTMLFramesetFrame::gDragInProgress = PR_FALSE;
    1: #define kFrameResizePref "layout.frames.force_resizability"
    1: #define DEFAULT_BORDER_WIDTH_PX 6
    1: 
    1: nsHTMLFramesetFrame::nsHTMLFramesetFrame(nsStyleContext* aContext)
    1:   : nsHTMLContainerFrame(aContext)
    1: {
    1:   mNumRows             = 0;
    1:   mRowSizes            = nsnull;
    1:   mNumCols             = 0;
    1:   mColSizes            = nsnull;
    1:   mEdgeVisibility      = 0;
    1:   mParentFrameborder   = eFrameborder_Yes; // default
    1:   mParentBorderWidth   = -1; // default not set
    1:   mParentBorderColor   = NO_COLOR; // default not set
    1:   mFirstDragPoint.x     = mFirstDragPoint.y = 0;
    1:   mMinDrag             = nsPresContext::CSSPixelsToAppUnits(2);
    1:   mNonBorderChildCount = 0;
    1:   mNonBlankChildCount  = 0;
    1:   mDragger             = nsnull;
    1:   mChildCount          = 0;
    1:   mTopLevelFrameset    = nsnull;
    1:   mEdgeColors.Set(NO_COLOR);
    1:   mVerBorders          = nsnull;
    1:   mHorBorders          = nsnull;
    1:   mChildTypes          = nsnull;
    1:   mChildFrameborder    = nsnull;
    1:   mChildBorderColors   = nsnull;
    1:   mForceFrameResizability = PR_FALSE;
    1: }
    1: 
    1: nsHTMLFramesetFrame::~nsHTMLFramesetFrame()
    1: {
    1:   delete[] mRowSizes;
    1:   delete[] mColSizes;
    1:   delete[] mVerBorders;
    1:   delete[] mHorBorders;
    1:   delete[] mChildTypes;
    1:   delete[] mChildFrameborder;
    1:   delete[] mChildBorderColors;
    1: 
    1:   nsContentUtils::UnregisterPrefCallback(kFrameResizePref,
    1:                                          FrameResizePrefCallback, this);
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsHTMLFramesetFrame)
23554:   NS_QUERYFRAME_ENTRY(nsHTMLFramesetFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsHTMLContainerFrame)
    1: 
    1: // static
    1: int
    1: nsHTMLFramesetFrame::FrameResizePrefCallback(const char* aPref, void* aClosure)
    1: {
    1:   nsHTMLFramesetFrame *frame =
 3233:     reinterpret_cast<nsHTMLFramesetFrame *>(aClosure);
    1: 
    1:   nsIDocument* doc = frame->mContent->GetDocument();
    1:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, PR_TRUE);
    1:   if (doc) {
29833:     nsNodeUtils::AttributeWillChange(frame->mContent, kNameSpaceID_None,
29833:                                      nsGkAtoms::frameborder,
29833:                                      nsIDOMMutationEvent::MODIFICATION);
    1:   }
    1: 
    1:   frame->mForceFrameResizability =
    1:     nsContentUtils::GetBoolPref(kFrameResizePref,
    1:                                 frame->mForceFrameResizability);
    1: 
    1:   frame->RecalculateBorderResize();
    1:   if (doc) {
    1:     nsNodeUtils::AttributeChanged(frame->GetContent(),
    1:                                   kNameSpaceID_None,
    1:                                   nsGkAtoms::frameborder,
35535:                                   nsIDOMMutationEvent::MODIFICATION);
    1:   }
    1: 
    1:   return 0;
    1: }
    1: 
    1: #define FRAMESET 0
    1: #define FRAME 1
    1: #define BLANK 2
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetFrame::Init(nsIContent*      aContent,
    1:                           nsIFrame*        aParent,
    1:                           nsIFrame*        aPrevInFlow)
    1: {
    1:   nsHTMLContainerFrame::Init(aContent, aParent, aPrevInFlow);
    1:   // find the highest ancestor that is a frameset
    1:   nsresult rv = NS_OK;
    1:   nsIFrame* parentFrame = GetParent();
    1:   mTopLevelFrameset = (nsHTMLFramesetFrame*)this;
    1:   while (parentFrame) {
23554:     nsHTMLFramesetFrame* frameset = do_QueryFrame(parentFrame);
    1:     if (frameset) {
    1:       mTopLevelFrameset = frameset;
    1:       parentFrame = parentFrame->GetParent();
    1:     } else {
    1:       break;
    1:     }
    1:   }
    1: 
26050:   nsPresContext* presContext = PresContext();
26050:   nsIPresShell* shell = presContext->PresShell();
    1: 
    1:   nsFrameborder  frameborder = GetFrameBorder();
26050:   PRInt32 borderWidth = GetBorderWidth(presContext, PR_FALSE);
    1:   nscolor borderColor = GetBorderColor();
    1:  
    1:   // Get the rows= cols= data
    1:   nsCOMPtr<nsIFrameSetElement> ourContent(do_QueryInterface(mContent));
    1:   NS_ASSERTION(ourContent, "Someone gave us a broken frameset element!");
    1:   const nsFramesetSpec* rowSpecs = nsnull;
    1:   const nsFramesetSpec* colSpecs = nsnull;
    1:   nsresult result = ourContent->GetRowSpec(&mNumRows, &rowSpecs);
    1:   NS_ENSURE_SUCCESS(result, result);
    1:   result = ourContent->GetColSpec(&mNumCols, &colSpecs);
    1:   NS_ENSURE_SUCCESS(result, result);
    1:   mRowSizes  = new nscoord[mNumRows];
    1:   mColSizes  = new nscoord[mNumCols];
    1:   if (!mRowSizes || !mColSizes)
    1:     return NS_ERROR_OUT_OF_MEMORY; 
    1: 
    1:   PRInt32 numCells = mNumRows*mNumCols;
    1: 
    1:   mVerBorders    = new nsHTMLFramesetBorderFrame*[mNumCols];  // 1 more than number of ver borders
    1:   if (!mVerBorders)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   for (int verX  = 0; verX < mNumCols; verX++)
    1:     mVerBorders[verX]    = nsnull;
    1: 
    1:   mHorBorders    = new nsHTMLFramesetBorderFrame*[mNumRows];  // 1 more than number of hor borders
    1:   if (!mHorBorders)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   for (int horX = 0; horX < mNumRows; horX++)
    1:     mHorBorders[horX]    = nsnull;
    1:      
    1:   mChildTypes = new PRInt32[numCells]; 
    1:   mChildFrameborder  = new nsFrameborder[numCells]; 
    1:   mChildBorderColors  = new nsBorderColor[numCells]; 
    1:   if (!mChildTypes || !mChildFrameborder || !mChildBorderColors)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // create the children frames; skip content which isn't <frameset> or <frame>
    1:   mChildCount = 0; // number of <frame> or <frameset> children
    1:   nsIFrame* frame;
    1: 
    1:   // number of any type of children
    1:   PRUint32 numChildren = mContent->GetChildCount();
    1: 
    1:   for (PRUint32 childX = 0; childX < numChildren; childX++) {
    1:     if (mChildCount == numCells) { // we have more <frame> or <frameset> than cells
    1:       break;
    1:     }
    1:     nsIContent *child = mContent->GetChildAt(childX);
    1: 
    1:     // IMPORTANT: This must match the conditions in
    1:     // nsCSSFrameConstructor::ContentAppended/Inserted/Removed    
33329:     if (!child->IsHTML())
    1:       continue;
    1: 
    1:     nsIAtom *tag = child->Tag();
    1:     if (tag == nsGkAtoms::frameset || tag == nsGkAtoms::frame) {
    1:       nsRefPtr<nsStyleContext> kidSC;
    1:       nsresult result;
    1: 
41641:       kidSC = shell->StyleSet()->ResolveStyleFor(child->AsElement(),
41641:                                                  mStyleContext);
    1:       if (tag == nsGkAtoms::frameset) {
    1:         frame = NS_NewHTMLFramesetFrame(shell, kidSC);
    1:         if (NS_UNLIKELY(!frame))
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         mChildTypes[mChildCount] = FRAMESET;
    1:         nsHTMLFramesetFrame* childFrame = (nsHTMLFramesetFrame*)frame;
    1:         childFrame->SetParentFrameborder(frameborder);
    1:         childFrame->SetParentBorderWidth(borderWidth);
    1:         childFrame->SetParentBorderColor(borderColor);
    1:         result = frame->Init(child, this, nsnull);
    1:         if (NS_FAILED(result)) {
    1:           frame->Destroy();
    1:           return result;
    1:         }
    1: 
    1:         mChildBorderColors[mChildCount].Set(childFrame->GetBorderColor());
    1:       } else { // frame
    1:         frame = NS_NewSubDocumentFrame(shell, kidSC);
    1:         if (NS_UNLIKELY(!frame))
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         result = frame->Init(child, this, nsnull);
    1:         if (NS_FAILED(result)) {
    1:           frame->Destroy();
    1:           return result;
    1:         }
    1: 
    1:         mChildTypes[mChildCount] = FRAME;
    1:         
    1:         mChildFrameborder[mChildCount] = GetFrameBorder(child);
    1:         mChildBorderColors[mChildCount].Set(GetBorderColor(child));
    1:       }
36653:       child->SetPrimaryFrame(frame);
    1:       
    1:       if (NS_FAILED(result))
    1:         return result;
    1: 
32841:       mFrames.AppendFrame(nsnull, frame);
    1: 
    1:       mChildCount++;
    1:     }
    1:   }
    1: 
    1:   mNonBlankChildCount = mChildCount;
    1:   // add blank frames for frameset cells that had no content provided
    1:   for (int blankX = mChildCount; blankX < numCells; blankX++) {
    1:     nsRefPtr<nsStyleContext> pseudoStyleContext;
    1:     pseudoStyleContext = shell->StyleSet()->
35554:       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::framesetBlank, mStyleContext);
    1:     if (!pseudoStyleContext) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     // XXX the blank frame is using the content of its parent - at some point it 
    1:     // should just have null content, if we support that                                                            
    1:     nsHTMLFramesetBlankFrame* blankFrame = new (shell) nsHTMLFramesetBlankFrame(pseudoStyleContext);
    1:     if (!blankFrame)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     result = blankFrame->Init(mContent, this, nsnull);
    1:     if (NS_FAILED(result)) {
    1:       blankFrame->Destroy();
    1:       return result;
    1:     }
    1:    
32841:     mFrames.AppendFrame(nsnull, blankFrame);
    1: 
    1:     mChildTypes[mChildCount] = BLANK;
    1:     mChildBorderColors[mChildCount].Set(NO_COLOR);
    1:     mChildCount++;
    1:   }
    1: 
    1:   mNonBorderChildCount = mChildCount;
    1:   return rv;
    1: }
    1: 
23939: NS_IMETHODIMP
23939: nsHTMLFramesetFrame::SetInitialChildList(nsIAtom*     aListName,
30790:                                          nsFrameList& aChildList)
23939: {
23939:   // We do this weirdness where we create our child frames in Init().  On the
30790:   // other hand, we're going to get a SetInitialChildList() with an empty list
30790:   // and null list name after the frame constructor is done creating us.  So
30790:   // just ignore that call.
30790:   if (!aListName && aChildList.IsEmpty()) {
23939:     return NS_OK;
23939:   }
23939: 
23939:   return nsHTMLContainerFrame::SetInitialChildList(aListName, aChildList);
23939: }
23939: 
    1: // XXX should this try to allocate twips based on an even pixel boundary?
    1: void nsHTMLFramesetFrame::Scale(nscoord  aDesired, 
    1:                                 PRInt32  aNumIndicies, 
    1:                                 PRInt32* aIndicies, 
    1:                                 PRInt32  aNumItems,
    1:                                 PRInt32* aItems)
    1: {
    1:   PRInt32 actual = 0;
    1:   PRInt32 i, j;
    1:   // get the actual total
    1:   for (i = 0; i < aNumIndicies; i++) {
    1:     j = aIndicies[i];
    1:     actual += aItems[j];
    1:   }
    1: 
    1:   if (actual > 0) {
    1:     float factor = (float)aDesired / (float)actual;
    1:     actual = 0;
    1:     // scale the items up or down
    1:     for (i = 0; i < aNumIndicies; i++) {
    1:       j = aIndicies[i];
    1:       aItems[j] = NSToCoordRound((float)aItems[j] * factor);
    1:       actual += aItems[j];
    1:     }
    1:   } else if (aNumIndicies != 0) {
    1:     // All the specs say zero width, but we have to fill up space
    1:     // somehow.  Distribute it equally.
    1:     nscoord width = NSToCoordRound((float)aDesired / (float)aNumIndicies);
    1:     actual = width * aNumIndicies;
    1:     for (i = 0; i < aNumIndicies; i++) {
    1:       aItems[aIndicies[i]] = width;
    1:     }
    1:   }
    1: 
    1:   if (aNumIndicies > 0 && aDesired != actual) {
    1:     PRInt32 unit = (aDesired > actual) ? 1 : -1;
    1:     for (i=0; (i < aNumIndicies) && (aDesired != actual); i++) {
    1:       j = aIndicies[i];
    1:       if (j < aNumItems) {
    1:         aItems[j] += unit;
    1:         actual += unit;
    1:       }
    1:     }
    1:   }
    1: }
    1:   
    1: 
    1: /**
    1:   * Translate the rows/cols specs into an array of integer sizes for
    1:   * each cell in the frameset. Sizes are allocated based on the priorities of the
    1:   * specifier - fixed sizes have the highest priority, percentage sizes have the next
    1:   * highest priority and relative sizes have the lowest.
    1:   */
    1: void nsHTMLFramesetFrame::CalculateRowCol(nsPresContext*       aPresContext, 
    1:                                           nscoord               aSize, 
    1:                                           PRInt32               aNumSpecs, 
    1:                                           const nsFramesetSpec* aSpecs, 
    1:                                           nscoord*              aValues)
    1: {
    1:   PRInt32  fixedTotal = 0;
    1:   PRInt32  numFixed = 0;
    1:   nsAutoArrayPtr<PRInt32> fixed(new PRInt32[aNumSpecs]);
    1:   PRInt32  numPercent = 0;
    1:   nsAutoArrayPtr<PRInt32> percent(new PRInt32[aNumSpecs]);
    1:   PRInt32  relativeSums = 0;
    1:   PRInt32  numRelative = 0;
    1:   nsAutoArrayPtr<PRInt32> relative(new PRInt32[aNumSpecs]);
    1: 
    1:   if (NS_UNLIKELY(!fixed || !percent || !relative)) {
    1:     return; // NS_ERROR_OUT_OF_MEMORY
    1:   }
    1: 
    1:   PRInt32 i, j;
    1:  
    1:   // initialize the fixed, percent, relative indices, allocate the fixed sizes and zero the others
    1:   for (i = 0; i < aNumSpecs; i++) {   
    1:     aValues[i] = 0;
    1:     switch (aSpecs[i].mUnit) {
    1:       case eFramesetUnit_Fixed:
    1:         aValues[i] = nsPresContext::CSSPixelsToAppUnits(aSpecs[i].mValue);
    1:         fixedTotal += aValues[i];
    1:         fixed[numFixed] = i;
    1:         numFixed++;
    1:         break;
    1:       case eFramesetUnit_Percent:
    1:         percent[numPercent] = i;
    1:         numPercent++;
    1:         break;
    1:       case eFramesetUnit_Relative:
    1:         relative[numRelative] = i;
    1:         numRelative++;
    1:         relativeSums += aSpecs[i].mValue;
    1:         break;
    1:     }
    1:   }
    1: 
    1:   // scale the fixed sizes if they total too much (or too little and there aren't any percent or relative)
    1:   if ((fixedTotal > aSize) || ((fixedTotal < aSize) && (0 == numPercent) && (0 == numRelative))) { 
    1:     Scale(aSize, numFixed, fixed, aNumSpecs, aValues);
    1:     return;
    1:   }
    1: 
    1:   PRInt32 percentMax = aSize - fixedTotal;
    1:   PRInt32 percentTotal = 0;
    1:   // allocate the percentage sizes from what is left over from the fixed allocation
    1:   for (i = 0; i < numPercent; i++) {
    1:     j = percent[i];
    1:     aValues[j] = NSToCoordRound((float)aSpecs[j].mValue * (float)aSize / 100.0f);
    1:     percentTotal += aValues[j];
    1:   }
    1: 
    1:   // scale the percent sizes if they total too much (or too little and there aren't any relative)
    1:   if ((percentTotal > percentMax) || ((percentTotal < percentMax) && (0 == numRelative))) { 
    1:     Scale(percentMax, numPercent, percent, aNumSpecs, aValues);
    1:     return;
    1:   }
    1: 
    1:   PRInt32 relativeMax = percentMax - percentTotal;
    1:   PRInt32 relativeTotal = 0;
    1:   // allocate the relative sizes from what is left over from the percent allocation
    1:   for (i = 0; i < numRelative; i++) {
    1:     j = relative[i];
    1:     aValues[j] = NSToCoordRound((float)aSpecs[j].mValue * (float)relativeMax / (float)relativeSums);
    1:     relativeTotal += aValues[j];
    1:   }
    1: 
    1:   // scale the relative sizes if they take up too much or too little
    1:   if (relativeTotal != relativeMax) { 
    1:     Scale(relativeMax, numRelative, relative, aNumSpecs, aValues);
    1:   }
    1: }
    1: 
    1: 
    1: /**
    1:   * Translate the rows/cols integer sizes into an array of specs for
    1:   * each cell in the frameset.  Reverse of CalculateRowCol() behaviour.
    1:   * This allows us to maintain the user size info through reflows.
    1:   */
    1: void nsHTMLFramesetFrame::GenerateRowCol(nsPresContext*       aPresContext, 
    1:                                          nscoord               aSize, 
    1:                                          PRInt32               aNumSpecs, 
    1:                                          const nsFramesetSpec* aSpecs,
    1:                                          nscoord*              aValues,
    1:                                          nsString&             aNewAttr)
    1: {
    1:   PRInt32 i;
    1:  
    1:   for (i = 0; i < aNumSpecs; i++) {
    1:     if (!aNewAttr.IsEmpty())
    1:       aNewAttr.Append(PRUnichar(','));
    1:     
    1:     switch (aSpecs[i].mUnit) {
    1:       case eFramesetUnit_Fixed:
    1:         aNewAttr.AppendInt(nsPresContext::AppUnitsToIntCSSPixels(aValues[i]));
    1:         break;
    1:       case eFramesetUnit_Percent: // XXX Only accurate to 1%, need 1 pixel
    1:       case eFramesetUnit_Relative:
    1:         // Add 0.5 to the percentage to make rounding work right.
    1:         aNewAttr.AppendInt(PRUint32((100.0*aValues[i])/aSize + 0.5)); 
    1:         aNewAttr.Append(PRUnichar('%'));
    1:         break;
    1:     }
    1:   }
    1: }
    1: 
    1: PRInt32 nsHTMLFramesetFrame::GetBorderWidth(nsPresContext* aPresContext,
    1:                                             PRBool aTakeForcingIntoAccount)
    1: {
    1:   PRBool forcing = mForceFrameResizability && aTakeForcingIntoAccount;
    1:   
    1:   if (!forcing) {
    1:     nsFrameborder frameborder = GetFrameBorder();
    1:     if (frameborder == eFrameborder_No) {
    1:       return 0;
    1:     }
    1:   }
    1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
    1: 
    1:   if (content) {
    1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::border);
    1:     if (attr) {
    1:       PRInt32 intVal = 0;
    1:       if (attr->Type() == nsAttrValue::eInteger) {
    1:         intVal = attr->GetIntegerValue();
    1:         if (intVal < 0) {
    1:           intVal = 0;
    1:         }
    1:       }
    1: 
    1:       if (forcing && intVal == 0) {
    1:         intVal = DEFAULT_BORDER_WIDTH_PX;
    1:       }
    1:       return nsPresContext::CSSPixelsToAppUnits(intVal);
    1:     }
    1:   }
    1: 
    1:   if (mParentBorderWidth > 0 ||
    1:       (mParentBorderWidth == 0 && !forcing)) {
    1:     return mParentBorderWidth;
    1:   }
    1: 
    1:   return nsPresContext::CSSPixelsToAppUnits(DEFAULT_BORDER_WIDTH_PX);
    1: }
    1: 
    1: 
    1: PRIntn
    1: nsHTMLFramesetFrame::GetSkipSides() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: void 
    1: nsHTMLFramesetFrame::GetDesiredSize(nsPresContext*          aPresContext,
    1:                                     const nsHTMLReflowState& aReflowState,
    1:                                     nsHTMLReflowMetrics&     aDesiredSize)
    1: {
    1:   nsHTMLFramesetFrame* framesetParent = GetFramesetParent(this);
    1:   if (nsnull == framesetParent) {
    1:     if (aPresContext->IsPaginated()) {
    1:       // XXX This needs to be changed when framesets paginate properly
    1:       aDesiredSize.width = aReflowState.availableWidth;
    1:       aDesiredSize.height = aReflowState.availableHeight;
    1:     } else {
    1:       nsRect area = aPresContext->GetVisibleArea();
    1: 
    1:       aDesiredSize.width = area.width;
    1:       aDesiredSize.height= area.height;
    1:     }
    1:   } else {
    1:     nsSize size;
    1:     framesetParent->GetSizeOfChild(this, size);
    1:     aDesiredSize.width  = size.width;
    1:     aDesiredSize.height = size.height;
    1:   } 
    1: }
    1: 
    1: 
    1: nsHTMLFramesetFrame* nsHTMLFramesetFrame::GetFramesetParent(nsIFrame* aChild)
    1: {
    1:   nsHTMLFramesetFrame* parent = nsnull;
    1:   nsIContent* content = aChild->GetContent();
    1: 
    1:   if (content) { 
    1:     nsCOMPtr<nsIContent> contentParent = content->GetParent();
    1: 
33329:     if (contentParent && contentParent->IsHTML() &&
    1:         contentParent->Tag() == nsGkAtoms::frameset) {
    1:       nsIFrame* fptr = aChild->GetParent();
    1:       parent = (nsHTMLFramesetFrame*) fptr;
    1:     }
    1:   }
    1: 
    1:   return parent;
    1: }
    1: 
    1: // only valid for non border children
    1: void nsHTMLFramesetFrame::GetSizeOfChildAt(PRInt32  aIndexInParent, 
    1:                                            nsSize&  aSize, 
23738:                                            nsIntPoint& aCellIndex)
    1: {
    1:   PRInt32 row = aIndexInParent / mNumCols;
    1:   PRInt32 col = aIndexInParent - (row * mNumCols); // remainder from dividing index by mNumCols
    1:   if ((row < mNumRows) && (col < mNumCols)) {
    1:     aSize.width  = mColSizes[col];
    1:     aSize.height = mRowSizes[row];
    1:     aCellIndex.x = col;
    1:     aCellIndex.y = row;
    1:   } else {
23738:     aSize.width = aSize.height = 0;
23738:     aCellIndex.x = aCellIndex.y = 0;
    1:   }
    1: }
    1: 
    1: // only valid for non border children
    1: void nsHTMLFramesetFrame::GetSizeOfChild(nsIFrame* aChild, 
    1:                                          nsSize&   aSize)
    1: {
    1:   // Reflow only creates children frames for <frameset> and <frame> content.
    1:   // this assumption is used here
    1:   int i = 0;
    1:   for (nsIFrame* child = mFrames.FirstChild(); child;
    1:        child = child->GetNextSibling()) {
    1:     if (aChild == child) {
23738:       nsIntPoint ignore;
    1:       GetSizeOfChildAt(i, aSize, ignore);
    1:       return;
    1:     }
    1:     i++;
    1:   }
    1:   aSize.width  = 0;
    1:   aSize.height = 0;
    1: }  
    1: 
    1:   
    1: NS_METHOD nsHTMLFramesetFrame::HandleEvent(nsPresContext* aPresContext, 
    1:                                            nsGUIEvent*     aEvent,
    1:                                            nsEventStatus*  aEventStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
    1:   if (mDragger) {
    1:     // the nsFramesetBorderFrame has captured NS_MOUSE_DOWN
    1:     switch (aEvent->message) {
    1:       case NS_MOUSE_MOVE:
    1:         MouseDrag(aPresContext, aEvent);
    1: 	      break;
    1:       case NS_MOUSE_BUTTON_UP:
    1:         if (aEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:             static_cast<nsMouseEvent*>(aEvent)->button ==
    1:               nsMouseEvent::eLeftButton) {
    1:           EndMouseDrag(aPresContext);
    1:         }
    1: 	      break;
    1:     }
    1:     *aEventStatus = nsEventStatus_eConsumeNoDefault;
    1:   } else {
    1:     *aEventStatus = nsEventStatus_eIgnore;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetFrame::GetCursor(const nsPoint&    aPoint,
    1:                                nsIFrame::Cursor& aCursor)
    1: {
    1:   if (mDragger) {
31385:     aCursor.mCursor = (mDragger->mVertical) ? NS_STYLE_CURSOR_EW_RESIZE : NS_STYLE_CURSOR_NS_RESIZE;
    1:   } else {
    1:     aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                       const nsRect&           aDirtyRect,
    1:                                       const nsDisplayListSet& aLists)
    1: {
    1:   nsresult rv = nsHTMLContainerFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   if (mDragger && aBuilder->IsForEventDelivery()) {
    1:     // REVIEW: GetFrameForPoint would always target ourselves if mDragger set
    1:     nsDisplayItem* item = new (aBuilder) nsDisplayEventReceiver(this);
    1:     if (!item)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     aLists.Content()->AppendToTop(item);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: void 
    1: nsHTMLFramesetFrame::ReflowPlaceChild(nsIFrame*                aChild,
    1:                                       nsPresContext*          aPresContext,
    1:                                       const nsHTMLReflowState& aReflowState,
    1:                                       nsPoint&                 aOffset,
    1:                                       nsSize&                  aSize,
23738:                                       nsIntPoint*              aCellIndex)
    1: {
    1:   // reflow the child
    1:   nsHTMLReflowState  reflowState(aPresContext, aReflowState, aChild, aSize);
    1:   nsHTMLReflowMetrics metrics;
    1:   metrics.width = aSize.width;
    1:   metrics.height= aSize.height;
    1:   nsReflowStatus status;
    1:   
    1:   ReflowChild(aChild, aPresContext, metrics, reflowState, aOffset.x,
    1:               aOffset.y, 0, status);
    1:   NS_ASSERTION(NS_FRAME_IS_COMPLETE(status), "bad status");
    1:   
    1:   // Place and size the child
    1:   metrics.width = aSize.width;
    1:   metrics.height = aSize.height;
    1:   FinishReflowChild(aChild, aPresContext, nsnull, metrics, aOffset.x, aOffset.y, 0);
    1: }
    1: 
    1: static
    1: nsFrameborder GetFrameBorderHelper(nsGenericHTMLElement* aContent)
    1: {
    1:   if (nsnull != aContent) {
    1:     const nsAttrValue* attr = aContent->GetParsedAttr(nsGkAtoms::frameborder);
    1:     if (attr && attr->Type() == nsAttrValue::eEnum) {
    1:       switch (attr->GetEnumValue())
    1:       {
    1:         case NS_STYLE_FRAME_YES:
    1:         case NS_STYLE_FRAME_1:
    1:           return eFrameborder_Yes;
    1:           break;
    1: 
    1:         case NS_STYLE_FRAME_NO:
    1:         case NS_STYLE_FRAME_0:
    1:           return eFrameborder_No;
    1:           break;
    1:       }
    1:     }
    1:   }
    1:   return eFrameborder_Notset;
    1: }
    1: 
    1: nsFrameborder nsHTMLFramesetFrame::GetFrameBorder() 
    1: {
    1:   nsFrameborder result = eFrameborder_Notset;
    1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
    1: 
    1:   if (content) {
    1:     result = GetFrameBorderHelper(content);
    1:   }
    1:   if (eFrameborder_Notset == result) {
    1:     return mParentFrameborder;
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsFrameborder nsHTMLFramesetFrame::GetFrameBorder(nsIContent* aContent)
    1: {
    1:   nsFrameborder result = eFrameborder_Notset;
    1: 
    1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(aContent);
    1: 
    1:   if (content) {
    1:     result = GetFrameBorderHelper(content);
    1:   }
    1:   if (eFrameborder_Notset == result) {
    1:     return GetFrameBorder();
    1:   }
    1:   return result;
    1: }
    1: 
    1: nscolor nsHTMLFramesetFrame::GetBorderColor() 
    1: {
    1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
    1: 
    1:   if (content) {
    1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::bordercolor);
    1:     if (attr) {
    1:       nscolor color;
    1:       if (attr->GetColorValue(color)) {
    1:         return color;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return mParentBorderColor;
    1: }
    1: 
    1: nscolor nsHTMLFramesetFrame::GetBorderColor(nsIContent* aContent) 
    1: {
    1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(aContent);
    1: 
    1:   if (content) {
    1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::bordercolor);
    1:     if (attr) {
    1:       nscolor color;
    1:       if (attr->GetColorValue(color)) {
    1:         return color;
    1:       }
    1:     }
    1:   }
    1:   return GetBorderColor();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetFrame::Reflow(nsPresContext*          aPresContext,
    1:                             nsHTMLReflowMetrics&     aDesiredSize,
    1:                             const nsHTMLReflowState& aReflowState,
    1:                             nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsHTMLFramesetFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1:   nsIPresShell *shell = aPresContext->PresShell();
    1:   nsStyleSet *styleSet = shell->StyleSet();
    1: 
    1:   mParent->AddStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
    1:   
    1:   //printf("FramesetFrame2::Reflow %X (%d,%d) \n", this, aReflowState.availableWidth, aReflowState.availableHeight); 
    1:   // Always get the size so that the caller knows how big we are
    1:   GetDesiredSize(aPresContext, aReflowState, aDesiredSize);
    1:   
    1:   nscoord width  = (aDesiredSize.width <= aReflowState.availableWidth)
    1:     ? aDesiredSize.width : aReflowState.availableWidth;
    1:   nscoord height = (aDesiredSize.height <= aReflowState.availableHeight)
    1:     ? aDesiredSize.height : aReflowState.availableHeight;
    1: 
    1:   PRBool firstTime = (GetStateBits() & NS_FRAME_FIRST_REFLOW) != 0;
    1:   if (firstTime) {
    1:     nsContentUtils::RegisterPrefCallback(kFrameResizePref,
    1:                                          FrameResizePrefCallback, this);
    1:     mForceFrameResizability =
    1:       nsContentUtils::GetBoolPref(kFrameResizePref);
    1:   }
    1:   
    1:   // subtract out the width of all of the potential borders. There are
    1:   // only borders between <frame>s. There are none on the edges (e.g the
    1:   // leftmost <frame> has no left border).
    1:   PRInt32 borderWidth = GetBorderWidth(aPresContext, PR_TRUE);
    1: 
    1:   width  -= (mNumCols - 1) * borderWidth;
    1:   if (width < 0) width = 0;
    1: 
    1:   height -= (mNumRows - 1) * borderWidth;
    1:   if (height < 0) height = 0;
    1: 
    1:   nsCOMPtr<nsIFrameSetElement> ourContent(do_QueryInterface(mContent));
    1:   NS_ASSERTION(ourContent, "Someone gave us a broken frameset element!");
    1:   const nsFramesetSpec* rowSpecs = nsnull;
    1:   const nsFramesetSpec* colSpecs = nsnull;
   14:   PRInt32 rows = 0;
   14:   PRInt32 cols = 0;
   14:   ourContent->GetRowSpec(&rows, &rowSpecs);
   14:   ourContent->GetColSpec(&cols, &colSpecs);
   14:   // If the number of cols or rows has changed, the frame for the frameset
   14:   // will be re-created.
  452:   if (mNumRows != rows || mNumCols != cols) {
  452:     aStatus = NS_FRAME_COMPLETE;
  452:     mDrag.UnSet();
  452:     NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
  452:     return NS_OK;
  452:   }
   14: 
   14:   if (!mDrag.mActive) {
    1:     CalculateRowCol(aPresContext, width, mNumCols, colSpecs, mColSizes);
    1:     CalculateRowCol(aPresContext, height, mNumRows, rowSpecs, mRowSizes);
    1:   }
    1: 
    1:   nsAutoArrayPtr<PRBool>  verBordersVis; // vertical borders visibility
    1:   nsAutoArrayPtr<nscolor> verBorderColors;
    1:   nsAutoArrayPtr<PRBool>  horBordersVis; // horizontal borders visibility
    1:   nsAutoArrayPtr<nscolor> horBorderColors;
    1:   nscolor                 borderColor = GetBorderColor();
    1:   nsFrameborder           frameborder = GetFrameBorder();
    1: 
    1:   if (firstTime) {
    1:     verBordersVis = new PRBool[mNumCols];
    1:     NS_ENSURE_TRUE(verBordersVis, NS_ERROR_OUT_OF_MEMORY);
    1:     verBorderColors = new nscolor[mNumCols];
    1:     NS_ENSURE_TRUE(verBorderColors, NS_ERROR_OUT_OF_MEMORY);
    1:     for (int verX  = 0; verX < mNumCols; verX++) {
    1:       verBordersVis[verX] = PR_FALSE;
    1:       verBorderColors[verX] = NO_COLOR;
    1:     }
    1: 
    1:     horBordersVis = new PRBool[mNumRows];
    1:     NS_ENSURE_TRUE(horBordersVis, NS_ERROR_OUT_OF_MEMORY);
    1:     horBorderColors = new nscolor[mNumRows];
    1:     NS_ENSURE_TRUE(horBorderColors, NS_ERROR_OUT_OF_MEMORY);
    1:     for (int horX = 0; horX < mNumRows; horX++) {
    1:       horBordersVis[horX] = PR_FALSE;
    1:       horBorderColors[horX] = NO_COLOR;
    1:     }
    1:   }
    1: 
    1:   // reflow the children
    1:   PRInt32 lastRow = 0;
    1:   PRInt32 lastCol = 0;
    1:   PRInt32 borderChildX = mNonBorderChildCount; // index of border children
    1:   nsHTMLFramesetBorderFrame* borderFrame = nsnull;
    1:   nsPoint offset(0,0);
    1:   nsSize size, lastSize;
    1:   nsIFrame* child = mFrames.FirstChild();
    1: 
    1:   for (PRInt32 childX = 0; childX < mNonBorderChildCount; childX++) {
23738:     nsIntPoint cellIndex;
    1:     GetSizeOfChildAt(childX, size, cellIndex);
    1: 
    1:     if (lastRow != cellIndex.y) {  // changed to next row
    1:       offset.x = 0;
    1:       offset.y += lastSize.height;
    1:       if (firstTime) { // create horizontal border
    1: 
    1:         nsRefPtr<nsStyleContext> pseudoStyleContext;
35554:         pseudoStyleContext = styleSet->
35554:           ResolveAnonymousBoxStyle(nsCSSAnonBoxes::horizontalFramesetBorder,
    1:                                    mStyleContext);
    1: 
    1:         borderFrame = new (shell) nsHTMLFramesetBorderFrame(pseudoStyleContext,
    1:                                                             borderWidth,
    1:                                                             PR_FALSE,
    1:                                                             PR_FALSE);
    1:         if (NS_LIKELY(borderFrame != nsnull)) {
    1:           borderFrame->Init(mContent, this, nsnull);
    1:           mChildCount++;
32841:           mFrames.AppendFrame(nsnull, borderFrame);
    1:           mHorBorders[cellIndex.y-1] = borderFrame;
    1:           // set the neighbors for determining drag boundaries
    1:           borderFrame->mPrevNeighbor = lastRow;
    1:           borderFrame->mNextNeighbor = cellIndex.y;
    1:         }
    1:       } else {
    1:         borderFrame = (nsHTMLFramesetBorderFrame*)mFrames.FrameAt(borderChildX);
    1:         if (NS_LIKELY(borderFrame != nsnull)) {
    1:           borderFrame->mWidth = borderWidth;
    1:           borderChildX++;
    1:         }
    1:       }
    1:       if (NS_LIKELY(borderFrame != nsnull)) {
    1:         nsSize borderSize(aDesiredSize.width, borderWidth);
    1:         ReflowPlaceChild(borderFrame, aPresContext, aReflowState, offset, borderSize);
    1:         borderFrame = nsnull;
    1:       }
    1:       offset.y += borderWidth;
    1:     } else {
    1:       if (cellIndex.x > 0) {  // moved to next col in same row
    1:         if (0 == cellIndex.y) { // in 1st row
    1:           if (firstTime) { // create vertical border
    1:             
    1:             nsRefPtr<nsStyleContext> pseudoStyleContext;
35554:             pseudoStyleContext = styleSet->
35554:               ResolveAnonymousBoxStyle(nsCSSAnonBoxes::verticalFramesetBorder,
    1:                                        mStyleContext);
    1: 
    1:             borderFrame = new (shell) nsHTMLFramesetBorderFrame(pseudoStyleContext, 
    1:                                                                 borderWidth,
    1:                                                                 PR_TRUE,
    1:                                                                 PR_FALSE);
    1:             if (NS_LIKELY(borderFrame != nsnull)) {
    1:               borderFrame->Init(mContent, this, nsnull);
    1:               mChildCount++;
32841:               mFrames.AppendFrame(nsnull, borderFrame);
    1:               mVerBorders[cellIndex.x-1] = borderFrame;
    1:               // set the neighbors for determining drag boundaries
    1:               borderFrame->mPrevNeighbor = lastCol;
    1:               borderFrame->mNextNeighbor = cellIndex.x;
    1:             }
    1:           } else {         
    1:             borderFrame = (nsHTMLFramesetBorderFrame*)mFrames.FrameAt(borderChildX);
    1:             if (NS_LIKELY(borderFrame != nsnull)) {
    1:               borderFrame->mWidth = borderWidth;
    1:               borderChildX++;
    1:             }
    1:           }
    1:           if (NS_LIKELY(borderFrame != nsnull)) {
    1:             nsSize borderSize(borderWidth, aDesiredSize.height);
    1:             ReflowPlaceChild(borderFrame, aPresContext, aReflowState, offset, borderSize);
    1:             borderFrame = nsnull;
    1:           }
    1:         }
    1:         offset.x += borderWidth;
    1:       }
    1:     }
    1: 
    1:     ReflowPlaceChild(child, aPresContext, aReflowState, offset, size, &cellIndex);
    1: 
    1:     if (firstTime) {
    1:       PRInt32 childVis; 
    1:       if (FRAMESET == mChildTypes[childX]) {
    1:         nsHTMLFramesetFrame* childFS = (nsHTMLFramesetFrame*)child; 
    1:         childVis = childFS->mEdgeVisibility;
    1:         mChildBorderColors[childX] = childFS->mEdgeColors;
    1:       } else if (FRAME == mChildTypes[childX]) {
    1:         if (eFrameborder_Yes == mChildFrameborder[childX]) {
    1:           childVis = ALL_VIS;
    1:         } else if (eFrameborder_No == mChildFrameborder[childX]) {
    1:           childVis = NONE_VIS;
    1:         } else {  // notset
    1:           childVis = (eFrameborder_No == frameborder) ? NONE_VIS : ALL_VIS;
    1:         }
    1:       } else {  // blank 
    1:         childVis = NONE_VIS;
    1:       }
    1:       nsBorderColor childColors = mChildBorderColors[childX];
    1:       // set the visibility, color of our edge borders based on children
    1:       if (0 == cellIndex.x) {
    1:         if (!(mEdgeVisibility & LEFT_VIS)) {
    1:           mEdgeVisibility |= (LEFT_VIS & childVis);
    1:         }
    1:         if (NO_COLOR == mEdgeColors.mLeft) {
    1:           mEdgeColors.mLeft = childColors.mLeft;
    1:         }
    1:       }
    1:       if (0 == cellIndex.y) {
    1:         if (!(mEdgeVisibility & TOP_VIS)) {
    1:           mEdgeVisibility |= (TOP_VIS & childVis);
    1:         }
    1:         if (NO_COLOR == mEdgeColors.mTop) {
    1:           mEdgeColors.mTop = childColors.mTop;
    1:         }
    1:       }
    1:       if (mNumCols-1 == cellIndex.x) {
    1:         if (!(mEdgeVisibility & RIGHT_VIS)) {
    1:           mEdgeVisibility |= (RIGHT_VIS & childVis);
    1:         }
    1:         if (NO_COLOR == mEdgeColors.mRight) {
    1:           mEdgeColors.mRight = childColors.mRight;
    1:         }
    1:       }
    1:       if (mNumRows-1 == cellIndex.y) {
    1:         if (!(mEdgeVisibility & BOTTOM_VIS)) {
    1:           mEdgeVisibility |= (BOTTOM_VIS & childVis);
    1:         }
    1:         if (NO_COLOR == mEdgeColors.mBottom) {
    1:           mEdgeColors.mBottom = childColors.mBottom;
    1:         }
    1:       }
    1:       // set the visibility of borders that the child may affect
    1:       if (childVis & RIGHT_VIS) {
    1:         verBordersVis[cellIndex.x] = PR_TRUE;
    1:       }
    1:       if (childVis & BOTTOM_VIS) {
    1:         horBordersVis[cellIndex.y] = PR_TRUE;
    1:       }
    1:       if ((cellIndex.x > 0) && (childVis & LEFT_VIS)) {
    1:         verBordersVis[cellIndex.x-1] = PR_TRUE;
    1:       }
    1:       if ((cellIndex.y > 0) && (childVis & TOP_VIS)) {
    1:         horBordersVis[cellIndex.y-1] = PR_TRUE;
    1:       }
    1:       // set the colors of borders that the child may affect
    1:       if (NO_COLOR == verBorderColors[cellIndex.x]) {
    1:         verBorderColors[cellIndex.x] = mChildBorderColors[childX].mRight;
    1:       }
    1:       if (NO_COLOR == horBorderColors[cellIndex.y]) {
    1:         horBorderColors[cellIndex.y] = mChildBorderColors[childX].mBottom;
    1:       }
    1:       if ((cellIndex.x > 0) && (NO_COLOR == verBorderColors[cellIndex.x-1])) {
    1:         verBorderColors[cellIndex.x-1] = mChildBorderColors[childX].mLeft;
    1:       }
    1:       if ((cellIndex.y > 0) && (NO_COLOR == horBorderColors[cellIndex.y-1])) {
    1:         horBorderColors[cellIndex.y-1] = mChildBorderColors[childX].mTop;
    1:       }
    1:     }
    1:     lastRow  = cellIndex.y;
    1:     lastCol  = cellIndex.x;
    1:     lastSize = size;
    1:     offset.x += size.width;
    1:     child = child->GetNextSibling();
    1:   }
    1: 
    1:   if (firstTime) {
    1:     nscolor childColor;
    1:     // set the visibility, color, mouse sensitivity of borders
    1:     for (int verX = 0; verX < mNumCols-1; verX++) {
    1:       if (mVerBorders[verX]) {
    1:         mVerBorders[verX]->SetVisibility(verBordersVis[verX]);
    1:         if (mForceFrameResizability) {
    1:           mVerBorders[verX]->mVisibilityOverride = PR_TRUE;
    1:         } else {
    1:           SetBorderResize(mChildTypes, mVerBorders[verX]);
    1:         }
    1:         childColor = (NO_COLOR == verBorderColors[verX]) ? borderColor : verBorderColors[verX];
    1:         mVerBorders[verX]->SetColor(childColor);
    1:       }
    1:     }
    1:     for (int horX = 0; horX < mNumRows-1; horX++) {
    1:       if (mHorBorders[horX]) {
    1:         mHorBorders[horX]->SetVisibility(horBordersVis[horX]);
    1:         if (mForceFrameResizability) {
    1:           mHorBorders[horX]->mVisibilityOverride = PR_TRUE;
    1:         } else {
    1:           SetBorderResize(mChildTypes, mHorBorders[horX]);
    1:         }
    1:         childColor = (NO_COLOR == horBorderColors[horX]) ? borderColor : horBorderColors[horX]; 
    1:         mHorBorders[horX]->SetColor(childColor);
    1:       }
    1:     }
    1: 
    1:     delete[] mChildTypes; 
    1:     delete[] mChildFrameborder;
    1:     delete[] mChildBorderColors;
    1: 
    1:     mChildTypes = nsnull;
    1:     mChildFrameborder = nsnull;
    1:     mChildBorderColors = nsnull;
    1:   }
    1: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   mDrag.UnSet();
    1: 
 2854:   aDesiredSize.mOverflowArea = nsRect(0, 0,
 2854:                                       aDesiredSize.width, aDesiredSize.height);
 2854: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1:   return NS_OK;
    1: }
    1: 
    1: nsIAtom*
    1: nsHTMLFramesetFrame::GetType() const
    1: {
    1:   return nsGkAtoms::frameSetFrame;
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsHTMLFramesetFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Frameset"), aResult);
    1: }
    1: #endif
    1: 
    1: PRBool
    1: nsHTMLFramesetFrame::IsLeaf() const
    1: {
    1:   // We handle constructing our kids manually
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool 
    1: nsHTMLFramesetFrame::ChildIsFrameset(nsIFrame* aChild) 
    1: {
23554:   nsHTMLFramesetFrame* childFrame = do_QueryFrame(aChild);
    1:   if (childFrame) {
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: PRBool 
    1: nsHTMLFramesetFrame::CanResize(PRBool aVertical, 
    1:                                PRBool aLeft) 
    1: {
    1:   nsIFrame* child;
    1:   PRInt32 childX;
    1:   PRInt32 startX;
    1:   if (aVertical) {
    1:     startX = (aLeft) ? 0 : mNumCols-1;
    1:     for (childX = startX; childX < mNonBorderChildCount; childX += mNumCols) {
    1:       child = mFrames.FrameAt(childX);
    1:       if (!CanChildResize(aVertical, aLeft, childX, ChildIsFrameset(child))) {
    1:         return PR_FALSE;
    1:       }
    1:     } 
    1:   } else {
    1:     startX = (aLeft) ? 0 : (mNumRows - 1) * mNumCols;
    1:     PRInt32 endX = startX + mNumCols;
    1:     for (childX = startX; childX < endX; childX++) {
    1:       child = mFrames.FrameAt(childX);
    1:       if (!CanChildResize(aVertical, aLeft, childX, ChildIsFrameset(child))) {
    1:         return PR_FALSE;
    1:       }
    1:     }
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsHTMLFramesetFrame::GetNoResize(nsIFrame* aChildFrame) 
    1: {
    1:   nsIContent* content = aChildFrame->GetContent();
    1: 
    1:   return content && content->HasAttr(kNameSpaceID_None, nsGkAtoms::noresize);
    1: }
    1: 
    1: PRBool 
    1: nsHTMLFramesetFrame::CanChildResize(PRBool  aVertical, 
    1:                                     PRBool  aLeft, 
    1:                                     PRInt32 aChildX, 
    1:                                     PRBool  aFrameset) 
    1: {
    1:   nsIFrame* child = mFrames.FrameAt(aChildX);
    1:   if (aFrameset) {
  137:     NS_ASSERTION(ChildIsFrameset(child), "Child frame is not a frameset!");
    1:     return ((nsHTMLFramesetFrame*)child)->CanResize(aVertical, aLeft);
    1:   } else {
    1:     return !GetNoResize(child);
    1:   }
    1: }
    1: 
    1: // This calculates and sets the resizability of all border frames
    1: 
    1: void
    1: nsHTMLFramesetFrame::RecalculateBorderResize()
    1: {
    1:   if (!mContent) {
    1:     return;
    1:   }
    1: 
    1:   PRInt32 numCells = mNumRows * mNumCols; // max number of cells
    1:   nsAutoArrayPtr<PRInt32> childTypes(new PRInt32[numCells]);
    1:   if (NS_UNLIKELY(!childTypes)) {
    1:     return;
    1:   }
  137:   PRUint32 childIndex, childTypeIndex = 0;
    1: 
    1:   // number of any type of children
    1:   PRUint32 numChildren = mContent->GetChildCount();
    1:   for (childIndex = 0; childIndex < numChildren; childIndex++) {
    1:     nsIContent *child = mContent->GetChildAt(childIndex);
    1: 
33329:     if (child->IsHTML()) {
    1:       nsINodeInfo *ni = child->NodeInfo();
    1: 
    1:       if (ni->Equals(nsGkAtoms::frameset)) {
  137:         childTypes[childTypeIndex++] = FRAMESET;
    1:       } else if (ni->Equals(nsGkAtoms::frame)) {
  137:         childTypes[childTypeIndex++] = FRAME;
    1:       }
    1:       // Don't overflow childTypes array
  137:       if (((PRInt32)childTypeIndex) >= numCells) {
    1:         break;
    1:       }
    1:     }
    1:   }
  137:   for (; childTypeIndex < numCells; ++childTypeIndex) {
  137:     childTypes[childTypeIndex] = BLANK;
  137:   }
    1: 
    1:   // set the visibility and mouse sensitivity of borders
    1:   PRInt32 verX;
    1:   for (verX = 0; verX < mNumCols-1; verX++) {
    1:     if (mVerBorders[verX]) {
    1:       mVerBorders[verX]->mCanResize = PR_TRUE;
    1:       if (mForceFrameResizability) {
    1:         mVerBorders[verX]->mVisibilityOverride = PR_TRUE;
    1:       } else {
    1:         mVerBorders[verX]->mVisibilityOverride = PR_FALSE;
    1:         SetBorderResize(childTypes, mVerBorders[verX]);
    1:       }
    1:     }
    1:   }
    1:   PRInt32 horX;
    1:   for (horX = 0; horX < mNumRows-1; horX++) {
    1:     if (mHorBorders[horX]) {
    1:       mHorBorders[horX]->mCanResize = PR_TRUE;
    1:       if (mForceFrameResizability) {
    1:         mHorBorders[horX]->mVisibilityOverride = PR_TRUE;
    1:       } else {
    1:         mHorBorders[horX]->mVisibilityOverride = PR_FALSE;
    1:         SetBorderResize(childTypes, mHorBorders[horX]);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void 
    1: nsHTMLFramesetFrame::SetBorderResize(PRInt32*                   aChildTypes, 
    1:                                      nsHTMLFramesetBorderFrame* aBorderFrame)
    1: {
    1:   if (aBorderFrame->mVertical) {
    1:     for (int rowX = 0; rowX < mNumRows; rowX++) {
    1:       PRInt32 childX = aBorderFrame->mPrevNeighbor + (rowX * mNumCols);
    1:       if (!CanChildResize(PR_TRUE, PR_FALSE, childX, (FRAMESET == aChildTypes[childX])) ||
    1:           !CanChildResize(PR_TRUE, PR_TRUE, childX+1,(FRAMESET == aChildTypes[childX+1]))) {
    1:         aBorderFrame->mCanResize = PR_FALSE;
    1:       }
    1:     }
    1:   } else {
    1:     PRInt32 childX = aBorderFrame->mPrevNeighbor * mNumCols;
    1:     PRInt32 endX   = childX + mNumCols;
    1:     for (; childX < endX; childX++) {
    1:       if (!CanChildResize(PR_FALSE, PR_FALSE, childX, (FRAMESET == aChildTypes[childX]))) {
    1:         aBorderFrame->mCanResize = PR_FALSE;
    1:       }
    1:     }
    1:     endX = endX + mNumCols;
    1:     for (; childX < endX; childX++) {
    1:       if (!CanChildResize(PR_FALSE, PR_TRUE, childX, (FRAMESET == aChildTypes[childX]))) {
    1:         aBorderFrame->mCanResize = PR_FALSE;
    1:       }
    1:     }
    1:   }
    1: }
    1:   
    1: void
    1: nsHTMLFramesetFrame::StartMouseDrag(nsPresContext*            aPresContext, 
    1:                                     nsHTMLFramesetBorderFrame* aBorder, 
    1:                                     nsGUIEvent*                aEvent)
    1: {
    1: #if 0
    1:   PRInt32 index;
    1:   IndexOf(aBorder, index);
    1:   NS_ASSERTION((nsnull != aBorder) && (index >= 0), "invalid dragger");
    1: #endif
32435: 
32435:   nsIPresShell::SetCapturingContent(GetContent(), CAPTURE_IGNOREALLOWED);
32435: 
    1:   mDragger = aBorder;
    1: 
    1:   mFirstDragPoint = aEvent->refPoint;
    1: 
    1:   // Store the original frame sizes
    1:   if (mDragger->mVertical) {
    1:     mPrevNeighborOrigSize = mColSizes[mDragger->mPrevNeighbor];
    1:     mNextNeighborOrigSize = mColSizes[mDragger->mNextNeighbor];
    1:   } else {
    1:     mPrevNeighborOrigSize = mRowSizes[mDragger->mPrevNeighbor];
    1:     mNextNeighborOrigSize = mRowSizes[mDragger->mNextNeighbor];
    1:   }
    1: 
    1:   gDragInProgress = PR_TRUE;
    1: }
    1:   
    1: 
    1: void
    1: nsHTMLFramesetFrame::MouseDrag(nsPresContext* aPresContext, 
    1:                                nsGUIEvent*     aEvent)
    1: {
33240:   // if the capture ended, reset the drag state
33240:   if (nsIPresShell::GetCapturingContent() != GetContent()) {
33240:     mDragger = nsnull;
33240:     gDragInProgress = PR_FALSE;
33240:     return;
33240:   }
33240: 
    1:   PRInt32 change; // measured positive from left-to-right or top-to-bottom
    1:   nsWeakFrame weakFrame(this);
    1:   if (mDragger->mVertical) {
    1:     change = aPresContext->DevPixelsToAppUnits(aEvent->refPoint.x - mFirstDragPoint.x);
    1:     if (change > mNextNeighborOrigSize - mMinDrag) {
    1:       change = mNextNeighborOrigSize - mMinDrag;
    1:     } else if (change <= mMinDrag - mPrevNeighborOrigSize) {
    1:       change = mMinDrag - mPrevNeighborOrigSize;
    1:     }
    1:     mColSizes[mDragger->mPrevNeighbor] = mPrevNeighborOrigSize + change;
    1:     mColSizes[mDragger->mNextNeighbor] = mNextNeighborOrigSize - change;
    1: 
    1:     if (change != 0) {
    1:       // Recompute the specs from the new sizes.
    1:       nscoord width = mRect.width - (mNumCols - 1) * GetBorderWidth(aPresContext, PR_TRUE);
    1:       nsCOMPtr<nsIFrameSetElement> ourContent(do_QueryInterface(mContent));
    1:       NS_ASSERTION(ourContent, "Someone gave us a broken frameset element!");
    1:       const nsFramesetSpec* colSpecs = nsnull;
    1:       ourContent->GetColSpec(&mNumCols, &colSpecs);
    1:       nsAutoString newColAttr;
    1:       GenerateRowCol(aPresContext, width, mNumCols, colSpecs, mColSizes,
    1:                      newColAttr);
    1:       // Setting the attr will trigger a reflow
    1:       mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::cols, newColAttr, PR_TRUE);
    1:     }
    1:   } else {
    1:     change = aPresContext->DevPixelsToAppUnits(aEvent->refPoint.y - mFirstDragPoint.y);
    1:     if (change > mNextNeighborOrigSize - mMinDrag) {
    1:       change = mNextNeighborOrigSize - mMinDrag;
    1:     } else if (change <= mMinDrag - mPrevNeighborOrigSize) {
    1:       change = mMinDrag - mPrevNeighborOrigSize;
    1:     }
    1:     mRowSizes[mDragger->mPrevNeighbor] = mPrevNeighborOrigSize + change;
    1:     mRowSizes[mDragger->mNextNeighbor] = mNextNeighborOrigSize - change;
    1: 
    1:     if (change != 0) {
    1:       // Recompute the specs from the new sizes.
    1:       nscoord height = mRect.height - (mNumRows - 1) * GetBorderWidth(aPresContext, PR_TRUE);
    1:       nsCOMPtr<nsIFrameSetElement> ourContent(do_QueryInterface(mContent));
    1:       NS_ASSERTION(ourContent, "Someone gave us a broken frameset element!");
    1:       const nsFramesetSpec* rowSpecs = nsnull;
    1:       ourContent->GetRowSpec(&mNumRows, &rowSpecs);
    1:       nsAutoString newRowAttr;
    1:       GenerateRowCol(aPresContext, height, mNumRows, rowSpecs, mRowSizes,
    1:                      newRowAttr);
    1:       // Setting the attr will trigger a reflow
    1:       mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::rows, newRowAttr, PR_TRUE);
    1:     }
    1:   }
    1: 
    1:   ENSURE_TRUE(weakFrame.IsAlive());
    1:   if (change != 0) {
    1:     mDrag.Reset(mDragger->mVertical, mDragger->mPrevNeighbor, change, this);
    1:     nsIFrame* parentFrame = GetParent();
    1:     if (!parentFrame) {
    1:       return;
    1:     }
    1: 
    1:     // Update the view immediately (make drag appear snappier)
26050:     nsIViewManager* vm = aPresContext->GetPresShell()->GetViewManager();
    1:     if (vm) {
    1:       nsIView* root;
    1:       vm->GetRootView(root);
    1:       if (root) {
    1:         vm->UpdateView(root, NS_VMREFRESH_IMMEDIATE);
    1:       }
    1:     }
    1:   }
    1: }  
    1: 
    1: void
    1: nsHTMLFramesetFrame::EndMouseDrag(nsPresContext* aPresContext)
    1: {
32435:   nsIPresShell::SetCapturingContent(nsnull, 0);
    1:   mDragger = nsnull;
    1:   gDragInProgress = PR_FALSE;
    1: }
    1: 
    1: nsIFrame*
    1: NS_NewHTMLFramesetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
23940: #ifdef DEBUG
23940:   const nsStyleDisplay* disp = aContext->GetStyleDisplay();
23940:   NS_ASSERTION(!disp->IsAbsolutelyPositioned() && !disp->IsFloating(),
23940:                "Framesets should not be positioned and should not float");
23940: #endif
23940: 
    1:   return new (aPresShell) nsHTMLFramesetFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsHTMLFramesetFrame)
32423: 
    1: /*******************************************************************************
    1:  * nsHTMLFramesetBorderFrame
    1:  ******************************************************************************/
    1: nsHTMLFramesetBorderFrame::nsHTMLFramesetBorderFrame(nsStyleContext* aContext,
    1:                                                      PRInt32 aWidth,
    1:                                                      PRBool  aVertical,
    1:                                                      PRBool  aVisibility)
    1:   : nsLeafFrame(aContext), mWidth(aWidth), mVertical(aVertical), mVisibility(aVisibility)
    1: {
    1:    mVisibilityOverride = PR_FALSE;
    1:    mCanResize    = PR_TRUE;
    1:    mColor        = NO_COLOR;
    1:    mPrevNeighbor = 0;
    1:    mNextNeighbor = 0;
    1: }
    1: 
    1: nsHTMLFramesetBorderFrame::~nsHTMLFramesetBorderFrame()
    1: {
    1:   //printf("nsHTMLFramesetBorderFrame destructor %p \n", this);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsHTMLFramesetBorderFrame)
32423: 
    1: nscoord nsHTMLFramesetBorderFrame::GetIntrinsicWidth()
    1: {
    1:   // No intrinsic width
    1:   return 0;
    1: }
    1: 
21104: nscoord nsHTMLFramesetBorderFrame::GetIntrinsicHeight()
21104: {
21104:   // No intrinsic height
21104:   return 0;
21104: }
21104: 
    1: void nsHTMLFramesetBorderFrame::SetVisibility(PRBool aVisibility)
    1: { 
    1:   mVisibility = aVisibility; 
    1: }
    1: 
    1: void nsHTMLFramesetBorderFrame::SetColor(nscolor aColor)
    1: { 
    1:   mColor = aColor;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetBorderFrame::Reflow(nsPresContext*          aPresContext,
    1:                                   nsHTMLReflowMetrics&     aDesiredSize,
    1:                                   const nsHTMLReflowState& aReflowState,
    1:                                   nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsHTMLFramesetBorderFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
    1:   // Override Reflow(), since we don't want to deal with what our
    1:   // computed values are.
    1:   SizeToAvailSize(aReflowState, aDesiredSize);
    1: 
 2854:   aDesiredSize.mOverflowArea = nsRect(0, 0,
 2854:                                       aDesiredSize.width, aDesiredSize.height);
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   return NS_OK;
    1: }
    1: 
    1: class nsDisplayFramesetBorder : public nsDisplayItem {
    1: public:
    1:   nsDisplayFramesetBorder(nsHTMLFramesetBorderFrame* aFrame)
    1:     : nsDisplayItem(aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayFramesetBorder);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayFramesetBorder() {
    1:     MOZ_COUNT_DTOR(nsDisplayFramesetBorder);
    1:   }
    1: #endif
    1: 
    1:   // REVIEW: see old GetFrameForPoint
    1:   // Receives events in its bounds
40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames) {
40570:     aOutFrames->AppendElement(mFrame);
40570:   }
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
33368:                      nsIRenderingContext* aCtx);
    1:   NS_DISPLAY_DECL_NAME("FramesetBorder")
    1: };
    1: 
    1: void nsDisplayFramesetBorder::Paint(nsDisplayListBuilder* aBuilder,
33368:                                     nsIRenderingContext* aCtx)
    1: {
 3233:   static_cast<nsHTMLFramesetBorderFrame*>(mFrame)->
    1:     PaintBorder(*aCtx, aBuilder->ToReferenceFrame(mFrame));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetBorderFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                             const nsRect&           aDirtyRect,
    1:                                             const nsDisplayListSet& aLists)
    1: {
    1:   nsDisplayItem* item = new (aBuilder) nsDisplayFramesetBorder(this);
    1:   if (!item)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   aLists.Content()->AppendToTop(item);
    1:   return NS_OK;
    1: }
    1: 
    1: void nsHTMLFramesetBorderFrame::PaintBorder(nsIRenderingContext& aRenderingContext,
    1:                                             nsPoint aPt)
    1: {
    1:   nscolor WHITE    = NS_RGB(255, 255, 255);
    1:   nscolor bgColor  = NS_RGB(200,200,200);
    1:   nscolor fgColor  = NS_RGB(0,0,0);
    1:   nscolor hltColor = NS_RGB(255,255,255);
    1:   nscolor sdwColor = NS_RGB(128,128,128);
    1: 
    1:   nsIRenderingContext::AutoPushTranslation
    1:     translate(&aRenderingContext, aPt.x, aPt.y);
    1: 
    1:   {
    1:     nsCOMPtr<nsILookAndFeel> lookAndFeel = do_GetService(kLookAndFeelCID);
    1:     if (lookAndFeel) {
    1:       lookAndFeel->GetColor(nsILookAndFeel::eColor_WidgetBackground,  bgColor);
    1:       lookAndFeel->GetColor(nsILookAndFeel::eColor_WidgetForeground,  fgColor);
    1:       lookAndFeel->GetColor(nsILookAndFeel::eColor_Widget3DShadow,    sdwColor);
    1:       lookAndFeel->GetColor(nsILookAndFeel::eColor_Widget3DHighlight, hltColor);
    1:     }
    1:   }
    1: 
    1:   nscoord widthInPixels = nsPresContext::AppUnitsToIntCSSPixels(mWidth);
    1:   nscoord pixelWidth    = nsPresContext::CSSPixelsToAppUnits(1);
    1: 
    1:   if (widthInPixels <= 0)
    1:     return;
    1: 
    1:   nscoord x0 = 0;
    1:   nscoord y0 = 0;
 2854:   nscoord x1 = (mVertical) ? 0 : mRect.width;
 2854:   nscoord y1 = (mVertical) ? mRect.height : 0;
    1: 
    1:   nscolor color = WHITE;
    1:   if (mVisibility || mVisibilityOverride) {
    1:     color = (NO_COLOR == mColor) ? bgColor : mColor;
    1:   }
    1:   aRenderingContext.SetColor(color);
    1:   // draw grey or white first
    1:   for (int i = 0; i < widthInPixels; i++) {
    1:     aRenderingContext.DrawLine (x0, y0, x1, y1);
    1:     if (mVertical) {
    1:       x0 += pixelWidth;
    1:       x1 =  x0;
    1:     } else {
    1:       y0 += pixelWidth;
    1:       y1 =  y0;
    1:     }
    1:   }
    1: 
    1:   if (!mVisibility && !mVisibilityOverride)
    1:     return;
    1: 
    1:   if (widthInPixels >= 5) {
    1:     aRenderingContext.SetColor(hltColor);
    1:     x0 = (mVertical) ? pixelWidth : 0;
    1:     y0 = (mVertical) ? 0 : pixelWidth;
    1:     x1 = (mVertical) ? x0 : mRect.width;
    1:     y1 = (mVertical) ? mRect.height : y0;
    1:     aRenderingContext.DrawLine(x0, y0, x1, y1);
    1:   }
    1: 
    1:   if (widthInPixels >= 2) {
    1:     aRenderingContext.SetColor(sdwColor);
    1:     x0 = (mVertical) ? mRect.width - (2 * pixelWidth) : 0;
    1:     y0 = (mVertical) ? 0 : mRect.height - (2 * pixelWidth);
    1:     x1 = (mVertical) ? x0 : mRect.width;
    1:     y1 = (mVertical) ? mRect.height : y0;
    1:     aRenderingContext.DrawLine(x0, y0, x1, y1);
    1:   }
    1: 
    1:   if (widthInPixels >= 1) {
    1:     aRenderingContext.SetColor(fgColor);
    1:     x0 = (mVertical) ? mRect.width - pixelWidth : 0;
    1:     y0 = (mVertical) ? 0 : mRect.height - pixelWidth;
    1:     x1 = (mVertical) ? x0 : mRect.width;
    1:     y1 = (mVertical) ? mRect.height : y0;
    1:     aRenderingContext.DrawLine(x0, y0, x1, y1);
    1:   }
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetBorderFrame::HandleEvent(nsPresContext* aPresContext, 
    1:                                        nsGUIEvent*     aEvent,
    1:                                        nsEventStatus*  aEventStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
    1:   *aEventStatus = nsEventStatus_eIgnore;
    1: 
    1:   //XXX Mouse setting logic removed.  The remaining logic should also move.
    1:   if (!mCanResize) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (aEvent->eventStructType == NS_MOUSE_EVENT &&
    1:       aEvent->message == NS_MOUSE_BUTTON_DOWN &&
 3233:       static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton) {
    1:     nsHTMLFramesetFrame* parentFrame;
    1:     nsIFrame* fptr = GetParent();
    1:     parentFrame = (nsHTMLFramesetFrame*) fptr;
    1:     parentFrame->StartMouseDrag(aPresContext, this, aEvent);
    1:     *aEventStatus = nsEventStatus_eConsumeNoDefault;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetBorderFrame::GetCursor(const nsPoint&    aPoint,
    1:                                      nsIFrame::Cursor& aCursor)
    1: {
    1:   if (!mCanResize) {
    1:     aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
    1:   } else {   
31385:     aCursor.mCursor = (mVertical) ? NS_STYLE_CURSOR_EW_RESIZE : NS_STYLE_CURSOR_NS_RESIZE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP nsHTMLFramesetBorderFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("FramesetBorder"), aResult);
    1: }
    1: #endif
    1: 
    1: /*******************************************************************************
    1:  * nsHTMLFramesetBlankFrame
    1:  ******************************************************************************/
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsHTMLFramesetBlankFrame)
32423: 
    1: nsHTMLFramesetBlankFrame::~nsHTMLFramesetBlankFrame()
    1: {
    1:   //printf("nsHTMLFramesetBlankFrame destructor %p \n", this);
    1: }
    1: 
    1: nscoord nsHTMLFramesetBlankFrame::GetIntrinsicWidth()
    1: {
    1:   // No intrinsic width
    1:   return 0;
    1: }
    1: 
21104: nscoord nsHTMLFramesetBlankFrame::GetIntrinsicHeight()
21104: {
21104:   // No intrinsic height
21104:   return 0;
21104: }
21104: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetBlankFrame::Reflow(nsPresContext*          aPresContext,
    1:                                  nsHTMLReflowMetrics&     aDesiredSize,
    1:                                  const nsHTMLReflowState& aReflowState,
    1:                                  nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsHTMLFramesetBlankFrame");
    1: 
    1:   // Override Reflow(), since we don't want to deal with what our
    1:   // computed values are.
    1:   SizeToAvailSize(aReflowState, aDesiredSize);
    1: 
 2854:   aDesiredSize.mOverflowArea = nsRect(0, 0,
 2854:                                       aDesiredSize.width, aDesiredSize.height);
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   return NS_OK;
    1: }
    1: 
    1: class nsDisplayFramesetBlank : public nsDisplayItem {
    1: public:
    1:   nsDisplayFramesetBlank(nsIFrame* aFrame) : nsDisplayItem(aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayFramesetBlank);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayFramesetBlank() {
    1:     MOZ_COUNT_DTOR(nsDisplayFramesetBlank);
    1:   }
    1: #endif
    1: 
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx);
    1:   NS_DISPLAY_DECL_NAME("FramesetBlank")
    1: };
    1: void nsDisplayFramesetBlank::Paint(nsDisplayListBuilder* aBuilder,
33368:                                    nsIRenderingContext* aCtx)
    1: {
    1:   nscolor white = NS_RGB(255,255,255);
    1:   aCtx->SetColor(white);
33368:   aCtx->FillRect(mVisibleRect);
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP nsHTMLFramesetBlankFrame::List(FILE*   out, 
    1:                                              PRInt32 aIndent) const
    1: {
    1:   for (PRInt32 i = aIndent; --i >= 0; ) fputs("  ", out);   // Indent
    1:   fprintf(out, "%p BLANK \n", (void*)this);
    1:   return nsLeafFrame::List(out, aIndent);
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFramesetBlankFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                            const nsRect&           aDirtyRect,
    1:                                            const nsDisplayListSet& aLists)
    1: {
    1:   nsDisplayItem* item = new (aBuilder) nsDisplayFramesetBlank(this);
    1:   if (!item)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   aLists.Content()->AppendToTop(item);
    1:   return NS_OK;
    1: }
