    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is The Browser Profile Migrator.
    1:  *
    1:  * The Initial Developer of the Original Code is Ben Goodger.
    1:  * Portions created by the Initial Developer are Copyright (C) 2004
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Ben Goodger <ben@bengoodger.com>
    1:  *  Asaf Romano <mozilla.mano@sent.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsBrowserProfileMigratorUtils.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsDirectoryServiceUtils.h"
    1: #include "nsDocShellCID.h"
    1: #include "nsINavBookmarksService.h"
    1: #include "nsBrowserCompsCID.h"
    1: #include "nsIBrowserHistory.h"
    1: #include "nsICookieManager2.h"
    1: #include "nsIFileProtocolHandler.h"
    1: #include "nsIFormHistory.h"
    1: #include "nsIIOService.h"
    1: #include "nsILocalFileMac.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIProfileMigrator.h"
    1: #include "nsIProtocolHandler.h"
    1: #include "nsIRDFContainer.h"
    1: #include "nsIRDFDataSource.h"
    1: #include "nsIRDFRemoteDataSource.h"
    1: #include "nsIRDFService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsSafariProfileMigrator.h"
    1: #include "nsToolkitCompsCID.h"
    1: #include "nsNetUtil.h"
 6076: #include "nsTArray.h"
    1: 
    1: #include <Carbon/Carbon.h>
    1: 
    1: #define SAFARI_PREFERENCES_FILE_NAME      NS_LITERAL_STRING("com.apple.Safari.plist")
    1: #define SAFARI_BOOKMARKS_FILE_NAME        NS_LITERAL_STRING("Bookmarks.plist")
    1: #define SAFARI_HISTORY_FILE_NAME          NS_LITERAL_STRING("History.plist")
    1: #define SAFARI_COOKIES_FILE_NAME          NS_LITERAL_STRING("Cookies.plist")
    1: #define SAFARI_COOKIE_BEHAVIOR_FILE_NAME  NS_LITERAL_STRING("com.apple.WebFoundation.plist")
    1: #define SAFARI_DATE_OFFSET                978307200
13026: #define SAFARI_HOME_PAGE_PREF             "HomePage"
    1: #define MIGRATION_BUNDLE                  "chrome://browser/locale/migration/migration.properties"
    1: 
    1: ///////////////////////////////////////////////////////////////////////////////
    1: // nsSafariProfileMigrator
    1: 
    1: NS_IMPL_ISUPPORTS1(nsSafariProfileMigrator, nsIBrowserProfileMigrator)
    1: 
    1: nsSafariProfileMigrator::nsSafariProfileMigrator()
    1: {
    1:   mObserverService = do_GetService("@mozilla.org/observer-service;1");
    1: }
    1: 
    1: nsSafariProfileMigrator::~nsSafariProfileMigrator()
    1: {
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////////
    1: // nsIBrowserProfileMigrator
    1: 
    1: NS_IMETHODIMP
    1: nsSafariProfileMigrator::Migrate(PRUint16 aItems, nsIProfileStartup* aStartup,
    1:                                  const PRUnichar* aProfile)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   PRBool replace = PR_FALSE;
    1: 
    1:   if (aStartup) {
    1:     replace = PR_TRUE;
    1:     rv = aStartup->DoStartup();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   NOTIFY_OBSERVERS(MIGRATION_STARTED, nsnull);
    1: 
    1:   COPY_DATA(CopyPreferences,  replace, nsIBrowserProfileMigrator::SETTINGS);
    1:   COPY_DATA(CopyCookies,      replace, nsIBrowserProfileMigrator::COOKIES);
    1:   COPY_DATA(CopyHistory,      replace, nsIBrowserProfileMigrator::HISTORY);
    1:   COPY_DATA(CopyBookmarks,    replace, nsIBrowserProfileMigrator::BOOKMARKS);
    1:   COPY_DATA(CopyFormData,     replace, nsIBrowserProfileMigrator::FORMDATA);
    1:   COPY_DATA(CopyOtherData,    replace, nsIBrowserProfileMigrator::OTHERDATA);
    1: 
    1:   NOTIFY_OBSERVERS(MIGRATION_ENDED, nsnull);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSafariProfileMigrator::GetMigrateData(const PRUnichar* aProfile,
    1:                                         PRBool aReplace,
    1:                                         PRUint16* aResult)
    1: {
    1:   *aResult = 0;
    1:   nsCOMPtr<nsIProperties> fileLocator(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:   nsCOMPtr<nsILocalFile> safariSettingsDir, safariCookiesDir;
    1:   fileLocator->Get(NS_MAC_USER_LIB_DIR, NS_GET_IID(nsILocalFile),
    1:                    getter_AddRefs(safariSettingsDir));
    1:   safariSettingsDir->Append(NS_LITERAL_STRING("Safari"));
    1:   fileLocator->Get(NS_MAC_USER_LIB_DIR, NS_GET_IID(nsILocalFile),
    1:                    getter_AddRefs(safariCookiesDir));
    1:   safariCookiesDir->Append(NS_LITERAL_STRING("Cookies"));
    1: 
    1:   // Safari stores most of its user settings under ~/Library/Safari/
    1:   MigrationData data[] = { { ToNewUnicode(SAFARI_HISTORY_FILE_NAME),
    1:                              nsIBrowserProfileMigrator::HISTORY,
    1:                              PR_FALSE },
    1:                            { ToNewUnicode(SAFARI_BOOKMARKS_FILE_NAME),
    1:                              nsIBrowserProfileMigrator::BOOKMARKS,
    1:                              PR_FALSE } };
    1:   // Frees file name strings allocated above.
    1:   GetMigrateDataFromArray(data, sizeof(data)/sizeof(MigrationData),
    1:                           aReplace, safariSettingsDir, aResult);
    1: 
    1:   // Safari stores Cookies under ~/Library/Cookies/Cookies.plist
    1:   MigrationData data2[] = { { ToNewUnicode(SAFARI_COOKIES_FILE_NAME),
    1:                               nsIBrowserProfileMigrator::COOKIES,
    1:                               PR_FALSE } };
    1:   GetMigrateDataFromArray(data2, sizeof(data2)/sizeof(MigrationData),
    1:                           aReplace, safariCookiesDir, aResult);
    1: 
    1:   // Safari stores Preferences under ~/Library/Preferences/
    1:   nsCOMPtr<nsILocalFile> systemPrefsDir;
    1:   fileLocator->Get(NS_OSX_USER_PREFERENCES_DIR, NS_GET_IID(nsILocalFile),
    1:                    getter_AddRefs(systemPrefsDir));
    1:   MigrationData data3[]= { { ToNewUnicode(SAFARI_PREFERENCES_FILE_NAME),
    1:                              nsIBrowserProfileMigrator::SETTINGS,
    1:                              PR_FALSE } };
    1:   GetMigrateDataFromArray(data3, sizeof(data3)/sizeof(MigrationData),
    1:                           aReplace, systemPrefsDir, aResult);
    1: 
    1:   // Don't offer to import the Safari user style sheet if the active profile
    1:   // already has a content style sheet (userContent.css)
    1:   PRBool hasContentStylesheet = PR_FALSE;
    1:   if (NS_SUCCEEDED(ProfileHasContentStyleSheet(&hasContentStylesheet)) &&
    1:       !hasContentStylesheet) {
    1:     nsCOMPtr<nsILocalFile> safariUserStylesheetFile;
    1:     if (NS_SUCCEEDED(GetSafariUserStyleSheet(getter_AddRefs(safariUserStylesheetFile))))
    1:       *aResult |= nsIBrowserProfileMigrator::OTHERDATA;
    1:   }
    1:   
    1:   // Don't offer to import that Safari form data if there isn't any
    1:   if (HasFormDataToImport())
    1:     *aResult |= nsIBrowserProfileMigrator::FORMDATA;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSafariProfileMigrator::GetSourceExists(PRBool* aResult)
    1: {
    1:   PRUint16 data;
    1:   GetMigrateData(nsnull, PR_FALSE, &data);
    1: 
    1:   *aResult = data != 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSafariProfileMigrator::GetSourceHasMultipleProfiles(PRBool* aResult)
    1: {
    1:   // Safari only has one profile per-user.
    1:   *aResult = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSafariProfileMigrator::GetSourceProfiles(nsISupportsArray** aResult)
    1: {
    1:   *aResult = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////////
    1: // nsSafariProfileMigrator
    1: 
    1: CFPropertyListRef CopyPListFromFile(nsILocalFile* aPListFile)
    1: {
    1:   PRBool exists;
    1:   aPListFile->Exists(&exists);
35211:   if (!exists)
35211:     return nsnull;
35211: 
    1:   nsCAutoString filePath;
    1:   aPListFile->GetNativePath(filePath);
    1: 
    1:   nsCOMPtr<nsILocalFileMac> macFile(do_QueryInterface(aPListFile));
    1:   CFURLRef urlRef;
    1:   macFile->GetCFURL(&urlRef);
    1: 
35211:   // It is possible for CFURLCreateDataAndPropertiesFromResource to allocate resource
35211:   // data and then return a failure so be careful to check both and clean up properly.
    1:   SInt32 errorCode;
35211:   CFDataRef resourceData = NULL;
35211:   Boolean dataSuccess = ::CFURLCreateDataAndPropertiesFromResource(kCFAllocatorDefault,
    1:                                                                    urlRef,
    1:                                                                    &resourceData,
    1:                                                                    NULL,
    1:                                                                    NULL,
    1:                                                                    &errorCode);
    1: 
35211:   CFPropertyListRef propertyList = NULL;
35211:   if (resourceData) {
35211:     if (dataSuccess) {
35211:       propertyList = ::CFPropertyListCreateFromXMLData(kCFAllocatorDefault,
    1:                                                        resourceData,
    1:                                                        kCFPropertyListImmutable,
    1:                                                        NULL);
35211:     }
    1:     ::CFRelease(resourceData);
35211:   }
35211: 
    1:   ::CFRelease(urlRef);
    1: 
35211:   return propertyList;
    1: }
    1: 
    1: CFDictionaryRef CopySafariPrefs()
    1: {
    1:   nsCOMPtr<nsIProperties> fileLocator(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:   nsCOMPtr<nsILocalFile> safariPrefsFile;
    1:   fileLocator->Get(NS_OSX_USER_PREFERENCES_DIR,
    1:                    NS_GET_IID(nsILocalFile),
    1:                    getter_AddRefs(safariPrefsFile));
    1: 
    1:   safariPrefsFile->Append(SAFARI_PREFERENCES_FILE_NAME);
    1: 
28227:   return static_cast<CFDictionaryRef>(CopyPListFromFile(safariPrefsFile));
    1: }
    1: 
    1: char*
    1: GetNullTerminatedString(CFStringRef aStringRef)
    1: {
    1:   CFIndex bufferSize = ::CFStringGetLength(aStringRef) + 1;
    1:   char* buffer = (char*)malloc(sizeof(char) * bufferSize);
    1:   if (!buffer)
    1:     return nsnull;
    1:   if (::CFStringGetCString(aStringRef, buffer, bufferSize,
    1:                            kCFStringEncodingASCII))
    1:     buffer[bufferSize-1] = '\0';
    1:   return buffer;
    1: }
    1: 
    1: void
    1: FreeNullTerminatedString(char* aString)
    1: {
    1:   free(aString);
    1:   aString = nsnull;
    1: }
    1: 
    1: PRBool
    1: GetDictionaryStringValue(CFDictionaryRef aDictionary, CFStringRef aKey,
    1:                          nsAString& aResult)
    1: {
    1:   CFStringRef value = (CFStringRef)::CFDictionaryGetValue(aDictionary, aKey);
    1:   if (value) {
 6076:     nsAutoTArray<UniChar, 1024> buffer;
    1:     CFIndex valueLength = ::CFStringGetLength(value);
 6076:     buffer.SetLength(valueLength);
    1: 
 6076:     ::CFStringGetCharacters(value, CFRangeMake(0, valueLength), buffer.Elements());
 6076:     aResult.Assign(buffer.Elements(), valueLength);
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: GetDictionaryCStringValue(CFDictionaryRef aDictionary, CFStringRef aKey,
    1:                           nsACString& aResult, CFStringEncoding aEncoding)
    1: {
    1:   CFStringRef value = (CFStringRef)::CFDictionaryGetValue(aDictionary, aKey);
    1:   if (value) {
 6076:     nsAutoTArray<char, 1024> buffer;
    1:     CFIndex valueLength = ::CFStringGetLength(value);
 6076:     buffer.SetLength(valueLength + 1);
    1: 
 6076:     if (::CFStringGetCString(value, buffer.Elements(), valueLength + 1, aEncoding)) {
 6076:       aResult = buffer.Elements();
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: GetArrayStringValue(CFArrayRef aArray, PRInt32 aIndex, nsAString& aResult)
    1: {
    1:   CFStringRef value = (CFStringRef)::CFArrayGetValueAtIndex(aArray, aIndex);
    1:   if (value) {
 6076:     nsAutoTArray<UniChar, 1024> buffer;
    1:     CFIndex valueLength = ::CFStringGetLength(value);
 6076:     buffer.SetLength(valueLength);
    1: 
 6076:     ::CFStringGetCharacters(value, CFRangeMake(0, valueLength), buffer.Elements());
 6076:     aResult.Assign(buffer.Elements(), valueLength);
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: #define _SPM(type) nsSafariProfileMigrator::type
    1: 
    1: static
    1: nsSafariProfileMigrator::PrefTransform gTransforms[] = {
31636:   { CFSTR("AlwaysShowTabBar"),            _SPM(BOOL),     "browser.tabs.autoHide",          _SPM(SetBoolInverted), PR_FALSE, { -1 } },
31636:   { CFSTR("AutoFillPasswords"),           _SPM(BOOL),     "signon.rememberSignons",         _SPM(SetBool), PR_FALSE, { -1 } },
31636:   { CFSTR("OpenNewTabsInFront"),          _SPM(BOOL),     "browser.tabs.loadInBackground",  _SPM(SetBoolInverted), PR_FALSE, { -1 } },
31636:   { CFSTR("NSDefaultOpenDir"),            _SPM(STRING),   "browser.download.dir",           _SPM(SetDownloadFolder), PR_FALSE, { -1 } },
31636:   { CFSTR("AutoOpenSafeDownloads"),       _SPM(BOOL),     nsnull,                           _SPM(SetDownloadHandlers), PR_FALSE, { -1 } },
31636:   { CFSTR("DownloadsClearingPolicy"),     _SPM(INT),      "browser.download.manager.retention", _SPM(SetDownloadRetention), PR_FALSE, { -1 } },
31636:   { CFSTR("WebKitDefaultTextEncodingName"),_SPM(STRING),  "intl.charset.default",           _SPM(SetDefaultEncoding), PR_FALSE, { -1 } },
31636:   { CFSTR("WebKitStandardFont"),          _SPM(STRING),   "font.name.serif.",               _SPM(SetFontName), PR_FALSE, { -1 } },
31636:   { CFSTR("WebKitDefaultFontSize"),       _SPM(INT),      "font.size.serif.",               _SPM(SetFontSize), PR_FALSE, { -1 } },
31636:   { CFSTR("WebKitFixedFont"),             _SPM(STRING),   "font.name.fixed.",               _SPM(SetFontName), PR_FALSE, { -1 } },
31636:   { CFSTR("WebKitDefaultFixedFontSize"),  _SPM(INT),      "font.size.fixed.",               _SPM(SetFontSize), PR_FALSE, { -1 } },
31636:   { CFSTR("WebKitMinimumFontSize"),       _SPM(INT),      "font.minimum-size.",             _SPM(SetFontSize), PR_FALSE, { -1 } },
31636:   { CFSTR("WebKitDisplayImagesKey"),      _SPM(BOOL),     "permissions.default.image",      _SPM(SetDisplayImages), PR_FALSE, { -1 } },
31636:   { CFSTR("WebKitJavaScriptEnabled"),     _SPM(BOOL),     "javascript.enabled",             _SPM(SetBool), PR_FALSE, { -1 } },
    1:   { CFSTR("WebKitJavaScriptCanOpenWindowsAutomatically"),
31636:                                           _SPM(BOOL),     "dom.disable_open_during_load",   _SPM(SetBoolInverted), PR_FALSE, { -1 } }
    1: };
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetBool(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1:   return aBranch->SetBoolPref(xform->targetPrefName, xform->boolValue);
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetBoolInverted(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1:   return aBranch->SetBoolPref(xform->targetPrefName, !xform->boolValue);
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetString(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1:   return aBranch->SetCharPref(xform->targetPrefName, xform->stringValue);
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetInt(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1:   return aBranch->SetIntPref(xform->targetPrefName, !xform->intValue);
    1: }
    1: 
    1: struct charsetEntry {
    1:   const char *webkitLabel;
    1:   size_t webkitLabelLength;
    1:   const char *mozLabel;
    1:   const char *associatedLangGroup;
    1: };
    1: 
    1: static const charsetEntry gCharsets[] = {
    1: #define CHARSET_ENTRY(charsetLabel, associatedLangGroup) \
    1:   {#charsetLabel, sizeof(#charsetLabel) - 1, #charsetLabel, #associatedLangGroup}
    1: #define CHARSET_ENTRY2(webkitLabel, mozLabel, associatedLangGroup) \
    1:   {#webkitLabel, sizeof(#webkitLabel) - 1, #mozLabel, #associatedLangGroup}
    1: 
    1:   CHARSET_ENTRY(ISO-8859-1,x-western),
    1:   CHARSET_ENTRY2(MACINTOSH,x-mac-roman,x-western),
    1:   // Since "x-unicode" in the font dialog means "Other Languages" (that is,
    1:   // languages which don't have their own script), we're picking the default
    1:   // font group - "Western".
    1:   CHARSET_ENTRY(UTF-8,x-western),
    1:   CHARSET_ENTRY2(SHIFT_JIS,Shift_JIS,ja),
    1:   CHARSET_ENTRY(ISO-2022-JP,ja),
    1:   CHARSET_ENTRY(EUC-JP,ja),
    1:   CHARSET_ENTRY2(BIG5,Big5,zh-TW),
    1:   CHARSET_ENTRY(CP950,zh-TW),
    1:   CHARSET_ENTRY(Big5-HKSCS,zh-HK),
    1:   CHARSET_ENTRY(ISO-2022-KR,ko),
    1:   // XXX: fallback to the generic Korean encoding
    1:   CHARSET_ENTRY2(X-MAC-KOREAN,ISO-2022-KR,ko),
    1:   CHARSET_ENTRY(CP949,ko),
    1:   CHARSET_ENTRY(ISO-8859-6,ar),
    1:   CHARSET_ENTRY2(WINDOWS-1256,windows-1256,ar),
    1:   CHARSET_ENTRY(ISO-8859-8,he),
    1:   CHARSET_ENTRY2(WINDOWS-1255,windows-1255,he),
    1:   CHARSET_ENTRY(ISO-8859-7,el),
    1:   CHARSET_ENTRY2(WINDOWS-1253,windows-1253,el),
    1:   CHARSET_ENTRY(ISO-8859-5,x-cyrillic),
    1:   CHARSET_ENTRY2(X-MAC-CYRILLIC,x-mac-cyrillic,x-cyrillic),
    1:   CHARSET_ENTRY(KOI8-R,x-cyrillic),
    1:   CHARSET_ENTRY2(WINDOWS-1251,windows-1251,x-cyrillic),
    1:   CHARSET_ENTRY(CP874,th),
    1:   CHARSET_ENTRY2(GB_2312-80,GB2312,zh-CN),
    1:   CHARSET_ENTRY(HZ-GB-2312,zh-CN),
    1:   CHARSET_ENTRY2(GB18030,gb18030,zh-CN),
    1:   CHARSET_ENTRY(ISO-8859-2,x-central-euro),
    1:   CHARSET_ENTRY2(X-MAC-CENTRALEURROMAN,x-mac-ce,x-central-euro),
    1:   CHARSET_ENTRY2(WINDOWS-1250,windows-1250,x-central-euro),
    1:   CHARSET_ENTRY(ISO-8859-4,x-central-euro),
    1:   CHARSET_ENTRY(ISO-8859-9,tr),
    1:   CHARSET_ENTRY2(WINDOWS-125,windows-1254,tr),
    1:   CHARSET_ENTRY2(WINDOWS-1257,windows-1257,x-baltic)
    1:   
    1: #undef CHARSET_ENTRY
    1: #undef CHARSET_ENTRY2
    1: };
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetDefaultEncoding(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1: 
    1:   nsCAutoString associatedLangGroup;
    1:   nsDependentCString encoding(xform->stringValue);
    1:   PRUint32 encodingLength = encoding.Length();
    1:   const char* encodingStr = encoding.get();
    1: 
    1:   PRInt16 charsetIndex = -1;
    1:   for (PRUint16 i = 0; (charsetIndex == -1) &&
    1:                        i < (sizeof(gCharsets) / sizeof(gCharsets[0])); ++i) {
    1:     if (gCharsets[i].webkitLabelLength == encodingLength &&
    1:         !strcmp(gCharsets[i].webkitLabel, encodingStr))
    1:       charsetIndex = (PRInt16)i;
    1:   }
    1:   if (charsetIndex == -1) // Default to "Western"
    1:     charsetIndex = 0;
    1: 
    1:   aBranch->SetCharPref(xform->targetPrefName, gCharsets[charsetIndex].mozLabel);
    1: 
    1:   // We also want to use the default encoding for picking the default language
    1:   // in the fonts preferences dialog, and its associated preferences.
    1: 
    1:   aBranch->SetCharPref("font.language.group",
    1:                        gCharsets[charsetIndex].associatedLangGroup);
    1:   aBranch->SetCharPref("migration.associatedLangGroup",
    1:                        gCharsets[charsetIndex].associatedLangGroup);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetDownloadFolder(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1: 
    1:   nsCOMPtr<nsILocalFile> downloadFolder;
    1:   nsresult rv = NS_NewNativeLocalFile(nsDependentCString(xform->stringValue),
    1:                                       PR_TRUE, getter_AddRefs(downloadFolder));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // If the Safari download folder is the desktop, set the folderList pref
    1:   // appropriately so that "Desktop" is selected in the list in our Preferences
    1:   // UI instead of just the raw path being shown.
    1:   nsCOMPtr<nsIProperties> fileLocator(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:   nsCOMPtr<nsILocalFile> desktopFolder;
    1:   fileLocator->Get(NS_OSX_USER_DESKTOP_DIR, NS_GET_IID(nsILocalFile),
    1:                    getter_AddRefs(desktopFolder));
    1: 
    1:   PRBool equals;
    1:   downloadFolder->Equals(desktopFolder, &equals);
    1:   aBranch->SetIntPref("browser.download.folderList", equals ? 0 : 2);
 4867:   aBranch->SetComplexValue("browser.download.dir",
    1:                            NS_GET_IID(nsILocalFile), downloadFolder);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetDownloadHandlers(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1:   if (!xform->boolValue) {
    1:     // If we're not set to auto-open safe downloads, we need to clear out the
    1:     // mime types list which contains default handlers.
    1: 
    1:     nsCOMPtr<nsIProperties> fileLocator(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:     nsCOMPtr<nsILocalFile> mimeRegistryFile;
    1:     fileLocator->Get(NS_APP_USER_MIMETYPES_50_FILE, NS_GET_IID(nsILocalFile),
    1:                      getter_AddRefs(mimeRegistryFile));
    1: 
    1:     nsCOMPtr<nsIIOService> ioService(do_GetService("@mozilla.org/network/io-service;1"));
    1:     nsCOMPtr<nsIProtocolHandler> ph;
    1:     ioService->GetProtocolHandler("file", getter_AddRefs(ph));
    1:     nsCOMPtr<nsIFileProtocolHandler> fph(do_QueryInterface(ph));
    1: 
    1:     nsCOMPtr<nsIRDFService> rdfService(do_GetService("@mozilla.org/rdf/rdf-service;1"));
    1:     nsCOMPtr<nsIRDFDataSource> mimeTypes;
    1: 
    1:     nsCAutoString dsURL;
    1:     fph->GetURLSpecFromFile(mimeRegistryFile, dsURL);
    1:     rdfService->GetDataSourceBlocking(dsURL.get(), getter_AddRefs(mimeTypes));
    1: 
    1:     nsCOMPtr<nsIRDFResource> overridesListResource;
    1:     rdfService->GetResource(NS_LITERAL_CSTRING("urn:mimetypes:root"),
    1:                             getter_AddRefs(overridesListResource));
    1: 
    1:     nsCOMPtr<nsIRDFContainer> overridesList(do_CreateInstance("@mozilla.org/rdf/container;1"));
    1:     overridesList->Init(mimeTypes, overridesListResource);
    1: 
    1:     nsCOMPtr<nsIRDFResource> handlerPropArc, externalApplicationArc;
    1:     rdfService->GetResource(NC_URI(handlerProp), getter_AddRefs(handlerPropArc));
    1:     rdfService->GetResource(NC_URI(externalApplication),
    1:                             getter_AddRefs(externalApplicationArc));
    1: 
    1:     PRInt32 count;
    1:     overridesList->GetCount(&count);
    1:     for (PRInt32 i = count; i >= 1; --i) {
    1:       nsCOMPtr<nsIRDFNode> currOverrideNode;
    1:       overridesList->RemoveElementAt(i, PR_FALSE, getter_AddRefs(currOverrideNode));
    1:       nsCOMPtr<nsIRDFResource> currOverride(do_QueryInterface(currOverrideNode));
    1: 
    1:       nsCOMPtr<nsIRDFNode> handlerPropNode;
    1:       mimeTypes->GetTarget(currOverride, handlerPropArc, PR_TRUE,
    1:                            getter_AddRefs(handlerPropNode));
    1:       nsCOMPtr<nsIRDFResource> handlerPropResource(do_QueryInterface(handlerPropNode));
    1: 
    1:       if (handlerPropResource) {
    1:         nsCOMPtr<nsIRDFNode> externalApplicationNode;
    1:         mimeTypes->GetTarget(handlerPropResource, externalApplicationArc,
    1:                              PR_TRUE, getter_AddRefs(externalApplicationNode));
    1:         nsCOMPtr<nsIRDFResource> externalApplicationResource(do_QueryInterface(externalApplicationNode));
    1: 
    1:         // Strip the resources down so that the datasource is completely flushed.
    1:         if (externalApplicationResource)
    1:           CleanResource(mimeTypes, externalApplicationResource);
    1: 
    1:         CleanResource(mimeTypes, handlerPropResource);
    1:       }
    1:       CleanResource(mimeTypes, currOverride);
    1:     }
    1: 
    1:     nsCOMPtr<nsIRDFRemoteDataSource> rds(do_QueryInterface(mimeTypes));
    1:     if (rds)
    1:       rds->Flush();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsSafariProfileMigrator::CleanResource(nsIRDFDataSource* aDataSource,
    1:                                        nsIRDFResource* aResource)
    1: {
    1:   nsCOMPtr<nsISimpleEnumerator> arcLabels;
    1:   aDataSource->ArcLabelsOut(aResource, getter_AddRefs(arcLabels));
    1:   if (!arcLabels)
    1:     return;
    1: 
    1:   do {
    1:     PRBool hasMore;
    1:     arcLabels->HasMoreElements(&hasMore);
    1: 
    1:     if (!hasMore)
    1:       break;
    1: 
    1:     nsCOMPtr<nsIRDFResource> currArc;
    1:     arcLabels->GetNext(getter_AddRefs(currArc));
    1: 
    1:     if (currArc) {
    1:       nsCOMPtr<nsIRDFNode> currTarget;
    1:       aDataSource->GetTarget(aResource, currArc, PR_TRUE,
    1:                              getter_AddRefs(currTarget));
    1: 
    1:       aDataSource->Unassert(aResource, currArc, currTarget);
    1:     }
    1:   }
    1:   while (1);
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetDownloadRetention(void* aTransform,
    1:                                               nsIPrefBranch* aBranch)
    1: {
    1:   // Safari stores Download Retention in the opposite order of Firefox, namely:
    1:   // Retention Mode:        Safari      Firefox
    1:   // Remove Manually        0           2
    1:   // Remove on Exit         1           1
    1:   // Remove on DL Complete  2           0
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1:   aBranch->SetIntPref(xform->targetPrefName,
    1:                       xform->intValue == 0 ? 2 : xform->intValue == 2 ? 0 : 1);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetDisplayImages(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   // Firefox has an elaborate set of Image preferences. The correlation is:
    1:   // Mode:                            Safari    Firefox
    1:   // Blocked                          FALSE     2
    1:   // Allowed                          TRUE      1
    1:   // Allowed, originating site only   --        3
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1:   aBranch->SetIntPref(xform->targetPrefName, xform->boolValue ? 1 : 2);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetFontName(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   nsCString associatedLangGroup;
    1:   nsresult rv = aBranch->GetCharPref("migration.associatedLangGroup",
    1:                                      getter_Copies(associatedLangGroup));
    1:   if (NS_FAILED(rv))
    1:     return NS_OK;
    1: 
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1:   nsCAutoString prefName(xform->targetPrefName);
    1:   prefName.Append(associatedLangGroup);
    1: 
    1:   return aBranch->SetCharPref(prefName.get(), xform->stringValue);
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::SetFontSize(void* aTransform, nsIPrefBranch* aBranch)
    1: {
    1:   nsCString associatedLangGroup;
    1:   nsresult rv = aBranch->GetCharPref("migration.associatedLangGroup",
    1:                                      getter_Copies(associatedLangGroup));
    1:   if (NS_FAILED(rv))
    1:     return NS_OK;
    1: 
    1:   PrefTransform* xform = (PrefTransform*)aTransform;
    1:   nsCAutoString prefName(xform->targetPrefName);
    1:   prefName.Append(associatedLangGroup);
    1: 
    1:   return aBranch->SetIntPref(prefName.get(), xform->intValue);
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::CopyPreferences(PRBool aReplace)
    1: {
    1:   nsCOMPtr<nsIPrefBranch> branch(do_GetService(NS_PREFSERVICE_CONTRACTID));
    1: 
    1:   CFDictionaryRef safariPrefs = CopySafariPrefs();
    1:   if (!safariPrefs)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Traverse the standard transforms
    1:   PrefTransform* transform;
    1:   PrefTransform* end = gTransforms +
    1:                        sizeof(gTransforms) / sizeof(PrefTransform);
    1: 
    1:   for (transform = gTransforms; transform < end; ++transform) {
    1:     Boolean hasValue = ::CFDictionaryContainsKey(safariPrefs, transform->keyName);
    1:     if (!hasValue)
    1:       continue;
    1: 
    1:     transform->prefHasValue = PR_FALSE;
    1:     switch (transform->type) {
    1:     case _SPM(STRING): {
    1:         CFStringRef stringValue = (CFStringRef)
    1:                                   ::CFDictionaryGetValue(safariPrefs,
    1:                                                          transform->keyName);
    1:         char* value = GetNullTerminatedString(stringValue);
    1:         if (value) {
    1:           transform->stringValue = value;
    1:           transform->prefHasValue = PR_TRUE;
    1:         }
    1:       }
    1:       break;
    1:     case _SPM(INT): {
    1:         CFNumberRef intValue = (CFNumberRef)
    1:                                ::CFDictionaryGetValue(safariPrefs,
    1:                                                       transform->keyName);
    1:         PRInt32 value = 0;
    1:         if (::CFNumberGetValue(intValue, kCFNumberSInt32Type, &value)) {
    1:           transform->intValue = value;
    1:           transform->prefHasValue = PR_TRUE;
    1:         }
    1:       }
    1:       break;
    1:     case _SPM(BOOL): {
    1:         CFBooleanRef boolValue = (CFBooleanRef)
    1:                                  ::CFDictionaryGetValue(safariPrefs,
    1:                                                         transform->keyName);
    1:         transform->boolValue = boolValue == kCFBooleanTrue;
    1:         transform->prefHasValue = PR_TRUE;
    1:       }
    1:       break;
    1:     default:
    1:       break;
    1:     }
    1: 
    1:     if (transform->prefHasValue)
    1:       transform->prefSetterFunc(transform, branch);
    1: 
    1:     if (transform->type == _SPM(STRING))
    1:       FreeNullTerminatedString(transform->stringValue);
    1:   }
    1: 
    1:   ::CFRelease(safariPrefs);
    1: 
    1:   // Safari stores the Cookie "Accept/Don't Accept/Don't Accept Foreign" cookie
    1:   // setting in a separate WebFoundation preferences PList.
    1:   nsCOMPtr<nsIProperties> fileLocator(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:   nsCOMPtr<nsILocalFile> safariWebFoundationPrefsFile;
    1:   fileLocator->Get(NS_OSX_USER_PREFERENCES_DIR, NS_GET_IID(nsILocalFile),
    1:                    getter_AddRefs(safariWebFoundationPrefsFile));
    1:   safariWebFoundationPrefsFile->Append(SAFARI_COOKIE_BEHAVIOR_FILE_NAME);
    1: 
    1:   CFDictionaryRef safariWebFoundationPrefs =
28227:     static_cast<CFDictionaryRef>(CopyPListFromFile(safariWebFoundationPrefsFile));
    1:   if (safariWebFoundationPrefs) {
    1:     // Mapping of Safari preference values to Firefox preference values:
    1:     //
    1:     // Setting                    Safari          Firefox
    1:     // Always Accept              always          0
    1:     // Accept from Originating    current page    1
    1:     // Never Accept               never           2
    1:     nsAutoString acceptCookies;
    1:     if (GetDictionaryStringValue(safariWebFoundationPrefs,
    1:                                  CFSTR("NSHTTPAcceptCookies"), acceptCookies)) {
    1:       PRInt32 cookieValue = 0;
    1:       if (acceptCookies.EqualsLiteral("never"))
    1:         cookieValue = 2;
    1:       else if (acceptCookies.EqualsLiteral("current page"))
    1:         cookieValue = 1;
    1: 
    1:       branch->SetIntPref("network.cookie.cookieBehavior", cookieValue);
    1:     }
    1: 
    1:     ::CFRelease(safariWebFoundationPrefs);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::CopyCookies(PRBool aReplace)
    1: {
    1:   nsCOMPtr<nsIProperties> fileLocator(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:   nsCOMPtr<nsILocalFile> safariCookiesFile;
    1:   fileLocator->Get(NS_MAC_USER_LIB_DIR,
    1:                    NS_GET_IID(nsILocalFile),
    1:                    getter_AddRefs(safariCookiesFile));
    1:   safariCookiesFile->Append(NS_LITERAL_STRING("Cookies"));
    1:   safariCookiesFile->Append(SAFARI_COOKIES_FILE_NAME);
    1: 
    1:   CFArrayRef safariCookies = (CFArrayRef)CopyPListFromFile(safariCookiesFile);
    1:   if (!safariCookies)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsICookieManager2> cookieManager(do_GetService(NS_COOKIEMANAGER_CONTRACTID));
    1:   CFIndex count = ::CFArrayGetCount(safariCookies);
    1:   for (PRInt32 i = 0; i < count; ++i) {
    1:     CFDictionaryRef entry = (CFDictionaryRef)::CFArrayGetValueAtIndex(safariCookies, i);
    1: 
    1:     CFDateRef date = (CFDateRef)::CFDictionaryGetValue(entry, CFSTR("Expires"));
    1: 
    1:     nsCAutoString domain, path, name, value;
    1:     if (date &&
    1:         GetDictionaryCStringValue(entry, CFSTR("Domain"), domain,
    1:                                   kCFStringEncodingUTF8) &&
    1:         GetDictionaryCStringValue(entry, CFSTR("Path"), path,
    1:                                   kCFStringEncodingUTF8) &&
    1:         GetDictionaryCStringValue(entry, CFSTR("Name"), name,
    1:                                   kCFStringEncodingASCII) &&
    1:         GetDictionaryCStringValue(entry, CFSTR("Value"), value,
    1:                                   kCFStringEncodingASCII)) {
    1:       PRInt64 expiryTime;
    1:       LL_D2L(expiryTime, (double)::CFDateGetAbsoluteTime(date));
    1: 
    1:       expiryTime += SAFARI_DATE_OFFSET;
    1:       cookieManager->Add(domain, path, name, value,
 2510:                          PR_FALSE, // isSecure
 2510:                          PR_FALSE, // isHttpOnly
 2510:                          PR_FALSE, // isSession
 2510:                          expiryTime);
    1:     }
    1:   }
    1:   ::CFRelease(safariCookies);
    1: 
    1:   return NS_OK;
    1: }
    1: 
28227: NS_IMETHODIMP
28227: nsSafariProfileMigrator::RunBatched(nsISupports* aUserData)
28227: {
28227:   PRUint8 batchAction;
28227:   nsCOMPtr<nsISupportsPRUint8> strWrapper(do_QueryInterface(aUserData));
28227:   NS_ASSERTION(strWrapper, "Unable to create nsISupportsPRUint8 wrapper!");
28227:   nsresult rv = strWrapper->GetData(&batchAction);
28227:   NS_ENSURE_SUCCESS(rv, rv);
28227: 
28227:   switch (batchAction) {
28227:     case BATCH_ACTION_HISTORY:
28227:       rv = CopyHistoryBatched(PR_FALSE);
28227:       break;
28227:     case BATCH_ACTION_HISTORY_REPLACE:
28227:       rv = CopyHistoryBatched(PR_TRUE);
28227:       break;
28227:     case BATCH_ACTION_BOOKMARKS:
28227:       rv = CopyBookmarksBatched(PR_FALSE);
28227:       break;
28227:     case BATCH_ACTION_BOOKMARKS_REPLACE:
28227:       rv = CopyBookmarksBatched(PR_TRUE);
28227:       break;
28227:   }
28227:   NS_ENSURE_SUCCESS(rv, rv);
28227: 
28227:   return NS_OK;
28227: }
28227: 
    1: nsresult
    1: nsSafariProfileMigrator::CopyHistory(PRBool aReplace)
    1: {
 4639:   nsresult rv;
28227:   nsCOMPtr<nsINavHistoryService> history =
28227:     do_GetService(NS_NAVHISTORYSERVICE_CONTRACTID, &rv);
 4639:   NS_ENSURE_SUCCESS(rv, rv);
 4639: 
28227:   PRUint8 batchAction = aReplace ? BATCH_ACTION_HISTORY_REPLACE
28227:                                  : BATCH_ACTION_HISTORY;
28227:   nsCOMPtr<nsISupportsPRUint8> supports =
28227:     do_CreateInstance(NS_SUPPORTS_PRUINT8_CONTRACTID);
28227:   NS_ENSURE_TRUE(supports, NS_ERROR_OUT_OF_MEMORY);
28227:   rv = supports->SetData(batchAction);
28227:   NS_ENSURE_SUCCESS(rv, rv);
28227: 
28227:   rv = history->RunInBatchMode(this, supports);
28227:   NS_ENSURE_SUCCESS(rv, rv);
28227: 
28227:   return rv;
 4639: }
 4639:  
28227: nsresult
28227: nsSafariProfileMigrator::CopyHistoryBatched(PRBool aReplace)
 4639: {
    1:   nsCOMPtr<nsIProperties> fileLocator(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:   nsCOMPtr<nsILocalFile> safariHistoryFile;
    1:   fileLocator->Get(NS_MAC_USER_LIB_DIR, NS_GET_IID(nsILocalFile),
    1:                    getter_AddRefs(safariHistoryFile));
    1:   safariHistoryFile->Append(NS_LITERAL_STRING("Safari"));
    1:   safariHistoryFile->Append(SAFARI_HISTORY_FILE_NAME);
    1: 
28227:   CFDictionaryRef safariHistory =
28227:     static_cast<CFDictionaryRef>(CopyPListFromFile(safariHistoryFile));
    1:   if (!safariHistory)
    1:     return NS_OK;
    1: 
    1:   if (!::CFDictionaryContainsKey(safariHistory, CFSTR("WebHistoryDates"))) {
    1:     ::CFRelease(safariHistory);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBrowserHistory> history(do_GetService(NS_GLOBALHISTORY2_CONTRACTID));
    1: 
    1:   CFArrayRef children = (CFArrayRef)
    1:                 ::CFDictionaryGetValue(safariHistory, CFSTR("WebHistoryDates"));
    1:   if (children) {
    1:     CFIndex count = ::CFArrayGetCount(children);
    1:     for (PRInt32 i = 0; i < count; ++i) {
    1:       CFDictionaryRef entry = (CFDictionaryRef)::CFArrayGetValueAtIndex(children, i);
    1: 
    1:       CFStringRef lastVisitedDate = (CFStringRef)
    1:                         ::CFDictionaryGetValue(entry, CFSTR("lastVisitedDate"));
    1:       nsAutoString url, title;
    1:       if (GetDictionaryStringValue(entry, CFSTR(""), url) &&
    1:           GetDictionaryStringValue(entry, CFSTR("title"), title) &&
    1:           lastVisitedDate) {
    1: 
    1:         double lvd = ::CFStringGetDoubleValue(lastVisitedDate) + SAFARI_DATE_OFFSET;
    1:         PRTime lastVisitTime;
    1:         PRInt64 temp, million;
    1:         LL_D2L(temp, lvd);
    1:         LL_I2L(million, PR_USEC_PER_SEC);
    1:         LL_MUL(lastVisitTime, temp, million);
    1: 
    1:         nsCOMPtr<nsIURI> uri;
    1:         NS_NewURI(getter_AddRefs(uri), url);
    1:         if (uri)
    1:           history->AddPageWithDetails(uri, title.get(), lastVisitTime);
    1:       }
    1:     }
    1:   }
    1: 
    1:   ::CFRelease(safariHistory);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::CopyBookmarks(PRBool aReplace)
    1: {
28227:   nsresult rv;
28227:   nsCOMPtr<nsINavBookmarksService> bookmarks =
28227:     do_GetService(NS_NAVBOOKMARKSSERVICE_CONTRACTID, &rv);
28227:   NS_ENSURE_SUCCESS(rv, rv);
28227: 
28227:   PRUint8 batchAction = aReplace ? BATCH_ACTION_BOOKMARKS_REPLACE
28227:                                  : BATCH_ACTION_BOOKMARKS;
28227:   nsCOMPtr<nsISupportsPRUint8> supports =
28227:     do_CreateInstance(NS_SUPPORTS_PRUINT8_CONTRACTID);
28227:   NS_ENSURE_TRUE(supports, NS_ERROR_OUT_OF_MEMORY);
28227:   rv = supports->SetData(batchAction);
28227:   NS_ENSURE_SUCCESS(rv, rv);
28227: 
28227:   rv = bookmarks->RunInBatchMode(this, supports);
28227:   NS_ENSURE_SUCCESS(rv, rv);
28227: 
28227:   return NS_OK;
28227: }
28227: 
28227: nsresult
28227: nsSafariProfileMigrator::CopyBookmarksBatched(PRBool aReplace)
28227: {
    1:   // If "aReplace" is true, merge into the root level of bookmarks. Otherwise, create
 5452:   // a folder called "Imported Safari Favorites" and place all the Bookmarks there.
    1:   nsresult rv;
    1: 
28227:   nsCOMPtr<nsINavBookmarksService> bms =
28227:     do_GetService(NS_NAVBOOKMARKSSERVICE_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
28227:   PRInt64 bookmarksMenuFolderId;
28227:   rv = bms->GetBookmarksMenuFolder(&bookmarksMenuFolderId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt64 folder;
    1:   if (!aReplace) {
28227:     nsCOMPtr<nsIStringBundleService> bundleService =
28227:       do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
28227:     NS_ENSURE_SUCCESS(rv, rv);
    1:     nsCOMPtr<nsIStringBundle> bundle;
28227:     rv = bundleService->CreateBundle(MIGRATION_BUNDLE, getter_AddRefs(bundle));
28227:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsString sourceNameSafari;
28227:     rv = bundle->GetStringFromName(NS_LITERAL_STRING("sourceNameSafari").get(),
    1:                                    getter_Copies(sourceNameSafari));
28227:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     const PRUnichar* sourceNameStrings[] = { sourceNameSafari.get() };
    1:     nsString importedSafariBookmarksTitle;
28227:     rv = bundle->FormatStringFromName(NS_LITERAL_STRING("importedBookmarksFolder").get(),
    1:                                       sourceNameStrings, 1,
    1:                                       getter_Copies(importedSafariBookmarksTitle));
28227:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
28227:     rv = bms->CreateFolder(bookmarksMenuFolderId,
28227:                            NS_ConvertUTF16toUTF8(importedSafariBookmarksTitle),
10046:                            nsINavBookmarksService::DEFAULT_INDEX, &folder);
28227:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   else {
 5452:     nsCOMPtr<nsIFile> profile;
 5452:     GetProfilePath(nsnull, profile);
 5452:     rv = InitializeBookmarks(profile);
 5452:     NS_ENSURE_SUCCESS(rv, rv);
 5452:     // In replace mode we are merging at the top level.
28227:     folder = bookmarksMenuFolderId;
    1:   }
    1: 
    1:   nsCOMPtr<nsIProperties> fileLocator(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:   nsCOMPtr<nsILocalFile> safariBookmarksFile;
    1:   fileLocator->Get(NS_MAC_USER_LIB_DIR, NS_GET_IID(nsILocalFile),
    1:                    getter_AddRefs(safariBookmarksFile));
    1:   safariBookmarksFile->Append(NS_LITERAL_STRING("Safari"));
    1:   safariBookmarksFile->Append(SAFARI_BOOKMARKS_FILE_NAME);
    1: 
28227:   CFDictionaryRef safariBookmarks =
28227:     static_cast<CFDictionaryRef>(CopyPListFromFile(safariBookmarksFile));
    1:   if (!safariBookmarks)
    1:     return NS_OK;
    1: 
    1:   // The Safari Bookmarks file looks like this:
    1:   // At the top level are all the Folders, Special Folders and Proxies. Proxies
    1:   // are references to other data sources such as History, Rendezvous etc.
    1:   // We ignore these. Special folders exist for the Bookmarks Toolbar folder
    1:   // (called "BookmarksBar" and the Bookmarks Menu (called "BookmarksMenu").
    1:   // We put the contents of the "BookmarksBar" folder into our Personal Toolbar
    1:   // and merge the contents of the "BookmarksMenu" folder and the other toplevel
    1:   // non-special folders under our NC:BookmarksRoot.
    1:   if (::CFDictionaryContainsKey(safariBookmarks, CFSTR("Children")) &&
    1:       ::CFDictionaryContainsKey(safariBookmarks, CFSTR("WebBookmarkFileVersion")) ) {
    1:     CFNumberRef intValue =
    1:       (CFNumberRef)::CFDictionaryGetValue(safariBookmarks,
    1:                                           CFSTR("WebBookmarkFileVersion"));
    1:     PRInt32 value = 0;
    1:     if (::CFNumberGetValue(intValue, kCFNumberSInt32Type, &value) && value ==1) {
    1:       CFArrayRef children =
    1:         (CFArrayRef)::CFDictionaryGetValue(safariBookmarks, CFSTR("Children"));
 1639:       if (children) {
    1:         rv = ParseBookmarksFolder(children, folder, bms, PR_TRUE);
 1639:       }
    1:     }
    1:   }
    1:   ::CFRelease(safariBookmarks);
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::ParseBookmarksFolder(CFArrayRef aChildren,
    1:                                               PRInt64 aParentFolder,
    1:                                               nsINavBookmarksService * aBookmarksService,
    1:                                               PRBool aIsAtRootLevel)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   CFIndex count = ::CFArrayGetCount(aChildren);
    1:   for (PRInt32 i = 0; i < count; ++i) {
    1:     CFDictionaryRef entry = (CFDictionaryRef)::CFArrayGetValueAtIndex(aChildren, i);
    1: 
    1:     nsAutoString type;
    1:     if (!GetDictionaryStringValue(entry, CFSTR("WebBookmarkType"), type))
    1:       continue;
    1: 
    1:     if (!type.EqualsLiteral("WebBookmarkTypeList") &&
    1:         !type.EqualsLiteral("WebBookmarkTypeLeaf"))
    1:       continue;
    1: 
    1:     if (::CFDictionaryContainsKey(entry, CFSTR("Children")) &&
    1:         type.EqualsLiteral("WebBookmarkTypeList")) {
15661:       nsAutoString title;
15661:       if (!GetDictionaryStringValue(entry, CFSTR("Title"), title))
    1:         continue;
    1: 
    1:       CFArrayRef children = (CFArrayRef)::CFDictionaryGetValue(entry,
    1:                                                                CFSTR("Children"));
    1: 
    1:       // Look for the BookmarksBar Bookmarks and add them into the appropriate
    1:       // Personal Toolbar Root
    1:       if (title.EqualsLiteral("BookmarksBar") && aIsAtRootLevel) {
    1:         PRInt64 toolbarFolder;
    1:         aBookmarksService->GetToolbarFolder(&toolbarFolder);
    1: 
    1:         rv |= ParseBookmarksFolder(children,
    1:                                    toolbarFolder,
    1:                                    aBookmarksService,
    1:                                    PR_FALSE);
    1:       }
    1:       // Look for the BookmarksMenu Bookmarks and flatten them into the top level
    1:       else if (title.EqualsLiteral("BookmarksMenu") && aIsAtRootLevel) {
    1:         rv |= ParseBookmarksFolder(children,
    1:                                    aParentFolder,
    1:                                    aBookmarksService,
    1:                                    PR_TRUE);
    1:       }
    1:       else {
    1:         // Encountered a Folder, so create one in our Bookmarks DataSource and then
    1:         // parse the contents of the Safari one into it...
    1:         PRInt64 folder;
15661:         rv |= aBookmarksService->CreateFolder(aParentFolder, NS_ConvertUTF16toUTF8(title),
    1:                                               nsINavBookmarksService::DEFAULT_INDEX,
    1:                                               &folder);
    1:         rv |= ParseBookmarksFolder(children,
    1:                                    folder,
    1:                                    aBookmarksService,
    1:                                    PR_FALSE);
    1:       }
    1:     }
    1:     else if (type.EqualsLiteral("WebBookmarkTypeLeaf")) {
    1:       // Encountered a Bookmark, so add it to the current folder...
    1:       CFDictionaryRef URIDictionary = (CFDictionaryRef)
    1:                       ::CFDictionaryGetValue(entry, CFSTR("URIDictionary"));
13680:       nsAutoString title;
13680:       nsCAutoString url;
13680:       if (GetDictionaryStringValue(URIDictionary, CFSTR("title"), title) &&
10046:           GetDictionaryCStringValue(entry, CFSTR("URLString"), url, kCFStringEncodingUTF8)) {
    1:         nsCOMPtr<nsIURI> uri;
29123:         rv = NS_NewURI(getter_AddRefs(uri), url);
29123:         if (NS_SUCCEEDED(rv)) {
    1:           PRInt64 id;
29123:           rv = aBookmarksService->InsertBookmark(aParentFolder, uri,
 1738:                                                  nsINavBookmarksService::DEFAULT_INDEX,
13680:                                                  NS_ConvertUTF16toUTF8(title), &id);
    1:         }
    1:       }
    1:     }
29123:   }
    1:   return rv;
    1: }
    1: 
    1: // nsSafariProfileMigrator::HasFormDataToImport()
    1: // if we add support for "~/Library/Safari/Form Values",
    1: // keep in sync with CopyFormData()
    1: // see bug #344284
    1: PRBool
    1: nsSafariProfileMigrator::HasFormDataToImport()
    1: {
    1:   PRBool hasFormData = PR_FALSE;
    1: 
    1:   // Safari stores this data in an array under the "RecentSearchStrings" key
    1:   // in its Preferences file.
    1:   CFDictionaryRef safariPrefs = CopySafariPrefs();
    1:   if (safariPrefs) {
    1:     if (::CFDictionaryContainsKey(safariPrefs, CFSTR("RecentSearchStrings")))
    1:       hasFormData = PR_TRUE;
    1:     ::CFRelease(safariPrefs);
    1:   }
    1:   return hasFormData;
    1: }
    1: 
    1: // nsSafariProfileMigrator::CopyFormData()
    1: // if we add support for "~/Library/Safari/Form Values",
    1: // keep in sync with HasFormDataToImport()
    1: // see bug #344284
    1: nsresult
    1: nsSafariProfileMigrator::CopyFormData(PRBool aReplace)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   CFDictionaryRef safariPrefs = CopySafariPrefs();
    1:   if (safariPrefs) {
    1:     // We lump saved Searches in with Form Data since that's how we store it.
    1:     // Safari stores this data in an array under the "RecentSearchStrings" key
    1:     // in its Preferences file.
    1:     Boolean hasSearchStrings = ::CFDictionaryContainsKey(safariPrefs,
    1:                                                          CFSTR("RecentSearchStrings"));
    1:     if (hasSearchStrings) {
    1:       nsCOMPtr<nsIFormHistory2> formHistory(do_GetService("@mozilla.org/satchel/form-history;1"));
    1:       if (formHistory) {
    1:         CFArrayRef strings = (CFArrayRef)::CFDictionaryGetValue(safariPrefs,
    1:                                                                 CFSTR("RecentSearchStrings"));
    1:         if (strings) {
    1:           CFIndex count = ::CFArrayGetCount(strings);
    1:           for (PRInt32 i = 0; i < count; ++i) {
    1:             nsAutoString value;
    1:             GetArrayStringValue(strings, i, value);
    1:             formHistory->AddEntry(NS_LITERAL_STRING("searchbar-history"), value);
    1:           }
    1:         }
    1:         rv = NS_OK;
    1:       }
    1:     }
    1:     else
    1:       rv = NS_OK;
    1: 
    1:     ::CFRelease(safariPrefs);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // Returns whether or not the active profile has a content style sheet
    1: // (That is chrome/userContent.css)
    1: nsresult
    1: nsSafariProfileMigrator::ProfileHasContentStyleSheet(PRBool *outExists)
    1: {
    1:   NS_ENSURE_ARG(outExists);
    1: 
    1:   // Get the profile's chrome/ directory native path
    1:   nsCOMPtr<nsIFile> userChromeDir;
    1:   nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_CHROME_DIR,
    1:                                       getter_AddRefs(userChromeDir));
    1:   nsCAutoString userChromeDirPath;
    1:   rv = userChromeDir->GetNativePath(userChromeDirPath);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCAutoString path(userChromeDirPath);
    1:   path.Append("/userContent.css");
    1: 
    1:   nsCOMPtr<nsILocalFile> file;
    1:   rv = NS_NewNativeLocalFile(path, PR_FALSE,
    1:                             getter_AddRefs(file));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   file->Exists(outExists);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::GetSafariUserStyleSheet(nsILocalFile** aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
    1:   CFDictionaryRef safariPrefs = CopySafariPrefs();
    1:   if (!safariPrefs)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   // Check whether or not a user style sheet has been specified
    1:   if (::CFDictionaryContainsKey
    1:         (safariPrefs, CFSTR("WebKitUserStyleSheetEnabledPreferenceKey")) &&
    1:       ::CFDictionaryContainsKey
    1:         (safariPrefs, CFSTR("WebKitUserStyleSheetLocationPreferenceKey"))) {
    1:     CFBooleanRef hasSheet = (CFBooleanRef)::CFDictionaryGetValue(safariPrefs,
    1:                              CFSTR("WebKitUserStyleSheetEnabledPreferenceKey"));
    1:     if (hasSheet == kCFBooleanTrue) {
    1:       nsAutoString path;
    1:       // Get its path
    1:       if (GetDictionaryStringValue(safariPrefs,
    1:                                    CFSTR("WebKitUserStyleSheetLocation" \
    1:                                    "PreferenceKey"), path)) {
    1:         nsCOMPtr<nsILocalFile> file;
    1:         rv = NS_NewLocalFile(path, PR_FALSE, getter_AddRefs(file));
    1:         if (NS_SUCCEEDED(rv)) {
    1:           PRBool exists = PR_FALSE;
    1:           file->Exists(&exists);
    1:           if (exists) {
    1:             NS_ADDREF(*aResult = file);
    1:             rv = NS_OK;
    1:           }
    1:           else
    1:             rv = NS_ERROR_FILE_NOT_FOUND;
    1:         }
    1:       }
    1:     }
    1:   }
    1:   ::CFRelease(safariPrefs);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsSafariProfileMigrator::CopyOtherData(PRBool aReplace)
    1: {
    1:   // Get the Safari user style sheet and copy it into the active profile's
    1:   // chrome folder
    1:   nsCOMPtr<nsILocalFile> stylesheetFile;
    1:   if (NS_SUCCEEDED(GetSafariUserStyleSheet(getter_AddRefs(stylesheetFile)))) {
    1:     nsCOMPtr<nsIFile> userChromeDir;
    1:     NS_GetSpecialDirectory(NS_APP_USER_CHROME_DIR,
    1:                            getter_AddRefs(userChromeDir));
    1: 
    1:     stylesheetFile->CopyTo(userChromeDir, NS_LITERAL_STRING("userContent.css"));
    1:   }
    1:   return NS_OK;
    1: }
13026: 
13026: 
13026: NS_IMETHODIMP
13026: nsSafariProfileMigrator::GetSourceHomePageURL(nsACString& aResult)
13026: {
13026:   aResult.Truncate();
13026: 
13026:   // Let's first check if there's a home page key in the com.apple.safari file...
13026:   CFDictionaryRef safariPrefs = CopySafariPrefs();
35211:   if (safariPrefs) {
32854:     PRBool foundPref = GetDictionaryCStringValue(safariPrefs,
13026:                                                  CFSTR(SAFARI_HOME_PAGE_PREF),
32854:                                                  aResult, kCFStringEncodingUTF8);
13026:     ::CFRelease(safariPrefs);
32854:     if (foundPref)
13026:       return NS_OK;
35211:   }
13026: 
32854: #ifdef __LP64__
32854:   return NS_ERROR_FAILURE;
32854: #else
13026:   // Couldn't find the home page in com.apple.safai, time to check
13026:   // com.apple.internetconfig for this key!
13026:   ICInstance internetConfig;
13026:   OSStatus error = ::ICStart(&internetConfig, 'FRFX');
13026:   if (error != noErr)
13026:     return NS_ERROR_FAILURE;
13026: 
13026:   ICAttr dummy;
13026:   Str255 homePagePValue;
13026:   long prefSize = sizeof(homePagePValue);
13026:   error = ::ICGetPref(internetConfig, kICWWWHomePage, &dummy,
13026:                       homePagePValue, &prefSize);
13026:   if (error != noErr)
13026:     return NS_ERROR_FAILURE;
13026: 
13026:   char homePageValue[256] = "";
13026:   CopyPascalStringToC((ConstStr255Param)homePagePValue, homePageValue);
13026:   aResult.Assign(homePageValue);
13026:   ::ICStop(internetConfig);
13026: 
13026:   return NS_OK;
32854: #endif
13026: }
