 69028: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 71663: /* vim: set ts=2 et sw=2 tw=80: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 99648: #include "AccessibleWrap.h"
 41384: 
 95586: #include "Accessible-inl.h"
 96920: #include "ApplicationAccessibleWrap.h"
 93543: #include "InterfaceInitFuncs.h"
 41384: #include "nsAccUtils.h"
 75194: #include "nsIAccessibleRelation.h"
111345: #include "nsIAccessibleTable.h"
 97643: #include "RootAccessible.h"
  2518: #include "nsIAccessibleValue.h"
 93543: #include "nsMai.h"
 93543: #include "nsMaiHyperlink.h"
     1: #include "nsString.h"
  2063: #include "nsAutoPtr.h"
     1: #include "prprf.h"
     1: #include "nsStateMap.h"
 75194: #include "Relation.h"
 97643: #include "RootAccessible.h"
 67790: #include "States.h"
     1: 
 95586: #include "mozilla/Util.h"
     1: #include "nsXPCOMStrings.h"
     1: #include "nsComponentManagerUtils.h"
     1: 
 80467: using namespace mozilla;
 74618: using namespace mozilla::a11y;
 74618: 
 99648: AccessibleWrap::EAvailableAtkSignals AccessibleWrap::gAvailableAtkSignals =
 73001:   eUnknown;
 73001: 
 96920: //defined in ApplicationAccessibleWrap.cpp
 31732: extern "C" GType g_atk_hyperlink_impl_type;
     1: 
     1: /* MaiAtkObject */
     1: 
     1: enum {
     1:   ACTIVATE,
     1:   CREATE,
     1:   DEACTIVATE,
     1:   DESTROY,
     1:   MAXIMIZE,
     1:   MINIMIZE,
     1:   RESIZE,
     1:   RESTORE,
     1:   LAST_SIGNAL
     1: };
     1: 
     1: enum MaiInterfaceType {
     1:     MAI_INTERFACE_COMPONENT, /* 0 */
     1:     MAI_INTERFACE_ACTION,
     1:     MAI_INTERFACE_VALUE,
     1:     MAI_INTERFACE_EDITABLE_TEXT,
     1:     MAI_INTERFACE_HYPERTEXT,
     1:     MAI_INTERFACE_HYPERLINK_IMPL,
     1:     MAI_INTERFACE_SELECTION,
     1:     MAI_INTERFACE_TABLE,
     1:     MAI_INTERFACE_TEXT,
     1:     MAI_INTERFACE_DOCUMENT, 
     1:     MAI_INTERFACE_IMAGE /* 10 */
     1: };
     1: 
     1: static GType GetAtkTypeForMai(MaiInterfaceType type)
     1: {
     1:   switch (type) {
     1:     case MAI_INTERFACE_COMPONENT:
     1:       return ATK_TYPE_COMPONENT;
     1:     case MAI_INTERFACE_ACTION:
     1:       return ATK_TYPE_ACTION;
     1:     case MAI_INTERFACE_VALUE:
     1:       return ATK_TYPE_VALUE;
     1:     case MAI_INTERFACE_EDITABLE_TEXT:
     1:       return ATK_TYPE_EDITABLE_TEXT;
     1:     case MAI_INTERFACE_HYPERTEXT:
     1:       return ATK_TYPE_HYPERTEXT;
     1:     case MAI_INTERFACE_HYPERLINK_IMPL:
     1:        return g_atk_hyperlink_impl_type;
     1:     case MAI_INTERFACE_SELECTION:
     1:       return ATK_TYPE_SELECTION;
     1:     case MAI_INTERFACE_TABLE:
     1:       return ATK_TYPE_TABLE;
     1:     case MAI_INTERFACE_TEXT:
     1:       return ATK_TYPE_TEXT;
     1:     case MAI_INTERFACE_DOCUMENT:
     1:       return ATK_TYPE_DOCUMENT;
     1:     case MAI_INTERFACE_IMAGE:
     1:       return ATK_TYPE_IMAGE;
     1:   }
     1:   return G_TYPE_INVALID;
     1: }
     1: 
  6066: static const char* kNonUserInputEvent = ":system";
  6066:     
     1: static const GInterfaceInfo atk_if_infos[] = {
     1:     {(GInterfaceInitFunc)componentInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr}, 
     1:     {(GInterfaceInitFunc)actionInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr},
     1:     {(GInterfaceInitFunc)valueInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr},
     1:     {(GInterfaceInitFunc)editableTextInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr},
     1:     {(GInterfaceInitFunc)hypertextInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr},
     1:     {(GInterfaceInitFunc)hyperlinkImplInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr},
     1:     {(GInterfaceInitFunc)selectionInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr},
     1:     {(GInterfaceInitFunc)tableInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr},
     1:     {(GInterfaceInitFunc)textInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr},
     1:     {(GInterfaceInitFunc)documentInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr},
     1:     {(GInterfaceInitFunc)imageInterfaceInitCB,
138800:      (GInterfaceFinalizeFunc) nullptr, nullptr}
     1: };
     1: 
     1: /**
     1:  * This MaiAtkObject is a thin wrapper, in the MAI namespace, for AtkObject
     1:  */
     1: struct MaiAtkObject
     1: {
     1:   AtkObject parent;
     1:   /*
 99648:    * The AccessibleWrap whose properties and features are exported
     1:    * via this object instance.
     1:    */
 99648:   AccessibleWrap* accWrap;
     1: };
     1: 
     1: struct MaiAtkObjectClass
     1: {
     1:     AtkObjectClass parent_class;
     1: };
     1: 
     1: static guint mai_atk_object_signals [LAST_SIGNAL] = { 0, };
     1: 
140597: static void MaybeFireNameChange(AtkObject* aAtkObj, const nsString& aNewName);
140597: 
     1: G_BEGIN_DECLS
     1: /* callbacks for MaiAtkObject */
     1: static void classInitCB(AtkObjectClass *aClass);
     1: static void initializeCB(AtkObject *aAtkObj, gpointer aData);
     1: static void finalizeCB(GObject *aObj);
     1: 
     1: /* callbacks for AtkObject virtual functions */
     1: static const gchar*        getNameCB (AtkObject *aAtkObj);
     1: /* getDescriptionCB is also used by image interface */
     1:        const gchar*        getDescriptionCB (AtkObject *aAtkObj);
     1: static AtkRole             getRoleCB(AtkObject *aAtkObj);
     1: static AtkAttributeSet*    getAttributesCB(AtkObject *aAtkObj);
     1: static AtkObject*          getParentCB(AtkObject *aAtkObj);
     1: static gint                getChildCountCB(AtkObject *aAtkObj);
     1: static AtkObject*          refChildCB(AtkObject *aAtkObj, gint aChildIndex);
     1: static gint                getIndexInParentCB(AtkObject *aAtkObj);
     1: static AtkStateSet*        refStateSetCB(AtkObject *aAtkObj);
     1: static AtkRelationSet*     refRelationSetCB(AtkObject *aAtkObj);
     1: 
     1: /* the missing atkobject virtual functions */
     1: /*
     1:   static AtkLayer            getLayerCB(AtkObject *aAtkObj);
     1:   static gint                getMdiZorderCB(AtkObject *aAtkObj);
     1:   static void                SetNameCB(AtkObject *aAtkObj,
     1:   const gchar *name);
     1:   static void                SetDescriptionCB(AtkObject *aAtkObj,
     1:   const gchar *description);
     1:   static void                SetParentCB(AtkObject *aAtkObj,
     1:   AtkObject *parent);
     1:   static void                SetRoleCB(AtkObject *aAtkObj,
     1:   AtkRole role);
     1:   static guint               ConnectPropertyChangeHandlerCB(
     1:   AtkObject  *aObj,
     1:   AtkPropertyChangeHandler *handler);
     1:   static void                RemovePropertyChangeHandlerCB(
     1:   AtkObject *aAtkObj,
     1:   guint handler_id);
     1:   static void                InitializeCB(AtkObject *aAtkObj,
     1:   gpointer data);
     1:   static void                ChildrenChangedCB(AtkObject *aAtkObj,
     1:   guint change_index,
     1:   gpointer changed_child);
     1:   static void                FocusEventCB(AtkObject *aAtkObj,
     1:   gboolean focus_in);
     1:   static void                PropertyChangeCB(AtkObject *aAtkObj,
     1:   AtkPropertyValues *values);
     1:   static void                StateChangeCB(AtkObject *aAtkObj,
     1:   const gchar *name,
     1:   gboolean state_set);
     1:   static void                VisibleDataChangedCB(AtkObject *aAtkObj);
     1: */
     1: G_END_DECLS
     1: 
108991: static GType GetMaiAtkType(uint16_t interfacesBits);
108991: static const char * GetUniqueMaiAtkTypeName(uint16_t interfacesBits);
     1: 
138800: static gpointer parent_class = nullptr;
     1: 
  1935: static GQuark quark_mai_hyperlink = 0;
  1935: 
     1: GType
     1: mai_atk_object_get_type(void)
     1: {
     1:     static GType type = 0;
     1: 
     1:     if (!type) {
     1:         static const GTypeInfo tinfo = {
     1:             sizeof(MaiAtkObjectClass),
138800:             (GBaseInitFunc)nullptr,
138800:             (GBaseFinalizeFunc)nullptr,
     1:             (GClassInitFunc)classInitCB,
138800:             (GClassFinalizeFunc)nullptr,
138800:             nullptr, /* class data */
     1:             sizeof(MaiAtkObject), /* instance size */
     1:             0, /* nb preallocs */
138800:             (GInstanceInitFunc)nullptr,
138800:             nullptr /* value table */
     1:         };
     1: 
     1:         type = g_type_register_static(ATK_TYPE_OBJECT,
     1:                                       "MaiAtkObject", &tinfo, GTypeFlags(0));
  1935:         quark_mai_hyperlink = g_quark_from_static_string("MaiHyperlink");
     1:     }
     1:     return type;
     1: }
     1: 
 99648: AccessibleWrap::
 99648:   AccessibleWrap(nsIContent* aContent, DocAccessible* aDoc) :
106838:   Accessible(aContent, aDoc), mAtkObject(nullptr)
     1: {
     1: }
     1: 
 99648: AccessibleWrap::~AccessibleWrap()
     1: {
 10519:     NS_ASSERTION(!mAtkObject, "ShutdownAtkObject() is not called");
  1935: }
     1: 
 99648: void
 99648: AccessibleWrap::ShutdownAtkObject()
  1935: {
     1:     if (mAtkObject) {
     1:         if (IS_MAI_OBJECT(mAtkObject)) {
106838:             MAI_ATK_OBJECT(mAtkObject)->accWrap = nullptr;
     1:         }
106838:         SetMaiHyperlink(nullptr);
     1:         g_object_unref(mAtkObject);
106838:         mAtkObject = nullptr;
  1935:     }
  3024: }
  3024: 
 43538: void
 99648: AccessibleWrap::Shutdown()
  3024: {
  3024:   ShutdownAtkObject();
 99648:   Accessible::Shutdown();
  1935: }
  1935: 
 99648: MaiHyperlink*
 99648: AccessibleWrap::GetMaiHyperlink(bool aCreate /* = true */)
  1935: {
  1935:     // make sure mAtkObject is created
  1935:     GetAtkObject();
  1935: 
  1935:     NS_ASSERTION(quark_mai_hyperlink, "quark_mai_hyperlink not initialized");
  1935:     NS_ASSERTION(IS_MAI_OBJECT(mAtkObject), "Invalid AtkObject");
106838:     MaiHyperlink* maiHyperlink = nullptr;
  1935:     if (quark_mai_hyperlink && IS_MAI_OBJECT(mAtkObject)) {
  1935:         maiHyperlink = (MaiHyperlink*)g_object_get_qdata(G_OBJECT(mAtkObject),
  1935:                                                          quark_mai_hyperlink);
  1935:         if (!maiHyperlink && aCreate) {
  1935:             maiHyperlink = new MaiHyperlink(this);
  1935:             SetMaiHyperlink(maiHyperlink);
  1935:         }
  1935:     }
  1935:     return maiHyperlink;
  1935: }
  1935: 
 99648: void
 99648: AccessibleWrap::SetMaiHyperlink(MaiHyperlink* aMaiHyperlink)
  1935: {
  1935:     NS_ASSERTION(quark_mai_hyperlink, "quark_mai_hyperlink not initialized");
  1935:     NS_ASSERTION(IS_MAI_OBJECT(mAtkObject), "Invalid AtkObject");
  1935:     if (quark_mai_hyperlink && IS_MAI_OBJECT(mAtkObject)) {
 80486:         MaiHyperlink* maiHyperlink = GetMaiHyperlink(false);
  1935:         if (!maiHyperlink && !aMaiHyperlink) {
  1935:             return; // Never set and we're shutting down
  1935:         }
  1935:         delete maiHyperlink;
  1935:         g_object_set_qdata(G_OBJECT(mAtkObject), quark_mai_hyperlink,
  1935:                            aMaiHyperlink);
     1:     }
     1: }
     1: 
 99648: NS_IMETHODIMP
 99648: AccessibleWrap::GetNativeInterface(void** aOutAccessible)
     1: {
106838:     *aOutAccessible = nullptr;
     1: 
  2091:     if (!mAtkObject) {
 89799:         if (IsDefunct() || !nsAccUtils::IsEmbeddedObject(this)) {
 15307:             // We don't create ATK objects for node which has been shutdown, or
 15307:             // nsIAccessible plain text leaves
     1:             return NS_ERROR_FAILURE;
     1:         }
  2091: 
     1:         GType type = GetMaiAtkType(CreateMaiInterfaces());
     1:         NS_ENSURE_TRUE(type, NS_ERROR_FAILURE);
     1:         mAtkObject =
  3233:             reinterpret_cast<AtkObject *>
138800:                             (g_object_new(type, nullptr));
     1:         NS_ENSURE_TRUE(mAtkObject, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:         atk_object_initialize(mAtkObject, this);
     1:         mAtkObject->role = ATK_ROLE_INVALID;
     1:         mAtkObject->layer = ATK_LAYER_INVALID;
     1:     }
     1: 
     1:     *aOutAccessible = mAtkObject;
     1:     return NS_OK;
     1: }
     1: 
     1: AtkObject *
 99648: AccessibleWrap::GetAtkObject(void)
     1: {
106838:     void *atkObj = nullptr;
     1:     GetNativeInterface(&atkObj);
  3233:     return static_cast<AtkObject *>(atkObj);
     1: }
     1: 
  2211: // Get AtkObject from nsIAccessible interface
  2211: /* static */
  2211: AtkObject *
 99648: AccessibleWrap::GetAtkObject(nsIAccessible* acc)
  2211: {
106838:     void *atkObjPtr = nullptr;
  2211:     acc->GetNativeInterface(&atkObjPtr);
106838:     return atkObjPtr ? ATK_OBJECT(atkObjPtr) : nullptr;    
  2211: }
  2211: 
     1: /* private */
108991: uint16_t
 99648: AccessibleWrap::CreateMaiInterfaces(void)
     1: {
108991:   uint16_t interfacesBits = 0;
     1:     
 99103:   // The Component interface is supported by all accessibles.
     1:   interfacesBits |= 1 << MAI_INTERFACE_COMPONENT;
     1: 
     1:   // Add Action interface if the action count is more than zero.
 74781:   if (ActionCount() > 0)
     1:     interfacesBits |= 1 << MAI_INTERFACE_ACTION;
     1: 
 99103:   // Text, Editabletext, and Hypertext interface.
 99901:   HyperTextAccessible* hyperText = AsHyperText();
 99103:   if (hyperText && hyperText->IsTextRole()) {
     1:     interfacesBits |= 1 << MAI_INTERFACE_TEXT;
 99103:     interfacesBits |= 1 << MAI_INTERFACE_EDITABLE_TEXT;
 99103:     if (!nsAccUtils::MustPrune(this))
 99103:       interfacesBits |= 1 << MAI_INTERFACE_HYPERTEXT;
     1:   }
     1: 
 99103:   // Value interface.
     1:   nsCOMPtr<nsIAccessibleValue> accessInterfaceValue;
     1:   QueryInterface(NS_GET_IID(nsIAccessibleValue),
     1:                  getter_AddRefs(accessInterfaceValue));
     1:   if (accessInterfaceValue) {
     1:     interfacesBits |= 1 << MAI_INTERFACE_VALUE; 
     1:   }
     1: 
 99103:   // Document interface.
 87451:   if (IsDoc())
     1:     interfacesBits |= 1 << MAI_INTERFACE_DOCUMENT;
     1: 
 99103:   if (IsImage())
     1:     interfacesBits |= 1 << MAI_INTERFACE_IMAGE;
     1: 
 99103:   // HyperLink interface.
 72484:   if (IsLink())
  4270:     interfacesBits |= 1 << MAI_INTERFACE_HYPERLINK_IMPL;
  4270: 
 20566:   if (!nsAccUtils::MustPrune(this)) {  // These interfaces require children
 99103:     // Table interface.
116036:     if (AsTable())
  4270:       interfacesBits |= 1 << MAI_INTERFACE_TABLE;
  4270:  
 99103:     // Selection interface.
 51865:     if (IsSelect()) {
  4270:       interfacesBits |= 1 << MAI_INTERFACE_SELECTION;
  4270:     }
  4270:   }
  4270: 
     1:   return interfacesBits;
     1: }
     1: 
     1: static GType
108991: GetMaiAtkType(uint16_t interfacesBits)
     1: {
     1:     GType type;
     1:     static const GTypeInfo tinfo = {
     1:         sizeof(MaiAtkObjectClass),
138800:         (GBaseInitFunc) nullptr,
138800:         (GBaseFinalizeFunc) nullptr,
138800:         (GClassInitFunc) nullptr,
138800:         (GClassFinalizeFunc) nullptr,
138800:         nullptr, /* class data */
     1:         sizeof(MaiAtkObject), /* instance size */
     1:         0, /* nb preallocs */
138800:         (GInstanceInitFunc) nullptr,
138800:         nullptr /* value table */
     1:     };
     1: 
     1:     /*
     1:      * The members we use to register GTypes are GetAtkTypeForMai
     1:      * and atk_if_infos, which are constant values to each MaiInterface
     1:      * So we can reuse the registered GType when having
     1:      * the same MaiInterface types.
     1:      */
     1:     const char *atkTypeName = GetUniqueMaiAtkTypeName(interfacesBits);
     1:     type = g_type_from_name(atkTypeName);
     1:     if (type) {
     1:         return type;
     1:     }
     1: 
     1:     /*
     1:      * gobject limits the number of types that can directly derive from any
     1:      * given object type to 4095.
     1:      */
108991:     static uint16_t typeRegCount = 0;
     1:     if (typeRegCount++ >= 4095) {
     1:         return G_TYPE_INVALID;
     1:     }
     1:     type = g_type_register_static(MAI_TYPE_ATK_OBJECT,
     1:                                   atkTypeName,
     1:                                   &tinfo, GTypeFlags(0));
     1: 
108991:     for (uint32_t index = 0; index < ArrayLength(atk_if_infos); index++) {
     1:       if (interfacesBits & (1 << index)) {
     1:         g_type_add_interface_static(type,
     1:                                     GetAtkTypeForMai((MaiInterfaceType)index),
     1:                                     &atk_if_infos[index]);
     1:       }
     1:     }
     1: 
     1:     return type;
     1: }
     1: 
     1: static const char*
108991: GetUniqueMaiAtkTypeName(uint16_t interfacesBits)
     1: {
108991: #define MAI_ATK_TYPE_NAME_LEN (30)     /* 10+sizeof(uint16_t)*8/4+1 < 30 */
     1: 
     1:     static gchar namePrefix[] = "MaiAtkType";   /* size = 10 */
     1:     static gchar name[MAI_ATK_TYPE_NAME_LEN + 1];
     1: 
     1:     PR_snprintf(name, MAI_ATK_TYPE_NAME_LEN, "%s%x", namePrefix,
     1:                 interfacesBits);
     1:     name[MAI_ATK_TYPE_NAME_LEN] = '\0';
     1: 
     1:     return name;
     1: }
     1: 
 99648: bool
 99648: AccessibleWrap::IsValidObject()
     1: {
     1:     // to ensure we are not shut down
 43504:     return !IsDefunct();
     1: }
     1: 
     1: /* static functions for ATK callbacks */
     1: void
     1: classInitCB(AtkObjectClass *aClass)
     1: {
     1:     GObjectClass *gobject_class = G_OBJECT_CLASS(aClass);
     1: 
     1:     parent_class = g_type_class_peek_parent(aClass);
     1: 
     1:     aClass->get_name = getNameCB;
     1:     aClass->get_description = getDescriptionCB;
     1:     aClass->get_parent = getParentCB;
     1:     aClass->get_n_children = getChildCountCB;
     1:     aClass->ref_child = refChildCB;
     1:     aClass->get_index_in_parent = getIndexInParentCB;
     1:     aClass->get_role = getRoleCB;
     1:     aClass->get_attributes = getAttributesCB;
     1:     aClass->ref_state_set = refStateSetCB;
     1:     aClass->ref_relation_set = refRelationSetCB;
     1: 
     1:     aClass->initialize = initializeCB;
     1: 
     1:     gobject_class->finalize = finalizeCB;
     1: 
     1:     mai_atk_object_signals [ACTIVATE] =
     1:     g_signal_new ("activate",
     1:                   MAI_TYPE_ATK_OBJECT,
     1:                   G_SIGNAL_RUN_LAST,
     1:                   0, /* default signal handler */
138800:                   nullptr, nullptr,
     1:                   g_cclosure_marshal_VOID__VOID,
     1:                   G_TYPE_NONE, 0);
     1:     mai_atk_object_signals [CREATE] =
     1:     g_signal_new ("create",
     1:                   MAI_TYPE_ATK_OBJECT,
     1:                   G_SIGNAL_RUN_LAST,
     1:                   0, /* default signal handler */
138800:                   nullptr, nullptr,
     1:                   g_cclosure_marshal_VOID__VOID,
     1:                   G_TYPE_NONE, 0);
     1:     mai_atk_object_signals [DEACTIVATE] =
     1:     g_signal_new ("deactivate",
     1:                   MAI_TYPE_ATK_OBJECT,
     1:                   G_SIGNAL_RUN_LAST,
     1:                   0, /* default signal handler */
138800:                   nullptr, nullptr,
     1:                   g_cclosure_marshal_VOID__VOID,
     1:                   G_TYPE_NONE, 0);
     1:     mai_atk_object_signals [DESTROY] =
     1:     g_signal_new ("destroy",
     1:                   MAI_TYPE_ATK_OBJECT,
     1:                   G_SIGNAL_RUN_LAST,
     1:                   0, /* default signal handler */
138800:                   nullptr, nullptr,
     1:                   g_cclosure_marshal_VOID__VOID,
     1:                   G_TYPE_NONE, 0);
     1:     mai_atk_object_signals [MAXIMIZE] =
     1:     g_signal_new ("maximize",
     1:                   MAI_TYPE_ATK_OBJECT,
     1:                   G_SIGNAL_RUN_LAST,
     1:                   0, /* default signal handler */
138800:                   nullptr, nullptr,
     1:                   g_cclosure_marshal_VOID__VOID,
     1:                   G_TYPE_NONE, 0);
     1:     mai_atk_object_signals [MINIMIZE] =
     1:     g_signal_new ("minimize",
     1:                   MAI_TYPE_ATK_OBJECT,
     1:                   G_SIGNAL_RUN_LAST,
     1:                   0, /* default signal handler */
138800:                   nullptr, nullptr,
     1:                   g_cclosure_marshal_VOID__VOID,
     1:                   G_TYPE_NONE, 0);
     1:     mai_atk_object_signals [RESIZE] =
     1:     g_signal_new ("resize",
     1:                   MAI_TYPE_ATK_OBJECT,
     1:                   G_SIGNAL_RUN_LAST,
     1:                   0, /* default signal handler */
138800:                   nullptr, nullptr,
     1:                   g_cclosure_marshal_VOID__VOID,
     1:                   G_TYPE_NONE, 0);
     1:     mai_atk_object_signals [RESTORE] =
     1:     g_signal_new ("restore",
     1:                   MAI_TYPE_ATK_OBJECT,
     1:                   G_SIGNAL_RUN_LAST,
     1:                   0, /* default signal handler */
138800:                   nullptr, nullptr,
     1:                   g_cclosure_marshal_VOID__VOID,
     1:                   G_TYPE_NONE, 0);
     1: 
     1: }
     1: 
     1: void
     1: initializeCB(AtkObject *aAtkObj, gpointer aData)
     1: {
     1:     NS_ASSERTION((IS_MAI_OBJECT(aAtkObj)), "Invalid AtkObject");
     1:     NS_ASSERTION(aData, "Invalid Data to init AtkObject");
     1:     if (!aAtkObj || !aData)
     1:         return;
     1: 
     1:     /* call parent init function */
     1:     /* AtkObjectClass has not a "initialize" function now,
     1:      * maybe it has later
     1:      */
     1: 
     1:     if (ATK_OBJECT_CLASS(parent_class)->initialize)
     1:         ATK_OBJECT_CLASS(parent_class)->initialize(aAtkObj, aData);
     1: 
     1:   /* initialize object */
     1:   MAI_ATK_OBJECT(aAtkObj)->accWrap =
 99648:     static_cast<AccessibleWrap*>(aData);
     1: }
     1: 
     1: void
     1: finalizeCB(GObject *aObj)
     1: {
     1:     if (!IS_MAI_OBJECT(aObj))
     1:         return;
106838:     NS_ASSERTION(MAI_ATK_OBJECT(aObj)->accWrap == nullptr, "AccWrap NOT null");
     1: 
     1:     // call parent finalize function
     1:     // finalize of GObjectClass will unref the accessible parent if has
     1:     if (G_OBJECT_CLASS (parent_class)->finalize)
     1:         G_OBJECT_CLASS (parent_class)->finalize(aObj);
     1: }
     1: 
     1: const gchar*
     1: getNameCB(AtkObject* aAtkObj)
     1: {
 99648:   AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
 97369:   if (!accWrap)
106838:     return nullptr;
     1: 
140597:   nsAutoString name;
140597:   accWrap->Name(name);
     1: 
140597:   // XXX Firing an event from here does not seem right
140597:   MaybeFireNameChange(aAtkObj, name);
 97369: 
     1:   return aAtkObj->name;
     1: }
     1: 
140597: static void
140597: MaybeFireNameChange(AtkObject* aAtkObj, const nsString& aNewName)
140597: {
140597:   NS_ConvertUTF16toUTF8 newNameUTF8(aNewName);
140597:   if (newNameUTF8.Equals(aAtkObj->name))
140597:     return;
140597: 
140597:   // Below we duplicate the functionality of atk_object_set_name(),
140597:   // but without calling atk_object_get_name(). Instead of
140597:   // atk_object_get_name() we directly access aAtkObj->name. This is because
140597:   // atk_object_get_name() would call getNameCB() which would call
140597:   // MaybeFireNameChange() (or atk_object_set_name() before this problem was
140597:   // fixed) and we would get an infinite recursion.
140597:   // See http://bugzilla.mozilla.org/733712
140597: 
140597:   // Do not notify for initial name setting.
140597:   // See bug http://bugzilla.gnome.org/665870
140597:   bool notify = !!aAtkObj->name;
140597: 
140597:   free(aAtkObj->name);
140597:   aAtkObj->name = strdup(newNameUTF8.get());
140597: 
140597:   if (notify)
140597:     g_object_notify(G_OBJECT(aAtkObj), "accessible-name");
140597: }
140597: 
     1: const gchar *
     1: getDescriptionCB(AtkObject *aAtkObj)
     1: {
 99648:     AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
 69342:     if (!accWrap || accWrap->IsDefunct())
106838:         return nullptr;
     1: 
140597:     /* nsIAccessible is responsible for the nonnull description */
     1:     nsAutoString uniDesc;
 69342:     accWrap->Description(uniDesc);
  2211: 
  2211:     NS_ConvertUTF8toUTF16 objDesc(aAtkObj->description);
 69342:     if (!uniDesc.Equals(objDesc))
     1:         atk_object_set_description(aAtkObj,
     1:                                    NS_ConvertUTF16toUTF8(uniDesc).get());
 69342: 
     1:     return aAtkObj->description;
     1: }
     1: 
     1: AtkRole
     1: getRoleCB(AtkObject *aAtkObj)
     1: {
 99648:   AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
 97224:   if (!accWrap)
   953:     return ATK_ROLE_INVALID;
     1: 
 97936: #ifdef DEBUG
 20566:   NS_ASSERTION(nsAccUtils::IsTextInterfaceSupportCorrect(accWrap),
 20566:       "Does not support nsIAccessibleText when it should");
     1: #endif
     1: 
 97224:   if (aAtkObj->role != ATK_ROLE_INVALID)
     1:     return aAtkObj->role;
 97224: 
106033: #define ROLE(geckoRole, stringRole, atkRole, macRole, \
106033:              msaaRole, ia2Role, nameRule) \
 97418:   case roles::geckoRole: \
 97418:     aAtkObj->role = atkRole; \
 97418:     break;
 97418: 
 97418:   switch (accWrap->Role()) {
 97418: #include "RoleMap.h"
 97418:     default:
 97418:       MOZ_NOT_REACHED("Unknown role.");
 97418:       aAtkObj->role = ATK_ROLE_UNKNOWN;
 97418:   };
 97418: 
 97418: #undef ROLE
 97418: 
 97418:   return aAtkObj->role;
     1: }
     1: 
     1: AtkAttributeSet*
 16001: ConvertToAtkAttributeSet(nsIPersistentProperties* aAttributes)
 16001: {
 16001:     if (!aAttributes)
106838:         return nullptr;
 16001: 
106838:     AtkAttributeSet *objAttributeSet = nullptr;
 16001:     nsCOMPtr<nsISimpleEnumerator> propEnum;
 16001:     nsresult rv = aAttributes->Enumerate(getter_AddRefs(propEnum));
106838:     NS_ENSURE_SUCCESS(rv, nullptr);
 16001: 
 79445:     bool hasMore;
 16001:     while (NS_SUCCEEDED(propEnum->HasMoreElements(&hasMore)) && hasMore) {
 16001:         nsCOMPtr<nsISupports> sup;
 16001:         rv = propEnum->GetNext(getter_AddRefs(sup));
 16001:         NS_ENSURE_SUCCESS(rv, objAttributeSet);
 16001: 
 16001:         nsCOMPtr<nsIPropertyElement> propElem(do_QueryInterface(sup));
 16001:         NS_ENSURE_TRUE(propElem, objAttributeSet);
 16001: 
110974:         nsAutoCString name;
 16001:         rv = propElem->GetKey(name);
 16001:         NS_ENSURE_SUCCESS(rv, objAttributeSet);
 16001: 
 16001:         nsAutoString value;
 16001:         rv = propElem->GetValue(value);
 16001:         NS_ENSURE_SUCCESS(rv, objAttributeSet);
 16001: 
 16001:         AtkAttribute *objAttr = (AtkAttribute *)g_malloc(sizeof(AtkAttribute));
 16001:         objAttr->name = g_strdup(name.get());
 16001:         objAttr->value = g_strdup(NS_ConvertUTF16toUTF8(value).get());
 16001:         objAttributeSet = g_slist_prepend(objAttributeSet, objAttr);
 16001:     }
 16001: 
 16001:     //libspi will free it
 16001:     return objAttributeSet;
 16001: }
 16001: 
 16001: AtkAttributeSet*
 99648: GetAttributeSet(Accessible* aAccessible)
     1: {
119399:   nsCOMPtr<nsIPersistentProperties> attributes = aAccessible->Attributes();
     1:   if (attributes) {
119399:     // There is no ATK state for haspopup, must use object attribute to expose
119399:     // the same info.
 67790:     if (aAccessible->State() & states::HASPOPUP) {
119399:       nsAutoString unused;
119399:       attributes->SetStringProperty(NS_LITERAL_CSTRING("haspopup"),
119399:                                     NS_LITERAL_STRING("true"), unused);
  3123:     }
  3123: 
 16001:     return ConvertToAtkAttributeSet(attributes);
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: AtkAttributeSet *
     1: getAttributesCB(AtkObject *aAtkObj)
     1: {
 99648:   AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
106838:   return accWrap ? GetAttributeSet(accWrap) : nullptr;
     1: }
     1: 
     1: AtkObject *
     1: getParentCB(AtkObject *aAtkObj)
     1: {
  2211:   if (!aAtkObj->accessible_parent) {
 99648:     AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
 74545:     if (!accWrap)
106838:       return nullptr;
     1: 
 99648:     Accessible* accParent = accWrap->Parent();
 50623:     if (!accParent)
106838:       return nullptr;
     1: 
 99648:     AtkObject* parent = AccessibleWrap::GetAtkObject(accParent);
 16034:     if (parent)
 16034:       atk_object_set_parent(aAtkObj, parent);
     1:   }
  2092:   return aAtkObj->accessible_parent;
     1: }
     1: 
     1: gint
     1: getChildCountCB(AtkObject *aAtkObj)
     1: {
 99648:     AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
 20566:     if (!accWrap || nsAccUtils::MustPrune(accWrap)) {
   953:         return 0;
   953:     }
     1: 
 99463:     return static_cast<gint>(accWrap->EmbeddedChildCount());
     1: }
     1: 
     1: AtkObject *
     1: refChildCB(AtkObject *aAtkObj, gint aChildIndex)
     1: {
     1:     // aChildIndex should not be less than zero
     1:     if (aChildIndex < 0) {
106838:       return nullptr;
     1:     }
     1: 
 99648:     AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
 20566:     if (!accWrap || nsAccUtils::MustPrune(accWrap)) {
106838:         return nullptr;
   953:     }
     1: 
 99648:     Accessible* accChild = accWrap->GetEmbeddedChildAt(aChildIndex);
  4341:     if (!accChild)
106838:         return nullptr;
     1: 
 99648:     AtkObject* childAtkObj = AccessibleWrap::GetAtkObject(accChild);
     1: 
  2211:     NS_ASSERTION(childAtkObj, "Fail to get AtkObj");
  2211:     if (!childAtkObj)
106838:         return nullptr;
 36870:     g_object_ref(childAtkObj);
  2092: 
 91132:   if (aAtkObj != childAtkObj->accessible_parent)
  2092:     atk_object_set_parent(childAtkObj, aAtkObj);
 91132: 
     1:   return childAtkObj;
     1: }
     1: 
     1: gint
     1: getIndexInParentCB(AtkObject *aAtkObj)
     1: {
     1:     // We don't use nsIAccessible::GetIndexInParent() because
     1:     // for ATK we don't want to include text leaf nodes as children
 99648:     AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
  2211:     if (!accWrap) {
   953:         return -1;
   953:     }
     1: 
 99648:     Accessible* parent = accWrap->Parent();
 74545:     if (!parent)
     1:         return -1; // No parent
     1: 
 50623:     return parent->GetIndexOfEmbeddedChild(accWrap);
     1: }
     1: 
 67790: static void
108991: TranslateStates(uint64_t aState, AtkStateSet* aStateSet)
     1: {
     1: 
     1:   // Convert every state to an entry in AtkStateMap
108991:   uint32_t stateIndex = 0;
108991:   uint64_t bitMask = 1;
 67790:   while (gAtkStateMap[stateIndex].stateMapEntryType != kNoSuchState) {
 67790:     if (gAtkStateMap[stateIndex].atkState) { // There's potentially an ATK state for this
 79445:       bool isStateOn = (aState & bitMask) != 0;
 67790:       if (gAtkStateMap[stateIndex].stateMapEntryType == kMapOpposite) {
     1:         isStateOn = !isStateOn;
     1:       }
     1:       if (isStateOn) {
 67790:         atk_state_set_add_state(aStateSet, gAtkStateMap[stateIndex].atkState);
     1:       }
     1:     }
     1:     bitMask <<= 1;
     1:     ++ stateIndex;
     1:   }
     1: }
     1: 
     1: AtkStateSet *
     1: refStateSetCB(AtkObject *aAtkObj)
     1: {
106838:     AtkStateSet *state_set = nullptr;
     1:     state_set = ATK_OBJECT_CLASS(parent_class)->ref_state_set(aAtkObj);
     1: 
 99648:     AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
  2211:     if (!accWrap) {
 67790:         TranslateStates(states::DEFUNCT, state_set);
   953:         return state_set;
   953:     }
  1360: 
     1:     // Map states
 67790:     TranslateStates(accWrap->State(), state_set);
     1: 
     1:     return state_set;
     1: }
     1: 
     1: AtkRelationSet *
     1: refRelationSetCB(AtkObject *aAtkObj)
     1: {
 75194:   AtkRelationSet* relation_set =
 75194:     ATK_OBJECT_CLASS(parent_class)->ref_relation_set(aAtkObj);
     1: 
 99648:   AccessibleWrap* accWrap = GetAccessibleWrap(aAtkObj);
 75194:   if (!accWrap)
   953:     return relation_set;
     1: 
134189:   // Keep in sync with AtkRelationType enum.
134189:   static const uint32_t relationTypes[] = {
  1628:     nsIAccessibleRelation::RELATION_CONTROLLED_BY,
  1628:     nsIAccessibleRelation::RELATION_CONTROLLER_FOR,
134189:     nsIAccessibleRelation::RELATION_LABEL_FOR,
134189:     nsIAccessibleRelation::RELATION_LABELLED_BY,
134189:     nsIAccessibleRelation::RELATION_MEMBER_OF,
134189:     nsIAccessibleRelation::RELATION_NODE_CHILD_OF,
  1628:     nsIAccessibleRelation::RELATION_FLOWS_TO,
  1628:     nsIAccessibleRelation::RELATION_FLOWS_FROM,
134189:     nsIAccessibleRelation::RELATION_SUBWINDOW_OF,
134189:     nsIAccessibleRelation::RELATION_EMBEDS,
134189:     nsIAccessibleRelation::RELATION_EMBEDDED_BY,
134189:     nsIAccessibleRelation::RELATION_POPUP_FOR,
134189:     nsIAccessibleRelation::RELATION_PARENT_WINDOW_OF,
  1628:     nsIAccessibleRelation::RELATION_DESCRIBED_BY,
  1628:     nsIAccessibleRelation::RELATION_DESCRIPTION_FOR,
134189:     nsIAccessibleRelation::RELATION_NODE_PARENT_OF
     1:   };
     1: 
108991:   for (uint32_t i = 0; i < ArrayLength(relationTypes); i++) {
134189:     // Shift to 1 to skip ATK_RELATION_NULL.
134189:     AtkRelationType atkType = static_cast<AtkRelationType>(i + 1);
 75194:     AtkRelation* atkRelation =
 75194:       atk_relation_set_get_relation_by_type(relation_set, atkType);
 75194:     if (atkRelation)
 75194:       atk_relation_set_remove(relation_set, atkRelation);
     1: 
 75194:     Relation rel(accWrap->RelationByType(relationTypes[i]));
 75194:     nsTArray<AtkObject*> targets;
106838:     Accessible* tempAcc = nullptr;
 75194:     while ((tempAcc = rel.Next()))
 99648:       targets.AppendElement(AccessibleWrap::GetAtkObject(tempAcc));
 24822: 
 76978:     if (targets.Length()) {
 75194:       atkRelation = atk_relation_new(targets.Elements(), targets.Length(), atkType);
 75194:       atk_relation_set_add(relation_set, atkRelation);
 75194:       g_object_unref(atkRelation);
     1:     }
 76978:   }
     1: 
     1:   return relation_set;
     1: }
     1: 
 99648: // Check if aAtkObj is a valid MaiAtkObject, and return the AccessibleWrap
     1: // for it.
 99648: AccessibleWrap*
 99648: GetAccessibleWrap(AtkObject* aAtkObj)
     1: {
106838:   NS_ENSURE_TRUE(IS_MAI_OBJECT(aAtkObj), nullptr);
 99648:   AccessibleWrap* accWrap = MAI_ATK_OBJECT(aAtkObj)->accWrap;
  2211: 
 96920:   // Check if the accessible was deconstructed.
 96920:   if (!accWrap)
106838:     return nullptr;
  2211: 
106838:   NS_ENSURE_TRUE(accWrap->GetAtkObject() == aAtkObj, nullptr);
 96920: 
114315:   AccessibleWrap* appAccWrap = ApplicationAcc();
 96920:   if (appAccWrap != accWrap && !accWrap->IsValidObject())
106838:     return nullptr;
 96920: 
 96920:   return accWrap;
     1: }
   552: 
 29320: nsresult
 99648: AccessibleWrap::HandleAccEvent(AccEvent* aEvent)
   552: {
 99648:   nsresult rv = Accessible::HandleAccEvent(aEvent);
   552:   NS_ENSURE_SUCCESS(rv, rv);
   552: 
 15375:   return FirePlatformEvent(aEvent);
 15375: }
 15375: 
 15375: nsresult
 99648: AccessibleWrap::FirePlatformEvent(AccEvent* aEvent)
 15375: {
 99648:     Accessible* accessible = aEvent->GetAccessible();
  2092:     NS_ENSURE_TRUE(accessible, NS_ERROR_FAILURE);
   552: 
108991:     uint32_t type = aEvent->GetEventType();
   552: 
 99648:     AtkObject* atkObj = AccessibleWrap::GetAtkObject(accessible);
  2211: 
  2191:     // We don't create ATK objects for nsIAccessible plain text leaves,
  2191:     // just return NS_OK in such case
  2191:     if (!atkObj) {
 32336:         NS_ASSERTION(type == nsIAccessibleEvent::EVENT_SHOW ||
 32336:                      type == nsIAccessibleEvent::EVENT_HIDE,
  2191:                      "Event other than SHOW and HIDE fired for plain text leaves");
  2191:         return NS_OK;
  2191:     }
  2191: 
 99648:     AccessibleWrap* accWrap = GetAccessibleWrap(atkObj);
  2629:     if (!accWrap) {
  2629:         return NS_OK; // Node is shut down
  2629:     }
  2518: 
   552:     switch (type) {
   552:     case nsIAccessibleEvent::EVENT_STATE_CHANGE:
   667:         return FireAtkStateChangeEvent(aEvent, atkObj);
   667: 
  4516:     case nsIAccessibleEvent::EVENT_TEXT_REMOVED:
  4516:     case nsIAccessibleEvent::EVENT_TEXT_INSERTED:
   667:         return FireAtkTextChangedEvent(aEvent, atkObj);
   667: 
  2518:     case nsIAccessibleEvent::EVENT_FOCUS:
  2518:       {
 97643:         a11y::RootAccessible* rootAccWrap = accWrap->RootAccessible();
  2518:         if (rootAccWrap && rootAccWrap->mActivated) {
  2518:             atk_focus_tracker_notify(atkObj);
  2746:             // Fire state change event for focus
 51377:             nsRefPtr<AccEvent> stateChangeEvent =
 80486:               new AccStateChangeEvent(accessible, states::FOCUSED, true);
  2746:             return FireAtkStateChangeEvent(stateChangeEvent, atkObj);
  2518:         }
  2518:       } break;
  2518: 
 72197:     case nsIAccessibleEvent::EVENT_NAME_CHANGE:
 72197:       {
 97369:         nsAutoString newName;
 97369:         accessible->Name(newName);
140597: 
140597:         MaybeFireNameChange(atkObj, newName);
 72197: 
 72197:         break;
 72197:       }
  2518:     case nsIAccessibleEvent::EVENT_VALUE_CHANGE:
  2518:       {
 43537:         nsCOMPtr<nsIAccessibleValue> value(do_QueryObject(accessible));
  2518:         if (value) {    // Make sure this is a numeric value
  2518:             // Don't fire for MSAA string value changes (e.g. text editing)
  2518:             // ATK values are always numeric
  2518:             g_object_notify( (GObject*)atkObj, "accessible-value" );
  2518:         }
  2518:       } break;
  2518: 
 81286:     case nsIAccessibleEvent::EVENT_SELECTION:
 81286:     case nsIAccessibleEvent::EVENT_SELECTION_ADD:
 81286:     case nsIAccessibleEvent::EVENT_SELECTION_REMOVE:
 81286:     {
 81286:       // XXX: dupe events may be fired
 81286:       AccSelChangeEvent* selChangeEvent = downcast_accEvent(aEvent);
 99648:       g_signal_emit_by_name(AccessibleWrap::GetAtkObject(selChangeEvent->Widget()),
 81286:                             "selection_changed");
 81286:       break;
 81286:     }
 81286: 
 81286:     case nsIAccessibleEvent::EVENT_SELECTION_WITHIN:
 81286:     {
  2518:       g_signal_emit_by_name(atkObj, "selection_changed");
  2518:       break;
 81286:     }
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_TEXT_SELECTION_CHANGED:
  2518:         g_signal_emit_by_name(atkObj, "text_selection_changed");
  2518:         break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_TEXT_CARET_MOVED:
  2688:       {
 51377:         AccCaretMoveEvent* caretMoveEvent = downcast_accEvent(aEvent);
  2688:         NS_ASSERTION(caretMoveEvent, "Event needs event data");
  2688:         if (!caretMoveEvent)
  2518:             break;
  2518: 
108991:         int32_t caretOffset = caretMoveEvent->GetCaretOffset();
124822:         g_signal_emit_by_name(atkObj, "text_caret_moved", caretOffset);
  2688:       } break;
  2518: 
 16001:     case nsIAccessibleEvent::EVENT_TEXT_ATTRIBUTE_CHANGED:
124822:         g_signal_emit_by_name(atkObj, "text-attributes-changed");
 16001:         break;
 16001: 
  2518:     case nsIAccessibleEvent::EVENT_TABLE_MODEL_CHANGED:
  2518:         g_signal_emit_by_name(atkObj, "model_changed");
  2518:         break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_TABLE_ROW_INSERT:
 10376:       {
 51377:         AccTableChangeEvent* tableEvent = downcast_accEvent(aEvent);
 10375:         NS_ENSURE_TRUE(tableEvent, NS_ERROR_FAILURE);
  2518: 
108991:         int32_t rowIndex = tableEvent->GetIndex();
108991:         int32_t numRows = tableEvent->GetCount();
  2518: 
124822:         g_signal_emit_by_name(atkObj, "row_inserted", rowIndex, numRows);
 10376:      } break;
  2518: 
  2518:    case nsIAccessibleEvent::EVENT_TABLE_ROW_DELETE:
 10376:      {
 51377:         AccTableChangeEvent* tableEvent = downcast_accEvent(aEvent);
 10375:         NS_ENSURE_TRUE(tableEvent, NS_ERROR_FAILURE);
  2518: 
108991:         int32_t rowIndex = tableEvent->GetIndex();
108991:         int32_t numRows = tableEvent->GetCount();
  2518: 
124822:         g_signal_emit_by_name(atkObj, "row_deleted", rowIndex, numRows);
 10376:       } break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_TABLE_ROW_REORDER:
 10376:       {
  2518:         g_signal_emit_by_name(atkObj, "row_reordered");
  2518:         break;
 10376:       }
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_TABLE_COLUMN_INSERT:
 10376:       {
 51377:         AccTableChangeEvent* tableEvent = downcast_accEvent(aEvent);
 10375:         NS_ENSURE_TRUE(tableEvent, NS_ERROR_FAILURE);
  2518: 
108991:         int32_t colIndex = tableEvent->GetIndex();
108991:         int32_t numCols = tableEvent->GetCount();
124822:         g_signal_emit_by_name(atkObj, "column_inserted", colIndex, numCols);
 10376:       } break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_TABLE_COLUMN_DELETE:
 10376:       {
 51377:         AccTableChangeEvent* tableEvent = downcast_accEvent(aEvent);
 10375:         NS_ENSURE_TRUE(tableEvent, NS_ERROR_FAILURE);
  2518: 
108991:         int32_t colIndex = tableEvent->GetIndex();
108991:         int32_t numCols = tableEvent->GetCount();
124822:         g_signal_emit_by_name(atkObj, "column_deleted", colIndex, numCols);
 10376:       } break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_TABLE_COLUMN_REORDER:
  2518:         g_signal_emit_by_name(atkObj, "column_reordered");
  2518:         break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_SECTION_CHANGED:
  2518:         g_signal_emit_by_name(atkObj, "visible_data_changed");
  2518:         break;
  2518: 
 32336:     case nsIAccessibleEvent::EVENT_SHOW:
 80486:         return FireAtkShowHideEvent(aEvent, atkObj, true);
  2518: 
 32336:     case nsIAccessibleEvent::EVENT_HIDE:
 80486:         return FireAtkShowHideEvent(aEvent, atkObj, false);
  2518: 
  2518:         /*
  2518:          * Because dealing with menu is very different between nsIAccessible
  2518:          * and ATK, and the menu activity is important, specially transfer the
  2518:          * following two event.
  2518:          * Need more verification by AT test.
  2518:          */
  2518:     case nsIAccessibleEvent::EVENT_MENU_START:
  2518:     case nsIAccessibleEvent::EVENT_MENU_END:
  2518:         break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_WINDOW_ACTIVATE:
  2518:       {
 97643:         accessible->AsRoot()->mActivated = true;
  2518:         guint id = g_signal_lookup ("activate", MAI_TYPE_ATK_OBJECT);
  2518:         g_signal_emit(atkObj, id, 0);
 15648: 
 15648:         // Always fire a current focus event after activation.
 79384:         FocusMgr()->ForceFocusEvent();
  2518:       } break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_WINDOW_DEACTIVATE:
  2518:       {
 97643:         accessible->AsRoot()->mActivated = false;
  2518:         guint id = g_signal_lookup ("deactivate", MAI_TYPE_ATK_OBJECT);
  2518:         g_signal_emit(atkObj, id, 0);
  2518:       } break;
  2518: 
 64019:     case nsIAccessibleEvent::EVENT_WINDOW_MAXIMIZE:
 64019:       {
 64019:         guint id = g_signal_lookup ("maximize", MAI_TYPE_ATK_OBJECT);
 64019:         g_signal_emit(atkObj, id, 0);
 64019:       } break;
 64019: 
 64019:     case nsIAccessibleEvent::EVENT_WINDOW_MINIMIZE:
 64019:       {
 64019:         guint id = g_signal_lookup ("minimize", MAI_TYPE_ATK_OBJECT);
 64019:         g_signal_emit(atkObj, id, 0);
 64019:       } break;
 64019: 
 64019:     case nsIAccessibleEvent::EVENT_WINDOW_RESTORE:
 64019:       {
 64019:         guint id = g_signal_lookup ("restore", MAI_TYPE_ATK_OBJECT);
 64019:         g_signal_emit(atkObj, id, 0);
 64019:       } break;
 64019: 
  2518:     case nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE:
  2518:         g_signal_emit_by_name (atkObj, "load_complete");
124822:       break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_DOCUMENT_RELOAD:
  2518:         g_signal_emit_by_name (atkObj, "reload");
124822:       break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_STOPPED:
  2518:         g_signal_emit_by_name (atkObj, "load_stopped");
124822:       break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_MENUPOPUP_START:
  2950:         atk_focus_tracker_notify(atkObj); // fire extra focus event
 80486:         atk_object_notify_state_change(atkObj, ATK_STATE_VISIBLE, true);
 80486:         atk_object_notify_state_change(atkObj, ATK_STATE_SHOWING, true);
  2518:         break;
  2518: 
  2518:     case nsIAccessibleEvent::EVENT_MENUPOPUP_END:
 80486:         atk_object_notify_state_change(atkObj, ATK_STATE_VISIBLE, false);
 80486:         atk_object_notify_state_change(atkObj, ATK_STATE_SHOWING, false);
  2518:         break;
   667:     }
   667: 
   667:     return NS_OK;
   667: }
   667: 
   667: nsresult
 99648: AccessibleWrap::FireAtkStateChangeEvent(AccEvent* aEvent,
   667:                                         AtkObject* aObject)
   552: {
 51377:     AccStateChangeEvent* event = downcast_accEvent(aEvent);
   552:     NS_ENSURE_TRUE(event, NS_ERROR_FAILURE);
   552: 
 79445:     bool isEnabled = event->IsStateEnabled();
108991:     int32_t stateIndex = AtkStateMap::GetStateIndexFor(event->GetState());
   552:     if (stateIndex >= 0) {
 67790:         NS_ASSERTION(gAtkStateMap[stateIndex].stateMapEntryType != kNoSuchState,
   552:                      "No such state");
   552: 
 67790:         if (gAtkStateMap[stateIndex].atkState != kNone) {
 67790:             NS_ASSERTION(gAtkStateMap[stateIndex].stateMapEntryType != kNoStateChange,
   552:                          "State changes should not fired for this state");
   552: 
 67790:             if (gAtkStateMap[stateIndex].stateMapEntryType == kMapOpposite)
   552:                 isEnabled = !isEnabled;
   552: 
   552:             // Fire state change for first state if there is one to map
   667:             atk_object_notify_state_change(aObject,
 67790:                                            gAtkStateMap[stateIndex].atkState,
   552:                                            isEnabled);
   552:         }
   552:     }
   667: 
   667:     return NS_OK;
   552: }
   582: 
   667: nsresult
 99648: AccessibleWrap::FireAtkTextChangedEvent(AccEvent* aEvent,
   667:                                         AtkObject* aObject)
   667: {
 51377:     AccTextChangeEvent* event = downcast_accEvent(aEvent);
   582:     NS_ENSURE_TRUE(event, NS_ERROR_FAILURE);
   582: 
108991:     int32_t start = event->GetStartOffset();
108991:     uint32_t length = event->GetLength();
 79445:     bool isInserted = event->IsTextInserted();
 79445:     bool isFromUserInput = aEvent->IsFromUserInput();
106838:     char* signal_name = nullptr;
   582: 
 73001:   if (gAvailableAtkSignals == eUnknown)
 86004:     gAvailableAtkSignals =
 86004:       g_signal_lookup("text-insert", G_OBJECT_TYPE(aObject)) ?
 73001:         eHaveNewAtkTextSignals : eNoNewAtkSignals;
 73001: 
 73001:   if (gAvailableAtkSignals == eNoNewAtkSignals) {
 68421:     // XXX remove this code and the gHaveNewTextSignals check when we can
 68421:     // stop supporting old atk since it doesn't really work anyway
 68421:     // see bug 619002
 68421:     signal_name = g_strconcat(isInserted ? "text_changed::insert" :
 68421:                               "text_changed::delete",
138800:                               isFromUserInput ? "" : kNonUserInputEvent, nullptr);
  6066:     g_signal_emit_by_name(aObject, signal_name, start, length);
 73001:   } else {
 73001:     nsAutoString text;
 73001:     event->GetModifiedText(text);
 73001:     signal_name = g_strconcat(isInserted ? "text-insert" : "text-remove",
138800:                               isFromUserInput ? "" : "::system", nullptr);
 73001:     g_signal_emit_by_name(aObject, signal_name, start, length,
 73001:                           NS_ConvertUTF16toUTF8(text).get());
 68421:   }
 68421: 
  6066:   g_free(signal_name);
   552:   return NS_OK;
   552: }
   552: 
   667: nsresult
 99648: AccessibleWrap::FireAtkShowHideEvent(AccEvent* aEvent,
 79445:                                      AtkObject* aObject, bool aIsAdded)
  2950: {
108991:     int32_t indexInParent = getIndexInParentCB(aObject);
 10947:     AtkObject *parentObject = getParentCB(aObject);
  2950:     NS_ENSURE_STATE(parentObject);
  2950: 
 79445:     bool isFromUserInput = aEvent->IsFromUserInput();
  6066:     char *signal_name = g_strconcat(aIsAdded ? "children_changed::add" :  "children_changed::remove",
138800:                                     isFromUserInput ? "" : kNonUserInputEvent, nullptr);
138800:     g_signal_emit_by_name(parentObject, signal_name, indexInParent, aObject, nullptr);
  6066:     g_free(signal_name);
  2950: 
  2950:     return NS_OK;
  2950: }
