81024: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
81024: /* ***** BEGIN LICENSE BLOCK *****
81024:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
81024:  *
81024:  * The contents of this file are subject to the Mozilla Public License Version
81024:  * 1.1 (the "License"); you may not use this file except in compliance with
81024:  * the License. You may obtain a copy of the License at
81024:  * http://www.mozilla.org/MPL/
81024:  *
81024:  * Software distributed under the License is distributed on an "AS IS" basis,
81024:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
81024:  * for the specific language governing rights and limitations under the
81024:  * License.
81024:  *
81024:  * The Original Code is mozilla.org code.
81024:  *
81024:  * The Initial Developer of the Original Code is
81024:  * Mozilla Foundation.
81024:  * Portions created by the Initial Developer are Copyright (C) 2011
81024:  * the Initial Developer. All Rights Reserved.
81024:  *
81024:  * Contributor(s):
81024:  *   Benoit Girard <bgirard@mozilla.com>
81024:  *
81024:  * Alternatively, the contents of this file may be used under the terms of
81024:  * either the GNU General Public License Version 2 or later (the "GPL"), or
81024:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
81024:  * in which case the provisions of the GPL or the LGPL are applicable instead
81024:  * of those above. If you wish to allow use of your version of this file only
81024:  * under the terms of either the GPL or the LGPL, and not to allow others to
81024:  * use your version of this file under the terms of the MPL, indicate your
81024:  * decision by deleting the provisions above and replace them with the notice
81024:  * and other provisions required by the GPL or the LGPL. If you do not delete
81024:  * the provisions above, a recipient may use your version of this file under
81024:  * the terms of any one of the MPL, the GPL or the LGPL.
81024:  *
81024:  * ***** END LICENSE BLOCK ***** */
81024: 
84182: #include <string>
81024: #include <stdio.h>
81024: #include "sps_sampler.h"
81024: #include "platform.h"
81024: #include "nsXULAppAPI.h"
81024: #include "nsThreadUtils.h"
81024: #include "prenv.h"
86339: #include "shared-libraries.h"
86344: #include "mozilla/StringBuilder.h"
89959: #include "mozilla/StackWalk.h"
81024: 
86346: // we eventually want to make this runtime switchable
89959: #if defined(MOZ_PROFILING) && (defined(XP_UNIX) && !defined(XP_MACOSX))
87197:  #ifndef ANDROID
87196:   #define USE_BACKTRACE
87196:  #endif
87197: #endif
86346: #ifdef USE_BACKTRACE
86346:  #include <execinfo.h>
86346: #endif
86346: 
89959: #if defined(MOZ_PROFILING) && (defined(XP_MACOSX) || defined(XP_WIN))
87491:  #define USE_NS_STACKWALK
87491: #endif
87491: #ifdef USE_NS_STACKWALK
87491:  #include "nsStackWalk.h"
87491: #endif
87491: 
84182: using std::string;
86344: using namespace mozilla;
84182: 
84348: #ifdef XP_WIN
84348:  #include <windows.h>
84348:  #define getpid GetCurrentProcessId
84348: #else
84348:  #include <unistd.h>
84348: #endif
84348: 
84348: #ifndef MAXPATHLEN
84348:  #ifdef PATH_MAX
84348:   #define MAXPATHLEN PATH_MAX
84348:  #elif defined(MAX_PATH)
84348:   #define MAXPATHLEN MAX_PATH
84348:  #elif defined(_MAX_PATH)
84348:   #define MAXPATHLEN _MAX_PATH
84348:  #elif defined(CCHMAXPATH)
84348:   #define MAXPATHLEN CCHMAXPATH
84348:  #else
84348:   #define MAXPATHLEN 1024
84348:  #endif
84348: #endif
84348: 
84348: #if _MSC_VER
84348:  #define snprintf _snprintf
84348: #endif
84348: 
86346: 
84348: mozilla::tls::key pkey_stack;
84348: mozilla::tls::key pkey_ticker;
84289: // We need to track whether we've been initialized otherwise
84289: // we end up using pkey_stack without initializing it.
84289: // Because pkey_stack is totally opaque to us we can't reuse
84289: // it as the flag itself.
84289: bool stack_key_initialized;
81024: 
84182: TimeStamp sLastTracerEvent;
84182: 
81024: class Profile;
81024: 
81024: class ProfileEntry
81024: {
81024: public:
81024:   ProfileEntry()
81024:     : mTagData(NULL)
81024:     , mLeafAddress(0)
81024:     , mTagName(0)
81024:   { }
81024: 
81024:   // aTagData must not need release (i.e. be a string from the text segment)
81024:   ProfileEntry(char aTagName, const char *aTagData)
81024:     : mTagData(aTagData)
81024:     , mLeafAddress(0)
81024:     , mTagName(aTagName)
81024:   { }
81024: 
84182:   // aTagData must not need release (i.e. be a string from the text segment)
81024:   ProfileEntry(char aTagName, const char *aTagData, Address aLeafAddress)
81024:     : mTagData(aTagData)
81024:     , mLeafAddress(aLeafAddress)
81024:     , mTagName(aTagName)
81024:   { }
81024: 
87177:   ProfileEntry(char aTagName, double aTagFloat)
84182:     : mTagFloat(aTagFloat)
84182:     , mLeafAddress(0)
84182:     , mTagName(aTagName)
84182:   { }
84182: 
87196:   ProfileEntry(char aTagName, uintptr_t aTagOffset)
87196:     : mTagOffset(aTagOffset)
87196:     , mLeafAddress(0)
87196:     , mTagName(aTagName)
87196:   { }
87196: 
84182:   string TagToString(Profile *profile);
81024: 
81024: private:
84182:   union {
81024:     const char* mTagData;
87177:     double mTagFloat;
86346:     Address mTagAddress;
87196:     uintptr_t mTagOffset;
84182:   };
81024:   Address mLeafAddress;
81024:   char mTagName;
81024: };
81024: 
81024: #define PROFILE_MAX_ENTRY 100000
81024: class Profile
81024: {
81024: public:
81024:   Profile(int aEntrySize)
81024:     : mWritePos(0)
87847:     , mLastFlushPos(0)
81024:     , mReadPos(0)
81024:     , mEntrySize(aEntrySize)
81024:   {
81024:     mEntries = new ProfileEntry[mEntrySize];
86342:     mNeedsSharedLibraryInfo = true;
81024:   }
81024: 
81024:   ~Profile()
81024:   {
81024:     delete[] mEntries;
81024:   }
81024: 
81024:   void addTag(ProfileEntry aTag)
81024:   {
81024:     // Called from signal, call only reentrant functions
81024:     mEntries[mWritePos] = aTag;
81024:     mWritePos = (mWritePos + 1) % mEntrySize;
81024:     if (mWritePos == mReadPos) {
81024:       // Keep one slot open
81024:       mEntries[mReadPos] = ProfileEntry();
81024:       mReadPos = (mReadPos + 1) % mEntrySize;
81024:     }
87847:     // we also need to move the flush pos to ensure we
87847:     // do not pass it
87847:     if (mWritePos == mLastFlushPos) {
87847:       mLastFlushPos = (mLastFlushPos + 1) % mEntrySize;
87847:     }
87847:   }
87847: 
87847:   // flush the new entries
87847:   void flush()
87847:   {
87847:     mLastFlushPos = mWritePos;
87847:   }
87847: 
87847:   // discards all of the entries since the last flush()
87847:   // NOTE: that if mWritePos happens to wrap around past
87847:   // mLastFlushPos we actually only discard mWritePos - mLastFlushPos entries
87847:   //
87847:   // r = mReadPos
87847:   // w = mWritePos
87847:   // f = mLastFlushPos
87847:   //
87847:   //     r          f    w
87847:   // |-----------------------------|
87847:   // |   abcdefghijklmnopq         | -> 'abcdefghijklmnopq'
87847:   // |-----------------------------|
87847:   //
87847:   //
87847:   // mWritePos and mReadPos have passed mLastFlushPos
87847:   //                      f
87847:   //                    w r
87847:   // |-----------------------------|
87847:   // |ABCDEFGHIJKLMNOPQRSqrstuvwxyz|
87847:   // |-----------------------------|
87847:   //                       w
87847:   //                       r
87847:   // |-----------------------------|
87847:   // |ABCDEFGHIJKLMNOPQRSqrstuvwxyz| -> ''
87847:   // |-----------------------------|
87847:   //
87847:   //
87847:   // mWritePos will end up the same as mReadPos
87847:   //                r
87847:   //              w f
87847:   // |-----------------------------|
87847:   // |ABCDEFGHIJKLMklmnopqrstuvwxyz|
87847:   // |-----------------------------|
87847:   //                r
87847:   //                w
87847:   // |-----------------------------|
87847:   // |ABCDEFGHIJKLMklmnopqrstuvwxyz| -> ''
87847:   // |-----------------------------|
87847:   //
87847:   //
87847:   // mWritePos has moved past mReadPos
87847:   //      w r       f
87847:   // |-----------------------------|
87847:   // |ABCDEFdefghijklmnopqrstuvwxyz|
87847:   // |-----------------------------|
87847:   //        r       w
87847:   // |-----------------------------|
87847:   // |ABCDEFdefghijklmnopqrstuvwxyz| -> 'defghijkl'
87847:   // |-----------------------------|
87847: 
87847:   void erase()
87847:   {
87847:     mWritePos = mLastFlushPos;
81024:   }
81024: 
86344:   void ToString(StringBuilder &profile)
84182:   {
86342:     if (mNeedsSharedLibraryInfo) {
84182:       // Can't be called from signal because
86339:       // getting the shared library information can call non-reentrant functions.
86339:       mSharedLibraryInfo = SharedLibraryInfo::GetInfoForSelf();
86342:     }
84182: 
87847:     //XXX: this code is not thread safe and needs to be fixed
84182:     int oldReadPos = mReadPos;
87847:     while (mReadPos != mLastFlushPos) {
86344:       profile.Append(mEntries[mReadPos].TagToString(this).c_str());
84182:       mReadPos = (mReadPos + 1) % mEntrySize;
84182:     }
84182:     mReadPos = oldReadPos;
84182:   }
84182: 
81024:   void WriteProfile(FILE* stream)
81024:   {
86342:     if (mNeedsSharedLibraryInfo) {
81024:       // Can't be called from signal because
86339:       // getting the shared library information can call non-reentrant functions.
86339:       mSharedLibraryInfo = SharedLibraryInfo::GetInfoForSelf();
86342:     }
81024: 
87847:     //XXX: this code is not thread safe and needs to be fixed
81024:     int oldReadPos = mReadPos;
87847:     while (mReadPos != mLastFlushPos) {
86345:       string tag = mEntries[mReadPos].TagToString(this);
86345:       fwrite(tag.data(), 1, tag.length(), stream);
81024:       mReadPos = (mReadPos + 1) % mEntrySize;
81024:     }
81024:     mReadPos = oldReadPos;
81024:   }
81024: 
86339:   SharedLibraryInfo& getSharedLibraryInfo()
81024:   {
86339:     return mSharedLibraryInfo;
81024:   }
81024: private:
81024:   // Circular buffer 'Keep One Slot Open' implementation
81024:   // for simplicity
81024:   ProfileEntry *mEntries;
81024:   int mWritePos; // points to the next entry we will write to
87847:   int mLastFlushPos; // points to the next entry since the last flush()
81024:   int mReadPos;  // points to the next entry we will read to
81024:   int mEntrySize;
86342:   bool mNeedsSharedLibraryInfo;
86339:   SharedLibraryInfo mSharedLibraryInfo;
81024: };
81024: 
81024: class SaveProfileTask;
81024: 
87178: static bool
87178: hasFeature(const char** aFeatures, uint32_t aFeatureCount, const char* aFeature) {
87178:   for(size_t i = 0; i < aFeatureCount; i++) {
87178:     if (strcmp(aFeatures[i], aFeature) == 0)
87178:       return true;
87178:   }
87178:   return false;
87178: }
87178: 
81024: class TableTicker: public Sampler {
81024:  public:
87178:   TableTicker(int aInterval, int aEntrySize, Stack *aStack,
87178:               const char** aFeatures, uint32_t aFeatureCount)
81024:     : Sampler(aInterval, true)
81024:     , mProfile(aEntrySize)
84182:     , mStack(aStack)
81024:     , mSaveRequested(false)
81024:   {
87196:     mUseStackWalk = hasFeature(aFeatures, aFeatureCount, "stackwalk");
87847:     //XXX: It's probably worth splitting the jank profiler out from the regular profiler at some point
87413:     mJankOnly = hasFeature(aFeatures, aFeatureCount, "jank");
89347:     mProfile.addTag(ProfileEntry('m', "Start"));
81024:   }
81024: 
81024:   ~TableTicker() { if (IsActive()) Stop(); }
81024: 
81024:   virtual void SampleStack(TickSample* sample) {}
81024: 
81024:   // Called within a signal. This function must be reentrant
81024:   virtual void Tick(TickSample* sample);
81024: 
81024:   // Called within a signal. This function must be reentrant
81024:   virtual void RequestSave()
81024:   {
81024:     mSaveRequested = true;
81024:   }
81024: 
81024:   virtual void HandleSaveRequest();
81024: 
81024:   Stack* GetStack()
81024:   {
84182:     return mStack;
81024:   }
81024: 
81024:   Profile* GetProfile()
81024:   {
81024:     return &mProfile;
81024:   }
87491: 
87491: private:
87491:   // Not implemented on platforms which do not support backtracing
89959:   void doBacktrace(Profile &aProfile, Address pc);
87491: 
81024: private:
81024:   Profile mProfile;
84182:   Stack *mStack;
81024:   bool mSaveRequested;
87196:   bool mUseStackWalk;
87413:   bool mJankOnly;
81024: };
81024: 
81024: /**
81024:  * This is an event used to save the profile on the main thread
81024:  * to be sure that it is not being modified while saving.
81024:  */
81024: class SaveProfileTask : public nsRunnable {
81024: public:
81024:   SaveProfileTask() {}
81024: 
81024:   NS_IMETHOD Run() {
84348:     TableTicker *t = mozilla::tls::get<TableTicker>(pkey_ticker);
81024: 
84348:     char buff[MAXPATHLEN];
81024: #ifdef ANDROID
81024:   #define FOLDER "/sdcard/"
84348: #elif defined(XP_WIN)
84348:   #define FOLDER "%TEMP%\\"
81024: #else
81024:   #define FOLDER "/tmp/"
81024: #endif
84348: 
84348:     snprintf(buff, MAXPATHLEN, "%sprofile_%i_%i.txt", FOLDER, XRE_GetProcessType(), getpid());
84348: 
84348: #ifdef XP_WIN
84348:     // Expand %TEMP% on Windows
84348:     {
84348:       char tmp[MAXPATHLEN];
84348:       ExpandEnvironmentStringsA(buff, tmp, mozilla::ArrayLength(tmp));
84348:       strcpy(buff, tmp);
84348:     }
84348: #endif
81024: 
81024:     FILE* stream = ::fopen(buff, "w");
81024:     if (stream) {
81024:       t->GetProfile()->WriteProfile(stream);
81024:       ::fclose(stream);
84182:       LOG("Saved to " FOLDER "profile_TYPE_PID.txt");
81024:     } else {
81024:       LOG("Fail to open profile log file.");
81024:     }
81024: 
81024:     return NS_OK;
81024:   }
81024: };
81024: 
81024: void TableTicker::HandleSaveRequest()
81024: {
81024:   if (!mSaveRequested)
81024:     return;
81024:   mSaveRequested = false;
81024: 
81024:   // TODO: Use use the ipc/chromium Tasks here to support processes
81024:   // without XPCOM.
81024:   nsCOMPtr<nsIRunnable> runnable = new SaveProfileTask();
81024:   NS_DispatchToMainThread(runnable);
81024: }
81024: 
89959: 
86346: #ifdef USE_BACKTRACE
89959: void TableTicker::doBacktrace(Profile &aProfile, Address pc)
86346: {
86346:   void *array[100];
86346:   int count = backtrace (array, 100);
86346: 
89123:   aProfile.addTag(ProfileEntry('s', "(root)", 0));
87196: 
87196:   for (int i = 0; i < count; i++) {
87196:     if( (intptr_t)array[i] == -1 ) break;
86346:     aProfile.addTag(ProfileEntry('l', (const char*)array[i]));
86346:   }
86346: }
86346: #endif
86346: 
89959: 
87491: #ifdef USE_NS_STACKWALK
87491: typedef struct {
87491:   void** array;
87491:   size_t size;
87491:   size_t count;
87491: } PCArray;
87491: 
87491: static
87491: void StackWalkCallback(void* aPC, void* aClosure)
87491: {
87491:   PCArray* array = static_cast<PCArray*>(aClosure);
87491:   if (array->count >= array->size) {
87491:     // too many frames, ignore
87491:     return;
87491:   }
87491:   array->array[array->count++] = aPC;
87491: }
87491: 
89959: void TableTicker::doBacktrace(Profile &aProfile, Address fp)
87491: {
89959: #ifndef XP_MACOSX
87491:   uintptr_t thread = GetThreadHandle(platform_data());
87491:   MOZ_ASSERT(thread);
89959: #endif
87491:   void* pc_array[1000];
87491:   PCArray array = {
87491:     pc_array,
87491:     mozilla::ArrayLength(pc_array),
87491:     0
87491:   };
89959: #ifdef XP_MACOSX
89959:   nsresult rv = FramePointerStackWalk(StackWalkCallback, 1, &array, reinterpret_cast<void**>(fp));
89959: #else
87491:   nsresult rv = NS_StackWalk(StackWalkCallback, 0, &array, thread);
89959: #endif
87491:   if (NS_SUCCEEDED(rv)) {
89123:     aProfile.addTag(ProfileEntry('s', "(root)", 0));
87491: 
87491:     for (size_t i = array.count; i > 0; --i) {
87491:       aProfile.addTag(ProfileEntry('l', (const char*)array.array[i - 1]));
87491:     }
87491:   }
87491: }
87491: #endif
87491: 
86346: static
86346: void doSampleStackTrace(Stack *aStack, Profile &aProfile, TickSample *sample)
86346: {
86346:   // Sample
86346:   // 's' tag denotes the start of a sample block
86346:   // followed by 0 or more 'c' tags.
86346:   for (int i = 0; i < aStack->mStackPointer; i++) {
86346:     if (i == 0) {
86346:       Address pc = 0;
86346:       if (sample) {
86346:         pc = sample->pc;
86346:       }
86346:       aProfile.addTag(ProfileEntry('s', aStack->mStack[i], pc));
86346:     } else {
86346:       aProfile.addTag(ProfileEntry('c', aStack->mStack[i]));
86346:     }
86346:   }
86346: }
81024: 
87847: /* used to keep track of the last event that we sampled during */
87847: unsigned int sLastSampledEventGeneration = 0;
87847: 
87847: /* a counter that's incremented everytime we get responsiveness event
87847:  * note: it might also be worth tracking everytime we go around
87847:  * the event loop */
87847: unsigned int sCurrentEventGeneration = 0;
87847: /* we don't need to worry about overflow because we only treat the
87847:  * case of them being the same as special. i.e. we only run into
87847:  * a problem if 2^32 events happen between samples that we need
87847:  * to know are associated with different events */
87847: 
81024: void TableTicker::Tick(TickSample* sample)
81024: {
81024:   // Marker(s) come before the sample
81024:   int i = 0;
84182:   const char *marker = mStack->getMarker(i++);
81024:   for (int i = 0; marker != NULL; i++) {
81024:     mProfile.addTag(ProfileEntry('m', marker));
84182:     marker = mStack->getMarker(i++);
81024:   }
84182:   mStack->mQueueClearMarker = true;
81024: 
87847:   // if we are on a different event we can discard any temporary samples
87847:   // we've kept around
87847:   if (sLastSampledEventGeneration != sCurrentEventGeneration) {
87847:     // XXX: we also probably want to add an entry to the profile to help
87847:     // distinguish which samples are part of the same event. That, or record
87847:     // the event generation in each sample
87847:     mProfile.erase();
87847:   }
87847:   sLastSampledEventGeneration = sCurrentEventGeneration;
87847: 
87413:   bool recordSample = true;
87413:   if (mJankOnly) {
87413:     recordSample = false;
87413:     // only record the events when we have a we haven't seen a tracer event for 100ms
87413:     if (!sLastTracerEvent.IsNull()) {
87413:       TimeDuration delta = sample->timestamp - sLastTracerEvent;
87413:       if (delta.ToMilliseconds() > 100.0) {
87413:           recordSample = true;
87413:       }
87413:     }
87413:   }
87413: 
87491: #if defined(USE_BACKTRACE) || defined(USE_NS_STACKWALK)
87196:   if (mUseStackWalk) {
89959:     doBacktrace(mProfile, sample->fp);
87196:   } else {
87196:     doSampleStackTrace(mStack, mProfile, sample);
87196:   }
86346: #else
86346:   doSampleStackTrace(mStack, mProfile, sample);
86346: #endif
87847: 
87847:   if (recordSample)
87847:     mProfile.flush();
81024: 
87413:   if (!mJankOnly && !sLastTracerEvent.IsNull() && sample) {
86164:     TimeDuration delta = sample->timestamp - sLastTracerEvent;
84182:     mProfile.addTag(ProfileEntry('r', delta.ToMilliseconds()));
84182:   }
84182: }
84182: 
84182: string ProfileEntry::TagToString(Profile *profile)
84182: {
84182:   string tag = "";
84182:   if (mTagName == 'r') {
84182:     char buff[50];
84182:     snprintf(buff, 50, "%-40f", mTagFloat);
84182:     tag += string(1, mTagName) + string("-") + string(buff) + string("\n");
86346:   } else if (mTagName == 'l') {
86346:     bool found = false;
86346:     char tagBuff[1024];
86346:     SharedLibraryInfo& shlibInfo = profile->getSharedLibraryInfo();
86346:     Address pc = mTagAddress;
86346:     // TODO Use binary sort (STL)
86346:     for (size_t i = 0; i < shlibInfo.GetSize(); i++) {
86346:       SharedLibrary &e = shlibInfo.GetEntry(i);
86346:       if (pc > (Address)e.GetStart() && pc < (Address)e.GetEnd()) {
86346:         if (e.GetName()) {
86346:           found = true;
87196: 
86346:           snprintf(tagBuff, 1024, "l-%s@%p\n", e.GetName(), pc - e.GetStart());
86346:           tag += string(tagBuff);
87196: 
86346:           break;
86346:         }
86346:       }
86346:     }
86346:     if (!found) {
86346:       snprintf(tagBuff, 1024, "l-???@%p\n", pc);
86346:       tag += string(tagBuff);
86346:     }
84182:   } else {
84182:     tag += string(1, mTagName) + string("-") + string(mTagData) + string("\n");
84182:   }
84182: 
84182: #ifdef ENABLE_SPS_LEAF_DATA
84182:   if (mLeafAddress) {
84182:     bool found = false;
84182:     char tagBuff[1024];
86339:     SharedLibraryInfo& shlibInfo = profile->getSharedLibraryInfo();
84182:     unsigned long pc = (unsigned long)mLeafAddress;
84182:     // TODO Use binary sort (STL)
86339:     for (size_t i = 0; i < shlibInfo.GetSize(); i++) {
86339:       SharedLibrary &e = shlibInfo.GetEntry(i);
84182:       if (pc > e.GetStart() && pc < e.GetEnd()) {
84182:         if (e.GetName()) {
84182:           found = true;
84182:           snprintf(tagBuff, 1024, "l-%900s@%llu\n", e.GetName(), pc - e.GetStart());
84182:           tag += string(tagBuff);
84182:           break;
84182:         }
84182:       }
84182:     }
84182:     if (!found) {
84182:       snprintf(tagBuff, 1024, "l-???@%llu\n", pc);
84182:       tag += string(tagBuff);
84182:     }
84182:   }
84182: #endif
84182:   return tag;
84182: }
81024: 
81024: #define PROFILE_DEFAULT_ENTRY 100000
84182: #define PROFILE_DEFAULT_INTERVAL 10
87178: #define PROFILE_DEFAULT_FEATURES NULL
87178: #define PROFILE_DEFAULT_FEATURE_COUNT 0
84182: 
81024: void mozilla_sampler_init()
81024: {
81024:   // TODO linux port: Use TLS with ifdefs
84348:   if (!mozilla::tls::create(&pkey_stack) ||
84348:       !mozilla::tls::create(&pkey_ticker)) {
81024:     LOG("Failed to init.");
81024:     return;
81024:   }
84289:   stack_key_initialized = true;
81024: 
84182:   Stack *stack = new Stack();
84348:   mozilla::tls::set(pkey_stack, stack);
84182: 
84182:   // We can't open pref so we use an environment variable
84182:   // to know if we should trigger the profiler on startup
84182:   // NOTE: Default
84182:   const char *val = PR_GetEnv("MOZ_PROFILER_STARTUP");
83113:   if (!val || !*val) {
83113:     return;
83113:   }
83113: 
87178:   mozilla_sampler_start(PROFILE_DEFAULT_ENTRY, PROFILE_DEFAULT_INTERVAL,
87178:                         PROFILE_DEFAULT_FEATURES, PROFILE_DEFAULT_FEATURE_COUNT);
84182: }
84182: 
84182: void mozilla_sampler_deinit()
84182: {
84182:   mozilla_sampler_stop();
84182:   // We can't delete the Stack because we can be between a
84182:   // sampler call_enter/call_exit point.
84182:   // TODO Need to find a safe time to delete Stack
84182: }
84182: 
87178: void mozilla_sampler_save()
87178: {
84348:   TableTicker *t = mozilla::tls::get<TableTicker>(pkey_ticker);
84182:   if (!t) {
84182:     return;
84182:   }
84182: 
84182:   t->RequestSave();
84182:   // We're on the main thread already so we don't
84182:   // have to wait to handle the save request.
84182:   t->HandleSaveRequest();
84182: }
84182: 
87178: char* mozilla_sampler_get_profile()
87178: {
84348:   TableTicker *t = mozilla::tls::get<TableTicker>(pkey_ticker);
84182:   if (!t) {
84182:     return NULL;
84182:   }
84182: 
86344:   StringBuilder profile;
86344:   t->GetProfile()->ToString(profile);
84182: 
86344:   char *rtn = (char*)malloc( (profile.Length()+1) * sizeof(char) );
86344:   strcpy(rtn, profile.Buffer());
84182:   return rtn;
84182: }
84182: 
87178: const char** mozilla_sampler_get_features()
87178: {
87196:   static const char* features[] = {
87647: #if defined(MOZ_PROFILING) && (defined(USE_BACKTRACE) || defined(USE_NS_STACKWALK))
87196:     "stackwalk",
87196: #endif
89347:     "jank",
87196:     NULL
87196:   };
87178: 
87178:   return features;
87178: }
87178: 
84182: // Values are only honored on the first start
87178: void mozilla_sampler_start(int aProfileEntries, int aInterval,
87178:                            const char** aFeatures, uint32_t aFeatureCount)
84182: {
84348:   Stack *stack = mozilla::tls::get<Stack>(pkey_stack);
84182:   if (!stack) {
84182:     ASSERT(false);
84182:     return;
84182:   }
84182: 
84182:   mozilla_sampler_stop();
84182: 
87178:   TableTicker *t = new TableTicker(aInterval, aProfileEntries, stack,
87178:                                    aFeatures, aFeatureCount);
84348:   mozilla::tls::set(pkey_ticker, t);
81024:   t->Start();
81024: }
81024: 
84182: void mozilla_sampler_stop()
81024: {
84348:   TableTicker *t = mozilla::tls::get<TableTicker>(pkey_ticker);
81024:   if (!t) {
81024:     return;
81024:   }
81024: 
81024:   t->Stop();
84348:   mozilla::tls::set(pkey_ticker, (Stack*)NULL);
81024: }
81024: 
84182: bool mozilla_sampler_is_active()
84182: {
84348:   TableTicker *t = mozilla::tls::get<TableTicker>(pkey_ticker);
84182:   if (!t) {
84182:     return false;
84182:   }
84182: 
84182:   return t->IsActive();
84182: }
84182: 
87177: double sResponsivenessTimes[100];
87177: double sCurrResponsiveness = 0.f;
84182: unsigned int sResponsivenessLoc = 0;
84182: void mozilla_sampler_responsiveness(TimeStamp aTime)
84182: {
84182:   if (!sLastTracerEvent.IsNull()) {
84182:     if (sResponsivenessLoc == 100) {
84182:       for(size_t i = 0; i < 100-1; i++) {
84182:         sResponsivenessTimes[i] = sResponsivenessTimes[i+1];
84182:       }
84182:       sResponsivenessLoc--;
84182:     }
84182:     TimeDuration delta = aTime - sLastTracerEvent;
84182:     sResponsivenessTimes[sResponsivenessLoc++] = delta.ToMilliseconds();
84182:   }
87847:   sCurrentEventGeneration++;
84182: 
84182:   sLastTracerEvent = aTime;
84182: }
84182: 
87177: const double* mozilla_sampler_get_responsiveness()
84182: {
84182:   return sResponsivenessTimes;
84182: }
84182: 
