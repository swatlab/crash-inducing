16300: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
16300: /* vim:set ts=2 sw=2 sts=2 et cindent: */
16300: /* ***** BEGIN LICENSE BLOCK *****
39436:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
16300:  *
16300:  * The contents of this file are subject to the Mozilla Public License Version
16300:  * 1.1 (the "License"); you may not use this file except in compliance with
16300:  * the License. You may obtain a copy of the License at
16300:  * http://www.mozilla.org/MPL/
16300:  *
16300:  * Software distributed under the License is distributed on an "AS IS" basis,
16300:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
16300:  * for the specific language governing rights and limitations under the
16300:  * License.
16300:  *
16300:  * The Original Code is Mozilla code.
16300:  *
16300:  * The Initial Developer of the Original Code is the Mozilla Corporation.
16300:  * Portions created by the Initial Developer are Copyright (C) 2007
16300:  * the Initial Developer. All Rights Reserved.
16300:  *
16300:  * Contributor(s):
16300:  *  Chris Double <chris.double@double.co.nz>
40132:  *  Chris Pearce <chris@pearce.org.nz>
16300:  *
16300:  * Alternatively, the contents of this file may be used under the terms of
16300:  * either the GNU General Public License Version 2 or later (the "GPL"), or
16300:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
16300:  * in which case the provisions of the GPL or the LGPL are applicable instead
16300:  * of those above. If you wish to allow use of your version of this file only
16300:  * under the terms of either the GPL or the LGPL, and not to allow others to
16300:  * use your version of this file under the terms of the MPL, indicate your
16300:  * decision by deleting the provisions above and replace them with the notice
16300:  * and other provisions required by the GPL or the LGPL. If you do not delete
16300:  * the provisions above, a recipient may use your version of this file under
16300:  * the terms of any one of the MPL, the GPL or the LGPL.
16300:  *
16300:  * ***** END LICENSE BLOCK ***** */
16300: /*
73703: Each video element based on nsBuiltinDecoder has a state machine to manage
73703: its play state and keep the current frame up to date. All state machines
73703: share time in a single shared thread. Each decoder also has one thread
73703: dedicated to decoding audio and video data. This thread is shutdown when
73703: playback is paused. Each decoder also has a thread to push decoded audio
73703: to the hardware. This thread is not created until playback starts, but
73703: currently is not destroyed when paused, only when playback ends.
28267: 
73703: The decoder owns the resources for downloading the media file, and the
73703: high level state. It holds an owning reference to the state machine
73703: (a subclass of nsDecoderStateMachine; nsBuiltinDecoderStateMachine) that
73703: owns all the resources related to decoding data, and manages the low level
73703: decoding operations and A/V sync. 
28267: 
73703: Each state machine runs on the shared state machine thread. Every time some
73703: action is required for a state machine, it is scheduled to run on the shared
73703: the state machine thread. The state machine runs one "cycle" on the state
73703: machine thread, and then returns. If necessary, it will schedule itself to
73703: run again in future. While running this cycle, it must not block the
73703: thread, as other state machines' events may need to run. State shared
73703: between a state machine's threads is synchronised via the monitor owned
73703: by its nsBuiltinDecoder object.
20627: 
20627: The Main thread controls the decode state machine by setting the value
41387: of a mPlayState variable and notifying on the monitor based on the
41387: high level player actions required (Seek, Pause, Play, etc).
20627: 
20627: The player states are the states requested by the client through the
20627: DOM API.  They represent the desired state of the player, while the
20627: decoder's state represents the actual state of the decoder.
20627: 
20627: The high level state of the player is maintained via a PlayState value. 
20627: It can have the following states:
20627: 
20627: START
20627:   The decoder has been initialized but has no resource loaded.
20627: PAUSED
20627:   A request via the API has been received to pause playback.
20627: LOADING
20627:   A request via the API has been received to load a resource.
20627: PLAYING
20627:   A request via the API has been received to start playback.
20627: SEEKING
20627:   A request via the API has been received to start seeking.
20627: COMPLETED
20627:   Playback has completed.
20627: SHUTDOWN
20627:   The decoder is about to be destroyed.
20627: 
20627: State transition occurs when the Media Element calls the Play, Seek,
41387: etc methods on the nsBuiltinDecoder object. When the transition
41387: occurs nsBuiltinDecoder then calls the methods on the decoder state
73703: machine object to cause it to behave as required by the play state.
73703: State transitions will likely schedule the state machine to run to
73703: affect the change.
20627: 
41954: An implementation of the nsDecoderStateMachine class is the event
73703: that gets dispatched to the state machine thread. Each time the event is run,
73703: the state machine must cycle the state machine once, and then return.
73703: 
73703: The state machine has the following states:
41954: 
41954: DECODING_METADATA
41954:   The media headers are being loaded, and things like framerate, etc are
41954:   being determined, and the first frame of audio/video data is being decoded.
41954: DECODING
73703:   The decode has started. If the PlayState is PLAYING, the decode thread
73703:   should be alive and decoding video and audio frame, the audio thread
73703:   should be playing audio, and the state machine should run periodically
73703:   to update the video frames being displayed.
41954: SEEKING
73703:   A seek operation is in progress. The decode thread should be seeking.
41954: BUFFERING
73703:   Decoding is paused while data is buffered for smooth playback. If playback
73703:   is paused (PlayState transitions to PAUSED) we'll destory the decode thread.
41954: COMPLETED
73703:   The resource has completed decoding, but possibly not finished playback.
73703:   The decode thread will be destroyed. Once playback finished, the audio
73703:   thread will also be destroyed.
41954: SHUTDOWN
73703:   The decoder object and its state machine are about to be destroyed.
73703:   Once the last state machine has been destroyed, the shared state machine
73703:   thread will also be destroyed. It will be recreated later if needed.
41954: 
41954: The following result in state transitions.
41954: 
41954: Shutdown()
41954:   Clean up any resources the nsDecoderStateMachine owns.
63623: Play()
63623:   Start decoding and playback of media data.
41954: Buffer
41954:   This is not user initiated. It occurs when the
41954:   available data in the stream drops below a certain point.
41954: Complete
41954:   This is not user initiated. It occurs when the
41954:   stream is completely decoded.
60727: Seek(double)
41954:   Seek to the time position given in the resource.
41954: 
41954: A state transition diagram:
41954: 
41954: DECODING_METADATA
41954:   |      |
41954:   v      | Shutdown()
41954:   |      |
41954:   v      -->-------------------->--------------------------|
41954:   |---------------->----->------------------------|        v
41954: DECODING             |          |  |              |        |
41954:   ^                  v Seek(t)  |  |              |        |
63623:   |         Play()   |          v  |              |        |
41954:   ^-----------<----SEEKING      |  v Complete     v        v
41954:   |                  |          |  |              |        |
41954:   |                  |          |  COMPLETED    SHUTDOWN-<-|
41954:   ^                  ^          |  |Shutdown()    |
41954:   |                  |          |  >-------->-----^
63623:   |          Play()  |Seek(t)   |Buffer()         |
41954:   -----------<--------<-------BUFFERING           |
41954:                                 |                 ^
41954:                                 v Shutdown()      |
41954:                                 |                 |
41954:                                 ------------>-----|
41954: 
41954: The following represents the states that the nsBuiltinDecoder object
41954: can be in, and the valid states the nsDecoderStateMachine can be in at that
41954: time:
41954: 
41954: player LOADING   decoder DECODING_METADATA
41954: player PLAYING   decoder DECODING, BUFFERING, SEEKING, COMPLETED
41954: player PAUSED    decoder DECODING, BUFFERING, SEEKING, COMPLETED
41954: player SEEKING   decoder SEEKING
41954: player COMPLETED decoder SHUTDOWN
41954: player SHUTDOWN  decoder SHUTDOWN
41954: 
41387: The general sequence of events is:
20627: 
20627: 1) The video element calls Load on nsMediaDecoder. This creates the
73703:    state machine and starts the channel for downloading the
73703:    file. It instantiates and schedules the nsDecoderStateMachine. The
41387:    high level LOADING state is entered, which results in the decode
73703:    thread being created and starting to decode metadata. These are
73703:    the headers that give the video size, framerate, etc. Load() returns
73703:    immediately to the calling video element.
16300: 
73703: 2) When the metadata has been loaded by the decode thread, the state machine
73703:    will call a method on the video element object to inform it that this
73703:    step is done, so it can do the things required by the video specification
73703:    at this stage. The decode thread then continues to decode the first frame
41387:    of data.
16300: 
73703: 3) When the first frame of data has been successfully decoded the state
73703:    machine calls a method on the video element object to inform it that
73703:    this step has been done, once again so it can do the required things
73703:    by the video specification at this stage.
16300: 
20627:    This results in the high level state changing to PLAYING or PAUSED
20627:    depending on any user action that may have occurred.
16300: 
73703:    While the play state is PLAYING, the decode thread will decode
73703:    data, and the audio thread will push audio data to the hardware to
73703:    be played. The state machine will run periodically on the shared
73703:    state machine thread to ensure video frames are played at the 
73703:    correct time; i.e. the state machine manages A/V sync.
16300: 
73703: The Shutdown method on nsBuiltinDecoder closes the download channel, and
73703: signals to the state machine that it should shutdown. The state machine
73703: shuts down asynchronously, and will release the owning reference to the
73703: state machine once its threads are shutdown.
16300: 
73703: The owning object of a nsBuiltinDecoder object *MUST* call Shutdown when
73703: destroying the nsBuiltinDecoder object.
16300: 
16300: */
41387: #if !defined(nsBuiltinDecoder_h_)
41387: #define nsBuiltinDecoder_h_
16300: 
33372: #include "nsMediaDecoder.h"
33372: 
16300: #include "nsISupports.h"
16300: #include "nsCOMPtr.h"
16300: #include "nsIThread.h"
16300: #include "nsIChannel.h"
16300: #include "nsIObserver.h"
16300: #include "nsIFrame.h"
16300: #include "nsAutoPtr.h"
16300: #include "nsSize.h"
16300: #include "prlog.h"
16300: #include "gfxContext.h"
16300: #include "gfxRect.h"
40132: #include "nsMediaStream.h"
40132: #include "nsMediaDecoder.h"
41387: #include "nsHTMLMediaElement.h"
69142: #include "mozilla/ReentrantMonitor.h"
40132: 
41387: class nsAudioStream;
16300: 
79445: static inline bool IsCurrentThread(nsIThread* aThread) {
41387:   return NS_GetCurrentThread() == aThread;
41387: }
16300: 
41387: // Decoder backends must implement this class to perform the codec
41387: // specific parts of decoding the video/audio format.
41387: class nsDecoderStateMachine : public nsRunnable
16300: {
41387: public:
41954:   // Enumeration for the valid decoding states
41954:   enum State {
41954:     DECODER_STATE_DECODING_METADATA,
41954:     DECODER_STATE_DECODING,
41954:     DECODER_STATE_SEEKING,
41954:     DECODER_STATE_BUFFERING,
41954:     DECODER_STATE_COMPLETED,
41954:     DECODER_STATE_SHUTDOWN
41954:   };
41954: 
41387:   // Initializes the state machine, returns NS_OK on success, or
41387:   // NS_ERROR_FAILURE on failure.
54993:   virtual nsresult Init(nsDecoderStateMachine* aCloneDonor) = 0;
16300: 
41954:   // Return the current decode state. The decoder monitor must be
41954:   // obtained before calling this.
41954:   virtual State GetState() = 0;
41954: 
41387:   // Set the audio volume. The decoder monitor must be obtained before
41387:   // calling this.
60727:   virtual void SetVolume(double aVolume) = 0;
41387: 
41387:   virtual void Shutdown() = 0;
41387: 
41387:   // Called from the main thread to get the duration. The decoder monitor
68450:   // must be obtained before calling this. It is in units of microseconds.
41387:   virtual PRInt64 GetDuration() = 0;
41387: 
41387:   // Called from the main thread to set the duration of the media resource
43340:   // if it is able to be obtained via HTTP headers. Called from the 
43340:   // state machine thread to set the duration if it is obtained from the
43340:   // media metadata. The decoder monitor must be obtained before calling this.
68450:   // aDuration is in microseconds.
41387:   virtual void SetDuration(PRInt64 aDuration) = 0;
41387: 
69475:   // Called while decoding metadata to set the end time of the media
69475:   // resource. The decoder monitor must be obtained before calling this.
69475:   // aEndTime is in microseconds.
69475:   virtual void SetEndTime(PRInt64 aEndTime) = 0;
69475: 
77175:   // Set the media fragment end time. aEndTime is in microseconds.
77175:   virtual void SetFragmentEndTime(PRInt64 aEndTime) = 0;
77175: 
41387:   // Functions used by assertions to ensure we're calling things
41387:   // on the appropriate threads.
79445:   virtual bool OnDecodeThread() const = 0;
41387: 
79547:   // Returns true if the current thread is the state machine thread.
79445:   virtual bool OnStateMachineThread() const = 0;
73701: 
41387:   virtual nsHTMLMediaElement::NextFrameStatus GetNextFrameStatus() = 0;
41387: 
41387:   // Cause state transitions. These methods obtain the decoder monitor
41387:   // to synchronise the change of state, and to notify other threads
41387:   // that the state has changed.
63623:   virtual void Play() = 0;
41387: 
41387:   // Seeks to aTime in seconds
60727:   virtual void Seek(double aTime) = 0;
41387: 
41387:   // Returns the current playback position in seconds.
41387:   // Called from the main thread to get the current frame time. The decoder
41387:   // monitor must be obtained before calling this.
63622:   virtual double GetCurrentTime() const = 0;
41387: 
41387:   // Clear the flag indicating that a playback position change event
41387:   // is currently queued. This is called from the main thread and must
41387:   // be called with the decode monitor held.
41387:   virtual void ClearPositionChangeFlag() = 0;
41387: 
41387:   // Called from the main thread to set whether the media resource can
69475:   // seek into unbuffered ranges. The decoder monitor must be obtained
69475:   // before calling this.
79445:   virtual void SetSeekable(bool aSeekable) = 0;
41954: 
79547:   // Returns true if the media resource can seek into unbuffered ranges,
69475:   // as set by SetSeekable(). The decoder monitor must be obtained before
69475:   // calling this.
79445:   virtual bool IsSeekable() = 0;
69475: 
41954:   // Update the playback position. This can result in a timeupdate event
41954:   // and an invalidate of the frame being dispatched asynchronously if
41954:   // there is no such event currently queued.
41954:   // Only called on the decoder thread. Must be called with
41954:   // the decode monitor held.
41954:   virtual void UpdatePlaybackPosition(PRInt64 aTime) = 0;
48104: 
51394:   virtual nsresult GetBuffered(nsTimeRanges* aBuffered) = 0;
48902: 
74548:   virtual PRInt64 VideoQueueMemoryInUse() = 0;
74548:   virtual PRInt64 AudioQueueMemoryInUse() = 0;
74548: 
53765:   virtual void NotifyDataArrived(const char* aBuffer, PRUint32 aLength, PRUint32 aOffset) = 0;
53765: 
48104:   // Causes the state machine to switch to buffering state, and to
48104:   // immediately stop playback and buffer downloaded data. Must be called
48104:   // with the decode monitor held. Called on the state machine thread and
48104:   // the main thread.
48104:   virtual void StartBuffering() = 0;
67873: 
67873:   // Sets the current size of the framebuffer used in MozAudioAvailable events.
67873:   // Called on the state machine thread and the main thread.
67873:   virtual void SetFrameBufferLength(PRUint32 aLength) = 0;
41387: };
41387: 
41387: class nsBuiltinDecoder : public nsMediaDecoder
41387: {
16300:   // ISupports
16300:   NS_DECL_ISUPPORTS
16300: 
16300:   // nsIObserver
16300:   NS_DECL_NSIOBSERVER
16300: 
16300:  public:
69142:   typedef mozilla::ReentrantMonitor ReentrantMonitor;
41954: 
20627:   // Enumeration for the valid play states (see mPlayState)
20627:   enum PlayState {
20627:     PLAY_STATE_START,
20627:     PLAY_STATE_LOADING,
20627:     PLAY_STATE_PAUSED,
20627:     PLAY_STATE_PLAYING,
20627:     PLAY_STATE_SEEKING,
20627:     PLAY_STATE_ENDED,
20627:     PLAY_STATE_SHUTDOWN
20627:   };
20627: 
41387:   nsBuiltinDecoder();
41387:   ~nsBuiltinDecoder();
32901:   
79445:   virtual bool Init(nsHTMLMediaElement* aElement);
20627: 
20627:   // This method must be called by the owning object before that
20627:   // object disposes of this decoder object.
21079:   virtual void Shutdown();
16300:   
60727:   virtual double GetCurrentTime();
16300: 
32900:   virtual nsresult Load(nsMediaStream* aStream,
54993:                         nsIStreamListener** aListener,
54993:                         nsMediaDecoder* aCloneDonor);
16300: 
41387:   virtual nsDecoderStateMachine* CreateStateMachine() = 0;
41387: 
16300:   // Start playback of a video. 'Load' must have previously been
16300:   // called.
21079:   virtual nsresult Play();
16300: 
16300:   // Seek to the time position in (seconds) from the start of the video.
60727:   virtual nsresult Seek(double aTime);
16300: 
21079:   virtual nsresult PlaybackRateChanged();
16300: 
21079:   virtual void Pause();
60727:   virtual void SetVolume(double aVolume);
60727:   virtual double GetDuration();
16300: 
79445:   virtual void SetInfinite(bool aInfinite);
79445:   virtual bool IsInfinite();
74647: 
32898:   virtual nsMediaStream* GetCurrentStream();
26836:   virtual already_AddRefed<nsIPrincipal> GetCurrentPrincipal();
16300: 
26836:   virtual void NotifySuspendedStatusChanged();
26836:   virtual void NotifyBytesDownloaded();
24721:   virtual void NotifyDownloadEnded(nsresult aStatus);
40132:   // Called by the decode thread to keep track of the number of bytes read
40132:   // from the resource.
26836:   void NotifyBytesConsumed(PRInt64 aBytes);
16300: 
20627:   // Called when the video file has completed downloading.
20627:   // Call on the main thread only.
20627:   void ResourceLoaded();
20627: 
21394:   // Called if the media file encounters a network error.
21394:   // Call on the main thread only.
21756:   virtual void NetworkError();
21394: 
79547:   // Call from any thread safely. Return true if we are currently
20627:   // seeking in the media resource.
79445:   virtual bool IsSeeking() const;
20627: 
79547:   // Return true if the decoder has reached the end of playback.
22783:   // Call on the main thread only.
79445:   virtual bool IsEnded() const;
22783: 
68450:   // Set the duration of the media resource in units of seconds.
24775:   // This is called via a channel listener if it can pick up the duration
24775:   // from a content header. Must be called from the main thread only.
68450:   virtual void SetDuration(double aDuration);
24775: 
21542:   // Set a flag indicating whether seeking is supported
79445:   virtual void SetSeekable(bool aSeekable);
21542: 
79547:   // Return true if seeking is supported.
79445:   virtual bool IsSeekable();
75108: 
75108:   virtual nsresult GetSeekable(nsTimeRanges* aSeekable);
21542: 
77175:   // Set the end time of the media resource. When playback reaches
77175:   // this point the media pauses. aTime is in seconds.
77175:   virtual void SetEndTime(double aTime);
77175: 
24721:   virtual Statistics GetStatistics();
24721: 
24020:   // Suspend any media downloads that are in progress. Called by the
24020:   // media element when it is sent to the bfcache. Call on the main
24020:   // thread only.
24020:   virtual void Suspend();
24020: 
24020:   // Resume any media downloads that have been suspended. Called by the
24020:   // media element when it is restored from the bfcache. Call on the
24020:   // main thread only.
79445:   virtual void Resume(bool aForceBuffering);
24020: 
27217:   // Tells our nsMediaStream to put all loads in the background.
27217:   virtual void MoveLoadsToBackground();
27217: 
54997:   void AudioAvailable(float* aFrameBuffer, PRUint32 aFrameBufferLength, float aTime);
51477: 
40132:   // Called by the state machine to notify the decoder that the duration
40132:   // has changed.
40132:   void DurationChanged();
40132: 
79445:   bool OnStateMachineThread() const;
41387: 
79445:   bool OnDecodeThread() const {
41387:     return mDecoderStateMachine->OnDecodeThread();
41387:   }
19675: 
20627:   // Returns the monitor for other threads to synchronise access to
21756:   // state.
69142:   ReentrantMonitor& GetReentrantMonitor() { 
69142:     return mReentrantMonitor; 
20627:   }
19675: 
48902:   // Constructs the time ranges representing what segments of the media
48902:   // are buffered and playable.
51394:   virtual nsresult GetBuffered(nsTimeRanges* aBuffered) {
64405:     if (mDecoderStateMachine) {
48902:       return mDecoderStateMachine->GetBuffered(aBuffered);
48902:     }
64405:     return NS_ERROR_FAILURE;
64405:   }
48902: 
74548:   virtual PRInt64 VideoQueueMemoryInUse() {
74548:     if (mDecoderStateMachine) {
74548:       return mDecoderStateMachine->VideoQueueMemoryInUse();
74548:     }
74548:     return 0;
74548:   }
74548: 
74548:   virtual PRInt64 AudioQueueMemoryInUse() {
74548:     if (mDecoderStateMachine) {
74548:       return mDecoderStateMachine->AudioQueueMemoryInUse();
74548:     }
74548:     return 0;
74548:   }
74548: 
53765:   virtual void NotifyDataArrived(const char* aBuffer, PRUint32 aLength, PRUint32 aOffset) {
82045:     if (mDecoderStateMachine) {
82045:       mDecoderStateMachine->NotifyDataArrived(aBuffer, aLength, aOffset);
82045:     }
53765:   }
53765: 
67873:   // Sets the length of the framebuffer used in MozAudioAvailable events.
67873:   // The new size must be between 512 and 16384.
67873:   virtual nsresult RequestFrameBufferLength(PRUint32 aLength);
67873: 
41387:  public:
21756:   // Return the current state. Can be called on any thread. If called from
21756:   // a non-main thread, the decoder monitor must be held.
40132:   PlayState GetState() {
20627:     return mPlayState;
20627:   }
16300: 
23763:   // Stop updating the bytes downloaded for progress notifications. Called
23763:   // when seeking to prevent wild changes to the progress notification.
23763:   // Must be called with the decoder monitor held.
23763:   void StopProgressUpdates();
23763: 
23763:   // Allow updating the bytes downloaded for progress notifications. Must
23763:   // be called with the decoder monitor held.
23763:   void StartProgressUpdates();
23763: 
26836:   // Something has changed that could affect the computed playback rate,
26836:   // so recompute it. The monitor must be held.
26836:   void UpdatePlaybackRate();
26836: 
26836:   // The actual playback rate computation. The monitor must be held.
79445:   double ComputePlaybackRate(bool* aReliable);
26836: 
41954:   // Make the decoder state machine update the playback position. Called by
41954:   // the reader on the decoder thread (Assertions for this checked by 
41954:   // mDecoderStateMachine). This must be called with the decode monitor
41954:   // held.
41954:   void UpdatePlaybackPosition(PRInt64 aTime)
41954:   {
41954:     mDecoderStateMachine->UpdatePlaybackPosition(aTime);
41954:   }
41954: 
16300:   /****** 
16300:    * The following methods must only be called on the main
16300:    * thread.
16300:    ******/
16300: 
21756:   // Change to a new play state. This updates the mState variable and
21756:   // notifies any thread blocking on this object's monitor of the
21756:   // change. Call on the main thread only.
21756:   void ChangeState(PlayState aState);
21756: 
41954:   // Called when the metadata from the media file has been read.
16300:   // Call on the main thread only.
51477:   void MetadataLoaded(PRUint32 aChannels,
67873:                       PRUint32 aRate);
16300: 
16300:   // Called when the first frame has been loaded.
16300:   // Call on the main thread only.
16300:   void FirstFrameLoaded();
16300: 
16300:   // Called when the video has completed playing.
16300:   // Call on the main thread only.
20627:   void PlaybackEnded();
16300: 
20627:   // Seeking has stopped. Inform the element on the main
20627:   // thread.
20627:   void SeekingStopped();
20627: 
28857:   // Seeking has stopped at the end of the resource. Inform the element on the main
28857:   // thread.
28857:   void SeekingStoppedAtEnd();
28857: 
20627:   // Seeking has started. Inform the element on the main
20627:   // thread.
20627:   void SeekingStarted();
20627: 
20776:   // Called when the backend has changed the current playback
20776:   // position. It dispatches a timeupdate event and invalidates the frame.
20776:   // This must be called on the main thread only.
20776:   void PlaybackPositionChanged();
20776: 
39441:   // Calls mElement->UpdateReadyStateForData, telling it which state we have
39441:   // entered.  Main thread only.
39441:   void NextFrameUnavailableBuffering();
39441:   void NextFrameAvailable();
39441:   void NextFrameUnavailable();
39441: 
24919:   // Calls mElement->UpdateReadyStateForData, telling it whether we have
24919:   // data for the next frame and if we're buffering. Main thread only.
24919:   void UpdateReadyStateForData();
24919: 
26836:   // Find the end of the cached data starting at the current decoder
26836:   // position.
26836:   PRInt64 GetDownloadPosition();
26836: 
41391:   // Updates the approximate byte offset which playback has reached. This is
41391:   // used to calculate the readyState transitions.
41391:   void UpdatePlaybackOffset(PRInt64 aOffset);
41391: 
41954:   // Provide access to the state machine object
41954:   nsDecoderStateMachine* GetStateMachine() { return mDecoderStateMachine; }
41954: 
41954:   // Return the current decode state. The decoder monitor must be
41954:   // obtained before calling this.
41954:   nsDecoderStateMachine::State GetDecodeState() { return mDecoderStateMachine->GetState(); }
41954: 
78619:   // Drop reference to state machine.  Only called during shutdown dance.
78619:   void ReleaseStateMachine() { mDecoderStateMachine = nsnull; }
78619: 
41387: public:
32934:   // Notifies the element that decoding has failed.
32934:   void DecodeError();
32934: 
73701:   // Schedules the state machine to run one cycle on the shared state
73701:   // machine thread. Main thread only.
73701:   nsresult ScheduleStateMachineThread();
73700: 
16300:   /******
24721:    * The following members should be accessed with the decoder lock held.
16300:    ******/
24721: 
24721:   // Current decoding position in the stream. This is where the decoder
26836:   // is up to consuming the stream. This is not adjusted during decoder
26836:   // seek operations, but it's updated at the end when we start playing
26836:   // back again.
24721:   PRInt64 mDecoderPosition;
24721:   // Current playback position in the stream. This is (approximately)
26836:   // where we're up to playing back the stream. This is not adjusted
26836:   // during decoder seek operations, but it's updated at the end when we
26836:   // start playing back again.
24721:   PRInt64 mPlaybackPosition;
24721:   // Data needed to estimate playback data rate. The timeline used for
24721:   // this estimate is "decode time" (where the "current time" is the
24721:   // time of the last decoded video frame).
26836:   nsChannelStatistics mPlaybackStatistics;
16300: 
20776:   // The current playback position of the media resource in units of
20776:   // seconds. This is updated approximately at the framerate of the
20776:   // video (if it is a video) or the callback period of the audio.
20776:   // It is read and written from the main thread only.
60727:   double mCurrentTime;
20776: 
20627:   // Volume that playback should start at.  0.0 = muted. 1.0 = full
40132:   // volume.  Readable/Writeable from the main thread.
60727:   double mInitialVolume;
16300: 
20627:   // Position to seek to when the seek notification is received by the
40132:   // decode thread. Written by the main thread and read via the
69142:   // decode thread. Synchronised using mReentrantMonitor. If the
20627:   // value is negative then no seek has been requested. When a seek is
20627:   // started this is reset to negative.
60727:   double mRequestedSeekTime;
19690: 
21542:   // Duration of the media resource. Set to -1 if unknown.
41954:   // Set when the metadata is loaded. Accessed on the main thread
21542:   // only.
21542:   PRInt64 mDuration;
21542: 
21542:   // True if the media resource is seekable (server supports byte range
21542:   // requests).
79445:   bool mSeekable;
21542: 
16300:   /******
16300:    * The following member variables can be accessed from any thread.
16300:    ******/
16300: 
40132:   // The state machine object for handling the decoding. It is safe to
40132:   // call methods of this object from other threads. Its internal data
40132:   // is synchronised on a monitor. The lifetime of this object is
40132:   // after mPlayState is LOADING and before mPlayState is SHUTDOWN. It
40132:   // is safe to access it during this period.
41387:   nsCOMPtr<nsDecoderStateMachine> mDecoderStateMachine;
16300: 
40132:   // Stream of media data.
40132:   nsAutoPtr<nsMediaStream> mStream;
16300: 
69142:   // ReentrantMonitor for detecting when the video play state changes. A call
20627:   // to Wait on this monitor will block the thread until the next
20627:   // state change.
69142:   ReentrantMonitor mReentrantMonitor;
16300: 
20627:   // Set to one of the valid play states. It is protected by the
69142:   // monitor mReentrantMonitor. This monitor must be acquired when reading or
20627:   // writing the state. Any change to the state on the main thread
20627:   // must call NotifyAll on the monitor so the decode thread can wake up.
20627:   PlayState mPlayState;
16300: 
21756:   // The state to change to after a seek or load operation. It must only
21756:   // be changed from the main thread. The decoder monitor must be acquired
21756:   // when writing to the state, or when reading from a non-main thread.
21756:   // Any change to the state must call NotifyAll on the monitor.
20627:   PlayState mNextState;	
23763: 
24721:   // True when we have fully loaded the resource and reported that
24721:   // to the element (i.e. reached NETWORK_LOADED state).
24721:   // Accessed on the main thread only.
79445:   bool mResourceLoaded;
23763: 
23763:   // True when seeking or otherwise moving the play position around in
23763:   // such a manner that progress event data is inaccurate. This is set
24721:   // during seek and duration operations to prevent the progress indicator
23763:   // from jumping around. Read/Write from any thread. Must have decode monitor
23763:   // locked before accessing.
79445:   bool mIgnoreProgressData;
74647: 
79547:   // True if the stream is infinite (e.g. a webradio).
79445:   bool mInfiniteStream;
16300: };
16300: 
16300: #endif
