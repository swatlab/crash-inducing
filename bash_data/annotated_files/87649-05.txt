    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set tw=80 expandtab softtabstop=2 ts=2 sw=2: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
77154:  *   Mats Palmgren <matspal@gmail.com>
71265:  *   Ms2ger <ms2ger@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
80467: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nscore.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIAtom.h"
    1: #include "nsIContentViewer.h"
63693: #include "mozilla/css/StyleRule.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDocumentEncoder.h"
    1: #include "nsIDOMHTMLBodyElement.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMDocumentFragment.h"
81041: #include "nsIDOMHTMLElement.h"
75019: #include "nsIDOMHTMLMenuElement.h"
    1: #include "nsIDOMElementCSSInlineStyle.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIDOMDocument.h"
72328: #include "nsEventListenerManager.h"
    1: #include "nsMappedAttributes.h"
    1: #include "nsHTMLStyleSheet.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsILink.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIStyleRule.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsEscape.h"
    1: #include "nsIFrame.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
82843: #include "nsIWidget.h"
    1: #include "nsRange.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIDocShell.h"
29018: #include "nsIDocShellTreeItem.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsDOMError.h"
    1: #include "nsScriptLoader.h"
    1: #include "nsRuleData.h"
    1: 
    1: #include "nsPresState.h"
    1: #include "nsILayoutHistoryState.h"
    1: 
    1: #include "nsHTMLParts.h"
    1: #include "nsContentUtils.h"
    1: #include "nsString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsGkAtoms.h"
68780: #include "nsEventStateManager.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsDOMCSSDeclaration.h"
    1: #include "nsITextControlFrame.h"
    1: #include "nsIForm.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIDOMHTMLFormElement.h"
34395: #include "nsHTMLFormElement.h"
29018: #include "nsFocusManager.h"
    1: 
    1: #include "nsMutationEvent.h"
    1: 
    1: #include "nsContentCID.h"
    1: 
70158: #include "nsDOMStringMap.h"
70158: 
    1: #include "nsIEditor.h"
    1: #include "nsIEditorIMESupport.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsContentCreatorFunctions.h"
14228: #include "mozAutoDocUpdate.h"
41754: #include "nsHtml5Module.h"
43129: #include "nsITextControlElement.h"
47801: #include "mozilla/dom/Element.h"
54346: #include "nsHTMLFieldSetElement.h"
75019: #include "nsHTMLMenuElement.h"
84833: #include "nsAsyncDOMEvent.h"
82583: #include "nsIScriptError.h"
47801: 
70840: #include "mozilla/Preferences.h"
82125: #include "mozilla/dom/FromParser.h"
70840: 
70840: using namespace mozilla;
47801: using namespace mozilla::dom;
    1: 
42460: #include "nsThreadUtils.h"
42460: 
    1: class nsINodeInfo;
    1: class nsIDOMNodeList;
    1: class nsRuleWalker;
    1: 
    1: // XXX todo: add in missing out-of-memory checks
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: #ifdef GATHER_ELEMENT_USEAGE_STATISTICS
    1: 
    1: // static objects that have constructors are kinda bad, but we don't
    1: // care here, this is only debugging code!
    1: 
    1: static nsHashtable sGEUS_ElementCounts;
    1: 
    1: void GEUS_ElementCreated(nsINodeInfo *aNodeInfo)
    1: {
    1:   nsAutoString name;
69362:   aNodeInfo->GetName(name);
    1: 
    1:   nsStringKey key(name);
    1: 
    1:   PRInt32 count = (PRInt32)sGEUS_ElementCounts.Get(&key);
    1: 
    1:   count++;
    1: 
    1:   sGEUS_ElementCounts.Put(&key, (void *)count);
    1: }
    1: 
79445: bool GEUS_enum_func(nsHashKey *aKey, void *aData, void *aClosure)
    1: {
    1:   const PRUnichar *name_chars = ((nsStringKey *)aKey)->GetString();
    1:   NS_ConvertUTF16toUTF8 name(name_chars);
    1: 
    1:   printf ("%s %d\n", name.get(), aData);
    1: 
80486:   return true;
    1: }
    1: 
    1: void GEUS_DumpElementCounts()
    1: {
    1:   printf ("Element count statistics:\n");
    1: 
    1:   sGEUS_ElementCounts.Enumerate(GEUS_enum_func, nsnull);
    1: 
    1:   printf ("End of element count statistics:\n");
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::Init(nsINodeInfo *aNodeInfo)
    1: {
    1:   GEUS_ElementCreated(aNodeInfo);
    1: 
 4306:   return nsGenericHTMLElementBase::Init(aNodeInfo);
    1: }
    1: 
    1: #endif
    1: 
42460: /**
42460:  * nsAutoFocusEvent is used to dispatch a focus event when a
42460:  * nsGenericHTMLFormElement is binded to the tree with the autofocus attribute
42460:  * enabled.
42460:  */
42460: class nsAutoFocusEvent : public nsRunnable
42460: {
42460: public:
42460:   nsAutoFocusEvent(nsGenericHTMLFormElement* aElement) : mElement(aElement) {}
42460: 
42460:   NS_IMETHOD Run() {
42460:     nsFocusManager* fm = nsFocusManager::GetFocusManager();
42460:     if (!fm) {
42460:       return NS_ERROR_NULL_POINTER;
42460:     }
42460: 
80526:     nsIDocument* document = mElement->OwnerDoc();
42460: 
42460:     nsPIDOMWindow* window = document->GetWindow();
59587:     if (!window) {
59587:       return NS_OK;
59587:     }
59450: 
59450:     // Trying to found the top window (equivalent to window.top).
59450:     nsCOMPtr<nsIDOMWindow> top;
59450:     window->GetTop(getter_AddRefs(top));
59450:     if (top) {
59450:       window = static_cast<nsPIDOMWindow*>(top.get());
59450:     }
59450: 
59587:     if (window->GetFocusedNode()) {
59587:       return NS_OK;
59587:     }
59587: 
59451:     nsCOMPtr<nsIDocument> topDoc = do_QueryInterface(window->GetExtantDocument());
59451:     if (topDoc && topDoc->GetReadyStateEnum() == nsIDocument::READYSTATE_COMPLETE) {
59451:       return NS_OK;
59451:     }
59451: 
42460:     // If something is focused in the same document, ignore autofocus.
42460:     if (!fm->GetFocusedContent() ||
80526:         fm->GetFocusedContent()->OwnerDoc() != document) {
42460:       return mElement->Focus();
42460:     }
42460: 
42460:     return NS_OK;
42460:   }
42460: private:
42460:   // NOTE: nsGenericHTMLFormElement is saved as a nsGenericHTMLElement
42460:   // because AddRef/Release are ambiguous with nsGenericHTMLFormElement
42460:   // and Focus() is declared (and defined) in nsGenericHTMLElement class.
42460:   nsRefPtr<nsGenericHTMLElement> mElement;
42460: };
    1: 
81041: class nsGenericHTMLElementTearoff : public nsIDOMElementCSSInlineStyle
12033: {
12033:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
12033: 
12033:   nsGenericHTMLElementTearoff(nsGenericHTMLElement *aElement)
12033:     : mElement(aElement)
12033:   {
12033:   }
12033: 
12033:   virtual ~nsGenericHTMLElementTearoff()
12033:   {
12033:   }
12033: 
48944:   NS_IMETHOD GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
48944:   {
48944:     nsresult rv;
48944:     *aStyle = mElement->GetStyle(&rv);
48944:     NS_ENSURE_SUCCESS(rv, rv);
48944:     NS_ADDREF(*aStyle);
48944:     return NS_OK;
48944:   }
12033: 
12033:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsGenericHTMLElementTearoff,
81041:                                            nsIDOMElementCSSInlineStyle)
12033: 
12033: private:
48449:   nsRefPtr<nsGenericHTMLElement> mElement;
12033: };
12033: 
    1: NS_IMPL_CYCLE_COLLECTION_1(nsGenericHTMLElementTearoff, mElement)
    1: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsGenericHTMLElementTearoff)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsGenericHTMLElementTearoff)
    1: 
 4838: NS_INTERFACE_TABLE_HEAD(nsGenericHTMLElementTearoff)
81041:   NS_INTERFACE_TABLE_INHERITED1(nsGenericHTMLElementTearoff,
 4838:                                 nsIDOMElementCSSInlineStyle)
 4838:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsGenericHTMLElementTearoff)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mElement)
    1: 
    1: 
56074: NS_IMPL_INT_ATTR_DEFAULT_VALUE(nsGenericHTMLElement, TabIndex, tabindex, -1)
48696: NS_IMPL_BOOL_ATTR(nsGenericHTMLElement, Hidden, hidden)
    1: 
    1: nsresult
    1: nsGenericHTMLElement::DOMQueryInterface(nsIDOMHTMLElement *aElement,
    1:                                         REFNSIID aIID, void **aInstancePtr)
    1: {
 3114:   NS_PRECONDITION(aInstancePtr, "null out param");
 3114: 
 4838:   nsresult rv = NS_ERROR_FAILURE;
 4838: 
 4838:   NS_INTERFACE_TABLE_BEGIN
 4838:     NS_INTERFACE_TABLE_ENTRY(nsIDOMHTMLElement, nsIDOMNode)
 4838:     NS_INTERFACE_TABLE_ENTRY(nsIDOMHTMLElement, nsIDOMElement)
 4838:     NS_INTERFACE_TABLE_ENTRY(nsIDOMHTMLElement, nsIDOMHTMLElement)
 4838:   NS_INTERFACE_TABLE_END_WITH_PTR(aElement)
 4838: 
 4838:   NS_INTERFACE_TABLE_TO_MAP_SEGUE
 4838:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMElementCSSInlineStyle,
 4838:                                  new nsGenericHTMLElementTearoff(this))
 4838:   NS_INTERFACE_MAP_END
 4838: 
48696: // No closing bracket, because NS_INTERFACE_MAP_END does that for us.
    1: 
    1: nsresult
    1: nsGenericHTMLElement::CopyInnerTo(nsGenericElement* aDst) const
    1: {
    1:   nsresult rv;
    1:   PRInt32 i, count = GetAttrCount();
    1:   for (i = 0; i < count; ++i) {
    1:     const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
    1:     const nsAttrValue *value = mAttrsAndChildren.AttrAt(i);
    1:     if (name->Equals(nsGkAtoms::style, kNameSpaceID_None) &&
    1:         value->Type() == nsAttrValue::eCSSStyleRule) {
    1:       // We can't just set this as a string, because that will fail
    1:       // to reparse the string into style data until the node is
69440:       // inserted into the document.  Clone the Rule instead.
69440:       nsRefPtr<mozilla::css::Rule> ruleClone = value->GetCSSStyleRuleValue()->Clone();
63693:       nsRefPtr<mozilla::css::StyleRule> styleRule = do_QueryObject(ruleClone);
    1:       NS_ENSURE_TRUE(styleRule, NS_ERROR_UNEXPECTED);
    1: 
80486:       rv = aDst->SetInlineStyleRule(styleRule, false);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       continue;
    1:     }
    1: 
    1:     nsAutoString valStr;
    1:     value->ToString(valStr);
    1:     rv = aDst->SetAttr(name->NamespaceID(), name->LocalName(),
80486:                        name->GetPrefix(), valStr, false);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericHTMLElement::SetAttribute(const nsAString& aName,
    1:                                    const nsAString& aValue)
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1: 
    1:   if (!name) {
80486:     nsresult rv = nsContentUtils::CheckQName(aName, false);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIAtom> nameAtom;
29004:     if (IsInHTMLDocument()) {
    1:       nsAutoString lower;
38422:       nsContentUtils::ASCIIToLower(aName, lower);
    1:       nameAtom = do_GetAtom(lower);
    1:     }
    1:     else {
    1:       nameAtom = do_GetAtom(aName);
    1:     }
    1:     NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
80486:     return SetAttr(kNameSpaceID_None, nameAtom, aValue, true);
    1:   }
    1: 
    1:   return SetAttr(name->NamespaceID(), name->LocalName(), name->GetPrefix(),
80486:                  aValue, true);
    1: }
    1: 
70158: nsresult
70158: nsGenericHTMLElement::GetDataset(nsIDOMDOMStringMap** aDataset)
70158: {
70158:   nsDOMSlots *slots = DOMSlots();
70158: 
70158:   if (!slots->mDataset) {
70158:     // mDataset is a weak reference so assignment will not AddRef.
70158:     // AddRef is called before assigning to out parameter.
70158:     slots->mDataset = new nsDOMStringMap(this);
70158:   }
70158: 
70158:   NS_ADDREF(*aDataset = slots->mDataset);
70158:   return NS_OK;
70158: }
70158: 
70158: nsresult
70158: nsGenericHTMLElement::ClearDataset()
70158: {
70158:   nsDOMSlots *slots = GetExistingDOMSlots();
70158: 
70158:   NS_ASSERTION(slots && slots->mDataset,
70158:                "Slots should exist and dataset should not be null.");
70158:   slots->mDataset = nsnull;
70158: 
70158:   return NS_OK;
70158: }
70158: 
    1: // Implementation for nsIDOMHTMLElement
    1: nsresult
    1: nsGenericHTMLElement::GetId(nsAString& aId)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::id, aId);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetId(const nsAString& aId)
    1: {
80486:   SetAttr(kNameSpaceID_None, nsGkAtoms::id, aId, true);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetTitle(nsAString& aTitle)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::title, aTitle);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetTitle(const nsAString& aTitle)
    1: {
80486:   SetAttr(kNameSpaceID_None, nsGkAtoms::title, aTitle, true);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetLang(nsAString& aLang)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::lang, aLang);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetLang(const nsAString& aLang)
    1: {
80486:   SetAttr(kNameSpaceID_None, nsGkAtoms::lang, aLang, true);
    1:   return NS_OK;
    1: }
    1: 
    1: static const nsAttrValue::EnumTable kDirTable[] = {
    1:   { "ltr", NS_STYLE_DIRECTION_LTR },
    1:   { "rtl", NS_STYLE_DIRECTION_RTL },
    1:   { 0 }
    1: };
    1: 
71265: NS_IMPL_ENUM_ATTR_DEFAULT_VALUE(nsGenericHTMLElement, Dir, dir, NULL)
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetClassName(nsAString& aClassName)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::_class, aClassName);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetClassName(const nsAString& aClassName)
    1: {
80486:   SetAttr(kNameSpaceID_None, nsGkAtoms::_class, aClassName, true);
    1:   return NS_OK;
    1: }
    1: 
67818: NS_IMPL_STRING_ATTR(nsGenericHTMLElement, AccessKey, accesskey)
67818: 
74612: NS_IMETHODIMP
74612: nsGenericHTMLElement::GetAccessKeyLabel(nsAString& aLabel)
74612: {
74612:   nsPresContext *presContext = GetPresContext();
74612: 
74612:   if (presContext &&
74612:     presContext->EventStateManager()->GetAccessKeyLabelPrefix(aLabel)) {
74612:       nsAutoString suffix;
74612:       GetAccessKey(suffix);
74612:       aLabel.Append(suffix);
74612:   }
74612: 
74612:   return NS_OK;
74612: }
74612: 
79445: static bool IS_TABLE_CELL(nsIAtom* frameType) {
 2370:   return nsGkAtoms::tableCellFrame == frameType ||
 2370:     nsGkAtoms::bcTableCellFrame == frameType;
 2370: }
 2370: 
79445: static bool
 2370: IsOffsetParent(nsIFrame* aFrame)
    1: {
 2370:   nsIAtom* frameType = aFrame->GetType();
 2370:   return (IS_TABLE_CELL(frameType) ||
 2370:           frameType == nsGkAtoms::tableFrame);
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::GetOffsetRect(nsRect& aRect, nsIContent** aOffsetParent)
    1: {
    1:   *aOffsetParent = nsnull;
16722:   aRect = nsRect();
16722: 
16722:   nsIFrame* frame = GetStyledFrame();
    1:   if (!frame) {
    1:     return;
    1:   }
    1: 
    1:   nsIFrame* parent = frame->GetParent();
    1:   nsPoint origin(0, 0);
    1: 
87317:   if (parent && parent->GetType() == nsGkAtoms::tableOuterFrame &&
87317:       frame->GetType() == nsGkAtoms::tableFrame) {
    1:     origin = parent->GetPositionIgnoringScrolling();
    1:     parent = parent->GetParent();
    1:   }
    1: 
41634:   Element* docElement = GetCurrentDoc()->GetRootElement();
    1:   nsIContent* content = frame->GetContent();
    1: 
82292:   if (content && (content->IsHTML(nsGkAtoms::body) || content == docElement)) {
    1:     parent = frame;
    1:   }
    1:   else {
79445:     const bool isPositioned = frame->GetStyleDisplay()->IsPositioned();
79445:     const bool isAbsolutelyPositioned =
    1:       frame->GetStyleDisplay()->IsAbsolutelyPositioned();
    1:     origin += frame->GetPositionIgnoringScrolling();
    1: 
    1:     for ( ; parent ; parent = parent->GetParent()) {
    1:       content = parent->GetContent();
    1: 
    1:       // Stop at the first ancestor that is positioned.
    1:       if (parent->GetStyleDisplay()->IsPositioned()) {
    1:         *aOffsetParent = content;
    1:         NS_IF_ADDREF(*aOffsetParent);
    1:         break;
    1:       }
    1: 
    1:       // Add the parent's origin to our own to get to the
    1:       // right coordinate system.
79445:       const bool isOffsetParent = !isPositioned && IsOffsetParent(parent);
 2370:       if (!isAbsolutelyPositioned && !isOffsetParent) {
    1:         origin += parent->GetPositionIgnoringScrolling();
    1:       }
    1: 
    1:       if (content) {
    1:         // If we've hit the document element, break here.
    1:         if (content == docElement) {
    1:           break;
    1:         }
    1: 
 2705:         // Break if the ancestor frame type makes it suitable as offset parent
 2705:         // and this element is *not* positioned or if we found the body element.
82292:         if (isOffsetParent || content->IsHTML(nsGkAtoms::body)) {
    1:           *aOffsetParent = content;
    1:           NS_ADDREF(*aOffsetParent);
    1:           break;
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (isAbsolutelyPositioned && !*aOffsetParent) {
    1:       // If this element is absolutely positioned, but we don't have
    1:       // an offset parent it means this element is an absolutely
    1:       // positioned child that's not nested inside another positioned
    1:       // element, in this case the element's frame's parent is the
    1:       // frame for the HTML element so we fail to find the body in the
    1:       // parent chain. We want the offset parent in this case to be
    1:       // the body, so we just get the body element from the document.
    1: 
    1:       nsCOMPtr<nsIDOMHTMLDocument> html_doc(do_QueryInterface(GetCurrentDoc()));
    1: 
    1:       if (html_doc) {
    1:         nsCOMPtr<nsIDOMHTMLElement> html_element;
    1:         html_doc->GetBody(getter_AddRefs(html_element));
    1:         if (html_element) {
    1:           CallQueryInterface(html_element, aOffsetParent);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Subtract the parent border unless it uses border-box sizing.
    1:   if (parent &&
    1:       parent->GetStylePosition()->mBoxSizing != NS_STYLE_BOX_SIZING_BORDER) {
    1:     const nsStyleBorder* border = parent->GetStyleBorder();
15992:     origin.x -= border->GetActualBorderWidth(NS_SIDE_LEFT);
15992:     origin.y -= border->GetActualBorderWidth(NS_SIDE_TOP);
    1:   }
    1: 
    1:   // XXX We should really consider subtracting out padding for
    1:   // content-box sizing, but we should see what IE does....
    1: 
    1:   // Convert to pixels.
    1:   aRect.x = nsPresContext::AppUnitsToIntCSSPixels(origin.x);
    1:   aRect.y = nsPresContext::AppUnitsToIntCSSPixels(origin.y);
12349: 
12349:   // Get the union of all rectangles in this and continuation frames.
12349:   // It doesn't really matter what we use as aRelativeTo here, since
14186:   // we only care about the size. We just have to use something non-null.
14186:   nsRect rcFrame = nsLayoutUtils::GetAllInFlowRectsUnion(frame, frame);
    1:   aRect.width = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.width);
    1:   aRect.height = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.height);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetTop(PRInt32* aOffsetTop)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   *aOffsetTop = rcFrame.y;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetLeft(PRInt32* aOffsetLeft)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   *aOffsetLeft = rcFrame.x;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetWidth(PRInt32* aOffsetWidth)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   *aOffsetWidth = rcFrame.width;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetHeight(PRInt32* aOffsetHeight)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   *aOffsetHeight = rcFrame.height;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetParent(nsIDOMElement** aOffsetParent)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   if (parent) {
    1:     CallQueryInterface(parent, aOffsetParent);
    1:   } else {
    1:     *aOffsetParent = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
82125: nsresult
82125: nsGenericHTMLElement::GetMarkup(bool aIncludeSelf, nsAString& aMarkup)
    1: {
82125:   aMarkup.Truncate();
    1: 
80526:   nsIDocument* doc = OwnerDoc();
    1: 
    1:   nsAutoString contentType;
29004:   if (IsInHTMLDocument()) {
    1:     contentType.AssignLiteral("text/html");
    1:   } else {
    1:     doc->GetContentType(contentType);
    1:   }
    1: 
46309:   nsCOMPtr<nsIDocumentEncoder> docEncoder = doc->GetCachedEncoder();
46309:   if (!docEncoder) {
    1:     docEncoder =
    1:       do_CreateInstance(PromiseFlatCString(
    1:         nsDependentCString(NS_DOC_ENCODER_CONTRACTID_BASE) +
    1:         NS_ConvertUTF16toUTF8(contentType)
    1:       ).get());
46309:   }
31946:   if (!(docEncoder || doc->IsHTML())) {
    1:     // This could be some type for which we create a synthetic document.  Try
    1:     // again as XML
    1:     contentType.AssignLiteral("application/xml");
    1:     docEncoder = do_CreateInstance(NS_DOC_ENCODER_CONTRACTID_BASE "application/xml");
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(docEncoder, NS_ERROR_FAILURE);
    1: 
82125:   nsresult rv = docEncoder->NativeInit(doc, contentType,
    1:                                        nsIDocumentEncoder::OutputEncodeBasicEntities |
    1:                                        // Output DOM-standard newlines
    1:                                        nsIDocumentEncoder::OutputLFLineBreak |
46309:                                        // Don't do linebreaking that's not present in
46309:                                        // the source
    1:                                        nsIDocumentEncoder::OutputRaw);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
82125:   if (aIncludeSelf) {
82125:     docEncoder->SetNativeNode(this);
82125:   } else {
46309:     docEncoder->SetNativeContainerNode(this);
82125:   }
82125:   rv = docEncoder->EncodeToString(aMarkup);
82125:   if (!aIncludeSelf) {
47922:     doc->SetCachedEncoder(docEncoder.forget());
82125:   }
46309:   return rv;
    1: }
    1: 
82125: nsresult
82125: nsGenericHTMLElement::GetInnerHTML(nsAString& aInnerHTML) {
82125:   return GetMarkup(false, aInnerHTML);
82125: }
82125: 
82125: NS_IMETHODIMP
82125: nsGenericHTMLElement::GetOuterHTML(nsAString& aOuterHTML) {
82125:   return GetMarkup(true, aOuterHTML);
82125: }
82125: 
74627: void
74627: nsGenericHTMLElement::FireMutationEventsForDirectParsing(nsIDocument* aDoc,
74627:                                                          nsIContent* aDest,
74627:                                                          PRInt32 aOldChildCount)
74627: {
74627:   // Fire mutation events. Optimize for the case when there are no listeners
74627:   PRInt32 newChildCount = aDest->GetChildCount();
74627:   if (newChildCount && nsContentUtils::
74627:         HasMutationListeners(aDoc, NS_EVENT_BITS_MUTATION_NODEINSERTED)) {
74627:     nsAutoTArray<nsCOMPtr<nsIContent>, 50> childNodes;
74627:     NS_ASSERTION(newChildCount - aOldChildCount >= 0,
74627:                  "What, some unexpected dom mutation has happened?");
74627:     childNodes.SetCapacity(newChildCount - aOldChildCount);
77283:     for (nsIContent* child = aDest->GetFirstChild();
77283:          child;
77283:          child = child->GetNextSibling()) {
77283:       childNodes.AppendElement(child);
74627:     }
74627:     nsGenericElement::FireNodeInserted(aDoc, aDest, childNodes);
74627:   }
74627: }
74627: 
81041: NS_IMETHODIMP
    1: nsGenericHTMLElement::SetInnerHTML(const nsAString& aInnerHTML)
    1: {
80526:   nsIDocument* doc = OwnerDoc();
41754: 
69573:   // Batch possible DOMSubtreeModified events.
69573:   mozAutoSubtreeModified subtree(doc, nsnull);
69573: 
69573:   FireNodeRemovedForChildren();
69573: 
74625:   // Needed when innerHTML is used in combination with contenteditable
80486:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, true);
    1: 
69573:   // Remove childnodes.
74804:   PRUint32 childCount = GetChildCount();
74804:   for (PRUint32 i = 0; i < childCount; ++i) {
80486:     RemoveChildAt(0, true);
69573:   }
    1: 
75206:   nsAutoScriptLoaderDisabler sld(doc);
75206:   
82125:   nsresult rv = NS_OK;
74622:   if (doc->IsHTML()) {
41754:     PRInt32 oldChildCount = GetChildCount();
80380:     rv = nsContentUtils::ParseFragmentHTML(aInnerHTML,
57561:                                            this,
57561:                                            Tag(),
57561:                                            GetNameSpaceID(),
57561:                                            doc->GetCompatibilityMode() ==
57561:                                              eCompatibility_NavQuirks,
80486:                                            true);
41754:     // HTML5 parser has notified, but not fired mutation events.
74627:     FireMutationEventsForDirectParsing(doc, this, oldChildCount);
41754:   } else {
82125:     nsCOMPtr<nsIDOMDocumentFragment> df;
74622:     rv = nsContentUtils::CreateContextualFragment(this, aInnerHTML,
80486:                                                   true,
    1:                                                   getter_AddRefs(df));
41240:     nsCOMPtr<nsINode> fragment = do_QueryInterface(df);
    1:     if (NS_SUCCEEDED(rv)) {
78082:       // Suppress assertion about node removal mutation events that can't have
78082:       // listeners anyway, because no one has had the chance to register mutation
78082:       // listeners on the fragment that comes from the parser.
78082:       nsAutoScriptBlockerSuppressNodeRemoved scriptBlocker;
78082: 
41240:       static_cast<nsINode*>(this)->AppendChild(fragment, &rv);
    1:     }
74623:   }
    1: 
    1:   return rv;
    1: }
    1: 
82125: NS_IMETHODIMP
82125: nsGenericHTMLElement::SetOuterHTML(const nsAString& aOuterHTML)
82125: {
82125:   nsINode* parent = GetNodeParent();
82125:   if (!parent) {
82125:     return NS_OK;
82125:   }
82125: 
82125:   if (parent->NodeType() == nsIDOMNode::DOCUMENT_NODE) {
82125:     return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
82125:   }
82125: 
82125:   if (OwnerDoc()->IsHTML()) {
82125:     nsIAtom* localName;
82125:     PRInt32 namespaceID;
82125:     if (parent->IsElement()) {
82125:       localName = static_cast<nsIContent*>(parent)->Tag();
82125:       namespaceID = static_cast<nsIContent*>(parent)->GetNameSpaceID();
82125:     } else {
82125:       NS_ASSERTION(parent->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE,
82125:         "How come the parent isn't a document, a fragment or an element?");
82125:       localName = nsGkAtoms::body;
82125:       namespaceID = kNameSpaceID_XHTML;
82125:     }
82125:     nsCOMPtr<nsIDOMDocumentFragment> df;
82125:     nsresult rv = NS_NewDocumentFragment(getter_AddRefs(df),
82125:                                          OwnerDoc()->NodeInfoManager());
82125:     NS_ENSURE_SUCCESS(rv, rv);
82125:     nsCOMPtr<nsIContent> fragment = do_QueryInterface(df);
82125:     nsContentUtils::ParseFragmentHTML(aOuterHTML,
82125:                                       fragment,
82125:                                       localName,
82125:                                       namespaceID,
82125:                                       OwnerDoc()->GetCompatibilityMode() ==
82125:                                         eCompatibility_NavQuirks,
82125:                                       PR_TRUE);
82125:     parent->ReplaceChild(fragment, this, &rv);
82125:     return rv;
82125:   }
82125: 
82125:   nsCOMPtr<nsINode> context;
82125:   if (parent->IsElement()) {
82125:     context = parent;
82125:   } else {
82125:     NS_ASSERTION(parent->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE,
82125:       "How come the parent isn't a document, a fragment or an element?");
82125:     nsCOMPtr<nsINodeInfo> info =
82125:       OwnerDoc()->NodeInfoManager()->GetNodeInfo(nsGkAtoms::body,
82125:                                                  nsnull,
82125:                                                  kNameSpaceID_XHTML,
82125:                                                  nsIDOMNode::ELEMENT_NODE);
82125:     context = NS_NewHTMLBodyElement(info.forget(), FROM_PARSER_FRAGMENT);
82125:   }
82125: 
82125:   nsCOMPtr<nsIDOMDocumentFragment> df;
82125:   nsresult rv = nsContentUtils::CreateContextualFragment(context,
82125:                                                          aOuterHTML,
82125:                                                          PR_TRUE,
82125:                                                          getter_AddRefs(df));
82125:   NS_ENSURE_SUCCESS(rv, rv);
82125:   nsCOMPtr<nsINode> fragment = do_QueryInterface(df);
82125:   parent->ReplaceChild(fragment, this, &rv);
82125:   return rv;
82125: }
82125: 
74627: enum nsAdjacentPosition {
74627:   eBeforeBegin,
74627:   eAfterBegin,
74627:   eBeforeEnd,
74627:   eAfterEnd
74627: };
74627: 
81041: NS_IMETHODIMP
74627: nsGenericHTMLElement::InsertAdjacentHTML(const nsAString& aPosition,
74627:                                          const nsAString& aText)
74627: {
74627:   nsAdjacentPosition position;
74627:   if (aPosition.LowerCaseEqualsLiteral("beforebegin")) {
74627:     position = eBeforeBegin;
74627:   } else if (aPosition.LowerCaseEqualsLiteral("afterbegin")) {
74627:     position = eAfterBegin;
74627:   } else if (aPosition.LowerCaseEqualsLiteral("beforeend")) {
74627:     position = eBeforeEnd;
74627:   } else if (aPosition.LowerCaseEqualsLiteral("afterend")) {
74627:     position = eAfterEnd;
74627:   } else {
74627:     return NS_ERROR_DOM_SYNTAX_ERR;
74627:   }
74627: 
74627:   nsCOMPtr<nsIContent> destination;
74627:   if (position == eBeforeBegin || position == eAfterEnd) {
74627:     destination = GetParent();
74627:     if (!destination) {
74627:       return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
74627:     }
74627:   } else {
74627:     destination = this;
74627:   }
74627: 
80526:   nsIDocument* doc = OwnerDoc();
74627: 
75206:   // Needed when insertAdjacentHTML is used in combination with contenteditable
80486:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, true);
75206:   nsAutoScriptLoaderDisabler sld(doc);
75206:   
74627:   // Batch possible DOMSubtreeModified events.
74627:   mozAutoSubtreeModified subtree(doc, nsnull);
74627: 
80380:   nsresult rv;
74627:   // Parse directly into destination if possible
74627:   if (doc->IsHTML() &&
74627:       (position == eBeforeEnd ||
74627:        (position == eAfterEnd && !GetNextSibling()) ||
74627:        (position == eAfterBegin && !GetFirstChild()))) {
74627:     PRInt32 oldChildCount = destination->GetChildCount();
74627:     PRInt32 contextNs = destination->GetNameSpaceID();
74627:     nsIAtom* contextLocal = destination->Tag();
74627:     if (contextLocal == nsGkAtoms::html && contextNs == kNameSpaceID_XHTML) {
74627:       // For compat with IE6 through IE9. Willful violation of HTML5 as of
74627:       // 2011-04-06. CreateContextualFragment does the same already.
74627:       // Spec bug: http://www.w3.org/Bugs/Public/show_bug.cgi?id=12434
74627:       contextLocal = nsGkAtoms::body;
74627:     }
80380:     rv = nsContentUtils::ParseFragmentHTML(aText,
74627:                                            destination,
74627:                                            contextLocal,
74627:                                            contextNs,
74627:                                            doc->GetCompatibilityMode() ==
74627:                                              eCompatibility_NavQuirks,
80486:                                            true);
74627:     // HTML5 parser has notified, but not fired mutation events.
74627:     FireMutationEventsForDirectParsing(doc, destination, oldChildCount);
80380:     return rv;
74627:   }
74627: 
74627:   // couldn't parse directly
74627:   nsCOMPtr<nsIDOMDocumentFragment> df;
80380:   rv = nsContentUtils::CreateContextualFragment(destination,
74627:                                                 aText,
80486:                                                 true,
74627:                                                 getter_AddRefs(df));
74627:   nsCOMPtr<nsINode> fragment = do_QueryInterface(df);
74627:   NS_ENSURE_SUCCESS(rv, rv);
74627: 
75206:   // Suppress assertion about node removal mutation events that can't have
75206:   // listeners anyway, because no one has had the chance to register mutation
75206:   // listeners on the fragment that comes from the parser.
75206:   nsAutoScriptBlockerSuppressNodeRemoved scriptBlocker;
75206: 
74627:   switch (position) {
74627:     case eBeforeBegin:
74627:       destination->InsertBefore(fragment, this, &rv);
74627:       break;
74627:     case eAfterBegin:
74627:       static_cast<nsINode*>(this)->InsertBefore(fragment, GetFirstChild(), &rv);
74627:       break;
74627:     case eBeforeEnd:
74627:       static_cast<nsINode*>(this)->AppendChild(fragment, &rv);
74627:       break;
74627:     case eAfterEnd:
74627:       destination->InsertBefore(fragment, GetNextSibling(), &rv);
74627:       break;
74627:     default:
74627:       NS_NOTREACHED("Bad position.");
74627:       break;
74627:   }
74627:   return rv;
74627: }
74627: 
    1: nsresult
79445: nsGenericHTMLElement::ScrollIntoView(bool aTop, PRUint8 optional_argc)
    1: {
    1:   nsIDocument *document = GetCurrentDoc();
    1: 
    1:   if (!document) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Get the presentation shell
46225:   nsCOMPtr<nsIPresShell> presShell = document->GetShell();
    1:   if (!presShell) {
    1:     return NS_OK;
    1:   }
    1: 
34226:   if (!optional_argc) {
80486:     aTop = true;
34226:   }
34226: 
    1:   PRIntn vpercent = aTop ? NS_PRESSHELL_SCROLL_TOP :
 9984:     NS_PRESSHELL_SCROLL_BOTTOM;
    1: 
    1:   presShell->ScrollContentIntoView(this, vpercent,
56647:                                    NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                    nsIPresShell::SCROLL_OVERFLOW_HIDDEN);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsGenericHTMLElement::GetSpellcheck(bool* aSpellcheck)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSpellcheck);
80486:   *aSpellcheck = false;              // Default answer is to not spellcheck
    1: 
    1:   // Has the state has been explicitly set?
33329:   nsIContent* node;
33329:   for (node = this; node; node = node->GetParent()) {
33329:     if (node->IsHTML()) {
    1:       static nsIContent::AttrValuesArray strings[] =
    1:         {&nsGkAtoms::_true, &nsGkAtoms::_false, nsnull};
33329:       switch (node->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::spellcheck,
    1:                                     strings, eCaseMatters)) {
    1:         case 0:                         // spellcheck = "true"
80486:           *aSpellcheck = true;
    1:           // Fall through
    1:         case 1:                         // spellcheck = "false"
    1:           return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Is this a chrome element?
80526:   if (nsContentUtils::IsChromeDoc(OwnerDoc())) {
    1:     return NS_OK;                       // Not spellchecked by default
    1:   }
    1: 
    1:   if (IsCurrentBodyElement()) {
 2896:     nsCOMPtr<nsIHTMLDocument> doc = do_QueryInterface(GetCurrentDoc());
 2896:     if (doc) {
 2896:       *aSpellcheck = doc->IsEditingOn();
 2896:     }
 2896: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Is this element editable?
    1:   nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(this);
    1:   if (!formControl) {
    1:     return NS_OK;                       // Not spellchecked by default
    1:   }
    1: 
    1:   // Is this a multiline plaintext input?
    1:   PRInt32 controlType = formControl->GetType();
    1:   if (controlType == NS_FORM_TEXTAREA) {
80486:     *aSpellcheck = true;             // Spellchecked by default
    1:     return NS_OK;
    1:   }
    1: 
42192:   // Is this anything other than an input text?
42192:   // Other inputs are not spellchecked.
    1:   if (controlType != NS_FORM_INPUT_TEXT) {
    1:     return NS_OK;                       // Not spellchecked by default
    1:   }
    1: 
42192:   // Does the user want input text spellchecked by default?
    1:   // NOTE: Do not reflect a pref value of 0 back to the DOM getter.
    1:   // The web page should not know if the user has disabled spellchecking.
    1:   // We'll catch this in the editor itself.
70842:   PRInt32 spellcheckLevel = Preferences::GetInt("layout.spellcheckDefault", 1);
    1:   if (spellcheckLevel == 2) {           // "Spellcheck multi- and single-line"
80486:     *aSpellcheck = true;             // Spellchecked by default
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsGenericHTMLElement::SetSpellcheck(bool aSpellcheck)
    1: {
    1:   if (aSpellcheck) {
    1:     return SetAttrHelper(nsGkAtoms::spellcheck, NS_LITERAL_STRING("true"));
    1:   }
    1: 
    1:   return SetAttrHelper(nsGkAtoms::spellcheck, NS_LITERAL_STRING("false"));
    1: }
    1: 
18445: NS_IMETHODIMP
79445: nsGenericHTMLElement::GetDraggable(bool* aDraggable)
18445: {
18445:   *aDraggable = AttrValueIs(kNameSpaceID_None, nsGkAtoms::draggable,
18445:                              nsGkAtoms::_true, eIgnoreCase);
18445:   return NS_OK;
18445: }
18445: 
18445: NS_IMETHODIMP
79445: nsGenericHTMLElement::SetDraggable(bool aDraggable)
18445: {
18445:   return SetAttrHelper(nsGkAtoms::draggable,
82292:                        aDraggable ? NS_LITERAL_STRING("true")
82292:                                   : NS_LITERAL_STRING("false"));
18445: }
18445: 
79445: bool
    1: nsGenericHTMLElement::InNavQuirksMode(nsIDocument* aDoc)
    1: {
    1:   return aDoc && aDoc->GetCompatibilityMode() == eCompatibility_NavQuirks;
    1: }
    1: 
 2896: void
79445: nsGenericHTMLElement::UpdateEditableState(bool aNotify)
 2896: {
 2896:   // XXX Should we do this only when in a document?
 2896:   ContentEditableTristate value = GetContentEditableValue();
 2896:   if (value != eInherit) {
71121:     DoSetEditableFlag(!!value, aNotify);
 2896:     return;
 2896:   }
 2896: 
71121:   nsStyledElement::UpdateEditableState(aNotify);
 2896: }
 2896: 
    1: nsresult
    1: nsGenericHTMLElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                                  nsIContent* aBindingParent,
79445:                                  bool aCompileEventHandlers)
    1: {
 4306:   nsresult rv = nsGenericHTMLElementBase::BindToTree(aDocument, aParent,
    1:                                                      aBindingParent,
    1:                                                      aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 4306:   if (aDocument) {
67818:     RegAccessKey();
67609:     if (HasName()) {
43079:       aDocument->
43079:         AddToNameTable(this, GetParsedAttr(nsGkAtoms::name)->GetAtomValue());
43079:     }
 4306:     if (HasFlag(NODE_IS_EDITABLE) && GetContentEditableValue() == eTrue) {
 2896:       nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(aDocument);
 2896:       if (htmlDocument) {
 2896:         htmlDocument->ChangeContentEditableCount(this, +1);
 2896:       }
 2896:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
 2896: void
79445: nsGenericHTMLElement::UnbindFromTree(bool aDeep, bool aNullParent)
 2896: {
67818:   if (IsInDoc()) {
67818:     UnregAccessKey();
67818:   }
67818: 
48037:   RemoveFromNameTable();
48037: 
 2896:   if (GetContentEditableValue() == eTrue) {
 2896:     nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(GetCurrentDoc());
 2896:     if (htmlDocument) {
 2896:       htmlDocument->ChangeContentEditableCount(this, -1);
 2896:     }
 2896:   }
 2896: 
43079:   nsStyledElement::UnbindFromTree(aDeep, aNullParent);
 2896: }
 2896: 
34395: nsHTMLFormElement*
51301: nsGenericHTMLElement::FindAncestorForm(nsHTMLFormElement* aCurrentForm)
    1: {
51301:   NS_ASSERTION(!HasAttr(kNameSpaceID_None, nsGkAtoms::form),
51301:                "FindAncestorForm should not be called if @form is set!");
51301: 
 3597:   // Make sure we don't end up finding a form that's anonymous from
 3597:   // our point of view.
 3597:   nsIContent* bindingParent = GetBindingParent();
 3597: 
    1:   nsIContent* content = this;
 3597:   while (content != bindingParent && content) {
    1:     // If the current ancestor is a form, return it as our form
82292:     if (content->IsHTML(nsGkAtoms::form)) {
 4206: #ifdef DEBUG
 4206:       if (!nsContentUtils::IsInSameAnonymousTree(this, content)) {
 4206:         // It's possible that we started unbinding at |content| or
 4206:         // some ancestor of it, and |content| and |this| used to all be
 4206:         // anonymous.  Check for this the hard way.
 4206:         for (nsIContent* child = this; child != content;
 4206:              child = child->GetParent()) {
 4206:           NS_ASSERTION(child->GetParent()->IndexOf(child) != -1,
 3597:                        "Walked too far?");
 4206:         }
 4206:       }
 4206: #endif
34395:       return static_cast<nsHTMLFormElement*>(content);
    1:     }
    1: 
    1:     nsIContent *prevContent = content;
    1:     content = prevContent->GetParent();
    1: 
    1:     if (!content && aCurrentForm) {
    1:       // We got to the root of the subtree we're in, and we're being removed
    1:       // from the DOM (the only time we get into this method with a non-null
    1:       // aCurrentForm).  Check whether aCurrentForm is in the same subtree.  If
    1:       // it is, we want to return aCurrentForm, since this case means that
    1:       // we're one of those inputs-in-a-table that have a hacked mForm pointer
    1:       // and a subtree containing both us and the form got removed from the
    1:       // DOM.
34395:       if (nsContentUtils::ContentIsDescendantOf(aCurrentForm, prevContent)) {
34395:         return aCurrentForm;
34395:       }
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
79445: static bool
    1: IsArea(nsIContent *aContent)
    1: {
    1:   return (aContent->Tag() == nsGkAtoms::area &&
33329:           aContent->IsHTML());
    1: }
    1: 
79445: bool
  723: nsGenericHTMLElement::CheckHandleEventForAnchorsPreconditions(nsEventChainVisitor& aVisitor)
    1: {
    1:   NS_PRECONDITION(nsCOMPtr<nsILink>(do_QueryInterface(this)),
    1:                   "should be called only when |this| implements |nsILink|");
    1: 
    1:   if (!aVisitor.mPresContext) {
    1:     // We need a pres context to do link stuff. Some events (e.g. mutation
    1:     // events) don't have one.
    1:     // XXX: ideally, shouldn't we be able to do what we need without one?
80486:     return false; 
    1:   }
    1: 
    1:   //Need to check if we hit an imagemap area and if so see if we're handling
    1:   //the event on that map or on a link farther up the tree.  If we're on a
    1:   //link farther up, do nothing.
68780:   nsCOMPtr<nsIContent> target = aVisitor.mPresContext->EventStateManager()->
68780:     GetEventTargetContent(aVisitor.mEvent);
    1: 
  723:   return !target || !IsArea(target) || IsArea(this);
  723: }
  723: 
  723: nsresult
  723: nsGenericHTMLElement::PreHandleEventForAnchors(nsEventChainPreVisitor& aVisitor)
  723: {
 4306:   nsresult rv = nsGenericHTMLElementBase::PreHandleEvent(aVisitor);
  723:   NS_ENSURE_SUCCESS(rv, rv);
  723: 
  723:   if (!CheckHandleEventForAnchorsPreconditions(aVisitor)) {
  723:     return NS_OK;
  723:   }
  723: 
  723:   return PreHandleEventForLinks(aVisitor);
  723: }
  723: 
  723: nsresult
  723: nsGenericHTMLElement::PostHandleEventForAnchors(nsEventChainPostVisitor& aVisitor)
  723: {
  723:   if (!CheckHandleEventForAnchorsPreconditions(aVisitor)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return PostHandleEventForLinks(aVisitor);
    1: }
    1: 
79445: bool
    1: nsGenericHTMLElement::IsHTMLLink(nsIURI** aURI) const
    1: {
    1:   NS_PRECONDITION(aURI, "Must provide aURI out param");
    1: 
30307:   *aURI = GetHrefURIForAnchors().get();
    1:   // We promise out param is non-null if we return true, so base rv on it
    1:   return *aURI != nsnull;
    1: }
    1: 
30307: already_AddRefed<nsIURI>
30307: nsGenericHTMLElement::GetHrefURIForAnchors() const
    1: {
    1:   // This is used by the three nsILink implementations and
    1:   // nsHTMLStyleElement.
    1: 
    1:   // Get href= attribute (relative URI).
    1: 
    1:   // We use the nsAttrValue's copy of the URI string to avoid copying.
30307:   nsCOMPtr<nsIURI> uri;
70015:   GetURIAttr(nsGkAtoms::href, nsnull, getter_AddRefs(uri));
30307: 
30307:   return uri.forget();
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
79445:                                    const nsAString* aValue, bool aNotify)
    1: {
    1:   if (aNamespaceID == kNameSpaceID_None) {
  265:     if (nsContentUtils::IsEventAttributeName(aName, EventNameType_HTML) && aValue) {
    1:       nsresult rv = AddScriptEventListener(aName, *aValue);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else if (aNotify && aName == nsGkAtoms::spellcheck) {
    1:       SyncEditorsOnSubtree(this);
    1:     }
    1:   }
    1: 
 4306:   return nsGenericHTMLElementBase::AfterSetAttr(aNamespaceID, aName,
    1:                                                 aValue, aNotify);
    1: }
    1: 
74595: nsEventListenerManager*
79415: nsGenericHTMLElement::GetEventListenerManagerForAttr(nsIAtom* aAttrName,
79445:                                                      bool* aDefer)
    1: {
    1:   // Attributes on the body and frameset tags get set on the global object
79415:   if ((mNodeInfo->Equals(nsGkAtoms::body) ||
79415:        mNodeInfo->Equals(nsGkAtoms::frameset)) &&
79415:       // We only forward some event attributes from body/frameset to window
79415:       (0
79415: #define EVENT(name_, id_, type_, struct_) /* nothing */
79415: #define FORWARDED_EVENT(name_, id_, type_, struct_) \
79415:        || nsGkAtoms::on##name_ == aAttrName
79415: #define WINDOW_EVENT FORWARDED_EVENT
79415: #include "nsEventNameList.h"
79415: #undef WINDOW_EVENT
79415: #undef FORWARDED_EVENT
79415: #undef EVENT
79415:        )
79415:       ) {
    1:     nsPIDOMWindow *win;
    1: 
    1:     // If we have a document, and it has a window, add the event
    1:     // listener on the window (the inner window). If not, proceed as
    1:     // normal.
    1:     // XXXbz sXBL/XBL2 issue: should we instead use GetCurrentDoc() here,
    1:     // override BindToTree for those classes and munge event listeners there?
80526:     nsIDocument *document = OwnerDoc();
14919: 
14919:     // FIXME (https://bugzilla.mozilla.org/show_bug.cgi?id=431767)
14919:     // nsDocument::GetInnerWindow can return an outer window in some cases,
14919:     // we don't want to stick an event listener on an outer window, so
77149:     // bail if it does.  See similar code in nsHTMLBodyElement and
77149:     // nsHTMLFramesetElement
80486:     *aDefer = false;
80527:     if ((win = document->GetInnerWindow()) && win->IsInnerWindow()) {
72326:       nsCOMPtr<nsIDOMEventTarget> piTarget(do_QueryInterface(win));
74595: 
80486:       return piTarget->GetListenerManager(true);
74595:     }
74595: 
74595:     return nsnull;
74595:   }
74595: 
79415:   return nsGenericHTMLElementBase::GetEventListenerManagerForAttr(aAttrName,
79415:                                                                   aDefer);
    1: }
    1: 
    1: nsresult
 2896: nsGenericHTMLElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 2896:                               nsIAtom* aPrefix, const nsAString& aValue,
79445:                               bool aNotify)
 2896: {
79445:   bool contentEditable = aNameSpaceID == kNameSpaceID_None &&
 2896:                            aName == nsGkAtoms::contenteditable;
79445:   bool accessKey = aName == nsGkAtoms::accesskey && 
67818:                      aNameSpaceID == kNameSpaceID_None;
67818: 
68468:   PRInt32 change = 0;
 2896:   if (contentEditable) {
 2896:     change = GetContentEditableValue() == eTrue ? -1 : 0;
67610:     SetMayHaveContentEditableAttr();
 2896:   }
 2896: 
67818:   if (accessKey) {
67818:     UnregAccessKey();
67818:   }
67818: 
43079:   nsresult rv = nsStyledElement::SetAttr(aNameSpaceID, aName, aPrefix, aValue,
 2896:                                          aNotify);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   if (contentEditable) {
 2896:     if (aValue.IsEmpty() || aValue.LowerCaseEqualsLiteral("true")) {
 2896:       change += 1;
 2896:     }
 2896: 
 2896:     ChangeEditableState(change);
 2896:   }
 2896: 
67818:   if (accessKey && !aValue.IsEmpty()) {
67818:     SetFlags(NODE_HAS_ACCESSKEY);
67818:     RegAccessKey();
67818:   }
67818: 
 2896:   return NS_OK;
 2896: }
 2896: 
 2896: nsresult
    1: nsGenericHTMLElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
79445:                                 bool aNotify)
    1: {
79445:   bool contentEditable = false;
68468:   PRInt32 contentEditableChange = 0;
20827: 
30099:   // Check for event handlers
20827:   if (aNameSpaceID == kNameSpaceID_None) {
43079:     if (aAttribute == nsGkAtoms::name) {
43079:       // Have to do this before clearing flag. See RemoveFromNameTable
43079:       RemoveFromNameTable();
67609:       ClearHasName();
43079:     }
43079:     else if (aAttribute == nsGkAtoms::contenteditable) {
80486:       contentEditable = true;
20827:       contentEditableChange = GetContentEditableValue() == eTrue ? -1 : 0;
20827:     }
67818:     else if (aAttribute == nsGkAtoms::accesskey) {
67818:       // Have to unregister before clearing flag. See UnregAccessKey
67818:       UnregAccessKey();
67818:       UnsetFlags(NODE_HAS_ACCESSKEY);
67818:     }
30099:     else if (nsContentUtils::IsEventAttributeName(aAttribute,
30099:                                                   EventNameType_HTML)) {
80486:       nsEventListenerManager* manager = GetListenerManager(false);
    1:       if (manager) {
    1:         manager->RemoveScriptEventListener(aAttribute);
    1:       }
    1:     }
70158: 
70158:     // Remove dataset property if necessary.
70158:     nsDOMSlots *slots = GetExistingDOMSlots();
70158:     if (slots && slots->mDataset) {
70158:       slots->mDataset->RemoveProp(aAttribute);
70158:     }
 2896:   }
    1: 
20827:   nsresult rv = nsGenericHTMLElementBase::UnsetAttr(aNameSpaceID, aAttribute,
 4306:                                                     aNotify);
20827:   NS_ENSURE_SUCCESS(rv, rv);
20827: 
20827:   if (contentEditable) {
20827:     ChangeEditableState(contentEditableChange);
20827:   }
20827: 
20827:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::GetBaseTarget(nsAString& aBaseTarget) const
    1: {
80527:   OwnerDoc()->GetBaseTarget(aBaseTarget);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
79445: static bool
43079: CanHaveName(nsIAtom* aTag)
43079: {
43079:   return aTag == nsGkAtoms::img ||
43079:          aTag == nsGkAtoms::form ||
43079:          aTag == nsGkAtoms::applet ||
43079:          aTag == nsGkAtoms::embed ||
43079:          aTag == nsGkAtoms::object;
43079: }
    1: 
79445: bool
    1: nsGenericHTMLElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                                      nsIAtom* aAttribute,
    1:                                      const nsAString& aValue,
    1:                                      nsAttrValue& aResult)
    1: {
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     if (aAttribute == nsGkAtoms::dir) {
80486:       return aResult.ParseEnumValue(aValue, kDirTable, false);
    1:     }
    1:   
    1:     if (aAttribute == nsGkAtoms::tabindex) {
    1:       return aResult.ParseIntWithBounds(aValue, -32768, 32767);
    1:     }
    1: 
43079:     if (aAttribute == nsGkAtoms::name) {
    1:       // Store name as an atom.  name="" means that the element has no name,
    1:       // not that it has an emptystring as the name.
43079:       RemoveFromNameTable();
43079:       if (aValue.IsEmpty()) {
67609:         ClearHasName();
80486:         return false;
43079:       }
43079: 
    1:       aResult.ParseAtom(aValue);
43079: 
43079:       if (CanHaveName(Tag())) {
67609:         SetHasName();
43079:         AddToNameTable(aResult.GetAtomValue());
43079:       }
43079:       
80486:       return true;
    1:     }
 2896: 
 2896:     if (aAttribute == nsGkAtoms::contenteditable) {
 2896:       aResult.ParseAtom(aValue);
80486:       return true;
 2896:     }
    1:   }
    1: 
 4306:   return nsGenericHTMLElementBase::ParseAttribute(aNamespaceID, aAttribute,
 4306:                                                   aValue, aResult);
    1: }
    1: 
79445: bool
    1: nsGenericHTMLElement::IsAttributeMapped(const nsIAtom* aAttribute) const
    1: {
    1:   static const MappedAttributeEntry* const map[] = {
    1:     sCommonAttributeMap
    1:   };
    1:   
84865:   return FindAttributeDependence(aAttribute, map);
    1: }
    1: 
    1: nsMapRuleToAttributesFunc
    1: nsGenericHTMLElement::GetAttributeMappingFunction() const
    1: {
    1:   return &MapCommonAttributesInto;
    1: }
    1: 
    1: nsIFormControlFrame*
79445: nsGenericHTMLElement::GetFormControlFrame(bool aFlushFrames)
    1: {
36655:   if (aFlushFrames && IsInDoc()) {
27993:     // Cause a flush of the frames, so we get up-to-date frame information
36655:     GetCurrentDoc()->FlushPendingNotifications(Flush_Frames);
36655:   }
36655:   nsIFrame* frame = GetPrimaryFrame();
    1:   if (frame) {
23554:     nsIFormControlFrame* form_frame = do_QueryFrame(frame);
    1:     if (form_frame) {
    1:       return form_frame;
    1:     }
    1: 
    1:     // If we have generated content, the primary frame will be a
    1:     // wrapper frame..  out real frame will be in its child list.
77154:     for (frame = frame->GetFirstPrincipalChild();
    1:          frame;
    1:          frame = frame->GetNextSibling()) {
23554:       form_frame = do_QueryFrame(frame);
    1:       if (form_frame) {
    1:         return form_frame;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: /* static */ nsresult
    1: nsGenericHTMLElement::GetPrimaryPresState(nsGenericHTMLElement* aContent,
    1:                                           nsPresState** aPresState)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPresState);
    1:   *aPresState = nsnull;
    1: 
    1:   nsresult result = NS_OK;
    1: 
    1:   nsCAutoString key;
87638:   nsCOMPtr<nsILayoutHistoryState> history = GetLayoutHistoryAndKey(aContent, false, key);
    1: 
    1:   if (history) {
    1:     // Get the pres state for this key, if it doesn't exist, create one
    1:     result = history->GetState(key, aPresState);
    1:     if (!*aPresState) {
22740:       *aPresState = new nsPresState();
    1:       result = history->AddState(key, *aPresState);
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: 
87638: already_AddRefed<nsILayoutHistoryState>
    1: nsGenericHTMLElement::GetLayoutHistoryAndKey(nsGenericHTMLElement* aContent,
79445:                                              bool aRead,
    1:                                              nsACString& aKey)
    1: {
    1:   //
    1:   // Get the pres shell
    1:   //
    1:   nsCOMPtr<nsIDocument> doc = aContent->GetDocument();
    1:   if (!doc) {
87638:     return nsnull;
    1:   }
    1: 
    1:   //
    1:   // Get the history (don't bother with the key if the history is not there)
    1:   //
87638:   nsCOMPtr<nsILayoutHistoryState> history = doc->GetLayoutHistoryState();
87638:   if (!history) {
87638:     return nsnull;
87638:   }
87638: 
87638:   if (aRead && !history->HasStates()) {
87638:     return nsnull;
 3727:   }
 3727: 
    1:   //
    1:   // Get the state key
    1:   //
    1:   nsresult rv = nsContentUtils::GenerateStateKey(aContent, doc,
    1:                                                  nsIStatefulFrame::eNoID,
    1:                                                  aKey);
    1:   if (NS_FAILED(rv)) {
87638:     return nsnull;
    1:   }
    1: 
    1:   // If the state key is blank, this is anonymous content or for
    1:   // whatever reason we are not supposed to save/restore state.
    1:   if (aKey.IsEmpty()) {
87638:     return nsnull;
    1:   }
    1: 
    1:   // Add something unique to content so layout doesn't muck us up
    1:   aKey += "-C";
    1: 
87638:   return history.forget();
    1: }
    1: 
79445: bool
    1: nsGenericHTMLElement::RestoreFormControlState(nsGenericHTMLElement* aContent,
    1:                                               nsIFormControl* aControl)
    1: {
    1:   nsCAutoString key;
87638:   nsCOMPtr<nsILayoutHistoryState> history = GetLayoutHistoryAndKey(aContent, true, key);
    1:   if (!history) {
80486:     return false;
    1:   }
    1: 
    1:   nsPresState *state;
    1:   // Get the pres state for this key
87010:   nsresult rv = history->GetState(key, &state);
87010:   if (NS_SUCCEEDED(rv) && state) {
79445:     bool result = aControl->RestoreState(state);
    1:     history->RemoveState(key);
    1:     return result;
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: // XXX This creates a dependency between content and frames
    1: nsPresContext*
    1: nsGenericHTMLElement::GetPresContext()
    1: {
    1:   // Get the document
    1:   nsIDocument* doc = GetDocument();
    1:   if (doc) {
82292:     // Get presentation shell.
46225:     nsIPresShell *presShell = doc->GetShell();
    1:     if (presShell) {
    1:       return presShell->GetPresContext();
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: static const nsAttrValue::EnumTable kAlignTable[] = {
    1:   { "left",      NS_STYLE_TEXT_ALIGN_LEFT },
    1:   { "right",     NS_STYLE_TEXT_ALIGN_RIGHT },
    1: 
    1:   { "top",       NS_STYLE_VERTICAL_ALIGN_TOP },
    1:   { "middle",    NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE },
    1:   { "bottom",    NS_STYLE_VERTICAL_ALIGN_BASELINE },
    1: 
    1:   { "center",    NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE },
    1:   { "baseline",  NS_STYLE_VERTICAL_ALIGN_BASELINE },
    1: 
    1:   { "texttop",   NS_STYLE_VERTICAL_ALIGN_TEXT_TOP },
    1:   { "absmiddle", NS_STYLE_VERTICAL_ALIGN_MIDDLE },
    1:   { "abscenter", NS_STYLE_VERTICAL_ALIGN_MIDDLE },
    1:   { "absbottom", NS_STYLE_VERTICAL_ALIGN_BOTTOM },
    1:   { 0 }
    1: };
    1: 
    1: static const nsAttrValue::EnumTable kDivAlignTable[] = {
    1:   { "left", NS_STYLE_TEXT_ALIGN_MOZ_LEFT },
    1:   { "right", NS_STYLE_TEXT_ALIGN_MOZ_RIGHT },
    1:   { "center", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
    1:   { "middle", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
    1:   { "justify", NS_STYLE_TEXT_ALIGN_JUSTIFY },
    1:   { 0 }
    1: };
    1: 
    1: static const nsAttrValue::EnumTable kFrameborderTable[] = {
    1:   { "yes", NS_STYLE_FRAME_YES },
    1:   { "no", NS_STYLE_FRAME_NO },
    1:   { "1", NS_STYLE_FRAME_1 },
    1:   { "0", NS_STYLE_FRAME_0 },
    1:   { 0 }
    1: };
    1: 
    1: static const nsAttrValue::EnumTable kScrollingTable[] = {
    1:   { "yes", NS_STYLE_FRAME_YES },
    1:   { "no", NS_STYLE_FRAME_NO },
    1:   { "on", NS_STYLE_FRAME_ON },
    1:   { "off", NS_STYLE_FRAME_OFF },
    1:   { "scroll", NS_STYLE_FRAME_SCROLL },
    1:   { "noscroll", NS_STYLE_FRAME_NOSCROLL },
    1:   { "auto", NS_STYLE_FRAME_AUTO },
    1:   { 0 }
    1: };
    1: 
    1: static const nsAttrValue::EnumTable kTableVAlignTable[] = {
    1:   { "top",     NS_STYLE_VERTICAL_ALIGN_TOP },
    1:   { "middle",  NS_STYLE_VERTICAL_ALIGN_MIDDLE },
    1:   { "bottom",  NS_STYLE_VERTICAL_ALIGN_BOTTOM },
    1:   { "baseline",NS_STYLE_VERTICAL_ALIGN_BASELINE },
    1:   { 0 }
    1: };
    1: 
79445: bool
    1: nsGenericHTMLElement::ParseAlignValue(const nsAString& aString,
    1:                                       nsAttrValue& aResult)
    1: {
80486:   return aResult.ParseEnumValue(aString, kAlignTable, false);
    1: }
    1: 
    1: //----------------------------------------
    1: 
    1: static const nsAttrValue::EnumTable kTableHAlignTable[] = {
    1:   { "left",   NS_STYLE_TEXT_ALIGN_LEFT },
    1:   { "right",  NS_STYLE_TEXT_ALIGN_RIGHT },
    1:   { "center", NS_STYLE_TEXT_ALIGN_CENTER },
    1:   { "char",   NS_STYLE_TEXT_ALIGN_CHAR },
    1:   { "justify",NS_STYLE_TEXT_ALIGN_JUSTIFY },
    1:   { 0 }
    1: };
    1: 
79445: bool
    1: nsGenericHTMLElement::ParseTableHAlignValue(const nsAString& aString,
43545:                                             nsAttrValue& aResult)
    1: {
80486:   return aResult.ParseEnumValue(aString, kTableHAlignTable, false);
    1: }
    1: 
    1: //----------------------------------------
    1: 
48442: // This table is used for td, th, tr, col, thead, tbody and tfoot.
    1: static const nsAttrValue::EnumTable kTableCellHAlignTable[] = {
    1:   { "left",   NS_STYLE_TEXT_ALIGN_MOZ_LEFT },
    1:   { "right",  NS_STYLE_TEXT_ALIGN_MOZ_RIGHT },
    1:   { "center", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
    1:   { "char",   NS_STYLE_TEXT_ALIGN_CHAR },
    1:   { "justify",NS_STYLE_TEXT_ALIGN_JUSTIFY },
    1:   { "middle", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
    1:   { "absmiddle", NS_STYLE_TEXT_ALIGN_CENTER },
    1:   { 0 }
    1: };
    1: 
79445: bool
    1: nsGenericHTMLElement::ParseTableCellHAlignValue(const nsAString& aString,
48442:                                                 nsAttrValue& aResult)
    1: {
80486:   return aResult.ParseEnumValue(aString, kTableCellHAlignTable, false);
    1: }
    1: 
    1: //----------------------------------------
    1: 
79445: bool
    1: nsGenericHTMLElement::ParseTableVAlignValue(const nsAString& aString,
    1:                                             nsAttrValue& aResult)
    1: {
80486:   return aResult.ParseEnumValue(aString, kTableVAlignTable, false);
    1: }
    1: 
79445: bool
    1: nsGenericHTMLElement::ParseDivAlignValue(const nsAString& aString,
47237:                                          nsAttrValue& aResult)
    1: {
80486:   return aResult.ParseEnumValue(aString, kDivAlignTable, false);
    1: }
    1: 
79445: bool
    1: nsGenericHTMLElement::ParseImageAttribute(nsIAtom* aAttribute,
    1:                                           const nsAString& aString,
    1:                                           nsAttrValue& aResult)
    1: {
    1:   if ((aAttribute == nsGkAtoms::width) ||
    1:       (aAttribute == nsGkAtoms::height)) {
61970:     return aResult.ParseSpecialIntValue(aString);
    1:   }
82292:   if ((aAttribute == nsGkAtoms::hspace) ||
    1:       (aAttribute == nsGkAtoms::vspace) ||
    1:       (aAttribute == nsGkAtoms::border)) {
    1:     return aResult.ParseIntWithBounds(aString, 0);
    1:   }
80486:   return false;
    1: }
    1: 
79445: bool
    1: nsGenericHTMLElement::ParseFrameborderValue(const nsAString& aString,
    1:                                             nsAttrValue& aResult)
    1: {
80486:   return aResult.ParseEnumValue(aString, kFrameborderTable, false);
    1: }
    1: 
79445: bool
    1: nsGenericHTMLElement::ParseScrollingValue(const nsAString& aString,
    1:                                           nsAttrValue& aResult)
    1: {
80486:   return aResult.ParseEnumValue(aString, kScrollingTable, false);
    1: }
    1: 
    1: /**
    1:  * Handle attributes common to all html elements
    1:  */
    1: void
58544: nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(const nsMappedAttributes* aAttributes,
    1:                                                           nsRuleData* aData)
    1: {
 6732:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(UserInterface)) {
63742:     nsCSSValue* userModify = aData->ValueForUserModify();
63742:     if (userModify->GetUnit() == eCSSUnit_Null) {
 2896:       const nsAttrValue* value =
 2896:         aAttributes->GetAttr(nsGkAtoms::contenteditable);
 2896:       if (value) {
 2896:         if (value->Equals(nsGkAtoms::_empty, eCaseMatters) ||
 2896:             value->Equals(nsGkAtoms::_true, eIgnoreCase)) {
63742:           userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_WRITE,
 2896:                                   eCSSUnit_Enumerated);
 2896:         }
20264:         else if (value->Equals(nsGkAtoms::_false, eIgnoreCase)) {
63742:             userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_ONLY,
 2896:                                     eCSSUnit_Enumerated);
 2896:         }
 2896:       }
 2896:     }
 2896:   }
48696: 
 6732:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Visibility)) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::lang);
    1:     if (value && value->Type() == nsAttrValue::eString) {
63742:       aData->ValueForLang()->SetStringValue(value->GetStringValue(),
25796:                                             eCSSUnit_Ident);
    1:     }
    1:   }
58544: }
58544: 
58544: void
58544: nsGenericHTMLElement::MapCommonAttributesInto(const nsMappedAttributes* aAttributes,
58544:                                               nsRuleData* aData)
58544: {
58544:   nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(aAttributes, aData);
48696: 
48696:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
63742:     nsCSSValue* display = aData->ValueForDisplay();
63742:     if (display->GetUnit() == eCSSUnit_Null) {
48696:       if (aAttributes->IndexOfAttr(nsGkAtoms::hidden, kNameSpaceID_None) >= 0) {
63742:         display->SetIntValue(NS_STYLE_DISPLAY_NONE, eCSSUnit_Enumerated);
48696:       }
48696:     }
48696:   }
    1: }
    1: 
80866: void
80866: nsGenericHTMLFormElement::UpdateEditableFormControlState(bool aNotify)
80866: {
80866:   // nsCSSFrameConstructor::MaybeConstructLazily is based on the logic of this
80866:   // function, so should be kept in sync with that.
80866: 
80866:   ContentEditableTristate value = GetContentEditableValue();
80866:   if (value != eInherit) {
80866:     DoSetEditableFlag(!!value, aNotify);
80866:     return;
80866:   }
80866: 
80866:   nsIContent *parent = GetParent();
80866: 
80866:   if (parent && parent->HasFlag(NODE_IS_EDITABLE)) {
80866:     DoSetEditableFlag(true, aNotify);
80866:     return;
80866:   }
80866: 
80866:   if (!IsTextControl(false)) {
80866:     DoSetEditableFlag(false, aNotify);
80866:     return;
80866:   }
80866: 
80866:   // If not contentEditable we still need to check the readonly attribute.
80866:   bool roState;
80866:   GetBoolAttr(nsGkAtoms::readonly, &roState);
80866: 
80866:   DoSetEditableFlag(!roState, aNotify);
80866: }
80866: 
    1: 
    1: /* static */ const nsGenericHTMLElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sCommonAttributeMap[] = {
 2896:   { &nsGkAtoms::contenteditable },
    1:   { &nsGkAtoms::lang },
48696:   { &nsGkAtoms::hidden },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sImageMarginSizeAttributeMap[] = {
    1:   { &nsGkAtoms::width },
    1:   { &nsGkAtoms::height },
    1:   { &nsGkAtoms::hspace },
    1:   { &nsGkAtoms::vspace },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sImageAlignAttributeMap[] = {
    1:   { &nsGkAtoms::align },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sDivAlignAttributeMap[] = {
    1:   { &nsGkAtoms::align },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sImageBorderAttributeMap[] = {
    1:   { &nsGkAtoms::border },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sBackgroundAttributeMap[] = {
    1:   { &nsGkAtoms::background },
    1:   { &nsGkAtoms::bgcolor },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sBackgroundColorAttributeMap[] = {
    1:   { &nsGkAtoms::bgcolor },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sScrollingAttributeMap[] = {
    1:   { &nsGkAtoms::scrolling },
    1:   { nsnull }
    1: };
    1: 
    1: void
    1: nsGenericHTMLElement::MapImageAlignAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                  nsRuleData* aRuleData)
    1: {
 6732:   if (aRuleData->mSIDs & (NS_STYLE_INHERIT_BIT(Display) |
 6732:                           NS_STYLE_INHERIT_BIT(TextReset))) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
    1:     if (value && value->Type() == nsAttrValue::eEnum) {
    1:       PRInt32 align = value->GetEnumValue();
63742:       if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
63742:         nsCSSValue* cssFloat = aRuleData->ValueForCssFloat();
63742:         if (cssFloat->GetUnit() == eCSSUnit_Null) {
63742:           if (align == NS_STYLE_TEXT_ALIGN_LEFT) {
63742:             cssFloat->SetIntValue(NS_STYLE_FLOAT_LEFT, eCSSUnit_Enumerated);
63742:           } else if (align == NS_STYLE_TEXT_ALIGN_RIGHT) {
63742:             cssFloat->SetIntValue(NS_STYLE_FLOAT_RIGHT, eCSSUnit_Enumerated);
63742:           }
63742:         }
63742:       }
63742:       if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
63742:         nsCSSValue* verticalAlign = aRuleData->ValueForVerticalAlign();
63742:         if (verticalAlign->GetUnit() == eCSSUnit_Null) {
    1:           switch (align) {
    1:           case NS_STYLE_TEXT_ALIGN_LEFT:
    1:           case NS_STYLE_TEXT_ALIGN_RIGHT:
    1:             break;
    1:           default:
63742:             verticalAlign->SetIntValue(align, eCSSUnit_Enumerated);
    1:             break;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
63742: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapDivAlignAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                nsRuleData* aRuleData)
    1: {
 6732:   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
63742:     nsCSSValue* textAlign = aRuleData->ValueForTextAlign();
63742:     if (textAlign->GetUnit() == eCSSUnit_Null) {
    1:       // align: enum
    1:       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
    1:       if (value && value->Type() == nsAttrValue::eEnum)
63742:         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: void
    1: nsGenericHTMLElement::MapImageMarginAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                   nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)))
    1:     return;
    1: 
    1:   const nsAttrValue* value;
    1: 
    1:   // hspace: value
    1:   value = aAttributes->GetAttr(nsGkAtoms::hspace);
    1:   if (value) {
    1:     nsCSSValue hval;
    1:     if (value->Type() == nsAttrValue::eInteger)
    1:       hval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
    1:     else if (value->Type() == nsAttrValue::ePercent)
    1:       hval.SetPercentValue(value->GetPercentValue());
    1: 
    1:     if (hval.GetUnit() != eCSSUnit_Null) {
63742:       nsCSSValue* left = aData->ValueForMarginLeftValue();
63742:       if (left->GetUnit() == eCSSUnit_Null)
63742:         *left = hval;
63742:       nsCSSValue* right = aData->ValueForMarginRightValue();
63742:       if (right->GetUnit() == eCSSUnit_Null)
63742:         *right = hval;
    1:     }
    1:   }
    1: 
    1:   // vspace: value
    1:   value = aAttributes->GetAttr(nsGkAtoms::vspace);
    1:   if (value) {
    1:     nsCSSValue vval;
    1:     if (value->Type() == nsAttrValue::eInteger)
    1:       vval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
    1:     else if (value->Type() == nsAttrValue::ePercent)
    1:       vval.SetPercentValue(value->GetPercentValue());
    1:   
    1:     if (vval.GetUnit() != eCSSUnit_Null) {
63742:       nsCSSValue* top = aData->ValueForMarginTop();
63742:       if (top->GetUnit() == eCSSUnit_Null)
63742:         *top = vval;
63742:       nsCSSValue* bottom = aData->ValueForMarginBottom();
63742:       if (bottom->GetUnit() == eCSSUnit_Null)
63742:         *bottom = vval;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapImageSizeAttributesInto(const nsMappedAttributes* aAttributes,
    1:                                                  nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)))
    1:     return;
    1: 
    1:   // width: value
63742:   nsCSSValue* width = aData->ValueForWidth();
63742:   if (width->GetUnit() == eCSSUnit_Null) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
    1:     if (value && value->Type() == nsAttrValue::eInteger)
63742:       width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
    1:     else if (value && value->Type() == nsAttrValue::ePercent)
63742:       width->SetPercentValue(value->GetPercentValue());
    1:   }
    1: 
    1:   // height: value
63742:   nsCSSValue* height = aData->ValueForHeight();
63742:   if (height->GetUnit() == eCSSUnit_Null) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
    1:     if (value && value->Type() == nsAttrValue::eInteger)
63742:       height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
    1:     else if (value && value->Type() == nsAttrValue::ePercent)
63742:       height->SetPercentValue(value->GetPercentValue());
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapImageBorderAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                   nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)))
    1:     return;
    1: 
    1:   // border: pixels
    1:   const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::border);
    1:   if (!value)
    1:     return;
    1:   
    1:   nscoord val = 0;
    1:   if (value->Type() == nsAttrValue::eInteger)
    1:     val = value->GetIntegerValue();
    1: 
63742:   nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidthValue();
63742:   if (borderLeftWidth->GetUnit() == eCSSUnit_Null)
63742:     borderLeftWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
63742:   nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
63742:   if (borderTopWidth->GetUnit() == eCSSUnit_Null)
63742:     borderTopWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
63742:   nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidthValue();
63742:   if (borderRightWidth->GetUnit() == eCSSUnit_Null)
63742:     borderRightWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
63742:   nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
63742:   if (borderBottomWidth->GetUnit() == eCSSUnit_Null)
63742:     borderBottomWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
63742: 
63742:   nsCSSValue* borderLeftStyle = aData->ValueForBorderLeftStyleValue();
63742:   if (borderLeftStyle->GetUnit() == eCSSUnit_Null)
63742:     borderLeftStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
63742:   nsCSSValue* borderTopStyle = aData->ValueForBorderTopStyle();
63742:   if (borderTopStyle->GetUnit() == eCSSUnit_Null)
63742:     borderTopStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
63742:   nsCSSValue* borderRightStyle = aData->ValueForBorderRightStyleValue();
63742:   if (borderRightStyle->GetUnit() == eCSSUnit_Null)
63742:     borderRightStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
63742:   nsCSSValue* borderBottomStyle = aData->ValueForBorderBottomStyle();
63742:   if (borderBottomStyle->GetUnit() == eCSSUnit_Null)
63742:     borderBottomStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
63742: 
63742:   nsCSSValue* borderLeftColor = aData->ValueForBorderLeftColorValue();
63742:   if (borderLeftColor->GetUnit() == eCSSUnit_Null)
63742:     borderLeftColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
63742:   nsCSSValue* borderTopColor = aData->ValueForBorderTopColor();
63742:   if (borderTopColor->GetUnit() == eCSSUnit_Null)
63742:     borderTopColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
63742:   nsCSSValue* borderRightColor = aData->ValueForBorderRightColorValue();
63742:   if (borderRightColor->GetUnit() == eCSSUnit_Null)
63742:     borderRightColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
63742:   nsCSSValue* borderBottomColor = aData->ValueForBorderBottomColor();
63742:   if (borderBottomColor->GetUnit() == eCSSUnit_Null)
63742:     borderBottomColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapBackgroundInto(const nsMappedAttributes* aAttributes,
    1:                                         nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
    1:     return;
    1: 
 8088:   nsPresContext* presContext = aData->mPresContext;
63742:   nsCSSValue* backImage = aData->ValueForBackgroundImage();
63742:   if (backImage->GetUnit() == eCSSUnit_Null &&
50931:       presContext->UseDocumentColors()) {
    1:     // background
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::background);
    1:     if (value && value->Type() == nsAttrValue::eString) {
    1:       const nsString& spec = value->GetStringValue();
    1:       if (!spec.IsEmpty()) {
    1:         // Resolve url to an absolute url
    1:         // XXX this breaks if the HTML element has an xml:base
    1:         // attribute (the xml:base will not be taken into account)
    1:         // as well as elements with _baseHref set. We need to be able
    1:         // to get to the element somehow, or store the base URI in the
    1:         // attributes.
 8088:         nsIDocument* doc = presContext->Document();
    1:         nsCOMPtr<nsIURI> uri;
    1:         nsresult rv = nsContentUtils::NewURIWithDocumentCharset(
41900:             getter_AddRefs(uri), spec, doc, doc->GetDocBaseURI());
    1:         if (NS_SUCCEEDED(rv)) {
    1:           // Note that this should generally succeed here, due to the way
    1:           // |spec| is created.  Maybe we should just add an nsStringBuffer
    1:           // accessor on nsAttrValue?
58631:           nsRefPtr<nsStringBuffer> buffer = nsCSSValue::BufferFromString(spec);
58631:           if (NS_LIKELY(buffer)) {
 1036:             // XXXbz it would be nice to assert that doc->NodePrincipal() is
 1036:             // the same as the principal of the node (which we'd need to store
 1036:             // in the mapped attrs or something?)
    1:             nsCSSValue::Image *img =
    1:               new nsCSSValue::Image(uri, buffer, doc->GetDocumentURI(),
 3076:                                     doc->NodePrincipal(), doc);
58631:             if (NS_LIKELY(img)) {
63742:               nsCSSValueList* list = backImage->SetListValue();
50931:               list->mValue.SetImageValue(img);
    1:             }
    1:           }
    1:         }
    1:       }
 8088:       else if (presContext->CompatibilityMode() == eCompatibility_NavQuirks) {
    1:         // in NavQuirks mode, allow the empty string to set the
    1:         // background to empty
63742:         nsCSSValueList* list = backImage->SetListValue();
50931:         list->mValue.SetNoneValue();
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapBGColorInto(const nsMappedAttributes* aAttributes,
    1:                                      nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
    1:     return;
    1: 
63742:   nsCSSValue* backColor = aData->ValueForBackgroundColor();
63742:   if (backColor->GetUnit() == eCSSUnit_Null &&
 8088:       aData->mPresContext->UseDocumentColors()) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bgcolor);
    1:     nscolor color;
    1:     if (value && value->GetColorValue(color)) {
63742:       backColor->SetColorValue(color);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapBackgroundAttributesInto(const nsMappedAttributes* aAttributes,
    1:                                                   nsRuleData* aData)
    1: {
    1:   MapBackgroundInto(aAttributes, aData);
    1:   MapBGColorInto(aAttributes, aData);
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapScrollingAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                 nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)))
    1:     return;
    1: 
    1:   // scrolling
    1:   nsCSSValue* overflowValues[2] = {
63742:     aData->ValueForOverflowX(),
63742:     aData->ValueForOverflowY(),
    1:   };
80467:   for (PRUint32 i = 0; i < ArrayLength(overflowValues); ++i) {
    1:     if (overflowValues[i]->GetUnit() == eCSSUnit_Null) {
    1:       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::scrolling);
    1:       if (value && value->Type() == nsAttrValue::eEnum) {
    1:         PRInt32 mappedValue;
    1:         switch (value->GetEnumValue()) {
    1:           case NS_STYLE_FRAME_ON:
    1:           case NS_STYLE_FRAME_SCROLL:
    1:           case NS_STYLE_FRAME_YES:
    1:             mappedValue = NS_STYLE_OVERFLOW_SCROLL;
    1:             break;
    1: 
    1:           case NS_STYLE_FRAME_OFF:
    1:           case NS_STYLE_FRAME_NOSCROLL:
    1:           case NS_STYLE_FRAME_NO:
    1:             mappedValue = NS_STYLE_OVERFLOW_HIDDEN;
    1:             break;
    1:         
    1:           case NS_STYLE_FRAME_AUTO:
    1:             mappedValue = NS_STYLE_OVERFLOW_AUTO;
    1:             break;
    1: 
    1:           default:
    1:             NS_NOTREACHED("unexpected value");
    1:             mappedValue = NS_STYLE_OVERFLOW_AUTO;
    1:             break;
    1:         }
    1:         overflowValues[i]->SetIntValue(mappedValue, eCSSUnit_Enumerated);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetAttrHelper(nsIAtom* aAttr, nsAString& aValue)
    1: {
    1:   GetAttr(kNameSpaceID_None, aAttr, aValue);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetAttrHelper(nsIAtom* aAttr, const nsAString& aValue)
    1: {
80486:   return SetAttr(kNameSpaceID_None, aAttr, aValue, true);
    1: }
    1: 
    1: nsresult
79445: nsGenericHTMLElement::SetBoolAttr(nsIAtom* aAttr, bool aValue)
    1: {
    1:   if (aValue) {
80486:     return SetAttr(kNameSpaceID_None, aAttr, EmptyString(), true);
80486:   }
80486: 
80486:   return UnsetAttr(kNameSpaceID_None, aAttr, true);
    1: }
    1: 
    1: nsresult
79445: nsGenericHTMLElement::GetBoolAttr(nsIAtom* aAttr, bool* aValue) const
    1: {
    1:   *aValue = HasAttr(kNameSpaceID_None, aAttr);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetIntAttr(nsIAtom* aAttr, PRInt32 aDefault, PRInt32* aResult)
    1: {
    1:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
    1:   if (attrVal && attrVal->Type() == nsAttrValue::eInteger) {
    1:     *aResult = attrVal->GetIntegerValue();
    1:   }
    1:   else {
    1:     *aResult = aDefault;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetIntAttr(nsIAtom* aAttr, PRInt32 aValue)
    1: {
    1:   nsAutoString value;
    1:   value.AppendInt(aValue);
    1: 
80486:   return SetAttr(kNameSpaceID_None, aAttr, value, true);
    1: }
    1: 
    1: nsresult
56994: nsGenericHTMLElement::GetUnsignedIntAttr(nsIAtom* aAttr, PRUint32 aDefault,
56994:                                          PRUint32* aResult)
56994: {
56994:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
56994:   if (attrVal && attrVal->Type() == nsAttrValue::eInteger) {
56994:     *aResult = attrVal->GetIntegerValue();
56994:   }
56994:   else {
56994:     *aResult = aDefault;
56994:   }
56994:   return NS_OK;
56994: }
56994: 
56994: nsresult
56994: nsGenericHTMLElement::SetUnsignedIntAttr(nsIAtom* aAttr, PRUint32 aValue)
56994: {
56994:   nsAutoString value;
56994:   value.AppendInt(aValue);
56994: 
80486:   return SetAttr(kNameSpaceID_None, aAttr, value, true);
56994: }
56994: 
56994: nsresult
63879: nsGenericHTMLElement::GetDoubleAttr(nsIAtom* aAttr, double aDefault, double* aResult)
15751: {
15751:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
63879:   if (attrVal && attrVal->Type() == nsAttrValue::eDoubleValue) {
63879:     *aResult = attrVal->GetDoubleValue();
15751:   }
15751:   else {
15751:     *aResult = aDefault;
15751:   }
15751:   return NS_OK;
15751: }
15751: 
15751: nsresult
63879: nsGenericHTMLElement::SetDoubleAttr(nsIAtom* aAttr, double aValue)
15751: {
15751:   nsAutoString value;
15751:   value.AppendFloat(aValue);
15751: 
80486:   return SetAttr(kNameSpaceID_None, aAttr, value, true);
15751: }
15751: 
15751: nsresult
    1: nsGenericHTMLElement::GetURIAttr(nsIAtom* aAttr, nsIAtom* aBaseAttr, nsAString& aResult)
    1: {
25979:   nsCOMPtr<nsIURI> uri;
79445:   bool hadAttr = GetURIAttr(aAttr, aBaseAttr, getter_AddRefs(uri));
56659:   if (!hadAttr) {
    1:     aResult.Truncate();
    1:     return NS_OK;
    1:   }
    1: 
56659:   if (!uri) {
56659:     // Just return the attr value
56659:     GetAttr(kNameSpaceID_None, aAttr, aResult);
56659:     return NS_OK;
56659:   }
56659: 
25979:   nsCAutoString spec;
25979:   uri->GetSpec(spec);
25979:   CopyUTF8toUTF16(spec, aResult);
25979:   return NS_OK;
25979: }
25979: 
79445: bool
70015: nsGenericHTMLElement::GetURIAttr(nsIAtom* aAttr, nsIAtom* aBaseAttr, nsIURI** aURI) const
25979: {
25979:   *aURI = nsnull;
25979: 
25979:   const nsAttrValue* attr = mAttrsAndChildren.GetAttr(aAttr);
25979:   if (!attr) {
80486:     return false;
25979:   }
25979: 
    1:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
    1: 
    1:   if (aBaseAttr) {
    1:     nsAutoString baseAttrValue;
    1:     if (GetAttr(kNameSpaceID_None, aBaseAttr, baseAttrValue)) {
    1:       nsCOMPtr<nsIURI> baseAttrURI;
25979:       nsresult rv =
25979:         nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(baseAttrURI),
80526:                                                   baseAttrValue, OwnerDoc(),
    1:                                                   baseURI);
    1:       if (NS_FAILED(rv)) {
80486:         return true;
    1:       }
    1:       baseURI.swap(baseAttrURI);
    1:     }
    1:   }
    1: 
25979:   // Don't care about return value.  If it fails, we still want to
80486:   // return true, and *aURI will be null.
25979:   nsContentUtils::NewURIWithDocumentCharset(aURI,
25979:                                             attr->GetStringValue(),
80526:                                             OwnerDoc(), baseURI);
80486:   return true;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetURIListAttr(nsIAtom* aAttr, nsAString& aResult)
    1: {
    1:   aResult.Truncate();
    1: 
    1:   nsAutoString value;
    1:   if (!GetAttr(kNameSpaceID_None, aAttr, value))
    1:     return NS_OK;
    1: 
80526:   nsIDocument* doc = OwnerDoc(); 
    1:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
    1: 
    1:   // Value contains relative URIs split on spaces (U+0020)
    1:   const PRUnichar *start = value.BeginReading();
    1:   const PRUnichar *end   = value.EndReading();
    1:   const PRUnichar *iter  = start;
    1:   for (;;) {
    1:     if (iter < end && *iter != ' ') {
    1:       ++iter;
    1:     } else {  // iter is pointing at either end or a space
    1:       while (*start == ' ' && start < iter)
    1:         ++start;
    1:       if (iter != start) {
    1:         if (!aResult.IsEmpty())
    1:           aResult.Append(PRUnichar(' '));
    1:         const nsSubstring& uriPart = Substring(start, iter);
    1:         nsCOMPtr<nsIURI> attrURI;
    1:         nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(attrURI),
    1:                                                   uriPart, doc, baseURI);
    1:         if (attrURI) {
    1:           nsCAutoString spec;
    1:           attrURI->GetSpec(spec);
    1:           AppendUTF8toUTF16(spec, aResult);
    1:         } else {
    1:           aResult.Append(uriPart);
    1:         }
    1:       }
    1:       start = iter = iter + 1;
    1:       if (iter >= end)
    1:         break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 2896: nsresult
41437: nsGenericHTMLElement::GetEnumAttr(nsIAtom* aAttr,
41437:                                   const char* aDefault,
41437:                                   nsAString& aResult)
41437: {
41437:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
41437: 
41437:   aResult.Truncate();
41437: 
41437:   if (attrVal && attrVal->Type() == nsAttrValue::eEnum) {
80486:     attrVal->GetEnumString(aResult, true);
71265:   } else if (aDefault) {
41437:     AppendASCIItoUTF16(nsDependentCString(aDefault), aResult);
41437:   }
41437: 
41437:   return NS_OK;
41437: }
41437: 
41437: nsresult
 2896: nsGenericHTMLElement::GetContentEditable(nsAString& aContentEditable)
 2896: {
 2896:   ContentEditableTristate value = GetContentEditableValue();
 2896: 
 2896:   if (value == eTrue) {
 2896:     aContentEditable.AssignLiteral("true");
 2896:   }
 2896:   else if (value == eFalse) {
 2896:     aContentEditable.AssignLiteral("false");
 2896:   }
 2896:   else {
 2896:     aContentEditable.AssignLiteral("inherit");
 2896:   }
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
 2896: nsresult
 2896: nsGenericHTMLElement::SetContentEditable(const nsAString& aContentEditable)
 2896: {
 2896:   nsString contentEditable;
 2896:   ToLowerCase(aContentEditable, contentEditable);
 2896: 
 2896:   if (contentEditable.EqualsLiteral("inherit")) {
80486:     UnsetAttr(kNameSpaceID_None, nsGkAtoms::contenteditable, true);
 2896: 
 2896:     return NS_OK;
 2896:   }
 2896: 
 2896:   if (!contentEditable.EqualsLiteral("true") &&
 2896:       !contentEditable.EqualsLiteral("false")) {
 2896:     return NS_ERROR_DOM_SYNTAX_ERR;
 2896:   }
 2896: 
 2896:   SetAttr(kNameSpaceID_None, nsGkAtoms::contenteditable, contentEditable,
80486:           true);
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
39457: nsresult
79445: nsGenericHTMLElement::GetIsContentEditable(bool* aContentEditable)
39457: {
39457:   NS_ENSURE_ARG_POINTER(aContentEditable);
39457: 
39457:   for (nsIContent* node = this; node; node = node->GetParent()) {
39457:     nsGenericHTMLElement* element = FromContent(node);
39457:     if (element) {
39457:       ContentEditableTristate value = element->GetContentEditableValue();
39457:       if (value != eInherit) {
39457:         *aContentEditable = value == eTrue;
39457:         return NS_OK;
39457:       }
39457:     }
39457:   }
39457: 
80486:   *aContentEditable = false;
39457:   return NS_OK;
39457: }
39457: 
75019: nsresult
75019: nsGenericHTMLElement::GetContextMenu(nsIDOMHTMLMenuElement** aContextMenu)
75019: {
75019:   *aContextMenu = nsnull;
75019: 
75019:   nsAutoString value;
75019:   GetAttr(kNameSpaceID_None, nsGkAtoms::contextmenu, value);
75019: 
75019:   if (value.IsEmpty()) {
75019:     return NS_OK;
75019:   }
75019: 
75019:   nsIDocument* doc = GetCurrentDoc();
75019:   if (doc) {
75019:     nsRefPtr<nsHTMLMenuElement> element =
75019:       nsHTMLMenuElement::FromContent(doc->GetElementById(value));
75019:     element.forget(aContextMenu);
75019:   }
75019: 
75019:   return NS_OK;
75019: }
75019: 
    1: //----------------------------------------------------------------------
    1: 
56074: NS_IMPL_INT_ATTR(nsGenericHTMLFrameElement, TabIndex, tabindex)
86957: NS_IMPL_BOOL_ATTR(nsGenericHTMLFrameElement, MozBrowser, mozbrowser)
    1: 
48124: nsGenericHTMLFormElement::nsGenericHTMLFormElement(already_AddRefed<nsINodeInfo> aNodeInfo)
54342:   : nsGenericHTMLElement(aNodeInfo)
54342:   , mForm(nsnull)
54342:   , mFieldSet(nsnull)
    1: {
71121:   // We should add the NS_EVENT_STATE_ENABLED bit here as needed, but
71121:   // that depends on our type, which is not initialized yet.  So we
71121:   // have to do this in subclasses.
    1: }
    1: 
    1: nsGenericHTMLFormElement::~nsGenericHTMLFormElement()
    1: {
56935:   if (mFieldSet) {
78416:     mFieldSet->RemoveElement(this);
56935:   }
56935: 
33311:   // Check that this element doesn't know anything about its form at this point.
54342:   NS_ASSERTION(!mForm, "mForm should be null at this point!");
    1: }
    1: 
 4838: NS_IMPL_QUERY_INTERFACE_INHERITED1(nsGenericHTMLFormElement,
 4838:                                    nsGenericHTMLElement,
 4838:                                    nsIFormControl)
    1: 
79445: bool
    1: nsGenericHTMLFormElement::IsNodeOfType(PRUint32 aFlags) const
    1: {
41646:   return !(aFlags & ~(eCONTENT | eHTML_FORM_CONTROL));
    1: }
    1: 
 8462: void
14188: nsGenericHTMLFormElement::SaveSubtreeState()
 8462: {
 8462:   SaveState();
 8462: 
14188:   nsGenericHTMLElement::SaveSubtreeState();
 8462: }
 8462: 
19131: void
19131: nsGenericHTMLFormElement::SetForm(nsIDOMHTMLFormElement* aForm)
19131: {
19131:   NS_PRECONDITION(aForm, "Don't pass null here");
19131:   NS_ASSERTION(!mForm,
19131:                "We don't support switching from one non-null form to another.");
19131: 
19131:   // keep a *weak* ref to the form here
34395:   mForm = static_cast<nsHTMLFormElement*>(aForm);
19131: }
19131: 
19131: void
79445: nsGenericHTMLFormElement::ClearForm(bool aRemoveFromForm)
    1: {
19131:   NS_ASSERTION((mForm != nsnull) == HasFlag(ADDED_TO_FORM),
19131:                "Form control should have had flag set correctly");
19131: 
19131:   if (!mForm) {
19131:     return;
19131:   }
19131:   
18976:   if (aRemoveFromForm) {
    1:     nsAutoString nameVal, idVal;
    1:     GetAttr(kNameSpaceID_None, nsGkAtoms::name, nameVal);
    1:     GetAttr(kNameSpaceID_None, nsGkAtoms::id, idVal);
 4014: 
57333:     mForm->RemoveElement(this, true);
    1: 
    1:     if (!nameVal.IsEmpty()) {
    1:       mForm->RemoveElementFromTable(this, nameVal);
    1:     }
    1: 
    1:     if (!idVal.IsEmpty()) {
    1:       mForm->RemoveElementFromTable(this, idVal);
    1:     }
18976:   }
 4014: 
 4014:   UnsetFlags(ADDED_TO_FORM);
18976:   mForm = nsnull;
    1: }
    1: 
47801: Element*
47801: nsGenericHTMLFormElement::GetFormElement()
47801: {
47801:   return mForm;
47801: }
47801: 
47801: nsresult
    1: nsGenericHTMLFormElement::GetForm(nsIDOMHTMLFormElement** aForm)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aForm);
34395:   NS_IF_ADDREF(*aForm = mForm);
    1:   return NS_OK;
    1: }
    1: 
82843: nsIContent::IMEState
    1: nsGenericHTMLFormElement::GetDesiredIMEState()
    1: {
    1:   nsCOMPtr<nsIEditor> editor = nsnull;
    1:   nsresult rv = GetEditorInternal(getter_AddRefs(editor));
    1:   if (NS_FAILED(rv) || !editor)
    1:     return nsGenericHTMLElement::GetDesiredIMEState();
    1:   nsCOMPtr<nsIEditorIMESupport> imeEditor = do_QueryInterface(editor);
    1:   if (!imeEditor)
    1:     return nsGenericHTMLElement::GetDesiredIMEState();
82843:   IMEState state;
    1:   rv = imeEditor->GetPreferredIMEState(&state);
    1:   if (NS_FAILED(rv))
    1:     return nsGenericHTMLElement::GetDesiredIMEState();
    1:   return state;
    1: }
    1: 
79445: bool
79445: nsGenericHTMLFrameElement::IsHTMLFocusable(bool aWithMouse,
79445:                                            bool *aIsFocusable,
14348:                                            PRInt32 *aTabIndex)
    1: {
43884:   if (nsGenericHTMLElement::IsHTMLFocusable(aWithMouse, aIsFocusable, aTabIndex)) {
80486:     return true;
    1:   }
    1: 
55189:   *aIsFocusable = nsContentUtils::IsSubDocumentTabbable(this);
55189: 
55189:   if (!*aIsFocusable && aTabIndex) {
    1:     *aTabIndex = -1;
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFormElement::BindToTree(nsIDocument* aDocument,
    1:                                      nsIContent* aParent,
    1:                                      nsIContent* aBindingParent,
79445:                                      bool aCompileEventHandlers)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
    1:                                                  aBindingParent,
    1:                                                  aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
42460: 
42460:   // An autofocus event has to be launched if the autofocus attribute is
42460:   // specified and the element accept the autofocus attribute. In addition,
42460:   // the document should not be already loaded and the "browser.autofocus"
42460:   // preference should be 'true'.
63766:   if (IsAutofocusable() && HasAttr(kNameSpaceID_None, nsGkAtoms::autofocus) &&
79445:       Preferences::GetBool("browser.autofocus", true)) {
42460:     nsCOMPtr<nsIRunnable> event = new nsAutoFocusEvent(this);
42460:     rv = NS_DispatchToCurrentThread(event);
42460:     NS_ENSURE_SUCCESS(rv, rv);
42460:   }
42460: 
51492:   // If @form is set, the element *has* to be in a document, otherwise it
51492:   // wouldn't be possible to find an element with the corresponding id.
51492:   // If @form isn't set, the element *has* to have a parent, otherwise it
51492:   // wouldn't be possible to find a form ancestor.
51496:   // We should not call UpdateFormOwner if none of these conditions are
51492:   // fulfilled.
51492:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::form) ? !!GetCurrentDoc()
51492:                                                   : !!aParent) {
51301:     UpdateFormOwner(true, nsnull);
 4014:   }
 4014: 
54342:   // Set parent fieldset which should be used for the disabled state.
80486:   UpdateFieldSet(false);
54342: 
 4014:   return NS_OK;
    1: }
    1: 
    1: void
79445: nsGenericHTMLFormElement::UnbindFromTree(bool aDeep, bool aNullParent)
    1: {
    1:   // Save state before doing anything
    1:   SaveState();
    1:   
    1:   if (mForm) {
    1:     // Might need to unset mForm
    1:     if (aNullParent) {
    1:       // No more parent means no more form
80486:       ClearForm(true);
    1:     } else {
    1:       // Recheck whether we should still have an mForm.
51301:       if (HasAttr(kNameSpaceID_None, nsGkAtoms::form) ||
51301:           !FindAncestorForm(mForm)) {
80486:         ClearForm(true);
 7654:       } else {
 7654:         UnsetFlags(MAYBE_ORPHAN_FORM_ELEMENT);
    1:       }
    1:     }
71121: 
71121:     if (!mForm) {
71121:       // Our novalidate state might have changed
71121:       UpdateState(false);
71121:     }
    1:   }
    1: 
51301:   // We have to remove the form id observer if there was one.
51301:   // We will re-add one later if needed (during bind to tree).
51301:   if (nsContentUtils::HasNonEmptyAttr(this, kNameSpaceID_None,
51301:                                       nsGkAtoms::form)) {
51301:     RemoveFormIdObserver();
51301:   }
51301: 
    1:   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
54342: 
54342:   // The element might not have a fieldset anymore.
80486:   UpdateFieldSet(false);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFormElement::BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
79445:                                         const nsAString* aValue, bool aNotify)
    1: {
    1:   if (aNameSpaceID == kNameSpaceID_None) {
    1:     nsAutoString tmp;
    1: 
    1:     // remove the control from the hashtable as needed
    1: 
    1:     if (mForm && (aName == nsGkAtoms::name || aName == nsGkAtoms::id)) {
    1:       GetAttr(kNameSpaceID_None, aName, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->RemoveElementFromTable(this, tmp);
    1:       }
    1:     }
    1: 
    1:     if (mForm && aName == nsGkAtoms::type) {
    1:       GetAttr(kNameSpaceID_None, nsGkAtoms::name, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->RemoveElementFromTable(this, tmp);
    1:       }
    1: 
    1:       GetAttr(kNameSpaceID_None, nsGkAtoms::id, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->RemoveElementFromTable(this, tmp);
    1:       }
    1: 
57333:       mForm->RemoveElement(this, false);
 3410: 
 3410:       // Removing the element from the form can make it not be the default
 3410:       // control anymore.  Go ahead and notify on that change, though we might
 3410:       // end up readding and becoming the default control again in
 3410:       // AfterSetAttr.
71121:       // FIXME: Bug 656197
71121:       UpdateState(aNotify);
    1:     }
51301: 
51301:     if (aName == nsGkAtoms::form) {
51301:       // If @form isn't set or set to the empty string, there were no observer
51301:       // so we don't have to remove it.
51301:       if (nsContentUtils::HasNonEmptyAttr(this, kNameSpaceID_None,
51301:                                           nsGkAtoms::form)) {
51301:         // The current form id observer is no longer needed.
51301:         // A new one may be added in AfterSetAttr.
51301:         RemoveFormIdObserver();
51301:       }
51301:     }
    1:   }
    1: 
    1:   return nsGenericHTMLElement::BeforeSetAttr(aNameSpaceID, aName,
    1:                                              aValue, aNotify);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFormElement::AfterSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
79445:                                        const nsAString* aValue, bool aNotify)
    1: {
    1:   if (aNameSpaceID == kNameSpaceID_None) {
    1:     // add the control to the hashtable as needed
    1: 
    1:     if (mForm && (aName == nsGkAtoms::name || aName == nsGkAtoms::id) &&
    1:         aValue) {
    1:       if (!aValue->IsEmpty()) {
    1:         mForm->AddElementToTable(this, *aValue);
    1:       }
    1:     }
    1: 
    1:     if (mForm && aName == nsGkAtoms::type) {
    1:       nsAutoString tmp;
    1: 
    1:       GetAttr(kNameSpaceID_None, nsGkAtoms::name, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->AddElementToTable(this, tmp);
    1:       }
    1: 
    1:       GetAttr(kNameSpaceID_None, nsGkAtoms::id, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->AddElementToTable(this, tmp);
    1:       }
    1: 
55187:       mForm->AddElement(this, false, aNotify);
    1: 
 3410:       // Adding the element to the form can make it be the default control .
 3410:       // Go ahead and notify on that change.
    1:       // Note: no need to notify on CanBeDisabled(), since type attr
    1:       // changes can't affect that.
71121:       UpdateState(aNotify);
    1:     }
51301: 
51301:     if (aName == nsGkAtoms::form) {
51301:       // We need a new form id observer.
51301:       nsIDocument* doc = GetCurrentDoc();
51301:       if (doc) {
51301:         Element* formIdElement = nsnull;
51301:         if (aValue && !aValue->IsEmpty()) {
51301:           formIdElement = AddFormIdObserver();
51301:         }
51301: 
51301:         // Because we have a new @form value (or no more @form), we have to
51301:         // update our form owner.
51301:         UpdateFormOwner(false, formIdElement);
51301:       }
51301:     }
    1:   }
    1: 
    1:   return nsGenericHTMLElement::AfterSetAttr(aNameSpaceID, aName,
    1:                                             aValue, aNotify);
    1: }
    1: 
29018: nsresult
29018: nsGenericHTMLFormElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
29018: {
29018:   if (NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
29018:     switch (aVisitor.mEvent->message) {
29018:       case NS_FOCUS_CONTENT:
29018:       {
29018:         // Check to see if focus has bubbled up from a form control's
29018:         // child textfield or button.  If that's the case, don't focus
29018:         // this parent file control -- leave focus on the child.
80486:         nsIFormControlFrame* formControlFrame = GetFormControlFrame(true);
29018:         if (formControlFrame &&
29018:             aVisitor.mEvent->originalTarget == static_cast<nsINode*>(this))
80486:           formControlFrame->SetFocus(true, true);
29018:         break;
29018:       }
29018:       case NS_BLUR_CONTENT:
29018:       {
80486:         nsIFormControlFrame* formControlFrame = GetFormControlFrame(true);
29018:         if (formControlFrame)
80486:           formControlFrame->SetFocus(false, false);
29018:         break;
29018:       }
29018:     }
29018:   }
29018: 
29018:   return nsGenericHTMLElement::PreHandleEvent(aVisitor);
29018: }
29018: 
78416: /* virtual */
78416: bool
78416: nsGenericHTMLFormElement::IsDisabled() const
78416: {
78416:   return HasAttr(kNameSpaceID_None, nsGkAtoms::disabled) ||
78416:          (mFieldSet && mFieldSet->IsDisabled());
78416: }
78416: 
78416: void
78416: nsGenericHTMLFormElement::ForgetFieldSet(nsIContent* aFieldset)
78416: {
78416:   if (mFieldSet == aFieldset) {
78416:     mFieldSet = nsnull;
78416:   }
78416: }
78416: 
79445: bool
    1: nsGenericHTMLFormElement::CanBeDisabled() const
    1: {
    1:   PRInt32 type = GetType();
    1:   // It's easier to test the types that _cannot_ be disabled
    1:   return
    1:     type != NS_FORM_LABEL &&
41438:     type != NS_FORM_OBJECT &&
69585:     type != NS_FORM_OUTPUT &&
69585:     type != NS_FORM_PROGRESS;
    1: }
    1: 
79445: bool
79445: nsGenericHTMLFormElement::IsHTMLFocusable(bool aWithMouse,
79445:                                           bool* aIsFocusable,
60074:                                           PRInt32* aTabIndex)
60074: {
60074:   if (nsGenericHTMLElement::IsHTMLFocusable(aWithMouse, aIsFocusable, aTabIndex)) {
80486:     return true;
60074:   }
60074: 
60074: #ifdef XP_MACOSX
60074:   *aIsFocusable =
60074:     (!aWithMouse || nsFocusManager::sMouseFocusesFormControl) && *aIsFocusable;
60074: #endif
80486:   return false;
60074: }
60074: 
56168: nsEventStates
    1: nsGenericHTMLFormElement::IntrinsicState() const
    1: {
    1:   // If you add attribute-dependent states here, you need to add them them to
    1:   // AfterSetAttr too.  And add them to AfterSetAttr for all subclasses that
    1:   // implement IntrinsicState() and are affected by that attribute.
56168:   nsEventStates state = nsGenericHTMLElement::IntrinsicState();
    1: 
    1:   if (CanBeDisabled()) {
    1:     // :enabled/:disabled
54342:     if (IsDisabled()) {
    1:       state |= NS_EVENT_STATE_DISABLED;
    1:       state &= ~NS_EVENT_STATE_ENABLED;
    1:     } else {
    1:       state &= ~NS_EVENT_STATE_DISABLED;
    1:       state |= NS_EVENT_STATE_ENABLED;
    1:     }
    1:   }
    1:   
32864:   if (mForm && mForm->IsDefaultSubmitElement(this)) {
    1:       NS_ASSERTION(IsSubmitControl(),
    1:                    "Default submit element that isn't a submit control.");
    1:       // We are the default submit element (:default)
    1:       state |= NS_EVENT_STATE_DEFAULT;
    1:   }
    1: 
    1:   return state;
    1: }
    1: 
20109: nsGenericHTMLFormElement::FocusTristate
20109: nsGenericHTMLFormElement::FocusState()
20109: {
20109:   // We can't be focused if we aren't in a document
20109:   nsIDocument* doc = GetCurrentDoc();
20109:   if (!doc)
20109:     return eUnfocusable;
20109: 
20109:   // first see if we are disabled or not. If disabled then do nothing.
54342:   if (IsDisabled()) {
20109:     return eUnfocusable;
20109:   }
20109: 
20109:   // If the window is not active, do not allow the focus to bring the
20109:   // window to the front.  We update the focus controller, but do
20109:   // nothing else.
30219:   nsPIDOMWindow* win = doc->GetWindow();
30219:   if (win) {
30219:     nsCOMPtr<nsIDOMWindow> rootWindow = do_QueryInterface(win->GetPrivateRoot());
29018: 
29018:     nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:     if (fm && rootWindow) {
29018:       nsCOMPtr<nsIDOMWindow> activeWindow;
29018:       fm->GetActiveWindow(getter_AddRefs(activeWindow));
29018:       if (activeWindow == rootWindow) {
29018:         return eActiveWindow;
29018:       }
29018:     }
29018:   }
20109: 
20109:   return eInactiveWindow;
20109: }
20109: 
51301: Element*
51301: nsGenericHTMLFormElement::AddFormIdObserver()
51301: {
51301:   NS_ASSERTION(GetCurrentDoc(), "When adding a form id observer, "
51301:                                 "we should be in a document!");
51301: 
51301:   nsAutoString formId;
80526:   nsIDocument* doc = OwnerDoc();
51301:   GetAttr(kNameSpaceID_None, nsGkAtoms::form, formId);
51301:   NS_ASSERTION(!formId.IsEmpty(),
51301:                "@form value should not be the empty string!");
51301:   nsCOMPtr<nsIAtom> atom = do_GetAtom(formId);
51301: 
80486:   return doc->AddIDTargetObserver(atom, FormIdUpdated, this, false);
51301: }
51301: 
51301: void
51301: nsGenericHTMLFormElement::RemoveFormIdObserver()
51301: {
51301:   /**
80526:    * We are using OwnerDoc() because we don't really care about having the
51301:    * element actually being in the tree. If it is not and @form value changes,
51301:    * this method will be called for nothing but removing an observer which does
51301:    * not exist doesn't cost so much (no entry in the hash table) so having a
51301:    * boolean for GetCurrentDoc()/GetOwnerDoc() would make everything look more
51301:    * complex for nothing.
51301:    */
51301: 
80526:   nsIDocument* doc = OwnerDoc();
51301: 
51301:   // At this point, we may not have a document anymore. In that case, we can't
51301:   // remove the observer. The document did that for us.
51301:   if (!doc) {
51301:     return;
51301:   }
51301: 
51301:   nsAutoString formId;
51301:   GetAttr(kNameSpaceID_None, nsGkAtoms::form, formId);
51301:   NS_ASSERTION(!formId.IsEmpty(),
51301:                "@form value should not be the empty string!");
51301:   nsCOMPtr<nsIAtom> atom = do_GetAtom(formId);
51301: 
80486:   doc->RemoveIDTargetObserver(atom, FormIdUpdated, this, false);
51301: }
51301: 
51301: 
51301: /* static */
79445: bool
51301: nsGenericHTMLFormElement::FormIdUpdated(Element* aOldElement,
51301:                                         Element* aNewElement,
51301:                                         void* aData)
51301: {
51301:   nsGenericHTMLFormElement* element =
51301:     static_cast<nsGenericHTMLFormElement*>(aData);
51301: 
51301:   NS_ASSERTION(element->IsHTML(), "aData should be an HTML element");
51301: 
51301:   element->UpdateFormOwner(false, aNewElement);
51301: 
80486:   return true;
51301: }
51301: 
79445: bool 
74002: nsGenericHTMLFormElement::IsElementDisabledForEvents(PRUint32 aMessage, 
74002:                                                     nsIFrame* aFrame)
74002: {
79445:   bool disabled = IsDisabled();
74002:   if (!disabled && aFrame) {
74002:     const nsStyleUserInterface* uiStyle = aFrame->GetStyleUserInterface();
74002:     disabled = uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE ||
74002:       uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED;
74002: 
74002:   }
74002:   return disabled && aMessage != NS_MOUSE_MOVE;
74002: }
74002: 
51301: void
51301: nsGenericHTMLFormElement::UpdateFormOwner(bool aBindToTree,
51301:                                           Element* aFormIdElement)
51301: {
51301:   NS_PRECONDITION(!aBindToTree || !aFormIdElement,
51301:                   "aFormIdElement shouldn't be set if aBindToTree is true!");
51301: 
79445:   bool needStateUpdate = false;
71120:   if (!aBindToTree) {
71121:     needStateUpdate = mForm && mForm->IsDefaultSubmitElement(this);
80486:     ClearForm(true);
71121:   }
71121: 
71121:   nsHTMLFormElement *oldForm = mForm;
51301: 
51301:   if (!mForm) {
51301:     // If @form is set, we have to use that to find the form.
51301:     nsAutoString formId;
51301:     if (GetAttr(kNameSpaceID_None, nsGkAtoms::form, formId)) {
51301:       if (!formId.IsEmpty()) {
51301:         Element* element = nsnull;
51301: 
51301:         if (aBindToTree) {
51301:           element = AddFormIdObserver();
51301:         } else {
51301:           element = aFormIdElement;
51301:         }
51301: 
51301:         NS_ASSERTION(GetCurrentDoc(), "The element should be in a document "
51301:                                       "when UpdateFormOwner is called!");
51492:         NS_ASSERTION(!GetCurrentDoc() ||
51492:                      element == GetCurrentDoc()->GetElementById(formId),
51301:                      "element should be equals to the current element "
51301:                      "associated with the id in @form!");
51301: 
82292:         if (element && element->IsHTML(nsGkAtoms::form)) {
51301:           mForm = static_cast<nsHTMLFormElement*>(element);
51301:         }
51301:       }
51301:      } else {
51301:       // We now have a parent, so we may have picked up an ancestor form.  Search
51301:       // for it.  Note that if mForm is already set we don't want to do this,
51301:       // because that means someone (probably the content sink) has already set
51301:       // it to the right value.  Also note that even if being bound here didn't
51301:       // change our parent, we still need to search, since our parent chain
51301:       // probably changed _somewhere_.
51301:       mForm = FindAncestorForm();
51301:     }
51301:   }
51301: 
51301:   if (mForm && !HasFlag(ADDED_TO_FORM)) {
51301:     // Now we need to add ourselves to the form
51301:     nsAutoString nameVal, idVal;
51301:     GetAttr(kNameSpaceID_None, nsGkAtoms::name, nameVal);
51301:     GetAttr(kNameSpaceID_None, nsGkAtoms::id, idVal);
51301: 
51301:     SetFlags(ADDED_TO_FORM);
51301: 
51301:     // Notify only if we just found this mForm.
71121:     mForm->AddElement(this, true, oldForm == nsnull);
51301: 
51301:     if (!nameVal.IsEmpty()) {
51301:       mForm->AddElementToTable(this, nameVal);
51301:     }
51301: 
51301:     if (!idVal.IsEmpty()) {
51301:       mForm->AddElementToTable(this, idVal);
51301:     }
51301:   }
71121: 
71121:   if (mForm != oldForm || needStateUpdate) {
71121:     UpdateState(true);
71121:   }
51301: }
51301: 
54342: void
79445: nsGenericHTMLFormElement::UpdateFieldSet(bool aNotify)
54342: {
54346:   nsIContent* parent = nsnull;
54346:   nsIContent* prev = nsnull;
54346: 
54346:   for (parent = GetParent(); parent;
54346:        prev = parent, parent = parent->GetParent()) {
54346:     nsHTMLFieldSetElement* fieldset =
78416:       nsHTMLFieldSetElement::FromContent(parent);
78416:     if (fieldset &&
78416:         (!prev || fieldset->GetFirstLegend() != prev)) {
71121:       if (mFieldSet == fieldset) {
71121:         // We already have the right fieldset;
71121:         return;
71121:       }
71121: 
56935:       if (mFieldSet) {
78416:         mFieldSet->RemoveElement(this);
56935:       }
54346:       mFieldSet = fieldset;
56935:       fieldset->AddElement(this);
71121: 
71121:       // The disabled state may have changed
71121:       FieldSetDisabledChanged(aNotify);
54342:       return;
54342:     }
54342:   }
54342: 
54342:   // No fieldset found.
56935:   if (mFieldSet) {
78416:     mFieldSet->RemoveElement(this);
54342:     mFieldSet = nsnull;
71121:     // The disabled state may have changed
71121:     FieldSetDisabledChanged(aNotify);
71121:   }
54342: }
54342: 
54342: void
79445: nsGenericHTMLFormElement::FieldSetDisabledChanged(bool aNotify)
54342: {
71121:   UpdateState(aNotify);
54342: }
54342: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsGenericHTMLFrameElement::~nsGenericHTMLFrameElement()
    1: {
    1:   if (mFrameLoader) {
    1:     mFrameLoader->Destroy();
    1:   }
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGenericHTMLFrameElement)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsGenericHTMLFrameElement,
    1:                                                   nsGenericHTMLElement)
60322:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mFrameLoader, nsIFrameLoader)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
12033: NS_INTERFACE_TABLE_HEAD(nsGenericHTMLFrameElement)
86957:   NS_INTERFACE_TABLE_INHERITED2(nsGenericHTMLFrameElement,
86957:                                 nsIFrameLoaderOwner,
86957:                                 nsIDOMMozBrowserFrameElement)
12033:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsGenericHTMLFrameElement)
12033: NS_INTERFACE_MAP_END_INHERITING(nsGenericHTMLElement)
12033: 
    1: nsresult
    1: nsGenericHTMLFrameElement::GetContentDocument(nsIDOMDocument** aContentDocument)
    1: {
    1:   NS_PRECONDITION(aContentDocument, "Null out param");
    1:   *aContentDocument = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMWindow> win;
    1:   GetContentWindow(getter_AddRefs(win));
    1: 
    1:   if (!win) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return win->GetDocument(aContentDocument);
    1: }
    1: 
80402: nsresult
    1: nsGenericHTMLFrameElement::GetContentWindow(nsIDOMWindow** aContentWindow)
    1: {
    1:   NS_PRECONDITION(aContentWindow, "Null out param");
    1:   *aContentWindow = nsnull;
    1: 
    1:   nsresult rv = EnsureFrameLoader();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!mFrameLoader) {
    1:     return NS_OK;
    1:   }
    1: 
79445:   bool depthTooGreat = false;
    1:   mFrameLoader->GetDepthTooGreat(&depthTooGreat);
    1:   if (depthTooGreat) {
    1:     // Claim to have no contentWindow
    1:     return NS_OK;
    1:   }
    1:   
    1:   nsCOMPtr<nsIDocShell> doc_shell;
    1:   mFrameLoader->GetDocShell(getter_AddRefs(doc_shell));
    1: 
    1:   nsCOMPtr<nsPIDOMWindow> win(do_GetInterface(doc_shell));
    1: 
    1:   if (!win) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ASSERTION(win->IsOuterWindow(),
    1:                "Uh, this window should always be an outer window!");
    1: 
    1:   return CallQueryInterface(win, aContentWindow);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFrameElement::EnsureFrameLoader()
    1: {
    1:   if (!GetParent() || !IsInDoc() || mFrameLoader) {
    1:     // If frame loader is there, we just keep it around, cached
    1:     return NS_OK;
    1:   }
    1: 
50721:   mFrameLoader = nsFrameLoader::Create(this, mNetworkCreated);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericHTMLFrameElement::GetFrameLoader(nsIFrameLoader **aFrameLoader)
    1: {
    1:   NS_IF_ADDREF(*aFrameLoader = mFrameLoader);
    1:   return NS_OK;
    1: }
    1: 
34076: NS_IMETHODIMP_(already_AddRefed<nsFrameLoader>)
34076: nsGenericHTMLFrameElement::GetFrameLoader()
34076: {
82292:   nsRefPtr<nsFrameLoader> loader = mFrameLoader;
82292:   return loader.forget();
34076: }
34076: 
16549: NS_IMETHODIMP
16549: nsGenericHTMLFrameElement::SwapFrameLoaders(nsIFrameLoaderOwner* aOtherOwner)
16549: {
16549:   // We don't support this yet
16549:   return NS_ERROR_NOT_IMPLEMENTED;
16549: }
16549: 
    1: nsresult
    1: nsGenericHTMLFrameElement::LoadSrc()
    1: {
    1:   nsresult rv = EnsureFrameLoader();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!mFrameLoader) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   rv = mFrameLoader->LoadFrame();
    1: #ifdef DEBUG
    1:   if (NS_FAILED(rv)) {
    1:     NS_WARNING("failed to load URL");
    1:   }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFrameElement::BindToTree(nsIDocument* aDocument,
    1:                                       nsIContent* aParent,
    1:                                       nsIContent* aBindingParent,
79445:                                       bool aCompileEventHandlers)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
    1:                                                  aBindingParent,
    1:                                                  aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aDocument) {
23256:     NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
23256:                  "Missing a script blocker!");
    1:     // We're in a document now.  Kick off the frame load.
    1:     LoadSrc();
    1:   }
    1: 
50721:   // We're now in document and scripts may move us, so clear
50721:   // the mNetworkCreated flag.
80486:   mNetworkCreated = false;
    1:   return rv;
    1: }
    1: 
    1: void
79445: nsGenericHTMLFrameElement::UnbindFromTree(bool aDeep, bool aNullParent)
    1: {
    1:   if (mFrameLoader) {
    1:     // This iframe is being taken out of the document, destroy the
    1:     // iframe's frame loader (doing that will tear down the window in
    1:     // this iframe).
    1:     // XXXbz we really want to only partially destroy the frame
    1:     // loader... we don't want to tear down the docshell.  Food for
    1:     // later bug.
    1:     mFrameLoader->Destroy();
    1:     mFrameLoader = nsnull;
    1:   }
    1: 
    1:   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFrameElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                                    nsIAtom* aPrefix, const nsAString& aValue,
79445:                                    bool aNotify)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::SetAttr(aNameSpaceID, aName, aPrefix,
    1:                                               aValue, aNotify);
38663:   NS_ENSURE_SUCCESS(rv, rv);
38663:   
82292:   if (aNameSpaceID == kNameSpaceID_None && aName == nsGkAtoms::src) {
38663:     // Don't propagate error here. The attribute was successfully set, that's
38663:     // what we should reflect.
38663:     LoadSrc();
38663:   }
38663: 
38663:   return NS_OK;
    1: }
    1: 
 8462: void
 8462: nsGenericHTMLFrameElement::DestroyContent()
 8462: {
 8462:   if (mFrameLoader) {
 8462:     mFrameLoader->Destroy();
 8462:     mFrameLoader = nsnull;
 8462:   }
 8462: 
 8462:   nsGenericHTMLElement::DestroyContent();
 8462: }
 8462: 
35581: nsresult
35581: nsGenericHTMLFrameElement::CopyInnerTo(nsGenericElement* aDest) const
35581: {
35581:   nsresult rv = nsGenericHTMLElement::CopyInnerTo(aDest);
35581:   NS_ENSURE_SUCCESS(rv, rv);
35581: 
80526:   nsIDocument* doc = aDest->OwnerDoc();
35581:   if (doc->IsStaticDocument() && mFrameLoader) {
35581:     nsGenericHTMLFrameElement* dest =
35581:       static_cast<nsGenericHTMLFrameElement*>(aDest);
80486:     nsFrameLoader* fl = nsFrameLoader::Create(dest, false);
35581:     NS_ENSURE_STATE(fl);
35581:     dest->mFrameLoader = fl;
35581:     static_cast<nsFrameLoader*>(mFrameLoader.get())->CreateStaticClone(fl);
35581:   }
35581: 
35581:   return rv;
35581: }
35581: 
74269: PRInt64
74269: nsGenericHTMLFrameElement::SizeOf() const
74269: {
74269:   PRInt64 size = MemoryReporter::GetBasicSize<nsGenericHTMLFrameElement,
74269:                                               nsGenericHTMLElement>(this);
74269:   // TODO: need to implement SizeOf() in nsFrameLoader, bug 672539.
74269:   size += mFrameLoader ? sizeof(*mFrameLoader.get()) : 0;
74269:   return size;
74269: }
74269: 
86957: namespace {
86957: 
86957: // GetContentStateCallbackRunnable is used by MozGetContentState to fire its callback
86957: // asynchronously.
86957: class GetContentStateCallbackRunnable : public nsRunnable
86957: {
86957: public:
86957:   GetContentStateCallbackRunnable(nsIDOMMozGetContentStateCallback *aCallback,
86957:                              nsIDOMEventTarget *aEventTarget,
86957:                              const nsAString &aResult)
86957:     : mCallback(aCallback)
86957:     , mEventTarget(aEventTarget)
86957:     , mResult(aResult)
86957:   {
86957:   }
86957: 
86957:   NS_IMETHOD Run()
86957:   {
86957:     FireCallback();
86957: 
86957:     // Break cycles.
86957:     mCallback = NULL;
86957:     mEventTarget = NULL;
86957:     return NS_OK;
86957:   }
86957: 
86957: private:
86957:   void FireCallback()
86957:   {
86957:     nsCxPusher pusher;
86957:     if (!pusher.Push(mEventTarget)) {
86957:       return;
86957:     }
86957: 
86957:     mCallback->Callback(mResult);
86957:   }
86957: 
86957:   nsCOMPtr<nsIDOMMozGetContentStateCallback> mCallback;
86957:   nsCOMPtr<nsIDOMEventTarget> mEventTarget;
86957:   const nsString mResult;
86957: };
86957: 
86957: } // anonymous namespace
86957: 
86957: nsresult
86957: nsGenericHTMLFrameElement::BrowserFrameSecurityCheck()
86957: {
86957:   if (!Preferences::GetBool("dom.mozBrowserFramesEnabled")) {
86957:     return NS_ERROR_FAILURE;
86957:   }
86957: 
86957:   bool browser;
86957:   GetMozBrowser(&browser);
86957:   if (!browser) {
86957:     return NS_ERROR_FAILURE;
86957:   }
86957: 
86957:   nsIPrincipal *principal = NodePrincipal();
86957:   nsCOMPtr<nsIURI> principalURI;
86957:   principal->GetURI(getter_AddRefs(principalURI));
86957:   if (!nsContentUtils::URIIsChromeOrInPref(principalURI,
86957:                                            "dom.mozBrowserFramesWhitelist")) {
86957:     return NS_ERROR_DOM_SECURITY_ERR;
86957:   }
86957: 
86957:   return NS_OK;
86957: }
86957: 
86957: NS_IMETHODIMP
86957: nsGenericHTMLFrameElement::MozGetContentState(const nsAString &aProperty,
86957:                                               nsIDOMMozGetContentStateCallback *aCallback)
86957: {
86957:   nsresult rv = BrowserFrameSecurityCheck();
86957:   NS_ENSURE_SUCCESS(rv, rv);
86957: 
86957:   if (!aProperty.EqualsLiteral("location")) {
86957:     return NS_ERROR_FAILURE;
86957:   }
86957: 
86957:   nsCOMPtr<nsIDOMWindow> contentWindow;
86957:   GetContentWindow(getter_AddRefs(contentWindow));
86957:   NS_ENSURE_TRUE(contentWindow, NS_ERROR_FAILURE);
86957: 
86957:   nsCOMPtr<nsIDOMLocation> location;
86957:   rv = contentWindow->GetLocation(getter_AddRefs(location));
86957:   NS_ENSURE_SUCCESS(rv, rv);
86957: 
86957:   nsAutoString href;
86957:   rv = location->ToString(href);
86957:   NS_ENSURE_SUCCESS(rv, rv);
86957: 
86957:   nsCOMPtr<nsIDOMEventTarget> eventTarget =
86957:     do_QueryInterface(nsContentUtils::GetWindowFromCaller());
86957:   NS_ENSURE_TRUE(eventTarget, NS_ERROR_FAILURE);
86957: 
86957:   // Asynchronously fire the callback.
86957:   nsRefPtr<GetContentStateCallbackRunnable> runnable =
86957:     new GetContentStateCallbackRunnable(aCallback, eventTarget, href);
86957:   NS_DispatchToMainThread(runnable);
86957:   return NS_OK;
86957: }
86957: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsGenericHTMLElement::Blur()
    1: {
82292:   if (!ShouldBlur(this)) {
29018:     return NS_OK;
82292:   }
29018: 
29018:   nsIDocument* doc = GetCurrentDoc();
82292:   if (!doc) {
29018:     return NS_OK;
82292:   }
29018: 
29018:   nsIDOMWindow* win = doc->GetWindow();
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   return (win && fm) ? fm->ClearFocus(win) : NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::Focus()
    1: {
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(this);
29018:   return fm ? fm->SetFocus(elem, 0) : NS_OK;
    1: }
    1: 
77843: nsresult nsGenericHTMLElement::MozRequestFullScreen()
77843: {
77848:   // Only grant full-screen requests if this is called from inside a trusted
77848:   // event handler (i.e. inside an event handler for a user initiated event).
77848:   // This stops the full-screen from being abused similar to the popups of old,
77848:   // and it also makes it harder for bad guys' script to go full-screen and
77848:   // spoof the browser chrome/window and phish logins etc.
81437:   if (!nsContentUtils::IsRequestFullScreenAllowed()) {
84636:     nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
84636:                                     "DOM", OwnerDoc(),
84636:                                     nsContentUtils::eDOM_PROPERTIES,
84636:                                     "FullScreenDeniedNotInputDriven");
84833:     nsRefPtr<nsAsyncDOMEvent> e =
84833:       new nsAsyncDOMEvent(OwnerDoc(),
81201:                           NS_LITERAL_STRING("mozfullscreenerror"),
81201:                           true,
81201:                           false);
81201:     e->PostDOMEvent();
77843:     return NS_OK;
77843:   }
77843: 
81437:   OwnerDoc()->AsyncRequestFullScreen(this);
81437: 
77843:   return NS_OK;
77843: }
77843: 
67818: nsresult nsGenericHTMLElement::Click()
67818: {
67818:   if (HasFlag(NODE_HANDLING_CLICK))
67818:     return NS_OK;
67818: 
67818:   // Strong in case the event kills it
67818:   nsCOMPtr<nsIDocument> doc = GetCurrentDoc();
67818: 
82292:   nsCOMPtr<nsIPresShell> shell;
82292:   nsRefPtr<nsPresContext> context;
67818:   if (doc) {
67818:     shell = doc->GetShell();
67818:     if (shell) {
67818:       context = shell->GetPresContext();
67818:     }
67818:   }
67818: 
67818:   SetFlags(NODE_HANDLING_CLICK);
67818: 
67818:   // Click() is never called from native code, but it may be
67818:   // called from chrome JS. Mark this event trusted if Click()
67818:   // is called from chrome code.
67818:   nsMouseEvent event(nsContentUtils::IsCallerChrome(),
67818:                      NS_MOUSE_CLICK, nsnull, nsMouseEvent::eReal);
77227:   event.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_UNKNOWN;
67818: 
67818:   nsEventDispatcher::Dispatch(this, context, &event);
67818: 
67818:   UnsetFlags(NODE_HANDLING_CLICK);
67818:   return NS_OK;
67818: }
67818: 
79445: bool
79445: nsGenericHTMLElement::IsHTMLFocusable(bool aWithMouse,
79445:                                       bool *aIsFocusable,
43884:                                       PRInt32 *aTabIndex)
    1: {
12253:   nsIDocument *doc = GetCurrentDoc();
12253:   if (!doc || doc->HasFlag(NODE_IS_EDITABLE)) {
12253:     // In designMode documents we only allow focusing the document.
12253:     if (aTabIndex) {
12253:       *aTabIndex = -1;
12253:     }
12253: 
80486:     *aIsFocusable = false;
80486: 
80486:     return true;
12253:   }
12253: 
    1:   PRInt32 tabIndex = 0;   // Default value for non HTML elements with -moz-user-focus
    1:   GetTabIndex(&tabIndex);
    1: 
79445:   bool override, disabled = false;
 2896:   if (IsEditableRoot()) {
14348:     // Editable roots should always be focusable.
80486:     override = true;
14348: 
 3444:     // Ignore the disabled attribute in editable contentEditable/designMode
 3444:     // roots.
 2896:     if (!HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
 3444:       // The default value for tabindex should be 0 for editable
 3444:       // contentEditable roots.
 2896:       tabIndex = 0;
 2896:     }
 2896:   }
 2896:   else {
80486:     override = false;
14348: 
29018:     // Just check for disabled attribute on form controls
54342:     disabled = IsDisabled();
    1:     if (disabled) {
    1:       tabIndex = -1;
    1:     }
 2896:   }
    1: 
    1:   if (aTabIndex) {
    1:     *aTabIndex = tabIndex;
    1:   }
    1: 
    1:   // If a tabindex is specified at all, or the default tabindex is 0, we're focusable
43884:   *aIsFocusable = 
43884:     (tabIndex >= 0 || (!disabled && HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)));
14348: 
14348:   return override;
    1: }
    1: 
    1: void
79445: nsGenericHTMLElement::RegUnRegAccessKey(bool aDoReg)
    1: {
    1:   // first check to see if we have an access key
    1:   nsAutoString accessKey;
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);
    1:   if (accessKey.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // We have an access key, so get the ESM from the pres context.
    1:   nsPresContext *presContext = GetPresContext();
    1: 
    1:   if (presContext) {
68780:     nsEventStateManager *esm = presContext->EventStateManager();
    1: 
    1:     // Register or unregister as appropriate.
    1:     if (aDoReg) {
    1:       esm->RegisterAccessKey(this, (PRUint32)accessKey.First());
    1:     } else {
    1:       esm->UnregisterAccessKey(this, (PRUint32)accessKey.First());
    1:     }
    1:   }
    1: }
    1: 
    1: void
79445: nsGenericHTMLElement::PerformAccesskey(bool aKeyCausesActivation,
79445:                                        bool aIsTrustedEvent)
    1: {
    1:   nsPresContext *presContext = GetPresContext();
    1:   if (!presContext)
    1:     return;
    1: 
    1:   // It's hard to say what HTML4 wants us to do in all cases.
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm) {
29018:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(this);
29018:     fm->SetFocus(elem, nsIFocusManager::FLAG_BYKEY);
29018:   }
    1: 
    1:   if (aKeyCausesActivation) {
    1:     // Click on it if the users prefs indicate to do so.
    1:     nsMouseEvent event(aIsTrustedEvent, NS_MOUSE_CLICK,
    1:                        nsnull, nsMouseEvent::eReal);
77227:     event.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_KEYBOARD;
    1: 
    1:     nsAutoPopupStatePusher popupStatePusher(aIsTrustedEvent ?
    1:                                             openAllowed : openAbused);
    1: 
    1:     nsEventDispatcher::Dispatch(this, presContext, &event);
    1:   }
    1: }
    1: 
    1: const nsAttrName*
    1: nsGenericHTMLElement::InternalGetExistingAttrNameFromQName(const nsAString& aStr) const
    1: {
29004:   if (IsInHTMLDocument()) {
    1:     nsAutoString lower;
38422:     nsContentUtils::ASCIIToLower(aStr, lower);
39101:     return mAttrsAndChildren.GetExistingAttrNameFromQName(lower);
39101:   }
39101: 
39101:   return mAttrsAndChildren.GetExistingAttrNameFromQName(aStr);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetEditor(nsIEditor** aEditor)
    1: {
    1:   *aEditor = nsnull;
    1: 
82292:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
    1:     return NS_ERROR_DOM_SECURITY_ERR;
82292:   }
    1: 
    1:   return GetEditorInternal(aEditor);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetEditorInternal(nsIEditor** aEditor)
    1: {
    1:   *aEditor = nsnull;
    1: 
43129:   nsCOMPtr<nsITextControlElement> textCtrl = do_QueryInterface(this);
43129:   if (textCtrl) {
43129:     *aEditor = textCtrl->GetTextEditor();
43129:     NS_IF_ADDREF(*aEditor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: already_AddRefed<nsIEditor>
    1: nsGenericHTMLElement::GetAssociatedEditor()
    1: {
    1:   // If contenteditable is ever implemented, it might need to do something different here?
    1: 
    1:   nsIEditor* editor = nsnull;
    1:   GetEditorInternal(&editor);
    1:   return editor;
    1: }
    1: 
79445: bool
    1: nsGenericHTMLElement::IsCurrentBodyElement()
    1: {
82292:   // TODO Bug 698498: Should this handle the case where GetBody returns a
82292:   //                  frameset?
    1:   nsCOMPtr<nsIDOMHTMLBodyElement> bodyElement = do_QueryInterface(this);
    1:   if (!bodyElement) {
80486:     return false;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDocument =
    1:     do_QueryInterface(GetCurrentDoc());
    1:   if (!htmlDocument) {
80486:     return false;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMHTMLElement> htmlElement;
    1:   htmlDocument->GetBody(getter_AddRefs(htmlElement));
    1:   return htmlElement == bodyElement;
    1: }
    1: 
    1: // static
    1: void
    1: nsGenericHTMLElement::SyncEditorsOnSubtree(nsIContent* content)
    1: {
    1:   /* Sync this node */
    1:   nsGenericHTMLElement* element = FromContent(content);
    1:   if (element) {
    1:     nsCOMPtr<nsIEditor> editor = element->GetAssociatedEditor();
    1:     if (editor) {
    1:       editor->SyncRealTimeSpell();
    1:     }
    1:   }
    1: 
    1:   /* Sync all children */
78992:   for (nsIContent* child = content->GetFirstChild();
78992:        child;
78992:        child = child->GetNextSibling()) {
78992:     SyncEditorsOnSubtree(child);
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::RecompileScriptEventListeners()
    1: {
    1:     PRInt32 i, count = mAttrsAndChildren.AttrCount();
    1:     for (i = 0; i < count; ++i) {
    1:         const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
    1: 
    1:         // Eventlistenener-attributes are always in the null namespace
    1:         if (!name->IsAtom()) {
    1:             continue;
    1:         }
    1: 
    1:         nsIAtom *attr = name->Atom();
  265:         if (!nsContentUtils::IsEventAttributeName(attr, EventNameType_HTML)) {
    1:             continue;
    1:         }
    1: 
    1:         nsAutoString value;
    1:         GetAttr(kNameSpaceID_None, attr, value);
80486:         AddScriptEventListener(attr, value, true);
    1:     }
    1: }
 2896: 
79445: bool
 2896: nsGenericHTMLElement::IsEditableRoot() const
 2896: {
 2896:   nsIDocument *document = GetCurrentDoc();
 2896:   if (!document) {
80486:     return false;
 2896:   }
 2896: 
 2896:   if (document->HasFlag(NODE_IS_EDITABLE)) {
80486:     return false;
 2896:   }
 2896: 
 3444:   if (GetContentEditableValue() != eTrue) {
80486:     return false;
 2896:   }
 2896: 
 2896:   nsIContent *parent = GetParent();
 2896: 
 2896:   return !parent || !parent->HasFlag(NODE_IS_EDITABLE);
 2896: }
 2896: 
 2896: static void
 2896: MakeContentDescendantsEditable(nsIContent *aContent, nsIDocument *aDocument)
 2896: {
71110:   // If aContent is not an element, we just need to update its
71110:   // internal editable state and don't need to notify anyone about
71110:   // that.  For elements, we need to send a ContentStateChanged
71110:   // notification.
71110:   if (!aContent->IsElement()) {
80486:     aContent->UpdateEditableState(false);
71110:     return;
71110:   }
71110: 
71110:   Element *element = aContent->AsElement();
71121: 
80486:   element->UpdateEditableState(true);
 2896: 
71110:   for (nsIContent *child = aContent->GetFirstChild();
71110:        child;
71110:        child = child->GetNextSibling()) {
 2896:     if (!child->HasAttr(kNameSpaceID_None, nsGkAtoms::contenteditable)) {
 2896:       MakeContentDescendantsEditable(child, aDocument);
 2896:     }
 2896:   }
 2896: }
 2896: 
 2896: void
 2896: nsGenericHTMLElement::ChangeEditableState(PRInt32 aChange)
 2896: {
 2896:   nsIDocument* document = GetCurrentDoc();
 2896:   if (!document) {
 2896:     return;
 2896:   }
 2896: 
 2896:   if (aChange != 0) {
 2896:     nsCOMPtr<nsIHTMLDocument> htmlDocument =
 2896:       do_QueryInterface(document);
 2896:     if (htmlDocument) {
 2896:       htmlDocument->ChangeContentEditableCount(this, aChange);
 2896:     }
 2896:   }
 2896: 
 2896:   if (document->HasFlag(NODE_IS_EDITABLE)) {
 2896:     document = nsnull;
 2896:   }
 2896: 
64120:   // MakeContentDescendantsEditable is going to call ContentStateChanged for
52197:   // this element and all descendants if editable state has changed.
71103:   // We might as well wrap it all in one script blocker.
71103:   nsAutoScriptBlocker scriptBlocker;
 2896:   MakeContentDescendantsEditable(this, document);
 2896: }
