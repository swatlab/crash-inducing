47840: <html xmlns="http://www.w3.org/1999/xhtml">
47840: <!--
47840: https://bugzilla.mozilla.org/show_bug.cgi?id=515116
47840: -->
47840: <head>
47840:   <title>Generic tests for SVG animated length lists</title>
47840:   <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
78857:   <script type="text/javascript" src="matrixUtils.js"></script>
90212:   <script type="text/javascript" src="MutationEventChecker.js"></script>
47840:   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
47840: </head>
47840: <body>
47840: <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=515116">Mozilla Bug 515116</a>
47840: <p id="display"></p>
47840: <div id="content" style="display:none;">
62660: <svg id="svg" xmlns="http://www.w3.org/2000/svg" width="100" height="100"
62660:      onload="this.pauseAnimations();">
58554:   <desc>
58554:     <filter>
58554:       <feComponentTransfer>
58554:         <feFuncR id="feFuncR" type="table"/>
58554:       </feComponentTransfer>
58554:     </filter>
58554:   </desc>
47840:   <text id="text">text</text>
57113:   <path id="path"/>
58893:   <polyline id="polyline"/>
78857:   <g id="g"/>
47840: </svg>
47840: </div>
47840: <pre id="test">
47840: <script class="testbody" type="text/javascript">
47840: <![CDATA[
47840: 
47840: 
47840: SimpleTest.waitForExplicitFinish();
47840: 
47840: /*
47840: This file runs a series of type-agnostic tests to check the state of the mini DOM trees that represent various SVG 'list' attributes (including checking the "object identity" of the objects in those trees) in the face of various changes, both with and without the complication of SMIL animation being active.
47840: 
47840: For additional high level information on the tests that are run, see the comment for 'create_animate_elements' below.
47840: 
47840: To have the battery of generic tests run for a new list attribute, add an element with that attribute to the document, then add a JavaScript object literal to the following 'tests' array with the following properties:
47840: 
47840:   target_element_id
47840:     The ID of the element that has the attribute that is to be tested.
47840:   attr_name
47840:     The name of the attribute that is to be tested.
47840:   prop_name
47840:     The name of the DOM property that corresponds to the attribute that is to
47840:     be tested. For some list types the SVGAnimatedXxxList interface is
47840:     inherited by the element interface rather than the element having a
47840:     property of that type, and in others the list type is not animatable so
47840:     there is no SVGAnimatedXxxList interface for that list type. In these
47840:     cases this property should be set to null.
47840:   bv_name
47840:     The name of the DOM base value property for the attribute that is to be
47840:     tested. This is usually 'baseVal', but not always. In the case of
47840:     SVGStringList, which is not animatable, this is the name of the
47840:     SVGStringList property.
47840:   av_name
47840:     The name of the DOM anim value property for the attribute that is to be
47840:     tested. This is usually 'animVal' but not always. In the case of
47840:     SVGStringList, which is not animatable, this should be set to null.
47840:   el_type
47840:     The name of the SVGXxxElement interface on which the property corresponding
47840:     to the attribute being tested is defined.
47840:   prop_type
47840:     The name of the SVGAnimatedXxxList interface (e.g. SVGAnimatedLengthList),
47840:     if it exists, and if the element has a property is of this type (as
47840:     opposed to the element interface inheriting it).
47840:   list_type
47840:     The name of the SVGXxxList inteface implemented by the baseVal and
47840:     animVal objects.
47840:   item_type
47840:     The name of the SVGXxx interface implemented by the list items.
47840:   attr_val_3a:
47840:   attr_val_3b:
47840:     Two attribute values containing three different items.
47840:   attr_val_4
47840:     An attribute value containing four items.
47840:   attr_val_5a:
47840:   attr_val_5b:
47840:     Two attribute values containing five different items.
68501:   attr_val_5b_firstItem_x3_constructor:
68501:     Function to construct a list-item that should match the first item in a
68501:     SVGXxxList after three repeats of a cumulative animation to attr_val_5b.
68501:     This function takes t.item_constructor as its only argument.
62660:   item_constructor:
62660:     Function to create a dummy list item.
62660:   item_is:
62660:     Function to compare two list items for equality, like "is()". If this
62660:     property is omitted, it is assumed that we can just compare
62660:     "item.value" (which is the case for most list types).
47840: */
75331: //helper method
75331: function keys(obj) {
75331:     var rval = [];
75331:     for (var prop in obj) {
75331:         rval.push(prop);
75331:     }    
75331:     return rval;
75331: };
47840: 
47840: var tests = [
47840:   {
47840:     // SVGLengthList test:
47840:     target_element_id: 'text',
47840:     attr_name: 'x',
47840:     prop_name: 'x',
47840:     bv_name: 'baseVal',
47840:     av_name: 'animVal',
47840:     el_type: 'SVGTextElement',
47840:     prop_type: 'SVGAnimatedLengthList',
47840:     list_type: 'SVGLengthList',
47840:     item_type: 'SVGLength',
47840:     attr_val_3a: '10 20ex, 30in',
47840:     attr_val_3b: '30in 10, 20ex',
47840:     attr_val_4 : '10 20ex, 30in ,40cm',
47840:     attr_val_5a: '10 20ex, 30in ,40cm , 50%',
68501:     attr_val_5b: '20 50%, 20ex ,30in , 40cm',
68501:     attr_val_5b_firstItem_x3_constructor: function(constructor) {
68501:       var expected = constructor();
68501:       expected.value = 60;
68501:       return expected;
68501:     },
47840:     item_constructor: function() {
47840:       // We need this function literal to avoid "Illegal operation on
47840:       // WrappedNative prototype object" NS_ERROR_XPC_BAD_OP_ON_WN_PROTO.
47840:       return document.getElementById('svg').createSVGLength();
47840:     }
47840:   },
47840:   {
47840:     // SVGNumberList test:
47840:     target_element_id: 'text',
47840:     attr_name: 'rotate',
47840:     prop_name: 'rotate',
47840:     bv_name: 'baseVal',
47840:     av_name: 'animVal',
47840:     el_type: 'SVGTextElement',
47840:     prop_type: 'SVGAnimatedNumberList',
47840:     list_type: 'SVGNumberList',
47840:     item_type: 'SVGNumber',
58554:     attr_val_3a: '0 20 40',
58554:     attr_val_3b: '60 40 20',
58554:     attr_val_4 : '40 20 10 80',
58554:     attr_val_5a: '90 30 60 20 70',
58554:     attr_val_5b: '30 20 70 30 90',
68501:     attr_val_5b_firstItem_x3_constructor: function(constructor) {
68501:       var expected = constructor();
68501:       expected.value = 90;
68501:       return expected;
68501:     },
58554:     item_constructor: function() {
58554:       // We need this function literal to avoid "Illegal operation on
58554:       // WrappedNative prototype object" NS_ERROR_XPC_BAD_OP_ON_WN_PROTO.
58554:       return document.getElementById('svg').createSVGNumber();
58554:     }
47840:   },
47840:   {
47840:     // SVGNumberList test:
58554:     target_element_id: 'feFuncR',
47840:     attr_name: 'tableValues',
47840:     prop_name: 'tableValues',
47840:     bv_name: 'baseVal',
47840:     av_name: 'animVal',
58554:     el_type: 'SVGFEComponentTransferElement',
47840:     prop_type: 'SVGAnimatedNumberList',
47840:     list_type: 'SVGNumberList',
47840:     item_type: 'SVGNumber',
58554:     attr_val_3a: '0 .5 .2',
58554:     attr_val_3b: '1 .7 .1',
58554:     attr_val_4 : '.5 .3 .8 .2',
58554:     attr_val_5a: '3 4 5 6 7',
58554:     attr_val_5b: '7 6 5 4 3',
68501:     attr_val_5b_firstItem_x3_constructor: function(constructor) {
68501:       var expected = constructor();
68501:       expected.value = 21;
68501:       return expected;
68501:     },
58554:     item_constructor: function() {
58554:       // We need this function literal to avoid "Illegal operation on
58554:       // WrappedNative prototype object" NS_ERROR_XPC_BAD_OP_ON_WN_PROTO.
58554:       return document.getElementById('svg').createSVGNumber();
58554:     }
47840:   },
47840:   {
47840:     // SVGPointList test:
47840:     target_element_id: 'polyline',
47840:     attr_name: 'points',
47840:     prop_name: null, // SVGAnimatedPoints is an inherited interface!
47840:     bv_name: 'points',
47840:     av_name: 'animatedPoints',
57113:     el_type: 'SVGPolylineElement',
47840:     prop_type: null,
47840:     list_type: 'SVGPointList',
47840:     item_type: 'SVGPoint',
58893:     attr_val_3a: ' 10,10 50,50 90,10 ',
58893:     attr_val_3b: ' 10,50 50,10 90,50 ',
58893:     attr_val_4 : ' 10,10 50,50 90,10 200,100 ',
58893:     attr_val_5a: ' 10,10 50,50 90,10 130,50 170,10 ',
58893:     attr_val_5b: ' 50,10 50,10 90,50 130,10 170,50 ',
68501:     attr_val_5b_firstItem_x3_constructor: function(constructor) {
68501:       var expected = constructor();
68501:       expected.x = 150;
68501:       expected.y = 30;
68501:       return expected;
68501:     },
58893:     item_constructor: function() {
58893:       // XXX return different values each time
58893:       return document.getElementById('svg').createSVGPoint();
62660:     },
62660:     item_is: function(itemA, itemB, message) {
62660:       ok(typeof(itemA.x) != 'undefined' &&
62660:          typeof(itemB.x) != 'undefined',
62660:          'expecting x property');
62660:       ok(typeof(itemA.y) != 'undefined' &&
62660:          typeof(itemB.y) != 'undefined',
62660:          'expecting y property');
62660: 
62660:       is(itemA.x, itemB.x, message);
62660:       is(itemA.y, itemB.y, message);
58893:     }
47840:   },
47840:   {
47840:     // SVGPathSegList test:
47840:     target_element_id: 'path',
47840:     attr_name: 'd',
47840:     prop_name: null, // SVGAnimatedPathData is an inherited interface!
47840:     bv_name: 'pathSegList',
47840:     av_name: 'animatedPathSegList',
57113:     el_type: 'SVGPathElement',
47840:     prop_type: null,
47840:     list_type: 'SVGPathSegList',
47840:     item_type: 'SVGPathSeg',
57113:     attr_val_3a: 'M 10,10 L 50,50 L 90,10',
57113:     attr_val_3b: 'M 10,50 L 50,10 L 90,50',
57113:     attr_val_4 : 'M 10,10 L 50,50 L 90,10 M 200,100',
57113:     attr_val_5a: 'M 10,10 L 50,50 L 90,10 L 130,50 L 170,10',
57113:     attr_val_5b: 'M 50,10 L 50,10 L 90,50 L 130,10 L 170,50',
68501:     attr_val_5b_firstItem_x3_constructor: function(constructor) {
68501:       var expected = constructor();
68501:       is(expected.pathSegTypeAsLetter, "M",
68501:          "test error -- expected constructor to generate a segment of type M");
68501:       expected.x = 150;
68501:       expected.y = 30;
68501:       return expected;
68501:     },
47840:     item_constructor: function() {
47840:       // XXX return different values each time
57113:       return document.getElementById('path').createSVGPathSegMovetoAbs(1, 1);
62660:     },
62660:     item_is: function(itemA, itemB, message) {
68501:       ok(typeof(itemA.pathSegTypeAsLetter) != 'undefined' &&
68501:          typeof(itemB.pathSegTypeAsLetter) != 'undefined',
68501:          'expecting pathSegTypeAsLetter property');
62660: 
68501:       // First: are we dealing  with the same type of segment?
68501:       is(itemA.pathSegTypeAsLetter, itemB.pathSegTypeAsLetter, message);
68501:       if (itemA.pathSegTypeAsLetter != itemB.pathSegTypeAsLetter)
68501:         return;  // The rest of this function is nonsense if types don't match.
68501: 
68501:       // Make sure property-counts match (so we can iterate across itemA's
68501:       // properties and not worry about itemB having extra properties that
68501:       // we might be skipping over).
68501:       is(keys(itemA).length, keys(itemB).length,
68501:         'expecting same property-count when comparing path segs of same type.');
68501: 
68501:       // Compare the properties, skipping the constant properties inherited
68501:       // from 'SVGPathSeg', and skipping the pathSegTypeAsLetter field since we
68501:       // already checked that above. 
68501:       for (var prop in itemA) {
68501:         if (!SVGPathSeg.hasOwnProperty(prop) &&
68501:             prop != 'pathSegTypeAsLetter') {
68501:           is(itemA[prop], itemB[prop], message);
68501:         }
68501:       }
47840:     }
47840:   },
47840:   {
47840:     // SVGStringList test:
47840:     target_element_id: 'g',
47840:     attr_name: 'requiredFeatures', // requiredExtensions, systemLanguage, viewTarget
47840:     prop_name: null, // SVGStringList attributes are not animatable
47840:     bv_name: 'requiredFeatures',
47840:     av_name: null,
57113:     el_type: 'SVGGElement',
47840:     prop_type: null,
47840:     list_type: 'SVGStringList',
47840:     item_type: 'DOMString',
86429:     attr_val_3a: 'http://www.w3.org/TR/SVG11/feature#Shape http://www.w3.org/TR/SVG11/feature#Image ' +
86429:                  'http://www.w3.org/TR/SVG11/feature#Style',
86429:     attr_val_3b: 'http://www.w3.org/TR/SVG11/feature#CoreAttribute http://www.w3.org/TR/SVG11/feature#Structure ' +
86429:                  'http://www.w3.org/TR/SVG11/feature#Gradient',
86429:     attr_val_4 : 'http://www.w3.org/TR/SVG11/feature#Pattern http://www.w3.org/TR/SVG11/feature#Clip ' +
86429:                  'http://www.w3.org/TR/SVG11/feature#Mask http://www.w3.org/TR/SVG11/feature#Extensibility',
86429:     attr_val_5a: 'http://www.w3.org/TR/SVG11/feature#BasicStructure http://www.w3.org/TR/SVG11/feature#BasicText ' +
86429:                  'http://www.w3.org/TR/SVG11/feature#BasicPaintAttribute http://www.w3.org/TR/SVG11/feature#BasicGraphicsAttribute ' +
86429:                  'http://www.w3.org/TR/SVG11/feature#BasicClip',
86429:     attr_val_5b: 'http://www.w3.org/TR/SVG11/feature#DocumentEventsAttribute http://www.w3.org/TR/SVG11/feature#GraphicalEventsAttribute ' +
86429:                  'http://www.w3.org/TR/SVG11/feature#AnimationEventsAttribute http://www.w3.org/TR/SVG11/feature#Hyperlinking ' +
86429:                  'http://www.w3.org/TR/SVG11/feature#XlinkAttribute',
47840:     item_constructor: function() {
86429:       return 'http://www.w3.org/TR/SVG11/feature#XlinkAttribute';
47840:     }
47840:   },
47840:   {
47840:     // SVGTransformList test:
47840:     target_element_id: 'g',
47840:     attr_name: 'transform', // gradientTransform, patternTransform
47840:     prop_name: 'transform',
47840:     bv_name: 'baseVal',
47840:     av_name: 'animVal',
57113:     el_type: 'SVGGElement',
47840:     prop_type: 'SVGAnimatedTransformList',
47840:     list_type: 'SVGTransformList',
47840:     item_type: 'SVGTransform',
78857:     attr_val_3a: 'translate(20 10) rotate(90 10 10) skewX(45)',
78857:     attr_val_3b: 'translate(30 40) scale(2) matrix(1 2 3 4 5 6)',
78857:     attr_val_4 : 'scale(3 2) translate(19) skewY(2) rotate(-10)',
78857:     attr_val_5a:
78857:       'translate(20) rotate(-10) skewY(3) matrix(1 2 3 4 5 6) scale(0.5)',
78857:     attr_val_5b:
78857:       'skewX(45) rotate(45 -10 -10) skewX(-45) scale(2) matrix(6 5 4 3 2 1)',
78857:     // SVGTransformList animation addition is tested in
78857:     // test_SVGTransformListAddition.xhtml so we don't need:
78857:     // - attr_val_3b
78857:     // - attr_val_3b
78857:     // - attr_val_5b_firstItem_x3_constructor
78857:     // But we populate the first two anyway just in case they are later used for
78857:     // something other than testing animation.
78857:     // attr_val_5b_firstItem_x3_constructor is only used for animation
47840:     item_constructor: function() {
47840:       // XXX populate the matrix with different values each time
47840:       return document.getElementById('svg').createSVGTransform();
78857:     },
78857:     item_is: function(itemA, itemB, message) {
78857:       ok(typeof(itemA.type) != 'undefined' &&
78857:          typeof(itemB.type) != 'undefined',
78857:          'expecting type property');
78857:       ok(typeof(itemA.matrix) != 'undefined' &&
78857:          typeof(itemB.matrix) != 'undefined',
78857:          'expecting matrix property');
78857:       ok(typeof(itemA.angle) != 'undefined' &&
78857:          typeof(itemB.angle) != 'undefined',
78857:          'expecting matrix property');
78857: 
78857:       is(itemA.type, itemB.type, message);
78857:       is(itemA.angle, itemB.angle, message);
78857:       cmpMatrix(itemA.matrix, itemB.matrix, message);
47840:     }
47840:   },
47840: ];
47840: 
47840: 
47840: /*
47840: This function returns a DocumentFragment with three 'animate' element children. The duration of the three animations is as follows:
47840: 
68501:   animation 1: |  *-----------*-----------*-----------*
47840:   animation 2: |     *--*
47840:   animation 3: |                    *--*
68501:                |___________________________________________> time (s)
68501:                |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
68501:                0  1  2  3  4  5  6  7  8  9 10 11 12 13 14
47840: 
47840: The first animation repeats once so that we can test state on a repeat animation.
47840: 
47840: The second animation overrides the first animation for a short time, and has fewer list items than the first animation. This allows us to test object identity and other state on and after an overriding animation. Specifically, it allows us to check whether animVal list items are kept or discarded after the end of an overriding animation that has fewer items.
47840: 
47840: The third animation has additive="sum", with fewer items than the lower priority animation 1, allowing us to test object identity and other state in that scenario. TODO: some type aware tests to check whether the composite fails or works?
47840: 
62563: At t=0s and t=1s we test the effect of an attribute value changes in the absence and presence of SMIL animation respectively.
47840: 
47840: At t=10s we programatically remove the fill="freeze" from animation 1.
47840: */
47840: function create_animate_elements(test)
47840: {
47840:   var SVG_NS = 'http://www.w3.org/2000/svg';
47840:   var df = document.createDocumentFragment();
47840: 
78857:   if (is_transform_attr(test.attr_name)) {
78857:     // animateTransform is "special". Although it targets an
78857:     // nsSVGAnimatedTransformList it only takes nsSVGTransform values as
78857:     // animation values. Therefore all the assumptions we're testing about the
78857:     // length of lists don't apply. We simply have to test it separately.
78857:     // This is done in test_SVGTransformListAddition.xhtml.
78857:     return df; // Return the empty document fragment
78857:   }
78857: 
47840:   var animate1 = document.createElementNS(SVG_NS, 'animate');
47840:   var animate2 = document.createElementNS(SVG_NS, 'animate');
47840:   var animate3 = document.createElementNS(SVG_NS, 'animate');
47840: 
47840:   animate1.setAttribute('attributeName', test.attr_name);
47840:   animate1.setAttribute('from', test.attr_val_5a);
47840:   animate1.setAttribute('to', test.attr_val_5b);
47840:   animate1.setAttribute('begin', '1s');
47840:   animate1.setAttribute('dur', '4s');
68501:   animate1.setAttribute('repeatCount', '3');
68501:   animate1.setAttribute('accumulate', 'sum');
47840:   animate1.setAttribute('fill', 'freeze');
47840:   df.appendChild(animate1);
47840: 
47840:   animate2.setAttribute('attributeName', test.attr_name);
47840:   animate2.setAttribute('from', test.attr_val_3a);
47840:   animate2.setAttribute('to', test.attr_val_3b);
47840:   animate2.setAttribute('begin', '2s');
47840:   animate2.setAttribute('dur', '1s');
47840:   df.appendChild(animate2);
47840: 
47840:   animate3.setAttribute('attributeName', test.attr_name);
47840:   animate3.setAttribute('from', test.attr_val_3a);
47840:   animate3.setAttribute('to', test.attr_val_3b);
47840:   animate3.setAttribute('begin', '7s');
47840:   animate3.setAttribute('dur', '1s');
47840:   animate3.setAttribute('additive', 'sum');
47840:   df.appendChild(animate3);
47840: 
47840:   return df;
47840: }
47840: 
78857: function is_transform_attr(attr_name) {
78857:   return attr_name == 'transform' ||
78857:          attr_name == 'gradientTransform' ||
78857:          attr_name == 'patternTransform';
78857: }
78857: 
47840: function get_array_of_list_items(list)
47840: {
47840:   array = [];
47840:   for (var i = 0; i < list.numberOfItems; ++i) {
47840:     array.push(list.getItem(i));
47840:   }
47840:   return array;
47840: }
47840: 
47840: 
47840: /**
47840:  * This function tests the SVGXxxList API for the base val list. This means
47840:  * running tests for the following property and methods:
47840:  *
47840:  *   numberOfItems
47840:  *   clear()
47840:  *   SVGLength initialize(in SVGLength newItem)
47840:  *   SVGLength getItem(in unsigned long index)
47840:  *   SVGLength insertItemBefore(in SVGLength newItem, in unsigned long index)
47840:  *   SVGLength replaceItem(in SVGLength newItem, in unsigned long index)
47840:  *   SVGLength removeItem(in unsigned long index)
47840:  *   SVGLength appendItem(in SVGLength newItem)
47840:  *
47840:  * @param t A test from the 'tests' array.
47840:  */
47840: function run_baseVal_API_tests()
47840: {
47840:   var res, threw, items;
90212:   var eventChecker = new MutationEventChecker;
47840: 
47840:   for each (var t in tests) {
47840: 
47840:     // Test .clear():
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840: 
47840:     is(t.baseVal.numberOfItems, 4,
47840:        'The '+t.list_type+' object should contain four list items.');
47840: 
90212:     eventChecker.watchAttr(t.element, t.attr_name);
90212:     eventChecker.expect("modify");
47840:     res = t.baseVal.clear();
47840: 
47840:     is(t.baseVal.numberOfItems, 0,
47840:        'The method '+t.list_type+'.clear() should clear the '+t.list_type+
47840:        ' object.');
47840:     is(res, undefined,
47840:        'The method '+t.list_type+'.clear() should not return a value.');
90212:     ok(t.element.hasAttribute(t.attr_name),
90212:        'The method '+t.list_type+'.clear() should not remove the attribute.');
90212:     ok(t.element.getAttribute(t.attr_name) === "",
90212:        'Cleared '+t.attr_name+' ('+t.list_type+') but did not get an '+
90212:        'empty string back.');
90212: 
90212:     eventChecker.expect("");
90212:     t.baseVal.clear();
90212:     eventChecker.ignoreEvents();
90212: 
90212:     // Test empty strings
90212: 
90212:     t.element.setAttribute(t.attr_name, "");
90212:     ok(t.element.getAttribute(t.attr_name) === "",
90212:        'Set an empty attribute value for '+t.attr_name+' ('+t.list_type+
90212:        ') but did not get an empty string back.');
90212: 
90212:     // Test removed attributes
90212: 
90212:     t.element.removeAttribute(t.attr_name);
90212:     ok(t.element.getAttribute(t.attr_name) === null,
90212:        'Removed attribute value for '+t.attr_name+' ('+t.list_type+
90212:        ') but did not get null back.');
90212:     ok(!t.element.hasAttribute(t.attr_name),
90212:        'Removed attribute value for '+t.attr_name+' ('+t.list_type+
90212:        ') but hasAttribute still returns true.');
47840: 
47840:     // Test .initialize():
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840: 
47840:     var item = t.item_constructor();
90212:     // Our current implementation of 'initialize' for most list types performs
90212:     // a 'clear' followed by an 'insertItemBefore'. This results in two
90212:     // modification events being dispatched. SVGStringList however avoids the
90212:     // additional clear.
90212:     var expectedModEvents =
90212:       t.item_type == "DOMString" ? "modify" : "modify modify";
90212:     eventChecker.expect(expectedModEvents);
47840:     var res = t.baseVal.initialize(item);
90212:     eventChecker.ignoreEvents();
90212: 
47840: 
47840:     is(t.baseVal.numberOfItems, 1,
47840:        'The '+t.list_type+' object should contain one list item.');
47840:     ok(res === item,
47840:        'The list item returned by '+t.list_type+'.initialize() should be the '+
47840:        'exact same object as the item that was passed to that method, since '+
47840:        'the item that was passed to that method did not already belong to a '+
47840:        'list.');
47840:     ok(t.baseVal.getItem(0) === item,
47840:        'The list item at index 0 should be the exact same object as the '+
47840:        'object that was passed to the '+t.list_type+'.initialize() method, '+
47840:        'since the item that was passed to that method did not already '+
47840:        'belong to a list.');
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840: 
86429:     if (t.item_type != "DOMString") {
47840:       var old_items = get_array_of_list_items(t.baseVal);
47840:       item = t.baseVal.getItem(3);
47840:       res = t.baseVal.initialize(item);
47840: 
47840:       ok(res !== item &&
47840:          t.baseVal.getItem(0) !== item &&
47840:          t.baseVal.getItem(0) !== old_items[0] &&
47840:          res === t.baseVal.getItem(0),
47840:          'The method '+t.list_type+'.initialize() should clone the object that '+
47840:          'is passed in if that object is already in a list.');
47840:       // [SVGWG issue] not what the spec currently says
47840: 
86429: 
47840:       item = t.baseVal.getItem(0);
47840:       res = t.baseVal.initialize(item);
47840: 
47840:       ok(res !== item &&
47840:          t.baseVal.getItem(0) !== item,
47840:          'The method '+t.list_type+'.initialize() should clone the object that '+
47840:          'is passed in, even if that object is the only item in that list.');
47840:       // [SVGWG issue] not what the spec currently says
47840: 
90212:       eventChecker.expect("");
47840:       threw = false;
47840:       try {
47840:         t.baseVal.initialize({});
47840:       } catch(e) {
47840:         threw = true;
47840:       }
47840:       ok(threw,
47840:          'The method '+t.list_type+'.initialize() should throw if passed an '+
47840:          'object of the wrong type.');
90212:       eventChecker.ignoreEvents();
86429:     }
47840: 
47840:     // Test .insertItemBefore():
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840: 
47840:     old_items = get_array_of_list_items(t.baseVal);
47840:     item = t.item_constructor();
90212:     eventChecker.expect("modify");
47840:     res = t.baseVal.insertItemBefore(item, 2);
90212:     eventChecker.ignoreEvents();
47840: 
47840:     is(t.baseVal.numberOfItems, 5,
47840:        'The '+t.list_type+' object should contain five list items.');
47840:     ok(res === item,
47840:        'The list item returned by '+t.list_type+'.insertItemBefore() should '+
47840:        'be the exact same object as the item that was passed to that method, '+
47840:        'since the item that was passed to that method did not already belong '+
47840:        'to a list.');
47840:     ok(t.baseVal.getItem(2) === item,
47840:        'The list item at index 2 should be the exact same object as the '+
47840:        'object that was passed to the '+t.list_type+'.insertItemBefore() '+
47840:        'method, since the item that was passed to that method did not '+
47840:        'already belong to a list.');
47840:     ok(t.baseVal.getItem(3) === old_items[2],
47840:        'The list item that was at index 2 should be at index 3 after '+
47840:        'inserting a new item at index 2 using the '+t.list_type+
47840:        '.insertItemBefore() method.');
47840: 
47840:     item = t.item_constructor();
47840:     t.baseVal.insertItemBefore(item, 100);
47840: 
47840:     ok(t.baseVal.getItem(5) === item,
47840:        'When the index passed to the '+t.list_type+'.insertItemBefore() '+
47840:        'method is out of bounds, the supplied list item should be appended '+
47840:        'to the list.');
47840: 
47840:     item = t.baseVal.getItem(4);
47840:     res = t.baseVal.insertItemBefore(item, 2);
47840: 
47840:     is(t.baseVal.numberOfItems, 7,
47840:        'The '+t.list_type+' object should contain seven list items.');
86429:     if (t.item_type != "DOMString") {
47840:       ok(res !== item &&
47840:          t.baseVal.getItem(2) !== item &&
47840:          t.baseVal.getItem(2) !== old_items[2] &&
47840:          res === t.baseVal.getItem(2),
47840:          'The method '+t.list_type+'.insertItemBefore() should clone the '+
47840:          'object that is passed in if that object is already in a list.');
47840:       // [SVGWG issue] not what the spec currently says
86429:     }
47840: 
47840:     item = t.baseVal.getItem(2);
47840:     res = t.baseVal.insertItemBefore(item, 2);
47840: 
47840:     is(t.baseVal.numberOfItems, 8,
47840:        'The '+t.list_type+' object should contain eight list items.');
86429:     if (t.item_type != "DOMString") {
47840:       ok(res !== item &&
47840:          t.baseVal.getItem(2) !== item,
47840:          'The method '+t.list_type+'.insertItemBefore() should clone the '+
47840:          'object that is passed in, even if that object is the item in '+
47840:          'the list at the index specified.');
47840:       // [SVGWG issue] not what the spec currently says
47840: 
90212:       eventChecker.expect("");
47840:       threw = false;
47840:       try {
47840:         t.baseVal.insertItemBefore({}, 2);
47840:       } catch(e) {
47840:         threw = true;
47840:       }
47840:       ok(threw,
47840:          'The method '+t.list_type+'.insertItemBefore() should throw if passed '+
47840:          'an object of the wrong type.');
90212:       eventChecker.ignoreEvents();
86429:     }
47840: 
47840:     // Test .replaceItem():
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840: 
47840:     old_items = get_array_of_list_items(t.baseVal);
47840:     item = t.item_constructor();
90212:     eventChecker.expect("modify");
47840:     res = t.baseVal.replaceItem(item, 2);
90212:     eventChecker.ignoreEvents();
47840: 
47840:     is(t.baseVal.numberOfItems, 4,
47840:        'The '+t.list_type+' object should contain four list items.');
86429:     if (t.item_type != "DOMString") {
47840:       ok(res === item,
47840:          'The list item returned by '+t.list_type+'.replaceItem() should be '+
47840:          'the exact same object as the item that was passed to that method, '+
47840:          'since the item that was passed to that method did not already belong '+
47840:          'to a list.');
86429:     }
47840:     ok(t.baseVal.getItem(2) === item,
47840:        'The list item at index 2 should be the exact same object as the '+
47840:        'object that was passed to the '+t.list_type+'.replaceItem() method, '+
47840:        'since the item that was passed to that method did not already belong '+
47840:        'to a list.');
47840:     ok(t.baseVal.getItem(3) === old_items[3],
47840:        'The list item that was at index 3 should still be at index 3 after '+
47840:        'the item at index 2 was replaced using the '+t.list_type+
47840:        '.replaceItem() method.');
47840: 
47840:     item = t.item_constructor();
47840: 
90212:     eventChecker.expect("");
47840:     threw = false;
47840:     try {
47840:       t.baseVal.replaceItem(item, 100);
47840:     } catch(e) {
47840:       threw = true;
47840:     }
47840:     ok(threw,
47840:        'The method '+t.list_type+'.replaceItem() should throw if passed '+
47840:        'an index that is out of bounds.');
90212:     eventChecker.ignoreEvents();
47840: 
47840:     old_items = get_array_of_list_items(t.baseVal);
47840:     item = t.baseVal.getItem(3);
47840:     res = t.baseVal.replaceItem(item, 1);
47840: 
47840:     is(t.baseVal.numberOfItems, 4,
47840:        'The '+t.list_type+' object should contain four list items.');
86429:     if (t.item_type != "DOMString") {
47840:       ok(res !== item &&
47840:          t.baseVal.getItem(1) !== item &&
47840:          t.baseVal.getItem(1) !== old_items[1] &&
47840:          res === t.baseVal.getItem(1),
47840:          'The method '+t.list_type+'.replaceItem() should clone the object '+
47840:          'that is passed in if that object is already in a list.');
47840:       // [SVGWG issue] not what the spec currently says
86429:     }
47840: 
47840:     item = t.baseVal.getItem(1);
47840:     res = t.baseVal.replaceItem(item, 1);
47840: 
47840:     is(t.baseVal.numberOfItems, 4,
47840:        'The '+t.list_type+' object should contain four list items.');
86429:     if (t.item_type != "DOMString") {
47840:       ok(res !== item &&
47840:          t.baseVal.getItem(1) !== item,
47840:          'The method '+t.list_type+'.replaceItem() should clone the object '+
47840:          'that is passed in, even if the object that object and the object '+
47840:          'that is being replaced are the exact same objects.');
47840:       // [SVGWG issue] not what the spec currently says
47840: 
47840:       threw = false;
47840:       try {
47840:         t.baseVal.replaceItem({}, 2);
47840:       } catch(e) {
47840:         threw = true;
47840:       }
47840:       ok(threw,
47840:          'The method '+t.list_type+'.replaceItem() should throw if passed '+
47840:          'an object of the wrong type.');
86429:     }
47840: 
47840:     // Test .removeItem():
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840: 
47840:     old_items = get_array_of_list_items(t.baseVal);
47840:     item = t.baseVal.getItem(2);
90212:     eventChecker.expect("modify");
47840:     res = t.baseVal.removeItem(2);
90212:     eventChecker.ignoreEvents();
47840: 
47840:     is(t.baseVal.numberOfItems, 3,
47840:        'The '+t.list_type+' object should contain three list items.');
86429:     if (t.item_type != "DOMString") {
47840:       ok(res === item,
47840:          'The list item returned by '+t.list_type+'.removeItem() should be the '+
47840:          'exact same object as the item that was at the specified index.');
86429:     }
47840:     ok(t.baseVal.getItem(1) === old_items[1],
47840:        'The list item that was at index 1 should still be at index 1 after '+
47840:        'the item at index 2 was removed using the '+t.list_type+
47840:        '.replaceItem() method.');
47840:     ok(t.baseVal.getItem(2) === old_items[3],
47840:        'The list item that was at index 3 should still be at index 2 after '+
47840:        'the item at index 2 was removed using the '+t.list_type+
47840:        '.replaceItem() method.');
47840: 
90212:     eventChecker.expect("");
47840:     threw = false;
47840:     try {
47840:       t.baseVal.removeItem(100);
47840:     } catch(e) {
47840:       threw = true;
47840:     }
47840:     ok(threw,
47840:        'The method '+t.list_type+'.removeItem() should throw if passed '+
47840:        'an index that is out of bounds.');
90212:     eventChecker.ignoreEvents();
47840: 
47840:     // Test .appendItem():
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840: 
47840:     old_items = get_array_of_list_items(t.baseVal);
47840:     item = t.item_constructor();
90212:     eventChecker.expect("modify");
47840:     res = t.baseVal.appendItem(item);
90212:     eventChecker.ignoreEvents();
47840: 
47840:     is(t.baseVal.numberOfItems, 5,
47840:        'The '+t.list_type+' object should contain five list items.');
47840:     ok(res === item,
47840:        'The list item returned by '+t.list_type+'.appendItem() should be the '+
47840:        'exact same object as the item that was passed to that method, since '+
47840:        'the item that was passed to that method did not already belong '+
47840:        'to a list.');
47840:     ok(t.baseVal.getItem(4) === item,
47840:        'The last list item should be the exact same object as the object '+
47840:        'that was passed to the '+t.list_type+'.appendItem() method, since '+
47840:        'the item that was passed to that method did not already belong to '+
47840:        'a list.');
47840:     ok(t.baseVal.getItem(3) === old_items[3],
47840:        'The list item that was at index 4 should still be at index 4 after '+
47840:        'appending a new item using the '+t.list_type+'.appendItem() '+
47840:        'method.');
47840: 
47840:     item = t.baseVal.getItem(2);
47840:     res = t.baseVal.appendItem(item);
47840: 
47840:     is(t.baseVal.numberOfItems, 6,
47840:        'The '+t.list_type+' object should contain six list items.');
86429:     if (t.item_type != "DOMString") {
47840:       ok(res !== item &&
47840:          t.baseVal.getItem(5) !== item &&
47840:          res === t.baseVal.getItem(5),
47840:          'The method '+t.list_type+'.appendItem() should clone the object '+
47840:          'that is passed in if that object is already in a list.');
47840:       // [SVGWG issue] not what the spec currently says
86429:     }
47840: 
47840:     item = t.baseVal.getItem(5);
47840:     res = t.baseVal.appendItem(item);
47840: 
47840:     is(t.baseVal.numberOfItems, 7,
47840:        'The '+t.list_type+' object should contain seven list items.');
86429:     if (t.item_type != "DOMString") {
47840:       ok(res !== item &&
47840:          t.baseVal.getItem(6) !== item,
47840:          'The method '+t.list_type+'.appendItem() should clone the object '+
47840:          'that is passed in, if that object is already the last item in '+
47840:          'that list.');
47840:       // [SVGWG issue] not what the spec currently says
47840: 
90212:       eventChecker.expect("");
47840:       threw = false;
47840:       try {
47840:         t.baseVal.appendItem({});
47840:       } catch(e) {
47840:         threw = true;
47840:       }
47840:       ok(threw,
47840:          'The method '+t.list_type+'.appendItem() should throw if passed '+
47840:          'an object of the wrong type.');
90212:       eventChecker.ignoreEvents();
47840:     }
90212: 
90212:     // Test removal and addition events
90212: 
90212:     eventChecker.expect("remove add");
90212:     t.element.removeAttribute(t.attr_name);
91863:     t.element.removeAttributeNS(null, t.attr_name);
90212:     res = t.baseVal.appendItem(item);
90212:     eventChecker.finish();
47840:   }
86429: }
47840: 
47840: 
47840: /**
47840:  * This function tests the SVGXxxList API for the anim val list (see also the
47840:  * comment for test_baseVal_API).
47840:  */
47840: function run_animVal_API_tests()
47840: {
47840:   var threw, item;
47840: 
47840:   for each (var t in tests) {
47840:     if (!t.animVal)
47840:       continue; // SVGStringList isn't animatable
47840: 
47840:     item = t.item_constructor();
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840: 
47840:     is(t.animVal.numberOfItems, 4,
47840:        'The '+t.list_type+' object should contain four list items.');
47840: 
47840:     // Test .clear():
47840: 
47840:     threw = false;
47840:     try {
47840:       t.animVal.clear();
47840:     } catch(e) {
47840:       threw = true;
47840:     }
47840:     ok(threw,
47840:        'The method '+t.list_type+'.clear() should throw when called on an '+
47840:        'anim val list, since anim val lists should be readonly.');
47840: 
47840:     // Test .getItem():
47840: 
47840:     var item = t.animVal.getItem(2);
47840:     ok(item != null && item === t.animVal.getItem(2),
47840:        'The method '+t.list_type+'.getItem() should work when called on an '+
47840:        'anim val list, and always return the exact same object.');
47840: 
47840:     // .initialize()
47840: 
47840:     threw = false;
47840:     try {
47840:       t.animVal.initialize(item);
47840:     } catch(e) {
47840:       threw = true;
47840:     }
47840:     ok(threw,
47840:        'The method '+t.list_type+'.initialize() should throw when called on '+
47840:        'an anim val list, since anim val lists should be readonly.');
47840: 
47840:     // Test .insertItemBefore():
47840: 
47840:     threw = false;
47840:     try {
47840:       t.animVal.insertItemBefore(item, 2);
47840:     } catch(e) {
47840:       threw = true;
47840:     }
47840:     ok(threw,
47840:        'The method '+t.list_type+'.insertItemBefore() should throw when '+
47840:        'called on an anim val list, since anim val lists should be readonly.');
47840: 
47840:     // Test .replaceItem():
47840: 
47840:     threw = false;
47840:     try {
47840:       t.animVal.replaceItem(item, 2);
47840:     } catch(e) {
47840:       threw = true;
47840:     }
47840:     ok(threw,
47840:        'The method '+t.list_type+'.replaceItem() should throw when called '+
47840:        'on an anim val list, since anim val lists should be readonly.');
47840: 
47840:     // Test .removeItem():
47840: 
47840:     threw = false;
47840:     try {
47840:       t.animVal.removeItem(2);
47840:     } catch(e) {
47840:       threw = true;
47840:     }
47840:     ok(threw,
47840:        'The method '+t.list_type+'.removeItem() should throw when called '+
47840:        'on an anim val list, since anim val lists should be readonly.');
47840: 
47840:     // Test .appendItem():
47840: 
47840:     threw = false;
47840:     try {
47840:       t.animVal.appendItem(item);
47840:     } catch(e) {
47840:       threw = true;
47840:     }
47840:     ok(threw,
47840:        'The method '+t.list_type+'.appendItem() should throw when called '+
47840:        'on an anim val list, since anim val lists should be readonly.');
47840:   }
47840: }
47840: 
47840: 
47840: /**
62563:  * This function runs some basic tests to check the effect of setAttribute()
90212:  * calls on object identity, without taking SMIL animation into consideration.
47840:  */
47840: function run_basic_setAttribute_tests()
47840: {
47840:   for each (var t in tests) {
47840: 
47840:     // Since the t.prop, t.baseVal and t.animVal objects should never ever
47840:     // change, we leave testing of them to our caller so that it can check
47840:     // them after all the other mutations such as SMIL changes.
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840: 
47840:     ok(t.baseVal.numberOfItems == 4 && t.baseVal.getItem(3) != null,
47840:        'The length of the '+t.list_type+' object for '+t.bv_path+' should '+
47840:        'have been set to 4 by the setAttribute() call.');
47840: 
47840:     if (t.animVal) {
47840:       ok(t.baseVal.numberOfItems == t.animVal.numberOfItems,
47840:          'When no animations are active, the '+t.list_type+' objects for '+
47840:          t.bv_path+' and '+t.av_path+' should be the same length (4).');
47840: 
47840:       ok(t.baseVal !== t.animVal,
47840:          'The '+t.list_type+' objects for '+t.bv_path+' and '+t.av_path+
47840:          ' should be different objects.');
47840: 
47840:       ok(t.baseVal.getItem(0) !== t.animVal.getItem(0),
47840:          'The '+t.item_type+' list items in the '+t.list_type+' objects for '+
47840:          t.bv_path+' and '+t.av_path+' should be different objects.');
47840:     }
47840: 
47840:     ok(t.baseVal.getItem(0) === t.baseVal.getItem(0),
47840:        'The exact same '+t.item_type+' DOM object should be returned each '+
47840:        'time the item at a given index in the '+t.list_type+' for '+
47840:        t.bv_path+' is accessed, given that the index was not made invalid '+
47840:        'by a change in list length between the successive accesses.');
47840: 
47840:     if (t.animVal) {
47840:       ok(t.animVal.getItem(0) === t.animVal.getItem(0),
47840:          'The exact same '+t.item_type+' DOM object should be returned each '+
47840:          'time the item at a given index in the '+t.list_type+' for '+
47840:          t.av_path+' is accessed, given that the index was not made invalid '+
47840:          'by a change in list length between the successive accesses.');
47840:     }
47840: 
62563:     // Test the effect of setting the attribute to new values:
47840: 
47840:     t.old_baseVal_items = get_array_of_list_items(t.baseVal);
86429:     if (t.animVal) {
47840:       t.old_animVal_items = get_array_of_list_items(t.animVal);
86429:     }
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_3a);
47840:     t.element.setAttribute(t.attr_name, t.attr_val_5a);
47840: 
47840:     ok(t.baseVal.numberOfItems == 5 && t.baseVal.getItem(4) != null,
47840:        'The length of the '+t.list_type+' object for '+t.bv_path+' should '+
47840:        'have been set to 5 by the setAttribute() call.');
47840: 
47840:     if (t.animVal) {
47840:       ok(t.baseVal.numberOfItems == t.animVal.numberOfItems,
47840:          'Since no animations are active, the length of the '+t.list_type+' '+
47840:          'objects for '+t.bv_path+' and '+t.av_path+' should be the same '+
47840:          '(5).');
47840:     }
47840: 
86429:     if (t.item_type != "DOMString") {
47840:       ok(t.baseVal.getItem(2) === t.old_baseVal_items[2],
47840:          'After its attribute changes, list items in the '+t.list_type+' for '+
47840:          t.bv_path+' that are at indexes that existed prior to the attribute '+
47840:          'change should be the exact same objects as the objects that were '+
47840:          'at those indexes prior to the attribute change.');
47840: 
47840:       ok(t.baseVal.getItem(3) !== t.old_baseVal_items[3],
47840:          'After its attribute changes, list items in the '+t.list_type+' for '+
47840:          t.bv_path+' that are at indexes that did not exist prior to the '+
47840:          'attribute change should not be the same objects as any objects that '+
47840:          'were at those indexes at some earlier time.');
86429:     }
47840: 
47840:     if (t.animVal) {
47840:       ok(t.animVal.getItem(2) === t.old_animVal_items[2],
47840:          'After its attribute changes, list items in the '+t.list_type+' for '+
47840:          t.av_path+' that are at indexes that existed prior to the attribute '+
47840:          'change should be the exact same objects as the objects that were '+
47840:          'at those indexes prior to the attribute change.');
47840: 
47840:       ok(t.animVal.getItem(3) !== t.old_animVal_items[3],
47840:          'After its attribute changes, list items in the '+t.list_type+' for '+
47840:          t.av_path+' that are at indexes that did not exist prior to the '+
47840:          'attribute change should not be the same objects as any objects '+
47840:          'that were at those indexes at some earlier time.');
47840:     }
47840:   }
47840: }
47840: 
62660: /**
62660:  * This function verifies that a list's animVal is kept in sync with its
62660:  * baseVal, when we add & remove items from the baseVal.
62660:  */
62660: function run_list_mutation_tests()
62660: {
62660:   for each (var t in tests) {
62660:     if (t.animVal) {
62660:       // Test removeItem()
62660:       // =================
62660:       // Save second item in baseVal list; then make it the first item, and
62660:       // check that animVal is updated accordingly.
62660:       t.element.setAttribute(t.attr_name, t.attr_val_4);
62660: 
62660:       var secondVal = t.baseVal.getItem(1);
62660:       var removedFirstVal = t.baseVal.removeItem(0);
62660:       t.item_is(t.animVal.getItem(0), secondVal,
62660:                 'animVal for '+t.attr_name+' needs update after first item ' +
62660:                 'removed');
62660: 
62660:       // Repeat with last item
62660:       var secondToLastVal = t.baseVal.getItem(1);
62660:       var removedLastVal = t.baseVal.removeItem(2);
62660: 
62660:       var threw = false;
62660:       try {
62660:         t.animVal.getItem(2);
62660:       } catch(e) {
62660:         threw = true;
62660:       }
62660:       ok(threw,
62660:          'The method '+t.attr_name+'.animVal.getItem() for previously-final ' +
62660:          'index should throw after final item is removed from baseVal.');
62660: 
62660:       t.item_is(t.animVal.getItem(1), secondToLastVal,
62660:                 'animVal for ' + t.attr_name +' needs update after last item ' +
62660:                 'removed');
62660: 
62660:       // Test insertItemBefore()
62660:       // =======================
62660:       // Reset base value, insert value @ start, check that animVal is updated.
62660:       t.element.setAttribute(t.attr_name, t.attr_val_3a);
62660:       t.baseVal.insertItemBefore(removedLastVal, 0);
62660:       t.item_is(t.animVal.getItem(0), removedLastVal,
62660:                 'animVal for '+t.attr_name+' needs update after insert at ' +
62660:                 'beginning');
62660: 
62660:       // Repeat with insert at end
62660:       t.element.setAttribute(t.attr_name, t.attr_val_3a);
62660:       t.baseVal.insertItemBefore(removedFirstVal, t.baseVal.numberOfItems);
62660:       t.item_is(t.animVal.getItem(t.baseVal.numberOfItems - 1),
62660:                 removedFirstVal,
62660:                 'animVal for '+t.attr_name+' needs update after insert at end');
62660: 
62660:       // Test appendItem()
62660:       // =================
62660:       var dummy = t.item_constructor();
62660:       t.baseVal.appendItem(dummy);
62660:       t.item_is(t.animVal.getItem(t.baseVal.numberOfItems - 1), dummy,
62660:                 'animVal for '+t.attr_name+' needs update after appendItem');
62660: 
62660:       // Test clear()
62660:       // ============
62660:       t.baseVal.clear();
62660:       threw = false;
62660:       try {
62660:         t.animVal.getItem(0);
62660:       } catch(e) {
62660:         threw = true;
62660:       }
62660:       ok(threw,
62660:          'The method '+t.attr_name+'.animVal.getItem() should throw after ' +
62660:          'we\'ve cleared baseVal.');
62660: 
62660:       is(t.animVal.numberOfItems, 0,
62660:          'animVal for '+t.attr_name+' should be empty after baseVal cleared');
62660: 
62660:       // Test initialize()
62660:       // =================
62660:       t.element.setAttribute(t.attr_name, t.attr_val_3a);
62660:       t.baseVal.initialize(dummy);
62660: 
62660:       is(t.animVal.numberOfItems, 1,
62660:          'animVal for '+t.attr_name+' should have length 1 after initialize');
62660:       t.item_is(t.animVal.getItem(0), dummy,
62660:                 'animVal for '+t.attr_name+' needs update after initialize');
62660:     }
62660:   }
62660: }
47840: 
47840: /**
47840:  * In this function we run a series of tests at various points along the SMIL
47840:  * animation timeline, using SVGSVGElement.setCurrentTime() to move forward
47840:  * along the timeline.
47840:  *
47840:  * See the comment for create_animate_elements() for details of the animations
47840:  * and their timings.
47840:  */
47840: function run_animation_timeline_tests()
47840: {
47840:   var svg = document.getElementById('svg');
47840: 
47840:   for each (var t in tests) {
78857:     // Skip if there is no animVal for this test or if it is a transform list
78857:     // since these are handled specially
78857:     if (!t.animVal || is_transform_attr(t.attr_name))
78856:       continue;
78856: 
78856:     svg.setCurrentTime(0); // reset timeline
78856: 
47840:     // Reset attributes before moving along the timeline and triggering SMIL:
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4);
47840:     t.old_baseVal_items = get_array_of_list_items(t.baseVal);
47840:     t.old_animVal_items = get_array_of_list_items(t.animVal);
47840: 
47840: 
47840:     /********************    t = 1s    ********************/
47840: 
47840:     svg.setCurrentTime(1); // begin first animation
47840: 
47840:     ok(t.baseVal.numberOfItems == t.old_baseVal_items.length &&
47840:        t.baseVal.getItem(3) === t.old_baseVal_items[3],
47840:        'The start of an animation should never affect the '+t.list_type+
47840:        ' for '+t.bv_path+', or its list items.');
47840: 
47840:     ok(t.animVal.numberOfItems == 5 && t.animVal.getItem(4) != null,
47840:        'The start of the animation should have changed the number of items '+
47840:        'in the '+t.list_type+' for '+t.bv_path+' to 5.');
47840: 
57113:     // TODO
57113:     if (t.list_type != 'SVGPathSegList') {
47840:     ok(t.animVal.getItem(3) === t.old_animVal_items[3],
47840:        'When affected by SMIL animation, list items in the '+t.list_type+
47840:        ' for '+t.bv_path+' that are at indexes that existed prior to the '+
47840:        'start of the animation should be the exact same objects as the '+
47840:        'objects that were at those indexes prior to the start of the '+
47840:        'animation.');
57113:     }
47840: 
47840:     t.old_animVal_items = get_array_of_list_items(t.animVal);
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_3a);
47840: 
47840:     ok(t.baseVal.numberOfItems == 3 &&
47840:        t.baseVal.getItem(2) === t.old_baseVal_items[2],
47840:        'Setting the underlying attribute should change the items in the '+
47840:        t.list_type+' for '+t.bv_path+', including when an animation is '+
47840:        'in progress.');
47840: 
47840:     ok(t.animVal.numberOfItems == 5 &&
47840:        t.animVal.getItem(4) === t.old_animVal_items[4],
47840:        'Setting the underlying attribute should not change the '+t.list_type+
47840:        ' for '+t.bv_path+' when an animation that does not depend on the '+
47840:        'base val is in progress.');
47840: 
47840:     t.element.setAttribute(t.attr_name, t.attr_val_4); // reset
47840: 
47840:     t.old_baseVal_items = get_array_of_list_items(t.baseVal);
47840:     t.old_animVal_items = get_array_of_list_items(t.animVal);
47840: 
47840: 
47840:     /********************    t = 2s    ********************/
47840: 
47840:     svg.setCurrentTime(2); // begin override animation
47840: 
47840:     ok(t.baseVal.numberOfItems == t.old_baseVal_items.length &&
47840:        t.baseVal.getItem(3) === t.old_baseVal_items[3],
47840:        'The start of an override animation should never affect the '+
47840:        t.list_type+' for '+t.bv_path+', or its list items.');
47840: 
47840:     is(t.animVal.numberOfItems, 3,
47840:        'The start of the override animation should have changed the number '+
47840:        'of items in the '+t.list_type+' for '+t.bv_path+' to 3.');
47840: 
47840:     ok(t.animVal.getItem(2) === t.old_animVal_items[2],
47840:        'When affected by an override SMIL animation, list items in the '+
47840:        t.list_type+' for '+t.bv_path+' that are at indexes that existed '+
47840:        'prior to the start of the animation should be the exact same '+
47840:        'objects as the objects that were at those indexes prior to the '+
47840:        'start of that animation.');
47840: 
47840:     t.old_animVal_items = get_array_of_list_items(t.animVal);
47840: 
47840: 
47840:     /********************    t = 3s    ********************/
47840: 
47840:     svg.setCurrentTime(3); // end of override animation
47840: 
47840:     ok(t.baseVal.numberOfItems == t.old_baseVal_items.length &&
47840:        t.baseVal.getItem(3) === t.old_baseVal_items[3],
47840:        'The end of an override animation should never affect the '+
47840:        t.list_type+' for '+t.bv_path+', or its list items.');
47840: 
47840:     is(t.animVal.numberOfItems, 5,
47840:        'At the end of the override animation, the number of items in the '+
47840:        t.list_type+' for '+t.bv_path+' should have reverted to 5.');
47840: 
47840:     ok(t.animVal.getItem(2) === t.old_animVal_items[2],
47840:        'At the end of the override animation, list items in the '+
47840:        t.list_type+' for '+t.bv_path+' that are at indexes that existed '+
47840:        'prior to the end of the animation should be the exact same '+
47840:        'objects as the objects that were at those indexes prior to the '+
47840:        'end of that animation.');
47840: 
47840:     t.old_animVal_items = get_array_of_list_items(t.animVal);
47840: 
47840: 
47840:     /********************    t = 5s    ********************/
47840: 
47840:     svg.setCurrentTime(5); // animation repeat point
47840: 
47840:     ok(t.baseVal.numberOfItems == t.old_baseVal_items.length &&
47840:        t.baseVal.getItem(3) === t.old_baseVal_items[3],
47840:        'When a SMIL animation repeats, it should never affect the '+
47840:        t.list_type+' for '+t.bv_path+', or its list items.');
47840: 
47840:     ok(t.animVal.numberOfItems == t.old_animVal_items.length &&
47840:        t.animVal.getItem(4) === t.old_animVal_items[4],
47840:        'When an animation repeats, the list items that are at a given '+
47840:        'index in the '+t.list_type+' for '+t.av_path+' should be the exact '+
47840:        'same objects as were at that index before the repeat occured.');
47840: 
47840: 
47840:     /********************    t = 6s    ********************/
47840: 
47840:     svg.setCurrentTime(6); // inside animation repeat
47840: 
47840:     ok(t.baseVal.numberOfItems == t.old_baseVal_items.length &&
47840:        t.baseVal.getItem(3) === t.old_baseVal_items[3],
47840:        'When a SMIL animation repeats, it should never affect the '+
47840:        t.list_type+' for '+t.bv_path+', or its list items.');
47840: 
47840:     ok(t.animVal.numberOfItems == t.old_animVal_items.length &&
47840:        t.animVal.getItem(4) === t.old_animVal_items[4],
47840:        'When an animation repeats, the list items that are at a given '+
47840:        'index in the '+t.list_type+' for '+t.av_path+' should be the exact '+
47840:        'same objects as were at that index before the repeat occured.');
47840: 
47840: 
47840:     /********************    t = 7s    ********************/
47840: 
47840:     svg.setCurrentTime(7); // start of additive="sum" animation
47840: 
47840:     ok(t.baseVal.numberOfItems == t.old_baseVal_items.length &&
47840:        t.baseVal.getItem(3) === t.old_baseVal_items[3],
47840:        'When a new SMIL animation starts and should blend with an '+
47840:        'underlying animation, it should never affect the '+
47840:        t.list_type+' for '+t.bv_path+', or its list items.');
47840: 
47840:     if (t.list_type == 'SVGLengthList') {
47840: 
47840:       // Length lists are a special case where it makes sense to allow shorter
47840:       // lists to be composed on top of longer lists (but not necessarily vice
47840:       // versa - see comment below).
47840: 
47840:       ok(t.animVal.numberOfItems == t.old_animVal_items.length &&
47840:          t.animVal.getItem(3) === t.old_animVal_items[3],
47840:          'When an animation with additive="sum" is added on top of an '+
47840:          'existing animation that has more list items, the length of the '+
47840:          t.list_type+' for '+t.av_path+' should not change.');
47840: 
47840:     } else {
47840: 
57113: /* TODO
47840:       ok(false,
47840:          'Decide what to do here - see ' +
47840:          'https://bugzilla.mozilla.org/show_bug.cgi?id=573716 - we ' +
47840:          'probably should be discarding any animation sandwich layers from ' +
47840:          'a layer that fails to add, on up.');
57113: */
47840: 
47840:       // In other words, we wouldn't need the if-else check here.
47840: 
47840:     }
47840: 
47840:     // XXX what if the higher priority sandwich layer has *more* list items
47840:     // than the underlying animation? In that case we would need to
47840:     // distinguish between different SVGLengthList attributes, since although
47840:     // all SVGLengthList attributes allow a short list to be added to longer
47840:     // list, they do not all allow a longer list to be added to shorter list.
47840:     // Specifically that would not be good for 'x' and 'y' on <text> since
47840:     // lengths there are not naturally zero. See the comment in
47840:     // SVGLengthListSMILAttr::Add().
47840: 
47840: 
68501:     /********************    t = 13s    ********************/
47840: 
68501:     svg.setCurrentTime(13); // all animations have finished, but one is frozen
47840: 
47840:     ok(t.baseVal.numberOfItems == t.old_baseVal_items.length &&
47840:        t.baseVal.getItem(3) === t.old_baseVal_items[3],
47840:        'When a SMIL animation ends, it should never affect the '+
47840:        t.list_type+' for '+t.bv_path+', or its list items.');
47840: 
47840:     is(t.animVal.numberOfItems, 5,
47840:        'Even though all SMIL animation have finished, the number '+
47840:        'of items in the '+t.list_type+' for '+t.av_path+
47840:        ' should still be more than the same as the number of items in '+
47840:        t.bv_path+' since one of the animations is still frozen.');
47840: 
68501:     var expected = t.attr_val_5b_firstItem_x3_constructor(t.item_constructor);
68501:     t.item_is(t.animVal.getItem(0), expected,
68501:       'animation with accumulate="sum" and repeatCount="3" for attribute "'+
68501:        t.attr_name+'" should end up at 3x the "to" value.');
68501: 
68501:     // Unfreeze frozen animation (removing its effects)
58554:     var frozen_animate_element =
58554:       t.element.querySelector('animate[fill][attributeName="'+t.attr_name+'"]');
58554:     frozen_animate_element.removeAttribute('fill');
47840: 
47840:     ok(t.animVal.numberOfItems == t.baseVal.numberOfItems,
47840:        'Once all SMIL animation have finished and been un-frozen, the number '+
47840:        'of items in the '+t.list_type+' for '+t.av_path+
47840:        ' should be the same as the number of items in '+t.bv_path+'.');
47840: 
47840:     ok(t.animVal.getItem(2) === t.old_animVal_items[2],
47840:        'Even after an animation finishes and is un-frozen, the list items '+
47840:        'that are at a given index in the '+t.list_type+' for '+t.av_path+
47840:        ' should be the exact same objects as were at that index before the '+
47840:        'end and unfreezing of the animation occured.');
47840:    }
47840: }
47840: 
47840: 
47840: function run_tests()
47840: {
47840:   // Initialize each test object with some useful properties, and create their
47840:   // 'animate' elements. Note that 'prop' and 'animVal' may be null.
47840:   for each (var t in tests) {
47840:     t.element = document.getElementById(t.target_element_id);
47840:     t.prop = t.prop_name ? t.element[t.prop_name] : null;
47840:     t.baseVal = ( t.prop || t.element )[t.bv_name];
47840:     t.animVal = t.av_name ? ( t.prop || t.element )[t.av_name] : null;
47840:     t.bv_path = t.el_type + '.' +
47840:                 (t.prop ? t.prop_name + '.' : '') +
47840:                 t.bv_name;  // e.g. 'SVGTextElement.x.baseVal'
47840:     if (t.animVal) {
47840:       t.av_path = t.el_type + '.' +
47840:                   (t.prop ? t.prop_name + '.' : '') +
47840:                   t.av_name;
47840:     }
47840:     t.prop_type = t.prop_type || null;
47840: 
62660:     // use fallback 'is' function, if none was provided.
62660:     if (!t.item_is) {
62660:       t.item_is = function(itemA, itemB, message) {
62660:       ok(typeof(itemA.value) != 'undefined' &&
62660:          typeof(itemB.value) != 'undefined',
62660:          'expecting value property');
62660:         is(itemA.value, itemB.value, message);
62660:       };
62660:     }
62660: 
86429:     if (t.animVal) {
47840:       t.element.appendChild(create_animate_elements(t));
47840:     }
86429:   }
47840: 
47840:   // Run the major test groups:
47840: 
47840:   run_baseVal_API_tests();
47840:   run_animVal_API_tests();
47840:   run_basic_setAttribute_tests();
62660:   run_list_mutation_tests();
47840:   run_animation_timeline_tests();
47840: 
47840:   // After all the other test manipulations, we check that the following
47840:   // objects have still not changed, since they never should:
47840: 
47840:   for each (var t in tests) {
47840:     if (t.prop) {
47840:       ok(t.prop === t.element[t.prop_name],
47840:          'The same '+t.prop_type+' object should ALWAYS be returned for '+
47840:          t.el_type+'.'+t.prop_name+' each time it is accessed.');
47840:     }
47840: 
47840:     ok(t.baseVal === ( t.prop || t.element )[t.bv_name],
47840:        'The same '+t.list_type+' object should ALWAYS be returned for '+
47840:        t.el_type+'.'+t.prop_name+'.'+t.bv_name+' each time it is accessed.');
47840: 
47840:     if (t.animVal) {
47840:       ok(t.animVal === ( t.prop || t.element )[t.av_name],
47840:          'The same '+t.list_type+' object should ALWAYS be returned for '+
47840:          t.el_type+'.'+t.prop_name+'.'+t.av_name+' each time it is accessed.');
47840:     }
47840:   }
47840: 
47840:   SimpleTest.finish();
47840: }
47840: 
47840: window.addEventListener("load", run_tests, false);
47840: 
47840: ]]>
47840: </script>
47840: </pre>
47840: </body>
47840: </html>
