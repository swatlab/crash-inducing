 4306: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 4306: /* vim:set tw=80 expandtab softtabstop=2 ts=2 sw=2: */
 4306: /* ***** BEGIN LICENSE BLOCK *****
 4306:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 4306:  *
 4306:  * The contents of this file are subject to the Mozilla Public License Version
 4306:  * 1.1 (the "License"); you may not use this file except in compliance with
 4306:  * the License. You may obtain a copy of the License at
 4306:  * http://www.mozilla.org/MPL/
 4306:  *
 4306:  * Software distributed under the License is distributed on an "AS IS" basis,
 4306:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 4306:  * for the specific language governing rights and limitations under the
 4306:  * License.
 4306:  *
 4306:  * The Original Code is Mozilla Communicator client code.
 4306:  *
 4306:  * The Initial Developer of the Original Code is
 4306:  * Netscape Communications Corporation.
 4306:  * Portions created by the Initial Developer are Copyright (C) 1998
 4306:  * the Initial Developer. All Rights Reserved.
 4306:  *
 4306:  * Contributor(s):
 4306:  *   Mats Palmgren <mats.palmgren@bredband.net>
 4306:  *   Daniel Kraft <d@domob.eu>
 4306:  *
 4306:  * Alternatively, the contents of this file may be used under the terms of
 4306:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 4306:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 4306:  * in which case the provisions of the GPL or the LGPL are applicable instead
 4306:  * of those above. If you wish to allow use of your version of this file only
 4306:  * under the terms of either the GPL or the LGPL, and not to allow others to
 4306:  * use your version of this file under the terms of the MPL, indicate your
 4306:  * decision by deleting the provisions above and replace them with the notice
 4306:  * and other provisions required by the GPL or the LGPL. If you do not delete
 4306:  * the provisions above, a recipient may use your version of this file under
 4306:  * the terms of any one of the MPL, the GPL or the LGPL.
 4306:  *
 4306:  * ***** END LICENSE BLOCK ***** */
 4306: 
 4306: #include "nsStyledElement.h"
 4306: #include "nsGkAtoms.h"
 4306: #include "nsAttrValue.h"
 4306: #include "nsGenericElement.h"
 4306: #include "nsMutationEvent.h"
 4306: #include "nsDOMCSSDeclaration.h"
 4306: #include "nsICSSOMFactory.h"
 4306: #include "nsServiceManagerUtils.h"
 4306: #include "nsIDocument.h"
 4306: #include "nsICSSStyleRule.h"
 4306: #include "nsICSSParser.h"
 4306: #include "nsICSSLoader.h"
 4314: 
 4314: #ifdef MOZ_SVG
 4306: #include "nsIDOMSVGStylable.h"
 4314: #endif
 4306: 
 4306: //----------------------------------------------------------------------
 4306: // nsIContent methods
 4306: 
 4306: nsIAtom*
 4306: nsStyledElement::GetClassAttributeName() const
 4306: {
 4306:   return nsGkAtoms::_class;
 4306: }
 4306: 
 4306: nsIAtom*
 4306: nsStyledElement::GetIDAttributeName() const
 4306: {
 4306:   return nsGkAtoms::id;
 4306: }
 4306: 
 4306: const nsAttrValue*
19132: nsStyledElement::DoGetClasses() const
 4306: {
19132:   NS_ASSERTION(HasFlag(NODE_MAY_HAVE_CLASS), "Unexpected call");
 5540:   return mAttrsAndChildren.GetAttr(nsGkAtoms::_class);
 4306: }
 4306: 
 4306: PRBool
 4306: nsStyledElement::ParseAttribute(PRInt32 aNamespaceID, nsIAtom* aAttribute,
 4306:                                 const nsAString& aValue, nsAttrValue& aResult)
 4306: {
 4306:   if (aNamespaceID == kNameSpaceID_None) {
 4306:     if (aAttribute == nsGkAtoms::style) {
 6041:       SetFlags(NODE_MAY_HAVE_STYLE);
11871:       ParseStyleAttribute(this, aValue, aResult, PR_FALSE);
 4306:       return PR_TRUE;
 4306:     }
 4306:     if (aAttribute == nsGkAtoms::_class) {
 6041:       SetFlags(NODE_MAY_HAVE_CLASS);
 4314: #ifdef MOZ_SVG
 4306:       NS_ASSERTION(!nsCOMPtr<nsIDOMSVGStylable>(do_QueryInterface(this)),
 4306:                    "SVG code should have handled this 'class' attribute!");
 4314: #endif
 4306:       aResult.ParseAtomArray(aValue);
 4306:       return PR_TRUE;
 4306:     }
 4306:   }
 4306: 
 4306:   return nsStyledElementBase::ParseAttribute(aNamespaceID, aAttribute, aValue,
 4306:                                              aResult);
 4306: }
 4306: 
 4306: NS_IMETHODIMP
 4306: nsStyledElement::SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify)
 4306: {
 6041:   SetFlags(NODE_MAY_HAVE_STYLE);
 4306:   PRBool modification = PR_FALSE;
 4306:   nsAutoString oldValueStr;
 4306: 
 4306:   PRBool hasListeners = aNotify &&
 4306:     nsContentUtils::HasMutationListeners(this,
 4306:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
 4306:                                          this);
 4306: 
 4306:   // There's no point in comparing the stylerule pointers since we're always
 4306:   // getting a new stylerule here. And we can't compare the stringvalues of
 4306:   // the old and the new rules since both will point to the same declaration
 4306:   // and thus will be the same.
 4306:   if (hasListeners) {
 4306:     // save the old attribute so we can set up the mutation event properly
 4306:     // XXXbz if the old rule points to the same declaration as the new one,
 4306:     // this is getting the new attr value, not the old one....
 4306:     modification = GetAttr(kNameSpaceID_None, nsGkAtoms::style,
 4306:                            oldValueStr);
 4306:   }
 4306:   else if (aNotify && IsInDoc()) {
 4306:     modification = !!mAttrsAndChildren.GetAttr(nsGkAtoms::style);
 4306:   }
 4306: 
 4306:   nsAttrValue attrValue(aStyleRule);
 4306: 
 4306:   return SetAttrAndNotify(kNameSpaceID_None, nsGkAtoms::style, nsnull,
 4306:                           oldValueStr, attrValue, modification, hasListeners,
22222:                           aNotify, nsnull);
 4306: }
 4306: 
 4306: nsICSSStyleRule*
 4306: nsStyledElement::GetInlineStyleRule()
 4306: {
 6041:   if (!HasFlag(NODE_MAY_HAVE_STYLE)) {
 6041:     return nsnull;
 6041:   }
 4306:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(nsGkAtoms::style);
 4306: 
 4306:   if (attrVal && attrVal->Type() == nsAttrValue::eCSSStyleRule) {
 4306:     return attrVal->GetCSSStyleRuleValue();
 4306:   }
 4306: 
 4306:   return nsnull;
 4306: }
 4306: 
 4306: nsresult
 4306: nsStyledElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
 4306:                             nsIContent* aBindingParent,
 4306:                             PRBool aCompileEventHandlers)
 4306: {
 4306:   nsresult rv = nsStyledElementBase::BindToTree(aDocument, aParent,
 4306:                                                 aBindingParent,
 4306:                                                 aCompileEventHandlers);
 4306:   NS_ENSURE_SUCCESS(rv, rv);
 4306: 
 4306:   // XXXbz if we already have a style attr parsed, this won't do
 4306:   // anything... need to fix that.
11871:   ReparseStyleAttribute(PR_FALSE);
 4306: 
 4306:   return rv;
 4306: }
 4306: 
 4306: // ---------------------------------------------------------------
 4306: // Others and helpers
 4306: 
 4306: static nsICSSOMFactory* gCSSOMFactory = nsnull;
 4306: static NS_DEFINE_CID(kCSSOMFactoryCID, NS_CSSOMFACTORY_CID);
 4306: 
 4306: nsresult
 4306: nsStyledElement::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
 4306: {
 4306:   nsGenericElement::nsDOMSlots *slots = GetDOMSlots();
 4306:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
 4306: 
 4306:   if (!slots->mStyle) {
 4306:     // Just in case...
11871:     ReparseStyleAttribute(PR_TRUE);
 4306: 
 4306:     nsresult rv;
 4306:     if (!gCSSOMFactory) {
 4306:       rv = CallGetService(kCSSOMFactoryCID, &gCSSOMFactory);
 4306:       NS_ENSURE_SUCCESS(rv, rv);
 4306:     }
 4306: 
 4306:     rv = gCSSOMFactory->CreateDOMCSSAttributeDeclaration(this,
 4306:                                                  getter_AddRefs(slots->mStyle));
 4306:     NS_ENSURE_SUCCESS(rv, rv);
 6041:     SetFlags(NODE_MAY_HAVE_STYLE);
 4306:   }
 4306: 
 4306:   // Why bother with QI?
 4306:   NS_ADDREF(*aStyle = slots->mStyle);
 4306:   return NS_OK;
 4306: }
 4306: 
 4306: nsresult
11871: nsStyledElement::ReparseStyleAttribute(PRBool aForceInDataDoc)
 4306: {
 6041:   if (!HasFlag(NODE_MAY_HAVE_STYLE)) {
 6041:     return NS_OK;
 6041:   }
 4306:   const nsAttrValue* oldVal = mAttrsAndChildren.GetAttr(nsGkAtoms::style);
 4306:   
 4306:   if (oldVal && oldVal->Type() != nsAttrValue::eCSSStyleRule) {
 4306:     nsAttrValue attrValue;
 4306:     nsAutoString stringValue;
 4306:     oldVal->ToString(stringValue);
11871:     ParseStyleAttribute(this, stringValue, attrValue, aForceInDataDoc);
 4306:     // Don't bother going through SetInlineStyleRule, we don't want to fire off
 4306:     // mutation events or document notifications anyway
 4306:     nsresult rv = mAttrsAndChildren.SetAndTakeAttr(nsGkAtoms::style, attrValue);
 4306:     NS_ENSURE_SUCCESS(rv, rv);
 4306:   }
 4306:   
 4306:   return NS_OK;
 4306: }
 4306: 
 4306: void
 4306: nsStyledElement::ParseStyleAttribute(nsIContent* aContent,
 4306:                                      const nsAString& aValue,
11871:                                      nsAttrValue& aResult,
11871:                                      PRBool aForceInDataDoc)
 4306: {
 4306:   nsresult result = NS_OK;
 4306:   nsIDocument* doc = aContent->GetOwnerDoc();
 4306: 
11871:   if (doc && (aForceInDataDoc || !doc->IsLoadedAsData())) {
 4306:     PRBool isCSS = PR_TRUE; // assume CSS until proven otherwise
 4306: 
12250:     if (!aContent->IsInNativeAnonymousSubtree()) {  // native anonymous content
 4306:                                                     // always assumes CSS
 4306:       nsAutoString styleType;
 4306:       doc->GetHeaderData(nsGkAtoms::headerContentStyleType, styleType);
 4306:       if (!styleType.IsEmpty()) {
 4306:         static const char textCssStr[] = "text/css";
 4306:         isCSS = (styleType.EqualsIgnoreCase(textCssStr, sizeof(textCssStr) - 1));
 4306:       }
 4306:     }
 4306: 
 4306:     if (isCSS) {
 4306:       nsICSSLoader* cssLoader = doc->CSSLoader();
 4306:       nsCOMPtr<nsICSSParser> cssParser;
 4306:       result = cssLoader->GetParserFor(nsnull, getter_AddRefs(cssParser));
 4306:       if (cssParser) {
 4306:         nsCOMPtr<nsIURI> baseURI = aContent->GetBaseURI();
 4306: 
 4306:         nsCOMPtr<nsICSSStyleRule> rule;
 4306:         result = cssParser->ParseStyleAttribute(aValue, doc->GetDocumentURI(),
 4306:                                                 baseURI,
 4306:                                                 aContent->NodePrincipal(),
 4306:                                                 getter_AddRefs(rule));
 4306:         cssLoader->RecycleParser(cssParser);
 4306: 
 4306:         if (rule) {
 4306:           aResult.SetTo(rule);
 4306:           return;
 4306:         }
 4306:       }
 4306:     }
 4306:   }
 4306: 
 4306:   aResult.SetTo(aValue);
 4306: }
 4306: 
 4306: 
 4306: /* static */ void
 4306: nsStyledElement::Shutdown()
 4306: {
 4306:   NS_IF_RELEASE(gCSSOMFactory);
 4306: }
