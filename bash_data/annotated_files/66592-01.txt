64755: <?xml version="1.0"?>
64987: 
64987: <!DOCTYPE bindings [
64987: <!ENTITY % browserDTD SYSTEM "chrome://browser/locale/browser.dtd">
64987: %browserDTD;
64987: ]>
64755: 
64755: <bindings
64755:     xmlns="http://www.mozilla.org/xbl"
64755:     xmlns:xbl="http://www.mozilla.org/xbl"
66139:     xmlns:svg="http://www.w3.org/2000/svg"
64755:     xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
64755: 
64755:   <binding id="autocomplete-aligned" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete">
64755:     <implementation>
66572:       <property name="mIgnoreFocus" onget="return true;" onset="val;"/>
64755:       <method name="openPopup">
64755:         <body><![CDATA[
65346:           this.popup.openAutocompletePopup(this, null);
64755:         ]]></body>
64755:       </method>
64755:       <method name="closePopup">
64755:         <body><![CDATA[
65346:           // hack! we want to revert to the "all results" popup when the
65346:           // controller would otherwise close us because of an empty search
65578:           // string.
65346:           if (this.value == "")
65346:             this.showHistoryPopup();
64755:         ]]></body>
64755:       </method>
64755:     </implementation>
65346:     <handlers>
66507:       <handler event="keypress" phase="capturing">
65346:         <![CDATA[
66507:           if (event.keyCode == event.DOM_VK_RETURN)
66474:             setTimeout(function() { BrowserUI.activePanel = null }, 0);
66507:           else if (this.readOnly)
66507:             this.readOnly = false;
65346:         ]]>
65346:       </handler>
66511:       <handler event="text" phase="bubbling">
66511:         <![CDATA[
66511:           if (this.mController.input == this)
66511:             this.mController.handleText();
66511:         ]]>
66511:       </handler>
66511:       <handler event="blur" phase="capturing">
66511:         <![CDATA[
66545:           // Bug 583341 - suppress disconnect of autocomplete controller
66511:           this._dontBlur = true;
66511:         ]]>
66511:       </handler>
65346:     </handlers>
64755:   </binding>
64755: 
65337:   <binding id="popup_autocomplete_result">
66547:     <handlers>
66547:       <handler event="contextmenu" phase="capturing">
66547:         <![CDATA[
66547:           let url = this.getAttribute("url");
66547:           if (!url)
66547:             return;
66547: 
66547:           let value = this.getAttribute("value");
66547:           let data = {
66547:             target: this,
66547:             json: {
66547:               types: ["link-saveable", "link-shareable"],
66547:               label: value,
66547:               linkTitle: value,
66547:               linkURL: url
66547:             }
66547:           };
66547:           ContextHelper.showPopup(data);
66547:         ]]>
66547:       </handler>
66547:     </handlers>
65585:     <content orient="vertical">
66551:       <xul:hbox class="autocomplete-item-container" align="top" xbl:inherits="favorite" mousethrough="always">
65585:         <xul:image xbl:inherits="src"/>
66158:         <xul:vbox flex="1">
66551:           <xul:label class="autocomplete-item-label" crop="center" xbl:inherits="value"/>
66551:           <xul:label class="autocomplete-item-url" xbl:inherits="value=url" crop="center"/>
66551:         </xul:vbox>
66551:         <xul:vbox align="end">
66551:           <xul:label class="autocomplete-item-tags" value="" xbl:inherits="value=tags"/>
66551:           <xul:label class="autocomplete-item-badge" value="" xbl:inherits="value=badge"/>
66158:         </xul:vbox>
65585:       </xul:hbox>
65337:     </content>
65337:   </binding>
65337: 
64970:   <binding id="popup_autocomplete">
66474:     <content orient="vbox" class="autocomplete-box" flex="1">
66132:       <!-- 24 child items, to match browser.urlbar.maxRichResults -->
65188:       <xul:scrollbox orient="vertical"
65188:                      class="autocomplete-items"
65188:                      anonid="autocomplete-items"
65188:                      flex="1000">
65337:         <xul:autocompleteresult/>
65337:         <xul:autocompleteresult/>
65337:         <xul:autocompleteresult/>
65337:         <xul:autocompleteresult/>
65337:         <xul:autocompleteresult/>
65337:         <xul:autocompleteresult/>
65337:         <xul:autocompleteresult/>
65509:         <xul:autocompleteresult/>
65509:         <xul:autocompleteresult/>
65509:         <xul:autocompleteresult/>
65509:         <xul:autocompleteresult/>
65509:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
66132:         <xul:autocompleteresult/>
65188:       </xul:scrollbox>
64970:       <children/>
64970:     </content>
64970: 
65762:     <implementation implements="nsIAutoCompletePopup">
65188:       <!-- Used by the chrome input handler -->
65188:       <property name="boxObject"
65188:                 readonly="true"
65188:                 onget="return this._items.boxObject;"/>
65188: 
65311:       <field name="_scrollBoxObject">
66362:         this.boxObject.QueryInterface(Ci.nsIScrollBoxObject);
65311:       </field>
65311: 
66551:       <!-- Used by the badges implementation -->
66551:       <field name="_badges">[]</field>
66551:       <field name="_badgesTimeout">-1</field>
66551:       <field name="_eTLDService">Cc["@mozilla.org/network/effective-tld-service;1"].getService(Ci.nsIEffectiveTLDService);</field>
66551: 
64970:       <!-- nsIAutocompleteInput -->
64970:       <property name="overrideValue"
64970:                 readonly="true"
64970:                 onget="return null;"/>
64970: 
64970:       <field name="_input"/>
64970:       <property name="input"
64970:                 readonly="true"
64970:                 onget="return this._input;"/>
64970: 
64970:       <field name="_selectedIndex">-1</field>
64970:       <field name="_selectedItem"/>
66474:       <property name="selectedIndex" onget="return this._selectedIndex;">
64970:         <setter><![CDATA[
64970:           // Ignore invalid indices
64970:           if (val < -1 ||
64970:               val > this._matchCount - 1)
64970:             return val;
64970: 
64970:           if (this._selectedItem)
64970:             this._styleItem(this._selectedItem, false);
64970: 
64970:           // highlight the selected item
64970:           let item = this._items.childNodes.item(val);
64970:           if (item) {
64970:             this._selectedItem = item;
64970:             this._styleItem(this._selectedItem, true);
65456:             this._scrollBoxObject.ensureElementIsVisible(this._selectedItem);
64970:           }
64970: 
64970:           return this._selectedIndex = val;
64970:         ]]></setter>
64970:       </property>
64970: 
64970:       <field name="_popupOpen">false</field>
64970:       <property name="popupOpen"
64970:                 readonly="true"
64970:                 onget="return this._popupOpen;"/>
64970: 
64970:       <method name="openAutocompletePopup">
64970:         <parameter name="aInput"/>
64970:         <parameter name="aElement"/>
64970:         <body><![CDATA[
64970:           if (this._popupOpen)
64970:             return;
64970: 
65592:           this._selectedItem = null;
64970:           this._input = aInput;
65479:           this._input.select();
64970:           this._popupOpen = true;
64970: 
64970:           this.invalidate();
66198: 
66198:           let event = document.createEvent("Events");
66198:           event.initEvent("popupshown", true, false);
66198:           this.dispatchEvent(event);
64970:         ]]></body>
64970:       </method>
64970: 
64970:       <method name="closePopup">
64970:         <body><![CDATA[
64970:           if (!this._popupOpen)
64970:             return;
64970: 
64970:           this.selectedIndex = -1;
64970:           this.input.controller.stopSearch();
64970:           this._popupOpen = false;
65320: 
66198:           let event = document.createEvent("Events");
66198:           event.initEvent("popuphidden", true, false);
66198:           this.dispatchEvent(event);
65320:         ]]></body>
65320:       </method>
65320: 
66047:       <method name="scrollToTop">
66047:         <body><![CDATA[
66047:           if (this._items.scrollTop || this._items.scrollLeft)
66047:             this._scrollBoxObject.scrollTo(0, 0);
66047:         ]]></body>
66047:       </method>
66047: 
65320:       <!-- Helper used by active dialog system -->
65320:       <method name="close">
65320:         <body><![CDATA[
65469:           this.input.reset();
65578:           this.input.blur();
65320:           this.closePopup();
64970:         ]]></body>
64970:       </method>
64970: 
65188:       <field name="_XULNS">("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul")</field>
65188: 
64970:       <method name="invalidate">
64970:         <body><![CDATA[
64970:           // Don't bother doing work if we're not even open
64970:           if (!this.popupOpen)
64970:             return;
64970: 
65346:           let controller = this.input.controller;
65346:           let searchString = controller.searchString;
65346:           let items = this._items;
65346: 
65188:           // Need to iterate over all our existing entries at a minimum, to make
65188:           // sure they're either updated or cleared out. We might also have to
65188:           // add extra items.
65222:           let matchCount = this._matchCount;
65337:           let children = items.childNodes;
65222:           let iterCount = Math.max(children.length, matchCount);
65188:           for (let i = 0; i < iterCount; ++i) {
65337:             let item = children.item(i);
65337: 
65337:             // Create an item if needed
65337:             if (!item) {
65337:               item = document.createElementNS(this._XULNS, "xul:autocompleteresult");
65337:               items.appendChild(item);
65188:             }
65509: 
65337:             item._index = i;
65222: 
64970:             // Check whether there's an entry to fill
64970:             if (i > matchCount - 1) {
65775:               // Just clear out the old item's value. CSS takes care of hiding
65775:               // everything else based on value="" (star, tags, etc.)
65337:               item.setAttribute("value", "");
65337:               item._empty = true;
64970: 
64970:               continue;
64970:             }
65337: 
65337:             // Assign the values
65337:             let type = controller.getStyleAt(i);
65337:             let title = controller.getCommentAt(i);
65337:             let tags = '';
65337: 
66480:             if (type == "tag") {
66480:               try {
65337:                 [, title, tags] = title.match(/^(.+) \u2013 (.+)$/);
66480:               } catch (e) {}
66480:             }
65337:             item.setAttribute("tags", tags);
64970: 
64970:             let url = controller.getValueAt(i);
65585:             item.setAttribute("value", title || url);
66551: 
66551:             // remove the badge only if the url has changed
66551:             if (item._empty || item.getAttribute("url") != url) {
65585:               item.setAttribute("url", url);
66551:               item.removeAttribute("badge");
66551:             }
64970: 
65337:             let isBookmark = ((type == "bookmark") || (type == "tag"));
65337:             item.setAttribute("favorite", isBookmark);
65337:             item.setAttribute("src", controller.getImageAt(i));
66551: 
66551:             item._empty = false;
64970:           }
65337: 
65346:           // Show the "no results" or "all bookmarks" entries as needed
65337:           this._updateNoResultsItem(matchCount);
66221: 
66221:           // Make sure the list is scrolled to the top
66221:           this.scrollToTop();
66551:           this._invalidateBadges();
65337:         ]]></body>
65337:       </method>
65337: 
65337:       <method name="_updateNoResultsItem">
65337:         <parameter name="isResults" />
65337:         <body><![CDATA[
65337:           let noResultsItem = this._items.childNodes.item(1);
65337:           if (isResults) {
65337:             noResultsItem.className = "";
66474:           } else {
65337:             noResultsItem.className = "noresults";
65337:             noResultsItem.setAttribute("value", "]]>&noResults.label;<![CDATA[");
65775:             noResultsItem.removeAttribute("favorite");
65775:             noResultsItem.removeAttribute("url");
65775:             noResultsItem.removeAttribute("src");
65775:             noResultsItem.removeAttribute("tags");
66551:             noResultsItem.removeAttribute("badge");
65337:           }
65337:         ]]></body>
65337:       </method>
65337: 
64970:       <method name="selectBy">
64970:         <parameter name="aReverse"/>
64970:         <parameter name="aPage"/>
64970:         <body><![CDATA[
64970:           let newIndex;
64970:           let lastIndex = this._matchCount - 1;
64970: 
64970:           if (this._selectedIndex == -1)
64970:             newIndex = aReverse ? lastIndex : 0;
64970:           else
64970:             newIndex = this._selectedIndex + (aReverse ? -1 : 1);
64970: 
64970:           // Deal with rollover
64970:           if (newIndex > lastIndex)
64970:             newIndex = 0;
64970:           else if (newIndex < 0)
64970:             newIndex = lastIndex;
64970: 
64970:           this.selectedIndex = newIndex;
64970:         ]]></body>
64970:       </method>
64970: 
66551:       <method name="_getEffectiveHost">
66551:         <parameter name="aURI"/>
66551:         <body><![CDATA[
66551:           let host = null;
66551:           try {
66551:             host = aURI.host;
66551:             return this._eTLDService.getBaseDomainFromHost(host);
66551:           } catch (e) {}
66551: 
66551:           return host ? host : aURI.spec;
66551:         ]]></body>
66551:       </method>
66551: 
66551:       <method name="registerBadgeHandler">
66551:         <parameter name="aURL"/>
66551:         <parameter name="aHandler"/>
66551:         <body><![CDATA[
66551:           if (!aHandler)
66551:             return false;
66551: 
66551:           let effectiveHost = this._getEffectiveHost(Services.io.newURI(aURL, null, null));
66551:           this._badges[effectiveHost] = aHandler;
66551:           return true;
66551:         ]]></body>
66551:       </method>
66551: 
66551:       <method name="unregisterBagdeHandler">
66551:         <parameter name="aURL"/>
66551:         <body><![CDATA[
66551:           let effectiveHost = this._getEffectiveHost(Services.io.newURI(aURL, null, null));
66551:           if (this._badges[effectiveHost])
66551:             delete this._badges[effectiveHost];
66551:         ]]></body>
66551:       </method>
66551: 
66551:       <method name="_invalidateBadges">
66551:         <body><![CDATA[
66551:           window.clearTimeout(this._badgesTimeout);
66551: 
66551:           this._badgesTimeout = window.setTimeout(function(self) {
66551:             for (let i = 0; i < self._items.childNodes.length; i++) {
66551:               let item = self._items.childNodes[i];
66551:               if (!item.hasAttribute("url"))
66551:                 continue;
66551: 
66570:               let currentURL = item.getAttribute("url");
66570:               let itemHost = self._getEffectiveHost(Services.io.newURI(currentURL, null, null));
66551:               for (let badgeHost in self._badges) {
66551:                 if (itemHost == badgeHost) {
66570:                   // wrap the item to prevent setting a badge on a wrong item
66570:                   let wrapper = {
66570:                     set: function(aBadge) {
66570:                       if (item.getAttribute("url") != currentURL)
66570:                         return;
66570: 
66570:                       if (!aBadge || aBadge == "")
66570:                         item.removeAttribute("badge");
66570:                       else
66570:                         item.setAttribute("badge", aBadge);
66570:                     }
66570:                   };
66570: 
66551:                   let handler = self._badges[badgeHost];
66570:                   handler.updateBadge ? handler.updateBadge(wrapper) : handler(wrapper);
66551:                   break;
66551:                 }
66551:               }
66551:             }
66551:           }, 300, this);
66551:         ]]></body>
66551:       </method>
66551: 
64970:       <!-- Helpers -->
64970:       <field name="_items">
64970:         document.getAnonymousElementByAttribute(this,
64970:                         "anonid", "autocomplete-items");
64970:       </field>
64970: 
64970:       <property name="_matchCount"
64970:                 readonly="true">
64970:         <getter><![CDATA[
66474:           return this.input.controller.matchCount;
64970:         ]]></getter>
64970:       </property>
64970: 
64970:       <method name="_styleItem">
64970:         <parameter name="aItem"/>
64970:         <parameter name="aAddStyle"/>
64970:         <body><![CDATA[
64970:           if (aAddStyle)
65346:             aItem.className += " autocompleteresult-selected";
64970:           else
65346:             aItem.className = aItem.className.replace(/\s*autocompleteresult-selected/, "");
64970:         ]]></body>
64970:       </method>
64970:     </implementation>
64970: 
64970:     <handlers>
65346:       <handler event="click" button="0">
64970:         <![CDATA[
65561:           let target = event.originalTarget;
66474:           if (target.localName == "autocompleteresult" && !target._empty) {
66474:             this._selectedIndex = target._index;
64970:             this.input.controller.handleEnter(true);
66474:             BrowserUI.activePanel = null;
65546:           }
64970:         ]]>
64970:       </handler>
64970:     </handlers>
64970:   </binding>
64970: 
65074:   <binding id="place-base">
65074:     <content/>
66055: 
66055:     <handlers>
66055:       <handler event="click" button="0">
66396:         <![CDATA[
66398:           if (this.control)
66055:             this.control._fireOpen(event, this);
66396:         ]]>
66396:       </handler>
66396:       <handler event="contextmenu" phase="capturing">
66396:         <![CDATA[
66519:           if (!this.uri || this._isEditing)
66396:             return;
66396: 
66396:           let data = {
66396:             target: this,
66396:             json: {
66547:               types: ["edit-bookmark", "link-saveable", "link-shareable"],
66547:               label: this.name,
66547:               linkTitle: this.name,
66547:               linkURL: this.spec
66396:            }};
66396:            ContextHelper.showPopup(data);
66396:          ]]>
66055:        </handler>
66055:      </handlers>
66055: 
64987:     <implementation>
65161:       <field name="_uri">null</field>
65075:       <field name="_control">null</field>
65074:       <field name="_isEditing">false</field>
65074: 
64987:       <field name="_nameField">
64987:         document.getAnonymousElementByAttribute(this, "anonid", "name");
64987:       </field>
64987:       <field name="_uriField">
64987:         document.getAnonymousElementByAttribute(this, "anonid", "uri");
64987:       </field>
64987:       <field name="_tagsField">
64987:         document.getAnonymousElementByAttribute(this, "anonid", "tags");
64987:       </field>
65835:       <property name="itemId" onget="return this.getAttribute('itemid');"/>
65074:       <property name="type" onget="return this.getAttribute('type');"/>
65075: 
65835:       <property name="uri">
65835:         <getter><![CDATA[
65835:           if (!this._uri && this.getAttribute("uri"))
66362:             this._uri = Services.io.newURI(this.getAttribute("uri"), null, null);
65835: 
65835:           return this._uri;
65835:         ]]></getter>
65835:       </property>
65835: 
64987:       <property name="name" onget="return this._nameField.value"
64987:                             onset="this._nameField.value = val; return val;"/>
65075:       <property name="spec" onget="return this._uriField.value"
64987:                             onset="this._uriField.value = val; return val;"/>
64987:       <property name="tags" onget="return this._tagsField.value"
64987:                             onset="this._tagsField.value = val; return val;"/>
64987:       <property name="tagsAsArray" readonly="true">
64987:         <getter>
64987:           <![CDATA[
64987:             // we don't require the leading space (after each comma)
64987:             var tags = this.tags.split(",");
64987:             for (var i = 0; i < tags.length; i++) {
64987:               // remove trailing and leading spaces
64987:               tags[i] = tags[i].trim();
64987: 
64987:               // remove empty entries from the array.
64987:               if (tags[i] == "") {
64987:                 tags.splice(i, 1);
64987:                 i--;
64987:               }
64987:             }
64987: 
64987:             return tags;
64987:           ]]>
64987:         </getter>
64987:       </property>
65074:       <property name="isEditing" readonly="true" onget="return this._isEditing;"/>
66425:       <property name="isReadOnly" readonly="true">
66425:         <getter><![CDATA[
66425:           return this.control && this.control._readOnlyFolders.indexOf(parseInt(this.itemId, 10)) != -1;
66425:         ]]></getter>
66425:       </property>
65074:       <property name="control" readonly="true">
65074:         <getter>
65074:           <![CDATA[
65075:             if (this._control)
65075:               return this._control;
65075: 
65074:             let parent = this.parentNode;
65074:             while (parent) {
65075:               if (parent.localName == "placelist") {
65075:                 this._control = parent;
65075:                 return this._control;
65075:               }
65074:               parent = parent.parentNode;
65074:             }
65074:             return null;
65074:           ]]>
65074:         </getter>
65074:       </property>
65074: 
65074:       <method name="startEditing">
65095:         <parameter name="autoSelect"/>
65074:         <body>
65074:           <![CDATA[
66425:             if (!this.itemId || this.isReadOnly)
64987:               return;
64987: 
65074:             this._isEditing = true;
65533:             if (this.control) {
65533:               this.setAttribute("selected", "true");
65533:               this.control.scrollBoxObject.ensureElementIsVisible(this);
65074:               this.control.activeItem = this;
65533:             }
64987: 
65074:             this.updateFields();
65074: 
64987:             this._nameField.focus();
65095:             if (autoSelect)
65095:               this._nameField.select();
64987:           ]]>
64987:         </body>
64987:       </method>
64987:       <method name="stopEditing">
64987:         <parameter name="shouldSave"/>
64987:         <body>
64987:           <![CDATA[
66425:             if (!this.itemId || this.isReadOnly)
66407:               return;
66407: 
64987:             if (shouldSave)
64987:               this.save();
64987: 
65074:             this._isEditing = false;
66396:             if (this.control && this.control.activeItem) {
65533:               this.control.activeItem.removeAttribute("selected");
65074:               this.control.activeItem = null;
65533:             }
65074: 
65074:             this.updateFields();
65074: 
65699:             let focusedElement = document.commandDispatcher.focusedElement;
65699:             if (focusedElement)
65699:               focusedElement.blur();
65699: 
64987:             let event = document.createEvent("Events");
66113:             event.initEvent("close", false, false);
64987:             this.dispatchEvent(event);
64987:           ]]>
64987:         </body>
64987:       </method>
64987:       <method name="save">
64987:         <body>
64987:           <![CDATA[
64987:             // Update the tags
65835:             if (this.uri && this.type != "folder") {
65835:               let currentTags = PlacesUtils.tagging.getTagsForURI(this.uri, {});
65175:               let tags = this.tagsAsArray;
64987:               if (tags.length > 0 || currentTags.length > 0) {
65175:                 let tagsToRemove = [];
65175:                 let tagsToAdd = [];
65175:                 for (let i = 0; i < currentTags.length; i++) {
64987:                   if (tags.indexOf(currentTags[i]) == -1)
64987:                     tagsToRemove.push(currentTags[i]);
64987:                 }
65175:                 for (let i = 0; i < tags.length; i++) {
64987:                   if (currentTags.indexOf(tags[i]) == -1)
64987:                     tagsToAdd.push(tags[i]);
64987:                 }
64987: 
64987:                 if (tagsToAdd.length > 0)
65835:                   PlacesUtils.tagging.tagURI(this.uri, tagsToAdd);
64987:                 if (tagsToRemove.length > 0)
65835:                   PlacesUtils.tagging.untagURI(this.uri, tagsToRemove);
64987:               }
65533:               this.setAttribute('tags', this.tags);
64987: 
65175:               // If the URI was updated change it in the bookmark, but don't
65175:               // allow a blank URI. Revert to previous URI if blank.
65175:               let spec = this.spec;
65835:               if (spec && this.uri.spec != spec) {
65175:                 try {
66007:                   let oldURI = this._uri;
66362:                   this._uri = Services.io.newURI(spec, null, null);
65835:                   PlacesUtils.bookmarks.changeBookmarkURI(this.itemId, this.uri);
65533:                   this.setAttribute('uri', this.spec);
66007: 
66007:                   // move tags from old URI to new URI
66007:                   let tags = this.tagsAsArray;
66007:                   if (tags.length != 0) {
66007:                     // only untag the old URI if this is the only bookmark
66007:                     if (PlacesUtils.getBookmarksForURI(oldURI, {}).length == 0)
66007:                       PlacesUtils.tagging.untagURI(oldURI, tags);
66007: 
66007:                     PlacesUtils.tagging.tagURI(this._uri, tags);
66007:                   }
65074:                 }
65175:                 catch (e) { }
64987:               }
65835:               if (spec != this.uri.spec)
65840:                 this.spec = this.uri.spec;
65175:             }
65175: 
65175:             // Update the name and use the URI if name is blank
65840:             this.name = this.name || this.spec;
65533:             this.setAttribute('title', this.name);
65835:             PlacesUtils.bookmarks.setItemTitle(this.itemId, this.name);
64987:           ]]>
64987:         </body>
64987:       </method>
64987:       <method name="remove">
64987:         <body>
64987:           <![CDATA[
65835:             PlacesUtils.bookmarks.removeItem(this.itemId);
64987: 
64987:             // If this was the last bookmark (excluding tag-items and livemark
64987:             // children, see getMostRecentBookmarkForURI) for the bookmark's url,
64987:             // remove the url from tag containers as well.
65835:             if (this.uri && this.type != "folder") {
65835:               if (PlacesUtils.getMostRecentBookmarkForURI(this.uri) == -1) {
65835:                 var tags = PlacesUtils.tagging.getTagsForURI(this.uri, {});
65835:                 PlacesUtils.tagging.untagURI(this.uri, tags);
65074:               }
64987:             }
64987: 
65074:             this.stopEditing(false);
65074: 
65690:             let event = document.createEvent("Events");
65690:             event.initEvent("BookmarkRemove", true, false);
65690:             this.dispatchEvent(event);
65690: 
65074:             if (this.control)
65074:               this.control.removeItem(this);
65074: 
65074:           ]]>
65074:         </body>
65074:       </method>
65074:       <method name="updateFields">
65074:         <body>
65074:           <![CDATA[
65074:             // implemented by sub classes
65074:           ]]>
65074:         </body>
65074:       </method>
65074:     </implementation>
65074:   </binding>
65074: 
65074:   <binding id="place-item" extends="chrome://browser/content/bindings.xml#place-base">
65646:     <content orient="vertical">
66551:       <xul:hbox anonid="bookmark-item" class="bookmark-item-container" align="top" flex="1" mousethrough="always">
65646:         <xul:image xbl:inherits="src"/>
66158:         <xul:vbox flex="1">
66551:           <xul:label class="bookmark-item-label" crop="center" xbl:inherits="value=title"/>
66158:           <xul:label anonid="bookmark-url" class="bookmark-item-url" xbl:inherits="value=uri" crop="center" mousethrough="always"/>
66158:         </xul:vbox>
66551:         <xul:vbox>
66551:           <xul:label class="bookmark-item-tags" xbl:inherits="value=tags"/>
66551:         </xul:vbox>
65646:       </xul:hbox>
65533: 
65646:       <xul:hbox anonid="bookmark-manage" class="bookmark-manage" hidden="true" flex="1">
65646:         <xul:image xbl:inherits="src"/>
65533:         <xul:vbox flex="1">
65533:           <xul:vbox flex="1">
65533:             <xul:textbox anonid="name" xbl:inherits="value=title"/>
65533:             <xul:textbox anonid="uri" xbl:inherits="value=uri"/>
65533:             <xul:textbox anonid="tags" xbl:inherits="value=tags" emptytext="&editBookmarkTags.label;"/>
65533:           </xul:vbox>
65533: 
65646:          <xul:hbox class="bookmark-controls" align="center">
65533:             <xul:spacer flex="1"/>
65678:             <xul:button anonid="done-button" class="bookmark-done" label="&editBookmarkDone.label;"
65074:                         oncommand="document.getBindingParent(this).stopEditing(true)"/>
65074:           </xul:hbox>
65533:         </xul:vbox>
65533:       </xul:hbox>
65074:     </content>
65533: 
65074:     <implementation>
65074:       <method name="updateFields">
65074:         <body>
65074:           <![CDATA[
65646:             document.getAnonymousElementByAttribute(this, "anonid", "bookmark-item").hidden = this._isEditing;
65646:             document.getAnonymousElementByAttribute(this, "anonid", "bookmark-url").hidden = this._isEditing;
65074: 
65646:             document.getAnonymousElementByAttribute(this, "anonid", "bookmark-manage").hidden = !this._isEditing;
65074:           ]]>
65074:         </body>
65074:       </method>
65074:     </implementation>
65074:   </binding>
65074: 
65533:   <binding id="place-folder" extends="chrome://browser/content/bindings.xml#place-item">
65074:     <implementation>
65074:       <method name="updateFields">
65074:         <body>
65074:           <![CDATA[
65646:             document.getAnonymousElementByAttribute(this, "anonid", "bookmark-item").hidden = this._isEditing;
65646:             document.getAnonymousElementByAttribute(this, "anonid", "bookmark-url").hidden = this._isEditing;
65646: 
65533:             this._uriField.hidden = true;
65533:             this._tagsField.hidden = true;
65646:             document.getAnonymousElementByAttribute(this, "anonid", "bookmark-manage").hidden = !this._isEditing;
65074:           ]]>
65074:         </body>
65074:       </method>
65074:     </implementation>
65074:   </binding>
65074: 
65074:   <binding id="place-label" extends="chrome://browser/content/bindings.xml#place-base">
66055:     <handlers>
66055:       <handler event="click" button="0">
66055:         <![CDATA[
66055:           if (this.control)
66474:             this.control.open(this.previousSibling.itemId);
66055:         ]]>
66055:       </handler>
66055:     </handlers>
66055: 
65074:     <content align="center">
65074:       <xul:spacer xbl:inherits="width=indent"/>
65074:       <xul:image anonid="favicon" class="bookmark-folder-image"/>
65161:       <xul:label anonid="name" crop="end" flex="1" xbl:inherits="value=title"/>
65074:     </content>
65074:   </binding>
65074: 
65074:   <binding id="place-list">
65074:     <content orient="vertical" flex="1">
65690:       <xul:vbox anonid="parent-items" class="place-list-parents" />
66055:       <xul:richlistbox anonid="child-items" class="place-list-children" flex="1" batch="25"/>
65074:     </content>
65074:     <implementation>
65074:       <constructor>
65074:         <![CDATA[
65074:           this._type = this.getAttribute("type");
65074:           this._mode = this.getAttribute("mode");
65913: 
65913:           this._folderParents = {};
66134:           this._folderParents[this._desktopFolderId] = this.mobileRoot;
66134:           this._folderParents[PlacesUtils.bookmarks.unfiledBookmarksFolder] = this._desktopFolderId;
66134:           this._folderParents[PlacesUtils.bookmarksMenuFolderId] = this._desktopFolderId;
66134:           this._folderParents[PlacesUtils.toolbarFolderId] = this._desktopFolderId;
65074:         ]]>
65074:       </constructor>
65161: 
66134:       <field name="_desktopFolderId">-1000</field>
65913:       <field name="_desktopFolder"><![CDATA[
65913:         ({
66134:           itemId: this._desktopFolderId, tags: "", uri: "",
65913:           title: Elements.browserBundle.getString("bookmarkList.desktop"),
65913:           type: Ci.nsINavHistoryResultNode.RESULT_TYPE_FOLDER
65913:         })
65913:       ]]></field>
65913:       <field name="_desktopChildren"><![CDATA[
65913:         [
65913:           {
65913:             itemId: PlacesUtils.bookmarks.unfiledBookmarksFolder, tags: "", uri: "",
65913:             title: PlacesUtils.bookmarks.getItemTitle(PlacesUtils.bookmarks.unfiledBookmarksFolder),
65913:             type: Ci.nsINavHistoryResultNode.RESULT_TYPE_FOLDER
65913:           },
65913:           {
65913:             itemId: PlacesUtils.bookmarksMenuFolderId, tags: "", uri: "",
65913:             title: PlacesUtils.bookmarks.getItemTitle(PlacesUtils.bookmarksMenuFolderId),
65913:             type: Ci.nsINavHistoryResultNode.RESULT_TYPE_FOLDER
65913:           },
65913:           {
65913:             itemId: PlacesUtils.toolbarFolderId, tags: "", uri: "",
65913:             title: PlacesUtils.bookmarks.getItemTitle(PlacesUtils.toolbarFolderId),
65913:             type: Ci.nsINavHistoryResultNode.RESULT_TYPE_FOLDER
65913:           }
65913:         ];
65913:       ]]></field>
65913: 
66173:       <field name="_readOnlyFolders"><![CDATA[
66173:         [
66173:           this._desktopFolderId,
66173:           PlacesUtils.bookmarks.unfiledBookmarksFolder,
66173:           PlacesUtils.bookmarksMenuFolderId,
66173:           PlacesUtils.toolbarFolderId
66173:         ];
66173:       ]]></field>
66173: 
65074:       <field name="_type"/>
65074:       <field name="_mode"/>
65074:       <field name="_activeItem">null</field>
65074:       <field name="_ignoreEditing">false</field>
65074:       <field name="_parents">
65074:         document.getAnonymousElementByAttribute(this, "anonid", "parent-items");
65074:       </field>
65074:       <field name="_children">
65074:         document.getAnonymousElementByAttribute(this, "anonid", "child-items");
65074:       </field>
65074: 
65923:       <field name="scrollBoxObject">this._children.scrollBoxObject</field>
65084: 
65690:       <property name="items" readonly="true" onget="return this._children.childNodes"/>
65690: 
65824:       <field name="mobileRoot"><![CDATA[
65824:         PlacesUtils.annotations.getItemsWithAnnotation("mobile/bookmarksRoot", {})[0];
65824:       ]]></field>
65824: 
65690:       <property name="isRootFolder" readonly="true">
65690:         <getter>
65690:           <![CDATA[
66173:             let currentFolderId = this._parents.lastChild.itemId;
65824:             return currentFolderId == this.mobileRoot;
65690:           ]]>
65690:         </getter>
65690:       </property>
65690: 
65074:       <property name="activeItem">
65074:         <getter>
65074:           <![CDATA[
65074:             return this._activeItem;
65074:           ]]>
65074:         </getter>
65074:         <setter>
65074:           <![CDATA[
65074:             if (!this._ignoreEditing) {
65074:               if (this._activeItem && this._activeItem.isEditing) {
65074:                 this._ignoreEditing = true;
65074:                 this._activeItem.stopEditing(false);
65074:                 this._ignoreEditing = false;
65074:               }
65074: 
65074:               this._activeItem = val;
65074:             }
65074:             return val;
65074:           ]]>
65074:         </setter>
65074:       </property>
65074: 
65913:       <method name="isDesktopFolderEmpty">
65913:         <body>
65913:           <![CDATA[
65913:             let options = PlacesUtils.history.getNewQueryOptions();
65913:             options.queryType = options.QUERY_TYPE_BOOKMARKS;
65913:             let query = PlacesUtils.history.getNewQuery();
65913:             let folders = [ PlacesUtils.bookmarks.unfiledBookmarksFolder,
65913:                             PlacesUtils.bookmarksMenuFolderId,
65913:                             PlacesUtils.toolbarFolderId
65913:                           ];
65913:             query.setFolders(folders, 3);
65913:             let result = PlacesUtils.history.executeQuery(query, options);
65913:             let rootNode = result.root;
65913:             rootNode.containerOpen = true;
65913:             let isEmpty = !rootNode.childCount;
65913:             rootNode.containerOpen = false;
65913: 
65913:             return isEmpty;
65913:           ]]>
65913:         </body>
65913:       </method>
65913: 
65074:       <method name="_getChildren">
65074:         <parameter name="aFolder"/>
65074:         <body>
65074:           <![CDATA[
65074:             let items = [];
65074: 
65074:             let options = PlacesUtils.history.getNewQueryOptions();
65074:             options.queryType = (this._type == "bookmarks" ? options.QUERY_TYPE_BOOKMARKS : options.QUERY_TYPE_HISTORY);
65933: 
65933:             // Exclude "query" items (e.g. "smart folders")
65933:             options.excludeQueries = true;
65933: 
65074:             let query = PlacesUtils.history.getNewQuery();
65074: 
65074:             if (aFolder)
65074:               query.setFolders([aFolder], 1);
65933: 
65074:             let result = PlacesUtils.history.executeQuery(query, options);
65074:             let rootNode = result.root;
65074:             rootNode.containerOpen = true;
65690: 
65074:             let cc = rootNode.childCount;
65074:             for (var i=0; i<cc; ++i) {
65933:               let node = rootNode.getChild(i);
65933: 
65933:               // Ignore separators
65933:               if (node.type == node.RESULT_TYPE_SEPARATOR)
65933:                 continue;
65933: 
65074:               if (this._mode == "folders" && node.type == node.RESULT_TYPE_FOLDER) {
65074:                 items.push(node);
65074:               }
65074:               else if (this._mode == "") {
65074:                 items.push(node);
65074:               }
65074:             }
65074:             rootNode.containerOpen = false;
65074:             return items;
65074:           ]]>
65074:         </body>
65074:       </method>
65074: 
66474:       <method name="open">
65074:         <parameter name="aRootFolder"/>
65074:         <body>
65074:           <![CDATA[
65824:             aRootFolder = aRootFolder || this.mobileRoot;
65074: 
65074:             this._activeItem = null;
65074: 
65074:             let parents = this._parents;
65074:             while (parents.firstChild)
65074:               parents.removeChild(parents.firstChild);
65074: 
65074:             const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
65074:             var self = this;
65074: 
65074:             let folderId = aRootFolder;
65074:             do {
65913:               let title;
66134:               if (folderId == this._desktopFolderId)
65913:                 title = this._desktopFolder.title;
65913:               else
65913:                 title = PlacesUtils.bookmarks.getItemTitle(folderId);
65161: 
65074:               let parent = document.createElementNS(XULNS, "placelabel");
65074:               parent.setAttribute("class", "bookmark-folder");
65074:               parent.setAttribute("itemid", folderId);
65074:               parent.setAttribute("indent", 0);
65161:               parent.setAttribute("title", title);
65074:               parents.insertBefore(parent, parents.firstChild);
65074: 
65913:               folderId = this._folderParents[folderId] || PlacesUtils.bookmarks.getFolderIdForItem(folderId);
65074:             } while (folderId != PlacesUtils.bookmarks.placesRoot)
65074: 
65074:             let children = this._children;
66474:             while (children.lastChild)
66474:               children.removeChild(children.lastChild);
65074: 
65095:             children.scrollBoxObject.scrollTo(0, 0);
65095: 
66134:             let items = (aRootFolder == this._desktopFolderId) ? this._desktopChildren.concat()
65913:                                                                : this._getChildren(aRootFolder);
65913: 
65913:             if (aRootFolder == this.mobileRoot && !this.isDesktopFolderEmpty())
66055:               items.unshift(this._desktopFolder);
65913: 
66055:             children.setItems(items.map(this.createItem));
65074:           ]]>
65074:         </body>
65074:       </method>
65074: 
65161:       <method name="createItem">
65161:         <parameter name="aItem"/>
65074:         <body>
65074:           <![CDATA[
65074:             const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
65074: 
65074:             let child = document.createElementNS(XULNS, "placeitem");
65161:             child.setAttribute("itemid", aItem.itemId);
65074:             child.setAttribute("class", "bookmark-item");
65161:             child.setAttribute("title", aItem.title);
65161:             child.setAttribute("uri", aItem.uri);
65161:             child.setAttribute("tags", aItem.tags);
65161:             if (aItem.type == Ci.nsINavHistoryResultNode.RESULT_TYPE_FOLDER)
65074:               child.setAttribute("type", "folder");
65835:             else
65835:               child.setAttribute("src", aItem.icon);
65074: 
65074:             return child;
65074:           ]]>
65074:         </body>
65074:       </method>
65074: 
65074:       <method name="removeItem">
65074:         <parameter name="aItem"/>
65074:         <body>
65074:           <![CDATA[
65074:             this._children.removeChild(aItem);
65074:           ]]>
65074:         </body>
65074:       </method>
65074: 
65074:       <method name="_fireOpen">
65074:         <parameter name="aEvent"/>
65074:         <parameter name="aItem"/>
65074:         <body>
65074:           <![CDATA[
66134:             let target = aEvent.originalTarget;
66173:             if (target.localName == "button" || this._activeItem == aItem)
65074:               return;
65074: 
65074:             if (aItem.type == "folder") {
66474:               this.open(aItem.itemId);
66474:             } else {
65074:               // Force the item to be active
65074:               this._activeItem = aItem;
65074: 
65074:               // This is a callback used to forward information to some
65074:               // external code [we fire an event & a pseudo attribute event]
65074:               let event = document.createEvent("Events");
65074:               event.initEvent("BookmarkOpen", true, false);
65074:               this.dispatchEvent(event);
66474: 
66474:               let func = new Function("event", this.getAttribute("onopen"));
66474:               func.call(this, aEvent);
66474:             }
66474:           ]]>
66474:         </body>
66474:       </method>
66474:     </implementation>
66474:   </binding>
66474: 
66474:   <binding id="history-list">
66474:     <handlers>
66474:       <handler event="click" button="0">
66474:         <![CDATA[
65074:         let func = new Function("event", this.getAttribute("onopen"));
65074:         func.call(this, event);
66474:         ]]>
66474:       </handler>
66474:     </handlers>
66474:     <content orient="vertical" flex="1">
66474:       <xul:richlistbox anonid="child-items" class="history-list-children" flex="1" batch="25"/>
66474:     </content>
66474:     <implementation>
66474:       <method name="open">
66474:         <body><![CDATA[
66474:           let children = this._children;
66474:           while (children.lastChild)
66474:             children.removeChild(children.lastChild);
66474: 
66474:           let items = this._getHistory();
66474:           children.setItems(items.map(this.createItem));
66474:         ]]></body>
66474:       </method>
66474: 
66474:       <field name="_children">
66474:         document.getAnonymousElementByAttribute(this, "anonid", "child-items");
66474:       </field>
66474: 
66474:       <field name="scrollBoxObject">this._children.scrollBoxObject</field>
66474: 
66474:       <method name="_getHistory">
66474:         <body><![CDATA[
66474:           let items = [];
66474:           let historyService = Cc["@mozilla.org/browser/nav-history-service;1"].getService(Ci.nsINavHistoryService);
66474:           let query = historyService.getNewQuery();
66474: 
66474:           let options = historyService.getNewQueryOptions();
66474:           options.excludeQueries = true;
66474:           options.queryType = options.QUERY_TYPE_HISTORY;
66474:           options.maxResults = Services.prefs.getIntPref("browser.display.history.maxresults");
66474:           options.resultType = options.RESULTS_AS_URI;
66474:           options.sortingMode = options.SORT_BY_DATE_DESCENDING;
66474: 
66474:           let result = historyService.executeQuery(query, options);
66474:           let rootNode = result.root;
66474:           rootNode.containerOpen = true;
66474:           let childCount = rootNode.childCount;
66474: 
66474:           // Get the rows title
66474:           let titleToday = PlacesUtils.getString("finduri-AgeInDays-is-0");
66474:           let titleYesterday = PlacesUtils.getString("finduri-AgeInDays-is-1");
66474:           let titleLastWeek = PlacesUtils.getFormattedString("finduri-AgeInDays-last-is", [7]);
66474:           let titleOlder = PlacesUtils.getFormattedString("finduri-AgeInDays-isgreater", [7]);
66474: 
66474:           let lastTitle = null;
66474:           let msPerDay = 86400000;
66474:           let msPerWeek = msPerDay * 7;
66474:           let today = new Date(Date.now() - (Date.now() % msPerDay));
66474:           for (let i = 0; i < childCount; i++) {
66474:             let node = rootNode.getChild(i);
66474:             let time = new Date(node.time / 1000); // node.time is microseconds
66474: 
66474:             // Insert a row title if needed
66474:             let msDelta = today - time;
66474:             if (msDelta < 0 && lastTitle == null) {
66474:               lastTitle = titleToday;
66474:               items.push({ title: lastTitle });
66474:             } else if (msDelta > 0 && msDelta < msPerDay && lastTitle != titleYesterday) {
66474:                 lastTitle = titleYesterday;
66474:                 items.push({ title: lastTitle });
66474:             } else if (msDelta > msPerDay && msDelta < msPerWeek && lastTitle != titleLastWeek) {
66474:               lastTitle = titleLastWeek;
66474:               items.push({ title: lastTitle });
66474:             } else if (msDelta > msPerWeek && lastTitle != titleOlder) {
66474:               lastTitle = titleOlder;
66474:               items.push({ title: lastTitle });
65074:             }
66474: 
66474:             items.push(node);
66474:           }
66474: 
66474:           rootNode.containerOpen = false;
66474:           return items;
66474:         ]]></body>
66474:       </method>
66474: 
66474:       <method name="createItem">
66474:         <parameter name="aItem"/>
66474:         <body>
66474:           <![CDATA[
66474:             const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
66474: 
66474:             let child = document.createElementNS(XULNS, "autocompleteresult");
66474:             child.setAttribute("value", aItem.title || aItem.uri);
66474:             if (!aItem.uri) {
66474:               child.setAttribute("class", "history-item-title");
66474:             } else {
66474:               child.setAttribute("class", "history-item");
66474:               child.setAttribute("url", aItem.uri);
66474:               child.setAttribute("src", aItem.icon);
66474:             }
66474: 
66474:             return child;
66474:           ]]>
66474:         </body>
66474:       </method>
66474:     </implementation>
66474:   </binding>
66474: 
66474:   <binding id="remotetabs-list">
66474:     <handlers>
66474:       <handler event="click" button="0">
66474:         <![CDATA[
66474:         let func = new Function("event", this.getAttribute("onopen"));
66474:         func.call(this, event);
66474:         ]]>
66474:       </handler>
66474:     </handlers>
66474:     <content orient="vertical" flex="1">
66474:       <xul:richlistbox anonid="child-items" class="remotetabs-list-children" flex="1" batch="25"/>
66474:     </content>
66474:     <implementation>
66474:       <method name="open">
66474:         <body><![CDATA[
66474:           let children = this._children;
66474:           while (children.lastChild)
66474:             children.removeChild(children.lastChild);
66474: 
66474:           let items = this._getRemoteTabs();
66474:           children.setItems(items.map(this.createItem));
66474:         ]]></body>
66474:       </method>
66474: 
66474:       <field name="_children">
66474:         document.getAnonymousElementByAttribute(this, "anonid", "child-items");
66474:       </field>
66474: 
66474:       <field name="scrollBoxObject">this._children.scrollBoxObject</field>
66474: 
66474:       <method name="_getRemoteTabs">
66474:         <body><![CDATA[
66474:           // Don't do anything if the tabs engine isn't ready
66474:           let engine = Weave.Engines.get("tabs");
66474:           if (!engine)
66474:             return [];
66474: 
66474:           // Don't bother refetching tabs if we already did so recently
66474:           let lastFetch = Weave.Svc.Prefs.get("lastTabFetch", 0);
66474:           let now = Math.floor(Date.now() / 1000);
66474:           if (now - lastFetch >= 30) {
66474:             // Force a sync only for the tabs engine
66474:             engine.lastModified = null;
66474:             engine.sync();
66474:             Weave.Svc.Prefs.set("lastTabFetch", now);
66474:           };
66474: 
66474:           // Generate the list of tabs
66474:           let tabs = [];
66474:           for (let [guid, client] in Iterator(engine.getAllClients())) {
66474:             tabs.push({ name: client.clientName });
66474: 
66474:             client.tabs.forEach(function({title, urlHistory, icon}) {
66570:               let pageURL = urlHistory[0];
66474: 
66474:               // Skip tabs that are already open
66570:               if (engine.locallyOpenTabMatchesURL(pageURL))
66474:                 return;
66474: 
66474:               tabs.push({
66570:                 title: title || pageURL,
66570:                 uri: pageURL,
66474:                 icon: Weave.Utils.getIcon(icon, "chrome://browser/skin/images/tab.png")
66474:               });
66474:             });
66474:           };
66474: 
66474:           return tabs;
66474:         ]]></body>
66474:       </method>
66474: 
66474:       <method name="createItem">
66474:         <parameter name="aItem"/>
66474:         <body>
66474:           <![CDATA[
66474:             const XULNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
66474: 
66474:             let child = document.createElementNS(XULNS, "autocompleteresult");
66474:             child.setAttribute("value", aItem.title || aItem.name);
66474:             if (aItem.name) {
66474:               child.setAttribute("class", "remotetabs-item-title");
66474:             } else {
66474:               child.setAttribute("class", "remotetabs-item");
66474:               child.setAttribute("url", aItem.uri);
66474:               child.setAttribute("src", aItem.icon);
66474:             }
66474: 
66474:             return child;
65074:           ]]>
65074:         </body>
65074:       </method>
65074:     </implementation>
65074:   </binding>
65074: 
66055:   <binding id="richlistbox-batch" extends="chrome://global/content/bindings/richlistbox.xml#richlistbox">
66055:     <handlers>
66055:       <handler event="scroll">
66055:         <![CDATA[
66055:           // if there no more items to insert, just return early
66055:           if (this._items.length == 0)
66055:             return;
66055: 
66055:           if (this._contentScrollHeight == -1) {
66055:             let scrollheight = {};
66055:             this.scrollBoxObject.getScrolledSize({}, scrollheight);
66055:             this._contentScrollHeight = scrollheight.value;
66055:           }
66055: 
66055:           let y = {};
66055:           this.scrollBoxObject.getPosition({}, y);
66055:           let scrollRatio = (y.value + this._childrenHeight) / this._contentScrollHeight;
66055: 
66055:           // If we're scrolled 80% to the bottom of the list, append the next
66055:           // set of items
66055:           if (scrollRatio > 0.8)
66055:             this._insertItems();
66055:         ]]>
66055:       </handler>
66055:     </handlers>
66055:     <implementation>
66055:       <!-- Number of elements to add to the list initially. If there are more
66055:            than this many elements to display, only add them to the list once
66055:            the user has scrolled towards them. This is a performance
66055:            optimization to avoid locking up while attempting to append hundreds
66055:            of nodes to our richlistbox.
66055:       -->
66055:       <property name="batchSize" readonly="true" onget="return this.getAttribute('batch')"/>
66055: 
66055:       <field name="_childrenHeight">this.scrollBoxObject.height;</field>
66055:       <field name="_items">[]</field>
66055: 
66055:       <method name="setItems">
66055:         <parameter name="aItems"/>
66055:         <body><![CDATA[
66055:           this._items = aItems;
66055:           this._insertItems();
66055:         ]]></body>
66055:       </method>
66055: 
66055:       <method name="_insertItems">
66055:         <body><![CDATA[
66055:           let items = this._items.splice(0, this.batchSize);
66055:           if (!items.length)
66055:             return; // no items to insert
66055: 
66055:           let count = items.length;
66055:           for (let i = 0; i<count; i++)
66055:             this.appendChild(items[i]);
66055: 
66055: 
66055:           // make sure we recalculate the scrollHeight of the content
66055:           this._contentScrollHeight = -1;
66055:         ]]></body>
66055:       </method>
66055:     </implementation>
66055:   </binding>
66055: 
65544:   <binding id="richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
65544:     <handlers>
65544:       <handler event="mousedown" phase="capturing">
65544:         <![CDATA[
65544:           event.stopPropagation();
65544:         ]]>
65544:       </handler>
65544:     </handlers>
65544:   </binding>
65544: 
66372:   <binding id="content-navigator">
66372:     <content pack="end">
66378:       <children includes="vbox"/>
66419:       <xul:hbox class="content-navigator-box panel-dark" pack="end">
66378:         <children includes="textbox|arrowscrollbox"/>
66419:         <xul:toolbarbutton anonid="previous-button" class="content-navigator-item button-image previous-button" xbl:inherits="command=previous"/>
66419:         <xul:toolbarbutton anonid="next-button" class="content-navigator-item button-image next-button" xbl:inherits="command=next"/>
66372:       </xul:hbox>
66372:     </content>
66372: 
66372:     <implementation>
66372:       <field name="_previousButton">
66372:         document.getAnonymousElementByAttribute(this, "anonid", "previous-button");
66372:       </field>
66372: 
66372:       <field name="_nextButton">
66372:         document.getAnonymousElementByAttribute(this, "anonid", "next-button");
66372:       </field>
66372: 
66372:       <field name="_spacer">
66372:         document.getElementById(this.getAttribute("spacer"));
66372:       </field>
66372: 
66372:       <method name="contentHasChanged">
66372:         <body><![CDATA[
66372:           let height = Math.floor(this.getBoundingClientRect().height);
66372:           this.top = window.innerHeight - height;
66372:           this._spacer.setAttribute("height", height);
66372:         ]]></body>
66372:       </method>
66372: 
66372:       <field name="_model">null</field>
66372:       <method name="show">
66372:         <parameter name="aModel" />
66372:         <body><![CDATA[
66372:           // call the hide callback of the current object if any
66372:           if (this._model && this._model.type != aModel.type)
66372:             this._model.hide();
66372: 
66372:           this.setAttribute("type", aModel.type);
66372:           this.setAttribute("next", aModel.commands.next);
66372:           this.setAttribute("previous", aModel.commands.previous);
66372:           this.setAttribute("close", aModel.commands.close);
66372: 
66372:           // buttons attributes sync with commands doesn not look updated when
66372:           // we dynamically switch the "command" attribute so we need to ensure
66372:           // the disabled state of the buttons is right when switching commands
66372:           this._previousButton.disabled = document.getElementById(aModel.commands.previous).disabled;
66372:           this._nextButton.disabled = document.getElementById(aModel.commands.next).disabled;
66372: 
66372:           this._model = aModel;
66372:           this.contentHasChanged();
66372:           this._spacer.hidden = false;
66372:         ]]></body>
66372:       </method>
66372: 
66372:       <method name="hide">
66372:         <parameter name="aModel" />
66372:         <body><![CDATA[
66372:           this.removeAttribute("next");
66372:           this.removeAttribute("previous");
66372:           this.removeAttribute("close");
66372:           this.removeAttribute("type");
66372: 
66372:           this._model = null;
66376:           this._spacer.hidden = true;
66372: 
66372:           // give the form spacer area back to the content
66372:           // XXX this should probably be removed with layers
66372:           Browser.forceChromeReflow();
66372:           Browser.contentScrollboxScroller.scrollBy(0, 0);
66372:           Browser._browserView.onAfterVisibleMove();
66372:         ]]></body>
66372:       </method>
66372:     </implementation>
66372:   </binding>
66372: 
65573:   <binding id="menulist" display="xul:box" extends="chrome://global/content/bindings/menulist.xml#menulist">
65573:     <handlers>
65573:       <handler event="mousedown" phase="capturing">
65573:         <![CDATA[
65573:           // Stop the normal menupopup from appearing
65573:           event.stopPropagation();
65573:         ]]>
65573:       </handler>
65573: 
65573:       <handler event="click" button="0">
65573:         <![CDATA[
65573:           if (this.disabled || this.itemCount == 0)
65573:             return;
65573: 
65573:           this.focus();
66479:           MenuListHelperUI.show(this);
65573:         ]]>
65573:       </handler>
65573:     </handlers>
65573:   </binding>
65573: 
65285:   <binding id="chrome-select-option">
65316:     <content orient="horizontal" flex="1">
66418:       <xul:image class="chrome-select-option-image" anonid="check"/>
65285:       <xul:label anonid="label" xbl:inherits="value=label"/>
65285:     </content>
65285: 
65285:     <implementation>
65285:       <property name="selected">
65285:         <getter>
65285:           <![CDATA[
65285:             return this.hasAttribute("selected");
65285:           ]]>
65285:         </getter>
65285:         <setter>
65285:           <![CDATA[
65285:             if (val)
65285:               this.setAttribute("selected", "true");
65285:             else
65285:               this.removeAttribute("selected");
65285:             return val;
65285:           ]]>
65285:         </setter>
65285:       </property>
65285:     </implementation>
65285:   </binding>
66139: 
66276:   <binding id="select-button" extends="xul:box">
66139:     <content>
66592:       <svg:svg width="11px" version="1.1" xmlns="http://www.w3.org/2000/svg" style="position: absolute; top: -moz-calc(50% - 2px); left: 4px;">
66139:         <svg:polyline points="1 1 5 6 9 1" stroke="#414141" stroke-width="2" stroke-linecap="round" fill="transparent" stroke-linejoin="round"/>
66139:       </svg:svg>
66139:     </content>
66139:   </binding>
64755: </bindings>
