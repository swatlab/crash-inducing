     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #ifndef nsTableOuterFrame_h__
     1: #define nsTableOuterFrame_h__
     1: 
113981: #include "mozilla/Attributes.h"
     1: #include "nscore.h"
 86231: #include "nsContainerFrame.h"
125899: #include "nsCellMap.h"
     1: #include "nsBlockFrame.h"
 78204: #include "nsTableFrame.h"
     1: 
     1: class nsTableCaptionFrame : public nsBlockFrame
     1: {
     1: public:
 32423:   NS_DECL_FRAMEARENA_HELPERS
 32423: 
     1:   // nsISupports
     1:   virtual nsIAtom* GetType() const;
     1:   friend nsIFrame* NS_NewTableCaptionFrame(nsIPresShell* aPresShell, nsStyleContext*  aContext);
     1: 
 68481:   virtual nsSize ComputeAutoSize(nsRenderingContext *aRenderingContext,
     1:                                  nsSize aCBSize, nscoord aAvailableWidth,
     1:                                  nsSize aMargin, nsSize aBorder,
 79445:                                  nsSize aPadding, bool aShrinkWrap);
     1: 
 90155:   virtual nsIFrame* GetParentStyleContextFrame() const;
 78202: 
  3151: #ifdef ACCESSIBILITY
118929:   virtual mozilla::a11y::AccType AccessibleType() MOZ_OVERRIDE;
  3151: #endif
  3151: 
102909: #ifdef DEBUG
113981:   NS_IMETHOD GetFrameName(nsAString& aResult) const MOZ_OVERRIDE;
     1: #endif
     1: 
     1: protected:
     1:   nsTableCaptionFrame(nsStyleContext*  aContext);
     1:   virtual ~nsTableCaptionFrame();
     1: };
     1: 
     1: 
     1: /* TODO
     1: 1. decide if we'll allow subclassing.  If so, decide which methods really need to be virtual.
     1: */
     1: 
     1: /**
     1:  * main frame for an nsTable content object, 
     1:  * the nsTableOuterFrame contains 0 or one caption frame, and a nsTableFrame
     1:  * pseudo-frame (referred to as the "inner frame').
     1:  */
125899: class nsTableOuterFrame : public nsContainerFrame
     1: {
     1: public:
 23554:   NS_DECL_QUERYFRAME
 32423:   NS_DECL_FRAMEARENA_HELPERS
     1: 
125899:   NS_DECL_QUERYFRAME_TARGET(nsTableOuterFrame)
125899: 
     1:   /** instantiate a new instance of nsTableRowFrame.
     1:     * @param aPresShell the pres shell for this frame
     1:     *
     1:     * @return           the frame that was created
     1:     */
     1:   friend nsIFrame* NS_NewTableOuterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1:   
     1:   // nsIFrame overrides - see there for a description
     1: 
 36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
     1: 
 77154:   NS_IMETHOD SetInitialChildList(ChildListID     aListID,
113981:                                  nsFrameList&    aChildList) MOZ_OVERRIDE;
     1:  
 91756:   virtual const nsFrameList& GetChildList(ChildListID aListID) const;
113981:   virtual void GetChildLists(nsTArray<ChildList>* aLists) const MOZ_OVERRIDE;
     1: 
 77154:   NS_IMETHOD AppendFrames(ChildListID     aListID,
113981:                           nsFrameList&    aFrameList) MOZ_OVERRIDE;
     1: 
 77154:   NS_IMETHOD InsertFrames(ChildListID     aListID,
     1:                           nsIFrame*       aPrevFrame,
113981:                           nsFrameList&    aFrameList) MOZ_OVERRIDE;
     1: 
 77154:   NS_IMETHOD RemoveFrame(ChildListID     aListID,
113981:                          nsIFrame*       aOldFrame) MOZ_OVERRIDE;
     1: 
     1:   virtual nsIFrame* GetContentInsertionFrame() {
 77154:     return GetFirstPrincipalChild()->GetContentInsertionFrame();
     1:   }
     1: 
     1: #ifdef ACCESSIBILITY
118929:   virtual mozilla::a11y::AccType AccessibleType() MOZ_OVERRIDE;
     1: #endif
     1: 
132778:   virtual void BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                 const nsRect&           aDirtyRect,
113981:                                 const nsDisplayListSet& aLists) MOZ_OVERRIDE;
     1: 
132778:   void BuildDisplayListForInnerTable(nsDisplayListBuilder*   aBuilder,
     1:                                      const nsRect&           aDirtyRect,
     1:                                      const nsDisplayListSet& aLists);
     1: 
132239:   virtual nscoord GetBaseline() const MOZ_OVERRIDE;
     1: 
113981:   virtual nscoord GetMinWidth(nsRenderingContext *aRenderingContext) MOZ_OVERRIDE;
113981:   virtual nscoord GetPrefWidth(nsRenderingContext *aRenderingContext) MOZ_OVERRIDE;
 68481:   virtual nsSize ComputeAutoSize(nsRenderingContext *aRenderingContext,
     1:                                  nsSize aCBSize, nscoord aAvailableWidth,
     1:                                  nsSize aMargin, nsSize aBorder,
113981:                                  nsSize aPadding, bool aShrinkWrap) MOZ_OVERRIDE;
     1: 
     1:   /** process a reflow command for the table.
     1:     * This involves reflowing the caption and the inner table.
     1:     * @see nsIFrame::Reflow */
     1:   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
     1:                     nsHTMLReflowMetrics&     aDesiredSize,
     1:                     const nsHTMLReflowState& aReflowState,
113981:                     nsReflowStatus&          aStatus) MOZ_OVERRIDE;
     1: 
     1:   /**
     1:    * Get the "type" of the frame
     1:    *
     1:    * @see nsGkAtoms::tableOuterFrame
     1:    */
113981:   virtual nsIAtom* GetType() const MOZ_OVERRIDE;
     1: 
     1: #ifdef DEBUG
113981:   NS_IMETHOD GetFrameName(nsAString& aResult) const MOZ_OVERRIDE;
     1: #endif
     1: 
113981:   virtual nsIFrame* GetParentStyleContextFrame() const MOZ_OVERRIDE;
     1: 
125899:   /**
125899:    * Return the content for the cell at the given row and column.
125899:    */
125899:   nsIContent* GetCellAt(uint32_t aRowIdx, uint32_t aColIdx) const;
     1: 
125899:   /**
125899:    * Return the number of rows in the table.
125899:    */
125899:   int32_t GetRowCount() const
125899:   {
125899:     return InnerTableFrame()->GetRowCount();
125899:   }
     1: 
125899:   /**
125899:    * Return the number of columns in the table.
125899:    */
125899:   int32_t GetColCount() const
125899:   {
125899:     return InnerTableFrame()->GetColCount();
125899:   }
     1: 
125899:   /**
125899:    * Return the index of the cell at the given row and column.
125899:    */
125899:   int32_t GetIndexByRowAndColumn(int32_t aRowIdx, int32_t aColIdx) const
125899:   {
125899:     nsTableCellMap* cellMap = InnerTableFrame()->GetCellMap();
125899:     if (!cellMap)
125899:       return -1;
125899: 
125899:     return cellMap->GetIndexByRowAndColumn(aRowIdx, aColIdx);
125899:   }
125899: 
125899:   /**
125899:    * Get the row and column indices for the cell at the given index.
125899:    */
125899:   void GetRowAndColumnByIndex(int32_t aCellIdx, int32_t* aRowIdx,
125899:                               int32_t* aColIdx) const
125899:   {
125899:     *aRowIdx = *aColIdx = 0;
125899:     nsTableCellMap* cellMap = InnerTableFrame()->GetCellMap();
125899:     if (cellMap) {
125899:       cellMap->GetRowAndColumnByIndex(aCellIdx, aRowIdx, aColIdx);
125899:     }
125899:   }
125899: 
125899:   /**
125899:    * return the frame for the cell at the given row and column.
125899:    */
125899:   nsTableCellFrame* GetCellFrameAt(uint32_t aRowIdx, uint32_t aColIdx) const
125899:   {
125899:     nsTableCellMap* map = InnerTableFrame()->GetCellMap();
125899:     if (!map) {
125899:       return nullptr;
125899:     }
125899: 
125899:     return map->GetCellInfoAt(aRowIdx, aColIdx);
125899:   }
125899: 
125899:   /**
125899:    * Return the col span of the cell at the given row and column indices.
125899:    */
125899:   uint32_t GetEffectiveColSpanAt(uint32_t aRowIdx, uint32_t aColIdx) const
125899:   {
125899:     nsTableCellMap* map = InnerTableFrame()->GetCellMap();
125899:     return map->GetEffectiveColSpan(aRowIdx, aColIdx);
125899:   }
125899: 
125899:   /**
125899:    * Return the effective row span of the cell at the given row and column.
125899:    */
125899:   uint32_t GetEffectiveRowSpanAt(uint32_t aRowIdx, uint32_t aColIdx) const
125899:   {
125899:     nsTableCellMap* map = InnerTableFrame()->GetCellMap();
125899:     return map->GetEffectiveRowSpan(aRowIdx, aColIdx);
125899:   }
 11311: 
     1: protected:
     1: 
     1: 
     1:   nsTableOuterFrame(nsStyleContext* aContext);
     1:   virtual ~nsTableOuterFrame();
     1: 
     1:   void InitChildReflowState(nsPresContext&    aPresContext,                     
     1:                             nsHTMLReflowState& aReflowState);
     1: 
108991:   uint8_t GetCaptionSide(); // NS_STYLE_CAPTION_SIDE_* or NO_SIDE
 12309: 
 79445:   bool HasSideCaption() {
108991:     uint8_t captionSide = GetCaptionSide();
 12309:     return captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
 12309:            captionSide == NS_STYLE_CAPTION_SIDE_RIGHT;
 12309:   }
     1:   
108991:   uint8_t GetCaptionVerticalAlign();
     1: 
108991:   void SetDesiredSize(uint8_t         aCaptionSide,
     1:                       const nsMargin& aInnerMargin,
     1:                       const nsMargin& aCaptionMargin,
     1:                       nscoord&        aWidth,
     1:                       nscoord&        aHeight);
     1: 
108991:   nsresult   GetCaptionOrigin(uint32_t         aCaptionSide,
     1:                               const nsSize&    aContainBlockSize,
     1:                               const nsSize&    aInnerSize, 
     1:                               const nsMargin&  aInnerMargin,
     1:                               const nsSize&    aCaptionSize,
     1:                               nsMargin&        aCaptionMargin,
     1:                               nsPoint&         aOrigin);
     1: 
108991:   nsresult   GetInnerOrigin(uint32_t         aCaptionSide,
     1:                             const nsSize&    aContainBlockSize,
     1:                             const nsSize&    aCaptionSize, 
     1:                             const nsMargin&  aCaptionMargin,
     1:                             const nsSize&    aInnerSize,
     1:                             nsMargin&        aInnerMargin,
     1:                             nsPoint&         aOrigin);
     1:   
     1:   // reflow the child (caption or innertable frame)
 12308:   void OuterBeginReflowChild(nsPresContext*           aPresContext,
     1:                              nsIFrame*                aChildFrame,
     1:                              const nsHTMLReflowState& aOuterRS,
     1:                              void*                    aChildRSSpace,
 12308:                              nscoord                  aAvailWidth);
 12308: 
 12308:   nsresult OuterDoReflowChild(nsPresContext*           aPresContext,
 12308:                               nsIFrame*                aChildFrame,
 12308:                               const nsHTMLReflowState& aChildRS,
     1:                               nsHTMLReflowMetrics&     aMetrics,
     1:                               nsReflowStatus&          aStatus);
     1: 
     1:   // Set the reflow metrics
108991:   void UpdateReflowMetrics(uint8_t              aCaptionSide,
     1:                            nsHTMLReflowMetrics& aMet,
     1:                            const nsMargin&      aInnerMargin,
     1:                            const nsMargin&      aCaptionMargin);
     1: 
     1:   // Get the margin.  aMarginNoAuto is aMargin, but with auto 
     1:   // margins set to 0
 36583:   void GetChildMargin(nsPresContext*           aPresContext,
     1:                       const nsHTMLReflowState& aOuterRS,
     1:                       nsIFrame*                aChildFrame,
     1:                       nscoord                  aAvailableWidth,
     1:                       nsMargin&                aMargin);
     1: 
136175:   virtual bool IsFrameOfType(uint32_t aFlags) const
136175:   {
136175:     return nsContainerFrame::IsFrameOfType(aFlags &
136175:                                            (~eCanContainOverflowContainers));
136175:   }
136175: 
 90155:   nsTableFrame* InnerTableFrame() const {
 78204:     return static_cast<nsTableFrame*>(mFrames.FirstChild());
 78204:   }
 78204:   
     1: private:
     1:   nsFrameList   mCaptionFrames;
     1: };
     1: 
     1: #endif
