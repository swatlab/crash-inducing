34546: /* -*- Mode: C++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
34546: /* ***** BEGIN LICENSE BLOCK *****
34546:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
34546:  *
34546:  * The contents of this file are subject to the Mozilla Public License Version
34546:  * 1.1 (the "License"); you may not use this file except in compliance with
34546:  * the License. You may obtain a copy of the License at
34546:  * http://www.mozilla.org/MPL/
34546:  *
34546:  * Software distributed under the License is distributed on an "AS IS" basis,
34546:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
34546:  * for the specific language governing rights and limitations under the
34546:  * License.
34546:  *
34546:  * The Original Code is mozilla.org code.
34546:  *
34546:  * The Initial Developer of the Original Code is
34546:  *   Mozilla Corp
34546:  * Portions created by the Initial Developer are Copyright (C) 2009
34546:  * the Initial Developer. All Rights Reserved.
34546:  *
34546:  * Contributor(s):
34546:  *  Vladimir Vukicevic <vladimir@pobox.com>
34546:  *
34546:  * Alternatively, the contents of this file may be used under the terms of
34546:  * either the GNU General Public License Version 2 or later (the "GPL"), or
34546:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
34546:  * in which case the provisions of the GPL or the LGPL are applicable instead
34546:  * of those above. If you wish to allow use of your version of this file only
34546:  * under the terms of either the GPL or the LGPL, and not to allow others to
34546:  * use your version of this file under the terms of the MPL, indicate your
34546:  * decision by deleting the provisions above and replace them with the notice
34546:  * and other provisions required by the GPL or the LGPL. If you do not delete
34546:  * the provisions above, a recipient may use your version of this file under
34546:  * the terms of any one of the MPL, the GPL or the LGPL.
34546:  *
34546:  * ***** END LICENSE BLOCK ***** */
34546: 
34546: #include <windows.h>
34546: #include <winternl.h>
34546: 
34546: #include <stdio.h>
34546: 
34546: #include "nsAutoPtr.h"
34546: 
34546: #include "prlog.h"
34546: 
34546: #include "nsWindowsDllInterceptor.h"
34546: 
34546: #define IN_WINDOWS_DLL_BLOCKLIST
34546: #include "nsWindowsDllBlocklist.h"
34546: 
34611: #ifndef STATUS_DLL_NOT_FOUND
34611: #define STATUS_DLL_NOT_FOUND ((DWORD)0xC0000135L)
34611: #endif
34611: 
34749: // define this for very verbose dll load debug spew
34749: #undef DEBUG_very_verbose
34749: 
34749: // The signature for LdrLoadDll changed at some point, with the second arg
34749: // becoming a PULONG instead of a ULONG.  This should only matter on 64-bit
34749: // systems, for which there was no support earlier -- on 32-bit systems,
34749: // they should be the same size.
34749: PR_STATIC_ASSERT(sizeof(PULONG) == sizeof(ULONG));
34749: 
34546: typedef NTSTATUS (NTAPI *LdrLoadDll_func) (PWCHAR filePath, PULONG flags, PUNICODE_STRING moduleFileName, PHANDLE handle);
34546: 
34546: static LdrLoadDll_func stub_LdrLoadDll = 0;
34546: 
34546: static NTSTATUS NTAPI
34546: patched_LdrLoadDll (PWCHAR filePath, PULONG flags, PUNICODE_STRING moduleFileName, PHANDLE handle)
34546: {
34546:   // We have UCS2 (UTF16?), we want ASCII, but we also just want the filename portion
34546: #define DLLNAME_MAX 128
34546:   char dllName[DLLNAME_MAX+1];
34546: 
34749:   int len = moduleFileName->Length / 2;
34749:   wchar_t *fname = moduleFileName->Buffer;
34546: 
34749:   // The filename isn't guaranteed to be null terminated, but in practice
34749:   // it always will be; ensure that this is so, and bail if not.
34749:   // This is done instead of the more robust approach because of bug 527122,
34749:   // where lots of weird things were happening when we tried to make a copy.
34749:   if (moduleFileName->MaximumLength < moduleFileName->Length+2 ||
34749:       fname[len] != 0)
34749:   {
34749: #ifdef DEBUG
34749:     printf_stderr("LdrLoadDll: non-null terminated string found!\n");
34749: #endif
34749:     goto continue_loading;
34749:   }
34546: 
34546:   wchar_t *dll_part = wcsrchr(fname, L'\\');
34546:   if (dll_part) {
34546:     dll_part = dll_part + 1;
34749:     len -= dll_part - fname;
34546:   } else {
34546:     dll_part = fname;
34546:   }
34546: 
34749: #ifdef DEBUG_very_verbose
34749:   printf_stderr("LdrLoadDll: dll_part '%S' %d\n", dll_part, len);
34749: #endif
34749: 
34546:   // if it's too long, then, we assume we won't want to block it,
34546:   // since DLLNAME_MAX should be at least long enough to hold the longest
34546:   // entry in our blocklist.
34749:   if (len > DLLNAME_MAX) {
34749: #ifdef DEBUG
34749:     printf_stderr("LdrLoadDll: len too long! %d\n", len);
34749: #endif
34546:     goto continue_loading;
34749:   }
34546: 
34546:   // copy over to our char byte buffer, lowercasing ASCII as we go
34546:   for (int i = 0; i < len; i++) {
34546:     wchar_t c = dll_part[i];
34546: 
34546:     if (c > 0x7f) {
34546:       // welp, it's not ascii; if we need to add non-ascii things to
34546:       // our blocklist, we'll have to remove this limitation.
34546:       goto continue_loading;
34546:     }
34546: 
34749:     // ensure that dll name is all lowercase
34749:     if (c >= 'A' && c <= 'Z')
34749:       c += 'a' - 'A';
34749: 
34546:     dllName[i] = (char) c;
34546:   }
34546: 
34546:   dllName[len] = 0;
34546: 
34749: #ifdef DEBUG_very_verbose
34749:   printf_stderr("LdrLoadDll: dll name '%s'\n", dllName);
34749: #endif
34749: 
34546:   // then compare to everything on the blocklist
34546:   DllBlockInfo *info = &sWindowsDllBlocklist[0];
34546:   while (info->name) {
34546:     if (strcmp(info->name, dllName) == 0)
34546:       break;
34546: 
34546:     info++;
34546:   }
34546: 
34546:   if (info->name) {
34749:     bool load_ok = false;
34749: 
34749: #ifdef DEBUG_very_verbose
34749:     printf_stderr("LdrLoadDll: info->name: '%s'\n", info->name);
34749: #endif
34546: 
34546:     if (info->maxVersion != ALL_VERSIONS) {
34546:       // figure out the length of the string that we need
34546:       DWORD pathlen = SearchPathW(filePath, fname, L".dll", 0, NULL, NULL);
34546:       if (pathlen == 0) {
34546:         // uh, we couldn't find the DLL at all, so...
34749:         printf_stderr("LdrLoadDll: Blocking load of '%s' (SearchPathW didn't find it?)\n", dllName);
34546:         return STATUS_DLL_NOT_FOUND;
34546:       }
34546: 
34749:       wchar_t *full_fname = (wchar_t*) malloc(sizeof(wchar_t)*(pathlen+1));
34749:       if (!full_fname) {
34749:         // couldn't allocate memory?
34749:         return STATUS_DLL_NOT_FOUND;
34749:       }
34546: 
34546:       // now actually grab it
34546:       SearchPathW(filePath, fname, L".dll", pathlen+1, full_fname, NULL);
34546: 
34546:       DWORD zero;
34546:       DWORD infoSize = GetFileVersionInfoSizeW(full_fname, &zero);
34546: 
34546:       // If we failed to get the version information, we block.
34546: 
34546:       if (infoSize != 0) {
34546:         nsAutoArrayPtr<unsigned char> infoData = new unsigned char[infoSize];
34546:         VS_FIXEDFILEINFO *vInfo;
34546:         UINT vInfoLen;
34546: 
34546:         if (GetFileVersionInfoW(full_fname, 0, infoSize, infoData) &&
34546:             VerQueryValueW(infoData, L"\\", (LPVOID*) &vInfo, &vInfoLen))
34546:         {
34546:           unsigned long long fVersion =
34546:             ((unsigned long long)vInfo->dwFileVersionMS) << 32 |
34546:             ((unsigned long long)vInfo->dwFileVersionLS);
34546: 
34546:           // finally do the version check, and if it's greater than our block
34546:           // version, keep loading
34546:           if (fVersion > info->maxVersion)
34749:             load_ok = true;
34546:         }
34546:       }
34546: 
34749:       free(full_fname);
34749:     }
34749: 
34749:     if (!load_ok) {
34749:       printf_stderr("LdrLoadDll: Blocking load of '%s' -- see http://www.mozilla.com/en-US/blocklist/\n", dllName);
34546:       return STATUS_DLL_NOT_FOUND;
34546:     }
34749:   }
34546: 
34546: continue_loading:
34749: #ifdef DEBUG_very_verbose
34749:   printf_stderr("LdrLoadDll: continuing load... ('%S')\n", moduleFileName->Buffer);
34749: #endif
34749: 
36449:   NS_SetHasLoadedNewDLLs();
36449: 
34546:   return stub_LdrLoadDll(filePath, flags, moduleFileName, handle);
34546: }
34546: 
34546: WindowsDllInterceptor NtDllIntercept;
34546: 
34546: void
34546: SetupDllBlocklist()
34546: {
34546:   NtDllIntercept.Init("ntdll.dll");
34546: 
34546:   bool ok = NtDllIntercept.AddHook("LdrLoadDll", patched_LdrLoadDll, (void**) &stub_LdrLoadDll);
34546: 
34749: #ifdef DEBUG
34546:   if (!ok)
34749:     printf_stderr ("LdrLoadDll hook failed, no dll blocklisting active\n");
34749: #endif
34546: }
