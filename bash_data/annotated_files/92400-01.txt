23697: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
23697: /* ***** BEGIN LICENSE BLOCK *****
23697:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
23697:  *
23697:  * The contents of this file are subject to the Mozilla Public License Version
23697:  * 1.1 (the "License"); you may not use this file except in compliance with
23697:  * the License. You may obtain a copy of the License at
23697:  * http://www.mozilla.org/MPL/
23697:  *
23697:  * Software distributed under the License is distributed on an "AS IS" basis,
23697:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
23697:  * for the specific language governing rights and limitations under the
23697:  * License.
23697:  *
23697:  * The Original Code is the Mozilla SMIL module.
23697:  *
23697:  * The Initial Developer of the Original Code is Brian Birtles.
23697:  * Portions created by the Initial Developer are Copyright (C) 2005
23697:  * the Initial Developer. All Rights Reserved.
23697:  *
23697:  * Contributor(s):
23697:  *   Brian Birtles <birtles@gmail.com>
23697:  *   Daniel Holbert <dholbert@mozilla.com>
55139:  *   Robert Longson <longsonr@gmail.com>
23697:  *
23697:  * Alternatively, the contents of this file may be used under the terms of
23697:  * either of the GNU General Public License Version 2 or later (the "GPL"),
23697:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
23697:  * in which case the provisions of the GPL or the LGPL are applicable instead
23697:  * of those above. If you wish to allow use of your version of this file only
23697:  * under the terms of either the GPL or the LGPL, and not to allow others to
23697:  * use your version of this file under the terms of the MPL, indicate your
23697:  * decision by deleting the provisions above and replace them with the notice
23697:  * and other provisions required by the GPL or the LGPL. If you do not delete
23697:  * the provisions above, a recipient may use your version of this file under
23697:  * the terms of any one of the MPL, the GPL or the LGPL.
23697:  *
23697:  * ***** END LICENSE BLOCK ***** */
23697: 
23697: #include "nsSMILAnimationController.h"
23697: #include "nsSMILCompositor.h"
33401: #include "nsSMILCSSProperty.h"
33401: #include "nsCSSProps.h"
23697: #include "nsComponentManagerUtils.h"
23697: #include "nsITimer.h"
23697: #include "nsIContent.h"
42326: #include "mozilla/dom/Element.h"
23697: #include "nsIDocument.h"
23697: #include "nsISMILAnimationElement.h"
23697: #include "nsIDOMSVGAnimationElement.h"
23697: #include "nsSMILTimedElement.h"
23697: 
42326: using namespace mozilla::dom;
42326: 
23697: //----------------------------------------------------------------------
23697: // nsSMILAnimationController implementation
23697: 
23697: //----------------------------------------------------------------------
23697: // ctors, dtors, factory methods
23697: 
69077: nsSMILAnimationController::nsSMILAnimationController(nsIDocument* aDoc)
58112:   : mAvgTimeBetweenSamples(0),
80486:     mResampleNeeded(false),
80486:     mDeferredStartSampling(false),
80486:     mRunningSample(false),
69077:     mDocument(aDoc)
23697: {
69077:   NS_ABORT_IF_FALSE(aDoc, "need a non-null document");
69077: 
23697:   mAnimationElementTable.Init();
23697:   mChildContainerTable.Init();
23697: 
69079:   nsRefreshDriver* refreshDriver = GetRefreshDriver();
54303:   if (refreshDriver) {
54303:     mStartTime = refreshDriver->MostRecentRefresh();
54303:   } else {
54303:     mStartTime = mozilla::TimeStamp::Now();
54303:   }
54303:   mCurrentSampleTime = mStartTime;
23697: 
23697:   Begin();
69077: }
23697: 
69077: nsSMILAnimationController::~nsSMILAnimationController()
69077: {
69077:   NS_ASSERTION(mAnimationElementTable.Count() == 0,
69077:                "Animation controller shouldn't be tracking any animation"
69077:                " elements when it dies");
23697: }
23697: 
69078: void
69078: nsSMILAnimationController::Disconnect()
69078: {
69078:   NS_ABORT_IF_FALSE(mDocument, "disconnecting when we weren't connected...?");
69078:   NS_ABORT_IF_FALSE(mRefCnt.get() == 1,
69078:                     "Expecting to disconnect when doc is sole remaining owner");
74743:   NS_ASSERTION(mPauseState & nsSMILTimeContainer::PAUSE_PAGEHIDE,
69790:                "Expecting to be paused for pagehide before disconnect");
69078: 
69079:   StopSampling(GetRefreshDriver());
69078: 
69078:   mDocument = nsnull; // (raw pointer)
69078: }
69078: 
23697: //----------------------------------------------------------------------
23697: // nsSMILTimeContainer methods:
23697: 
23697: void
23697: nsSMILAnimationController::Pause(PRUint32 aType)
23697: {
23697:   nsSMILTimeContainer::Pause(aType);
23697: 
23697:   if (mPauseState) {
80486:     mDeferredStartSampling = false;
69079:     StopSampling(GetRefreshDriver());
23697:   }
23697: }
23697: 
23697: void
23697: nsSMILAnimationController::Resume(PRUint32 aType)
23697: {
79445:   bool wasPaused = (mPauseState != 0);
58112:   // Update mCurrentSampleTime so that calls to GetParentTime--used for
58112:   // calculating parent offsets--are accurate
58112:   mCurrentSampleTime = mozilla::TimeStamp::Now();
23697: 
23697:   nsSMILTimeContainer::Resume(aType);
23697: 
24029:   if (wasPaused && !mPauseState && mChildContainerTable.Count()) {
39626:     Sample(); // Run the first sample manually
69079:     MaybeStartSampling(GetRefreshDriver());
23697:   }
23697: }
23697: 
23697: nsSMILTime
23697: nsSMILAnimationController::GetParentTime() const
23697: {
54303:   return (nsSMILTime)(mCurrentSampleTime - mStartTime).ToMilliseconds();
23697: }
23697: 
23697: //----------------------------------------------------------------------
39626: // nsARefreshObserver methods:
39626: NS_IMPL_ADDREF(nsSMILAnimationController)
39626: NS_IMPL_RELEASE(nsSMILAnimationController)
39626: 
39626: // nsRefreshDriver Callback function
39626: void
39626: nsSMILAnimationController::WillRefresh(mozilla::TimeStamp aTime)
39626: {
54303:   // Although we never expect aTime to go backwards, when we initialise the
54303:   // animation controller, if we can't get hold of a refresh driver we
54303:   // initialise mCurrentSampleTime to Now(). It may be possible that after
54303:   // doing so we get sampled by a refresh driver whose most recent refresh time
54303:   // predates when we were initialised, so to be safe we make sure to take the
54303:   // most recent time here.
58112:   aTime = NS_MAX(mCurrentSampleTime, aTime);
58112: 
58112:   // Sleep detection: If the time between samples is a whole lot greater than we
58112:   // were expecting then we assume the computer went to sleep or someone's
58112:   // messing with the clock. In that case, fiddle our parent offset and use our
58112:   // average time between samples to calculate the new sample time. This
58112:   // prevents us from hanging while trying to catch up on all the missed time.
58112: 
58112:   // Smoothing of coefficient for the average function. 0.2 should let us track
58112:   // the sample rate reasonably tightly without being overly affected by
58112:   // occasional delays.
58112:   static const double SAMPLE_DUR_WEIGHTING = 0.2;
58112:   // If the elapsed time exceeds our expectation by this number of times we'll
58112:   // initiate special behaviour to basically ignore the intervening time.
58112:   static const double SAMPLE_DEV_THRESHOLD = 200.0;
58112: 
58112:   nsSMILTime elapsedTime =
58112:     (nsSMILTime)(aTime - mCurrentSampleTime).ToMilliseconds();
58112:   // First sample:
58112:   if (mAvgTimeBetweenSamples == 0) {
58112:     mAvgTimeBetweenSamples = elapsedTime;
58112:   // Unexpectedly long delay between samples:
58112:   } else if (elapsedTime > SAMPLE_DEV_THRESHOLD * mAvgTimeBetweenSamples) {
58112:     NS_WARNING("Detected really long delay between samples, continuing from "
58112:                "previous sample");
58112:     mParentOffset += elapsedTime - mAvgTimeBetweenSamples;
58112:   // Usual case, update moving average:
58112:   } else {
58112:     // Due to truncation here the average will normally be a little less than
58112:     // it should be but that's probably ok
58112:     mAvgTimeBetweenSamples =
58112:       (nsSMILTime)(elapsedTime * SAMPLE_DUR_WEIGHTING +
58112:       mAvgTimeBetweenSamples * (1.0 - SAMPLE_DUR_WEIGHTING));
58112:   }
58112:   mCurrentSampleTime = aTime;
58112: 
39626:   Sample();
39626: }
39626: 
39626: //----------------------------------------------------------------------
23697: // Animation element registration methods:
23697: 
23697: void
23697: nsSMILAnimationController::RegisterAnimationElement(
23697:                                   nsISMILAnimationElement* aAnimationElement)
23697: {
23697:   mAnimationElementTable.PutEntry(aAnimationElement);
39687:   if (mDeferredStartSampling) {
80486:     mDeferredStartSampling = false;
57024:     if (mChildContainerTable.Count()) {
57024:       // mAnimationElementTable was empty, but now we've added its 1st element
39687:       NS_ABORT_IF_FALSE(mAnimationElementTable.Count() == 1,
39687:                         "we shouldn't have deferred sampling if we already had "
39687:                         "animations registered");
69079:       StartSampling(GetRefreshDriver());
81423:       Sample(); // Run the first sample manually
57024:     } // else, don't sample until a time container is registered (via AddChild)
39687:   }
23697: }
23697: 
23697: void
23697: nsSMILAnimationController::UnregisterAnimationElement(
23697:                                   nsISMILAnimationElement* aAnimationElement)
23697: {
23697:   mAnimationElementTable.RemoveEntry(aAnimationElement);
23697: }
23697: 
23697: //----------------------------------------------------------------------
23697: // Page show/hide
23697: 
23697: void
23697: nsSMILAnimationController::OnPageShow()
23697: {
23697:   Resume(nsSMILTimeContainer::PAUSE_PAGEHIDE);
23697: }
23697: 
23697: void
23697: nsSMILAnimationController::OnPageHide()
23697: {
23697:   Pause(nsSMILTimeContainer::PAUSE_PAGEHIDE);
23697: }
23697: 
23697: //----------------------------------------------------------------------
23697: // Cycle-collection support
23697: 
23697: void
23697: nsSMILAnimationController::Traverse(
23697:     nsCycleCollectionTraversalCallback* aCallback)
23697: {
23697:   // Traverse last compositor table
23697:   if (mLastCompositorTable) {
23697:     mLastCompositorTable->EnumerateEntries(CompositorTableEntryTraverse,
23697:                                            aCallback);
23697:   }
23697: }
23697: 
23697: /*static*/ PR_CALLBACK PLDHashOperator
23697: nsSMILAnimationController::CompositorTableEntryTraverse(
23697:                                       nsSMILCompositor* aCompositor,
23697:                                       void* aArg)
23697: {
23697:   nsCycleCollectionTraversalCallback* cb =
23697:     static_cast<nsCycleCollectionTraversalCallback*>(aArg);
23697:   aCompositor->Traverse(cb);
23697:   return PL_DHASH_NEXT;
23697: }
23697: 
23697: void
23697: nsSMILAnimationController::Unlink()
23697: {
23697:   mLastCompositorTable = nsnull;
23697: }
23697: 
23697: //----------------------------------------------------------------------
56137: // Refresh driver lifecycle related methods
56137: 
56137: void
56137: nsSMILAnimationController::NotifyRefreshDriverCreated(
56137:     nsRefreshDriver* aRefreshDriver)
56137: {
64632:   if (!mPauseState) {
64632:     MaybeStartSampling(aRefreshDriver);
56137:   }
56137: }
56137: 
56137: void
56137: nsSMILAnimationController::NotifyRefreshDriverDestroying(
56137:     nsRefreshDriver* aRefreshDriver)
56137: {
56137:   if (!mPauseState && !mDeferredStartSampling) {
56137:     StopSampling(aRefreshDriver);
56137:   }
56137: }
56137: 
56137: //----------------------------------------------------------------------
23697: // Timer-related implementation helpers
23697: 
39694: void
39694: nsSMILAnimationController::StartSampling(nsRefreshDriver* aRefreshDriver)
39234: {
39694:   NS_ASSERTION(mPauseState == 0, "Starting sampling but controller is paused");
56136:   NS_ASSERTION(!mDeferredStartSampling,
56136:                "Started sampling but the deferred start flag is still set");
39694:   if (aRefreshDriver) {
69079:     NS_ABORT_IF_FALSE(!GetRefreshDriver() ||
69079:                       aRefreshDriver == GetRefreshDriver(),
39694:                       "Starting sampling with wrong refresh driver");
58112:     // We're effectively resuming from a pause so update our current sample time
58112:     // or else it will confuse our "average time between samples" calculations.
58112:     mCurrentSampleTime = mozilla::TimeStamp::Now();
39694:     aRefreshDriver->AddRefreshObserver(this, Flush_Style);
39694:   }
39234: }
39234: 
39694: void
39626: nsSMILAnimationController::StopSampling(nsRefreshDriver* aRefreshDriver)
39580: {
39694:   if (aRefreshDriver) {
39694:     // NOTE: The document might already have been detached from its PresContext
39694:     // (and RefreshDriver), which would make GetRefreshDriverForDoc return null.
69079:     NS_ABORT_IF_FALSE(!GetRefreshDriver() ||
69079:                       aRefreshDriver == GetRefreshDriver(),
39694:                       "Stopping sampling with wrong refresh driver");
39694:     aRefreshDriver->RemoveRefreshObserver(this, Flush_Style);
39694:   }
23697: }
23697: 
64632: void
64632: nsSMILAnimationController::MaybeStartSampling(nsRefreshDriver* aRefreshDriver)
64632: {
64632:   if (mDeferredStartSampling) {
64632:     // We've received earlier 'MaybeStartSampling' calls, and we're
64632:     // deferring until we get a registered animation.
64632:     return;
64632:   }
64632: 
64632:   if (mAnimationElementTable.Count()) {
64632:     StartSampling(aRefreshDriver);
64632:   } else {
80486:     mDeferredStartSampling = true;
64632:   }
64632: }
64632: 
23697: //----------------------------------------------------------------------
23697: // Sample-related methods and callbacks
23697: 
30313: PR_CALLBACK PLDHashOperator
38351: TransferCachedBaseValue(nsSMILCompositor* aCompositor,
38351:                         void* aData)
38351: {
38351:   nsSMILCompositorTable* lastCompositorTable =
38351:     static_cast<nsSMILCompositorTable*>(aData);
38351:   nsSMILCompositor* lastCompositor =
38351:     lastCompositorTable->GetEntry(aCompositor->GetKey());
38351: 
38351:   if (lastCompositor) {
38351:     aCompositor->StealCachedBaseValue(lastCompositor);
38351:   }
38351: 
38351:   return PL_DHASH_NEXT;  
38351: }
38351: 
38351: PR_CALLBACK PLDHashOperator
30313: RemoveCompositorFromTable(nsSMILCompositor* aCompositor,
30313:                           void* aData)
30313: {
30313:   nsSMILCompositorTable* lastCompositorTable =
30313:     static_cast<nsSMILCompositorTable*>(aData);
30313:   lastCompositorTable->RemoveEntry(aCompositor->GetKey());
30313:   return PL_DHASH_NEXT;
30313: }
30313: 
30313: PR_CALLBACK PLDHashOperator
30313: DoClearAnimationEffects(nsSMILCompositor* aCompositor,
30313:                         void* /*aData*/)
30313: {
30313:   aCompositor->ClearAnimationEffects();
30313:   return PL_DHASH_NEXT;
30313: }
30313: 
30313: PR_CALLBACK PLDHashOperator
30313: DoComposeAttribute(nsSMILCompositor* aCompositor,
30313:                    void* /*aData*/)
30313: {
30313:   aCompositor->ComposeAttribute();
30313:   return PL_DHASH_NEXT;
30313: }
30313: 
23697: void
23697: nsSMILAnimationController::DoSample()
23697: {
80486:   DoSample(true); // Skip unchanged time containers
24029: }
24029: 
24029: void
79445: nsSMILAnimationController::DoSample(bool aSkipUnchangedContainers)
24029: {
69078:   if (!mDocument) {
69078:     NS_ERROR("Shouldn't be sampling after document has disconnected");
69078:     return;
69078:   }
69078: 
80486:   mResampleNeeded = false;
57170:   // Set running sample flag -- do this before flushing styles so that when we
57170:   // flush styles we don't end up requesting extra samples
80486:   mRunningSample = true;
92400:   nsCOMPtr<nsIDocument> kungFuDeathGrip(mDocument);  // keeps 'this' alive too
52455:   mDocument->FlushPendingNotifications(Flush_Style);
24029: 
92400:   // WARNING: 
92400:   // WARNING: the above flush may have destroyed the pres shell and/or
92400:   // WARNING: frames and other layout related objects.
92400:   // WARNING:
92400:   
37113:   // STEP 1: Bring model up to date
47197:   // (i)  Rewind elements where necessary
47197:   // (ii) Run milestone samples
47197:   RewindElements();
37113:   DoMilestoneSamples();
37113: 
37113:   // STEP 2: Sample the child time containers
23697:   //
23697:   // When we sample the child time containers they will simply record the sample
23697:   // time in document time.
23697:   TimeContainerHashtable activeContainers;
23697:   activeContainers.Init(mChildContainerTable.Count());
24029:   SampleTimeContainerParams tcParams = { &activeContainers,
24029:                                          aSkipUnchangedContainers };
24029:   mChildContainerTable.EnumerateEntries(SampleTimeContainer, &tcParams);
23697: 
37113:   // STEP 3: (i)  Sample the timed elements AND
23697:   //         (ii) Create a table of compositors
23697:   //
23697:   // (i) Here we sample the timed elements (fetched from the
23697:   // nsISMILAnimationElements) which determine from the active time if the
24112:   // element is active and what its simple time etc. is. This information is
23697:   // then passed to its time client (nsSMILAnimationFunction).
23697:   //
23697:   // (ii) During the same loop we also build up a table that contains one
23697:   // compositor for each animated attribute and which maps animated elements to
23697:   // the corresponding compositor for their target attribute.
23697:   //
23697:   // Note that this compositor table needs to be allocated on the heap so we can
23697:   // store it until the next sample. This lets us find out which elements were
23697:   // animated in sample 'n-1' but not in sample 'n' (and hence need to have
23697:   // their animation effects removed in sample 'n').
23697:   //
23697:   // Parts (i) and (ii) are not functionally related but we combine them here to
23697:   // save iterating over the animation elements twice.
23697: 
23697:   // Create the compositor table
23697:   nsAutoPtr<nsSMILCompositorTable>
23697:     currentCompositorTable(new nsSMILCompositorTable());
23697:   currentCompositorTable->Init(0);
23697: 
24029:   SampleAnimationParams saParams = { &activeContainers,
24029:                                      currentCompositorTable };
38076:   mAnimationElementTable.EnumerateEntries(SampleAnimation,
24029:                                           &saParams);
23697:   activeContainers.Clear();
23697: 
38351:   // STEP 4: Compare previous sample's compositors against this sample's.
38351:   // (Transfer cached base values across, & remove animation effects from 
38351:   // no-longer-animated targets.)
23697:   if (mLastCompositorTable) {
38351:     // * Transfer over cached base values, from last sample's compositors
38351:     currentCompositorTable->EnumerateEntries(TransferCachedBaseValue,
38351:                                              mLastCompositorTable);
38351: 
30313:     // * For each compositor in current sample's hash table, remove entry from
30313:     // prev sample's hash table -- we don't need to clear animation
30313:     // effects of those compositors, since they're still being animated.
30313:     currentCompositorTable->EnumerateEntries(RemoveCompositorFromTable,
30313:                                              mLastCompositorTable);
30313: 
30313:     // * For each entry that remains in prev sample's hash table (i.e. for
30313:     // every target that's no longer animated), clear animation effects.
30313:     mLastCompositorTable->EnumerateEntries(DoClearAnimationEffects, nsnull);
23697:   }
23697: 
37113:   // STEP 5: Compose currently-animated attributes.
33401:   // XXXdholbert: This step traverses our animation targets in an effectively
33401:   // random order. For animation from/to 'inherit' values to work correctly
33401:   // when the inherited value is *also* being animated, we really should be
33401:   // traversing our animated nodes in an ancestors-first order (bug 501183)
30313:   currentCompositorTable->EnumerateEntries(DoComposeAttribute, nsnull);
80486:   mRunningSample = false;
23697: 
23697:   // Update last compositor table
23697:   mLastCompositorTable = currentCompositorTable.forget();
24029: 
24029:   NS_ASSERTION(!mResampleNeeded, "Resample dirty flag set during sample!");
23697: }
23697: 
37113: void
47197: nsSMILAnimationController::RewindElements()
47197: {
79445:   bool rewindNeeded = false;
47197:   mChildContainerTable.EnumerateEntries(RewindNeeded, &rewindNeeded);
47197:   if (!rewindNeeded)
47197:     return;
47197: 
47197:   mAnimationElementTable.EnumerateEntries(RewindAnimation, nsnull);
47197:   mChildContainerTable.EnumerateEntries(ClearRewindNeeded, nsnull);
47197: }
47197: 
47197: /*static*/ PR_CALLBACK PLDHashOperator
47197: nsSMILAnimationController::RewindNeeded(TimeContainerPtrKey* aKey,
47197:                                         void* aData)
47197: {
47197:   NS_ABORT_IF_FALSE(aData,
47197:       "Null data pointer during time container enumeration");
79445:   bool* rewindNeeded = static_cast<bool*>(aData);
47197: 
47197:   nsSMILTimeContainer* container = aKey->GetKey();
47197:   if (container->NeedsRewind()) {
80486:     *rewindNeeded = true;
47197:     return PL_DHASH_STOP;
47197:   }
47197: 
47197:   return PL_DHASH_NEXT;
47197: }
47197: 
47197: /*static*/ PR_CALLBACK PLDHashOperator
47197: nsSMILAnimationController::RewindAnimation(AnimationElementPtrKey* aKey,
47197:                                            void* aData)
47197: {
47197:   nsISMILAnimationElement* animElem = aKey->GetKey();
47197:   nsSMILTimeContainer* timeContainer = animElem->GetTimeContainer();
47197:   if (timeContainer && timeContainer->NeedsRewind()) {
47197:     animElem->TimedElement().Rewind();
47197:   }
47197: 
47197:   return PL_DHASH_NEXT;
47197: }
47197: 
47197: /*static*/ PR_CALLBACK PLDHashOperator
47197: nsSMILAnimationController::ClearRewindNeeded(TimeContainerPtrKey* aKey,
47197:                                              void* aData)
47197: {
47197:   aKey->GetKey()->ClearNeedsRewind();
47197:   return PL_DHASH_NEXT;
47197: }
47197: 
47197: void
37113: nsSMILAnimationController::DoMilestoneSamples()
37113: {
37113:   // We need to sample the timing model but because SMIL operates independently
37113:   // of the frame-rate, we can get one sample at t=0s and the next at t=10min.
37113:   //
37113:   // In between those two sample times a whole string of significant events
37113:   // might be expected to take place: events firing, new interdependencies
37113:   // between animations resolved and dissolved, etc.
37113:   //
37113:   // Furthermore, at any given time, we want to sample all the intervals that
37113:   // end at that time BEFORE any that begin. This behaviour is implied by SMIL's
37113:   // endpoint-exclusive timing model.
37113:   //
37113:   // So we have the animations (specifically the timed elements) register the
37113:   // next significant moment (called a milestone) in their lifetime and then we
37113:   // step through the model at each of these moments and sample those animations
37113:   // registered for those times. This way events can fire in the correct order,
37113:   // dependencies can be resolved etc.
37113: 
37113:   nsSMILTime sampleTime = LL_MININT;
37113: 
80486:   while (true) {
37113:     // We want to find any milestones AT OR BEFORE the current sample time so we
37113:     // initialise the next milestone to the moment after (1ms after, to be
37113:     // precise) the current sample time and see if there are any milestones
37113:     // before that. Any other milestones will be dealt with in a subsequent
37113:     // sample.
80486:     nsSMILMilestone nextMilestone(GetCurrentTime() + 1, true);
37113:     mChildContainerTable.EnumerateEntries(GetNextMilestone, &nextMilestone);
37113: 
37113:     if (nextMilestone.mTime > GetCurrentTime()) {
37113:       break;
37113:     }
37113: 
37113:     GetMilestoneElementsParams params;
37113:     params.mMilestone = nextMilestone;
37113:     mChildContainerTable.EnumerateEntries(GetMilestoneElements, &params);
37113:     PRUint32 length = params.mElements.Length();
37113: 
37113:     // During the course of a sampling we don't want to actually go backwards.
37113:     // Due to negative offsets, early ends and the like, a timed element might
37113:     // register a milestone that is actually in the past. That's fine, but it's
37113:     // still only going to get *sampled* with whatever time we're up to and no
37113:     // earlier.
37113:     //
37113:     // Because we're only performing this clamping at the last moment, the
37113:     // animations will still all get sampled in the correct order and
37113:     // dependencies will be appropriately resolved.
71173:     sampleTime = NS_MAX(nextMilestone.mTime, sampleTime);
37113: 
37113:     for (PRUint32 i = 0; i < length; ++i) {
37113:       nsISMILAnimationElement* elem = params.mElements[i].get();
37113:       NS_ABORT_IF_FALSE(elem, "NULL animation element in list");
37113:       nsSMILTimeContainer* container = elem->GetTimeContainer();
37113:       if (!container)
37113:         // The container may be nsnull if the element has been detached from its
37113:         // parent since registering a milestone.
37113:         continue;
37113: 
37113:       nsSMILTimeValue containerTimeValue =
37113:         container->ParentToContainerTime(sampleTime);
77938:       if (!containerTimeValue.IsDefinite())
37113:         continue;
37113: 
37113:       // Clamp the converted container time to non-negative values.
71173:       nsSMILTime containerTime = NS_MAX<nsSMILTime>(0, containerTimeValue.GetMillis());
37113: 
37113:       if (nextMilestone.mIsEnd) {
37113:         elem->TimedElement().SampleEndAt(containerTime);
37113:       } else {
37113:         elem->TimedElement().SampleAt(containerTime);
37113:       }
37113:     }
37113:   }
37113: }
37113: 
37113: /*static*/ PR_CALLBACK PLDHashOperator
37113: nsSMILAnimationController::GetNextMilestone(TimeContainerPtrKey* aKey,
37113:                                             void* aData)
37113: {
37113:   NS_ABORT_IF_FALSE(aKey, "Null hash key for time container hash table");
37113:   NS_ABORT_IF_FALSE(aKey->GetKey(), "Null time container key in hash table");
37113:   NS_ABORT_IF_FALSE(aData,
37113:       "Null data pointer during time container enumeration");
37113: 
37113:   nsSMILMilestone* nextMilestone = static_cast<nsSMILMilestone*>(aData);
37113: 
37113:   nsSMILTimeContainer* container = aKey->GetKey();
37113:   if (container->IsPausedByType(nsSMILTimeContainer::PAUSE_BEGIN))
37113:     return PL_DHASH_NEXT;
37113: 
37113:   nsSMILMilestone thisMilestone;
79445:   bool didGetMilestone =
37113:     container->GetNextMilestoneInParentTime(thisMilestone);
37113:   if (didGetMilestone && thisMilestone < *nextMilestone) {
37113:     *nextMilestone = thisMilestone;
37113:   }
37113: 
37113:   return PL_DHASH_NEXT;
37113: }
37113: 
37113: /*static*/ PR_CALLBACK PLDHashOperator
37113: nsSMILAnimationController::GetMilestoneElements(TimeContainerPtrKey* aKey,
37113:                                                 void* aData)
37113: {
37113:   NS_ABORT_IF_FALSE(aKey, "Null hash key for time container hash table");
37113:   NS_ABORT_IF_FALSE(aKey->GetKey(), "Null time container key in hash table");
37113:   NS_ABORT_IF_FALSE(aData,
37113:       "Null data pointer during time container enumeration");
37113: 
37113:   GetMilestoneElementsParams* params =
37113:     static_cast<GetMilestoneElementsParams*>(aData);
37113: 
37113:   nsSMILTimeContainer* container = aKey->GetKey();
37113:   if (container->IsPausedByType(nsSMILTimeContainer::PAUSE_BEGIN))
37113:     return PL_DHASH_NEXT;
37113: 
37113:   container->PopMilestoneElementsAtMilestone(params->mMilestone,
37113:                                              params->mElements);
37113: 
37113:   return PL_DHASH_NEXT;
37113: }
37113: 
23697: /*static*/ PR_CALLBACK PLDHashOperator
24029: nsSMILAnimationController::SampleTimeContainer(TimeContainerPtrKey* aKey,
23697:                                                void* aData)
23697: {
23697:   NS_ENSURE_TRUE(aKey, PL_DHASH_NEXT);
23697:   NS_ENSURE_TRUE(aKey->GetKey(), PL_DHASH_NEXT);
23697:   NS_ENSURE_TRUE(aData, PL_DHASH_NEXT);
23697: 
24029:   SampleTimeContainerParams* params =
24029:     static_cast<SampleTimeContainerParams*>(aData);
23697: 
23697:   nsSMILTimeContainer* container = aKey->GetKey();
37113:   if (!container->IsPausedByType(nsSMILTimeContainer::PAUSE_BEGIN) &&
37113:       (container->NeedsSample() || !params->mSkipUnchangedContainers)) {
37113:     container->ClearMilestones();
23697:     container->Sample();
47197:     container->MarkSeekFinished();
24029:     params->mActiveContainers->PutEntry(container);
23697:   }
23697: 
23697:   return PL_DHASH_NEXT;
23697: }
23697: 
23697: /*static*/ PR_CALLBACK PLDHashOperator
23697: nsSMILAnimationController::SampleAnimation(AnimationElementPtrKey* aKey,
23697:                                            void* aData)
23697: {
23697:   NS_ENSURE_TRUE(aKey, PL_DHASH_NEXT);
23697:   NS_ENSURE_TRUE(aKey->GetKey(), PL_DHASH_NEXT);
23697:   NS_ENSURE_TRUE(aData, PL_DHASH_NEXT);
23697: 
23697:   nsISMILAnimationElement* animElem = aKey->GetKey();
89495:   if (animElem->PassesConditionalProcessingTests()) {
23697:     SampleAnimationParams* params = static_cast<SampleAnimationParams*>(aData);
23697: 
23697:     SampleTimedElement(animElem, params->mActiveContainers);
23697:     AddAnimationToCompositorTable(animElem, params->mCompositorTable);
89495:   }
23697: 
23697:   return PL_DHASH_NEXT;
23697: }
23697: 
23697: /*static*/ void
23697: nsSMILAnimationController::SampleTimedElement(
23697:   nsISMILAnimationElement* aElement, TimeContainerHashtable* aActiveContainers)
23697: {
23697:   nsSMILTimeContainer* timeContainer = aElement->GetTimeContainer();
23697:   if (!timeContainer)
23697:     return;
23697: 
23697:   // We'd like to call timeContainer->NeedsSample() here and skip all timed
23697:   // elements that belong to paused time containers that don't need a sample,
23697:   // but that doesn't work because we've already called Sample() on all the time
23697:   // containers so the paused ones don't need a sample any more and they'll
23697:   // return false.
23697:   //
23697:   // Instead we build up a hashmap of active time containers during the previous
24029:   // step (SampleTimeContainer) and then test here if the container for this
23697:   // timed element is in the list.
23697:   if (!aActiveContainers->GetEntry(timeContainer))
23697:     return;
23697: 
23697:   nsSMILTime containerTime = timeContainer->GetCurrentTime();
23697: 
47197:   NS_ABORT_IF_FALSE(!timeContainer->IsSeeking(),
47197:       "Doing a regular sample but the time container is still seeking");
23697:   aElement->TimedElement().SampleAt(containerTime);
23697: }
23697: 
23697: /*static*/ void
23697: nsSMILAnimationController::AddAnimationToCompositorTable(
23697:   nsISMILAnimationElement* aElement, nsSMILCompositorTable* aCompositorTable)
23697: {
23697:   // Add a compositor to the hash table if there's not already one there
38346:   nsSMILTargetIdentifier key;
38346:   if (!GetTargetIdentifierForAnimation(aElement, key))
23697:     // Something's wrong/missing about animation's target; skip this animation
23697:     return;
23697: 
31953:   nsSMILAnimationFunction& func = aElement->AnimationFunction();
31953: 
31953:   // Only add active animation functions. If there are no active animations
38348:   // targeting an attribute, no compositor will be created and any previously
31953:   // applied animations will be cleared.
31953:   if (func.IsActiveOrFrozen()) {
38348:     // Look up the compositor for our target, & add our animation function
38348:     // to its list of animation functions.
23697:     nsSMILCompositor* result = aCompositorTable->PutEntry(key);
38348:     result->AddAnimationFunction(&func);
23697: 
38348:   } else if (func.HasChanged()) {
38348:     // Look up the compositor for our target, and force it to skip the
38348:     // "nothing's changed so don't bother compositing" optimization for this
38348:     // sample. |func| is inactive, but it's probably *newly* inactive (since
80486:     // it's got HasChanged() == true), so we need to make sure to recompose
38348:     // its target.
38348:     nsSMILCompositor* result = aCompositorTable->PutEntry(key);
38348:     result->ToggleForceCompositing();
38348: 
38348:     // We've now made sure that |func|'s inactivity will be reflected as of
38348:     // this sample. We need to clear its HasChanged() flag so that it won't
38348:     // trigger this same clause in future samples (until it changes again).
38348:     func.ClearHasChanged();
31953:   }
23697: }
23697: 
23697: // Helper function that, given a nsISMILAnimationElement, looks up its target
38346: // element & target attribute and populates a nsSMILTargetIdentifier
23697: // for this target.
79445: /*static*/ bool
38346: nsSMILAnimationController::GetTargetIdentifierForAnimation(
38346:     nsISMILAnimationElement* aAnimElem, nsSMILTargetIdentifier& aResult)
23697: {
23697:   // Look up target (animated) element
42326:   Element* targetElem = aAnimElem->GetTargetElementContent();
23697:   if (!targetElem)
23697:     // Animation has no target elem -- skip it.
80486:     return false;
23697: 
23697:   // Look up target (animated) attribute
55139:   // SMILANIM section 3.1, attributeName may
55139:   // have an XMLNS prefix to indicate the XML namespace.
55139:   nsCOMPtr<nsIAtom> attributeName;
55139:   PRInt32 attributeNamespaceID;
55139:   if (!aAnimElem->GetTargetAttributeName(&attributeNamespaceID,
55139:                                          getter_AddRefs(attributeName)))
23697:     // Animation has no target attr -- skip it.
80486:     return false;
23697: 
23697:   // Look up target (animated) attribute-type
23697:   nsSMILTargetAttrType attributeType = aAnimElem->GetTargetAttributeType();
23697: 
23697:   // Check if an 'auto' attributeType refers to a CSS property or XML attribute.
23697:   // Note that SMIL requires we search for CSS properties first. So if they
23697:   // overlap, 'auto' = 'CSS'. (SMILANIM 3.1)
79445:   bool isCSS = false;
23697:   if (attributeType == eSMILTargetAttrType_auto) {
55139:     if (attributeNamespaceID == kNameSpaceID_None) {
39101:       nsCSSProperty prop =
39101:         nsCSSProps::LookupProperty(nsDependentAtomString(attributeName));
33401:       isCSS = nsSMILCSSProperty::IsPropertyAnimatable(prop);
55139:     }
33401:   } else {
33401:     isCSS = (attributeType == eSMILTargetAttrType_CSS);
23697:   }
23697: 
23697:   // Construct the key
23697:   aResult.mElement = targetElem;
23697:   aResult.mAttributeName = attributeName;
55139:   aResult.mAttributeNamespaceID = attributeNamespaceID;
23697:   aResult.mIsCSS = isCSS;
23697: 
80486:   return true;
23697: }
23697: 
23697: //----------------------------------------------------------------------
23697: // Add/remove child time containers
23697: 
23697: nsresult
23697: nsSMILAnimationController::AddChild(nsSMILTimeContainer& aChild)
23697: {
23697:   TimeContainerPtrKey* key = mChildContainerTable.PutEntry(&aChild);
23697:   NS_ENSURE_TRUE(key, NS_ERROR_OUT_OF_MEMORY);
23697: 
23697:   if (!mPauseState && mChildContainerTable.Count() == 1) {
81423:     MaybeStartSampling(GetRefreshDriver());
39626:     Sample(); // Run the first sample manually
23697:   }
23697: 
23697:   return NS_OK;
23697: }
23697: 
23697: void
23697: nsSMILAnimationController::RemoveChild(nsSMILTimeContainer& aChild)
23697: {
23697:   mChildContainerTable.RemoveEntry(&aChild);
23697: 
23697:   if (!mPauseState && mChildContainerTable.Count() == 0) {
69079:     StopSampling(GetRefreshDriver());
23697:   }
23697: }
69079: 
69079: // Helper method
69079: nsRefreshDriver*
69079: nsSMILAnimationController::GetRefreshDriver()
69079: {
69079:   if (!mDocument) {
69079:     NS_ERROR("Requesting refresh driver after document has disconnected!");
69079:     return nsnull;
69079:   }
69079: 
69079:   nsIPresShell* shell = mDocument->GetShell();
69079:   if (!shell) {
69079:     return nsnull;
69079:   }
69079: 
69079:   nsPresContext* context = shell->GetPresContext();
69079:   return context ? context->RefreshDriver() : nsnull;
69079: }
84597: 
84597: void
84597: nsSMILAnimationController::FlagDocumentNeedsFlush()
84597: {
84597:   mDocument->SetNeedStyleFlush();
84597: }
