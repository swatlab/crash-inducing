 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 43532:  * vim: set ts=8 sw=4 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS debugging API.
     1:  */
     1: #include <string.h>
 76358: #include <stdarg.h>
 62057: #include "jsprvtd.h"
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
     1: #include "jsclist.h"
     1: #include "jsapi.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsdbgapi.h"
     1: #include "jsfun.h"
     1: #include "jsgc.h"
     1: #include "jsinterp.h"
     1: #include "jslock.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: #include "jsstr.h"
 74472: #include "jswatchpoint.h"
 56704: #include "jswrapper.h"
 80202: 
 97569: #include "gc/Marking.h"
 80964: #include "frontend/BytecodeEmitter.h"
 80506: #include "frontend/Parser.h"
 76244: #include "vm/Debugger.h"
     1: 
 30283: #include "jsatominlines.h"
 77343: #include "jsinferinlines.h"
 69223: #include "jsobjinlines.h"
 53840: #include "jsinterpinlines.h"
 35453: #include "jsscopeinlines.h"
 59968: #include "jsscriptinlines.h"
 30283: 
 69223: #include "vm/Stack-inl.h"
 69223: 
 15453: #include "jsautooplen.h"
 96797: #include "mozilla/Util.h"
 15453: 
 76358: #ifdef __APPLE__
 76358: #include "sharkctl.h"
 76358: #endif
 76358: 
 37741: using namespace js;
 54707: using namespace js::gc;
 96797: using namespace mozilla;
 37741: 
 53391: JS_PUBLIC_API(JSBool)
 53391: JS_GetDebugMode(JSContext *cx)
 53391: {
 75489:     return cx->compartment->debugMode();
 53391: }
 53391: 
 62057: JS_PUBLIC_API(JSBool)
 62057: JS_SetDebugMode(JSContext *cx, JSBool debug)
 53391: {
 62057:     return JS_SetDebugModeForCompartment(cx, cx->compartment, debug);
 53391: }
 53391: 
 56783: JS_PUBLIC_API(void)
 56783: JS_SetRuntimeDebugMode(JSRuntime *rt, JSBool debug)
 56783: {
 75489:     rt->debugMode = !!debug;
 56783: }
 56783: 
 64363: namespace js {
 64363: 
 84070: JSTrapStatus
 69223: ScriptDebugPrologue(JSContext *cx, StackFrame *fp)
 64363: {
 75523:     JS_ASSERT(fp == cx->fp());
 75523: 
 64363:     if (fp->isFramePushedByExecute()) {
 91178:         if (JSInterpreterHook hook = cx->runtime->debugHooks.executeHook)
 91178:             fp->setHookData(hook(cx, Jsvalify(fp), true, 0, cx->runtime->debugHooks.executeHookData));
 64363:     } else {
 91178:         if (JSInterpreterHook hook = cx->runtime->debugHooks.callHook)
 91178:             fp->setHookData(hook(cx, Jsvalify(fp), true, 0, cx->runtime->debugHooks.callHookData));
 64363:     }
 84070: 
 84070:     Value rval;
 84070:     JSTrapStatus status = Debugger::onEnterFrame(cx, &rval);
 84070:     switch (status) {
 84070:       case JSTRAP_CONTINUE:
 84070:         break;
 84070:       case JSTRAP_THROW:
 84070:         cx->setPendingException(rval);
 84070:         break;
 84070:       case JSTRAP_ERROR:
 84070:         cx->clearPendingException();
 84070:         break;
 84070:       case JSTRAP_RETURN:
 84070:         fp->setReturnValue(rval);
 84070:         break;
 84070:       default:
 84070:         JS_NOT_REACHED("bad Debugger::onEnterFrame JSTrapStatus value");
 84070:     }
 84070:     return status;
 64363: }
 64363: 
 64363: bool
 69223: ScriptDebugEpilogue(JSContext *cx, StackFrame *fp, bool okArg)
 64363: {
 75413:     JS_ASSERT(fp == cx->fp());
 64363:     JSBool ok = okArg;
 64363: 
 64363:     if (void *hookData = fp->maybeHookData()) {
 64363:         if (fp->isFramePushedByExecute()) {
 91178:             if (JSInterpreterHook hook = cx->runtime->debugHooks.executeHook)
 69223:                 hook(cx, Jsvalify(fp), false, &ok, hookData);
 64363:         } else {
 91178:             if (JSInterpreterHook hook = cx->runtime->debugHooks.callHook)
 69223:                 hook(cx, Jsvalify(fp), false, &ok, hookData);
 64363:         }
 64363:     }
 64363: 
 91435:     return Debugger::onLeaveFrame(cx, ok);
 64363: }
 64363: 
 64363: } /* namespace js */
 64363: 
 62779: JS_FRIEND_API(JSBool)
 98493: JS_SetDebugModeForAllCompartments(JSContext *cx, JSBool debug)
 98493: {
 98493:     AutoDebugModeGC dmgc(cx->runtime);
 98493: 
 98493:     for (CompartmentsIter c(cx->runtime); !c.done(); c.next()) {
 98493:         // Ignore special compartments (atoms, JSD compartments)
 98493:         if (c->principals) {
 98493:             if (!c->setDebugModeFromC(cx, !!debug, dmgc))
 98493:                 return false;
 98493:         }
 98493:     }
 98493:     return true;
 98493: }
 98493: 
 98493: JS_FRIEND_API(JSBool)
 62779: JS_SetDebugModeForCompartment(JSContext *cx, JSCompartment *comp, JSBool debug)
 62779: {
 98493:     AutoDebugModeGC dmgc(cx->runtime);
 98493:     return comp->setDebugModeFromC(cx, !!debug, dmgc);
 53391: }
 53391: 
 53391: static JSBool
 53391: CheckDebugMode(JSContext *cx)
 53391: {
 53391:     JSBool debugMode = JS_GetDebugMode(cx);
 53391:     /*
 53391:      * :TODO:
 53391:      * This probably should be an assertion, since it's indicative of a severe
 53391:      * API misuse.
 53391:      */
 53391:     if (!debugMode) {
 53391:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage,
 53391:                                      NULL, JSMSG_NEED_DEBUG_MODE);
 53391:     }
 53391:     return debugMode;
 53391: }
 53391: 
 59882: JS_PUBLIC_API(JSBool)
 59882: JS_SetSingleStepMode(JSContext *cx, JSScript *script, JSBool singleStep)
 59882: {
 64192:     assertSameCompartment(cx, script);
 59882:     if (!CheckDebugMode(cx))
 59882:         return JS_FALSE;
 59882: 
 77169:     return script->setStepModeFlag(cx, singleStep);
 59882: }
 59882: 
     1: JS_PUBLIC_API(JSBool)
 75506: JS_SetTrap(JSContext *cx, JSScript *script, jsbytecode *pc, JSTrapHandler handler, jsval closure)
     1: {
 84195:     assertSameCompartment(cx, script, closure);
 84195: 
 75506:     if (!CheckDebugMode(cx))
 75506:         return false;
     1: 
 84195:     BreakpointSite *site = script->getOrCreateBreakpointSite(cx, pc, NULL);
 75506:     if (!site)
 75506:         return false;
 94740:     site->setTrap(cx->runtime->defaultFreeOp(), handler, closure);
 75506:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ClearTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
 41863:              JSTrapHandler *handlerp, jsval *closurep)
     1: {
 84195:     if (BreakpointSite *site = script->getBreakpointSite(pc)) {
 94740:         site->clearTrap(cx->runtime->defaultFreeOp(), handlerp, closurep);
 75506:     } else {
     1:         if (handlerp)
 75506:             *handlerp = NULL;
     1:         if (closurep)
 75506:             *closurep = JSVAL_VOID;
 53168:     }
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ClearScriptTraps(JSContext *cx, JSScript *script)
     1: {
 94740:     script->clearTraps(cx->runtime->defaultFreeOp());
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 75506: JS_ClearAllTrapsForCompartment(JSContext *cx)
     1: {
 94959:     cx->compartment->clearTraps(cx->runtime->defaultFreeOp());
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 41863: JS_SetInterrupt(JSRuntime *rt, JSInterruptHook hook, void *closure)
     1: {
 91178:     rt->debugHooks.interruptHook = hook;
 91178:     rt->debugHooks.interruptHookData = closure;
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 41863: JS_ClearInterrupt(JSRuntime *rt, JSInterruptHook *hoop, void **closurep)
     1: {
 41863:     if (hoop)
 91178:         *hoop = rt->debugHooks.interruptHook;
     1:     if (closurep)
 91178:         *closurep = rt->debugHooks.interruptHookData;
 91178:     rt->debugHooks.interruptHook = 0;
 91178:     rt->debugHooks.interruptHookData = 0;
     1:     return JS_TRUE;
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(JSBool)
 97353: JS_SetWatchPoint(JSContext *cx, JSObject *obj_, jsid id,
 97353:                  JSWatchPointHandler handler, JSObject *closure_)
     1: {
 97353:     assertSameCompartment(cx, obj_);
 64192: 
 99421:     RootedObject obj(cx, obj_), closure(cx, closure_);
 97353: 
 98960:     JSObject *origobj = obj;
 98960:     obj = GetInnerObject(cx, obj);
 98960:     if (!obj)
 98960:         return false;
 98960: 
 98953:     Value v;
 98953:     unsigned attrs;
 98953: 
 99421:     RootedId propid(cx);
 97353: 
 48470:     if (JSID_IS_INT(id)) {
 48470:         propid = id;
 80787:     } else if (JSID_IS_OBJECT(id)) {
 80787:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_WATCH_PROP);
 80787:         return false;
 24284:     } else {
 97828:         if (!ValueToId(cx, IdToValue(id), propid.address()))
 64199:             return false;
 24284:     }
     1: 
 35046:     /*
 35046:      * If, by unwrapping and innerizing, we changed the object, check
 35046:      * again to make sure that we're allowed to set a watch point.
 35046:      */
 47455:     if (origobj != obj && !CheckAccess(cx, obj, propid, JSACC_WATCH, &v, &attrs))
 64199:         return false;
 35046: 
 40430:     if (!obj->isNative()) {
 35046:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_WATCH,
 40826:                              obj->getClass()->name);
 64199:         return false;
 35046:     }
 35046: 
 77353:     types::MarkTypePropertyConfigured(cx, obj, propid);
 77343: 
 74472:     WatchpointMap *wpmap = cx->compartment->watchpointMap;
 74472:     if (!wpmap) {
 74472:         wpmap = cx->runtime->new_<WatchpointMap>();
 74472:         if (!wpmap || !wpmap->init()) {
 74472:             js_ReportOutOfMemory(cx);
 64199:             return false;
     1:         }
 74472:         cx->compartment->watchpointMap = wpmap;
 64199:     }
 80787:     return wpmap->watch(cx, obj, propid, handler, closure);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 48470: JS_ClearWatchPoint(JSContext *cx, JSObject *obj, jsid id,
 51134:                    JSWatchPointHandler *handlerp, JSObject **closurep)
     1: {
 74472:     assertSameCompartment(cx, obj, id);
 64192: 
 74472:     if (WatchpointMap *wpmap = cx->compartment->watchpointMap)
 74472:         wpmap->unwatch(obj, id, handlerp, closurep);
 74472:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ClearWatchPointsForObject(JSContext *cx, JSObject *obj)
     1: {
 64192:     assertSameCompartment(cx, obj);
 64192: 
 74472:     if (WatchpointMap *wpmap = cx->compartment->watchpointMap)
 74472:         wpmap->unwatchObject(obj);
 74472:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ClearAllWatchPoints(JSContext *cx)
     1: {
 74472:     if (JSCompartment *comp = cx->compartment) {
 74472:         if (WatchpointMap *wpmap = comp->watchpointMap)
 74472:             wpmap->clear();
     1:     }
 74472:     return true;
     1: }
     1: 
     1: /************************************************************************/
     1: 
 91237: JS_PUBLIC_API(unsigned)
     1: JS_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc)
     1: {
 91316:     return js::PCToLineNumber(script, pc);
     1: }
     1: 
     1: JS_PUBLIC_API(jsbytecode *)
 91237: JS_LineNumberToPC(JSContext *cx, JSScript *script, unsigned lineno)
     1: {
     1:     return js_LineNumberToPC(script, lineno);
     1: }
     1: 
 55561: JS_PUBLIC_API(jsbytecode *)
 55561: JS_EndPC(JSContext *cx, JSScript *script)
 55561: {
 55561:     return script->code + script->length;
 55561: }
 55561: 
 71318: JS_PUBLIC_API(JSBool)
 71318: JS_GetLinePCs(JSContext *cx, JSScript *script,
 91237:               unsigned startLine, unsigned maxLines,
 91237:               unsigned* count, unsigned** retLines, jsbytecode*** retPCs)
 71318: {
 91237:     unsigned* lines;
 71318:     jsbytecode** pcs;
 71318:     size_t len = (script->length > maxLines ? maxLines : script->length);
 91237:     lines = (unsigned*) cx->malloc_(len * sizeof(unsigned));
 71318:     if (!lines)
 71318:         return JS_FALSE;
 71318: 
 71318:     pcs = (jsbytecode**) cx->malloc_(len * sizeof(jsbytecode*));
 71318:     if (!pcs) {
 71318:         cx->free_(lines);
 71318:         return JS_FALSE;
 71318:     }
 71318: 
 91237:     unsigned lineno = script->lineno;
 91237:     unsigned offset = 0;
 91237:     unsigned i = 0;
 71318:     for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
 71318:         offset += SN_DELTA(sn);
 80631:         SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
 71318:         if (type == SRC_SETLINE || type == SRC_NEWLINE) {
 71318:             if (type == SRC_SETLINE)
 91237:                 lineno = (unsigned) js_GetSrcNoteOffset(sn, 0);
 71318:             else
 71318:                 lineno++;
 71318: 
 71318:             if (lineno >= startLine) {
 71318:                 lines[i] = lineno;
 71318:                 pcs[i] = script->code + offset;
 71318:                 if (++i >= maxLines)
 71318:                     break;
 71318:             }
 71318:         }
 71318:     }
 71318: 
 71318:     *count = i;
 71318:     if (retLines)
 71318:         *retLines = lines;
 71318:     else
 71318:         cx->free_(lines);
 71318: 
 71318:     if (retPCs)
 71318:         *retPCs = pcs;
 71318:     else
 71318:         cx->free_(pcs);
 71318: 
 71318:     return JS_TRUE;
 71318: }
 71318: 
 91237: JS_PUBLIC_API(unsigned)
 48470: JS_GetFunctionArgumentCount(JSContext *cx, JSFunction *fun)
 48470: {
 48470:     return fun->nargs;
 48470: }
 48470: 
 48470: JS_PUBLIC_API(JSBool)
 48470: JS_FunctionHasLocalNames(JSContext *cx, JSFunction *fun)
 48470: {
 95100:     return fun->script()->bindings.count() > 0;
 48470: }
 48470: 
 86976: extern JS_PUBLIC_API(uintptr_t *)
 48470: JS_GetFunctionLocalNameArray(JSContext *cx, JSFunction *fun, void **markp)
 48470: {
 97297:     BindingNames localNames(cx);
 73058:     if (!fun->script()->bindings.getLocalNameArray(cx, &localNames))
 73058:         return NULL;
 73058: 
 73058:     /* Munge data into the API this method implements.  Avert your eyes! */
 79410:     *markp = cx->tempLifoAlloc().mark();
 73058: 
 86976:     uintptr_t *names = cx->tempLifoAlloc().newArray<uintptr_t>(localNames.length());
 73058:     if (!names) {
 73058:         js_ReportOutOfMemory(cx);
 73058:         return NULL;
 73058:     }
 73058: 
 97297:     for (size_t i = 0; i < localNames.length(); i++)
 97297:         names[i] = reinterpret_cast<uintptr_t>(localNames[i].maybeAtom);
 97297: 
 73058:     return names;
 48470: }
 48470: 
 48470: extern JS_PUBLIC_API(JSAtom *)
 86976: JS_LocalNameToAtom(uintptr_t w)
 48470: {
 97297:     return reinterpret_cast<JSAtom *>(w);
 48470: }
 48470: 
 48470: extern JS_PUBLIC_API(JSString *)
 48470: JS_AtomKey(JSAtom *atom)
 48470: {
 64345:     return atom;
 48470: }
 48470: 
 48470: extern JS_PUBLIC_API(void)
 48470: JS_ReleaseFunctionLocalNameArray(JSContext *cx, void *mark)
 48470: {
 79410:     cx->tempLifoAlloc().release(mark);
 48470: }
 48470: 
     1: JS_PUBLIC_API(JSScript *)
     1: JS_GetFunctionScript(JSContext *cx, JSFunction *fun)
     1: {
 76812:     return fun->maybeScript();
     1: }
     1: 
     1: JS_PUBLIC_API(JSNative)
     1: JS_GetFunctionNative(JSContext *cx, JSFunction *fun)
     1: {
 78614:     return fun->maybeNative();
  4127: }
  4127: 
     1: JS_PUBLIC_API(JSPrincipals *)
 93548: JS_GetScriptPrincipals(JSScript *script)
     1: {
     1:     return script->principals;
     1: }
     1: 
 84691: JS_PUBLIC_API(JSPrincipals *)
 93548: JS_GetScriptOriginPrincipals(JSScript *script)
 84691: {
 84691:     return script->originPrincipals;
 84691: }
 84691: 
     1: /************************************************************************/
     1: 
     1: /*
     1:  *  Stack Frame Iterator
     1:  */
     1: JS_PUBLIC_API(JSStackFrame *)
     1: JS_FrameIterator(JSContext *cx, JSStackFrame **iteratorp)
     1: {
 69223:     StackFrame *fp = Valueify(*iteratorp);
 77343:     *iteratorp = Jsvalify((fp == NULL) ? js_GetTopStackFrame(cx, FRAME_EXPAND_ALL) : fp->prev());
     1:     return *iteratorp;
     1: }
     1: 
     1: JS_PUBLIC_API(JSScript *)
     1: JS_GetFrameScript(JSContext *cx, JSStackFrame *fp)
     1: {
 69223:     return Valueify(fp)->maybeScript();
     1: }
     1: 
     1: JS_PUBLIC_API(jsbytecode *)
     1: JS_GetFramePC(JSContext *cx, JSStackFrame *fp)
     1: {
 77343:     return Valueify(fp)->pcQuadratic(cx->stack);
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
 69223: JS_GetFrameAnnotation(JSContext *cx, JSStackFrame *fpArg)
     1: {
 69223:     StackFrame *fp = Valueify(fpArg);
 53840:     if (fp->annotation() && fp->isScriptFrame()) {
 96793:         JSPrincipals *principals = fp->scopeChain()->principals(cx);
     1: 
 86807:         if (principals) {
     1:             /*
     1:              * Give out an annotation only if privileges have not been revoked
     1:              * or disabled globally.
     1:              */
 53840:             return fp->annotation();
     1:         }
     1:     }
     1: 
     1:     return NULL;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetFrameAnnotation(JSContext *cx, JSStackFrame *fp, void *annotation)
     1: {
 69223:     Valueify(fp)->setAnnotation(annotation);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 53557: JS_IsScriptFrame(JSContext *cx, JSStackFrame *fp)
     1: {
 69223:     return !Valueify(fp)->isDummyFrame();
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
 69223: JS_GetFrameScopeChain(JSContext *cx, JSStackFrame *fpArg)
     1: {
 69223:     StackFrame *fp = Valueify(fpArg);
 98783:     JS_ASSERT(cx->stack.space().containsSlow(fp));
 42714: 
 96793:     js::AutoCompartment ac(cx, fp->scopeChain());
 56704:     if (!ac.enter())
 56704:         return NULL;
 56704: 
 98921:     return GetDebugScopeForFrame(cx, fp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
 69223: JS_GetFrameCallObject(JSContext *cx, JSStackFrame *fpArg)
     1: {
 69223:     StackFrame *fp = Valueify(fpArg);
 98783:     JS_ASSERT(cx->stack.space().containsSlow(fp));
 42714: 
 53840:     if (!fp->isFunctionFrame())
     1:         return NULL;
     1: 
 98921:     JSObject *o = GetDebugScopeForFrame(cx, fp);
 56704: 
     1:     /*
 98921:      * Given that fp is a function frame and GetDebugScopeForFrame always fills
 98921:      * in missing scopes, we can expect to find fp's CallObject on 'o'. Note:
 98921:      *  - GetDebugScopeForFrame wraps every ScopeObject (missing or not) with
 98921:      *    a DebugScopeObject proxy.
 98921:      *  - If fp is an eval-in-function, then fp has no callobj of its own and
 98921:      *    JS_GetFrameCallObject will return the innermost function's callobj.
     1:      */
 98921:     while (o) {
 98921:         ScopeObject &scope = o->asDebugScope().scope();
100006:         if (scope.isCall()) {
100006:             JS_ASSERT_IF(cx->compartment->debugMode() && fp->isNonEvalFunctionFrame(),
100006:                          fp == scope.asCall().maybeStackFrame());
 98921:             return o;
100006:         }
 98921:         o = o->enclosingScope();
 98921:     }
 98921:     return NULL;
     1: }
     1: 
 55713: JS_PUBLIC_API(JSBool)
 69223: JS_GetFrameThis(JSContext *cx, JSStackFrame *fpArg, jsval *thisv)
     1: {
 69223:     StackFrame *fp = Valueify(fpArg);
 50484:     if (fp->isDummyFrame())
 55713:         return false;
 56704: 
 96793:     js::AutoCompartment ac(cx, fp->scopeChain());
 56704:     if (!ac.enter())
 56704:         return false;
 56704: 
 68904:     if (!ComputeThis(cx, fp))
 55713:         return false;
 78614:     *thisv = fp->thisValue();
 55713:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
     1: JS_GetFrameFunction(JSContext *cx, JSStackFrame *fp)
     1: {
 83474:     return Valueify(fp)->maybeScriptFunction();
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
 69223: JS_GetFrameFunctionObject(JSContext *cx, JSStackFrame *fpArg)
     1: {
 69223:     StackFrame *fp = Valueify(fpArg);
 53840:     if (!fp->isFunctionFrame())
 18955:         return NULL;
 18572: 
 53840:     JS_ASSERT(fp->callee().isFunction());
 53840:     return &fp->callee();
     1: }
     1: 
 84198: JS_PUBLIC_API(JSFunction *)
 84198: JS_GetScriptFunction(JSContext *cx, JSScript *script)
 84198: {
 84198:     return script->function();
 84198: }
 84198: 
 83331: JS_PUBLIC_API(JSObject *)
 83331: JS_GetParentOrScopeChain(JSContext *cx, JSObject *obj)
 83331: {
 86483:     return obj->enclosingScope();
 83331: }
 83331: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_IsConstructorFrame(JSContext *cx, JSStackFrame *fp)
     1: {
 69223:     return Valueify(fp)->isConstructing();
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
     1: JS_GetFrameCalleeObject(JSContext *cx, JSStackFrame *fp)
     1: {
 71695:     return Valueify(fp)->maybeCalleev().toObjectOrNull();
     1: }
     1: 
 98921: JS_PUBLIC_API(const char *)
 98921: JS_GetDebugClassName(JSObject *obj)
 98921: {
 98921:     if (obj->isDebugScope())
 98921:         return obj->asDebugScope().scope().getClass()->name;
 98921:     return obj->getClass()->name;
 98921: }
 98921: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_IsDebuggerFrame(JSContext *cx, JSStackFrame *fp)
     1: {
 69223:     return Valueify(fp)->isDebuggerFrame();
     1: }
     1: 
 69704: JS_PUBLIC_API(JSBool)
 69704: JS_IsGlobalFrame(JSContext *cx, JSStackFrame *fp)
 69704: {
 69704:     return Valueify(fp)->isGlobalFrame();
 69704: }
 69704: 
     1: JS_PUBLIC_API(jsval)
     1: JS_GetFrameReturnValue(JSContext *cx, JSStackFrame *fp)
     1: {
 78614:     return Valueify(fp)->returnValue();
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 69223: JS_SetFrameReturnValue(JSContext *cx, JSStackFrame *fpArg, jsval rval)
     1: {
 69223:     StackFrame *fp = Valueify(fpArg);
 57727: #ifdef JS_METHODJIT
 57727:     JS_ASSERT_IF(fp->isScriptFrame(), fp->script()->debugMode);
 57727: #endif
 56704:     assertSameCompartment(cx, fp, rval);
 78614:     fp->setReturnValue(rval);
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(const char *)
     1: JS_GetScriptFilename(JSContext *cx, JSScript *script)
     1: {
     1:     return script->filename;
     1: }
     1: 
 74581: JS_PUBLIC_API(const jschar *)
 74581: JS_GetScriptSourceMap(JSContext *cx, JSScript *script)
 74581: {
 95139:     return script->hasSourceMap ? script->getSourceMap() : NULL;
 74581: }
 74581: 
 91237: JS_PUBLIC_API(unsigned)
     1: JS_GetScriptBaseLineNumber(JSContext *cx, JSScript *script)
     1: {
     1:     return script->lineno;
     1: }
     1: 
 91237: JS_PUBLIC_API(unsigned)
     1: JS_GetScriptLineExtent(JSContext *cx, JSScript *script)
     1: {
     1:     return js_GetScriptLineExtent(script);
     1: }
     1: 
     1: JS_PUBLIC_API(JSVersion)
     1: JS_GetScriptVersion(JSContext *cx, JSScript *script)
     1: {
 53848:     return VersionNumber(script->getVersion());
     1: }
     1: 
     1: /***************************************************************************/
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetNewScriptHook(JSRuntime *rt, JSNewScriptHook hook, void *callerdata)
     1: {
 91178:     rt->debugHooks.newScriptHook = hook;
 91178:     rt->debugHooks.newScriptHookData = callerdata;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetDestroyScriptHook(JSRuntime *rt, JSDestroyScriptHook hook,
     1:                         void *callerdata)
     1: {
 91178:     rt->debugHooks.destroyScriptHook = hook;
 91178:     rt->debugHooks.destroyScriptHookData = callerdata;
     1: }
     1: 
     1: /***************************************************************************/
     1: 
     1: JS_PUBLIC_API(JSBool)
 69223: JS_EvaluateUCInStackFrame(JSContext *cx, JSStackFrame *fpArg,
 91237:                           const jschar *chars, unsigned length,
 91237:                           const char *filename, unsigned lineno,
     1:                           jsval *rval)
     1: {
 53391:     if (!CheckDebugMode(cx))
 58070:         return false;
 53391: 
 97353:     SkipRoot skip(cx, &chars);
 97353: 
 99421:     Rooted<Env*> env(cx, JS_GetFrameScopeChain(cx, fpArg));
 84307:     if (!env)
 48582:         return false;
     1: 
 84307:     js::AutoCompartment ac(cx, env);
 56704:     if (!ac.enter())
 58070:         return false;
 56704: 
 69223:     StackFrame *fp = Valueify(fpArg);
 84307:     return EvaluateInEnv(cx, env, fp, chars, length, filename, lineno, rval);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_EvaluateInStackFrame(JSContext *cx, JSStackFrame *fp,
 91237:                         const char *bytes, unsigned length,
 91237:                         const char *filename, unsigned lineno,
     1:                         jsval *rval)
     1: {
     1:     jschar *chars;
     1:     JSBool ok;
     1:     size_t len = length;
     1: 
 53391:     if (!CheckDebugMode(cx))
 53391:         return JS_FALSE;
 53391: 
 71337:     chars = InflateString(cx, bytes, &len);
     1:     if (!chars)
     1:         return JS_FALSE;
 91237:     length = (unsigned) len;
     1:     ok = JS_EvaluateUCInStackFrame(cx, fp, chars, length, filename, lineno,
     1:                                    rval);
 64560:     cx->free_(chars);
     1: 
     1:     return ok;
     1: }
     1: 
     1: /************************************************************************/
     1: 
 52503: /* This all should be reworked to avoid requiring JSScopeProperty types. */
     1: 
 97596: static JSBool
 97596: GetPropertyDesc(JSContext *cx, JSObject *obj_, Shape *shape, JSPropertyDesc *pd)
     1: {
 95355:     assertSameCompartment(cx, obj_);
 83221:     pd->id = IdToJsval(shape->propid());
     1: 
 99421:     RootedObject obj(cx, obj_);
 95355: 
 60211:     JSBool wasThrowing = cx->isExceptionPending();
 60211:     Value lastException = UndefinedValue();
 60211:     if (wasThrowing)
 60211:         lastException = cx->getPendingException();
 60211:     cx->clearPendingException();
     1: 
 99421:     if (!baseops::GetProperty(cx, obj, RootedId(cx, shape->propid()), &pd->value)) {
 60211:         if (!cx->isExceptionPending()) {
     1:             pd->flags = JSPD_ERROR;
     1:             pd->value = JSVAL_VOID;
     1:         } else {
     1:             pd->flags = JSPD_EXCEPTION;
 78614:             pd->value = cx->getPendingException();
     1:         }
     1:     } else {
     1:         pd->flags = 0;
     1:     }
     1: 
 35076:     if (wasThrowing)
 60211:         cx->setPendingException(lastException);
     1: 
 52503:     pd->flags |= (shape->enumerable() ? JSPD_ENUMERATE : 0)
 52503:               |  (!shape->writable()  ? JSPD_READONLY  : 0)
 52503:               |  (!shape->configurable() ? JSPD_PERMANENT : 0);
 13706:     pd->spare = 0;
100006:     if (shape->getter() == CallObject::getArgOp) {
 83221:         pd->slot = shape->shortid();
 13706:         pd->flags |= JSPD_ARGUMENT;
100006:     } else if (shape->getter() == CallObject::getVarOp) {
 83221:         pd->slot = shape->shortid();
 13706:         pd->flags |= JSPD_VARIABLE;
 13706:     } else {
 13706:         pd->slot = 0;
     1:     }
     1:     pd->alias = JSVAL_VOID;
 35076: 
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 98960: JS_GetPropertyDescArray(JSContext *cx, JSObject *obj_, JSPropertyDescArray *pda)
     1: {
 99421:     RootedObject obj(cx, obj_);
 98960: 
 56704:     assertSameCompartment(cx, obj);
 98921:     uint32_t i = 0;
 98921:     JSPropertyDesc *pd = NULL;
 97596: 
 98921:     if (obj->isDebugScope()) {
 98921:         AutoIdVector props(cx);
 98921:         if (!Proxy::enumerate(cx, obj, props))
 98921:             return false;
 98921: 
 98921:         pd = (JSPropertyDesc *)cx->calloc_(props.length() * sizeof(JSPropertyDesc));
 98921:         if (!pd)
 98921:             return false;
 98921: 
 98921:         for (i = 0; i < props.length(); ++i) {
 98921:             if (!js_AddRoot(cx, &pd[i].id, NULL))
 98921:                 goto bad;
 98921:             pd[i].id = IdToValue(props[i]);
 98921:             if (!js_AddRoot(cx, &pd[i].value, NULL))
 98921:                 goto bad;
 98921:             if (!Proxy::get(cx, obj, obj, props[i], &pd[i].value))
 98921:                 goto bad;
 98921:         }
 98921: 
 98921:         pda->length = props.length();
 98921:         pda->array = pd;
 98921:         return true;
 98921:     }
 98921: 
 98921:     Class *clasp;
 98921:     clasp = obj->getClass();
 40430:     if (!obj->isNative() || (clasp->flags & JSCLASS_NEW_ENUMERATE)) {
     1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
     1:                              JSMSG_CANT_DESCRIBE_PROPS, clasp->name);
 98921:         return false;
     1:     }
     1:     if (!clasp->enumerate(cx, obj))
 98921:         return false;
     1: 
 52503:     /* Return an empty pda early if obj has no own properties. */
 52503:     if (obj->nativeEmpty()) {
     1:         pda->length = 0;
     1:         pda->array = NULL;
 98921:         return true;
     1:     }
     1: 
 98921:     pd = (JSPropertyDesc *)cx->malloc_(obj->propertyCount() * sizeof(JSPropertyDesc));
     1:     if (!pd)
 98921:         return false;
 52503:     for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront()) {
 78614:         if (!js_AddRoot(cx, &pd[i].id, NULL))
     1:             goto bad;
 78614:         if (!js_AddRoot(cx, &pd[i].value, NULL))
     1:             goto bad;
 52503:         Shape *shape = const_cast<Shape *>(&r.front());
 97596:         if (!GetPropertyDesc(cx, obj, shape, &pd[i]))
     1:             goto bad;
 78614:         if ((pd[i].flags & JSPD_ALIAS) && !js_AddRoot(cx, &pd[i].alias, NULL))
     1:             goto bad;
 98921:         if (++i == obj->propertyCount())
     1:             break;
     1:     }
     1:     pda->length = i;
     1:     pda->array = pd;
 98921:     return true;
     1: 
     1: bad:
     1:     pda->length = i + 1;
     1:     pda->array = pd;
     1:     JS_PutPropertyDescArray(cx, pda);
 98921:     return false;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_PutPropertyDescArray(JSContext *cx, JSPropertyDescArray *pda)
     1: {
     1:     JSPropertyDesc *pd;
 84755:     uint32_t i;
     1: 
     1:     pd = pda->array;
     1:     for (i = 0; i < pda->length; i++) {
     1:         js_RemoveRoot(cx->runtime, &pd[i].id);
     1:         js_RemoveRoot(cx->runtime, &pd[i].value);
     1:         if (pd[i].flags & JSPD_ALIAS)
     1:             js_RemoveRoot(cx->runtime, &pd[i].alias);
     1:     }
 64560:     cx->free_(pd);
 98921:     pda->array = NULL;
 98921:     pda->length = 0;
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(JSBool)
 41863: JS_SetDebuggerHandler(JSRuntime *rt, JSDebuggerHandler handler, void *closure)
     1: {
 91178:     rt->debugHooks.debuggerHandler = handler;
 91178:     rt->debugHooks.debuggerHandlerData = closure;
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_SetSourceHandler(JSRuntime *rt, JSSourceHandler handler, void *closure)
     1: {
 91178:     rt->debugHooks.sourceHandler = handler;
 91178:     rt->debugHooks.sourceHandlerData = closure;
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_SetExecuteHook(JSRuntime *rt, JSInterpreterHook hook, void *closure)
     1: {
 91178:     rt->debugHooks.executeHook = hook;
 91178:     rt->debugHooks.executeHookData = closure;
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_SetCallHook(JSRuntime *rt, JSInterpreterHook hook, void *closure)
     1: {
 91178:     rt->debugHooks.callHook = hook;
 91178:     rt->debugHooks.callHookData = closure;
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 41863: JS_SetThrowHook(JSRuntime *rt, JSThrowHook hook, void *closure)
     1: {
 91178:     rt->debugHooks.throwHook = hook;
 91178:     rt->debugHooks.throwHookData = closure;
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_SetDebugErrorHook(JSRuntime *rt, JSDebugErrorHook hook, void *closure)
     1: {
 91178:     rt->debugHooks.debugErrorHook = hook;
 91178:     rt->debugHooks.debugErrorHookData = closure;
     1:     return JS_TRUE;
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(size_t)
     1: JS_GetObjectTotalSize(JSContext *cx, JSObject *obj)
     1: {
 89497:     return obj->computedSizeOfThisSlotsElements();
     1: }
     1: 
     1: static size_t
     1: GetAtomTotalSize(JSContext *cx, JSAtom *atom)
     1: {
 94610:     return sizeof(AtomStateEntry) + sizeof(HashNumber) +
 94610:            sizeof(JSString) +
 94610:            (atom->length() + 1) * sizeof(jschar);
     1: }
     1: 
     1: JS_PUBLIC_API(size_t)
     1: JS_GetFunctionTotalSize(JSContext *cx, JSFunction *fun)
     1: {
     1:     size_t nbytes;
     1: 
     1:     nbytes = sizeof *fun;
 76812:     nbytes += JS_GetObjectTotalSize(cx, fun);
 76812:     if (fun->isInterpreted())
 70311:         nbytes += JS_GetScriptTotalSize(cx, fun->script());
     1:     if (fun->atom)
     1:         nbytes += GetAtomTotalSize(cx, fun->atom);
     1:     return nbytes;
     1: }
     1: 
     1: JS_PUBLIC_API(size_t)
     1: JS_GetScriptTotalSize(JSContext *cx, JSScript *script)
     1: {
     1:     size_t nbytes, pbytes;
     1:     jssrcnote *sn, *notes;
 97362:     ObjectArray *objarray;
     1:     JSPrincipals *principals;
     1: 
     1:     nbytes = sizeof *script;
     1:     nbytes += script->length * sizeof script->code[0];
 77659:     nbytes += script->natoms * sizeof script->atoms[0];
 77659:     for (size_t i = 0; i < script->natoms; i++)
 77659:         nbytes += GetAtomTotalSize(cx, script->atoms[i]);
     1: 
     1:     if (script->filename)
     1:         nbytes += strlen(script->filename) + 1;
     1: 
 32723:     notes = script->notes();
     1:     for (sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
     1:         continue;
     1:     nbytes += (sn - notes + 1) * sizeof *sn;
     1: 
 97361:     if (script->hasObjects()) {
 32723:         objarray = script->objects();
 72579:         size_t i = objarray->length;
  3235:         nbytes += sizeof *objarray + i * sizeof objarray->vector[0];
  3235:         do {
  3235:             nbytes += JS_GetObjectTotalSize(cx, objarray->vector[--i]);
  3235:         } while (i != 0);
  3235:     }
  3235: 
 97361:     if (script->hasRegexps()) {
 32723:         objarray = script->regexps();
 72579:         size_t i = objarray->length;
  3235:         nbytes += sizeof *objarray + i * sizeof objarray->vector[0];
  3235:         do {
  3235:             nbytes += JS_GetObjectTotalSize(cx, objarray->vector[--i]);
  3235:         } while (i != 0);
  3235:     }
  3235: 
 97362:     if (script->hasTrynotes())
 97362:         nbytes += sizeof(TryNoteArray) + script->trynotes()->length * sizeof(JSTryNote);
     1: 
     1:     principals = script->principals;
     1:     if (principals) {
     1:         JS_ASSERT(principals->refcount);
     1:         pbytes = sizeof *principals;
     1:         if (principals->refcount > 1)
     1:             pbytes = JS_HOWMANY(pbytes, principals->refcount);
     1:         nbytes += pbytes;
     1:     }
     1: 
     1:     return nbytes;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_IsSystemObject(JSContext *cx, JSObject *obj)
     1: {
 32603:     return obj->isSystem();
     1: }
     1: 
 43286: JS_PUBLIC_API(JSBool)
 43286: JS_MakeSystemObject(JSContext *cx, JSObject *obj)
     1: {
 83248:     return obj->setSystem(cx);
     1: }
  2433: 
  2433: /************************************************************************/
  2433: 
 53848: JS_FRIEND_API(void)
 53848: js_RevertVersion(JSContext *cx)
 53848: {
 53848:     cx->clearVersionOverride();
 53848: }
 53848: 
 35331: JS_PUBLIC_API(const JSDebugHooks *)
  2433: JS_GetGlobalDebugHooks(JSRuntime *rt)
  2433: {
 91178:     return &rt->debugHooks;
 37717: }
 37717: 
 76358: /************************************************************************/
 76358: 
 76358: /* Profiling-related API */
 76358: 
 76358: /* Thread-unsafe error management */
 76358: 
 76358: static char gLastError[2000];
 76358: 
 76358: static void
 76711: #ifdef __GNUC__
 76358: __attribute__((unused,format(printf,1,2)))
 76358: #endif
 76358: UnsafeError(const char *format, ...)
 60787: {
 76358:     va_list args;
 76358:     va_start(args, format);
 76358:     (void) vsnprintf(gLastError, sizeof(gLastError), format, args);
 76358:     va_end(args);
 76358: 
 76358:     gLastError[sizeof(gLastError) - 1] = '\0';
 60787: }
 10339: 
 76358: JS_PUBLIC_API(const char *)
 76358: JS_UnsafeGetLastProfilingError()
 60787: {
 76358:     return gLastError;
 76358: }
 76358: 
 76358: JS_PUBLIC_API(JSBool)
 76358: JS_StartProfiling(const char *profileName)
 76358: {
 76358:     JSBool ok = JS_TRUE;
 76358: #if defined(MOZ_SHARK) && defined(__APPLE__)
 76358:     if (!Shark::Start()) {
 76358:         UnsafeError("Failed to start Shark for %s", profileName);
 76358:         ok = JS_FALSE;
 76358:     }
 76358: #endif
 76358: #ifdef MOZ_VTUNE
 76358:     if (!js_StartVtune(profileName))
 76358:         ok = JS_FALSE;
 76358: #endif
 96797: #ifdef __linux__
 96797:     if (!js_StartPerf())
 96797:         ok = JS_FALSE;
 96797: #endif
 76358:     return ok;
 76358: }
 76358: 
 76358: JS_PUBLIC_API(JSBool)
 76358: JS_StopProfiling(const char *profileName)
 76358: {
 76358:     JSBool ok = JS_TRUE;
 76358: #if defined(MOZ_SHARK) && defined(__APPLE__)
 76358:     Shark::Stop();
 76358: #endif
 76358: #ifdef MOZ_VTUNE
 76358:     if (!js_StopVtune())
 76358:         ok = JS_FALSE;
 76358: #endif
 96797: #ifdef __linux__
 96797:     if (!js_StopPerf())
 96797:         ok = JS_FALSE;
 96797: #endif
 76358:     return ok;
 76358: }
 76358: 
 76358: /*
 76358:  * Start or stop whatever platform- and configuration-specific profiling
 76358:  * backends are available.
 76358:  */
 76358: static JSBool
 76358: ControlProfilers(bool toState)
 76358: {
 76358:     JSBool ok = JS_TRUE;
 76358: 
 76358:     if (! Probes::ProfilingActive && toState) {
 76358: #if defined(MOZ_SHARK) && defined(__APPLE__)
 76358:         if (!Shark::Start()) {
 76358:             UnsafeError("Failed to start Shark");
 76358:             ok = JS_FALSE;
 76358:         }
 76358: #endif
 76358: #ifdef MOZ_CALLGRIND
 76358:         if (! js_StartCallgrind()) {
 76358:             UnsafeError("Failed to start Callgrind");
 76358:             ok = JS_FALSE;
 76358:         }
 76358: #endif
 76358: #ifdef MOZ_VTUNE
 76358:         if (! js_ResumeVtune())
 76358:             ok = JS_FALSE;
 76358: #endif
 76358:     } else if (Probes::ProfilingActive && ! toState) {
 76358: #if defined(MOZ_SHARK) && defined(__APPLE__)
 76358:         Shark::Stop();
 76358: #endif
 76358: #ifdef MOZ_CALLGRIND
 76358:         if (! js_StopCallgrind()) {
 76358:             UnsafeError("failed to stop Callgrind");
 76358:             ok = JS_FALSE;
 76358:         }
 76358: #endif
 76358: #ifdef MOZ_VTUNE
 76358:         if (! js_PauseVtune())
 76358:             ok = JS_FALSE;
 76358: #endif
 76358:     }
 76358: 
 76358:     Probes::ProfilingActive = toState;
 76358: 
 76358:     return ok;
 76358: }
 76358: 
 76358: /*
 76358:  * Pause/resume whatever profiling mechanism is currently compiled
 76358:  * in, if applicable. This will not affect things like dtrace.
 76358:  *
 76358:  * Do not mix calls to these APIs with calls to the individual
 76358:  * profilers' pause/resume functions, because only overall state is
 76358:  * tracked, not the state of each profiler.
 76358:  */
 76358: JS_PUBLIC_API(JSBool)
 76358: JS_PauseProfilers(const char *profileName)
 76358: {
 76358:     return ControlProfilers(false);
 76358: }
 76358: 
 76358: JS_PUBLIC_API(JSBool)
 76358: JS_ResumeProfilers(const char *profileName)
 76358: {
 76358:     return ControlProfilers(true);
 76358: }
 76358: 
 76358: JS_PUBLIC_API(JSBool)
 76358: JS_DumpProfile(const char *outfile, const char *profileName)
 76358: {
 76358:     JSBool ok = JS_TRUE;
 76358: #ifdef MOZ_CALLGRIND
 76358:     js_DumpCallgrind(outfile);
 76358: #endif
 76358:     return ok;
 60787: }
 60787: 
 60787: #ifdef MOZ_PROFILING
 60787: 
 76358: struct RequiredStringArg {
 76358:     JSContext *mCx;
 76358:     char *mBytes;
 91237:     RequiredStringArg(JSContext *cx, unsigned argc, jsval *vp, size_t argi, const char *caller)
 76358:         : mCx(cx), mBytes(NULL)
 76358:     {
 76358:         if (argc <= argi) {
 76358:             JS_ReportError(cx, "%s: not enough arguments", caller);
 76358:         } else if (!JSVAL_IS_STRING(JS_ARGV(cx, vp)[argi])) {
 76358:             JS_ReportError(cx, "%s: invalid arguments (string expected)", caller);
 76358:         } else {
 76358:             mBytes = JS_EncodeString(cx, JSVAL_TO_STRING(JS_ARGV(cx, vp)[argi]));
 76358:         }
 76358:     }
 76358:     operator void*() {
 76358:         return (void*) mBytes;
 76358:     }
 76358:     ~RequiredStringArg() {
 76358:         if (mBytes)
 76358:             mCx->free_(mBytes);
 76358:     }
 76358: };
 76358: 
 60787: static JSBool
 91237: StartProfiling(JSContext *cx, unsigned argc, jsval *vp)
 60787: {
 76358:     if (argc == 0) {
 76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_StartProfiling(NULL)));
 76358:         return JS_TRUE;
 76358:     }
 76358: 
 76358:     RequiredStringArg profileName(cx, argc, vp, 0, "startProfiling");
 76358:     if (!profileName)
 76358:         return JS_FALSE;
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_StartProfiling(profileName.mBytes)));
 76358:     return JS_TRUE;
 60787: }
 60787: 
 60787: static JSBool
 91237: StopProfiling(JSContext *cx, unsigned argc, jsval *vp)
 60787: {
 76358:     if (argc == 0) {
 76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_StopProfiling(NULL)));
 76358:         return JS_TRUE;
 76358:     }
 76358: 
 76358:     RequiredStringArg profileName(cx, argc, vp, 0, "stopProfiling");
 76358:     if (!profileName)
 76358:         return JS_FALSE;
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_StopProfiling(profileName.mBytes)));
 76358:     return JS_TRUE;
 76358: }
 76358: 
 76358: static JSBool
 91237: PauseProfilers(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     if (argc == 0) {
 76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_PauseProfilers(NULL)));
 76358:         return JS_TRUE;
 76358:     }
 76358: 
 76358:     RequiredStringArg profileName(cx, argc, vp, 0, "pauseProfiling");
 76358:     if (!profileName)
 76358:         return JS_FALSE;
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_PauseProfilers(profileName.mBytes)));
 76358:     return JS_TRUE;
 76358: }
 76358: 
 76358: static JSBool
 91237: ResumeProfilers(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     if (argc == 0) {
 76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_ResumeProfilers(NULL)));
 76358:         return JS_TRUE;
 76358:     }
 76358: 
 76358:     RequiredStringArg profileName(cx, argc, vp, 0, "resumeProfiling");
 76358:     if (!profileName)
 76358:         return JS_FALSE;
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_ResumeProfilers(profileName.mBytes)));
 76358:     return JS_TRUE;
 76358: }
 76358: 
 76358: /* Usage: DumpProfile([filename[, profileName]]) */
 76358: static JSBool
 91237: DumpProfile(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     bool ret;
 76358:     if (argc == 0) {
 76358:         ret = JS_DumpProfile(NULL, NULL);
 76358:     } else {
 76358:         RequiredStringArg filename(cx, argc, vp, 0, "dumpProfile");
 76358:         if (!filename)
 76358:             return JS_FALSE;
 76358: 
 76358:         if (argc == 1) {
 76358:             ret = JS_DumpProfile(filename.mBytes, NULL);
 76358:         } else {
 76358:             RequiredStringArg profileName(cx, argc, vp, 1, "dumpProfile");
 76358:             if (!profileName)
 76358:                 return JS_FALSE;
 76358: 
 76358:             ret = JS_DumpProfile(filename.mBytes, profileName.mBytes);
 76358:         }
 76358:     }
 76358: 
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret));
 60787:     return true;
 60787: }
 60787: 
 60791: #ifdef MOZ_SHARK
 60791: 
 60791: static JSBool
 91237: IgnoreAndReturnTrue(JSContext *cx, unsigned argc, jsval *vp)
 60791: {
 60791:     JS_SET_RVAL(cx, vp, JSVAL_TRUE);
 60791:     return true;
 60791: }
 60791: 
 60791: #endif
 60791: 
 76358: #ifdef MOZ_CALLGRIND
 76358: static JSBool
 91237: StartCallgrind(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_StartCallgrind()));
 76358:     return JS_TRUE;
 76358: }
 76358: 
 76358: static JSBool
 91237: StopCallgrind(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_StopCallgrind()));
 76358:     return JS_TRUE;
 76358: }
 76358: 
 76358: static JSBool
 91237: DumpCallgrind(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     if (argc == 0) {
 76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_DumpCallgrind(NULL)));
 76358:         return JS_TRUE;
 76358:     }
 76358: 
 76358:     RequiredStringArg outFile(cx, argc, vp, 0, "dumpCallgrind");
 76358:     if (!outFile)
 76358:         return JS_FALSE;
 76358: 
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_DumpCallgrind(outFile.mBytes)));
 76358:     return JS_TRUE;
 76358: }
 76358: #endif
 76358: 
 76358: #ifdef MOZ_VTUNE
 76358: static JSBool
 91237: StartVtune(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     RequiredStringArg profileName(cx, argc, vp, 0, "startVtune");
 76358:     if (!profileName)
 76358:         return JS_FALSE;
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_StartVtune(profileName.mBytes)));
 76358:     return JS_TRUE;
 76358: }
 76358: 
 76358: static JSBool
 91237: StopVtune(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_StopVtune()));
 76358:     return JS_TRUE;
 76358: }
 76358: 
 76358: static JSBool
 91237: PauseVtune(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_PauseVtune()));
 76358:     return JS_TRUE;
 76358: }
 76358: 
 76358: static JSBool
 91237: ResumeVtune(JSContext *cx, unsigned argc, jsval *vp)
 76358: {
 76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_ResumeVtune()));
 76358:     return JS_TRUE;
 76358: }
 76358: #endif
 76358: 
 60787: static JSFunctionSpec profiling_functions[] = {
 76358:     JS_FN("startProfiling",  StartProfiling,      1,0),
 76358:     JS_FN("stopProfiling",   StopProfiling,       1,0),
 76358:     JS_FN("pauseProfilers",  PauseProfilers,      1,0),
 76358:     JS_FN("resumeProfilers", ResumeProfilers,     1,0),
 76358:     JS_FN("dumpProfile",     DumpProfile,         2,0),
 60791: #ifdef MOZ_SHARK
 60791:     /* Keep users of the old shark API happy. */
 60791:     JS_FN("connectShark",    IgnoreAndReturnTrue, 0,0),
 60791:     JS_FN("disconnectShark", IgnoreAndReturnTrue, 0,0),
 60791:     JS_FN("startShark",      StartProfiling,      0,0),
 60791:     JS_FN("stopShark",       StopProfiling,       0,0),
 60791: #endif
 76358: #ifdef MOZ_CALLGRIND
 76358:     JS_FN("startCallgrind", StartCallgrind,       0,0),
 76358:     JS_FN("stopCallgrind",  StopCallgrind,        0,0),
 76358:     JS_FN("dumpCallgrind",  DumpCallgrind,        1,0),
 76358: #endif
 76358: #ifdef MOZ_VTUNE
 76358:     JS_FN("startVtune",     js_StartVtune,        1,0),
 76358:     JS_FN("stopVtune",      js_StopVtune,         0,0),
 76358:     JS_FN("pauseVtune",     js_PauseVtune,        0,0),
 76358:     JS_FN("resumeVtune",    js_ResumeVtune,       0,0),
 76358: #endif
 60787:     JS_FS_END
 60787: };
 60787: 
 60787: #endif
 13496: 
 10447: JS_PUBLIC_API(JSBool)
 60787: JS_DefineProfilingFunctions(JSContext *cx, JSObject *obj)
 10339: {
 64192:     assertSameCompartment(cx, obj);
 60787: #ifdef MOZ_PROFILING
 60787:     return JS_DefineFunctions(cx, obj, profiling_functions);
 60787: #else
 60787:     return true;
 60787: #endif
 10339: }
 10339: 
 15763: #ifdef MOZ_CALLGRIND
 15763: 
 15763: #include <valgrind/callgrind.h>
 15763: 
 15763: JS_FRIEND_API(JSBool)
 76358: js_StartCallgrind()
 15763: {
 84602:     JS_SILENCE_UNUSED_VALUE_IN_EXPR(CALLGRIND_START_INSTRUMENTATION);
 84602:     JS_SILENCE_UNUSED_VALUE_IN_EXPR(CALLGRIND_ZERO_STATS);
 76358:     return true;
 15763: }
 15763: 
 15763: JS_FRIEND_API(JSBool)
 76358: js_StopCallgrind()
 15763: {
 84602:     JS_SILENCE_UNUSED_VALUE_IN_EXPR(CALLGRIND_STOP_INSTRUMENTATION);
 76358:     return true;
 15763: }
 15763: 
 15763: JS_FRIEND_API(JSBool)
 76358: js_DumpCallgrind(const char *outfile)
 15763: {
 76358:     if (outfile) {
 84602:         JS_SILENCE_UNUSED_VALUE_IN_EXPR(CALLGRIND_DUMP_STATS_AT(outfile));
 76358:     } else {
 84602:         JS_SILENCE_UNUSED_VALUE_IN_EXPR(CALLGRIND_DUMP_STATS);
 76358:     }
 75388: 
 76358:     return true;
 15763: }
 15763: 
 15763: #endif /* MOZ_CALLGRIND */
 16288: 
 16288: #ifdef MOZ_VTUNE
 16288: #include <VTuneApi.h>
 16288: 
 16288: static const char *vtuneErrorMessages[] = {
 16288:   "unknown, error #0",
 16288:   "invalid 'max samples' field",
 16288:   "invalid 'samples per buffer' field",
 16288:   "invalid 'sample interval' field",
 16288:   "invalid path",
 16288:   "sample file in use",
 16288:   "invalid 'number of events' field",
 16288:   "unknown, error #7",
 16288:   "internal error",
 16288:   "bad event name",
 16288:   "VTStopSampling called without calling VTStartSampling",
 16288:   "no events selected for event-based sampling",
 16288:   "events selected cannot be run together",
 16288:   "no sampling parameters",
 16288:   "sample database already exists",
 16288:   "sampling already started",
 16288:   "time-based sampling not supported",
 16288:   "invalid 'sampling parameters size' field",
 16288:   "invalid 'event size' field",
 16288:   "sampling file already bound",
 16288:   "invalid event path",
 16288:   "invalid license",
 16288:   "invalid 'global options' field",
 16288: 
 16288: };
 16288: 
 76358: bool
 76358: js_StartVtune(const char *profileName)
 16288: {
 16288:     VTUNE_EVENT events[] = {
 16288:         { 1000000, 0, 0, 0, "CPU_CLK_UNHALTED.CORE" },
 16288:         { 1000000, 0, 0, 0, "INST_RETIRED.ANY" },
 16288:     };
 16288: 
 16288:     U32 n_events = sizeof(events) / sizeof(VTUNE_EVENT);
 16288:     char *default_filename = "mozilla-vtune.tb5";
 16288:     JSString *str;
 16288:     U32 status;
 16288: 
 54568:     VTUNE_SAMPLING_PARAMS params = {
 16288:         sizeof(VTUNE_SAMPLING_PARAMS),
 16288:         sizeof(VTUNE_EVENT),
 16288:         0, 0, /* Reserved fields */
 16288:         1,    /* Initialize in "paused" state */
 16288:         0,    /* Max samples, or 0 for "continuous" */
 16288:         4096, /* Samples per buffer */
 16288:         0.1,  /* Sampling interval in ms */
 16288:         1,    /* 1 for event-based sampling, 0 for time-based */
 16288: 
 16288:         n_events,
 16288:         events,
 16288:         default_filename,
 16288:     };
 16288: 
 76358:     if (profileName) {
 76358:         char filename[strlen(profileName) + strlen("-vtune.tb5") + 1];
 76358:         snprintf(filename, sizeof(filename), "%s-vtune.tb5", profileName);
 76358:         params.tb5Filename = filename;
 16288:     }
 16288: 
 16288:     status = VTStartSampling(&params);
 16288: 
 16288:     if (params.tb5Filename != default_filename)
 76358:         Foreground::free_(params.tb5Filename);
 16288: 
 16288:     if (status != 0) {
 16288:         if (status == VTAPI_MULTIPLE_RUNS)
 16288:             VTStopSampling(0);
 16288:         if (status < sizeof(vtuneErrorMessages))
 76358:             UnsafeError("Vtune setup error: %s", vtuneErrorMessages[status]);
 16288:         else
 76358:             UnsafeError("Vtune setup error: %d", status);
 54568:         return false;
 16288:     }
 54568:     return true;
 16288: }
 16288: 
 76358: bool
 76358: js_StopVtune()
 16288: {
 16288:     U32 status = VTStopSampling(1);
 16288:     if (status) {
 16288:         if (status < sizeof(vtuneErrorMessages))
 76358:             UnsafeError("Vtune shutdown error: %s", vtuneErrorMessages[status]);
 16288:         else
 76358:             UnsafeError("Vtune shutdown error: %d", status);
 54568:         return false;
 16288:     }
 54568:     return true;
 16288: }
 16288: 
 76358: bool
 76358: js_PauseVtune()
 16288: {
 16288:     VTPause();
 54568:     return true;
 16288: }
 16288: 
 76358: bool
 76358: js_ResumeVtune()
 16288: {
 16288:     VTResume();
 54568:     return true;
 16288: }
 16288: 
 16288: #endif /* MOZ_VTUNE */
 31063: 
 96797: #ifdef __linux__
 96797: 
 96797: /*
 96797:  * Code for starting and stopping |perf|, the Linux profiler.
 96797:  *
 96797:  * Output from profiling is written to mozperf.data in your cwd.
 96797:  *
 96797:  * To enable, set MOZ_PROFILE_WITH_PERF=1 in your environment.
 96797:  *
 96797:  * To pass additional parameters to |perf record|, provide them in the
 96797:  * MOZ_PROFILE_PERF_FLAGS environment variable.  If this variable does not
 96797:  * exist, we default it to "--call-graph".  (If you don't want --call-graph but
 96797:  * don't want to pass any other args, define MOZ_PROFILE_PERF_FLAGS to the empty
 96797:  * string.)
 96797:  *
 96797:  * If you include --pid or --output in MOZ_PROFILE_PERF_FLAGS, you're just
 96797:  * asking for trouble.
 96797:  *
 96797:  * Our split-on-spaces logic is lame, so don't expect MOZ_PROFILE_PERF_FLAGS to
 96797:  * work if you pass an argument which includes a space (e.g.
 96797:  * MOZ_PROFILE_PERF_FLAGS="-e 'foo bar'").
 96797:  */
 96797: 
 96797: #include <sys/types.h>
 96797: #include <sys/wait.h>
 96797: #include <unistd.h>
 96797: #include <signal.h>
 96797: 
 96797: static bool perfInitialized = false;
 96797: static pid_t perfPid = 0;
 96797: 
 96797: JSBool js_StartPerf()
 96797: {
 96797:     const char *outfile = "mozperf.data";
 96797: 
 96797:     if (perfPid != 0) {
 96797:         UnsafeError("js_StartPerf: called while perf was already running!\n");
 96797:         return false;
 96797:     }
 96797: 
 96797:     // Bail if MOZ_PROFILE_WITH_PERF is empty or undefined.
 96797:     if (!getenv("MOZ_PROFILE_WITH_PERF") ||
 96797:         !strlen(getenv("MOZ_PROFILE_WITH_PERF"))) {
 96797:         return true;
 96797:     }
 96797: 
 96797:     /*
 96797:      * Delete mozperf.data the first time through -- we're going to append to it
 96797:      * later on, so we want it to be clean when we start out.
 96797:      */
 96797:     if (!perfInitialized) {
 96797:         perfInitialized = true;
 96797:         unlink(outfile);
 96797:         char cwd[4096];
 96797:         printf("Writing perf profiling data to %s/%s\n",
 96797:                getcwd(cwd, sizeof(cwd)), outfile);
 96797:     }
 96797: 
 96797:     pid_t mainPid = getpid();
 96797: 
 96797:     pid_t childPid = fork();
 96797:     if (childPid == 0) {
 96797:         /* perf record --append --pid $mainPID --output=$outfile $MOZ_PROFILE_PERF_FLAGS */
 96797: 
 96797:         char mainPidStr[16];
 96797:         snprintf(mainPidStr, sizeof(mainPidStr), "%d", mainPid);
 96797:         const char *defaultArgs[] = {"perf", "record", "--append",
 96797:                                      "--pid", mainPidStr, "--output", outfile};
 96797: 
 96797:         Vector<const char*, 0, SystemAllocPolicy> args;
 96797:         args.append(defaultArgs, ArrayLength(defaultArgs));
 96797: 
 96797:         const char *flags = getenv("MOZ_PROFILE_PERF_FLAGS");
 96797:         if (!flags) {
 96797:             flags = "--call-graph";
 96797:         }
 96797: 
 96797:         // Split |flags| on spaces.  (Don't bother to free it -- we're going to
 96797:         // exec anyway.)
 96797:         char *toksave;
 96797:         char *tok = strtok_r(strdup(flags), " ", &toksave);
 96797:         while (tok) {
 96797:             args.append(tok);
 96797:             tok = strtok_r(NULL, " ", &toksave);
 96797:         }
 96797: 
 96797:         args.append((char*) NULL);
 96797: 
 96797:         execvp("perf", const_cast<char**>(args.begin()));
 96797: 
 96797:         /* Reached only if execlp fails. */
 96797:         fprintf(stderr, "Unable to start perf.\n");
 96797:         exit(1);
 96797:     }
 96797:     else if (childPid > 0) {
 96797:         perfPid = childPid;
 96797: 
 96797:         /* Give perf a chance to warm up. */
 96797:         usleep(500 * 1000);
 96797:         return true;
 96797:     }
 96797:     else {
 96797:         UnsafeError("js_StartPerf: fork() failed\n");
 96797:         return false;
 96797:     }
 96797: }
 96797: 
 96797: JSBool js_StopPerf()
 96797: {
 96797:     if (perfPid == 0) {
 96797:         UnsafeError("js_StopPerf: perf is not running.\n");
 96797:         return true;
 96797:     }
 96797: 
 96797:     if (kill(perfPid, SIGINT)) {
 96797:         UnsafeError("js_StopPerf: kill failed\n");
 96797: 
 96797:         // Try to reap the process anyway.
 96797:         waitpid(perfPid, NULL, WNOHANG);
 96797:     }
 96797:     else {
 96797:         waitpid(perfPid, NULL, 0);
 96797:     }
 96797: 
 96797:     perfPid = 0;
 96797:     return true;
 96797: }
 96797: 
 96797: #endif /* __linux__ */
 96797: 
 71700: JS_PUBLIC_API(void)
 76358: JS_DumpBytecode(JSContext *cx, JSScript *script)
 71700: {
 71700: #if defined(DEBUG)
 87952:     Sprinter sprinter(cx);
 87952:     if (!sprinter.init())
 87952:         return;
 71700: 
 76358:     fprintf(stdout, "--- SCRIPT %s:%d ---\n", script->filename, script->lineno);
 71700:     js_Disassemble(cx, script, true, &sprinter);
 87952:     fputs(sprinter.string(), stdout);
 76358:     fprintf(stdout, "--- END SCRIPT %s:%d ---\n", script->filename, script->lineno);
 71700: #endif
 71700: }
 71700: 
 82134: extern JS_PUBLIC_API(void)
 82134: JS_DumpPCCounts(JSContext *cx, JSScript *script)
 82134: {
 82134: #if defined(DEBUG)
 95113:     JS_ASSERT(script->hasScriptCounts);
 82134: 
 87952:     Sprinter sprinter(cx);
 87952:     if (!sprinter.init())
 87952:         return;
 82134: 
 82134:     fprintf(stdout, "--- SCRIPT %s:%d ---\n", script->filename, script->lineno);
 82134:     js_DumpPCCounts(cx, script, &sprinter);
 87952:     fputs(sprinter.string(), stdout);
 82134:     fprintf(stdout, "--- END SCRIPT %s:%d ---\n", script->filename, script->lineno);
 82134: #endif
 82134: }
 82134: 
 91287: namespace {
 91287: 
 91287: typedef Vector<JSScript *, 0, SystemAllocPolicy> ScriptsToDump;
 91287: 
 77659: static void
 91287: DumpBytecodeScriptCallback(JSRuntime *rt, void *data, void *thing,
 77659:                            JSGCTraceKind traceKind, size_t thingSize)
 77659: {
 77659:     JS_ASSERT(traceKind == JSTRACE_SCRIPT);
 77659:     JSScript *script = static_cast<JSScript *>(thing);
 91287:     static_cast<ScriptsToDump *>(data)->append(script);
 77659: }
 77659: 
 91287: } /* anonymous namespace */
 91287: 
 71700: JS_PUBLIC_API(void)
 76358: JS_DumpCompartmentBytecode(JSContext *cx)
 71700: {
 91287:     ScriptsToDump scripts;
 91287:     IterateCells(cx->runtime, cx->compartment, gc::FINALIZE_SCRIPT, &scripts, DumpBytecodeScriptCallback);
 79734: 
 84803:     for (size_t i = 0; i < scripts.length(); i++)
 84803:         JS_DumpBytecode(cx, scripts[i]);
 82134: }
 82134: 
 82134: JS_PUBLIC_API(void)
 82134: JS_DumpCompartmentPCCounts(JSContext *cx)
 82134: {
 91287:     for (CellIter i(cx->compartment, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
 84803:         JSScript *script = i.get<JSScript>();
 95113:         if (script->hasScriptCounts)
 84803:             JS_DumpPCCounts(cx, script);
 84803:     }
 82134: }
 82134: 
 79734: JS_PUBLIC_API(JSObject *)
 79734: JS_UnwrapObject(JSObject *obj)
 79734: {
 79734:     return UnwrapObject(obj);
 79734: }
 92133: 
 97683: JS_PUBLIC_API(JSObject *)
 97683: JS_UnwrapObjectAndInnerize(JSObject *obj)
 97683: {
 97683:     return UnwrapObject(obj, /* stopAtOuter = */ false);
 97683: }
 97683: 
 92133: JS_FRIEND_API(JSBool)
 92133: js_CallContextDebugHandler(JSContext *cx)
 92133: {
 97161:     ScriptFrameIter iter(cx);
 92133:     JS_ASSERT(!iter.done());
 92133: 
 92133:     jsval rval;
 92133:     switch (js::CallContextDebugHandler(cx, iter.script(), iter.pc(), &rval)) {
 92133:       case JSTRAP_ERROR:
 92133:         JS_ClearPendingException(cx);
 92133:         return JS_FALSE;
 92133:       case JSTRAP_THROW:
 92133:         JS_SetPendingException(cx, rval);
 92133:         return JS_FALSE;
 92133:       case JSTRAP_RETURN:
 92133:       case JSTRAP_CONTINUE:
 92133:       default:
 92133:         return JS_TRUE;
 92133:     }
 92133: }
 92133: 
