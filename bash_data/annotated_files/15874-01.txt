    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Constantine A. Murenin <cnst+moz#bugmail.mojo.ru>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsLocaleCID.h"
    1: #include "nsILocaleService.h"
    1: #include "nsDateTimeFormatCID.h"
    1: #include "nsIDateTimeFormat.h"
    1: #include "nsIScriptableDateFormat.h"
    1: #include "nsCRT.h"
    1: #include "nsReadableUtils.h"
15867: #include "nsIPrefService.h"
    1: 
    1: static NS_DEFINE_CID(kLocaleServiceCID, NS_LOCALESERVICE_CID);
    1: static NS_DEFINE_CID(kDateTimeFormatCID, NS_DATETIMEFORMAT_CID);
    1: 
    1: class nsScriptableDateFormat : public nsIScriptableDateFormat {
    1:  public: 
    1:   NS_DECL_ISUPPORTS 
    1: 
    1:   NS_IMETHOD FormatDateTime(const PRUnichar *locale, 
    1:                             nsDateFormatSelector dateFormatSelector, 
    1:                             nsTimeFormatSelector timeFormatSelector, 
    1:                             PRInt32 year, 
    1:                             PRInt32 month, 
    1:                             PRInt32 day, 
    1:                             PRInt32 hour, 
    1:                             PRInt32 minute, 
    1:                             PRInt32 second, 
    1:                             PRUnichar **dateTimeString);
    1: 
    1:   NS_IMETHOD FormatDate(const PRUnichar *locale, 
    1:                         nsDateFormatSelector dateFormatSelector, 
    1:                         PRInt32 year, 
    1:                         PRInt32 month, 
    1:                         PRInt32 day, 
    1:                         PRUnichar **dateString)
    1:                         {return FormatDateTime(locale, dateFormatSelector, kTimeFormatNone, 
    1:                                                year, month, day, 0, 0, 0, dateString);}
    1: 
    1:   NS_IMETHOD FormatTime(const PRUnichar *locale, 
    1:                         nsTimeFormatSelector timeFormatSelector, 
    1:                         PRInt32 hour, 
    1:                         PRInt32 minute, 
    1:                         PRInt32 second, 
    1:                         PRUnichar **timeString)
    1:                         {return FormatDateTime(locale, kDateFormatNone, timeFormatSelector, 
    1:                                                1999, 1, 1, hour, minute, second, timeString);}
    1: 
    1:   nsScriptableDateFormat() {}
    1:   virtual ~nsScriptableDateFormat() {}
    1: private:
    1:   nsString mStringOut;   
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(nsScriptableDateFormat, nsIScriptableDateFormat)
    1: 
    1: NS_IMETHODIMP nsScriptableDateFormat::FormatDateTime(
    1:                             const PRUnichar *aLocale, 
    1:                             nsDateFormatSelector dateFormatSelector, 
    1:                             nsTimeFormatSelector timeFormatSelector, 
    1:                             PRInt32 year, 
    1:                             PRInt32 month, 
    1:                             PRInt32 day, 
    1:                             PRInt32 hour, 
    1:                             PRInt32 minute, 
    1:                             PRInt32 second, 
    1:                             PRUnichar **dateTimeString)
    1: {
    1:   // We can't have a valid date with the year, month or day
    1:   // being lower than 1.
    1:   if (year < 1 || month < 1 || day < 1)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   nsresult rv;
    1:   nsAutoString localeName(aLocale);
    1:   *dateTimeString = nsnull;
    1: 
    1:   nsCOMPtr<nsILocale> locale;
    1:   // re-initialise locale pointer only if the locale was given explicitly
15867:   if (localeName.IsEmpty()) {
15867:     nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
15867:     NS_ENSURE_SUCCESS(rv, rv);
15867:     nsCString cLocaleName;
15867:     rv = prefs->GetCharPref("general.useragent.locale", getter_Copies(cLocaleName));
15867:     CopyUTF8toUTF16(cLocaleName, localeName);
15867:   }
    1:   // get locale service
    1:   nsCOMPtr<nsILocaleService> localeService(do_GetService(kLocaleServiceCID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // get locale
    1:   rv = localeService->NewLocale(localeName, getter_AddRefs(locale));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDateTimeFormat> dateTimeFormat(do_CreateInstance(kDateTimeFormatCID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   tm tmTime;
    1:   time_t timetTime;
    1: 
    1:   memset(&tmTime, 0, sizeof(tmTime));
    1:   tmTime.tm_year = year - 1900;
    1:   tmTime.tm_mon = month - 1;
    1:   tmTime.tm_mday = day;
    1:   tmTime.tm_hour = hour;
    1:   tmTime.tm_min = minute;
    1:   tmTime.tm_sec = second;
    1:   tmTime.tm_yday = tmTime.tm_wday = 0;
    1:   tmTime.tm_isdst = -1;
    1:   timetTime = mktime(&tmTime);
    1: 
    1:   if ((time_t)-1 != timetTime) {
    1:     rv = dateTimeFormat->FormatTime(locale, dateFormatSelector, timeFormatSelector, 
    1:                                      timetTime, mStringOut);
    1:   }
    1:   else {
    1:     // if mktime fails (e.g. year <= 1970), then try NSPR.
    1:     PRTime prtime;
    1:     char string[32];
    1:     sprintf(string, "%.2d/%.2d/%d %.2d:%.2d:%.2d", month, day, year, hour, minute, second);
    1:     if (PR_SUCCESS != PR_ParseTimeString(string, PR_FALSE, &prtime))
    1:       return NS_ERROR_INVALID_ARG;
    1: 
    1:     rv = dateTimeFormat->FormatPRTime(locale, dateFormatSelector, timeFormatSelector, 
    1:                                       prtime, mStringOut);
    1:   }
    1:   if (NS_SUCCEEDED(rv))
    1:     *dateTimeString = ToNewUnicode(mStringOut);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: NS_NewScriptableDateFormat(nsISupports* aOuter, REFNSIID aIID, void** aResult)
    1: {
    1:   if (aOuter)
    1:     return NS_ERROR_NO_AGGREGATION;
    1: 
    1:   nsScriptableDateFormat* result = new nsScriptableDateFormat();
    1:   if (! result)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(result);
    1:   nsresult rv = result->QueryInterface(aIID, aResult);
    1:   NS_RELEASE(result);
    1: 
    1:   return rv;
    1: }
