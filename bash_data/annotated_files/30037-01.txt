29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set sw=4 ts=8 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS array class.
11835:  *
25888:  * Array objects begin as "dense" arrays, optimized for index-only property
11835:  * access over a vector of slots (obj->dslots) with high load factor.  Array
11835:  * methods optimize for denseness by testing that the object's class is
11835:  * &js_ArrayClass, and can then directly manipulate the slots for efficiency.
11835:  *
11835:  * We track these pieces of metadata for arrays in dense mode:
11835:  *  - the array's length property as a uint32, in JSSLOT_ARRAY_LENGTH,
11835:  *  - the number of indices that are filled (non-holes), in JSSLOT_ARRAY_COUNT,
25475:  *  - the net number of slots starting at dslots (capacity), in dslots[-1] if
11835:  *    dslots is non-NULL.
11835:  *
11835:  * In dense mode, holes in the array are represented by JSVAL_HOLE.  The final
27483:  * slot in fslots is unused.
11835:  *
28242:  * NB: the capacity and length of a dense array are entirely unrelated!  The
28242:  * length may be greater than, less than, or equal to the capacity.  See
28242:  * array_length_setter for an explanation of how the first, most surprising
28242:  * case may occur.
28242:  *
11835:  * Arrays are converted to use js_SlowArrayClass when any of these conditions
11835:  * are met:
25475:  *  - the load factor (COUNT / capacity) is less than 0.25, and there are
11835:  *    more than MIN_SPARSE_INDEX slots total
25888:  *  - a property is set that is not indexed (and not "length"); or
25475:  *  - a property is defined that has non-default property attributes.
11835:  *
25475:  * Dense arrays do not track property creation order, so unlike other native
25475:  * objects and slow arrays, enumerating an array does not necessarily visit the
25475:  * properties in the order they were created.  We could instead maintain the
25475:  * scope to track property enumeration order, but still use the fast slot
25475:  * access.  That would have the same memory cost as just using a
25475:  * js_SlowArrayClass, but have the same performance characteristics as a dense
25475:  * array for slot accesses, at some cost in code complexity.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
11835: #include "jsbit.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
11835: #include "jsdbgapi.h" /* for js_TraceWatchPoints */
 8439: #include "jsdtoa.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
11835: #include "jsscope.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
30023: #include "jsvector.h"
    1: 
    1: /* 2^32 - 1 as a number and a string */
    1: #define MAXINDEX 4294967295u
    1: #define MAXSTR   "4294967295"
    1: 
11835: /* Small arrays are dense, no matter what. */
25626: #define MIN_SPARSE_INDEX 256
11835: 
27543: static inline bool
27543: INDEX_TOO_BIG(jsuint index)
27543: {
27543:     return index > JS_BIT(29) - 1;
27543: }
27543: 
11835: #define INDEX_TOO_SPARSE(array, index)                                         \
11835:     (INDEX_TOO_BIG(index) ||                                                   \
25475:      ((index) > js_DenseArrayCapacity(array) && (index) >= MIN_SPARSE_INDEX && \
12231:       (index) > (uint32)((array)->fslots[JSSLOT_ARRAY_COUNT] + 1) * 4))
11835: 
11835: JS_STATIC_ASSERT(sizeof(JSScopeProperty) > 4 * sizeof(jsval));
11835: 
11835: #define ENSURE_SLOW_ARRAY(cx, obj)                                             \
15602:     (OBJ_GET_CLASS(cx, obj) == &js_SlowArrayClass || js_MakeArraySlow(cx, obj))
11835: 
    1: /*
    1:  * Determine if the id represents an array index or an XML property index.
    1:  *
    1:  * An id is an array index according to ECMA by (15.4):
    1:  *
    1:  * "Array objects give special treatment to a certain class of property names.
    1:  * A property name P (in the form of a string value) is an array index if and
    1:  * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    1:  * to 2^32-1."
    1:  *
    1:  * In our implementation, it would be sufficient to check for JSVAL_IS_INT(id)
    1:  * except that by using signed 32-bit integers we miss the top half of the
    1:  * valid range. This function checks the string representation itself; note
    1:  * that calling a standard conversion routine might allow strings such as
    1:  * "08" or "4.0" as array indices, which they are not.
    1:  */
    1: JSBool
    1: js_IdIsIndex(jsval id, jsuint *indexp)
    1: {
    1:     JSString *str;
    1:     jschar *cp;
    1: 
    1:     if (JSVAL_IS_INT(id)) {
    1:         jsint i;
    1:         i = JSVAL_TO_INT(id);
    1:         if (i < 0)
    1:             return JS_FALSE;
    1:         *indexp = (jsuint)i;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /* NB: id should be a string, but jsxml.c may call us with an object id. */
    1:     if (!JSVAL_IS_STRING(id))
    1:         return JS_FALSE;
    1: 
    1:     str = JSVAL_TO_STRING(id);
29366:     cp = str->chars();
29366:     if (JS7_ISDEC(*cp) && str->length() < sizeof(MAXSTR)) {
    1:         jsuint index = JS7_UNDEC(*cp++);
    1:         jsuint oldIndex = 0;
    1:         jsuint c = 0;
    1:         if (index != 0) {
    1:             while (JS7_ISDEC(*cp)) {
    1:                 oldIndex = index;
    1:                 c = JS7_UNDEC(*cp);
    1:                 index = 10*index + c;
    1:                 cp++;
    1:             }
    1:         }
    1: 
    1:         /* Ensure that all characters were consumed and we didn't overflow. */
    1:         if (*cp == 0 &&
    1:              (oldIndex < (MAXINDEX / 10) ||
    1:               (oldIndex == (MAXINDEX / 10) && c < (MAXINDEX % 10))))
    1:         {
    1:             *indexp = index;
    1:             return JS_TRUE;
    1:         }
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
12694: static jsuint
12694: ValueIsLength(JSContext *cx, jsval* vp)
    1: {
    1:     jsint i;
    1:     jsdouble d;
12694:     jsuint length;
12694: 
12694:     if (JSVAL_IS_INT(*vp)) {
12694:         i = JSVAL_TO_INT(*vp);
12694:         if (i < 0)
12694:             goto error;
12694:         return (jsuint) i;
12694:     }
12694: 
12694:     d = js_ValueToNumber(cx, vp);
12694:     if (JSVAL_IS_NULL(*vp))
12694:         goto error;
12694: 
12694:     if (JSDOUBLE_IS_NaN(d))
12694:         goto error;
12694:     length = (jsuint) d;
12694:     if (d != (jsdouble) length)
12694:         goto error;
12694:     return length;
12694: 
12694:   error:
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                          JSMSG_BAD_ARRAY_LENGTH);
12694:     *vp = JSVAL_NULL;
12694:     return 0;
    1: }
    1: 
    1: JSBool
    1: js_GetLengthProperty(JSContext *cx, JSObject *obj, jsuint *lengthp)
    1: {
11835:     if (OBJ_IS_ARRAY(cx, obj)) {
12231:         *lengthp = obj->fslots[JSSLOT_ARRAY_LENGTH];
11835:         return JS_TRUE;
11835:     }
11835: 
28839:     JSAutoTempValueRooter tvr(cx, JSVAL_NULL);
28839:     if (!OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom), tvr.addr()))
28839:         return JS_FALSE;
28839: 
28839:     if (JSVAL_IS_INT(tvr.value())) {
28839:         *lengthp = jsuint(jsint(JSVAL_TO_INT(tvr.value()))); /* jsuint cast does ToUint32 */
28839:         return JS_TRUE;
28839:     }
28839: 
28839:     *lengthp = js_ValueToECMAUint32(cx, tvr.addr());
28839:     return !JSVAL_IS_NULL(tvr.value());
    1: }
    1: 
    1: static JSBool
26564: IndexToValue(JSContext *cx, jsdouble index, jsval *vp)
    1: {
26564:     return js_NewWeaklyRootedNumber(cx, index, vp);
    1: }
    1: 
19545: JSBool JS_FASTCALL
19545: js_IndexToId(JSContext *cx, jsuint index, jsid *idp)
12479: {
12479:     JSString *str;
12479: 
12479:     if (index <= JSVAL_INT_MAX) {
12479:         *idp = INT_TO_JSID(index);
12479:         return JS_TRUE;
12479:     }
12479:     str = js_NumberToString(cx, index);
12479:     if (!str)
12479:         return JS_FALSE;
12479:     return js_ValueToStringId(cx, STRING_TO_JSVAL(str), idp);
    1: }
    1: 
    1: static JSBool
    1: BigIndexToId(JSContext *cx, JSObject *obj, jsuint index, JSBool createAtom,
    1:              jsid *idp)
    1: {
    1:     jschar buf[10], *start;
    1:     JSClass *clasp;
    1:     JSAtom *atom;
    1:     JS_STATIC_ASSERT((jsuint)-1 == 4294967295U);
    1: 
    1:     JS_ASSERT(index > JSVAL_INT_MAX);
    1: 
    1:     start = JS_ARRAY_END(buf);
    1:     do {
    1:         --start;
    1:         *start = (jschar)('0' + index % 10);
    1:         index /= 10;
    1:     } while (index != 0);
    1: 
    1:     /*
    1:      * Skip the atomization if the class is known to store atoms corresponding
    1:      * to big indexes together with elements. In such case we know that the
    1:      * array does not have an element at the given index if its atom does not
11835:      * exist.  Fast arrays (clasp == &js_ArrayClass) don't use atoms for
11835:      * any indexes, though it would be rare to see them have a big index
11835:      * in any case.
    1:      */
    1:     if (!createAtom &&
11835:         ((clasp = OBJ_GET_CLASS(cx, obj)) == &js_SlowArrayClass ||
    1:          clasp == &js_ArgumentsClass ||
    1:          clasp == &js_ObjectClass)) {
    1:         atom = js_GetExistingStringAtom(cx, start, JS_ARRAY_END(buf) - start);
    1:         if (!atom) {
    1:             *idp = JSVAL_VOID;
    1:             return JS_TRUE;
    1:         }
    1:     } else {
    1:         atom = js_AtomizeChars(cx, start, JS_ARRAY_END(buf) - start, 0);
    1:         if (!atom)
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     *idp = ATOM_TO_JSID(atom);
    1:     return JS_TRUE;
    1: }
    1: 
11835: static JSBool
25475: ResizeSlots(JSContext *cx, JSObject *obj, uint32 oldsize, uint32 size)
11835: {
11835:     jsval *slots, *newslots;
11835: 
25475:     if (size == 0) {
11835:         if (obj->dslots) {
11835:             JS_free(cx, obj->dslots - 1);
11835:             obj->dslots = NULL;
11835:         }
11835:         return JS_TRUE;
11835:     }
11835: 
27891:     /*
27891:      * MAX_DSLOTS_LENGTH is the maximum net capacity supported. Since we allocate
27891:      * one additional slot to hold the array length, we have to use >= here.
27891:      */
27891:     if (size >= MAX_DSLOTS_LENGTH) {
12983:         js_ReportAllocationOverflow(cx);
11835:         return JS_FALSE;
11835:     }
11835: 
11835:     slots = obj->dslots ? obj->dslots - 1 : NULL;
27891:     newslots = (jsval *) JS_realloc(cx, slots, (size + 1) * sizeof(jsval));
11835:     if (!newslots)
11835:         return JS_FALSE;
11835: 
11835:     obj->dslots = newslots + 1;
25475:     js_SetDenseArrayCapacity(obj, size);
25475: 
25475:     for (slots = obj->dslots + oldsize; slots < obj->dslots + size; slots++)
11835:         *slots = JSVAL_HOLE;
11835: 
11835:     return JS_TRUE;
11835: }
11835: 
25488: /*
25488:  * When a dense array with CAPACITY_DOUBLING_MAX or fewer slots needs to grow,
25488:  * double its capacity, to push() N elements in amortized O(N) time.
25488:  *
25488:  * Above this limit, grow by 12.5% each time. Speed is still amortized O(N),
25488:  * with a higher constant factor, and we waste less space.
25488:  */
25488: #define CAPACITY_DOUBLING_MAX    (1024 * 1024)
25488: 
25488: /*
25488:  * Round up all large allocations to a multiple of this (1MB), so as not to
25488:  * waste space if malloc gives us 1MB-sized chunks (as jemalloc does).
25488:  */
25488: #define CAPACITY_CHUNK  (1024 * 1024 / sizeof(jsval))
25488: 
11835: static JSBool
25488: EnsureCapacity(JSContext *cx, JSObject *obj, uint32 capacity)
11835: {
25488:     uint32 oldsize = js_DenseArrayCapacity(obj);
25488: 
25488:     if (capacity > oldsize) {
25488:         /*
25488:          * If this overflows uint32, capacity is very large. nextsize will end
25488:          * up being less than capacity, the code below will thus disregard it,
25488:          * and ResizeSlots will fail.
25488:          *
25488:          * The way we use dslots[-1] forces a few +1s and -1s here. For
25488:          * example, (oldsize * 2 + 1) produces the sequence 7, 15, 31, 63, ...
25488:          * which makes the total allocation size (with dslots[-1]) a power
25488:          * of two.
25488:          */
25488:         uint32 nextsize = (oldsize <= CAPACITY_DOUBLING_MAX)
25488:                           ? oldsize * 2 + 1
25488:                           : oldsize + (oldsize >> 3);
25488: 
25488:         capacity = JS_MAX(capacity, nextsize);
25488:         if (capacity >= CAPACITY_CHUNK)
25488:             capacity = JS_ROUNDUP(capacity + 1, CAPACITY_CHUNK) - 1;  /* -1 for dslots[-1] */
25488:         else if (capacity < ARRAY_CAPACITY_MIN)
25488:             capacity = ARRAY_CAPACITY_MIN;
25488:         return ResizeSlots(cx, obj, oldsize, capacity);
11835:     }
11835:     return JS_TRUE;
11835: }
11835: 
26564: static bool
26564: ReallyBigIndexToId(JSContext* cx, jsdouble index, jsid* idp)
26564: {
26564:     JSAutoTempValueRooter dval(cx);
26564:     if (!js_NewDoubleInRootedValue(cx, index, dval.addr()) ||
26564:         !js_ValueToStringId(cx, dval.value(), idp)) {
26564:         return JS_FALSE;
26564:     }
26564:     return JS_TRUE;
26564: }
26564: 
26564: static bool
26564: IndexToId(JSContext* cx, JSObject* obj, jsdouble index, JSBool* hole, jsid* idp,
26564:           JSBool createAtom = JS_FALSE)
26564: {
26564:     if (index <= JSVAL_INT_MAX) {
26564:         *idp = INT_TO_JSID(index);
26564:         return JS_TRUE;
26564:     }
26564: 
26564:     if (index <= jsuint(-1)) {
26564:         if (!BigIndexToId(cx, obj, jsuint(index), createAtom, idp))
26564:             return JS_FALSE;
26564:         if (hole && JSVAL_IS_VOID(*idp))
26564:             *hole = JS_TRUE;
26564:         return JS_TRUE;
26564:     }
26564: 
26564:     return ReallyBigIndexToId(cx, index, idp);
26564: }
26564: 
    1: /*
    1:  * If the property at the given index exists, get its value into location
    1:  * pointed by vp and set *hole to false. Otherwise set *hole to true and *vp
    1:  * to JSVAL_VOID. This function assumes that the location pointed by vp is
    1:  * properly rooted and can be used as GC-protected storage for temporaries.
    1:  */
    1: static JSBool
26564: GetArrayElement(JSContext *cx, JSObject *obj, jsdouble index, JSBool *hole,
    1:                 jsval *vp)
    1: {
26564:     JS_ASSERT(index >= 0);
26564:     if (OBJ_IS_DENSE_ARRAY(cx, obj) && index < js_DenseArrayCapacity(obj) &&
26564:         (*vp = obj->dslots[jsuint(index)]) != JSVAL_HOLE) {
26564:         *hole = JS_FALSE;
26564:         return JS_TRUE;
26564:     }
26564: 
26564:     JSAutoTempIdRooter idr(cx);
26564: 
26564:     *hole = JS_FALSE;
26564:     if (!IndexToId(cx, obj, index, hole, idr.addr()))
26564:         return JS_FALSE;
26564:     if (*hole) {
26564:         *vp = JSVAL_VOID;
26564:         return JS_TRUE;
26564:     }
26564: 
    1:     JSObject *obj2;
    1:     JSProperty *prop;
26564:     if (!OBJ_LOOKUP_PROPERTY(cx, obj, idr.id(), &obj2, &prop))
    1:         return JS_FALSE;
    1:     if (!prop) {
    1:         *hole = JS_TRUE;
    1:         *vp = JSVAL_VOID;
    1:     } else {
    1:         OBJ_DROP_PROPERTY(cx, obj2, prop);
26564:         if (!OBJ_GET_PROPERTY(cx, obj, idr.id(), vp))
    1:             return JS_FALSE;
    1:         *hole = JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Set the value of the property at the given index to v assuming v is rooted.
    1:  */
    1: static JSBool
26564: SetArrayElement(JSContext *cx, JSObject *obj, jsdouble index, jsval v)
    1: {
26564:     JS_ASSERT(index >= 0);
    1: 
11848:     if (OBJ_IS_DENSE_ARRAY(cx, obj)) {
26564:         /* Predicted/prefetched code should favor the remains-dense case. */
26564:         if (index <= jsuint(-1)) {
26564:             jsuint idx = jsuint(index);
26564:             if (!INDEX_TOO_SPARSE(obj, idx)) {
26564:                 JS_ASSERT(idx + 1 > idx);
26564:                 if (!EnsureCapacity(cx, obj, idx + 1))
11835:                     return JS_FALSE;
28242:                 if (idx >= uint32(obj->fslots[JSSLOT_ARRAY_LENGTH]))
26564:                     obj->fslots[JSSLOT_ARRAY_LENGTH] = idx + 1;
26564:                 if (obj->dslots[idx] == JSVAL_HOLE)
12231:                     obj->fslots[JSSLOT_ARRAY_COUNT]++;
26564:                 obj->dslots[idx] = v;
11835:                 return JS_TRUE;
11835:             }
26564:         }
18712: 
18712:         if (!js_MakeArraySlow(cx, obj))
18712:             return JS_FALSE;
11835:     }
11835: 
26564:     JSAutoTempIdRooter idr(cx);
26564: 
26564:     if (!IndexToId(cx, obj, index, NULL, idr.addr(), JS_TRUE))
    1:         return JS_FALSE;
26564:     JS_ASSERT(!JSVAL_IS_VOID(idr.id()));
26564: 
26564:     return OBJ_SET_PROPERTY(cx, obj, idr.id(), &v);
    1: }
    1: 
    1: static JSBool
26564: DeleteArrayElement(JSContext *cx, JSObject *obj, jsdouble index)
    1: {
26564:     JS_ASSERT(index >= 0);
26564:     if (OBJ_IS_DENSE_ARRAY(cx, obj)) {
26564:         if (index <= jsuint(-1)) {
26564:             jsuint idx = jsuint(index);
26564:             if (!INDEX_TOO_SPARSE(obj, idx) && idx < js_DenseArrayCapacity(obj)) {
26564:                 if (obj->dslots[idx] != JSVAL_HOLE)
26564:                     obj->fslots[JSSLOT_ARRAY_COUNT]--;
26564:                 obj->dslots[idx] = JSVAL_HOLE;
26564:                 return JS_TRUE;
26564:             }
26564:         }
26564:         return JS_TRUE;
26564:     }
26564: 
26564:     JSAutoTempIdRooter idr(cx);
26564: 
26564:     if (!IndexToId(cx, obj, index, NULL, idr.addr()))
26564:         return JS_FALSE;
26564:     if (JSVAL_IS_VOID(idr.id()))
26564:         return JS_TRUE;
26564: 
    1:     jsval junk;
26564:     return OBJ_DELETE_PROPERTY(cx, obj, idr.id(), &junk);
    1: }
    1: 
    1: /*
    1:  * When hole is true, delete the property at the given index. Otherwise set
    1:  * its value to v assuming v is rooted.
    1:  */
    1: static JSBool
26564: SetOrDeleteArrayElement(JSContext *cx, JSObject *obj, jsdouble index,
    1:                         JSBool hole, jsval v)
    1: {
    1:     if (hole) {
15521:         JS_ASSERT(JSVAL_IS_VOID(v));
    1:         return DeleteArrayElement(cx, obj, index);
11835:     }
    1:     return SetArrayElement(cx, obj, index, v);
    1: }
    1: 
    1: JSBool
26564: js_SetLengthProperty(JSContext *cx, JSObject *obj, jsdouble length)
    1: {
    1:     jsval v;
    1:     jsid id;
    1: 
    1:     if (!IndexToValue(cx, length, &v))
    1:         return JS_FALSE;
    1:     id = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
    1:     return OBJ_SET_PROPERTY(cx, obj, id, &v);
    1: }
    1: 
    1: JSBool
    1: js_HasLengthProperty(JSContext *cx, JSObject *obj, jsuint *lengthp)
    1: {
    1:     JSErrorReporter older;
    1:     JSTempValueRooter tvr;
    1:     jsid id;
    1:     JSBool ok;
    1: 
    1:     older = JS_SetErrorReporter(cx, NULL);
    1:     JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &tvr);
    1:     id = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
    1:     ok = OBJ_GET_PROPERTY(cx, obj, id, &tvr.u.value);
    1:     JS_SetErrorReporter(cx, older);
12694:     if (ok) {
12694:         *lengthp = ValueIsLength(cx, &tvr.u.value);
12694:         ok = !JSVAL_IS_NULL(tvr.u.value);
12694:     }
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_IsArrayLike(JSContext *cx, JSObject *obj, JSBool *answerp, jsuint *lengthp)
    1: {
    1:     JSClass *clasp;
    1: 
    1:     clasp = OBJ_GET_CLASS(cx, obj);
11835:     *answerp = (clasp == &js_ArgumentsClass || clasp == &js_ArrayClass ||
11835:                 clasp == &js_SlowArrayClass);
    1:     if (!*answerp) {
    1:         *lengthp = 0;
    1:         return JS_TRUE;
    1:     }
    1:     return js_GetLengthProperty(cx, obj, lengthp);
    1: }
    1: 
    1: /*
 4127:  * The 'length' property of all native Array instances is a shared permanent
 4127:  * property of Array.prototype, so it appears to be a direct property of each
 4127:  * array instance delegating to that Array.prototype. It accesses the private
 4127:  * slot reserved by js_ArrayClass.
 4182:  *
 4182:  * Since SpiderMonkey supports cross-class prototype-based delegation, we have
 4182:  * to be careful about the length getter and setter being called on an object
 4182:  * not of Array class. For the getter, we search obj's prototype chain for the
 4182:  * array that caused this getter to be invoked. In the setter case to overcome
 4182:  * the JSPROP_SHARED attribute, we must define a shadowing length property.
    1:  */
    1: static JSBool
    1: array_length_getter(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
 4182:     do {
11835:         if (OBJ_IS_ARRAY(cx, obj))
12231:             return IndexToValue(cx, obj->fslots[JSSLOT_ARRAY_LENGTH], vp);
 4182:     } while ((obj = OBJ_GET_PROTO(cx, obj)) != NULL);
 4127:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: array_length_setter(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsuint newlen, oldlen, gap, index;
    1:     jsval junk;
    1:     JSObject *iter;
    1:     JSTempValueRooter tvr;
    1:     JSBool ok;
    1: 
11835:     if (!OBJ_IS_ARRAY(cx, obj)) {
 4182:         jsid lengthId = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
 4182: 
 4182:         return OBJ_DEFINE_PROPERTY(cx, obj, lengthId, *vp, NULL, NULL,
 4182:                                    JSPROP_ENUMERATE, NULL);
 4182:     }
 4182: 
12694:     newlen = ValueIsLength(cx, vp);
12694:     if (JSVAL_IS_NULL(*vp))
    1:         return JS_FALSE;
12231:     oldlen = obj->fslots[JSSLOT_ARRAY_LENGTH];
11835: 
11835:     if (oldlen == newlen)
11835:         return JS_TRUE;
11835: 
11835:     if (!IndexToValue(cx, newlen, vp))
    1:         return JS_FALSE;
11835: 
11835:     if (oldlen < newlen) {
12231:         obj->fslots[JSSLOT_ARRAY_LENGTH] = newlen;
11835:         return JS_TRUE;
11835:     }
11835: 
11848:     if (OBJ_IS_DENSE_ARRAY(cx, obj)) {
24302:         /* Don't reallocate if we're not actually shrinking our slots. */
25475:         jsuint oldsize = js_DenseArrayCapacity(obj);
24302:         if (oldsize >= newlen && !ResizeSlots(cx, obj, oldsize, newlen))
11835:             return JS_FALSE;
11835:     } else if (oldlen - newlen < (1 << 24)) {
    1:         do {
    1:             --oldlen;
25087:             if (!JS_CHECK_OPERATION_LIMIT(cx) ||
    1:                 !DeleteArrayElement(cx, obj, oldlen)) {
    1:                 return JS_FALSE;
    1:             }
    1:         } while (oldlen != newlen);
    1:     } else {
    1:         /*
    1:          * We are going to remove a lot of indexes in a presumably sparse
    1:          * array. So instead of looping through indexes between newlen and
    1:          * oldlen, we iterate through all properties and remove those that
11835:          * correspond to indexes in the half-open range [newlen, oldlen).  See
11835:          * bug 322135.
    1:          */
    1:         iter = JS_NewPropertyIterator(cx, obj);
    1:         if (!iter)
    1:             return JS_FALSE;
    1: 
    1:         /* Protect iter against GC in OBJ_DELETE_PROPERTY. */
    1:         JS_PUSH_TEMP_ROOT_OBJECT(cx, iter, &tvr);
    1:         gap = oldlen - newlen;
    1:         for (;;) {
25087:             ok = (JS_CHECK_OPERATION_LIMIT(cx) &&
 4127:                   JS_NextProperty(cx, iter, &id));
    1:             if (!ok)
    1:                 break;
15521:             if (JSVAL_IS_VOID(id))
    1:                 break;
 4127:             if (js_IdIsIndex(id, &index) && index - newlen < gap) {
 4127:                 ok = OBJ_DELETE_PROPERTY(cx, obj, id, &junk);
    1:                 if (!ok)
    1:                     break;
    1:             }
    1:         }
    1:         JS_POP_TEMP_ROOT(cx, &tvr);
    1:         if (!ok)
    1:             return JS_FALSE;
    1:     }
11835: 
12231:     obj->fslots[JSSLOT_ARRAY_LENGTH] = newlen;
 4127:     return JS_TRUE;
    1: }
    1: 
27483: /*
27483:  * We have only indexed properties up to capacity (excepting holes), plus the
27483:  * length property. For all else, we delegate to the prototype.
27483:  */
27483: static inline bool
27483: IsDenseArrayId(JSContext *cx, JSObject *obj, jsid id)
27483: {
27483:     JS_ASSERT(OBJ_IS_DENSE_ARRAY(cx, obj));
27483: 
27483:     uint32 i;
27483:     return id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom) ||
27483:            (js_IdIsIndex(id, &i) &&
27483:             obj->fslots[JSSLOT_ARRAY_LENGTH] != 0 &&
27483:             i < js_DenseArrayCapacity(obj) &&
27483:             obj->dslots[i] != JSVAL_HOLE);
27483: }
27483: 
    1: static JSBool
11835: array_lookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
11835:                      JSProperty **propp)
11835: {
11848:     if (!OBJ_IS_DENSE_ARRAY(cx, obj))
11835:         return js_LookupProperty(cx, obj, id, objp, propp);
11835: 
27483:     if (IsDenseArrayId(cx, obj, id)) {
27483:         *propp = (JSProperty *) id;
27483:         *objp = obj;
27483:         return JS_TRUE;
27483:     }
27483: 
11835:     JSObject *proto = STOBJ_GET_PROTO(obj);
11835:     if (!proto) {
11835:         *objp = NULL;
11835:         *propp = NULL;
11835:         return JS_TRUE;
    1:     }
11835:     return OBJ_LOOKUP_PROPERTY(cx, proto, id, objp, propp);
11835: }
11835: 
11835: static void
11835: array_dropProperty(JSContext *cx, JSObject *obj, JSProperty *prop)
11835: {
27483:     JS_ASSERT(IsDenseArrayId(cx, obj, (jsid) prop));
27483: }
27483: 
27483: JSBool
27483: js_GetDenseArrayElementValue(JSContext *cx, JSObject *obj, JSProperty *prop,
27483:                              jsval *vp)
26820: {
27483:     jsid id = (jsid) prop;
27483:     JS_ASSERT(IsDenseArrayId(cx, obj, id));
27483: 
27483:     uint32 i;
27483:     if (!js_IdIsIndex(id, &i)) {
27483:         JS_ASSERT(id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom));
27483:         return IndexToValue(cx, obj->fslots[JSSLOT_ARRAY_LENGTH], vp);
27483:     }
27483:     *vp = obj->dslots[i];
27483:     return JS_TRUE;
26820: }
26820: 
    1: static JSBool
11835: array_getProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
11835: {
11835:     uint32 i;
11835: 
11835:     if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom))
12231:         return IndexToValue(cx, obj->fslots[JSSLOT_ARRAY_LENGTH], vp);
11835: 
11835:     if (id == ATOM_TO_JSID(cx->runtime->atomState.protoAtom)) {
11835:         *vp = STOBJ_GET_SLOT(obj, JSSLOT_PROTO);
11835:         return JS_TRUE;
11835:     }
11835: 
11848:     if (!OBJ_IS_DENSE_ARRAY(cx, obj))
11835:         return js_GetProperty(cx, obj, id, vp);
11835: 
25475:     if (!js_IdIsIndex(ID_TO_VALUE(id), &i) || i >= js_DenseArrayCapacity(obj) ||
11835:         obj->dslots[i] == JSVAL_HOLE) {
15601:         JSObject *obj2;
15601:         JSProperty *prop;
15601:         JSScopeProperty *sprop;
15601: 
11835:         JSObject *proto = STOBJ_GET_PROTO(obj);
11835:         if (!proto) {
11835:             *vp = JSVAL_VOID;
11835:             return JS_TRUE;
11835:         }
11835: 
15601:         *vp = JSVAL_VOID;
19712:         if (js_LookupPropertyWithFlags(cx, proto, id, cx->resolveFlags,
19712:                                        &obj2, &prop) < 0)
15601:             return JS_FALSE;
15601: 
15601:         if (prop) {
15601:             if (OBJ_IS_NATIVE(obj2)) {
15601:                 sprop = (JSScopeProperty *) prop;
15601:                 if (!js_NativeGet(cx, obj, obj2, sprop, vp))
15601:                     return JS_FALSE;
27490:             }
15601:             OBJ_DROP_PROPERTY(cx, obj2, prop);
15601:         }
15601:         return JS_TRUE;
11835:     }
11835: 
11835:     *vp = obj->dslots[i];
11835:     return JS_TRUE;
11835: }
11835: 
11835: static JSBool
11835: slowarray_addProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsuint index, length;
    1: 
    1:     if (!js_IdIsIndex(id, &index))
    1:         return JS_TRUE;
12231:     length = obj->fslots[JSSLOT_ARRAY_LENGTH];
11835:     if (index >= length)
12231:         obj->fslots[JSSLOT_ARRAY_LENGTH] = index + 1;
    1:     return JS_TRUE;
    1: }
    1: 
11835: static void
11835: slowarray_trace(JSTracer *trc, JSObject *obj)
11835: {
12231:     uint32 length = obj->fslots[JSSLOT_ARRAY_LENGTH];
11835: 
11835:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_SlowArrayClass);
11835: 
11835:     /*
11835:      * Move JSSLOT_ARRAY_LENGTH aside to prevent the GC from treating
11835:      * untagged integer values as objects or strings.
11835:      */
12231:     obj->fslots[JSSLOT_ARRAY_LENGTH] = JSVAL_VOID;
11835:     js_TraceObject(trc, obj);
12231:     obj->fslots[JSSLOT_ARRAY_LENGTH] = length;
11835: }
11835: 
11835: static JSObjectOps js_SlowArrayObjectOps;
11835: 
11835: static JSObjectOps *
11835: slowarray_getObjectOps(JSContext *cx, JSClass *clasp)
11835: {
11835:     return &js_SlowArrayObjectOps;
11835: }
11835: 
    1: static JSBool
11835: array_setProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
11835:     uint32 i;
11835: 
11835:     if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom))
11835:         return array_length_setter(cx, obj, id, vp);
11835: 
11848:     if (!OBJ_IS_DENSE_ARRAY(cx, obj))
11835:         return js_SetProperty(cx, obj, id, vp);
11835: 
11835:     if (!js_IdIsIndex(id, &i) || INDEX_TOO_SPARSE(obj, i)) {
15602:         if (!js_MakeArraySlow(cx, obj))
    1:             return JS_FALSE;
11835:         return js_SetProperty(cx, obj, id, vp);
11835:     }
11835: 
25475:     if (!EnsureCapacity(cx, obj, i + 1))
11835:         return JS_FALSE;
11835: 
12231:     if (i >= (uint32)obj->fslots[JSSLOT_ARRAY_LENGTH])
12231:         obj->fslots[JSSLOT_ARRAY_LENGTH] = i + 1;
11835:     if (obj->dslots[i] == JSVAL_HOLE)
12231:         obj->fslots[JSSLOT_ARRAY_COUNT]++;
11835:     obj->dslots[i] = *vp;
11835:     return JS_TRUE;
11835: }
11835: 
25886: JSBool
25886: js_PrototypeHasIndexedProperties(JSContext *cx, JSObject *obj)
25883: {
25883:     /*
25888:      * Walk up the prototype chain and see if this indexed element already
25888:      * exists. If we hit the end of the prototype chain, it's safe to set the
25888:      * element on the original object.
25883:      */
25888:    while ((obj = JSVAL_TO_OBJECT(obj->fslots[JSSLOT_PROTO])) != NULL) {
25883:         /*
25888:          * If the prototype is a non-native object (possibly a dense array), or
25888:          * a native object (possibly a slow array) that has indexed properties,
25888:          * return true.
25883:          */
25888:         if (!OBJ_IS_NATIVE(obj))
25888:             return JS_TRUE;
25888:         if (SCOPE_HAS_INDEXED_PROPERTIES(OBJ_SCOPE(obj)))
25883:             return JS_TRUE;
25883:     }
25883:     return JS_FALSE;
25883: }
25883: 
20408: #ifdef JS_TRACER
20408: JSBool FASTCALL
20408: js_Array_dense_setelem(JSContext* cx, JSObject* obj, jsint i, jsval v)
20408: {
20408:     JS_ASSERT(OBJ_IS_DENSE_ARRAY(cx, obj));
20408: 
25629:     /*
25629:      * Let the interpreter worry about negative array indexes.
25629:      */
27891:     JS_ASSERT((MAX_DSLOTS_LENGTH > JSVAL_INT_MAX) == (sizeof(jsval) != sizeof(uint32)));
27892:     if (MAX_DSLOTS_LENGTH > JSVAL_INT_MAX) {
27891:         /*
27891:          * Have to check for negative values bleeding through on 64-bit machines only,
27891:          * since we can't allocate large enough arrays for this on 32-bit machines.
27891:          */
25629:         if (i < 0)
25629:             return JS_FALSE;
27891:     }
25629: 
25629:     /*
25629:      * If needed, grow the array as long it remains dense, otherwise fall off trace.
25629:      */
25629:     jsuint u = jsuint(i);
25475:     jsuint capacity = js_DenseArrayCapacity(obj);
25629:     if ((u >= capacity) && (INDEX_TOO_SPARSE(obj, u) || !EnsureCapacity(cx, obj, u + 1)))
25629:         return JS_FALSE;
25629: 
25629:     if (obj->dslots[u] == JSVAL_HOLE) {
25886:         if (js_PrototypeHasIndexedProperties(cx, obj))
25629:             return JS_FALSE;
25883: 
25629:         if (u >= jsuint(obj->fslots[JSSLOT_ARRAY_LENGTH]))
25629:             obj->fslots[JSSLOT_ARRAY_LENGTH] = u + 1;
25629:         ++obj->fslots[JSSLOT_ARRAY_COUNT];
20408:     }
25629: 
25629:     obj->dslots[u] = v;
20408:     return JS_TRUE;
20408: }
28088: JS_DEFINE_CALLINFO_4(extern, BOOL, js_Array_dense_setelem, CONTEXT, OBJECT, INT32, JSVAL, 0, 0)
20408: #endif
20408: 
11835: static JSBool
11835: array_defineProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
11835:                      JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
11835:                      JSProperty **propp)
11835: {
11835:     uint32 i;
20404:     JSBool isIndex;
11835: 
11835:     if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom))
11835:         return JS_TRUE;
11835: 
20404:     isIndex = js_IdIsIndex(ID_TO_VALUE(id), &i);
20404:     if (!isIndex || attrs != JSPROP_ENUMERATE) {
11835:         if (!ENSURE_SLOW_ARRAY(cx, obj))
11835:             return JS_FALSE;
20404:         return js_DefineProperty(cx, obj, id, value, getter, setter, attrs, propp);
11835:     }
11835: 
11835:     return array_setProperty(cx, obj, id, &value);
11835: }
11835: 
11835: static JSBool
11835: array_getAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
11835:                     uintN *attrsp)
11835: {
11835:     *attrsp = id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)
11835:         ? JSPROP_PERMANENT : JSPROP_ENUMERATE;
11835:     return JS_TRUE;
11835: }
11835: 
11835: static JSBool
11835: array_setAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
11835:                     uintN *attrsp)
11835: {
11835:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
11835:                          JSMSG_CANT_SET_ARRAY_ATTRS);
11835:     return JS_FALSE;
11835: }
11835: 
11835: static JSBool
11835: array_deleteProperty(JSContext *cx, JSObject *obj, jsval id, jsval *rval)
11835: {
11835:     uint32 i;
11835: 
11848:     if (!OBJ_IS_DENSE_ARRAY(cx, obj))
11835:         return js_DeleteProperty(cx, obj, id, rval);
11835: 
11835:     if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)) {
11835:         *rval = JSVAL_FALSE;
11835:         return JS_TRUE;
11835:     }
11835: 
25475:     if (js_IdIsIndex(id, &i) && i < js_DenseArrayCapacity(obj) &&
11835:         obj->dslots[i] != JSVAL_HOLE) {
12231:         obj->fslots[JSSLOT_ARRAY_COUNT]--;
11835:         obj->dslots[i] = JSVAL_HOLE;
11835:     }
11835: 
11835:     *rval = JSVAL_TRUE;
11835:     return JS_TRUE;
11835: }
11835: 
12479: /*
12479:  * JSObjectOps.enumerate implementation.
12479:  *
12479:  * For a fast array, JSENUMERATE_INIT captures in the enumeration state both
12479:  * the length of the array and the bitmap indicating the positions of holes in
12479:  * the array. This ensures that adding or deleting array elements does not
12479:  * affect the sequence of indexes JSENUMERATE_NEXT returns.
12479:  *
12479:  * For a common case of an array without holes, to represent the state we pack
12479:  * the (nextEnumerationIndex, arrayLength) pair as a pseudo-boolean jsval.
12479:  * This is possible when length <= PACKED_UINT_PAIR_BITS. For arrays with
12479:  * greater length or holes we allocate the JSIndexIterState structure and
12479:  * store it as an int-tagged private pointer jsval. For a slow array we
12479:  * delegate the enumeration implementation to js_Enumerate in
12479:  * slowarray_enumerate.
12479:  *
12479:  * Array mutations can turn a fast array into a slow one after the enumeration
12479:  * starts. When this happens, slowarray_enumerate receives a state created
12479:  * when the array was fast. To distinguish such fast state from a slow state,
12479:  * which is an int-tagged pointer that js_Enumerate creates, we set not one
12479:  * but two lowest bits when tagging a JSIndexIterState pointer -- see
12479:  * INDEX_ITER_TAG usage below. Thus, when slowarray_enumerate receives a state
12479:  * tagged with JSVAL_BOOLEAN or with two lowest bits set, it knows that this
12479:  * is a fast state so it calls array_enumerate to continue enumerating the
12479:  * indexes present in the original fast array.
12479:  */
12479: 
12479: #define PACKED_UINT_PAIR_BITS           14
12479: #define PACKED_UINT_PAIR_MASK           JS_BITMASK(PACKED_UINT_PAIR_BITS)
12479: 
12479: #define UINT_PAIR_TO_BOOLEAN_JSVAL(i,j)                                       \
12479:     (JS_ASSERT((uint32) (i) <= PACKED_UINT_PAIR_MASK),                        \
12479:      JS_ASSERT((uint32) (j) <= PACKED_UINT_PAIR_MASK),                        \
12479:      ((jsval) (i) << (PACKED_UINT_PAIR_BITS + JSVAL_TAGBITS)) |               \
12479:      ((jsval) (j) << (JSVAL_TAGBITS)) |                                       \
12479:      (jsval) JSVAL_BOOLEAN)
12479: 
12479: #define BOOLEAN_JSVAL_TO_UINT_PAIR(v,i,j)                                     \
12479:     (JS_ASSERT(JSVAL_TAG(v) == JSVAL_BOOLEAN),                                \
12479:      (i) = (uint32) ((v) >> (PACKED_UINT_PAIR_BITS + JSVAL_TAGBITS)),         \
12479:      (j) = (uint32) ((v) >> JSVAL_TAGBITS) & PACKED_UINT_PAIR_MASK,           \
12479:      JS_ASSERT((i) <= PACKED_UINT_PAIR_MASK))
12479: 
12479: JS_STATIC_ASSERT(PACKED_UINT_PAIR_BITS * 2 + JSVAL_TAGBITS <= JS_BITS_PER_WORD);
12479: 
12479: typedef struct JSIndexIterState {
12479:     uint32          index;
12479:     uint32          length;
12479:     JSBool          hasHoles;
12479: 
12479:     /*
12479:      * Variable-length bitmap representing array's holes. It must not be
12479:      * accessed when hasHoles is false.
12479:      */
12479:     jsbitmap        holes[1];
12479: } JSIndexIterState;
12479: 
12479: #define INDEX_ITER_TAG      3
12479: 
12479: JS_STATIC_ASSERT(JSVAL_INT == 1);
12479: 
12479: static JSBool
12479: array_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
12479:                 jsval *statep, jsid *idp)
12479: {
25475:     uint32 capacity, i;
12479:     JSIndexIterState *ii;
12479: 
12479:     switch (enum_op) {
12479:       case JSENUMERATE_INIT:
12479:         JS_ASSERT(OBJ_IS_DENSE_ARRAY(cx, obj));
25475:         capacity = js_DenseArrayCapacity(obj);
15531:         if (idp)
15531:             *idp = INT_TO_JSVAL(obj->fslots[JSSLOT_ARRAY_COUNT]);
12479:         ii = NULL;
25475:         for (i = 0; i != capacity; ++i) {
12479:             if (obj->dslots[i] == JSVAL_HOLE) {
12479:                 if (!ii) {
12479:                     ii = (JSIndexIterState *)
12479:                          JS_malloc(cx, offsetof(JSIndexIterState, holes) +
25475:                                    JS_BITMAP_SIZE(capacity));
12479:                     if (!ii)
12479:                         return JS_FALSE;
12479:                     ii->hasHoles = JS_TRUE;
25475:                     memset(ii->holes, 0, JS_BITMAP_SIZE(capacity));
12479:                 }
12479:                 JS_SET_BIT(ii->holes, i);
12479:             }
12479:         }
12479:         if (!ii) {
12479:             /* Array has no holes. */
25475:             if (capacity <= PACKED_UINT_PAIR_MASK) {
25475:                 *statep = UINT_PAIR_TO_BOOLEAN_JSVAL(0, capacity);
12479:                 break;
12479:             }
12479:             ii = (JSIndexIterState *)
12479:                  JS_malloc(cx, offsetof(JSIndexIterState, holes));
12479:             if (!ii)
12479:                 return JS_FALSE;
12479:             ii->hasHoles = JS_FALSE;
12479:         }
12479:         ii->index = 0;
25475:         ii->length = capacity;
12479:         *statep = (jsval) ii | INDEX_ITER_TAG;
12479:         JS_ASSERT(*statep & JSVAL_INT);
12479:         break;
12479: 
12479:       case JSENUMERATE_NEXT:
12479:         if (JSVAL_TAG(*statep) == JSVAL_BOOLEAN) {
25475:             BOOLEAN_JSVAL_TO_UINT_PAIR(*statep, i, capacity);
25475:             if (i != capacity) {
12479:                 *idp = INT_TO_JSID(i);
25475:                 *statep = UINT_PAIR_TO_BOOLEAN_JSVAL(i + 1, capacity);
12479:                 break;
12479:             }
12479:         } else {
12479:             JS_ASSERT((*statep & INDEX_ITER_TAG) == INDEX_ITER_TAG);
12479:             ii = (JSIndexIterState *) (*statep & ~INDEX_ITER_TAG);
12479:             i = ii->index;
12479:             if (i != ii->length) {
12479:                 /* Skip holes if any. */
12479:                 if (ii->hasHoles) {
12479:                     while (JS_TEST_BIT(ii->holes, i) && ++i != ii->length)
12479:                         continue;
12479:                 }
12479:                 if (i != ii->length) {
12479:                     ii->index = i + 1;
19545:                     return js_IndexToId(cx, i, idp);
12479:                 }
12479:             }
12479:         }
12482:         /* FALL THROUGH */
12479: 
12479:       case JSENUMERATE_DESTROY:
12479:         if (JSVAL_TAG(*statep) != JSVAL_BOOLEAN) {
12479:             JS_ASSERT((*statep & INDEX_ITER_TAG) == INDEX_ITER_TAG);
12479:             ii = (JSIndexIterState *) (*statep & ~INDEX_ITER_TAG);
12479:             JS_free(cx, ii);
12479:         }
12479:         *statep = JSVAL_NULL;
12479:         break;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
11835: slowarray_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
11835:                     jsval *statep, jsid *idp)
    1: {
12479:     JSBool ok;
12479: 
11835:     /* Are we continuing an enumeration that started when we were dense? */
12479:     if (enum_op != JSENUMERATE_INIT) {
12479:         if (JSVAL_TAG(*statep) == JSVAL_BOOLEAN ||
12479:             (*statep & INDEX_ITER_TAG) == INDEX_ITER_TAG) {
12479:             return array_enumerate(cx, obj, enum_op, statep, idp);
11835:         }
12479:         JS_ASSERT((*statep & INDEX_ITER_TAG) == JSVAL_INT);
11835:     }
12479:     ok = js_Enumerate(cx, obj, enum_op, statep, idp);
12479:     JS_ASSERT(*statep == JSVAL_NULL || (*statep & INDEX_ITER_TAG) == JSVAL_INT);
12479:     return ok;
11835: }
11835: 
11835: static void
11835: array_finalize(JSContext *cx, JSObject *obj)
11835: {
11835:     if (obj->dslots)
11835:         JS_free(cx, obj->dslots - 1);
11835:     obj->dslots = NULL;
11835: }
11835: 
11835: static void
11835: array_trace(JSTracer *trc, JSObject *obj)
11835: {
25475:     uint32 capacity;
11835:     size_t i;
11835:     jsval v;
11835: 
29066:     JS_ASSERT(js_IsDenseArray(obj));
11835: 
25475:     capacity = js_DenseArrayCapacity(obj);
25475:     for (i = 0; i < capacity; i++) {
11835:         v = obj->dslots[i];
11835:         if (JSVAL_IS_TRACEABLE(v)) {
11835:             JS_SET_TRACING_INDEX(trc, "array_dslots", i);
11835:             JS_CallTracer(trc, JSVAL_TO_TRACEABLE(v), JSVAL_TRACE_KIND(v));
11835:         }
11835:     }
11835: 
11835:     for (i = JSSLOT_PROTO; i <= JSSLOT_PARENT; ++i) {
11835:         v = STOBJ_GET_SLOT(obj, i);
11835:         if (JSVAL_IS_TRACEABLE(v)) {
11835:             JS_SET_TRACING_DETAILS(trc, js_PrintObjectSlotName, obj, i);
11835:             JS_CallTracer(trc, JSVAL_TO_TRACEABLE(v), JSVAL_TRACE_KIND(v));
11835:         }
11835:     }
11835: }
11835: 
11835: extern JSObjectOps js_ArrayObjectOps;
28353: 
28353: static const JSObjectMap SharedArrayMap = { &js_ArrayObjectOps };
11835: 
11835: JSObjectOps js_ArrayObjectOps = {
28353:     &SharedArrayMap,
11835:     array_lookupProperty, array_defineProperty,
11835:     array_getProperty,    array_setProperty,
11835:     array_getAttributes,  array_setAttributes,
11835:     array_deleteProperty, js_DefaultValue,
11835:     array_enumerate,      js_CheckAccess,
11835:     NULL,                 array_dropProperty,
11835:     NULL,                 NULL,
26828:     js_HasInstance,       array_trace,
26828:     NULL,                 NULL,
26828:     NULL
11835: };
11835: 
11835: static JSObjectOps *
11835: array_getObjectOps(JSContext *cx, JSClass *clasp)
11835: {
11835:     return &js_ArrayObjectOps;
    1: }
    1: 
    1: JSClass js_ArrayClass = {
    1:     "Array",
11835:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_CACHED_PROTO(JSProto_Array) |
11835:     JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_NEW_ENUMERATE,
11835:     JS_PropertyStub,    JS_PropertyStub,   JS_PropertyStub,   JS_PropertyStub,
11835:     JS_EnumerateStub,   JS_ResolveStub,    js_TryValueOf,     array_finalize,
11835:     array_getObjectOps, NULL,              NULL,              NULL,
11835:     NULL,               NULL,              NULL,              NULL
    1: };
    1: 
11835: JSClass js_SlowArrayClass = {
11835:     "Array",
 9561:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_CACHED_PROTO(JSProto_Array),
11835:     slowarray_addProperty, JS_PropertyStub, JS_PropertyStub,  JS_PropertyStub,
11835:     JS_EnumerateStub,      JS_ResolveStub,  js_TryValueOf,    JS_FinalizeStub,
11835:     slowarray_getObjectOps, NULL,           NULL,             NULL,
11835:     NULL,                  NULL,            NULL,             NULL
    1: };
    1: 
11835: /*
11835:  * Convert an array object from fast-and-dense to slow-and-flexible.
11835:  */
15602: JSBool
15602: js_MakeArraySlow(JSContext *cx, JSObject *obj)
11835: {
11835:     JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_ArrayClass);
11835: 
11835:     /* Create a native scope. */
28353:     JSScope *scope = js_NewScope(cx, &js_SlowArrayObjectOps,
11835:                                  &js_SlowArrayClass, obj);
28353:     if (!scope)
11835:         return JS_FALSE;
11835: 
28353:     uint32 capacity = js_DenseArrayCapacity(obj);
25475:     if (capacity) {
28353:         scope->freeslot = STOBJ_NSLOTS(obj) + JS_INITIAL_NSLOTS;
25475:         obj->dslots[-1] = JS_INITIAL_NSLOTS + capacity;
11835:     } else {
28353:         scope->freeslot = STOBJ_NSLOTS(obj);
11835:     }
11835: 
11835:     /* Create new properties pointing to existing values in dslots */
28353:     for (uint32 i = 0; i < capacity; i++) {
11835:         jsid id;
11835:         JSScopeProperty *sprop;
11835: 
11835:         if (!JS_ValueToId(cx, INT_TO_JSVAL(i), &id))
11835:             goto out_bad;
11835: 
11835:         if (obj->dslots[i] == JSVAL_HOLE) {
11835:             obj->dslots[i] = JSVAL_VOID;
11835:             continue;
11835:         }
11835: 
28353:         sprop = js_AddScopeProperty(cx, scope, id, NULL, NULL,
11835:                                     i + JS_INITIAL_NSLOTS, JSPROP_ENUMERATE,
27490:                                     0, 0);
11835:         if (!sprop)
11835:             goto out_bad;
11835:     }
11835: 
18712:     /*
18712:      * Render our formerly-reserved count property GC-safe. If length fits in
18712:      * a jsval, set our slow/sparse COUNT to the current length as a jsval, so
18712:      * we can tell when only named properties have been added to a dense array
18712:      * to make it slow-but-not-sparse.
18712:      */
25476:     {
25475:         uint32 length = obj->fslots[JSSLOT_ARRAY_LENGTH];
18712:         obj->fslots[JSSLOT_ARRAY_COUNT] = INT_FITS_IN_JSVAL(length)
18712:                                           ? INT_TO_JSVAL(length)
18712:                                           : JSVAL_VOID;
25476:     }
11835: 
19020:     /* Make sure we preserve any flags borrowing bits in classword. */
19020:     obj->classword ^= (jsuword) &js_ArrayClass;
19020:     obj->classword |= (jsuword) &js_SlowArrayClass;
11835: 
28353:     obj->map = &scope->map;
11835:     return JS_TRUE;
11835: 
11835:   out_bad:
28353:     js_DestroyScope(cx, scope);
11835:     return JS_FALSE;
11835: }
11835: 
30023: /* Transfer ownership of buffer to returned string. */
30023: static JSBool
30023: BufferToString(JSContext *cx, JSTempVector<jschar> &buf, jsval *rval)
30023: {
30023:     size_t length = buf.size() - 1;
30023:     jschar *chars = buf.extractRawBuffer();
30023:     JSString *str = js_NewString(cx, chars, length);
30023:     if (!str) {
30023:         JS_free(cx, chars);
30023:         return JS_FALSE;
30023:     }
30023:     *rval = STRING_TO_JSVAL(str);
30023:     return JS_TRUE;
30023: }
30023: 
30023: #if JS_HAS_TOSOURCE
30023: static JSBool
30023: array_toSource(JSContext *cx, uintN argc, jsval *vp)
30023: {
30023:     JS_CHECK_RECURSION(cx, return JS_FALSE);
30023: 
30023:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
30023:     if (!obj ||
30023:         (OBJ_GET_CLASS(cx, obj) != &js_SlowArrayClass &&
30023:          !JS_InstanceOf(cx, obj, &js_ArrayClass, vp + 2))) {
30023:         return JS_FALSE;
30023:     }
30023: 
30023:     /* Find joins or cycles in the reachable object graph. */
30023:     jschar *sharpchars;
30023:     JSHashEntry *he = js_EnterSharpObject(cx, obj, NULL, &sharpchars);
30023:     if (!he)
30023:         return JS_FALSE;
30023:     JSBool initiallySharp = IS_SHARP(he) ? JS_TRUE : JS_FALSE;
30023: 
30023:     /* After this point, all paths exit through the 'done' label. */
30023:     MUST_FLOW_THROUGH("done");
30023:     JSBool ok = JS_TRUE;
30021: 
30021:     /*
30023:      * This object will take responsibility for the jschar buffer until the 
30023:      * buffer is transferred to the returned JSString.
30021:      */
30023:     JSTempVector<jschar> buf(cx);
30023:     if (!(ok = buf.reserve(3)))
30023:         goto done;
30023: 
30023:     /* Cycles/joins are indicated by sharp objects. */
30023: #if JS_HAS_SHARP_VARS
30023:     if (IS_SHARP(he)) {
30023:         JS_ASSERT(sharpchars != 0);
30023:         /* +1 to include the trailing '\0' */
30023:         buf.replaceRawBuffer(sharpchars, js_strlen(sharpchars) + 1);
30023:         goto make_string;
30023:     } else if (sharpchars) {
30023:         MAKE_SHARP(he);
30023:         buf.replaceRawBuffer(sharpchars, js_strlen(sharpchars));
30023:     }
30023: #else
30023:     if (IS_SHARP(he)) {
30023:         static const jschar arr[] = { '[', ']', 0 };
30023:         if (!(ok = buf.pushBack(arr, arr + 3)))
30023:             goto done;
30023:         if (sharpchars)
30023:             JS_free(cx, sharpchars);
30023:         goto make_string;
30023:     }
30023: #endif
30023: 
30023:     if (!(ok = buf.pushBack('[')))
30023:         goto done;
30023: 
30023:     jsuint length;
30021:     ok = js_GetLengthProperty(cx, obj, &length);
30021:     if (!ok)
30018:         goto done;
30023: 
30023:     for (jsuint index = 0; index < length; index++) {
30023:         /* Use vp to locally root each element value. */
30023:         JSBool hole;
30021:         ok = (JS_CHECK_OPERATION_LIMIT(cx) &&
30023:               GetArrayElement(cx, obj, index, &hole, vp));
    1:         if (!ok)
    1:             goto done;
30023: 
30023:         /* Get element's character string. */
30023:         JSString *str;
30023:         if (hole) {
    1:             str = cx->runtime->emptyString;
    1:         } else {
30023:             str = js_ValueToSource(cx, *vp);
30023:             if (!str) {
30023:                 ok = JS_FALSE;
30023:                 goto done;
30023:             }
30023:         }
30023:         *vp = STRING_TO_JSVAL(str);
30023:         const jschar *chars;
30023:         size_t charlen;
30023:         str->getCharsAndLength(chars, charlen);
30023: 
30023:         /* Append element to buffer. */
30023:         if (!(ok = buf.pushBack(chars, chars + charlen)))
30023:             goto done;
30023:         if (index + 1 != length) {
30023:             if (!(ok = buf.pushBack(',')) || !(ok = buf.pushBack(' ')))
30023:                 goto done;
30023:         } else if (hole) {
30023:             if (!(ok = buf.pushBack(',')))
30023:                 goto done;
30023:         }
30023:     }
30023: 
30023:     /* Finalize the buffer. */
30023:     if (!(ok = buf.pushBack(']')) || !(ok = buf.pushBack(0)))
30023:         goto done;
30023: 
30023:   make_string:
30023:     if (!(ok = BufferToString(cx, buf, vp)))
30023:         goto done;
30023: 
30023:   done:
30023:     if (!initiallySharp)
30023:         js_LeaveSharpObject(cx, NULL);
30023:     return ok;
30023: }
30023: #endif
30023: 
30023: static JSHashNumber
30023: js_hash_array(const void *key)
30023: {
30023:     return (JSHashNumber)JS_PTR_TO_UINT32(key) >> JSVAL_TAGBITS;
30023: }
30023: 
30023: JSBool
30023: js_InitContextBusyArrayTable(JSContext *cx)
30023: {
30023:     cx->busyArrayTable = JS_NewHashTable(4, js_hash_array, JS_CompareValues,
30023:                                          JS_CompareValues, NULL, NULL);
30023:     return cx->busyArrayTable != NULL;
30023: }
30023: 
30023: static JSBool
30023: array_toString_sub(JSContext *cx, JSObject *obj, JSBool locale,
30023:                    JSString *sepstr, jsval *rval)
30023: {
30023:     JS_CHECK_RECURSION(cx, return JS_FALSE);
30023: 
30023:     /*
30023:      * This hash table is shared between toString invocations and must be empty
30023:      * after the root invocation completes.
30023:      */
30023:     JSHashTable *table = cx->busyArrayTable;
30023: 
30023:     /*
30023:      * Use HashTable entry as the cycle indicator.  On first visit, create the
30023:      * entry, and, when leaving, remove the entry.
30023:      */
30023:     JSHashNumber hash = js_hash_array(obj);
30023:     JSHashEntry **hep = JS_HashTableRawLookup(table, hash, obj);
30023:     JSHashEntry *he = *hep;
30023:     if (!he) {
30023:         /* Not in hash table, so not a cycle. */
30023:         he = JS_HashTableRawAdd(table, hep, hash, obj, NULL);
30023:         if (!he) {
30023:             JS_ReportOutOfMemory(cx);
30023:             return JS_FALSE;
30023:         }
30023:     } else {
30023:         /* Cycle, so return empty string. */
30023:         *rval = ATOM_KEY(cx->runtime->atomState.emptyAtom);
30023:         return JS_TRUE;
30023:     }
30023: 
30023:     JSAutoTempValueRooter tvr(cx, obj);
30023: 
30023:     /* After this point, all paths exit through the 'done' label. */
30023:     MUST_FLOW_THROUGH("done");
30023:     JSBool ok = JS_TRUE;
30023: 
30023:     /* Get characters to use for the separator. */
30023:     static const jschar comma = ',';
30023:     const jschar *sep;
30023:     size_t seplen;
30023:     if (sepstr) {
30023:         sepstr->getCharsAndLength(sep, seplen);
30023:     } else {
30023:         sep = &comma;
30023:         seplen = 1;
30023:     }
30023: 
30023:     /*
30023:      * This object will take responsibility for the jschar buffer until the 
30023:      * buffer is transferred to the returned JSString.
30023:      */
30023:     JSTempVector<jschar> buf(cx);
30023: 
30023:     jsuint length;
30023:     ok = js_GetLengthProperty(cx, obj, &length);
30023:     if (!ok)
30023:         goto done;
30023: 
30023:     for (jsuint index = 0; index < length; index++) {
30023:         /* Use rval to locally root each element value. */
30023:         JSBool hole;
30023:         ok = JS_CHECK_OPERATION_LIMIT(cx) &&
30023:              GetArrayElement(cx, obj, index, &hole, rval);
30023:         if (!ok)
30023:             goto done;
30023: 
30023:         /* Get element's character string. */
30023:         if (!(hole || JSVAL_IS_VOID(*rval) || JSVAL_IS_NULL(*rval))) {
30023:             if (locale) {
 4127:                 JSObject *robj;
 4127: 
30023:                 JSAtom *atom = cx->runtime->atomState.toLocaleStringAtom;
 4129:                 ok = js_ValueToObject(cx, *rval, &robj);
 4127:                 if (ok) {
 4129:                     /* Re-use *rval to protect robj temporarily. */
 4129:                     *rval = OBJECT_TO_JSVAL(robj);
 4129:                     ok = js_TryMethod(cx, robj, atom, 0, NULL, rval);
 4127:                 }
    1:                 if (!ok)
    1:                     goto done;
30023:             }
30023: 
30023:             ok = js_ValueToStringBuffer(cx, *rval, buf);
30023:             if (!ok)
    1:                 goto done;
    1:         }
30023: 
30023:         /* Append the separator. */
30023:         if (index + 1 != length) {
30023:             if (!(ok = buf.pushBack(sep, sep + seplen)))
    1:                 goto done;
    1:         }
30023:     }
30023: 
30023:     /* Finalize the buffer. */
30023:     if (buf.empty()) {
30023:         *rval = ATOM_KEY(cx->runtime->atomState.emptyAtom);
    1:         goto done;
30023:     }
30023: 
30023:     ok = buf.pushBack(0) &&
30023:          BufferToString(cx, buf, rval);
30023:     if (!ok)
    1:         goto done;
    1: 
    1:   done:
30037:     /*
30037:      * It is possible that 'hep' may have been invalidated by subsequent
30037:      * RawAdd/Remove.  Hence, 'RawRemove' must not be used.
30037:      */
30037:     JS_HashTableRemove(table, obj);
    1:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: array_toString(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 4127: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
30023:     if (!obj ||
30023:         (OBJ_GET_CLASS(cx, obj) != &js_SlowArrayClass &&
30023:          !JS_InstanceOf(cx, obj, &js_ArrayClass, vp + 2))) {
 3287:         return JS_FALSE;
    1:     }
30023: 
30023:     return array_toString_sub(cx, obj, JS_FALSE, NULL, vp);
    1: }
    1: 
    1: static JSBool
 4127: array_toLocaleString(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 4127: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
30023:     if (!obj ||
30023:         (OBJ_GET_CLASS(cx, obj) != &js_SlowArrayClass &&
30023:          !JS_InstanceOf(cx, obj, &js_ArrayClass, vp + 2))) {
 3287:         return JS_FALSE;
11835:     }
 3287: 
    1:     /*
    1:      *  Passing comma here as the separator. Need a way to get a
    1:      *  locale-specific version.
    1:      */
30023:     return array_toString_sub(cx, obj, JS_TRUE, NULL, vp);
    1: }
    1: 
28242: enum TargetElementsType {
28242:     TargetElementsAllHoles,
28242:     TargetElementsMayContainValues
28242: };
28242: 
28242: enum SourceVectorType {
28242:     SourceVectorAllValues,
28242:     SourceVectorMayContainHoles
28242: };
28242: 
    1: static JSBool
28242: InitArrayElements(JSContext *cx, JSObject *obj, jsuint start, jsuint count, jsval *vector,
28242:                   TargetElementsType targetType, SourceVectorType vectorType)
    1: {
26564:     JS_ASSERT(count < MAXINDEX);
28242: 
26564:     /*
26564:      * Optimize for dense arrays so long as adding the given set of elements
26564:      * wouldn't otherwise make the array slow.
26564:      */
28242:     if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_PrototypeHasIndexedProperties(cx, obj) &&
28242:         start <= MAXINDEX - count && !INDEX_TOO_BIG(start + count)) {
28242: 
28242: #ifdef DEBUG_jwalden
28242:         {
28242:             /* Verify that overwriteType and writeType were accurate. */
28242:             JSAutoTempIdRooter idr(cx, JSVAL_ZERO);
28242:             for (jsuint i = 0; i < count; i++) {
28242:                 JS_ASSERT_IF(vectorType == SourceVectorAllValues, vector[i] != JSVAL_HOLE);
28242: 
28242:                 jsdouble index = jsdouble(start) + i;
28242:                 if (targetType == TargetElementsAllHoles && index < jsuint(-1)) {
28242:                     JS_ASSERT(ReallyBigIndexToId(cx, index, idr.addr()));
28242:                     JSObject* obj2;
28242:                     JSProperty* prop;
28242:                     JS_ASSERT(OBJ_LOOKUP_PROPERTY(cx, obj, idr.id(), &obj2, &prop));
28242:                     JS_ASSERT(!prop);
28242:                 }
28242:             }
28242:         }
28242: #endif
28242: 
26564:         jsuint newlen = start + count;
26564:         JS_ASSERT(jsdouble(start) + count == jsdouble(newlen));
26564:         if (!EnsureCapacity(cx, obj, newlen))
11835:             return JS_FALSE;
11835: 
26564:         if (newlen > uint32(obj->fslots[JSSLOT_ARRAY_LENGTH]))
26564:             obj->fslots[JSSLOT_ARRAY_LENGTH] = newlen;
26564: 
26564:         JS_ASSERT(count < size_t(-1) / sizeof(jsval));
28242:         if (targetType == TargetElementsMayContainValues) {
28242:             jsuint valueCount = 0;
28242:             for (jsuint i = 0; i < count; i++) {
28242:                  if (obj->dslots[start + i] != JSVAL_HOLE)
28242:                      valueCount++;
28242:             }
28242:             JS_ASSERT(uint32(obj->fslots[JSSLOT_ARRAY_COUNT]) >= valueCount);
28242:             obj->fslots[JSSLOT_ARRAY_COUNT] -= valueCount;
28242:         }
26564:         memcpy(obj->dslots + start, vector, sizeof(jsval) * count);
28242:         if (vectorType == SourceVectorAllValues) {
28242:             obj->fslots[JSSLOT_ARRAY_COUNT] += count;
28242:         } else {
28242:             jsuint valueCount = 0;
28242:             for (jsuint i = 0; i < count; i++) {
28242:                  if (obj->dslots[start + i] != JSVAL_HOLE)
28242:                      valueCount++;
28242:             }
28242:             obj->fslots[JSSLOT_ARRAY_COUNT] += valueCount;
28242:         }
26566:         JS_ASSERT_IF(count != 0, obj->dslots[newlen - 1] != JSVAL_HOLE);
11835:         return JS_TRUE;
11835:     }
11835: 
26564:     jsval* end = vector + count;
26564:     while (vector != end && start < MAXINDEX) {
25087:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
    1:             !SetArrayElement(cx, obj, start++, *vector++)) {
    1:             return JS_FALSE;
    1:         }
    1:     }
26564: 
26564:     if (vector == end)
26564:         return JS_TRUE;
26564: 
26564:     /* Finish out any remaining elements past the max array index. */
27888:     if (OBJ_IS_DENSE_ARRAY(cx, obj) && !ENSURE_SLOW_ARRAY(cx, obj))
26564:         return JS_FALSE;
26564: 
26564:     JS_ASSERT(start == MAXINDEX);
26564:     jsval tmp[2] = {JSVAL_NULL, JSVAL_NULL};
26564:     jsdouble* dp = js_NewWeaklyRootedDouble(cx, MAXINDEX);
26564:     if (!dp)
26564:         return JS_FALSE;
26564:     tmp[0] = DOUBLE_TO_JSVAL(dp);
26564:     JSAutoTempValueRooter(cx, JS_ARRAY_LENGTH(tmp), tmp);
26564:     JSAutoTempIdRooter idr(cx);
26564:     do {
26564:         tmp[1] = *vector++;
26564:         if (!js_ValueToStringId(cx, tmp[0], idr.addr()) ||
27888:             !OBJ_SET_PROPERTY(cx, obj, idr.id(), &tmp[1])) {
26564:             return JS_FALSE;
26564:         }
26564:         *dp += 1;
26564:     } while (vector != end);
26564: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
15281: InitArrayObject(JSContext *cx, JSObject *obj, jsuint length, jsval *vector,
15281:                 JSBool holey = JS_FALSE)
    1: {
11835:     JS_ASSERT(OBJ_IS_ARRAY(cx, obj));
11835: 
12231:     obj->fslots[JSSLOT_ARRAY_LENGTH] = length;
11835: 
11835:     if (vector) {
25475:         if (!EnsureCapacity(cx, obj, length))
    1:             return JS_FALSE;
15281: 
15281:         jsuint count = length;
15281:         if (!holey) {
11835:             memcpy(obj->dslots, vector, length * sizeof (jsval));
15281:         } else {
15281:             for (jsuint i = 0; i < length; i++) {
15281:                 if (vector[i] == JSVAL_HOLE)
15281:                     --count;
15281:                 obj->dslots[i] = vector[i];
15281:             }
15281:         }
15281:         obj->fslots[JSSLOT_ARRAY_COUNT] = count;
11835:     } else {
12231:         obj->fslots[JSSLOT_ARRAY_COUNT] = 0;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
20408: #ifdef JS_TRACER
20915: static JSString* FASTCALL
20915: Array_p_join(JSContext* cx, JSObject* obj, JSString *str)
20408: {
25094:     JSAutoTempValueRooter tvr(cx);
30023:     if (!array_toString_sub(cx, obj, JS_FALSE, str, tvr.addr())) {
27166:         js_SetBuiltinError(cx);
20408:         return NULL;
24612:     }
25094:     return JSVAL_TO_STRING(tvr.value());
20408: }
21685: 
21685: static JSString* FASTCALL
21685: Array_p_toString(JSContext* cx, JSObject* obj)
21685: {
25094:     JSAutoTempValueRooter tvr(cx);
30023:     if (!array_toString_sub(cx, obj, JS_FALSE, NULL, tvr.addr())) {
27166:         js_SetBuiltinError(cx);
21685:         return NULL;
25094:     }
25094:     return JSVAL_TO_STRING(tvr.value());
21685: }
20408: #endif
20408: 
    1: /*
    1:  * Perl-inspired join, reverse, and sort.
    1:  */
20408: static JSBool
20408: array_join(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSString *str;
11809:     JSObject *obj;
    1: 
16519:     if (argc == 0 || JSVAL_IS_VOID(vp[2])) {
    1:         str = NULL;
    1:     } else {
 4127:         str = js_ValueToString(cx, vp[2]);
    1:         if (!str)
    1:             return JS_FALSE;
 4127:         vp[2] = STRING_TO_JSVAL(str);
    1:     }
11809:     obj = JS_THIS_OBJECT(cx, vp);
30023:     return obj && array_toString_sub(cx, obj, JS_FALSE, str, vp);
    1: }
    1: 
    1: static JSBool
 4127: array_reverse(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 6917:     JSTempValueRooter tvr;
    1:     jsuint len, half, i;
 6917:     JSBool ok, hole, hole2;
    1: 
 4127:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_GetLengthProperty(cx, obj, &len))
    1:         return JS_FALSE;
28242:     *vp = OBJECT_TO_JSVAL(obj);
28242: 
28242:     if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_PrototypeHasIndexedProperties(cx, obj)) {
28242:         /* An empty array or an array with no elements is already reversed. */
28242:         if (len == 0 || !obj->dslots)
28242:             return JS_TRUE;
28242: 
28242:         /*
28242:          * It's actually surprisingly complicated to reverse an array due to the
28242:          * orthogonality of array length and array capacity while handling
28242:          * leading and trailing holes correctly.  Reversing seems less likely to
28242:          * be a common operation than other array mass-mutation methods, so for
28242:          * now just take a probably-small memory hit (in the absence of too many
28242:          * holes in the array at its start) and ensure that the capacity is
28242:          * sufficient to hold all the elements in the array if it were full.
28242:          */
28242:         if (!EnsureCapacity(cx, obj, len))
28242:             return JS_FALSE;
28242: 
28242:         jsval* lo = &obj->dslots[0];
28242:         jsval* hi = &obj->dslots[len - 1];
28242:         for (; lo < hi; lo++, hi--) {
28242:              jsval tmp = *lo;
28242:              *lo = *hi;
28242:              *hi = tmp;
28242:         }
28242: 
28242:         /*
28242:          * Per ECMA-262, don't update the length of the array, even if the new
28242:          * array has trailing holes (and thus the original array began with
28242:          * holes).
28242:          */
28242:         return JS_TRUE;
28242:     }
    1: 
 6917:     ok = JS_TRUE;
 6917:     JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &tvr);
    1:     half = len / 2;
    1:     for (i = 0; i < half; i++) {
25087:         ok = JS_CHECK_OPERATION_LIMIT(cx) &&
 6917:              GetArrayElement(cx, obj, i, &hole, &tvr.u.value) &&
 6917:              GetArrayElement(cx, obj, len - i - 1, &hole2, vp) &&
 6917:              SetOrDeleteArrayElement(cx, obj, len - i - 1, hole, tvr.u.value) &&
 6917:              SetOrDeleteArrayElement(cx, obj, i, hole2, *vp);
 6917:         if (!ok)
 6917:             break;
    1:     }
 6917:     JS_POP_TEMP_ROOT(cx, &tvr);
 6917: 
 4127:     *vp = OBJECT_TO_JSVAL(obj);
 6917:     return ok;
    1: }
    1: 
    1: typedef struct MSortArgs {
    1:     size_t       elsize;
    1:     JSComparator cmp;
    1:     void         *arg;
    1:     JSBool       fastcopy;
    1: } MSortArgs;
    1: 
    1: /* Helper function for js_MergeSort. */
29887: static JSBool
    1: MergeArrays(MSortArgs *msa, void *src, void *dest, size_t run1, size_t run2)
    1: {
    1:     void *arg, *a, *b, *c;
    1:     size_t elsize, runtotal;
    1:     int cmp_result;
    1:     JSComparator cmp;
    1:     JSBool fastcopy;
    1: 
    1:     runtotal = run1 + run2;
    1: 
    1:     elsize = msa->elsize;
    1:     cmp = msa->cmp;
    1:     arg = msa->arg;
    1:     fastcopy = msa->fastcopy;
    1: 
    1: #define CALL_CMP(a, b) \
    1:     if (!cmp(arg, (a), (b), &cmp_result)) return JS_FALSE;
    1: 
    1:     /* Copy runs already in sorted order. */
    1:     b = (char *)src + run1 * elsize;
    1:     a = (char *)b - elsize;
    1:     CALL_CMP(a, b);
    1:     if (cmp_result <= 0) {
    1:         memcpy(dest, src, runtotal * elsize);
    1:         return JS_TRUE;
    1:     }
    1: 
    1: #define COPY_ONE(p,q,n) \
    1:     (fastcopy ? (void)(*(jsval*)(p) = *(jsval*)(q)) : (void)memcpy(p, q, n))
    1: 
    1:     a = src;
    1:     c = dest;
    1:     for (; runtotal != 0; runtotal--) {
    1:         JSBool from_a = run2 == 0;
    1:         if (!from_a && run1 != 0) {
    1:             CALL_CMP(a,b);
    1:             from_a = cmp_result <= 0;
    1:         }
    1: 
    1:         if (from_a) {
    1:             COPY_ONE(c, a, elsize);
    1:             run1--;
    1:             a = (char *)a + elsize;
    1:         } else {
    1:             COPY_ONE(c, b, elsize);
    1:             run2--;
    1:             b = (char *)b + elsize;
    1:         }
    1:         c = (char *)c + elsize;
    1:     }
    1: #undef COPY_ONE
    1: #undef CALL_CMP
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * This sort is stable, i.e. sequence of equal elements is preserved.
    1:  * See also bug #224128.
    1:  */
29887: JSBool
    1: js_MergeSort(void *src, size_t nel, size_t elsize,
    1:              JSComparator cmp, void *arg, void *tmp)
    1: {
    1:     void *swap, *vec1, *vec2;
    1:     MSortArgs msa;
    1:     size_t i, j, lo, hi, run;
    1:     JSBool fastcopy;
    1:     int cmp_result;
    1: 
 9015:     /* Avoid memcpy overhead for word-sized and word-aligned elements. */
 9015:     fastcopy = (elsize == sizeof(jsval) &&
 9015:                 (((jsuword) src | (jsuword) tmp) & JSVAL_ALIGN) == 0);
    1: #define COPY_ONE(p,q,n) \
    1:     (fastcopy ? (void)(*(jsval*)(p) = *(jsval*)(q)) : (void)memcpy(p, q, n))
    1: #define CALL_CMP(a, b) \
    1:     if (!cmp(arg, (a), (b), &cmp_result)) return JS_FALSE;
    1: #define INS_SORT_INT 4
    1: 
    1:     /*
    1:      * Apply insertion sort to small chunks to reduce the number of merge
    1:      * passes needed.
    1:      */
    1:     for (lo = 0; lo < nel; lo += INS_SORT_INT) {
    1:         hi = lo + INS_SORT_INT;
    1:         if (hi >= nel)
    1:             hi = nel;
    1:         for (i = lo + 1; i < hi; i++) {
    1:             vec1 = (char *)src + i * elsize;
    1:             vec2 = (char *)vec1 - elsize;
    1:             for (j = i; j > lo; j--) {
    1:                 CALL_CMP(vec2, vec1);
    1:                 /* "<=" instead of "<" insures the sort is stable */
    1:                 if (cmp_result <= 0) {
    1:                     break;
    1:                 }
    1: 
    1:                 /* Swap elements, using "tmp" as tmp storage */
    1:                 COPY_ONE(tmp, vec2, elsize);
    1:                 COPY_ONE(vec2, vec1, elsize);
    1:                 COPY_ONE(vec1, tmp, elsize);
    1:                 vec1 = vec2;
    1:                 vec2 = (char *)vec1 - elsize;
    1:             }
    1:         }
    1:     }
    1: #undef CALL_CMP
    1: #undef COPY_ONE
    1: 
    1:     msa.elsize = elsize;
    1:     msa.cmp = cmp;
    1:     msa.arg = arg;
    1:     msa.fastcopy = fastcopy;
    1: 
    1:     vec1 = src;
    1:     vec2 = tmp;
    1:     for (run = INS_SORT_INT; run < nel; run *= 2) {
    1:         for (lo = 0; lo < nel; lo += 2 * run) {
    1:             hi = lo + run;
    1:             if (hi >= nel) {
    1:                 memcpy((char *)vec2 + lo * elsize, (char *)vec1 + lo * elsize,
    1:                        (nel - lo) * elsize);
    1:                 break;
    1:             }
    1:             if (!MergeArrays(&msa, (char *)vec1 + lo * elsize,
    1:                              (char *)vec2 + lo * elsize, run,
    1:                              hi + run > nel ? nel - hi : run)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         swap = vec1;
    1:         vec1 = vec2;
    1:         vec2 = swap;
    1:     }
    1:     if (src != vec1)
    1:         memcpy(src, tmp, nel * elsize);
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: typedef struct CompareArgs {
    1:     JSContext   *context;
    1:     jsval       fval;
 8249:     jsval       *elemroot;      /* stack needed for js_Invoke */
    1: } CompareArgs;
    1: 
24499: static JS_REQUIRES_STACK JSBool
    1: sort_compare(void *arg, const void *a, const void *b, int *result)
    1: {
    1:     jsval av = *(const jsval *)a, bv = *(const jsval *)b;
    1:     CompareArgs *ca = (CompareArgs *) arg;
    1:     JSContext *cx = ca->context;
 8439:     jsval *invokevp, *sp;
 8439:     jsdouble cmp;
    1: 
    1:     /**
    1:      * array_sort deals with holes and undefs on its own and they should not
    1:      * come here.
    1:      */
15521:     JS_ASSERT(!JSVAL_IS_VOID(av));
15521:     JS_ASSERT(!JSVAL_IS_VOID(bv));
    1: 
25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
    1:         return JS_FALSE;
    1: 
 8249:     invokevp = ca->elemroot;
 8249:     sp = invokevp;
 8249:     *sp++ = ca->fval;
 8249:     *sp++ = JSVAL_NULL;
 8249:     *sp++ = av;
 8249:     *sp++ = bv;
 8249: 
14721:     if (!js_Invoke(cx, 2, invokevp, 0))
 8439:         return JS_FALSE;
12694: 
12694:     cmp = js_ValueToNumber(cx, invokevp);
12694:     if (JSVAL_IS_NULL(*invokevp))
12694:         return JS_FALSE;
    1: 
    1:     /* Clamp cmp to -1, 0, 1. */
    1:     *result = 0;
 8439:     if (!JSDOUBLE_IS_NaN(cmp) && cmp != 0)
 8439:         *result = cmp > 0 ? 1 : -1;
 8439: 
    1:     /*
 8439:      * XXX else report some kind of error here?  ECMA talks about 'consistent
 8439:      * compare functions' that don't return NaN, but is silent about what the
 8439:      * result should be.  So we currently ignore it.
    1:      */
 8439: 
 8439:     return JS_TRUE;
    1: }
    1: 
29885: typedef JSBool (JS_REQUIRES_STACK *JSRedComparator)(void*, const void*,
29885:                                                     const void*, int *);
29885: 
29885: static inline JS_IGNORE_STACK JSComparator
29885: comparator_stack_cast(JSRedComparator func)
29885: {
29885:     return func;
29885: }
29885: 
    1: static int
    1: sort_compare_strings(void *arg, const void *a, const void *b, int *result)
    1: {
    1:     jsval av = *(const jsval *)a, bv = *(const jsval *)b;
    1: 
 9015:     JS_ASSERT(JSVAL_IS_STRING(av));
 9015:     JS_ASSERT(JSVAL_IS_STRING(bv));
25087:     if (!JS_CHECK_OPERATION_LIMIT((JSContext *)arg))
    1:         return JS_FALSE;
    1: 
    1:     *result = (int) js_CompareStrings(JSVAL_TO_STRING(av), JSVAL_TO_STRING(bv));
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * The array_sort function below assumes JSVAL_NULL is zero in order to
    1:  * perform initialization using memset.  Other parts of SpiderMonkey likewise
    1:  * "know" that JSVAL_NULL is zero; this static assertion covers all cases.
    1:  */
    1: JS_STATIC_ASSERT(JSVAL_NULL == 0);
    1: 
29887: static JSBool
 4127: array_sort(JSContext *cx, uintN argc, jsval *vp)
    1: {
 9015:     jsval *argv, fval, *vec, *mergesort_tmp, v;
 4127:     JSObject *obj;
    1:     CompareArgs ca;
    1:     jsuint len, newlen, i, undefs;
    1:     JSTempValueRooter tvr;
18998:     JSBool hole;
25628:     JSBool ok;
 9015:     size_t elemsize;
 9015:     JSString *str;
    1: 
    1:     /*
    1:      * Optimize the default compare function case if all of obj's elements
    1:      * have values of type string.
    1:      */
    1:     JSBool all_strings;
    1: 
 4127:     argv = JS_ARGV(cx, vp);
    1:     if (argc > 0) {
    1:         if (JSVAL_IS_PRIMITIVE(argv[0])) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_SORT_ARG);
    1:             return JS_FALSE;
    1:         }
 9015:         fval = argv[0];     /* non-default compare function */
    1:     } else {
    1:         fval = JSVAL_NULL;
    1:     }
    1: 
 4127:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_GetLengthProperty(cx, obj, &len))
    1:         return JS_FALSE;
    1:     if (len == 0) {
 4127:         *vp = OBJECT_TO_JSVAL(obj);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /*
 9015:      * We need a temporary array of 2 * len jsvals to hold the array elements
 9015:      * and the scratch space for merge sort. Check that its size does not
 9015:      * overflow size_t, which would allow for indexing beyond the end of the
 9015:      * malloc'd vector.
    1:      */
 9975: #if JS_BITS_PER_WORD == 32
 9975:     if ((size_t)len > ~(size_t)0 / (2 * sizeof(jsval))) {
12983:         js_ReportAllocationOverflow(cx);
    1:         return JS_FALSE;
    1:     }
 9975: #endif
    1:     vec = (jsval *) JS_malloc(cx, 2 * (size_t) len * sizeof(jsval));
    1:     if (!vec)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Initialize vec as a root. We will clear elements of vec one by
    1:      * one while increasing tvr.count when we know that the property at
    1:      * the corresponding index exists and its value must be rooted.
    1:      *
    1:      * In this way when sorting a huge mostly sparse array we will not
    1:      * access the tail of vec corresponding to properties that do not
    1:      * exist, allowing OS to avoiding committing RAM. See bug 330812.
    1:      *
    1:      * After this point control must flow through label out: to exit.
    1:      */
    1:     JS_PUSH_TEMP_ROOT(cx, 0, vec, &tvr);
    1: 
    1:     /*
    1:      * By ECMA 262, 15.4.4.11, a property that does not exist (which we
    1:      * call a "hole") is always greater than an existing property with
    1:      * value undefined and that is always greater than any other property.
    1:      * Thus to sort holes and undefs we simply count them, sort the rest
    1:      * of elements, append undefs after them and then make holes after
    1:      * undefs.
    1:      */
    1:     undefs = 0;
    1:     newlen = 0;
 9015:     all_strings = JS_TRUE;
    1:     for (i = 0; i < len; i++) {
25087:         ok = JS_CHECK_OPERATION_LIMIT(cx);
    1:         if (!ok)
    1:             goto out;
    1: 
    1:         /* Clear vec[newlen] before including it in the rooted set. */
    1:         vec[newlen] = JSVAL_NULL;
    1:         tvr.count = newlen + 1;
    1:         ok = GetArrayElement(cx, obj, i, &hole, &vec[newlen]);
    1:         if (!ok)
    1:             goto out;
    1: 
    1:         if (hole)
    1:             continue;
    1: 
15521:         if (JSVAL_IS_VOID(vec[newlen])) {
    1:             ++undefs;
    1:             continue;
    1:         }
    1: 
    1:         /* We know JSVAL_IS_STRING yields 0 or 1, so avoid a branch via &=. */
    1:         all_strings &= JSVAL_IS_STRING(vec[newlen]);
    1: 
    1:         ++newlen;
    1:     }
    1: 
 9015:     if (newlen == 0) {
 9015:         /* The array has only holes and undefs. */
 9015:         ok = JS_TRUE;
 9015:         goto out;
 9015:     }
 9015: 
    1:     /*
 9015:      * The first newlen elements of vec are copied from the array object
 9015:      * (above). The remaining newlen positions are used as GC-rooted scratch
 9015:      * space for mergesort. We must clear the space before including it to
 9015:      * the root set covered by tvr.count. We assume JSVAL_NULL==0 to optimize
 9015:      * initialization using memset.
    1:      */
    1:     mergesort_tmp = vec + newlen;
    1:     memset(mergesort_tmp, 0, newlen * sizeof(jsval));
    1:     tvr.count = newlen * 2;
    1: 
    1:     /* Here len == 2 * (newlen + undefs + number_of_holes). */
 9015:     if (fval == JSVAL_NULL) {
 9015:         /*
 9015:          * Sort using the default comparator converting all elements to
 9015:          * strings.
 9015:          */
    1:         if (all_strings) {
 9015:             elemsize = sizeof(jsval);
 9015:         } else {
 9015:             /*
 9015:              * To avoid string conversion on each compare we do it only once
 9015:              * prior to sorting. But we also need the space for the original
 9015:              * values to recover the sorting result. To reuse
 9015:              * sort_compare_strings we move the original values to the odd
 9015:              * indexes in vec, put the string conversion results in the even
 9015:              * indexes and pass 2 * sizeof(jsval) as an element size to the
 9015:              * sorting function. In this way sort_compare_strings will only
 9015:              * see the string values when it casts the compare arguments as
 9015:              * pointers to jsval.
 9015:              *
 9015:              * This requires doubling the temporary storage including the
 9015:              * scratch space for the merge sort. Since vec already contains
 9015:              * the rooted scratch space for newlen elements at the tail, we
 9015:              * can use it to rearrange and convert to strings first and try
 9015:              * realloc only when we know that we successfully converted all
 9015:              * the elements.
 9015:              */
 9975: #if JS_BITS_PER_WORD == 32
 9975:             if ((size_t)newlen > ~(size_t)0 / (4 * sizeof(jsval))) {
12983:                 js_ReportAllocationOverflow(cx);
 9015:                 ok = JS_FALSE;
 9015:                 goto out;
 9015:             }
 9975: #endif
 9015: 
 9015:             /*
 9015:              * Rearrange and string-convert the elements of the vector from
 9015:              * the tail here and, after sorting, move the results back
 9015:              * starting from the start to prevent overwrite the existing
 9015:              * elements.
 9015:              */
 9015:             i = newlen;
 9015:             do {
 9015:                 --i;
25087:                 ok = JS_CHECK_OPERATION_LIMIT(cx);
 9015:                 if (!ok)
 9015:                     goto out;
 9015:                 v = vec[i];
 9015:                 str = js_ValueToString(cx, v);
 9015:                 if (!str) {
 9015:                     ok = JS_FALSE;
 9015:                     goto out;
 9015:                 }
 9015:                 vec[2 * i] = STRING_TO_JSVAL(str);
 9015:                 vec[2 * i + 1] = v;
 9015:             } while (i != 0);
 9015: 
 9015:             JS_ASSERT(tvr.u.array == vec);
 9930:             vec = (jsval *) JS_realloc(cx, vec,
 9930:                                        4 * (size_t) newlen * sizeof(jsval));
 9015:             if (!vec) {
 9015:                 vec = tvr.u.array;
 9015:                 ok = JS_FALSE;
 9015:                 goto out;
 9015:             }
 9015:             tvr.u.array = vec;
 9015:             mergesort_tmp = vec + 2 * newlen;
 9015:             memset(mergesort_tmp, 0, newlen * 2 * sizeof(jsval));
 9015:             tvr.count = newlen * 4;
 9015:             elemsize = 2 * sizeof(jsval);
 9015:         }
 9015:         ok = js_MergeSort(vec, (size_t) newlen, elemsize,
    1:                           sort_compare_strings, cx, mergesort_tmp);
 9015:         if (!ok)
 9015:             goto out;
 9015:         if (!all_strings) {
 9015:             /*
 9780:              * We want to make the following loop fast and to unroot the
 9780:              * cached results of toString invocations before the operation
 9780:              * callback has a chance to run the GC. For this reason we do
 9780:              * not call JS_CHECK_OPERATION_LIMIT in the loop.
 9015:              */
 9069:             i = 0;
 9069:             do {
 9015:                 vec[i] = vec[2 * i + 1];
 9069:             } while (++i != newlen);
 9015:         }
    1:     } else {
 8249:         void *mark;
 8249: 
29887:         js_LeaveTrace(cx);
29887: 
    1:         ca.context = cx;
    1:         ca.fval = fval;
 8249:         ca.elemroot  = js_AllocStack(cx, 2 + 2, &mark);
 8249:         if (!ca.elemroot) {
 8249:             ok = JS_FALSE;
 8249:             goto out;
 8249:         }
    1:         ok = js_MergeSort(vec, (size_t) newlen, sizeof(jsval),
29885:                           comparator_stack_cast(sort_compare),
29885:                           &ca, mergesort_tmp);
 8249:         js_FreeStack(cx, mark);
    1:         if (!ok)
    1:             goto out;
 9015:     }
    1: 
 9015:     /*
 9015:      * We no longer need to root the scratch space for the merge sort, so
 9015:      * unroot it now to make the job of a potential GC under InitArrayElements
 9015:      * easier.
 9015:      */
 9015:     tvr.count = newlen;
28242:     ok = InitArrayElements(cx, obj, 0, newlen, vec, TargetElementsMayContainValues,
28242:                            SourceVectorAllValues);
    1:     if (!ok)
    1:         goto out;
    1: 
    1:   out:
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     JS_free(cx, vec);
    1:     if (!ok)
    1:         return JS_FALSE;
    1: 
    1:     /* Set undefs that sorted after the rest of elements. */
    1:     while (undefs != 0) {
    1:         --undefs;
25087:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
    1:             !SetArrayElement(cx, obj, newlen++, JSVAL_VOID)) {
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     /* Re-create any holes that sorted to the end of the array. */
    1:     while (len > newlen) {
25087:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
    1:             !DeleteArrayElement(cx, obj, --len)) {
    1:             return JS_FALSE;
    1:         }
    1:     }
 4127:     *vp = OBJECT_TO_JSVAL(obj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Perl-inspired push, pop, shift, unshift, and splice methods.
    1:  */
20408: static JSBool
20408: array_push_slowly(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
26564:     jsuint length;
    1: 
    1:     if (!js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
28242:     if (!InitArrayElements(cx, obj, length, argc, argv, TargetElementsMayContainValues,
28242:                            SourceVectorAllValues)) {
    1:         return JS_FALSE;
28242:     }
    1: 
    1:     /* Per ECMA-262, return the new array length. */
26564:     jsdouble newlength = length + jsdouble(argc);
19571:     if (!IndexToValue(cx, newlength, rval))
    1:         return JS_FALSE;
    1:     return js_SetLengthProperty(cx, obj, newlength);
    1: }
    1: 
20408: static JSBool
20408: array_push1_dense(JSContext* cx, JSObject* obj, jsval v, jsval *rval)
19571: {
19571:     uint32 length = obj->fslots[JSSLOT_ARRAY_LENGTH];
19571:     if (INDEX_TOO_SPARSE(obj, length)) {
19571:         if (!js_MakeArraySlow(cx, obj))
19571:             return JS_FALSE;
20408:         return array_push_slowly(cx, obj, 1, &v, rval);
19571:     }
19571: 
25475:     if (!EnsureCapacity(cx, obj, length + 1))
19571:         return JS_FALSE;
19571:     obj->fslots[JSSLOT_ARRAY_LENGTH] = length + 1;
19571: 
19571:     JS_ASSERT(obj->dslots[length] == JSVAL_HOLE);
19571:     obj->fslots[JSSLOT_ARRAY_COUNT]++;
19571:     obj->dslots[length] = v;
19571:     return IndexToValue(cx, obj->fslots[JSSLOT_ARRAY_LENGTH], rval);
19571: }
19571: 
24865: JSBool JS_FASTCALL
24861: js_ArrayCompPush(JSContext *cx, JSObject *obj, jsval v)
24861: {
24861:     JS_ASSERT(OBJ_IS_DENSE_ARRAY(cx, obj));
24861:     uint32_t length = (uint32_t) obj->fslots[JSSLOT_ARRAY_LENGTH];
25475:     JS_ASSERT(length <= js_DenseArrayCapacity(obj));
25475: 
25475:     if (length == js_DenseArrayCapacity(obj)) {
24861:         if (length >= ARRAY_INIT_LIMIT) {
24861:             JS_ReportErrorNumberUC(cx, js_GetErrorMessage, NULL,
24861:                                    JSMSG_ARRAY_INIT_TOO_BIG);
24861:             return JS_FALSE;
24861:         }
24861: 
25488:         if (!EnsureCapacity(cx, obj, length + 1))
24861:             return JS_FALSE;
24861:     }
24861:     obj->fslots[JSSLOT_ARRAY_LENGTH] = length + 1;
24861:     obj->fslots[JSSLOT_ARRAY_COUNT]++;
24861:     obj->dslots[length] = v;
24861:     return JS_TRUE;
24861: }
28088: JS_DEFINE_CALLINFO_3(extern, BOOL, js_ArrayCompPush, CONTEXT, OBJECT, JSVAL, 0, 0)
24861: 
20408: #ifdef JS_TRACER
20915: static jsval FASTCALL
20915: Array_p_push1(JSContext* cx, JSObject* obj, jsval v)
20408: {
25094:     JSAutoTempValueRooter tvr(cx, v);
20408:     if (OBJ_IS_DENSE_ARRAY(cx, obj)
25094:         ? array_push1_dense(cx, obj, v, tvr.addr())
25094:         : array_push_slowly(cx, obj, 1, tvr.addr(), tvr.addr())) {
25094:         return tvr.value();
20408:     }
27166:     js_SetBuiltinError(cx);
24612:     return JSVAL_VOID;
20408: }
20408: #endif
20408: 
20408: static JSBool
20408: array_push(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 4127: 
 4127:     /* Insist on one argument and obj of the expected class. */
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj)
 4127:         return JS_FALSE;
11848:     if (argc != 1 || !OBJ_IS_DENSE_ARRAY(cx, obj))
20408:         return array_push_slowly(cx, obj, argc, vp + 2, vp);
20408: 
20408:     return array_push1_dense(cx, obj, vp[2], vp);
 4127: }
11835: 
20408: static JSBool
20408: array_pop_slowly(JSContext *cx, JSObject* obj, jsval *vp)
 4127: {
    1:     jsuint index;
    1:     JSBool hole;
    1: 
19571:     if (!js_GetLengthProperty(cx, obj, &index))
11835:         return JS_FALSE;
19571:     if (index == 0) {
19571:         *vp = JSVAL_VOID;
19571:     } else {
19571:         index--;
19571: 
19571:         /* Get the to-be-deleted property's value into vp. */
19571:         if (!GetArrayElement(cx, obj, index, &hole, vp))
19571:             return JS_FALSE;
19571:         if (!hole && !DeleteArrayElement(cx, obj, index))
19571:             return JS_FALSE;
19571:     }
19571:     return js_SetLengthProperty(cx, obj, index);
19571: }
19571: 
20408: static JSBool
20408: array_pop_dense(JSContext *cx, JSObject* obj, jsval *vp)
19571: {
19571:     jsuint index;
19571:     JSBool hole;
19571: 
15603:     index = obj->fslots[JSSLOT_ARRAY_LENGTH];
15603:     if (index == 0) {
11835:         *vp = JSVAL_VOID;
11835:         return JS_TRUE;
15603:     }
11835:     index--;
15603:     if (!GetArrayElement(cx, obj, index, &hole, vp))
15603:         return JS_FALSE;
15603:     if (!hole && !DeleteArrayElement(cx, obj, index))
15603:         return JS_FALSE;
12231:     obj->fslots[JSSLOT_ARRAY_LENGTH] = index;
11835:     return JS_TRUE;
11835: }
11835: 
20408: #ifdef JS_TRACER
20915: static jsval FASTCALL
20915: Array_p_pop(JSContext* cx, JSObject* obj)
20408: {
25094:     JSAutoTempValueRooter tvr(cx);
20408:     if (OBJ_IS_DENSE_ARRAY(cx, obj)
25094:         ? array_pop_dense(cx, obj, tvr.addr())
25094:         : array_pop_slowly(cx, obj, tvr.addr())) {
25094:         return tvr.value();
20408:     }
27166:     js_SetBuiltinError(cx);
24612:     return JSVAL_VOID;
20408: }
20408: #endif
20408: 
20408: static JSBool
20408: array_pop(JSContext *cx, uintN argc, jsval *vp)
19571: {
19571:     JSObject *obj;
19571: 
19571:     obj = JS_THIS_OBJECT(cx, vp);
19571:     if (!obj)
    1:         return JS_FALSE;
19571:     if (OBJ_IS_DENSE_ARRAY(cx, obj))
20408:         return array_pop_dense(cx, obj, vp);
20408:     return array_pop_slowly(cx, obj, vp);
    1: }
    1: 
    1: static JSBool
 4127: array_shift(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
    1:     jsuint length, i;
28242:     JSBool hole;
    1: 
 4127:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
    1:     if (length == 0) {
 4127:         *vp = JSVAL_VOID;
    1:     } else {
    1:         length--;
    1: 
28242:         if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_PrototypeHasIndexedProperties(cx, obj) &&
28242:             length < js_DenseArrayCapacity(obj)) {
28242:             if (JS_LIKELY(obj->dslots != NULL)) {
28242:                 *vp = obj->dslots[0];
28242:                 if (*vp == JSVAL_HOLE)
28242:                     *vp = JSVAL_VOID;
28242:                 else
28242:                     obj->fslots[JSSLOT_ARRAY_COUNT]--;
28242:                 memmove(obj->dslots, obj->dslots + 1, length * sizeof(jsval));
28242:                 obj->dslots[length] = JSVAL_HOLE;
28242:             } else {
28242:                 /*
28242:                  * We don't need to modify the indexed properties of an empty array
28242:                  * with an explicitly set non-zero length when shift() is called on
28242:                  * it, but note fallthrough to reduce the length by one.
28242:                  */
28242:                 JS_ASSERT(obj->fslots[JSSLOT_ARRAY_COUNT] == 0);
28242:                 *vp = JSVAL_VOID;
28242:             }
28242:         } else {
 4127:             /* Get the to-be-deleted property's value into vp ASAP. */
 4127:             if (!GetArrayElement(cx, obj, 0, &hole, vp))
    1:                 return JS_FALSE;
    1: 
 6917:             /* Slide down the array above the first element. */
28242:             JSAutoTempValueRooter tvr(cx, JSVAL_NULL);
    1:             for (i = 0; i != length; i++) {
28242:                 if (!JS_CHECK_OPERATION_LIMIT(cx) ||
28242:                     !GetArrayElement(cx, obj, i + 1, &hole, tvr.addr()) ||
28242:                     !SetOrDeleteArrayElement(cx, obj, i, hole, tvr.value())) {
    1:                     return JS_FALSE;
28242:                 }
28242:             }
28242: 
28242:             /* Delete the only or last element when it exists. */
    1:             if (!hole && !DeleteArrayElement(cx, obj, length))
    1:                 return JS_FALSE;
    1:         }
28242:     }
    1:     return js_SetLengthProperty(cx, obj, length);
    1: }
    1: 
    1: static JSBool
 4127: array_unshift(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 6917:     jsval *argv;
26564:     jsuint length;
28242:     JSBool hole;
26564:     jsdouble last, newlen;
    1: 
 4127:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
26564:     newlen = length;
    1:     if (argc > 0) {
    1:         /* Slide up the array to make room for argc at the bottom. */
 4127:         argv = JS_ARGV(cx, vp);
    1:         if (length > 0) {
28242:             if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_PrototypeHasIndexedProperties(cx, obj) &&
28242:                 !INDEX_TOO_SPARSE(obj, newlen + argc)) {
28242:                 JS_ASSERT(newlen + argc == length + argc);
28242:                 if (!EnsureCapacity(cx, obj, length + argc))
28242:                     return JS_FALSE;
28242:                 memmove(obj->dslots + argc, obj->dslots, length * sizeof(jsval));
28242:                 for (uint32 i = 0; i < argc; i++)
28242:                     obj->dslots[i] = JSVAL_HOLE;
28242:             } else {
    1:                 last = length;
28242:                 jsdouble upperIndex = last + argc;
28242:                 JSAutoTempValueRooter tvr(cx, JSVAL_NULL);
    1:                 do {
28242:                     --last, --upperIndex;
28242:                     if (!JS_CHECK_OPERATION_LIMIT(cx) ||
28242:                         !GetArrayElement(cx, obj, last, &hole, tvr.addr()) ||
28242:                         !SetOrDeleteArrayElement(cx, obj, upperIndex, hole, tvr.value())) {
28242:                         return JS_FALSE;
28242:                     }
 6917:                 } while (last != 0);
28242:             }
    1:         }
    1: 
    1:         /* Copy from argv to the bottom of the array. */
28242:         if (!InitArrayElements(cx, obj, 0, argc, argv, TargetElementsAllHoles, SourceVectorAllValues))
    1:             return JS_FALSE;
    1: 
26564:         newlen += argc;
26564:         if (!js_SetLengthProperty(cx, obj, newlen))
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     /* Follow Perl by returning the new array length. */
26564:     return IndexToValue(cx, newlen, vp);
    1: }
    1: 
    1: static JSBool
 4127: array_splice(JSContext *cx, uintN argc, jsval *vp)
    1: {
 6917:     jsval *argv;
 4127:     JSObject *obj;
    1:     jsuint length, begin, end, count, delta, last;
    1:     jsdouble d;
28242:     JSBool hole;
    1:     JSObject *obj2;
    1: 
18402:     /*
18402:      * Create a new array value to return.  Our ECMA v2 proposal specs
18402:      * that splice always returns an array value, even when given no
18402:      * arguments.  We think this is best because it eliminates the need
18402:      * for callers to do an extra test to handle the empty splice case.
18402:      */
18402:     obj2 = js_NewArrayObject(cx, 0, NULL);
18402:     if (!obj2)
18402:         return JS_FALSE;
18402:     *vp = OBJECT_TO_JSVAL(obj2);
18402: 
 6917:     /* Nothing to do if no args.  Otherwise get length. */
    1:     if (argc == 0)
    1:         return JS_TRUE;
 4127:     argv = JS_ARGV(cx, vp);
 4127:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
    1: 
    1:     /* Convert the first argument into a starting index. */
12694:     d = js_ValueToNumber(cx, argv);
12694:     if (JSVAL_IS_NULL(*argv))
    1:         return JS_FALSE;
    1:     d = js_DoubleToInteger(d);
    1:     if (d < 0) {
    1:         d += length;
    1:         if (d < 0)
    1:             d = 0;
    1:     } else if (d > length) {
    1:         d = length;
    1:     }
    1:     begin = (jsuint)d; /* d has been clamped to uint32 */
    1:     argc--;
    1:     argv++;
    1: 
    1:     /* Convert the second argument from a count into a fencepost index. */
    1:     delta = length - begin;
    1:     if (argc == 0) {
    1:         count = delta;
    1:         end = length;
    1:     } else {
12694:         d = js_ValueToNumber(cx, argv);
12694:         if (JSVAL_IS_NULL(*argv))
    1:             return JS_FALSE;
    1:         d = js_DoubleToInteger(d);
    1:         if (d < 0)
    1:             d = 0;
    1:         else if (d > delta)
    1:             d = delta;
    1:         count = (jsuint)d;
    1:         end = begin + count;
    1:         argc--;
    1:         argv++;
    1:     }
    1: 
28242:     JSAutoTempValueRooter tvr(cx, JSVAL_NULL);
    1: 
    1:     /* If there are elements to remove, put them into the return value. */
    1:     if (count > 0) {
28242:         if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_PrototypeHasIndexedProperties(cx, obj) &&
28242:             !js_PrototypeHasIndexedProperties(cx, obj2) &&
28242:             end <= js_DenseArrayCapacity(obj)) {
28242:             if (!InitArrayObject(cx, obj2, count, obj->dslots + begin,
28242:                                  obj->fslots[JSSLOT_ARRAY_COUNT] !=
28242:                                  obj->fslots[JSSLOT_ARRAY_LENGTH])) {
28242:                 return JS_FALSE;
28242:             }
28242:         } else {
    1:             for (last = begin; last < end; last++) {
28242:                 if (!JS_CHECK_OPERATION_LIMIT(cx) ||
28242:                     !GetArrayElement(cx, obj, last, &hole, tvr.addr())) {
28242:                     return JS_FALSE;
28242:                 }
28242: 
28242:                 /* Copy tvr.value() to the new array unless it's a hole. */
28242:                 if (!hole && !SetArrayElement(cx, obj2, last - begin, tvr.value()))
28242:                     return JS_FALSE;
28242:             }
28242: 
28242:             if (!js_SetLengthProperty(cx, obj2, count))
28242:                 return JS_FALSE;
28242:         }
    1:     }
    1: 
    1:     /* Find the direction (up or down) to copy and make way for argv. */
    1:     if (argc > count) {
    1:         delta = (jsuint)argc - count;
    1:         last = length;
28242:         if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_PrototypeHasIndexedProperties(cx, obj) &&
28243:             length <= js_DenseArrayCapacity(obj) &&
28243:             (length == 0 || obj->dslots[length - 1] != JSVAL_HOLE)) {
28242:             if (!EnsureCapacity(cx, obj, length + delta))
28242:                 return JS_FALSE;
28242:             /* (uint) end could be 0, so we can't use a vanilla >= test. */
    1:             while (last-- > end) {
28242:                 jsval srcval = obj->dslots[last];
28242:                 jsval* dest = &obj->dslots[last + delta];
28242:                 if (*dest == JSVAL_HOLE && srcval != JSVAL_HOLE)
28242:                     obj->fslots[JSSLOT_ARRAY_COUNT]++;
28242:                 *dest = srcval;
28242:             }
28242:             obj->fslots[JSSLOT_ARRAY_LENGTH] += delta;
28242:         } else {
28242:             /* (uint) end could be 0, so we can't use a vanilla >= test. */
28242:             while (last-- > end) {
28242:                 if (!JS_CHECK_OPERATION_LIMIT(cx) ||
28242:                     !GetArrayElement(cx, obj, last, &hole, tvr.addr()) ||
28242:                     !SetOrDeleteArrayElement(cx, obj, last + delta, hole, tvr.value())) {
28242:                     return JS_FALSE;
28242:                 }
28242:             }
    1:         }
    1:         length += delta;
    1:     } else if (argc < count) {
    1:         delta = count - (jsuint)argc;
28242:         if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_PrototypeHasIndexedProperties(cx, obj) &&
28242:             length <= js_DenseArrayCapacity(obj)) {
28242:             /* (uint) end could be 0, so we can't use a vanilla >= test. */
    1:             for (last = end; last < length; last++) {
28242:                 jsval srcval = obj->dslots[last];
28242:                 jsval* dest = &obj->dslots[last - delta];
28242:                 if (*dest == JSVAL_HOLE && srcval != JSVAL_HOLE)
28242:                     obj->fslots[JSSLOT_ARRAY_COUNT]++;
28242:                 *dest = srcval;
28242:             }
28242:         } else {
28242:             for (last = end; last < length; last++) {
28242:                 if (!JS_CHECK_OPERATION_LIMIT(cx) ||
28242:                     !GetArrayElement(cx, obj, last, &hole, tvr.addr()) ||
28242:                     !SetOrDeleteArrayElement(cx, obj, last - delta, hole, tvr.value())) {
28242:                     return JS_FALSE;
28242:                 }
28242:             }
    1:         }
    1:         length -= delta;
    1:     }
    1: 
28242:     /*
28242:      * Copy from argv into the hole to complete the splice, and update length in
28242:      * case we deleted elements from the end.
28242:      */
28242:     return InitArrayElements(cx, obj, begin, argc, argv, TargetElementsMayContainValues,
28242:                              SourceVectorAllValues) &&
28242:            js_SetLengthProperty(cx, obj, length);
    1: }
    1: 
    1: /*
    1:  * Python-esque sequence operations.
    1:  */
    1: static JSBool
 4127: array_concat(JSContext *cx, uintN argc, jsval *vp)
    1: {
 6917:     jsval *argv, v;
15282:     JSObject *aobj, *nobj;
    1:     jsuint length, alength, slot;
    1:     uintN i;
 6917:     JSBool hole, ok;
 6917:     JSTempValueRooter tvr;
    1: 
 4127:     /* Treat our |this| object as the first argument; see ECMA 15.4.4.4. */
 6917:     argv = JS_ARGV(cx, vp) - 1;
 4127:     JS_ASSERT(JS_THIS_OBJECT(cx, vp) == JSVAL_TO_OBJECT(argv[0]));
    1: 
 4127:     /* Create a new Array object and root it using *vp. */
11835:     aobj = JS_THIS_OBJECT(cx, vp);
11848:     if (OBJ_IS_DENSE_ARRAY(cx, aobj)) {
15282:         /*
25488:          * Clone aobj but pass the minimum of its length and capacity, to
25488:          * handle a = [1,2,3]; a.length = 10000 "dense" cases efficiently. In
25488:          * such a case we'll pass 8 (not 3) due to ARRAY_CAPACITY_MIN, which
25488:          * will cause nobj to be over-allocated to 16. But in the normal case
25488:          * where length is <= capacity, nobj and aobj will have the same
25488:          * capacity.
15282:          */
15282:         length = aobj->fslots[JSSLOT_ARRAY_LENGTH];
25475:         jsuint capacity = js_DenseArrayCapacity(aobj);
15282:         nobj = js_NewArrayObject(cx, JS_MIN(length, capacity), aobj->dslots,
15282:                                  aobj->fslots[JSSLOT_ARRAY_COUNT] !=
15282:                                  (jsval) length);
11835:         if (!nobj)
11835:             return JS_FALSE;
12231:         nobj->fslots[JSSLOT_ARRAY_LENGTH] = length;
11835:         *vp = OBJECT_TO_JSVAL(nobj);
11835:         if (argc == 0)
11835:             return JS_TRUE;
11835:         argc--;
11835:         argv++;
11835:     } else {
    1:         nobj = js_NewArrayObject(cx, 0, NULL);
    1:         if (!nobj)
    1:             return JS_FALSE;
 4129:         *vp = OBJECT_TO_JSVAL(nobj);
11835:         length = 0;
11835:     }
    1: 
18989:     MUST_FLOW_THROUGH("out");
 6917:     JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &tvr);
    1: 
    1:     /* Loop over [0, argc] to concat args into nobj, expanding all Arrays. */
    1:     for (i = 0; i <= argc; i++) {
25087:         ok = JS_CHECK_OPERATION_LIMIT(cx);
 6917:         if (!ok)
 6917:             goto out;
    1:         v = argv[i];
13554:         if (!JSVAL_IS_PRIMITIVE(v)) {
12674:             JSObject *wobj;
12674: 
    1:             aobj = JSVAL_TO_OBJECT(v);
12674:             wobj = js_GetWrappedObject(cx, aobj);
13554:             if (OBJ_IS_ARRAY(cx, wobj)) {
 6917:                 ok = OBJ_GET_PROPERTY(cx, aobj,
    1:                                       ATOM_TO_JSID(cx->runtime->atomState
    1:                                                    .lengthAtom),
 6917:                                       &tvr.u.value);
 6917:                 if (!ok)
 6917:                     goto out;
12694:                 alength = ValueIsLength(cx, &tvr.u.value);
12694:                 ok = !JSVAL_IS_NULL(tvr.u.value);
 6917:                 if (!ok)
 6917:                     goto out;
    1:                 for (slot = 0; slot < alength; slot++) {
25087:                     ok = JS_CHECK_OPERATION_LIMIT(cx) &&
 6917:                          GetArrayElement(cx, aobj, slot, &hole,
 6917:                                          &tvr.u.value);
 6917:                     if (!ok)
 6917:                         goto out;
    1: 
    1:                     /*
    1:                      * Per ECMA 262, 15.4.4.4, step 9, ignore non-existent
    1:                      * properties.
    1:                      */
 6917:                     if (!hole) {
 6917:                         ok = SetArrayElement(cx, nobj, length + slot,
 6917:                                              tvr.u.value);
 6917:                         if (!ok)
 6917:                             goto out;
    1:                     }
    1:                 }
    1:                 length += alength;
    1:                 continue;
    1:             }
    1:         }
    1: 
 6917:         ok = SetArrayElement(cx, nobj, length, v);
 6917:         if (!ok)
 6917:             goto out;
    1:         length++;
    1:     }
    1: 
 6917:     ok = js_SetLengthProperty(cx, nobj, length);
 6917: 
 6917: out:
 6917:     JS_POP_TEMP_ROOT(cx, &tvr);
 6917:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: array_slice(JSContext *cx, uintN argc, jsval *vp)
    1: {
 6917:     jsval *argv;
 4127:     JSObject *nobj, *obj;
    1:     jsuint length, begin, end, slot;
    1:     jsdouble d;
28242:     JSBool hole;
    1: 
 4127:     argv = JS_ARGV(cx, vp);
    1: 
 4127:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
    1:     begin = 0;
    1:     end = length;
    1: 
    1:     if (argc > 0) {
12694:         d = js_ValueToNumber(cx, &argv[0]);
12694:         if (JSVAL_IS_NULL(argv[0]))
    1:             return JS_FALSE;
    1:         d = js_DoubleToInteger(d);
    1:         if (d < 0) {
    1:             d += length;
    1:             if (d < 0)
    1:                 d = 0;
    1:         } else if (d > length) {
    1:             d = length;
    1:         }
    1:         begin = (jsuint)d;
    1: 
    1:         if (argc > 1) {
12694:             d = js_ValueToNumber(cx, &argv[1]);
12694:             if (JSVAL_IS_NULL(argv[1]))
    1:                 return JS_FALSE;
    1:             d = js_DoubleToInteger(d);
    1:             if (d < 0) {
    1:                 d += length;
    1:                 if (d < 0)
    1:                     d = 0;
    1:             } else if (d > length) {
    1:                 d = length;
    1:             }
    1:             end = (jsuint)d;
    1:         }
    1:     }
    1: 
    1:     if (begin > end)
    1:         begin = end;
    1: 
28242:     if (OBJ_IS_DENSE_ARRAY(cx, obj) && end <= js_DenseArrayCapacity(obj) &&
28242:         !js_PrototypeHasIndexedProperties(cx, obj)) {
15281:         nobj = js_NewArrayObject(cx, end - begin, obj->dslots + begin,
15282:                                  obj->fslots[JSSLOT_ARRAY_COUNT] !=
15282:                                  obj->fslots[JSSLOT_ARRAY_LENGTH]);
11835:         if (!nobj)
11835:             return JS_FALSE;
11835:         *vp = OBJECT_TO_JSVAL(nobj);
11835:         return JS_TRUE;
11835:     }
11835: 
11835:     /* Create a new Array object and root it using *vp. */
11835:     nobj = js_NewArrayObject(cx, 0, NULL);
11835:     if (!nobj)
11835:         return JS_FALSE;
11835:     *vp = OBJECT_TO_JSVAL(nobj);
11835: 
28242:     JSAutoTempValueRooter tvr(cx, JSVAL_NULL);
    1:     for (slot = begin; slot < end; slot++) {
28242:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
28242:             !GetArrayElement(cx, obj, slot, &hole, tvr.addr())) {
28242:             return JS_FALSE;
28242:         }
28242:         if (!hole && !SetArrayElement(cx, nobj, slot - begin, tvr.value()))
28242:             return JS_FALSE;
28242:     }
28242: 
28242:     return js_SetLengthProperty(cx, nobj, end - begin);
    1: }
    1: 
    1: #if JS_HAS_ARRAY_EXTRAS
    1: 
    1: static JSBool
 4127: array_indexOfHelper(JSContext *cx, JSBool isLast, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
    1:     jsuint length, i, stop;
16519:     jsval tosearch;
    1:     jsint direction;
    1:     JSBool hole;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
    1:     if (length == 0)
    1:         goto not_found;
    1: 
    1:     if (argc <= 1) {
    1:         i = isLast ? length - 1 : 0;
16519:         tosearch = (argc != 0) ? vp[2] : JSVAL_VOID;
    1:     } else {
    1:         jsdouble start;
    1: 
16519:         tosearch = vp[2];
12694:         start = js_ValueToNumber(cx, &vp[3]);
12694:         if (JSVAL_IS_NULL(vp[3]))
    1:             return JS_FALSE;
    1:         start = js_DoubleToInteger(start);
    1:         if (start < 0) {
    1:             start += length;
    1:             if (start < 0) {
    1:                 if (isLast)
    1:                     goto not_found;
    1:                 i = 0;
    1:             } else {
    1:                 i = (jsuint)start;
    1:             }
    1:         } else if (start >= length) {
    1:             if (!isLast)
    1:                 goto not_found;
    1:             i = length - 1;
    1:         } else {
    1:             i = (jsuint)start;
    1:         }
    1:     }
    1: 
    1:     if (isLast) {
    1:         stop = 0;
    1:         direction = -1;
    1:     } else {
    1:         stop = length - 1;
    1:         direction = 1;
    1:     }
    1: 
    1:     for (;;) {
25087:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 4127:             !GetArrayElement(cx, obj, (jsuint)i, &hole, vp)) {
    1:             return JS_FALSE;
    1:         }
16519:         if (!hole && js_StrictlyEqual(cx, *vp, tosearch))
12850:             return js_NewNumberInRootedValue(cx, i, vp);
    1:         if (i == stop)
    1:             goto not_found;
    1:         i += direction;
    1:     }
    1: 
    1:   not_found:
 4127:     *vp = INT_TO_JSVAL(-1);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: array_indexOf(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return array_indexOfHelper(cx, JS_FALSE, argc, vp);
    1: }
    1: 
    1: static JSBool
 4127: array_lastIndexOf(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return array_indexOfHelper(cx, JS_TRUE, argc, vp);
    1: }
    1: 
    1: /* Order is important; extras that take a predicate funarg must follow MAP. */
    1: typedef enum ArrayExtraMode {
    1:     FOREACH,
    1:     REDUCE,
    1:     REDUCE_RIGHT,
    1:     MAP,
    1:     FILTER,
    1:     SOME,
    1:     EVERY
    1: } ArrayExtraMode;
    1: 
    1: #define REDUCE_MODE(mode) ((mode) == REDUCE || (mode) == REDUCE_RIGHT)
    1: 
29887: static JSBool
 4127: array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
    1:     jsuint length, newlen;
 6040:     jsval *argv, *elemroot, *invokevp, *sp;
 4127:     JSBool ok, cond, hole;
    1:     JSObject *callable, *thisp, *newarr;
    1:     jsint start, end, step, i;
    1:     void *mark;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * First, get or compute our callee, so that we error out consistently
    1:      * when passed a non-callable object.
    1:      */
16519:     if (argc == 0) {
16519:         js_ReportMissingArg(cx, vp, 0);
16519:         return JS_FALSE;
16519:     }
 6040:     argv = vp + 2;
    1:     callable = js_ValueToCallableObject(cx, &argv[0], JSV2F_SEARCH_STACK);
    1:     if (!callable)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Set our initial return condition, used for zero-length array cases
    1:      * (and pre-size our map return to match our known length, for all cases).
    1:      */
    1: #ifdef __GNUC__ /* quell GCC overwarning */
    1:     newlen = 0;
    1:     newarr = NULL;
    1: #endif
    1:     start = 0, end = length, step = 1;
 4127: 
    1:     switch (mode) {
    1:       case REDUCE_RIGHT:
    1:         start = length - 1, end = -1, step = -1;
    1:         /* FALL THROUGH */
    1:       case REDUCE:
    1:         if (length == 0 && argc == 1) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_EMPTY_ARRAY_REDUCE);
    1:             return JS_FALSE;
    1:         }
    1:         if (argc >= 2) {
 6040:             *vp = argv[1];
    1:         } else {
 2888:             do {
 6040:                 if (!GetArrayElement(cx, obj, start, &hole, vp))
    1:                     return JS_FALSE;
    1:                 start += step;
 2888:             } while (hole && start != end);
 2888: 
 2888:             if (hole && start == end) {
 2888:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 2888:                                      JSMSG_EMPTY_ARRAY_REDUCE);
 2888:                 return JS_FALSE;
 2888:             }
    1:         }
    1:         break;
    1:       case MAP:
    1:       case FILTER:
    1:         newlen = (mode == MAP) ? length : 0;
    1:         newarr = js_NewArrayObject(cx, newlen, NULL);
    1:         if (!newarr)
    1:             return JS_FALSE;
 6040:         *vp = OBJECT_TO_JSVAL(newarr);
    1:         break;
    1:       case SOME:
 6040:         *vp = JSVAL_FALSE;
    1:         break;
    1:       case EVERY:
 6040:         *vp = JSVAL_TRUE;
    1:         break;
    1:       case FOREACH:
 6040:         *vp = JSVAL_VOID;
    1:         break;
    1:     }
    1: 
    1:     if (length == 0)
    1:         return JS_TRUE;
    1: 
    1:     if (argc > 1 && !REDUCE_MODE(mode)) {
    1:         if (!js_ValueToObject(cx, argv[1], &thisp))
    1:             return JS_FALSE;
    1:         argv[1] = OBJECT_TO_JSVAL(thisp);
    1:     } else {
    1:         thisp = NULL;
    1:     }
    1: 
    1:     /*
 6040:      * For all but REDUCE, we call with 3 args (value, index, array). REDUCE
 6040:      * requires 4 args (accum, value, index, array).
    1:      */
29887:     js_LeaveTrace(cx);
    1:     argc = 3 + REDUCE_MODE(mode);
 6040:     elemroot = js_AllocStack(cx, 1 + 2 + argc, &mark);
 6040:     if (!elemroot)
    1:         return JS_FALSE;
    1: 
18989:     MUST_FLOW_THROUGH("out");
 6040:     ok = JS_TRUE;
 6040:     invokevp = elemroot + 1;
    1: 
    1:     for (i = start; i != end; i += step) {
25087:         ok = JS_CHECK_OPERATION_LIMIT(cx) &&
 6040:              GetArrayElement(cx, obj, i, &hole, elemroot);
    1:         if (!ok)
 6040:             goto out;
    1:         if (hole)
    1:             continue;
    1: 
    1:         /*
    1:          * Push callable and 'this', then args. We must do this for every
 6040:          * iteration around the loop since js_Invoke uses spbase[0] for return
 6040:          * value storage, while some native functions use spbase[1] for local
 4127:          * rooting.
    1:          */
 6040:         sp = invokevp;
    1:         *sp++ = OBJECT_TO_JSVAL(callable);
    1:         *sp++ = OBJECT_TO_JSVAL(thisp);
    1:         if (REDUCE_MODE(mode))
    1:             *sp++ = *vp;
 6040:         *sp++ = *elemroot;
    1:         *sp++ = INT_TO_JSVAL(i);
    1:         *sp++ = OBJECT_TO_JSVAL(obj);
    1: 
    1:         /* Do the call. */
14721:         ok = js_Invoke(cx, argc, invokevp, 0);
    1:         if (!ok)
    1:             break;
    1: 
10449:         if (mode > MAP)
10449:             cond = js_ValueToBoolean(*invokevp);
10449: #ifdef __GNUC__ /* quell GCC overwarning */
10449:         else
    1:             cond = JS_FALSE;
10449: #endif
    1: 
    1:         switch (mode) {
    1:           case FOREACH:
    1:             break;
    1:           case REDUCE:
    1:           case REDUCE_RIGHT:
 6040:             *vp = *invokevp;
    1:             break;
    1:           case MAP:
 6040:             ok = SetArrayElement(cx, newarr, i, *invokevp);
    1:             if (!ok)
    1:                 goto out;
    1:             break;
    1:           case FILTER:
    1:             if (!cond)
    1:                 break;
 6040:             /* The filter passed *elemroot, so push it onto our result. */
 6040:             ok = SetArrayElement(cx, newarr, newlen++, *elemroot);
    1:             if (!ok)
    1:                 goto out;
    1:             break;
    1:           case SOME:
    1:             if (cond) {
 6040:                 *vp = JSVAL_TRUE;
    1:                 goto out;
    1:             }
    1:             break;
    1:           case EVERY:
    1:             if (!cond) {
 6040:                 *vp = JSVAL_FALSE;
    1:                 goto out;
    1:             }
    1:             break;
    1:         }
    1:     }
    1: 
    1:   out:
    1:     js_FreeStack(cx, mark);
    1:     if (ok && mode == FILTER)
    1:         ok = js_SetLengthProperty(cx, newarr, newlen);
    1:     return ok;
    1: }
    1: 
29887: static JSBool
 4127: array_forEach(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return array_extra(cx, FOREACH, argc, vp);
    1: }
    1: 
29887: static JSBool
 4127: array_map(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return array_extra(cx, MAP, argc, vp);
    1: }
    1: 
29887: static JSBool
 4127: array_reduce(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return array_extra(cx, REDUCE, argc, vp);
    1: }
    1: 
29887: static JSBool
 4127: array_reduceRight(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return array_extra(cx, REDUCE_RIGHT, argc, vp);
    1: }
    1: 
29887: static JSBool
 4127: array_filter(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return array_extra(cx, FILTER, argc, vp);
    1: }
    1: 
29887: static JSBool
 4127: array_some(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return array_extra(cx, SOME, argc, vp);
    1: }
    1: 
29887: static JSBool
 4127: array_every(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return array_extra(cx, EVERY, argc, vp);
    1: }
    1: #endif
    1: 
 4127: static JSPropertySpec array_props[] = {
 4127:     {js_length_str,   -1,   JSPROP_SHARED | JSPROP_PERMANENT,
 4127:                             array_length_getter,    array_length_setter},
 4127:     {0,0,0,0,0}
 4127: };
 4127: 
21685: JS_DEFINE_TRCINFO_1(array_toString,
21685:     (2, (static, STRING_FAIL, Array_p_toString, CONTEXT, THIS,      0, 0)))
20930: JS_DEFINE_TRCINFO_1(array_join,
20930:     (3, (static, STRING_FAIL, Array_p_join, CONTEXT, THIS, STRING,  0, 0)))
20930: JS_DEFINE_TRCINFO_1(array_push,
20930:     (3, (static, JSVAL_FAIL, Array_p_push1, CONTEXT, THIS, JSVAL,   0, 0)))
20930: JS_DEFINE_TRCINFO_1(array_pop,
20930:     (2, (static, JSVAL_FAIL, Array_p_pop, CONTEXT, THIS,            0, 0)))
20408: 
    1: static JSFunctionSpec array_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,      array_toSource,     0,0),
    1: #endif
21685:     JS_TN(js_toString_str,      array_toString,     0,0, array_toString_trcinfo),
16519:     JS_FN(js_toLocaleString_str,array_toLocaleString,0,0),
    1: 
    1:     /* Perl-ish methods. */
20408:     JS_TN("join",               array_join,         1,JSFUN_GENERIC_NATIVE, array_join_trcinfo),
16519:     JS_FN("reverse",            array_reverse,      0,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("sort",               array_sort,         1,JSFUN_GENERIC_NATIVE),
20408:     JS_TN("push",               array_push,         1,JSFUN_GENERIC_NATIVE, array_push_trcinfo),
20408:     JS_TN("pop",                array_pop,          0,JSFUN_GENERIC_NATIVE, array_pop_trcinfo),
16519:     JS_FN("shift",              array_shift,        0,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("unshift",            array_unshift,      1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("splice",             array_splice,       2,JSFUN_GENERIC_NATIVE),
    1: 
11835:     /* Pythonic sequence methods. */
16519:     JS_FN("concat",             array_concat,       1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("slice",              array_slice,        2,JSFUN_GENERIC_NATIVE),
    1: 
    1: #if JS_HAS_ARRAY_EXTRAS
16519:     JS_FN("indexOf",            array_indexOf,      1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("lastIndexOf",        array_lastIndexOf,  1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("forEach",            array_forEach,      1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("map",                array_map,          1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("reduce",             array_reduce,       1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("reduceRight",        array_reduceRight,  1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("filter",             array_filter,       1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("some",               array_some,         1,JSFUN_GENERIC_NATIVE),
16519:     JS_FN("every",              array_every,        1,JSFUN_GENERIC_NATIVE),
    1: #endif
    1: 
 4127:     JS_FS_END
    1: };
    1: 
18300: JSBool
18300: js_Array(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     jsuint length;
    1:     jsval *vector;
    1: 
    1:     /* If called without new, replace obj with a new Array object. */
22652:     if (!JS_IsConstructing(cx)) {
13427:         obj = js_NewObject(cx, &js_ArrayClass, NULL, NULL, 0);
    1:         if (!obj)
    1:             return JS_FALSE;
    1:         *rval = OBJECT_TO_JSVAL(obj);
    1:     }
    1: 
    1:     if (argc == 0) {
    1:         length = 0;
    1:         vector = NULL;
    1:     } else if (argc > 1) {
    1:         length = (jsuint) argc;
    1:         vector = argv;
    1:     } else if (!JSVAL_IS_NUMBER(argv[0])) {
    1:         length = 1;
    1:         vector = argv;
    1:     } else {
12694:         length = ValueIsLength(cx, &argv[0]);
12694:         if (JSVAL_IS_NULL(argv[0]))
    1:             return JS_FALSE;
    1:         vector = NULL;
    1:     }
    1:     return InitArrayObject(cx, obj, length, vector);
    1: }
    1: 
20408: JS_STATIC_ASSERT(JSSLOT_PRIVATE == JSSLOT_ARRAY_LENGTH);
20408: JS_STATIC_ASSERT(JSSLOT_ARRAY_LENGTH + 1 == JSSLOT_ARRAY_COUNT);
20408: 
20408: #ifdef JS_TRACER
20408: 
20408: JSObject* FASTCALL
28086: js_NewEmptyArray(JSContext* cx, JSObject* proto)
20408: {
20408:     JS_ASSERT(OBJ_IS_ARRAY(cx, proto));
20408: 
20408:     JS_ASSERT(JS_ON_TRACE(cx));
20408:     JSObject* obj = (JSObject*) js_NewGCThing(cx, GCX_OBJECT, sizeof(JSObject));
20408:     if (!obj)
20408:         return NULL;
20408: 
28353:     /* Initialize all fields of JSObject. */
28353:     obj->map = const_cast<JSObjectMap *>(&SharedArrayMap);
28353:     obj->classword = jsuword(&js_ArrayClass);
20408:     obj->fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(proto);
20408:     obj->fslots[JSSLOT_PARENT] = proto->fslots[JSSLOT_PARENT];
20408: 
20408:     obj->fslots[JSSLOT_ARRAY_LENGTH] = 0;
20408:     obj->fslots[JSSLOT_ARRAY_COUNT] = 0;
20408:     for (unsigned i = JSSLOT_ARRAY_COUNT + 1; i != JS_INITIAL_NSLOTS; ++i)
20408:         obj->fslots[i] = JSVAL_VOID;
20408:     obj->dslots = NULL;
20408:     return obj;
20408: }
28088: JS_DEFINE_CALLINFO_2(extern, OBJECT, js_NewEmptyArray, CONTEXT, OBJECT, 0, 0)
20408: 
20408: JSObject* FASTCALL
28086: js_NewUninitializedArray(JSContext* cx, JSObject* proto, uint32 len)
20408: {
20408:     JS_ASSERT(JS_ON_TRACE(cx));
28086:     JSObject* obj = js_NewEmptyArray(cx, proto);
28086:     if (!obj)
28086:         return NULL;
28086:     obj->fslots[JSSLOT_ARRAY_LENGTH] = len;
28086:     if (!ResizeSlots(cx, obj, 0, JS_MAX(len, ARRAY_CAPACITY_MIN)))
22626:         return NULL;
22626:     return obj;
22626: }
28088: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_NewUninitializedArray, CONTEXT, OBJECT, UINT32, 0, 0)
22626: 
20408: #endif /* JS_TRACER */
20408: 
    1: JSObject *
    1: js_InitArrayClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto;
    1: 
11835:     /* Initialize the ops structure used by slow arrays */
11835:     memcpy(&js_SlowArrayObjectOps, &js_ObjectOps, sizeof(JSObjectOps));
11835:     js_SlowArrayObjectOps.trace = slowarray_trace;
11835:     js_SlowArrayObjectOps.enumerate = slowarray_enumerate;
11835:     js_SlowArrayObjectOps.call = NULL;
11835: 
18300:     proto = JS_InitClass(cx, obj, NULL, &js_ArrayClass, js_Array, 1,
 4127:                          array_props, array_methods, NULL, NULL);
    1: 
    1:     /* Initialize the Array prototype object so it gets a length property. */
    1:     if (!proto || !InitArrayObject(cx, proto, 0, NULL))
    1:         return NULL;
    1:     return proto;
    1: }
    1: 
    1: JSObject *
15281: js_NewArrayObject(JSContext *cx, jsuint length, jsval *vector, JSBool holey)
    1: {
    1:     JSTempValueRooter tvr;
    1:     JSObject *obj;
    1: 
13427:     obj = js_NewObject(cx, &js_ArrayClass, NULL, NULL, 0);
    1:     if (!obj)
    1:         return NULL;
    1: 
    1:     JS_PUSH_TEMP_ROOT_OBJECT(cx, obj, &tvr);
15281:     if (!InitArrayObject(cx, obj, length, vector, holey))
    1:         obj = NULL;
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1: 
    1:     /* Set/clear newborn root, in case we lost it.  */
 5917:     cx->weakRoots.newborn[GCX_OBJECT] = obj;
    1:     return obj;
    1: }
11835: 
11835: JSObject *
11835: js_NewSlowArrayObject(JSContext *cx)
11835: {
13427:     JSObject *obj = js_NewObject(cx, &js_SlowArrayClass, NULL, NULL, 0);
11835:     if (obj)
12231:         obj->fslots[JSSLOT_ARRAY_LENGTH] = 0;
11835:     return obj;
11835: }
11835: 
11835: #ifdef DEBUG_ARRAYS
11835: JSBool
11835: js_ArrayInfo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
11835: {
11835:     uintN i;
11835:     JSObject *array;
11835: 
11835:     for (i = 0; i < argc; i++) {
11835:         char *bytes;
11835: 
11835:         bytes = js_DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, argv[i],
11835:                                            NULL);
11835:         if (!bytes)
11835:             return JS_FALSE;
11835:         if (JSVAL_IS_PRIMITIVE(argv[i]) ||
11835:             !OBJ_IS_ARRAY(cx, (array = JSVAL_TO_OBJECT(argv[i])))) {
11835:             fprintf(stderr, "%s: not array\n", bytes);
11835:             JS_free(cx, bytes);
11835:             continue;
11835:         }
11835:         fprintf(stderr, "%s: %s (len %lu", bytes,
11848:                 OBJ_IS_DENSE_ARRAY(cx, array) ? "dense" : "sparse",
12231:                 array->fslots[JSSLOT_ARRAY_LENGTH]);
11848:         if (OBJ_IS_DENSE_ARRAY(cx, array)) {
25475:             fprintf(stderr, ", count %lu, capacity %lu",
12231:                     array->fslots[JSSLOT_ARRAY_COUNT],
25475:                     js_DenseArrayCapacity(array));
11835:         }
11835:         fputs(")\n", stderr);
11835:         JS_free(cx, bytes);
11835:     }
11835:     return JS_TRUE;
11835: }
11835: #endif
18268: 
18293: JS_FRIEND_API(JSBool)
29066: js_CoerceArrayToCanvasImageData(JSObject *obj, jsuint offset, jsuint count,
18268:                                 JSUint8 *dest)
18268: {
18268:     uint32 length;
18268: 
29066:     if (!obj || !js_IsDenseArray(obj))
18268:         return JS_FALSE;
18268: 
18268:     length = obj->fslots[JSSLOT_ARRAY_LENGTH];
18268:     if (length < offset + count)
18268:         return JS_FALSE;
18268: 
18268:     JSUint8 *dp = dest;
18268:     for (uintN i = offset; i < offset+count; i++) {
29066:         jsval v = obj->dslots[i];
29066:         if (JSVAL_IS_INT(v)) {
29066:             jsint vi = JSVAL_TO_INT(v);
29066:             if (jsuint(vi) > 255)
29066:                 vi = (vi < 0) ? 0 : 255;
29066:             *dp++ = JSUint8(vi);
29066:         } else if (JSVAL_IS_DOUBLE(v)) {
29066:             jsdouble vd = *JSVAL_TO_DOUBLE(v);
29066:             if (!(vd >= 0)) /* Not < so that NaN coerces to 0 */
29066:                 *dp++ = 0;
29066:             else if (vd > 255)
29066:                 *dp++ = 255;
29066:             else {
29066:                 jsdouble toTruncate = vd + 0.5;
29066:                 JSUint8 val = JSUint8(toTruncate);
29066: 
29066:                 /*
29066:                  * now val is rounded to nearest, ties rounded up.  We want
29066:                  * rounded to nearest ties to even, so check whether we had a
29066:                  * tie.
29066:                  */
29066:                 if (val == toTruncate) {
29066:                   /*
29066:                    * It was a tie (since adding 0.5 gave us the exact integer
29066:                    * we want).  Since we rounded up, we either already have an
29066:                    * even number or we have an odd number but the number we
29066:                    * want is one less.  So just unconditionally masking out the
29066:                    * ones bit should do the trick to get us the value we
29066:                    * want.
29066:                    */
29066:                   *dp++ = (val & ~1);
29066:                 } else {
29066:                   *dp++ = val;
29066:                 }
29066:             }
29066:         } else {
18268:             return JS_FALSE;
29066:         }
18268:     }
18268: 
18268:     return JS_TRUE;
18268: }
