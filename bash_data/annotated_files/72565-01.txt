29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18308:  * vim: set ts=8 sw=4 et tw=79:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsemit_h___
    1: #define jsemit_h___
    1: /*
    1:  * JS bytecode generation.
    1:  */
    1: #include "jstypes.h"
    1: #include "jsatom.h"
    1: #include "jsopcode.h"
27012: #include "jsparse.h"
 1825: #include "jsscript.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
    1: /*
    1:  * NB: If you add enumerators for scope statements, add them between STMT_WITH
    1:  * and STMT_CATCH, or you will break the STMT_TYPE_IS_SCOPE macro. If you add
    1:  * non-looping statement enumerators, add them before STMT_DO_LOOP or you will
    1:  * break the STMT_TYPE_IS_LOOP macro.
    1:  *
    1:  * Also remember to keep the statementName array in jsemit.c in sync.
    1:  */
    1: typedef enum JSStmtType {
    1:     STMT_LABEL,                 /* labeled statement:  L: s */
    1:     STMT_IF,                    /* if (then) statement */
    1:     STMT_ELSE,                  /* else clause of if statement */
20413:     STMT_SEQ,                   /* synthetic sequence of statements */
    1:     STMT_BLOCK,                 /* compound statement: { s1[;... sN] } */
10030:     STMT_SWITCH,                /* switch statement */
    1:     STMT_WITH,                  /* with statement */
    1:     STMT_CATCH,                 /* catch block */
    1:     STMT_TRY,                   /* try block */
    1:     STMT_FINALLY,               /* finally block */
    1:     STMT_SUBROUTINE,            /* gosub-target subroutine body */
    1:     STMT_DO_LOOP,               /* do/while loop statement */
    1:     STMT_FOR_LOOP,              /* for loop statement */
    1:     STMT_FOR_IN_LOOP,           /* for/in loop statement */
11672:     STMT_WHILE_LOOP,            /* while loop statement */
11672:     STMT_LIMIT
    1: } JSStmtType;
    1: 
    1: #define STMT_TYPE_IN_RANGE(t,b,e) ((uint)((t) - (b)) <= (uintN)((e) - (b)))
    1: 
    1: /*
    1:  * A comment on the encoding of the JSStmtType enum and type-testing macros:
    1:  *
    1:  * STMT_TYPE_MAYBE_SCOPE tells whether a statement type is always, or may
10030:  * become, a lexical scope.  It therefore includes block and switch (the two
10030:  * low-numbered "maybe" scope types) and excludes with (with has dynamic scope
10030:  * pending the "reformed with" in ES4/JS2).  It includes all try-catch-finally
10030:  * types, which are high-numbered maybe-scope types.
    1:  *
    1:  * STMT_TYPE_LINKS_SCOPE tells whether a JSStmtInfo of the given type eagerly
10030:  * links to other scoping statement info records.  It excludes the two early
10030:  * "maybe" types, block and switch, as well as the try and both finally types,
10030:  * since try and the other trailing maybe-scope types don't need block scope
10030:  * unless they contain let declarations.
    1:  *
 9832:  * We treat WITH as a static scope because it prevents lexical binding from
18084:  * continuing further up the static scope chain. With the lost "reformed with"
18084:  * proposal for ES4, we would be able to model it statically, too.
    1:  */
    1: #define STMT_TYPE_MAYBE_SCOPE(type)                                           \
    1:     (type != STMT_WITH &&                                                     \
    1:      STMT_TYPE_IN_RANGE(type, STMT_BLOCK, STMT_SUBROUTINE))
    1: 
    1: #define STMT_TYPE_LINKS_SCOPE(type)                                           \
    1:     STMT_TYPE_IN_RANGE(type, STMT_WITH, STMT_CATCH)
    1: 
    1: #define STMT_TYPE_IS_TRYING(type)                                             \
    1:     STMT_TYPE_IN_RANGE(type, STMT_TRY, STMT_SUBROUTINE)
    1: 
    1: #define STMT_TYPE_IS_LOOP(type) ((type) >= STMT_DO_LOOP)
    1: 
    1: #define STMT_MAYBE_SCOPE(stmt)  STMT_TYPE_MAYBE_SCOPE((stmt)->type)
    1: #define STMT_LINKS_SCOPE(stmt)  (STMT_TYPE_LINKS_SCOPE((stmt)->type) ||       \
    1:                                  ((stmt)->flags & SIF_SCOPE))
    1: #define STMT_IS_TRYING(stmt)    STMT_TYPE_IS_TRYING((stmt)->type)
    1: #define STMT_IS_LOOP(stmt)      STMT_TYPE_IS_LOOP((stmt)->type)
    1: 
    1: typedef struct JSStmtInfo JSStmtInfo;
    1: 
    1: struct JSStmtInfo {
    1:     uint16          type;           /* statement type */
    1:     uint16          flags;          /* flags, see below */
27012:     uint32          blockid;        /* for simplified dominance computation */
    1:     ptrdiff_t       update;         /* loop update offset (top if none) */
    1:     ptrdiff_t       breaks;         /* offset of last break in loop */
    1:     ptrdiff_t       continues;      /* offset of last continue in loop */
 3235:     union {
 3235:         JSAtom      *label;         /* name of LABEL */
54855:         JSObjectBox *blockBox;      /* block scope object */
27012:     };
    1:     JSStmtInfo      *down;          /* info for enclosing statement */
    1:     JSStmtInfo      *downScope;     /* next enclosing lexical scope */
    1: };
    1: 
    1: #define SIF_SCOPE        0x0001     /* statement has its own lexical scope */
    1: #define SIF_BODY_BLOCK   0x0002     /* STMT_BLOCK type is a function body */
 9976: #define SIF_FOR_BLOCK    0x0004     /* for (let ...) induced block scope */
    1: 
    1: /*
    1:  * To reuse space in JSStmtInfo, rename breaks and continues for use during
    1:  * try/catch/finally code generation and backpatching. To match most common
    1:  * use cases, the macro argument is a struct, not a struct pointer. Only a
    1:  * loop, switch, or label statement info record can have breaks and continues,
    1:  * and only a for loop has an update backpatch chain, so it's safe to overlay
    1:  * these for the "trying" JSStmtTypes.
    1:  */
    1: #define CATCHNOTE(stmt)  ((stmt).update)
    1: #define GOSUBS(stmt)     ((stmt).breaks)
    1: #define GUARDJUMP(stmt)  ((stmt).continues)
    1: 
    1: #define SET_STATEMENT_TOP(stmt, top)                                          \
    1:     ((stmt)->update = (top), (stmt)->breaks = (stmt)->continues = (-1))
    1: 
27012: #define TCF_COMPILING           0x01 /* JSTreeContext is JSCodeGenerator */
27012: #define TCF_IN_FUNCTION         0x02 /* parsing inside function body */
27012: #define TCF_RETURN_EXPR         0x04 /* function has 'return expr;' */
27012: #define TCF_RETURN_VOID         0x08 /* function has 'return;' */
27012: #define TCF_IN_FOR_INIT         0x10 /* parsing init expr of for; exclude 'in' */
27012: #define TCF_FUN_SETS_OUTER_NAME 0x20 /* function set outer name (lexical or free) */
27012: #define TCF_FUN_PARAM_ARGUMENTS 0x40 /* function has parameter named arguments */
27012: #define TCF_FUN_USES_ARGUMENTS  0x80 /* function uses arguments except as a
27012:                                         parameter name */
27012: #define TCF_FUN_HEAVYWEIGHT    0x100 /* function needs Call object per call */
27012: #define TCF_FUN_IS_GENERATOR   0x200 /* parsed yield statement in function */
32658: #define TCF_FUN_USES_OWN_NAME  0x400 /* named function expression that uses its
32658:                                         own name */
27012: #define TCF_HAS_FUNCTION_STMT  0x800 /* block contains a function statement */
27012: #define TCF_GENEXP_LAMBDA     0x1000 /* flag lambda from generator expression */
40860: #define TCF_COMPILE_N_GO      0x2000 /* compile-and-go mode of script, can
27012:                                         optimize name references based on scope
27012:                                         chain */
27012: #define TCF_NO_SCRIPT_RVAL    0x4000 /* API caller does not want result value
27012:                                         from global script */
27012: #define TCF_HAS_SHARPS        0x8000 /* source contains sharp defs or uses */
27012: 
27012: /*
33753:  * Set when parsing a declaration-like destructuring pattern.  This
33753:  * flag causes PrimaryExpr to create PN_NAME parse nodes for variable
33753:  * references which are not hooked into any definition's use chain,
33753:  * added to any tree context's AtomList, etc. etc.  CheckDestructuring
33753:  * will do that work later.
33753:  *
33753:  * The comments atop CheckDestructuring explain the distinction
33753:  * between assignment-like and declaration-like destructuring
33753:  * patterns, and why they need to be treated differently.
33753:  */
33753: #define TCF_DECL_DESTRUCTURING  0x10000
33753: 
33753: /*
40860:  * A request flag passed to Compiler::compileScript and then down via
34290:  * JSCodeGenerator to js_NewScriptFromCG, from script_compile_sub and any
34290:  * kindred functions that need to make mutable scripts (even empty ones;
34290:  * i.e., they can't share the const JSScript::emptyScript() singleton).
34290:  */
34290: #define TCF_NEED_MUTABLE_SCRIPT 0x20000
34290: 
34290: /*
37685:  * This function/global/eval code body contained a Use Strict Directive. Treat
37685:  * certain strict warnings as errors, and forbid the use of 'with'. See also
37685:  * TSF_STRICT_MODE_CODE, JSScript::strictModeCode, and JSREPORT_STRICT_ERROR.
35113:  */
35113: #define TCF_STRICT_MODE_CODE    0x40000
35113: 
62048: /* bit 0x80000 is unused */
35464: 
35113: /*
37685:  * Flag signifying that the current function seems to be a constructor that
37685:  * sets this.foo to define "methods", at least one of which can't be a null
37685:  * closure, so we should avoid over-specializing property cache entries and
37685:  * trace inlining guards to method function object identity, which will vary
37685:  * per instance.
37685:  */
37685: #define TCF_FUN_UNBRAND_THIS   0x100000
37685: 
37685: /*
38549:  * "Module pattern", i.e., a lambda that is immediately applied and the whole
38549:  * of an expression statement.
38549:  */
38549: #define TCF_FUN_MODULE_PATTERN 0x200000
38549: 
38549: /*
41853:  * Flag to prevent a non-escaping function from being optimized into a null
41849:  * closure (i.e., a closure that needs only its global object for free variable
60254:  * resolution), because this function contains a closure that needs one or more
60254:  * scope objects surrounding it (i.e., a Call object for an outer heavyweight
60254:  * function). See bug 560234.
41849:  */
41849: #define TCF_FUN_ENTRAINS_SCOPES 0x400000
41849: 
51096: /* The function calls 'eval'. */
51096: #define TCF_FUN_CALLS_EVAL       0x800000
51096: 
51096: /* The function mutates a positional (non-destructuring) parameter. */
51096: #define TCF_FUN_MUTATES_PARAMETER 0x1000000
51096: 
41849: /*
52555:  * Compiling an eval() script.
52555:  */
53446: #define TCF_COMPILE_FOR_EVAL     0x2000000
52555: 
52555: /*
59944:  * The function or a function that encloses it may define new local names
59944:  * at runtime through means other than calling eval.
57801:  */
58291: #define TCF_FUN_MIGHT_ALIAS_LOCALS  0x4000000
57801: 
57801: /*
59962:  * The script contains singleton initialiser JSOP_OBJECT.
59962:  */
59962: #define TCF_HAS_SINGLETONS       0x8000000
59962: 
59962: /*
61210:  * Some enclosing scope is a with-statement or E4X filter-expression.
61210:  */
61210: #define TCF_IN_WITH             0x10000000
61210: 
61210: /* 
64296:  * This function does something that can extend the set of bindings in its
64296:  * call objects --- it does a direct eval in non-strict code, or includes a
64296:  * function statement (as opposed to a function definition).
64296:  *
64296:  * This flag is *not* inherited by enclosed or enclosing functions; it
64296:  * applies only to the function in whose flags it appears.
64296:  */
64296: #define TCF_FUN_EXTENSIBLE_SCOPE 0x20000000
64296: 
64296: /*
37685:  * Flags to check for return; vs. return expr; in a function.
35113:  */
35113: #define TCF_RETURN_FLAGS        (TCF_RETURN_EXPR | TCF_RETURN_VOID)
35113: 
35113: /*
27236:  * Sticky deoptimization flags to propagate from FunctionBody.
26970:  */
27012: #define TCF_FUN_FLAGS           (TCF_FUN_SETS_OUTER_NAME |                    \
27012:                                  TCF_FUN_USES_ARGUMENTS  |                    \
27012:                                  TCF_FUN_PARAM_ARGUMENTS |                    \
26970:                                  TCF_FUN_HEAVYWEIGHT     |                    \
27012:                                  TCF_FUN_IS_GENERATOR    |                    \
32658:                                  TCF_FUN_USES_OWN_NAME   |                    \
35113:                                  TCF_HAS_SHARPS          |                    \
51096:                                  TCF_FUN_CALLS_EVAL      |                    \
58291:                                  TCF_FUN_MIGHT_ALIAS_LOCALS |                 \
51096:                                  TCF_FUN_MUTATES_PARAMETER |                  \
64296:                                  TCF_STRICT_MODE_CODE    |                    \
64296:                                  TCF_FUN_EXTENSIBLE_SCOPE)
26970: 
41884: struct JSTreeContext {              /* tree context for semantic checks */
41884:     uint32          flags;          /* statement state flags, see above */
41884:     uint32          bodyid;         /* block number of program/function body */
41884:     uint32          blockidGen;     /* preincremented block number generator */
72565:     uint32          parenDepth;     /* nesting depth of parens that might turn out
72565:                                        to be generator expressions */
72073:     uint32          yieldCount;     /* number of |yield| tokens encountered at
72073:                                        non-zero depth in current paren tree */
72073:     uint32          argumentsCount; /* number of |arguments| references encountered
72073:                                        at non-zero depth in current paren tree */
41884:     JSStmtInfo      *topStmt;       /* top of statement info stack */
41884:     JSStmtInfo      *topScopeStmt;  /* top lexical scope statement */
54855:     JSObjectBox     *blockChainBox; /* compile time block scope chain (NB: one
41884:                                        deeper than the topScopeStmt/downScope
41884:                                        chain when in head of let block/expr) */
41884:     JSParseNode     *blockNode;     /* parse node for a block with let declarations
41884:                                        (block with its own lexical scope)  */
41884:     JSAtomList      decls;          /* function, const, and var declarations */
41884:     js::Parser      *parser;        /* ptr to common parsing and lexing data */
72073:     JSParseNode     *yieldNode;     /* parse node for a yield expression that might
72073:                                        be an error if we turn out to be inside a
72073:                                        generator expression */
72073:     JSParseNode     *argumentsNode; /* parse node for an arguments variable that
72073:                                        might be an error if we turn out to be
72073:                                        inside a generator expression */
41884: 
57829:   private:
41884:     union {
57829:         JSFunction  *fun_;          /* function to store argument and variable
41884:                                        names when flags & TCF_IN_FUNCTION */
57829:         JSObject    *scopeChain_;   /* scope chain object for the script */
41884:     };
41884: 
57829:   public:
57829:     JSFunction *fun() const {
57829:         JS_ASSERT(inFunction());
57829:         return fun_;
57829:     }
57829:     void setFunction(JSFunction *fun) {
57829:         JS_ASSERT(inFunction());
57829:         fun_ = fun;
57829:     }
57829:     JSObject *scopeChain() const {
57829:         JS_ASSERT(!inFunction());
57829:         return scopeChain_;
57829:     }
57829:     void setScopeChain(JSObject *scopeChain) {
57829:         JS_ASSERT(!inFunction());
57829:         scopeChain_ = scopeChain;
57829:     }
57829: 
41884:     JSAtomList      lexdeps;        /* unresolved lexical name dependencies */
41884:     JSTreeContext   *parent;        /* enclosing function or global context */
41884:     uintN           staticLevel;    /* static compilation unit nesting level */
41884: 
41884:     JSFunctionBox   *funbox;        /* null or box for function we're compiling
41884:                                        if (flags & TCF_IN_FUNCTION) and not in
41884:                                        Compiler::compileFunctionBody */
41884:     JSFunctionBox   *functionList;
41884: 
52554:     JSParseNode     *innermostWith; /* innermost WITH parse node */
52554: 
59968:     js::Bindings    bindings;       /* bindings in this code, including
59968:                                        arguments if we're compiling a function */
59968: 
59968:     void trace(JSTracer *trc);
59968: 
41884:     JSTreeContext(js::Parser *prs)
72073:       : flags(0), bodyid(0), blockidGen(0), parenDepth(0), yieldCount(0), argumentsCount(0),
72073:         topStmt(NULL), topScopeStmt(NULL),
72073:         blockChainBox(NULL), blockNode(NULL), parser(prs),
72073:         yieldNode(NULL), argumentsNode(NULL),
72073:         scopeChain_(NULL), parent(prs->tc), staticLevel(0), funbox(NULL), functionList(NULL),
64242:         innermostWith(NULL), bindings(prs->context, prs->emptyCallShape),
59968:         sharpSlotBase(-1)
41884:     {
41884:         prs->tc = this;
41884:     }
41884: 
41884:     /*
41884:      * For functions the tree context is constructed and destructed a second
41884:      * time during code generation. To avoid a redundant stats update in such
41884:      * cases, we store uint16(-1) in maxScopeDepth.
41884:      */
41884:     ~JSTreeContext() {
41884:         parser->tc = this->parent;
41884:     }
41884: 
41884:     uintN blockid() { return topStmt ? topStmt->blockid : bodyid; }
41884: 
54855:     JSObject *blockChain() {
54855:         return blockChainBox ? blockChainBox->object : NULL;
54855:     }
54855: 
59229:     /*
59229:      * True if we are at the topmost level of a entire script or function body.
59229:      * For example, while parsing this code we would encounter f1 and f2 at
59229:      * body level, but we would not encounter f3 or f4 at body level:
59229:      *
59229:      *   function f1() { function f2() { } }
59229:      *   if (cond) { function f3() { if (cond) { function f4() { } } } }
59229:      */
59229:     bool atBodyLevel() { return !topStmt || (topStmt->flags & SIF_BODY_BLOCK); }
41884: 
41884:     /* Test whether we're in a statement of given type. */
41884:     bool inStatement(JSStmtType type);
41884: 
51096:     bool inStrictMode() const {
51096:         return flags & TCF_STRICT_MODE_CODE;
51096:     }
51096: 
41884:     inline bool needStrictChecks();
41884: 
41884:     /* 
41884:      * sharpSlotBase is -1 or first slot of pair for [sharpArray, sharpDepth].
41884:      * The parser calls ensureSharpSlots to allocate these two stack locals.
41884:      */
41884:     int sharpSlotBase;
41884:     bool ensureSharpSlots();
41884: 
52555:     js::Compiler *compiler() { return (js::Compiler *)parser; }
52555: 
41884:     // Return true there is a generator function within |skip| lexical scopes
41884:     // (going upward) from this context's lexical scope. Always return true if
41884:     // this context is itself a generator.
41884:     bool skipSpansGenerator(unsigned skip);
41884: 
51096:     bool compileAndGo() const { return flags & TCF_COMPILE_N_GO; }
51096:     bool inFunction() const { return flags & TCF_IN_FUNCTION; }
59218: 
51096:     bool compiling() const { return flags & TCF_COMPILING; }
59218:     inline JSCodeGenerator *asCodeGenerator();
51096: 
51096:     bool usesArguments() const {
51096:         return flags & TCF_FUN_USES_ARGUMENTS;
51096:     }
51096: 
51096:     void noteCallsEval() {
51096:         flags |= TCF_FUN_CALLS_EVAL;
51096:     }
51096: 
51096:     bool callsEval() const {
51096:         return flags & TCF_FUN_CALLS_EVAL;
51096:     }
51096: 
58291:     void noteMightAliasLocals() {
58291:         flags |= TCF_FUN_MIGHT_ALIAS_LOCALS;
57801:     }
57801: 
58291:     bool mightAliasLocals() const {
58291:         return flags & TCF_FUN_MIGHT_ALIAS_LOCALS;
57801:     }
57801: 
51096:     void noteParameterMutation() {
51096:         JS_ASSERT(inFunction());
51096:         flags |= TCF_FUN_MUTATES_PARAMETER;
51096:     }
51096: 
51096:     bool mutatesParameter() const {
51096:         JS_ASSERT(inFunction());
51096:         return flags & TCF_FUN_MUTATES_PARAMETER;
51096:     }
51096: 
72073:     void noteArgumentsUse(JSParseNode *pn) {
51096:         JS_ASSERT(inFunction());
72073:         countArgumentsUse(pn);
51096:         flags |= TCF_FUN_USES_ARGUMENTS;
51096:         if (funbox)
51096:             funbox->node->pn_dflags |= PND_FUNARG;
51096:     }
51096: 
72073:     void countArgumentsUse(JSParseNode *pn) {
72073:         JS_ASSERT(pn->pn_atom == parser->context->runtime->atomState.argumentsAtom);
72073:         argumentsCount++;
72073:         argumentsNode = pn;
72073:     }
72073: 
51096:     bool needsEagerArguments() const {
51096:         return inStrictMode() && ((usesArguments() && mutatesParameter()) || callsEval());
51096:     }
64296: 
64296:     void noteHasExtensibleScope() {
64296:         flags |= TCF_FUN_EXTENSIBLE_SCOPE;
64296:     }
64296: 
64296:     bool hasExtensibleScope() const {
64296:         return flags & TCF_FUN_EXTENSIBLE_SCOPE;
64296:     }
41884: };
41884: 
26970: /*
35310:  * Return true if we need to check for conditions that elicit
35310:  * JSOPTION_STRICT warnings or strict mode errors.
35310:  */
35310: inline bool JSTreeContext::needStrictChecks() {
61450:     return parser->context->hasStrictOption() || inStrictMode();
35310: }
35310: 
35310: /*
    1:  * Span-dependent instructions are jumps whose span (from the jump bytecode to
    1:  * the jump target) may require 2 or 4 bytes of immediate operand.
    1:  */
    1: typedef struct JSSpanDep    JSSpanDep;
    1: typedef struct JSJumpTarget JSJumpTarget;
    1: 
    1: struct JSSpanDep {
    1:     ptrdiff_t       top;        /* offset of first bytecode in an opcode */
    1:     ptrdiff_t       offset;     /* offset - 1 within opcode of jump operand */
    1:     ptrdiff_t       before;     /* original offset - 1 of jump operand */
    1:     JSJumpTarget    *target;    /* tagged target pointer or backpatch delta */
    1: };
    1: 
    1: /*
    1:  * Jump targets are stored in an AVL tree, for O(log(n)) lookup with targets
    1:  * sorted by offset from left to right, so that targets after a span-dependent
    1:  * instruction whose jump offset operand must be extended can be found quickly
    1:  * and adjusted upward (toward higher offsets).
    1:  */
    1: struct JSJumpTarget {
    1:     ptrdiff_t       offset;     /* offset of span-dependent jump target */
    1:     int             balance;    /* AVL tree balance number */
    1:     JSJumpTarget    *kids[2];   /* left and right AVL tree child pointers */
    1: };
    1: 
    1: #define JT_LEFT                 0
    1: #define JT_RIGHT                1
    1: #define JT_OTHER_DIR(dir)       (1 - (dir))
    1: #define JT_IMBALANCE(dir)       (((dir) << 1) - 1)
    1: #define JT_DIR(imbalance)       (((imbalance) + 1) >> 1)
    1: 
    1: /*
    1:  * Backpatch deltas are encoded in JSSpanDep.target if JT_TAG_BIT is clear,
    1:  * so we can maintain backpatch chains when using span dependency records to
    1:  * hold jump offsets that overflow 16 bits.
    1:  */
    1: #define JT_TAG_BIT              ((jsword) 1)
    1: #define JT_UNTAG_SHIFT          1
    1: #define JT_SET_TAG(jt)          ((JSJumpTarget *)((jsword)(jt) | JT_TAG_BIT))
    1: #define JT_CLR_TAG(jt)          ((JSJumpTarget *)((jsword)(jt) & ~JT_TAG_BIT))
    1: #define JT_HAS_TAG(jt)          ((jsword)(jt) & JT_TAG_BIT)
    1: 
    1: #define BITS_PER_PTRDIFF        (sizeof(ptrdiff_t) * JS_BITS_PER_BYTE)
    1: #define BITS_PER_BPDELTA        (BITS_PER_PTRDIFF - 1 - JT_UNTAG_SHIFT)
    1: #define BPDELTA_MAX             (((ptrdiff_t)1 << BITS_PER_BPDELTA) - 1)
    1: #define BPDELTA_TO_JT(bp)       ((JSJumpTarget *)((bp) << JT_UNTAG_SHIFT))
    1: #define JT_TO_BPDELTA(jt)       ((ptrdiff_t)((jsword)(jt) >> JT_UNTAG_SHIFT))
    1: 
    1: #define SD_SET_TARGET(sd,jt)    ((sd)->target = JT_SET_TAG(jt))
    1: #define SD_GET_TARGET(sd)       (JS_ASSERT(JT_HAS_TAG((sd)->target)),         \
    1:                                  JT_CLR_TAG((sd)->target))
    1: #define SD_SET_BPDELTA(sd,bp)   ((sd)->target = BPDELTA_TO_JT(bp))
    1: #define SD_GET_BPDELTA(sd)      (JS_ASSERT(!JT_HAS_TAG((sd)->target)),        \
    1:                                  JT_TO_BPDELTA((sd)->target))
    1: 
    1: /* Avoid asserting twice by expanding SD_GET_TARGET in the "then" clause. */
    1: #define SD_SPAN(sd,pivot)       (SD_GET_TARGET(sd)                            \
    1:                                  ? JT_CLR_TAG((sd)->target)->offset - (pivot) \
    1:                                  : 0)
    1: 
 3025: typedef struct JSTryNode JSTryNode;
 3025: 
 3025: struct JSTryNode {
 3025:     JSTryNote       note;
 3025:     JSTryNode       *prev;
 3025: };
 3025: 
27012: struct JSCGObjectList {
 3235:     uint32              length;     /* number of emitted so far objects */
27012:     JSObjectBox         *lastbox;   /* last emitted object */
 3235: 
27012:     JSCGObjectList() : length(0), lastbox(NULL) {}
 3235: 
27012:     uintN index(JSObjectBox *objbox);
27012:     void finish(JSObjectArray *array);
27012: };
    1: 
48470: class JSGCConstList {
48470:     js::Vector<js::Value> list;
48470:   public:
48470:     JSGCConstList(JSContext *cx) : list(cx) {}
48470:     bool append(js::Value v) { return list.append(v); }
48470:     size_t length() const { return list.length(); }
48470:     void finish(JSConstArray *array);
48470: 
48470: };
48470: 
27012: struct JSCodeGenerator : public JSTreeContext
27012: {
    1:     JSArenaPool     *codePool;      /* pointer to thread code arena pool */
    1:     JSArenaPool     *notePool;      /* pointer to thread srcnote arena pool */
    1:     void            *codeMark;      /* low watermark in cg->codePool */
    1:     void            *noteMark;      /* low watermark in cg->notePool */
    1: 
    1:     struct {
    1:         jsbytecode  *base;          /* base of JS bytecode vector */
    1:         jsbytecode  *limit;         /* one byte beyond end of bytecode */
    1:         jsbytecode  *next;          /* pointer to next free bytecode */
    1:         jssrcnote   *notes;         /* source notes, see below */
    1:         uintN       noteCount;      /* number of source notes so far */
    1:         uintN       noteMask;       /* growth increment for notes */
    1:         ptrdiff_t   lastNoteOffset; /* code offset for last source note */
    1:         uintN       currentLine;    /* line number for tree-based srcnote gen */
    1:     } prolog, main, *current;
    1: 
17182:     JSAtomList      atomList;       /* literals indexed for mapping */
    1:     uintN           firstLine;      /* first line, for js_NewScriptFromCG */
    1: 
    1:     intN            stackDepth;     /* current stack depth in script frame */
    1:     uintN           maxStackDepth;  /* maximum stack depth so far */
    1: 
 3025:     uintN           ntrynotes;      /* number of allocated so far try notes */
 3025:     JSTryNode       *lastTryNode;   /* the last allocated try node */
    1: 
    1:     JSSpanDep       *spanDeps;      /* span dependent instruction records */
    1:     JSJumpTarget    *jumpTargets;   /* AVL tree of jump target offsets */
    1:     JSJumpTarget    *jtFreeList;    /* JT_LEFT-linked list of free structs */
    1:     uintN           numSpanDeps;    /* number of span dependencies */
    1:     uintN           numJumpTargets; /* number of jump targets */
    1:     ptrdiff_t       spanDepTodo;    /* offset from main.base of potentially
    1:                                        unoptimized spandeps */
    1: 
16072:     uintN           arrayCompDepth; /* stack depth of array in comprehension */
    1: 
    1:     uintN           emitLevel;      /* js_EmitTree recursion level */
41867: 
48470:     typedef js::HashMap<JSAtom *, js::Value> ConstMap;
41867:     ConstMap        constMap;       /* compile time constants */
 3235: 
48470:     JSGCConstList   constList;      /* constants to be included with the script */
48470: 
27012:     JSCGObjectList  objectList;     /* list of emitted objects */
27012:     JSCGObjectList  regexpList;     /* list of emitted regexp that will be
27012:                                        cloned during execution */
 3235: 
18308:     JSAtomList      upvarList;      /* map of atoms to upvar indexes */
18308:     JSUpvarArray    upvarMap;       /* indexed upvar pairs (JS_realloc'ed) */
27012: 
72091:     typedef js::Vector<js::GlobalSlotArray::Entry, 16> GlobalUseVector;
52555: 
52555:     GlobalUseVector globalUses;     /* per-script global uses */
52555:     JSAtomList      globalMap;      /* per-script map of global name to globalUses vector */
52555: 
54840:     /* Vectors of pn_cookie slot values. */
72091:     typedef js::Vector<uint32, 8> SlotVector;
54840:     SlotVector      closedArgs;
54840:     SlotVector      closedVars;
54840: 
56217:     uint16          traceIndex;     /* index for the next JSOP_TRACE instruction */
56217: 
27012:     /*
27012:      * Initialize cg to allocate bytecode space from codePool, source note
27012:      * space from notePool, and all other arena-allocated temporaries from
40860:      * parser->context->tempPool.
27012:      */
40860:     JSCodeGenerator(js::Parser *parser,
27012:                     JSArenaPool *codePool, JSArenaPool *notePool,
27012:                     uintN lineno);
41867:     bool init();
41867: 
27012:     /*
40860:      * Release cg->codePool, cg->notePool, and parser->context->tempPool to
27012:      * marks set by JSCodeGenerator's ctor. Note that cgs are magic: they own
27012:      * the arena pool "tops-of-stack" space above their codeMark, noteMark, and
27012:      * tempMark points.  This means you cannot alloc from tempPool and save the
27012:      * pointer beyond the next JSCodeGenerator destructor call.
27012:      */
27012:     ~JSCodeGenerator();
32729: 
54477:     /*
54477:      * Adds a use of a variable that is statically known to exist on the
54477:      * global object. 
54477:      *
54477:      * The actual slot of the variable on the global object is not known
54477:      * until after compilation. Properties must be resolved before being
54477:      * added, to avoid aliasing properties that should be resolved. This makes
54477:      * slot prediction based on the global object's free slot impossible. So,
54477:      * we use the slot to index into cg->globalScope->defs, and perform a
54477:      * fixup of the script at the very end of compilation.
54477:      *
54477:      * If the global use can be cached, |cookie| will be set to |slot|.
54477:      * Otherwise, |cookie| is set to the free cookie value.
54477:      */
54477:     bool addGlobalUse(JSAtom *atom, uint32 slot, js::UpvarCookie *cookie);
52555: 
61450:     bool hasSharps() const {
33166:         bool rv = !!(flags & TCF_HAS_SHARPS);
32729:         JS_ASSERT((sharpSlotBase >= 0) == rv);
32729:         return rv;
32729:     }
32729: 
61450:     uintN sharpSlots() const {
32772:         return hasSharps() ? SHARP_NSLOTS : 0;
32729:     }
52555: 
61450:     bool compilingForEval() const { return !!(flags & TCF_COMPILE_FOR_EVAL); }
61450:     JSVersion version() const { return parser->versionWithFlags(); }
54840: 
54840:     bool shouldNoteClosedName(JSParseNode *pn);
59962: 
59962:     bool checkSingletonContext() {
59962:         if (!compileAndGo() || inFunction())
59962:             return false;
59962:         for (JSStmtInfo *stmt = topStmt; stmt; stmt = stmt->down) {
59962:             if (STMT_IS_LOOP(stmt))
59962:                 return false;
59962:         }
59962:         flags |= TCF_HAS_SINGLETONS;
59962:         return true;
59962:     }
    1: };
    1: 
40860: #define CG_TS(cg)               TS((cg)->parser)
18308: 
    1: #define CG_BASE(cg)             ((cg)->current->base)
    1: #define CG_LIMIT(cg)            ((cg)->current->limit)
    1: #define CG_NEXT(cg)             ((cg)->current->next)
    1: #define CG_CODE(cg,offset)      (CG_BASE(cg) + (offset))
25144: #define CG_OFFSET(cg)           (CG_NEXT(cg) - CG_BASE(cg))
    1: 
    1: #define CG_NOTES(cg)            ((cg)->current->notes)
    1: #define CG_NOTE_COUNT(cg)       ((cg)->current->noteCount)
    1: #define CG_NOTE_MASK(cg)        ((cg)->current->noteMask)
    1: #define CG_LAST_NOTE_OFFSET(cg) ((cg)->current->lastNoteOffset)
    1: #define CG_CURRENT_LINE(cg)     ((cg)->current->currentLine)
    1: 
    1: #define CG_PROLOG_BASE(cg)      ((cg)->prolog.base)
    1: #define CG_PROLOG_LIMIT(cg)     ((cg)->prolog.limit)
    1: #define CG_PROLOG_NEXT(cg)      ((cg)->prolog.next)
    1: #define CG_PROLOG_CODE(cg,poff) (CG_PROLOG_BASE(cg) + (poff))
25144: #define CG_PROLOG_OFFSET(cg)    (CG_PROLOG_NEXT(cg) - CG_PROLOG_BASE(cg))
    1: 
    1: #define CG_SWITCH_TO_MAIN(cg)   ((cg)->current = &(cg)->main)
    1: #define CG_SWITCH_TO_PROLOG(cg) ((cg)->current = &(cg)->prolog)
    1: 
59218: inline JSCodeGenerator *
59218: JSTreeContext::asCodeGenerator()
59218: {
59218:     JS_ASSERT(compiling());
59218:     return static_cast<JSCodeGenerator *>(this);
59218: }
59218: 
    1: /*
    1:  * Emit one bytecode.
    1:  */
    1: extern ptrdiff_t
    1: js_Emit1(JSContext *cx, JSCodeGenerator *cg, JSOp op);
    1: 
    1: /*
    1:  * Emit two bytecodes, an opcode (op) with a byte of immediate operand (op1).
    1:  */
    1: extern ptrdiff_t
    1: js_Emit2(JSContext *cx, JSCodeGenerator *cg, JSOp op, jsbytecode op1);
    1: 
    1: /*
    1:  * Emit three bytecodes, an opcode with two bytes of immediate operands.
    1:  */
    1: extern ptrdiff_t
    1: js_Emit3(JSContext *cx, JSCodeGenerator *cg, JSOp op, jsbytecode op1,
    1:          jsbytecode op2);
    1: 
    1: /*
54855:  * Emit five bytecodes, an opcode with two 16-bit immediates.
54855:  */
54855: extern ptrdiff_t
54855: js_Emit5(JSContext *cx, JSCodeGenerator *cg, JSOp op, uint16 op1,
54855:          uint16 op2);
54855: 
54855: /*
    1:  * Emit (1 + extra) bytecodes, for N bytes of op and its immediate operand.
    1:  */
    1: extern ptrdiff_t
    1: js_EmitN(JSContext *cx, JSCodeGenerator *cg, JSOp op, size_t extra);
    1: 
    1: /*
    1:  * Unsafe macro to call js_SetJumpOffset and return false if it does.
    1:  */
18729: #define CHECK_AND_SET_JUMP_OFFSET_CUSTOM(cx,cg,pc,off,BAD_EXIT)               \
    1:     JS_BEGIN_MACRO                                                            \
18729:         if (!js_SetJumpOffset(cx, cg, pc, off)) {                             \
18729:             BAD_EXIT;                                                         \
18729:         }                                                                     \
    1:     JS_END_MACRO
    1: 
18729: #define CHECK_AND_SET_JUMP_OFFSET(cx,cg,pc,off)                               \
18729:     CHECK_AND_SET_JUMP_OFFSET_CUSTOM(cx,cg,pc,off,return JS_FALSE)
18729: 
18729: #define CHECK_AND_SET_JUMP_OFFSET_AT_CUSTOM(cx,cg,off,BAD_EXIT)               \
18729:     CHECK_AND_SET_JUMP_OFFSET_CUSTOM(cx, cg, CG_CODE(cg,off),                 \
18729:                                      CG_OFFSET(cg) - (off), BAD_EXIT)
18729: 
    1: #define CHECK_AND_SET_JUMP_OFFSET_AT(cx,cg,off)                               \
18729:     CHECK_AND_SET_JUMP_OFFSET_AT_CUSTOM(cx, cg, off, return JS_FALSE)
    1: 
    1: extern JSBool
    1: js_SetJumpOffset(JSContext *cx, JSCodeGenerator *cg, jsbytecode *pc,
    1:                  ptrdiff_t off);
    1: 
    1: /*
    1:  * Push the C-stack-allocated struct at stmt onto the stmtInfo stack.
    1:  */
    1: extern void
    1: js_PushStatement(JSTreeContext *tc, JSStmtInfo *stmt, JSStmtType type,
    1:                  ptrdiff_t top);
    1: 
    1: /*
 3235:  * Push a block scope statement and link blockObj into tc->blockChain. To pop
 3235:  * this statement info record, use js_PopStatement as usual, or if appropriate
 3235:  * (if generating code), js_PopStatementCG.
    1:  */
    1: extern void
54855: js_PushBlockScope(JSTreeContext *tc, JSStmtInfo *stmt, JSObjectBox *blockBox,
    1:                   ptrdiff_t top);
    1: 
    1: /*
    1:  * Pop tc->topStmt. If the top JSStmtInfo struct is not stack-allocated, it
    1:  * is up to the caller to free it.
    1:  */
    1: extern void
    1: js_PopStatement(JSTreeContext *tc);
    1: 
    1: /*
27012:  * Like js_PopStatement(cg), also patch breaks and continues unless the top
27012:  * statement info record represents a try-catch-finally suite. May fail if a
27012:  * jump offset overflows.
    1:  */
    1: extern JSBool
    1: js_PopStatementCG(JSContext *cx, JSCodeGenerator *cg);
    1: 
    1: /*
    1:  * Define and lookup a primitive jsval associated with the const named by atom.
    1:  * js_DefineCompileTimeConstant analyzes the constant-folded initializer at pn
    1:  * and saves the const's value in cg->constList, if it can be used at compile
    1:  * time. It returns true unless an error occurred.
    1:  *
 8817:  * If the initializer's value could not be saved, js_DefineCompileTimeConstant
 8817:  * calls will return the undefined value. js_DefineCompileTimeConstant tries
    1:  * to find a const value memorized for atom, returning true with *vp set to a
    1:  * value other than undefined if the constant was found, true with *vp set to
    1:  * JSVAL_VOID if not found, and false on error.
    1:  */
    1: extern JSBool
    1: js_DefineCompileTimeConstant(JSContext *cx, JSCodeGenerator *cg, JSAtom *atom,
    1:                              JSParseNode *pn);
    1: 
    1: /*
    1:  * Find a lexically scoped variable (one declared by let, catch, or an array
    1:  * comprehension) named by atom, looking in tc's compile-time scopes.
    1:  *
    1:  * If a WITH statement is reached along the scope stack, return its statement
    1:  * info record, so callers can tell that atom is ambiguous. If slotp is not
    1:  * null, then if atom is found, set *slotp to its stack slot, otherwise to -1.
    1:  * This means that if slotp is not null, all the block objects on the lexical
    1:  * scope chain must have had their depth slots computed by the code generator,
    1:  * so the caller must be under js_EmitTree.
    1:  *
    1:  * In any event, directly return the statement info record in which atom was
    1:  * found. Otherwise return null.
    1:  */
    1: extern JSStmtInfo *
27112: js_LexicalLookup(JSTreeContext *tc, JSAtom *atom, jsint *slotp,
27112:                  JSStmtInfo *stmt = NULL);
    1: 
    1: /*
    1:  * Emit code into cg for the tree rooted at pn.
    1:  */
    1: extern JSBool
    1: js_EmitTree(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn);
    1: 
    1: /*
 9786:  * Emit function code using cg for the tree rooted at body.
    1:  */
    1: extern JSBool
 9786: js_EmitFunctionScript(JSContext *cx, JSCodeGenerator *cg, JSParseNode *body);
    1: 
    1: /*
    1:  * Source notes generated along with bytecode for decompiling and debugging.
    1:  * A source note is a uint8 with 5 bits of type and 3 of offset from the pc of
    1:  * the previous note. If 3 bits of offset aren't enough, extended delta notes
    1:  * (SRC_XDELTA) consisting of 2 set high order bits followed by 6 offset bits
    1:  * are emitted before the next note. Some notes have operand offsets encoded
    1:  * immediately after them, in note bytes or byte-triples.
    1:  *
    1:  *                 Source Note               Extended Delta
    1:  *              +7-6-5-4-3+2-1-0+           +7-6-5+4-3-2-1-0+
    1:  *              |note-type|delta|           |1 1| ext-delta |
    1:  *              +---------+-----+           +---+-----------+
    1:  *
    1:  * At most one "gettable" note (i.e., a note of type other than SRC_NEWLINE,
    1:  * SRC_SETLINE, and SRC_XDELTA) applies to a given bytecode.
    1:  *
    1:  * NB: the js_SrcNoteSpec array in jsemit.c is indexed by this enum, so its
    1:  * initializers need to match the order here.
    1:  *
    1:  * Note on adding new source notes: every pair of bytecodes (A, B) where A and
    1:  * B have disjoint sets of source notes that could apply to each bytecode may
    1:  * reuse the same note type value for two notes (snA, snB) that have the same
    1:  * arity, offsetBias, and isSpanDep initializers in js_SrcNoteSpec. This is
    1:  * why SRC_IF and SRC_INITPROP have the same value below. For bad historical
    1:  * reasons, some bytecodes below that could be overlayed have not been, but
    1:  * before using SRC_EXTENDED, consider compressing the existing note types.
    1:  *
    1:  * Don't forget to update JSXDR_BYTECODE_VERSION in jsxdrapi.h for all such
    1:  * incompatible source note or other bytecode changes.
    1:  */
    1: typedef enum JSSrcNoteType {
    1:     SRC_NULL        = 0,        /* terminates a note vector */
    1:     SRC_IF          = 1,        /* JSOP_IFEQ bytecode is from an if-then */
18603:     SRC_BREAK       = 1,        /* JSOP_GOTO is a break */
    1:     SRC_INITPROP    = 1,        /* disjoint meaning applied to JSOP_INITELEM or
    1:                                    to an index label in a regular (structuring)
    1:                                    or a destructuring object initialiser */
27012:     SRC_GENEXP      = 1,        /* JSOP_LAMBDA from generator expression */
    1:     SRC_IF_ELSE     = 2,        /* JSOP_IFEQ bytecode is from an if-then-else */
20943:     SRC_FOR_IN      = 2,        /* JSOP_GOTO to for-in loop condition from
20943:                                    before loop (same arity as SRC_IF_ELSE) */
20943:     SRC_FOR         = 3,        /* JSOP_NOP or JSOP_POP in for(;;) loop head */
20943:     SRC_WHILE       = 4,        /* JSOP_GOTO to for or while loop condition
20943:                                    from before loop, else JSOP_NOP at top of
20943:                                    do-while loop */
56551:     SRC_TRACE       = 4,        /* For JSOP_TRACE; includes distance to loop end */
    1:     SRC_CONTINUE    = 5,        /* JSOP_GOTO is a continue, not a break;
    1:                                    also used on JSOP_ENDINIT if extra comma
26956:                                    at end of array literal: [1,2,,];
26956:                                    JSOP_DUP continuing destructuring pattern */
    1:     SRC_DECL        = 6,        /* type of a declaration (var, const, let*) */
    1:     SRC_DESTRUCT    = 6,        /* JSOP_DUP starting a destructuring assignment
    1:                                    operation, with SRC_DECL_* offset operand */
    1:     SRC_PCDELTA     = 7,        /* distance forward from comma-operator to
    1:                                    next POP, or from CONDSWITCH to first CASE
    1:                                    opcode, etc. -- always a forward delta */
    1:     SRC_GROUPASSIGN = 7,        /* SRC_DESTRUCT variant for [a, b] = [c, d] */
    1:     SRC_ASSIGNOP    = 8,        /* += or another assign-op follows */
    1:     SRC_COND        = 9,        /* JSOP_IFEQ is from conditional ?: operator */
    1:     SRC_BRACE       = 10,       /* mandatory brace, for scope or to avoid
    1:                                    dangling else */
    1:     SRC_HIDDEN      = 11,       /* opcode shouldn't be decompiled */
    1:     SRC_PCBASE      = 12,       /* distance back from annotated getprop or
    1:                                    setprop op to left-most obj.prop.subprop
    1:                                    bytecode -- always a backward delta */
    1:     SRC_LABEL       = 13,       /* JSOP_NOP for label: with atomid immediate */
    1:     SRC_LABELBRACE  = 14,       /* JSOP_NOP for label: {...} begin brace */
    1:     SRC_ENDBRACE    = 15,       /* JSOP_NOP for label: {...} end brace */
    1:     SRC_BREAK2LABEL = 16,       /* JSOP_GOTO for 'break label' with atomid */
    1:     SRC_CONT2LABEL  = 17,       /* JSOP_GOTO for 'continue label' with atomid */
    1:     SRC_SWITCH      = 18,       /* JSOP_*SWITCH with offset to end of switch,
    1:                                    2nd off to first JSOP_CASE if condswitch */
    1:     SRC_FUNCDEF     = 19,       /* JSOP_NOP for function f() with atomid */
    1:     SRC_CATCH       = 20,       /* catch block has guard */
    1:     SRC_EXTENDED    = 21,       /* extended source note, 32-159, in next byte */
    1:     SRC_NEWLINE     = 22,       /* bytecode follows a source newline */
    1:     SRC_SETLINE     = 23,       /* a file-absolute source line number note */
    1:     SRC_XDELTA      = 24        /* 24-31 are for extended delta notes */
    1: } JSSrcNoteType;
    1: 
    1: /*
    1:  * Constants for the SRC_DECL source note. Note that span-dependent bytecode
    1:  * selection means that any SRC_DECL offset greater than SRC_DECL_LET may need
    1:  * to be adjusted, but these "offsets" are too small to span a span-dependent
    1:  * instruction, so can be used to denote distinct declaration syntaxes to the
    1:  * decompiler.
    1:  *
    1:  * NB: the var_prefix array in jsopcode.c depends on these dense indexes from
    1:  * SRC_DECL_VAR through SRC_DECL_LET.
    1:  */
    1: #define SRC_DECL_VAR            0
    1: #define SRC_DECL_CONST          1
    1: #define SRC_DECL_LET            2
    1: #define SRC_DECL_NONE           3
    1: 
    1: #define SN_TYPE_BITS            5
    1: #define SN_DELTA_BITS           3
    1: #define SN_XDELTA_BITS          6
    1: #define SN_TYPE_MASK            (JS_BITMASK(SN_TYPE_BITS) << SN_DELTA_BITS)
    1: #define SN_DELTA_MASK           ((ptrdiff_t)JS_BITMASK(SN_DELTA_BITS))
    1: #define SN_XDELTA_MASK          ((ptrdiff_t)JS_BITMASK(SN_XDELTA_BITS))
    1: 
    1: #define SN_MAKE_NOTE(sn,t,d)    (*(sn) = (jssrcnote)                          \
    1:                                           (((t) << SN_DELTA_BITS)             \
    1:                                            | ((d) & SN_DELTA_MASK)))
    1: #define SN_MAKE_XDELTA(sn,d)    (*(sn) = (jssrcnote)                          \
    1:                                           ((SRC_XDELTA << SN_DELTA_BITS)      \
    1:                                            | ((d) & SN_XDELTA_MASK)))
    1: 
    1: #define SN_IS_XDELTA(sn)        ((*(sn) >> SN_DELTA_BITS) >= SRC_XDELTA)
 3164: #define SN_TYPE(sn)             ((JSSrcNoteType)(SN_IS_XDELTA(sn)             \
 3164:                                                  ? SRC_XDELTA                 \
 3164:                                                  : *(sn) >> SN_DELTA_BITS))
    1: #define SN_SET_TYPE(sn,type)    SN_MAKE_NOTE(sn, type, SN_DELTA(sn))
    1: #define SN_IS_GETTABLE(sn)      (SN_TYPE(sn) < SRC_NEWLINE)
    1: 
    1: #define SN_DELTA(sn)            ((ptrdiff_t)(SN_IS_XDELTA(sn)                 \
    1:                                              ? *(sn) & SN_XDELTA_MASK         \
    1:                                              : *(sn) & SN_DELTA_MASK))
    1: #define SN_SET_DELTA(sn,delta)  (SN_IS_XDELTA(sn)                             \
    1:                                  ? SN_MAKE_XDELTA(sn, delta)                  \
    1:                                  : SN_MAKE_NOTE(sn, SN_TYPE(sn), delta))
    1: 
    1: #define SN_DELTA_LIMIT          ((ptrdiff_t)JS_BIT(SN_DELTA_BITS))
    1: #define SN_XDELTA_LIMIT         ((ptrdiff_t)JS_BIT(SN_XDELTA_BITS))
    1: 
    1: /*
    1:  * Offset fields follow certain notes and are frequency-encoded: an offset in
    1:  * [0,0x7f] consumes one byte, an offset in [0x80,0x7fffff] takes three, and
    1:  * the high bit of the first byte is set.
    1:  */
    1: #define SN_3BYTE_OFFSET_FLAG    0x80
    1: #define SN_3BYTE_OFFSET_MASK    0x7f
    1: 
    1: typedef struct JSSrcNoteSpec {
    1:     const char      *name;      /* name for disassembly/debugging output */
15428:     int8            arity;      /* number of offset operands */
    1:     uint8           offsetBias; /* bias of offset(s) from annotated pc */
    1:     int8            isSpanDep;  /* 1 or -1 if offsets could span extended ops,
    1:                                    0 otherwise; sign tells span direction */
    1: } JSSrcNoteSpec;
    1: 
    1: extern JS_FRIEND_DATA(JSSrcNoteSpec) js_SrcNoteSpec[];
    1: extern JS_FRIEND_API(uintN)          js_SrcNoteLength(jssrcnote *sn);
    1: 
    1: #define SN_LENGTH(sn)           ((js_SrcNoteSpec[SN_TYPE(sn)].arity == 0) ? 1 \
    1:                                  : js_SrcNoteLength(sn))
    1: #define SN_NEXT(sn)             ((sn) + SN_LENGTH(sn))
    1: 
    1: /* A source note array is terminated by an all-zero element. */
    1: #define SN_MAKE_TERMINATOR(sn)  (*(sn) = SRC_NULL)
    1: #define SN_IS_TERMINATOR(sn)    (*(sn) == SRC_NULL)
    1: 
    1: /*
    1:  * Append a new source note of the given type (and therefore size) to cg's
    1:  * notes dynamic array, updating cg->noteCount. Return the new note's index
    1:  * within the array pointed at by cg->current->notes. Return -1 if out of
    1:  * memory.
    1:  */
    1: extern intN
    1: js_NewSrcNote(JSContext *cx, JSCodeGenerator *cg, JSSrcNoteType type);
    1: 
    1: extern intN
    1: js_NewSrcNote2(JSContext *cx, JSCodeGenerator *cg, JSSrcNoteType type,
    1:                ptrdiff_t offset);
    1: 
    1: extern intN
    1: js_NewSrcNote3(JSContext *cx, JSCodeGenerator *cg, JSSrcNoteType type,
    1:                ptrdiff_t offset1, ptrdiff_t offset2);
    1: 
    1: /*
    1:  * NB: this function can add at most one extra extended delta note.
    1:  */
    1: extern jssrcnote *
    1: js_AddToSrcNoteDelta(JSContext *cx, JSCodeGenerator *cg, jssrcnote *sn,
    1:                      ptrdiff_t delta);
    1: 
    1: /*
    1:  * Get and set the offset operand identified by which (0 for the first, etc.).
    1:  */
    1: extern JS_FRIEND_API(ptrdiff_t)
    1: js_GetSrcNoteOffset(jssrcnote *sn, uintN which);
    1: 
    1: extern JSBool
    1: js_SetSrcNoteOffset(JSContext *cx, JSCodeGenerator *cg, uintN index,
    1:                     uintN which, ptrdiff_t offset);
    1: 
    1: /*
    1:  * Finish taking source notes in cx's notePool, copying final notes to the new
    1:  * stable store allocated by the caller and passed in via notes. Return false
    1:  * on malloc failure, which means this function reported an error.
    1:  *
    1:  * To compute the number of jssrcnotes to allocate and pass in via notes, use
    1:  * the CG_COUNT_FINAL_SRCNOTES macro. This macro knows a lot about details of
    1:  * js_FinishTakingSrcNotes, SO DON'T CHANGE jsemit.c's js_FinishTakingSrcNotes
    1:  * FUNCTION WITHOUT CHECKING WHETHER THIS MACRO NEEDS CORRESPONDING CHANGES!
    1:  */
    1: #define CG_COUNT_FINAL_SRCNOTES(cg, cnt)                                      \
    1:     JS_BEGIN_MACRO                                                            \
    1:         ptrdiff_t diff_ = CG_PROLOG_OFFSET(cg) - (cg)->prolog.lastNoteOffset; \
    1:         cnt = (cg)->prolog.noteCount + (cg)->main.noteCount + 1;              \
    1:         if ((cg)->prolog.noteCount &&                                         \
    1:             (cg)->prolog.currentLine != (cg)->firstLine) {                    \
    1:             if (diff_ > SN_DELTA_MASK)                                        \
    1:                 cnt += JS_HOWMANY(diff_ - SN_DELTA_MASK, SN_XDELTA_MASK);     \
    1:             cnt += 2 + (((cg)->firstLine > SN_3BYTE_OFFSET_MASK) << 1);       \
    1:         } else if (diff_ > 0) {                                               \
    1:             if (cg->main.noteCount) {                                         \
    1:                 jssrcnote *sn_ = (cg)->main.notes;                            \
    1:                 diff_ -= SN_IS_XDELTA(sn_)                                    \
    1:                          ? SN_XDELTA_MASK - (*sn_ & SN_XDELTA_MASK)           \
    1:                          : SN_DELTA_MASK - (*sn_ & SN_DELTA_MASK);            \
    1:             }                                                                 \
    1:             if (diff_ > 0)                                                    \
    1:                 cnt += JS_HOWMANY(diff_, SN_XDELTA_MASK);                     \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: extern JSBool
    1: js_FinishTakingSrcNotes(JSContext *cx, JSCodeGenerator *cg, jssrcnote *notes);
    1: 
    1: extern void
 3235: js_FinishTakingTryNotes(JSCodeGenerator *cg, JSTryNoteArray *array);
    1: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jsemit_h___ */
