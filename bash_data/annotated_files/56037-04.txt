53414: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53414:  * vim: set ts=8 sw=4 et tw=79:
53414:  *
53414:  * ***** BEGIN LICENSE BLOCK *****
50491:  * Copyright (C) 2008 Apple Inc. All rights reserved.
50491:  *
50491:  * Redistribution and use in source and binary forms, with or without
50491:  * modification, are permitted provided that the following conditions
50491:  * are met:
50491:  * 1. Redistributions of source code must retain the above copyright
50491:  *    notice, this list of conditions and the following disclaimer.
50491:  * 2. Redistributions in binary form must reproduce the above copyright
50491:  *    notice, this list of conditions and the following disclaimer in the
50491:  *    documentation and/or other materials provided with the distribution.
50491:  *
50491:  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
50491:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
50491:  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
50491:  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
50491:  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
50491:  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
50491:  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
50491:  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
50491:  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
50491:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
50491:  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
53414:  * 
53414:  * ***** END LICENSE BLOCK ***** */
50491: 
50491: #ifndef AbstractMacroAssembler_h
50491: #define AbstractMacroAssembler_h
50491: 
50491: #include "assembler/wtf/Platform.h"
50491: #include "assembler/assembler/MacroAssemblerCodeRef.h"
50491: #include "assembler/assembler/CodeLocation.h"
50491: #include "jsstdint.h"
50491: 
50491: #if ENABLE_ASSEMBLER
50491: 
50491: namespace JSC {
50491: 
50491: class LinkBuffer;
50491: class RepatchBuffer;
50491: 
50491: template <class AssemblerType>
50491: class AbstractMacroAssembler {
50491: public:
50491:     typedef AssemblerType AssemblerType_T;
50491: 
50491:     typedef MacroAssemblerCodePtr CodePtr;
50491:     typedef MacroAssemblerCodeRef CodeRef;
50491: 
50491:     class Jump;
50491: 
50491:     typedef typename AssemblerType::RegisterID RegisterID;
50491:     typedef typename AssemblerType::FPRegisterID FPRegisterID;
50491:     typedef typename AssemblerType::JmpSrc JmpSrc;
50491:     typedef typename AssemblerType::JmpDst JmpDst;
50491: 
50491: #ifdef DEBUG
50491:     void setSpewPath(bool isOOLPath)
50491:     {
50491:         m_assembler.isOOLPath = isOOLPath;
50491:     }
50491: #endif
50491: 
50491:     // Section 1: MacroAssembler operand types
50491:     //
50491:     // The following types are used as operands to MacroAssembler operations,
50491:     // describing immediate  and memory operands to the instructions to be planted.
50491: 
50491: 
50491:     enum Scale {
50491:         TimesOne,
50491:         TimesTwo,
50491:         TimesFour,
50491:         TimesEight
50491:     };
50491: 
50491:     // Address:
50491:     //
50491:     // Describes a simple base-offset address.
50491:     struct Address {
50491:         explicit Address(RegisterID base, int32_t offset = 0)
50491:             : base(base)
50491:             , offset(offset)
50491:         {
50491:         }
50491: 
50491:         RegisterID base;
50491:         int32_t offset;
50491:     };
50491: 
50491:     struct ExtendedAddress {
50491:         explicit ExtendedAddress(RegisterID base, intptr_t offset = 0)
50491:             : base(base)
50491:             , offset(offset)
50491:         {
50491:         }
50491:         
50491:         RegisterID base;
50491:         intptr_t offset;
50491:     };
50491: 
50491:     // ImplicitAddress:
50491:     //
50491:     // This class is used for explicit 'load' and 'store' operations
50491:     // (as opposed to situations in which a memory operand is provided
50491:     // to a generic operation, such as an integer arithmetic instruction).
50491:     //
50491:     // In the case of a load (or store) operation we want to permit
50491:     // addresses to be implicitly constructed, e.g. the two calls:
50491:     //
50491:     //     load32(Address(addrReg), destReg);
50491:     //     load32(addrReg, destReg);
50491:     //
50491:     // Are equivalent, and the explicit wrapping of the Address in the former
50491:     // is unnecessary.
50491:     struct ImplicitAddress {
50491:         ImplicitAddress(RegisterID base)
50491:             : base(base)
50491:             , offset(0)
50491:         {
50491:         }
50491: 
50491:         ImplicitAddress(Address address)
50491:             : base(address.base)
50491:             , offset(address.offset)
50491:         {
50491:         }
50491: 
50491:         RegisterID base;
50491:         int32_t offset;
50491:     };
50491: 
50491:     // BaseIndex:
50491:     //
50491:     // Describes a complex addressing mode.
50491:     struct BaseIndex {
50491:         BaseIndex(RegisterID base, RegisterID index, Scale scale, int32_t offset = 0)
50491:             : base(base)
50491:             , index(index)
50491:             , scale(scale)
50491:             , offset(offset)
50491:         {
50491:         }
50491: 
50491:         RegisterID base;
50491:         RegisterID index;
50491:         Scale scale;
50491:         int32_t offset;
50491:     };
50491: 
50491:     // AbsoluteAddress:
50491:     //
50491:     // Describes an memory operand given by a pointer.  For regular load & store
50491:     // operations an unwrapped void* will be used, rather than using this.
50491:     struct AbsoluteAddress {
50491:         explicit AbsoluteAddress(void* ptr)
50491:             : m_ptr(ptr)
50491:         {
50491:         }
50491: 
50491:         void* m_ptr;
50491:     };
50491: 
50491:     // ImmPtr:
50491:     //
50491:     // A pointer sized immediate operand to an instruction - this is wrapped
50491:     // in a class requiring explicit construction in order to differentiate
50491:     // from pointers used as absolute addresses to memory operations
50491:     struct ImmPtr {
50491:         explicit ImmPtr(const void* value)
50491:             : m_value(value)
50491:         {
50491:         }
50491: 
50491:         intptr_t asIntptr()
50491:         {
50491:             return reinterpret_cast<intptr_t>(m_value);
50491:         }
50491: 
50491:         const void* m_value;
50491:     };
50491: 
50491:     // Imm32:
50491:     //
50491:     // A 32bit immediate operand to an instruction - this is wrapped in a
50491:     // class requiring explicit construction in order to prevent RegisterIDs
50491:     // (which are implemented as an enum) from accidentally being passed as
50491:     // immediate values.
50491:     struct Imm32 {
50491:         explicit Imm32(int32_t value)
50491:             : m_value(value)
50491: #if WTF_CPU_ARM || WTF_CPU_MIPS
50491:             , m_isPointer(false)
50491: #endif
50491:         {
50491:         }
50491: 
50491: #if !WTF_CPU_X86_64
50491:         explicit Imm32(ImmPtr ptr)
50491:             : m_value(ptr.asIntptr())
50491: #if WTF_CPU_ARM || WTF_CPU_MIPS
50491:             , m_isPointer(true)
50491: #endif
50491:         {
50491:         }
50491: #endif
50491: 
50491:         int32_t m_value;
50491: #if WTF_CPU_ARM || WTF_CPU_MIPS
50491:         // We rely on being able to regenerate code to recover exception handling
50491:         // information.  Since ARMv7 supports 16-bit immediates there is a danger
50491:         // that if pointer values change the layout of the generated code will change.
50491:         // To avoid this problem, always generate pointers (and thus Imm32s constructed
50491:         // from ImmPtrs) with a code sequence that is able  to represent  any pointer
50491:         // value - don't use a more compact form in these cases.
50491:         // Same for MIPS.
50491:         bool m_isPointer;
50491: #endif
50491:     };
50491: 
50491: 
50491:     // Section 2: MacroAssembler code buffer handles
50491:     //
50491:     // The following types are used to reference items in the code buffer
50491:     // during JIT code generation.  For example, the type Jump is used to
50491:     // track the location of a jump instruction so that it may later be
50491:     // linked to a label marking its destination.
50491: 
50491: 
50491:     // Label:
50491:     //
50491:     // A Label records a point in the generated instruction stream, typically such that
50491:     // it may be used as a destination for a jump.
50491:     class Label {
50491:         template<class TemplateAssemblerType>
50491:         friend class AbstractMacroAssembler;
50491:         friend class Jump;
50491:         friend class MacroAssemblerCodeRef;
50491:         friend class LinkBuffer;
50491: 
50491:     public:
50491:         Label()
50491:         {
50491:         }
50491: 
50491:         Label(AbstractMacroAssembler<AssemblerType>* masm)
50491:             : m_label(masm->m_assembler.label())
50491:         {
50491:         }
50491:         
50491:         bool isUsed() const { return m_label.isUsed(); }
50491:         void used() { m_label.used(); }
50491:         bool isValid() const { return m_label.isValid(); }
50491:     private:
50491:         JmpDst m_label;
50491:     };
50491: 
50491:     // DataLabelPtr:
50491:     //
50491:     // A DataLabelPtr is used to refer to a location in the code containing a pointer to be
50491:     // patched after the code has been generated.
50491:     class DataLabelPtr {
50491:         template<class TemplateAssemblerType>
50491:         friend class AbstractMacroAssembler;
50491:         friend class LinkBuffer;
50491:     public:
50491:         DataLabelPtr()
50491:         {
50491:         }
50491: 
50491:         DataLabelPtr(AbstractMacroAssembler<AssemblerType>* masm)
50491:             : m_label(masm->m_assembler.label())
50491:         {
50491:         }
50491:         
50491:     private:
50491:         JmpDst m_label;
50491:     };
50491: 
50491:     // DataLabel32:
50491:     //
53408:     // A DataLabel32 is used to refer to a location in the code containing a
53408:     // 32-bit constant to be patched after the code has been generated.
50491:     class DataLabel32 {
50491:         template<class TemplateAssemblerType>
50491:         friend class AbstractMacroAssembler;
50491:         friend class LinkBuffer;
50491:     public:
50491:         DataLabel32()
50491:         {
50491:         }
50491: 
50491:         DataLabel32(AbstractMacroAssembler<AssemblerType>* masm)
50491:             : m_label(masm->m_assembler.label())
50491:         {
50491:         }
50491: 
50491:     private:
50491:         JmpDst m_label;
50491:     };
50491: 
50491:     // Call:
50491:     //
50491:     // A Call object is a reference to a call instruction that has been planted
50491:     // into the code buffer - it is typically used to link the call, setting the
50491:     // relative offset such that when executed it will call to the desired
50491:     // destination.
50491:     class Call {
50491:         template<class TemplateAssemblerType>
50491:         friend class AbstractMacroAssembler;
50491: 
50491:     public:
50491:         enum Flags {
50491:             None = 0x0,
50491:             Linkable = 0x1,
50491:             Near = 0x2,
50491:             LinkableNear = 0x3
50491:         };
50491: 
50491:         Call()
50491:             : m_flags(None)
50491:         {
50491:         }
50491:         
50491:         Call(JmpSrc jmp, Flags flags)
50491:             : m_jmp(jmp)
50491:             , m_flags(flags)
50491:         {
50491:         }
50491: 
50491:         bool isFlagSet(Flags flag)
50491:         {
50491:             return !!(m_flags & flag);
50491:         }
50491: 
50491:         static Call fromTailJump(Jump jump)
50491:         {
50491:             return Call(jump.m_jmp, Linkable);
50491:         }
50491: 
50491:         JmpSrc m_jmp;
50491:     private:
50491:         Flags m_flags;
50491:     };
50491: 
50491:     // Jump:
50491:     //
50491:     // A jump object is a reference to a jump instruction that has been planted
50491:     // into the code buffer - it is typically used to link the jump, setting the
50491:     // relative offset such that when executed it will jump to the desired
50491:     // destination.
50491:     class Jump {
50491:         template<class TemplateAssemblerType>
50491:         friend class AbstractMacroAssembler;
50491:         friend class Call;
50491:         friend class LinkBuffer;
50491:     public:
50491:         Jump()
50491:         {
50491:         }
50491:         
50491:         Jump(JmpSrc jmp)    
50491:             : m_jmp(jmp)
50491:         {
50491:         }
50491:         
50491:         void link(AbstractMacroAssembler<AssemblerType>* masm)
50491:         {
50491:             masm->m_assembler.linkJump(m_jmp, masm->m_assembler.label());
50491:         }
50491:         
50491:         void linkTo(Label label, AbstractMacroAssembler<AssemblerType>* masm)
50491:         {
50491:             masm->m_assembler.linkJump(m_jmp, label.m_label);
50491:         }
50491: 
50491:     private:
50491:         JmpSrc m_jmp;
50491:     };
50491: 
50491:     // JumpList:
50491:     //
50491:     // A JumpList is a set of Jump objects.
50491:     // All jumps in the set will be linked to the same destination.
50491:     class JumpList {
50491:         friend class LinkBuffer;
50491: 
50491:     public:
50491:         typedef js::Vector<Jump, 16 ,js::SystemAllocPolicy > JumpVector;
50491: 
50491:         void link(AbstractMacroAssembler<AssemblerType>* masm)
50491:         {
50491:             size_t size = m_jumps.length();
50491:             for (size_t i = 0; i < size; ++i)
50491:                 m_jumps[i].link(masm);
50491:             m_jumps.clear();
50491:         }
50491:         
50491:         void linkTo(Label label, AbstractMacroAssembler<AssemblerType>* masm)
50491:         {
50491:             size_t size = m_jumps.length();
50491:             for (size_t i = 0; i < size; ++i)
50491:                 m_jumps[i].linkTo(label, masm);
50491:             m_jumps.clear();
50491:         }
50491:         
50491:         void append(Jump jump)
50491:         {
50491:             m_jumps.append(jump);
50491:         }
50491:         
50491:         void append(JumpList& other)
50491:         {
50491:             m_jumps.append(other.m_jumps.begin(), other.m_jumps.length());
50491:         }
50491: 
50491:         bool empty()
50491:         {
50491:             return !m_jumps.length();
50491:         }
50491:         
50491:         const JumpVector& jumps() { return m_jumps; }
50491: 
50491:     private:
50491:         JumpVector m_jumps;
50491:     };
50491: 
50491: 
50491:     // Section 3: Misc admin methods
50491: 
50491:     static CodePtr trampolineAt(CodeRef ref, Label label)
50491:     {
50491:         return CodePtr(AssemblerType::getRelocatedAddress(ref.m_code.dataLocation(), label.m_label));
50491:     }
50491: 
50491:     size_t size()
50491:     {
50491:         return m_assembler.size();
50491:     }
50491: 
50491:     unsigned char *buffer()
50491:     {
50491:         return m_assembler.buffer();
50491:     }
50491: 
56037:     bool oom()
56037:     {
56037:         return m_assembler.oom();
56037:     }
56037: 
50491:     void* executableCopy(void* buffer)
50491:     {
50491:         return m_assembler.executableCopy(buffer);
50491:     }
50491: 
50491:     Label label()
50491:     {
50491:         return Label(this);
50491:     }
50491:     
50491:     Label align()
50491:     {
50491:         m_assembler.align(16);
50491:         return Label(this);
50491:     }
50491: 
50491:     ptrdiff_t differenceBetween(Label from, Jump to)
50491:     {
50491:         return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_jmp);
50491:     }
50491: 
50491:     ptrdiff_t differenceBetween(Label from, Call to)
50491:     {
50491:         return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_jmp);
50491:     }
50491: 
50491:     ptrdiff_t differenceBetween(Label from, Label to)
50491:     {
50491:         return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_label);
50491:     }
50491: 
50491:     ptrdiff_t differenceBetween(Label from, DataLabelPtr to)
50491:     {
50491:         return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_label);
50491:     }
50491: 
50491:     ptrdiff_t differenceBetween(Label from, DataLabel32 to)
50491:     {
50491:         return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_label);
50491:     }
50491: 
53408:     ptrdiff_t differenceBetween(DataLabel32 from, Label to)
53408:     {
53408:         return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_label);
53408:     }
53408: 
50491:     ptrdiff_t differenceBetween(DataLabelPtr from, Jump to)
50491:     {
50491:         return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_jmp);
50491:     }
50491: 
50491:     ptrdiff_t differenceBetween(DataLabelPtr from, DataLabelPtr to)
50491:     {
50491:         return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_label);
50491:     }
50491: 
50491:     ptrdiff_t differenceBetween(DataLabelPtr from, Call to)
50491:     {
50491:         return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_jmp);
50491:     }
50491: 
50491: protected:
50491:     AssemblerType m_assembler;
50491: 
50491:     friend class LinkBuffer;
50491:     friend class RepatchBuffer;
50491: 
50491:     static void linkJump(void* code, Jump jump, CodeLocationLabel target)
50491:     {
50491:         AssemblerType::linkJump(code, jump.m_jmp, target.dataLocation());
50491:     }
50491: 
50491:     static void linkPointer(void* code, typename AssemblerType::JmpDst label, void* value)
50491:     {
50491:         AssemblerType::linkPointer(code, label, value);
50491:     }
50491: 
50491:     static void* getLinkerAddress(void* code, typename AssemblerType::JmpSrc label)
50491:     {
50491:         return AssemblerType::getRelocatedAddress(code, label);
50491:     }
50491: 
50491:     static void* getLinkerAddress(void* code, typename AssemblerType::JmpDst label)
50491:     {
50491:         return AssemblerType::getRelocatedAddress(code, label);
50491:     }
50491: 
50491:     static unsigned getLinkerCallReturnOffset(Call call)
50491:     {
50491:         return AssemblerType::getCallReturnOffset(call.m_jmp);
50491:     }
50491: 
50491:     static void repatchJump(CodeLocationJump jump, CodeLocationLabel destination)
50491:     {
50491:         AssemblerType::relinkJump(jump.dataLocation(), destination.dataLocation());
50491:     }
50491: 
50491:     static void repatchNearCall(CodeLocationNearCall nearCall, CodeLocationLabel destination)
50491:     {
50491:         AssemblerType::relinkCall(nearCall.dataLocation(), destination.executableAddress());
50491:     }
50491: 
50491:     static void repatchInt32(CodeLocationDataLabel32 dataLabel32, int32_t value)
50491:     {
50491:         AssemblerType::repatchInt32(dataLabel32.dataLocation(), value);
50491:     }
50491: 
50491:     static void repatchPointer(CodeLocationDataLabelPtr dataLabelPtr, void* value)
50491:     {
50491:         AssemblerType::repatchPointer(dataLabelPtr.dataLocation(), value);
50491:     }
50491: 
50491:     static void repatchLoadPtrToLEA(CodeLocationInstruction instruction)
50491:     {
50491:         AssemblerType::repatchLoadPtrToLEA(instruction.dataLocation());
50491:     }
50491: 
50491:     static void repatchLEAToLoadPtr(CodeLocationInstruction instruction)
50491:     {
50491:         AssemblerType::repatchLEAToLoadPtr(instruction.dataLocation());
50491:     }
50491: };
50491: 
50491: } // namespace JSC
50491: 
50491: #endif // ENABLE(ASSEMBLER)
50491: 
50491: #endif // AbstractMacroAssembler_h
