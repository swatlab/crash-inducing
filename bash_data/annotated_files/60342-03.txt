    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object for CSS display:inline objects */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsInlineFrame.h"
    1: #include "nsBlockFrame.h"
32107: #include "nsPlaceholderFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsAbsoluteContainingBlock.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsFrameManager.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIServiceManager.h"
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: #include "nsDisplayList.h"
    1: 
    1: #ifdef DEBUG
    1: #undef NOISY_PUSHING
    1: #endif
    1: 
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: 
    1: // Basic nsInlineFrame methods
    1: 
    1: nsIFrame*
    1: NS_NewInlineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsInlineFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsInlineFrame)
32423: 
23554: NS_QUERYFRAME_HEAD(nsInlineFrame)
23554:   NS_QUERYFRAME_ENTRY(nsInlineFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsInlineFrameSuper)
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsInlineFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Inline"), aResult);
    1: }
    1: #endif
    1: 
    1: nsIAtom*
    1: nsInlineFrame::GetType() const
    1: {
    1:   return nsGkAtoms::inlineFrame;
    1: }
    1: 
12630: static inline PRBool
51776: IsMarginZero(const nsStyleCoord &aCoord)
    1: {
51777:   return aCoord.GetUnit() == eStyleUnit_Auto ||
52283:          nsLayoutUtils::IsMarginZero(aCoord);
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsInlineFrame::IsSelfEmpty()
    1: {
    1: #if 0
    1:   // I used to think inline frames worked this way, but it seems they
    1:   // don't.  At least not in our codebase.
    1:   if (GetPresContext()->CompatibilityMode() == eCompatibility_FullStandards) {
    1:     return PR_FALSE;
    1:   }
    1: #endif
    1:   const nsStyleMargin* margin = GetStyleMargin();
    1:   const nsStyleBorder* border = GetStyleBorder();
    1:   const nsStylePadding* padding = GetStylePadding();
    1:   // XXX Top and bottom removed, since they shouldn't affect things, but this
    1:   // doesn't really match with nsLineLayout.cpp's setting of
    1:   // ZeroEffectiveSpanBox, anymore, so what should this really be?
34461:   PRBool haveRight =
34461:     border->GetActualBorderWidth(NS_SIDE_RIGHT) != 0 ||
51777:     !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetRight()) ||
51776:     !IsMarginZero(margin->mMargin.GetRight());
34461:   PRBool haveLeft =
34461:     border->GetActualBorderWidth(NS_SIDE_LEFT) != 0 ||
51777:     !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetLeft()) ||
51776:     !IsMarginZero(margin->mMargin.GetLeft());
34461:   if (haveLeft || haveRight) {
34461:     if (GetStateBits() & NS_FRAME_IS_SPECIAL) {
34461:       PRBool haveStart, haveEnd;
34461:       if (NS_STYLE_DIRECTION_LTR == GetStyleVisibility()->mDirection) {
34461:         haveStart = haveLeft;
34461:         haveEnd = haveRight;
34461:       } else {
34461:         haveStart = haveRight;
34461:         haveEnd = haveLeft;
34461:       }
34461:       // For special frames, ignore things we know we'll skip in GetSkipSides.
34461:       // XXXbz should we be doing this for non-special frames too, in a more
34461:       // general way?
34461: 
34461:       // Get the first continuation eagerly, as a performance optimization, to
34461:       // avoid having to get it twice..
34461:       nsIFrame* firstCont = GetFirstContinuation();
34461:       return
34461:         (!haveStart || nsLayoutUtils::FrameIsNonFirstInIBSplit(firstCont)) &&
34461:         (!haveEnd || nsLayoutUtils::FrameIsNonLastInIBSplit(firstCont));
34461:     }
    1:     return PR_FALSE;
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsInlineFrame::IsEmpty()
    1: {
    1:   if (!IsSelfEmpty()) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   for (nsIFrame *kid = mFrames.FirstChild(); kid; kid = kid->GetNextSibling()) {
    1:     if (!kid->IsEmpty())
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
59604: nsInlineFrame::PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset,
59604:                                    PRBool aRespectClusters)
    1: {
    1:   // Override the implementation in nsFrame, to skip empty inline frames
    1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
    1:   PRInt32 startOffset = *aOffset;
    1:   if (startOffset < 0)
    1:     startOffset = 1;
    1:   if (aForward == (startOffset == 0)) {
    1:     // We're before the frame and moving forward, or after it and moving backwards:
    1:     // skip to the other side, but keep going.
    1:     *aOffset = 1 - startOffset;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsInlineFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                 const nsRect&           aDirtyRect,
    1:                                 const nsDisplayListSet& aLists)
    1: {
    1:   nsresult rv = nsHTMLContainerFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   // The sole purpose of this is to trigger display of the selection
    1:   // window for Named Anchors, which don't have any children and
    1:   // normally don't have any size, but in Editor we use CSS to display
    1:   // an image to represent this "hidden" element.
    1:   if (!mFrames.FirstChild()) {
52291:     rv = DisplaySelectionOverlay(aBuilder, aLists.Content());
    1:   }
    1:   return rv;
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: // Reflow methods
    1: 
    1: /* virtual */ void
    1: nsInlineFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                                  nsIFrame::InlineMinWidthData *aData)
    1: {
    1:   DoInlineIntrinsicWidth(aRenderingContext, aData, nsLayoutUtils::MIN_WIDTH);
    1: }
    1: 
    1: /* virtual */ void
    1: nsInlineFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                                   nsIFrame::InlinePrefWidthData *aData)
    1: {
    1:   DoInlineIntrinsicWidth(aRenderingContext, aData, nsLayoutUtils::PREF_WIDTH);
    1: }
    1: 
    1: /* virtual */ nsSize
    1: nsInlineFrame::ComputeSize(nsIRenderingContext *aRenderingContext,
    1:                            nsSize aCBSize, nscoord aAvailableWidth,
    1:                            nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                            PRBool aShrinkWrap)
    1: {
    1:   // Inlines and text don't compute size before reflow.
    1:   return nsSize(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: }
    1: 
 6862: nsRect
 6862: nsInlineFrame::ComputeTightBounds(gfxContext* aContext) const
 6862: {
 6862:   // be conservative
 6862:   if (GetStyleContext()->HasTextDecorations())
55035:     return GetVisualOverflowRect();
 6862:   return ComputeSimpleTightBounds(aContext);
 6862: }
 6862: 
  686: void
  686: nsInlineFrame::ReparentFloatsForInlineChild(nsIFrame* aOurLineContainer,
  686:                                             nsIFrame* aFrame,
  686:                                             PRBool aReparentSiblings)
  686: {
30781:   // XXXbz this would be better if it took a nsFrameList or a frame
30781:   // list slice....
  686:   NS_ASSERTION(aOurLineContainer->GetNextContinuation() ||
  686:                aOurLineContainer->GetPrevContinuation(),
  686:                "Don't call this when we have no continuation, it's a waste");
 3667:   if (!aFrame) {
 3667:     NS_ASSERTION(aReparentSiblings, "Why did we get called?");
 3667:     return;
 3667:   }
  686: 
  686:   nsIFrame* ancestor = aFrame;
  686:   nsIFrame* ancestorBlockChild;
  686:   do {
  686:     ancestorBlockChild = ancestor;
  686:     ancestor = ancestor->GetParent();
  686:     if (!ancestor)
  686:       return;
  686:   } while (!ancestor->IsFloatContainingBlock());
  686: 
  686:   if (ancestor == aOurLineContainer)
  686:     return;
  686: 
15909:   nsBlockFrame* ourBlock = nsLayoutUtils::GetAsBlock(aOurLineContainer);
15909:   NS_ASSERTION(ourBlock, "Not a block, but broke vertically?");
15909:   nsBlockFrame* frameBlock = nsLayoutUtils::GetAsBlock(ancestor);
15909:   NS_ASSERTION(frameBlock, "ancestor not a block");
  686: 
32846:   const nsFrameList& blockChildren(ancestor->GetChildList(nsnull));
  686:   PRBool isOverflow = !blockChildren.ContainsFrame(ancestorBlockChild);
  686: 
  686:   while (PR_TRUE) {
  686:     ourBlock->ReparentFloats(aFrame, frameBlock, isOverflow, PR_FALSE);
  686: 
  686:     if (!aReparentSiblings)
  686:       return;
  686:     nsIFrame* next = aFrame->GetNextSibling();
  686:     if (!next)
  686:       return;
  686:     if (next->GetParent() == aFrame->GetParent()) {
  686:       aFrame = next;
  686:       continue;
  686:     }
  686:     // This is paranoid and will hardly ever get hit ... but we can't actually
  686:     // trust that the frames in the sibling chain all have the same parent,
  686:     // because lazy reparenting may be going on. If we find a different
  686:     // parent we need to redo our analysis.
  686:     ReparentFloatsForInlineChild(aOurLineContainer, next, aReparentSiblings);
  686:     return;
  686:   }
  686: }
  686: 
36803: static void
40137: ReparentChildListStyle(nsPresContext* aPresContext,
36803:                        const nsFrameList::Slice& aFrames,
36803:                        nsIFrame* aParentFrame)
36803: {
36803:   nsFrameManager *frameManager = aPresContext->FrameManager();
36803: 
36803:   for (nsFrameList::Enumerator e(aFrames); !e.AtEnd(); e.Next()) {
36803:     NS_ASSERTION(e.get()->GetParent() == aParentFrame, "Bogus parentage");
40137:     frameManager->ReparentStyleContext(e.get());
36803:   }
36803: }
36803: 
    1: NS_IMETHODIMP
    1: nsInlineFrame::Reflow(nsPresContext*          aPresContext,
    1:                       nsHTMLReflowMetrics&     aMetrics,
    1:                       const nsHTMLReflowState& aReflowState,
    1:                       nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsInlineFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
    1:   if (nsnull == aReflowState.mLineLayout) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   PRBool  lazilySetParentPointer = PR_FALSE;
    1: 
  686:   nsIFrame* lineContainer = aReflowState.mLineLayout->GetLineContainerFrame();
  686: 
    1:    // Check for an overflow list with our prev-in-flow
    1:   nsInlineFrame* prevInFlow = (nsInlineFrame*)GetPrevInFlow();
    1:   if (nsnull != prevInFlow) {
30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
    1: 
    1:     if (prevOverflowFrames) {
    1:       // When pushing and pulling frames we need to check for whether any
    1:       // views need to be reparented.
30781:       nsHTMLContainerFrame::ReparentFrameViewList(aPresContext,
30781:                                                   *prevOverflowFrames,
    1:                                                   prevInFlow, this);
    1: 
24722:       // Check if we should do the lazilySetParentPointer optimization.
24722:       // Only do it in simple cases where we're being reflowed for the
24722:       // first time, nothing (e.g. bidi resolution) has already given
24722:       // us children, and there's no next-in-flow, so all our frames
24722:       // will be taken from prevOverflowFrames.
24722:       if ((GetStateBits() & NS_FRAME_FIRST_REFLOW) && mFrames.IsEmpty() &&
24722:           !GetNextInFlow()) {
30781:         // If our child list is empty, just put the new frames into it.
    1:         // Note that we don't set the parent pointer for the new frames. Instead wait
    1:         // to do this until we actually reflow the frame. If the overflow list contains
    1:         // thousands of frames this is a big performance issue (see bug #5588)
30790:         mFrames.SetFrames(*prevOverflowFrames);
    1:         lazilySetParentPointer = PR_TRUE;
    1:       } else {
  686:         // Assign all floats to our block if necessary
  686:         if (lineContainer && lineContainer->GetPrevContinuation()) {
30781:           ReparentFloatsForInlineChild(lineContainer,
30781:                                        prevOverflowFrames->FirstChild(),
30781:                                        PR_TRUE);
  686:         }
    1:         // Insert the new frames at the beginning of the child list
    1:         // and set their parent pointer
36803:         const nsFrameList::Slice& newFrames =
30781:           mFrames.InsertFrames(this, nsnull, *prevOverflowFrames);
36803:         // If our prev in flow was under the first continuation of a first-line
36803:         // frame then we need to reparent the style contexts to remove the
36803:         // the special first-line styling. In the lazilySetParentPointer case
36803:         // we reparent the style contexts when we set their parents in
36803:         // nsInlineFrame::ReflowFrames and nsInlineFrame::ReflowInlineFrame.
36803:         if (aReflowState.mLineLayout->GetInFirstLine()) {
40137:           ReparentChildListStyle(aPresContext, newFrames, this);
36803:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // It's also possible that we have an overflow list for ourselves
    1: #ifdef DEBUG
    1:   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
    1:     // If it's our initial reflow, then we should not have an overflow list.
    1:     // However, add an assertion in case we get reflowed more than once with
    1:     // the initial reflow reason
30781:     nsFrameList* overflowFrames = GetOverflowFrames();
30781:     NS_ASSERTION(!overflowFrames || overflowFrames->IsEmpty(),
30781:                  "overflow list is not empty for initial reflow");
    1:   }
    1: #endif
    1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
30781:     nsAutoPtr<nsFrameList> overflowFrames(StealOverflowFrames());
    1:     if (overflowFrames) {
    1:       NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
    1: 
    1:       // Because we lazily set the parent pointer of child frames we get from
    1:       // our prev-in-flow's overflow list, it's possible that we have not set
    1:       // the parent pointer for these frames.
30781:       mFrames.AppendFrames(this, *overflowFrames);
    1:     }
    1:   }
    1: 
    1:   if (IsFrameTreeTooDeep(aReflowState, aMetrics)) {
    1:     aStatus = NS_FRAME_COMPLETE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Set our own reflow state (additional state above and beyond
    1:   // aReflowState)
    1:   InlineReflowState irs;
    1:   irs.mPrevFrame = nsnull;
  686:   irs.mLineContainer = lineContainer;
34500:   irs.mLineLayout = aReflowState.mLineLayout;
    1:   irs.mNextInFlow = (nsInlineFrame*) GetNextInFlow();
    1:   irs.mSetParentPointer = lazilySetParentPointer;
    1: 
    1:   nsresult rv;
    1:   if (mFrames.IsEmpty()) {
    1:     // Try to pull over one frame before starting so that we know
    1:     // whether we have an anonymous block or not.
    1:     PRBool complete;
    1:     (void) PullOneFrame(aPresContext, irs, &complete);
    1:   }
    1: 
    1:   rv = ReflowFrames(aPresContext, aReflowState, irs, aMetrics, aStatus);
    1:   
    1:   // Note: the line layout code will properly compute our
26950:   // overflow-rect state for us.
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
    1:   return rv;
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsInlineFrame::CanContinueTextRun() const
    1: {
    1:   // We can continue a text run through an inline frame
    1:   return PR_TRUE;
    1: }
    1: 
30638: /* virtual */ void
30638: nsInlineFrame::PullOverflowsFromPrevInFlow()
30638: {
30638:   nsInlineFrame* prevInFlow = static_cast<nsInlineFrame*>(GetPrevInFlow());
30638:   if (prevInFlow) {
30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
30638:     if (prevOverflowFrames) {
30638:       // Assume that our prev-in-flow has the same line container that we do.
31288:       nsHTMLContainerFrame::ReparentFrameViewList(PresContext(),
31288:                                                   *prevOverflowFrames,
31288:                                                   prevInFlow, this);
30781:       mFrames.InsertFrames(this, nsnull, *prevOverflowFrames);
30638:     }
30638:   }
30638: }
30638: 
    1: nsresult
    1: nsInlineFrame::ReflowFrames(nsPresContext* aPresContext,
    1:                             const nsHTMLReflowState& aReflowState,
    1:                             InlineReflowState& irs,
    1:                             nsHTMLReflowMetrics& aMetrics,
    1:                             nsReflowStatus& aStatus)
    1: {
    1:   nsresult rv = NS_OK;
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
    1:   nsLineLayout* lineLayout = aReflowState.mLineLayout;
36803:   PRBool inFirstLine = aReflowState.mLineLayout->GetInFirstLine();
36803:   nsFrameManager* frameManager = aPresContext->FrameManager();
    1:   PRBool ltr = (NS_STYLE_DIRECTION_LTR == aReflowState.mStyleVisibility->mDirection);
    1:   nscoord leftEdge = 0;
28217:   // Don't offset by our start borderpadding if we have a prev continuation or
34460:   // if we're in a part of an {ib} split other than the first one.
28217:   if (!GetPrevContinuation() &&
34460:       !nsLayoutUtils::FrameIsNonFirstInIBSplit(this)) {
    1:     leftEdge = ltr ? aReflowState.mComputedBorderPadding.left
    1:                    : aReflowState.mComputedBorderPadding.right;
    1:   }
    1:   nscoord availableWidth = aReflowState.availableWidth;
 8982:   NS_ASSERTION(availableWidth != NS_UNCONSTRAINEDSIZE,
 8982:                "should no longer use available widths");
    1:   // Subtract off left and right border+padding from availableWidth
    1:   availableWidth -= leftEdge;
    1:   availableWidth -= ltr ? aReflowState.mComputedBorderPadding.right
    1:                         : aReflowState.mComputedBorderPadding.left;
    1:   lineLayout->BeginSpan(this, &aReflowState, leftEdge, leftEdge + availableWidth);
    1: 
    1:   // First reflow our current children
    1:   nsIFrame* frame = mFrames.FirstChild();
    1:   PRBool done = PR_FALSE;
    1:   while (nsnull != frame) {
    1:     PRBool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
    1: 
    1:     // Check if we should lazily set the child frame's parent pointer
    1:     if (irs.mSetParentPointer) {
  686:       PRBool havePrevBlock =
  686:         irs.mLineContainer && irs.mLineContainer->GetPrevContinuation();
  686:       // If our block is the first in flow, then any floats under the pulled
  686:       // frame must already belong to our block.
  686:       if (havePrevBlock) {
  686:         // This has to happen before we update frame's parent; we need to
  686:         // know frame's ancestry under its old block.
  686:         // The blockChildren.ContainsFrame check performed by
  686:         // ReparentFloatsForInlineChild here may be slow, but we can't
  686:         // easily avoid it because we don't know where 'frame' originally
  686:         // came from. If we really really have to optimize this we could
  686:         // cache whether frame->GetParent() is under its containing blocks
  686:         // overflowList or not.
  686:         ReparentFloatsForInlineChild(irs.mLineContainer, frame, PR_FALSE);
  686:       }
    1:       frame->SetParent(this);
36803:       if (inFirstLine) {
40137:         frameManager->ReparentStyleContext(frame);
36803:       }
    1:       // We also need to check if frame has a next-in-flow. If it does, then set
    1:       // its parent frame pointer, too. Otherwise, if we reflow frame and it's
    1:       // complete we'll fail when deleting its next-in-flow which is no longer
    1:       // needed. This scenario doesn't happen often, but it can happen
    1:       nsIFrame* nextInFlow = frame->GetNextInFlow();
22469:       for ( ; nextInFlow; nextInFlow = nextInFlow->GetNextInFlow()) {
    1:         // Since we only do lazy setting of parent pointers for the frame's
    1:         // initial reflow, this frame can't have a next-in-flow. That means
    1:         // the continuing child frame must be in our child list as well. If
    1:         // not, then something is wrong
    1:         NS_ASSERTION(mFrames.ContainsFrame(nextInFlow), "unexpected flow");
  686:         if (havePrevBlock) {
  686:           ReparentFloatsForInlineChild(irs.mLineContainer, nextInFlow, PR_FALSE);
  686:         }
    1:         nextInFlow->SetParent(this);
36803:         if (inFirstLine) {
40137:           frameManager->ReparentStyleContext(nextInFlow);
36803:         }
22469:       }
22469: 
22469:       // Fix the parent pointer for ::first-letter child frame next-in-flows,
22469:       // so nsFirstLetterFrame::Reflow can destroy them safely (bug 401042).
22469:       nsIFrame* realFrame = nsPlaceholderFrame::GetRealFrameFor(frame);
22469:       if (realFrame->GetType() == nsGkAtoms::letterFrame) {
22469:         nsIFrame* child = realFrame->GetFirstChild(nsnull);
22469:         if (child) {
22469:           NS_ASSERTION(child->GetType() == nsGkAtoms::textFrame,
22469:                        "unexpected frame type");
22469:           nsIFrame* nextInFlow = child->GetNextInFlow();
22469:           for ( ; nextInFlow; nextInFlow = nextInFlow->GetNextInFlow()) {
22469:             NS_ASSERTION(nextInFlow->GetType() == nsGkAtoms::textFrame,
22469:                          "unexpected frame type");
22469:             if (mFrames.ContainsFrame(nextInFlow)) {
22469:               nextInFlow->SetParent(this);
36803:               if (inFirstLine) {
40137:                 frameManager->ReparentStyleContext(nextInFlow);
36803:               }
22469:             }
22469:             else {
22469: #ifdef DEBUG              
22469:               // Once we find a next-in-flow that isn't ours none of the
22469:               // remaining next-in-flows should be either.
22469:               for ( ; nextInFlow; nextInFlow = nextInFlow->GetNextInFlow()) {
22469:                 NS_ASSERTION(!mFrames.ContainsFrame(nextInFlow),
22469:                              "unexpected letter frame flow");
22469:               }
22469: #endif
22469:               break;
22469:             }
22469:           }
22469:         }
    1:       }
    1:     }
    1:     rv = ReflowInlineFrame(aPresContext, aReflowState, irs, frame, aStatus);
    1:     if (NS_FAILED(rv)) {
    1:       done = PR_TRUE;
    1:       break;
    1:     }
    1:     if (NS_INLINE_IS_BREAK(aStatus) || 
    1:         (!reflowingFirstLetter && NS_FRAME_IS_NOT_COMPLETE(aStatus))) {
    1:       done = PR_TRUE;
    1:       break;
    1:     }
    1:     irs.mPrevFrame = frame;
    1:     frame = frame->GetNextSibling();
    1:   }
    1: 
    1:   // Attempt to pull frames from our next-in-flow until we can't
    1:   if (!done && (nsnull != GetNextInFlow())) {
    1:     while (!done) {
    1:       PRBool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
    1:       PRBool isComplete;
    1:       if (!frame) { // Could be non-null if we pulled a first-letter frame and
    1:                     // it created a continuation, since we don't push those.
    1:         frame = PullOneFrame(aPresContext, irs, &isComplete);
    1:       }
    1: #ifdef NOISY_PUSHING
    1:       printf("%p pulled up %p\n", this, frame);
    1: #endif
    1:       if (nsnull == frame) {
    1:         if (!isComplete) {
    1:           aStatus = NS_FRAME_NOT_COMPLETE;
    1:         }
    1:         break;
    1:       }
    1:       rv = ReflowInlineFrame(aPresContext, aReflowState, irs, frame, aStatus);
    1:       if (NS_FAILED(rv)) {
    1:         done = PR_TRUE;
    1:         break;
    1:       }
    1:       if (NS_INLINE_IS_BREAK(aStatus) || 
    1:           (!reflowingFirstLetter && NS_FRAME_IS_NOT_COMPLETE(aStatus))) {
    1:         done = PR_TRUE;
    1:         break;
    1:       }
    1:       irs.mPrevFrame = frame;
    1:       frame = frame->GetNextSibling();
    1:     }
    1:   }
    1: #ifdef DEBUG
    1:   if (NS_FRAME_IS_COMPLETE(aStatus)) {
    1:     // We can't be complete AND have overflow frames!
30781:     NS_ASSERTION(!GetOverflowFrames(), "whoops");
    1:   }
    1: #endif
    1: 
    1:   // If after reflowing our children they take up no area then make
    1:   // sure that we don't either.
    1:   //
    1:   // Note: CSS demands that empty inline elements still affect the
    1:   // line-height calculations. However, continuations of an inline
    1:   // that are empty we force to empty so that things like collapsed
    1:   // whitespace in an inline element don't affect the line-height.
 8983:   aMetrics.width = lineLayout->EndSpan(this);
 1123: 
28217:   // Compute final width.
28217: 
28217:   // Make sure to not include our start border and padding if we have a prev
34460:   // continuation or if we're in a part of an {ib} split other than the first
34460:   // one.
28217:   if (!GetPrevContinuation() &&
34460:       !nsLayoutUtils::FrameIsNonFirstInIBSplit(this)) {
    1:     aMetrics.width += ltr ? aReflowState.mComputedBorderPadding.left
    1:                           : aReflowState.mComputedBorderPadding.right;
    1:   }
28217: 
28217:   /*
28217:    * We want to only apply the end border and padding if we're the last
34460:    * continuation and either not in an {ib} split or the last part of it.  To
34460:    * be the last continuation we have to be complete (so that we won't get a
34460:    * next-in-flow) and have no non-fluid continuations on our continuation
34460:    * chain.
28217:    */
28217:   if (NS_FRAME_IS_COMPLETE(aStatus) &&
28290:       !GetLastInFlow()->GetNextContinuation() &&
34460:       !nsLayoutUtils::FrameIsNonLastInIBSplit(this)) {
    1:     aMetrics.width += ltr ? aReflowState.mComputedBorderPadding.right
    1:                           : aReflowState.mComputedBorderPadding.left;
    1:   }
    1: 
 1105:   nsLayoutUtils::SetFontFromStyle(aReflowState.rendContext, mStyleContext);
    1:   nsCOMPtr<nsIFontMetrics> fm;
    1:   aReflowState.rendContext->GetFontMetrics(*getter_AddRefs(fm));
    1: 
    1:   if (fm) {
    1:     // Compute final height of the frame.
    1:     //
    1:     // Do things the standard css2 way -- though it's hard to find it
    1:     // in the css2 spec! It's actually found in the css1 spec section
    1:     // 4.4 (you will have to read between the lines to really see
    1:     // it).
    1:     //
    1:     // The height of our box is the sum of our font size plus the top
    1:     // and bottom border and padding. The height of children do not
    1:     // affect our height.
    1:     fm->GetMaxAscent(aMetrics.ascent);
    1:     fm->GetHeight(aMetrics.height);
    1:   } else {
    1:     NS_WARNING("Cannot get font metrics - defaulting sizes to 0");
    1:     aMetrics.ascent = aMetrics.height = 0;
    1:   }
    1:   aMetrics.ascent += aReflowState.mComputedBorderPadding.top;
    1:   aMetrics.height += aReflowState.mComputedBorderPadding.top +
    1:     aReflowState.mComputedBorderPadding.bottom;
    1: 
    1:   // For now our overflow area is zero. The real value will be
11780:   // computed in |nsLineLayout::RelativePositionFrames|.
55039:   aMetrics.mOverflowAreas.Clear();
    1: 
    1: #ifdef NOISY_FINAL_SIZE
    1:   ListTag(stdout);
    1:   printf(": metrics=%d,%d ascent=%d\n",
    1:          aMetrics.width, aMetrics.height, aMetrics.ascent);
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsInlineFrame::ReflowInlineFrame(nsPresContext* aPresContext,
    1:                                  const nsHTMLReflowState& aReflowState,
    1:                                  InlineReflowState& irs,
    1:                                  nsIFrame* aFrame,
    1:                                  nsReflowStatus& aStatus)
    1: {
    1:   nsLineLayout* lineLayout = aReflowState.mLineLayout;
    1:   PRBool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
    1:   PRBool pushedFrame;
    1:   nsresult rv =
    1:     lineLayout->ReflowFrame(aFrame, aStatus, nsnull, pushedFrame);
    1:   
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
46400: 
    1:   if (NS_INLINE_IS_BREAK_BEFORE(aStatus)) {
    1:     if (aFrame != mFrames.FirstChild()) {
    1:       // Change break-before status into break-after since we have
    1:       // already placed at least one child frame. This preserves the
    1:       // break-type so that it can be propagated upward.
    1:       aStatus = NS_FRAME_NOT_COMPLETE |
    1:         NS_INLINE_BREAK | NS_INLINE_BREAK_AFTER |
    1:         (aStatus & NS_INLINE_BREAK_TYPE_MASK);
34500:       PushFrames(aPresContext, aFrame, irs.mPrevFrame, irs);
    1:     }
    1:     else {
    1:       // Preserve reflow status when breaking-before our first child
    1:       // and propagate it upward without modification.
    1:       // Note: if we're lazily setting the frame pointer for our child 
    1:       // frames, then we need to set it now. Don't return and leave the
    1:       // remaining child frames in our child list with the wrong parent
    1:       // frame pointer...
    1:       if (irs.mSetParentPointer) {
  686:         if (irs.mLineContainer && irs.mLineContainer->GetPrevContinuation()) {
  686:           ReparentFloatsForInlineChild(irs.mLineContainer, aFrame->GetNextSibling(),
  686:                                        PR_TRUE);
  686:         }
    1:         for (nsIFrame* f = aFrame->GetNextSibling(); f; f = f->GetNextSibling()) {
    1:           f->SetParent(this);
36803:           if (lineLayout->GetInFirstLine()) {
40137:             aPresContext->FrameManager()->ReparentStyleContext(f);
36803:           }
    1:         }
    1:       }
    1:     }
46400:     return NS_OK;
    1:   }
46400: 
46400:   // Create a next-in-flow if needed.
46400:   if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
    1:     nsIFrame* newFrame;
32841:     rv = CreateNextInFlow(aPresContext, aFrame, newFrame);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:   }
46400: 
46400:   if (NS_INLINE_IS_BREAK_AFTER(aStatus)) {
    1:     nsIFrame* nextFrame = aFrame->GetNextSibling();
    1:     if (nextFrame) {
 4006:       NS_FRAME_SET_INCOMPLETE(aStatus);
34500:       PushFrames(aPresContext, nextFrame, aFrame, irs);
    1:     }
46400:     else {
    1:       // We must return an incomplete status if there are more child
    1:       // frames remaining in a next-in-flow that follows this frame.
46400:       nsInlineFrame* nextInFlow = static_cast<nsInlineFrame*>(GetNextInFlow());
46400:       while (nextInFlow) {
    1:         if (nextInFlow->mFrames.NotEmpty()) {
 4006:           NS_FRAME_SET_INCOMPLETE(aStatus);
    1:           break;
    1:         }
46400:         nextInFlow = static_cast<nsInlineFrame*>(nextInFlow->GetNextInFlow());
    1:       }
    1:     }
46400:     return NS_OK;
    1:   }
46400: 
46400:   if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus) && !reflowingFirstLetter) {
    1:     nsIFrame* nextFrame = aFrame->GetNextSibling();
    1:     if (nextFrame) {
34500:       PushFrames(aPresContext, nextFrame, aFrame, irs);
    1:     }
    1:   }
46400:   return NS_OK;
    1: }
    1: 
    1: nsIFrame*
    1: nsInlineFrame::PullOneFrame(nsPresContext* aPresContext,
    1:                             InlineReflowState& irs,
    1:                             PRBool* aIsComplete)
    1: {
    1:   PRBool isComplete = PR_TRUE;
    1: 
    1:   nsIFrame* frame = nsnull;
    1:   nsInlineFrame* nextInFlow = irs.mNextInFlow;
    1:   while (nsnull != nextInFlow) {
  686:     frame = nextInFlow->mFrames.FirstChild();
37866: 
37866:     if (!frame) {
37866:       // If the principal childlist has no frames, then try moving the overflow
37866:       // frames to it.
37866:       nsAutoPtr<nsFrameList> overflowFrames(nextInFlow->StealOverflowFrames());
37866:       if (overflowFrames) {
37866:         nextInFlow->mFrames.SetFrames(*overflowFrames);
37866:         frame = nextInFlow->mFrames.FirstChild();
37866:       }
37866:     }
37866: 
    1:     if (nsnull != frame) {
  686:       // If our block has no next continuation, then any floats belonging to
  686:       // the pulled frame must belong to our block already. This check ensures
  686:       // we do no extra work in the common non-vertical-breaking case.
  686:       if (irs.mLineContainer && irs.mLineContainer->GetNextContinuation()) {
  686:         // The blockChildren.ContainsFrame check performed by
  686:         // ReparentFloatsForInlineChild will be fast because frame's ancestor
  686:         // will be the first child of its containing block.
  686:         ReparentFloatsForInlineChild(irs.mLineContainer, frame, PR_FALSE);
  686:       }
  686:       nextInFlow->mFrames.RemoveFirstChild();
36452: 
36452:       // If we removed the last frame from the principal child list then move
36452:       // any overflow frames to it.
36452:       if (!nextInFlow->mFrames.FirstChild()) {
36452:         nsAutoPtr<nsFrameList> overflowFrames(nextInFlow->StealOverflowFrames());
36452:         if (overflowFrames) {
36452:           nextInFlow->mFrames.SetFrames(*overflowFrames);
36452:         }
36452:       }
36452: 
  686:       mFrames.InsertFrame(this, irs.mPrevFrame, frame);
    1:       isComplete = PR_FALSE;
34500:       if (irs.mLineLayout) {
34500:         irs.mLineLayout->SetDirtyNextLine();
34500:       }
    1:       nsHTMLContainerFrame::ReparentFrameView(aPresContext, frame, nextInFlow, this);
    1:       break;
    1:     }
    1:     nextInFlow = (nsInlineFrame*) nextInFlow->GetNextInFlow();
    1:     irs.mNextInFlow = nextInFlow;
    1:   }
    1: 
    1:   *aIsComplete = isComplete;
    1:   return frame;
    1: }
    1: 
    1: void
    1: nsInlineFrame::PushFrames(nsPresContext* aPresContext,
    1:                           nsIFrame* aFromChild,
34500:                           nsIFrame* aPrevSibling,
34500:                           InlineReflowState& aState)
    1: {
32841:   NS_PRECONDITION(aFromChild, "null pointer");
32841:   NS_PRECONDITION(aPrevSibling, "pushing first child");
    1:   NS_PRECONDITION(aPrevSibling->GetNextSibling() == aFromChild, "bad prev sibling");
    1: 
    1: #ifdef NOISY_PUSHING
    1:   printf("%p pushing aFromChild %p, disconnecting from prev sib %p\n", 
    1:          this, aFromChild, aPrevSibling);
    1: #endif
    1: 
    1:   // Add the frames to our overflow list (let our next in flow drain
    1:   // our overflow list when it is ready)
32841:   SetOverflowFrames(aPresContext, mFrames.RemoveFramesAfter(aPrevSibling));
34500:   if (aState.mLineLayout) {
34500:     aState.mLineLayout->SetDirtyNextLine();
34500:   }
    1: }
    1: 
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: 
    1: PRIntn
    1: nsInlineFrame::GetSkipSides() const
    1: {
    1:   PRIntn skip = 0;
    1:   if (!IsLeftMost()) {
    1:     nsInlineFrame* prev = (nsInlineFrame*) GetPrevContinuation();
    1:     if ((GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET) ||
    1:         (prev && (prev->mRect.height || prev->mRect.width))) {
    1:       // Prev continuation is not empty therefore we don't render our left
    1:       // border edge.
    1:       skip |= 1 << NS_SIDE_LEFT;
    1:     }
    1:     else {
    1:       // If the prev continuation is empty, then go ahead and let our left
    1:       // edge border render.
    1:     }
    1:   }
    1:   if (!IsRightMost()) {
    1:     nsInlineFrame* next = (nsInlineFrame*) GetNextContinuation();
    1:     if ((GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET) ||
    1:         (next && (next->mRect.height || next->mRect.width))) {
    1:       // Next continuation is not empty therefore we don't render our right
    1:       // border edge.
    1:       skip |= 1 << NS_SIDE_RIGHT;
    1:     }
    1:     else {
    1:       // If the next continuation is empty, then go ahead and let our right
    1:       // edge border render.
    1:     }
    1:   }
28217: 
28217:   if (GetStateBits() & NS_FRAME_IS_SPECIAL) {
34460:     // All but the last part of an {ib} split should skip the "end" side (as
34460:     // determined by this frame's direction) and all but the first part of such
34460:     // a split should skip the "start" side.  But figuring out which part of
34460:     // the split we are involves getting our first continuation, which might be
28217:     // expensive.  So don't bother if we already have the relevant bits set.
28217:     PRBool ltr = (NS_STYLE_DIRECTION_LTR == GetStyleVisibility()->mDirection);
28217:     PRIntn startBit = (1 << (ltr ? NS_SIDE_LEFT : NS_SIDE_RIGHT));
28217:     PRIntn endBit = (1 << (ltr ? NS_SIDE_RIGHT : NS_SIDE_LEFT));
28217:     if (((startBit | endBit) & skip) != (startBit | endBit)) {
28217:       // We're missing one of the skip bits, so check whether we need to set it.
34460:       // Only get the first continuation once, as an optimization.
34460:       nsIFrame* firstContinuation = GetFirstContinuation();
34460:       if (nsLayoutUtils::FrameIsNonLastInIBSplit(firstContinuation)) {
28217:         skip |= endBit;
34460:       }
34460:       if (nsLayoutUtils::FrameIsNonFirstInIBSplit(firstContinuation)) {
28217:         skip |= startBit;
28217:       }
28217:     }
28217:   }
28217: 
    1:   return skip;
    1: }
    1: 
56866: nscoord
56866: nsInlineFrame::GetBaseline() const
56866: {
56866:   nscoord ascent = 0;
56866:   nsCOMPtr<nsIFontMetrics> fm;
56866:   if (NS_SUCCEEDED(nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm)))) {
56866:     fm->GetMaxAscent(ascent);
56866:   }
56866:   return ascent + GetUsedBorderAndPadding().top;
56866: }
56866: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsInlineFrame::CreateAccessible()
    1: {
    1:   // Broken image accessibles are created here, because layout
    1:   // replaces the image or image control frame with an inline frame
    1:   nsIAtom *tagAtom = mContent->Tag();
    1:   if ((tagAtom == nsGkAtoms::img || tagAtom == nsGkAtoms::input || 
33329:        tagAtom == nsGkAtoms::label) && mContent->IsHTML()) {
    1:     // Only get accessibility service if we're going to use it
    1:     nsCOMPtr<nsIAccessibilityService> accService(do_GetService("@mozilla.org/accessibilityService;1"));
    1:     if (!accService)
46338:       return nsnull;
    1:     if (tagAtom == nsGkAtoms::input)  // Broken <input type=image ... />
46338:       return accService->CreateHTMLButtonAccessible(mContent,
46338:                                                     PresContext()->PresShell());
    1:     else if (tagAtom == nsGkAtoms::img)  // Create accessible for broken <img>
46338:       return accService->CreateHTMLImageAccessible(mContent,
46338:                                                    PresContext()->PresShell());
    1:     else if (tagAtom == nsGkAtoms::label)  // Creat accessible for <label>
46338:       return accService->CreateHTMLLabelAccessible(mContent,
46338:                                                    PresContext()->PresShell());
    1:   }
    1: 
46338:   return nsnull;
    1: }
    1: #endif
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: 
    1: // nsLineFrame implementation
    1: 
    1: nsIFrame*
    1: NS_NewFirstLineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsFirstLineFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsFirstLineFrame)
32423: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsFirstLineFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Line"), aResult);
    1: }
    1: #endif
    1: 
    1: nsIAtom*
    1: nsFirstLineFrame::GetType() const
    1: {
    1:   return nsGkAtoms::lineFrame;
    1: }
    1: 
    1: nsIFrame*
  686: nsFirstLineFrame::PullOneFrame(nsPresContext* aPresContext, InlineReflowState& irs,
  686:                                PRBool* aIsComplete)
    1: {
    1:   nsIFrame* frame = nsInlineFrame::PullOneFrame(aPresContext, irs, aIsComplete);
    1:   if (frame && !GetPrevInFlow()) {
    1:     // We are a first-line frame. Fixup the child frames
    1:     // style-context that we just pulled.
    1:     NS_ASSERTION(frame->GetParent() == this, "Incorrect parent?");
40137:     aPresContext->FrameManager()->ReparentStyleContext(frame);
    1:   }
    1:   return frame;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFirstLineFrame::Reflow(nsPresContext* aPresContext,
    1:                          nsHTMLReflowMetrics& aMetrics,
    1:                          const nsHTMLReflowState& aReflowState,
    1:                          nsReflowStatus& aStatus)
    1: {
    1:   if (nsnull == aReflowState.mLineLayout) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
  686:   nsIFrame* lineContainer = aReflowState.mLineLayout->GetLineContainerFrame();
  686: 
    1:   // Check for an overflow list with our prev-in-flow
    1:   nsFirstLineFrame* prevInFlow = (nsFirstLineFrame*)GetPrevInFlow();
    1:   if (nsnull != prevInFlow) {
30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
    1:     if (prevOverflowFrames) {
  686:       // Assign all floats to our block if necessary
  686:       if (lineContainer && lineContainer->GetPrevContinuation()) {
30781:         ReparentFloatsForInlineChild(lineContainer,
30781:                                      prevOverflowFrames->FirstChild(),
30781:                                      PR_TRUE);
  686:       }
30781:       const nsFrameList::Slice& newFrames =
30781:         mFrames.InsertFrames(this, nsnull, *prevOverflowFrames);
40137:       ReparentChildListStyle(aPresContext, newFrames, this);
    1:     }
    1:   }
    1: 
    1:   // It's also possible that we have an overflow list for ourselves
30781:   nsAutoPtr<nsFrameList> overflowFrames(StealOverflowFrames());
    1:   if (overflowFrames) {
    1:     NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
    1: 
30781:     const nsFrameList::Slice& newFrames =
30781:       mFrames.AppendFrames(nsnull, *overflowFrames);
40137:     ReparentChildListStyle(aPresContext, newFrames, this);
    1:   }
    1: 
    1:   // Set our own reflow state (additional state above and beyond
    1:   // aReflowState)
    1:   InlineReflowState irs;
    1:   irs.mPrevFrame = nsnull;
  686:   irs.mLineContainer = lineContainer;
36220:   irs.mLineLayout = aReflowState.mLineLayout;
    1:   irs.mNextInFlow = (nsInlineFrame*) GetNextInFlow();
    1: 
    1:   nsresult rv;
    1:   PRBool wasEmpty = mFrames.IsEmpty();
    1:   if (wasEmpty) {
    1:     // Try to pull over one frame before starting so that we know
    1:     // whether we have an anonymous block or not.
    1:     PRBool complete;
    1:     PullOneFrame(aPresContext, irs, &complete);
    1:   }
    1: 
    1:   if (nsnull == GetPrevInFlow()) {
    1:     // XXX This is pretty sick, but what we do here is to pull-up, in
    1:     // advance, all of the next-in-flows children. We re-resolve their
    1:     // style while we are at at it so that when we reflow they have
    1:     // the right style.
    1:     //
    1:     // All of this is so that text-runs reflow properly.
    1:     irs.mPrevFrame = mFrames.LastChild();
    1:     for (;;) {
    1:       PRBool complete;
    1:       nsIFrame* frame = PullOneFrame(aPresContext, irs, &complete);
    1:       if (!frame) {
    1:         break;
    1:       }
    1:       irs.mPrevFrame = frame;
    1:     }
    1:     irs.mPrevFrame = nsnull;
    1:   }
    1:   else {
    1: // XXX do this in the Init method instead
    1:     // For continuations, we need to check and see if our style
    1:     // context is right. If its the same as the first-in-flow, then
    1:     // we need to fix it up (that way :first-line style doesn't leak
    1:     // into this continuation since we aren't the first line).
    1:     nsFirstLineFrame* first = (nsFirstLineFrame*) GetFirstInFlow();
    1:     if (mStyleContext == first->mStyleContext) {
    1:       // Fixup our style context and our children. First get the
    1:       // proper parent context.
    1:       nsStyleContext* parentContext = first->GetParent()->GetStyleContext();
    1:       if (parentContext) {
    1:         // Create a new style context that is a child of the parent
    1:         // style context thus removing the :first-line style. This way
    1:         // we behave as if an anonymous (unstyled) span was the child
    1:         // of the parent frame.
    1:         nsRefPtr<nsStyleContext> newSC;
    1:         newSC = aPresContext->StyleSet()->
35554:           ResolveAnonymousBoxStyle(nsCSSAnonBoxes::mozLineFrame, parentContext);
    1:         if (newSC) {
    1:           // Switch to the new style context.
    1:           SetStyleContext(newSC);
    1: 
    1:           // Re-resolve all children
40137:           ReparentChildListStyle(aPresContext, mFrames, this);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   NS_ASSERTION(!aReflowState.mLineLayout->GetInFirstLine(),
    1:                "Nested first-line frames? BOGUS");
    1:   aReflowState.mLineLayout->SetInFirstLine(PR_TRUE);
    1:   rv = ReflowFrames(aPresContext, aReflowState, irs, aMetrics, aStatus);
    1:   aReflowState.mLineLayout->SetInFirstLine(PR_FALSE);
    1: 
    1:   // Note: the line layout code will properly compute our overflow state for us
    1: 
    1:   return rv;
    1: }
    1: 
30638: /* virtual */ void
30638: nsFirstLineFrame::PullOverflowsFromPrevInFlow()
30638: {
30638:   nsFirstLineFrame* prevInFlow = static_cast<nsFirstLineFrame*>(GetPrevInFlow());
30638:   if (prevInFlow) {
30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
30638:     if (prevOverflowFrames) {
30638:       // Assume that our prev-in-flow has the same line container that we do.
30781:       const nsFrameList::Slice& newFrames =
30781:         mFrames.InsertFrames(this, nsnull, *prevOverflowFrames);
40137:       ReparentChildListStyle(PresContext(), newFrames, this);
30638:     }
30638:   }
30638: }
30638: 
    1: //////////////////////////////////////////////////////////////////////
    1: 
    1: nsIFrame*
    1: NS_NewPositionedInlineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsPositionedInlineFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsPositionedInlineFrame)
32423: 
    1: void
36647: nsPositionedInlineFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
36647:   mAbsoluteContainer.DestroyFrames(this, aDestructRoot);
36647:   nsInlineFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPositionedInlineFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                              nsFrameList&    aChildList)
    1: {
    1:   nsresult  rv;
    1: 
 4205:   if (nsGkAtoms::absoluteList == aListName) {
    1:     rv = mAbsoluteContainer.SetInitialChildList(this, aListName, aChildList);
    1:   } else {
    1:     rv = nsInlineFrame::SetInitialChildList(aListName, aChildList);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPositionedInlineFrame::AppendFrames(nsIAtom*        aListName,
30941:                                       nsFrameList&    aFrameList)
    1: {
    1:   nsresult  rv;
    1:   
 4205:   if (nsGkAtoms::absoluteList == aListName) {
    1:     rv = mAbsoluteContainer.AppendFrames(this, aListName, aFrameList);
    1:   } else {
    1:     rv = nsInlineFrame::AppendFrames(aListName, aFrameList);
    1:   }
    1: 
    1:   return rv;
    1: }
    1:   
    1: NS_IMETHODIMP
    1: nsPositionedInlineFrame::InsertFrames(nsIAtom*        aListName,
    1:                                       nsIFrame*       aPrevFrame,
30941:                                       nsFrameList&    aFrameList)
    1: {
    1:   nsresult  rv;
    1: 
 4205:   if (nsGkAtoms::absoluteList == aListName) {
    1:     rv = mAbsoluteContainer.InsertFrames(this, aListName, aPrevFrame,
    1:                                          aFrameList);
    1:   } else {
    1:     rv = nsInlineFrame::InsertFrames(aListName, aPrevFrame, aFrameList);
    1:   }
    1: 
    1:   return rv;
    1: }
    1:   
    1: NS_IMETHODIMP
    1: nsPositionedInlineFrame::RemoveFrame(nsIAtom*        aListName,
    1:                                      nsIFrame*       aOldFrame)
    1: {
    1:   nsresult  rv;
    1: 
 4205:   if (nsGkAtoms::absoluteList == aListName) {
32844:     mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
32844:     rv = NS_OK;
    1:   } else {
    1:     rv = nsInlineFrame::RemoveFrame(aListName, aOldFrame);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPositionedInlineFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                           const nsRect&           aDirtyRect,
    1:                                           const nsDisplayListSet& aLists)
    1: {
30783:   aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetChildList(),
30783: 				     aDirtyRect);
    1:   return nsHTMLContainerFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
    1: }
    1: 
    1: nsIAtom*
    1: nsPositionedInlineFrame::GetAdditionalChildListName(PRInt32 aIndex) const
    1: {
    1:   if (0 == aIndex) {
 4205:     return nsGkAtoms::absoluteList;
    1:   }
    1:   return nsnull;
    1: }
    1: 
30783: nsFrameList
30783: nsPositionedInlineFrame::GetChildList(nsIAtom* aListName) const
    1: {
18953:   if (nsGkAtoms::absoluteList == aListName)
30783:     return mAbsoluteContainer.GetChildList();
    1: 
30783:   return nsInlineFrame::GetChildList(aListName);
    1: }
    1: 
    1: nsIAtom*
    1: nsPositionedInlineFrame::GetType() const
    1: {
    1:   return nsGkAtoms::positionedInlineFrame;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPositionedInlineFrame::Reflow(nsPresContext*          aPresContext,
    1:                                 nsHTMLReflowMetrics&     aDesiredSize,
    1:                                 const nsHTMLReflowState& aReflowState,
    1:                                 nsReflowStatus&          aStatus)
    1: {
    1:   nsresult  rv = NS_OK;
    1: 
    1:   // Don't bother optimizing for fast incremental reflow of absolute
    1:   // children of an inline
    1: 
    1:   // Let the inline frame do its reflow first
    1:   rv = nsInlineFrame::Reflow(aPresContext, aDesiredSize, aReflowState, aStatus);
    1: 
    1:   // Let the absolutely positioned container reflow any absolutely positioned
    1:   // child frames that need to be reflowed
    1:   // We want to do this under either of two conditions:
    1:   //  1. If we didn't do the incremental reflow above.
    1:   //  2. If our size changed.
    1:   // Even though it's the padding edge that's the containing block, we
    1:   // can use our rect (the border edge) since if the border style
    1:   // changed, the reflow would have been targeted at us so we'd satisfy
    1:   // condition 1.
    1:   if (NS_SUCCEEDED(rv) &&
    1:       mAbsoluteContainer.HasAbsoluteFrames()) {
    1:     // The containing block for the abs pos kids is formed by our padding edge.
    1:     nsMargin computedBorder =
    1:       aReflowState.mComputedBorderPadding - aReflowState.mComputedPadding;
    1:     nscoord containingBlockWidth =
    1:       aDesiredSize.width - computedBorder.LeftRight();
    1:     nscoord containingBlockHeight =
    1:       aDesiredSize.height - computedBorder.TopBottom();
    1: 
    1:     // Factor the absolutely positioned child bounds into the overflow area
    1:     // Don't include this frame's bounds, nor its inline descendants' bounds,
    1:     // and don't store the overflow property.
    1:     // That will all be done by nsLineLayout::RelativePositionFrames.
 6521:     rv = mAbsoluteContainer.Reflow(this, aPresContext, aReflowState, aStatus,
    1:                                    containingBlockWidth, containingBlockHeight,
 6528:                                    PR_TRUE, PR_TRUE, PR_TRUE, // XXX could be optimized
55022:                                    &aDesiredSize.mOverflowAreas);
    1:   }
    1: 
    1:   return rv;
    1: }
