43113: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
43113: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is mozilla.org code.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2003
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Daniel Witte (dwitte@stanford.edu)
43113:  *   Michiel van Leeuwen (mvl@exedo.nl)
43113:  *   Michael Ventnor <m.ventnor@gmail.com>
43113:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
49142: 
49142: #ifdef MOZ_LOGGING
49142: // this next define has to appear before the include of prlog.h
49142: #define FORCE_PR_LOG // Allow logging in the release build
49142: #endif
49142: 
46770: #ifdef MOZ_IPC
46770: #include "mozilla/net/CookieServiceChild.h"
46770: #include "mozilla/net/NeckoCommon.h"
46770: #endif
46770: 
43113: #include "nsCookieService.h"
43113: #include "nsIServiceManager.h"
43113: 
43113: #include "nsIIOService.h"
43113: #include "nsIPrefBranch.h"
43113: #include "nsIPrefBranch2.h"
43113: #include "nsIPrefService.h"
43113: #include "nsICookiePermission.h"
43113: #include "nsIURI.h"
43113: #include "nsIURL.h"
43113: #include "nsIChannel.h"
43113: #include "nsIFile.h"
43113: #include "nsIObserverService.h"
43113: #include "nsILineInputStream.h"
43113: #include "nsIEffectiveTLDService.h"
43113: #include "nsIIDNService.h"
56094: #include "mozIThirdPartyUtil.h"
43113: 
43113: #include "nsTArray.h"
43113: #include "nsCOMArray.h"
43113: #include "nsIMutableArray.h"
43113: #include "nsArrayEnumerator.h"
43113: #include "nsEnumeratorUtils.h"
43113: #include "nsAutoPtr.h"
43113: #include "nsReadableUtils.h"
43113: #include "nsCRT.h"
43113: #include "prtime.h"
43113: #include "prprf.h"
43113: #include "nsNetUtil.h"
43113: #include "nsNetCID.h"
43113: #include "nsAppDirectoryServiceDefs.h"
43113: #include "nsIPrivateBrowsingService.h"
43113: #include "nsNetCID.h"
43113: #include "mozilla/storage.h"
43113: #include "mozilla/FunctionTimer.h"
43113: 
46770: using namespace mozilla::net;
46770: 
43113: /******************************************************************************
43113:  * nsCookieService impl:
43113:  * useful types & constants
43113:  ******************************************************************************/
43113: 
48744: static nsCookieService *gCookieService;
48744: 
43113: // XXX_hack. See bug 178993.
43113: // This is a hack to hide HttpOnly cookies from older browsers
43113: static const char kHttpOnlyPrefix[] = "#HttpOnly_";
43113: 
57406: #define COOKIES_FILE "cookies.sqlite"
56146: #define COOKIES_SCHEMA_VERSION 4
43113: 
43113: static const PRInt64 kCookieStaleThreshold = 60 * PR_USEC_PER_SEC; // 1 minute in microseconds
57404: static const PRInt64 kCookiePurgeAge =
57404:   PRInt64(30 * 24 * 60 * 60) * PR_USEC_PER_SEC; // 30 days in microseconds
43113: 
43113: static const char kOldCookieFileName[] = "cookies.txt";
43113: 
43113: #undef  LIMIT
43113: #define LIMIT(x, low, high, default) ((x) >= (low) && (x) <= (high) ? (x) : (default))
43113: 
43113: #undef  ADD_TEN_PERCENT
43113: #define ADD_TEN_PERCENT(i) ((i) + (i)/10)
43113: 
43113: // default limits for the cookie list. these can be tuned by the
43113: // network.cookie.maxNumber and network.cookie.maxPerHost prefs respectively.
43113: static const PRUint32 kMaxNumberOfCookies = 3000;
52139: static const PRUint32 kMaxCookiesPerHost  = 150;
43113: static const PRUint32 kMaxBytesPerCookie  = 4096;
43113: static const PRUint32 kMaxBytesPerPath    = 1024;
43113: 
43113: // behavior pref constants
43113: static const PRUint32 BEHAVIOR_ACCEPT        = 0;
43113: static const PRUint32 BEHAVIOR_REJECTFOREIGN = 1;
43113: static const PRUint32 BEHAVIOR_REJECT        = 2;
43113: 
43113: // pref string constants
43113: static const char kPrefCookieBehavior[]     = "network.cookie.cookieBehavior";
43113: static const char kPrefMaxNumberOfCookies[] = "network.cookie.maxNumber";
43113: static const char kPrefMaxCookiesPerHost[]  = "network.cookie.maxPerHost";
43113: static const char kPrefCookiePurgeAge[]     = "network.cookie.purgeAge";
43113: static const char kPrefThirdPartySession[]  = "network.cookie.thirdparty.sessionOnly";
43113: 
57410: static void
57410: bindCookieParameters(mozIStorageBindingParamsArray *aParamsArray,
57410:                      const nsCString &aBaseDomain,
57410:                      const nsCookie *aCookie);
57410: 
43113: // struct for temporarily storing cookie attributes during header parsing
43113: struct nsCookieAttributes
43113: {
43113:   nsCAutoString name;
43113:   nsCAutoString value;
43113:   nsCAutoString host;
43113:   nsCAutoString path;
43113:   nsCAutoString expires;
43113:   nsCAutoString maxage;
43113:   PRInt64 expiryTime;
43113:   PRBool isSession;
43113:   PRBool isSecure;
43113:   PRBool isHttpOnly;
43113: };
43113: 
43113: // stores the nsCookieEntry entryclass and an index into the cookie array
43113: // within that entryclass, for purposes of storing an iteration state that
43113: // points to a certain cookie.
43113: struct nsListIter
43113: {
43113:   // default (non-initializing) constructor.
43113:   nsListIter()
43113:   {
43113:   }
43113: 
43113:   // explicit constructor to a given iterator state with entryclass 'aEntry'
43113:   // and index 'aIndex'.
43113:   explicit
43113:   nsListIter(nsCookieEntry *aEntry, nsCookieEntry::IndexType aIndex)
43113:    : entry(aEntry)
43113:    , index(aIndex)
43113:   {
43113:   }
43113: 
43113:   // get the nsCookie * the iterator currently points to.
43113:   nsCookie * Cookie() const
43113:   {
43113:     return entry->GetCookies()[index];
43113:   }
43113: 
43113:   nsCookieEntry            *entry;
43113:   nsCookieEntry::IndexType  index;
43113: };
43113: 
43113: /******************************************************************************
43113:  * Cookie logging handlers
43113:  * used for logging in nsCookieService
43113:  ******************************************************************************/
43113: 
43113: // logging handlers
43113: #ifdef MOZ_LOGGING
43113: // in order to do logging, the following environment variables need to be set:
43113: //
43113: //    set NSPR_LOG_MODULES=cookie:3 -- shows rejected cookies
43113: //    set NSPR_LOG_MODULES=cookie:4 -- shows accepted and rejected cookies
43113: //    set NSPR_LOG_FILE=cookie.log
43113: //
43113: #include "prlog.h"
43113: #endif
43113: 
43113: // define logging macros for convenience
43113: #define SET_COOKIE PR_TRUE
43113: #define GET_COOKIE PR_FALSE
43113: 
43113: #ifdef PR_LOGGING
43113: static PRLogModuleInfo *sCookieLog = PR_NewLogModule("cookie");
43113: 
43113: #define COOKIE_LOGFAILURE(a, b, c, d)    LogFailure(a, b, c, d)
43113: #define COOKIE_LOGSUCCESS(a, b, c, d, e) LogSuccess(a, b, c, d, e)
43113: 
51398: #define COOKIE_LOGEVICTED(a, details)          \
43113:   PR_BEGIN_MACRO                               \
43113:     if (PR_LOG_TEST(sCookieLog, PR_LOG_DEBUG)) \
51398:       LogEvicted(a, details);                  \
43113:   PR_END_MACRO
43113: 
43113: #define COOKIE_LOGSTRING(lvl, fmt)   \
43113:   PR_BEGIN_MACRO                     \
43113:     PR_LOG(sCookieLog, lvl, fmt);    \
43113:     PR_LOG(sCookieLog, lvl, ("\n")); \
43113:   PR_END_MACRO
43113: 
43113: static void
43113: LogFailure(PRBool aSetCookie, nsIURI *aHostURI, const char *aCookieString, const char *aReason)
43113: {
43113:   // if logging isn't enabled, return now to save cycles
43113:   if (!PR_LOG_TEST(sCookieLog, PR_LOG_WARNING))
43113:     return;
43113: 
43113:   nsCAutoString spec;
43113:   if (aHostURI)
43113:     aHostURI->GetAsciiSpec(spec);
43113: 
43113:   PR_LOG(sCookieLog, PR_LOG_WARNING,
43113:     ("===== %s =====\n", aSetCookie ? "COOKIE NOT ACCEPTED" : "COOKIE NOT SENT"));
43113:   PR_LOG(sCookieLog, PR_LOG_WARNING,("request URL: %s\n", spec.get()));
43113:   if (aSetCookie)
43113:     PR_LOG(sCookieLog, PR_LOG_WARNING,("cookie string: %s\n", aCookieString));
43113: 
43113:   PRExplodedTime explodedTime;
43113:   PR_ExplodeTime(PR_Now(), PR_GMTParameters, &explodedTime);
43113:   char timeString[40];
43113:   PR_FormatTimeUSEnglish(timeString, 40, "%c GMT", &explodedTime);
43113: 
43113:   PR_LOG(sCookieLog, PR_LOG_WARNING,("current time: %s", timeString));
43113:   PR_LOG(sCookieLog, PR_LOG_WARNING,("rejected because %s\n", aReason));
43113:   PR_LOG(sCookieLog, PR_LOG_WARNING,("\n"));
43113: }
43113: 
43113: static void
43113: LogCookie(nsCookie *aCookie)
43113: {
43113:   PRExplodedTime explodedTime;
43113:   PR_ExplodeTime(PR_Now(), PR_GMTParameters, &explodedTime);
43113:   char timeString[40];
43113:   PR_FormatTimeUSEnglish(timeString, 40, "%c GMT", &explodedTime);
43113: 
43113:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("current time: %s", timeString));
43113: 
43113:   if (aCookie) {
43113:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("----------------\n"));
43113:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("name: %s\n", aCookie->Name().get()));
43113:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("value: %s\n", aCookie->Value().get()));
43113:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("%s: %s\n", aCookie->IsDomain() ? "domain" : "host", aCookie->Host().get()));
43113:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("path: %s\n", aCookie->Path().get()));
43113: 
43113:     PR_ExplodeTime(aCookie->Expiry() * PR_USEC_PER_SEC, PR_GMTParameters, &explodedTime);
43113:     PR_FormatTimeUSEnglish(timeString, 40, "%c GMT", &explodedTime);
43113:     PR_LOG(sCookieLog, PR_LOG_DEBUG,
43113:       ("expires: %s%s", timeString, aCookie->IsSession() ? " (at end of session)" : ""));
43113: 
56146:     PR_ExplodeTime(aCookie->CreationTime(), PR_GMTParameters, &explodedTime);
43113:     PR_FormatTimeUSEnglish(timeString, 40, "%c GMT", &explodedTime);
56146:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("created: %s", timeString));
43113: 
43113:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("is secure: %s\n", aCookie->IsSecure() ? "true" : "false"));
43113:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("is httpOnly: %s\n", aCookie->IsHttpOnly() ? "true" : "false"));
43113:   }
43113: }
43113: 
43113: static void
43113: LogSuccess(PRBool aSetCookie, nsIURI *aHostURI, const char *aCookieString, nsCookie *aCookie, PRBool aReplacing)
43113: {
43113:   // if logging isn't enabled, return now to save cycles
43113:   if (!PR_LOG_TEST(sCookieLog, PR_LOG_DEBUG)) {
43113:     return;
43113:   }
43113: 
43113:   nsCAutoString spec;
43113:   if (aHostURI)
43113:     aHostURI->GetAsciiSpec(spec);
43113: 
43113:   PR_LOG(sCookieLog, PR_LOG_DEBUG,
43113:     ("===== %s =====\n", aSetCookie ? "COOKIE ACCEPTED" : "COOKIE SENT"));
43113:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("request URL: %s\n", spec.get()));
43113:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("cookie string: %s\n", aCookieString));
43113:   if (aSetCookie)
43113:     PR_LOG(sCookieLog, PR_LOG_DEBUG,("replaces existing cookie: %s\n", aReplacing ? "true" : "false"));
43113: 
43113:   LogCookie(aCookie);
43113: 
43113:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("\n"));
43113: }
43113: 
43113: static void
51398: LogEvicted(nsCookie *aCookie, const char* details)
43113: {
43113:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("===== COOKIE EVICTED =====\n"));
51398:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("%s\n", details));
43113: 
43113:   LogCookie(aCookie);
43113: 
43113:   PR_LOG(sCookieLog, PR_LOG_DEBUG,("\n"));
43113: }
43113: 
43113: // inline wrappers to make passing in nsAFlatCStrings easier
43113: static inline void
43113: LogFailure(PRBool aSetCookie, nsIURI *aHostURI, const nsAFlatCString &aCookieString, const char *aReason)
43113: {
43113:   LogFailure(aSetCookie, aHostURI, aCookieString.get(), aReason);
43113: }
43113: 
43113: static inline void
43113: LogSuccess(PRBool aSetCookie, nsIURI *aHostURI, const nsAFlatCString &aCookieString, nsCookie *aCookie, PRBool aReplacing)
43113: {
43113:   LogSuccess(aSetCookie, aHostURI, aCookieString.get(), aCookie, aReplacing);
43113: }
43113: 
43113: #else
43113: #define COOKIE_LOGFAILURE(a, b, c, d)    PR_BEGIN_MACRO /* nothing */ PR_END_MACRO
43113: #define COOKIE_LOGSUCCESS(a, b, c, d, e) PR_BEGIN_MACRO /* nothing */ PR_END_MACRO
51782: #define COOKIE_LOGEVICTED(a, b)          PR_BEGIN_MACRO /* nothing */ PR_END_MACRO
43113: #define COOKIE_LOGSTRING(a, b)           PR_BEGIN_MACRO /* nothing */ PR_END_MACRO
43113: #endif
43113: 
43113: #ifdef DEBUG
43113: #define NS_ASSERT_SUCCESS(res)                                               \
43113:   PR_BEGIN_MACRO                                                             \
43113:   nsresult __rv = res; /* Do not evaluate |res| more than once! */           \
43113:   if (NS_FAILED(__rv)) {                                                     \
43113:     char *msg = PR_smprintf("NS_ASSERT_SUCCESS(%s) failed with result 0x%X", \
43113:                             #res, __rv);                                     \
43113:     NS_ASSERTION(NS_SUCCEEDED(__rv), msg);                                   \
43113:     PR_smprintf_free(msg);                                                   \
43113:   }                                                                          \
43113:   PR_END_MACRO
43113: #else
43113: #define NS_ASSERT_SUCCESS(res) PR_BEGIN_MACRO /* nothing */ PR_END_MACRO
43113: #endif
43113: 
43113: /******************************************************************************
48743:  * DBListenerErrorHandler impl:
43113:  * Parent class for our async storage listeners that handles the logging of
43113:  * errors.
43113:  ******************************************************************************/
43113: class DBListenerErrorHandler : public mozIStorageStatementCallback
43113: {
43113: protected:
57405:   DBListenerErrorHandler(DBState* dbState) : mDBState(dbState) { }
57405:   nsRefPtr<DBState> mDBState;
43113:   virtual const char *GetOpType() = 0;
43113: 
43113: public:
43113:   NS_DECL_ISUPPORTS
43113: 
43113:   NS_IMETHOD HandleError(mozIStorageError* aError)
43113:   {
43113:     PRInt32 result = -1;
43113:     aError->GetResult(&result);
57410: 
57410: #ifdef PR_LOGGING
43113:     nsCAutoString message;
43113:     aError->GetMessage(message);
43113:     COOKIE_LOGSTRING(PR_LOG_WARNING,
57410:       ("DBListenerErrorHandler::HandleError(): Error %d occurred while "
57410:        "performing operation '%s' with message '%s'; rebuilding database.",
43113:        result, GetOpType(), message.get()));
43113: #endif
57410: 
57410:     // Rebuild the database.
57410:     gCookieService->HandleCorruptDB(mDBState);
57410: 
43113:     return NS_OK;
43113:   }
43113: };
43933: 
43933: NS_IMPL_ISUPPORTS1(DBListenerErrorHandler, mozIStorageStatementCallback)
43113: 
43113: /******************************************************************************
48743:  * InsertCookieDBListener impl:
48743:  * mozIStorageStatementCallback used to track asynchronous insertion operations.
43113:  ******************************************************************************/
43113: class InsertCookieDBListener : public DBListenerErrorHandler
43113: {
43113: protected:
43113:   virtual const char *GetOpType() { return "INSERT"; }
43113: 
43113: public:
57405:   InsertCookieDBListener(DBState* dbState) : DBListenerErrorHandler(dbState) { }
43113:   NS_IMETHOD HandleResult(mozIStorageResultSet*)
43113:   {
43113:     NS_NOTREACHED("Unexpected call to InsertCookieDBListener::HandleResult");
43113:     return NS_OK;
43113:   }
43113:   NS_IMETHOD HandleCompletion(PRUint16 aReason)
43113:   {
57410:     // If we were rebuilding the db and we succeeded, make our corruptFlag say
57410:     // so.
57410:     if (mDBState->corruptFlag == DBState::REBUILDING &&
57410:         aReason == mozIStorageStatementCallback::REASON_FINISHED) {
57410:       COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:         ("InsertCookieDBListener::HandleCompletion(): rebuild complete"));
57410:       mDBState->corruptFlag = DBState::OK;
57410:     }
43113:     return NS_OK;
43113:   }
43113: };
43113: 
43113: /******************************************************************************
48743:  * UpdateCookieDBListener impl:
48743:  * mozIStorageStatementCallback used to track asynchronous update operations.
43113:  ******************************************************************************/
43113: class UpdateCookieDBListener : public DBListenerErrorHandler
43113: {
43113: protected:
43113:   virtual const char *GetOpType() { return "UPDATE"; }
43113: 
43113: public:
57405:   UpdateCookieDBListener(DBState* dbState) : DBListenerErrorHandler(dbState) { }
43113:   NS_IMETHOD HandleResult(mozIStorageResultSet*)
43113:   {
43113:     NS_NOTREACHED("Unexpected call to UpdateCookieDBListener::HandleResult");
43113:     return NS_OK;
43113:   }
43113:   NS_IMETHOD HandleCompletion(PRUint16 aReason)
43113:   {
43113:     return NS_OK;
43113:   }
43113: };
43113: 
43113: /******************************************************************************
48743:  * RemoveCookieDBListener impl:
48743:  * mozIStorageStatementCallback used to track asynchronous removal operations.
43113:  ******************************************************************************/
43113: class RemoveCookieDBListener :  public DBListenerErrorHandler
43113: {
43113: protected:
43113:   virtual const char *GetOpType() { return "REMOVE"; }
43113: 
43113: public:
57405:   RemoveCookieDBListener(DBState* dbState) : DBListenerErrorHandler(dbState) { }
43113:   NS_IMETHOD HandleResult(mozIStorageResultSet*)
43113:   {
43113:     NS_NOTREACHED("Unexpected call to RemoveCookieDBListener::HandleResult");
43113:     return NS_OK;
43113:   }
43113:   NS_IMETHOD HandleCompletion(PRUint16 aReason)
43113:   {
43113:     return NS_OK;
43113:   }
43113: };
43113: 
43933: /******************************************************************************
48743:  * ReadCookieDBListener impl:
48743:  * mozIStorageStatementCallback used to track asynchronous removal operations.
48743:  ******************************************************************************/
48743: class ReadCookieDBListener :  public DBListenerErrorHandler
48743: {
48743: protected:
48743:   virtual const char *GetOpType() { return "READ"; }
48743:   bool mCanceled;
48743: 
48743: public:
57405:   ReadCookieDBListener(DBState* dbState)
57405:     : DBListenerErrorHandler(dbState)
57405:     , mCanceled(false)
57405:   {
57405:   }
48743: 
48743:   void Cancel() { mCanceled = true; }
48743: 
48743:   NS_IMETHOD HandleResult(mozIStorageResultSet *aResult)
48743:   {
48743:     nsresult rv;
48743:     nsCOMPtr<mozIStorageRow> row;
48743: 
48743:     while (1) {
48743:       rv = aResult->GetNextRow(getter_AddRefs(row));
48743:       NS_ASSERT_SUCCESS(rv);
48743: 
48743:       if (!row)
48743:         break;
48743: 
57405:       CookieDomainTuple *tuple = mDBState->hostArray.AppendElement();
48744:       row->GetUTF8String(9, tuple->baseDomain);
48744:       tuple->cookie = gCookieService->GetCookieFromRow(row);
48743:     }
48743: 
48743:     return NS_OK;
48743:   }
48743:   NS_IMETHOD HandleCompletion(PRUint16 aReason)
48743:   {
48743:     // Process the completion of the read operation. If we have been canceled,
48743:     // we cannot assume that the cookieservice still has an open connection
48743:     // or that it even refers to the same database, so we must return early.
48743:     // Conversely, the cookieservice guarantees that if we have not been
48743:     // canceled, the database connection is still alive and we can safely
48743:     // operate on it.
48743: 
48743:     if (mCanceled) {
48743:       // We may receive a REASON_FINISHED after being canceled;
48743:       // tweak the reason accordingly.
48743:       aReason = mozIStorageStatementCallback::REASON_CANCELED;
48743:     }
48743: 
48743:     switch (aReason) {
48743:     case mozIStorageStatementCallback::REASON_FINISHED:
48744:       gCookieService->AsyncReadComplete();
48743:       break;
48743:     case mozIStorageStatementCallback::REASON_CANCELED:
48743:       // Nothing more to do here. The partially read data has already been
48743:       // thrown away.
48743:       COOKIE_LOGSTRING(PR_LOG_DEBUG, ("Read canceled"));
48743:       break;
48743:     case mozIStorageStatementCallback::REASON_ERROR:
48743:       // Nothing more to do here. DBListenerErrorHandler::HandleError()
57410:       // can handle it.
48743:       COOKIE_LOGSTRING(PR_LOG_DEBUG, ("Read error"));
48743:       break;
48743:     default:
48743:       NS_NOTREACHED("invalid reason");
48743:     }
48743:     return NS_OK;
48743:   }
48743: };
48743: 
48743: /******************************************************************************
43933:  * CloseCookieDBListener imp:
43933:  * Static mozIStorageCompletionCallback used to notify when the database is
43933:  * successfully closed.
43933:  ******************************************************************************/
43933: class CloseCookieDBListener :  public mozIStorageCompletionCallback
43933: {
43933: public:
57405:   CloseCookieDBListener(DBState* dbState) : mDBState(dbState) { }
57405:   nsRefPtr<DBState> mDBState;
43933:   NS_DECL_ISUPPORTS
43933: 
43933:   NS_IMETHOD Complete()
43933:   {
57410:     gCookieService->HandleDBClosed(mDBState);
43933:     return NS_OK;
43933:   }
43933: };
43933: 
43933: NS_IMPL_ISUPPORTS1(CloseCookieDBListener, mozIStorageCompletionCallback)
43113: 
43113: /******************************************************************************
43113:  * nsCookieService impl:
43113:  * singleton instance ctor/dtor methods
43113:  ******************************************************************************/
43113: 
46770: nsICookieService*
46770: nsCookieService::GetXPCOMSingleton()
46770: {
46770: #ifdef MOZ_IPC
46770:   if (IsNeckoChild())
46770:     return CookieServiceChild::GetSingleton();
46770: #endif
46770: 
46770:   return GetSingleton();
46770: }
43113: 
43113: nsCookieService*
43113: nsCookieService::GetSingleton()
43113: {
46770: #ifdef MOZ_IPC
46770:   NS_ASSERTION(!IsNeckoChild(), "not a parent process");
46770: #endif
46770: 
43113:   if (gCookieService) {
43113:     NS_ADDREF(gCookieService);
43113:     return gCookieService;
43113:   }
43113: 
43113:   // Create a new singleton nsCookieService.
43113:   // We AddRef only once since XPCOM has rules about the ordering of module
43113:   // teardowns - by the time our module destructor is called, it's too late to
43113:   // Release our members (e.g. nsIObserverService and nsIPrefBranch), since GC
43113:   // cycles have already been completed and would result in serious leaks.
43113:   // See bug 209571.
43113:   gCookieService = new nsCookieService();
43113:   if (gCookieService) {
43113:     NS_ADDREF(gCookieService);
43113:     if (NS_FAILED(gCookieService->Init())) {
43113:       NS_RELEASE(gCookieService);
43113:     }
43113:   }
43113: 
43113:   return gCookieService;
43113: }
43113: 
43113: /******************************************************************************
43113:  * nsCookieService impl:
43113:  * public methods
43113:  ******************************************************************************/
43113: 
43113: NS_IMPL_ISUPPORTS5(nsCookieService,
43113:                    nsICookieService,
43113:                    nsICookieManager,
43113:                    nsICookieManager2,
43113:                    nsIObserver,
43113:                    nsISupportsWeakReference)
43113: 
43113: nsCookieService::nsCookieService()
57405:  : mDBState(NULL)
43113:  , mCookieBehavior(BEHAVIOR_ACCEPT)
43344:  , mThirdPartySession(PR_FALSE)
43113:  , mMaxNumberOfCookies(kMaxNumberOfCookies)
43113:  , mMaxCookiesPerHost(kMaxCookiesPerHost)
43113:  , mCookiePurgeAge(kCookiePurgeAge)
43113: {
43113: }
43113: 
43113: nsresult
43113: nsCookieService::Init()
43113: {
43113:   NS_TIME_FUNCTION;
43113: 
43113:   nsresult rv;
43113:   mTLDService = do_GetService(NS_EFFECTIVETLDSERVICE_CONTRACTID, &rv);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   mIDNService = do_GetService(NS_IDNSERVICE_CONTRACTID, &rv);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   // init our pref and observer
43113:   nsCOMPtr<nsIPrefBranch2> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
43113:   if (prefBranch) {
43113:     prefBranch->AddObserver(kPrefCookieBehavior,     this, PR_TRUE);
43113:     prefBranch->AddObserver(kPrefMaxNumberOfCookies, this, PR_TRUE);
43113:     prefBranch->AddObserver(kPrefMaxCookiesPerHost,  this, PR_TRUE);
43113:     prefBranch->AddObserver(kPrefCookiePurgeAge,     this, PR_TRUE);
43113:     prefBranch->AddObserver(kPrefThirdPartySession,  this, PR_TRUE);
43113:     PrefChanged(prefBranch);
43113:   }
43113: 
48747:   mStorageService = do_GetService("@mozilla.org/storage/service;1", &rv);
48747:   NS_ENSURE_SUCCESS(rv, rv);
48747: 
57405:   // Init our default, and possibly private DBStates.
57405:   InitDBStates();
43113: 
43113:   mObserverService = mozilla::services::GetObserverService();
57405:   NS_ENSURE_STATE(mObserverService);
43113:   mObserverService->AddObserver(this, "profile-before-change", PR_TRUE);
43113:   mObserverService->AddObserver(this, "profile-do-change", PR_TRUE);
43113:   mObserverService->AddObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC, PR_TRUE);
43113: 
57405:   mPermissionService = do_GetService(NS_COOKIEPERMISSION_CONTRACTID);
57405:   if (!mPermissionService) {
57405:     NS_WARNING("nsICookiePermission implementation not available - some features won't work!");
57405:     COOKIE_LOGSTRING(PR_LOG_WARNING, ("Init(): nsICookiePermission implementation not available"));
57405:   }
57405: 
57405:   return NS_OK;
57405: }
57405: 
57405: void
57405: nsCookieService::InitDBStates()
57405: {
57406:   NS_ASSERTION(!mDBState, "already have a DBState");
57406:   NS_ASSERTION(!mDefaultDBState, "already have a default DBState");
57406:   NS_ASSERTION(!mPrivateDBState, "already have a private DBState");
57406: 
57406:   // Create a new default DBState and set our current one.
57405:   mDefaultDBState = new DBState();
57405:   mDBState = mDefaultDBState;
57405: 
57406:   // If we're in private browsing mode, create a private DBState.
43113:   nsCOMPtr<nsIPrivateBrowsingService> pbs =
43113:     do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
43113:   if (pbs) {
43113:     PRBool inPrivateBrowsing = PR_FALSE;
43113:     pbs->GetPrivateBrowsingEnabled(&inPrivateBrowsing);
43113:     if (inPrivateBrowsing) {
57405:       mPrivateDBState = new DBState();
57405:       mDBState = mPrivateDBState;
43113:     }
43113:   }
57406: 
57406:   // Get our cookie file.
57406:   nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
57406:     getter_AddRefs(mDefaultDBState->cookieFile));
57406:   if (NS_FAILED(rv)) {
57406:     // We've already set up our DBStates appropriately; nothing more to do.
57406:     COOKIE_LOGSTRING(PR_LOG_WARNING,
57406:       ("InitDBStates(): couldn't get cookie file"));
57406:     return;
43113:   }
57406:   mDefaultDBState->cookieFile->AppendNative(NS_LITERAL_CSTRING(COOKIES_FILE));
57406: 
57406:   // Attempt to open and read the database. If TryInitDB() returns RESULT_RETRY,
57406:   // do so.
57406:   OpenDBResult result = TryInitDB(false);
57406:   if (result == RESULT_RETRY) {
57406:     // Database may be corrupt. Synchronously close the connection, clean up the
57406:     // default DBState, and try again.
57406:     COOKIE_LOGSTRING(PR_LOG_WARNING, ("InitDBStates(): retrying TryInitDB()"));
57406: 
57406:     CloseDefaultDBConnection();
57406:     result = TryInitDB(true);
57406:     if (result == RESULT_RETRY) {
57406:       // We're done. Change the code to failure so we clean up below.
57406:       result = RESULT_FAILURE;
57406:     }
57406:   }
57406: 
57406:   if (result == RESULT_FAILURE) {
57406:     COOKIE_LOGSTRING(PR_LOG_WARNING,
57406:       ("InitDBStates(): TryInitDB() failed, closing connection"));
57406: 
57406:     // Connection failure is unrecoverable. Clean up our connection. We can run
57406:     // fine without persistent storage -- e.g. if there's no profile.
57406:     CloseDefaultDBConnection();
57406:   }
57406: }
57406: 
57406: /* Attempt to open and read the database. If 'aRecreateDB' is true, try to
57406:  * move the existing database file out of the way and create a new one.
57406:  *
57406:  * @returns RESULT_OK if opening or creating the database succeeded;
57406:  *          RESULT_RETRY if the database cannot be opened, is corrupt, or some
57406:  *          other failure occurred that might be resolved by recreating the
57406:  *          database; or RESULT_FAILED if there was an unrecoverable error and
57406:  *          we must run without a database.
57406:  *
57406:  * If RESULT_RETRY or RESULT_FAILED is returned, the caller should perform
57406:  * cleanup of the default DBState.
57406:  */
57406: OpenDBResult
57406: nsCookieService::TryInitDB(bool aRecreateDB)
43113: {
57405:   NS_ASSERTION(!mDefaultDBState->dbConn, "nonnull dbConn");
57405:   NS_ASSERTION(!mDefaultDBState->stmtInsert, "nonnull stmtInsert");
57405:   NS_ASSERTION(!mDefaultDBState->insertListener, "nonnull insertListener");
57405:   NS_ASSERTION(!mDefaultDBState->syncConn, "nonnull syncConn");
43113: 
57406:   // Ditch an existing db, if we've been told to (i.e. it's corrupt). We don't
57406:   // want to delete it outright, since it may be useful for debugging purposes,
57406:   // so we move it out of the way.
57406:   nsresult rv;
57406:   if (aRecreateDB) {
57406:     nsCOMPtr<nsIFile> backupFile;
57406:     mDefaultDBState->cookieFile->Clone(getter_AddRefs(backupFile));
57406:     rv = backupFile->MoveToNative(NULL,
57406:       NS_LITERAL_CSTRING(COOKIES_FILE ".bak"));
57406:     NS_ENSURE_SUCCESS(rv, RESULT_FAILURE);
43113:   }
43113: 
43113:   // open a connection to the cookie database, and only cache our connection
56144:   // and statements upon success. The connection is opened unshared to eliminate
56144:   // cache contention between the main and background threads.
57406:   rv = mStorageService->OpenUnsharedDatabase(mDefaultDBState->cookieFile,
57405:     getter_AddRefs(mDefaultDBState->dbConn));
57406:   NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113: 
57405:   // Set up our listeners.
57405:   mDefaultDBState->insertListener = new InsertCookieDBListener(mDefaultDBState);
57405:   mDefaultDBState->updateListener = new UpdateCookieDBListener(mDefaultDBState);
57405:   mDefaultDBState->removeListener = new RemoveCookieDBListener(mDefaultDBState);
57405:   mDefaultDBState->closeListener = new CloseCookieDBListener(mDefaultDBState);
57405: 
51868:   // Grow cookie db in 512KB increments
57405:   mDefaultDBState->dbConn->SetGrowthIncrement(512 * 1024, EmptyCString());
51868: 
43113:   PRBool tableExists = PR_FALSE;
57405:   mDefaultDBState->dbConn->TableExists(NS_LITERAL_CSTRING("moz_cookies"),
57405:     &tableExists);
43113:   if (!tableExists) {
43113:     rv = CreateTable();
57406:     NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113: 
43113:   } else {
43113:     // table already exists; check the schema version before reading
43113:     PRInt32 dbSchemaVersion;
57405:     rv = mDefaultDBState->dbConn->GetSchemaVersion(&dbSchemaVersion);
57406:     NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113: 
56146:     // Start a transaction for the whole migration block.
57405:     mozStorageTransaction transaction(mDefaultDBState->dbConn, PR_TRUE);
56146: 
43113:     switch (dbSchemaVersion) {
57406:     // Upgrading.
57406:     // Every time you increment the database schema, you need to implement
57406:     // the upgrading code from the previous version to the new one. If migration
57406:     // fails for any reason, it's a bug -- so we return RESULT_RETRY such that
57406:     // the original database will be saved, in the hopes that we might one day
57406:     // see it and fix it.
43113:     case 1:
43113:       {
48370:         // Add the lastAccessed column to the table.
57405:         rv = mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
43113:           "ALTER TABLE moz_cookies ADD lastAccessed INTEGER"));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
48370:       }
48370:       // Fall through to the next upgrade.
48370: 
48370:     case 2:
48370:       {
48370:         // Add the baseDomain column and index to the table.
57405:         rv = mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
48370:           "ALTER TABLE moz_cookies ADD baseDomain TEXT"));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
48370: 
48370:         // Compute the baseDomains for the table. This must be done eagerly
48370:         // otherwise we won't be able to synchronously read in individual
48370:         // domains on demand.
48370:         nsCOMPtr<mozIStorageStatement> select;
57405:         rv = mDefaultDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
48370:           "SELECT id, host FROM moz_cookies"), getter_AddRefs(select));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
48370: 
48370:         nsCOMPtr<mozIStorageStatement> update;
57405:         rv = mDefaultDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
56146:           "UPDATE moz_cookies SET baseDomain = :baseDomain WHERE id = :id"),
48370:           getter_AddRefs(update));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
48370: 
48370:         nsCString baseDomain, host;
48370:         PRBool hasResult;
48370:         while (1) {
48370:           rv = select->ExecuteStep(&hasResult);
57406:           NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
48370: 
48370:           if (!hasResult)
48370:             break;
48370: 
48370:           PRInt64 id = select->AsInt64(0);
48370:           select->GetUTF8String(1, host);
48370: 
48370:           rv = GetBaseDomainFromHost(host, baseDomain);
57406:           NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
48370: 
48370:           mozStorageStatementScoper scoper(update);
48370: 
56146:           rv = update->BindUTF8StringByName(NS_LITERAL_CSTRING("baseDomain"),
56146:                                             baseDomain);
48370:           NS_ASSERT_SUCCESS(rv);
56146:           rv = update->BindInt64ByName(NS_LITERAL_CSTRING("id"),
56146:                                        id);
48370:           NS_ASSERT_SUCCESS(rv);
48370: 
48370:           rv = update->ExecuteStep(&hasResult);
57406:           NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
48370:         }
48370: 
48370:         // Create an index on baseDomain.
57405:         rv = mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
48370:           "CREATE INDEX moz_basedomain ON moz_cookies (baseDomain)"));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56146:       }
56146:       // Fall through to the next upgrade.
56146: 
56146:     case 3:
56146:       {
56148:         // Add the creationTime column to the table, and create a unique index
56148:         // on (name, host, path). Before we do this, we have to purge the table
56148:         // of expired cookies such that we know that the (name, host, path)
56148:         // index is truly unique -- otherwise we can't create the index. Note
56148:         // that we can't just execute a statement to delete all rows where the
56148:         // expiry column is in the past -- doing so would rely on the clock
56148:         // (both now and when previous cookies were set) being monotonic.
56148: 
56148:         // Select the whole table, and order by the fields we're interested in.
56148:         // This means we can simply do a linear traversal of the results and
56148:         // check for duplicates as we go.
56148:         nsCOMPtr<mozIStorageStatement> select;
57405:         rv = mDefaultDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
56148:           "SELECT id, name, host, path FROM moz_cookies "
56148:             "ORDER BY name ASC, host ASC, path ASC, expiry ASC"),
56148:           getter_AddRefs(select));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56148: 
56148:         nsCOMPtr<mozIStorageStatement> deleteExpired;
57405:         rv = mDefaultDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
56148:           "DELETE FROM moz_cookies WHERE id = :id"),
56148:           getter_AddRefs(deleteExpired));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56148: 
56148:         // Read the first row.
56148:         PRBool hasResult;
56148:         rv = select->ExecuteStep(&hasResult);
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56148: 
56148:         if (hasResult) {
56148:           nsCString name1, host1, path1;
56148:           PRInt64 id1 = select->AsInt64(0);
56148:           select->GetUTF8String(1, name1);
56148:           select->GetUTF8String(2, host1);
56148:           select->GetUTF8String(3, path1);
56148: 
56148:           nsCString name2, host2, path2;
56148:           while (1) {
56148:             // Read the second row.
56148:             rv = select->ExecuteStep(&hasResult);
57406:             NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56148: 
56148:             if (!hasResult)
56148:               break;
56148: 
56148:             PRInt64 id2 = select->AsInt64(0);
56148:             select->GetUTF8String(1, name2);
56148:             select->GetUTF8String(2, host2);
56148:             select->GetUTF8String(3, path2);
56148: 
56148:             // If the two rows match in (name, host, path), we know the earlier
56148:             // row has an earlier expiry time. Delete it.
56148:             if (name1 == name2 && host1 == host2 && path1 == path2) {
56148:               mozStorageStatementScoper scoper(deleteExpired);
56148: 
57405:               rv = deleteExpired->BindInt64ByName(NS_LITERAL_CSTRING("id"),
57405:                 id1);
56148:               NS_ASSERT_SUCCESS(rv);
56148: 
56148:               rv = deleteExpired->ExecuteStep(&hasResult);
57406:               NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56148:             }
56148: 
56148:             // Make the second row the first for the next iteration.
56148:             name1 = name2;
56148:             host1 = host2;
56148:             path1 = path2;
56148:             id1 = id2;
56148:           }
56148:         }
56148: 
56146:         // Add the creationTime column to the table.
57405:         rv = mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
56146:           "ALTER TABLE moz_cookies ADD creationTime INTEGER"));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56146: 
56148:         // Copy the id of each row into the new creationTime column.
57405:         rv = mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
56148:           "UPDATE moz_cookies SET creationTime = "
56148:             "(SELECT id WHERE id = moz_cookies.id)"));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56146: 
56146:         // Create a unique index on (name, host, path) to allow fast lookup.
57405:         rv = mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
56146:           "CREATE UNIQUE INDEX moz_uniqueid "
56146:           "ON moz_cookies (name, host, path)"));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113:       }
48370:       // Fall through to the next upgrade.
43113: 
56146:       // No more upgrades. Update the schema version.
57405:       rv = mDefaultDBState->dbConn->SetSchemaVersion(COOKIES_SCHEMA_VERSION);
57406:       NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56146: 
43113:     case COOKIES_SCHEMA_VERSION:
43113:       break;
43113: 
43113:     case 0:
43113:       {
43113:         NS_WARNING("couldn't get schema version!");
43113:           
43113:         // the table may be usable; someone might've just clobbered the schema
43113:         // version. we can treat this case like a downgrade using the codepath
43113:         // below, by verifying the columns we care about are all there. for now,
43113:         // re-set the schema version in the db, in case the checks succeed (if
43113:         // they don't, we're dropping the table anyway).
57405:         rv = mDefaultDBState->dbConn->SetSchemaVersion(COOKIES_SCHEMA_VERSION);
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113:       }
43113:       // fall through to downgrade check
43113: 
43113:     // downgrading.
43113:     // if columns have been added to the table, we can still use the ones we
43113:     // understand safely. if columns have been deleted or altered, just
43113:     // blow away the table and start from scratch! if you change the way
43113:     // a column is interpreted, make sure you also change its name so this
43113:     // check will catch it.
43113:     default:
43113:       {
43113:         // check if all the expected columns exist
43113:         nsCOMPtr<mozIStorageStatement> stmt;
57405:         rv = mDefaultDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
43113:           "SELECT "
43113:             "id, "
48370:             "baseDomain, "
43113:             "name, "
43113:             "value, "
43113:             "host, "
43113:             "path, "
43113:             "expiry, "
48748:             "lastAccessed, "
56146:             "creationTime, "
43113:             "isSecure, "
43113:             "isHttpOnly "
43113:           "FROM moz_cookies"), getter_AddRefs(stmt));
43113:         if (NS_SUCCEEDED(rv))
43113:           break;
43113: 
43113:         // our columns aren't there - drop the table!
57405:         rv = mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
57405:           "DROP TABLE moz_cookies"));
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113: 
43113:         rv = CreateTable();
57406:         NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113:       }
43113:       break;
43113:     }
43113:   }
43113: 
43113:   // make operations on the table asynchronous, for performance
57405:   mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
57405:     "PRAGMA synchronous = OFF"));
43113: 
56708:   // Use write-ahead-logging for performance. We cap the autocheckpoint limit at
56708:   // 16 pages (around 500KB).
57405:   mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
57405:     "PRAGMA journal_mode = WAL"));
57405:   mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
56708:     "PRAGMA wal_autocheckpoint = 16"));
56153: 
43113:   // cache frequently used statements (for insertion, deletion, and updating)
57405:   rv = mDefaultDBState->dbConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
43113:     "INSERT INTO moz_cookies ("
48370:       "baseDomain, "
43113:       "name, "
43113:       "value, "
43113:       "host, "
43113:       "path, "
43113:       "expiry, "
43113:       "lastAccessed, "
56146:       "creationTime, "
43113:       "isSecure, "
43113:       "isHttpOnly"
56146:     ") VALUES ("
56146:       ":baseDomain, "
56146:       ":name, "
56146:       ":value, "
56146:       ":host, "
56146:       ":path, "
56146:       ":expiry, "
56146:       ":lastAccessed, "
56146:       ":creationTime, "
56146:       ":isSecure, "
56146:       ":isHttpOnly"
56146:     ")"),
57405:     getter_AddRefs(mDefaultDBState->stmtInsert));
57406:   NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113: 
57405:   rv = mDefaultDBState->dbConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
56146:     "DELETE FROM moz_cookies "
56146:     "WHERE name = :name AND host = :host AND path = :path"),
57405:     getter_AddRefs(mDefaultDBState->stmtDelete));
57406:   NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113: 
57405:   rv = mDefaultDBState->dbConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
56146:     "UPDATE moz_cookies SET lastAccessed = :lastAccessed "
56146:     "WHERE name = :name AND host = :host AND path = :path"),
57405:     getter_AddRefs(mDefaultDBState->stmtUpdate));
57406:   NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113: 
43113:   // if we deleted a corrupt db, don't attempt to import - return now
57406:   if (aRecreateDB)
57406:     return RESULT_OK;
43113: 
43113:   // check whether to import or just read in the db
43113:   if (tableExists)
43113:     return Read();
43113: 
43113:   nsCOMPtr<nsIFile> oldCookieFile;
57405:   rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
57405:     getter_AddRefs(oldCookieFile));
57406:   if (NS_FAILED(rv)) return RESULT_OK;
57406: 
57406:   // Import cookies, and clean up the old file regardless of success or failure.
57406:   // Note that we have to switch out our DBState temporarily, in case we're in
57406:   // private browsing mode; otherwise ImportCookies() won't be happy.
57406:   DBState* initialState = mDBState;
57406:   mDBState = mDefaultDBState;
43113:   oldCookieFile->AppendNative(NS_LITERAL_CSTRING(kOldCookieFileName));
57406:   ImportCookies(oldCookieFile);
43113:   oldCookieFile->Remove(PR_FALSE);
57406:   mDBState = initialState;
57406: 
57406:   return RESULT_OK;
43113: }
43113: 
48370: // Sets the schema version and creates the moz_cookies table.
43113: nsresult
43113: nsCookieService::CreateTable()
43113: {
48370:   // Set the schema version, before creating the table.
57405:   nsresult rv = mDefaultDBState->dbConn->SetSchemaVersion(
57405:     COOKIES_SCHEMA_VERSION);
43113:   if (NS_FAILED(rv)) return rv;
43113: 
48370:   // Create the table.
57405:   rv = mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
43113:     "CREATE TABLE moz_cookies ("
43113:       "id INTEGER PRIMARY KEY, "
48370:       "baseDomain TEXT, "
43113:       "name TEXT, "
43113:       "value TEXT, "
43113:       "host TEXT, "
43113:       "path TEXT, "
43113:       "expiry INTEGER, "
43113:       "lastAccessed INTEGER, "
56146:       "creationTime INTEGER, "
43113:       "isSecure INTEGER, "
56146:       "isHttpOnly INTEGER, "
56146:       "CONSTRAINT moz_uniqueid UNIQUE (name, host, path)"
43113:     ")"));
48370:   if (NS_FAILED(rv)) return rv;
48370: 
48370:   // Create an index on baseDomain.
57405:   return mDefaultDBState->dbConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
48370:     "CREATE INDEX moz_basedomain ON moz_cookies (baseDomain)"));
43113: }
43113: 
43113: void
57405: nsCookieService::CloseDBStates()
43113: {
57405:   // Null out our private and pointer DBStates regardless.
57405:   mPrivateDBState = NULL;
57405:   mDBState = NULL;
57405: 
57405:   // If we don't have a default DBState, we're done.
57405:   if (!mDefaultDBState)
57405:     return;
57405: 
57405:   if (mDefaultDBState->dbConn) {
48743:     // Cancel any pending read. No further results will be received by our
48743:     // read listener.
57405:     if (mDefaultDBState->pendingRead) {
48744:       CancelAsyncRead(PR_TRUE);
48747:     }
48743: 
57405:     // Asynchronously close the connection. We will null it below.
57405:     mDefaultDBState->dbConn->AsyncClose(mDefaultDBState->closeListener);
43113:   }
57405: 
57405:   CloseDefaultDBConnection();
57405: 
57405:   mDefaultDBState = NULL;
57405: }
57405: 
57405: // Close the default connection by nulling out statements, listeners, and the
57405: // connection itself. This will not cancel a pending read or asynchronously
57405: // close the connection -- these must be done beforehand if necessary.
57405: void
57405: nsCookieService::CloseDefaultDBConnection()
57405: {
57405:   // Destroy our statements before we close the db.
57405:   mDefaultDBState->stmtInsert = NULL;
57405:   mDefaultDBState->stmtDelete = NULL;
57405:   mDefaultDBState->stmtUpdate = NULL;
57405: 
57407:   // Null out the database connections. If 'dbConn' has not been used for any
57407:   // asynchronous operations yet, this will synchronously close it; otherwise,
57407:   // it's expected that the caller has performed an AsyncClose prior.
57405:   mDefaultDBState->dbConn = NULL;
57407:   mDefaultDBState->syncConn = NULL;
57405: 
57405:   // Manually null out our listeners. This is necessary because they hold a
57410:   // strong ref to the DBState itself. They'll stay alive until whatever
57410:   // statements are still executing complete.
57405:   mDefaultDBState->readListener = NULL;
57405:   mDefaultDBState->insertListener = NULL;
57405:   mDefaultDBState->updateListener = NULL;
57405:   mDefaultDBState->removeListener = NULL;
57405:   mDefaultDBState->closeListener = NULL;
43113: }
43113: 
57410: void
57410: nsCookieService::HandleDBClosed(DBState* aDBState)
57410: {
57410:   COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:     ("HandleDBClosed(): DBState %x closed", aDBState));
57410: 
57410:   switch (aDBState->corruptFlag) {
57410:   case DBState::OK: {
57410:     // Database is healthy. Notify of closure.
57410:     mObserverService->NotifyObservers(nsnull, "cookie-db-closed", nsnull);
57410:     break;
57410:   }
57410:   case DBState::CLOSING_FOR_REBUILD: {
57410:     // Our close finished. Start the rebuild, and notify of db closure later.
57410:     RebuildCorruptDB(aDBState);
57410:     break;
57410:   }
57410:   case DBState::REBUILDING: {
57410:     // We encountered an error during rebuild, closed the database, and now
57410:     // here we are. We already have a 'cookies.sqlite.bak' from the original
57410:     // dead database; we don't want to overwrite it, so let's move this one to
57410:     // 'cookies.sqlite.bak-rebuild'.
57410:     nsCOMPtr<nsIFile> backupFile;
57410:     aDBState->cookieFile->Clone(getter_AddRefs(backupFile));
57410:     nsresult rv = backupFile->MoveToNative(NULL,
57410:       NS_LITERAL_CSTRING(COOKIES_FILE ".bak-rebuild"));
57410: 
57410:     COOKIE_LOGSTRING(PR_LOG_WARNING,
57410:       ("HandleDBClosed(): DBState %x encountered error rebuilding db; move to "
57410:        "'cookies.sqlite.bak-rebuild' gave rv 0x%x", aDBState, rv));
57410:     mObserverService->NotifyObservers(nsnull, "cookie-db-closed", nsnull);
57410:     break;
57410:   }
57410:   }
57410: }
57410: 
57410: void
57410: nsCookieService::HandleCorruptDB(DBState* aDBState)
57410: {
57410:   if (mDefaultDBState != aDBState) {
57410:     // We've either closed the state or we've switched profiles. It's getting
57410:     // a bit late to rebuild -- bail instead.
57410:     COOKIE_LOGSTRING(PR_LOG_WARNING,
57410:       ("HandleCorruptDB(): DBState %x is already closed, aborting", aDBState));
57410:     return;
57410:   }
57410: 
57410:   COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:     ("HandleCorruptDB(): DBState %x has corruptFlag %u", aDBState,
57410:       aDBState->corruptFlag));
57410: 
57410:   // Mark the database corrupt, so the close listener can begin reconstructing
57410:   // it.
57410:   switch (mDefaultDBState->corruptFlag) {
57410:   case DBState::OK: {
57410:     // Move to 'closing' state.
57410:     mDefaultDBState->corruptFlag = DBState::CLOSING_FOR_REBUILD;
57410: 
57410:     // Cancel any pending read and close the database. If we do have an
57410:     // in-flight read we want to throw away all the results so far -- we have no
57410:     // idea how consistent the database is. Note that we may have already
57410:     // canceled the read but not emptied our readSet; do so now.
57410:     mDefaultDBState->readSet.Clear();
57410:     if (mDefaultDBState->pendingRead) {
57410:       CancelAsyncRead(PR_TRUE);
57410:       mDefaultDBState->syncConn = nsnull;
57410:     }
57410: 
57410:     mDefaultDBState->dbConn->AsyncClose(mDefaultDBState->closeListener);
57410:     CloseDefaultDBConnection();
57410:     break;
57410:   }
57410:   case DBState::CLOSING_FOR_REBUILD: {
57410:     // We had an error while waiting for close completion. That's OK, just
57410:     // ignore it -- we're rebuilding anyway.
57410:     return;
57410:   }
57410:   case DBState::REBUILDING: {
57410:     // We had an error while rebuilding the DB. Game over. Close the database
57410:     // and let the close handler do nothing; then we'll move it out of the way.
64102:     if (mDefaultDBState->dbConn) {
57410:       mDefaultDBState->dbConn->AsyncClose(mDefaultDBState->closeListener);
64102:     }
57410:     CloseDefaultDBConnection();
57410:     break;
57410:   }
57410:   }
57410: }
57410: 
57410: static PLDHashOperator
57410: RebuildDBCallback(nsCookieEntry *aEntry,
57410:                   void          *aArg)
57410: {
57410:   mozIStorageBindingParamsArray* paramsArray =
57410:     static_cast<mozIStorageBindingParamsArray*>(aArg);
57410: 
57410:   const nsCookieEntry::ArrayType &cookies = aEntry->GetCookies();
57410:   for (nsCookieEntry::IndexType i = 0; i < cookies.Length(); ++i) {
57410:     nsCookie* cookie = cookies[i];
57410: 
57410:     if (!cookie->IsSession()) {
57410:       bindCookieParameters(paramsArray, aEntry->GetKey(), cookie);
57410:     }
57410:   }
57410: 
57410:   return PL_DHASH_NEXT;
57410: }
57410: 
57410: void
57410: nsCookieService::RebuildCorruptDB(DBState* aDBState)
57410: {
57410:   NS_ASSERTION(!aDBState->dbConn, "shouldn't have an open db connection");
57410:   NS_ASSERTION(aDBState->corruptFlag == DBState::CLOSING_FOR_REBUILD,
57410:     "should be in CLOSING_FOR_REBUILD state");
57410: 
57410:   aDBState->corruptFlag = DBState::REBUILDING;
57410: 
57410:   if (mDefaultDBState != aDBState) {
57410:     // We've either closed the state or we've switched profiles. It's getting
57410:     // a bit late to rebuild -- bail instead. In any case, we were waiting
57410:     // on rebuild completion to notify of the db closure, which won't happen --
57410:     // do so now.
57410:     COOKIE_LOGSTRING(PR_LOG_WARNING,
57410:       ("RebuildCorruptDB(): DBState %x is stale, aborting", aDBState));
57410:     mObserverService->NotifyObservers(nsnull, "cookie-db-closed", nsnull);
57410:     return;
57410:   }
57410: 
57410:   COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:     ("RebuildCorruptDB(): creating new database"));
57410: 
57410:   // The database has been closed, and we're ready to rebuild. Open a
57410:   // connection.
57410:   OpenDBResult result = TryInitDB(true);
57410:   if (result != RESULT_OK) {
57410:     // We're done. Reset our DB connection and statements, and notify of
57410:     // closure.
57410:     COOKIE_LOGSTRING(PR_LOG_WARNING,
57410:       ("RebuildCorruptDB(): TryInitDB() failed with result %u", result));
57410:     CloseDefaultDBConnection();
57410:     mDefaultDBState->corruptFlag = DBState::OK;
57410:     mObserverService->NotifyObservers(nsnull, "cookie-db-closed", nsnull);
57410:     return;
57410:   }
57410: 
57410:   // Notify observers that we're beginning the rebuild.
57410:   mObserverService->NotifyObservers(nsnull, "cookie-db-rebuilding", nsnull);
57410: 
57410:   // Enumerate the hash, and add cookies to the params array.
57410:   mozIStorageAsyncStatement* stmt = aDBState->stmtInsert;
57410:   nsCOMPtr<mozIStorageBindingParamsArray> paramsArray;
57410:   stmt->NewBindingParamsArray(getter_AddRefs(paramsArray));
57410:   aDBState->hostTable.EnumerateEntries(RebuildDBCallback, paramsArray.get());
57410: 
57410:   // Make sure we've got something to write. If we don't, we're done.
57410:   PRUint32 length;
57410:   paramsArray->GetLength(&length);
57410:   if (length == 0) {
57410:     COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:       ("RebuildCorruptDB(): nothing to write, rebuild complete"));
57410:     mDefaultDBState->corruptFlag = DBState::OK;
57410:     return;
57410:   }
57410: 
57410:   // Execute the statement. If any errors crop up, we won't try again.
57410:   nsresult rv = stmt->BindParameters(paramsArray);
57410:   NS_ASSERT_SUCCESS(rv);
57410:   nsCOMPtr<mozIStoragePendingStatement> handle;
57410:   rv = stmt->ExecuteAsync(aDBState->insertListener, getter_AddRefs(handle));
57410:   NS_ASSERT_SUCCESS(rv);    
57410: }
57410: 
43113: nsCookieService::~nsCookieService()
43113: {
57405:   CloseDBStates();
43113: 
43113:   gCookieService = nsnull;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsCookieService::Observe(nsISupports     *aSubject,
43113:                          const char      *aTopic,
43113:                          const PRUnichar *aData)
43113: {
43113:   // check the topic
43113:   if (!strcmp(aTopic, "profile-before-change")) {
43113:     // The profile is about to change,
43113:     // or is going away because the application is shutting down.
57405:     if (mDBState && mDBState->dbConn &&
57405:         !nsCRT::strcmp(aData, NS_LITERAL_STRING("shutdown-cleanse").get())) {
57405:       // Clear the cookie db if we're in the default DBState.
48746:       RemoveAll();
43113:     }
43113: 
57405:     // Close the default DB connection and null out our DBStates before
57405:     // changing.
57405:     CloseDBStates();
43113: 
43113:   } else if (!strcmp(aTopic, "profile-do-change")) {
57405:     NS_ASSERTION(!mDefaultDBState, "shouldn't have a default DBState");
57405:     NS_ASSERTION(!mPrivateDBState, "shouldn't have a private DBState");
57405: 
43113:     // the profile has already changed; init the db from the new location.
43113:     // if we are in the private browsing state, however, we do not want to read
43113:     // data into it - we should instead put it into the default state, so it's
43113:     // ready for us if and when we switch back to it.
57405:     InitDBStates();
43113: 
43113:   } else if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
43113:     nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(aSubject);
43113:     if (prefBranch)
43113:       PrefChanged(prefBranch);
43113: 
43113:   } else if (!strcmp(aTopic, NS_PRIVATE_BROWSING_SWITCH_TOPIC)) {
43113:     if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_ENTER).Equals(aData)) {
57405:       NS_ASSERTION(mDefaultDBState, "don't have a default state");
57405:       NS_ASSERTION(mDBState == mDefaultDBState, "not in default state");
57405:       NS_ASSERTION(!mPrivateDBState, "already have a private state");
57405: 
57405:       // Create a new DBState, and swap it in.
57405:       mPrivateDBState = new DBState();
57405:       mDBState = mPrivateDBState;
57405: 
57405:     } else if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_LEAVE).Equals(aData)) {
57405:       NS_ASSERTION(mDefaultDBState, "don't have a default state");
57405:       NS_ASSERTION(mDBState == mPrivateDBState, "not in private state");
57405:       NS_ASSERTION(!mPrivateDBState->dbConn, "private DB connection not null");
57405: 
57405:       // Clear the private DBState, and restore the default one.
57405:       mPrivateDBState = NULL;
57405:       mDBState = mDefaultDBState;
57405:     }
43113: 
43113:     NotifyChanged(nsnull, NS_LITERAL_STRING("reload").get());
43113:   }
43113: 
43113:   return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsCookieService::GetCookieString(nsIURI     *aHostURI,
43113:                                  nsIChannel *aChannel,
43113:                                  char       **aCookie)
43113: {
54196:   return GetCookieStringCommon(aHostURI, aChannel, false, aCookie);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsCookieService::GetCookieStringFromHttp(nsIURI     *aHostURI,
43113:                                          nsIURI     *aFirstURI,
43113:                                          nsIChannel *aChannel,
43113:                                          char       **aCookie)
43113: {
54196:   return GetCookieStringCommon(aHostURI, aChannel, true, aCookie);
54196: }
54196: 
54196: nsresult
54196: nsCookieService::GetCookieStringCommon(nsIURI *aHostURI,
54196:                                        nsIChannel *aChannel,
54196:                                        bool aHttpBound,
54196:                                        char** aCookie)
54196: {
46770:   NS_ENSURE_ARG(aHostURI);
46770:   NS_ENSURE_ARG(aCookie);
46770: 
56094:   // Determine whether the request is foreign. Failure is acceptable.
56094:   PRBool isForeign = true;
56094:   if (RequireThirdPartyCheck())
56094:     mThirdPartyUtil->IsThirdPartyChannel(aChannel, aHostURI, &isForeign);
46770: 
46770:   nsCAutoString result;
56094:   GetCookieStringInternal(aHostURI, isForeign, aHttpBound, result);
46770:   *aCookie = result.IsEmpty() ? nsnull : ToNewCString(result);
43113:   return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsCookieService::SetCookieString(nsIURI     *aHostURI,
43113:                                  nsIPrompt  *aPrompt,
43113:                                  const char *aCookieHeader,
43113:                                  nsIChannel *aChannel)
43113: {
54196:   return SetCookieStringCommon(aHostURI, aCookieHeader, NULL, aChannel, false);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsCookieService::SetCookieStringFromHttp(nsIURI     *aHostURI,
43113:                                          nsIURI     *aFirstURI,
43113:                                          nsIPrompt  *aPrompt,
43113:                                          const char *aCookieHeader,
43113:                                          const char *aServerTime,
43113:                                          nsIChannel *aChannel) 
43113: {
54196:   return SetCookieStringCommon(aHostURI, aCookieHeader, aServerTime, aChannel,
54196:                                true);
54196: }
54196: 
54196: nsresult
54196: nsCookieService::SetCookieStringCommon(nsIURI *aHostURI,
54196:                                        const char *aCookieHeader,
54196:                                        const char *aServerTime,
54196:                                        nsIChannel *aChannel,
54196:                                        bool aFromHttp) 
54196: {
46770:   NS_ENSURE_ARG(aHostURI);
46770:   NS_ENSURE_ARG(aCookieHeader);
46770: 
56094:   // Determine whether the request is foreign. Failure is acceptable.
56094:   PRBool isForeign = true;
56094:   if (RequireThirdPartyCheck())
56094:     mThirdPartyUtil->IsThirdPartyChannel(aChannel, aHostURI, &isForeign);
46770: 
46770:   nsDependentCString cookieString(aCookieHeader);
46770:   nsDependentCString serverTime(aServerTime ? aServerTime : "");
56094:   SetCookieStringInternal(aHostURI, isForeign, cookieString,
54196:                           serverTime, aFromHttp);
46770:   return NS_OK;
43113: }
43113: 
46770: void
43113: nsCookieService::SetCookieStringInternal(nsIURI          *aHostURI,
56094:                                          bool             aIsForeign,
46770:                                          const nsCString &aCookieHeader,
46770:                                          const nsCString &aServerTime,
43113:                                          PRBool           aFromHttp) 
43113: {
54196:   NS_ASSERTION(aHostURI, "null host!");
54196: 
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return;
58006:   }
58006: 
43113:   // get the base domain for the host URI.
43113:   // e.g. for "www.bbc.co.uk", this would be "bbc.co.uk".
43113:   // file:// URI's (i.e. with an empty host) are allowed, but any other
43113:   // scheme must have a non-empty host. A trailing dot in the host
59617:   // is acceptable.
43113:   PRBool requireHostMatch;
43113:   nsCAutoString baseDomain;
43113:   nsresult rv = GetBaseDomain(aHostURI, baseDomain, requireHostMatch);
43113:   if (NS_FAILED(rv)) {
43113:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader, 
43113:                       "couldn't get base domain from URI");
46770:     return;
43113:   }
43113: 
43113:   // check default prefs
56094:   CookieStatus cookieStatus = CheckPrefs(aHostURI, aIsForeign, baseDomain,
46770:                                          requireHostMatch, aCookieHeader.get());
43113:   // fire a notification if cookie was rejected (but not if there was an error)
43113:   switch (cookieStatus) {
43113:   case STATUS_REJECTED:
43113:     NotifyRejected(aHostURI);
63789:     return;
43113:   case STATUS_REJECTED_WITH_ERROR:
46770:     return;
43113:   default:
43113:     break;
43113:   }
43113: 
43113:   // parse server local time. this is not just done here for efficiency
43113:   // reasons - if there's an error parsing it, and we need to default it
43113:   // to the current time, we must do it here since the current time in
43113:   // SetCookieInternal() will change for each cookie processed (e.g. if the
43113:   // user is prompted).
43113:   PRTime tempServerTime;
43113:   PRInt64 serverTime;
46770:   PRStatus result = PR_ParseTimeString(aServerTime.get(), PR_TRUE,
46770:                                        &tempServerTime);
46770:   if (result == PR_SUCCESS) {
43113:     serverTime = tempServerTime / PR_USEC_PER_SEC;
43113:   } else {
43113:     serverTime = PR_Now() / PR_USEC_PER_SEC;
43113:   }
43113: 
46770:   // process each cookie in the header
43113:   nsDependentCString cookieHeader(aCookieHeader);
46770:   while (SetCookieInternal(aHostURI, baseDomain, requireHostMatch,
43113:                            cookieStatus, cookieHeader, serverTime, aFromHttp));
43113: }
43113: 
43113: // notify observers that a cookie was rejected due to the users' prefs.
43113: void
43113: nsCookieService::NotifyRejected(nsIURI *aHostURI)
43113: {
43113:   if (mObserverService)
43113:     mObserverService->NotifyObservers(aHostURI, "cookie-rejected", nsnull);
43113: }
43113: 
43113: // notify observers that the cookie list changed. there are five possible
43113: // values for aData:
43113: // "deleted" means a cookie was deleted. aSubject is the deleted cookie.
43113: // "added"   means a cookie was added. aSubject is the added cookie.
43113: // "changed" means a cookie was altered. aSubject is the new cookie.
43113: // "cleared" means the entire cookie list was cleared. aSubject is null.
56824: // "batch-deleted" means a set of cookies was purged. aSubject is the list of
43113: // cookies.
43113: void
43113: nsCookieService::NotifyChanged(nsISupports     *aSubject,
43113:                                const PRUnichar *aData)
43113: {
43113:   if (mObserverService)
43113:     mObserverService->NotifyObservers(aSubject, "cookie-changed", aData);
43113: }
43113: 
57409: already_AddRefed<nsIArray>
57409: nsCookieService::CreatePurgeList(nsICookie2* aCookie)
56830: {
56830:   nsCOMPtr<nsIMutableArray> removedList =
56830:     do_CreateInstance(NS_ARRAY_CONTRACTID);
56830:   removedList->AppendElement(aCookie, PR_FALSE);
57409:   return removedList.forget();
56830: }
56830: 
43113: /******************************************************************************
43113:  * nsCookieService:
43113:  * pref observer impl
43113:  ******************************************************************************/
43113: 
43113: void
43113: nsCookieService::PrefChanged(nsIPrefBranch *aPrefBranch)
43113: {
43113:   PRInt32 val;
43113:   if (NS_SUCCEEDED(aPrefBranch->GetIntPref(kPrefCookieBehavior, &val)))
43113:     mCookieBehavior = (PRUint8) LIMIT(val, 0, 2, 0);
43113: 
43113:   if (NS_SUCCEEDED(aPrefBranch->GetIntPref(kPrefMaxNumberOfCookies, &val)))
43113:     mMaxNumberOfCookies = (PRUint16) LIMIT(val, 1, 0xFFFF, kMaxNumberOfCookies);
43113: 
43113:   if (NS_SUCCEEDED(aPrefBranch->GetIntPref(kPrefMaxCookiesPerHost, &val)))
43113:     mMaxCookiesPerHost = (PRUint16) LIMIT(val, 1, 0xFFFF, kMaxCookiesPerHost);
43113: 
57404:   if (NS_SUCCEEDED(aPrefBranch->GetIntPref(kPrefCookiePurgeAge, &val))) {
57404:     mCookiePurgeAge =
57404:       PRInt64(LIMIT(val, 0, PR_INT32_MAX, PR_INT32_MAX)) * PR_USEC_PER_SEC;
57404:   }
43113: 
43113:   PRBool boolval;
43113:   if (NS_SUCCEEDED(aPrefBranch->GetBoolPref(kPrefThirdPartySession, &boolval)))
43113:     mThirdPartySession = boolval;
56094: 
56094:   // Lazily instantiate the third party service if necessary.
56094:   if (!mThirdPartyUtil && RequireThirdPartyCheck()) {
56094:     mThirdPartyUtil = do_GetService(THIRDPARTYUTIL_CONTRACTID);
56094:     NS_ABORT_IF_FALSE(mThirdPartyUtil, "require ThirdPartyUtil service");
56094:   }
43113: }
43113: 
43113: /******************************************************************************
43113:  * nsICookieManager impl:
43113:  * nsICookieManager
43113:  ******************************************************************************/
43113: 
43113: NS_IMETHODIMP
43113: nsCookieService::RemoveAll()
43113: {
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return NS_ERROR_NOT_AVAILABLE;
58006:   }
58006: 
43113:   RemoveAllFromMemory();
43113: 
43113:   // clear the cookie file
43113:   if (mDBState->dbConn) {
57405:     NS_ASSERTION(mDBState == mDefaultDBState, "not in default DB state");
43113: 
56149:     // Cancel any pending read. No further results will be received by our
56149:     // read listener.
57405:     if (mDefaultDBState->pendingRead) {
56149:       CancelAsyncRead(PR_TRUE);
56149:     }
56149: 
48746:     nsCOMPtr<mozIStorageStatement> stmt;
57405:     nsresult rv = mDefaultDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
48746:       "DELETE FROM moz_cookies"), getter_AddRefs(stmt));
57410:     if (NS_SUCCEEDED(rv)) {
48746:       nsCOMPtr<mozIStoragePendingStatement> handle;
57405:       rv = stmt->ExecuteAsync(mDefaultDBState->removeListener,
57405:         getter_AddRefs(handle));
48746:       NS_ASSERT_SUCCESS(rv);
57410:     } else {
57410:       // Recreate the database.
57410:       COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:         ("RemoveAll(): corruption detected with rv 0x%x", rv));
57410:       HandleCorruptDB(mDefaultDBState);
57410:     }
43113:   }
43113: 
43113:   NotifyChanged(nsnull, NS_LITERAL_STRING("cleared").get());
43113:   return NS_OK;
43113: }
43113: 
43113: static PLDHashOperator
43113: COMArrayCallback(nsCookieEntry *aEntry,
43113:                  void          *aArg)
43113: {
56149:   nsCOMArray<nsICookie> *data = static_cast<nsCOMArray<nsICookie> *>(aArg);
43113: 
43113:   const nsCookieEntry::ArrayType &cookies = aEntry->GetCookies();
43113:   for (nsCookieEntry::IndexType i = 0; i < cookies.Length(); ++i) {
56149:     data->AppendObject(cookies[i]);
43113:   }
56149: 
43113:   return PL_DHASH_NEXT;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsCookieService::GetEnumerator(nsISimpleEnumerator **aEnumerator)
43113: {
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return NS_ERROR_NOT_AVAILABLE;
58006:   }
58006: 
56149:   EnsureReadComplete();
56149: 
43113:   nsCOMArray<nsICookie> cookieList(mDBState->cookieCount);
56149:   mDBState->hostTable.EnumerateEntries(COMArrayCallback, &cookieList);
43113: 
43113:   return NS_NewArrayEnumerator(aEnumerator, cookieList);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsCookieService::Add(const nsACString &aHost,
43113:                      const nsACString &aPath,
43113:                      const nsACString &aName,
43113:                      const nsACString &aValue,
43113:                      PRBool            aIsSecure,
43113:                      PRBool            aIsHttpOnly,
43113:                      PRBool            aIsSession,
43113:                      PRInt64           aExpiry)
43113: {
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return NS_ERROR_NOT_AVAILABLE;
58006:   }
58006: 
43113:   // first, normalize the hostname, and fail if it contains illegal characters.
43113:   nsCAutoString host(aHost);
43113:   nsresult rv = NormalizeHost(host);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   // get the base domain for the host URI.
43113:   // e.g. for "www.bbc.co.uk", this would be "bbc.co.uk".
43113:   nsCAutoString baseDomain;
43113:   rv = GetBaseDomainFromHost(host, baseDomain);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   PRInt64 currentTimeInUsec = PR_Now();
43113: 
43113:   nsRefPtr<nsCookie> cookie =
43113:     nsCookie::Create(aName, aValue, host, aPath,
43113:                      aExpiry,
43113:                      currentTimeInUsec,
56146:                      nsCookie::GenerateUniqueCreationTime(currentTimeInUsec),
43113:                      aIsSession,
43113:                      aIsSecure,
43113:                      aIsHttpOnly);
43113:   if (!cookie) {
43113:     return NS_ERROR_OUT_OF_MEMORY;
43113:   }
43113: 
43113:   AddInternal(baseDomain, cookie, currentTimeInUsec, nsnull, nsnull, PR_TRUE);
43113:   return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsCookieService::Remove(const nsACString &aHost,
43113:                         const nsACString &aName,
43113:                         const nsACString &aPath,
43113:                         PRBool           aBlocked)
43113: {
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return NS_ERROR_NOT_AVAILABLE;
58006:   }
58006: 
43113:   // first, normalize the hostname, and fail if it contains illegal characters.
43113:   nsCAutoString host(aHost);
43113:   nsresult rv = NormalizeHost(host);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   nsCAutoString baseDomain;
43113:   rv = GetBaseDomainFromHost(host, baseDomain);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   nsListIter matchIter;
57409:   nsRefPtr<nsCookie> cookie;
43113:   if (FindCookie(baseDomain,
43113:                  host,
43113:                  PromiseFlatCString(aName),
43113:                  PromiseFlatCString(aPath),
56146:                  matchIter)) {
57409:     cookie = matchIter.Cookie();
43113:     RemoveCookieFromList(matchIter);
43113:   }
43113: 
43113:   // check if we need to add the host to the permissions blacklist.
43113:   if (aBlocked && mPermissionService) {
43113:     // strip off the domain dot, if necessary
43113:     if (!host.IsEmpty() && host.First() == '.')
43113:       host.Cut(0, 1);
43113: 
43113:     host.Insert(NS_LITERAL_CSTRING("http://"), 0);
43113: 
43113:     nsCOMPtr<nsIURI> uri;
43113:     NS_NewURI(getter_AddRefs(uri), host);
43113: 
43113:     if (uri)
43113:       mPermissionService->SetAccess(uri, nsICookiePermission::ACCESS_DENY);
43113:   }
43113: 
57409:   if (cookie) {
57409:     // Everything's done. Notify observers.
57409:     NotifyChanged(cookie, NS_LITERAL_STRING("deleted").get());
57409:   }
57409: 
43113:   return NS_OK;
43113: }
43113: 
43113: /******************************************************************************
43113:  * nsCookieService impl:
43113:  * private file I/O functions
43113:  ******************************************************************************/
43113: 
57406: // Begin an asynchronous read from the database.
57406: OpenDBResult
43113: nsCookieService::Read()
43113: {
57405:   // Set up a statement for the read. Note that our query specifies that
57405:   // 'baseDomain' not be NULL -- see below for why.
57405:   nsCOMPtr<mozIStorageStatement> stmtRead;
57405:   nsresult rv = mDefaultDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
43113:     "SELECT "
43113:       "name, "
43113:       "value, "
43113:       "host, "
43113:       "path, "
43113:       "expiry, "
43113:       "lastAccessed, "
56146:       "creationTime, "
43113:       "isSecure, "
48370:       "isHttpOnly, "
48370:       "baseDomain "
56150:     "FROM moz_cookies "
57405:     "WHERE baseDomain NOTNULL"), getter_AddRefs(stmtRead));
57406:   NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
43113: 
57405:   // Set up a statement to delete any rows with a NULL 'baseDomain'
56150:   // column. This takes care of any cookies set by browsers that don't
56150:   // understand the 'baseDomain' column, where the database schema version
56150:   // is from one that does. (This would occur when downgrading.)
57405:   nsCOMPtr<mozIStorageStatement> stmtDeleteNull;
57405:   rv = mDefaultDBState->dbConn->CreateStatement(NS_LITERAL_CSTRING(
57405:     "DELETE FROM moz_cookies WHERE baseDomain ISNULL"),
57405:     getter_AddRefs(stmtDeleteNull));
57406:   NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
56150: 
57407:   // Start a new connection for sync reads, to reduce contention with the
57407:   // background thread. We need to do this before we kick off write statements,
57407:   // since they can lock the database and prevent connections from being opened.
57407:   rv = mStorageService->OpenUnsharedDatabase(mDefaultDBState->cookieFile,
57407:     getter_AddRefs(mDefaultDBState->syncConn));
57407:   NS_ENSURE_SUCCESS(rv, RESULT_RETRY);
57407: 
57405:   // Init our readSet hash and execute the statements. Note that, after this
57405:   // point, we cannot fail without altering the cleanup code in InitDBStates()
57405:   // to handle closing of the now-asynchronous connection.
57405:   mDefaultDBState->readSet.Init();
57410:   mDefaultDBState->hostArray.SetCapacity(kMaxNumberOfCookies);
57405: 
57405:   mDefaultDBState->readListener = new ReadCookieDBListener(mDefaultDBState);
57405:   rv = stmtRead->ExecuteAsync(mDefaultDBState->readListener,
57405:     getter_AddRefs(mDefaultDBState->pendingRead));
57405:   NS_ASSERT_SUCCESS(rv);
57405: 
56150:   nsCOMPtr<mozIStoragePendingStatement> handle;
57405:   rv = stmtDeleteNull->ExecuteAsync(mDefaultDBState->removeListener,
57405:     getter_AddRefs(handle));
56150:   NS_ASSERT_SUCCESS(rv);
56150: 
57406:   return RESULT_OK;
48743: }
48743: 
48744: // Extract data from a single result row and create an nsCookie.
48744: // This is templated since 'T' is different for sync vs async results.
48744: template<class T> nsCookie*
48744: nsCookieService::GetCookieFromRow(T &aRow)
48743: {
48744:   // Skip reading 'baseDomain' -- up to the caller.
48743:   nsCString name, value, host, path;
56146:   nsresult rv = aRow->GetUTF8String(0, name);
48744:   NS_ASSERT_SUCCESS(rv);
56146:   rv = aRow->GetUTF8String(1, value);
48744:   NS_ASSERT_SUCCESS(rv);
56146:   rv = aRow->GetUTF8String(2, host);
48744:   NS_ASSERT_SUCCESS(rv);
56146:   rv = aRow->GetUTF8String(3, path);
48744:   NS_ASSERT_SUCCESS(rv);
48743: 
56146:   PRInt64 expiry = aRow->AsInt64(4);
56146:   PRInt64 lastAccessed = aRow->AsInt64(5);
56146:   PRInt64 creationTime = aRow->AsInt64(6);
48743:   PRBool isSecure = 0 != aRow->AsInt32(7);
48743:   PRBool isHttpOnly = 0 != aRow->AsInt32(8);
48743: 
56146:   // Create a new nsCookie and assign the data.
48744:   return nsCookie::Create(name, value, host, path,
43113:                           expiry,
43113:                           lastAccessed,
56146:                           creationTime,
43113:                           PR_FALSE,
43113:                           isSecure,
43113:                           isHttpOnly);
43113: }
43113: 
48743: void
48744: nsCookieService::AsyncReadComplete()
48743: {
56145:   // We may be in the private browsing DB state, with a pending read on the
56145:   // default DB state. (This would occur if we started up in private browsing
56145:   // mode.) As long as we do all our operations on the default state, we're OK.
57405:   NS_ASSERTION(mDefaultDBState, "no default DBState");
57405:   NS_ASSERTION(mDefaultDBState->pendingRead, "no pending read");
57405:   NS_ASSERTION(mDefaultDBState->readListener, "no read listener");
48744: 
48744:   // Merge the data read on the background thread with the data synchronously
48744:   // read on the main thread. Note that transactions on the cookie table may
48744:   // have occurred on the main thread since, making the background data stale.
57405:   for (PRUint32 i = 0; i < mDefaultDBState->hostArray.Length(); ++i) {
57405:     const CookieDomainTuple &tuple = mDefaultDBState->hostArray[i];
48744: 
48744:     // Tiebreak: if the given base domain has already been read in, ignore
48744:     // the background data. Note that readSet may contain domains that were
48744:     // queried but found not to be in the db -- that's harmless.
57405:     if (mDefaultDBState->readSet.GetEntry(tuple.baseDomain))
48744:       continue;
48744: 
57405:     AddCookieToList(tuple.baseDomain, tuple.cookie, mDefaultDBState, NULL,
56145:       PR_FALSE);
48743:   }
48743: 
57405:   mDefaultDBState->stmtReadDomain = nsnull;
57405:   mDefaultDBState->pendingRead = nsnull;
57405:   mDefaultDBState->readListener = nsnull;
57405:   mDefaultDBState->syncConn = nsnull;
57405:   mDefaultDBState->hostArray.Clear();
57405:   mDefaultDBState->readSet.Clear();
48744: 
48743:   COOKIE_LOGSTRING(PR_LOG_DEBUG, ("Read(): %ld cookies read",
57405:                                   mDefaultDBState->cookieCount));
57409: 
57409:   mObserverService->NotifyObservers(nsnull, "cookie-db-read", nsnull);
48372: }
48372: 
48744: void
48744: nsCookieService::CancelAsyncRead(PRBool aPurgeReadSet)
48744: {
56145:   // We may be in the private browsing DB state, with a pending read on the
56145:   // default DB state. (This would occur if we started up in private browsing
56145:   // mode.) As long as we do all our operations on the default state, we're OK.
57405:   NS_ASSERTION(mDefaultDBState, "no default DBState");
57405:   NS_ASSERTION(mDefaultDBState->pendingRead, "no pending read");
57405:   NS_ASSERTION(mDefaultDBState->readListener, "no read listener");
48744: 
48744:   // Cancel the pending read, kill the read listener, and empty the array
48744:   // of data already read in on the background thread.
57405:   mDefaultDBState->readListener->Cancel();
57405:   nsresult rv = mDefaultDBState->pendingRead->Cancel();
48744:   NS_ASSERT_SUCCESS(rv);
48744: 
57405:   mDefaultDBState->stmtReadDomain = nsnull;
57405:   mDefaultDBState->pendingRead = nsnull;
57405:   mDefaultDBState->readListener = nsnull;
57405:   mDefaultDBState->hostArray.Clear();
48744: 
48744:   // Only clear the 'readSet' table if we no longer need to know what set of
48744:   // data is already accounted for.
48744:   if (aPurgeReadSet)
57405:     mDefaultDBState->readSet.Clear();
48744: }
48744: 
48744: void
48744: nsCookieService::EnsureReadDomain(const nsCString &aBaseDomain)
48744: {
57405:   NS_ASSERTION(!mDBState->dbConn || mDBState == mDefaultDBState,
48744:     "not in default db state");
48744: 
48744:   // Fast path 1: nothing to read, or we've already finished reading.
57405:   if (NS_LIKELY(!mDBState->dbConn || !mDefaultDBState->pendingRead))
48744:     return;
48744: 
48744:   // Fast path 2: already read in this particular domain.
57405:   if (NS_LIKELY(mDefaultDBState->readSet.GetEntry(aBaseDomain)))
48744:     return;
48744: 
48744:   // Read in the data synchronously.
48744:   nsresult rv;
57405:   if (!mDefaultDBState->stmtReadDomain) {
48744:     // Cache the statement, since it's likely to be used again.
57405:     rv = mDefaultDBState->syncConn->CreateStatement(NS_LITERAL_CSTRING(
48744:       "SELECT "
48744:         "name, "
48744:         "value, "
48744:         "host, "
48744:         "path, "
48744:         "expiry, "
48744:         "lastAccessed, "
56146:         "creationTime, "
48744:         "isSecure, "
48744:         "isHttpOnly "
48744:       "FROM moz_cookies "
57405:       "WHERE baseDomain = :baseDomain"),
57405:       getter_AddRefs(mDefaultDBState->stmtReadDomain));
48744: 
57410:     if (NS_FAILED(rv)) {
57410:       // Recreate the database.
57410:       COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:         ("EnsureReadDomain(): corruption detected when creating statement "
57410:          "with rv 0x%x", rv));
57410:       HandleCorruptDB(mDefaultDBState);
57410:       return;
57410:     }
48744:   }
48744: 
57405:   NS_ASSERTION(mDefaultDBState->syncConn, "should have a sync db connection");
57405: 
57405:   mozStorageStatementScoper scoper(mDefaultDBState->stmtReadDomain);
57405: 
57405:   rv = mDefaultDBState->stmtReadDomain->BindUTF8StringByName(
57405:     NS_LITERAL_CSTRING("baseDomain"), aBaseDomain);
48744:   NS_ASSERT_SUCCESS(rv);
48744: 
48744:   PRBool hasResult;
48744:   nsCString name, value, host, path;
57410:   nsAutoTArray<nsRefPtr<nsCookie>, kMaxCookiesPerHost> array;
48744:   while (1) {
57405:     rv = mDefaultDBState->stmtReadDomain->ExecuteStep(&hasResult);
57410:     if (NS_FAILED(rv)) {
57410:       // Recreate the database.
57410:       COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:         ("EnsureReadDomain(): corruption detected when reading result "
57410:          "with rv 0x%x", rv));
57410:       HandleCorruptDB(mDefaultDBState);
57410:       return;
57410:     }
48744: 
48744:     if (!hasResult)
48744:       break;
48744: 
57410:     array.AppendElement(GetCookieFromRow(mDefaultDBState->stmtReadDomain));
57410:   }
57410: 
57410:   // Add the cookies to the table in a single operation. This makes sure that
57410:   // either all the cookies get added, or in the case of corruption, none.
57410:   for (PRUint32 i = 0; i < array.Length(); ++i) {
57410:     AddCookieToList(aBaseDomain, array[i], mDefaultDBState, NULL, PR_FALSE);
48744:   }
48744: 
48744:   // Add it to the hashset of read entries, so we don't read it again.
57405:   mDefaultDBState->readSet.PutEntry(aBaseDomain);
48744: 
48744:   COOKIE_LOGSTRING(PR_LOG_DEBUG,
48744:     ("EnsureReadDomain(): %ld cookies read for base domain %s",
57410:      array.Length(), aBaseDomain.get()));
48744: }
48744: 
48744: void
48744: nsCookieService::EnsureReadComplete()
48744: {
57405:   NS_ASSERTION(!mDBState->dbConn || mDBState == mDefaultDBState,
48744:     "not in default db state");
48744: 
48744:   // Fast path 1: nothing to read, or we've already finished reading.
57405:   if (NS_LIKELY(!mDBState->dbConn || !mDefaultDBState->pendingRead))
48744:     return;
48744: 
48744:   // Cancel the pending read, so we don't get any more results.
48744:   CancelAsyncRead(PR_FALSE);
48744: 
48744:   // Read in the data synchronously.
48744:   nsCOMPtr<mozIStorageStatement> stmt;
57405:   nsresult rv = mDefaultDBState->syncConn->CreateStatement(NS_LITERAL_CSTRING(
48744:     "SELECT "
48744:       "name, "
48744:       "value, "
48744:       "host, "
48744:       "path, "
48744:       "expiry, "
48744:       "lastAccessed, "
56146:       "creationTime, "
48744:       "isSecure, "
48744:       "isHttpOnly, "
48744:       "baseDomain "
57408:     "FROM moz_cookies "
57408:     "WHERE baseDomain NOTNULL"), getter_AddRefs(stmt));
48744: 
57410:   if (NS_FAILED(rv)) {
57410:     // Recreate the database.
57410:     COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:       ("EnsureReadComplete(): corruption detected when creating statement "
57410:        "with rv 0x%x", rv));
57410:     HandleCorruptDB(mDefaultDBState);
57410:     return;
57410:   }
48744: 
48744:   nsCString baseDomain, name, value, host, path;
48744:   PRBool hasResult;
57410:   nsAutoTArray<CookieDomainTuple, kMaxNumberOfCookies> array;
48744:   while (1) {
48744:     rv = stmt->ExecuteStep(&hasResult);
57410:     if (NS_FAILED(rv)) {
57410:       // Recreate the database.
57410:       COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:         ("EnsureReadComplete(): corruption detected when reading result "
57410:          "with rv 0x%x", rv));
57410:       HandleCorruptDB(mDefaultDBState);
57410:       return;
57410:     }
48744: 
48744:     if (!hasResult)
48744:       break;
48744: 
48744:     // Make sure we haven't already read the data.
48744:     stmt->GetUTF8String(9, baseDomain);
57405:     if (mDefaultDBState->readSet.GetEntry(baseDomain))
48744:       continue;
48744: 
57410:     CookieDomainTuple* tuple = array.AppendElement();
57410:     tuple->baseDomain = baseDomain;
57410:     tuple->cookie = GetCookieFromRow(stmt);
57410:   }
57410: 
57410:   // Add the cookies to the table in a single operation. This makes sure that
57410:   // either all the cookies get added, or in the case of corruption, none.
57410:   for (PRUint32 i = 0; i < array.Length(); ++i) {
57410:     CookieDomainTuple& tuple = array[i];
57410:     AddCookieToList(tuple.baseDomain, tuple.cookie, mDefaultDBState, NULL,
57410:       PR_FALSE);
48744:   }
48744: 
57405:   mDefaultDBState->syncConn = nsnull;
57405:   mDefaultDBState->readSet.Clear();
48744: 
48744:   COOKIE_LOGSTRING(PR_LOG_DEBUG,
57410:     ("EnsureReadComplete(): %ld cookies read", array.Length()));
48744: }
48744: 
43113: NS_IMETHODIMP
43113: nsCookieService::ImportCookies(nsIFile *aCookieFile)
43113: {
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return NS_ERROR_NOT_AVAILABLE;
58006:   }
58006: 
56145:   // Make sure we're in the default DB state. We don't want people importing
56145:   // cookies into a private browsing session!
57405:   if (mDBState != mDefaultDBState) {
56145:     NS_WARNING("Trying to import cookies in a private browsing session!");
56145:     return NS_ERROR_NOT_AVAILABLE;
56145:   }
56145: 
43113:   nsresult rv;
43113:   nsCOMPtr<nsIInputStream> fileInputStream;
43113:   rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInputStream), aCookieFile);
43113:   if (NS_FAILED(rv)) return rv;
43113: 
43113:   nsCOMPtr<nsILineInputStream> lineInputStream = do_QueryInterface(fileInputStream, &rv);
43113:   if (NS_FAILED(rv)) return rv;
43113: 
57409:   // First, ensure we've read in everything from the database, if we have one.
57409:   EnsureReadComplete();
57409: 
43113:   static const char kTrue[] = "TRUE";
43113: 
43113:   nsCAutoString buffer, baseDomain;
43113:   PRBool isMore = PR_TRUE;
43113:   PRInt32 hostIndex, isDomainIndex, pathIndex, secureIndex, expiresIndex, nameIndex, cookieIndex;
43113:   nsASingleFragmentCString::char_iterator iter;
43113:   PRInt32 numInts;
43113:   PRInt64 expires;
43113:   PRBool isDomain, isHttpOnly = PR_FALSE;
57405:   PRUint32 originalCookieCount = mDefaultDBState->cookieCount;
43113: 
43113:   PRInt64 currentTimeInUsec = PR_Now();
43113:   PRInt64 currentTime = currentTimeInUsec / PR_USEC_PER_SEC;
43113:   // we use lastAccessedCounter to keep cookies in recently-used order,
43113:   // so we start by initializing to currentTime (somewhat arbitrary)
43113:   PRInt64 lastAccessedCounter = currentTimeInUsec;
43113: 
43113:   /* file format is:
43113:    *
43113:    * host \t isDomain \t path \t secure \t expires \t name \t cookie
43113:    *
43113:    * if this format isn't respected we move onto the next line in the file.
43113:    * isDomain is "TRUE" or "FALSE" (default to "FALSE")
43113:    * isSecure is "TRUE" or "FALSE" (default to "TRUE")
43113:    * expires is a PRInt64 integer
43113:    * note 1: cookie can contain tabs.
43113:    * note 2: cookies will be stored in order of lastAccessed time:
43113:    *         most-recently used come first; least-recently-used come last.
43113:    */
43113: 
43113:   /*
43113:    * ...but due to bug 178933, we hide HttpOnly cookies from older code
43113:    * in a comment, so they don't expose HttpOnly cookies to JS.
43113:    *
43113:    * The format for HttpOnly cookies is
43113:    *
43113:    * #HttpOnly_host \t isDomain \t path \t secure \t expires \t name \t cookie
43113:    *
43113:    */
43113: 
43113:   // We will likely be adding a bunch of cookies to the DB, so we use async
43113:   // batching with storage to make this super fast.
43113:   nsCOMPtr<mozIStorageBindingParamsArray> paramsArray;
57405:   if (originalCookieCount == 0 && mDefaultDBState->dbConn) {
57405:     mDefaultDBState->stmtInsert->NewBindingParamsArray(getter_AddRefs(paramsArray));
43113:   }
43113: 
43113:   while (isMore && NS_SUCCEEDED(lineInputStream->ReadLine(buffer, &isMore))) {
43113:     if (StringBeginsWith(buffer, NS_LITERAL_CSTRING(kHttpOnlyPrefix))) {
43113:       isHttpOnly = PR_TRUE;
43113:       hostIndex = sizeof(kHttpOnlyPrefix) - 1;
43113:     } else if (buffer.IsEmpty() || buffer.First() == '#') {
43113:       continue;
43113:     } else {
43113:       isHttpOnly = PR_FALSE;
43113:       hostIndex = 0;
43113:     }
43113: 
43113:     // this is a cheap, cheesy way of parsing a tab-delimited line into
43113:     // string indexes, which can be lopped off into substrings. just for
43113:     // purposes of obfuscation, it also checks that each token was found.
43113:     // todo: use iterators?
43113:     if ((isDomainIndex = buffer.FindChar('\t', hostIndex)     + 1) == 0 ||
43113:         (pathIndex     = buffer.FindChar('\t', isDomainIndex) + 1) == 0 ||
43113:         (secureIndex   = buffer.FindChar('\t', pathIndex)     + 1) == 0 ||
43113:         (expiresIndex  = buffer.FindChar('\t', secureIndex)   + 1) == 0 ||
43113:         (nameIndex     = buffer.FindChar('\t', expiresIndex)  + 1) == 0 ||
43113:         (cookieIndex   = buffer.FindChar('\t', nameIndex)     + 1) == 0) {
43113:       continue;
43113:     }
43113: 
43113:     // check the expirytime first - if it's expired, ignore
43113:     // nullstomp the trailing tab, to avoid copying the string
43113:     buffer.BeginWriting(iter);
43113:     *(iter += nameIndex - 1) = char(0);
43113:     numInts = PR_sscanf(buffer.get() + expiresIndex, "%lld", &expires);
43113:     if (numInts != 1 || expires < currentTime) {
43113:       continue;
43113:     }
43113: 
43113:     isDomain = Substring(buffer, isDomainIndex, pathIndex - isDomainIndex - 1).EqualsLiteral(kTrue);
43113:     const nsASingleFragmentCString &host = Substring(buffer, hostIndex, isDomainIndex - hostIndex - 1);
43113:     // check for bad legacy cookies (domain not starting with a dot, or containing a port),
43113:     // and discard
43113:     if ((isDomain && !host.IsEmpty() && host.First() != '.') ||
43113:         host.FindChar(':') != kNotFound) {
43113:       continue;
43113:     }
43113: 
43113:     // compute the baseDomain from the host
43113:     rv = GetBaseDomainFromHost(host, baseDomain);
43113:     if (NS_FAILED(rv))
43113:       continue;
43113: 
56146:     // Create a new nsCookie and assign the data. We don't know the cookie
56146:     // creation time, so just use the current time to generate a unique one.
43113:     nsRefPtr<nsCookie> newCookie =
43113:       nsCookie::Create(Substring(buffer, nameIndex, cookieIndex - nameIndex - 1),
43113:                        Substring(buffer, cookieIndex, buffer.Length() - cookieIndex),
43113:                        host,
43113:                        Substring(buffer, pathIndex, secureIndex - pathIndex - 1),
43113:                        expires,
43113:                        lastAccessedCounter,
56146:                        nsCookie::GenerateUniqueCreationTime(currentTimeInUsec),
43113:                        PR_FALSE,
43113:                        Substring(buffer, secureIndex, expiresIndex - secureIndex - 1).EqualsLiteral(kTrue),
43113:                        isHttpOnly);
43113:     if (!newCookie) {
43113:       return NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113:     
43113:     // trick: preserve the most-recently-used cookie ordering,
43113:     // by successively decrementing the lastAccessed time
43113:     lastAccessedCounter--;
43113: 
43113:     if (originalCookieCount == 0) {
57405:       AddCookieToList(baseDomain, newCookie, mDefaultDBState, paramsArray);
43113:     }
43113:     else {
43113:       AddInternal(baseDomain, newCookie, currentTimeInUsec, NULL, NULL, PR_TRUE);
43113:     }
43113:   }
43113: 
43113:   // If we need to write to disk, do so now.
43113:   if (paramsArray) {
43113:     PRUint32 length;
43113:     paramsArray->GetLength(&length);
43113:     if (length) {
57405:       rv = mDefaultDBState->stmtInsert->BindParameters(paramsArray);
43113:       NS_ASSERT_SUCCESS(rv);
43113:       nsCOMPtr<mozIStoragePendingStatement> handle;
57405:       rv = mDefaultDBState->stmtInsert->ExecuteAsync(
57405:         mDefaultDBState->insertListener, getter_AddRefs(handle));
43113:       NS_ASSERT_SUCCESS(rv);
43113:     }
43113:   }
43113: 
43113: 
56145:   COOKIE_LOGSTRING(PR_LOG_DEBUG, ("ImportCookies(): %ld cookies imported",
57405:     mDefaultDBState->cookieCount));
43113: 
43113:   return NS_OK;
43113: }
43113: 
43113: /******************************************************************************
43113:  * nsCookieService impl:
43113:  * private GetCookie/SetCookie helpers
43113:  ******************************************************************************/
43113: 
43113: // helper function for GetCookieList
43113: static inline PRBool ispathdelimiter(char c) { return c == '/' || c == '?' || c == '#' || c == ';'; }
43113: 
43113: // Comparator class for sorting cookies before sending to a server.
43113: class CompareCookiesForSending
43113: {
43113: public:
43113:   PRBool Equals(const nsCookie* aCookie1, const nsCookie* aCookie2) const
43113:   {
56146:     return aCookie1->CreationTime() == aCookie2->CreationTime() &&
56146:            aCookie2->Path().Length() == aCookie1->Path().Length();
43113:   }
43113: 
43113:   PRBool LessThan(const nsCookie* aCookie1, const nsCookie* aCookie2) const
43113:   {
43113:     // compare by cookie path length in accordance with RFC2109
43113:     PRInt32 result = aCookie2->Path().Length() - aCookie1->Path().Length();
43113:     if (result != 0)
43113:       return result < 0;
43113: 
43113:     // when path lengths match, older cookies should be listed first.  this is
43113:     // required for backwards compatibility since some websites erroneously
43113:     // depend on receiving cookies in the order in which they were sent to the
43113:     // browser!  see bug 236772.
56146:     return aCookie1->CreationTime() < aCookie2->CreationTime();
43113:   }
43113: };
43113: 
43113: void
54196: nsCookieService::GetCookieStringInternal(nsIURI *aHostURI,
56094:                                          bool aIsForeign,
43113:                                          PRBool aHttpBound,
46770:                                          nsCString &aCookieString)
43113: {
54196:   NS_ASSERTION(aHostURI, "null host!");
43113: 
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return;
58006:   }
58006: 
43113:   // get the base domain, host, and path from the URI.
43113:   // e.g. for "www.bbc.co.uk", the base domain would be "bbc.co.uk".
43113:   // file:// URI's (i.e. with an empty host) are allowed, but any other
43113:   // scheme must have a non-empty host. A trailing dot in the host
59617:   // is acceptable.
43113:   PRBool requireHostMatch;
43113:   nsCAutoString baseDomain, hostFromURI, pathFromURI;
43113:   nsresult rv = GetBaseDomain(aHostURI, baseDomain, requireHostMatch);
43113:   if (NS_SUCCEEDED(rv))
43113:     rv = aHostURI->GetAsciiHost(hostFromURI);
43113:   if (NS_SUCCEEDED(rv))
43113:     rv = aHostURI->GetPath(pathFromURI);
43113:   if (NS_FAILED(rv)) {
43113:     COOKIE_LOGFAILURE(GET_COOKIE, aHostURI, nsnull, "invalid host/path from URI");
43113:     return;
43113:   }
43113: 
43113:   // check default prefs
56094:   CookieStatus cookieStatus = CheckPrefs(aHostURI, aIsForeign, baseDomain,
43113:                                          requireHostMatch, nsnull);
43113:   // for GetCookie(), we don't fire rejection notifications.
43113:   switch (cookieStatus) {
43113:   case STATUS_REJECTED:
43113:   case STATUS_REJECTED_WITH_ERROR:
43113:     return;
43113:   default:
43113:     break;
43113:   }
43113: 
43113:   // check if aHostURI is using an https secure protocol.
43113:   // if it isn't, then we can't send a secure cookie over the connection.
43113:   // if SchemeIs fails, assume an insecure connection, to be on the safe side
43113:   PRBool isSecure;
43113:   if (NS_FAILED(aHostURI->SchemeIs("https", &isSecure))) {
43113:     isSecure = PR_FALSE;
43113:   }
43113: 
43113:   nsCookie *cookie;
43113:   nsAutoTArray<nsCookie*, 8> foundCookieList;
43113:   PRInt64 currentTimeInUsec = PR_Now();
43113:   PRInt64 currentTime = currentTimeInUsec / PR_USEC_PER_SEC;
43113:   PRBool stale = PR_FALSE;
43113: 
48744:   EnsureReadDomain(baseDomain);
48744: 
43113:   // perform the hash lookup
43113:   nsCookieEntry *entry = mDBState->hostTable.GetEntry(baseDomain);
43113:   if (!entry)
43113:     return;
43113: 
43113:   // iterate the cookies!
43113:   const nsCookieEntry::ArrayType &cookies = entry->GetCookies();
43113:   for (nsCookieEntry::IndexType i = 0; i < cookies.Length(); ++i) {
43113:     cookie = cookies[i];
43113: 
43113:     // check the host, since the base domain lookup is conservative.
43113:     // first, check for an exact host or domain cookie match, e.g. "google.com"
43113:     // or ".google.com"; second a subdomain match, e.g.
43113:     // host = "mail.google.com", cookie domain = ".google.com".
43113:     if (cookie->RawHost() != hostFromURI &&
43113:         !(cookie->IsDomain() && StringEndsWith(hostFromURI, cookie->Host())))
43113:       continue;
43113: 
43113:     // if the cookie is secure and the host scheme isn't, we can't send it
43113:     if (cookie->IsSecure() && !isSecure)
43113:       continue;
43113: 
43113:     // if the cookie is httpOnly and it's not going directly to the HTTP
43113:     // connection, don't send it
43113:     if (cookie->IsHttpOnly() && !aHttpBound)
43113:       continue;
43113: 
43113:     // calculate cookie path length, excluding trailing '/'
43113:     PRUint32 cookiePathLen = cookie->Path().Length();
43113:     if (cookiePathLen > 0 && cookie->Path().Last() == '/')
43113:       --cookiePathLen;
43113: 
43113:     // if the nsIURI path is shorter than the cookie path, don't send it back
43113:     if (!StringBeginsWith(pathFromURI, Substring(cookie->Path(), 0, cookiePathLen)))
43113:       continue;
43113: 
43113:     if (pathFromURI.Length() > cookiePathLen &&
43113:         !ispathdelimiter(pathFromURI.CharAt(cookiePathLen))) {
43113:       /*
43113:        * |ispathdelimiter| tests four cases: '/', '?', '#', and ';'.
43113:        * '/' is the "standard" case; the '?' test allows a site at host/abc?def
43113:        * to receive a cookie that has a path attribute of abc.  this seems
43113:        * strange but at least one major site (citibank, bug 156725) depends
43113:        * on it.  The test for # and ; are put in to proactively avoid problems
43113:        * with other sites - these are the only other chars allowed in the path.
43113:        */
43113:       continue;
43113:     }
43113: 
43113:     // check if the cookie has expired
43113:     if (cookie->Expiry() <= currentTime) {
43113:       continue;
43113:     }
43113: 
43113:     // all checks passed - add to list and check if lastAccessed stamp needs updating
43113:     foundCookieList.AppendElement(cookie);
43113:     if (currentTimeInUsec - cookie->LastAccessed() > kCookieStaleThreshold)
43113:       stale = PR_TRUE;
43113:   }
43113: 
43113:   PRInt32 count = foundCookieList.Length();
43113:   if (count == 0)
43113:     return;
43113: 
43113:   // update lastAccessed timestamps. we only do this if the timestamp is stale
43113:   // by a certain amount, to avoid thrashing the db during pageload.
43113:   if (stale) {
43113:     // Create an array of parameters to bind to our update statement. Batching
43113:     // is OK here since we're updating cookies with no interleaved operations.
43113:     nsCOMPtr<mozIStorageBindingParamsArray> paramsArray;
57405:     mozIStorageAsyncStatement* stmt = mDBState->stmtUpdate;
43113:     if (mDBState->dbConn) {
43113:       stmt->NewBindingParamsArray(getter_AddRefs(paramsArray));
43113:     }
43113: 
43113:     for (PRInt32 i = 0; i < count; ++i) {
43113:       cookie = foundCookieList.ElementAt(i);
43113: 
43113:       if (currentTimeInUsec - cookie->LastAccessed() > kCookieStaleThreshold)
43113:         UpdateCookieInList(cookie, currentTimeInUsec, paramsArray);
43113:     }
43113:     // Update the database now if necessary.
43113:     if (paramsArray) {
43113:       PRUint32 length;
43113:       paramsArray->GetLength(&length);
43113:       if (length) {
43113:         nsresult rv = stmt->BindParameters(paramsArray);
43113:         NS_ASSERT_SUCCESS(rv);
43113:         nsCOMPtr<mozIStoragePendingStatement> handle;
57405:         rv = stmt->ExecuteAsync(mDBState->updateListener,
57405:           getter_AddRefs(handle));
43113:         NS_ASSERT_SUCCESS(rv);
43113:       }
43113:     }
43113:   }
43113: 
43113:   // return cookies in order of path length; longest to shortest.
43113:   // this is required per RFC2109.  if cookies match in length,
43113:   // then sort by creation time (see bug 236772).
43113:   foundCookieList.Sort(CompareCookiesForSending());
43113: 
43113:   for (PRInt32 i = 0; i < count; ++i) {
43113:     cookie = foundCookieList.ElementAt(i);
43113: 
43113:     // check if we have anything to write
43113:     if (!cookie->Name().IsEmpty() || !cookie->Value().IsEmpty()) {
43113:       // if we've already added a cookie to the return list, append a "; " so
43113:       // that subsequent cookies are delimited in the final list.
46770:       if (!aCookieString.IsEmpty()) {
46770:         aCookieString.AppendLiteral("; ");
43113:       }
43113: 
43113:       if (!cookie->Name().IsEmpty()) {
43113:         // we have a name and value - write both
46770:         aCookieString += cookie->Name() + NS_LITERAL_CSTRING("=") + cookie->Value();
43113:       } else {
43113:         // just write value
46770:         aCookieString += cookie->Value();
43113:       }
43113:     }
43113:   }
43113: 
46770:   if (!aCookieString.IsEmpty())
46770:     COOKIE_LOGSUCCESS(GET_COOKIE, aHostURI, aCookieString, nsnull, nsnull);
43113: }
43113: 
43113: // processes a single cookie, and returns PR_TRUE if there are more cookies
43113: // to be processed
43113: PRBool
43113: nsCookieService::SetCookieInternal(nsIURI                        *aHostURI,
43113:                                    const nsCString               &aBaseDomain,
43113:                                    PRBool                         aRequireHostMatch,
43113:                                    CookieStatus                   aStatus,
43113:                                    nsDependentCString            &aCookieHeader,
43113:                                    PRInt64                        aServerTime,
43113:                                    PRBool                         aFromHttp)
43113: {
54196:   NS_ASSERTION(aHostURI, "null host!");
54196: 
43113:   // create a stack-based nsCookieAttributes, to store all the
43113:   // attributes parsed from the cookie
43113:   nsCookieAttributes cookieAttributes;
43113: 
43113:   // init expiryTime such that session cookies won't prematurely expire
43113:   cookieAttributes.expiryTime = LL_MAXINT;
43113: 
43113:   // aCookieHeader is an in/out param to point to the next cookie, if
43113:   // there is one. Save the present value for logging purposes
43113:   nsDependentCString savedCookieHeader(aCookieHeader);
43113: 
43113:   // newCookie says whether there are multiple cookies in the header;
43113:   // so we can handle them separately.
43113:   PRBool newCookie = ParseAttributes(aCookieHeader, cookieAttributes);
43113: 
43113:   PRInt64 currentTimeInUsec = PR_Now();
43113: 
43113:   // calculate expiry time of cookie.
43113:   cookieAttributes.isSession = GetExpiry(cookieAttributes, aServerTime,
43113:                                          currentTimeInUsec / PR_USEC_PER_SEC);
43113:   if (aStatus == STATUS_ACCEPT_SESSION) {
43113:     // force lifetime to session. note that the expiration time, if set above,
43113:     // will still apply.
43113:     cookieAttributes.isSession = PR_TRUE;
43113:   }
43113: 
43113:   // reject cookie if it's over the size limit, per RFC2109
43113:   if ((cookieAttributes.name.Length() + cookieAttributes.value.Length()) > kMaxBytesPerCookie) {
43113:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "cookie too big (> 4kb)");
43113:     return newCookie;
43113:   }
43113: 
43113:   if (cookieAttributes.name.FindChar('\t') != kNotFound) {
43113:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "invalid name character");
43113:     return newCookie;
43113:   }
43113: 
43113:   // domain & path checks
43113:   if (!CheckDomain(cookieAttributes, aHostURI, aBaseDomain, aRequireHostMatch)) {
43113:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "failed the domain tests");
43113:     return newCookie;
43113:   }
43113:   if (!CheckPath(cookieAttributes, aHostURI)) {
43113:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "failed the path tests");
43113:     return newCookie;
43113:   }
43113: 
43113:   // create a new nsCookie and copy attributes
43113:   nsRefPtr<nsCookie> cookie =
43113:     nsCookie::Create(cookieAttributes.name,
43113:                      cookieAttributes.value,
43113:                      cookieAttributes.host,
43113:                      cookieAttributes.path,
43113:                      cookieAttributes.expiryTime,
43113:                      currentTimeInUsec,
56146:                      nsCookie::GenerateUniqueCreationTime(currentTimeInUsec),
43113:                      cookieAttributes.isSession,
43113:                      cookieAttributes.isSecure,
43113:                      cookieAttributes.isHttpOnly);
43113:   if (!cookie)
43113:     return newCookie;
43113: 
43113:   // check permissions from site permission list, or ask the user,
43113:   // to determine if we can set the cookie
43113:   if (mPermissionService) {
43113:     PRBool permission;
46770:     // Not passing an nsIChannel here means CanSetCookie will use the currently
54196:     // active window to display the prompt. This isn't exactly ideal, but this
54196:     // code is going away. See bug 546746.
43113:     mPermissionService->CanSetCookie(aHostURI,
46770:                                      nsnull,
43113:                                      static_cast<nsICookie2*>(static_cast<nsCookie*>(cookie)),
43113:                                      &cookieAttributes.isSession,
43113:                                      &cookieAttributes.expiryTime,
43113:                                      &permission);
43113:     if (!permission) {
43113:       COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, savedCookieHeader, "cookie rejected by permission manager");
43113:       NotifyRejected(aHostURI);
43113:       return newCookie;
43113:     }
43113: 
43113:     // update isSession and expiry attributes, in case they changed
43113:     cookie->SetIsSession(cookieAttributes.isSession);
43113:     cookie->SetExpiry(cookieAttributes.expiryTime);
43113:   }
43113: 
43113:   // add the cookie to the list. AddInternal() takes care of logging.
43113:   // we get the current time again here, since it may have changed during prompting
43113:   AddInternal(aBaseDomain, cookie, PR_Now(), aHostURI, savedCookieHeader.get(),
43113:               aFromHttp);
43113:   return newCookie;
43113: }
43113: 
43113: // this is a backend function for adding a cookie to the list, via SetCookie.
43113: // also used in the cookie manager, for profile migration from IE.
43113: // it either replaces an existing cookie; or adds the cookie to the hashtable,
43113: // and deletes a cookie (if maximum number of cookies has been
43113: // reached). also performs list maintenance by removing expired cookies.
43113: void
43113: nsCookieService::AddInternal(const nsCString               &aBaseDomain,
43113:                              nsCookie                      *aCookie,
43113:                              PRInt64                        aCurrentTimeInUsec,
43113:                              nsIURI                        *aHostURI,
43113:                              const char                    *aCookieHeader,
43113:                              PRBool                         aFromHttp)
43113: {
43113:   PRInt64 currentTime = aCurrentTimeInUsec / PR_USEC_PER_SEC;
43113: 
43113:   // if the new cookie is httponly, make sure we're not coming from script
43113:   if (!aFromHttp && aCookie->IsHttpOnly()) {
56257:     COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader,
56257:       "cookie is httponly; coming from script");
43113:     return;
43113:   }
43113: 
43113:   nsListIter matchIter;
43113:   PRBool foundCookie = FindCookie(aBaseDomain, aCookie->Host(),
56146:     aCookie->Name(), aCookie->Path(), matchIter);
43113: 
43113:   nsRefPtr<nsCookie> oldCookie;
57409:   nsCOMPtr<nsIArray> purgedList;
43113:   if (foundCookie) {
43113:     oldCookie = matchIter.Cookie();
43113: 
56257:     // Check if the old cookie is stale (i.e. has already expired). If so, we
56257:     // need to be careful about the semantics of removing it and adding the new
56257:     // cookie: we want the behavior wrt adding the new cookie to be the same as
56257:     // if it didn't exist, but we still want to fire a removal notification.
56257:     if (oldCookie->Expiry() <= currentTime) {
56257:       if (aCookie->Expiry() <= currentTime) {
56257:         // The new cookie has expired and the old one is stale. Nothing to do.
56257:         COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader,
56257:           "cookie has already expired");
43113:         return;
43113:       }
43113: 
57409:       // Remove the stale cookie. We save notification for later, once all list
57409:       // modifications are complete.
43113:       RemoveCookieFromList(matchIter);
56257:       COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader,
56824:         "stale cookie was purged");
57409:       purgedList = CreatePurgeList(oldCookie);
56257: 
56257:       // We've done all we need to wrt removing and notifying the stale cookie.
56257:       // From here on out, we pretend pretend it didn't exist, so that we
56257:       // preserve expected notification semantics when adding the new cookie.
56257:       foundCookie = PR_FALSE;
56257: 
56257:     } else {
56257:       // If the old cookie is httponly, make sure we're not coming from script.
56257:       if (!aFromHttp && oldCookie->IsHttpOnly()) {
56257:         COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader,
56257:           "previously stored cookie is httponly; coming from script");
56257:         return;
56257:       }
56257: 
56824:       // Remove the old cookie.
56257:       RemoveCookieFromList(matchIter);
56257: 
56824:       // If the new cookie has expired -- i.e. the intent was simply to delete
56824:       // the old cookie -- then we're done.
56824:       if (aCookie->Expiry() <= currentTime) {
56257:         COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader,
56257:           "previously stored cookie was deleted");
43113:         NotifyChanged(oldCookie, NS_LITERAL_STRING("deleted").get());
43113:         return;
56257:       }
56146: 
56146:       // Preserve creation time of cookie for ordering purposes.
56146:       aCookie->SetCreationTime(oldCookie->CreationTime());
56257:     }
43113: 
43113:   } else {
43113:     // check if cookie has already expired
43113:     if (aCookie->Expiry() <= currentTime) {
56257:       COOKIE_LOGFAILURE(SET_COOKIE, aHostURI, aCookieHeader,
56257:         "cookie has already expired");
43113:       return;
43113:     }
43113: 
43113:     // check if we have to delete an old cookie.
56149:     nsCookieEntry *entry = mDBState->hostTable.GetEntry(aBaseDomain);
56149:     if (entry && entry->GetCookies().Length() >= mMaxCookiesPerHost) {
56149:       nsListIter iter;
56149:       FindStaleCookie(entry, currentTime, iter);
56824:       oldCookie = iter.Cookie();
56149: 
51398:       // remove the oldest cookie from the domain
56149:       RemoveCookieFromList(iter);
56824:       COOKIE_LOGEVICTED(oldCookie, "Too many cookies for this domain");
57409:       purgedList = CreatePurgeList(oldCookie);
43113: 
43113:     } else if (mDBState->cookieCount >= ADD_TEN_PERCENT(mMaxNumberOfCookies)) {
43113:       PRInt64 maxAge = aCurrentTimeInUsec - mDBState->cookieOldestTime;
43113:       PRInt64 purgeAge = ADD_TEN_PERCENT(mCookiePurgeAge);
43113:       if (maxAge >= purgeAge) {
43113:         // we're over both size and age limits by 10%; time to purge the table!
43113:         // do this by:
43113:         // 1) removing expired cookies;
56257:         // 2) evicting the balance of old cookies until we reach the size limit.
43113:         // note that the cookieOldestTime indicator can be pessimistic - if it's
43113:         // older than the actual oldest cookie, we'll just purge more eagerly.
57409:         purgedList = PurgeCookies(aCurrentTimeInUsec);
43113:       }
43113:     }
43113:   }
43113: 
43113:   // Add the cookie to the db. We do not supply a params array for batching
43113:   // because this might result in removals and additions being out of order.
56145:   AddCookieToList(aBaseDomain, aCookie, mDBState, NULL);
57409:   COOKIE_LOGSUCCESS(SET_COOKIE, aHostURI, aCookieHeader, aCookie, foundCookie);
57409: 
57409:   // Now that list mutations are complete, notify observers. We do it here
57409:   // because observers may themselves attempt to mutate the list.
57409:   if (purgedList) {
57409:     NotifyChanged(purgedList, NS_LITERAL_STRING("batch-deleted").get());
57409:   }
57409: 
43113:   NotifyChanged(aCookie, foundCookie ? NS_LITERAL_STRING("changed").get()
43113:                                      : NS_LITERAL_STRING("added").get());
43113: }
43113: 
43113: /******************************************************************************
43113:  * nsCookieService impl:
43113:  * private cookie header parsing functions
43113:  ******************************************************************************/
43113: 
43113: // The following comment block elucidates the function of ParseAttributes.
43113: /******************************************************************************
43113:  ** Augmented BNF, modified from RFC2109 Section 4.2.2 and RFC2616 Section 2.1
43113:  ** please note: this BNF deviates from both specifications, and reflects this
43113:  ** implementation. <bnf> indicates a reference to the defined grammar "bnf".
43113: 
43113:  ** Differences from RFC2109/2616 and explanations:
43113:     1. implied *LWS
43113:          The grammar described by this specification is word-based. Except
43113:          where noted otherwise, linear white space (<LWS>) can be included
43113:          between any two adjacent words (token or quoted-string), and
43113:          between adjacent words and separators, without changing the
43113:          interpretation of a field.
43113:        <LWS> according to spec is SP|HT|CR|LF, but here, we allow only SP | HT.
43113: 
43113:     2. We use CR | LF as cookie separators, not ',' per spec, since ',' is in
43113:        common use inside values.
43113: 
43113:     3. tokens and values have looser restrictions on allowed characters than
43113:        spec. This is also due to certain characters being in common use inside
43113:        values. We allow only '=' to separate token/value pairs, and ';' to
43113:        terminate tokens or values. <LWS> is allowed within tokens and values
43113:        (see bug 206022).
43113: 
43113:     4. where appropriate, full <OCTET>s are allowed, where the spec dictates to
43113:        reject control chars or non-ASCII chars. This is erring on the loose
43113:        side, since there's probably no good reason to enforce this strictness.
43113: 
43113:     5. cookie <NAME> is optional, where spec requires it. This is a fairly
43113:        trivial case, but allows the flexibility of setting only a cookie <VALUE>
43113:        with a blank <NAME> and is required by some sites (see bug 169091).
43113:        
43113:     6. Attribute "HttpOnly", not covered in the RFCs, is supported
43113:        (see bug 178993).
43113: 
43113:  ** Begin BNF:
43113:     token         = 1*<any allowed-chars except separators>
43113:     value         = 1*<any allowed-chars except value-sep>
43113:     separators    = ";" | "="
43113:     value-sep     = ";"
43113:     cookie-sep    = CR | LF
43113:     allowed-chars = <any OCTET except NUL or cookie-sep>
43113:     OCTET         = <any 8-bit sequence of data>
43113:     LWS           = SP | HT
43113:     NUL           = <US-ASCII NUL, null control character (0)>
43113:     CR            = <US-ASCII CR, carriage return (13)>
43113:     LF            = <US-ASCII LF, linefeed (10)>
43113:     SP            = <US-ASCII SP, space (32)>
43113:     HT            = <US-ASCII HT, horizontal-tab (9)>
43113: 
43113:     set-cookie    = "Set-Cookie:" cookies
43113:     cookies       = cookie *( cookie-sep cookie )
43113:     cookie        = [NAME "="] VALUE *(";" cookie-av)    ; cookie NAME/VALUE must come first
43113:     NAME          = token                                ; cookie name
43113:     VALUE         = value                                ; cookie value
43113:     cookie-av     = token ["=" value]
43113: 
43113:     valid values for cookie-av (checked post-parsing) are:
43113:     cookie-av     = "Path"    "=" value
43113:                   | "Domain"  "=" value
43113:                   | "Expires" "=" value
43113:                   | "Max-Age" "=" value
43113:                   | "Comment" "=" value
43113:                   | "Version" "=" value
43113:                   | "Secure"
43113:                   | "HttpOnly"
43113: 
43113: ******************************************************************************/
43113: 
43113: // helper functions for GetTokenValue
43113: static inline PRBool iswhitespace     (char c) { return c == ' '  || c == '\t'; }
43113: static inline PRBool isterminator     (char c) { return c == '\n' || c == '\r'; }
43113: static inline PRBool isvalueseparator (char c) { return isterminator(c) || c == ';'; }
43113: static inline PRBool istokenseparator (char c) { return isvalueseparator(c) || c == '='; }
43113: 
43113: // Parse a single token/value pair.
43113: // Returns PR_TRUE if a cookie terminator is found, so caller can parse new cookie.
43113: PRBool
43113: nsCookieService::GetTokenValue(nsASingleFragmentCString::const_char_iterator &aIter,
43113:                                nsASingleFragmentCString::const_char_iterator &aEndIter,
43113:                                nsDependentCSubstring                         &aTokenString,
43113:                                nsDependentCSubstring                         &aTokenValue,
43113:                                PRBool                                        &aEqualsFound)
43113: {
43113:   nsASingleFragmentCString::const_char_iterator start, lastSpace;
43113:   // initialize value string to clear garbage
43113:   aTokenValue.Rebind(aIter, aIter);
43113: 
43113:   // find <token>, including any <LWS> between the end-of-token and the
43113:   // token separator. we'll remove trailing <LWS> next
43113:   while (aIter != aEndIter && iswhitespace(*aIter))
43113:     ++aIter;
43113:   start = aIter;
43113:   while (aIter != aEndIter && !istokenseparator(*aIter))
43113:     ++aIter;
43113: 
43113:   // remove trailing <LWS>; first check we're not at the beginning
43113:   lastSpace = aIter;
43113:   if (lastSpace != start) {
43113:     while (--lastSpace != start && iswhitespace(*lastSpace));
43113:     ++lastSpace;
43113:   }
43113:   aTokenString.Rebind(start, lastSpace);
43113: 
43113:   aEqualsFound = (*aIter == '=');
43113:   if (aEqualsFound) {
43113:     // find <value>
43113:     while (++aIter != aEndIter && iswhitespace(*aIter));
43113: 
43113:     start = aIter;
43113: 
43113:     // process <token>
43113:     // just look for ';' to terminate ('=' allowed)
43113:     while (aIter != aEndIter && !isvalueseparator(*aIter))
43113:       ++aIter;
43113: 
43113:     // remove trailing <LWS>; first check we're not at the beginning
43113:     if (aIter != start) {
43113:       lastSpace = aIter;
43113:       while (--lastSpace != start && iswhitespace(*lastSpace));
43113:       aTokenValue.Rebind(start, ++lastSpace);
43113:     }
43113:   }
43113: 
43113:   // aIter is on ';', or terminator, or EOS
43113:   if (aIter != aEndIter) {
43113:     // if on terminator, increment past & return PR_TRUE to process new cookie
43113:     if (isterminator(*aIter)) {
43113:       ++aIter;
43113:       return PR_TRUE;
43113:     }
43113:     // fall-through: aIter is on ';', increment and return PR_FALSE
43113:     ++aIter;
43113:   }
43113:   return PR_FALSE;
43113: }
43113: 
43113: // Parses attributes from cookie header. expires/max-age attributes aren't folded into the
43113: // cookie struct here, because we don't know which one to use until we've parsed the header.
43113: PRBool
43113: nsCookieService::ParseAttributes(nsDependentCString &aCookieHeader,
43113:                                  nsCookieAttributes &aCookieAttributes)
43113: {
43113:   static const char kPath[]    = "path";
43113:   static const char kDomain[]  = "domain";
43113:   static const char kExpires[] = "expires";
43113:   static const char kMaxage[]  = "max-age";
43113:   static const char kSecure[]  = "secure";
43113:   static const char kHttpOnly[]  = "httponly";
43113: 
43113:   nsASingleFragmentCString::const_char_iterator tempBegin, tempEnd;
43113:   nsASingleFragmentCString::const_char_iterator cookieStart, cookieEnd;
43113:   aCookieHeader.BeginReading(cookieStart);
43113:   aCookieHeader.EndReading(cookieEnd);
43113: 
43113:   aCookieAttributes.isSecure = PR_FALSE;
43113:   aCookieAttributes.isHttpOnly = PR_FALSE;
43113:   
43113:   nsDependentCSubstring tokenString(cookieStart, cookieStart);
43113:   nsDependentCSubstring tokenValue (cookieStart, cookieStart);
43113:   PRBool newCookie, equalsFound;
43113: 
43113:   // extract cookie <NAME> & <VALUE> (first attribute), and copy the strings.
43113:   // if we find multiple cookies, return for processing
43113:   // note: if there's no '=', we assume token is <VALUE>. this is required by
43113:   //       some sites (see bug 169091).
43113:   // XXX fix the parser to parse according to <VALUE> grammar for this case
43113:   newCookie = GetTokenValue(cookieStart, cookieEnd, tokenString, tokenValue, equalsFound);
43113:   if (equalsFound) {
43113:     aCookieAttributes.name = tokenString;
43113:     aCookieAttributes.value = tokenValue;
43113:   } else {
43113:     aCookieAttributes.value = tokenString;
43113:   }
43113: 
43113:   // extract remaining attributes
43113:   while (cookieStart != cookieEnd && !newCookie) {
43113:     newCookie = GetTokenValue(cookieStart, cookieEnd, tokenString, tokenValue, equalsFound);
43113: 
43113:     if (!tokenValue.IsEmpty()) {
43113:       tokenValue.BeginReading(tempBegin);
43113:       tokenValue.EndReading(tempEnd);
43113:     }
43113: 
43113:     // decide which attribute we have, and copy the string
43113:     if (tokenString.LowerCaseEqualsLiteral(kPath))
43113:       aCookieAttributes.path = tokenValue;
43113: 
43113:     else if (tokenString.LowerCaseEqualsLiteral(kDomain))
43113:       aCookieAttributes.host = tokenValue;
43113: 
43113:     else if (tokenString.LowerCaseEqualsLiteral(kExpires))
43113:       aCookieAttributes.expires = tokenValue;
43113: 
43113:     else if (tokenString.LowerCaseEqualsLiteral(kMaxage))
43113:       aCookieAttributes.maxage = tokenValue;
43113: 
43113:     // ignore any tokenValue for isSecure; just set the boolean
43113:     else if (tokenString.LowerCaseEqualsLiteral(kSecure))
43113:       aCookieAttributes.isSecure = PR_TRUE;
43113:       
43113:     // ignore any tokenValue for isHttpOnly (see bug 178993);
43113:     // just set the boolean
43113:     else if (tokenString.LowerCaseEqualsLiteral(kHttpOnly))
43113:       aCookieAttributes.isHttpOnly = PR_TRUE;
43113:   }
43113: 
43113:   // rebind aCookieHeader, in case we need to process another cookie
43113:   aCookieHeader.Rebind(cookieStart, cookieEnd);
43113:   return newCookie;
43113: }
43113: 
43113: /******************************************************************************
43113:  * nsCookieService impl:
43113:  * private domain & permission compliance enforcement functions
43113:  ******************************************************************************/
43113: 
43113: // Get the base domain for aHostURI; e.g. for "www.bbc.co.uk", this would be
43113: // "bbc.co.uk". Only properly-formed URI's are tolerated, though a trailing
59617: // dot may be present. If aHostURI is an IP address, an alias such as
59617: // 'localhost', an eTLD such as 'co.uk', or the empty string, aBaseDomain will
59617: // be the exact host, and aRequireHostMatch will be true to indicate that
59617: // substring matches should not be performed.
43113: nsresult
43113: nsCookieService::GetBaseDomain(nsIURI    *aHostURI,
43113:                                nsCString &aBaseDomain,
43113:                                PRBool    &aRequireHostMatch)
43113: {
43113:   // get the base domain. this will fail if the host contains a leading dot,
43113:   // more than one trailing dot, or is otherwise malformed.
43113:   nsresult rv = mTLDService->GetBaseDomain(aHostURI, 0, aBaseDomain);
43113:   aRequireHostMatch = rv == NS_ERROR_HOST_IS_IP_ADDRESS ||
43113:                       rv == NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS;
43113:   if (aRequireHostMatch) {
43113:     // aHostURI is either an IP address, an alias such as 'localhost', an eTLD
43113:     // such as 'co.uk', or the empty string. use the host as a key in such
43113:     // cases.
43113:     rv = aHostURI->GetAsciiHost(aBaseDomain);
43113:   }
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
59617:   // aHost (and thus aBaseDomain) may be the string '.'. If so, fail.
59617:   if (aBaseDomain.Length() == 1 && aBaseDomain.Last() == '.')
59617:     return NS_ERROR_INVALID_ARG;
43113: 
43113:   // block any URIs without a host that aren't file:// URIs.
43113:   if (aBaseDomain.IsEmpty()) {
43113:     PRBool isFileURI = PR_FALSE;
43113:     aHostURI->SchemeIs("file", &isFileURI);
43113:     if (!isFileURI)
43113:       return NS_ERROR_INVALID_ARG;
43113:   }
43113: 
43113:   return NS_OK;
43113: }
43113: 
43113: // Get the base domain for aHost; e.g. for "www.bbc.co.uk", this would be
43113: // "bbc.co.uk". This is done differently than GetBaseDomain(): it is assumed
43113: // that aHost is already normalized, and it may contain a leading dot
59617: // (indicating that it represents a domain). A trailing dot may be present.
43113: // If aHost is an IP address, an alias such as 'localhost', an eTLD such as
43113: // 'co.uk', or the empty string, aBaseDomain will be the exact host, and a
43113: // leading dot will be treated as an error.
43113: nsresult
43113: nsCookieService::GetBaseDomainFromHost(const nsACString &aHost,
43113:                                        nsCString        &aBaseDomain)
43113: {
59617:   // aHost must not be the string '.'.
59617:   if (aHost.Length() == 1 && aHost.Last() == '.')
43113:     return NS_ERROR_INVALID_ARG;
43113: 
43113:   // aHost may contain a leading dot; if so, strip it now.
63869:   PRBool domain = !aHost.IsEmpty() && aHost.First() == '.';
43113: 
43113:   // get the base domain. this will fail if the host contains a leading dot,
43113:   // more than one trailing dot, or is otherwise malformed.
63869:   nsresult rv = mTLDService->GetBaseDomainFromHost(Substring(aHost, domain), 0, aBaseDomain);
43113:   if (rv == NS_ERROR_HOST_IS_IP_ADDRESS ||
43113:       rv == NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS) {
43113:     // aHost is either an IP address, an alias such as 'localhost', an eTLD
43113:     // such as 'co.uk', or the empty string. use the host as a key in such
43113:     // cases; however, we reject any such hosts with a leading dot, since it
43113:     // doesn't make sense for them to be domain cookies.
43113:     if (domain)
43113:       return NS_ERROR_INVALID_ARG;
43113: 
63869:     aBaseDomain = aHost;
43113:     return NS_OK;
43113:   }
43113:   return rv;
43113: }
43113: 
43113: // Normalizes the given hostname, component by component. ASCII/ACE
43113: // components are lower-cased, and UTF-8 components are normalized per
59617: // RFC 3454 and converted to ACE.
43113: nsresult
43113: nsCookieService::NormalizeHost(nsCString &aHost)
43113: {
43113:   if (!IsASCII(aHost)) {
43113:     nsCAutoString host;
43113:     nsresult rv = mIDNService->ConvertUTF8toACE(aHost, host);
43113:     if (NS_FAILED(rv))
43113:       return rv;
43113: 
43113:     aHost = host;
43113:   }
43113: 
43113:   ToLowerCase(aHost);
43113:   return NS_OK;
43113: }
43113: 
43113: // returns PR_TRUE if 'a' is equal to or a subdomain of 'b',
59617: // assuming no leading dots are present.
43113: static inline PRBool IsSubdomainOf(const nsCString &a, const nsCString &b)
43113: {
43113:   if (a == b)
43113:     return PR_TRUE;
43113:   if (a.Length() > b.Length())
43113:     return a[a.Length() - b.Length() - 1] == '.' && StringEndsWith(a, b);
43113:   return PR_FALSE;
43113: }
43113: 
56094: bool
56094: nsCookieService::RequireThirdPartyCheck()
43113: {
56094:   // 'true' iff we need to perform a third party test.
56094:   return mCookieBehavior == BEHAVIOR_REJECTFOREIGN || mThirdPartySession;
46770: }
46770: 
43113: CookieStatus
43113: nsCookieService::CheckPrefs(nsIURI          *aHostURI,
56094:                             bool             aIsForeign,
43113:                             const nsCString &aBaseDomain,
43113:                             PRBool           aRequireHostMatch,
43113:                             const char      *aCookieHeader)
43113: {
43113:   nsresult rv;
43113: 
43113:   // don't let ftp sites get/set cookies (could be a security issue)
43113:   PRBool ftp;
43113:   if (NS_SUCCEEDED(aHostURI->SchemeIs("ftp", &ftp)) && ftp) {
43113:     COOKIE_LOGFAILURE(aCookieHeader ? SET_COOKIE : GET_COOKIE, aHostURI, aCookieHeader, "ftp sites cannot read cookies");
43113:     return STATUS_REJECTED_WITH_ERROR;
43113:   }
43113: 
43113:   // check the permission list first; if we find an entry, it overrides
43113:   // default prefs. see bug 184059.
43113:   if (mPermissionService) {
43113:     nsCookieAccess access;
46770:     // Not passing an nsIChannel here is probably OK; our implementation
46770:     // doesn't do anything with it anyway.
46770:     rv = mPermissionService->CanAccess(aHostURI, nsnull, &access);
43113: 
43113:     // if we found an entry, use it
43113:     if (NS_SUCCEEDED(rv)) {
43113:       switch (access) {
43113:       case nsICookiePermission::ACCESS_DENY:
43113:         COOKIE_LOGFAILURE(aCookieHeader ? SET_COOKIE : GET_COOKIE, aHostURI, aCookieHeader, "cookies are blocked for this site");
43113:         return STATUS_REJECTED;
43113: 
43113:       case nsICookiePermission::ACCESS_ALLOW:
43113:         return STATUS_ACCEPTED;
43113:       }
43113:     }
43113:   }
43113: 
43113:   // check default prefs
43113:   if (mCookieBehavior == BEHAVIOR_REJECT) {
43113:     COOKIE_LOGFAILURE(aCookieHeader ? SET_COOKIE : GET_COOKIE, aHostURI, aCookieHeader, "cookies are disabled");
43113:     return STATUS_REJECTED;
43113:   }
43113: 
56094:   if (RequireThirdPartyCheck() && aIsForeign) {
43113:     // check if cookie is foreign
43113:     if (mCookieBehavior == BEHAVIOR_ACCEPT && mThirdPartySession)
43113:       return STATUS_ACCEPT_SESSION;
43113: 
43113:     COOKIE_LOGFAILURE(aCookieHeader ? SET_COOKIE : GET_COOKIE, aHostURI, aCookieHeader, "context is third party");
43113:     return STATUS_REJECTED;
43113:   }
43113: 
43113:   // if nothing has complained, accept cookie
43113:   return STATUS_ACCEPTED;
43113: }
43113: 
43113: // processes domain attribute, and returns PR_TRUE if host has permission to set for this domain.
43113: PRBool
43113: nsCookieService::CheckDomain(nsCookieAttributes &aCookieAttributes,
43113:                              nsIURI             *aHostURI,
43113:                              const nsCString    &aBaseDomain,
43113:                              PRBool              aRequireHostMatch)
43113: {
43113:   // get host from aHostURI
43113:   nsCAutoString hostFromURI;
43113:   aHostURI->GetAsciiHost(hostFromURI);
43113: 
43113:   // if a domain is given, check the host has permission
43113:   if (!aCookieAttributes.host.IsEmpty()) {
59617:     // Tolerate leading '.' characters, but not if it's otherwise an empty host.
59617:     if (aCookieAttributes.host.Length() > 1 &&
59617:         aCookieAttributes.host.First() == '.') {
43113:       aCookieAttributes.host.Cut(0, 1);
59617:     }
43113: 
43113:     // switch to lowercase now, to avoid case-insensitive compares everywhere
43113:     ToLowerCase(aCookieAttributes.host);
43113: 
43113:     // check whether the host is either an IP address, an alias such as
43113:     // 'localhost', an eTLD such as 'co.uk', or the empty string. in these
43113:     // cases, require an exact string match for the domain, and leave the cookie
43113:     // as a non-domain one. bug 105917 originally noted the requirement to deal
43113:     // with IP addresses.
43113:     if (aRequireHostMatch)
43113:       return hostFromURI.Equals(aCookieAttributes.host);
43113: 
43113:     // ensure the proposed domain is derived from the base domain; and also
43113:     // that the host domain is derived from the proposed domain (per RFC2109).
43113:     if (IsSubdomainOf(aCookieAttributes.host, aBaseDomain) &&
43113:         IsSubdomainOf(hostFromURI, aCookieAttributes.host)) {
43113:       // prepend a dot to indicate a domain cookie
43113:       aCookieAttributes.host.Insert(NS_LITERAL_CSTRING("."), 0);
43113:       return PR_TRUE;
43113:     }
43113: 
43113:     /*
43113:      * note: RFC2109 section 4.3.2 requires that we check the following:
43113:      * that the portion of host not in domain does not contain a dot.
43113:      * this prevents hosts of the form x.y.co.nz from setting cookies in the
43113:      * entire .co.nz domain. however, it's only a only a partial solution and
43113:      * it breaks sites (IE doesn't enforce it), so we don't perform this check.
43113:      */
43113:     return PR_FALSE;
43113:   }
43113: 
43113:   // no domain specified, use hostFromURI
43113:   aCookieAttributes.host = hostFromURI;
43113:   return PR_TRUE;
43113: }
43113: 
43113: PRBool
43113: nsCookieService::CheckPath(nsCookieAttributes &aCookieAttributes,
43113:                            nsIURI             *aHostURI)
43113: {
43113:   // if a path is given, check the host has permission
43113:   if (aCookieAttributes.path.IsEmpty()) {
43113:     // strip down everything after the last slash to get the path,
43113:     // ignoring slashes in the query string part.
43113:     // if we can QI to nsIURL, that'll take care of the query string portion.
43113:     // otherwise, it's not an nsIURL and can't have a query string, so just find the last slash.
43113:     nsCOMPtr<nsIURL> hostURL = do_QueryInterface(aHostURI);
43113:     if (hostURL) {
43113:       hostURL->GetDirectory(aCookieAttributes.path);
43113:     } else {
43113:       aHostURI->GetPath(aCookieAttributes.path);
43113:       PRInt32 slash = aCookieAttributes.path.RFindChar('/');
43113:       if (slash != kNotFound) {
43113:         aCookieAttributes.path.Truncate(slash + 1);
43113:       }
43113:     }
43113: 
43113: #if 0
43113:   } else {
43113:     /**
43113:      * The following test is part of the RFC2109 spec.  Loosely speaking, it says that a site
43113:      * cannot set a cookie for a path that it is not on.  See bug 155083.  However this patch
43113:      * broke several sites -- nordea (bug 155768) and citibank (bug 156725).  So this test has
43113:      * been disabled, unless we can evangelize these sites.
43113:      */
43113:     // get path from aHostURI
43113:     nsCAutoString pathFromURI;
43113:     if (NS_FAILED(aHostURI->GetPath(pathFromURI)) ||
43113:         !StringBeginsWith(pathFromURI, aCookieAttributes.path)) {
43113:       return PR_FALSE;
43113:     }
43113: #endif
43113:   }
43113: 
43113:   if (aCookieAttributes.path.Length() > kMaxBytesPerPath ||
43113:       aCookieAttributes.path.FindChar('\t') != kNotFound )
43113:     return PR_FALSE;
43113: 
43113:   return PR_TRUE;
43113: }
43113: 
43113: PRBool
43113: nsCookieService::GetExpiry(nsCookieAttributes &aCookieAttributes,
43113:                            PRInt64             aServerTime,
43113:                            PRInt64             aCurrentTime)
43113: {
43113:   /* Determine when the cookie should expire. This is done by taking the difference between 
43113:    * the server time and the time the server wants the cookie to expire, and adding that 
43113:    * difference to the client time. This localizes the client time regardless of whether or
43113:    * not the TZ environment variable was set on the client.
43113:    *
43113:    * Note: We need to consider accounting for network lag here, per RFC.
43113:    */
43113:   PRInt64 delta;
43113: 
43113:   // check for max-age attribute first; this overrides expires attribute
43113:   if (!aCookieAttributes.maxage.IsEmpty()) {
43113:     // obtain numeric value of maxageAttribute
43113:     PRInt64 maxage;
43113:     PRInt32 numInts = PR_sscanf(aCookieAttributes.maxage.get(), "%lld", &maxage);
43113: 
43113:     // default to session cookie if the conversion failed
43113:     if (numInts != 1) {
43113:       return PR_TRUE;
43113:     }
43113: 
43113:     delta = maxage;
43113: 
43113:   // check for expires attribute
43113:   } else if (!aCookieAttributes.expires.IsEmpty()) {
43113:     PRTime expires;
43113: 
43113:     // parse expiry time
43113:     if (PR_ParseTimeString(aCookieAttributes.expires.get(), PR_TRUE, &expires) != PR_SUCCESS) {
43113:       return PR_TRUE;
43113:     }
43113: 
43113:     delta = expires / PR_USEC_PER_SEC - aServerTime;
43113: 
43113:   // default to session cookie if no attributes found
43113:   } else {
43113:     return PR_TRUE;
43113:   }
43113: 
43113:   // if this addition overflows, expiryTime will be less than currentTime
43113:   // and the cookie will be expired - that's okay.
43113:   aCookieAttributes.expiryTime = aCurrentTime + delta;
43113: 
43113:   return PR_FALSE;
43113: }
43113: 
43113: /******************************************************************************
43113:  * nsCookieService impl:
43113:  * private cookielist management functions
43113:  ******************************************************************************/
43113: 
43113: void
43113: nsCookieService::RemoveAllFromMemory()
43113: {
43113:   // clearing the hashtable will call each nsCookieEntry's dtor,
43113:   // which releases all their respective children.
43113:   mDBState->hostTable.Clear();
43113:   mDBState->cookieCount = 0;
43113:   mDBState->cookieOldestTime = LL_MAXINT;
43113: }
43113: 
43113: // stores temporary data for enumerating over the hash entries,
43113: // since enumeration is done using callback functions
43113: struct nsPurgeData
43113: {
43113:   typedef nsTArray<nsListIter> ArrayType;
43113: 
43113:   nsPurgeData(PRInt64 aCurrentTime,
43113:               PRInt64 aPurgeTime,
43113:               ArrayType &aPurgeList,
43113:               nsIMutableArray *aRemovedList,
43113:               mozIStorageBindingParamsArray *aParamsArray)
43113:    : currentTime(aCurrentTime)
43113:    , purgeTime(aPurgeTime)
43113:    , oldestTime(LL_MAXINT)
43113:    , purgeList(aPurgeList)
43113:    , removedList(aRemovedList)
43113:    , paramsArray(aParamsArray)
43113:   {
43113:   }
43113: 
43113:   // the current time, in seconds
43113:   PRInt64 currentTime;
43113: 
43113:   // lastAccessed time older than which cookies are eligible for purge
43113:   PRInt64 purgeTime;
43113: 
43113:   // lastAccessed time of the oldest cookie found during purge, to update our indicator
43113:   PRInt64 oldestTime;
43113: 
43113:   // list of cookies over the age limit, for purging
43113:   ArrayType &purgeList;
43113: 
43113:   // list of all cookies we've removed, for notification
43113:   nsIMutableArray *removedList;
43113: 
43113:   // The array of parameters to be bound to the statement for deletion later.
43113:   mozIStorageBindingParamsArray *paramsArray;
43113: };
43113: 
43113: // comparator class for lastaccessed times of cookies.
43113: class CompareCookiesByAge {
43113: public:
43113:   PRBool Equals(const nsListIter &a, const nsListIter &b) const
43113:   {
56146:     return a.Cookie()->LastAccessed() == b.Cookie()->LastAccessed() &&
56146:            a.Cookie()->CreationTime() == b.Cookie()->CreationTime();
43113:   }
43113: 
43113:   PRBool LessThan(const nsListIter &a, const nsListIter &b) const
43113:   {
56146:     // compare by lastAccessed time, and tiebreak by creationTime.
43113:     PRInt64 result = a.Cookie()->LastAccessed() - b.Cookie()->LastAccessed();
43113:     if (result != 0)
43113:       return result < 0;
43113: 
56146:     return a.Cookie()->CreationTime() < b.Cookie()->CreationTime();
43113:   }
43113: };
43113: 
43113: // comparator class for sorting cookies by entry and index.
43113: class CompareCookiesByIndex {
43113: public:
43113:   PRBool Equals(const nsListIter &a, const nsListIter &b) const
43113:   {
57258:     NS_ASSERTION(a.entry != b.entry || a.index != b.index,
57258:       "cookie indexes should never be equal");
43113:     return PR_FALSE;
43113:   }
43113: 
43113:   PRBool LessThan(const nsListIter &a, const nsListIter &b) const
43113:   {
43113:     // compare by entryclass pointer, then by index.
43113:     if (a.entry != b.entry)
43113:       return a.entry < b.entry;
43113: 
43113:     return a.index < b.index;
43113:   }
43113: };
43113: 
43113: PLDHashOperator
43113: purgeCookiesCallback(nsCookieEntry *aEntry,
43113:                      void          *aArg)
43113: {
43113:   nsPurgeData &data = *static_cast<nsPurgeData*>(aArg);
43113: 
43113:   const nsCookieEntry::ArrayType &cookies = aEntry->GetCookies();
43113:   mozIStorageBindingParamsArray *array = data.paramsArray;
43113:   for (nsCookieEntry::IndexType i = 0; i < cookies.Length(); ) {
43113:     nsListIter iter(aEntry, i);
43113:     nsCookie *cookie = cookies[i];
43113: 
43113:     // check if the cookie has expired
43113:     if (cookie->Expiry() <= data.currentTime) {
43113:       data.removedList->AppendElement(cookie, PR_FALSE);
51398:       COOKIE_LOGEVICTED(cookie, "Cookie expired");
43113: 
43113:       // remove from list; do not increment our iterator
46770:       gCookieService->RemoveCookieFromList(iter, array);
43113: 
43113:     } else {
43113:       // check if the cookie is over the age limit
43113:       if (cookie->LastAccessed() <= data.purgeTime) {
43113:         data.purgeList.AppendElement(iter);
43113: 
43113:       } else if (cookie->LastAccessed() < data.oldestTime) {
43113:         // reset our indicator
43113:         data.oldestTime = cookie->LastAccessed();
43113:       }
43113: 
43113:       ++i;
43113:     }
43113:   }
43113:   return PL_DHASH_NEXT;
43113: }
43113: 
43113: // purges expired and old cookies in a batch operation.
57409: already_AddRefed<nsIArray>
43113: nsCookieService::PurgeCookies(PRInt64 aCurrentTimeInUsec)
43113: {
43113:   NS_ASSERTION(mDBState->hostTable.Count() > 0, "table is empty");
57409:   EnsureReadComplete();
57409: 
43113: #ifdef PR_LOGGING
43113:   PRUint32 initialCookieCount = mDBState->cookieCount;
43113:   COOKIE_LOGSTRING(PR_LOG_DEBUG,
56147:     ("PurgeCookies(): beginning purge with %ld cookies and %lld oldest age",
43113:      mDBState->cookieCount, aCurrentTimeInUsec - mDBState->cookieOldestTime));
43113: #endif
43113: 
43113:   nsAutoTArray<nsListIter, kMaxNumberOfCookies> purgeList;
43113: 
43113:   nsCOMPtr<nsIMutableArray> removedList = do_CreateInstance(NS_ARRAY_CONTRACTID);
43113: 
43113:   // Create a params array to batch the removals. This is OK here because
43113:   // all the removals are in order, and there are no interleaved additions.
57405:   mozIStorageAsyncStatement *stmt = mDBState->stmtDelete;
43113:   nsCOMPtr<mozIStorageBindingParamsArray> paramsArray;
43113:   if (mDBState->dbConn) {
43113:     stmt->NewBindingParamsArray(getter_AddRefs(paramsArray));
43113:   }
43113: 
43113:   nsPurgeData data(aCurrentTimeInUsec / PR_USEC_PER_SEC,
43113:     aCurrentTimeInUsec - mCookiePurgeAge, purgeList, removedList, paramsArray);
43113:   mDBState->hostTable.EnumerateEntries(purgeCookiesCallback, &data);
43113: 
43113: #ifdef PR_LOGGING
43113:   PRUint32 postExpiryCookieCount = mDBState->cookieCount;
43113: #endif
43113: 
43113:   // now we have a list of iterators for cookies over the age limit.
43113:   // sort them by age, and then we'll see how many to remove...
43113:   purgeList.Sort(CompareCookiesByAge());
43113: 
43113:   // only remove old cookies until we reach the max cookie limit, no more.
57258:   PRUint32 excess = mDBState->cookieCount > mMaxNumberOfCookies ?
57258:     mDBState->cookieCount - mMaxNumberOfCookies : 0;
43113:   if (purgeList.Length() > excess) {
57258:     // We're not purging everything in the list, so update our indicator.
43113:     data.oldestTime = purgeList[excess].Cookie()->LastAccessed();
43113: 
43113:     purgeList.SetLength(excess);
43113:   }
43113: 
43113:   // sort the list again, this time grouping cookies with a common entryclass
43113:   // together, and with ascending index. this allows us to iterate backwards
43113:   // over the list removing cookies, without having to adjust indexes as we go.
43113:   purgeList.Sort(CompareCookiesByIndex());
43113:   for (nsPurgeData::ArrayType::index_type i = purgeList.Length(); i--; ) {
43113:     nsCookie *cookie = purgeList[i].Cookie();
43113:     removedList->AppendElement(cookie, PR_FALSE);
56147:     COOKIE_LOGEVICTED(cookie, "Cookie too old");
43113: 
43113:     RemoveCookieFromList(purgeList[i], paramsArray);
43113:   }
43113: 
43113:   // Update the database if we have entries to purge.
43113:   if (paramsArray) {
43113:     PRUint32 length;
43113:     paramsArray->GetLength(&length);
43113:     if (length) {
43113:       nsresult rv = stmt->BindParameters(paramsArray);
43113:       NS_ASSERT_SUCCESS(rv);
43113:       nsCOMPtr<mozIStoragePendingStatement> handle;
57405:       rv = stmt->ExecuteAsync(mDBState->removeListener, getter_AddRefs(handle));
43113:       NS_ASSERT_SUCCESS(rv);
43113:     }
43113:   }
43113: 
43113:   // reset the oldest time indicator
43113:   mDBState->cookieOldestTime = data.oldestTime;
43113: 
43113:   COOKIE_LOGSTRING(PR_LOG_DEBUG,
43113:     ("PurgeCookies(): %ld expired; %ld purged; %ld remain; %lld oldest age",
43113:      initialCookieCount - postExpiryCookieCount,
56147:      postExpiryCookieCount - mDBState->cookieCount,
43113:      mDBState->cookieCount,
43113:      aCurrentTimeInUsec - mDBState->cookieOldestTime));
57409: 
57409:   return removedList.forget();
43113: }
43113: 
43113: // find whether a given cookie has been previously set. this is provided by the
43113: // nsICookieManager2 interface.
43113: NS_IMETHODIMP
43113: nsCookieService::CookieExists(nsICookie2 *aCookie,
43113:                               PRBool     *aFoundCookie)
43113: {
43113:   NS_ENSURE_ARG_POINTER(aCookie);
43113: 
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return NS_ERROR_NOT_AVAILABLE;
58006:   }
58006: 
43113:   nsCAutoString host, name, path;
43113:   nsresult rv = aCookie->GetHost(host);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113:   rv = aCookie->GetName(name);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113:   rv = aCookie->GetPath(path);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   nsCAutoString baseDomain;
43113:   rv = GetBaseDomainFromHost(host, baseDomain);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   nsListIter iter;
56146:   *aFoundCookie = FindCookie(baseDomain, host, name, path, iter);
43113:   return NS_OK;
43113: }
43113: 
56149: // For a given base domain, find either an expired cookie or the oldest cookie
56149: // by lastAccessed time.
56149: void
56149: nsCookieService::FindStaleCookie(nsCookieEntry *aEntry,
56149:                                  PRInt64 aCurrentTime,
56149:                                  nsListIter &aIter)
43113: {
56149:   aIter.entry = NULL;
56149: 
56149:   PRInt64 oldestTime;
56149:   const nsCookieEntry::ArrayType &cookies = aEntry->GetCookies();
43113:   for (nsCookieEntry::IndexType i = 0; i < cookies.Length(); ++i) {
43113:     nsCookie *cookie = cookies[i];
43113: 
56149:     // If we found an expired cookie, we're done.
57258:     if (cookie->Expiry() <= aCurrentTime) {
56149:       aIter.entry = aEntry;
56149:       aIter.index = i;
56149:       return;
43113:     }
56149: 
56149:     // Check if we've found the oldest cookie so far.
56149:     if (!aIter.entry || oldestTime > cookie->LastAccessed()) {
56149:       oldestTime = cookie->LastAccessed();
56149:       aIter.entry = aEntry;
56149:       aIter.index = i;
43113:     }
43113:   }
43113: }
43113: 
43113: // count the number of cookies stored by a particular host. this is provided by the
43113: // nsICookieManager2 interface.
43113: NS_IMETHODIMP
43113: nsCookieService::CountCookiesFromHost(const nsACString &aHost,
43113:                                       PRUint32         *aCountFromHost)
43113: {
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return NS_ERROR_NOT_AVAILABLE;
58006:   }
58006: 
43113:   // first, normalize the hostname, and fail if it contains illegal characters.
43113:   nsCAutoString host(aHost);
43113:   nsresult rv = NormalizeHost(host);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   nsCAutoString baseDomain;
43113:   rv = GetBaseDomainFromHost(host, baseDomain);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
56149:   EnsureReadDomain(baseDomain);
56149: 
56149:   // Return a count of all cookies, including expired.
56149:   nsCookieEntry *entry = mDBState->hostTable.GetEntry(baseDomain);
56149:   *aCountFromHost = entry ? entry->GetCookies().Length() : 0;
43113:   return NS_OK;
43113: }
43113: 
43113: // get an enumerator of cookies stored by a particular host. this is provided by the
43113: // nsICookieManager2 interface.
43113: NS_IMETHODIMP
43113: nsCookieService::GetCookiesFromHost(const nsACString     &aHost,
43113:                                     nsISimpleEnumerator **aEnumerator)
43113: {
58006:   if (!mDBState) {
58006:     NS_WARNING("No DBState! Profile already closed?");
58006:     return NS_ERROR_NOT_AVAILABLE;
58006:   }
58006: 
43113:   // first, normalize the hostname, and fail if it contains illegal characters.
43113:   nsCAutoString host(aHost);
43113:   nsresult rv = NormalizeHost(host);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:   nsCAutoString baseDomain;
43113:   rv = GetBaseDomainFromHost(host, baseDomain);
43113:   NS_ENSURE_SUCCESS(rv, rv);
43113: 
48744:   EnsureReadDomain(baseDomain);
48744: 
43113:   nsCookieEntry *entry = mDBState->hostTable.GetEntry(baseDomain);
43113:   if (!entry)
43113:     return NS_NewEmptyEnumerator(aEnumerator);
43113: 
56149:   nsCOMArray<nsICookie> cookieList(mMaxCookiesPerHost);
43113:   const nsCookieEntry::ArrayType &cookies = entry->GetCookies();
43113:   for (nsCookieEntry::IndexType i = 0; i < cookies.Length(); ++i) {
56149:     cookieList.AppendObject(cookies[i]);
43113:   }
43113: 
43113:   return NS_NewArrayEnumerator(aEnumerator, cookieList);
43113: }
43113: 
43113: // find an exact cookie specified by host, name, and path that hasn't expired.
43113: PRBool
43113: nsCookieService::FindCookie(const nsCString      &aBaseDomain,
43113:                             const nsAFlatCString &aHost,
43113:                             const nsAFlatCString &aName,
43113:                             const nsAFlatCString &aPath,
56146:                             nsListIter           &aIter)
43113: {
48744:   EnsureReadDomain(aBaseDomain);
48744: 
43113:   nsCookieEntry *entry = mDBState->hostTable.GetEntry(aBaseDomain);
43113:   if (!entry)
43113:     return PR_FALSE;
43113: 
43113:   const nsCookieEntry::ArrayType &cookies = entry->GetCookies();
43113:   for (nsCookieEntry::IndexType i = 0; i < cookies.Length(); ++i) {
43113:     nsCookie *cookie = cookies[i];
43113: 
56146:     if (aHost.Equals(cookie->Host()) &&
43113:         aPath.Equals(cookie->Path()) &&
43113:         aName.Equals(cookie->Name())) {
43113:       aIter = nsListIter(entry, i);
43113:       return PR_TRUE;
43113:     }
43113:   }
43113: 
43113:   return PR_FALSE;
43113: }
43113: 
43113: // remove a cookie from the hashtable, and update the iterator state.
43113: void
43113: nsCookieService::RemoveCookieFromList(const nsListIter              &aIter,
43113:                                       mozIStorageBindingParamsArray *aParamsArray)
43113: {
43113:   // if it's a non-session cookie, remove it from the db
43113:   if (!aIter.Cookie()->IsSession() && mDBState->dbConn) {
43113:     // Use the asynchronous binding methods to ensure that we do not acquire
43113:     // the database lock.
57405:     mozIStorageAsyncStatement *stmt = mDBState->stmtDelete;
43113:     nsCOMPtr<mozIStorageBindingParamsArray> paramsArray(aParamsArray);
43113:     if (!paramsArray) {
43113:       stmt->NewBindingParamsArray(getter_AddRefs(paramsArray));
43113:     }
43113: 
43113:     nsCOMPtr<mozIStorageBindingParams> params;
43113:     paramsArray->NewBindingParams(getter_AddRefs(params));
43113: 
56146:     nsresult rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("name"),
56146:                                                aIter.Cookie()->Name());
56146:     NS_ASSERT_SUCCESS(rv);
56146: 
56146:     rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("host"),
56146:                                       aIter.Cookie()->Host());
56146:     NS_ASSERT_SUCCESS(rv);
56146: 
56146:     rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("path"),
56146:                                       aIter.Cookie()->Path());
43113:     NS_ASSERT_SUCCESS(rv);
43113: 
43113:     rv = paramsArray->AddParams(params);
43113:     NS_ASSERT_SUCCESS(rv);
43113: 
43113:     // If we weren't given a params array, we'll need to remove it ourselves.
43113:     if (!aParamsArray) {
43113:       rv = stmt->BindParameters(paramsArray);
43113:       NS_ASSERT_SUCCESS(rv);
43113:       nsCOMPtr<mozIStoragePendingStatement> handle;
57405:       rv = stmt->ExecuteAsync(mDBState->removeListener, getter_AddRefs(handle));
43113:       NS_ASSERT_SUCCESS(rv);
43113:     }
43113:   }
43113: 
43113:   if (aIter.entry->GetCookies().Length() == 1) {
43113:     // we're removing the last element in the array - so just remove the entry
43113:     // from the hash. note that the entryclass' dtor will take care of
43113:     // releasing this last element for us!
43113:     mDBState->hostTable.RawRemoveEntry(aIter.entry);
43113: 
43113:   } else {
43113:     // just remove the element from the list
43113:     aIter.entry->GetCookies().RemoveElementAt(aIter.index);
43113:   }
43113: 
43113:   --mDBState->cookieCount;
43113: }
43113: 
57410: void
43113: bindCookieParameters(mozIStorageBindingParamsArray *aParamsArray,
48370:                      const nsCString &aBaseDomain,
43113:                      const nsCookie *aCookie)
43113: {
43113:   NS_ASSERTION(aParamsArray, "Null params array passed to bindCookieParameters!");
43113:   NS_ASSERTION(aCookie, "Null cookie passed to bindCookieParameters!");
43113:   nsresult rv;
43113: 
43113:   // Use the asynchronous binding methods to ensure that we do not acquire the
43113:   // database lock.
43113:   nsCOMPtr<mozIStorageBindingParams> params;
43113:   rv = aParamsArray->NewBindingParams(getter_AddRefs(params));
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
43113:   // Bind our values to params
56146:   rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("baseDomain"),
56146:                                     aBaseDomain);
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
56146:   rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("name"),
56146:                                     aCookie->Name());
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
56146:   rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("value"),
56146:                                     aCookie->Value());
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
56146:   rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("host"),
56146:                                     aCookie->Host());
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
56146:   rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("path"),
56146:                                     aCookie->Path());
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
56146:   rv = params->BindInt64ByName(NS_LITERAL_CSTRING("expiry"),
56146:                                aCookie->Expiry());
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
56146:   rv = params->BindInt64ByName(NS_LITERAL_CSTRING("lastAccessed"),
56146:                                aCookie->LastAccessed());
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
56146:   rv = params->BindInt64ByName(NS_LITERAL_CSTRING("creationTime"),
56146:                                aCookie->CreationTime());
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
56146:   rv = params->BindInt32ByName(NS_LITERAL_CSTRING("isSecure"),
56146:                                aCookie->IsSecure());
48370:   NS_ASSERT_SUCCESS(rv);
48370: 
56146:   rv = params->BindInt32ByName(NS_LITERAL_CSTRING("isHttpOnly"),
56146:                                aCookie->IsHttpOnly());
43113:   NS_ASSERT_SUCCESS(rv);
43113: 
43113:   // Bind the params to the array.
43113:   rv = aParamsArray->AddParams(params);
43113:   NS_ASSERT_SUCCESS(rv);
43113: }
43113: 
48743: void
43113: nsCookieService::AddCookieToList(const nsCString               &aBaseDomain,
43113:                                  nsCookie                      *aCookie,
56145:                                  DBState                       *aDBState,
43113:                                  mozIStorageBindingParamsArray *aParamsArray,
43113:                                  PRBool                         aWriteToDB)
43113: {
56145:   NS_ASSERTION(!(aDBState->dbConn && !aWriteToDB && aParamsArray),
43113:                "Not writing to the DB but have a params array?");
56145:   NS_ASSERTION(!(!aDBState->dbConn && aParamsArray),
43113:                "Do not have a DB connection but have a params array?");
43113: 
56145:   nsCookieEntry *entry = aDBState->hostTable.PutEntry(aBaseDomain);
48743:   NS_ASSERTION(entry, "can't insert element into a null entry!");
43113: 
43113:   entry->GetCookies().AppendElement(aCookie);
56145:   ++aDBState->cookieCount;
43113: 
43113:   // keep track of the oldest cookie, for when it comes time to purge
56145:   if (aCookie->LastAccessed() < aDBState->cookieOldestTime)
56145:     aDBState->cookieOldestTime = aCookie->LastAccessed();
43113: 
43113:   // if it's a non-session cookie and hasn't just been read from the db, write it out.
56145:   if (aWriteToDB && !aCookie->IsSession() && aDBState->dbConn) {
57405:     mozIStorageAsyncStatement *stmt = aDBState->stmtInsert;
43113:     nsCOMPtr<mozIStorageBindingParamsArray> paramsArray(aParamsArray);
43113:     if (!paramsArray) {
43113:       stmt->NewBindingParamsArray(getter_AddRefs(paramsArray));
43113:     }
48370:     bindCookieParameters(paramsArray, aBaseDomain, aCookie);
43113: 
43113:     // If we were supplied an array to store parameters, we shouldn't call
43113:     // executeAsync - someone up the stack will do this for us.
43113:     if (!aParamsArray) {
43113:       nsresult rv = stmt->BindParameters(paramsArray);
43113:       NS_ASSERT_SUCCESS(rv);
43113:       nsCOMPtr<mozIStoragePendingStatement> handle;
57405:       rv = stmt->ExecuteAsync(mDBState->insertListener, getter_AddRefs(handle));
43113:       NS_ASSERT_SUCCESS(rv);
43113:     }
43113:   }
43113: }
43113: 
43113: void
43113: nsCookieService::UpdateCookieInList(nsCookie                      *aCookie,
43113:                                     PRInt64                        aLastAccessed,
43113:                                     mozIStorageBindingParamsArray *aParamsArray)
43113: {
43113:   NS_ASSERTION(aCookie, "Passing a null cookie to UpdateCookieInList!");
43113: 
43113:   // udpate the lastAccessed timestamp
43113:   aCookie->SetLastAccessed(aLastAccessed);
43113: 
43113:   // if it's a non-session cookie, update it in the db too
43113:   if (!aCookie->IsSession() && aParamsArray) {
43113:     // Create our params holder.
43113:     nsCOMPtr<mozIStorageBindingParams> params;
43113:     aParamsArray->NewBindingParams(getter_AddRefs(params));
43113: 
43113:     // Bind our parameters.
56146:     nsresult rv = params->BindInt64ByName(NS_LITERAL_CSTRING("lastAccessed"),
56146:                                           aLastAccessed);
43113:     NS_ASSERT_SUCCESS(rv);
56146: 
56146:     rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("name"),
56146:                                       aCookie->Name());
56146:     NS_ASSERT_SUCCESS(rv);
56146: 
56146:     rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("host"),
56146:                                       aCookie->Host());
56146:     NS_ASSERT_SUCCESS(rv);
56146: 
56146:     rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("path"),
56146:                                       aCookie->Path());
43113:     NS_ASSERT_SUCCESS(rv);
43113: 
43113:     // Add our bound parameters to the array.
43113:     rv = aParamsArray->AddParams(params);
43113:     NS_ASSERT_SUCCESS(rv);
43113:   }
43113: }
57406: 
