    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla SVG project.
    1:  *
    1:  * The Initial Developer of the Original Code is IBM Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsPresContext.h"
    1: #include "nsSVGUtils.h"
    1: #include "nsSVGGeometryFrame.h"
    1: #include "nsSVGPaintServerFrame.h"
    1: #include "nsContentUtils.h"
    1: #include "gfxContext.h"
19948: #include "nsSVGEffects.h"
    1: 
    1: //----------------------------------------------------------------------
 3557: // nsIFrame methods
    1: 
 3557: NS_IMETHODIMP
 3557: nsSVGGeometryFrame::Init(nsIContent* aContent,
 3557:                          nsIFrame* aParent,
 3557:                          nsIFrame* aPrevInFlow)
 3557: {
19125:   AddStateBits((aParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD) |
19125:                NS_STATE_SVG_PROPAGATE_TRANSFORM);
 5468:   nsresult rv = nsSVGGeometryFrameBase::Init(aContent, aParent, aPrevInFlow);
 5468:   return rv;
 3557: }
 3557: 
 3557: //----------------------------------------------------------------------
 3557: 
    1: nsSVGPaintServerFrame *
19948: nsSVGGeometryFrame::GetPaintServer(const nsStyleSVGPaint *aPaint,
19948:                                    nsIAtom *aType)
    1: {
    1:   if (aPaint->mType != eStyleSVGPaintType_Server)
    1:     return nsnull;
    1: 
19948:   nsSVGPaintingProperty *property =
19948:     nsSVGEffects::GetPaintingProperty(aPaint->mPaint.mPaintServer, this, aType);
19948:   if (!property)
    1:     return nsnull;
19948:   nsIFrame *result = property->GetReferencedFrame();
19948:   if (!result)
    1:     return nsnull;
    1: 
    1:   nsIAtom *type = result->GetType();
    1:   if (type != nsGkAtoms::svgLinearGradientFrame &&
    1:       type != nsGkAtoms::svgRadialGradientFrame &&
    1:       type != nsGkAtoms::svgPatternFrame)
    1:     return nsnull;
    1: 
19948:   return static_cast<nsSVGPaintServerFrame*>(result);
    1: }
    1: 
    1: float
    1: nsSVGGeometryFrame::GetStrokeWidth()
    1: {
 3233:   nsSVGElement *ctx = static_cast<nsSVGElement*>
 3233:                                  (GetType() == nsGkAtoms::svgGlyphFrame ?
    1:                                      mContent->GetParent() : mContent);
    1: 
    1:   return
  238:     nsSVGUtils::CoordToFloat(PresContext(),
    1:                              ctx,
    1:                              GetStyleSVG()->mStrokeWidth);
    1: }
    1: 
    1: nsresult
    1: nsSVGGeometryFrame::GetStrokeDashArray(gfxFloat **aDashes, PRUint32 *aCount)
    1: {
21697:   nsSVGElement *ctx = static_cast<nsSVGElement*>
21697:                                  (GetType() == nsGkAtoms::svgGlyphFrame ?
21697:                                      mContent->GetParent() : mContent);
    1:   *aDashes = nsnull;
    1:   *aCount = 0;
    1: 
    1:   PRUint32 count = GetStyleSVG()->mStrokeDasharrayLength;
    1:   gfxFloat *dashes = nsnull;
    1: 
    1:   if (count) {
    1:     const nsStyleCoord *dasharray = GetStyleSVG()->mStrokeDasharray;
  238:     nsPresContext *presContext = PresContext();
    1:     gfxFloat totalLength = 0.0f;
    1: 
    1:     dashes = new gfxFloat[count];
    1:     if (dashes) {
    1:       for (PRUint32 i = 0; i < count; i++) {
    1:         dashes[i] =
    1:           nsSVGUtils::CoordToFloat(presContext,
21697:                                    ctx,
    1:                                    dasharray[i]);
    1:         if (dashes[i] < 0.0f) {
    1:           delete [] dashes;
    1:           return NS_OK;
    1:         }
    1:         totalLength += dashes[i];
    1:       }
    1:     } else {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (totalLength == 0.0f) {
    1:       delete [] dashes;
    1:       return NS_OK;
    1:     }
    1: 
    1:     *aDashes = dashes;
    1:     *aCount = count;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: float
    1: nsSVGGeometryFrame::GetStrokeDashoffset()
    1: {
21697:   nsSVGElement *ctx = static_cast<nsSVGElement*>
21697:                                  (GetType() == nsGkAtoms::svgGlyphFrame ?
21697:                                      mContent->GetParent() : mContent);
21697: 
    1:   return
  238:     nsSVGUtils::CoordToFloat(PresContext(),
21697:                              ctx,
    1:                              GetStyleSVG()->mStrokeDashoffset);
    1: }
    1: 
    1: PRUint16
    1: nsSVGGeometryFrame::GetClipRule()
    1: {
    1:   return GetStyleSVG()->mClipRule;
    1: }
    1: 
    1: PRBool
    1: nsSVGGeometryFrame::IsClipChild()
    1: {
    1:   nsIContent *node = mContent;
    1: 
    1:   do {
    1:     // Return false if we find a non-svg ancestor. Non-SVG elements are not
    1:     // allowed inside an SVG clipPath element.
    1:     if (node->GetNameSpaceID() != kNameSpaceID_SVG) {
    1:       break;
    1:     }
    1:     if (node->NodeInfo()->Equals(nsGkAtoms::clipPath, kNameSpaceID_SVG)) {
    1:       return PR_TRUE;
    1:     }
    1:     node = node->GetParent();
    1:   } while (node);
    1:     
    1:   return PR_FALSE;
    1: }
    1: 
    1: static void
    1: SetupCairoColor(gfxContext *aContext, nscolor aRGB, float aOpacity)
    1: {
    1:   aContext->SetColor(gfxRGBA(NS_GET_R(aRGB)/255.0,
    1:                              NS_GET_G(aRGB)/255.0,
    1:                              NS_GET_B(aRGB)/255.0,
    1:                              NS_GET_A(aRGB)/255.0 * aOpacity));
    1: }
    1: 
    1: float
    1: nsSVGGeometryFrame::MaybeOptimizeOpacity(float aOpacity)
    1: {
    1:   if (nsSVGUtils::CanOptimizeOpacity(this)) {
    1:     aOpacity *= GetStyleDisplay()->mOpacity;
    1:   }
    1:   return aOpacity;
    1: }
    1: 
  725: PRBool
 7077: nsSVGGeometryFrame::SetupCairoFill(gfxContext *aContext)
    1: {
20085:   const nsStyleSVG* style = GetStyleSVG();
20085:   if (style->mFill.mType == eStyleSVGPaintType_None)
20085:     return PR_FALSE;
20085: 
20085:   if (style->mFillRule == NS_STYLE_FILL_RULE_EVENODD)
    1:     aContext->SetFillRule(gfxContext::FILL_RULE_EVEN_ODD);
    1:   else
    1:     aContext->SetFillRule(gfxContext::FILL_RULE_WINDING);
    1: 
20085:   float opacity = MaybeOptimizeOpacity(style->mFillOpacity);
    1: 
19948:   nsSVGPaintServerFrame *ps =
20085:     GetPaintServer(&style->mFill, nsGkAtoms::fill);
19948:   if (ps && ps->SetupPaintServer(aContext, this, opacity))
11336:     return PR_TRUE;
11336: 
11336:   // On failure, use the fallback colour in case we have an
11336:   // objectBoundingBox where the width or height of the object is zero.
11336:   // See http://www.w3.org/TR/SVG11/coords.html#ObjectBoundingBox
20085:   if (style->mFill.mType == eStyleSVGPaintType_Server) {
    1:     SetupCairoColor(aContext,
    1:                     GetStyleSVG()->mFill.mFallbackColor,
    1:                     opacity);
    1:   } else
    1:     SetupCairoColor(aContext,
    1:                     GetStyleSVG()->mFill.mPaint.mColor,
    1:                     opacity);
    1: 
  725:   return PR_TRUE;
    1: }
    1: 
19948: PRBool
    1: nsSVGGeometryFrame::SetupCairoStrokeGeometry(gfxContext *aContext)
    1: {
19948:   const nsStyleSVG* style = GetStyleSVG();
19948:   if (style->mStroke.mType == eStyleSVGPaintType_None)
19948:     return PR_FALSE;
    1:   
19948:   float width = GetStrokeWidth();
19948:   if (width <= 0)
19948:     return PR_FALSE;
19948:   aContext->SetLineWidth(width);
19948: 
19948:   switch (style->mStrokeLinecap) {
    1:   case NS_STYLE_STROKE_LINECAP_BUTT:
    1:     aContext->SetLineCap(gfxContext::LINE_CAP_BUTT);
    1:     break;
    1:   case NS_STYLE_STROKE_LINECAP_ROUND:
    1:     aContext->SetLineCap(gfxContext::LINE_CAP_ROUND);
    1:     break;
    1:   case NS_STYLE_STROKE_LINECAP_SQUARE:
    1:     aContext->SetLineCap(gfxContext::LINE_CAP_SQUARE);
    1:     break;
    1:   }
    1: 
19948:   aContext->SetMiterLimit(style->mStrokeMiterlimit);
    1: 
19948:   switch (style->mStrokeLinejoin) {
    1:   case NS_STYLE_STROKE_LINEJOIN_MITER:
    1:     aContext->SetLineJoin(gfxContext::LINE_JOIN_MITER);
    1:     break;
    1:   case NS_STYLE_STROKE_LINEJOIN_ROUND:
    1:     aContext->SetLineJoin(gfxContext::LINE_JOIN_ROUND);
    1:     break;
    1:   case NS_STYLE_STROKE_LINEJOIN_BEVEL:
    1:     aContext->SetLineJoin(gfxContext::LINE_JOIN_BEVEL);
    1:     break;
    1:   }
19948: 
19948:   return PR_TRUE;
    1: }
    1: 
19948: PRBool
    1: nsSVGGeometryFrame::SetupCairoStrokeHitGeometry(gfxContext *aContext)
    1: {
19948:   if (!SetupCairoStrokeGeometry(aContext))
19948:     return PR_FALSE;
    1: 
    1:   gfxFloat *dashArray;
    1:   PRUint32 count;
    1:   GetStrokeDashArray(&dashArray, &count);
    1:   if (count > 0) {
    1:     aContext->SetDash(dashArray, count, GetStrokeDashoffset());
    1:     delete [] dashArray;
    1:   }
19948:   return PR_TRUE;
    1: }
    1: 
  725: PRBool
 7077: nsSVGGeometryFrame::SetupCairoStroke(gfxContext *aContext)
    1: {
19948:   if (!SetupCairoStrokeHitGeometry(aContext))
19948:     return PR_FALSE;
    1: 
20085:   const nsStyleSVG* style = GetStyleSVG();
20085:   float opacity = MaybeOptimizeOpacity(style->mStrokeOpacity);
    1: 
19948:   nsSVGPaintServerFrame *ps =
20085:     GetPaintServer(&style->mStroke, nsGkAtoms::stroke);
19948:   if (ps && ps->SetupPaintServer(aContext, this, opacity))
11336:     return PR_TRUE;
11336: 
11336:   // On failure, use the fallback colour in case we have an
11336:   // objectBoundingBox where the width or height of the object is zero.
11336:   // See http://www.w3.org/TR/SVG11/coords.html#ObjectBoundingBox
20085:   if (style->mStroke.mType == eStyleSVGPaintType_Server) {
    1:     SetupCairoColor(aContext,
    1:                     GetStyleSVG()->mStroke.mFallbackColor,
    1:                     opacity);
    1:   } else
    1:     SetupCairoColor(aContext,
    1:                     GetStyleSVG()->mStroke.mPaint.mColor,
    1:                     opacity);
    1: 
  725:   return PR_TRUE;
    1: }
