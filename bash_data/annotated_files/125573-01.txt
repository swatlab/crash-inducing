     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsDOMParser.h"
     1: #include "nsNetUtil.h"
     1: #include "nsStringStream.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsCRT.h"
     1: #include "nsStreamUtils.h"
     1: #include "nsContentUtils.h"
     1: #include "nsDOMJSUtils.h"
108290: #include "nsError.h"
  8947: #include "nsPIDOMWindow.h"
 54924: 
 54924: using namespace mozilla;
124724: using namespace mozilla::dom;
     1: 
     1: nsDOMParser::nsDOMParser()
 80486:   : mAttemptedInit(false)
     1: {
124724:   SetIsDOMBinding();
     1: }
     1: 
     1: nsDOMParser::~nsDOMParser()
     1: {
     1: }
     1: 
     1: // QueryInterface implementation for nsDOMParser
124724: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMParser)
124724:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMParser)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMParser)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
     1: NS_INTERFACE_MAP_END
     1: 
124724: NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_1(nsDOMParser, mOwner)
     1: 
124724: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDOMParser)
124724: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDOMParser)
124724: 
124724: already_AddRefed<nsIDocument>
124724: nsDOMParser::ParseFromString(const nsAString& aStr, SupportedType aType,
124724:                              ErrorResult& rv)
124724: {
124724:   nsCOMPtr<nsIDOMDocument> domDocument;
124868:   rv = ParseFromString(aStr,
124724:                        SupportedTypeValues::strings[aType].value,
124724:                        getter_AddRefs(domDocument));
124724:   nsCOMPtr<nsIDocument> document(do_QueryInterface(domDocument));
124724:   return document.forget();
124724: }
     1: 
     1: NS_IMETHODIMP 
     1: nsDOMParser::ParseFromString(const PRUnichar *str, 
     1:                              const char *contentType,
     1:                              nsIDOMDocument **aResult)
     1: {
     1:   NS_ENSURE_ARG(str);
124868:   // Converting a string to an enum value manually is a bit of a pain,
124868:   // so let's just use a helper that takes a content-type string.
124868:   return ParseFromString(nsDependentString(str), contentType, aResult);
124868: }
124868: 
124868: nsresult
124868: nsDOMParser::ParseFromString(const nsAString& str,
124868:                              const char *contentType,
124868:                              nsIDOMDocument **aResult)
124868: {
     1:   NS_ENSURE_ARG_POINTER(aResult);
     1: 
 87808:   nsresult rv;
 87808: 
 87808:   if (!nsCRT::strcmp(contentType, "text/html")) {
 87808:     nsCOMPtr<nsIDOMDocument> domDocument;
 87808:     rv = SetUpDocument(DocumentFlavorHTML, getter_AddRefs(domDocument));
 87808:     NS_ENSURE_SUCCESS(rv, rv);
 87808:     nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
 87808: 
 87808:     // Keep the XULXBL state, base URL and principal setting in sync with the
 87808:     // XML case
 87808: 
 87808:     if (nsContentUtils::IsSystemPrincipal(mOriginalPrincipal)) {
 87808:       document->ForceEnableXULXBL();
 87808:     }
 87808: 
 87808:     // Make sure to give this document the right base URI
 87808:     document->SetBaseURI(mBaseURI);
 87808:     // And the right principal
 87808:     document->SetPrincipal(mPrincipal);
 87808: 
124868:     rv = nsContentUtils::ParseDocumentHTML(str, document, false);
103964:     NS_ENSURE_SUCCESS(rv, rv);
103964: 
 87808:     domDocument.forget(aResult);
 87808:     return rv;
 87808:   }
 87808: 
     1:   NS_ConvertUTF16toUTF8 data(str);
     1: 
     1:   // The new stream holds a reference to the buffer
     1:   nsCOMPtr<nsIInputStream> stream;
 87808:   rv = NS_NewByteInputStream(getter_AddRefs(stream),
     1:                              data.get(), data.Length(),
     1:                              NS_ASSIGNMENT_DEPEND);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   return ParseFromStream(stream, "UTF-8", data.Length(), contentType, aResult);
     1: }
     1: 
124724: already_AddRefed<nsIDocument>
124724: nsDOMParser::ParseFromBuffer(const Sequence<uint8_t>& aBuf, uint32_t aBufLen,
124724:                              SupportedType aType, ErrorResult& rv)
124724: {
124724:   if (aBufLen > aBuf.Length()) {
124724:     rv.Throw(NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY);
124724:     return nullptr;
124724:   }
124724:   nsCOMPtr<nsIDOMDocument> domDocument;
124724:   rv = nsDOMParser::ParseFromBuffer(aBuf.Elements(), aBufLen,
124724:                                     SupportedTypeValues::strings[aType].value,
124724:                                     getter_AddRefs(domDocument));
124724:   nsCOMPtr<nsIDocument> document(do_QueryInterface(domDocument));
124724:   return document.forget();
124724: }
124724: 
124724: already_AddRefed<nsIDocument>
124724: nsDOMParser::ParseFromBuffer(const Uint8Array& aBuf, uint32_t aBufLen,
124724:                              SupportedType aType, ErrorResult& rv)
124724: {
124724:   if (aBufLen > aBuf.Length()) {
124724:     rv.Throw(NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY);
124724:     return nullptr;
124724:   }
124724:   nsCOMPtr<nsIDOMDocument> domDocument;
124724:   rv = nsDOMParser::ParseFromBuffer(aBuf.Data(), aBufLen,
124724:                                     SupportedTypeValues::strings[aType].value,
124724:                                     getter_AddRefs(domDocument));
124724:   nsCOMPtr<nsIDocument> document(do_QueryInterface(domDocument));
124724:   return document.forget();
124724: }
124724: 
     1: NS_IMETHODIMP 
108991: nsDOMParser::ParseFromBuffer(const uint8_t *buf,
108991:                              uint32_t bufLen,
     1:                              const char *contentType,
     1:                              nsIDOMDocument **aResult)
     1: {
     1:   NS_ENSURE_ARG_POINTER(buf);
     1:   NS_ENSURE_ARG_POINTER(aResult);
     1: 
     1:   // The new stream holds a reference to the buffer
     1:   nsCOMPtr<nsIInputStream> stream;
     1:   nsresult rv = NS_NewByteInputStream(getter_AddRefs(stream),
  3233:                                       reinterpret_cast<const char *>(buf),
     1:                                       bufLen, NS_ASSIGNMENT_DEPEND);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
106838:   return ParseFromStream(stream, nullptr, bufLen, contentType, aResult);
     1: }
     1: 
     1: 
124724: already_AddRefed<nsIDocument>
124724: nsDOMParser::ParseFromStream(nsIInputStream* aStream,
124724:                              const nsAString& aCharset,
124724:                              int32_t aContentLength,
124724:                              SupportedType aType,
124724:                              ErrorResult& rv)
124724: {
124724:   nsCOMPtr<nsIDOMDocument> domDocument;
124724:   rv = nsDOMParser::ParseFromStream(aStream,
124724:                                     NS_ConvertUTF16toUTF8(aCharset).get(),
124724:                                     aContentLength,
124724:                                     SupportedTypeValues::strings[aType].value,
124724:                                     getter_AddRefs(domDocument));
124724:   nsCOMPtr<nsIDocument> document(do_QueryInterface(domDocument));
124724:   return document.forget();
124724: }
124724: 
     1: NS_IMETHODIMP 
     1: nsDOMParser::ParseFromStream(nsIInputStream *stream, 
     1:                              const char *charset, 
108991:                              int32_t contentLength,
     1:                              const char *contentType,
     1:                              nsIDOMDocument **aResult)
     1: {
     1:   NS_ENSURE_ARG(stream);
     1:   NS_ENSURE_ARG(contentType);
     1:   NS_ENSURE_ARG_POINTER(aResult);
106838:   *aResult = nullptr;
     1: 
 80256:   bool svg = nsCRT::strcmp(contentType, "image/svg+xml") == 0;
 80256: 
     1:   // For now, we can only create XML documents.
 80256:   //XXXsmaug Should we create an HTMLDocument (in XHTML mode)
 80256:   //         for "application/xhtml+xml"?
     1:   if ((nsCRT::strcmp(contentType, "text/xml") != 0) &&
     1:       (nsCRT::strcmp(contentType, "application/xml") != 0) &&
 80256:       (nsCRT::strcmp(contentType, "application/xhtml+xml") != 0) &&
 80256:       !svg)
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1: 
     1:   nsresult rv;
     1: 
     1:   // Put the nsCOMPtr out here so we hold a ref to the stream as needed
     1:   nsCOMPtr<nsIInputStream> bufferedStream;
     1:   if (!NS_InputStreamIsBuffered(stream)) {
     1:     rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedStream), stream,
     1:                                    4096);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     stream = bufferedStream;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMDocument> domDocument;
 87808:   rv = SetUpDocument(svg ? DocumentFlavorSVG : DocumentFlavorLegacyGuess,
     1:                      getter_AddRefs(domDocument));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // Create a fake channel 
     1:   nsCOMPtr<nsIChannel> parserChannel;
106838:   NS_NewInputStreamChannel(getter_AddRefs(parserChannel), mDocumentURI, nullptr,
106838:                            nsDependentCString(contentType), nullptr);
     1:   NS_ENSURE_STATE(parserChannel);
     1: 
 14668:   // More principal-faking here 
 14668:   parserChannel->SetOwner(mOriginalPrincipal);
     1: 
     1:   if (charset) {
     1:     parserChannel->SetContentCharset(nsDependentCString(charset));
     1:   }
     1: 
     1:   // Tell the document to start loading
     1:   nsCOMPtr<nsIStreamListener> listener;
     1: 
 80486:   // Have to pass false for reset here, else the reset will remove
     1:   // our event listener.  Should that listener addition move to later
     1:   // than this call?  Then we wouldn't need to mess around with
     1:   // SetPrincipal, etc, probably!
 14668:   nsCOMPtr<nsIDocument> document(do_QueryInterface(domDocument));
 14668:   if (!document) return NS_ERROR_FAILURE;
 14668: 
 87808:   // Keep the XULXBL state, base URL and principal setting in sync with the
 87808:   // HTML case
 87808: 
 51393:   if (nsContentUtils::IsSystemPrincipal(mOriginalPrincipal)) {
 51393:     document->ForceEnableXULXBL();
 51393:   }
 51393: 
     1:   rv = document->StartDocumentLoad(kLoadAsData, parserChannel, 
106838:                                    nullptr, nullptr, 
     1:                                    getter_AddRefs(listener),
 80486:                                    false);
     1: 
 14668:   // Make sure to give this document the right base URI
 14668:   document->SetBaseURI(mBaseURI);
 14668: 
 14668:   // And the right principal
     1:   document->SetPrincipal(mPrincipal);
     1: 
     1:   if (NS_FAILED(rv) || !listener) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   // Now start pumping data to the listener
     1:   nsresult status;
     1: 
106838:   rv = listener->OnStartRequest(parserChannel, nullptr);
     1:   if (NS_FAILED(rv))
     1:     parserChannel->Cancel(rv);
     1:   parserChannel->GetStatus(&status);
     1: 
     1:   if (NS_SUCCEEDED(rv) && NS_SUCCEEDED(status)) {
106838:     rv = listener->OnDataAvailable(parserChannel, nullptr, stream, 0,
     1:                                    contentLength);
     1:     if (NS_FAILED(rv))
     1:       parserChannel->Cancel(rv);
     1:     parserChannel->GetStatus(&status);
     1:   }
     1: 
106838:   rv = listener->OnStopRequest(parserChannel, nullptr, status);
     1:   // Failure returned from OnStopRequest does not affect the final status of
     1:   // the channel, so we do not need to call Cancel(rv) as we do above.
     1: 
     1:   if (NS_FAILED(rv)) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   domDocument.swap(*aResult);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDOMParser::Init(nsIPrincipal* principal, nsIURI* documentURI,
  6475:                   nsIURI* baseURI, nsIScriptGlobalObject* aScriptObject)
     1: {
     1:   NS_ENSURE_STATE(!mAttemptedInit);
 80486:   mAttemptedInit = true;
     1:   
     1:   NS_ENSURE_ARG(principal || documentURI);
     1: 
     1:   mDocumentURI = documentURI;
 50981:   
     1:   if (!mDocumentURI) {
     1:     principal->GetURI(getter_AddRefs(mDocumentURI));
 50981:     // If we have the system principal, then we'll just use the null principals
 50981:     // uri.
 50981:     if (!mDocumentURI && !nsContentUtils::IsSystemPrincipal(principal)) {
     1:       return NS_ERROR_INVALID_ARG;
     1:     }
     1:   }
     1: 
  6475:   mScriptHandlingObject = do_GetWeakReference(aScriptObject);
     1:   mPrincipal = principal;
 50981:   nsresult rv;
 50981:   if (!mPrincipal) {
     1:     nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
     1:     NS_ENSURE_TRUE(secMan, NS_ERROR_NOT_AVAILABLE);
 13653:     rv =
106025:       secMan->GetSimpleCodebasePrincipal(mDocumentURI,
106025:                                          getter_AddRefs(mPrincipal));
 50981:     NS_ENSURE_SUCCESS(rv, rv);
 13653:     mOriginalPrincipal = mPrincipal;
 13653:   } else {
 50981:     mOriginalPrincipal = mPrincipal;
 50981:     if (nsContentUtils::IsSystemPrincipal(mPrincipal)) {
 13653:       // Don't give DOMParsers the system principal.  Use a null
 13653:       // principal instead.
 13653:       mPrincipal = do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
 50981:       NS_ENSURE_SUCCESS(rv, rv);
 50981: 
 50981:       if (!mDocumentURI) {
 50981:         rv = mPrincipal->GetURI(getter_AddRefs(mDocumentURI));
 50981:         NS_ENSURE_SUCCESS(rv, rv);
 13653:       }
 13653:     }
 50981:   }
     1:   
     1:   mBaseURI = baseURI;
     1:   // Note: if mBaseURI is null, fine.  Leave it like that; that will use the
     1:   // documentURI as the base.  Otherwise for null principals we'll get
     1:   // nsDocument::SetBaseURI giving errors.
     1: 
     1:   NS_POSTCONDITION(mPrincipal, "Must have principal");
 13653:   NS_POSTCONDITION(mOriginalPrincipal, "Must have original principal");
     1:   NS_POSTCONDITION(mDocumentURI, "Must have document URI");
     1:   return NS_OK;
     1: }
     1: 
124724: /*static */already_AddRefed<nsDOMParser>
124724: nsDOMParser::Constructor(nsISupports* aOwner, nsIPrincipal* aPrincipal,
124724:                          nsIURI* aDocumentURI, nsIURI* aBaseURI,
124724:                          ErrorResult& rv)
124724: {
124724:   if (!nsContentUtils::IsCallerChrome()) {
124724:     rv.Throw(NS_ERROR_DOM_SECURITY_ERR);
124724:     return nullptr;
124724:   }
124724:   nsRefPtr<nsDOMParser> domParser = new nsDOMParser(aOwner);
124724:   rv = domParser->InitInternal(aOwner, aPrincipal, aDocumentURI, aBaseURI);
124724:   if (rv.Failed()) {
124724:     return nullptr;
124724:   }
124724:   return domParser.forget();
124724: }
124724: 
124725: /*static */already_AddRefed<nsDOMParser>
124725: nsDOMParser::Constructor(nsISupports* aOwner, mozilla::ErrorResult& rv)
     1: {
     1:   nsCOMPtr<nsIPrincipal> prin;
     1:   nsCOMPtr<nsIURI> documentURI;
     1:   nsCOMPtr<nsIURI> baseURI;
     1:   // No arguments; use the subject principal
     1:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
124725:   if (!secMan) {
124725:     rv.Throw(NS_ERROR_UNEXPECTED);
124725:     return nullptr;
124725:   }
     1: 
124725:   rv = secMan->GetSubjectPrincipal(getter_AddRefs(prin));
124725:   if (rv.Failed()) {
124725:     return nullptr;
124725:   }
     1: 
     1:   // We're called from JS; there better be a subject principal, really.
124725:   if (!prin) {
124725:     rv.Throw(NS_ERROR_UNEXPECTED);
124725:     return nullptr;
     1:   }
     1: 
124725:   nsRefPtr<nsDOMParser> domParser = new nsDOMParser(aOwner);
124725:   rv = domParser->InitInternal(aOwner, prin, documentURI, baseURI);
124725:   if (rv.Failed()) {
124725:     return nullptr;
124725:   }
124725:   return domParser.forget();
124724: }
     1: 
124724: nsresult
124724: nsDOMParser::InitInternal(nsISupports* aOwner, nsIPrincipal* prin,
124724:                           nsIURI* documentURI, nsIURI* baseURI)
124724: {
124724:   AttemptedInitMarker marker(&mAttemptedInit);
     1:   if (!documentURI) {
     1:     // No explicit documentURI; grab document and base URIs off the window our
     1:     // constructor was called on. Error out if anything untoward happens.
     1: 
     1:     // Note that this is a behavior change as far as I can tell -- we're now
     1:     // using the base URI and document URI of the window off of which the
     1:     // DOMParser is created, not the window in which parse*() is called.
     1:     // Does that matter?
     1: 
     1:     // Also note that |cx| matches what GetDocumentFromContext() would return,
     1:     // while GetDocumentFromCaller() gives us the window that the DOMParser()
     1:     // call was made on.
     1: 
  8947:     nsCOMPtr<nsIDocument> doc;
  8947:     nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aOwner);
125573:     if (window) {
  8947:       nsCOMPtr<nsIDOMDocument> domdoc = window->GetExtantDocument();
  8947:       doc = do_QueryInterface(domdoc);
  8947:     }
  8947: 
     1:     if (!doc) {
     1:       return NS_ERROR_UNEXPECTED;
     1:     }
     1: 
 41900:     baseURI = doc->GetDocBaseURI();
     1:     documentURI = doc->GetDocumentURI();
     1:   }
     1: 
  8947:   nsCOMPtr<nsIScriptGlobalObject> scriptglobal = do_QueryInterface(aOwner);
  8947:   return Init(prin, documentURI, baseURI, scriptglobal);
     1: }
     1: 
124725: void
 50981: nsDOMParser::Init(nsIPrincipal* aPrincipal, nsIURI* aDocumentURI,
124725:                   nsIURI* aBaseURI, mozilla::ErrorResult& rv)
     1: {
     1:   AttemptedInitMarker marker(&mAttemptedInit);
     1: 
 18869:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
124725:   if (!cx) {
124725:     rv.Throw(NS_ERROR_UNEXPECTED);
124725:     return;
124725:   }
     1: 
  6475:   nsIScriptContext* scriptContext = GetScriptContextFromJSContext(cx);
 50981: 
 50981:   nsCOMPtr<nsIPrincipal> principal = aPrincipal;
 50981: 
 50981:   if (!principal && !aDocumentURI) {
 50981:     nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
124725:     if (!secMan) {
124725:       rv.Throw(NS_ERROR_UNEXPECTED);
124725:       return;
124725:     }
 50981: 
124725:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(principal));
124725:     if (rv.Failed()) {
124725:       return;
124725:     }
 50981: 
 50981:     // We're called from JS; there better be a subject principal, really.
124725:     if (!principal) {
124725:       rv.Throw(NS_ERROR_UNEXPECTED);
124725:       return;
124725:     }
 50981:   }
 50981: 
124725:   rv = Init(principal, aDocumentURI, aBaseURI,
106838:             scriptContext ? scriptContext->GetGlobalObject() : nullptr);
     1: }
 87808: 
 87808: nsresult
 87808: nsDOMParser::SetUpDocument(DocumentFlavor aFlavor, nsIDOMDocument** aResult)
 87808: {
 87808:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
 87808:     do_QueryReferent(mScriptHandlingObject);
 87808:   nsresult rv;
 87808:   if (!mPrincipal) {
 87808:     NS_ENSURE_TRUE(!mAttemptedInit, NS_ERROR_NOT_INITIALIZED);
 87808:     AttemptedInitMarker marker(&mAttemptedInit);
 87808: 
 87808:     nsCOMPtr<nsIPrincipal> prin =
 87808:       do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
 87808:     NS_ENSURE_SUCCESS(rv, rv);
 87808: 
106838:     rv = Init(prin, nullptr, nullptr, scriptHandlingObject);
 87808:     NS_ENSURE_SUCCESS(rv, rv);
 87808:   }
 87808: 
 87808:   NS_ASSERTION(mPrincipal, "Must have principal by now");
 87808:   NS_ASSERTION(mDocumentURI, "Must have document URI by now");
 87808: 
 87808:   // Here we have to cheat a little bit...  Setting the base URI won't
 87808:   // work if the document has a null principal, so use
 87808:   // mOriginalPrincipal when creating the document, then reset the
 87808:   // principal.
125373:   return NS_NewDOMDocument(aResult, EmptyString(), EmptyString(), nullptr,
 87808:                            mDocumentURI, mBaseURI,
 87808:                            mOriginalPrincipal,
125373:                            true,
 87808:                            scriptHandlingObject,
125373:                            aFlavor);
 87808: }
