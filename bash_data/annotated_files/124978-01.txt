 43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 43113: /* vim:set ts=4 sw=4 sts=4 et cin: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43113: 
 46801: #include "base/basictypes.h"
 46801: 
 43113: #include "nsIOService.h"
 43113: #include "nsHttpHandler.h"
 43113: #include "nsHttpTransaction.h"
 43113: #include "nsHttpConnection.h"
 43113: #include "nsHttpRequestHead.h"
 43113: #include "nsHttpResponseHead.h"
 43113: #include "nsHttpChunkedDecoder.h"
 43113: #include "nsTransportUtils.h"
 43113: #include "nsNetUtil.h"
 43113: #include "nsProxyRelease.h"
 43113: #include "nsIOService.h"
 64101: #include "nsAtomicRefcnt.h"
 43113: 
 43113: #include "nsISeekableStream.h"
 43113: #include "nsISocketTransport.h"
 43113: #include "nsMultiplexInputStream.h"
 43113: #include "nsStringStream.h"
 43113: 
 43113: #include "nsComponentManagerUtils.h" // do_CreateInstance
 43113: #include "nsServiceManagerUtils.h"   // do_GetService
 43113: #include "nsIHttpActivityObserver.h"
124978: #include "nsSocketTransportService2.h"
 43113: 
 43113: 
 93845: using namespace mozilla;
 93845: 
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: #ifdef DEBUG
 43113: // defined by the socket transport service while active
 43113: extern PRThread *gSocketThread;
 43113: #endif
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: static NS_DEFINE_CID(kMultiplexInputStream, NS_MULTIPLEXINPUTSTREAM_CID);
 43113: 
 61543: // Place a limit on how much non-compliant HTTP can be skipped while
 61543: // looking for a response header
 61543: #define MAX_INVALID_RESPONSE_BODY_SIZE (1024 * 128)
 61543: 
 43113: //-----------------------------------------------------------------------------
 43113: // helpers
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: #if defined(PR_LOGGING)
 43113: static void
111275: LogHeaders(const char *lineStart)
 43113: {
110974:     nsAutoCString buf;
111275:     char *endOfLine;
111275:     while ((endOfLine = PL_strstr(lineStart, "\r\n"))) {
111275:         buf.Assign(lineStart, endOfLine - lineStart);
111275:         if (PL_strcasestr(buf.get(), "authorization: ") ||
111275:             PL_strcasestr(buf.get(), "proxy-authorization: ")) {
 43113:             char *p = PL_strchr(PL_strchr(buf.get(), ' ') + 1, ' ');
111275:             while (p && *++p)
111275:                 *p = '*';
 43113:         }
 43113:         LOG3(("  %s\n", buf.get()));
111275:         lineStart = endOfLine + 2;
 43113:     }
 43113: }
 43113: #endif
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpTransaction <public>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: nsHttpTransaction::nsHttpTransaction()
121882:     : mCallbacksLock("transaction mCallbacks lock")
121882:     , mRequestSize(0)
106838:     , mConnection(nullptr)
106838:     , mConnInfo(nullptr)
106838:     , mRequestHead(nullptr)
106838:     , mResponseHead(nullptr)
 43113:     , mContentLength(-1)
 43113:     , mContentRead(0)
 61543:     , mInvalidResponseBytesRead(0)
106838:     , mChunkedDecoder(nullptr)
 43113:     , mStatus(NS_OK)
 43113:     , mPriority(0)
 43113:     , mRestartCount(0)
 43113:     , mCaps(0)
 93840:     , mClassification(CLASS_GENERAL)
 93839:     , mPipelinePosition(0)
108528:     , mHttpVersion(NS_HTTP_VERSION_UNKNOWN)
 80486:     , mClosed(false)
 80486:     , mConnected(false)
 80486:     , mHaveStatusLine(false)
 80486:     , mHaveAllHeaders(false)
 80486:     , mTransactionDone(false)
 80486:     , mResponseIsComplete(false)
 80486:     , mDidContentStart(false)
 80486:     , mNoContent(false)
 80486:     , mSentData(false)
 80486:     , mReceivedData(false)
 80486:     , mStatusEventPending(false)
 80486:     , mHasRequestBody(false)
109252:     , mProxyConnectFailed(false)
 80486:     , mHttpResponseMatched(false)
 80486:     , mPreserveStream(false)
124828:     , mDispatchedAsBlocking(false)
 93845:     , mReportedStart(false)
 93845:     , mReportedResponseHeader(false)
106838:     , mForTakeResponseHead(nullptr)
 94866:     , mResponseHeadTaken(false)
 43113: {
 43113:     LOG(("Creating nsHttpTransaction @%x\n", this));
 94988:     gHttpHandler->GetMaxPipelineObjectSize(&mMaxPipelineObjectSize);
 43113: }
 43113: 
 43113: nsHttpTransaction::~nsHttpTransaction()
 43113: {
 43113:     LOG(("Destroying nsHttpTransaction @%x\n", this));
 43113: 
121883:     // Force the callbacks to be released right now
121883:     mCallbacks = nullptr;
121883: 
 43113:     NS_IF_RELEASE(mConnection);
 43113:     NS_IF_RELEASE(mConnInfo);
 43113: 
 43113:     delete mResponseHead;
 93845:     delete mForTakeResponseHead;
 43113:     delete mChunkedDecoder;
124828:     ReleaseBlockingTransaction();
 43113: }
 43113: 
 93840: nsHttpTransaction::Classifier
 93840: nsHttpTransaction::Classify()
 93840: {
 93840:     if (!(mCaps & NS_HTTP_ALLOW_PIPELINING))
 93840:         return (mClassification = CLASS_SOLO);
 93840: 
 93840:     if (mRequestHead->PeekHeader(nsHttp::If_Modified_Since) ||
 93840:         mRequestHead->PeekHeader(nsHttp::If_None_Match))
 93840:         return (mClassification = CLASS_REVALIDATION);
 93840: 
 93840:     const char *accept = mRequestHead->PeekHeader(nsHttp::Accept);
 93840:     if (accept && !PL_strncmp(accept, "image/", 6))
 93840:         return (mClassification = CLASS_IMAGE);
 93840: 
 93840:     if (accept && !PL_strncmp(accept, "text/css", 8))
 93840:         return (mClassification = CLASS_SCRIPT);
 93840: 
 93840:     mClassification = CLASS_GENERAL;
 93840: 
108991:     int32_t queryPos = mRequestHead->RequestURI().FindChar('?');
 93840:     if (queryPos == kNotFound) {
 93840:         if (StringEndsWith(mRequestHead->RequestURI(),
 93840:                            NS_LITERAL_CSTRING(".js")))
 93840:             mClassification = CLASS_SCRIPT;
 93840:     }
 93840:     else if (queryPos >= 3 &&
 93840:              Substring(mRequestHead->RequestURI(), queryPos - 3, 3).
 93840:              EqualsLiteral(".js")) {
 93840:         mClassification = CLASS_SCRIPT;
 93840:     }
 93840: 
 93840:     return mClassification;
 93840: }
 93840: 
 43113: nsresult
124419: nsHttpTransaction::Init(uint32_t caps,
 43113:                         nsHttpConnectionInfo *cinfo,
 43113:                         nsHttpRequestHead *requestHead,
 43113:                         nsIInputStream *requestBody,
 79445:                         bool requestBodyHasHeaders,
 43113:                         nsIEventTarget *target,
 43113:                         nsIInterfaceRequestor *callbacks,
 43113:                         nsITransportEventSink *eventsink,
 43113:                         nsIAsyncInputStream **responseBody)
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpTransaction::Init [this=%x caps=%x]\n", this, caps));
 43113: 
 43113:     NS_ASSERTION(cinfo, "ouch");
 43113:     NS_ASSERTION(requestHead, "ouch");
 43113:     NS_ASSERTION(target, "ouch");
 43113: 
 43113:     mActivityDistributor = do_GetService(NS_HTTPACTIVITYDISTRIBUTOR_CONTRACTID, &rv);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 79445:     bool activityDistributorActive;
 43113:     rv = mActivityDistributor->GetIsActive(&activityDistributorActive);
 43113:     if (NS_SUCCEEDED(rv) && activityDistributorActive) {
 43113:         // there are some observers registered at activity distributor, gather
 43113:         // nsISupports for the channel that called Init()
 43113:         mChannel = do_QueryInterface(eventsink);
 43113:         LOG(("nsHttpTransaction::Init() " \
 43113:              "mActivityDistributor is active " \
 43113:              "this=%x", this));
 43113:     } else {
 43113:         // there is no observer, so don't use it
 80486:         activityDistributorActive = false;
106838:         mActivityDistributor = nullptr;
 43113:     }
 43113: 
 43113:     // create transport event sink proxy. it coalesces all events if and only 
 43113:     // if the activity observer is not active. when the observer is active
 43113:     // we need not to coalesce any events to get all expected notifications
 43113:     // of the transaction state, necessary for correct debugging and logging.
 43113:     rv = net_NewTransportEventSinkProxy(getter_AddRefs(mTransportSink),
 43113:                                         eventsink, target,
 43113:                                         !activityDistributorActive);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     NS_ADDREF(mConnInfo = cinfo);
 43113:     mCallbacks = callbacks;
 43113:     mConsumerTarget = target;
 43113:     mCaps = caps;
 43113: 
 43113:     if (requestHead->Method() == nsHttp::Head)
 80486:         mNoContent = true;
 43113: 
 43113:     // Make sure that there is "Content-Length: 0" header in the requestHead
 43113:     // in case of POST and PUT methods when there is no requestBody and
 43113:     // requestHead doesn't contain "Transfer-Encoding" header.
 43113:     //
 43113:     // RFC1945 section 7.2.2:
 43113:     //   HTTP/1.0 requests containing an entity body must include a valid
 43113:     //   Content-Length header field.
 43113:     //
 43113:     // RFC2616 section 4.4:
 43113:     //   For compatibility with HTTP/1.0 applications, HTTP/1.1 requests
 43113:     //   containing a message-body MUST include a valid Content-Length header
 43113:     //   field unless the server is known to be HTTP/1.1 compliant.
 43113:     if ((requestHead->Method() == nsHttp::Post || requestHead->Method() == nsHttp::Put) &&
 43113:         !requestBody && !requestHead->PeekHeader(nsHttp::Transfer_Encoding)) {
 43113:         requestHead->SetHeader(nsHttp::Content_Length, NS_LITERAL_CSTRING("0"));
 43113:     }
 43113: 
 43113:     // grab a weak reference to the request head
 43113:     mRequestHead = requestHead;
 43113: 
 43113:     // make sure we eliminate any proxy specific headers from 
102295:     // the request if we are using CONNECT
102295:     bool pruneProxyHeaders = cinfo->UsingConnect();
 69816:     
 43113:     mReqHeaderBuf.Truncate();
 43113:     requestHead->Flatten(mReqHeaderBuf, pruneProxyHeaders);
 43113: 
 43113: #if defined(PR_LOGGING)
 43113:     if (LOG3_ENABLED()) {
 43113:         LOG3(("http request [\n"));
 43113:         LogHeaders(mReqHeaderBuf.get());
 43113:         LOG3(("]\n"));
 43113:     }
 43113: #endif
 43113: 
 43113:     // If the request body does not include headers or if there is no request
 43113:     // body, then we must add the header/body separator manually.
 43113:     if (!requestBodyHasHeaders || !requestBody)
 43113:         mReqHeaderBuf.AppendLiteral("\r\n");
 43113: 
 43113:     // report the request header
 43113:     if (mActivityDistributor)
 43113:         mActivityDistributor->ObserveActivity(
 43113:             mChannel,
 43113:             NS_HTTP_ACTIVITY_TYPE_HTTP_TRANSACTION,
 43113:             NS_HTTP_ACTIVITY_SUBTYPE_REQUEST_HEADER,
120112:             PR_Now(), 0,
 43113:             mReqHeaderBuf);
 43113: 
 43113:     // Create a string stream for the request header buf (the stream holds
 43113:     // a non-owning reference to the request header data, so we MUST keep
 43113:     // mReqHeaderBuf around).
 43113:     nsCOMPtr<nsIInputStream> headers;
 43113:     rv = NS_NewByteInputStream(getter_AddRefs(headers),
 43113:                                mReqHeaderBuf.get(),
 43113:                                mReqHeaderBuf.Length());
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     if (requestBody) {
 80486:         mHasRequestBody = true;
 43113: 
 43113:         // wrap the headers and request body in a multiplexed input stream.
 43113:         nsCOMPtr<nsIMultiplexInputStream> multi =
 43113:             do_CreateInstance(kMultiplexInputStream, &rv);
 43113:         if (NS_FAILED(rv)) return rv;
 43113: 
 43113:         rv = multi->AppendStream(headers);
 43113:         if (NS_FAILED(rv)) return rv;
 43113: 
 43113:         rv = multi->AppendStream(requestBody);
 43113:         if (NS_FAILED(rv)) return rv;
 43113: 
 43113:         // wrap the multiplexed input stream with a buffered input stream, so
 43113:         // that we write data in the largest chunks possible.  this is actually
 43113:         // necessary to workaround some common server bugs (see bug 137155).
 43113:         rv = NS_NewBufferedInputStream(getter_AddRefs(mRequestStream), multi,
 43113:                                        nsIOService::gDefaultSegmentSize);
 43113:         if (NS_FAILED(rv)) return rv;
 43113:     }
 43113:     else
 43113:         mRequestStream = headers;
 43113: 
 43113:     rv = mRequestStream->Available(&mRequestSize);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // create pipe for response stream
 43113:     rv = NS_NewPipe2(getter_AddRefs(mPipeIn),
 43113:                      getter_AddRefs(mPipeOut),
 80486:                      true, true,
 43113:                      nsIOService::gDefaultSegmentSize,
 87134:                      nsIOService::gDefaultSegmentCount);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 93840:     Classify();
 93840: 
 43113:     NS_ADDREF(*responseBody = mPipeIn);
 43113:     return NS_OK;
 43113: }
 43113: 
 84549: nsAHttpConnection *
 84549: nsHttpTransaction::Connection()
 84549: {
 84549:     return mConnection;
 84549: }
 84549: 
 43113: nsHttpResponseHead *
 43113: nsHttpTransaction::TakeResponseHead()
 43113: {
 94866:     NS_ABORT_IF_FALSE(!mResponseHeadTaken, "TakeResponseHead called 2x");
 93845: 
 93845:     // Lock RestartInProgress() and TakeResponseHead() against main thread
 93845:     MutexAutoLock lock(*nsHttp::GetLock());
 93845: 
 94866:     mResponseHeadTaken = true;
 93845: 
 94793:     // Prefer mForTakeResponseHead over mResponseHead. It is always a complete
 94793:     // set of headers.
 94793:     nsHttpResponseHead *head;
 94793:     if (mForTakeResponseHead) {
 94793:         head = mForTakeResponseHead;
106838:         mForTakeResponseHead = nullptr;
 94793:         return head;
 94793:     }
 94793:     
 93845:     // Even in OnStartRequest() the headers won't be available if we were
 93845:     // canceled
 43113:     if (!mHaveAllHeaders) {
 43113:         NS_WARNING("response headers not available or incomplete");
106838:         return nullptr;
 43113:     }
 43113: 
 93845:     head = mResponseHead;
106838:     mResponseHead = nullptr;
 43113:     return head;
 43113: }
 43113: 
 67712: void
109252: nsHttpTransaction::SetProxyConnectFailed()
 67712: {
109252:     mProxyConnectFailed = true;
 67712: }
 67712: 
 67712: nsHttpRequestHead *
 67712: nsHttpTransaction::RequestHead()
 67712: {
 67712:     return mRequestHead;
 67712: }
 67712: 
108991: uint32_t
 84549: nsHttpTransaction::Http1xTransactionCount()
 84549: {
 84549:   return 1;
 84549: }
 84549: 
 90199: nsresult
 90199: nsHttpTransaction::TakeSubTransactions(
 90199:     nsTArray<nsRefPtr<nsAHttpTransaction> > &outTransactions)
 90199: {
 90199:     return NS_ERROR_NOT_IMPLEMENTED;
 90199: }
 90199: 
 43113: //----------------------------------------------------------------------------
 43113: // nsHttpTransaction::nsAHttpTransaction
 43113: //----------------------------------------------------------------------------
 43113: 
 43113: void
 43113: nsHttpTransaction::SetConnection(nsAHttpConnection *conn)
 43113: {
 43113:     NS_IF_RELEASE(mConnection);
 43113:     NS_IF_ADDREF(mConnection = conn);
 43113: }
 43113: 
 43113: void
121883: nsHttpTransaction::GetSecurityCallbacks(nsIInterfaceRequestor **cb)
 43113: {
121882:     MutexAutoLock lock(mCallbacksLock);
 43113:     NS_IF_ADDREF(*cb = mCallbacks);
 43113: }
 43113: 
 43113: void
121883: nsHttpTransaction::SetSecurityCallbacks(nsIInterfaceRequestor* aCallbacks)
121882: {
121882:     {
121882:         MutexAutoLock lock(mCallbacksLock);
121882:         mCallbacks = aCallbacks;
121882:     }
124978: 
124978:     if (gSocketTransportService) {
124978:         nsRefPtr<UpdateSecurityCallbacks> event = new UpdateSecurityCallbacks(this, aCallbacks);
124978:         gSocketTransportService->Dispatch(event, nsIEventTarget::DISPATCH_NORMAL);
121882:     }
121882: }
121882: 
121882: void
 67756: nsHttpTransaction::OnTransportStatus(nsITransport* transport,
108991:                                      nsresult status, uint64_t progress)
 43113: {
 43113:     LOG(("nsHttpTransaction::OnSocketStatus [this=%x status=%x progress=%llu]\n",
 43113:         this, status, progress));
 43113: 
 70188:     if (TimingEnabled()) {
107210:         if (status == NS_NET_STATUS_RESOLVING_HOST) {
119958:             mTimings.domainLookupStart = TimeStamp::Now();
107210:         } else if (status == NS_NET_STATUS_RESOLVED_HOST) {
119958:             mTimings.domainLookupEnd = TimeStamp::Now();
107210:         } else if (status == NS_NET_STATUS_CONNECTING_TO) {
119958:             mTimings.connectStart = TimeStamp::Now();
107210:         } else if (status == NS_NET_STATUS_CONNECTED_TO) {
119958:             mTimings.connectEnd = TimeStamp::Now();
 70188:         }
 70188:     }
 70188: 
 43113:     if (!mTransportSink)
 43113:         return;
 43113: 
 43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
 43113: 
 43113:     // Need to do this before the STATUS_RECEIVING_FROM check below, to make
 43113:     // sure that the activity distributor gets told about all status events.
 43113:     if (mActivityDistributor) {
 43113:         // upon STATUS_WAITING_FOR; report request body sent
 43113:         if ((mHasRequestBody) &&
107210:             (status == NS_NET_STATUS_WAITING_FOR))
 43113:             mActivityDistributor->ObserveActivity(
 43113:                 mChannel,
 43113:                 NS_HTTP_ACTIVITY_TYPE_HTTP_TRANSACTION,
 43113:                 NS_HTTP_ACTIVITY_SUBTYPE_REQUEST_BODY_SENT,
120112:                 PR_Now(), 0, EmptyCString());
 43113: 
 43113:         // report the status and progress
 94866:         if (!mRestartInProgressVerifier.IsDiscardingContent())
 43113:             mActivityDistributor->ObserveActivity(
 43113:                 mChannel,
 43113:                 NS_HTTP_ACTIVITY_TYPE_SOCKET_TRANSPORT,
108991:                 static_cast<uint32_t>(status),
 43113:                 PR_Now(),
 43113:                 progress,
 43113:                 EmptyCString());
 43113:     }
 43113: 
 43113:     // nsHttpChannel synthesizes progress events in OnDataAvailable
107210:     if (status == NS_NET_STATUS_RECEIVING_FROM)
 43113:         return;
 43113: 
108991:     uint64_t progressMax;
 43113: 
107210:     if (status == NS_NET_STATUS_SENDING_TO) {
 43113:         // suppress progress when only writing request headers
 43113:         if (!mHasRequestBody)
 43113:             return;
 43113: 
 43113:         nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mRequestStream);
 43113:         NS_ASSERTION(seekable, "Request stream isn't seekable?!?");
 43113: 
108991:         int64_t prog = 0;
 43113:         seekable->Tell(&prog);
 43113:         progress = prog;
 43113: 
 43113:         // when uploading, we include the request headers in the progress
 43113:         // notifications.
 43113:         progressMax = mRequestSize; // XXX mRequestSize is 32-bit!
 43113:     }
 43113:     else {
120112:         progress = 0;
 43113:         progressMax = 0;
 43113:     }
 43113: 
 67756:     mTransportSink->OnTransportStatus(transport, status, progress, progressMax);
 43113: }
 43113: 
 79445: bool
 43113: nsHttpTransaction::IsDone()
 43113: {
 43113:     return mTransactionDone;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpTransaction::Status()
 43113: {
 43113:     return mStatus;
 43113: }
 43113: 
124419: uint32_t
 93838: nsHttpTransaction::Caps()
 93838: { 
 93838:     return mCaps;
 93838: }
 93838: 
108991: uint64_t
 43113: nsHttpTransaction::Available()
 43113: {
108991:     uint64_t size;
 43113:     if (NS_FAILED(mRequestStream->Available(&size)))
 43113:         size = 0;
 43113:     return size;
 43113: }
 43113: 
 43113: NS_METHOD
 43113: nsHttpTransaction::ReadRequestSegment(nsIInputStream *stream,
 43113:                                       void *closure,
 43113:                                       const char *buf,
108991:                                       uint32_t offset,
108991:                                       uint32_t count,
108991:                                       uint32_t *countRead)
 43113: {
 43113:     nsHttpTransaction *trans = (nsHttpTransaction *) closure;
 43113:     nsresult rv = trans->mReader->OnReadSegment(buf, count, countRead);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 70188:     if (trans->TimingEnabled() && trans->mTimings.requestStart.IsNull()) {
 70188:         // First data we're sending -> this is requestStart
119958:         trans->mTimings.requestStart = TimeStamp::Now();
 70188:     }
 80486:     trans->mSentData = true;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpTransaction::ReadSegments(nsAHttpSegmentReader *reader,
108991:                                 uint32_t count, uint32_t *countRead)
 43113: {
 43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
 43113: 
 43113:     if (mTransactionDone) {
 43113:         *countRead = 0;
 43113:         return mStatus;
 43113:     }
 43113: 
 43113:     if (!mConnected) {
 80486:         mConnected = true;
 43113:         mConnection->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
 43113:     }
 43113: 
 43113:     mReader = reader;
 43113: 
 43113:     nsresult rv = mRequestStream->ReadSegments(ReadRequestSegment, this, count, countRead);
 43113: 
106838:     mReader = nullptr;
 43113: 
 43113:     // if read would block then we need to AsyncWait on the request stream.
 43113:     // have callback occur on socket thread so we stay synchronized.
 43113:     if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
 43113:         nsCOMPtr<nsIAsyncInputStream> asyncIn =
 43113:                 do_QueryInterface(mRequestStream);
 43113:         if (asyncIn) {
 43113:             nsCOMPtr<nsIEventTarget> target;
 43113:             gHttpHandler->GetSocketThreadTarget(getter_AddRefs(target));
 43113:             if (target)
 43113:                 asyncIn->AsyncWait(this, 0, 0, target);
 43113:             else {
 43113:                 NS_ERROR("no socket thread event target");
 43113:                 rv = NS_ERROR_UNEXPECTED;
 43113:             }
 43113:         }
 43113:     }
 43113: 
 43113:     return rv;
 43113: }
 43113: 
 43113: NS_METHOD
 43113: nsHttpTransaction::WritePipeSegment(nsIOutputStream *stream,
 43113:                                     void *closure,
 43113:                                     char *buf,
108991:                                     uint32_t offset,
108991:                                     uint32_t count,
108991:                                     uint32_t *countWritten)
 43113: {
 43113:     nsHttpTransaction *trans = (nsHttpTransaction *) closure;
 43113: 
 43113:     if (trans->mTransactionDone)
 43113:         return NS_BASE_STREAM_CLOSED; // stop iterating
 43113: 
 70188:     if (trans->TimingEnabled() && trans->mTimings.responseStart.IsNull()) {
119958:         trans->mTimings.responseStart = TimeStamp::Now();
 70188:     }
 70188: 
 43113:     nsresult rv;
 43113:     //
 43113:     // OK, now let the caller fill this segment with data.
 43113:     //
 43113:     rv = trans->mWriter->OnWriteSegment(buf, count, countWritten);
 43113:     if (NS_FAILED(rv)) return rv; // caller didn't want to write anything
 43113: 
 43113:     NS_ASSERTION(*countWritten > 0, "bad writer");
 80486:     trans->mReceivedData = true;
 43113: 
 72347:     // Let the transaction "play" with the buffer.  It is free to modify
 43113:     // the contents of the buffer and/or modify countWritten.
 72347:     // - Bytes in HTTP headers don't count towards countWritten, so the input
 72347:     // side of pipe (aka nsHttpChannel's mTransactionPump) won't hit
 72347:     // OnInputStreamReady until all headers have been parsed.
 72347:     //    
 43113:     rv = trans->ProcessData(buf, *countWritten, countWritten);
 43113:     if (NS_FAILED(rv))
 43113:         trans->Close(rv);
 43113: 
 43113:     return rv; // failure code only stops WriteSegments; it is not propagated.
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpTransaction::WriteSegments(nsAHttpSegmentWriter *writer,
108991:                                  uint32_t count, uint32_t *countWritten)
 43113: {
 43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
 43113: 
 43113:     if (mTransactionDone)
 43113:         return NS_SUCCEEDED(mStatus) ? NS_BASE_STREAM_CLOSED : mStatus;
 43113: 
 43113:     mWriter = writer;
 43113: 
 43113:     nsresult rv = mPipeOut->WriteSegments(WritePipeSegment, this, count, countWritten);
 43113: 
106838:     mWriter = nullptr;
 43113: 
 43113:     // if pipe would block then we need to AsyncWait on it.  have callback
 43113:     // occur on socket thread so we stay synchronized.
 43113:     if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
 43113:         nsCOMPtr<nsIEventTarget> target;
 43113:         gHttpHandler->GetSocketThreadTarget(getter_AddRefs(target));
 43113:         if (target)
 43113:             mPipeOut->AsyncWait(this, 0, 0, target);
 43113:         else {
 43113:             NS_ERROR("no socket thread event target");
 43113:             rv = NS_ERROR_UNEXPECTED;
 43113:         }
 43113:     }
 43113: 
 43113:     return rv;
 43113: }
 43113: 
 43113: void
 43113: nsHttpTransaction::Close(nsresult reason)
 43113: {
 43113:     LOG(("nsHttpTransaction::Close [this=%x reason=%x]\n", this, reason));
 43113: 
 43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
 43113: 
 43113:     if (mClosed) {
 43113:         LOG(("  already closed\n"));
 43113:         return;
 43113:     }
 43113: 
 43113:     if (mActivityDistributor) {
 43113:         // report the reponse is complete if not already reported
 43113:         if (!mResponseIsComplete)
 43113:             mActivityDistributor->ObserveActivity(
 43113:                 mChannel,
 43113:                 NS_HTTP_ACTIVITY_TYPE_HTTP_TRANSACTION,
 43113:                 NS_HTTP_ACTIVITY_SUBTYPE_RESPONSE_COMPLETE,
 43113:                 PR_Now(),
108991:                 static_cast<uint64_t>(mContentRead),
 43113:                 EmptyCString());
 43113: 
 43113:         // report that this transaction is closing
 43113:         mActivityDistributor->ObserveActivity(
 43113:             mChannel,
 43113:             NS_HTTP_ACTIVITY_TYPE_HTTP_TRANSACTION,
 43113:             NS_HTTP_ACTIVITY_SUBTYPE_TRANSACTION_CLOSE,
120112:             PR_Now(), 0, EmptyCString());
 43113:     }
 43113: 
 43113:     // we must no longer reference the connection!  find out if the 
 43113:     // connection was being reused before letting it go.
 79445:     bool connReused = false;
 43113:     if (mConnection)
 43113:         connReused = mConnection->IsReused();
 80486:     mConnected = false;
 43113: 
 43113:     //
 43113:     // if the connection was reset or closed before we wrote any part of the
 43113:     // request or if we wrote the request but didn't receive any part of the
 43113:     // response and the connection was being reused, then we can (and really
 43113:     // should) assume that we wrote to a stale connection and we must therefore
 43113:     // repeat the request over a new connection.
 43113:     //
 43113:     // NOTE: the conditions under which we will automatically retry the HTTP
 43113:     // request have to be carefully selected to avoid duplication of the
 43113:     // request from the point-of-view of the server.  such duplication could
 43113:     // have dire consequences including repeated purchases, etc.
 43113:     //
 43113:     // NOTE: because of the way SSL proxy CONNECT is implemented, it is
 43113:     // possible that the transaction may have received data without having
 43113:     // sent any data.  for this reason, mSendData == FALSE does not imply
 43113:     // mReceivedData == FALSE.  (see bug 203057 for more info.)
 43113:     //
 43113:     if (reason == NS_ERROR_NET_RESET || reason == NS_OK) {
 98400: 
 98400:         // reallySentData is meant to separate the instances where data has
 98400:         // been sent by this transaction but buffered at a higher level while
 98400:         // a TLS session (perhaps via a tunnel) is setup.
 98400:         bool reallySentData =
 98400:             mSentData && (!mConnection || mConnection->BytesWritten());
 98400:         
 98400:         if (!mReceivedData &&
 98400:             (!reallySentData || connReused || mPipelinePosition)) {
 43113:             // if restarting fails, then we must proceed to close the pipe,
 43113:             // which will notify the channel that the transaction failed.
 93840:             
 93840:             if (mPipelinePosition) {
 93840:                 gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
 93840:                     mConnInfo, nsHttpConnectionMgr::RedCanceledPipeline,
106838:                     nullptr, 0);
 93840:             }
 43113:             if (NS_SUCCEEDED(Restart()))
 43113:                 return;
 43113:         }
 93845:         else if (!mResponseIsComplete && mPipelinePosition &&
 93845:                  reason == NS_ERROR_NET_RESET) {
 93845:             // due to unhandled rst on a pipeline - safe to
 93845:             // restart as only idempotent is found there
 93845: 
 93845:             gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
106838:                 mConnInfo, nsHttpConnectionMgr::RedCorruptedContent, nullptr, 0);
 93845:             if (NS_SUCCEEDED(RestartInProgress()))
 93845:                 return;
 93845:         }
 43113:     }
 43113: 
 79445:     bool relConn = true;
 43113:     if (NS_SUCCEEDED(reason)) {
 93840:         if (!mResponseIsComplete) {
 93840:             // The response has not been delimited with a high-confidence
 93840:             // algorithm like Content-Length or Chunked Encoding. We
 93840:             // need to use a strong framing mechanism to pipeline.
 93840:             gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
 93840:                 mConnInfo, nsHttpConnectionMgr::BadInsufficientFraming,
106838:                 nullptr, mClassification);
 93840:         }
 93840:         else if (mPipelinePosition) {
 93840:             // report this success as feedback
 93840:             gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
 93840:                 mConnInfo, nsHttpConnectionMgr::GoodCompletedOK,
106838:                 nullptr, mPipelinePosition);
 93840:         }
 93840: 
 43113:         // the server has not sent the final \r\n terminating the header
 43113:         // section, and there may still be a header line unparsed.  let's make
 43113:         // sure we parse the remaining header line, and then hopefully, the
 77826:         // response will be usable (see bug 88792).
 43113:         if (!mHaveAllHeaders) {
 43113:             char data = '\n';
108991:             uint32_t unused;
 43113:             ParseHead(&data, 1, &unused);
 77826: 
 77826:             if (mResponseHead->Version() == NS_HTTP_VERSION_0_9) {
 77826:                 // Reject 0 byte HTTP/0.9 Responses - bug 423506
 77826:                 LOG(("nsHttpTransaction::Close %p 0 Byte 0.9 Response", this));
 77826:                 reason = NS_ERROR_NET_RESET;
 77826:             }
 43113:         }
 43113: 
 43113:         // honor the sticky connection flag...
 43113:         if (mCaps & NS_HTTP_STICKY_CONNECTION)
 80486:             relConn = false;
 43113:     }
102984: 
102984:     // mTimings.responseEnd is normally recorded based on the end of a
102984:     // HTTP delimiter such as chunked-encodings or content-length. However,
102984:     // EOF or an error still require an end time be recorded.
102984:     if (TimingEnabled() &&
102984:         mTimings.responseEnd.IsNull() && !mTimings.responseStart.IsNull())
119958:         mTimings.responseEnd = TimeStamp::Now();
102984: 
 43113:     if (relConn && mConnection)
 43113:         NS_RELEASE(mConnection);
 43113: 
 43113:     mStatus = reason;
 80486:     mTransactionDone = true; // forcibly flag the transaction as complete
 80486:     mClosed = true;
124828:     ReleaseBlockingTransaction();
 43113: 
 43113:     // release some resources that we no longer need
106838:     mRequestStream = nullptr;
 43113:     mReqHeaderBuf.Truncate();
 43113:     mLineBuf.Truncate();
 43113:     if (mChunkedDecoder) {
 43113:         delete mChunkedDecoder;
106838:         mChunkedDecoder = nullptr;
 43113:     }
 43113: 
 43113:     // closing this pipe triggers the channel's OnStopRequest method.
 43113:     mPipeOut->CloseWithStatus(reason);
 43113: }
 43113: 
 93838: nsresult
 93838: nsHttpTransaction::AddTransaction(nsAHttpTransaction *trans)
 93838: {
 93838:     return NS_ERROR_NOT_IMPLEMENTED;
 93838: }
 93838: 
108991: uint32_t
 93840: nsHttpTransaction::PipelineDepth()
 93838: {
 93840:     return IsDone() ? 0 : 1;
 93838: }
 93838: 
 93839: nsresult
108991: nsHttpTransaction::SetPipelinePosition(int32_t position)
 93839: {
 93839:     mPipelinePosition = position;
 93839:     return NS_OK;
 93839: }
 93839:  
108991: int32_t
 93839: nsHttpTransaction::PipelinePosition()
 93839: {
 93839:     return mPipelinePosition;
 93839: }
 93839: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpTransaction <private>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: nsresult
 93845: nsHttpTransaction::RestartInProgress()
 93845: {
 93845:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
 93845:     
 94866:     if ((mRestartCount + 1) >= gHttpHandler->MaxRequestAttempts()) {
 94866:         LOG(("nsHttpTransaction::RestartInProgress() "
 94866:              "reached max request attempts, failing transaction %p\n", this));
 94866:         return NS_ERROR_NET_RESET;
 94866:     }
 94866: 
 93845:     // Lock RestartInProgress() and TakeResponseHead() against main thread
 93845:     MutexAutoLock lock(*nsHttp::GetLock());
 93845: 
 94866:     // Don't try and RestartInProgress() things that haven't gotten a response
 94866:     // header yet. Those should be handled under the normal restart() path if
 94866:     // they are eligible.
 94866:     if (!mHaveAllHeaders)
 94866:         return NS_ERROR_NET_RESET;
 94866: 
 94793:     // don't try and restart 0.9 or non 200/Get HTTP/1
 94866:     if (!mRestartInProgressVerifier.IsSetup())
 93845:         return NS_ERROR_NET_RESET;
 93845: 
 93845:     LOG(("Will restart transaction %p and skip first %lld bytes, "
 93845:          "old Content-Length %lld",
 93845:          this, mContentRead, mContentLength));
 93845: 
 93845:     mRestartInProgressVerifier.SetAlreadyProcessed(
115357:         NS_MAX(mRestartInProgressVerifier.AlreadyProcessed(), mContentRead));
 93845: 
 94866:     if (!mResponseHeadTaken && !mForTakeResponseHead) {
 93845:         // TakeResponseHeader() has not been called yet and this
 93845:         // is the first restart. Store the resp headers exclusively
 94866:         // for TakeResponseHead() which is called from the main thread and
 94866:         // could happen at any time - so we can't continue to modify those
 94866:         // headers (which restarting will effectively do)
 93845:         mForTakeResponseHead = mResponseHead;
106838:         mResponseHead = nullptr;
 93845:     }
 93845: 
 93845:     if (mResponseHead) {
 93845:         mResponseHead->Reset();
 93845:     }
 93845: 
 93845:     mContentRead = 0;
 93845:     mContentLength = -1;
 93845:     delete mChunkedDecoder;
106838:     mChunkedDecoder = nullptr;
 93845:     mHaveStatusLine = false;
 93845:     mHaveAllHeaders = false;
 93845:     mHttpResponseMatched = false;
 93845:     mResponseIsComplete = false;
 93845:     mDidContentStart = false;
 93845:     mNoContent = false;
 93845:     mSentData = false;
 93845:     mReceivedData = false;
 93845: 
 93845:     return Restart();
 93845: }
 93845: 
 93845: nsresult
 43113: nsHttpTransaction::Restart()
 43113: {
 43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
 43113: 
 43113:     // limit the number of restart attempts - bug 92224
 43113:     if (++mRestartCount >= gHttpHandler->MaxRequestAttempts()) {
 43113:         LOG(("reached max request attempts, failing transaction @%x\n", this));
 43113:         return NS_ERROR_NET_RESET;
 43113:     }
 43113: 
 43113:     LOG(("restarting transaction @%x\n", this));
 43113: 
 43113:     // rewind streams in case we already wrote out the request
 43113:     nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mRequestStream);
 43113:     if (seekable)
 43113:         seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
 43113: 
 43113:     // clear old connection state...
 43113:     mSecurityInfo = 0;
 43113:     NS_IF_RELEASE(mConnection);
 43113: 
 43113:     // disable pipelining for the next attempt in case pipelining caused the
 43113:     // reset.  this is being overly cautious since we don't know if pipelining
 43113:     // was the problem here.
 43113:     mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
103256:     SetPipelinePosition(0);
 43113: 
 43113:     return gHttpHandler->InitiateTransaction(this, mPriority);
 43113: }
 43113: 
 58521: char *
108991: nsHttpTransaction::LocateHttpStart(char *buf, uint32_t len,
 79445:                                    bool aAllowPartialMatch)
 58521: {
 58521:     NS_ASSERTION(!aAllowPartialMatch || mLineBuf.IsEmpty(), "ouch");
 58521: 
 58521:     static const char HTTPHeader[] = "HTTP/1.";
108991:     static const uint32_t HTTPHeaderLen = sizeof(HTTPHeader) - 1;
 62992:     static const char HTTP2Header[] = "HTTP/2.0";
108991:     static const uint32_t HTTP2HeaderLen = sizeof(HTTP2Header) - 1;
 58521:     
 62188:     if (aAllowPartialMatch && (len < HTTPHeaderLen))
106838:         return (PL_strncasecmp(buf, HTTPHeader, len) == 0) ? buf : nullptr;
 62188: 
 58521:     // mLineBuf can contain partial match from previous search
 58521:     if (!mLineBuf.IsEmpty()) {
 58521:         NS_ASSERTION(mLineBuf.Length() < HTTPHeaderLen, "ouch");
108991:         int32_t checkChars = NS_MIN(len, HTTPHeaderLen - mLineBuf.Length());
 58521:         if (PL_strncasecmp(buf, HTTPHeader + mLineBuf.Length(),
 58521:                            checkChars) == 0) {
 58521:             mLineBuf.Append(buf, checkChars);
 58521:             if (mLineBuf.Length() == HTTPHeaderLen) {
 58521:                 // We've found whole HTTPHeader sequence. Return pointer at the
 58521:                 // end of matched sequence since it is stored in mLineBuf.
 58521:                 return (buf + checkChars);
 58521:             }
 58521:             // Response matches pattern but is still incomplete.
 58521:             return 0;
 58521:         }
 58521:         // Previous partial match together with new data doesn't match the
 58521:         // pattern. Start the search again.
 58521:         mLineBuf.Truncate();
 58521:     }
 58521: 
 79445:     bool firstByte = true;
 58521:     while (len > 0) {
108991:         if (PL_strncasecmp(buf, HTTPHeader, NS_MIN<uint32_t>(len, HTTPHeaderLen)) == 0) {
 58521:             if (len < HTTPHeaderLen) {
 58521:                 // partial HTTPHeader sequence found
 58521:                 // save partial match to mLineBuf
 58521:                 mLineBuf.Assign(buf, len);
 58521:                 return 0;
 58521:             }
 58521: 
 58521:             // whole HTTPHeader sequence found
 58521:             return buf;
 58521:         }
 62992: 
 62992:         // At least "SmarterTools/2.0.3974.16813" generates nonsensical
 62992:         // HTTP/2.0 responses to our HTTP/1 requests. Treat the minimal case of
 62992:         // it as HTTP/1.1 to be compatible with old versions of ourselves and
 62992:         // other browsers
 62992: 
 62992:         if (firstByte && !mInvalidResponseBytesRead && len >= HTTP2HeaderLen &&
 62992:             (PL_strncasecmp(buf, HTTP2Header, HTTP2HeaderLen) == 0)) {
 62992:             LOG(("nsHttpTransaction:: Identified HTTP/2.0 treating as 1.x\n"));
 62992:             return buf;
 62992:         }
 62992: 
 62992:         if (!nsCRT::IsAsciiSpace(*buf))
 80486:             firstByte = false;
 58521:         buf++;
 58521:         len--;
 58521:     }
 58521:     return 0;
 58521: }
 58521: 
 71093: nsresult
 43113: nsHttpTransaction::ParseLine(char *line)
 43113: {
 43113:     LOG(("nsHttpTransaction::ParseLine [%s]\n", line));
 71093:     nsresult rv = NS_OK;
 43113:     
 43113:     if (!mHaveStatusLine) {
 43113:         mResponseHead->ParseStatusLine(line);
 80486:         mHaveStatusLine = true;
 43113:         // XXX this should probably never happen
 43113:         if (mResponseHead->Version() == NS_HTTP_VERSION_0_9)
 80486:             mHaveAllHeaders = true;
 43113:     }
 71093:     else {
 71093:         rv = mResponseHead->ParseHeaderLine(line);
 71093:     }
 71093:     return rv;
 43113: }
 43113: 
 43113: nsresult
108991: nsHttpTransaction::ParseLineSegment(char *segment, uint32_t len)
 43113: {
 43113:     NS_PRECONDITION(!mHaveAllHeaders, "already have all headers");
 43113: 
 43113:     if (!mLineBuf.IsEmpty() && mLineBuf.Last() == '\n') {
 43113:         // trim off the new line char, and if this segment is
 43113:         // not a continuation of the previous or if we haven't
 43113:         // parsed the status line yet, then parse the contents
 43113:         // of mLineBuf.
 43113:         mLineBuf.Truncate(mLineBuf.Length() - 1);
 43113:         if (!mHaveStatusLine || (*segment != ' ' && *segment != '\t')) {
 71093:             nsresult rv = ParseLine(mLineBuf.BeginWriting());
 43113:             mLineBuf.Truncate();
 71093:             if (NS_FAILED(rv)) {
 93840:                 gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
 93840:                     mConnInfo, nsHttpConnectionMgr::RedCorruptedContent,
106838:                     nullptr, 0);
 71093:                 return rv;
 71093:             }
 43113:         }
 43113:     }
 43113: 
 43113:     // append segment to mLineBuf...
 43113:     mLineBuf.Append(segment, len);
 43113:     
 43113:     // a line buf with only a new line char signifies the end of headers.
 43113:     if (mLineBuf.First() == '\n') {
 43113:         mLineBuf.Truncate();
 43113:         // discard this response if it is a 100 continue or other 1xx status.
108991:         uint16_t status = mResponseHead->Status();
 70090:         if ((status != 101) && (status / 100 == 1)) {
 43113:             LOG(("ignoring 1xx response\n"));
 80486:             mHaveStatusLine = false;
 80486:             mHttpResponseMatched = false;
 80486:             mConnection->SetLastTransactionExpectedNoContent(true);
 43113:             mResponseHead->Reset();
 43113:             return NS_OK;
 43113:         }
 80486:         mHaveAllHeaders = true;
 43113:     }
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpTransaction::ParseHead(char *buf,
108991:                              uint32_t count,
108991:                              uint32_t *countRead)
 43113: {
 43113:     nsresult rv;
108991:     uint32_t len;
 43113:     char *eol;
 43113: 
 43113:     LOG(("nsHttpTransaction::ParseHead [count=%u]\n", count));
 43113: 
 43113:     *countRead = 0;
 43113: 
 43113:     NS_PRECONDITION(!mHaveAllHeaders, "oops");
 43113:         
 43113:     // allocate the response head object if necessary
 43113:     if (!mResponseHead) {
 43113:         mResponseHead = new nsHttpResponseHead();
 43113:         if (!mResponseHead)
 43113:             return NS_ERROR_OUT_OF_MEMORY;
 43113: 
 43113:         // report that we have a least some of the response
 93845:         if (mActivityDistributor && !mReportedStart) {
 93845:             mReportedStart = true;
 43113:             mActivityDistributor->ObserveActivity(
 43113:                 mChannel,
 43113:                 NS_HTTP_ACTIVITY_TYPE_HTTP_TRANSACTION,
 43113:                 NS_HTTP_ACTIVITY_SUBTYPE_RESPONSE_START,
120112:                 PR_Now(), 0, EmptyCString());
 43113:         }
 93845:     }
 43113: 
 58521:     if (!mHttpResponseMatched) {
 61543:         // Normally we insist on seeing HTTP/1.x in the first few bytes,
 61543:         // but if we are on a persistent connection and the previous transaction
 61543:         // was not supposed to have any content then we need to be prepared
 61543:         // to skip over a response body that the server may have sent even
 61543:         // though it wasn't allowed.
 61543:         if (!mConnection || !mConnection->LastTransactionExpectedNoContent()) {
 61543:             // tolerate only minor junk before the status line
 80486:             mHttpResponseMatched = true;
108991:             char *p = LocateHttpStart(buf, NS_MIN<uint32_t>(count, 11), true);
 43113:             if (!p) {
 43113:                 // Treat any 0.9 style response of a put as a failure.
 43113:                 if (mRequestHead->Method() == nsHttp::Put)
 43113:                     return NS_ERROR_ABORT;
 43113: 
 43113:                 mResponseHead->ParseStatusLine("");
 80486:                 mHaveStatusLine = true;
 80486:                 mHaveAllHeaders = true;
 43113:                 return NS_OK;
 43113:             }
 43113:             if (p > buf) {
 43113:                 // skip over the junk
 61543:                 mInvalidResponseBytesRead += p - buf;
 43113:                 *countRead = p - buf;
 43113:                 buf = p;
 43113:             }
 43113:         }
 58521:         else {
 80486:             char *p = LocateHttpStart(buf, count, false);
 58521:             if (p) {
 61543:                 mInvalidResponseBytesRead += p - buf;
 58521:                 *countRead = p - buf;
 58521:                 buf = p;
 80486:                 mHttpResponseMatched = true;
 58521:             } else {
 61543:                 mInvalidResponseBytesRead += count;
 58521:                 *countRead = count;
 61543:                 if (mInvalidResponseBytesRead > MAX_INVALID_RESPONSE_BODY_SIZE) {
 61543:                     LOG(("nsHttpTransaction::ParseHead() "
 61543:                          "Cannot find Response Header\n"));
 61543:                     // cannot go back and call this 0.9 anymore as we
 61543:                     // have thrown away a lot of the leading junk
 61543:                     return NS_ERROR_ABORT;
 61543:                 }
 58521:                 return NS_OK;
 58521:             }
 58521:         }
 58521:     }
 43113:     // otherwise we can assume that we don't have a HTTP/0.9 response.
 43113: 
 64671:     NS_ABORT_IF_FALSE (mHttpResponseMatched, "inconsistent");
106838:     while ((eol = static_cast<char *>(memchr(buf, '\n', count - *countRead))) != nullptr) {
 43113:         // found line in range [buf:eol]
 43113:         len = eol - buf + 1;
 43113: 
 43113:         *countRead += len;
 43113: 
 43113:         // actually, the line is in the range [buf:eol-1]
 43113:         if ((eol > buf) && (*(eol-1) == '\r'))
 43113:             len--;
 43113: 
 43113:         buf[len-1] = '\n';
 43113:         rv = ParseLineSegment(buf, len);
 43113:         if (NS_FAILED(rv))
 43113:             return rv;
 43113: 
 43113:         if (mHaveAllHeaders)
 43113:             return NS_OK;
 43113: 
 43113:         // skip over line
 43113:         buf = eol + 1;
 64671: 
 64671:         if (!mHttpResponseMatched) {
 64671:             // a 100 class response has caused us to throw away that set of
 64671:             // response headers and look for the next response
 64671:             return NS_ERROR_NET_INTERRUPT;
 64671:         }
 43113:     }
 43113: 
 43113:     // do something about a partial header line
 43113:     if (!mHaveAllHeaders && (len = count - *countRead)) {
 43113:         *countRead = count;
 43113:         // ignore a trailing carriage return, and don't bother calling
 43113:         // ParseLineSegment if buf only contains a carriage return.
 43113:         if ((buf[len-1] == '\r') && (--len == 0))
 43113:             return NS_OK;
 43113:         rv = ParseLineSegment(buf, len);
 43113:         if (NS_FAILED(rv))
 43113:             return rv;
 43113:     }
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: // called on the socket thread
 43113: nsresult
 43113: nsHttpTransaction::HandleContentStart()
 43113: {
 43113:     LOG(("nsHttpTransaction::HandleContentStart [this=%x]\n", this));
 43113: 
 43113:     if (mResponseHead) {
 43113: #if defined(PR_LOGGING)
 43113:         if (LOG3_ENABLED()) {
 43113:             LOG3(("http response [\n"));
110974:             nsAutoCString headers;
 80486:             mResponseHead->Flatten(headers, false);
 43113:             LogHeaders(headers.get());
 43113:             LOG3(("]\n"));
 43113:         }
 43113: #endif
108528:         // Save http version, mResponseHead isn't available anymore after
108528:         // TakeResponseHead() is called
108528:         mHttpVersion = mResponseHead->Version();
108528: 
 43113:         // notify the connection, give it a chance to cause a reset.
 79445:         bool reset = false;
 93845:         if (!mRestartInProgressVerifier.IsSetup())
 43113:             mConnection->OnHeadersAvailable(this, mRequestHead, mResponseHead, &reset);
 43113: 
 43113:         // looks like we should ignore this response, resetting...
 43113:         if (reset) {
 43113:             LOG(("resetting transaction's response head\n"));
 80486:             mHaveAllHeaders = false;
 80486:             mHaveStatusLine = false;
 80486:             mReceivedData = false;
 80486:             mSentData = false;
 80486:             mHttpResponseMatched = false;
 43113:             mResponseHead->Reset();
 43113:             // wait to be called again...
 43113:             return NS_OK;
 43113:         }
 43113: 
 43113:         // check if this is a no-content response
 43113:         switch (mResponseHead->Status()) {
 70090:         case 101:
 80486:             mPreserveStream = true;    // fall through to other no content
 43113:         case 204:
 43113:         case 205:
 43113:         case 304:
 80486:             mNoContent = true;
 43113:             LOG(("this response should not contain a body.\n"));
 43113:             break;
 43113:         }
 97864:         
 97864:         if (mResponseHead->Status() == 200 &&
 97864:             mConnection->IsProxyConnectInProgress()) {
 97864:             // successful CONNECTs do not have response bodies
 97864:             mNoContent = true;
 97864:         }
 61543:         mConnection->SetLastTransactionExpectedNoContent(mNoContent);
 93840:         if (mInvalidResponseBytesRead)
 93840:             gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
 93840:                 mConnInfo, nsHttpConnectionMgr::BadInsufficientFraming,
106838:                 nullptr, mClassification);
 43113: 
 43113:         if (mNoContent)
 43113:             mContentLength = 0;
 43113:         else {
 43113:             // grab the content-length from the response headers
 43113:             mContentLength = mResponseHead->ContentLength();
 43113: 
 93843:             if ((mClassification != CLASS_SOLO) &&
 93843:                 (mContentLength > mMaxPipelineObjectSize))
 93843:                 CancelPipeline(nsHttpConnectionMgr::BadUnexpectedLarge);
 93843:             
 43113:             // handle chunked encoding here, so we'll know immediately when
 43113:             // we're done with the socket.  please note that _all_ other
 43113:             // decoding is done when the channel receives the content data
 43113:             // so as not to block the socket transport thread too much.
 43113:             // ignore chunked responses from HTTP/1.0 servers and proxies.
 43113:             if (mResponseHead->Version() >= NS_HTTP_VERSION_1_1 &&
 43113:                 mResponseHead->HasHeaderValue(nsHttp::Transfer_Encoding, "chunked")) {
 43113:                 // we only support the "chunked" transfer encoding right now.
 43113:                 mChunkedDecoder = new nsHttpChunkedDecoder();
 43113:                 if (!mChunkedDecoder)
 43113:                     return NS_ERROR_OUT_OF_MEMORY;
 43113:                 LOG(("chunked decoder created\n"));
 43113:                 // Ignore server specified Content-Length.
 43113:                 mContentLength = -1;
 43113:             }
 43113: #if defined(PR_LOGGING)
108991:             else if (mContentLength == int64_t(-1))
 43113:                 LOG(("waiting for the server to close the connection.\n"));
 43113: #endif
 43113:         }
 94866:         if (mRestartInProgressVerifier.IsSetup() &&
 93845:             !mRestartInProgressVerifier.Verify(mContentLength, mResponseHead)) {
 93845:             LOG(("Restart in progress subsequent transaction failed to match"));
 93845:             return NS_ERROR_ABORT;
 93845:         }
 43113:     }
 43113: 
 80486:     mDidContentStart = true;
 94866: 
 94866:     // The verifier only initializes itself once (from the first iteration of
 94866:     // a transaction that gets far enough to have response headers)
 94793:     if (mRequestHead->Method() == nsHttp::Get)
 93845:         mRestartInProgressVerifier.Set(mContentLength, mResponseHead);
 94866: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: // called on the socket thread
 43113: nsresult
 43113: nsHttpTransaction::HandleContent(char *buf,
108991:                                  uint32_t count,
108991:                                  uint32_t *contentRead,
108991:                                  uint32_t *contentRemaining)
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpTransaction::HandleContent [this=%x count=%u]\n", this, count));
 43113: 
 43113:     *contentRead = 0;
 43113:     *contentRemaining = 0;
 43113: 
 43113:     NS_ASSERTION(mConnection, "no connection");
 43113: 
 43113:     if (!mDidContentStart) {
 43113:         rv = HandleContentStart();
 43113:         if (NS_FAILED(rv)) return rv;
 43113:         // Do not write content to the pipe if we haven't started streaming yet
 43113:         if (!mDidContentStart)
 43113:             return NS_OK;
 43113:     }
 43113: 
 43113:     if (mChunkedDecoder) {
 43113:         // give the buf over to the chunked decoder so it can reformat the
 43113:         // data and tell us how much is really there.
 43113:         rv = mChunkedDecoder->HandleChunkedContent(buf, count, contentRead, contentRemaining);
 43113:         if (NS_FAILED(rv)) return rv;
 43113:     }
108991:     else if (mContentLength >= int64_t(0)) {
 43113:         // HTTP/1.0 servers have been known to send erroneous Content-Length
 43113:         // headers. So, unless the connection is persistent, we must make
 43113:         // allowances for a possibly invalid Content-Length header. Thus, if
 43113:         // NOT persistent, we simply accept everything in |buf|.
108528:         if (mConnection->IsPersistent() || mPreserveStream ||
108528:             mHttpVersion >= NS_HTTP_VERSION_1_1) {
108991:             int64_t remaining = mContentLength - mContentRead;
108991:             *contentRead = uint32_t(NS_MIN<int64_t>(count, remaining));
 43113:             *contentRemaining = count - *contentRead;
 43113:         }
 43113:         else {
 43113:             *contentRead = count;
 43113:             // mContentLength might need to be increased...
108991:             int64_t position = mContentRead + int64_t(count);
 43113:             if (position > mContentLength) {
 43113:                 mContentLength = position;
 43113:                 //mResponseHead->SetContentLength(mContentLength);
 43113:             }
 43113:         }
 43113:     }
 43113:     else {
 43113:         // when we are just waiting for the server to close the connection...
 43113:         // (no explicit content-length given)
 43113:         *contentRead = count;
 43113:     }
 43113:     
108991:     int64_t toReadBeforeRestart =
 94866:         mRestartInProgressVerifier.ToReadBeforeRestart();
 94866: 
 94866:     if (toReadBeforeRestart && *contentRead) {
108991:         uint32_t ignore =
115367:             static_cast<uint32_t>(NS_MIN<int64_t>(toReadBeforeRestart, UINT32_MAX));
115357:         ignore = NS_MIN(*contentRead, ignore);
 93845:         LOG(("Due To Restart ignoring %d of remaining %ld",
 94866:              ignore, toReadBeforeRestart));
 93845:         *contentRead -= ignore;
 93845:         mContentRead += ignore;
 94866:         mRestartInProgressVerifier.HaveReadBeforeRestart(ignore);
 93845:         memmove(buf, buf + ignore, *contentRead + *contentRemaining);
 93845:     }
 93845: 
 43113:     if (*contentRead) {
 43113:         // update count of content bytes read and report progress...
 43113:         mContentRead += *contentRead;
 72496:         /* when uncommenting, take care of 64-bit integers w/ NS_MAX...
 43113:         if (mProgressSink)
106838:             mProgressSink->OnProgress(nullptr, nullptr, mContentRead, NS_MAX(0, mContentLength));
 43113:         */
 43113:     }
 43113: 
 43113:     LOG(("nsHttpTransaction::HandleContent [this=%x count=%u read=%u mContentRead=%lld mContentLength=%lld]\n",
 64616:         this, count, *contentRead, mContentRead, mContentLength));
 43113: 
 93843:     // Check the size of chunked responses. If we exceed the max pipeline size
 93843:     // for this response reschedule the pipeline
 93843:     if ((mClassification != CLASS_SOLO) &&
 93843:         mChunkedDecoder &&
 94988:         ((mContentRead + mChunkedDecoder->GetChunkRemaining()) >
 94988:          mMaxPipelineObjectSize)) {
 93843:         CancelPipeline(nsHttpConnectionMgr::BadUnexpectedLarge);
 94988:     }
 93843: 
 43113:     // check for end-of-file
 43113:     if ((mContentRead == mContentLength) ||
 43113:         (mChunkedDecoder && mChunkedDecoder->ReachedEOF())) {
 43113:         // the transaction is done with a complete response.
 80486:         mTransactionDone = true;
 80486:         mResponseIsComplete = true;
124828:         ReleaseBlockingTransaction();
 43113: 
 76927:         if (TimingEnabled())
119958:             mTimings.responseEnd = TimeStamp::Now();
 76927: 
 43113:         // report the entire response has arrived
 43113:         if (mActivityDistributor)
 43113:             mActivityDistributor->ObserveActivity(
 43113:                 mChannel,
 43113:                 NS_HTTP_ACTIVITY_TYPE_HTTP_TRANSACTION,
 43113:                 NS_HTTP_ACTIVITY_SUBTYPE_RESPONSE_COMPLETE,
 43113:                 PR_Now(),
108991:                 static_cast<uint64_t>(mContentRead),
 43113:                 EmptyCString());
 43113:     }
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
108991: nsHttpTransaction::ProcessData(char *buf, uint32_t count, uint32_t *countRead)
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpTransaction::ProcessData [this=%x count=%u]\n", this, count));
 43113: 
 43113:     *countRead = 0;
 43113: 
 43113:     // we may not have read all of the headers yet...
 43113:     if (!mHaveAllHeaders) {
108991:         uint32_t bytesConsumed = 0;
 43113: 
 64671:         do {
108991:             uint32_t localBytesConsumed = 0;
 64671:             char *localBuf = buf + bytesConsumed;
108991:             uint32_t localCount = count - bytesConsumed;
 64671:             
 64671:             rv = ParseHead(localBuf, localCount, &localBytesConsumed);
 64671:             if (NS_FAILED(rv) && rv != NS_ERROR_NET_INTERRUPT)
 64671:                 return rv;
 64671:             bytesConsumed += localBytesConsumed;
 64671:         } while (rv == NS_ERROR_NET_INTERRUPT);
 43113:         
 43113:         count -= bytesConsumed;
 43113: 
 43113:         // if buf has some content in it, shift bytes to top of buf.
 43113:         if (count && bytesConsumed)
 43113:             memmove(buf, buf + bytesConsumed, count);
 43113: 
 43113:         // report the completed response header
 93845:         if (mActivityDistributor && mResponseHead && mHaveAllHeaders &&
 93845:             !mReportedResponseHeader) {
 93845:             mReportedResponseHeader = true;
110974:             nsAutoCString completeResponseHeaders;
 80486:             mResponseHead->Flatten(completeResponseHeaders, false);
 43113:             completeResponseHeaders.AppendLiteral("\r\n");
 43113:             mActivityDistributor->ObserveActivity(
 43113:                 mChannel,
 43113:                 NS_HTTP_ACTIVITY_TYPE_HTTP_TRANSACTION,
 43113:                 NS_HTTP_ACTIVITY_SUBTYPE_RESPONSE_HEADER,
120112:                 PR_Now(), 0,
 43113:                 completeResponseHeaders);
 43113:         }
 43113:     }
 43113: 
 43113:     // even though count may be 0, we still want to call HandleContent
 43113:     // so it can complete the transaction if this is a "no-content" response.
 43113:     if (mHaveAllHeaders) {
108991:         uint32_t countRemaining = 0;
 43113:         //
 43113:         // buf layout:
 43113:         // 
 43113:         // +--------------------------------------+----------------+-----+
 43113:         // |              countRead               | countRemaining |     |
 43113:         // +--------------------------------------+----------------+-----+
 43113:         //
 43113:         // count          : bytes read from the socket
 43113:         // countRead      : bytes corresponding to this transaction
 43113:         // countRemaining : bytes corresponding to next pipelined transaction
 43113:         //
 43113:         // NOTE:
 43113:         // count > countRead + countRemaining <==> chunked transfer encoding
 43113:         //
 43113:         rv = HandleContent(buf, count, countRead, &countRemaining);
 43113:         if (NS_FAILED(rv)) return rv;
 43113:         // we may have read more than our share, in which case we must give
 43113:         // the excess bytes back to the connection
 43113:         if (mResponseIsComplete && countRemaining) {
 43113:             NS_ASSERTION(mConnection, "no connection");
 43113:             mConnection->PushBack(buf + *countRead, countRemaining);
 43113:         }
 43113:     }
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 93843: void
108991: nsHttpTransaction::CancelPipeline(uint32_t reason)
 93843: {
 93843:     // reason is casted through a uint to avoid compiler header deps
 93843:     gHttpHandler->ConnMgr()->PipelineFeedbackInfo(
 93843:         mConnInfo,
 93843:         static_cast<nsHttpConnectionMgr::PipelineFeedbackInfoType>(reason),
106838:         nullptr, mClassification);
 93843: 
 94988:     mConnection->CancelPipeline(NS_ERROR_ABORT);
 93843: 
 93843:     // Avoid pipelining this transaction on restart by classifying it as solo.
 93843:     // This also prevents BadUnexpectedLarge from being reported more
 93843:     // than one time per transaction.
 93843:     mClassification = CLASS_SOLO;
 93843: }
 93843: 
124828: // Called when the transaction marked for blocking is associated with a connection
124828: // (i.e. added to a spdy session, an idle http connection, or placed into
124828: // a http pipeline). It is safe to call this multiple times with it only
124828: // having an effect once.
124828: void
124828: nsHttpTransaction::DispatchedAsBlocking()
124828: {
124828:     if (mDispatchedAsBlocking)
124828:         return;
124828: 
124828:     LOG(("nsHttpTransaction %p dispatched as blocking\n", this));
124828:     
124828:     if (!mLoadGroupCI)
124828:         return;
124828: 
124828:     LOG(("nsHttpTransaction adding blocking channel %p from "
124828:          "loadgroup %p\n", this, mLoadGroupCI.get()));
124828:     
124828:     mLoadGroupCI->AddBlockingTransaction();
124828:     mDispatchedAsBlocking = true;
124828: }
124828: 
124828: void
124828: nsHttpTransaction::RemoveDispatchedAsBlocking()
124828: {
124828:     if (!mLoadGroupCI || !mDispatchedAsBlocking)
124828:         return;
124828:     
124828:     uint32_t blockers = 0;
124828:     nsresult rv = mLoadGroupCI->RemoveBlockingTransaction(&blockers);
124828: 
124828:     LOG(("nsHttpTransaction removing blocking channel %p from "
124828:          "loadgroup %p. %d blockers remain.\n", this,
124828:          mLoadGroupCI.get(), blockers));
124828: 
124828:     if (NS_SUCCEEDED(rv) && !blockers) {
124828:         LOG(("nsHttpTransaction %p triggering release of blocked channels.\n",
124828:              this));
124828:         gHttpHandler->ConnMgr()->ProcessPendingQ();
124828:     }
124828:     
124828:     mDispatchedAsBlocking = false;
124828: }
124828: 
124828: void
124828: nsHttpTransaction::ReleaseBlockingTransaction()
124828: {
124828:     RemoveDispatchedAsBlocking();
124828:     mLoadGroupCI = nullptr;
124828: }
124828: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpTransaction deletion event
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: class nsDeleteHttpTransaction : public nsRunnable {
 43113: public:
 43113:     nsDeleteHttpTransaction(nsHttpTransaction *trans)
 43113:         : mTrans(trans)
 43113:     {}
 43113: 
 43113:     NS_IMETHOD Run()
 43113:     {
 43113:         delete mTrans;
 43113:         return NS_OK;
 43113:     }
 43113: private:
 43113:     nsHttpTransaction *mTrans;
 43113: };
 43113: 
 43113: void
 43113: nsHttpTransaction::DeleteSelfOnConsumerThread()
 43113: {
 43113:     LOG(("nsHttpTransaction::DeleteSelfOnConsumerThread [this=%x]\n", this));
 43113:     
 79445:     bool val;
 71626:     if (!mConsumerTarget ||
 71626:         (NS_SUCCEEDED(mConsumerTarget->IsOnCurrentThread(&val)) && val)) {
 43113:         delete this;
 71626:     } else {
 43113:         LOG(("proxying delete to consumer thread...\n"));
 43113:         nsCOMPtr<nsIRunnable> event = new nsDeleteHttpTransaction(this);
 43113:         if (NS_FAILED(mConsumerTarget->Dispatch(event, NS_DISPATCH_NORMAL)))
 43113:             NS_WARNING("failed to dispatch nsHttpDeleteTransaction event");
 43113:     }
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpTransaction::nsISupports
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMPL_THREADSAFE_ADDREF(nsHttpTransaction)
 43113: 
 43113: NS_IMETHODIMP_(nsrefcnt)
 43113: nsHttpTransaction::Release()
 43113: {
 43113:     nsrefcnt count;
 43113:     NS_PRECONDITION(0 != mRefCnt, "dup release");
 64101:     count = NS_AtomicDecrementRefcnt(mRefCnt);
 43113:     NS_LOG_RELEASE(this, count, "nsHttpTransaction");
 43113:     if (0 == count) {
 43113:         mRefCnt = 1; /* stablize */
 43113:         // it is essential that the transaction be destroyed on the consumer 
 43113:         // thread (we could be holding the last reference to our consumer).
 43113:         DeleteSelfOnConsumerThread();
 43113:         return 0;
 43113:     }
 43113:     return count;
 43113: }
 43113: 
 43113: NS_IMPL_THREADSAFE_QUERY_INTERFACE2(nsHttpTransaction,
 43113:                                     nsIInputStreamCallback,
 43113:                                     nsIOutputStreamCallback)
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpTransaction::nsIInputStreamCallback
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: // called on the socket thread
 43113: NS_IMETHODIMP
 43113: nsHttpTransaction::OnInputStreamReady(nsIAsyncInputStream *out)
 43113: {
 43113:     if (mConnection) {
 88247:         mConnection->TransactionHasDataToWrite(this);
 88247:         nsresult rv = mConnection->ResumeSend();
 43113:         if (NS_FAILED(rv))
 43113:             NS_ERROR("ResumeSend failed");
 43113:     }
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpTransaction::nsIOutputStreamCallback
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: // called on the socket thread
 43113: NS_IMETHODIMP
 43113: nsHttpTransaction::OnOutputStreamReady(nsIAsyncOutputStream *out)
 43113: {
 43113:     if (mConnection) {
 88247:         nsresult rv = mConnection->ResumeRecv();
 43113:         if (NS_FAILED(rv))
 43113:             NS_ERROR("ResumeRecv failed");
 43113:     }
 43113:     return NS_OK;
 43113: }
 93845: 
 93845: // nsHttpTransaction::RestartVerifier
 93845: 
 93845: static bool
 93845: matchOld(nsHttpResponseHead *newHead, nsCString &old,
 93845:          nsHttpAtom headerAtom)
 93845: {
 93845:     const char *val;
 93845:     
 93845:     val = newHead->PeekHeader(headerAtom);
 93845:     if (val && old.IsEmpty())
 93845:         return false;
 93845:     if (!val && !old.IsEmpty())
 93845:         return false;
 93845:     if (val && !old.Equals(val))
 93845:         return false;
 93845:     return true;
 93845: }
 93845: 
 93845: bool
108991: nsHttpTransaction::RestartVerifier::Verify(int64_t contentLength,
 93845:                                            nsHttpResponseHead *newHead)
 93845: {
 93845:     if (mContentLength != contentLength)
 93845:         return false;
 93845: 
 94793:     if (newHead->Status() != 200)
 94793:         return false;
 94793: 
 93845:     if (!matchOld(newHead, mContentRange, nsHttp::Content_Range))
 93845:         return false;
 93845: 
 93845:     if (!matchOld(newHead, mLastModified, nsHttp::Last_Modified))
 93845:         return false;
 93845: 
 93845:     if (!matchOld(newHead, mETag, nsHttp::ETag))
 93845:         return false;
 93845: 
 93845:     if (!matchOld(newHead, mContentEncoding, nsHttp::Content_Encoding))
 93845:         return false;
 93845: 
 93845:     if (!matchOld(newHead, mTransferEncoding, nsHttp::Transfer_Encoding))
 93845:         return false;
 93845:     
 93845:     return true;
 93845: }
 93845: 
 93845: void
108991: nsHttpTransaction::RestartVerifier::Set(int64_t contentLength,
 93845:                                         nsHttpResponseHead *head)
 93845: {
 93845:     if (mSetup)
 93845:         return;
 93845: 
 94793:     // If mSetup does not transition to true RestartInPogress() is later
 94793:     // forbidden
 94793: 
 94793:     // Only RestartInProgress with 200 response code
 94793:     if (head->Status() != 200)
 94793:         return;
 94793: 
 93845:     mContentLength = contentLength;
 93845:     
 93845:     if (head) {
 93845:         const char *val;
 93845:         val = head->PeekHeader(nsHttp::ETag);
 93845:         if (val)
 93845:             mETag.Assign(val);
 93845:         val = head->PeekHeader(nsHttp::Last_Modified);
 93845:         if (val)
 93845:             mLastModified.Assign(val);
 93845:         val = head->PeekHeader(nsHttp::Content_Range);
 93845:         if (val)
 93845:             mContentRange.Assign(val);
 93845:         val = head->PeekHeader(nsHttp::Content_Encoding);
 93845:         if (val)
 93845:             mContentEncoding.Assign(val);
 93845:         val = head->PeekHeader(nsHttp::Transfer_Encoding);
 93845:         if (val)
 93845:             mTransferEncoding.Assign(val);
 94866: 
 94866:         // We can only restart with any confidence if we have a stored etag or
 94866:         // last-modified header
 94866:         if (mETag.IsEmpty() && mLastModified.IsEmpty())
 94866:             return;
 94866: 
 93845:         mSetup = true;
 93845:     }
 93845: }
