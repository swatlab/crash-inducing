    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla OS/2 libraries.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * John Fairhurst, <john_fairhurst@iname.com>.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Rich Walsh <dragtext@e-vertise.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  * This Original Code has been modified by IBM Corporation.
    1:  * Modifications made by IBM described herein are
    1:  * Copyright (c) International Business Machines
    1:  * Corporation, 2000
    1:  *
    1:  * Modifications to Mozilla code or documentation
    1:  * identified per MPL Section 3.3
    1:  *
    1:  * Date             Modified by     Description of modification
    1:  * 03/23/2000       IBM Corp.      Added InvalidateRegion method.
    1:  * 04/12/2000       IBM Corp.      Changed params on DispatchMouseEvent to match Windows..
    1:  * 04/14/2000       IBM Corp.      Declared EventIsInsideWindow for CaptureRollupEvents
    1:  * 06/15/2000       IBM Corp.      Added NS2PM for rectangles
    1:  * 06/21/2000       IBM Corp.      Added CaptureMouse
    1:  *
    1:  */
    1: 
    1: #ifndef _nswindow_h
    1: #define _nswindow_h
    1: 
    1: #include "nsWidgetDefs.h"
    1: #include "nsBaseWidget.h"
    1: #include "nsToolkit.h"
    1: #include "nsSwitchToUIThread.h"
 5828: #include "gfxOS2Surface.h"
 5828: #include "gfxContext.h"
    1: 
    1: class imgIContainer;
    1: 
    1: //#define DEBUG_FOCUS
    1: 
    1: #ifdef DEBUG_FOCUS
    1:   #define DEBUGFOCUS(what) printf("[%x] "#what" (%d)\n", (int)this, mWindowIdentifier)
    1: #else
    1:   #define DEBUGFOCUS(what)
    1: #endif
    1: 
    1: // Base widget class.
    1: // This is abstract.  Controls (labels, radio buttons, listboxen) derive
    1: // from here.  A thing called a child window derives from here, and the
 9710: // frame window class derives from the child.
 9710: // nsFrameWindow is separate because work needs to be done there to decide
 9710: // whether methods apply to frame or client.
    1: 
    1: /* Possible states of the window, used to emulate windows better... */
    1:    // default state; Create() not called 
    1:    #define   nsWindowState_ePrecreate      0x00000001
    1:    // processing Create() method          
    1:    #define   nsWindowState_eInCreate       0x00000002
    1:    // active, existing window             
    1:    #define      nsWindowState_eLive        0x00000004
    1:    //processing Close() method            
    1:    #define      nsWindowState_eClosing     0x00000008
    1:    // object destructor running 
    1:    #define      nsWindowState_eDoingDelete 0x00000010
    1:    // window destroyed 
    1:    #define      nsWindowState_eDead        0x00000100         
    1: 
    1: MRESULT EXPENTRY fnwpNSWindow( HWND, ULONG, MPARAM, MPARAM);
    1: MRESULT EXPENTRY fnwpFrame( HWND, ULONG, MPARAM, MPARAM);
    1: 
    1: class nsWindow : public nsBaseWidget,
    1:                  public nsSwitchToUIThread
    1: {
    1:  public:
    1:    // Scaffolding
    1:    nsWindow();
    1:    virtual ~nsWindow();
    1: 
    1:    static void ReleaseGlobals();
    1: 
    1:    // nsIWidget
    1: 
    1:    // Creation from native (eh?) or widget parent, destroy
    1:    NS_IMETHOD Create( nsIWidget *aParent,
23850:                       const nsIntRect &aRect,
    1:                       EVENT_CALLBACK aHandleEventFunction,
    1:                       nsIDeviceContext *aContext,
    1:                       nsIAppShell *aAppShell = nsnull,
    1:                       nsIToolkit *aToolkit = nsnull,
    1:                       nsWidgetInitData *aInitData = nsnull);
    1:    NS_IMETHOD Create( nsNativeWidget aParent,
23850:                       const nsIntRect &aRect,
    1:                       EVENT_CALLBACK aHandleEventFunction,
    1:                       nsIDeviceContext *aContext,
    1:                       nsIAppShell *aAppShell = nsnull,
    1:                       nsIToolkit *aToolkit = nsnull,
    1:                       nsWidgetInitData *aInitData = nsnull);
    1:    gfxASurface* GetThebesSurface();
    1:    NS_IMETHOD Destroy(); // call before releasing
    1: 
    1:    // Hierarchy: only interested in widget children (it seems)
    1:    virtual nsIWidget *GetParent();
    1: 
    1:    NS_IMETHOD SetSizeMode(PRInt32 aMode);
    1: 
    1:    // Physical properties
    1:    NS_IMETHOD Show( PRBool bState);
    1:    NS_IMETHOD ConstrainPosition(PRBool aAllowSlop, PRInt32 *aX, PRInt32 *aY);
    1:    NS_IMETHOD Move( PRInt32 aX, PRInt32 aY);
    1:    NS_IMETHOD Resize( PRInt32 aWidth,
    1:                       PRInt32 aHeight,
    1:                       PRBool   aRepaint);
    1:    NS_IMETHOD Resize( PRInt32 aX,
    1:                       PRInt32 aY,
    1:                       PRInt32 aWidth,
    1:                       PRInt32 aHeight,
    1:                       PRBool   aRepaint);
23850:    NS_IMETHOD GetClientBounds( nsIntRect &aRect);
    1:    NS_IMETHOD Enable( PRBool aState);
    1:    NS_IMETHOD IsEnabled(PRBool *aState);
    1:    NS_IMETHOD SetFocus(PRBool aRaise);
23850:    NS_IMETHOD GetBounds(nsIntRect &aRect);
    1:    NS_IMETHOD IsVisible( PRBool &aState);
    1:    NS_IMETHOD PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
    1:                           nsIWidget *aWidget, PRBool aActivate);
13220:    NS_IMETHOD SetZIndex(PRInt32 aZIndex);
    1: 
    1:    NS_IMETHOD CaptureMouse(PRBool aCapture);
    1: 
    1:    NS_IMETHOD BeginResizingChildren();
    1:    NS_IMETHOD EndResizingChildren();
25183:    virtual nsIntPoint WidgetToScreenOffset();
    1:    NS_IMETHOD DispatchEvent( struct nsGUIEvent *event, nsEventStatus &aStatus);
    1:    NS_IMETHOD CaptureRollupEvents(nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent);
    1: 
26911:    NS_IMETHOD              GetLastInputEventTime(PRUint32& aTime);
    1: 
    1:    // Widget appearance
    1:    NS_IMETHOD              SetCursor( nsCursor aCursor);
    1:    NS_IMETHOD              SetCursor(imgIContainer* aCursor,
    1:                                      PRUint32 aHotspotX, PRUint32 aHotspotY);
    1:    NS_IMETHOD              HideWindowChrome(PRBool aShouldHide);
    1:    NS_IMETHOD              SetTitle( const nsAString& aTitle); 
    1:    NS_IMETHOD              SetIcon(const nsAString& aIconSpec); 
    1:    NS_IMETHOD              Invalidate( PRBool aIsSynchronous);
23850:    NS_IMETHOD              Invalidate( const nsIntRect & aRect, PRBool aIsSynchronous);
    1:    NS_IMETHOD              Update();
23850:    NS_IMETHOD              Scroll( PRInt32 aDx, PRInt32 aDy, nsIntRect *aClipRect);
    1: 
    1:    // Get a HWND or a HPS.
    1:    virtual void  *GetNativeData( PRUint32 aDataType);
    1:    virtual void   FreeNativeData( void *aDatum, PRUint32 aDataType);
    1:    virtual HWND   GetMainWindow() const           { return mWnd; }
    1: 
    1:    // nsSwitchToPMThread interface
    1:    virtual BOOL CallMethod(MethodInfo *info);
    1: 
    1:    // PM methods which need to be public (menus, etc)
    1:    ULONG  GetNextID()    { return mNextID++; }
    1:    void   NS2PM_PARENT( POINTL &ptl);
    1:    void   NS2PM( POINTL &ptl);
    1:    void   NS2PM( RECTL &rcl);
    1: 
    1: protected:
    1:    static  BOOL            DealWithPopups ( ULONG inMsg, MRESULT* outResult ) ;
    1: 
    1:    static  PRBool          EventIsInsideWindow(nsWindow* aWindow); 
    1: 
    1:    static  nsWindow *      GetNSWindowPtr(HWND aWnd);
    1:    static  BOOL            SetNSWindowPtr(HWND aWnd, nsWindow * ptr);
    1: 
    1:    static  nsWindow*   gCurrentWindow;
    1:    // nsWindow methods subclasses must provide for creation to work
    1:    virtual PCSZ  WindowClass();
    1:    virtual ULONG WindowStyle();
    1: 
    1:    // hooks subclasses may wish to override!
    1:    virtual void     PostCreateWidget()            {}
    1:    virtual PRInt32  GetClientHeight()             { return mBounds.height; }
    1:    virtual ULONG    GetSWPFlags( ULONG flags)     { return flags; }
    1:    virtual void     SetupForPrint( HWND /*hwnd*/) {}
    1: 
    1:    // Useful functions for subclasses to use, threaded as necessary.
    1:    virtual nsresult GetWindowText( nsString &str, PRUint32 *rc);
    1:    virtual void     AddToStyle( ULONG style);
    1:    virtual void     RemoveFromStyle( ULONG style);
    1:    // return true if deferred
    1:    virtual BOOL     SetWindowPos( HWND hwndInsertBehind, long x, long y,
    1:                                   long cx, long cy, unsigned long flags);
    1: 
    1:    // Message handlers - may wish to override.  Default implementation for
 9710:    // control, paint & scroll is to do nothing.
    1: 
    1:    // Return whether message has been processed.
    1:    virtual PRBool ProcessMessage( ULONG m, MPARAM p1, MPARAM p2, MRESULT &r);
    1:    virtual PRBool OnPaint();
    1:    virtual void   OnDestroy();
    1:    virtual PRBool OnReposition( PSWP pNewSwp);
    1:    virtual PRBool OnResize( PRInt32 aX, PRInt32 aY);
    1:    virtual PRBool OnMove( PRInt32 aX, PRInt32 aY);
    1:    virtual PRBool OnKey( MPARAM mp1, MPARAM mp2);
    1:    virtual PRBool DispatchFocus( PRUint32 aEventType, PRBool isMozWindowTakingFocus);
    1:    virtual PRBool OnScroll( ULONG msgid, MPARAM mp1, MPARAM mp2);
    1:    virtual PRBool OnVScroll( MPARAM mp1, MPARAM mp2);
    1:    virtual PRBool OnHScroll( MPARAM mp1, MPARAM mp2);
    1:    virtual PRBool OnControl( MPARAM mp1, MPARAM mp2);
    1:    // called after param has been set...
    1:    virtual PRBool OnPresParamChanged( MPARAM mp1, MPARAM mp2);
    1:    virtual PRBool OnDragDropMsg(ULONG msg, MPARAM mp1, MPARAM mp2, MRESULT &mr);
    1: 
    1:    static BOOL sIsRegistered;
    1: 
    1:    // PM data members
    1:    HWND      mWnd;            // window handle
    1:    HWND      mFrameWnd;       // frame window handle
    1:    PFNWP     mPrevWndProc;    // previous window procedure
    1:    nsWindow *mParent;         // parent widget
    1:    ULONG     mNextID;         // next child window id
    1:    PSWP      mSWPs;           // SWPs for deferred window positioning
    1:    ULONG     mlHave, mlUsed;  // description of mSWPs array
    1:    HPOINTER  mFrameIcon;      // current frame icon
    1:    VDKEY     mDeadKey;        // dead key from previous keyevent
    1:    BOOL      mHaveDeadKey;    // is mDeadKey valid [0 may be a valid dead key, for all I know]
    1:    QMSG      mQmsg;
    1:    PRBool    mIsTopWidgetWindow;
    1:    BOOL      mIsScrollBar;
27505:    BOOL      mIsDestroying;
    1:    BOOL      mInSetFocus;
    1:    BOOL      mChromeHidden;
    1:    nsContentType mContentType;
    1:    HPS       mDragHps;        // retrieved by DrgGetPS() during a drag
    1:    PRUint32  mDragStatus;     // set while this object is being dragged over
    1:    HPOINTER  mCssCursorHPtr;  // created by SetCursor(imgIContainer*)
    1:    nsCOMPtr<imgIContainer> mCssCursorImg;  // saved by SetCursor(imgIContainer*)
    1: 
    1:    HWND      GetParentHWND() const;
    1:    HWND      GetHWND() const   { return mWnd; }
    1:    PFNWP     GetPrevWP() const { return mPrevWndProc; }
    1: 
    1:    // nglayout data members
    1:    PRInt32        mPreferredHeight;
    1:    PRInt32        mPreferredWidth;
    1:    nsToolkit     *mOS2Toolkit;
    1:    PRInt32        mWindowState;
    1:    nsRefPtr<gfxOS2Surface> mThebesSurface;
    1: 
    1:    // Implementation ------------------------------
23850:    void DoCreate( HWND hwndP, nsWindow *wndP, const nsIntRect &rect,
    1:                   EVENT_CALLBACK aHandleEventFunction,
    1:                   nsIDeviceContext *aContext, nsIAppShell *aAppShell,
    1:                   nsIToolkit *aToolkit, nsWidgetInitData *aInitData);
    1: 
    1:    virtual void RealDoCreate( HWND hwndP, nsWindow *aParent,
23850:                               const nsIntRect &aRect,
    1:                               EVENT_CALLBACK aHandleEventFunction,
    1:                               nsIDeviceContext *aContext,
    1:                               nsIAppShell *aAppShell,
    1:                               nsWidgetInitData *aInitData,
    1:                               HWND hwndOwner = 0);
    1: 
    1:    // hook so dialog can be created looking like a dialog
    1:    virtual ULONG GetFCFlags();
    1: 
    1:    virtual void SubclassWindow(BOOL bState);
    1: 
    1:    PRBool  ConvertStatus( nsEventStatus aStatus)
    1:                         { return aStatus == nsEventStatus_eConsumeNoDefault; }
23850:    void    InitEvent( nsGUIEvent &event, nsIntPoint *pt = 0);
    1:    virtual PRBool DispatchWindowEvent(nsGUIEvent* event);
    1:    virtual PRBool DispatchWindowEvent(nsGUIEvent*event, nsEventStatus &aStatus);
    1:    PRBool  DispatchStandardEvent( PRUint32 aMsg);
    1:    PRBool  DispatchCommandEvent(PRUint32 aEventCommand);
    1:    PRBool  DispatchDragDropEvent( PRUint32 aMsg);
    1:    virtual PRBool DispatchMouseEvent(PRUint32 aEventType, MPARAM mp1, MPARAM mp2, 
    1:                                      PRBool aIsContextMenuKey = PR_FALSE,
    1:                                      PRInt16 aButton = nsMouseEvent::eLeftButton);
    1:    virtual PRBool DispatchResizeEvent( PRInt32 aClientX, PRInt32 aClientY);
23850:    void GetNonClientBounds(nsIntRect &aRect);
    1:    void    DeferPosition( HWND, HWND, long, long, long, long, ULONG);
    1:    void ConstrainZLevel(HWND *aAfter);
    1: 
    1:    PRBool   CheckDragStatus(PRUint32 aAction, HPS * oHps);
    1:    PRBool   ReleaseIfDragHPS(HPS aHps);
    1: 
    1:    HBITMAP DataToBitmap(PRUint8* aImageData, PRUint32 aWidth,
    1:                         PRUint32 aHeight, PRUint32 aDepth);
 5664:    HBITMAP CreateBitmapRGB(PRUint8* aImageData, PRUint32 aWidth, PRUint32 aHeight);
    1:    // 'format' should be 'gfx_format' which is a PRInt32
    1:    HBITMAP CreateTransparencyMask(PRInt32  format, PRUint8* aImageData,
    1:                                   PRUint32 aWidth, PRUint32 aHeight);
    1: 
14309:    BOOL NotifyForeignChildWindows(HWND aWnd);
14900:    void ScrollChildWindows(PRInt32 aX, PRInt32 aY);
14309: 
    1:    // Enumeration of the methods which are accessible on the PM thread
    1:    enum {
    1:       CREATE,
    1:       DESTROY,
    1:       SET_FOCUS,
    1:       UPDATE_WINDOW,
    1:       SET_TITLE,
    1:       GET_TITLE
    1:    };
    1:    friend MRESULT EXPENTRY fnwpNSWindow( HWND, ULONG, MPARAM, MPARAM);
    1:    friend MRESULT EXPENTRY fnwpFrame( HWND, ULONG, MPARAM, MPARAM);
    1: #ifdef DEBUG_FOCUS
    1:    int mWindowIdentifier;
    1: #endif
    1: };
    1: 
    1: #define PM2NS_PARENT NS2PM_PARENT
    1: #define PM2NS NS2PM
    1: 
    1: #define PMSCAN_PADMULT      0x37
    1: #define PMSCAN_PAD7         0x47
    1: #define PMSCAN_PAD8         0x48
    1: #define PMSCAN_PAD9         0x49
    1: #define PMSCAN_PADMINUS     0x4A
    1: #define PMSCAN_PAD4         0x4B
    1: #define PMSCAN_PAD5         0x4C
    1: #define PMSCAN_PAD6         0x4D
    1: #define PMSCAN_PADPLUS      0x4E
    1: #define PMSCAN_PAD1         0x4F
    1: #define PMSCAN_PAD2         0x50
    1: #define PMSCAN_PAD3         0x51
    1: #define PMSCAN_PAD0         0x52
    1: #define PMSCAN_PADPERIOD    0x53
    1: #define PMSCAN_PADDIV       0x5c
    1: 
    1: #define isNumPadScanCode(scanCode) !( (scanCode < PMSCAN_PAD7) ||      \
    1:                                       (scanCode > PMSCAN_PADPERIOD) || \
    1:                                       (scanCode == PMSCAN_PADMULT) ||  \
    1:                                       (scanCode == PMSCAN_PADDIV) ||   \
    1:                                       (scanCode == PMSCAN_PADMINUS) || \
    1:                                       (scanCode == PMSCAN_PADPLUS) )
    1: #define isNumlockOn (BOOL)WinGetKeyState(HWND_DESKTOP, VK_NUMLOCK) & 0x0001
    1: 
    1: extern PRUint32 WMChar2KeyCode( MPARAM mp1, MPARAM mp2);
    1: 
    1: extern nsWindow *NS_HWNDToWindow( HWND hwnd);
    1: 
    1: #endif
