    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
32381:  *   Aaron Leventhal <aaronl@netscape.com> (original author)
32381:  *   Alexander Surkov <surkov.alexander@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsHTMLTableAccessible.h"
39503: 
41384: #include "nsAccessibilityService.h"
47105: #include "nsAccTreeWalker.h"
41384: #include "nsAccUtils.h"
39503: #include "nsDocAccessible.h"
41384: #include "nsRelUtils.h"
41384: #include "nsTextEquivUtils.h"
39503: 
    1: #include "nsIDOMElement.h"
 1370: #include "nsIDOMDocument.h"
 1370: #include "nsIDOMDocumentRange.h"
 1370: #include "nsIDOMRange.h"
 1370: #include "nsISelection2.h"
 1370: #include "nsISelectionPrivate.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOMHTMLCollection.h"
    1: #include "nsIDOMHTMLTableCellElement.h"
    1: #include "nsIDOMHTMLTableElement.h"
    1: #include "nsIDOMHTMLTableRowElement.h"
    1: #include "nsIDOMHTMLTableSectionElem.h"
    1: #include "nsIDocument.h"
    1: #include "nsIPresShell.h"
    1: #include "nsITableLayout.h"
  666: #include "nsITableCellLayout.h"
32354: #include "nsFrameSelection.h"
12645: #include "nsLayoutErrors.h"
32381: #include "nsArrayUtils.h"
    1: 
14327: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
28316: 
32381: nsHTMLTableCellAccessible::
43504:   nsHTMLTableCellAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible: nsISupports implementation
32381: 
32381: NS_IMPL_ISUPPORTS_INHERITED1(nsHTMLTableCellAccessible,
32381:                              nsHyperTextAccessible,
32381:                              nsIAccessibleTableCell)
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible: nsAccessible implementation
28316: 
25822: nsresult
25822: nsHTMLTableCellAccessible::GetRoleInternal(PRUint32 *aResult)
    1: {
    1:   *aResult = nsIAccessibleRole::ROLE_CELL;
    1:   return NS_OK;
    1: }
    1: 
14327: nsresult
30059: nsHTMLTableCellAccessible::GetStateInternal(PRUint32 *aState,
30059:                                             PRUint32 *aExtraState)
30059: {
30059:   nsresult rv= nsHyperTextAccessibleWrap::GetStateInternal(aState, aExtraState);
30059:   NS_ENSURE_A11Y_SUCCESS(rv, rv);
30059: 
43504:   nsIFrame *frame = mContent->GetPrimaryFrame();
30059:   NS_ASSERTION(frame, "No frame for valid cell accessible!");
30059: 
30059:   if (frame) {
30059:     *aState |= nsIAccessibleStates::STATE_SELECTABLE;
30059:     PRBool isSelected = PR_FALSE;
30059:     frame->GetSelected(&isSelected);
30059:     if (isSelected)
30059:       *aState |= nsIAccessibleStates::STATE_SELECTED;
30059:   }
30059: 
30059:   return NS_OK;
30059: }
30059: 
30059: nsresult
14327: nsHTMLTableCellAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
14327: {
14327:   if (IsDefunct())
14327:     return NS_ERROR_FAILURE;
14327: 
14327:   nsresult rv = nsHyperTextAccessibleWrap::GetAttributesInternal(aAttributes);
14327:   NS_ENSURE_SUCCESS(rv, rv);
14327: 
28316:   nsCOMPtr<nsIAccessibleTable> tableAcc(GetTableAccessible());
28316:   if (!tableAcc)
28316:     return NS_OK;
28316: 
28316:   PRInt32 rowIdx = -1, colIdx = -1;
28316:   rv = GetCellIndexes(rowIdx, colIdx);
28316:   NS_ENSURE_SUCCESS(rv, rv);
28316: 
28316:   PRInt32 idx = -1;
32381:   rv = tableAcc->GetCellIndexAt(rowIdx, colIdx, &idx);
28316:   NS_ENSURE_SUCCESS(rv, rv);
28316: 
28316:   nsAutoString stringIdx;
28316:   stringIdx.AppendInt(idx);
28316:   nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::tableCellIndex,
28316:                          stringIdx);
28316:   return NS_OK;
28316: }
28316: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible: nsIAccessibleTableCell implementation
28316: 
28316: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetTable(nsIAccessibleTable **aTable)
28316: {
32381:   NS_ENSURE_ARG_POINTER(aTable);
32381:   *aTable = nsnull;
28316: 
32381:   if (IsDefunct())
28316:     return NS_OK;
28316: 
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   table.swap(*aTable);
28316: 
32381:   return NS_OK;
28316: }
28316: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetColumnIndex(PRInt32 *aColumnIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aColumnIndex);
32381:   *aColumnIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsITableCellLayout* cellLayout = GetCellLayout();
32381:   NS_ENSURE_STATE(cellLayout);
32381: 
32381:   return cellLayout->GetColIndex(*aColumnIndex);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetRowIndex(PRInt32 *aRowIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aRowIndex);
32381:   *aRowIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsITableCellLayout* cellLayout = GetCellLayout();
32381:   NS_ENSURE_STATE(cellLayout);
32381: 
32381:   return cellLayout->GetRowIndex(*aRowIndex);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetColumnExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 1;
32381: 
32381:   PRInt32 rowIdx = -1, colIdx = -1;
32381:   GetCellIndexes(rowIdx, colIdx);
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   NS_ENSURE_STATE(table);
32381: 
32381:   return table->GetColumnExtentAt(rowIdx, colIdx, aExtentCount);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetRowExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 1;
32381: 
32381:   PRInt32 rowIdx = -1, colIdx = -1;
32381:   GetCellIndexes(rowIdx, colIdx);
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   NS_ENSURE_STATE(table);
32381: 
32381:   return table->GetRowExtentAt(rowIdx, colIdx, aExtentCount);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetColumnHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   return GetHeaderCells(nsAccUtils::eColumnHeaderCells, aHeaderCells);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::GetRowHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   return GetHeaderCells(nsAccUtils::eRowHeaderCells, aHeaderCells);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableCellAccessible::IsSelected(PRBool *aIsSelected)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aIsSelected);
32381:   *aIsSelected = PR_FALSE;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   PRInt32 rowIdx = -1, colIdx = -1;
32381:   GetCellIndexes(rowIdx, colIdx);
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   NS_ENSURE_STATE(table);
32381: 
32381:   return table->IsCellSelected(rowIdx, colIdx, aIsSelected);
32381: }
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableCellAccessible: protected implementation
28316: 
28316: already_AddRefed<nsIAccessibleTable>
28316: nsHTMLTableCellAccessible::GetTableAccessible()
28316: {
32476:   nsCOMPtr<nsIAccessible> childAcc(this), parentAcc;
32476:   childAcc->GetParent(getter_AddRefs(parentAcc));
28316: 
28316:   while (parentAcc) {
32476:     PRUint32 role = nsAccUtils::Role(parentAcc);
32476:     if (role == nsIAccessibleRole::ROLE_TABLE ||
32476:         role == nsIAccessibleRole::ROLE_TREE_TABLE) {
28316:       nsIAccessibleTable* tableAcc = nsnull;
28316:       CallQueryInterface(parentAcc, &tableAcc);
28316:       return tableAcc;
28316:     }
28316: 
28316:     parentAcc.swap(childAcc);
32476:     childAcc->GetParent(getter_AddRefs(parentAcc));
28316:   }
28316: 
28316:   return nsnull;
28316: }
28316: 
32381: nsITableCellLayout*
32381: nsHTMLTableCellAccessible::GetCellLayout()
32381: {
43504:   nsIFrame *frame = mContent->GetPrimaryFrame();
32381:   NS_ASSERTION(frame, "The frame cannot be obtaied for HTML table cell.");
32381:   if (!frame)
32381:     return nsnull;
32381: 
32381:   nsITableCellLayout *cellLayout = do_QueryFrame(frame);
32381:   return cellLayout;
32381: }
32381: 
28316: nsresult
28316: nsHTMLTableCellAccessible::GetCellIndexes(PRInt32& aRowIndex,
28316:                                           PRInt32& aColIndex)
28316: {
32381:   nsITableCellLayout *cellLayout = GetCellLayout();
14327:   NS_ENSURE_STATE(cellLayout);
14327: 
28316:   return cellLayout->GetCellIndexes(aRowIndex, aColIndex);
28316: }
28316: 
28316: nsresult
32381: nsHTMLTableCellAccessible::GetHeaderCells(PRInt32 aRowOrColumnHeaderCell,
32381:                                           nsIArray **aHeaderCells)
28316: {
32381:   // Get header cells from @header attribute.
32381:   nsCOMPtr<nsIArray> headerCellElms;
43504:   nsCoreUtils::GetElementsByIDRefsAttr(mContent, nsAccessibilityAtoms::headers,
32381:                                        getter_AddRefs(headerCellElms));
32381: 
32381:   if (headerCellElms) {
32381:     nsresult rv = NS_OK;
32381:     nsCOMPtr<nsIMutableArray> headerCells =
32381:       do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
14327:     NS_ENSURE_SUCCESS(rv, rv);
14327: 
32381:     PRUint32 count = 0;
32381:     rv = headerCellElms->GetLength(&count);
32381:     if (NS_SUCCEEDED(rv) && count > 0) {
43504:       nsCOMPtr<nsIContent> headerCellContent;
32381:       for (PRUint32 idx = 0; idx < count; idx++) {
43504:         headerCellContent = do_QueryElementAt(headerCellElms, idx, &rv);
42795:         nsAccessible *headerCell =
43504:           GetAccService()->GetAccessibleInWeakShell(headerCellContent, mWeakShell);
14327: 
32381:         if (headerCell &&
32381:             (aRowOrColumnHeaderCell == nsAccUtils::eRowHeaderCells &&
32381:              nsAccUtils::Role(headerCell) == nsIAccessibleRole::ROLE_ROWHEADER ||
32381:              aRowOrColumnHeaderCell == nsAccUtils::eColumnHeaderCells &&
32381:              nsAccUtils::Role(headerCell) == nsIAccessibleRole::ROLE_COLUMNHEADER))
42795:           headerCells->AppendElement(static_cast<nsIAccessible*>(headerCell),
41227:                                      PR_FALSE);
32381:       }
14327:     }
14327: 
32381:     NS_ADDREF(*aHeaderCells = headerCells);
32381:     return NS_OK;
28316:   }
28316: 
32381:   // Otherwise calculate header cells from hierarchy (see 11.4.3 "Algorithm to
32381:   // find heading information" of w3c HTML 4.01).
32381:   nsCOMPtr<nsIAccessibleTable> table = GetTableAccessible();
32381:   if (table) {
32381:     return nsAccUtils::GetHeaderCellsFor(table, this, aRowOrColumnHeaderCell,
32381:                                          aHeaderCells);
14327:   }
14327: 
14327:   return NS_OK;
14327: }
14327: 
28316: ////////////////////////////////////////////////////////////////////////////////
28316: // nsHTMLTableHeaderAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
28316: 
32381: nsHTMLTableHeaderCellAccessible::
43504:   nsHTMLTableHeaderCellAccessible(nsIContent *aContent,
32381:                                   nsIWeakReference *aShell) :
43504:   nsHTMLTableCellAccessible(aContent, aShell)
28316: {
28316: }
28316: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableHeaderAccessible: nsAccessible implementation
32381: 
28316: nsresult
32381: nsHTMLTableHeaderCellAccessible::GetRoleInternal(PRUint32 *aRole)
28316: {
28316:   // Check value of @scope attribute.
28316:   static nsIContent::AttrValuesArray scopeValues[] =
28316:     {&nsAccessibilityAtoms::col, &nsAccessibilityAtoms::row, nsnull};
28316:   PRInt32 valueIdx = 
43504:     mContent->FindAttrValueIn(kNameSpaceID_None, nsAccessibilityAtoms::scope,
28316:                               scopeValues, eCaseMatters);
28316: 
28316:   switch (valueIdx) {
28316:     case 0:
28316:       *aRole = nsIAccessibleRole::ROLE_COLUMNHEADER;
28316:       return NS_OK;
28316:     case 1:
28316:       *aRole = nsIAccessibleRole::ROLE_ROWHEADER;
28316:       return NS_OK;
28316:   }
28316: 
28316:   // Assume it's columnheader if there are headers in siblings, oterwise
28316:   // rowheader.
43504:   nsIContent *parent = mContent->GetParent();
34720:   NS_ENSURE_STATE(parent);
34720: 
43504:   PRInt32 indexInParent = parent->IndexOf(mContent);
28316: 
28316:   for (PRInt32 idx = indexInParent - 1; idx >= 0; idx--) {
28316:     nsIContent* sibling = parent->GetChildAt(idx);
41645:     if (sibling && sibling->IsElement()) {
28316:       if (nsCoreUtils::IsHTMLTableHeader(sibling))
28316:         *aRole = nsIAccessibleRole::ROLE_COLUMNHEADER;
28316:       else
28316:         *aRole = nsIAccessibleRole::ROLE_ROWHEADER;
28316: 
28316:       return NS_OK;
28316:     }
28316:   }
28316: 
28316:   PRInt32 childCount = parent->GetChildCount();
28316:   for (PRInt32 idx = indexInParent + 1; idx < childCount; idx++) {
28316:     nsIContent* sibling = parent->GetChildAt(idx);
41645:     if (sibling && sibling->IsElement()) {
28316:       if (nsCoreUtils::IsHTMLTableHeader(sibling))
28316:         *aRole = nsIAccessibleRole::ROLE_COLUMNHEADER;
28316:       else
28316:         *aRole = nsIAccessibleRole::ROLE_ROWHEADER;
28316:       
28316:       return NS_OK;
28316:     }
28316:   }
28316: 
35582:   // No elements in siblings what means the table has one column only. Therefore
35582:   // it should be column header.
35582:   *aRole = nsIAccessibleRole::ROLE_COLUMNHEADER;
35582: 
28316:   return NS_OK;
28316: }
28316: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
32381: 
32381: nsHTMLTableAccessible::
43504:   nsHTMLTableAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessibleWrap(aContent, aShell)
28316: {
28316: }
28316: 
14327: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible: nsISupports implementation
14327: 
28316: NS_IMPL_ISUPPORTS_INHERITED2(nsHTMLTableAccessible, nsAccessible,
28316:                              nsHTMLTableAccessible, nsIAccessibleTable)
    1: 
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible: nsAccessible implementation
  140: 
35523: void
35523: nsHTMLTableAccessible::CacheChildren()
  140: {
47105:   // Move caption accessible so that it's the first child. Check for the first
47105:   // caption only, because nsAccessibilityService ensures we don't create
47105:   // accessibles for the other captions, since only the first is actually
47105:   // visible.
47105:   nsAccTreeWalker walker(mWeakShell, mContent, GetAllowsAnonChildAccessibles());
35136: 
47105:   nsRefPtr<nsAccessible> child;
47105:   while ((child = walker.GetNextChild())) {
35523:     if (nsAccUtils::Role(child) == nsIAccessibleRole::ROLE_CAPTION) {
47105:       InsertChildAt(0, child);
47105:       while ((child = walker.GetNextChild()) && AppendChild(child));
35133:       break;
35136:     }
47105:     AppendChild(child);
  140:   }
  140: }
    1: 
25822: nsresult
25822: nsHTMLTableAccessible::GetRoleInternal(PRUint32 *aResult)
    1: {
    1:   *aResult = nsIAccessibleRole::ROLE_TABLE;
    1:   return NS_OK;
    1: }
    1: 
21256: nsresult
21256: nsHTMLTableAccessible::GetStateInternal(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
21256:   nsresult rv= nsAccessible::GetStateInternal(aState, aExtraState);
21984:   NS_ENSURE_A11Y_SUCCESS(rv, rv);
21256: 
  262:   *aState |= nsIAccessibleStates::STATE_READONLY;
    1:   return NS_OK;
    1: }
    1: 
20246: nsresult
20246: nsHTMLTableAccessible::GetNameInternal(nsAString& aName)
    1: {
20246:   nsAccessible::GetNameInternal(aName);
    1: 
43504:   if (aName.IsEmpty())
43504:     mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::summary, aName);
    1: 
    1:   return NS_OK;
    1: }
    1: 
  401: nsresult
  401: nsHTMLTableAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
    1: {
  401:   nsresult rv = nsAccessibleWrap::GetAttributesInternal(aAttributes);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool isProbablyForLayout;
    1:   IsProbablyForLayout(&isProbablyForLayout);
    1:   if (isProbablyForLayout) {
    1:     nsAutoString oldValueUnused;
  401:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("layout-guess"),
  401:                                    NS_LITERAL_STRING("true"), oldValueUnused);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible: nsIAccessible implementation
32381: 
    1: NS_IMETHODIMP
24822: nsHTMLTableAccessible::GetRelationByType(PRUint32 aRelationType,
24822:                                          nsIAccessibleRelation **aRelation)
    1: {
24822:   nsresult rv = nsAccessibleWrap::GetRelationByType(aRelationType,
24822:                                                     aRelation);
24822:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3151:   if (aRelationType == nsIAccessibleRelation::RELATION_DESCRIBED_BY) {
24822:     nsCOMPtr<nsIAccessible> accCaption;
24822:     GetCaption(getter_AddRefs(accCaption));
24822:     return nsRelUtils::AddTarget(aRelationType, aRelation, accCaption);
 3151:   }
 3151: 
 1560:   return NS_OK;
 1560: }
    1: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsHTMLTableAccessible: nsIAccessibleTable implementation
    1: 
    1: NS_IMETHODIMP
 3151: nsHTMLTableAccessible::GetCaption(nsIAccessible **aCaption)
    1: {
 3151:   nsCOMPtr<nsIAccessible> firstChild;
 3151:   GetFirstChild(getter_AddRefs(firstChild));
20566:   if (nsAccUtils::Role(firstChild) == nsIAccessibleRole::ROLE_CAPTION)
 3151:     NS_ADDREF(*aCaption = firstChild);
20566: 
 3151:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLTableAccessible::GetSummary(nsAString &aSummary)
    1: {
43504:   nsCOMPtr<nsIDOMHTMLTableElement> table(do_QueryInterface(mContent));
    1:   NS_ENSURE_TRUE(table, NS_ERROR_FAILURE);
    1: 
    1:   return table->GetSummary(aSummary);
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetColumnCount(PRInt32 *acolumnCount)
    1: {
32381:   NS_ENSURE_ARG_POINTER(acolumnCount);
32381:   *acolumnCount = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
    1:   PRInt32 rows;
32381:   return tableLayout->GetTableSize(rows, *acolumnCount);
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetRowCount(PRInt32 *arowCount)
    1: {
32381:   NS_ENSURE_ARG_POINTER(arowCount);
32381:   *arowCount = 0;
    1: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
    1: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
32381:   PRInt32 columns;
32381:   return tableLayout->GetTableSize(*arowCount, columns);
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedCellCount(PRUint32* aCount)
 3337: {
 3337:   NS_ENSURE_ARG_POINTER(aCount);
 3337:   *aCount = 0;
 3337: 
32381:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
29966: 
29966:   nsCOMPtr<nsIDOMElement> domElement;
29966:   PRInt32 startRowIndex = 0, startColIndex = 0,
29966:     rowSpan, colSpan, actualRowSpan, actualColSpan;
29966:   PRBool isSelected = PR_FALSE;
29966: 
 3337:   PRInt32 rowIndex;
32381:   for (rowIndex = 0; rowIndex < rowCount; rowIndex++) {
 3337:     PRInt32 columnIndex;
32381:     for (columnIndex = 0; columnIndex < columnCount; columnIndex++) {
29966:       rv = tableLayout->GetCellDataAt(rowIndex, columnIndex,
29966:                                       *getter_AddRefs(domElement),
29966:                                       startRowIndex, startColIndex,
29966:                                       rowSpan, colSpan,
29966:                                       actualRowSpan, actualColSpan,
29966:                                       isSelected);
 3337: 
29966:       if (NS_SUCCEEDED(rv) && startRowIndex == rowIndex &&
29966:           startColIndex == columnIndex && isSelected) {
 3337:         (*aCount)++;
 3337:       }
 3337:     }
29966:   }
 3337: 
 3337:   return NS_OK;
 3337: }
 3337: 
 3337: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedColumnCount(PRUint32* aCount)
 3337: {
 3337:   NS_ENSURE_ARG_POINTER(aCount);
 3337:   *aCount = 0;
 3337: 
 3337:   PRInt32 count = 0;
32381:   nsresult rv = GetColumnCount(&count);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
 3337:   PRInt32 index;
 3337:   for (index = 0; index < count; index++) {
 3337:     PRBool state = PR_FALSE;
 3337:     rv = IsColumnSelected(index, &state);
 3337:     NS_ENSURE_SUCCESS(rv, rv);
 3337: 
 3337:     if (state)
 3337:       (*aCount)++;
 3337:   }
 3337: 
 3337:   return NS_OK;
 3337: }
 3337: 
 3337: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedRowCount(PRUint32* aCount)
 3337: {
 3337:   NS_ENSURE_ARG_POINTER(aCount);
 3337:   *aCount = 0;
 3337: 
 3337:   PRInt32 count = 0;
32381:   nsresult rv = GetRowCount(&count);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
 3337:   PRInt32 index;
 3337:   for (index = 0; index < count; index++) {
 3337:     PRBool state = PR_FALSE;
 3337:     rv = IsRowSelected(index, &state);
 3337:     NS_ENSURE_SUCCESS(rv, rv);
 3337: 
 3337:     if (state)
 3337:       (*aCount)++;
 3337:   }
 3337: 
 3337:   return NS_OK;
 3337: }
 3337: 
 3337: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedCells(nsIArray **aCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aCells);
32381:   *aCells = nsnull;
32381: 
32381:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
32381: 
32381:   nsCOMPtr<nsIMutableArray> selCells =
32381:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   nsCOMPtr<nsIDOMElement> cellElement;
32381:   PRInt32 startRowIndex = 0, startColIndex = 0,
32381:     rowSpan, colSpan, actualRowSpan, actualColSpan;
32381:   PRBool isSelected = PR_FALSE;
32381: 
32381:   PRInt32 rowIndex, index;
32381:   for (rowIndex = 0, index = 0; rowIndex < rowCount; rowIndex++) {
32381:     PRInt32 columnIndex;
32381:     for (columnIndex = 0; columnIndex < columnCount; columnIndex++, index++) {
32381:       rv = tableLayout->GetCellDataAt(rowIndex, columnIndex,
32381:                                       *getter_AddRefs(cellElement),
32381:                                       startRowIndex, startColIndex,
32381:                                       rowSpan, colSpan,
32381:                                       actualRowSpan, actualColSpan,
32381:                                       isSelected);
32381: 
32381:       if (NS_SUCCEEDED(rv) && startRowIndex == rowIndex &&
32381:           startColIndex == columnIndex && isSelected) {
43504:         nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
42795:         nsAccessible *cell =
43504:           GetAccService()->GetAccessibleInWeakShell(cellContent, mWeakShell);
42795:         selCells->AppendElement(static_cast<nsIAccessible*>(cell), PR_FALSE);
32381:       }
32381:     }
32381:   }
32381: 
32381:   NS_ADDREF(*aCells = selCells);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedCellIndices(PRUint32 *aNumCells,
 3337:                                               PRInt32 **aCells)
 3337: {
 3337:   NS_ENSURE_ARG_POINTER(aNumCells);
 3337:   *aNumCells = 0;
 3337:   NS_ENSURE_ARG_POINTER(aCells);
 3337:   *aCells = nsnull;
 3337: 
32381:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
 3337:   NS_ENSURE_SUCCESS(rv, rv);
 3337: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
29966: 
29966:   nsCOMPtr<nsIDOMElement> domElement;
29966:   PRInt32 startRowIndex = 0, startColIndex = 0,
29966:     rowSpan, colSpan, actualRowSpan, actualColSpan;
29966:   PRBool isSelected = PR_FALSE;
29966: 
32381:   PRInt32 cellsCount = columnCount * rowCount;
 3337:   nsAutoArrayPtr<PRBool> states(new PRBool[cellsCount]);
 3337:   NS_ENSURE_TRUE(states, NS_ERROR_OUT_OF_MEMORY);
 3337: 
 3337:   PRInt32 rowIndex, index;
32381:   for (rowIndex = 0, index = 0; rowIndex < rowCount; rowIndex++) {
 3337:     PRInt32 columnIndex;
32381:     for (columnIndex = 0; columnIndex < columnCount; columnIndex++, index++) {
29966:       rv = tableLayout->GetCellDataAt(rowIndex, columnIndex,
29966:                                       *getter_AddRefs(domElement),
29966:                                       startRowIndex, startColIndex,
29966:                                       rowSpan, colSpan,
29966:                                       actualRowSpan, actualColSpan,
29966:                                       isSelected);
 3337: 
29966:       if (NS_SUCCEEDED(rv) && startRowIndex == rowIndex &&
29966:           startColIndex == columnIndex && isSelected) {
29966:         states[index] = PR_TRUE;
 3337:         (*aNumCells)++;
29966:       } else {
29966:         states[index] = PR_FALSE;
29966:       }
 3337:     }
 3337:   }
 3337: 
 3337:   PRInt32 *cellsArray =
32381:     static_cast<PRInt32*>(nsMemory::Alloc((*aNumCells) * sizeof(PRInt32)));
 3337:   NS_ENSURE_TRUE(cellsArray, NS_ERROR_OUT_OF_MEMORY);
 3337: 
 3337:   PRInt32 curr = 0;
32381:   for (rowIndex = 0, index = 0; rowIndex < rowCount; rowIndex++) {
 3337:     PRInt32 columnIndex;
32381:     for (columnIndex = 0; columnIndex < columnCount; columnIndex++, index++) {
 3337:       if (states[index]) {
 3337:         PRInt32 cellIndex = -1;
32381:         GetCellIndexAt(rowIndex, columnIndex, &cellIndex);
 3337:         cellsArray[curr++] = cellIndex;
 3337:       }
 3337:     }
 3337:   }
 3337: 
 3337:   *aCells = cellsArray;
 3337:   return NS_OK;
 3337: }
 3337: 
 3337: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedColumnIndices(PRUint32 *aNumColumns,
    1:                                                 PRInt32 **aColumns)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   PRInt32 columnCount;
32381:   rv = GetColumnCount(&columnCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool *states = new PRBool[columnCount];
    1:   NS_ENSURE_TRUE(states, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   *aNumColumns = 0;
    1:   PRInt32 index;
    1:   for (index = 0; index < columnCount; index++) {
    1:     rv = IsColumnSelected(index, &states[index]);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (states[index]) {
    1:       (*aNumColumns)++;
    1:     }
    1:   }
    1: 
    1:   PRInt32 *outArray = (PRInt32 *)nsMemory::Alloc((*aNumColumns) * sizeof(PRInt32));
    1:   if (!outArray) {
    1:     delete []states;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   PRInt32 curr = 0;
    1:   for (index = 0; index < columnCount; index++) {
    1:     if (states[index]) {
    1:       outArray[curr++] = index;
    1:     }
    1:   }
    1: 
    1:   delete []states;
    1:   *aColumns = outArray;
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetSelectedRowIndices(PRUint32 *aNumRows,
32381:                                              PRInt32 **aRows)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   PRInt32 rowCount;
32381:   rv = GetRowCount(&rowCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool *states = new PRBool[rowCount];
    1:   NS_ENSURE_TRUE(states, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   *aNumRows = 0;
    1:   PRInt32 index;
    1:   for (index = 0; index < rowCount; index++) {
    1:     rv = IsRowSelected(index, &states[index]);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (states[index]) {
    1:       (*aNumRows)++;
    1:     }
    1:   }
    1: 
    1:   PRInt32 *outArray = (PRInt32 *)nsMemory::Alloc((*aNumRows) * sizeof(PRInt32));
    1:   if (!outArray) {
    1:     delete []states;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   PRInt32 curr = 0;
    1:   for (index = 0; index < rowCount; index++) {
    1:     if (states[index]) {
    1:       outArray[curr++] = index;
    1:     }
    1:   }
    1: 
    1:   delete []states;
    1:   *aRows = outArray;
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetCellAt(PRInt32 aRow, PRInt32 aColumn,
    1:                                  nsIAccessible **aTableCellAccessible)
    1: {
    1:   nsCOMPtr<nsIDOMElement> cellElement;
34001:   nsresult rv = GetCellAt(aRow, aColumn, *getter_AddRefs(cellElement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
43504:   nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
42795:   nsAccessible *cell =
43504:     GetAccService()->GetAccessibleInWeakShell(cellContent, mWeakShell);
49702: 
49702:   if (!cell) {
49702:     return NS_ERROR_INVALID_ARG;
49702:   }
49702: 
49702:   if (cell != this) {
49701:     // XXX bug 576838: crazy tables (like table6 in tables/test_table2.html) may
49701:     // return itself as a cell what makes Orca hang.
49701:     NS_ADDREF(*aTableCellAccessible = cell);
49701:   }
41227: 
41227:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetCellIndexAt(PRInt32 aRow, PRInt32 aColumn,
  666:                                       PRInt32 *aIndex)
    1: {
  666:   NS_ENSURE_ARG_POINTER(aIndex);
    1: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
32381:   nsresult rv = tableLayout->GetIndexByRowAndColumn(aRow, aColumn, aIndex);
29821:   if (rv == NS_TABLELAYOUT_CELL_NOT_FOUND)
29821:     return NS_ERROR_INVALID_ARG;
29821: 
29821:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetColumnIndexAt(PRInt32 aIndex, PRInt32 *aColumn)
    1: {
  666:   NS_ENSURE_ARG_POINTER(aColumn);
    1: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
11311: 
11311:   PRInt32 row;
34001:   nsresult rv = tableLayout->GetRowAndColumnByIndex(aIndex, &row, aColumn);
34001:   NS_ENSURE_SUCCESS(rv, rv);
34001: 
34001:   return (row == -1 || *aColumn == -1) ? NS_ERROR_INVALID_ARG : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetRowIndexAt(PRInt32 aIndex, PRInt32 *aRow)
    1: {
  666:   NS_ENSURE_ARG_POINTER(aRow);
    1: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
11311: 
11311:   PRInt32 column;
34001:   nsresult rv = tableLayout->GetRowAndColumnByIndex(aIndex, aRow, &column);
34001:   NS_ENSURE_SUCCESS(rv, rv);
34001: 
34001:   return (*aRow == -1 || column == -1) ? NS_ERROR_INVALID_ARG : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
47173: nsHTMLTableAccessible::GetRowAndColumnIndicesAt(PRInt32 aIndex,
47173:                                                 PRInt32* aRowIdx,
47173:                                                 PRInt32* aColumnIdx)
47173: {
47173:   NS_ENSURE_ARG_POINTER(aRowIdx);
47173:   *aRowIdx = -1;
47173:   NS_ENSURE_ARG_POINTER(aColumnIdx);
47173:   *aColumnIdx = -1;
47173: 
47173:   if (IsDefunct())
47173:     return NS_ERROR_FAILURE;
47173: 
47173:   nsITableLayout* tableLayout = GetTableLayout();
47173:   if (tableLayout)
47173:     tableLayout->GetRowAndColumnByIndex(aIndex, aRowIdx, aColumnIdx);
47173: 
47173:   return (*aRowIdx == -1 || *aColumnIdx == -1) ? NS_ERROR_INVALID_ARG : NS_OK;
47173: }
47173: 
47173: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetColumnExtentAt(PRInt32 aRowIndex,
32381:                                          PRInt32 aColumnIndex,
32381:                                          PRInt32 *aExtentCount)
    1: {
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
    1:   nsCOMPtr<nsIDOMElement> domElement;
32381:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualRowSpan;
32381:   PRBool isSelected;
    1: 
34001:   nsresult rv = tableLayout->
32381:     GetCellDataAt(aRowIndex, aColumnIndex, *getter_AddRefs(domElement),
32381:                   startRowIndex, startColIndex, rowSpan, colSpan,
32381:                   actualRowSpan, *aExtentCount, isSelected);
34001: 
34001:   return (rv == NS_TABLELAYOUT_CELL_NOT_FOUND) ? NS_ERROR_INVALID_ARG : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsHTMLTableAccessible::GetRowExtentAt(PRInt32 aRowIndex, PRInt32 aColumnIndex,
32381:                                       PRInt32 *aExtentCount)
    1: {
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
    1:   nsCOMPtr<nsIDOMElement> domElement;
32381:   PRInt32 startRowIndex, startColIndex, rowSpan, colSpan, actualColSpan;
32381:   PRBool isSelected;
    1: 
34001:   nsresult rv = tableLayout->
32381:     GetCellDataAt(aRowIndex, aColumnIndex, *getter_AddRefs(domElement),
32381:                   startRowIndex, startColIndex, rowSpan, colSpan,
32381:                   *aExtentCount, actualColSpan, isSelected);
34001: 
34001:   return (rv == NS_TABLELAYOUT_CELL_NOT_FOUND) ? NS_ERROR_INVALID_ARG : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLTableAccessible::GetColumnDescription(PRInt32 aColumn, nsAString &_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLTableAccessible::GetRowDescription(PRInt32 aRow, nsAString &_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
34001: nsHTMLTableAccessible::IsColumnSelected(PRInt32 aColumn, PRBool *aIsSelected)
    1: {
34001:   NS_ENSURE_ARG_POINTER(aIsSelected);
34001:   *aIsSelected = PR_FALSE;
    1: 
34001:   PRInt32 colCount = 0;
34001:   nsresult rv = GetColumnCount(&colCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
34001:   if (aColumn < 0 || aColumn >= colCount)
34001:     return NS_ERROR_INVALID_ARG;
34001: 
34001:   PRInt32 rowCount = 0;
34001:   rv = GetRowCount(&rowCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
34001: 
34001:   for (PRInt32 rowIdx = 0; rowIdx < rowCount; rowIdx++) {
34001:     PRBool isSelected = PR_FALSE;
34001:     rv = IsCellSelected(rowIdx, aColumn, &isSelected);
34001:     if (NS_SUCCEEDED(rv)) {
34001:       *aIsSelected = isSelected;
34001:       if (!isSelected)
    1:         break;
    1:     }
    1:   }
    1: 
34001:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
34001: nsHTMLTableAccessible::IsRowSelected(PRInt32 aRow, PRBool *aIsSelected)
    1: {
34001:   NS_ENSURE_ARG_POINTER(aIsSelected);
34001:   *aIsSelected = PR_FALSE;
    1: 
34001:   PRInt32 rowCount = 0;
34001:   nsresult rv = GetRowCount(&rowCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
34001:   if (aRow < 0 || aRow >= rowCount)
34001:     return NS_ERROR_INVALID_ARG;
34001: 
34001:   PRInt32 colCount = 0;
34001:   rv = GetColumnCount(&colCount);
    1:   NS_ENSURE_SUCCESS(rv, rv);
34001: 
34001:   for (PRInt32 colIdx = 0; colIdx < colCount; colIdx++) {
34001:     PRBool isSelected = PR_FALSE;
34001:     rv = IsCellSelected(aRow, colIdx, &isSelected);
34001:     if (NS_SUCCEEDED(rv)) {
34001:       *aIsSelected = isSelected;
34001:       if (!isSelected)
    1:         break;
    1:     }
    1:   }
    1: 
34001:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLTableAccessible::IsCellSelected(PRInt32 aRow, PRInt32 aColumn,
12645:                                       PRBool *aIsSelected)
    1: {
12645:   NS_ENSURE_ARG_POINTER(aIsSelected);
12645:   *aIsSelected = PR_FALSE;
 9759: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
    1:   nsCOMPtr<nsIDOMElement> domElement;
    1:   PRInt32 startRowIndex = 0, startColIndex = 0,
    1:           rowSpan, colSpan, actualRowSpan, actualColSpan;
    1: 
32381:   nsresult rv = tableLayout->
32381:     GetCellDataAt(aRow, aColumn, *getter_AddRefs(domElement),
32381:                   startRowIndex, startColIndex, rowSpan, colSpan,
12645:                   actualRowSpan, actualColSpan, *aIsSelected);
12645: 
12645:   if (rv == NS_TABLELAYOUT_CELL_NOT_FOUND)
12645:     return NS_ERROR_INVALID_ARG;
12645:   return rv;
    1: }
    1: 
 1370: NS_IMETHODIMP
 1370: nsHTMLTableAccessible::SelectRow(PRInt32 aRow)
 1370: {
32354:   if (IsDefunct())
32354:     return NS_ERROR_FAILURE;
32354: 
32354:   nsresult rv =
32354:     RemoveRowsOrColumnsFromSelection(aRow,
32354:                                      nsISelectionPrivate::TABLESELECTION_ROW,
 1370:                                      PR_TRUE);
32354:   NS_ENSURE_SUCCESS(rv, rv);
32354: 
32354:   return AddRowOrColumnToSelection(aRow,
32354:                                    nsISelectionPrivate::TABLESELECTION_ROW);
 1370: }
 1370: 
 1370: NS_IMETHODIMP
 1370: nsHTMLTableAccessible::SelectColumn(PRInt32 aColumn)
 1370: {
32354:   if (IsDefunct())
32354:     return NS_ERROR_FAILURE;
32354: 
32354:   nsresult rv =
32354:     RemoveRowsOrColumnsFromSelection(aColumn,
32354:                                      nsISelectionPrivate::TABLESELECTION_COLUMN,
 1370:                                      PR_TRUE);
32354:   NS_ENSURE_SUCCESS(rv, rv);
32354: 
32354:   return AddRowOrColumnToSelection(aColumn,
32354:                                    nsISelectionPrivate::TABLESELECTION_COLUMN);
 1370: }
 1370: 
 1370: NS_IMETHODIMP
 1370: nsHTMLTableAccessible::UnselectRow(PRInt32 aRow)
 1370: {
32354:   if (IsDefunct())
32354:     return NS_ERROR_FAILURE;
32354: 
32354:   return
32354:     RemoveRowsOrColumnsFromSelection(aRow,
32354:                                      nsISelectionPrivate::TABLESELECTION_ROW,
 1370:                                      PR_FALSE);
 1370: }
 1370: 
 1370: NS_IMETHODIMP
 1370: nsHTMLTableAccessible::UnselectColumn(PRInt32 aColumn)
 1370: {
32354:   if (IsDefunct())
32354:     return NS_ERROR_FAILURE;
32354: 
32354:   return
32354:     RemoveRowsOrColumnsFromSelection(aColumn,
32354:                                      nsISelectionPrivate::TABLESELECTION_COLUMN,
 1370:                                      PR_FALSE);
 1370: }
 1370: 
 1370: nsresult
32354: nsHTMLTableAccessible::AddRowOrColumnToSelection(PRInt32 aIndex,
32354:                                                  PRUint32 aTarget)
 1370: {
 1370:   PRBool doSelectRow = (aTarget == nsISelectionPrivate::TABLESELECTION_ROW);
 1370: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
 1370: 
32354:   nsCOMPtr<nsIDOMElement> cellElm;
32354:   PRInt32 startRowIdx, startColIdx, rowSpan, colSpan,
32354:     actualRowSpan, actualColSpan;
32354:   PRBool isSelected = PR_FALSE;
 1370: 
32381:   nsresult rv = NS_OK;
 1370:   PRInt32 count = 0;
32354:   if (doSelectRow)
32381:     rv = GetColumnCount(&count);
32354:   else
32381:     rv = GetRowCount(&count);
32354: 
 1370:   NS_ENSURE_SUCCESS(rv, rv);
 1370: 
32354:   nsCOMPtr<nsIPresShell> presShell(GetPresShell());
32354:   nsRefPtr<nsFrameSelection> tableSelection =
32354:     const_cast<nsFrameSelection*>(presShell->ConstFrameSelection());
 1370: 
32354:   for (PRInt32 idx = 0; idx < count; idx++) {
32354:     PRInt32 rowIdx = doSelectRow ? aIndex : idx;
32354:     PRInt32 colIdx = doSelectRow ? idx : aIndex;
32354:     rv = tableLayout->GetCellDataAt(rowIdx, colIdx,
32354:                                     *getter_AddRefs(cellElm),
32354:                                     startRowIdx, startColIdx,
32354:                                     rowSpan, colSpan,
32354:                                     actualRowSpan, actualColSpan,
32354:                                     isSelected);      
32354: 
32354:     if (NS_SUCCEEDED(rv) && !isSelected) {
32354:       nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElm));
32354:       rv = tableSelection->SelectCellElement(cellContent);
 1370:       NS_ENSURE_SUCCESS(rv, rv);
32354:     }
 1370:   }
 1382: 
 1382:   return NS_OK;
 1370: }
 1370: 
 1370: nsresult
32354: nsHTMLTableAccessible::RemoveRowsOrColumnsFromSelection(PRInt32 aIndex,
32354:                                                         PRUint32 aTarget,
32354:                                                         PRBool aIsOuter)
 1370: {
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
 1370: 
32354:   nsCOMPtr<nsIPresShell> presShell(GetPresShell());
32354:   nsRefPtr<nsFrameSelection> tableSelection =
32354:     const_cast<nsFrameSelection*>(presShell->ConstFrameSelection());
 1370: 
32354:   PRBool doUnselectRow = (aTarget == nsISelectionPrivate::TABLESELECTION_ROW);
32354: 
32381:   nsresult rv = NS_OK;
32354:   PRInt32 count = 0;
32354:   if (doUnselectRow)
32381:     rv = GetColumnCount(&count);
32354:   else
32381:     rv = GetRowCount(&count);
32354: 
32354:   PRInt32 startRowIdx = doUnselectRow ? aIndex : 0;
32354:   PRInt32 endRowIdx = doUnselectRow ? aIndex : count - 1;
32354:   PRInt32 startColIdx = doUnselectRow ? 0 : aIndex;
32354:   PRInt32 endColIdx = doUnselectRow ? count - 1 : aIndex;
32354: 
32354:   if (aIsOuter)
43504:     return tableSelection->RestrictCellsToSelection(mContent,
32354:                                                     startRowIdx, startColIdx, 
32354:                                                     endRowIdx, endColIdx);
32354: 
43504:   return tableSelection->RemoveCellsFromSelection(mContent,
32354:                                                   startRowIdx, startColIdx, 
32354:                                                   endRowIdx, endColIdx);
 1370: }
 1370: 
32381: nsITableLayout*
32381: nsHTMLTableAccessible::GetTableLayout()
    1: {
43504:   nsIFrame *frame = mContent->GetPrimaryFrame();
23554:   if (!frame)
32381:     return nsnull;
23554: 
32381:   nsITableLayout *tableLayout = do_QueryFrame(frame);
32381:   return tableLayout;
    1: }
    1: 
    1: nsresult
    1: nsHTMLTableAccessible::GetCellAt(PRInt32        aRowIndex,
    1:                                  PRInt32        aColIndex,
    1:                                  nsIDOMElement* &aCell)
    1: {
    1:   PRInt32 startRowIndex = 0, startColIndex = 0,
    1:           rowSpan, colSpan, actualRowSpan, actualColSpan;
    1:   PRBool isSelected;
    1: 
32381:   nsITableLayout *tableLayout = GetTableLayout();
32381:   NS_ENSURE_STATE(tableLayout);
    1: 
32381:   nsresult rv = tableLayout->
32381:     GetCellDataAt(aRowIndex, aColIndex, aCell, startRowIndex, startColIndex,
32381:                   rowSpan, colSpan, actualRowSpan, actualColSpan, isSelected);
12645: 
12645:   if (rv == NS_TABLELAYOUT_CELL_NOT_FOUND)
12645:     return NS_ERROR_INVALID_ARG;
12645:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLTableAccessible::GetDescription(nsAString& aDescription)
    1: {
    1:   // Helpful for debugging layout vs. data tables
    1:   aDescription.Truncate();
 3151:   nsAccessible::GetDescription(aDescription);
 3151:   if (!aDescription.IsEmpty()) {
 3151:     return NS_OK;
 3151:   }
 3151: 
 3151:   nsCOMPtr<nsIAccessible> captionAccessible;
 3151:   GetCaption(getter_AddRefs(captionAccessible));
 3151:   nsCOMPtr<nsIAccessNode> captionAccessNode = do_QueryInterface(captionAccessible);
 3151:   if (captionAccessNode) {
 3151:     nsCOMPtr<nsIDOMNode> captionNode;
 3151:     captionAccessNode->GetDOMNode(getter_AddRefs(captionNode));
 3151:     nsCOMPtr<nsIContent> captionContent = do_QueryInterface(captionNode);
 3151:     if (captionContent) {
25175:       nsTextEquivUtils::
25175:         AppendTextEquivFromContent(this, captionContent, &aDescription);
 3151:     }
 3151:   }
 3151: #ifdef SHOW_LAYOUT_HEURISTIC
 3151:   if (aDescription.IsEmpty()) {
    1:     PRBool isProbablyForLayout;
    1:     IsProbablyForLayout(&isProbablyForLayout);
    1:     aDescription = mLayoutHeuristic;
 3151:   }
    1: #ifdef DEBUG_A11Y
    1:   printf("\nTABLE: %s\n", NS_ConvertUTF16toUTF8(mLayoutHeuristic).get());
    1: #endif
 3151: #endif
 3151: 
    1:   return NS_OK;
    1: }
    1: 
30060: PRBool
30060: nsHTMLTableAccessible::HasDescendant(const nsAString& aTagName,
30060:                                      PRBool aAllowEmpty)
    1: {
43504:   nsCOMPtr<nsIDOMElement> tableElt(do_QueryInterface(mContent));
    1:   NS_ENSURE_TRUE(tableElt, PR_FALSE);
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
30060:   tableElt->GetElementsByTagName(aTagName, getter_AddRefs(nodeList));
11916:   NS_ENSURE_TRUE(nodeList, PR_FALSE);
    1: 
  438:   nsCOMPtr<nsIDOMNode> foundItem;
  438:   nodeList->Item(0, getter_AddRefs(foundItem));
30060:   if (!foundItem)
  438:     return PR_FALSE;
30060: 
30060:   if (aAllowEmpty)
30060:     return PR_TRUE;
30060: 
30060:   // Make sure that the item we found has contents and either has multiple
30060:   // children or the found item is not a whitespace-only text node.
  438:   nsCOMPtr<nsIContent> foundItemContent = do_QueryInterface(foundItem);
30060:   if (foundItemContent->GetChildCount() > 1)
  438:     return PR_TRUE; // Treat multiple child nodes as non-empty
30060: 
  438:   nsIContent *innerItemContent = foundItemContent->GetChildAt(0);
30060:   if (innerItemContent && !innerItemContent->TextIsOnlyWhitespace())
  438:     return PR_TRUE;
    1: 
30060:   // If we found more than one node then return true not depending on
30060:   // aAllowEmpty flag.
30060:   // XXX it might be dummy but bug 501375 where we changed this addresses
30060:   // performance problems only. Note, currently 'aAllowEmpty' flag is used for
30060:   // caption element only. On another hand we create accessible object for
30060:   // the first entry of caption element (see
30060:   // nsHTMLTableAccessible::CacheChildren).
30060:   nodeList->Item(1, getter_AddRefs(foundItem));
30060:   return !!foundItem;
    1: }
    1: 
29980: NS_IMETHODIMP
29980: nsHTMLTableAccessible::IsProbablyForLayout(PRBool *aIsProbablyForLayout)
    1: {
    1:   // Implement a heuristic to determine if table is most likely used for layout
    1:   // XXX do we want to look for rowspan or colspan, especialy that span all but a couple cells
    1:   // at the beginning or end of a row/col, and especially when they occur at the edge of a table?
    1:   // XXX expose this info via object attributes to AT-SPI
    1: 
    1:   // XXX For now debugging descriptions are always on via SHOW_LAYOUT_HEURISTIC
    1:   // This will allow release trunk builds to be used by testers to refine the algorithm
    1:   // Change to |#define SHOW_LAYOUT_HEURISTIC DEBUG| before final release
    1: #ifdef SHOW_LAYOUT_HEURISTIC
    1: #define RETURN_LAYOUT_ANSWER(isLayout, heuristic) \
    1:   { *aIsProbablyForLayout = isLayout; \
    1:     mLayoutHeuristic = isLayout ? NS_LITERAL_STRING("layout table: ") : NS_LITERAL_STRING("data table: "); \
    1:     mLayoutHeuristic += NS_LITERAL_STRING(heuristic); return NS_OK; }
    1: #else
    1: #define RETURN_LAYOUT_ANSWER(isLayout, heuristic) { *aIsProbablyForLayout = isLayout; return NS_OK; }
    1: #endif
    1: 
    1:   *aIsProbablyForLayout = PR_FALSE;
    1: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
    1: 
39503:   nsDocAccessible *docAccessible = GetDocAccessible();
  512:   if (docAccessible) {
  512:     PRUint32 state, extState;
21256:     docAccessible->GetState(&state, &extState);
  512:     if (extState & nsIAccessibleStates::EXT_STATE_EDITABLE) {  // Need to see all elements while document is being edited
  512:       RETURN_LAYOUT_ANSWER(PR_FALSE, "In editable document");
  512:     }
  512:   }
  512: 
29980:   // Check to see if an ARIA role overrides the role from native markup,
29980:   // but for which we still expose table semantics (treegrid, for example).
20566:   PRBool hasNonTableRole =
20566:     (nsAccUtils::Role(this) != nsIAccessibleRole::ROLE_TABLE);
    1:   if (hasNonTableRole) {
    1:     RETURN_LAYOUT_ANSWER(PR_FALSE, "Has role attribute");
    1:   }
    1: 
43504:   if (mContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::role)) {
29980:     // Role attribute is present, but overridden roles have already been dealt with.
29980:     // Only landmarks and other roles that don't override the role from native
29980:     // markup are left to deal with here.
29980:     RETURN_LAYOUT_ANSWER(PR_FALSE, "Has role attribute, weak role, and role is table");
    1:   }
    1:   
    1:   // Check for legitimate data table elements or attributes
  438:   nsAutoString summary;
43504:   if ((mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::summary, summary) &&
43504:        !summary.IsEmpty()) || 
30060:       HasDescendant(NS_LITERAL_STRING("caption"), PR_FALSE) ||
30060:       HasDescendant(NS_LITERAL_STRING("th")) ||
30060:       HasDescendant(NS_LITERAL_STRING("thead")) ||
30060:       HasDescendant(NS_LITERAL_STRING("tfoot")) ||
30060:       HasDescendant(NS_LITERAL_STRING("colgroup"))) {
    1:     RETURN_LAYOUT_ANSWER(PR_FALSE, "Has caption, summary, th, thead, tfoot or colgroup -- legitimate table structures");
    1:   }
30060:   if (HasDescendant(NS_LITERAL_STRING("table"))) {
    1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "Has a nested table within it");
    1:   }
    1:   
    1:   // If only 1 column or only 1 row, it's for layout
    1:   PRInt32 columns, rows;
32381:   GetColumnCount(&columns);
    1:   if (columns <=1) {
    1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "Has only 1 column");
    1:   }
32381:   GetRowCount(&rows);
    1:   if (rows <=1) {
    1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "Has only 1 row");
    1:   }
    1: 
    1:   // Check for many columns
    1:   if (columns >= 5) {
    1:     RETURN_LAYOUT_ANSWER(PR_FALSE, ">=5 columns");
    1:   }
    1:   
    1:   // Now we know there are 2-4 columns and 2 or more rows
    1:   // Check to see if there are visible borders on the cells
    1:   // XXX currently, we just check the first cell -- do we really need to do more?
    1:   nsCOMPtr<nsIDOMElement> cellElement;
12645:   nsresult rv = GetCellAt(0, 0, *getter_AddRefs(cellElement));
12645:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
12645: 
    1:   nsCOMPtr<nsIContent> cellContent(do_QueryInterface(cellElement));
    1:   NS_ENSURE_TRUE(cellContent, NS_ERROR_FAILURE);
36654:   nsIFrame *cellFrame = cellContent->GetPrimaryFrame();
 1560:   if (!cellFrame) {
 1560:     return NS_OK;
 1560:   }
    1:   nsMargin border;
    1:   cellFrame->GetBorder(border);
    1:   if (border.top && border.bottom && border.left && border.right) {
    1:     RETURN_LAYOUT_ANSWER(PR_FALSE, "Has nonzero border-width on table cell");
    1:   }
    1: 
    1:   /**
    1:    * Rules for non-bordered tables with 2-4 columns and 2+ rows from here on forward
    1:    */
    1: 
    1:   // Check for styled background color across the row
    1:   // Alternating background color is a common way 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
43504:   nsCOMPtr<nsIDOMElement> tableElt(do_QueryInterface(mContent));    
    1:   tableElt->GetElementsByTagName(NS_LITERAL_STRING("tr"), getter_AddRefs(nodeList));
    1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
    1:   PRUint32 length;
    1:   nodeList->GetLength(&length);
    1:   nsAutoString color, lastRowColor;
29560:   for (PRUint32 rowCount = 0; rowCount < length; rowCount ++) {
    1:     nsCOMPtr<nsIDOMNode> rowNode;
    1:     nodeList->Item(rowCount, getter_AddRefs(rowNode));
43504:     nsCOMPtr<nsIContent> rowContent(do_QueryInterface(rowNode));
19322: 
43504:     nsCOMPtr<nsIDOMCSSStyleDeclaration> styleDecl =
43504:       nsCoreUtils::GetComputedStyleDeclaration(EmptyString(), rowContent);
    1:     NS_ENSURE_TRUE(styleDecl, NS_ERROR_FAILURE);
19322: 
    1:     lastRowColor = color;
    1:     styleDecl->GetPropertyValue(NS_LITERAL_STRING("background-color"), color);
    1:     if (rowCount > 0 && PR_FALSE == lastRowColor.Equals(color)) {
    1:       RETURN_LAYOUT_ANSWER(PR_FALSE, "2 styles of row background color, non-bordered");
    1:     }
    1:   }
    1: 
    1:   // Check for many rows
    1:   const PRInt32 kMaxLayoutRows = 20;
    1:   if (rows > kMaxLayoutRows) { // A ton of rows, this is probably for data
    1:     RETURN_LAYOUT_ANSWER(PR_FALSE, ">= kMaxLayoutRows (20) and non-bordered");
    1:   }
    1: 
    1:   // Check for very wide table
    1:   nsAutoString styledWidth;
    1:   GetComputedStyleValue(EmptyString(), NS_LITERAL_STRING("width"), styledWidth);
    1:   if (styledWidth.EqualsLiteral("100%")) {
    1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "<=4 columns and 100% width");
    1:   }
    1:   if (styledWidth.Find(NS_LITERAL_STRING("px"))) { // Hardcoded in pixels
    1:     nsIFrame *tableFrame = GetFrame();
    1:     NS_ENSURE_TRUE(tableFrame , NS_ERROR_FAILURE);
    1:     nsSize tableSize  = tableFrame->GetSize();
21169: 
43539:     nsDocAccessible *docAccessible = GetDocAccessible();
21169:     NS_ENSURE_TRUE(docAccessible, NS_ERROR_FAILURE);
43539:     nsIFrame *docFrame = docAccessible->GetFrame();
    1:     NS_ENSURE_TRUE(docFrame , NS_ERROR_FAILURE);
21169: 
    1:     nsSize docSize = docFrame->GetSize();
15310:     if (docSize.width > 0) {
    1:       PRInt32 percentageOfDocWidth = (100 * tableSize.width) / docSize.width;
    1:       if (percentageOfDocWidth > 95) {
    1:         // 3-4 columns, no borders, not a lot of rows, and 95% of the doc's width
    1:         // Probably for layout
    1:         RETURN_LAYOUT_ANSWER(PR_TRUE, "<=4 columns, width hardcoded in pixels and 95% of document width");
    1:       }
    1:     }
15310:   }
    1: 
    1:   // Two column rules
    1:   if (rows * columns <= 10) {
    1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "2-4 columns, 10 cells or less, non-bordered");
    1:   }
    1: 
30060:   if (HasDescendant(NS_LITERAL_STRING("embed")) ||
30060:       HasDescendant(NS_LITERAL_STRING("object")) ||
30060:       HasDescendant(NS_LITERAL_STRING("applet")) ||
30060:       HasDescendant(NS_LITERAL_STRING("iframe"))) {
    1:     RETURN_LAYOUT_ANSWER(PR_TRUE, "Has no borders, and has iframe, object, applet or iframe, typical of advertisements");
    1:   }
    1: 
    1:   RETURN_LAYOUT_ANSWER(PR_FALSE, "no layout factor strong enough, so will guess data");
    1: }
    1: 
    1: 
25822: ////////////////////////////////////////////////////////////////////////////////
25822: // nsHTMLCaptionAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
25822: 
 3151: NS_IMETHODIMP
24822: nsHTMLCaptionAccessible::GetRelationByType(PRUint32 aRelationType,
24822:                                            nsIAccessibleRelation **aRelation)
 3151: {
24822:   nsresult rv = nsHyperTextAccessible::GetRelationByType(aRelationType,
24822:                                                          aRelation);
24822:   NS_ENSURE_SUCCESS(rv, rv);
 3151: 
 3151:   if (aRelationType == nsIAccessibleRelation::RELATION_DESCRIPTION_FOR) {
24822:     nsCOMPtr<nsIAccessible> accParent;
24822:     GetParent(getter_AddRefs(accParent));
24822:     return nsRelUtils::AddTarget(aRelationType, aRelation, accParent);
 3151:   }
 3151: 
 3151:   return NS_OK;
 3151: }
 3151: 
25822: nsresult
25822: nsHTMLCaptionAccessible::GetRoleInternal(PRUint32 *aRole)
25822: {
25822:   *aRole = nsIAccessibleRole::ROLE_CAPTION;
25822:   return NS_OK;
25822: }
