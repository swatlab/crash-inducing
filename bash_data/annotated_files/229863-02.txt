 99753: /* This Source Code Form is subject to the terms of the Mozilla Public
 99753:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99753:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 29805:  
157923: #ifndef nsHtml5TreeOperation_h
157923: #define nsHtml5TreeOperation_h
 29805: 
 32917: #include "nsHtml5DocumentMode.h"
 34978: #include "nsHtml5HtmlAttributes.h"
 38132: #include "nsXPCOMStrings.h"
190520: #include "mozilla/dom/FromParser.h"
 29805: 
 51351: class nsIContent;
 32917: class nsHtml5TreeOpExecutor;
 34979: class nsHtml5StateSnapshot;
190519: class nsHtml5DocumentBuilder;
 29805: 
 29805: enum eHtml5TreeOperation {
 34979:   eTreeOpUninitialized,
 29805:   // main HTML5 ops
 29805:   eTreeOpAppend,
 29805:   eTreeOpDetach,
 29805:   eTreeOpAppendChildrenToNewParent,
 29805:   eTreeOpFosterParent,
 29805:   eTreeOpAppendToDocument,
 29805:   eTreeOpAddAttributes,
 32917:   eTreeOpDocumentMode,
 43386:   eTreeOpCreateElementNetwork,
 43386:   eTreeOpCreateElementNotNetwork,
 34978:   eTreeOpSetFormElement,
 35600:   eTreeOpAppendText,
 44175:   eTreeOpAppendIsindexPrompt,
 35600:   eTreeOpFosterParentText,
 35600:   eTreeOpAppendComment,
 35600:   eTreeOpAppendCommentToDocument,
 35600:   eTreeOpAppendDoctypeToDocument,
137419:   eTreeOpGetDocumentFragmentForTemplate,
 29805:   // Gecko-specific on-pop ops
 80404:   eTreeOpMarkAsBroken,
 34978:   eTreeOpRunScript,
 35607:   eTreeOpRunScriptAsyncDefer,
104074:   eTreeOpPreventScriptExecution,
 29805:   eTreeOpDoneAddingChildren,
 29805:   eTreeOpDoneCreatingElement,
 81150:   eTreeOpSetDocumentCharset,
 34979:   eTreeOpNeedsCharsetSwitchTo,
 29805:   eTreeOpUpdateStyleSheet,
 29805:   eTreeOpProcessMeta,
 29805:   eTreeOpProcessOfflineManifest,
 34978:   eTreeOpMarkMalformedIfScript,
 34979:   eTreeOpStreamEnded,
 35294:   eTreeOpSetStyleLineNumber,
 35606:   eTreeOpSetScriptLineNumberAndFreeze,
 47894:   eTreeOpSvgLoad,
 94004:   eTreeOpMaybeComplainAboutCharset,
 81151:   eTreeOpAddClass,
 81151:   eTreeOpAddViewSourceHref,
 81152:   eTreeOpAddError,
 81157:   eTreeOpAddLineNumberId,
 81160:   eTreeOpAddErrorAtom,
 81160:   eTreeOpAddErrorTwoAtoms,
 29805:   eTreeOpStartLayout
 29805: };
 29805: 
 34978: class nsHtml5TreeOperationStringPair {
 34978:   private:
 34978:     nsString mPublicId;
 34978:     nsString mSystemId;
 34978:   public:
 34978:     nsHtml5TreeOperationStringPair(const nsAString& aPublicId, 
 34978:                                    const nsAString& aSystemId)
 34978:       : mPublicId(aPublicId)
190522:       , mSystemId(aSystemId)
190522:     {
 34978:       MOZ_COUNT_CTOR(nsHtml5TreeOperationStringPair);
 34978:     }
 34978:     
190522:     ~nsHtml5TreeOperationStringPair()
190522:     {
 34978:       MOZ_COUNT_DTOR(nsHtml5TreeOperationStringPair);    
 34978:     }
 34978:     
190522:     inline void Get(nsAString& aPublicId, nsAString& aSystemId)
190522:     {
 34978:       aPublicId.Assign(mPublicId);
 34978:       aSystemId.Assign(mSystemId);
 34978:     }
 34978: };
 34978: 
 29805: class nsHtml5TreeOperation {
 29805: 
 29805:   public:
190518:     /**
190518:      * Atom is used inside the parser core are either static atoms that are
190518:      * the same as Gecko-wide static atoms or they are dynamic atoms scoped by
190518:      * both thread and parser to a particular nsHtml5AtomTable. In order to
190518:      * such scoped atoms coming into contact with the rest of Gecko, atoms
190518:      * that are about to exit the parser must go through this method which
190518:      * reobtains dynamic atoms from the Gecko-global atom table.
190518:      *
190518:      * @param aAtom a potentially parser-scoped atom
190518:      * @return an nsIAtom that's pointer comparable on the main thread with
190518:      *         other not-parser atoms.
190518:      */
190518:     static inline already_AddRefed<nsIAtom> Reget(nsIAtom* aAtom)
190518:     {
190518:       if (!aAtom || aAtom->IsStaticAtom()) {
190518:         return dont_AddRef(aAtom);
190518:       }
190518:       nsAutoString str;
190518:       aAtom->ToString(str);
190518:       return do_GetAtom(str);
190518:     }
190518: 
190518:     static nsresult AppendTextToTextNode(const char16_t* aBuffer,
190518:                                          uint32_t aLength,
190518:                                          nsIContent* aTextNode,
190519:                                          nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult AppendText(const char16_t* aBuffer,
190518:                                uint32_t aLength,
190518:                                nsIContent* aParent,
190519:                                nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult Append(nsIContent* aNode,
190518:                            nsIContent* aParent,
190519:                            nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult AppendToDocument(nsIContent* aNode,
190519:                                      nsHtml5DocumentBuilder* aBuilder);
190518: 
190519:     static void Detach(nsIContent* aNode, nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult AppendChildrenToNewParent(nsIContent* aNode,
190518:                                               nsIContent* aParent,
190519:                                               nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult FosterParent(nsIContent* aNode,
190518:                                  nsIContent* aParent,
190518:                                  nsIContent* aTable,
190519:                                  nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult AddAttributes(nsIContent* aNode,
190518:                                   nsHtml5HtmlAttributes* aAttributes,
190519:                                   nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsIContent* CreateElement(int32_t aNs,
190518:                                      nsIAtom* aName,
190518:                                      nsHtml5HtmlAttributes* aAttributes,
190520:                                      mozilla::dom::FromParser aFromParser,
190519:                                      nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static void SetFormElement(nsIContent* aNode, nsIContent* aParent);
190518: 
190518:     static nsresult AppendIsindexPrompt(nsIContent* parent,
190519:                                         nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult FosterParentText(nsIContent* aStackParent,
190518:                                      char16_t* aBuffer,
190518:                                      uint32_t aLength,
190518:                                      nsIContent* aTable,
190519:                                      nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult AppendComment(nsIContent* aParent,
190518:                                   char16_t* aBuffer,
190518:                                   int32_t aLength,
190519:                                   nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult AppendCommentToDocument(char16_t* aBuffer,
190518:                                            int32_t aLength,
190519:                                            nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsresult AppendDoctypeToDocument(nsIAtom* aName,
190518:                                             const nsAString& aPublicId,
190518:                                             const nsAString& aSystemId,
190519:                                             nsHtml5DocumentBuilder* aBuilder);
190518: 
190518:     static nsIContent* GetDocumentFragmentForTemplate(nsIContent* aNode);
190518: 
190518:     static void PreventScriptExecution(nsIContent* aNode);
190518: 
210881:     static void DoneAddingChildren(nsIContent* aNode);
190518: 
190518:     static void DoneCreatingElement(nsIContent* aNode);
190518: 
190523:     static void SvgLoad(nsIContent* aNode);
190523: 
190523:     static void MarkMalformedIfScript(nsIContent* aNode);
190523: 
 29805:     nsHtml5TreeOperation();
 29805: 
 29805:     ~nsHtml5TreeOperation();
 29805: 
190522:     inline void Init(eHtml5TreeOperation aOpCode)
190522:     {
 34979:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34979:         "Op code must be uninitialized when initializing.");
 34979:       mOpCode = aOpCode;
 29805:     }
 29805: 
190522:     inline void Init(eHtml5TreeOperation aOpCode, nsIContentHandle* aNode)
190522:     {
 34979:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34979:         "Op code must be uninitialized when initializing.");
 35295:       NS_PRECONDITION(aNode, "Initialized tree op with null node.");
 29805:       mOpCode = aOpCode;
190517:       mOne.node = static_cast<nsIContent**>(aNode);
 29805:     }
 29805: 
 29805:     inline void Init(eHtml5TreeOperation aOpCode, 
190517:                      nsIContentHandle* aNode,
190522:                      nsIContentHandle* aParent)
190522:     {
 34979:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34979:         "Op code must be uninitialized when initializing.");
 35295:       NS_PRECONDITION(aNode, "Initialized tree op with null node.");
 35295:       NS_PRECONDITION(aParent, "Initialized tree op with null parent.");
 29805:       mOpCode = aOpCode;
190517:       mOne.node = static_cast<nsIContent**>(aNode);
190517:       mTwo.node = static_cast<nsIContent**>(aParent);
 29805:     }
 29805:     
 29805:     inline void Init(eHtml5TreeOperation aOpCode, 
 39511:                      const nsACString& aString,
190522:                      int32_t aInt32)
190522:     {
 62346:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 62346:         "Op code must be uninitialized when initializing.");
 62346: 
108991:       int32_t len = aString.Length();
 62346:       char* str = new char[len + 1];
 62346:       const char* start = aString.BeginReading();
108991:       for (int32_t i = 0; i < len; ++i) {
 62346:         str[i] = start[i];
 62346:       }
 62346:       str[len] = '\0';
 62346: 
 62346:       mOpCode = aOpCode;
 62346:       mOne.charPtr = str;
 81160:       mFour.integer = aInt32;
 39511:     }
 39511: 
 39511:     inline void Init(eHtml5TreeOperation aOpCode,
 94004:                      const nsACString& aString,
108991:                      int32_t aInt32,
190522:                      int32_t aLineNumber)
190522:     {
 94004:       Init(aOpCode, aString, aInt32);
 94004:       mTwo.integer = aLineNumber;
 94004:     }
 94004: 
 94004:     inline void Init(eHtml5TreeOperation aOpCode,
190517:                      nsIContentHandle* aNode,
190517:                      nsIContentHandle* aParent,
190522:                      nsIContentHandle* aTable)
190522:     {
 34979:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34979:         "Op code must be uninitialized when initializing.");
 35295:       NS_PRECONDITION(aNode, "Initialized tree op with null node.");
 35295:       NS_PRECONDITION(aParent, "Initialized tree op with null parent.");
 35295:       NS_PRECONDITION(aTable, "Initialized tree op with null table.");
 29805:       mOpCode = aOpCode;
190517:       mOne.node = static_cast<nsIContent**>(aNode);
190517:       mTwo.node = static_cast<nsIContent**>(aParent);
190517:       mThree.node = static_cast<nsIContent**>(aTable);
 29805:     }
 32917: 
190522:     inline void Init(nsHtml5DocumentMode aMode)
190522:     {
 34979:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34979:         "Op code must be uninitialized when initializing.");
 32917:       mOpCode = eTreeOpDocumentMode;
 34978:       mOne.mode = aMode;
 32917:     }
 32917:     
190522:     inline void InitScript(nsIContentHandle* aNode)
190522:     {
 34981:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34981:         "Op code must be uninitialized when initializing.");
 35295:       NS_PRECONDITION(aNode, "Initialized tree op with null node.");
 34981:       mOpCode = eTreeOpRunScript;
190517:       mOne.node = static_cast<nsIContent**>(aNode);
106838:       mTwo.state = nullptr;
 34981:     }
 34981:     
108991:     inline void Init(int32_t aNamespace, 
 34978:                      nsIAtom* aName, 
 34978:                      nsHtml5HtmlAttributes* aAttributes,
190517:                      nsIContentHandle* aTarget,
190522:                      bool aFromNetwork)
190522:     {
 34979:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34979:         "Op code must be uninitialized when initializing.");
 35295:       NS_PRECONDITION(aName, "Initialized tree op with null name.");
 35295:       NS_PRECONDITION(aTarget, "Initialized tree op with null target node.");
 43386:       mOpCode = aFromNetwork ?
 43386:                 eTreeOpCreateElementNetwork :
 43386:                 eTreeOpCreateElementNotNetwork;
 81160:       mFour.integer = aNamespace;
190517:       mOne.node = static_cast<nsIContent**>(aTarget);
 34978:       mTwo.atom = aName;
 34978:       if (aAttributes == nsHtml5HtmlAttributes::EMPTY_ATTRIBUTES) {
106838:         mThree.attributes = nullptr;
 34978:       } else {
 34978:         mThree.attributes = aAttributes;
 34978:       }
 34978:     }
 34978: 
 34978:     inline void Init(eHtml5TreeOperation aOpCode, 
179103:                      char16_t* aBuffer, 
108991:                      int32_t aLength, 
190517:                      nsIContentHandle* aStackParent,
190522:                      nsIContentHandle* aTable)
190522:     {
 34979:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34979:         "Op code must be uninitialized when initializing.");
 35295:       NS_PRECONDITION(aBuffer, "Initialized tree op with null buffer.");
 34978:       mOpCode = aOpCode;
190517:       mOne.node = static_cast<nsIContent**>(aStackParent);
 35600:       mTwo.unicharPtr = aBuffer;
190517:       mThree.node = static_cast<nsIContent**>(aTable);
 81160:       mFour.integer = aLength;
 35600:     }
 35600: 
 35600:     inline void Init(eHtml5TreeOperation aOpCode, 
179103:                      char16_t* aBuffer, 
108991:                      int32_t aLength, 
190522:                      nsIContentHandle* aParent)
190522:     {
 35600:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 35600:         "Op code must be uninitialized when initializing.");
 35600:       NS_PRECONDITION(aBuffer, "Initialized tree op with null buffer.");
 35600:       mOpCode = aOpCode;
190517:       mOne.node = static_cast<nsIContent**>(aParent);
 35600:       mTwo.unicharPtr = aBuffer;
 81160:       mFour.integer = aLength;
 35600:     }
 35600: 
 35600:     inline void Init(eHtml5TreeOperation aOpCode, 
179103:                      char16_t* aBuffer, 
190522:                      int32_t aLength)
190522:     {
 35600:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 35600:         "Op code must be uninitialized when initializing.");
 35600:       NS_PRECONDITION(aBuffer, "Initialized tree op with null buffer.");
 35600:       mOpCode = aOpCode;
 34978:       mTwo.unicharPtr = aBuffer;
 81160:       mFour.integer = aLength;
 34978:     }
 34978:     
190517:     inline void Init(nsIContentHandle* aElement,
190522:                      nsHtml5HtmlAttributes* aAttributes)
190522:     {
 34979:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34979:         "Op code must be uninitialized when initializing.");
 35295:       NS_PRECONDITION(aElement, "Initialized tree op with null element.");
 34978:       mOpCode = eTreeOpAddAttributes;
190517:       mOne.node = static_cast<nsIContent**>(aElement);
 34978:       mTwo.attributes = aAttributes;
 34978:     }
 34978:     
 34978:     inline void Init(nsIAtom* aName, 
 34978:                      const nsAString& aPublicId, 
190522:                      const nsAString& aSystemId)
190522:     {
 34979:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 34979:         "Op code must be uninitialized when initializing.");
 35600:       mOpCode = eTreeOpAppendDoctypeToDocument;
 34978:       mOne.atom = aName;
 34978:       mTwo.stringPair = new nsHtml5TreeOperationStringPair(aPublicId, aSystemId);
 34978:     }
 34978:     
190517:     inline void Init(nsIContentHandle* aElement,
 81160:                      const char* aMsgId,
 81160:                      nsIAtom* aAtom,
190522:                      nsIAtom* aOtherAtom)
190522:     {
 81152:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 81152:         "Op code must be uninitialized when initializing.");
 81152:       mOpCode = eTreeOpAddError;
190517:       mOne.node = static_cast<nsIContent**>(aElement);
 81152:       mTwo.charPtr = (char*)aMsgId;
 81160:       mThree.atom = aAtom;
 81160:       mFour.atom = aOtherAtom;
 81160:     }
 81160: 
190517:     inline void Init(nsIContentHandle* aElement,
 81160:                      const char* aMsgId,
190522:                      nsIAtom* aAtom)
190522:     {
106838:       Init(aElement, aMsgId, aAtom, nullptr);
 81160:     }
 81160: 
190517:     inline void Init(nsIContentHandle* aElement,
190522:                      const char* aMsgId)
190522:     {
106838:       Init(aElement, aMsgId, nullptr, nullptr);
 81152:     }
 81152: 
 94004:     inline void Init(const char* aMsgId,
 94004:                      bool aError,
190522:                      int32_t aLineNumber)
190522:     {
 94004:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 94004:         "Op code must be uninitialized when initializing.");
 94004:       mOpCode = eTreeOpMaybeComplainAboutCharset;
 94004:       mOne.charPtr = const_cast<char*>(aMsgId);
 94004:       mTwo.integer = aError;
 94004:       mThree.integer = aLineNumber;
 94004:     }
 94004: 
190522:     inline void Init(eHtml5TreeOperation aOpCode, const nsAString& aString)
190522:     {
 38132:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 38132:         "Op code must be uninitialized when initializing.");
 38132: 
179103:       char16_t* str = NS_StringCloneData(aString);
 38132:       mOpCode = aOpCode;
 38132:       mOne.unicharPtr = str;
 38132:     }
 38132:     
 35294:     inline void Init(eHtml5TreeOperation aOpCode,
190517:                      nsIContentHandle* aNode,
190522:                      int32_t aInt)
190522:     {
 35294:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 35294:         "Op code must be uninitialized when initializing.");
 35295:       NS_PRECONDITION(aNode, "Initialized tree op with null node.");
 35294:       mOpCode = aOpCode;
190517:       mOne.node = static_cast<nsIContent**>(aNode);
 81160:       mFour.integer = aInt;
 35294:     }
 35294: 
190522:     inline void InitAddClass(nsIContentHandle* aNode, const char16_t* aClass)
190522:     {
 81151:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 81151:         "Op code must be uninitialized when initializing.");
 81151:       NS_PRECONDITION(aNode, "Initialized tree op with null node.");
 81151:       NS_PRECONDITION(aClass, "Initialized tree op with null string.");
 81151:       // aClass must be a literal string that does not need freeing
 81151:       mOpCode = eTreeOpAddClass;
190517:       mOne.node = static_cast<nsIContent**>(aNode);
179103:       mTwo.unicharPtr = (char16_t*)aClass;
 81151:     }
 81151: 
190517:     inline void InitAddLineNumberId(nsIContentHandle* aNode,
190522:                                     const int32_t aLineNumber)
190522:     {
 81157:       NS_PRECONDITION(mOpCode == eTreeOpUninitialized,
 81157:         "Op code must be uninitialized when initializing.");
 81157:       NS_PRECONDITION(aNode, "Initialized tree op with null node.");
 81157:       NS_PRECONDITION(aLineNumber > 0, "Initialized tree op with line number.");
 81157:       // aClass must be a literal string that does not need freeing
 81157:       mOpCode = eTreeOpAddLineNumberId;
190517:       mOne.node = static_cast<nsIContent**>(aNode);
 81160:       mFour.integer = aLineNumber;
 81157:     }
 81157: 
190522:     inline bool IsRunScript()
190522:     {
 34978:       return mOpCode == eTreeOpRunScript;
 29805:     }
 29805:     
190522:     inline void SetSnapshot(nsAHtml5TreeBuilderState* aSnapshot, int32_t aLine)
190522:     {
 34979:       NS_ASSERTION(IsRunScript(), 
 34979:         "Setting a snapshot for a tree operation other than eTreeOpRunScript!");
 35295:       NS_PRECONDITION(aSnapshot, "Initialized tree op with null snapshot.");
 34979:       mTwo.state = aSnapshot;
 81160:       mFour.integer = aLine;
 34979:     }
 34979: 
190519:     nsresult Perform(nsHtml5TreeOpExecutor* aBuilder,
190519:                      nsIContent** aScriptElement);
190333: 
 29805:   private:
 34978:     // possible optimization:
 34978:     // Make the queue take items the size of pointer and make the op code
 34978:     // decide how many operands it dequeues after it.
 29805:     eHtml5TreeOperation mOpCode;
 34978:     union {
 34978:       nsIContent**                    node;
 34978:       nsIAtom*                        atom;
 34978:       nsHtml5HtmlAttributes*          attributes;
 34978:       nsHtml5DocumentMode             mode;
179103:       char16_t*                      unicharPtr;
 34979:       char*                           charPtr;
 34978:       nsHtml5TreeOperationStringPair* stringPair;
 34979:       nsAHtml5TreeBuilderState*       state;
108991:       int32_t                         integer;
 81160:     }                   mOne, mTwo, mThree, mFour;
 29805: };
 29805: 
157923: #endif // nsHtml5TreeOperation_h
