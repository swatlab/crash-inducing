16299: /*
16299:    Copyright (C) 2003 Commonwealth Scientific and Industrial Research
16299:    Organisation (CSIRO) Australia
16299: 
16299:    Redistribution and use in source and binary forms, with or without
16299:    modification, are permitted provided that the following conditions
16299:    are met:
16299: 
16299:    - Redistributions of source code must retain the above copyright
16299:    notice, this list of conditions and the following disclaimer.
16299: 
16299:    - Redistributions in binary form must reproduce the above copyright
16299:    notice, this list of conditions and the following disclaimer in the
16299:    documentation and/or other materials provided with the distribution.
16299: 
16299:    - Neither the name of CSIRO Australia nor the names of its
16299:    contributors may be used to endorse or promote products derived from
16299:    this software without specific prior written permission.
16299: 
16299:    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
16299:    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
16299:    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
16299:    PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ORGANISATION OR
16299:    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
16299:    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
16299:    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
16299:    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
16299:    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
16299:    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
16299:    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
16299: */
16299: 
16299: /*
16299:  * oggplay.c
16299:  *
16299:  * Shane Stephens <shane.stephens@annodex.net>
16299:  * Michael Martin
16299:  */
16299: 
16299: #include "oggplay_private.h"
16299: #include "oggplay_buffer.h"
16299: 
16299: #include <string.h>
16299: #include <stdlib.h>
16299: 
16299: #define OGGZ_READ_CHUNK_SIZE 8192
16299: 
16299: OggPlay *
16299: oggplay_new_with_reader(OggPlayReader *reader) {
16299: 
16299:   OggPlay * me = (OggPlay *)malloc(sizeof(OggPlay));
16299: 
16299:   me->reader = reader;
16299:   me->decode_data = NULL;
16299:   me->callback_info = NULL;
16299:   me->num_tracks = 0;
16299:   me->all_tracks_initialised = 0;
16299:   me->callback_period = 0;
16299:   me->callback = NULL;
16299:   me->target = 0L;
16299:   me->active_tracks = 0;
16299:   me->buffer = NULL;
16299:   me->shutdown = 0;
16299:   me->trash = NULL;
16299:   me->oggz = NULL;
16299:   me->pt_update_valid = 1;
16299: 
16299:   return me;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_initialise(OggPlay *me, int block) {
16299: 
16299:   OggPlayErrorCode  return_val;
16299:   int               i;
16299: 
16299:   return_val = me->reader->initialise(me->reader, block);
16299: 
16299:   if (return_val != E_OGGPLAY_OK) {
16299:     return return_val;
16299:   }
16299: 
16299:   /*
16299:    * this is the cut-off time value below which packets will be ignored.  Initialise it to 0 here.
16299:    * We'll reinitialise it when/if we encounter a skeleton header
16299:    */
16299:   me->presentation_time = 0;
16299: 
16299:   /*
16299:    * start to retrieve data, until we get all of the track info.  We need
16299:    * to do this now so that the user can query us for this info before entering
16299:    * the main loop
16299:    */
16299:   me->oggz = oggz_new(OGGZ_READ | OGGZ_AUTO);
16299:   oggz_io_set_read(me->oggz, me->reader->io_read, me->reader);
16299:   oggz_io_set_seek(me->oggz, me->reader->io_seek, me->reader);
16299:   oggz_io_set_tell(me->oggz, me->reader->io_tell, me->reader);
16299:   oggz_set_read_callback(me->oggz, -1, oggplay_callback_predetected, me);
16299: 
16299:   while (1) {
16299: 
21124:     if (oggz_read(me->oggz, OGGZ_READ_CHUNK_SIZE) <= 0) {
16299:       return E_OGGPLAY_BAD_INPUT;
16299:     }
16299: 
16299:     if (me->all_tracks_initialised) {
16299:       break;
16299:     }
16299:   }
16299: 
16299:   /*
16299:    * set all the tracks to inactive
16299:    */
16299:   for (i = 0; i < me->num_tracks; i++) {
16299:     me->decode_data[i]->active = 0;
16299:   }
16299: 
16299:   /*
16299:    * if the buffer was set up before initialisation, prepare it now
16299:    */
16299:   if (me->buffer != NULL) {
16299:     oggplay_buffer_prepare(me);
16299:   }
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: OggPlay *
16299: oggplay_open_with_reader(OggPlayReader *reader) {
16299: 
16299:   OggPlay *me = oggplay_new_with_reader(reader);
16299: 
16299:   int r = E_OGGPLAY_TIMEOUT;
16299:   while (r == E_OGGPLAY_TIMEOUT) {
16299:     r = oggplay_initialise(me, 0);
16299:   }
16299: 
16299:   if (r != E_OGGPLAY_OK) {
16299:     free(me);
16299:     return NULL;
16299:   }
16299: 
16299:   return me;
16299: }
16299: 
16299: /*
16299:  * API function to prevent bad input, and to prevent data callbacks being registered
16299:  * in buffer mode
16299:  */
16299: OggPlayErrorCode
16299: oggplay_set_data_callback(OggPlay *me, OggPlayDataCallback callback,
16299:                           void *user) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->buffer != NULL) {
16299:     return E_OGGPLAY_BUFFER_MODE;
16299:   }
16299: 
16299:   oggplay_set_data_callback_force(me, callback, user);
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: /*
16299:  * internal function that doesn't perform error checking.  Used so the buffer
16299:  * can register a callback!
16299:  */
16299: void
16299: oggplay_set_data_callback_force(OggPlay *me, OggPlayDataCallback callback,
16299:                 void *user) {
16299: 
16299:   me->callback = callback;
16299:   me->callback_user_ptr = user;
16299: 
16299: }
16299: 
16299: 
16299: OggPlayErrorCode
16299: oggplay_set_callback_num_frames(OggPlay *me, int track, int frames) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   me->callback_period = me->decode_data[track]->granuleperiod * frames;
16299:   me->target = me->presentation_time + me->callback_period - 1;
16299: 
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_set_offset(OggPlay *me, int track, ogg_int64_t offset) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track <= 0 || track > me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   me->decode_data[track]->offset = (offset << 32);
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_get_video_fps(OggPlay *me, int track, int* fps_denom, int* fps_num) {
16299:   OggPlayTheoraDecode *decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_YUV_VIDEO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayTheoraDecode *)(me->decode_data[track]);
16299: 
16299:   if ((decode->video_info.fps_denominator == 0)
16299:     || (decode->video_info.fps_numerator == 0)) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   (*fps_denom) = decode->video_info.fps_denominator;
16299:   (*fps_num) = decode->video_info.fps_numerator;
16299: 
16299:   return E_OGGPLAY_OK;
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_get_video_y_size(OggPlay *me, int track, int *y_width, int *y_height) {
16299: 
16299:   OggPlayTheoraDecode *decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_YUV_VIDEO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayTheoraDecode *)(me->decode_data[track]);
16299: 
16299:   if (decode->y_width == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   (*y_width) = decode->y_width;
16299:   (*y_height) = decode->y_height;
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_get_video_uv_size(OggPlay *me, int track, int *uv_width, int *uv_height)
16299: {
16299: 
16299:   OggPlayTheoraDecode *decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_YUV_VIDEO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayTheoraDecode *)(me->decode_data[track]);
16299: 
16299:   if (decode->y_width == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   (*uv_width) = decode->uv_width;
16299:   (*uv_height) = decode->uv_height;
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: int
16299: oggplay_get_audio_channels(OggPlay *me, int track, int* channels) {
16299: 
16299:   OggPlayAudioDecode *decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_FLOATS_AUDIO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayAudioDecode *)(me->decode_data[track]);
16299: 
16299:   if (decode->sound_info.channels == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299:   (*channels) = decode->sound_info.channels;
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: int
16299: oggplay_get_audio_samplerate(OggPlay *me, int track, int* rate) {
16299: 
16299:   OggPlayAudioDecode * decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_FLOATS_AUDIO) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayAudioDecode *)(me->decode_data[track]);
16299: 
16299:   if (decode->sound_info.channels == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299:   (*rate) = decode->sound_info.samplerate;
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: int
16299: oggplay_get_kate_category(OggPlay *me, int track, const char** category) {
16608: 
16299:   OggPlayKateDecode * decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_KATE) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayKateDecode *)(me->decode_data[track]);
16299: 
16608: #ifdef HAVE_KATE
16299:   (*category) = decode->k.ki->category;
16299:   return E_OGGPLAY_OK;
16299: #else
16299:   return E_OGGPLAY_NO_KATE_SUPPORT;
16299: #endif
16299: }
16299: 
16299: int
16299: oggplay_get_kate_language(OggPlay *me, int track, const char** language) {
16299: 
16299:   OggPlayKateDecode * decode;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track < 0 || track >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track]->decoded_type != OGGPLAY_KATE) {
16299:     return E_OGGPLAY_WRONG_TRACK_TYPE;
16299:   }
16299: 
16299:   decode = (OggPlayKateDecode *)(me->decode_data[track]);
16299: 
16299: #ifdef HAVE_KATE
16299:   (*language) = decode->k.ki->language;
16299:   return E_OGGPLAY_OK;
16299: #else
16299:   return E_OGGPLAY_NO_KATE_SUPPORT;
16299: #endif
16299: }
16299: 
16299: #define MAX_CHUNK_COUNT   10
16299: 
16299: OggPlayErrorCode
16299: oggplay_step_decoding(OggPlay *me) {
16299: 
16299:   OggPlayCallbackInfo  ** info;
16299:   int                     num_records;
16299:   int                     r;
16299:   int                     i;
16299:   int                     need_data  = 0;
16299:   int                     chunk_count = 0;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   /*
16299:    * clean up any trash pointers.  As soon as the current buffer has a
16299:    * frame taken out, we know the old buffer will no longer be used.
16299:    */
16299: 
16299:   if (me->trash != NULL && me->buffer->last_emptied > -1) {
16299:     oggplay_take_out_trash(me, me->trash);
16299:     me->trash = NULL;
16299:   }
16299: 
16299: read_more_data:
16299: 
16299:   while (1) {
16299:      /*
16299:      * if there are no active tracks, we might need to return some data
16299:      * left over at the end of a once-active track that has had all of its
16299:      * data processed.  Look through the tracks to find these overhangs
16299:      */
16299:     int r;
16299: 
16299:     if (me->active_tracks == 0) {
16299:       int remaining = 0;
16299:       for (i = 0; i < me->num_tracks; i++) {
16299:         if (me->decode_data[i]->current_loc +
16299:                      me->decode_data[i]->granuleperiod >= me->target + me->decode_data[i]->offset) {
16299:           remaining++;
16299:         }
16299:       }
16299:       if (remaining == 0) {
16299:         return E_OGGPLAY_OK;
16299:       }
16299:     }
16299: 
16299:     /*
16299:      * if any of the tracks have not yet met the target (modified by that
16299:      * track's offset), then retrieve more data
16299:      */
16299:     need_data = 0;
16299:     for (i = 0; i < me->num_tracks; i++) {
16299:       if (me->decode_data[i]->active == 0)
16299:         continue;
16299:       if (me->decode_data[i]->content_type == OGGZ_CONTENT_CMML)
16299:         continue;
16299:       if (me->decode_data[i]->content_type == OGGZ_CONTENT_KATE)
16299:         continue;
16299:       if
16299:       (
16299:         me->decode_data[i]->current_loc
16299:         <
16299:         me->target + me->decode_data[i]->offset
16299:       )
16299:       {
16299:         need_data = 1;
16299:         break;
16299:       }
16299:     }
16299: 
16299:     if (!need_data) {
16299:       break;
16299:     }
16299: 
16299:     /*
16299:      * get a chunk of data.  If we're at the end of the file, then we must
16299:      * have some final frames to render (?).  E_OGGPLAY_END_OF_FILE is
16299:      * only returned if there is *no* more data.
16299:      */
16299: 
16299:     if (chunk_count > MAX_CHUNK_COUNT) {
16299:       return E_OGGPLAY_TIMEOUT;
16299:     }
16299: 
16299:     chunk_count += 1;
16299: 
16299:     r = oggz_read(me->oggz, OGGZ_READ_CHUNK_SIZE);
16299: 
16299:     /* end-of-file */
16299:     if (r == 0) {
16299:       num_records = oggplay_callback_info_prepare(me, &info);
16299:      /*
16299:        * set all of the tracks to active
16299:        */
16299:       for (i = 0; i < me->num_tracks; i++) {
16299:         me->decode_data[i]->active = 0;
16299:         me->active_tracks = 0;
16299:       }
16299: 
16299:       if (info != NULL) {
16299:         me->callback (me, num_records, info, me->callback_user_ptr);
16299:         oggplay_callback_info_destroy(me, info);
16299:       }
16299: 
16299:       /*
24450:        * ensure all tracks have their final data packet set to end_of_stream.
24450:        * But skip doing this if we're shutting down --- me->buffer may not
24450:        * be in a safe state.
16299:        */
24450:       if (me->buffer != NULL && !me->shutdown) {
16299:         oggplay_buffer_set_last_data(me, me->buffer);
16299:       }
16299: 
16299:       return E_OGGPLAY_OK;
16299:     }
16299: 
16299:   }
16299:   /*
16299:    * prepare a callback
16299:    */
16299:   num_records = oggplay_callback_info_prepare (me, &info);
16299:   if (info != NULL) {
16299:     r = me->callback (me, num_records, info, me->callback_user_ptr);
16299:     oggplay_callback_info_destroy (me, info);
16299:   } else {
16299:     r = 0;
16299:   }
16299: 
16299:   /*
16299:    * clean the data lists
16299:    */
16299:   for (i = 0; i < me->num_tracks; i++) {
16299:     oggplay_data_clean_list (me->decode_data[i]);
16299:   }
16299: 
16299:   if (info == NULL) {
16299:     goto read_more_data;
16299:   }
16299: 
16299:   me->target += me->callback_period;
16299:   if (me->shutdown) {
16299:     return E_OGGPLAY_OK;
16299:   }
16299:   if (r == -1) {
16299:     return E_OGGPLAY_USER_INTERRUPT;
16299:   }
16299: 
16299:   return E_OGGPLAY_CONTINUE;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_start_decoding(OggPlay *me) {
16299: 
16299:   int r;
16299: 
16299:   while (1) {
16299:     if ((r = oggplay_step_decoding(me)) != E_OGGPLAY_CONTINUE)
16299:       return (OggPlayErrorCode)r;
16299:   }
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_close(OggPlay *me) {
16299: 
16299:   int i;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->reader != NULL) {
16299:     me->reader->destroy(me->reader);
16299:   }
16299: 
16299:   for (i = 0; i < me->num_tracks; i++) {
16299:     oggplay_callback_shutdown(me->decode_data[i]);
16299:   }
16299: 
16299:   oggz_close(me->oggz);
16299: 
16299:   if (me->buffer != NULL) {
16299:     oggplay_buffer_shutdown(me, me->buffer);
16299:   }
16299: 
16299:   free(me);
16299: 
16299:   return E_OGGPLAY_OK;
16299: }
16299: 
16299: /*
16299:  * this function is required to release the frame_sem in the buffer, if
16299:  * the buffer is being used.
16299:  */
16299: void
16299: oggplay_prepare_for_close(OggPlay *me) {
16299: 
16299:   me->shutdown = 1;
16299:   if (me->buffer != NULL) {
16299:     SEM_SIGNAL(((OggPlayBuffer *)(me->buffer))->frame_sem);
16299:   }
16299: }
16299: 
16299: int
16299: oggplay_get_available(OggPlay *me) {
16299: 
16299:   ogg_int64_t current_time, current_byte;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   current_time = oggz_tell_units(me->oggz);
16299:   current_byte = (ogg_int64_t)oggz_tell(me->oggz);
16299: 
16299:   return me->reader->available(me->reader, current_byte, current_time);
16299: 
16299: }
16299: 
21265: ogg_int64_t
16299: oggplay_get_duration(OggPlay *me) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
21265:   if (me->reader->duration) 
16299:     return me->reader->duration(me->reader);
21265:   else {
21541:     ogg_int64_t pos;
21541:     ogg_int64_t duration;
21541:     pos = oggz_tell_units(me->oggz);
21541:     duration = oggz_seek_units(me->oggz, 0, SEEK_END);
21265:     oggz_seek_units(me->oggz, pos, SEEK_SET);
21541:     oggplay_seek_cleanup(me, pos);
21265:     return duration;
21265:   }
16299: }
16299: 
16299: int
16299: oggplay_media_finished_retrieving(OggPlay *me) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->reader == NULL) {
16299:     return E_OGGPLAY_BAD_READER;
16299:   }
16299: 
16299:   return me->reader->finished_retrieving(me->reader);
16299: 
16299: }
