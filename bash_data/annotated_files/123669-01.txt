     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * Implementation of the DOM nsIDOMRange object.
     1:  */
     1: 
     1: #include "nscore.h"
     1: #include "nsRange.h"
     1: 
     1: #include "nsString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMDocumentFragment.h"
 94562: #include "nsIDOMDocumentType.h"
     1: #include "nsIContent.h"
     1: #include "nsIDocument.h"
     1: #include "nsIDOMText.h"
108290: #include "nsError.h"
     1: #include "nsIContentIterator.h"
     1: #include "nsIDOMNodeList.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsContentUtils.h"
 16205: #include "nsGenericDOMDataNode.h"
 33027: #include "nsClientRect.h"
 33027: #include "nsLayoutUtils.h"
 33027: #include "nsTextFrame.h"
 71908: #include "nsFontFaceList.h"
 95603: #include "mozilla/Telemetry.h"
120353: #include "mozilla/Likely.h"
 95603: 
 95603: using namespace mozilla;
     1: 
     1: /******************************************************
     1:  * stack based utilty class for managing monitor
     1:  ******************************************************/
     1: 
     1: // NS_ERROR_DOM_NOT_OBJECT_ERR is not the correct one to throw, but spec doesn't say
     1: // what is
     1: #define VALIDATE_ACCESS(node_)                                                     \
     1:   PR_BEGIN_MACRO                                                                   \
     1:     if (!node_) {                                                                  \
     1:       return NS_ERROR_DOM_NOT_OBJECT_ERR;                                          \
     1:     }                                                                              \
     1:     if (!nsContentUtils::CanCallerAccess(node_)) {                                 \
     1:       return NS_ERROR_DOM_SECURITY_ERR;                                            \
     1:     }                                                                              \
     1:   PR_END_MACRO
     1: 
 86160: static void InvalidateAllFrames(nsINode* aNode)
 86160: {
 86160:   NS_PRECONDITION(aNode, "bad arg");
 86160: 
106838:   nsIFrame* frame = nullptr;
 86160:   switch (aNode->NodeType()) {
 86160:     case nsIDOMNode::TEXT_NODE:
 86160:     case nsIDOMNode::ELEMENT_NODE:
 86160:     {
 86160:       nsIContent* content = static_cast<nsIContent*>(aNode);
 86160:       frame = content->GetPrimaryFrame();
 86160:       break;
 86160:     }
 86160:     case nsIDOMNode::DOCUMENT_NODE:
 86160:     {
 86160:       nsIDocument* doc = static_cast<nsIDocument*>(aNode);
106838:       nsIPresShell* shell = doc ? doc->GetShell() : nullptr;
106838:       frame = shell ? shell->GetRootFrame() : nullptr;
 86160:       break;
 86160:     }
 86160:   }
 86160:   for (nsIFrame* f = frame; f; f = f->GetNextContinuation()) {
 86160:     f->InvalidateFrameSubtree();
 86160:   }
 86160: }
 86160: 
     1: // Utility routine to detect if a content node is completely contained in a range
     1: // If outNodeBefore is returned true, then the node starts before the range does.
     1: // If outNodeAfter is returned true, then the node ends after the range does.
     1: // Note that both of the above might be true.
     1: // If neither are true, the node is contained inside of the range.
     1: // XXX - callers responsibility to ensure node in same doc as range! 
     1: 
     1: // static
     1: nsresult
 86939: nsRange::CompareNodeToRange(nsINode* aNode, nsRange* aRange,
 79445:                             bool *outNodeBefore, bool *outNodeAfter)
     1: {
 12178:   NS_ENSURE_STATE(aNode);
     1:   // create a pair of dom points that expresses location of node:
     1:   //     NODE(start), NODE(end)
     1:   // Let incoming range be:
     1:   //    {RANGE(start), RANGE(end)}
     1:   // if (RANGE(start) <= NODE(start))  and (RANGE(end) => NODE(end))
     1:   // then the Node is contained (completely) by the Range.
     1:   
 26992:   if (!aRange || !aRange->IsPositioned()) 
     1:     return NS_ERROR_UNEXPECTED; 
     1:   
     1:   // gather up the dom point info
108991:   int32_t nodeStart, nodeEnd;
119415:   nsINode* parent = aNode->GetParentNode();
     1:   if (!parent) {
     1:     // can't make a parent/offset pair to represent start or 
 20503:     // end of the root node, because it has no parent.
     1:     // so instead represent it by (node,0) and (node,numChildren)
     1:     parent = aNode;
     1:     nodeStart = 0;
     1:     nodeEnd = aNode->GetChildCount();
     1:   }
     1:   else {
     1:     nodeStart = parent->IndexOf(aNode);
     1:     nodeEnd = nodeStart + 1;
     1:   }
     1: 
 26992:   nsINode* rangeStartParent = aRange->GetStartParent();
 26992:   nsINode* rangeEndParent = aRange->GetEndParent();
108991:   int32_t rangeStartOffset = aRange->StartOffset();
108991:   int32_t rangeEndOffset = aRange->EndOffset();
     1: 
     1:   // is RANGE(start) <= NODE(start) ?
 79445:   bool disconnected = false;
     1:   *outNodeBefore = nsContentUtils::ComparePoints(rangeStartParent,
     1:                                                  rangeStartOffset,
 12178:                                                  parent, nodeStart,
 12178:                                                  &disconnected) > 0;
 12178:   NS_ENSURE_TRUE(!disconnected, NS_ERROR_DOM_WRONG_DOCUMENT_ERR);
 12178: 
     1:   // is RANGE(end) >= NODE(end) ?
     1:   *outNodeAfter = nsContentUtils::ComparePoints(rangeEndParent,
     1:                                                 rangeEndOffset,
 12178:                                                 parent, nodeEnd,
 12178:                                                 &disconnected) < 0;
 12178:   NS_ENSURE_TRUE(!disconnected, NS_ERROR_DOM_WRONG_DOCUMENT_ERR);
     1:   return NS_OK;
     1: }
     1: 
 85101: struct FindSelectedRangeData
 85101: {
 85101:   nsINode*  mNode;
 86939:   nsRange* mResult;
108991:   uint32_t  mStartOffset;
108991:   uint32_t  mEndOffset;
 85101: };
 85101: 
 85101: static PLDHashOperator
 86939: FindSelectedRange(nsPtrHashKey<nsRange>* aEntry, void* userArg)
 85101: {
 86939:   nsRange* range = aEntry->GetKey();
 85101:   if (range->IsInSelection() && !range->Collapsed()) {
 85101:     FindSelectedRangeData* data = static_cast<FindSelectedRangeData*>(userArg);
108991:     int32_t cmp = nsContentUtils::ComparePoints(data->mNode, data->mEndOffset,
 85101:                                                 range->GetStartParent(),
 85101:                                                 range->StartOffset());
 85101:     if (cmp == 1) {
 85101:       cmp = nsContentUtils::ComparePoints(data->mNode, data->mStartOffset,
 85101:                                           range->GetEndParent(),
 85101:                                           range->EndOffset());
 85101:       if (cmp == -1) {
 85101:         data->mResult = range;
 85101:         return PL_DHASH_STOP;
 85101:       }
 85101:     }
 85101:   }
 85101:   return PL_DHASH_NEXT;
 85101: }
 85101: 
 85101: static nsINode*
 85101: GetNextRangeCommonAncestor(nsINode* aNode)
 85101: {
 85101:   while (aNode && !aNode->IsCommonAncestorForRangeInSelection()) {
 85101:     if (!aNode->IsDescendantOfCommonAncestorForRangeInSelection()) {
106838:       return nullptr;
 85101:     }
119415:     aNode = aNode->GetParentNode();
 85101:   }
 85101:   return aNode;
 85101: }
 85101: 
 85101: /* static */ bool
108991: nsRange::IsNodeSelected(nsINode* aNode, uint32_t aStartOffset,
108991:                         uint32_t aEndOffset)
 85101: {
 85101:   NS_PRECONDITION(aNode, "bad arg");
 85101: 
106838:   FindSelectedRangeData data = { aNode, nullptr, aStartOffset, aEndOffset };
 85101:   nsINode* n = GetNextRangeCommonAncestor(aNode);
 85101:   NS_ASSERTION(n || !aNode->IsSelectionDescendant(),
 85101:                "orphan selection descendant");
119415:   for (; n; n = GetNextRangeCommonAncestor(n->GetParentNode())) {
 85101:     RangeHashTable* ranges =
 85101:       static_cast<RangeHashTable*>(n->GetProperty(nsGkAtoms::range));
 85101:     ranges->EnumerateEntries(FindSelectedRange, &data);
 85101:     if (data.mResult) {
 85101:       return true;
 85101:     }
 85101:   }
 85101:   return false;
 85101: }
 85101: 
     1: /******************************************************
     1:  * constructor/destructor
     1:  ******************************************************/
     1: 
     1: nsRange::~nsRange() 
     1: {
 85101:   NS_ASSERTION(!IsInSelection(), "deleting nsRange that is in use");
 85101: 
 95603:   // Maybe we can remove Detach() -- bug 702948.
 95603:   Telemetry::Accumulate(Telemetry::DOM_RANGE_DETACHED, mIsDetached);
 95603: 
 85101:   // we want the side effects (releases and list removals)
106838:   DoSetRange(nullptr, 0, nullptr, 0, nullptr);
     1: } 
     1: 
 87303: /* static */
 87303: nsresult
108991: nsRange::CreateRange(nsIDOMNode* aStartParent, int32_t aStartOffset,
108991:                      nsIDOMNode* aEndParent, int32_t aEndOffset,
 87303:                      nsRange** aRange)
 87303: {
 87303:   MOZ_ASSERT(aRange);
 87303:   *aRange = NULL;
 87303: 
 87303:   nsRefPtr<nsRange> range = new nsRange();
 87303: 
 87303:   nsresult rv = range->SetStart(aStartParent, aStartOffset);
 87303:   NS_ENSURE_SUCCESS(rv, rv);
 87303: 
 87303:   rv = range->SetEnd(aEndParent, aEndOffset);
 87303:   NS_ENSURE_SUCCESS(rv, rv);
 87303: 
 87303:   range.forget(aRange);
 87303:   return NS_OK;
 87303: }
 87303: 
 87303: /* static */
 87303: nsresult
108991: nsRange::CreateRange(nsIDOMNode* aStartParent, int32_t aStartOffset,
108991:                      nsIDOMNode* aEndParent, int32_t aEndOffset,
 87303:                      nsIDOMRange** aRange)
 87303: {
 87303:   nsRefPtr<nsRange> range;
 87303:   nsresult rv = nsRange::CreateRange(aStartParent, aStartOffset, aEndParent,
 87303:                                      aEndOffset, getter_AddRefs(range));
 87303:   range.forget(aRange);
 87303:   return rv;
 87303: }
 87303: 
     1: /******************************************************
     1:  * nsISupports
     1:  ******************************************************/
     1: 
 22215: NS_IMPL_CYCLE_COLLECTION_CLASS(nsRange)
 22215: 
 22215: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsRange)
 22215: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsRange)
 22215: 
 40490: DOMCI_DATA(Range, nsRange)
 40490: 
     1: // QueryInterface implementation for nsRange
 22215: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsRange)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMRange)
     1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
 86939:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMRange)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Range)
     1: NS_INTERFACE_MAP_END
     1: 
 22215: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsRange)
 22215:   tmp->Reset();
 22215: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 22215: 
 22215: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsRange)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mStartParent)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEndParent)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRoot)
 22215: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
     1: 
 85101: static void
 85101: RangeHashTableDtor(void* aObject, nsIAtom* aPropertyName, void* aPropertyValue,
 85101:                    void* aData)
 85101: {
 86939:   nsRange::RangeHashTable* ranges =
 86939:     static_cast<nsRange::RangeHashTable*>(aPropertyValue);
 85101:   delete ranges;
 85101: }
 85101: 
 85101: static void MarkDescendants(nsINode* aNode)
 85101: {
 85101:   // Set NodeIsDescendantOfCommonAncestorForRangeInSelection on aNode's
 85101:   // descendants unless aNode is already marked as a range common ancestor
 85101:   // or a descendant of one, in which case all of our descendants have the
 85101:   // bit set already.
 85101:   if (!aNode->IsSelectionDescendant()) {
 85101:     // don't set the Descendant bit on |aNode| itself
 85101:     nsINode* node = aNode->GetNextNode(aNode);
 85101:     while (node) {
 85101:       node->SetDescendantOfCommonAncestorForRangeInSelection();
 85101:       if (!node->IsCommonAncestorForRangeInSelection()) {
 85101:         node = node->GetNextNode(aNode);
 85101:       } else {
 85101:         // optimize: skip this sub-tree since it's marked already.
 85101:         node = node->GetNextNonChildNode(aNode);
 85101:       }
 85101:     }
 85101:   }
 85101: }
 85101: 
 85101: static void UnmarkDescendants(nsINode* aNode)
 85101: {
 85101:   // Unset NodeIsDescendantOfCommonAncestorForRangeInSelection on aNode's
 85101:   // descendants unless aNode is a descendant of another range common ancestor.
 85101:   // Also, exclude descendants of range common ancestors (but not the common
 85101:   // ancestor itself).
 85101:   if (!aNode->IsDescendantOfCommonAncestorForRangeInSelection()) {
 85101:     // we know |aNode| doesn't have any bit set
 85101:     nsINode* node = aNode->GetNextNode(aNode);
 85101:     while (node) {
 85101:       node->ClearDescendantOfCommonAncestorForRangeInSelection();
 85101:       if (!node->IsCommonAncestorForRangeInSelection()) {
 85101:         node = node->GetNextNode(aNode);
 85101:       } else {
 85101:         // We found an ancestor of an overlapping range, skip its descendants.
 85101:         node = node->GetNextNonChildNode(aNode);
 85101:       }
 85101:     }
 85101:   }
 85101: }
 85101: 
 85101: void
 86939: nsRange::RegisterCommonAncestor(nsINode* aNode)
 85101: {
 85101:   NS_PRECONDITION(aNode, "bad arg");
 85101:   NS_ASSERTION(IsInSelection(), "registering range not in selection");
 85101: 
 85101:   MarkDescendants(aNode);
 85101: 
 85101:   RangeHashTable* ranges =
 85101:     static_cast<RangeHashTable*>(aNode->GetProperty(nsGkAtoms::range));
 85101:   if (!ranges) {
 85101:     ranges = new RangeHashTable;
 85101:     ranges->Init();
 86178:     aNode->SetProperty(nsGkAtoms::range, ranges, RangeHashTableDtor, true);
 85101:   }
 85101:   ranges->PutEntry(this);
 85101:   aNode->SetCommonAncestorForRangeInSelection();
 85101: }
 85101: 
 85101: void
 86939: nsRange::UnregisterCommonAncestor(nsINode* aNode)
 85101: {
 85101:   NS_PRECONDITION(aNode, "bad arg");
 85101:   NS_ASSERTION(aNode->IsCommonAncestorForRangeInSelection(), "wrong node");
 85101:   RangeHashTable* ranges =
 85101:     static_cast<RangeHashTable*>(aNode->GetProperty(nsGkAtoms::range));
 85101:   NS_ASSERTION(ranges->GetEntry(this), "unknown range");
 85101: 
 85101:   if (ranges->Count() == 1) {
 85101:     aNode->ClearCommonAncestorForRangeInSelection();
 85101:     aNode->DeleteProperty(nsGkAtoms::range);
 85101:     UnmarkDescendants(aNode);
 85101:   } else {
 85101:     ranges->RemoveEntry(this);
 85101:   }
 85101: }
 85101: 
     1: /******************************************************
     1:  * nsIMutationObserver implementation
     1:  ******************************************************/
     1: 
     1: void
     1: nsRange::CharacterDataChanged(nsIDocument* aDocument,
     1:                               nsIContent* aContent,
     1:                               CharacterDataChangeInfo* aInfo)
     1: {
123668:   MOZ_ASSERT(mAssertNextInsertOrAppendIndex == -1,
123668:              "splitText failed to notify insert/append?");
     1:   NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
     1: 
106838:   nsINode* newRoot = nullptr;
106838:   nsINode* newStartNode = nullptr;
106838:   nsINode* newEndNode = nullptr;
108991:   uint32_t newStartOffset = 0;
108991:   uint32_t newEndOffset = 0;
 78794: 
123668:   if (aInfo->mDetails &&
123668:       aInfo->mDetails->mType == CharacterDataChangeInfo::Details::eSplit) {
123668:     // If the splitted text node is immediately before a range boundary point
123668:     // that refers to a child index (i.e. its parent is the boundary container)
123668:     // then we need to increment the corresponding offset to account for the new
123668:     // text node that will be inserted.  If so, we need to prevent the next
123668:     // ContentInserted or ContentAppended for this range from incrementing it
123668:     // again (when the new text node is notified).
123668:     nsINode* parentNode = aContent->GetParentNode();
123668:     int32_t index = -1;
123668:     if (parentNode == mEndParent && mEndOffset > 0 &&
123668:         (index = parentNode->IndexOf(aContent)) + 1 == mEndOffset) {
123668:       ++mEndOffset;
123668:       mEndOffsetWasIncremented = true;
123668:     }
123668:     if (parentNode == mStartParent && mStartOffset > 0 &&
123668:         (index != -1 ? index : parentNode->IndexOf(aContent)) + 1 == mStartOffset) {
123668:       ++mStartOffset;
123668:       mStartOffsetWasIncremented = true;
123668:     }
123668: #ifdef DEBUG
123668:     if (mStartOffsetWasIncremented || mEndOffsetWasIncremented) {
123668:       mAssertNextInsertOrAppendIndex =
123668:         (mStartOffsetWasIncremented ? mStartOffset : mEndOffset) - 1;
123668:       mAssertNextInsertOrAppendNode = aInfo->mDetails->mNextSibling;
123668:     }
123668: #endif
123668:   }
123668: 
 11516:   // If the changed node contains our start boundary and the change starts
 11516:   // before the boundary we'll need to adjust the offset.
     1:   if (aContent == mStartParent &&
108991:       aInfo->mChangeStart < static_cast<uint32_t>(mStartOffset)) {
 76359:     if (aInfo->mDetails) {
 76359:       // splitText(), aInfo->mDetails->mNextSibling is the new text node
 76359:       NS_ASSERTION(aInfo->mDetails->mType ==
 76359:                    CharacterDataChangeInfo::Details::eSplit,
 76359:                    "only a split can start before the end");
108991:       NS_ASSERTION(static_cast<uint32_t>(mStartOffset) <= aInfo->mChangeEnd + 1,
 76359:                    "mStartOffset is beyond the end of this node");
108991:       newStartOffset = static_cast<uint32_t>(mStartOffset) - aInfo->mChangeStart;
 78794:       newStartNode = aInfo->mDetails->mNextSibling;
120353:       if (MOZ_UNLIKELY(aContent == mRoot)) {
 78794:         newRoot = IsValidBoundary(newStartNode);
 78794:       }
 85101: 
 85101:       bool isCommonAncestor = IsInSelection() && mStartParent == mEndParent;
 85101:       if (isCommonAncestor) {
 85101:         UnregisterCommonAncestor(mStartParent);
 85101:         RegisterCommonAncestor(newStartNode);
 85101:       }
 85101:       if (mStartParent->IsDescendantOfCommonAncestorForRangeInSelection()) {
 85101:         newStartNode->SetDescendantOfCommonAncestorForRangeInSelection();
 85101:       }
 76359:     } else {
 11516:       // If boundary is inside changed text, position it before change
 76359:       // else adjust start offset for the change in length.
108991:       mStartOffset = static_cast<uint32_t>(mStartOffset) <= aInfo->mChangeEnd ?
     1:         aInfo->mChangeStart :
     1:         mStartOffset + aInfo->mChangeStart - aInfo->mChangeEnd +
     1:           aInfo->mReplaceLength;
     1:     }
 76359:   }
     1: 
 78794:   // Do the same thing for the end boundary, except for splitText of a node
 78794:   // with no parent then only switch to the new node if the start boundary
 78794:   // did so too (otherwise the range would end up with disconnected nodes).
 78794:   if (aContent == mEndParent &&
108991:       aInfo->mChangeStart < static_cast<uint32_t>(mEndOffset)) {
119415:     if (aInfo->mDetails && (aContent->GetParentNode() || newStartNode)) {
 76359:       // splitText(), aInfo->mDetails->mNextSibling is the new text node
 76359:       NS_ASSERTION(aInfo->mDetails->mType ==
 76359:                    CharacterDataChangeInfo::Details::eSplit,
 76359:                    "only a split can start before the end");
108991:       NS_ASSERTION(static_cast<uint32_t>(mEndOffset) <= aInfo->mChangeEnd + 1,
 76359:                    "mEndOffset is beyond the end of this node");
108991:       newEndOffset = static_cast<uint32_t>(mEndOffset) - aInfo->mChangeStart;
 78794:       newEndNode = aInfo->mDetails->mNextSibling;
 85101: 
 85101:       bool isCommonAncestor = IsInSelection() && mStartParent == mEndParent;
 85101:       if (isCommonAncestor && !newStartNode) {
 85101:         // The split occurs inside the range.
 85101:         UnregisterCommonAncestor(mStartParent);
119415:         RegisterCommonAncestor(mStartParent->GetParentNode());
 85101:         newEndNode->SetDescendantOfCommonAncestorForRangeInSelection();
 85101:       } else if (mEndParent->IsDescendantOfCommonAncestorForRangeInSelection()) {
 85101:         newEndNode->SetDescendantOfCommonAncestorForRangeInSelection();
 85101:       }
 76359:     } else {
108991:       mEndOffset = static_cast<uint32_t>(mEndOffset) <= aInfo->mChangeEnd ?
     1:         aInfo->mChangeStart :
     1:         mEndOffset + aInfo->mChangeStart - aInfo->mChangeEnd +
     1:           aInfo->mReplaceLength;
     1:     }
     1:   }
     1: 
 76359:   if (aInfo->mDetails &&
 76359:       aInfo->mDetails->mType == CharacterDataChangeInfo::Details::eMerge) {
 76359:     // normalize(), aInfo->mDetails->mNextSibling is the merged text node
 76359:     // that will be removed
 76359:     nsIContent* removed = aInfo->mDetails->mNextSibling;
 76359:     if (removed == mStartParent) {
108991:       newStartOffset = static_cast<uint32_t>(mStartOffset) + aInfo->mChangeStart;
 78794:       newStartNode = aContent;
120353:       if (MOZ_UNLIKELY(removed == mRoot)) {
 78794:         newRoot = IsValidBoundary(newStartNode);
 78794:       }
 76359:     }
 76359:     if (removed == mEndParent) {
108991:       newEndOffset = static_cast<uint32_t>(mEndOffset) + aInfo->mChangeStart;
 78794:       newEndNode = aContent;
120353:       if (MOZ_UNLIKELY(removed == mRoot)) {
 78794:         newRoot = IsValidBoundary(newEndNode);
 76359:       }
 76359:     }
123669:     // When the removed text node's parent is one of our boundary nodes we may
123669:     // need to adjust the offset to account for the removed node. However,
123669:     // there will also be a ContentRemoved notification later so the only cases
123669:     // we need to handle here is when the removed node is the text node after
123669:     // the boundary.  (The m*Offset > 0 check is an optimization - a boundary
123669:     // point before the first child is never affected by normalize().)
123669:     nsINode* parentNode = aContent->GetParentNode();
123669:     if (parentNode == mStartParent && mStartOffset > 0 &&
123669:         mStartOffset < parentNode->GetChildCount() &&
123669:         removed == parentNode->GetChildAt(mStartOffset)) {
123669:       newStartNode = aContent;
123669:       newStartOffset = aInfo->mChangeStart;
 76359:     }
123669:     if (parentNode == mEndParent && mEndOffset > 0 &&
123669:         mEndOffset < parentNode->GetChildCount() &&
123669:         removed == parentNode->GetChildAt(mEndOffset)) {
123669:       newEndNode = aContent;
123669:       newEndOffset = aInfo->mChangeEnd;
123669:     }
123669:   }
123669: 
 78794:   if (newStartNode || newEndNode) {
 78794:     if (!newStartNode) {
 78794:       newStartNode = mStartParent;
 78794:       newStartOffset = mStartOffset;
 78794:     }
 78794:     if (!newEndNode) {
 78794:       newEndNode = mEndParent;
 78794:       newEndOffset = mEndOffset;
 78794:     }
 78794:     DoSetRange(newStartNode, newStartOffset, newEndNode, newEndOffset,
 85101:                newRoot ? newRoot : mRoot.get(),
119415:                !newEndNode->GetParentNode() || !newStartNode->GetParentNode());
 85101:   }
 85101: }
 85101: 
 85101: void
 85101: nsRange::ContentAppended(nsIDocument* aDocument,
 85101:                          nsIContent*  aContainer,
 85101:                          nsIContent*  aFirstNewContent,
108991:                          int32_t      aNewIndexInContainer)
 85101: {
 85101:   NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
 85101: 
 85101:   nsINode* container = NODE_FROM(aContainer, aDocument);
 85101:   if (container->IsSelectionDescendant() && IsInSelection()) {
 85101:     nsINode* child = aFirstNewContent;
 85101:     while (child) {
 85101:       if (!child->IsDescendantOfCommonAncestorForRangeInSelection()) {
 85101:         MarkDescendants(child);
 85101:         child->SetDescendantOfCommonAncestorForRangeInSelection();
 85101:       }
 85101:       child = child->GetNextSibling();
 85101:     }
 78794:   }
123668: 
123668:   if (mStartOffsetWasIncremented || mEndOffsetWasIncremented) {
123668:     MOZ_ASSERT(mAssertNextInsertOrAppendIndex == aNewIndexInContainer);
123668:     MOZ_ASSERT(mAssertNextInsertOrAppendNode == aFirstNewContent);
123668:     MOZ_ASSERT(aFirstNewContent->IsNodeOfType(nsINode::eTEXT));
123668:     mStartOffsetWasIncremented = mEndOffsetWasIncremented = false;
123668: #ifdef DEBUG
123668:     mAssertNextInsertOrAppendIndex = -1;
123668:     mAssertNextInsertOrAppendNode = nullptr;
123668: #endif
123668:   }
 78794: }
 76359: 
     1: void
     1: nsRange::ContentInserted(nsIDocument* aDocument,
     1:                          nsIContent* aContainer,
     1:                          nsIContent* aChild,
108991:                          int32_t aIndexInContainer)
     1: {
     1:   NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
     1: 
     1:   nsINode* container = NODE_FROM(aContainer, aDocument);
     1: 
     1:   // Adjust position if a sibling was inserted.
123668:   if (container == mStartParent && aIndexInContainer < mStartOffset &&
123668:       !mStartOffsetWasIncremented) {
     1:     ++mStartOffset;
     1:   }
123668:   if (container == mEndParent && aIndexInContainer < mEndOffset &&
123668:       !mEndOffsetWasIncremented) {
     1:     ++mEndOffset;
     1:   }
 85101:   if (container->IsSelectionDescendant() &&
 85101:       !aChild->IsDescendantOfCommonAncestorForRangeInSelection()) {
 85101:     MarkDescendants(aChild);
 85101:     aChild->SetDescendantOfCommonAncestorForRangeInSelection();
 85101:   }
123668: 
123668:   if (mStartOffsetWasIncremented || mEndOffsetWasIncremented) {
123668:     MOZ_ASSERT(mAssertNextInsertOrAppendIndex == aIndexInContainer);
123668:     MOZ_ASSERT(mAssertNextInsertOrAppendNode == aChild);
123668:     MOZ_ASSERT(aChild->IsNodeOfType(nsINode::eTEXT));
123668:     mStartOffsetWasIncremented = mEndOffsetWasIncremented = false;
123668: #ifdef DEBUG
123668:     mAssertNextInsertOrAppendIndex = -1;
123668:     mAssertNextInsertOrAppendNode = nullptr;
123668: #endif
123668:   }
     1: }
     1: 
     1: void
     1: nsRange::ContentRemoved(nsIDocument* aDocument,
     1:                         nsIContent* aContainer,
     1:                         nsIContent* aChild,
108991:                         int32_t aIndexInContainer,
 48038:                         nsIContent* aPreviousSibling)
     1: {
     1:   NS_ASSERTION(mIsPositioned, "shouldn't be notified if not positioned");
123668:   MOZ_ASSERT(!mStartOffsetWasIncremented && !mEndOffsetWasIncremented &&
123668:              mAssertNextInsertOrAppendIndex == -1,
123668:              "splitText failed to notify insert/append?");
     1: 
     1:   nsINode* container = NODE_FROM(aContainer, aDocument);
 85101:   bool gravitateStart = false;
 85101:   bool gravitateEnd = false;
     1: 
     1:   // Adjust position if a sibling was removed...
 30712:   if (container == mStartParent) {
 30712:     if (aIndexInContainer < mStartOffset) {
     1:       --mStartOffset;
     1:     }
 30712:   }
     1:   // ...or gravitate if an ancestor was removed.
     1:   else if (nsContentUtils::ContentIsDescendantOf(mStartParent, aChild)) {
 85101:     gravitateStart = true;
     1:   }
     1: 
     1:   // Do same thing for end boundry.
 30712:   if (container == mEndParent) {
 30712:     if (aIndexInContainer < mEndOffset) {
     1:       --mEndOffset;
     1:     }
 30712:   }
     1:   else if (nsContentUtils::ContentIsDescendantOf(mEndParent, aChild)) {
 85101:     gravitateEnd = true;
 85101:   }
 85101: 
 85101:   if (gravitateStart || gravitateEnd) {
 85101:     DoSetRange(gravitateStart ? container : mStartParent.get(),
 85101:                gravitateStart ? aIndexInContainer : mStartOffset,
 85101:                gravitateEnd ? container : mEndParent.get(),
 85101:                gravitateEnd ? aIndexInContainer : mEndOffset,
 85101:                mRoot);
 85101:   }
 85101:   if (container->IsSelectionDescendant() &&
 85101:       aChild->IsDescendantOfCommonAncestorForRangeInSelection()) {
 85101:     aChild->ClearDescendantOfCommonAncestorForRangeInSelection();
 85101:     UnmarkDescendants(aChild);
     1:   }
     1: }
     1: 
     1: void
 12178: nsRange::ParentChainChanged(nsIContent *aContent)
 12178: {
123668:   MOZ_ASSERT(!mStartOffsetWasIncremented && !mEndOffsetWasIncremented &&
123668:              mAssertNextInsertOrAppendIndex == -1,
123668:              "splitText failed to notify insert/append?");
 12178:   NS_ASSERTION(mRoot == aContent, "Wrong ParentChainChanged notification?");
 13002:   nsINode* newRoot = IsValidBoundary(mStartParent);
 13002:   NS_ASSERTION(newRoot, "No valid boundary or root found!");
 13002:   NS_ASSERTION(newRoot == IsValidBoundary(mEndParent),
 13002:                "Start parent and end parent give different root!");
 48008:   // This is safe without holding a strong ref to self as long as the change
 48008:   // of mRoot is the last thing in DoSetRange.
 12178:   DoSetRange(mStartParent, mStartOffset, mEndParent, mEndOffset, newRoot);
 12178: }
 12178: 
 86938: /******************************************************
 86938:  * Utilities for comparing points: API from nsIDOMRange
 86938:  ******************************************************/
     1: NS_IMETHODIMP
108991: nsRange::IsPointInRange(nsIDOMNode* aParent, int32_t aOffset, bool* aResult)
     1: {
108991:   int16_t compareResult = 0;
     1:   nsresult rv = ComparePoint(aParent, aOffset, &compareResult);
  8394:   // If the node isn't in the range's document, it clearly isn't in the range.
  8394:   if (rv == NS_ERROR_DOM_WRONG_DOCUMENT_ERR) {
 80486:     *aResult = false;
  8394:     return NS_OK;
  8394:   }
  8394: 
     1:   *aResult = compareResult == 0;
     1: 
     1:   return rv;
     1: }
     1:   
     1: // returns -1 if point is before range, 0 if point is in range,
     1: // 1 if point is after range.
     1: NS_IMETHODIMP
108991: nsRange::ComparePoint(nsIDOMNode* aParent, int32_t aOffset, int16_t* aResult)
     1: {
     1:   // our range is in a good state?
     1:   if (!mIsPositioned) 
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   nsCOMPtr<nsINode> parent = do_QueryInterface(aParent);
     1:   NS_ENSURE_TRUE(parent, NS_ERROR_DOM_HIERARCHY_REQUEST_ERR);
     1: 
     1:   if (!nsContentUtils::ContentIsDescendantOf(parent, mRoot)) {
     1:     return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
     1:   }
     1:   
 93676:   if (parent->NodeType() == nsIDOMNode::DOCUMENT_TYPE_NODE) {
 93676:     return NS_ERROR_DOM_INVALID_NODE_TYPE_ERR;
 93676:   }
 93676: 
108991:   if (aOffset < 0 || uint32_t(aOffset) > parent->Length()) {
 93676:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
 93676:   }
 93676:   
108991:   int32_t cmp;
     1:   if ((cmp = nsContentUtils::ComparePoints(parent, aOffset,
     1:                                            mStartParent, mStartOffset)) <= 0) {
     1:     
     1:     *aResult = cmp;
     1:   }
     1:   else if (nsContentUtils::ComparePoints(mEndParent, mEndOffset,
 20634:                                          parent, aOffset) == -1) {
     1:     *aResult = 1;
     1:   }
     1:   else {
     1:     *aResult = 0;
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
105524: NS_IMETHODIMP
105524: nsRange::IntersectsNode(nsIDOMNode* aNode, bool* aResult)
105524: {
105524:   *aResult = false;
105524: 
105524:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
105524:   // TODO: This should throw a TypeError.
105524:   NS_ENSURE_ARG(node);
105524: 
105524:   NS_ENSURE_TRUE(mIsPositioned, NS_ERROR_NOT_INITIALIZED);
105524: 
105524:   // Step 3.
119415:   nsINode* parent = node->GetParentNode();
105524:   if (!parent) {
105524:     // Steps 2 and 4. 
105524:     // |parent| is null, so |node|'s root is |node| itself.
105524:     *aResult = (GetRoot() == node);
105524:     return NS_OK;
105524:   }
105524: 
105524:   // Step 5.
108991:   int32_t nodeIndex = parent->IndexOf(node);
105524: 
105524:   // Steps 6-7.
105524:   // Note: if disconnected is true, ComparePoints returns 1.
105524:   bool disconnected = false;
105524:   *aResult = nsContentUtils::ComparePoints(mStartParent, mStartOffset,
105524:                                            parent, nodeIndex + 1,
105524:                                            &disconnected) < 0 &&
105524:              nsContentUtils::ComparePoints(parent, nodeIndex,
105524:                                            mEndParent, mEndOffset,
105524:                                            &disconnected) < 0;
105524: 
105524:   // Step 2.
105524:   if (disconnected) {
105524:     *aResult = false;
105524:   }
105524:   return NS_OK;
105524: }
105524: 
     1: /******************************************************
     1:  * Private helper routines
     1:  ******************************************************/
     1: 
     1: // It's important that all setting of the range start/end points 
     1: // go through this function, which will do all the right voodoo
     1: // for content notification of range ownership.  
     1: // Calling DoSetRange with either parent argument null will collapse
     1: // the range to have both endpoints point to the other node
     1: void
108991: nsRange::DoSetRange(nsINode* aStartN, int32_t aStartOffset,
108991:                     nsINode* aEndN, int32_t aEndOffset,
 85101:                     nsINode* aRoot, bool aNotInsertedYet)
     1: {
     1:   NS_PRECONDITION((aStartN && aEndN && aRoot) ||
     1:                   (!aStartN && !aEndN && !aRoot),
     1:                   "Set all or none");
 78794:   NS_PRECONDITION(!aRoot || aNotInsertedYet ||
     1:                   (nsContentUtils::ContentIsDescendantOf(aStartN, aRoot) &&
     1:                    nsContentUtils::ContentIsDescendantOf(aEndN, aRoot) &&
     1:                    aRoot == IsValidBoundary(aStartN) &&
     1:                    aRoot == IsValidBoundary(aEndN)),
     1:                   "Wrong root");
     1:   NS_PRECONDITION(!aRoot ||
     1:                   (aStartN->IsNodeOfType(nsINode::eCONTENT) &&
     1:                    aEndN->IsNodeOfType(nsINode::eCONTENT) &&
     1:                    aRoot ==
  3233:                     static_cast<nsIContent*>(aStartN)->GetBindingParent() &&
     1:                    aRoot ==
  3233:                     static_cast<nsIContent*>(aEndN)->GetBindingParent()) ||
119415:                   (!aRoot->GetParentNode() &&
     1:                    (aRoot->IsNodeOfType(nsINode::eDOCUMENT) ||
     1:                     aRoot->IsNodeOfType(nsINode::eATTRIBUTE) ||
 12178:                     aRoot->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT) ||
 12178:                      /*For backward compatibility*/
 12178:                     aRoot->IsNodeOfType(nsINode::eCONTENT))),
     1:                   "Bad root");
     1: 
     1:   if (mRoot != aRoot) {
     1:     if (mRoot) {
     1:       mRoot->RemoveMutationObserver(this);
     1:     }
     1:     if (aRoot) {
     1:       aRoot->AddMutationObserver(this);
     1:     }
     1:   }
 85101:   bool checkCommonAncestor = (mStartParent != aStartN || mEndParent != aEndN) &&
 85101:                              IsInSelection() && !aNotInsertedYet;
106838:   nsINode* oldCommonAncestor = checkCommonAncestor ? GetCommonAncestor() : nullptr;
     1:   mStartParent = aStartN;
     1:   mStartOffset = aStartOffset;
     1:   mEndParent = aEndN;
     1:   mEndOffset = aEndOffset;
     1:   mIsPositioned = !!mStartParent;
 85101:   if (checkCommonAncestor) {
 85101:     nsINode* newCommonAncestor = GetCommonAncestor();
 85101:     if (newCommonAncestor != oldCommonAncestor) {
 85101:       if (oldCommonAncestor) {
 85101:         UnregisterCommonAncestor(oldCommonAncestor);
 85101:       }
 85101:       if (newCommonAncestor) {
 85101:         RegisterCommonAncestor(newCommonAncestor);
 85101:       } else {
 96921:         NS_ASSERTION(!mIsPositioned, "unexpected disconnected nodes");
 85101:         mInSelection = false;
 85101:       }
 85101:     }
 85101:   }
 85101: 
 48008:   // This needs to be the last thing this function does.  See comment
 48008:   // in ParentChainChanged.
     1:   mRoot = aRoot;
     1: }
     1: 
108991: static int32_t
     1: IndexOf(nsIDOMNode* aChildNode)
     1: {
     1:   // convert node to nsIContent, so that we can find the child index
     1: 
     1:   nsCOMPtr<nsINode> child = do_QueryInterface(aChildNode);
     1:   if (!child) {
     1:     return -1;
     1:   }
     1: 
119415:   nsINode *parent = child->GetParentNode();
     1: 
     1:   // finally we get the index
     1:   return parent ? parent->IndexOf(child) : -1;
     1: }
     1: 
 86939: nsINode*
 26993: nsRange::GetCommonAncestor() const
     1: {
     1:   return mIsPositioned ?
     1:     nsContentUtils::GetCommonAncestor(mStartParent, mEndParent) :
106838:     nullptr;
     1: }
     1: 
 86939: void
     1: nsRange::Reset()
     1: {
106838:   DoSetRange(nullptr, 0, nullptr, 0, nullptr);
     1: }
     1: 
     1: /******************************************************
     1:  * public functionality
     1:  ******************************************************/
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::GetStartContainer(nsIDOMNode** aStartParent)
     1: {
     1:   if (!mIsPositioned)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   return CallQueryInterface(mStartParent, aStartParent);
     1: }
     1: 
 47862: NS_IMETHODIMP
108991: nsRange::GetStartOffset(int32_t* aStartOffset)
     1: {
     1:   if (!mIsPositioned)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   *aStartOffset = mStartOffset;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::GetEndContainer(nsIDOMNode** aEndParent)
     1: {
     1:   if (!mIsPositioned)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   return CallQueryInterface(mEndParent, aEndParent);
     1: }
     1: 
 47862: NS_IMETHODIMP
108991: nsRange::GetEndOffset(int32_t* aEndOffset)
     1: {
     1:   if (!mIsPositioned)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   *aEndOffset = mEndOffset;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 47862: NS_IMETHODIMP
 79445: nsRange::GetCollapsed(bool* aIsCollapsed)
     1: {
     1:   if (!mIsPositioned)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   *aIsCollapsed = Collapsed();
     1: 
     1:   return NS_OK;
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::GetCommonAncestorContainer(nsIDOMNode** aCommonParent)
     1: {
106838:   *aCommonParent = nullptr;
     1:   if (!mIsPositioned)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   nsINode* container = nsContentUtils::GetCommonAncestor(mStartParent, mEndParent);
     1:   if (container) {
     1:     return CallQueryInterface(container, aCommonParent);
     1:   }
     1: 
     1:   return NS_ERROR_NOT_INITIALIZED;
     1: }
     1: 
 86939: nsINode*
 86939: nsRange::IsValidBoundary(nsINode* aNode)
     1: {
     1:   if (!aNode) {
106838:     return nullptr;
     1:   }
     1: 
     1:   if (aNode->IsNodeOfType(nsINode::eCONTENT)) {
  3233:     nsIContent* content = static_cast<nsIContent*>(aNode);
     1:     if (content->Tag() == nsGkAtoms::documentTypeNodeName) {
106838:       return nullptr;
     1:     }
     1: 
  2561:     if (!mMaySpanAnonymousSubtrees) {
     1:       // If the node has a binding parent, that should be the root.
     1:       // XXXbz maybe only for native anonymous content?
     1:       nsINode* root = content->GetBindingParent();
     1:       if (root) {
     1:         return root;
     1:       }
     1:     }
  2561:   }
     1: 
     1:   // Elements etc. must be in document or in document fragment,
     1:   // text nodes in document, in document fragment or in attribute.
     1:   nsINode* root = aNode->GetCurrentDoc();
     1:   if (root) {
     1:     return root;
     1:   }
     1: 
     1:   root = aNode;
119415:   while ((aNode = aNode->GetParentNode())) {
     1:     root = aNode;
     1:   }
     1: 
     1:   NS_ASSERTION(!root->IsNodeOfType(nsINode::eDOCUMENT),
     1:                "GetCurrentDoc should have returned a doc");
     1: 
     1: #ifdef DEBUG_smaug
 12178:   NS_WARN_IF_FALSE(root->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT) ||
 12178:                    root->IsNodeOfType(nsINode::eATTRIBUTE),
 12178:                    "Creating a DOM Range using root which isn't in DOM!");
     1: #endif
     1: 
 12178:   // We allow this because of backward compatibility.
 12178:   return root;
     1: }
     1: 
 47862: NS_IMETHODIMP
108991: nsRange::SetStart(nsIDOMNode* aParent, int32_t aOffset)
     1: {
     1:   VALIDATE_ACCESS(aParent);
     1: 
     1:   nsCOMPtr<nsINode> parent = do_QueryInterface(aParent);
 86160:   AutoInvalidateSelection atEndOfBlock(this);
 26992:   return SetStart(parent, aOffset);
 26992: }
 26992: 
 47862: /* virtual */ nsresult
108991: nsRange::SetStart(nsINode* aParent, int32_t aOffset)
 26992: {
 26992:   nsINode* newRoot = IsValidBoundary(aParent);
 91491:   NS_ENSURE_TRUE(newRoot, NS_ERROR_DOM_INVALID_NODE_TYPE_ERR);
     1: 
108991:   if (aOffset < 0 || uint32_t(aOffset) > aParent->Length()) {
     1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
 94357:   }
     1: 
     1:   // Collapse if not positioned yet, if positioned in another doc or
     1:   // if the new start is after end.
     1:   if (!mIsPositioned || newRoot != mRoot ||
 26992:       nsContentUtils::ComparePoints(aParent, aOffset,
     1:                                     mEndParent, mEndOffset) == 1) {
 26992:     DoSetRange(aParent, aOffset, aParent, aOffset, newRoot);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
 26992:   DoSetRange(aParent, aOffset, mEndParent, mEndOffset, mRoot);
     1:   
     1:   return NS_OK;
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::SetStartBefore(nsIDOMNode* aSibling)
     1: {
     1:   VALIDATE_ACCESS(aSibling);
     1:   
     1:   nsCOMPtr<nsIDOMNode> parent;
     1:   nsresult rv = aSibling->GetParentNode(getter_AddRefs(parent));
     1:   if (NS_FAILED(rv) || !parent) {
 91491:     return NS_ERROR_DOM_INVALID_NODE_TYPE_ERR;
     1:   }
     1: 
     1:   return SetStart(parent, IndexOf(aSibling));
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::SetStartAfter(nsIDOMNode* aSibling)
     1: {
     1:   VALIDATE_ACCESS(aSibling);
     1: 
     1:   nsCOMPtr<nsIDOMNode> nParent;
     1:   nsresult res = aSibling->GetParentNode(getter_AddRefs(nParent));
     1:   if (NS_FAILED(res) || !nParent) {
 91491:     return NS_ERROR_DOM_INVALID_NODE_TYPE_ERR;
     1:   }
     1: 
     1:   return SetStart(nParent, IndexOf(aSibling) + 1);
     1: }
     1: 
 47862: NS_IMETHODIMP
108991: nsRange::SetEnd(nsIDOMNode* aParent, int32_t aOffset)
     1: {
     1:   VALIDATE_ACCESS(aParent);
     1: 
 86160:   AutoInvalidateSelection atEndOfBlock(this);
     1:   nsCOMPtr<nsINode> parent = do_QueryInterface(aParent);
 26992:   return SetEnd(parent, aOffset);
 26992: }
 26992: 
 26992: 
 47862: /* virtual */ nsresult
108991: nsRange::SetEnd(nsINode* aParent, int32_t aOffset)
 26992: {
 26992:   nsINode* newRoot = IsValidBoundary(aParent);
 91491:   NS_ENSURE_TRUE(newRoot, NS_ERROR_DOM_INVALID_NODE_TYPE_ERR);
     1: 
108991:   if (aOffset < 0 || uint32_t(aOffset) > aParent->Length()) {
     1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
     1:   }
     1: 
     1:   // Collapse if not positioned yet, if positioned in another doc or
     1:   // if the new end is before start.
     1:   if (!mIsPositioned || newRoot != mRoot ||
     1:       nsContentUtils::ComparePoints(mStartParent, mStartOffset,
 26992:                                     aParent, aOffset) == 1) {
 26992:     DoSetRange(aParent, aOffset, aParent, aOffset, newRoot);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
 26992:   DoSetRange(mStartParent, mStartOffset, aParent, aOffset, mRoot);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::SetEndBefore(nsIDOMNode* aSibling)
     1: {
     1:   VALIDATE_ACCESS(aSibling);
     1:   
     1:   nsCOMPtr<nsIDOMNode> nParent;
     1:   nsresult rv = aSibling->GetParentNode(getter_AddRefs(nParent));
     1:   if (NS_FAILED(rv) || !nParent) {
 91491:     return NS_ERROR_DOM_INVALID_NODE_TYPE_ERR;
     1:   }
     1: 
     1:   return SetEnd(nParent, IndexOf(aSibling));
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::SetEndAfter(nsIDOMNode* aSibling)
     1: {
     1:   VALIDATE_ACCESS(aSibling);
     1:   
     1:   nsCOMPtr<nsIDOMNode> nParent;
     1:   nsresult res = aSibling->GetParentNode(getter_AddRefs(nParent));
     1:   if (NS_FAILED(res) || !nParent) {
 91491:     return NS_ERROR_DOM_INVALID_NODE_TYPE_ERR;
     1:   }
     1: 
     1:   return SetEnd(nParent, IndexOf(aSibling) + 1);
     1: }
     1: 
 47862: NS_IMETHODIMP
 79445: nsRange::Collapse(bool aToStart)
     1: {
     1:   if (!mIsPositioned)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
 86160:   AutoInvalidateSelection atEndOfBlock(this);
     1:   if (aToStart)
     1:     DoSetRange(mStartParent, mStartOffset, mStartParent, mStartOffset, mRoot);
     1:   else
     1:     DoSetRange(mEndParent, mEndOffset, mEndParent, mEndOffset, mRoot);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::SelectNode(nsIDOMNode* aN)
     1: {
     1:   VALIDATE_ACCESS(aN);
     1:   
     1:   nsCOMPtr<nsINode> node = do_QueryInterface(aN);
 91491:   NS_ENSURE_TRUE(node, NS_ERROR_DOM_INVALID_NODE_TYPE_ERR);
     1: 
119415:   nsINode* parent = node->GetParentNode();
     1:   nsINode* newRoot = IsValidBoundary(parent);
 91491:   NS_ENSURE_TRUE(newRoot, NS_ERROR_DOM_INVALID_NODE_TYPE_ERR);
     1: 
108991:   int32_t index = parent->IndexOf(node);
     1:   if (index < 0) {
 91491:     return NS_ERROR_DOM_INVALID_NODE_TYPE_ERR;
     1:   }
     1: 
 86160:   AutoInvalidateSelection atEndOfBlock(this);
     1:   DoSetRange(parent, index, parent, index + 1, newRoot);
     1:   
     1:   return NS_OK;
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::SelectNodeContents(nsIDOMNode* aN)
     1: {
     1:   VALIDATE_ACCESS(aN);
     1: 
     1:   nsCOMPtr<nsINode> node = do_QueryInterface(aN);
     1:   nsINode* newRoot = IsValidBoundary(node);
 91491:   NS_ENSURE_TRUE(newRoot, NS_ERROR_DOM_INVALID_NODE_TYPE_ERR);
     1:   
 86160:   AutoInvalidateSelection atEndOfBlock(this);
 94357:   DoSetRange(node, 0, node, node->Length(), newRoot);
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: // The Subtree Content Iterator only returns subtrees that are
     1: // completely within a given range. It doesn't return a CharacterData
 20321: // node that contains either the start or end point of the range.,
 20321: // nor does it return element nodes when nothing in the element is selected.
     1: // We need an iterator that will also include these start/end points
     1: // so that our methods/algorithms aren't cluttered with special
     1: // case code that tries to include these points while iterating.
     1: //
     1: // The RangeSubtreeIterator class mimics the nsIContentIterator
     1: // methods we need, so should the Content Iterator support the
     1: // start/end points in the future, we can switchover relatively
     1: // easy.
     1: 
 15594: class NS_STACK_CLASS RangeSubtreeIterator
     1: {
     1: private:
     1: 
     1:   enum RangeSubtreeIterState { eDone=0,
 20321:                                eUseStart,
     1:                                eUseIterator,
 20321:                                eUseEnd };
     1: 
     1:   nsCOMPtr<nsIContentIterator>  mIter;
     1:   RangeSubtreeIterState         mIterState;
     1: 
 20321:   nsCOMPtr<nsIDOMNode> mStart;
 20321:   nsCOMPtr<nsIDOMNode> mEnd;
     1: 
     1: public:
     1: 
     1:   RangeSubtreeIterator()
     1:     : mIterState(eDone)
     1:   {
     1:   }
     1:   ~RangeSubtreeIterator()
     1:   {
     1:   }
     1: 
     1:   nsresult Init(nsIDOMRange *aRange);
     1:   already_AddRefed<nsIDOMNode> GetCurrentNode();
     1:   void First();
     1:   void Last();
     1:   void Next();
     1:   void Prev();
     1: 
 79445:   bool IsDone()
     1:   {
     1:     return mIterState == eDone;
     1:   }
     1: };
     1: 
     1: nsresult
     1: RangeSubtreeIterator::Init(nsIDOMRange *aRange)
     1: {
     1:   mIterState = eDone;
 79445:   bool collapsed;
 20321:   aRange->GetCollapsed(&collapsed);
 20321:   if (collapsed) {
 20321:     return NS_OK;
 20321:   }
     1: 
     1:   nsCOMPtr<nsIDOMNode> node;
     1: 
     1:   // Grab the start point of the range and QI it to
     1:   // a CharacterData pointer. If it is CharacterData store
     1:   // a pointer to the node.
     1: 
     1:   nsresult res = aRange->GetStartContainer(getter_AddRefs(node));
     1:   if (!node) return NS_ERROR_FAILURE;
     1: 
 20321:   nsCOMPtr<nsIDOMCharacterData> startData = do_QueryInterface(node);
 20321:   if (startData) {
 20321:     mStart = node;
 20321:   } else {
108991:     int32_t startIndex;
 20321:     aRange->GetStartOffset(&startIndex);
 20321:     nsCOMPtr<nsINode> iNode = do_QueryInterface(node);
 41636:     if (iNode->IsElement() && 
108991:         int32_t(iNode->AsElement()->GetChildCount()) == startIndex) {
 20321:       mStart = node;
 20321:     }
 20321:   }
     1: 
     1:   // Grab the end point of the range and QI it to
     1:   // a CharacterData pointer. If it is CharacterData store
     1:   // a pointer to the node.
     1: 
     1:   res = aRange->GetEndContainer(getter_AddRefs(node));
     1:   if (!node) return NS_ERROR_FAILURE;
     1: 
 20321:   nsCOMPtr<nsIDOMCharacterData> endData = do_QueryInterface(node);
 20321:   if (endData) {
 20321:     mEnd = node;
 20321:   } else {
108991:     int32_t endIndex;
 20321:     aRange->GetEndOffset(&endIndex);
 20321:     nsCOMPtr<nsINode> iNode = do_QueryInterface(node);
 41636:     if (iNode->IsElement() && endIndex == 0) {
 20321:       mEnd = node;
 20321:     }
 20321:   }
     1: 
 20321:   if (mStart && mStart == mEnd)
     1:   {
     1:     // The range starts and stops in the same CharacterData
     1:     // node. Null out the end pointer so we only visit the
     1:     // node once!
     1: 
106838:     mEnd = nullptr;
     1:   }
     1:   else
     1:   {
     1:     // Now create a Content Subtree Iterator to be used
     1:     // for the subtrees between the end points!
     1: 
101616:     mIter = NS_NewContentSubtreeIterator();
     1: 
     1:     res = mIter->Init(aRange);
     1:     if (NS_FAILED(res)) return res;
     1: 
     1:     if (mIter->IsDone())
     1:     {
     1:       // The subtree iterator thinks there's nothing
     1:       // to iterate over, so just free it up so we
     1:       // don't accidentally call into it.
     1: 
106838:       mIter = nullptr;
     1:     }
     1:   }
     1: 
     1:   // Initialize the iterator by calling First().
     1:   // Note that we are ignoring the return value on purpose!
     1: 
     1:   First();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: already_AddRefed<nsIDOMNode>
     1: RangeSubtreeIterator::GetCurrentNode()
     1: {
106838:   nsIDOMNode *node = nullptr;
     1: 
 20321:   if (mIterState == eUseStart && mStart) {
 20321:     NS_ADDREF(node = mStart);
 20321:   } else if (mIterState == eUseEnd && mEnd)
 20321:     NS_ADDREF(node = mEnd);
     1:   else if (mIterState == eUseIterator && mIter)
     1:   {
 20503:     nsINode* n = mIter->GetCurrentNode();
     1: 
 20503:     if (n) {
 20503:       CallQueryInterface(n, &node);
     1:     }
     1:   }
     1: 
     1:   return node;
     1: }
     1: 
     1: void
     1: RangeSubtreeIterator::First()
     1: {
 20321:   if (mStart)
 20321:     mIterState = eUseStart;
     1:   else if (mIter)
     1:   {
     1:     mIter->First();
     1: 
     1:     mIterState = eUseIterator;
     1:   }
 20321:   else if (mEnd)
 20321:     mIterState = eUseEnd;
     1:   else
     1:     mIterState = eDone;
     1: }
     1: 
     1: void
     1: RangeSubtreeIterator::Last()
     1: {
 20321:   if (mEnd)
 20321:     mIterState = eUseEnd;
     1:   else if (mIter)
     1:   {
     1:     mIter->Last();
     1: 
     1:     mIterState = eUseIterator;
     1:   }
 20321:   else if (mStart)
 20321:     mIterState = eUseStart;
     1:   else
     1:     mIterState = eDone;
     1: }
     1: 
     1: void
     1: RangeSubtreeIterator::Next()
     1: {
 20321:   if (mIterState == eUseStart)
     1:   {
     1:     if (mIter)
     1:     {
     1:       mIter->First();
     1: 
     1:       mIterState = eUseIterator;
     1:     }
 20321:     else if (mEnd)
 20321:       mIterState = eUseEnd;
     1:     else
     1:       mIterState = eDone;
     1:   }
     1:   else if (mIterState == eUseIterator)
     1:   {
     1:     mIter->Next();
     1: 
     1:     if (mIter->IsDone())
     1:     {
 20321:       if (mEnd)
 20321:         mIterState = eUseEnd;
     1:       else
     1:         mIterState = eDone;
     1:     }
     1:   }
     1:   else
     1:     mIterState = eDone;
     1: }
     1: 
     1: void
     1: RangeSubtreeIterator::Prev()
     1: {
 20321:   if (mIterState == eUseEnd)
     1:   {
     1:     if (mIter)
     1:     {
     1:       mIter->Last();
     1: 
     1:       mIterState = eUseIterator;
     1:     }
 20321:     else if (mStart)
 20321:       mIterState = eUseStart;
     1:     else
     1:       mIterState = eDone;
     1:   }
     1:   else if (mIterState == eUseIterator)
     1:   {
     1:     mIter->Prev();
     1: 
     1:     if (mIter->IsDone())
     1:     {
 20321:       if (mStart)
 20321:         mIterState = eUseStart;
     1:       else
     1:         mIterState = eDone;
     1:     }
     1:   }
     1:   else
     1:     mIterState = eDone;
     1: }
     1: 
     1: 
     1: // CollapseRangeAfterDelete() is a utility method that is used by
     1: // DeleteContents() and ExtractContents() to collapse the range
     1: // in the correct place, under the range's root container (the
     1: // range end points common container) as outlined by the Range spec:
     1: //
     1: // http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/ranges.html
     1: // The assumption made by this method is that the delete or extract
     1: // has been done already, and left the range in a state where there is
     1: // no content between the 2 end points.
     1: 
     1: static nsresult
     1: CollapseRangeAfterDelete(nsIDOMRange *aRange)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aRange);
     1: 
     1:   // Check if range gravity took care of collapsing the range for us!
     1: 
 79445:   bool isCollapsed = false;
     1:   nsresult res = aRange->GetCollapsed(&isCollapsed);
     1:   if (NS_FAILED(res)) return res;
     1: 
     1:   if (isCollapsed)
     1:   {
     1:     // aRange is collapsed so there's nothing for us to do.
     1:     //
     1:     // There are 2 possible scenarios here:
     1:     //
     1:     // 1. aRange could've been collapsed prior to the delete/extract,
     1:     //    which would've resulted in nothing being removed, so aRange
     1:     //    is already where it should be.
     1:     //
     1:     // 2. Prior to the delete/extract, aRange's start and end were in
     1:     //    the same container which would mean everything between them
     1:     //    was removed, causing range gravity to collapse the range.
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   // aRange isn't collapsed so figure out the appropriate place to collapse!
     1:   // First get both end points and their common ancestor.
     1: 
     1:   nsCOMPtr<nsIDOMNode> commonAncestor;
     1:   res = aRange->GetCommonAncestorContainer(getter_AddRefs(commonAncestor));
     1:   if(NS_FAILED(res)) return res;
     1: 
     1:   nsCOMPtr<nsIDOMNode> startContainer, endContainer;
     1: 
     1:   res = aRange->GetStartContainer(getter_AddRefs(startContainer));
     1:   if (NS_FAILED(res)) return res;
     1: 
     1:   res = aRange->GetEndContainer(getter_AddRefs(endContainer));
     1:   if (NS_FAILED(res)) return res;
     1: 
     1:   // Collapse to one of the end points if they are already in the
     1:   // commonAncestor. This should work ok since this method is called
     1:   // immediately after a delete or extract that leaves no content
     1:   // between the 2 end points!
     1: 
     1:   if (startContainer == commonAncestor)
 80486:     return aRange->Collapse(true);
     1:   if (endContainer == commonAncestor)
 80486:     return aRange->Collapse(false);
     1: 
     1:   // End points are at differing levels. We want to collapse to the
     1:   // point that is between the 2 subtrees that contain each point,
     1:   // under the common ancestor.
     1: 
     1:   nsCOMPtr<nsIDOMNode> nodeToSelect(startContainer), parent;
     1: 
     1:   while (nodeToSelect)
     1:   {
     1:     nsresult res = nodeToSelect->GetParentNode(getter_AddRefs(parent));
     1:     if (NS_FAILED(res)) return res;
     1: 
     1:     if (parent == commonAncestor)
     1:       break; // We found the nodeToSelect!
     1: 
     1:     nodeToSelect = parent;
     1:   }
     1: 
     1:   if (!nodeToSelect)
     1:     return NS_ERROR_FAILURE; // This should never happen!
     1: 
     1:   res = aRange->SelectNode(nodeToSelect);
     1:   if (NS_FAILED(res)) return res;
     1: 
 80486:   return aRange->Collapse(false);
     1: }
     1: 
 16205: /**
 29803:  * Split a data node into two parts.
 16205:  *
 29803:  * @param aStartNode          The original node we are trying to split.
 29803:  * @param aStartIndex         The index at which to split.
 29803:  * @param aEndNode            The second node.
 80486:  * @param aCloneAfterOriginal Set false if the original node should be the
 16205:  *                            latter one after split.
 16205:  */
 16205: static nsresult SplitDataNode(nsIDOMCharacterData* aStartNode,
108991:                               uint32_t aStartIndex,
 16205:                               nsIDOMCharacterData** aEndNode,
 79445:                               bool aCloneAfterOriginal = true)
 16205: {
 16205:   nsresult rv;
 16205:   nsCOMPtr<nsINode> node = do_QueryInterface(aStartNode);
 16205:   NS_ENSURE_STATE(node && node->IsNodeOfType(nsINode::eDATA_NODE));
 16205:   nsGenericDOMDataNode* dataNode = static_cast<nsGenericDOMDataNode*>(node.get());
 16205: 
 16205:   nsCOMPtr<nsIContent> newData;
 16205:   rv = dataNode->SplitData(aStartIndex, getter_AddRefs(newData),
 16205:                            aCloneAfterOriginal);
 16205:   NS_ENSURE_SUCCESS(rv, rv);
 29803:   return CallQueryInterface(newData, aEndNode);
 16205: }
 16205: 
 47862: NS_IMETHODIMP
 47862: PrependChild(nsIDOMNode* aParent, nsIDOMNode* aChild)
 20321: {
 20321:   nsCOMPtr<nsIDOMNode> first, tmpNode;
 20321:   aParent->GetFirstChild(getter_AddRefs(first));
 20321:   return aParent->InsertBefore(aChild, first, getter_AddRefs(tmpNode));
 20321: }
 20321: 
103795: // Helper function for CutContents, making sure that the current node wasn't
103795: // removed by mutation events (bug 766426)
103795: static bool
103795: ValidateCurrentNode(nsRange* aRange, RangeSubtreeIterator& aIter)
103795: {
103795:   bool before, after;
103795:   nsCOMPtr<nsIDOMNode> domNode = aIter.GetCurrentNode();
103993:   if (!domNode) {
103993:     // We don't have to worry that the node was removed if it doesn't exist,
103993:     // e.g., the iterator is done.
103993:     return true;
103993:   }
103795:   nsCOMPtr<nsINode> node = do_QueryInterface(domNode);
103795:   MOZ_ASSERT(node);
103795: 
103795:   nsresult res = nsRange::CompareNodeToRange(node, aRange, &before, &after);
103795: 
103795:   return NS_SUCCEEDED(res) && !before && !after;
103795: }
103795: 
 16205: nsresult nsRange::CutContents(nsIDOMDocumentFragment** aFragment)
     1: { 
 19010:   if (aFragment) {
106838:     *aFragment = nullptr;
 19010:   }
 19010: 
 16205:   nsresult rv;
 16205: 
 80527:   nsCOMPtr<nsIDocument> doc = mStartParent->OwnerDoc();
 16205: 
 20321:   nsCOMPtr<nsIDOMNode> commonAncestor;
 20321:   rv = GetCommonAncestorContainer(getter_AddRefs(commonAncestor));
 20321:   NS_ENSURE_SUCCESS(rv, rv);
 20321: 
 16205:   // If aFragment isn't null, create a temporary fragment to hold our return.
 16205:   nsCOMPtr<nsIDOMDocumentFragment> retval;
 16205:   if (aFragment) {
 16205:     rv = NS_NewDocumentFragment(getter_AddRefs(retval),
 16205:                                 doc->NodeInfoManager());
 16205:     NS_ENSURE_SUCCESS(rv, rv);
 16205:   }
 20321:   nsCOMPtr<nsIDOMNode> commonCloneAncestor(do_QueryInterface(retval));
 16205: 
    62:   // Batch possible DOMSubtreeModified events.
106838:   mozAutoSubtreeModified subtree(mRoot ? mRoot->OwnerDoc(): nullptr, nullptr);
    62: 
     1:   // Save the range end points locally to avoid interference
     1:   // of Range gravity during our edits!
     1: 
     1:   nsCOMPtr<nsIDOMNode> startContainer = do_QueryInterface(mStartParent);
108991:   int32_t              startOffset = mStartOffset;
     1:   nsCOMPtr<nsIDOMNode> endContainer = do_QueryInterface(mEndParent);
108991:   int32_t              endOffset = mEndOffset;
     1: 
 94562:   if (retval) {
 94562:     // For extractContents(), abort early if there's a doctype (bug 719533).
 94562:     // This can happen only if the common ancestor is a document, in which case
 94562:     // we just need to find its doctype child and check if that's in the range.
 94562:     nsCOMPtr<nsIDOMDocument> commonAncestorDocument(do_QueryInterface(commonAncestor));
 94562:     if (commonAncestorDocument) {
 94562:       nsCOMPtr<nsIDOMDocumentType> doctype;
 94562:       rv = commonAncestorDocument->GetDoctype(getter_AddRefs(doctype));
 94562:       NS_ENSURE_SUCCESS(rv, rv);
 94562: 
 94562:       if (doctype &&
 94562:           nsContentUtils::ComparePoints(startContainer, startOffset,
 94562:                                         doctype.get(), 0) < 0 &&
 94562:           nsContentUtils::ComparePoints(doctype.get(), 0,
 94562:                                         endContainer, endOffset) < 0) {
 94562:         return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
 94562:       }
 94562:     }
 94562:   }
 94562: 
     1:   // Create and initialize a subtree iterator that will give
     1:   // us all the subtrees within the range.
     1: 
     1:   RangeSubtreeIterator iter;
     1: 
 16205:   rv = iter.Init(this);
 16205:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   if (iter.IsDone())
     1:   {
     1:     // There's nothing for us to delete.
 19010:     rv = CollapseRangeAfterDelete(this);
 19010:     if (NS_SUCCEEDED(rv) && aFragment) {
 19010:       NS_ADDREF(*aFragment = retval);
 19010:     }
 19010:     return rv;
     1:   }
     1: 
     1:   // We delete backwards to avoid iterator problems!
     1: 
     1:   iter.Last();
     1: 
 79445:   bool handled = false;
     1: 
     1:   // With the exception of text nodes that contain one of the range
     1:   // end points, the subtree iterator should only give us back subtrees
     1:   // that are completely contained between the range's end points.
     1: 
     1:   while (!iter.IsDone())
     1:   {
 20321:     nsCOMPtr<nsIDOMNode> nodeToResult;
     1:     nsCOMPtr<nsIDOMNode> node(iter.GetCurrentNode());
     1: 
     1:     // Before we delete anything, advance the iterator to the
     1:     // next subtree.
     1: 
     1:     iter.Prev();
     1: 
 80486:     handled = false;
     1: 
     1:     // If it's CharacterData, make sure we might need to delete
     1:     // part of the data, instead of removing the whole node.
     1:     //
     1:     // XXX_kin: We need to also handle ProcessingInstruction
     1:     // XXX_kin: according to the spec.
     1: 
     1:     nsCOMPtr<nsIDOMCharacterData> charData(do_QueryInterface(node));
     1: 
     1:     if (charData)
     1:     {
108991:       uint32_t dataLength = 0;
     1: 
     1:       if (node == startContainer)
     1:       {
     1:         if (node == endContainer)
     1:         {
     1:           // This range is completely contained within a single text node.
 16205:           // Delete or extract the data between startOffset and endOffset.
     1: 
     1:           if (endOffset > startOffset)
     1:           {
 29803:             if (retval) {
 29803:               nsAutoString cutValue;
 29803:               rv = charData->SubstringData(startOffset, endOffset - startOffset,
 29803:                                            cutValue);
 16205:               NS_ENSURE_SUCCESS(rv, rv);
 29803:               nsCOMPtr<nsIDOMNode> clone;
 90796:               rv = charData->CloneNode(false, 1, getter_AddRefs(clone));
 29803:               NS_ENSURE_SUCCESS(rv, rv);
 29803:               clone->SetNodeValue(cutValue);
 29803:               nodeToResult = clone;
 29803:             }
 29803: 
103795:             nsMutationGuard guard;
 29803:             rv = charData->DeleteData(startOffset, endOffset - startOffset);
 29803:             NS_ENSURE_SUCCESS(rv, rv);
103795:             NS_ENSURE_STATE(!guard.Mutated(0) ||
103795:                             ValidateCurrentNode(this, iter));
     1:           }
     1: 
 80486:           handled = true;
     1:         }
     1:         else
     1:         {
 16205:           // Delete or extract everything after startOffset.
     1: 
 16205:           rv = charData->GetLength(&dataLength);
 16205:           NS_ENSURE_SUCCESS(rv, rv);
     1: 
108991:           if (dataLength >= (uint32_t)startOffset)
     1:           {
103795:             nsMutationGuard guard;
 16205:             nsCOMPtr<nsIDOMCharacterData> cutNode;
 29803:             rv = SplitDataNode(charData, startOffset, getter_AddRefs(cutNode));
 16205:             NS_ENSURE_SUCCESS(rv, rv);
103795:             NS_ENSURE_STATE(!guard.Mutated(1) ||
103795:                             ValidateCurrentNode(this, iter));
 20321:             nodeToResult = cutNode;
     1:           }
     1: 
 80486:           handled = true;
     1:         }
     1:       }
     1:       else if (node == endContainer)
     1:       {
 16205:         // Delete or extract everything before endOffset.
     1: 
 22768:         if (endOffset >= 0)
     1:         {
103795:           nsMutationGuard guard;
 16205:           nsCOMPtr<nsIDOMCharacterData> cutNode;
 16205:           /* The Range spec clearly states clones get cut and original nodes
 80486:              remain behind, so use false as the last parameter.
 16205:           */
 29803:           rv = SplitDataNode(charData, endOffset, getter_AddRefs(cutNode),
 80486:                              false);
 16205:           NS_ENSURE_SUCCESS(rv, rv);
103795:           NS_ENSURE_STATE(!guard.Mutated(1) ||
103795:                           ValidateCurrentNode(this, iter));
 20321:           nodeToResult = cutNode;
     1:         }
     1: 
 80486:         handled = true;
     1:       }       
     1:     }
     1: 
 20321:     if (!handled && (node == endContainer || node == startContainer))
 20321:     {
 20321:       nsCOMPtr<nsINode> iNode = do_QueryInterface(node);
 41636:       if (iNode && iNode->IsElement() &&
 20321:           ((node == endContainer && endOffset == 0) ||
 20321:            (node == startContainer &&
108991:             int32_t(iNode->AsElement()->GetChildCount()) == startOffset)))
 20321:       {
 20321:         if (retval) {
 20321:           nsCOMPtr<nsIDOMNode> clone;
 90796:           rv = node->CloneNode(false, 1, getter_AddRefs(clone));
 20321:           NS_ENSURE_SUCCESS(rv, rv);
 20321:           nodeToResult = clone;
 20321:         }
 80486:         handled = true;
 20321:       }
 20321:     }
 20321: 
     1:     if (!handled)
     1:     {
     1:       // node was not handled above, so it must be completely contained
     1:       // within the range. Just remove it from the tree!
 20321:       nodeToResult = node;
 20321:     }
 20321: 
108991:     uint32_t parentCount = 0;
 20321:     nsCOMPtr<nsIDOMNode> tmpNode;
 20321:     // Set the result to document fragment if we have 'retval'.
 16205:     if (retval) {
 20321:       nsCOMPtr<nsIDOMNode> oldCommonAncestor = commonAncestor;
 20321:       if (!iter.IsDone()) {
 20321:         // Setup the parameters for the next iteration of the loop.
 20321:         nsCOMPtr<nsIDOMNode> prevNode(iter.GetCurrentNode());
 20321:         NS_ENSURE_STATE(prevNode);
 20321: 
 20321:         // Get node's and prevNode's common parent. Do this before moving
 20321:         // nodes from original DOM to result fragment.
 20321:         nsContentUtils::GetCommonAncestor(node, prevNode,
 20321:                                           getter_AddRefs(commonAncestor));
 20321:         NS_ENSURE_STATE(commonAncestor);
 20321: 
 20321:         nsCOMPtr<nsIDOMNode> parentCounterNode = node;
 20321:         while (parentCounterNode && parentCounterNode != commonAncestor)
 20321:         {
 20321:           ++parentCount;
 20321:           tmpNode = parentCounterNode;
 20321:           tmpNode->GetParentNode(getter_AddRefs(parentCounterNode));
 20321:           NS_ENSURE_STATE(parentCounterNode);
     1:         }
     1:       }
 20321: 
 20321:       // Clone the parent hierarchy between commonAncestor and node.
 20321:       nsCOMPtr<nsIDOMNode> closestAncestor, farthestAncestor;
 20321:       rv = CloneParentsBetween(oldCommonAncestor, node,
 20321:                                getter_AddRefs(closestAncestor),
 20321:                                getter_AddRefs(farthestAncestor));
 20321:       NS_ENSURE_SUCCESS(rv, rv);
 20321: 
 20321:       if (farthestAncestor)
 20321:       {
 20321:         rv = PrependChild(commonCloneAncestor, farthestAncestor);
 20321:         NS_ENSURE_SUCCESS(rv, rv);
 20321:       }
 20321: 
103795:       nsMutationGuard guard;
103795:       nsCOMPtr<nsIDOMNode> parent;
103795:       nodeToResult->GetParentNode(getter_AddRefs(parent));
 20321:       rv = closestAncestor ? PrependChild(closestAncestor, nodeToResult)
 20321:                            : PrependChild(commonCloneAncestor, nodeToResult);
 20321:       NS_ENSURE_SUCCESS(rv, rv);
103795:       NS_ENSURE_STATE(!guard.Mutated(parent ? 2 : 1) ||
103795:                       ValidateCurrentNode(this, iter));
 20321:     } else if (nodeToResult) {
103795:       nsMutationGuard guard;
119415:       nsCOMPtr<nsINode> node = do_QueryInterface(nodeToResult);
119415:       nsINode* parent = node->GetParentNode();
119415:       if (parent) {
119415:         mozilla::ErrorResult error;
119415:         parent->RemoveChild(*node, error);
119415:         NS_ENSURE_FALSE(error.Failed(), error.ErrorCode());
119415:       }
103795:       NS_ENSURE_STATE(!guard.Mutated(1) ||
103795:                       ValidateCurrentNode(this, iter));
 20321:     }
 20321: 
 20321:     if (!iter.IsDone() && retval) {
 20321:       // Find the equivalent of commonAncestor in the cloned tree.
 20321:       nsCOMPtr<nsIDOMNode> newCloneAncestor = nodeToResult;
108991:       for (uint32_t i = parentCount; i; --i)
 20321:       {
 20321:         tmpNode = newCloneAncestor;
 20321:         tmpNode->GetParentNode(getter_AddRefs(newCloneAncestor));
 20321:         NS_ENSURE_STATE(newCloneAncestor);
 20321:       }
 20321:       commonCloneAncestor = newCloneAncestor;
 20321:     }
     1:   }
     1: 
 19010:   rv = CollapseRangeAfterDelete(this);
 19010:   if (NS_SUCCEEDED(rv) && aFragment) {
 16205:     NS_ADDREF(*aFragment = retval);
 16205:   }
 19010:   return rv;
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::DeleteContents()
 16205: {
106838:   return CutContents(nullptr);
 16205: }
 16205: 
 47862: NS_IMETHODIMP
 47862: nsRange::ExtractContents(nsIDOMDocumentFragment** aReturn)
 16205: {
 16205:   NS_ENSURE_ARG_POINTER(aReturn);
 16205:   return CutContents(aReturn);
 16205: }
 16205: 
     1: NS_IMETHODIMP
108991: nsRange::CompareBoundaryPoints(uint16_t aHow, nsIDOMRange* aOtherRange,
108991:                                int16_t* aCmpRet)
     1: {
 86939:   nsRange* otherRange = static_cast<nsRange*>(aOtherRange);
     1:   NS_ENSURE_TRUE(otherRange, NS_ERROR_NULL_POINTER);
     1: 
     1:   if (!mIsPositioned || !otherRange->IsPositioned())
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   nsINode *ourNode, *otherNode;
108991:   int32_t ourOffset, otherOffset;
     1: 
     1:   switch (aHow) {
     1:     case nsIDOMRange::START_TO_START:
     1:       ourNode = mStartParent;
     1:       ourOffset = mStartOffset;
     1:       otherNode = otherRange->GetStartParent();
     1:       otherOffset = otherRange->StartOffset();
     1:       break;
     1:     case nsIDOMRange::START_TO_END:
     1:       ourNode = mEndParent;
     1:       ourOffset = mEndOffset;
     1:       otherNode = otherRange->GetStartParent();
     1:       otherOffset = otherRange->StartOffset();
     1:       break;
     1:     case nsIDOMRange::END_TO_START:
     1:       ourNode = mStartParent;
     1:       ourOffset = mStartOffset;
     1:       otherNode = otherRange->GetEndParent();
     1:       otherOffset = otherRange->EndOffset();
     1:       break;
     1:     case nsIDOMRange::END_TO_END:
     1:       ourNode = mEndParent;
     1:       ourOffset = mEndOffset;
     1:       otherNode = otherRange->GetEndParent();
     1:       otherOffset = otherRange->EndOffset();
     1:       break;
     1:     default:
     1:       // We were passed an illegal value
107464:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
     1:   }
     1: 
     1:   if (mRoot != otherRange->GetRoot())
     1:     return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
     1: 
     1:   *aCmpRet = nsContentUtils::ComparePoints(ourNode, ourOffset,
     1:                                            otherNode, otherOffset);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 47862: /* static */ nsresult
 20321: nsRange::CloneParentsBetween(nsIDOMNode *aAncestor,
     1:                              nsIDOMNode *aNode,
     1:                              nsIDOMNode **aClosestAncestor,
     1:                              nsIDOMNode **aFarthestAncestor)
     1: {
     1:   NS_ENSURE_ARG_POINTER((aAncestor && aNode && aClosestAncestor && aFarthestAncestor));
     1: 
106838:   *aClosestAncestor  = nullptr;
106838:   *aFarthestAncestor = nullptr;
     1: 
     1:   if (aAncestor == aNode)
     1:     return NS_OK;
     1: 
     1:   nsCOMPtr<nsIDOMNode> parent, firstParent, lastParent;
     1: 
     1:   nsresult res = aNode->GetParentNode(getter_AddRefs(parent));
     1: 
     1:   while(parent && parent != aAncestor)
     1:   {
     1:     nsCOMPtr<nsIDOMNode> clone, tmpNode;
     1: 
 90796:     res = parent->CloneNode(false, 1, getter_AddRefs(clone));
     1: 
     1:     if (NS_FAILED(res)) return res;
     1:     if (!clone)         return NS_ERROR_FAILURE;
     1: 
     1:     if (! firstParent)
     1:       firstParent = lastParent = clone;
     1:     else
     1:     {
     1:       res = clone->AppendChild(lastParent, getter_AddRefs(tmpNode));
     1: 
     1:       if (NS_FAILED(res)) return res;
     1: 
     1:       lastParent = clone;
     1:     }
     1: 
     1:     tmpNode = parent;
     1:     res = tmpNode->GetParentNode(getter_AddRefs(parent));
     1:   }
     1: 
     1:   *aClosestAncestor  = firstParent;
     1:   NS_IF_ADDREF(*aClosestAncestor);
     1: 
     1:   *aFarthestAncestor = lastParent;
     1:   NS_IF_ADDREF(*aFarthestAncestor);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::CloneContents(nsIDOMDocumentFragment** aReturn)
     1: {
     1:   nsresult res;
     1:   nsCOMPtr<nsIDOMNode> commonAncestor;
     1:   res = GetCommonAncestorContainer(getter_AddRefs(commonAncestor));
     1:   if (NS_FAILED(res)) return res;
     1: 
     1:   nsCOMPtr<nsIDOMDocument> document =
 80526:     do_QueryInterface(mStartParent->OwnerDoc());
     1:   NS_ASSERTION(document, "CloneContents needs a document to continue.");
     1:   if (!document) return NS_ERROR_FAILURE;
     1: 
     1:   // Create a new document fragment in the context of this document,
     1:   // which might be null
     1: 
     1:   nsCOMPtr<nsIDOMDocumentFragment> clonedFrag;
     1: 
     1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(document));
     1: 
     1:   res = NS_NewDocumentFragment(getter_AddRefs(clonedFrag),
     1:                                doc->NodeInfoManager());
     1:   if (NS_FAILED(res)) return res;
     1: 
     1:   nsCOMPtr<nsIDOMNode> commonCloneAncestor(do_QueryInterface(clonedFrag));
     1:   if (!commonCloneAncestor) return NS_ERROR_FAILURE;
     1: 
     1:   // Create and initialize a subtree iterator that will give
     1:   // us all the subtrees within the range.
     1: 
     1:   RangeSubtreeIterator iter;
     1: 
     1:   res = iter.Init(this);
     1:   if (NS_FAILED(res)) return res;
     1: 
     1:   if (iter.IsDone())
     1:   {
     1:     // There's nothing to add to the doc frag, we must be done!
     1: 
     1:     *aReturn = clonedFrag;
     1:     NS_IF_ADDREF(*aReturn);
     1:     return NS_OK;
     1:   }
     1: 
     1:   iter.First();
     1: 
     1:   // With the exception of text nodes that contain one of the range
 20321:   // end points and elements which don't have any content selected the subtree
 20321:   // iterator should only give us back subtrees that are completely contained
 20321:   // between the range's end points.
     1:   //
     1:   // Unfortunately these subtrees don't contain the parent hierarchy/context
     1:   // that the Range spec requires us to return. This loop clones the
     1:   // parent hierarchy, adds a cloned version of the subtree, to it, then
     1:   // correctly places this new subtree into the doc fragment.
     1: 
     1:   while (!iter.IsDone())
     1:   {
     1:     nsCOMPtr<nsIDOMNode> node(iter.GetCurrentNode());
     1:     nsCOMPtr<nsINode> iNode = do_QueryInterface(node);
 79445:     bool deepClone = !iNode->IsElement() ||
 20321:                        (!(iNode == mEndParent && mEndOffset == 0) &&
 20321:                         !(iNode == mStartParent &&
 41636:                           mStartOffset ==
108991:                             int32_t(iNode->AsElement()->GetChildCount())));
 20321: 
     1:     // Clone the current subtree!
     1: 
     1:     nsCOMPtr<nsIDOMNode> clone;
 90796:     res = node->CloneNode(deepClone, 1, getter_AddRefs(clone));
     1:     if (NS_FAILED(res)) return res;
     1: 
     1:     // If it's CharacterData, make sure we only clone what
     1:     // is in the range.
     1:     //
     1:     // XXX_kin: We need to also handle ProcessingInstruction
     1:     // XXX_kin: according to the spec.
     1: 
     1:     nsCOMPtr<nsIDOMCharacterData> charData(do_QueryInterface(clone));
     1: 
     1:     if (charData)
     1:     {
     1:       if (iNode == mEndParent)
     1:       {
     1:         // We only need the data before mEndOffset, so get rid of any
     1:         // data after it.
     1: 
108991:         uint32_t dataLength = 0;
     1:         res = charData->GetLength(&dataLength);
     1:         if (NS_FAILED(res)) return res;
     1: 
108991:         if (dataLength > (uint32_t)mEndOffset)
     1:         {
     1:           res = charData->DeleteData(mEndOffset, dataLength - mEndOffset);
     1:           if (NS_FAILED(res)) return res;
     1:         }
     1:       }       
     1: 
     1:       if (iNode == mStartParent)
     1:       {
     1:         // We don't need any data before mStartOffset, so just
     1:         // delete it!
     1: 
     1:         if (mStartOffset > 0)
     1:         {
     1:           res = charData->DeleteData(0, mStartOffset);
     1:           if (NS_FAILED(res)) return res;
     1:         }
     1:       }
     1:     }
     1: 
     1:     // Clone the parent hierarchy between commonAncestor and node.
     1: 
     1:     nsCOMPtr<nsIDOMNode> closestAncestor, farthestAncestor;
     1: 
     1:     res = CloneParentsBetween(commonAncestor, node,
     1:                               getter_AddRefs(closestAncestor),
     1:                               getter_AddRefs(farthestAncestor));
     1: 
     1:     if (NS_FAILED(res)) return res;
     1: 
     1:     // Hook the parent hierarchy/context of the subtree into the clone tree.
     1: 
     1:     nsCOMPtr<nsIDOMNode> tmpNode;
     1: 
     1:     if (farthestAncestor)
     1:     {
     1:       res = commonCloneAncestor->AppendChild(farthestAncestor,
     1:                                              getter_AddRefs(tmpNode));
     1: 
     1:       if (NS_FAILED(res)) return res;
     1:     }
     1: 
     1:     // Place the cloned subtree into the cloned doc frag tree!
     1: 
     1:     if (closestAncestor)
     1:     {
     1:       // Append the subtree under closestAncestor since it is the
     1:       // immediate parent of the subtree.
     1: 
     1:       res = closestAncestor->AppendChild(clone, getter_AddRefs(tmpNode));
     1:     }
     1:     else
     1:     {
     1:       // If we get here, there is no missing parent hierarchy between 
     1:       // commonAncestor and node, so just append clone to commonCloneAncestor.
     1: 
     1:       res = commonCloneAncestor->AppendChild(clone, getter_AddRefs(tmpNode));
     1:     }
     1:     if (NS_FAILED(res)) return res;
     1: 
     1:     // Get the next subtree to be processed. The idea here is to setup
     1:     // the parameters for the next iteration of the loop.
     1: 
     1:     iter.Next();
     1: 
     1:     if (iter.IsDone())
     1:       break; // We must be done!
     1: 
     1:     nsCOMPtr<nsIDOMNode> nextNode(iter.GetCurrentNode());
     1:     if (!nextNode) return NS_ERROR_FAILURE;
     1: 
     1:     // Get node and nextNode's common parent.
     1:     nsContentUtils::GetCommonAncestor(node, nextNode, getter_AddRefs(commonAncestor));
     1: 
     1:     if (!commonAncestor)
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     // Find the equivalent of commonAncestor in the cloned tree!
     1: 
     1:     while (node && node != commonAncestor)
     1:     {
     1:       tmpNode = node;
     1:       res = tmpNode->GetParentNode(getter_AddRefs(node));
     1:       if (NS_FAILED(res)) return res;
     1:       if (!node) return NS_ERROR_FAILURE;
     1: 
     1:       tmpNode = clone;
     1:       res = tmpNode->GetParentNode(getter_AddRefs(clone));
     1:       if (NS_FAILED(res)) return res;
 12178:       if (!clone) return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     commonCloneAncestor = clone;
     1:   }
     1: 
     1:   *aReturn = clonedFrag;
     1:   NS_IF_ADDREF(*aReturn);
     1: 
     1:   return NS_OK;
     1: }
     1: 
103057: already_AddRefed<nsRange>
103057: nsRange::CloneRange() const
     1: {
 26992:   nsRefPtr<nsRange> range = new nsRange();
     1: 
  2561:   range->SetMaySpanAnonymousSubtrees(mMaySpanAnonymousSubtrees);
  2561: 
     1:   range->DoSetRange(mStartParent, mStartOffset, mEndParent, mEndOffset, mRoot);
     1: 
103057:   return range.forget();
     1: }
     1: 
 86939: NS_IMETHODIMP
 86939: nsRange::CloneRange(nsIDOMRange** aReturn)
 26992: {
103057:   *aReturn = CloneRange().get();
103057:   return NS_OK;
 26992: }
 26992: 
 47862: NS_IMETHODIMP
 95436: nsRange::InsertNode(nsIDOMNode* aNode)
     1: {
 95436:   VALIDATE_ACCESS(aNode);
     1:   
     1:   nsresult res;
108991:   int32_t tStartOffset;
     1:   this->GetStartOffset(&tStartOffset);
     1: 
     1:   nsCOMPtr<nsIDOMNode> tStartContainer;
     1:   res = this->GetStartContainer(getter_AddRefs(tStartContainer));
 95436:   NS_ENSURE_SUCCESS(res, res);
 95436: 
 95436:   // This is the node we'll be inserting before, and its parent
 95436:   nsCOMPtr<nsIDOMNode> referenceNode;
 95436:   nsCOMPtr<nsIDOMNode> referenceParentNode = tStartContainer;
     1: 
     1:   nsCOMPtr<nsIDOMText> startTextNode(do_QueryInterface(tStartContainer));
 95437:   nsCOMPtr<nsIDOMNodeList> tChildList;
 95436:   if (startTextNode) {
 95436:     res = tStartContainer->GetParentNode(getter_AddRefs(referenceParentNode));
 95436:     NS_ENSURE_SUCCESS(res, res);
 95436:     NS_ENSURE_TRUE(referenceParentNode, NS_ERROR_DOM_HIERARCHY_REQUEST_ERR);
 31645: 
     1:     nsCOMPtr<nsIDOMText> secondPart;
     1:     res = startTextNode->SplitText(tStartOffset, getter_AddRefs(secondPart));
 95436:     NS_ENSURE_SUCCESS(res, res);
 95436: 
 95436:     referenceNode = secondPart;
 95436:   } else {
     1:     res = tStartContainer->GetChildNodes(getter_AddRefs(tChildList));
 95436:     NS_ENSURE_SUCCESS(res, res);
     1: 
     1:     // find the insertion point in the DOM and insert the Node
 95436:     res = tChildList->Item(tStartOffset, getter_AddRefs(referenceNode));
 95436:     NS_ENSURE_SUCCESS(res, res);
 95436:   }
     1: 
102306:   // We might need to update the end to include the new node (bug 433662).
102306:   // Ideally we'd only do this if needed, but it's tricky to know when it's
102306:   // needed in advance (bug 765799).
108991:   int32_t newOffset;
 95437: 
 95437:   if (referenceNode) {
 95437:     newOffset = IndexOf(referenceNode);
 95437:   } else {
108991:     uint32_t length;
 95437:     res = tChildList->GetLength(&length);
 95437:     NS_ENSURE_SUCCESS(res, res);
 95437:     newOffset = length;
 95437:   }
 95437: 
 95437:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
 95437:   NS_ENSURE_STATE(node);
 95437:   if (node->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {
 95437:     newOffset += node->GetChildCount();
 95437:   } else {
 95437:     newOffset++;
 95437:   }
102306: 
102306:   // Now actually insert the node
     1:   nsCOMPtr<nsIDOMNode> tResultNode;
 95437:   res = referenceParentNode->InsertBefore(aNode, referenceNode, getter_AddRefs(tResultNode));
 95437:   NS_ENSURE_SUCCESS(res, res);
 95437: 
 95437:   if (Collapsed()) {
 95437:     return SetEnd(referenceParentNode, newOffset);
 95437:   }
 95437:   return NS_OK;
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::SurroundContents(nsIDOMNode* aNewParent)
     1: {
     1:   VALIDATE_ACCESS(aNewParent);
     1: 
 19294:   NS_ENSURE_TRUE(mRoot, NS_ERROR_DOM_INVALID_STATE_ERR);
 91491:   // INVALID_STATE_ERROR: Raised if the Range partially selects a non-text
 19294:   // node.
 19294:   if (mStartParent != mEndParent) {
 79445:     bool startIsText = mStartParent->IsNodeOfType(nsINode::eTEXT);
 79445:     bool endIsText = mEndParent->IsNodeOfType(nsINode::eTEXT);
119415:     nsINode* startGrandParent = mStartParent->GetParentNode();
119415:     nsINode* endGrandParent = mEndParent->GetParentNode();
 19294:     NS_ENSURE_TRUE((startIsText && endIsText &&
 19294:                     startGrandParent &&
 19294:                     startGrandParent == endGrandParent) ||
 19294:                    (startIsText &&
 19294:                     startGrandParent &&
 19294:                     startGrandParent == mEndParent) ||
 19294:                    (endIsText &&
 19294:                     endGrandParent &&
 19294:                     endGrandParent == mStartParent),
 91491:                    NS_ERROR_DOM_INVALID_STATE_ERR);
 19294:   }
 19294: 
 93790:   // INVALID_NODE_TYPE_ERROR if aNewParent is something that can't be inserted
 93790:   // (Document, DocumentType, DocumentFragment)
108991:   uint16_t nodeType;
 93790:   nsresult res = aNewParent->GetNodeType(&nodeType);
 93790:   if (NS_FAILED(res)) return res;
 93790:   if (nodeType == nsIDOMNode::DOCUMENT_NODE ||
 93790:       nodeType == nsIDOMNode::DOCUMENT_TYPE_NODE ||
 93790:       nodeType == nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {
 93790:     return NS_ERROR_DOM_INVALID_NODE_TYPE_ERR;
 93790:   }
 93790: 
     1:   // Extract the contents within the range.
     1: 
     1:   nsCOMPtr<nsIDOMDocumentFragment> docFrag;
     1: 
 93790:   res = ExtractContents(getter_AddRefs(docFrag));
     1: 
     1:   if (NS_FAILED(res)) return res;
     1:   if (!docFrag) return NS_ERROR_FAILURE;
     1: 
     1:   // Spec says we need to remove all of aNewParent's
     1:   // children prior to insertion.
     1: 
     1:   nsCOMPtr<nsIDOMNodeList> children;
     1:   res = aNewParent->GetChildNodes(getter_AddRefs(children));
     1: 
     1:   if (NS_FAILED(res)) return res;
     1:   if (!children) return NS_ERROR_FAILURE;
     1: 
108991:   uint32_t numChildren = 0;
     1:   res = children->GetLength(&numChildren);
     1:   if (NS_FAILED(res)) return res;
     1: 
     1:   nsCOMPtr<nsIDOMNode> tmpNode;
     1: 
     1:   while (numChildren)
     1:   {
     1:     nsCOMPtr<nsIDOMNode> child;
     1:     res = children->Item(--numChildren, getter_AddRefs(child));
     1: 
     1:     if (NS_FAILED(res)) return res;
     1:     if (!child) return NS_ERROR_FAILURE;
     1: 
     1:     res = aNewParent->RemoveChild(child, getter_AddRefs(tmpNode));
     1:     if (NS_FAILED(res)) return res;
     1:   }
     1: 
     1:   // Insert aNewParent at the range's start point.
     1: 
     1:   res = InsertNode(aNewParent);
     1:   if (NS_FAILED(res)) return res;
     1: 
     1:   // Append the content we extracted under aNewParent.
     1: 
     1:   res = aNewParent->AppendChild(docFrag, getter_AddRefs(tmpNode));
     1:   if (NS_FAILED(res)) return res;
     1: 
     1:   // Select aNewParent, and its contents.
     1: 
     1:   return SelectNode(aNewParent);
     1: }
     1: 
 47862: NS_IMETHODIMP
 47862: nsRange::ToString(nsAString& aReturn)
     1: { 
     1:   // clear the string
     1:   aReturn.Truncate();
     1:   
     1:   // If we're unpositioned, return the empty string
     1:   if (!mIsPositioned) {
     1:     return NS_OK;
     1:   }
     1: 
     1: #ifdef DEBUG_range
     1:       printf("Range dump: -----------------------\n");
     1: #endif /* DEBUG */
     1:     
     1:   // effeciency hack for simple case
     1:   if (mStartParent == mEndParent)
     1:   {
     1:     nsCOMPtr<nsIDOMText> textNode( do_QueryInterface(mStartParent) );
     1:     
     1:     if (textNode)
     1:     {
     1: #ifdef DEBUG_range
     1:       // If debug, dump it:
     1:       nsCOMPtr<nsIContent> cN (do_QueryInterface(mStartParent));
     1:       if (cN) cN->List(stdout);
     1:       printf("End Range dump: -----------------------\n");
     1: #endif /* DEBUG */
     1: 
     1:       // grab the text
     1:       if (NS_FAILED(textNode->SubstringData(mStartOffset,mEndOffset-mStartOffset,aReturn)))
     1:         return NS_ERROR_UNEXPECTED;
     1:       return NS_OK;
     1:     }
     1:   } 
     1:   
     1:   /* complex case: mStartParent != mEndParent, or mStartParent not a text node
     1:      revisit - there are potential optimizations here and also tradeoffs.
     1:   */
     1: 
101616:   nsCOMPtr<nsIContentIterator> iter = NS_NewContentIterator();
101616:   nsresult rv = iter->Init(this);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   
     1:   nsString tempString;
     1:  
     1:   // loop through the content iterator, which returns nodes in the range in 
     1:   // close tag order, and grab the text from any text node
     1:   while (!iter->IsDone())
     1:   {
 20503:     nsINode *n = iter->GetCurrentNode();
     1: 
     1: #ifdef DEBUG_range
     1:     // If debug, dump it:
 20503:     n->List(stdout);
     1: #endif /* DEBUG */
 20503:     nsCOMPtr<nsIDOMText> textNode(do_QueryInterface(n));
     1:     if (textNode) // if it's a text node, get the text
     1:     {
 20503:       if (n == mStartParent) // only include text past start offset
     1:       {
108991:         uint32_t strLength;
     1:         textNode->GetLength(&strLength);
     1:         textNode->SubstringData(mStartOffset,strLength-mStartOffset,tempString);
     1:         aReturn += tempString;
     1:       }
 20503:       else if (n == mEndParent)  // only include text before end offset
     1:       {
     1:         textNode->SubstringData(0,mEndOffset,tempString);
     1:         aReturn += tempString;
     1:       }
     1:       else  // grab the whole kit-n-kaboodle
     1:       {
     1:         textNode->GetData(tempString);
     1:         aReturn += tempString;
     1:       }
     1:     }
     1: 
     1:     iter->Next();
     1:   }
     1: 
     1: #ifdef DEBUG_range
     1:   printf("End Range dump: -----------------------\n");
     1: #endif /* DEBUG */
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: 
 47862: NS_IMETHODIMP
     1: nsRange::Detach()
     1: {
 96921:   // No-op, but still set mIsDetached for telemetry (bug 702948)
 80486:   mIsDetached = true;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP    
     1: nsRange::CreateContextualFragment(const nsAString& aFragment,
     1:                                   nsIDOMDocumentFragment** aReturn)
     1: {
 12676:   if (mIsPositioned) {
 41240:     return nsContentUtils::CreateContextualFragment(mStartParent, aFragment,
 80486:                                                     false, aReturn);
     1:   }
 12676:   return NS_ERROR_FAILURE;
 12676: }
 33027: 
 33027: static void ExtractRectFromOffset(nsIFrame* aFrame,
 33027:                                   const nsIFrame* aRelativeTo, 
108991:                                   const int32_t aOffset, nsRect* aR, bool aKeepLeft)
 33027: {
 33027:   nsPoint point;
 33027:   aFrame->GetPointFromOffset(aOffset, &point);
 33027: 
 33027:   point += aFrame->GetOffsetTo(aRelativeTo);
 33027: 
 33027:   //given a point.x, extract left or right portion of rect aR
 33027:   //point.x has to be within this rect
 33027:   NS_ASSERTION(aR->x <= point.x && point.x <= aR->XMost(),
 33027:                    "point.x should not be outside of rect r");
 33027: 
 33027:   if (aKeepLeft) {
 33027:     aR->width = point.x - aR->x;
 33027:   } else {
 33027:     aR->width = aR->XMost() - point.x;
 33027:     aR->x = point.x;
 33027:   }
 33027: }
 33027: 
 36655: static nsresult GetPartialTextRect(nsLayoutUtils::RectCallback* aCallback,
108991:                                    nsIContent* aContent, int32_t aStartOffset, int32_t aEndOffset)
 33027: {
 36655:   nsIFrame* frame = aContent->GetPrimaryFrame();
 33027:   if (frame && frame->GetType() == nsGkAtoms::textFrame) {
 33027:     nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
 33027:     nsIFrame* relativeTo = nsLayoutUtils::GetContainingBlockForClientRect(textFrame);
 33027:     for (nsTextFrame* f = textFrame; f; f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
108991:       int32_t fstart = f->GetContentOffset(), fend = f->GetContentEnd();
 33027:       if (fend <= aStartOffset || fstart >= aEndOffset)
 33027:         continue;
 33027: 
 41480:       // overlapping with the offset we want
 82675:       f->EnsureTextRun(nsTextFrame::eInflated);
 82675:       NS_ENSURE_TRUE(f->GetTextRun(nsTextFrame::eInflated), NS_ERROR_OUT_OF_MEMORY);
 82675:       bool rtl = f->GetTextRun(nsTextFrame::eInflated)->IsRightToLeft();
 33027:       nsRect r(f->GetOffsetTo(relativeTo), f->GetSize());
 33027:       if (fstart < aStartOffset) {
 33027:         // aStartOffset is within this frame
 33027:         ExtractRectFromOffset(f, relativeTo, aStartOffset, &r, rtl);
 33027:       }
 33027:       if (fend > aEndOffset) {
 33027:         // aEndOffset is in the middle of this frame
 33027:         ExtractRectFromOffset(f, relativeTo, aEndOffset, &r, !rtl);
 33027:       }
 33027:       aCallback->AddRect(r);
 33027:     }
 33027:   }
 33027:   return NS_OK;
 33027: }
 33027: 
 33027: static void CollectClientRects(nsLayoutUtils::RectCallback* aCollector, 
 33027:                                nsRange* aRange,
108991:                                nsINode* aStartParent, int32_t aStartOffset,
108991:                                nsINode* aEndParent, int32_t aEndOffset)
 33027: {
 36655:   // Hold strong pointers across the flush
 33027:   nsCOMPtr<nsIDOMNode> startContainer = do_QueryInterface(aStartParent);
 33027:   nsCOMPtr<nsIDOMNode> endContainer = do_QueryInterface(aEndParent);
 33027: 
 36655:   // Flush out layout so our frames are up to date.
 36655:   if (!aStartParent->IsInDoc()) {
 36655:     return;
 36655:   }
 36655: 
 36655:   aStartParent->GetCurrentDoc()->FlushPendingNotifications(Flush_Layout);
 36655: 
 36655:   // Recheck whether we're still in the document
 36655:   if (!aStartParent->IsInDoc()) {
 33027:     return;
 33027:   }
 33027: 
 33027:   RangeSubtreeIterator iter;
 33027: 
 33027:   nsresult rv = iter.Init(aRange);
 33027:   if (NS_FAILED(rv)) return;
 33027: 
 33027:   if (iter.IsDone()) {
 33027:     // the range is collapsed, only continue if the cursor is in a text node
 33027:     nsCOMPtr<nsIContent> content = do_QueryInterface(aStartParent);
 36986:     if (content && content->IsNodeOfType(nsINode::eTEXT)) {
 36655:       nsIFrame* frame = content->GetPrimaryFrame();
 33027:       if (frame && frame->GetType() == nsGkAtoms::textFrame) {
 33027:         nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
108991:         int32_t outOffset;
 33027:         nsIFrame* outFrame;
 80486:         textFrame->GetChildFrameContainingOffset(aStartOffset, false, 
 33027:           &outOffset, &outFrame);
 33027:         if (outFrame) {
 33027:            nsIFrame* relativeTo = 
 33027:              nsLayoutUtils::GetContainingBlockForClientRect(outFrame);
 33027:            nsRect r(outFrame->GetOffsetTo(relativeTo), outFrame->GetSize());
 80486:            ExtractRectFromOffset(outFrame, relativeTo, aStartOffset, &r, false);
 33027:            r.width = 0;
 33027:            aCollector->AddRect(r);
 33027:         }
 33027:       }
 33027:     }
 33027:     return;
 33027:   }
 33027: 
 33027:   do {
 33027:     nsCOMPtr<nsIDOMNode> node(iter.GetCurrentNode());
 33027:     iter.Next();
 33027:     nsCOMPtr<nsIContent> content = do_QueryInterface(node);
 36986:     if (!content)
 36986:       continue;
 33027:     if (content->IsNodeOfType(nsINode::eTEXT)) {
 33027:        if (node == startContainer) {
108991:          int32_t offset = startContainer == endContainer ? 
 33027:            aEndOffset : content->GetText()->GetLength();
 36655:          GetPartialTextRect(aCollector, content, aStartOffset, offset);
 33027:          continue;
 33027:        } else if (node == endContainer) {
 36655:          GetPartialTextRect(aCollector, content, 0, aEndOffset);
 33027:          continue;
 33027:        }
 33027:     }
 33027: 
 36655:     nsIFrame* frame = content->GetPrimaryFrame();
 33027:     if (frame) {
 33027:       nsLayoutUtils::GetAllInFlowRects(frame,
 33027:         nsLayoutUtils::GetContainingBlockForClientRect(frame), aCollector);
 33027:     }
 33027:   } while (!iter.IsDone());
 33027: }
 33027: 
 33027: NS_IMETHODIMP
 33027: nsRange::GetBoundingClientRect(nsIDOMClientRect** aResult)
 33027: {
106838:   *aResult = nullptr;
 36986: 
 33027:   // Weak ref, since we addref it below
 33027:   nsClientRect* rect = new nsClientRect();
 33027:   if (!rect)
 33027:     return NS_ERROR_OUT_OF_MEMORY;
 33027: 
 33027:   NS_ADDREF(*aResult = rect);
 33027: 
 36986:   if (!mStartParent)
 36986:     return NS_OK;
 36986: 
 33027:   nsLayoutUtils::RectAccumulator accumulator;
 33027:   
 33027:   CollectClientRects(&accumulator, this, mStartParent, mStartOffset, 
 33027:     mEndParent, mEndOffset);
 33027: 
 33027:   nsRect r = accumulator.mResultRect.IsEmpty() ? accumulator.mFirstRect : 
 33027:     accumulator.mResultRect;
 33027:   rect->SetLayoutRect(r);
 33027:   return NS_OK;
 33027: }
 33027: 
 33027: NS_IMETHODIMP
 33027: nsRange::GetClientRects(nsIDOMClientRectList** aResult)
 33027: {
106838:   *aResult = nullptr;
 33027: 
 36986:   if (!mStartParent)
 36986:     return NS_OK;
 36986: 
 92064:   nsRefPtr<nsClientRectList> rectList =
 92064:     new nsClientRectList(static_cast<nsIDOMRange*>(this));
 33027:   if (!rectList)
 33027:     return NS_ERROR_OUT_OF_MEMORY;
 33027: 
 33027:   nsLayoutUtils::RectListBuilder builder(rectList);
 33027: 
 33027:   CollectClientRects(&builder, this, mStartParent, mStartOffset, 
 33027:     mEndParent, mEndOffset);
 33027: 
 33027:   if (NS_FAILED(builder.mRV))
 33027:     return builder.mRV;
 33027:   rectList.forget(aResult);
 33027:   return NS_OK;
 33027: }
 33027: 
 71908: NS_IMETHODIMP
 71908: nsRange::GetUsedFontFaces(nsIDOMFontFaceList** aResult)
 71908: {
106838:   *aResult = nullptr;
 71908: 
 71908:   NS_ENSURE_TRUE(mStartParent, NS_ERROR_UNEXPECTED);
 71908: 
 71908:   nsCOMPtr<nsIDOMNode> startContainer = do_QueryInterface(mStartParent);
 71908:   nsCOMPtr<nsIDOMNode> endContainer = do_QueryInterface(mEndParent);
 71908: 
 71908:   // Flush out layout so our frames are up to date.
 80526:   nsIDocument* doc = mStartParent->OwnerDoc();
 71908:   NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
 71908:   doc->FlushPendingNotifications(Flush_Frames);
 71908: 
 71908:   // Recheck whether we're still in the document
 71908:   NS_ENSURE_TRUE(mStartParent->IsInDoc(), NS_ERROR_UNEXPECTED);
 71908: 
 71908:   nsRefPtr<nsFontFaceList> fontFaceList = new nsFontFaceList();
 71908: 
 71908:   RangeSubtreeIterator iter;
 71908:   nsresult rv = iter.Init(this);
 71908:   NS_ENSURE_SUCCESS(rv, rv);
 71908: 
 71908:   while (!iter.IsDone()) {
 71908:     // only collect anything if the range is not collapsed
 71908:     nsCOMPtr<nsIDOMNode> node(iter.GetCurrentNode());
 71908:     iter.Next();
 71908: 
 71908:     nsCOMPtr<nsIContent> content = do_QueryInterface(node);
 71908:     if (!content) {
 71908:       continue;
 71908:     }
 71908:     nsIFrame* frame = content->GetPrimaryFrame();
 71908:     if (!frame) {
 71908:       continue;
 71908:     }
 71908: 
 71908:     if (content->IsNodeOfType(nsINode::eTEXT)) {
 71908:        if (node == startContainer) {
108991:          int32_t offset = startContainer == endContainer ? 
 71908:            mEndOffset : content->GetText()->GetLength();
 71908:          nsLayoutUtils::GetFontFacesForText(frame, mStartOffset, offset,
 80486:                                             true, fontFaceList);
 71908:          continue;
 71908:        }
 71908:        if (node == endContainer) {
 71908:          nsLayoutUtils::GetFontFacesForText(frame, 0, mEndOffset,
 80486:                                             true, fontFaceList);
 71908:          continue;
 71908:        }
 71908:     }
 71908: 
 71908:     nsLayoutUtils::GetFontFacesForFrames(frame, fontFaceList);
 71908:   }
 71908: 
 71908:   fontFaceList.forget(aResult);
 71908:   return NS_OK;
 71908: }
 86160: 
 86160: nsINode*
 86160: nsRange::GetRegisteredCommonAncestor()
 86160: {
 86160:   NS_ASSERTION(IsInSelection(),
 86160:                "GetRegisteredCommonAncestor only valid for range in selection");
 86160:   nsINode* ancestor = GetNextRangeCommonAncestor(mStartParent);
 86160:   while (ancestor) {
 86160:     RangeHashTable* ranges =
 86160:       static_cast<RangeHashTable*>(ancestor->GetProperty(nsGkAtoms::range));
 86160:     if (ranges->GetEntry(this)) {
 86160:       break;
 86160:     }
119415:     ancestor = GetNextRangeCommonAncestor(ancestor->GetParentNode());
 86160:   }
 86160:   NS_ASSERTION(ancestor, "can't find common ancestor for selected range");
 86160:   return ancestor;
 86160: }
 86160: 
 86160: /* static */ bool nsRange::AutoInvalidateSelection::mIsNested;
 86160: 
 86160: nsRange::AutoInvalidateSelection::~AutoInvalidateSelection()
 86160: {
 86160:   NS_ASSERTION(mWasInSelection == mRange->IsInSelection(),
 86160:                "Range got unselected in AutoInvalidateSelection block");
 86160:   if (!mCommonAncestor) {
 86160:     return;
 86160:   }
 86160:   mIsNested = false;
 86160:   ::InvalidateAllFrames(mCommonAncestor);
 86160:   nsINode* commonAncestor = mRange->GetRegisteredCommonAncestor();
 86160:   if (commonAncestor != mCommonAncestor) {
 86160:     ::InvalidateAllFrames(commonAncestor);
 86160:   }
 86160: }
