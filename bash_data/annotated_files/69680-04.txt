51215: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
51215:  *
51215:  * ***** BEGIN LICENSE BLOCK *****
51215:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
51215:  *
51215:  * The contents of this file are subject to the Mozilla Public License Version
51215:  * 1.1 (the "License"); you may not use this file except in compliance with
51215:  * the License. You may obtain a copy of the License at
51215:  * http://www.mozilla.org/MPL/
51215:  *
51215:  * Software distributed under the License is distributed on an "AS IS" basis,
51215:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
51215:  * for the specific language governing rights and limitations under the
51215:  * License.
51215:  *
51215:  * The Original Code is mozilla.org code.
51215:  *
51215:  * The Initial Developer of the Original Code is
51215:  * Netscape Communications Corporation.
51215:  * Portions created by the Initial Developer are Copyright (C) 2001
51215:  * the Initial Developer. All Rights Reserved.
51215:  *
51215:  * Contributor(s):
51215:  *   Stuart Parmenter <stuart@mozilla.com>
51215:  *   Federico Mena-Quintero <federico@novell.com>
51215:  *   Bobby Holley <bobbyholley@gmail.com>
51215:  *
51215:  * Alternatively, the contents of this file may be used under the terms of
51215:  * either the GNU General Public License Version 2 or later (the "GPL"), or
51215:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
51215:  * in which case the provisions of the GPL or the LGPL are applicable instead
51215:  * of those above. If you wish to allow use of your version of this file only
51215:  * under the terms of either the GPL or the LGPL, and not to allow others to
51215:  * use your version of this file under the terms of the MPL, indicate your
51215:  * decision by deleting the provisions above and replace them with the notice
51215:  * and other provisions required by the GPL or the LGPL. If you do not delete
51215:  * the provisions above, a recipient may use your version of this file under
51215:  * the terms of any one of the MPL, the GPL or the LGPL.
51215:  *
51215:  * ***** END LICENSE BLOCK ***** */
51215: 
51215: #include "nsJPEGDecoder.h"
51215: 
51215: #include "imgIContainerObserver.h"
51215: 
51215: #include "nsIInputStream.h"
51215: 
51215: #include "nspr.h"
51215: #include "nsCRT.h"
51215: #include "ImageLogging.h"
51215: #include "gfxColor.h"
51215: 
51215: #include "jerror.h"
51215: 
51215: #include "gfxPlatform.h"
51215: 
51215: extern "C" {
51215: #include "iccjpeg.h"
51215: 
51215: /* Colorspace conversion (copied from jpegint.h) */
51215: struct jpeg_color_deconverter {
51215:   JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
51215:   JMETHOD(void, color_convert, (j_decompress_ptr cinfo,
51215: 				JSAMPIMAGE input_buf, JDIMENSION input_row,
51215: 				JSAMPARRAY output_buf, int num_rows));
51215: };
51215: 
51215: METHODDEF(void)
51215: ycc_rgb_convert_argb (j_decompress_ptr cinfo,
51215:                  JSAMPIMAGE input_buf, JDIMENSION input_row,
51215:                  JSAMPARRAY output_buf, int num_rows);
51215: }
51215: 
51241: static void cmyk_convert_rgb(JSAMPROW row, JDIMENSION width);
51241: 
51241: namespace mozilla {
51241: namespace imagelib {
51215: 
51215: #if defined(PR_LOGGING)
51215: PRLogModuleInfo *gJPEGlog = PR_NewLogModule("JPEGDecoder");
51215: static PRLogModuleInfo *gJPEGDecoderAccountingLog = PR_NewLogModule("JPEGDecoderAccounting");
51215: #else
51215: #define gJPEGlog
51215: #define gJPEGDecoderAccountingLog
51215: #endif
51215: 
63776: static qcms_profile*
63776: GetICCProfile(struct jpeg_decompress_struct &info)
63776: {
63776:   JOCTET* profilebuf;
63776:   PRUint32 profileLength;
63776:   qcms_profile* profile = nsnull;
63776: 
63776:   if (read_icc_profile(&info, &profilebuf, &profileLength)) {
63778:     profile = qcms_profile_from_memory(profilebuf, profileLength);
63776:     free(profilebuf);
63776:   }
63776: 
63776:   return profile;
63776: }
51215: 
51215: METHODDEF(void) init_source (j_decompress_ptr jd);
51215: METHODDEF(boolean) fill_input_buffer (j_decompress_ptr jd);
51215: METHODDEF(void) skip_input_data (j_decompress_ptr jd, long num_bytes);
51215: METHODDEF(void) term_source (j_decompress_ptr jd);
51215: METHODDEF(void) my_error_exit (j_common_ptr cinfo);
51215: 
51215: /* Normal JFIF markers can't have more bytes than this. */
51215: #define MAX_JPEG_MARKER_LENGTH  (((PRUint32)1 << 16) - 1)
51215: 
51215: 
51215: nsJPEGDecoder::nsJPEGDecoder()
51215: {
51215:   mState = JPEG_HEADER;
51215:   mReading = PR_TRUE;
51215:   mImageData = nsnull;
51215: 
51215:   mBytesToSkip = 0;
51215:   memset(&mInfo, 0, sizeof(jpeg_decompress_struct));
51215:   memset(&mSourceMgr, 0, sizeof(mSourceMgr));
51215:   mInfo.client_data = (void*)this;
51215: 
51215:   mSegment = nsnull;
51215:   mSegmentLen = 0;
51215: 
51215:   mBackBuffer = nsnull;
51215:   mBackBufferLen = mBackBufferSize = mBackBufferUnreadLen = 0;
51215: 
51215:   mInProfile = nsnull;
51215:   mTransform = nsnull;
51215: 
60418:   mCMSMode = 0;
60418: 
51215:   PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:          ("nsJPEGDecoder::nsJPEGDecoder: Creating JPEG decoder %p",
51215:           this));
51215: }
51215: 
51215: nsJPEGDecoder::~nsJPEGDecoder()
51215: {
51247:   // Step 8: Release JPEG decompression object
51247:   mInfo.src = nsnull;
51247:   jpeg_destroy_decompress(&mInfo);
51247: 
51215:   PR_FREEIF(mBackBuffer);
51215:   if (mTransform)
51215:     qcms_transform_release(mTransform);
51215:   if (mInProfile)
51215:     qcms_profile_release(mInProfile);
51215: 
51215:   PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:          ("nsJPEGDecoder::~nsJPEGDecoder: Destroying JPEG decoder %p",
51215:           this));
51215: }
51215: 
51215: 
53664: void
51241: nsJPEGDecoder::InitInternal()
51215: {
60418:   mCMSMode = gfxPlatform::GetCMSMode();
60418:   if ((mDecodeFlags & DECODER_NO_COLORSPACE_CONVERSION) != 0)
60418:     mCMSMode = eCMSMode_Off;
60418: 
51215:   /* We set up the normal JPEG error routines, then override error_exit. */
51215:   mInfo.err = jpeg_std_error(&mErr.pub);
51215:   /*   mInfo.err = jpeg_std_error(&mErr.pub); */
51215:   mErr.pub.error_exit = my_error_exit;
51215:   /* Establish the setjmp return context for my_error_exit to use. */
51215:   if (setjmp(mErr.setjmp_buffer)) {
51215:     /* If we get here, the JPEG code has signaled an error.
51215:      * We need to clean up the JPEG object, close the input file, and return.
51215:      */
53662:     PostDecoderError(NS_ERROR_FAILURE);
53664:     return;
51215:   }
51215: 
51215:   /* Step 1: allocate and initialize JPEG decompression object */
51215:   jpeg_create_decompress(&mInfo);
51215:   /* Set the source manager */
51215:   mInfo.src = &mSourceMgr;
51215: 
51215:   /* Step 2: specify data source (eg, a file) */
51215: 
51215:   /* Setup callback functions. */
51215:   mSourceMgr.init_source = init_source;
51215:   mSourceMgr.fill_input_buffer = fill_input_buffer;
51215:   mSourceMgr.skip_input_data = skip_input_data;
51215:   mSourceMgr.resync_to_restart = jpeg_resync_to_restart;
51215:   mSourceMgr.term_source = term_source;
51215: 
51215:   /* Record app markers for ICC data */
51215:   for (PRUint32 m = 0; m < 16; m++)
51215:     jpeg_save_markers(&mInfo, JPEG_APP0 + m, 0xFFFF);
51215: }
51215: 
53664: void
51247: nsJPEGDecoder::FinishInternal()
51215: {
51239:   /* If we're not in any sort of error case, flush the decoder.
51239:    *
51239:    * XXXbholley - It seems wrong that this should be necessary, but at the
51239:    * moment I'm just folding the contents of Flush() into Close() so that
51239:    * we can get rid of it.
51239:    */
51239:   if ((mState != JPEG_DONE && mState != JPEG_SINK_NON_JPEG_TRAILER) &&
51239:       (mState != JPEG_ERROR) &&
51247:       !IsSizeDecode())
51239:     this->Write(nsnull, 0);
51215: }
51215: 
53664: void
51241: nsJPEGDecoder::WriteInternal(const char *aBuffer, PRUint32 aCount)
51215: {
51215:   mSegment = (const JOCTET *)aBuffer;
51215:   mSegmentLen = aCount;
51215: 
53675:   NS_ABORT_IF_FALSE(!HasError(), "Shouldn't call WriteInternal after error!");
53673: 
51215:   /* Return here if there is a fatal error within libjpeg. */
51215:   nsresult error_code;
51215:   if ((error_code = setjmp(mErr.setjmp_buffer)) != 0) {
51215:     if (error_code == NS_ERROR_FAILURE) {
53662:       PostDataError();
51215:       /* Error due to corrupt stream - return NS_OK and consume silently
51215:          so that libpr0n doesn't throw away a partial image load */
51215:       mState = JPEG_SINK_NON_JPEG_TRAILER;
51215:       PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:              ("} (setjmp returned NS_ERROR_FAILURE)"));
53664:       return;
51215:     } else {
51215:       /* Error due to reasons external to the stream (probably out of
51215:          memory) - let libpr0n attempt to clean up, even though
51215:          mozilla is seconds away from falling flat on its face. */
53662:       PostDecoderError(error_code);
51215:       mState = JPEG_ERROR;
51215:       PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:              ("} (setjmp returned an error)"));
53664:       return;
51215:     }
51215:   }
51215: 
51215:   PR_LOG(gJPEGlog, PR_LOG_DEBUG,
51215:          ("[this=%p] nsJPEGDecoder::Write -- processing JPEG data\n", this));
51215: 
51215:   switch (mState) {
51215:   case JPEG_HEADER:
51215:   {
51215:     LOG_SCOPE(gJPEGlog, "nsJPEGDecoder::Write -- entering JPEG_HEADER case");
51215: 
51215:     /* Step 3: read file parameters with jpeg_read_header() */
51215:     if (jpeg_read_header(&mInfo, TRUE) == JPEG_SUSPENDED) {
51215:       PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:              ("} (JPEG_SUSPENDED)"));
53664:       return; /* I/O suspension */
51215:     }
51215: 
51245:     // Post our size to the superclass
51245:     PostSize(mInfo.image_width, mInfo.image_height);
69680:     if (HasError()) {
69680:       // Setting the size lead to an error; this can happen when for example
69680:       // a multipart channel sends an image of a different size.
69680:       mState = JPEG_ERROR;
69680:       return;
69680:     }
51215: 
51244:     /* If we're doing a size decode, we're done. */
51244:     if (IsSizeDecode())
53664:       return;
51215: 
51215:     /* We're doing a full decode. */
63776:     if (mCMSMode != eCMSMode_Off &&
63776:         (mInProfile = GetICCProfile(mInfo)) != nsnull) {
51215:       PRUint32 profileSpace = qcms_profile_get_color_space(mInProfile);
51215:       PRBool mismatch = PR_FALSE;
51215: 
51215: #ifdef DEBUG_tor
51215:       fprintf(stderr, "JPEG profileSpace: 0x%08X\n", profileSpace);
51215: #endif
51215:       switch (mInfo.jpeg_color_space) {
51215:       case JCS_GRAYSCALE:
51215:         if (profileSpace == icSigRgbData)
51215:           mInfo.out_color_space = JCS_RGB;
51215:         else if (profileSpace != icSigGrayData)
51215:           mismatch = PR_TRUE;
51215:         break;
51215:       case JCS_RGB:
51215:         if (profileSpace != icSigRgbData)
51215:           mismatch =  PR_TRUE;
51215:         break;
51215:       case JCS_YCbCr:
51215:         if (profileSpace == icSigRgbData)
51215:           mInfo.out_color_space = JCS_RGB;
51215:         else
51215: 	  // qcms doesn't support ycbcr
51215:           mismatch = PR_TRUE;
51215:         break;
51215:       case JCS_CMYK:
51215:       case JCS_YCCK:
51215: 	  // qcms doesn't support cmyk
51215:           mismatch = PR_TRUE;
51215:         break;
51215:       default:
51215:         mState = JPEG_ERROR;
53662:         PostDataError();
51215:         PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:                ("} (unknown colorpsace (1))"));
53664:         return;
51215:       }
51215: 
51215:       if (!mismatch) {
51215:         qcms_data_type type;
51215:         switch (mInfo.out_color_space) {
51215:         case JCS_GRAYSCALE:
51215:           type = QCMS_DATA_GRAY_8;
51215:           break;
51215:         case JCS_RGB:
51215:           type = QCMS_DATA_RGB_8;
51215:           break;
51215:         default:
51215:           mState = JPEG_ERROR;
53662:           PostDataError();
51215:           PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:                  ("} (unknown colorpsace (2))"));
53664:           return;
51215:         }
51215: #if 0
51215:         /* We don't currently support CMYK profiles. The following
51215:          * code dealt with lcms types. Add something like this
51215:          * back when we gain support for CMYK.
51215:          */
51215:         /* Adobe Photoshop writes YCCK/CMYK files with inverted data */
51215:         if (mInfo.out_color_space == JCS_CMYK)
51215:           type |= FLAVOR_SH(mInfo.saw_Adobe_marker ? 1 : 0);
51215: #endif
51215: 
51215:         if (gfxPlatform::GetCMSOutputProfile()) {
51215: 
51215:           /* Calculate rendering intent. */
51215:           int intent = gfxPlatform::GetRenderingIntent();
51215:           if (intent == -1)
51215:               intent = qcms_profile_get_rendering_intent(mInProfile);
51215: 
51215:           /* Create the color management transform. */
51215:           mTransform = qcms_transform_create(mInProfile,
51215:                                           type,
51215:                                           gfxPlatform::GetCMSOutputProfile(),
51215:                                           QCMS_DATA_RGB_8,
51215:                                           (qcms_intent)intent);
51215:         }
51215:       } else {
51215: #ifdef DEBUG_tor
51215:         fprintf(stderr, "ICM profile colorspace mismatch\n");
51215: #endif
51215:       }
51215:     }
51215: 
51215:     if (!mTransform) {
51215:       switch (mInfo.jpeg_color_space) {
51215:       case JCS_GRAYSCALE:
51215:       case JCS_RGB:
51215:       case JCS_YCbCr:
51215:         mInfo.out_color_space = JCS_RGB;
51215:         break;
51215:       case JCS_CMYK:
51215:       case JCS_YCCK:
51215:         /* libjpeg can convert from YCCK to CMYK, but not to RGB */
51215:         mInfo.out_color_space = JCS_CMYK;
51215:         break;
51215:       default:
51215:         mState = JPEG_ERROR;
53662:         PostDataError();
51215:         PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:                ("} (unknown colorpsace (3))"));
53664:         return;
51215:         break;
51215:       }
51215:     }
51215: 
51215:     /*
51215:      * Don't allocate a giant and superfluous memory buffer
51215:      * when the image is a sequential JPEG.
51215:      */
51215:     mInfo.buffered_image = jpeg_has_multiple_scans(&mInfo);
51215: 
51215:     /* Used to set up image size so arrays can be allocated */
51215:     jpeg_calc_output_dimensions(&mInfo);
51215: 
51215: 
51215:     // Use EnsureCleanFrame so we don't create a new frame if we're being
51215:     // reused for e.g. multipart/x-replace
51215:     PRUint32 imagelength;
51215:     if (NS_FAILED(mImage->EnsureCleanFrame(0, 0, 0, mInfo.image_width, mInfo.image_height,
51215:                                            gfxASurface::ImageFormatRGB24,
51215:                                            &mImageData, &imagelength))) {
51215:       mState = JPEG_ERROR;
53662:       PostDecoderError(NS_ERROR_OUT_OF_MEMORY);
51215:       PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:              ("} (could not initialize image frame)"));
53664:       return;
51215:     }
51215: 
51215:     PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:            ("        JPEGDecoderAccounting: nsJPEGDecoder::Write -- created image frame with %ux%u pixels",
51215:             mInfo.image_width, mInfo.image_height));
51215: 
51246:     // Tell the superclass we're starting a frame
51246:     PostFrameStart();
51246: 
51215:     mState = JPEG_START_DECOMPRESS;
51215:   }
51215: 
51215:   case JPEG_START_DECOMPRESS:
51215:   {
51215:     LOG_SCOPE(gJPEGlog, "nsJPEGDecoder::Write -- entering JPEG_START_DECOMPRESS case");
51215:     /* Step 4: set parameters for decompression */
51215: 
51215:     /* FIXME -- Should reset dct_method and dither mode
51215:      * for final pass of progressive JPEG
51215:      */
51215:     mInfo.dct_method =  JDCT_ISLOW;
51215:     mInfo.dither_mode = JDITHER_FS;
51215:     mInfo.do_fancy_upsampling = TRUE;
51215:     mInfo.enable_2pass_quant = FALSE;
51215:     mInfo.do_block_smoothing = TRUE;
51215: 
51215:     /* Step 5: Start decompressor */
51215:     if (jpeg_start_decompress(&mInfo) == FALSE) {
51215:       PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:              ("} (I/O suspension after jpeg_start_decompress())"));
53664:       return; /* I/O suspension */
51215:     }
51215: 
51215:     /* Force to use our YCbCr to Packed RGB converter when possible */
60418:     if (!mTransform && (mCMSMode != eCMSMode_All) &&
51215:         mInfo.jpeg_color_space == JCS_YCbCr && mInfo.out_color_space == JCS_RGB) {
51215:       /* Special case for the most common case: transform from YCbCr direct into packed ARGB */
51215:       mInfo.out_color_components = 4; /* Packed ARGB pixels are always 4 bytes...*/
51215:       mInfo.cconvert->color_convert = ycc_rgb_convert_argb;
51215:     }
51215: 
51215:     /* If this is a progressive JPEG ... */
51215:     mState = mInfo.buffered_image ? JPEG_DECOMPRESS_PROGRESSIVE : JPEG_DECOMPRESS_SEQUENTIAL;
51215:   }
51215: 
51215:   case JPEG_DECOMPRESS_SEQUENTIAL:
51215:   {
51215:     if (mState == JPEG_DECOMPRESS_SEQUENTIAL)
51215:     {
51215:       LOG_SCOPE(gJPEGlog, "nsJPEGDecoder::Write -- JPEG_DECOMPRESS_SEQUENTIAL case");
51215:       
51215:       PRBool suspend;
53664:       OutputScanlines(&suspend);
51215:       
51215:       if (suspend) {
51215:         PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:                ("} (I/O suspension after OutputScanlines() - SEQUENTIAL)"));
53664:         return; /* I/O suspension */
51215:       }
51215:       
51215:       /* If we've completed image output ... */
51215:       NS_ASSERTION(mInfo.output_scanline == mInfo.output_height, "We didn't process all of the data!");
51215:       mState = JPEG_DONE;
51215:     }
51215:   }
51215: 
51215:   case JPEG_DECOMPRESS_PROGRESSIVE:
51215:   {
51215:     if (mState == JPEG_DECOMPRESS_PROGRESSIVE)
51215:     {
51215:       LOG_SCOPE(gJPEGlog, "nsJPEGDecoder::Write -- JPEG_DECOMPRESS_PROGRESSIVE case");
51215: 
51215:       int status;
51215:       do {
51215:         status = jpeg_consume_input(&mInfo);
51215:       } while ((status != JPEG_SUSPENDED) &&
51215:                (status != JPEG_REACHED_EOI));
51215: 
51215:       for (;;) {
51215:         if (mInfo.output_scanline == 0) {
51215:           int scan = mInfo.input_scan_number;
51215: 
51215:           /* if we haven't displayed anything yet (output_scan_number==0)
51215:              and we have enough data for a complete scan, force output
51215:              of the last full scan */
51215:           if ((mInfo.output_scan_number == 0) &&
51215:               (scan > 1) &&
51215:               (status != JPEG_REACHED_EOI))
51215:             scan--;
51215: 
51215:           if (!jpeg_start_output(&mInfo, scan)) {
51215:             PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:                    ("} (I/O suspension after jpeg_start_output() - PROGRESSIVE)"));
53664:             return; /* I/O suspension */
51215:           }
51215:         }
51215: 
51215:         if (mInfo.output_scanline == 0xffffff)
51215:           mInfo.output_scanline = 0;
51215: 
51215:         PRBool suspend;
53664:         OutputScanlines(&suspend);
51215: 
51215:         if (suspend) {
51215:           if (mInfo.output_scanline == 0) {
51215:             /* didn't manage to read any lines - flag so we don't call
51215:                jpeg_start_output() multiple times for the same scan */
51215:             mInfo.output_scanline = 0xffffff;
51215:           }
51215:           PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:                  ("} (I/O suspension after OutputScanlines() - PROGRESSIVE)"));
53664:           return; /* I/O suspension */
51215:         }
51215: 
51215:         if (mInfo.output_scanline == mInfo.output_height)
51215:         {
51215:           if (!jpeg_finish_output(&mInfo)) {
51215:             PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:                    ("} (I/O suspension after jpeg_finish_output() - PROGRESSIVE)"));
53664:             return; /* I/O suspension */
51215:           }
51215: 
51215:           if (jpeg_input_complete(&mInfo) &&
51215:               (mInfo.input_scan_number == mInfo.output_scan_number))
51215:             break;
51215: 
51215:           mInfo.output_scanline = 0;
51215:         }
51215:       }
51215: 
51215:       mState = JPEG_DONE;
51215:     }
51215:   }
51215: 
51215:   case JPEG_DONE:
51215:   {
51215:     LOG_SCOPE(gJPEGlog, "nsJPEGDecoder::ProcessData -- entering JPEG_DONE case");
51215: 
51215:     /* Step 7: Finish decompression */
51215: 
51215:     if (jpeg_finish_decompress(&mInfo) == FALSE) {
51215:       PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:              ("} (I/O suspension after jpeg_finish_decompress() - DONE)"));
53664:       return; /* I/O suspension */
51215:     }
51215: 
51215:     mState = JPEG_SINK_NON_JPEG_TRAILER;
51215: 
51215:     /* we're done dude */
51215:     break;
51215:   }
51215:   case JPEG_SINK_NON_JPEG_TRAILER:
51215:     PR_LOG(gJPEGlog, PR_LOG_DEBUG,
51215:            ("[this=%p] nsJPEGDecoder::ProcessData -- entering JPEG_SINK_NON_JPEG_TRAILER case\n", this));
51215: 
51215:     break;
51215: 
51215:   case JPEG_ERROR:
53662:     NS_ABORT_IF_FALSE(0, "Should always return immediately after error and not re-enter decoder");
51215:   }
51215: 
51215:   PR_LOG(gJPEGDecoderAccountingLog, PR_LOG_DEBUG,
51215:          ("} (end of function)"));
53664:   return;
51215: }
51215: 
51215: void
53669: nsJPEGDecoder::NotifyDone()
51215: {
51246:   PostFrameStop();
53669:   PostDecodeDone();
51215: }
51215: 
53664: void
51215: nsJPEGDecoder::OutputScanlines(PRBool* suspend)
51215: {
51215:   *suspend = PR_FALSE;
51215: 
51215:   const PRUint32 top = mInfo.output_scanline;
51215: 
51215:   while ((mInfo.output_scanline < mInfo.output_height)) {
51215:       /* Use the Cairo image buffer as scanline buffer */
51215:       PRUint32 *imageRow = ((PRUint32*)mImageData) +
51215:                            (mInfo.output_scanline * mInfo.output_width);
51215: 
51215:       if (mInfo.cconvert->color_convert == ycc_rgb_convert_argb) {
51215:         /* Special case: scanline will be directly converted into packed ARGB */
51215:         if (jpeg_read_scanlines(&mInfo, (JSAMPARRAY)&imageRow, 1) != 1) {
51215:           *suspend = PR_TRUE; /* suspend */
51215:           break;
51215:         }
51215:         continue; /* all done for this row! */
51215:       }
51215: 
51215:       JSAMPROW sampleRow = (JSAMPROW)imageRow;
51215:       if (mInfo.output_components == 3) {
51215:         /* Put the pixels at end of row to enable in-place expansion */
51215:         sampleRow += mInfo.output_width;
51215:       }
51215: 
51215:       /* Request one scanline.  Returns 0 or 1 scanlines. */    
51215:       if (jpeg_read_scanlines(&mInfo, &sampleRow, 1) != 1) {
51215:         *suspend = PR_TRUE; /* suspend */
51215:         break;
51215:       }
51215: 
51215:       if (mTransform) {
51215:         JSAMPROW source = sampleRow;
51215:         if (mInfo.out_color_space == JCS_GRAYSCALE) {
51215:           /* Convert from the 1byte grey pixels at begin of row 
51215:              to the 3byte RGB byte pixels at 'end' of row */
51215:           sampleRow += mInfo.output_width;
51215:         }
51215:         qcms_transform_data(mTransform, source, sampleRow, mInfo.output_width);
51215:         /* Move 3byte RGB data to end of row */
51215:         if (mInfo.out_color_space == JCS_CMYK) {
51215:           memmove(sampleRow + mInfo.output_width,
51215:                   sampleRow,
51215:                   3 * mInfo.output_width);
51215:           sampleRow += mInfo.output_width;
51215:         }
51215:       } else {
51215:         if (mInfo.out_color_space == JCS_CMYK) {
51215:           /* Convert from CMYK to RGB */
51215:           /* We cannot convert directly to Cairo, as the CMSRGBTransform may wants to do a RGB transform... */
51215:           /* Would be better to have platform CMSenabled transformation from CMYK to (A)RGB... */
51215:           cmyk_convert_rgb((JSAMPROW)imageRow, mInfo.output_width);
51215:           sampleRow += mInfo.output_width;
51215:         }
60418:         if (mCMSMode == eCMSMode_All) {
51215:           /* No embedded ICC profile - treat as sRGB */
51215:           qcms_transform *transform = gfxPlatform::GetCMSRGBTransform();
51215:           if (transform) {
51215:             qcms_transform_data(transform, sampleRow, sampleRow, mInfo.output_width);
51215:           }
51215:         }
51215:       }
51215: 
51215:       // counter for while() loops below
51215:       PRUint32 idx = mInfo.output_width;
51215: 
51215:       // copy as bytes until source pointer is 32-bit-aligned
51215:       for (; (NS_PTR_TO_UINT32(sampleRow) & 0x3) && idx; --idx) {
51215:         *imageRow++ = GFX_PACKED_PIXEL(0xFF, sampleRow[0], sampleRow[1], sampleRow[2]);
51215:         sampleRow += 3;
51215:       }
51215: 
51215:       // copy pixels in blocks of 4
51215:       while (idx >= 4) {
51215:         GFX_BLOCK_RGB_TO_FRGB(sampleRow, imageRow);
51215:         idx       -=  4;
51215:         sampleRow += 12;
51215:         imageRow  +=  4;
51215:       }
51215: 
51215:       // copy remaining pixel(s)
51215:       while (idx--) {
51215:         // 32-bit read of final pixel will exceed buffer, so read bytes
51215:         *imageRow++ = GFX_PACKED_PIXEL(0xFF, sampleRow[0], sampleRow[1], sampleRow[2]);
51215:         sampleRow += 3;
51215:       }
51215:   }
51215: 
51215:   if (top != mInfo.output_scanline) {
51215:       nsIntRect r(0, top, mInfo.output_width, mInfo.output_scanline-top);
51592:       PostInvalidation(r);
51215:   }
51215: 
51215: }
51215: 
51215: 
51215: /* Override the standard error method in the IJG JPEG decoder code. */
51215: METHODDEF(void)
51215: my_error_exit (j_common_ptr cinfo)
51215: {
51215:   decoder_error_mgr *err = (decoder_error_mgr *) cinfo->err;
51215: 
51215:   /* Convert error to a browser error code */
51215:   nsresult error_code = err->pub.msg_code == JERR_OUT_OF_MEMORY
51215:                       ? NS_ERROR_OUT_OF_MEMORY
51215:                       : NS_ERROR_FAILURE;
51215: 
51215: #ifdef DEBUG
51215:   char buffer[JMSG_LENGTH_MAX];
51215: 
51215:   /* Create the message */
51215:   (*err->pub.format_message) (cinfo, buffer);
51215: 
51215:   fprintf(stderr, "JPEG decoding error:\n%s\n", buffer);
51215: #endif
51215: 
51215:   /* Return control to the setjmp point. */
51215:   longjmp(err->setjmp_buffer, error_code);
51215: }
51215: 
51215: /******************************************************************************/
51215: /*-----------------------------------------------------------------------------
51215:  * This is the callback routine from the IJG JPEG library used to supply new
51215:  * data to the decompressor when its input buffer is exhausted.  It juggles
51215:  * multiple buffers in an attempt to avoid unnecessary copying of input data.
51215:  *
51215:  * (A simpler scheme is possible: It's much easier to use only a single
51215:  * buffer; when fill_input_buffer() is called, move any unconsumed data
51215:  * (beyond the current pointer/count) down to the beginning of this buffer and
51215:  * then load new data into the remaining buffer space.  This approach requires
51215:  * a little more data copying but is far easier to get right.)
51215:  *
51215:  * At any one time, the JPEG decompressor is either reading from the necko
51215:  * input buffer, which is volatile across top-level calls to the IJG library,
51215:  * or the "backtrack" buffer.  The backtrack buffer contains the remaining
51215:  * unconsumed data from the necko buffer after parsing was suspended due
51215:  * to insufficient data in some previous call to the IJG library.
51215:  *
51215:  * When suspending, the decompressor will back up to a convenient restart
51215:  * point (typically the start of the current MCU). The variables
51215:  * next_input_byte & bytes_in_buffer indicate where the restart point will be
51215:  * if the current call returns FALSE.  Data beyond this point must be
51215:  * rescanned after resumption, so it must be preserved in case the decompressor
51215:  * decides to backtrack.
51215:  *
51215:  * Returns:
51215:  *  TRUE if additional data is available, FALSE if no data present and
51215:  *   the JPEG library should therefore suspend processing of input stream
51215:  *---------------------------------------------------------------------------*/
51215: 
51215: /******************************************************************************/
51215: /* data source manager method                                                 */
51215: /******************************************************************************/
51215: 
51215: 
51215: /******************************************************************************/
51215: /* data source manager method 
51215:         Initialize source.  This is called by jpeg_read_header() before any
51215:         data is actually read.  May leave
51215:         bytes_in_buffer set to 0 (in which case a fill_input_buffer() call
51215:         will occur immediately).
51215: */
51215: METHODDEF(void)
51215: init_source (j_decompress_ptr jd)
51215: {
51215: }
51215: 
51215: /******************************************************************************/
51215: /* data source manager method
51215:         Skip num_bytes worth of data.  The buffer pointer and count should
51215:         be advanced over num_bytes input bytes, refilling the buffer as
51215:         needed.  This is used to skip over a potentially large amount of
51215:         uninteresting data (such as an APPn marker).  In some applications
51215:         it may be possible to optimize away the reading of the skipped data,
51215:         but it's not clear that being smart is worth much trouble; large
51215:         skips are uncommon.  bytes_in_buffer may be zero on return.
51215:         A zero or negative skip count should be treated as a no-op.
51215: */
51215: METHODDEF(void)
51215: skip_input_data (j_decompress_ptr jd, long num_bytes)
51215: {
51215:   struct jpeg_source_mgr *src = jd->src;
51215:   nsJPEGDecoder *decoder = (nsJPEGDecoder *)(jd->client_data);
51215: 
51215:   if (num_bytes > (long)src->bytes_in_buffer) {
51215:     /*
51215:      * Can't skip it all right now until we get more data from
51215:      * network stream. Set things up so that fill_input_buffer
51215:      * will skip remaining amount.
51215:      */
51215:     decoder->mBytesToSkip = (size_t)num_bytes - src->bytes_in_buffer;
51215:     src->next_input_byte += src->bytes_in_buffer;
51215:     src->bytes_in_buffer = 0;
51215: 
51215:   } else {
51215:     /* Simple case. Just advance buffer pointer */
51215: 
51215:     src->bytes_in_buffer -= (size_t)num_bytes;
51215:     src->next_input_byte += num_bytes;
51215:   }
51215: }
51215: 
51215: 
51215: /******************************************************************************/
51215: /* data source manager method
51215:         This is called whenever bytes_in_buffer has reached zero and more
51215:         data is wanted.  In typical applications, it should read fresh data
51215:         into the buffer (ignoring the current state of next_input_byte and
51215:         bytes_in_buffer), reset the pointer & count to the start of the
51215:         buffer, and return TRUE indicating that the buffer has been reloaded.
51215:         It is not necessary to fill the buffer entirely, only to obtain at
51215:         least one more byte.  bytes_in_buffer MUST be set to a positive value
51215:         if TRUE is returned.  A FALSE return should only be used when I/O
51215:         suspension is desired.
51215: */
51215: METHODDEF(boolean)
51215: fill_input_buffer (j_decompress_ptr jd)
51215: {
51215:   struct jpeg_source_mgr *src = jd->src;
51215:   nsJPEGDecoder *decoder = (nsJPEGDecoder *)(jd->client_data);
51215: 
51215:   if (decoder->mReading) {
51215:     const JOCTET *new_buffer = decoder->mSegment;
51215:     PRUint32 new_buflen = decoder->mSegmentLen;
51215:   
51215:     if (!new_buffer || new_buflen == 0)
51215:       return PR_FALSE; /* suspend */
51215: 
51215:     decoder->mSegmentLen = 0;
51215: 
51215:     if (decoder->mBytesToSkip) {
51215:       if (decoder->mBytesToSkip < new_buflen) {
51215:         /* All done skipping bytes; Return what's left. */
51215:         new_buffer += decoder->mBytesToSkip;
51215:         new_buflen -= decoder->mBytesToSkip;
51215:         decoder->mBytesToSkip = 0;
51215:       } else {
51215:         /* Still need to skip some more data in the future */
51215:         decoder->mBytesToSkip -= (size_t)new_buflen;
51215:         return PR_FALSE; /* suspend */
51215:       }
51215:     }
51215: 
51215:       decoder->mBackBufferUnreadLen = src->bytes_in_buffer;
51215: 
51215:     src->next_input_byte = new_buffer;
51215:     src->bytes_in_buffer = (size_t)new_buflen;
51215:     decoder->mReading = PR_FALSE;
51215: 
51215:     return PR_TRUE;
51215:   }
51215: 
51215:   if (src->next_input_byte != decoder->mSegment) {
51215:     /* Backtrack data has been permanently consumed. */
51215:     decoder->mBackBufferUnreadLen = 0;
51215:     decoder->mBackBufferLen = 0;
51215:   }
51215: 
51215:   /* Save remainder of netlib buffer in backtrack buffer */
51215:   const PRUint32 new_backtrack_buflen = src->bytes_in_buffer + decoder->mBackBufferLen;
51215:  
51215:   /* Make sure backtrack buffer is big enough to hold new data. */
51215:   if (decoder->mBackBufferSize < new_backtrack_buflen) {
51215:     /* Check for malformed MARKER segment lengths, before allocating space for it */
51215:     if (new_backtrack_buflen > MAX_JPEG_MARKER_LENGTH) {
51215:       my_error_exit((j_common_ptr)(&decoder->mInfo));
51215:     }
51215: 
51215:     /* Round up to multiple of 256 bytes. */
51215:     const size_t roundup_buflen = ((new_backtrack_buflen + 255) >> 8) << 8;
51215:     JOCTET *buf = (JOCTET *)PR_REALLOC(decoder->mBackBuffer, roundup_buflen);
51215:     /* Check for OOM */
51215:     if (!buf) {
51215:       decoder->mInfo.err->msg_code = JERR_OUT_OF_MEMORY;
51215:       my_error_exit((j_common_ptr)(&decoder->mInfo));
51215:     }
51215:     decoder->mBackBuffer = buf;
51215:     decoder->mBackBufferSize = roundup_buflen;
51215:   }
51215: 
51215:   /* Copy remainder of netlib segment into backtrack buffer. */
51215:   memmove(decoder->mBackBuffer + decoder->mBackBufferLen,
51215:           src->next_input_byte,
51215:           src->bytes_in_buffer);
51215: 
51215:   /* Point to start of data to be rescanned. */
51215:   src->next_input_byte = decoder->mBackBuffer + decoder->mBackBufferLen - decoder->mBackBufferUnreadLen;
51215:   src->bytes_in_buffer += decoder->mBackBufferUnreadLen;
51215:   decoder->mBackBufferLen = (size_t)new_backtrack_buflen;
51215:   decoder->mReading = PR_TRUE;
51215: 
51215:   return PR_FALSE;
51215: }
51215: 
51215: /******************************************************************************/
51215: /* data source manager method */
51215: /*
51215:  * Terminate source --- called by jpeg_finish_decompress() after all
51215:  * data has been read to clean up JPEG source manager. NOT called by 
51215:  * jpeg_abort() or jpeg_destroy().
51215:  */
51215: METHODDEF(void)
51215: term_source (j_decompress_ptr jd)
51215: {
51215:   nsJPEGDecoder *decoder = (nsJPEGDecoder *)(jd->client_data);
51215: 
51215:   // This function shouldn't be called if we ran into an error we didn't
51215:   // recover from.
51215:   NS_ABORT_IF_FALSE(decoder->mState != JPEG_ERROR,
51215:                     "Calling term_source on a JPEG with mState == JPEG_ERROR!");
51215: 
53669:   // Notify using a helper method to get around protectedness issues.
53669:   decoder->NotifyDone();
51215: }
51215: 
51241: } // namespace imagelib
51241: } // namespace mozilla
51241: 
51215: 
51215: /**************** YCbCr -> Cairo's RGB24/ARGB32 conversion: most common case **************/
51215: 
51215: /*
51215:  * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
51215:  * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
51215:  * The conversion equations to be implemented are therefore
51215:  *      R = Y                + 1.40200 * Cr
51215:  *      G = Y - 0.34414 * Cb - 0.71414 * Cr
51215:  *      B = Y + 1.77200 * Cb
51215:  * where Cb and Cr represent the incoming values less CENTERJSAMPLE.
51215:  * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
51215:  *
51215:  * To avoid floating-point arithmetic, we represent the fractional constants
51215:  * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
51215:  * the products by 2^16, with appropriate rounding, to get the correct answer.
51215:  * Notice that Y, being an integral input, does not contribute any fraction
51215:  * so it need not participate in the rounding.
51215:  *
51215:  * For even more speed, we avoid doing any multiplications in the inner loop
51215:  * by precalculating the constants times Cb and Cr for all possible values.
51215:  * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
51215:  * for 12-bit samples it is still acceptable.  It's not very reasonable for
51215:  * 16-bit samples, but if you want lossless storage you shouldn't be changing
51215:  * colorspace anyway.
51215:  * The Cr=>R and Cb=>B values can be rounded to integers in advance; the
51215:  * values for the G calculation are left scaled up, since we must add them
51215:  * together before rounding.
51215:  */
51215: 
51215: #define SCALEBITS       16      /* speediest right-shift on some machines */
51215: 
51215: /* Use static tables for color processing. */
51215: /* Four tables, each 256 entries of 4 bytes totals 4K which is not bad... */
51215: 
51215: const int Cr_r_tab[(MAXJSAMPLE+1) * sizeof(int)] ={
51215:   0xffffff4dU, 0xffffff4eU, 0xffffff4fU, 0xffffff51U, 0xffffff52U, 0xffffff54U, 
51215:   0xffffff55U, 0xffffff56U, 0xffffff58U, 0xffffff59U, 0xffffff5bU, 0xffffff5cU, 
51215:   0xffffff5dU, 0xffffff5fU, 0xffffff60U, 0xffffff62U, 0xffffff63U, 0xffffff64U, 
51215:   0xffffff66U, 0xffffff67U, 0xffffff69U, 0xffffff6aU, 0xffffff6bU, 0xffffff6dU, 
51215:   0xffffff6eU, 0xffffff70U, 0xffffff71U, 0xffffff72U, 0xffffff74U, 0xffffff75U, 
51215:   0xffffff77U, 0xffffff78U, 0xffffff79U, 0xffffff7bU, 0xffffff7cU, 0xffffff7eU, 
51215:   0xffffff7fU, 0xffffff80U, 0xffffff82U, 0xffffff83U, 0xffffff85U, 0xffffff86U, 
51215:   0xffffff87U, 0xffffff89U, 0xffffff8aU, 0xffffff8cU, 0xffffff8dU, 0xffffff8eU, 
51215:   0xffffff90U, 0xffffff91U, 0xffffff93U, 0xffffff94U, 0xffffff95U, 0xffffff97U, 
51215:   0xffffff98U, 0xffffff9aU, 0xffffff9bU, 0xffffff9cU, 0xffffff9eU, 0xffffff9fU, 
51215:   0xffffffa1U, 0xffffffa2U, 0xffffffa3U, 0xffffffa5U, 0xffffffa6U, 0xffffffa8U, 
51215:   0xffffffa9U, 0xffffffaaU, 0xffffffacU, 0xffffffadU, 0xffffffafU, 0xffffffb0U, 
51215:   0xffffffb1U, 0xffffffb3U, 0xffffffb4U, 0xffffffb6U, 0xffffffb7U, 0xffffffb8U, 
51215:   0xffffffbaU, 0xffffffbbU, 0xffffffbdU, 0xffffffbeU, 0xffffffc0U, 0xffffffc1U, 
51215:   0xffffffc2U, 0xffffffc4U, 0xffffffc5U, 0xffffffc7U, 0xffffffc8U, 0xffffffc9U, 
51215:   0xffffffcbU, 0xffffffccU, 0xffffffceU, 0xffffffcfU, 0xffffffd0U, 0xffffffd2U, 
51215:   0xffffffd3U, 0xffffffd5U, 0xffffffd6U, 0xffffffd7U, 0xffffffd9U, 0xffffffdaU, 
51215:   0xffffffdcU, 0xffffffddU, 0xffffffdeU, 0xffffffe0U, 0xffffffe1U, 0xffffffe3U, 
51215:   0xffffffe4U, 0xffffffe5U, 0xffffffe7U, 0xffffffe8U, 0xffffffeaU, 0xffffffebU, 
51215:   0xffffffecU, 0xffffffeeU, 0xffffffefU, 0xfffffff1U, 0xfffffff2U, 0xfffffff3U, 
51215:   0xfffffff5U, 0xfffffff6U, 0xfffffff8U, 0xfffffff9U, 0xfffffffaU, 0xfffffffcU, 
51215:   0xfffffffdU, 0xffffffffU,       0x00U,       0x01U,       0x03U,       0x04U, 
51215:         0x06U,       0x07U,       0x08U,       0x0aU,       0x0bU,       0x0dU, 
51215:         0x0eU,       0x0fU,       0x11U,       0x12U,       0x14U,       0x15U, 
51215:         0x16U,       0x18U,       0x19U,       0x1bU,       0x1cU,       0x1dU, 
51215:         0x1fU,       0x20U,       0x22U,       0x23U,       0x24U,       0x26U, 
51215:         0x27U,       0x29U,       0x2aU,       0x2bU,       0x2dU,       0x2eU, 
51215:         0x30U,       0x31U,       0x32U,       0x34U,       0x35U,       0x37U, 
51215:         0x38U,       0x39U,       0x3bU,       0x3cU,       0x3eU,       0x3fU, 
51215:         0x40U,       0x42U,       0x43U,       0x45U,       0x46U,       0x48U, 
51215:         0x49U,       0x4aU,       0x4cU,       0x4dU,       0x4fU,       0x50U, 
51215:         0x51U,       0x53U,       0x54U,       0x56U,       0x57U,       0x58U, 
51215:         0x5aU,       0x5bU,       0x5dU,       0x5eU,       0x5fU,       0x61U, 
51215:         0x62U,       0x64U,       0x65U,       0x66U,       0x68U,       0x69U, 
51215:         0x6bU,       0x6cU,       0x6dU,       0x6fU,       0x70U,       0x72U, 
51215:         0x73U,       0x74U,       0x76U,       0x77U,       0x79U,       0x7aU, 
51215:         0x7bU,       0x7dU,       0x7eU,       0x80U,       0x81U,       0x82U, 
51215:         0x84U,       0x85U,       0x87U,       0x88U,       0x89U,       0x8bU, 
51215:         0x8cU,       0x8eU,       0x8fU,       0x90U,       0x92U,       0x93U, 
51215:         0x95U,       0x96U,       0x97U,       0x99U,       0x9aU,       0x9cU, 
51215:         0x9dU,       0x9eU,       0xa0U,       0xa1U,       0xa3U,       0xa4U, 
51215:         0xa5U,       0xa7U,       0xa8U,       0xaaU,       0xabU,       0xacU, 
51215:         0xaeU,       0xafU,       0xb1U,       0xb2U
51215:   };
51215: 
51215: const int Cb_b_tab[(MAXJSAMPLE+1) * sizeof(int)] ={
51215:   0xffffff1dU, 0xffffff1fU, 0xffffff21U, 0xffffff22U, 0xffffff24U, 0xffffff26U, 
51215:   0xffffff28U, 0xffffff2aU, 0xffffff2bU, 0xffffff2dU, 0xffffff2fU, 0xffffff31U, 
51215:   0xffffff32U, 0xffffff34U, 0xffffff36U, 0xffffff38U, 0xffffff3aU, 0xffffff3bU, 
51215:   0xffffff3dU, 0xffffff3fU, 0xffffff41U, 0xffffff42U, 0xffffff44U, 0xffffff46U, 
51215:   0xffffff48U, 0xffffff49U, 0xffffff4bU, 0xffffff4dU, 0xffffff4fU, 0xffffff51U, 
51215:   0xffffff52U, 0xffffff54U, 0xffffff56U, 0xffffff58U, 0xffffff59U, 0xffffff5bU, 
51215:   0xffffff5dU, 0xffffff5fU, 0xffffff61U, 0xffffff62U, 0xffffff64U, 0xffffff66U, 
51215:   0xffffff68U, 0xffffff69U, 0xffffff6bU, 0xffffff6dU, 0xffffff6fU, 0xffffff70U, 
51215:   0xffffff72U, 0xffffff74U, 0xffffff76U, 0xffffff78U, 0xffffff79U, 0xffffff7bU, 
51215:   0xffffff7dU, 0xffffff7fU, 0xffffff80U, 0xffffff82U, 0xffffff84U, 0xffffff86U, 
51215:   0xffffff88U, 0xffffff89U, 0xffffff8bU, 0xffffff8dU, 0xffffff8fU, 0xffffff90U, 
51215:   0xffffff92U, 0xffffff94U, 0xffffff96U, 0xffffff97U, 0xffffff99U, 0xffffff9bU, 
51215:   0xffffff9dU, 0xffffff9fU, 0xffffffa0U, 0xffffffa2U, 0xffffffa4U, 0xffffffa6U, 
51215:   0xffffffa7U, 0xffffffa9U, 0xffffffabU, 0xffffffadU, 0xffffffaeU, 0xffffffb0U, 
51215:   0xffffffb2U, 0xffffffb4U, 0xffffffb6U, 0xffffffb7U, 0xffffffb9U, 0xffffffbbU, 
51215:   0xffffffbdU, 0xffffffbeU, 0xffffffc0U, 0xffffffc2U, 0xffffffc4U, 0xffffffc6U, 
51215:   0xffffffc7U, 0xffffffc9U, 0xffffffcbU, 0xffffffcdU, 0xffffffceU, 0xffffffd0U, 
51215:   0xffffffd2U, 0xffffffd4U, 0xffffffd5U, 0xffffffd7U, 0xffffffd9U, 0xffffffdbU, 
51215:   0xffffffddU, 0xffffffdeU, 0xffffffe0U, 0xffffffe2U, 0xffffffe4U, 0xffffffe5U, 
51215:   0xffffffe7U, 0xffffffe9U, 0xffffffebU, 0xffffffedU, 0xffffffeeU, 0xfffffff0U, 
51215:   0xfffffff2U, 0xfffffff4U, 0xfffffff5U, 0xfffffff7U, 0xfffffff9U, 0xfffffffbU, 
51215:   0xfffffffcU, 0xfffffffeU,       0x00U,       0x02U,       0x04U,       0x05U, 
51215:         0x07U,       0x09U,       0x0bU,       0x0cU,       0x0eU,       0x10U, 
51215:         0x12U,       0x13U,       0x15U,       0x17U,       0x19U,       0x1bU, 
51215:         0x1cU,       0x1eU,       0x20U,       0x22U,       0x23U,       0x25U, 
51215:         0x27U,       0x29U,       0x2bU,       0x2cU,       0x2eU,       0x30U, 
51215:         0x32U,       0x33U,       0x35U,       0x37U,       0x39U,       0x3aU, 
51215:         0x3cU,       0x3eU,       0x40U,       0x42U,       0x43U,       0x45U, 
51215:         0x47U,       0x49U,       0x4aU,       0x4cU,       0x4eU,       0x50U, 
51215:         0x52U,       0x53U,       0x55U,       0x57U,       0x59U,       0x5aU, 
51215:         0x5cU,       0x5eU,       0x60U,       0x61U,       0x63U,       0x65U, 
51215:         0x67U,       0x69U,       0x6aU,       0x6cU,       0x6eU,       0x70U, 
51215:         0x71U,       0x73U,       0x75U,       0x77U,       0x78U,       0x7aU, 
51215:         0x7cU,       0x7eU,       0x80U,       0x81U,       0x83U,       0x85U, 
51215:         0x87U,       0x88U,       0x8aU,       0x8cU,       0x8eU,       0x90U, 
51215:         0x91U,       0x93U,       0x95U,       0x97U,       0x98U,       0x9aU, 
51215:         0x9cU,       0x9eU,       0x9fU,       0xa1U,       0xa3U,       0xa5U, 
51215:         0xa7U,       0xa8U,       0xaaU,       0xacU,       0xaeU,       0xafU, 
51215:         0xb1U,       0xb3U,       0xb5U,       0xb7U,       0xb8U,       0xbaU, 
51215:         0xbcU,       0xbeU,       0xbfU,       0xc1U,       0xc3U,       0xc5U, 
51215:         0xc6U,       0xc8U,       0xcaU,       0xccU,       0xceU,       0xcfU, 
51215:         0xd1U,       0xd3U,       0xd5U,       0xd6U,       0xd8U,       0xdaU, 
51215:         0xdcU,       0xdeU,       0xdfU,       0xe1U
51215:   };
51215: 
51215: const int Cr_g_tab[(MAXJSAMPLE+1) * sizeof(int)] ={
51215:     0x5b6900U,   0x5ab22eU,   0x59fb5cU,   0x59448aU,   0x588db8U,   0x57d6e6U, 
51215:     0x572014U,   0x566942U,   0x55b270U,   0x54fb9eU,   0x5444ccU,   0x538dfaU, 
51215:     0x52d728U,   0x522056U,   0x516984U,   0x50b2b2U,   0x4ffbe0U,   0x4f450eU, 
51215:     0x4e8e3cU,   0x4dd76aU,   0x4d2098U,   0x4c69c6U,   0x4bb2f4U,   0x4afc22U, 
51215:     0x4a4550U,   0x498e7eU,   0x48d7acU,   0x4820daU,   0x476a08U,   0x46b336U, 
51215:     0x45fc64U,   0x454592U,   0x448ec0U,   0x43d7eeU,   0x43211cU,   0x426a4aU, 
51215:     0x41b378U,   0x40fca6U,   0x4045d4U,   0x3f8f02U,   0x3ed830U,   0x3e215eU, 
51215:     0x3d6a8cU,   0x3cb3baU,   0x3bfce8U,   0x3b4616U,   0x3a8f44U,   0x39d872U, 
51215:     0x3921a0U,   0x386aceU,   0x37b3fcU,   0x36fd2aU,   0x364658U,   0x358f86U, 
51215:     0x34d8b4U,   0x3421e2U,   0x336b10U,   0x32b43eU,   0x31fd6cU,   0x31469aU, 
51215:     0x308fc8U,   0x2fd8f6U,   0x2f2224U,   0x2e6b52U,   0x2db480U,   0x2cfdaeU, 
51215:     0x2c46dcU,   0x2b900aU,   0x2ad938U,   0x2a2266U,   0x296b94U,   0x28b4c2U, 
51215:     0x27fdf0U,   0x27471eU,   0x26904cU,   0x25d97aU,   0x2522a8U,   0x246bd6U, 
51215:     0x23b504U,   0x22fe32U,   0x224760U,   0x21908eU,   0x20d9bcU,   0x2022eaU, 
51215:     0x1f6c18U,   0x1eb546U,   0x1dfe74U,   0x1d47a2U,   0x1c90d0U,   0x1bd9feU, 
51215:     0x1b232cU,   0x1a6c5aU,   0x19b588U,   0x18feb6U,   0x1847e4U,   0x179112U, 
51215:     0x16da40U,   0x16236eU,   0x156c9cU,   0x14b5caU,   0x13fef8U,   0x134826U, 
51215:     0x129154U,   0x11da82U,   0x1123b0U,   0x106cdeU,    0xfb60cU,    0xeff3aU, 
51215:      0xe4868U,    0xd9196U,    0xcdac4U,    0xc23f2U,    0xb6d20U,    0xab64eU, 
51215:      0x9ff7cU,    0x948aaU,    0x891d8U,    0x7db06U,    0x72434U,    0x66d62U, 
51215:      0x5b690U,    0x4ffbeU,    0x448ecU,    0x3921aU,    0x2db48U,    0x22476U, 
51215:      0x16da4U,     0xb6d2U,        0x0U, 0xffff492eU, 0xfffe925cU, 0xfffddb8aU, 
51215:   0xfffd24b8U, 0xfffc6de6U, 0xfffbb714U, 0xfffb0042U, 0xfffa4970U, 0xfff9929eU, 
51215:   0xfff8dbccU, 0xfff824faU, 0xfff76e28U, 0xfff6b756U, 0xfff60084U, 0xfff549b2U, 
51215:   0xfff492e0U, 0xfff3dc0eU, 0xfff3253cU, 0xfff26e6aU, 0xfff1b798U, 0xfff100c6U, 
51215:   0xfff049f4U, 0xffef9322U, 0xffeedc50U, 0xffee257eU, 0xffed6eacU, 0xffecb7daU, 
51215:   0xffec0108U, 0xffeb4a36U, 0xffea9364U, 0xffe9dc92U, 0xffe925c0U, 0xffe86eeeU, 
51215:   0xffe7b81cU, 0xffe7014aU, 0xffe64a78U, 0xffe593a6U, 0xffe4dcd4U, 0xffe42602U, 
51215:   0xffe36f30U, 0xffe2b85eU, 0xffe2018cU, 0xffe14abaU, 0xffe093e8U, 0xffdfdd16U, 
51215:   0xffdf2644U, 0xffde6f72U, 0xffddb8a0U, 0xffdd01ceU, 0xffdc4afcU, 0xffdb942aU, 
51215:   0xffdadd58U, 0xffda2686U, 0xffd96fb4U, 0xffd8b8e2U, 0xffd80210U, 0xffd74b3eU, 
51215:   0xffd6946cU, 0xffd5dd9aU, 0xffd526c8U, 0xffd46ff6U, 0xffd3b924U, 0xffd30252U, 
51215:   0xffd24b80U, 0xffd194aeU, 0xffd0dddcU, 0xffd0270aU, 0xffcf7038U, 0xffceb966U, 
51215:   0xffce0294U, 0xffcd4bc2U, 0xffcc94f0U, 0xffcbde1eU, 0xffcb274cU, 0xffca707aU, 
51215:   0xffc9b9a8U, 0xffc902d6U, 0xffc84c04U, 0xffc79532U, 0xffc6de60U, 0xffc6278eU, 
51215:   0xffc570bcU, 0xffc4b9eaU, 0xffc40318U, 0xffc34c46U, 0xffc29574U, 0xffc1dea2U, 
51215:   0xffc127d0U, 0xffc070feU, 0xffbfba2cU, 0xffbf035aU, 0xffbe4c88U, 0xffbd95b6U, 
51215:   0xffbcdee4U, 0xffbc2812U, 0xffbb7140U, 0xffbaba6eU, 0xffba039cU, 0xffb94ccaU, 
51215:   0xffb895f8U, 0xffb7df26U, 0xffb72854U, 0xffb67182U, 0xffb5bab0U, 0xffb503deU, 
51215:   0xffb44d0cU, 0xffb3963aU, 0xffb2df68U, 0xffb22896U, 0xffb171c4U, 0xffb0baf2U, 
51215:   0xffb00420U, 0xffaf4d4eU, 0xffae967cU, 0xffaddfaaU, 0xffad28d8U, 0xffac7206U, 
51215:   0xffabbb34U, 0xffab0462U, 0xffaa4d90U, 0xffa996beU, 0xffa8dfecU, 0xffa8291aU, 
51215:   0xffa77248U, 0xffa6bb76U, 0xffa604a4U, 0xffa54dd2U
51215:  };
51215: 
51215: const int Cb_g_tab[(MAXJSAMPLE+1) * sizeof(int)] ={
51215:     0x2c8d00U,   0x2c34e6U,   0x2bdcccU,   0x2b84b2U,   0x2b2c98U,   0x2ad47eU, 
51215:     0x2a7c64U,   0x2a244aU,   0x29cc30U,   0x297416U,   0x291bfcU,   0x28c3e2U, 
51215:     0x286bc8U,   0x2813aeU,   0x27bb94U,   0x27637aU,   0x270b60U,   0x26b346U, 
51215:     0x265b2cU,   0x260312U,   0x25aaf8U,   0x2552deU,   0x24fac4U,   0x24a2aaU, 
51215:     0x244a90U,   0x23f276U,   0x239a5cU,   0x234242U,   0x22ea28U,   0x22920eU, 
51215:     0x2239f4U,   0x21e1daU,   0x2189c0U,   0x2131a6U,   0x20d98cU,   0x208172U, 
51215:     0x202958U,   0x1fd13eU,   0x1f7924U,   0x1f210aU,   0x1ec8f0U,   0x1e70d6U, 
51215:     0x1e18bcU,   0x1dc0a2U,   0x1d6888U,   0x1d106eU,   0x1cb854U,   0x1c603aU, 
51215:     0x1c0820U,   0x1bb006U,   0x1b57ecU,   0x1affd2U,   0x1aa7b8U,   0x1a4f9eU, 
51215:     0x19f784U,   0x199f6aU,   0x194750U,   0x18ef36U,   0x18971cU,   0x183f02U, 
51215:     0x17e6e8U,   0x178eceU,   0x1736b4U,   0x16de9aU,   0x168680U,   0x162e66U, 
51215:     0x15d64cU,   0x157e32U,   0x152618U,   0x14cdfeU,   0x1475e4U,   0x141dcaU, 
51215:     0x13c5b0U,   0x136d96U,   0x13157cU,   0x12bd62U,   0x126548U,   0x120d2eU, 
51215:     0x11b514U,   0x115cfaU,   0x1104e0U,   0x10acc6U,   0x1054acU,    0xffc92U, 
51215:      0xfa478U,    0xf4c5eU,    0xef444U,    0xe9c2aU,    0xe4410U,    0xdebf6U, 
51215:      0xd93dcU,    0xd3bc2U,    0xce3a8U,    0xc8b8eU,    0xc3374U,    0xbdb5aU, 
51215:      0xb8340U,    0xb2b26U,    0xad30cU,    0xa7af2U,    0xa22d8U,    0x9cabeU, 
51215:      0x972a4U,    0x91a8aU,    0x8c270U,    0x86a56U,    0x8123cU,    0x7ba22U, 
51215:      0x76208U,    0x709eeU,    0x6b1d4U,    0x659baU,    0x601a0U,    0x5a986U, 
51215:      0x5516cU,    0x4f952U,    0x4a138U,    0x4491eU,    0x3f104U,    0x398eaU, 
51215:      0x340d0U,    0x2e8b6U,    0x2909cU,    0x23882U,    0x1e068U,    0x1884eU, 
51215:      0x13034U,     0xd81aU,     0x8000U,     0x27e6U, 0xffffcfccU, 0xffff77b2U,
51215:   0xffff1f98U, 0xfffec77eU, 0xfffe6f64U, 0xfffe174aU, 0xfffdbf30U, 0xfffd6716U,
51215:   0xfffd0efcU, 0xfffcb6e2U, 0xfffc5ec8U, 0xfffc06aeU, 0xfffbae94U, 0xfffb567aU,
51215:   0xfffafe60U, 0xfffaa646U, 0xfffa4e2cU, 0xfff9f612U, 0xfff99df8U, 0xfff945deU,
51215:   0xfff8edc4U, 0xfff895aaU, 0xfff83d90U, 0xfff7e576U, 0xfff78d5cU, 0xfff73542U,
51215:   0xfff6dd28U, 0xfff6850eU, 0xfff62cf4U, 0xfff5d4daU, 0xfff57cc0U, 0xfff524a6U,
51215:   0xfff4cc8cU, 0xfff47472U, 0xfff41c58U, 0xfff3c43eU, 0xfff36c24U, 0xfff3140aU,
51215:   0xfff2bbf0U, 0xfff263d6U, 0xfff20bbcU, 0xfff1b3a2U, 0xfff15b88U, 0xfff1036eU,
51215:   0xfff0ab54U, 0xfff0533aU, 0xffeffb20U, 0xffefa306U, 0xffef4aecU, 0xffeef2d2U,
51215:   0xffee9ab8U, 0xffee429eU, 0xffedea84U, 0xffed926aU, 0xffed3a50U, 0xffece236U,
51215:   0xffec8a1cU, 0xffec3202U, 0xffebd9e8U, 0xffeb81ceU, 0xffeb29b4U, 0xffead19aU,
51215:   0xffea7980U, 0xffea2166U, 0xffe9c94cU, 0xffe97132U, 0xffe91918U, 0xffe8c0feU,
51215:   0xffe868e4U, 0xffe810caU, 0xffe7b8b0U, 0xffe76096U, 0xffe7087cU, 0xffe6b062U,
51215:   0xffe65848U, 0xffe6002eU, 0xffe5a814U, 0xffe54ffaU, 0xffe4f7e0U, 0xffe49fc6U,
51215:   0xffe447acU, 0xffe3ef92U, 0xffe39778U, 0xffe33f5eU, 0xffe2e744U, 0xffe28f2aU,
51215:   0xffe23710U, 0xffe1def6U, 0xffe186dcU, 0xffe12ec2U, 0xffe0d6a8U, 0xffe07e8eU,
51215:   0xffe02674U, 0xffdfce5aU, 0xffdf7640U, 0xffdf1e26U, 0xffdec60cU, 0xffde6df2U,
51215:   0xffde15d8U, 0xffddbdbeU, 0xffdd65a4U, 0xffdd0d8aU, 0xffdcb570U, 0xffdc5d56U,
51215:   0xffdc053cU, 0xffdbad22U, 0xffdb5508U, 0xffdafceeU, 0xffdaa4d4U, 0xffda4cbaU,
51215:   0xffd9f4a0U, 0xffd99c86U, 0xffd9446cU, 0xffd8ec52U, 0xffd89438U, 0xffd83c1eU,
51215:   0xffd7e404U, 0xffd78beaU, 0xffd733d0U, 0xffd6dbb6U, 0xffd6839cU, 0xffd62b82U,
51215:   0xffd5d368U, 0xffd57b4eU, 0xffd52334U, 0xffd4cb1aU
51215:  };
51215: 
51215: 
51215: /* We assume that right shift corresponds to signed division by 2 with
51215:  * rounding towards minus infinity.  This is correct for typical "arithmetic
51215:  * shift" instructions that shift in copies of the sign bit.  But some
51215:  * C compilers implement >> with an unsigned shift.  For these machines you
51215:  * must define RIGHT_SHIFT_IS_UNSIGNED.
51215:  * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
51215:  * It is only applied with constant shift counts.  SHIFT_TEMPS must be
51215:  * included in the variables of any routine using RIGHT_SHIFT.
51215:  */
51215: 
51215: #ifdef RIGHT_SHIFT_IS_UNSIGNED
51215: #define SHIFT_TEMPS	INT32 shift_temp;
51215: #define RIGHT_SHIFT(x,shft)  \
51215: 	((shift_temp = (x)) < 0 ? \
51215: 	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
51215: 	 (shift_temp >> (shft)))
51215: #else
51215: #define SHIFT_TEMPS
51215: #define RIGHT_SHIFT(x,shft)	((x) >> (shft))
51215: #endif
51215: 
51215: 
51215: METHODDEF(void)
51215: ycc_rgb_convert_argb (j_decompress_ptr cinfo,
51215:                  JSAMPIMAGE input_buf, JDIMENSION input_row,
51215:                  JSAMPARRAY output_buf, int num_rows)
51215: {
51215:   JDIMENSION num_cols = cinfo->output_width;
51215:   JSAMPLE * range_limit = cinfo->sample_range_limit;
51215: 
51215:   SHIFT_TEMPS
51215: 
51215:   /* This is used if we don't have SSE2 */
51215: 
51215:   while (--num_rows >= 0) {
51215:     JSAMPROW inptr0 = input_buf[0][input_row];
51215:     JSAMPROW inptr1 = input_buf[1][input_row];
51215:     JSAMPROW inptr2 = input_buf[2][input_row];
51215:     input_row++;
51215:     PRUint32 *outptr = (PRUint32 *) *output_buf++;
51215:     for (JDIMENSION col = 0; col < num_cols; col++) {
51215:       int y  = GETJSAMPLE(inptr0[col]);
51215:       int cb = GETJSAMPLE(inptr1[col]);
51215:       int cr = GETJSAMPLE(inptr2[col]);
51215:       JSAMPLE * range_limit_y = range_limit + y;
51215:       /* Range-limiting is essential due to noise introduced by DCT losses. */
51215:       outptr[col] = 0xFF000000 |
51215:                     ( range_limit_y[Cr_r_tab[cr]] << 16 ) |
51215:                     ( range_limit_y[((int) RIGHT_SHIFT(Cb_g_tab[cb] + Cr_g_tab[cr], SCALEBITS))] << 8 ) |
51215:                     ( range_limit_y[Cb_b_tab[cb]] );
51215:     }
51215:   }
51215: }
51215: 
51215: 
51215: /**************** Inverted CMYK -> RGB conversion **************/
51215: /*
51215:  * Input is (Inverted) CMYK stored as 4 bytes per pixel.
51215:  * Output is RGB stored as 3 bytes per pixel.
51215:  * @param row Points to row buffer containing the CMYK bytes for each pixel in the row.
51215:  * @param width Number of pixels in the row.
51215:  */
51215: static void cmyk_convert_rgb(JSAMPROW row, JDIMENSION width)
51215: {
51215:   /* Work from end to front to shrink from 4 bytes per pixel to 3 */
51215:   JSAMPROW in = row + width*4;
51215:   JSAMPROW out = in;
51215: 
51215:   for (PRUint32 i = width; i > 0; i--) {
51215:     in -= 4;
51215:     out -= 3;
51215: 
51215:     // Source is 'Inverted CMYK', output is RGB.
51215:     // See: http://www.easyrgb.com/math.php?MATH=M12#text12
51215:     // Or:  http://www.ilkeratalay.com/colorspacesfaq.php#rgb
51215: 
51215:     // From CMYK to CMY
51215:     // C = ( C * ( 1 - K ) + K )
51215:     // M = ( M * ( 1 - K ) + K )
51215:     // Y = ( Y * ( 1 - K ) + K )
51215: 
51215:     // From Inverted CMYK to CMY is thus:
51215:     // C = ( (1-iC) * (1 - (1-iK)) + (1-iK) ) => 1 - iC*iK
51215:     // Same for M and Y
51215: 
51215:     // Convert from CMY (0..1) to RGB (0..1)
51215:     // R = 1 - C => 1 - (1 - iC*iK) => iC*iK
51215:     // G = 1 - M => 1 - (1 - iM*iK) => iM*iK
51215:     // B = 1 - Y => 1 - (1 - iY*iK) => iY*iK
51215:   
51215:     // Convert from Inverted CMYK (0..255) to RGB (0..255)
51215:     const PRUint32 iC = in[0];
51215:     const PRUint32 iM = in[1];
51215:     const PRUint32 iY = in[2];
51215:     const PRUint32 iK = in[3];
51215:     out[0] = iC*iK/255;   // Red
51215:     out[1] = iM*iK/255;   // Green
51215:     out[2] = iY*iK/255;   // Blue
51215:   }
51215: }
