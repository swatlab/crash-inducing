16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: floor backend 1 implementation
31034:  last mod: $Id: floor1.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: #include <stdlib.h>
16295: #include <string.h>
16295: #include <math.h>
16295: #include <ogg/ogg.h>
16295: #include "vorbis/codec.h"
16295: #include "codec_internal.h"
16295: #include "registry.h"
16295: #include "codebook.h"
16295: #include "misc.h"
16295: #include "scales.h"
16295: 
16295: #include <stdio.h>
16295: 
16295: #define floor1_rangedB 140 /* floor 1 fixed at -140dB to 0dB range */
16295: 
16295: typedef struct lsfit_acc{
16295:   long x0;
16295:   long x1;
16295: 
16295:   long xa;
16295:   long ya;
16295:   long x2a;
16295:   long y2a;
16295:   long xya;
16295:   long an;
16295: } lsfit_acc;
16295: 
16295: /***********************************************/
16295: 
16295: static void floor1_free_info(vorbis_info_floor *i){
16295:   vorbis_info_floor1 *info=(vorbis_info_floor1 *)i;
16295:   if(info){
16295:     memset(info,0,sizeof(*info));
16295:     _ogg_free(info);
16295:   }
16295: }
16295: 
16295: static void floor1_free_look(vorbis_look_floor *i){
16295:   vorbis_look_floor1 *look=(vorbis_look_floor1 *)i;
16295:   if(look){
16295:     /*fprintf(stderr,"floor 1 bit usage %f:%f (%f total)\n",
16295:             (float)look->phrasebits/look->frames,
16295:             (float)look->postbits/look->frames,
16295:             (float)(look->postbits+look->phrasebits)/look->frames);*/
16295: 
16295:     memset(look,0,sizeof(*look));
16295:     _ogg_free(look);
16295:   }
16295: }
16295: 
16295: static int ilog(unsigned int v){
16295:   int ret=0;
16295:   while(v){
16295:     ret++;
16295:     v>>=1;
16295:   }
16295:   return(ret);
16295: }
16295: 
16295: static int ilog2(unsigned int v){
16295:   int ret=0;
16295:   if(v)--v;
16295:   while(v){
16295:     ret++;
16295:     v>>=1;
16295:   }
16295:   return(ret);
16295: }
16295: 
16295: static void floor1_pack (vorbis_info_floor *i,oggpack_buffer *opb){
16295:   vorbis_info_floor1 *info=(vorbis_info_floor1 *)i;
16295:   int j,k;
16295:   int count=0;
16295:   int rangebits;
16295:   int maxposit=info->postlist[1];
16295:   int maxclass=-1;
16295: 
16295:   /* save out partitions */
16295:   oggpack_write(opb,info->partitions,5); /* only 0 to 31 legal */
16295:   for(j=0;j<info->partitions;j++){
16295:     oggpack_write(opb,info->partitionclass[j],4); /* only 0 to 15 legal */
16295:     if(maxclass<info->partitionclass[j])maxclass=info->partitionclass[j];
16295:   }
16295: 
16295:   /* save out partition classes */
16295:   for(j=0;j<maxclass+1;j++){
16295:     oggpack_write(opb,info->class_dim[j]-1,3); /* 1 to 8 */
16295:     oggpack_write(opb,info->class_subs[j],2); /* 0 to 3 */
16295:     if(info->class_subs[j])oggpack_write(opb,info->class_book[j],8);
16295:     for(k=0;k<(1<<info->class_subs[j]);k++)
16295:       oggpack_write(opb,info->class_subbook[j][k]+1,8);
16295:   }
16295: 
16295:   /* save out the post list */
16295:   oggpack_write(opb,info->mult-1,2);     /* only 1,2,3,4 legal now */
16295:   oggpack_write(opb,ilog2(maxposit),4);
16295:   rangebits=ilog2(maxposit);
16295: 
16295:   for(j=0,k=0;j<info->partitions;j++){
16295:     count+=info->class_dim[info->partitionclass[j]];
16295:     for(;k<count;k++)
16295:       oggpack_write(opb,info->postlist[k+2],rangebits);
16295:   }
16295: }
16295: 
30043: static int icomp(const void *a,const void *b){
30043:   return(**(int **)a-**(int **)b);
30043: }
16295: 
16295: static vorbis_info_floor *floor1_unpack (vorbis_info *vi,oggpack_buffer *opb){
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   int j,k,count=0,maxclass=-1,rangebits;
16295: 
16295:   vorbis_info_floor1 *info=_ogg_calloc(1,sizeof(*info));
16295:   /* read partitions */
16295:   info->partitions=oggpack_read(opb,5); /* only 0 to 31 legal */
16295:   for(j=0;j<info->partitions;j++){
16295:     info->partitionclass[j]=oggpack_read(opb,4); /* only 0 to 15 legal */
31034:     if(info->partitionclass[j]<0)goto err_out;
16295:     if(maxclass<info->partitionclass[j])maxclass=info->partitionclass[j];
16295:   }
16295: 
16295:   /* read partition classes */
16295:   for(j=0;j<maxclass+1;j++){
16295:     info->class_dim[j]=oggpack_read(opb,3)+1; /* 1 to 8 */
16295:     info->class_subs[j]=oggpack_read(opb,2); /* 0,1,2,3 bits */
16295:     if(info->class_subs[j]<0)
16295:       goto err_out;
16295:     if(info->class_subs[j])info->class_book[j]=oggpack_read(opb,8);
16295:     if(info->class_book[j]<0 || info->class_book[j]>=ci->books)
16295:       goto err_out;
16295:     for(k=0;k<(1<<info->class_subs[j]);k++){
16295:       info->class_subbook[j][k]=oggpack_read(opb,8)-1;
16295:       if(info->class_subbook[j][k]<-1 || info->class_subbook[j][k]>=ci->books)
16295:         goto err_out;
16295:     }
16295:   }
16295: 
16295:   /* read the post list */
16295:   info->mult=oggpack_read(opb,2)+1;     /* only 1,2,3,4 legal now */
16295:   rangebits=oggpack_read(opb,4);
31034:   if(rangebits<0)goto err_out;
16295: 
16295:   for(j=0,k=0;j<info->partitions;j++){
16295:     count+=info->class_dim[info->partitionclass[j]];
16295:     for(;k<count;k++){
16295:       int t=info->postlist[k+2]=oggpack_read(opb,rangebits);
16295:       if(t<0 || t>=(1<<rangebits))
16295:         goto err_out;
16295:     }
16295:   }
16295:   info->postlist[0]=0;
16295:   info->postlist[1]=1<<rangebits;
16295: 
30043:   /* don't allow repeated values in post list as they'd result in
30043:      zero-length segments */
30043:   {
30043:     int *sortpointer[VIF_POSIT+2];
30043:     for(j=0;j<count+2;j++)sortpointer[j]=info->postlist+j;
30043:     qsort(sortpointer,count+2,sizeof(*sortpointer),icomp);
30043: 
30043:     for(j=1;j<count+2;j++)
30043:       if(*sortpointer[j-1]==*sortpointer[j])goto err_out;
30043:   }
30043: 
16295:   return(info);
16295: 
16295:  err_out:
16295:   floor1_free_info(info);
16295:   return(NULL);
16295: }
16295: 
16295: static vorbis_look_floor *floor1_look(vorbis_dsp_state *vd,
16295:                                       vorbis_info_floor *in){
16295: 
16295:   int *sortpointer[VIF_POSIT+2];
16295:   vorbis_info_floor1 *info=(vorbis_info_floor1 *)in;
16295:   vorbis_look_floor1 *look=_ogg_calloc(1,sizeof(*look));
16295:   int i,j,n=0;
16295: 
16295:   look->vi=info;
16295:   look->n=info->postlist[1];
16295: 
16295:   /* we drop each position value in-between already decoded values,
16295:      and use linear interpolation to predict each new value past the
16295:      edges.  The positions are read in the order of the position
16295:      list... we precompute the bounding positions in the lookup.  Of
16295:      course, the neighbors can change (if a position is declined), but
16295:      this is an initial mapping */
16295: 
16295:   for(i=0;i<info->partitions;i++)n+=info->class_dim[info->partitionclass[i]];
16295:   n+=2;
16295:   look->posts=n;
16295: 
16295:   /* also store a sorted position index */
16295:   for(i=0;i<n;i++)sortpointer[i]=info->postlist+i;
16295:   qsort(sortpointer,n,sizeof(*sortpointer),icomp);
16295: 
16295:   /* points from sort order back to range number */
16295:   for(i=0;i<n;i++)look->forward_index[i]=sortpointer[i]-info->postlist;
16295:   /* points from range order to sorted position */
16295:   for(i=0;i<n;i++)look->reverse_index[look->forward_index[i]]=i;
16295:   /* we actually need the post values too */
16295:   for(i=0;i<n;i++)look->sorted_index[i]=info->postlist[look->forward_index[i]];
16295: 
16295:   /* quantize values to multiplier spec */
16295:   switch(info->mult){
16295:   case 1: /* 1024 -> 256 */
16295:     look->quant_q=256;
16295:     break;
16295:   case 2: /* 1024 -> 128 */
16295:     look->quant_q=128;
16295:     break;
16295:   case 3: /* 1024 -> 86 */
16295:     look->quant_q=86;
16295:     break;
16295:   case 4: /* 1024 -> 64 */
16295:     look->quant_q=64;
16295:     break;
16295:   }
16295: 
16295:   /* discover our neighbors for decode where we don't use fit flags
16295:      (that would push the neighbors outward) */
16295:   for(i=0;i<n-2;i++){
16295:     int lo=0;
16295:     int hi=1;
16295:     int lx=0;
16295:     int hx=look->n;
16295:     int currentx=info->postlist[i+2];
16295:     for(j=0;j<i+2;j++){
16295:       int x=info->postlist[j];
16295:       if(x>lx && x<currentx){
16295:         lo=j;
16295:         lx=x;
16295:       }
16295:       if(x<hx && x>currentx){
16295:         hi=j;
16295:         hx=x;
16295:       }
16295:     }
16295:     look->loneighbor[i]=lo;
16295:     look->hineighbor[i]=hi;
16295:   }
16295: 
16295:   return(look);
16295: }
16295: 
16295: static int render_point(int x0,int x1,int y0,int y1,int x){
16295:   y0&=0x7fff; /* mask off flag */
16295:   y1&=0x7fff;
16295: 
16295:   {
16295:     int dy=y1-y0;
16295:     int adx=x1-x0;
16295:     int ady=abs(dy);
16295:     int err=ady*(x-x0);
16295: 
16295:     int off=err/adx;
16295:     if(dy<0)return(y0-off);
16295:     return(y0+off);
16295:   }
16295: }
16295: 
16295: static int vorbis_dBquant(const float *x){
16295:   int i= *x*7.3142857f+1023.5f;
16295:   if(i>1023)return(1023);
16295:   if(i<0)return(0);
16295:   return i;
16295: }
16295: 
30043: static const float FLOOR1_fromdB_LOOKUP[256]={
16295:   1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
16295:   1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
16295:   1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
16295:   2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
16295:   2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
16295:   3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
16295:   4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
16295:   6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
16295:   7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
16295:   1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
16295:   1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
16295:   1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
16295:   2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
16295:   2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
16295:   3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
16295:   4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
16295:   5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
16295:   7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
16295:   9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
16295:   1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
16295:   1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
16295:   2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
16295:   2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
16295:   3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
16295:   4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
16295:   5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
16295:   7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
16295:   9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
16295:   0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
16295:   0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
16295:   0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
16295:   0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
16295:   0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
16295:   0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
16295:   0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
16295:   0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
16295:   0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F,
16295:   0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F,
16295:   0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F,
16295:   0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F,
16295:   0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F,
16295:   0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F,
16295:   0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F,
16295:   0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F,
16295:   0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F,
16295:   0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F,
16295:   0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F,
16295:   0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F,
16295:   0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F,
16295:   0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F,
16295:   0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F,
16295:   0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F,
16295:   0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F,
16295:   0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F,
16295:   0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F,
16295:   0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F,
16295:   0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F,
16295:   0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F,
16295:   0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F,
16295:   0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F,
16295:   0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F,
16295:   0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F,
16295:   0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F,
16295:   0.82788260F, 0.88168307F, 0.9389798F, 1.F,
16295: };
16295: 
16295: static void render_line(int n, int x0,int x1,int y0,int y1,float *d){
16295:   int dy=y1-y0;
16295:   int adx=x1-x0;
16295:   int ady=abs(dy);
16295:   int base=dy/adx;
16295:   int sy=(dy<0?base-1:base+1);
16295:   int x=x0;
16295:   int y=y0;
16295:   int err=0;
16295: 
16295:   ady-=abs(base*adx);
16295: 
16295:   if(n>x1)n=x1;
16295: 
16295:   if(x<n)
16295:     d[x]*=FLOOR1_fromdB_LOOKUP[y];
16295: 
16295:   while(++x<n){
16295:     err=err+ady;
16295:     if(err>=adx){
16295:       err-=adx;
16295:       y+=sy;
16295:     }else{
16295:       y+=base;
16295:     }
16295:     d[x]*=FLOOR1_fromdB_LOOKUP[y];
16295:   }
16295: }
16295: 
16295: static void render_line0(int x0,int x1,int y0,int y1,int *d){
16295:   int dy=y1-y0;
16295:   int adx=x1-x0;
16295:   int ady=abs(dy);
16295:   int base=dy/adx;
16295:   int sy=(dy<0?base-1:base+1);
16295:   int x=x0;
16295:   int y=y0;
16295:   int err=0;
16295: 
16295:   ady-=abs(base*adx);
16295: 
16295:   d[x]=y;
16295:   while(++x<x1){
16295:     err=err+ady;
16295:     if(err>=adx){
16295:       err-=adx;
16295:       y+=sy;
16295:     }else{
16295:       y+=base;
16295:     }
16295:     d[x]=y;
16295:   }
16295: }
16295: 
16295: /* the floor has already been filtered to only include relevant sections */
16295: static int accumulate_fit(const float *flr,const float *mdct,
16295:                           int x0, int x1,lsfit_acc *a,
16295:                           int n,vorbis_info_floor1 *info){
16295:   long i;
16295: 
16295:   long xa=0,ya=0,x2a=0,y2a=0,xya=0,na=0, xb=0,yb=0,x2b=0,y2b=0,xyb=0,nb=0;
16295: 
16295:   memset(a,0,sizeof(*a));
16295:   a->x0=x0;
16295:   a->x1=x1;
16295:   if(x1>=n)x1=n-1;
16295: 
16295:   for(i=x0;i<=x1;i++){
16295:     int quantized=vorbis_dBquant(flr+i);
16295:     if(quantized){
16295:       if(mdct[i]+info->twofitatten>=flr[i]){
16295:         xa  += i;
16295:         ya  += quantized;
16295:         x2a += i*i;
16295:         y2a += quantized*quantized;
16295:         xya += i*quantized;
16295:         na++;
16295:       }else{
16295:         xb  += i;
16295:         yb  += quantized;
16295:         x2b += i*i;
16295:         y2b += quantized*quantized;
16295:         xyb += i*quantized;
16295:         nb++;
16295:       }
16295:     }
16295:   }
16295: 
16295:   xb+=xa;
16295:   yb+=ya;
16295:   x2b+=x2a;
16295:   y2b+=y2a;
16295:   xyb+=xya;
16295:   nb+=na;
16295: 
16295:   /* weight toward the actually used frequencies if we meet the threshhold */
16295:   {
16295:     int weight=nb*info->twofitweight/(na+1);
16295: 
16295:     a->xa=xa*weight+xb;
16295:     a->ya=ya*weight+yb;
16295:     a->x2a=x2a*weight+x2b;
16295:     a->y2a=y2a*weight+y2b;
16295:     a->xya=xya*weight+xyb;
16295:     a->an=na*weight+nb;
16295:   }
16295: 
16295:   return(na);
16295: }
16295: 
30043: static int fit_line(lsfit_acc *a,int fits,int *y0,int *y1){
16295:   long x=0,y=0,x2=0,y2=0,xy=0,an=0,i;
16295:   long x0=a[0].x0;
16295:   long x1=a[fits-1].x1;
16295: 
16295:   for(i=0;i<fits;i++){
16295:     x+=a[i].xa;
16295:     y+=a[i].ya;
16295:     x2+=a[i].x2a;
16295:     y2+=a[i].y2a;
16295:     xy+=a[i].xya;
16295:     an+=a[i].an;
16295:   }
16295: 
16295:   if(*y0>=0){
16295:     x+=   x0;
16295:     y+=  *y0;
16295:     x2+=  x0 *  x0;
16295:     y2+= *y0 * *y0;
16295:     xy+= *y0 *  x0;
16295:     an++;
16295:   }
16295: 
16295:   if(*y1>=0){
16295:     x+=   x1;
16295:     y+=  *y1;
16295:     x2+=  x1 *  x1;
16295:     y2+= *y1 * *y1;
16295:     xy+= *y1 *  x1;
16295:     an++;
16295:   }
16295: 
30043:   {
16295:     /* need 64 bit multiplies, which C doesn't give portably as int */
16295:     double fx=x;
30043:     double fx2=x2;
30043:     double denom=(an*fx2-fx*fx);
30043: 
30043:     if(denom>0.){
16295:       double fy=y;
16295:       double fxy=xy;
30043: 
30043:       double a=(fy*fx2-fxy*fx)/denom;
30043:       double b=(an*fxy-fx*fy)/denom;
16295:       *y0=rint(a+b*x0);
16295:       *y1=rint(a+b*x1);
16295: 
16295:       /* limit to our range! */
16295:       if(*y0>1023)*y0=1023;
16295:       if(*y1>1023)*y1=1023;
16295:       if(*y0<0)*y0=0;
16295:       if(*y1<0)*y1=0;
16295: 
30043:       return 0;
16295:     }else{
16295:       *y0=0;
16295:       *y1=0;
30043:       return 1;
30043:     }
16295:   }
16295: }
16295: 
16295: /*static void fit_line_point(lsfit_acc *a,int fits,int *y0,int *y1){
16295:   long y=0;
16295:   int i;
16295: 
16295:   for(i=0;i<fits && y==0;i++)
16295:     y+=a[i].ya;
16295: 
16295:   *y0=*y1=y;
16295:   }*/
16295: 
16295: static int inspect_error(int x0,int x1,int y0,int y1,const float *mask,
16295:                          const float *mdct,
16295:                          vorbis_info_floor1 *info){
16295:   int dy=y1-y0;
16295:   int adx=x1-x0;
16295:   int ady=abs(dy);
16295:   int base=dy/adx;
16295:   int sy=(dy<0?base-1:base+1);
16295:   int x=x0;
16295:   int y=y0;
16295:   int err=0;
16295:   int val=vorbis_dBquant(mask+x);
16295:   int mse=0;
16295:   int n=0;
16295: 
16295:   ady-=abs(base*adx);
16295: 
16295:   mse=(y-val);
16295:   mse*=mse;
16295:   n++;
16295:   if(mdct[x]+info->twofitatten>=mask[x]){
16295:     if(y+info->maxover<val)return(1);
16295:     if(y-info->maxunder>val)return(1);
16295:   }
16295: 
16295:   while(++x<x1){
16295:     err=err+ady;
16295:     if(err>=adx){
16295:       err-=adx;
16295:       y+=sy;
16295:     }else{
16295:       y+=base;
16295:     }
16295: 
16295:     val=vorbis_dBquant(mask+x);
16295:     mse+=((y-val)*(y-val));
16295:     n++;
16295:     if(mdct[x]+info->twofitatten>=mask[x]){
16295:       if(val){
16295:         if(y+info->maxover<val)return(1);
16295:         if(y-info->maxunder>val)return(1);
16295:       }
16295:     }
16295:   }
16295: 
16295:   if(info->maxover*info->maxover/n>info->maxerr)return(0);
16295:   if(info->maxunder*info->maxunder/n>info->maxerr)return(0);
16295:   if(mse/n>info->maxerr)return(1);
16295:   return(0);
16295: }
16295: 
16295: static int post_Y(int *A,int *B,int pos){
16295:   if(A[pos]<0)
16295:     return B[pos];
16295:   if(B[pos]<0)
16295:     return A[pos];
16295: 
16295:   return (A[pos]+B[pos])>>1;
16295: }
16295: 
16295: int *floor1_fit(vorbis_block *vb,vorbis_look_floor1 *look,
16295:                           const float *logmdct,   /* in */
16295:                           const float *logmask){
16295:   long i,j;
16295:   vorbis_info_floor1 *info=look->vi;
16295:   long n=look->n;
16295:   long posts=look->posts;
16295:   long nonzero=0;
16295:   lsfit_acc fits[VIF_POSIT+1];
16295:   int fit_valueA[VIF_POSIT+2]; /* index by range list position */
16295:   int fit_valueB[VIF_POSIT+2]; /* index by range list position */
16295: 
16295:   int loneighbor[VIF_POSIT+2]; /* sorted index of range list position (+2) */
16295:   int hineighbor[VIF_POSIT+2];
16295:   int *output=NULL;
16295:   int memo[VIF_POSIT+2];
16295: 
16295:   for(i=0;i<posts;i++)fit_valueA[i]=-200; /* mark all unused */
16295:   for(i=0;i<posts;i++)fit_valueB[i]=-200; /* mark all unused */
16295:   for(i=0;i<posts;i++)loneighbor[i]=0; /* 0 for the implicit 0 post */
16295:   for(i=0;i<posts;i++)hineighbor[i]=1; /* 1 for the implicit post at n */
16295:   for(i=0;i<posts;i++)memo[i]=-1;      /* no neighbor yet */
16295: 
16295:   /* quantize the relevant floor points and collect them into line fit
16295:      structures (one per minimal division) at the same time */
16295:   if(posts==0){
16295:     nonzero+=accumulate_fit(logmask,logmdct,0,n,fits,n,info);
16295:   }else{
16295:     for(i=0;i<posts-1;i++)
16295:       nonzero+=accumulate_fit(logmask,logmdct,look->sorted_index[i],
16295:                               look->sorted_index[i+1],fits+i,
16295:                               n,info);
16295:   }
16295: 
16295:   if(nonzero){
16295:     /* start by fitting the implicit base case.... */
16295:     int y0=-200;
16295:     int y1=-200;
16295:     fit_line(fits,posts-1,&y0,&y1);
16295: 
16295:     fit_valueA[0]=y0;
16295:     fit_valueB[0]=y0;
16295:     fit_valueB[1]=y1;
16295:     fit_valueA[1]=y1;
16295: 
16295:     /* Non degenerate case */
16295:     /* start progressive splitting.  This is a greedy, non-optimal
16295:        algorithm, but simple and close enough to the best
16295:        answer. */
16295:     for(i=2;i<posts;i++){
16295:       int sortpos=look->reverse_index[i];
16295:       int ln=loneighbor[sortpos];
16295:       int hn=hineighbor[sortpos];
16295: 
16295:       /* eliminate repeat searches of a particular range with a memo */
16295:       if(memo[ln]!=hn){
16295:         /* haven't performed this error search yet */
16295:         int lsortpos=look->reverse_index[ln];
16295:         int hsortpos=look->reverse_index[hn];
16295:         memo[ln]=hn;
16295: 
16295:         {
16295:           /* A note: we want to bound/minimize *local*, not global, error */
16295:           int lx=info->postlist[ln];
16295:           int hx=info->postlist[hn];
16295:           int ly=post_Y(fit_valueA,fit_valueB,ln);
16295:           int hy=post_Y(fit_valueA,fit_valueB,hn);
16295: 
16295:           if(ly==-1 || hy==-1){
16295:             exit(1);
16295:           }
16295: 
16295:           if(inspect_error(lx,hx,ly,hy,logmask,logmdct,info)){
16295:             /* outside error bounds/begin search area.  Split it. */
16295:             int ly0=-200;
16295:             int ly1=-200;
16295:             int hy0=-200;
16295:             int hy1=-200;
30043:             int ret0=fit_line(fits+lsortpos,sortpos-lsortpos,&ly0,&ly1);
30043:             int ret1=fit_line(fits+sortpos,hsortpos-sortpos,&hy0,&hy1);
16295: 
30043:             if(ret0){
30043:               ly0=ly;
30043:               ly1=hy0;
30043:             }
30043:             if(ret1){
30043:               hy0=ly1;
30043:               hy1=hy;
30043:             }
30043: 
30043:             if(ret0 && ret1){
30043:               fit_valueA[i]=-200;
30043:               fit_valueB[i]=-200;
30043:             }else{
16295:               /* store new edge values */
16295:               fit_valueB[ln]=ly0;
16295:               if(ln==0)fit_valueA[ln]=ly0;
16295:               fit_valueA[i]=ly1;
16295:               fit_valueB[i]=hy0;
16295:               fit_valueA[hn]=hy1;
16295:               if(hn==1)fit_valueB[hn]=hy1;
16295: 
16295:               if(ly1>=0 || hy0>=0){
16295:                 /* store new neighbor values */
16295:                 for(j=sortpos-1;j>=0;j--)
16295:                   if(hineighbor[j]==hn)
16295:                     hineighbor[j]=i;
16295:                   else
16295:                     break;
16295:                 for(j=sortpos+1;j<posts;j++)
16295:                   if(loneighbor[j]==ln)
16295:                     loneighbor[j]=i;
16295:                   else
16295:                     break;
30043:               }
16295:             }
16295:           }else{
16295:             fit_valueA[i]=-200;
16295:             fit_valueB[i]=-200;
16295:           }
16295:         }
16295:       }
16295:     }
16295: 
16295:     output=_vorbis_block_alloc(vb,sizeof(*output)*posts);
16295: 
16295:     output[0]=post_Y(fit_valueA,fit_valueB,0);
16295:     output[1]=post_Y(fit_valueA,fit_valueB,1);
16295: 
16295:     /* fill in posts marked as not using a fit; we will zero
16295:        back out to 'unused' when encoding them so long as curve
16295:        interpolation doesn't force them into use */
16295:     for(i=2;i<posts;i++){
16295:       int ln=look->loneighbor[i-2];
16295:       int hn=look->hineighbor[i-2];
16295:       int x0=info->postlist[ln];
16295:       int x1=info->postlist[hn];
16295:       int y0=output[ln];
16295:       int y1=output[hn];
16295: 
16295:       int predicted=render_point(x0,x1,y0,y1,info->postlist[i]);
16295:       int vx=post_Y(fit_valueA,fit_valueB,i);
16295: 
16295:       if(vx>=0 && predicted!=vx){
16295:         output[i]=vx;
16295:       }else{
16295:         output[i]= predicted|0x8000;
16295:       }
16295:     }
16295:   }
16295: 
16295:   return(output);
16295: 
16295: }
16295: 
16295: int *floor1_interpolate_fit(vorbis_block *vb,vorbis_look_floor1 *look,
16295:                           int *A,int *B,
16295:                           int del){
16295: 
16295:   long i;
16295:   long posts=look->posts;
16295:   int *output=NULL;
16295: 
16295:   if(A && B){
16295:     output=_vorbis_block_alloc(vb,sizeof(*output)*posts);
16295: 
30043:     /* overly simpleminded--- look again post 1.2 */
16295:     for(i=0;i<posts;i++){
16295:       output[i]=((65536-del)*(A[i]&0x7fff)+del*(B[i]&0x7fff)+32768)>>16;
16295:       if(A[i]&0x8000 && B[i]&0x8000)output[i]|=0x8000;
16295:     }
16295:   }
16295: 
16295:   return(output);
16295: }
16295: 
16295: 
16295: int floor1_encode(oggpack_buffer *opb,vorbis_block *vb,
16295:                   vorbis_look_floor1 *look,
16295:                   int *post,int *ilogmask){
16295: 
16295:   long i,j;
16295:   vorbis_info_floor1 *info=look->vi;
16295:   long posts=look->posts;
16295:   codec_setup_info *ci=vb->vd->vi->codec_setup;
16295:   int out[VIF_POSIT+2];
16295:   static_codebook **sbooks=ci->book_param;
16295:   codebook *books=ci->fullbooks;
16295: 
16295:   /* quantize values to multiplier spec */
16295:   if(post){
16295:     for(i=0;i<posts;i++){
16295:       int val=post[i]&0x7fff;
16295:       switch(info->mult){
16295:       case 1: /* 1024 -> 256 */
16295:         val>>=2;
16295:         break;
16295:       case 2: /* 1024 -> 128 */
16295:         val>>=3;
16295:         break;
16295:       case 3: /* 1024 -> 86 */
16295:         val/=12;
16295:         break;
16295:       case 4: /* 1024 -> 64 */
16295:         val>>=4;
16295:         break;
16295:       }
16295:       post[i]=val | (post[i]&0x8000);
16295:     }
16295: 
16295:     out[0]=post[0];
16295:     out[1]=post[1];
16295: 
16295:     /* find prediction values for each post and subtract them */
16295:     for(i=2;i<posts;i++){
16295:       int ln=look->loneighbor[i-2];
16295:       int hn=look->hineighbor[i-2];
16295:       int x0=info->postlist[ln];
16295:       int x1=info->postlist[hn];
16295:       int y0=post[ln];
16295:       int y1=post[hn];
16295: 
16295:       int predicted=render_point(x0,x1,y0,y1,info->postlist[i]);
16295: 
16295:       if((post[i]&0x8000) || (predicted==post[i])){
16295:         post[i]=predicted|0x8000; /* in case there was roundoff jitter
16295:                                      in interpolation */
16295:         out[i]=0;
16295:       }else{
16295:         int headroom=(look->quant_q-predicted<predicted?
16295:                       look->quant_q-predicted:predicted);
16295: 
16295:         int val=post[i]-predicted;
16295: 
16295:         /* at this point the 'deviation' value is in the range +/- max
16295:            range, but the real, unique range can always be mapped to
16295:            only [0-maxrange).  So we want to wrap the deviation into
16295:            this limited range, but do it in the way that least screws
16295:            an essentially gaussian probability distribution. */
16295: 
16295:         if(val<0)
16295:           if(val<-headroom)
16295:             val=headroom-val-1;
16295:           else
16295:             val=-1-(val<<1);
16295:         else
16295:           if(val>=headroom)
16295:             val= val+headroom;
16295:           else
16295:             val<<=1;
16295: 
16295:         out[i]=val;
16295:         post[ln]&=0x7fff;
16295:         post[hn]&=0x7fff;
16295:       }
16295:     }
16295: 
16295:     /* we have everything we need. pack it out */
16295:     /* mark nontrivial floor */
16295:     oggpack_write(opb,1,1);
16295: 
16295:     /* beginning/end post */
16295:     look->frames++;
16295:     look->postbits+=ilog(look->quant_q-1)*2;
16295:     oggpack_write(opb,out[0],ilog(look->quant_q-1));
16295:     oggpack_write(opb,out[1],ilog(look->quant_q-1));
16295: 
16295: 
16295:     /* partition by partition */
16295:     for(i=0,j=2;i<info->partitions;i++){
16295:       int class=info->partitionclass[i];
16295:       int cdim=info->class_dim[class];
16295:       int csubbits=info->class_subs[class];
16295:       int csub=1<<csubbits;
16295:       int bookas[8]={0,0,0,0,0,0,0,0};
16295:       int cval=0;
16295:       int cshift=0;
16295:       int k,l;
16295: 
16295:       /* generate the partition's first stage cascade value */
16295:       if(csubbits){
16295:         int maxval[8];
16295:         for(k=0;k<csub;k++){
16295:           int booknum=info->class_subbook[class][k];
16295:           if(booknum<0){
16295:             maxval[k]=1;
16295:           }else{
16295:             maxval[k]=sbooks[info->class_subbook[class][k]]->entries;
16295:           }
16295:         }
16295:         for(k=0;k<cdim;k++){
16295:           for(l=0;l<csub;l++){
16295:             int val=out[j+k];
16295:             if(val<maxval[l]){
16295:               bookas[k]=l;
16295:               break;
16295:             }
16295:           }
16295:           cval|= bookas[k]<<cshift;
16295:           cshift+=csubbits;
16295:         }
16295:         /* write it */
16295:         look->phrasebits+=
16295:           vorbis_book_encode(books+info->class_book[class],cval,opb);
16295: 
16295: #ifdef TRAIN_FLOOR1
16295:         {
16295:           FILE *of;
16295:           char buffer[80];
16295:           sprintf(buffer,"line_%dx%ld_class%d.vqd",
16295:                   vb->pcmend/2,posts-2,class);
16295:           of=fopen(buffer,"a");
16295:           fprintf(of,"%d\n",cval);
16295:           fclose(of);
16295:         }
16295: #endif
16295:       }
16295: 
16295:       /* write post values */
16295:       for(k=0;k<cdim;k++){
16295:         int book=info->class_subbook[class][bookas[k]];
16295:         if(book>=0){
16295:           /* hack to allow training with 'bad' books */
16295:           if(out[j+k]<(books+book)->entries)
16295:             look->postbits+=vorbis_book_encode(books+book,
16295:                                                out[j+k],opb);
16295:           /*else
16295:             fprintf(stderr,"+!");*/
16295: 
16295: #ifdef TRAIN_FLOOR1
16295:           {
16295:             FILE *of;
16295:             char buffer[80];
16295:             sprintf(buffer,"line_%dx%ld_%dsub%d.vqd",
16295:                     vb->pcmend/2,posts-2,class,bookas[k]);
16295:             of=fopen(buffer,"a");
16295:             fprintf(of,"%d\n",out[j+k]);
16295:             fclose(of);
16295:           }
16295: #endif
16295:         }
16295:       }
16295:       j+=cdim;
16295:     }
16295: 
16295:     {
16295:       /* generate quantized floor equivalent to what we'd unpack in decode */
16295:       /* render the lines */
16295:       int hx=0;
16295:       int lx=0;
16295:       int ly=post[0]*info->mult;
16295:       for(j=1;j<look->posts;j++){
16295:         int current=look->forward_index[j];
16295:         int hy=post[current]&0x7fff;
16295:         if(hy==post[current]){
16295: 
16295:           hy*=info->mult;
16295:           hx=info->postlist[current];
16295: 
16295:           render_line0(lx,hx,ly,hy,ilogmask);
16295: 
16295:           lx=hx;
16295:           ly=hy;
16295:         }
16295:       }
16295:       for(j=hx;j<vb->pcmend/2;j++)ilogmask[j]=ly; /* be certain */
16295:       return(1);
16295:     }
16295:   }else{
16295:     oggpack_write(opb,0,1);
16295:     memset(ilogmask,0,vb->pcmend/2*sizeof(*ilogmask));
16295:     return(0);
16295:   }
16295: }
16295: 
16295: static void *floor1_inverse1(vorbis_block *vb,vorbis_look_floor *in){
16295:   vorbis_look_floor1 *look=(vorbis_look_floor1 *)in;
16295:   vorbis_info_floor1 *info=look->vi;
16295:   codec_setup_info   *ci=vb->vd->vi->codec_setup;
16295: 
16295:   int i,j,k;
16295:   codebook *books=ci->fullbooks;
16295: 
16295:   /* unpack wrapped/predicted values from stream */
16295:   if(oggpack_read(&vb->opb,1)==1){
16295:     int *fit_value=_vorbis_block_alloc(vb,(look->posts)*sizeof(*fit_value));
16295: 
16295:     fit_value[0]=oggpack_read(&vb->opb,ilog(look->quant_q-1));
16295:     fit_value[1]=oggpack_read(&vb->opb,ilog(look->quant_q-1));
16295: 
16295:     /* partition by partition */
16295:     for(i=0,j=2;i<info->partitions;i++){
16295:       int class=info->partitionclass[i];
16295:       int cdim=info->class_dim[class];
16295:       int csubbits=info->class_subs[class];
16295:       int csub=1<<csubbits;
16295:       int cval=0;
16295: 
16295:       /* decode the partition's first stage cascade value */
16295:       if(csubbits){
16295:         cval=vorbis_book_decode(books+info->class_book[class],&vb->opb);
16295: 
16295:         if(cval==-1)goto eop;
16295:       }
16295: 
16295:       for(k=0;k<cdim;k++){
16295:         int book=info->class_subbook[class][cval&(csub-1)];
16295:         cval>>=csubbits;
16295:         if(book>=0){
16295:           if((fit_value[j+k]=vorbis_book_decode(books+book,&vb->opb))==-1)
16295:             goto eop;
16295:         }else{
16295:           fit_value[j+k]=0;
16295:         }
16295:       }
16295:       j+=cdim;
16295:     }
16295: 
16295:     /* unwrap positive values and reconsitute via linear interpolation */
16295:     for(i=2;i<look->posts;i++){
16295:       int predicted=render_point(info->postlist[look->loneighbor[i-2]],
16295:                                  info->postlist[look->hineighbor[i-2]],
16295:                                  fit_value[look->loneighbor[i-2]],
16295:                                  fit_value[look->hineighbor[i-2]],
16295:                                  info->postlist[i]);
16295:       int hiroom=look->quant_q-predicted;
16295:       int loroom=predicted;
16295:       int room=(hiroom<loroom?hiroom:loroom)<<1;
16295:       int val=fit_value[i];
16295: 
16295:       if(val){
16295:         if(val>=room){
16295:           if(hiroom>loroom){
16295:             val = val-loroom;
16295:           }else{
16295:             val = -1-(val-hiroom);
16295:           }
16295:         }else{
16295:           if(val&1){
16295:             val= -((val+1)>>1);
16295:           }else{
16295:             val>>=1;
16295:           }
16295:         }
16295: 
16295:         fit_value[i]=val+predicted;
16295:         fit_value[look->loneighbor[i-2]]&=0x7fff;
16295:         fit_value[look->hineighbor[i-2]]&=0x7fff;
16295: 
16295:       }else{
16295:         fit_value[i]=predicted|0x8000;
16295:       }
16295: 
16295:     }
16295: 
16295:     return(fit_value);
16295:   }
16295:  eop:
16295:   return(NULL);
16295: }
16295: 
16295: static int floor1_inverse2(vorbis_block *vb,vorbis_look_floor *in,void *memo,
16295:                           float *out){
16295:   vorbis_look_floor1 *look=(vorbis_look_floor1 *)in;
16295:   vorbis_info_floor1 *info=look->vi;
16295: 
16295:   codec_setup_info   *ci=vb->vd->vi->codec_setup;
16295:   int                  n=ci->blocksizes[vb->W]/2;
16295:   int j;
16295: 
16295:   if(memo){
16295:     /* render the lines */
16295:     int *fit_value=(int *)memo;
16295:     int hx=0;
16295:     int lx=0;
16295:     int ly=fit_value[0]*info->mult;
16295:     for(j=1;j<look->posts;j++){
16295:       int current=look->forward_index[j];
16295:       int hy=fit_value[current]&0x7fff;
16295:       if(hy==fit_value[current]){
16295: 
16295:         hy*=info->mult;
16295:         hx=info->postlist[current];
16295: 
16295:         render_line(n,lx,hx,ly,hy,out);
16295: 
16295:         lx=hx;
16295:         ly=hy;
16295:       }
16295:     }
16295:     for(j=hx;j<n;j++)out[j]*=FLOOR1_fromdB_LOOKUP[ly]; /* be certain */
16295:     return(1);
16295:   }
16295:   memset(out,0,sizeof(*out)*n);
16295:   return(0);
16295: }
16295: 
16295: /* export hooks */
30043: const vorbis_func_floor floor1_exportbundle={
16295:   &floor1_pack,&floor1_unpack,&floor1_look,&floor1_free_info,
16295:   &floor1_free_look,&floor1_inverse1,&floor1_inverse2
16295: };
