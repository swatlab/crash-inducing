80063: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
80063:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
80063:  *
80063:  * ***** BEGIN LICENSE BLOCK *****
80063:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
80063:  *
80063:  * The contents of this file are subject to the Mozilla Public License Version
80063:  * 1.1 (the "License"); you may not use this file except in compliance with
80063:  * the License. You may obtain a copy of the License at
80063:  * http://www.mozilla.org/MPL/
80063:  *
80063:  * Software distributed under the License is distributed on an "AS IS" basis,
80063:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
80063:  * for the specific language governing rights and limitations under the
80063:  * License.
80063:  *
80063:  * The Original Code is mozilla.org code, released
80063:  * June 24, 2010.
80063:  *
80063:  * The Initial Developer of the Original Code is
80063:  *    The Mozilla Foundation
80063:  *
80063:  * Contributor(s):
80063:  *    Andreas Gal <gal@mozilla.com>
80063:  *
80063:  * Alternatively, the contents of this file may be used under the terms of
80063:  * either of the GNU General Public License Version 2 or later (the "GPL"),
80063:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
80063:  * in which case the provisions of the GPL or the LGPL are applicable instead
80063:  * of those above. If you wish to allow use of your version of this file only
80063:  * under the terms of either the GPL or the LGPL, and not to allow others to
80063:  * use your version of this file under the terms of the MPL, indicate your
80063:  * decision by deleting the provisions above and replace them with the notice
80063:  * and other provisions required by the GPL or the LGPL. If you do not delete
80063:  * the provisions above, a recipient may use your version of this file under
80063:  * the terms of any one of the MPL, the GPL or the LGPL.
80063:  *
80063:  * ***** END LICENSE BLOCK ***** */
80063: 
80467: #include "mozilla/Util.h"
80467: 
80063: #include "dombindings.h"
80063: #include "xpcprivate.h"
80384: #include "XPCQuickStubs.h"
80072: #include "XPCWrapper.h"
80072: #include "WrapperFactory.h"
80064: #include "nsDOMClassInfo.h"
80070: #include "nsGlobalWindow.h"
80074: #include "jsiter.h"
80074: #include "nsWrapperCacheInlines.h"
80064: 
80063: using namespace js;
80063: 
80092: namespace mozilla {
80063: namespace dom {
80092: namespace binding {
80063: 
80086: 
80086: static jsid s_constructor_id = JSID_VOID;
80086: static jsid s_prototype_id = JSID_VOID;
80086: 
80086: static jsid s_length_id = JSID_VOID;
80086: 
80086: bool
80086: DefineStaticJSVal(JSContext *cx, jsid &id, const char *string)
80086: {
80086:     if (JSString *str = ::JS_InternString(cx, string)) {
80086:         id = INTERNED_STRING_TO_JSID(cx, str);
80086:         return true;
80086:     }
80086:     return false;
80086: }
80086: 
80086: #define SET_JSID_TO_STRING(_cx, _string)                                      \
80086:     DefineStaticJSVal(_cx, s_##_string##_id, #_string)
80086: 
80086: bool
80086: DefineStaticJSVals(JSContext *cx)
80086: {
80086:     JSAutoRequest ar(cx);
80086: 
80086:     return SET_JSID_TO_STRING(cx, constructor) &&
80086:            SET_JSID_TO_STRING(cx, prototype) &&
80086:            SET_JSID_TO_STRING(cx, length) &&
80098:            DefinePropertyStaticJSVals(cx);
80086: }
80086: 
80086: 
80071: int HandlerFamily;
80063: 
80083: 
80083: JSBool
80083: Throw(JSContext *cx, nsresult rv)
80083: {
80083:     XPCThrower::Throw(rv, cx);
80083:     return JS_FALSE;
80083: }
80083: 
80083: 
80081: // Only set allowNativeWrapper to false if you really know you need it, if in
80081: // doubt use true. Setting it to false disables security wrappers.
80081: static bool
80081: XPCOMObjectToJsval(JSContext *cx, JSObject *scope, xpcObjectHelper &helper,
80081:                    bool allowNativeWrapper, jsval *rval)
80081: {
80081:     // XXX The OBJ_IS_NOT_GLOBAL here is not really right. In
80081:     // fact, this code is depending on the fact that the
80081:     // global object will not have been collected, and
80081:     // therefore this NativeInterface2JSObject will not end up
80081:     // creating a new XPCNativeScriptableShared.
80081: 
80081:     XPCLazyCallContext lccx(JS_CALLER, cx, scope);
80081: 
80081:     nsresult rv;
80081:     if (!XPCConvert::NativeInterface2JSObject(lccx, rval, NULL, helper, NULL, NULL,
80081:                                               allowNativeWrapper, OBJ_IS_NOT_GLOBAL, &rv)) {
80081:         // I can't tell if NativeInterface2JSObject throws JS exceptions
80081:         // or not.  This is a sloppy stab at the right semantics; the
80081:         // method really ought to be fixed to behave consistently.
80081:         if (!JS_IsExceptionPending(cx))
80083:             Throw(cx, NS_FAILED(rv) ? rv : NS_ERROR_UNEXPECTED);
80081:         return false;
80081:     }
80081: 
80081: #ifdef DEBUG
80081:     JSObject* jsobj = JSVAL_TO_OBJECT(*rval);
80081:     if (jsobj && !js::GetObjectParent(jsobj))
80081:         NS_ASSERTION(js::GetObjectClass(jsobj)->flags & JSCLASS_IS_GLOBAL,
80081:                      "Why did we recreate this wrapper?");
80081: #endif
80081: 
80081:     return true;
80081: }
80081: 
80081: template<class T>
80081: static inline JSObject*
80081: WrapNativeParent(JSContext *cx, JSObject *scope, T *p)
80081: {
80081:     if (!p)
80081:         return NULL;
80081: 
80081:     nsWrapperCache *cache = GetWrapperCache(p);
80081:     JSObject* obj;
80081:     if (cache && (obj = cache->GetWrapper())) {
80081: #ifdef DEBUG
80081:         qsObjectHelper helper(p, cache);
80081:         jsval debugVal;
80081: 
80081:         bool ok = XPCOMObjectToJsval(cx, scope, helper, false, &debugVal);
80081:         NS_ASSERTION(ok && JSVAL_TO_OBJECT(debugVal) == obj,
80081:                      "Unexpected object in nsWrapperCache");
80081: #endif
80081:         return obj;
80081:     }
80081: 
80081:     qsObjectHelper helper(p, cache);
80081:     jsval v;
80081:     return XPCOMObjectToJsval(cx, scope, helper, false, &v) ? JSVAL_TO_OBJECT(v) : NULL;
80081: }
80081: 
80095: template<class T>
80094: static bool
80095: Wrap(JSContext *cx, JSObject *scope, T *p, nsWrapperCache *cache, jsval *vp)
80068: {
80094:     if (xpc_FastGetCachedWrapper(cache, scope, vp))
80094:         return true;
80095:     qsObjectHelper helper(p, cache);
80094:     return XPCOMObjectToJsval(cx, scope, helper, true, vp);
80068: }
80068: 
80068: template<class T>
80095: static inline bool
80095: Wrap(JSContext *cx, JSObject *scope, T *p, jsval *vp)
80095: {
80095:     return Wrap(cx, scope, p, GetWrapperCache(p), vp);
80095: }
80095: 
80095: template<>
80095: inline bool
80095: Wrap(JSContext *cx, JSObject *scope, NoType *p, jsval *vp)
80095: {
80095:     NS_RUNTIMEABORT("We try to wrap the result from calling a noop?");
80095:     return false;
80095: }
80095: 
80095: template<class T>
80095: inline bool
80095: Wrap(JSContext *cx, JSObject *scope, nsCOMPtr<T> &p, jsval *vp)
80095: {
80095:     return Wrap(cx, scope, p.get(), vp);
80095: }
80095: 
80095: static inline bool
80095: Wrap(JSContext *cx, JSObject *scope, nsISupportsResult &result, jsval *vp)
80095: {
80095:     return Wrap(cx, scope, result.mResult, result.mCache, vp);
80095: }
80095: 
80095: static inline bool
80095: Wrap(JSContext *cx, JSObject *scope, nsString &result, jsval *vp)
80095: {
80095:     return xpc_qsStringToJsval(cx, result, vp);
80095: }
80095: 
80095: template<class T>
80095: bool
80095: Unwrap(JSContext *cx, jsval v, T **ppArg, nsISupports **ppArgRef, jsval *vp)
80095: {
80095:     nsresult rv = xpc_qsUnwrapArg(cx, v, ppArg, ppArgRef, vp);
80095:     if (NS_FAILED(rv))
80095:         return Throw(cx, rv);
80095:     return true;
80095: }
80095: 
80095: template<>
80095: bool
80095: Unwrap(JSContext *cx, jsval v, NoType **ppArg, nsISupports **ppArgRef, jsval *vp)
80095: {
80095:     NS_RUNTIMEABORT("We try to unwrap an argument for a noop?");
80095:     return false;
80095: }
80095: 
80095: 
80095: template<class LC>
80095: ListBase<LC> ListBase<LC>::instance;
80063: 
80079: bool
80085: DefineConstructor(JSContext *cx, JSObject *obj, DefineInterface aDefine, nsresult *aResult)
80079: {
80085:     bool enabled;
80085:     bool defined = !!aDefine(cx, XPCWrappedNativeScope::FindInJSObjectScope(cx, obj), &enabled);
80085:     NS_ASSERTION(!defined || enabled,
80085:                  "We defined a constructor but the new bindings are disabled?");
80085:     *aResult = defined ? NS_OK : NS_ERROR_FAILURE;
80085:     return enabled;
80079: }
80079: 
80095: template<class LC>
80095: typename ListBase<LC>::ListType*
80096: ListBase<LC>::getNative(JSObject *obj)
80096: {
80096:     return static_cast<ListType*>(js::GetProxyPrivate(obj).toPrivate());
80096: }
80096: 
80096: template<class LC>
80096: typename ListBase<LC>::ListType*
80095: ListBase<LC>::getListObject(JSObject *obj)
80063: {
80091:     if (xpc::WrapperFactory::IsXrayWrapper(obj))
80091:         obj = js::UnwrapObject(obj);
80093:     JS_ASSERT(objIsList(obj));
80096:     return getNative(obj);
80063: }
80063: 
80095: template<class LC>
80063: uint32
80095: ListBase<LC>::getProtoShape(JSObject *obj)
80063: {
80093:     JS_ASSERT(objIsList(obj));
80074:     return js::GetProxyExtra(obj, JSPROXYSLOT_PROTOSHAPE).toPrivateUint32();
80063: }
80063: 
80095: template<class LC>
80063: void
80095: ListBase<LC>::setProtoShape(JSObject *obj, uint32 shape)
80063: {
80093:     JS_ASSERT(objIsList(obj));
80074:     js::SetProxyExtra(obj, JSPROXYSLOT_PROTOSHAPE, PrivateUint32Value(shape));
80063: }
80063: 
80095: template<class LC>
80065: bool
80095: ListBase<LC>::instanceIsListObject(JSContext *cx, JSObject *obj, JSObject *callee)
80063: {
80072:     if (XPCWrapper::IsSecurityWrapper(obj)) {
80072:         if (callee && js::GetObjectGlobal(obj) == js::GetObjectGlobal(callee)) {
80072:             obj = js::UnwrapObject(obj);
80390:         } else {
80072:             obj = XPCWrapper::Unwrap(cx, obj);
80072:             if (!obj)
80083:                 return Throw(cx, NS_ERROR_XPC_SECURITY_MANAGER_VETO);
80072:         }
80072:     }
80072: 
80093:     if (!objIsList(obj)) {
80063:         // FIXME: Throw a proper DOM exception.
80063:         JS_ReportError(cx, "type error: wrong object");
80063:         return false;
80063:     }
80065:     return true;
80065: }
80065: 
80095: template<class LC>
80065: JSBool
80095: ListBase<LC>::length_getter(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
80065: {
80093:     if (!instanceIsListObject(cx, obj, NULL))
80065:         return false;
80063:     PRUint32 length;
80093:     getListObject(obj)->GetLength(&length);
80063:     JS_ASSERT(int32(length) >= 0);
80087:     *vp = UINT_TO_JSVAL(length);
80063:     return true;
80063: }
80063: 
80095: template<class LC>
80095: bool
80097: ListBase<LC>::getItemAt(ListType *list, uint32 i, IndexGetterType &item)
80097: {
80097:     JS_STATIC_ASSERT(!hasIndexGetter);
80097:     return false;
80097: }
80097: 
80097: template<class LC>
80097: bool
81554: ListBase<LC>::setItemAt(JSContext *cx, ListType *list, uint32 i, IndexSetterType item)
80097: {
80097:     JS_STATIC_ASSERT(!hasIndexSetter);
80097:     return false;
80097: }
80097: 
80097: template<class LC>
80097: bool
80095: ListBase<LC>::getNamedItem(ListType *list, const nsAString& aName, NameGetterType &item)
80095: {
80095:     JS_STATIC_ASSERT(!hasNameGetter);
80095:     return false;
80095: }
80095: 
80095: template<class LC>
80097: bool
81554: ListBase<LC>::setNamedItem(JSContext *cx, ListType *list, const nsAString& aName,
81554:                            NameSetterType item)
80097: {
80097:     JS_STATIC_ASSERT(!hasNameSetter);
80097:     return false;
80097: }
80097: 
80097: template<class LC>
80082: bool
80095: ListBase<LC>::namedItem(JSContext *cx, JSObject *obj, jsval *name, NameGetterType &result,
80095:                         bool *hasResult)
80076: {
80076:     xpc_qsDOMString nameString(cx, *name, name,
80076:                                xpc_qsDOMString::eDefaultNullBehavior,
80076:                                xpc_qsDOMString::eDefaultUndefinedBehavior);
80076:     if (!nameString.IsValid())
80082:         return false;
80095:     *hasResult = getNamedItem(getListObject(obj), nameString, result);
80082:     return true;
80076: }
80076: 
80079: JSBool
80079: interface_hasInstance(JSContext *cx, JSObject *obj, const js::Value *vp, JSBool *bp)
80079: {
80079:     if (vp->isObject()) {
80079:         jsval prototype;
80086:         if (!JS_GetPropertyById(cx, obj, s_prototype_id, &prototype) ||
80079:             JSVAL_IS_PRIMITIVE(prototype)) {
80079:             JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
80079:                                          JSMSG_THROW_TYPE_ERROR);
80079:             return JS_FALSE;
80079:         }
80079: 
80079:         JSObject *other = &vp->toObject();
80079:         if (instanceIsProxy(other)) {
80079:             ProxyHandler *handler = static_cast<ProxyHandler*>(js::GetProxyHandler(other));
80079:             if (handler->isInstanceOf(JSVAL_TO_OBJECT(prototype))) {
80079:                 *bp = JS_TRUE;
80390:             } else {
80079:                 JSObject *protoObj = JSVAL_TO_OBJECT(prototype);
80079:                 JSObject *proto = other;
80079:                 while ((proto = JS_GetPrototype(cx, proto))) {
80079:                     if (proto == protoObj) {
80079:                         *bp = JS_TRUE;
80079:                         return JS_TRUE;
80079:                     }
80079:                 }
80079:                 *bp = JS_FALSE;
80079:             }
80079: 
80079:             return JS_TRUE;
80079:         }
80079:     }
80079: 
80079:     *bp = JS_FALSE;
80079:     return JS_TRUE;
80079: }
80079: 
80095: template<class LC>
80063: JSObject *
80095: ListBase<LC>::getPrototype(JSContext *cx, XPCWrappedNativeScope *scope, bool *enabled)
80063: {
80085:     if (!scope->NewDOMBindingsEnabled()) {
80085:         *enabled = false;
80085:         return NULL;
80085:     }
80085: 
80085:     *enabled = true;
80085: 
80096:     return getPrototype(cx, scope);
80096: }
80096: 
80096: template<class LC>
80096: JSObject *
80096: ListBase<LC>::getPrototype(JSContext *cx, XPCWrappedNativeScope *scope)
80096: {
80079:     nsDataHashtable<nsDepCharHashKey, JSObject*> &cache =
80070:         scope->GetCachedDOMPrototypes();
80070: 
80079:     JSObject *interfacePrototype;
80070:     if (cache.IsInitialized()) {
80079:         if (cache.Get(sInterfaceClass.name, &interfacePrototype))
80079:             return interfacePrototype;
80390:     } else if (!cache.Init()) {
80070:         return NULL;
80070:     }
80070: 
80096:     JSObject* proto = Base::getPrototype(cx, scope);
80096:     if (!proto)
80063:         return NULL;
80070: 
80096:     JSObject *global = scope->GetGlobalJSObject();
80079:     interfacePrototype = JS_NewObject(cx, NULL, proto, global);
80079:     if (!interfacePrototype)
80079:         return NULL;
80079: 
80467:     for (size_t n = 0; n < ArrayLength(sProtoProperties); ++n) {
80095:         JS_ASSERT(sProtoProperties[n].getter);
80087:         jsid id = sProtoProperties[n].id;
80087:         uintN attrs = JSPROP_ENUMERATE | JSPROP_SHARED;
80087:         if (!sProtoProperties[n].setter)
80087:             attrs |= JSPROP_READONLY;
80087:         if (!JS_DefinePropertyById(cx, interfacePrototype, id, JSVAL_VOID,
80087:                                    sProtoProperties[n].getter, sProtoProperties[n].setter, attrs))
80063:             return NULL;
80087:     }
80070: 
80467:     for (size_t n = 0; n < ArrayLength(sProtoMethods); ++n) {
80070:         jsid id = sProtoMethods[n].id;
80070:         JSFunction *fun = JS_NewFunctionById(cx, sProtoMethods[n].native, sProtoMethods[n].nargs,
80079:                                              0, js::GetObjectParent(interfacePrototype), id);
80065:         if (!fun)
80065:             return NULL;
80065:         JSObject *funobj = JS_GetFunctionObject(fun);
80079:         if (!JS_DefinePropertyById(cx, interfacePrototype, id, OBJECT_TO_JSVAL(funobj),
80065:                                    NULL, NULL, JSPROP_ENUMERATE))
80065:             return NULL;
80063:     }
80063: 
80079:     JSObject *interface = JS_NewObject(cx, Jsvalify(&sInterfaceClass), NULL, global);
80079:     if (!interface ||
80087:         !JS_DefinePropertyById(cx, interface, s_prototype_id, OBJECT_TO_JSVAL(interfacePrototype),
80087:                                nsnull, nsnull, JSPROP_PERMANENT | JSPROP_READONLY))
80069:         return NULL;
80069: 
80086:     if (!JS_DefinePropertyById(cx, interfacePrototype, s_constructor_id,
80079:                                OBJECT_TO_JSVAL(interface), nsnull, nsnull, 0))
80079:         return NULL;
80079: 
80079:     if (!JS_DefineProperty(cx, global, sInterfaceClass.name, OBJECT_TO_JSVAL(interface), NULL,
80079:                            NULL, 0))
80079:         return NULL;
80079: 
80079:     if (!cache.Put(sInterfaceClass.name, interfacePrototype))
80079:         return NULL;
80079: 
80079:     return interfacePrototype;
80069: }
80069: 
80095: template<class LC>
80063: JSObject *
80095: ListBase<LC>::create(JSContext *cx, XPCWrappedNativeScope *scope, ListType *aList,
80085:                      nsWrapperCache* aWrapperCache, bool *triedToWrap)
80063: {
80085:     *triedToWrap = true;
80085: 
80095:     JSObject *parent = WrapNativeParent(cx, scope->GetGlobalJSObject(), aList->GetParentObject());
80081:     if (!parent)
80077:         return NULL;
80077: 
80077:     JSAutoEnterCompartment ac;
80077:     if (js::GetObjectGlobal(parent) != scope->GetGlobalJSObject()) {
80077:         if (!ac.enter(cx, parent))
80077:             return NULL;
80077: 
80077:         scope = XPCWrappedNativeScope::FindInJSObjectScope(cx, parent);
80077:     }
80077: 
80085:     JSObject *proto = getPrototype(cx, scope, triedToWrap);
80661:     if (!proto && !*triedToWrap)
80661:         aWrapperCache->ClearIsProxy();
80063:     if (!proto)
80063:         return NULL;
80095:     JSObject *obj = NewProxyObject(cx, &ListBase<LC>::instance,
80095:                                    PrivateValue(aList), proto, parent);
80063:     if (!obj)
80063:         return NULL;
80063: 
80095:     NS_ADDREF(aList);
80063:     setProtoShape(obj, -1);
80063: 
80068:     aWrapperCache->SetWrapper(obj);
80067: 
80063:     return obj;
80063: }
80063: 
80074: static JSObject *
80074: getExpandoObject(JSObject *obj)
80074: {
80074:     NS_ASSERTION(instanceIsProxy(obj), "expected a DOM proxy object");
80074:     Value v = js::GetProxyExtra(obj, JSPROXYSLOT_EXPANDO);
80074:     return v.isUndefined() ? NULL : v.toObjectOrNull();
80074: }
80074: 
80089: static int32
80089: IdToInt32(JSContext *cx, jsid id)
80089: {
80089:     JSAutoRequest ar(cx);
80089: 
80089:     jsval idval;
80089:     jsdouble array_index;
80089:     jsint i;
80089:     if (!::JS_IdToValue(cx, id, &idval) ||
80089:         !::JS_ValueToNumber(cx, idval, &array_index) ||
80089:         !::JS_DoubleIsInt32(array_index, &i)) {
80089:         return -1;
80089:     }
80089: 
80089:     return i;
80089: }
80089: 
80089: static inline int32
80089: GetArrayIndexFromId(JSContext *cx, jsid id)
80089: {
80089:     if (NS_LIKELY(JSID_IS_INT(id)))
80089:         return JSID_TO_INT(id);
80089:     if (NS_LIKELY(id == s_length_id))
80089:         return -1;
80089:     if (NS_LIKELY(JSID_IS_ATOM(id))) {
80089:         JSAtom *atom = JSID_TO_ATOM(id);
80089:         jschar s = *atom->chars();
80089:         if (NS_LIKELY((unsigned)s >= 'a' && (unsigned)s <= 'z'))
80089:             return -1;
80661: 
80661:         jsuint i;
80661:         return js::StringIsArrayIndex(JSID_TO_ATOM(id), &i) ? i : -1;
80089:     }
80089:     return IdToInt32(cx, id);
80089: }
80089: 
80097: static void
80097: FillPropertyDescriptor(PropertyDescriptor *desc, JSObject *obj, jsval v, bool readonly)
80097: {
80097:     desc->obj = obj;
80097:     desc->value = v;
80097:     desc->attrs = (readonly ? JSPROP_READONLY : 0) | JSPROP_ENUMERATE;
80097:     desc->getter = NULL;
80097:     desc->setter = NULL;
80097:     desc->shortid = 0;
80097: }
80097: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::getOwnPropertyDescriptor(JSContext *cx, JSObject *proxy, jsid id, bool set,
80063:                                        PropertyDescriptor *desc)
80063: {
80100:     if (set) {
80100:         if (hasIndexSetter) {
80100:             int32 index = GetArrayIndexFromId(cx, id);
80100:             if (index >= 0) {
80100:                 FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
80100:                 return true;
80100:             }
80100:         }
80100: 
80100:         if (hasNameSetter && JSID_IS_STRING(id)) {
80100:             FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);
80100:             return true;
80100:         }
80390:     } else {
80100:         if (hasIndexGetter) {
80100:             int32 index = GetArrayIndexFromId(cx, id);
80100:             if (index >= 0) {
80100:                 IndexGetterType result;
80100:                 if (!getItemAt(getListObject(proxy), PRUint32(index), result))
80100:                     return true;
80100: 
80100:                 jsval v;
80100:                 if (!Wrap(cx, proxy, result, &v))
80100:                     return false;
80100:                 FillPropertyDescriptor(desc, proxy, v, !hasIndexSetter);
80100:                 return true;
80100:             }
80100:         }
80100:     }
80100: 
80091:     JSObject *expando;
80091:     if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = getExpandoObject(proxy))) {
80074:         uintN flags = (set ? JSRESOLVE_ASSIGNING : 0) | JSRESOLVE_QUALIFIED;
80091:         if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc))
80074:             return false;
80074:         if (desc->obj) {
80074:             // Pretend the property lives on the wrapper.
80074:             desc->obj = proxy;
80074:             return true;
80074:         }
80091:     }
80074: 
80100:     if (hasNameGetter && !set && JSID_IS_STRING(id) && !hasPropertyOnPrototype(cx, proxy, id)) {
80082:         jsval name = STRING_TO_JSVAL(JSID_TO_STRING(id));
80082:         bool hasResult;
80095:         NameGetterType result;
80095:         if (!namedItem(cx, proxy, &name, result, &hasResult))
80082:             return false;
80082:         if (hasResult) {
80082:             jsval v;
80095:             if (!Wrap(cx, proxy, result, &v))
80082:                 return false;
80097:             FillPropertyDescriptor(desc, proxy, v, !hasNameSetter);
80082:             return true;
80082:         }
80095:     }
80078: 
80063:     desc->obj = NULL;
80063:     return true;
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::getPropertyDescriptor(JSContext *cx, JSObject *proxy, jsid id, bool set,
80063:                                     PropertyDescriptor *desc)
80063: {
80063:     if (!getOwnPropertyDescriptor(cx, proxy, id, set, desc))
80063:         return false;
80063:     if (desc->obj)
80063:         return true;
80092:     if (xpc::WrapperFactory::IsXrayWrapper(proxy))
80072:         return resolveNativeName(cx, proxy, id, desc);
80063:     return JS_GetPropertyDescriptorById(cx, js::GetObjectProto(proxy), id, JSRESOLVE_QUALIFIED,
80063:                                         desc);
80063: }
80063: 
80074: JSClass ExpandoClass = {
80074:     "DOM proxy binding expando object",
80074:     JSCLASS_HAS_PRIVATE,
80074:     JS_PropertyStub,
80074:     JS_PropertyStub,
80074:     JS_PropertyStub,
80074:     JS_StrictPropertyStub,
80074:     JS_EnumerateStub,
80074:     JS_ResolveStub,
80074:     JS_ConvertStub
80074: };
80074: 
80095: template<class LC>
80074: JSObject *
80095: ListBase<LC>::ensureExpandoObject(JSContext *cx, JSObject *obj)
80074: {
80074:     NS_ASSERTION(instanceIsProxy(obj), "expected a DOM proxy object");
80074:     JSObject *expando = getExpandoObject(obj);
80074:     if (!expando) {
80074:         expando = JS_NewObjectWithGivenProto(cx, &ExpandoClass, nsnull,
80074:                                              js::GetObjectParent(obj));
80074:         if (!expando)
80074:             return NULL;
80074: 
80074:         JSCompartment *compartment = js::GetObjectCompartment(obj);
80074:         xpc::CompartmentPrivate *priv =
80074:             static_cast<xpc::CompartmentPrivate *>(js_GetCompartmentPrivate(compartment));
80074:         if (!priv->RegisterDOMExpandoObject(expando))
80074:             return NULL;
80074: 
80074:         js::SetProxyExtra(obj, JSPROXYSLOT_EXPANDO, ObjectValue(*expando));
80074:         expando->setPrivate(js::GetProxyPrivate(obj).toPrivate());
80074:     }
80074:     return expando;
80074: }
80074: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::defineProperty(JSContext *cx, JSObject *proxy, jsid id, PropertyDescriptor *desc)
80063: {
80100:     if (hasIndexSetter) {
80100:         int32 index = GetArrayIndexFromId(cx, id);
80100:         if (index >= 0) {
80100:             nsCOMPtr<nsISupports> ref;
80100:             IndexSetterType value;
80100:             jsval v;
80100:             return Unwrap(cx, desc->value, &value, getter_AddRefs(ref), &v) &&
81554:                    setItemAt(cx, getListObject(proxy), index, value);
80100:         }
80100:     }
80100: 
80097:     if (hasNameSetter && JSID_IS_STRING(id)) {
80097:         jsval name = STRING_TO_JSVAL(JSID_TO_STRING(id));
80097:         xpc_qsDOMString nameString(cx, name, &name,
80097:                                    xpc_qsDOMString::eDefaultNullBehavior,
80097:                                    xpc_qsDOMString::eDefaultUndefinedBehavior);
80097:         if (!nameString.IsValid())
80097:             return false;
80097: 
80097:         nsCOMPtr<nsISupports> ref;
80097:         NameSetterType value;
80097:         jsval v;
80100:         if (!Unwrap(cx, desc->value, &value, getter_AddRefs(ref), &v))
80100:             return false;
81554:         return setNamedItem(cx, getListObject(proxy), nameString, value);
80097:     }
80097: 
80091:     if (xpc::WrapperFactory::IsXrayWrapper(proxy))
80091:         return true;
80091: 
80074:     JSObject *expando = ensureExpandoObject(cx, proxy);
80074:     if (!expando)
80074:         return false;
80074: 
80074:     return JS_DefinePropertyById(cx, expando, id, desc->value, desc->getter, desc->setter,
80074:                                  desc->attrs);
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::getOwnPropertyNames(JSContext *cx, JSObject *proxy, AutoIdVector &props)
80063: {
80063:     PRUint32 length;
80093:     getListObject(proxy)->GetLength(&length);
80063:     JS_ASSERT(int32(length) >= 0);
80063:     for (int32 i = 0; i < int32(length); ++i) {
80063:         if (!props.append(INT_TO_JSID(i)))
80063:             return false;
80063:     }
80100: 
80100:     JSObject *expando;
80100:     if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = getExpandoObject(proxy)) &&
80100:         !GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props))
80100:         return false;
80100: 
80100:     // FIXME: Add named items
80063:     return true;
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::delete_(JSContext *cx, JSObject *proxy, jsid id, bool *bp)
80063: {
80074:     JSBool b = true;
80074: 
80074:     JSObject *expando;
80074:     if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = getExpandoObject(proxy))) {
80074:         jsval v;
80074:         if (!JS_DeletePropertyById2(cx, expando, id, &v) ||
80074:             !JS_ValueToBoolean(cx, v, &b)) {
80074:             return false;
80074:         }
80074:     }
80074: 
80074:     *bp = !!b;
80063:     return true;
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::enumerate(JSContext *cx, JSObject *proxy, AutoIdVector &props)
80063: {
80063:     // FIXME: enumerate proto as well
80063:     return getOwnPropertyNames(cx, proxy, props);
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::fix(JSContext *cx, JSObject *proxy, Value *vp)
80063: {
80063:     vp->setUndefined();
80063:     return true;
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::hasOwn(JSContext *cx, JSObject *proxy, jsid id, bool *bp)
80063: {
80100:     if (hasIndexGetter) {
80100:         int32 index = GetArrayIndexFromId(cx, id);
80100:         if (index >= 0) {
80100:             IndexGetterType result;
80100:             *bp = getItemAt(getListObject(proxy), PRUint32(index), result);
80100:             return true;
80100:         }
80100:     }
80100: 
80074:     JSObject *expando = getExpandoObject(proxy);
80074:     if (expando) {
80074:         JSBool b = JS_TRUE;
80074:         JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
80074:         *bp = !!b;
80074:         if (!ok || *bp)
80074:             return ok;
80074:     }
80074: 
80100:     if (hasNameGetter && JSID_IS_STRING(id) && !hasPropertyOnPrototype(cx, proxy, id)) {
80082:         jsval name = STRING_TO_JSVAL(JSID_TO_STRING(id));
80095:         NameGetterType result;
80095:         return namedItem(cx, proxy, &name, result, bp);
80082:     }
80082: 
80063:     *bp = false;
80063:     return true;
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::has(JSContext *cx, JSObject *proxy, jsid id, bool *bp)
80063: {
80886:     if (!hasOwn(cx, proxy, id, bp))
80886:         return false;
80886:     // We have the property ourselves; no need to worry about our
80886:     // prototype chain.
80886:     if (*bp)
80886:         return true;
80886: 
80886:     // OK, now we have to look at the proto
80886:     JSObject *proto = js::GetObjectProto(proxy);
80886:     if (!proto)
80886:         return true;
80886: 
80886:     JSBool protoHasProp;
80886:     bool ok = JS_HasPropertyById(cx, proto, id, &protoHasProp);
80886:     if (ok)
80886:         *bp = protoHasProp;
80886:     return ok;
80063: }
80063: 
80095: template<class LC>
80063: bool
80096: ListBase<LC>::shouldCacheProtoShape(JSContext *cx, JSObject *proto, bool *shouldCache)
80066: {
80066:     JSPropertyDescriptor desc;
80467:     for (size_t n = 0; n < ArrayLength(sProtoProperties); ++n) {
80087:         jsid id = sProtoProperties[n].id;
80087:         if (!JS_GetPropertyDescriptorById(cx, proto, id, JSRESOLVE_QUALIFIED, &desc))
80066:             return false;
80087:         if (desc.obj != proto || desc.getter != sProtoProperties[n].getter ||
80096:             desc.setter != sProtoProperties[n].setter) {
80096:             *shouldCache = false;
80096:             return true;
80096:         }
80087:     }
80070: 
80467:     for (size_t n = 0; n < ArrayLength(sProtoMethods); ++n) {
80070:         jsid id = sProtoMethods[n].id;
80070:         if (!JS_GetPropertyDescriptorById(cx, proto, id, JSRESOLVE_QUALIFIED, &desc))
80066:             return false;
80066:         if (desc.obj != proto || desc.getter || JSVAL_IS_PRIMITIVE(desc.value) ||
80070:             n >= js::GetNumSlots(proto) || js::GetSlot(proto, n) != desc.value ||
80070:             !JS_IsNativeFunction(JSVAL_TO_OBJECT(desc.value), sProtoMethods[n].native)) {
80096:             *shouldCache = false;
80096:             return true;
80066:         }
80070:     }
80070: 
80096:     return Base::shouldCacheProtoShape(cx, js::GetObjectProto(proto), shouldCache);
80066: }
80066: 
80095: template<class LC>
80066: bool
80095: ListBase<LC>::resolveNativeName(JSContext *cx, JSObject *proxy, jsid id, PropertyDescriptor *desc)
80072: {
80092:     JS_ASSERT(xpc::WrapperFactory::IsXrayWrapper(proxy));
80072: 
80467:     for (size_t n = 0; n < ArrayLength(sProtoProperties); ++n) {
80087:         if (id == sProtoProperties[n].id) {
80087:             desc->attrs = JSPROP_ENUMERATE | JSPROP_SHARED;
80087:             if (!sProtoProperties[n].setter)
80087:                 desc->attrs |= JSPROP_READONLY;
80072:             desc->obj = proxy;
80087:             desc->setter = sProtoProperties[n].setter;
80087:             desc->getter = sProtoProperties[n].getter;
80072:             return true;
80072:         }
80087:     }
80072: 
80467:     for (size_t n = 0; n < ArrayLength(sProtoMethods); ++n) {
80072:         if (id == sProtoMethods[n].id) {
80072:             JSFunction *fun = JS_NewFunctionById(cx, sProtoMethods[n].native,
80072:                                                  sProtoMethods[n].nargs, 0, proxy, id);
80072:             if (!fun)
80072:                 return false;
80072:             JSObject *funobj = JS_GetFunctionObject(fun);
80072:             desc->value.setObject(*funobj);
80072:             desc->attrs = JSPROP_ENUMERATE;
80072:             desc->obj = proxy;
80072:             desc->setter = nsnull;
80072:             desc->getter = nsnull;
80072:             return true;
80072:         }
80072:     }
80072: 
80096:     return Base::resolveNativeName(cx, proxy, id, desc);
80072: }
80072: 
80095: template<class LC>
80072: bool
80095: ListBase<LC>::nativeGet(JSContext *cx, JSObject *proxy, JSObject *proto, jsid id, bool *found, Value *vp)
80095: {
80096: #ifdef DEBUG
80096:     bool shouldCache;
80096:     JS_ASSERT(shouldCacheProtoShape(cx, proto, &shouldCache) && shouldCache);
80096: #endif
80096: 
80467:     for (size_t n = 0; n < ArrayLength(sProtoProperties); ++n) {
80095:         if (id == sProtoProperties[n].id) {
80095:             *found = true;
80095:             if (!vp)
80095:                 return true;
80095: 
80095:             return sProtoProperties[n].getter(cx, proxy, id, vp);
80095:         }
80095:     }
80467:     for (size_t n = 0; n < ArrayLength(sProtoMethods); ++n) {
80095:         if (id == sProtoMethods[n].id) {
80095:             *found = true;
80095:             if (!vp)
80095:                 return true;
80095: 
80095:             *vp = js::GetSlot(proto, n);
80095:             JS_ASSERT(JS_IsNativeFunction(&vp->toObject(), sProtoMethods[n].native));
80095:             return true;
80095:         }
80095:     }
80095: 
80096:     return Base::nativeGet(cx, proxy, js::GetObjectProto(proto), id, found, vp);
80095: }
80095: 
80095: template<class LC>
80095: bool
80100: ListBase<LC>::getPropertyOnPrototype(JSContext *cx, JSObject *proxy, jsid id, bool *found,
80100:                                      js::Value *vp)
80100: {
80100:     JSObject *proto = js::GetObjectProto(proxy);
80343:     if (!proto)
80343:         return true;
80343: 
80100:     bool hit;
80100:     if (getProtoShape(proxy) != js::GetObjectShape(proto)) {
80100:         if (!shouldCacheProtoShape(cx, proto, &hit))
80100:             return false;
80100:         if (hit)
80100:             setProtoShape(proxy, js::GetObjectShape(proto));
80390:     } else {
80100:         hit = true;
80100:     }
80100: 
80100:     if (hit) {
80100:         if (id == s_length_id) {
80100:             if (vp) {
80100:                 PRUint32 length;
80100:                 getListObject(proxy)->GetLength(&length);
80100:                 JS_ASSERT(int32(length) >= 0);
80100:                 vp->setInt32(length);
80100:             }
80100:             *found = true;
80100:             return true;
80100:         }
80100:         if (!nativeGet(cx, proxy, proto, id, found, vp))
80100:             return false;
80100:         if (*found)
80100:             return true;
80100:     }
80100: 
80100:     JSBool hasProp;
80100:     if (!JS_HasPropertyById(cx, proto, id, &hasProp))
80100:         return false;
80100: 
80100:     *found = hasProp;
80100:     if (!hasProp || !vp)
80100:         return true;
80100: 
81415:     return JS_ForwardGetPropertyTo(cx, proto, id, proxy, vp);
80100: }
80100: 
80100: template<class LC>
80100: bool
80100: ListBase<LC>::hasPropertyOnPrototype(JSContext *cx, JSObject *proxy, jsid id)
80100: {
80100:     JSAutoEnterCompartment ac;
80100:     if (xpc::WrapperFactory::IsXrayWrapper(proxy)) {
80100:         proxy = js::UnwrapObject(proxy);
80100:         if (!ac.enter(cx, proxy))
80100:             return false;
80100:     }
80100:     JS_ASSERT(objIsList(proxy));
80100: 
80100:     bool found;
80100:     // We ignore an error from getPropertyOnPrototype.
80100:     return !getPropertyOnPrototype(cx, proxy, id, &found, NULL) || found;
80100: }
80100: 
80100: template<class LC>
80100: bool
80095: ListBase<LC>::get(JSContext *cx, JSObject *proxy, JSObject *receiver, jsid id, Value *vp)
80063: {
80100:     if (hasIndexGetter) {
80100:         int32 index = GetArrayIndexFromId(cx, id);
80100:         if (index >= 0) {
80100:             IndexGetterType result;
80100:             if (!getItemAt(getListObject(proxy), PRUint32(index), result)) {
80100:                 vp->setUndefined();
80100:                 return true;
80100:             }
80100:             return Wrap(cx, proxy, result, vp);
80100:         }
80100:     }
80100: 
80074:     JSObject *expando = getExpandoObject(proxy);
80074:     if (expando) {
80074:         JSBool hasProp;
80074:         if (!JS_HasPropertyById(cx, expando, id, &hasProp))
80074:             return false;
80100: 
80074:         if (hasProp)
80074:             return JS_GetPropertyById(cx, expando, id, vp);
80074:     }
80074: 
80100:     bool found;
80100:     if (!getPropertyOnPrototype(cx, proxy, id, &found, vp))
80100:         return false;
80100: 
80100:     if (found)
80100:         return true;
80100: 
80100:     if (hasNameGetter && JSID_IS_STRING(id)) {
80082:         jsval name = STRING_TO_JSVAL(JSID_TO_STRING(id));
80082:         bool hasResult;
80095:         NameGetterType result;
80095:         if (!namedItem(cx, proxy, &name, result, &hasResult))
80082:             return false;
80082:         if (hasResult)
80095:             return Wrap(cx, proxy, result, vp);
80082:     }
80082: 
80100:     vp->setUndefined();
80064:     return true;
80066: }
80063: 
80095: template<class LC>
80063: bool
81420: ListBase<LC>::getElementIfPresent(JSContext *cx, JSObject *proxy, JSObject *receiver,
81420:                                   uint32 index, Value *vp, bool *present)
81420: {
81420:     if (hasIndexGetter) {
81420:         IndexGetterType result;
81420:         *present = getItemAt(getListObject(proxy), index, result);
81420:         if (*present)
81420:             return Wrap(cx, proxy, result, vp);
81420: 
81420:         vp->setUndefined();
81420:         return true;
81420:     }
81420: 
81420:     jsid id;
81420:     if (!JS_IndexToId(cx, index, &id))
81420:         return false;
81420: 
81420:     JSObject *expando = getExpandoObject(proxy);
81420:     if (expando) {
81420:         JSBool isPresent;
81420:         if (!JS_GetElementIfPresent(cx, expando, index, expando, vp, &isPresent))
81420:             return false;
81420:         if (isPresent) {
81420:             *present = true;
81420:             return true;
81420:         }
81420:     }
81420: 
81420:     // No need to worry about name getters here, so just check the proto.
81420: 
81420:     JSObject *proto = js::GetObjectProto(proxy);
81420:     if (proto) {
81420:         JSBool isPresent;
81420:         if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent))
81420:             return false;
81420:         *present = isPresent;
81420:         return true;
81420:     }
81420: 
81420:     *present = false;
81420:     // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
81420:     return true;
81420: }
81420: 
81420: template<class LC>
81420: bool
80095: ListBase<LC>::set(JSContext *cx, JSObject *proxy, JSObject *receiver, jsid id, bool strict,
80066:                   Value *vp)
80063: {
80074:     return ProxyHandler::set(cx, proxy, proxy, id, strict, vp);
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::keys(JSContext *cx, JSObject *proxy, AutoIdVector &props)
80063: {
80074:     return ProxyHandler::keys(cx, proxy, props);
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::iterate(JSContext *cx, JSObject *proxy, uintN flags, Value *vp)
80063: {
80080:     return ProxyHandler::iterate(cx, proxy, flags, vp);
80063: }
80063: 
80095: template<class LC>
80063: bool
80095: ListBase<LC>::hasInstance(JSContext *cx, JSObject *proxy, const Value *vp, bool *bp)
80063: {
80079:     *bp = vp->isObject() && js::GetObjectClass(&vp->toObject()) == &sInterfaceClass;
80063:     return true;
80063: }
80063: 
80095: template<class LC>
80063: JSString *
80095: ListBase<LC>::obj_toString(JSContext *cx, JSObject *proxy)
80068: {
80090:     const char *clazz = sInterfaceClass.name;
80090:     size_t nchars = 9 + strlen(clazz); /* 9 for "[object ]" */
80090:     jschar *chars = (jschar *)JS_malloc(cx, (nchars + 1) * sizeof(jschar));
80090:     if (!chars)
80090:         return NULL;
80068: 
80090:     const char *prefix = "[object ";
80090:     nchars = 0;
80090:     while ((chars[nchars] = (jschar)*prefix) != 0)
80090:         nchars++, prefix++;
80090:     while ((chars[nchars] = (jschar)*clazz) != 0)
80090:         nchars++, clazz++;
80090:     chars[nchars++] = ']';
80090:     chars[nchars] = 0;
80090: 
80090:     JSString *str = JS_NewUCString(cx, chars, nchars);
80090:     if (!str)
80090:         JS_free(cx, chars);
80090:     return str;
80063: }
80063: 
80095: template<class LC>
80063: void
80095: ListBase<LC>::finalize(JSContext *cx, JSObject *proxy)
80063: {
80095:     ListType *list = getListObject(proxy);
80067:     nsWrapperCache *cache;
80093:     CallQueryInterface(list, &cache);
80067:     if (cache) {
80067:         cache->ClearWrapper();
80067:     }
80093:     NS_RELEASE(list);
80063: }
80063: 
80094: 
80096: JSObject*
80096: NoBase::getPrototype(JSContext *cx, XPCWrappedNativeScope *scope)
80096: {
80096:     // We need to pass the object prototype to JS_NewObject. If we pass NULL then the JS engine
80096:     // will look up a prototype on the global by using the class' name and we'll recurse into
80096:     // getPrototype.
80096:     JSObject* proto;
80096:     if (!js_GetClassPrototype(cx, scope->GetGlobalJSObject(), JSProto_Object, &proto))
80096:         return NULL;
80096:     return proto;
80096: }
80096: 
80096: 
80094: }
80094: }
80094: }
80098: #include "dombindings_gen.cpp"
