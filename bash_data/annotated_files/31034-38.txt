16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: residue backend 0, 1 and 2 implementation
31034:  last mod: $Id: res0.c 16327 2009-07-24 00:49:25Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: /* Slow, slow, slow, simpleminded and did I mention it was slow?  The
16295:    encode/decode loops are coded for clarity and performance is not
16295:    yet even a nagging little idea lurking in the shadows.  Oh and BTW,
16295:    it's slow. */
16295: 
16295: #include <stdlib.h>
16295: #include <string.h>
16295: #include <math.h>
16295: #include <ogg/ogg.h>
16295: #include "vorbis/codec.h"
16295: #include "codec_internal.h"
16295: #include "registry.h"
16295: #include "codebook.h"
16295: #include "misc.h"
16295: #include "os.h"
16295: 
16295: #if defined(TRAIN_RES) || defined (TRAIN_RESAUX)
16295: #include <stdio.h>
16295: #endif
16295: 
16295: typedef struct {
16295:   vorbis_info_residue0 *info;
16295: 
16295:   int         parts;
16295:   int         stages;
16295:   codebook   *fullbooks;
16295:   codebook   *phrasebook;
16295:   codebook ***partbooks;
16295: 
16295:   int         partvals;
16295:   int       **decodemap;
16295: 
16295:   long      postbits;
16295:   long      phrasebits;
16295:   long      frames;
16295: 
16295: #if defined(TRAIN_RES) || defined(TRAIN_RESAUX)
16295:   int        train_seq;
16295:   long      *training_data[8][64];
16295:   float      training_max[8][64];
16295:   float      training_min[8][64];
16295:   float     tmin;
16295:   float     tmax;
16295: #endif
16295: 
16295: } vorbis_look_residue0;
16295: 
16295: void res0_free_info(vorbis_info_residue *i){
16295:   vorbis_info_residue0 *info=(vorbis_info_residue0 *)i;
16295:   if(info){
16295:     memset(info,0,sizeof(*info));
16295:     _ogg_free(info);
16295:   }
16295: }
16295: 
16295: void res0_free_look(vorbis_look_residue *i){
16295:   int j;
16295:   if(i){
16295: 
16295:     vorbis_look_residue0 *look=(vorbis_look_residue0 *)i;
16295: 
16295: #ifdef TRAIN_RES
16295:     {
16295:       int j,k,l;
16295:       for(j=0;j<look->parts;j++){
16295:         /*fprintf(stderr,"partition %d: ",j);*/
16295:         for(k=0;k<8;k++)
16295:           if(look->training_data[k][j]){
16295:             char buffer[80];
16295:             FILE *of;
16295:             codebook *statebook=look->partbooks[j][k];
16295: 
16295:             /* long and short into the same bucket by current convention */
16295:             sprintf(buffer,"res_part%d_pass%d.vqd",j,k);
16295:             of=fopen(buffer,"a");
16295: 
16295:             for(l=0;l<statebook->entries;l++)
16295:               fprintf(of,"%d:%ld\n",l,look->training_data[k][j][l]);
16295: 
16295:             fclose(of);
16295: 
16295:             /*fprintf(stderr,"%d(%.2f|%.2f) ",k,
16295:               look->training_min[k][j],look->training_max[k][j]);*/
16295: 
16295:             _ogg_free(look->training_data[k][j]);
16295:             look->training_data[k][j]=NULL;
16295:           }
16295:         /*fprintf(stderr,"\n");*/
16295:       }
16295:     }
16295:     fprintf(stderr,"min/max residue: %g::%g\n",look->tmin,look->tmax);
16295: 
16295:     /*fprintf(stderr,"residue bit usage %f:%f (%f total)\n",
16295:             (float)look->phrasebits/look->frames,
16295:             (float)look->postbits/look->frames,
16295:             (float)(look->postbits+look->phrasebits)/look->frames);*/
16295: #endif
16295: 
16295: 
16295:     /*vorbis_info_residue0 *info=look->info;
16295: 
16295:     fprintf(stderr,
16295:             "%ld frames encoded in %ld phrasebits and %ld residue bits "
16295:             "(%g/frame) \n",look->frames,look->phrasebits,
16295:             look->resbitsflat,
16295:             (look->phrasebits+look->resbitsflat)/(float)look->frames);
16295: 
16295:     for(j=0;j<look->parts;j++){
16295:       long acc=0;
16295:       fprintf(stderr,"\t[%d] == ",j);
16295:       for(k=0;k<look->stages;k++)
16295:         if((info->secondstages[j]>>k)&1){
16295:           fprintf(stderr,"%ld,",look->resbits[j][k]);
16295:           acc+=look->resbits[j][k];
16295:         }
16295: 
16295:       fprintf(stderr,":: (%ld vals) %1.2fbits/sample\n",look->resvals[j],
16295:               acc?(float)acc/(look->resvals[j]*info->grouping):0);
16295:     }
16295:     fprintf(stderr,"\n");*/
16295: 
16295:     for(j=0;j<look->parts;j++)
16295:       if(look->partbooks[j])_ogg_free(look->partbooks[j]);
16295:     _ogg_free(look->partbooks);
16295:     for(j=0;j<look->partvals;j++)
16295:       _ogg_free(look->decodemap[j]);
16295:     _ogg_free(look->decodemap);
16295: 
16295:     memset(look,0,sizeof(*look));
16295:     _ogg_free(look);
16295:   }
16295: }
16295: 
16295: static int ilog(unsigned int v){
16295:   int ret=0;
16295:   while(v){
16295:     ret++;
16295:     v>>=1;
16295:   }
16295:   return(ret);
16295: }
16295: 
16295: static int icount(unsigned int v){
16295:   int ret=0;
16295:   while(v){
16295:     ret+=v&1;
16295:     v>>=1;
16295:   }
16295:   return(ret);
16295: }
16295: 
16295: 
16295: void res0_pack(vorbis_info_residue *vr,oggpack_buffer *opb){
16295:   vorbis_info_residue0 *info=(vorbis_info_residue0 *)vr;
16295:   int j,acc=0;
16295:   oggpack_write(opb,info->begin,24);
16295:   oggpack_write(opb,info->end,24);
16295: 
16295:   oggpack_write(opb,info->grouping-1,24);  /* residue vectors to group and
16295:                                              code with a partitioned book */
16295:   oggpack_write(opb,info->partitions-1,6); /* possible partition choices */
16295:   oggpack_write(opb,info->groupbook,8);  /* group huffman book */
16295: 
16295:   /* secondstages is a bitmask; as encoding progresses pass by pass, a
16295:      bitmask of one indicates this partition class has bits to write
16295:      this pass */
16295:   for(j=0;j<info->partitions;j++){
16295:     if(ilog(info->secondstages[j])>3){
16295:       /* yes, this is a minor hack due to not thinking ahead */
16295:       oggpack_write(opb,info->secondstages[j],3);
16295:       oggpack_write(opb,1,1);
16295:       oggpack_write(opb,info->secondstages[j]>>3,5);
16295:     }else
16295:       oggpack_write(opb,info->secondstages[j],4); /* trailing zero */
16295:     acc+=icount(info->secondstages[j]);
16295:   }
16295:   for(j=0;j<acc;j++)
16295:     oggpack_write(opb,info->booklist[j],8);
16295: 
16295: }
16295: 
16295: /* vorbis_info is for range checking */
16295: vorbis_info_residue *res0_unpack(vorbis_info *vi,oggpack_buffer *opb){
16295:   int j,acc=0;
16295:   vorbis_info_residue0 *info=_ogg_calloc(1,sizeof(*info));
16295:   codec_setup_info     *ci=vi->codec_setup;
16295: 
16295:   info->begin=oggpack_read(opb,24);
16295:   info->end=oggpack_read(opb,24);
16295:   info->grouping=oggpack_read(opb,24)+1;
16295:   info->partitions=oggpack_read(opb,6)+1;
16295:   info->groupbook=oggpack_read(opb,8);
16295: 
31034:   /* check for premature EOP */
31034:   if(info->groupbook<0)goto errout;
31034: 
16295:   for(j=0;j<info->partitions;j++){
16295:     int cascade=oggpack_read(opb,3);
31034:     int cflag=oggpack_read(opb,1);
31034:     if(cflag<0) goto errout;
31034:     if(cflag){
31034:       int c=oggpack_read(opb,5);
31034:       if(c<0) goto errout;
31034:       cascade|=(c<<3);
31034:     }
16295:     info->secondstages[j]=cascade;
16295: 
16295:     acc+=icount(cascade);
16295:   }
31034:   for(j=0;j<acc;j++){
31034:     int book=oggpack_read(opb,8);
31034:     if(book<0) goto errout;
31034:     info->booklist[j]=book;
31034:   }
16295: 
16295:   if(info->groupbook>=ci->books)goto errout;
30043:   for(j=0;j<acc;j++){
16295:     if(info->booklist[j]>=ci->books)goto errout;
30043:     if(ci->book_param[info->booklist[j]]->maptype==0)goto errout;
30043:   }
30043: 
30043:   /* verify the phrasebook is not specifying an impossible or
30043:      inconsistent partitioning scheme. */
30043:   {
30043:     int entries = ci->book_param[info->groupbook]->entries;
30043:     int dim = ci->book_param[info->groupbook]->dim;
30043:     int partvals = 1;
30043:     while(dim>0){
30043:       partvals *= info->partitions;
30043:       if(partvals > entries) goto errout;
30043:       dim--;
30043:     }
31034:     if(partvals < entries) goto errout;
30043:   }
16295: 
16295:   return(info);
16295:  errout:
16295:   res0_free_info(info);
16295:   return(NULL);
16295: }
16295: 
16295: vorbis_look_residue *res0_look(vorbis_dsp_state *vd,
16295:                                vorbis_info_residue *vr){
16295:   vorbis_info_residue0 *info=(vorbis_info_residue0 *)vr;
16295:   vorbis_look_residue0 *look=_ogg_calloc(1,sizeof(*look));
16295:   codec_setup_info     *ci=vd->vi->codec_setup;
16295: 
16295:   int j,k,acc=0;
16295:   int dim;
16295:   int maxstage=0;
16295:   look->info=info;
16295: 
16295:   look->parts=info->partitions;
16295:   look->fullbooks=ci->fullbooks;
16295:   look->phrasebook=ci->fullbooks+info->groupbook;
16295:   dim=look->phrasebook->dim;
16295: 
16295:   look->partbooks=_ogg_calloc(look->parts,sizeof(*look->partbooks));
16295: 
16295:   for(j=0;j<look->parts;j++){
16295:     int stages=ilog(info->secondstages[j]);
16295:     if(stages){
16295:       if(stages>maxstage)maxstage=stages;
16295:       look->partbooks[j]=_ogg_calloc(stages,sizeof(*look->partbooks[j]));
16295:       for(k=0;k<stages;k++)
16295:         if(info->secondstages[j]&(1<<k)){
16295:           look->partbooks[j][k]=ci->fullbooks+info->booklist[acc++];
16295: #ifdef TRAIN_RES
16295:           look->training_data[k][j]=_ogg_calloc(look->partbooks[j][k]->entries,
16295:                                            sizeof(***look->training_data));
16295: #endif
16295:         }
16295:     }
16295:   }
16295: 
30043:   look->partvals=1;
30043:   for(j=0;j<dim;j++)
30043:       look->partvals*=look->parts;
30043: 
16295:   look->stages=maxstage;
16295:   look->decodemap=_ogg_malloc(look->partvals*sizeof(*look->decodemap));
16295:   for(j=0;j<look->partvals;j++){
16295:     long val=j;
16295:     long mult=look->partvals/look->parts;
16295:     look->decodemap[j]=_ogg_malloc(dim*sizeof(*look->decodemap[j]));
16295:     for(k=0;k<dim;k++){
16295:       long deco=val/mult;
16295:       val-=deco*mult;
16295:       mult/=look->parts;
16295:       look->decodemap[j][k]=deco;
16295:     }
16295:   }
16295: #if defined(TRAIN_RES) || defined (TRAIN_RESAUX)
16295:   {
16295:     static int train_seq=0;
16295:     look->train_seq=train_seq++;
16295:   }
16295: #endif
16295:   return(look);
16295: }
16295: 
16295: /* break an abstraction and copy some code for performance purposes */
16295: static int local_book_besterror(codebook *book,float *a){
16295:   int dim=book->dim,i,k,o;
16295:   int best=0;
16295:   encode_aux_threshmatch *tt=book->c->thresh_tree;
16295: 
16295:   /* find the quant val of each scalar */
16295:   for(k=0,o=dim;k<dim;++k){
16295:     float val=a[--o];
16295:     i=tt->threshvals>>1;
16295: 
16295:     if(val<tt->quantthresh[i]){
16295:       if(val<tt->quantthresh[i-1]){
16295:         for(--i;i>0;--i)
16295:           if(val>=tt->quantthresh[i-1])
16295:             break;
16295:       }
16295:     }else{
16295: 
16295:       for(++i;i<tt->threshvals-1;++i)
16295:         if(val<tt->quantthresh[i])break;
16295: 
16295:     }
16295: 
16295:     best=(best*tt->quantvals)+tt->quantmap[i];
16295:   }
16295:   /* regular lattices are easy :-) */
16295: 
16295:   if(book->c->lengthlist[best]<=0){
16295:     const static_codebook *c=book->c;
16295:     int i,j;
16295:     float bestf=0.f;
16295:     float *e=book->valuelist;
16295:     best=-1;
16295:     for(i=0;i<book->entries;i++){
16295:       if(c->lengthlist[i]>0){
16295:         float this=0.f;
16295:         for(j=0;j<dim;j++){
16295:           float val=(e[j]-a[j]);
16295:           this+=val*val;
16295:         }
16295:         if(best==-1 || this<bestf){
16295:           bestf=this;
16295:           best=i;
16295:         }
16295:       }
16295:       e+=dim;
16295:     }
16295:   }
16295: 
16295:   if(best>-1){
16295:     float *ptr=book->valuelist+best*dim;
16295:     for(i=0;i<dim;i++)
16295:       *a++ -= *ptr++;
16295:   }
16295: 
16295:   return(best);
16295: }
16295: 
16295: static int _encodepart(oggpack_buffer *opb,float *vec, int n,
16295:                        codebook *book,long *acc){
16295:   int i,bits=0;
16295:   int dim=book->dim;
16295:   int step=n/dim;
16295: 
16295:   for(i=0;i<step;i++){
16295:     int entry=local_book_besterror(book,vec+i*dim);
16295: 
16295: #ifdef TRAIN_RES
16295:     if(entry>0)
16295:       acc[entry]++;
16295: #endif
16295: 
16295:     bits+=vorbis_book_encode(book,entry,opb);
16295: 
16295:   }
16295: 
16295:   return(bits);
16295: }
16295: 
16295: static long **_01class(vorbis_block *vb,vorbis_look_residue *vl,
16295:                        float **in,int ch){
16295:   long i,j,k;
16295:   vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
16295:   vorbis_info_residue0 *info=look->info;
16295: 
16295:   /* move all this setup out later */
16295:   int samples_per_partition=info->grouping;
16295:   int possible_partitions=info->partitions;
16295:   int n=info->end-info->begin;
16295: 
16295:   int partvals=n/samples_per_partition;
16295:   long **partword=_vorbis_block_alloc(vb,ch*sizeof(*partword));
16295:   float scale=100./samples_per_partition;
16295: 
16295:   /* we find the partition type for each partition of each
16295:      channel.  We'll go back and do the interleaved encoding in a
16295:      bit.  For now, clarity */
16295: 
16295:   for(i=0;i<ch;i++){
16295:     partword[i]=_vorbis_block_alloc(vb,n/samples_per_partition*sizeof(*partword[i]));
16295:     memset(partword[i],0,n/samples_per_partition*sizeof(*partword[i]));
16295:   }
16295: 
16295:   for(i=0;i<partvals;i++){
16295:     int offset=i*samples_per_partition+info->begin;
16295:     for(j=0;j<ch;j++){
16295:       float max=0.;
16295:       float ent=0.;
16295:       for(k=0;k<samples_per_partition;k++){
16295:         if(fabs(in[j][offset+k])>max)max=fabs(in[j][offset+k]);
16295:         ent+=fabs(rint(in[j][offset+k]));
16295:       }
16295:       ent*=scale;
16295: 
16295:       for(k=0;k<possible_partitions-1;k++)
16295:         if(max<=info->classmetric1[k] &&
16295:            (info->classmetric2[k]<0 || (int)ent<info->classmetric2[k]))
16295:           break;
16295: 
16295:       partword[j][i]=k;
16295:     }
16295:   }
16295: 
16295: #ifdef TRAIN_RESAUX
16295:   {
16295:     FILE *of;
16295:     char buffer[80];
16295: 
16295:     for(i=0;i<ch;i++){
16295:       sprintf(buffer,"resaux_%d.vqd",look->train_seq);
16295:       of=fopen(buffer,"a");
16295:       for(j=0;j<partvals;j++)
16295:         fprintf(of,"%ld, ",partword[i][j]);
16295:       fprintf(of,"\n");
16295:       fclose(of);
16295:     }
16295:   }
16295: #endif
16295:   look->frames++;
16295: 
16295:   return(partword);
16295: }
16295: 
16295: /* designed for stereo or other modes where the partition size is an
16295:    integer multiple of the number of channels encoded in the current
16295:    submap */
16295: static long **_2class(vorbis_block *vb,vorbis_look_residue *vl,float **in,
16295:                       int ch){
16295:   long i,j,k,l;
16295:   vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
16295:   vorbis_info_residue0 *info=look->info;
16295: 
16295:   /* move all this setup out later */
16295:   int samples_per_partition=info->grouping;
16295:   int possible_partitions=info->partitions;
16295:   int n=info->end-info->begin;
16295: 
16295:   int partvals=n/samples_per_partition;
16295:   long **partword=_vorbis_block_alloc(vb,sizeof(*partword));
16295: 
16295: #if defined(TRAIN_RES) || defined (TRAIN_RESAUX)
16295:   FILE *of;
16295:   char buffer[80];
16295: #endif
16295: 
16295:   partword[0]=_vorbis_block_alloc(vb,n*ch/samples_per_partition*sizeof(*partword[0]));
16295:   memset(partword[0],0,n*ch/samples_per_partition*sizeof(*partword[0]));
16295: 
16295:   for(i=0,l=info->begin/ch;i<partvals;i++){
16295:     float magmax=0.f;
16295:     float angmax=0.f;
16295:     for(j=0;j<samples_per_partition;j+=ch){
16295:       if(fabs(in[0][l])>magmax)magmax=fabs(in[0][l]);
16295:       for(k=1;k<ch;k++)
16295:         if(fabs(in[k][l])>angmax)angmax=fabs(in[k][l]);
16295:         l++;
16295:     }
16295: 
16295:     for(j=0;j<possible_partitions-1;j++)
16295:       if(magmax<=info->classmetric1[j] &&
16295:          angmax<=info->classmetric2[j])
16295:         break;
16295: 
16295:     partword[0][i]=j;
16295: 
16295:   }
16295: 
16295: #ifdef TRAIN_RESAUX
16295:   sprintf(buffer,"resaux_%d.vqd",look->train_seq);
16295:   of=fopen(buffer,"a");
16295:   for(i=0;i<partvals;i++)
16295:     fprintf(of,"%ld, ",partword[0][i]);
16295:   fprintf(of,"\n");
16295:   fclose(of);
16295: #endif
16295: 
16295:   look->frames++;
16295: 
16295:   return(partword);
16295: }
16295: 
16295: static int _01forward(oggpack_buffer *opb,
16295:                       vorbis_block *vb,vorbis_look_residue *vl,
16295:                       float **in,int ch,
16295:                       long **partword,
16295:                       int (*encode)(oggpack_buffer *,float *,int,
16295:                                     codebook *,long *)){
16295:   long i,j,k,s;
16295:   vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
16295:   vorbis_info_residue0 *info=look->info;
16295: 
16295:   /* move all this setup out later */
16295:   int samples_per_partition=info->grouping;
16295:   int possible_partitions=info->partitions;
16295:   int partitions_per_word=look->phrasebook->dim;
16295:   int n=info->end-info->begin;
16295: 
16295:   int partvals=n/samples_per_partition;
16295:   long resbits[128];
16295:   long resvals[128];
16295: 
16295: #ifdef TRAIN_RES
16295:   for(i=0;i<ch;i++)
16295:     for(j=info->begin;j<end;j++){
16295:       if(in[i][j]>look->tmax)look->tmax=in[i][j];
16295:       if(in[i][j]<look->tmin)look->tmin=in[i][j];
16295:     }
16295: #endif
16295: 
16295:   memset(resbits,0,sizeof(resbits));
16295:   memset(resvals,0,sizeof(resvals));
16295: 
16295:   /* we code the partition words for each channel, then the residual
16295:      words for a partition per channel until we've written all the
16295:      residual words for that partition word.  Then write the next
16295:      partition channel words... */
16295: 
16295:   for(s=0;s<look->stages;s++){
16295: 
16295:     for(i=0;i<partvals;){
16295: 
16295:       /* first we encode a partition codeword for each channel */
16295:       if(s==0){
16295:         for(j=0;j<ch;j++){
16295:           long val=partword[j][i];
16295:           for(k=1;k<partitions_per_word;k++){
16295:             val*=possible_partitions;
16295:             if(i+k<partvals)
16295:               val+=partword[j][i+k];
16295:           }
16295: 
16295:           /* training hack */
16295:           if(val<look->phrasebook->entries)
16295:             look->phrasebits+=vorbis_book_encode(look->phrasebook,val,opb);
16295: #if 0 /*def TRAIN_RES*/
16295:           else
16295:             fprintf(stderr,"!");
16295: #endif
16295: 
16295:         }
16295:       }
16295: 
16295:       /* now we encode interleaved residual values for the partitions */
16295:       for(k=0;k<partitions_per_word && i<partvals;k++,i++){
16295:         long offset=i*samples_per_partition+info->begin;
16295: 
16295:         for(j=0;j<ch;j++){
16295:           if(s==0)resvals[partword[j][i]]+=samples_per_partition;
16295:           if(info->secondstages[partword[j][i]]&(1<<s)){
16295:             codebook *statebook=look->partbooks[partword[j][i]][s];
16295:             if(statebook){
16295:               int ret;
16295:               long *accumulator=NULL;
16295: 
16295: #ifdef TRAIN_RES
16295:               accumulator=look->training_data[s][partword[j][i]];
16295:               {
16295:                 int l;
16295:                 float *samples=in[j]+offset;
16295:                 for(l=0;l<samples_per_partition;l++){
16295:                   if(samples[l]<look->training_min[s][partword[j][i]])
16295:                     look->training_min[s][partword[j][i]]=samples[l];
16295:                   if(samples[l]>look->training_max[s][partword[j][i]])
16295:                     look->training_max[s][partword[j][i]]=samples[l];
16295:                 }
16295:               }
16295: #endif
16295: 
16295:               ret=encode(opb,in[j]+offset,samples_per_partition,
16295:                          statebook,accumulator);
16295: 
16295:               look->postbits+=ret;
16295:               resbits[partword[j][i]]+=ret;
16295:             }
16295:           }
16295:         }
16295:       }
16295:     }
16295:   }
16295: 
16295:   /*{
16295:     long total=0;
16295:     long totalbits=0;
16295:     fprintf(stderr,"%d :: ",vb->mode);
16295:     for(k=0;k<possible_partitions;k++){
16295:     fprintf(stderr,"%ld/%1.2g, ",resvals[k],(float)resbits[k]/resvals[k]);
16295:     total+=resvals[k];
16295:     totalbits+=resbits[k];
16295:     }
16295: 
16295:     fprintf(stderr,":: %ld:%1.2g\n",total,(double)totalbits/total);
16295:     }*/
16295: 
16295:   return(0);
16295: }
16295: 
16295: /* a truncated packet here just means 'stop working'; it's not an error */
16295: static int _01inverse(vorbis_block *vb,vorbis_look_residue *vl,
16295:                       float **in,int ch,
16295:                       long (*decodepart)(codebook *, float *,
16295:                                          oggpack_buffer *,int)){
16295: 
16295:   long i,j,k,l,s;
16295:   vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
16295:   vorbis_info_residue0 *info=look->info;
16295: 
16295:   /* move all this setup out later */
16295:   int samples_per_partition=info->grouping;
16295:   int partitions_per_word=look->phrasebook->dim;
16295:   int max=vb->pcmend>>1;
16295:   int end=(info->end<max?info->end:max);
16295:   int n=end-info->begin;
16295: 
16295:   if(n>0){
16295:     int partvals=n/samples_per_partition;
16295:     int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
16295:     int ***partword=alloca(ch*sizeof(*partword));
16295: 
16295:     for(j=0;j<ch;j++)
16295:       partword[j]=_vorbis_block_alloc(vb,partwords*sizeof(*partword[j]));
16295: 
16295:     for(s=0;s<look->stages;s++){
16295: 
16295:       /* each loop decodes on partition codeword containing
16295:          partitions_per_word partitions */
16295:       for(i=0,l=0;i<partvals;l++){
16295:         if(s==0){
16295:           /* fetch the partition word for each channel */
16295:           for(j=0;j<ch;j++){
16295:             int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
16295: 
16295:             if(temp==-1)goto eopbreak;
16295:             partword[j][l]=look->decodemap[temp];
16295:             if(partword[j][l]==NULL)goto errout;
16295:           }
16295:         }
16295: 
16295:         /* now we decode residual values for the partitions */
16295:         for(k=0;k<partitions_per_word && i<partvals;k++,i++)
16295:           for(j=0;j<ch;j++){
16295:             long offset=info->begin+i*samples_per_partition;
16295:             if(info->secondstages[partword[j][l][k]]&(1<<s)){
16295:               codebook *stagebook=look->partbooks[partword[j][l][k]][s];
16295:               if(stagebook){
16295:                 if(decodepart(stagebook,in[j]+offset,&vb->opb,
16295:                               samples_per_partition)==-1)goto eopbreak;
16295:               }
16295:             }
16295:           }
16295:       }
16295:     }
16295:   }
16295:  errout:
16295:  eopbreak:
16295:   return(0);
16295: }
16295: 
16295: #if 0
16295: /* residue 0 and 1 are just slight variants of one another. 0 is
16295:    interleaved, 1 is not */
16295: long **res0_class(vorbis_block *vb,vorbis_look_residue *vl,
16295:                   float **in,int *nonzero,int ch){
16295:   /* we encode only the nonzero parts of a bundle */
16295:   int i,used=0;
16295:   for(i=0;i<ch;i++)
16295:     if(nonzero[i])
16295:       in[used++]=in[i];
16295:   if(used)
16295:     /*return(_01class(vb,vl,in,used,_interleaved_testhack));*/
16295:     return(_01class(vb,vl,in,used));
16295:   else
16295:     return(0);
16295: }
16295: 
16295: int res0_forward(vorbis_block *vb,vorbis_look_residue *vl,
16295:                  float **in,float **out,int *nonzero,int ch,
16295:                  long **partword){
16295:   /* we encode only the nonzero parts of a bundle */
16295:   int i,j,used=0,n=vb->pcmend/2;
16295:   for(i=0;i<ch;i++)
16295:     if(nonzero[i]){
16295:       if(out)
16295:         for(j=0;j<n;j++)
16295:           out[i][j]+=in[i][j];
16295:       in[used++]=in[i];
16295:     }
16295:   if(used){
16295:     int ret=_01forward(vb,vl,in,used,partword,
16295:                       _interleaved_encodepart);
16295:     if(out){
16295:       used=0;
16295:       for(i=0;i<ch;i++)
16295:         if(nonzero[i]){
16295:           for(j=0;j<n;j++)
16295:             out[i][j]-=in[used][j];
16295:           used++;
16295:         }
16295:     }
16295:     return(ret);
16295:   }else{
16295:     return(0);
16295:   }
16295: }
16295: #endif
16295: 
16295: int res0_inverse(vorbis_block *vb,vorbis_look_residue *vl,
16295:                  float **in,int *nonzero,int ch){
16295:   int i,used=0;
16295:   for(i=0;i<ch;i++)
16295:     if(nonzero[i])
16295:       in[used++]=in[i];
16295:   if(used)
16295:     return(_01inverse(vb,vl,in,used,vorbis_book_decodevs_add));
16295:   else
16295:     return(0);
16295: }
16295: 
16295: int res1_forward(oggpack_buffer *opb,vorbis_block *vb,vorbis_look_residue *vl,
16295:                  float **in,float **out,int *nonzero,int ch,
16295:                  long **partword){
16295:   int i,j,used=0,n=vb->pcmend/2;
16295:   for(i=0;i<ch;i++)
16295:     if(nonzero[i]){
16295:       if(out)
16295:         for(j=0;j<n;j++)
16295:           out[i][j]+=in[i][j];
16295:       in[used++]=in[i];
16295:     }
16295: 
16295:   if(used){
16295:     int ret=_01forward(opb,vb,vl,in,used,partword,_encodepart);
16295:     if(out){
16295:       used=0;
16295:       for(i=0;i<ch;i++)
16295:         if(nonzero[i]){
16295:           for(j=0;j<n;j++)
16295:             out[i][j]-=in[used][j];
16295:           used++;
16295:         }
16295:     }
16295:     return(ret);
16295:   }else{
16295:     return(0);
16295:   }
16295: }
16295: 
16295: long **res1_class(vorbis_block *vb,vorbis_look_residue *vl,
16295:                   float **in,int *nonzero,int ch){
16295:   int i,used=0;
16295:   for(i=0;i<ch;i++)
16295:     if(nonzero[i])
16295:       in[used++]=in[i];
16295:   if(used)
16295:     return(_01class(vb,vl,in,used));
16295:   else
16295:     return(0);
16295: }
16295: 
16295: int res1_inverse(vorbis_block *vb,vorbis_look_residue *vl,
16295:                  float **in,int *nonzero,int ch){
16295:   int i,used=0;
16295:   for(i=0;i<ch;i++)
16295:     if(nonzero[i])
16295:       in[used++]=in[i];
16295:   if(used)
16295:     return(_01inverse(vb,vl,in,used,vorbis_book_decodev_add));
16295:   else
16295:     return(0);
16295: }
16295: 
16295: long **res2_class(vorbis_block *vb,vorbis_look_residue *vl,
16295:                   float **in,int *nonzero,int ch){
16295:   int i,used=0;
16295:   for(i=0;i<ch;i++)
16295:     if(nonzero[i])used++;
16295:   if(used)
16295:     return(_2class(vb,vl,in,ch));
16295:   else
16295:     return(0);
16295: }
16295: 
16295: /* res2 is slightly more different; all the channels are interleaved
16295:    into a single vector and encoded. */
16295: 
16295: int res2_forward(oggpack_buffer *opb,
16295:                  vorbis_block *vb,vorbis_look_residue *vl,
16295:                  float **in,float **out,int *nonzero,int ch,
16295:                  long **partword){
16295:   long i,j,k,n=vb->pcmend/2,used=0;
16295: 
16295:   /* don't duplicate the code; use a working vector hack for now and
16295:      reshape ourselves into a single channel res1 */
16295:   /* ugly; reallocs for each coupling pass :-( */
16295:   float *work=_vorbis_block_alloc(vb,ch*n*sizeof(*work));
16295:   for(i=0;i<ch;i++){
16295:     float *pcm=in[i];
16295:     if(nonzero[i])used++;
16295:     for(j=0,k=i;j<n;j++,k+=ch)
16295:       work[k]=pcm[j];
16295:   }
16295: 
16295:   if(used){
16295:     int ret=_01forward(opb,vb,vl,&work,1,partword,_encodepart);
16295:     /* update the sofar vector */
16295:     if(out){
16295:       for(i=0;i<ch;i++){
16295:         float *pcm=in[i];
16295:         float *sofar=out[i];
16295:         for(j=0,k=i;j<n;j++,k+=ch)
16295:           sofar[j]+=pcm[j]-work[k];
16295: 
16295:       }
16295:     }
16295:     return(ret);
16295:   }else{
16295:     return(0);
16295:   }
16295: }
16295: 
16295: /* duplicate code here as speed is somewhat more important */
16295: int res2_inverse(vorbis_block *vb,vorbis_look_residue *vl,
16295:                  float **in,int *nonzero,int ch){
16295:   long i,k,l,s;
16295:   vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
16295:   vorbis_info_residue0 *info=look->info;
16295: 
16295:   /* move all this setup out later */
16295:   int samples_per_partition=info->grouping;
16295:   int partitions_per_word=look->phrasebook->dim;
16295:   int max=(vb->pcmend*ch)>>1;
16295:   int end=(info->end<max?info->end:max);
16295:   int n=end-info->begin;
16295: 
16295:   if(n>0){
16295:     int partvals=n/samples_per_partition;
16295:     int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
16295:     int **partword=_vorbis_block_alloc(vb,partwords*sizeof(*partword));
16295: 
16295:     for(i=0;i<ch;i++)if(nonzero[i])break;
16295:     if(i==ch)return(0); /* no nonzero vectors */
16295: 
16295:     for(s=0;s<look->stages;s++){
16295:       for(i=0,l=0;i<partvals;l++){
16295: 
16295:         if(s==0){
16295:           /* fetch the partition word */
16295:           int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
16295:           if(temp==-1)goto eopbreak;
16295:           partword[l]=look->decodemap[temp];
16295:           if(partword[l]==NULL)goto errout;
16295:         }
16295: 
16295:         /* now we decode residual values for the partitions */
16295:         for(k=0;k<partitions_per_word && i<partvals;k++,i++)
16295:           if(info->secondstages[partword[l][k]]&(1<<s)){
16295:             codebook *stagebook=look->partbooks[partword[l][k]][s];
16295: 
16295:             if(stagebook){
16295:               if(vorbis_book_decodevv_add(stagebook,in,
16295:                                           i*samples_per_partition+info->begin,ch,
16295:                                           &vb->opb,samples_per_partition)==-1)
16295:                 goto eopbreak;
16295:             }
16295:           }
16295:       }
16295:     }
16295:   }
16295:  errout:
16295:  eopbreak:
16295:   return(0);
16295: }
16295: 
16295: 
30043: const vorbis_func_residue residue0_exportbundle={
16295:   NULL,
16295:   &res0_unpack,
16295:   &res0_look,
16295:   &res0_free_info,
16295:   &res0_free_look,
16295:   NULL,
16295:   NULL,
16295:   &res0_inverse
16295: };
16295: 
30043: const vorbis_func_residue residue1_exportbundle={
16295:   &res0_pack,
16295:   &res0_unpack,
16295:   &res0_look,
16295:   &res0_free_info,
16295:   &res0_free_look,
16295:   &res1_class,
16295:   &res1_forward,
16295:   &res1_inverse
16295: };
16295: 
30043: const vorbis_func_residue residue2_exportbundle={
16295:   &res0_pack,
16295:   &res0_unpack,
16295:   &res0_look,
16295:   &res0_free_info,
16295:   &res0_free_look,
16295:   &res2_class,
16295:   &res2_forward,
16295:   &res2_inverse
16295: };
