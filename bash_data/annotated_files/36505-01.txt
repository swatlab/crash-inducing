    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: ft=cpp tw=78 sw=4 et ts=4 sts=4 cin
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Peter Annema <disttsc@bart.nl>
    1:  *   Dan Rosen <dr@netscape.com>
 1585:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifdef MOZ_LOGGING
    1: // so we can get logging even in release builds (but only for some things)
    1: #define FORCE_PR_LOG 1
    1: #endif
    1: 
    1: #include "nsIBrowserDOMWindow.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMElement.h"
28438: #include "nsIDOMStorageObsolete.h"
28676: #include "nsIDOMStorage.h"
    1: #include "nsPIDOMStorage.h"
    1: #include "nsIDocumentViewer.h"
    1: #include "nsIDocumentLoaderFactory.h"
    1: #include "nsCURILoader.h"
 5528: #include "nsURILoader.h"
    1: #include "nsDocShellCID.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsDOMCID.h"
    1: #include "nsIDOMScriptObjectFactory.h"
    1: #include "nsNetUtil.h"
    1: #include "nsRect.h"
    1: #include "prprf.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMChromeWindow.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsPoint.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIPrompt.h"
    1: #include "nsIAuthPrompt.h"
    1: #include "nsIAuthPrompt2.h"
    1: #include "nsTextFormatter.h"
    1: #include "nsIChannelEventSink.h"
    1: #include "nsIUploadChannel.h"
    1: #include "nsISecurityEventSink.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsDocumentCharsetInfoCID.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsContentPolicyUtils.h" // NS_CheckContentLoadPolicy(...)
    1: #include "nsICategoryManager.h"
    1: #include "nsXPCOMCID.h"
    1: #include "nsISeekableStream.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIWritablePropertyBag2.h"
    1: #include "nsIAppShell.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsDOMJSUtils.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsIScriptChannel.h"
 5528: #include "nsIURIClassifier.h"
20651: #include "nsIOfflineCacheUpdate.h"
20651: #include "nsCPrefetchService.h"
    1: 
    1: // we want to explore making the document own the load group
    1: // so we can associate the document URI with the load group.
    1: // until this point, we have an evil hack:
    1: #include "nsIHttpChannelInternal.h"  
    1: 
    1: 
    1: // Local Includes
    1: #include "nsDocShell.h"
    1: #include "nsDocShellLoadInfo.h"
    1: #include "nsCDefaultURIFixup.h"
    1: #include "nsDocShellEnumerator.h"
    1: #include "nsSHistory.h"
14631: #include "nsDocShellEditorData.h"
    1: 
    1: // Helper Classes
    1: #include "nsDOMError.h"
    1: #include "nsEscape.h"
    1: 
    1: // Interfaces Needed
    1: #include "nsIUploadChannel.h"
    1: #include "nsIProgressEventSink.h"
    1: #include "nsIWebProgress.h"
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsITimer.h"
    1: #include "nsISHistoryInternal.h"
    1: #include "nsIPrincipal.h"
13414: #include "nsIFileURL.h"
    1: #include "nsIHistoryEntry.h"
    1: #include "nsISHistoryListener.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsIPromptFactory.h"
    1: #include "nsIObserver.h"
    1: #include "nsINestedURI.h"
    1: #include "nsITransportSecurityInfo.h"
    1: #include "nsINSSErrorsService.h"
18430: #include "nsIApplicationCache.h"
21311: #include "nsIApplicationCacheChannel.h"
18430: #include "nsIApplicationCacheContainer.h"
18430: #include "nsIPermissionManager.h"
28078: #include "nsStreamUtils.h"
28078: #include "nsIController.h"
28078: #include "nsPICommandUpdater.h"
28078: #include "nsIDOMHTMLAnchorElement.h"
28078: #include "nsIWebBrowserChrome2.h"
    1: 
    1: // Editor-related
    1: #include "nsIEditingSession.h"
    1: 
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsICachingChannel.h"
    1: #include "nsICacheVisitor.h"
10966: #include "nsICacheEntryDescriptor.h"
    1: #include "nsIMultiPartChannel.h"
    1: #include "nsIWyciwygChannel.h"
    1: 
    1: // The following are for bug #13871: Prevent frameset spoofing
    1: #include "nsIHTMLDocument.h"
    1: 
    1: // For reporting errors with the console service.
    1: // These can go away if error reporting is propagated up past nsDocShell.
    1: #include "nsIConsoleService.h"
    1: #include "nsIScriptError.h"
    1: 
    1: // used to dispatch urls to default protocol handlers
    1: #include "nsCExternalHandlerService.h"
    1: #include "nsIExternalProtocolService.h"
    1: 
    1: #include "nsIFocusController.h"
29018: #include "nsFocusManager.h"
    1: 
    1: #include "nsITextToSubURI.h"
    1: 
 8363: #include "nsIJARChannel.h"
 8363: 
    1: #include "prlog.h"
    1: #include "prmem.h"
    1: 
    1: #include "nsISelectionDisplay.h"
    1: 
    1: #include "nsIGlobalHistory2.h"
    1: #include "nsIGlobalHistory3.h"
    1: 
    1: #ifdef DEBUG_DOCSHELL_FOCUS
    1: #include "nsIEventStateManager.h"
    1: #endif
    1: 
    1: #include "nsIFrame.h"
    1: 
    1: // for embedding
    1: #include "nsIWebBrowserChromeFocus.h"
    1: 
35581: #if NS_PRINT_PREVIEW
35581: #include "nsIDocumentViewerPrint.h"
35581: #include "nsIWebBrowserPrint.h"
35581: #endif
35581: 
    1: #include "nsPluginError.h"
    1: 
    1: static NS_DEFINE_CID(kDOMScriptObjectFactoryCID,
    1:                      NS_DOM_SCRIPT_OBJECT_FACTORY_CID);
    1: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
    1: 
    1: #if defined(DEBUG_bryner) || defined(DEBUG_chb)
    1: //#define DEBUG_DOCSHELL_FOCUS
    1: #define DEBUG_PAGE_CACHE
    1: #endif
    1: 
    1: #include "nsContentErrors.h"
    1: 
    1: // Number of documents currently loading
    1: static PRInt32 gNumberOfDocumentsLoading = 0;
    1: 
    1: // Global count of existing docshells.
    1: static PRInt32 gDocShellCount = 0;
    1: 
    1: // Global reference to the URI fixup service.
    1: nsIURIFixup *nsDocShell::sURIFixup = 0;
    1: 
    1: // True means we validate window targets to prevent frameset
    1: // spoofing. Initialize this to a non-bolean value so we know to check
    1: // the pref on the creation of the first docshell.
    1: static PRBool gValidateOrigin = (PRBool)0xffffffff;
    1: 
    1: // Hint for native dispatch of events on how long to delay after 
    1: // all documents have loaded in milliseconds before favoring normal
    1: // native event dispatch priorites over performance
    1: #define NS_EVENT_STARVATION_DELAY_HINT 2000
    1: 
    1: // This is needed for displaying an error message 
    1: // when navigation is attempted on a document when printing
    1: // The value arbitrary as long as it doesn't conflict with
    1: // any of the other values in the errors in DisplayLoadError
    1: #define NS_ERROR_DOCUMENT_IS_PRINTMODE  NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_GENERAL,2001)
    1: 
    1: #ifdef PR_LOGGING
    1: #ifdef DEBUG
    1: static PRLogModuleInfo* gDocShellLog;
    1: #endif
    1: static PRLogModuleInfo* gDocShellLeakLog;
    1: #endif
    1: 
    1: const char kBrandBundleURL[]      = "chrome://branding/locale/brand.properties";
    1: const char kAppstringsBundleURL[] = "chrome://global/locale/appstrings.properties";
    1: 
    1: static void
    1: FavorPerformanceHint(PRBool perfOverStarvation, PRUint32 starvationDelay)
    1: {
    1:     nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
    1:     if (appShell)
    1:         appShell->FavorPerformanceHint(perfOverStarvation, starvationDelay);
    1: }
    1: 
    1: //*****************************************************************************
28078: // <a ping> support
28078: //*****************************************************************************
28078: 
28078: #define PREF_PINGS_ENABLED           "browser.send_pings"
28078: #define PREF_PINGS_MAX_PER_LINK      "browser.send_pings.max_per_link"
28078: #define PREF_PINGS_REQUIRE_SAME_HOST "browser.send_pings.require_same_host"
28078: 
28078: // Check prefs to see if pings are enabled and if so what restrictions might
28078: // be applied.
28078: //
28078: // @param maxPerLink
28078: //   This parameter returns the number of pings that are allowed per link click
28078: //
28078: // @param requireSameHost
28078: //   This parameter returns PR_TRUE if pings are restricted to the same host as
28078: //   the document in which the click occurs.  If the same host restriction is
28078: //   imposed, then we still allow for pings to cross over to different
28078: //   protocols and ports for flexibility and because it is not possible to send
28078: //   a ping via FTP.
28078: //
28078: // @returns
28078: //   PR_TRUE if pings are enabled and PR_FALSE otherwise.
28078: //
28078: static PRBool
28078: PingsEnabled(PRInt32 *maxPerLink, PRBool *requireSameHost)
28078: {
28078:   PRBool allow = PR_FALSE;
28078: 
28078:   *maxPerLink = 1;
28078:   *requireSameHost = PR_TRUE;
28078: 
28078:   nsCOMPtr<nsIPrefBranch> prefs =
28078:       do_GetService(NS_PREFSERVICE_CONTRACTID);
28078:   if (prefs) {
28078:     PRBool val;
28078:     if (NS_SUCCEEDED(prefs->GetBoolPref(PREF_PINGS_ENABLED, &val)))
28078:       allow = val;
28078:     if (allow) {
28078:       prefs->GetIntPref(PREF_PINGS_MAX_PER_LINK, maxPerLink);
28078:       prefs->GetBoolPref(PREF_PINGS_REQUIRE_SAME_HOST, requireSameHost);
28078:     }
28078:   }
28078: 
28078:   return allow;
28078: }
28078: 
28078: static PRBool
28078: CheckPingURI(nsIURI* uri, nsIContent* content)
28078: {
28078:   if (!uri)
28078:     return PR_FALSE;
28078: 
28078:   // Check with nsIScriptSecurityManager
28078:   nsCOMPtr<nsIScriptSecurityManager> ssmgr =
28078:     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
28078:   NS_ENSURE_TRUE(ssmgr, PR_FALSE);
28078: 
28078:   nsresult rv =
28078:     ssmgr->CheckLoadURIWithPrincipal(content->NodePrincipal(), uri,
28078:                                      nsIScriptSecurityManager::STANDARD);
28078:   if (NS_FAILED(rv)) {
28078:     return PR_FALSE;
28078:   }
28078: 
28078:   // Ignore non-HTTP(S)
28078:   PRBool match;
28078:   if ((NS_FAILED(uri->SchemeIs("http", &match)) || !match) &&
28078:       (NS_FAILED(uri->SchemeIs("https", &match)) || !match)) {
28078:     return PR_FALSE;
28078:   }
28078: 
28078:   // Check with contentpolicy
28078:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
28078:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_PING,
28078:                                  uri,
28078:                                  content->NodePrincipal(),
28078:                                  content,
28078:                                  EmptyCString(), // mime hint
28078:                                  nsnull, //extra
28078:                                  &shouldLoad);
28078:   return NS_SUCCEEDED(rv) && NS_CP_ACCEPTED(shouldLoad);
28078: }
28078: 
28078: typedef void (* ForEachPingCallback)(void *closure, nsIContent *content,
28078:                                      nsIURI *uri, nsIIOService *ios);
28078: 
28078: static void
28078: ForEachPing(nsIContent *content, ForEachPingCallback callback, void *closure)
28078: {
28078:   // NOTE: Using nsIDOMNSHTMLAnchorElement2::GetPing isn't really worth it here
28078:   //       since we'd still need to parse the resulting string.  Instead, we
28078:   //       just parse the raw attribute.  It might be nice if the content node
28078:   //       implemented an interface that exposed an enumeration of nsIURIs.
28078: 
28078:   // Make sure we are dealing with either an <A> or <AREA> element in the HTML
28078:   // or XHTML namespace.
33329:   if (!content->IsHTML())
28078:     return;
28078:   nsIAtom *nameAtom = content->Tag();
28078:   if (!nameAtom->EqualsUTF8(NS_LITERAL_CSTRING("a")) &&
28078:       !nameAtom->EqualsUTF8(NS_LITERAL_CSTRING("area")))
28078:     return;
28078: 
28078:   nsCOMPtr<nsIAtom> pingAtom = do_GetAtom("ping");
28078:   if (!pingAtom)
28078:     return;
28078: 
28078:   nsAutoString value;
28078:   content->GetAttr(kNameSpaceID_None, pingAtom, value);
28078:   if (value.IsEmpty())
28078:     return;
28078: 
28078:   nsCOMPtr<nsIIOService> ios = do_GetIOService();
28078:   if (!ios)
28078:     return;
28078: 
28078:   nsIDocument *doc = content->GetOwnerDoc();
28078:   if (!doc)
28078:     return;
28078: 
28078:   // value contains relative URIs split on spaces (U+0020)
28078:   const PRUnichar *start = value.BeginReading();
28078:   const PRUnichar *end   = value.EndReading();
28078:   const PRUnichar *iter  = start;
28078:   for (;;) {
28078:     if (iter < end && *iter != ' ') {
28078:       ++iter;
28078:     } else {  // iter is pointing at either end or a space
28078:       while (*start == ' ' && start < iter)
28078:         ++start;
28078:       if (iter != start) {
28078:         nsCOMPtr<nsIURI> uri, baseURI = content->GetBaseURI();
28078:         ios->NewURI(NS_ConvertUTF16toUTF8(Substring(start, iter)),
28078:                     doc->GetDocumentCharacterSet().get(),
28078:                     baseURI, getter_AddRefs(uri));
28078:         if (CheckPingURI(uri, content)) {
28078:           callback(closure, content, uri, ios);
28078:         }
28078:       }
28078:       start = iter = iter + 1;
28078:       if (iter >= end)
28078:         break;
28078:     }
28078:   }
28078: }
28078: 
28078: //----------------------------------------------------------------------
28078: 
28078: // We wait this many milliseconds before killing the ping channel...
28078: #define PING_TIMEOUT 10000
28078: 
28078: static void
28078: OnPingTimeout(nsITimer *timer, void *closure)
28078: {
28078:   nsILoadGroup *loadGroup = static_cast<nsILoadGroup *>(closure);
28078:   loadGroup->Cancel(NS_ERROR_ABORT);
28078:   loadGroup->Release();
28078: }
28078: 
28078: // Check to see if two URIs have the same host or not
28078: static PRBool
28078: IsSameHost(nsIURI *uri1, nsIURI *uri2)
28078: {
28078:   nsCAutoString host1, host2;
28078:   uri1->GetAsciiHost(host1);
28078:   uri2->GetAsciiHost(host2);
28078:   return host1.Equals(host2);
28078: }
28078: 
28078: class nsPingListener : public nsIStreamListener
28078:                      , public nsIInterfaceRequestor
28078:                      , public nsIChannelEventSink
28078: {
28078: public:
28078:   NS_DECL_ISUPPORTS
28078:   NS_DECL_NSIREQUESTOBSERVER
28078:   NS_DECL_NSISTREAMLISTENER
28078:   NS_DECL_NSIINTERFACEREQUESTOR
28078:   NS_DECL_NSICHANNELEVENTSINK
28078: 
28078:   nsPingListener(PRBool requireSameHost, nsIContent* content)
28078:     : mRequireSameHost(requireSameHost),
28078:       mContent(content)
28078:   {}
28078: 
28078: private:
28078:   PRBool mRequireSameHost;
28078:   nsCOMPtr<nsIContent> mContent;
28078: };
28078: 
28078: NS_IMPL_ISUPPORTS4(nsPingListener, nsIStreamListener, nsIRequestObserver,
28078:                    nsIInterfaceRequestor, nsIChannelEventSink)
28078: 
28078: NS_IMETHODIMP
28078: nsPingListener::OnStartRequest(nsIRequest *request, nsISupports *context)
28078: {
28078:   return NS_OK;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsPingListener::OnDataAvailable(nsIRequest *request, nsISupports *context,
28078:                                 nsIInputStream *stream, PRUint32 offset,
28078:                                 PRUint32 count)
28078: {
28078:   PRUint32 result;
28078:   return stream->ReadSegments(NS_DiscardSegment, nsnull, count, &result);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsPingListener::OnStopRequest(nsIRequest *request, nsISupports *context,
28078:                               nsresult status)
28078: {
28078:   return NS_OK;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsPingListener::GetInterface(const nsIID &iid, void **result)
28078: {
28078:   if (iid.Equals(NS_GET_IID(nsIChannelEventSink))) {
28078:     NS_ADDREF_THIS();
28078:     *result = (nsIChannelEventSink *) this;
28078:     return NS_OK;
28078:   }
28078: 
28078:   return NS_ERROR_NO_INTERFACE;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsPingListener::OnChannelRedirect(nsIChannel *oldChan, nsIChannel *newChan,
28078:                                   PRUint32 flags)
28078: {
28078:   nsCOMPtr<nsIURI> newURI;
28078:   newChan->GetURI(getter_AddRefs(newURI));
28078: 
28078:   if (!CheckPingURI(newURI, mContent))
28078:     return NS_ERROR_ABORT;
28078: 
28078:   if (!mRequireSameHost)
28078:     return NS_OK;
28078: 
28078:   // XXXbz should this be using something more like the nsContentUtils
28078:   // same-origin checker?
28078:   nsCOMPtr<nsIURI> oldURI;
28078:   oldChan->GetURI(getter_AddRefs(oldURI));
28078:   NS_ENSURE_STATE(oldURI && newURI);
28078: 
28078:   if (!IsSameHost(oldURI, newURI))
28078:     return NS_ERROR_ABORT;
28078: 
28078:   return NS_OK;
28078: }
28078: 
28078: struct SendPingInfo {
28078:   PRInt32 numPings;
28078:   PRInt32 maxPings;
28078:   PRBool  requireSameHost;
28078:   nsIURI *referrer;
28078: };
28078: 
28078: static void
28078: SendPing(void *closure, nsIContent *content, nsIURI *uri, nsIIOService *ios)
28078: {
28078:   SendPingInfo *info = static_cast<SendPingInfo *>(closure);
28078:   if (info->numPings >= info->maxPings)
28078:     return;
28078: 
28078:   if (info->requireSameHost) {
28078:     // Make sure the referrer and the given uri share the same origin.  We
28078:     // only require the same hostname.  The scheme and port may differ.
28078:     if (!IsSameHost(uri, info->referrer))
28078:       return;
28078:   }
28078: 
28078:   nsIDocument *doc = content->GetOwnerDoc();
28078:   if (!doc)
28078:     return;
28078: 
28078:   nsCOMPtr<nsIChannel> chan;
28078:   ios->NewChannelFromURI(uri, getter_AddRefs(chan));
28078:   if (!chan)
28078:     return;
28078: 
28078:   // Don't bother caching the result of this URI load.
28078:   chan->SetLoadFlags(nsIRequest::INHIBIT_CACHING);
28078: 
28078:   nsCOMPtr<nsIHttpChannel> httpChan = do_QueryInterface(chan);
28078:   if (!httpChan)
28078:     return;
28078: 
28078:   // This is needed in order for 3rd-party cookie blocking to work.
28078:   nsCOMPtr<nsIHttpChannelInternal> httpInternal = do_QueryInterface(httpChan);
28078:   if (httpInternal)
28078:     httpInternal->SetDocumentURI(doc->GetDocumentURI());
28078: 
28078:   if (info->referrer)
28078:     httpChan->SetReferrer(info->referrer);
28078: 
28078:   httpChan->SetRequestMethod(NS_LITERAL_CSTRING("POST"));
28078: 
28078:   // Remove extraneous request headers (to reduce request size)
28078:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept"),
28078:                              EmptyCString(), PR_FALSE);
28078:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept-language"),
28078:                              EmptyCString(), PR_FALSE);
28078:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept-charset"),
28078:                              EmptyCString(), PR_FALSE);
28078:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept-encoding"),
28078:                              EmptyCString(), PR_FALSE);
28078: 
28078:   nsCOMPtr<nsIUploadChannel> uploadChan = do_QueryInterface(httpChan);
28078:   if (!uploadChan)
28078:     return;
28078: 
28078:   // To avoid sending an unnecessary Content-Type header, we encode the
28078:   // closing portion of the headers in the POST body.
28078:   NS_NAMED_LITERAL_CSTRING(uploadData, "Content-Length: 0\r\n\r\n");
28078: 
28078:   nsCOMPtr<nsIInputStream> uploadStream;
28078:   NS_NewPostDataStream(getter_AddRefs(uploadStream), PR_FALSE,
28078:                        uploadData, 0);
28078:   if (!uploadStream)
28078:     return;
28078: 
28078:   uploadChan->SetUploadStream(uploadStream, EmptyCString(), -1);
28078: 
28078:   // The channel needs to have a loadgroup associated with it, so that we can
28078:   // cancel the channel and any redirected channels it may create.
28078:   nsCOMPtr<nsILoadGroup> loadGroup =
28078:       do_CreateInstance(NS_LOADGROUP_CONTRACTID);
28078:   if (!loadGroup)
28078:     return;
28078:   chan->SetLoadGroup(loadGroup);
28078: 
28078:   // Construct a listener that merely discards any response.  If successful at
28078:   // opening the channel, then it is not necessary to hold a reference to the
28078:   // channel.  The networking subsystem will take care of that for us.
28078:   nsCOMPtr<nsIStreamListener> listener =
28078:       new nsPingListener(info->requireSameHost, content);
28078:   if (!listener)
28078:     return;
28078: 
28078:   // Observe redirects as well:
28078:   nsCOMPtr<nsIInterfaceRequestor> callbacks = do_QueryInterface(listener);
28078:   NS_ASSERTION(callbacks, "oops");
28078:   loadGroup->SetNotificationCallbacks(callbacks);
28078: 
28078:   chan->AsyncOpen(listener, nsnull);
28078: 
28078:   // Even if AsyncOpen failed, we still count this as a successful ping.  It's
28078:   // possible that AsyncOpen may have failed after triggering some background
28078:   // process that may have written something to the network.
28078:   info->numPings++;
28078: 
28078:   // Prevent ping requests from stalling and never being garbage collected...
28078:   nsCOMPtr<nsITimer> timer =
28078:       do_CreateInstance(NS_TIMER_CONTRACTID);
28078:   if (timer) {
28078:     nsresult rv = timer->InitWithFuncCallback(OnPingTimeout, loadGroup,
28078:                                               PING_TIMEOUT,
28078:                                               nsITimer::TYPE_ONE_SHOT);
28078:     if (NS_SUCCEEDED(rv)) {
28078:       // When the timer expires, the callback function will release this
28078:       // reference to the loadgroup.
28078:       static_cast<nsILoadGroup *>(loadGroup.get())->AddRef();
28078:       loadGroup = 0;
28078:     }
28078:   }
28078:   
28078:   // If we failed to setup the timer, then we should just cancel the channel
28078:   // because we won't be able to ensure that it goes away in a timely manner.
28078:   if (loadGroup)
28078:     chan->Cancel(NS_ERROR_ABORT);
28078: }
28078: 
28078: // Spec: http://whatwg.org/specs/web-apps/current-work/#ping
28078: static void
28078: DispatchPings(nsIContent *content, nsIURI *referrer)
28078: {
28078:   SendPingInfo info;
28078: 
28078:   if (!PingsEnabled(&info.maxPings, &info.requireSameHost))
28078:     return;
28078:   if (info.maxPings == 0)
28078:     return;
28078: 
28078:   info.numPings = 0;
28078:   info.referrer = referrer;
28078: 
28078:   ForEachPing(content, SendPing, &info);
28078: }
28078: 
28078: //*****************************************************************************
    1: //***    nsDocShell: Object Management
    1: //*****************************************************************************
    1: 
28078: // Note: operator new zeros our memory
    1: nsDocShell::nsDocShell():
    1:     nsDocLoader(),
28564:     mDefaultScrollbarPref(Scrollbar_Auto, Scrollbar_Auto),
28564:     mTreeOwner(nsnull),
28564:     mChromeEventHandler(nsnull),
28564:     mCharsetReloadState(eCharsetReloadInit),
28564:     mChildOffset(0),
28564:     mBusyFlags(BUSY_FLAGS_NONE),
28564:     mAppType(nsIDocShell::APP_TYPE_UNKNOWN),
28564:     mMarginWidth(-1),
28564:     mMarginHeight(-1),
28564:     mItemType(typeContent),
28564:     mPreviousTransIndex(-1),
28564:     mLoadedTransIndex(-1),
    1:     mAllowSubframes(PR_TRUE),
    1:     mAllowPlugins(PR_TRUE),
    1:     mAllowJavascript(PR_TRUE),
    1:     mAllowMetaRedirects(PR_TRUE),
    1:     mAllowImages(PR_TRUE),
28460:     mAllowDNSPrefetch(PR_TRUE),
    1:     mCreatingDocument(PR_FALSE),
    1:     mUseErrorPages(PR_FALSE),
    1:     mObserveErrorPages(PR_TRUE),
    1:     mAllowAuth(PR_TRUE),
    1:     mAllowKeywordFixup(PR_FALSE),
21191:     mIsOffScreenBrowser(PR_FALSE),
    1:     mFiredUnloadEvent(PR_FALSE),
    1:     mEODForCurrentDocument(PR_FALSE),
    1:     mURIResultedInDocument(PR_FALSE),
    1:     mIsBeingDestroyed(PR_FALSE),
    1:     mIsExecutingOnLoadHandler(PR_FALSE),
    1:     mIsPrintingOrPP(PR_FALSE),
28564:     mSavingOldViewer(PR_FALSE)
 7837: #ifdef DEBUG
 7837:     , mInEnsureScriptEnv(PR_FALSE)
 7837: #endif
    1: {
    1:     if (gDocShellCount++ == 0) {
    1:         NS_ASSERTION(sURIFixup == nsnull,
    1:                      "Huh, sURIFixup not null in first nsDocShell ctor!");
    1: 
    1:         CallGetService(NS_URIFIXUP_CONTRACTID, &sURIFixup);
    1:     }
    1: 
    1: #ifdef PR_LOGGING
    1: #ifdef DEBUG
    1:     if (! gDocShellLog)
    1:         gDocShellLog = PR_NewLogModule("nsDocShell");
    1: #endif
    1:     if (nsnull == gDocShellLeakLog)
    1:         gDocShellLeakLog = PR_NewLogModule("nsDocShellLeak");
    1:     if (gDocShellLeakLog)
    1:         PR_LOG(gDocShellLeakLog, PR_LOG_DEBUG, ("DOCSHELL %p created\n", this));
    1: #endif
28078: 
28078: #ifdef DEBUG
28078:   // We're counting the number of |nsDocShells| to help find leaks
28078:   ++gNumberOfDocShells;
28078: #endif
28078: #ifdef DEBUG
28078:   printf("++DOCSHELL %p == %ld\n", (void*) this, gNumberOfDocShells);
28078: #endif
    1: }
    1: 
    1: nsDocShell::~nsDocShell()
    1: {
    1:     Destroy();
    1: 
    1:     if (--gDocShellCount == 0) {
    1:         NS_IF_RELEASE(sURIFixup);
    1:     }
    1: 
    1: #ifdef PR_LOGGING
    1:     if (gDocShellLeakLog)
    1:         PR_LOG(gDocShellLeakLog, PR_LOG_DEBUG, ("DOCSHELL %p destroyed\n", this));
    1: #endif
28078: 
28078: #ifdef DEBUG
28078:     // We're counting the number of |nsDocShells| to help find leaks
28078:     --gNumberOfDocShells;
28078: #endif
28078: #ifdef DEBUG
28078:     printf("--DOCSHELL %p == %ld\n", (void*) this, gNumberOfDocShells);
28078: #endif
    1: }
    1: 
    1: nsresult
    1: nsDocShell::Init()
    1: {
    1:     nsresult rv = nsDocLoader::Init();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     NS_ASSERTION(mLoadGroup, "Something went wrong!");
    1: 
    1:     mContentListener = new nsDSURIContentListener(this);
    1:     NS_ENSURE_TRUE(mContentListener, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     rv = mContentListener->Init();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (!mStorages.Init())
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // We want to hold a strong ref to the loadgroup, so it better hold a weak
    1:     // ref to us...  use an InterfaceRequestorProxy to do this.
    1:     nsCOMPtr<InterfaceRequestorProxy> proxy =
 3233:         new InterfaceRequestorProxy(static_cast<nsIInterfaceRequestor*>
 3233:                                                (this));
    1:     NS_ENSURE_TRUE(proxy, NS_ERROR_OUT_OF_MEMORY);
    1:     mLoadGroup->SetNotificationCallbacks(proxy);
    1: 
    1:     rv = nsDocLoader::AddDocLoaderAsChildOfRoot(this);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     // Add as |this| a progress listener to itself.  A little weird, but
    1:     // simpler than reproducing all the listener-notification logic in
    1:     // overrides of the various methods via which nsDocLoader can be
    1:     // notified.   Note that this holds an nsWeakPtr to ourselves, so it's ok.
    1:     return AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_DOCUMENT |
    1:                                      nsIWebProgress::NOTIFY_STATE_NETWORK);
    1:     
    1: }
    1: 
    1: void
    1: nsDocShell::DestroyChildren()
    1: {
    1:     nsCOMPtr<nsIDocShellTreeItem> shell;
29263:     PRInt32 n = mChildList.Count();
29263:     for (PRInt32 i = 0; i < n; i++) {
29263:         shell = do_QueryInterface(ChildAt(i));
    1:         NS_ASSERTION(shell, "docshell has null child");
    1: 
    1:         if (shell) {
    1:             shell->SetTreeOwner(nsnull);
    1:         }
    1:     }
    1: 
    1:     nsDocLoader::DestroyChildren();
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsISupports
    1: //*****************************************************************************   
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsDocShell, nsDocLoader)
    1: NS_IMPL_RELEASE_INHERITED(nsDocShell, nsDocLoader)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsDocShell)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocShell)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellTreeItem)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellTreeNode)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellHistory)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebNavigation)
    1:     NS_INTERFACE_MAP_ENTRY(nsIBaseWindow)
    1:     NS_INTERFACE_MAP_ENTRY(nsIScrollable)
    1:     NS_INTERFACE_MAP_ENTRY(nsITextScroll)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocCharset)
    1:     NS_INTERFACE_MAP_ENTRY(nsIScriptGlobalObjectOwner)
    1:     NS_INTERFACE_MAP_ENTRY(nsIRefreshURI)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
    1:     NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewerContainer)
    1:     NS_INTERFACE_MAP_ENTRY(nsIEditorDocShell)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebPageDescriptor)
    1:     NS_INTERFACE_MAP_ENTRY(nsIAuthPromptProvider)
    1:     NS_INTERFACE_MAP_ENTRY(nsIObserver)
21877:     NS_INTERFACE_MAP_ENTRY(nsILoadContext)
28078:     NS_INTERFACE_MAP_ENTRY(nsIWebShellServices)
28078:     NS_INTERFACE_MAP_ENTRY(nsILinkHandler)
28078:     NS_INTERFACE_MAP_ENTRY(nsIClipboardCommands)
    1: NS_INTERFACE_MAP_END_INHERITING(nsDocLoader)
    1: 
    1: ///*****************************************************************************
    1: // nsDocShell::nsIInterfaceRequestor
    1: //*****************************************************************************   
    1: NS_IMETHODIMP nsDocShell::GetInterface(const nsIID & aIID, void **aSink)
    1: {
    1:     NS_PRECONDITION(aSink, "null out param");
    1: 
    1:     *aSink = nsnull;
    1: 
28078:     if (aIID.Equals(NS_GET_IID(nsICommandManager))) {
28078:         NS_ENSURE_SUCCESS(EnsureCommandHandler(), NS_ERROR_FAILURE);
28078:         *aSink = mCommandManager;
28078:     }
28078:     else if (aIID.Equals(NS_GET_IID(nsIURIContentListener))) {
    1:         *aSink = mContentListener;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIScriptGlobalObject)) &&
    1:              NS_SUCCEEDED(EnsureScriptEnvironment())) {
    1:         *aSink = mScriptGlobal;
    1:     }
    1:     else if ((aIID.Equals(NS_GET_IID(nsIDOMWindowInternal)) ||
    1:               aIID.Equals(NS_GET_IID(nsPIDOMWindow)) ||
    1:               aIID.Equals(NS_GET_IID(nsIDOMWindow))) &&
    1:              NS_SUCCEEDED(EnsureScriptEnvironment())) {
    1:         return mScriptGlobal->QueryInterface(aIID, aSink);
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIDOMDocument)) &&
    1:              NS_SUCCEEDED(EnsureContentViewer())) {
    1:         mContentViewer->GetDOMDocument((nsIDOMDocument **) aSink);
    1:         return *aSink ? NS_OK : NS_NOINTERFACE;
    1:     }
19860:     else if (aIID.Equals(NS_GET_IID(nsIApplicationCacheContainer))) {
18430:         *aSink = nsnull;
18430: 
21366:         // Return application cache associated with this docshell, if any
19860: 
19860:         nsCOMPtr<nsIContentViewer> contentViewer;
21366:         GetContentViewer(getter_AddRefs(contentViewer));
19860:         if (!contentViewer)
19860:             return NS_ERROR_NO_INTERFACE;
19860: 
19860:         nsCOMPtr<nsIDOMDocument> domDoc;
19860:         contentViewer->GetDOMDocument(getter_AddRefs(domDoc));
18430:         NS_ASSERTION(domDoc, "Should have a document.");
18430:         if (!domDoc)
18430:             return NS_ERROR_NO_INTERFACE;
18430: 
21366: #if defined(PR_LOGGING) && defined(DEBUG)
21366:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
21366:                ("nsDocShell[%p]: returning app cache container %p",
21366:                 this, domDoc.get()));
21366: #endif
18430:         return domDoc->QueryInterface(aIID, aSink);
18430:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIPrompt)) &&
    1:              NS_SUCCEEDED(EnsureScriptEnvironment())) {
    1:         nsresult rv;
    1:         nsCOMPtr<nsIWindowWatcher> wwatch =
    1:             do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         nsCOMPtr<nsIDOMWindow> window(do_QueryInterface(mScriptGlobal));
    1: 
    1:         // Get the an auth prompter for our window so that the parenting
    1:         // of the dialogs works as it should when using tabs.
    1: 
    1:         nsIPrompt *prompt;
    1:         rv = wwatch->GetNewPrompter(window, &prompt);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         *aSink = prompt;
    1:         return NS_OK;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
    1:              aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
    1:         return NS_SUCCEEDED(
    1:                 GetAuthPrompt(PROMPT_NORMAL, aIID, aSink)) ?
    1:                 NS_OK : NS_NOINTERFACE;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsISHistory))) {
    1:         nsCOMPtr<nsISHistory> shistory;
    1:         nsresult
    1:             rv =
    1:             GetSessionHistory(getter_AddRefs(shistory));
    1:         if (NS_SUCCEEDED(rv) && shistory) {
    1:             *aSink = shistory;
    1:             NS_ADDREF((nsISupports *) * aSink);
    1:             return NS_OK;
    1:         }
    1:         return NS_NOINTERFACE;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIWebBrowserFind))) {
    1:         nsresult rv = EnsureFind();
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         *aSink = mFind;
    1:         NS_ADDREF((nsISupports*)*aSink);
    1:         return NS_OK;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIEditingSession)) && NS_SUCCEEDED(EnsureEditorData())) {
    1:       nsCOMPtr<nsIEditingSession> editingSession;
    1:       mEditorData->GetEditingSession(getter_AddRefs(editingSession));
    1:       if (editingSession)
    1:       {
    1:         *aSink = editingSession;
    1:         NS_ADDREF((nsISupports *)*aSink);
    1:         return NS_OK;
    1:       }  
    1: 
    1:       return NS_NOINTERFACE;   
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIClipboardDragDropHookList)) 
    1:             && NS_SUCCEEDED(EnsureTransferableHookData())) {
    1:         *aSink = mTransferableHookData;
    1:         NS_ADDREF((nsISupports *)*aSink);
    1:         return NS_OK;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsISelectionDisplay))) {
    1:       nsCOMPtr<nsIPresShell> shell;
    1:       nsresult rv = GetPresShell(getter_AddRefs(shell));
    1:       if (NS_SUCCEEDED(rv) && shell)
    1:         return shell->QueryInterface(aIID,aSink);    
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIDocShellTreeOwner))) {
    1:       nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:       nsresult rv = GetTreeOwner(getter_AddRefs(treeOwner));
    1:       if (NS_SUCCEEDED(rv) && treeOwner)
    1:         return treeOwner->QueryInterface(aIID, aSink);
    1:     }
    1:     else {
    1:         return nsDocLoader::GetInterface(aIID, aSink);
    1:     }
    1: 
    1:     NS_IF_ADDREF(((nsISupports *) * aSink));
    1:     return *aSink ? NS_OK : NS_NOINTERFACE;
    1: }
    1: 
    1: PRUint32
    1: nsDocShell::
    1: ConvertDocShellLoadInfoToLoadType(nsDocShellInfoLoadType aDocShellLoadType)
    1: {
    1:     PRUint32 loadType = LOAD_NORMAL;
    1: 
    1:     switch (aDocShellLoadType) {
    1:     case nsIDocShellLoadInfo::loadNormal:
    1:         loadType = LOAD_NORMAL;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalReplace:
    1:         loadType = LOAD_NORMAL_REPLACE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalExternal:
    1:         loadType = LOAD_NORMAL_EXTERNAL;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadHistory:
    1:         loadType = LOAD_HISTORY;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalBypassCache:
    1:         loadType = LOAD_NORMAL_BYPASS_CACHE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalBypassProxy:
    1:         loadType = LOAD_NORMAL_BYPASS_PROXY;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalBypassProxyAndCache:
    1:         loadType = LOAD_NORMAL_BYPASS_PROXY_AND_CACHE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadNormal:
    1:         loadType = LOAD_RELOAD_NORMAL;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadCharsetChange:
    1:         loadType = LOAD_RELOAD_CHARSET_CHANGE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadBypassCache:
    1:         loadType = LOAD_RELOAD_BYPASS_CACHE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadBypassProxy:
    1:         loadType = LOAD_RELOAD_BYPASS_PROXY;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadBypassProxyAndCache:
    1:         loadType = LOAD_RELOAD_BYPASS_PROXY_AND_CACHE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadLink:
    1:         loadType = LOAD_LINK;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadRefresh:
    1:         loadType = LOAD_REFRESH;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadBypassHistory:
    1:         loadType = LOAD_BYPASS_HISTORY;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadStopContent:
    1:         loadType = LOAD_STOP_CONTENT;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadStopContentAndReplace:
    1:         loadType = LOAD_STOP_CONTENT_AND_REPLACE;
    1:         break;
    1:     default:
    1:         NS_NOTREACHED("Unexpected nsDocShellInfoLoadType value");
    1:     }
    1: 
    1:     return loadType;
    1: }
    1: 
    1: 
    1: nsDocShellInfoLoadType
    1: nsDocShell::ConvertLoadTypeToDocShellLoadInfo(PRUint32 aLoadType)
    1: {
    1:     nsDocShellInfoLoadType docShellLoadType = nsIDocShellLoadInfo::loadNormal;
    1:     switch (aLoadType) {
    1:     case LOAD_NORMAL:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormal;
    1:         break;
    1:     case LOAD_NORMAL_REPLACE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalReplace;
    1:         break;
    1:     case LOAD_NORMAL_EXTERNAL:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalExternal;
    1:         break;
    1:     case LOAD_NORMAL_BYPASS_CACHE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalBypassCache;
    1:         break;
    1:     case LOAD_NORMAL_BYPASS_PROXY:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalBypassProxy;
    1:         break;
    1:     case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalBypassProxyAndCache;
    1:         break;
    1:     case LOAD_HISTORY:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadHistory;
    1:         break;
    1:     case LOAD_RELOAD_NORMAL:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadNormal;
    1:         break;
    1:     case LOAD_RELOAD_CHARSET_CHANGE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadCharsetChange;
    1:         break;
    1:     case LOAD_RELOAD_BYPASS_CACHE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadBypassCache;
    1:         break;
    1:     case LOAD_RELOAD_BYPASS_PROXY:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadBypassProxy;
    1:         break;
    1:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadBypassProxyAndCache;
    1:         break;
    1:     case LOAD_LINK:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadLink;
    1:         break;
    1:     case LOAD_REFRESH:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadRefresh;
    1:         break;
    1:     case LOAD_BYPASS_HISTORY:
    1:     case LOAD_ERROR_PAGE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadBypassHistory;
    1:         break;
    1:     case LOAD_STOP_CONTENT:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadStopContent;
    1:         break;
    1:     case LOAD_STOP_CONTENT_AND_REPLACE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadStopContentAndReplace;
    1:         break;
    1:     default:
    1:         NS_NOTREACHED("Unexpected load type value");
    1:     }
    1: 
    1:     return docShellLoadType;
    1: }                                                                               
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIDocShell
    1: //*****************************************************************************   
    1: NS_IMETHODIMP
    1: nsDocShell::LoadURI(nsIURI * aURI,
    1:                     nsIDocShellLoadInfo * aLoadInfo,
    1:                     PRUint32 aLoadFlags,
    1:                     PRBool aFirstParty)
    1: {
21935:     NS_PRECONDITION(aLoadInfo || (aLoadFlags & EXTRA_LOAD_FLAGS) == 0,
21935:                     "Unexpected flags");
21959:     NS_PRECONDITION((aLoadFlags & 0xf) == 0, "Should not have these flags set");
21935:     
10676:     // Note: we allow loads to get through here even if mFiredUnloadEvent is
10676:     // true; that case will get handled in LoadInternal or LoadHistoryEntry.
10676:     if (IsPrintingOrPP()) {
 2400:       return NS_OK; // JS may not handle returning of an error code
 2400:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsIURI> referrer;
    1:     nsCOMPtr<nsIInputStream> postStream;
    1:     nsCOMPtr<nsIInputStream> headersStream;
    1:     nsCOMPtr<nsISupports> owner;
    1:     PRBool inheritOwner = PR_FALSE;
25969:     PRBool ownerIsExplicit = PR_FALSE;
    1:     PRBool sendReferrer = PR_TRUE;
    1:     nsCOMPtr<nsISHEntry> shEntry;
    1:     nsXPIDLString target;
    1:     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_NORMAL, aLoadFlags);    
    1: 
    1:     NS_ENSURE_ARG(aURI);
    1: 
    1:     // Extract the info from the DocShellLoadInfo struct...
    1:     if (aLoadInfo) {
    1:         aLoadInfo->GetReferrer(getter_AddRefs(referrer));
    1: 
    1:         nsDocShellInfoLoadType lt = nsIDocShellLoadInfo::loadNormal;
    1:         aLoadInfo->GetLoadType(&lt);
    1:         // Get the appropriate loadType from nsIDocShellLoadInfo type
    1:         loadType = ConvertDocShellLoadInfoToLoadType(lt);
    1: 
    1:         aLoadInfo->GetOwner(getter_AddRefs(owner));
    1:         aLoadInfo->GetInheritOwner(&inheritOwner);
25969:         aLoadInfo->GetOwnerIsExplicit(&ownerIsExplicit);
    1:         aLoadInfo->GetSHEntry(getter_AddRefs(shEntry));
    1:         aLoadInfo->GetTarget(getter_Copies(target));
    1:         aLoadInfo->GetPostDataStream(getter_AddRefs(postStream));
    1:         aLoadInfo->GetHeadersStream(getter_AddRefs(headersStream));
    1:         aLoadInfo->GetSendReferrer(&sendReferrer);
    1:     }
    1: 
    1: #if defined(PR_LOGGING) && defined(DEBUG)
    1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString uristr;
    1:         aURI->GetAsciiSpec(uristr);
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:                ("nsDocShell[%p]: loading %s with flags 0x%08x",
    1:                 this, uristr.get(), aLoadFlags));
    1:     }
    1: #endif
    1: 
    1:     if (!shEntry &&
    1:         !LOAD_TYPE_HAS_FLAGS(loadType, LOAD_FLAGS_REPLACE_HISTORY)) {
    1:         // First verify if this is a subframe.
    1:         nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
    1:         GetSameTypeParent(getter_AddRefs(parentAsItem));
    1:         nsCOMPtr<nsIDocShell> parentDS(do_QueryInterface(parentAsItem));
    1:         PRUint32 parentLoadType;
    1: 
 3233:         if (parentDS && parentDS != static_cast<nsIDocShell *>(this)) {
    1:             /* OK. It is a subframe. Checkout the 
    1:              * parent's loadtype. If the parent was loaded thro' a history
    1:              * mechanism, then get the SH entry for the child from the parent.
    1:              * This is done to restore frameset navigation while going back/forward.
    1:              * If the parent was loaded through any other loadType, set the
    1:              * child's loadType too accordingly, so that session history does not
    1:              * get confused. 
    1:              */
    1:             
    1:             // Get the parent's load type
    1:             parentDS->GetLoadType(&parentLoadType);            
    1: 
    1:             nsCOMPtr<nsIDocShellHistory> parent(do_QueryInterface(parentAsItem));
    1:             if (parent) {
    1:                 // Get the ShEntry for the child from the parent
    1:                 parent->GetChildSHEntry(mChildOffset, getter_AddRefs(shEntry));
    1:                 // Make some decisions on the child frame's loadType based on the 
    1:                 // parent's loadType. 
    1:                 if (mCurrentURI == nsnull) {
    1:                     // This is a newly created frame. Check for exception cases first. 
    1:                     // By default the subframe will inherit the parent's loadType.
    1:                     if (shEntry && (parentLoadType == LOAD_NORMAL ||
    1:                                     parentLoadType == LOAD_LINK   ||
    1:                                     parentLoadType == LOAD_NORMAL_EXTERNAL)) {
    1:                         // The parent was loaded normally. In this case, this *brand new* child really shouldn't
    1:                         // have a SHEntry. If it does, it could be because the parent is replacing an
    1:                         // existing frame with a new frame, in the onLoadHandler. We don't want this
    1:                         // url to get into session history. Clear off shEntry, and set laod type to
    1:                         // LOAD_BYPASS_HISTORY. 
    1:                         PRBool inOnLoadHandler=PR_FALSE;
    1:                         parentDS->GetIsExecutingOnLoadHandler(&inOnLoadHandler);
    1:                         if (inOnLoadHandler) {
    1:                             loadType = LOAD_NORMAL_REPLACE;
    1:                             shEntry = nsnull;
    1:                         }
    1:                     }   
    1:                     else if (parentLoadType == LOAD_REFRESH) {
    1:                         // Clear shEntry. For refresh loads, we have to load
    1:                         // what comes thro' the pipe, not what's in history.
    1:                         shEntry = nsnull;
    1:                     }
    1:                     else if ((parentLoadType == LOAD_BYPASS_HISTORY) ||
    1:                              (parentLoadType == LOAD_ERROR_PAGE) ||
    1:                               (shEntry && 
    1:                                ((parentLoadType & LOAD_CMD_HISTORY) || 
    1:                                 (parentLoadType == LOAD_RELOAD_NORMAL) || 
    1:                                 (parentLoadType == LOAD_RELOAD_CHARSET_CHANGE)))) {
    1:                         // If the parent url, bypassed history or was loaded from
    1:                         // history, pass on the parent's loadType to the new child 
    1:                         // frame too, so that the child frame will also
    1:                         // avoid getting into history. 
    1:                         loadType = parentLoadType;
    1:                     }
    1:                 }
    1:                 else {
    1:                     // This is a pre-existing subframe. If the load was not originally initiated
    1:                     // by session history, (if (!shEntry) condition succeeded) and mCurrentURI is not null,
    1:                     // it is possible that a parent's onLoadHandler or even self's onLoadHandler is loading 
    1:                     // a new page in this child. Check parent's and self's busy flag  and if it is set,
    1:                     // we don't want this onLoadHandler load to get in to session history.
    1:                     PRUint32 parentBusy = BUSY_FLAGS_NONE;
    1:                     PRUint32 selfBusy = BUSY_FLAGS_NONE;
    1:                     parentDS->GetBusyFlags(&parentBusy);                    
    1:                     GetBusyFlags(&selfBusy);
    1:                     if (((parentBusy & BUSY_FLAGS_BUSY) ||
    1:                          (selfBusy & BUSY_FLAGS_BUSY)) &&
    1:                         shEntry) {
    1:                         loadType = LOAD_NORMAL_REPLACE;
    1:                         shEntry = nsnull; 
    1:                     }
    1:                 }
    1:             } // parent
    1:         } //parentDS
    1:         else {  
    1:             // This is the root docshell. If we got here while  
    1:             // executing an onLoad Handler,this load will not go 
    1:             // into session history.
    1:             PRBool inOnLoadHandler=PR_FALSE;
    1:             GetIsExecutingOnLoadHandler(&inOnLoadHandler);
    1:             if (inOnLoadHandler) {
    1:                 loadType = LOAD_NORMAL_REPLACE;
    1:             }
    1:         } 
    1:     } // !shEntry
    1: 
    1:     if (shEntry) {
    1: #ifdef DEBUG
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:               ("nsDocShell[%p]: loading from session history", this));
    1: #endif
    1: 
25969:         return LoadHistoryEntry(shEntry, loadType);
25969:     }
25969: 
    1:     // Perform the load...
25969: 
25969:     // We need an owner (a referring principal).
25969:     //
25969:     // If ownerIsExplicit is not set there are 4 possibilities:
 3596:     // (1) If the system principal was passed in and we're a typeContent
 3596:     //     docshell, inherit the principal from the current document
 3596:     //     instead.
 3596:     // (2) In all other cases when the principal passed in is not null,
 3596:     //     use that principal.
 3596:     // (3) If the caller has allowed inheriting from the current document,
    1:     //     or if we're being called from system code (eg chrome JS or pure
    1:     //     C++) then inheritOwner should be true and InternalLoad will get
    1:     //     an owner from the current document. If none of these things are
    1:     //     true, then
 3596:     // (4) we pass a null owner into the channel, and an owner will be
 3596:     //     created later from the channel's internal data.
    1:     //
25969:     // If ownerIsExplicit *is* set, there are 4 possibilities
25969:     // (1) If the system principal was passed in and we're a typeContent
25969:     //     docshell, return an error.
25969:     // (2) In all other cases when the principal passed in is not null,
25969:     //     use that principal.
25969:     // (3) If the caller has allowed inheriting from the current document,
25969:     //     then inheritOwner should be true and InternalLoad will get an owner
25969:     //     from the current document. If none of these things are true, then
25969:     // (4) we pass a null owner into the channel, and an owner will be
25969:     //     created later from the channel's internal data.
25969:     //
    1:     // NOTE: This all only works because the only thing the owner is used  
 3596:     //       for in InternalLoad is data:, javascript:, and about:blank
 3596:     //       URIs.  For other URIs this would all be dead wrong!
25969: 
 3596:     nsCOMPtr<nsIScriptSecurityManager> secMan =
 3596:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
 3596:     NS_ENSURE_SUCCESS(rv, rv);
 3596: 
 3596:     if (owner && mItemType != typeChrome) {
 3596:         nsCOMPtr<nsIPrincipal> ownerPrincipal = do_QueryInterface(owner);
 3596:         PRBool isSystem;
 3596:         rv = secMan->IsSystemPrincipal(ownerPrincipal, &isSystem);
 3596:         NS_ENSURE_SUCCESS(rv, rv);
 3596: 
 3596:         if (isSystem) {
25969:             if (ownerIsExplicit) {
25969:                 return NS_ERROR_DOM_SECURITY_ERR;
25969:             }
 3596:             owner = nsnull;
 3596:             inheritOwner = PR_TRUE;
 3596:         }
 3596:     }
25969:     if (!owner && !inheritOwner && !ownerIsExplicit) {
    1:         // See if there's system or chrome JS code running
    1:         rv = secMan->SubjectPrincipalIsSystem(&inheritOwner);
    1:         if (NS_FAILED(rv)) {
    1:             // Set it back to false
    1:             inheritOwner = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     PRUint32 flags = 0;
    1: 
    1:     if (inheritOwner)
    1:         flags |= INTERNAL_LOAD_FLAGS_INHERIT_OWNER;
    1: 
    1:     if (!sendReferrer)
    1:         flags |= INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER;
    1:             
    1:     if (aLoadFlags & LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP)
    1:         flags |= INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
    1: 
    1:     if (aLoadFlags & LOAD_FLAGS_FIRST_LOAD)
    1:         flags |= INTERNAL_LOAD_FLAGS_FIRST_LOAD;
    1: 
10966:     if (aLoadFlags & LOAD_FLAGS_BYPASS_CLASSIFIER)
10966:         flags |= INTERNAL_LOAD_FLAGS_BYPASS_CLASSIFIER;
10966: 
29288:     if (aLoadFlags & LOAD_FLAGS_FORCE_ALLOW_COOKIES)
29288:         flags |= INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES;
29288: 
25969:     return InternalLoad(aURI,
    1:                         referrer,
    1:                         owner,
    1:                         flags,
    1:                         target.get(),
    1:                         nsnull,         // No type hint
    1:                         postStream,
    1:                         headersStream,
    1:                         loadType,
    1:                         nsnull,         // No SHEntry
    1:                         aFirstParty,
    1:                         nsnull,         // No nsIDocShell
    1:                         nsnull);        // No nsIRequest
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::LoadStream(nsIInputStream *aStream, nsIURI * aURI,
    1:                        const nsACString &aContentType,
    1:                        const nsACString &aContentCharset,
    1:                        nsIDocShellLoadInfo * aLoadInfo)
    1: {
    1:     NS_ENSURE_ARG(aStream);
    1: 
    1:     mAllowKeywordFixup = PR_FALSE;
    1: 
    1:     // if the caller doesn't pass in a URI we need to create a dummy URI. necko
    1:     // currently requires a URI in various places during the load. Some consumers
    1:     // do as well.
    1:     nsCOMPtr<nsIURI> uri = aURI;
    1:     if (!uri) {
    1:         // HACK ALERT
    1:         nsresult rv = NS_OK;
    1:         uri = do_CreateInstance(NS_SIMPLEURI_CONTRACTID, &rv);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:         // Make sure that the URI spec "looks" like a protocol and path...
    1:         // For now, just use a bogus protocol called "internal"
    1:         rv = uri->SetSpec(NS_LITERAL_CSTRING("internal:load-stream"));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     PRUint32 loadType = LOAD_NORMAL;
    1:     if (aLoadInfo) {
    1:         nsDocShellInfoLoadType lt = nsIDocShellLoadInfo::loadNormal;
    1:         (void) aLoadInfo->GetLoadType(&lt);
    1:         // Get the appropriate LoadType from nsIDocShellLoadInfo type
    1:         loadType = ConvertDocShellLoadInfoToLoadType(lt);
    1:     }
    1: 
    1:     NS_ENSURE_SUCCESS(Stop(nsIWebNavigation::STOP_NETWORK), NS_ERROR_FAILURE);
    1: 
    1:     mLoadType = loadType;
    1: 
    1:     // build up a channel for this stream.
    1:     nsCOMPtr<nsIChannel> channel;
    1:     NS_ENSURE_SUCCESS(NS_NewInputStreamChannel
    1:                       (getter_AddRefs(channel), uri, aStream,
    1:                        aContentType, aContentCharset),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIURILoader>
    1:         uriLoader(do_GetService(NS_URI_LOADER_CONTRACTID));
    1:     NS_ENSURE_TRUE(uriLoader, NS_ERROR_FAILURE);
    1: 
10966:     NS_ENSURE_SUCCESS(DoChannelLoad(channel, uriLoader, PR_FALSE),
10966:                       NS_ERROR_FAILURE);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::CreateLoadInfo(nsIDocShellLoadInfo ** aLoadInfo)
    1: {
    1:     nsDocShellLoadInfo *loadInfo = new nsDocShellLoadInfo();
    1:     NS_ENSURE_TRUE(loadInfo, NS_ERROR_OUT_OF_MEMORY);
    1:     nsCOMPtr<nsIDocShellLoadInfo> localRef(loadInfo);
    1: 
    1:     *aLoadInfo = localRef;
    1:     NS_ADDREF(*aLoadInfo);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: /*
    1:  * Reset state to a new content model within the current document and the document
    1:  * viewer.  Called by the document before initiating an out of band document.write().
    1:  */
    1: NS_IMETHODIMP
    1: nsDocShell::PrepareForNewContentModel()
    1: {
    1:   mEODForCurrentDocument = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::FirePageHideNotification(PRBool aIsUnload)
    1: {
    1:     if (mContentViewer && !mFiredUnloadEvent) {
    1:         // Keep an explicit reference since calling PageHide could release
    1:         // mContentViewer
    1:         nsCOMPtr<nsIContentViewer> kungFuDeathGrip(mContentViewer);
    1:         mFiredUnloadEvent = PR_TRUE;
    1: 
    1:         mContentViewer->PageHide(aIsUnload);
    1: 
 8259:         nsAutoTArray<nsCOMPtr<nsIDocShell>, 8> kids;
29263:         PRInt32 i, n = mChildList.Count();
 8259:         kids.SetCapacity(n);
    1:         for (i = 0; i < n; i++) {
29263:             kids.AppendElement(do_QueryInterface(ChildAt(i)));
 8259:         }
 8259: 
 8259:         n = kids.Length();
 8259:         for (i = 0; i < n; ++i) {
 8259:             if (kids[i]) {
 8259:                 kids[i]->FirePageHideNotification(aIsUnload);
    1:             }
    1:         }
14631:         // Now make sure our editor, if any, is detached before we go
 8553:         // any farther.
14631:         DetachEditorFromWindow();
 8553:     }
 8553: 
    1:     return NS_OK;
    1: }
    1: 
    1: //
    1: // Bug 13871: Prevent frameset spoofing
    1: //
    1: // This routine answers: 'Is origin's document from same domain as
    1: // target's document?'
    1: //
13337: // file: uris are considered the same domain for the purpose of
13337: // frame navigation regardless of script accessibility (bug 420425)
13337: //
    1: /* static */
    1: PRBool
    1: nsDocShell::ValidateOrigin(nsIDocShellTreeItem* aOriginTreeItem,
    1:                            nsIDocShellTreeItem* aTargetTreeItem)
    1: {
    1:     nsCOMPtr<nsIScriptSecurityManager> securityManager =
    1:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
    1:     NS_ENSURE_TRUE(securityManager, PR_FALSE);
    1: 
    1:     nsCOMPtr<nsIPrincipal> subjectPrincipal;
    1:     nsresult rv =
    1:         securityManager->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
    1:     NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:     if (subjectPrincipal) {
    1:         // We're called from JS, check if UniversalBrowserWrite is
    1:         // enabled.
    1:         PRBool ubwEnabled = PR_FALSE;
    1:         rv = securityManager->IsCapabilityEnabled("UniversalBrowserWrite",
    1:                                                   &ubwEnabled);
    1:         NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:         if (ubwEnabled) {
    1:             return PR_TRUE;
    1:         }
    1:     }
    1: 
    1:     // Get origin document principal
    1:     nsCOMPtr<nsIDOMDocument> originDOMDocument =
    1:         do_GetInterface(aOriginTreeItem);
    1:     nsCOMPtr<nsIDocument> originDocument(do_QueryInterface(originDOMDocument));
    1:     NS_ENSURE_TRUE(originDocument, PR_FALSE);
    1:     
    1:     // Get target principal
    1:     nsCOMPtr<nsIDOMDocument> targetDOMDocument =
    1:         do_GetInterface(aTargetTreeItem);
    1:     nsCOMPtr<nsIDocument> targetDocument(do_QueryInterface(targetDOMDocument));
    1:     NS_ENSURE_TRUE(targetDocument, PR_FALSE);
    1: 
 3286:     PRBool equal;
13337:     rv = originDocument->NodePrincipal()->
13337:             Equals(targetDocument->NodePrincipal(), &equal);
13337:     if (NS_SUCCEEDED(rv) && equal) {
13337:         return PR_TRUE;
13337:     }
13337: 
13337:     // Not strictly equal, special case if both are file: uris
13337:     PRBool originIsFile = PR_FALSE;
13337:     PRBool targetIsFile = PR_FALSE;
13337:     nsCOMPtr<nsIURI> originURI;
13337:     nsCOMPtr<nsIURI> targetURI;
13337:     nsCOMPtr<nsIURI> innerOriginURI;
13337:     nsCOMPtr<nsIURI> innerTargetURI;
13337: 
13337:     rv = originDocument->NodePrincipal()->GetURI(getter_AddRefs(originURI));
14261:     if (NS_SUCCEEDED(rv) && originURI)
13337:         innerOriginURI = NS_GetInnermostURI(originURI);
13337: 
13337:     rv = targetDocument->NodePrincipal()->GetURI(getter_AddRefs(targetURI));
14261:     if (NS_SUCCEEDED(rv) && targetURI)
13337:         innerTargetURI = NS_GetInnermostURI(targetURI);
13337: 
13337:     return innerOriginURI && innerTargetURI &&
13338:         NS_SUCCEEDED(innerOriginURI->SchemeIs("file", &originIsFile)) &&
13338:         NS_SUCCEEDED(innerTargetURI->SchemeIs("file", &targetIsFile)) &&
13337:         originIsFile && targetIsFile;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetEldestPresContext(nsPresContext** aPresContext)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     NS_ENSURE_ARG_POINTER(aPresContext);
    1:     *aPresContext = nsnull;
    1: 
    1:     nsCOMPtr<nsIContentViewer> viewer = mContentViewer;
    1:     while (viewer) {
    1:         nsCOMPtr<nsIContentViewer> prevViewer;
    1:         viewer->GetPreviousViewer(getter_AddRefs(prevViewer));
    1:         if (prevViewer)
    1:             viewer = prevViewer;
    1:         else {
    1:             nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(viewer));
    1:             if (docv)
    1:                 rv = docv->GetPresContext(aPresContext);
    1:             break;
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPresContext(nsPresContext ** aPresContext)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aPresContext);
    1:     *aPresContext = nsnull;
    1: 
    1:     if (!mContentViewer)
    1:       return NS_OK;
    1: 
    1:     nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(mContentViewer));
    1:     NS_ENSURE_TRUE(docv, NS_ERROR_NO_INTERFACE);
    1: 
    1:     return docv->GetPresContext(aPresContext);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPresShell(nsIPresShell ** aPresShell)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     NS_ENSURE_ARG_POINTER(aPresShell);
    1:     *aPresShell = nsnull;
    1: 
    1:     nsCOMPtr<nsPresContext> presContext;
    1:     (void) GetPresContext(getter_AddRefs(presContext));
    1: 
    1:     if (presContext) {
    1:         NS_IF_ADDREF(*aPresShell = presContext->GetPresShell());
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetEldestPresShell(nsIPresShell** aPresShell)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     NS_ENSURE_ARG_POINTER(aPresShell);
    1:     *aPresShell = nsnull;
    1: 
    1:     nsCOMPtr<nsPresContext> presContext;
    1:     (void) GetEldestPresContext(getter_AddRefs(presContext));
    1: 
    1:     if (presContext) {
    1:         NS_IF_ADDREF(*aPresShell = presContext->GetPresShell());
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetContentViewer(nsIContentViewer ** aContentViewer)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aContentViewer);
    1: 
    1:     *aContentViewer = mContentViewer;
    1:     NS_IF_ADDREF(*aContentViewer);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetChromeEventHandler(nsIDOMEventTarget* aChromeEventHandler)
    1: {
    1:     nsCOMPtr<nsPIDOMEventTarget> piTarget =
    1:       do_QueryInterface(aChromeEventHandler);
    1:     // Weak reference. Don't addref.
    1:     mChromeEventHandler = piTarget;
    1: 
16549:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
16549:     if (win) {
16549:         win->SetChromeEventHandler(piTarget);
16549:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetChromeEventHandler(nsIDOMEventTarget** aChromeEventHandler)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChromeEventHandler);
    1:     nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(mChromeEventHandler);
    1:     target.swap(*aChromeEventHandler);
    1:     return NS_OK;
    1: }
    1: 
    1: /* [noscript] void setCurrentURI (in nsIURI uri); */
    1: NS_IMETHODIMP
    1: nsDocShell::SetCurrentURI(nsIURI *aURI)
    1: {
    1:     SetCurrentURI(aURI, nsnull, PR_TRUE);
    1:     return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsDocShell::SetCurrentURI(nsIURI *aURI, nsIRequest *aRequest,
    1:                           PRBool aFireOnLocationChange)
    1: {
    1: #ifdef PR_LOGGING
    1:     if (gDocShellLeakLog && PR_LOG_TEST(gDocShellLeakLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         if (aURI)
    1:             aURI->GetSpec(spec);
    1:         PR_LogPrint("DOCSHELL %p SetCurrentURI %s\n", this, spec.get());
    1:     }
    1: #endif
    1: 
    1:     // We don't want to send a location change when we're displaying an error
    1:     // page, and we don't want to change our idea of "current URI" either
    1:     if (mLoadType == LOAD_ERROR_PAGE) {
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     mCurrentURI = NS_TryToMakeImmutable(aURI);
    1:     
    1:     PRBool isRoot = PR_FALSE;   // Is this the root docshell
    1:     PRBool isSubFrame = PR_FALSE;  // Is this a subframe navigation?
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1: 
    1:     GetSameTypeRootTreeItem(getter_AddRefs(root));
 3233:     if (root.get() == static_cast<nsIDocShellTreeItem *>(this)) 
    1:     {
    1:         // This is the root docshell
    1:         isRoot = PR_TRUE;
    1:     }
    1:     if (mLSHE) {
    1:         mLSHE->GetIsSubFrame(&isSubFrame);
    1:     }
    1: 
    1:     if (!isSubFrame && !isRoot) {
    1:       /* 
    1:        * We don't want to send OnLocationChange notifications when
    1:        * a subframe is being loaded for the first time, while
    1:        * visiting a frameset page
    1:        */
    1:       return PR_FALSE; 
    1:     }
    1: 
    1:     if (aFireOnLocationChange) {
    1:         FireOnLocationChange(this, aRequest, aURI);
    1:     }
    1:     return !aFireOnLocationChange;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCharset(char** aCharset)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCharset);
    1:     *aCharset = nsnull; 
    1: 
    1:     nsCOMPtr<nsIPresShell> presShell;
    1:     GetPresShell(getter_AddRefs(presShell));
    1:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1:     nsIDocument *doc = presShell->GetDocument();
    1:     NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
    1:     *aCharset = ToNewCString(doc->GetDocumentCharacterSet());
    1:     if (!*aCharset) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetCharset(const char* aCharset)
    1: {
    1:     // set the default charset
    1:     nsCOMPtr<nsIContentViewer> viewer;
    1:     GetContentViewer(getter_AddRefs(viewer));
    1:     if (viewer) {
    1:       nsCOMPtr<nsIMarkupDocumentViewer> muDV(do_QueryInterface(viewer));
    1:       if (muDV) {
    1:         NS_ENSURE_SUCCESS(muDV->SetDefaultCharacterSet(nsDependentCString(aCharset)),
    1:                           NS_ERROR_FAILURE);
    1:       }
    1:     }
    1: 
    1:     // set the charset override
    1:     nsCOMPtr<nsIDocumentCharsetInfo> dcInfo;
    1:     GetDocumentCharsetInfo(getter_AddRefs(dcInfo));
    1:     if (dcInfo) {
    1:       nsCOMPtr<nsIAtom> csAtom;
    1:       csAtom = do_GetAtom(aCharset);
    1:       dcInfo->SetForcedCharset(csAtom);
    1:     }
    1: 
    1:     return NS_OK;
    1: } 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetDocumentCharsetInfo(nsIDocumentCharsetInfo **
    1:                                    aDocumentCharsetInfo)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aDocumentCharsetInfo);
    1: 
    1:     // if the mDocumentCharsetInfo does not exist already, we create it now
    1:     if (!mDocumentCharsetInfo) {
    1:         mDocumentCharsetInfo = do_CreateInstance(NS_DOCUMENTCHARSETINFO_CONTRACTID);
    1:         if (!mDocumentCharsetInfo)
    1:             return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     *aDocumentCharsetInfo = mDocumentCharsetInfo;
    1:     NS_IF_ADDREF(*aDocumentCharsetInfo);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetDocumentCharsetInfo(nsIDocumentCharsetInfo *
    1:                                    aDocumentCharsetInfo)
    1: {
    1:     mDocumentCharsetInfo = aDocumentCharsetInfo;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 8363: nsDocShell::GetChannelIsUnsafe(PRBool *aUnsafe)
 8363: {
 8363:     *aUnsafe = PR_FALSE;
 8363: 
 8363:     nsCOMPtr<nsIChannel> channel;
 8363:     GetCurrentDocumentChannel(getter_AddRefs(channel));
 8363:     if (!channel) {
 8363:         return NS_OK;
 8363:     }
 8363: 
 8363:     nsCOMPtr<nsIJARChannel> jarChannel = do_QueryInterface(channel);
 8363:     if (!jarChannel) {
 8363:         return NS_OK;
 8363:     }
 8363: 
 8363:     return jarChannel->GetIsUnsafe(aUnsafe);
 8363: }
 8363: 
 8363: NS_IMETHODIMP
    1: nsDocShell::GetAllowPlugins(PRBool * aAllowPlugins)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aAllowPlugins);
    1: 
    1:     *aAllowPlugins = mAllowPlugins;
 8363:     if (!mAllowPlugins) {
 8363:         return NS_OK;
 8363:     }
 8363: 
 8363:     PRBool unsafe;
 8363:     *aAllowPlugins = NS_SUCCEEDED(GetChannelIsUnsafe(&unsafe)) && !unsafe;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetAllowPlugins(PRBool aAllowPlugins)
    1: {
    1:     mAllowPlugins = aAllowPlugins;
    1:     //XXX should enable or disable a plugin host
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetAllowJavascript(PRBool * aAllowJavascript)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aAllowJavascript);
    1: 
    1:     *aAllowJavascript = mAllowJavascript;
 8363:     if (!mAllowJavascript) {
 8363:         return NS_OK;
 8363:     }
 8363: 
 8363:     PRBool unsafe;
 8363:     *aAllowJavascript = NS_SUCCEEDED(GetChannelIsUnsafe(&unsafe)) && !unsafe;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetAllowJavascript(PRBool aAllowJavascript)
    1: {
    1:     mAllowJavascript = aAllowJavascript;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::GetAllowMetaRedirects(PRBool * aReturn)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:     *aReturn = mAllowMetaRedirects;
 8363:     if (!mAllowMetaRedirects) {
 8363:         return NS_OK;
 8363:     }
 8363: 
 8363:     PRBool unsafe;
 8363:     *aReturn = NS_SUCCEEDED(GetChannelIsUnsafe(&unsafe)) && !unsafe;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::SetAllowMetaRedirects(PRBool aValue)
    1: {
    1:     mAllowMetaRedirects = aValue;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::GetAllowSubframes(PRBool * aAllowSubframes)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aAllowSubframes);
    1: 
    1:     *aAllowSubframes = mAllowSubframes;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::SetAllowSubframes(PRBool aAllowSubframes)
    1: {
    1:     mAllowSubframes = aAllowSubframes;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::GetAllowImages(PRBool * aAllowImages)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aAllowImages);
    1: 
    1:     *aAllowImages = mAllowImages;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::SetAllowImages(PRBool aAllowImages)
    1: {
    1:     mAllowImages = aAllowImages;
    1:     return NS_OK;
    1: }
    1: 
28460: NS_IMETHODIMP nsDocShell::GetAllowDNSPrefetch(PRBool * aAllowDNSPrefetch)
28460: {
28460:     *aAllowDNSPrefetch = mAllowDNSPrefetch;
28460:     return NS_OK;
28460: }
28460: 
28460: NS_IMETHODIMP nsDocShell::SetAllowDNSPrefetch(PRBool aAllowDNSPrefetch)
28460: {
28460:     mAllowDNSPrefetch = aAllowDNSPrefetch;
28460:     return NS_OK;
28460: }
28460: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetDocShellEnumerator(PRInt32 aItemType, PRInt32 aDirection, nsISimpleEnumerator **outEnum)
    1: {
    1:     NS_ENSURE_ARG_POINTER(outEnum);
    1:     *outEnum = nsnull;
    1:     
    1:     nsRefPtr<nsDocShellEnumerator> docShellEnum;
    1:     if (aDirection == ENUMERATE_FORWARDS)
    1:         docShellEnum = new nsDocShellForwardsEnumerator;
    1:     else
    1:         docShellEnum = new nsDocShellBackwardsEnumerator;
    1:     
    1:     if (!docShellEnum) return NS_ERROR_OUT_OF_MEMORY;
    1:     
    1:     nsresult rv = docShellEnum->SetEnumDocShellType(aItemType);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = docShellEnum->SetEnumerationRootItem((nsIDocShellTreeItem *)this);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = docShellEnum->First();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = docShellEnum->QueryInterface(NS_GET_IID(nsISimpleEnumerator), (void **)outEnum);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetAppType(PRUint32 * aAppType)
    1: {
    1:     *aAppType = mAppType;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetAppType(PRUint32 aAppType)
    1: {
    1:     mAppType = aAppType;
28460:     if (mAppType == APP_TYPE_MAIL || mAppType == APP_TYPE_EDITOR) {
28460:         SetAllowDNSPrefetch(PR_FALSE);
28460:     }
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetAllowAuth(PRBool * aAllowAuth)
    1: {
    1:     *aAllowAuth = mAllowAuth;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetAllowAuth(PRBool aAllowAuth)
    1: {
    1:     mAllowAuth = aAllowAuth;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetZoom(float *zoom)
    1: {
    1:     NS_ENSURE_ARG_POINTER(zoom);
    1:     *zoom = 1.0f;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetZoom(float zoom)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetMarginWidth(PRInt32 * aWidth)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aWidth);
    1: 
    1:     *aWidth = mMarginWidth;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetMarginWidth(PRInt32 aWidth)
    1: {
    1:     mMarginWidth = aWidth;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetMarginHeight(PRInt32 * aHeight)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aHeight);
    1: 
    1:     *aHeight = mMarginHeight;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetMarginHeight(PRInt32 aHeight)
    1: {
    1:     mMarginHeight = aHeight;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetBusyFlags(PRUint32 * aBusyFlags)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aBusyFlags);
    1: 
    1:     *aBusyFlags = mBusyFlags;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::TabToTreeOwner(PRBool aForward, PRBool* aTookFocus)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aTookFocus);
    1:     
    1:     nsCOMPtr<nsIWebBrowserChromeFocus> chromeFocus = do_GetInterface(mTreeOwner);
    1:     if (chromeFocus) {
    1:         if (aForward)
    1:             *aTookFocus = NS_SUCCEEDED(chromeFocus->FocusNextElement());
    1:         else
    1:             *aTookFocus = NS_SUCCEEDED(chromeFocus->FocusPrevElement());
    1:     } else
    1:         *aTookFocus = PR_FALSE;
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSecurityUI(nsISecureBrowserUI **aSecurityUI)
    1: {
    1:     NS_IF_ADDREF(*aSecurityUI = mSecurityUI);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetSecurityUI(nsISecureBrowserUI *aSecurityUI)
    1: {
    1:     mSecurityUI = aSecurityUI;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetUseErrorPages(PRBool *aUseErrorPages)
    1: {
    1:     *aUseErrorPages = mUseErrorPages;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetUseErrorPages(PRBool aUseErrorPages)
    1: {
    1:     // If mUseErrorPages is set explicitly, stop observing the pref.
    1:     if (mObserveErrorPages) {
    1:         nsCOMPtr<nsIPrefBranch2> prefs(do_QueryInterface(mPrefs));
    1:         if (prefs) {
    1:             prefs->RemoveObserver("browser.xul.error_pages.enabled", this);
    1:             mObserveErrorPages = PR_FALSE;
    1:         }
    1:     }
    1:     mUseErrorPages = aUseErrorPages;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
19870: nsDocShell::GetPreviousTransIndex(PRInt32 *aPreviousTransIndex)
19870: {
19870:     *aPreviousTransIndex = mPreviousTransIndex;
19870:     return NS_OK;
19870: }
19870: 
19870: NS_IMETHODIMP
19870: nsDocShell::GetLoadedTransIndex(PRInt32 *aLoadedTransIndex)
19870: {
19870:     *aLoadedTransIndex = mLoadedTransIndex;
19870:     return NS_OK;
19870: }
19870: 
19870: NS_IMETHODIMP
19870: nsDocShell::HistoryPurged(PRInt32 aNumEntries)
19870: {
19870:     // These indices are used for fastback cache eviction, to determine
19870:     // which session history entries are candidates for content viewer
19870:     // eviction.  We need to adjust by the number of entries that we
19870:     // just purged from history, so that we look at the right session history
19870:     // entries during eviction.
19870:     mPreviousTransIndex = PR_MAX(-1, mPreviousTransIndex - aNumEntries);
19870:     mLoadedTransIndex = PR_MAX(0, mLoadedTransIndex - aNumEntries);
19870: 
29263:     PRInt32 count = mChildList.Count();
29263:     for (PRInt32 i = 0; i < count; ++i) {
29263:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
19870:         if (shell) {
19870:             shell->HistoryPurged(aNumEntries);
19870:         }
19870:     }
19870: 
19870:     return NS_OK;
19870: }
19870: 
28820: static
28820: nsresult
28820: GetPrincipalDomain(nsIPrincipal* aPrincipal, nsACString& aDomain)
28820: {
28820:   aDomain.Truncate();
28820: 
28820:   nsCOMPtr<nsIURI> codebaseURI;
28820:   nsresult rv = aPrincipal->GetDomain(getter_AddRefs(codebaseURI));
28820:   NS_ENSURE_SUCCESS(rv, rv);
28820:   if (!codebaseURI) {
28820:      rv = aPrincipal->GetURI(getter_AddRefs(codebaseURI));
28820:      NS_ENSURE_SUCCESS(rv, rv);
28820:   }
28820: 
28820:   if (!codebaseURI)
28820:      return NS_OK;
28820: 
28820:   nsCOMPtr<nsIURI> innerURI = NS_GetInnermostURI(codebaseURI);
28820:   NS_ASSERTION(innerURI, "Failed to get innermost URI");
28820:   NS_ENSURE_SUCCESS(rv, rv);
28820: 
28820:   rv = innerURI->GetAsciiHost(aDomain);
28820:   if (NS_FAILED(rv))
28820:       return rv;
28820: 
28820:   return NS_OK;
28820: }
28820: 
19870: NS_IMETHODIMP
23579: nsDocShell::GetSessionStorageForPrincipal(nsIPrincipal* aPrincipal,
23579:                                           PRBool aCreate,
28676:                                           nsIDOMStorage** aStorage)
23579: {
23579:     NS_ENSURE_ARG_POINTER(aStorage);
23579:     *aStorage = nsnull;
23579: 
23579:     if (!aPrincipal)
23579:         return NS_OK;
23579: 
28676:     nsresult rv;
28676: 
28676:     nsCOMPtr<nsIDocShellTreeItem> topItem;
28676:     rv = GetSameTypeRootTreeItem(getter_AddRefs(topItem));
28676:     if (NS_FAILED(rv))
28676:         return rv;
28676: 
28676:     if (!topItem)
28676:         return NS_ERROR_FAILURE;
28676: 
28676:     nsDocShell* topDocShell = static_cast<nsDocShell*>(topItem.get());
28676:     if (topDocShell != this)
28676:         return topDocShell->GetSessionStorageForPrincipal(aPrincipal, aCreate,
28676:                                                           aStorage);
28676: 
28820:     nsCAutoString currentDomain;
28820:     rv = GetPrincipalDomain(aPrincipal, currentDomain);
28676:     if (NS_FAILED(rv))
28676:         return rv;
28676: 
28820:     if (currentDomain.IsEmpty())
28820:         return NS_OK;
28820: 
28820:     if (!mStorages.Get(currentDomain, aStorage) && aCreate) {
28676:         nsCOMPtr<nsIDOMStorage> newstorage =
28676:             do_CreateInstance("@mozilla.org/dom/storage;2");
28676:         if (!newstorage)
28676:             return NS_ERROR_OUT_OF_MEMORY;
28676: 
28676:         nsCOMPtr<nsPIDOMStorage> pistorage = do_QueryInterface(newstorage);
28676:         if (!pistorage)
28676:             return NS_ERROR_FAILURE;
28820:         rv = pistorage->InitAsSessionStorage(aPrincipal);
28820:         if (NS_FAILED(rv))
28820:             return rv;
28820: 
28820:         if (!mStorages.Put(currentDomain, newstorage))
28676:             return NS_ERROR_OUT_OF_MEMORY;
28676: 
28676:         newstorage.swap(*aStorage);
28676:         return NS_OK;
28676:     }
23579: 
23579:     nsCOMPtr<nsPIDOMStorage> piStorage = do_QueryInterface(*aStorage);
23579:     if (piStorage) {
23579:         PRBool canAccess = piStorage->CanAccess(aPrincipal);
23579:         NS_ASSERTION(canAccess,
23579:                      "GetSessionStorageForPrincipal got a storage "
23579:                      "that could not be accessed!");
23579:         if (!canAccess) {
23579:             NS_RELEASE(*aStorage);
23579:             return NS_ERROR_DOM_SECURITY_ERR;
23579:         }
23579:     }
23579: 
23579:     return NS_OK;
23579: }
23579: 
23579: NS_IMETHODIMP
    1: nsDocShell::GetSessionStorageForURI(nsIURI* aURI,
28676:                                     nsIDOMStorage** aStorage)
    1: {
23579:     return GetSessionStorageForURI(aURI, PR_TRUE, aStorage);
23579: }
23579: 
23579: nsresult
23579: nsDocShell::GetSessionStorageForURI(nsIURI* aURI,
23579:                                     PRBool aCreate,
28676:                                     nsIDOMStorage** aStorage)
23579: {
23579:     NS_ENSURE_ARG(aURI);
    1:     NS_ENSURE_ARG_POINTER(aStorage);
    1: 
    1:     *aStorage = nsnull;
    1: 
28676:     nsresult rv;
28676: 
28676:     nsCOMPtr<nsIScriptSecurityManager> securityManager =
28676:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
28676:     NS_ENSURE_SUCCESS(rv, rv);
28676: 
28676:     // This is terrible hack and should go away along with this whole method.
28676:     nsCOMPtr<nsIPrincipal> principal;
28676:     rv = securityManager->GetCodebasePrincipal(aURI, getter_AddRefs(principal));
28676:     if (NS_FAILED(rv))
28676:         return rv;
28676: 
28676:     return GetSessionStorageForPrincipal(principal, aCreate, aStorage);
28676: }
28676: 
28676: nsresult
28676: nsDocShell::AddSessionStorage(nsIPrincipal* aPrincipal,
28676:                               nsIDOMStorage* aStorage)
28676: {
28676:     NS_ENSURE_ARG_POINTER(aStorage);
28676: 
28676:     if (!aPrincipal)
28676:         return NS_OK;
23579: 
    1:     nsCOMPtr<nsIDocShellTreeItem> topItem;
    1:     nsresult rv = GetSameTypeRootTreeItem(getter_AddRefs(topItem));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (topItem) {
    1:         nsCOMPtr<nsIDocShell> topDocShell = do_QueryInterface(topItem);
    1:         if (topDocShell == this) {
28820:             nsCAutoString currentDomain;
28820:             rv = GetPrincipalDomain(aPrincipal, currentDomain);
28676:             if (NS_FAILED(rv))
28676:                 return rv;
28676: 
28820:             if (currentDomain.IsEmpty())
28676:                 return NS_ERROR_FAILURE;
28676: 
23579:             // Do not replace an existing session storage.
28820:             if (mStorages.GetWeak(currentDomain))
23579:                 return NS_ERROR_NOT_AVAILABLE;
23579: 
28820:             if (!mStorages.Put(currentDomain, aStorage))
    1:                 return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:         else {
28676:             return topDocShell->AddSessionStorage(aPrincipal, aStorage);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCurrentDocumentChannel(nsIChannel** aResult)
    1: {
    1:     *aResult = nsnull;
    1:     if (!mContentViewer)
    1:         return NS_OK;
    1: 
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     nsresult rv = mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
    1:     if (doc) {
    1:       *aResult = doc->GetChannel();
    1:       NS_IF_ADDREF(*aResult);
    1:     }
    1:   
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIDocShellTreeItem
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetName(PRUnichar ** aName)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aName);
    1:     *aName = ToNewUnicode(mName);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetName(const PRUnichar * aName)
    1: {
    1:     mName = aName;              // this does a copy of aName
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::NameEquals(const PRUnichar *aName, PRBool *_retval)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aName);
    1:     NS_ENSURE_ARG_POINTER(_retval);
    1:     *_retval = mName.Equals(aName);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetItemType(PRInt32 * aItemType)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aItemType);
    1: 
    1:     *aItemType = mItemType;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetItemType(PRInt32 aItemType)
    1: {
    1:     NS_ENSURE_ARG((aItemType == typeChrome) || (typeContent == aItemType));
    1: 
    1:     // Only allow setting the type on root docshells.  Those would be the ones
    1:     // that have the docloader service as mParent or have no mParent at all.
    1:     nsCOMPtr<nsIDocumentLoader> docLoaderService =
    1:         do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
    1:     NS_ENSURE_TRUE(docLoaderService, NS_ERROR_UNEXPECTED);
    1:     
    1:     NS_ENSURE_STATE(!mParent || mParent == docLoaderService);
    1: 
    1:     mItemType = aItemType;
    1: 
    1:     // disable auth prompting for anything but content
    1:     mAllowAuth = mItemType == typeContent; 
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetParent(nsIDocShellTreeItem ** aParent)
    1: {
    1:     if (!mParent) {
    1:         *aParent = nsnull;
    1:     } else {
    1:         CallQueryInterface(mParent, aParent);
    1:     }
    1:     // Note that in the case when the parent is not an nsIDocShellTreeItem we
    1:     // don't want to throw; we just want to return null.
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::SetDocLoaderParent(nsDocLoader * aParent)
    1: {
    1:     nsDocLoader::SetDocLoaderParent(aParent);
    1: 
    1:     // Curse ambiguous nsISupports inheritance!
    1:     nsISupports* parent = GetAsSupports(aParent);
    1: 
    1:     // If parent is another docshell, we inherit all their flags for
    1:     // allowing plugins, scripting etc.
    1:     nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(parent));
    1:     if (parentAsDocShell)
    1:     {
    1:         PRBool value;
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowPlugins(&value)))
    1:         {
    1:             SetAllowPlugins(value);
    1:         }
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowJavascript(&value)))
    1:         {
    1:             SetAllowJavascript(value);
    1:         }
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowMetaRedirects(&value)))
    1:         {
    1:             SetAllowMetaRedirects(value);
    1:         }
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowSubframes(&value)))
    1:         {
    1:             SetAllowSubframes(value);
    1:         }
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowImages(&value)))
    1:         {
    1:             SetAllowImages(value);
    1:         }
28460:         if (NS_FAILED(parentAsDocShell->GetAllowDNSPrefetch(&value))) {
28460:             value = PR_FALSE;
28460:         }
28460:         SetAllowDNSPrefetch(value);
    1:     }
    1: 
    1:     nsCOMPtr<nsIURIContentListener> parentURIListener(do_GetInterface(parent));
    1:     if (parentURIListener)
    1:         mContentListener->SetParentContentListener(parentURIListener);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSameTypeParent(nsIDocShellTreeItem ** aParent)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aParent);
    1:     *aParent = nsnull;
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parent =
    1:         do_QueryInterface(GetAsSupports(mParent));
    1:     if (!parent)
    1:         return NS_OK;
    1: 
    1:     PRInt32 parentType;
    1:     NS_ENSURE_SUCCESS(parent->GetItemType(&parentType), NS_ERROR_FAILURE);
    1: 
    1:     if (parentType == mItemType) {
    1:         parent.swap(*aParent);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetRootTreeItem(nsIDocShellTreeItem ** aRootTreeItem)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aRootTreeItem);
 3233:     *aRootTreeItem = static_cast<nsIDocShellTreeItem *>(this);
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parent;
    1:     NS_ENSURE_SUCCESS(GetParent(getter_AddRefs(parent)), NS_ERROR_FAILURE);
    1:     while (parent) {
    1:         *aRootTreeItem = parent;
    1:         NS_ENSURE_SUCCESS((*aRootTreeItem)->GetParent(getter_AddRefs(parent)),
    1:                           NS_ERROR_FAILURE);
    1:     }
    1:     NS_ADDREF(*aRootTreeItem);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSameTypeRootTreeItem(nsIDocShellTreeItem ** aRootTreeItem)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aRootTreeItem);
 3233:     *aRootTreeItem = static_cast<nsIDocShellTreeItem *>(this);
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parent;
    1:     NS_ENSURE_SUCCESS(GetSameTypeParent(getter_AddRefs(parent)),
    1:                       NS_ERROR_FAILURE);
    1:     while (parent) {
    1:         *aRootTreeItem = parent;
    1:         NS_ENSURE_SUCCESS((*aRootTreeItem)->
    1:                           GetSameTypeParent(getter_AddRefs(parent)),
    1:                           NS_ERROR_FAILURE);
    1:     }
    1:     NS_ADDREF(*aRootTreeItem);
    1:     return NS_OK;
    1: }
    1: 
    1: /* static */
    1: PRBool
    1: nsDocShell::CanAccessItem(nsIDocShellTreeItem* aTargetItem,
    1:                           nsIDocShellTreeItem* aAccessingItem,
    1:                           PRBool aConsiderOpener)
    1: {
    1:     NS_PRECONDITION(aTargetItem, "Must have target item!");
    1: 
    1:     if (!gValidateOrigin || !aAccessingItem) {
    1:         // Good to go
    1:         return PR_TRUE;
    1:     }
    1: 
    1:     // XXXbz should we care if aAccessingItem or the document therein is
    1:     // chrome?  Should those get extra privileges?
    1: 
10790:     // For historical context, see:
10790:     // 
10790:     // Bug 13871:  Prevent frameset spoofing
10790:     // Bug 103638: Targets with same name in different windows open in wrong
10790:     //             window with javascript
13337:     // Bug 408052: Adopt "ancestor" frame navigation policy
10790: 
    1:     // Now do a security check
10790:     //
10790:     // Allow navigation if
10790:     //  1) aAccessingItem can script aTargetItem or one of its ancestors in
10790:     //     the frame hierarchy or
10790:     //  2) aTargetItem is a top-level frame and aAccessingItem is its descendant
10790:     //  3) aTargetItem is a top-level frame and aAccessingItem can target
10790:     //     its opener per rule (1) or (2).
10790: 
10790:     if (aTargetItem == aAccessingItem) {
10790:         // A frame is allowed to navigate itself.
10790:         return PR_TRUE;  
10790:     }
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> accessingRoot;
    1:     aAccessingItem->GetSameTypeRootTreeItem(getter_AddRefs(accessingRoot));
    1: 
10790:     if (aTargetItem == accessingRoot) {
10790:         // A frame can navigate its root.
    1:         return PR_TRUE;
    1:     }
    1: 
10790:     // Check if aAccessingItem can navigate one of aTargetItem's ancestors.
    1:     nsCOMPtr<nsIDocShellTreeItem> target = aTargetItem;
    1:     do {
    1:         if (ValidateOrigin(aAccessingItem, target)) {
    1:             return PR_TRUE;
    1:         }
    1:             
    1:         nsCOMPtr<nsIDocShellTreeItem> parent;
    1:         target->GetSameTypeParent(getter_AddRefs(parent));
    1:         parent.swap(target);
    1:     } while (target);
    1: 
10790:     nsCOMPtr<nsIDocShellTreeItem> targetRoot;
10790:     aTargetItem->GetSameTypeRootTreeItem(getter_AddRefs(targetRoot));
10790: 
    1:     if (aTargetItem != targetRoot) {
    1:         // target is a subframe, not in accessor's frame hierarchy, and all its
    1:         // ancestors have origins different from that of the accessor. Don't
    1:         // allow access.
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     if (!aConsiderOpener) {
    1:         // All done here
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMWindow> targetWindow(do_GetInterface(aTargetItem));
    1:     nsCOMPtr<nsIDOMWindowInternal> targetInternal(do_QueryInterface(targetWindow));
    1:     if (!targetInternal) {
    1:         NS_ERROR("This should not happen, really");
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMWindowInternal> targetOpener;
    1:     targetInternal->GetOpener(getter_AddRefs(targetOpener));
    1:     nsCOMPtr<nsIWebNavigation> openerWebNav(do_GetInterface(targetOpener));
    1:     nsCOMPtr<nsIDocShellTreeItem> openerItem(do_QueryInterface(openerWebNav));
    1: 
    1:     if (!openerItem) {
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     return CanAccessItem(openerItem, aAccessingItem, PR_FALSE);    
    1: }
    1: 
    1: static PRBool
    1: ItemIsActive(nsIDocShellTreeItem *aItem)
    1: {
    1:     nsCOMPtr<nsIDOMWindow> tmp(do_GetInterface(aItem));
    1:     nsCOMPtr<nsIDOMWindowInternal> window(do_QueryInterface(tmp));
    1: 
    1:     if (window) {
    1:         PRBool isClosed;
    1: 
    1:         if (NS_SUCCEEDED(window->GetClosed(&isClosed)) && !isClosed) {
    1:             return PR_TRUE;
    1:         }
    1:     }
    1: 
    1:     return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::FindItemWithName(const PRUnichar * aName,
    1:                              nsISupports * aRequestor,
    1:                              nsIDocShellTreeItem * aOriginalRequestor,
    1:                              nsIDocShellTreeItem ** _retval)
    1: {
    1:     NS_ENSURE_ARG(aName);
    1:     NS_ENSURE_ARG_POINTER(_retval);
    1: 
    1:     // If we don't find one, we return NS_OK and a null result
    1:     *_retval = nsnull;
    1: 
    1:     if (!*aName)
    1:         return NS_OK;
    1: 
    1:     if (!aRequestor)
    1:     {
    1:         nsCOMPtr<nsIDocShellTreeItem> foundItem;
    1: 
    1:         // This is the entry point into the target-finding algorithm.  Check
    1:         // for special names.  This should only be done once, hence the check
    1:         // for a null aRequestor.
    1: 
    1:         nsDependentString name(aName);
    1:         if (name.LowerCaseEqualsLiteral("_self")) {
    1:             foundItem = this;
    1:         }
11699:         else if (name.LowerCaseEqualsLiteral("_blank"))
    1:         {
    1:             // Just return null.  Caller must handle creating a new window with
    1:             // a blank name himself.
    1:             return NS_OK;
    1:         }
    1:         else if (name.LowerCaseEqualsLiteral("_parent"))
    1:         {
    1:             GetSameTypeParent(getter_AddRefs(foundItem));
    1:             if(!foundItem)
    1:                 foundItem = this;
    1:         }
    1:         else if (name.LowerCaseEqualsLiteral("_top"))
    1:         {
    1:             GetSameTypeRootTreeItem(getter_AddRefs(foundItem));
    1:             NS_ASSERTION(foundItem, "Must have this; worst case it's us!");
    1:         }
    1:         // _main is an IE target which should be case-insensitive but isn't
    1:         // see bug 217886 for details
    1:         else if (name.LowerCaseEqualsLiteral("_content") ||
    1:                  name.EqualsLiteral("_main"))
    1:         {
    1:             // Must pass our same type root as requestor to the
    1:             // treeowner to make sure things work right.
    1:             nsCOMPtr<nsIDocShellTreeItem> root;
    1:             GetSameTypeRootTreeItem(getter_AddRefs(root));
    1:             if (mTreeOwner) {
    1:                 NS_ASSERTION(root, "Must have this; worst case it's us!");
    1:                 mTreeOwner->FindItemWithName(aName, root, aOriginalRequestor,
    1:                                              getter_AddRefs(foundItem));
    1:             }
    1: #ifdef DEBUG
    1:             else {
    1:                 NS_ERROR("Someone isn't setting up the tree owner.  "
    1:                          "You might like to try that.  "
    1:                          "Things will.....you know, work.");
    1:                 // Note: _content should always exist.  If we don't have one
    1:                 // hanging off the treeowner, just create a named window....
    1:                 // so don't return here, in case we did that and can now find
    1:                 // it.                
    1:                 // XXXbz should we be using |root| instead of creating
    1:                 // a new window?
    1:             }
    1: #endif
    1:         }
    1: 
    1:         if (foundItem && !CanAccessItem(foundItem, aOriginalRequestor)) {
    1:             foundItem = nsnull;
    1:         }
    1: 
    1:         if (foundItem) {
    1:             // We return foundItem here even if it's not an active
    1:             // item since all the names we've dealt with so far are
    1:             // special cases that we won't bother looking for further.
    1: 
    1:             foundItem.swap(*_retval);
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     // Keep looking
    1:         
    1:     // First we check our name.
    1:     if (mName.Equals(aName) && ItemIsActive(this) &&
    1:         CanAccessItem(this, aOriginalRequestor)) {
    1:         NS_ADDREF(*_retval = this);
    1:         return NS_OK;
    1:     }
    1: 
    1:     // This QI may fail, but the places where we want to compare, comparing
    1:     // against nsnull serves the same purpose.
    1:     nsCOMPtr<nsIDocShellTreeItem> reqAsTreeItem(do_QueryInterface(aRequestor));
    1: 
    1:     // Second we check our children making sure not to ask a child if
    1:     // it is the aRequestor.
    1: #ifdef DEBUG
    1:     nsresult rv =
    1: #endif
    1:     FindChildWithName(aName, PR_TRUE, PR_TRUE, reqAsTreeItem,
    1:                       aOriginalRequestor, _retval);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv),
    1:                  "FindChildWithName should not be failing here.");
    1:     if (*_retval)
    1:         return NS_OK;
    1:         
    1:     // Third if we have a parent and it isn't the requestor then we
    1:     // should ask it to do the search.  If it is the requestor we
    1:     // should just stop here and let the parent do the rest.  If we
    1:     // don't have a parent, then we should ask the
    1:     // docShellTreeOwner to do the search.
    1:     nsCOMPtr<nsIDocShellTreeItem> parentAsTreeItem =
    1:         do_QueryInterface(GetAsSupports(mParent));
    1:     if (parentAsTreeItem) {
    1:         if (parentAsTreeItem == reqAsTreeItem)
    1:             return NS_OK;
    1: 
    1:         PRInt32 parentType;
    1:         parentAsTreeItem->GetItemType(&parentType);
    1:         if (parentType == mItemType) {
    1:             return parentAsTreeItem->
    1:                 FindItemWithName(aName,
 3233:                                  static_cast<nsIDocShellTreeItem*>
 3233:                                             (this),
    1:                                  aOriginalRequestor,
    1:                                  _retval);
    1:         }
    1:     }
    1: 
    1:     // If the parent is null or not of the same type fall through and ask tree
    1:     // owner.
    1: 
    1:     // This may fail, but comparing against null serves the same purpose
    1:     nsCOMPtr<nsIDocShellTreeOwner>
    1:         reqAsTreeOwner(do_QueryInterface(aRequestor));
    1: 
    1:     if (mTreeOwner && mTreeOwner != reqAsTreeOwner) {
    1:         return mTreeOwner->
    1:             FindItemWithName(aName, this, aOriginalRequestor, _retval);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetTreeOwner(nsIDocShellTreeOwner ** aTreeOwner)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aTreeOwner);
    1: 
    1:     *aTreeOwner = mTreeOwner;
    1:     NS_IF_ADDREF(*aTreeOwner);
    1:     return NS_OK;
    1: }
    1: 
    1: #ifdef DEBUG_DOCSHELL_FOCUS
    1: static void 
 1160: PrintDocTree(nsIDocShellTreeItem * aParentNode, int aLevel)
    1: {
    1:   for (PRInt32 i=0;i<aLevel;i++) printf("  ");
    1: 
    1:   PRInt32 childWebshellCount;
    1:   aParentNode->GetChildCount(&childWebshellCount);
    1:   nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(aParentNode));
    1:   PRInt32 type;
 1160:   aParentNode->GetItemType(&type);
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   parentAsDocShell->GetPresShell(getter_AddRefs(presShell));
    1:   nsCOMPtr<nsPresContext> presContext;
    1:   parentAsDocShell->GetPresContext(getter_AddRefs(presContext));
    1:   nsIDocument *doc = presShell->GetDocument();
    1: 
    1:   nsCOMPtr<nsIDOMWindowInternal> domwin(doc->GetWindow());
    1: 
    1:   nsCOMPtr<nsIWidget> widget;
    1:   nsIViewManager* vm = presShell->GetViewManager();
    1:   if (vm) {
    1:     vm->GetWidget(getter_AddRefs(widget));
    1:   }
   58:   nsIContent* rootContent = doc->GetRootContent();
    1: 
    1:   printf("DS %p  Ty %s  Doc %p DW %p EM %p CN %p\n",  
   58:     (void*)parentAsDocShell.get(), 
    1:     type==nsIDocShellTreeItem::typeChrome?"Chr":"Con", 
   58:      (void*)doc, (void*)domwin.get(),
   58:      (void*)presContext->EventStateManager(), (void*)rootContent);
    1: 
    1:   if (childWebshellCount > 0) {
    1:     for (PRInt32 i=0;i<childWebshellCount;i++) {
    1:       nsCOMPtr<nsIDocShellTreeItem> child;
    1:       aParentNode->GetChildAt(i, getter_AddRefs(child));
 1160:       PrintDocTree(child, aLevel+1);
    1:     }
    1:   }
    1: }
    1: 
    1: static void 
 1160: PrintDocTree(nsIDocShellTreeItem * aParentNode)
    1: {
    1:   NS_ASSERTION(aParentNode, "Pointer is null!");
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> parentItem;
 1160:   aParentNode->GetParent(getter_AddRefs(parentItem));
    1:   while (parentItem) {
    1:     nsCOMPtr<nsIDocShellTreeItem>tmp;
    1:     parentItem->GetParent(getter_AddRefs(tmp));
    1:     if (!tmp) {
    1:       break;
    1:     }
    1:     parentItem = tmp;
    1:   }
    1: 
    1:   if (!parentItem) {
 1160:     parentItem = aParentNode;
 1160:   }
 1160: 
 1160:   PrintDocTree(parentItem, 0);
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetTreeOwner(nsIDocShellTreeOwner * aTreeOwner)
    1: {
    1: #ifdef DEBUG_DOCSHELL_FOCUS
 1160:     nsCOMPtr<nsIDocShellTreeItem> item(do_QueryInterface(aTreeOwner));
 1160:     if (item) {
 1160:       PrintDocTree(item);
    1:     }
    1: #endif
    1: 
    1:     // Don't automatically set the progress based on the tree owner for frames
    1:     if (!IsFrame()) {
    1:         nsCOMPtr<nsIWebProgress> webProgress =
    1:             do_QueryInterface(GetAsSupports(this));
    1: 
    1:         if (webProgress) {
    1:             nsCOMPtr<nsIWebProgressListener>
    1:                 oldListener(do_QueryInterface(mTreeOwner));
    1:             nsCOMPtr<nsIWebProgressListener>
    1:                 newListener(do_QueryInterface(aTreeOwner));
    1: 
    1:             if (oldListener) {
    1:                 webProgress->RemoveProgressListener(oldListener);
    1:             }
    1: 
    1:             if (newListener) {
    1:                 webProgress->AddProgressListener(newListener,
    1:                                                  nsIWebProgress::NOTIFY_ALL);
    1:             }
    1:         }
    1:     }
    1: 
    1:     mTreeOwner = aTreeOwner;    // Weak reference per API
    1: 
29263:     PRInt32 i, n = mChildList.Count();
    1:     for (i = 0; i < n; i++) {
29263:         nsCOMPtr<nsIDocShellTreeItem> child = do_QueryInterface(ChildAt(i));
    1:         NS_ENSURE_TRUE(child, NS_ERROR_FAILURE);
    1:         PRInt32 childType = ~mItemType; // Set it to not us in case the get fails
    1:         child->GetItemType(&childType); // We don't care if this fails, if it does we won't set the owner
    1:         if (childType == mItemType)
    1:             child->SetTreeOwner(aTreeOwner);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 1585: nsDocShell::SetChildOffset(PRUint32 aChildOffset)
    1: {
    1:     mChildOffset = aChildOffset;
    1:     return NS_OK;
    1: }
    1: 
 2400: NS_IMETHODIMP
 2400: nsDocShell::GetIsInUnload(PRBool* aIsInUnload)
 2400: {
 2400:     *aIsInUnload = mFiredUnloadEvent;
 2400:     return NS_OK;
 2400: }
 2400: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIDocShellTreeNode
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetChildCount(PRInt32 * aChildCount)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChildCount);
29263:     *aChildCount = mChildList.Count();
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::AddChild(nsIDocShellTreeItem * aChild)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChild);
    1: 
    1:     nsRefPtr<nsDocLoader> childAsDocLoader = GetAsDocLoader(aChild);
    1:     NS_ENSURE_TRUE(childAsDocLoader, NS_ERROR_UNEXPECTED);
    1: 
    1:     // Make sure we're not creating a loop in the docshell tree
    1:     nsDocLoader* ancestor = this;
    1:     do {
    1:         if (childAsDocLoader == ancestor) {
    1:             return NS_ERROR_ILLEGAL_VALUE;
    1:         }
    1:         ancestor = ancestor->GetParent();
    1:     } while (ancestor);
    1:     
    1:     // Make sure to remove the child from its current parent.
    1:     nsDocLoader* childsParent = childAsDocLoader->GetParent();
    1:     if (childsParent) {
    1:         childsParent->RemoveChildLoader(childAsDocLoader);
    1:     }
    1: 
    1:     // Make sure to clear the treeowner in case this child is a different type
    1:     // from us.
    1:     aChild->SetTreeOwner(nsnull);
    1:     
    1:     nsresult res = AddChildLoader(childAsDocLoader);
    1:     NS_ENSURE_SUCCESS(res, res);
29263:     NS_ASSERTION(mChildList.Count() > 0,
 1585:                  "child list must not be empty after a successful add");
    1: 
    1:     // Set the child's index in the parent's children list 
    1:     // XXX What if the parent had different types of children?
    1:     // XXX in that case docshell hierarchy and SH hierarchy won't match.
 1585:     {
 1585:         nsCOMPtr<nsIDocShell> childDocShell = do_QueryInterface(aChild);
14757:         if (childDocShell) {
14757:             // If there are frameloaders in the finalization list, reduce
14757:             // the offset so that the SH hierarchy is more likely to match the
14757:             // docshell hierarchy
14757:             nsCOMPtr<nsIDOMDocument> domDoc =
14757:               do_GetInterface(GetAsSupports(this));
14757:             nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
29263:             PRUint32 offset = mChildList.Count() - 1;
14757:             if (doc) {
14757:                PRUint32 oldChildCount = offset; // Current child count - 1
14757:                for (PRUint32 i = 0; i < oldChildCount; ++i) {
29263:                  nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
14757:                  if (doc->FrameLoaderScheduledToBeFinalized(child)) {
14757:                    --offset;
14757:                  }
14757:                }
14757:             }
14757: 
14757:             childDocShell->SetChildOffset(offset);
14757:         }
 1585:     }
    1: 
    1:     /* Set the child's global history if the parent has one */
    1:     if (mGlobalHistory) {
    1:         nsCOMPtr<nsIDocShellHistory>
    1:             dsHistoryChild(do_QueryInterface(aChild));
    1:         if (dsHistoryChild)
    1:             dsHistoryChild->SetUseGlobalHistory(PR_TRUE);
    1:     }
    1: 
    1: 
    1:     PRInt32 childType = ~mItemType;     // Set it to not us in case the get fails
    1:     aChild->GetItemType(&childType);
    1:     if (childType != mItemType)
    1:         return NS_OK;
    1:     // Everything below here is only done when the child is the same type.
    1: 
    1: 
    1:     aChild->SetTreeOwner(mTreeOwner);
    1: 
    1:     nsCOMPtr<nsIDocShell> childAsDocShell(do_QueryInterface(aChild));
    1:     if (!childAsDocShell)
    1:         return NS_OK;
    1: 
    1:     // charset, style-disabling, and zoom will be inherited in SetupNewViewer()
    1: 
    1:     // Now take this document's charset and set the parentCharset field of the 
    1:     // child's DocumentCharsetInfo to it. We'll later use that field, in the 
    1:     // loading process, for the charset choosing algorithm.
    1:     // If we fail, at any point, we just return NS_OK.
    1:     // This code has some performance impact. But this will be reduced when 
    1:     // the current charset will finally be stored as an Atom, avoiding the
    1:     // alias resolution extra look-up.
    1: 
    1:     // we are NOT going to propagate the charset is this Chrome's docshell
    1:     if (mItemType == nsIDocShellTreeItem::typeChrome)
    1:         return NS_OK;
    1: 
    1:     // get the child's docCSInfo object
    1:     nsCOMPtr<nsIDocumentCharsetInfo> dcInfo = NULL;
    1:     res = childAsDocShell->GetDocumentCharsetInfo(getter_AddRefs(dcInfo));
    1:     if (NS_FAILED(res) || (!dcInfo))
    1:         return NS_OK;
    1: 
    1:     // get the parent's current charset
    1:     nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(mContentViewer));
    1:     if (!docv)
    1:         return NS_OK;
    1:     nsCOMPtr<nsIDocument> doc;
    1:     res = docv->GetDocument(getter_AddRefs(doc));
    1:     if (NS_FAILED(res) || (!doc))
    1:         return NS_OK;
    1:     const nsACString &parentCS = doc->GetDocumentCharacterSet();
    1: 
    1:     PRBool isWyciwyg = PR_FALSE;
    1: 
    1:     if (mCurrentURI) {
    1:         // Check if the url is wyciwyg
    1:         mCurrentURI->SchemeIs("wyciwyg", &isWyciwyg);      
    1:     }
    1: 
    1:     if (!isWyciwyg) {
    1:         // If this docshell is loaded from a wyciwyg: URI, don't
    1:         // advertise our charset since it does not in any way reflect
    1:         // the actual source charset, which is what we're trying to
    1:         // expose here.
    1: 
    1:         // set the child's parentCharset
    1:         nsCOMPtr<nsIAtom> parentCSAtom(do_GetAtom(parentCS));
    1:         res = dcInfo->SetParentCharset(parentCSAtom);
    1:         if (NS_FAILED(res))
    1:             return NS_OK;
    1: 
    1:         PRInt32 charsetSource = doc->GetDocumentCharacterSetSource();
    1: 
    1:         // set the child's parentCharset
    1:         res = dcInfo->SetParentCharsetSource(charsetSource);
    1:         if (NS_FAILED(res))
    1:             return NS_OK;
    1:     }
    1: 
    1:     // printf("### 1 >>> Adding child. Parent CS = %s. ItemType = %d.\n", NS_LossyConvertUTF16toASCII(parentCS).get(), mItemType);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::RemoveChild(nsIDocShellTreeItem * aChild)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChild);
    1: 
    1:     nsRefPtr<nsDocLoader> childAsDocLoader = GetAsDocLoader(aChild);
    1:     NS_ENSURE_TRUE(childAsDocLoader, NS_ERROR_UNEXPECTED);
    1:     
    1:     nsresult rv = RemoveChildLoader(childAsDocLoader);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     aChild->SetTreeOwner(nsnull);
    1: 
    1:     return nsDocLoader::AddDocLoaderAsChildOfRoot(childAsDocLoader);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetChildAt(PRInt32 aIndex, nsIDocShellTreeItem ** aChild)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChild);
    1: 
    1: #ifdef DEBUG
    1:     if (aIndex < 0) {
    1:       NS_WARNING("Negative index passed to GetChildAt");
    1:     }
29263:     else if (aIndex >= mChildList.Count()) {
    1:       NS_WARNING("Too large an index passed to GetChildAt");
    1:     }
    1: #endif
    1: 
29263:     nsIDocumentLoader* child = SafeChildAt(aIndex);
    1:     NS_ENSURE_TRUE(child, NS_ERROR_UNEXPECTED);
    1:     
    1:     return CallQueryInterface(child, aChild);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::FindChildWithName(const PRUnichar * aName,
    1:                               PRBool aRecurse, PRBool aSameType,
    1:                               nsIDocShellTreeItem * aRequestor,
    1:                               nsIDocShellTreeItem * aOriginalRequestor,
    1:                               nsIDocShellTreeItem ** _retval)
    1: {
    1:     NS_ENSURE_ARG(aName);
    1:     NS_ENSURE_ARG_POINTER(_retval);
    1: 
    1:     *_retval = nsnull;          // if we don't find one, we return NS_OK and a null result 
    1: 
    1:     if (!*aName)
    1:         return NS_OK;
    1: 
    1:     nsXPIDLString childName;
29263:     PRInt32 i, n = mChildList.Count();
    1:     for (i = 0; i < n; i++) {
29263:         nsCOMPtr<nsIDocShellTreeItem> child = do_QueryInterface(ChildAt(i));
    1:         NS_ENSURE_TRUE(child, NS_ERROR_FAILURE);
    1:         PRInt32 childType;
    1:         child->GetItemType(&childType);
    1: 
    1:         if (aSameType && (childType != mItemType))
    1:             continue;
    1: 
    1:         PRBool childNameEquals = PR_FALSE;
    1:         child->NameEquals(aName, &childNameEquals);
    1:         if (childNameEquals && ItemIsActive(child) &&
    1:             CanAccessItem(child, aOriginalRequestor)) {
    1:             child.swap(*_retval);
    1:             break;
    1:         }
    1: 
    1:         if (childType != mItemType)     //Only ask it to check children if it is same type
    1:             continue;
    1: 
    1:         if (aRecurse && (aRequestor != child))  // Only ask the child if it isn't the requestor
    1:         {
    1:             // See if child contains the shell with the given name
    1: #ifdef DEBUG
    1:             nsresult rv =
    1: #endif
 1160:             child->FindChildWithName(aName, PR_TRUE,
    1:                                      aSameType,
 3233:                                      static_cast<nsIDocShellTreeItem*>
 3233:                                                 (this),
    1:                                      aOriginalRequestor,
    1:                                      _retval);
    1:             NS_ASSERTION(NS_SUCCEEDED(rv),
    1:                          "FindChildWithName should not fail here");
    1:             if (*_retval)           // found it
    1:                 return NS_OK;
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIDocShellHistory
    1: //*****************************************************************************   
    1: NS_IMETHODIMP
    1: nsDocShell::GetChildSHEntry(PRInt32 aChildOffset, nsISHEntry ** aResult)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     NS_ENSURE_ARG_POINTER(aResult);
    1:     *aResult = nsnull;
    1: 
    1:     
    1:     // A nsISHEntry for a child is *only* available when the parent is in
    1:     // the progress of loading a document too...
    1:     
    1:     if (mLSHE) {
    1:         /* Before looking for the subframe's url, check
    1:          * the expiration status of the parent. If the parent
    1:          * has expired from cache, then subframes will not be 
    1:          * loaded from history in certain situations.  
    1:          */
    1:         PRBool parentExpired=PR_FALSE;
    1:         mLSHE->GetExpirationStatus(&parentExpired);
    1:         
    1:         /* Get the parent's Load Type so that it can be set on the child too.
    1:          * By default give a loadHistory value
    1:          */
    1:         PRUint32 loadType = nsIDocShellLoadInfo::loadHistory;
    1:         mLSHE->GetLoadType(&loadType);  
    1:         // If the user did a shift-reload on this frameset page, 
    1:         // we don't want to load the subframes from history.
    1:         if (loadType == nsIDocShellLoadInfo::loadReloadBypassCache ||
    1:             loadType == nsIDocShellLoadInfo::loadReloadBypassProxy ||
    1:             loadType == nsIDocShellLoadInfo::loadReloadBypassProxyAndCache ||
    1:             loadType == nsIDocShellLoadInfo::loadRefresh)
    1:             return rv;
    1:         
    1:         /* If the user pressed reload and the parent frame has expired
    1:          *  from cache, we do not want to load the child frame from history.
    1:          */
    1:         if (parentExpired && (loadType == nsIDocShellLoadInfo::loadReloadNormal)) {
    1:             // The parent has expired. Return null.
    1:             *aResult = nsnull;
    1:             return rv;
    1:         }
    1: 
    1:         nsCOMPtr<nsISHContainer> container(do_QueryInterface(mLSHE));
    1:         if (container) {
    1:             // Get the child subframe from session history.
    1:             rv = container->GetChildAt(aChildOffset, aResult);            
    1:             if (*aResult) 
    1:                 (*aResult)->SetLoadType(loadType);            
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::AddChildSHEntry(nsISHEntry * aCloneRef, nsISHEntry * aNewEntry,
    1:                             PRInt32 aChildOffset)
    1: {
    1:     nsresult rv;
    1: 
    1:     if (mLSHE) {
    1:         /* You get here if you are currently building a 
    1:          * hierarchy ie.,you just visited a frameset page
    1:          */
    1:         nsCOMPtr<nsISHContainer> container(do_QueryInterface(mLSHE, &rv));
    1:         if (container) {
    1:             rv = container->AddChild(aNewEntry, aChildOffset);
    1:         }
    1:     }
    1:     else if (!aCloneRef) {
    1:         /* This is an initial load in some subframe.  Just append it if we can */
    1:         nsCOMPtr<nsISHContainer> container(do_QueryInterface(mOSHE, &rv));
    1:         if (container) {
    1:             rv = container->AddChild(aNewEntry, aChildOffset);
    1:         }
    1:     }
    1:     else if (mSessionHistory) {
    1:         /* You are currently in the rootDocShell.
    1:          * You will get here when a subframe has a new url
    1:          * to load and you have walked up the tree all the 
    1:          * way to the top to clone the current SHEntry hierarchy
    1:          * and replace the subframe where a new url was loaded with
    1:          * a new entry.
    1:          */
    1:         PRInt32 index = -1;
    1:         nsCOMPtr<nsIHistoryEntry> currentHE;
    1:         mSessionHistory->GetIndex(&index);
    1:         if (index < 0)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         rv = mSessionHistory->GetEntryAtIndex(index, PR_FALSE,
    1:                                               getter_AddRefs(currentHE));
    1:         NS_ENSURE_TRUE(currentHE, NS_ERROR_FAILURE);
    1: 
    1:         nsCOMPtr<nsISHEntry> currentEntry(do_QueryInterface(currentHE));
    1:         if (currentEntry) {
    1:             PRUint32 cloneID = 0;
    1:             nsCOMPtr<nsISHEntry> nextEntry;
    1:             aCloneRef->GetID(&cloneID);
    1:             rv = CloneAndReplace(currentEntry, this, cloneID, aNewEntry,
    1:                                  getter_AddRefs(nextEntry));
    1: 
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 nsCOMPtr<nsISHistoryInternal>
    1:                     shPrivate(do_QueryInterface(mSessionHistory));
    1:                 NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
    1:                 rv = shPrivate->AddEntry(nextEntry, PR_TRUE);
    1:             }
    1:         }
    1:     }
    1:     else {
    1:         /* Just pass this along */
    1:         nsCOMPtr<nsIDocShellHistory> parent =
    1:             do_QueryInterface(GetAsSupports(mParent), &rv);
    1:         if (parent) {
    1:             rv = parent->AddChildSHEntry(aCloneRef, aNewEntry, aChildOffset);
    1:         }          
    1:     }
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::DoAddChildSHEntry(nsISHEntry* aNewEntry, PRInt32 aChildOffset)
    1: {
    1:     /* You will get here when you are in a subframe and
    1:      * a new url has been loaded on you. 
    1:      * The mOSHE in this subframe will be the previous url's
    1:      * mOSHE. This mOSHE will be used as the identification
    1:      * for this subframe in the  CloneAndReplace function.
    1:      */
    1: 
19870:     // In this case, we will end up calling AddEntry, which increases the
19870:     // current index by 1
19870:     nsCOMPtr<nsISHistory> rootSH;
19870:     GetRootSessionHistory(getter_AddRefs(rootSH));
19870:     if (rootSH) {
19870:         rootSH->GetIndex(&mPreviousTransIndex);
19870:     }
19870: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsIDocShellHistory> parent =
    1:         do_QueryInterface(GetAsSupports(mParent), &rv);
    1:     if (parent) {
    1:         rv = parent->AddChildSHEntry(mOSHE, aNewEntry, aChildOffset);
    1:     }
    1: 
19870: 
19870:     if (rootSH) {
19870:         rootSH->GetIndex(&mLoadedTransIndex);
19870: #ifdef DEBUG_PAGE_CACHE
19870:         printf("Previous index: %d, Loaded index: %d\n\n", mPreviousTransIndex,
19870:                mLoadedTransIndex);
19870: #endif
19870:     }
19870: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetUseGlobalHistory(PRBool aUseGlobalHistory)
    1: {
    1:     nsresult rv;
    1: 
    1:     if (!aUseGlobalHistory) {
    1:         mGlobalHistory = nsnull;
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (mGlobalHistory) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     mGlobalHistory = do_GetService(NS_GLOBALHISTORY2_CONTRACTID, &rv);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetUseGlobalHistory(PRBool *aUseGlobalHistory)
    1: {
    1:     *aUseGlobalHistory = (mGlobalHistory != nsnull);
    1:     return NS_OK;
    1: }
    1: 
    1: //-------------------------------------
    1: //-- Helper Method for Print discovery
    1: //-------------------------------------
    1: PRBool 
    1: nsDocShell::IsPrintingOrPP(PRBool aDisplayErrorDialog)
    1: {
    1:   if (mIsPrintingOrPP && aDisplayErrorDialog) {
    1:     DisplayLoadError(NS_ERROR_DOCUMENT_IS_PRINTMODE, nsnull, nsnull);
    1:   }
    1: 
    1:   return mIsPrintingOrPP;
    1: }
    1: 
 2400: PRBool
 2400: nsDocShell::IsNavigationAllowed(PRBool aDisplayPrintErrorDialog)
 2400: {
 2400:     return !IsPrintingOrPP(aDisplayPrintErrorDialog) && !mFiredUnloadEvent;
 2400: }
 2400: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIWebNavigation
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCanGoBack(PRBool * aCanGoBack)
    1: {
 2400:     if (!IsNavigationAllowed(PR_FALSE)) {
    1:       *aCanGoBack = PR_FALSE;
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GetCanGoBack(aCanGoBack);   
    1:     return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCanGoForward(PRBool * aCanGoForward)
    1: {
 2400:     if (!IsNavigationAllowed(PR_FALSE)) {
    1:       *aCanGoForward = PR_FALSE;
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH)); 
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GetCanGoForward(aCanGoForward);
    1:     return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GoBack()
    1: {
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GoBack();
    1:     return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GoForward()
    1: {
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GoForward();
    1:     return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::GotoIndex(PRInt32 aIndex)
    1: {
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GotoIndex(aIndex);
    1:     return rv;
    1: 
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::LoadURI(const PRUnichar * aURI,
    1:                     PRUint32 aLoadFlags,
    1:                     nsIURI * aReferringURI,
    1:                     nsIInputStream * aPostStream,
    1:                     nsIInputStream * aHeaderStream)
    1: {
21935:     NS_ASSERTION((aLoadFlags & 0xf) == 0, "Unexpected flags");
21935:     
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsCOMPtr<nsIURI> uri;
    1:     nsresult rv = NS_OK;
    1: 
    1:     // Create a URI from our string; if that succeeds, we want to
    1:     // change aLoadFlags to not include the ALLOW_THIRD_PARTY_FIXUP
    1:     // flag.
    1: 
    1:     NS_ConvertUTF16toUTF8 uriString(aURI);
    1:     // Cleanup the empty spaces that might be on each end.
    1:     uriString.Trim(" ");
    1:     // Eliminate embedded newlines, which single-line text fields now allow:
    1:     uriString.StripChars("\r\n");
    1:     NS_ENSURE_TRUE(!uriString.IsEmpty(), NS_ERROR_FAILURE);
    1: 
    1:     rv = NS_NewURI(getter_AddRefs(uri), uriString);
    1:     if (uri) {
    1:         aLoadFlags &= ~LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
    1:     }
    1:     
    1:     if (sURIFixup) {
    1:         // Call the fixup object.  This will clobber the rv from NS_NewURI
    1:         // above, but that's fine with us.  Note that we need to do this even
    1:         // if NS_NewURI returned a URI, because fixup handles nested URIs, etc
    1:         // (things like view-source:mozilla.org for example).
    1:         PRUint32 fixupFlags = 0;
    1:         if (aLoadFlags & LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP) {
    1:           fixupFlags |= nsIURIFixup::FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP;
    1:         }
    1:         rv = sURIFixup->CreateFixupURI(uriString, fixupFlags,
    1:                                        getter_AddRefs(uri));
    1:     }
    1:     // else no fixup service so just use the URI we created and see
    1:     // what happens
    1: 
    1:     if (NS_ERROR_MALFORMED_URI == rv) {
    1:         DisplayLoadError(rv, uri, aURI);
    1:     }
    1: 
    1:     if (NS_FAILED(rv) || !uri)
    1:         return NS_ERROR_FAILURE;
    1: 
 5873:     PopupControlState popupState;
 5873:     if (aLoadFlags & LOAD_FLAGS_ALLOW_POPUPS) {
 5873:         popupState = openAllowed;
 5873:         aLoadFlags &= ~LOAD_FLAGS_ALLOW_POPUPS;
 5873:     } else {
 5873:         popupState = openOverridden;
 5873:     }
 5873:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
 5873:     nsAutoPopupStatePusher statePusher(win, popupState);
 5873: 
 2235:     // Don't pass certain flags that aren't needed and end up confusing
 2235:     // ConvertLoadTypeToDocShellLoadInfo.  We do need to ensure that they are
 2235:     // passed to LoadURI though, since it uses them.
 2235:     PRUint32 extraFlags = (aLoadFlags & EXTRA_LOAD_FLAGS);
 2235:     aLoadFlags &= ~EXTRA_LOAD_FLAGS;
    1: 
    1:     nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
    1:     rv = CreateLoadInfo(getter_AddRefs(loadInfo));
    1:     if (NS_FAILED(rv)) return rv;
    1:     
    1:     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_NORMAL, aLoadFlags);
    1:     loadInfo->SetLoadType(ConvertLoadTypeToDocShellLoadInfo(loadType));
    1:     loadInfo->SetPostDataStream(aPostStream);
    1:     loadInfo->SetReferrer(aReferringURI);
    1:     loadInfo->SetHeadersStream(aHeaderStream);
    1: 
 2235:     rv = LoadURI(uri, loadInfo, extraFlags, PR_TRUE);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::DisplayLoadError(nsresult aError, nsIURI *aURI,
    1:                              const PRUnichar *aURL,
    1:                              nsIChannel* aFailedChannel)
    1: {
    1:     // Get prompt and string bundle servcies
    1:     nsCOMPtr<nsIPrompt> prompter;
    1:     nsCOMPtr<nsIStringBundle> stringBundle;
    1:     GetPromptAndStringBundle(getter_AddRefs(prompter),
    1:                              getter_AddRefs(stringBundle));
    1: 
    1:     NS_ENSURE_TRUE(stringBundle, NS_ERROR_FAILURE);
    1:     NS_ENSURE_TRUE(prompter, NS_ERROR_FAILURE);
    1: 
    1:     nsAutoString error;
13314:     const PRUint32 kMaxFormatStrArgs = 3;
    1:     nsAutoString formatStrs[kMaxFormatStrArgs];
    1:     PRUint32 formatStrCount = 0;
13314:     PRBool addHostPort = PR_FALSE;
    1:     nsresult rv = NS_OK;
    1:     nsAutoString messageStr;
 5528:     nsCAutoString cssClass;
 7236:     nsCAutoString errorPage;
 7236: 
 7236:     errorPage.AssignLiteral("neterror");
    1: 
    1:     // Turn the error code into a human readable error message.
    1:     if (NS_ERROR_UNKNOWN_PROTOCOL == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
    1:         // extract the scheme
    1:         nsCAutoString scheme;
    1:         aURI->GetScheme(scheme);
    1:         CopyASCIItoUTF16(scheme, formatStrs[0]);
    1:         formatStrCount = 1;
    1:         error.AssignLiteral("protocolNotFound");
    1:     }
    1:     else if (NS_ERROR_FILE_NOT_FOUND == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
    1:         error.AssignLiteral("fileNotFound");
    1:     }
    1:     else if (NS_ERROR_UNKNOWN_HOST == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
    1:         // Get the host
    1:         nsCAutoString host;
 8889:         nsCOMPtr<nsIURI> innermostURI = NS_GetInnermostURI(aURI);
 8889:         innermostURI->GetHost(host);
    1:         CopyUTF8toUTF16(host, formatStrs[0]);
    1:         formatStrCount = 1;
    1:         error.AssignLiteral("dnsNotFound");
    1:     }
    1:     else if(NS_ERROR_CONNECTION_REFUSED == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
13314:         addHostPort = PR_TRUE;
    1:         error.AssignLiteral("connectionFailure");
    1:     }
    1:     else if(NS_ERROR_NET_INTERRUPT == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
13314:         addHostPort = PR_TRUE;
    1:         error.AssignLiteral("netInterrupt");
    1:     }
    1:     else if (NS_ERROR_NET_TIMEOUT == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
    1:         // Get the host
    1:         nsCAutoString host;
    1:         aURI->GetHost(host);
    1:         CopyUTF8toUTF16(host, formatStrs[0]);
    1:         formatStrCount = 1;
    1:         error.AssignLiteral("netTimeout");
    1:     }
    1:     else if (NS_ERROR_GET_MODULE(aError) == NS_ERROR_MODULE_SECURITY) {
 7252:         nsCOMPtr<nsINSSErrorsService> nsserr =
 7252:             do_GetService(NS_NSS_ERRORS_SERVICE_CONTRACTID);
 7252: 
 7252:         PRUint32 errorClass;
 7252:         if (!nsserr ||
 7252:             NS_FAILED(nsserr->GetErrorClass(aError, &errorClass))) {
 7252:           errorClass = nsINSSErrorsService::ERROR_CLASS_SSL_PROTOCOL;
 7252:         }
 7252: 
    1:         nsCOMPtr<nsISupports> securityInfo;
    1:         nsCOMPtr<nsITransportSecurityInfo> tsi;
    1:         if (aFailedChannel)
    1:             aFailedChannel->GetSecurityInfo(getter_AddRefs(securityInfo));
    1:         tsi = do_QueryInterface(securityInfo);
    1:         if (tsi) {
    1:             // Usually we should have aFailedChannel and get a detailed message
    1:             tsi->GetErrorMessage(getter_Copies(messageStr));
    1:         }
    1:         else {
    1:             // No channel, let's obtain the generic error message
    1:             if (nsserr) {
    1:                 nsserr->GetErrorMessage(aError, messageStr);
    1:             }
    1:         }
 7252:         if (!messageStr.IsEmpty()) {
 7252:             if (errorClass == nsINSSErrorsService::ERROR_CLASS_BAD_CERT) {
 7252:                 error.AssignLiteral("nssBadCert");
14875:                 PRBool expert = PR_FALSE;
14875:                 mPrefs->GetBoolPref("browser.xul.error_pages.expert_bad_cert",
14875:                                     &expert);
14875:                 if (expert) {
14875:                     cssClass.AssignLiteral("expertBadCert");
14875:                 }
21051:                 
21051:                 // See if an alternate cert error page is registered
21051:                 nsXPIDLCString alternateErrorPage;
21051:                 mPrefs->GetCharPref("security.alternate_certificate_error_page",
21051:                                     getter_Copies(alternateErrorPage));
21051:                 if (alternateErrorPage)
21051:                     errorPage.Assign(alternateErrorPage);
 7252:             } else {
 2609:                 error.AssignLiteral("nssFailure2");
 7252:             }
 7252:         }
 7236:     } else if (NS_ERROR_PHISHING_URI == aError || NS_ERROR_MALWARE_URI == aError) {
 7236:         nsCAutoString host;
 7236:         aURI->GetHost(host);
 7236:         CopyUTF8toUTF16(host, formatStrs[0]);
 7236:         formatStrCount = 1;
 7236: 
 7236:         // Malware and phishing detectors may want to use an alternate error
 7236:         // page, but if the pref's not set, we'll fall back on the standard page
 7236:         nsXPIDLCString alternateErrorPage;
 7236:         mPrefs->GetCharPref("urlclassifier.alternate_error_page",
 7236:                             getter_Copies(alternateErrorPage));
 7236:         if (alternateErrorPage)
 7236:             errorPage.Assign(alternateErrorPage);
 7236: 
 7236:         if (NS_ERROR_PHISHING_URI == aError)
 7236:             error.AssignLiteral("phishingBlocked");
 7236:         else
 7236:             error.AssignLiteral("malwareBlocked");
 7236:         cssClass.AssignLiteral("blacklist");
    1:     }
    1:     else {
    1:         // Errors requiring simple formatting
    1:         switch (aError) {
    1:         case NS_ERROR_MALFORMED_URI:
    1:             // URI is malformed
    1:             error.AssignLiteral("malformedURI");
    1:             break;
    1:         case NS_ERROR_REDIRECT_LOOP:
    1:             // Doc failed to load because the server generated too many redirects
    1:             error.AssignLiteral("redirectLoop");
    1:             break;
    1:         case NS_ERROR_UNKNOWN_SOCKET_TYPE:
    1:             // Doc failed to load because PSM is not installed
    1:             error.AssignLiteral("unknownSocketType");
    1:             break;
    1:         case NS_ERROR_NET_RESET:
    1:             // Doc failed to load because the server kept reseting the connection
    1:             // before we could read any data from it
    1:             error.AssignLiteral("netReset");
    1:             break;
    1:         case NS_ERROR_DOCUMENT_NOT_CACHED:
13314:             // Doc failed to load because we are offline and the cache does not
    1:             // contain a copy of the document.
    1:             error.AssignLiteral("netOffline");
    1:             break;
    1:         case NS_ERROR_DOCUMENT_IS_PRINTMODE:
    1:             // Doc navigation attempted while Printing or Print Preview
    1:             error.AssignLiteral("isprinting");
    1:             break;
    1:         case NS_ERROR_PORT_ACCESS_NOT_ALLOWED:
    1:             // Port blocked for security reasons
13314:             addHostPort = PR_TRUE;
    1:             error.AssignLiteral("deniedPortAccess");
    1:             break;
    1:         case NS_ERROR_UNKNOWN_PROXY_HOST:
    1:             // Proxy hostname could not be resolved.
    1:             error.AssignLiteral("proxyResolveFailure");
    1:             break;
    1:         case NS_ERROR_PROXY_CONNECTION_REFUSED:
    1:             // Proxy connection was refused.
    1:             error.AssignLiteral("proxyConnectFailure");
    1:             break;
    1:         case NS_ERROR_INVALID_CONTENT_ENCODING:
    1:             // Bad Content Encoding.
    1:             error.AssignLiteral("contentEncodingError");
    1:             break;
 8363:         case NS_ERROR_UNSAFE_CONTENT_TYPE:
 8363:             // Channel refused to load from an unrecognized content type.
 8363:             error.AssignLiteral("unsafeContentType");
 8363:             break;
    1:         }
    1:     }
    1: 
    1:     // Test if the error should be displayed
    1:     if (error.IsEmpty()) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Test if the error needs to be formatted
    1:     if (!messageStr.IsEmpty()) {
    1:         // already obtained message
    1:     }
13314:     else {
13314:         if (addHostPort) {
13314:             // Build up the host:port string.
13314:             nsCAutoString hostport;
13314:             if (aURI) {
13314:                 aURI->GetHostPort(hostport);
13314:             } else {
13314:                 hostport.AssignLiteral("?");
13314:             }
13314:             CopyUTF8toUTF16(hostport, formatStrs[formatStrCount++]);
13314:         }
13314: 
13314:         nsCAutoString spec;
13314:         rv = NS_ERROR_NOT_AVAILABLE;
13314:         if (aURI) {
13314:             // displaying "file://" is aesthetically unpleasing and could even be
13314:             // confusing to the user
13314:             PRBool isFileURI = PR_FALSE;
13314:             rv = aURI->SchemeIs("file", &isFileURI);
13314:             if (NS_SUCCEEDED(rv) && isFileURI)
13314:                 aURI->GetPath(spec);
13314:             else
13314:                 aURI->GetSpec(spec);
13314: 
13314:             nsCAutoString charset;
13314:             // unescape and convert from origin charset
13314:             aURI->GetOriginCharset(charset);
13314:             nsCOMPtr<nsITextToSubURI> textToSubURI(
13314:                 do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv));
13314:             if (NS_SUCCEEDED(rv)) {
13314:                 rv = textToSubURI->UnEscapeURIForUI(charset, spec, formatStrs[formatStrCount]);
13314:             }
13314:         } else {
13314:             spec.AssignLiteral("?");
13314:         }
13314:         if (NS_FAILED(rv))
13314:             CopyUTF8toUTF16(spec, formatStrs[formatStrCount]);
13314:         rv = NS_OK;
13314:         ++formatStrCount;
13314: 
    1:         const PRUnichar *strs[kMaxFormatStrArgs];
    1:         for (PRUint32 i = 0; i < formatStrCount; i++) {
    1:             strs[i] = formatStrs[i].get();
    1:         }
    1:         nsXPIDLString str;
    1:         rv = stringBundle->FormatStringFromName(
    1:             error.get(),
    1:             strs, formatStrCount, getter_Copies(str));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:         messageStr.Assign(str.get());
    1:     }
    1: 
    1:     // Display the error as a page or an alert prompt
    1:     NS_ENSURE_FALSE(messageStr.IsEmpty(), NS_ERROR_FAILURE);
    1:     // Note: For now, display an alert instead of an error page if we have no
    1:     // URI object. Missing URI objects are handled badly by session history.
    1:     if (mUseErrorPages && aURI && aFailedChannel) {
    1:         // Display an error page
 7236:         LoadErrorPage(aURI, aURL, errorPage.get(), error.get(),
 7236:                       messageStr.get(), cssClass.get(), aFailedChannel);
    1:     } 
    1:     else
    1:     {
    1:         // The prompter reqires that our private window has a document (or it
    1:         // asserts). Satisfy that assertion now since GetDocument will force
    1:         // creation of one if it hasn't already been created.
    1:         nsCOMPtr<nsPIDOMWindow> pwin(do_QueryInterface(mScriptGlobal));
    1:         if (pwin) {
    1:             nsCOMPtr<nsIDOMDocument> doc;
    1:             pwin->GetDocument(getter_AddRefs(doc));
    1:         }
    1: 
    1:         // Display a message box
    1:         prompter->Alert(nsnull, messageStr.get());
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::LoadErrorPage(nsIURI *aURI, const PRUnichar *aURL,
 7236:                           const char *aErrorPage,
    1:                           const PRUnichar *aErrorType,
    1:                           const PRUnichar *aDescription,
 5528:                           const char *aCSSClass,
    1:                           nsIChannel* aFailedChannel)
    1: {
    1: #if defined(PR_LOGGING) && defined(DEBUG)
    1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         aURI->GetSpec(spec);
    1: 
    1:         nsCAutoString chanName;
    1:         if (aFailedChannel)
    1:             aFailedChannel->GetName(chanName);
    1:         else
    1:             chanName.AssignLiteral("<no channel>");
    1: 
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:                ("nsDocShell[%p]::LoadErrorPage(\"%s\", \"%s\", {...}, [%s])\n", this,
    1:                 spec.get(), NS_ConvertUTF16toUTF8(aURL).get(), chanName.get()));
    1:     }
    1: #endif
34780:     mFailedChannel = aFailedChannel;
34780:     mFailedURI = aURI;
34780:     mFailedLoadType = mLoadType;
34780: 
    1:     nsCAutoString url;
    1:     nsCAutoString charset;
    1:     if (aURI)
    1:     {
    1:         nsresult rv = aURI->GetSpec(url);
    1:         rv |= aURI->GetOriginCharset(charset);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else if (aURL)
    1:     {
    1:         CopyUTF16toUTF8(aURL, url);
    1:     }
    1:     else
    1:     {
    1:         return NS_ERROR_INVALID_POINTER;
    1:     }
    1: 
    1:     // Create a URL to pass all the error information through to the page.
    1: 
    1:     char *escapedUrl = nsEscape(url.get(), url_Path);
    1:     char *escapedCharset = nsEscape(charset.get(), url_Path);
    1:     char *escapedError = nsEscape(NS_ConvertUTF16toUTF8(aErrorType).get(), url_Path);
    1:     char *escapedDescription = nsEscape(NS_ConvertUTF16toUTF8(aDescription).get(), url_Path);
 5528:     char *escapedCSSClass = nsEscape(aCSSClass, url_Path);
    1: 
 7236:     nsCString errorPageUrl("about:");
 7236:     errorPageUrl.AppendASCII(aErrorPage);
 7236:     errorPageUrl.AppendLiteral("?e=");
    1: 
    1:     errorPageUrl.AppendASCII(escapedError);
    1:     errorPageUrl.AppendLiteral("&u=");
    1:     errorPageUrl.AppendASCII(escapedUrl);
 5528:     if (escapedCSSClass && escapedCSSClass[0]) {
 5528:         errorPageUrl.AppendASCII("&s=");
 5528:         errorPageUrl.AppendASCII(escapedCSSClass);
 5528:     }
    1:     errorPageUrl.AppendLiteral("&c=");
    1:     errorPageUrl.AppendASCII(escapedCharset);
    1:     errorPageUrl.AppendLiteral("&d=");
    1:     errorPageUrl.AppendASCII(escapedDescription);
    1: 
    1:     nsMemory::Free(escapedDescription);
    1:     nsMemory::Free(escapedError);
    1:     nsMemory::Free(escapedUrl);
    1:     nsMemory::Free(escapedCharset);
 5528:     nsMemory::Free(escapedCSSClass);
    1: 
    1:     nsCOMPtr<nsIURI> errorPageURI;
    1:     nsresult rv = NS_NewURI(getter_AddRefs(errorPageURI), errorPageUrl);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
20758:     return InternalLoad(errorPageURI, nsnull, nsnull,
20758:                         INTERNAL_LOAD_FLAGS_INHERIT_OWNER, nsnull, nsnull,
    1:                         nsnull, nsnull, LOAD_ERROR_PAGE,
    1:                         nsnull, PR_TRUE, nsnull, nsnull);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Reload(PRUint32 aReloadFlags)
    1: {
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     NS_ASSERTION(((aReloadFlags & 0xf) == 0),
    1:                  "Reload command not updated to use load flags!");
21935:     NS_ASSERTION((aReloadFlags & EXTRA_LOAD_FLAGS) == 0,
21935:                  "Don't pass these flags to Reload");
    1: 
    1:     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_RELOAD_NORMAL, aReloadFlags);
    1:     NS_ENSURE_TRUE(IsValidLoadType(loadType), NS_ERROR_INVALID_ARG);
    1: 
    1:     // Send notifications to the HistoryListener if any, about the impending reload
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsISHistoryInternal> shistInt(do_QueryInterface(rootSH));
    1:     PRBool canReload = PR_TRUE; 
    1:     if (rootSH) {
    1:       nsCOMPtr<nsISHistoryListener> listener;
    1:       shistInt->GetListener(getter_AddRefs(listener));
    1:       if (listener) {
    1:         listener->OnHistoryReload(mCurrentURI, aReloadFlags, &canReload);
    1:       }
    1:     }
    1: 
    1:     if (!canReload)
    1:       return NS_OK;
    1:     
    1:     /* If you change this part of code, make sure bug 45297 does not re-occur */
    1:     if (mOSHE) {
    1:         rv = LoadHistoryEntry(mOSHE, loadType);
    1:     }
    1:     else if (mLSHE) { // In case a reload happened before the current load is done
    1:         rv = LoadHistoryEntry(mLSHE, loadType);
    1:     }
    1:     else {
    1:         nsCOMPtr<nsIDOMDocument> domDoc(do_GetInterface(GetAsSupports(this)));
    1:         nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
    1: 
    1:         nsIPrincipal* principal = nsnull;
    1:         nsAutoString contentTypeHint;
    1:         if (doc) {
    1:             principal = doc->NodePrincipal();
    1:             doc->GetContentType(contentTypeHint);
    1:         }
    1: 
    1:         rv = InternalLoad(mCurrentURI,
    1:                           mReferrerURI,
    1:                           principal,
    1:                           INTERNAL_LOAD_FLAGS_NONE, // Do not inherit owner from document
    1:                           nsnull,         // No window target
    1:                           NS_LossyConvertUTF16toASCII(contentTypeHint).get(),
    1:                           nsnull,         // No post data
    1:                           nsnull,         // No headers data
    1:                           loadType,       // Load type
    1:                           nsnull,         // No SHEntry
    1:                           PR_TRUE,
    1:                           nsnull,         // No nsIDocShell
    1:                           nsnull);        // No nsIRequest
    1:     }
    1:     
14631: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Stop(PRUint32 aStopFlags)
    1: {
    1:     // Revoke any pending event related to content viewer restoration
    1:     mRestorePresentationEvent.Revoke();
    1: 
34780:     if (mLoadType == LOAD_ERROR_PAGE) {
34780:         if (mLSHE) {
30832:             // Since error page loads never unset mLSHE, do so now
30832:             SetHistoryEntry(&mOSHE, mLSHE);
30832:             SetHistoryEntry(&mLSHE, nsnull);
30832:         }
30832: 
34780:         mFailedChannel = nsnull;
34780:         mFailedURI = nsnull;
34780:     }
34780: 
 5536:     if (nsIWebNavigation::STOP_CONTENT & aStopFlags) {
    1:         // Stop the document loading
    1:         if (mContentViewer)
    1:             mContentViewer->Stop();
    1:     }
    1: 
    1:     if (nsIWebNavigation::STOP_NETWORK & aStopFlags) {
    1:         // Suspend any timers that were set for this loader.  We'll clear
    1:         // them out for good in CreateContentViewer.
    1:         if (mRefreshURIList) {
    1:             SuspendRefreshURIs();
    1:             mSavedRefreshURIList.swap(mRefreshURIList);
    1:             mRefreshURIList = nsnull;
    1:         }
    1: 
 5528:         if (mClassifier) {
 5528:             mClassifier->Cancel();
 5528:             mClassifier = nsnull;
 5528:         }
 5528: 
    1:         // XXXbz We could also pass |this| to nsIURILoader::Stop.  That will
    1:         // just call Stop() on us as an nsIDocumentLoader... We need fewer
    1:         // redundant apis!
    1:         Stop();
    1:     }
    1: 
29263:     PRInt32 n;
29263:     PRInt32 count = mChildList.Count();
    1:     for (n = 0; n < count; n++) {
29263:         nsCOMPtr<nsIWebNavigation> shellAsNav(do_QueryInterface(ChildAt(n)));
    1:         if (shellAsNav)
    1:             shellAsNav->Stop(aStopFlags);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetDocument(nsIDOMDocument ** aDocument)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aDocument);
    1:     NS_ENSURE_SUCCESS(EnsureContentViewer(), NS_ERROR_FAILURE);
    1: 
    1:     return mContentViewer->GetDOMDocument(aDocument);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCurrentURI(nsIURI ** aURI)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aURI);
    1: 
    1:     if (mCurrentURI) {
    1:         return NS_EnsureSafeToReturn(mCurrentURI, aURI);
    1:     }
    1: 
    1:     *aURI = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetReferringURI(nsIURI ** aURI)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aURI);
    1: 
    1:     *aURI = mReferrerURI;
    1:     NS_IF_ADDREF(*aURI);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetSessionHistory(nsISHistory * aSessionHistory)
    1: {
    1: 
    1:     NS_ENSURE_TRUE(aSessionHistory, NS_ERROR_FAILURE);
    1:     // make sure that we are the root docshell and
    1:     // set a handle to root docshell in SH.
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1:     /* Get the root docshell. If *this* is the root docshell
    1:      * then save a handle to *this* in SH. SH needs it to do
    1:      * traversions thro' its entries
    1:      */
    1:     GetSameTypeRootTreeItem(getter_AddRefs(root));
    1:     NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
 3233:     if (root.get() == static_cast<nsIDocShellTreeItem *>(this)) {
    1:         mSessionHistory = aSessionHistory;
    1:         nsCOMPtr<nsISHistoryInternal>
    1:             shPrivate(do_QueryInterface(mSessionHistory));
    1:         NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
    1:         shPrivate->SetRootDocShell(this);
    1:         return NS_OK;
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: 
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSessionHistory(nsISHistory ** aSessionHistory)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aSessionHistory);
    1:     *aSessionHistory = mSessionHistory;
    1:     NS_IF_ADDREF(*aSessionHistory);
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIWebPageDescriptor
    1: //*****************************************************************************   
    1: NS_IMETHODIMP
    1: nsDocShell::LoadPage(nsISupports *aPageDescriptor, PRUint32 aDisplayType)
    1: {
    1:     nsCOMPtr<nsISHEntry> shEntryIn(do_QueryInterface(aPageDescriptor));
    1: 
    1:     // Currently, the opaque 'page descriptor' is an nsISHEntry...
    1:     if (!shEntryIn) {
    1:         return NS_ERROR_INVALID_POINTER;
    1:     }
    1: 
    1:     // Now clone shEntryIn, since we might end up modifying it later on, and we
    1:     // want a page descriptor to be reusable.
    1:     nsCOMPtr<nsISHEntry> shEntry;
    1:     nsresult rv = shEntryIn->Clone(getter_AddRefs(shEntry));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     //
    1:     // load the page as view-source
    1:     //
    1:     if (nsIWebPageDescriptor::DISPLAY_AS_SOURCE == aDisplayType) {
    1:         nsCOMPtr<nsIURI> oldUri, newUri;
    1:         nsCString spec, newSpec;
    1: 
    1:         // Create a new view-source URI and replace the original.
    1:         rv = shEntry->GetURI(getter_AddRefs(oldUri));
    1:         if (NS_FAILED(rv))
    1:               return rv;
    1: 
    1:         oldUri->GetSpec(spec);
    1:         newSpec.AppendLiteral("view-source:");
    1:         newSpec.Append(spec);
    1: 
    1:         rv = NS_NewURI(getter_AddRefs(newUri), newSpec);
    1:         if (NS_FAILED(rv)) {
    1:             return rv;
    1:         }
    1:         shEntry->SetURI(newUri);
    1:     }
    1: 
    1:     rv = LoadHistoryEntry(shEntry, LOAD_HISTORY);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCurrentDescriptor(nsISupports **aPageDescriptor)
    1: {
    1:     NS_PRECONDITION(aPageDescriptor, "Null out param?");
    1: 
    1:     *aPageDescriptor = nsnull;
    1: 
    1:     nsISHEntry* src = mOSHE ? mOSHE : mLSHE;
    1:     if (src) {
    1:         nsCOMPtr<nsISHEntry> dest;
    1: 
    1:         nsresult rv = src->Clone(getter_AddRefs(dest));
    1:         if (NS_FAILED(rv)) {
    1:             return rv;
    1:         }
    1: 
    1:         // null out inappropriate cloned attributes...
    1:         dest->SetParent(nsnull);
    1:         dest->SetIsSubFrame(PR_FALSE);
    1:         
    1:         return CallQueryInterface(dest, aPageDescriptor);
    1:     }
    1: 
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIBaseWindow
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::InitWindow(nativeWindow parentNativeWindow,
    1:                        nsIWidget * parentWidget, PRInt32 x, PRInt32 y,
    1:                        PRInt32 cx, PRInt32 cy)
    1: {
    1:     SetParentWidget(parentWidget);
    1:     SetPositionAndSize(x, y, cx, cy, PR_FALSE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Create()
    1: {
28078:     if (mPrefs) {
28078:         // We've already been created
28078:         return NS_OK;
28078:     }
28078: 
    1:     NS_ASSERTION(mItemType == typeContent || mItemType == typeChrome,
    1:                  "Unexpected item type in docshell");
    1: 
    1:     nsresult rv = NS_ERROR_FAILURE;
    1:     mPrefs = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRBool tmpbool;
    1: 
    1:     rv = mPrefs->GetBoolPref("browser.frames.enabled", &tmpbool);
    1:     if (NS_SUCCEEDED(rv))
    1:         mAllowSubframes = tmpbool;
    1: 
    1:     if (gValidateOrigin == (PRBool)0xffffffff) {
    1:         // Check pref to see if we should prevent frameset spoofing
    1:         rv = mPrefs->GetBoolPref("browser.frame.validate_origin", &tmpbool);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             gValidateOrigin = tmpbool;
    1:         } else {
    1:             gValidateOrigin = PR_TRUE;
    1:         }
    1:     }
    1: 
    1:     // Should we use XUL error pages instead of alerts if possible?
    1:     rv = mPrefs->GetBoolPref("browser.xul.error_pages.enabled", &tmpbool);
    1:     if (NS_SUCCEEDED(rv))
    1:         mUseErrorPages = tmpbool;
    1: 
    1:     nsCOMPtr<nsIPrefBranch2> prefs(do_QueryInterface(mPrefs, &rv));
    1:     if (NS_SUCCEEDED(rv) && mObserveErrorPages) {
    1:         prefs->AddObserver("browser.xul.error_pages.enabled", this, PR_FALSE);
    1:     }
    1: 
    1:     nsCOMPtr<nsIObserverService> serv = do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
    1:     if (serv) {
    1:         const char* msg = mItemType == typeContent ?
    1:             NS_WEBNAVIGATION_CREATE : NS_CHROME_WEBNAVIGATION_CREATE;
    1:         serv->NotifyObservers(GetAsSupports(this), msg, nsnull);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Destroy()
    1: {
    1:     NS_ASSERTION(mItemType == typeContent || mItemType == typeChrome,
    1:                  "Unexpected item type in docshell");
    1: 
    1:     if (!mIsBeingDestroyed) {
    1:         nsCOMPtr<nsIObserverService> serv =
    1:             do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
    1:         if (serv) {
    1:             const char* msg = mItemType == typeContent ?
    1:                 NS_WEBNAVIGATION_DESTROY : NS_CHROME_WEBNAVIGATION_DESTROY;
    1:             serv->NotifyObservers(GetAsSupports(this), msg, nsnull);
    1:         }
    1:     }
    1:     
    1:     mIsBeingDestroyed = PR_TRUE;
    1: 
    1:     // Remove our pref observers
    1:     if (mObserveErrorPages) {
    1:         nsCOMPtr<nsIPrefBranch2> prefs(do_QueryInterface(mPrefs));
    1:         if (prefs) {
    1:             prefs->RemoveObserver("browser.xul.error_pages.enabled", this);
    1:             mObserveErrorPages = PR_FALSE;
    1:         }
    1:     }
    1: 
10676:     // Make sure to blow away our mLoadingURI just in case.  No loads
10676:     // from inside this pagehide.
10676:     mLoadingURI = nsnull;
10676: 
    1:     // Fire unload event before we blow anything away.
    1:     (void) FirePageHideNotification(PR_TRUE);
    1: 
15052:     // Clear pointers to any detached nsEditorData that's lying
15052:     // around in shistory entries. Breaks cycle. See bug 430921.
15052:     if (mOSHE)
15052:       mOSHE->SetEditorData(nsnull);
15052:     if (mLSHE)
15052:       mLSHE->SetEditorData(nsnull);
15052:       
    1:     // Note: mContentListener can be null if Init() failed and we're being
    1:     // called from the destructor.
    1:     if (mContentListener) {
    1:         mContentListener->DropDocShellreference();
    1:         mContentListener->SetParentContentListener(nsnull);
    1:         // Note that we do NOT set mContentListener to null here; that
    1:         // way if someone tries to do a load in us after this point
    1:         // the nsDSURIContentListener will block it.  All of which
    1:         // means that we should do this before calling Stop(), of
    1:         // course.
    1:     }
    1: 
    1:     // Stop any URLs that are currently being loaded...
    1:     Stop(nsIWebNavigation::STOP_ALL);
    1: 
14631:     mEditorData = nsnull;
    1: 
    1:     mTransferableHookData = nsnull;
    1: 
    1:     // Save the state of the current document, before destroying the window.
    1:     // This is needed to capture the state of a frameset when the new document
    1:     // causes the frameset to be destroyed...
    1:     PersistLayoutHistoryState();
    1: 
    1:     // Remove this docshell from its parent's child list
 1160:     nsCOMPtr<nsIDocShellTreeItem> docShellParentAsItem =
    1:         do_QueryInterface(GetAsSupports(mParent));
 1160:     if (docShellParentAsItem)
 1160:         docShellParentAsItem->RemoveChild(this);
    1: 
    1:     if (mContentViewer) {
    1:         mContentViewer->Close(nsnull);
    1:         mContentViewer->Destroy();
    1:         mContentViewer = nsnull;
    1:     }
    1: 
    1:     nsDocLoader::Destroy();
    1:     
    1:     mParentWidget = nsnull;
    1:     mCurrentURI = nsnull;
    1: 
    1:     if (mScriptGlobal) {
    1:         nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
    1:         win->SetDocShell(nsnull);
    1: 
    1:         mScriptGlobal = nsnull;
    1:     }
    1: 
27412:     if (mSessionHistory) {
27412:         // We want to destroy these content viewers now rather than
27412:         // letting their destruction wait for the session history
27412:         // entries to get garbage collected.  (Bug 488394)
27412:         nsCOMPtr<nsISHistoryInternal> shPrivate =
27412:             do_QueryInterface(mSessionHistory);
27412:         if (shPrivate) {
27412:             shPrivate->EvictAllContentViewers();
27412:         }
    1:         mSessionHistory = nsnull;
27412:     }
27412: 
    1:     SetTreeOwner(nsnull);
    1: 
    1:     // required to break ref cycle
    1:     mSecurityUI = nsnull;
    1: 
    1:     // Cancel any timers that were set for this docshell; this is needed
    1:     // to break the cycle between us and the timers.
    1:     CancelRefreshURITimers();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetPosition(PRInt32 x, PRInt32 y)
    1: {
    1:     mBounds.x = x;
    1:     mBounds.y = y;
    1: 
    1:     if (mContentViewer)
    1:         NS_ENSURE_SUCCESS(mContentViewer->Move(x, y), NS_ERROR_FAILURE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPosition(PRInt32 * aX, PRInt32 * aY)
    1: {
    1:     PRInt32 dummyHolder;
    1:     return GetPositionAndSize(aX, aY, &dummyHolder, &dummyHolder);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetSize(PRInt32 aCX, PRInt32 aCY, PRBool aRepaint)
    1: {
    1:     PRInt32 x = 0, y = 0;
    1:     GetPosition(&x, &y);
    1:     return SetPositionAndSize(x, y, aCX, aCY, aRepaint);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSize(PRInt32 * aCX, PRInt32 * aCY)
    1: {
    1:     PRInt32 dummyHolder;
    1:     return GetPositionAndSize(&dummyHolder, &dummyHolder, aCX, aCY);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetPositionAndSize(PRInt32 x, PRInt32 y, PRInt32 cx,
    1:                                PRInt32 cy, PRBool fRepaint)
    1: {
    1:     mBounds.x = x;
    1:     mBounds.y = y;
    1:     mBounds.width = cx;
    1:     mBounds.height = cy;
    1: 
 6162:     // Hold strong ref, since SetBounds can make us null out mContentViewer
 6162:     nsCOMPtr<nsIContentViewer> viewer = mContentViewer;
 6162:     if (viewer) {
    1:         //XXX Border figured in here or is that handled elsewhere?
 6162:         NS_ENSURE_SUCCESS(viewer->SetBounds(mBounds), NS_ERROR_FAILURE);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPositionAndSize(PRInt32 * x, PRInt32 * y, PRInt32 * cx,
    1:                                PRInt32 * cy)
    1: {
    1:     // We should really consider just getting this information from
    1:     // our window instead of duplicating the storage and code...
33393:     if (cx || cy) {
33393:         // Caller wants to know our size; make sure to give them up to
33393:         // date information.
    1:         nsCOMPtr<nsIDOMDocument> document(do_GetInterface(GetAsSupports(mParent)));
    1:         nsCOMPtr<nsIDocument> doc(do_QueryInterface(document));
    1:         if (doc) {
    1:             doc->FlushPendingNotifications(Flush_Layout);
    1:         }
33393:     }
    1:     
 1027:     DoGetPositionAndSize(x, y, cx, cy);
 1027:     return NS_OK;
 1027: }
 1027: 
 1027: void
 1027: nsDocShell::DoGetPositionAndSize(PRInt32 * x, PRInt32 * y, PRInt32 * cx,
 1027:                                  PRInt32 * cy)
 1027: {    
    1:     if (x)
    1:         *x = mBounds.x;
    1:     if (y)
    1:         *y = mBounds.y;
    1:     if (cx)
    1:         *cx = mBounds.width;
    1:     if (cy)
    1:         *cy = mBounds.height;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Repaint(PRBool aForce)
    1: {
26050:     nsCOMPtr<nsIPresShell> presShell;
26050:     GetPresShell(getter_AddRefs(presShell));
26050:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
26050: 
26050:     nsIViewManager* viewManager = presShell->GetViewManager();
    1:     NS_ENSURE_TRUE(viewManager, NS_ERROR_FAILURE);
    1: 
    1:     // what about aForce ?
    1:     NS_ENSURE_SUCCESS(viewManager->UpdateAllViews(0), NS_ERROR_FAILURE);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetParentWidget(nsIWidget ** parentWidget)
    1: {
    1:     NS_ENSURE_ARG_POINTER(parentWidget);
    1: 
    1:     *parentWidget = mParentWidget;
    1:     NS_IF_ADDREF(*parentWidget);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetParentWidget(nsIWidget * aParentWidget)
    1: {
    1:     mParentWidget = aParentWidget;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetParentNativeWindow(nativeWindow * parentNativeWindow)
    1: {
    1:     NS_ENSURE_ARG_POINTER(parentNativeWindow);
    1: 
    1:     if (mParentWidget)
    1:         *parentNativeWindow = mParentWidget->GetNativeData(NS_NATIVE_WIDGET);
    1:     else
    1:         *parentNativeWindow = nsnull;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetParentNativeWindow(nativeWindow parentNativeWindow)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetVisibility(PRBool * aVisibility)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aVisibility);
21191: 
    1:     *aVisibility = PR_FALSE;
21191: 
21191:     if (!mContentViewer)
21191:         return NS_OK;
21191: 
    1:     nsCOMPtr<nsIPresShell> presShell;
21191:     GetPresShell(getter_AddRefs(presShell));
21191:     if (!presShell)
21191:         return NS_OK;
    1: 
    1:     // get the view manager
    1:     nsIViewManager* vm = presShell->GetViewManager();
    1:     NS_ENSURE_TRUE(vm, NS_ERROR_FAILURE);
    1: 
    1:     // get the root view
    1:     nsIView *view = nsnull; // views are not ref counted
    1:     NS_ENSURE_SUCCESS(vm->GetRootView(view), NS_ERROR_FAILURE);
    1:     NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
    1: 
    1:     // if our root view is hidden, we are not visible
21191:     if (view->GetVisibility() == nsViewVisibility_kHide)
21191:         return NS_OK;
    1: 
    1:     // otherwise, we must walk up the document and view trees checking
19435:     // for a hidden view, unless we're an off screen browser, which 
19435:     // would make this test meaningless.
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> treeItem = this;
    1:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
    1:     treeItem->GetParent(getter_AddRefs(parentItem));
    1:     while (parentItem) {
    1:         nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(treeItem));
    1:         docShell->GetPresShell(getter_AddRefs(presShell));
    1: 
    1:         nsCOMPtr<nsIDocShell> parentDS = do_QueryInterface(parentItem);
    1:         nsCOMPtr<nsIPresShell> pPresShell;
    1:         parentDS->GetPresShell(getter_AddRefs(pPresShell));
    1: 
    1:         // Null-check for crash in bug 267804
    1:         if (!pPresShell) {
21191:             NS_NOTREACHED("parent docshell has null pres shell");
    1:             return NS_OK;
    1:         }
    1: 
    1:         nsIContent *shellContent =
    1:             pPresShell->GetDocument()->FindContentForSubDocument(presShell->GetDocument());
    1:         NS_ASSERTION(shellContent, "subshell not in the map");
    1: 
    1:         nsIFrame* frame = pPresShell->GetPrimaryFrameFor(shellContent);
19435:         PRBool isDocShellOffScreen = PR_FALSE;
19435:         docShell->GetIsOffScreenBrowser(&isDocShellOffScreen);
21191:         if (frame && !frame->AreAncestorViewsVisible() && !isDocShellOffScreen)
21191:             return NS_OK;
    1: 
    1:         treeItem = parentItem;
    1:         treeItem->GetParent(getter_AddRefs(parentItem));
    1:     }
    1: 
21191:     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin(do_QueryInterface(mTreeOwner));
    1:     if (!treeOwnerAsWin) {
    1:         *aVisibility = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Check with the tree owner as well to give embedders a chance to
    1:     // expose visibility as well.
    1:     return treeOwnerAsWin->GetVisibility(aVisibility);
    1: }
    1: 
    1: NS_IMETHODIMP
19435: nsDocShell::SetIsOffScreenBrowser(PRBool aIsOffScreen) 
19435: {
19435:     mIsOffScreenBrowser = aIsOffScreen;
19435:     return NS_OK;
19435: }
19435: 
19435: NS_IMETHODIMP
19435: nsDocShell::GetIsOffScreenBrowser(PRBool *aIsOffScreen) 
19435: {
19435:     *aIsOffScreen = mIsOffScreenBrowser;
19435:     return NS_OK;
19435: }
19435: 
19435: NS_IMETHODIMP
    1: nsDocShell::SetVisibility(PRBool aVisibility)
    1: {
    1:     if (!mContentViewer)
    1:         return NS_OK;
    1:     if (aVisibility) {
    1:         mContentViewer->Show();
    1:     }
    1:     else {
    1:         mContentViewer->Hide();
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetEnabled(PRBool *aEnabled)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEnabled);
    1:   *aEnabled = PR_TRUE;
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetEnabled(PRBool aEnabled)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetBlurSuppression(PRBool *aBlurSuppression)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aBlurSuppression);
    1:   *aBlurSuppression = PR_FALSE;
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetBlurSuppression(PRBool aBlurSuppression)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
29018: nsDocShell::SetFocus()
29018: {
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
    1: nsDocShell::GetMainWidget(nsIWidget ** aMainWidget)
    1: {
    1:     // We don't create our own widget, so simply return the parent one. 
    1:     return GetParentWidget(aMainWidget);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetTitle(PRUnichar ** aTitle)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aTitle);
    1: 
    1:     *aTitle = ToNewUnicode(mTitle);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetTitle(const PRUnichar * aTitle)
    1: {
    1:     // Store local title
    1:     mTitle = aTitle;
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parent;
    1:     GetSameTypeParent(getter_AddRefs(parent));
    1: 
    1:     // When title is set on the top object it should then be passed to the 
    1:     // tree owner.
    1:     if (!parent) {
    1:         nsCOMPtr<nsIBaseWindow>
    1:             treeOwnerAsWin(do_QueryInterface(mTreeOwner));
    1:         if (treeOwnerAsWin)
    1:             treeOwnerAsWin->SetTitle(aTitle);
    1:     }
    1: 
    1:     if (mGlobalHistory && mCurrentURI && mLoadType != LOAD_ERROR_PAGE) {
    1:         mGlobalHistory->SetPageTitle(mCurrentURI, nsDependentString(aTitle));
    1:     }
    1: 
    1: 
31319:     // Update SessionHistory with the document's title.
31319:     if (mOSHE && mLoadType != LOAD_BYPASS_HISTORY &&
31319:         mLoadType != LOAD_ERROR_PAGE) {
31319: 
    1:         mOSHE->SetTitle(mTitle);    
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIScrollable
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCurScrollPos(PRInt32 scrollOrientation, PRInt32 * curPos)
    1: {
    1:     NS_ENSURE_ARG_POINTER(curPos);
    1: 
    1:     nsIScrollableView* scrollView;
    1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
    1:                       NS_ERROR_FAILURE);
    1:     if (!scrollView) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nscoord x, y;
    1:     NS_ENSURE_SUCCESS(scrollView->GetScrollPosition(x, y), NS_ERROR_FAILURE);
    1: 
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
    1:         *curPos = x;
    1:         return NS_OK;
    1: 
    1:     case ScrollOrientation_Y:
    1:         *curPos = y;
    1:         return NS_OK;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetCurScrollPos(PRInt32 scrollOrientation, PRInt32 curPos)
    1: {
    1:     nsIScrollableView* scrollView;
    1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
    1:                       NS_ERROR_FAILURE);
    1:     if (!scrollView) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     PRInt32 other;
    1:     PRInt32 x;
    1:     PRInt32 y;
    1: 
    1:     GetCurScrollPos(scrollOrientation, &other);
    1: 
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
    1:         x = curPos;
    1:         y = other;
    1:         break;
    1: 
    1:     case ScrollOrientation_Y:
    1:         x = other;
    1:         y = curPos;
    1:         break;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
    1:         x = 0;
    1:         y = 0;                  // fix compiler warning, not actually executed
    1:     }
    1: 
21290:     NS_ENSURE_SUCCESS(scrollView->ScrollTo(x, y, 0),
    1:                       NS_ERROR_FAILURE);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetCurScrollPosEx(PRInt32 curHorizontalPos, PRInt32 curVerticalPos)
    1: {
    1:     nsIScrollableView* scrollView;
    1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
    1:                       NS_ERROR_FAILURE);
    1:     if (!scrollView) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
21290:     NS_ENSURE_SUCCESS(scrollView->ScrollTo(curHorizontalPos, curVerticalPos, 0),
    1:                       NS_ERROR_FAILURE);
    1:     return NS_OK;
    1: }
    1: 
    1: // XXX This is wrong
    1: NS_IMETHODIMP
    1: nsDocShell::GetScrollRange(PRInt32 scrollOrientation,
    1:                            PRInt32 * minPos, PRInt32 * maxPos)
    1: {
    1:     NS_ENSURE_ARG_POINTER(minPos && maxPos);
    1: 
    1:     nsIScrollableView* scrollView;
    1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
    1:                       NS_ERROR_FAILURE);
    1:     if (!scrollView) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     PRInt32 cx;
    1:     PRInt32 cy;
    1: 
    1:     NS_ENSURE_SUCCESS(scrollView->GetContainerSize(&cx, &cy), NS_ERROR_FAILURE);
    1:     *minPos = 0;
    1: 
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
    1:         *maxPos = cx;
    1:         return NS_OK;
    1: 
    1:     case ScrollOrientation_Y:
    1:         *maxPos = cy;
    1:         return NS_OK;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
    1:     }
    1: 
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetScrollRange(PRInt32 scrollOrientation,
    1:                            PRInt32 minPos, PRInt32 maxPos)
    1: {
    1:     //XXX First Check
    1:     /*
    1:        Retrieves or Sets the valid ranges for the thumb.  When maxPos is set to 
    1:        something less than the current thumb position, curPos is set = to maxPos.
    1: 
    1:        @return NS_OK - Setting or Getting completed successfully.
    1:        NS_ERROR_INVALID_ARG - returned when curPos is not within the
    1:        minPos and maxPos.
    1:      */
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetScrollRangeEx(PRInt32 minHorizontalPos,
    1:                              PRInt32 maxHorizontalPos, PRInt32 minVerticalPos,
    1:                              PRInt32 maxVerticalPos)
    1: {
    1:     //XXX First Check
    1:     /*
    1:        Retrieves or Sets the valid ranges for the thumb.  When maxPos is set to 
    1:        something less than the current thumb position, curPos is set = to maxPos.
    1: 
    1:        @return NS_OK - Setting or Getting completed successfully.
    1:        NS_ERROR_INVALID_ARG - returned when curPos is not within the
    1:        minPos and maxPos.
    1:      */
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
28078: // This returns setting for all documents in this docshell
    1: NS_IMETHODIMP
    1: nsDocShell::GetDefaultScrollbarPreferences(PRInt32 scrollOrientation,
    1:                                            PRInt32 * scrollbarPref)
    1: {
    1:     NS_ENSURE_ARG_POINTER(scrollbarPref);
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
    1:         *scrollbarPref = mDefaultScrollbarPref.x;
    1:         return NS_OK;
    1: 
    1:     case ScrollOrientation_Y:
    1:         *scrollbarPref = mDefaultScrollbarPref.y;
    1:         return NS_OK;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // Set scrolling preference for all documents in this shell
    1: //
    1: // There are three possible values stored in the shell:
    1: //  1) nsIScrollable::Scrollbar_Never = no scrollbar
    1: //  2) nsIScrollable::Scrollbar_Auto = scrollbar appears if the document
    1: //     being displayed would normally have scrollbar
    1: //  3) nsIScrollable::Scrollbar_Always = scrollbar always appears
    1: //
    1: // One important client is nsHTMLFrameInnerFrame::CreateWebShell()
    1: NS_IMETHODIMP
    1: nsDocShell::SetDefaultScrollbarPreferences(PRInt32 scrollOrientation,
    1:                                            PRInt32 scrollbarPref)
    1: {
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
    1:         mDefaultScrollbarPref.x = scrollbarPref;
    1:         return NS_OK;
    1: 
    1:     case ScrollOrientation_Y:
    1:         mDefaultScrollbarPref.y = scrollbarPref;
    1:         return NS_OK;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetScrollbarVisibility(PRBool * verticalVisible,
    1:                                    PRBool * horizontalVisible)
    1: {
    1:     nsIScrollableView* scrollView;
    1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
    1:                       NS_ERROR_FAILURE);
    1:     if (!scrollView)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // We should now call nsLayoutUtils::GetScrollableFrameFor,
    1:     // but we can't because of stupid linkage!
    1:     nsIFrame* scrollFrame =
 3233:         static_cast<nsIFrame*>(scrollView->View()->GetParent()->GetClientData());
    1:     if (!scrollFrame)
    1:         return NS_ERROR_FAILURE;
23554:     nsIScrollableFrame* scrollable = do_QueryFrame(scrollFrame);
    1:     if (!scrollable)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsMargin scrollbars = scrollable->GetActualScrollbarSizes();
    1:     if (verticalVisible)
    1:         *verticalVisible = scrollbars.left != 0 || scrollbars.right != 0;
    1:     if (horizontalVisible)
    1:         *horizontalVisible = scrollbars.top != 0 || scrollbars.bottom != 0;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsITextScroll
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::ScrollByLines(PRInt32 numLines)
    1: {
    1:     nsIScrollableView* scrollView;
    1: 
    1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
    1:                       NS_ERROR_FAILURE);
    1:     if (!scrollView) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     NS_ENSURE_SUCCESS(scrollView->ScrollByLines(0, numLines), NS_ERROR_FAILURE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::ScrollByPages(PRInt32 numPages)
    1: {
    1:     nsIScrollableView* scrollView;
    1: 
    1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
    1:                       NS_ERROR_FAILURE);
    1:     if (!scrollView) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     NS_ENSURE_SUCCESS(scrollView->ScrollByPages(0, numPages), NS_ERROR_FAILURE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIScriptGlobalObjectOwner
    1: //*****************************************************************************   
    1: 
    1: nsIScriptGlobalObject*
    1: nsDocShell::GetScriptGlobalObject()
    1: {
    1:     NS_ENSURE_SUCCESS(EnsureScriptEnvironment(), nsnull);
    1: 
    1:     return mScriptGlobal;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIRefreshURI
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::RefreshURI(nsIURI * aURI, PRInt32 aDelay, PRBool aRepeat,
    1:                        PRBool aMetaRefresh)
    1: {
    1:     NS_ENSURE_ARG(aURI);
    1: 
    1:     /* Check if Meta refresh/redirects are permitted. Some
    1:      * embedded applications may not want to do this.
    1:      * Must do this before sending out NOTIFY_REFRESH events
    1:      * because listeners may have side effects (e.g. displaying a
    1:      * button to manually trigger the refresh later).
    1:      */
    1:     PRBool allowRedirects = PR_TRUE;
    1:     GetAllowMetaRedirects(&allowRedirects);
    1:     if (!allowRedirects)
    1:         return NS_OK;
    1: 
    1:     // If any web progress listeners are listening for NOTIFY_REFRESH events,
    1:     // give them a chance to block this refresh.
    1:     PRBool sameURI;
    1:     nsresult rv = aURI->Equals(mCurrentURI, &sameURI);
    1:     if (NS_FAILED(rv))
    1:         sameURI = PR_FALSE;
    1:     if (!RefreshAttempted(this, aURI, aDelay, sameURI))
    1:         return NS_OK;
    1: 
    1:     nsRefreshTimer *refreshTimer = new nsRefreshTimer();
    1:     NS_ENSURE_TRUE(refreshTimer, NS_ERROR_OUT_OF_MEMORY);
    1:     PRUint32 busyFlags = 0;
    1:     GetBusyFlags(&busyFlags);
    1: 
    1:     nsCOMPtr<nsISupports> dataRef = refreshTimer;    // Get the ref count to 1
    1: 
    1:     refreshTimer->mDocShell = this;
    1:     refreshTimer->mURI = aURI;
    1:     refreshTimer->mDelay = aDelay;
    1:     refreshTimer->mRepeat = aRepeat;
    1:     refreshTimer->mMetaRefresh = aMetaRefresh;
    1: 
    1:     if (!mRefreshURIList) {
    1:         NS_ENSURE_SUCCESS(NS_NewISupportsArray(getter_AddRefs(mRefreshURIList)),
    1:                           NS_ERROR_FAILURE);
    1:     }
    1: 
    1:     if (busyFlags & BUSY_FLAGS_BUSY) {
    1:         // We are busy loading another page. Don't create the
    1:         // timer right now. Instead queue up the request and trigger the
    1:         // timer in EndPageLoad(). 
    1:         mRefreshURIList->AppendElement(refreshTimer);
    1:     }
    1:     else {
    1:         // There is no page loading going on right now.  Create the
    1:         // timer and fire it right away.
    1:         nsCOMPtr<nsITimer> timer = do_CreateInstance("@mozilla.org/timer;1");
    1:         NS_ENSURE_TRUE(timer, NS_ERROR_FAILURE);
    1: 
    1:         mRefreshURIList->AppendElement(timer);      // owning timer ref
    1:         timer->InitWithCallback(refreshTimer, aDelay, nsITimer::TYPE_ONE_SHOT);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
18977: nsresult
18977: nsDocShell::ForceRefreshURIFromTimer(nsIURI * aURI,
18977:                                      PRInt32 aDelay, 
18977:                                      PRBool aMetaRefresh,
18977:                                      nsITimer* aTimer)
18977: {
18977:     NS_PRECONDITION(aTimer, "Must have a timer here");
18977: 
18977:     // Remove aTimer from mRefreshURIList if needed
18977:     if (mRefreshURIList) {
18977:         PRUint32 n = 0;
18977:         mRefreshURIList->Count(&n);
18977: 
18977:         for (PRUint32 i = 0;  i < n; ++i) {
18977:             nsCOMPtr<nsITimer> timer = do_QueryElementAt(mRefreshURIList, i);
18977:             if (timer == aTimer) {
18977:                 mRefreshURIList->RemoveElementAt(i);
18977:                 break;
18977:             }
18977:         }
18977:     }
18977: 
18977:     return ForceRefreshURI(aURI, aDelay, aMetaRefresh);
18977: }
18977: 
    1: NS_IMETHODIMP
    1: nsDocShell::ForceRefreshURI(nsIURI * aURI,
    1:                             PRInt32 aDelay, 
    1:                             PRBool aMetaRefresh)
    1: {
    1:     NS_ENSURE_ARG(aURI);
    1: 
    1:     nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
    1:     CreateLoadInfo(getter_AddRefs(loadInfo));
    1:     NS_ENSURE_TRUE(loadInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     /* We do need to pass in a referrer, but we don't want it to
    1:      * be sent to the server.
    1:      */
    1:     loadInfo->SetSendReferrer(PR_FALSE);
    1: 
    1:     /* for most refreshes the current URI is an appropriate
    1:      * internal referrer
    1:      */
    1:     loadInfo->SetReferrer(mCurrentURI);
    1: 
25969:     /* Don't ever "guess" on which owner to use to avoid picking
25969:      * the current owner.
25969:      */
25969:     loadInfo->SetOwnerIsExplicit(PR_TRUE);
25969: 
    1:     /* Check if this META refresh causes a redirection
    1:      * to another site. 
    1:      */
    1:     PRBool equalUri = PR_FALSE;
    1:     nsresult rv = aURI->Equals(mCurrentURI, &equalUri);
25969:     if (NS_SUCCEEDED(rv) && (!equalUri) && aMetaRefresh &&
25969:         aDelay <= REFRESH_REDIRECT_TIMER) {
25969: 
25969:         /* It is a META refresh based redirection within the threshold time
25969:          * we have in mind (15000 ms as defined by REFRESH_REDIRECT_TIMER).
25969:          * Pass a REPLACE flag to LoadURI().
    1:          */
    1:         loadInfo->SetLoadType(nsIDocShellLoadInfo::loadNormalReplace);
    1:             
    1:         /* for redirects we mimic HTTP, which passes the
    1:          *  original referrer
    1:          */
    1:         nsCOMPtr<nsIURI> internalReferrer;
    1:         GetReferringURI(getter_AddRefs(internalReferrer));
    1:         if (internalReferrer) {
    1:             loadInfo->SetReferrer(internalReferrer);
    1:         }
    1:     }
25969:     else {
    1:         loadInfo->SetLoadType(nsIDocShellLoadInfo::loadRefresh);
25969:     }
25969: 
    1:     /*
    1:      * LoadURI(...) will cancel all refresh timers... This causes the
    1:      * Timer and its refreshData instance to be released...
    1:      */
    1:     LoadURI(aURI, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, PR_TRUE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::SetupRefreshURIFromHeader(nsIURI * aBaseURI,
    1:                                       const nsACString & aHeader)
    1: {
    1:     // Refresh headers are parsed with the following format in mind
    1:     // <META HTTP-EQUIV=REFRESH CONTENT="5; URL=http://uri">
    1:     // By the time we are here, the following is true:
    1:     // header = "REFRESH"
    1:     // content = "5; URL=http://uri" // note the URL attribute is
    1:     // optional, if it is absent, the currently loaded url is used.
    1:     // Also note that the seconds and URL separator can be either
    1:     // a ';' or a ','. The ',' separator should be illegal but CNN
    1:     // is using it.
    1:     // 
    1:     // We need to handle the following strings, where
    1:     //  - X is a set of digits
    1:     //  - URI is either a relative or absolute URI
    1:     //
    1:     // Note that URI should start with "url=" but we allow omission
    1:     //
    1:     // "" || ";" || "," 
    1:     //  empty string. use the currently loaded URI
    1:     //  and refresh immediately.
    1:     // "X" || "X;" || "X,"
    1:     //  Refresh the currently loaded URI in X seconds.
    1:     // "X; URI" || "X, URI"
    1:     //  Refresh using URI as the destination in X seconds.
    1:     // "URI" || "; URI" || ", URI"
    1:     //  Refresh immediately using URI as the destination.
    1:     // 
    1:     // Currently, anything immediately following the URI, if
    1:     // separated by any char in the set "'\"\t\r\n " will be
    1:     // ignored. So "10; url=go.html ; foo=bar" will work,
    1:     // and so will "10; url='go.html'; foo=bar". However,
    1:     // "10; url=go.html; foo=bar" will result in the uri
    1:     // "go.html;" since ';' and ',' are valid uri characters.
    1:     // 
    1:     // Note that we need to remove any tokens wrapping the URI.
    1:     // These tokens currently include spaces, double and single
    1:     // quotes.
    1: 
    1:     // when done, seconds is 0 or the given number of seconds
    1:     //            uriAttrib is empty or the URI specified
    1:     nsCAutoString uriAttrib;
    1:     PRInt32 seconds = 0;
    1:     PRBool specifiesSeconds = PR_FALSE;
    1: 
    1:     nsACString::const_iterator iter, tokenStart, doneIterating;
    1: 
    1:     aHeader.BeginReading(iter);
    1:     aHeader.EndReading(doneIterating);
    1: 
    1:     // skip leading whitespace
    1:     while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:         ++iter;
    1: 
    1:     tokenStart = iter;
    1: 
    1:     // skip leading + and -
    1:     if (iter != doneIterating && (*iter == '-' || *iter == '+'))
    1:         ++iter;
    1: 
    1:     // parse number
    1:     while (iter != doneIterating && (*iter >= '0' && *iter <= '9')) {
    1:         seconds = seconds * 10 + (*iter - '0');
    1:         specifiesSeconds = PR_TRUE;
    1:         ++iter;
    1:     }
    1: 
    1:     if (iter != doneIterating) {
    1:         // if we started with a '-', number is negative
    1:         if (*tokenStart == '-')
    1:             seconds = -seconds;
    1: 
    1:         // skip to next ';' or ','
    1:         nsACString::const_iterator iterAfterDigit = iter;
    1:         while (iter != doneIterating && !(*iter == ';' || *iter == ','))
    1:         {
    1:             if (specifiesSeconds)
    1:             {
    1:                 // Non-whitespace characters here mean that the string is
    1:                 // malformed but tolerate sites that specify a decimal point,
    1:                 // even though meta refresh only works on whole seconds.
    1:                 if (iter == iterAfterDigit &&
    1:                     !nsCRT::IsAsciiSpace(*iter) && *iter != '.')
    1:                 {
    1:                     // The characters between the seconds and the next
    1:                     // section are just garbage!
    1:                     //   e.g. content="2a0z+,URL=http://www.mozilla.org/"
    1:                     // Just ignore this redirect.
    1:                     return NS_ERROR_FAILURE;
    1:                 }
    1:                 else if (nsCRT::IsAsciiSpace(*iter))
    1:                 {
    1:                     // We've had at least one whitespace so tolerate the mistake
    1:                     // and drop through.
    1:                     // e.g. content="10 foo"
    1:                     ++iter;
    1:                     break;
    1:                 }
    1:             }
    1:             ++iter;
    1:         }
    1: 
    1:         // skip any remaining whitespace
    1:         while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:             ++iter;
    1: 
    1:         // skip ';' or ','
    1:         if (iter != doneIterating && (*iter == ';' || *iter == ',')) {
    1:             ++iter;
    1:         }
    1: 
    1:         // skip whitespace
    1:         while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:             ++iter;
    1:     }
    1: 
    1:     // possible start of URI
    1:     tokenStart = iter;
    1: 
    1:     // skip "url = " to real start of URI
    1:     if (iter != doneIterating && (*iter == 'u' || *iter == 'U')) {
    1:         ++iter;
    1:         if (iter != doneIterating && (*iter == 'r' || *iter == 'R')) {
    1:             ++iter;
    1:             if (iter != doneIterating && (*iter == 'l' || *iter == 'L')) {
    1:                 ++iter;
    1: 
    1:                 // skip whitespace
    1:                 while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:                     ++iter;
    1: 
    1:                 if (iter != doneIterating && *iter == '=') {
    1:                     ++iter;
    1: 
    1:                     // skip whitespace
    1:                     while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:                         ++iter;
    1: 
    1:                     // found real start of URI
    1:                     tokenStart = iter;
    1:                 }
    1:             }
    1:         }
    1:     }
    1: 
    1:     // skip a leading '"' or '\''.
    1: 
    1:     PRBool isQuotedURI = PR_FALSE;
    1:     if (tokenStart != doneIterating && (*tokenStart == '"' || *tokenStart == '\''))
    1:     {
    1:         isQuotedURI = PR_TRUE;
    1:         ++tokenStart;
    1:     }
    1: 
    1:     // set iter to start of URI
    1:     iter = tokenStart;
    1: 
    1:     // tokenStart here points to the beginning of URI
    1: 
    1:     // grab the rest of the URI
    1:     while (iter != doneIterating)
    1:     {
    1:         if (isQuotedURI && (*iter == '"' || *iter == '\''))
    1:             break;
    1:         ++iter;
    1:     }
    1: 
    1:     // move iter one back if the last character is a '"' or '\''
    1:     if (iter != tokenStart && isQuotedURI) {
    1:         --iter;
    1:         if (!(*iter == '"' || *iter == '\''))
    1:             ++iter;
    1:     }
    1: 
    1:     // URI is whatever's contained from tokenStart to iter.
    1:     // note: if tokenStart == doneIterating, so is iter.
    1: 
    1:     nsresult rv = NS_OK;
    1: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     PRBool specifiesURI = PR_FALSE;
    1:     if (tokenStart == iter) {
    1:         uri = aBaseURI;
    1:     }
    1:     else {
    1:         uriAttrib = Substring(tokenStart, iter);
    1:         // NS_NewURI takes care of any whitespace surrounding the URL
    1:         rv = NS_NewURI(getter_AddRefs(uri), uriAttrib, nsnull, aBaseURI);
    1:         specifiesURI = PR_TRUE;
    1:     }
    1: 
    1:     // No URI or seconds were specified
    1:     if (!specifiesSeconds && !specifiesURI)
    1:     {
    1:         // Do nothing because the alternative is to spin around in a refresh
    1:         // loop forever!
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:         nsCOMPtr<nsIScriptSecurityManager>
    1:             securityManager(do_GetService
    1:                             (NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             rv = securityManager->
    1:                 CheckLoadURI(aBaseURI, uri,
    1:                              nsIScriptSecurityManager::
    1:                              LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT);
25969: 
25969:             if (NS_SUCCEEDED(rv)) {
25969:                 PRBool isjs = PR_TRUE;
25969:                 rv = NS_URIChainHasFlags(uri,
25969:                   nsIProtocolHandler::URI_OPENING_EXECUTES_SCRIPT, &isjs);
25969:                 NS_ENSURE_SUCCESS(rv, rv);
25969: 
25969:                 if (isjs) {
25969:                     return NS_ERROR_FAILURE;
25969:                 }
25969:             }
25969: 
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 // Since we can't travel back in time yet, just pretend
    1:                 // negative numbers do nothing at all.
    1:                 if (seconds < 0)
    1:                     return NS_ERROR_FAILURE;
    1: 
    1:                 rv = RefreshURI(uri, seconds * 1000, PR_FALSE, PR_TRUE);
    1:             }
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::SetupRefreshURI(nsIChannel * aChannel)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel, &rv));
    1:     if (NS_SUCCEEDED(rv)) {
    1:         nsCAutoString refreshHeader;
    1:         rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("refresh"),
    1:                                             refreshHeader);
    1: 
    1:         if (!refreshHeader.IsEmpty()) {
    1:             SetupReferrerFromChannel(aChannel);
    1:             rv = SetupRefreshURIFromHeader(mCurrentURI, refreshHeader);
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 return NS_REFRESHURI_HEADER_FOUND;
    1:             }
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: static void
    1: DoCancelRefreshURITimers(nsISupportsArray* aTimerList)
    1: {
    1:     if (!aTimerList)
    1:         return;
    1: 
    1:     PRUint32 n=0;
    1:     aTimerList->Count(&n);
    1: 
    1:     while (n) {
    1:         nsCOMPtr<nsITimer> timer(do_QueryElementAt(aTimerList, --n));
    1: 
    1:         aTimerList->RemoveElementAt(n);    // bye bye owning timer ref
    1: 
    1:         if (timer)
    1:             timer->Cancel();        
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::CancelRefreshURITimers()
    1: {
    1:     DoCancelRefreshURITimers(mRefreshURIList);
    1:     DoCancelRefreshURITimers(mSavedRefreshURIList);
    1:     mRefreshURIList = nsnull;
    1:     mSavedRefreshURIList = nsnull;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetRefreshPending(PRBool* _retval)
    1: {
    1:     if (!mRefreshURIList) {
    1:         *_retval = PR_FALSE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     PRUint32 count;
    1:     nsresult rv = mRefreshURIList->Count(&count);
    1:     if (NS_SUCCEEDED(rv))
    1:         *_retval = (count != 0);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SuspendRefreshURIs()
    1: {
    1:     if (mRefreshURIList) {
    1:         PRUint32 n = 0;
    1:         mRefreshURIList->Count(&n);
    1: 
    1:         for (PRUint32 i = 0;  i < n; ++i) {
    1:             nsCOMPtr<nsITimer> timer = do_QueryElementAt(mRefreshURIList, i);
    1:             if (!timer)
    1:                 continue;  // this must be a nsRefreshURI already
    1: 
    1:             // Replace this timer object with a nsRefreshTimer object.
    1:             nsCOMPtr<nsITimerCallback> callback;
    1:             timer->GetCallback(getter_AddRefs(callback));
    1: 
    1:             timer->Cancel();
    1: 
    1:             nsCOMPtr<nsITimerCallback> rt = do_QueryInterface(callback);
    1:             NS_ASSERTION(rt, "RefreshURIList timer callbacks should only be RefreshTimer objects");
    1: 
    1:             mRefreshURIList->ReplaceElementAt(rt, i);
    1:         }
    1:     }
    1: 
    1:     // Suspend refresh URIs for our child shells as well.
29263:     PRInt32 n = mChildList.Count();
29263: 
29263:     for (PRInt32 i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
    1:         if (shell)
    1:             shell->SuspendRefreshURIs();
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::ResumeRefreshURIs()
    1: {
    1:     RefreshURIFromQueue();
    1: 
    1:     // Resume refresh URIs for our child shells as well.
29263:     PRInt32 n = mChildList.Count();
29263: 
29263:     for (PRInt32 i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
    1:         if (shell)
    1:             shell->ResumeRefreshURIs();
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::RefreshURIFromQueue()
    1: {
    1:     if (!mRefreshURIList)
    1:         return NS_OK;
    1:     PRUint32 n = 0;
    1:     mRefreshURIList->Count(&n);
    1: 
    1:     while (n) {
    1:         nsCOMPtr<nsISupports> element;
    1:         mRefreshURIList->GetElementAt(--n, getter_AddRefs(element));
    1:         nsCOMPtr<nsITimerCallback> refreshInfo(do_QueryInterface(element));
    1: 
    1:         if (refreshInfo) {   
    1:             // This is the nsRefreshTimer object, waiting to be
    1:             // setup in a timer object and fired.                         
    1:             // Create the timer and  trigger it.
 3233:             PRUint32 delay = static_cast<nsRefreshTimer*>(static_cast<nsITimerCallback*>(refreshInfo))->GetDelay();
    1:             nsCOMPtr<nsITimer> timer = do_CreateInstance("@mozilla.org/timer;1");
    1:             if (timer) {    
    1:                 // Replace the nsRefreshTimer element in the queue with
    1:                 // its corresponding timer object, so that in case another
    1:                 // load comes through before the timer can go off, the timer will
    1:                 // get cancelled in CancelRefreshURITimer()
    1:                 mRefreshURIList->ReplaceElementAt(timer, n);
    1:                 timer->InitWithCallback(refreshInfo, delay, nsITimer::TYPE_ONE_SHOT);
    1:             }           
    1:         }        
    1:     }  // while
    1:  
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIContentViewerContainer
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Embed(nsIContentViewer * aContentViewer,
    1:                   const char *aCommand, nsISupports * aExtraInfo)
    1: {
    1:     // Save the LayoutHistoryState of the previous document, before
    1:     // setting up new document
    1:     PersistLayoutHistoryState();
    1: 
    1:     nsresult rv = SetupNewViewer(aContentViewer);
    1: 
    1:     // If we are loading a wyciwyg url from history, change the base URI for 
    1:     // the document to the original http url that created the document.write().
    1:     // This makes sure that all relative urls in a document.written page loaded
    1:     // via history work properly.
    1:     if (mCurrentURI &&
    1:        (mLoadType & LOAD_CMD_HISTORY ||
    1:         mLoadType == LOAD_RELOAD_NORMAL ||
    1:         mLoadType == LOAD_RELOAD_CHARSET_CHANGE)){
    1:         PRBool isWyciwyg = PR_FALSE;
    1:         // Check if the url is wyciwyg
    1:         rv = mCurrentURI->SchemeIs("wyciwyg", &isWyciwyg);      
    1:         if (isWyciwyg && NS_SUCCEEDED(rv))
    1:             SetBaseUrlForWyciwyg(aContentViewer);
    1:     }
    1:     // XXX What if SetupNewViewer fails?
14887:     if (mLSHE) {
14887:         // Restore the editing state, if it's stored in session history.
14887:         if (mLSHE->HasDetachedEditor()) {
14887:             ReattachEditorToWindow(mLSHE);
14887:         }
    1:         SetHistoryEntry(&mOSHE, mLSHE);
14887:     }
    1: 
    1:     PRBool updateHistory = PR_TRUE;
    1: 
    1:     // Determine if this type of load should update history
    1:     switch (mLoadType) {
    1:     case LOAD_NORMAL_REPLACE:
    1:     case LOAD_STOP_CONTENT_AND_REPLACE:
    1:     case LOAD_RELOAD_BYPASS_CACHE:
    1:     case LOAD_RELOAD_BYPASS_PROXY:
    1:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
    1:         updateHistory = PR_FALSE;
    1:         break;
    1:     default:
    1:         break;
    1:     }
    1: 
    1:     if (!updateHistory)
    1:         SetLayoutHistoryState(nsnull);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* void setIsPrinting (in boolean aIsPrinting); */
    1: NS_IMETHODIMP 
    1: nsDocShell::SetIsPrinting(PRBool aIsPrinting)
    1: {
    1:     mIsPrintingOrPP = aIsPrinting;
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIWebProgressListener
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnProgressChange(nsIWebProgress * aProgress,
    1:                              nsIRequest * aRequest,
    1:                              PRInt32 aCurSelfProgress,
    1:                              PRInt32 aMaxSelfProgress,
    1:                              PRInt32 aCurTotalProgress,
    1:                              PRInt32 aMaxTotalProgress)
    1: {
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnStateChange(nsIWebProgress * aProgress, nsIRequest * aRequest,
    1:                           PRUint32 aStateFlags, nsresult aStatus)
    1: {
    1:     nsresult rv;
    1: 
    1:     if ((~aStateFlags & (STATE_START | STATE_IS_NETWORK)) == 0) {
    1:         nsCOMPtr<nsIWyciwygChannel>  wcwgChannel(do_QueryInterface(aRequest));
    1:         nsCOMPtr<nsIWebProgress> webProgress =
    1:             do_QueryInterface(GetAsSupports(this));
    1: 
    1:         // Was the wyciwyg document loaded on this docshell?
    1:         if (wcwgChannel && !mLSHE && (mItemType == typeContent) && aProgress == webProgress.get()) {
    1:             nsCOMPtr<nsIURI> uri;
    1:             wcwgChannel->GetURI(getter_AddRefs(uri));
    1:         
    1:             PRBool equalUri = PR_TRUE;
    1:             // Store the wyciwyg url in session history, only if it is
    1:             // being loaded fresh for the first time. We don't want 
    1:             // multiple entries for successive loads
    1:             if (mCurrentURI &&
    1:                 NS_SUCCEEDED(uri->Equals(mCurrentURI, &equalUri)) &&
    1:                 !equalUri) {
    1:                 // This is a document.write(). Get the made-up url
    1:                 // from the channel and store it in session history.
22687:                 rv = AddToSessionHistory(uri, wcwgChannel, nsnull,
22687:                                          getter_AddRefs(mLSHE));
    1:                 SetCurrentURI(uri, aRequest, PR_TRUE);
    1:                 // Save history state of the previous page
    1:                 rv = PersistLayoutHistoryState();
24072:                 // We'll never get an Embed() for this load, so just go ahead
24072:                 // and SetHistoryEntry now.
    1:                 SetHistoryEntry(&mOSHE, mLSHE);
    1:             }
    1:         
    1:         }
    1:         // Page has begun to load
    1:         mBusyFlags = BUSY_FLAGS_BUSY | BUSY_FLAGS_BEFORE_PAGE_LOAD;
32813: 
32819:         if ((aStateFlags & STATE_RESTORING) == 0) {
32813:             // Show the progress cursor if the pref is set
32813:             PRBool tmpBool = PR_FALSE;
32813:             if (NS_SUCCEEDED(mPrefs->GetBoolPref("ui.use_activity_cursor", &tmpBool))
32813:                 && tmpBool) {
32813:                 nsCOMPtr<nsIWidget> mainWidget;
32813:                 GetMainWidget(getter_AddRefs(mainWidget));
32813:                 if (mainWidget) {
32813:                     mainWidget->SetCursor(eCursor_spinning);
32813:                 }
32813:             }
    1:         }
32819:     }
    1:     else if ((~aStateFlags & (STATE_TRANSFERRING | STATE_IS_DOCUMENT)) == 0) {
    1:         // Page is loading
    1:         mBusyFlags = BUSY_FLAGS_BUSY | BUSY_FLAGS_PAGE_LOADING;
    1:     }
    1:     else if ((aStateFlags & STATE_STOP) && (aStateFlags & STATE_IS_NETWORK)) {
    1:         // Page has finished loading
    1:         mBusyFlags = BUSY_FLAGS_NONE;
32813: 
32813:         // Hide the progress cursor if the pref is set
32813:         PRBool tmpBool = PR_FALSE;
32813:         if (NS_SUCCEEDED(mPrefs->GetBoolPref("ui.use_activity_cursor", &tmpBool))
32813:             && tmpBool) {
32813:             nsCOMPtr<nsIWidget> mainWidget;
32813:             GetMainWidget(getter_AddRefs(mainWidget));
32813:             if (mainWidget) {
32813:                 mainWidget->SetCursor(eCursor_standard);
32813:             }
32813:         }
    1:     }
    1:     if ((~aStateFlags & (STATE_IS_DOCUMENT | STATE_STOP)) == 0) {
    1:         nsCOMPtr<nsIWebProgress> webProgress =
    1:             do_QueryInterface(GetAsSupports(this));
    1:         // Is the document stop notification for this document?
    1:         if (aProgress == webProgress.get()) {
    1:             nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1:             EndPageLoad(aProgress, channel, aStatus);
    1:         }
    1:     }
    1:     // note that redirect state changes will go through here as well, but it
    1:     // is better to handle those in OnRedirectStateChange where more
    1:     // information is available.
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnLocationChange(nsIWebProgress * aProgress,
    1:                              nsIRequest * aRequest, nsIURI * aURI)
    1: {
    1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocShell::OnRedirectStateChange(nsIChannel* aOldChannel,
    1:                                   nsIChannel* aNewChannel,
    1:                                   PRUint32 aRedirectFlags,
    1:                                   PRUint32 aStateFlags)
    1: {
    1:     NS_ASSERTION(aStateFlags & STATE_REDIRECTING,
    1:                  "Calling OnRedirectStateChange when there is no redirect");
    1:     if (!(aStateFlags & STATE_IS_DOCUMENT))
    1:         return; // not a toplevel document
    1: 
 5528:     // If this load is being checked by the URI classifier, we need to
 5528:     // query the classifier again for the new URI.
 5528:     if (mClassifier) {
12968:         mClassifier->OnRedirect(aOldChannel, aNewChannel);
 5528:     }
 5528: 
    1:     nsCOMPtr<nsIGlobalHistory3> history3(do_QueryInterface(mGlobalHistory));
    1:     nsresult result = NS_ERROR_NOT_IMPLEMENTED;
    1:     if (history3) {
    1:         // notify global history of this redirect
    1:         result = history3->AddDocumentRedirect(aOldChannel, aNewChannel,
    1:                                                aRedirectFlags, !IsFrame());
    1:     }
    1: 
    1:     if (result == NS_ERROR_NOT_IMPLEMENTED) {
    1:         // when there is no GlobalHistory3, or it doesn't implement
    1:         // AddToplevelRedirect, we fall back to GlobalHistory2.  Just notify
21366:         // that the redirecting page was a rePdirect so it will be link colored
    1:         // but not visible.
    1:         nsCOMPtr<nsIURI> oldURI;
    1:         aOldChannel->GetURI(getter_AddRefs(oldURI));
    1:         if (! oldURI)
    1:             return; // nothing to tell anybody about
    1:         AddToGlobalHistory(oldURI, PR_TRUE, aOldChannel);
    1:     }
21311: 
21311:     // check if the new load should go through the application cache.
21311:     nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
21311:         do_QueryInterface(aNewChannel);
21311:     if (appCacheChannel) {
21311:         nsCOMPtr<nsIURI> newURI;
21311:         aNewChannel->GetURI(getter_AddRefs(newURI));
21311:         appCacheChannel->SetChooseApplicationCache(ShouldCheckAppCache(newURI));
21311:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnStatusChange(nsIWebProgress * aWebProgress,
    1:                            nsIRequest * aRequest,
    1:                            nsresult aStatus, const PRUnichar * aMessage)
    1: {
    1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnSecurityChange(nsIWebProgress * aWebProgress,
    1:                              nsIRequest * aRequest, PRUint32 state)
    1: {
    1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsDocShell::EndPageLoad(nsIWebProgress * aProgress,
    1:                         nsIChannel * aChannel, nsresult aStatus)
    1: {
28078:     if(!aChannel)
28078:         return NS_ERROR_NULL_POINTER;
28078:     
28078:     nsCOMPtr<nsIURI> url;
28078:     nsresult rv = aChannel->GetURI(getter_AddRefs(url));
28078:     if (NS_FAILED(rv)) return rv;
28078:   
28078:     // clean up reload state for meta charset
28078:     if (eCharsetReloadRequested == mCharsetReloadState)
28078:         mCharsetReloadState = eCharsetReloadStopOrigional;
28078:     else 
28078:         mCharsetReloadState = eCharsetReloadInit;
28078: 
28078:     // Save a pointer to the currently-loading history entry.
28078:     // nsDocShell::EndPageLoad will clear mLSHE, but we may need this history
28078:     // entry further down in this method.
28078:     nsCOMPtr<nsISHEntry> loadingSHE = mLSHE;
28078:   
    1:     //
    1:     // one of many safeguards that prevent death and destruction if
    1:     // someone is so very very rude as to bring this window down
    1:     // during this load handler.
    1:     //
    1:     nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
 5528: 
 5528:     // We're done with the URI classifier for this channel
 5528:     mClassifier = nsnull;
 5528: 
    1:     //
    1:     // Notify the ContentViewer that the Document has finished loading...
    1:     //
    1:     // This will cause any OnLoad(...) handlers to fire, if it is a HTML
    1:     // document...
    1:     //
    1:     if (!mEODForCurrentDocument && mContentViewer) {
    1:         mIsExecutingOnLoadHandler = PR_TRUE;
    1:         mContentViewer->LoadComplete(aStatus);
    1:         mIsExecutingOnLoadHandler = PR_FALSE;
    1: 
    1:         mEODForCurrentDocument = PR_TRUE;
    1: 
    1:         // If all documents have completed their loading
    1:         // favor native event dispatch priorities
    1:         // over performance
    1:         if (--gNumberOfDocumentsLoading == 0) {
    1:           // Hint to use normal native event dispatch priorities 
    1:           FavorPerformanceHint(PR_FALSE, NS_EVENT_STARVATION_DELAY_HINT);
    1:         }
    1:     }
    1:     /* Check if the httpChannel has any cache-control related response headers,
    1:      * like no-store, no-cache. If so, update SHEntry so that 
    1:      * when a user goes back/forward to this page, we appropriately do 
    1:      * form value restoration or load from server.
    1:      */
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1:     if (!httpChannel) // HttpChannel could be hiding underneath a Multipart channel.    
    1:         GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
    1: 
    1:     if (httpChannel) {
    1:         // figure out if SH should be saving layout state.
    1:         PRBool discardLayoutState = ShouldDiscardLayoutState(httpChannel);       
    1:         if (mLSHE && discardLayoutState && (mLoadType & LOAD_CMD_NORMAL) &&
    1:             (mLoadType != LOAD_BYPASS_HISTORY) && (mLoadType != LOAD_ERROR_PAGE))
    1:             mLSHE->SetSaveLayoutStateFlag(PR_FALSE);            
    1:     }
    1: 
    1:     // Clear mLSHE after calling the onLoadHandlers. This way, if the
    1:     // onLoadHandler tries to load something different in
    1:     // itself or one of its children, we can deal with it appropriately.
    1:     if (mLSHE) {
    1:         mLSHE->SetLoadType(nsIDocShellLoadInfo::loadHistory);
    1: 
    1:         // Clear the mLSHE reference to indicate document loading is done one
    1:         // way or another.
    1:         SetHistoryEntry(&mLSHE, nsnull);
    1:     }
    1:     // if there's a refresh header in the channel, this method
    1:     // will set it up for us. 
    1:     RefreshURIFromQueue();
    1: 
28078:     // Test whether this is the top frame or a subframe
28078:     PRBool isTopFrame = PR_TRUE;
28078:     nsCOMPtr<nsIDocShellTreeItem> targetParentTreeItem;
28078:     rv = GetSameTypeParent(getter_AddRefs(targetParentTreeItem));
28078:     if (NS_SUCCEEDED(rv) && targetParentTreeItem) {
28078:         isTopFrame = PR_FALSE;
28078:     }
28078: 
28078:     //
28078:     // If the page load failed, then deal with the error condition...
28078:     // Errors are handled as follows:
28078:     //   1. Check to see if it's a file not found error or bad content
28078:     //      encoding error.
28078:     //   2. Send the URI to a keyword server (if enabled)
28078:     //   3. If the error was DNS failure, then add www and .com to the URI
28078:     //      (if appropriate).
28078:     //   4. Throw an error dialog box...
28078:     //
28078:     if (url && NS_FAILED(aStatus)) {
28078:         if (aStatus == NS_ERROR_FILE_NOT_FOUND ||
28078:             aStatus == NS_ERROR_INVALID_CONTENT_ENCODING) {
28078:             DisplayLoadError(aStatus, url, nsnull, aChannel);
28078:             return NS_OK;
28078:         }
28078: 
28078:         if (sURIFixup) {
28078:             //
28078:             // Try and make an alternative URI from the old one
28078:             //
28078:             nsCOMPtr<nsIURI> newURI;
28078: 
28078:             nsCAutoString oldSpec;
28078:             url->GetSpec(oldSpec);
28078:       
28078:             //
28078:             // First try keyword fixup
28078:             //
28078:             if (aStatus == NS_ERROR_UNKNOWN_HOST && mAllowKeywordFixup) {
28078:                 PRBool keywordsEnabled = PR_FALSE;
28078: 
28078:                 if (mPrefs &&
28078:                     NS_FAILED(mPrefs->GetBoolPref("keyword.enabled",
28078:                                                   &keywordsEnabled)))
28078:                     keywordsEnabled = PR_FALSE;
28078: 
28078:                 nsCAutoString host;
28078:                 url->GetHost(host);
28078: 
28078:                 nsCAutoString scheme;
28078:                 url->GetScheme(scheme);
28078: 
28078:                 PRInt32 dotLoc = host.FindChar('.');
28078: 
28078:                 // we should only perform a keyword search under the following
28078:                 // conditions:
28078:                 // (0) Pref keyword.enabled is true
28078:                 // (1) the url scheme is http (or https)
28078:                 // (2) the url does not have a protocol scheme
28078:                 // If we don't enforce such a policy, then we end up doing
28078:                 // keyword searchs on urls we don't intend like imap, file,
28078:                 // mailbox, etc. This could lead to a security problem where we
28078:                 // send data to the keyword server that we shouldn't be.
28078:                 // Someone needs to clean up keywords in general so we can
28078:                 // determine on a per url basis if we want keywords
28078:                 // enabled...this is just a bandaid...
28078:                 if (keywordsEnabled && !scheme.IsEmpty() &&
28078:                     (scheme.Find("http") != 0)) {
28078:                     keywordsEnabled = PR_FALSE;
28078:                 }
28078: 
28078:                 if (keywordsEnabled && (kNotFound == dotLoc)) {
28078:                     // only send non-qualified hosts to the keyword server
28078:                     //
28078:                     // If this string was passed through nsStandardURL by
28078:                     // chance, then it may have been converted from UTF-8 to
28078:                     // ACE, which would result in a completely bogus keyword
28078:                     // query.  Here we try to recover the original Unicode
28078:                     // value, but this is not 100% correct since the value may
28078:                     // have been normalized per the IDN normalization rules.
28078:                     //
28078:                     // Since we don't have access to the exact original string
28078:                     // that was entered by the user, this will just have to do.
28078:                     PRBool isACE;
28078:                     nsCAutoString utf8Host;
28078:                     nsCOMPtr<nsIIDNService> idnSrv =
28078:                         do_GetService(NS_IDNSERVICE_CONTRACTID);
28078:                     if (idnSrv &&
28078:                         NS_SUCCEEDED(idnSrv->IsACE(host, &isACE)) && isACE &&
28078:                         NS_SUCCEEDED(idnSrv->ConvertACEtoUTF8(host, utf8Host)))
28078:                         sURIFixup->KeywordToURI(utf8Host,
28078:                                                 getter_AddRefs(newURI));
28078:                     else
28078:                         sURIFixup->KeywordToURI(host, getter_AddRefs(newURI));
28078:                 } // end keywordsEnabled
28078:             }
28078: 
28078:             //
28078:             // Now try change the address, e.g. turn http://foo into
28078:             // http://www.foo.com
28078:             //
28078:             if (aStatus == NS_ERROR_UNKNOWN_HOST ||
28078:                 aStatus == NS_ERROR_NET_RESET) {
28078:                 PRBool doCreateAlternate = PR_TRUE;
28078: 
28078:                 // Skip fixup for anything except a normal document load
28078:                 // operation on the topframe.
28078:         
28078:                 if (mLoadType != LOAD_NORMAL || !isTopFrame) {
28078:                     doCreateAlternate = PR_FALSE;
28078:                 }
28078:                 else {
28078:                     // Test if keyword lookup produced a new URI or not
28078:                     if (newURI) {
28078:                         PRBool sameURI = PR_FALSE;
28078:                         url->Equals(newURI, &sameURI);
28078:                         if (!sameURI) {
28078:                             // Keyword lookup made a new URI so no need to try
28078:                             // an alternate one.
28078:                             doCreateAlternate = PR_FALSE;
28078:                         }
28078:                     }
28078:                 }
28078:                 if (doCreateAlternate) {
28078:                     newURI = nsnull;
28078:                     sURIFixup->CreateFixupURI(oldSpec,
28078:                       nsIURIFixup::FIXUP_FLAGS_MAKE_ALTERNATE_URI,
28078:                                               getter_AddRefs(newURI));
28078:                 }
28078:             }
28078: 
28078:             // Did we make a new URI that is different to the old one? If so
28078:             // load it.
28078:             //
28078:             if (newURI) {
28078:                 // Make sure the new URI is different from the old one,
28078:                 // otherwise there's little point trying to load it again.
28078:                 PRBool sameURI = PR_FALSE;
28078:                 url->Equals(newURI, &sameURI);
28078:                 if (!sameURI) {
28078:                     nsCAutoString newSpec;
28078:                     newURI->GetSpec(newSpec);
28078:                     NS_ConvertUTF8toUTF16 newSpecW(newSpec);
28078: 
28078:                     return LoadURI(newSpecW.get(),  // URI string
28078:                                    LOAD_FLAGS_NONE, // Load flags
28078:                                    nsnull,          // Referring URI
28078:                                    nsnull,          // Post data stream
28078:                                    nsnull);         // Headers stream
28078:                 }
28078:             }
28078:         }
28078: 
28078:         // Well, fixup didn't work :-(
28078:         // It is time to throw an error dialog box, and be done with it...
28078: 
28078:         // Errors to be shown only on top-level frames
28078:         if ((aStatus == NS_ERROR_UNKNOWN_HOST || 
28078:              aStatus == NS_ERROR_CONNECTION_REFUSED ||
28078:              aStatus == NS_ERROR_UNKNOWN_PROXY_HOST || 
28078:              aStatus == NS_ERROR_PROXY_CONNECTION_REFUSED) &&
28078:             (isTopFrame || mUseErrorPages)) {
28078:             DisplayLoadError(aStatus, url, nsnull, aChannel);
28078:         }
28078:         // Errors to be shown for any frame
28078:         else if (aStatus == NS_ERROR_NET_TIMEOUT ||
28078:                  aStatus == NS_ERROR_REDIRECT_LOOP ||
28078:                  aStatus == NS_ERROR_UNKNOWN_SOCKET_TYPE ||
28078:                  aStatus == NS_ERROR_NET_INTERRUPT ||
28078:                  aStatus == NS_ERROR_NET_RESET ||
28078:                  aStatus == NS_ERROR_MALWARE_URI ||
28078:                  aStatus == NS_ERROR_PHISHING_URI ||
28078:                  aStatus == NS_ERROR_UNSAFE_CONTENT_TYPE ||
28078:                  NS_ERROR_GET_MODULE(aStatus) == NS_ERROR_MODULE_SECURITY) {
28078:             DisplayLoadError(aStatus, url, nsnull, aChannel);
28078:         }
28078:         else if (aStatus == NS_ERROR_DOCUMENT_NOT_CACHED) {
28078:             /* A document that was requested to be fetched *only* from
28078:              * the cache is not in cache. May be this is one of those 
28078:              * postdata results. Throw a  dialog to the user,
28078:              * saying that the page has expired from cache and ask if 
28078:              * they wish to refetch the page from the net. Do this only
28078:              * if the request is a form post.
28078:              */
28078:             nsCAutoString method;
28078:             if (httpChannel)
28078:                 httpChannel->GetRequestMethod(method);
28078:             if (method.Equals("POST") && !NS_IsOffline()) {
28078:                 PRBool repost;
28078:                 rv = ConfirmRepost(&repost);
28078:                 if (NS_FAILED(rv)) return rv;
28078:                 // If the user pressed cancel in the dialog, return. Don't try
28078:                 // to load the page without the post data.
28078:                 if (!repost)
28078:                     return NS_OK;
28078: 
28078:                 // The user wants to repost the data to the server.
28078:                 // If the page was loaded due to a back/forward/go
28078:                 // operation, update the session history index.
28078:                 // This is similar to the updating done in
28078:                 // nsDocShell::OnNewURI() for regular pages
28078:                 nsCOMPtr<nsISHistory> rootSH=mSessionHistory;
28078:                 if (!mSessionHistory) {
28078:                     nsCOMPtr<nsIDocShellTreeItem> root;
28078:                     //Get the root docshell
28078:                     GetSameTypeRootTreeItem(getter_AddRefs(root));
28078:                     if (root) {
28078:                         // QI root to nsIWebNavigation
28078:                         nsCOMPtr<nsIWebNavigation> rootAsWebnav =
28078:                             do_QueryInterface(root);
28078:                         if (rootAsWebnav) {
28078:                             // Get the handle to SH from the root docshell
28078:                             rootAsWebnav->GetSessionHistory(getter_AddRefs(rootSH));
28078:                         }
28078:                     }
28078:                 }  // mSessionHistory
28078: 
28078:                 if (rootSH && (mLoadType & LOAD_CMD_HISTORY)) {
28078:                     nsCOMPtr<nsISHistoryInternal> shInternal =
28078:                         do_QueryInterface(rootSH);
28078:                     if (shInternal) {
28078:                         rootSH->GetIndex(&mPreviousTransIndex);
28078:                         shInternal->UpdateIndex();
28078:                         rootSH->GetIndex(&mLoadedTransIndex);
28078: #ifdef DEBUG_PAGE_CACHE
28078:                         printf("Previous index: %d, Loaded index: %d\n\n",
28078:                                mPreviousTransIndex, mLoadedTransIndex);
28078: #endif
28078:                     }
28078:                 }
28078: 
28078:                 // Make it look like we really did honestly finish loading the
28078:                 // history page we were loading, since the "reload" load we're
28078:                 // about to kick off will reload our current history entry.
28078:                 // This is a bit of a hack, and if the force-load fails I think
28078:                 // we'll end up being confused about what page we're on... but
28078:                 // we would anyway, since we've updated the session history
28078:                 // index above.
28078:                 SetHistoryEntry(&mOSHE, loadingSHE);
28078: 
28078:                 // The user does want to repost the data to the server.
28078:                 // Initiate a new load again.
28078: 
28078:                 // Get the postdata if any from the channel.
28078:                 nsCOMPtr<nsIInputStream> inputStream;
28078:                 nsCOMPtr<nsIURI> referrer;
28078:                 if (httpChannel) {
28078:                     httpChannel->GetReferrer(getter_AddRefs(referrer));
28078:                     nsCOMPtr<nsIUploadChannel> uploadChannel =
28078:                         do_QueryInterface(aChannel);
28078:                     if (uploadChannel) {
28078:                         uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
28078:                     }
28078:                 }
28078:                 nsCOMPtr<nsISeekableStream> postDataSeekable =
28078:                     do_QueryInterface(inputStream);
28078:                 if (postDataSeekable) {
28078:                     postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
28078:                 }
28078:                 InternalLoad(url,                               // URI
28078:                              referrer,                          // Referring URI
28078:                              nsnull,                            // Owner
28078:                              INTERNAL_LOAD_FLAGS_INHERIT_OWNER, // Inherit owner
28078:                              nsnull,                            // No window target
28078:                              nsnull,                            // No type hint
28078:                              inputStream,                       // Post data stream
28078:                              nsnull,                            // No headers stream
28078:                              LOAD_RELOAD_BYPASS_PROXY_AND_CACHE,// Load type
28078:                              nsnull,                            // No SHEntry
28078:                              PR_TRUE,                           // first party site
28078:                              nsnull,                            // No nsIDocShell
28078:                              nsnull);                           // No nsIRequest
28078:             }
28078:             else {
28078:                 DisplayLoadError(aStatus, url, nsnull, aChannel);
28078:             }
28078:         }
28078:   } // if we have a host
28078: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: Content Viewer Management
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::EnsureContentViewer()
    1: {
    1:     if (mContentViewer)
    1:         return NS_OK;
    1:     if (mIsBeingDestroyed)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsIPrincipal* principal = nsnull;
27151:     nsCOMPtr<nsIURI> baseURI;
    1: 
    1:     nsCOMPtr<nsPIDOMWindow> piDOMWindow(do_QueryInterface(mScriptGlobal));
    1:     if (piDOMWindow) {
    1:         principal = piDOMWindow->GetOpenerScriptPrincipal();
    1:     }
    1: 
    1:     if (!principal) {
    1:         principal = GetInheritedPrincipal(PR_FALSE);
27151:         nsCOMPtr<nsIDocShellTreeItem> parentItem;
27151:         GetSameTypeParent(getter_AddRefs(parentItem));
27151:         if (parentItem) {
27151:             nsCOMPtr<nsPIDOMWindow> domWin = do_GetInterface(GetAsSupports(this));
27151:             if (domWin) {
27151:                 nsCOMPtr<nsIContent> parentContent =
27151:                     do_QueryInterface(domWin->GetFrameElementInternal());
27151:                 if (parentContent) {
27151:                     baseURI = parentContent->GetBaseURI();
27151:                 }
27151:             }
27151:         }
27151:     }
27151: 
27151:     nsresult rv = CreateAboutBlankContentViewer(principal, baseURI);
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:         nsCOMPtr<nsIDOMDocument> domDoc;
    1:         mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
    1:         nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
    1:         NS_ASSERTION(doc,
    1:                      "Should have doc if CreateAboutBlankContentViewer "
    1:                      "succeeded!");
    1: 
    1:         doc->SetIsInitialDocument(PR_TRUE);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
27151: nsDocShell::CreateAboutBlankContentViewer(nsIPrincipal* aPrincipal,
27151:                                           nsIURI* aBaseURI)
    1: {
    1:   nsCOMPtr<nsIDocument> blankDoc;
    1:   nsCOMPtr<nsIContentViewer> viewer;
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   /* mCreatingDocument should never be true at this point. However, it's
    1:      a theoretical possibility. We want to know about it and make it stop,
    1:      and this sounds like a job for an assertion. */
    1:   NS_ASSERTION(!mCreatingDocument, "infinite(?) loop creating document averted");
    1:   if (mCreatingDocument)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mCreatingDocument = PR_TRUE;
    1: 
    1:   // mContentViewer->PermitUnload may release |this| docshell.
    1:   nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
    1:   
    1:   if (mContentViewer) {
    1:     // We've got a content viewer already. Make sure the user
    1:     // permits us to discard the current document and replace it
    1:     // with about:blank. And also ensure we fire the unload events
    1:     // in the current document.
    1: 
    1:     PRBool okToUnload;
34032:     rv = mContentViewer->PermitUnload(PR_FALSE, &okToUnload);
    1: 
    1:     if (NS_SUCCEEDED(rv) && !okToUnload) {
    1:       // The user chose not to unload the page, interrupt the load.
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     mSavingOldViewer = CanSavePresentation(LOAD_NORMAL, nsnull, nsnull);
    1: 
10676:     // Make sure to blow away our mLoadingURI just in case.  No loads
10676:     // from inside this pagehide.
10676:     mLoadingURI = nsnull;
10676:     
    1:     // Notify the current document that it is about to be unloaded!!
    1:     //
    1:     // It is important to fire the unload() notification *before* any state
    1:     // is changed within the DocShell - otherwise, javascript will get the
    1:     // wrong information :-(
    1:     //
    1:     (void) FirePageHideNotification(!mSavingOldViewer);
    1:   }
    1: 
 5212:   // Now make sure we don't think we're in the middle of firing unload after
 5212:   // this point.  This will make us fire unload when the about:blank document
 5212:   // unloads... but that's ok, more or less.  Would be nice if it fired load
 5212:   // too, of course.
 5212:   mFiredUnloadEvent = PR_FALSE;
 5212: 
    1:   // one helper factory, please
    1:   nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID));
    1:   if (!catMan)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsXPIDLCString contractId;
    1:   rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", "text/html", getter_Copies(contractId));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIDocumentLoaderFactory> docFactory(do_GetService(contractId));
    1:   if (docFactory) {
    1:     // generate (about:blank) document to load
    1:     docFactory->CreateBlankDocument(mLoadGroup, aPrincipal,
    1:                                     getter_AddRefs(blankDoc));
    1:     if (blankDoc) {
27151:       // Hack: set the base URI manually, since this document never
27151:       // got Reset() with a channel.
27151:       blankDoc->SetBaseURI(aBaseURI);
27151: 
 3233:       blankDoc->SetContainer(static_cast<nsIDocShell *>(this));
    1: 
    1:       // create a content viewer for us and the new document
    1:       docFactory->CreateInstanceForDocument(NS_ISUPPORTS_CAST(nsIDocShell *, this),
    1:                     blankDoc, "view", getter_AddRefs(viewer));
    1: 
    1:       // hook 'em up
    1:       if (viewer) {
 3233:         viewer->SetContainer(static_cast<nsIContentViewerContainer *>(this));
    1:         nsCOMPtr<nsIDOMDocument> domdoc(do_QueryInterface(blankDoc));
    1:         Embed(viewer, "", 0);
    1:         viewer->SetDOMDocument(domdoc);
    1: 
    1:         SetCurrentURI(blankDoc->GetDocumentURI(), nsnull, PR_TRUE);
36505:         rv = mIsBeingDestroyed ? NS_ERROR_NOT_AVAILABLE : NS_OK;
    1:       }
    1:     }
    1:   }
    1:   mCreatingDocument = PR_FALSE;
    1: 
    1:   // The transient about:blank viewer doesn't have a session history entry.
    1:   SetHistoryEntry(&mOSHE, nsnull);
    1: 
    1:   return rv;
    1: }
    1: 
    1: PRBool
    1: nsDocShell::CanSavePresentation(PRUint32 aLoadType,
    1:                                 nsIRequest *aNewRequest,
    1:                                 nsIDocument *aNewDocument)
    1: {
    1:     if (!mOSHE)
    1:         return PR_FALSE; // no entry to save into
    1: 
    1:     // Only save presentation for "normal" loads and link loads.  Anything else
    1:     // probably wants to refetch the page, so caching the old presentation
    1:     // would be incorrect.
    1:     if (aLoadType != LOAD_NORMAL &&
    1:         aLoadType != LOAD_HISTORY &&
    1:         aLoadType != LOAD_LINK &&
    1:         aLoadType != LOAD_STOP_CONTENT &&
    1:         aLoadType != LOAD_STOP_CONTENT_AND_REPLACE &&
    1:         aLoadType != LOAD_ERROR_PAGE)
    1:         return PR_FALSE;
    1: 
    1:     // If the session history entry has the saveLayoutState flag set to false,
    1:     // then we should not cache the presentation.
    1:     PRBool canSaveState;
    1:     mOSHE->GetSaveLayoutStateFlag(&canSaveState);
    1:     if (canSaveState == PR_FALSE)
    1:         return PR_FALSE;
    1: 
    1:     // If the document is not done loading, don't cache it.
    1:     nsCOMPtr<nsPIDOMWindow> pWin = do_QueryInterface(mScriptGlobal);
    1:     if (!pWin || pWin->IsLoading())
    1:         return PR_FALSE;
    1: 
    1:     if (pWin->WouldReuseInnerWindow(aNewDocument))
    1:         return PR_FALSE;
    1: 
    1:     // Avoid doing the work of saving the presentation state in the case where
    1:     // the content viewer cache is disabled.
    1:     if (nsSHistory::GetMaxTotalViewers() == 0)
    1:         return PR_FALSE;
    1: 
    1:     // Don't cache the content viewer if we're in a subframe and the subframe
    1:     // pref is disabled.
    1:     PRBool cacheFrames = PR_FALSE;
    1:     mPrefs->GetBoolPref("browser.sessionhistory.cache_subframes",
    1:                         &cacheFrames);
    1:     if (!cacheFrames) {
    1:         nsCOMPtr<nsIDocShellTreeItem> root;
    1:         GetSameTypeParent(getter_AddRefs(root));
    1:         if (root && root != this) {
    1:             return PR_FALSE;  // this is a subframe load
    1:         }
    1:     }
    1: 
    1:     // If the document does not want its presentation cached, then don't.
    1:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(pWin->GetExtantDocument());
    1:     if (!doc || !doc->CanSavePresentation(aNewRequest))
    1:         return PR_FALSE;
    1: 
    1:     return PR_TRUE;
    1: }
    1: 
14631: void
14887: nsDocShell::ReattachEditorToWindow(nsISHEntry *aSHEntry)
14631: {
14631:     NS_ASSERTION(!mEditorData,
14631:                  "Why reattach an editor when we already have one?");
14887:     NS_ASSERTION(aSHEntry && aSHEntry->HasDetachedEditor(),
14631:                  "Reattaching when there's not a detached editor.");
14631: 
14887:     if (mEditorData || !aSHEntry)
14631:       return;
14631: 
14631:     mEditorData = aSHEntry->ForgetEditorData();
14631:     if (mEditorData) {
14887:         nsresult res = mEditorData->ReattachToWindow(this);
14631:         NS_ASSERTION(NS_SUCCEEDED(res), "Failed to reattach editing session");
14631:     }
14631: }
14631: 
14631: void
24129: nsDocShell::DetachEditorFromWindow()
24129: {
24129:     if (!mEditorData || mEditorData->WaitingForLoad()) {
24129:         // If there's nothing to detach, or if the editor data is actually set
24129:         // up for the _new_ page that's coming in, don't detach.
14631:         return;
24129:     }
24129: 
24129:     NS_ASSERTION(!mOSHE || !mOSHE->HasDetachedEditor(),
14887:                  "Detaching editor when it's already detached.");
14631: 
14631:     nsresult res = mEditorData->DetachFromWindow();
14631:     NS_ASSERTION(NS_SUCCEEDED(res), "Failed to detach editor");
14631: 
14631:     if (NS_SUCCEEDED(res)) {
24129:         // Make mOSHE hold the owning ref to the editor data.
24129:         if (mOSHE)
24129:             mOSHE->SetEditorData(mEditorData.forget());
14887:         else
14887:             mEditorData = nsnull;
14631:     }
14631: 
14631: #ifdef DEBUG
14631:     {
14631:         PRBool isEditable;
14631:         GetEditable(&isEditable);
14631:         NS_ASSERTION(!isEditable,
14631:                      "Window is still editable after detaching editor.");
14631:     }
14631: #endif // DEBUG
14631: }
14631: 
    1: nsresult
    1: nsDocShell::CaptureState()
    1: {
    1:     if (!mOSHE || mOSHE == mLSHE) {
    1:         // No entry to save into, or we're replacing the existing entry.
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nsCOMPtr<nsPIDOMWindow> privWin = do_QueryInterface(mScriptGlobal);
    1:     if (!privWin)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsISupports> windowState;
19870:     nsresult rv = privWin->SaveWindowState(getter_AddRefs(windowState));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:     nsCOMPtr<nsIURI> uri;
    1:     mOSHE->GetURI(getter_AddRefs(uri));
    1:     nsCAutoString spec;
    1:     if (uri)
    1:         uri->GetSpec(spec);
    1:     printf("Saving presentation into session history\n");
    1:     printf("  SH URI: %s\n", spec.get());
    1: #endif
    1: 
    1:     rv = mOSHE->SetWindowState(windowState);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Suspend refresh URIs and save off the timer queue
    1:     rv = mOSHE->SetRefreshURIList(mSavedRefreshURIList);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Capture the current content viewer bounds.
30537:     if (mContentViewer) {
30537:         nsIntRect bounds;
30537:         mContentViewer->GetBounds(bounds);
    1:         rv = mOSHE->SetViewerBounds(bounds);
30537:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     // Capture the docshell hierarchy.
    1:     mOSHE->ClearChildShells();
    1: 
29263:     PRInt32 childCount = mChildList.Count();
29263:     for (PRInt32 i = 0; i < childCount; ++i) {
29263:         nsCOMPtr<nsIDocShellTreeItem> childShell = do_QueryInterface(ChildAt(i));
    1:         NS_ASSERTION(childShell, "null child shell");
    1: 
    1:         mOSHE->AddChildShell(childShell);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::RestorePresentationEvent::Run()
    1: {
    1:     if (mDocShell && NS_FAILED(mDocShell->RestoreFromHistory()))
    1:         NS_WARNING("RestoreFromHistory failed");
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::BeginRestore(nsIContentViewer *aContentViewer, PRBool aTop)
    1: {
    1:     nsresult rv;
    1:     if (!aContentViewer) {
    1:         rv = EnsureContentViewer();
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         aContentViewer = mContentViewer;
    1:     }
    1: 
    1:     // Dispatch events for restoring the presentation.  We try to simulate
    1:     // the progress notifications loading the document would cause, so we add
    1:     // the document's channel to the loadgroup to initiate stateChange
    1:     // notifications.
    1: 
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     aContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
    1:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:     if (doc) {
    1:         nsIChannel *channel = doc->GetChannel();
    1:         if (channel) {
    1:             mEODForCurrentDocument = PR_FALSE;
    1:             mIsRestoringDocument = PR_TRUE;
    1:             mLoadGroup->AddRequest(channel, nsnull);
    1:             mIsRestoringDocument = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     if (!aTop) {
 3339:         // This point corresponds to us having gotten OnStartRequest or
 3339:         // STATE_START, so do the same thing that CreateContentViewer does at
 3339:         // this point to ensure that unload/pagehide events for this document
 3339:         // will fire when it's unloaded again.
 3339:         mFiredUnloadEvent = PR_FALSE;
 3339:         
    1:         // For non-top frames, there is no notion of making sure that the
    1:         // previous document is in the domwindow when STATE_START notifications
    1:         // happen.  We can just call BeginRestore for all of the child shells
    1:         // now.
    1:         rv = BeginRestoreChildren();
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::BeginRestoreChildren()
    1: {
29263:     PRInt32 n = mChildList.Count();
29263:     for (PRInt32 i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
    1:         if (child) {
    1:             nsresult rv = child->BeginRestore(nsnull, PR_FALSE);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::FinishRestore()
    1: {
    1:     // First we call finishRestore() on our children.  In the simulated load,
    1:     // all of the child frames finish loading before the main document.
    1: 
29263:     PRInt32 n = mChildList.Count();
29263:     for (PRInt32 i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
    1:         if (child) {
    1:             child->FinishRestore();
    1:         }
    1:     }
    1: 
14887:     if (mOSHE && mOSHE->HasDetachedEditor()) {
14887:       ReattachEditorToWindow(mOSHE);
14887:     }
14887: 
    1:     if (mContentViewer) {
    1:         nsCOMPtr<nsIDOMDocument> domDoc;
    1:         mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
    1: 
    1:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:         if (doc) {
    1:             // Finally, we remove the request from the loadgroup.  This will
    1:             // cause onStateChange(STATE_STOP) to fire, which will fire the
    1:             // pageshow event to the chrome.
    1: 
    1:             nsIChannel *channel = doc->GetChannel();
    1:             if (channel) {
    1:                 mIsRestoringDocument = PR_TRUE;
    1:                 mLoadGroup->RemoveRequest(channel, nsnull, NS_OK);
    1:                 mIsRestoringDocument = PR_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetRestoringDocument(PRBool *aRestoring)
    1: {
    1:     *aRestoring = mIsRestoringDocument;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::RestorePresentation(nsISHEntry *aSHEntry, PRBool *aRestoring)
    1: {
    1:     NS_ASSERTION(mLoadType & LOAD_CMD_HISTORY,
    1:                  "RestorePresentation should only be called for history loads");
    1: 
    1:     nsCOMPtr<nsIContentViewer> viewer;
    1:     aSHEntry->GetContentViewer(getter_AddRefs(viewer));
    1: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:     nsCOMPtr<nsIURI> uri;
    1:     aSHEntry->GetURI(getter_AddRefs(uri));
    1: 
    1:     nsCAutoString spec;
    1:     if (uri)
    1:         uri->GetSpec(spec);
    1: #endif
    1: 
    1:     *aRestoring = PR_FALSE;
    1: 
    1:     if (!viewer) {
    1: #ifdef DEBUG_PAGE_CACHE
    1:         printf("no saved presentation for uri: %s\n", spec.get());
    1: #endif
    1:         return NS_OK;
    1:     }
    1: 
    1:     // We need to make sure the content viewer's container is this docshell.
    1:     // In subframe navigation, it's possible for the docshell that the
    1:     // content viewer was originally loaded into to be replaced with a
    1:     // different one.  We don't currently support restoring the presentation
    1:     // in that case.
    1: 
    1:     nsCOMPtr<nsISupports> container;
    1:     viewer->GetContainer(getter_AddRefs(container));
    1:     if (!::SameCOMIdentity(container, GetAsSupports(this))) {
    1: #ifdef DEBUG_PAGE_CACHE
    1:         printf("No valid container, clearing presentation\n");
    1: #endif
    1:         aSHEntry->SetContentViewer(nsnull);
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     NS_ASSERTION(mContentViewer != viewer, "Restoring existing presentation");
    1: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:     printf("restoring presentation from session history: %s\n", spec.get());
    1: #endif
    1: 
    1:     SetHistoryEntry(&mLSHE, aSHEntry);
    1: 
    1:     // Add the request to our load group.  We do this before swapping out
    1:     // the content viewers so that consumers of STATE_START can access
    1:     // the old document.  We only deal with the toplevel load at this time --
    1:     // to be consistent with normal document loading, subframes cannot start
    1:     // loading until after data arrives, which is after STATE_START completes.
    1: 
    1:     BeginRestore(viewer, PR_TRUE);
    1: 
    1:     // Post an event that will remove the request after we've returned
    1:     // to the event loop.  This mimics the way it is called by nsIChannel
    1:     // implementations.
    1: 
    1:     // Revoke any pending restore (just in case)
    1:     NS_ASSERTION(!mRestorePresentationEvent.IsPending(),
    1:         "should only have one RestorePresentationEvent");
    1:     mRestorePresentationEvent.Revoke();
    1: 
    1:     nsRefPtr<RestorePresentationEvent> evt = new RestorePresentationEvent(this);
    1:     nsresult rv = NS_DispatchToCurrentThread(evt);
    1:     if (NS_SUCCEEDED(rv)) {
    1:         mRestorePresentationEvent = evt.get();
    1:         // The rest of the restore processing will happen on our event
    1:         // callback.
    1:         *aRestoring = PR_TRUE;
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::RestoreFromHistory()
    1: {
    1:     mRestorePresentationEvent.Forget();
    1: 
    1:     // This section of code follows the same ordering as CreateContentViewer.
    1:     if (!mLSHE)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsIContentViewer> viewer;
    1:     mLSHE->GetContentViewer(getter_AddRefs(viewer));
    1:     if (!viewer)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     if (mSavingOldViewer) {
    1:         // We determined that it was safe to cache the document presentation
    1:         // at the time we initiated the new load.  We need to check whether
    1:         // it's still safe to do so, since there may have been DOM mutations
    1:         // or new requests initiated.
    1:         nsCOMPtr<nsIDOMDocument> domDoc;
    1:         viewer->GetDOMDocument(getter_AddRefs(domDoc));
    1:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:         nsIRequest *request = nsnull;
    1:         if (doc)
    1:             request = doc->GetChannel();
    1:         mSavingOldViewer = CanSavePresentation(mLoadType, request, doc);
    1:     }
    1: 
    1:     nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV(do_QueryInterface(mContentViewer));
    1:     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV(do_QueryInterface(viewer));
 5357:     float textZoom = 1.0f;
 5357:     float pageZoom = 1.0f;
 5357:     if (oldMUDV && newMUDV) {
 5357:         oldMUDV->GetTextZoom(&textZoom);
 5357:         oldMUDV->GetFullZoom(&pageZoom);
 5357:     }
    1: 
    1:     // Protect against mLSHE going away via a load triggered from
    1:     // pagehide or unload.
    1:     nsCOMPtr<nsISHEntry> origLSHE = mLSHE;
    1: 
10676:     // Make sure to blow away our mLoadingURI just in case.  No loads
10676:     // from inside this pagehide.
10676:     mLoadingURI = nsnull;
10676:     
    1:     // Notify the old content viewer that it's being hidden.
    1:     FirePageHideNotification(!mSavingOldViewer);
    1: 
    1:     // If mLSHE was changed as a result of the pagehide event, then
    1:     // something else was loaded.  Don't finish restoring.
    1:     if (mLSHE != origLSHE)
    1:       return NS_OK;
    1: 
    1:     // Set mFiredUnloadEvent = PR_FALSE so that the unload handler for the
    1:     // *new* document will fire.
    1:     mFiredUnloadEvent = PR_FALSE;
    1: 
    1:     mURIResultedInDocument = PR_TRUE;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     if (rootSH) {
    1:         nsCOMPtr<nsISHistoryInternal> hist = do_QueryInterface(rootSH);
19870:         rootSH->GetIndex(&mPreviousTransIndex);
    1:         hist->UpdateIndex();
19870:         rootSH->GetIndex(&mLoadedTransIndex);
19870: #ifdef DEBUG_PAGE_CACHE
19870:         printf("Previous index: %d, Loaded index: %d\n\n", mPreviousTransIndex,
19870:                    mLoadedTransIndex);
19870: #endif
    1:     }
    1: 
    1:     // Rather than call Embed(), we will retrieve the viewer from the session
    1:     // history entry and swap it in.
    1:     // XXX can we refactor this so that we can just call Embed()?
    1:     PersistLayoutHistoryState();
    1:     nsresult rv;
    1:     if (mContentViewer) {
    1:         if (mSavingOldViewer && NS_FAILED(CaptureState())) {
    1:             if (mOSHE) {
    1:                 mOSHE->SyncPresentationState();
    1:             }
    1:             mSavingOldViewer = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     mSavedRefreshURIList = nsnull;
    1: 
    1:     // In cases where we use a transient about:blank viewer between loads,
    1:     // we never show the transient viewer, so _its_ previous viewer is never
    1:     // unhooked from the view hierarchy.  Destroy any such previous viewer now,
    1:     // before we grab the root view sibling, so that we don't grab a view
    1:     // that's about to go away.
    1: 
    1:     if (mContentViewer) {
    1:         nsCOMPtr<nsIContentViewer> previousViewer;
    1:         mContentViewer->GetPreviousViewer(getter_AddRefs(previousViewer));
    1:         if (previousViewer) {
    1:             mContentViewer->SetPreviousViewer(nsnull);
    1:             previousViewer->Destroy();
    1:         }
    1:     }
    1: 
    1:     // Save off the root view's parent and sibling so that we can insert the
    1:     // new content viewer's root view at the same position.  Also save the
    1:     // bounds of the root view's widget.
    1: 
    1:     nsIView *rootViewSibling = nsnull, *rootViewParent = nsnull;
23738:     nsIntRect newBounds(0, 0, 0, 0);
    1: 
    1:     nsCOMPtr<nsIPresShell> oldPresShell;
    1:     nsDocShell::GetPresShell(getter_AddRefs(oldPresShell));
    1:     if (oldPresShell) {
    1:         nsIViewManager *vm = oldPresShell->GetViewManager();
    1:         if (vm) {
    1:             nsIView *oldRootView = nsnull;
    1:             vm->GetRootView(oldRootView);
    1: 
    1:             if (oldRootView) {
    1:                 rootViewSibling = oldRootView->GetNextSibling();
    1:                 rootViewParent = oldRootView->GetParent();
    1: 
30537:                 mContentViewer->GetBounds(newBounds);
    1:             }
    1:         }
    1:     }
    1: 
    1:     // Transfer ownership to mContentViewer.  By ensuring that either the
    1:     // docshell or the session history, but not both, have references to the
    1:     // content viewer, we prevent the viewer from being torn down after
    1:     // Destroy() is called.
    1: 
    1:     if (mContentViewer) {
    1:         mContentViewer->Close(mSavingOldViewer ? mOSHE.get() : nsnull);
    1:         viewer->SetPreviousViewer(mContentViewer);
    1:     }
    1: 
    1:     mContentViewer.swap(viewer);
    1:     viewer = nsnull; // force a release to complete ownership transfer
    1: 
    1:     // Grab all of the related presentation from the SHEntry now.
    1:     // Clearing the viewer from the SHEntry will clear all of this state.
    1:     nsCOMPtr<nsISupports> windowState;
    1:     mLSHE->GetWindowState(getter_AddRefs(windowState));
    1:     mLSHE->SetWindowState(nsnull);
    1: 
    1:     PRBool sticky;
    1:     mLSHE->GetSticky(&sticky);
    1: 
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
    1: 
    1:     nsCOMArray<nsIDocShellTreeItem> childShells;
    1:     PRInt32 i = 0;
    1:     nsCOMPtr<nsIDocShellTreeItem> child;
    1:     while (NS_SUCCEEDED(mLSHE->ChildShellAt(i++, getter_AddRefs(child))) &&
    1:            child) {
    1:         childShells.AppendObject(child);
    1:     }
    1: 
    1:     // get the previous content viewer size
23738:     nsIntRect oldBounds(0, 0, 0, 0);
    1:     mLSHE->GetViewerBounds(oldBounds);
    1: 
    1:     // Restore the refresh URI list.  The refresh timers will be restarted
    1:     // when EndPageLoad() is called.
    1:     nsCOMPtr<nsISupportsArray> refreshURIList;
    1:     mLSHE->GetRefreshURIList(getter_AddRefs(refreshURIList));
    1: 
    1:     // Reattach to the window object.
    1:     rv = mContentViewer->Open(windowState, mLSHE);
    1: 
    1:     // Now remove it from the cached presentation.
    1:     mLSHE->SetContentViewer(nsnull);
    1:     mEODForCurrentDocument = PR_FALSE;
    1: 
    1: #ifdef DEBUG
    1:  {
    1:      nsCOMPtr<nsISupportsArray> refreshURIs;
    1:      mLSHE->GetRefreshURIList(getter_AddRefs(refreshURIs));
    1:      nsCOMPtr<nsIDocShellTreeItem> childShell;
    1:      mLSHE->ChildShellAt(0, getter_AddRefs(childShell));
    1:      NS_ASSERTION(!refreshURIs && !childShell,
    1:                   "SHEntry should have cleared presentation state");
    1:  }
    1: #endif
    1: 
    1:     // Restore the sticky state of the viewer.  The viewer has set this state
    1:     // on the history entry in Destroy() just before marking itself non-sticky,
    1:     // to avoid teardown of the presentation.
    1:     mContentViewer->SetSticky(sticky);
    1: 
    1:     // Now that we have switched documents, forget all of our children.
    1:     DestroyChildren();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // mLSHE is now our currently-loaded document.
    1:     SetHistoryEntry(&mOSHE, mLSHE);
    1:     
    1:     // XXX special wyciwyg handling in Embed()?
    1: 
    1:     // We aren't going to restore any items from the LayoutHistoryState,
    1:     // but we don't want them to stay around in case the page is reloaded.
    1:     SetLayoutHistoryState(nsnull);
    1: 
    1:     // This is the end of our Embed() replacement
    1: 
    1:     mSavingOldViewer = PR_FALSE;
    1:     mEODForCurrentDocument = PR_FALSE;
    1: 
    1:     // Tell the event loop to favor plevents over user events, see comments
    1:     // in CreateContentViewer.
    1:     if (++gNumberOfDocumentsLoading == 1)
    1:         FavorPerformanceHint(PR_TRUE, NS_EVENT_STARVATION_DELAY_HINT);
    1: 
    1: 
 5357:     if (oldMUDV && newMUDV) {
 5357:         newMUDV->SetTextZoom(textZoom);
 5357:         newMUDV->SetFullZoom(pageZoom);
 5357:     }
    1: 
    1:     nsCOMPtr<nsIDocument> document = do_QueryInterface(domDoc);
25723:     PRUint32 parentSuspendCount = 0;
    1:     if (document) {
25722:         nsCOMPtr<nsIDocShellTreeItem> parent;
25722:         GetParent(getter_AddRefs(parent));
25722:         nsCOMPtr<nsIDOMDocument> parentDoc = do_GetInterface(parent);
25722:         nsCOMPtr<nsIDocument> d = do_QueryInterface(parentDoc);
25723:         if (d) {
25723:             if (d->EventHandlingSuppressed()) {
25722:                 document->SuppressEventHandling(d->EventHandlingSuppressed());
25722:             }
25723:             nsCOMPtr<nsPIDOMWindow> parentWindow = d->GetWindow();
25723:             if (parentWindow) {
25723:                 parentSuspendCount = parentWindow->TimeoutSuspendCount();
25723:             }
25723:         }
25722: 
    1:         // Use the uri from the mLSHE we had when we entered this function
    1:         // (which need not match the document's URI if anchors are involved),
    1:         // since that's the history entry we're loading.  Note that if we use
    1:         // origLSHE we don't have to worry about whether the entry in question
    1:         // is still mLSHE or whether it's now mOSHE.
    1:         nsCOMPtr<nsIURI> uri;
    1:         origLSHE->GetURI(getter_AddRefs(uri));
    1:         SetCurrentURI(uri, document->GetChannel(), PR_TRUE);
    1:     }
    1: 
    1:     // This is the end of our CreateContentViewer() replacement.
    1:     // Now we simulate a load.  First, we restore the state of the javascript
    1:     // window object.
    1:     nsCOMPtr<nsPIDOMWindow> privWin =
 3233:         do_GetInterface(static_cast<nsIInterfaceRequestor*>(this));
    1:     NS_ASSERTION(privWin, "could not get nsPIDOMWindow interface");
    1: 
    1:     rv = privWin->RestoreWindowState(windowState);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
16977:     // Now, dispatch a title change event which would happen as the
    1:     // <head> is parsed.
16977:     document->NotifyPossibleTitleChange(PR_FALSE);
    1: 
    1:     // Now we simulate appending child docshells for subframes.
    1:     for (i = 0; i < childShells.Count(); ++i) {
    1:         nsIDocShellTreeItem *childItem = childShells.ObjectAt(i);
 6685:         nsCOMPtr<nsIDocShell> childShell = do_QueryInterface(childItem);
 6685: 
 6685:         // Make sure to not clobber the state of the child.  Since AddChild
 6685:         // always clobbers it, save it off first.
 6685:         PRBool allowPlugins;
 6685:         childShell->GetAllowPlugins(&allowPlugins);
 6685: 
 6685:         PRBool allowJavascript;
 6685:         childShell->GetAllowJavascript(&allowJavascript);
 6685: 
 6685:         PRBool allowRedirects;
 6685:         childShell->GetAllowMetaRedirects(&allowRedirects);
 6685: 
 6685:         PRBool allowSubframes;
 6685:         childShell->GetAllowSubframes(&allowSubframes);
 6685: 
 6685:         PRBool allowImages;
 6685:         childShell->GetAllowImages(&allowImages);
 6685: 
28460:         PRBool allowDNSPrefetch;
28460:         childShell->GetAllowDNSPrefetch(&allowDNSPrefetch);
28460:         
    1:         AddChild(childItem);
    1: 
 6685:         childShell->SetAllowPlugins(allowPlugins);
 6685:         childShell->SetAllowJavascript(allowJavascript);
 6685:         childShell->SetAllowMetaRedirects(allowRedirects);
 6685:         childShell->SetAllowSubframes(allowSubframes);
 6685:         childShell->SetAllowImages(allowImages);
28460:         childShell->SetAllowDNSPrefetch(allowDNSPrefetch);
 6685: 
    1:         rv = childShell->BeginRestore(nsnull, PR_FALSE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     nsCOMPtr<nsIPresShell> shell;
    1:     nsDocShell::GetPresShell(getter_AddRefs(shell));
    1: 
    1:     nsIViewManager *newVM = shell ? shell->GetViewManager() : nsnull;
    1:     nsIView *newRootView = nsnull;
    1:     if (newVM)
    1:         newVM->GetRootView(newRootView);
    1: 
    1:     // Insert the new root view at the correct location in the view tree.
    1:     if (rootViewParent) {
    1:         nsIViewManager *parentVM = rootViewParent->GetViewManager();
    1: 
    1:         if (parentVM && newRootView) {
    1:             // InsertChild(parent, child, sib, PR_TRUE) inserts the child after
    1:             // sib in content order, which is before sib in view order. BUT
    1:             // when sib is null it inserts at the end of the the document
    1:             // order, i.e., first in view order.  But when oldRootSibling is
    1:             // null, the old root as at the end of the view list --- last in
    1:             // content order --- and we want to call InsertChild(parent, child,
    1:             // nsnull, PR_FALSE) in that case.
    1:             parentVM->InsertChild(rootViewParent, newRootView,
    1:                                   rootViewSibling,
    1:                                   rootViewSibling ? PR_TRUE : PR_FALSE);
    1: 
    1:             NS_ASSERTION(newRootView->GetNextSibling() == rootViewSibling,
    1:                          "error in InsertChild");
    1:         }
    1:     }
    1: 
25723:     // If parent is suspended, increase suspension count.
25723:     // This can't be done as early as event suppression since this
25723:     // depends on docshell tree.
25723:     if (parentSuspendCount) {
25723:       privWin->SuspendTimeouts(parentSuspendCount, PR_FALSE);
25723:     }
25723: 
    1:     // Now that all of the child docshells have been put into place, we can
    1:     // restart the timers for the window and all of the child frames.
    1:     privWin->ResumeTimeouts();
    1: 
    1:     // Restore the refresh URI list.  The refresh timers will be restarted
    1:     // when EndPageLoad() is called.
    1:     mRefreshURIList = refreshURIList;
    1: 
    1:     // Meta-refresh timers have been restarted for this shell, but not
    1:     // for our children.  Walk the child shells and restart their timers.
29263:     PRInt32 n = mChildList.Count();
    1:     for (i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
    1:         if (child)
    1:             child->ResumeRefreshURIs();
    1:     }
    1: 
    1:     // Make sure this presentation is the same size as the previous
    1:     // presentation.  If this is not the same size we showed it at last time,
    1:     // then we need to resize the widget.
    1: 
    1:     // XXXbryner   This interacts poorly with Firefox's infobar.  If the old
    1:     // presentation had the infobar visible, then we will resize the new
    1:     // presentation to that smaller size.  However, firing the locationchanged
    1:     // event will hide the infobar, which will immediately resize the window
    1:     // back to the larger size.  A future optimization might be to restore
    1:     // the presentation at the "wrong" size, then fire the locationchanged
    1:     // event and check whether the docshell's new size is the same as the
    1:     // cached viewer size (skipping the resize if they are equal).
    1: 
    1:     if (newRootView) {
30537:         if (!newBounds.IsEmpty() && newBounds != oldBounds) {
    1: #ifdef DEBUG_PAGE_CACHE
    1:             printf("resize widget(%d, %d, %d, %d)\n", newBounds.x,
    1:                    newBounds.y, newBounds.width, newBounds.height);
    1: #endif
30537:             mContentViewer->SetBounds(newBounds);
34480:         } else {
34482:             nsIScrollableFrame *rootScrollFrame =
34482:               shell->GetRootScrollFrameAsScrollableExternal();
34480:             if (rootScrollFrame) {
34480:                 rootScrollFrame->PostScrolledAreaEventForCurrentArea();
34480:             }
    1:         }
    1:     }
    1: 
    1:     // Simulate the completion of the load.
    1:     nsDocShell::FinishRestore();
    1: 
    1:     // Restart plugins, and paint the content.
    1:     if (shell)
    1:         shell->Thaw();
    1: 
    1:     return privWin->FireDelayedDOMEvents();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::CreateContentViewer(const char *aContentType,
    1:                                 nsIRequest * request,
    1:                                 nsIStreamListener ** aContentHandler)
    1: {
    1:     *aContentHandler = nsnull;
    1: 
    1:     // Can we check the content type of the current content viewer
    1:     // and reuse it without destroying it and re-creating it?
    1: 
    1:     NS_ASSERTION(mLoadGroup, "Someone ignored return from Init()?");
    1: 
    1:     // Instantiate the content viewer object
    1:     nsCOMPtr<nsIContentViewer> viewer;
    1:     nsresult rv = NewContentViewerObj(aContentType, request, mLoadGroup,
    1:                                       aContentHandler, getter_AddRefs(viewer));
    1: 
    1:     if (NS_FAILED(rv))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // Notify the current document that it is about to be unloaded!!
    1:     //
    1:     // It is important to fire the unload() notification *before* any state
    1:     // is changed within the DocShell - otherwise, javascript will get the
    1:     // wrong information :-(
    1:     //
    1: 
    1:     if (mSavingOldViewer) {
    1:         // We determined that it was safe to cache the document presentation
    1:         // at the time we initiated the new load.  We need to check whether
    1:         // it's still safe to do so, since there may have been DOM mutations
    1:         // or new requests initiated.
    1:         nsCOMPtr<nsIDOMDocument> domDoc;
    1:         viewer->GetDOMDocument(getter_AddRefs(domDoc));
    1:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:         mSavingOldViewer = CanSavePresentation(mLoadType, request, doc);
    1:     }
    1: 
10676:     NS_ASSERTION(!mLoadingURI, "Re-entering unload?");
10676:     
10676:     nsCOMPtr<nsIChannel> aOpenedChannel = do_QueryInterface(request);
10676:     if (aOpenedChannel) {
10676:         aOpenedChannel->GetURI(getter_AddRefs(mLoadingURI));
10676:     }
    1:     FirePageHideNotification(!mSavingOldViewer);
10676:     mLoadingURI = nsnull;
    1: 
    1:     // Set mFiredUnloadEvent = PR_FALSE so that the unload handler for the
    1:     // *new* document will fire.
    1:     mFiredUnloadEvent = PR_FALSE;
    1: 
    1:     // we've created a new document so go ahead and call
    1:     // OnLoadingSite(), but don't fire OnLocationChange()
    1:     // notifications before we've called Embed(). See bug 284993.
    1:     mURIResultedInDocument = PR_TRUE;
    1: 
34780:     if (mLoadType == LOAD_ERROR_PAGE) {
34780:         // We need to set the SH entry and our current URI here and not
34780:         // at the moment we load the page. We want the same behavior 
34780:         // of Stop() as for a normal page load. See bug 514232 for details.
34780: 
34780:         // Revert mLoadType to load type to state the page load failed,
34780:         // following function calls need it.
34780:         mLoadType = mFailedLoadType;
34780: 
34780:         nsCOMPtr<nsIChannel> failedChannel = mFailedChannel;
34780:         nsCOMPtr<nsIURI> failedURI = mFailedURI;
34780:         mFailedChannel = nsnull;
34780:         mFailedURI = nsnull;
34780: 
34780:         // Create an shistory entry for the old load, if we have a channel
34780:         if (failedChannel) {
34780:             mURIResultedInDocument = PR_TRUE;
34780:             OnLoadingSite(failedChannel, PR_TRUE, PR_FALSE);
34780:         } else if (failedURI) {
34780:             mURIResultedInDocument = PR_TRUE;
34780:             OnNewURI(failedURI, nsnull, nsnull, mLoadType, PR_TRUE, PR_FALSE);
34780:         }
34780: 
35007:         // Be sure to have a correct mLSHE, it may have been cleared by
35007:         // EndPageLoad. See bug 302115.
35007:         if (mSessionHistory && !mLSHE) {
35007:             PRInt32 idx;
35007:             mSessionHistory->GetRequestedIndex(&idx);
35007:             if (idx == -1)
35007:                 mSessionHistory->GetIndex(&idx);
35007: 
35007:             nsCOMPtr<nsIHistoryEntry> entry;
35007:             mSessionHistory->GetEntryAtIndex(idx, PR_FALSE,
35007:                                              getter_AddRefs(entry));
35007:             mLSHE = do_QueryInterface(entry);
35007:         }
35007: 
34780:         // Set our current URI
34780:         SetCurrentURI(failedURI);
34780: 
34780:         mLoadType = LOAD_ERROR_PAGE;
34780:     }
34780: 
    1:     PRBool onLocationChangeNeeded = OnLoadingSite(aOpenedChannel, PR_FALSE);
    1: 
    1:     // let's try resetting the load group if we need to...
    1:     nsCOMPtr<nsILoadGroup> currentLoadGroup;
    1:     NS_ENSURE_SUCCESS(aOpenedChannel->
    1:                       GetLoadGroup(getter_AddRefs(currentLoadGroup)),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     if (currentLoadGroup != mLoadGroup) {
    1:         nsLoadFlags loadFlags = 0;
    1: 
    1:         //Cancel any URIs that are currently loading...
    1:         /// XXX: Need to do this eventually      Stop();
    1:         //
    1:         // Retarget the document to this loadgroup...
    1:         //
    1:         /* First attach the channel to the right loadgroup
    1:          * and then remove from the old loadgroup. This 
    1:          * puts the notifications in the right order and
    1:          * we don't null-out mLSHE in OnStateChange() for 
    1:          * all redirected urls
    1:          */
    1:         aOpenedChannel->SetLoadGroup(mLoadGroup);
    1: 
    1:         // Mark the channel as being a document URI...
    1:         aOpenedChannel->GetLoadFlags(&loadFlags);
    1:         loadFlags |= nsIChannel::LOAD_DOCUMENT_URI;
    1: 
    1:         aOpenedChannel->SetLoadFlags(loadFlags);
    1: 
    1:         mLoadGroup->AddRequest(request, nsnull);
    1:         if (currentLoadGroup)
    1:             currentLoadGroup->RemoveRequest(request, nsnull,
    1:                                             NS_BINDING_RETARGETED);
    1: 
    1:         // Update the notification callbacks, so that progress and
    1:         // status information are sent to the right docshell...
    1:         aOpenedChannel->SetNotificationCallbacks(this);
    1:     }
    1: 
    1:     NS_ENSURE_SUCCESS(Embed(viewer, "", (nsISupports *) nsnull),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     mSavedRefreshURIList = nsnull;
    1:     mSavingOldViewer = PR_FALSE;
    1:     mEODForCurrentDocument = PR_FALSE;
    1: 
    1:     // if this document is part of a multipart document,
    1:     // the ID can be used to distinguish it from the other parts.
    1:     nsCOMPtr<nsIMultiPartChannel> multiPartChannel(do_QueryInterface(request));
    1:     if (multiPartChannel) {
    1:       nsCOMPtr<nsIPresShell> shell;
    1:       rv = GetPresShell(getter_AddRefs(shell));
    1:       if (NS_SUCCEEDED(rv) && shell) {
    1:         nsIDocument *doc = shell->GetDocument();
    1:         if (doc) {
    1:           PRUint32 partID;
    1:           multiPartChannel->GetPartID(&partID);
    1:           doc->SetPartID(partID);
    1:         }
    1:       }
    1:     }
    1: 
    1:     // Give hint to native plevent dispatch mechanism. If a document
    1:     // is loading the native plevent dispatch mechanism should favor
    1:     // performance over normal native event dispatch priorities.
    1:     if (++gNumberOfDocumentsLoading == 1) {
    1:       // Hint to favor performance for the plevent notification mechanism.
    1:       // We want the pages to load as fast as possible even if its means 
    1:       // native messages might be starved.
    1:       FavorPerformanceHint(PR_TRUE, NS_EVENT_STARVATION_DELAY_HINT);
    1:     }
    1: 
    1:     if (onLocationChangeNeeded) {
    1:       FireOnLocationChange(this, request, mCurrentURI);
    1:     }
    1:   
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::NewContentViewerObj(const char *aContentType,
    1:                                 nsIRequest * request, nsILoadGroup * aLoadGroup,
    1:                                 nsIStreamListener ** aContentHandler,
    1:                                 nsIContentViewer ** aViewer)
    1: {
    1:     nsCOMPtr<nsIChannel> aOpenedChannel = do_QueryInterface(request);
    1: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     
    1:     nsXPIDLCString contractId;
    1:     rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", aContentType, getter_Copies(contractId));
    1: 
    1:     // Create an instance of the document-loader-factory
    1:     nsCOMPtr<nsIDocumentLoaderFactory> docLoaderFactory;
    1:     if (NS_SUCCEEDED(rv))
    1:         docLoaderFactory = do_GetService(contractId.get());
    1: 
    1:     if (!docLoaderFactory) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Now create an instance of the content viewer
    1:     // nsLayoutDLF makes the determination if it should be a "view-source" instead of "view"
    1:     NS_ENSURE_SUCCESS(docLoaderFactory->CreateInstance("view",
    1:                                                        aOpenedChannel,
    1:                                                        aLoadGroup, aContentType,
 3051:                                                        static_cast<nsIContentViewerContainer*>(this),
 3051:                                                        nsnull,
    1:                                                        aContentHandler,
    1:                                                        aViewer),
    1:                       NS_ERROR_FAILURE);
    1: 
 3233:     (*aViewer)->SetContainer(static_cast<nsIContentViewerContainer *>(this));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetupNewViewer(nsIContentViewer * aNewViewer)
    1: {
    1:     //
    1:     // Copy content viewer state from previous or parent content viewer.
    1:     //
    1:     // The following logic is mirrored in nsHTMLDocument::StartDocumentLoad!
    1:     //
    1:     // Do NOT to maintain a reference to the old content viewer outside
    1:     // of this "copying" block, or it will not be destroyed until the end of
    1:     // this routine and all <SCRIPT>s and event handlers fail! (bug 20315)
    1:     //
    1:     // In this block of code, if we get an error result, we return it
    1:     // but if we get a null pointer, that's perfectly legal for parent
    1:     // and parentContentViewer.
    1:     //
    1: 
    1:     PRInt32 x = 0;
    1:     PRInt32 y = 0;
    1:     PRInt32 cx = 0;
    1:     PRInt32 cy = 0;
    1: 
    1:     // This will get the size from the current content viewer or from the
    1:     // Init settings
 1027:     DoGetPositionAndSize(&x, &y, &cx, &cy);
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
    1:     NS_ENSURE_SUCCESS(GetSameTypeParent(getter_AddRefs(parentAsItem)),
    1:                       NS_ERROR_FAILURE);
    1:     nsCOMPtr<nsIDocShell> parent(do_QueryInterface(parentAsItem));
    1: 
    1:     nsCAutoString defaultCharset;
    1:     nsCAutoString forceCharset;
    1:     nsCAutoString hintCharset;
    1:     PRInt32 hintCharsetSource;
    1:     nsCAutoString prevDocCharset;
    1:     float textZoom;
 5357:     float pageZoom;
    1:     PRBool styleDisabled;
    1:     // |newMUDV| also serves as a flag to set the data from the above vars
    1:     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV;
    1: 
    1:     if (mContentViewer || parent) {
    1:         nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV;
    1:         if (mContentViewer) {
    1:             // Get any interesting state from old content viewer
    1:             // XXX: it would be far better to just reuse the document viewer ,
    1:             //      since we know we're just displaying the same document as before
    1:             oldMUDV = do_QueryInterface(mContentViewer);
    1: 
    1:             // Tell the old content viewer to hibernate in session history when
    1:             // it is destroyed.
    1: 
    1:             if (mSavingOldViewer && NS_FAILED(CaptureState())) {
    1:                 if (mOSHE) {
    1:                     mOSHE->SyncPresentationState();
    1:                 }
    1:                 mSavingOldViewer = PR_FALSE;
    1:             }
    1:         }
    1:         else {
    1:             // No old content viewer, so get state from parent's content viewer
    1:             nsCOMPtr<nsIContentViewer> parentContentViewer;
    1:             parent->GetContentViewer(getter_AddRefs(parentContentViewer));
    1:             oldMUDV = do_QueryInterface(parentContentViewer);
    1:         }
    1: 
    1:         if (oldMUDV) {
    1:             nsresult rv;
    1: 
    1:             newMUDV = do_QueryInterface(aNewViewer,&rv);
    1:             if (newMUDV) {
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetDefaultCharacterSet(defaultCharset),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetForceCharacterSet(forceCharset),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetHintCharacterSet(hintCharset),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetHintCharacterSetSource(&hintCharsetSource),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetTextZoom(&textZoom),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
 5357:                                   GetFullZoom(&pageZoom),
 5357:                                   NS_ERROR_FAILURE);
 5357:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetAuthorStyleDisabled(&styleDisabled),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetPrevDocCharacterSet(prevDocCharset),
    1:                                   NS_ERROR_FAILURE);
    1:             }
    1:         }
    1:     }
    1: 
    1:     nscolor bgcolor = NS_RGBA(0, 0, 0, 0);
    1:     // Ensure that the content viewer is destroyed *after* the GC - bug 71515
    1:     nsCOMPtr<nsIContentViewer> kungfuDeathGrip = mContentViewer;
    1:     if (mContentViewer) {
    1:         // Stop any activity that may be happening in the old document before
    1:         // releasing it...
    1:         mContentViewer->Stop();
    1: 
25385:         // Try to extract the canvas background color from the old
25385:         // presentation shell, so we can use it for the next document.
    1:         nsCOMPtr<nsIDocumentViewer> docviewer =
    1:         do_QueryInterface(mContentViewer);
    1: 
    1:         if (docviewer) {
    1:             nsCOMPtr<nsIPresShell> shell;
    1:             docviewer->GetPresShell(getter_AddRefs(shell));
    1: 
    1:             if (shell) {
25385:                 bgcolor = shell->GetCanvasBackground();
    1:             }
    1:         }
    1: 
    1:         mContentViewer->Close(mSavingOldViewer ? mOSHE.get() : nsnull);
    1:         aNewViewer->SetPreviousViewer(mContentViewer);
    1: 
    1:         mContentViewer = nsnull;
    1:     }
    1: 
    1:     mContentViewer = aNewViewer;
    1: 
    1:     nsCOMPtr<nsIWidget> widget;
    1:     NS_ENSURE_SUCCESS(GetMainWidget(getter_AddRefs(widget)), NS_ERROR_FAILURE);
    1: 
23738:     nsIntRect bounds(x, y, cx, cy);
    1: 
17009:     if (NS_FAILED(mContentViewer->Init(widget, bounds))) {
    1:         mContentViewer = nsnull;
    1:         NS_ERROR("ContentViewer Initialization failed");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // If we have old state to copy, set the old state onto the new content
    1:     // viewer
    1:     if (newMUDV) {
    1:         NS_ENSURE_SUCCESS(newMUDV->SetDefaultCharacterSet(defaultCharset),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetForceCharacterSet(forceCharset),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetHintCharacterSet(hintCharset),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->
    1:                           SetHintCharacterSetSource(hintCharsetSource),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetPrevDocCharacterSet(prevDocCharset),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetTextZoom(textZoom),
    1:                           NS_ERROR_FAILURE);
 5357:         NS_ENSURE_SUCCESS(newMUDV->SetFullZoom(pageZoom),
 5357:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetAuthorStyleDisabled(styleDisabled),
    1:                           NS_ERROR_FAILURE);
    1:     }
    1: 
25385:     // Stuff the bgcolor from the old pres shell into the new
25385:     // pres shell. This improves page load continuity.
    1:     nsCOMPtr<nsIDocumentViewer> docviewer =
    1:         do_QueryInterface(mContentViewer);
    1: 
    1:     if (docviewer) {
    1:         nsCOMPtr<nsIPresShell> shell;
    1:         docviewer->GetPresShell(getter_AddRefs(shell));
    1: 
    1:         if (shell) {
25385:             shell->SetCanvasBackground(bgcolor);
    1:         }
    1:     }
    1: 
    1: // XXX: It looks like the LayoutState gets restored again in Embed()
    1: //      right after the call to SetupNewViewer(...)
    1: 
    1:     // We don't show the mContentViewer yet, since we want to draw the old page
    1:     // until we have enough of the new page to show.  Just return with the new
    1:     // viewer still set to hidden.
    1: 
    1:     // Now that we have switched documents, forget all of our children
    1:     DestroyChildren();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsDocShell::CheckLoadingPermissions()
    1: {
    1:     // This method checks whether the caller may load content into
    1:     // this docshell. Even though we've done our best to hide windows
    1:     // from code that doesn't have the right to access them, it's
    1:     // still possible for an evil site to open a window and access
    1:     // frames in the new window through window.frames[] (which is
    1:     // allAccess for historic reasons), so we still need to do this
    1:     // check on load.
    1:     nsresult rv = NS_OK, sameOrigin = NS_OK;
    1: 
    1:     if (!gValidateOrigin || !IsFrame()) {
    1:         // Origin validation was turned off, or we're not a frame.
    1:         // Permit all loads.
    1: 
    1:         return rv;
    1:     }
    1: 
    1:     // We're a frame. Check that the caller has write permission to
    1:     // the parent before allowing it to load anything into this
    1:     // docshell.
    1: 
    1:     nsCOMPtr<nsIScriptSecurityManager> securityManager =
    1:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRBool ubwEnabled = PR_FALSE;
    1:     rv = securityManager->IsCapabilityEnabled("UniversalBrowserWrite",
    1:                                               &ubwEnabled);
    1:     if (NS_FAILED(rv) || ubwEnabled) {
    1:         return rv;
    1:     }
    1: 
    1:     nsCOMPtr<nsIPrincipal> subjPrincipal;
    1:     rv = securityManager->GetSubjectPrincipal(getter_AddRefs(subjPrincipal));
    1:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && subjPrincipal, rv);
    1: 
    1:     // Check if the caller is from the same origin as this docshell,
24692:     // or any of its ancestors.
    1:     nsCOMPtr<nsIDocShellTreeItem> item(this);
    1:     do {
    1:         nsCOMPtr<nsIScriptGlobalObject> sgo(do_GetInterface(item));
    1:         nsCOMPtr<nsIScriptObjectPrincipal> sop(do_QueryInterface(sgo));
    1: 
    1:         nsIPrincipal *p;
    1:         if (!sop || !(p = sop->GetPrincipal())) {
    1:             return NS_ERROR_UNEXPECTED;
    1:         }
    1: 
    1:         // Compare origins
 3286:         PRBool equal;
 3286:         sameOrigin = subjPrincipal->Equals(p, &equal);
    1:         if (NS_SUCCEEDED(sameOrigin)) {
 3286:             if (equal) {
    1:                 // Same origin, permit load
    1: 
    1:                 return sameOrigin;
    1:             }
    1: 
 3286:             sameOrigin = NS_ERROR_DOM_PROP_ACCESS_DENIED;
 3286:         }
 3286: 
    1:         nsCOMPtr<nsIDocShellTreeItem> tmp;
    1:         item->GetSameTypeParent(getter_AddRefs(tmp));
    1:         item.swap(tmp);
    1:     } while (item);
    1: 
    1:     return sameOrigin;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: Site Loading
    1: //*****************************************************************************   
10676: class InternalLoadEvent : public nsRunnable
10676: {
10676: public:
10676:     InternalLoadEvent(nsDocShell* aDocShell, nsIURI * aURI, nsIURI * aReferrer,
10676:                       nsISupports * aOwner, PRUint32 aFlags,
10999:                       const char* aTypeHint, nsIInputStream * aPostData,
10676:                       nsIInputStream * aHeadersData, PRUint32 aLoadType,
10676:                       nsISHEntry * aSHEntry, PRBool aFirstParty) :
10676:         mDocShell(aDocShell),
10676:         mURI(aURI),
10676:         mReferrer(aReferrer),
10676:         mOwner(aOwner),
10676:         mPostData(aPostData),
10676:         mHeadersData(aHeadersData),
28564:         mSHEntry(aSHEntry),
28564:         mFlags(aFlags),
10676:         mLoadType(aLoadType),
10676:         mFirstParty(aFirstParty)
10676:     {
10676:         // Make sure to keep null things null as needed
10676:         if (aTypeHint) {
10676:             mTypeHint = aTypeHint;
10676:         }
10676:     }
10676:     
10676:     NS_IMETHOD Run() {
10676:         return mDocShell->InternalLoad(mURI, mReferrer, mOwner, mFlags,
10999:                                        nsnull, mTypeHint.get(),
10676:                                        mPostData, mHeadersData, mLoadType,
10676:                                        mSHEntry, mFirstParty, nsnull, nsnull);
10676:     }
10676: 
10676: private:
28564: 
28564:     // Use IDL strings so .get() returns null by default
28564:     nsXPIDLString mWindowTarget;
28564:     nsXPIDLCString mTypeHint;
28564: 
10676:     nsRefPtr<nsDocShell> mDocShell;
10676:     nsCOMPtr<nsIURI> mURI;
10676:     nsCOMPtr<nsIURI> mReferrer;
10676:     nsCOMPtr<nsISupports> mOwner;
10676:     nsCOMPtr<nsIInputStream> mPostData;
10676:     nsCOMPtr<nsIInputStream> mHeadersData;
28564:     nsCOMPtr<nsISHEntry> mSHEntry;
28564:     PRUint32 mFlags;
10676:     PRUint32 mLoadType;
10676:     PRBool mFirstParty;
10676: };
10676: 
    1: NS_IMETHODIMP
    1: nsDocShell::InternalLoad(nsIURI * aURI,
    1:                          nsIURI * aReferrer,
    1:                          nsISupports * aOwner,
    1:                          PRUint32 aFlags,
    1:                          const PRUnichar *aWindowTarget,
    1:                          const char* aTypeHint,
    1:                          nsIInputStream * aPostData,
    1:                          nsIInputStream * aHeadersData,
    1:                          PRUint32 aLoadType,
    1:                          nsISHEntry * aSHEntry,
    1:                          PRBool aFirstParty,
    1:                          nsIDocShell** aDocShell,
    1:                          nsIRequest** aRequest)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1: #ifdef PR_LOGGING
    1:     if (gDocShellLeakLog && PR_LOG_TEST(gDocShellLeakLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         if (aURI)
    1:             aURI->GetSpec(spec);
    1:         PR_LogPrint("DOCSHELL %p InternalLoad %s\n", this, spec.get());
    1:     }
    1: #endif
    1:     
    1:     // Initialize aDocShell/aRequest
    1:     if (aDocShell) {
    1:         *aDocShell = nsnull;
    1:     }
    1:     if (aRequest) {
    1:         *aRequest = nsnull;
    1:     }
    1: 
    1:     if (!aURI) {
    1:         return NS_ERROR_NULL_POINTER;
    1:     }
    1: 
    1:     NS_ENSURE_TRUE(IsValidLoadType(aLoadType), NS_ERROR_INVALID_ARG);
    1: 
    1:     NS_ENSURE_TRUE(!mIsBeingDestroyed, NS_ERROR_NOT_AVAILABLE);
    1: 
    1:     // wyciwyg urls can only be loaded through history. Any normal load of
    1:     // wyciwyg through docshell is  illegal. Disallow such loads.
    1:     if (aLoadType & LOAD_CMD_NORMAL) {
    1:         PRBool isWyciwyg = PR_FALSE;
    1:         rv = aURI->SchemeIs("wyciwyg", &isWyciwyg);   
    1:         if ((isWyciwyg && NS_SUCCEEDED(rv)) || NS_FAILED(rv)) 
    1:             return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     PRBool bIsJavascript = PR_FALSE;
    1:     if (NS_FAILED(aURI->SchemeIs("javascript", &bIsJavascript))) {
    1:         bIsJavascript = PR_FALSE;
    1:     }
    1: 
    1:     //
    1:     // First, notify any nsIContentPolicy listeners about the document load.
    1:     // Only abort the load if a content policy listener explicitly vetos it!
    1:     //
    1:     nsCOMPtr<nsIDOMElement> requestingElement;
    1:     // Use nsPIDOMWindow since we _want_ to cross the chrome boundary if needed
    1:     nsCOMPtr<nsPIDOMWindow> privateWin(do_QueryInterface(mScriptGlobal));
    1:     if (privateWin)
    1:         requestingElement = privateWin->GetFrameElementInternal();
    1: 
    1:     PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
    1:     PRUint32 contentType;
    1:     if (IsFrame()) {
    1:         NS_ASSERTION(requestingElement, "A frame but no DOM element!?");
    1:         contentType = nsIContentPolicy::TYPE_SUBDOCUMENT;
    1:     } else {
    1:         contentType = nsIContentPolicy::TYPE_DOCUMENT;
    1:     }
    1: 
    1:     nsISupports* context = requestingElement;
    1:     if (!context) {
    1:         context =  mScriptGlobal;
    1:     }
 4444: 
 4367:     // XXXbz would be nice to know the loading principal here... but we don't
 4444:     nsCOMPtr<nsIPrincipal> loadingPrincipal;
 4444:     if (aReferrer) {
 4444:         nsCOMPtr<nsIScriptSecurityManager> secMan =
 4444:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
 4444:         NS_ENSURE_SUCCESS(rv, rv);
 4444: 
 4444:         rv = secMan->GetCodebasePrincipal(aReferrer,
 4444:                                           getter_AddRefs(loadingPrincipal));
 4444:     }
 4444:     
    1:     rv = NS_CheckContentLoadPolicy(contentType,
    1:                                    aURI,
 4444:                                    loadingPrincipal,
    1:                                    context,
    1:                                    EmptyCString(), //mime guess
    1:                                    nsnull,         //extra
    1:                                    &shouldLoad);
    1: 
    1:     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
    1:         if (NS_SUCCEEDED(rv) && shouldLoad == nsIContentPolicy::REJECT_TYPE) {
    1:             return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
    1:         }
    1: 
    1:         return NS_ERROR_CONTENT_BLOCKED;
    1:     }
    1: 
    1:     nsCOMPtr<nsISupports> owner(aOwner);
    1:     //
    1:     // Get an owner from the current document if necessary.  Note that we only
15185:     // do this for URIs that inherit a security context and local file URIs;
15185:     // in particular we do NOT do this for about:blank.  This way, random
15185:     // about:blank loads that have no owner (which basically means they were
15185:     // done by someone from chrome manually messing with our nsIWebNavigation
15185:     // or by C++ setting document.location) don't get a funky principal.  If
15185:     // callers want something interesting to happen with the about:blank
15185:     // principal in this case, they should pass an owner in.
    1:     //
    1:     {
    1:         PRBool inherits;
  853:         // One more twist: Don't inherit the owner for external loads.
  853:         if (aLoadType != LOAD_NORMAL_EXTERNAL && !owner &&
  853:             (aFlags & INTERNAL_LOAD_FLAGS_INHERIT_OWNER) &&
27265:             NS_SUCCEEDED(URIInheritsSecurityContext(aURI, &inherits)) &&
27265:             inherits) {
 8363: 
 8363:             // Don't allow loads that would inherit our security context
 8363:             // if this document came from an unsafe channel.
 8363:             nsCOMPtr<nsIDocShellTreeItem> treeItem = this;
 8363:             do {
 8363:                 nsCOMPtr<nsIDocShell> itemDocShell =
 8363:                     do_QueryInterface(treeItem);
 8363:                 PRBool isUnsafe;
 8363:                 if (itemDocShell &&
 8363:                     NS_SUCCEEDED(itemDocShell->GetChannelIsUnsafe(&isUnsafe)) &&
 8363:                     isUnsafe) {
 8363:                     return NS_ERROR_DOM_SECURITY_ERR;
 8363:                 }
 8363: 
 8363:                 nsCOMPtr<nsIDocShellTreeItem> parent;
 8363:                 treeItem->GetSameTypeParent(getter_AddRefs(parent));
 8363:                 parent.swap(treeItem);
 8363:             } while (treeItem);
 8363: 
    1:             owner = GetInheritedPrincipal(PR_TRUE);
    1:         }
    1:     }
    1: 
    1:     //
    1:     // Resolve the window target before going any further...
    1:     // If the load has been targeted to another DocShell, then transfer the
    1:     // load to it...
    1:     //
    1:     if (aWindowTarget && *aWindowTarget) {
    1:         // We've already done our owner-inheriting.  Mask out that bit, so we
    1:         // don't try inheriting an owner from the target window if we came up
    1:         // with a null owner above.
    1:         aFlags = aFlags & ~INTERNAL_LOAD_FLAGS_INHERIT_OWNER;
    1:         
    1:         // Locate the target DocShell.
    1:         // This may involve creating a new toplevel window - if necessary.
    1:         //
    1:         nsCOMPtr<nsIDocShellTreeItem> targetItem;
    1:         FindItemWithName(aWindowTarget, nsnull, this,
    1:                          getter_AddRefs(targetItem));
    1: 
    1:         nsCOMPtr<nsIDocShell> targetDocShell = do_QueryInterface(targetItem);
    1:         
    1:         PRBool isNewWindow = PR_FALSE;
    1:         if (!targetDocShell) {
    1:             nsCOMPtr<nsIDOMWindowInternal> win =
    1:                 do_GetInterface(GetAsSupports(this));
    1:             NS_ENSURE_TRUE(win, NS_ERROR_NOT_AVAILABLE);
    1: 
    1:             nsDependentString name(aWindowTarget);
    1:             nsCOMPtr<nsIDOMWindow> newWin;
    1:             rv = win->Open(EmptyString(), // URL to load
    1:                            name,          // window name
    1:                            EmptyString(), // Features
    1:                            getter_AddRefs(newWin));
    1: 
    1:             // In some cases the Open call doesn't actually result in a new
    1:             // window being opened.  We can detect these cases by examining the
    1:             // document in |newWin|, if any.
    1:             nsCOMPtr<nsPIDOMWindow> piNewWin = do_QueryInterface(newWin);
    1:             if (piNewWin) {
    1:                 nsCOMPtr<nsIDocument> newDoc =
    1:                     do_QueryInterface(piNewWin->GetExtantDocument());
    1:                 if (!newDoc || newDoc->IsInitialDocument()) {
    1:                     isNewWindow = PR_TRUE;
    1:                     aFlags |= INTERNAL_LOAD_FLAGS_FIRST_LOAD;
    1:                 }
    1:             }
    1: 
    1:             nsCOMPtr<nsIWebNavigation> webNav = do_GetInterface(newWin);
    1:             targetDocShell = do_QueryInterface(webNav);
    1:         }
    1: 
    1:         //
    1:         // Transfer the load to the target DocShell...  Pass nsnull as the
    1:         // window target name from to prevent recursive retargeting!
    1:         //
    1:         if (NS_SUCCEEDED(rv) && targetDocShell) {
    1:             rv = targetDocShell->InternalLoad(aURI,
    1:                                               aReferrer,
    1:                                               owner,
    1:                                               aFlags,
    1:                                               nsnull,         // No window target
    1:                                               aTypeHint,
    1:                                               aPostData,
    1:                                               aHeadersData,
    1:                                               aLoadType,
    1:                                               aSHEntry,
    1:                                               aFirstParty,
    1:                                               aDocShell,
    1:                                               aRequest);
    1:             if (rv == NS_ERROR_NO_CONTENT) {
    1:                 // XXXbz except we never reach this code!
    1:                 if (isNewWindow) {
    1:                     //
    1:                     // At this point, a new window has been created, but the
    1:                     // URI did not have any data associated with it...
    1:                     //
    1:                     // So, the best we can do, is to tear down the new window
    1:                     // that was just created!
    1:                     //
    1:                     nsCOMPtr<nsIDOMWindowInternal> domWin =
    1:                         do_GetInterface(targetDocShell);
    1:                     if (domWin) {
    1:                         domWin->Close();
    1:                     }
    1:                 }
    1:                 //
    1:                 // NS_ERROR_NO_CONTENT should not be returned to the
    1:                 // caller... This is an internal error code indicating that
    1:                 // the URI had no data associated with it - probably a 
    1:                 // helper-app style protocol (ie. mailto://)
    1:                 //
    1:                 rv = NS_OK;
    1:             }
    1:             else if (isNewWindow) {
    1:                 // XXX: Once new windows are created hidden, the new
    1:                 //      window will need to be made visible...  For now,
    1:                 //      do nothing.
    1:             }
    1:         }
    1: 
    1:         // Else we ran out of memory, or were a popup and got blocked,
    1:         // or something.
    1:         
    1:         return rv;
    1:     }
    1: 
    1:     //
    1:     // Load is being targetted at this docshell so return an error if the
    1:     // docshell is in the process of being destroyed.
    1:     //
    1:     if (mIsBeingDestroyed) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
10999:     rv = CheckLoadingPermissions();
10999:     if (NS_FAILED(rv)) {
10999:         return rv;
10999:     }
10999: 
14660:     // If this docshell is owned by a frameloader, make sure to cancel
14660:     // possible frameloader initialization before loading a new page.
14660:     nsCOMPtr<nsIDocShellTreeItem> parent;
14660:     GetParent(getter_AddRefs(parent));
14660:     if (parent) {
14660:       nsCOMPtr<nsIDOMDocument> domDoc = do_GetInterface(parent);
14660:       nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
14660:       if (doc) {
14660:         doc->TryCancelFrameLoaderInitialization(this);
14660:       }
14660:     }
14660: 
10999:     if (mFiredUnloadEvent) {
10999:         if (IsOKToLoadURI(aURI)) {
10999:             NS_PRECONDITION(!aWindowTarget || !*aWindowTarget,
10999:                             "Shouldn't have a window target here!");
10999: 
10999:             // If this is a replace load, make whatever load triggered
10999:             // the unload event also a replace load, so we don't
10999:             // create extra history entries.
10999:             if (LOAD_TYPE_HAS_FLAGS(aLoadType, LOAD_FLAGS_REPLACE_HISTORY)) {
10999:                 mLoadType = LOAD_NORMAL_REPLACE;
10999:             }
10999:             
10999:             // Do this asynchronously
10999:             nsCOMPtr<nsIRunnable> ev =
10999:                 new InternalLoadEvent(this, aURI, aReferrer, aOwner, aFlags,
10999:                                       aTypeHint, aPostData, aHeadersData,
10999:                                       aLoadType, aSHEntry, aFirstParty);
10999:             return NS_DispatchToCurrentThread(ev);
10999:         }
10999: 
10999:         // Just ignore this load attempt
10999:         return NS_OK;
10999:     }
10999: 
    1:     // Before going any further vet loads initiated by external programs.
    1:     if (aLoadType == LOAD_NORMAL_EXTERNAL) {
    1:         // Disallow external chrome: loads targetted at content windows
    1:         PRBool isChrome = PR_FALSE;
    1:         if (NS_SUCCEEDED(aURI->SchemeIs("chrome", &isChrome)) && isChrome) {
    1:             NS_WARNING("blocked external chrome: url -- use '-chrome' option");
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         // clear the decks to prevent context bleed-through (bug 298255)
27151:         rv = CreateAboutBlankContentViewer(nsnull, nsnull);
    1:         if (NS_FAILED(rv))
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         // reset loadType so we don't have to add lots of tests for
    1:         // LOAD_NORMAL_EXTERNAL after this point
    1:         aLoadType = LOAD_NORMAL;
    1:     }
    1: 
    1:     mAllowKeywordFixup =
    1:       (aFlags & INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP) != 0;
    1:     mURIResultedInDocument = PR_FALSE;  // reset the clock...
    1:    
    1:     //
    1:     // First:
    1:     // Check to see if the new URI is an anchor in the existing document.
    1:     // Skip this check if we're doing some sort of abnormal load, if the
    1:     // new load is a non-history load and has postdata, or if we're doing
    1:     // a history load and the page identifiers of mOSHE and aSHEntry
    1:     // don't match.
    1:     //
    1:     PRBool allowScroll = PR_TRUE;
    1:     if (!aSHEntry) {
    1:         allowScroll = (aPostData == nsnull);
    1:     } else if (mOSHE) {
    1:         PRUint32 ourPageIdent;
    1:         mOSHE->GetPageIdentifier(&ourPageIdent);
    1:         PRUint32 otherPageIdent;
    1:         aSHEntry->GetPageIdentifier(&otherPageIdent);
    1:         allowScroll = (ourPageIdent == otherPageIdent);
    1: #ifdef DEBUG
    1:         if (allowScroll) {
    1:             nsCOMPtr<nsIInputStream> currentPostData;
    1:             mOSHE->GetPostData(getter_AddRefs(currentPostData));
    1:             NS_ASSERTION(currentPostData == aPostData,
    1:                          "Different POST data for entries for the same page?");
    1:         }
    1: #endif
    1:     }
    1:     
    1:     if ((aLoadType == LOAD_NORMAL ||
    1:          aLoadType == LOAD_STOP_CONTENT ||
    1:          LOAD_TYPE_HAS_FLAGS(aLoadType, LOAD_FLAGS_REPLACE_HISTORY) ||
    1:          aLoadType == LOAD_HISTORY ||
    1:          aLoadType == LOAD_LINK) && allowScroll) {
    1:         PRBool wasAnchor = PR_FALSE;
29975:         PRBool doHashchange = PR_FALSE;
    1:         nscoord cx, cy;
29975:         NS_ENSURE_SUCCESS(ScrollIfAnchor(aURI, &wasAnchor, aLoadType, &cx, &cy,
29975:                                          &doHashchange),
29975:                           NS_ERROR_FAILURE);
29975: 
    1:         if (wasAnchor) {
    1:             mLoadType = aLoadType;
    1:             mURIResultedInDocument = PR_TRUE;
    1: 
    1:             /* we need to assign mLSHE to aSHEntry right here, so that on History loads, 
    1:              * SetCurrentURI() called from OnNewURI() will send proper 
    1:              * onLocationChange() notifications to the browser to update
    1:              * back/forward buttons. 
    1:              */
    1:             SetHistoryEntry(&mLSHE, aSHEntry);
    1: 
    1:             /* This is a anchor traversal with in the same page.
    1:              * call OnNewURI() so that, this traversal will be 
    1:              * recorded in session and global history.
    1:              */
22687:             nsCOMPtr<nsISupports> owner;
22687:             if (mOSHE) {
22687:                 mOSHE->GetOwner(getter_AddRefs(owner));
22687:             }
22687:             OnNewURI(aURI, nsnull, owner, mLoadType, PR_TRUE);
    1:             nsCOMPtr<nsIInputStream> postData;
    1:             PRUint32 pageIdent = PR_UINT32_MAX;
12420:             nsCOMPtr<nsISupports> cacheKey;
    1:             
    1:             if (mOSHE) {
    1:                 /* save current position of scroller(s) (bug 59774) */
    1:                 mOSHE->SetScrollPosition(cx, cy);
    1:                 // Get the postdata and page ident from the current page, if
    1:                 // the new load is being done via normal means.  Note that
    1:                 // "normal means" can be checked for just by checking for
    1:                 // LOAD_CMD_NORMAL, given the loadType and allowScroll check
    1:                 // above -- it filters out some LOAD_CMD_NORMAL cases that we
    1:                 // wouldn't want here.
    1:                 if (aLoadType & LOAD_CMD_NORMAL) {
    1:                     mOSHE->GetPostData(getter_AddRefs(postData));
    1:                     mOSHE->GetPageIdentifier(&pageIdent);
12420:                     mOSHE->GetCacheKey(getter_AddRefs(cacheKey));
    1:                 }
    1:             }
    1:             
    1:             /* Assign mOSHE to mLSHE. This will either be a new entry created
    1:              * by OnNewURI() for normal loads or aSHEntry for history loads.
    1:              */
    1:             if (mLSHE) {
    1:                 SetHistoryEntry(&mOSHE, mLSHE);
    1:                 // Save the postData obtained from the previous page
    1:                 // in to the session history entry created for the 
    1:                 // anchor page, so that any history load of the anchor
    1:                 // page will restore the appropriate postData.
    1:                 if (postData)
    1:                     mOSHE->SetPostData(postData);
    1: 
12420:                 // Make sure we won't just repost without hitting the
12420:                 // cache first
12420:                 if (cacheKey)
12420:                     mOSHE->SetCacheKey(cacheKey);
12420:                 
    1:                 // Propagate our page ident to the new mOSHE so that
    1:                 // we'll know it just differed by a scroll on the page.
    1:                 if (pageIdent != PR_UINT32_MAX)
    1:                     mOSHE->SetPageIdentifier(pageIdent);
    1:             }
    1: 
    1:             /* restore previous position of scroller(s), if we're moving
    1:              * back in history (bug 59774)
    1:              */
    1:             if (mOSHE && (aLoadType == LOAD_HISTORY || aLoadType == LOAD_RELOAD_NORMAL))
    1:             {
    1:                 nscoord bx, by;
    1:                 mOSHE->GetScrollPosition(&bx, &by);
    1:                 SetCurScrollPosEx(bx, by);
    1:             }
    1: 
    1:             /* Clear out mLSHE so that further anchor visits get
    1:              * recorded in SH and SH won't misbehave. 
    1:              */
    1:             SetHistoryEntry(&mLSHE, nsnull);
    1:             /* Set the title for the SH entry for this target url. so that
    1:              * SH menus in go/back/forward buttons won't be empty for this.
    1:              */
    1:             if (mSessionHistory) {
    1:                 PRInt32 index = -1;
    1:                 mSessionHistory->GetIndex(&index);
    1:                 nsCOMPtr<nsIHistoryEntry> hEntry;
    1:                 mSessionHistory->GetEntryAtIndex(index, PR_FALSE,
    1:                                                  getter_AddRefs(hEntry));
    1:                 NS_ENSURE_TRUE(hEntry, NS_ERROR_FAILURE);
    1:                 nsCOMPtr<nsISHEntry> shEntry(do_QueryInterface(hEntry));
    1:                 if (shEntry)
    1:                     shEntry->SetTitle(mTitle);
    1:             }
    1: 
29975:             if (doHashchange) {
29975:                 nsCOMPtr<nsPIDOMWindow> window =
29975:                     do_QueryInterface(mScriptGlobal);
29975: 
29975:                 if (window)
29975:                     window->DispatchAsyncHashchange();
29975:             }
29975: 
    1:             return NS_OK;
    1:         }
    1:     }
    1:     
    1:     // mContentViewer->PermitUnload can destroy |this| docShell, which
    1:     // causes the next call of CanSavePresentation to crash. 
    1:     // Hold onto |this| until we return, to prevent a crash from happening. 
    1:     // (bug#331040)
    1:     nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
    1: 
    1:     // Check if the page doesn't want to be unloaded. The javascript:
    1:     // protocol handler deals with this for javascript: URLs.
    1:     if (!bIsJavascript && mContentViewer) {
    1:         PRBool okToUnload;
34032:         rv = mContentViewer->PermitUnload(PR_FALSE, &okToUnload);
    1: 
    1:         if (NS_SUCCEEDED(rv) && !okToUnload) {
    1:             // The user chose not to unload the page, interrupt the
    1:             // load.
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     // Check for saving the presentation here, before calling Stop().
    1:     // This is necessary so that we can catch any pending requests.
    1:     // Since the new request has not been created yet, we pass null for the
    1:     // new request parameter.
    1:     // Also pass nsnull for the document, since it doesn't affect the return
    1:     // value for our purposes here.
    1:     PRBool savePresentation = CanSavePresentation(aLoadType, nsnull, nsnull);
    1: 
    1:     // Don't stop current network activity for javascript: URL's since
    1:     // they might not result in any data, and thus nothing should be
    1:     // stopped in those cases. In the case where they do result in
    1:     // data, the javascript: URL channel takes care of stopping
    1:     // current network activity.
    1:     if (!bIsJavascript) {
    1:         // Stop any current network activity.
    1:         // Also stop content if this is a zombie doc. otherwise 
    1:         // the onload will be delayed by other loads initiated in the 
    1:         // background by the first document that
    1:         // didn't fully load before the next load was initiated.
    1:         // If not a zombie, don't stop content until data 
    1:         // starts arriving from the new URI...
    1: 
    1:         nsCOMPtr<nsIContentViewer> zombieViewer;
    1:         if (mContentViewer) {
    1:             mContentViewer->GetPreviousViewer(getter_AddRefs(zombieViewer));
    1:         }
    1: 
    1:         if (zombieViewer ||
    1:             LOAD_TYPE_HAS_FLAGS(aLoadType, LOAD_FLAGS_STOP_CONTENT)) {
    1:             rv = Stop(nsIWebNavigation::STOP_ALL);
    1:         } else {
    1:             rv = Stop(nsIWebNavigation::STOP_NETWORK);
    1:         }
    1: 
    1:         if (NS_FAILED(rv)) 
    1:             return rv;
    1:     }
    1: 
    1:     mLoadType = aLoadType;
    1: 
    1:     // mLSHE should be assigned to aSHEntry, only after Stop() has
    1:     // been called. But when loading an error page, do not clear the
    1:     // mLSHE for the real page.
    1:     if (mLoadType != LOAD_ERROR_PAGE)
    1:         SetHistoryEntry(&mLSHE, aSHEntry);
    1: 
    1:     mSavingOldViewer = savePresentation;
    1: 
    1:     // If we have a saved content viewer in history, restore and show it now.
    1:     if (aSHEntry && (mLoadType & LOAD_CMD_HISTORY)) {
 6685:         // It's possible that the previous viewer of mContentViewer is the
 6685:         // viewer that will end up in aSHEntry when it gets closed.  If that's
 6685:         // the case, we need to go ahead and force it into its shentry so we
 6685:         // can restore it.
 6685:         if (mContentViewer) {
 6685:             nsCOMPtr<nsIContentViewer> prevViewer;
 6685:             mContentViewer->GetPreviousViewer(getter_AddRefs(prevViewer));
 6685:             if (prevViewer) {
 6685: #ifdef DEBUG
 6685:                 nsCOMPtr<nsIContentViewer> prevPrevViewer;
 6685:                 prevViewer->GetPreviousViewer(getter_AddRefs(prevPrevViewer));
 6685:                 NS_ASSERTION(!prevPrevViewer, "Should never have viewer chain here");
 6685: #endif
 6685:                 nsCOMPtr<nsISHEntry> viewerEntry;
 6685:                 prevViewer->GetHistoryEntry(getter_AddRefs(viewerEntry));
 6685:                 if (viewerEntry == aSHEntry) {
 6685:                     // Make sure this viewer ends up in the right place
 6685:                     mContentViewer->SetPreviousViewer(nsnull);
 6685:                     prevViewer->Destroy();
 6685:                 }
 6685:             }
 6685:         }
    1:         nsCOMPtr<nsISHEntry> oldEntry = mOSHE;
    1:         PRBool restoring;
    1:         rv = RestorePresentation(aSHEntry, &restoring);
    1:         if (restoring)
    1:             return rv;
    1: 
    1:         // We failed to restore the presentation, so clean up.
    1:         // Both the old and new history entries could potentially be in
    1:         // an inconsistent state.
    1:         if (NS_FAILED(rv)) {
    1:             if (oldEntry)
    1:                 oldEntry->SyncPresentationState();
    1: 
    1:             aSHEntry->SyncPresentationState();
    1:         }
    1:     }
    1: 
    1:     nsCOMPtr<nsIRequest> req;
    1:     rv = DoURILoad(aURI, aReferrer,
    1:                    !(aFlags & INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER),
    1:                    owner, aTypeHint, aPostData, aHeadersData, aFirstParty,
    1:                    aDocShell, getter_AddRefs(req),
10966:                    (aFlags & INTERNAL_LOAD_FLAGS_FIRST_LOAD) != 0,
29288:                    (aFlags & INTERNAL_LOAD_FLAGS_BYPASS_CLASSIFIER) != 0,
29288:                    (aFlags & INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES) != 0);
    1:     if (req && aRequest)
    1:         NS_ADDREF(*aRequest = req);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:         nsCOMPtr<nsIChannel> chan(do_QueryInterface(req));
    1:         DisplayLoadError(rv, aURI, nsnull, chan);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsIPrincipal*
    1: nsDocShell::GetInheritedPrincipal(PRBool aConsiderCurrentDocument)
    1: {
    1:     nsCOMPtr<nsIDocument> document;
    1: 
    1:     if (aConsiderCurrentDocument && mContentViewer) {
    1:         nsCOMPtr<nsIDocumentViewer>
    1:             docViewer(do_QueryInterface(mContentViewer));
    1:         if (!docViewer)
    1:             return nsnull;
    1:         docViewer->GetDocument(getter_AddRefs(document));
    1:     }
    1: 
    1:     if (!document) {
    1:         nsCOMPtr<nsIDocShellTreeItem> parentItem;
    1:         GetSameTypeParent(getter_AddRefs(parentItem));
    1:         if (parentItem) {
    1:             nsCOMPtr<nsIDOMDocument> parentDomDoc(do_GetInterface(parentItem));
    1:             document = do_QueryInterface(parentDomDoc);
    1:         }
    1:     }
    1: 
    1:     if (!document) {
    1:         if (!aConsiderCurrentDocument) {
    1:             return nsnull;
    1:         }
    1: 
    1:         // Make sure we end up with _something_ as the principal no matter
    1:         // what.
    1:         EnsureContentViewer();  // If this fails, we'll just get a null
    1:                                 // docViewer and bail.
    1: 
    1:         nsCOMPtr<nsIDocumentViewer>
    1:             docViewer(do_QueryInterface(mContentViewer));
    1:         if (!docViewer)
    1:             return nsnull;
    1:         docViewer->GetDocument(getter_AddRefs(document));
    1:     }
    1: 
    1:     //-- Get the document's principal
    1:     if (document) {
    1:         return document->NodePrincipal();
    1:     }
    1: 
    1:     return nsnull;
    1: }
    1: 
20651: PRBool
20651: nsDocShell::ShouldCheckAppCache(nsIURI *aURI)
20651: {
20651:     nsCOMPtr<nsIOfflineCacheUpdateService> offlineService =
20651:         do_GetService(NS_OFFLINECACHEUPDATESERVICE_CONTRACTID);
20651:     if (!offlineService) {
20651:         return PR_FALSE;
20651:     }
20651: 
20651:     PRBool allowed;
20651:     nsresult rv = offlineService->OfflineAppAllowedForURI(aURI,
20651:                                                           nsnull,
20651:                                                           &allowed);
20651:     return NS_SUCCEEDED(rv) && allowed;
20651: }
20651: 
    1: nsresult
    1: nsDocShell::DoURILoad(nsIURI * aURI,
    1:                       nsIURI * aReferrerURI,
    1:                       PRBool aSendReferrer,
    1:                       nsISupports * aOwner,
    1:                       const char * aTypeHint,
    1:                       nsIInputStream * aPostData,
    1:                       nsIInputStream * aHeadersData,
    1:                       PRBool aFirstParty,
    1:                       nsIDocShell ** aDocShell,
    1:                       nsIRequest ** aRequest,
10966:                       PRBool aIsNewWindowTarget,
29288:                       PRBool aBypassClassifier,
29288:                       PRBool aForceAllowCookies)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIURILoader> uriLoader;
    1: 
    1:     uriLoader = do_GetService(NS_URI_LOADER_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
    1:     if (aFirstParty) {
    1:         // tag first party URL loads
    1:         loadFlags |= nsIChannel::LOAD_INITIAL_DOCUMENT_URI;
    1:     }
    1: 
    1:     if (mLoadType == LOAD_ERROR_PAGE) {
    1:         // Error pages are LOAD_BACKGROUND
    1:         loadFlags |= nsIChannel::LOAD_BACKGROUND;
    1:     }
    1: 
    1:     // open a channel for the url
    1:     nsCOMPtr<nsIChannel> channel;
    1: 
    1:     rv = NS_NewChannel(getter_AddRefs(channel),
    1:                        aURI,
    1:                        nsnull,
    1:                        nsnull,
 3233:                        static_cast<nsIInterfaceRequestor *>(this),
    1:                        loadFlags);
    1:     if (NS_FAILED(rv)) {
    1:         if (rv == NS_ERROR_UNKNOWN_PROTOCOL) {
    1:             // This is a uri with a protocol scheme we don't know how
    1:             // to handle.  Embedders might still be interested in
    1:             // handling the load, though, so we fire a notification
    1:             // before throwing the load away.
    1:             PRBool abort = PR_FALSE;
    1:             nsresult rv2 = mContentListener->OnStartURIOpen(aURI, &abort);
    1:             if (NS_SUCCEEDED(rv2) && abort) {
    1:                 // Hey, they're handling the load for us!  How convenient!
    1:                 return NS_OK;
    1:             }
    1:         }
    1:             
    1:         return rv;
    1:     }
    1: 
21311:     nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
21311:         do_QueryInterface(channel);
21311:     if (appCacheChannel) {
21366:         // Any document load should not inherit application cache.
21311:         appCacheChannel->SetInheritApplicationCache(PR_FALSE);
21366: 
21366:         // Loads with the correct permissions should check for a matching
21366:         // application cache.
21311:         appCacheChannel->SetChooseApplicationCache(ShouldCheckAppCache(aURI));
21311:     }
21311: 
    1:     // Make sure to give the caller a channel if we managed to create one
    1:     // This is important for correct error page/session history interaction
    1:     if (aRequest)
    1:         NS_ADDREF(*aRequest = channel);
    1: 
    1:     channel->SetOriginalURI(aURI);
    1:     if (aTypeHint && *aTypeHint) {
    1:         channel->SetContentType(nsDependentCString(aTypeHint));
    1:         mContentTypeHint = aTypeHint;
    1:     }
    1:     else {
    1:         mContentTypeHint.Truncate();
    1:     }
    1:     
    1:     //hack
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:     nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal(do_QueryInterface(channel));
    1:     if (httpChannelInternal) {
29288:       if (aForceAllowCookies) {
29288:         httpChannelInternal->SetForceAllowThirdPartyCookie(PR_TRUE);
29288:       } 
    1:       if (aFirstParty) {
    1:         httpChannelInternal->SetDocumentURI(aURI);
    1:       } else {
    1:         httpChannelInternal->SetDocumentURI(aReferrerURI);
    1:       }
    1:     }
    1: 
    1:     nsCOMPtr<nsIWritablePropertyBag2> props(do_QueryInterface(channel));
    1:     if (props)
    1:     {
    1:       // save true referrer for those who need it (e.g. xpinstall whitelisting)
    1:       // Currently only http and ftp channels support this.
    1:       props->SetPropertyAsInterface(NS_LITERAL_STRING("docshell.internalReferrer"),
    1:                                     aReferrerURI);
    1:     }
    1: 
    1:     //
    1:     // If this is a HTTP channel, then set up the HTTP specific information
    1:     // (ie. POST data, referrer, ...)
    1:     //
    1:     if (httpChannel) {
    1:         nsCOMPtr<nsICachingChannel>  cacheChannel(do_QueryInterface(httpChannel));
    1:         /* Get the cache Key from SH */
    1:         nsCOMPtr<nsISupports> cacheKey;
    1:         if (mLSHE) {
    1:             mLSHE->GetCacheKey(getter_AddRefs(cacheKey));
    1:         }
    1:         else if (mOSHE)          // for reload cases
    1:             mOSHE->GetCacheKey(getter_AddRefs(cacheKey));
    1: 
    1:         // figure out if we need to set the post data stream on the channel...
    1:         // right now, this is only done for http channels.....
    1:         if (aPostData) {
    1:             // XXX it's a bit of a hack to rewind the postdata stream here but
    1:             // it has to be done in case the post data is being reused multiple
    1:             // times.
    1:             nsCOMPtr<nsISeekableStream>
    1:                 postDataSeekable(do_QueryInterface(aPostData));
    1:             if (postDataSeekable) {
    1:                 rv = postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
    1:                 NS_ENSURE_SUCCESS(rv, rv);
    1:             }
    1: 
    1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
    1:             NS_ASSERTION(uploadChannel, "http must support nsIUploadChannel");
    1: 
    1:             // we really need to have a content type associated with this stream!!
    1:             uploadChannel->SetUploadStream(aPostData, EmptyCString(), -1);
    1:             /* If there is a valid postdata *and* it is a History Load,
    1:              * set up the cache key on the channel, to retrieve the
    1:              * data *only* from the cache. If it is a normal reload, the 
    1:              * cache is free to go to the server for updated postdata. 
    1:              */
    1:             if (cacheChannel && cacheKey) {
    1:                 if (mLoadType == LOAD_HISTORY || mLoadType == LOAD_RELOAD_CHARSET_CHANGE) {
    1:                     cacheChannel->SetCacheKey(cacheKey);
    1:                     PRUint32 loadFlags;
    1:                     if (NS_SUCCEEDED(channel->GetLoadFlags(&loadFlags)))
    1:                         channel->SetLoadFlags(loadFlags | nsICachingChannel::LOAD_ONLY_FROM_CACHE);
    1:                 }
    1:                 else if (mLoadType == LOAD_RELOAD_NORMAL)
    1:                     cacheChannel->SetCacheKey(cacheKey);
    1:             }         
    1:         }
    1:         else {
    1:             /* If there is no postdata, set the cache key on the channel, and
    1:              * do not set the LOAD_ONLY_FROM_CACHE flag, so that the channel
    1:              * will be free to get it from net if it is not found in cache.
    1:              * New cache may use it creatively on CGI pages with GET
    1:              * method and even on those that say "no-cache"
    1:              */
    1:             if (mLoadType == LOAD_HISTORY || mLoadType == LOAD_RELOAD_NORMAL 
    1:                 || mLoadType == LOAD_RELOAD_CHARSET_CHANGE) {
    1:                 if (cacheChannel && cacheKey)
    1:                     cacheChannel->SetCacheKey(cacheKey);
    1:             }
    1:         }
    1:         if (aHeadersData) {
    1:             rv = AddHeadersToChannel(aHeadersData, httpChannel);
    1:         }
    1:         // Set the referrer explicitly
    1:         if (aReferrerURI && aSendReferrer) {
    1:             // Referrer is currenly only set for link clicks here.
    1:             httpChannel->SetReferrer(aReferrerURI);
    1:         }
    1:     }
    1:     //
    1:     // Set the owner of the channel, but only for channels that can't
    1:     // provide their own security context.
    1:     //
    1:     // XXX: Is seems wrong that the owner is ignored - even if one is
    1:     //      supplied) unless the URI is javascript or data or about:blank.
    1:     // XXX: If this is ever changed, check all callers for what owners they're
    1:     //      passing in.  In particular, see the code and comments in LoadURI
    1:     //      where we fall back on inheriting the owner if called
    1:     //      from chrome.  That would be very wrong if this code changed
    1:     //      anything but channels that can't provide their own security context!
    1:     //
    1:     //      (Currently chrome URIs set the owner when they are created!
    1:     //      So setting a NULL owner would be bad!)
    1:     //
 8608:     // If this code ever changes, change nsObjectLoadingContent::LoadObject
 8608:     // accordingly.
    1:     PRBool inherit;
    1:     // We expect URIInheritsSecurityContext to return success for an
    1:     // about:blank URI, so don't call IsAboutBlank() if this call fails.
    1:     rv = URIInheritsSecurityContext(aURI, &inherit);
    1:     if (NS_SUCCEEDED(rv) && (inherit || IsAboutBlank(aURI))) {
    1:         channel->SetOwner(aOwner);
 8608:     }
 8608: 
13414:     //
13414:     // file: uri special-casing
13414:     //
13414:     // If this is a file: load opened from another file: then it may need
13414:     // to inherit the owner from the referrer so they can script each other.
13414:     // If we don't set the owner explicitly then each file: gets an owner
13414:     // based on its own codebase later.
13414:     //
13414:     nsCOMPtr<nsIPrincipal> ownerPrincipal(do_QueryInterface(aOwner));
13471:     if (URIIsLocalFile(aURI) && ownerPrincipal &&
13471:         NS_SUCCEEDED(ownerPrincipal->CheckMayLoad(aURI, PR_FALSE))) {
18504:         // One more check here.  CheckMayLoad will always return true for the
18504:         // system principal, but we do NOT want to inherit in that case.
18504:         PRBool isSystem;
18504:         nsCOMPtr<nsIScriptSecurityManager> secMan =
18504:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
18504:         if (secMan &&
18504:             NS_SUCCEEDED(secMan->IsSystemPrincipal(ownerPrincipal,
18504:                                                    &isSystem)) &&
18504:             !isSystem) {
13414:             channel->SetOwner(aOwner);
13414:         }
18504:     }
13414: 
    1:     nsCOMPtr<nsIScriptChannel> scriptChannel = do_QueryInterface(channel);
    1:     if (scriptChannel) {
    1:         // Allow execution against our context if the principals match
    1:         scriptChannel->
    1:             SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
    1:     }
    1: 
    1:     if (aIsNewWindowTarget) {
    1:         nsCOMPtr<nsIWritablePropertyBag2> props = do_QueryInterface(channel);
    1:         if (props) {
    1:             props->SetPropertyAsBool(
    1:                 NS_LITERAL_STRING("docshell.newWindowTarget"),
    1:                 PR_TRUE);
    1:         }
    1:     }
    1: 
10966:     rv = DoChannelLoad(channel, uriLoader, aBypassClassifier);
    1: 
    1:     //
    1:     // If the channel load failed, we failed and nsIWebProgress just ain't
    1:     // gonna happen.
    1:     //
    1:     if (NS_SUCCEEDED(rv)) {
    1:         if (aDocShell) {
    1:           *aDocShell = this;
    1:           NS_ADDREF(*aDocShell);
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: static NS_METHOD
    1: AppendSegmentToString(nsIInputStream *in,
    1:                       void *closure,
    1:                       const char *fromRawSegment,
    1:                       PRUint32 toOffset,
    1:                       PRUint32 count,
    1:                       PRUint32 *writeCount)
    1: {
    1:     // aFromSegment now contains aCount bytes of data.
    1: 
 3233:     nsCAutoString *buf = static_cast<nsCAutoString *>(closure);
    1:     buf->Append(fromRawSegment, count);
    1: 
    1:     // Indicate that we have consumed all of aFromSegment
    1:     *writeCount = count;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::AddHeadersToChannel(nsIInputStream *aHeadersData,
    1:                                 nsIChannel *aGenericChannel)
    1: {
    1:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aGenericChannel);
    1:     NS_ENSURE_STATE(httpChannel);
    1: 
    1:     PRUint32 numRead;
    1:     nsCAutoString headersString;
    1:     nsresult rv = aHeadersData->ReadSegments(AppendSegmentToString,
    1:                                              &headersString,
    1:                                              PR_UINT32_MAX,
    1:                                              &numRead);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // used during the manipulation of the String from the InputStream
    1:     nsCAutoString headerName;
    1:     nsCAutoString headerValue;
    1:     PRInt32 crlf;
    1:     PRInt32 colon;
    1: 
    1:     //
    1:     // Iterate over the headersString: for each "\r\n" delimited chunk,
    1:     // add the value as a header to the nsIHttpChannel
    1:     //
    1: 
    1:     static const char kWhitespace[] = "\b\t\r\n ";
    1:     while (PR_TRUE) {
    1:         crlf = headersString.Find("\r\n");
    1:         if (crlf == kNotFound)
    1:             return NS_OK;
    1: 
    1:         const nsCSubstring &oneHeader = StringHead(headersString, crlf);
    1: 
    1:         colon = oneHeader.FindChar(':');
    1:         if (colon == kNotFound)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         headerName = StringHead(oneHeader, colon);
    1:         headerValue = Substring(oneHeader, colon + 1);
    1: 
    1:         headerName.Trim(kWhitespace);
    1:         headerValue.Trim(kWhitespace);
    1: 
    1:         headersString.Cut(0, crlf + 2);
    1: 
    1:         //
    1:         // FINALLY: we can set the header!
    1:         // 
    1: 
    1:         rv = httpChannel->SetRequestHeader(headerName, headerValue, PR_TRUE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     NS_NOTREACHED("oops");
    1:     return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: nsresult nsDocShell::DoChannelLoad(nsIChannel * aChannel,
10966:                                    nsIURILoader * aURILoader,
10966:                                    PRBool aBypassClassifier)
    1: {
    1:     nsresult rv;
    1:     // Mark the channel as being a document URI and allow content sniffing...
    1:     nsLoadFlags loadFlags = 0;
    1:     (void) aChannel->GetLoadFlags(&loadFlags);
    1:     loadFlags |= nsIChannel::LOAD_DOCUMENT_URI |
    1:                  nsIChannel::LOAD_CALL_CONTENT_SNIFFERS;
    1: 
    1:     // Load attributes depend on load type...
    1:     switch (mLoadType) {
    1:     case LOAD_HISTORY:
    1:         loadFlags |= nsIRequest::VALIDATE_NEVER;
    1:         break;
    1: 
    1:     case LOAD_RELOAD_CHARSET_CHANGE:
    1:         loadFlags |= nsIRequest::LOAD_FROM_CACHE;
    1:         break;
    1:     
    1:     case LOAD_RELOAD_NORMAL:
    1:     case LOAD_REFRESH:
    1:         loadFlags |= nsIRequest::VALIDATE_ALWAYS;
    1:         break;
    1: 
    1:     case LOAD_NORMAL_BYPASS_CACHE:
    1:     case LOAD_NORMAL_BYPASS_PROXY:
    1:     case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    1:     case LOAD_RELOAD_BYPASS_CACHE:
    1:     case LOAD_RELOAD_BYPASS_PROXY:
    1:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
    1:         loadFlags |= nsIRequest::LOAD_BYPASS_CACHE;
    1:         break;
    1: 
    1:     case LOAD_NORMAL:
    1:     case LOAD_LINK:
    1:         // Set cache checking flags
    1:         PRInt32 prefSetting;
    1:         if (NS_SUCCEEDED
    1:             (mPrefs->
    1:              GetIntPref("browser.cache.check_doc_frequency",
    1:                         &prefSetting))) {
    1:             switch (prefSetting) {
    1:             case 0:
    1:                 loadFlags |= nsIRequest::VALIDATE_ONCE_PER_SESSION;
    1:                 break;
    1:             case 1:
    1:                 loadFlags |= nsIRequest::VALIDATE_ALWAYS;
    1:                 break;
    1:             case 2:
    1:                 loadFlags |= nsIRequest::VALIDATE_NEVER;
    1:                 break;
    1:             }
    1:         }
    1:         break;
    1:     }
    1: 
    1:     (void) aChannel->SetLoadFlags(loadFlags);
    1: 
    1:     rv = aURILoader->OpenURI(aChannel,
    1:                              (mLoadType == LOAD_LINK),
    1:                              this);
 5528:     NS_ENSURE_SUCCESS(rv, rv);
 5528: 
10966:     if (!aBypassClassifier) {
 5528:         rv = CheckClassifier(aChannel);
 5528:         if (NS_FAILED(rv)) {
 5528:             aChannel->Cancel(rv);
    1:             return rv;
    1:         }
10966:     }
    1: 
 5528:     return NS_OK;
 5528: }
 5528: 
 5528: nsresult
 5528: nsDocShell::CheckClassifier(nsIChannel *aChannel)
 5528: {
 5528:     nsRefPtr<nsClassifierCallback> classifier = new nsClassifierCallback();
 5528:     if (!classifier) return NS_ERROR_OUT_OF_MEMORY;
 5528: 
23790:     nsresult rv = classifier->Start(aChannel, PR_FALSE);
 5528:     NS_ENSURE_SUCCESS(rv, rv);
 5528: 
 5528:     mClassifier = classifier;
 5528: 
 5528:     return NS_OK;
 5528: }
 5528: 
29975: nsresult
    1: nsDocShell::ScrollIfAnchor(nsIURI * aURI, PRBool * aWasAnchor,
29975:                            PRUint32 aLoadType, nscoord *cx, nscoord *cy,
29975:                            PRBool * aDoHashchange)
    1: {
    1:     NS_ASSERTION(aURI, "null uri arg");
    1:     NS_ASSERTION(aWasAnchor, "null anchor arg");
29975:     NS_PRECONDITION(aDoHashchange, "null hashchange arg");
29975: 
29975:     if (!aURI || !aWasAnchor) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     *aWasAnchor = PR_FALSE;
29975:     *aDoHashchange = PR_FALSE;
    1: 
    1:     if (!mCurrentURI) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsCOMPtr<nsIPresShell> shell;
    1:     nsresult rv = GetPresShell(getter_AddRefs(shell));
    1:     if (NS_FAILED(rv) || !shell) {
    1:         // If we failed to get the shell, or if there is no shell,
    1:         // nothing left to do here.
    1:         
    1:         return rv;
    1:     }
    1: 
    1:     // NOTE: we assume URIs are absolute for comparison purposes
    1: 
    1:     nsCAutoString currentSpec;
    1:     NS_ENSURE_SUCCESS(mCurrentURI->GetSpec(currentSpec),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     nsCAutoString newSpec;
    1:     NS_ENSURE_SUCCESS(aURI->GetSpec(newSpec), NS_ERROR_FAILURE);
    1: 
    1:     // Search for hash marks in the current URI and the new URI and
    1:     // take a copy of everything to the left of the hash for
    1:     // comparison.
    1: 
    1:     const char kHash = '#';
    1: 
    1:     // Split the new URI into a left and right part
29975:     // (assume we're parsing it out right)
    1:     nsACString::const_iterator urlStart, urlEnd, refStart, refEnd;
    1:     newSpec.BeginReading(urlStart);
    1:     newSpec.EndReading(refEnd);
    1:     
    1:     PRInt32 hashNew = newSpec.FindChar(kHash);
    1:     if (hashNew == 0) {
    1:         return NS_OK;           // Strange URI
    1:     }
    1: 
    1:     if (hashNew > 0) {
    1:         // found it
    1:         urlEnd = urlStart;
    1:         urlEnd.advance(hashNew);
    1:         
    1:         refStart = urlEnd;
    1:         ++refStart;             // advanced past '#'
    1:         
    1:     }
    1:     else {
    1:         // no hash at all
    1:         urlEnd = refStart = refEnd;
    1:     }
    1:     const nsACString& sNewLeft = Substring(urlStart, urlEnd);
    1:     const nsACString& sNewRef =  Substring(refStart, refEnd);
    1:                                           
    1:     // Split the current URI in a left and right part
29975:     nsACString::const_iterator currentLeftStart, currentLeftEnd,
29975:                                currentRefStart, currentRefEnd;
    1:     currentSpec.BeginReading(currentLeftStart);
29975:     currentSpec.EndReading(currentRefEnd);
    1: 
    1:     PRInt32 hashCurrent = currentSpec.FindChar(kHash);
    1:     if (hashCurrent == 0) {
    1:         return NS_OK;           // Strange URI 
    1:     }
    1: 
    1:     if (hashCurrent > 0) {
    1:         currentLeftEnd = currentLeftStart;
    1:         currentLeftEnd.advance(hashCurrent);
29975: 
29975:         currentRefStart = currentLeftEnd;
29975:         ++currentRefStart; // advance past '#'
    1:     }
    1:     else {
29975:         // no hash at all in currentSpec
29975:         currentLeftEnd = currentRefStart = currentRefEnd;
    1:     }
    1: 
    1:     // If we have no new anchor, we do not want to scroll, unless there is a
    1:     // current anchor and we are doing a history load.  So return if we have no
    1:     // new anchor, and there is no current anchor or the load is not a history
    1:     // load.
    1:     NS_ASSERTION(hashNew != 0 && hashCurrent != 0,
    1:                  "What happened to the early returns above?");
    1:     if (hashNew == kNotFound &&
    1:         (hashCurrent == kNotFound || aLoadType != LOAD_HISTORY)) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Compare the URIs.
    1:     //
    1:     // NOTE: this is a case sensitive comparison because some parts of the
    1:     // URI are case sensitive, and some are not. i.e. the domain name
    1:     // is case insensitive but the the paths are not.
    1:     //
    1:     // This means that comparing "http://www.ABC.com/" to "http://www.abc.com/"
    1:     // will fail this test.
    1: 
    1:     if (!Substring(currentLeftStart, currentLeftEnd).Equals(sNewLeft)) {
    1:         return NS_OK;           // URIs not the same
    1:     }
    1: 
    1:     // Now we know we are dealing with an anchor
    1:     *aWasAnchor = PR_TRUE;
    1: 
29975:     // We should fire a hashchange event once we're done here if the two hashes
29975:     // are different.
29975:     *aDoHashchange = !Substring(currentRefStart, currentRefEnd).Equals(sNewRef);
29975: 
    1:     // Both the new and current URIs refer to the same page. We can now
    1:     // browse to the hash stored in the new URI.
    1:     //
    1:     // But first let's capture positions of scroller(s) that can
    1:     // (and usually will) be modified by GoToAnchor() call.
    1: 
    1:     GetCurScrollPos(ScrollOrientation_X, cx);
    1:     GetCurScrollPos(ScrollOrientation_Y, cy);
    1: 
    1:     if (!sNewRef.IsEmpty()) {
    1:         // anchor is there, but if it's a load from history,
    1:         // we don't have any anchor jumping to do
    1:         PRBool scroll = aLoadType != LOAD_HISTORY &&
    1:                         aLoadType != LOAD_RELOAD_NORMAL;
    1: 
    1:         char *str = ToNewCString(sNewRef);
    1:         if (!str) {
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         // nsUnescape modifies the string that is passed into it.
    1:         nsUnescape(str);
    1: 
    1:         // We assume that the bytes are in UTF-8, as it says in the
    1:         // spec:
    1:         // http://www.w3.org/TR/html4/appendix/notes.html#h-B.2.1
    1: 
    1:         // We try the UTF-8 string first, and then try the document's
    1:         // charset (see below).  If the string is not UTF-8,
    1:         // conversion will fail and give us an empty Unicode string.
    1:         // In that case, we should just fall through to using the
    1:         // page's charset.
    1:         rv = NS_ERROR_FAILURE;
    1:         NS_ConvertUTF8toUTF16 uStr(str);
    1:         if (!uStr.IsEmpty()) {
    1:             rv = shell->GoToAnchor(NS_ConvertUTF8toUTF16(str), scroll);
    1:         }
    1:         nsMemory::Free(str);
    1: 
    1:         // Above will fail if the anchor name is not UTF-8.  Need to
    1:         // convert from document charset to unicode.
    1:         if (NS_FAILED(rv)) {
    1:                 
    1:             // Get a document charset
    1:             NS_ENSURE_TRUE(mContentViewer, NS_ERROR_FAILURE);
    1:             nsCOMPtr<nsIDocumentViewer>
    1:                 docv(do_QueryInterface(mContentViewer));
    1:             NS_ENSURE_TRUE(docv, NS_ERROR_FAILURE);
    1:             nsCOMPtr<nsIDocument> doc;
    1:             rv = docv->GetDocument(getter_AddRefs(doc));
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1:             const nsACString &aCharset = doc->GetDocumentCharacterSet();
    1: 
    1:             nsCOMPtr<nsITextToSubURI> textToSubURI =
    1:                 do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             // Unescape and convert to unicode
    1:             nsXPIDLString uStr;
    1: 
    1:             rv = textToSubURI->UnEscapeAndConvert(PromiseFlatCString(aCharset).get(),
    1:                                                   PromiseFlatCString(sNewRef).get(),
    1:                                                   getter_Copies(uStr));
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             // Ignore return value of GoToAnchor, since it will return an error
    1:             // if there is no such anchor in the document, which is actually a
    1:             // success condition for us (we want to update the session history
    1:             // with the new URI no matter whether we actually scrolled
    1:             // somewhere).
    1:             shell->GoToAnchor(uStr, scroll);
    1:         }
    1:     }
    1:     else {
    1: 
    1:         // Tell the shell it's at an anchor, without scrolling.
    1:         shell->GoToAnchor(EmptyString(), PR_FALSE);
    1:         
    1:         // An empty anchor was found, but if it's a load from history,
    1:         // we don't have to jump to the top of the page. Scrollbar 
    1:         // position will be restored by the caller, based on positions
    1:         // stored in session history.
    1:         if (aLoadType == LOAD_HISTORY || aLoadType == LOAD_RELOAD_NORMAL)
    1:             return rv;
    1:         //An empty anchor. Scroll to the top of the page.
    1:         rv = SetCurScrollPosEx(0, 0);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: void
    1: nsDocShell::SetupReferrerFromChannel(nsIChannel * aChannel)
    1: {
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1:     if (httpChannel) {
    1:         nsCOMPtr<nsIURI> referrer;
    1:         nsresult rv = httpChannel->GetReferrer(getter_AddRefs(referrer));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             SetReferrerURI(referrer);
    1:         }
    1:     }
    1: }
    1: 
    1: PRBool
22687: nsDocShell::OnNewURI(nsIURI * aURI, nsIChannel * aChannel, nsISupports* aOwner,
    1:                      PRUint32 aLoadType, PRBool aFireOnLocationChange,
    1:                      PRBool aAddToGlobalHistory)
    1: {
22687:     NS_PRECONDITION(aURI, "uri is null");
22687:     NS_PRECONDITION(!aChannel || !aOwner, "Shouldn't have both set");
22687: 
    1: #if defined(PR_LOGGING) && defined(DEBUG)
    1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         aURI->GetSpec(spec);
    1: 
    1:         nsCAutoString chanName;
    1:         if (aChannel)
    1:             aChannel->GetName(chanName);
    1:         else
    1:             chanName.AssignLiteral("<no channel>");
    1: 
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:                ("nsDocShell[%p]::OnNewURI(\"%s\", [%s], 0x%x)\n", this, spec.get(),
    1:                 chanName.get(), aLoadType));
    1:     }
    1: #endif
    1: 
    1:     PRBool updateHistory = PR_TRUE;
    1:     PRBool equalUri = PR_FALSE;
    1:     PRBool shAvailable = PR_TRUE;  
    1: 
    1:     // Get the post data from the channel
    1:     nsCOMPtr<nsIInputStream> inputStream;
    1:     if (aChannel) {
    1:         nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1:         
    1:         // Check if the HTTPChannel is hiding under a multiPartChannel
    1:         if (!httpChannel)  {
    1:             GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
    1:         }
    1: 
    1:         if (httpChannel) {
    1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
    1:             if (uploadChannel) {
    1:                 uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
    1:             }
    1:         }
    1:     }
    1:     /* Create SH Entry (mLSHE) only if there is a  SessionHistory object (mSessionHistory) in
    1:      * the current frame or in the root docshell
    1:      */
    1:     nsCOMPtr<nsISHistory> rootSH = mSessionHistory;
    1:     if (!rootSH) {
    1:         // Get the handle to SH from the root docshell          
    1:         GetRootSessionHistory(getter_AddRefs(rootSH));
    1:         if (!rootSH)
    1:             shAvailable = PR_FALSE;
    1:     }  // rootSH
    1: 
    1: 
    1:     // Determine if this type of load should update history.
    1:     if (aLoadType == LOAD_BYPASS_HISTORY ||
    1:         aLoadType == LOAD_ERROR_PAGE ||
    1:         aLoadType & LOAD_CMD_HISTORY ||
    1:         aLoadType & LOAD_CMD_RELOAD)
    1:         updateHistory = PR_FALSE;
    1: 
    1:     // Check if the url to be loaded is the same as the one already loaded. 
    1:     if (mCurrentURI)
    1:         aURI->Equals(mCurrentURI, &equalUri);
    1: 
    1: #ifdef DEBUG
    1:     PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:            ("  shAvailable=%i updateHistory=%i equalURI=%i\n",
    1:             shAvailable, updateHistory, equalUri));
    1: #endif
    1: 
    1:     /* If the url to be loaded is the same as the one already there,
    1:      * and the original loadType is LOAD_NORMAL, LOAD_LINK, or
    1:      * LOAD_STOP_CONTENT, set loadType to LOAD_NORMAL_REPLACE so that
    1:      * AddToSessionHistory() won't mess with the current SHEntry and
    1:      * if this page has any frame children, it also will be handled
    1:      * properly. see bug 83684
    1:      *
    1:      * XXX Hopefully changing the loadType at this time will not hurt  
    1:      *  anywhere. The other way to take care of sequentially repeating
    1:      *  frameset pages is to add new methods to nsIDocShellTreeItem.
    1:      * Hopefully I don't have to do that. 
    1:      */
    1:     if (equalUri &&
    1:         (mLoadType == LOAD_NORMAL ||
    1:          mLoadType == LOAD_LINK ||
    1:          mLoadType == LOAD_STOP_CONTENT) &&
    1:         !inputStream)
    1:     {
    1:         mLoadType = LOAD_NORMAL_REPLACE;
    1:     }
    1: 
    1:     // If this is a refresh to the currently loaded url, we don't
    1:     // have to update session or global history.
    1:     if (mLoadType == LOAD_REFRESH && !inputStream && equalUri) {
    1:         SetHistoryEntry(&mLSHE, mOSHE);
    1:     }
    1: 
    1: 
    1:     /* If the user pressed shift-reload, cache will create a new cache key
    1:      * for the page. Save the new cacheKey in Session History. 
    1:      * see bug 90098
    1:      */
    1:     if (aChannel &&
    1:         (aLoadType == LOAD_RELOAD_BYPASS_CACHE ||
    1:          aLoadType == LOAD_RELOAD_BYPASS_PROXY ||
    1:          aLoadType == LOAD_RELOAD_BYPASS_PROXY_AND_CACHE)) {
    1:         NS_ASSERTION(!updateHistory,
    1:                      "We shouldn't be updating history for forced reloads!");
    1:         
    1:         nsCOMPtr<nsICachingChannel> cacheChannel(do_QueryInterface(aChannel));
    1:         nsCOMPtr<nsISupports>  cacheKey;
    1:         // Get the Cache Key  and store it in SH.         
    1:         if (cacheChannel) 
    1:             cacheChannel->GetCacheKey(getter_AddRefs(cacheKey));
    1:         // If we already have a loading history entry, store the new cache key
    1:         // in it.  Otherwise, since we're doing a reload and won't be updating
    1:         // our history entry, store the cache key in our current history entry.
    1:         if (mLSHE)
    1:             mLSHE->SetCacheKey(cacheKey);
    1:         else if (mOSHE)
    1:             mOSHE->SetCacheKey(cacheKey);
    1:     }
    1: 
    1:     if (updateHistory && shAvailable) { 
    1:         // Update session history if necessary...
    1:         if (!mLSHE && (mItemType == typeContent) && mURIResultedInDocument) {
    1:             /* This is  a fresh page getting loaded for the first time
    1:              *.Create a Entry for it and add it to SH, if this is the
    1:              * rootDocShell
    1:              */
22687:             (void) AddToSessionHistory(aURI, aChannel, aOwner,
22687:                                        getter_AddRefs(mLSHE));
    1:         }
    1: 
    1:         // Update Global history
    1:         if (aAddToGlobalHistory) {
    1:             // Get the referrer uri from the channel
    1:             AddToGlobalHistory(aURI, PR_FALSE, aChannel);
    1:         }
    1:     }
    1: 
    1:     // If this was a history load, update the index in 
    1:     // SH. 
    1:     if (rootSH && (mLoadType & LOAD_CMD_HISTORY)) {
    1:         nsCOMPtr<nsISHistoryInternal> shInternal(do_QueryInterface(rootSH));
    1:         if (shInternal) {
19870:             rootSH->GetIndex(&mPreviousTransIndex);
    1:             shInternal->UpdateIndex();
19870:             rootSH->GetIndex(&mLoadedTransIndex);
19870: #ifdef DEBUG_PAGE_CACHE
19870:             printf("Previous index: %d, Loaded index: %d\n\n",
19870:                    mPreviousTransIndex, mLoadedTransIndex);
19870: #endif
    1:         }
    1:     }
    1:     PRBool onLocationChangeNeeded = SetCurrentURI(aURI, aChannel,
    1:                                                   aFireOnLocationChange);
    1:     // Make sure to store the referrer from the channel, if any
    1:     SetupReferrerFromChannel(aChannel);
    1:     return onLocationChangeNeeded;
    1: }
    1: 
    1: PRBool
    1: nsDocShell::OnLoadingSite(nsIChannel * aChannel, PRBool aFireOnLocationChange,
    1:                           PRBool aAddToGlobalHistory)
    1: {
    1:     nsCOMPtr<nsIURI> uri;
    1:     // If this a redirect, use the final url (uri)
    1:     // else use the original url
    1:     //
    1:     // Note that this should match what documents do (see nsDocument::Reset).
 7109:     NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
    1:     NS_ENSURE_TRUE(uri, PR_FALSE);
    1: 
22687:     return OnNewURI(uri, aChannel, nsnull, mLoadType, aFireOnLocationChange,
    1:                     aAddToGlobalHistory);
    1: 
    1: }
    1: 
    1: void
    1: nsDocShell::SetReferrerURI(nsIURI * aURI)
    1: {
    1:     mReferrerURI = aURI;        // This assigment addrefs
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: Session History
    1: //*****************************************************************************   
    1: PRBool
    1: nsDocShell::ShouldAddToSessionHistory(nsIURI * aURI)
    1: {
    1:     // I believe none of the about: urls should go in the history. But then
    1:     // that could just be me... If the intent is only deny about:blank then we
    1:     // should just do a spec compare, rather than two gets of the scheme and
    1:     // then the path.  -Gagan
    1:     nsresult rv;
    1:     nsCAutoString buf;
    1: 
    1:     rv = aURI->GetScheme(buf);
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
    1:     if (buf.Equals("about")) {
    1:         rv = aURI->GetPath(buf);
    1:         if (NS_FAILED(rv))
    1:             return PR_FALSE;
    1: 
    1:         if (buf.Equals("blank")) {
    1:             return PR_FALSE;
    1:         }
    1:     }
    1:     return PR_TRUE;
    1: }
    1: 
    1: nsresult
22687: nsDocShell::AddToSessionHistory(nsIURI * aURI, nsIChannel * aChannel,
22687:                                 nsISupports* aOwner, nsISHEntry ** aNewEntry)
22687: {
22687:     NS_PRECONDITION(aURI, "uri is null");
22687:     NS_PRECONDITION(!aChannel || !aOwner, "Shouldn't have both set");
22687: 
    1: #if defined(PR_LOGGING) && defined(DEBUG)
    1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         aURI->GetSpec(spec);
    1: 
    1:         nsCAutoString chanName;
    1:         if (aChannel)
    1:             aChannel->GetName(chanName);
    1:         else
    1:             chanName.AssignLiteral("<no channel>");
    1: 
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:                ("nsDocShell[%p]::AddToSessionHistory(\"%s\", [%s])\n", this, spec.get(),
    1:                 chanName.get()));
    1:     }
    1: #endif
    1: 
    1:     nsresult rv = NS_OK;
    1:     nsCOMPtr<nsISHEntry> entry;
    1:     PRBool shouldPersist;
    1: 
    1:     shouldPersist = ShouldAddToSessionHistory(aURI);
    1: 
    1:     // Get a handle to the root docshell 
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1:     GetSameTypeRootTreeItem(getter_AddRefs(root));     
    1:     /*
    1:      * If this is a LOAD_FLAGS_REPLACE_HISTORY in a subframe, we use
    1:      * the existing SH entry in the page and replace the url and
    1:      * other vitalities.
    1:      */
    1:     if (LOAD_TYPE_HAS_FLAGS(mLoadType, LOAD_FLAGS_REPLACE_HISTORY) &&
 3233:         root != static_cast<nsIDocShellTreeItem *>(this)) {
    1:         // This is a subframe 
    1:         entry = mOSHE;
    1:         nsCOMPtr<nsISHContainer> shContainer(do_QueryInterface(entry));
    1:         if (shContainer) {
    1:             PRInt32 childCount = 0;
    1:             shContainer->GetChildCount(&childCount);
    1:             // Remove all children of this entry 
    1:             for (PRInt32 i = childCount - 1; i >= 0; i--) {
    1:                 nsCOMPtr<nsISHEntry> child;
    1:                 shContainer->GetChildAt(i, getter_AddRefs(child));
    1:                 shContainer->RemoveChild(child);
    1:             }  // for
    1:         }  // shContainer
    1:     }
    1: 
    1:     // Create a new entry if necessary.
    1:     if (!entry) {
    1:         entry = do_CreateInstance(NS_SHENTRY_CONTRACTID);
    1: 
    1:         if (!entry) {
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:     }
    1: 
    1:     // Get the post data & referrer
    1:     nsCOMPtr<nsIInputStream> inputStream;
    1:     nsCOMPtr<nsIURI> referrerURI;
    1:     nsCOMPtr<nsISupports> cacheKey;
    1:     nsCOMPtr<nsISupports> cacheToken;
22687:     nsCOMPtr<nsISupports> owner = aOwner;
    1:     PRBool expired = PR_FALSE;
    1:     PRBool discardLayoutState = PR_FALSE;
    1:     if (aChannel) {
    1:         nsCOMPtr<nsICachingChannel>
    1:             cacheChannel(do_QueryInterface(aChannel));
    1:         /* If there is a caching channel, get the Cache Key  and store it 
    1:          * in SH.
    1:          */
    1:         if (cacheChannel) {
    1:             cacheChannel->GetCacheKey(getter_AddRefs(cacheKey));
    1:             cacheChannel->GetCacheToken(getter_AddRefs(cacheToken));
    1:         }
    1:         nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1:         
    1:         // Check if the httpChannel is hiding under a multipartChannel
    1:         if (!httpChannel) {
    1:             GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
    1:         }
    1:         if (httpChannel) {
    1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
    1:             if (uploadChannel) {
    1:                 uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
    1:             }
    1:             httpChannel->GetReferrer(getter_AddRefs(referrerURI));
    1: 
    1:             discardLayoutState = ShouldDiscardLayoutState(httpChannel);
    1:         }
    1:         aChannel->GetOwner(getter_AddRefs(owner));
    1:     }
    1: 
    1:     //Title is set in nsDocShell::SetTitle()
    1:     entry->Create(aURI,              // uri
    1:                   EmptyString(),     // Title
    1:                   inputStream,       // Post data stream
    1:                   nsnull,            // LayoutHistory state
    1:                   cacheKey,          // CacheKey
    1:                   mContentTypeHint,  // Content-type
22687:                   owner);            // Channel or provided owner
    1:     entry->SetReferrerURI(referrerURI);
    1:     /* If cache got a 'no-store', ask SH not to store
    1:      * HistoryLayoutState. By default, SH will set this
    1:      * flag to PR_TRUE and save HistoryLayoutState.
    1:      */    
    1:     if (discardLayoutState) {
    1:         entry->SetSaveLayoutStateFlag(PR_FALSE);
    1:     }
    1:     if (cacheToken) {
    1:         // Check if the page has expired from cache 
    1:         nsCOMPtr<nsICacheEntryInfo> cacheEntryInfo(do_QueryInterface(cacheToken));
    1:         if (cacheEntryInfo) {        
    1:             PRUint32 expTime;         
    1:             cacheEntryInfo->GetExpirationTime(&expTime);         
    1:             PRUint32 now = PRTimeToSeconds(PR_Now());                  
    1:             if (expTime <=  now)            
    1:                 expired = PR_TRUE;         
    1:          
    1:         }
    1:     }
    1:     if (expired == PR_TRUE)
    1:         entry->SetExpirationStatus(PR_TRUE);
    1: 
    1: 
 3233:     if (root == static_cast<nsIDocShellTreeItem *>(this) && mSessionHistory) {
    1:         // This is the root docshell
    1:         if (LOAD_TYPE_HAS_FLAGS(mLoadType, LOAD_FLAGS_REPLACE_HISTORY)) {            
    1:             // Replace current entry in session history.
    1:             PRInt32  index = 0;   
    1:             mSessionHistory->GetIndex(&index);
    1:             nsCOMPtr<nsISHistoryInternal>   shPrivate(do_QueryInterface(mSessionHistory));
    1:             // Replace the current entry with the new entry
    1:             if (shPrivate)
    1:                 rv = shPrivate->ReplaceEntry(index, entry);          
    1:         }
    1:         else {
    1:             // Add to session history
    1:             nsCOMPtr<nsISHistoryInternal>
    1:                 shPrivate(do_QueryInterface(mSessionHistory));
    1:             NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
19870:             mSessionHistory->GetIndex(&mPreviousTransIndex);
    1:             rv = shPrivate->AddEntry(entry, shouldPersist);
19870:             mSessionHistory->GetIndex(&mLoadedTransIndex);
19870: #ifdef DEBUG_PAGE_CACHE
19870:             printf("Previous index: %d, Loaded index: %d\n\n",
19870:                    mPreviousTransIndex, mLoadedTransIndex);
19870: #endif
    1:         }
    1:     }
    1:     else {  
    1:         // This is a subframe.
    1:         if (!mOSHE || !LOAD_TYPE_HAS_FLAGS(mLoadType,
    1:                                            LOAD_FLAGS_REPLACE_HISTORY))
    1:             rv = DoAddChildSHEntry(entry, mChildOffset);
    1:     }
    1: 
    1:     // Return the new SH entry...
    1:     if (aNewEntry) {
    1:         *aNewEntry = nsnull;
    1:         if (NS_SUCCEEDED(rv)) {
    1:             *aNewEntry = entry;
    1:             NS_ADDREF(*aNewEntry);
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::LoadHistoryEntry(nsISHEntry * aEntry, PRUint32 aLoadType)
    1: {
10676:     if (!IsNavigationAllowed()) {
10676:         return NS_OK;
10676:     }
10676:     
    1:     nsCOMPtr<nsIURI> uri;
    1:     nsCOMPtr<nsIInputStream> postData;
    1:     nsCOMPtr<nsIURI> referrerURI;
    1:     nsCAutoString contentType;
    1:     nsCOMPtr<nsISupports> owner;
    1: 
    1:     NS_ENSURE_TRUE(aEntry, NS_ERROR_FAILURE);
    1: 
    1:     NS_ENSURE_SUCCESS(aEntry->GetURI(getter_AddRefs(uri)), NS_ERROR_FAILURE);
    1:     NS_ENSURE_SUCCESS(aEntry->GetReferrerURI(getter_AddRefs(referrerURI)),
    1:                       NS_ERROR_FAILURE);
    1:     NS_ENSURE_SUCCESS(aEntry->GetPostData(getter_AddRefs(postData)),
    1:                       NS_ERROR_FAILURE);
    1:     NS_ENSURE_SUCCESS(aEntry->GetContentType(contentType), NS_ERROR_FAILURE);
    1:     NS_ENSURE_SUCCESS(aEntry->GetOwner(getter_AddRefs(owner)),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     // Calling CreateAboutBlankContentViewer can set mOSHE to null, and if
    1:     // that's the only thing holding a ref to aEntry that will cause aEntry to
    1:     // die while we're loading it.  So hold a strong ref to aEntry here, just
    1:     // in case.
    1:     nsCOMPtr<nsISHEntry> kungFuDeathGrip(aEntry);
    1:     PRBool isJS;
    1:     nsresult rv = uri->SchemeIs("javascript", &isJS);
    1:     if (NS_FAILED(rv) || isJS) {
    1:         // We're loading a URL that will execute script from inside asyncOpen.
    1:         // Replace the current document with about:blank now to prevent
    1:         // anything from the current document from leaking into any JavaScript
    1:         // code in the URL.
 6712:         nsCOMPtr<nsIPrincipal> prin = do_QueryInterface(owner);
27151:         rv = CreateAboutBlankContentViewer(prin, nsnull);
    1: 
    1:         if (NS_FAILED(rv)) {
    1:             // The creation of the intermittent about:blank content
    1:             // viewer failed for some reason (potentially because the
    1:             // user prevented it). Interrupt the history load.
    1:             return NS_OK;
    1:         }
    1: 
    1:         if (!owner) {
    1:             // Ensure that we have an owner.  Otherwise javascript: URIs will
    1:             // pick it up from the about:blank page we just loaded, and we
    1:             // don't really want even that in this case.
    1:             owner = do_CreateInstance("@mozilla.org/nullprincipal;1");
    1:             NS_ENSURE_TRUE(owner, NS_ERROR_OUT_OF_MEMORY);
    1:         }
    1:     }
    1: 
    1:     /* If there is a valid postdata *and* the user pressed
    1:      * reload or shift-reload, take user's permission before we  
    1:      * repost the data to the server.
    1:      */
    1:     if ((aLoadType & LOAD_CMD_RELOAD) && postData) {
    1:       PRBool repost;
    1:       rv = ConfirmRepost(&repost);
    1:       if (NS_FAILED(rv)) return rv;
    1: 
    1:       // If the user pressed cancel in the dialog, return.  We're done here.
    1:       if (!repost)
    1:         return NS_BINDING_ABORTED;
    1:     }
    1: 
    1:     rv = InternalLoad(uri,
    1:                       referrerURI,
    1:                       owner,
    1:                       INTERNAL_LOAD_FLAGS_NONE, // Do not inherit owner from document (security-critical!)
    1:                       nsnull,            // No window target
    1:                       contentType.get(), // Type hint
    1:                       postData,          // Post data stream
    1:                       nsnull,            // No headers stream
    1:                       aLoadType,         // Load type
    1:                       aEntry,            // SHEntry
    1:                       PR_TRUE,
    1:                       nsnull,            // No nsIDocShell
    1:                       nsnull);           // No nsIRequest
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::GetShouldSaveLayoutState(PRBool* aShould)
    1: {
    1:     *aShould = PR_FALSE;
    1:     if (mOSHE) {
    1:         // Don't capture historystate and save it in history
    1:         // if the page asked not to do so.
    1:         mOSHE->GetSaveLayoutStateFlag(aShould);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::PersistLayoutHistoryState()
    1: {
    1:     nsresult  rv = NS_OK;
    1:     
    1:     if (mOSHE) {
    1:         nsCOMPtr<nsIPresShell> shell;
    1:         rv = GetPresShell(getter_AddRefs(shell));
    1:         if (NS_SUCCEEDED(rv) && shell) {
    1:             nsCOMPtr<nsILayoutHistoryState> layoutState;
    1:             rv = shell->CaptureHistoryState(getter_AddRefs(layoutState),
    1:                                             PR_TRUE);
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: /* static */ nsresult
    1: nsDocShell::WalkHistoryEntries(nsISHEntry *aRootEntry,
    1:                                nsDocShell *aRootShell,
    1:                                WalkHistoryEntriesFunc aCallback,
    1:                                void *aData)
    1: {
    1:     NS_ENSURE_TRUE(aRootEntry, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsISHContainer> container(do_QueryInterface(aRootEntry));
    1:     if (!container)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     PRInt32 childCount;
    1:     container->GetChildCount(&childCount);
    1:     for (PRInt32 i = 0; i < childCount; i++) {
    1:         nsCOMPtr<nsISHEntry> childEntry;
    1:         container->GetChildAt(i, getter_AddRefs(childEntry));
    1:         if (!childEntry) {
    1:             // childEntry can be null for valid reasons, for example if the
    1:             // docshell at index i never loaded anything useful.
    1:             continue;
    1:         }
    1: 
    1:         nsDocShell *childShell = nsnull;
    1:         if (aRootShell) {
    1:             // Walk the children of aRootShell and see if one of them
    1:             // has srcChild as a SHEntry.
    1: 
29263:             PRInt32 childCount = aRootShell->mChildList.Count();
29263:             for (PRInt32 j = 0; j < childCount; ++j) {
    1:                 nsDocShell *child =
29263:                     static_cast<nsDocShell*>(aRootShell->ChildAt(j));
    1: 
    1:                 if (child->HasHistoryEntry(childEntry)) {
    1:                     childShell = child;
    1:                     break;
    1:                 }
    1:             }
    1:         }
    1:         nsresult rv = aCallback(childEntry, childShell, i, aData);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: // callback data for WalkHistoryEntries
15594: struct NS_STACK_CLASS CloneAndReplaceData
    1: {
    1:     CloneAndReplaceData(PRUint32 aCloneID, nsISHEntry *aReplaceEntry,
    1:                         nsISHEntry *aDestTreeParent)
    1:         : cloneID(aCloneID),
    1:           replaceEntry(aReplaceEntry),
    1:           destTreeParent(aDestTreeParent) { }
    1: 
    1:     PRUint32              cloneID;
    1:     nsISHEntry           *replaceEntry;
    1:     nsISHEntry           *destTreeParent;
    1:     nsCOMPtr<nsISHEntry>  resultEntry;
    1: };
    1: 
    1: /* static */ nsresult
    1: nsDocShell::CloneAndReplaceChild(nsISHEntry *aEntry, nsDocShell *aShell,
    1:                                  PRInt32 aEntryIndex, void *aData)
    1: {
    1:     nsresult result = NS_OK;
    1:     nsCOMPtr<nsISHEntry> dest;
    1: 
 3233:     CloneAndReplaceData *data = static_cast<CloneAndReplaceData*>(aData);
    1:     PRUint32 cloneID = data->cloneID;
    1:     nsISHEntry *replaceEntry = data->replaceEntry;
    1: 
    1:     PRUint32 srcID;
    1:     aEntry->GetID(&srcID);
    1: 
    1:     if (srcID == cloneID) {
    1:         // Just replace the entry, and don't walk the children.
    1:         dest = replaceEntry;
    1:         dest->SetIsSubFrame(PR_TRUE);
    1:     } else {
    1:         // Clone the SHEntry...
    1:         result = aEntry->Clone(getter_AddRefs(dest));
    1:         if (NS_FAILED(result))
    1:             return result;
    1: 
    1:         // This entry is for a subframe navigation
    1:         dest->SetIsSubFrame(PR_TRUE);
    1: 
    1:         // Walk the children
    1:         CloneAndReplaceData childData(cloneID, replaceEntry, dest);
    1:         result = WalkHistoryEntries(aEntry, aShell,
    1:                                     CloneAndReplaceChild, &childData);
    1:         if (NS_FAILED(result))
    1:             return result;
    1: 
    1:         if (aShell)
    1:             aShell->SwapHistoryEntries(aEntry, dest);
    1:     }
    1: 
    1:     nsCOMPtr<nsISHContainer> container =
    1:         do_QueryInterface(data->destTreeParent);
    1:     if (container)
    1:         container->AddChild(dest, aEntryIndex);
    1: 
    1:     data->resultEntry = dest;
    1:     return result;
    1: }
    1: 
    1: /* static */ nsresult
    1: nsDocShell::CloneAndReplace(nsISHEntry *aSrcEntry,
    1:                                    nsDocShell *aSrcShell,
    1:                                    PRUint32 aCloneID,
    1:                                    nsISHEntry *aReplaceEntry,
    1:                                    nsISHEntry **aResultEntry)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aResultEntry);
    1:     NS_ENSURE_TRUE(aReplaceEntry, NS_ERROR_FAILURE);
    1: 
    1:     CloneAndReplaceData data(aCloneID, aReplaceEntry, nsnull);
    1:     nsresult rv = CloneAndReplaceChild(aSrcEntry, aSrcShell, 0, &data);
    1: 
    1:     data.resultEntry.swap(*aResultEntry);
    1:     return rv;
    1: }
    1: 
    1: 
    1: void
    1: nsDocShell::SwapHistoryEntries(nsISHEntry *aOldEntry, nsISHEntry *aNewEntry)
    1: {
    1:     if (aOldEntry == mOSHE)
    1:         mOSHE = aNewEntry;
    1: 
    1:     if (aOldEntry == mLSHE)
    1:         mLSHE = aNewEntry;
    1: }
    1: 
    1: 
    1: struct SwapEntriesData
    1: {
    1:     nsDocShell *ignoreShell;     // constant; the shell to ignore
    1:     nsISHEntry *destTreeRoot;    // constant; the root of the dest tree
    1:     nsISHEntry *destTreeParent;  // constant; the node under destTreeRoot
    1:                                  // whose children will correspond to aEntry
    1: };
    1: 
    1: 
    1: nsresult
    1: nsDocShell::SetChildHistoryEntry(nsISHEntry *aEntry, nsDocShell *aShell,
    1:                                  PRInt32 aEntryIndex, void *aData)
    1: {
 3233:     SwapEntriesData *data = static_cast<SwapEntriesData*>(aData);
    1:     nsDocShell *ignoreShell = data->ignoreShell;
    1: 
    1:     if (!aShell || aShell == ignoreShell)
    1:         return NS_OK;
    1: 
    1:     nsISHEntry *destTreeRoot = data->destTreeRoot;
    1: 
    1:     nsCOMPtr<nsISHEntry> destEntry;
    1:     nsCOMPtr<nsISHContainer> container =
    1:         do_QueryInterface(data->destTreeParent);
    1: 
    1:     if (container) {
    1:         // aEntry is a clone of some child of destTreeParent, but since the
    1:         // trees aren't necessarily in sync, we'll have to locate it.
    1:         // Note that we could set aShell's entry to null if we don't find a
    1:         // corresponding entry under destTreeParent.
    1: 
    1:         PRUint32 targetID, id;
    1:         aEntry->GetID(&targetID);
    1: 
    1:         // First look at the given index, since this is the common case.
    1:         nsCOMPtr<nsISHEntry> entry;
    1:         container->GetChildAt(aEntryIndex, getter_AddRefs(entry));
    1:         if (entry && NS_SUCCEEDED(entry->GetID(&id)) && id == targetID) {
    1:             destEntry.swap(entry);
    1:         } else {
    1:             PRInt32 childCount;
    1:             container->GetChildCount(&childCount);
    1:             for (PRInt32 i = 0; i < childCount; ++i) {
    1:                 container->GetChildAt(i, getter_AddRefs(entry));
    1:                 if (!entry)
    1:                     continue;
    1: 
    1:                 entry->GetID(&id);
    1:                 if (id == targetID) {
    1:                     destEntry.swap(entry);
    1:                     break;
    1:                 }
    1:             }
    1:         }
    1:     } else {
    1:         destEntry = destTreeRoot;
    1:     }
    1: 
    1:     aShell->SwapHistoryEntries(aEntry, destEntry);
    1: 
    1:     // Now handle the children of aEntry.
    1:     SwapEntriesData childData = { ignoreShell, destTreeRoot, destEntry };
    1:     return WalkHistoryEntries(aEntry, aShell,
    1:                               SetChildHistoryEntry, &childData);
    1: }
    1: 
    1: 
    1: static nsISHEntry*
    1: GetRootSHEntry(nsISHEntry *aEntry)
    1: {
    1:     nsCOMPtr<nsISHEntry> rootEntry = aEntry;
    1:     nsISHEntry *result = nsnull;
    1:     while (rootEntry) {
    1:         result = rootEntry;
    1:         result->GetParent(getter_AddRefs(rootEntry));
    1:     }
    1: 
    1:     return result;
    1: }
    1: 
    1: 
    1: void
    1: nsDocShell::SetHistoryEntry(nsCOMPtr<nsISHEntry> *aPtr, nsISHEntry *aEntry)
    1: {
    1:     // We need to sync up the docshell and session history trees for
    1:     // subframe navigation.  If the load was in a subframe, we forward up to
    1:     // the root docshell, which will then recursively sync up all docshells
    1:     // to their corresponding entries in the new session history tree.
    1:     // If we don't do this, then we can cache a content viewer on the wrong
    1:     // cloned entry, and subsequently restore it at the wrong time.
    1: 
    1:     nsISHEntry *newRootEntry = GetRootSHEntry(aEntry);
    1:     if (newRootEntry) {
    1:         // newRootEntry is now the new root entry.
    1:         // Find the old root entry as well.
    1: 
    1:         // Need a strong ref. on |oldRootEntry| so it isn't destroyed when
    1:         // SetChildHistoryEntry() does SwapHistoryEntries() (bug 304639).
    1:         nsCOMPtr<nsISHEntry> oldRootEntry = GetRootSHEntry(*aPtr);
    1:         if (oldRootEntry) {
    1:             nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
    1:             GetSameTypeParent(getter_AddRefs(parentAsItem));
    1:             nsCOMPtr<nsIDocShell> rootShell = do_QueryInterface(parentAsItem);
    1:             if (rootShell) { // if we're the root just set it, nothing to swap
    1:                 SwapEntriesData data = { this, newRootEntry };
    1:                 nsIDocShell *rootIDocShell =
 3233:                     static_cast<nsIDocShell*>(rootShell);
 3233:                 nsDocShell *rootDocShell = static_cast<nsDocShell*>
 3233:                                                       (rootIDocShell);
    1: 
    1: #ifdef NS_DEBUG
    1:                 nsresult rv =
    1: #endif
    1:                 SetChildHistoryEntry(oldRootEntry, rootDocShell,
    1:                                                    0, &data);
    1:                 NS_ASSERTION(NS_SUCCEEDED(rv), "SetChildHistoryEntry failed");
    1:             }
    1:         }
    1:     }
    1: 
    1:     *aPtr = aEntry;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsDocShell::GetRootSessionHistory(nsISHistory ** aReturn)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1:     //Get the root docshell
    1:     rv = GetSameTypeRootTreeItem(getter_AddRefs(root));
    1:     // QI to nsIWebNavigation
    1:     nsCOMPtr<nsIWebNavigation> rootAsWebnav(do_QueryInterface(root));
    1:     if (rootAsWebnav) {
    1:         // Get the handle to SH from the root docshell
    1:         rv = rootAsWebnav->GetSessionHistory(aReturn);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::GetHttpChannel(nsIChannel * aChannel, nsIHttpChannel ** aReturn)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aReturn);
    1:     if (!aChannel)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsIMultiPartChannel>  multiPartChannel(do_QueryInterface(aChannel));
    1:     if (multiPartChannel) {
    1:         nsCOMPtr<nsIChannel> baseChannel;
    1:         multiPartChannel->GetBaseChannel(getter_AddRefs(baseChannel));
    1:         nsCOMPtr<nsIHttpChannel>  httpChannel(do_QueryInterface(baseChannel));
    1:         *aReturn = httpChannel;
    1:         NS_IF_ADDREF(*aReturn);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: PRBool 
    1: nsDocShell::ShouldDiscardLayoutState(nsIHttpChannel * aChannel)
    1: {    
    1:     // By default layout State will be saved. 
    1:     if (!aChannel)
    1:         return PR_FALSE;
    1: 
    1:     // figure out if SH should be saving layout state 
    1:     nsCOMPtr<nsISupports> securityInfo;
    1:     PRBool noStore = PR_FALSE, noCache = PR_FALSE;
    1:     aChannel->GetSecurityInfo(getter_AddRefs(securityInfo));
    1:     aChannel->IsNoStoreResponse(&noStore);
    1:     aChannel->IsNoCacheResponse(&noCache);
    1: 
    1:     return (noStore || (noCache && securityInfo));
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: nsIEditorDocShell
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsDocShell::GetEditor(nsIEditor * *aEditor)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEditor);
14887: 
14887:   if (!mEditorData) {
14887:     *aEditor = nsnull;
14887:     return NS_OK;
14887:   }
    1: 
    1:   return mEditorData->GetEditor(aEditor);
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::SetEditor(nsIEditor * aEditor)
    1: {
    1:   nsresult rv = EnsureEditorData();
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   return mEditorData->SetEditor(aEditor);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsDocShell::GetEditable(PRBool *aEditable)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEditable);
    1:   *aEditable = mEditorData && mEditorData->GetEditable();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsDocShell::GetHasEditingSession(PRBool *aHasEditingSession)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aHasEditingSession);
    1:   
    1:   if (mEditorData)
    1:   {
    1:     nsCOMPtr<nsIEditingSession> editingSession;
    1:     mEditorData->GetEditingSession(getter_AddRefs(editingSession));
    1:     *aHasEditingSession = (editingSession.get() != nsnull);
    1:   }
    1:   else
    1:   {
    1:     *aHasEditingSession = PR_FALSE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::MakeEditable(PRBool inWaitForUriLoad)
    1: {
    1:   nsresult rv = EnsureEditorData();
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   return mEditorData->MakeEditable(inWaitForUriLoad);
    1: }
    1: 
    1: nsresult
    1: nsDocShell::AddToGlobalHistory(nsIURI * aURI, PRBool aRedirect,
    1:                                nsIChannel * aChannel)
    1: {
    1:     if (mItemType != typeContent || !mGlobalHistory)
    1:         return NS_OK;
    1: 
11255:     // If this is a POST request, we do not want to include this in global
11255:     // history, so return early.
11255:     nsCOMPtr<nsIHttpChannel> hchan(do_QueryInterface(aChannel));
11255:     if (hchan) {
11255:         nsCAutoString type;
11255:         nsresult rv = hchan->GetRequestMethod(type);
11255:         if (NS_SUCCEEDED(rv) && type.EqualsLiteral("POST"))
11255:             return NS_OK;
11255:     }
11255: 
    1:     PRBool visited;
    1:     nsresult rv = mGlobalHistory->IsVisited(aURI, &visited);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCOMPtr<nsIURI> referrer;
 8309:     if (aChannel)
 8309:         NS_GetReferrerFromChannel(aChannel, getter_AddRefs(referrer));
    1: 
    1:     rv = mGlobalHistory->AddURI(aURI, aRedirect, !IsFrame(), referrer);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (!visited) {
    1:         nsCOMPtr<nsIObserverService> obsService =
    1:             do_GetService("@mozilla.org/observer-service;1");
    1:         if (obsService) {
    1:             obsService->NotifyObservers(aURI, NS_LINK_VISITED_EVENT_TOPIC, nsnull);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: Helper Routines
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetLoadType(PRUint32 aLoadType)
    1: {
    1:     mLoadType = aLoadType;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetLoadType(PRUint32 * aLoadType)
    1: {
    1:     *aLoadType = mLoadType;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::ConfirmRepost(PRBool * aRepost)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIPrompt> prompter;
 3233:   CallGetInterface(this, static_cast<nsIPrompt**>(getter_AddRefs(prompter)));
    1: 
    1:   nsCOMPtr<nsIStringBundleService> 
    1:       stringBundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIStringBundle> appBundle;
    1:   rv = stringBundleService->CreateBundle(kAppstringsBundleURL,
    1:                                          getter_AddRefs(appBundle));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIStringBundle> brandBundle;
    1:   rv = stringBundleService->CreateBundle(kBrandBundleURL, getter_AddRefs(brandBundle));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   NS_ASSERTION(prompter && brandBundle && appBundle,
    1:                "Unable to set up repost prompter.");
    1: 
    1:   nsXPIDLString brandName;
    1:   rv = brandBundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
    1:                                       getter_Copies(brandName));
 9886: 
 9886:   nsXPIDLString msgString, button0Title;
 9886:   if (NS_FAILED(rv)) { // No brand, use the generic version.
 9886:     rv = appBundle->GetStringFromName(NS_LITERAL_STRING("confirmRepostPrompt").get(),
 9886:                                       getter_Copies(msgString));
 9886:   }
 9886:   else {
 9886:     // Brand available - if the app has an override file with formatting, the app name will
 9886:     // be included. Without an override, the prompt will look like the generic version.
    1:     const PRUnichar *formatStrings[] = { brandName.get() };
 9886:     rv = appBundle->FormatStringFromName(NS_LITERAL_STRING("confirmRepostPrompt").get(),
    1:                                          formatStrings, NS_ARRAY_LENGTH(formatStrings),
    1:                                          getter_Copies(msgString));
 9886:   }
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = appBundle->GetStringFromName(NS_LITERAL_STRING("resendButton.label").get(),
    1:                                     getter_Copies(button0Title));
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   PRInt32 buttonPressed;
29073:   PRBool checkState;
    1:   rv = prompter->
    1:          ConfirmEx(nsnull, msgString.get(),
    1:                    (nsIPrompt::BUTTON_POS_0 * nsIPrompt::BUTTON_TITLE_IS_STRING) +
    1:                    (nsIPrompt::BUTTON_POS_1 * nsIPrompt::BUTTON_TITLE_CANCEL),
29073:                    button0Title.get(), nsnull, nsnull, nsnull, &checkState, &buttonPressed);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   *aRepost = (buttonPressed == 0);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPromptAndStringBundle(nsIPrompt ** aPrompt,
    1:                                      nsIStringBundle ** aStringBundle)
    1: {
    1:     NS_ENSURE_SUCCESS(GetInterface(NS_GET_IID(nsIPrompt), (void **) aPrompt),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIStringBundleService>
    1:         stringBundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID));
    1:     NS_ENSURE_TRUE(stringBundleService, NS_ERROR_FAILURE);
    1: 
    1:     NS_ENSURE_SUCCESS(stringBundleService->
    1:                       CreateBundle(kAppstringsBundleURL,
    1:                                    aStringBundle),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetChildOffset(nsIDOMNode * aChild, nsIDOMNode * aParent,
    1:                            PRInt32 * aOffset)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChild || aParent);
    1: 
    1:     nsCOMPtr<nsIDOMNodeList> childNodes;
    1:     NS_ENSURE_SUCCESS(aParent->GetChildNodes(getter_AddRefs(childNodes)),
    1:                       NS_ERROR_FAILURE);
    1:     NS_ENSURE_TRUE(childNodes, NS_ERROR_FAILURE);
    1: 
    1:     PRInt32 i = 0;
    1: 
    1:     for (; PR_TRUE; i++) {
    1:         nsCOMPtr<nsIDOMNode> childNode;
    1:         NS_ENSURE_SUCCESS(childNodes->Item(i, getter_AddRefs(childNode)),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_TRUE(childNode, NS_ERROR_FAILURE);
    1: 
    1:         if (childNode.get() == aChild) {
    1:             *aOffset = i;
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetRootScrollableView(nsIScrollableView ** aOutScrollView)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aOutScrollView);
    1: 
    1:     nsCOMPtr<nsIPresShell> shell;
    1:     NS_ENSURE_SUCCESS(GetPresShell(getter_AddRefs(shell)), NS_ERROR_FAILURE);
    1:     NS_ENSURE_TRUE(shell, NS_ERROR_NULL_POINTER);
    1: 
    1:     NS_ENSURE_SUCCESS(shell->GetViewManager()->GetRootScrollableView(aOutScrollView),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     if (*aOutScrollView == nsnull) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
11929: #ifdef DEBUG
11929: class nsDebugAutoBoolTrueSetter
11929: {
11929: public:
28564:     nsDebugAutoBoolTrueSetter(PRPackedBool *aBool)
11929:         : mBool(aBool)
11929:     {
11929:         *mBool = PR_TRUE;
11929:     }
11929: 
11929:     ~nsDebugAutoBoolTrueSetter()
11929:     {
11929:         *mBool = PR_FALSE;
11929:     }
11929: protected:
28564:     PRPackedBool *mBool;
11929: };
11929: #endif
11929: 
    1: NS_IMETHODIMP
    1: nsDocShell::EnsureScriptEnvironment()
    1: {
    1:     if (mScriptGlobal)
    1:         return NS_OK;
    1: 
    1:     if (mIsBeingDestroyed) {
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1: 
 7837: #ifdef DEBUG
 7837:     NS_ASSERTION(!mInEnsureScriptEnv,
 7837:                  "Infinite loop! Calling EnsureScriptEnvironment() from "
 7837:                  "within EnsureScriptEnvironment()!");
 7837: 
 7837:     // Yeah, this isn't re-entrant safe, but that's ok since if we
 7837:     // re-enter this method, we'll infinitely loop...
11929:     nsDebugAutoBoolTrueSetter boolSetter(&mInEnsureScriptEnv);
 7837: #endif
 7837: 
    1:     nsCOMPtr<nsIDOMScriptObjectFactory> factory =
    1:         do_GetService(kDOMScriptObjectFactoryCID);
    1:     NS_ENSURE_TRUE(factory, NS_ERROR_FAILURE);
    1: 
 4422:     nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(mTreeOwner));
36177:     NS_ENSURE_TRUE(browserChrome, NS_ERROR_NOT_AVAILABLE);
 4422: 
 4422:     PRUint32 chromeFlags;
 4422:     browserChrome->GetChromeFlags(&chromeFlags);
 4422: 
 4422:     PRBool isModalContentWindow =
 4422:         (chromeFlags & nsIWebBrowserChrome::CHROME_MODAL) &&
 4422:         !(chromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME);
 4422: 
 4422:     // If our window is modal and we're not opened as chrome, make
 4422:     // this window a modal content window.
    1:     factory->NewScriptGlobalObject(mItemType == typeChrome,
 4422:                                    isModalContentWindow,
    1:                                    getter_AddRefs(mScriptGlobal));
    1:     NS_ENSURE_TRUE(mScriptGlobal, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
 3233:     win->SetDocShell(static_cast<nsIDocShell *>(this));
    1: 
    1:     // Ensure the script object is set to run javascript - other languages
    1:     // setup on demand.
    1:     // XXXmarkh - should this be setup to run the default language for this doc?
    1:     nsresult rv;
    1:     rv = mScriptGlobal->EnsureScriptEnvironment(nsIProgrammingLanguage::JAVASCRIPT);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 7837: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::EnsureEditorData()
    1: {
14887:     PRBool openDocHasDetachedEditor = mOSHE && mOSHE->HasDetachedEditor();
14887:     if (!mEditorData && !mIsBeingDestroyed && !openDocHasDetachedEditor) {
14887:         // We shouldn't recreate the editor data if it already exists, or
14887:         // we're shutting down, or we already have a detached editor data
14887:         // stored in the session history. We should only have one editordata
14887:         // per docshell.
    1:         mEditorData = new nsDocShellEditorData(this);
    1:     }
    1: 
    1:     return mEditorData ? NS_OK : NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::EnsureTransferableHookData()
    1: {
    1:     if (!mTransferableHookData) {
    1:         mTransferableHookData = new nsTransferableHookData();
    1:         if (!mTransferableHookData) return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsDocShell::EnsureFind()
    1: {
    1:     nsresult rv;
    1:     if (!mFind)
    1:     {
    1:         mFind = do_CreateInstance("@mozilla.org/embedcomp/find;1", &rv);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1:     
    1:     // we promise that the nsIWebBrowserFind that we return has been set
    1:     // up to point to the focused, or content window, so we have to
    1:     // set that up each time.
    1: 
    1:     nsIScriptGlobalObject* scriptGO = GetScriptGlobalObject();
    1:     NS_ENSURE_TRUE(scriptGO, NS_ERROR_UNEXPECTED);
    1: 
    1:     // default to our window
29018:     nsCOMPtr<nsIDOMWindow> windowToSearch(do_QueryInterface(mScriptGlobal));
29018: 
29018:     nsCOMPtr<nsIDocShellTreeItem> root;
29018:     GetRootTreeItem(getter_AddRefs(root));
29018: 
29018:     // if the active window is the same window that this docshell is in,
29018:     // use the currently focused frame
29018:     nsCOMPtr<nsIDOMWindow> rootWindow = do_GetInterface(root);
29018:     nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:     if (fm) {
29018:       nsCOMPtr<nsIDOMWindow> activeWindow;
29018:       fm->GetActiveWindow(getter_AddRefs(activeWindow));
29018:       if (activeWindow == rootWindow)
29018:         fm->GetFocusedWindow(getter_AddRefs(windowToSearch));
    1:     }
    1: 
    1:     nsCOMPtr<nsIWebBrowserFindInFrames> findInFrames = do_QueryInterface(mFind);
    1:     if (!findInFrames) return NS_ERROR_NO_INTERFACE;
    1:     
    1:     rv = findInFrames->SetRootSearchFrame(rootWindow);
    1:     if (NS_FAILED(rv)) return rv;
    1:     rv = findInFrames->SetCurrentSearchFrame(windowToSearch);
    1:     if (NS_FAILED(rv)) return rv;
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsDocShell::IsFrame()
    1: {
    1:     nsCOMPtr<nsIDocShellTreeItem> parent =
    1:         do_QueryInterface(GetAsSupports(mParent));
    1:     if (parent) {
    1:         PRInt32 parentType = ~mItemType;        // Not us
    1:         parent->GetItemType(&parentType);
    1:         if (parentType == mItemType)    // This is a frame
    1:             return PR_TRUE;
    1:     }
    1: 
    1:     return PR_FALSE;
    1: }
    1: 
    1: /* boolean IsBeingDestroyed (); */
    1: NS_IMETHODIMP 
    1: nsDocShell::IsBeingDestroyed(PRBool *aDoomed)
    1: {
    1:   NS_ENSURE_ARG(aDoomed);
    1:   *aDoomed = mIsBeingDestroyed;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsDocShell::GetIsExecutingOnLoadHandler(PRBool *aResult)
    1: {
    1:   NS_ENSURE_ARG(aResult);
    1:   *aResult = mIsExecutingOnLoadHandler;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetLayoutHistoryState(nsILayoutHistoryState **aLayoutHistoryState)
    1: {
    1:   if (mOSHE)
    1:     mOSHE->GetLayoutHistoryState(aLayoutHistoryState);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetLayoutHistoryState(nsILayoutHistoryState *aLayoutHistoryState)
    1: {
    1:   if (mOSHE)
    1:     mOSHE->SetLayoutHistoryState(aLayoutHistoryState);
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: //***    nsRefreshTimer: Object Management
    1: //*****************************************************************************
    1: 
    1: nsRefreshTimer::nsRefreshTimer()
    1:     : mDelay(0), mRepeat(PR_FALSE), mMetaRefresh(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsRefreshTimer::~nsRefreshTimer()
    1: {
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsRefreshTimer::nsISupports
    1: //*****************************************************************************   
    1: 
    1: NS_IMPL_THREADSAFE_ADDREF(nsRefreshTimer)
    1: NS_IMPL_THREADSAFE_RELEASE(nsRefreshTimer)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsRefreshTimer)
    1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsITimerCallback)
    1:     NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
    1: NS_INTERFACE_MAP_END_THREADSAFE
    1: 
    1: ///*****************************************************************************
    1: // nsRefreshTimer::nsITimerCallback
    1: //******************************************************************************
    1: NS_IMETHODIMP
    1: nsRefreshTimer::Notify(nsITimer * aTimer)
    1: {
    1:     NS_ASSERTION(mDocShell, "DocShell is somehow null");
    1: 
    1:     if (mDocShell && aTimer) {
    1:         // Get the delay count to determine load type
    1:         PRUint32 delay = 0;
    1:         aTimer->GetDelay(&delay);
18977:         mDocShell->ForceRefreshURIFromTimer(mURI, delay, mMetaRefresh, aTimer);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::InterfaceRequestorProxy
    1: //*****************************************************************************
    1: nsDocShell::InterfaceRequestorProxy::InterfaceRequestorProxy(nsIInterfaceRequestor* p)
    1: {
    1:     if (p) {
    1:         mWeakPtr = do_GetWeakReference(p);
    1:     }
    1: }
    1:  
    1: nsDocShell::InterfaceRequestorProxy::~InterfaceRequestorProxy()
    1: {
    1:     mWeakPtr = nsnull;
    1: }
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsDocShell::InterfaceRequestorProxy, nsIInterfaceRequestor) 
    1:   
    1: NS_IMETHODIMP 
    1: nsDocShell::InterfaceRequestorProxy::GetInterface(const nsIID & aIID, void **aSink)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aSink);
    1:     nsCOMPtr<nsIInterfaceRequestor> ifReq = do_QueryReferent(mWeakPtr);
    1:     if (ifReq) {
    1:         return ifReq->GetInterface(aIID, aSink);
    1:     }
    1:     *aSink = nsnull;
    1:     return NS_NOINTERFACE;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::SetBaseUrlForWyciwyg(nsIContentViewer * aContentViewer)
    1: {
    1:     if (!aContentViewer)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsIURI> baseURI;
    1:     nsCOMPtr<nsIDocument> document;
    1:     nsresult rv = NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     if (sURIFixup)
    1:         rv = sURIFixup->CreateExposableURI(mCurrentURI,
    1:                                            getter_AddRefs(baseURI));
    1: 
    1:     // Get the current document and set the base uri
    1:     if (baseURI) {
    1:         nsCOMPtr<nsIDocumentViewer> docViewer(do_QueryInterface(aContentViewer));
    1:         if (docViewer) {
    1:             rv = docViewer->GetDocument(getter_AddRefs(document));
    1:             if (document)
    1:                 rv = document->SetBaseURI(baseURI);
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIAuthPromptProvider
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetAuthPrompt(PRUint32 aPromptReason, const nsIID& iid,
    1:                           void** aResult)
    1: {
    1:     // a priority prompt request will override a false mAllowAuth setting
    1:     PRBool priorityPrompt = (aPromptReason == PROMPT_PROXY);
    1: 
    1:     if (!mAllowAuth && !priorityPrompt)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // we're either allowing auth, or it's a proxy request
    1:     nsresult rv;
    1:     nsCOMPtr<nsIPromptFactory> wwatch =
    1:       do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = EnsureScriptEnvironment();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIDOMWindow> window(do_QueryInterface(mScriptGlobal));
    1: 
    1:     // Get the an auth prompter for our window so that the parenting
    1:     // of the dialogs works as it should when using tabs.
    1: 
    1:     return wwatch->GetPrompt(window, iid,
 3233:                              reinterpret_cast<void**>(aResult));
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIObserver
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Observe(nsISupports *aSubject, const char *aTopic,
    1:                     const PRUnichar *aData)
    1: {
    1:     nsresult rv = NS_OK;
    1:     if (mObserveErrorPages &&
    1:         !nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) &&
    1:         !nsCRT::strcmp(aData,
    1:           NS_LITERAL_STRING("browser.xul.error_pages.enabled").get())) {
    1: 
    1:         nsCOMPtr<nsIPrefBranch> prefs(do_QueryInterface(aSubject, &rv));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         PRBool tmpbool;
    1:         rv = prefs->GetBoolPref("browser.xul.error_pages.enabled", &tmpbool);
    1:         if (NS_SUCCEEDED(rv))
    1:             mUseErrorPages = tmpbool;
    1: 
    1:     } else {
    1:         rv = NS_ERROR_UNEXPECTED;
    1:     }
    1:     return rv;
    1: }
    1: 
21877: //*****************************************************************************
21877: // nsDocShell::nsILoadContext
21877: //*****************************************************************************
21877: NS_IMETHODIMP
21877: nsDocShell::GetAssociatedWindow(nsIDOMWindow** aWindow)
21877: {
21877:     return CallGetInterface(this, aWindow);
21877: }
21877: 
21877: NS_IMETHODIMP
21877: nsDocShell::GetTopWindow(nsIDOMWindow** aWindow)
21877: {
21877:     nsresult rv;
21877:     nsCOMPtr<nsIDOMWindow> win = do_GetInterface(GetAsSupports(this), &rv);
21877:     NS_ENSURE_SUCCESS(rv, rv);
21877:     return win->GetTop(aWindow);
21877: }
21877: 
21877: NS_IMETHODIMP
21877: nsDocShell::IsAppOfType(PRUint32 aAppType, PRBool *aIsOfType)
21877: {
21877:     nsCOMPtr<nsIDocShell> shell = this;
21877:     while (shell) {
21877:         PRUint32 type;
21877:         shell->GetAppType(&type);
21877:         if (type == aAppType) {
21877:             *aIsOfType = PR_TRUE;
21877:             return NS_OK;
21877:         }
21877:         nsCOMPtr<nsIDocShellTreeItem> item = do_QueryInterface(shell);
21877:         nsCOMPtr<nsIDocShellTreeItem> parent;
21877:         item->GetParent(getter_AddRefs(parent));
21877:         shell = do_QueryInterface(parent);
21877:     }
21877: 
21877:     *aIsOfType = PR_FALSE;
21877:     return NS_OK;
21877: }
21877: 
21877: NS_IMETHODIMP
21877: nsDocShell::GetIsContent(PRBool *aIsContent)
21877: {
21877:     *aIsContent = (mItemType == typeContent);
21877:     return NS_OK;
21877: }
21877: 
    1: /* static */
    1: nsresult
    1: nsDocShell::URIInheritsSecurityContext(nsIURI* aURI, PRBool* aResult)
    1: {
    1:     // Note: about:blank URIs do NOT inherit the security context from the
    1:     // current document, which is what this function tests for...
    1:     return NS_URIChainHasFlags(aURI,
    1:                                nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
    1:                                aResult);
    1: }
    1: 
    1: /* static */
    1: PRBool
13414: nsDocShell::URIIsLocalFile(nsIURI *aURI)
13414: {
13414:     PRBool isFile;
13414:     nsCOMPtr<nsINetUtil> util = do_GetIOService();
13414: 
13414:     return util && NS_SUCCEEDED(util->ProtocolHasFlags(aURI,
13414:                                     nsIProtocolHandler::URI_IS_LOCAL_FILE,
13414:                                     &isFile)) &&
13414:            isFile;
13414: }
13414: 
13414: /* static */
13414: PRBool
    1: nsDocShell::IsAboutBlank(nsIURI* aURI)
    1: {
    1:     NS_PRECONDITION(aURI, "Must have URI");
    1:     
    1:     // GetSpec can be expensive for some URIs, so check the scheme first.
    1:     PRBool isAbout = PR_FALSE;
    1:     if (NS_FAILED(aURI->SchemeIs("about", &isAbout)) || !isAbout) {
    1:         return PR_FALSE;
    1:     }
    1:     
    1:     nsCAutoString str;
    1:     aURI->GetSpec(str);
    1:     return str.EqualsLiteral("about:blank");
    1: }
    1: 
10676: PRBool
10676: nsDocShell::IsOKToLoadURI(nsIURI* aURI)
10676: {
10676:     NS_PRECONDITION(aURI, "Must have a URI!");
10676:     
10676:     if (!mFiredUnloadEvent) {
10676:         return PR_TRUE;
10676:     }
10676: 
10676:     if (!mLoadingURI) {
10676:         return PR_FALSE;
10676:     }
10676: 
10676:     nsCOMPtr<nsIScriptSecurityManager> secMan =
10676:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
10676:     return
10676:         secMan &&
10676:         NS_SUCCEEDED(secMan->CheckSameOriginURI(aURI, mLoadingURI, PR_FALSE));
10676: }
10676: 
 5528: //*****************************************************************************
 5528: // nsClassifierCallback
 5528: //*****************************************************************************
 5528: 
23790: NS_IMPL_ISUPPORTS5(nsClassifierCallback,
12968:                    nsIChannelClassifier,
 5528:                    nsIURIClassifierCallback,
23790:                    nsIRunnable,
23790:                    nsIChannelEventSink,
23790:                    nsIInterfaceRequestor)
 5528: 
 5528: NS_IMETHODIMP
 5528: nsClassifierCallback::Run()
 5528: {
 5528:     if (!mChannel) {
 5528:         return NS_OK;
 5528:     }
 5528: 
 5528:     NS_ASSERTION(!mSuspendedChannel,
 5528:                  "nsClassifierCallback::Run() called while a "
 5528:                  "channel is still suspended.");
 5528: 
 5528:     nsCOMPtr<nsIChannel> channel;
 5528:     channel.swap(mChannel);
 5528: 
 5528:     // Don't bother to run the classifier on a load that has already failed.
 5528:     // (this might happen after a redirect)
 5528:     PRUint32 status;
 5528:     channel->GetStatus(&status);
 5528:     if (NS_FAILED(status))
 5528:         return NS_OK;
 5528: 
10966:     // Don't bother to run the classifier on a cached load that was
10966:     // previously classified.
23790:     if (HasBeenClassified(channel)) {
10966:         return NS_OK;
 5528:     }
 5528: 
 5528:     nsCOMPtr<nsIURI> uri;
 5528:     nsresult rv = channel->GetURI(getter_AddRefs(uri));
 5528:     NS_ENSURE_SUCCESS(rv, rv);
 5528: 
 8380:     // Don't bother checking certain types of URIs.
 8380:     PRBool hasFlags;
 8380:     rv = NS_URIChainHasFlags(uri,
 8380:                              nsIProtocolHandler::URI_DANGEROUS_TO_LOAD,
 8380:                              &hasFlags);
 8380:     NS_ENSURE_SUCCESS(rv, rv);
 8380:     if (hasFlags) return NS_OK;
 8380: 
 8380:     rv = NS_URIChainHasFlags(uri,
 8380:                              nsIProtocolHandler::URI_IS_LOCAL_FILE,
 8380:                              &hasFlags);
 8380:     NS_ENSURE_SUCCESS(rv, rv);
 8380:     if (hasFlags) return NS_OK;
 8380: 
 8380:     rv = NS_URIChainHasFlags(uri,
 8380:                              nsIProtocolHandler::URI_IS_UI_RESOURCE,
 8380:                              &hasFlags);
 8380:     NS_ENSURE_SUCCESS(rv, rv);
 8380:     if (hasFlags) return NS_OK;
 5528: 
22559:     rv = NS_URIChainHasFlags(uri,
22559:                              nsIProtocolHandler::URI_IS_LOCAL_RESOURCE,
22559:                              &hasFlags);
22559:     NS_ENSURE_SUCCESS(rv, rv);
22559:     if (hasFlags) return NS_OK;
22559: 
 5528:     nsCOMPtr<nsIURIClassifier> uriClassifier =
 5528:         do_GetService(NS_URICLASSIFIERSERVICE_CONTRACTID, &rv);
23832:     if (rv == NS_ERROR_FACTORY_NOT_REGISTERED ||
23832:         rv == NS_ERROR_NOT_AVAILABLE) {
23832:         // no URI classifier, ignore this failure.
23832:         return NS_OK;
23832:     }
23832:     NS_ENSURE_SUCCESS(rv, rv);
 5528: 
 5528:     PRBool expectCallback;
 5528:     rv = uriClassifier->Classify(uri, this, &expectCallback);
 5528:     if (NS_FAILED(rv)) return rv;
 5528: 
 5528:     if (expectCallback) {
 5528:         // Suspend the channel, it will be resumed when we get the classifier
 5528:         // callback.
 5528:         rv = channel->Suspend();
 8380:         if (NS_FAILED(rv)) {
 8380:             // Some channels (including nsJSChannel) fail on Suspend.  This
 8380:             // shouldn't be fatal, but will prevent malware from being
 8380:             // blocked on these channels.
 8380:             return NS_OK;
 8380:         }
 8380: 
 5528:         mSuspendedChannel = channel;
 5530: #ifdef DEBUG
 5528:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
 5528:                ("nsClassifierCallback[%p]: suspended channel %p",
 5528:                 this, mSuspendedChannel.get()));
 5529: #endif
 5528:     }
 5528: 
 5528:     return NS_OK;
 5528: }
 5528: 
10966: // Note in the cache entry that this URL was classified, so that future
10966: // cached loads don't need to be checked.
10966: void
10966: nsClassifierCallback::MarkEntryClassified(nsresult status)
10966: {
10966:     nsCOMPtr<nsICachingChannel> cachingChannel =
10966:         do_QueryInterface(mSuspendedChannel);
10966:     if (!cachingChannel) {
10966:         return;
10966:     }
10966: 
10966:     nsCOMPtr<nsISupports> cacheToken;
10966:     cachingChannel->GetCacheToken(getter_AddRefs(cacheToken));
10966:     if (!cacheToken) {
10966:         return;
10966:     }
10966: 
10966:     nsCOMPtr<nsICacheEntryDescriptor> cacheEntry =
10966:         do_QueryInterface(cacheToken);
10966:     if (!cacheEntry) {
10966:         return;
10966:     }
10966: 
10966:     cacheEntry->SetMetaDataElement("docshell:classified",
10966:                                    NS_SUCCEEDED(status) ? "1" : nsnull);
10966: }
10966: 
10966: PRBool
23790: nsClassifierCallback::HasBeenClassified(nsIChannel *aChannel)
10966: {
10966:     nsCOMPtr<nsICachingChannel> cachingChannel =
23790:         do_QueryInterface(aChannel);
10966:     if (!cachingChannel) {
10966:         return PR_FALSE;
10966:     }
10966: 
10966:     // Only check the tag if we are loading from the cache without
10966:     // validation.
10966:     PRBool fromCache;
10966:     if (NS_FAILED(cachingChannel->IsFromCache(&fromCache)) || !fromCache) {
10966:         return PR_FALSE;
10966:     }
10966: 
10966:     nsCOMPtr<nsISupports> cacheToken;
10966:     cachingChannel->GetCacheToken(getter_AddRefs(cacheToken));
10966:     if (!cacheToken) {
10966:         return PR_FALSE;
10966:     }
10966: 
10966:     nsCOMPtr<nsICacheEntryDescriptor> cacheEntry =
10966:         do_QueryInterface(cacheToken);
10966:     if (!cacheEntry) {
10966:         return PR_FALSE;
10966:     }
10966: 
10966:     nsXPIDLCString tag;
10966:     cacheEntry->GetMetaDataElement("docshell:classified", getter_Copies(tag));
10966:     return tag.EqualsLiteral("1");
10966: }
10966: 
 5528: NS_IMETHODIMP
 5528: nsClassifierCallback::OnClassifyComplete(nsresult aErrorCode)
 5528: {
 5528:     if (mSuspendedChannel) {
10966:         MarkEntryClassified(aErrorCode);
10966: 
 5528:         if (NS_FAILED(aErrorCode)) {
 5530: #ifdef DEBUG
 5528:             PR_LOG(gDocShellLog, PR_LOG_DEBUG,
 5528:                    ("nsClassifierCallback[%p]: cancelling channel %p with error code: %d",
 5528:                     this, mSuspendedChannel.get(), aErrorCode));
 5530: #endif
 5528:             mSuspendedChannel->Cancel(aErrorCode);
 5530:         }
 5530: #ifdef DEBUG
 5528:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
 5528:                ("nsClassifierCallback[%p]: resuming channel %p from OnClassifyComplete",
 5528:                 this, mSuspendedChannel.get()));
 5529: #endif
 5528:         mSuspendedChannel->Resume();
 5528:         mSuspendedChannel = nsnull;
 5528:     }
 5528: 
 5528:     return NS_OK;
 5528: }
 5528: 
12968: NS_IMETHODIMP
23790: nsClassifierCallback::Start(nsIChannel *aChannel, PRBool aInstallListener)
12968: {
12968:     mChannel = aChannel;
23790: 
23790:     if (aInstallListener) {
23790:         nsresult rv = aChannel->GetNotificationCallbacks
23790:             (getter_AddRefs(mNotificationCallbacks));
23790:         NS_ENSURE_SUCCESS(rv, rv);
23790: 
23790:         rv = aChannel->SetNotificationCallbacks
23790:             (static_cast<nsIInterfaceRequestor*>(this));
23790:         NS_ENSURE_SUCCESS(rv, rv);
23790:     }
23790: 
12968:     return Run();
12968: }
12968: 
12968: NS_IMETHODIMP
12968: nsClassifierCallback::OnRedirect(nsIChannel *aOldChannel,
12968:                                  nsIChannel *aNewChannel)
12968: {
12968:     mChannel = aNewChannel;
12968: 
12968:     // we call the Run() from the main loop to give the channel a
12968:     // chance to AsyncOpen() before we suspend it.
12968:     NS_DispatchToCurrentThread(this);
12968: 
12968:     return NS_OK;
12968: }
12968: 
12968: NS_IMETHODIMP
 5528: nsClassifierCallback::Cancel()
 5528: {
 5528:     if (mSuspendedChannel) {
 5530: #ifdef DEBUG
 5528:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
 5528:                ("nsClassifierCallback[%p]: resuming channel %p from Cancel()",
 5528:                 this, mSuspendedChannel.get()));
 5529: #endif
 5528:         mSuspendedChannel->Resume();
 5528:         mSuspendedChannel = nsnull;
 5528:     }
 5528: 
 5528:     if (mChannel) {
 5528:         mChannel = nsnull;
 5528:     }
12968: 
12968:     return NS_OK;
12968: }
23790: 
23790: NS_IMETHODIMP
23790: nsClassifierCallback::OnChannelRedirect(nsIChannel *aOldChannel,
23790:                                         nsIChannel *aNewChannel,
23790:                                         PRUint32 aFlags)
23790: {
23790:     nsresult rv = OnRedirect(aOldChannel, aNewChannel);
23790:     NS_ENSURE_SUCCESS(rv, rv);
23790: 
23790:     if (mNotificationCallbacks) {
23790:         nsCOMPtr<nsIChannelEventSink> sink =
23790:             do_GetInterface(mNotificationCallbacks);
23790:         if (sink) {
23790:             return sink->OnChannelRedirect(aOldChannel, aNewChannel, aFlags);
23790:         }
23790:     }
23790: 
23790:     return NS_OK;
23790: }
23790: 
23790: NS_IMETHODIMP
23790: nsClassifierCallback::GetInterface(const nsIID &aIID, void **aResult)
23790: {
23790:     if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
23790:         NS_ADDREF_THIS();
23790:         *aResult = static_cast<nsIChannelEventSink *>(this);
23790:         return NS_OK;
23790:     } else if (mNotificationCallbacks) {
23790:         return mNotificationCallbacks->GetInterface(aIID, aResult);
23790:     } else {
23790:         return NS_ERROR_NO_INTERFACE;
23790:     }
23790: }
28078: 
28078: //
28078: // Routines for selection and clipboard
28078: //
28078: nsresult
28078: nsDocShell::GetControllerForCommand(const char * inCommand,
28078:                                     nsIController** outController)
28078: {
28078:   NS_ENSURE_ARG_POINTER(outController);
28078:   *outController = nsnull;
28078:   
28078:   nsresult rv = NS_ERROR_FAILURE;
28078:   
28078:   nsCOMPtr<nsPIDOMWindow> window ( do_QueryInterface(mScriptGlobal) );
28078:   if (window) {
28078:     nsIFocusController *focusController = window->GetRootFocusController();
28078:     if (focusController)
32922:       rv = focusController->GetControllerForCommand (window, inCommand, outController);
28078:   } // if window
28078: 
28078:   return rv;
28078:   
28078: }
28078: 
28078: nsresult
28078: nsDocShell::IsCommandEnabled(const char * inCommand, PRBool* outEnabled)
28078: {
28078:   NS_ENSURE_ARG_POINTER(outEnabled);
28078:   *outEnabled = PR_FALSE;
28078: 
28078:   nsresult rv = NS_ERROR_FAILURE;
28078:   
28078:   nsCOMPtr<nsIController> controller;
28078:   rv = GetControllerForCommand (inCommand, getter_AddRefs(controller));
28078:   if (controller)
28078:     rv = controller->IsCommandEnabled(inCommand, outEnabled);
28078:   
28078:   return rv;
28078: }
28078: 
28078: nsresult
28078: nsDocShell::DoCommand(const char * inCommand)
28078: {
28078:   nsresult rv = NS_ERROR_FAILURE;
28078:   
28078:   nsCOMPtr<nsIController> controller;
28078:   rv = GetControllerForCommand(inCommand, getter_AddRefs(controller));
28078:   if (controller)
28078:     rv = controller->DoCommand(inCommand);
28078:   
28078:   return rv;
28078: }
28078: 
28078: nsresult
28078: nsDocShell::EnsureCommandHandler()
28078: {
28078:   if (!mCommandManager)
28078:   {
28078:     nsCOMPtr<nsPICommandUpdater> commandUpdater =
28078:       do_CreateInstance("@mozilla.org/embedcomp/command-manager;1");
28078:     if (!commandUpdater) return NS_ERROR_OUT_OF_MEMORY;
28078:     
28078:     nsCOMPtr<nsIDOMWindow> domWindow =
28078:       do_GetInterface(static_cast<nsIInterfaceRequestor *>(this));
28078: 
28078:     nsresult rv = commandUpdater->Init(domWindow);
28078:     if (NS_SUCCEEDED(rv))
28078:       mCommandManager = do_QueryInterface(commandUpdater);
28078:   }
28078:   
28078:   return mCommandManager ? NS_OK : NS_ERROR_FAILURE;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CanCutSelection(PRBool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_cut", aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CanCopySelection(PRBool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_copy", aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CanCopyLinkLocation(PRBool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_copyLink", aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CanCopyImageLocation(PRBool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_copyImageLocation",
28078:                           aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CanCopyImageContents(PRBool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_copyImageContents",
28078:                           aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CanPaste(PRBool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_paste", aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CutSelection(void)
28078: {
28078:   return DoCommand ( "cmd_cut" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CopySelection(void)
28078: {
28078:   return DoCommand ( "cmd_copy" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CopyLinkLocation(void)
28078: {
28078:   return DoCommand ( "cmd_copyLink" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CopyImageLocation(void)
28078: {
28078:   return DoCommand ( "cmd_copyImageLocation" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CopyImageContents(void)
28078: {
28078:   return DoCommand ( "cmd_copyImageContents" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::Paste(void)
28078: {
28078:   return DoCommand ( "cmd_paste" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::SelectAll(void)
28078: {
28078:   return DoCommand ( "cmd_selectAll" );
28078: }
28078: 
28078: //
28078: // SelectNone
28078: //
28078: // Collapses the current selection, insertion point ends up at beginning
28078: // of previous selection.
28078: //
28078: NS_IMETHODIMP
28078: nsDocShell::SelectNone(void)
28078: {
28078:   return DoCommand ( "cmd_selectNone" );
28078: }
28078: 
28078: //----------------------------------------------------------------------
28078: 
28078: // link handling
28078: 
28078: class OnLinkClickEvent : public nsRunnable {
28078: public:
28078:   OnLinkClickEvent(nsDocShell* aHandler, nsIContent* aContent,
28078:                    nsIURI* aURI,
28078:                    const PRUnichar* aTargetSpec,
28078:                    nsIInputStream* aPostDataStream = 0, 
28078:                    nsIInputStream* aHeadersDataStream = 0);
28078: 
28078:   NS_IMETHOD Run() {
28078:     nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(mHandler->mScriptGlobal));
28078:     nsAutoPopupStatePusher popupStatePusher(window, mPopupState);
28078: 
28078:     mHandler->OnLinkClickSync(mContent, mURI,
28078:                               mTargetSpec.get(), mPostDataStream,
28078:                               mHeadersDataStream,
28078:                               nsnull, nsnull);
28078:     return NS_OK;
28078:   }
28078: 
28078: private:
28078:   nsRefPtr<nsDocShell>     mHandler;
28078:   nsCOMPtr<nsIURI>         mURI;
28078:   nsString                 mTargetSpec;
28078:   nsCOMPtr<nsIInputStream> mPostDataStream;
28078:   nsCOMPtr<nsIInputStream> mHeadersDataStream;
28078:   nsCOMPtr<nsIContent>     mContent;
28078:   PopupControlState        mPopupState;
28078: };
28078: 
28078: OnLinkClickEvent::OnLinkClickEvent(nsDocShell* aHandler,
28078:                                    nsIContent *aContent,
28078:                                    nsIURI* aURI,
28078:                                    const PRUnichar* aTargetSpec,
28078:                                    nsIInputStream* aPostDataStream,
28078:                                    nsIInputStream* aHeadersDataStream)
28078:   : mHandler(aHandler)
28078:   , mURI(aURI)
28078:   , mTargetSpec(aTargetSpec)
28078:   , mPostDataStream(aPostDataStream)
28078:   , mHeadersDataStream(aHeadersDataStream)
28078:   , mContent(aContent)
28078: {
28078:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(mHandler->mScriptGlobal));
28078: 
28078:   mPopupState = window->GetPopupControlState();
28078: }
28078: 
28078: //----------------------------------------
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::OnLinkClick(nsIContent* aContent,
28078:                         nsIURI* aURI,
28078:                         const PRUnichar* aTargetSpec,
28078:                         nsIInputStream* aPostDataStream,
28078:                         nsIInputStream* aHeadersDataStream)
28078: {
28078:   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
28078: 
28078:   if (!IsOKToLoadURI(aURI)) {
28078:     return NS_OK;
28078:   }
28078: 
28078:   if (aContent->IsEditable()) {
28078:     return NS_OK;
28078:   }
28078: 
28078:   nsCOMPtr<nsIRunnable> ev =
28078:       new OnLinkClickEvent(this, aContent, aURI, aTargetSpec,
28078:                            aPostDataStream, aHeadersDataStream);
28078:   return NS_DispatchToCurrentThread(ev);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::OnLinkClickSync(nsIContent *aContent,
28078:                             nsIURI* aURI,
28078:                             const PRUnichar* aTargetSpec,
28078:                             nsIInputStream* aPostDataStream,
28078:                             nsIInputStream* aHeadersDataStream,
28078:                             nsIDocShell** aDocShell,
28078:                             nsIRequest** aRequest)
28078: {
28078:   // Initialize the DocShell / Request
28078:   if (aDocShell) {
28078:     *aDocShell = nsnull;
28078:   }
28078:   if (aRequest) {
28078:     *aRequest = nsnull;
28078:   }
28078: 
28078:   if (!IsOKToLoadURI(aURI)) {
28078:     return NS_OK;
28078:   }
28078: 
28078:   if (aContent->IsEditable()) {
28078:     return NS_OK;
28078:   }
28078: 
28078:   {
28078:     // defer to an external protocol handler if necessary...
28078:     nsCOMPtr<nsIExternalProtocolService> extProtService =
28078:         do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID);
28078:     if (extProtService) {
28078:       nsCAutoString scheme;
28078:       aURI->GetScheme(scheme);
28078:       if (!scheme.IsEmpty()) {
28078:         // if the URL scheme does not correspond to an exposed protocol, then we
28078:         // need to hand this link click over to the external protocol handler.
28078:         PRBool isExposed;
28078:         nsresult rv = extProtService->IsExposedProtocol(scheme.get(), &isExposed);
28078:         if (NS_SUCCEEDED(rv) && !isExposed) {
28078:           return extProtService->LoadURI(aURI, this); 
28078:         }
28078:       }
28078:     }
28078:   }
28078: 
28078:   // Get the owner document of the link that was clicked, this will be
28078:   // the document that the link is in, or the last document that the
28078:   // link was in. From that document, we'll get the URI to use as the
28078:   // referer, since the current URI in this docshell may be a
28078:   // new document that we're in the process of loading.
28078:   nsCOMPtr<nsIDocument> refererDoc = aContent->GetOwnerDoc();
28078:   NS_ENSURE_TRUE(refererDoc, NS_ERROR_UNEXPECTED);
28078: 
28078:   nsCOMPtr<nsIURI> referer = refererDoc->GetDocumentURI();
28078: 
28078:   // referer could be null here in some odd cases, but that's ok,
28078:   // we'll just load the link w/o sending a referer in those cases.
28078: 
28078:   nsAutoString target(aTargetSpec);
28078: 
28078:   // If this is an anchor element, grab its type property to use as a hint
28078:   nsAutoString typeHint;
28078:   nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(aContent));
28078:   if (anchor) {
28078:     anchor->GetType(typeHint);
28078:   }
28078:   
28078:   nsresult rv = InternalLoad(aURI,                      // New URI
28078:                              referer,                   // Referer URI
28078:                              aContent->NodePrincipal(), // Owner is our node's
28078:                                                         // principal
28078:                              INTERNAL_LOAD_FLAGS_NONE,
28078:                              target.get(),              // Window target
28078:                              NS_LossyConvertUTF16toASCII(typeHint).get(),
28078:                              aPostDataStream,           // Post data stream
28078:                              aHeadersDataStream,        // Headers stream
28078:                              LOAD_LINK,                 // Load type
28078:                              nsnull,                    // No SHEntry
28078:                              PR_TRUE,                   // first party site
28078:                              aDocShell,                 // DocShell out-param
28078:                              aRequest);                 // Request out-param
28078:   if (NS_SUCCEEDED(rv)) {
28078:     DispatchPings(aContent, referer);
28078:   }
28078:   return rv;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::OnOverLink(nsIContent* aContent,
28078:                        nsIURI* aURI,
28078:                        const PRUnichar* aTargetSpec)
28078: {
28078:   if (aContent->IsEditable()) {
28078:     return NS_OK;
28078:   }
28078: 
28078:   nsCOMPtr<nsIWebBrowserChrome2> browserChrome2 = do_GetInterface(mTreeOwner);
28078:   nsresult rv = NS_ERROR_FAILURE;
28078: 
28078:   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
28078:   if (!browserChrome2) {
28078:     browserChrome = do_GetInterface(mTreeOwner);
28078:     if (!browserChrome)
28078:       return rv;
28078:   }
28078: 
28078:   nsCOMPtr<nsITextToSubURI> textToSubURI =
28078:       do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
28078:   if (NS_FAILED(rv))
28078:     return rv;
28078: 
28078:   // use url origin charset to unescape the URL
28078:   nsCAutoString charset;
28078:   rv = aURI->GetOriginCharset(charset);
28078:   NS_ENSURE_SUCCESS(rv, rv);
28078: 
28078:   nsCAutoString spec;
28078:   rv = aURI->GetSpec(spec);
28078:   NS_ENSURE_SUCCESS(rv, rv);
28078: 
28078:   nsAutoString uStr;
28078:   rv = textToSubURI->UnEscapeURIForUI(charset, spec, uStr);    
28078:   NS_ENSURE_SUCCESS(rv, rv);
28078: 
28078:   if (browserChrome2) {
28078:     nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aContent);
28078:     rv = browserChrome2->SetStatusWithContext(nsIWebBrowserChrome::STATUS_LINK,
28078:                                               uStr, element);
28078:   } else {
28078:     rv = browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_LINK, uStr.get());
28078:   }
28078:   return rv;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::OnLeaveLink()
28078: {
28078:   nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(mTreeOwner));
28078:   nsresult rv = NS_ERROR_FAILURE;
28078: 
28078:   if (browserChrome)  {
28078:       rv = browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_LINK,
28078:                                     EmptyString().get());
28078:   }
28078:   return rv;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::GetLinkState(nsIURI* aLinkURI, nsLinkState& aState)
28078: {
28078:   if (!aLinkURI) {
28078:     // No uri means not a link
28078:     aState = eLinkState_NotLink;
28078:     return NS_OK;
28078:   }
28078:     
28078:   aState = eLinkState_Unvisited;
28078: 
28078:   // no history, leave state unchanged
28078:   if (!mGlobalHistory)
28078:     return NS_OK;
28078: 
28078:   PRBool isVisited;
28078:   NS_ENSURE_SUCCESS(mGlobalHistory->IsVisited(aLinkURI, &isVisited),
28078:                     NS_ERROR_FAILURE);
28078:   if (isVisited)
28078:     aState = eLinkState_Visited;
28078:   
28078:   return NS_OK;
28078: }
28078: 
28078: //----------------------------------------------------------------------
28078: // Web Shell Services API
28078: 
28078: //This functions is only called when a new charset is detected in loading a document. 
28078: //Its name should be changed to "CharsetReloadDocument"
28078: NS_IMETHODIMP
28078: nsDocShell::ReloadDocument(const char* aCharset,
28078:                            PRInt32 aSource)
28078: {
28078: 
28078:   // XXX hack. kee the aCharset and aSource wait to pick it up
28078:   nsCOMPtr<nsIContentViewer> cv;
28078:   NS_ENSURE_SUCCESS(GetContentViewer(getter_AddRefs(cv)), NS_ERROR_FAILURE);
28078:   if (cv)
28078:   {
28078:     nsCOMPtr<nsIMarkupDocumentViewer> muDV = do_QueryInterface(cv);  
28078:     if (muDV)
28078:     {
28078:       PRInt32 hint;
28078:       muDV->GetHintCharacterSetSource(&hint);
28078:       if( aSource > hint ) 
28078:       {
28078:          muDV->SetHintCharacterSet(nsDependentCString(aCharset));
28078:          muDV->SetHintCharacterSetSource(aSource);
28078:          if(eCharsetReloadRequested != mCharsetReloadState) 
28078:          {
28078:             mCharsetReloadState = eCharsetReloadRequested;
28078:             return Reload(LOAD_FLAGS_CHARSET_CHANGE);
28078:          }
28078:       }
28078:     }
28078:   }
28078:   //return failer if this request is not accepted due to mCharsetReloadState
28078:   return NS_ERROR_DOCSHELL_REQUEST_REJECTED;
28078: }
28078: 
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::StopDocumentLoad(void)
28078: {
28078:   if(eCharsetReloadRequested != mCharsetReloadState) 
28078:   {
28078:     Stop(nsIWebNavigation::STOP_ALL);
28078:     return NS_OK;
28078:   }
28078:   //return failer if this request is not accepted due to mCharsetReloadState
28078:   return NS_ERROR_DOCSHELL_REQUEST_REJECTED;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::SetRendering(PRBool aRender)
28078: {
28078:   if(eCharsetReloadRequested != mCharsetReloadState) 
28078:   {
28078:     if (mContentViewer) {
28078:        mContentViewer->SetEnableRendering(aRender);
28078:        return NS_OK;
28078:     }
28078:   }
28078:   //return failer if this request is not accepted due to mCharsetReloadState
28078:   return NS_ERROR_DOCSHELL_REQUEST_REJECTED;
28078: }
28078: 
35581: NS_IMETHODIMP
35581: nsDocShell::GetPrintPreview(nsIWebBrowserPrint** aPrintPreview)
35581: {
35581:   *aPrintPreview = nsnull;
35581: #if NS_PRINT_PREVIEW
35581:   nsCOMPtr<nsIDocumentViewerPrint> print = do_QueryInterface(mContentViewer);
35581:   if (!print || !print->IsInitializedForPrintPreview()) {
35581:     Stop(nsIWebNavigation::STOP_ALL);
35581:     nsCOMPtr<nsIPrincipal> principal =
35581:       do_CreateInstance("@mozilla.org/nullprincipal;1");
35581:     NS_ENSURE_STATE(principal);
35581:     nsresult rv = CreateAboutBlankContentViewer(principal, nsnull);
35581:     NS_ENSURE_SUCCESS(rv, rv);
35581:     print = do_QueryInterface(mContentViewer);
35581:     NS_ENSURE_STATE(print);
35581:     print->InitializeForPrintPreview();
35581:   }
35581:   nsCOMPtr<nsIWebBrowserPrint> result = do_QueryInterface(print);
35581:   result.forget(aPrintPreview);
35581:   return NS_OK;
35581: #else
35581:   return NS_ERROR_NOT_IMPLEMENTED;
35581: #endif
35581: }
35581: 
35581: 
28078: #ifdef DEBUG
28078: unsigned long nsDocShell::gNumberOfDocShells = 0;
28078: #endif
