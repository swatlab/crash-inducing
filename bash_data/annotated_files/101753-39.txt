 99742: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "gfxTypes.h"
     1: #include "gfxPattern.h"
     1: #include "gfxASurface.h"
  7754: #include "gfxPlatform.h"
     1: 
     1: #include "cairo.h"
     1: 
 86662: #include <vector>
 86662: 
 86662: using namespace mozilla::gfx;
 86662: 
     1: gfxPattern::gfxPattern(cairo_pattern_t *aPattern)
 86662:   : mGfxPattern(NULL)
     1: {
     1:     mPattern = cairo_pattern_reference(aPattern);
     1: }
     1: 
     1: gfxPattern::gfxPattern(const gfxRGBA& aColor)
 86662:   : mGfxPattern(NULL)
     1: {
     1:     mPattern = cairo_pattern_create_rgba(aColor.r, aColor.g, aColor.b, aColor.a);
     1: }
     1: 
     1: // from another surface
     1: gfxPattern::gfxPattern(gfxASurface *surface)
 86662:   : mGfxPattern(NULL)
     1: {
     1:     mPattern = cairo_pattern_create_for_surface(surface->CairoSurface());
     1: }
     1: 
     1: // linear
     1: gfxPattern::gfxPattern(gfxFloat x0, gfxFloat y0, gfxFloat x1, gfxFloat y1)
 86662:   : mGfxPattern(NULL)
     1: {
     1:     mPattern = cairo_pattern_create_linear(x0, y0, x1, y1);
     1: }
     1: 
     1: // radial
     1: gfxPattern::gfxPattern(gfxFloat cx0, gfxFloat cy0, gfxFloat radius0,
     1:                        gfxFloat cx1, gfxFloat cy1, gfxFloat radius1)
 86662:   : mGfxPattern(NULL)
     1: {
     1:     mPattern = cairo_pattern_create_radial(cx0, cy0, radius0,
     1:                                            cx1, cy1, radius1);
     1: }
     1: 
 86662: // Azure
 86662: gfxPattern::gfxPattern(SourceSurface *aSurface, const Matrix &aTransform)
 86662:   : mPattern(NULL)
 86662:   , mGfxPattern(NULL)
 86662:   , mSourceSurface(aSurface)
 86662:   , mTransform(aTransform)
 86662: {
 86662: }
 86662: 
     1: gfxPattern::~gfxPattern()
     1: {
     1:     cairo_pattern_destroy(mPattern);
 86662: 
 86662:     if (mGfxPattern) {
 86662:       mGfxPattern->~Pattern();
 86662:     }
     1: }
     1: 
     1: cairo_pattern_t *
     1: gfxPattern::CairoPattern()
     1: {
     1:     return mPattern;
     1: }
     1: 
     1: void
     1: gfxPattern::AddColorStop(gfxFloat offset, const gfxRGBA& c)
     1: {
 86662:   if (mPattern) {
 86662:     mStops = NULL;
 16571:     if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
 19127:         gfxRGBA cms;
 19127:         gfxPlatform::TransformPixel(c, cms, gfxPlatform::GetCMSRGBTransform());
 19127: 
 19002:         // Use the original alpha to avoid unnecessary float->byte->float
 19002:         // conversion errors
  7754:         cairo_pattern_add_color_stop_rgba(mPattern, offset,
 19002:                                           cms.r, cms.g, cms.b, c.a);
  7754:     }
 19127:     else
     1:         cairo_pattern_add_color_stop_rgba(mPattern, offset, c.r, c.g, c.b, c.a);
     1:   }
 86662: }
     1: 
     1: void
     1: gfxPattern::SetMatrix(const gfxMatrix& matrix)
     1: {
 86662:   if (mPattern) {
     1:     cairo_matrix_t mat = *reinterpret_cast<const cairo_matrix_t*>(&matrix);
     1:     cairo_pattern_set_matrix(mPattern, &mat);
 86662:   } else {
 86662:     mTransform = ToMatrix(matrix);
 95880:     // Cairo-pattern matrices specify the conversion from DrawTarget to pattern
 95880:     // space. Azure pattern matrices specify the conversion from pattern to
 95880:     // DrawTarget space.
 95880:     mTransform.Invert();
 86662:   }
     1: }
     1: 
     1: gfxMatrix
     1: gfxPattern::GetMatrix() const
     1: {
 86662:   if (mPattern) {
     1:     cairo_matrix_t mat;
     1:     cairo_pattern_get_matrix(mPattern, &mat);
     1:     return gfxMatrix(*reinterpret_cast<gfxMatrix*>(&mat));
 86662:   } else {
 86662:     return ThebesMatrix(mTransform);
 86662:   }
 86662: }
 86662: 
 86662: Pattern*
 94391: gfxPattern::GetPattern(DrawTarget *aTarget, Matrix *aPatternTransform)
 86662: {
 99742:   if (mGfxPattern) {
 99742:     mGfxPattern->~Pattern();
 99742:     mGfxPattern = nsnull;
 99742:   }
 99742: 
 86662:   if (!mPattern) {
 86662:     mGfxPattern = new (mSurfacePattern.addr())
 86662:       SurfacePattern(mSourceSurface, EXTEND_CLAMP, mTransform);
 86662:     return mGfxPattern;
 86662:   }
 86662: 
 86662:   GraphicsExtend extend = (GraphicsExtend)cairo_pattern_get_extend(mPattern);
 86662: 
 86662:   switch (cairo_pattern_get_type(mPattern)) {
 94390:   case CAIRO_PATTERN_TYPE_SOLID:
 94390:     {
 94390:       double r, g, b, a;
 94390:       cairo_pattern_get_rgba(mPattern, &r, &g, &b, &a);
 94390: 
 94390:       new (mColorPattern.addr()) ColorPattern(Color(r, g, b, a));
 94390:       return mColorPattern.addr();
 94390:     }
 86662:   case CAIRO_PATTERN_TYPE_SURFACE:
 86662:     {
 86662:       GraphicsFilter filter = (GraphicsFilter)cairo_pattern_get_filter(mPattern);
 86662:       cairo_matrix_t mat;
 86662:       cairo_pattern_get_matrix(mPattern, &mat);
 86662:       gfxMatrix matrix(*reinterpret_cast<gfxMatrix*>(&mat));
 86662: 
 86662:       cairo_surface_t *surf = NULL;
 86662:       cairo_pattern_get_surface(mPattern, &surf);
 86662: 
 86662:       if (!mSourceSurface) {
 86662:         nsRefPtr<gfxASurface> gfxSurf = gfxASurface::Wrap(surf);
 99077:         // The underlying surface here will be kept around by the gfxPattern.
 99077:         // This function is intended to be used right away.
 86662:         mSourceSurface =
 86662:           gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(aTarget, gfxSurf);
 86662:       }
 86662: 
 86662:       if (mSourceSurface) {
 86662:         Matrix newMat = ToMatrix(matrix);
 94391: 
 94391:         AdjustTransformForPattern(newMat, aTarget->GetTransform(), aPatternTransform);
 94391: 
101753:         newMat.Invert();
 86662:         double x, y;
 86662:         cairo_surface_get_device_offset(surf, &x, &y);
 86662:         newMat.Translate(-x, -y);
 86662:         mGfxPattern = new (mSurfacePattern.addr())
 86662:           SurfacePattern(mSourceSurface, ToExtendMode(extend), newMat, ToFilter(filter));
 86662:         return mGfxPattern;
 86662:       }
 86662:       break;
 86662:     }
 86662:   case CAIRO_PATTERN_TYPE_LINEAR:
 86662:     {
 86662:       double x1, y1, x2, y2;
 86662:       cairo_pattern_get_linear_points(mPattern, &x1, &y1, &x2, &y2);
 86662:       if (!mStops) {
 86662:         int count = 0;
 86662:         cairo_pattern_get_color_stop_count(mPattern, &count);
 86662: 
 86662:         std::vector<GradientStop> stops;
 86662: 
 86662:         for (int i = 0; i < count; i++) {
 86662:           GradientStop stop;
 86662:           double r, g, b, a, offset;
 86662:           cairo_pattern_get_color_stop_rgba(mPattern, i, &offset, &r, &g, &b, &a);
 86662: 
 86662:           stop.offset = offset;
 86662:           stop.color = Color(Float(r), Float(g), Float(b), Float(a));
 86662:           stops.push_back(stop);
 86662:         }
 86662: 
 86662:         mStops = aTarget->CreateGradientStops(&stops.front(), count, ToExtendMode(extend));
 86662:       }
 86662: 
 86662:       if (mStops) {
 86662:         cairo_matrix_t mat;
 86662:         cairo_pattern_get_matrix(mPattern, &mat);
 86662:         gfxMatrix matrix(*reinterpret_cast<gfxMatrix*>(&mat));
 86662: 
 86662:         Matrix newMat = ToMatrix(matrix);
 94391: 
 94391:         AdjustTransformForPattern(newMat, aTarget->GetTransform(), aPatternTransform);
 94391: 
101753:         newMat.Invert();
101753: 
 86662:         mGfxPattern = new (mLinearGradientPattern.addr())
 86662:           LinearGradientPattern(Point(x1, y1), Point(x2, y2), mStops, newMat);
 86662: 
 86662:         return mGfxPattern;
 86662:       }
 86662:       break;
 86662:     }
 86662:   case CAIRO_PATTERN_TYPE_RADIAL:
 86662:     {
 86662:       if (!mStops) {
 86662:         int count = 0;
 86662:         cairo_pattern_get_color_stop_count(mPattern, &count);
 86662: 
 86662:         std::vector<GradientStop> stops;
 86662: 
 86662:         for (int i = 0; i < count; i++) {
 86662:           GradientStop stop;
 86662:           double r, g, b, a, offset;
 86662:           cairo_pattern_get_color_stop_rgba(mPattern, i, &offset, &r, &g, &b, &a);
 86662: 
 86662:           stop.offset = offset;
 86662:           stop.color = Color(Float(r), Float(g), Float(b), Float(a));
 86662:           stops.push_back(stop);
 86662:         }
 86662: 
 86662:         mStops = aTarget->CreateGradientStops(&stops.front(), count, ToExtendMode(extend));
 86662:       }
 86662: 
 86662:       if (mStops) {
 86662:         cairo_matrix_t mat;
 86662:         cairo_pattern_get_matrix(mPattern, &mat);
 86662:         gfxMatrix matrix(*reinterpret_cast<gfxMatrix*>(&mat));
 86662: 
 86662:         Matrix newMat = ToMatrix(matrix);
 94391: 
 94391:         AdjustTransformForPattern(newMat, aTarget->GetTransform(), aPatternTransform);
 94391: 
101753:         newMat.Invert();
101753: 
 86662:         double x1, y1, x2, y2, r1, r2;
 86662:         cairo_pattern_get_radial_circles(mPattern, &x1, &y1, &r1, &x2, &y2, &r2);
 86662:         mGfxPattern = new (mRadialGradientPattern.addr())
 86662:           RadialGradientPattern(Point(x1, y1), Point(x2, y2), r1, r2, mStops, newMat);
 86662: 
 86662:         return mGfxPattern;
 86662:       }
 86662:       break;
 86662:     }
 89482:   default:
 89482:     /* Reassure the compiler we are handling all the enum values.  */
 89482:     break;
 86662:   }
 86662: 
 86662:   new (mColorPattern.addr()) ColorPattern(Color(0, 0, 0, 0));
 86662:   return mColorPattern.addr();
     1: }
     1: 
     1: void
     1: gfxPattern::SetExtend(GraphicsExtend extend)
     1: {
 86662:   if (mPattern) {
 86662:     mStops = NULL;
 19731:     if (extend == EXTEND_PAD_EDGE) {
 19731:         if (cairo_pattern_get_type(mPattern) == CAIRO_PATTERN_TYPE_SURFACE) {
 19731:             cairo_surface_t *surf = NULL;
 19731: 
 19731:             cairo_pattern_get_surface (mPattern, &surf);
 19731:             if (surf) {
 19731:                 switch (cairo_surface_get_type(surf)) {
 19731:                     case CAIRO_SURFACE_TYPE_WIN32_PRINTING:
 19731:                     case CAIRO_SURFACE_TYPE_QUARTZ:
 19731:                         extend = EXTEND_NONE;
 19731:                         break;
 19731: 
 19731:                     case CAIRO_SURFACE_TYPE_WIN32:
 19742:                     case CAIRO_SURFACE_TYPE_XLIB:
 19731:                     default:
 19731:                         extend = EXTEND_PAD;
 19731:                         break;
 19731:                 }
 19731:             }
 19731:         }
 19731: 
 19731:         // if something went wrong, or not a surface pattern, use PAD
 19731:         if (extend == EXTEND_PAD_EDGE)
 19731:             extend = EXTEND_PAD;
 19731:     }
 19731: 
     1:     cairo_pattern_set_extend(mPattern, (cairo_extend_t)extend);
 86662:   } else {
 86662:     // This is always a surface pattern and will default to EXTEND_PAD
 86662:     // for EXTEND_PAD_EDGE.
 86662:     mExtend = ToExtendMode(extend);
 86662:   }
 86662: }
 86662: 
 86662: bool
 86662: gfxPattern::IsOpaque()
 86662: {
 86662:   if (mPattern) {
 86662:     switch (cairo_pattern_get_type(mPattern)) {
 86662:     case CAIRO_PATTERN_TYPE_SURFACE:
 86662:       {
 86662:         cairo_surface_t *surf = NULL;
 86662:         cairo_pattern_get_surface(mPattern, &surf);
 86662: 
 86662:         if (cairo_surface_get_content(surf) == CAIRO_CONTENT_COLOR) {
 86662:           return true;
 86662:         }
 86662:       }
 89482:     default:
 89482:       return false;
 86662:     }
 86662:   }
 86662: 
 86662:   if (mSourceSurface->GetFormat() == FORMAT_B8G8R8X8) {
 86662:     return true;
 86662:   }
 86662:   return false;
     1: }
     1: 
     1: gfxPattern::GraphicsExtend
     1: gfxPattern::Extend() const
     1: {
 86662:   if (mPattern) {
     1:     return (GraphicsExtend)cairo_pattern_get_extend(mPattern);
 86662:   } else {
 86662:     return ThebesExtend(mExtend);
 86662:   }
     1: }
     1: 
     1: void
 26449: gfxPattern::SetFilter(GraphicsFilter filter)
     1: {
 86662:   if (mPattern) {
     1:     cairo_pattern_set_filter(mPattern, (cairo_filter_t)filter);
 86662:   } else {
 86662:     mFilter = ToFilter(filter);
 86662:   }
     1: }
     1: 
 26449: gfxPattern::GraphicsFilter
     1: gfxPattern::Filter() const
     1: {
 86662:   if (mPattern) {
 26449:     return (GraphicsFilter)cairo_pattern_get_filter(mPattern);
 86662:   } else {
 86662:     return ThebesFilter(mFilter);
 86662:   }
     1: }
     1: 
 79445: bool
     1: gfxPattern::GetSolidColor(gfxRGBA& aColor)
     1: {
     1:     return cairo_pattern_get_rgba(mPattern,
     1:                                   &aColor.r,
     1:                                   &aColor.g,
     1:                                   &aColor.b,
     1:                                   &aColor.a) == CAIRO_STATUS_SUCCESS;
     1: }
     1: 
     1: already_AddRefed<gfxASurface>
     1: gfxPattern::GetSurface()
     1: {
 86662:   if (mPattern) {
     1:     cairo_surface_t *surf = nsnull;
     1: 
     1:     if (cairo_pattern_get_surface (mPattern, &surf) != CAIRO_STATUS_SUCCESS)
     1:         return nsnull;
     1: 
     1:     return gfxASurface::Wrap(surf);
 86662:   } else {
 86662:     // We should never be trying to get the surface off an Azure gfx Pattern.
 86662:     NS_ERROR("Attempt to get surface off an Azure gfxPattern!");
 86662:     return NULL;
 86662:   }
     1: }
 12652: 
 12652: gfxPattern::GraphicsPatternType
 12652: gfxPattern::GetType() const
 12652: {
 86662:   if (mPattern) {
 12652:     return (GraphicsPatternType) cairo_pattern_get_type(mPattern);
 86662:   } else {
 86662:     // We should never be trying to get the type off an Azure gfx Pattern.
 86662:     MOZ_ASSERT(0);
 86662:     return PATTERN_SURFACE;
 86662:   }
 12652: }
 12652: 
 12652: int
 12652: gfxPattern::CairoStatus()
 12652: {
 86662:   if (mPattern) {
 12652:     return cairo_pattern_status(mPattern);
 86662:   } else {
 86662:     // An Azure pattern as this point is never in error status.
 86662:     return CAIRO_STATUS_SUCCESS;
 12652:   }
 86662: }
 94391: 
 94391: void
 94391: gfxPattern::AdjustTransformForPattern(Matrix &aPatternTransform,
 94391:                                       const Matrix &aCurrentTransform,
 94391:                                       const Matrix *aOriginalTransform)
 94391: {
 94391:   if (!aOriginalTransform) {
 94391:     return;
 94391:   }
 94391: 
101753:   Matrix mat = *aOriginalTransform;
 94391:   mat.Invert();
 94391: 
101753:   aPatternTransform = mat * aCurrentTransform * aPatternTransform;
101753: }
