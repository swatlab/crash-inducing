    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
32381:  *   Aaron Leventhal <aaronl@netscape.com> (original author)
32381:  *   Kyle Yuan <kyle.yuan@sun.com>
32381:  *   Alexander Surkov <surkov.alexander@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
32381: #include "nsXULListboxAccessible.h"
32381: 
67790: #include "States.h"
41384: #include "nsAccessibilityService.h"
41384: #include "nsAccUtils.h"
41384: 
10594: #include "nsIDOMXULPopupElement.h"
12646: #include "nsIDOMXULMultSelectCntrlEl.h"
    1: #include "nsIDOMXULSelectCntrlItemEl.h"
    1: 
 6094: ////////////////////////////////////////////////////////////////////////////////
 6094: // nsXULColumnsAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
    1: 
 6094: nsXULColumnsAccessible::
43504:   nsXULColumnsAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessibleWrap(aContent, aShell)
 6094: {
 6094: }
 6094: 
52027: PRUint32
52027: nsXULColumnsAccessible::NativeRole()
 6094: {
52027:   return nsIAccessibleRole::ROLE_LIST;
 6094: }
 6094: 
67790: PRUint64
67790: nsXULColumnsAccessible::NativeState()
 6094: {
67973:   return states::READONLY;
 6094: }
 6094: 
32381: 
 6094: ////////////////////////////////////////////////////////////////////////////////
 6094: // nsXULColumnItemAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
 6094: 
 6094: nsXULColumnItemAccessible::
43504:   nsXULColumnItemAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsLeafAccessible(aContent, aShell)
 6094: {
 6094: }
 6094: 
52027: PRUint32
52027: nsXULColumnItemAccessible::NativeRole()
 6094: {
52027:   return nsIAccessibleRole::ROLE_COLUMNHEADER;
 6094: }
 6094: 
67790: PRUint64
67790: nsXULColumnItemAccessible::NativeState()
 6094: {
67973:   return states::READONLY;
 6094: }
 6094: 
 6094: NS_IMETHODIMP
 6094: nsXULColumnItemAccessible::GetNumActions(PRUint8 *aNumActions)
 6094: {
 6094:   NS_ENSURE_ARG_POINTER(aNumActions);
 6094: 
 6094:   *aNumActions = 1;
 6094:   return NS_OK;
 6094: }
 6094: 
 6094: NS_IMETHODIMP
 6094: nsXULColumnItemAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
 6094: {
 6094:   if (aIndex != eAction_Click)
 6094:     return NS_ERROR_INVALID_ARG;
 6094: 
 6094:   aName.AssignLiteral("click");
 6094:   return NS_OK;
 6094: }
 6094: 
 6094: NS_IMETHODIMP
 6094: nsXULColumnItemAccessible::DoAction(PRUint8 aIndex)
 6094: {
 6094:   if (aIndex != eAction_Click)
 6094:     return NS_ERROR_INVALID_ARG;
 6094: 
37481:   DoCommand();
37481:   return NS_OK;
 6094: }
 6094: 
 6094: ////////////////////////////////////////////////////////////////////////////////
 6094: // nsXULListboxAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
    1: 
11854: nsXULListboxAccessible::
43504:   nsXULListboxAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsXULSelectableAccessible(aContent, aShell)
    1: {
    1: }
    1: 
11854: NS_IMPL_ADDREF_INHERITED(nsXULListboxAccessible, nsXULSelectableAccessible)
11854: NS_IMPL_RELEASE_INHERITED(nsXULListboxAccessible, nsXULSelectableAccessible)
11854: 
11854: nsresult
11854: nsXULListboxAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
11854: {
11854:   nsresult rv = nsXULSelectableAccessible::QueryInterface(aIID, aInstancePtr);
11854:   if (*aInstancePtr)
11854:     return rv;
11854: 
32381:   if (aIID.Equals(NS_GET_IID(nsIAccessibleTable)) && IsMulticolumn()) {
11854:     *aInstancePtr = static_cast<nsIAccessibleTable*>(this);
11854:     NS_ADDREF_THIS();
11854:     return NS_OK;
11854:   }
11854: 
11854:   return NS_ERROR_NO_INTERFACE;
11854: }
11854: 
11854: PRBool
32381: nsXULListboxAccessible::IsMulticolumn()
11854: {
11854:   PRInt32 numColumns = 0;
32381:   nsresult rv = GetColumnCount(&numColumns);
11854:   if (NS_FAILED(rv))
11854:     return PR_FALSE;
11854: 
11854:   return numColumns > 1;
11854: }
11854: 
11854: ////////////////////////////////////////////////////////////////////////////////
11854: // nsXULListboxAccessible. nsIAccessible
11854: 
67790: PRUint64
67790: nsXULListboxAccessible::NativeState()
    1: {
11854:   // As a nsXULListboxAccessible we can have the following states:
67790:   //   FOCUSED, READONLY, FOCUSABLE
11854: 
    1:   // Get focus status from base class
67790:   PRUint64 states = nsAccessible::NativeState();
    1: 
    1:   // see if we are multiple select if so set ourselves as such
43504: 
43504:   if (mContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::seltype,
43504:                             nsAccessibilityAtoms::multiple, eCaseMatters)) {
67790:       states |= states::MULTISELECTABLE | states::EXTSELECTABLE;
    1:   }
    1: 
67790:   return states;
    1: }
    1: 
    1: /**
    1:   * Our value is the label of our ( first ) selected child.
    1:   */
    1: NS_IMETHODIMP nsXULListboxAccessible::GetValue(nsAString& _retval)
    1: {
    1:   _retval.Truncate();
43504:   nsCOMPtr<nsIDOMXULSelectControlElement> select(do_QueryInterface(mContent));
    1:   if (select) {
    1:     nsCOMPtr<nsIDOMXULSelectControlItemElement> selectedItem;
    1:     select->GetSelectedItem(getter_AddRefs(selectedItem));
    1:     if (selectedItem)
    1:       return selectedItem->GetLabel(_retval);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
52027: PRUint32
52027: nsXULListboxAccessible::NativeRole()
    1: {
43504:   // A richlistbox is used with the new autocomplete URL bar, and has a parent
43504:   // popup <panel>.
10594:   nsCOMPtr<nsIDOMXULPopupElement> xulPopup =
43504:     do_QueryInterface(mContent->GetParent());
52027:   if (xulPopup)
52027:     return nsIAccessibleRole::ROLE_COMBOBOX_LIST;
11854: 
32381:   if (IsMulticolumn())
52027:     return nsIAccessibleRole::ROLE_TABLE;
52027:   return nsIAccessibleRole::ROLE_LISTBOX;
    1: }
    1: 
11854: ////////////////////////////////////////////////////////////////////////////////
11854: // nsXULListboxAccessible. nsIAccessibleTable
    1: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::GetCaption(nsIAccessible **aCaption)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aCaption);
11854:   *aCaption = nsnull;
11854: 
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::GetSummary(nsAString &aSummary)
11854: {
11854:   aSummary.Truncate();
11854: 
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetColumnCount(PRInt32 *aColumnsCout)
11854: {
32381:   NS_ENSURE_ARG_POINTER(aColumnsCout);
32381:   *aColumnsCout = 0;
11854: 
32381:   if (IsDefunct())
11854:     return NS_ERROR_FAILURE;
11854: 
43504:   nsIContent* headContent = nsnull;
11854: 
43504:   PRUint32 count = mContent->GetChildCount();
11854:   for (PRUint32 index = 0; index < count; ++index) {
43504:     nsIContent* childContent = mContent->GetChildAt(index);
12646:     if (childContent->NodeInfo()->Equals(nsAccessibilityAtoms::listcols,
11854:                                          kNameSpaceID_XUL)) {
11854:       headContent = childContent;
11854:     }
11854:   }
11854: 
11854:   if (!headContent)
11854:     return NS_OK;
11854: 
11854:   PRUint32 columnCount = 0;
43504: 
11854:   count = headContent->GetChildCount();
11854:   for (PRUint32 index = 0; index < count; ++index) {
43504:     nsIContent* childContent = headContent->GetChildAt(index);
12646:     if (childContent->NodeInfo()->Equals(nsAccessibilityAtoms::listcol,
11854:                                          kNameSpaceID_XUL)) {
11854:       columnCount++;
11854:     }
11854:   }
11854: 
32381:   *aColumnsCout = columnCount;
11854:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
43504: nsXULListboxAccessible::GetRowCount(PRInt32 *aRowCount)
11854: {
43504:   NS_ENSURE_ARG_POINTER(aRowCount);
43504:   *aRowCount = 0;
11854: 
32381:   if (IsDefunct())
11854:     return NS_ERROR_FAILURE;
11854: 
43504:   nsCOMPtr<nsIDOMXULSelectControlElement> element(do_QueryInterface(mContent));
11854:   NS_ENSURE_STATE(element);
11854: 
11854:   PRUint32 itemCount = 0;
11854:   nsresult rv = element->GetItemCount(&itemCount);
11854:   NS_ENSURE_SUCCESS(rv, rv);
11854: 
43504:   *aRowCount = itemCount;
11854:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetCellAt(PRInt32 aRow, PRInt32 aColumn,
11854:                                   nsIAccessible **aAccessibleCell)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aAccessibleCell);
11854:   *aAccessibleCell = nsnull;
11854: 
11854:   if (IsDefunct())
11854:     return NS_OK;
11854: 
11854:   nsCOMPtr<nsIDOMXULSelectControlElement> control =
43504:     do_QueryInterface(mContent);
11854: 
11854:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
11854:   control->GetItemAtIndex(aRow, getter_AddRefs(item));
11854:   NS_ENSURE_TRUE(item, NS_ERROR_INVALID_ARG);
11854: 
43504:   nsCOMPtr<nsIContent> itemContent(do_QueryInterface(item));
32381: 
42795:   nsAccessible *row =
43504:     GetAccService()->GetAccessibleInWeakShell(itemContent, mWeakShell);
42795:   NS_ENSURE_STATE(row);
11854: 
42795:   nsresult rv = row->GetChildAt(aColumn, aAccessibleCell);
11854:   NS_ENSURE_SUCCESS(rv, NS_ERROR_INVALID_ARG);
11854: 
11854:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetCellIndexAt(PRInt32 aRow, PRInt32 aColumn,
11854:                                        PRInt32 *aIndex)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aIndex);
11854:   *aIndex = -1;
11854: 
11854:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
11854:   NS_ENSURE_SUCCESS(rv, rv);
11854:   NS_ENSURE_TRUE(0 <= aRow && aRow <= rowCount, NS_ERROR_INVALID_ARG);
11854: 
11854:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
11854:   NS_ENSURE_SUCCESS(rv, rv);
11854:   NS_ENSURE_TRUE(0 <= aColumn && aColumn <= columnCount, NS_ERROR_INVALID_ARG);
11854: 
11854:   *aIndex = aRow * columnCount + aColumn;
11854:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetColumnIndexAt(PRInt32 aIndex, PRInt32 *aColumn)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aColumn);
11854:   *aColumn = -1;
11854: 
11854:   PRInt32 columnCount = 0;
32381:   nsresult rv = GetColumnCount(&columnCount);
11854:   NS_ENSURE_SUCCESS(rv, rv);
11854: 
11854:   *aColumn = aIndex % columnCount;
11854:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetRowIndexAt(PRInt32 aIndex, PRInt32 *aRow)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aRow);
11854:   *aRow = -1;
11854: 
11854:   PRInt32 columnCount = 0;
32381:   nsresult rv = GetColumnCount(&columnCount);
11854:   NS_ENSURE_SUCCESS(rv, rv);
11854: 
11854:   *aRow = aIndex / columnCount;
11854:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
47173: nsXULListboxAccessible::GetRowAndColumnIndicesAt(PRInt32 aCellIndex,
47173:                                                  PRInt32* aRowIndex,
47173:                                                  PRInt32* aColumnIndex)
47173: {
47173:   NS_ENSURE_ARG_POINTER(aRowIndex);
47173:   *aRowIndex = -1;
47173:   NS_ENSURE_ARG_POINTER(aColumnIndex);
47173:   *aColumnIndex = -1;
47173: 
47173:   if (IsDefunct())
47173:     return NS_ERROR_FAILURE;
47173: 
47173:   PRInt32 columnCount = 0;
47173:   nsresult rv = GetColumnCount(&columnCount);
47173:   NS_ENSURE_SUCCESS(rv, rv);
47173: 
47173:   *aColumnIndex = aCellIndex % columnCount;
47173:   *aRowIndex = aCellIndex / columnCount;
47173:   return NS_OK;
47173: }
47173: 
47173: NS_IMETHODIMP
11854: nsXULListboxAccessible::GetColumnExtentAt(PRInt32 aRow, PRInt32 aColumn,
11854:                                           PRInt32 *aCellSpans)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aCellSpans);
11854:   *aCellSpans = 1;
11854: 
11854:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::GetRowExtentAt(PRInt32 aRow, PRInt32 aColumn,
11854:                                        PRInt32 *aCellSpans)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aCellSpans);
11854:   *aCellSpans = 1;
11854: 
11854:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::GetColumnDescription(PRInt32 aColumn,
11854:                                              nsAString& aDescription)
11854: {
12646:   aDescription.Truncate();
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::GetRowDescription(PRInt32 aRow, nsAString& aDescription)
11854: {
12646:   aDescription.Truncate();
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::IsColumnSelected(PRInt32 aColumn, PRBool *aIsSelected)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aIsSelected);
12646:   *aIsSelected = PR_FALSE;
11854: 
12646:   if (IsDefunct())
12646:     return NS_ERROR_FAILURE;
12646: 
12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
43504:     do_QueryInterface(mContent);
12646:   NS_ASSERTION(control,
12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
12646: 
32381:   PRInt32 selectedrowCount = 0;
32381:   nsresult rv = control->GetSelectedCount(&selectedrowCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   PRInt32 rowCount = 0;
32381:   rv = GetRowCount(&rowCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   *aIsSelected = (selectedrowCount == rowCount);
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::IsRowSelected(PRInt32 aRow, PRBool *aIsSelected)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aIsSelected);
12646:   *aIsSelected = PR_FALSE;
11854: 
12646:   if (IsDefunct())
12646:     return NS_ERROR_FAILURE;
12646: 
12646:   nsCOMPtr<nsIDOMXULSelectControlElement> control =
43504:     do_QueryInterface(mContent);
12646:   NS_ASSERTION(control,
12646:                "Doesn't implement nsIDOMXULSelectControlElement.");
12646:   
12646:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
12646:   control->GetItemAtIndex(aRow, getter_AddRefs(item));
12646:   NS_ENSURE_TRUE(item, NS_ERROR_INVALID_ARG);
12646: 
12646:   return item->GetSelected(aIsSelected);
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::IsCellSelected(PRInt32 aRowIndex, PRInt32 aColumnIndex,
11854:                                        PRBool *aIsSelected)
11854: {
32381:   return IsRowSelected(aRowIndex, aIsSelected);
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetSelectedCellCount(PRUint32* aCount)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aCount);
12646:   *aCount = 0;
11854: 
12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
43504:     do_QueryInterface(mContent);
12646:   NS_ASSERTION(control,
12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
12646: 
12646:   nsCOMPtr<nsIDOMNodeList> selectedItems;
12646:   control->GetSelectedItems(getter_AddRefs(selectedItems));
12646:   if (!selectedItems)
12646:     return NS_OK;
12646: 
12646:   PRUint32 selectedItemsCount = 0;
12646:   nsresult rv = selectedItems->GetLength(&selectedItemsCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
12646:   if (!selectedItemsCount)
12646:     return NS_OK;
12646: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   *aCount = selectedItemsCount * columnCount;
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetSelectedColumnCount(PRUint32* aCount)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aCount);
12646:   *aCount = 0;
11854: 
12646:   if (IsDefunct())
12646:     return NS_ERROR_FAILURE;
12646: 
12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
43504:     do_QueryInterface(mContent);
12646:   NS_ASSERTION(control,
12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
12646: 
32381:   PRInt32 selectedrowCount = 0;
32381:   nsresult rv = control->GetSelectedCount(&selectedrowCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   PRInt32 rowCount = 0;
32381:   rv = GetRowCount(&rowCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   if (selectedrowCount != rowCount)
12646:     return NS_OK;
12646: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   *aCount = columnCount;
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetSelectedRowCount(PRUint32* aCount)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aCount);
12646:   *aCount = 0;
11854: 
12646:   if (IsDefunct())
12646:     return NS_ERROR_FAILURE;
12646: 
12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
43504:     do_QueryInterface(mContent);
12646:   NS_ASSERTION(control,
12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
12646: 
32381:   PRInt32 selectedrowCount = 0;
32381:   nsresult rv = control->GetSelectedCount(&selectedrowCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   *aCount = selectedrowCount;
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetSelectedCells(nsIArray **aCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aCells);
32381:   *aCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsresult rv = NS_OK;
32381:   nsCOMPtr<nsIMutableArray> selCells =
32381:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
43504:     do_QueryInterface(mContent);
32381:   NS_ASSERTION(control,
32381:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
32381: 
32381:   nsCOMPtr<nsIDOMNodeList> selectedItems;
32381:   control->GetSelectedItems(getter_AddRefs(selectedItems));
32381:   if (!selectedItems)
32381:     return NS_OK;
32381: 
32381:   PRUint32 selectedItemsCount = 0;
32381:   rv = selectedItems->GetLength(&selectedItemsCount);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   PRUint32 index = 0;
32381:   for (; index < selectedItemsCount; index++) {
32381:     nsCOMPtr<nsIDOMNode> itemNode;
32381:     selectedItems->Item(index, getter_AddRefs(itemNode));
43504:     nsCOMPtr<nsIContent> itemContent(do_QueryInterface(itemNode));
42795:     nsAccessible *item =
43504:       GetAccService()->GetAccessibleInWeakShell(itemContent, mWeakShell);
32381: 
32381:     if (item) {
41227:       PRInt32 cellCount = item->GetChildCount();
41227:       for (PRInt32 cellIdx = 0; cellIdx < cellCount; cellIdx++) {
41227:         nsAccessible *cell = mChildren[cellIdx];
52089:         if (cell->Role() == nsIAccessibleRole::ROLE_CELL)
41227:           selCells->AppendElement(static_cast<nsIAccessible*>(cell), PR_FALSE);
32381:       }
32381:     }
32381:   }
32381: 
32381:   NS_ADDREF(*aCells = selCells);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetSelectedCellIndices(PRUint32 *aNumCells,
32381:                                                PRInt32 **aCells)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aNumCells);
12646:   *aNumCells = 0;
11854:   NS_ENSURE_ARG_POINTER(aCells);
12646:   *aCells = nsnull;
11854: 
12646:   if (IsDefunct())
12646:     return NS_ERROR_FAILURE;
12646: 
12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
43504:     do_QueryInterface(mContent);
12646:   NS_ASSERTION(control,
12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
12646: 
12646:   nsCOMPtr<nsIDOMNodeList> selectedItems;
12646:   control->GetSelectedItems(getter_AddRefs(selectedItems));
12646:   if (!selectedItems)
12646:     return NS_OK;
12646: 
12646:   PRUint32 selectedItemsCount = 0;
12646:   nsresult rv = selectedItems->GetLength(&selectedItemsCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   PRUint32 cellsCount = selectedItemsCount * columnCount;
12646: 
12646:   PRInt32 *cellsIdxArray =
12646:     static_cast<PRInt32*>(nsMemory::Alloc((cellsCount) * sizeof(PRInt32)));
12646:   NS_ENSURE_TRUE(cellsIdxArray, NS_ERROR_OUT_OF_MEMORY);
12646: 
12646:   PRUint32 index = 0, cellsIdx = 0;
12646:   for (; index < selectedItemsCount; index++) {
12646:     nsCOMPtr<nsIDOMNode> itemNode;
12646:     selectedItems->Item(index, getter_AddRefs(itemNode));
12646:     nsCOMPtr<nsIDOMXULSelectControlItemElement> item =
12646:       do_QueryInterface(itemNode);
12646: 
12646:     if (item) {
12646:       PRInt32 itemIdx = -1;
12646:       control->GetIndexOfItem(item, &itemIdx);
12646:       if (itemIdx != -1) {
12646:         PRInt32 colIdx = 0;
32381:         for (; colIdx < columnCount; colIdx++)
32381:           cellsIdxArray[cellsIdx++] = itemIdx * columnCount + colIdx;
12646:       }
12646:     }
12646:   }
12646: 
12646:   *aNumCells = cellsCount;
12646:   *aCells = cellsIdxArray;
12646: 
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetSelectedColumnIndices(PRUint32 *aNumColumns,
11854:                                                  PRInt32 **aColumns)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aNumColumns);
12646:   *aNumColumns = 0;
11854:   NS_ENSURE_ARG_POINTER(aColumns);
12646:   *aColumns = nsnull;
11854: 
12646:   if (IsDefunct())
12646:     return NS_ERROR_FAILURE;
12646: 
32381:   PRUint32 columnCount = 0;
32381:   nsresult rv = GetSelectedColumnCount(&columnCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
32381:   if (!columnCount)
12646:     return NS_OK;
12646: 
12646:   PRInt32 *colsIdxArray =
32381:     static_cast<PRInt32*>(nsMemory::Alloc((columnCount) * sizeof(PRInt32)));
12646:   NS_ENSURE_TRUE(colsIdxArray, NS_ERROR_OUT_OF_MEMORY);
12646: 
12646:   PRUint32 colIdx = 0;
32381:   for (; colIdx < columnCount; colIdx++)
12646:     colsIdxArray[colIdx] = colIdx;
12646: 
32381:   *aNumColumns = columnCount;
12646:   *aColumns = colsIdxArray;
12646: 
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
32381: nsXULListboxAccessible::GetSelectedRowIndices(PRUint32 *aNumRows,
32381:                                               PRInt32 **aRows)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aNumRows);
12646:   *aNumRows = 0;
11854:   NS_ENSURE_ARG_POINTER(aRows);
12646:   *aRows = nsnull;
11854: 
12646:   if (IsDefunct())
12646:     return NS_ERROR_FAILURE;
12646: 
12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
43504:     do_QueryInterface(mContent);
12646:   NS_ASSERTION(control,
12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
12646:   
12646:   nsCOMPtr<nsIDOMNodeList> selectedItems;
12646:   control->GetSelectedItems(getter_AddRefs(selectedItems));
12646:   if (!selectedItems)
12646:     return NS_OK;
12646:   
12646:   PRUint32 selectedItemsCount = 0;
12646:   nsresult rv = selectedItems->GetLength(&selectedItemsCount);
12646:   NS_ENSURE_SUCCESS(rv, rv);
12646: 
12646:   if (!selectedItemsCount)
12646:     return NS_OK;
12646: 
12646:   PRInt32 *rowsIdxArray =
12646:     static_cast<PRInt32*>(nsMemory::Alloc((selectedItemsCount) * sizeof(PRInt32)));
12646:   NS_ENSURE_TRUE(rowsIdxArray, NS_ERROR_OUT_OF_MEMORY);
12646: 
12646:   PRUint32 index = 0;
12646:   for (; index < selectedItemsCount; index++) {
12646:     nsCOMPtr<nsIDOMNode> itemNode;
12646:     selectedItems->Item(index, getter_AddRefs(itemNode));
12646:     nsCOMPtr<nsIDOMXULSelectControlItemElement> item =
12646:       do_QueryInterface(itemNode);
12646:     
12646:     if (item) {
12646:       PRInt32 itemIdx = -1;
12646:       control->GetIndexOfItem(item, &itemIdx);
12646:       if (itemIdx != -1)
12646:         rowsIdxArray[index] = itemIdx;
12646:     }
12646:   }
12646: 
12646:   *aNumRows = selectedItemsCount;
12646:   *aRows = rowsIdxArray;
12646: 
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::SelectRow(PRInt32 aRow)
11854: {
12646:   if (IsDefunct())
12646:     return NS_ERROR_FAILURE;
12646:   
12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
43504:     do_QueryInterface(mContent);
12646:   NS_ASSERTION(control,
12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
12646: 
12646:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
12646:   control->GetItemAtIndex(aRow, getter_AddRefs(item));
12646:   NS_ENSURE_TRUE(item, NS_ERROR_INVALID_ARG);
12646: 
12646:   return control->SelectItem(item);
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::SelectColumn(PRInt32 aColumn)
11854: {
12646:   // xul:listbox and xul:richlistbox support row selection only.
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::UnselectRow(PRInt32 aRow)
11854: {
12646:   if (IsDefunct())
12646:     return NS_ERROR_FAILURE;
12646:   
12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
43504:     do_QueryInterface(mContent);
12646:   NS_ASSERTION(control,
12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
12646: 
12646:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
12646:   control->GetItemAtIndex(aRow, getter_AddRefs(item));
12646:   NS_ENSURE_TRUE(item, NS_ERROR_INVALID_ARG);
12646: 
12646:   return control->RemoveItemFromSelection(item);
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::UnselectColumn(PRInt32 aColumn)
11854: {
12646:   // xul:listbox and xul:richlistbox support row selection only.
12646:   return NS_OK;
11854: }
11854: 
11854: NS_IMETHODIMP
11854: nsXULListboxAccessible::IsProbablyForLayout(PRBool *aIsProbablyForLayout)
11854: {
11854:   NS_ENSURE_ARG_POINTER(aIsProbablyForLayout);
11854:   *aIsProbablyForLayout = PR_FALSE;
11854: 
11854:   return NS_OK;
11854: }
11854: 
11854: ////////////////////////////////////////////////////////////////////////////////
11854: // nsXULListitemAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
11854: 
11854: nsXULListitemAccessible::
43504:   nsXULListitemAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsXULMenuitemAccessible(aContent, aShell)
    1: {
43504:   mIsCheckbox = mContent->AttrValueIs(kNameSpaceID_None,
43504:                                       nsAccessibilityAtoms::type,
43504:                                       nsAccessibilityAtoms::checkbox,
43504:                                       eCaseMatters);
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED0(nsXULListitemAccessible, nsAccessible)
    1: 
42795: nsAccessible *
11854: nsXULListitemAccessible::GetListAccessible()
11854: {
11854:   if (IsDefunct())
11854:     return nsnull;
11854:   
11854:   nsCOMPtr<nsIDOMXULSelectControlItemElement> listItem =
43504:     do_QueryInterface(mContent);
12090:   if (!listItem)
12090:     return nsnull;
11854: 
11854:   nsCOMPtr<nsIDOMXULSelectControlElement> list;
11854:   listItem->GetControl(getter_AddRefs(list));
15311: 
43504:   nsCOMPtr<nsIContent> listContent(do_QueryInterface(list));
43504:   if (!listContent)
11854:     return nsnull;
11854: 
43504:   return GetAccService()->GetAccessibleInWeakShell(listContent, mWeakShell);
11854: }
11854: 
11854: ////////////////////////////////////////////////////////////////////////////////
11854: // nsXULListitemAccessible. nsIAccessible
11854: 
    1: /**
    1:   * If there is a Listcell as a child ( not anonymous ) use it, otherwise
    1:   *   default to getting the name from GetXULName
    1:   */
20246: nsresult
20246: nsXULListitemAccessible::GetNameInternal(nsAString& aName)
    1: {
43504:   nsIContent* child = mContent->GetChildAt(0);
43504:   if (child) {
43504:     if (child->NodeInfo()->Equals(nsAccessibilityAtoms::listcell,
43504:                                   kNameSpaceID_XUL)) {
43504:       child->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::label, aName);
    1:       return NS_OK;
    1:     }
    1:   }
18347:   return GetXULName(aName);
    1: }
    1: 
52027: PRUint32
52027: nsXULListitemAccessible::NativeRole()
    1: {
42795:   nsAccessible *list = GetListAccessible();
52027:   if (!list) {
52027:     NS_ERROR("No list accessible for listitem accessible!");
52027:     return nsIAccessibleRole::ROLE_NOTHING;
11854:   }
11854: 
52089:   if (list->Role() == nsIAccessibleRole::ROLE_TABLE)
52027:     return nsIAccessibleRole::ROLE_ROW;
52027: 
    1:   if (mIsCheckbox)
52027:     return nsIAccessibleRole::ROLE_CHECKBUTTON;
52027: 
52089:   if (mParent && mParent->Role() == nsIAccessibleRole::ROLE_COMBOBOX_LIST)
52027:     return nsIAccessibleRole::ROLE_COMBOBOX_OPTION;
52027: 
52027:   return nsIAccessibleRole::ROLE_RICH_OPTION;
    1: }
    1: 
67790: PRUint64
67790: nsXULListitemAccessible::NativeState()
    1: {
67973:   if (mIsCheckbox)
67790:     return nsXULMenuitemAccessible::NativeState();
21984: 
67790:   PRUint64 states = states::FOCUSABLE | states::SELECTABLE;
32381: 
32381:   nsCOMPtr<nsIDOMXULSelectControlItemElement> listItem =
43504:     do_QueryInterface(mContent);
32381: 
    1:   if (listItem) {
    1:     PRBool isSelected;
    1:     listItem->GetSelected(&isSelected);
    1:     if (isSelected)
67790:       states |= states::SELECTED;
    1: 
43504:     if (gLastFocusedNode == mContent)
67790:       states |= states::FOCUSED;
43504: 
    1:   }
    1: 
67790:   return states;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULListitemAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
    1:   if (aIndex == eAction_Click && mIsCheckbox) {
    1:     // check or uncheck
67790:     PRUint64 states = NativeState();
    1: 
67790:     if (states & states::CHECKED)
    1:       aName.AssignLiteral("uncheck");
    1:     else
    1:       aName.AssignLiteral("check");
    1: 
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
29320: PRBool
29320: nsXULListitemAccessible::GetAllowsAnonChildAccessibles()
  954: {
  954:   // That indicates we should walk anonymous children for listitems
29320:   return PR_TRUE;
  954: }
  954: 
36879: void
36879: nsXULListitemAccessible::GetPositionAndSizeInternal(PRInt32 *aPosInSet,
36879:                                                     PRInt32 *aSetSize)
11864: {
43504:   nsAccUtils::GetPositionAndSizeForXULSelectControlItem(mContent, aPosInSet,
36879:                                                         aSetSize);
11864: }
11864: 
11864: 
11854: ////////////////////////////////////////////////////////////////////////////////
11854: // nsXULListCellAccessible
32381: ////////////////////////////////////////////////////////////////////////////////
32381: 
11854: nsXULListCellAccessible::
43504:   nsXULListCellAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
11854: {
11854: }
11854: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsISupports
32381: 
32381: NS_IMPL_ISUPPORTS_INHERITED1(nsXULListCellAccessible,
32381:                              nsHyperTextAccessible,
32381:                              nsIAccessibleTableCell)
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsXULListCellAccessible: nsIAccessibleTableCell implementation
32381: 
32381: NS_IMETHODIMP
32381: nsXULListCellAccessible::GetTable(nsIAccessibleTable **aTable)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aTable);
32381:   *aTable = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
52089:   nsAccessible* thisRow = GetParent();
52089:   if (!thisRow || thisRow->Role() != nsIAccessibleRole::ROLE_ROW)
32381:     return NS_OK;
32381: 
52089:   nsAccessible* table = thisRow->GetParent();
52089:   if (!table || table->Role() != nsIAccessibleRole::ROLE_TABLE)
32381:     return NS_OK;
32381: 
32381:   CallQueryInterface(table, aTable);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULListCellAccessible::GetColumnIndex(PRInt32 *aColumnIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aColumnIndex);
32381:   *aColumnIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
52089:   nsAccessible* row = GetParent();
52089:   if (!row)
52089:     return NS_OK;
52089: 
32381:   *aColumnIndex = 0;
32381: 
52089:   PRInt32 indexInRow = GetIndexInParent();
52089:   for (PRInt32 idx = 0; idx < indexInRow; idx++) {
52089:     nsAccessible* cell = row->GetChildAt(idx);
52089:     PRUint32 role = cell->Role();
32381:     if (role == nsIAccessibleRole::ROLE_CELL ||
32381:         role == nsIAccessibleRole::ROLE_GRID_CELL ||
32381:         role == nsIAccessibleRole::ROLE_ROWHEADER ||
32381:         role == nsIAccessibleRole::ROLE_COLUMNHEADER)
32381:       (*aColumnIndex)++;
32381:   }
32381: 
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULListCellAccessible::GetRowIndex(PRInt32 *aRowIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aRowIndex);
32381:   *aRowIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
52089:   nsAccessible* row = GetParent();
52089:   if (!row)
52089:     return NS_OK;
32381: 
52089:   nsAccessible* table = row->GetParent();
52089:   if (!table)
52089:     return NS_OK;
52089: 
52089:   *aRowIndex = 0;
52089: 
52089:   PRInt32 indexInTable = row->GetIndexInParent();
52089:   for (PRInt32 idx = 0; idx < indexInTable; idx++) {
52089:     row = table->GetChildAt(idx);
52089:     if (row->Role() == nsIAccessibleRole::ROLE_ROW)
32381:       (*aRowIndex)++;
32381:   }
32381: 
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULListCellAccessible::GetColumnExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 0;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   *aExtentCount = 1;
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULListCellAccessible::GetRowExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 0;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   *aExtentCount = 1;
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULListCellAccessible::GetColumnHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table;
32381:   GetTable(getter_AddRefs(table));
34948:   NS_ENSURE_STATE(table); // we expect to be in a listbox (table)
32381: 
32381:   // Get column header cell from XUL listhead.
42415:   nsAccessible *list = nsnull;
32381: 
42415:   nsRefPtr<nsAccessible> tableAcc(do_QueryObject(table));
42415:   PRInt32 tableChildCount = tableAcc->GetChildCount();
42415:   for (PRInt32 childIdx = 0; childIdx < tableChildCount; childIdx++) {
42415:     nsAccessible *child = tableAcc->GetChildAt(childIdx);
52089:     if (child->Role() == nsIAccessibleRole::ROLE_LIST) {
42415:       list = child;
32381:       break;
42415:     }
32381:   }
32381: 
32381:   if (list) {
32381:     PRInt32 colIdx = -1;
32381:     GetColumnIndex(&colIdx);
32381: 
42415:     nsIAccessible *headerCell = list->GetChildAt(colIdx);
32381:     if (headerCell) {
32381:       nsresult rv = NS_OK;
32381:       nsCOMPtr<nsIMutableArray> headerCells =
32381:         do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
32381:       NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:       headerCells->AppendElement(headerCell, PR_FALSE);
32381:       NS_ADDREF(*aHeaderCells = headerCells);
32381:       return NS_OK;
32381:     }
32381:   }
32381: 
32381:   // No column header cell from XUL markup, try to get it from ARIA markup.
32381:   return nsAccUtils::GetHeaderCellsFor(table, this,
32381:                                        nsAccUtils::eColumnHeaderCells,
32381:                                        aHeaderCells);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULListCellAccessible::GetRowHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table;
32381:   GetTable(getter_AddRefs(table));
34948:   NS_ENSURE_STATE(table); // we expect to be in a listbox (table)
32381: 
32381:   // Calculate row header cells from ARIA markup.
32381:   return nsAccUtils::GetHeaderCellsFor(table, this,
32381:                                        nsAccUtils::eRowHeaderCells,
32381:                                        aHeaderCells);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULListCellAccessible::IsSelected(PRBool *aIsSelected)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aIsSelected);
32381:   *aIsSelected = PR_FALSE;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table;
32381:   GetTable(getter_AddRefs(table));
34948:   NS_ENSURE_STATE(table); // we expect to be in a listbox (table)
32381: 
32381:   PRInt32 rowIdx = -1;
32381:   GetRowIndex(&rowIdx);
32381: 
32381:   return table->IsRowSelected(rowIdx, aIsSelected);
32381: }
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsXULListCellAccessible. nsAccessible implementation
32381: 
52027: PRUint32
52027: nsXULListCellAccessible::NativeRole()
11854: {
52027:   return nsIAccessibleRole::ROLE_CELL;
11854: }
11854: 
32381: nsresult
32381: nsXULListCellAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aAttributes);
    1: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
    1: 
32381:   // "table-cell-index" attribute
32381:   nsCOMPtr<nsIAccessibleTable> table;
32381:   GetTable(getter_AddRefs(table));
34948:   NS_ENSURE_STATE(table); // we expect to be in a listbox (table)
    1: 
32381:   PRInt32 rowIdx = -1;
32381:   GetRowIndex(&rowIdx);
32381:   PRInt32 colIdx = -1;
32381:   GetColumnIndex(&colIdx);
    1: 
32381:   PRInt32 cellIdx = -1;
32381:   table->GetCellIndexAt(rowIdx, colIdx, &cellIdx);
    1: 
32381:   nsAutoString stringIdx;
32381:   stringIdx.AppendInt(cellIdx);
32381:   nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::tableCellIndex,
32381:                          stringIdx);
    1: 
    1:   return NS_OK;
    1: }
