 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 25100:  * vim: set ts=8 sw=4 et tw=79:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS object implementation.
     1:  */
     1: #include <stdlib.h>
     1: #include <string.h>
 80468: 
 80468: #include "mozilla/Util.h"
 80468: 
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
 55477: #include "jshash.h"
     1: #include "jsprf.h"
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jsbool.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsfun.h"
     1: #include "jsgc.h"
     1: #include "jsinterp.h"
 43281: #include "jsiter.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
     1: #include "jsobj.h"
 67934: #include "jsonparser.h"
     1: #include "jsopcode.h"
 73746: #include "jsprobes.h"
 42733: #include "jsproxy.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: #include "jsstr.h"
 25215: #include "jsdbgapi.h"
 51457: #include "json.h"
 74472: #include "jswatchpoint.h"
 58714: #include "jswrapper.h"
 94006: #include "jsxml.h"
     1: 
 87812: #include "builtin/MapObject.h"
 80507: #include "frontend/BytecodeCompiler.h"
 80506: #include "frontend/Parser.h"
 98180: #include "frontend/TreeContext.h"
 97569: #include "gc/Marking.h"
 94006: #include "js/MemoryMetrics.h"
 94001: #include "vm/StringBuffer.h"
 94006: #include "vm/Xdr.h"
 80506: 
 77343: #include "jsarrayinlines.h"
 91234: #include "jsatominlines.h"
 98835: #include "jscntxtinlines.h"
 53840: #include "jsinterpinlines.h"
 84052: #include "jsobjinlines.h"
 34349: #include "jsscopeinlines.h"
 34349: #include "jsscriptinlines.h"
 34349: 
 90523: #include "vm/MethodGuard-inl.h"
 69242: 
 15453: #include "jsautooplen.h"
 15453: 
 80468: using namespace mozilla;
 37741: using namespace js;
 54707: using namespace js::gc;
 77343: using namespace js::types;
 37741: 
 84755: JS_STATIC_ASSERT(int32_t((JSObject::NELEMENTS_LIMIT - 1) * sizeof(Value)) == int64_t((JSObject::NELEMENTS_LIMIT - 1) * sizeof(Value)));
 84338: 
 77817: Class js::ObjectClass = {
     1:     js_Object_str,
 53557:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub
     1: };
     1: 
 48622: JS_FRIEND_API(JSObject *)
102586: JS_ObjectToInnerObject(JSContext *cx, JSObject *obj_)
102586: {
102586:     if (!obj_) {
 79734:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INACTIVE);
 79734:         return NULL;
 79734:     }
102586:     Rooted<JSObject*> obj(cx, obj_);
102586:     return GetInnerObject(cx, obj);
 79734: }
 79734: 
 79734: JS_FRIEND_API(JSObject *)
102586: JS_ObjectToOuterObject(JSContext *cx, JSObject *obj_)
102586: {
102586:     Rooted<JSObject*> obj(cx, obj_);
102586:     return GetOuterObject(cx, obj);
 48622: }
 48622: 
     1: #if JS_HAS_OBJ_PROTO_PROP
     1: 
     1: static JSBool
 98960: obj_getProto(JSContext *cx, HandleObject obj, HandleId id, Value *vp);
     1: 
     1: static JSBool
 98960: obj_setProto(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp);
     1: 
 78466: JSPropertySpec object_props[] = {
 78614:     {js_proto_str, 0, JSPROP_PERMANENT|JSPROP_SHARED, obj_getProto, obj_setProto},
     1:     {0,0,0,0,0}
     1: };
     1: 
     1: static JSBool
 98960: obj_getProto(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
 41968: {
 47455:     /* Let CheckAccess get the slot's value, based on the access mode. */
 91237:     unsigned attrs;
 99421:     RootedId nid(cx, NameToId(cx->runtime->atomState.protoAtom));
 98960:     return CheckAccess(cx, obj, nid, JSACC_PROTO, vp, &attrs);
     1: }
     1: 
 74914: size_t sSetProtoCalled = 0;
 74914: 
     1: static JSBool
 98960: obj_setProto(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp)
 98960: {
 74914:     if (!cx->runningWithTrustedPrincipals())
 74914:         ++sSetProtoCalled;
 74914: 
 54563:     /* ECMAScript 5 8.6.2 forbids changing [[Prototype]] if not [[Extensible]]. */
 54563:     if (!obj->isExtensible()) {
 54587:         obj->reportNotExtensible(cx);
 54563:         return false;
 54563:     }
 54563: 
 48470:     if (!vp->isObjectOrNull())
 89336:         return true;
 41968: 
 99421:     RootedObject pobj(cx, vp->toObjectOrNull());
 91237:     unsigned attrs;
 99421:     RootedId nid(cx, NameToId(cx->runtime->atomState.protoAtom));
 98960:     if (!CheckAccess(cx, obj, nid, JSAccessMode(JSACC_PROTO|JSACC_WRITE), vp, &attrs))
 89336:         return false;
 89336: 
 89336:     return SetProto(cx, obj, pobj, true);
     1: }
     1: 
     1: #else  /* !JS_HAS_OBJ_PROTO_PROP */
     1: 
     1: #define object_props NULL
     1: 
     1: #endif /* !JS_HAS_OBJ_PROTO_PROP */
     1: 
 90320: static bool
 97353: MarkSharpObjects(JSContext *cx, HandleObject obj, JSIdArray **idap, JSSharpInfo *value)
     1: {
101773:     JS_CHECK_RECURSION(cx, return false);
 88138: 
     1:     JSIdArray *ida;
 88138: 
 88138:     JSSharpObjectMap *map = &cx->sharpObjectMap;
 23915:     JS_ASSERT(map->depth >= 1);
 90320:     JSSharpInfo sharpid;
 90320:     JSSharpTable::Ptr p = map->table.lookup(obj);
 90320:     if (!p) {
 97353:         if (!map->table.put(obj.value(), sharpid))
 90320:             return false;
     1: 
     1:         ida = JS_Enumerate(cx, obj);
     1:         if (!ida)
 90320:             return false;
     1: 
 88138:         bool ok = true;
 99421:         RootedId id(cx);
 91450:         for (int i = 0, length = ida->length; i < length; i++) {
 98960:             id = ida->vector[i];
 88138:             JSObject *obj2;
 88138:             JSProperty *prop;
 80442:             ok = obj->lookupGeneric(cx, id, &obj2, &prop);
     1:             if (!ok)
     1:                 break;
     1:             if (!prop)
     1:                 continue;
 42834:             bool hasGetter, hasSetter;
 99421:             RootedValue valueRoot(cx), setterRoot(cx);
 99364:             Value &value = valueRoot.reference();
 99364:             Value &setter = setterRoot.reference();
 43202:             if (obj2->isNative()) {
 52503:                 const Shape *shape = (Shape *) prop;
 52503:                 hasGetter = shape->hasGetterValue();
 52503:                 hasSetter = shape->hasSetterValue();
 42834:                 if (hasGetter)
 97353:                     value = shape->getterValue();
 42834:                 if (hasSetter)
 97353:                     setter = shape->setterValue();
 42834:             } else {
 42834:                 hasGetter = hasSetter = false;
 42834:             }
 42834:             if (hasSetter) {
     1:                 /* Mark the getter, then set val to setter. */
 97353:                 if (hasGetter && value.isObject()) {
102586:                     Rooted<JSObject*> vobj(cx, &value.toObject());
102586:                     ok = MarkSharpObjects(cx, vobj, NULL, NULL);
     1:                     if (!ok)
     1:                         break;
 42834:                 }
 97353:                 value = setter;
 42834:             } else if (!hasGetter) {
 97353:                 ok = obj->getGeneric(cx, id, &value);
 42834:                 if (!ok)
 42834:                     break;
 42834:             }
102586:             if (value.isObject()) {
102586:                 Rooted<JSObject*> vobj(cx, &value.toObject());
102586:                 if (!MarkSharpObjects(cx, vobj, NULL, NULL)) {
 88138:                     ok = false;
     1:                     break;
     1:                 }
     1:             }
102586:         }
     1:         if (!ok || !idap)
     1:             JS_DestroyIdArray(cx, ida);
     1:         if (!ok)
 90320:             return false;
     1:     } else {
 90320:         if (!p->value.hasGen && !p->value.isSharp) {
 90320:             p->value.hasGen = true;
 90320:         }
 90320:         sharpid = p->value;
     1:         ida = NULL;
     1:     }
     1:     if (idap)
     1:         *idap = ida;
 90320:     if (value)
 90320:         *value = sharpid;
 90320:     return true;
 90320: }
 90320: 
 90320: bool
 97353: js_EnterSharpObject(JSContext *cx, HandleObject obj, JSIdArray **idap, bool *alreadySeen, bool *isSharp)
 88138: {
 25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
 90320:         return false;
     1: 
 88138:     *alreadySeen = false;
 88138: 
 88138:     JSSharpObjectMap *map = &cx->sharpObjectMap;
 90320: 
 90320:     JS_ASSERT_IF(map->depth == 0, map->table.count() == 0);
 90320:     JS_ASSERT_IF(map->table.count() == 0, map->depth == 0);
 90320: 
 90320:     JSSharpTable::Ptr p;
 90320:     JSSharpInfo sharpid;
 88138:     JSIdArray *ida = NULL;
 88138: 
     1:     /* From this point the control must flow either through out: or bad:. */
     1:     if (map->depth == 0) {
 90320:         JS_KEEP_ATOMS(cx->runtime);
 90320: 
 23915:         /*
 23915:          * Although MarkSharpObjects tries to avoid invoking getters,
 23915:          * it ends up doing so anyway under some circumstances; for
 23915:          * example, if a wrapped object has getters, the wrapper will
 23915:          * prevent MarkSharpObjects from recognizing them as such.
 23915:          * This could lead to js_LeaveSharpObject being called while
 23915:          * MarkSharpObjects is still working.
 23915:          *
 23915:          * Increment map->depth while we call MarkSharpObjects, to
 23915:          * ensure that such a call doesn't free the hash table we're
 23915:          * still using.
 23915:          */
 90320:         map->depth = 1;
 90320:         bool success = MarkSharpObjects(cx, obj, &ida, &sharpid);
 90320:         JS_ASSERT(map->depth == 1);
 90320:         map->depth = 0;
 90320:         if (!success)
     1:             goto bad;
 90320:         JS_ASSERT(!sharpid.isSharp);
     1:         if (!idap) {
     1:             JS_DestroyIdArray(cx, ida);
     1:             ida = NULL;
     1:         }
     1:     } else {
     1:         /*
     1:          * It's possible that the value of a property has changed from the
     1:          * first time the object's properties are traversed (when the property
     1:          * ids are entered into the hash table) to the second (when they are
 31501:          * converted to strings), i.e., the JSObject::getProperty() call is not
     1:          * idempotent.
     1:          */
 90320:         p = map->table.lookup(obj);
 90320:         if (!p) {
 97353:             if (!map->table.put(obj.value(), sharpid))
     1:                 goto bad;
     1:             goto out;
     1:         }
 90320:         sharpid = p->value;
 90320:     }
 90320: 
 90320:     if (sharpid.isSharp || sharpid.hasGen)
 88138:         *alreadySeen = true;
     1: 
     1: out:
 90320:     if (!sharpid.isSharp) {
     1:         if (idap && !ida) {
     1:             ida = JS_Enumerate(cx, obj);
 88138:             if (!ida)
     1:                 goto bad;
     1:         }
     1:         map->depth++;
     1:     }
     1: 
     1:     if (idap)
     1:         *idap = ida;
 90320:     *isSharp = sharpid.isSharp;
 90320:     return true;
     1: 
     1: bad:
     1:     /* Clean up the sharpObjectMap table on outermost error. */
     1:     if (map->depth == 0) {
     1:         JS_UNKEEP_ATOMS(cx->runtime);
     1:         map->sharpgen = 0;
 90320:         map->table.clear();
 90320:     }
 90320:     return false;
     1: }
     1: 
     1: void
     1: js_LeaveSharpObject(JSContext *cx, JSIdArray **idap)
     1: {
 88138:     JSSharpObjectMap *map = &cx->sharpObjectMap;
     1:     JS_ASSERT(map->depth > 0);
     1:     if (--map->depth == 0) {
     1:         JS_UNKEEP_ATOMS(cx->runtime);
     1:         map->sharpgen = 0;
 90320:         map->table.clear();
     1:     }
     1:     if (idap) {
 88138:         if (JSIdArray *ida = *idap) {
     1:             JS_DestroyIdArray(cx, ida);
     1:             *idap = NULL;
     1:         }
     1:     }
     1: }
     1: 
     1: void
   583: js_TraceSharpMap(JSTracer *trc, JSSharpObjectMap *map)
     1: {
     1:     JS_ASSERT(map->depth > 0);
     1: 
     1:     /*
     1:      * During recursive calls to MarkSharpObjects a non-native object or
     1:      * object with a custom getProperty method can potentially return an
     1:      * unrooted value or even cut from the object graph an argument of one of
     1:      * MarkSharpObjects recursive invocations. So we must protect map->table
     1:      * entries against GC.
     1:      *
     1:      * We can not simply use JSTempValueRooter to mark the obj argument of
     1:      * MarkSharpObjects during recursion as we have to protect *all* entries
     1:      * in JSSharpObjectMap including those that contains otherwise unreachable
     1:      * objects just allocated through custom getProperty. Otherwise newer
     1:      * allocations can re-use the address of an object stored in the hashtable
     1:      * confusing js_EnterSharpObject. So to address the problem we simply
     1:      * mark all objects from map->table.
     1:      *
     1:      * An alternative "proper" solution is to use JSTempValueRooter in
     1:      * MarkSharpObjects with code to remove during finalization entries
     1:      * with otherwise unreachable objects. But this is way too complex
     1:      * to justify spending efforts.
     1:      */
 90409:     for (JSSharpTable::Range r = map->table.all(); !r.empty(); r.popFront()) {
 90409:         JSObject *tmp = r.front().key;
 90409:         MarkObjectRoot(trc, &tmp, "sharp table entry");
 90409:         JS_ASSERT(tmp == r.front().key);
 90409:     }
     1: }
     1: 
     1: #if JS_HAS_TOSOURCE
  4127: static JSBool
 91237: obj_toSource(JSContext *cx, unsigned argc, Value *vp)
     1: {
 89633:     bool comma = false;
 89633:     const jschar *vchars;
 89633:     size_t vlength;
 48470:     Value *val;
     1:     JSString *gsop[2];
 11139: 
 11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
     1: 
 48470:     Value localroot[4];
 48470:     PodArrayZero(localroot);
 80468:     AutoArrayRooter tvr(cx, ArrayLength(localroot), localroot);
     1: 
     1:     /* If outermost, we need parentheses to be an expression, not a block. */
 88138:     bool outermost = (cx->sharpObjectMap.depth == 0);
 61734: 
 99421:     RootedObject obj(cx, ToObject(cx, &vp[1]));
 61734:     if (!obj)
 61734:         return false;
 61734: 
 88138:     JSIdArray *ida;
 88138:     bool alreadySeen = false;
 90320:     bool isSharp = false;
 90320:     if (!js_EnterSharpObject(cx, obj, &ida, &alreadySeen, &isSharp))
 82308:         return false;
 82308: 
 69323:     if (!ida) {
     1:         /*
 88138:          * We've already seen obj, so don't serialize it again (particularly as
 88138:          * we might recur in the process): just serialize an empty object.
     1:          */
 88138:         JS_ASSERT(alreadySeen);
 88138:         JSString *str = js_NewStringCopyZ(cx, "{}");
 88138:         if (!str)
 88138:             return false;
 88138:         vp->setString(str);
 88138:         return true;
     1:     }
 90320: 
 90320:     JS_ASSERT(!isSharp);
 90320:     if (alreadySeen) {
 90320:         JSSharpTable::Ptr p = cx->sharpObjectMap.table.lookup(obj);
 90320:         JS_ASSERT(p);
 90320:         JS_ASSERT(!p->value.isSharp);
 90320:         p->value.isSharp = true;
 90320:     }
 88138: 
 89633:     /* Automatically call js_LeaveSharpObject when we leave this frame. */
 89633:     class AutoLeaveSharpObject {
 89633:         JSContext *cx;
 89633:         JSIdArray *ida;
 89633:       public:
 89633:         AutoLeaveSharpObject(JSContext *cx, JSIdArray *ida) : cx(cx), ida(ida) {}
 89633:         ~AutoLeaveSharpObject() {
 89633:             js_LeaveSharpObject(cx, &ida);
 89633:         }
 89633:     } autoLeaveSharpObject(cx, ida);
 89633: 
 89633:     StringBuffer buf(cx);
 89633:     if (outermost && !buf.append('('))
 89633:         return false;
 89633:     if (!buf.append('{'))
 89633:         return false;
     1: 
     1:     /*
     1:      * We have four local roots for cooked and raw value GC safety.  Hoist the
  6917:      * "localroot + 2" out of the loop using the val local, which refers to
  6917:      * the raw (unconverted, "uncooked") values.
     1:      */
  6917:     val = localroot + 2;
     1: 
 99421:     RootedId id(cx);
 91450:     for (int i = 0; i < ida->length; i++) {
  4127:         /* Get strings for id and value and GC-root them via vp. */
 98960:         id = ida->vector[i];
 89633:         JSLinearString *idstr;
 40855: 
 88138:         JSObject *obj2;
 88138:         JSProperty *prop;
 89633:         if (!obj->lookupGeneric(cx, id, &obj2, &prop))
 89633:             return false;
   969: 
   969:         /*
 48470:          * Convert id to a value and then to a string.  Decide early whether we
   969:          * prefer get/set or old getter/setter syntax.
   969:          */
 84160:         JSString *s = ToString(cx, IdToValue(id));
 89633:         if (!s || !(idstr = s->ensureLinear(cx)))
 89633:             return false;
 40855: 
 89633:         int valcnt = 0;
     1:         if (prop) {
 43183:             bool doGet = true;
 43202:             if (obj2->isNative()) {
 52503:                 const Shape *shape = (Shape *) prop;
 52503:                 unsigned attrs = shape->attributes();
     1:                 if (attrs & JSPROP_GETTER) {
 43183:                     doGet = false;
 52503:                     val[valcnt] = shape->getterValue();
 64345:                     gsop[valcnt] = cx->runtime->atomState.getAtom;
  1677:                     valcnt++;
     1:                 }
     1:                 if (attrs & JSPROP_SETTER) {
 43183:                     doGet = false;
 52503:                     val[valcnt] = shape->setterValue();
 64345:                     gsop[valcnt] = cx->runtime->atomState.setAtom;
     1:                     valcnt++;
  1677:                 }
 43183:             }
 43183:             if (doGet) {
     1:                 valcnt = 1;
     1:                 gsop[0] = NULL;
 89633:                 if (!obj->getGeneric(cx, id, &val[0]))
 89633:                     return false;
 43183:             }
 43183:         }
     1: 
     1:         /*
 40855:          * If id is a string that's not an identifier, or if it's a negative
 40855:          * integer, then it must be quoted.
     1:          */
  4529:         if (JSID_IS_ATOM(id)
 89633:             ? !IsIdentifier(idstr)
  4529:             : (!JSID_IS_INT(id) || JSID_TO_INT(id) < 0)) {
 59890:             s = js_QuoteString(cx, idstr, jschar('\''));
 89633:             if (!s || !(idstr = s->ensureLinear(cx)))
 89633:                 return false;
     1:         }
 89633: 
 89633:         for (int j = 0; j < valcnt; j++) {
 40855:             /*
 40855:              * Censor an accessor descriptor getter or setter part if it's
 40855:              * undefined.
 40855:              */
 48470:             if (gsop[j] && val[j].isUndefined())
 40855:                 continue;
 40855: 
     1:             /* Convert val[j] to its canonical source form. */
 89633:             JSString *valstr = js_ValueToSource(cx, val[j]);
 89633:             if (!valstr)
 89633:                 return false;
 48470:             localroot[j].setString(valstr);             /* local root */
 59890:             vchars = valstr->getChars(cx);
 89633:             if (!vchars)
 89633:                 return false;
 59890:             vlength = valstr->length();
     1: 
 40855:             /*
  2149:              * Remove '(function ' from the beginning of valstr and ')' from the
  2149:              * end so that we can put "get" in front of the function definition.
  2149:              */
 48470:             if (gsop[j] && IsFunctionObject(val[j])) {
  2149:                 const jschar *start = vchars;
  2149:                 const jschar *end = vchars + vlength;
  2149: 
 84755:                 uint8_t parenChomp = 0;
  2149:                 if (vchars[0] == '(') {
  2149:                     vchars++;
  2149:                     parenChomp = 1;
  2149:                 }
  2149: 
  2149:                 /* Try to jump "function" keyword. */
  2149:                 if (vchars)
  2149:                     vchars = js_strchr_limit(vchars, ' ', end);
  2149: 
 40855:                 /*
 40855:                  * Jump over the function's name: it can't be encoded as part
 40855:                  * of an ECMA getter or setter.
 40855:                  */
 40855:                 if (vchars)
 40855:                     vchars = js_strchr_limit(vchars, '(', end);
 40855: 
  2149:                 if (vchars) {
  2149:                     if (*vchars == ' ')
  2149:                         vchars++;
  2149:                     vlength = end - vchars - parenChomp;
  2149:                 } else {
  2149:                     gsop[j] = NULL;
  2149:                     vchars = start;
  2149:                 }
  2149:             }
  2149: 
 89633:             if (comma && !buf.append(", "))
 89633:                 return false;
 89633:             comma = true;
 89633: 
     1:             if (gsop[j])
 89633:                 if (!buf.append(gsop[j]) || !buf.append(' '))
 89633:                     return false;
 89633: 
 89633:             if (!buf.append(idstr))
 89633:                 return false;
 89633:             if (!buf.append(gsop[j] ? ' ' : ':'))
 89633:                 return false;
 89633: 
 89633:             if (!buf.append(vchars, vlength))
 89633:                 return false;
 89633:         }
 89633:     }
 89633: 
 89633:     if (!buf.append('}'))
 89633:         return false;
 89633:     if (outermost && !buf.append(')'))
 89633:         return false;
 89633: 
 89633:     JSString *str = buf.finishString();
 89633:     if (!str)
 89633:         return false;
 48470:     vp->setString(str);
 82308:     return true;
     1: }
     1: #endif /* JS_HAS_TOSOURCE */
     1: 
 47498: namespace js {
 47498: 
 47498: JSString *
 47498: obj_toStringHelper(JSContext *cx, JSObject *obj)
 47498: {
 47498:     if (obj->isProxy())
 79386:         return Proxy::obj_toString(cx, obj);
 47498: 
 84052:     StringBuffer sb(cx);
 84052:     const char *className = obj->getClass()->name;
 84052:     if (!sb.append("[object ") || !sb.appendInflated(className, strlen(className)) ||
 84052:         !sb.append("]"))
 84052:     {
 47498:         return NULL;
 84052:     }
 84052:     return sb.finishString();
 47498: }
 47498: 
 68911: JSObject *
 68911: NonNullObject(JSContext *cx, const Value &v)
 68911: {
 68911:     if (v.isPrimitive()) {
 68911:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
 68911:         return NULL;
 68911:     }
 68911:     return &v.toObject();
 68911: }
 68911: 
 75433: const char *
 75433: InformalValueTypeName(const Value &v)
 75433: {
 76241:     if (v.isObject())
 76241:         return v.toObject().getClass()->name;
 76241:     if (v.isString())
 76241:         return "string";
 76241:     if (v.isNumber())
 76241:         return "number";
 76241:     if (v.isBoolean())
 76241:         return "boolean";
 76241:     if (v.isNull())
 76241:         return "null";
 76241:     if (v.isUndefined())
 76241:         return "undefined";
 76241:     return "value";
 76241: }
 76241: 
 76241: } /* namespace js */
 47498: 
 55714: /* ES5 15.2.4.2.  Note steps 1 and 2 are errata. */
 47498: static JSBool
 91237: obj_toString(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 55714:     Value &thisv = vp[1];
 55714: 
 61734:     /* Step 1. */
 55714:     if (thisv.isUndefined()) {
 64345:         vp->setString(cx->runtime->atomState.objectUndefinedAtom);
 55714:         return true;
 55714:     }
 55714: 
 61734:     /* Step 2. */
 55714:     if (thisv.isNull()) {
 64345:         vp->setString(cx->runtime->atomState.objectNullAtom);
 55714:         return true;
 55714:     }
 55714: 
 61734:     /* Step 3. */
 61734:     JSObject *obj = ToObject(cx, &thisv);
 61734:     if (!obj)
 47498:         return false;
 47498: 
 61734:     /* Steps 4-5. */
 61734:     JSString *str = js::obj_toStringHelper(cx, obj);
 47498:     if (!str)
 47498:         return false;
 48470:     vp->setString(str);
 47498:     return true;
     1: }
     1: 
 69828: /* ES5 15.2.4.3. */
     1: static JSBool
 91237: obj_toLocaleString(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 69828:     JS_CHECK_RECURSION(cx, return false);
 69828: 
 69828:     /* Step 1. */
 61734:     JSObject *obj = ToObject(cx, &vp[1]);
 61734:     if (!obj)
 61734:         return false;
 61734: 
 69828:     /* Steps 2-4. */
 99421:     RootedId id(cx, NameToId(cx->runtime->atomState.toStringAtom));
 98960:     return obj->callMethod(cx, id, 0, NULL, vp);
     1: }
     1: 
     1: static JSBool
 91237: obj_valueOf(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 61734:     JSObject *obj = ToObject(cx, &vp[1]);
 61734:     if (!obj)
 61734:         return false;
 61734:     vp->setObject(*obj);
 61734:     return true;
     1: }
     1: 
 68932: /* We should be able to assert this for *any* fp->scopeChain(). */
 68894: static void
 68932: AssertInnerizedScopeChain(JSContext *cx, JSObject &scopeobj)
 68894: {
 68894: #ifdef DEBUG
 86483:     for (JSObject *o = &scopeobj; o; o = o->enclosingScope()) {
102586:         if (JSObjectOp op = o->getClass()->ext.innerObject) {
102586:             Rooted<JSObject*> obj(cx, o);
102586:             JS_ASSERT(op(cx, obj) == o);
102586:         }
 68894:     }
 68894: #endif
 12690: }
 12690: 
 24375: #ifndef EVAL_CACHE_CHAIN_LIMIT
 24375: # define EVAL_CACHE_CHAIN_LIMIT 4
 24375: #endif
 24375: 
 97468: void
 97468: EvalCache::purge()
 97468: {
 97468:     /*
 97468:      * Purge all scripts from the eval cache. In addition to removing them from
 97468:      * table_, null out the evalHashLink field of any script removed. Since
 97468:      * evalHashLink is in a union with globalObject, this allows the GC to
 97468:      * indiscriminately use the union as a nullable globalObject pointer.
 97468:      */
 97468:     for (size_t i = 0; i < ArrayLength(table_); ++i) {
 97468:         for (JSScript **listHeadp = &table_[i]; *listHeadp; ) {
 97468:             JSScript *script = *listHeadp;
 97468:             JS_ASSERT(GetGCThingTraceKind(script) == JSTRACE_SCRIPT);
 97468:             *listHeadp = script->evalHashLink();
 97468:             script->evalHashLink() = NULL;
 97468:         }
 97468:     }
 97468: }
 97468: 
 97468: inline JSScript **
 97468: EvalCache::bucket(JSLinearString *str)
 59890: {
 59890:     const jschar *s = str->chars();
 59890:     size_t n = str->length();
 59890: 
 24375:     if (n > 100)
 24375:         n = 100;
 84755:     uint32_t h;
 24375:     for (h = 0; n; s++, n--)
 91527:         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
 91527: 
 91527:     h *= JS_GOLDEN_RATIO;
 97468:     h >>= 32 - SHIFT;
 97468:     JS_ASSERT(h < ArrayLength(table_));
 97468:     return &table_[h];
 24375: }
 24375: 
 55553: static JS_ALWAYS_INLINE JSScript *
 91237: EvalCacheLookup(JSContext *cx, JSLinearString *str, StackFrame *caller, unsigned staticLevel,
 68893:                 JSPrincipals *principals, JSObject &scopeobj, JSScript **bucket)
 55553: {
 55553:     /*
 55553:      * Cache local eval scripts indexed by source qualified by scope.
 55553:      *
 55553:      * An eval cache entry should never be considered a hit unless its
 55553:      * strictness matches that of the new eval code. The existing code takes
 55553:      * care of this, because hits are qualified by the function from which
 59939:      * eval was called, whose strictness doesn't change. (We don't cache evals
 59939:      * in eval code, so the calling function corresponds to the calling script,
 59939:      * and its strictness never varies.) Scripts produced by calls to eval from
 59939:      * global code aren't cached.
 59939:      *
 59939:      * FIXME bug 620141: Qualify hits by calling script rather than function.
 59939:      * Then we wouldn't need the unintuitive !isEvalFrame() hack in EvalKernel
 59939:      * to avoid caching nested evals in functions (thus potentially mismatching
 59939:      * on strict mode), and we could cache evals in global code if desired.
 55553:      */
 91237:     unsigned count = 0;
 55553:     JSScript **scriptp = bucket;
 55553: 
 55553:     JSVersion version = cx->findVersion();
 55553:     JSScript *script;
 91900:     JSSubsumePrincipalsOp subsume = cx->runtime->securityCallbacks->subsumePrincipals;
 55553:     while ((script = *scriptp) != NULL) {
 55553:         if (script->savedCallerFun &&
 55553:             script->staticLevel == staticLevel &&
 61450:             script->getVersion() == version &&
 59962:             !script->hasSingletons &&
 91900:             (!subsume || script->principals == principals ||
 91900:              (subsume(principals, script->principals) &&
 91900:               subsume(script->principals, principals)))) {
 55553:             /*
 55553:              * Get the prior (cache-filling) eval's saved caller function.
 80991:              * See frontend::CompileScript.
 55553:              */
 75519:             JSFunction *fun = script->getCallerFunction();
 55553: 
 55553:             if (fun == caller->fun()) {
 55553:                 /*
 80634:                  * Get the source string passed for safekeeping in the atom map
 80991:                  * by the prior eval to frontend::CompileScript.
 55553:                  */
 77659:                 JSAtom *src = script->atoms[0];
 59890: 
 59890:                 if (src == str || EqualStrings(src, str)) {
 55553:                     /*
 83244:                      * Source matches. Make sure there are no inner objects
 83244:                      * which might use the wrong parent and/or call scope by
 83244:                      * reusing the previous eval's script. Skip the script's
 83244:                      * first object, which entrains the eval's scope.
 83244:                      */
 83244:                     JS_ASSERT(script->objects()->length >= 1);
 83244:                     if (script->objects()->length == 1 &&
 97361:                         !script->hasRegexps()) {
 55553:                         JS_ASSERT(staticLevel == script->staticLevel);
 82129:                         *scriptp = script->evalHashLink();
 82129:                         script->evalHashLink() = NULL;
 55553:                         return script;
 55553:                     }
 55553:                 }
 55553:             }
 55553:         }
 55553: 
 55553:         if (++count == EVAL_CACHE_CHAIN_LIMIT)
 55553:             return NULL;
 82129:         scriptp = &script->evalHashLink();
 55553:     }
 55553:     return NULL;
 55553: }
 55553: 
 56775: /*
 68894:  * There are two things we want to do with each script executed in EvalKernel:
 68894:  *  1. notify jsdbgapi about script creation/destruction
 68894:  *  2. add the script to the eval cache when EvalKernel is finished
 68894:  *
 68894:  * NB: Although the eval cache keeps a script alive wrt to the JS engine, from
 68894:  * a jsdbgapi user's perspective, we want each eval() to create and destroy a
 68894:  * script. This hides implementation details and means we don't have to deal
 68894:  * with calls to JS_GetScriptObject for scripts in the eval cache (currently,
 82129:  * script->object aliases script->evalHashLink()).
 56775:  */
 68894: class EvalScriptGuard
 68894: {
 68894:     JSContext *cx_;
 68894:     JSLinearString *str_;
 68894:     JSScript **bucket_;
 99421:     Rooted<JSScript*> script_;
 68894: 
 68894:   public:
 68894:     EvalScriptGuard(JSContext *cx, JSLinearString *str)
 68894:       : cx_(cx),
 68894:         str_(str),
 95355:         script_(cx) {
 97468:         bucket_ = cx->runtime->evalCache.bucket(str);
 68894:     }
 68894: 
 68894:     ~EvalScriptGuard() {
 68894:         if (script_) {
 94740:             CallDestroyScriptHook(cx_->runtime->defaultFreeOp(), script_);
 77343:             script_->isActiveEval = false;
 77343:             script_->isCachedEval = true;
 82129:             script_->evalHashLink() = *bucket_;
 68894:             *bucket_ = script_;
 68894:         }
 68894:     }
 68894: 
 91237:     void lookupInEvalCache(StackFrame *caller, unsigned staticLevel,
 68894:                            JSPrincipals *principals, JSObject &scopeobj) {
 68894:         if (JSScript *found = EvalCacheLookup(cx_, str_, caller, staticLevel,
 68894:                                               principals, scopeobj, bucket_)) {
 68894:             js_CallNewScriptHook(cx_, found, NULL);
 68894:             script_ = found;
 77343:             script_->isCachedEval = false;
 77343:             script_->isActiveEval = true;
 68894:         }
 68894:     }
 68894: 
 68894:     void setNewScript(JSScript *script) {
102045:         /* JSScript::initFromEmitter has already called js_CallNewScriptHook. */
 68894:         JS_ASSERT(!script_ && script);
 68894:         script_ = script;
 77343:         script_->isActiveEval = true;
 68894:     }
 68894: 
 68894:     bool foundScript() {
 68894:         return !!script_;
 68894:     }
 68894: 
 68894:     JSScript *script() const {
 68894:         JS_ASSERT(script_);
 68894:         return script_;
 68894:     }
 68894: };
 68894: 
 71695: /* Define subset of ExecuteType so that casting performs the injection. */
 71695: enum EvalType { DIRECT_EVAL = EXECUTE_DIRECT_EVAL, INDIRECT_EVAL = EXECUTE_INDIRECT_EVAL };
 71695: 
 68894: /*
 68894:  * Common code implementing direct and indirect eval.
 68894:  *
 68894:  * Evaluate call.argv[2], if it is a string, in the context of the given calling
 68894:  * frame, with the provided scope chain, with the semantics of either a direct
 68894:  * or indirect eval (see ES5 10.4.2).  If this is an indirect eval, scopeobj
 68894:  * must be a global object.
 68894:  *
 68894:  * On success, store the completion value in call.rval and return true.
 68894:  */
 68894: static bool
 79387: EvalKernel(JSContext *cx, const CallArgs &args, EvalType evalType, StackFrame *caller,
 95355:            HandleObject scopeobj)
 56775: {
 68894:     JS_ASSERT((evalType == INDIRECT_EVAL) == (caller == NULL));
 98921:     JS_ASSERT_IF(evalType == INDIRECT_EVAL, scopeobj->isGlobal());
 95355:     AssertInnerizedScopeChain(cx, *scopeobj);
 95355: 
 95355:     if (!scopeobj->global().isRuntimeCodeGenEnabled(cx)) {
 82739:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CSP_BLOCKED_EVAL);
 55553:         return false;
 39061:     }
 39061: 
 56775:     /* ES5 15.1.2.1 step 1. */
 79387:     if (args.length() < 1) {
 79387:         args.rval().setUndefined();
 56775:         return true;
 56775:     }
 79387:     if (!args[0].isString()) {
 79387:         args.rval() = args[0];
 56775:         return true;
 56775:     }
 79387:     JSString *str = args[0].toString();
 56775: 
 56775:     /* ES5 15.1.2.1 steps 2-8. */
 56775: 
 56775:     /*
 56775:      * Per ES5, indirect eval runs in the global scope. (eval is specified this
 56775:      * way so that the compiler can make assumptions about what bindings may or
 56775:      * may not exist in the current frame if it doesn't see 'eval'.)
 56775:      */
 91237:     unsigned staticLevel;
 99421:     RootedValue thisv(cx);
 56775:     if (evalType == DIRECT_EVAL) {
 56775:         staticLevel = caller->script()->staticLevel + 1;
 56775: 
 71695:         /*
 71695:          * Direct calls to eval are supposed to see the caller's |this|. If we
 71695:          * haven't wrapped that yet, do so now, before we make a copy of it for
 71695:          * the eval code to use.
 71695:          */
 71695:         if (!ComputeThis(cx, caller))
 71695:             return false;
 71695:         thisv = caller->thisValue();
 71695: 
 56775: #ifdef DEBUG
 71363:         jsbytecode *callerPC = caller->pcQuadratic(cx);
 84195:         JS_ASSERT(callerPC && JSOp(*callerPC) == JSOP_EVAL);
 56775: #endif
 56775:     } else {
 95355:         JS_ASSERT(args.callee().global() == *scopeobj);
 56775:         staticLevel = 0;
 71695: 
 71695:         /* Use the global as 'this', modulo outerization. */
 95355:         JSObject *thisobj = scopeobj->thisObject(cx);
 71695:         if (!thisobj)
 71695:             return false;
 71695:         thisv = ObjectValue(*thisobj);
 68894:     }
 55532: 
 99421:     Rooted<JSLinearString*> linearStr(cx, str->ensureLinear(cx));
 59890:     if (!linearStr)
 59890:         return false;
 59890:     const jschar *chars = linearStr->chars();
 59890:     size_t length = linearStr->length();
 51457: 
 97353:     SkipRoot skip(cx, &chars);
 97353: 
 51457:     /*
 84494:      * If the eval string starts with '(' or '[' and ends with ')' or ']', it may be JSON.
 51457:      * Try the JSON parser first because it's much faster.  If the eval string
 51457:      * isn't JSON, JSON parsing will probably fail quickly, so little time
 51457:      * will be lost.
 70299:      *
 70299:      * Don't use the JSON parser if the caller is strict mode code, because in
 70299:      * strict mode object literals must not have repeated properties, and the
 70299:      * JSON parser cheerfully (and correctly) accepts them.  If you're parsing
 70299:      * JSON with eval and using strict mode, you deserve to be slow.
 51457:      */
 70299:     if (length > 2 &&
 84494:         ((chars[0] == '[' && chars[length - 1] == ']') ||
 84494:         (chars[0] == '(' && chars[length - 1] == ')')) &&
 70299:          (!caller || !caller->script()->strictModeCode))
 70299:     {
 71691:         /*
 71691:          * Remarkably, JavaScript syntax is not a superset of JSON syntax:
 71691:          * strings in JavaScript cannot contain the Unicode line and paragraph
 71691:          * terminator characters U+2028 and U+2029, but strings in JSON can.
 71691:          * Rather than force the JSON parser to handle this quirk when used by
 71691:          * eval, we simply don't use the JSON parser when either character
 71691:          * appears in the provided string.  See bug 657367.
 71691:          */
 71691:         for (const jschar *cp = &chars[1], *end = &chars[length - 2]; ; cp++) {
 71691:             if (*cp == 0x2028 || *cp == 0x2029)
 71691:                 break;
 71691: 
 71691:             if (cp == end) {
 84494:                 bool isArray = (chars[0] == '[');
 84494:                 JSONParser parser(cx, isArray ? chars : chars + 1, isArray ? length : length - 2,
 71691:                                   JSONParser::StrictJSON, JSONParser::NoError);
 68894:                 Value tmp;
 68894:                 if (!parser.parse(&tmp))
 68894:                     return false;
 71691:                 if (tmp.isUndefined())
 71691:                     break;
 79387:                 args.rval() = tmp;
 67934:                 return true;
 68894:             }
 55553:         }
 71691:     }
 55553: 
 68894:     EvalScriptGuard esg(cx, linearStr);
 68894: 
 79387:     JSPrincipals *principals = PrincipalsForCompiledCode(args, cx);
 68894: 
 68894:     if (evalType == DIRECT_EVAL && caller->isNonEvalFunctionFrame())
 95355:         esg.lookupInEvalCache(caller, staticLevel, principals, *scopeobj);
 68894: 
 68894:     if (!esg.foundScript()) {
 91237:         unsigned lineno;
 84691:         const char *filename;
 84691:         JSPrincipals *originPrincipals;
 84691:         CurrentScriptFileLineOrigin(cx, &filename, &lineno, &originPrincipals,
 84691:                                     evalType == DIRECT_EVAL ? CALLED_FROM_JSOP_EVAL
 68894:                                                             : NOT_CALLED_FROM_JSOP_EVAL);
 98463: 
 98463:         bool compileAndGo = true;
 98463:         bool noScriptRval = false;
 98463:         bool needScriptGlobal = false;
 95355:         JSScript *compiled = frontend::CompileScript(cx, scopeobj, caller,
 84691:                                                      principals, originPrincipals,
 98463:                                                      compileAndGo, noScriptRval, needScriptGlobal,
 98463:                                                      chars, length, filename,
 80634:                                                      lineno, cx->findVersion(), linearStr,
 80634:                                                      staticLevel);
 68894:         if (!compiled)
 68894:             return false;
 68894: 
 68894:         esg.setNewScript(compiled);
 68894:     }
 68894: 
 95355:     return ExecuteKernel(cx, esg.script(), *scopeobj, thisv, ExecuteType(evalType),
 79387:                          NULL /* evalInFrame */, &args.rval());
 68894: }
 24375: 
 33281: /*
 68894:  * We once supported a second argument to eval to use as the scope chain
 68894:  * when evaluating the code string.  Warn when such uses are seen so that
 68894:  * authors will know that support for eval(s, o) has been removed.
 62571:  */
 68894: static inline bool
 79387: WarnOnTooManyArgs(JSContext *cx, const CallArgs &args)
 79387: {
 79387:     if (args.length() > 1) {
 77343:         if (JSScript *script = cx->stack.currentScript()) {
 77343:             if (!script->warnedAboutTwoArgumentEval) {
 68894:                 static const char TWO_ARGUMENT_WARNING[] =
 68894:                     "Support for eval(code, scopeObject) has been removed. "
 68894:                     "Use |with (scopeObject) eval(code);| instead.";
 68894:                 if (!JS_ReportWarning(cx, TWO_ARGUMENT_WARNING))
 68894:                     return false;
 77343:                 script->warnedAboutTwoArgumentEval = true;
 68894:             }
 68894:         } else {
 62571:             /*
 68894:              * In the case of an indirect call without a caller frame, avoid a
 68894:              * potential warning-flood by doing nothing.
 33281:              */
 68894:         }
 68894:     }
 68894: 
 68894:     return true;
 68894: }
 55482: 
 78466: namespace js {
 78466: 
     1: /*
 68894:  * ES5 15.1.2.1.
 68894:  *
 68894:  * NB: This method handles only indirect eval.
     1:  */
 78466: JSBool
 91237: eval(JSContext *cx, unsigned argc, Value *vp)
 68894: {
 79387:     CallArgs args = CallArgsFromVp(argc, vp);
102586:     if (!WarnOnTooManyArgs(cx, args))
102586:         return false;
102586: 
102586:     Rooted<GlobalObject*> global(cx, &args.callee().global());
102586:     return EvalKernel(cx, args, INDIRECT_EVAL, NULL, global);
 68894: }
 68894: 
 68894: bool
 79387: DirectEval(JSContext *cx, const CallArgs &args)
 68894: {
 68894:     /* Direct eval can assume it was called from an interpreted frame. */
 69223:     StackFrame *caller = cx->fp();
 68894:     JS_ASSERT(caller->isScriptFrame());
 96793:     JS_ASSERT(IsBuiltinEvalForScope(caller->scopeChain(), args.calleev()));
 84195:     JS_ASSERT(JSOp(*cx->regs().pc) == JSOP_EVAL);
 68894: 
 83234:     AutoFunctionCallProbe callProbe(cx, args.callee().toFunction(), caller->script());
 68894: 
 86077:     if (!WarnOnTooManyArgs(cx, args))
 86077:         return false;
 86077: 
 98921:     return EvalKernel(cx, args, DIRECT_EVAL, caller, caller->scopeChain());
     1: }
     1: 
 64210: bool
 64228: IsBuiltinEvalForScope(JSObject *scopeChain, const Value &v)
 64228: {
 86483:     return scopeChain->global().getOriginalEval() == v;
 64228: }
 64228: 
 64228: bool
 64228: IsAnyBuiltinEval(JSFunction *fun)
 56556: {
 56556:     return fun->maybeNative() == eval;
 56556: }
 56556: 
 68894: JSPrincipals *
 79387: PrincipalsForCompiledCode(const CallReceiver &call, JSContext *cx)
 68894: {
 83234:     JS_ASSERT(IsAnyBuiltinEval(call.callee().toFunction()) ||
 83234:               IsBuiltinFunctionConstructor(call.callee().toFunction()));
 68894: 
 68894:     /*
 68894:      * To compute the principals of the compiled eval/Function code, we simply
 68894:      * use the callee's principals. To see why the caller's principals are
 68894:      * ignored, consider first that, in the capability-model we assume, the
 68894:      * high-privileged eval/Function should never have escaped to the
 68894:      * low-privileged caller. (For the Mozilla embedding, this is brute-enforced
 68894:      * by explicit filtering by wrappers.) Thus, the caller's privileges should
 68894:      * subsume the callee's.
 68894:      *
 68894:      * In the converse situation, where the callee has lower privileges than the
 68894:      * caller, we might initially guess that the caller would want to retain
 68894:      * their higher privileges in the generated code. However, since the
 68894:      * compiled code will be run with the callee's scope chain, this would make
 68894:      * fp->script()->compartment() != fp->compartment().
 68894:      */
 68894: 
 71362:     return call.callee().principals(cx);
 68894: }
 68894: 
 68894: }  /* namespace js */
 56556: 
     1: #if JS_HAS_OBJ_WATCHPOINT
     1: 
     1: static JSBool
 48470: obj_watch_handler(JSContext *cx, JSObject *obj, jsid id, jsval old,
 48470:                   jsval *nvp, void *closure)
     1: {
 64302:     JSObject *callable = (JSObject *) closure;
 91900:     if (JSSubsumePrincipalsOp subsume = cx->runtime->securityCallbacks->subsumePrincipals) {
 68894:         if (JSPrincipals *watcher = callable->principals(cx)) {
 77343:             if (JSObject *scopeChain = cx->stack.currentScriptedScopeChain()) {
 77343:                 if (JSPrincipals *subject = scopeChain->principals(cx)) {
 91900:                     if (!subsume(watcher, subject)) {
     1:                         /* Silently don't call the watch handler. */
 91900:                         return true;
 91900:                     }
 68894:                 }
     1:             }
     1:         }
     1:     }
     1: 
     1:     /* Avoid recursion on (obj, id) already being watched on cx. */
 64302:     AutoResolving resolving(cx, obj, id, AutoResolving::WATCH);
 64302:     if (resolving.alreadyStarted())
 64302:         return true;
 64302: 
 78614:     Value argv[] = { IdToValue(id), old, *nvp };
 80468:     return Invoke(cx, ObjectValue(*obj), ObjectOrNullValue(callable), ArrayLength(argv), argv, nvp);
     1: }
     1: 
     1: static JSBool
 91237: obj_watch(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 16519:     if (argc <= 1) {
 48470:         js_ReportMissingArg(cx, *vp, 1);
 91362:         return false;
 16519:     }
 16519: 
103274:     RootedObject callable(cx, ValueToCallable(cx, &vp[3]));
     1:     if (!callable)
 91362:         return false;
     1: 
 99421:     RootedId propid(cx);
 97353:     if (!ValueToId(cx, vp[2], propid.address()))
 91362:         return false;
     1: 
 99421:     RootedObject obj(cx, ToObject(cx, &vp[1]));
 61734:     if (!obj)
 61734:         return false;
 61734: 
 48470:     Value tmp;
 91237:     unsigned attrs;
 61734:     if (!CheckAccess(cx, obj, propid, JSACC_WATCH, &tmp, &attrs))
 91362:         return false;
 40878: 
 48470:     vp->setUndefined();
 40878: 
 95355:     if (obj->isDenseArray() && !JSObject::makeDenseArraySlow(cx, obj))
 91362:         return false;
 48470:     return JS_SetWatchPoint(cx, obj, propid, obj_watch_handler, callable);
     1: }
     1: 
     1: static JSBool
 91237: obj_unwatch(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 61734:     JSObject *obj = ToObject(cx, &vp[1]);
 11809:     if (!obj)
 61734:         return false;
 48470:     vp->setUndefined();
 48470:     jsid id;
 48470:     if (argc != 0) {
 48470:         if (!ValueToId(cx, vp[2], &id))
 91362:             return false;
 48470:     } else {
 48470:         id = JSID_VOID;
 48470:     }
 48470:     return JS_ClearWatchPoint(cx, obj, id, NULL, NULL);
     1: }
     1: 
     1: #endif /* JS_HAS_OBJ_WATCHPOINT */
     1: 
     1: /*
     1:  * Prototype and property query methods, to complement the 'in' and
     1:  * 'instanceof' operators.
     1:  */
     1: 
     1: /* Proposed ECMA 15.2.4.5. */
 20408: static JSBool
 91237: obj_hasOwnProperty(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 61734:     JSObject *obj = ToObject(cx, &vp[1]);
 61734:     if (!obj)
 61734:         return false;
 80442:     return js_HasOwnPropertyHelper(cx, obj->getOps()->lookupGeneric, argc, vp);
     1: }
     1: 
     1: JSBool
 91237: js_HasOwnPropertyHelper(JSContext *cx, LookupGenericOp lookup, unsigned argc,
 48470:                         Value *vp)
     1: {
 99421:     RootedId id(cx);
 98960:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), id.address()))
     1:         return JS_FALSE;
 32721: 
 99421:     RootedObject obj(cx, ToObject(cx, &vp[1]));
 61734:     if (!obj)
 61734:         return false;
 36991:     JSObject *obj2;
 36991:     JSProperty *prop;
 42733:     if (obj->isProxy()) {
 42733:         bool has;
 79386:         if (!Proxy::hasOwn(cx, obj, id, &has))
 42733:             return false;
 48470:         vp->setBoolean(has);
 42733:         return true;
 42733:     }
 42733:     if (!js_HasOwnProperty(cx, lookup, obj, id, &obj2, &prop))
 36991:         return JS_FALSE;
 56568:     vp->setBoolean(!!prop);
 32721:     return JS_TRUE;
 18062: }
 18062: 
 18062: JSBool
 98960: js_HasOwnProperty(JSContext *cx, LookupGenericOp lookup, HandleObject obj, HandleId id,
 36991:                   JSObject **objp, JSProperty **propp)
 36991: {
 43285:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING);
 98960:     if (lookup) {
 98960:         if (!lookup(cx, obj, id, objp, propp))
 98960:             return false;
 98960:     } else {
 98960:         if (!baseops::LookupProperty(cx, obj, id, objp, propp))
 98960:             return false;
 98960:     }
 36991:     if (!*propp)
 40327:         return true;
 36991: 
 36991:     if (*objp == obj)
 40327:         return true;
 36991: 
 48622:     JSObject *outer = NULL;
 48622:     if (JSObjectOp op = (*objp)->getClass()->ext.outerObject) {
102586:         Rooted<JSObject*> inner(cx, *objp);
102586:         outer = op(cx, inner);
  4780:         if (!outer)
 40327:             return false;
 40327:     }
 40327: 
 72069:     if (outer != *objp)
 36991:         *propp = NULL;
 40327:     return true;
     1: }
     1: 
 61734: /* ES5 15.2.4.6. */
     1: static JSBool
 91237: obj_isPrototypeOf(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 61734:     /* Step 1. */
 61734:     if (argc < 1 || !vp[2].isObject()) {
 61734:         vp->setBoolean(false);
 61734:         return true;
 61734:     }
 61734: 
 61734:     /* Step 2. */
 61734:     JSObject *obj = ToObject(cx, &vp[1]);
 40880:     if (!obj)
 61734:         return false;
 61734: 
 61734:     /* Step 3. */
 61734:     vp->setBoolean(js_IsDelegate(cx, obj, vp[2]));
 61734:     return true;
 61734: }
 61734: 
 61734: /* ES5 15.2.4.7. */
 20408: static JSBool
 91237: obj_propertyIsEnumerable(JSContext *cx, unsigned argc, Value *vp)
     1: {
 61734:     /* Step 1. */
 99421:     RootedId id(cx);
 98960:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), id.address()))
 61734:         return false;
 61734: 
 61734:     /* Step 2. */
 99421:     RootedObject obj(cx, ToObject(cx, &vp[1]));
 61734:     if (!obj)
 61734:         return false;
 61734: 
 61734:     /* Steps 3-5. */
 61734:     return js_PropertyIsEnumerable(cx, obj, id, vp);
 18062: }
 18062: 
 18062: JSBool
 98960: js_PropertyIsEnumerable(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
 18062: {
 18062:     JSObject *pobj;
     1:     JSProperty *prop;
 80442:     if (!obj->lookupGeneric(cx, id, &pobj, &prop))
 72089:         return false;
     1: 
     1:     if (!prop) {
 48470:         vp->setBoolean(false);
 72089:         return true;
     1:     }
     1: 
     1:     /*
 72089:      * ECMA spec botch: return false unless hasOwnProperty. Leaving "own" out
 72089:      * of propertyIsEnumerable's name was a mistake.
     1:      */
 72089:     if (pobj != obj) {
 48470:         vp->setBoolean(false);
 43290:         return true;
 43290:     }
 72089: 
 91237:     unsigned attrs;
 80622:     if (!pobj->getGenericAttributes(cx, id, &attrs))
 72089:         return false;
 72089: 
 48470:     vp->setBoolean((attrs & JSPROP_ENUMERATE) != 0);
 43290:     return true;
     1: }
     1: 
 40855: #if OLD_GETTER_SETTER_METHODS
 40855: 
 86885: enum DefineType { Getter, Setter };
 86885: 
 86885: template<DefineType Type>
 86885: static bool
 91237: DefineAccessor(JSContext *cx, unsigned argc, Value *vp)
 86885: {
 86885:     CallArgs args = CallArgsFromVp(argc, vp);
 86885:     if (!BoxNonStrictThis(cx, args))
 86885:         return false;
 86885: 
 86885:     if (args.length() < 2 || !js_IsCallable(args[1])) {
 86885:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 86885:                              JSMSG_BAD_GETTER_OR_SETTER,
 86885:                              Type == Getter ? js_getter_str : js_setter_str);
 86885:         return false;
 86885:     }
 86885: 
 99421:     RootedId id(cx);
 97353:     if (!ValueToId(cx, args[0], id.address()))
 97353:         return false;
 97353: 
 99421:     RootedObject descObj(cx, NewBuiltinClassInstance(cx, &ObjectClass));
 86885:     if (!descObj)
 86885:         return false;
 86885: 
 86885:     JSAtomState &state = cx->runtime->atomState;
 86885:     /* enumerable: true */
 86885:     if (!descObj->defineProperty(cx, state.enumerableAtom, BooleanValue(true)))
 86885:         return false;
 86885: 
 86885:     /* configurable: true */
 86885:     if (!descObj->defineProperty(cx, state.configurableAtom, BooleanValue(true)))
 86885:         return false;
 86885: 
 86885:     /* enumerable: true */
 86885:     PropertyName *acc = (Type == Getter) ? state.getAtom : state.setAtom;
 86885:     if (!descObj->defineProperty(cx, acc, args[1]))
 86885:         return false;
 86885: 
 99421:     RootedObject thisObj(cx, &args.thisv().toObject());
 97353: 
 86885:     JSBool dummy;
 97353:     if (!js_DefineOwnProperty(cx, thisObj, id, ObjectValue(*descObj), &dummy)) {
 95355:         return false;
 95355:     }
 86885:     args.rval().setUndefined();
 86885:     return true;
 86885: }
 86885: 
 24145: JS_FRIEND_API(JSBool)
 91237: js::obj_defineGetter(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 86885:     return DefineAccessor<Getter>(cx, argc, vp);
     1: }
     1: 
 24145: JS_FRIEND_API(JSBool)
 91237: js::obj_defineSetter(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 86885:     return DefineAccessor<Setter>(cx, argc, vp);
     1: }
     1: 
     1: static JSBool
 91237: obj_lookupGetter(JSContext *cx, unsigned argc, Value *vp)
     1: {
 99421:     RootedId id(cx);
 98960:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), id.address()))
 48470:         return JS_FALSE;
 99421:     RootedObject obj(cx, ToObject(cx, &vp[1]));
 61734:     if (!obj)
 61734:         return JS_FALSE;
101760:     if (obj->isProxy()) {
101760:         // The vanilla getter lookup code below requires that the object is
101760:         // native. Handle proxies separately.
101760:         vp->setUndefined();
101760:         PropertyDescriptor desc;
101760:         if (!Proxy::getPropertyDescriptor(cx, obj, id, false, &desc))
101760:             return JS_FALSE;
102211:         if (desc.obj && (desc.attrs & JSPROP_GETTER) && desc.getter)
101760:             *vp = CastAsObjectJsval(desc.getter);
101760:         return JS_TRUE;
101760:     }
 48470:     JSObject *pobj;
     1:     JSProperty *prop;
 80442:     if (!obj->lookupGeneric(cx, id, &pobj, &prop))
     1:         return JS_FALSE;
 48470:     vp->setUndefined();
     1:     if (prop) {
 40430:         if (pobj->isNative()) {
 52503:             Shape *shape = (Shape *) prop;
 52503:             if (shape->hasGetterValue())
 52503:                 *vp = shape->getterValue();
 43290:         }
     1:     }
     1:     return JS_TRUE;
     1: }
     1: 
     1: static JSBool
 91237: obj_lookupSetter(JSContext *cx, unsigned argc, Value *vp)
     1: {
 99421:     RootedId id(cx);
 98960:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), id.address()))
 48470:         return JS_FALSE;
 99421:     RootedObject obj(cx, ToObject(cx, &vp[1]));
 61734:     if (!obj)
 61734:         return JS_FALSE;
101760:     if (obj->isProxy()) {
101760:         // The vanilla setter lookup code below requires that the object is
101760:         // native. Handle proxies separately.
101760:         vp->setUndefined();
101760:         PropertyDescriptor desc;
101760:         if (!Proxy::getPropertyDescriptor(cx, obj, id, false, &desc))
101760:             return JS_FALSE;
102211:         if (desc.obj && (desc.attrs & JSPROP_SETTER) && desc.setter)
101760:             *vp = CastAsObjectJsval(desc.setter);
101760:         return JS_TRUE;
101760:     }
 48470:     JSObject *pobj;
     1:     JSProperty *prop;
 80442:     if (!obj->lookupGeneric(cx, id, &pobj, &prop))
     1:         return JS_FALSE;
 48470:     vp->setUndefined();
     1:     if (prop) {
 40430:         if (pobj->isNative()) {
 52503:             Shape *shape = (Shape *) prop;
 52503:             if (shape->hasSetterValue())
 52503:                 *vp = shape->setterValue();
 43290:         }
     1:     }
     1:     return JS_TRUE;
     1: }
 40855: #endif /* OLD_GETTER_SETTER_METHODS */
     1: 
 16380: JSBool
 91237: obj_getPrototypeOf(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 16519:     if (argc == 0) {
 48470:         js_ReportMissingArg(cx, *vp, 0);
 16519:         return JS_FALSE;
 16519:     }
 16519: 
 48470:     if (vp[2].isPrimitive()) {
 50457:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, vp[2], NULL);
 31844:         if (!bytes)
 16380:             return JS_FALSE;
 31844:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 31844:                              JSMSG_UNEXPECTED_TYPE, bytes, "not an object");
 31844:         JS_free(cx, bytes);
 31844:         return JS_FALSE;
 31844:     }
 31844: 
 48470:     JSObject *obj = &vp[2].toObject();
 91237:     unsigned attrs;
 99421:     RootedId nid(cx, NameToId(cx->runtime->atomState.protoAtom));
 98960:     return CheckAccess(cx, obj, nid, JSACC_PROTO, vp, &attrs);
 16380: }
 16380: 
 76213: namespace js {
 76213: 
 76213: bool
 76213: NewPropertyDescriptorObject(JSContext *cx, const PropertyDescriptor *desc, Value *vp)
 76213: {
 76213:     if (!desc->obj) {
 76213:         vp->setUndefined();
 76213:         return true;
 76213:     }
 76223: 
 42733:     /* We have our own property, so start creating the descriptor. */
 76223:     PropDesc d;
 99364:     PropDesc::AutoRooter dRoot(cx, &d);
 97353: 
 76223:     d.initFromPropertyDescriptor(*desc);
 76223:     if (!d.makeObject(cx))
 76223:         return false;
 97047:     *vp = d.pd();
 76223:     return true;
 76223: }
 76223: 
 76223: void
 76223: PropDesc::initFromPropertyDescriptor(const PropertyDescriptor &desc)
 76223: {
 97048:     isUndefined_ = false;
 97047:     pd_.setUndefined();
 84755:     attrs = uint8_t(desc.attrs);
 84680:     JS_ASSERT_IF(attrs & JSPROP_READONLY, !(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
 76223:     if (desc.attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
 97047:         hasGet_ = true;
 97047:         get_ = ((desc.attrs & JSPROP_GETTER) && desc.getter)
 76223:                ? CastAsObjectJsval(desc.getter)
 76222:                : UndefinedValue();
 97047:         hasSet_ = true;
 97047:         set_ = ((desc.attrs & JSPROP_SETTER) && desc.setter)
 76223:                ? CastAsObjectJsval(desc.setter)
 76222:                : UndefinedValue();
 97047:         hasValue_ = false;
 97047:         value_.setUndefined();
 97047:         hasWritable_ = false;
 76223:     } else {
 97047:         hasGet_ = false;
 97047:         get_.setUndefined();
 97047:         hasSet_ = false;
 97047:         set_.setUndefined();
 97047:         hasValue_ = true;
 97047:         value_ = desc.value;
 97047:         hasWritable_ = true;
 97047:     }
 97047:     hasEnumerable_ = true;
 97047:     hasConfigurable_ = true;
 76223: }
 76223: 
 76223: bool
 76223: PropDesc::makeObject(JSContext *cx)
 76223: {
 97048:     MOZ_ASSERT(!isUndefined());
 97048: 
 99421:     RootedObject obj(cx, NewBuiltinClassInstance(cx, &ObjectClass));
 76213:     if (!obj)
 76213:         return false;
 42733: 
 42733:     const JSAtomState &atomState = cx->runtime->atomState;
 97047:     if ((hasConfigurable() &&
 80624:          !obj->defineProperty(cx, atomState.configurableAtom,
 80624:                               BooleanValue((attrs & JSPROP_PERMANENT) == 0))) ||
 97047:         (hasEnumerable() &&
 80624:          !obj->defineProperty(cx, atomState.enumerableAtom,
 80624:                               BooleanValue((attrs & JSPROP_ENUMERATE) != 0))) ||
 97047:         (hasGet() &&
 97047:          !obj->defineProperty(cx, atomState.getAtom, getterValue())) ||
 97047:         (hasSet() &&
 97047:          !obj->defineProperty(cx, atomState.setAtom, setterValue())) ||
 97047:         (hasValue() &&
 97047:          !obj->defineProperty(cx, atomState.valueAtom, value())) ||
 97047:         (hasWritable() &&
 80624:          !obj->defineProperty(cx, atomState.writableAtom,
 80624:                               BooleanValue((attrs & JSPROP_READONLY) == 0))))
 76223:     {
 76223:         return false;
 76223:     }
 76223: 
 97047:     pd_.setObject(*obj);
 76213:     return true;
 76213: }
 76213: 
 76213: bool
 95355: GetOwnPropertyDescriptor(JSContext *cx, HandleObject obj, HandleId id, PropertyDescriptor *desc)
 40356: {
 56606:     if (obj->isProxy())
 79386:         return Proxy::getOwnPropertyDescriptor(cx, obj, id, false, desc);
 42733: 
 36991:     JSObject *pobj;
 36991:     JSProperty *prop;
 80442:     if (!js_HasOwnProperty(cx, obj->getOps()->lookupGeneric, obj, id, &pobj, &prop))
 40356:         return false;
 36991:     if (!prop) {
 76213:         desc->obj = NULL;
 40356:         return true;
 32721:     }
 32721: 
 43290:     bool doGet = true;
 43290:     if (pobj->isNative()) {
 52503:         Shape *shape = (Shape *) prop;
 76213:         desc->attrs = shape->attributes();
 76213:         if (desc->attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
 43290:             doGet = false;
 76213:             if (desc->attrs & JSPROP_GETTER)
 76222:                 desc->getter = CastAsPropertyOp(shape->getterObject());
 76213:             if (desc->attrs & JSPROP_SETTER)
 76222:                 desc->setter = CastAsStrictPropertyOp(shape->setterObject());
 35098:         }
 54713:     } else {
 80622:         if (!pobj->getGenericAttributes(cx, id, &desc->attrs))
 76213:             return false;
 76213:     }
 76213: 
 78675:     if (doGet && !obj->getGeneric(cx, id, &desc->value))
 76213:         return false;
 76213: 
 76213:     desc->obj = obj;
 76213:     return true;
 76213: }
 76213: 
 76213: bool
 95355: GetOwnPropertyDescriptor(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
 76213: {
 76213:     AutoPropertyDescriptorRooter desc(cx);
 76213:     return GetOwnPropertyDescriptor(cx, obj, id, &desc) &&
 76213:            NewPropertyDescriptorObject(cx, &desc, vp);
 76213: }
 76213: 
 97574: bool
 91237: GetFirstArgumentAsObject(JSContext *cx, unsigned argc, Value *vp, const char *method, JSObject **objp)
 47569: {
 47569:     if (argc == 0) {
 47569:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
 47569:                              method, "0", "s");
 47569:         return false;
 47569:     }
 47569: 
 48470:     const Value &v = vp[2];
 54564:     if (!v.isObject()) {
 48470:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);
 47569:         if (!bytes)
 47569:             return false;
 47569:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
 47569:                              bytes, "not an object");
 47569:         JS_free(cx, bytes);
 47569:         return false;
 47569:     }
 47569: 
 48470:     *objp = &v.toObject();
 47569:     return true;
 47569: }
 47569: 
 97574: } /* namespace js */
 97574: 
 33155: static JSBool
 91237: obj_getOwnPropertyDescriptor(JSContext *cx, unsigned argc, Value *vp)
 40356: {
 99421:     RootedObject obj(cx);
 95355:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.getOwnPropertyDescriptor", obj.address()))
 47569:         return JS_FALSE;
 99421:     RootedId id(cx);
 95355:     if (!ValueToId(cx, argc >= 2 ? vp[3] : UndefinedValue(), id.address()))
 40356:         return JS_FALSE;
 95355:     return GetOwnPropertyDescriptor(cx, obj, id, vp);
 40356: }
 40356: 
 40356: static JSBool
 91237: obj_keys(JSContext *cx, unsigned argc, Value *vp)
 33155: {
 47569:     JSObject *obj;
 47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.keys", &obj))
 57759:         return false;
 42733: 
 48470:     AutoIdVector props(cx);
 54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY, &props))
 57759:         return false;
 33155: 
 48470:     AutoValueVector vals(cx);
 57759:     if (!vals.reserve(props.length()))
 57759:         return false;
 48463:     for (size_t i = 0, len = props.length(); i < len; i++) {
 48470:         jsid id = props[i];
 48470:         if (JSID_IS_STRING(id)) {
 86726:             vals.infallibleAppend(StringValue(JSID_TO_STRING(id)));
 57759:         } else if (JSID_IS_INT(id)) {
102228:             JSString *str = Int32ToString(cx, JSID_TO_INT(id));
 48470:             if (!str)
 57759:                 return false;
 64229:             vals.infallibleAppend(StringValue(str));
 57759:         } else {
 57759:             JS_ASSERT(JSID_IS_OBJECT(id));
 48470:         }
 48463:     }
 48463: 
 48463:     JS_ASSERT(props.length() <= UINT32_MAX);
 86726:     JSObject *aobj = NewDenseCopiedArray(cx, uint32_t(vals.length()), vals.begin());
 33155:     if (!aobj)
 57759:         return false;
 48470:     vp->setObject(*aobj);
 33155: 
 57759:     return true;
 33155: }
 33155: 
 54713: static bool
 98960: HasProperty(JSContext *cx, HandleObject obj, HandleId id, Value *vp, bool *foundp)
 54713: {
 54713:     if (!obj->hasProperty(cx, id, foundp, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING))
 54713:         return false;
 54713:     if (!*foundp) {
 48470:         vp->setUndefined();
 54713:         return true;
 54713:     }
 54713: 
 54713:     /*
 54713:      * We must go through the method read barrier in case id is 'get' or 'set'.
 54713:      * There is no obvious way to defer cloning a joined function object whose
 54713:      * identity will be used by DefinePropertyOnObject, e.g., or reflected via
 76213:      * js::GetOwnPropertyDescriptor, as the getter or setter callable object.
 54713:      */
 78675:     return !!obj->getGeneric(cx, id, vp);
 48470: }
 48470: 
 36991: bool
 76223: PropDesc::initialize(JSContext *cx, const Value &origval, bool checkAccessors)
 48470: {
 48470:     Value v = origval;
 36991: 
 36991:     /* 8.10.5 step 1 */
 48470:     if (v.isPrimitive()) {
 37010:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
 36991:         return false;
 36991:     }
 99421:     RootedObject desc(cx, &v.toObject());
 36991: 
 42733:     /* Make a copy of the descriptor. We might need it later. */
 97047:     pd_ = v;
 96916: 
 97048:     isUndefined_ = false;
 97048: 
 97048:     /*
 97048:      * Start with the proper defaults.  XXX shouldn't be necessary when we get
 97048:      * rid of PropDesc::attributes()
 97048:      */
 36991:     attrs = JSPROP_PERMANENT | JSPROP_READONLY;
 36991: 
 98960:     bool found = false;
 99421:     RootedId id(cx);
 36991: 
 36991:     /* 8.10.5 step 3 */
 98960:     id = NameToId(cx->runtime->atomState.enumerableAtom);
 98960:     if (!HasProperty(cx, desc, id, &v, &found))
 36991:         return false;
 54713:     if (found) {
 97047:         hasEnumerable_ = true;
 36991:         if (js_ValueToBoolean(v))
 36991:             attrs |= JSPROP_ENUMERATE;
 36991:     }
 36991: 
 36991:     /* 8.10.5 step 4 */
 98960:     id = NameToId(cx->runtime->atomState.configurableAtom);
 98960:     if (!HasProperty(cx, desc, id, &v, &found))
 36991:         return false;
 54713:     if (found) {
 97047:         hasConfigurable_ = true;
 36991:         if (js_ValueToBoolean(v))
 36991:             attrs &= ~JSPROP_PERMANENT;
 36991:     }
 36991: 
 36991:     /* 8.10.5 step 5 */
 98960:     id = NameToId(cx->runtime->atomState.valueAtom);
 98960:     if (!HasProperty(cx, desc, id, &v, &found))
 36991:         return false;
 54713:     if (found) {
 97047:         hasValue_ = true;
 97047:         value_ = v;
 36991:     }
 36991: 
 36991:     /* 8.10.6 step 6 */
 98960:     id = NameToId(cx->runtime->atomState.writableAtom);
 98960:     if (!HasProperty(cx, desc, id, &v, &found))
 36991:         return false;
 54713:     if (found) {
 97047:         hasWritable_ = true;
 36991:         if (js_ValueToBoolean(v))
 36991:             attrs &= ~JSPROP_READONLY;
 36991:     }
 36991: 
 36991:     /* 8.10.7 step 7 */
 98960:     id = NameToId(cx->runtime->atomState.getAtom);
 98960:     if (!HasProperty(cx, desc, id, &v, &found))
 36991:         return false;
 54713:     if (found) {
 97047:         hasGet_ = true;
 97047:         get_ = v;
 36991:         attrs |= JSPROP_GETTER | JSPROP_SHARED;
 84680:         attrs &= ~JSPROP_READONLY;
 76223:         if (checkAccessors && !checkGetter(cx))
 76223:             return false;
 36991:     }
 36991: 
 36991:     /* 8.10.7 step 8 */
 98960:     id = NameToId(cx->runtime->atomState.setAtom);
 98960:     if (!HasProperty(cx, desc, id, &v, &found))
 36991:         return false;
 54713:     if (found) {
 97047:         hasSet_ = true;
 97047:         set_ = v;
 36991:         attrs |= JSPROP_SETTER | JSPROP_SHARED;
 84680:         attrs &= ~JSPROP_READONLY;
 76223:         if (checkAccessors && !checkSetter(cx))
 76223:             return false;
 36991:     }
 36991: 
 36991:     /* 8.10.7 step 9 */
 97047:     if ((hasGet() || hasSet()) && (hasValue() || hasWritable())) {
 36991:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INVALID_DESCRIPTOR);
 36991:         return false;
 36991:     }
 36991: 
 84680:     JS_ASSERT_IF(attrs & JSPROP_READONLY, !(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
 84680: 
 36991:     return true;
 36991: }
 36991: 
 94783: namespace js {
 94783: 
 94783: bool
 94783: Throw(JSContext *cx, jsid id, unsigned errorNumber)
 94783: {
 94783:     JS_ASSERT(js_ErrorFormatString[errorNumber].argCount == 1);
 94783: 
 94783:     JSString *idstr = IdToString(cx, id);
 94783:     if (!idstr)
 94783:        return false;
 94783:     JSAutoByteString bytes(cx, idstr);
 57812:     if (!bytes)
 94783:         return false;
 57812:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber, bytes.ptr());
 94783:     return false;
 94783: }
 94783: 
 94783: bool
 94783: Throw(JSContext *cx, JSObject *obj, unsigned errorNumber)
 94783: {
 54587:     if (js_ErrorFormatString[errorNumber].argCount == 1) {
 54587:         js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,
 54587:                                  JSDVG_IGNORE_STACK, ObjectValue(*obj),
 54587:                                  NULL, NULL, NULL);
 54587:     } else {
 54587:         JS_ASSERT(js_ErrorFormatString[errorNumber].argCount == 0);
 36991:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber);
 54587:     }
 94783:     return false;
 94783: }
 94783: 
 94783: } /* namespace js */
 94783: 
 94783: static JSBool
 94783: Reject(JSContext *cx, unsigned errorNumber, bool throwError, jsid id, bool *rval)
 94783: {
 94783:     if (throwError)
 94783:         return Throw(cx, id, errorNumber);
 94783: 
 94783:     *rval = false;
 94783:     return true;
 94783: }
 94783: 
 94783: static JSBool
 94783: Reject(JSContext *cx, JSObject *obj, unsigned errorNumber, bool throwError, bool *rval)
 94783: {
 94783:     if (throwError)
 94783:         return Throw(cx, obj, errorNumber);
 36991: 
 36991:     *rval = false;
 36991:     return JS_TRUE;
 36991: }
 36991: 
101861: // See comments on CheckDefineProperty in jsobj.h.
101861: //
101861: // DefinePropertyOnObject has its own implementation of these checks.
101861: //
101861: bool
101861: js::CheckDefineProperty(JSContext *cx, HandleObject obj, HandleId id, HandleValue value,
101861:                         PropertyOp getter, StrictPropertyOp setter, unsigned attrs)
101861: {
101861:     if (!obj->isNative())
101861:         return true;
101861: 
101861:     // ES5 8.12.9 Step 1. Even though we know obj is native, we use generic
101861:     // APIs for shorter, more readable code.
101861:     AutoPropertyDescriptorRooter desc(cx);
101861:     if (!GetOwnPropertyDescriptor(cx, obj, id, &desc))
101861:         return false;
101861: 
101861:     // This does not have to check obj->isExtensible() when !desc.obj (steps
101861:     // 2-3) because the low-level methods JSObject::{add,put}Property check
101861:     // for that.
101861:     if (desc.obj && (desc.attrs & JSPROP_PERMANENT)) {
101861:         // Steps 6-11, skipping step 10.a.ii. Prohibit redefining a permanent
101861:         // property with different metadata, except to make a writable property
101861:         // non-writable.
101861:         if (getter != desc.getter ||
101861:             setter != desc.setter ||
101861:             (attrs != desc.attrs && attrs != (desc.attrs | JSPROP_READONLY)))
101861:         {
101861:             return Throw(cx, id, JSMSG_CANT_REDEFINE_PROP);
101861:         }
101861: 
101861:         // Step 10.a.ii. Prohibit changing the value of a non-configurable,
101861:         // non-writable data property.
101861:         if ((desc.attrs & (JSPROP_GETTER | JSPROP_SETTER | JSPROP_READONLY)) == JSPROP_READONLY) {
101861:             bool same;
101861:             if (!SameValue(cx, value, desc.value, &same))
101861:                 return false;
101861:             if (!same)
101861:                 return JSObject::reportReadOnly(cx, id);
101861:         }
101861:     }
101861:     return true;
101861: }
101861: 
 36991: static JSBool
 95355: DefinePropertyOnObject(JSContext *cx, HandleObject obj, HandleId id, const PropDesc &desc,
 36991:                        bool throwError, bool *rval)
 36991: {
 36991:     /* 8.12.9 step 1. */
 36991:     JSProperty *current;
 99421:     RootedObject obj2(cx);
 80442:     JS_ASSERT(!obj->getOps()->lookupGeneric);
 95355:     if (!js_HasOwnProperty(cx, NULL, obj, id, obj2.address(), &current))
 36991:         return JS_FALSE;
 36991: 
 48622:     JS_ASSERT(!obj->getOps()->defineProperty);
 36991: 
 36991:     /* 8.12.9 steps 2-4. */
 36991:     if (!current) {
 54563:         if (!obj->isExtensible())
 54587:             return Reject(cx, obj, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
 36991: 
 36991:         *rval = true;
 36991: 
 36991:         if (desc.isGenericDescriptor() || desc.isDataDescriptor()) {
 48622:             JS_ASSERT(!obj->getOps()->defineProperty);
 97047:             Value v = desc.hasValue() ? desc.value() : UndefinedValue();
102586:             return baseops::DefineGeneric(cx, obj, id, &v,
 97047:                                           JS_PropertyStub, JS_StrictPropertyStub,
 97047:                                           desc.attributes());
 36991:         }
 36991: 
 36991:         JS_ASSERT(desc.isAccessorDescriptor());
 36991: 
 50518:         /*
 50518:          * Getters and setters are just like watchpoints from an access
 50518:          * control point of view.
 50518:          */
 48470:         Value dummy;
 91237:         unsigned dummyAttrs;
 64250:         if (!CheckAccess(cx, obj, id, JSACC_WATCH, &dummy, &dummyAttrs))
 36991:             return JS_FALSE;
 36991: 
 48470:         Value tmp = UndefinedValue();
102586:         return baseops::DefineGeneric(cx, obj, id, &tmp,
 97047:                                       desc.getter(), desc.setter(), desc.attributes());
 36991:     }
 36991: 
 36991:     /* 8.12.9 steps 5-6 (note 5 is merely a special case of 6). */
 48470:     Value v = UndefinedValue();
 36991: 
 72089:     JS_ASSERT(obj == obj2);
 36991: 
101203:     Rooted<const Shape *> shape(cx, reinterpret_cast<Shape *>(current));
 36991:     do {
 36991:         if (desc.isAccessorDescriptor()) {
 52503:             if (!shape->isAccessorDescriptor())
 36991:                 break;
 36991: 
 97047:             if (desc.hasGet()) {
 88099:                 bool same;
 59890:                 if (!SameValue(cx, desc.getterValue(), shape->getterOrUndefined(), &same))
 88099:                     return false;
 59890:                 if (!same)
 36991:                     break;
 36991:             }
 36991: 
 97047:             if (desc.hasSet()) {
 88099:                 bool same;
 59890:                 if (!SameValue(cx, desc.setterValue(), shape->setterOrUndefined(), &same))
 88099:                     return false;
 59890:                 if (!same)
 36991:                     break;
 36991:             }
 36991:         } else {
 36991:             /*
 36991:              * Determine the current value of the property once, if the current
 36991:              * value might actually need to be used or preserved later.  NB: we
 36991:              * guard on whether the current property is a data descriptor to
 36991:              * avoid calling a getter; we won't need the value if it's not a
 36991:              * data descriptor.
 36991:              */
 52503:             if (shape->isDataDescriptor()) {
 36991:                 /*
 61685:                  * We must rule out a non-configurable js::PropertyOp-guarded
 61685:                  * property becoming a writable unguarded data property, since
 61685:                  * such a property can have its value changed to one the getter
 61685:                  * and setter preclude.
 36991:                  *
 61685:                  * A desc lacking writable but with value is a data descriptor
 61685:                  * and we must reject it as if it had writable: true if current
 61685:                  * is writable.
 36991:                  */
 52503:                 if (!shape->configurable() &&
 61685:                     (!shape->hasDefaultGetter() || !shape->hasDefaultSetter()) &&
 61685:                     desc.isDataDescriptor() &&
 97047:                     (desc.hasWritable() ? desc.writable() : shape->writable()))
 61685:                 {
 64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
 36991:                 }
 36991: 
 94227:                 if (!js_NativeGet(cx, obj, obj2, shape, 0, &v))
 36991:                     return JS_FALSE;
 36991:             }
 36991: 
 36991:             if (desc.isDataDescriptor()) {
 52503:                 if (!shape->isDataDescriptor())
 36991:                     break;
 36991: 
 88099:                 bool same;
 97047:                 if (desc.hasValue()) {
 97047:                     if (!SameValue(cx, desc.value(), v, &same))
 88099:                         return false;
 61689:                     if (!same) {
 61689:                         /*
 61689:                          * Insist that a non-configurable js::PropertyOp data
 61689:                          * property is frozen at exactly the last-got value.
 61689:                          *
 61689:                          * Duplicate the first part of the big conjunction that
 61689:                          * we tested above, rather than add a local bool flag.
 61689:                          * Likewise, don't try to keep shape->writable() in a
 61689:                          * flag we veto from true to false for non-configurable
 61689:                          * PropertyOp-based data properties and test before the
 61689:                          * SameValue check later on in order to re-use that "if
 61689:                          * (!SameValue) Reject" logic.
 61689:                          *
 61689:                          * This function is large and complex enough that it
 61689:                          * seems best to repeat a small bit of code and return
 61689:                          * Reject(...) ASAP, instead of being clever.
 61689:                          */
 61689:                         if (!shape->configurable() &&
 61689:                             (!shape->hasDefaultGetter() || !shape->hasDefaultSetter()))
 61689:                         {
 64250:                             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
 61689:                         }
 36991:                         break;
 59890:                     }
 61689:                 }
 97047:                 if (desc.hasWritable() && desc.writable() != shape->writable())
 36991:                     break;
 36991:             } else {
 36991:                 /* The only fields in desc will be handled below. */
 36991:                 JS_ASSERT(desc.isGenericDescriptor());
 36991:             }
 36991:         }
 36991: 
 97047:         if (desc.hasConfigurable() && desc.configurable() != shape->configurable())
 36991:             break;
 97047:         if (desc.hasEnumerable() && desc.enumerable() != shape->enumerable())
 36991:             break;
 36991: 
 36991:         /* The conditions imposed by step 5 or step 6 apply. */
 36991:         *rval = true;
 97047:         return true;
 36991:     } while (0);
 36991: 
 36991:     /* 8.12.9 step 7. */
 52503:     if (!shape->configurable()) {
 97047:         if ((desc.hasConfigurable() && desc.configurable()) ||
 97047:             (desc.hasEnumerable() && desc.enumerable() != shape->enumerable())) {
 64250:             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
 36991:         }
 36991:     }
 36991: 
 55492:     bool callDelProperty = false;
 55492: 
 36991:     if (desc.isGenericDescriptor()) {
 36991:         /* 8.12.9 step 8, no validation required */
 52503:     } else if (desc.isDataDescriptor() != shape->isDataDescriptor()) {
 36991:         /* 8.12.9 step 9. */
 54587:         if (!shape->configurable())
 64250:             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
 41860:     } else if (desc.isDataDescriptor()) {
 36991:         /* 8.12.9 step 10. */
 52503:         JS_ASSERT(shape->isDataDescriptor());
 52503:         if (!shape->configurable() && !shape->writable()) {
 97047:             if (desc.hasWritable() && desc.writable())
 64250:                 return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
 97047:             if (desc.hasValue()) {
 88099:                 bool same;
 97047:                 if (!SameValue(cx, desc.value(), v, &same))
 88099:                     return false;
 59890:                 if (!same)
 64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
 36991:             }
 36991:         }
 55492: 
 55492:         callDelProperty = !shape->hasDefaultGetter() || !shape->hasDefaultSetter();
 36991:     } else {
 36991:         /* 8.12.9 step 11. */
 52503:         JS_ASSERT(desc.isAccessorDescriptor() && shape->isAccessorDescriptor());
 52503:         if (!shape->configurable()) {
 97047:             if (desc.hasSet()) {
 88099:                 bool same;
 59890:                 if (!SameValue(cx, desc.setterValue(), shape->setterOrUndefined(), &same))
 88099:                     return false;
 59890:                 if (!same)
 64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
 59890:             }
 59890: 
 97047:             if (desc.hasGet()) {
 88099:                 bool same;
 59890:                 if (!SameValue(cx, desc.getterValue(), shape->getterOrUndefined(), &same))
 88099:                     return false;
 59890:                 if (!same)
 64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
 36991:             }
 36991:         }
 36991:     }
 36991: 
 36991:     /* 8.12.9 step 12. */
 91237:     unsigned attrs;
 62395:     PropertyOp getter;
 62395:     StrictPropertyOp setter;
 36991:     if (desc.isGenericDescriptor()) {
 91237:         unsigned changed = 0;
 97047:         if (desc.hasConfigurable())
 36991:             changed |= JSPROP_PERMANENT;
 97047:         if (desc.hasEnumerable())
 36991:             changed |= JSPROP_ENUMERATE;
 36991: 
 97047:         attrs = (shape->attributes() & ~changed) | (desc.attributes() & changed);
 52503:         getter = shape->getter();
 52503:         setter = shape->setter();
 36991:     } else if (desc.isDataDescriptor()) {
 91237:         unsigned unchanged = 0;
 97047:         if (!desc.hasConfigurable())
 36991:             unchanged |= JSPROP_PERMANENT;
 97047:         if (!desc.hasEnumerable())
 36991:             unchanged |= JSPROP_ENUMERATE;
 84819:         /* Watch out for accessor -> data transformations here. */
 97047:         if (!desc.hasWritable() && shape->isDataDescriptor())
 36991:             unchanged |= JSPROP_READONLY;
 36991: 
 97047:         if (desc.hasValue())
 97047:             v = desc.value();
 97047:         attrs = (desc.attributes() & ~unchanged) | (shape->attributes() & unchanged);
 78614:         getter = JS_PropertyStub;
 78614:         setter = JS_StrictPropertyStub;
 36991:     } else {
 36991:         JS_ASSERT(desc.isAccessorDescriptor());
 36991: 
 50518:         /*
 50518:          * Getters and setters are just like watchpoints from an access
 50518:          * control point of view.
 50518:          */
 48470:         Value dummy;
 64250:         if (!CheckAccess(cx, obj2, id, JSACC_WATCH, &dummy, &attrs))
 36991:              return JS_FALSE;
 36991: 
 36991:         /* 8.12.9 step 12. */
 91237:         unsigned changed = 0;
 97047:         if (desc.hasConfigurable())
 36991:             changed |= JSPROP_PERMANENT;
 97047:         if (desc.hasEnumerable())
 36991:             changed |= JSPROP_ENUMERATE;
 97047:         if (desc.hasGet())
 84680:             changed |= JSPROP_GETTER | JSPROP_SHARED | JSPROP_READONLY;
 97047:         if (desc.hasSet())
 84680:             changed |= JSPROP_SETTER | JSPROP_SHARED | JSPROP_READONLY;
 36991: 
 97047:         attrs = (desc.attributes() & changed) | (shape->attributes() & ~changed);
 97047:         if (desc.hasGet()) {
 41860:             getter = desc.getter();
 41860:         } else {
 94227:             getter = (shape->hasDefaultGetter() && !shape->hasGetterValue())
 78614:                      ? JS_PropertyStub
 52503:                      : shape->getter();
 41860:         }
 97047:         if (desc.hasSet()) {
 41860:             setter = desc.setter();
 41860:         } else {
 52503:             setter = (shape->hasDefaultSetter() && !shape->hasSetterValue())
 78614:                      ? JS_StrictPropertyStub
 52503:                      : shape->setter();
 41860:         }
 36991:     }
 36991: 
 36991:     *rval = true;
 55492: 
 55492:     /*
 55492:      * Since "data" properties implemented using native C functions may rely on
 55492:      * side effects during setting, we must make them aware that they have been
 55492:      * "assigned"; deleting the property before redefining it does the trick.
 55492:      * See bug 539766, where we ran into problems when we redefined
 55492:      * arguments.length without making the property aware that its value had
 55492:      * been changed (which would have happened if we had deleted it before
 55492:      * redefining it or we had invoked its setter to change its value).
 55492:      */
 55492:     if (callDelProperty) {
 61707:         Value dummy = UndefinedValue();
 64250:         if (!CallJSPropertyOp(cx, obj2->getClass()->delProperty, obj2, id, &dummy))
 64250:             return false;
 64250:     }
 64250: 
102586:     return baseops::DefineGeneric(cx, obj, id, &v, getter, setter, attrs);
 36991: }
 36991: 
 36991: static JSBool
 95355: DefinePropertyOnArray(JSContext *cx, HandleObject obj, HandleId id, const PropDesc &desc,
 36991:                       bool throwError, bool *rval)
 36991: {
 36991:     /*
 36991:      * We probably should optimize dense array property definitions where
 36991:      * the descriptor describes a traditional array property (enumerable,
 36991:      * configurable, writable, numeric index or length without altering its
 36991:      * attributes).  Such definitions are probably unlikely, so we don't bother
 36991:      * for now.
 36991:      */
 95355:     if (obj->isDenseArray() && !JSObject::makeDenseArraySlow(cx, obj))
 36991:         return JS_FALSE;
 36991: 
 91688:     uint32_t oldLen = obj->getArrayLength();
 36991: 
 64250:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
 36991:         /*
 36991:          * Our optimization of storage of the length property of arrays makes
 36991:          * it very difficult to properly implement defining the property.  For
 36991:          * now simply throw an exception (NB: not merely Reject) on any attempt
 36991:          * to define the "length" property, rather than attempting to implement
 36991:          * some difficult-for-authors-to-grasp subset of that functionality.
 36991:          */
 54587:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_DEFINE_ARRAY_LENGTH);
 36991:         return JS_FALSE;
 36991:     }
 36991: 
 84755:     uint32_t index;
 64250:     if (js_IdIsIndex(id, &index)) {
 36991:         /*
 36991:         // Disabled until we support defining "length":
 36991:         if (index >= oldLen && lengthPropertyNotWritable())
 54587:             return ThrowTypeError(cx, JSMSG_CANT_APPEND_TO_ARRAY);
 36991:          */
 64250:         if (!DefinePropertyOnObject(cx, obj, id, desc, false, rval))
 36991:             return JS_FALSE;
 36991:         if (!*rval)
 54587:             return Reject(cx, obj, JSMSG_CANT_DEFINE_ARRAY_INDEX, throwError, rval);
 36991: 
 36991:         if (index >= oldLen) {
 36991:             JS_ASSERT(index != UINT32_MAX);
 77343:             obj->setArrayLength(cx, index + 1);
 36991:         }
 36991: 
 36991:         *rval = true;
 36991:         return JS_TRUE;
 36991:     }
 36991: 
 64250:     return DefinePropertyOnObject(cx, obj, id, desc, throwError, rval);
 36991: }
 36991: 
 76223: namespace js {
 76223: 
 76223: bool
 95355: DefineProperty(JSContext *cx, HandleObject obj, HandleId id, const PropDesc &desc, bool throwError,
 36991:                bool *rval)
 36991: {
 39928:     if (obj->isArray())
 64250:         return DefinePropertyOnArray(cx, obj, id, desc, throwError, rval);
 36991: 
 80442:     if (obj->getOps()->lookupGeneric) {
 42733:         if (obj->isProxy())
 97047:             return Proxy::defineProperty(cx, obj, id, desc.pd());
 54587:         return Reject(cx, obj, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
 42733:     }
 36991: 
 64250:     return DefinePropertyOnObject(cx, obj, id, desc, throwError, rval);
 36991: }
 36991: 
 76240: } /* namespace js */
 76223: 
 40356: JSBool
 95355: js_DefineOwnProperty(JSContext *cx, HandleObject obj, HandleId id, const Value &descriptor, JSBool *bp)
 48470: {
 48470:     AutoPropDescArrayRooter descs(cx);
 48470:     PropDesc *desc = descs.append();
 64250:     if (!desc || !desc->initialize(cx, descriptor))
 40356:         return false;
 40356: 
 40356:     bool rval;
 64250:     if (!DefineProperty(cx, obj, id, *desc, true, &rval))
 40356:         return false;
 40356:     *bp = !!rval;
 40356:     return true;
 40356: }
 40356: 
 36991: /* ES5 15.2.3.6: Object.defineProperty(O, P, Attributes) */
 36991: static JSBool
 91237: obj_defineProperty(JSContext *cx, unsigned argc, Value *vp)
 36991: {
 99421:     RootedObject obj(cx);
 95355:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.defineProperty", obj.address()))
 95355:         return false;
 95355: 
 99421:     RootedId id(cx);
 95355:     if (!ValueToId(cx, argc >= 2 ? vp[3] : UndefinedValue(), id.address()))
 36991:         return JS_FALSE;
 76223: 
 76223:     const Value descval = argc >= 3 ? vp[4] : UndefinedValue();
 76223: 
 76223:     JSBool junk;
 76223:     if (!js_DefineOwnProperty(cx, obj, id, descval, &junk))
 76223:         return false;
 76223: 
 48470:     vp->setObject(*obj);
 76223:     return true;
 73086: }
 73086: 
 76224: namespace js {
 76224: 
 76224: bool
 76224: ReadPropertyDescriptors(JSContext *cx, JSObject *props, bool checkAccessors,
 76224:                         AutoIdVector *ids, AutoPropDescArrayRooter *descs)
 76224: {
 76224:     if (!GetPropertyNames(cx, props, JSITER_OWNONLY, ids))
 76224:         return false;
 76224: 
 99421:     RootedId id(cx);
 76224:     for (size_t i = 0, len = ids->length(); i < len; i++) {
 98960:         id = (*ids)[i];
 76224:         PropDesc* desc = descs->append();
 76224:         Value v;
 78675:         if (!desc || !props->getGeneric(cx, id, &v) || !desc->initialize(cx, v, checkAccessors))
 76224:             return false;
 76224:     }
 76224:     return true;
 76224: }
 76224: 
 76224: } /* namespace js */
 36991: 
 42733: static bool
 95355: DefineProperties(JSContext *cx, HandleObject obj, JSObject *props)
 42733: {
 64250:     AutoIdVector ids(cx);
 48470:     AutoPropDescArrayRooter descs(cx);
 76224:     if (!ReadPropertyDescriptors(cx, props, true, &ids, &descs))
 76224:         return false;
 42733: 
 36991:     bool dummy;
 76224:     for (size_t i = 0, len = ids.length(); i < len; i++) {
102586:         if (!DefineProperty(cx, obj, Handle<jsid>::fromMarkedLocation(&ids[i]), descs[i], true, &dummy))
 42733:             return false;
 42733:     }
 42733: 
 42733:     return true;
 42733: }
 42733: 
 42733: extern JSBool
 95355: js_PopulateObject(JSContext *cx, HandleObject newborn, JSObject *props)
 42733: {
 42733:     return DefineProperties(cx, newborn, props);
 42733: }
 42733: 
 42733: /* ES5 15.2.3.7: Object.defineProperties(O, Properties) */
 42733: static JSBool
 91237: obj_defineProperties(JSContext *cx, unsigned argc, Value *vp)
 42733: {
 64250:     /* Steps 1 and 7. */
 99421:     RootedObject obj(cx);
 95355:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.defineProperties", obj.address()))
 47569:         return false;
 48470:     vp->setObject(*obj);
 47569: 
 64250:     /* Step 2. */
 42733:     if (argc < 2) {
 42733:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
 42733:                              "Object.defineProperties", "0", "s");
 42733:         return false;
 42733:     }
 64250:     JSObject *props = ToObject(cx, &vp[3]);
 42733:     if (!props)
 42733:         return false;
 64250: 
 64250:     /* Steps 3-6. */
 42733:     return DefineProperties(cx, obj, props);
 36991: }
 36991: 
 37000: /* ES5 15.2.3.5: Object.create(O [, Properties]) */
 37000: static JSBool
 91237: obj_create(JSContext *cx, unsigned argc, Value *vp)
 37000: {
 37000:     if (argc == 0) {
 37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
 37000:                              "Object.create", "0", "s");
 91388:         return false;
 91388:     }
 91388: 
 91388:     CallArgs args = CallArgsFromVp(argc, vp);
 91388:     const Value &v = args[0];
 48470:     if (!v.isObjectOrNull()) {
 48470:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);
 37000:         if (!bytes)
 91388:             return false;
 37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
 37000:                              bytes, "not an object or null");
 37000:         JS_free(cx, bytes);
 91388:         return false;
 37000:     }
 37000: 
 73086:     JSObject *proto = v.toObjectOrNull();
 98644: #if JS_HAS_XML_SUPPORT
 73086:     if (proto && proto->isXML()) {
 72561:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_XML_PROTO_FORBIDDEN);
 72561:         return false;
 72561:     }
 98644: #endif
 72561: 
 37000:     /*
 47497:      * Use the callee's global as the parent of the new object to avoid dynamic
 47497:      * scoping (i.e., using the caller's global).
 37000:      */
 99421:     RootedObject obj(cx);
 95355:     obj = NewObjectWithGivenProto(cx, &ObjectClass, proto, &args.callee().global());
 37000:     if (!obj)
 91388:         return false;
 37000: 
 77343:     /* Don't track types or array-ness for objects created here. */
 77353:     MarkTypeObjectUnknownProperties(cx, obj->type());
 77343: 
 37000:     /* 15.2.3.5 step 4. */
 91388:     if (args.hasDefined(1)) {
 91388:         if (args[1].isPrimitive()) {
 37010:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
 91388:             return false;
 91388:         }
 91388: 
 91388:         if (!DefineProperties(cx, obj, &args[1].toObject()))
 91388:             return false;
 37000:     }
 37000: 
 37000:     /* 5. Return obj. */
 91388:     args.rval().setObject(*obj);
 91388:     return true;
 37000: }
 37000: 
 47569: static JSBool
 91237: obj_getOwnPropertyNames(JSContext *cx, unsigned argc, Value *vp)
 47569: {
 47569:     JSObject *obj;
 47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.getOwnPropertyNames", &obj))
 47569:         return false;
 47569: 
 48470:     AutoIdVector keys(cx);
 54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &keys))
 47569:         return false;
 47569: 
 48470:     AutoValueVector vals(cx);
 48470:     if (!vals.resize(keys.length()))
 48470:         return false;
 48470: 
 48470:     for (size_t i = 0, len = keys.length(); i < len; i++) {
 48470:          jsid id = keys[i];
 48470:          if (JSID_IS_INT(id)) {
102228:              JSString *str = Int32ToString(cx, JSID_TO_INT(id));
 47569:              if (!str)
 47569:                  return false;
 48470:              vals[i].setString(str);
 48470:          } else if (JSID_IS_ATOM(id)) {
 48470:              vals[i].setString(JSID_TO_STRING(id));
 48470:          } else {
 48470:              vals[i].setObject(*JSID_TO_OBJECT(id));
 48470:          }
 48470:     }
 48470: 
 59234:     JSObject *aobj = NewDenseCopiedArray(cx, vals.length(), vals.begin());
 47569:     if (!aobj)
 47569:         return false;
 47569: 
 48470:     vp->setObject(*aobj);
 47569:     return true;
 47569: }
 47569: 
 54563: static JSBool
 91237: obj_isExtensible(JSContext *cx, unsigned argc, Value *vp)
 54563: {
 54563:     JSObject *obj;
 54563:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.isExtensible", &obj))
 54563:         return false;
 54563: 
 54563:     vp->setBoolean(obj->isExtensible());
 54563:     return true;
 54563: }
 54563: 
 54563: static JSBool
 91237: obj_preventExtensions(JSContext *cx, unsigned argc, Value *vp)
 54563: {
 54563:     JSObject *obj;
 54563:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.preventExtensions", &obj))
 54563:         return false;
 54563: 
 54563:     vp->setObject(*obj);
 57813:     if (!obj->isExtensible())
 57813:         return true;
 54563: 
 97157:     return obj->preventExtensions(cx);
 54563: }
 54563: 
 91237: /* static */ inline unsigned
 91237: JSObject::getSealedOrFrozenAttributes(unsigned attrs, ImmutabilityType it)
 86736: {
 86736:     /* Make all attributes permanent; if freezing, make data attributes read-only. */
 86736:     if (it == FREEZE && !(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
 86736:         return JSPROP_PERMANENT | JSPROP_READONLY;
 86736:     return JSPROP_PERMANENT;
 86736: }
 86736: 
 54563: bool
 57813: JSObject::sealOrFreeze(JSContext *cx, ImmutabilityType it)
 54563: {
 54563:     assertSameCompartment(cx, this);
 57813:     JS_ASSERT(it == SEAL || it == FREEZE);
 54563: 
 99421:     RootedObject self(cx, this);
 86437: 
 97157:     if (isExtensible() && !preventExtensions(cx))
 97157:         return false;
 97157: 
 54563:     AutoIdVector props(cx);
 97731:     if (!GetPropertyNames(cx, self, JSITER_HIDDEN | JSITER_OWNONLY, &props))
 54563:         return false;
 54563: 
 54563:     /* preventExtensions must slowify dense arrays, so we can assign to holes without checks. */
 86437:     JS_ASSERT(!self->isDenseArray());
 54563: 
 95355:     if (self->isNative() && !self->inDictionaryMode()) {
 86736:         /*
 86736:          * Seal/freeze non-dictionary objects by constructing a new shape
 86736:          * hierarchy mirroring the original one, which can be shared if many
 86736:          * objects with the same structure are sealed/frozen. If we use the
 86736:          * generic path below then any non-empty object will be converted to
 86736:          * dictionary mode.
 86736:          */
 86736:         Shape *last = EmptyShape::getInitialShape(cx, self->getClass(),
 86736:                                                   self->getProto(),
 86736:                                                   self->getParent(),
 86736:                                                   self->getAllocKind(),
 86736:                                                   self->lastProperty()->getObjectFlags());
 86736:         if (!last)
 86736:             return false;
 86736: 
 86736:         /* Get an in order list of the shapes in this object. */
 86736:         AutoShapeVector shapes(cx);
 86736:         for (Shape::Range r = self->lastProperty()->all(); !r.empty(); r.popFront()) {
 86736:             if (!shapes.append(&r.front()))
 86736:                 return false;
 86736:         }
 86736:         Reverse(shapes.begin(), shapes.end());
 86736: 
 86736:         for (size_t i = 0; i < shapes.length(); i++) {
 86736:             StackShape child(shapes[i]);
 86736:             child.attrs |= getSealedOrFrozenAttributes(child.attrs, it);
 86736: 
 86736:             if (!JSID_IS_EMPTY(child.propid))
 86736:                 MarkTypePropertyConfigured(cx, self, child.propid);
 86736: 
 98835:             last = cx->propertyTree().getChild(cx, last, self->numFixedSlots(), child);
 86736:             if (!last)
101773:                 return false;
 86736:         }
 86736: 
 86736:         JS_ASSERT(self->lastProperty()->slotSpan() == last->slotSpan());
 95355:         JS_ALWAYS_TRUE(self->setLastProperty(cx, last));
 86736:     } else {
 99421:         RootedId id(cx);
 86736:         for (size_t i = 0; i < props.length(); i++) {
 98960:             id = props[i];
 54563: 
 91237:             unsigned attrs;
 86437:             if (!self->getGenericAttributes(cx, id, &attrs))
 54563:                 return false;
 54563: 
 91237:             unsigned new_attrs = getSealedOrFrozenAttributes(attrs, it);
 54563: 
 54563:             /* If we already have the attributes we need, skip the setAttributes call. */
 54563:             if ((attrs | new_attrs) == attrs)
 54563:                 continue;
 54563: 
 54563:             attrs |= new_attrs;
 86437:             if (!self->setGenericAttributes(cx, id, &attrs))
 54563:                 return false;
 54563:         }
 86736:     }
 54563: 
 54563:     return true;
 54563: }
 32721: 
 76228: bool
 76228: JSObject::isSealedOrFrozen(JSContext *cx, ImmutabilityType it, bool *resultp)
 76228: {
 76228:     if (isExtensible()) {
 76228:         *resultp = false;
 76228:         return true;
 76228:     }
 76228: 
 76228:     AutoIdVector props(cx);
 76228:     if (!GetPropertyNames(cx, this, JSITER_HIDDEN | JSITER_OWNONLY, &props))
 76228:         return false;
 76228: 
 99421:     RootedId id(cx);
 76228:     for (size_t i = 0, len = props.length(); i < len; i++) {
 98960:         id = props[i];
 76228: 
 91237:         unsigned attrs;
 80622:         if (!getGenericAttributes(cx, id, &attrs))
 76228:             return false;
 76228: 
 76228:         /*
 76228:          * If the property is configurable, this object is neither sealed nor
 76228:          * frozen. If the property is a writable data property, this object is
 76228:          * not frozen.
 76228:          */
 76228:         if (!(attrs & JSPROP_PERMANENT) ||
 76228:             (it == FREEZE && !(attrs & (JSPROP_READONLY | JSPROP_GETTER | JSPROP_SETTER))))
 76228:         {
 76228:             *resultp = false;
 76228:             return true;
 76228:         }
 76228:     }
 76228: 
 76228:     /* All properties checked out. This object is sealed/frozen. */
 76228:     *resultp = true;
 76228:     return true;
 76228: }
 76228: 
 54564: static JSBool
 91237: obj_freeze(JSContext *cx, unsigned argc, Value *vp)
 54564: {
 54564:     JSObject *obj;
 54564:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.freeze", &obj))
 54564:         return false;
 54564: 
 54564:     vp->setObject(*obj);
 54564: 
 54564:     return obj->freeze(cx);
 54564: }
 54564: 
 54564: static JSBool
 91237: obj_isFrozen(JSContext *cx, unsigned argc, Value *vp)
 54564: {
 54564:     JSObject *obj;
 54564:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.preventExtensions", &obj))
 54564:         return false;
 54564: 
 76228:     bool frozen;
 76228:     if (!obj->isFrozen(cx, &frozen))
 76228:         return false;
 76228:     vp->setBoolean(frozen);
 54565:     return true;
 54565: }
 54565: 
 54565: static JSBool
 91237: obj_seal(JSContext *cx, unsigned argc, Value *vp)
 54565: {
 54565:     JSObject *obj;
 54565:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.seal", &obj))
 54565:         return false;
 54565: 
 54565:     vp->setObject(*obj);
 54565: 
 54565:     return obj->seal(cx);
 54565: }
 54565: 
 54565: static JSBool
 91237: obj_isSealed(JSContext *cx, unsigned argc, Value *vp)
 54565: {
 54565:     JSObject *obj;
 54565:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.isSealed", &obj))
 54565:         return false;
 54565: 
 76228:     bool sealed;
 76228:     if (!obj->isSealed(cx, &sealed))
 76228:         return false;
 76228:     vp->setBoolean(sealed);
 54564:     return true;
 54564: }
 54564: 
 78466: JSFunctionSpec object_methods[] = {
     1: #if JS_HAS_TOSOURCE
 16519:     JS_FN(js_toSource_str,             obj_toSource,                0,0),
     1: #endif
 59941:     JS_FN(js_toString_str,             obj_toString,                0,0),
 16519:     JS_FN(js_toLocaleString_str,       obj_toLocaleString,          0,0),
 41856:     JS_FN(js_valueOf_str,              obj_valueOf,                 0,0),
     1: #if JS_HAS_OBJ_WATCHPOINT
 16519:     JS_FN(js_watch_str,                obj_watch,                   2,0),
 16519:     JS_FN(js_unwatch_str,              obj_unwatch,                 1,0),
     1: #endif
 41856:     JS_FN(js_hasOwnProperty_str,       obj_hasOwnProperty,          1,0),
 16519:     JS_FN(js_isPrototypeOf_str,        obj_isPrototypeOf,           1,0),
 41856:     JS_FN(js_propertyIsEnumerable_str, obj_propertyIsEnumerable,    1,0),
 40855: #if OLD_GETTER_SETTER_METHODS
 79734:     JS_FN(js_defineGetter_str,         js::obj_defineGetter,        2,0),
 79734:     JS_FN(js_defineSetter_str,         js::obj_defineSetter,        2,0),
 16519:     JS_FN(js_lookupGetter_str,         obj_lookupGetter,            1,0),
 16519:     JS_FN(js_lookupSetter_str,         obj_lookupSetter,            1,0),
     1: #endif
  4127:     JS_FS_END
     1: };
     1: 
 78466: JSFunctionSpec object_static_methods[] = {
 16519:     JS_FN("getPrototypeOf",            obj_getPrototypeOf,          1,0),
 32721:     JS_FN("getOwnPropertyDescriptor",  obj_getOwnPropertyDescriptor,2,0),
 33155:     JS_FN("keys",                      obj_keys,                    1,0),
 36991:     JS_FN("defineProperty",            obj_defineProperty,          3,0),
 36991:     JS_FN("defineProperties",          obj_defineProperties,        2,0),
 37000:     JS_FN("create",                    obj_create,                  2,0),
 47569:     JS_FN("getOwnPropertyNames",       obj_getOwnPropertyNames,     1,0),
 54563:     JS_FN("isExtensible",              obj_isExtensible,            1,0),
 54563:     JS_FN("preventExtensions",         obj_preventExtensions,       1,0),
 54564:     JS_FN("freeze",                    obj_freeze,                  1,0),
 54564:     JS_FN("isFrozen",                  obj_isFrozen,                1,0),
 54565:     JS_FN("seal",                      obj_seal,                    1,0),
 54565:     JS_FN("isSealed",                  obj_isSealed,                1,0),
 16380:     JS_FS_END
 16380: };
 16380: 
 30439: JSBool
 91237: js_Object(JSContext *cx, unsigned argc, Value *vp)
 50489: {
 50489:     JSObject *obj;
 30439:     if (argc == 0) {
 30439:         /* Trigger logic below to construct a blank object. */
 30439:         obj = NULL;
 30439:     } else {
 30439:         /* If argv[0] is null or undefined, obj comes back null. */
 50489:         if (!js_ValueToObjectOrNull(cx, vp[2], &obj))
 30439:             return JS_FALSE;
 30439:     }
 30439:     if (!obj) {
 50489:         /* Make an object whether this was called with 'new' or not. */
 50489:         JS_ASSERT(!argc || vp[2].isNull() || vp[2].isUndefined());
 77817:         gc::AllocKind kind = NewObjectGCKind(cx, &ObjectClass);
 77817:         obj = NewBuiltinClassInstance(cx, &ObjectClass, kind);
 30439:         if (!obj)
 30439:             return JS_FALSE;
103065:         jsbytecode *pc;
103065:         JSScript *script = cx->stack.currentScript(&pc);
103065:         if (script) {
103065:             /* Try to specialize the type of the object to the scripted call site. */
103065:             if (!types::SetInitializerObjectType(cx, script, pc, obj))
 77343:                 return JS_FALSE;
103065:         }
 30439:     }
 50489:     vp->setObject(*obj);
 30439:     return JS_TRUE;
 30439: }
 30439: 
 83276: static inline JSObject *
 99364: NewObject(JSContext *cx, Class *clasp, types::TypeObject *type_, JSObject *parent,
 83276:           gc::AllocKind kind)
 83276: {
 83276:     JS_ASSERT(clasp != &ArrayClass);
 83276:     JS_ASSERT_IF(clasp == &FunctionClass,
 83276:                  kind == JSFunction::FinalizeKind || kind == JSFunction::ExtendedFinalizeKind);
102757:     JS_ASSERT_IF(parent, parent->global() == cx->compartment->global());
 83276: 
 99421:     RootedTypeObject type(cx, type_);
 99421: 
 99421:     RootedShape shape(cx);
 86437:     shape = EmptyShape::getInitialShape(cx, clasp, type->proto, parent, kind);
 83276:     if (!shape)
 83276:         return NULL;
 83276: 
 91146:     HeapSlot *slots;
 83314:     if (!PreallocateObjectDynamicSlots(cx, shape, &slots))
 83276:         return NULL;
 83276: 
 99364:     JSObject *obj = JSObject::create(cx, kind, shape, type, slots);
102715:     if (!obj) {
102715:         cx->free_(slots);
 83276:         return NULL;
102715:     }
 83276: 
 90410:     /*
 90410:      * This will cancel an already-running incremental GC from doing any more
 90410:      * slices, and it will prevent any future incremental GCs.
 90410:      */
 90410:     if (clasp->trace && !(clasp->flags & JSCLASS_IMPLEMENTS_BARRIERS))
 90410:         cx->runtime->gcIncrementalEnabled = false;
 90410: 
 83276:     Probes::createObject(cx, obj);
 83276:     return obj;
 83276: }
 83276: 
 80993: JSObject *
 99364: js::NewObjectWithGivenProto(JSContext *cx, js::Class *clasp, JSObject *proto_, JSObject *parent_,
 83275:                             gc::AllocKind kind)
 83275: {
 99421:     RootedObject proto(cx, proto_), parent(cx, parent_);
 99364: 
 83276:     if (CanBeFinalizedInBackground(kind, clasp))
 83276:         kind = GetBackgroundAllocKind(kind);
 83276: 
 97465:     NewObjectCache &cache = cx->runtime->newObjectCache;
 83313: 
 83313:     NewObjectCache::EntryIndex entry = -1;
 83276:     if (proto && (!parent || parent == proto->getParent()) && !proto->isGlobal()) {
 83313:         if (cache.lookupProto(clasp, proto, kind, &entry))
 83313:             return cache.newObjectFromHit(cx, entry);
 83276:     }
 83276: 
 83275:     types::TypeObject *type = proto ? proto->getNewType(cx) : cx->compartment->getEmptyType(cx);
 83275:     if (!type)
 83275:         return NULL;
 83275: 
 83276:     /*
 83276:      * Default parent to the parent of the prototype, which was set from
 83276:      * the parent of the prototype's constructor.
 83276:      */
 83276:     if (!parent && proto)
 83276:         parent = proto->getParent();
 83276: 
 83276:     JSObject *obj = NewObject(cx, clasp, type, parent, kind);
 83276:     if (!obj)
 83276:         return NULL;
 83276: 
 83313:     if (entry != -1 && !obj->hasDynamicSlots())
 83313:         cache.fillProto(entry, clasp, proto, kind, obj);
 83276: 
 83276:     return obj;
 83276: }
 83276: 
 83276: JSObject *
 99364: js::NewObjectWithClassProto(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent_,
 83276:                             gc::AllocKind kind)
 83276: {
 83276:     if (proto)
 99364:         return NewObjectWithGivenProto(cx, clasp, proto, parent_, kind);
 99364: 
 99421:     RootedObject parent(cx, parent_);
 83275: 
 83275:     if (CanBeFinalizedInBackground(kind, clasp))
 83275:         kind = GetBackgroundAllocKind(kind);
 83275: 
 83276:     if (!parent)
 83276:         parent = GetCurrentGlobal(cx);
 83276: 
 83306:     /*
 83306:      * Use the object cache, except for classes without a cached proto key.
 83306:      * On these objects, FindProto will do a dynamic property lookup to get
 83306:      * global[className].prototype, where changes to either the className or
 83306:      * prototype property would render the cached lookup incorrect. For classes
 83306:      * with a proto key, the prototype created during class initialization is
 83306:      * stored in an immutable slot on the global (except for ClearScope, which
 83306:      * will flush the new object cache).
 83306:      */
 83306:     JSProtoKey protoKey = GetClassProtoKey(clasp);
 83306: 
 97465:     NewObjectCache &cache = cx->runtime->newObjectCache;
 83313: 
 83313:     NewObjectCache::EntryIndex entry = -1;
 83306:     if (parent->isGlobal() && protoKey != JSProto_Null) {
 86483:         if (cache.lookupGlobal(clasp, &parent->asGlobal(), kind, &entry))
 83313:             return cache.newObjectFromHit(cx, entry);
 83276:     }
 83276: 
 99364:     if (!FindProto(cx, clasp, parent, &proto))
 83275:         return NULL;
 83275: 
 83276:     types::TypeObject *type = proto->getNewType(cx);
 83276:     if (!type)
 83275:         return NULL;
 83275: 
 83276:     JSObject *obj = NewObject(cx, clasp, type, parent, kind);
 83275:     if (!obj)
 83275:         return NULL;
 83275: 
 83313:     if (entry != -1 && !obj->hasDynamicSlots())
 86483:         cache.fillGlobal(entry, clasp, &parent->asGlobal(), kind, obj);
 83276: 
 83275:     return obj;
 83275: }
 83275: 
 83275: JSObject *
 95355: js::NewObjectWithType(JSContext *cx, HandleTypeObject type, JSObject *parent, gc::AllocKind kind)
 83275: {
 83275:     JS_ASSERT(type->proto->hasNewType(type));
 83276:     JS_ASSERT(parent);
 83275: 
101075:     JS_ASSERT(kind <= gc::FINALIZE_OBJECT_LAST);
 83275:     if (CanBeFinalizedInBackground(kind, &ObjectClass))
 83275:         kind = GetBackgroundAllocKind(kind);
 83275: 
 97465:     NewObjectCache &cache = cx->runtime->newObjectCache;
 83313: 
 83313:     NewObjectCache::EntryIndex entry = -1;
 83276:     if (parent == type->proto->getParent()) {
 83313:         if (cache.lookupType(&ObjectClass, type, kind, &entry))
 83313:             return cache.newObjectFromHit(cx, entry);
 83276:     }
 83276: 
 83276:     JSObject *obj = NewObject(cx, &ObjectClass, type, parent, kind);
 83275:     if (!obj)
 83275:         return NULL;
 83275: 
 83313:     if (entry != -1 && !obj->hasDynamicSlots())
 83313:         cache.fillType(entry, &ObjectClass, type, kind, obj);
 83276: 
 83275:     return obj;
 83275: }
 83275: 
 53557: JSObject *
 95355: js::NewReshapedObject(JSContext *cx, HandleTypeObject type, JSObject *parent,
 77775:                       gc::AllocKind kind, const Shape *shape)
 77343: {
 99421:     RootedObject res(cx, NewObjectWithType(cx, type, parent, kind));
 77343:     if (!res)
 77343:         return NULL;
 77343: 
 83221:     if (shape->isEmptyShape())
 77343:         return res;
 77343: 
 77343:     /* Get all the ids in the object, in order. */
 77343:     js::AutoIdVector ids(cx);
 83221:     for (unsigned i = 0; i <= shape->slot(); i++) {
 77343:         if (!ids.append(JSID_VOID))
 77343:             return NULL;
 77343:     }
 77343:     const js::Shape *nshape = shape;
 83221:     while (!nshape->isEmptyShape()) {
 83221:         ids[nshape->slot()] = nshape->propid();
 77343:         nshape = nshape->previous();
 77343:     }
 77343: 
 77343:     /* Construct the new shape. */
 99421:     RootedId id(cx);
 77343:     for (unsigned i = 0; i < ids.length(); i++) {
 98960:         id = ids[i];
 98960:         if (!DefineNativeProperty(cx, res, id, js::UndefinedValue(), NULL, NULL,
 77343:                                   JSPROP_ENUMERATE, 0, 0, DNP_SKIP_TYPE)) {
 77343:             return NULL;
 77343:         }
 77343:     }
 77343:     JS_ASSERT(!res->inDictionaryMode());
 77343: 
 77343:     return res;
 77343: }
 77343: 
 77343: JSObject*
 94094: js_CreateThis(JSContext *cx, Class *newclasp, JSObject *callee)
 94094: {
 53557:     Value protov;
 78675:     if (!callee->getProperty(cx, cx->runtime->atomState.classPrototypeAtom, &protov))
 53557:         return NULL;
 53557: 
 53557:     JSObject *proto = protov.isObjectOrNull() ? protov.toObjectOrNull() : NULL;
 53557:     JSObject *parent = callee->getParent();
 77775:     gc::AllocKind kind = NewObjectGCKind(cx, newclasp);
 83275:     return NewObjectWithClassProto(cx, newclasp, proto, parent, kind);
 53557: }
 53557: 
 77343: static inline JSObject *
 95355: CreateThisForFunctionWithType(JSContext *cx, HandleTypeObject type, JSObject *parent)
 77343: {
 77343:     if (type->newScript) {
 77343:         /*
 77343:          * Make an object with the type's associated finalize kind and shape,
 77343:          * which reflects any properties that will definitely be added to the
 77343:          * object before it is read from.
 77343:          */
 77775:         gc::AllocKind kind = type->newScript->allocKind;
 77343:         JSObject *res = NewObjectWithType(cx, type, parent, kind);
 77343:         if (res)
 83301:             JS_ALWAYS_TRUE(res->setLastProperty(cx, (Shape *) type->newScript->shape.get()));
 77343:         return res;
 77343:     }
 77343: 
 77817:     gc::AllocKind kind = NewObjectGCKind(cx, &ObjectClass);
 77343:     return NewObjectWithType(cx, type, parent, kind);
 77343: }
 77343: 
 55503: JSObject *
 95355: js_CreateThisForFunctionWithProto(JSContext *cx, HandleObject callee, JSObject *proto)
 55503: {
 77361:     JSObject *res;
 77361: 
 77343:     if (proto) {
 99421:         RootedTypeObject type(cx, proto->getNewType(cx, callee->toFunction()));
 77343:         if (!type)
 77343:             return NULL;
 77361:         res = CreateThisForFunctionWithType(cx, type, callee->getParent());
 77361:     } else {
 77817:         gc::AllocKind kind = NewObjectGCKind(cx, &ObjectClass);
 83275:         res = NewObjectWithClassProto(cx, &ObjectClass, proto, callee->getParent(), kind);
 77361:     }
 77361: 
 77361:     if (res && cx->typeInferenceEnabled())
 83234:         TypeScript::SetThis(cx, callee->toFunction()->script(), types::Type::ObjectType(res));
 77361: 
 77361:     return res;
 55503: }
 55503: 
 55503: JSObject *
 95355: js_CreateThisForFunction(JSContext *cx, HandleObject callee, bool newType)
 55503: {
 55503:     Value protov;
 78675:     if (!callee->getProperty(cx, cx->runtime->atomState.classPrototypeAtom, &protov))
 55503:         return NULL;
 77343:     JSObject *proto;
 77343:     if (protov.isObject())
 77343:         proto = &protov.toObject();
 77343:     else
 77343:         proto = NULL;
 77343:     JSObject *obj = js_CreateThisForFunctionWithProto(cx, callee, proto);
 77343: 
 77343:     if (obj && newType) {
 77343:         /*
 77353:          * Reshape the object and give it a (lazily instantiated) singleton
 77353:          * type before passing it as the 'this' value for the call.
 77353:          */
 77353:         obj->clear(cx);
 77353:         if (!obj->setSingletonType(cx))
 77353:             return NULL;
 77353: 
 83234:         JSScript *calleeScript = callee->toFunction()->script();
 77391:         TypeScript::SetThis(cx, calleeScript, types::Type::ObjectType(obj));
 77343:     }
 77343: 
 77343:     return obj;
 55503: }
 55503: 
     1: /*
 23435:  * Given pc pointing after a property accessing bytecode, return true if the
 23435:  * access is "object-detecting" in the sense used by web scripts, e.g., when
 23435:  * checking whether document.all is defined.
 23435:  */
 90965: static bool
 23435: Detecting(JSContext *cx, jsbytecode *pc)
 23435: {
 90965:     /* General case: a branch or equality op follows the access. */
 90965:     JSOp op = JSOp(*pc);
 90965:     if (js_CodeSpec[op].format & JOF_DETECTING)
 90965:         return true;
 90965: 
 23435:     JSAtom *atom;
 23435: 
 77343:     JSScript *script = cx->stack.currentScript();
 90965:     jsbytecode *endpc = script->code + script->length;
 82642:     JS_ASSERT(script->code <= pc && pc < endpc);
 25474: 
 90965:     if (op == JSOP_NULL) {
 23435:         /*
 23435:          * Special case #1: handle (document.all == null).  Don't sweat
 23435:          * about JS1.2's revision of the equality operators here.
 23435:          */
 25474:         if (++pc < endpc) {
 84195:             op = JSOp(*pc);
 84950:             return op == JSOP_EQ || op == JSOP_NE;
 25474:         }
 90965:         return false;
 90965:     }
 90965: 
 90965:     if (op == JSOP_GETGNAME || op == JSOP_NAME) {
 23435:         /*
 90965:          * Special case #2: handle (document.all == undefined).  Don't worry
 90965:          * about a local variable named |undefined| shadowing the immutable
 90965:          * global binding...because, really?
 23435:          */
 90965:         atom = script->getAtom(GET_UINT32_INDEX(pc));
 25474:         if (atom == cx->runtime->atomState.typeAtoms[JSTYPE_VOID] &&
 25474:             (pc += js_CodeSpec[op].length) < endpc) {
 84195:             op = JSOp(*pc);
 90965:             return op == JSOP_EQ || op == JSOP_NE || op == JSOP_STRICTEQ || op == JSOP_STRICTNE;
 90965:         }
 90965:     }
 90965: 
 90965:     return false;
 23435: }
 23435: 
 23435: /*
101158:  * Infer lookup flags from the currently executing bytecode, returning
101158:  * defaultFlags if a currently executing bytecode cannot be determined.
 23435:  */
 91237: unsigned
 91237: js_InferFlags(JSContext *cx, unsigned defaultFlags)
 23435: {
 23435:     const JSCodeSpec *cs;
 84755:     uint32_t format;
 91237:     unsigned flags = 0;
 23435: 
 77343:     jsbytecode *pc;
 77343:     JSScript *script = cx->stack.currentScript(&pc);
 77343:     if (!script || !pc)
 23435:         return defaultFlags;
 77343: 
 84195:     cs = &js_CodeSpec[*pc];
 23435:     format = cs->format;
 23435:     if (JOF_MODE(format) != JOF_NAME)
 23435:         flags |= JSRESOLVE_QUALIFIED;
 83221:     if (format & JOF_SET) {
 23435:         flags |= JSRESOLVE_ASSIGNING;
 32680:     } else if (cs->length >= 0) {
 23435:         pc += cs->length;
 51446:         if (pc < script->code + script->length && Detecting(cx, pc))
 23435:             flags |= JSRESOLVE_DETECTING;
 23435:     }
 23435:     if (format & JOF_DECLARING)
 23435:         flags |= JSRESOLVE_DECLARING;
 23435:     return flags;
 23435: }
 23435: 
 74472: JSBool
 98960: JSObject::nonNativeSetProperty(JSContext *cx, HandleId id, js::Value *vp, JSBool strict)
 98960: {
 99421:     RootedObject self(cx, this);
 74472:     if (JS_UNLIKELY(watched())) {
 74472:         WatchpointMap *wpmap = cx->compartment->watchpointMap;
 98960:         if (wpmap && !wpmap->triggerWatchpoint(cx, self, id, vp))
 97353:             return false;
 97353:     }
 97353:     return self->getOps()->setGeneric(cx, self, id, vp, strict);
 74472: }
 74472: 
 78346: JSBool
 84755: JSObject::nonNativeSetElement(JSContext *cx, uint32_t index, js::Value *vp, JSBool strict)
 78346: {
 99421:     RootedObject self(cx, this);
 78346:     if (JS_UNLIKELY(watched())) {
 99421:         RootedId id(cx);
 98960:         if (!IndexToId(cx, index, id.address()))
 98960:             return false;
 97353: 
 78346:         WatchpointMap *wpmap = cx->compartment->watchpointMap;
 98960:         if (wpmap && !wpmap->triggerWatchpoint(cx, self, id, vp))
 97353:             return false;
 97353:     }
 97353:     return self->getOps()->setElement(cx, self, index, vp, strict);
 78346: }
 78346: 
 86790: bool
 86790: JSObject::deleteByValue(JSContext *cx, const Value &property, Value *rval, bool strict)
 86790: {
 86790:     uint32_t index;
 86790:     if (IsDefinitelyIndex(property, &index))
 86790:         return deleteElement(cx, index, rval, strict);
 86790: 
 86790:     Value propval = property;
102586:     Rooted<SpecialId> sid(cx);
102586:     if (ValueIsSpecial(this, &propval, sid.address(), cx))
102586:         return deleteSpecial(cx, sid, rval, strict);
 99421: 
 99421:     RootedObject self(cx, this);
 97353: 
102387:     JSAtom *name = ToAtom(cx, propval);
102387:     if (!name)
 86790:         return false;
 86790: 
 86790:     if (name->isIndex(&index))
 97353:         return self->deleteElement(cx, index, rval, false);
 97353: 
102586:     Rooted<PropertyName*> propname(cx, name->asPropertyName());
102586:     return self->deleteProperty(cx, propname, rval, false);
 86790: }
 86790: 
 79734: JS_FRIEND_API(bool)
 79734: JS_CopyPropertiesFrom(JSContext *cx, JSObject *target, JSObject *obj)
 58714: {
 58714:     // If we're not native, then we cannot copy properties.
 79734:     JS_ASSERT(target->isNative() == obj->isNative());
 79734:     if (!target->isNative())
 58714:         return true;
 58714: 
 62363:     AutoShapeVector shapes(cx);
 58714:     for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
 58714:         if (!shapes.append(&r.front()))
 58714:             return false;
 58714:     }
 58714: 
 58714:     size_t n = shapes.length();
 58714:     while (n > 0) {
 58714:         const Shape *shape = shapes[--n];
 91237:         unsigned attrs = shape->attributes();
 58714:         PropertyOp getter = shape->getter();
 98960:         StrictPropertyOp setter = shape->setter();
 99364:         AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
 98953:         if ((attrs & JSPROP_GETTER) && !cx->compartment->wrap(cx, &getter))
 98953:             return false;
 58714:         if ((attrs & JSPROP_SETTER) && !cx->compartment->wrap(cx, &setter))
 58714:             return false;
 83221:         Value v = shape->hasSlot() ? obj->getSlot(shape->slot()) : UndefinedValue();
 58714:         if (!cx->compartment->wrap(cx, &v))
 58714:             return false;
102586:         Rooted<jsid> id(cx, shape->propid());
102586:         if (!target->defineGeneric(cx, id, v, getter, setter, attrs))
 58714:             return false;
 58714:     }
 58714:     return true;
 58714: }
 58714: 
 58714: static bool
 58714: CopySlots(JSContext *cx, JSObject *from, JSObject *to)
 58714: {
 58714:     JS_ASSERT(!from->isNative() && !to->isNative());
 83231:     JS_ASSERT(from->getClass() == to->getClass());
 58714: 
 58714:     size_t n = 0;
 74459:     if (from->isWrapper() &&
 95795:         (Wrapper::wrapperHandler(from)->flags() &
 95795:          Wrapper::CROSS_COMPARTMENT)) {
 74457:         to->setSlot(0, from->getSlot(0));
 74457:         to->setSlot(1, from->getSlot(1));
 58714:         n = 2;
 58714:     }
 58714: 
 83231:     size_t span = JSCLASS_RESERVED_SLOTS(from->getClass());
 83231:     for (; n < span; ++n) {
 74457:         Value v = from->getSlot(n);
 58714:         if (!cx->compartment->wrap(cx, &v))
 58714:             return false;
 74457:         to->setSlot(n, v);
 58714:     }
 58714:     return true;
 58714: }
 58714: 
 79734: JS_FRIEND_API(JSObject *)
 95355: JS_CloneObject(JSContext *cx, JSObject *obj_, JSObject *proto_, JSObject *parent_)
 95355: {
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedObject proto(cx, proto_);
 99421:     RootedObject parent(cx, parent_);
 95355: 
 58714:     /*
 58714:      * We can only clone native objects and proxies. Dense arrays are slowified if
 58714:      * we try to clone them.
 58714:      */
 79734:     if (!obj->isNative()) {
 79734:         if (obj->isDenseArray()) {
 95355:             if (!JSObject::makeDenseArraySlow(cx, obj))
 58714:                 return NULL;
 79734:         } else if (!obj->isProxy()) {
 58714:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 58714:                                  JSMSG_CANT_CLONE_OBJECT);
 58714:             return NULL;
 58714:         }
 58714:     }
 83275:     JSObject *clone = NewObjectWithGivenProto(cx, obj->getClass(), proto, parent, obj->getAllocKind());
 58714:     if (!clone)
 58714:         return NULL;
 79734:     if (obj->isNative()) {
 79734:         if (clone->isFunction() && (obj->compartment() != clone->compartment())) {
 58714:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 58714:                                  JSMSG_CANT_CLONE_OBJECT);
 58714:             return NULL;
 58714:         }
 58714: 
 83233:         if (obj->hasPrivate())
 79734:             clone->setPrivate(obj->getPrivate());
 58714:     } else {
 79734:         JS_ASSERT(obj->isProxy());
 79734:         if (!CopySlots(cx, obj, clone))
 58714:             return NULL;
 58714:     }
 74458: 
 58714:     return clone;
 58714: }
 58714: 
 77343: struct JSObject::TradeGutsReserved {
 77343:     JSContext *cx;
 77343:     Vector<Value> avals;
 77343:     Vector<Value> bvals;
 83236:     int newafixed;
 83236:     int newbfixed;
 83247:     Shape *newashape;
 83247:     Shape *newbshape;
 91146:     HeapSlot *newaslots;
 91146:     HeapSlot *newbslots;
 77343: 
 77343:     TradeGutsReserved(JSContext *cx)
 83233:         : cx(cx), avals(cx), bvals(cx),
 83233:           newafixed(0), newbfixed(0),
 83247:           newashape(NULL), newbshape(NULL),
 83233:           newaslots(NULL), newbslots(NULL)
 77343:     {}
 77343: 
 77343:     ~TradeGutsReserved()
 77343:     {
 77343:         if (newaslots)
 77343:             cx->free_(newaslots);
 77343:         if (newbslots)
 77343:             cx->free_(newbslots);
 77343:     }
 77343: };
 77343: 
 77343: bool
 77343: JSObject::ReserveForTradeGuts(JSContext *cx, JSObject *a, JSObject *b,
 77343:                               TradeGutsReserved &reserved)
 77343: {
 77343:     /*
 77343:      * When performing multiple swaps between objects which may have different
 77343:      * numbers of fixed slots, we reserve all space ahead of time so that the
 77343:      * swaps can be performed infallibly.
 77343:      */
 77343: 
 88142:     if (a->sizeOfThis() == b->sizeOfThis())
 77343:         return true;
 77343: 
 83221:     /*
 83221:      * If either object is native, it needs a new shape to preserve the
 83221:      * invariant that objects with the same shape have the same number of
 83247:      * inline slots. The fixed slots will be updated in place during TradeGuts.
 83247:      * Non-native objects need to be reshaped according to the new count.
 83247:      */
 83247:     if (a->isNative()) {
 83247:         if (!a->generateOwnShape(cx))
 83247:             return false;
 83247:     } else {
 83316:         reserved.newbshape = EmptyShape::getInitialShape(cx, a->getClass(),
 83297:                                                          a->getProto(), a->getParent(),
 83247:                                                          b->getAllocKind());
 83247:         if (!reserved.newbshape)
 83247:             return false;
 83247:     }
 83247:     if (b->isNative()) {
 83247:         if (!b->generateOwnShape(cx))
 83247:             return false;
 83247:     } else {
 83316:         reserved.newashape = EmptyShape::getInitialShape(cx, b->getClass(),
 83297:                                                          b->getProto(), b->getParent(),
 83247:                                                          a->getAllocKind());
 83247:         if (!reserved.newashape)
 83247:             return false;
 83247:     }
 83221: 
 77343:     /* The avals/bvals vectors hold all original values from the objects. */
 77343: 
 83231:     if (!reserved.avals.reserve(a->slotSpan()))
 83231:         return false;
 83231:     if (!reserved.bvals.reserve(b->slotSpan()))
 83231:         return false;
 83231: 
 83231:     JS_ASSERT(a->elements == emptyObjectElements);
 83231:     JS_ASSERT(b->elements == emptyObjectElements);
 79734: 
 79734:     /*
 83233:      * The newafixed/newbfixed hold the number of fixed slots in the objects
 83233:      * after the swap. Adjust these counts according to whether the objects
 83233:      * use their last fixed slot for storing private data.
 83233:      */
 83233: 
 83233:     reserved.newafixed = a->numFixedSlots();
 83233:     reserved.newbfixed = b->numFixedSlots();
 83233: 
 83233:     if (a->hasPrivate()) {
 83233:         reserved.newafixed++;
 83233:         reserved.newbfixed--;
 83233:     }
 83233:     if (b->hasPrivate()) {
 83233:         reserved.newbfixed++;
 83233:         reserved.newafixed--;
 83233:     }
 83233: 
 83236:     JS_ASSERT(reserved.newafixed >= 0);
 83236:     JS_ASSERT(reserved.newbfixed >= 0);
 77343: 
 77343:     /*
 77343:      * The newaslots/newbslots arrays hold any dynamic slots for the objects
 77343:      * if they do not have enough fixed slots to accomodate the slots in the
 77343:      * other object.
 77343:      */
 77343: 
 83233:     unsigned adynamic = dynamicSlotsCount(reserved.newafixed, b->slotSpan());
 83233:     unsigned bdynamic = dynamicSlotsCount(reserved.newbfixed, a->slotSpan());
 83231: 
 83231:     if (adynamic) {
 91146:         reserved.newaslots = (HeapSlot *) cx->malloc_(sizeof(HeapSlot) * adynamic);
 77343:         if (!reserved.newaslots)
 77343:             return false;
 91146:         Debug_SetSlotRangeToCrashOnTouch(reserved.newaslots, adynamic);
 83231:     }
 83231:     if (bdynamic) {
 91146:         reserved.newbslots = (HeapSlot *) cx->malloc_(sizeof(HeapSlot) * bdynamic);
 77343:         if (!reserved.newbslots)
 77343:             return false;
 91146:         Debug_SetSlotRangeToCrashOnTouch(reserved.newbslots, bdynamic);
 77343:     }
 77343: 
 77343:     return true;
 77343: }
 77343: 
 77343: void
 77343: JSObject::TradeGuts(JSContext *cx, JSObject *a, JSObject *b, TradeGutsReserved &reserved)
 58714: {
 58714:     JS_ASSERT(a->compartment() == b->compartment());
 58714:     JS_ASSERT(a->isFunction() == b->isFunction());
 58714: 
 77343:     /* Don't try to swap a JSFunction for a plain function JSObject. */
 88142:     JS_ASSERT_IF(a->isFunction(), a->sizeOfThis() == b->sizeOfThis());
 77343: 
 60168:     /*
 60168:      * Regexp guts are more complicated -- we would need to migrate the
 60168:      * refcounted JIT code blob for them across compartments instead of just
 60168:      * swapping guts.
 60168:      */
 60168:     JS_ASSERT(!a->isRegExp() && !b->isRegExp());
 60168: 
 77343:     /*
 77427:      * Callers should not try to swap dense arrays or ArrayBuffer objects,
 77427:      * these use a different slot representation from other objects.
 77343:      */
 77343:     JS_ASSERT(!a->isDenseArray() && !b->isDenseArray());
 77427:     JS_ASSERT(!a->isArrayBuffer() && !b->isArrayBuffer());
 58714: 
 82129: #ifdef JSGC_INCREMENTAL
 82129:     /*
 82129:      * We need a write barrier here. If |a| was marked and |b| was not, then
 82129:      * after the swap, |b|'s guts would never be marked. The write barrier
 82129:      * solves this.
 82129:      */
 82129:     JSCompartment *comp = a->compartment();
 82129:     if (comp->needsBarrier()) {
 82129:         MarkChildren(comp->barrierTracer(), a);
 82129:         MarkChildren(comp->barrierTracer(), b);
 82129:     }
 82129: #endif
 82129: 
 58714:     /* Trade the guts of the objects. */
 88142:     const size_t size = a->sizeOfThis();
 88142:     if (size == b->sizeOfThis()) {
 58714:         /*
 58714:          * If the objects are the same size, then we make no assumptions about
 58714:          * whether they have dynamically allocated slots and instead just copy
 58714:          * them over wholesale.
 58714:          */
 58714:         char tmp[tl::Max<sizeof(JSFunction), sizeof(JSObject_Slots16)>::result];
 58714:         JS_ASSERT(size <= sizeof(tmp));
 58714: 
 87623:         js_memcpy(tmp, a, size);
 87623:         js_memcpy(a, b, size);
 87623:         js_memcpy(b, tmp, size);
 89359: 
 89359: #ifdef JSGC_GENERATIONAL
 89359:         /*
 89359:          * Trigger post barriers for fixed slots. JSObject bits are barriered
 89359:          * below, in common with the other case.
 89359:          */
 91146:         JSCompartment *comp = cx->compartment;
 89359:         for (size_t i = 0; i < a->numFixedSlots(); ++i) {
 91146:             HeapSlot::writeBarrierPost(comp, a, i);
 91146:             HeapSlot::writeBarrierPost(comp, b, i);
 89359:         }
 89359: #endif
 58714:     } else {
 58714:         /*
 77343:          * If the objects are of differing sizes, use the space we reserved
 77343:          * earlier to save the slots from each object and then copy them into
 77343:          * the new layout for the other object.
 58714:          */
 77343: 
 83231:         unsigned acap = a->slotSpan();
 83231:         unsigned bcap = b->slotSpan();
 77343: 
 77343:         for (size_t i = 0; i < acap; i++)
 77343:             reserved.avals.infallibleAppend(a->getSlot(i));
 77343: 
 77343:         for (size_t i = 0; i < bcap; i++)
 77343:             reserved.bvals.infallibleAppend(b->getSlot(i));
 77343: 
 77343:         /* Done with the dynamic slots. */
 83231:         if (a->hasDynamicSlots())
 77343:             cx->free_(a->slots);
 83231:         if (b->hasDynamicSlots())
 77343:             cx->free_(b->slots);
 77343: 
 83233:         void *apriv = a->hasPrivate() ? a->getPrivate() : NULL;
 83233:         void *bpriv = b->hasPrivate() ? b->getPrivate() : NULL;
 77343: 
 82129:         char tmp[sizeof(JSObject)];
 87623:         js_memcpy(&tmp, a, sizeof tmp);
 87623:         js_memcpy(a, b, sizeof tmp);
 87623:         js_memcpy(b, &tmp, sizeof tmp);
 77343: 
 83247:         if (a->isNative())
 83247:             a->shape_->setNumFixedSlots(reserved.newafixed);
 83247:         else
 83247:             a->shape_ = reserved.newashape;
 83247: 
 77343:         a->slots = reserved.newaslots;
 86295:         a->initSlotRange(0, reserved.bvals.begin(), bcap);
 83233:         if (a->hasPrivate())
 90410:             a->initPrivate(bpriv);
 83233: 
 83247:         if (b->isNative())
 83247:             b->shape_->setNumFixedSlots(reserved.newbfixed);
 83247:         else
 83247:             b->shape_ = reserved.newbshape;
 83247: 
 77343:         b->slots = reserved.newbslots;
 86295:         b->initSlotRange(0, reserved.avals.begin(), acap);
 83233:         if (b->hasPrivate())
 90410:             b->initPrivate(apriv);
 77343: 
 77343:         /* Make sure the destructor for reserved doesn't free the slots. */
 77343:         reserved.newaslots = NULL;
 77343:         reserved.newbslots = NULL;
 58714:     }
 89359: 
 89359: #ifdef JSGC_GENERATIONAL
 89359:     Shape::writeBarrierPost(a->shape_, &a->shape_);
 89359:     Shape::writeBarrierPost(b->shape_, &b->shape_);
 89359:     types::TypeObject::writeBarrierPost(a->type_, &a->type_);
 89359:     types::TypeObject::writeBarrierPost(b->type_, &b->type_);
 89359: #endif
 90326: 
 90326:     if (a->inDictionaryMode())
 90326:         a->lastProperty()->listp = &a->shape_;
 90326:     if (b->inDictionaryMode())
 90326:         b->lastProperty()->listp = &b->shape_;
 58714: }
 58714: 
 42733: /*
 42733:  * Use this method with extreme caution. It trades the guts of two objects and updates
 42733:  * scope ownership. This operation is not thread-safe, just as fast array to slow array
 42733:  * transitions are inherently not thread-safe. Don't perform a swap operation on objects
 42733:  * shared across threads or, or bad things will happen. You have been warned.
 42733:  */
 55746: bool
 55746: JSObject::swap(JSContext *cx, JSObject *other)
 42733: {
 58714:     if (this->compartment() == other->compartment()) {
 77343:         TradeGutsReserved reserved(cx);
 77343:         if (!ReserveForTradeGuts(cx, this, other, reserved))
 77343:             return false;
 77343:         TradeGuts(cx, this, other, reserved);
 58714:         return true;
 58714:     }
 58714: 
 58714:     JSObject *thisClone;
 58714:     JSObject *otherClone;
 58714:     {
 58714:         AutoCompartment ac(cx, other);
 58714:         if (!ac.enter())
 58714:             return false;
 79734:         thisClone = JS_CloneObject(cx, this, other->getProto(), other->getParent());
 79734:         if (!thisClone || !JS_CopyPropertiesFrom(cx, thisClone, this))
 58714:             return false;
 58714:     }
 58714:     {
 58714:         AutoCompartment ac(cx, this);
 58714:         if (!ac.enter())
 58714:             return false;
 79734:         otherClone = JS_CloneObject(cx, other, other->getProto(), other->getParent());
 79734:         if (!otherClone || !JS_CopyPropertiesFrom(cx, otherClone, other))
 58714:             return false;
 58714:     }
 77343: 
 77343:     TradeGutsReserved reservedThis(cx);
 77343:     TradeGutsReserved reservedOther(cx);
 77343: 
 77343:     if (!ReserveForTradeGuts(cx, this, otherClone, reservedThis) ||
 77343:         !ReserveForTradeGuts(cx, other, thisClone, reservedOther)) {
 77343:         return false;
 77343:     }
 77343: 
 77343:     TradeGuts(cx, this, otherClone, reservedThis);
 77343:     TradeGuts(cx, other, thisClone, reservedOther);
 55746: 
 55746:     return true;
 42733: }
 42733: 
 42772: static bool
 42772: DefineStandardSlot(JSContext *cx, JSObject *obj, JSProtoKey key, JSAtom *atom,
 84755:                    const Value &v, uint32_t attrs, bool &named)
 42772: {
 99421:     RootedId id(cx, AtomToId(atom));
 42772: 
 42772:     if (key != JSProto_Null) {
 42772:         /*
 42772:          * Initializing an actual standard class on a global object. If the
 42772:          * property is not yet present, force it into a new one bound to a
 42772:          * reserved slot. Otherwise, go through the normal property path.
 42772:          */
 60566:         JS_ASSERT(obj->isGlobal());
 42772:         JS_ASSERT(obj->isNative());
 42772: 
 78194:         const Shape *shape = obj->nativeLookup(cx, id);
 52503:         if (!shape) {
 84755:             uint32_t slot = 2 * JSProto_LIMIT + key;
 90279:             obj->setReservedSlot(slot, v);
 78614:             if (!obj->addProperty(cx, id, JS_PropertyStub, JS_StrictPropertyStub, slot, attrs, 0, 0))
 42772:                 return false;
 77353:             AddTypePropertyId(cx, obj, id, v);
 42772: 
 42772:             named = true;
 42772:             return true;
 42772:         }
 42772:     }
 42772: 
 80624:     named = obj->defineGeneric(cx, id, v, JS_PropertyStub, JS_StrictPropertyStub, attrs);
 42772:     return named;
 42772: }
 42772: 
 61705: namespace js {
 61705: 
 89826: static void
 89826: SetClassObject(JSObject *obj, JSProtoKey key, JSObject *cobj, JSObject *proto)
 77343: {
 77343:     JS_ASSERT(!obj->getParent());
 77343:     if (!obj->isGlobal())
 89826:         return;
 89826: 
 90279:     obj->setReservedSlot(key, ObjectOrNullValue(cobj));
 90279:     obj->setReservedSlot(JSProto_LIMIT + key, ObjectOrNullValue(proto));
 77343: }
 77343: 
 77343: static void
 77343: ClearClassObject(JSContext *cx, JSObject *obj, JSProtoKey key)
 77343: {
 77343:     JS_ASSERT(!obj->getParent());
 77343:     if (!obj->isGlobal())
 77343:         return;
 77343: 
 77343:     obj->setSlot(key, UndefinedValue());
 77343:     obj->setSlot(JSProto_LIMIT + key, UndefinedValue());
 77343: }
 77343: 
 25897: JSObject *
 86437: DefineConstructorAndPrototype(JSContext *cx, HandleObject obj, JSProtoKey key, HandleAtom atom,
 61705:                               JSObject *protoProto, Class *clasp,
 91237:                               Native constructor, unsigned nargs,
 25897:                               JSPropertySpec *ps, JSFunctionSpec *fs,
 75413:                               JSPropertySpec *static_ps, JSFunctionSpec *static_fs,
 83262:                               JSObject **ctorp, AllocKind ctorKind)
 25897: {
 47497:     /*
 47497:      * Create a prototype object for this class.
 47497:      *
 47497:      * FIXME: lazy standard (built-in) class initialization and even older
 47497:      * eager boostrapping code rely on all of these properties:
 47497:      *
 47497:      * 1. NewObject attempting to compute a default prototype object when
 47497:      *    passed null for proto; and
 47497:      *
 47497:      * 2. NewObject tolerating no default prototype (null proto slot value)
 47497:      *    due to this js_InitClass call coming from js_InitFunctionClass on an
 47497:      *    otherwise-uninitialized global.
 47497:      *
 47497:      * 3. NewObject allocating a JSFunction-sized GC-thing when clasp is
 77817:      *    &FunctionClass, not a JSObject-sized (smaller) GC-thing.
 47497:      *
 47497:      * The JS_NewObjectForGivenProto and JS_NewObject APIs also allow clasp to
 77817:      * be &FunctionClass (we could break compatibility easily). But fixing
 47497:      * (3) is not enough without addressing the bootstrapping dependency on (1)
 47497:      * and (2).
 47497:      */
 73996: 
 73996:     /*
 73996:      * Create the prototype object.  (GlobalObject::createBlankPrototype isn't
 73996:      * used because it parents the prototype object to the global and because
 73996:      * it uses WithProto::Given.  FIXME: Undo dependencies on this parentage
 73996:      * [which already needs to happen for bug 638316], figure out nicer
 73996:      * semantics for null-protoProto, and use createBlankPrototype.)
 73996:      */
 99421:     RootedObject proto(cx);
 86437:     proto = NewObjectWithClassProto(cx, clasp, protoProto, obj);
 73904:     if (!proto)
 73904:         return NULL;
 73904: 
 77353:     if (!proto->setSingletonType(cx))
 77343:         return NULL;
 77343: 
 95355:     if (clasp == &ArrayClass && !JSObject::makeDenseArraySlow(cx, proto))
 77343:         return NULL;
 77343: 
 25897:     /* After this point, control must exit via label bad or out. */
 99421:     RootedObject ctor(cx);
 61705:     bool named = false;
 77343:     bool cached = false;
 25897:     if (!constructor) {
 25897:         /*
 25897:          * Lacking a constructor, name the prototype (e.g., Math) unless this
 25897:          * class (a) is anonymous, i.e. for internal use only; (b) the class
 25897:          * of obj (the global object) is has a reserved slot indexed by key;
 25897:          * and (c) key is not the null key.
 25897:          */
 60566:         if (!(clasp->flags & JSCLASS_IS_ANONYMOUS) || !obj->isGlobal() || key == JSProto_Null) {
 84755:             uint32_t attrs = (clasp->flags & JSCLASS_IS_ANONYMOUS)
 25897:                            ? JSPROP_READONLY | JSPROP_PERMANENT
 42772:                            : 0;
 48470:             if (!DefineStandardSlot(cx, obj, key, atom, ObjectValue(*proto), attrs, named))
 25897:                 goto bad;
 25897:         }
 25897: 
 25897:         ctor = proto;
 25897:     } else {
 73789:         /*
 73789:          * Create the constructor, not using GlobalObject::createConstructor
 73789:          * because the constructor currently must have |obj| as its parent.
 73789:          * (FIXME: remove this dependency on the exact identity of the parent,
 73789:          * perhaps as part of bug 638316.)
 73789:          */
 99421:         RootedFunction fun(cx);
 86437:         fun = js_NewFunction(cx, NULL, constructor, nargs, JSFUN_CONSTRUCTOR, obj, atom,
 83262:                              ctorKind);
 25897:         if (!fun)
 25897:             goto bad;
 25897: 
 77343:         /*
 77343:          * Set the class object early for standard class constructors. Type
 77343:          * inference may need to access these, and js_GetClassPrototype will
 77343:          * fail if it tries to do a reentrant reconstruction of the class.
 77343:          */
 82391:         if (key != JSProto_Null) {
 89826:             SetClassObject(obj, key, fun, proto);
 77343:             cached = true;
 77343:         }
 77343: 
 97353:         if (!DefineStandardSlot(cx, obj, key, atom, ObjectValue(*fun), 0, named))
 42772:             goto bad;
 42772: 
 25897:         /*
 25897:          * Optionally construct the prototype object, before the class has
 25897:          * been fully initialized.  Allow the ctor to replace proto with a
 25897:          * different object, as is done for operator new -- and as at least
 25897:          * XML support requires.
 25897:          */
 76812:         ctor = fun;
 73788:         if (!LinkConstructorAndPrototype(cx, ctor, proto))
 25897:             goto bad;
 25897: 
 25897:         /* Bootstrap Function.prototype (see also JS_InitStandardClasses). */
 77353:         if (ctor->getClass() == clasp && !ctor->splicePrototype(cx, proto))
 77353:             goto bad;
 25897:     }
 25897: 
 73790:     if (!DefinePropertiesAndBrand(cx, proto, ps, fs) ||
 73790:         (ctor != proto && !DefinePropertiesAndBrand(cx, ctor, static_ps, static_fs)))
 73790:     {
 25897:         goto bad;
 25897:     }
 25897: 
 56574:     if (clasp->flags & (JSCLASS_FREEZE_PROTO|JSCLASS_FREEZE_CTOR)) {
 56576:         JS_ASSERT_IF(ctor == proto, !(clasp->flags & JSCLASS_FREEZE_CTOR));
 56574:         if (proto && (clasp->flags & JSCLASS_FREEZE_PROTO) && !proto->freeze(cx))
 56574:             goto bad;
 56574:         if (ctor && (clasp->flags & JSCLASS_FREEZE_CTOR) && !ctor->freeze(cx))
 56574:             goto bad;
 56574:     }
 56574: 
 25897:     /* If this is a standard class, cache its prototype. */
 89826:     if (!cached && key != JSProto_Null)
 89826:         SetClassObject(obj, key, ctor, proto);
 25897: 
 75413:     if (ctorp)
 75413:         *ctorp = ctor;
 25897:     return proto;
 25897: 
 25897: bad:
 48470:     if (named) {
 48470:         Value rval;
 86790:         obj->deleteByValue(cx, StringValue(atom), &rval, false);
 48470:     }
 77343:     if (cached)
 77343:         ClearClassObject(cx, obj, key);
 48470:     return NULL;
 25897: }
 25897: 
 69232: /*
 69232:  * Lazy standard classes need a way to indicate if they have been initialized.
 69232:  * Otherwise, when we delete them, we might accidentally recreate them via a
 69232:  * lazy initialization. We use the presence of a ctor or proto in the
 69232:  * globalObject's slot to indicate that they've been constructed, but this only
 69232:  * works for classes which have a proto and ctor. Classes which don't have one
 69232:  * can call MarkStandardClassInitializedNoProto(), and we can always check
 69232:  * whether a class is initialized by calling IsStandardClassResolved().
 69232:  */
 69232: bool
 69232: IsStandardClassResolved(JSObject *obj, js::Class *clasp)
 69232: {
 69232:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
 69232: 
 69232:     /* If the constructor is undefined, then it hasn't been initialized. */
 69237:     return (obj->getReservedSlot(key) != UndefinedValue());
 69232: }
 69232: 
 69232: void
 69232: MarkStandardClassInitializedNoProto(JSObject *obj, js::Class *clasp)
 69232: {
 69232:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
 69232: 
 69232:     /*
 69232:      * We use True so that it's obvious what we're doing (instead of, say,
 69232:      * Null, which might be miscontrued as an error in setting Undefined).
 69232:      */
 69237:     if (obj->getReservedSlot(key) == UndefinedValue())
 69232:         obj->setSlot(key, BooleanValue(true));
 69232: }
 69232: 
 61705: }
 61705: 
 61705: JSObject *
 99364: js_InitClass(JSContext *cx, HandleObject obj, JSObject *protoProto_,
 91237:              Class *clasp, Native constructor, unsigned nargs,
 61705:              JSPropertySpec *ps, JSFunctionSpec *fs,
 75413:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs,
 83262:              JSObject **ctorp, AllocKind ctorKind)
 61705: {
 99421:     RootedObject protoProto(cx, protoProto_);
 99421: 
 99421:     RootedAtom atom(cx);
 86437:     atom = js_Atomize(cx, clasp->name, strlen(clasp->name));
 61705:     if (!atom)
 61705:         return NULL;
 61705: 
 61705:     /*
 61705:      * All instances of the class will inherit properties from the prototype
 61705:      * object we are about to create (in DefineConstructorAndPrototype), which
 61705:      * in turn will inherit from protoProto.
 61705:      *
 61705:      * When initializing a standard class (other than Object), if protoProto is
 61705:      * null, default to the Object prototype object. The engine's internal uses
 61705:      * of js_InitClass depend on this nicety. Note that in
 61705:      * js_InitFunctionAndObjectClasses, we specially hack the resolving table
 61705:      * and then depend on js_GetClassPrototype here leaving protoProto NULL and
 61705:      * returning true.
 61705:      */
 61705:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
 61705:     if (key != JSProto_Null &&
 61705:         !protoProto &&
 99364:         !js_GetClassPrototype(cx, obj, JSProto_Object, protoProto.address())) {
 61705:         return NULL;
 61705:     }
 61705: 
 61705:     return DefineConstructorAndPrototype(cx, obj, key, atom, protoProto, clasp, constructor, nargs,
 83262:                                          ps, fs, static_ps, static_fs, ctorp, ctorKind);
 77343: }
 77343: 
 83304: inline bool
 83304: JSObject::updateSlotsForSpan(JSContext *cx, size_t oldSpan, size_t newSpan)
 83231: {
 83231:     JS_ASSERT(oldSpan != newSpan);
 83231: 
 83304:     size_t oldCount = dynamicSlotsCount(numFixedSlots(), oldSpan);
 83304:     size_t newCount = dynamicSlotsCount(numFixedSlots(), newSpan);
 83304: 
 83304:     if (oldSpan < newSpan) {
 83304:         if (oldCount < newCount && !growSlots(cx, oldCount, newCount))
 83304:             return false;
 83304: 
 83304:         if (newSpan == oldSpan + 1)
 83301:             initSlotUnchecked(oldSpan, UndefinedValue());
 83304:         else
 83301:             initializeSlotRange(oldSpan, newSpan - oldSpan);
 83301:     } else {
 83304:         /* Trigger write barriers on the old slots before reallocating. */
 83301:         prepareSlotRangeForOverwrite(newSpan, oldSpan);
 83231:         invalidateSlotRange(newSpan, oldSpan - newSpan);
 83304: 
 83304:         if (oldCount > newCount)
 83304:             shrinkSlots(cx, oldCount, newCount);
 83304:     }
 83304: 
 83304:     return true;
 77343: }
 77343: 
 40858: bool
 83231: JSObject::setLastProperty(JSContext *cx, const js::Shape *shape)
 83231: {
 83231:     JS_ASSERT(!inDictionaryMode());
 83231:     JS_ASSERT(!shape->inDictionary());
 83231:     JS_ASSERT(shape->compartment() == compartment());
 83247:     JS_ASSERT(shape->numFixedSlots() == numFixedSlots());
 83231: 
 83231:     size_t oldSpan = lastProperty()->slotSpan();
 83231:     size_t newSpan = shape->slotSpan();
 83231: 
 83231:     if (oldSpan == newSpan) {
 83231:         shape_ = const_cast<js::Shape *>(shape);
 83231:         return true;
 83231:     }
 83231: 
 83304:     if (!updateSlotsForSpan(cx, oldSpan, newSpan))
 83231:         return false;
 83231: 
 83231:     shape_ = const_cast<js::Shape *>(shape);
 83231:     return true;
 83231: }
 83231: 
 83231: bool
 84755: JSObject::setSlotSpan(JSContext *cx, uint32_t span)
 83231: {
 83231:     JS_ASSERT(inDictionaryMode());
 83231:     js::BaseShape *base = lastProperty()->base();
 83231: 
 83231:     size_t oldSpan = base->slotSpan();
 83231: 
 83231:     if (oldSpan == span)
 83231:         return true;
 83231: 
 83304:     if (!updateSlotsForSpan(cx, oldSpan, span))
 83231:         return false;
 83231: 
 83231:     base->setSlotSpan(span);
 83231:     return true;
 83231: }
 83231: 
 83231: bool
 84755: JSObject::growSlots(JSContext *cx, uint32_t oldCount, uint32_t newCount)
 83231: {
 83231:     JS_ASSERT(newCount > oldCount);
 83231:     JS_ASSERT(newCount >= SLOT_CAPACITY_MIN);
 83275:     JS_ASSERT(!isDenseArray());
 83231: 
 80561:     /*
 83247:      * Slot capacities are determined by the span of allocated objects. Due to
 83247:      * the limited number of bits to store shape slots, object growth is
 83247:      * throttled well before the slot capacity can overflow.
 83247:      */
 83247:     JS_ASSERT(newCount < NELEMENTS_LIMIT);
 83231: 
 89497:     size_t oldSize = Probes::objectResizeActive() ? computedSizeOfThisSlotsElements() : 0;
 83231:     size_t newSize = oldSize + (newCount - oldCount) * sizeof(Value);
 55746: 
 77343:     /*
 77343:      * If we are allocating slots for an object whose type is always created
 77343:      * by calling 'new' on a particular script, bump the GC kind for that
 77343:      * type to give these objects a larger number of fixed slots when future
 77343:      * objects are constructed.
 77343:      */
 83267:     if (!hasLazyType() && !oldCount && type()->newScript) {
 77775:         gc::AllocKind kind = type()->newScript->allocKind;
 77343:         unsigned newScriptSlots = gc::GetGCKindSlots(kind);
 77775:         if (newScriptSlots == numFixedSlots() && gc::TryIncrementAllocKind(&kind)) {
102586:             Rooted<TypeObject*> typeObj(cx, type());
102586:             JSObject *obj = NewReshapedObject(cx, typeObj,
 95355:                                               getParent(), kind,
102586:                                               typeObj->newScript->shape);
 77343:             if (!obj)
 77343:                 return false;
 77343: 
102586:             typeObj->newScript->allocKind = kind;
102586:             typeObj->newScript->shape = obj->lastProperty();
102586:             typeObj->markStateChange(cx);
 77343:         }
 77343:     }
 55746: 
 83231:     if (!oldCount) {
 91146:         slots = (HeapSlot *) cx->malloc_(newCount * sizeof(HeapSlot));
 83231:         if (!slots)
 83231:             return false;
 91146:         Debug_SetSlotRangeToCrashOnTouch(slots, newCount);
 83231:         if (Probes::objectResizeActive())
 83231:             Probes::resizeObject(cx, this, oldSize, newSize);
 30454:         return true;
 30454:     }
 30454: 
 91146:     HeapSlot *newslots = (HeapSlot*) cx->realloc_(slots, oldCount * sizeof(HeapSlot),
 91146:                                                   newCount * sizeof(HeapSlot));
 83281:     if (!newslots)
 83231:         return false;  /* Leave slots at its old size. */
 83231: 
 83281:     bool changed = slots != newslots;
 83281:     slots = newslots;
 83231: 
 91146:     Debug_SetSlotRangeToCrashOnTouch(slots + oldCount, newCount - oldCount);
 83231: 
 83231:     /* Changes in the slots of global objects can trigger recompilation. */
 83231:     if (changed && isGlobal())
 83231:         types::MarkObjectStateChange(cx, this);
 83231: 
 83231:     if (Probes::objectResizeActive())
 83231:         Probes::resizeObject(cx, this, oldSize, newSize);
 80993: 
 80993:     return true;
 80993: }
 80993: 
 83231: void
 84755: JSObject::shrinkSlots(JSContext *cx, uint32_t oldCount, uint32_t newCount)
 83231: {
 83231:     JS_ASSERT(newCount < oldCount);
 83231:     JS_ASSERT(!isDenseArray());
 83231: 
 83231:     /*
 83231:      * Refuse to shrink slots for call objects. This only happens in a very
 83231:      * obscure situation (deleting names introduced by a direct 'eval') and
 83231:      * allowing the slots pointer to change may require updating pointers in
 83231:      * the function's active args/vars information.
 83231:      */
 83231:     if (isCall())
 83231:         return;
 83231: 
 89497:     size_t oldSize = Probes::objectResizeActive() ? computedSizeOfThisSlotsElements() : 0;
 83231:     size_t newSize = oldSize - (oldCount - newCount) * sizeof(Value);
 83231: 
 83231:     if (newCount == 0) {
 83231:         cx->free_(slots);
 83231:         slots = NULL;
 83231:         if (Probes::objectResizeActive())
 83231:             Probes::resizeObject(cx, this, oldSize, newSize);
 83231:         return;
 83231:     }
 83231: 
 83231:     JS_ASSERT(newCount >= SLOT_CAPACITY_MIN);
 83231: 
 91146:     HeapSlot *newslots = (HeapSlot *) cx->realloc_(slots, newCount * sizeof(HeapSlot));
 83281:     if (!newslots)
 83231:         return;  /* Leave slots at its old size. */
 83231: 
 83281:     bool changed = slots != newslots;
 83281:     slots = newslots;
 83231: 
 83231:     /* Watch for changes in global object slots, as for growSlots. */
 83231:     if (changed && isGlobal())
 83231:         types::MarkObjectStateChange(cx, this);
 83231: 
 83231:     if (Probes::objectResizeActive())
 83231:         Probes::resizeObject(cx, this, oldSize, newSize);
 83231: }
 83231: 
 30454: bool
 91237: JSObject::growElements(JSContext *cx, unsigned newcap)
 83231: {
 83231:     JS_ASSERT(isDenseArray());
 83231: 
 83231:     /*
 83231:      * When an object with CAPACITY_DOUBLING_MAX or fewer elements needs to
 55746:      * grow, double its capacity, to add N elements in amortized O(N) time.
 55746:      *
 55746:      * Above this limit, grow by 12.5% each time. Speed is still amortized
 55746:      * O(N), with a higher constant factor, and we waste less space.
     1:      */
 55746:     static const size_t CAPACITY_DOUBLING_MAX = 1024 * 1024;
 55746:     static const size_t CAPACITY_CHUNK = CAPACITY_DOUBLING_MAX / sizeof(Value);
 55746: 
 84755:     uint32_t oldcap = getDenseArrayCapacity();
 83231:     JS_ASSERT(oldcap <= newcap);
 83231: 
 89497:     size_t oldSize = Probes::objectResizeActive() ? computedSizeOfThisSlotsElements() : 0;
 77354: 
 84755:     uint32_t nextsize = (oldcap <= CAPACITY_DOUBLING_MAX)
 55746:                       ? oldcap * 2
 55746:                       : oldcap + (oldcap >> 3);
 55746: 
 84755:     uint32_t actualCapacity = JS_MAX(newcap, nextsize);
 55746:     if (actualCapacity >= CAPACITY_CHUNK)
 55746:         actualCapacity = JS_ROUNDUP(actualCapacity, CAPACITY_CHUNK);
 55746:     else if (actualCapacity < SLOT_CAPACITY_MIN)
 55746:         actualCapacity = SLOT_CAPACITY_MIN;
 52503: 
 84755:     /* Don't let nelements get close to wrapping around uint32_t. */
 83247:     if (actualCapacity >= NELEMENTS_LIMIT || actualCapacity < oldcap || actualCapacity < newcap) {
 52503:         JS_ReportOutOfMemory(cx);
 52503:         return false;
 52503:     }
 30454: 
 84755:     uint32_t initlen = getDenseArrayInitializedLength();
 84755:     uint32_t newAllocated = actualCapacity + ObjectElements::VALUES_PER_HEADER;
 83281: 
 83281:     ObjectElements *newheader;
 83231:     if (hasDynamicElements()) {
 84755:         uint32_t oldAllocated = oldcap + ObjectElements::VALUES_PER_HEADER;
 83281:         newheader = (ObjectElements *)
 83281:             cx->realloc_(getElementsHeader(), oldAllocated * sizeof(Value),
 83281:                          newAllocated * sizeof(Value));
 83281:         if (!newheader)
 83231:             return false;  /* Leave elements as its old size. */
 77343:     } else {
 83281:         newheader = (ObjectElements *) cx->malloc_(newAllocated * sizeof(Value));
 83281:         if (!newheader)
 83231:             return false;  /* Ditto. */
 87623:         js_memcpy(newheader, getElementsHeader(),
 83281:                   (ObjectElements::VALUES_PER_HEADER + initlen) * sizeof(Value));
 83281:     }
 83281: 
 83281:     newheader->capacity = actualCapacity;
 83281:     elements = newheader->elements();
 83231: 
 91146:     Debug_SetSlotRangeToCrashOnTouch(elements + initlen, actualCapacity - initlen);
 83231: 
 83231:     if (Probes::objectResizeActive())
 89497:         Probes::resizeObject(cx, this, oldSize, computedSizeOfThisSlotsElements());
 73746: 
 30454:     return true;
 30454: }
 30454: 
 30454: void
 91237: JSObject::shrinkElements(JSContext *cx, unsigned newcap)
 83231: {
 83231:     JS_ASSERT(isDenseArray());
 83231: 
 84755:     uint32_t oldcap = getDenseArrayCapacity();
 83231:     JS_ASSERT(newcap <= oldcap);
 83231: 
 89497:     size_t oldSize = Probes::objectResizeActive() ? computedSizeOfThisSlotsElements() : 0;
 83231: 
 83231:     /* Don't shrink elements below the minimum capacity. */
 83231:     if (oldcap <= SLOT_CAPACITY_MIN || !hasDynamicElements())
 77884:         return;
 77884: 
 83231:     newcap = Max(newcap, SLOT_CAPACITY_MIN);
 83231: 
 84755:     uint32_t newAllocated = newcap + ObjectElements::VALUES_PER_HEADER;
 83281: 
 83281:     ObjectElements *newheader = (ObjectElements *)
 83281:         cx->realloc_(getElementsHeader(), newAllocated * sizeof(Value));
 83281:     if (!newheader)
 83231:         return;  /* Leave elements at its old size. */
 83231: 
 83281:     newheader->capacity = newcap;
 83281:     elements = newheader->elements();
 83231: 
 83231:     if (Probes::objectResizeActive())
 89497:         Probes::resizeObject(cx, this, oldSize, computedSizeOfThisSlotsElements());
     1: }
     1: 
 18907: static JSObject *
     1: js_InitNullClass(JSContext *cx, JSObject *obj)
     1: {
     1:     JS_ASSERT(0);
     1:     return NULL;
     1: }
     1: 
     1: #define JS_PROTO(name,code,init) extern JSObject *init(JSContext *, JSObject *);
     1: #include "jsproto.tbl"
     1: #undef JS_PROTO
     1: 
 98960: static JSClassInitializerOp lazy_prototype_init[JSProto_LIMIT] = {
     1: #define JS_PROTO(name,code,init) init,
     1: #include "jsproto.tbl"
     1: #undef JS_PROTO
     1: };
     1: 
 47465: namespace js {
 47465: 
 47465: bool
 97353: SetProto(JSContext *cx, HandleObject obj, HandleObject proto, bool checkForCycles)
 47465: {
 47465:     JS_ASSERT_IF(!checkForCycles, obj != proto);
 54563:     JS_ASSERT(obj->isExtensible());
 47465: 
 98644: #if JS_HAS_XML_SUPPORT
 72561:     if (proto && proto->isXML()) {
 72561:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_XML_PROTO_FORBIDDEN);
 72561:         return false;
 72561:     }
 98644: #endif
 72561: 
 47465:     /*
 83221:      * Regenerate shapes for all of the scopes along the old prototype chain,
 84343:      * in case any entries were filled by looking up through obj. Stop when a
 83334:      * non-native object is found, prototype lookups will not be cached across
 83334:      * these.
 84343:      *
 84343:      * How this shape change is done is very delicate; the change can be made
 84343:      * either by marking the object's prototype as uncacheable (such that the
 84343:      * property cache and JIT'ed ICs cannot assume the shape determines the
 84343:      * prototype) or by just generating a new shape for the object. Choosing
 84343:      * the former is bad if the object is on the prototype chain of other
 84343:      * objects, as the uncacheable prototype can inhibit iterator caches on
 84343:      * those objects and slow down prototype accesses. Choosing the latter is
 84343:      * bad if there are many similar objects to this one which will have their
 84343:      * prototype mutated, as the generateOwnShape forces the object into
 84343:      * dictionary mode and similar property lineages will be repeatedly cloned.
 84343:      *
 84343:      * :XXX: bug 707717 make this code less brittle.
 47465:      */
 99421:     RootedObject oldproto(cx, obj);
 47465:     while (oldproto && oldproto->isNative()) {
 84343:         if (oldproto->hasSingletonType()) {
 84343:             if (!oldproto->generateOwnShape(cx))
 84343:                 return false;
 84343:         } else {
 83334:             if (!oldproto->setUncacheableProto(cx))
 83221:                 return false;
 84343:         }
 56567:         oldproto = oldproto->getProto();
 47465:     }
 47465: 
 70316:     if (checkForCycles) {
 70316:         for (JSObject *obj2 = proto; obj2; obj2 = obj2->getProto()) {
 70316:             if (obj2 == obj) {
 70316:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CYCLIC_VALUE,
 70316:                                      js_proto_str);
 70316:                 return false;
 70316:             }
 70316:         }
 70316:     }
 77343: 
 77353:     if (obj->hasSingletonType()) {
 77353:         /*
 77353:          * Just splice the prototype, but mark the properties as unknown for
 77353:          * consistent behavior.
 77353:          */
 77353:         if (!obj->splicePrototype(cx, proto))
 77353:             return false;
 77353:         MarkTypeObjectUnknownProperties(cx, obj->type());
 77353:         return true;
 77353:     }
 77353: 
 83286:     if (proto && !proto->setNewTypeUnknown(cx))
 83286:         return false;
 83286: 
 77353:     TypeObject *type = proto
 83286:         ? proto->getNewType(cx, NULL)
 83230:         : cx->compartment->getEmptyType(cx);
 77353:     if (!type)
 77353:         return false;
 77353: 
 77353:     /*
 77353:      * Setting __proto__ on an object that has escaped and may be referenced by
 77353:      * other heap objects can only be done if the properties of both objects
 77353:      * are unknown. Type sets containing this object will contain the original
 77353:      * type but not the new type of the object, so we need to go and scan the
 77353:      * entire compartment for type sets which have these objects and mark them
 77353:      * as containing generic objects.
 77353:      */
 77353:     MarkTypeObjectUnknownProperties(cx, obj->type(), true);
 77353:     MarkTypeObjectUnknownProperties(cx, type, true);
 77353: 
 77343:     obj->setType(type);
 47465:     return true;
 47465: }
 47465: 
 43258: }
 43258: 
     1: JSBool
 99364: js_GetClassObject(JSContext *cx, JSObject *obj_, JSProtoKey key,
     1:                   JSObject **objp)
     1: {
 99421:     RootedObject obj(cx, obj_);
 86437: 
 86483:     obj = &obj->global();
 60566:     if (!obj->isGlobal()) {
     1:         *objp = NULL;
 64302:         return true;
 64302:     }
 64302: 
 69237:     Value v = obj->getReservedSlot(key);
 48470:     if (v.isObject()) {
 48470:         *objp = &v.toObject();
 64302:         return true;
 64302:     }
 64302: 
 97828:     AutoResolving resolving(cx, obj, NameToId(cx->runtime->atomState.classAtoms[key]));
 64302:     if (resolving.alreadyStarted()) {
 64302:         /* Already caching id in obj -- suppress recursion. */
     1:         *objp = NULL;
 64302:         return true;
 64302:     }
 64302: 
 64302:     JSObject *cobj = NULL;
 98960:     if (JSClassInitializerOp init = lazy_prototype_init[key]) {
 64302:         if (!init(cx, obj))
 64302:             return false;
 69237:         v = obj->getReservedSlot(key);
 48470:         if (v.isObject())
 48470:             cobj = &v.toObject();
     1:     }
 64302: 
     1:     *objp = cobj;
 64302:     return true;
     1: }
     1: 
     1: JSBool
 38604: js_FindClassObject(JSContext *cx, JSObject *start, JSProtoKey protoKey,
 48470:                    Value *vp, Class *clasp)
     1: {
 86437:     JSObject *cobj, *pobj;
 99421:     RootedId id(cx);
     1:     JSProperty *prop;
 52503:     const Shape *shape;
     1: 
 99421:     RootedObject obj(cx);
 86437: 
 22652:     if (start) {
 86483:         obj = &start->global();
 98960:         obj = GetInnerObject(cx, obj);
     1:     } else {
 84293:         obj = GetGlobalForScopeChain(cx);
 84293:     }
     1:     if (!obj)
 69855:         return false;
     1: 
 38604:     if (protoKey != JSProto_Null) {
 69237:         JS_ASSERT(JSProto_Null < protoKey);
 69237:         JS_ASSERT(protoKey < JSProto_LIMIT);
 38604:         if (!js_GetClassObject(cx, obj, protoKey, &cobj))
 69855:             return false;
     1:         if (cobj) {
 48470:             vp->setObject(*cobj);
     1:             return JS_TRUE;
     1:         }
 97828:         id = NameToId(cx->runtime->atomState.classAtoms[protoKey]);
 38604:     } else {
 70270:         JSAtom *atom = js_Atomize(cx, clasp->name, strlen(clasp->name));
 38604:         if (!atom)
 38604:             return false;
 97828:         id = AtomToId(atom);
     1:     }
     1: 
 40430:     JS_ASSERT(obj->isNative());
 99447:     if (!LookupPropertyWithFlags(cx, obj, id, 0, &pobj, &prop))
 69855:         return false;
 48470:     Value v = UndefinedValue();
 43290:     if (prop && pobj->isNative()) {
 52503:         shape = (Shape *) prop;
 86009:         if (shape->hasSlot()) {
 83221:             v = pobj->nativeGetSlot(shape->slot());
 48470:             if (v.isPrimitive())
 48470:                 v.setUndefined();
  8893:         }
  8893:     }
  8893:     *vp = v;
 69855:     return true;
     1: }
     1: 
 52503: bool
 84755: JSObject::allocSlot(JSContext *cx, uint32_t *slotp)
 84755: {
 84755:     uint32_t slot = slotSpan();
 74457:     JS_ASSERT(slot >= JSSLOT_FREE(getClass()));
 53650: 
 53650:     /*
 83221:      * If this object is in dictionary mode, try to pull a free slot from the
 97571:      * shape table's slot-number freelist.
 83221:      */
 83221:     if (inDictionaryMode()) {
 97571:         ShapeTable &table = lastProperty()->table();
 84755:         uint32_t last = table.freelist;
 53546:         if (last != SHAPE_INVALID_SLOT) {
 53650: #ifdef DEBUG
 53650:             JS_ASSERT(last < slot);
 84755:             uint32_t next = getSlot(last).toPrivateUint32();
 53650:             JS_ASSERT_IF(next != SHAPE_INVALID_SLOT, next < slot);
 53650: #endif
 53650: 
 53546:             *slotp = last;
 53546: 
 74457:             const Value &vref = getSlot(last);
 83229:             table.freelist = vref.toPrivateUint32();
 74457:             setSlot(last, UndefinedValue());
 53546:             return true;
 53546:         }
 53546:     }
 53546: 
 83247:     if (slot >= SHAPE_MAXIMUM_SLOT) {
 83247:         js_ReportOutOfMemory(cx);
 83247:         return false;
 83247:     }
 83247: 
 53650:     *slotp = slot;
 83221: 
 83231:     if (inDictionaryMode() && !setSlotSpan(cx, slot + 1))
 83231:         return false;
 83221: 
 52503:     return true;
     1: }
     1: 
 83221: void
 84755: JSObject::freeSlot(JSContext *cx, uint32_t slot)
 52503: {
 83227:     JS_ASSERT(slot < slotSpan());
 79734: 
 83221:     if (inDictionaryMode()) {
 84755:         uint32_t &last = lastProperty()->table().freelist;
 53546: 
 53650:         /* Can't afford to check the whole freelist, but let's check the head. */
 83227:         JS_ASSERT_IF(last != SHAPE_INVALID_SLOT, last < slotSpan() && last != slot);
 79734: 
 79734:         /*
 83221:          * Place all freed slots other than reserved slots (bug 595230) on the
 83221:          * dictionary's free list.
 83221:          */
 83221:         if (JSSLOT_FREE(getClass()) <= slot) {
 53652:             JS_ASSERT_IF(last != SHAPE_INVALID_SLOT, last < slotSpan());
 74457:             setSlot(slot, PrivateUint32Value(last));
 53546:             last = slot;
 83221:             return;
 53546:         }
 53546:     }
 74457:     setSlot(slot, UndefinedValue());
 83221: }
 83221: 
 83221: static bool
 99364: PurgeProtoChain(JSContext *cx, JSObject *obj_, jsid id_)
     1: {
 52503:     const Shape *shape;
 11377: 
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedId id(cx, id_);
 86437: 
 11377:     while (obj) {
 40430:         if (!obj->isNative()) {
 39928:             obj = obj->getProto();
 11377:             continue;
 11377:         }
 78194:         shape = obj->nativeLookup(cx, id);
 52503:         if (shape) {
 83221:             if (!obj->shadowingShapeChange(cx, *shape))
 83221:                 return false;
 79734: 
 52503:             obj->shadowingShapeChange(cx, *shape);
 83221:             return true;
 11377:         }
 32603:         obj = obj->getProto();
 11377:     }
 83221: 
 83221:     return true;
 83221: }
 83221: 
 83221: bool
 99364: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj_, jsid id_)
 99364: {
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedId id(cx, id_);
 86437: 
 32603:     JS_ASSERT(obj->isDelegate());
 32603:     PurgeProtoChain(cx, obj->getProto(), id);
 28397: 
 28397:     /*
 28397:      * We must purge the scope chain only for Call objects as they are the only
 28397:      * kind of cacheable non-global object that can gain properties after outer
 28397:      * properties with the same names have been cached or traced. Call objects
 28397:      * may gain such properties via eval introducing new vars; see bug 490364.
 28397:      */
 52503:     if (obj->isCall()) {
 86483:         while ((obj = obj->enclosingScope()) != NULL) {
 83221:             if (!PurgeProtoChain(cx, obj, id))
 83221:                 return false;
 83221:         }
 83221:     }
 83221: 
 83221:     return true;
 81417: }
 81417: 
 83297: Shape *
 97353: js_AddNativeProperty(JSContext *cx, HandleObject obj, jsid id_,
 84755:                      PropertyOp getter, StrictPropertyOp setter, uint32_t slot,
 91237:                      unsigned attrs, unsigned flags, int shortid)
     1: {
 99421:     RootedId id(cx, id_);
 97353: 
 11377:     /*
 11377:      * Purge the property cache of now-shadowed id in obj's scope chain. Do
 11377:      * this optimistically (assuming no failure below) before locking obj, so
 11377:      * we can lock the shadowed scope.
 11377:      */
 83221:     if (!js_PurgeScopeChain(cx, obj, id))
 56567:         return NULL;
 56567: 
 56567:     return obj->putProperty(cx, id, getter, setter, slot, attrs, flags, shortid);
 52503: }
 52503: 
     1: JSBool
102586: baseops::DefineGeneric(JSContext *cx, HandleObject obj, HandleId id, const Value *value,
 91237:                         PropertyOp getter, StrictPropertyOp setter, unsigned attrs)
 48470: {
 69855:     return !!DefineNativeProperty(cx, obj, id, *value, getter, setter, attrs, 0, 0);
     1: }
     1: 
 78345: JSBool
 98960: baseops::DefineElement(JSContext *cx, HandleObject obj, uint32_t index, const Value *value,
 91237:                        PropertyOp getter, StrictPropertyOp setter, unsigned attrs)
 78345: {
102586:     Rooted<jsid> id(cx);
 97353:     if (index <= JSID_INT_MAX) {
102586:         id = INT_TO_JSID(index);
102586:         return !!DefineNativeProperty(cx, obj, id, *value, getter, setter, attrs, 0, 0);
 97353:     }
 97353: 
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
 98960: 
 98960:     if (!IndexToId(cx, index, id.address()))
 98960:         return false;
 98960: 
 98960:     return !!DefineNativeProperty(cx, obj, id, *value, getter, setter, attrs, 0, 0);
 78345: }
 78345: 
     1: /*
     1:  * Backward compatibility requires allowing addProperty hooks to mutate the
 53650:  * nominal initial value of a slotful property, while GC safety wants that
     1:  * value to be stored before the call-out through the hook.  Optimize to do
     1:  * both while saving cycles for classes that stub their addProperty hook.
     1:  */
 32658: static inline bool
 98960: CallAddPropertyHook(JSContext *cx, Class *clasp, HandleObject obj, HandleShape shape, Value *vp)
 48470: {
 78614:     if (clasp->addProperty != JS_PropertyStub) {
 48470:         Value nominal = *vp;
 32658: 
102586:         Rooted<jsid> id(cx, shape->propid());
102586:         if (!CallJSPropertyOp(cx, clasp->addProperty, obj, id, vp))
 32658:             return false;
 32658:         if (*vp != nominal) {
 86009:             if (shape->hasSlot())
 77343:                 obj->nativeSetSlotWithType(cx, shape, *vp);
 32658:         }
 32658:     }
 32658:     return true;
 32658: }
     1: 
 69855: namespace js {
 69855: 
 69855: const Shape *
 98960: DefineNativeProperty(JSContext *cx, HandleObject obj, HandleId id, const Value &value_,
 91237:                      PropertyOp getter, StrictPropertyOp setter, unsigned attrs,
 91237:                      unsigned flags, int shortid, unsigned defineHow /* = 0 */)
 69855: {
 77343:     JS_ASSERT((defineHow & ~(DNP_CACHE_RESULT | DNP_DONT_PURGE |
 94227:                              DNP_SKIP_TYPE)) == 0);
 94398:     JS_ASSERT(!(attrs & JSPROP_NATIVE_ACCESSORS));
 27492: 
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
 86437: 
 94227:     /* Make a local copy of value so addProperty can mutate its inout parameter. */
 99421:     RootedValue value(cx);
 86437:     value = value_;
 86437: 
     1:     /*
     1:      * If defining a getter or setter, we must check for its counterpart and
     1:      * update the attributes and property ops.  A getter or setter is really
     1:      * only half of a property.
     1:      */
 99421:     RootedShape shape(cx);
     1:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
     1:         JSObject *pobj;
     1:         JSProperty *prop;
     1: 
 77343:         /* Type information for getter/setter properties is unknown. */
 77353:         AddTypePropertyId(cx, obj, id, types::Type::UnknownType());
 77353:         MarkTypePropertyConfigured(cx, obj, id);
 77343: 
     1:         /*
 69855:          * If we are defining a getter whose setter was already defined, or
 69855:          * vice versa, finish the job via obj->changeProperty, and refresh the
 69855:          * property cache line for (obj, id) to map shape.
     1:          */
 98960:         if (!baseops::LookupProperty(cx, obj, id, &pobj, &prop))
 69855:             return NULL;
 69855:         if (prop && pobj == obj) {
 83297:             shape = (Shape *) prop;
 69855:             if (shape->isAccessorDescriptor()) {
 52503:                 shape = obj->changeProperty(cx, shape, attrs,
 33152:                                             JSPROP_GETTER | JSPROP_SETTER,
     1:                                             (attrs & JSPROP_GETTER)
     1:                                             ? getter
 52503:                                             : shape->getter(),
     1:                                             (attrs & JSPROP_SETTER)
     1:                                             ? setter
 52503:                                             : shape->setter());
 52503:                 if (!shape)
 69855:                     return NULL;
 69855:             } else {
 52503:                 shape = NULL;
     1:             }
     1:         }
 69855:     }
     1: 
 11377:     /*
 28397:      * Purge the property cache of any properties named by id that are about
 28397:      * to be shadowed in obj's scope chain unless it is known a priori that it
 28397:      * is not possible. We do this before locking obj to avoid nesting locks.
 28312:      */
 83221:     if (!(defineHow & DNP_DONT_PURGE)) {
 83221:         if (!js_PurgeScopeChain(cx, obj, id))
 83221:             return NULL;
 83221:     }
 11377: 
     1:     /* Use the object's class getter and setter by default. */
 62034:     Class *clasp = obj->getClass();
 41860:     if (!getter && !(attrs & JSPROP_GETTER))
     1:         getter = clasp->getProperty;
 41860:     if (!setter && !(attrs & JSPROP_SETTER))
     1:         setter = clasp->setProperty;
 94227: 
 94227:     if ((getter == JS_PropertyStub) && !(defineHow & DNP_SKIP_TYPE)) {
 77343:         /*
 77343:          * Type information for normal native properties should reflect the
 77343:          * initial value of the property.
 77343:          */
 77353:         AddTypePropertyId(cx, obj, id, value);
 77343:         if (attrs & JSPROP_READONLY)
 77353:             MarkTypePropertyConfigured(cx, obj, id);
 77343:     }
 77343: 
 52503:     if (!shape) {
 52503:         shape = obj->putProperty(cx, id, getter, setter, SHAPE_INVALID_SLOT,
 35334:                                  attrs, flags, shortid);
 52503:         if (!shape)
 69855:             return NULL;
 14646:     }
     1: 
 62790:     /* Store valueCopy before calling addProperty, in case the latter GC's. */
 86009:     if (shape->hasSlot())
 86437:         obj->nativeSetSlot(shape->slot(), value);
     1: 
 86437:     if (!CallAddPropertyHook(cx, clasp, obj, shape, value.address())) {
 52503:         obj->removeProperty(cx, id);
 69855:         return NULL;
 69855:     }
 69855: 
 69855:     return shape;
 69855: }
 69855: 
 69855: } /* namespace js */
 10217: 
     1: /*
 64217:  * Call obj's resolve hook.
 43260:  *
102659:  * cx, id, and flags are the parameters initially passed to the ongoing lookup;
102659:  * objp and propp are its out parameters. obj is an object along the prototype
102659:  * chain from where the lookup started.
 43260:  *
 43260:  * There are four possible outcomes:
 43260:  *
 64217:  *   - On failure, report an error or exception and return false.
 43260:  *
 64217:  *   - If we are already resolving a property of *curobjp, set *recursedp = true,
 64217:  *     and return true.
 43260:  *
 43260:  *   - If the resolve hook finds or defines the sought property, set *objp and
 64217:  *     *propp appropriately, set *recursedp = false, and return true.
 43260:  *
 43260:  *   - Otherwise no property was resolved. Set *propp = NULL and *recursedp = false
 43260:  *     and return true.
 43260:  */
 43260: static JSBool
102659: CallResolveOp(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
 43260:               JSObject **objp, JSProperty **propp, bool *recursedp)
 43260: {
 48470:     Class *clasp = obj->getClass();
 43260:     JSResolveOp resolve = clasp->resolve;
 43260: 
 43260:     /*
 43260:      * Avoid recursion on (obj, id) already being resolved on cx.
 43260:      *
     1:      * Once we have successfully added an entry for (obj, key) to
     1:      * cx->resolvingTable, control must go through cleanup: before
     1:      * returning.  But note that JS_DHASH_ADD may find an existing
     1:      * entry, in which case we bail to suppress runaway recursion.
     1:      */
 64302:     AutoResolving resolving(cx, obj, id);
 64302:     if (resolving.alreadyStarted()) {
     1:         /* Already resolving id in obj -- suppress recursion. */
 43260:         *recursedp = true;
 43260:         return true;
 43260:     }
 43260:     *recursedp = false;
 43260: 
     1:     *propp = NULL;
     1: 
     1:     if (clasp->flags & JSCLASS_NEW_RESOLVE) {
 64217:         JSNewResolveOp newresolve = reinterpret_cast<JSNewResolveOp>(resolve);
 69855:         if (flags == RESOLVE_INFER)
 52503:             flags = js_InferFlags(cx, 0);
 86437: 
102659:         RootedObject obj2(cx, NULL);
 86437:         if (!newresolve(cx, obj, id, flags, obj2.address()))
 64302:             return false;
     1: 
 64217:         /*
 64217:          * We trust the new style resolve hook to set obj2 to NULL when
 64217:          * the id cannot be resolved. But, when obj2 is not null, we do
 64217:          * not assume that id must exist and do full nativeLookup for
 64217:          * compatibility.
 64217:          */
 64217:         if (!obj2)
 64302:             return true;
 64217: 
 40430:         if (!obj2->isNative()) {
     1:             /* Whoops, newresolve handed back a foreign obj2. */
     1:             JS_ASSERT(obj2 != obj);
 80442:             return obj2->lookupGeneric(cx, id, objp, propp);
 64217:         }
 64217:         obj = obj2;
     1:     } else {
 64302:         if (!resolve(cx, obj, id))
 64302:             return false;
 64217:     }
 64217: 
 64217:     if (!obj->nativeEmpty()) {
 78194:         if (const Shape *shape = obj->nativeLookup(cx, id)) {
 43260:             *objp = obj;
 52503:             *propp = (JSProperty *) shape;
 43260:         }
 64217:     }
 64217: 
 64302:     return true;
 43260: }
 43260: 
 69855: static JS_ALWAYS_INLINE bool
 98960: LookupPropertyWithFlagsInline(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
 43260:                               JSObject **objp, JSProperty **propp)
 43260: {
 43260:     /* Search scopes starting with obj and following the prototype link. */
 99421:     RootedObject current(cx, obj);
 72559:     while (true) {
 98960:         const Shape *shape = current->nativeLookup(cx, id);
 52503:         if (shape) {
 98960:             *objp = current;
 52503:             *propp = (JSProperty *) shape;
 69855:             return true;
     1:         }
     1: 
 43260:         /* Try obj's class resolve hook if id was not found in obj's scope. */
 98960:         if (current->getClass()->resolve != JS_ResolveStub) {
 43260:             bool recursed;
102659:             if (!CallResolveOp(cx, current, id, flags, objp, propp, &recursed))
 69855:                 return false;
 43260:             if (recursed)
 43260:                 break;
 43260:             if (*propp) {
 69855:                 /*
 69855:                  * For stats we do not recalculate protoIndex even if it was
 69855:                  * resolved on some other object.
 69855:                  */
 69855:                 return true;
 43260:             }
 43260:         }
 43260: 
 98960:         JSObject *proto = current->getProto();
     1:         if (!proto)
     1:             break;
 40430:         if (!proto->isNative()) {
 80442:             if (!proto->lookupGeneric(cx, id, objp, propp))
 69855:                 return false;
 60172: #ifdef DEBUG
 60172:             /*
 60172:              * Non-native objects must have either non-native lookup results,
 60172:              * or else native results from the non-native's prototype chain.
 60172:              *
 69223:              * See StackFrame::getValidCalleeObject, where we depend on this
 60172:              * fact to force a prototype-delegated joined method accessed via
 60172:              * arguments.callee through the delegating |this| object's method
 60172:              * read barrier.
 60172:              */
 60172:             if (*propp && (*objp)->isNative()) {
 60172:                 while ((proto = proto->getProto()) != *objp)
 60172:                     JS_ASSERT(proto);
 60172:             }
 60172: #endif
 69855:             return true;
 10217:         }
 30645: 
 98960:         current = proto;
     1:     }
     1: 
     1:     *objp = NULL;
     1:     *propp = NULL;
 69855:     return true;
 10217: }
 10217: 
 56740: JS_FRIEND_API(JSBool)
 98960: baseops::LookupProperty(JSContext *cx, HandleObject obj, HandleId id, JSObject **objp,
 56740:                         JSProperty **propp)
 56740: {
 69855:     return LookupPropertyWithFlagsInline(cx, obj, id, cx->resolveFlags, objp, propp);
 69855: }
 69855: 
 78330: JS_FRIEND_API(JSBool)
 98960: baseops::LookupElement(JSContext *cx, HandleObject obj, uint32_t index, JSObject **objp, JSProperty **propp)
 98960: {
 99421:     RootedId id(cx);
 98960:     if (!IndexToId(cx, index, id.address()))
 78330:         return false;
 78330: 
 78330:     return LookupPropertyWithFlagsInline(cx, obj, id, cx->resolveFlags, objp, propp);
 78330: }
 78330: 
 69855: bool
 98960: js::LookupPropertyWithFlags(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
 55535:                             JSObject **objp, JSProperty **propp)
 55535: {
 69855:     return LookupPropertyWithFlagsInline(cx, obj, id, flags, objp, propp);
 69855: }
 69855: 
 86855: bool
 95355: js::FindPropertyHelper(JSContext *cx,
 95355:                        HandlePropertyName name, bool cacheResult, HandleObject scopeChain,
 27575:                        JSObject **objp, JSObject **pobjp, JSProperty **propp)
     1: {
 99421:     RootedId id(cx, NameToId(name));
 95355: 
 95355:     JSObject *pobj;
 69855:     int scopeIndex;
     1:     JSProperty *prop;
 27575: 
 27539:     /* Scan entries on the scope chain that we can cache across. */
 99421:     RootedObject obj(cx, scopeChain);
 99421:     RootedObject parent(cx, obj->enclosingScope());
 27539:     for (scopeIndex = 0;
 27539:          parent
 63085:          ? IsCacheableNonGlobalScope(obj)
 48622:          : !obj->getOps()->lookupProperty;
 27539:          ++scopeIndex) {
 69855:         if (!LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags, &pobj, &prop))
 86855:             return false;
 27539: 
 27539:         if (prop) {
 27539: #ifdef DEBUG
 27539:             if (parent) {
 40430:                 JS_ASSERT(pobj->isNative());
 77817:                 JS_ASSERT(pobj->getClass() == obj->getClass());
 77817:                 if (obj->isBlock()) {
 27539:                     /*
 69855:                      * A block instance on the scope chain is immutable and
 69855:                      * shares its shape with the compile-time prototype. Thus
 69855:                      * we cannot find any property on the prototype.
 27539:                      */
 53650:                     JS_ASSERT(pobj->isClonedBlock());
 11377:                 } else {
 27539:                     /* Call and DeclEnvClass objects have no prototypes. */
 39928:                     JS_ASSERT(!obj->getProto());
 69855:                 }
 69855:                 JS_ASSERT(pobj == obj);
 42726:             } else {
 42726:                 JS_ASSERT(obj->isNative());
 27539:             }
 27539: #endif
 86855: 
 42726:             /*
 42726:              * We must check if pobj is native as a global object can have
 42726:              * non-native prototype.
 42726:              */
 42726:             if (cacheResult && pobj->isNative()) {
 86855:                 JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex, pobj,
 52503:                                            (Shape *) prop);
 27539:             }
 86855: 
 27539:             goto out;
 27539:         }
 27539: 
 27539:         if (!parent) {
 27539:             pobj = NULL;
 27539:             goto out;
 27539:         }
 27539:         obj = parent;
 86483:         parent = obj->enclosingScope();
 27539:     }
 27539: 
 27539:     for (;;) {
 80442:         if (!obj->lookupGeneric(cx, id, &pobj, &prop))
 86855:             return false;
 86855:         if (prop)
 27539:             goto out;
 27539: 
 27539:         /*
 27539:          * We conservatively assume that a resolve hook could mutate the scope
 80442:          * chain during JSObject::lookupGeneric. So we read parent here again.
 27539:          */
 86483:         parent = obj->enclosingScope();
 27539:         if (!parent) {
 27539:             pobj = NULL;
 27539:             break;
 27539:         }
 27539:         obj = parent;
 27539:     }
 27539: 
 27539:   out:
 27539:     JS_ASSERT(!!pobj == !!prop);
     1:     *objp = obj;
     1:     *pobjp = pobj;
     1:     *propp = prop;
 86855:     return true;
     1: }
     1: 
 57125: /*
 57125:  * On return, if |*pobjp| is a native object, then |*propp| is a |Shape *|.
 57125:  * Otherwise, its type and meaning depends on the host object's implementation.
 57125:  */
 86542: bool
 95355: js::FindProperty(JSContext *cx, HandlePropertyName name, HandleObject scopeChain,
 77343:                  JSObject **objp, JSObject **pobjp, JSProperty **propp)
 77343: {
 87657:     return !!FindPropertyHelper(cx, name, false, scopeChain, objp, pobjp, propp);
     1: }
     1: 
 27319: JSObject *
 97353: js::FindIdentifierBase(JSContext *cx, HandleObject scopeChain, HandlePropertyName name)
     1: {
 27237:     /*
 27237:      * This function should not be called for a global object or from the
 27237:      * trace and should have a valid cache entry for native scopeChain.
 27237:      */
 86483:     JS_ASSERT(scopeChain->enclosingScope() != NULL);
 27237: 
 99421:     RootedObject obj(cx, scopeChain);
 27319: 
 27237:     /*
 27319:      * Loop over cacheable objects on the scope chain until we find a
 27319:      * property. We also stop when we reach the global object skipping any
 27319:      * farther checks or lookups. For details see the JSOP_BINDNAME case of
 27319:      * js_Interpret.
 41775:      *
 63085:      * The test order here matters because IsCacheableNonGlobalScope
 41775:      * must not be passed a global object (i.e. one with null parent).
 27237:      */
 41775:     for (int scopeIndex = 0;
 83239:          obj->isGlobal() || IsCacheableNonGlobalScope(obj);
 41775:          scopeIndex++) {
 27237:         JSObject *pobj;
 27236:         JSProperty *prop;
 98960:         if (!LookupPropertyWithFlags(cx, obj, name.value(), cx->resolveFlags, &pobj, &prop))
 27237:             return NULL;
 27237:         if (prop) {
 42726:             if (!pobj->isNative()) {
 83239:                 JS_ASSERT(obj->isGlobal());
 42726:                 return obj;
 42726:             }
 86483:             JS_ASSERT_IF(obj->isScope(), pobj->getClass() == obj->getClass());
 69855:             JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex, pobj, (Shape *) prop);
 27237:             return obj;
 27237:         }
 27237: 
 86483:         JSObject *parent = obj->enclosingScope();
 41775:         if (!parent)
 27237:             return obj;
 41775:         obj = parent;
 27237:     }
 27319: 
 27319:     /* Loop until we find a property or reach the global object. */
 27237:     do {
 27237:         JSObject *pobj;
 27237:         JSProperty *prop;
 86542:         if (!obj->lookupProperty(cx, name, &pobj, &prop))
     1:             return NULL;
 56567:         if (prop)
 27237:             break;
 27319: 
 27319:         /*
 27319:          * We conservatively assume that a resolve hook could mutate the scope
 80442:          * chain during JSObject::lookupGeneric. So we must check if parent is
 31501:          * not null here even if it wasn't before the lookup.
 27319:          */
 86483:         JSObject *parent = obj->enclosingScope();
 27319:         if (!parent)
 27319:             break;
 27237:         obj = parent;
 83257:     } while (!obj->isGlobal());
     1:     return obj;
     1: }
     1: 
 55535: static JS_ALWAYS_INLINE JSBool
102586: js_NativeGetInline(JSContext *cx, Handle<JSObject*> receiver, JSObject *obj, JSObject *pobj,
 91237:                    const Shape *shape, unsigned getHow, Value *vp)
     1: {
 40430:     JS_ASSERT(pobj->isNative());
 52503: 
 83221:     if (shape->hasSlot()) {
 83221:         *vp = pobj->nativeGetSlot(shape->slot());
 55746:         JS_ASSERT(!vp->isMagic());
 94227:         JS_ASSERT_IF(!pobj->hasSingletonType() && shape->hasDefaultGetter(),
 83221:                      js::types::TypeHasProperty(cx, pobj->type(), shape->propid(), *vp));
 55746:     } else {
 48470:         vp->setUndefined();
 55746:     }
 52503:     if (shape->hasDefaultGetter())
 32658:         return true;
 32658: 
 78454:     jsbytecode *pc;
 78454:     JSScript *script = cx->stack.currentScript(&pc);
 82642:     if (script && script->hasAnalysis()) {
 78454:         analyze::Bytecode *code = script->analysis()->maybeCode(pc);
 78454:         if (code)
 78454:             code->accessGetter = true;
 78454:     }
 78454: 
 99421:     Rooted<const Shape*> shapeRoot(cx, shape);
 99421:     RootedObject pobjRoot(cx, pobj);
 99421: 
102586:     if (!shape->get(cx, receiver, obj, pobj, vp))
 32658:         return false;
 52503: 
 83221:     /* Update slotful shapes according to the value produced by the getter. */
 99364:     if (shapeRoot->hasSlot() && pobjRoot->nativeContains(cx, *shapeRoot))
 99364:         pobjRoot->nativeSetSlot(shapeRoot->slot(), *vp);
 32658: 
 32658:     return true;
     1: }
     1: 
     1: JSBool
102586: js_NativeGet(JSContext *cx, Handle<JSObject*> obj, Handle<JSObject*> pobj, const Shape *shape,
102586:              unsigned getHow, Value *vp)
102586: {
102586:     return js_NativeGetInline(cx, obj, obj, pobj, shape, getHow, vp);
102586: }
102586: 
102586: JSBool
102586: js_NativeSet(JSContext *cx, Handle<JSObject*> obj, const Shape *shape, bool added, bool strict,
102532:              Value *vp)
102531: {
 83221:     AddTypePropertyId(cx, obj, shape->propid(), *vp);
 27490: 
 40430:     JS_ASSERT(obj->isNative());
 52503: 
 83221:     if (shape->hasSlot()) {
 84755:         uint32_t slot = shape->slot();
 27490: 
 83221:         /* If shape has a stub setter, just store *vp. */
 52503:         if (shape->hasDefaultSetter()) {
 56567:             obj->nativeSetSlot(slot, *vp);
 32658:             return true;
 32658:         }
 27490:     } else {
     1:         /*
     1:          * Allow API consumers to create shared properties with stub setters.
 36491:          * Such properties effectively function as data descriptors which are
 36491:          * not writable, so attempting to set such a property should do nothing
 36491:          * or throw if we're in strict mode.
     1:          */
 52503:         if (!shape->hasGetterValue() && shape->hasDefaultSetter())
 36491:             return js_ReportGetterOnlyAssignment(cx);
     1:     }
 27490: 
 99421:     Rooted<const Shape *> shapeRoot(cx, shape);
 95355: 
 84755:     int32_t sample = cx->runtime->propertyRemovals;
102586:     if (!shapeRoot->set(cx, obj, strict, vp))
 32658:         return false;
 60552: 
 83221:     /*
 83221:      * Update any slot for the shape with the value produced by the setter,
 83221:      * unless the setter deleted the shape.
 83221:      */
 99364:     if (shapeRoot->hasSlot() &&
     1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
 99364:          obj->nativeContains(cx, *shapeRoot))) {
 99364:         obj->setSlot(shapeRoot->slot(), *vp);
 32658:     }
 32658: 
 32658:     return true;
     1: }
     1: 
 74260: static JS_ALWAYS_INLINE JSBool
 95355: js_GetPropertyHelperInline(JSContext *cx, HandleObject obj, HandleObject receiver, jsid id_,
 84755:                            uint32_t getHow, Value *vp)
     1: {
     1:     JSProperty *prop;
 95355: 
 99421:     RootedId id(cx, id_);
     1: 
 69855:     /* This call site is hot -- use the always-inlined variant of LookupPropertyWithFlags(). */
 99421:     RootedObject obj2(cx);
 95355:     if (!LookupPropertyWithFlagsInline(cx, obj, id, cx->resolveFlags, obj2.address(), &prop))
 69855:         return false;
 54172: 
     1:     if (!prop) {
 48470:         vp->setUndefined();
 48470: 
 52503:         if (!CallJSPropertyOp(cx, obj->getClass()->getProperty, obj, id, vp))
     1:             return JS_FALSE;
     1: 
 77343:         /* Record non-undefined values produced by the class getter hook. */
 77343:         if (!vp->isUndefined())
 77353:             AddTypePropertyId(cx, obj, id, *vp);
 77343: 
     1:         /*
     1:          * Give a strict warning if foo.bar is evaluated by a script for an
     1:          * object foo with no property named 'bar'.
     1:          */
 24598:         jsbytecode *pc;
 48470:         if (vp->isUndefined() && ((pc = js_GetCurrentBytecodePC(cx)) != NULL)) {
 84346:             JSOp op = (JSOp) *pc;
 84346: 
     1:             if (op == JSOP_GETXPROP) {
 84346:                 /* Undefined property during a name lookup, report an error. */
 84346:                 JSAutoByteString printable;
 84346:                 if (js_ValueToPrintable(cx, IdToValue(id), &printable))
 84346:                     js_ReportIsNotDefined(cx, printable.ptr());
 84346:                 return false;
 84346:             }
 84346: 
 61450:             if (!cx->hasStrictOption() ||
 77343:                 cx->stack.currentScript()->warnedAboutUndefinedProp ||
 82642:                 (op != JSOP_GETPROP && op != JSOP_GETELEM)) {
     1:                 return JS_TRUE;
     1:             }
     1: 
     1:             /*
     1:              * XXX do not warn about missing __iterator__ as the function
     1:              * may be called from JS_GetMethodById. See bug 355145.
     1:              */
 48470:             if (JSID_IS_ATOM(id, cx->runtime->atomState.iteratorAtom))
     1:                 return JS_TRUE;
     1: 
 25213:             /* Do not warn about tests like (obj[prop] == undefined). */
 69855:             if (cx->resolveFlags == RESOLVE_INFER) {
     1:                 pc += js_CodeSpec[op].length;
     1:                 if (Detecting(cx, pc))
     1:                     return JS_TRUE;
 25213:             } else if (cx->resolveFlags & JSRESOLVE_DETECTING) {
 25213:                 return JS_TRUE;
 25213:             }
     1: 
 91237:             unsigned flags = JSREPORT_WARNING | JSREPORT_STRICT;
 77343:             cx->stack.currentScript()->warnedAboutUndefinedProp = true;
     1: 
     1:             /* Ok, bad undefined property reference: whine about it. */
     1:             if (!js_ReportValueErrorFlags(cx, flags, JSMSG_UNDEFINED_PROP,
 48470:                                           JSDVG_IGNORE_STACK, IdToValue(id),
 84346:                                           NULL, NULL, NULL))
 84346:             {
 84346:                 return false;
     1:             }
     1:         }
     1:         return JS_TRUE;
     1:     }
     1: 
 56817:     if (!obj2->isNative()) {
 56817:         return obj2->isProxy()
 79386:                ? Proxy::get(cx, obj2, receiver, id, vp)
 78675:                : obj2->getGeneric(cx, id, vp);
 56817:     }
     1: 
 95355:     Shape *shape = (Shape *) prop;
 27490: 
 82645:     if (getHow & JSGET_CACHE_RESULT)
 95355:         JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, obj2, shape);
 52503: 
 55535:     /* This call site is hot -- use the always-inlined variant of js_NativeGet(). */
 57739:     if (!js_NativeGetInline(cx, receiver, obj, obj2, shape, getHow, vp))
 27932:         return JS_FALSE;
 27932: 
 27490:     return JS_TRUE;
     1: }
     1: 
 86542: bool
 95355: js::GetPropertyHelper(JSContext *cx, HandleObject obj, jsid id, uint32_t getHow, Value *vp)
 86542: {
 86542:     return !!js_GetPropertyHelperInline(cx, obj, obj, id, getHow, vp);
 56757: }
 56757: 
 56757: JSBool
 98960: baseops::GetProperty(JSContext *cx, HandleObject obj, HandleObject receiver, HandleId id, Value *vp)
     1: {
 55535:     /* This call site is hot -- use the always-inlined variant of js_GetPropertyHelper(). */
 94227:     return js_GetPropertyHelperInline(cx, obj, receiver, id, 0, vp);
 11377: }
 11377: 
 11377: JSBool
 98960: baseops::GetElement(JSContext *cx, HandleObject obj, HandleObject receiver, uint32_t index, Value *vp)
 78341: {
 78341:     jsid id;
 78341:     if (!IndexToId(cx, index, &id))
 78341:         return false;
 78341: 
 78341:     /* This call site is hot -- use the always-inlined variant of js_GetPropertyHelper(). */
 94227:     return js_GetPropertyHelperInline(cx, obj, receiver, id, 0, vp);
 78341: }
 78341: 
 78341: JSBool
 98960: baseops::GetPropertyDefault(JSContext *cx, HandleObject obj, HandleId id, const Value &def, Value *vp)
 56211: {
 56211:     JSProperty *prop;
 99421:     RootedObject obj2(cx);
 95355:     if (!LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_QUALIFIED, obj2.address(), &prop))
 56211:         return false;
 56211: 
 56211:     if (!prop) {
 56211:         *vp = def;
 56211:         return true;
 56211:     }
 56211: 
 98960:     return baseops::GetProperty(cx, obj2, id, vp);
 56211: }
 56211: 
 56211: JSBool
 98960: js::GetMethod(JSContext *cx, HandleObject obj, HandleId id, unsigned getHow, Value *vp)
 26187: {
 29913:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 29913: 
 78675:     GenericIdOp op = obj->getOps()->getGeneric;
 48622:     if (!op) {
 48622: #if JS_HAS_XML_SUPPORT
 48622:         JS_ASSERT(!obj->isXML());
 48622: #endif
 86542:         return GetPropertyHelper(cx, obj, id, getHow, vp);
 32658:     }
 26187: #if JS_HAS_XML_SUPPORT
 42693:     if (obj->isXML())
 26187:         return js_GetXMLMethod(cx, obj, id, vp);
 26187: #endif
 56817:     return op(cx, obj, obj, id, vp);
 26187: }
 26187: 
 35308: JS_FRIEND_API(bool)
 79734: js::CheckUndeclaredVarAssignment(JSContext *cx, JSString *propname)
 27372: {
 77398:     StackFrame *const fp = js_GetTopStackFrame(cx, FRAME_EXPAND_ALL);
 35308:     if (!fp)
 35308:         return true;
 35308: 
 35308:     /* If neither cx nor the code is strict, then no check is needed. */
 53840:     if (!(fp->isScriptFrame() && fp->script()->strictModeCode) &&
 61450:         !cx->hasStrictOption()) {
 35308:         return true;
 35308:     }
 35308: 
 57812:     JSAutoByteString bytes(cx, propname);
 57812:     return !!bytes &&
 35308:            JS_ReportErrorFlagsAndNumber(cx,
 35308:                                         (JSREPORT_WARNING | JSREPORT_STRICT
 35308:                                          | JSREPORT_STRICT_MODE_ERROR),
 27372:                                         js_GetErrorMessage, NULL,
 57812:                                         JSMSG_UNDECLARED_VAR, bytes.ptr());
 27372: }
 27372: 
101861: bool
101861: JSObject::reportReadOnly(JSContext *cx, jsid id, unsigned report)
 54587: {
 54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_READ_ONLY,
 48470:                                     JSDVG_IGNORE_STACK, IdToValue(id), NULL,
 40832:                                     NULL, NULL);
 40832: }
 40832: 
 54587: bool
 91237: JSObject::reportNotConfigurable(JSContext *cx, jsid id, unsigned report)
 54587: {
 54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_CANT_DELETE,
 54169:                                     JSDVG_IGNORE_STACK, IdToValue(id), NULL,
 54169:                                     NULL, NULL);
 54169: }
 54169: 
 54587: bool
 91237: JSObject::reportNotExtensible(JSContext *cx, unsigned report)
 54587: {
 54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_OBJECT_NOT_EXTENSIBLE,
 54587:                                     JSDVG_IGNORE_STACK, ObjectValue(*this),
 54587:                                     NULL, NULL, NULL);
 40832: }
 40832: 
 67921: bool
 98960: JSObject::callMethod(JSContext *cx, HandleId id, unsigned argc, Value *argv, Value *vp)
 67921: {
 67921:     Value fval;
102586:     Rooted<JSObject*> obj(cx, this);
102586:     return GetMethod(cx, obj, id, 0, &fval) &&
102586:            Invoke(cx, ObjectValue(*obj), fval, argc, argv, vp);
 67921: }
 67921: 
 27932: JSBool
 98960: baseops::SetPropertyHelper(JSContext *cx, HandleObject obj, HandleId id, unsigned defineHow,
 54169:                            Value *vp, JSBool strict)
 11377: {
     1:     JSObject *pobj;
     1:     JSProperty *prop;
 91237:     unsigned attrs, flags;
 91237:     int shortid;
 48470:     Class *clasp;
 62395:     PropertyOp getter;
 62395:     StrictPropertyOp setter;
 27930:     bool added;
     1: 
 94227:     JS_ASSERT((defineHow & ~(DNP_CACHE_RESULT | DNP_UNQUALIFIED)) == 0);
 28398: 
 74472:     if (JS_UNLIKELY(obj->watched())) {
 74472:         /* Fire watchpoints, if any. */
 74472:         WatchpointMap *wpmap = cx->compartment->watchpointMap;
 98960:         if (wpmap && !wpmap->triggerWatchpoint(cx, obj, id, vp))
 74472:             return false;
 74472:     }
 74472: 
 69855:     if (!LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags, &pobj, &prop))
 69855:         return false;
 27237:     if (prop) {
 56817:         if (!pobj->isNative()) {
 56817:             if (pobj->isProxy()) {
 56817:                 AutoPropertyDescriptorRooter pd(cx);
 79386:                 if (!Proxy::getPropertyDescriptor(cx, pobj, id, true, &pd))
 56817:                     return false;
 56817: 
 63289:                 if ((pd.attrs & (JSPROP_SHARED | JSPROP_SHADOWABLE)) == JSPROP_SHARED) {
 63289:                     return !pd.setter ||
 63289:                            CallSetter(cx, obj, id, pd.setter, pd.attrs, pd.shortid, strict, vp);
 63289:                 }
 56817: 
 56817:                 if (pd.attrs & JSPROP_READONLY) {
 56817:                     if (strict)
101861:                         return JSObject::reportReadOnly(cx, id, JSREPORT_ERROR);
 61450:                     if (cx->hasStrictOption())
101861:                         return JSObject::reportReadOnly(cx, id, JSREPORT_STRICT | JSREPORT_WARNING);
 56817:                     return true;
 56817:                 }
 56817:             }
 56817: 
     1:             prop = NULL;
 56817:         }
 27237:     } else {
 27237:         /* We should never add properties to lexical blocks. */
 53650:         JS_ASSERT(!obj->isBlock());
 27237: 
 83254:         if (obj->isGlobal() &&
 69855:             (defineHow & DNP_UNQUALIFIED) &&
 79734:             !js::CheckUndeclaredVarAssignment(cx, JSID_TO_STRING(id))) {
 41774:             return JS_FALSE;
 41774:         }
 27237:     }
 95355: 
 99421:     RootedShape shape(cx, (Shape *) prop);
     1: 
     1:     /*
 52503:      * Now either shape is null, meaning id was not found in obj or one of its
 52503:      * prototypes; or shape is non-null, meaning id was found directly in pobj.
     1:      */
     1:     attrs = JSPROP_ENUMERATE;
     1:     flags = 0;
     1:     shortid = 0;
 40826:     clasp = obj->getClass();
     1:     getter = clasp->getProperty;
     1:     setter = clasp->setProperty;
     1: 
 52503:     if (shape) {
 40832:         /* ES5 8.12.4 [[Put]] step 2. */
 52503:         if (shape->isAccessorDescriptor()) {
 60780:             if (shape->hasDefaultSetter())
 40832:                 return js_ReportGetterOnlyAssignment(cx);
 40832:         } else {
 52503:             JS_ASSERT(shape->isDataDescriptor());
 52503: 
 52503:             if (!shape->writable()) {
 54169:                 /* Error in strict mode code, warn with strict option, otherwise do nothing. */
 54169:                 if (strict)
101861:                     return JSObject::reportReadOnly(cx, id, JSREPORT_ERROR);
 61450:                 if (cx->hasStrictOption())
101861:                     return JSObject::reportReadOnly(cx, id, JSREPORT_STRICT | JSREPORT_WARNING);
 27932:                 return JS_TRUE;
     1:             }
 40832:         }
     1: 
 52503:         attrs = shape->attributes();
 56760:         if (pobj != obj) {
     1:             /*
     1:              * We found id in a prototype object: prepare to share or shadow.
     1:              */
 59898:             if (!shape->shadowable()) {
 69855:                 if (defineHow & DNP_CACHE_RESULT)
 69855:                     JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, pobj, shape);
 52503: 
 52503:                 if (shape->hasDefaultSetter() && !shape->hasGetterValue())
 27932:                     return JS_TRUE;
 27932: 
 62395:                 return shape->set(cx, obj, strict, vp);
     1:             }
     1: 
     1:             /*
 59898:              * Preserve attrs except JSPROP_SHARED, getter, and setter when
 59898:              * shadowing any property that has no slot (is shared). We must
 59898:              * clear the shared attribute for the shadowing shape so that the
 59898:              * property in obj that it defines has a slot to retain the value
 59898:              * being set, in case the setter simply cannot operate on instances
 59898:              * of obj's class by storing the value in some class-specific
 59898:              * location.
 59898:              *
 59898:              * A subset of slotless shared properties is the set of properties
 59898:              * with shortids, which must be preserved too. An old API requires
 59898:              * that the property's getter and setter receive the shortid, not
 59898:              * id, when they are called on the shadowing property that we are
 52503:              * about to create in obj.
     1:              */
 59898:             if (!shape->hasSlot()) {
 52503:                 if (shape->hasShortID()) {
 52503:                     flags = Shape::HAS_SHORTID;
 83221:                     shortid = shape->shortid();
 59898:                 }
 59898:                 attrs &= ~JSPROP_SHARED;
 52503:                 getter = shape->getter();
 52503:                 setter = shape->setter();
 59898:             } else {
 59898:                 /* Restore attrs to the ECMA default for new properties. */
 59898:                 attrs = JSPROP_ENUMERATE;
     1:             }
     1: 
     1:             /*
     1:              * Forget we found the proto-property now that we've copied any
     1:              * needed member values.
     1:              */
 52503:             shape = NULL;
 52503:         }
     1:     }
     1: 
 27930:     added = false;
 52503:     if (!shape) {
 54563:         if (!obj->isExtensible()) {
 54563:             /* Error in strict mode code, warn with strict option, otherwise do nothing. */
 54563:             if (strict)
 54587:                 return obj->reportNotExtensible(cx);
 61450:             if (cx->hasStrictOption())
 54587:                 return obj->reportNotExtensible(cx, JSREPORT_STRICT | JSREPORT_WARNING);
 54563:             return JS_TRUE;
 54563:         }
 54563: 
 11377:         /*
 11377:          * Purge the property cache of now-shadowed id in obj's scope chain.
 11377:          * Do this early, before locking obj to avoid nesting locks.
 11377:          */
 83221:         if (!js_PurgeScopeChain(cx, obj, id))
 27932:             return JS_FALSE;
 32658: 
 52503:         shape = obj->putProperty(cx, id, getter, setter, SHAPE_INVALID_SLOT,
 35334:                                  attrs, flags, shortid);
 56567:         if (!shape)
 27932:             return JS_FALSE;
     1: 
     1:         /*
     1:          * Initialize the new property value (passed to setter) to undefined.
     1:          * Note that we store before calling addProperty, to match the order
 69855:          * in DefineNativeProperty.
     1:          */
 86009:         if (shape->hasSlot())
 83221:             obj->nativeSetSlot(shape->slot(), UndefinedValue());
     1: 
     1:         /* XXXbe called with obj locked */
 52503:         if (!CallAddPropertyHook(cx, clasp, obj, shape, vp)) {
 52503:             obj->removeProperty(cx, id);
 32658:             return JS_FALSE;
 32658:         }
 27930:         added = true;
     1:     }
     1: 
 83221:     if ((defineHow & DNP_CACHE_RESULT) && !added)
 83221:         JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, obj, shape);
 60780: 
 62395:     return js_NativeSet(cx, obj, shape, added, strict, vp);
     1: }
     1: 
     1: JSBool
 98960: baseops::SetElementHelper(JSContext *cx, HandleObject obj, uint32_t index, unsigned defineHow,
 78346:                           Value *vp, JSBool strict)
 78346: {
 99421:     RootedId id(cx);
 98960:     if (!IndexToId(cx, index, id.address()))
 98960:         return false;
 98960:     return baseops::SetPropertyHelper(cx, obj, id, defineHow, vp, strict);
 78346: }
 78346: 
 78346: JSBool
 98960: baseops::GetAttributes(JSContext *cx, HandleObject obj, HandleId id, unsigned *attrsp)
 98960: {
 98960:     JSObject *nobj;
 43290:     JSProperty *prop;
 98960:     if (!baseops::LookupProperty(cx, obj, id, &nobj, &prop))
 43290:         return false;
     1:     if (!prop) {
     1:         *attrsp = 0;
 43290:         return true;
 43290:     }
 98960:     if (!nobj->isNative())
 98960:         return nobj->getGenericAttributes(cx, id, attrsp);
 43290: 
 52503:     const Shape *shape = (Shape *)prop;
 52503:     *attrsp = shape->attributes();
 43290:     return true;
     1: }
     1: 
     1: JSBool
 98960: baseops::GetElementAttributes(JSContext *cx, HandleObject obj, uint32_t index, unsigned *attrsp)
 98960: {
 98960:     JSObject *nobj;
 78342:     JSProperty *prop;
 98960:     if (!baseops::LookupElement(cx, obj, index, &nobj, &prop))
 78342:         return false;
 78342:     if (!prop) {
 78342:         *attrsp = 0;
 78342:         return true;
 78342:     }
 98960:     if (!nobj->isNative())
 98960:         return nobj->getElementAttributes(cx, index, attrsp);
 78342: 
 78342:     const Shape *shape = (Shape *)prop;
 78342:     *attrsp = shape->attributes();
 78342:     return true;
 78342: }
 78342: 
 78342: JSBool
 98960: baseops::SetAttributes(JSContext *cx, HandleObject obj, HandleId id, unsigned *attrsp)
 98960: {
 98960:     JSObject *nobj;
 43290:     JSProperty *prop;
 98960:     if (!baseops::LookupProperty(cx, obj, id, &nobj, &prop))
 43290:         return false;
     1:     if (!prop)
 43290:         return true;
 98960:     return nobj->isNative()
 98960:            ? nobj->changePropertyAttributes(cx, (Shape *) prop, *attrsp)
 98960:            : nobj->setGenericAttributes(cx, id, attrsp);
     1: }
     1: 
     1: JSBool
 98960: baseops::SetElementAttributes(JSContext *cx, HandleObject obj, uint32_t index, unsigned *attrsp)
 98960: {
 98960:     JSObject *nobj;
 78343:     JSProperty *prop;
 98960:     if (!baseops::LookupElement(cx, obj, index, &nobj, &prop))
 78343:         return false;
 78343:     if (!prop)
 78343:         return true;
 98960:     return nobj->isNative()
 98960:            ? nobj->changePropertyAttributes(cx, (Shape *) prop, *attrsp)
 98960:            : nobj->setElementAttributes(cx, index, attrsp);
 78343: }
 78343: 
 78343: JSBool
 98960: baseops::DeleteGeneric(JSContext *cx, HandleObject obj, HandleId id, Value *rval, JSBool strict)
     1: {
     1:     JSObject *proto;
     1:     JSProperty *prop;
 52503:     const Shape *shape;
     1: 
 48470:     rval->setBoolean(true);
     1: 
 98960:     if (!baseops::LookupProperty(cx, obj, id, &proto, &prop))
 54169:         return false;
     1:     if (!prop || proto != obj) {
     1:         /*
 72089:          * If no property, or the property comes from a prototype, call the
 72089:          * class's delProperty hook, passing rval as the result parameter.
     1:          */
 52503:         return CallJSPropertyOp(cx, obj->getClass()->delProperty, obj, id, rval);
 52503:     }
 52503: 
 52503:     shape = (Shape *)prop;
 52503:     if (!shape->configurable()) {
 54169:         if (strict)
 54587:             return obj->reportNotConfigurable(cx, id);
 48470:         rval->setBoolean(false);
 54169:         return true;
     1:     }
     1: 
 86009:     if (shape->hasSlot()) {
 83221:         const Value &v = obj->nativeGetSlot(shape->slot());
 89826:         GCPoke(cx->runtime, v);
 48676:     }
     1: 
 99421:     RootedId userid(cx);
 98960:     if (!shape->getUserId(cx, userid.address()))
 97828:         return false;
 97828: 
 97828:     if (!CallJSPropertyOp(cx, obj->getClass()->delProperty, obj, userid, rval))
 86009:         return false;
 86009:     if (rval->isFalse())
 86009:         return true;
 86009: 
 56567:     return obj->removeProperty(cx, id) && js_SuppressDeletedProperty(cx, obj, id);
     1: }
     1: 
 78344: JSBool
 98960: baseops::DeleteProperty(JSContext *cx, HandleObject obj, HandlePropertyName name, Value *rval, JSBool strict)
 98960: {
102586:     Rooted<jsid> id(cx, NameToId(name));
102586:     return baseops::DeleteGeneric(cx, obj, id, rval, strict);
 86790: }
 86790: 
 86790: JSBool
 98960: baseops::DeleteElement(JSContext *cx, HandleObject obj, uint32_t index, Value *rval, JSBool strict)
 98960: {
 99421:     RootedId id(cx);
 98960:     if (!IndexToId(cx, index, id.address()))
 98960:         return false;
 98960:     return baseops::DeleteGeneric(cx, obj, id, rval, strict);
 86790: }
 86790: 
 86790: JSBool
 98960: baseops::DeleteSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid, Value *rval, JSBool strict)
 98960: {
102586:     Rooted<jsid> id(cx, SPECIALID_TO_JSID(sid));
102586:     return baseops::DeleteGeneric(cx, obj, id, rval, strict);
 78344: }
 78344: 
 47607: namespace js {
 47607: 
 72053: bool
 95355: HasDataProperty(JSContext *cx, HandleObject obj, jsid id, Value *vp)
 93245: {
 93245:     if (const Shape *shape = obj->nativeLookup(cx, id)) {
 94227:         if (shape->hasDefaultGetter() && shape->hasSlot()) {
 83221:             *vp = obj->nativeGetSlot(shape->slot());
 72053:             return true;
 72053:         }
 72053:     }
 72053: 
 72053:     return false;
 57686: }
 57686: 
 72054: /*
 72054:  * Gets |obj[id]|.  If that value's not callable, returns true and stores a
 72054:  * non-primitive value in *vp.  If it's callable, calls it with no arguments
 72054:  * and |obj| as |this|, returning the result in *vp.
 72054:  *
 72054:  * This is a mini-abstraction for ES5 8.12.8 [[DefaultValue]], either steps 1-2
 72054:  * or steps 3-4.
 72054:  */
 72054: static bool
102586: MaybeCallMethod(JSContext *cx, HandleObject obj, Handle<jsid> id, Value *vp)
102586: {
102586:     if (!GetMethod(cx, obj, id, 0, vp))
 72054:         return false;
 72054:     if (!js_IsCallable(*vp)) {
 72054:         *vp = ObjectValue(*obj);
 72054:         return true;
 72054:     }
 76829:     return Invoke(cx, ObjectValue(*obj), *vp, 0, NULL, vp);
 72054: }
 72054: 
 72054: JSBool
 95355: DefaultValue(JSContext *cx, HandleObject obj, JSType hint, Value *vp)
 55737: {
 72054:     JS_ASSERT(hint == JSTYPE_NUMBER || hint == JSTYPE_STRING || hint == JSTYPE_VOID);
 98644: #if JS_HAS_XML_SUPPORT
 72054:     JS_ASSERT(!obj->isXML());
 98644: #endif
 72054: 
102586:     Rooted<jsid> id(cx);
102586: 
 72054:     Class *clasp = obj->getClass();
 55737:     if (hint == JSTYPE_STRING) {
102586:         id = NameToId(cx->runtime->atomState.toStringAtom);
102586: 
 55737:         /* Optimize (new String(...)).toString(). */
102586:         if (clasp == &StringClass) {
102586:             if (ClassMethodIsNative(cx, obj, &StringClass, id, js_str_toString)) {
 90338:                 *vp = StringValue(obj->asString().unbox());
 55737:                 return true;
 55737:             }
102586:         }
102586: 
102586:         if (!MaybeCallMethod(cx, obj, id, vp))
 72054:             return false;
 72054:         if (vp->isPrimitive())
 67921:             return true;
 72054: 
102586:         id = NameToId(cx->runtime->atomState.valueOfAtom);
102586:         if (!MaybeCallMethod(cx, obj, id, vp))
 72054:             return false;
 72054:         if (vp->isPrimitive())
 72054:             return true;
 48470:     } else {
102586: 
102586:         /* Optimize new String(...).valueOf(). */
102586:         if (clasp == &StringClass) {
102586:             id = NameToId(cx->runtime->atomState.valueOfAtom);
102586:             if (ClassMethodIsNative(cx, obj, &StringClass, id, js_str_toString)) {
102586:                 *vp = StringValue(obj->asString().unbox());
 55737:                 return true;
 55737:             }
102586:         }
102586: 
102586:         /* Optimize new Number(...).valueOf(). */
102586:         if (clasp == &NumberClass) {
102586:             id = NameToId(cx->runtime->atomState.valueOfAtom);
102586:             if (ClassMethodIsNative(cx, obj, &NumberClass, id, js_num_valueOf)) {
102586:                 *vp = NumberValue(obj->asNumber().unbox());
102586:                 return true;
102586:             }
102586:         }
102586: 
102586:         id = NameToId(cx->runtime->atomState.valueOfAtom);
102586:         if (!MaybeCallMethod(cx, obj, id, vp))
 72054:             return false;
 72054:         if (vp->isPrimitive())
 67921:             return true;
 72054: 
102586:         id = NameToId(cx->runtime->atomState.toStringAtom);
102586:         if (!MaybeCallMethod(cx, obj, id, vp))
 72054:             return false;
 72054:         if (vp->isPrimitive())
 72054:             return true;
 72054:     }
 72054: 
     1:     /* Avoid recursive death when decompiling in js_ReportValueError. */
 48470:     JSString *str;
     1:     if (hint == JSTYPE_STRING) {
 72054:         str = JS_InternString(cx, clasp->name);
     1:         if (!str)
 55737:             return false;
     1:     } else {
     1:         str = NULL;
     1:     }
 72054: 
 72054:     js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO, JSDVG_SEARCH_STACK, ObjectValue(*obj), str,
 72054:                          (hint == JSTYPE_VOID) ? "primitive type" : JS_TYPE_STR(hint));
 72054:     return false;
     1: }
     1: 
 47607: } /* namespace js */
 47607: 
 48622: JS_FRIEND_API(JSBool)
 98960: JS_EnumerateState(JSContext *cx, JSHandleObject obj, JSIterateOp enum_op, Value *statep, jsid *idp)
 42641: {
 42641:     /* If the class has a custom JSCLASS_NEW_ENUMERATE hook, call it. */
 48470:     Class *clasp = obj->getClass();
 33128:     JSEnumerateOp enumerate = clasp->enumerate;
 11835:     if (clasp->flags & JSCLASS_NEW_ENUMERATE) {
 11835:         JS_ASSERT(enumerate != JS_EnumerateStub);
 78614:         return ((JSNewEnumerateOp) enumerate)(cx, obj, enum_op, statep, idp);
 11835:     }
     1: 
     1:     if (!enumerate(cx, obj))
 33128:         return false;
 15677: 
 42641:     /* Tell InitNativeIterator to treat us like a native object. */
 47569:     JS_ASSERT(enum_op == JSENUMERATE_INIT || enum_op == JSENUMERATE_INIT_ALL);
 48470:     statep->setMagic(JS_NATIVE_ENUMERATE);
 33128:     return true;
     1: }
     1: 
 47455: namespace js {
 47455: 
     1: JSBool
 98960: CheckAccess(JSContext *cx, JSObject *obj_, HandleId id, JSAccessMode mode,
 91237:             Value *vp, unsigned *attrsp)
     1: {
     1:     JSBool writing;
     1:     JSProperty *prop;
 52503:     const Shape *shape;
     1: 
 99421:     RootedObject obj(cx, obj_), pobj(cx);
 98960: 
 77817:     while (JS_UNLIKELY(obj->isWith()))
 47455:         obj = obj->getProto();
 47455: 
     1:     writing = (mode & JSACC_WRITE) != 0;
     1:     switch (mode & JSACC_TYPEMASK) {
     1:       case JSACC_PROTO:
     1:         pobj = obj;
     1:         if (!writing)
 48470:             vp->setObjectOrNull(obj->getProto());
     1:         *attrsp = JSPROP_PERMANENT;
     1:         break;
     1: 
     1:       case JSACC_PARENT:
     1:         JS_ASSERT(!writing);
     1:         pobj = obj;
 48470:         vp->setObject(*obj->getParent());
     1:         *attrsp = JSPROP_READONLY | JSPROP_PERMANENT;
     1:         break;
     1: 
     1:       default:
 98960:         if (!obj->lookupGeneric(cx, id, pobj.address(), &prop))
     1:             return JS_FALSE;
     1:         if (!prop) {
     1:             if (!writing)
 48470:                 vp->setUndefined();
     1:             *attrsp = 0;
 11842:             pobj = obj;
 11842:             break;
 11842:         }
 11842: 
 40430:         if (!pobj->isNative()) {
 16403:             if (!writing) {
 48470:                     vp->setUndefined();
 16403:                 *attrsp = 0;
 16403:             }
 11842:             break;
 11961:         }
     1: 
 52503:         shape = (Shape *)prop;
 52503:         *attrsp = shape->attributes();
     1:         if (!writing) {
 83221:             if (shape->hasSlot())
 83221:                 *vp = pobj->nativeGetSlot(shape->slot());
 48470:             else
 48470:                 vp->setUndefined();
     1:         }
     1:     }
     1: 
 84680:     JS_ASSERT_IF(*attrsp & JSPROP_READONLY, !(*attrsp & (JSPROP_GETTER | JSPROP_SETTER)));
 84680: 
     1:     /*
     1:      * If obj's class has a stub (null) checkAccess hook, use the per-runtime
     1:      * checkObjectAccess callback, if configured.
     1:      *
     1:      * We don't want to require all classes to supply a checkAccess hook; we
     1:      * need that hook only for certain classes used when precompiling scripts
     1:      * and functions ("brutal sharing").  But for general safety of built-in
 41968:      * magic properties like __proto__, we route all access checks, even for
 41968:      * classes that stub out checkAccess, through the global checkObjectAccess
 41968:      * hook.  This covers precompilation-based sharing and (possibly
 41968:      * unintended) runtime sharing across trust boundaries.
     1:      */
 91900:     JSCheckAccessOp check = pobj->getClass()->checkAccess;
 91900:     if (!check)
 91900:         check = cx->runtime->securityCallbacks->checkObjectAccess;
 48470:     return !check || check(cx, pobj, id, mode, vp);
     1: }
     1: 
 47455: }
 47455: 
 38633: JSType
 98960: baseops::TypeOf(JSContext *cx, HandleObject obj)
 38633: {
 64209:     return obj->isCallable() ? JSTYPE_FUNCTION : JSTYPE_OBJECT;
 38633: }
 38633: 
 48470: bool
 48470: js_IsDelegate(JSContext *cx, JSObject *obj, const Value &v)
 48470: {
 48470:     if (v.isPrimitive())
 48470:         return false;
 56565:     JSObject *obj2 = &v.toObject();
 39928:     while ((obj2 = obj2->getProto()) != NULL) {
 48470:         if (obj2 == obj)
 48470:             return true;
 48470:     }
 48470:     return false;
     1: }
     1: 
 47497: bool
 52503: js::FindClassPrototype(JSContext *cx, JSObject *scopeobj, JSProtoKey protoKey,
 52503:                        JSObject **protop, Class *clasp)
 48470: {
 48470:     Value v;
 52503:     if (!js_FindClassObject(cx, scopeobj, protoKey, &v, clasp))
 47497:         return false;
 47497: 
 48470:     if (IsFunctionObject(v)) {
 48470:         JSObject *ctor = &v.toObject();
 78675:         if (!ctor->getProperty(cx, cx->runtime->atomState.classPrototypeAtom, &v))
 47497:             return false;
 47497:     }
 47497: 
 48470:     *protop = v.isObject() ? &v.toObject() : NULL;
 47497:     return true;
 47497: }
 47497: 
 47497: /*
 47497:  * The first part of this function has been hand-expanded and optimized into
 47497:  * NewBuiltinClassInstance in jsobjinlines.h.
 47497:  */
     1: JSBool
 52503: js_GetClassPrototype(JSContext *cx, JSObject *scopeobj, JSProtoKey protoKey,
 48470:                      JSObject **protop, Class *clasp)
 38604: {
 38604:     JS_ASSERT(JSProto_Null <= protoKey);
 38604:     JS_ASSERT(protoKey < JSProto_LIMIT);
 38604: 
 38604:     if (protoKey != JSProto_Null) {
 80803:         GlobalObject *global;
 80803:         if (scopeobj) {
 86483:             global = &scopeobj->global();
 80803:         } else {
 80803:             global = GetCurrentGlobal(cx);
 80803:             if (!global) {
 62953:                 *protop = NULL;
 62953:                 return true;
 62953:             }
 62953:         }
 80803:         const Value &v = global->getReservedSlot(JSProto_LIMIT + protoKey);
 48470:         if (v.isObject()) {
 48470:             *protop = &v.toObject();
 38604:             return true;
 38604:         }
 38604:     }
 38604: 
 52503:     return FindClassPrototype(cx, scopeobj, protoKey, protop, clasp);
     1: }
     1: 
 61734: JSObject *
 61734: PrimitiveToObject(JSContext *cx, const Value &v)
 61734: {
102586:     if (v.isString()) {
102586:         Rooted<JSString*> str(cx, v.toString());
102586:         return StringObject::create(cx, str);
102586:     }
 78915:     if (v.isNumber())
 78915:         return NumberObject::create(cx, v.toNumber());
 78915: 
 78915:     JS_ASSERT(v.isBoolean());
 80701:     return BooleanObject::create(cx, v.toBoolean());
 61734: }
 61734: 
 61734: JSBool
 61734: js_PrimitiveToObject(JSContext *cx, Value *vp)
 61734: {
 61734:     JSObject *obj = PrimitiveToObject(cx, *vp);
 61734:     if (!obj)
 61734:         return false;
 61734: 
 48470:     vp->setObject(*obj);
 61734:     return true;
  2383: }
  2383: 
  2383: JSBool
 48470: js_ValueToObjectOrNull(JSContext *cx, const Value &v, JSObject **objp)
     1: {
     1:     JSObject *obj;
     1: 
 48470:     if (v.isObjectOrNull()) {
 48470:         obj = v.toObjectOrNull();
 48470:     } else if (v.isUndefined()) {
     1:         obj = NULL;
     1:     } else {
 61734:         obj = PrimitiveToObject(cx, v);
 61734:         if (!obj)
 61734:             return false;
     1:     }
     1:     *objp = obj;
 61734:     return true;
 61734: }
 61734: 
 61734: namespace js {
 61734: 
 61734: /* Callers must handle the already-object case . */
 61734: JSObject *
 61734: ToObjectSlow(JSContext *cx, Value *vp)
 61734: {
 61734:     JS_ASSERT(!vp->isMagic());
 61734:     JS_ASSERT(!vp->isObject());
 61734: 
 61734:     if (vp->isNullOrUndefined()) {
 61734:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_CONVERT_TO,
 61734:                             vp->isNull() ? "null" : "undefined", "object");
 61734:         return NULL;
 61734:     }
 61734: 
 61734:     JSObject *obj = PrimitiveToObject(cx, *vp);
 61734:     if (obj)
 61734:         vp->setObject(*obj);
 61734:     return obj;
 61734: }
 61734: 
     1: }
     1: 
     1: JSObject *
 48470: js_ValueToNonNullObject(JSContext *cx, const Value &v)
     1: {
     1:     JSObject *obj;
     1: 
 48470:     if (!js_ValueToObjectOrNull(cx, v, &obj))
     1:         return NULL;
  7897:     if (!obj)
  7897:         js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, v, NULL);
     1:     return obj;
     1: }
     1: 
 11835: void
 98544: js_GetObjectSlotName(JSTracer *trc, char *buf, size_t bufsize)
 98544: {
 98544:     JS_ASSERT(trc->debugPrinter == js_GetObjectSlotName);
 32684: 
 32684:     JSObject *obj = (JSObject *)trc->debugPrintArg;
 84755:     uint32_t slot = uint32_t(trc->debugPrintIndex);
 32684: 
 52503:     const Shape *shape;
 40430:     if (obj->isNative()) {
 52503:         shape = obj->lastProperty();
 86009:         while (shape && (!shape->hasSlot() || shape->slot() != slot))
 52503:             shape = shape->previous();
 11835:     } else {
 52503:         shape = NULL;
 52503:     }
 52503: 
 52503:     if (!shape) {
 32684:         const char *slotname = NULL;
 60566:         if (obj->isGlobal()) {
   583: #define JS_PROTO(name,code,init)                                              \
 55746:     if ((code) == slot) { slotname = js_##name##_str; goto found; }
   583: #include "jsproto.tbl"
   583: #undef JS_PROTO
   583:         }
   583:       found:
   583:         if (slotname)
   583:             JS_snprintf(buf, bufsize, "CLASS_OBJECT(%s)", slotname);
   583:         else
   583:             JS_snprintf(buf, bufsize, "**UNKNOWN SLOT %ld**", (long)slot);
   583:     } else {
 83221:         jsid propid = shape->propid();
 69637:         if (JSID_IS_INT(propid)) {
 69637:             JS_snprintf(buf, bufsize, "%ld", (long)JSID_TO_INT(propid));
 69637:         } else if (JSID_IS_ATOM(propid)) {
 69637:             PutEscapedString(buf, bufsize, JSID_TO_ATOM(propid), 0);
   583:         } else {
   583:             JS_snprintf(buf, bufsize, "**FINALIZED ATOM KEY**");
   583:         }
   583:     }
   583: }
   583: 
 68903: static const Shape *
 68903: LastConfigurableShape(JSObject *obj)
 68903: {
 68903:     for (Shape::Range r(obj->lastProperty()->all()); !r.empty(); r.popFront()) {
 68903:         const Shape *shape = &r.front();
 68903:         if (shape->configurable())
 68903:             return shape;
 68903:     }
 68903:     return NULL;
 68903: }
 68903: 
 68903: bool
 48622: js_ClearNative(JSContext *cx, JSObject *obj)
     1: {
 68903:     /* Remove all configurable properties from obj. */
 68903:     while (const Shape *shape = LastConfigurableShape(obj)) {
 83221:         if (!obj->removeProperty(cx, shape->propid()))
 68903:             return false;
 68903:     }
 68903: 
 68903:     /* Set all remaining writable plain data properties to undefined. */
 68903:     for (Shape::Range r(obj->lastProperty()->all()); !r.empty(); r.popFront()) {
 68903:         const Shape *shape = &r.front();
 68903:         if (shape->isDataDescriptor() &&
 68903:             shape->writable() &&
 68903:             shape->hasDefaultSetter() &&
 86009:             shape->hasSlot()) {
 86009:             obj->nativeSetSlot(shape->slot(), UndefinedValue());
 68903:         }
 68903:     }
 68903:     return true;
     1: }
     1: 
 36491: JSBool
 27641: js_ReportGetterOnlyAssignment(JSContext *cx)
 27641: {
 36491:     return JS_ReportErrorFlagsAndNumber(cx,
 36491:                                         JSREPORT_WARNING | JSREPORT_STRICT |
 36491:                                         JSREPORT_STRICT_MODE_ERROR,
 36491:                                         js_GetErrorMessage, NULL,
 36491:                                         JSMSG_GETTER_ONLY);
 27641: }
 27641: 
 27641: JS_FRIEND_API(JSBool)
 98960: js_GetterOnlyPropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, JSBool strict, jsval *vp)
 27641: {
 36491:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_GETTER_ONLY);
 27641:     return JS_FALSE;
 27641: }
 27641: 
 24294: #ifdef DEBUG
 19714: 
 19714: /*
 19714:  * Routines to print out values during debugging.  These are FRIEND_API to help
 19714:  * the debugger find them and to support temporarily hacking js_Dump* calls
 19714:  * into other code.
 19714:  */
 19714: 
 19714: void
 48470: dumpValue(const Value &v)
 48470: {
 48470:     if (v.isNull())
 19714:         fprintf(stderr, "null");
 48470:     else if (v.isUndefined())
 19714:         fprintf(stderr, "undefined");
 48470:     else if (v.isInt32())
 48470:         fprintf(stderr, "%d", v.toInt32());
 48470:     else if (v.isDouble())
 48470:         fprintf(stderr, "%g", v.toDouble());
 48470:     else if (v.isString())
 89265:         v.toString()->dump();
 48470:     else if (v.isObject() && v.toObject().isFunction()) {
 83234:         JSFunction *fun = v.toObject().toFunction();
 57721:         if (fun->atom) {
 57721:             fputs("<function ", stderr);
 64345:             FileEscapedString(stderr, fun->atom, 0);
 57721:         } else {
 57721:             fputs("<unnamed function", stderr);
 57721:         }
 59062:         if (fun->isInterpreted()) {
 59062:             JSScript *script = fun->script();
 59062:             fprintf(stderr, " (%s:%u)",
 59062:                     script->filename ? script->filename : "", script->lineno);
 59062:         }
 83234:         fprintf(stderr, " at %p>", (void *) fun);
 48470:     } else if (v.isObject()) {
 48470:         JSObject *obj = &v.toObject();
 48470:         Class *clasp = obj->getClass();
 19714:         fprintf(stderr, "<%s%s at %p>",
 47480:                 clasp->name,
 77817:                 (clasp == &ObjectClass) ? "" : " object",
 25218:                 (void *) obj);
 48470:     } else if (v.isBoolean()) {
 48470:         if (v.toBoolean())
 19714:             fprintf(stderr, "true");
 48470:         else
 19714:             fprintf(stderr, "false");
 48470:     } else if (v.isMagic()) {
 48470:         fprintf(stderr, "<invalid");
 48470: #ifdef DEBUG
 48470:         switch (v.whyMagic()) {
 48470:           case JS_ARRAY_HOLE:        fprintf(stderr, " array hole");         break;
 48470:           case JS_NATIVE_ENUMERATE:  fprintf(stderr, " native enumeration"); break;
 48470:           case JS_NO_ITER_VALUE:     fprintf(stderr, " no iter value");      break;
 48470:           case JS_GENERATOR_CLOSING: fprintf(stderr, " generator closing");  break;
 48470:           default:                   fprintf(stderr, " ?!");                 break;
 48470:         }
 48470: #endif
 48470:         fprintf(stderr, ">");
 19714:     } else {
 48470:         fprintf(stderr, "unexpected value");
 19714:     }
 19714: }
 19714: 
 19714: JS_FRIEND_API(void)
 48470: js_DumpValue(const Value &val)
 48470: {
 19714:     dumpValue(val);
 19714:     fputc('\n', stderr);
 19714: }
 19714: 
 19714: JS_FRIEND_API(void)
 19714: js_DumpId(jsid id)
 19714: {
 48470:     fprintf(stderr, "jsid %p = ", (void *) JSID_BITS(id));
 48470:     dumpValue(IdToValue(id));
 19714:     fputc('\n', stderr);
 19714: }
 19714: 
 20208: static void
 62931: DumpProperty(JSObject *obj, const Shape &shape)
 52503: {
 83221:     jsid id = shape.propid();
 84755:     uint8_t attrs = shape.attributes();
 19714: 
 62931:     fprintf(stderr, "    ((Shape *) %p) ", (void *) &shape);
 19714:     if (attrs & JSPROP_ENUMERATE) fprintf(stderr, "enumerate ");
 19714:     if (attrs & JSPROP_READONLY) fprintf(stderr, "readonly ");
 19714:     if (attrs & JSPROP_PERMANENT) fprintf(stderr, "permanent ");
 19714:     if (attrs & JSPROP_SHARED) fprintf(stderr, "shared ");
 62931: 
 62931:     if (shape.hasGetterValue())
 62931:         fprintf(stderr, "getterValue=%p ", (void *) shape.getterObject());
 62931:     else if (!shape.hasDefaultGetter())
 62936:         fprintf(stderr, "getterOp=%p ", JS_FUNC_TO_DATA_PTR(void *, shape.getterOp()));
 62931: 
 62931:     if (shape.hasSetterValue())
 62931:         fprintf(stderr, "setterValue=%p ", (void *) shape.setterObject());
 62931:     else if (!shape.hasDefaultSetter())
 62936:         fprintf(stderr, "setterOp=%p ", JS_FUNC_TO_DATA_PTR(void *, shape.setterOp()));
 59009: 
 19714:     if (JSID_IS_ATOM(id))
 89265:         JSID_TO_STRING(id)->dump();
 19714:     else if (JSID_IS_INT(id))
 19714:         fprintf(stderr, "%d", (int) JSID_TO_INT(id));
 19714:     else
 48470:         fprintf(stderr, "unknown jsid %p", (void *) JSID_BITS(id));
 83221: 
 84755:     uint32_t slot = shape.hasSlot() ? shape.maybeSlot() : SHAPE_INVALID_SLOT;
 83221:     fprintf(stderr, ": slot %d", slot);
 86009:     if (shape.hasSlot()) {
 62931:         fprintf(stderr, " = ");
 83221:         dumpValue(obj->getSlot(slot));
 83221:     } else if (slot != SHAPE_INVALID_SLOT) {
 62931:         fprintf(stderr, " (INVALID!)");
 62931:     }
 19714:     fprintf(stderr, "\n");
 19714: }
 19714: 
 89265: void
 89265: JSObject::dump()
 89265: {
 89265:     JSObject *obj = this;
 13437:     fprintf(stderr, "object %p\n", (void *) obj);
 55747:     Class *clasp = obj->getClass();
     1:     fprintf(stderr, "class %p %s\n", (void *)clasp, clasp->name);
 19714: 
 52503:     fprintf(stderr, "flags:");
 83248:     if (obj->isDelegate()) fprintf(stderr, " delegate");
 83248:     if (obj->isSystem()) fprintf(stderr, " system");
 83248:     if (!obj->isExtensible()) fprintf(stderr, " not_extensible");
 83248:     if (obj->isIndexed()) fprintf(stderr, " indexed");
 79734: 
 53569:     if (obj->isNative()) {
 83249:         if (obj->inDictionaryMode())
 52503:             fprintf(stderr, " inDictionaryMode");
 97571:         if (obj->hasShapeTable())
 97571:             fprintf(stderr, " hasShapeTable");
 83249:     }
 52503:     fprintf(stderr, "\n");
 52503: 
 37003:     if (obj->isDenseArray()) {
 77343:         unsigned slots = obj->getDenseArrayInitializedLength();
 19714:         fprintf(stderr, "elements\n");
 55748:         for (unsigned i = 0; i < slots; i++) {
 19714:             fprintf(stderr, " %3d: ", i);
 41782:             dumpValue(obj->getDenseArrayElement(i));
 19714:             fprintf(stderr, "\n");
 19714:             fflush(stderr);
 19714:         }
 13437:         return;
 13437:     }
 13437: 
 31452:     fprintf(stderr, "proto ");
 48470:     dumpValue(ObjectOrNullValue(obj->getProto()));
 31452:     fputc('\n', stderr);
 31452: 
 31452:     fprintf(stderr, "parent ");
 48470:     dumpValue(ObjectOrNullValue(obj->getParent()));
 31452:     fputc('\n', stderr);
 31452: 
 55746:     if (clasp->flags & JSCLASS_HAS_PRIVATE)
 31452:         fprintf(stderr, "private %p\n", obj->getPrivate());
 31452: 
 62931:     if (!obj->isNative())
 62931:         fprintf(stderr, "not native\n");
 62931: 
 55748:     unsigned reservedEnd = JSCLASS_RESERVED_SLOTS(clasp);
 55748:     unsigned slots = obj->slotSpan();
 62931:     unsigned stop = obj->isNative() ? reservedEnd : slots;
 62931:     if (stop > 0)
 62931:         fprintf(stderr, obj->isNative() ? "reserved slots:\n" : "slots:\n");
 62931:     for (unsigned i = 0; i < stop; i++) {
 19714:         fprintf(stderr, " %3d ", i);
 31452:         if (i < reservedEnd)
 19714:             fprintf(stderr, "(reserved) ");
 19714:         fprintf(stderr, "= ");
 40410:         dumpValue(obj->getSlot(i));
 19714:         fputc('\n', stderr);
 19714:     }
 62931: 
 62931:     if (obj->isNative()) {
 62931:         fprintf(stderr, "properties:\n");
 62931:         Vector<const Shape *, 8, SystemAllocPolicy> props;
 62931:         for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront())
 62931:             props.append(&r.front());
 62931:         for (size_t i = props.length(); i-- != 0;)
 62931:             DumpProperty(obj, *props[i]);
 62931:     }
 19714:     fputc('\n', stderr);
     1: }
     1: 
 28665: static void
 28665: MaybeDumpObject(const char *name, JSObject *obj)
 28665: {
 28665:     if (obj) {
 28665:         fprintf(stderr, "  %s: ", name);
 48470:         dumpValue(ObjectValue(*obj));
 28665:         fputc('\n', stderr);
 28665:     }
 28665: }
 28665: 
 32774: static void
 48470: MaybeDumpValue(const char *name, const Value &v)
 48470: {
 48470:     if (!v.isNull()) {
 32774:         fprintf(stderr, "  %s: ", name);
 32774:         dumpValue(v);
 32774:         fputc('\n', stderr);
 32774:     }
 32774: }
 32774: 
 28665: JS_FRIEND_API(void)
 69223: js_DumpStackFrame(JSContext *cx, StackFrame *start)
 42717: {
 42717:     /* This should only called during live debugging. */
 97161:     ScriptFrameIter i(cx, StackIter::GO_THROUGH_SAVED);
 76890:     if (!start) {
 76890:         if (i.done()) {
 76890:             fprintf(stderr, "no stack for cx = %p\n", (void*) cx);
 76890:             return;
 76890:         }
 76890:     } else {
 42717:         while (!i.done() && i.fp() != start)
 42717:             ++i;
 42717: 
 42717:         if (i.done()) {
 76890:             fprintf(stderr, "fp = %p not found in cx = %p\n",
 76890:                     (void *)start, (void *)cx);
 42717:             return;
 42717:         }
 76890:     }
 42717: 
 42717:     for (; !i.done(); ++i) {
 69223:         StackFrame *const fp = i.fp();
 69223: 
 69223:         fprintf(stderr, "StackFrame at %p\n", (void *) fp);
 53840:         if (fp->isFunctionFrame()) {
 53840:             fprintf(stderr, "callee fun: ");
 53840:             dumpValue(ObjectValue(fp->callee()));
 42717:         } else {
 28665:             fprintf(stderr, "global frame, no callee");
 42717:         }
 28665:         fputc('\n', stderr);
 28665: 
 53840:         if (fp->isScriptFrame()) {
 51056:             fprintf(stderr, "file %s line %u\n",
 53840:                     fp->script()->filename, (unsigned) fp->script()->lineno);
 51056:         }
 28665: 
 42717:         if (jsbytecode *pc = i.pc()) {
 53840:             if (!fp->isScriptFrame()) {
 42717:                 fprintf(stderr, "*** pc && !script, skipping frame\n\n");
 28665:                 continue;
 28665:             }
 28665:             fprintf(stderr, "  pc = %p\n", pc);
 28665:             fprintf(stderr, "  current op: %s\n", js_CodeName[*pc]);
 28665:         }
 86077:         MaybeDumpObject("blockChain", fp->maybeBlockChain());
 55608:         if (!fp->isDummyFrame()) {
 53840:             MaybeDumpValue("this", fp->thisValue());
 28665:             fprintf(stderr, "  rval: ");
 53840:             dumpValue(fp->returnValue());
 55608:         } else {
 55608:             fprintf(stderr, "dummy frame");
 55608:         }
 28665:         fputc('\n', stderr);
 28665: 
 28665:         fprintf(stderr, "  flags:");
 53840:         if (fp->isConstructing())
 28665:             fprintf(stderr, " constructing");
 53840:         if (fp->isDebuggerFrame())
 28665:             fprintf(stderr, " debugger");
 53840:         if (fp->isEvalFrame())
 28665:             fprintf(stderr, " eval");
 53840:         if (fp->isYielding())
 28665:             fprintf(stderr, " yielding");
 53840:         if (fp->isGeneratorFrame())
 28665:             fprintf(stderr, " generator");
 28665:         fputc('\n', stderr);
 28665: 
 96793:         fprintf(stderr, "  scopeChain: (JSObject *) %p\n", (void *) fp->scopeChain());
 28665: 
 28665:         fputc('\n', stderr);
 28665:     }
 28665: }
 28665: 
 53013: #endif /* DEBUG */
 53013: 
 95385: JS_FRIEND_API(void)
 95385: js_DumpBacktrace(JSContext *cx)
 95385: {
 95385:     Sprinter sprinter(cx);
 95385:     sprinter.init();
 95385:     size_t depth = 0;
 95385:     for (StackIter i(cx); !i.done(); ++i, ++depth) {
 95385:         if (i.isScript()) {
 95385:             const char *filename = JS_GetScriptFilename(cx, i.script());
 95385:             unsigned line = JS_PCToLineNumber(cx, i.script(), i.pc());
 95385:             sprinter.printf("#%d %14p   %s:%d (%p @ %d)\n",
 95385:                             depth, i.fp(), filename, line,
 95385:                             i.script(), i.pc() - i.script()->code);
 95385:         } else {
 95385:             sprinter.printf("#%d ???\n", depth);
 95385:         }
 95385:     }
 95385:     fprintf(stdout, "%s", sprinter.string());
 95385: }
