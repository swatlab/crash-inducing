29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsstr_h___
    1: #define jsstr_h___
    1: /*
    1:  * JS string type implementation.
    1:  *
    1:  * A JS string is a counted array of unicode characters.  To support handoff
    1:  * of API client memory, the chars are allocated separately from the length,
    1:  * necessitating a pointer after the count, to form a separately allocated
    1:  * string descriptor.  String descriptors are GC'ed, while their chars are
    1:  * allocated from the malloc heap.
    1:  */
    1: #include <ctype.h>
48470: #include "jsapi.h"
    1: #include "jsprvtd.h"
40281: #include "jshashtable.h"
29366: #include "jslock.h"
40901: #include "jsobj.h"
48470: #include "jsvalue.h"
54707: #include "jscell.h"
40337: 
56388: #define JS_CRASH(addr) *(int *) (addr) = 0;
56388: 
29366: #define JSSTRING_BIT(n)             ((size_t)1 << (n))
29366: #define JSSTRING_BITMASK(n)         (JSSTRING_BIT(n) - 1)
29366: 
32674: enum {
32674:     UNIT_STRING_LIMIT        = 256U,
48610:     SMALL_CHAR_LIMIT         = 128U, /* Bigger chars cannot be in a length-2 string. */
48610:     NUM_SMALL_CHARS          = 64U,
48610:     INT_STRING_LIMIT         = 256U,
48610:     NUM_HUNDRED_STRINGS      = 156U
32674: };
30275: 
54707: extern JSStringFinalizeOp str_finalizers[8];
54707: 
29366: extern jschar *
29366: js_GetDependentStringChars(JSString *str);
29366: 
48536: extern JSString * JS_FASTCALL
48536: js_ConcatStrings(JSContext *cx, JSString *left, JSString *right);
48536: 
33745: JS_STATIC_ASSERT(JS_BITS_PER_WORD >= 32);
33745: 
48491: struct JSRopeBufferInfo {
48491:     /* Number of jschars we can hold, not including null terminator. */
48491:     size_t capacity;
48491: };
48491: 
54160: /* Forward declaration for friending. */
54160: namespace js { namespace mjit {
54160:     class Compiler;
54160: }}
54160: 
    1: /*
 4718:  * The GC-thing "string" type.
    1:  *
48491:  * In FLAT strings, the mChars field  points to a flat character array owned by
48491:  * its GC-thing descriptor. The array is terminated at index length by a zero
48491:  * character and the size of the array in bytes is
48491:  * (length + 1) * sizeof(jschar). The terminator is purely a backstop, in case
48491:  * the chars pointer flows out to native code that requires \u0000 termination.
 4718:  *
29366:  * A flat string with the ATOMIZED flag means that the string is hashed as
14755:  * an atom. This flag is used to avoid re-hashing the already-atomized string.
10573:  *
48491:  * A flat string with the MUTABLE flag means that the string may change into a
48491:  * dependent string as part of an optimization with js_ConcatStrings. Flat
48491:  * strings without the MUTABLE flag can be safely accessed by multiple threads.
48491:  *
48491:  * When the string is DEPENDENT, the string depends on characters of another
29366:  * string strongly referenced by the mBase field. The base member may point to
29366:  * another dependent string if chars() has not been called yet.
 4718:  *
48491:  * To optimize js_ConcatStrings and some other cases, we lazily concatenate
48491:  * strings when possible, creating concatenation trees, a.k.a. ropes. A string
48491:  * is an INTERIOR_NODE if it is a non-root, non-leaf node in a rope, and a
48491:  * string is a TOP_NODE if it is the root of a rope. In order to meet API
48491:  * requirements, chars() is not allowed to fail, so we build ropes so that they
48491:  * form a well-defined tree structure, and the top node of every rope contains
48491:  * an (almost) empty buffer that is large enough to contain the entire string.
48491:  * Whenever chars() is called on a rope, it traverses its tree and fills that
48491:  * buffer in, and when concatenating strings, we reuse these empty buffers
48491:  * whenever possible, so that we can build a string through concatenation in
48491:  * linear time, and have relatively few malloc calls when doing so.
48491:  *
29366:  * NB: Always use the length() and chars() accessor methods.
    1:  */
    1: struct JSString {
37741:     friend class js::TraceRecorder;
54160:     friend class js::mjit::Compiler;
29366: 
29366:     friend JSAtom *
29366:     js_AtomizeString(JSContext *cx, JSString *str, uintN flags);
54707:  public:
48610:     /*
48610:      * Not private because we want to be able to use static
48610:      * initializers for them. Don't use these directly!
48610:      */
48563:     size_t                          mLengthAndFlags;  /* in all strings */
48491:     union {
48562:         jschar                      *mChars; /* in flat and dependent strings */
48491:         JSString                    *mLeft;  /* in rope interior and top nodes */
48491:     };
48563:     union {
48610:         /*
48610:          * We may keep more than 4 inline chars, but 4 is necessary for all of
48610:          * our static initialization.
48610:          */
48610:         jschar                      mInlineStorage[4]; /* In short strings. */
48610:         struct {
48610:             union {
48563:                 size_t              mCapacity; /* in mutable flat strings (optional) */
48563:                 JSString            *mParent; /* in rope interior nodes */
48563:                 JSRopeBufferInfo    *mBufferWithInfo; /* in rope top nodes */
48563:             };
48491:             union {
48491:                 JSString            *mBase;  /* in dependent strings */
48491:                 JSString            *mRight; /* in rope interior and top nodes */
    1:             };
48610:         } e;
48610:     };
    1: 
    1:     /*
48491:      * The mLengthAndFlags field in string headers has data arranged in the
48491:      * following way:
29366:      *
48491:      * [ length (bits 4-31) ][ flags (bits 2-3) ][ type (bits 0-1) ]
48491:      *
48491:      * The length is packed in mLengthAndFlags, even in string types that don't
48491:      * need 3 other fields, to make the length check simpler.
48491:      *
48491:      * When the string type is FLAT, the flags can contain ATOMIZED or MUTABLE.
48491:      * When the string type is INTERIOR_NODE or TOP_NODE, the flags area is
48491:      * used to store the rope traversal count.
    1:      */
48491:     static const size_t FLAT =          0;
48491:     static const size_t DEPENDENT =     1;
48491:     static const size_t INTERIOR_NODE = 2;
48491:     static const size_t TOP_NODE =      3;
48491: 
48491:     /* Rope/non-rope can be checked by checking one bit. */
48491:     static const size_t ROPE_BIT = JSSTRING_BIT(1);
48491: 
48491:     static const size_t ATOMIZED = JSSTRING_BIT(2);
48491:     static const size_t MUTABLE = JSSTRING_BIT(3);
48491: 
48491:     static const size_t FLAGS_LENGTH_SHIFT = 4;
48491: 
48491:     static const size_t ROPE_TRAVERSAL_COUNT_SHIFT = 2;
48491:     static const size_t ROPE_TRAVERSAL_COUNT_MASK = JSSTRING_BITMASK(4) -
48491:                                                     JSSTRING_BITMASK(2);
48491:     static const size_t ROPE_TRAVERSAL_COUNT_UNIT =
48491:                                 (1 << ROPE_TRAVERSAL_COUNT_SHIFT);
48491: 
48491:     static const size_t TYPE_MASK = JSSTRING_BITMASK(2);
54160:     static const size_t TYPE_FLAGS_MASK = JSSTRING_BITMASK(4);
 4718: 
36420:     inline bool hasFlag(size_t flag) const {
48491:         return (mLengthAndFlags & flag) != 0;
29366:     }
 4718: 
54707:     inline js::gc::Cell *asCell() {
54707:         return reinterpret_cast<js::gc::Cell *>(this);
54707:     }
54707:     
54707:     inline js::gc::FreeCell *asFreeCell() {
54707:         return reinterpret_cast<js::gc::FreeCell *>(this);
54707:     }
54707: 
56388:     inline void checkInteriorParent(int addr) {
56388:         if (isInteriorNode() && e.mParent == NULL)
56388:             JS_CRASH(addr);
56388:     }
56388: 
56388:     inline void checkCompartment(JSContext *cx, int addr);
56388: 
36382:     /*
36382:      * Generous but sane length bound; the "-1" is there for comptibility with
36382:      * OOM tests.
36382:      */
36382:     static const size_t MAX_LENGTH = (1 << 28) - 1;
27471: 
48491:     inline size_t type() const {
48491:         return mLengthAndFlags & TYPE_MASK;
48491:     }
48491: 
48516:     JS_ALWAYS_INLINE bool isDependent() const {
48491:         return type() == DEPENDENT;
29366:     }
27471: 
48516:     JS_ALWAYS_INLINE bool isFlat() const {
48491:         return type() == FLAT;
29366:     }
27471: 
36420:     inline bool isMutable() const {
48491:         return isFlat() && hasFlag(MUTABLE);
48491:     }
48491: 
48491:     inline bool isRope() const {
48491:         return hasFlag(ROPE_BIT);
29366:     }
 4718: 
48516:     JS_ALWAYS_INLINE bool isAtomized() const {
48491:         return isFlat() && hasFlag(ATOMIZED);
48491:     }
48491: 
48491:     inline bool isInteriorNode() const {
48491:         return type() == INTERIOR_NODE;
48491:     }
48491: 
48491:     inline bool isTopNode() const {
48491:         return type() == TOP_NODE;
29366:     }
10444: 
48516:     JS_ALWAYS_INLINE jschar *chars() {
48562:         if (JS_UNLIKELY(isRope()))
48491:             flatten();
48562:         return mChars;
29366:     }
29366: 
48516:     JS_ALWAYS_INLINE size_t length() const {
48491:         return mLengthAndFlags >> FLAGS_LENGTH_SHIFT;
29366:     }
29366: 
48516:     JS_ALWAYS_INLINE bool empty() const {
29366:         return length() == 0;
29366:     }
29366: 
48516:     JS_ALWAYS_INLINE void getCharsAndLength(const jschar *&chars, size_t &length) {
35470:         chars = this->chars();
35470:         length = this->length();
29366:     }
29366: 
48516:     JS_ALWAYS_INLINE void getCharsAndEnd(const jschar *&chars, const jschar *&end) {
35470:         end = length() + (chars = this->chars());
29366:     }
29366: 
48563:     JS_ALWAYS_INLINE jschar *inlineStorage() {
48563:         JS_ASSERT(isFlat());
48563:         return mInlineStorage;
48563:     }
48563: 
29366:     /* Specific flat string initializer and accessor methods. */
48516:     JS_ALWAYS_INLINE void initFlat(jschar *chars, size_t length) {
29366:         JS_ASSERT(length <= MAX_LENGTH);
54716:         JS_ASSERT(!isStatic(this));
48610:         e.mBase = NULL;
48610:         e.mCapacity = 0;
48491:         mLengthAndFlags = (length << FLAGS_LENGTH_SHIFT) | FLAT;
48491:         mChars = chars;
56388:         checkInteriorParent(0x90);
48491:     }
48491: 
48516:     JS_ALWAYS_INLINE void initFlatMutable(jschar *chars, size_t length, size_t cap) {
48491:         JS_ASSERT(length <= MAX_LENGTH);
54716:         JS_ASSERT(!isStatic(this));
48610:         e.mBase = NULL;
48610:         e.mCapacity = cap;
48491:         mLengthAndFlags = (length << FLAGS_LENGTH_SHIFT) | FLAT | MUTABLE;
29366:         mChars = chars;
56388:         checkInteriorParent(0x94);
29366:     }
29366: 
48516:     JS_ALWAYS_INLINE jschar *flatChars() const {
29366:         JS_ASSERT(isFlat());
29366:         return mChars;
29366:     }
29366: 
48516:     JS_ALWAYS_INLINE size_t flatLength() const {
29366:         JS_ASSERT(isFlat());
35470:         return length();
29366:     }
10444: 
48516:     JS_ALWAYS_INLINE size_t flatCapacity() const {
48491:         JS_ASSERT(isFlat());
48610:         return e.mCapacity;
48491:     }
48491: 
10573:     /*
29366:      * Methods to manipulate atomized and mutable flags of flat strings. It is
29366:      * safe to use these without extra locking due to the following properties:
10573:      *
29366:      *   * We do not have a flatClearAtomized method, as a string remains
29366:      *     atomized until the GC collects it.
10573:      *
29366:      *   * A thread may call flatSetMutable only when it is the only
29366:      *     thread accessing the string until a later call to
29366:      *     flatClearMutable.
10573:      *
29366:      *   * Multiple threads can call flatClearMutable but the function actually
29366:      *     clears the mutable flag only when the flag is set -- in which case
29366:      *     only one thread can access the string (see previous property).
10573:      *
29366:      * Thus, when multiple threads access the string, JSString::flatSetAtomized
48491:      * is the only function that can update the mLengthAndFlags field of the
48491:      * string by changing the mutable bit from 0 to 1. We call the method only
48491:      * after the string has been hashed. When some threads in js_ValueToStringId
48491:      * see that the flag is set, it knows that the string was atomized.
10573:      *
29366:      * On the other hand, if the thread sees that the flag is unset, it could
29366:      * be seeing a stale value when another thread has just atomized the string
29366:      * and set the flag. But this can lead only to an extra call to
29366:      * js_AtomizeString. This function would find that the string was already
29366:      * hashed and return it with the atomized bit set.
10573:      */
36420:     inline void flatSetAtomized() {
48491:         JS_ASSERT(isFlat());
54716:         JS_ASSERT(!isStatic(this));
48491:         JS_ATOMIC_SET_MASK((jsword *)&mLengthAndFlags, ATOMIZED);
56388:         checkInteriorParent(0x98);
29366:     }
10573: 
36420:     inline void flatSetMutable() {
48491:         JS_ASSERT(isFlat());
48491:         JS_ASSERT(!isAtomized());
48491:         mLengthAndFlags |= MUTABLE;
56388:         checkInteriorParent(0x9c);
29366:     }
 4718: 
36420:     inline void flatClearMutable() {
29366:         JS_ASSERT(isFlat());
54716: 
54716:         /*
54716:          * We cannot eliminate the flag check before writing to mLengthAndFlags as
54716:          * static strings may reside in write-protected memory. See bug 599481.
54716:          */
54716:         if (mLengthAndFlags & MUTABLE)
48491:             mLengthAndFlags &= ~MUTABLE;
56388:         checkInteriorParent(0xa0);
29366:     }
 4718: 
48562:     /*
48562:      * The chars pointer should point somewhere inside the buffer owned by bstr.
48562:      * The caller still needs to pass bstr for GC purposes.
48562:      */
48562:     inline void initDependent(JSString *bstr, jschar *chars, size_t len) {
35470:         JS_ASSERT(len <= MAX_LENGTH);
54716:         JS_ASSERT(!isStatic(this));
48610:         e.mParent = NULL;
48562:         mChars = chars;
48491:         mLengthAndFlags = DEPENDENT | (len << FLAGS_LENGTH_SHIFT);
48610:         e.mBase = bstr;
56388:         checkInteriorParent(0xa4);
29366:     }
    1: 
36420:     inline JSString *dependentBase() const {
29366:         JS_ASSERT(isDependent());
48610:         return e.mBase;
29366:     }
    1: 
48516:     JS_ALWAYS_INLINE jschar *dependentChars() {
48562:         return mChars;
29366:     }
 4718: 
36420:     inline size_t dependentLength() const {
29366:         JS_ASSERT(isDependent());
35470:         return length();
29366:     }
32607: 
48491:     /* Rope-related initializers and accessors. */
48491:     inline void initTopNode(JSString *left, JSString *right, size_t len,
48491:                             JSRopeBufferInfo *buf) {
48491:         JS_ASSERT(left->length() + right->length() <= MAX_LENGTH);
54716:         JS_ASSERT(!isStatic(this));
48491:         mLengthAndFlags = TOP_NODE | (len << FLAGS_LENGTH_SHIFT);
48491:         mLeft = left;
48610:         e.mRight = right;
48610:         e.mBufferWithInfo = buf;
56388:         checkInteriorParent(0xa8);
48491:     }
48491: 
48491:     inline void convertToInteriorNode(JSString *parent) {
48491:         JS_ASSERT(isTopNode());
56388:         if (parent == NULL)
56388:             JS_CRASH(0x80);
48610:         e.mParent = parent;
48491:         mLengthAndFlags = INTERIOR_NODE | (length() << FLAGS_LENGTH_SHIFT);
56388:         checkInteriorParent(0xac);
48491:     }
48491: 
48491:     inline JSString *interiorNodeParent() const {
48491:         JS_ASSERT(isInteriorNode());
48610:         return e.mParent;
48491:     }
48491: 
48491:     inline JSString *ropeLeft() const {
48491:         JS_ASSERT(isRope());
48491:         return mLeft;
48491:     }
48491: 
48491:     inline JSString *ropeRight() const {
48491:         JS_ASSERT(isRope());
48610:         return e.mRight;
48491:     }
48491: 
48491:     inline size_t topNodeCapacity() const {
48491:         JS_ASSERT(isTopNode());
48610:         return e.mBufferWithInfo->capacity;
48491:     }
48491: 
48491:     inline JSRopeBufferInfo *topNodeBuffer() const {
48491:         JS_ASSERT(isTopNode());
48610:         return e.mBufferWithInfo;
48491:     }
48491: 
48491:     inline void nullifyTopNodeBuffer() {
48491:         JS_ASSERT(isTopNode());
56388:         if (!isTopNode())
56388:             JS_CRASH(0x84);
48610:         e.mBufferWithInfo = NULL;
56388:         checkInteriorParent(0xb0);
48491:     }
48491: 
48491:     /*
48491:      * When flattening a rope, we need to convert a rope node to a dependent
48491:      * string in two separate parts instead of calling initDependent.
48491:      */
48562:     inline void startTraversalConversion(jschar *chars, size_t offset) {
48491:         JS_ASSERT(isInteriorNode());
48562:         mChars = chars + offset;
48491:     }    
48491: 
48562:     inline void finishTraversalConversion(JSString *base, jschar *chars,
48562:                                           size_t end) {
48491:         JS_ASSERT(isInteriorNode());
48491:         /* Note that setting flags also clears the traversal count. */
48491:         mLengthAndFlags = JSString::DEPENDENT |
48562:             ((chars + end - mChars) << JSString::FLAGS_LENGTH_SHIFT);
48610:         e.mBase = base;
56388:         checkInteriorParent(0xb4);
48491:     }
48491: 
48491:     inline void ropeClearTraversalCount() {
48491:         JS_ASSERT(isRope());
48491:         mLengthAndFlags &= ~ROPE_TRAVERSAL_COUNT_MASK;
56388:         checkInteriorParent(0xb8);
48491:     }
48491: 
48491:     inline size_t ropeTraversalCount() const {
48491:         JS_ASSERT(isRope());
48491:         return (mLengthAndFlags & ROPE_TRAVERSAL_COUNT_MASK) >>
48491:                 ROPE_TRAVERSAL_COUNT_SHIFT;
48491:     }
48491: 
48491:     inline void ropeIncrementTraversalCount() {
48536:         JS_ASSERT(isRope());
48491:         mLengthAndFlags += ROPE_TRAVERSAL_COUNT_UNIT;
56388:         checkInteriorParent(0xbc);
48491:     }
48491: 
48491:     inline bool ensureNotDependent(JSContext *cx) {
48491:         return !isDependent() || undepend(cx);
48491:     }
48491: 
48491:     inline void ensureNotRope() {
48491:         if (isRope())
48491:             flatten();
48491:     }
48491: 
48491:     const jschar *undepend(JSContext *cx);
48491: 
48491:     /* By design, this is not allowed to fail. */
48491:     void flatten();
48491: 
48610:     typedef uint8 SmallChar;
48610: 
48610:     static inline bool fitsInSmallChar(jschar c) {
48610:         return c < SMALL_CHAR_LIMIT && toSmallChar[c] != INVALID_SMALL_CHAR;
48610:     }
48610: 
32734:     static inline bool isUnitString(void *ptr) {
32734:         jsuword delta = reinterpret_cast<jsuword>(ptr) -
32734:                         reinterpret_cast<jsuword>(unitStringTable);
32734:         if (delta >= UNIT_STRING_LIMIT * sizeof(JSString))
32734:             return false;
32734: 
32734:         /* If ptr points inside the static array, it must be well-aligned. */
32734:         JS_ASSERT(delta % sizeof(JSString) == 0);
32734:         return true;
32702:     }
32702: 
48610:     static inline bool isLength2String(void *ptr) {
32734:         jsuword delta = reinterpret_cast<jsuword>(ptr) -
48610:                         reinterpret_cast<jsuword>(length2StringTable);
48610:         if (delta >= NUM_SMALL_CHARS * NUM_SMALL_CHARS * sizeof(JSString))
48610:             return false;
48610: 
48610:         /* If ptr points inside the static array, it must be well-aligned. */
48610:         JS_ASSERT(delta % sizeof(JSString) == 0);
48610:         return true;
48610:     }
48610: 
48610:     static inline bool isHundredString(void *ptr) {
48610:         jsuword delta = reinterpret_cast<jsuword>(ptr) -
48610:                         reinterpret_cast<jsuword>(hundredStringTable);
48610:         if (delta >= NUM_HUNDRED_STRINGS * sizeof(JSString))
32734:             return false;
32734: 
32734:         /* If ptr points inside the static array, it must be well-aligned. */
32734:         JS_ASSERT(delta % sizeof(JSString) == 0);
32734:         return true;
32702:     }
32702: 
32734:     static inline bool isStatic(void *ptr) {
48610:         return isUnitString(ptr) || isLength2String(ptr) || isHundredString(ptr);
32674:     }
32674: 
34026: #ifdef __SUNPRO_CC
51116: #pragma align 8 (__1cIJSStringPunitStringTable_, __1cIJSStringSlength2StringTable_, __1cIJSStringShundredStringTable_)
34026: #endif
34026: 
48610:     static const SmallChar INVALID_SMALL_CHAR = -1;
48610: 
54716:     static const jschar fromSmallChar[];
54716:     static const SmallChar toSmallChar[];
54716:     static const JSString unitStringTable[];
54716:     static const JSString length2StringTable[];
54716:     static const JSString hundredStringTable[];
48610:     /*
48610:      * Since int strings can be unit strings, length-2 strings, or hundred
48610:      * strings, we keep a table to map from integer to the correct string.
48610:      */
54716:     static const JSString *const intStringTable[];
48610:     static const char deflatedIntStringTable[];
37696:     static const char deflatedUnitStringTable[];
48610:     static const char deflatedLength2StringTable[];
32682: 
32674:     static JSString *unitString(jschar c);
32607:     static JSString *getUnitString(JSContext *cx, JSString *str, size_t index);
48610:     static JSString *length2String(jschar c1, jschar c2);
32686:     static JSString *intString(jsint i);
54707:     
54707:     JS_ALWAYS_INLINE void finalize(JSContext *cx, unsigned thingKind);
29366: };
    1: 
48491: /*
48563:  * Short strings should be created in cases where it's worthwhile to avoid
48563:  * mallocing the string buffer for a small string. We keep 2 string headers'
48563:  * worth of space in short strings so that more strings can be stored this way.
48563:  */
54707: struct JSShortString : js::gc::Cell {
48563:     JSString mHeader;
48563:     JSString mDummy;
48563: 
48563:     /*
48563:      * Set the length of the string, and return a buffer for the caller to write
48563:      * to. This buffer must be written immediately, and should not be modified
48563:      * afterward.
48563:      */
48563:     inline jschar *init(size_t length) {
48563:         JS_ASSERT(length <= MAX_SHORT_STRING_LENGTH);
48563:         mHeader.initFlat(mHeader.inlineStorage(), length);
48563:         return mHeader.inlineStorage();
48563:     }
48563: 
48563:     inline void resetLength(size_t length) {
48563:         mHeader.initFlat(mHeader.flatChars(), length);
48563:     }
48563: 
48563:     inline JSString *header() {
48563:         return &mHeader;
48563:     }
48563: 
48563:     static const size_t MAX_SHORT_STRING_LENGTH =
48563:             ((sizeof(JSString) + 2 * sizeof(size_t)) / sizeof(jschar)) - 1;
48563: 
48563:     static inline bool fitsIntoShortString(size_t length) {
48563:         return length <= MAX_SHORT_STRING_LENGTH;
48563:     }
54707:     
54707:     JS_ALWAYS_INLINE void finalize(JSContext *cx, unsigned thingKind);
48563: };
48563: 
48563: /*
48563:  * We're doing some tricks to give us more space for short strings, so make
48563:  * sure that space is ordered in the way we expect.
48563:  */
48563: JS_STATIC_ASSERT(offsetof(JSString, mInlineStorage) == 2 * sizeof(void *));
48563: JS_STATIC_ASSERT(offsetof(JSShortString, mDummy) == sizeof(JSString));
48563: JS_STATIC_ASSERT(offsetof(JSString, mInlineStorage) +
48563:                  sizeof(jschar) * (JSShortString::MAX_SHORT_STRING_LENGTH + 1) ==
48563:                  sizeof(JSShortString));
48563: 
48563: /*
48491:  * An iterator that iterates through all nodes in a rope (the top node, the
48491:  * interior nodes, and the leaves) without writing to any of the nodes.
48491:  *
48491:  * It is safe to iterate through a rope in this way, even when something else is
48491:  * already iterating through it.
48491:  *
48491:  * To use, pass any node of the rope into the constructor. The first call should
48491:  * be to init, which returns the first node, and each subsequent call should
48491:  * be to next. NULL is returned when there are no more nodes to return.
48491:  */
48491: class JSRopeNodeIterator {
48491:   private:
48491:     JSString *mStr;
48491:     size_t mUsedFlags;
48491: 
48491:     static const size_t DONE_LEFT = 0x1;
48491:     static const size_t DONE_RIGHT = 0x2;
48491: 
48491:   public:
48609:     JSRopeNodeIterator(JSString *str)
48609:       : mUsedFlags(0)
48609:     {
48491:         mStr = str;
48491:     }
48491:     
48491:     JSString *init() {
48491:         /* If we were constructed with a non-rope string, just return that. */
48491:         if (!mStr->isRope()) {
48491:             JSString *oldStr = mStr;
48491:             mStr = NULL;
48491:             return oldStr;
48491:         }
48491:         /* Move to the farthest-left leaf in the rope. */
48491:         while (mStr->isInteriorNode())
48491:             mStr = mStr->interiorNodeParent();
48491:         while (mStr->ropeLeft()->isInteriorNode())
48491:             mStr = mStr->ropeLeft();
48609:         JS_ASSERT(mUsedFlags == 0);
48491:         return mStr;
48491:     }
48491: 
48491:     JSString *next() {
48491:         if (!mStr)
48491:             return NULL;
48491:         if (!mStr->ropeLeft()->isInteriorNode() && !(mUsedFlags & DONE_LEFT)) {
48491:             mUsedFlags |= DONE_LEFT;
48491:             return mStr->ropeLeft();
48491:         }
48491:         if (!mStr->ropeRight()->isInteriorNode() && !(mUsedFlags & DONE_RIGHT)) {
48491:             mUsedFlags |= DONE_RIGHT;
48491:             return mStr->ropeRight();
48491:         }
48491:         if (mStr->ropeRight()->isInteriorNode()) {
48491:             /*
48491:              * If we have a right child, go right once, then left as far as
48491:              * possible.
48491:              */
48491:             mStr = mStr->ropeRight();
48491:             while (mStr->ropeLeft()->isInteriorNode())
48491:                 mStr = mStr->ropeLeft();
48491:         } else {
48491:             /*
48491:              * If we have no right child, follow our parent until we move
48491:              * up-right.
48491:              */
48491:             JSString *prev;
48491:             do {
48491:                 prev = mStr;
48491:                 /* Set the string to NULL if we reach the end of the tree. */
48491:                 mStr = mStr->isInteriorNode() ? mStr->interiorNodeParent() : NULL;
48491:             } while (mStr && mStr->ropeRight() == prev);
48491:         }
48491:         mUsedFlags = 0;
48491:         return mStr;
48491:     }
48491: };
48491: 
48536: /*
48536:  * An iterator that returns the leaves of a rope (which hold the actual string
48536:  * data) in order. The usage is the same as JSRopeNodeIterator.
48536:  */
48536: class JSRopeLeafIterator {
48536:   private:
48536:     JSRopeNodeIterator mNodeIterator;
48536: 
48536:   public:
48536: 
48536:     JSRopeLeafIterator(JSString *topNode) :
48536:         mNodeIterator(topNode) {
48536:         JS_ASSERT(topNode->isTopNode());
48536:     }
48536: 
48536:     inline JSString *init() {
48536:         JSString *str = mNodeIterator.init();
48536:         while (str->isRope()) {
48536:             str = mNodeIterator.next();
48536:             JS_ASSERT(str);
48536:         }
48536:         return str;
48536:     }
48536: 
48536:     inline JSString *next() {
48536:         JSString *str;
48536:         do {
48536:             str = mNodeIterator.next();
48536:         } while (str && str->isRope());
48536:         return str;
48536:     }
48536: };
48536: 
48536: class JSRopeBuilder {
51460:     JSContext   * const cx;
48536:     JSString    *mStr;
48536: 
48536:   public:
48536:     JSRopeBuilder(JSContext *cx);
48536: 
51460:     inline bool append(JSString *str) {
48536:         mStr = js_ConcatStrings(cx, mStr, str);
51460:         return !!mStr;
48536:     }
48536: 
48536:     inline JSString *getStr() {
48536:         return mStr;
48536:     }
48536: };
48536:      
48491: JS_STATIC_ASSERT(JSString::INTERIOR_NODE & JSString::ROPE_BIT);
48491: JS_STATIC_ASSERT(JSString::TOP_NODE & JSString::ROPE_BIT);
48491: 
48491: JS_STATIC_ASSERT(((JSString::MAX_LENGTH << JSString::FLAGS_LENGTH_SHIFT) >>
48491:                    JSString::FLAGS_LENGTH_SHIFT) == JSString::MAX_LENGTH);
48491: 
    1: extern const jschar *
    1: js_GetStringChars(JSContext *cx, JSString *str);
    1: 
    1: extern const jschar *
    1: js_UndependString(JSContext *cx, JSString *str);
    1: 
 4718: extern JSBool
 4718: js_MakeStringImmutable(JSContext *cx, JSString *str);
 4718: 
18703: extern JSString * JS_FASTCALL
18703: js_toLowerCase(JSContext *cx, JSString *str);
18703: 
18703: extern JSString * JS_FASTCALL
18703: js_toUpperCase(JSContext *cx, JSString *str);
18703: 
    1: struct JSSubString {
    1:     size_t          length;
    1:     const jschar    *chars;
    1: };
    1: 
    1: extern jschar      js_empty_ucstr[];
    1: extern JSSubString js_EmptySubString;
    1: 
    1: /* Unicode character attribute lookup tables. */
    1: extern const uint8 js_X[];
    1: extern const uint8 js_Y[];
    1: extern const uint32 js_A[];
    1: 
    1: /* Enumerated Unicode general category types. */
    1: typedef enum JSCharType {
    1:     JSCT_UNASSIGNED             = 0,
    1:     JSCT_UPPERCASE_LETTER       = 1,
    1:     JSCT_LOWERCASE_LETTER       = 2,
    1:     JSCT_TITLECASE_LETTER       = 3,
    1:     JSCT_MODIFIER_LETTER        = 4,
    1:     JSCT_OTHER_LETTER           = 5,
    1:     JSCT_NON_SPACING_MARK       = 6,
    1:     JSCT_ENCLOSING_MARK         = 7,
    1:     JSCT_COMBINING_SPACING_MARK = 8,
    1:     JSCT_DECIMAL_DIGIT_NUMBER   = 9,
    1:     JSCT_LETTER_NUMBER          = 10,
    1:     JSCT_OTHER_NUMBER           = 11,
    1:     JSCT_SPACE_SEPARATOR        = 12,
    1:     JSCT_LINE_SEPARATOR         = 13,
    1:     JSCT_PARAGRAPH_SEPARATOR    = 14,
    1:     JSCT_CONTROL                = 15,
    1:     JSCT_FORMAT                 = 16,
    1:     JSCT_PRIVATE_USE            = 18,
    1:     JSCT_SURROGATE              = 19,
    1:     JSCT_DASH_PUNCTUATION       = 20,
    1:     JSCT_START_PUNCTUATION      = 21,
    1:     JSCT_END_PUNCTUATION        = 22,
    1:     JSCT_CONNECTOR_PUNCTUATION  = 23,
    1:     JSCT_OTHER_PUNCTUATION      = 24,
    1:     JSCT_MATH_SYMBOL            = 25,
    1:     JSCT_CURRENCY_SYMBOL        = 26,
    1:     JSCT_MODIFIER_SYMBOL        = 27,
    1:     JSCT_OTHER_SYMBOL           = 28
    1: } JSCharType;
    1: 
    1: /* Character classifying and mapping macros, based on java.lang.Character. */
    1: #define JS_CCODE(c)     (js_A[js_Y[(js_X[(uint16)(c)>>6]<<6)|((c)&0x3F)]])
    1: #define JS_CTYPE(c)     (JS_CCODE(c) & 0x1F)
    1: 
    1: #define JS_ISALPHA(c)   ((((1 << JSCT_UPPERCASE_LETTER) |                     \
    1:                            (1 << JSCT_LOWERCASE_LETTER) |                     \
    1:                            (1 << JSCT_TITLECASE_LETTER) |                     \
    1:                            (1 << JSCT_MODIFIER_LETTER) |                      \
    1:                            (1 << JSCT_OTHER_LETTER))                          \
    1:                           >> JS_CTYPE(c)) & 1)
    1: 
    1: #define JS_ISALNUM(c)   ((((1 << JSCT_UPPERCASE_LETTER) |                     \
    1:                            (1 << JSCT_LOWERCASE_LETTER) |                     \
    1:                            (1 << JSCT_TITLECASE_LETTER) |                     \
    1:                            (1 << JSCT_MODIFIER_LETTER) |                      \
    1:                            (1 << JSCT_OTHER_LETTER) |                         \
    1:                            (1 << JSCT_DECIMAL_DIGIT_NUMBER))                  \
    1:                           >> JS_CTYPE(c)) & 1)
    1: 
    1: /* A unicode letter, suitable for use in an identifier. */
    1: #define JS_ISLETTER(c)   ((((1 << JSCT_UPPERCASE_LETTER) |                    \
    1:                             (1 << JSCT_LOWERCASE_LETTER) |                    \
    1:                             (1 << JSCT_TITLECASE_LETTER) |                    \
    1:                             (1 << JSCT_MODIFIER_LETTER) |                     \
    1:                             (1 << JSCT_OTHER_LETTER) |                        \
    1:                             (1 << JSCT_LETTER_NUMBER))                        \
    1:                            >> JS_CTYPE(c)) & 1)
    1: 
    1: /*
    1:  * 'IdentifierPart' from ECMA grammar, is Unicode letter or combining mark or
    1:  * digit or connector punctuation.
    1:  */
    1: #define JS_ISIDPART(c)  ((((1 << JSCT_UPPERCASE_LETTER) |                     \
    1:                            (1 << JSCT_LOWERCASE_LETTER) |                     \
    1:                            (1 << JSCT_TITLECASE_LETTER) |                     \
    1:                            (1 << JSCT_MODIFIER_LETTER) |                      \
    1:                            (1 << JSCT_OTHER_LETTER) |                         \
    1:                            (1 << JSCT_LETTER_NUMBER) |                        \
    1:                            (1 << JSCT_NON_SPACING_MARK) |                     \
    1:                            (1 << JSCT_COMBINING_SPACING_MARK) |               \
    1:                            (1 << JSCT_DECIMAL_DIGIT_NUMBER) |                 \
    1:                            (1 << JSCT_CONNECTOR_PUNCTUATION))                 \
    1:                           >> JS_CTYPE(c)) & 1)
    1: 
    1: /* Unicode control-format characters, ignored in input */
    1: #define JS_ISFORMAT(c) (((1 << JSCT_FORMAT) >> JS_CTYPE(c)) & 1)
    1: 
    1: /*
30451:  * This table is used in JS_ISWORD.  The definition has external linkage to
30451:  * allow the raw table data to be used in the regular expression compiler.
    1:  */
30451: extern const bool js_alnum[];
30451: 
30451: /*
30451:  * This macro performs testing for the regular expression word class \w, which
30451:  * is defined by ECMA-262 15.10.2.6 to be [0-9A-Z_a-z].  If we want a
30451:  * Unicode-friendlier definition of "word", we should rename this macro to
30451:  * something regexp-y.
30451:  */
30451: #define JS_ISWORD(c)    ((c) < 128 && js_alnum[(c)])
    1: 
    1: #define JS_ISIDSTART(c) (JS_ISLETTER(c) || (c) == '_' || (c) == '$')
    1: #define JS_ISIDENT(c)   (JS_ISIDPART(c) || (c) == '_' || (c) == '$')
    1: 
    1: #define JS_ISXMLSPACE(c)        ((c) == ' ' || (c) == '\t' || (c) == '\r' ||  \
    1:                                  (c) == '\n')
    1: #define JS_ISXMLNSSTART(c)      ((JS_CCODE(c) & 0x00000100) || (c) == '_')
    1: #define JS_ISXMLNS(c)           ((JS_CCODE(c) & 0x00000080) || (c) == '.' ||  \
    1:                                  (c) == '-' || (c) == '_')
    1: #define JS_ISXMLNAMESTART(c)    (JS_ISXMLNSSTART(c) || (c) == ':')
    1: #define JS_ISXMLNAME(c)         (JS_ISXMLNS(c) || (c) == ':')
    1: 
    1: #define JS_ISDIGIT(c)   (JS_CTYPE(c) == JSCT_DECIMAL_DIGIT_NUMBER)
    1: 
48545: const jschar BYTE_ORDER_MARK = 0xFEFF;
48545: const jschar NO_BREAK_SPACE  = 0x00A0;
48545: 
32608: static inline bool
32608: JS_ISSPACE(jschar c)
32608: {
32614:     unsigned w = c;
32610: 
32610:     if (w < 256)
48545:         return (w <= ' ' && (w == ' ' || (9 <= w && w <= 0xD))) || w == NO_BREAK_SPACE;
32610: 
48545:     return w == BYTE_ORDER_MARK || (JS_CCODE(w) & 0x00070000) == 0x00040000;
32608: }
32608: 
    1: #define JS_ISPRINT(c)   ((c) < 128 && isprint(c))
    1: 
    1: #define JS_ISUPPER(c)   (JS_CTYPE(c) == JSCT_UPPERCASE_LETTER)
    1: #define JS_ISLOWER(c)   (JS_CTYPE(c) == JSCT_LOWERCASE_LETTER)
    1: 
    1: #define JS_TOUPPER(c)   ((jschar) ((JS_CCODE(c) & 0x00100000)                 \
    1:                                    ? (c) - ((int32)JS_CCODE(c) >> 22)         \
    1:                                    : (c)))
    1: #define JS_TOLOWER(c)   ((jschar) ((JS_CCODE(c) & 0x00200000)                 \
    1:                                    ? (c) + ((int32)JS_CCODE(c) >> 22)         \
    1:                                    : (c)))
    1: 
    1: /*
    1:  * Shorthands for ASCII (7-bit) decimal and hex conversion.
    1:  * Manually inline isdigit for performance; MSVC doesn't do this for us.
    1:  */
    1: #define JS7_ISDEC(c)    ((((unsigned)(c)) - '0') <= 9)
    1: #define JS7_UNDEC(c)    ((c) - '0')
    1: #define JS7_ISHEX(c)    ((c) < 128 && isxdigit(c))
    1: #define JS7_UNHEX(c)    (uintN)(JS7_ISDEC(c) ? (c) - '0' : 10 + tolower(c) - 'a')
    1: #define JS7_ISLET(c)    ((c) < 128 && isalpha(c))
    1: 
    1: /* Initialize the String class, returning its prototype object. */
48470: extern js::Class js_StringClass;
    1: 
40901: inline bool
40901: JSObject::isString() const
40901: {
40901:     return getClass() == &js_StringClass;
40901: }
40901: 
    1: extern JSObject *
    1: js_InitStringClass(JSContext *cx, JSObject *obj);
    1: 
    1: extern const char js_escape_str[];
    1: extern const char js_unescape_str[];
    1: extern const char js_uneval_str[];
    1: extern const char js_decodeURI_str[];
    1: extern const char js_encodeURI_str[];
    1: extern const char js_decodeURIComponent_str[];
    1: extern const char js_encodeURIComponent_str[];
    1: 
    1: /* GC-allocate a string descriptor for the given malloc-allocated chars. */
    1: extern JSString *
18040: js_NewString(JSContext *cx, jschar *chars, size_t length);
    1: 
31477: /*
31477:  * GC-allocate a string descriptor and steal the char buffer held by |cb|.
31477:  * This function takes responsibility for adding the terminating '\0' required
31477:  * by js_NewString.
31477:  */
31477: extern JSString *
31890: js_NewStringFromCharBuffer(JSContext *cx, JSCharBuffer &cb);
31477: 
    1: extern JSString *
    1: js_NewDependentString(JSContext *cx, JSString *base, size_t start,
 4076:                       size_t length);
    1: 
    1: /* Copy a counted string and GC-allocate a descriptor for it. */
    1: extern JSString *
 4076: js_NewStringCopyN(JSContext *cx, const jschar *s, size_t n);
    1: 
48563: extern JSString *
48563: js_NewStringCopyN(JSContext *cx, const char *s, size_t n);
48563: 
    1: /* Copy a C string and GC-allocate a descriptor for it. */
    1: extern JSString *
 4076: js_NewStringCopyZ(JSContext *cx, const jschar *s);
    1: 
48563: extern JSString *
48563: js_NewStringCopyZ(JSContext *cx, const char *s);
48563: 
 6117: /*
    1:  * Convert a value to a printable C string.
    1:  */
48470: typedef JSString *(*JSValueToStringFun)(JSContext *cx, const js::Value &v);
    1: 
    1: extern JS_FRIEND_API(const char *)
48470: js_ValueToPrintable(JSContext *cx, const js::Value &, JSValueToStringFun v2sfun);
    1: 
    1: #define js_ValueToPrintableString(cx,v) \
    1:     js_ValueToPrintable(cx, v, js_ValueToString)
    1: 
    1: #define js_ValueToPrintableSource(cx,v) \
    1:     js_ValueToPrintable(cx, v, js_ValueToSource)
    1: 
    1: /*
    1:  * Convert a value to a string, returning null after reporting an error,
    1:  * otherwise returning a new string reference.
    1:  */
48470: extern JSString *
48470: js_ValueToString(JSContext *cx, const js::Value &v);
    1: 
55566: namespace js {
55566: 
55566: /*
55566:  * Most code that calls js_ValueToString knows the value is (probably) not a
55566:  * string, so it does not make sense to put this inline fast path into
55566:  * js_ValueToString.
55566:  */
55566: static JS_ALWAYS_INLINE JSString *
55566: ValueToString_TestForStringInline(JSContext *cx, const Value &v)
55566: {
55566:     if (v.isString())
55566:         return v.toString();
55566:     return js_ValueToString(cx, v);
55566: }
55566: 
55566: }
55566: 
    1: /*
30023:  * This function implements E-262-3 section 9.8, toString. Convert the given
30023:  * value to a string of jschars appended to the given buffer. On error, the
30023:  * passed buffer may have partial results appended.
30023:  */
48470: extern JSBool
48470: js_ValueToCharBuffer(JSContext *cx, const js::Value &v, JSCharBuffer &cb);
30023: 
30023: /*
    1:  * Convert a value to its source expression, returning null after reporting
    1:  * an error, otherwise returning a new string reference.
    1:  */
    1: extern JS_FRIEND_API(JSString *)
48470: js_ValueToSource(JSContext *cx, const js::Value &v);
    1: 
    1: /*
 4529:  * Compute a hash function from str. The caller can call this function even if
 4529:  * str is not a GC-allocated thing.
    1:  */
 4529: extern uint32
    1: js_HashString(JSString *str);
 4529: 
 4529: /*
 4529:  * Test if strings are equal. The caller can call the function even if str1
 4529:  * or str2 are not GC-allocated things.
 4529:  */
18728: extern JSBool JS_FASTCALL
 4529: js_EqualStrings(JSString *str1, JSString *str2);
    1: 
    1: /*
    1:  * Return less than, equal to, or greater than zero depending on whether
    1:  * str1 is less than, equal to, or greater than str2.
    1:  */
20408: extern int32 JS_FASTCALL
    1: js_CompareStrings(JSString *str1, JSString *str2);
    1: 
    1: /*
    1:  * Boyer-Moore-Horspool superlinear search for pat:patlen in text:textlen.
33165:  * The patlen argument must be positive and no greater than sBMHPatLenMax.
    1:  *
    1:  * Return the index of pat in text, or -1 if not found.
    1:  */
33165: static const jsuint sBMHCharSetSize = 256; /* ISO-Latin-1 */
33165: static const jsuint sBMHPatLenMax   = 255; /* skip table element is uint8 */
33165: static const jsint  sBMHBadPattern  = -2;  /* return value if pat is not ISO-Latin-1 */
    1: 
    1: extern jsint
33165: js_BoyerMooreHorspool(const jschar *text, jsuint textlen,
33165:                       const jschar *pat, jsuint patlen);
    1: 
    1: extern size_t
    1: js_strlen(const jschar *s);
    1: 
    1: extern jschar *
    1: js_strchr(const jschar *s, jschar c);
    1: 
    1: extern jschar *
    1: js_strchr_limit(const jschar *s, jschar c, const jschar *limit);
    1: 
    1: #define js_strncpy(t, s, n)     memcpy((t), (s), (n) * sizeof(jschar))
    1: 
48563: inline void
48563: js_short_strncpy(jschar *dest, const jschar *src, size_t num)
48563: {
48563:     /*
48563:      * It isn't strictly necessary here for |num| to be small, but this function
48563:      * is currently only called on buffers for short strings.
48563:      */
48563:     JS_ASSERT(JSShortString::fitsIntoShortString(num));
48563:     for (size_t i = 0; i < num; i++)
48563:         dest[i] = src[i];
48563: }
48563: 
    1: /*
    1:  * Return s advanced past any Unicode white space characters.
    1:  */
32608: static inline const jschar *
32608: js_SkipWhiteSpace(const jschar *s, const jschar *end)
32608: {
32608:     JS_ASSERT(s <= end);
32608:     while (s != end && JS_ISSPACE(*s))
32608:         s++;
32608:     return s;
32608: }
    1: 
    1: /*
52503:  * Inflate bytes to JS chars and vice versa.  Report out of memory via cx and
52503:  * return null on error, otherwise return the jschar or byte vector that was
52503:  * JS_malloc'ed. length is updated to the length of the new string in jschars.
    1:  */
    1: extern jschar *
    1: js_InflateString(JSContext *cx, const char *bytes, size_t *length);
    1: 
    1: extern char *
    1: js_DeflateString(JSContext *cx, const jschar *chars, size_t length);
    1: 
    1: /*
    1:  * Inflate bytes to JS chars into a buffer. 'chars' must be large enough for
    1:  * 'length' jschars. The buffer is NOT null-terminated. The destination length
    1:  * must be be initialized with the buffer size and will contain on return the
40444:  * number of copied chars. Conversion behavior depends on js_CStringsAreUTF8.
    1:  */
    1: extern JSBool
    1: js_InflateStringToBuffer(JSContext *cx, const char *bytes, size_t length,
    1:                          jschar *chars, size_t *charsLength);
    1: 
    1: /*
40444:  * Same as js_InflateStringToBuffer, but always treats 'bytes' as UTF-8.
40444:  */
40444: extern JSBool
40444: js_InflateUTF8StringToBuffer(JSContext *cx, const char *bytes, size_t length,
40444:                              jschar *chars, size_t *charsLength);
40444: 
40444: /*
40444:  * Get number of bytes in the deflated sequence of characters. Behavior depends
40444:  * on js_CStringsAreUTF8.
    1:  */
    1: extern size_t
    1: js_GetDeflatedStringLength(JSContext *cx, const jschar *chars,
    1:                            size_t charsLength);
    1: 
    1: /*
40444:  * Same as js_GetDeflatedStringLength, but always treats the result as UTF-8.
40444:  */
40444: extern size_t
40444: js_GetDeflatedUTF8StringLength(JSContext *cx, const jschar *chars,
40444:                                size_t charsLength);
40444: 
40444: /*
    1:  * Deflate JS chars to bytes into a buffer. 'bytes' must be large enough for
    1:  * 'length chars. The buffer is NOT null-terminated. The destination length
    1:  * must to be initialized with the buffer size and will contain on return the
40444:  * number of copied bytes. Conversion behavior depends on js_CStringsAreUTF8.
    1:  */
    1: extern JSBool
    1: js_DeflateStringToBuffer(JSContext *cx, const jschar *chars,
    1:                          size_t charsLength, char *bytes, size_t *length);
    1: 
    1: /*
40444:  * Same as js_DeflateStringToBuffer, but always treats 'bytes' as UTF-8.
40444:  */
40444: extern JSBool
40444: js_DeflateStringToUTF8Buffer(JSContext *cx, const jschar *chars,
40444:                              size_t charsLength, char *bytes, size_t *length);
40444: 
40444: /*
    1:  * Find or create a deflated string cache entry for str that contains its
    1:  * characters chopped from Unicode code points into bytes.
    1:  */
    1: extern const char *
    1: js_GetStringBytes(JSContext *cx, JSString *str);
    1: 
18115: /* Export a few natives and a helper to other files in SpiderMonkey. */
18115: extern JSBool
48470: js_str_escape(JSContext *cx, JSObject *obj, uintN argc, js::Value *argv,
48470:               js::Value *rval);
    1: 
48676: /*
48676:  * The String.prototype.replace fast-native entry point is exported for joined
48676:  * function optimization in js{interp,tracer}.cpp.
48676:  */
48676: namespace js {
48676: extern JSBool
48676: str_replace(JSContext *cx, uintN argc, js::Value *vp);
48676: }
48676: 
18115: extern JSBool
48470: js_str_toString(JSContext *cx, uintN argc, js::Value *vp);
30443: 
49109: extern JSBool
49109: js_str_charAt(JSContext *cx, uintN argc, js::Value *vp);
49109: 
49109: extern JSBool
49109: js_str_charCodeAt(JSContext *cx, uintN argc, js::Value *vp);
49109: 
    1: /*
    1:  * Convert one UCS-4 char and write it into a UTF-8 buffer, which must be at
    1:  * least 6 bytes long.  Return the number of UTF-8 bytes of data written.
    1:  */
    1: extern int
    1: js_OneUcs4ToUtf8Char(uint8 *utf8Buffer, uint32 ucs4Char);
    1: 
    1: /*
    1:  * Write str into buffer escaping any non-printable or non-ASCII character.
    1:  * Guarantees that a NUL is at the end of the buffer. Returns the length of
    1:  * the written output, NOT including the NUL. If buffer is null, just returns
    1:  * the length of the output. If quote is not 0, it must be a single or double
    1:  * quote character that will quote the output.
    1:  *
    1:  * The function is only defined for debug builds.
    1: */
    1: #define js_PutEscapedString(buffer, bufferSize, str, quote)                   \
    1:     js_PutEscapedStringImpl(buffer, bufferSize, NULL, str, quote)
    1: 
    1: /*
    1:  * Write str into file escaping any non-printable or non-ASCII character.
    1:  * Returns the number of bytes written to file. If quote is not 0, it must
    1:  * be a single or double quote character that will quote the output.
    1:  *
    1:  * The function is only defined for debug builds.
    1: */
    1: #define js_FileEscapedString(file, str, quote)                                \
    1:     (JS_ASSERT(file), js_PutEscapedStringImpl(NULL, 0, file, str, quote))
    1: 
 4569: extern JS_FRIEND_API(size_t)
    1: js_PutEscapedStringImpl(char *buffer, size_t bufferSize, FILE *fp,
    1:                         JSString *str, uint32 quote);
    1: 
26008: extern JSBool
50489: js_String(JSContext *cx, uintN argc, js::Value *vp);
40337: 
40281: namespace js {
40281: 
40281: class DeflatedStringCache {
40281:   public:
40281:     DeflatedStringCache();
40281:     bool init();
40281:     ~DeflatedStringCache();
40281: 
40281:     void sweep(JSContext *cx);
40281:     void remove(JSString *str);
40281:     bool setBytes(JSContext *cx, JSString *str, char *bytes);
40281: 
40281:   private:
40281:     struct StringPtrHasher
40281:     {
40281:         typedef JSString *Lookup;
40281: 
42645:         static HashNumber hash(JSString *str) {
40281:             /*
40281:              * We hash only GC-allocated Strings. They are aligned on
40281:              * sizeof(JSString) boundary so we can improve hashing by stripping
40281:              * initial zeros.
40281:              */
40281:             const jsuword ALIGN_LOG = tl::FloorLog2<sizeof(JSString)>::result;
40281:             JS_STATIC_ASSERT(sizeof(JSString) == (size_t(1) << ALIGN_LOG));
40281: 
40281:             jsuword ptr = reinterpret_cast<jsuword>(str);
40281:             jsuword key = ptr >> ALIGN_LOG;
40281:             JS_ASSERT((key << ALIGN_LOG) == ptr);
42645:             return HashNumber(key);
40281:         }
40281: 
40281:         static bool match(JSString *s1, JSString *s2) {
40281:             return s1 == s2;
40281:         }
40281:     };
40281: 
40281:     typedef HashMap<JSString *, char *, StringPtrHasher, SystemAllocPolicy> Map;
40281: 
40281:     /* cx is NULL when the caller is JS_GetStringBytes(JSString *). */
40281:     char *getBytes(JSContext *cx, JSString *str);
40281: 
40281:     friend const char *
40281:     ::js_GetStringBytes(JSContext *cx, JSString *str);
40281: 
40281:     Map                 map;
40281: #ifdef JS_THREADSAFE
40281:     JSLock              *lock;
40281: #endif
40281: };
40281: 
40281: } /* namespace js */
40281: 
    1: #endif /* jsstr_h___ */
