    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla FastLoad code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brendan Eich <brendan@mozilla.org> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsFastLoadFile_h___
    1: #define nsFastLoadFile_h___
    1: 
    1: /**
    1:  * Mozilla FastLoad file format and helper types.
    1:  */
    1: 
    1: #include "prtypes.h"
    1: #include "pldhash.h"
    1: 
    1: #include "nsBinaryStream.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsDebug.h"
    1: #include "nsID.h"
    1: #include "nsMemory.h"
    1: 
    1: #include "nsIFastLoadFileControl.h"
    1: #include "nsIFastLoadService.h"
    1: #include "nsISeekableStream.h"
    1: #include "nsISupportsArray.h"
    1: 
    1: /**
    1:  * FastLoad file Object ID (OID) is an identifier for multiply and cyclicly
    1:  * connected objects in the serialized graph of all reachable objects.
    1:  *
    1:  * Holy Mixed Metaphors: JS, after Common Lisp, uses #n= to define a "sharp
    1:  * variable" naming an object that's multiply or cyclicly connected, and #n#
    1:  * to stand for a connection to an already-defined object.  We too call any
    1:  * object with multiple references "sharp", and (here it comes) any object
    1:  * with only one reference "dull".
    1:  *
    1:  * Note that only sharp objects require a mapping from OID to FastLoad file
    1:  * offset and other information.  Dull objects can be serialized _in situ_
    1:  * (where they are referenced) and deserialized when their (singular, shared)
    1:  * OID is scanned.
    1:  *
    1:  * We also compress 16-byte XPCOM IDs into 32-bit dense identifiers to save
    1:  * space.  See nsFastLoadFooter, below, for the mapping data structure used to
    1:  * compute an nsID given an NSFastLoadID.
    1:  */
    1: typedef PRUint32 NSFastLoadID;          // nsFastLoadFooter::mIDMap index
    1: typedef PRUint32 NSFastLoadOID;         // nsFastLoadFooter::mObjectMap index
    1: 
    1: /**
    1:  * A Mozilla FastLoad file is an untagged (in general) stream of objects and
    1:  * primitive-type data.  Small integers are fairly common, and could easily be
    1:  * confused for NSFastLoadIDs and NSFastLoadOIDs.  To help catch bugs where
    1:  * reader and writer code fail to match, we XOR unlikely 32-bit numbers with
    1:  * NSFastLoad*IDs when storing and fetching.  The following unlikely values are
    1:  * irrational numbers ((sqrt(5)-1)/2, sqrt(2)-1) represented in fixed point.
    1:  *
    1:  * The reader XORs, converts the ID to an index, and bounds-checks all array
    1:  * accesses that use the index.  Array access code asserts that the index is in
    1:  * bounds, and returns a dummy array element if it isn't.
    1:  */
    1: #define MFL_ID_XOR_KEY  0x9E3779B9      // key XOR'd with ID when serialized
    1: #define MFL_OID_XOR_KEY 0x6A09E667      // key XOR'd with OID when serialized
    1: 
    1: /**
    1:  * An OID can be tagged to introduce the serialized definition of the object,
    1:  * or to stand for a strong or weak reference to that object.  Thus the high
    1:  * 29 bits actually identify the object, and the low three bits tell whether
    1:  * the object is being defined or just referenced -- and via what inheritance
    1:  * chain or inner object, if necessary.
    1:  *
    1:  * The MFL_QUERY_INTERFACE_TAG bit helps us cope with aggregation and multiple
    1:  * inheritance: object identity follows the XPCOM rule, but a deserializer may
    1:  * need to query for an interface not on the primary inheritance chain ending
    1:  * in the nsISupports whose address uniquely identifies the XPCOM object being
    1:  * referenced or defined.
    1:  */
    1: #define MFL_OBJECT_TAG_BITS     3
    1: #define MFL_OBJECT_TAG_MASK     PR_BITMASK(MFL_OBJECT_TAG_BITS)
    1: 
    1: #define MFL_OBJECT_DEF_TAG      1U      // object definition follows this OID
    1: #define MFL_WEAK_REF_TAG        2U      // OID weakly refers to a prior object
    1:                                         // NB: do not confuse with nsWeakPtr!
    1: #define MFL_QUERY_INTERFACE_TAG 4U      // QI object to the ID follows this OID
    1:                                         // NB: an NSFastLoadID, not an nsIID!
    1: 
    1: /**
    1:  * The dull object identifier introduces the definition of all objects that
    1:  * have only one (necessarily strong) ref in the serialization.  The definition
    1:  * appears at the point of reference.
    1:  */
    1: #define MFL_DULL_OBJECT_OID     MFL_OBJECT_DEF_TAG
    1: 
    1: /**
    1:  * Convert an OID to an index into nsFastLoadFooter::mObjectMap.
    1:  */
    1: #define MFL_OID_TO_SHARP_INDEX(oid)     (((oid) >> MFL_OBJECT_TAG_BITS) - 1)
    1: #define MFL_SHARP_INDEX_TO_OID(index)   (((index) + 1) << MFL_OBJECT_TAG_BITS)
    1: 
    1: /**
    1:  * Magic "number" at start of a FastLoad file.  Inspired by the PNG "magic"
    1:  * string, which inspired XPCOM's typelib (.xpt) file magic.  Guaranteed to be
    1:  * corrupted by FTP-as-ASCII and other likely errors, meaningful to clued-in
    1:  * humans, and ending in ^Z to terminate erroneous text input on Windows.
    1:  */
    1: #define MFL_FILE_MAGIC          "XPCOM\nMozFASL\r\n\032"
    1: #define MFL_FILE_MAGIC_SIZE     16
    1: 
    1: #define MFL_FILE_VERSION_0      0
    1: #define MFL_FILE_VERSION_1      1000
    1: #define MFL_FILE_VERSION        5       // rev'ed to defend against unversioned
    1:                                         // XPCOM JS component fastload files
    1: 
    1: /**
    1:  * Compute Fletcher's 16-bit checksum over aLength bytes starting at aBuffer,
    1:  * with the initial accumulators seeded from *aChecksum, and final checksum
    1:  * returned in *aChecksum.  The return value is the number of unchecked bytes,
    1:  * which may be non-zero if aBuffer is misaligned or aLength is odd.  Callers
    1:  * should copy any remaining bytes to the front of the next buffer.
    1:  *
    1:  * If aLastBuffer is false, do not check any bytes remaining due to misaligned
    1:  * aBuffer or odd aLength, instead returning the remaining byte count.  But if
    1:  * aLastBuffer is true, treat aBuffer as the last buffer in the file and check
    1:  * every byte, returning 0.  Here's a read-loop checksumming sketch:
    1:  *
    1:  *  char buf[BUFSIZE];
    1:  *  PRUint32 len, rem = 0;
    1:  *  PRUint32 checksum = 0;
    1:  *
    1:  *  while (NS_SUCCEEDED(rv = Read(buf + rem, sizeof buf - rem, &len)) && len) {
    1:  *      len += rem;
    1:  *      rem = NS_AccumulateFastLoadChecksum(&checksum,
 3233:  *                                          reinterpret_cast<PRUint8*>(buf),
    1:  *                                          len,
    1:  *                                          PR_FALSE);
    1:  *      if (rem)
    1:  *          memcpy(buf, buf + len - rem, rem);
    1:  *  }
    1:  *
    1:  *  if (rem) {
    1:  *      NS_AccumulateFastLoadChecksum(&checksum,
 3233:  *                                    reinterpret_cast<PRUint8*>(buf),
    1:  *                                    rem,
    1:  *                                    PR_TRUE);
    1:  *  }
    1:  *
    1:  * After this, if NS_SUCCEEDED(rv), checksum contains a valid FastLoad sum.
    1:  */
    1: NS_COM PRUint32
    1: NS_AccumulateFastLoadChecksum(PRUint32 *aChecksum,
    1:                               const PRUint8* aBuffer,
    1:                               PRUint32 aLength,
    1:                               PRBool aLastBuffer);
    1: 
    1: NS_COM PRUint32
    1: NS_AddFastLoadChecksums(PRUint32 sum1, PRUint32 sum2, PRUint32 sum2ByteCount);
    1: 
    1: /**
    1:  * Header at the start of a FastLoad file.
    1:  */
    1: struct nsFastLoadHeader {
    1:     char        mMagic[MFL_FILE_MAGIC_SIZE];
    1:     PRUint32    mChecksum;
    1:     PRUint32    mVersion;
    1:     PRUint32    mFooterOffset;
    1:     PRUint32    mFileSize;
    1: };
    1: 
    1: /**
    1:  * Footer prefix structure (footer header, ugh), after which come arrays of
    1:  * structures or strings counted by these members.
    1:  */
    1: struct nsFastLoadFooterPrefix {
    1:     PRUint32    mNumIDs;
    1:     PRUint32    mNumSharpObjects;
    1:     PRUint32    mNumMuxedDocuments;
    1:     PRUint32    mNumDependencies;
    1: };
    1: 
    1: struct nsFastLoadSharpObjectInfo {
    1:     PRUint32    mCIDOffset;     // offset of object's NSFastLoadID and data
    1:     PRUint16    mStrongRefCnt;
    1:     PRUint16    mWeakRefCnt;    // high bit is singleton flag, see below
    1: };
    1: 
    1: #define MFL_SINGLETON_FLAG          0x8000
    1: #define MFL_WEAK_REFCNT_MASK        0x7fff
    1: 
    1: #define MFL_GET_SINGLETON_FLAG(ip)  ((ip)->mWeakRefCnt & MFL_SINGLETON_FLAG)
    1: #define MFL_GET_WEAK_REFCNT(ip)     ((ip)->mWeakRefCnt & MFL_WEAK_REFCNT_MASK)
    1: 
    1: #define MFL_SET_SINGLETON_FLAG(ip)                                            \
    1:     ((ip)->mWeakRefCnt |= MFL_SINGLETON_FLAG)
    1: #define MFL_SET_WEAK_REFCNT(ip,rc)                                            \
    1:     ((ip)->mWeakRefCnt = (((ip)->mWeakRefCnt & MFL_SINGLETON_FLAG) | (rc)))
    1: 
    1: #define MFL_BUMP_WEAK_REFCNT(ip)    (++(ip)->mWeakRefCnt)
    1: #define MFL_DROP_WEAK_REFCNT(ip)    (--(ip)->mWeakRefCnt)
    1: 
    1: struct nsFastLoadMuxedDocumentInfo {
    1:     const char* mURISpec;
    1:     PRUint32    mInitialSegmentOffset;
    1: };
    1: 
    1: // forward declarations of opaque types defined in nsFastLoadFile.cpp
    1: struct nsDocumentMapReadEntry;
    1: struct nsDocumentMapWriteEntry;
    1: 
    1: // So nsFastLoadFileUpdater can verify that its nsIObjectInputStream parameter
    1: // is an nsFastLoadFileReader.
    1: #define NS_FASTLOADFILEREADER_IID \
    1:     {0x7d37d1bb,0xcef3,0x4c5f,{0x97,0x68,0x0f,0x89,0x7f,0x1a,0xe1,0x40}}
    1: 
    1: struct nsIFastLoadFileReader : public nsISupports {
    1:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_FASTLOADFILEREADER_IID)
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsIFastLoadFileReader, NS_FASTLOADFILEREADER_IID)
    1: 
    1: /**
    1:  * Inherit from the concrete class nsBinaryInputStream, which inherits from
    1:  * abstract nsIObjectInputStream but does not implement its direct methods.
    1:  * Though the names are not as clear as I'd like, this seems to be the best
    1:  * way to share nsBinaryStream.cpp code.
    1:  */
    1: class nsFastLoadFileReader
    1:     : public nsBinaryInputStream,
    1:       public nsIFastLoadReadControl,
    1:       public nsISeekableStream,
    1:       public nsIFastLoadFileReader
    1: {
    1:   public:
33672:     nsFastLoadFileReader(nsIFile *aFile)
36799:         : mCurrentDocumentMapEntry(nsnull), mFile(aFile),
33672:           mFileLen(0), mFilePos(0), mFileMap(nsnull), mFileData(nsnull)
33672:     {
    1:         MOZ_COUNT_CTOR(nsFastLoadFileReader);
    1:     }
    1: 
    1:     virtual ~nsFastLoadFileReader() {
33884:         Close();
    1:         MOZ_COUNT_DTOR(nsFastLoadFileReader);
    1:     }
    1: 
    1:   private:
    1:     // nsISupports methods
    1:     NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:     // overridden nsIObjectInputStream methods
    1:     NS_IMETHOD ReadObject(PRBool aIsStrongRef, nsISupports* *_retval);
    1:     NS_IMETHOD ReadID(nsID *aResult);
    1: 
33672:     void SeekTo(PRInt64 aOffset) {
33672:         mFilePos = PR_MAX(0, PR_MIN(aOffset, mFileLen));
33672:         NS_ASSERTION(aOffset == mFilePos, "Attempt to seek out of bounds");
33672:     }
33672: 
    1:     // nsIFastLoadFileControl methods
    1:     NS_DECL_NSIFASTLOADFILECONTROL
    1: 
    1:     // nsIFastLoadReadControl methods
    1:     NS_DECL_NSIFASTLOADREADCONTROL
    1: 
    1:     // nsISeekableStream methods
    1:     NS_DECL_NSISEEKABLESTREAM
    1: 
    1:     // Override Read so we can demultiplex a document interleaved with others.
    1:     NS_IMETHOD Read(char* aBuffer, PRUint32 aCount, PRUint32 *aBytesRead);
    1:     nsresult ReadHeader(nsFastLoadHeader *aHeader);
    1: 
    1:     /**
    1:      * In-memory representation of an indexed nsFastLoadSharpObjectInfo record.
    1:      */
    1:     struct nsObjectMapEntry : public nsFastLoadSharpObjectInfo {
    1:         nsCOMPtr<nsISupports>   mReadObject;
    1:         PRInt64                 mSkipOffset;
    1:         PRUint16                mSaveStrongRefCnt;      // saved for an Update
    1:         PRUint16                mSaveWeakRefCnt;        // after a Read
    1:     };
    1: 
33672:     NS_IMETHODIMP ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
33672:                                PRUint32 aCount, PRUint32 *aResult);
33672: 
    1:     /**
    1:      * In-memory representation of the FastLoad file footer.
    1:      */
    1:     struct nsFastLoadFooter : public nsFastLoadFooterPrefix {
    1:         nsFastLoadFooter()
    1:           : mIDMap(nsnull),
    1:             mObjectMap(nsnull) {
    1:             mDocumentMap.ops = mURIMap.ops = nsnull;
    1:         }
    1: 
    1:         ~nsFastLoadFooter() {
    1:             delete[] mIDMap;
    1:             delete[] mObjectMap;
    1:             if (mDocumentMap.ops)
    1:                 PL_DHashTableFinish(&mDocumentMap);
    1:             if (mURIMap.ops)
    1:                 PL_DHashTableFinish(&mURIMap);
    1:         }
    1: 
    1:         // These can't be static within GetID and GetSharpObjectEntry or the
    1:         // toolchains on HP-UX 10.20's, RH 7.0, and Mac OS X all barf at link
    1:         // time ("common symbols not allowed with MY_DHLIB output format", to
    1:         // quote the OS X rev of gcc).
    1:         static nsID gDummyID;
    1:         static nsObjectMapEntry gDummySharpObjectEntry;
    1: 
    1:         const nsID& GetID(NSFastLoadID aFastId) const {
    1:             PRUint32 index = aFastId - 1;
    1:             NS_ASSERTION(index < mNumIDs, "aFastId out of range");
    1:             if (index >= mNumIDs)
    1:                 return gDummyID;
    1:             return mIDMap[index];
    1:         }
    1: 
    1:         nsObjectMapEntry&
    1:         GetSharpObjectEntry(NSFastLoadOID aOID) const {
    1:             PRUint32 index = MFL_OID_TO_SHARP_INDEX(aOID);
    1:             NS_ASSERTION(index < mNumSharpObjects, "aOID out of range");
    1:             if (index >= mNumSharpObjects)
    1:                 return gDummySharpObjectEntry;
    1:             return mObjectMap[index];
    1:         }
    1: 
    1:         // Map from dense, zero-based, uint32 NSFastLoadID to 16-byte nsID.
    1:         nsID* mIDMap;
    1: 
    1:         // Map from dense, zero-based MFL_OID_TO_SHARP_INDEX(oid) to sharp
    1:         // object offset and refcnt information.
    1:         nsObjectMapEntry* mObjectMap;
    1: 
    1:         // Map from URI spec string to nsDocumentMapReadEntry, which helps us
    1:         // demultiplex a document's objects from among the interleaved object
    1:         // stream segments in the FastLoad file.
    1:         PLDHashTable mDocumentMap;
    1: 
    1:         // Fast mapping from URI object pointer to mDocumentMap entry, valid
    1:         // only while the muxed document is loading.
    1:         PLDHashTable mURIMap;
    1: 
    1:         // List of source filename dependencies that should trigger regeneration
    1:         // of the FastLoad file.
    1:         nsCOMPtr<nsISupportsArray> mDependencies;
    1:     };
    1: 
    1:     nsresult ReadFooter(nsFastLoadFooter *aFooter);
    1:     nsresult ReadFooterPrefix(nsFastLoadFooterPrefix *aFooterPrefix);
    1:     nsresult ReadSlowID(nsID *aID);
    1:     nsresult ReadFastID(NSFastLoadID *aID);
    1:     nsresult ReadSharpObjectInfo(nsFastLoadSharpObjectInfo *aInfo);
    1:     nsresult ReadMuxedDocumentInfo(nsFastLoadMuxedDocumentInfo *aInfo);
    1:     nsresult DeserializeObject(nsISupports* *aObject);
    1: 
    1:     nsresult   Open();
    1:     NS_IMETHOD Close();
    1: 
    1:   protected:
    1:     nsFastLoadHeader mHeader;
    1:     nsFastLoadFooter mFooter;
    1: 
    1:     nsDocumentMapReadEntry* mCurrentDocumentMapEntry;
    1: 
    1:     friend class nsFastLoadFileUpdater;
33672:     nsIFile *mFile;     // .mfasl file
33672:     PRUint32 mFileLen;  // length of file
33672:     PRUint32 mFilePos;  // current position within file
33672:     PRFileMap *mFileMap;// nspr datastructure for mmap
33672:     PRUint8 *mFileData; // pointer to mmaped file
    1: };
    1: 
    1: NS_COM nsresult
22697: NS_NewFastLoadFileReader(nsIObjectInputStream* *aResult NS_OUTPARAM,
33672:                          nsIFile* aFile);
    1: 
    1: /**
    1:  * Inherit from the concrete class nsBinaryInputStream, which inherits from
    1:  * abstract nsIObjectInputStream but does not implement its direct methods.
    1:  * Though the names are not as clear as I'd like, this seems to be the best
    1:  * way to share nsBinaryStream.cpp code.
    1:  */
    1: class nsFastLoadFileWriter
    1:     : public nsBinaryOutputStream,
    1:       public nsIFastLoadWriteControl,
    1:       public nsISeekableStream
    1: {
    1:   public:
    1:     nsFastLoadFileWriter(nsIOutputStream *aStream, nsIFastLoadFileIO* aFileIO)
    1:       : mCurrentDocumentMapEntry(nsnull),
    1:         mFileIO(aFileIO)
    1:     {
    1:         SetOutputStream(aStream);
    1:         mHeader.mChecksum = 0;
    1:         mIDMap.ops = mObjectMap.ops = mDocumentMap.ops = mURIMap.ops = nsnull;
    1:         mDependencyMap.ops = nsnull;
    1:         MOZ_COUNT_CTOR(nsFastLoadFileWriter);
    1:     }
    1: 
    1:     virtual ~nsFastLoadFileWriter()
    1:     {
    1:         if (mIDMap.ops)
    1:             PL_DHashTableFinish(&mIDMap);
    1:         if (mObjectMap.ops)
    1:             PL_DHashTableFinish(&mObjectMap);
    1:         if (mDocumentMap.ops)
    1:             PL_DHashTableFinish(&mDocumentMap);
    1:         if (mURIMap.ops)
    1:             PL_DHashTableFinish(&mURIMap);
    1:         if (mDependencyMap.ops)
    1:             PL_DHashTableFinish(&mDependencyMap);
    1:         MOZ_COUNT_DTOR(nsFastLoadFileWriter);
    1:     }
    1: 
    1:   private:
    1:     // nsISupports methods
    1:     NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:     // overridden nsIObjectOutputStream methods
    1:     NS_IMETHOD WriteObject(nsISupports* aObject, PRBool aIsStrongRef);
    1:     NS_IMETHOD WriteSingleRefObject(nsISupports* aObject);
    1:     NS_IMETHOD WriteCompoundObject(nsISupports* aObject,
    1:                                    const nsIID& aIID,
    1:                                    PRBool aIsStrongRef);
    1:     NS_IMETHOD WriteID(const nsID& aID);
    1: 
    1:     // Override SetOutputStream so we can update mSeekableOutput
    1:     NS_IMETHOD SetOutputStream(nsIOutputStream* aOutputStream);
    1: 
    1:     // nsIFastLoadFileControl methods
    1:     NS_DECL_NSIFASTLOADFILECONTROL
    1: 
    1:     // nsIFastLoadWriteControl methods
    1:     NS_DECL_NSIFASTLOADWRITECONTROL
    1: 
    1:     // nsISeekableStream methods
    1:     NS_DECL_NSISEEKABLESTREAM
    1: 
    1:     nsresult MapID(const nsID& aSlowID, NSFastLoadID *aResult);
    1: 
    1:     nsresult WriteHeader(nsFastLoadHeader *aHeader);
    1:     nsresult WriteFooter();
    1:     nsresult WriteFooterPrefix(const nsFastLoadFooterPrefix& aFooterPrefix);
    1:     nsresult WriteSlowID(const nsID& aID);
    1:     nsresult WriteFastID(NSFastLoadID aID);
    1:     nsresult WriteSharpObjectInfo(const nsFastLoadSharpObjectInfo& aInfo);
    1:     nsresult WriteMuxedDocumentInfo(const nsFastLoadMuxedDocumentInfo& aInfo);
    1: 
    1:     nsresult   Init();
    1:     nsresult   Open();
    1:     NS_IMETHOD Close();
    1: 
    1:     nsresult WriteObjectCommon(nsISupports* aObject,
    1:                                PRBool aIsStrongRef,
    1:                                PRUint32 aQITag);
    1: 
20261:     static PLDHashOperator
    1:     IDMapEnumerate(PLDHashTable *aTable,
    1:                    PLDHashEntryHdr *aHdr,
    1:                    PRUint32 aNumber,
    1:                    void *aData);
    1: 
20261:     static PLDHashOperator
    1:     ObjectMapEnumerate(PLDHashTable *aTable,
    1:                        PLDHashEntryHdr *aHdr,
    1:                        PRUint32 aNumber,
    1:                        void *aData);
    1: 
20261:     static PLDHashOperator
    1:     DocumentMapEnumerate(PLDHashTable *aTable,
    1:                          PLDHashEntryHdr *aHdr,
    1:                          PRUint32 aNumber,
    1:                          void *aData);
    1: 
20261:     static PLDHashOperator
    1:     DependencyMapEnumerate(PLDHashTable *aTable,
    1:                            PLDHashEntryHdr *aHdr,
    1:                            PRUint32 aNumber,
    1:                            void *aData);
    1: 
    1:   protected:
    1:     // Kept in sync with mOutputStream to avoid repeated QI
    1:     nsCOMPtr<nsISeekableStream> mSeekableOutput;
    1: 
    1:     nsFastLoadHeader mHeader;
    1: 
    1:     PLDHashTable mIDMap;
    1:     PLDHashTable mObjectMap;
    1:     PLDHashTable mDocumentMap;
    1:     PLDHashTable mURIMap;
    1:     PLDHashTable mDependencyMap;
    1: 
    1:     nsDocumentMapWriteEntry* mCurrentDocumentMapEntry;
    1:     nsCOMPtr<nsIFastLoadFileIO> mFileIO;
    1: };
    1: 
    1: NS_COM nsresult
22697: NS_NewFastLoadFileWriter(nsIObjectOutputStream* *aResult NS_OUTPARAM,
    1:                          nsIOutputStream* aDestStream,
    1:                          nsIFastLoadFileIO* aFileIO);
    1: 
    1: /**
    1:  * Subclass of nsFastLoadFileWriter, friend of nsFastLoadFileReader which it
    1:  * wraps when a FastLoad file needs to be updated.  The wrapped reader can be
    1:  * used to demulitplex data for documents already in the FastLoad file, while
    1:  * the updater writes new data over the old footer, then writes a new footer
    1:  * that maps all data on Close.
    1:  */
    1: class nsFastLoadFileUpdater
33672:     : public nsFastLoadFileWriter
    1: {
    1:   public:
33672:     nsFastLoadFileUpdater(nsIOutputStream* aOutputStream, nsIFastLoadFileIO *aFileIO)
33672:         : nsFastLoadFileWriter(aOutputStream, aFileIO) {
    1:         MOZ_COUNT_CTOR(nsFastLoadFileUpdater);
    1:     }
    1: 
    1:     virtual ~nsFastLoadFileUpdater() {
    1:         MOZ_COUNT_DTOR(nsFastLoadFileUpdater);
    1:     }
    1: 
    1:   private:
    1:     // nsISupports methods
    1:     NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:     nsresult   Open(nsFastLoadFileReader* aReader);
    1:     NS_IMETHOD Close();
    1: 
20261:     static PLDHashOperator
    1:     CopyReadDocumentMapEntryToUpdater(PLDHashTable *aTable,
    1:                                       PLDHashEntryHdr *aHdr,
    1:                                       PRUint32 aNumber,
    1:                                       void *aData);
    1: 
    1:     friend class nsFastLoadFileReader;
    1: 
    1:   protected:
    1:     nsCOMPtr<nsIInputStream> mInputStream;
    1: 
    1:     // Kept in sync with mInputStream to avoid repeated QI
    1:     nsCOMPtr<nsISeekableStream> mSeekableInput;
    1: };
    1: 
    1: NS_COM nsresult
22697: NS_NewFastLoadFileUpdater(nsIObjectOutputStream* *aResult NS_OUTPARAM,
33672:                           nsIFastLoadFileIO* aFileIO,
    1:                           nsIObjectInputStream* aReaderAsStream);
    1: 
    1: #endif // nsFastLoadFile_h___
