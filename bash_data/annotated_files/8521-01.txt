   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: // vim:cindent:ts=2:et:sw=2:
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Steve Clark <buster@netscape.com>
   1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
   1:  *   L. David Baron <dbaron@dbaron.org>
   1:  *   IBM Corporation
   1:  *   Mats Palmgren <mats.palmgren@bredband.net>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /*
   1:  * rendering object for CSS display:block and display:list-item objects,
   1:  * also used inside table cells
   1:  */
   1: 
   1: #include "nsCOMPtr.h"
   1: #include "nsBlockFrame.h"
   1: #include "nsBlockReflowContext.h"
   1: #include "nsBlockReflowState.h"
   1: #include "nsBlockBandData.h"
   1: #include "nsBulletFrame.h"
   1: #include "nsLineBox.h"
   1: #include "nsInlineFrame.h"
   1: #include "nsLineLayout.h"
   1: #include "nsPlaceholderFrame.h"
   1: #include "nsStyleConsts.h"
   1: #include "nsFrameManager.h"
   1: #include "nsPresContext.h"
   1: #include "nsIPresShell.h"
   1: #include "nsStyleContext.h"
   1: #include "nsIView.h"
   1: #include "nsIFontMetrics.h"
   1: #include "nsHTMLParts.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsIDOMEvent.h"
   1: #include "nsGenericHTMLElement.h"
   1: #include "prprf.h"
   1: #include "nsStyleChangeList.h"
   1: #include "nsFrameSelection.h"
   1: #include "nsSpaceManager.h"
   1: #include "nsIntervalSet.h"
   1: #include "prenv.h"
   1: #include "plstr.h"
   1: #include "nsGUIEvent.h"
   1: #include "nsLayoutErrors.h"
   1: #include "nsAutoPtr.h"
   1: #include "nsIServiceManager.h"
   1: #include "nsIScrollableFrame.h"
   1: #ifdef ACCESSIBILITY
   1: #include "nsIDOMHTMLDocument.h"
   1: #include "nsIAccessibilityService.h"
   1: #endif
   1: #include "nsLayoutUtils.h"
   1: #include "nsBoxLayoutState.h"
   1: #include "nsDisplayList.h"
   1: #include "nsContentErrors.h"
 691: #include "nsCSSAnonBoxes.h"
4302: #include "nsCSSRendering.h"
   1: 
   1: #ifdef IBMBIDI
   1: #include "nsBidiPresUtils.h"
   1: #endif // IBMBIDI
   1: 
   1: #include "nsIDOMHTMLBodyElement.h"
   1: #include "nsIDOMHTMLHtmlElement.h"
   1: 
   1: static const int MIN_LINES_NEEDING_CURSOR = 20;
   1: 
   1: #ifdef DEBUG
   1: #include "nsPrintfCString.h"
   1: #include "nsBlockDebugFlags.h"
   1: 
   1: PRBool nsBlockFrame::gLamePaintMetrics;
   1: PRBool nsBlockFrame::gLameReflowMetrics;
   1: PRBool nsBlockFrame::gNoisy;
   1: PRBool nsBlockFrame::gNoisyDamageRepair;
   1: PRBool nsBlockFrame::gNoisyIntrinsic;
   1: PRBool nsBlockFrame::gNoisyReflow;
   1: PRBool nsBlockFrame::gReallyNoisyReflow;
   1: PRBool nsBlockFrame::gNoisySpaceManager;
   1: PRBool nsBlockFrame::gVerifyLines;
   1: PRBool nsBlockFrame::gDisableResizeOpt;
   1: 
   1: PRInt32 nsBlockFrame::gNoiseIndent;
   1: 
   1: struct BlockDebugFlags {
   1:   const char* name;
   1:   PRBool* on;
   1: };
   1: 
   1: static const BlockDebugFlags gFlags[] = {
   1:   { "reflow", &nsBlockFrame::gNoisyReflow },
   1:   { "really-noisy-reflow", &nsBlockFrame::gReallyNoisyReflow },
   1:   { "intrinsic", &nsBlockFrame::gNoisyIntrinsic },
   1:   { "space-manager", &nsBlockFrame::gNoisySpaceManager },
   1:   { "verify-lines", &nsBlockFrame::gVerifyLines },
   1:   { "damage-repair", &nsBlockFrame::gNoisyDamageRepair },
   1:   { "lame-paint-metrics", &nsBlockFrame::gLamePaintMetrics },
   1:   { "lame-reflow-metrics", &nsBlockFrame::gLameReflowMetrics },
   1:   { "disable-resize-opt", &nsBlockFrame::gDisableResizeOpt },
   1: };
   1: #define NUM_DEBUG_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
   1: 
   1: static void
   1: ShowDebugFlags()
   1: {
   1:   printf("Here are the available GECKO_BLOCK_DEBUG_FLAGS:\n");
   1:   const BlockDebugFlags* bdf = gFlags;
   1:   const BlockDebugFlags* end = gFlags + NUM_DEBUG_FLAGS;
   1:   for (; bdf < end; bdf++) {
   1:     printf("  %s\n", bdf->name);
   1:   }
   1:   printf("Note: GECKO_BLOCK_DEBUG_FLAGS is a comma separated list of flag\n");
   1:   printf("names (no whitespace)\n");
   1: }
   1: 
   1: void
   1: nsBlockFrame::InitDebugFlags()
   1: {
   1:   static PRBool firstTime = PR_TRUE;
   1:   if (firstTime) {
   1:     firstTime = PR_FALSE;
   1:     char* flags = PR_GetEnv("GECKO_BLOCK_DEBUG_FLAGS");
   1:     if (flags) {
   1:       PRBool error = PR_FALSE;
   1:       for (;;) {
   1:         char* cm = PL_strchr(flags, ',');
   1:         if (cm) *cm = '\0';
   1: 
   1:         PRBool found = PR_FALSE;
   1:         const BlockDebugFlags* bdf = gFlags;
   1:         const BlockDebugFlags* end = gFlags + NUM_DEBUG_FLAGS;
   1:         for (; bdf < end; bdf++) {
   1:           if (PL_strcasecmp(bdf->name, flags) == 0) {
   1:             *(bdf->on) = PR_TRUE;
   1:             printf("nsBlockFrame: setting %s debug flag on\n", bdf->name);
   1:             gNoisy = PR_TRUE;
   1:             found = PR_TRUE;
   1:             break;
   1:           }
   1:         }
   1:         if (!found) {
   1:           error = PR_TRUE;
   1:         }
   1: 
   1:         if (!cm) break;
   1:         *cm = ',';
   1:         flags = cm + 1;
   1:       }
   1:       if (error) {
   1:         ShowDebugFlags();
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: #endif
   1: 
   1: // add in a sanity check for absurdly deep frame trees.  See bug 42138
   1: // can't just use IsFrameTreeTooDeep() because that method has side effects we don't want
   1: #define MAX_DEPTH_FOR_LIST_RENUMBERING 200  // 200 open displayable tags is pretty unrealistic
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: // Debugging support code
   1: 
   1: #ifdef DEBUG
   1: const char* nsBlockFrame::kReflowCommandType[] = {
   1:   "ContentChanged",
   1:   "StyleChanged",
   1:   "ReflowDirty",
   1:   "Timeout",
   1:   "UserDefined",
   1: };
   1: #endif
   1: 
   1: #ifdef REALLY_NOISY_FIRST_LINE
   1: static void
   1: DumpStyleGeneaology(nsIFrame* aFrame, const char* gap)
   1: {
   1:   fputs(gap, stdout);
   1:   nsFrame::ListTag(stdout, aFrame);
   1:   printf(": ");
   1:   nsStyleContext* sc = aFrame->GetStyleContext();
   1:   while (nsnull != sc) {
   1:     nsStyleContext* psc;
   1:     printf("%p ", sc);
   1:     psc = sc->GetParent();
   1:     sc = psc;
   1:   }
   1:   printf("\n");
   1: }
   1: #endif
   1: 
   1: #ifdef REFLOW_STATUS_COVERAGE
   1: static void
   1: RecordReflowStatus(PRBool aChildIsBlock, nsReflowStatus aFrameReflowStatus)
   1: {
   1:   static PRUint32 record[2];
   1: 
   1:   // 0: child-is-block
   1:   // 1: child-is-inline
   1:   PRIntn index = 0;
   1:   if (!aChildIsBlock) index |= 1;
   1: 
   1:   // Compute new status
   1:   PRUint32 newS = record[index];
   1:   if (NS_INLINE_IS_BREAK(aFrameReflowStatus)) {
   1:     if (NS_INLINE_IS_BREAK_BEFORE(aFrameReflowStatus)) {
   1:       newS |= 1;
   1:     }
   1:     else if (NS_FRAME_IS_NOT_COMPLETE(aFrameReflowStatus)) {
   1:       newS |= 2;
   1:     }
   1:     else {
   1:       newS |= 4;
   1:     }
   1:   }
   1:   else if (NS_FRAME_IS_NOT_COMPLETE(aFrameReflowStatus)) {
   1:     newS |= 8;
   1:   }
   1:   else {
   1:     newS |= 16;
   1:   }
   1: 
   1:   // Log updates to the status that yield different values
   1:   if (record[index] != newS) {
   1:     record[index] = newS;
   1:     printf("record(%d): %02x %02x\n", index, record[0], record[1]);
   1:   }
   1: }
   1: #endif
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: const nsIID kBlockFrameCID = NS_BLOCK_FRAME_CID;
   1: 
   1: nsIFrame*
   1: NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags)
   1: {
   1:   nsBlockFrame* it = new (aPresShell) nsBlockFrame(aContext);
   1:   if (it) {
   1:     it->SetFlags(aFlags);
   1:   }
   1:   return it;
   1: }
   1: 
   1: nsBlockFrame::~nsBlockFrame()
   1: {
   1: }
   1: 
   1: void
   1: nsBlockFrame::Destroy()
   1: {
   1:   mAbsoluteContainer.DestroyFrames(this);
   1:   // Outside bullets are not in our child-list so check for them here
   1:   // and delete them when present.
   1:   if (mBullet && HaveOutsideBullet()) {
   1:     mBullet->Destroy();
   1:     mBullet = nsnull;
   1:   }
   1: 
   1:   mFloats.DestroyFrames();
   1:   
 238:   nsPresContext* presContext = PresContext();
   1: 
   1:   nsLineBox::DeleteLineList(presContext, mLines);
   1: 
   1:   // destroy overflow lines now
   1:   nsLineList* overflowLines = RemoveOverflowLines();
   1:   if (overflowLines) {
   1:     nsLineBox::DeleteLineList(presContext, *overflowLines);
   1:   }
   1: 
   1:   {
   1:     nsAutoOOFFrameList oofs(this);
   1:     oofs.mList.DestroyFrames();
   1:     // oofs is now empty and will remove the frame list property
   1:   }
   1: 
   1:   nsBlockFrameSuper::Destroy();
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::QueryInterface(const nsIID& aIID, void** aInstancePtr)
   1: {
   1:   NS_PRECONDITION(aInstancePtr, "null out param");
3114: 
   1:   if (aIID.Equals(kBlockFrameCID)) {
3233:     *aInstancePtr = static_cast<void*>(static_cast<nsBlockFrame*>(this));
   1:     return NS_OK;
   1:   }
   1:   if (aIID.Equals(NS_GET_IID(nsILineIterator)) ||
3114:       aIID.Equals(NS_GET_IID(nsILineIteratorNavigator))) {
   1:     nsLineIterator* it = new nsLineIterator;
   1:     if (!it) {
   1:       *aInstancePtr = nsnull;
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     NS_ADDREF(it); // reference passed to caller
   1:     const nsStyleVisibility* visibility = GetStyleVisibility();
   1:     nsresult rv = it->Init(mLines,
   1:                            visibility->mDirection == NS_STYLE_DIRECTION_RTL);
   1:     if (NS_FAILED(rv)) {
3114:       *aInstancePtr = nsnull;
   1:       NS_RELEASE(it);
   1:       return rv;
   1:     }
3233:     *aInstancePtr = static_cast<nsILineIteratorNavigator*>(it);
   1:     return NS_OK;
   1:   }
3114: 
   1:   return nsBlockFrameSuper::QueryInterface(aIID, aInstancePtr);
   1: }
   1: 
   1: nsSplittableType
   1: nsBlockFrame::GetSplittableType() const
   1: {
   1:   return NS_FRAME_SPLITTABLE_NON_RECTANGULAR;
   1: }
   1: 
   1: #ifdef DEBUG
   1: NS_METHOD
   1: nsBlockFrame::List(FILE* out, PRInt32 aIndent) const
   1: {
   1:   IndentBy(out, aIndent);
   1:   ListTag(out);
   1: #ifdef DEBUG_waterson
   1:   fprintf(out, " [parent=%p]", mParent);
   1: #endif
   1:   if (HasView()) {
3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
   1:   }
   1:   if (nsnull != mNextSibling) {
3233:     fprintf(out, " next=%p", static_cast<void*>(mNextSibling));
   1:   }
   1: 
   1:   // Output the flow linkage
   1:   if (nsnull != GetPrevInFlow()) {
3233:     fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
   1:   }
   1:   if (nsnull != GetNextInFlow()) {
3233:     fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
   1:   }
   1: 
   1:   // Output the rect and state
   1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
   1:   if (0 != mState) {
   1:     fprintf(out, " [state=%08x]", mState);
   1:   }
3233:   nsBlockFrame* f = const_cast<nsBlockFrame*>(this);
   1:   nsRect* overflowArea = f->GetOverflowAreaProperty(PR_FALSE);
   1:   if (overflowArea) {
   1:     fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea->x, overflowArea->y,
   1:             overflowArea->width, overflowArea->height);
   1:   }
   1:   PRInt32 numInlineLines = 0;
   1:   PRInt32 numBlockLines = 0;
   1:   if (! mLines.empty()) {
   1:     for (const_line_iterator line = begin_lines(), line_end = end_lines();
   1:          line != line_end;
   1:          ++line)
   1:     {
   1:       if (line->IsBlock())
   1:         numBlockLines++;
   1:       else
   1:         numInlineLines++;
   1:     }
   1:   }
   1:   fprintf(out, " sc=%p(i=%d,b=%d)",
3233:           static_cast<void*>(mStyleContext), numInlineLines, numBlockLines);
   1:   nsIAtom* pseudoTag = mStyleContext->GetPseudoType();
   1:   if (pseudoTag) {
   1:     nsAutoString atomString;
   1:     pseudoTag->ToString(atomString);
   1:     fprintf(out, " pst=%s",
   1:             NS_LossyConvertUTF16toASCII(atomString).get());
   1:   }
   1:   fputs("<\n", out);
   1: 
   1:   aIndent++;
   1: 
   1:   // Output the lines
   1:   if (! mLines.empty()) {
   1:     for (const_line_iterator line = begin_lines(), line_end = end_lines();
   1:          line != line_end;
   1:          ++line)
   1:     {
   1:       line->List(out, aIndent);
   1:     }
   1:   }
   1: 
   1:   nsIAtom* listName = nsnull;
   1:   PRInt32 listIndex = 0;
   1:   for (;;) {
   1:     listName = GetAdditionalChildListName(listIndex++);
   1:     if (nsnull == listName) {
   1:       break;
   1:     }
   1:     nsIFrame* kid = GetFirstChild(listName);
   1:     if (kid) {
   1:       IndentBy(out, aIndent);
   1:       nsAutoString tmp;
   1:       if (nsnull != listName) {
   1:         listName->ToString(tmp);
   1:         fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
   1:       }
   1:       fputs("<\n", out);
   1:       while (kid) {
   1:         nsIFrameDebug*  frameDebug;
   1: 
   1:         if (NS_SUCCEEDED(CallQueryInterface(kid, &frameDebug))) {
   1:           frameDebug->List(out, aIndent + 1);
   1:         }
   1:         kid = kid->GetNextSibling();
   1:       }
   1:       IndentBy(out, aIndent);
   1:       fputs(">\n", out);
   1:     }
   1:   }
   1: 
   1:   aIndent--;
   1:   IndentBy(out, aIndent);
   1:   fputs(">\n", out);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP_(nsFrameState)
   1: nsBlockFrame::GetDebugStateBits() const
   1: {
   1:   // We don't want to include our cursor flag in the bits the
   1:   // regression tester looks at
   1:   return nsBlockFrameSuper::GetDebugStateBits() & ~NS_BLOCK_HAS_LINE_CURSOR;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::GetFrameName(nsAString& aResult) const
   1: {
   1:   return MakeFrameName(NS_LITERAL_STRING("Block"), aResult);
   1: }
   1: #endif
   1: 
   1: nsIAtom*
   1: nsBlockFrame::GetType() const
   1: {
   1:   return nsGkAtoms::blockFrame;
   1: }
   1: 
   1: void
   1: nsBlockFrame::InvalidateInternal(const nsRect& aDamageRect,
   1:                                  nscoord aX, nscoord aY, nsIFrame* aForChild,
   1:                                  PRBool aImmediate)
   1: {
   1:   // Optimize by suppressing invalidation of areas that are clipped out
   1:   // with CSS 'clip'.
   1:   const nsStyleDisplay* disp = GetStyleDisplay();
   1:   nsRect absPosClipRect;
 462:   if (GetAbsPosClipRect(disp, &absPosClipRect, GetSize())) {
   1:     // Restrict the invalidated area to abs-pos clip rect
   1:     // abs-pos clipping clips everything in the frame
   1:     nsRect r;
   1:     if (r.IntersectRect(aDamageRect, absPosClipRect - nsPoint(aX, aY))) {
 683:       nsBlockFrameSuper::InvalidateInternal(r, aX, aY, this, aImmediate);
   1:     }
   1:     return;
   1:   }
   1: 
 683:   nsBlockFrameSuper::InvalidateInternal(aDamageRect, aX, aY, this, aImmediate);
   1: }
   1: 
   1: nscoord
   1: nsBlockFrame::GetBaseline() const
   1: {
1158:   NS_ASSERTION(!NS_SUBTREE_DIRTY(this), "frame must not be dirty");
   1:   nscoord result;
   1:   if (nsLayoutUtils::GetLastLineBaseline(this, &result))
   1:     return result;
   1:   return nsFrame::GetBaseline();
   1: }
   1: 
   1: /////////////////////////////////////////////////////////////////////////////
   1: // Child frame enumeration
   1: 
   1: nsIFrame*
   1: nsBlockFrame::GetFirstChild(nsIAtom* aListName) const
   1: {
4205:   if (nsGkAtoms::absoluteList == aListName) {
   1:     nsIFrame* result = nsnull;
   1:     mAbsoluteContainer.FirstChild(this, aListName, &result);
   1:     return result;
   1:   }
   1:   else if (nsnull == aListName) {
   1:     return (mLines.empty()) ? nsnull : mLines.front()->mFirstChild;
   1:   }
   1:   else if (aListName == nsGkAtoms::overflowList) {
   1:     nsLineList* overflowLines = GetOverflowLines();
   1:     return overflowLines ? overflowLines->front()->mFirstChild : nsnull;
   1:   }
   1:   else if (aListName == nsGkAtoms::overflowOutOfFlowList) {
   1:     return GetOverflowOutOfFlows().FirstChild();
   1:   }
   1:   else if (aListName == nsGkAtoms::floatList) {
   1:     return mFloats.FirstChild();
   1:   }
   1:   else if (aListName == nsGkAtoms::bulletList) {
4006:     return (HaveOutsideBullet()) ? mBullet : nsnull;
4006:   }
4006:   return nsContainerFrame::GetFirstChild(aListName);;
4006: }
4006: 
4006: #define NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX  (NS_CONTAINER_LIST_COUNT_INCL_OC + 0)
4006: #define NS_BLOCK_FRAME_FLOAT_LIST_INDEX         (NS_CONTAINER_LIST_COUNT_INCL_OC + 1)
4006: #define NS_BLOCK_FRAME_BULLET_LIST_INDEX        (NS_CONTAINER_LIST_COUNT_INCL_OC + 2)
4006: #define NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX      (NS_CONTAINER_LIST_COUNT_INCL_OC + 3)
4006: // If adding/removing lists, don't forget to update the count in nsBlockFrame.h
   1: 
   1: nsIAtom*
   1: nsBlockFrame::GetAdditionalChildListName(PRInt32 aIndex) const
   1: {
4006:   if (aIndex < NS_CONTAINER_LIST_COUNT_INCL_OC)
4006:     return nsContainerFrame::GetAdditionalChildListName(aIndex);
4006: 
   1:   switch (aIndex) {
   1:   case NS_BLOCK_FRAME_FLOAT_LIST_INDEX:
   1:     return nsGkAtoms::floatList;
   1:   case NS_BLOCK_FRAME_BULLET_LIST_INDEX:
   1:     return nsGkAtoms::bulletList;
   1:   case NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX:
   1:     return nsGkAtoms::overflowOutOfFlowList;
   1:   case NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX:
4205:     return nsGkAtoms::absoluteList;
   1:   default:
   1:     return nsnull;
   1:   }
   1: }
   1: 
   1: /* virtual */ PRBool
   1: nsBlockFrame::IsContainingBlock() const
   1: {
   1:   return PR_TRUE;
   1: }
   1: 
   1: /* virtual */ PRBool
   1: nsBlockFrame::IsFloatContainingBlock() const
   1: {
   1:   return PR_TRUE;
   1: }
   1: 
   1: static PRBool IsContinuationPlaceholder(nsIFrame* aFrame)
   1: {
   1:   return aFrame->GetPrevInFlow() &&
   1:     nsGkAtoms::placeholderFrame == aFrame->GetType();
   1: }
   1: 
   1: static void ReparentFrame(nsIFrame* aFrame, nsIFrame* aOldParent,
   1:                           nsIFrame* aNewParent) {
   1:   NS_ASSERTION(aOldParent == aFrame->GetParent(),
   1:                "Parent not consistent with exepectations");
   1: 
   1:   aFrame->SetParent(aNewParent);
   1: 
   1:   // When pushing and pulling frames we need to check for whether any
   1:   // views need to be reparented
 238:   nsHTMLContainerFrame::ReparentFrameView(aFrame->PresContext(), aFrame,
   1:                                           aOldParent, aNewParent);
   1: }
   1:  
   1: //////////////////////////////////////////////////////////////////////
   1: // Frame structure methods
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: // Reflow methods
   1: 
   1: /* virtual */ void
   1: nsBlockFrame::MarkIntrinsicWidthsDirty()
   1: {
5675:   nsBlockFrame* dirtyBlock = static_cast<nsBlockFrame*>(GetFirstContinuation());
3786:   dirtyBlock->mMinWidth = NS_INTRINSIC_WIDTH_UNKNOWN;
3786:   dirtyBlock->mPrefWidth = NS_INTRINSIC_WIDTH_UNKNOWN;
6829:   if (!(GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)) {
6829:     for (nsIFrame* frame = dirtyBlock; frame; 
6829:          frame = frame->GetNextContinuation()) {
6829:       frame->AddStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);
6829:     }
6829:   }
   1: 
   1:   nsBlockFrameSuper::MarkIntrinsicWidthsDirty();
   1: }
   1: 
   1: /* virtual */ nscoord
   1: nsBlockFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
   1: {
3786:   nsIFrame* firstInFlow = GetFirstContinuation();
3786:   if (firstInFlow != this)
3786:     return firstInFlow->GetMinWidth(aRenderingContext);
3786: 
   1:   DISPLAY_MIN_WIDTH(this, mMinWidth);
   1:   if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
   1:     return mMinWidth;
   1: 
   1: #ifdef DEBUG
   1:   if (gNoisyIntrinsic) {
   1:     IndentBy(stdout, gNoiseIndent);
   1:     ListTag(stdout);
   1:     printf(": GetMinWidth\n");
   1:   }
   1:   AutoNoisyIndenter indent(gNoisyIntrinsic);
   1: #endif
   1: 
6829:   if (GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)
5590:     ResolveBidi();
   1:   InlineMinWidthData data;
3786:   for (nsBlockFrame* curFrame = this; curFrame;
5675:        curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {
3786:     for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
2668:       line != line_end; ++line)
   1:     {
   1: #ifdef DEBUG
   1:       if (gNoisyIntrinsic) {
   1:         IndentBy(stdout, gNoiseIndent);
2668:         printf("line (%s%s)\n",
   1:                line->IsBlock() ? "block" : "inline",
   1:                line->IsEmpty() ? ", empty" : "");
   1:       }
   1:       AutoNoisyIndenter lineindent(gNoisyIntrinsic);
   1: #endif
   1:       if (line->IsBlock()) {
2668:         data.ForceBreak(aRenderingContext);
   1:         data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
   1:                         line->mFirstChild, nsLayoutUtils::MIN_WIDTH);
2668:         data.ForceBreak(aRenderingContext);
   1:       } else {
8006:         if (!curFrame->GetPrevContinuation() &&
8006:             line == curFrame->begin_lines()) {
2668:           const nsStyleCoord &indent = GetStyleText()->mTextIndent;
2668:           if (indent.GetUnit() == eStyleUnit_Coord)
2668:             data.currentLine += indent.GetCoordValue();
2668:         }
2668:         // XXX Bug NNNNNN Should probably handle percentage text-indent.
   1: 
6029:       data.line = &line;
   1:         nsIFrame *kid = line->mFirstChild;
   1:         for (PRInt32 i = 0, i_end = line->GetChildCount(); i != i_end;
   1:              ++i, kid = kid->GetNextSibling()) {
   1:           kid->AddInlineMinWidth(aRenderingContext, &data);
   1:         }
   1:       }
   1: #ifdef DEBUG
   1:       if (gNoisyIntrinsic) {
   1:         IndentBy(stdout, gNoiseIndent);
   1:         printf("min: [prevLines=%d currentLine=%d]\n",
   1:                data.prevLines, data.currentLine);
   1:       }
   1: #endif
   1:     }
3786:   }
2668:   data.ForceBreak(aRenderingContext);
   1: 
   1:   mMinWidth = data.prevLines;
   1:   return mMinWidth;
   1: }
   1: 
   1: /* virtual */ nscoord
   1: nsBlockFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
   1: {
3786:   nsIFrame* firstInFlow = GetFirstContinuation();
3786:   if (firstInFlow != this)
3786:     return firstInFlow->GetPrefWidth(aRenderingContext);
3786: 
   1:   DISPLAY_PREF_WIDTH(this, mPrefWidth);
3786: 
   1:   if (mPrefWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
   1:     return mPrefWidth;
   1: 
   1: #ifdef DEBUG
   1:   if (gNoisyIntrinsic) {
   1:     IndentBy(stdout, gNoiseIndent);
   1:     ListTag(stdout);
   1:     printf(": GetPrefWidth\n");
   1:   }
   1:   AutoNoisyIndenter indent(gNoisyIntrinsic);
   1: #endif
   1: 
6829:   if (GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)
5590:     ResolveBidi();
   1:   InlinePrefWidthData data;
3786:   for (nsBlockFrame* curFrame = this; curFrame;
5675:        curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {
3786:     for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
2668:          line != line_end; ++line)
   1:     {
   1: #ifdef DEBUG
   1:       if (gNoisyIntrinsic) {
   1:         IndentBy(stdout, gNoiseIndent);
2668:         printf("line (%s%s)\n",
   1:                line->IsBlock() ? "block" : "inline",
   1:                line->IsEmpty() ? ", empty" : "");
   1:       }
   1:       AutoNoisyIndenter lineindent(gNoisyIntrinsic);
   1: #endif
   1:       if (line->IsBlock()) {
2668:         data.ForceBreak(aRenderingContext);
   1:         data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
   1:                         line->mFirstChild, nsLayoutUtils::PREF_WIDTH);
2668:         data.ForceBreak(aRenderingContext);
   1:       } else {
8006:         if (!curFrame->GetPrevContinuation() &&
8006:             line == curFrame->begin_lines()) {
2668:           const nsStyleCoord &indent = GetStyleText()->mTextIndent;
2668:           if (indent.GetUnit() == eStyleUnit_Coord)
2668:             data.currentLine += indent.GetCoordValue();
2668:         }
2668:         // XXX Bug NNNNNN Should probably handle percentage text-indent.
   1: 
6029:       data.line = &line;
   1:         nsIFrame *kid = line->mFirstChild;
   1:         for (PRInt32 i = 0, i_end = line->GetChildCount(); i != i_end;
   1:              ++i, kid = kid->GetNextSibling()) {
   1:           kid->AddInlinePrefWidth(aRenderingContext, &data);
   1:         }
   1:       }
   1: #ifdef DEBUG
   1:       if (gNoisyIntrinsic) {
   1:         IndentBy(stdout, gNoiseIndent);
   1:         printf("pref: [prevLines=%d currentLine=%d]\n",
   1:                data.prevLines, data.currentLine);
   1:       }
   1: #endif
   1:     }
3786:   }
2668:   data.ForceBreak(aRenderingContext);
   1: 
   1:   mPrefWidth = data.prevLines;
   1:   return mPrefWidth;
   1: }
   1: 
6862: nsRect
6862: nsBlockFrame::ComputeTightBounds(gfxContext* aContext) const
6862: {
6862:   // be conservative
6862:   if (GetStyleContext()->HasTextDecorations())
6862:     return GetOverflowRect();
6862:   return ComputeSimpleTightBounds(aContext);
6862: }
6862: 
   1: static nsSize
   1: CalculateContainingBlockSizeForAbsolutes(const nsHTMLReflowState& aReflowState,
   1:                                          nsSize aFrameSize)
   1: {
   1:   // The issue here is that for a 'height' of 'auto' the reflow state
   1:   // code won't know how to calculate the containing block height
   1:   // because it's calculated bottom up. So we use our own computed
8518:   // size as the dimensions.
   1:   nsIFrame* frame = aReflowState.frame;
   1: 
   1:   nsSize cbSize(aFrameSize);
   1:     // Containing block is relative to the padding edge
   1:   const nsMargin& border = aReflowState.mStyleBorder->GetBorder();
   1:   cbSize.width -= border.left + border.right;
   1:   cbSize.height -= border.top + border.bottom;
   1: 
   1:   if (frame->GetParent()->GetContent() == frame->GetContent()) {
   1:     // We are a wrapped frame for the content. Use the container's
   1:     // dimensions, if they have been precomputed.
   1:     // XXX This is a hack! We really should be waiting until the outermost
   1:     // frame is fully reflowed and using the resulting dimensions, even
   1:     // if they're intrinsic.
   1:     // In fact we should be attaching absolute children to the outermost
   1:     // frame and not always sticking them in block frames.
   1: 
   1:     // First, find the reflow state for the outermost frame for this
   1:     // content.
   1:     const nsHTMLReflowState* aLastRS = &aReflowState;
   1:     const nsHTMLReflowState* lastButOneRS = &aReflowState;
   1:     while (aLastRS->parentReflowState &&
   1:            aLastRS->parentReflowState->frame->GetContent() == frame->GetContent()) {
   1:       lastButOneRS = aLastRS;
   1:       aLastRS = aLastRS->parentReflowState;
   1:     }
   1:     if (aLastRS != &aReflowState) {
   1:       // Scrollbars need to be specifically excluded, if present, because they are outside the
   1:       // padding-edge. We need better APIs for getting the various boxes from a frame.
   1:       nsIScrollableFrame* scrollFrame;
   1:       CallQueryInterface(aLastRS->frame, &scrollFrame);
   1:       nsMargin scrollbars(0,0,0,0);
   1:       if (scrollFrame) {
 238:         nsBoxLayoutState dummyState(aLastRS->frame->PresContext(),
   1:                                     aLastRS->rendContext);
   1:         scrollbars = scrollFrame->GetDesiredScrollbarSizes(&dummyState);
8518:         if (!lastButOneRS->mFlags.mAssumingHScrollbar) {
   1:           scrollbars.top = scrollbars.bottom = 0;
8518:         }
   1:         if (!lastButOneRS->mFlags.mAssumingVScrollbar) {
   1:           scrollbars.left = scrollbars.right = 0;
   1:         }
   1:       }
   1:       // We found a reflow state for the outermost wrapping frame, so use
   1:       // its computed metrics if available
   1:       if (aLastRS->ComputedWidth() != NS_UNCONSTRAINEDSIZE) {
   1:         cbSize.width = PR_MAX(0,
   1:           aLastRS->ComputedWidth() + aLastRS->mComputedPadding.LeftRight() - scrollbars.LeftRight());
   1:       }
4166:       if (aLastRS->ComputedHeight() != NS_UNCONSTRAINEDSIZE) {
   1:         cbSize.height = PR_MAX(0,
4166:           aLastRS->ComputedHeight() + aLastRS->mComputedPadding.TopBottom() - scrollbars.TopBottom());
   1:       }
   1:     }
   1:   }
   1: 
   1:   return cbSize;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::Reflow(nsPresContext*           aPresContext,
   1:                      nsHTMLReflowMetrics&     aMetrics,
   1:                      const nsHTMLReflowState& aReflowState,
   1:                      nsReflowStatus&          aStatus)
   1: {
   1:   DO_GLOBAL_REFLOW_COUNT("nsBlockFrame");
   1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
   1: #ifdef DEBUG
   1:   if (gNoisyReflow) {
   1:     IndentBy(stdout, gNoiseIndent);
   1:     ListTag(stdout);
   1:     printf(": begin reflow availSize=%d,%d computedSize=%d,%d\n",
   1:            aReflowState.availableWidth, aReflowState.availableHeight,
4166:            aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
   1:   }
   1:   AutoNoisyIndenter indent(gNoisy);
   1:   PRTime start = LL_ZERO; // Initialize these variablies to silence the compiler.
   1:   PRInt32 ctc = 0;        // We only use these if they are set (gLameReflowMetrics).
   1:   if (gLameReflowMetrics) {
   1:     start = PR_Now();
   1:     ctc = nsLineBox::GetCtorCount();
   1:   }
   1: #endif
   1: 
   1:   nsSize oldSize = GetSize();
   1: 
   1:   // Should we create a space manager?
3233:   nsAutoSpaceManager autoSpaceManager(const_cast<nsHTMLReflowState &>(aReflowState));
   1: 
   1:   // XXXldb If we start storing the space manager in the frame rather
   1:   // than keeping it around only during reflow then we should create it
   1:   // only when there are actually floats to manage.  Otherwise things
   1:   // like tables will gain significant bloat.
   1:   PRBool needSpaceManager = nsBlockFrame::BlockNeedsSpaceManager(this);
   1:   if (needSpaceManager)
   1:     autoSpaceManager.CreateSpaceManagerFor(aPresContext, this);
   1: 
   1:   // OK, some lines may be reflowed. Blow away any saved line cursor because
   1:   // we may invalidate the nondecreasing combinedArea.y/yMost invariant,
   1:   // and we may even delete the line with the line cursor.
   1:   ClearLineCursor();
   1: 
   1:   if (IsFrameTreeTooDeep(aReflowState, aMetrics)) {
   1: #ifdef DEBUG_kipp
   1:     {
   1:       extern char* nsPresShell_ReflowStackPointerTop;
   1:       char marker;
   1:       char* newsp = (char*) &marker;
   1:       printf("XXX: frame tree is too deep; approx stack size = %d\n",
   1:              nsPresShell_ReflowStackPointerTop - newsp);
   1:     }
   1: #endif
   1:     aStatus = NS_FRAME_COMPLETE;
   1:     return NS_OK;
   1:   }
   1: 
   1:   PRBool marginRoot = BlockIsMarginRoot(this);
   1:   nsBlockReflowState state(aReflowState, aPresContext, this, aMetrics,
   1:                            marginRoot, marginRoot, needSpaceManager);
   1: 
   1: #ifdef IBMBIDI
6829:   if (GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)
6829:     static_cast<nsBlockFrame*>(GetFirstContinuation())->ResolveBidi();
   1: #endif // IBMBIDI
   1: 
1158:   if (RenumberLists(aPresContext)) {
1158:     AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
1158:   }
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1:   // ALWAYS drain overflow. We never want to leave the previnflow's
   1:   // overflow lines hanging around; block reflow depends on the
   1:   // overflow line lists being cleared out between reflow passes.
   1:   DrainOverflowLines(state);
   1:   state.SetupOverflowPlaceholdersProperty();
   1:  
   1:   // If we're not dirty (which means we'll mark everything dirty later)
   1:   // and our width has changed, mark the lines dirty that we need to
   1:   // mark dirty for a resize reflow.
   1:   if (aReflowState.mFlags.mHResize)
   1:     PrepareResizeReflow(state);
   1: 
   1:   mState &= ~NS_FRAME_FIRST_REFLOW;
   1: 
   1:   // Now reflow...
   1:   rv = ReflowDirtyLines(state);
   1:   NS_ASSERTION(NS_SUCCEEDED(rv), "reflow dirty lines failed");
   1:   if (NS_FAILED(rv)) return rv;
   1: 
4006:   // Handle paginated overflow (see nsContainerFrame.h)
4006:   nsRect overflowContainerBounds;
4006:   if (GetPrevInFlow()) {
4006:     ReflowOverflowContainerChildren(aPresContext, aReflowState,
4006:                                     overflowContainerBounds, 0,
4006:                                     state.mReflowStatus);
4006:   }
4006: 
   1:   // If the block is complete, put continuted floats in the closest ancestor 
   1:   // block that uses the same space manager and leave the block complete; this 
   1:   // allows subsequent lines on the page to be impacted by floats. If the 
   1:   // block is incomplete or there is no ancestor using the same space manager, 
   1:   // put continued floats at the beginning of the first overflow line.
   1:   if (state.mOverflowPlaceholders.NotEmpty()) {
   1:     NS_ASSERTION(aReflowState.availableHeight != NS_UNCONSTRAINEDSIZE,
   1:                  "Somehow we failed to fit all content, even though we have unlimited space!");
4006:     if (NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
   1:       // find the nearest block ancestor that uses the same space manager
   1:       for (const nsHTMLReflowState* ancestorRS = aReflowState.parentReflowState; 
   1:            ancestorRS; 
   1:            ancestorRS = ancestorRS->parentReflowState) {
   1:         nsIFrame* ancestor = ancestorRS->frame;
   1:         nsIAtom* fType = ancestor->GetType();
   1:         if ((nsGkAtoms::blockFrame == fType || nsGkAtoms::areaFrame == fType) &&
   1:             aReflowState.mSpaceManager == ancestorRS->mSpaceManager) {
   1:           // Put the continued floats in ancestor since it uses the same space manager
   1:           nsFrameList* ancestorPlace =
   1:             ((nsBlockFrame*)ancestor)->GetOverflowPlaceholders();
   1:           // The ancestor should have this list, since it's being reflowed. But maybe
   1:           // it isn't because of reflow roots or something.
   1:           if (ancestorPlace) {
   1:             for (nsIFrame* f = state.mOverflowPlaceholders.FirstChild();
   1:                  f; f = f->GetNextSibling()) {
   1:               NS_ASSERTION(IsContinuationPlaceholder(f),
   1:                            "Overflow placeholders must be continuation placeholders");
   1:               ReparentFrame(f, this, ancestorRS->frame);
   1:               nsIFrame* oof = nsPlaceholderFrame::GetRealFrameForPlaceholder(f);
   1:               mFloats.RemoveFrame(oof);
   1:               ReparentFrame(oof, this, ancestorRS->frame);
   1:               // Clear the next-sibling in case the frame wasn't in mFloats
   1:               oof->SetNextSibling(nsnull);
   1:               // Do not put the float into any child frame list, because
   1:               // placeholders in the overflow-placeholder block-state list
   1:               // don't keep their out of flows in a child frame list.
   1:             }
   1:             ancestorPlace->AppendFrames(nsnull, state.mOverflowPlaceholders.FirstChild());
   1:             state.mOverflowPlaceholders.SetFrames(nsnull);
   1:             break;
   1:           }
   1:         }
   1:       }
   1:     }
   1:     if (!state.mOverflowPlaceholders.IsEmpty()) {
   1:       state.mOverflowPlaceholders.SortByContentOrder();
   1:       PRInt32 numOverflowPlace = state.mOverflowPlaceholders.GetLength();
   1:       nsLineBox* newLine =
   1:         state.NewLineBox(state.mOverflowPlaceholders.FirstChild(),
   1:                          numOverflowPlace, PR_FALSE);
   1:       if (newLine) {
   1:         nsLineList* overflowLines = GetOverflowLines();
   1:         if (overflowLines) {
   1:           // Need to put the overflow placeholders' floats into our
   1:           // overflow-out-of-flows list, since the overflow placeholders are
   1:           // going onto our overflow line list. Put them last, because that's
   1:           // where the placeholders are going.
   1:           nsFrameList floats;
   1:           nsIFrame* lastFloat = nsnull;
   1:           for (nsIFrame* f = state.mOverflowPlaceholders.FirstChild();
   1:                f; f = f->GetNextSibling()) {
   1:             NS_ASSERTION(IsContinuationPlaceholder(f),
   1:                          "Overflow placeholders must be continuation placeholders");
   1:             nsIFrame* oof = nsPlaceholderFrame::GetRealFrameForPlaceholder(f);
   1:             // oof is not currently in any child list
   1:             floats.InsertFrames(nsnull, lastFloat, oof);
   1:             lastFloat = oof;
   1:           }
   1: 
   1:           // Put the new placeholders *last* in the overflow lines
   1:           // because they might have previnflows in the overflow lines.
   1:           nsIFrame* lastChild = overflowLines->back()->LastChild();
   1:           lastChild->SetNextSibling(state.mOverflowPlaceholders.FirstChild());
   1:           // Create a new line as the last line and put the
   1:           // placeholders there
   1:           overflowLines->push_back(newLine);
   1: 
   1:           nsAutoOOFFrameList oofs(this);
   1:           oofs.mList.AppendFrames(nsnull, floats.FirstChild());
   1:         }
   1:         else {
   1:           mLines.push_back(newLine);
   1:           nsLineList::iterator nextToLastLine = ----end_lines();
   1:           PushLines(state, nextToLastLine);
   1:         }
   1:         state.mOverflowPlaceholders.SetFrames(nsnull);
   1:       }
4006:       state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
4006:       NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
   1:     }
   1:   }
   1: 
   1:   if (NS_FRAME_IS_NOT_COMPLETE(state.mReflowStatus)) {
   1:     if (GetOverflowLines()) {
   1:       state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
   1:     }
   1: 
   1:     if (NS_STYLE_OVERFLOW_CLIP == aReflowState.mStyleDisplay->mOverflowX) {
   1:       state.mReflowStatus = NS_FRAME_COMPLETE;
   1:     }
   1:     else {
   1: #ifdef DEBUG_kipp
   1:       ListTag(stdout); printf(": block is not complete\n");
   1: #endif
   1:     }
   1:   }
   1: 
   1:   CheckFloats(state);
   1: 
   1:   // Place the "marker" (bullet) frame if it is placed next to a block
   1:   // child.
   1:   //
   1:   // According to the CSS2 spec, section 12.6.1, the "marker" box
   1:   // participates in the height calculation of the list-item box's
   1:   // first line box.
   1:   //
   1:   // There are exactly two places a bullet can be placed: near the
   1:   // first or second line. It's only placed on the second line in a
   1:   // rare case: an empty first line followed by a second line that
   1:   // contains a block (example: <LI>\n<P>... ). This is where
   1:   // the second case can happen.
   1:   if (mBullet && HaveOutsideBullet() &&
   1:       (mLines.empty() ||
   1:        mLines.front()->IsBlock() ||
   1:        0 == mLines.front()->mBounds.height)) {
   1:     // Reflow the bullet
   1:     nsHTMLReflowMetrics metrics;
   1:     ReflowBullet(state, metrics);
   1: 
   1:     nscoord baseline;
   1:     if (!nsLayoutUtils::GetFirstLineBaseline(this, &baseline)) {
   1:       baseline = 0;
   1:     }
   1:     
   1:     // Doing the alignment using the baseline will also cater for
   1:     // bullets that are placed next to a child block (bug 92896)
   1:     
   1:     // Tall bullets won't look particularly nice here...
   1:     nsRect bbox = mBullet->GetRect();
   1:     bbox.y = baseline - metrics.ascent;
   1:     mBullet->SetRect(bbox);
   1:   }
   1: 
   1:   // Compute our final size
   1:   ComputeFinalSize(aReflowState, state, aMetrics);
   1: 
   1:   ComputeCombinedArea(aReflowState, aMetrics);
4006:   // Factor overflow container child bounds into the overflow area
4006:   aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea,
4006:                                    overflowContainerBounds);
   1: 
   1:   // see if verifyReflow is enabled, and if so store off the space manager pointer
   1: #ifdef DEBUG
   1:   PRInt32 verifyReflowFlags = nsIPresShell::GetVerifyReflowFlags();
   1:   if (VERIFY_REFLOW_INCLUDE_SPACE_MANAGER & verifyReflowFlags)
   1:   {
   1:     // this is a leak of the space manager, but it's only in debug if verify reflow is enabled, so not a big deal
   1:     nsIPresShell *shell = aPresContext->GetPresShell();
   1:     if (shell) {
   1:       nsHTMLReflowState&  reflowState = (nsHTMLReflowState&)aReflowState;
   1:       rv = SetProperty(nsGkAtoms::spaceManagerProperty,
   1:                        reflowState.mSpaceManager,
   1:                        nsnull /* should be nsSpaceManagerDestroyer*/);
   1: 
   1:       autoSpaceManager.DebugOrphanSpaceManager();
   1:     }
   1:   }
   1: #endif
   1: 
   1:   // Let the absolutely positioned container reflow any absolutely positioned
   1:   // child frames that need to be reflowed, e.g., elements with a percentage
   1:   // based width/height
   1:   // We want to do this under either of two conditions:
   1:   //  1. If we didn't do the incremental reflow above.
   1:   //  2. If our size changed.
   1:   // Even though it's the padding edge that's the containing block, we
   1:   // can use our rect (the border edge) since if the border style
   1:   // changed, the reflow would have been targeted at us so we'd satisfy
   1:   // condition 1.
   1:   if (mAbsoluteContainer.HasAbsoluteFrames()) {
   1:     nsRect childBounds;
   1:     nsSize containingBlockSize
   1:       = CalculateContainingBlockSizeForAbsolutes(aReflowState,
   1:                                                  nsSize(aMetrics.width, aMetrics.height));
   1: 
   1:     // Mark frames that depend on changes we just made to this frame as dirty:
   1:     // Now we can assume that the padding edge hasn't moved.
   1:     // We need to reflow the absolutes if one of them depends on
   1:     // its placeholder position, or the containing block size in a
   1:     // direction in which the containing block size might have
   1:     // changed.
   1:     PRBool cbWidthChanged = aMetrics.width != oldSize.width;
   1:     PRBool isRoot = !GetContent()->GetParent();
   1:     // If isRoot and we have auto height, then we are the initial
   1:     // containing block and the containing block height is the
   1:     // viewport height, which can't change during incremental
   1:     // reflow.
   1:     PRBool cbHeightChanged =
4166:       !(isRoot && NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight()) &&
   1:       aMetrics.height != oldSize.height;
   1: 
   1:     rv = mAbsoluteContainer.Reflow(this, aPresContext, aReflowState,
6521:                                    state.mReflowStatus,
   1:                                    containingBlockSize.width,
6528:                                    containingBlockSize.height, PR_TRUE,
   1:                                    cbWidthChanged, cbHeightChanged,
   1:                                    &childBounds);
   1: 
3107:     //XXXfr Why isn't this rv (and others in this file) checked/returned?
3107: 
   1:     // Factor the absolutely positioned child bounds into the overflow area
   1:     aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, childBounds);
   1:   }
   1: 
   1:   // Determine if we need to repaint our border, background or outline
   1:   CheckInvalidateSizeChange(aPresContext, aMetrics, aReflowState);
   1: 
1669:   FinishAndStoreOverflow(&aMetrics);
1669: 
   1:   // Clear the space manager pointer in the block reflow state so we
   1:   // don't waste time translating the coordinate system back on a dead
   1:   // space manager.
   1:   if (needSpaceManager)
   1:     state.mSpaceManager = nsnull;
   1: 
   1:   aStatus = state.mReflowStatus;
   1: 
   1: #ifdef DEBUG
   1:   if (gNoisyReflow) {
   1:     IndentBy(stdout, gNoiseIndent);
   1:     ListTag(stdout);
   1:     printf(": status=%x (%scomplete) metrics=%d,%d carriedMargin=%d",
   1:            aStatus, NS_FRAME_IS_COMPLETE(aStatus) ? "" : "not ",
   1:            aMetrics.width, aMetrics.height,
   1:            aMetrics.mCarriedOutBottomMargin.get());
   1:     if (mState & NS_FRAME_OUTSIDE_CHILDREN) {
   1:       printf(" combinedArea={%d,%d,%d,%d}",
   1:              aMetrics.mOverflowArea.x,
   1:              aMetrics.mOverflowArea.y,
   1:              aMetrics.mOverflowArea.width,
   1:              aMetrics.mOverflowArea.height);
   1:     }
   1:     printf("\n");
   1:   }
   1: 
   1:   if (gLameReflowMetrics) {
   1:     PRTime end = PR_Now();
   1: 
   1:     PRInt32 ectc = nsLineBox::GetCtorCount();
   1:     PRInt32 numLines = mLines.size();
   1:     if (!numLines) numLines = 1;
   1:     PRTime delta, perLineDelta, lines;
   1:     LL_I2L(lines, numLines);
   1:     LL_SUB(delta, end, start);
   1:     LL_DIV(perLineDelta, delta, lines);
   1: 
   1:     ListTag(stdout);
   1:     char buf[400];
   1:     PR_snprintf(buf, sizeof(buf),
   1:                 ": %lld elapsed (%lld per line) (%d lines; %d new lines)",
   1:                 delta, perLineDelta, numLines, ectc - ctc);
   1:     printf("%s\n", buf);
   1:   }
   1: #endif
   1: 
   1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
   1:   return rv;
   1: }
   1: 
   1: PRBool
   1: nsBlockFrame::CheckForCollapsedBottomMarginFromClearanceLine()
   1: {
   1:   line_iterator begin = begin_lines();
   1:   line_iterator line = end_lines();
   1: 
   1:   while (PR_TRUE) {
   1:     if (begin == line) {
   1:       return PR_FALSE;
   1:     }
   1:     --line;
   1:     if (line->mBounds.height != 0 || !line->CachedIsEmpty()) {
   1:       return PR_FALSE;
   1:     }
   1:     if (line->HasClearance()) {
   1:       return PR_TRUE;
   1:     }
   1:   }
   1:   // not reached
   1: }
   1: 
   1: void
   1: nsBlockFrame::ComputeFinalSize(const nsHTMLReflowState& aReflowState,
   1:                                nsBlockReflowState&      aState,
   1:                                nsHTMLReflowMetrics&     aMetrics)
   1: {
   1:   const nsMargin& borderPadding = aState.BorderPadding();
   1: #ifdef NOISY_FINAL_SIZE
   1:   ListTag(stdout);
   1:   printf(": mY=%d mIsBottomMarginRoot=%s mPrevBottomMargin=%d bp=%d,%d\n",
   1:          aState.mY, aState.GetFlag(BRS_ISBOTTOMMARGINROOT) ? "yes" : "no",
   1:          aState.mPrevBottomMargin,
   1:          borderPadding.top, borderPadding.bottom);
   1: #endif
   1: 
   1:   // Compute final width
   1:   aMetrics.width = borderPadding.left + aReflowState.ComputedWidth() +
   1:     borderPadding.right;
   1: 
   1:   // Return bottom margin information
   1:   // rbs says he hit this assertion occasionally (see bug 86947), so
   1:   // just set the margin to zero and we'll figure out why later
   1:   //NS_ASSERTION(aMetrics.mCarriedOutBottomMargin.IsZero(),
   1:   //             "someone else set the margin");
   1:   nscoord nonCarriedOutVerticalMargin = 0;
   1:   if (!aState.GetFlag(BRS_ISBOTTOMMARGINROOT)) {
   1:     // Apply rule from CSS 2.1 section 8.3.1. If we have some empty
   1:     // line with clearance and a non-zero top margin and all
   1:     // subsequent lines are empty, then we do not allow our children's
   1:     // carried out bottom margin to be carried out of us and collapse
   1:     // with our own bottom margin.
   1:     if (CheckForCollapsedBottomMarginFromClearanceLine()) {
   1:       // Convert the children's carried out margin to something that
   1:       // we will include in our height
   1:       nonCarriedOutVerticalMargin = aState.mPrevBottomMargin.get();
   1:       aState.mPrevBottomMargin.Zero();
   1:     }
   1:     aMetrics.mCarriedOutBottomMargin = aState.mPrevBottomMargin;
   1:   } else {
   1:     aMetrics.mCarriedOutBottomMargin.Zero();
   1:   }
   1: 
   1:   // Compute final height
4166:   if (NS_UNCONSTRAINEDSIZE != aReflowState.ComputedHeight()) {
   1:     // Figure out how much of the computed height should be
   1:     // applied to this frame.
4166:     nscoord computedHeightLeftOver = aReflowState.ComputedHeight();
   1:     if (GetPrevInFlow()) {
   1:       // Reduce the height by the computed height of prev-in-flows.
   1:       for (nsIFrame* prev = GetPrevInFlow(); prev; prev = prev->GetPrevInFlow()) {
   1:         computedHeightLeftOver -= prev->GetRect().height;
   1:       }
   1:       // We just subtracted our top-border padding, since it was included in the
   1:       // first frame's height. Add it back to get the content height.
   1:       computedHeightLeftOver += aReflowState.mComputedBorderPadding.top;
   1:       // We may have stretched the frame beyond its computed height. Oh well.
   1:       computedHeightLeftOver = PR_MAX(0, computedHeightLeftOver);
   1:     }
6521:     NS_ASSERTION(!( IS_TRUE_OVERFLOW_CONTAINER(this)
4006:                     && computedHeightLeftOver ),
4006:                  "overflow container must not have computedHeightLeftOver");
4006: 
4006:     aMetrics.height = borderPadding.top + computedHeightLeftOver + borderPadding.bottom;
4006:     if (NS_FRAME_IS_NOT_COMPLETE(aState.mReflowStatus)
4006:         && aMetrics.height < aReflowState.availableHeight) {
4006:       // We ran out of height on this page but we're incomplete
4006:       // Set status to complete except for overflow
4006:       NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
4006:     }
   1: 
   1:     if (NS_FRAME_IS_COMPLETE(aState.mReflowStatus)) {
   1:       if (computedHeightLeftOver > 0 &&
4279:           NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight &&
   1:           aMetrics.height > aReflowState.availableHeight) {
   1:         // We don't fit and we consumed some of the computed height,
   1:         // so we should consume all the available height and then
   1:         // break.  If our bottom border/padding straddles the break
   1:         // point, then this will increase our height and push the
   1:         // border/padding to the next page/column.
3045:         aMetrics.height = PR_MAX(aReflowState.availableHeight,
3045:                                  aState.mY + nonCarriedOutVerticalMargin);
4006:         NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
4006:         if (!GetNextInFlow())
4006:           aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
   1:       }
   1:     }
   1:     else {
   1:       // Use the current height; continuations will take up the rest.
   1:       // Do extend the height to at least consume the available
   1:       // height, otherwise our left/right borders (for example) won't
   1:       // extend all the way to the break.
   1:       aMetrics.height = PR_MAX(aReflowState.availableHeight,
   1:                                aState.mY + nonCarriedOutVerticalMargin);
   1:       // ... but don't take up more height than is available
   1:       aMetrics.height = PR_MIN(aMetrics.height,
   1:                                borderPadding.top + computedHeightLeftOver);
   1:       // XXX It's pretty wrong that our bottom border still gets drawn on
   1:       // on its own on the last-in-flow, even if we ran out of height
   1:       // here. We need GetSkipSides to check whether we ran out of content
   1:       // height in the current frame, not whether it's last-in-flow.
   1:     }
   1: 
   1:     // Don't carry out a bottom margin when our height is fixed.
   1:     aMetrics.mCarriedOutBottomMargin.Zero();
   1:   }
   1:   else {
   1:     nscoord autoHeight = aState.mY + nonCarriedOutVerticalMargin;
   1: 
   1:     // Shrink wrap our height around our contents.
   1:     if (aState.GetFlag(BRS_ISBOTTOMMARGINROOT)) {
   1:       // When we are a bottom-margin root make sure that our last
   1:       // childs bottom margin is fully applied.
   1:       // Apply the margin only if there's space for it.
   1:       if (autoHeight < aState.mReflowState.availableHeight)
   1:       {
   1:         // Truncate bottom margin if it doesn't fit to our available height.
   1:         autoHeight = PR_MIN(autoHeight + aState.mPrevBottomMargin.get(), aState.mReflowState.availableHeight);
   1:       }
   1:     }
   1: 
   1:     if (aState.GetFlag(BRS_SPACE_MGR)) {
   1:       // Include the space manager's state to properly account for the
   1:       // bottom margin of any floated elements; e.g., inside a table cell.
7682:       nscoord floatHeight =
7682:         aState.ClearFloats(autoHeight, NS_STYLE_CLEAR_LEFT_AND_RIGHT);
7682:       autoHeight = PR_MAX(autoHeight, floatHeight);
   1:     }
   1: 
   1:     // Apply min/max values
   1:     autoHeight -= borderPadding.top;
   1:     nscoord oldAutoHeight = autoHeight;
   1:     aReflowState.ApplyMinMaxConstraints(nsnull, &autoHeight);
   1:     if (autoHeight != oldAutoHeight) {
   1:       // Our min-height or max-height made our height change.  Don't carry out
   1:       // our kids' bottom margins.
   1:       aMetrics.mCarriedOutBottomMargin.Zero();
   1:     }
   1:     autoHeight += borderPadding.top + borderPadding.bottom;
   1:     aMetrics.height = autoHeight;
   1:   }
   1: 
6521:   if (IS_TRUE_OVERFLOW_CONTAINER(this) &&
6521:       NS_FRAME_IS_NOT_COMPLETE(aState.mReflowStatus)) {
6521:     // Overflow containers can only be overflow complete.
6521:     // Note that auto height overflow containers have no normal children
6521:     NS_ASSERTION(aMetrics.height == 0, "overflow containers must be zero-height");
6521:     NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
6521:   }
6521: 
   1: #ifdef DEBUG_blocks
   1:   if (CRAZY_WIDTH(aMetrics.width) || CRAZY_HEIGHT(aMetrics.height)) {
   1:     ListTag(stdout);
   1:     printf(": WARNING: desired:%d,%d\n", aMetrics.width, aMetrics.height);
   1:   }
   1: #endif
   1: }
   1: 
   1: void
   1: nsBlockFrame::ComputeCombinedArea(const nsHTMLReflowState& aReflowState,
   1:                                   nsHTMLReflowMetrics& aMetrics)
   1: {
   1:   // Compute the combined area of our children
   1:   // XXX_perf: This can be done incrementally.  It is currently one of
   1:   // the things that makes incremental reflow O(N^2).
   1:   nsRect area(0, 0, aMetrics.width, aMetrics.height);
   1:   if (NS_STYLE_OVERFLOW_CLIP != aReflowState.mStyleDisplay->mOverflowX) {
   1:     for (line_iterator line = begin_lines(), line_end = end_lines();
   1:          line != line_end;
   1:          ++line) {
   1:       area.UnionRect(area, line->GetCombinedArea());
   1:     }
   1: 
   1:     // Factor the bullet in; normally the bullet will be factored into
   1:     // the line-box's combined area. However, if the line is a block
   1:     // line then it won't; if there are no lines, it won't. So just
   1:     // factor it in anyway (it can't hurt if it was already done).
   1:     // XXXldb Can we just fix GetCombinedArea instead?
   1:     if (mBullet) {
   1:       area.UnionRect(area, mBullet->GetRect());
   1:     }
   1:   }
   1: #ifdef NOISY_COMBINED_AREA
   1:   ListTag(stdout);
   1:   printf(": ca=%d,%d,%d,%d\n", area.x, area.y, area.width, area.height);
   1: #endif
   1: 
   1:   aMetrics.mOverflowArea = area;
   1: }
   1: 
   1: nsresult
   1: nsBlockFrame::MarkLineDirty(line_iterator aLine)
   1: {
   1:   // Mark aLine dirty
   1:   aLine->MarkDirty();
7719:   aLine->SetInvalidateTextRuns(PR_TRUE);
   1: #ifdef DEBUG
   1:   if (gNoisyReflow) {
   1:     IndentBy(stdout, gNoiseIndent);
   1:     ListTag(stdout);
3233:     printf(": mark line %p dirty\n", static_cast<void*>(aLine.get()));
   1:   }
   1: #endif
   1: 
   1:   // Mark previous line dirty if it's an inline line so that it can
   1:   // maybe pullup something from the line just affected.
   1:   // XXX We don't need to do this if aPrevLine ends in a break-after...
   1:   if (aLine != mLines.front() &&
   1:       aLine->IsInline() &&
   1:       aLine.prev()->IsInline()) {
   1:     aLine.prev()->MarkDirty();
7719:     aLine.prev()->SetInvalidateTextRuns(PR_TRUE);
   1: #ifdef DEBUG
   1:     if (gNoisyReflow) {
   1:       IndentBy(stdout, gNoiseIndent);
   1:       ListTag(stdout);
   1:       printf(": mark prev-line %p dirty\n",
3233:              static_cast<void*>(aLine.prev().get()));
   1:     }
   1: #endif
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsBlockFrame::PrepareResizeReflow(nsBlockReflowState& aState)
   1: {
   1:   // we need to calculate if any part of then block itself 
   1:   // is impacted by a float (bug 19579)
   1:   aState.GetAvailableSpace();
   1: 
   1:   const nsStyleText* styleText = GetStyleText();
   1:   // See if we can try and avoid marking all the lines as dirty
   1:   PRBool tryAndSkipLines =
   1:       // There must be no floats.
   1:       !aState.IsImpactedByFloat() &&
   1:       // The text must be left-aligned.
   1:       (NS_STYLE_TEXT_ALIGN_LEFT == styleText->mTextAlign ||
   1:        (NS_STYLE_TEXT_ALIGN_DEFAULT == styleText->mTextAlign &&
   1:         NS_STYLE_DIRECTION_LTR ==
   1:           aState.mReflowState.mStyleVisibility->mDirection)) &&
   1:       // The left content-edge must be a constant distance from the left
   1:       // border-edge.
   1:       GetStylePadding()->mPadding.GetLeftUnit() != eStyleUnit_Percent;
   1: 
   1: #ifdef DEBUG
   1:   if (gDisableResizeOpt) {
   1:     tryAndSkipLines = PR_FALSE;
   1:   }
   1:   if (gNoisyReflow) {
   1:     if (!tryAndSkipLines) {
   1:       IndentBy(stdout, gNoiseIndent);
   1:       ListTag(stdout);
   1:       printf(": marking all lines dirty: availWidth=%d textAlign=%d\n",
   1:              aState.mReflowState.availableWidth,
   1:              styleText->mTextAlign);
   1:     }
   1:   }
   1: #endif
   1: 
   1:   if (tryAndSkipLines) {
   1:     nscoord newAvailWidth = aState.mReflowState.mComputedBorderPadding.left +
   1:                             aState.mReflowState.ComputedWidth();
   1:     NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aState.mReflowState.mComputedBorderPadding.left &&
   1:                  NS_UNCONSTRAINEDSIZE != aState.mReflowState.ComputedWidth(),
   1:                  "math on NS_UNCONSTRAINEDSIZE");
   1: 
   1: #ifdef DEBUG
   1:     if (gNoisyReflow) {
   1:       IndentBy(stdout, gNoiseIndent);
   1:       ListTag(stdout);
   1:       printf(": trying to avoid marking all lines dirty\n");
   1:     }
   1: #endif
   1: 
   1:     for (line_iterator line = begin_lines(), line_end = end_lines();
   1:          line != line_end;
   1:          ++line)
   1:     {
   1:       // We let child blocks make their own decisions the same
   1:       // way we are here.
   1:       if (line->IsBlock() ||
   1:           line->HasFloats() ||
   1:           (line != mLines.back() && !line->HasBreakAfter()) ||
   1:           line->ResizeReflowOptimizationDisabled() ||
   1:           line->IsImpactedByFloat() ||
   1:           (line->mBounds.XMost() > newAvailWidth)) {
   1:         line->MarkDirty();
   1:       }
   1: 
   1: #ifdef REALLY_NOISY_REFLOW
   1:       if (!line->IsBlock()) {
   1:         printf("PrepareResizeReflow thinks line %p is %simpacted by floats\n", 
   1:                line.get(), line->IsImpactedByFloat() ? "" : "not ");
   1:       }
   1: #endif
   1: #ifdef DEBUG
   1:       if (gNoisyReflow && !line->IsDirty()) {
   1:         IndentBy(stdout, gNoiseIndent + 1);
   1:         printf("skipped: line=%p next=%p %s %s%s%s breakTypeBefore/After=%d/%d xmost=%d\n",
3233:            static_cast<void*>(line.get()),
3233:            static_cast<void*>((line.next() != end_lines() ? line.next().get() : nsnull)),
   1:            line->IsBlock() ? "block" : "inline",
   1:            line->HasBreakAfter() ? "has-break-after " : "",
   1:            line->HasFloats() ? "has-floats " : "",
   1:            line->IsImpactedByFloat() ? "impacted " : "",
   1:            line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
   1:            line->mBounds.XMost());
   1:       }
   1: #endif
   1:     }
   1:   }
   1:   else {
   1:     // Mark everything dirty
   1:     for (line_iterator line = begin_lines(), line_end = end_lines();
   1:          line != line_end;
   1:          ++line)
   1:     {
   1:       line->MarkDirty();
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: //----------------------------------------
   1: 
   1: nsBlockFrame::line_iterator
   1: nsBlockFrame::FindLineFor(nsIFrame* aFrame)
   1: {
   1:   NS_PRECONDITION(aFrame, "why pass a null frame?");
   1:   line_iterator line = begin_lines(),
   1:                 line_end = end_lines();
   1:   for ( ; line != line_end; ++line) {
   1:     // If the target frame is in-flow, and this line contains the it,
   1:     // then we've found our line.
   1:     if (line->Contains(aFrame))
   1:       return line;
   1: 
   1:     // If the target frame is floated, and this line contains the
   1:     // float's placeholder, then we've found our line.
   1:     if (line->HasFloats()) {
   1:       for (nsFloatCache *fc = line->GetFirstFloat();
   1:            fc != nsnull;
   1:            fc = fc->Next()) {
   1:         if (aFrame == fc->mPlaceholder->GetOutOfFlowFrame())
   1:           return line;
   1:       }
   1:     }
   1:   }
   1: 
   1:   return line_end;
   1: }
   1: 
   1: /**
   1:  * Propagate reflow "damage" from from earlier lines to the current
   1:  * line.  The reflow damage comes from the following sources:
   1:  *  1. The regions of float damage remembered during reflow.
   1:  *  2. The combination of nonzero |aDeltaY| and any impact by a float,
   1:  *     either the previous reflow or now.
   1:  *
   1:  * When entering this function, |aLine| is still at its old position and
   1:  * |aDeltaY| indicates how much it will later be slid (assuming it
   1:  * doesn't get marked dirty and reflowed entirely).
   1:  */
   1: void
   1: nsBlockFrame::PropagateFloatDamage(nsBlockReflowState& aState,
   1:                                    nsLineBox* aLine,
   1:                                    nscoord aDeltaY)
   1: {
4831:   nsSpaceManager *spaceManager = aState.mReflowState.mSpaceManager;
4831:   NS_ASSERTION((aState.mReflowState.parentReflowState &&
4831:                 aState.mReflowState.parentReflowState->mSpaceManager == spaceManager) ||
4831:                 aState.mReflowState.mBlockDelta == 0, "Bad block delta passed in");
4831: 
4831:   // Check to see if there are any floats; if there aren't, there can't
4831:   // be any float damage
4831:   if (!spaceManager->HasAnyFloats())
4831:     return;
   1: 
   1:   // Check the damage region recorded in the float damage.
   1:   if (spaceManager->HasFloatDamage()) {
7668:     // Need to check mBounds *and* mCombinedArea to find intersections 
7668:     // with aLine's floats
   1:     nscoord lineYA = aLine->mBounds.y + aDeltaY;
   1:     nscoord lineYB = lineYA + aLine->mBounds.height;
7668:     nscoord lineYCombinedA = aLine->GetCombinedArea().y + aDeltaY;
7668:     nscoord lineYCombinedB = lineYCombinedA + aLine->GetCombinedArea().height;
7668:     if (spaceManager->IntersectsDamage(lineYA, lineYB) ||
7668:         spaceManager->IntersectsDamage(lineYCombinedA, lineYCombinedB)) {
   1:       aLine->MarkDirty();
   1:       return;
   1:     }
   1:   }
   1: 
4831:   // Check if the line is moving relative to the space manager
4831:   if (aDeltaY + aState.mReflowState.mBlockDelta != 0) {
4831:     if (aLine->IsBlock()) {
4831:       // Unconditionally reflow sliding blocks; we only really need to reflow
4831:       // if there's a float impacting this block, but the current space manager
4831:       // makes it difficult to check that.  Therefore, we let the child block
4831:       // decide what it needs to reflow.
4831:       aLine->MarkDirty();
4831:     } else {
4831:       // Note that this check will become incorrect once bug 25888 is fixed
4831:       // because we are only checking the top of the line
   1:       aState.GetAvailableSpace(aLine->mBounds.y + aDeltaY, PR_FALSE);
   1:       PRBool wasImpactedByFloat = aLine->IsImpactedByFloat();
   1:       PRBool isImpactedByFloat = aState.IsImpactedByFloat();
4831: 
   1: #ifdef REALLY_NOISY_REFLOW
   1:     printf("nsBlockFrame::PropagateFloatDamage %p was = %d, is=%d\n", 
   1:        this, wasImpactedByFloat, isImpactedByFloat);
   1: #endif
4831: 
4831:       // Mark the line dirty if it was or is affected by a float
4831:       // We actually only really need to reflow if the amount of impact
4831:       // changes, but that's not straightforward to check
4831:       if (wasImpactedByFloat || isImpactedByFloat) {
   1:         aLine->MarkDirty();
   1:       }
   1:     }
   1:   }
4831: }
   1: 
   1: static void PlaceFrameView(nsIFrame* aFrame);
   1: 
   1: static PRBool LineHasClear(nsLineBox* aLine) {
   1:   return aLine->GetBreakTypeBefore() || aLine->HasFloatBreakAfter()
   1:     || (aLine->IsBlock() && (aLine->mFirstChild->GetStateBits() & NS_BLOCK_HAS_CLEAR_CHILDREN));
   1: }
   1: 
   1: 
   1: /**
   1:  * Reparent a whole list of floats from aOldParent to this block.  The
   1:  * floats might be taken from aOldParent's overflow list. They will be
   1:  * removed from the list. They end up appended to our mFloats list.
   1:  */
   1: void
   1: nsBlockFrame::ReparentFloats(nsIFrame* aFirstFrame,
 686:                              nsBlockFrame* aOldParent, PRBool aFromOverflow,
 686:                              PRBool aReparentSiblings) {
   1:   nsFrameList list;
   1:   nsIFrame* tail = nsnull;
 686:   aOldParent->CollectFloats(aFirstFrame, list, &tail, aFromOverflow, aReparentSiblings);
   1:   if (list.NotEmpty()) {
   1:     for (nsIFrame* f = list.FirstChild(); f; f = f->GetNextSibling()) {
   1:       ReparentFrame(f, aOldParent, this);
   1:     }
   1:     mFloats.AppendFrames(nsnull, list.FirstChild());
   1:   }
   1: }
   1: 
   1: static void DumpLine(const nsBlockReflowState& aState, nsLineBox* aLine,
   1:                      nscoord aDeltaY, PRInt32 aDeltaIndent) {
   1: #ifdef DEBUG
   1:   if (nsBlockFrame::gNoisyReflow) {
   1:     nsRect lca(aLine->GetCombinedArea());
   1:     nsBlockFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent + aDeltaIndent);
   1:     printf("line=%p mY=%d dirty=%s oldBounds={%d,%d,%d,%d} oldCombinedArea={%d,%d,%d,%d} deltaY=%d mPrevBottomMargin=%d childCount=%d\n",
3233:            static_cast<void*>(aLine), aState.mY,
   1:            aLine->IsDirty() ? "yes" : "no",
   1:            aLine->mBounds.x, aLine->mBounds.y,
   1:            aLine->mBounds.width, aLine->mBounds.height,
   1:            lca.x, lca.y, lca.width, lca.height,
   1:            aDeltaY, aState.mPrevBottomMargin.get(), aLine->GetChildCount());
   1:   }
   1: #endif
   1: }
   1: 
   1: /**
   1:  * Reflow the dirty lines
   1:  */
   1: nsresult
   1: nsBlockFrame::ReflowDirtyLines(nsBlockReflowState& aState)
   1: {
   1:   nsresult rv = NS_OK;
   1:   PRBool keepGoing = PR_TRUE;
   1:   PRBool repositionViews = PR_FALSE; // should we really need this?
   1:   PRBool foundAnyClears = PR_FALSE;
8457:   PRBool willReflowAgain = PR_FALSE;
   1: 
   1: #ifdef DEBUG
   1:   if (gNoisyReflow) {
   1:     IndentBy(stdout, gNoiseIndent);
   1:     ListTag(stdout);
   1:     printf(": reflowing dirty lines");
   1:     printf(" computedWidth=%d\n", aState.mReflowState.ComputedWidth());
   1:   }
   1:   AutoNoisyIndenter indent(gNoisyReflow);
   1: #endif
   1: 
   1:   PRBool selfDirty = (GetStateBits() & NS_FRAME_IS_DIRTY) ||
   1:                      (aState.mReflowState.mFlags.mVResize &&
   1:                       (GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT));
   1:   
   1:     // the amount by which we will slide the current line if it is not
   1:     // dirty
   1:   nscoord deltaY = 0;
   1: 
   1:     // whether we did NOT reflow the previous line and thus we need to
   1:     // recompute the carried out margin before the line if we want to
   1:     // reflow it or if its previous margin is dirty
   1:   PRBool needToRecoverState = PR_FALSE;
   1:   PRBool reflowedFloat = PR_FALSE;
   1:   PRBool lastLineMovedUp = PR_FALSE;
   1:   // We save up information about BR-clearance here
   1:   PRUint8 inlineFloatBreakType = NS_STYLE_CLEAR_NONE;
   1: 
   1:   line_iterator line = begin_lines(), line_end = end_lines();
   1: 
   1:   // Reflow the lines that are already ours
   1:   for ( ; line != line_end; ++line, aState.AdvanceToNextLine()) {
   1:     DumpLine(aState, line, deltaY, 0);
   1: #ifdef DEBUG
   1:     AutoNoisyIndenter indent2(gNoisyReflow);
   1: #endif
   1: 
   1:     if (selfDirty)
   1:       line->MarkDirty();
   1: 
   1:     // This really sucks, but we have to look inside any blocks that have clear
   1:     // elements inside them.
   1:     // XXX what can we do smarter here?
   1:     if (!line->IsDirty() && line->IsBlock() &&
   1:         (line->mFirstChild->GetStateBits() & NS_BLOCK_HAS_CLEAR_CHILDREN)) {
   1:       line->MarkDirty();
   1:     }
   1: 
   1:     // We have to reflow the line if it's a block whose clearance
   1:     // might have changed, so detect that.
   1:     if (!line->IsDirty() && line->GetBreakTypeBefore() != NS_STYLE_CLEAR_NONE) {
   1:       nscoord curY = aState.mY;
   1:       // See where we would be after applying any clearance due to
   1:       // BRs.
   1:       if (inlineFloatBreakType != NS_STYLE_CLEAR_NONE) {
   1:         curY = aState.ClearFloats(curY, inlineFloatBreakType);
   1:       }
   1: 
   1:       nscoord newY = aState.ClearFloats(curY, line->GetBreakTypeBefore());
   1:       
   1:       if (line->HasClearance()) {
   1:         // Reflow the line if it might not have clearance anymore.
   1:         if (newY == curY
   1:             // aState.mY is the clearance point which should be the
   1:             // top border-edge of the block frame. If sliding the
   1:             // block by deltaY isn't going to put it in the predicted
   1:             // position, then we'd better reflow the line.
   1:             || newY != line->mBounds.y + deltaY) {
   1:           line->MarkDirty();
   1:         }
   1:       } else {
   1:         // Reflow the line if the line might have clearance now.
   1:         if (curY != newY) {
   1:           line->MarkDirty();
   1:         }
   1:       }
   1:     }
   1: 
   1:     // We might have to reflow a line that is after a clearing BR.
   1:     if (inlineFloatBreakType != NS_STYLE_CLEAR_NONE) {
   1:       aState.mY = aState.ClearFloats(aState.mY, inlineFloatBreakType);
   1:       if (aState.mY != line->mBounds.y + deltaY) {
   1:         // SlideLine is not going to put the line where the clearance
   1:         // put it. Reflow the line to be sure.
   1:         line->MarkDirty();
   1:       }
   1:       inlineFloatBreakType = NS_STYLE_CLEAR_NONE;
   1:     }
   1: 
   1:     PRBool previousMarginWasDirty = line->IsPreviousMarginDirty();
   1:     if (previousMarginWasDirty) {
   1:       // If the previous margin is dirty, reflow the current line
   1:       line->MarkDirty();
   1:       line->ClearPreviousMarginDirty();
   1:     } else if (line->mBounds.YMost() + deltaY > aState.mBottomEdge) {
   1:       // Lines that aren't dirty but get slid past our height constraint must
   1:       // be reflowed.
   1:       line->MarkDirty();
   1:     }
   1: 
   1:     if (!line->IsDirty()) {
   1:       // See if there's any reflow damage that requires that we mark the
   1:       // line dirty.
   1:       PropagateFloatDamage(aState, line, deltaY);
   1:     }
   1: 
   1:     if (needToRecoverState && line->IsDirty()) {
   1:       // We need to reconstruct the bottom margin only if we didn't
   1:       // reflow the previous line and we do need to reflow (or repair
   1:       // the top position of) the next line.
   1:       aState.ReconstructMarginAbove(line);
   1:     }
   1: 
   1:     if (needToRecoverState) {
   1:       needToRecoverState = PR_FALSE;
   1: 
   1:       // Update aState.mPrevChild as if we had reflowed all of the frames in
   1:       // this line.  This is expensive in some cases, since it requires
   1:       // walking |GetNextSibling|.
   1:       if (line->IsDirty())
   1:         aState.mPrevChild = line.prev()->LastChild();
   1:     }
   1: 
   1:     // Now repair the line and update |aState.mY| by calling
   1:     // |ReflowLine| or |SlideLine|.
8512:     // If we're going to reflow everything again, then no need to reflow
8512:     // the dirty line ... unless the line has floats, in which case we'd
8512:     // better reflow it now to refresh its float cache, which may contain
8512:     // dangling frame pointers! Ugh! This reflow of the line may be
8512:     // incorrect because we skipped reflowing previous lines (e.g., floats
8512:     // may be placed incorrectly), but that's OK because we'll mark the
8512:     // line dirty below under "if (aState.mReflowState.mDiscoveredClearance..."
8512:     if (line->IsDirty() && (line->HasFloats() || !willReflowAgain)) {
   1:       lastLineMovedUp = PR_TRUE;
   1: 
   1:       PRBool maybeReflowingForFirstTime =
   1:         line->mBounds.x == 0 && line->mBounds.y == 0 &&
   1:         line->mBounds.width == 0 && line->mBounds.height == 0;
   1: 
   1:       // Compute the dirty lines "before" YMost, after factoring in
   1:       // the running deltaY value - the running value is implicit in
   1:       // aState.mY.
   1:       nscoord oldY = line->mBounds.y;
   1:       nscoord oldYMost = line->mBounds.YMost();
   1: 
   1:       // Reflow the dirty line. If it's an incremental reflow, then force
   1:       // it to invalidate the dirty area if necessary
   1:       rv = ReflowLine(aState, line, &keepGoing);
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1: 
8457:       if (aState.mReflowState.mDiscoveredClearance &&
8457:           *aState.mReflowState.mDiscoveredClearance) {
8457:         line->MarkDirty();
8457:         willReflowAgain = PR_TRUE;
8512:         // Note that once we've entered this state, every line that gets here
8512:         // (e.g. because it has floats) gets marked dirty and reflowed again.
8512:         // in the next pass. This is important, see above.
8457:       }
8457: 
   1:       if (line->HasFloats()) {
   1:         reflowedFloat = PR_TRUE;
   1:       }
   1: 
   1:       if (!keepGoing) {
   1:         DumpLine(aState, line, deltaY, -1);
   1:         if (0 == line->GetChildCount()) {
   1:           DeleteLine(aState, line, line_end);
   1:         }
   1:         break;
   1:       }
   1: 
   1:       // Test to see whether the margin that should be carried out
   1:       // to the next line (NL) might have changed. In ReflowBlockFrame
   1:       // we call nextLine->MarkPreviousMarginDirty if the block's
   1:       // actual carried-out bottom margin changed. So here we only
   1:       // need to worry about the following effects:
   1:       // 1) the line was just created, and it might now be blocking
   1:       // a carried-out bottom margin from previous lines that
   1:       // used to reach NL from reaching NL
   1:       // 2) the line used to be empty, and is now not empty,
   1:       // thus blocking a carried-out bottom margin from previous lines
   1:       // that used to reach NL from reaching NL
   1:       // 3) the line wasn't empty, but now is, so a carried-out
   1:       // bottom margin from previous lines that didn't used to reach NL
   1:       // now does
   1:       // 4) the line might have changed in a way that affects NL's
   1:       // ShouldApplyTopMargin decision. The three things that matter
   1:       // are the line's emptiness, its adjacency to the top of the block,
   1:       // and whether it has clearance (the latter only matters if the block
   1:       // was and is adjacent to the top and empty).
   1:       //
   1:       // If the line is empty now, we can't reliably tell if the line was empty
   1:       // before, so we just assume it was and do nextLine->MarkPreviousMarginDirty.
   1:       // This means the checks in 4) are redundant; if the line is empty now
   1:       // we don't need to check 4), but if the line is not empty now and we're sure
   1:       // it wasn't empty before, any adjacency and clearance changes are irrelevant
   1:       // to the result of nextLine->ShouldApplyTopMargin.
   1:       if (line.next() != end_lines()) {
8048:         PRBool maybeWasEmpty = oldY == line.next()->mBounds.y;
   1:         PRBool isEmpty = line->mBounds.height == 0 && line->CachedIsEmpty();
   1:         if (maybeReflowingForFirstTime /*1*/ ||
   1:             (isEmpty || maybeWasEmpty) /*2/3/4*/) {
   1:           line.next()->MarkPreviousMarginDirty();
   1:           // since it's marked dirty, nobody will care about |deltaY|
   1:         }
   1:       }
   1: 
   1:       // If the line was just reflowed for the first time, then its
   1:       // old mBounds cannot be trusted so this deltaY computation is
   1:       // bogus. But that's OK because we just did
   1:       // MarkPreviousMarginDirty on the next line which will force it
   1:       // to be reflowed, so this computation of deltaY will not be
   1:       // used.
   1:       deltaY = line->mBounds.YMost() - oldYMost;
   1:     } else {
4006:       aState.mOverflowTracker.Skip(line->mFirstChild, aState.mReflowStatus);
4006:         // Nop except for blocks (we don't create overflow container
4006:         // continuations for any inlines atm), so only checking mFirstChild
4006:         // is enough
4006: 
   1:       lastLineMovedUp = deltaY < 0;
   1: 
   1:       if (deltaY != 0)
   1:         SlideLine(aState, line, deltaY);
   1:       else
   1:         repositionViews = PR_TRUE;
   1: 
8512:       if (willReflowAgain) {
8512:         NS_ASSERTION(!line->HasFloats(), "Possibly stale float cache here!");
8512:         // If we're going to reflow everything again, and this line has no
8512:         // cached floats, then there is no need to recover float state. The line
8512:         // may be a block that contains other lines with floats, but in that
8512:         // case RecoverStateFrom would only add floats to the space manager.
8512:         // We don't need to do that because everything's going to get reflowed
8512:         // again "for real". Calling RecoverStateFrom in this situation could
8512:         // be lethal because the block's descendant lines may have float
8512:         // caches containing dangling frame pointers. Ugh!
8512:       } else {
   1:         // XXX EVIL O(N^2) EVIL
   1:         aState.RecoverStateFrom(line, deltaY);
8512:       }
   1: 
   1:       // Keep mY up to date in case we're propagating reflow damage
   1:       // and also because our final height may depend on it. If the
   1:       // line is inlines, then only update mY if the line is not
   1:       // empty, because that's what PlaceLine does. (Empty blocks may
   1:       // want to update mY, e.g. if they have clearance.)
   1:       if (line->IsBlock() || !line->CachedIsEmpty()) {
   1:         aState.mY = line->mBounds.YMost();
   1:       }
   1: 
   1:       needToRecoverState = PR_TRUE;
   1:     }
   1: 
   1:     // Record if we need to clear floats before reflowing the next
   1:     // line. Note that inlineFloatBreakType will be handled and
   1:     // cleared before the next line is processed, so there is no
   1:     // need to combine break types here.
   1:     if (line->HasFloatBreakAfter()) {
   1:       inlineFloatBreakType = line->GetBreakTypeAfter();
   1:     }
   1: 
   1:     if (LineHasClear(line.get())) {
   1:       foundAnyClears = PR_TRUE;
   1:     }
   1: 
   1:     DumpLine(aState, line, deltaY, -1);
   1:   }
   1: 
   1:   // Handle BR-clearance from the last line of the block
   1:   if (inlineFloatBreakType != NS_STYLE_CLEAR_NONE) {
   1:     aState.mY = aState.ClearFloats(aState.mY, inlineFloatBreakType);
   1:   }
   1: 
   1:   if (needToRecoverState) {
   1:     // Is this expensive?
   1:     aState.ReconstructMarginAbove(line);
   1: 
   1:     // Update aState.mPrevChild as if we had reflowed all of the frames in
   1:     // the last line.  This is expensive in some cases, since it requires
   1:     // walking |GetNextSibling|.
   1:     aState.mPrevChild = line.prev()->LastChild();
   1:   }
   1: 
   1:   // Should we really have to do this?
   1:   if (repositionViews)
   1:     ::PlaceFrameView(this);
   1: 
   1:   // We can skip trying to pull up the next line if there is no next
   1:   // in flow or we were told not to or we know it will be futile, i.e.,
   1:   // -- the next in flow is not changing
   1:   // -- and we cannot have added more space for its first line to be
   1:   // pulled up into,
   1:   // -- it's an incremental reflow of a descendant
   1:   // -- and we didn't reflow any floats (so the available space
   1:   // didn't change)
6260:   // -- my chain of next-in-flows either has no first line, or its first
6260:   // line isn't dirty.
8457:   PRBool skipPull = willReflowAgain;
4006:   if (aState.mNextInFlow &&
   1:       (aState.mReflowState.mFlags.mNextInFlowUntouched &&
   1:        !lastLineMovedUp && 
   1:        !(GetStateBits() & NS_FRAME_IS_DIRTY) &&
   1:        !reflowedFloat)) {
6260:     // We'll place lineIter at the last line of this block, so that 
6260:     // nsBlockInFlowLineIterator::Next() will take us to the first
6260:     // line of my next-in-flow-chain.  (But first, check that I 
6260:     // have any lines -- if I don't, just bail out of this
6260:     // optimization.) 
6260:     line_iterator lineIter = this->end_lines();
6260:     if (lineIter != this->begin_lines()) {
6260:       lineIter--; // I have lines; step back from dummy iterator to last line.
6260:       nsBlockInFlowLineIterator bifLineIter(this, lineIter, PR_FALSE);
6260: 
6260:       // Check for next-in-flow-chain's first line.
6260:       // (First, see if there is such a line, and second, see if it's clean)
6260:       if (!bifLineIter.Next() ||                
6260:           !bifLineIter.GetLine()->IsDirty()) {
6521:         if (IS_TRUE_OVERFLOW_CONTAINER(aState.mNextInFlow))
6521:           NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
6521:         else
4006:           NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
6260:         skipPull=PR_TRUE;
6260:       }
6260:     }
6260:   }
6260:   
6260:   if (!skipPull && aState.mNextInFlow) {
   1:     // Pull data from a next-in-flow if there's still room for more
   1:     // content here.
   1:     while (keepGoing && (nsnull != aState.mNextInFlow)) {
   1:       // Grab first line from our next-in-flow
   1:       nsBlockFrame* nextInFlow = aState.mNextInFlow;
   1:       line_iterator nifLine = nextInFlow->begin_lines();
   1:       nsLineBox *toMove;
   1:       PRBool collectOverflowFloats;
   1:       if (nifLine != nextInFlow->end_lines()) {
   1:         if (HandleOverflowPlaceholdersOnPulledLine(aState, nifLine)) {
   1:           // go around again in case the line was deleted
   1:           continue;
   1:         }
   1:         toMove = nifLine;
   1:         nextInFlow->mLines.erase(nifLine);
   1:         collectOverflowFloats = PR_FALSE;
   1:       } else {
   1:         // Grab an overflow line if there are any
   1:         nsLineList* overflowLines = nextInFlow->GetOverflowLines();
   1:         if (overflowLines &&
   1:             HandleOverflowPlaceholdersOnPulledLine(aState, overflowLines->front())) {
   1:           // go around again in case the line was deleted
   1:           continue;
   1:         }
   1:         if (!overflowLines) {
   1:           aState.mNextInFlow =
3233:             static_cast<nsBlockFrame*>(nextInFlow->GetNextInFlow());
   1:           continue;
   1:         }
   1:         nifLine = overflowLines->begin();
   1:         NS_ASSERTION(nifLine != overflowLines->end(),
   1:                      "Stored overflow line list should not be empty");
   1:         toMove = nifLine;
   1:         nextInFlow->RemoveOverflowLines();
   1:         nifLine = overflowLines->erase(nifLine);
   1:         if (nifLine != overflowLines->end()) {
   1:           // We need to this remove-and-put-back dance because we want
   1:           // to avoid making the overflow line list empty while it's
   1:           // stored in the property (because the property has the
   1:           // invariant that the list is never empty).
   1:           nextInFlow->SetOverflowLines(overflowLines);
   1:         }
   1:         collectOverflowFloats = PR_TRUE;
   1:       }
   1: 
   1:       if (0 == toMove->GetChildCount()) {
   1:         // The line is empty. Try the next one.
   1:         NS_ASSERTION(nsnull == toMove->mFirstChild, "bad empty line");
   1:         aState.FreeLineBox(toMove);
   1:         continue;
   1:       }
   1: 
   1:       // XXX move to a subroutine: run-in, overflow, pullframe and this do this
   1:       // Make the children in the line ours.
   1:       nsIFrame* frame = toMove->mFirstChild;
   1:       nsIFrame* lastFrame = nsnull;
   1:       PRInt32 n = toMove->GetChildCount();
   1:       while (--n >= 0) {
   1:         ReparentFrame(frame, nextInFlow, this);
   1:         lastFrame = frame;
   1:         frame = frame->GetNextSibling();
   1:       }
   1:       lastFrame->SetNextSibling(nsnull);
   1: 
   1:       // Reparent floats whose placeholders are in the line.
 686:       ReparentFloats(toMove->mFirstChild, nextInFlow, collectOverflowFloats, PR_TRUE);
   1: 
   1:       // Add line to our line list
   1:       if (aState.mPrevChild) {
   1:         aState.mPrevChild->SetNextSibling(toMove->mFirstChild);
   1:       }
   1: 
   1:       line = mLines.before_insert(end_lines(), toMove);
   1: 
   1:       DumpLine(aState, toMove, deltaY, 0);
   1: #ifdef DEBUG
   1:       AutoNoisyIndenter indent2(gNoisyReflow);
   1: #endif
   1: 
   1:       // Now reflow it and any lines that it makes during it's reflow
   1:       // (we have to loop here because reflowing the line may case a new
   1:       // line to be created; see SplitLine's callers for examples of
   1:       // when this happens).
   1:       while (line != end_lines()) {
   1:         rv = ReflowLine(aState, line, &keepGoing);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:         DumpLine(aState, line, deltaY, -1);
   1:         if (!keepGoing) {
   1:           if (0 == line->GetChildCount()) {
   1:             DeleteLine(aState, line, line_end);
   1:           }
   1:           break;
   1:         }
   1: 
   1:         if (LineHasClear(line.get())) {
   1:           foundAnyClears = PR_TRUE;
   1:         }
   1: 
   1:         // If this is an inline frame then its time to stop
   1:         ++line;
   1:         aState.AdvanceToNextLine();
   1:       }
   1:     }
   1: 
   1:     if (NS_FRAME_IS_NOT_COMPLETE(aState.mReflowStatus)) {
   1:       aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
4006:     } //XXXfr shouldn't set this flag when nextinflow has no lines
   1:   }
   1: 
   1:   // Handle an odd-ball case: a list-item with no lines
   1:   if (mBullet && HaveOutsideBullet() && mLines.empty()) {
   1:     nsHTMLReflowMetrics metrics;
   1:     ReflowBullet(aState, metrics);
   1: 
   1:     // There are no lines so we have to fake up some y motion so that
   1:     // we end up with *some* height.
   1:     aState.mY += metrics.height;
   1:   }
   1: 
   1:   if (foundAnyClears) {
   1:     AddStateBits(NS_BLOCK_HAS_CLEAR_CHILDREN);
   1:   } else {
   1:     RemoveStateBits(NS_BLOCK_HAS_CLEAR_CHILDREN);
   1:   }
   1: 
   1: #ifdef DEBUG
   1:   if (gNoisyReflow) {
   1:     IndentBy(stdout, gNoiseIndent - 1);
   1:     ListTag(stdout);
   1:     printf(": done reflowing dirty lines (status=%x)\n",
   1:            aState.mReflowStatus);
   1:   }
   1: #endif
   1: 
   1:   return rv;
   1: }
   1: 
   1: void
   1: nsBlockFrame::DeleteLine(nsBlockReflowState& aState,
   1:                          nsLineList::iterator aLine,
   1:                          nsLineList::iterator aLineEnd)
   1: {
   1:   NS_PRECONDITION(0 == aLine->GetChildCount(), "can't delete !empty line");
   1:   if (0 == aLine->GetChildCount()) {
   1:     NS_ASSERTION(aState.mCurrentLine == aLine,
   1:                  "using function more generally than designed, "
   1:                  "but perhaps OK now");
   1:     nsLineBox *line = aLine;
   1:     aLine = mLines.erase(aLine);
   1:     aState.FreeLineBox(line);
   1:     // Mark the previous margin of the next line dirty since we need to
   1:     // recompute its top position.
   1:     if (aLine != aLineEnd)
   1:       aLine->MarkPreviousMarginDirty();
   1:   }
   1: }
   1: 
   1: /**
   1:  * Takes two rectangles whose origins must be the same, and computes
   1:  * the difference between their union and their intersection as two
   1:  * rectangles. (This difference is a superset of the difference
   1:  * between the two rectangles.)
   1:  */
   1: static void GetRectDifferenceStrips(const nsRect& aR1, const nsRect& aR2,
   1:                                     nsRect* aHStrip, nsRect* aVStrip) {
   1:   NS_ASSERTION(aR1.TopLeft() == aR2.TopLeft(),
   1:                "expected rects at the same position");
   1:   nsRect unionRect(aR1.x, aR1.y, PR_MAX(aR1.width, aR2.width),
   1:                    PR_MAX(aR1.height, aR2.height));
   1:   nscoord VStripStart = PR_MIN(aR1.width, aR2.width);
   1:   nscoord HStripStart = PR_MIN(aR1.height, aR2.height);
   1:   *aVStrip = unionRect;
   1:   aVStrip->x += VStripStart;
   1:   aVStrip->width -= VStripStart;
   1:   *aHStrip = unionRect;
   1:   aHStrip->y += HStripStart;
   1:   aHStrip->height -= HStripStart;
   1: }
   1: 
   1: /**
   1:  * Reflow a line. The line will either contain a single block frame
   1:  * or contain 1 or more inline frames. aKeepReflowGoing indicates
   1:  * whether or not the caller should continue to reflow more lines.
   1:  */
   1: nsresult
   1: nsBlockFrame::ReflowLine(nsBlockReflowState& aState,
   1:                          line_iterator aLine,
   1:                          PRBool* aKeepReflowGoing)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1:   NS_ABORT_IF_FALSE(aLine->GetChildCount(), "reflowing empty line");
   1: 
   1:   // Setup the line-layout for the new line
   1:   aState.mCurrentLine = aLine;
   1:   aLine->ClearDirty();
   1:   aLine->InvalidateCachedIsEmpty();
   1:   
   1:   // Now that we know what kind of line we have, reflow it
   1:   if (aLine->IsBlock()) {
   1:     nsRect oldBounds = aLine->mFirstChild->GetRect();
   1:     nsRect oldCombinedArea(aLine->GetCombinedArea());
   1:     rv = ReflowBlockFrame(aState, aLine, aKeepReflowGoing);
   1:     nsRect newBounds = aLine->mFirstChild->GetRect();
   1: 
   1:     // We expect blocks to damage any area inside their bounds that is
   1:     // dirty; however, if the frame changes size or position then we
   1:     // need to do some repainting.
   1:     // XXX roc --- the above statement is ambiguous about whether 'bounds'
   1:     // means the frame's bounds or overflowArea, and in fact this is a source
   1:     // of much confusion and bugs. Thus the following hack considers *both*
   1:     // overflowArea and bounds. This should be considered a temporary hack
   1:     // until we decide how it's really supposed to work.
   1:     nsRect lineCombinedArea(aLine->GetCombinedArea());
   1:     if (oldCombinedArea.TopLeft() != lineCombinedArea.TopLeft() ||
   1:         oldBounds.TopLeft() != newBounds.TopLeft()) {
   1:       // The block has moved, and so to be safe we need to repaint
   1:       // XXX We need to improve on this...
   1:       nsRect  dirtyRect;
   1:       dirtyRect.UnionRect(oldCombinedArea, lineCombinedArea);
   1: #ifdef NOISY_BLOCK_INVALIDATE
   1:       printf("%p invalidate 6 (%d, %d, %d, %d)\n",
   1:              this, dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height);
   1: #endif
   1:       Invalidate(dirtyRect);
   1:     } else {
   1:       nsRect combinedAreaHStrip, combinedAreaVStrip;
   1:       nsRect boundsHStrip, boundsVStrip;
   1:       GetRectDifferenceStrips(oldBounds, newBounds,
   1:                               &boundsHStrip, &boundsVStrip);
   1:       GetRectDifferenceStrips(oldCombinedArea, lineCombinedArea,
   1:                               &combinedAreaHStrip, &combinedAreaVStrip);
   1: 
   1: #ifdef NOISY_BLOCK_INVALIDATE
   1:       printf("%p invalidate boundsVStrip (%d, %d, %d, %d)\n",
   1:              this, boundsVStrip.x, boundsVStrip.y, boundsVStrip.width, boundsVStrip.height);
   1:       printf("%p invalidate boundsHStrip (%d, %d, %d, %d)\n",
   1:              this, boundsHStrip.x, boundsHStrip.y, boundsHStrip.width, boundsHStrip.height);
   1:       printf("%p invalidate combinedAreaVStrip (%d, %d, %d, %d)\n",
   1:              this, combinedAreaVStrip.x, combinedAreaVStrip.y, combinedAreaVStrip.width, combinedAreaVStrip.height);
   1:       printf("%p invalidate combinedAreaHStrip (%d, %d, %d, %d)\n",
   1:              this, combinedAreaHStrip.x, combinedAreaHStrip.y, combinedAreaHStrip.width, combinedAreaHStrip.height);
   1: #endif
   1:       // The first thing Invalidate does is check if the rect is empty, so
   1:       // don't bother doing that here.
   1:       Invalidate(boundsVStrip);
   1:       Invalidate(boundsHStrip);
   1:       Invalidate(combinedAreaVStrip);
   1:       Invalidate(combinedAreaHStrip);
   1:     }
   1:   }
   1:   else {
   1:     nsRect oldCombinedArea(aLine->GetCombinedArea());
   1:     aLine->SetLineWrapped(PR_FALSE);
   1: 
   1:     rv = ReflowInlineFrames(aState, aLine, aKeepReflowGoing);
   1: 
   1:     // We don't really know what changed in the line, so use the union
   1:     // of the old and new combined areas
   1:     nsRect dirtyRect;
   1:     dirtyRect.UnionRect(oldCombinedArea, aLine->GetCombinedArea());
   1: #ifdef NOISY_BLOCK_INVALIDATE
   1:     printf("%p invalidate (%d, %d, %d, %d)\n",
   1:            this, dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height);
   1:     if (aLine->IsForceInvalidate())
3233:       printf("  dirty line is %p\n", static_cast<void*>(aLine.get());
   1: #endif
   1:     Invalidate(dirtyRect);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: /**
   1:  * Pull frame from the next available location (one of our lines or
   1:  * one of our next-in-flows lines).
   1:  */
   1: nsresult
   1: nsBlockFrame::PullFrame(nsBlockReflowState& aState,
   1:                         line_iterator aLine,
   1:                         nsIFrame*& aFrameResult)
   1: {
   1:   aFrameResult = nsnull;
   1: 
   1:   // First check our remaining lines
   1:   if (end_lines() != aLine.next()) {
   1: #ifdef DEBUG
   1:     PRBool retry =
   1: #endif
   1:       PullFrameFrom(aState, aLine, this, PR_FALSE, aLine.next(), aFrameResult);
   1:     NS_ASSERTION(!retry, "Shouldn't have to retry in the current block");
   1:     return NS_OK;
   1:   }
   1: 
   1:   NS_ASSERTION(!GetOverflowLines(),
   1:     "Our overflow lines should have been removed at the start of reflow");
   1: 
   1:   // Try each next in flows
   1:   nsBlockFrame* nextInFlow = aState.mNextInFlow;
   1:   while (nextInFlow) {
   1:     // first normal lines, then overflow lines
   1:     if (!nextInFlow->mLines.empty()) {
   1:       if (PullFrameFrom(aState, aLine, nextInFlow, PR_FALSE,
   1:                         nextInFlow->mLines.begin(), aFrameResult)) {
   1:         // try again with the same value of nextInFlow
   1:         continue;
   1:       }
   1:       break;
   1:     }
   1: 
   1:     nsLineList* overflowLines = nextInFlow->GetOverflowLines();
   1:     if (overflowLines) {
   1:       if (PullFrameFrom(aState, aLine, nextInFlow, PR_TRUE,
   1:                         overflowLines->begin(), aFrameResult)) {
   1:         // try again with the same value of nextInFlow
   1:         continue;
   1:       }
   1:       break;
   1:     }
   1: 
   1:     nextInFlow = (nsBlockFrame*) nextInFlow->GetNextInFlow();
   1:     aState.mNextInFlow = nextInFlow;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:  * Try to pull a frame out of a line pointed at by aFromLine. If
   1:  * aUpdateGeometricParent is set then the pulled frames geometric parent
   1:  * will be updated (e.g. when pulling from a next-in-flows line list).
   1:  *
   1:  * Note: pulling a frame from a line that is a place-holder frame
   1:  * doesn't automatically remove the corresponding float from the
   1:  * line's float array. This happens indirectly: either the line gets
   1:  * emptied (and destroyed) or the line gets reflowed (because we mark
   1:  * it dirty) and the code at the top of ReflowLine empties the
   1:  * array. So eventually, it will be removed, just not right away.
   1:  *
   1:  * @return PR_TRUE to force retrying of the pull.
   1:  */
   1: PRBool
   1: nsBlockFrame::PullFrameFrom(nsBlockReflowState& aState,
   1:                             nsLineBox* aLine,
   1:                             nsBlockFrame* aFromContainer,
   1:                             PRBool aFromOverflowLine,
   1:                             nsLineList::iterator aFromLine,
   1:                             nsIFrame*& aFrameResult)
   1: {
   1:   nsLineBox* fromLine = aFromLine;
   1:   NS_ABORT_IF_FALSE(fromLine, "bad line to pull from");
   1:   NS_ABORT_IF_FALSE(fromLine->GetChildCount(), "empty line");
   1:   NS_ABORT_IF_FALSE(aLine->GetChildCount(), "empty line");
   1: 
2829:   NS_ASSERTION(fromLine->IsBlock() == fromLine->mFirstChild->GetStyleDisplay()->IsBlockOutside(),
   1:                "Disagreement about whether it's a block or not");
   1: 
   1:   if (fromLine->IsBlock()) {
   1:     // If our line is not empty and the child in aFromLine is a block
   1:     // then we cannot pull up the frame into this line. In this case
   1:     // we stop pulling.
   1:     aFrameResult = nsnull;
   1:   }
   1:   else {
   1:     // Take frame from fromLine
   1:     nsIFrame* frame = fromLine->mFirstChild;
   1: 
   1:     if (aFromContainer != this) {
   1:       if (HandleOverflowPlaceholdersForPulledFrame(aState, frame)) {
   1:         // we lost this one, retry
   1:         return PR_TRUE;
   1:       }
   1: 
   1:       aLine->LastChild()->SetNextSibling(frame);
   1:     }
   1:     // when aFromContainer is 'this', then aLine->LastChild()'s next sibling
   1:     // is already set correctly.
   1:     aLine->SetChildCount(aLine->GetChildCount() + 1);
   1:       
   1:     PRInt32 fromLineChildCount = fromLine->GetChildCount();
   1:     if (0 != --fromLineChildCount) {
   1:       // Mark line dirty now that we pulled a child
   1:       fromLine->SetChildCount(fromLineChildCount);
   1:       fromLine->MarkDirty();
   1:       fromLine->mFirstChild = frame->GetNextSibling();
   1:     }
   1:     else {
   1:       // Free up the fromLine now that it's empty
   1:       // Its bounds might need to be redrawn, though.
   1:       // XXX WHY do we invalidate the bounds AND the combined area? doesn't
   1:       // the combined area always enclose the bounds?
   1:       Invalidate(fromLine->mBounds);
   1:       nsLineList* fromLineList = aFromOverflowLine
   1:         ? aFromContainer->RemoveOverflowLines()
   1:         : &aFromContainer->mLines;
   1:       if (aFromLine.next() != fromLineList->end())
   1:         aFromLine.next()->MarkPreviousMarginDirty();
   1: 
   1:       Invalidate(fromLine->GetCombinedArea());
   1:       fromLineList->erase(aFromLine);
   1:       // Note that aFromLine just got incremented, so don't use it again here!
   1:       aState.FreeLineBox(fromLine);
   1: 
   1:       // Put any remaining overflow lines back.
   1:       if (aFromOverflowLine && !fromLineList->empty()) {
   1:         aFromContainer->SetOverflowLines(fromLineList);
   1:       }
   1:     }
   1: 
   1:     // Change geometric parents
   1:     if (aFromContainer != this) {
   1:       // When pushing and pulling frames we need to check for whether any
   1:       // views need to be reparented
   1:       NS_ASSERTION(frame->GetParent() == aFromContainer, "unexpected parent frame");
   1: 
   1:       ReparentFrame(frame, aFromContainer, this);
   1: 
   1:       // The frame is being pulled from a next-in-flow; therefore we
   1:       // need to add it to our sibling list.
   1:       frame->SetNextSibling(nsnull);
   1:       if (nsnull != aState.mPrevChild) {
   1:         aState.mPrevChild->SetNextSibling(frame);
   1:       }
   1: 
   1:       // The frame might have (or contain) floats that need to be
   1:       // brought over too.
 686:       ReparentFloats(frame, aFromContainer, aFromOverflowLine, PR_TRUE);
   1:     }
   1: 
   1:     // Stop pulling because we found a frame to pull
   1:     aFrameResult = frame;
   1: #ifdef DEBUG
   1:     VerifyLines(PR_TRUE);
   1: #endif
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: static void
   1: PlaceFrameView(nsIFrame* aFrame)
   1: {
   1:   if (aFrame->HasView())
   1:     nsContainerFrame::PositionFrameView(aFrame);
   1:   else
   1:     nsContainerFrame::PositionChildViews(aFrame);
   1: }
   1: 
   1: void
   1: nsBlockFrame::SlideLine(nsBlockReflowState& aState,
   1:                         nsLineBox* aLine, nscoord aDY)
   1: {
   1:   NS_PRECONDITION(aDY != 0, "why slide a line nowhere?");
   1: 
   1:   Invalidate(aLine->GetCombinedArea());
   1:   // Adjust line state
   1:   aLine->SlideBy(aDY);
   1:   Invalidate(aLine->GetCombinedArea());
   1: 
   1:   // Adjust the frames in the line
   1:   nsIFrame* kid = aLine->mFirstChild;
   1:   if (!kid) {
   1:     return;
   1:   }
   1: 
   1:   if (aLine->IsBlock()) {
   1:     if (aDY) {
   1:       nsPoint p = kid->GetPosition();
   1:       p.y += aDY;
   1:       kid->SetPosition(p);
   1:     }
   1: 
   1:     // Make sure the frame's view and any child views are updated
   1:     ::PlaceFrameView(kid);
   1:   }
   1:   else {
   1:     // Adjust the Y coordinate of the frames in the line.
   1:     // Note: we need to re-position views even if aDY is 0, because
   1:     // one of our parent frames may have moved and so the view's position
   1:     // relative to its parent may have changed
   1:     PRInt32 n = aLine->GetChildCount();
   1:     while (--n >= 0) {
   1:       if (aDY) {
   1:         nsPoint p = kid->GetPosition();
   1:         p.y += aDY;
   1:         kid->SetPosition(p);
   1:       }
   1:       // Make sure the frame's view and any child views are updated
   1:       ::PlaceFrameView(kid);
   1:       kid = kid->GetNextSibling();
   1:     }
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsBlockFrame::AttributeChanged(PRInt32         aNameSpaceID,
   1:                                nsIAtom*        aAttribute,
   1:                                PRInt32         aModType)
   1: {
   1:   nsresult rv = nsBlockFrameSuper::AttributeChanged(aNameSpaceID,
   1:                                                     aAttribute, aModType);
   1: 
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1:   if (nsGkAtoms::start == aAttribute) {
 238:     nsPresContext* presContext = PresContext();
   1: 
   1:     // XXX Not sure if this is necessary anymore
1158:     if (RenumberLists(presContext)) {
   1:       presContext->PresShell()->
1158:         FrameNeedsReflow(this, nsIPresShell::eStyleChange,
1158:                          NS_FRAME_HAS_DIRTY_CHILDREN);
1158:     }
   1:   }
   1:   else if (nsGkAtoms::value == aAttribute) {
   1:     const nsStyleDisplay* styleDisplay = GetStyleDisplay();
   1:     if (NS_STYLE_DISPLAY_LIST_ITEM == styleDisplay->mDisplay) {
   1:       // Search for the closest ancestor that's a block frame. We
   1:       // make the assumption that all related list items share a
   1:       // common block parent.
   1:       // XXXldb I think that's a bad assumption.
   1:       nsBlockFrame* blockParent = nsLayoutUtils::FindNearestBlockAncestor(this);
   1: 
   1:       // Tell the enclosing block frame to renumber list items within
   1:       // itself
   1:       if (nsnull != blockParent) {
 238:         nsPresContext* presContext = PresContext();
   1:         // XXX Not sure if this is necessary anymore
1158:         if (blockParent->RenumberLists(presContext)) {
   1:           presContext->PresShell()->
1158:             FrameNeedsReflow(blockParent, nsIPresShell::eStyleChange,
1158:                              NS_FRAME_HAS_DIRTY_CHILDREN);
1158:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: inline PRBool
   1: IsPaddingZero(nsStyleUnit aUnit, nsStyleCoord &aCoord)
   1: {
1364:     return ((aUnit == eStyleUnit_Coord && aCoord.GetCoordValue() == 0) ||
   1:             (aUnit == eStyleUnit_Percent && aCoord.GetPercentValue() == 0.0));
   1: }
   1: 
   1: inline PRBool
   1: IsMarginZero(nsStyleUnit aUnit, nsStyleCoord &aCoord)
   1: {
1364:     return (aUnit == eStyleUnit_Auto ||
   1:             (aUnit == eStyleUnit_Coord && aCoord.GetCoordValue() == 0) ||
   1:             (aUnit == eStyleUnit_Percent && aCoord.GetPercentValue() == 0.0));
   1: }
   1: 
   1: /* virtual */ PRBool
   1: nsBlockFrame::IsSelfEmpty()
   1: {
7674:   // Blocks which are margin-roots (including inline-blocks) cannot be treated
7674:   // as empty for margin-collapsing and other purposes. They're more like
7674:   // replaced elements.
7674:   if (GetStateBits() & NS_BLOCK_MARGIN_ROOT)
7674:     return PR_FALSE;
7674: 
   1:   const nsStylePosition* position = GetStylePosition();
   1: 
   1:   switch (position->mMinHeight.GetUnit()) {
   1:     case eStyleUnit_Coord:
   1:       if (position->mMinHeight.GetCoordValue() != 0)
   1:         return PR_FALSE;
   1:       break;
   1:     case eStyleUnit_Percent:
   1:       if (position->mMinHeight.GetPercentValue() != 0.0f)
   1:         return PR_FALSE;
   1:       break;
   1:     default:
   1:       return PR_FALSE;
   1:   }
   1: 
   1:   switch (position->mHeight.GetUnit()) {
   1:     case eStyleUnit_Auto:
   1:       break;
   1:     case eStyleUnit_Coord:
   1:       if (position->mHeight.GetCoordValue() != 0)
   1:         return PR_FALSE;
   1:       break;
   1:     case eStyleUnit_Percent:
   1:       if (position->mHeight.GetPercentValue() != 0.0f)
   1:         return PR_FALSE;
   1:       break;
   1:     default:
   1:       return PR_FALSE;
   1:   }
   1: 
   1:   const nsStyleBorder* border = GetStyleBorder();
   1:   const nsStylePadding* padding = GetStylePadding();
   1:   nsStyleCoord coord;
   1:   if (border->GetBorderWidth(NS_SIDE_TOP) != 0 ||
   1:       border->GetBorderWidth(NS_SIDE_BOTTOM) != 0 ||
   1:       !IsPaddingZero(padding->mPadding.GetTopUnit(),
   1:                     padding->mPadding.GetTop(coord)) ||
   1:       !IsPaddingZero(padding->mPadding.GetBottomUnit(),
   1:                     padding->mPadding.GetBottom(coord))) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: PRBool
   1: nsBlockFrame::CachedIsEmpty()
   1: {
   1:   if (!IsSelfEmpty()) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   for (line_iterator line = begin_lines(), line_end = end_lines();
   1:        line != line_end;
   1:        ++line)
   1:   {
   1:     if (!line->CachedIsEmpty())
   1:       return PR_FALSE;
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: PRBool
   1: nsBlockFrame::IsEmpty()
   1: {
   1:   if (!IsSelfEmpty()) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   for (line_iterator line = begin_lines(), line_end = end_lines();
   1:        line != line_end;
   1:        ++line)
   1:   {
   1:     if (!line->IsEmpty())
   1:       return PR_FALSE;
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: PRBool
   1: nsBlockFrame::ShouldApplyTopMargin(nsBlockReflowState& aState,
   1:                                    nsLineBox* aLine)
   1: {
   1:   if (aState.GetFlag(BRS_APPLYTOPMARGIN)) {
   1:     // Apply short-circuit check to avoid searching the line list
   1:     return PR_TRUE;
   1:   }
   1: 
   1:   if (!aState.IsAdjacentWithTop()) {
   1:     // If we aren't at the top Y coordinate then something of non-zero
   1:     // height must have been placed. Therefore the childs top-margin
   1:     // applies.
   1:     aState.SetFlag(BRS_APPLYTOPMARGIN, PR_TRUE);
   1:     return PR_TRUE;
   1:   }
   1: 
   1:   // Determine if this line is "essentially" the first line
   1:   line_iterator line = begin_lines();
   1:   if (aState.GetFlag(BRS_HAVELINEADJACENTTOTOP)) {
   1:     line = aState.mLineAdjacentToTop;
   1:   }
   1:   while (line != aLine) {
   1:     if (!line->CachedIsEmpty() || line->HasClearance()) {
   1:       // A line which precedes aLine is non-empty, or has clearance,
   1:       // so therefore the top margin applies.
   1:       aState.SetFlag(BRS_APPLYTOPMARGIN, PR_TRUE);
   1:       return PR_TRUE;
   1:     }
   1:     // No need to apply the top margin if the line has floats.  We
   1:     // should collapse anyway (bug 44419)
   1:     ++line;
   1:     aState.SetFlag(BRS_HAVELINEADJACENTTOTOP, PR_TRUE);
   1:     aState.mLineAdjacentToTop = line;
   1:   }
   1: 
   1:   // The line being reflowed is "essentially" the first line in the
   1:   // block. Therefore its top-margin will be collapsed by the
   1:   // generational collapsing logic with its parent (us).
   1:   return PR_FALSE;
   1: }
   1: 
   1: nsIFrame*
   1: nsBlockFrame::GetTopBlockChild(nsPresContext* aPresContext)
   1: {
   1:   if (mLines.empty())
   1:     return nsnull;
   1: 
   1:   nsLineBox *firstLine = mLines.front();
   1:   if (firstLine->IsBlock())
   1:     return firstLine->mFirstChild;
   1: 
   1:   if (!firstLine->CachedIsEmpty())
   1:     return nsnull;
   1: 
   1:   line_iterator secondLine = begin_lines();
   1:   ++secondLine;
   1:   if (secondLine == end_lines() || !secondLine->IsBlock())
   1:     return nsnull;
   1: 
   1:   return secondLine->mFirstChild;
   1: }
   1: 
   1: nsresult
   1: nsBlockFrame::ReflowBlockFrame(nsBlockReflowState& aState,
   1:                                line_iterator aLine,
   1:                                PRBool* aKeepReflowGoing)
   1: {
   1:   NS_PRECONDITION(*aKeepReflowGoing, "bad caller");
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsIFrame* frame = aLine->mFirstChild;
   1:   if (!frame) {
   1:     NS_ASSERTION(PR_FALSE, "program error - unexpected empty line"); 
   1:     return NS_ERROR_NULL_POINTER; 
   1:   }
   1: 
   1:   // Prepare the block reflow engine
   1:   const nsStyleDisplay* display = frame->GetStyleDisplay();
   1:   nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);
   1: 
   1:   PRUint8 breakType = display->mBreakType;
   1:   // If a float split and its prev-in-flow was followed by a <BR>, then combine 
   1:   // the <BR>'s break type with the block's break type (the block will be the very 
   1:   // next frame after the split float).
   1:   if (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType) {
   1:     breakType = nsLayoutUtils::CombineBreakType(breakType,
   1:                                                 aState.mFloatBreakType);
   1:     aState.mFloatBreakType = NS_STYLE_CLEAR_NONE;
   1:   }
   1: 
   1:   // Clear past floats before the block if the clear style is not none
   1:   aLine->SetBreakTypeBefore(breakType);
   1: 
   1:   // See if we should apply the top margin. If the block frame being
   1:   // reflowed is a continuation (non-null prev-in-flow) then we don't
   1:   // apply its top margin because it's not significant. Otherwise, dig
   1:   // deeper.
   1:   PRBool applyTopMargin =
   1:     !frame->GetPrevInFlow() && ShouldApplyTopMargin(aState, aLine);
   1: 
   1:   if (applyTopMargin) {
   1:     // The HasClearance setting is only valid if ShouldApplyTopMargin
   1:     // returned PR_FALSE (in which case the top-margin-root set our
   1:     // clearance flag). Otherwise clear it now. We'll set it later on
   1:     // ourselves if necessary.
   1:     aLine->ClearHasClearance();
   1:   }
   1:   PRBool treatWithClearance = aLine->HasClearance();
   1:   // If our top margin was counted as part of some parents top-margin
   1:   // collapse and we are being speculatively reflowed assuming this
   1:   // frame DID NOT need clearance, then we need to check that
   1:   // assumption.
   1:   if (!treatWithClearance && !applyTopMargin && breakType != NS_STYLE_CLEAR_NONE &&
   1:       aState.mReflowState.mDiscoveredClearance) {
   1:     nscoord curY = aState.mY + aState.mPrevBottomMargin.get();
   1:     nscoord clearY = aState.ClearFloats(curY, breakType);
   1:     if (clearY != curY) {
   1:       // Looks like that assumption was invalid, we do need
   1:       // clearance. Tell our ancestor so it can reflow again. It is
   1:       // responsible for actually setting our clearance flag before
   1:       // the next reflow.
   1:       treatWithClearance = PR_TRUE;
   1:       // Only record the first frame that requires clearance
   1:       if (!*aState.mReflowState.mDiscoveredClearance) {
   1:         *aState.mReflowState.mDiscoveredClearance = frame;
   1:       }
   1:       // Exactly what we do now is flexible since we'll definitely be
   1:       // reflowed.
8457:       return NS_OK;
   1:     }
   1:   }
   1:   if (treatWithClearance) {
   1:     applyTopMargin = PR_TRUE;
   1:   }
   1: 
   1:   nsIFrame* clearanceFrame = nsnull;
   1:   nscoord startingY = aState.mY;
   1:   nsCollapsingMargin incomingMargin = aState.mPrevBottomMargin;
   1:   nscoord clearance;
 375:   // Save the original position of the frame so that we can reposition
 375:   // its view as needed.
 375:   nsPoint originalPosition = frame->GetPosition();
   1:   while (PR_TRUE) {
   1:     // Save the frame's current position. We might need it later.
 375:     nscoord passOriginalY = frame->GetRect().y;
   1:     
   1:     clearance = 0;
   1:     nscoord topMargin = 0;
   1:     PRBool mayNeedRetry = PR_FALSE;
   1:     if (applyTopMargin) {
   1:       // Precompute the blocks top margin value so that we can get the
   1:       // correct available space (there might be a float that's
   1:       // already been placed below the aState.mPrevBottomMargin
   1: 
   1:       // Setup a reflowState to get the style computed margin-top
   1:       // value. We'll use a reason of `resize' so that we don't fudge
   1:       // any incremental reflow state.
   1:       
   1:       // The availSpace here is irrelevant to our needs - all we want
   1:       // out if this setup is the margin-top value which doesn't depend
   1:       // on the childs available space.
   1:       // XXX building a complete nsHTMLReflowState just to get the margin-top
   1:       // seems like a waste. And we do this for almost every block!
   1:       nsSize availSpace(aState.mContentArea.width, NS_UNCONSTRAINEDSIZE);
   1:       nsHTMLReflowState reflowState(aState.mPresContext, aState.mReflowState,
   1:                                     frame, availSpace);
   1:       
   1:       if (treatWithClearance) {
   1:         aState.mY += aState.mPrevBottomMargin.get();
   1:         aState.mPrevBottomMargin.Zero();
   1:       }
   1:       
   1:       // Now compute the collapsed margin-top value into aState.mPrevBottomMargin, assuming
   1:       // that all child margins collapse down to clearanceFrame.
   1:       nsBlockReflowContext::ComputeCollapsedTopMargin(reflowState,
   1:                                                       &aState.mPrevBottomMargin, clearanceFrame, &mayNeedRetry);
   1:       
   1:       // XXX optimization; we could check the collapsing children to see if they are sure
   1:       // to require clearance, and so avoid retrying them
   1:       
   1:       if (clearanceFrame) {
   1:         // Don't allow retries on the second pass. The clearance decisions for the
   1:         // blocks whose top-margins collapse with ours are now fixed.
   1:         mayNeedRetry = PR_FALSE;
   1:       }
   1:       
   1:       if (!treatWithClearance && !clearanceFrame && breakType != NS_STYLE_CLEAR_NONE) {
   1:         // We don't know if we need clearance and this is the first,
   1:         // optimistic pass.  So determine whether *this block* needs
   1:         // clearance. Note that we do not allow the decision for whether
   1:         // this block has clearance to change on the second pass; that
   1:         // decision is only allowed to be made under the optimistic
   1:         // first pass.
   1:         nscoord curY = aState.mY + aState.mPrevBottomMargin.get();
   1:         nscoord clearY = aState.ClearFloats(curY, breakType);
   1:         if (clearY != curY) {
   1:           // Looks like we need clearance and we didn't know about it already. So
   1:           // recompute collapsed margin
   1:           treatWithClearance = PR_TRUE;
   1:           // Remember this decision, needed for incremental reflow
   1:           aLine->SetHasClearance();
   1:           
   1:           // Apply incoming margins
   1:           aState.mY += aState.mPrevBottomMargin.get();
   1:           aState.mPrevBottomMargin.Zero();
   1:           
   1:           // Compute the collapsed margin again, ignoring the incoming margin this time
   1:           mayNeedRetry = PR_FALSE;
   1:           nsBlockReflowContext::ComputeCollapsedTopMargin(reflowState,
   1:                                                           &aState.mPrevBottomMargin, clearanceFrame, &mayNeedRetry);
   1:         }
   1:       }
   1:       
   1:       // Temporarily advance the running Y value so that the
   1:       // GetAvailableSpace method will return the right available
   1:       // space. This undone as soon as the horizontal margins are
   1:       // computed.
   1:       topMargin = aState.mPrevBottomMargin.get();
   1:       
   1:       if (treatWithClearance) {
   1:         nscoord currentY = aState.mY;
   1:         // advance mY to the clear position.
   1:         aState.mY = aState.ClearFloats(aState.mY, breakType);
   1:         
   1:         // Compute clearance. It's the amount we need to add to the top
   1:         // border-edge of the frame, after applying collapsed margins
   1:         // from the frame and its children, to get it to line up with
   1:         // the bottom of the floats. The former is currentY + topMargin,
   1:         // the latter is the current aState.mY.
   1:         // Note that negative clearance is possible
   1:         clearance = aState.mY - (currentY + topMargin);
   1:         
   1:         // Add clearance to our top margin while we compute available
   1:         // space for the frame
   1:         topMargin += clearance;
   1:         
   1:         // Note that aState.mY should stay where it is: at the top
   1:         // border-edge of the frame
   1:       } else {
   1:         // Advance aState.mY to the top border-edge of the frame.
   1:         aState.mY += topMargin;
   1:       }
   1:     }
   1:     
   1:     // Here aState.mY is the top border-edge of the block.
   1:     // Compute the available space for the block
   1:     aState.GetAvailableSpace();
   1: #ifdef REALLY_NOISY_REFLOW
   1:     printf("setting line %p isImpacted to %s\n", aLine.get(), aState.IsImpactedByFloat()?"true":"false");
   1: #endif
   1:     PRBool isImpacted = aState.IsImpactedByFloat() ? PR_TRUE : PR_FALSE;
   1:     aLine->SetLineIsImpactedByFloat(isImpacted);
   1:     nsRect availSpace;
   1:     aState.ComputeBlockAvailSpace(frame, display, availSpace);
   1:     
   1:     // Now put the Y coordinate back to the top of the top-margin +
   1:     // clearance, and flow the block.
   1:     aState.mY -= topMargin;
   1:     availSpace.y -= topMargin;
   1:     if (NS_UNCONSTRAINEDSIZE != availSpace.height) {
   1:       availSpace.height += topMargin;
   1:     }
   1:     
   1:     // Reflow the block into the available space
   1:     nsMargin computedOffsets;
   1:     // construct the html reflow state for the block. ReflowBlock 
   1:     // will initialize it
   1:     nsHTMLReflowState blockHtmlRS(aState.mPresContext, aState.mReflowState, frame, 
   1:                                   nsSize(availSpace.width, availSpace.height));
   1:     blockHtmlRS.mFlags.mHasClearance = aLine->HasClearance();
   1:     
   1:     nsSpaceManager::SavedState spaceManagerState;
   1:     if (mayNeedRetry) {
   1:       blockHtmlRS.mDiscoveredClearance = &clearanceFrame;
   1:       aState.mSpaceManager->PushState(&spaceManagerState);
   1:     } else if (!applyTopMargin) {
   1:       blockHtmlRS.mDiscoveredClearance = aState.mReflowState.mDiscoveredClearance;
   1:     }
   1:     
   1:     nsReflowStatus frameReflowStatus = NS_FRAME_COMPLETE;
   1:     rv = brc.ReflowBlock(availSpace, applyTopMargin, aState.mPrevBottomMargin,
   1:                          clearance, aState.IsAdjacentWithTop(), computedOffsets,
6521:                          aLine.get(), blockHtmlRS, frameReflowStatus, aState);
   1: 
   1:     // If this was a second-pass reflow and the block's vertical position
   1:     // changed, invalidates from the first pass might have happened in the
   1:     // wrong places.  Invalidate the entire overflow rect at the new position.
 375:     if (!mayNeedRetry && clearanceFrame &&
 375:         frame->GetRect().y != passOriginalY) {
   1:       Invalidate(frame->GetOverflowRect() + frame->GetPosition());
   1:     }
   1:     
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     
   1:     if (mayNeedRetry && clearanceFrame) {
   1:       aState.mSpaceManager->PopState(&spaceManagerState);
   1:       aState.mY = startingY;
   1:       aState.mPrevBottomMargin = incomingMargin;
   1:       continue;
   1:     }
   1:     
   1:     aState.mPrevChild = frame;
   1:     
   1: #if defined(REFLOW_STATUS_COVERAGE)
   1:     RecordReflowStatus(PR_TRUE, frameReflowStatus);
   1: #endif
   1:     
   1:     if (NS_INLINE_IS_BREAK_BEFORE(frameReflowStatus)) {
   1:       // None of the child block fits.
   1:       PushLines(aState, aLine.prev());
   1:       *aKeepReflowGoing = PR_FALSE;
4006:       NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
   1:     }
   1:     else {
   1:       // Note: line-break-after a block is a nop
   1:       
   1:       // Try to place the child block.
   1:       // Don't force the block to fit if we have positive clearance, because
   1:       // pushing it to the next page would give it more room.
   1:       // Don't force the block to fit if it's impacted by a float. If it is,
   1:       // then pushing it to the next page would give it more room. Note that
   1:       // isImpacted doesn't include impact from the block's own floats.
   1:       PRBool forceFit = aState.IsAdjacentWithTop() && clearance <= 0 &&
   1:         !isImpacted;
   1:       nsCollapsingMargin collapsedBottomMargin;
   1:       nsRect combinedArea(0,0,0,0);
   1:       *aKeepReflowGoing = brc.PlaceBlock(blockHtmlRS, forceFit, aLine.get(),
   1:                                          computedOffsets, collapsedBottomMargin,
   1:                                          aLine->mBounds, combinedArea, frameReflowStatus);
   1:       if (aLine->SetCarriedOutBottomMargin(collapsedBottomMargin)) {
   1:         line_iterator nextLine = aLine;
   1:         ++nextLine;
   1:         if (nextLine != end_lines()) {
   1:           nextLine->MarkPreviousMarginDirty();
   1:         }
   1:       }
   1:       
   1:       aLine->SetCombinedArea(combinedArea);
   1:       if (*aKeepReflowGoing) {
   1:         // Some of the child block fit
   1:         
   1:         // Advance to new Y position
   1:         nscoord newY = aLine->mBounds.YMost();
   1:         aState.mY = newY;
   1:         
   1:         // Continue the block frame now if it didn't completely fit in
   1:         // the available space.
4006:         if (!NS_FRAME_IS_FULLY_COMPLETE(frameReflowStatus)) {
   1:           PRBool madeContinuation;
   1:           rv = CreateContinuationFor(aState, nsnull, frame, madeContinuation);
   1:           NS_ENSURE_SUCCESS(rv, rv);
   1:           
   1:           nsIFrame* nextFrame = frame->GetNextInFlow();
4006:           NS_ASSERTION(nextFrame, "We're supposed to have a next-in-flow by now");
4006:           
4006:           if (NS_FRAME_IS_NOT_COMPLETE(frameReflowStatus)) {
4006:             // If nextFrame used to be an overflow container, make it a normal block
4006:             if (!madeContinuation &&
4006:                 (NS_FRAME_IS_OVERFLOW_CONTAINER & nextFrame->GetStateBits())) {
4006:               aState.mOverflowTracker.Finish(frame);
4006:               nsContainerFrame* parent =
4006:                 static_cast<nsContainerFrame*>(nextFrame->GetParent());
4006:               rv = parent->StealFrame(aState.mPresContext, nextFrame);
4006:               NS_ENSURE_SUCCESS(rv, rv);
6800:               if (parent != this)
4006:                 ReparentFrame(nextFrame, parent, this);
4006:               nextFrame->SetNextSibling(frame->GetNextSibling());
4006:               frame->SetNextSibling(nextFrame);
4006:               madeContinuation = PR_TRUE; // needs to be added to mLines
4006:               nextFrame->RemoveStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
4006:               frameReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
4006:             }
   1: 
   1:             // Push continuation to a new line, but only if we actually made one.
   1:             if (madeContinuation) {
   1:               nsLineBox* line = aState.NewLineBox(nextFrame, 1, PR_TRUE);
   1:               NS_ENSURE_TRUE(line, NS_ERROR_OUT_OF_MEMORY);
   1:               mLines.after_insert(aLine, line);
   1:             }
   1: 
   1:             PushLines(aState, aLine);
4006:             NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
4006: 
   1:             // If we need to reflow the continuation of the block child,
   1:             // then we'd better reflow our continuation
   1:             if (frameReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW) {
   1:               aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
   1:               // We also need to make that continuation's line dirty so
   1:               // it gets reflowed when we reflow our next in flow. The
   1:               // nif's line must always be either a line of the nif's
   1:               // parent block (only if we didn't make a continuation) or
   1:               // else one of our own overflow lines. In the latter case
   1:               // the line is already marked dirty, so just handle the
   1:               // first case.
   1:               if (!madeContinuation) {
3233:                 nsBlockFrame* nifBlock = static_cast<nsBlockFrame*>(nextFrame->GetParent());
   1:                 NS_ASSERTION(nifBlock->GetType() == nsGkAtoms::blockFrame
   1:                              || nifBlock->GetType() == nsGkAtoms::areaFrame,
   1:                              "A block's child's next in flow's parent must be a block!");
   1:                 for (line_iterator line = nifBlock->begin_lines(),
   1:                      line_end = nifBlock->end_lines(); line != line_end; ++line) {
   1:                   if (line->Contains(nextFrame)) {
   1:                     line->MarkDirty();
   1:                     break;
   1:                   }
   1:                 }
   1:               }
   1:             }
   1:             *aKeepReflowGoing = PR_FALSE;
   1:             
   1:             // The bottom margin for a block is only applied on the last
   1:             // flow block. Since we just continued the child block frame,
   1:             // we know that line->mFirstChild is not the last flow block
   1:             // therefore zero out the running margin value.
   1: #ifdef NOISY_VERTICAL_MARGINS
   1:             ListTag(stdout);
   1:             printf(": reflow incomplete, frame=");
   1:             nsFrame::ListTag(stdout, frame);
   1:             printf(" prevBottomMargin=%d, setting to zero\n",
   1:                    aState.mPrevBottomMargin);
   1: #endif
   1:             aState.mPrevBottomMargin.Zero();
   1:           }
4006:           else { // frame is complete but its overflow is not complete
4006:             // Disconnect the next-in-flow and put it in our overflow tracker
4006:             if (!madeContinuation &&
4006:                 !(NS_FRAME_IS_OVERFLOW_CONTAINER & nextFrame->GetStateBits())) {
4006:               // It already exists, but as a normal next-in-flow, so we need
4006:               // to dig it out of the child lists.
4006:               nsContainerFrame* parent = static_cast<nsContainerFrame*>
4006:                                            (nextFrame->GetParent());
4006:               rv = parent->StealFrame(aState.mPresContext, nextFrame);
4006:               NS_ENSURE_SUCCESS(rv, rv);
4006:             }
4006:             else if (madeContinuation) {
4006:               frame->SetNextSibling(nextFrame->GetNextSibling());
4006:               nextFrame->SetNextSibling(nsnull);
4006:             }
4006: 
4006:             // Put it in our overflow list
4006:             aState.mOverflowTracker.Insert(nextFrame, frameReflowStatus);
4006:             aState.mReflowStatus = NS_FRAME_MERGE_INCOMPLETE(frameReflowStatus,
4006:                                      aState.mReflowStatus);
4006: 
4006: #ifdef NOISY_VERTICAL_MARGINS
4006:             ListTag(stdout);
4006:             printf(": reflow complete but overflow incomplete for ");
4006:             nsFrame::ListTag(stdout, frame);
4006:             printf(" prevBottomMargin=%d collapsedBottomMargin=%d\n",
4006:                    aState.mPrevBottomMargin, collapsedBottomMargin.get());
4006: #endif
4006:             aState.mPrevBottomMargin = collapsedBottomMargin;
4006:           }
4006:         }
4006:         else { // frame is fully complete
   1: #ifdef NOISY_VERTICAL_MARGINS
   1:           ListTag(stdout);
   1:           printf(": reflow complete for ");
   1:           nsFrame::ListTag(stdout, frame);
   1:           printf(" prevBottomMargin=%d collapsedBottomMargin=%d\n",
   1:                  aState.mPrevBottomMargin, collapsedBottomMargin.get());
   1: #endif
   1:           aState.mPrevBottomMargin = collapsedBottomMargin;
   1:         }
   1: #ifdef NOISY_VERTICAL_MARGINS
   1:         ListTag(stdout);
   1:         printf(": frame=");
   1:         nsFrame::ListTag(stdout, frame);
   1:         printf(" carriedOutBottomMargin=%d collapsedBottomMargin=%d => %d\n",
   1:                brc.GetCarriedOutBottomMargin(), collapsedBottomMargin.get(),
   1:                aState.mPrevBottomMargin);
   1: #endif
   1:       }
   1:       else {
   1:         // None of the block fits. Determine the correct reflow status.
   1:         if (aLine == mLines.front()) {
   1:           // If it's our very first line then we need to be pushed to
   1:           // our parents next-in-flow. Therefore, return break-before
   1:           // status for our reflow status.
   1:           aState.mReflowStatus = NS_INLINE_LINE_BREAK_BEFORE();
   1:         }
   1:         else {
   1:           // Push the line that didn't fit and any lines that follow it
   1:           // to our next-in-flow.
   1:           PushLines(aState, aLine.prev());
4006:           NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
   1:         }
   1:       }
   1:     }
   1:     break; // out of the reflow retry loop
   1:   }
   1: 
 375:   // Now that we've got its final position all figured out, position any child
 375:   // views it may have.  Note that the case when frame has a view got handled
 375:   // by FinishReflowChild, but that function didn't have the coordinates needed
 375:   // to correctly decide whether to reposition child views.
 375:   if (originalPosition != frame->GetPosition() && !frame->HasView()) {
 375:     nsContainerFrame::PositionChildViews(frame);
 375:   }
 375:   
   1: #ifdef DEBUG
   1:   VerifyLines(PR_TRUE);
   1: #endif
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsBlockFrame::ReflowInlineFrames(nsBlockReflowState& aState,
   1:                                  line_iterator aLine,
   1:                                  PRBool* aKeepReflowGoing)
   1: {
   1:   nsresult rv = NS_OK;
   1:   *aKeepReflowGoing = PR_TRUE;
   1: 
   1: #ifdef DEBUG
   1:   PRInt32 spins = 0;
   1: #endif
   1:   LineReflowStatus lineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
   1:   PRBool movedPastFloat = PR_FALSE;
   1:   do {
   1:     PRBool allowPullUp = PR_TRUE;
   1:     nsIContent* forceBreakInContent = nsnull;
   1:     PRInt32 forceBreakOffset = -1;
   1:     do {
   1:       nsSpaceManager::SavedState spaceManagerState;
   1:       aState.mReflowState.mSpaceManager->PushState(&spaceManagerState);
   1: 
   1:       // Once upon a time we allocated the first 30 nsLineLayout objects
   1:       // on the stack, and then we switched to the heap.  At that time
   1:       // these objects were large (1100 bytes on a 32 bit system).
   1:       // Then the nsLineLayout object was shrunk to 156 bytes by
   1:       // removing some internal buffers.  Given that it is so much
   1:       // smaller, the complexity of 2 different ways of allocating
5593:       // no longer makes sense.  Now we always allocate on the stack.
   1:       nsLineLayout lineLayout(aState.mPresContext,
   1:                               aState.mReflowState.mSpaceManager,
   1:                               &aState.mReflowState, &aLine);
   1:       lineLayout.Init(&aState, aState.mMinLineHeight, aState.mLineNumber);
   1:       if (forceBreakInContent) {
   1:         lineLayout.ForceBreakAtPosition(forceBreakInContent, forceBreakOffset);
   1:       }
   1:       rv = DoReflowInlineFrames(aState, lineLayout, aLine,
   1:                                 aKeepReflowGoing, &lineReflowStatus,
   1:                                 allowPullUp);
   1:       lineLayout.EndLineReflow();
   1: 
   1:       if (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus ||
   1:           LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
   1:         if (lineLayout.NeedsBackup()) {
   1:           NS_ASSERTION(!forceBreakInContent, "Backing up twice; this should never be necessary");
   1:           // If there is no saved break position, then this will set
   1:           // set forceBreakInContent to null and we won't back up, which is
   1:           // correct.
   1:           forceBreakInContent = lineLayout.GetLastOptionalBreakPosition(&forceBreakOffset);
   1:         } else {
   1:           forceBreakInContent = nsnull;
   1:         }
   1:         // restore the space manager state
   1:         aState.mReflowState.mSpaceManager->PopState(&spaceManagerState);
   1:         // Clear out float lists
   1:         aState.mCurrentLineFloats.DeleteAll();
   1:         aState.mBelowCurrentLineFloats.DeleteAll();
   1:       }
   1:       
   1: #ifdef DEBUG
   1:       spins++;
   1:       if (1000 == spins) {
   1:         ListTag(stdout);
   1:         printf(": yikes! spinning on a line over 1000 times!\n");
   1:         NS_ABORT();
   1:       }
   1: #endif
   1: 
   1:       // Don't allow pullup on a subsequent LINE_REFLOW_REDO_NO_PULL pass
   1:       allowPullUp = PR_FALSE;
   1:     } while (NS_SUCCEEDED(rv) && LINE_REFLOW_REDO_NO_PULL == lineReflowStatus);
   1: 
   1:     if (LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
   1:       movedPastFloat = PR_TRUE;
   1:     }
   1:   } while (NS_SUCCEEDED(rv) && LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus);
   1: 
   1:   // If we did at least one REDO_FOR_FLOAT, then the line did not fit next to some float.
   1:   // Mark it as impacted by a float, even if it no longer is next to a float.
   1:   if (movedPastFloat) {
   1:     aLine->SetLineIsImpactedByFloat(PR_TRUE);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: // If at least one float on the line was complete, not at the top of
   1: // page, but was truncated, then restore the overflow floats to what
   1: // they were before and push the line.  The floats that will be removed
   1: // from the list aren't yet known by the block's next in flow.  
   1: void
   1: nsBlockFrame::PushTruncatedPlaceholderLine(nsBlockReflowState& aState,
   1:                                            line_iterator       aLine,
   1:                                            PRBool&             aKeepReflowGoing)
   1: {
   1:   line_iterator prevLine = aLine;
   1:   --prevLine;
   1:   PushLines(aState, prevLine);
   1:   aKeepReflowGoing = PR_FALSE;
4006:   NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
   1: }
   1: 
   1: #ifdef DEBUG
   1: static const char* LineReflowStatusNames[] = {
   1:   "LINE_REFLOW_OK", "LINE_REFLOW_STOP", "LINE_REFLOW_REDO_NO_PULL",
   1:   "LINE_REFLOW_REDO_NEXT_BAND", "LINE_REFLOW_TRUNCATED"
   1: };
   1: #endif
   1: 
   1: nsresult
   1: nsBlockFrame::DoReflowInlineFrames(nsBlockReflowState& aState,
   1:                                    nsLineLayout& aLineLayout,
   1:                                    line_iterator aLine,
   1:                                    PRBool* aKeepReflowGoing,
   1:                                    LineReflowStatus* aLineReflowStatus,
   1:                                    PRBool aAllowPullUp)
   1: {
   1:   // Forget all of the floats on the line
   1:   aLine->FreeFloats(aState.mFloatCacheFreeList);
   1:   aState.mFloatCombinedArea.SetRect(0, 0, 0, 0);
   1: 
   1:   // Setup initial coordinate system for reflowing the inline frames
   1:   // into. Apply a previous block frame's bottom margin first.
   1:   if (ShouldApplyTopMargin(aState, aLine)) {
   1:     aState.mY += aState.mPrevBottomMargin.get();
   1:   }
   1:   aState.GetAvailableSpace();
   1:   PRBool impactedByFloats = aState.IsImpactedByFloat() ? PR_TRUE : PR_FALSE;
   1:   aLine->SetLineIsImpactedByFloat(impactedByFloats);
   1: #ifdef REALLY_NOISY_REFLOW
   1:   printf("nsBlockFrame::DoReflowInlineFrames %p impacted = %d\n",
   1:          this, impactedByFloats);
   1: #endif
   1: 
   1:   const nsMargin& borderPadding = aState.BorderPadding();
   1:   nscoord x = aState.mAvailSpaceRect.x + borderPadding.left;
   1:   nscoord availWidth = aState.mAvailSpaceRect.width;
   1:   nscoord availHeight;
   1:   if (aState.GetFlag(BRS_UNCONSTRAINEDHEIGHT)) {
   1:     availHeight = NS_UNCONSTRAINEDSIZE;
   1:   }
   1:   else {
   1:     /* XXX get the height right! */
   1:     availHeight = aState.mAvailSpaceRect.height;
   1:   }
1668: 
1668:   // Make sure to enable resize optimization before we call BeginLineReflow
1668:   // because it might get disabled there
1668:   aLine->EnableResizeReflowOptimization();
1668: 
   1:   aLineLayout.BeginLineReflow(x, aState.mY,
   1:                               availWidth, availHeight,
   1:                               impactedByFloats,
   1:                               PR_FALSE /*XXX isTopOfPage*/);
   1: 
   1:   // XXX Unfortunately we need to know this before reflowing the first
   1:   // inline frame in the line. FIX ME.
   1:   if ((0 == aLineLayout.GetLineNumber()) &&
   1:       (NS_BLOCK_HAS_FIRST_LETTER_STYLE & mState)) {
   1:     aLineLayout.SetFirstLetterStyleOK(PR_TRUE);
   1:   }
   1: 
   1:   // Reflow the frames that are already on the line first
   1:   nsresult rv = NS_OK;
   1:   LineReflowStatus lineReflowStatus = LINE_REFLOW_OK;
   1:   PRInt32 i;
   1:   nsIFrame* frame = aLine->mFirstChild;
   1: 
   1:   // Determine whether this is a line of placeholders for out-of-flow
   1:   // continuations
   1:   PRBool isContinuingPlaceholders = PR_FALSE;
   1: 
   1:   if (impactedByFloats) {
   1:     // There is a soft break opportunity at the start of the line, because
   1:     // we can always move this line down below float(s).
   1:     if (aLineLayout.NotifyOptionalBreakPosition(frame->GetContent(), 0, PR_TRUE)) {
   1:       lineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
   1:     }
   1:   }
   1: 
   1:   // need to repeatedly call GetChildCount here, because the child
   1:   // count can change during the loop!
   1:   for (i = 0; LINE_REFLOW_OK == lineReflowStatus && i < aLine->GetChildCount();
   1:        i++, frame = frame->GetNextSibling()) {
   1:     if (IsContinuationPlaceholder(frame)) {
   1:       isContinuingPlaceholders = PR_TRUE;
   1:     }
   1:     rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
   1:                            &lineReflowStatus);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     if (LINE_REFLOW_OK != lineReflowStatus) {
   1:       // It is possible that one or more of next lines are empty
   1:       // (because of DeleteNextInFlowChild). If so, delete them now
   1:       // in case we are finished.
   1:       ++aLine;
   1:       while ((aLine != end_lines()) && (0 == aLine->GetChildCount())) {
   1:         // XXX Is this still necessary now that DeleteNextInFlowChild
   1:         // uses DoRemoveFrame?
   1:         nsLineBox *toremove = aLine;
   1:         aLine = mLines.erase(aLine);
   1:         NS_ASSERTION(nsnull == toremove->mFirstChild, "bad empty line");
   1:         aState.FreeLineBox(toremove);
   1:       }
   1:       --aLine;
   1: 
   1:       if (LINE_REFLOW_TRUNCATED == lineReflowStatus) {
   1:         // Push the line with the truncated float 
8521:         PushTruncatedPlaceholderLine(aState, aLine, *aKeepReflowGoing);
   1:       }
   1:     }
   1:   }
   1: 
   1:   // Don't pull up new frames into lines with continuation placeholders
   1:   if (!isContinuingPlaceholders && aAllowPullUp) {
   1:     // Pull frames and reflow them until we can't
   1:     while (LINE_REFLOW_OK == lineReflowStatus) {
   1:       rv = PullFrame(aState, aLine, frame);
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1:       if (nsnull == frame) {
   1:         break;
   1:       }
   1: 
   1:       while (LINE_REFLOW_OK == lineReflowStatus) {
   1:         PRInt32 oldCount = aLine->GetChildCount();
   1:         rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
   1:                                &lineReflowStatus);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:         if (aLine->GetChildCount() != oldCount) {
   1:           // We just created a continuation for aFrame AND its going
   1:           // to end up on this line (e.g. :first-letter
   1:           // situation). Therefore we have to loop here before trying
   1:           // to pull another frame.
   1:           frame = frame->GetNextSibling();
   1:         }
   1:         else {
   1:           break;
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   // We only need to backup if the line isn't going to be reflowed again anyway
   1:   PRBool needsBackup = aLineLayout.NeedsBackup() &&
   1:     (lineReflowStatus == LINE_REFLOW_STOP || lineReflowStatus == LINE_REFLOW_OK);
   1:   if (needsBackup && aLineLayout.HaveForcedBreakPosition()) {
   1:   	NS_WARNING("We shouldn't be backing up more than once! "
   1:                "Someone must have set a break opportunity beyond the available width, "
   1:                "even though there were better break opportunities before it");
   1:     needsBackup = PR_FALSE;
   1:   }
   1:   if (needsBackup) {
   1:     // We need to try backing up to before a text run
   1:     PRInt32 offset;
   1:     nsIContent* breakContent = aLineLayout.GetLastOptionalBreakPosition(&offset);
   7:     // XXX It's possible, in fact not unusual, for the break opportunity to already
   7:     // be the end of the line. We should detect that and optimize to not
   7:     // re-do the line.
   1:     if (breakContent) {
   1:       // We can back up!
   1:       lineReflowStatus = LINE_REFLOW_REDO_NO_PULL;
   1:     }
   1:   } else {
   1:     // In case we reflow this line again, remember that we don't
   1:     // need to force any breaking
   1:     aLineLayout.ClearOptionalBreakPosition();
   1:   }
   1: 
   1:   if (LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
   1:     // This happens only when we have a line that is impacted by
   1:     // floats and the first element in the line doesn't fit with
   1:     // the floats.
   1:     //
   1:     // What we do is to advance past the first float we find and
   1:     // then reflow the line all over again.
   1:     NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aState.mAvailSpaceRect.height,
   1:                  "unconstrained height on totally empty line");
   1: 
   1:     if (aState.mAvailSpaceRect.height > 0) {
6777:       NS_ASSERTION(aState.IsImpactedByFloat(),
6777:                    "redo line on totally empty line with non-empty band...");
   1:       aState.mY += aState.mAvailSpaceRect.height;
   1:     } else {
   1:       NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aState.mReflowState.availableHeight,
   1:                    "We shouldn't be running out of height here");
   1:       if (NS_UNCONSTRAINEDSIZE == aState.mReflowState.availableHeight) {
   1:         // just move it down a bit to try to get out of this mess
   1:         aState.mY += 1;
   1:       } else {
   1:         // There's nowhere to retry placing the line. Just treat it as if
   1:         // we placed the float but it was truncated so we need this line
   1:         // to go to the next page/column.
   1:         lineReflowStatus = LINE_REFLOW_TRUNCATED;
   1:         // Push the line that didn't fit
8521:         PushTruncatedPlaceholderLine(aState, aLine, *aKeepReflowGoing);
   1:       }
   1:     }
   1:       
   1:     // We don't want to advance by the bottom margin anymore (we did it
   1:     // once at the beginning of this function, which will just be called
   1:     // again), and we certainly don't want to go back if it's negative
   1:     // (infinite loop, bug 153429).
   1:     aState.mPrevBottomMargin.Zero();
   1: 
   1:     // XXX: a small optimization can be done here when paginating:
   1:     // if the new Y coordinate is past the end of the block then
   1:     // push the line and return now instead of later on after we are
   1:     // past the float.
   1:   }
   1:   else if (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus) {
   1:     // We don't want to advance by the bottom margin anymore (we did it
   1:     // once at the beginning of this function, which will just be called
   1:     // again), and we certainly don't want to go back if it's negative
   1:     // (infinite loop, bug 153429).
   1:     aState.mPrevBottomMargin.Zero();
   1:   }
   1:   else if (LINE_REFLOW_TRUNCATED != lineReflowStatus) {
   1:     // If we are propagating out a break-before status then there is
   1:     // no point in placing the line.
   1:     if (!NS_INLINE_IS_BREAK_BEFORE(aState.mReflowStatus)) {
8521:       PlaceLine(aState, aLineLayout, aLine, aKeepReflowGoing);
   1:     }
   1:   }
   1: #ifdef DEBUG
   1:   if (gNoisyReflow) {
   1:     printf("Line reflow status = %s\n", LineReflowStatusNames[lineReflowStatus]);
   1:   }
   1: #endif
   1:   *aLineReflowStatus = lineReflowStatus;
   1: 
   1:   return rv;
   1: }
   1: 
   1: /**
   1:  * Reflow an inline frame. The reflow status is mapped from the frames
   1:  * reflow status to the lines reflow status (not to our reflow status).
   1:  * The line reflow status is simple: PR_TRUE means keep placing frames
   1:  * on the line; PR_FALSE means don't (the line is done). If the line
   1:  * has some sort of breaking affect then aLine's break-type will be set
   1:  * to something other than NS_STYLE_CLEAR_NONE.
   1:  */
   1: nsresult
   1: nsBlockFrame::ReflowInlineFrame(nsBlockReflowState& aState,
   1:                                 nsLineLayout& aLineLayout,
   1:                                 line_iterator aLine,
   1:                                 nsIFrame* aFrame,
   1:                                 LineReflowStatus* aLineReflowStatus)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aFrame);
   1:   
   1:   *aLineReflowStatus = LINE_REFLOW_OK;
   1: 
   1:   // If it's currently ok to be reflowing in first-letter style then
   1:   // we must be about to reflow a frame that has first-letter style.
   1:   PRBool reflowingFirstLetter = aLineLayout.GetFirstLetterStyleOK();
   1: #ifdef NOISY_FIRST_LETTER
   1:   ListTag(stdout);
   1:   printf(": reflowing ");
   1:   nsFrame::ListTag(stdout, aFrame);
   1:   printf(" reflowingFirstLetter=%s\n", reflowingFirstLetter ? "on" : "off");
   1: #endif
   1: 
   1:   // Reflow the inline frame
   1:   nsReflowStatus frameReflowStatus;
   1:   PRBool         pushedFrame;
   1:   nsresult rv = aLineLayout.ReflowFrame(aFrame, frameReflowStatus,
   1:                                         nsnull, pushedFrame);
 709:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (frameReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW) {
   1:     // we need to ensure that the frame's nextinflow gets reflowed.
   1:     aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
3233:     nsBlockFrame* ourNext = static_cast<nsBlockFrame*>(GetNextInFlow());
   1:     if (ourNext && aFrame->GetNextInFlow()) {
   1:       line_iterator f = ourNext->FindLineFor(aFrame->GetNextInFlow());
   1:       if (f != ourNext->end_lines()) {
   1:         f->MarkDirty();
   1:       }
   1:     }
   1:   }
   1: 
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: #ifdef REALLY_NOISY_REFLOW_CHILD
   1:   nsFrame::ListTag(stdout, aFrame);
   1:   printf(": status=%x\n", frameReflowStatus);
   1: #endif
   1: 
   1: #if defined(REFLOW_STATUS_COVERAGE)
   1:   RecordReflowStatus(PR_FALSE, frameReflowStatus);
   1: #endif
   1: 
   1:   // Send post-reflow notification
   1:   aState.mPrevChild = aFrame;
   1: 
   1:    /* XXX
   1:       This is where we need to add logic to handle some odd behavior.
   1:       For one thing, we should usually place at least one thing next
   1:       to a left float, even when that float takes up all the width on a line.
   1:       see bug 22496
   1:    */
   1: 
   1:   // Process the child frames reflow status. There are 5 cases:
   1:   // complete, not-complete, break-before, break-after-complete,
   1:   // break-after-not-complete. There are two situations: we are a
   1:   // block or we are an inline. This makes a total of 10 cases
   1:   // (fortunately, there is some overlap).
   1:   aLine->SetBreakTypeAfter(NS_STYLE_CLEAR_NONE);
   1:   if (NS_INLINE_IS_BREAK(frameReflowStatus) || 
   1:       (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType)) {
   1:     // Always abort the line reflow (because a line break is the
   1:     // minimal amount of break we do).
   1:     *aLineReflowStatus = LINE_REFLOW_STOP;
   1: 
   1:     // XXX what should aLine's break-type be set to in all these cases?
   1:     PRUint8 breakType = NS_INLINE_GET_BREAK_TYPE(frameReflowStatus);
   1:     NS_ASSERTION((NS_STYLE_CLEAR_NONE != breakType) || 
   1:                  (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType), "bad break type");
   1:     NS_ASSERTION(NS_STYLE_CLEAR_PAGE != breakType, "no page breaks yet");
   1: 
   1:     if (NS_INLINE_IS_BREAK_BEFORE(frameReflowStatus)) {
   1:       // Break-before cases.
   1:       if (aFrame == aLine->mFirstChild) {
   1:         // If we break before the first frame on the line then we must
   1:         // be trying to place content where there's no room (e.g. on a
   1:         // line with wide floats). Inform the caller to reflow the
   1:         // line after skipping past a float.
   1:         *aLineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
   1:       }
   1:       else {
   1:         // It's not the first child on this line so go ahead and split
   1:         // the line. We will see the frame again on the next-line.
   1:         rv = SplitLine(aState, aLineLayout, aLine, aFrame, aLineReflowStatus);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:         // If we're splitting the line because the frame didn't fit and it
   1:         // was pushed, then mark the line as having word wrapped. We need to
   1:         // know that if we're shrink wrapping our width
   1:         if (pushedFrame) {
   1:           aLine->SetLineWrapped(PR_TRUE);
   1:         }
   1:       }
   1:     }
   1:     else {
   1:       // If a float split and its prev-in-flow was followed by a <BR>, then combine 
   1:       // the <BR>'s break type with the inline's break type (the inline will be the very 
   1:       // next frame after the split float).
   1:       if (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType) {
   1:         breakType = nsLayoutUtils::CombineBreakType(breakType,
   1:                                                     aState.mFloatBreakType);
   1:         aState.mFloatBreakType = NS_STYLE_CLEAR_NONE;
   1:       }
   1:       // Break-after cases
   1:       if (breakType == NS_STYLE_CLEAR_LINE) {
   1:         if (!aLineLayout.GetLineEndsInBR()) {
   1:           breakType = NS_STYLE_CLEAR_NONE;
   1:         }
   1:       }
   1:       aLine->SetBreakTypeAfter(breakType);
   1:       if (NS_FRAME_IS_NOT_COMPLETE(frameReflowStatus)) {
   1:         // Create a continuation for the incomplete frame. Note that the
   1:         // frame may already have a continuation.
   1:         PRBool madeContinuation;
   1:         rv = CreateContinuationFor(aState, aLine, aFrame, madeContinuation);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:         if (!aLineLayout.GetLineEndsInBR()) {
   1:           // Remember that the line has wrapped
   1:           aLine->SetLineWrapped(PR_TRUE);
   1:         }
   1:       }
   1: 
   1:       // Split line, but after the frame just reflowed
   1:       rv = SplitLine(aState, aLineLayout, aLine, aFrame->GetNextSibling(), aLineReflowStatus);
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:       if (NS_FRAME_IS_NOT_COMPLETE(frameReflowStatus) ||
   1:           (NS_INLINE_IS_BREAK_AFTER(frameReflowStatus) &&
   1:            !aLineLayout.GetLineEndsInBR())) {
   1:         // Mark next line dirty in case SplitLine didn't end up
   1:         // pushing any frames.
   1:         nsLineList_iterator next = aLine.next();
   1:         if (next != end_lines() && !next->IsBlock()) {
   1:           next->MarkDirty();
   1:         }
   1:       }
   1:     }
   1:   }
8521:   else if (NS_FRAME_IS_TRUNCATED(frameReflowStatus) &&
8521:            nsGkAtoms::placeholderFrame == aFrame->GetType()) {
8521:     // if the frame is a placeholder and was complete but truncated (and not at the top
8521:     // of page), the entire line will be pushed to give it another chance to not truncate.
8521:     *aLineReflowStatus = LINE_REFLOW_TRUNCATED;
8521:   }  
   1:   else if (NS_FRAME_IS_NOT_COMPLETE(frameReflowStatus)) {
   1:     // Frame is not-complete, no special breaking status
   1: 
   1:     nsIAtom* frameType = aFrame->GetType();
   1: 
   1:     // Create a continuation for the incomplete frame. Note that the
   1:     // frame may already have a continuation.
   1:     PRBool madeContinuation;
   1:     rv = (nsGkAtoms::placeholderFrame == frameType)
   1:          ? SplitPlaceholder(aState, aFrame)
   1:          : CreateContinuationFor(aState, aLine, aFrame, madeContinuation);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     // Remember that the line has wrapped
   1:     if (!aLineLayout.GetLineEndsInBR()) {
   1:       aLine->SetLineWrapped(PR_TRUE);
   1:     }
   1:     
   1:     // If we are reflowing the first letter frame or a placeholder then 
   1:     // don't split the line and don't stop the line reflow...
   1:     PRBool splitLine = !reflowingFirstLetter && 
   1:       nsGkAtoms::placeholderFrame != frameType;
   1:     if (reflowingFirstLetter) {
   1:       if ((nsGkAtoms::inlineFrame == frameType) ||
   1:           (nsGkAtoms::lineFrame == frameType)) {
   1:         splitLine = PR_TRUE;
   1:       }
   1:     }
   1: 
   1:     if (splitLine) {
   1:       // Split line after the current frame
   1:       *aLineReflowStatus = LINE_REFLOW_STOP;
   1:       rv = SplitLine(aState, aLineLayout, aLine, aFrame->GetNextSibling(), aLineReflowStatus);
   1:       NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:       // Mark next line dirty in case SplitLine didn't end up
   1:       // pushing any frames.
   1:       nsLineList_iterator next = aLine.next();
   1:       if (next != end_lines() && !next->IsBlock()) {
   1:         next->MarkDirty();
   1:       }
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:  * Create a continuation, if necessary, for aFrame. Place it in aLine
   1:  * if aLine is not null. Set aMadeNewFrame to PR_TRUE if a new frame is created.
   1:  */
   1: nsresult
   1: nsBlockFrame::CreateContinuationFor(nsBlockReflowState& aState,
   1:                                     nsLineBox*          aLine,
   1:                                     nsIFrame*           aFrame,
   1:                                     PRBool&             aMadeNewFrame)
   1: {
   1:   aMadeNewFrame = PR_FALSE;
   1:   nsresult rv;
   1:   nsIFrame* nextInFlow;
   1:   rv = CreateNextInFlow(aState.mPresContext, this, aFrame, nextInFlow);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   if (nsnull != nextInFlow) {
   1:     aMadeNewFrame = PR_TRUE;
   1:     if (aLine) { 
   1:       aLine->SetChildCount(aLine->GetChildCount() + 1);
   1:     }
   1:   }
   1: #ifdef DEBUG
   1:   VerifyLines(PR_FALSE);
   1: #endif
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsBlockFrame::SplitPlaceholder(nsBlockReflowState& aState,
   1:                                nsIFrame*           aPlaceholder)
   1: {
   1:   nsIFrame* nextInFlow;
   1:   nsresult rv = CreateNextInFlow(aState.mPresContext, this, aPlaceholder, nextInFlow);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (!nextInFlow) {
   1:     // Next in flow was not created because it already exists.
   1:     return NS_OK;
   1:   }
   1: 
   1:   // put the sibling list back to what it was before the continuation was created
   1:   nsIFrame *contFrame = aPlaceholder->GetNextSibling();
   1:   nsIFrame *next = contFrame->GetNextSibling();
   1:   aPlaceholder->SetNextSibling(next);
   1:   contFrame->SetNextSibling(nsnull);
   1:   
   1:   NS_ASSERTION(IsContinuationPlaceholder(contFrame),
   1:                "Didn't create the right kind of frame");
   1: 
   1:   // The new out of flow frame does not get put anywhere; the out-of-flows
   1:   // for placeholders in mOverflowPlaceholders are not kept in any child list
   1:   aState.mOverflowPlaceholders.AppendFrame(this, contFrame);
   1:   return NS_OK;
   1: }
   1: 
   1: static nsFloatCache*
   1: GetLastFloat(nsLineBox* aLine)
   1: {
   1:   nsFloatCache* fc = aLine->GetFirstFloat();
   1:   while (fc && fc->Next()) {
   1:     fc = fc->Next();
   1:   }
   1:   return fc;
   1: }
   1: 
   1: static PRBool
   1: CheckPlaceholderInLine(nsIFrame* aBlock, nsLineBox* aLine, nsFloatCache* aFC)
   1: {
   1:   if (!aFC)
   1:     return PR_TRUE;
   1:   for (nsIFrame* f = aFC->mPlaceholder; f; f = f->GetParent()) {
   1:     if (f->GetParent() == aBlock)
   1:       return aLine->Contains(f);
   1:   }
   1:   NS_ASSERTION(PR_FALSE, "aBlock is not an ancestor of aFrame!");
   1:   return PR_TRUE;
   1: }
   1: 
   1: nsresult
   1: nsBlockFrame::SplitLine(nsBlockReflowState& aState,
   1:                         nsLineLayout& aLineLayout,
   1:                         line_iterator aLine,
   1:                         nsIFrame* aFrame,
   1:                         LineReflowStatus* aLineReflowStatus)
   1: {
   1:   NS_ABORT_IF_FALSE(aLine->IsInline(), "illegal SplitLine on block line");
   1: 
   1:   PRInt32 pushCount = aLine->GetChildCount() - aLineLayout.GetCurrentSpanCount();
   1:   NS_ABORT_IF_FALSE(pushCount >= 0, "bad push count"); 
   1: 
   1: #ifdef DEBUG
   1:   if (gNoisyReflow) {
   1:     nsFrame::IndentBy(stdout, gNoiseIndent);
   1:     printf("split line: from line=%p pushCount=%d aFrame=",
3233:            static_cast<void*>(aLine.get()), pushCount);
   1:     if (aFrame) {
   1:       nsFrame::ListTag(stdout, aFrame);
   1:     }
   1:     else {
   1:       printf("(null)");
   1:     }
   1:     printf("\n");
   1:     if (gReallyNoisyReflow) {
   1:       aLine->List(stdout, gNoiseIndent+1);
   1:     }
   1:   }
   1: #endif
   1: 
   1:   if (0 != pushCount) {
   1:     NS_ABORT_IF_FALSE(aLine->GetChildCount() > pushCount, "bad push");
   1:     NS_ABORT_IF_FALSE(nsnull != aFrame, "whoops");
   1:     NS_ASSERTION(nsFrameList(aFrame).GetLength() >= pushCount,
   1:                  "Not enough frames to push");
   1: 
   1:     // Put frames being split out into their own line
   1:     nsLineBox* newLine = aState.NewLineBox(aFrame, pushCount, PR_FALSE);
   1:     if (!newLine) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     mLines.after_insert(aLine, newLine);
   1:     aLine->SetChildCount(aLine->GetChildCount() - pushCount);
   1: #ifdef DEBUG
   1:     if (gReallyNoisyReflow) {
   1:       newLine->List(stdout, gNoiseIndent+1);
   1:     }
   1: #endif
   1: 
   1:     // Let line layout know that some frames are no longer part of its
   1:     // state.
   1:     aLineLayout.SplitLineTo(aLine->GetChildCount());
   1: 
   1:     // If floats have been placed whose placeholders have been pushed to the new
   1:     // line, we need to reflow the old line again. We don't want to look at the
   1:     // frames in the new line, because as a large paragraph is laid out the 
   1:     // we'd get O(N^2) performance. So instead we just check that the last
   1:     // float and the last below-current-line float are still in aLine.
   1:     if (!CheckPlaceholderInLine(this, aLine, GetLastFloat(aLine)) ||
   1:         !CheckPlaceholderInLine(this, aLine, aState.mBelowCurrentLineFloats.Tail())) {
   1:       *aLineReflowStatus = LINE_REFLOW_REDO_NO_PULL;
   1:     }
   1: 
   1: #ifdef DEBUG
   1:     VerifyLines(PR_TRUE);
   1: #endif
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: PRBool
   1: nsBlockFrame::ShouldJustifyLine(nsBlockReflowState& aState,
   1:                                 line_iterator aLine)
   1: {
   1:   while (++aLine != end_lines()) {
   1:     // There is another line
   1:     if (0 != aLine->GetChildCount()) {
   1:       // If the next line is a block line then we must not justify
   1:       // this line because it means that this line is the last in a
   1:       // group of inline lines.
   1:       return !aLine->IsBlock();
   1:     }
   1:     // The next line is empty, try the next one
   1:   }
   1: 
   1:   // XXX Not sure about this part
   1:   // Try our next-in-flows lines to answer the question
   1:   nsBlockFrame* nextInFlow = (nsBlockFrame*) GetNextInFlow();
   1:   while (nsnull != nextInFlow) {
   1:     for (line_iterator line = nextInFlow->begin_lines(),
   1:                    line_end = nextInFlow->end_lines();
   1:          line != line_end;
   1:          ++line)
   1:     {
   1:       if (0 != line->GetChildCount())
   1:         return !line->IsBlock();
   1:     }
   1:     nextInFlow = (nsBlockFrame*) nextInFlow->GetNextInFlow();
   1:   }
   1: 
   1:   // This is the last line - so don't allow justification
   1:   return PR_FALSE;
   1: }
   1: 
8521: void
   1: nsBlockFrame::PlaceLine(nsBlockReflowState& aState,
   1:                         nsLineLayout&       aLineLayout,
   1:                         line_iterator       aLine,
   1:                         PRBool*             aKeepReflowGoing)
   1: {
   1:   // Trim extra white-space from the line before placing the frames
   1:   aLineLayout.TrimTrailingWhiteSpace();
   1: 
   1:   // Vertically align the frames on this line.
   1:   //
   1:   // According to the CSS2 spec, section 12.6.1, the "marker" box
   1:   // participates in the height calculation of the list-item box's
   1:   // first line box.
   1:   //
   1:   // There are exactly two places a bullet can be placed: near the
   1:   // first or second line. It's only placed on the second line in a
   1:   // rare case: an empty first line followed by a second line that
   1:   // contains a block (example: <LI>\n<P>... ).
   1:   //
   1:   // For this code, only the first case is possible because this
   1:   // method is used for placing a line of inline frames. If the rare
   1:   // case is happening then the worst that will happen is that the
   1:   // bullet frame will be reflowed twice.
   1:   PRBool addedBullet = PR_FALSE;
   1:   if (mBullet && HaveOutsideBullet() && (aLine == mLines.front()) &&
   1:       (!aLineLayout.IsZeroHeight() || (aLine == mLines.back()))) {
   1:     nsHTMLReflowMetrics metrics;
   1:     ReflowBullet(aState, metrics);
   1:     aLineLayout.AddBulletFrame(mBullet, metrics);
   1:     addedBullet = PR_TRUE;
   1:   }
   1:   aLineLayout.VerticalAlignLine();
   1: 
   1: #ifdef DEBUG
   1:   {
   1:     static nscoord lastHeight = 0;
   1:     if (CRAZY_HEIGHT(aLine->mBounds.y)) {
   1:       lastHeight = aLine->mBounds.y;
   1:       if (abs(aLine->mBounds.y - lastHeight) > CRAZY_H/10) {
   1:         nsFrame::ListTag(stdout);
   1:         printf(": line=%p y=%d line.bounds.height=%d\n",
3233:                static_cast<void*>(aLine.get()),
   1:                aLine->mBounds.y, aLine->mBounds.height);
   1:       }
   1:     }
   1:     else {
   1:       lastHeight = 0;
   1:     }
   1:   }
   1: #endif
   1: 
   1:   // Only block frames horizontally align their children because
   1:   // inline frames "shrink-wrap" around their children (therefore
   1:   // there is no extra horizontal space).
   1:   const nsStyleText* styleText = GetStyleText();
   1:   PRBool allowJustify = NS_STYLE_TEXT_ALIGN_JUSTIFY == styleText->mTextAlign &&
   1:                         !aLineLayout.GetLineEndsInBR() &&
   1:                         ShouldJustifyLine(aState, aLine);
   1:   aLineLayout.HorizontalAlignFrames(aLine->mBounds, allowJustify);
   1:   // XXX: not only bidi: right alignment can be broken after
   1:   // RelativePositionFrames!!!
   1:   // XXXldb Is something here considering relatively positioned frames at
   1:   // other than their original positions?
   1: #ifdef IBMBIDI
   1:   // XXXldb Why don't we do this earlier?
   1:   if (aState.mPresContext->BidiEnabled()) {
   1:     if (!aState.mPresContext->IsVisualMode()) {
   1:       nsBidiPresUtils* bidiUtils = aState.mPresContext->GetBidiUtils();
   1: 
   1:       if (bidiUtils && bidiUtils->IsSuccessful() ) {
5423:         bidiUtils->ReorderFrames(aLine->mFirstChild, aLine->GetChildCount());
   1:       } // bidiUtils
   1:     } // not visual mode
   1:   } // bidi enabled
   1: #endif // IBMBIDI
   1: 
   1:   nsRect combinedArea;
   1:   aLineLayout.RelativePositionFrames(combinedArea);  // XXXldb This returned width as -15, 2001-06-12, Bugzilla
   1:   aLine->SetCombinedArea(combinedArea);
   1:   if (addedBullet) {
   1:     aLineLayout.RemoveBulletFrame(mBullet);
   1:   }
   1: 
   1:   // Inline lines do not have margins themselves; however they are
   1:   // impacted by prior block margins. If this line ends up having some
   1:   // height then we zero out the previous bottom margin value that was
   1:   // already applied to the line's starting Y coordinate. Otherwise we
   1:   // leave it be so that the previous blocks bottom margin can be
   1:   // collapsed with a block that follows.
   1:   nscoord newY;
   1: 
   1:   if (!aLine->CachedIsEmpty()) {
   1:     // This line has some height. Therefore the application of the
   1:     // previous-bottom-margin should stick.
   1:     aState.mPrevBottomMargin.Zero();
   1:     newY = aLine->mBounds.YMost();
   1:   }
   1:   else {
   1:     // Don't let the previous-bottom-margin value affect the newY
   1:     // coordinate (it was applied in ReflowInlineFrames speculatively)
   1:     // since the line is empty.
   1:     // We already called |ShouldApplyTopMargin|, and if we applied it
   1:     // then BRS_APPLYTOPMARGIN is set.
   1:     nscoord dy = aState.GetFlag(BRS_APPLYTOPMARGIN)
   1:                    ? -aState.mPrevBottomMargin.get() : 0;
   1:     newY = aState.mY + dy;
   1:     aLine->SlideBy(dy); // XXXldb Do we really want to do this?
   1:   }
   1: 
   1:   // See if the line fit. If it doesn't we need to push it. Our first
   1:   // line will always fit.
   1:   if (mLines.front() != aLine &&
   1:       newY > aState.mBottomEdge &&
   1:       aState.mBottomEdge != NS_UNCONSTRAINEDSIZE) {
   1:     // Push this line and all of its children and anything else that
   1:     // follows to our next-in-flow
   1:     NS_ASSERTION((aState.mCurrentLine == aLine), "oops");
   1:     PushLines(aState, aLine.prev());
   1: 
   1:     // Stop reflow and whack the reflow status if reflow hasn't
   1:     // already been stopped.
   1:     if (*aKeepReflowGoing) {
4006:       NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
   1:       *aKeepReflowGoing = PR_FALSE;
   1:     }
8521:     return;
   1:   }
   1: 
   1:   // May be needed below
   1:   PRBool wasAdjacentWIthTop = aState.IsAdjacentWithTop();
   1: 
   1:   aState.mY = newY;
   1:   
   1:   // Add the already placed current-line floats to the line
   1:   aLine->AppendFloats(aState.mCurrentLineFloats);
   1: 
   1:   // Any below current line floats to place?
   1:   if (aState.mBelowCurrentLineFloats.NotEmpty()) {
   1:     // Reflow the below-current-line floats, then add them to the
   1:     // lines float list if there aren't any truncated floats.
   1:     if (aState.PlaceBelowCurrentLineFloats(aState.mBelowCurrentLineFloats,
   1:                                            wasAdjacentWIthTop)) {
   1:       aLine->AppendFloats(aState.mBelowCurrentLineFloats);
   1:     }
   1:     else { 
   1:       // At least one float is truncated, so fix up any placeholders that got split and 
   1:       // push the line. XXX It may be better to put the float on the next line, but this 
   1:       // is not common enough to justify the complexity. Or maybe it is now...
8521:       PushTruncatedPlaceholderLine(aState, aLine, *aKeepReflowGoing);
   1:     }
   1:   }
   1: 
   1:   // When a line has floats, factor them into the combined-area
   1:   // computations.
   1:   if (aLine->HasFloats()) {
   1:     // Combine the float combined area (stored in aState) and the
   1:     // value computed by the line layout code.
   1:     nsRect lineCombinedArea(aLine->GetCombinedArea());
   1: #ifdef NOISY_COMBINED_AREA
   1:     ListTag(stdout);
   1:     printf(": lineCA=%d,%d,%d,%d floatCA=%d,%d,%d,%d\n",
   1:            lineCombinedArea.x, lineCombinedArea.y,
   1:            lineCombinedArea.width, lineCombinedArea.height,
   1:            aState.mFloatCombinedArea.x, aState.mFloatCombinedArea.y,
   1:            aState.mFloatCombinedArea.width,
   1:            aState.mFloatCombinedArea.height);
   1: #endif
   1:     lineCombinedArea.UnionRect(aState.mFloatCombinedArea, lineCombinedArea);
   1: 
   1:     aLine->SetCombinedArea(lineCombinedArea);
   1: #ifdef NOISY_COMBINED_AREA
   1:     printf("  ==> final lineCA=%d,%d,%d,%d\n",
   1:            lineCombinedArea.x, lineCombinedArea.y,
   1:            lineCombinedArea.width, lineCombinedArea.height);
   1: #endif
   1:   }
   1: 
   1:   // Apply break-after clearing if necessary
   1:   // This must stay in sync with |ReflowDirtyLines|.
   1:   if (aLine->HasFloatBreakAfter()) {
   1:     aState.mY = aState.ClearFloats(aState.mY, aLine->GetBreakTypeAfter());
   1:   }
   1: }
   1: 
   1: void
   1: nsBlockFrame::PushLines(nsBlockReflowState&  aState,
   1:                         nsLineList::iterator aLineBefore)
   1: {
   1:   nsLineList::iterator overBegin(aLineBefore.next());
   1: 
   1:   // PushTruncatedPlaceholderLine sometimes pushes the first line.  Ugh.
   1:   PRBool firstLine = overBegin == begin_lines();
   1: 
   1:   if (overBegin != end_lines()) {
   1:     // Remove floats in the lines from mFloats
   1:     nsFrameList floats;
   1:     nsIFrame* tail = nsnull;
 686:     CollectFloats(overBegin->mFirstChild, floats, &tail, PR_FALSE, PR_TRUE);
   1: 
   1:     if (floats.NotEmpty()) {
   1:       // Push the floats onto the front of the overflow out-of-flows list
   1:       nsFrameList oofs = GetOverflowOutOfFlows();
   1:       if (oofs.NotEmpty()) {
   1:         floats.InsertFrames(nsnull, tail, oofs.FirstChild());
   1:       }
   1:       SetOverflowOutOfFlows(floats);
   1:     }
   1: 
   1:     // overflow lines can already exist in some cases, in particular,
   1:     // when shrinkwrapping and we discover that the shrinkwap causes
   1:     // the height of some child block to grow which creates additional
   1:     // overflowing content. In such cases we must prepend the new
   1:     // overflow to the existing overflow.
   1:     nsLineList* overflowLines = RemoveOverflowLines();
   1:     if (!overflowLines) {
   1:       // XXXldb use presshell arena!
   1:       overflowLines = new nsLineList();
   1:     }
   1:     if (overflowLines) {
   1:       if (!overflowLines->empty()) {
   1:         mLines.back()->LastChild()->SetNextSibling(overflowLines->front()->mFirstChild);
   1:       }
   1:       overflowLines->splice(overflowLines->begin(), mLines, overBegin,
   1:                             end_lines());
   1:       NS_ASSERTION(!overflowLines->empty(), "should not be empty");
   1:       // this takes ownership but it won't delete it immediately so we
   1:       // can keep using it.
   1:       SetOverflowLines(overflowLines);
   1:   
   1:       // Mark all the overflow lines dirty so that they get reflowed when
   1:       // they are pulled up by our next-in-flow.
   1: 
   1:       // XXXldb Can this get called O(N) times making the whole thing O(N^2)?
   1:       for (line_iterator line = overflowLines->begin(),
   1:              line_end = overflowLines->end();
   1:            line != line_end;
   1:            ++line)
   1:         {
   1:           line->MarkDirty();
   1:           line->MarkPreviousMarginDirty();
   1:           line->mBounds.SetRect(0, 0, 0, 0);
   1:           if (line->HasFloats()) {
   1:             line->FreeFloats(aState.mFloatCacheFreeList);
   1:           }
   1:         }
   1:     }
   1:   }
   1: 
   1:   // Break frame sibling list
   1:   if (!firstLine)
   1:     aLineBefore->LastChild()->SetNextSibling(nsnull);
   1: 
   1: #ifdef DEBUG
   1:   VerifyOverflowSituation();
   1: #endif
   1: }
   1: 
   1: /**
   1:  * Call this when a frame will be pulled from the block's
   1:  * next-in-flow into this frame. If it's a continuation placeholder,
   1:  * it should not be here so we push it into our overflow placeholders
   1:  * list. To avoid creating holes (e.g., the following block doesn't
   1:  * have a placeholder but the block after it does) we also need to
   1:  * pull all the following placeholders and put them in our overflow
   1:  * placeholders list too.
   1:  *
   1:  * If it's a first-in-flow placeholder, or it contains one, then we
   1:  * need to do this to the continuation placeholders.
   1:  *
   1:  * We return PR_TRUE if we removed the frame and it cannot be used.
   1:  * If we return PR_FALSE then the frame *must* be pulled immediately.
   1:  */
   1: PRBool
   1: nsBlockFrame::HandleOverflowPlaceholdersForPulledFrame(
   1:   nsBlockReflowState& aState, nsIFrame* aFrame)
   1: {
   1:   if (nsGkAtoms::placeholderFrame != aFrame->GetType()) {
   1:     // Descend into children that are not float containing blocks.
   1:     // We should encounter only first-in-flow placeholders, so the
   1:     // frame subtree rooted at aFrame should not change.
   1:     if (!aFrame->IsFloatContainingBlock()) {
   1:       for (nsIFrame* f = aFrame->GetFirstChild(nsnull); f; f = f->GetNextSibling()) {
   1: #ifdef DEBUG
   1:         PRBool changed =
   1: #endif
   1:           HandleOverflowPlaceholdersForPulledFrame(aState, f);
   1:         NS_ASSERTION(!changed, "Shouldn't find any continuation placeholders inside inlines");
   1:       }
   1:     }
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   PRBool taken = PR_TRUE;
   1:   nsIFrame* frame = aFrame;
   1:   if (!aFrame->GetPrevInFlow()) {
   1:     // First in flow frame. We only want to deal with its
   1:     // next in flows, if there are any.
   1:     taken = PR_FALSE;
   1:     frame = frame->GetNextInFlow();
   1:     if (!frame)
   1:       return PR_FALSE;
   1:   }
   1: 
3233:   nsBlockFrame* parent = static_cast<nsBlockFrame*>(frame->GetParent());
   1:   // Remove aFrame and all its next in flows from their parents, but
   1:   // don't destroy the frames.
   1: #ifdef DEBUG
   1:   nsresult rv =
   1: #endif
   1:     parent->DoRemoveFrame(frame, PR_FALSE);
   1:   NS_ASSERTION(NS_SUCCEEDED(rv), "frame should be in parent's lists");
   1:   
   1:   nsIFrame* lastOverflowPlace = aState.mOverflowPlaceholders.LastChild();
   1:   while (frame) {
   1:     NS_ASSERTION(IsContinuationPlaceholder(frame),
   1:                  "Should only be dealing with continuation placeholders here");
   1: 
3233:     parent = static_cast<nsBlockFrame*>(frame->GetParent());
   1:     ReparentFrame(frame, parent, this);
   1: 
   1:     // continuation placeholders are always direct children of a block
   1:     nsIFrame* outOfFlow = nsPlaceholderFrame::GetRealFrameForPlaceholder(frame);
   1: 
   1:     if (!parent->mFloats.RemoveFrame(outOfFlow)) {
   1:       nsAutoOOFFrameList oofs(parent);
   1: #ifdef DEBUG
   1:       PRBool found =
   1: #endif
   1:         oofs.mList.RemoveFrame(outOfFlow);
   1:       NS_ASSERTION(found, "Must have the out of flow in some child list");
   1:     }
   1:     ReparentFrame(outOfFlow, parent, this);
   1: 
   1:     aState.mOverflowPlaceholders.InsertFrames(nsnull, lastOverflowPlace, frame);
   1:     // outOfFlow isn't inserted anywhere yet. Eventually the overflow
   1:     // placeholders get put into the overflow lines, and at the same time we
   1:     // insert the placeholders' out of flows into the overflow out-of-flows
   1:     // list.
   1:     lastOverflowPlace = frame;
   1: 
   1:     frame = frame->GetNextInFlow();
   1:   }
   1: 
   1:   return taken;
   1: }
   1: 
   1: /**
   1:  * Call this when a line will be pulled from the block's
   1:  * next-in-flow's line.
   1:  *
   1:  * @return PR_TRUE we consumed the entire line, delete it and try again
   1:  */
   1: PRBool
   1: nsBlockFrame::HandleOverflowPlaceholdersOnPulledLine(
   1:   nsBlockReflowState& aState, nsLineBox* aLine)
   1: {
   1:   // First, see if it's a line of continuation placeholders. If it
   1:   // is, remove one and retry.
   1:   if (aLine->mFirstChild && IsContinuationPlaceholder(aLine->mFirstChild)) {
   1:     PRBool taken =
   1:       HandleOverflowPlaceholdersForPulledFrame(aState, aLine->mFirstChild);
   1:     NS_ASSERTION(taken, "We must have removed that frame");
   1:     return PR_TRUE;
   1:   }
   1:  
   1:   // OK, it's a normal line. Scan it for floats with continuations that
   1:   // need to be taken care of. We won't need to change the line.
   1:   PRInt32 n = aLine->GetChildCount();
   1:   for (nsIFrame* f = aLine->mFirstChild; n > 0; f = f->GetNextSibling(), --n) {
   1: #ifdef DEBUG
   1:     PRBool taken =
   1: #endif
   1:       HandleOverflowPlaceholdersForPulledFrame(aState, f);
   1:     NS_ASSERTION(!taken, "Shouldn't be any continuation placeholders on this line");
   1:   }
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
   1: // The overflowLines property is stored as a pointer to a line list,
   1: // which must be deleted.  However, the following functions all maintain
   1: // the invariant that the property is never set if the list is empty.
   1: 
   1: PRBool
   1: nsBlockFrame::DrainOverflowLines(nsBlockReflowState& aState)
   1: {
   1: #ifdef DEBUG
   1:   VerifyOverflowSituation();
   1: #endif
   1:   nsLineList* overflowLines = nsnull;
   1:   nsLineList* ourOverflowLines = nsnull;
   1: 
   1:   // First grab the prev-in-flows overflow lines
   1:   nsBlockFrame* prevBlock = (nsBlockFrame*) GetPrevInFlow();
   1:   if (prevBlock) {
   1:     overflowLines = prevBlock->RemoveOverflowLines();
   1:     if (overflowLines) {
   1:       NS_ASSERTION(! overflowLines->empty(),
   1:                    "overflow lines should never be set and empty");
   1:       // Make all the frames on the overflow line list mine
   1:       nsIFrame* frame = overflowLines->front()->mFirstChild;
   1:       while (nsnull != frame) {
   1:         ReparentFrame(frame, prevBlock, this);
   1: 
   1:         // Get the next frame
   1:         frame = frame->GetNextSibling();
   1:       }
   1: 
   1:       // make the overflow out-of-flow frames mine too
   1:       nsAutoOOFFrameList oofs(prevBlock);
   1:       if (oofs.mList.NotEmpty()) {
   1:         for (nsIFrame* f = oofs.mList.FirstChild(); f; f = f->GetNextSibling()) {
   1:           ReparentFrame(f, prevBlock, this);
   1:         }
   1:         mFloats.InsertFrames(nsnull, nsnull, oofs.mList.FirstChild());
   1:         oofs.mList.SetFrames(nsnull);
   1:       }
   1:     }
   1:     
   1:     // The lines on the overflow list have already been marked dirty and their
   1:     // previous margins marked dirty also.
   1:   }
   1: 
   1:   // Don't need to reparent frames in our own overflow lines/oofs, because they're
   1:   // already ours. But we should put overflow floats back in mFloats.
   1:   ourOverflowLines = RemoveOverflowLines();
   1:   if (ourOverflowLines) {
   1:     nsAutoOOFFrameList oofs(this);
   1:     if (oofs.mList.NotEmpty()) {
   1:       // The overflow floats go after our regular floats
   1:       mFloats.AppendFrames(nsnull, oofs.mList.FirstChild());
   1:       oofs.mList.SetFrames(nsnull);
   1:     }
   1:   }
   1: 
   1:   if (!overflowLines && !ourOverflowLines) {
   1:     // nothing to do; always the case for non-constrained-height reflows
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   NS_ASSERTION(aState.mOverflowPlaceholders.IsEmpty(),
   1:                "Should have no overflow placeholders yet");
   1: 
   1:   // HANDLING CONTINUATION PLACEHOLDERS (floats only at the moment, because
   1:   // abs-pos frames don't have continuations)
   1:   //
   1:   // All continuation placeholders need to be moved to the front of
   1:   // our line list. We also need to maintain the invariant that at
   1:   // most one frame for a given piece of content is in our normal
   1:   // child list, by pushing all but the first placeholder to our
   1:   // overflow placeholders list.
   1:   // 
   1:   // One problem we have to deal with is that some of these
   1:   // continuation placeholders may have been donated to us by a
   1:   // descendant block that was complete. We need to push them down to
   1:   // a lower block if possible.
   1:   //
   1:   // We keep the lists ordered so that prev in flows come before their
   1:   // next in flows. We do not worry about properly ordering the
   1:   // placeholders for different content relative to each other until
   1:   // the end. Then we sort them.
   1:   //
   1:   // When we're shuffling placeholders we also need to shuffle their out of
   1:   // flows to match. As we put placeholders into keepPlaceholders, we unhook
   1:   // their floats from mFloats. Later we put the floats back based on the
   1:   // order of the placeholders.
   1:   nsIFrame* lastOP = nsnull;
   1:   nsFrameList keepPlaceholders;
   1:   nsFrameList keepOutOfFlows;
   1:   nsIFrame* lastKP = nsnull;
   1:   nsIFrame* lastKOOF = nsnull;
   1:   nsLineList* lineLists[3] = { overflowLines, &mLines, ourOverflowLines };
   1:   static const PRPackedBool searchFirstLinesOnly[3] = { PR_FALSE, PR_TRUE, PR_FALSE };
   1:   for (PRInt32 i = 0; i < 3; ++i) {
   1:     nsLineList* ll = lineLists[i];
   1:     if (ll && !ll->empty()) {
   1:       line_iterator iter = ll->begin();
   1:       line_iterator iter_end = ll->end();
   1:       nsIFrame* lastFrame = nsnull;
   1:       while (iter != iter_end) {
   1:         PRUint32 n = iter->GetChildCount();
   1:         if (n == 0 || !IsContinuationPlaceholder(iter->mFirstChild)) {
   1:           if (lastFrame) {
   1:             lastFrame->SetNextSibling(iter->mFirstChild);
   1:           }
   1:           if (searchFirstLinesOnly[i]) {
   1:             break;
   1:           }
   1:           lastFrame = iter->LastChild();
   1:           ++iter;
   1:         } else {
   1:           nsLineBox* line = iter;
   1:           iter = ll->erase(iter);
   1:           nsIFrame* next;
3233:           for (nsPlaceholderFrame* f = static_cast<nsPlaceholderFrame*>(line->mFirstChild);
3233:                n > 0; --n, f = static_cast<nsPlaceholderFrame*>(next)) {
   1:             if (!IsContinuationPlaceholder(f)) {
   1:               NS_ASSERTION(IsContinuationPlaceholder(f),
   1:                            "Line frames should all be continuation placeholders");
   1:             }
   1:             next = f->GetNextSibling();
   1:             nsIFrame* fpif = f->GetPrevInFlow();
   1:             nsIFrame* oof = f->GetOutOfFlowFrame();
   1:             
   1:             // Take this out of mFloats for now. We may put it back later in
   1:             // this function
   1: #ifdef DEBUG
   1:             PRBool found =
   1: #endif
   1:               mFloats.RemoveFrame(oof);
   1:             NS_ASSERTION(found, "Float should have been put in our mFloats list");
   1: 
   1:             PRBool isAncestor = nsLayoutUtils::IsProperAncestorFrame(this, fpif);
   1:             if (isAncestor) {
   1:               // oops. we already have a prev-in-flow for this
   1:               // placeholder. We have to move this frame out of here. We
   1:               // can put it in our overflow placeholders.
   1:               aState.mOverflowPlaceholders.InsertFrame(nsnull, lastOP, f);
   1:               // Let oof dangle for now, because placeholders in
   1:               // mOverflowPlaceholders do not keep their floats in any child list
   1:               lastOP = f;
   1:             } else {
   1:               if (fpif->GetParent() == prevBlock) {
   1:                 keepPlaceholders.InsertFrame(nsnull, lastKP, f);
   1:                 keepOutOfFlows.InsertFrame(nsnull, lastKOOF, oof);
   1:                 lastKP = f;
   1:                 lastKOOF = oof;
   1:               } else {
   1:                 // Ok, now we're in the tough situation where some child
   1:                 // of prevBlock was complete and pushed its overflow
   1:                 // placeholders up to prevBlock's overflow. We might be
   1:                 // able to find a more appropriate parent for f somewhere
   1:                 // down in our descendants.
   1:                 NS_ASSERTION(nsLayoutUtils::IsProperAncestorFrame(prevBlock, fpif),
   1:                              "bad prev-in-flow ancestor chain");
   1:                 // Find the first ancestor of f's prev-in-flow that has a next in flow
   1:                 // that can contain the float.
   1:                 // That next in flow should become f's parent.
   1:                 nsIFrame* fpAncestor;
   1:                 for (fpAncestor = fpif->GetParent();
   1:                      !fpAncestor->GetNextInFlow() || !fpAncestor->IsFloatContainingBlock();
   1:                      fpAncestor = fpAncestor->GetParent())
   1:                   ;
   1:                 if (fpAncestor == prevBlock) {
   1:                   // We're still the best parent.
   1:                   keepPlaceholders.InsertFrame(nsnull, lastKP, f);
   1:                   keepOutOfFlows.InsertFrame(nsnull, lastKOOF, oof);
   1:                   lastKP = f;
   1:                   lastKOOF = oof;
   1:                 } else {
   1:                   // Just put it at the front of
   1:                   // fpAncestor->GetNextInFlow()'s lines.
   1:                   nsLineBox* newLine = aState.NewLineBox(f, 1, PR_FALSE);
   1:                   if (newLine) {
   1:                     nsBlockFrame* target =
3233:                       static_cast<nsBlockFrame*>(fpAncestor->GetNextInFlow());
   1:                     if (!target->mLines.empty()) {
   1:                       f->SetNextSibling(target->mLines.front()->mFirstChild);
   1:                     } else {
   1:                       f->SetNextSibling(nsnull);
   1:                     }
   1:                     target->mLines.push_front(newLine);
   1:                     ReparentFrame(f, this, target);
   1: 
   1:                     target->mFloats.InsertFrame(nsnull, nsnull, oof);
   1:                     ReparentFrame(oof, this, target);
   1:                   }
   1:                 }
   1:               }
   1:             }
   1:           }
   1:           aState.FreeLineBox(line);
   1:         }
   1:       }
   1:       if (lastFrame) {
   1:         lastFrame->SetNextSibling(nsnull);
   1:       }
   1:     }
   1:   }
   1: 
   1:   // Now join the line lists into mLines
   1:   if (overflowLines) {
   1:     if (!overflowLines->empty()) {
   1:       // Join the line lists
   1:       if (! mLines.empty()) 
   1:         {
   1:           // Remember to recompute the margins on the first line. This will
   1:           // also recompute the correct deltaY if necessary.
   1:           mLines.front()->MarkPreviousMarginDirty();
   1:           // Join the sibling lists together
   1:           nsIFrame* lastFrame = overflowLines->back()->LastChild();
   1:           lastFrame->SetNextSibling(mLines.front()->mFirstChild);
   1:         }
   1:       // Place overflow lines at the front of our line list
   1:       mLines.splice(mLines.begin(), *overflowLines);
   1:       NS_ASSERTION(overflowLines->empty(), "splice should empty list");
   1:     }
   1:     delete overflowLines;
   1:   }
   1:   if (ourOverflowLines) {
   1:     if (!ourOverflowLines->empty()) {
   1:       if (!mLines.empty()) {
   1:         mLines.back()->LastChild()->
   1:           SetNextSibling(ourOverflowLines->front()->mFirstChild);
   1:       }
   1:       // append the overflow to mLines
   1:       mLines.splice(mLines.end(), *ourOverflowLines);
   1:     }
   1:     delete ourOverflowLines;
   1:   }
   1: 
   1:   // store the placeholders that we're keeping in our frame list
   1:   if (keepPlaceholders.NotEmpty()) {
   1:     keepPlaceholders.SortByContentOrder();
   1:     nsLineBox* newLine = aState.NewLineBox(keepPlaceholders.FirstChild(),
   1:                                            keepPlaceholders.GetLength(), PR_FALSE);
   1:     if (newLine) {
   1:       if (!mLines.empty()) {
   1:         keepPlaceholders.LastChild()->SetNextSibling(mLines.front()->mFirstChild);
   1:       }
   1:       mLines.push_front(newLine);
   1:     }
   1: 
   1:     // Put the placeholders' out of flows into the float list
   1:     keepOutOfFlows.SortByContentOrder();
   1:     mFloats.InsertFrames(nsnull, nsnull, keepOutOfFlows.FirstChild());
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: nsLineList*
   1: nsBlockFrame::GetOverflowLines() const
   1: {
   1:   if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_LINES)) {
   1:     return nsnull;
   1:   }
3233:   nsLineList* lines = static_cast<nsLineList*>
3233:                                  (GetProperty(nsGkAtoms::overflowLinesProperty));
   1:   NS_ASSERTION(lines && !lines->empty(),
   1:                "value should always be stored and non-empty when state set");
   1:   return lines;
   1: }
   1: 
   1: nsLineList*
   1: nsBlockFrame::RemoveOverflowLines()
   1: {
   1:   if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_LINES)) {
   1:     return nsnull;
   1:   }
3233:   nsLineList* lines = static_cast<nsLineList*>
3233:                                  (UnsetProperty(nsGkAtoms::overflowLinesProperty));
   1:   NS_ASSERTION(lines && !lines->empty(),
   1:                "value should always be stored and non-empty when state set");
   1:   RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_LINES);
   1:   return lines;
   1: }
   1: 
   1: // Destructor function for the overflowLines frame property
   1: static void
   1: DestroyOverflowLines(void*           aFrame,
   1:                      nsIAtom*        aPropertyName,
   1:                      void*           aPropertyValue,
   1:                      void*           aDtorData)
   1: {
   1:   if (aPropertyValue) {
3233:     nsLineList* lines = static_cast<nsLineList*>(aPropertyValue);
3233:     nsPresContext *context = static_cast<nsPresContext*>(aDtorData);
   1:     nsLineBox::DeleteLineList(context, *lines);
   1:     delete lines;
   1:   }
   1: }
   1: 
   1: // This takes ownership of aOverflowLines.
   1: // XXX We should allocate overflowLines from presShell arena!
   1: nsresult
   1: nsBlockFrame::SetOverflowLines(nsLineList* aOverflowLines)
   1: {
   1:   NS_ASSERTION(aOverflowLines, "null lines");
   1:   NS_ASSERTION(!aOverflowLines->empty(), "empty lines");
   1:   NS_ASSERTION(!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_LINES),
   1:                "Overwriting existing overflow lines");
   1: 
 238:   nsPresContext *presContext = PresContext();
   1:   nsresult rv = presContext->PropertyTable()->
   1:     SetProperty(this, nsGkAtoms::overflowLinesProperty, aOverflowLines,
   1:                 DestroyOverflowLines, presContext);
   1:   // Verify that we didn't overwrite an existing overflow list
   1:   NS_ASSERTION(rv != NS_PROPTABLE_PROP_OVERWRITTEN, "existing overflow list");
   1:   AddStateBits(NS_BLOCK_HAS_OVERFLOW_LINES);
   1:   return rv;
   1: }
   1: 
   1: nsFrameList
   1: nsBlockFrame::GetOverflowOutOfFlows() const
   1: {
   1:   if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS)) {
   1:     return nsFrameList();
   1:   }
3233:   nsIFrame* result = static_cast<nsIFrame*>
3233:                                 (GetProperty(nsGkAtoms::overflowOutOfFlowsProperty));
   1:   NS_ASSERTION(result, "value should always be non-empty when state set");
   1:   return nsFrameList(result);
   1: }
   1: 
   1: // This takes ownership of the frames
   1: void
   1: nsBlockFrame::SetOverflowOutOfFlows(const nsFrameList& aList)
   1: {
   1:   if (aList.IsEmpty()) {
   1:     if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS)) {
   1:       return;
   1:     }
3233:     nsIFrame* result = static_cast<nsIFrame*>
3233:                                   (UnsetProperty(nsGkAtoms::overflowOutOfFlowsProperty));
   1:     NS_ASSERTION(result, "value should always be non-empty when state set");
   1:     RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
   1:   } else {
   1:     SetProperty(nsGkAtoms::overflowOutOfFlowsProperty,
   1:                 aList.FirstChild(), nsnull);
   1:     AddStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
   1:   }
   1: }
   1: 
   1: nsFrameList*
   1: nsBlockFrame::GetOverflowPlaceholders() const
   1: {
   1:   if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_PLACEHOLDERS)) {
   1:     return nsnull;
   1:   }
3233:   nsFrameList* result = static_cast<nsFrameList*>
3233:                                    (GetProperty(nsGkAtoms::overflowPlaceholdersProperty));
   1:   NS_ASSERTION(result, "value should always be non-empty when state set");
   1:   return result;
   1: }
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: // Frame list manipulation routines
   1: 
   1: nsIFrame*
   1: nsBlockFrame::LastChild()
   1: {
   1:   if (! mLines.empty()) {
   1:     return mLines.back()->LastChild();
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::AppendFrames(nsIAtom*  aListName,
   1:                            nsIFrame* aFrameList)
   1: {
   1:   if (nsnull == aFrameList) {
   1:     return NS_OK;
   1:   }
   1:   if (aListName) {
4205:     if (nsGkAtoms::absoluteList == aListName) {
   1:       return mAbsoluteContainer.AppendFrames(this, aListName, aFrameList);
   1:     }
   1:     else if (nsGkAtoms::floatList == aListName) {
   1:       mFloats.AppendFrames(nsnull, aFrameList);
   1:       return NS_OK;
   1:     }
   1:     else {
   1:       NS_ERROR("unexpected child list");
   1:       return NS_ERROR_INVALID_ARG;
   1:     }
   1:   }
   1: 
   1:   // Find the proper last-child for where the append should go
   1:   nsIFrame* lastKid = nsnull;
   1:   nsLineBox* lastLine = mLines.empty() ? nsnull : mLines.back();
   1:   if (lastLine) {
   1:     lastKid = lastLine->LastChild();
   1:   }
   1: 
   1:   // Add frames after the last child
   1: #ifdef NOISY_REFLOW_REASON
   1:   ListTag(stdout);
   1:   printf(": append ");
   1:   nsFrame::ListTag(stdout, aFrameList);
   1:   if (lastKid) {
   1:     printf(" after ");
   1:     nsFrame::ListTag(stdout, lastKid);
   1:   }
   1:   printf("\n");
   1: #endif
   1:   nsresult rv = AddFrames(aFrameList, lastKid);
   1:   if (NS_SUCCEEDED(rv)) {
 238:     PresContext()->PresShell()->
1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
1158:                        NS_FRAME_HAS_DIRTY_CHILDREN); // XXX sufficient?
   1:   }
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::InsertFrames(nsIAtom*  aListName,
   1:                            nsIFrame* aPrevFrame,
   1:                            nsIFrame* aFrameList)
   1: {
   1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
   1:                "inserting after sibling frame with different parent");
   1: 
   1:   if (aListName) {
4205:     if (nsGkAtoms::absoluteList == aListName) {
   1:       return mAbsoluteContainer.InsertFrames(this, aListName, aPrevFrame,
   1:                                              aFrameList);
   1:     }
   1:     else if (nsGkAtoms::floatList == aListName) {
   1:       mFloats.InsertFrames(this, aPrevFrame, aFrameList);
   1:       return NS_OK;
   1:     }
   1: #ifdef IBMBIDI
   1:     else if (nsGkAtoms::nextBidi == aListName) {}
   1: #endif // IBMBIDI
   1:     else {
   1:       NS_ERROR("unexpected child list");
   1:       return NS_ERROR_INVALID_ARG;
   1:     }
   1:   }
   1: 
   1: #ifdef NOISY_REFLOW_REASON
   1:   ListTag(stdout);
   1:   printf(": insert ");
   1:   nsFrame::ListTag(stdout, aFrameList);
   1:   if (aPrevFrame) {
   1:     printf(" after ");
   1:     nsFrame::ListTag(stdout, aPrevFrame);
   1:   }
   1:   printf("\n");
   1: #endif
   1:   nsresult rv = AddFrames(aFrameList, aPrevFrame);
   1: #ifdef IBMBIDI
   1:   if (aListName != nsGkAtoms::nextBidi)
   1: #endif // IBMBIDI
   1:   if (NS_SUCCEEDED(rv)) {
 238:     PresContext()->PresShell()->
1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
1158:                        NS_FRAME_HAS_DIRTY_CHILDREN); // XXX sufficient?
   1:   }
   1:   return rv;
   1: }
   1: 
   1: static PRBool
   1: ShouldPutNextSiblingOnNewLine(nsIFrame* aLastFrame)
   1: {
   1:   nsIAtom* type = aLastFrame->GetType();
   1:   if (type == nsGkAtoms::brFrame)
   1:     return PR_TRUE;
   1:   if (type == nsGkAtoms::textFrame)
   1:     return aLastFrame->HasTerminalNewline() &&
   1:            aLastFrame->GetStyleText()->WhiteSpaceIsSignificant();
   1:   if (type == nsGkAtoms::placeholderFrame)
   1:     return IsContinuationPlaceholder(aLastFrame);
   1:   return PR_FALSE;
   1: }
   1: 
   1: nsresult
   1: nsBlockFrame::AddFrames(nsIFrame* aFrameList,
   1:                         nsIFrame* aPrevSibling)
   1: {
   1:   // Clear our line cursor, since our lines may change.
   1:   ClearLineCursor();
   1: 
   1:   if (nsnull == aFrameList) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   // If we're inserting at the beginning of our list and we have an
   1:   // inside bullet, insert after that bullet.
   1:   if (!aPrevSibling && mBullet && !HaveOutsideBullet()) {
   1:     NS_ASSERTION(!nsFrameList(aFrameList).ContainsFrame(mBullet),
   1:                  "Trying to make mBullet prev sibling to itself");
   1:     aPrevSibling = mBullet;
   1:   }
   1:   
 238:   nsIPresShell *presShell = PresContext()->PresShell();
   1: 
   1:   // Attempt to find the line that contains the previous sibling
   1:   nsLineList::iterator prevSibLine = end_lines();
   1:   PRInt32 prevSiblingIndex = -1;
   1:   if (aPrevSibling) {
   1:     // XXX_perf This is technically O(N^2) in some cases, but by using
   1:     // RFind instead of Find, we make it O(N) in the most common case,
   1:     // which is appending content.
   1: 
   1:     // Find the line that contains the previous sibling
   1:     if (! nsLineBox::RFindLineContaining(aPrevSibling,
   1:                                          begin_lines(), prevSibLine,
   1:                                          &prevSiblingIndex)) {
   1:       // Note: defensive code! RFindLineContaining must not return
   1:       // false in this case, so if it does...
   1:       NS_NOTREACHED("prev sibling not in line list");
   1:       aPrevSibling = nsnull;
   1:       prevSibLine = end_lines();
   1:     }
   1:   }
   1: 
   1:   // Find the frame following aPrevSibling so that we can join up the
   1:   // two lists of frames.
   1:   nsIFrame* prevSiblingNextFrame = nsnull;
   1:   if (aPrevSibling) {
   1:     prevSiblingNextFrame = aPrevSibling->GetNextSibling();
   1: 
   1:     // Split line containing aPrevSibling in two if the insertion
   1:     // point is somewhere in the middle of the line.
   1:     PRInt32 rem = prevSibLine->GetChildCount() - prevSiblingIndex - 1;
   1:     if (rem) {
   1:       // Split the line in two where the frame(s) are being inserted.
   1:       nsLineBox* line = NS_NewLineBox(presShell, prevSiblingNextFrame, rem, PR_FALSE);
   1:       if (!line) {
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:       }
   1:       mLines.after_insert(prevSibLine, line);
   1:       prevSibLine->SetChildCount(prevSibLine->GetChildCount() - rem);
7719:       // Mark prevSibLine dirty and as needing textrun invalidation, since
7719:       // we may be breaking up text in the line. Its previous line may also
7719:       // need to be invalidated because it may be able to pull some text up.
7719:       MarkLineDirty(prevSibLine);
7719:       // The new line will also need its textruns recomputed because of the
7719:       // frame changes.
7719:       line->SetInvalidateTextRuns(PR_TRUE);
6029:     }
   1: 
   1:     // Now (partially) join the sibling lists together
   1:     aPrevSibling->SetNextSibling(aFrameList);
   1:   }
   1:   else if (! mLines.empty()) {
   1:     prevSiblingNextFrame = mLines.front()->mFirstChild;
6029:     mLines.front()->SetInvalidateTextRuns(PR_TRUE);
   1:   }
   1: 
   1:   // Walk through the new frames being added and update the line data
   1:   // structures to fit.
   1:   nsIFrame* newFrame = aFrameList;
   1:   while (newFrame) {
3812:     NS_ASSERTION(newFrame->GetType() != nsGkAtoms::placeholderFrame ||
3812:                  (!newFrame->GetStyleDisplay()->IsAbsolutelyPositioned() &&
3812:                   !newFrame->GetStyleDisplay()->IsFloating()),
3812:                  "Placeholders should not float or be positioned");
3812: 
2829:     PRBool isBlock = newFrame->GetStyleDisplay()->IsBlockOutside();
   1: 
   1:     // If the frame is a block frame, or if there is no previous line or if the
   1:     // previous line is a block line we need to make a new line.  We also make
   1:     // a new line, as an optimization, in the three cases we know we'll need it:
   1:     // if the previous line ended with a <br>, if it has significant whitespace and
   1:     // ended in a newline, or if it contains continuation placeholders.
   1:     if (isBlock || prevSibLine == end_lines() || prevSibLine->IsBlock() ||
   1:         (aPrevSibling && ShouldPutNextSiblingOnNewLine(aPrevSibling))) {
   1:       // Create a new line for the frame and add its line to the line
   1:       // list.
   1:       nsLineBox* line = NS_NewLineBox(presShell, newFrame, 1, isBlock);
   1:       if (!line) {
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:       }
   1:       if (prevSibLine != end_lines()) {
   1:         // Append new line after prevSibLine
   1:         mLines.after_insert(prevSibLine, line);
   1:         ++prevSibLine;
   1:       }
   1:       else {
   1:         // New line is going before the other lines
   1:         mLines.push_front(line);
   1:         prevSibLine = begin_lines();
   1:       }
   1:     }
   1:     else {
   1:       prevSibLine->SetChildCount(prevSibLine->GetChildCount() + 1);
7719:       // We're adding inline content to prevSibLine, so we need to mark it
7719:       // dirty, ensure its textruns are recomputed, and possibly do the same
7719:       // to its previous line since that line may be able to pull content up.
7719:       MarkLineDirty(prevSibLine);
   1:     }
   1: 
   1:     aPrevSibling = newFrame;
   1:     newFrame = newFrame->GetNextSibling();
   1:   }
   1:   if (prevSiblingNextFrame) {
   1:     // Connect the last new frame to the remainder of the sibling list
   1:     aPrevSibling->SetNextSibling(prevSiblingNextFrame);
   1:   }
   1: 
   1: #ifdef DEBUG
   1:   VerifyLines(PR_TRUE);
   1: #endif
   1:   return NS_OK;
   1: }
   1: 
   1: nsBlockFrame::line_iterator
   1: nsBlockFrame::RemoveFloat(nsIFrame* aFloat) {
   1:   // Find which line contains the float, so we can update
   1:   // the float cache.
   1:   line_iterator line = begin_lines(), line_end = end_lines();
   1:   for ( ; line != line_end; ++line) {
   1:     if (line->IsInline() && line->RemoveFloat(aFloat)) {
   1:       break;
   1:     }
   1:   }
   1: 
   1:   // Unlink the placeholder *after* we searched the lines, because
   1:   // the line search uses the placeholder relationship.
 238:   nsFrameManager* fm = PresContext()->GetPresShell()->FrameManager();
   1:   nsPlaceholderFrame* placeholder = fm->GetPlaceholderFrameFor(aFloat);
   1:   if (placeholder) {
   1:     fm->UnregisterPlaceholderFrame(placeholder);
   1:     placeholder->SetOutOfFlowFrame(nsnull);
   1:   }
   1: 
   1:   // Try to destroy if it's in mFloats.
   1:   if (mFloats.DestroyFrame(aFloat)) {
   1:     return line;
   1:   }
   1: 
   1:   // Try our overflow list
   1:   {
   1:     nsAutoOOFFrameList oofs(this);
   1:     if (oofs.mList.DestroyFrame(aFloat)) {
   1:       return line_end;
   1:     }
   1:   }
   1:   
   1:   // If this is during reflow, it could be the out-of-flow frame for a
   1:   // placeholder in our block reflow state's mOverflowPlaceholders. But that's
   1:   // OK; it's not part of any child list, so we can just go ahead and delete it.
   1:   aFloat->Destroy();
   1:   return line_end;
   1: }
   1: 
   1: static void MarkAllDescendantLinesDirty(nsBlockFrame* aBlock)
   1: {
   1:   nsLineList::iterator line = aBlock->begin_lines();
   1:   nsLineList::iterator endLine = aBlock->end_lines();
   1:   while (line != endLine) {
   1:     if (line->IsBlock()) {
   1:       nsIFrame* f = line->mFirstChild;
   1:       void* bf;
   1:       if (NS_SUCCEEDED(f->QueryInterface(kBlockFrameCID, &bf))) {
3233:         MarkAllDescendantLinesDirty(static_cast<nsBlockFrame*>(f));
   1:       }
   1:     }
   1:     line->MarkDirty();
   1:     ++line;
   1:   }
   1: }
   1: 
   1: static void MarkSameSpaceManagerLinesDirty(nsBlockFrame* aBlock)
   1: {
   1:   nsBlockFrame* blockWithSpaceMgr = aBlock;
   1:   while (!(blockWithSpaceMgr->GetStateBits() & NS_BLOCK_SPACE_MGR)) {
   1:     void* bf;
   1:     if (NS_FAILED(blockWithSpaceMgr->GetParent()->
   1:                   QueryInterface(kBlockFrameCID, &bf))) {
   1:       break;
   1:     }
3233:     blockWithSpaceMgr = static_cast<nsBlockFrame*>(blockWithSpaceMgr->GetParent());
   1:   }
   1:     
   1:   // Mark every line at and below the line where the float was
   1:   // dirty, and mark their lines dirty too. We could probably do
   1:   // something more efficient --- e.g., just dirty the lines that intersect
   1:   // the float vertically.
   1:   MarkAllDescendantLinesDirty(blockWithSpaceMgr);
   1: }
   1: 
   1: /**
   1:  * Returns PR_TRUE if aFrame is a block that has one or more float children.
   1:  */
   1: static PRBool BlockHasAnyFloats(nsIFrame* aFrame)
   1: {
   1:   void* bf;
   1:   if (NS_FAILED(aFrame->QueryInterface(kBlockFrameCID, &bf)))
   1:     return PR_FALSE;
3233:   nsBlockFrame* block = static_cast<nsBlockFrame*>(aFrame);
   1:   if (block->GetFirstChild(nsGkAtoms::floatList))
   1:     return PR_TRUE;
   1:     
   1:   nsLineList::iterator line = block->begin_lines();
   1:   nsLineList::iterator endLine = block->end_lines();
   1:   while (line != endLine) {
   1:     if (line->IsBlock() && BlockHasAnyFloats(line->mFirstChild))
   1:       return PR_TRUE;
   1:     ++line;
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::RemoveFrame(nsIAtom*  aListName,
   1:                           nsIFrame* aOldFrame)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
   1: #ifdef NOISY_REFLOW_REASON
   1:   ListTag(stdout);
   1:   printf(": remove ");
   1:   nsFrame::ListTag(stdout, aOldFrame);
   1:   printf("\n");
   1: #endif
   1: 
   1:   if (nsnull == aListName) {
   1:     PRBool hasFloats = BlockHasAnyFloats(aOldFrame);
   1:     rv = DoRemoveFrame(aOldFrame, PR_TRUE, PR_FALSE);
   1:     if (hasFloats) {
   1:       MarkSameSpaceManagerLinesDirty(this);
   1:     }
   1:   }
4205:   else if (nsGkAtoms::absoluteList == aListName) {
   1:     return mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
   1:   }
   1:   else if (nsGkAtoms::floatList == aListName) {
4772:     nsIFrame* curFrame = aOldFrame;
4772:     // Make sure to delete all the continuations for the float frame
4772:     // we are removing; this way is a bit messy, but so is the rest of the code.
4772:     // See bug 390762.
4772:     do {
4772:       nsIFrame* continuation = curFrame->GetNextContinuation();
4772:       nsBlockFrame* curParent = static_cast<nsBlockFrame*>(curFrame->GetParent());
4772:       curParent->RemoveFloat(curFrame);
4772:       MarkSameSpaceManagerLinesDirty(curParent);
4772:       curFrame = continuation;
4772:     } while (curFrame);
   1:   }
   1: #ifdef IBMBIDI
   1:   else if (nsGkAtoms::nextBidi == aListName) {
   1:     // Skip the call to |FrameNeedsReflow| below by returning now.
   1:     return DoRemoveFrame(aOldFrame, PR_TRUE, PR_FALSE);
   1:   }
   1: #endif // IBMBIDI
   1:   else {
   1:     NS_ERROR("unexpected child list");
   1:     rv = NS_ERROR_INVALID_ARG;
   1:   }
   1: 
   1:   if (NS_SUCCEEDED(rv)) {
 238:     PresContext()->PresShell()->
1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
1158:                        NS_FRAME_HAS_DIRTY_CHILDREN); // XXX sufficient?
   1:   }
   1:   return rv;
   1: }
   1: 
   1: void
   1: nsBlockFrame::DoRemoveOutOfFlowFrame(nsIFrame* aFrame)
   1: {
6521:   // The containing block is always the parent of aFrame.
6521:   nsBlockFrame* block = (nsBlockFrame*)aFrame->GetParent();
6521: 
6521:   // Remove aFrame from the appropriate list.
6521:   const nsStyleDisplay* display = aFrame->GetStyleDisplay();
6521:   if (display->IsAbsolutelyPositioned()) {
6521:     // This also deletes the next-in-flows
6521:     block->mAbsoluteContainer.RemoveFrame(block,
6521:                                           nsGkAtoms::absoluteList,
6521:                                           aFrame);
6521:   }
6521:   else {
   1:     // First remove aFrame's next in flow
   1:     nsIFrame* nextInFlow = aFrame->GetNextInFlow();
   1:     if (nextInFlow) {
   1:       nsBlockFrame::DoRemoveOutOfFlowFrame(nextInFlow);
   1:     }
   1:     // Now remove aFrame
   1:     // This also destroys the frame.
   1:     block->RemoveFloat(aFrame);
   1:   }
   1: }
   1: 
   1: /**
   1:  * This helps us iterate over the list of all normal + overflow lines
   1:  */
   1: void
   1: nsBlockFrame::TryAllLines(nsLineList::iterator* aIterator,
6709:                           nsLineList::iterator* aStartIterator,
   1:                           nsLineList::iterator* aEndIterator,
   1:                           PRBool* aInOverflowLines) {
   1:   if (*aIterator == *aEndIterator) {
   1:     if (!*aInOverflowLines) {
   1:       *aInOverflowLines = PR_TRUE;
   1:       // Try the overflow lines
   1:       nsLineList* overflowLines = GetOverflowLines();
   1:       if (overflowLines) {
6709:         *aStartIterator = overflowLines->begin();
6709:         *aIterator = *aStartIterator;
   1:         *aEndIterator = overflowLines->end();
   1:       }
   1:     }
   1:   }
   1: }
   1: 
5145: nsBlockInFlowLineIterator::nsBlockInFlowLineIterator(nsBlockFrame* aFrame,
5145:     line_iterator& aLine, PRBool aInOverflow)
5145:   : mFrame(aFrame), mLine(aLine), mInOverflowLines(nsnull)
5145: {
5145:   if (aInOverflow) {
5145:     mInOverflowLines = aFrame->GetOverflowLines();
5145:     NS_ASSERTION(mInOverflowLines, "How can we be in overflow if there isn't any?");
5145:   }
5145: }
5145: 
5145: PRBool
5145: nsBlockInFlowLineIterator::Next()
5145: {
5145:   ++mLine;
5145:   line_iterator end = mInOverflowLines ? mInOverflowLines->end() : mFrame->end_lines();
5145:   if (mLine != end)
5145:     return PR_TRUE;
5145:   PRBool currentlyInOverflowLines = mInOverflowLines != nsnull;
5145:   while (PR_TRUE) {
5145:     if (currentlyInOverflowLines) {
5145:       mFrame = static_cast<nsBlockFrame*>(mFrame->GetNextInFlow());
5145:       if (!mFrame)
5145:         return PR_FALSE;
5145:       mInOverflowLines = nsnull;
5145:       mLine = mFrame->begin_lines();
5145:       if (mLine != mFrame->end_lines())
5145:         return PR_TRUE;
5145:     } else {
5145:       mInOverflowLines = mFrame->GetOverflowLines();
5145:       if (mInOverflowLines) {
5145:         mLine = mInOverflowLines->begin();
5145:         NS_ASSERTION(mLine != mInOverflowLines->end(), "empty overflow line list?");
5145:         return PR_TRUE;
5145:       }
5145:     }
5145:     currentlyInOverflowLines = !currentlyInOverflowLines;
5145:   }
5145: }
5145: 
5145: PRBool
5145: nsBlockInFlowLineIterator::Prev()
5145: {
5145:   line_iterator begin = mInOverflowLines ? mInOverflowLines->begin() : mFrame->begin_lines();
5145:   if (mLine != begin) {
5145:     --mLine;
5145:     return PR_TRUE;
5145:   }
5145:   PRBool currentlyInOverflowLines = mInOverflowLines != nsnull;
5145:   while (PR_TRUE) {
5145:     if (currentlyInOverflowLines) {
5145:       mLine = mFrame->end_lines();
5145:       if (mLine != mFrame->begin_lines()) {
5145:         --mLine;
5145:         return PR_TRUE;
5145:       }
5145:     } else {
5145:       mFrame = static_cast<nsBlockFrame*>(mFrame->GetPrevInFlow());
5145:       if (!mFrame)
5145:         return PR_FALSE;
5145:       mInOverflowLines = mFrame->GetOverflowLines();
5145:       if (mInOverflowLines) {
5145:         mLine = mInOverflowLines->end();
5145:         NS_ASSERTION(mLine != mInOverflowLines->begin(), "empty overflow line list?");
5145:         --mLine;
5145:         return PR_TRUE;
5145:       }
5145:     }
5145:     currentlyInOverflowLines = !currentlyInOverflowLines;
5145:   }
5145: }
5145: 
8520: static nsresult RemoveBlockChild(nsIFrame* aFrame, PRBool aDestroyFrames,
8520:                                  PRBool aRemoveOnlyFluidContinuations)
   1: {
   1:   if (!aFrame)
   1:     return NS_OK;
   1: 
3233:   nsBlockFrame* nextBlock = static_cast<nsBlockFrame*>(aFrame->GetParent());
   1:   NS_ASSERTION(nextBlock->GetType() == nsGkAtoms::blockFrame ||
   1:                nextBlock->GetType() == nsGkAtoms::areaFrame,
   1:                "Our child's continuation's parent is not a block?");
8520:   return nextBlock->DoRemoveFrame(aFrame, aDestroyFrames,
8520:                                   aRemoveOnlyFluidContinuations);
   1: }
   1: 
   1: // This function removes aDeletedFrame and all its continuations.  It
   1: // is optimized for deleting a whole series of frames. The easy
   1: // implementation would invoke itself recursively on
   1: // aDeletedFrame->GetNextContinuation, then locate the line containing
   1: // aDeletedFrame and remove aDeletedFrame from that line. But here we
   1: // start by locating aDeletedFrame and then scanning from that point
   1: // on looking for continuations.
   1: nsresult
   1: nsBlockFrame::DoRemoveFrame(nsIFrame* aDeletedFrame, PRBool aDestroyFrames,
   1:                             PRBool aRemoveOnlyFluidContinuations)
   1: {
   1:   // Clear our line cursor, since our lines may change.
   1:   ClearLineCursor();
   1: 
6521:   nsPresContext* presContext = PresContext();
6521:   if (NS_FRAME_IS_OVERFLOW_CONTAINER & aDeletedFrame->GetStateBits()) {
6800:     if (aDestroyFrames) {
6800:       nsIFrame* nif = aDeletedFrame->GetNextInFlow();
6800:       if (nif)
7040:         static_cast<nsContainerFrame*>(nif->GetParent())
7040:           ->nsContainerFrame::DeleteNextInFlowChild(presContext, nif);
6800:       nsresult rv = nsContainerFrame::StealFrame(presContext, aDeletedFrame);
6800:       NS_ENSURE_SUCCESS(rv, rv);
6800:       aDeletedFrame->Destroy();
6800:     }
6800:     else {
6800:       PR_NOT_REACHED("We can't not destroy overflow containers");
6800:       return NS_ERROR_NOT_IMPLEMENTED;
6800:       //XXXfr It seems not destroying frames is only used for placeholder
6800:       // continuations; see nsBlockFrame::HandleOverflowPlaceholdersForPulledFrame.
6800:       // If we get rid of placeholder continuations, we can simplify this
6800:       // function by getting rid of that option.
6800:     }
6800:     return NS_OK;
6521:   }
6521: 
   1:   if (aDeletedFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
   1:     NS_ASSERTION(aDestroyFrames, "We can't not destroy out of flows");
   1:     DoRemoveOutOfFlowFrame(aDeletedFrame);
   1:     return NS_OK;
   1:   }
   1:   
   1:   nsIPresShell* presShell = presContext->PresShell();
   1: 
   1:   PRBool isPlaceholder = nsGkAtoms::placeholderFrame == aDeletedFrame->GetType();
   1:   if (isPlaceholder) {
   1:     nsFrameList* overflowPlaceholders = GetOverflowPlaceholders();
   1:     if (overflowPlaceholders && overflowPlaceholders->RemoveFrame(aDeletedFrame)) {
   1:       nsIFrame* nif = aDeletedFrame->GetNextInFlow();
   1:       if (aDestroyFrames) {
   1:         aDeletedFrame->Destroy();
   1:       } else {
   1:         aDeletedFrame->SetNextSibling(nsnull);
   1:       }
8520:       return RemoveBlockChild(nif, aDestroyFrames,
8520:                               aRemoveOnlyFluidContinuations);
   1:     }
   1:   }
   1:   
   1:   // Find the line and the previous sibling that contains
   1:   // deletedFrame; we also find the pointer to the line.
6709:   nsLineList::iterator line_start = mLines.begin(),
   1:                        line_end = mLines.end();
6709:   nsLineList::iterator line = line_start;
   1:   PRBool searchingOverflowList = PR_FALSE;
   1:   nsIFrame* prevSibling = nsnull;
   1:   // Make sure we look in the overflow lines even if the normal line
   1:   // list is empty
6709:   TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
   1:   while (line != line_end) {
   1:     nsIFrame* frame = line->mFirstChild;
   1:     PRInt32 n = line->GetChildCount();
   1:     while (--n >= 0) {
   1:       if (frame == aDeletedFrame) {
   1:         goto found_frame;
   1:       }
   1:       prevSibling = frame;
   1:       frame = frame->GetNextSibling();
   1:     }
   1:     ++line;
6709:     TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
   1:   }
   1: found_frame:;
   1:   if (line == line_end) {
   1:     NS_ERROR("can't find deleted frame in lines");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   
6709:   if (line != line_start) {
6029:     line.prev()->SetInvalidateTextRuns(PR_TRUE);
6029:   }
6709:   else if (searchingOverflowList && !mLines.empty()) {
6709:     mLines.back()->SetInvalidateTextRuns(PR_TRUE);
6709:   }
6029: 
   1:   if (prevSibling && !prevSibling->GetNextSibling()) {
   1:     // We must have found the first frame in the overflow line list. So
   1:     // there is no prevSibling
   1:     prevSibling = nsnull;
   1:   }
   1:   NS_ASSERTION(!prevSibling || prevSibling->GetNextSibling() == aDeletedFrame, "bad prevSibling");
   1: 
   1:   while ((line != line_end) && (nsnull != aDeletedFrame)) {
   1:     NS_ASSERTION(this == aDeletedFrame->GetParent(), "messed up delete code");
   1:     NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
   1: 
6029:     line->SetInvalidateTextRuns(PR_TRUE);
6029: 
   1:     // If the frame being deleted is the last one on the line then
   1:     // optimize away the line->Contains(next-in-flow) call below.
   1:     PRBool isLastFrameOnLine = (1 == line->GetChildCount() ||
   1:                                 line->LastChild() == aDeletedFrame);
   1: 
   1:     // Remove aDeletedFrame from the line
   1:     nsIFrame* nextFrame = aDeletedFrame->GetNextSibling();
   1:     if (line->mFirstChild == aDeletedFrame) {
   1:       // We should be setting this to null if aDeletedFrame
   1:       // is the only frame on the line. HOWEVER in that case
   1:       // we will be removing the line anyway, see below.
   1:       line->mFirstChild = nextFrame;
   1:     }
   1: 
   1:     // Hmm, this won't do anything if we're removing a frame in the first
   1:     // overflow line... Hopefully doesn't matter
   1:     --line;
   1:     if (line != line_end && !line->IsBlock()) {
   1:       // Since we just removed a frame that follows some inline
   1:       // frames, we need to reflow the previous line.
   1:       line->MarkDirty();
   1:     }
   1:     ++line;
   1: 
   1:     // Take aDeletedFrame out of the sibling list. Note that
   1:     // prevSibling will only be nsnull when we are deleting the very
   1:     // first frame in the main or overflow list.
   1:     if (prevSibling) {
   1:       prevSibling->SetNextSibling(nextFrame);
   1:     }
   1: 
   1:     // Update the child count of the line to be accurate
   1:     PRInt32 lineChildCount = line->GetChildCount();
   1:     lineChildCount--;
   1:     line->SetChildCount(lineChildCount);
   1: 
   1:     // Destroy frame; capture its next continuation first in case we need
   1:     // to destroy that too.
   1:     nsIFrame* deletedNextContinuation = aRemoveOnlyFluidContinuations ?
   1:       aDeletedFrame->GetNextInFlow() : aDeletedFrame->GetNextContinuation();
   1: #ifdef NOISY_REMOVE_FRAME
   1:     printf("DoRemoveFrame: %s line=%p frame=",
   1:            searchingOverflowList?"overflow":"normal", line.get());
   1:     nsFrame::ListTag(stdout, aDeletedFrame);
   1:     printf(" prevSibling=%p deletedNextContinuation=%p\n", prevSibling, deletedNextContinuation);
   1: #endif
   1: 
   1:     if (aDestroyFrames) {
   1:       aDeletedFrame->Destroy();
   1:     } else {
   1:       aDeletedFrame->SetNextSibling(nsnull);
   1:     }
   1:     aDeletedFrame = deletedNextContinuation;
   1: 
   1:     PRBool haveAdvancedToNextLine = PR_FALSE;
   1:     // If line is empty, remove it now.
   1:     if (0 == lineChildCount) {
   1: #ifdef NOISY_REMOVE_FRAME
   1:         printf("DoRemoveFrame: %s line=%p became empty so it will be removed\n",
   1:                searchingOverflowList?"overflow":"normal", line.get());
   1: #endif
   1:       nsLineBox *cur = line;
   1:       if (!searchingOverflowList) {
   1:         line = mLines.erase(line);
   1:         // Invalidate the space taken up by the line.
   1:         // XXX We need to do this if we're removing a frame as a result of
   1:         // a call to RemoveFrame(), but we may not need to do this in all
   1:         // cases...
   1:         nsRect lineCombinedArea(cur->GetCombinedArea());
   1: #ifdef NOISY_BLOCK_INVALIDATE
   1:         printf("%p invalidate 10 (%d, %d, %d, %d)\n",
   1:                this, lineCombinedArea.x, lineCombinedArea.y,
   1:                lineCombinedArea.width, lineCombinedArea.height);
   1: #endif
   1:         Invalidate(lineCombinedArea);
   1:       } else {
   1:         nsLineList* lineList = RemoveOverflowLines();
   1:         line = lineList->erase(line);
   1:         if (!lineList->empty()) {
   1:           SetOverflowLines(lineList);
   1:         }
   1:       }
   1:       cur->Destroy(presShell);
   1: 
   1:       // If we're removing a line, ReflowDirtyLines isn't going to
   1:       // know that it needs to slide lines unless something is marked
   1:       // dirty.  So mark the previous margin of the next line dirty if
   1:       // there is one.
   1:       if (line != line_end) {
   1:         line->MarkPreviousMarginDirty();
   1:       }
   1:       haveAdvancedToNextLine = PR_TRUE;
   1:     } else {
   1:       // Make the line that just lost a frame dirty, and advance to
   1:       // the next line.
   1:       if (!deletedNextContinuation || isLastFrameOnLine ||
   1:           !line->Contains(deletedNextContinuation)) {
   1:         line->MarkDirty();
   1:         ++line;
   1:         haveAdvancedToNextLine = PR_TRUE;
   1:       }
   1:     }
   1: 
   1:     if (deletedNextContinuation) {
   1:       // Continuations for placeholder frames don't always appear in
   1:       // consecutive lines. So for placeholders, just continue the slow easy way.
   1:       if (isPlaceholder) {
8520:         return RemoveBlockChild(deletedNextContinuation, aDestroyFrames,
8520:                                 aRemoveOnlyFluidContinuations);
   1:       }
   1: 
   1:       // See if we should keep looking in the current flow's line list.
   1:       if (deletedNextContinuation->GetParent() != this) {
   1:         // The deceased frames continuation is not a child of the
   1:         // current block. So break out of the loop so that we advance
   1:         // to the next parent.
   1:         break;
   1:       }
   1: 
   1:       // If we advanced to the next line then check if we should switch to the
   1:       // overflow line list.
   1:       if (haveAdvancedToNextLine) {
   1:         if (line != line_end && !searchingOverflowList &&
   1:             !line->Contains(deletedNextContinuation)) {
   1:           // We have advanced to the next *normal* line but the next-in-flow
   1:           // is not there - force a switch to the overflow line list.
   1:           line = line_end;
   1:         }
   1: 
   1:         PRBool wasSearchingOverflowList = searchingOverflowList;
6709:         TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
   1:         if (NS_UNLIKELY(searchingOverflowList && !wasSearchingOverflowList &&
   1:                         prevSibling)) {
   1:           // We switched to the overflow line list and we have a prev sibling
   1:           // (in the main list), in this case we don't want to pick up any
   1:           // sibling list from the deceased frames (bug 344557).
   1:           prevSibling->SetNextSibling(nsnull);
   1:           prevSibling = nsnull;
   1:         }
   1: #ifdef NOISY_REMOVE_FRAME
   1:         printf("DoRemoveFrame: now on %s line=%p prevSibling=%p\n",
   1:                searchingOverflowList?"overflow":"normal", line.get(),
   1:                prevSibling);
   1: #endif
   1:       }
   1:     }
   1:   }
   1:   
6029:   if (line.next() != line_end) {
6029:     line.next()->SetInvalidateTextRuns(PR_TRUE);
6029:   }
6029: 
   1: #ifdef DEBUG
   1:   VerifyLines(PR_TRUE);
   1: #endif
   1: 
   1:   // Advance to next flow block if the frame has more continuations
8520:   return RemoveBlockChild(aDeletedFrame, aDestroyFrames,
8520:                           aRemoveOnlyFluidContinuations);
   1: }
   1: 
4006: nsresult
4006: nsBlockFrame::StealFrame(nsPresContext* aPresContext,
4006:                          nsIFrame*      aChild,
4006:                          PRBool         aForceNormal)
4006: {
4006:   NS_PRECONDITION(aPresContext && aChild, "null pointer");
4006: 
4006:   if ((aChild->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)
4006:       && !aForceNormal)
4006:     return nsContainerFrame::StealFrame(aPresContext, aChild);
4006: 
4006:   // Find the line and the previous sibling that contains
4006:   // aChild; we also find the pointer to the line.
4006:   nsLineList::iterator line = mLines.begin(),
6709:                        line_start = line,
4006:                        line_end = mLines.end();
4006:   PRBool searchingOverflowList = PR_FALSE;
4006:   nsIFrame* prevSibling = nsnull;
4006:   // Make sure we look in the overflow lines even if the normal line
4006:   // list is empty
6709:   TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
4006:   while (line != line_end) {
4006:     nsIFrame* frame = line->mFirstChild;
4006:     PRInt32 n = line->GetChildCount();
4006:     while (--n >= 0) {
4006:       if (frame == aChild) {
4006:         // Disconnect from sibling list
4006:         if (prevSibling)
4006:           prevSibling->SetNextSibling(frame->GetNextSibling());
4006:         else
4006:           line->mFirstChild = frame->GetNextSibling();
4006:         frame->SetNextSibling(nsnull);
4006: 
4006:         // Register removal with the line boxes
4006:         PRInt32 count = line->GetChildCount();
4006:         line->SetChildCount(--count);
4006:         if (count > 0) {
4006:            line->MarkDirty();
4006:         }
4006:         else {
4006:           // Remove the line box
4006:           nsLineBox* lineBox = line;
4006:           if (searchingOverflowList) {
4006:             // Erase line, but avoid making the overflow line list empty
4006:             nsLineList* lineList = RemoveOverflowLines();
4006:             lineList->erase(line);
4006:             if (!lineList->empty()) {
4006:               nsresult rv = SetOverflowLines(lineList);
4006:               NS_ENSURE_SUCCESS(rv, rv);
4006:             }
4006:           }
4006:           else {
4006:             mLines.erase(line);
4006:           }
4006:           lineBox->Destroy(aPresContext->PresShell());
4006:           if (line != line_end) {
4006:             // Line disappeared, so tell next line it may have to change position
4006:             line->MarkPreviousMarginDirty();
4006:           }
4006:         }
4006: 
4006:         // Ok, we're done
4006:         return NS_OK;
4006:       }
4006:       prevSibling = frame;
4006:       frame = frame->GetNextSibling();
4006:     }
4006:     ++line;
6709:     TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
4006:   }
4006:   return NS_ERROR_UNEXPECTED;
4006: }
4006: 
   1: void
   1: nsBlockFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
   1:                                     nsIFrame*       aNextInFlow)
   1: {
   1:   nsIFrame* prevInFlow = aNextInFlow->GetPrevInFlow();
   1:   NS_PRECONDITION(prevInFlow, "bad next-in-flow");
4006: 
4006:   if (NS_FRAME_IS_OVERFLOW_CONTAINER & aNextInFlow->GetStateBits()) {
4006:     nsContainerFrame::DeleteNextInFlowChild(aPresContext, aNextInFlow);
4006:   }
4006:   else {
   1:     DoRemoveFrame(aNextInFlow);
   1:   }
4006: }
   1: 
   1: ////////////////////////////////////////////////////////////////////////
   1: // Float support
   1: 
   1: nsresult
   1: nsBlockFrame::ReflowFloat(nsBlockReflowState& aState,
   1:                           nsPlaceholderFrame* aPlaceholder,
2480:                           nsMargin&           aFloatMargin,
   1:                           nsReflowStatus&     aReflowStatus)
   1: {
   1:   // Reflow the float.
   1:   nsIFrame* floatFrame = aPlaceholder->GetOutOfFlowFrame();
   1:   aReflowStatus = NS_FRAME_COMPLETE;
   1: 
   1: #ifdef NOISY_FLOAT
   1:   printf("Reflow Float %p in parent %p, availSpace(%d,%d,%d,%d)\n",
   1:           aPlaceholder->GetOutOfFlowFrame(), this, 
   1:           aState.mAvailSpaceRect.x, aState.mAvailSpaceRect.y, 
   1:           aState.mAvailSpaceRect.width, aState.mAvailSpaceRect.height
   1:   );
   1: #endif
   1: 
   1:   // Compute the available width. By default, assume the width of the
   1:   // containing block.
   1:   nscoord availWidth;
   1:   const nsStyleDisplay* floatDisplay = floatFrame->GetStyleDisplay();
   1: 
   1:   if (NS_STYLE_DISPLAY_TABLE != floatDisplay->mDisplay ||
   1:       eCompatibility_NavQuirks != aState.mPresContext->CompatibilityMode() ) {
   1:     availWidth = aState.mContentArea.width;
   1:   }
   1:   else {
   1:     // This quirk matches the one in nsBlockReflowState::FlowAndPlaceFloat
   1:     // give tables only the available space
   1:     // if they can shrink we may not be constrained to place
   1:     // them in the next line
   1:     availWidth = aState.mAvailSpaceRect.width;
   1:     // round down to twips per pixel so that we fit
   1:     // needed when prev. float has procentage width
   1:     // (maybe is a table flaw that makes table chose to round up
   1:     // but I don't want to change that, too risky)
   1:     nscoord twp = nsPresContext::CSSPixelsToAppUnits(1);
   1:     availWidth -=  availWidth % twp;
   1:   }
   1: 
   1:   // aState.mY is relative to the border-top, make it relative to the content-top
   1:   nscoord contentYOffset = aState.mY - aState.BorderPadding().top;
   1:   nscoord availHeight = NS_UNCONSTRAINEDSIZE == aState.mContentArea.height
   1:                         ? NS_UNCONSTRAINEDSIZE 
   1:                         : PR_MAX(0, aState.mContentArea.height - contentYOffset);
   1: 
   1:   nsRect availSpace(aState.BorderPadding().left,
   1:                     aState.BorderPadding().top,
   1:                     availWidth, availHeight);
   1: 
   1:   // construct the html reflow state for the float. ReflowBlock will 
   1:   // initialize it.
   1:   nsHTMLReflowState floatRS(aState.mPresContext, aState.mReflowState,
   1:                             floatFrame, 
   1:                             nsSize(availSpace.width, availSpace.height));
   1: 
   1:   // Setup a block reflow state to reflow the float.
   1:   nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);
   1: 
   1:   // Reflow the float
   1:   PRBool isAdjacentWithTop = aState.IsAdjacentWithTop();
   1: 
   1:   nsIFrame* clearanceFrame = nsnull;
   1:   nsresult rv;
   1:   do {
   1:     nsCollapsingMargin margin;
   1:     PRBool mayNeedRetry = PR_FALSE;
   1:     floatRS.mDiscoveredClearance = nsnull;
   1:     // Only first in flow gets a top margin.
   1:     if (!floatFrame->GetPrevInFlow()) {
   1:       nsBlockReflowContext::ComputeCollapsedTopMargin(floatRS, &margin,
   1:                                                       clearanceFrame, &mayNeedRetry);
   1: 
   1:       if (mayNeedRetry && !clearanceFrame) {
   1:         floatRS.mDiscoveredClearance = &clearanceFrame;
   1:         // We don't need to push the space manager state because the the block has its own
   1:         // space manager that will be destroyed and recreated
   1:       }
   1:     }
   1: 
2480:     nsMargin offsets; // Don't bother returning this to the caller; it's stored
2480:                       // on a frame property anyawy
   1:     rv = brc.ReflowBlock(availSpace, PR_TRUE, margin,
   1:                          0, isAdjacentWithTop,
4831:                          offsets, nsnull, floatRS,
6521:                          aReflowStatus, aState);
   1:   } while (NS_SUCCEEDED(rv) && clearanceFrame);
   1: 
   1:   // An incomplete reflow status means we should split the float 
   1:   // if the height is constrained (bug 145305). 
   1:   if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus) && (NS_UNCONSTRAINEDSIZE == availHeight))
   1:     aReflowStatus = NS_FRAME_COMPLETE;
   1: 
4006:   //XXXfr Floats can't be overflow incomplete yet
4006:   if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aReflowStatus))
4006:     NS_FRAME_SET_INCOMPLETE(aReflowStatus);
4006:   
   1:   if (NS_FRAME_IS_COMPLETE(aReflowStatus)) {
   1:     // Float is now complete, so delete the placeholder's next in
   1:     // flows, if any; their floats (which are this float's continuations)
   1:     // have already been deleted.
   1:     // XXX won't this be done later in nsLineLayout::ReflowFrame anyway??
   1:     nsIFrame* nextInFlow = aPlaceholder->GetNextInFlow();
   1:     if (nextInFlow) {
3233:       static_cast<nsHTMLContainerFrame*>(nextInFlow->GetParent())
   1:         ->DeleteNextInFlowChild(aState.mPresContext, nextInFlow);
   1:       // that takes care of all subsequent nextinflows too
   1:     }
   1:   }
   1:   if (aReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW) {
   1:     aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
   1:   }
   1: 
   1:   if (floatFrame->GetType() == nsGkAtoms::letterFrame) {
   1:     // We never split floating first letters; an incomplete state for
   1:     // such frames simply means that there is more content to be
   1:     // reflowed on the line.
   1:     if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus)) 
   1:       aReflowStatus = NS_FRAME_COMPLETE;
   1:   }
   1: 
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   // Capture the margin information for the caller
4831:   const nsMargin& m = floatRS.mComputedMargin;
2480:   aFloatMargin.top = brc.GetTopMargin();
2480:   aFloatMargin.right = m.right;
   1:   // Only last in flows get a bottom margin
   1:   if (NS_FRAME_IS_COMPLETE(aReflowStatus)) {
   1:     brc.GetCarriedOutBottomMargin().Include(m.bottom);
   1:   }
2480:   aFloatMargin.bottom = brc.GetCarriedOutBottomMargin().get();
2480:   aFloatMargin.left = m.left;
   1: 
   1:   const nsHTMLReflowMetrics& metrics = brc.GetMetrics();
   1: 
   1:   // Set the rect, make sure the view is properly sized and positioned,
   1:   // and tell the frame we're done reflowing it
   1:   // XXXldb This seems like the wrong place to be doing this -- shouldn't
   1:   // we be doing this in nsBlockReflowState::FlowAndPlaceFloat after
   1:   // we've positioned the float, and shouldn't we be doing the equivalent
   1:   // of |::PlaceFrameView| here?
   1:   floatFrame->SetSize(nsSize(metrics.width, metrics.height));
   1:   if (floatFrame->HasView()) {
   1:     nsContainerFrame::SyncFrameViewAfterReflow(aState.mPresContext, floatFrame,
   1:                                                floatFrame->GetView(),
   1:                                                &metrics.mOverflowArea,
   1:                                                NS_FRAME_NO_MOVE_VIEW);
   1:   }
   1:   // Pass floatRS so the frame hierarchy can be used (redoFloatRS has the same hierarchy)  
   1:   floatFrame->DidReflow(aState.mPresContext, &floatRS,
   1:                         NS_FRAME_REFLOW_FINISHED);
   1: 
   1: #ifdef NOISY_FLOAT
   1:   printf("end ReflowFloat %p, sized to %d,%d\n",
   1:          floatFrame, metrics.width, metrics.height);
   1: #endif
   1: 
   1:   // If the placeholder was continued and its first-in-flow was followed by a 
   1:   // <BR>, then cache the <BR>'s break type in aState.mFloatBreakType so that
   1:   // the next frame after the placeholder can combine that break type with its own
   1:   nsIFrame* prevPlaceholder = aPlaceholder->GetPrevInFlow();
   1:   if (prevPlaceholder) {
   1:     // the break occurs only after the last continued placeholder
   1:     PRBool lastPlaceholder = PR_TRUE;
   1:     nsIFrame* next = aPlaceholder->GetNextSibling();
   1:     if (next) {
   1:       if (nsGkAtoms::placeholderFrame == next->GetType()) {
   1:         lastPlaceholder = PR_FALSE;
   1:       }
   1:     }
   1:     if (lastPlaceholder) {
   1:       // get the containing block of prevPlaceholder which is our prev-in-flow
   1:       if (GetPrevInFlow()) {
   1:         // get the break type of the last line in mPrevInFlow
4006:         nsBlockFrame* prevBlock = static_cast<nsBlockFrame*>(GetPrevInFlow());
4006:         line_iterator endLine = prevBlock->end_lines();
4006:         if (endLine != prevBlock->begin_lines()) {
4006:           --endLine;
4006:           if (endLine->HasFloatBreakAfter())
   1:             aState.mFloatBreakType = endLine->GetBreakTypeAfter();
   1:         }
   1:       }
   1:       else NS_ASSERTION(PR_FALSE, "no prev in flow");
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: // Painting, event handling
   1: 
   1: PRIntn
   1: nsBlockFrame::GetSkipSides() const
   1: {
6521:   if (IS_TRUE_OVERFLOW_CONTAINER(this))
4006:     return (1 << NS_SIDE_TOP) | (1 << NS_SIDE_BOTTOM);
4006: 
   1:   PRIntn skip = 0;
4006:   if (GetPrevInFlow()) {
   1:     skip |= 1 << NS_SIDE_TOP;
   1:   }
4006:   nsIFrame* nif = GetNextInFlow();
6521:   if (nif && !IS_TRUE_OVERFLOW_CONTAINER(nif)) {
   1:     skip |= 1 << NS_SIDE_BOTTOM;
   1:   }
   1:   return skip;
   1: }
   1: 
   1: #ifdef DEBUG
   1: static void ComputeCombinedArea(nsLineList& aLines,
   1:                                 nscoord aWidth, nscoord aHeight,
   1:                                 nsRect& aResult)
   1: {
   1:   nscoord xa = 0, ya = 0, xb = aWidth, yb = aHeight;
   1:   for (nsLineList::iterator line = aLines.begin(), line_end = aLines.end();
   1:        line != line_end;
   1:        ++line) {
   1:     // Compute min and max x/y values for the reflowed frame's
   1:     // combined areas
   1:     nsRect lineCombinedArea(line->GetCombinedArea());
   1:     nscoord x = lineCombinedArea.x;
   1:     nscoord y = lineCombinedArea.y;
   1:     nscoord xmost = x + lineCombinedArea.width;
   1:     nscoord ymost = y + lineCombinedArea.height;
   1:     if (x < xa) {
   1:       xa = x;
   1:     }
   1:     if (xmost > xb) {
   1:       xb = xmost;
   1:     }
   1:     if (y < ya) {
   1:       ya = y;
   1:     }
   1:     if (ymost > yb) {
   1:       yb = ymost;
   1:     }
   1:   }
   1: 
   1:   aResult.x = xa;
   1:   aResult.y = ya;
   1:   aResult.width = xb - xa;
   1:   aResult.height = yb - ya;
   1: }
   1: #endif
   1: 
   1: PRBool
   1: nsBlockFrame::IsVisibleInSelection(nsISelection* aSelection)
   1: {
   1:   nsCOMPtr<nsIDOMHTMLHtmlElement> html(do_QueryInterface(mContent));
   1:   nsCOMPtr<nsIDOMHTMLBodyElement> body(do_QueryInterface(mContent));
   1:   if (html || body)
   1:     return PR_TRUE;
   1: 
   1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
   1:   PRBool visible;
   1:   nsresult rv = aSelection->ContainsNode(node, PR_TRUE, &visible);
   1:   return NS_SUCCEEDED(rv) && visible;
   1: }
   1: 
   1: /* virtual */ void
   1: nsBlockFrame::PaintTextDecorationLine(nsIRenderingContext& aRenderingContext, 
   1:                                       nsPoint aPt,
   1:                                       nsLineBox* aLine,
   1:                                       nscolor aColor, 
   1:                                       nscoord aOffset, 
   1:                                       nscoord aAscent, 
4302:                                       nscoord aSize,
4302:                                       const PRUint8 aDecoration) 
   1: {
   1:   NS_ASSERTION(!aLine->IsBlock(), "Why did we ask for decorations on a block?");
   1: 
   1:   nscoord start = aLine->mBounds.x;
   1:   nscoord width = aLine->mBounds.width;
   1: 
8006:   if (!GetPrevContinuation() && aLine == begin_lines().get()) {
   1:     // Adjust for the text-indent.  See similar code in
   1:     // nsLineLayout::BeginLineReflow.
   1:     nscoord indent = 0;
   1:     const nsStyleText* styleText = GetStyleText();
   1:     nsStyleUnit unit = styleText->mTextIndent.GetUnit();
   1:     if (eStyleUnit_Coord == unit) {
   1:       indent = styleText->mTextIndent.GetCoordValue();
   1:     } else if (eStyleUnit_Percent == unit) {
   1:       // It's a percentage of the containing block width.
   1:       nsIFrame* containingBlock =
   1:         nsHTMLReflowState::GetContainingBlockFor(this);
   1:       NS_ASSERTION(containingBlock, "Must have containing block!");
   1:       indent = nscoord(styleText->mTextIndent.GetPercentValue() *
   1:                        containingBlock->GetContentRect().width);
   1:     }
   1: 
   1:     // Adjust the start position and the width of the decoration by the
   1:     // value of the indent.  Note that indent can be negative; that's OK.
   1:     // It'll just increase the width (which can also happen to be
   1:     // negative!).
   1:     start += indent;
   1:     width -= indent;
   1:   }
   1:       
   1:   // Only paint if we have a positive width
   1:   if (width > 0) {
4302:     const nsStyleVisibility* visibility = GetStyleVisibility();
4302:     PRBool isRTL = visibility->mDirection == NS_STYLE_DIRECTION_RTL;
4302:     nsRefPtr<gfxContext> ctx = (gfxContext*)
4302:       aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT);
5147:     gfxPoint pt(PresContext()->AppUnitsToGfxUnits(start + aPt.x),
5147:                 PresContext()->AppUnitsToGfxUnits(aLine->mBounds.y + aPt.y));
5147:     gfxSize size(PresContext()->AppUnitsToGfxUnits(width),
5147:                  PresContext()->AppUnitsToGfxUnits(aSize));
5147:     nsCSSRendering::PaintDecorationLine(
5147:       ctx, aColor, pt, size,
5147:       PresContext()->AppUnitsToGfxUnits(aLine->GetAscent()),
5147:       PresContext()->AppUnitsToGfxUnits(aOffset),
5147:       PresContext()->AppUnitsToGfxUnits(aSize),
5147:       aDecoration, NS_STYLE_BORDER_STYLE_SOLID, isRTL);
   1:   }
   1: }
   1: 
   1: #ifdef DEBUG
   1: static void DebugOutputDrawLine(PRInt32 aDepth, nsLineBox* aLine, PRBool aDrawn) {
   1:   if (nsBlockFrame::gNoisyDamageRepair) {
   1:     nsFrame::IndentBy(stdout, aDepth+1);
   1:     nsRect lineArea = aLine->GetCombinedArea();
   1:     printf("%s line=%p bounds=%d,%d,%d,%d ca=%d,%d,%d,%d\n",
   1:            aDrawn ? "draw" : "skip",
3233:            static_cast<void*>(aLine),
   1:            aLine->mBounds.x, aLine->mBounds.y,
   1:            aLine->mBounds.width, aLine->mBounds.height,
   1:            lineArea.x, lineArea.y,
   1:            lineArea.width, lineArea.height);
   1:   }
   1: }
   1: #endif
   1: 
   1: static nsresult
   1: DisplayLine(nsDisplayListBuilder* aBuilder, const nsRect& aLineArea,
   1:             const nsRect& aDirtyRect, nsBlockFrame::line_iterator& aLine,
   1:             PRInt32 aDepth, PRInt32& aDrawnLines, const nsDisplayListSet& aLists,
   1:             nsBlockFrame* aFrame) {
   1:   // If the line's combined area (which includes child frames that
   1:   // stick outside of the line's bounding box or our bounding box)
   1:   // intersects the dirty rect then paint the line.
   1:   PRBool intersect = aLineArea.Intersects(aDirtyRect);
   1: #ifdef DEBUG
   1:   if (nsBlockFrame::gLamePaintMetrics) {
   1:     aDrawnLines++;
   1:   }
   1:   DebugOutputDrawLine(aDepth, aLine.get(), intersect);
   1: #endif
   1:   // The line might contain a placeholder for a visible out-of-flow, in which
   1:   // case we need to descend into it. If there is such a placeholder, we will
   1:   // have NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO set.
   1:   if (!intersect &&
   1:       !(aFrame->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO))
   1:     return NS_OK;
   1: 
   1:   nsresult rv;
   1:   nsDisplayList aboveTextDecorations;
   1:   PRBool lineInline = aLine->IsInline();
   1:   if (lineInline) {
   1:     // Display the text-decoration for the hypothetical anonymous inline box
   1:     // that wraps these inlines
   1:     rv = aFrame->DisplayTextDecorations(aBuilder, aLists.Content(),
   1:                                         &aboveTextDecorations, aLine);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   // Block-level child backgrounds go on the blockBorderBackgrounds list ...
   1:   // Inline-level child backgrounds go on the regular child content list.
   1:   nsDisplayListSet childLists(aLists,
   1:       lineInline ? aLists.Content() : aLists.BlockBorderBackgrounds());
   1:   nsIFrame* kid = aLine->mFirstChild;
   1:   PRInt32 n = aLine->GetChildCount();
   1:   while (--n >= 0) {
   1:     rv = aFrame->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, childLists,
   1:                                           lineInline ? nsIFrame::DISPLAY_CHILD_INLINE : 0);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     kid = kid->GetNextSibling();
   1:   }
   1:   
   1:   aLists.Content()->AppendToTop(&aboveTextDecorations);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                                const nsRect&           aDirtyRect,
   1:                                const nsDisplayListSet& aLists)
   1: {
   1:   PRInt32 drawnLines; // Will only be used if set (gLamePaintMetrics).
   1:   PRInt32 depth = 0;
   1: #ifdef DEBUG
   1:   if (gNoisyDamageRepair) {
   1:       depth = GetDepth();
   1:       nsRect ca;
   1:       ::ComputeCombinedArea(mLines, mRect.width, mRect.height, ca);
   1:       nsFrame::IndentBy(stdout, depth);
   1:       ListTag(stdout);
   1:       printf(": bounds=%d,%d,%d,%d dirty(absolute)=%d,%d,%d,%d ca=%d,%d,%d,%d\n",
   1:              mRect.x, mRect.y, mRect.width, mRect.height,
   1:              aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height,
   1:              ca.x, ca.y, ca.width, ca.height);
   1:   }
   1:   PRTime start = LL_ZERO; // Initialize these variables to silence the compiler.
   1:   if (gLamePaintMetrics) {
   1:     start = PR_Now();
   1:     drawnLines = 0;
   1:   }
   1: #endif
   1: 
   1:   DisplayBorderBackgroundOutline(aBuilder, aLists);
   1: 
4006:   if (GetPrevInFlow()) {
4006:     DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
4006:   }
4006: 
   1:   aBuilder->MarkFramesForDisplayList(this, mFloats.FirstChild(), aDirtyRect);
   1:   aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetFirstChild(), aDirtyRect);
   1: 
   1:   // Don't use the line cursor if we might have a descendant placeholder ...
   1:   // it might skip lines that contain placeholders but don't themselves
   1:   // intersect with the dirty area.
   1:   nsLineBox* cursor = GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
   1:     ? nsnull : GetFirstLineContaining(aDirtyRect.y);
   1:   line_iterator line_end = end_lines();
   1:   nsresult rv = NS_OK;
   1:   
   1:   if (cursor) {
   1:     for (line_iterator line = mLines.begin(cursor);
   1:          line != line_end;
   1:          ++line) {
   1:       nsRect lineArea = line->GetCombinedArea();
   1:       if (!lineArea.IsEmpty()) {
   1:         // Because we have a cursor, the combinedArea.ys are non-decreasing.
   1:         // Once we've passed aDirtyRect.YMost(), we can never see it again.
   1:         if (lineArea.y >= aDirtyRect.YMost()) {
   1:           break;
   1:         }
   1:         rv = DisplayLine(aBuilder, lineArea, aDirtyRect, line, depth, drawnLines,
   1:                          aLists, this);
   1:         if (NS_FAILED(rv))
   1:           break;
   1:       }
   1:     }
   1:   } else {
   1:     PRBool nonDecreasingYs = PR_TRUE;
   1:     PRInt32 lineCount = 0;
   1:     nscoord lastY = PR_INT32_MIN;
   1:     nscoord lastYMost = PR_INT32_MIN;
   1:     for (line_iterator line = begin_lines();
   1:          line != line_end;
   1:          ++line) {
   1:       nsRect lineArea = line->GetCombinedArea();
   1:       rv = DisplayLine(aBuilder, lineArea, aDirtyRect, line, depth, drawnLines,
   1:                        aLists, this);
   1:       if (NS_FAILED(rv))
   1:         break;
   1:       if (!lineArea.IsEmpty()) {
   1:         if (lineArea.y < lastY
   1:             || lineArea.YMost() < lastYMost) {
   1:           nonDecreasingYs = PR_FALSE;
   1:         }
   1:         lastY = lineArea.y;
   1:         lastYMost = lineArea.YMost();
   1:       }
   1:       lineCount++;
   1:     }
   1: 
   1:     if (NS_SUCCEEDED(rv) && nonDecreasingYs && lineCount >= MIN_LINES_NEEDING_CURSOR) {
   1:       SetupLineCursor();
   1:     }
   1:   }
   1: 
   1:   if (NS_SUCCEEDED(rv) && (nsnull != mBullet) && HaveOutsideBullet()) {
   1:     // Display outside bullets manually
   1:     rv = BuildDisplayListForChild(aBuilder, mBullet, aDirtyRect, aLists);
   1:   }
   1: 
   1: #ifdef DEBUG
   1:   if (gLamePaintMetrics) {
   1:     PRTime end = PR_Now();
   1: 
   1:     PRInt32 numLines = mLines.size();
   1:     if (!numLines) numLines = 1;
   1:     PRTime lines, deltaPerLine, delta;
   1:     LL_I2L(lines, numLines);
   1:     LL_SUB(delta, end, start);
   1:     LL_DIV(deltaPerLine, delta, lines);
   1: 
   1:     ListTag(stdout);
   1:     char buf[400];
   1:     PR_snprintf(buf, sizeof(buf),
   1:                 ": %lld elapsed (%lld per line) lines=%d drawn=%d skip=%d",
   1:                 delta, deltaPerLine,
   1:                 numLines, drawnLines, numLines - drawnLines);
   1:     printf("%s\n", buf);
   1:   }
   1: #endif
   1: 
   1:   return rv;
   1: }
   1: 
   1: #ifdef ACCESSIBILITY
   1: NS_IMETHODIMP nsBlockFrame::GetAccessible(nsIAccessible** aAccessible)
   1: {
   1:   *aAccessible = nsnull;
   1:   nsCOMPtr<nsIAccessibilityService> accService = 
   1:     do_GetService("@mozilla.org/accessibilityService;1");
   1:   NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
   1: 
   1:   // block frame may be for <hr>
   1:   if (mContent->Tag() == nsGkAtoms::hr) {
3233:     return accService->CreateHTMLHRAccessible(static_cast<nsIFrame*>(this), aAccessible);
   1:   }
   1: 
 238:   nsPresContext *aPresContext = PresContext();
   1:   if (!mBullet || !aPresContext) {
   1:     if (!mContent || !mContent->GetParent()) {
   1:       // Don't create accessible objects for the root content node, they are redundant with
   1:       // the nsDocAccessible object created with the document node
   1:       return NS_ERROR_FAILURE;
   1:     }
   1:     
   1:     nsCOMPtr<nsIDOMHTMLDocument> htmlDoc =
   1:       do_QueryInterface(mContent->GetDocument());
   1:     if (htmlDoc) {
   1:       nsCOMPtr<nsIDOMHTMLElement> body;
   1:       htmlDoc->GetBody(getter_AddRefs(body));
   1:       if (SameCOMIdentity(body, mContent)) {
   1:         // Don't create accessible objects for the body, they are redundant with
   1:         // the nsDocAccessible object created with the document node
   1:         return NS_ERROR_FAILURE;
   1:       }
   1:     }
   1: 
   1:     // Not a bullet, treat as normal HTML container
3233:     return accService->CreateHyperTextAccessible(static_cast<nsIFrame*>(this), aAccessible);
   1:   }
   1: 
   1:   // Create special list bullet accessible
   1:   const nsStyleList* myList = GetStyleList();
   1:   nsAutoString bulletText;
   1:   if (myList->mListStyleImage || myList->mListStyleType == NS_STYLE_LIST_STYLE_DISC ||
   1:       myList->mListStyleType == NS_STYLE_LIST_STYLE_CIRCLE ||
   1:       myList->mListStyleType == NS_STYLE_LIST_STYLE_SQUARE) {
   1:     bulletText.Assign(PRUnichar(0x2022));; // Unicode bullet character
   1:   }
   1:   else if (myList->mListStyleType != NS_STYLE_LIST_STYLE_NONE) {
   1:     mBullet->GetListItemText(*myList, bulletText);
   1:   }
   1: 
3233:   return accService->CreateHTMLLIAccessible(static_cast<nsIFrame*>(this), 
3233:                                             static_cast<nsIFrame*>(mBullet), 
   1:                                             bulletText,
   1:                                             aAccessible);
   1: }
   1: #endif
   1: 
   1: void nsBlockFrame::ClearLineCursor() {
   1:   if (!(GetStateBits() & NS_BLOCK_HAS_LINE_CURSOR)) {
   1:     return;
   1:   }
   1: 
   1:   UnsetProperty(nsGkAtoms::lineCursorProperty);
   1:   RemoveStateBits(NS_BLOCK_HAS_LINE_CURSOR);
   1: }
   1: 
   1: void nsBlockFrame::SetupLineCursor() {
   1:   if (GetStateBits() & NS_BLOCK_HAS_LINE_CURSOR
   1:       || mLines.empty()) {
   1:     return;
   1:   }
   1:    
   1:   SetProperty(nsGkAtoms::lineCursorProperty,
   1:               mLines.front(), nsnull);
   1:   AddStateBits(NS_BLOCK_HAS_LINE_CURSOR);
   1: }
   1: 
   1: nsLineBox* nsBlockFrame::GetFirstLineContaining(nscoord y) {
   1:   if (!(GetStateBits() & NS_BLOCK_HAS_LINE_CURSOR)) {
   1:     return nsnull;
   1:   }
   1: 
3233:   nsLineBox* property = static_cast<nsLineBox*>
3233:                                    (GetProperty(nsGkAtoms::lineCursorProperty));
   1:   line_iterator cursor = mLines.begin(property);
   1:   nsRect cursorArea = cursor->GetCombinedArea();
   1: 
   1:   while ((cursorArea.IsEmpty() || cursorArea.YMost() > y)
   1:          && cursor != mLines.front()) {
   1:     cursor = cursor.prev();
   1:     cursorArea = cursor->GetCombinedArea();
   1:   }
   1:   while ((cursorArea.IsEmpty() || cursorArea.YMost() <= y)
   1:          && cursor != mLines.back()) {
   1:     cursor = cursor.next();
   1:     cursorArea = cursor->GetCombinedArea();
   1:   }
   1: 
   1:   if (cursor.get() != property) {
   1:     SetProperty(nsGkAtoms::lineCursorProperty,
   1:                 cursor.get(), nsnull);
   1:   }
   1: 
   1:   return cursor.get();
   1: }
   1: 
   1: /* virtual */ void
   1: nsBlockFrame::ChildIsDirty(nsIFrame* aChild)
   1: {
   1:   // See if the child is absolutely positioned
   1:   if (aChild->GetStateBits() & NS_FRAME_OUT_OF_FLOW &&
   1:       aChild->GetStyleDisplay()->IsAbsolutelyPositioned()) {
   1:     // do nothing
   1:   } else if (aChild == mBullet && HaveOutsideBullet()) {
   1:     // The bullet lives in the first line, unless the first line has
   1:     // height 0 and there is a second line, in which case it lives
   1:     // in the second line.
   1:     line_iterator bulletLine = begin_lines();
   1:     if (bulletLine != end_lines() && bulletLine->mBounds.height == 0 &&
   1:         bulletLine != mLines.back()) {
   1:       bulletLine = bulletLine.next();
   1:     }
   1:     
   1:     if (bulletLine != end_lines()) {
   1:       MarkLineDirty(bulletLine);
   1:     }
   1:     // otherwise we have an empty line list, and ReflowDirtyLines
   1:     // will handle reflowing the bullet.
   1:   } else {
6029:     // Mark the line containing the child frame dirty. We would rather do this
6029:     // in MarkIntrinsicWidthsDirty but that currently won't tell us which
6029:     // child is being dirtied.
   1:     line_iterator fline = FindLineFor(aChild);
6029:     if (fline != end_lines()) {
   1:       MarkLineDirty(fline);
   1:     }
6029:   }
   1: 
   1:   nsBlockFrameSuper::ChildIsDirty(aChild);
   1: }
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: // Start Debugging
   1: 
   1: #ifdef NS_DEBUG
   1: static PRBool
   1: InLineList(nsLineList& aLines, nsIFrame* aFrame)
   1: {
   1:   for (nsLineList::iterator line = aLines.begin(), line_end = aLines.end();
   1:        line != line_end;
   1:        ++line) {
   1:     nsIFrame* frame = line->mFirstChild;
   1:     PRInt32 n = line->GetChildCount();
   1:     while (--n >= 0) {
   1:       if (frame == aFrame) {
   1:         return PR_TRUE;
   1:       }
   1:       frame = frame->GetNextSibling();
   1:     }
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: static PRBool
   1: InSiblingList(nsLineList& aLines, nsIFrame* aFrame)
   1: {
   1:   if (! aLines.empty()) {
   1:     nsIFrame* frame = aLines.front()->mFirstChild;
   1:     while (frame) {
   1:       if (frame == aFrame) {
   1:         return PR_TRUE;
   1:       }
   1:       frame = frame->GetNextSibling();
   1:     }
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::VerifyTree() const
   1: {
   1:   // XXX rewrite this
   1:   return NS_OK;
   1: }
   1: #endif
   1: 
   1: // End Debugging
   1: //////////////////////////////////////////////////////////////////////
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::Init(nsIContent*      aContent,
   1:                    nsIFrame*        aParent,
   1:                    nsIFrame*        aPrevInFlow)
   1: {
   1:   if (aPrevInFlow) {
   1:     // Copy over the block/area frame type flags
   1:     nsBlockFrame*  blockFrame = (nsBlockFrame*)aPrevInFlow;
   1: 
   1:     SetFlags(blockFrame->mState &
   1:              (NS_BLOCK_FLAGS_MASK & ~NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET));
   1:   }
   1: 
   1:   nsresult rv = nsBlockFrameSuper::Init(aContent, aParent, aPrevInFlow);
   1: 
6829:   if (!aPrevInFlow ||
6829:       aPrevInFlow->GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)
5590:     AddStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);
5590: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsBlockFrame::SetInitialChildList(nsIAtom*        aListName,
   1:                                   nsIFrame*       aChildList)
   1: {
   1:   nsresult rv = NS_OK;
   1: 
4205:   if (nsGkAtoms::absoluteList == aListName) {
   1:     mAbsoluteContainer.SetInitialChildList(this, aListName, aChildList);
   1:   }
   1:   else if (nsGkAtoms::floatList == aListName) {
   1:     mFloats.SetFrames(aChildList);
   1:   }
   1:   else {
 238:     nsPresContext* presContext = PresContext();
   1: 
1026: #ifdef DEBUG
1026:     // The only times a block that is an anonymous box is allowed to have a
1026:     // first-letter frame are when it's the block inside a non-anonymous cell,
1026:     // the block inside a fieldset, a scrolled content block, or a column
1026:     // content block.  Note that this means that blocks which are the anonymous
8324:     // block in {ib} splits do NOT get first-letter frames.  Note that
8324:     // NS_BLOCK_HAS_FIRST_LETTER_STYLE gets set on all continuations of the
8324:     // block.
1026:     nsIAtom *pseudo = GetStyleContext()->GetPseudoType();
1026:     PRBool haveFirstLetterStyle =
1026:       (!pseudo ||
1026:        (pseudo == nsCSSAnonBoxes::cellContent &&
1026:         mParent->GetStyleContext()->GetPseudoType() == nsnull) ||
1026:        pseudo == nsCSSAnonBoxes::fieldsetContent ||
1026:        pseudo == nsCSSAnonBoxes::scrolledContent ||
1026:        pseudo == nsCSSAnonBoxes::columnContent) &&
6818:       !IsFrameOfType(eMathML) &&
1026:       nsRefPtr<nsStyleContext>(GetFirstLetterStyle(presContext)) != nsnull;
1026:     NS_ASSERTION(haveFirstLetterStyle ==
 551:                  ((mState & NS_BLOCK_HAS_FIRST_LETTER_STYLE) != 0),
 551:                  "NS_BLOCK_HAS_FIRST_LETTER_STYLE state out of sync");
1026: #endif
   1:     
   1:     rv = AddFrames(aChildList, nsnull);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     // Create list bullet if this is a list-item. Note that this is done
   1:     // here so that RenumberLists will work (it needs the bullets to
   1:     // store the bullet numbers).
   1:     const nsStyleDisplay* styleDisplay = GetStyleDisplay();
   1:     if ((nsnull == GetPrevInFlow()) &&
   1:         (NS_STYLE_DISPLAY_LIST_ITEM == styleDisplay->mDisplay) &&
   1:         (nsnull == mBullet)) {
   1:       // Resolve style for the bullet frame
   1:       const nsStyleList* styleList = GetStyleList();
   1:       nsIAtom *pseudoElement;
   1:       switch (styleList->mListStyleType) {
   1:         case NS_STYLE_LIST_STYLE_DISC:
   1:         case NS_STYLE_LIST_STYLE_CIRCLE:
   1:         case NS_STYLE_LIST_STYLE_SQUARE:
   1:           pseudoElement = nsCSSPseudoElements::mozListBullet;
   1:           break;
   1:         default:
   1:           pseudoElement = nsCSSPseudoElements::mozListNumber;
   1:           break;
   1:       }
   1: 
   1:       nsIPresShell *shell = presContext->PresShell();
   1: 
4200:       nsStyleContext* parentStyle =
4200:         CorrectStyleParentFrame(this, pseudoElement)->GetStyleContext();
   1:       nsRefPtr<nsStyleContext> kidSC = shell->StyleSet()->
4200:         ResolvePseudoStyleFor(mContent, pseudoElement, parentStyle);
   1: 
   1:       // Create bullet frame
   1:       nsBulletFrame* bullet = new (shell) nsBulletFrame(kidSC);
   1:       if (nsnull == bullet) {
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:       }
   1:       bullet->Init(mContent, this, nsnull);
   1: 
   1:       // If the list bullet frame should be positioned inside then add
   1:       // it to the flow now.
   1:       if (NS_STYLE_LIST_STYLE_POSITION_INSIDE ==
   1:           styleList->mListStylePosition) {
   1:         AddFrames(bullet, nsnull);
   1:         mState &= ~NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET;
   1:       }
   1:       else {
   1:         mState |= NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET;
   1:       }
   1: 
   1:       mBullet = bullet;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // static
   1: PRBool
   1: nsBlockFrame::FrameStartsCounterScope(nsIFrame* aFrame)
   1: {
   1:   nsIContent* content = aFrame->GetContent();
   1:   if (!content || !content->IsNodeOfType(nsINode::eHTML))
   1:     return PR_FALSE;
   1: 
   1:   nsIAtom *localName = content->NodeInfo()->NameAtom();
   1:   return localName == nsGkAtoms::ol ||
   1:          localName == nsGkAtoms::ul ||
   1:          localName == nsGkAtoms::dir ||
   1:          localName == nsGkAtoms::menu;
   1: }
   1: 
1158: PRBool
   1: nsBlockFrame::RenumberLists(nsPresContext* aPresContext)
   1: {
   1:   if (!FrameStartsCounterScope(this)) {
   1:     // If this frame doesn't start a counter scope then we don't need
   1:     // to renumber child list items.
1158:     return PR_FALSE;
   1:   }
   1: 
   1:   // Setup initial list ordinal value
   1:   // XXX Map html's start property to counter-reset style
   1:   PRInt32 ordinal = 1;
   1: 
   1:   nsGenericHTMLElement *hc = nsGenericHTMLElement::FromContent(mContent);
   1: 
   1:   if (hc) {
   1:     const nsAttrValue* attr = hc->GetParsedAttr(nsGkAtoms::start);
   1:     if (attr && attr->Type() == nsAttrValue::eInteger) {
   1:       ordinal = attr->GetIntegerValue();
   1:     }
   1:   }
   1: 
   1:   // Get to first-in-flow
   1:   nsBlockFrame* block = (nsBlockFrame*) GetFirstInFlow();
1158:   return RenumberListsInBlock(aPresContext, block, &ordinal, 0);
   1: }
   1: 
   1: PRBool
   1: nsBlockFrame::RenumberListsInBlock(nsPresContext* aPresContext,
   1:                                    nsBlockFrame* aBlockFrame,
   1:                                    PRInt32* aOrdinal,
   1:                                    PRInt32 aDepth)
   1: {
   1:   PRBool renumberedABullet = PR_FALSE;
   1: 
   1:   while (nsnull != aBlockFrame) {
   1:     // Examine each line in the block
   1:     for (line_iterator line = aBlockFrame->begin_lines(),
   1:                        line_end = aBlockFrame->end_lines();
   1:          line != line_end;
   1:          ++line) {
   1:       nsIFrame* kid = line->mFirstChild;
   1:       PRInt32 n = line->GetChildCount();
   1:       while (--n >= 0) {
   1:         PRBool kidRenumberedABullet = RenumberListsFor(aPresContext, kid, aOrdinal, aDepth);
   1:         if (kidRenumberedABullet) {
   1:           line->MarkDirty();
   1:           renumberedABullet = PR_TRUE;
   1:         }
   1:         kid = kid->GetNextSibling();
   1:       }
   1:     }
   1: 
   1:     // Advance to the next continuation
3233:     aBlockFrame = static_cast<nsBlockFrame*>(aBlockFrame->GetNextInFlow());
   1:   }
   1: 
   1:   return renumberedABullet;
   1: }
   1: 
   1: PRBool
   1: nsBlockFrame::RenumberListsFor(nsPresContext* aPresContext,
   1:                                nsIFrame* aKid,
   1:                                PRInt32* aOrdinal,
   1:                                PRInt32 aDepth)
   1: {
   1:   NS_PRECONDITION(aPresContext && aKid && aOrdinal, "null params are immoral!");
   1: 
   1:   // add in a sanity check for absurdly deep frame trees.  See bug 42138
   1:   if (MAX_DEPTH_FOR_LIST_RENUMBERING < aDepth)
   1:     return PR_FALSE;
   1: 
   1:   PRBool kidRenumberedABullet = PR_FALSE;
   1: 
   1:   // if the frame is a placeholder, then get the out of flow frame
   1:   nsIFrame* kid = nsPlaceholderFrame::GetRealFrameFor(aKid);
   1: 
   1:   // drill down through any wrappers to the real frame
   1:   kid = kid->GetContentInsertionFrame();
   1: 
   1:   // If the frame is a list-item and the frame implements our
   1:   // block frame API then get its bullet and set the list item
   1:   // ordinal.
   1:   const nsStyleDisplay* display = kid->GetStyleDisplay();
   1:   if (NS_STYLE_DISPLAY_LIST_ITEM == display->mDisplay) {
   1:     // Make certain that the frame is a block frame in case
   1:     // something foreign has crept in.
   1:     nsBlockFrame* listItem;
   1:     nsresult rv = kid->QueryInterface(kBlockFrameCID, (void**)&listItem);
   1:     if (NS_SUCCEEDED(rv)) {
   1:       if (nsnull != listItem->mBullet) {
   1:         PRBool changed;
   1:         *aOrdinal = listItem->mBullet->SetListItemOrdinal(*aOrdinal,
   1:                                                           &changed);
   1:         if (changed) {
   1:           kidRenumberedABullet = PR_TRUE;
   1: 
   1:           // Invalidate the bullet content area since it may look different now
   1:           nsRect damageRect(nsPoint(0, 0), listItem->mBullet->GetSize());
   1:           listItem->mBullet->Invalidate(damageRect);
   1:         }
   1:       }
   1: 
   1:       // XXX temporary? if the list-item has child list-items they
   1:       // should be numbered too; especially since the list-item is
   1:       // itself (ASSUMED!) not to be a counter-resetter.
   1:       PRBool meToo = RenumberListsInBlock(aPresContext, listItem, aOrdinal, aDepth + 1);
   1:       if (meToo) {
   1:         kidRenumberedABullet = PR_TRUE;
   1:       }
   1:     }
   1:   }
   1:   else if (NS_STYLE_DISPLAY_BLOCK == display->mDisplay) {
   1:     if (FrameStartsCounterScope(kid)) {
   1:       // Don't bother recursing into a block frame that is a new
   1:       // counter scope. Any list-items in there will be handled by
   1:       // it.
   1:     }
   1:     else {
   1:       // If the display=block element is a block frame then go ahead
   1:       // and recurse into it, as it might have child list-items.
   1:       nsBlockFrame* kidBlock;
   1:       nsresult rv = kid->QueryInterface(kBlockFrameCID, (void**) &kidBlock);
   1:       if (NS_SUCCEEDED(rv)) {
   1:         kidRenumberedABullet = RenumberListsInBlock(aPresContext, kidBlock, aOrdinal, aDepth + 1);
   1:       }
   1:     }
   1:   }
   1:   return kidRenumberedABullet;
   1: }
   1: 
   1: void
   1: nsBlockFrame::ReflowBullet(nsBlockReflowState& aState,
   1:                            nsHTMLReflowMetrics& aMetrics)
   1: {
   1:   const nsHTMLReflowState &rs = aState.mReflowState;
   1: 
   1:   // Reflow the bullet now
   1:   nsSize availSize;
   1:   // Make up a width since it doesn't really matter (XXX).
   1:   availSize.width = rs.ComputedWidth();
   1:   availSize.height = NS_UNCONSTRAINEDSIZE;
   1: 
   1:   // Get the reason right.
   1:   // XXXwaterson Should this look just like the logic in
   1:   // nsBlockReflowContext::ReflowBlock and nsLineLayout::ReflowFrame?
   1:   nsHTMLReflowState reflowState(aState.mPresContext, rs,
   1:                                 mBullet, availSize);
   1:   nsReflowStatus  status;
   1:   mBullet->WillReflow(aState.mPresContext);
   1:   mBullet->Reflow(aState.mPresContext, aMetrics, reflowState, status);
   1: 
   1:   // Place the bullet now; use its right margin to distance it
   1:   // from the rest of the frames in the line
   1:   nscoord x = 
   1: #ifdef IBMBIDI
   1:            (NS_STYLE_DIRECTION_RTL == GetStyleVisibility()->mDirection)
   1:              // According to the CSS2 spec, section 12.6.1, outside marker box
   1:              // is distanced from the associated principal box's border edge.
   1:              // |rs.availableWidth| reflects exactly a border edge: it includes
   1:              // border, padding, and content area, without margins.
   1:              ? rs.ComputedWidth() + rs.mComputedBorderPadding.LeftRight() +
   1:                reflowState.mComputedMargin.left :
   1: #endif
   1:              - reflowState.mComputedMargin.right - aMetrics.width;
   1: 
   1:   // Approximate the bullets position; vertical alignment will provide
   1:   // the final vertical location.
   1:   const nsMargin& bp = aState.BorderPadding();
   1:   nscoord y = bp.top;
   1:   mBullet->SetRect(nsRect(x, y, aMetrics.width, aMetrics.height));
   1:   mBullet->DidReflow(aState.mPresContext, &aState.mReflowState, NS_FRAME_REFLOW_FINISHED);
   1: }
   1: 
   1: // This is used to scan frames for any float placeholders, add their
6261: // floats to the list represented by aList and aTail, and remove the
   1: // floats from whatever list they might be in. We don't search descendants
   1: // that are float containing blocks. The floats must be children of 'this'.
   1: void nsBlockFrame::CollectFloats(nsIFrame* aFrame, nsFrameList& aList, nsIFrame** aTail,
 686:                                  PRBool aFromOverflow, PRBool aCollectSiblings) {
   1:   while (aFrame) {
   1:     // Don't descend into float containing blocks.
   1:     if (!aFrame->IsFloatContainingBlock()) {
   1:       nsIFrame *outOfFlowFrame = nsLayoutUtils::GetFloatFromPlaceholder(aFrame);
   1:       if (outOfFlowFrame) {
   1:         // Make sure that its parent is us. Otherwise we don't want
   1:         // to mess around with it because it belongs to someone
   1:         // else. I think this could happen if the overflow lines
   1:         // contain a block descendant which owns its own floats.
   1:         NS_ASSERTION(outOfFlowFrame->GetParent() == this,
   1:                      "Out of flow frame doesn't have the expected parent");
   1:         if (aFromOverflow) {
   1:           nsAutoOOFFrameList oofs(this);
   1:           oofs.mList.RemoveFrame(outOfFlowFrame);
   1:         } else {
   1:           mFloats.RemoveFrame(outOfFlowFrame);
   1:         }
   1:         aList.InsertFrame(nsnull, *aTail, outOfFlowFrame);
   1:         *aTail = outOfFlowFrame;
   1:       }
   1: 
6261:       CollectFloats(aFrame->GetFirstChild(nsnull), 
6261:                     aList, aTail, aFromOverflow, PR_TRUE);
6261:       // Note: Even though we're calling CollectFloats on aFrame's overflow
6261:       // list, we'll pass down aFromOverflow unchanged because we're still
6262:       // traversing the regular-children subtree of the 'this' frame.
6261:       CollectFloats(aFrame->GetFirstChild(nsGkAtoms::overflowList), 
6261:                     aList, aTail, aFromOverflow, PR_TRUE);
 686:     }
 686:     if (!aCollectSiblings)
 686:       break;
   1:     aFrame = aFrame->GetNextSibling();
   1:   }
   1: }
   1: 
   1: void
   1: nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
   1: {
   1: #ifdef DEBUG
8457:   // If any line is still dirty, that must mean we're going to reflow this
8457:   // block again soon (e.g. because we bailed out after noticing that
8457:   // clearance was imposed), so don't worry if the floats are out of sync.
8457:   PRBool anyLineDirty = PR_FALSE;
8457: 
   1:   // Check that the float list is what we would have built
   1:   nsAutoVoidArray lineFloats;
   1:   for (line_iterator line = begin_lines(), line_end = end_lines();
   1:        line != line_end; ++line) {
   1:     if (line->HasFloats()) {
   1:       nsFloatCache* fc = line->GetFirstFloat();
   1:       while (fc) {
   1:         nsIFrame* floatFrame = fc->mPlaceholder->GetOutOfFlowFrame();
   1:         lineFloats.AppendElement(floatFrame);
   1:         fc = fc->Next();
   1:       }
   1:     }
8457:     if (line->IsDirty()) {
8457:       anyLineDirty = PR_TRUE;
8457:     }
   1:   }
   1:   
   1:   nsAutoVoidArray storedFloats;
   1:   PRBool equal = PR_TRUE;
   1:   PRInt32 i = 0;
   1:   for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
   1:     storedFloats.AppendElement(f);
   1:     if (i < lineFloats.Count() && lineFloats.ElementAt(i) != f) {
   1:       equal = PR_FALSE;
   1:     }
   1:     ++i;
   1:   }
   1: 
8457:   if ((!equal || lineFloats.Count() != storedFloats.Count()) && !anyLineDirty) {
   1:     NS_WARNING("nsBlockFrame::CheckFloats: Explicit float list is out of sync with float cache");
   1: #if defined(DEBUG_roc)
 280:     nsIFrameDebug::RootFrameList(PresContext(), stdout, 0);
   1:     for (i = 0; i < lineFloats.Count(); ++i) {
   1:       printf("Line float: %p\n", lineFloats.ElementAt(i));
   1:     }
   1:     for (i = 0; i < storedFloats.Count(); ++i) {
   1:       printf("Stored float: %p\n", storedFloats.ElementAt(i));
   1:     }
   1: #endif
   1:   }
   1: #endif
   1: 
   1:   nsFrameList oofs = GetOverflowOutOfFlows();
   1:   if (oofs.NotEmpty()) {
   1:     // Floats that were pushed should be removed from our space
   1:     // manager.  Otherwise the space manager's YMost or XMost might
   1:     // be larger than necessary, causing this block to get an
   1:     // incorrect desired height (or width).  Some of these floats
   1:     // may not actually have been added to the space manager because
   1:     // they weren't reflowed before being pushed; that's OK,
   1:     // RemoveRegions will ignore them. It is safe to do this here
   1:     // because we know from here on the space manager will only be
   1:     // used for its XMost and YMost, not to place new floats and
   1:     // lines.
   1:     aState.mSpaceManager->RemoveTrailingRegions(oofs.FirstChild());
   1:   }
   1: }
   1: 
   1: /* static */
   1: PRBool
   1: nsBlockFrame::BlockIsMarginRoot(nsIFrame* aBlock)
   1: {
   1:   NS_PRECONDITION(aBlock, "Must have a frame");
   1: #ifdef DEBUG
   1:   nsBlockFrame* blockFrame;
   1:   aBlock->QueryInterface(kBlockFrameCID, (void**)&blockFrame);
   1:   NS_ASSERTION(blockFrame, "aBlock must be a block");
   1: #endif
   1: 
   1:   nsIFrame* parent = aBlock->GetParent();
   1:   return (aBlock->GetStateBits() & NS_BLOCK_MARGIN_ROOT) ||
   1:     (parent && !parent->IsFloatContainingBlock() &&
   1:      parent->GetType() != nsGkAtoms::columnSetFrame);
   1: }
   1: 
   1: /* static */
   1: PRBool
   1: nsBlockFrame::BlockNeedsSpaceManager(nsIFrame* aBlock)
   1: {
   1:   NS_PRECONDITION(aBlock, "Must have a frame");
   1: #ifdef DEBUG
   1:   nsBlockFrame* blockFrame;
   1:   aBlock->QueryInterface(kBlockFrameCID, (void**)&blockFrame);
   1:   NS_ASSERTION(blockFrame, "aBlock must be a block");
   1: #endif
   1: 
   1:   nsIFrame* parent = aBlock->GetParent();
   1:   return (aBlock->GetStateBits() & NS_BLOCK_SPACE_MGR) ||
   1:     (parent && !parent->IsFloatContainingBlock());
   1: }
   1:  
7046: /* static */
7046: nsBlockFrame*
7046: nsBlockFrame::GetNearestAncestorBlock(nsIFrame* aCandidate)
7046: {
7046:   nsBlockFrame* block = nsnull;
7046:   while(aCandidate) {
7046:     aCandidate->QueryInterface(kBlockFrameCID, (void**)&block);
7046:     if (block) { 
7046:       // yay, candidate is a block!
7046:       return block;
7046:     }
7046:     // Not a block. Check its parent next.
7046:     aCandidate = aCandidate->GetParent();
7046:   }
7046:   NS_NOTREACHED("Fell off frame tree looking for ancestor block!");
7046:   return nsnull;
7046: }
7046: 
   1: #ifdef IBMBIDI
1920: nsresult
1920: nsBlockFrame::ResolveBidi()
1920: {
5590:   NS_ASSERTION(!GetPrevInFlow(),
5590:                "ResolveBidi called on non-first continuation");
5590: 
1920:   nsPresContext* presContext = PresContext();
1920:   if (!presContext->BidiEnabled()) {
1920:     return NS_OK;
1920:   }
1920: 
1920:   nsBidiPresUtils* bidiUtils = presContext->GetBidiUtils();
1920:   if (!bidiUtils)
5590:     return NS_ERROR_NULL_POINTER;
5590: 
6829:   for (nsBlockFrame* curFrame = this; curFrame;
6829:        curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {
6829:     curFrame->RemoveStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);
5590:     if (!curFrame->mLines.empty()) {
5590:       nsresult rv = bidiUtils->Resolve(curFrame,
5590:                                        curFrame->mLines.front()->mFirstChild,
5590:                                        IsVisualFormControl(presContext));
5590:       if (NS_FAILED(rv))
5590:         return rv;
5590:     }
5590:   }
5590: 
1920:   return NS_OK;
1920: }
1920: 
   1: PRBool
   1: nsBlockFrame::IsVisualFormControl(nsPresContext* aPresContext)
   1: {
   1:   // This check is only necessary on visual bidi pages, because most
   1:   // visual pages use logical order for form controls so that they will
   1:   // display correctly on native widgets in OSs with Bidi support.
   1:   // So bail out if the page is not visual, or if the pref is
   1:   // set to use visual order on forms in visual pages
   1:   if (!aPresContext->IsVisualMode()) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   PRUint32 options = aPresContext->GetBidi();
   1:   if (IBMBIDI_CONTROLSTEXTMODE_LOGICAL != GET_BIDI_OPTION_CONTROLSTEXTMODE(options)) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   nsIContent* content = GetContent();
   1:   for ( ; content; content = content->GetParent()) {
   1:     if (content->IsNodeOfType(nsINode::eHTML_FORM_CONTROL)) {
   1:       return PR_TRUE;
   1:     }
   1:   }
   1:   
   1:   return PR_FALSE;
   1: }
   1: #endif
   1: 
   1: #ifdef DEBUG
   1: void
   1: nsBlockFrame::VerifyLines(PRBool aFinalCheckOK)
   1: {
   1:   if (!gVerifyLines) {
   1:     return;
   1:   }
   1:   if (mLines.empty()) {
   1:     return;
   1:   }
   1: 
   1:   // Add up the counts on each line. Also validate that IsFirstLine is
   1:   // set properly.
   1:   PRInt32 count = 0;
   1:   PRBool seenBlock = PR_FALSE;
   1:   line_iterator line, line_end;
   1:   for (line = begin_lines(), line_end = end_lines();
   1:        line != line_end;
   1:        ++line) {
   1:     if (aFinalCheckOK) {
   1:       NS_ABORT_IF_FALSE(line->GetChildCount(), "empty line");
   1:       if (line->IsBlock()) {
   1:         seenBlock = PR_TRUE;
   1:       }
   1:       if (line->IsBlock()) {
   1:         NS_ASSERTION(1 == line->GetChildCount(), "bad first line");
   1:       }
   1:     }
   1:     count += line->GetChildCount();
   1:   }
   1: 
   1:   // Then count the frames
   1:   PRInt32 frameCount = 0;
   1:   nsIFrame* frame = mLines.front()->mFirstChild;
   1:   while (frame) {
   1:     frameCount++;
   1:     frame = frame->GetNextSibling();
   1:   }
   1:   NS_ASSERTION(count == frameCount, "bad line list");
   1: 
   1:   // Next: test that each line has right number of frames on it
   1:   for (line = begin_lines(), line_end = end_lines();
   1:        line != line_end;
   1:         ) {
   1:     count = line->GetChildCount();
   1:     frame = line->mFirstChild;
   1:     while (--count >= 0) {
   1:       frame = frame->GetNextSibling();
   1:     }
   1:     ++line;
   1:     if ((line != line_end) && (0 != line->GetChildCount())) {
   1:       NS_ASSERTION(frame == line->mFirstChild, "bad line list");
   1:     }
   1:   }
   1: }
   1: 
   1: // Its possible that a frame can have some frames on an overflow
   1: // list. But its never possible for multiple frames to have overflow
   1: // lists. Check that this fact is actually true.
   1: void
   1: nsBlockFrame::VerifyOverflowSituation()
   1: {
   1:   nsBlockFrame* flow = (nsBlockFrame*) GetFirstInFlow();
   1:   while (nsnull != flow) {
   1:     nsLineList* overflowLines = GetOverflowLines();
   1:     if (nsnull != overflowLines) {
   1:       NS_ASSERTION(! overflowLines->empty(), "should not be empty if present");
   1:       NS_ASSERTION(overflowLines->front()->mFirstChild, "bad overflow list");
   1:     }
   1:     flow = (nsBlockFrame*) flow->GetNextInFlow();
   1:   }
   1: }
   1: 
   1: PRInt32
   1: nsBlockFrame::GetDepth() const
   1: {
   1:   PRInt32 depth = 0;
   1:   nsIFrame* parent = mParent;
   1:   while (parent) {
   1:     parent = parent->GetParent();
   1:     depth++;
   1:   }
   1:   return depth;
   1: }
   1: #endif
