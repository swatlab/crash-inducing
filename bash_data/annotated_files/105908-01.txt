 69169: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
     1:  *
     1:  * This Original Code has been modified by IBM Corporation.
     1:  * Modifications made by IBM described herein are
     1:  * Copyright (c) International Business Machines
     1:  * Corporation, 2000
     1:  *
     1:  * Modifications to Mozilla code or documentation
     1:  * identified per MPL Section 3.3
     1:  *
     1:  * Date         Modified by     Description of modification
     1:  * 03/27/2000   IBM Corp.       Added PR_CALLBACK for Optlink
     1:  *                               use in OS2
     1:  */
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsDOMCID.h"
     1: #include "nsDOMError.h"
     1: #include "nsDOMString.h"
     1: #include "nsIDOMEvent.h"
     1: #include "nsHashtable.h"
     1: #include "nsIAtom.h"
  7242: #include "nsIBaseWindow.h"
     1: #include "nsIDOMAttr.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMEventListener.h"
     1: #include "nsIDOMNodeList.h"
     1: #include "nsIDOMXULCommandDispatcher.h"
     1: #include "nsIDOMXULElement.h"
     1: #include "nsIDOMElementCSSInlineStyle.h"
     1: #include "nsIDOMXULSelectCntrlItemEl.h"
     1: #include "nsIDocument.h"
 72328: #include "nsEventListenerManager.h"
 68780: #include "nsEventStateManager.h"
 29018: #include "nsFocusManager.h"
     1: #include "nsHTMLStyleSheet.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsIObjectInputStream.h"
     1: #include "nsIObjectOutputStream.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIPrincipal.h"
     1: #include "nsIRDFCompositeDataSource.h"
     1: #include "nsIRDFNode.h"
     1: #include "nsIRDFService.h"
     1: #include "nsIScriptContext.h"
     1: #include "nsIScriptRuntime.h"
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsIScriptGlobalObjectOwner.h"
     1: #include "nsIServiceManager.h"
 63693: #include "mozilla/css/StyleRule.h"
     1: #include "nsIStyleSheet.h"
     1: #include "nsIURL.h"
     1: #include "nsIViewManager.h"
     1: #include "nsIWidget.h"
     1: #include "nsIXULDocument.h"
     1: #include "nsIXULTemplateBuilder.h"
     1: #include "nsLayoutCID.h"
     1: #include "nsContentCID.h"
     1: #include "nsRDFCID.h"
     1: #include "nsStyleConsts.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsXULControllers.h"
     1: #include "nsIBoxObject.h"
     1: #include "nsPIBoxObject.h"
     1: #include "nsXULDocument.h"
  3129: #include "nsXULPopupListener.h"
     1: #include "nsRuleWalker.h"
     1: #include "nsIDOMCSSStyleDeclaration.h"
 38849: #include "nsCSSParser.h"
     1: #include "nsIListBoxObject.h"
     1: #include "nsContentUtils.h"
     1: #include "nsContentList.h"
     1: #include "nsMutationEvent.h"
 84833: #include "nsAsyncDOMEvent.h"
     1: #include "nsIDOMMutationEvent.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsDOMAttributeMap.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsXULContentUtils.h"
     1: #include "nsNodeUtils.h"
 13432: #include "nsFrameLoader.h"
     1: #include "prlog.h"
     1: #include "rdf.h"
     1: #include "nsIControllers.h"
 90060: #include "nsAttrValueOrString.h"
102310: #include "mozilla/Attributes.h"
     1: 
     1: // The XUL doc interface
     1: #include "nsIDOMXULDocument.h"
     1: 
     1: #include "nsReadableUtils.h"
     1: #include "nsIFrame.h"
     1: #include "nsNodeInfoManager.h"
     1: #include "nsXBLBinding.h"
     1: #include "nsEventDispatcher.h"
 14228: #include "mozAutoDocUpdate.h"
 15254: #include "nsIDOMXULCommandEvent.h"
 15254: #include "nsIDOMNSEvent.h"
 20136: #include "nsCCUncollectableMarker.h"
     1: 
 63693: namespace css = mozilla::css;
 63693: 
     1: //----------------------------------------------------------------------
     1: 
     1: static NS_DEFINE_CID(kXULPopupListenerCID,        NS_XULPOPUPLISTENER_CID);
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: #ifdef XUL_PROTOTYPE_ATTRIBUTE_METERING
     1: PRUint32             nsXULPrototypeAttribute::gNumElements;
     1: PRUint32             nsXULPrototypeAttribute::gNumAttributes;
     1: PRUint32             nsXULPrototypeAttribute::gNumCacheTests;
     1: PRUint32             nsXULPrototypeAttribute::gNumCacheHits;
     1: PRUint32             nsXULPrototypeAttribute::gNumCacheSets;
     1: PRUint32             nsXULPrototypeAttribute::gNumCacheFills;
     1: #endif
     1: 
102310: class nsXULElementTearoff MOZ_FINAL : public nsIDOMElementCSSInlineStyle,
 13432:                                       public nsIFrameLoaderOwner
     1: {
     1: public:
 13432:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 13432:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsXULElementTearoff,
 13432:                                            nsIDOMElementCSSInlineStyle)
     1: 
     1:   nsXULElementTearoff(nsXULElement *aElement)
     1:     : mElement(aElement)
     1:   {
     1:   }
     1: 
 48944:   NS_IMETHOD GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
 48944:   {
 48944:     nsresult rv;
 48944:     *aStyle = static_cast<nsXULElement*>(mElement.get())->GetStyle(&rv);
 48944:     NS_ENSURE_SUCCESS(rv, rv);
 48944:     NS_ADDREF(*aStyle);
 48944:     return NS_OK;
 48944:   }
 13432:   NS_FORWARD_NSIFRAMELOADEROWNER(static_cast<nsXULElement*>(mElement.get())->);
     1: private:
 13432:   nsCOMPtr<nsIDOMXULElement> mElement;
     1: };
     1: 
 13432: NS_IMPL_CYCLE_COLLECTION_1(nsXULElementTearoff, mElement)
 13432: 
 13432: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXULElementTearoff)
 13432: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXULElementTearoff)
 13432: 
 13432: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXULElementTearoff)
 13432:   NS_INTERFACE_MAP_ENTRY(nsIFrameLoaderOwner)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMElementCSSInlineStyle)
     1: NS_INTERFACE_MAP_END_AGGREGATED(mElement)
     1: 
     1: //----------------------------------------------------------------------
     1: // nsXULElement
     1: //
     1: 
 94340: nsXULElement::nsXULElement(already_AddRefed<nsINodeInfo> aNodeInfo)
 38452:     : nsStyledElement(aNodeInfo),
     1:       mBindingParent(nsnull)
     1: {
     1:     XUL_PROTOTYPE_ATTRIBUTE_METER(gNumElements);
 71121: 
 71121:     // We may be READWRITE by default; check.
 71121:     if (IsReadWriteTextElement()) {
 71121:         AddStatesSilently(NS_EVENT_STATE_MOZ_READWRITE);
 71121:         RemoveStatesSilently(NS_EVENT_STATE_MOZ_READONLY);
 71121:     }
     1: }
     1: 
 67604: nsXULElement::nsXULSlots::nsXULSlots()
 67604:     : nsXULElement::nsDOMSlots()
     1: {
     1: }
     1: 
     1: nsXULElement::nsXULSlots::~nsXULSlots()
     1: {
     1:     NS_IF_RELEASE(mControllers); // Forces release
 13432:     if (mFrameLoader) {
 13432:         mFrameLoader->Destroy();
 13432:     }
     1: }
     1: 
 77323: void
 77323: nsXULElement::nsXULSlots::Traverse(nsCycleCollectionTraversalCallback &cb)
 77323: {
 77323:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mSlots->mFrameLoader");
 77323:     cb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsIFrameLoader*, mFrameLoader));
 77323: }
 77323: 
     1: nsINode::nsSlots*
     1: nsXULElement::CreateSlots()
     1: {
 67604:     return new nsXULSlots();
     1: }
     1: 
     1: /* static */
     1: already_AddRefed<nsXULElement>
 94340: nsXULElement::Create(nsXULPrototypeElement* aPrototype, nsINodeInfo *aNodeInfo,
 79445:                      bool aIsScriptable)
     1: {
 94340:     nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
 48124:     nsXULElement *element = new nsXULElement(ni.forget());
     1:     if (element) {
     1:         NS_ADDREF(element);
     1: 
  6041:         if (aPrototype->mHasIdAttribute) {
 67607:             element->SetHasID();
  6041:         }
  6041:         if (aPrototype->mHasClassAttribute) {
  6041:             element->SetFlags(NODE_MAY_HAVE_CLASS);
  6041:         }
  6041:         if (aPrototype->mHasStyleAttribute) {
 67608:             element->SetMayHaveStyle();
  6041:         }
     1: 
105643:         element->MakeHeavyweight(aPrototype);
     1:         if (aIsScriptable) {
     1:             // Check each attribute on the prototype to see if we need to do
     1:             // any additional processing and hookup that would otherwise be
     1:             // done 'automagically' by SetAttr().
     1:             for (PRUint32 i = 0; i < aPrototype->mNumAttributes; ++i) {
     1:                 element->AddListenerFor(aPrototype->mAttributes[i].mName,
 80486:                                         true);
     1:             }
     1:         }
     1:     }
     1: 
     1:     return element;
     1: }
     1: 
     1: nsresult
     1: nsXULElement::Create(nsXULPrototypeElement* aPrototype,
     1:                      nsIDocument* aDocument,
 79445:                      bool aIsScriptable,
 41635:                      Element** aResult)
     1: {
     1:     // Create an nsXULElement from a prototype
     1:     NS_PRECONDITION(aPrototype != nsnull, "null ptr");
     1:     if (! aPrototype)
     1:         return NS_ERROR_NULL_POINTER;
     1: 
     1:     NS_PRECONDITION(aResult != nsnull, "null ptr");
     1:     if (! aResult)
     1:         return NS_ERROR_NULL_POINTER;
     1: 
 94340:     nsCOMPtr<nsINodeInfo> nodeInfo;
     1:     if (aDocument) {
 94340:         nsINodeInfo* ni = aPrototype->mNodeInfo;
 71770:         nodeInfo = aDocument->NodeInfoManager()->
 71770:           GetNodeInfo(ni->NameAtom(), ni->GetPrefixAtom(), ni->NamespaceID(),
 71770:                       nsIDOMNode::ELEMENT_NODE);
 19747:         NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
     1:     }
     1:     else {
     1:         nodeInfo = aPrototype->mNodeInfo;
     1:     }
     1: 
     1:     nsRefPtr<nsXULElement> element = Create(aPrototype, nodeInfo,
     1:                                             aIsScriptable);
     1:     if (!element) {
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
105643:     element.forget(aResult);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
 94340: NS_NewXULElement(nsIContent** aResult, already_AddRefed<nsINodeInfo> aNodeInfo)
     1: {
 48124:     NS_PRECONDITION(aNodeInfo.get(), "need nodeinfo for non-proto Create");
     1: 
 51393:     nsIDocument* doc = aNodeInfo.get()->GetDocument();
 51393:     if (doc && !doc->AllowXULXBL()) {
 94340:         nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
 51393:         return NS_ERROR_NOT_AVAILABLE;
 51393:     }
 51393: 
 51393:     NS_ADDREF(*aResult = new nsXULElement(aNodeInfo));
 51393: 
 51393:     return NS_OK;
 51393: }
 51393: 
 51393: void
 94340: NS_TrustedNewXULElement(nsIContent** aResult, already_AddRefed<nsINodeInfo> aNodeInfo)
 51393: {
 51393:     NS_PRECONDITION(aNodeInfo.get(), "need nodeinfo for non-proto Create");
 50997: 
 50997:     // Create an nsXULElement with the specified namespace and tag.
 51393:     NS_ADDREF(*aResult = new nsXULElement(aNodeInfo));
 50986: }
 50986: 
     1: //----------------------------------------------------------------------
     1: // nsISupports interface
     1: 
  1829: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULElement)
  1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXULElement,
 38452:                                                   nsStyledElement)
 62825:     {
 62825:         nsXULSlots* slots = static_cast<nsXULSlots*>(tmp->GetExistingSlots());
 62825:         if (slots) {
 77323:             slots->Traverse(cb);
 62825:         }
 62825:     }
  1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
  1829: 
 38452: NS_IMPL_ADDREF_INHERITED(nsXULElement, nsStyledElement)
 38452: NS_IMPL_RELEASE_INHERITED(nsXULElement, nsStyledElement)
     1: 
 48124: DOMCI_NODE_DATA(XULElement, nsXULElement)
 40490: 
 21218: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsXULElement)
 21218:     NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsXULElement)
 21218:         NS_INTERFACE_TABLE_ENTRY(nsXULElement, nsIDOMNode)
 21218:         NS_INTERFACE_TABLE_ENTRY(nsXULElement, nsIDOMElement)
 21218:         NS_INTERFACE_TABLE_ENTRY(nsXULElement, nsIDOMXULElement)
 21218:     NS_OFFSET_AND_INTERFACE_TABLE_END
 21218:     NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE
 21218:     NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMElementCSSInlineStyle,
 21218:                                    new nsXULElementTearoff(this))
 21218:     NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIFrameLoaderOwner,
 21218:                                    new nsXULElementTearoff(this))
 39587:     NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XULElement)
 21218: NS_ELEMENT_INTERFACE_MAP_END
     1: 
     1: //----------------------------------------------------------------------
     1: // nsIDOMNode interface
     1: 
     1: nsresult
 94340: nsXULElement::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
     1: {
     1:     *aResult = nsnull;
     1: 
 94340:     nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
105643:     nsRefPtr<nsXULElement> element = new nsXULElement(ni.forget());
     1: 
     1:     // XXX TODO: set up RDF generic builder n' stuff if there is a
     1:     // 'datasources' attribute? This is really kind of tricky,
     1:     // because then we'd need to -selectively- copy children that
     1:     // -weren't- generated from RDF. Ugh. Forget it.
     1: 
     1:     // Note that we're _not_ copying mControllers.
     1: 
105646:     PRUint32 count = mAttrsAndChildren.AttrCount();
105646:     nsresult rv = NS_OK;
105646:     for (PRUint32 i = 0; i < count; ++i) {
105646:         const nsAttrName* originalName = mAttrsAndChildren.AttrNameAt(i);
105646:         const nsAttrValue* originalValue = mAttrsAndChildren.AttrAt(i);
105646:         nsAttrValue attrValue;
105646: 
105646:         // Style rules need to be cloned.
105646:         if (originalValue->Type() == nsAttrValue::eCSSStyleRule) {
105646:             nsRefPtr<css::Rule> ruleClone =
105646:                 originalValue->GetCSSStyleRuleValue()->Clone();
105646: 
105646:             nsString stringValue;
105646:             originalValue->ToString(stringValue);
105646: 
105646:             nsRefPtr<css::StyleRule> styleRule = do_QueryObject(ruleClone);
105646:             attrValue.SetTo(styleRule, &stringValue);
105646:         } else {
105646:             attrValue.SetTo(*originalValue);
     1:         }
     1: 
105646:         if (originalName->IsAtom()) {
105646:            rv = element->mAttrsAndChildren.SetAndTakeAttr(originalName->Atom(),
105646:                                                           attrValue);
105646:         } else {
105646:             rv = element->mAttrsAndChildren.SetAndTakeAttr(originalName->NodeInfo(),
105646:                                                            attrValue);
105646:         }
105646:         NS_ENSURE_SUCCESS(rv, rv);
105646:         element->AddListenerFor(*originalName, true);
105908:         if (originalName->Equals(nsGkAtoms::id) &&
105908:             !originalValue->IsEmptyString()) {
105646:             element->SetHasID();
105646:         }
105646:         if (originalName->Equals(nsGkAtoms::_class)) {
105646:             element->SetFlags(NODE_MAY_HAVE_CLASS);
105646:         }
105646:         if (originalName->Equals(nsGkAtoms::style)) {
105646:             element->SetMayHaveStyle();
105646:         }
105646:     }
105646: 
105646:     element.forget(aResult);
     1:     return rv;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::GetElementsByAttribute(const nsAString& aAttribute,
     1:                                      const nsAString& aValue,
     1:                                      nsIDOMNodeList** aReturn)
     1: {
     1:     nsCOMPtr<nsIAtom> attrAtom(do_GetAtom(aAttribute));
     1:     NS_ENSURE_TRUE(attrAtom, NS_ERROR_OUT_OF_MEMORY);
     1:     void* attrValue = new nsString(aValue);
     1:     NS_ENSURE_TRUE(attrValue, NS_ERROR_OUT_OF_MEMORY);
     1:     nsContentList *list = 
     1:         new nsContentList(this,
     1:                           nsXULDocument::MatchAttribute,
     1:                           nsContentUtils::DestroyMatchString,
     1:                           attrValue,
 80486:                           true,
     1:                           attrAtom,
     1:                           kNameSpaceID_Unknown);
     1:     NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:     NS_ADDREF(*aReturn = list);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::GetElementsByAttributeNS(const nsAString& aNamespaceURI,
     1:                                        const nsAString& aAttribute,
     1:                                        const nsAString& aValue,
     1:                                        nsIDOMNodeList** aReturn)
     1: {
     1:     nsCOMPtr<nsIAtom> attrAtom(do_GetAtom(aAttribute));
     1:     NS_ENSURE_TRUE(attrAtom, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:     PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
     1:     if (!aNamespaceURI.EqualsLiteral("*")) {
     1:       nsresult rv =
     1:         nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
     1:                                                               nameSpaceId);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1: 
     1:     void* attrValue = new nsString(aValue);
     1:     NS_ENSURE_TRUE(attrValue, NS_ERROR_OUT_OF_MEMORY);
     1:     
     1:     nsContentList *list = 
     1:         new nsContentList(this,
     1:                           nsXULDocument::MatchAttribute,
     1:                           nsContentUtils::DestroyMatchString,
     1:                           attrValue,
 80486:                           true,
     1:                           attrAtom,
     1:                           nameSpaceId);
     1:     NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:     NS_ADDREF(*aReturn = list);
     1:     return NS_OK;
     1: }
     1: 
 74595: nsEventListenerManager*
 79445: nsXULElement::GetEventListenerManagerForAttr(nsIAtom* aAttrName, bool* aDefer)
     1: {
     1:     // XXXbz sXBL/XBL2 issue: should we instead use GetCurrentDoc()
     1:     // here, override BindToTree for those classes and munge event
     1:     // listeners there?
 80526:     nsIDocument* doc = OwnerDoc();
     1: 
 15042:     nsPIDOMWindow *window;
 41634:     Element *root = doc->GetRootElement();
 15042:     if ((!root || root == this) && !mNodeInfo->Equals(nsGkAtoms::overlay) &&
 15042:         (window = doc->GetInnerWindow()) && window->IsInnerWindow()) {
     1: 
 72326:         nsCOMPtr<nsIDOMEventTarget> piTarget = do_QueryInterface(window);
     1: 
 80486:         *aDefer = false;
 80486:         return piTarget->GetListenerManager(true);
 74595:     }
 74595: 
 79415:     return nsStyledElement::GetEventListenerManagerForAttr(aAttrName, aDefer);
     1: }
     1: 
 41071: // returns true if the element is not a list
 94340: static bool IsNonList(nsINodeInfo* aNodeInfo)
 41071: {
 41071:   return !aNodeInfo->Equals(nsGkAtoms::tree) &&
 41071:          !aNodeInfo->Equals(nsGkAtoms::listbox) &&
 41071:          !aNodeInfo->Equals(nsGkAtoms::richlistbox);
 41071: }
 41071: 
 79445: bool
 79445: nsXULElement::IsFocusable(PRInt32 *aTabIndex, bool aWithMouse)
     1: {
 12728:   /* 
 12728:    * Returns true if an element may be focused, and false otherwise. The inout
 12728:    * argument aTabIndex will be set to the tab order index to be used; -1 for
 12728:    * elements that should not be part of the tab order and a greater value to
 12728:    * indicate its tab order.
 12728:    *
 12728:    * Confusingly, the supplied value for the aTabIndex argument may indicate
 12728:    * whether the element may be focused as a result of the -moz-user-focus
 13629:    * property, where -1 means no and 0 means yes.
 12728:    *
 12728:    * For controls, the element cannot be focused and is not part of the tab
 12728:    * order if it is disabled.
 12728:    *
 12728:    * Controls (those that implement nsIDOMXULControlElement):
 12728:    *  *aTabIndex = -1  no tabindex     Not focusable or tabbable
 12728:    *  *aTabIndex = -1  tabindex="-1"   Not focusable or tabbable
 12728:    *  *aTabIndex = -1  tabindex=">=0"  Focusable and tabbable
 12728:    *  *aTabIndex >= 0  no tabindex     Focusable and tabbable
 12728:    *  *aTabIndex >= 0  tabindex="-1"   Focusable but not tabbable
 12728:    *  *aTabIndex >= 0  tabindex=">=0"  Focusable and tabbable
 12728:    * Non-controls:
 12728:    *  *aTabIndex = -1                  Not focusable or tabbable
 12728:    *  *aTabIndex >= 0                  Focusable and tabbable
 12728:    *
 12728:    * If aTabIndex is null, then the tabindex is not computed, and
 12728:    * true is returned for non-disabled controls and false otherwise.
 12728:    */
 12728: 
 12728:   // elements are not focusable by default
 79445:   bool shouldFocus = false;
 12728: 
 41071: #ifdef XP_MACOSX
 41071:   // on Mac, mouse interactions only focus the element if it's a list
 41071:   if (aWithMouse && IsNonList(mNodeInfo))
 80486:     return false;
 41071: #endif
 41071: 
 77547:   nsCOMPtr<nsIDOMXULControlElement> xulControl = do_QueryObject(this);
     1:   if (xulControl) {
 12728:     // a disabled element cannot be focused and is not part of the tab order
 79445:     bool disabled;
     1:     xulControl->GetDisabled(&disabled);
     1:     if (disabled) {
 12728:       if (aTabIndex)
 12728:         *aTabIndex = -1;
 80486:       return false;
 80486:     }
 80486:     shouldFocus = true;
 12728:   }
 12728: 
 12728:   if (aTabIndex) {
 13629:     if (xulControl) {
 13629:       if (HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
 12728:         // if either the aTabIndex argument or a specified tabindex is non-negative,
 12728:         // the element becomes focusable.
 12728:         PRInt32 tabIndex = 0;
     1:         xulControl->GetTabIndex(&tabIndex);
 12728:         shouldFocus = *aTabIndex >= 0 || tabIndex >= 0;
 12728:         *aTabIndex = tabIndex;
 13629:       }
 13629:       else {
 13629:         // otherwise, if there is no tabindex attribute, just use the value of
 35170:         // *aTabIndex to indicate focusability. Reset any supplied tabindex to 0.
 13629:         shouldFocus = *aTabIndex >= 0;
 35170:         if (shouldFocus)
 35170:           *aTabIndex = 0;
 13629:       }
 12728: 
 12728:       if (shouldFocus && sTabFocusModelAppliesToXUL &&
     1:           !(sTabFocusModel & eTabFocus_formElementsMask)) {
     1:         // By default, the tab focus model doesn't apply to xul element on any system but OS X.
     1:         // on OS X we're following it for UI elements (XUL) as sTabFocusModel is based on
     1:         // "Full Keyboard Access" system setting (see mac/nsILookAndFeel).
     1:         // both textboxes and list elements (i.e. trees and list) should always be focusable
     1:         // (textboxes are handled as html:input)
 13008:         // For compatibility, we only do this for controls, otherwise elements like <browser>
 13008:         // cannot take this focus.
 41071:         if (IsNonList(mNodeInfo))
 12728:           *aTabIndex = -1;
 12728:       }
 12728:     }
 13008:     else {
 13008:       shouldFocus = *aTabIndex >= 0;
 13008:     }
 13008:   }
 12728: 
 12728:   return shouldFocus;
     1: }
     1: 
     1: void
 79445: nsXULElement::PerformAccesskey(bool aKeyCausesActivation,
 79445:                                bool aIsTrustedEvent)
     1: {
     1:     nsCOMPtr<nsIContent> content(this);
     1: 
     1:     if (Tag() == nsGkAtoms::label) {
     1:         nsCOMPtr<nsIDOMElement> element;
     1: 
     1:         nsAutoString control;
     1:         GetAttr(kNameSpaceID_None, nsGkAtoms::control, control);
     1:         if (!control.IsEmpty()) {
     1:             nsCOMPtr<nsIDOMDocument> domDocument =
     1:                 do_QueryInterface(content->GetCurrentDoc());
     1:             if (domDocument)
     1:                 domDocument->GetElementById(control, getter_AddRefs(element));
     1:         }
     1:         // here we'll either change |content| to the element referenced by
     1:         // |element|, or clear it.
     1:         content = do_QueryInterface(element);
     1: 
     1:         if (!content)
     1:             return;
     1:     }
     1: 
 36655:     nsIFrame* frame = content->GetPrimaryFrame();
 80910:     if (!frame || !frame->IsVisibleConsideringAncestors())
     1:         return;
     1: 
 51609:     nsXULElement* elm = FromContent(content);
  7823:     if (elm) {
     1:         // Define behavior for each type of XUL element.
     1:         nsIAtom *tag = content->Tag();
 29018:         if (tag != nsGkAtoms::toolbarbutton) {
 29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29244:           if (fm) {
 29244:             nsCOMPtr<nsIDOMElement> element;
 29244:             // for radio buttons, focus the radiogroup instead
 29244:             if (tag == nsGkAtoms::radio) {
 51609:               nsCOMPtr<nsIDOMXULSelectControlItemElement> controlItem(do_QueryInterface(content));
 29244:               if (controlItem) {
 79445:                 bool disabled;
 29244:                 controlItem->GetDisabled(&disabled);
 29244:                 if (!disabled) {
 29244:                   nsCOMPtr<nsIDOMXULSelectControlElement> selectControl;
 29244:                   controlItem->GetControl(getter_AddRefs(selectControl));
 29244:                   element = do_QueryInterface(selectControl);
 29244:                 }
 29244:               }
 29244:             }
 29244:             else {
 29244:               element = do_QueryInterface(content);
 29244:             }
 29244:             if (element)
 29018:               fm->SetFocus(element, nsIFocusManager::FLAG_BYKEY);
 29018:           }
 29244:         }
 40485:         if (aKeyCausesActivation && tag != nsGkAtoms::textbox && tag != nsGkAtoms::menulist) {
 77227:           elm->ClickWithInputSource(nsIDOMMouseEvent::MOZ_SOURCE_KEYBOARD);
 40485:         }
     1:     }
  7823:     else {
  7823:         content->PerformAccesskey(aKeyCausesActivation, aIsTrustedEvent);
  7823:     }
  7823: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: void
     1: nsXULElement::AddListenerFor(const nsAttrName& aName,
 79445:                              bool aCompileEventHandlers)
     1: {
     1:     // If appropriate, add a popup listener and/or compile the event
     1:     // handler. Called when we change the element's document, create a
     1:     // new element, change an attribute's value, etc.
     1:     // Eventlistenener-attributes are always in the null namespace
     1:     if (aName.IsAtom()) {
     1:         nsIAtom *attr = aName.Atom();
     1:         MaybeAddPopupListener(attr);
   265:         if (aCompileEventHandlers &&
   265:             nsContentUtils::IsEventAttributeName(attr, EventNameType_XUL)) {
     1:             nsAutoString value;
     1:             GetAttr(kNameSpaceID_None, attr, value);
 80486:             AddScriptEventListener(attr, value, true);
     1:         }
     1:     }
     1: }
     1: 
     1: void
     1: nsXULElement::MaybeAddPopupListener(nsIAtom* aLocalName)
     1: {
     1:     // If appropriate, add a popup listener. Called when we change the
     1:     // element's document, create a new element, change an attribute's
     1:     // value, etc.
     1:     if (aLocalName == nsGkAtoms::menu ||
     1:         aLocalName == nsGkAtoms::contextmenu ||
     1:         // XXXdwh popup and context are deprecated
     1:         aLocalName == nsGkAtoms::popup ||
     1:         aLocalName == nsGkAtoms::context) {
     1:         AddPopupListener(aLocalName);
     1:     }
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: //
     1: // nsIContent interface
     1: //
 71121: void
 79445: nsXULElement::UpdateEditableState(bool aNotify)
 71121: {
 71121:     // Don't call through to nsGenericElement here because the things
 71121:     // it does don't work for cases when we're an editable control.
 71121:     nsIContent *parent = GetParent();
 71121: 
 71121:     SetEditableFlag(parent && parent->HasFlag(NODE_IS_EDITABLE));
 71121:     UpdateState(aNotify);
 71121: }
     1: 
 13432: nsresult
 13432: nsXULElement::BindToTree(nsIDocument* aDocument,
 13432:                          nsIContent* aParent,
 13432:                          nsIContent* aBindingParent,
 79445:                          bool aCompileEventHandlers)
 13432: {
 43079:   nsresult rv = nsStyledElement::BindToTree(aDocument, aParent,
 13432:                                             aBindingParent,
 13432:                                             aCompileEventHandlers);
 13432:   NS_ENSURE_SUCCESS(rv, rv);
 13432: 
 13432:   if (aDocument) {
 23256:       NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
 23256:                    "Missing a script blocker!");
 13432:       // We're in a document now.  Kick off the frame load.
 13432:       LoadSrc();
 13432:   }
 13432: 
 13432:   return rv;
 13432: }
 13432: 
     1: void
 79445: nsXULElement::UnbindFromTree(bool aDeep, bool aNullParent)
  1684: {
  1684:     // mControllers can own objects that are implemented
  1684:     // in JavaScript (such as some implementations of
  1684:     // nsIControllers.  These objects prevent their global
  1684:     // object's script object from being garbage collected,
  1684:     // which means JS continues to hold an owning reference
  1684:     // to the nsGlobalWindow, which owns the document,
  1684:     // which owns this content.  That's a cycle, so we break
  1684:     // it here.  (It might be better to break this by releasing
  1684:     // mDocument in nsGlobalWindow::SetDocShell, but I'm not
  1684:     // sure whether that would fix all possible cycles through
  1684:     // mControllers.)
 13432:     nsXULSlots* slots = static_cast<nsXULSlots*>(GetExistingDOMSlots());
  1684:     if (slots) {
  1684:         NS_IF_RELEASE(slots->mControllers);
 13432:         if (slots->mFrameLoader) {
 13432:             // This element is being taken out of the document, destroy the
 13432:             // possible frame loader.
 13432:             // XXXbz we really want to only partially destroy the frame
 13432:             // loader... we don't want to tear down the docshell.  Food for
 13432:             // later bug.
 13432:             slots->mFrameLoader->Destroy();
 13432:             slots->mFrameLoader = nsnull;
 13432:         }
  1684:     }
  1684: 
 38452:     nsStyledElement::UnbindFromTree(aDeep, aNullParent);
  1684: }
  1684: 
 94359: void
 79445: nsXULElement::RemoveChildAt(PRUint32 aIndex, bool aNotify)
     1: {
     1:     nsCOMPtr<nsIContent> oldKid = mAttrsAndChildren.GetSafeChildAt(aIndex);
     1:     if (!oldKid) {
 94359:       return;
     1:     }
     1: 
     1:     // On the removal of a <treeitem>, <treechildren>, or <treecell> element,
     1:     // the possibility exists that some of the items in the removed subtree
     1:     // are selected (and therefore need to be deselected). We need to account for this.
     1:     nsCOMPtr<nsIDOMXULMultiSelectControlElement> controlElement;
     1:     nsCOMPtr<nsIListBoxObject> listBox;
 79445:     bool fireSelectionHandler = false;
     1: 
     1:     // -1 = do nothing, -2 = null out current item
     1:     // anything else = index to re-set as current
     1:     PRInt32 newCurrentIndex = -1;
     1: 
     1:     if (oldKid->NodeInfo()->Equals(nsGkAtoms::listitem, kNameSpaceID_XUL)) {
     1:       // This is the nasty case. We have (potentially) a slew of selected items
     1:       // and cells going away.
     1:       // First, retrieve the tree.
     1:       // Check first whether this element IS the tree
 77547:       controlElement = do_QueryObject(this);
     1: 
     1:       // If it's not, look at our parent
     1:       if (!controlElement)
 94359:         GetParentTree(getter_AddRefs(controlElement));
     1: 
     1:       nsCOMPtr<nsIDOMElement> oldKidElem = do_QueryInterface(oldKid);
     1:       if (controlElement && oldKidElem) {
     1:         // Iterate over all of the items and find out if they are contained inside
     1:         // the removed subtree.
     1:         PRInt32 length;
     1:         controlElement->GetSelectedCount(&length);
     1:         for (PRInt32 i = 0; i < length; i++) {
     1:           nsCOMPtr<nsIDOMXULSelectControlItemElement> node;
     1:           controlElement->GetSelectedItem(i, getter_AddRefs(node));
     1:           // we need to QI here to do an XPCOM-correct pointercompare
     1:           nsCOMPtr<nsIDOMElement> selElem = do_QueryInterface(node);
     1:           if (selElem == oldKidElem &&
     1:               NS_SUCCEEDED(controlElement->RemoveItemFromSelection(node))) {
     1:             length--;
     1:             i--;
 80486:             fireSelectionHandler = true;
     1:           }
     1:         }
     1: 
     1:         nsCOMPtr<nsIDOMXULSelectControlItemElement> curItem;
     1:         controlElement->GetCurrentItem(getter_AddRefs(curItem));
     1:         nsCOMPtr<nsIContent> curNode = do_QueryInterface(curItem);
     1:         if (curNode && nsContentUtils::ContentIsDescendantOf(curNode, oldKid)) {
     1:             // Current item going away
     1:             nsCOMPtr<nsIBoxObject> box;
     1:             controlElement->GetBoxObject(getter_AddRefs(box));
     1:             listBox = do_QueryInterface(box);
     1:             if (listBox && oldKidElem) {
     1:               listBox->GetIndexOfItem(oldKidElem, &newCurrentIndex);
     1:             }
     1: 
     1:             // If any of this fails, we'll just set the current item to null
     1:             if (newCurrentIndex == -1)
     1:               newCurrentIndex = -2;
     1:         }
     1:       }
     1:     }
     1: 
 94359:     nsStyledElement::RemoveChildAt(aIndex, aNotify);
     1:     
     1:     if (newCurrentIndex == -2)
     1:         controlElement->SetCurrentItem(nsnull);
     1:     else if (newCurrentIndex > -1) {
     1:         // Make sure the index is still valid
     1:         PRInt32 treeRows;
     1:         listBox->GetRowCount(&treeRows);
     1:         if (treeRows > 0) {
 71173:             newCurrentIndex = NS_MIN((treeRows - 1), newCurrentIndex);
     1:             nsCOMPtr<nsIDOMElement> newCurrentItem;
     1:             listBox->GetItemAtIndex(newCurrentIndex, getter_AddRefs(newCurrentItem));
     1:             nsCOMPtr<nsIDOMXULSelectControlItemElement> xulCurItem = do_QueryInterface(newCurrentItem);
     1:             if (xulCurItem)
     1:                 controlElement->SetCurrentItem(xulCurItem);
     1:         } else {
     1:             controlElement->SetCurrentItem(nsnull);
     1:         }
     1:     }
     1: 
     1:     nsIDocument* doc;
     1:     if (fireSelectionHandler && (doc = GetCurrentDoc())) {
     1:       nsContentUtils::DispatchTrustedEvent(doc,
  3233:                                            static_cast<nsIContent*>(this),
     1:                                            NS_LITERAL_STRING("select"),
 80486:                                            false,
 80486:                                            true);
     1:     }
     1: }
     1: 
     1: void
     1: nsXULElement::UnregisterAccessKey(const nsAString& aOldValue)
     1: {
     1:     // If someone changes the accesskey, unregister the old one
     1:     //
     1:     nsIDocument* doc = GetCurrentDoc();
     1:     if (doc && !aOldValue.IsEmpty()) {
 46225:         nsIPresShell *shell = doc->GetShell();
     1: 
     1:         if (shell) {
     1:             nsIContent *content = this;
     1: 
     1:             // find out what type of content node this is
     1:             if (mNodeInfo->Equals(nsGkAtoms::label)) {
     1:                 // For anonymous labels the unregistering must
     1:                 // occur on the binding parent control.
 16126:                 // XXXldb: And what if the binding parent is null?
     1:                 content = GetBindingParent();
     1:             }
     1: 
     1:             if (content) {
     1:                 shell->GetPresContext()->EventStateManager()->
     1:                     UnregisterAccessKey(content, aOldValue.First());
     1:             }
     1:         }
     1:     }
     1: }
     1: 
     1: nsresult
     1: nsXULElement::BeforeSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
 90060:                             const nsAttrValueOrString* aValue, bool aNotify)
     1: {
     1:     if (aNamespaceID == kNameSpaceID_None && aName == nsGkAtoms::accesskey &&
     1:         IsInDoc()) {
     1:         nsAutoString oldValue;
105643:         if (GetAttr(aNamespaceID, aName, oldValue)) {
     1:             UnregisterAccessKey(oldValue);
     1:         }
     1:     } 
 10912:     else if (aNamespaceID == kNameSpaceID_None && (aName ==
 10912:              nsGkAtoms::command || aName == nsGkAtoms::observes) && IsInDoc()) {
 10912: //         XXX sXBL/XBL2 issue! Owner or current document?
 10912:         nsAutoString oldValue;
 10912:         GetAttr(kNameSpaceID_None, nsGkAtoms::observes, oldValue);
 10912:         if (oldValue.IsEmpty()) {
 10912:           GetAttr(kNameSpaceID_None, nsGkAtoms::command, oldValue);
 10912:         }
 10912: 
 10912:         if (!oldValue.IsEmpty()) {
 10912:           RemoveBroadcaster(oldValue);
 10912:         }
 10912:     }
 46199:     else if (aNamespaceID == kNameSpaceID_None &&
 46199:              aValue &&
 46199:              mNodeInfo->Equals(nsGkAtoms::window) &&
 46199:              aName == nsGkAtoms::chromemargin) {
 46199:       nsAttrValue attrValue;
 46199:       // Make sure the margin format is valid first
 90060:       if (!attrValue.ParseIntMarginValue(aValue->String())) {
 46199:         return NS_ERROR_INVALID_ARG;
 46199:       }
 46199:     }
     1: 
 38452:     return nsStyledElement::BeforeSetAttr(aNamespaceID, aName,
     1:                                           aValue, aNotify);
     1: }
     1: 
     1: nsresult
     1: nsXULElement::AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
 90061:                            const nsAttrValue* aValue, bool aNotify)
     1: {
     1:     if (aNamespaceID == kNameSpaceID_None) {
105644:         if (aValue) {
     1:             // Add popup and event listeners. We can't call AddListenerFor since
     1:             // the attribute isn't set yet.
     1:             MaybeAddPopupListener(aName);
105644:             if (nsContentUtils::IsEventAttributeName(aName, EventNameType_XUL)) {
 90061:                 if (aValue->Type() == nsAttrValue::eString) {
 94840:                     AddScriptEventListener(aName, aValue->GetStringValue(), true);
 90061:                 } else {
 90061:                     nsAutoString body;
 90061:                     aValue->ToString(body);
 94840:                     AddScriptEventListener(aName, body, true);
 90061:                 }
     1:             }
     1:     
     1:             // Hide chrome if needed
105644:             if (mNodeInfo->Equals(nsGkAtoms::window)) {
 46199:                 if (aName == nsGkAtoms::hidechrome) {
 90061:                     HideWindowChrome(
 90061:                       aValue->Equals(NS_LITERAL_STRING("true"), eCaseMatters));
 34053:                 }
 46199:                 else if (aName == nsGkAtoms::chromemargin) {
 46199:                     SetChromeMargins(aValue);
 46199:                 }
 46199:             }
 34053:     
 34053:             // title, (in)activetitlebarcolor and drawintitlebar are settable on
 34053:             // any root node (windows, dialogs, etc)
 16977:             nsIDocument *document = GetCurrentDoc();
 41634:             if (document && document->GetRootElement() == this) {
 34053:                 if (aName == nsGkAtoms::title) {
 80486:                     document->NotifyPossibleTitleChange(false);
 16977:                 }
 34053:                 else if ((aName == nsGkAtoms::activetitlebarcolor ||
105644:                           aName == nsGkAtoms::inactivetitlebarcolor)) {
  7242:                     nscolor color = NS_RGBA(0, 0, 0, 0);
 90061:                     if (aValue->Type() == nsAttrValue::eColor) {
 90061:                         aValue->GetColorValue(color);
 90061:                     } else {
 90061:                         nsAutoString tmp;
  7242:                         nsAttrValue attrValue;
 90061:                         aValue->ToString(tmp);
 90061:                         attrValue.ParseColor(tmp);
  7242:                         attrValue.GetColorValue(color);
 90061:                     }
 14886:                     SetTitlebarColor(color, aName == nsGkAtoms::activetitlebarcolor);
  7242:                 }
 34053:                 else if (aName == nsGkAtoms::drawintitlebar) {
105644:                     SetDrawsInTitlebar(
 90061:                         aValue->Equals(NS_LITERAL_STRING("true"), eCaseMatters));
 34053:                 }
 34053:                 else if (aName == nsGkAtoms::localedir) {
 30836:                     // if the localedir changed on the root element, reset the document direction
 30836:                     nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(document);
 30836:                     if (xuldoc) {
 30836:                         xuldoc->ResetDocumentDirection();
 30836:                     }
 30836:                 }
 34053:                 else if (aName == nsGkAtoms::lwtheme ||
 34053:                          aName == nsGkAtoms::lwthemetextcolor) {
 33380:                     // if the lwtheme changed, make sure to reset the document lwtheme cache
 33380:                     nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(document);
 33380:                     if (xuldoc) {
 33380:                         xuldoc->ResetDocumentLWTheme();
 33380:                     }
 33380:                 }
 34053:             }
 33380:     
 13432:             if (aName == nsGkAtoms::src && document) {
 13432:                 LoadSrc();
 13432:             }
105644:         } else  {
105644:             if (mNodeInfo->Equals(nsGkAtoms::window)) {
105644:                 if (aName == nsGkAtoms::hidechrome) {
105644:                     HideWindowChrome(false);
105644:                 }
105644:                 else if (aName == nsGkAtoms::chromemargin) {
105644:                     ResetChromeMargins();
105644:                 }
105644:             }
105644:     
105644:             nsIDocument* doc = GetCurrentDoc();
105644:             if (doc && doc->GetRootElement() == this) {
105644:                 if ((aName == nsGkAtoms::activetitlebarcolor ||
105644:                      aName == nsGkAtoms::inactivetitlebarcolor)) {
105644:                     // Use 0, 0, 0, 0 as the "none" color.
105644:                     SetTitlebarColor(NS_RGBA(0, 0, 0, 0), aName == nsGkAtoms::activetitlebarcolor);
105644:                 }
105644:                 else if (aName == nsGkAtoms::localedir) {
105644:                     // if the localedir changed on the root element, reset the document direction
105644:                     nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(doc);
105644:                     if (xuldoc) {
105644:                         xuldoc->ResetDocumentDirection();
105644:                     }
105644:                 }
105644:                 else if ((aName == nsGkAtoms::lwtheme ||
105644:                           aName == nsGkAtoms::lwthemetextcolor)) {
105644:                     // if the lwtheme changed, make sure to restyle appropriately
105644:                     nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(doc);
105644:                     if (xuldoc) {
105644:                         xuldoc->ResetDocumentLWTheme();
105644:                     }
105644:                 }
105644:                 else if (aName == nsGkAtoms::drawintitlebar) {
105644:                     SetDrawsInTitlebar(false);
105644:                 }
105644:             }
105644:         }
 13432: 
     1:         // XXX need to check if they're changing an event handler: if
     1:         // so, then we need to unhook the old one.  Or something.
     1:     }
     1: 
 38452:     return nsStyledElement::AfterSetAttr(aNamespaceID, aName,
     1:                                          aValue, aNotify);
     1: }
     1: 
 79445: bool
     1: nsXULElement::ParseAttribute(PRInt32 aNamespaceID,
     1:                              nsIAtom* aAttribute,
     1:                              const nsAString& aValue,
     1:                              nsAttrValue& aResult)
     1: {
     1:     // Parse into a nsAttrValue
 38452:     if (!nsStyledElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
     1:                                          aResult)) {
     1:         // Fall back to parsing as atom for short values
     1:         aResult.ParseStringOrAtom(aValue);
     1:     }
     1: 
 80486:     return true;
     1: }
     1: 
 10912: void
 10912: nsXULElement::RemoveBroadcaster(const nsAString & broadcasterId)
 10912: {
 80526:     nsCOMPtr<nsIDOMXULDocument> xuldoc = do_QueryInterface(OwnerDoc());
 10912:     if (xuldoc) {
 10912:         nsCOMPtr<nsIDOMElement> broadcaster;
 10912:         nsCOMPtr<nsIDOMDocument> domDoc (do_QueryInterface(xuldoc));
 10912:         domDoc->GetElementById(broadcasterId, getter_AddRefs(broadcaster));
 10912:         if (broadcaster) {
 10912:             xuldoc->RemoveBroadcastListenerFor(broadcaster, this,
 10912:               NS_LITERAL_STRING("*"));
 10912:         }
 10912:     }
 10912: }
 10912: 
  8462: void
  8462: nsXULElement::DestroyContent()
  8462: {
 13432:     nsXULSlots* slots = static_cast<nsXULSlots*>(GetExistingDOMSlots());
  8462:     if (slots) {
  8462:         NS_IF_RELEASE(slots->mControllers);
 13432:         if (slots->mFrameLoader) {
 13432:             slots->mFrameLoader->Destroy();
 13432:             slots->mFrameLoader = nsnull;
 13432:         }
  8462:     }
  8462: 
 38452:     nsStyledElement::DestroyContent();
  8462: }
     1: 
     1: #ifdef DEBUG
     1: void
     1: nsXULElement::List(FILE* out, PRInt32 aIndent) const
     1: {
 31437:     nsCString prefix("XUL");
     1:     if (HasSlots()) {
     1:       prefix.Append('*');
     1:     }
     1:     prefix.Append(' ');
     1: 
 38452:     nsStyledElement::List(out, aIndent, prefix);
     1: }
     1: #endif
     1: 
     1: nsresult
     1: nsXULElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
     1: {
 80486:     aVisitor.mForceContentDispatch = true; //FIXME! Bug 329119
     1:     nsIAtom* tag = Tag();
 29471:     if (IsRootOfNativeAnonymousSubtree() &&
 29471:         (tag == nsGkAtoms::scrollbar || tag == nsGkAtoms::scrollcorner) &&
 29471:         (aVisitor.mEvent->message == NS_MOUSE_CLICK ||
 29471:          aVisitor.mEvent->message == NS_MOUSE_DOUBLECLICK ||
 29471:          aVisitor.mEvent->message == NS_XUL_COMMAND ||
 31035:          aVisitor.mEvent->message == NS_CONTEXTMENU ||
 31035:          aVisitor.mEvent->message == NS_DRAGDROP_START ||
 31035:          aVisitor.mEvent->message == NS_DRAGDROP_GESTURE)) {
 29471:         // Don't propagate these events from native anonymous scrollbar.
 80486:         aVisitor.mCanHandle = true;
 29471:         aVisitor.mParentTarget = nsnull;
 29471:         return NS_OK;
 29471:     }
     1:     if (aVisitor.mEvent->message == NS_XUL_COMMAND &&
 29844:         aVisitor.mEvent->eventStructType == NS_INPUT_EVENT &&
  3233:         aVisitor.mEvent->originalTarget == static_cast<nsIContent*>(this) &&
     1:         tag != nsGkAtoms::command) {
 29844:         // Check that we really have an xul command event. That will be handled
 29844:         // in a special way.
 29844:         nsCOMPtr<nsIDOMXULCommandEvent> xulEvent =
 29844:             do_QueryInterface(aVisitor.mDOMEvent);
     1:         // See if we have a command elt.  If so, we execute on the command
     1:         // instead of on our content element.
     1:         nsAutoString command;
 29844:         if (xulEvent && GetAttr(kNameSpaceID_None, nsGkAtoms::command, command) &&
 29844:             !command.IsEmpty()) {
     1:             // Stop building the event target chain for the original event.
     1:             // We don't want it to propagate to any DOM nodes.
 80486:             aVisitor.mCanHandle = false;
     1: 
     1:             // XXX sXBL/XBL2 issue! Owner or current document?
     1:             nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(GetCurrentDoc()));
     1:             NS_ENSURE_STATE(domDoc);
     1:             nsCOMPtr<nsIDOMElement> commandElt;
     1:             domDoc->GetElementById(command, getter_AddRefs(commandElt));
     1:             nsCOMPtr<nsIContent> commandContent(do_QueryInterface(commandElt));
     1:             if (commandContent) {
     1:                 // Create a new command event to dispatch to the element
     1:                 // pointed to by the command attribute.  The new event's
     1:                 // sourceEvent will be the original command event that we're
     1:                 // handling.
 15254:                 nsCOMPtr<nsIDOMNSEvent> nsevent =
 15254:                     do_QueryInterface(aVisitor.mDOMEvent);
 15254:                 while (nsevent) {
 15254:                     nsCOMPtr<nsIDOMEventTarget> oTarget;
 15254:                     nsevent->GetOriginalTarget(getter_AddRefs(oTarget));
 15254:                     NS_ENSURE_STATE(!SameCOMIdentity(oTarget, commandContent));
 15254:                     nsCOMPtr<nsIDOMEvent> tmp;
 15254:                     nsCOMPtr<nsIDOMXULCommandEvent> commandEvent =
 15254:                         do_QueryInterface(nsevent);
 15254:                     if (commandEvent) {
 15254:                         commandEvent->GetSourceEvent(getter_AddRefs(tmp));
 15254:                     }
 15254:                     nsevent = do_QueryInterface(tmp);
 15254:                 }
 15254: 
 29844:                 nsInputEvent* orig =
 29844:                     static_cast<nsInputEvent*>(aVisitor.mEvent);
 29844:                 nsContentUtils::DispatchXULCommand(
 29844:                   commandContent,
 29844:                   NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
 29844:                   aVisitor.mDOMEvent,
 29844:                   nsnull,
 96893:                   orig->IsControl(),
 96893:                   orig->IsAlt(),
 96893:                   orig->IsShift(),
 96893:                   orig->IsMeta());
     1:             } else {
     1:                 NS_WARNING("A XUL element is attached to a command that doesn't exist!\n");
     1:             }
     1:             return NS_OK;
     1:         }
     1:     }
     1: 
 38452:     return nsStyledElement::PreHandleEvent(aVisitor);
     1: }
     1: 
     1: // XXX This _should_ be an implementation method, _not_ publicly exposed :-(
     1: NS_IMETHODIMP
     1: nsXULElement::GetResource(nsIRDFResource** aResource)
     1: {
     1:     nsAutoString id;
     1:     GetAttr(kNameSpaceID_None, nsGkAtoms::ref, id);
     1:     if (id.IsEmpty()) {
     1:         GetAttr(kNameSpaceID_None, nsGkAtoms::id, id);
     1:     }
     1: 
     1:     if (!id.IsEmpty()) {
     1:         return nsXULContentUtils::RDFService()->
     1:             GetUnicodeResource(id, aResource);
     1:     }
     1:     *aResource = nsnull;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::GetDatabase(nsIRDFCompositeDataSource** aDatabase)
     1: {
     1:     nsCOMPtr<nsIXULTemplateBuilder> builder;
     1:     GetBuilder(getter_AddRefs(builder));
     1: 
     1:     if (builder)
     1:         builder->GetDatabase(aDatabase);
     1:     else
     1:         *aDatabase = nsnull;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::GetBuilder(nsIXULTemplateBuilder** aBuilder)
     1: {
     1:     *aBuilder = nsnull;
     1: 
     1:     // XXX sXBL/XBL2 issue! Owner or current document?
     1:     nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(GetCurrentDoc());
     1:     if (xuldoc)
     1:         xuldoc->GetTemplateBuilderFor(this, aBuilder);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: //----------------------------------------------------------------------
     1: // Implementation methods
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
     1: {
     1:     return NS_OK;
     1: }
     1: 
     1: nsChangeHint
     1: nsXULElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
     1:                                      PRInt32 aModType) const
     1: {
     1:     nsChangeHint retval(NS_STYLE_HINT_NONE);
     1: 
     1:     if (aAttribute == nsGkAtoms::value &&
     1:         (aModType == nsIDOMMutationEvent::REMOVAL ||
     1:          aModType == nsIDOMMutationEvent::ADDITION)) {
     1:       nsIAtom *tag = Tag();
     1:       if (tag == nsGkAtoms::label || tag == nsGkAtoms::description)
     1:         // Label and description dynamically morph between a normal
     1:         // block and a cropping single-line XUL text frame.  If the
     1:         // value attribute is being added or removed, then we need to
     1:         // return a hint of frame change.  (See bugzilla bug 95475 for
     1:         // details.)
     1:         retval = NS_STYLE_HINT_FRAMECHANGE;
     1:     } else {
     1:         // if left or top changes we reflow. This will happen in xul
 30836:         // containers that manage positioned children such as a stack.
 32443:         if (nsGkAtoms::left == aAttribute || nsGkAtoms::top == aAttribute ||
 63170:             nsGkAtoms::right == aAttribute || nsGkAtoms::bottom == aAttribute ||
 63170:             nsGkAtoms::start == aAttribute || nsGkAtoms::end == aAttribute)
     1:             retval = NS_STYLE_HINT_REFLOW;
     1:     }
     1: 
     1:     return retval;
     1: }
     1: 
 79445: NS_IMETHODIMP_(bool)
     1: nsXULElement::IsAttributeMapped(const nsIAtom* aAttribute) const
     1: {
 80486:     return false;
     1: }
     1: 
     1: // Controllers Methods
     1: NS_IMETHODIMP
     1: nsXULElement::GetControllers(nsIControllers** aResult)
     1: {
     1:     if (! Controllers()) {
 59659:         nsDOMSlots* slots = DOMSlots();
     1: 
     1:         nsresult rv;
     1:         rv = NS_NewXULControllers(nsnull, NS_GET_IID(nsIControllers),
  3233:                                   reinterpret_cast<void**>(&slots->mControllers));
     1: 
     1:         NS_ASSERTION(NS_SUCCEEDED(rv), "unable to create a controllers");
     1:         if (NS_FAILED(rv)) return rv;
     1:     }
     1: 
     1:     *aResult = Controllers();
     1:     NS_IF_ADDREF(*aResult);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::GetBoxObject(nsIBoxObject** aResult)
     1: {
     1:   *aResult = nsnull;
     1: 
     1:   // XXX sXBL/XBL2 issue! Owner or current document?
 80527:   return OwnerDoc()->GetBoxObjectFor(this, aResult);
     1: }
     1: 
     1: // Methods for setting/getting attributes from nsIDOMXULElement
     1: #define NS_IMPL_XUL_STRING_ATTR(_method, _atom)                     \
     1:   NS_IMETHODIMP                                                     \
     1:   nsXULElement::Get##_method(nsAString& aReturn)                    \
     1:   {                                                                 \
     1:     GetAttr(kNameSpaceID_None, nsGkAtoms::_atom, aReturn);         \
     1:     return NS_OK;                                                   \
     1:   }                                                                 \
     1:   NS_IMETHODIMP                                                     \
     1:   nsXULElement::Set##_method(const nsAString& aValue)               \
     1:   {                                                                 \
     1:     return SetAttr(kNameSpaceID_None, nsGkAtoms::_atom, aValue,    \
 80486:                    true);                                        \
     1:   }
     1: 
     1: #define NS_IMPL_XUL_BOOL_ATTR(_method, _atom)                       \
     1:   NS_IMETHODIMP                                                     \
 79445:   nsXULElement::Get##_method(bool* aResult)                       \
     1:   {                                                                 \
     1:     *aResult = BoolAttrIsTrue(nsGkAtoms::_atom);                   \
     1:                                                                     \
     1:     return NS_OK;                                                   \
     1:   }                                                                 \
     1:   NS_IMETHODIMP                                                     \
 79445:   nsXULElement::Set##_method(bool aValue)                         \
     1:   {                                                                 \
     1:     if (aValue)                                                     \
     1:       SetAttr(kNameSpaceID_None, nsGkAtoms::_atom,                 \
 80486:               NS_LITERAL_STRING("true"), true);                  \
     1:     else                                                            \
 80486:       UnsetAttr(kNameSpaceID_None, nsGkAtoms::_atom, true);     \
     1:                                                                     \
     1:     return NS_OK;                                                   \
     1:   }
     1: 
     1: 
     1: NS_IMPL_XUL_STRING_ATTR(Id, id)
     1: NS_IMPL_XUL_STRING_ATTR(ClassName, _class)
     1: NS_IMPL_XUL_STRING_ATTR(Align, align)
     1: NS_IMPL_XUL_STRING_ATTR(Dir, dir)
     1: NS_IMPL_XUL_STRING_ATTR(Flex, flex)
     1: NS_IMPL_XUL_STRING_ATTR(FlexGroup, flexgroup)
     1: NS_IMPL_XUL_STRING_ATTR(Ordinal, ordinal)
     1: NS_IMPL_XUL_STRING_ATTR(Orient, orient)
     1: NS_IMPL_XUL_STRING_ATTR(Pack, pack)
     1: NS_IMPL_XUL_BOOL_ATTR(Hidden, hidden)
     1: NS_IMPL_XUL_BOOL_ATTR(Collapsed, collapsed)
     1: NS_IMPL_XUL_BOOL_ATTR(AllowEvents, allowevents)
     1: NS_IMPL_XUL_STRING_ATTR(Observes, observes)
     1: NS_IMPL_XUL_STRING_ATTR(Menu, menu)
     1: NS_IMPL_XUL_STRING_ATTR(ContextMenu, contextmenu)
     1: NS_IMPL_XUL_STRING_ATTR(Tooltip, tooltip)
     1: NS_IMPL_XUL_STRING_ATTR(Width, width)
     1: NS_IMPL_XUL_STRING_ATTR(Height, height)
     1: NS_IMPL_XUL_STRING_ATTR(MinWidth, minwidth)
     1: NS_IMPL_XUL_STRING_ATTR(MinHeight, minheight)
     1: NS_IMPL_XUL_STRING_ATTR(MaxWidth, maxwidth)
     1: NS_IMPL_XUL_STRING_ATTR(MaxHeight, maxheight)
     1: NS_IMPL_XUL_STRING_ATTR(Persist, persist)
     1: NS_IMPL_XUL_STRING_ATTR(Left, left)
     1: NS_IMPL_XUL_STRING_ATTR(Top, top)
     1: NS_IMPL_XUL_STRING_ATTR(Datasources, datasources)
     1: NS_IMPL_XUL_STRING_ATTR(Ref, ref)
     1: NS_IMPL_XUL_STRING_ATTR(TooltipText, tooltiptext)
     1: NS_IMPL_XUL_STRING_ATTR(StatusText, statustext)
     1: 
     1: nsresult
 13432: nsXULElement::LoadSrc()
 13432: {
 13432:     // Allow frame loader only on objects for which a container box object
 13432:     // can be obtained.
 13432:     nsIAtom* tag = Tag();
 13432:     if (tag != nsGkAtoms::browser &&
 13432:         tag != nsGkAtoms::editor &&
 13432:         tag != nsGkAtoms::iframe) {
 13432:         return NS_OK;
 13432:     }
 13432:     if (!IsInDoc() ||
 80526:         !OwnerDoc()->GetRootElement() ||
 80526:         OwnerDoc()->GetRootElement()->
 13432:             NodeInfo()->Equals(nsGkAtoms::overlay, kNameSpaceID_XUL)) {
 13432:         return NS_OK;
 13432:     }
 13432:     nsXULSlots* slots = static_cast<nsXULSlots*>(GetSlots());
 13432:     NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
 13432:     if (!slots->mFrameLoader) {
 80486:         // false as the last parameter so that xul:iframe/browser/editor
 50721:         // session history handling works like dynamic html:iframes.
 50721:         // Usually xul elements are used in chrome, which doesn't have
 50721:         // session history at all.
 80486:         slots->mFrameLoader = nsFrameLoader::Create(this, false);
 31661:         NS_ENSURE_TRUE(slots->mFrameLoader, NS_OK);
 13432:     }
 13432: 
 13432:     return slots->mFrameLoader->LoadFrame();
 13432: }
 13432: 
 13432: nsresult
 13432: nsXULElement::GetFrameLoader(nsIFrameLoader **aFrameLoader)
 13432: {
 34076:     *aFrameLoader = GetFrameLoader().get();
 34076:     return NS_OK;
 34076: }
 34076: 
 34076: already_AddRefed<nsFrameLoader>
 34076: nsXULElement::GetFrameLoader()
 34076: {
 13432:     nsXULSlots* slots = static_cast<nsXULSlots*>(GetExistingSlots());
 34076:     if (!slots)
 34076:         return nsnull;
 34076: 
 34076:     nsFrameLoader* loader = slots->mFrameLoader;
 34076:     NS_IF_ADDREF(loader);
 34076:     return loader;
 13432: }
 13432: 
 16549: nsresult
 16549: nsXULElement::SwapFrameLoaders(nsIFrameLoaderOwner* aOtherOwner)
 16549: {
 16549:     nsCOMPtr<nsIContent> otherContent(do_QueryInterface(aOtherOwner));
 16549:     NS_ENSURE_TRUE(otherContent, NS_ERROR_NOT_IMPLEMENTED);
 16549: 
 16549:     nsXULElement* otherEl = FromContent(otherContent);
 16549:     NS_ENSURE_TRUE(otherEl, NS_ERROR_NOT_IMPLEMENTED);
 16549: 
 16549:     if (otherEl == this) {
 16549:         // nothing to do
 16549:         return NS_OK;
 16549:     }
 16549: 
 16549:     nsXULSlots *ourSlots = static_cast<nsXULSlots*>(GetExistingDOMSlots());
 16549:     nsXULSlots *otherSlots =
 16549:         static_cast<nsXULSlots*>(otherEl->GetExistingDOMSlots());
 16549:     if (!ourSlots || !ourSlots->mFrameLoader ||
 16549:         !otherSlots || !otherSlots->mFrameLoader) {
 16549:         // Can't handle swapping when there is nothing to swap... yet.
 16549:         return NS_ERROR_NOT_IMPLEMENTED;
 16549:     }
 16549: 
 16549:     return
 16549:         ourSlots->mFrameLoader->SwapWithOtherLoader(otherSlots->mFrameLoader,
 16549:                                                     ourSlots->mFrameLoader,
 16549:                                                     otherSlots->mFrameLoader);
 16549: }
 16549: 
     1: NS_IMETHODIMP
     1: nsXULElement::GetParentTree(nsIDOMXULMultiSelectControlElement** aTreeElement)
     1: {
     1:     for (nsIContent* current = GetParent(); current;
     1:          current = current->GetParent()) {
     1:         if (current->NodeInfo()->Equals(nsGkAtoms::listbox,
     1:                                         kNameSpaceID_XUL)) {
     1:             CallQueryInterface(current, aTreeElement);
     1:             // XXX returning NS_OK because that's what the code used to do;
     1:             // is that the right thing, though?
     1: 
     1:             return NS_OK;
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::Focus()
     1: {
 29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 77547:     nsCOMPtr<nsIDOMElement> elem = do_QueryObject(this);
 29018:     return fm ? fm->SetFocus(this, 0) : NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::Blur()
     1: {
 29018:     if (!ShouldBlur(this))
 29018:       return NS_OK;
 29018: 
     1:     nsIDocument* doc = GetCurrentDoc();
     1:     if (!doc)
     1:       return NS_OK;
     1: 
 29018:     nsIDOMWindow* win = doc->GetWindow();
 29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:     if (win && fm)
 29018:       return fm->ClearFocus(win);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::Click()
     1: {
 77227:   return ClickWithInputSource(nsIDOMMouseEvent::MOZ_SOURCE_UNKNOWN);
 40485: }
 40485: 
 40485: nsresult
 40485: nsXULElement::ClickWithInputSource(PRUint16 aInputSource)
 40485: {
     1:     if (BoolAttrIsTrue(nsGkAtoms::disabled))
     1:         return NS_OK;
     1: 
     1:     nsCOMPtr<nsIDocument> doc = GetCurrentDoc(); // Strong just in case
     1:     if (doc) {
 46225:         nsCOMPtr<nsIPresShell> shell = doc->GetShell();
 36917:         if (shell) {
     1:             // strong ref to PresContext so events don't destroy it
 39823:             nsRefPtr<nsPresContext> context = shell->GetPresContext();
     1: 
 79445:             bool isCallerChrome = nsContentUtils::IsCallerChrome();
     1: 
     1:             nsMouseEvent eventDown(isCallerChrome, NS_MOUSE_BUTTON_DOWN,
     1:                                    nsnull, nsMouseEvent::eReal);
     1:             nsMouseEvent eventUp(isCallerChrome, NS_MOUSE_BUTTON_UP,
     1:                                  nsnull, nsMouseEvent::eReal);
     1:             nsMouseEvent eventClick(isCallerChrome, NS_MOUSE_CLICK, nsnull,
     1:                                     nsMouseEvent::eReal);
 40485:             eventDown.inputSource = eventUp.inputSource = eventClick.inputSource 
 40485:                                   = aInputSource;
     1: 
     1:             // send mouse down
     1:             nsEventStatus status = nsEventStatus_eIgnore;
  3233:             nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this),
     1:                                         context, &eventDown,  nsnull, &status);
     1: 
     1:             // send mouse up
     1:             status = nsEventStatus_eIgnore;  // reset status
  3233:             nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this),
     1:                                         context, &eventUp, nsnull, &status);
     1: 
     1:             // send mouse click
     1:             status = nsEventStatus_eIgnore;  // reset status
  3233:             nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this),
     1:                                         context, &eventClick, nsnull, &status);
     1:         }
     1:     }
     1: 
     1:     // oncommand is fired when an element is clicked...
     1:     return DoCommand();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXULElement::DoCommand()
     1: {
     1:     nsCOMPtr<nsIDocument> doc = GetCurrentDoc(); // strong just in case
     1:     if (doc) {
 80486:         nsContentUtils::DispatchXULCommand(this, true);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsIContent *
     1: nsXULElement::GetBindingParent() const
     1: {
     1:     return mBindingParent;
     1: }
     1: 
 79445: bool
     1: nsXULElement::IsNodeOfType(PRUint32 aFlags) const
     1: {
 41646:     return !(aFlags & ~eCONTENT);
     1: }
     1: 
     1: static void
     1: PopupListenerPropertyDtor(void* aObject, nsIAtom* aPropertyName,
     1:                           void* aPropertyValue, void* aData)
     1: {
  3129:   nsIDOMEventListener* listener =
  3233:     static_cast<nsIDOMEventListener*>(aPropertyValue);
     1:   if (!listener) {
     1:     return;
     1:   }
 72330:   nsEventListenerManager* manager = static_cast<nsINode*>(aObject)->
 80486:     GetListenerManager(false);
 72330:   if (manager) {
 72330:     manager->RemoveEventListenerByType(listener,
 72330:                                        NS_LITERAL_STRING("mousedown"),
 72330:                                        NS_EVENT_FLAG_BUBBLE |
 72331:                                        NS_EVENT_FLAG_SYSTEM_EVENT);
 72330:     manager->RemoveEventListenerByType(listener,
 72330:                                        NS_LITERAL_STRING("contextmenu"),
 72330:                                        NS_EVENT_FLAG_BUBBLE |
 72331:                                        NS_EVENT_FLAG_SYSTEM_EVENT);
     1:   }
     1:   NS_RELEASE(listener);
     1: }
     1: 
     1: nsresult
     1: nsXULElement::AddPopupListener(nsIAtom* aName)
     1: {
  3129:     // Add a popup listener to the element
 79445:     bool isContext = (aName == nsGkAtoms::context ||
  3129:                         aName == nsGkAtoms::contextmenu);
  3129:     nsIAtom* listenerAtom = isContext ?
  3129:                             nsGkAtoms::contextmenulistener :
  3129:                             nsGkAtoms::popuplistener;
  3129: 
  3129:     nsCOMPtr<nsIDOMEventListener> popupListener =
  3233:         static_cast<nsIDOMEventListener*>(GetProperty(listenerAtom));
     1:     if (popupListener) {
     1:         // Popup listener is already installed.
     1:         return NS_OK;
     1:     }
  3129: 
 72600:     popupListener = new nsXULPopupListener(this, isContext);
     1: 
     1:     // Add the popup as a listener on this element.
 80486:     nsEventListenerManager* manager = GetListenerManager(true);
 72330:     NS_ENSURE_TRUE(manager, NS_ERROR_FAILURE);
 72600:     nsresult rv = SetProperty(listenerAtom, popupListener,
 80486:                               PopupListenerPropertyDtor, true);
     1:     NS_ENSURE_SUCCESS(rv, rv);
  3129:     // Want the property to have a reference to the listener.
  3129:     nsIDOMEventListener* listener = nsnull;
  3129:     popupListener.swap(listener);
 29471: 
 29471:     if (isContext) {
 72330:       manager->AddEventListenerByType(listener,
 72330:                                       NS_LITERAL_STRING("contextmenu"),
 72330:                                       NS_EVENT_FLAG_BUBBLE |
 72331:                                       NS_EVENT_FLAG_SYSTEM_EVENT);
 29471:     } else {
 72330:       manager->AddEventListenerByType(listener,
 72330:                                       NS_LITERAL_STRING("mousedown"),
 72330:                                       NS_EVENT_FLAG_BUBBLE |
 72331:                                       NS_EVENT_FLAG_SYSTEM_EVENT);
 29471:     }
     1:     return NS_OK;
     1: }
     1: 
 56168: nsEventStates
  2896: nsXULElement::IntrinsicState() const
  2896: {
 56168:     nsEventStates state = nsStyledElement::IntrinsicState();
  2896: 
 71121:     if (IsReadWriteTextElement()) {
  2896:         state |= NS_EVENT_STATE_MOZ_READWRITE;
  2896:         state &= ~NS_EVENT_STATE_MOZ_READONLY;
  2896:     }
  2896: 
  2896:     return state;
  2896: }
  2896: 
     1: //----------------------------------------------------------------------
     1: 
105643: nsresult
105643: nsXULElement::MakeHeavyweight(nsXULPrototypeElement* aPrototype)
     1: {
105643:     if (!aPrototype) {
105643:         return NS_OK;
     1:     }
     1: 
     1:     PRUint32 i;
     1:     nsresult rv;
105643:     for (i = 0; i < aPrototype->mNumAttributes; ++i) {
105643:         nsXULPrototypeAttribute* protoattr = &aPrototype->mAttributes[i];
 50380:         nsAttrValue attrValue;
 50380:         
 50380:         // Style rules need to be cloned.
 50380:         if (protoattr->mValue.Type() == nsAttrValue::eCSSStyleRule) {
 69440:             nsRefPtr<css::Rule> ruleClone =
 50636:                 protoattr->mValue.GetCSSStyleRuleValue()->Clone();
 50380: 
 50380:             nsString stringValue;
 50380:             protoattr->mValue.ToString(stringValue);
 50380: 
 63693:             nsRefPtr<css::StyleRule> styleRule = do_QueryObject(ruleClone);
 50380:             attrValue.SetTo(styleRule, &stringValue);
 50380:         }
 50380:         else {
 50380:             attrValue.SetTo(protoattr->mValue);
 50380:         }
 50380: 
     1:         // XXX we might wanna have a SetAndTakeAttr that takes an nsAttrName
     1:         if (protoattr->mName.IsAtom()) {
     1:             rv = mAttrsAndChildren.SetAndTakeAttr(protoattr->mName.Atom(), attrValue);
     1:         }
     1:         else {
     1:             rv = mAttrsAndChildren.SetAndTakeAttr(protoattr->mName.NodeInfo(),
     1:                                                   attrValue);
     1:         }
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
 79445: nsXULElement::HideWindowChrome(bool aShouldHide)
     1: {
     1:     nsIDocument* doc = GetCurrentDoc();
 41634:     if (!doc || doc->GetRootElement() != this)
     1:       return NS_ERROR_UNEXPECTED;
     1: 
  4856:     // only top level chrome documents can hide the window chrome
 20078:     if (!doc->IsRootDisplayDocument())
  4856:       return NS_OK;
  4856: 
 46225:     nsIPresShell *shell = doc->GetShell();
     1: 
     1:     if (shell) {
 36655:         nsIFrame* frame = GetPrimaryFrame();
     1: 
     1:         nsPresContext *presContext = shell->GetPresContext();
     1: 
  4856:         if (frame && presContext && presContext->IsChrome()) {
     1:             nsIView* view = frame->GetClosestView();
     1: 
     1:             if (view) {
     1:                 nsIWidget* w = view->GetWidget();
     1:                 NS_ENSURE_STATE(w);
     1:                 w->HideWindowChrome(aShouldHide);
     1:             }
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
 34053: nsIWidget*
 34053: nsXULElement::GetWindowWidget()
  7242: {
  7242:     nsIDocument* doc = GetCurrentDoc();
  7242: 
  7242:     // only top level chrome documents can set the titlebar color
 20078:     if (doc->IsRootDisplayDocument()) {
  7242:         nsCOMPtr<nsISupports> container = doc->GetContainer();
  7242:         nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(container);
  7242:         if (baseWindow) {
  7242:             nsCOMPtr<nsIWidget> mainWidget;
  7242:             baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
 34053:             return mainWidget;
 34053:         }
 34053:     }
 34053:     return nsnull;
 34053: }
 34053: 
 34053: void
 79445: nsXULElement::SetTitlebarColor(nscolor aColor, bool aActive)
 34053: {
 34053:     nsIWidget* mainWidget = GetWindowWidget();
  7242:     if (mainWidget) {
 14886:         mainWidget->SetWindowTitlebarColor(aColor, aActive);
  7242:     }
  7242: }
 34053: 
 61932: class SetDrawInTitleBarEvent : public nsRunnable
 61932: {
 61932: public:
 79445:   SetDrawInTitleBarEvent(nsIWidget* aWidget, bool aState)
 61932:     : mWidget(aWidget)
 61932:     , mState(aState)
 61932:   {}
 61932: 
 61932:   NS_IMETHOD Run() {
 61932:     NS_ASSERTION(mWidget, "You shouldn't call this runnable with a null widget!");
 61932: 
 61932:     mWidget->SetDrawsInTitlebar(mState);
 61932:     return NS_OK;
 61932:   }
 61932: 
 61932: private:
 61932:   nsCOMPtr<nsIWidget> mWidget;
 79445:   bool mState;
 61932: };
 61932: 
 34053: void
 79445: nsXULElement::SetDrawsInTitlebar(bool aState)
 34053: {
 34053:     nsIWidget* mainWidget = GetWindowWidget();
 34053:     if (mainWidget) {
 62308:         nsContentUtils::AddScriptRunner(new SetDrawInTitleBarEvent(mainWidget, aState));
  7242:     }
  7242: }
  7242: 
 74803: class MarginSetter : public nsRunnable
 74803: {
 74803: public:
 74803:     MarginSetter(nsIWidget* aWidget) :
 74803:         mWidget(aWidget), mMargin(-1, -1, -1, -1)
 74803:     {}
 74803:     MarginSetter(nsIWidget *aWidget, const nsIntMargin& aMargin) :
 74803:         mWidget(aWidget), mMargin(aMargin)
 74803:     {}
 74803: 
 74803:     NS_IMETHOD Run()
 74803:     {
 74803:         // SetNonClientMargins can dispatch native events, hence doing
 74803:         // it off a script runner.
 74803:         mWidget->SetNonClientMargins(mMargin);
 74803:         return NS_OK;
 74803:     }
 74803: 
 74803: private:
 74803:     nsCOMPtr<nsIWidget> mWidget;
 74803:     nsIntMargin mMargin;
 74803: };
 74803: 
 46199: void
 90061: nsXULElement::SetChromeMargins(const nsAttrValue* aValue)
 46199: {
 46199:     if (!aValue)
 46199:         return;
 46199: 
 46199:     nsIWidget* mainWidget = GetWindowWidget();
 46199:     if (!mainWidget)
 46199:         return;
 46199: 
 46199:     // top, right, bottom, left - see nsAttrValue
 46199:     nsIntMargin margins;
 90061:     bool gotMargins = false;
 90061: 
 90061:     if (aValue->Type() == nsAttrValue::eIntMarginValue) {
 90061:         gotMargins = aValue->GetIntMarginValue(margins);
 90061:     } else {
 90061:         nsAutoString tmp;
 90061:         aValue->ToString(tmp);
 90061:         gotMargins = nsContentUtils::ParseIntMarginValue(tmp, margins);
 90061:     }
 90061:     if (gotMargins) {
 74803:         nsContentUtils::AddScriptRunner(new MarginSetter(mainWidget, margins));
 46199:     }
 46199: }
 46199: 
 46199: void
 46199: nsXULElement::ResetChromeMargins()
 46199: {
 46199:     nsIWidget* mainWidget = GetWindowWidget();
 46199:     if (!mainWidget)
 46199:         return;
 46199:     // See nsIWidget
 74803:     nsContentUtils::AddScriptRunner(new MarginSetter(mainWidget));
 46199: }
 46199: 
 79445: bool
     1: nsXULElement::BoolAttrIsTrue(nsIAtom* aName)
     1: {
     1:     const nsAttrValue* attr =
105643:         GetAttrInfo(kNameSpaceID_None, aName).mValue;
     1: 
     1:     return attr && attr->Type() == nsAttrValue::eAtom &&
     1:            attr->GetAtomValue() == nsGkAtoms::_true;
     1: }
     1: 
     1: void
     1: nsXULElement::RecompileScriptEventListeners()
     1: {
     1:     PRInt32 i, count = mAttrsAndChildren.AttrCount();
     1:     for (i = 0; i < count; ++i) {
     1:         const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
     1: 
     1:         // Eventlistenener-attributes are always in the null namespace
     1:         if (!name->IsAtom()) {
     1:             continue;
     1:         }
     1: 
     1:         nsIAtom *attr = name->Atom();
   265:         if (!nsContentUtils::IsEventAttributeName(attr, EventNameType_XUL)) {
     1:             continue;
     1:         }
     1: 
     1:         nsAutoString value;
     1:         GetAttr(kNameSpaceID_None, attr, value);
 80486:         AddScriptEventListener(attr, value, true);
     1:     }
     1: }
     1: 
  7230: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULPrototypeNode)
 97347: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsXULPrototypeNode)
  7286:     if (tmp->mType == nsXULPrototypeNode::eType_Element) {
  7286:         static_cast<nsXULPrototypeElement*>(tmp)->Unlink();
  7286:     }
 67680:     else if (tmp->mType == nsXULPrototypeNode::eType_Script) {
 67680:         static_cast<nsXULPrototypeScript*>(tmp)->UnlinkJSObjects();
 67680:     }
  7286: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 97347: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsXULPrototypeNode)
  1829:     if (tmp->mType == nsXULPrototypeNode::eType_Element) {
  1829:         nsXULPrototypeElement *elem =
  3233:             static_cast<nsXULPrototypeElement*>(tmp);
 87968:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mNodeInfo");
 94340:         cb.NoteXPCOMChild(elem->mNodeInfo);
  1829:         PRUint32 i;
 13669:         for (i = 0; i < elem->mNumAttributes; ++i) {
 13669:             const nsAttrName& name = elem->mAttributes[i].mName;
 87968:             if (!name.IsAtom()) {
 87968:                 NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
 87968:                     "mAttributes[i].mName.NodeInfo()");
 94340:                 cb.NoteXPCOMChild(name.NodeInfo());
 13669:             }
 87968:         }
 20136:         for (i = 0; i < elem->mChildren.Length(); ++i) {
 97347:             NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildren[i]");
 97347:             cb.NoteXPCOMChild(elem->mChildren[i]);
  1829:         }
  1829:     }
  7230:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
  7230: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 97347: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsXULPrototypeNode)
105645:     if (tmp->mType == nsXULPrototypeNode::eType_Script) {
  7230:         nsXULPrototypeScript *script =
  7230:             static_cast<nsXULPrototypeScript*>(tmp);
 96831:         NS_IMPL_CYCLE_COLLECTION_TRACE_JS_CALLBACK(script->mScriptObject.mObject,
 69023:                                                    "mScriptObject.mObject")
  7227:     }
  7230: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 97347: 
 97347: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXULPrototypeNode)
 97347: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXULPrototypeNode)
 97347: 
 97347: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXULPrototypeNode)
 97347:     NS_INTERFACE_MAP_ENTRY(nsISupports)
 97347: NS_INTERFACE_MAP_END
  1829: 
     1: //----------------------------------------------------------------------
     1: //
     1: // nsXULPrototypeAttribute
     1: //
     1: 
     1: nsXULPrototypeAttribute::~nsXULPrototypeAttribute()
     1: {
     1:     MOZ_COUNT_DTOR(nsXULPrototypeAttribute);
     1: }
     1: 
     1: 
     1: //----------------------------------------------------------------------
     1: //
     1: // nsXULPrototypeElement
     1: //
     1: 
     1: nsresult
     1: nsXULPrototypeElement::Serialize(nsIObjectOutputStream* aStream,
     1:                                  nsIScriptGlobalObject* aGlobal,
 94340:                                  const nsCOMArray<nsINodeInfo> *aNodeInfos)
     1: {
     1:     nsresult rv;
     1: 
     1:     // Write basic prototype data
     1:     rv = aStream->Write32(mType);
     1: 
     1:     // Write Node Info
     1:     PRInt32 index = aNodeInfos->IndexOf(mNodeInfo);
 94340:     NS_ASSERTION(index >= 0, "unknown nsINodeInfo index");
     1:     rv |= aStream->Write32(index);
     1: 
     1:     // Write Attributes
     1:     rv |= aStream->Write32(mNumAttributes);
     1: 
     1:     nsAutoString attributeValue;
     1:     PRUint32 i;
     1:     for (i = 0; i < mNumAttributes; ++i) {
 94340:         nsCOMPtr<nsINodeInfo> ni;
     1:         if (mAttributes[i].mName.IsAtom()) {
 19197:             ni = mNodeInfo->NodeInfoManager()->
     1:                 GetNodeInfo(mAttributes[i].mName.Atom(), nsnull,
 71770:                             kNameSpaceID_None,
 71770:                             nsIDOMNode::ATTRIBUTE_NODE);
     1:             NS_ASSERTION(ni, "the nodeinfo should already exist");
     1:         }
     1:         else {
     1:             ni = mAttributes[i].mName.NodeInfo();
     1:         }
     1: 
     1:         index = aNodeInfos->IndexOf(ni);
 94340:         NS_ASSERTION(index >= 0, "unknown nsINodeInfo index");
     1:         rv |= aStream->Write32(index);
     1: 
     1:         mAttributes[i].mValue.ToString(attributeValue);
     1:         rv |= aStream->WriteWStringZ(attributeValue.get());
     1:     }
     1: 
     1:     // Now write children
 20136:     rv |= aStream->Write32(PRUint32(mChildren.Length()));
 20136:     for (i = 0; i < mChildren.Length(); i++) {
 20136:         nsXULPrototypeNode* child = mChildren[i].get();
     1:         switch (child->mType) {
     1:         case eType_Element:
     1:         case eType_Text:
     1:         case eType_PI:
     1:             rv |= child->Serialize(aStream, aGlobal, aNodeInfos);
     1:             break;
     1:         case eType_Script:
     1:             rv |= aStream->Write32(child->mType);
  3233:             nsXULPrototypeScript* script = static_cast<nsXULPrototypeScript*>(child);
     1: 
     1:             rv |= aStream->Write8(script->mOutOfLine);
     1:             if (! script->mOutOfLine) {
     1:                 rv |= script->Serialize(aStream, aGlobal, aNodeInfos);
     1:             } else {
     1:                 rv |= aStream->WriteCompoundObject(script->mSrcURI,
     1:                                                    NS_GET_IID(nsIURI),
 80486:                                                    true);
     1: 
     1:                 if (script->mScriptObject.mObject) {
     1:                     // This may return NS_OK without muxing script->mSrcURI's
 71883:                     // data into the cache file, in the case where that
     1:                     // muxed document is already there (written by a prior
 71883:                     // session, or by an earlier cache episode during this
     1:                     // session).
     1:                     rv |= script->SerializeOutOfLine(aStream, aGlobal);
     1:                 }
     1:             }
     1:             break;
     1:         }
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult
     1: nsXULPrototypeElement::Deserialize(nsIObjectInputStream* aStream,
     1:                                    nsIScriptGlobalObject* aGlobal,
     1:                                    nsIURI* aDocumentURI,
 94340:                                    const nsCOMArray<nsINodeInfo> *aNodeInfos)
     1: {
     1:     NS_PRECONDITION(aNodeInfos, "missing nodeinfo array");
     1: 
     1:     // Read Node Info
     1:     PRUint32 number;
 95168:     nsresult rv = aStream->Read32(&number);
 94340:     mNodeInfo = aNodeInfos->SafeObjectAt(number);
 94340:     if (!mNodeInfo)
     1:         return NS_ERROR_UNEXPECTED;
     1: 
     1:     // Read Attributes
     1:     rv |= aStream->Read32(&number);
     1:     mNumAttributes = PRInt32(number);
     1: 
     1:     PRUint32 i;
     1:     if (mNumAttributes > 0) {
     1:         mAttributes = new nsXULPrototypeAttribute[mNumAttributes];
     1:         if (! mAttributes)
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:         nsAutoString attributeValue;
     1:         for (i = 0; i < mNumAttributes; ++i) {
     1:             rv |= aStream->Read32(&number);
 94340:             nsINodeInfo* ni = aNodeInfos->SafeObjectAt(number);
 94340:             if (!ni)
     1:                 return NS_ERROR_UNEXPECTED;
     1: 
     1:             mAttributes[i].mName.SetTo(ni);
     1: 
     1:             rv |= aStream->ReadString(attributeValue);
     1:             rv |= SetAttrAt(i, attributeValue, aDocumentURI);
     1:         }
     1:     }
     1: 
     1:     rv |= aStream->Read32(&number);
 20136:     PRUint32 numChildren = PRInt32(number);
 20136: 
 20136:     if (numChildren > 0) {
 20136:         if (!mChildren.SetCapacity(numChildren))
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1: 
 20136:         for (i = 0; i < numChildren; i++) {
     1:             rv |= aStream->Read32(&number);
     1:             Type childType = (Type)number;
     1: 
 20136:             nsRefPtr<nsXULPrototypeNode> child;
     1: 
     1:             switch (childType) {
     1:             case eType_Element:
     1:                 child = new nsXULPrototypeElement();
     1:                 if (! child)
     1:                     return NS_ERROR_OUT_OF_MEMORY;
     1:                 child->mType = childType;
     1: 
     1:                 rv |= child->Deserialize(aStream, aGlobal, aDocumentURI,
     1:                                          aNodeInfos);
     1:                 break;
     1:             case eType_Text:
     1:                 child = new nsXULPrototypeText();
     1:                 if (! child)
     1:                     return NS_ERROR_OUT_OF_MEMORY;
     1:                 child->mType = childType;
     1: 
     1:                 rv |= child->Deserialize(aStream, aGlobal, aDocumentURI,
     1:                                          aNodeInfos);
     1:                 break;
     1:             case eType_PI:
     1:                 child = new nsXULPrototypePI();
     1:                 if (! child)
     1:                     return NS_ERROR_OUT_OF_MEMORY;
     1:                 child->mType = childType;
     1: 
     1:                 rv |= child->Deserialize(aStream, aGlobal, aDocumentURI,
     1:                                          aNodeInfos);
     1:                 break;
     1:             case eType_Script: {
     1:                 // language version/options obtained during deserialization.
 96831:                 nsXULPrototypeScript* script = new nsXULPrototypeScript(0, 0);
     1:                 if (! script)
     1:                     return NS_ERROR_OUT_OF_MEMORY;
     1:                 child = script;
     1:                 child->mType = childType;
     1: 
 79445:                 rv |= aStream->ReadBoolean(&script->mOutOfLine);
     1:                 if (! script->mOutOfLine) {
     1:                     rv |= script->Deserialize(aStream, aGlobal, aDocumentURI,
     1:                                               aNodeInfos);
     1:                 } else {
 80486:                     rv |= aStream->ReadObject(true, getter_AddRefs(script->mSrcURI));
     1: 
     1:                     rv |= script->DeserializeOutOfLine(aStream, aGlobal);
     1:                 }
     1:                 // If we failed to deserialize, consider deleting 'script'?
     1:                 break;
     1:             }
     1:             default:
     1:                 NS_NOTREACHED("Unexpected child type!");
     1:                 rv = NS_ERROR_UNEXPECTED;
     1:             }
     1: 
 20136:             mChildren.AppendElement(child);
     1: 
     1:             // Oh dear. Something failed during the deserialization.
     1:             // We don't know what.  But likely consequences of failed
 71883:             // deserializations included calls to |AbortCaching| which
 71883:             // shuts down the cache and closes our streams.
     1:             // If that happens, next time through this loop, we die a messy
     1:             // death. So, let's just fail now, and propagate that failure
     1:             // upward so that the ChromeProtocolHandler knows it can't use
     1:             // a cached chrome channel for this.
     1:             if (NS_FAILED(rv))
     1:                 return rv;
     1:         }
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult
     1: nsXULPrototypeElement::SetAttrAt(PRUint32 aPos, const nsAString& aValue,
     1:                                  nsIURI* aDocumentURI)
     1: {
     1:     NS_PRECONDITION(aPos < mNumAttributes, "out-of-bounds");
     1: 
     1:     // WARNING!!
     1:     // This code is largely duplicated in nsXULElement::SetAttr.
     1:     // Any changes should be made to both functions.
     1: 
     1:     if (!mNodeInfo->NamespaceEquals(kNameSpaceID_XUL)) {
     1:         mAttributes[aPos].mValue.ParseStringOrAtom(aValue);
     1: 
     1:         return NS_OK;
     1:     }
     1: 
     1:     if (mAttributes[aPos].mName.Equals(nsGkAtoms::id) &&
     1:         !aValue.IsEmpty()) {
 80486:         mHasIdAttribute = true;
     1:         // Store id as atom.
     1:         // id="" means that the element has no id. Not that it has
     1:         // emptystring as id.
     1:         mAttributes[aPos].mValue.ParseAtom(aValue);
     1: 
     1:         return NS_OK;
     1:     }
     1:     else if (mAttributes[aPos].mName.Equals(nsGkAtoms::_class)) {
 80486:         mHasClassAttribute = true;
     1:         // Compute the element's class list
     1:         mAttributes[aPos].mValue.ParseAtomArray(aValue);
     1: 
     1:         return NS_OK;
     1:     }
     1:     else if (mAttributes[aPos].mName.Equals(nsGkAtoms::style)) {
 80486:         mHasStyleAttribute = true;
     1:         // Parse the element's 'style' attribute
 63693:         nsRefPtr<css::StyleRule> rule;
 38849: 
 38849:         nsCSSParser parser;
     1: 
     1:         // XXX Get correct Base URI (need GetBaseURI on *prototype* element)
 38849:         parser.ParseStyleAttribute(aValue, aDocumentURI, aDocumentURI,
  1036:                                    // This is basically duplicating what
  1036:                                    // nsINode::NodePrincipal() does
  1036:                                    mNodeInfo->NodeInfoManager()->
  1036:                                      DocumentPrincipal(),
     1:                                    getter_AddRefs(rule));
     1:         if (rule) {
 50380:             mAttributes[aPos].mValue.SetTo(rule, &aValue);
     1: 
     1:             return NS_OK;
     1:         }
     1:         // Don't abort if parsing failed, it could just be malformed css.
     1:     }
     1: 
     1:     mAttributes[aPos].mValue.ParseStringOrAtom(aValue);
     1: 
     1:     return NS_OK;
     1: }
     1: 
  7230: void
 67680: nsXULPrototypeElement::Unlink()
  7230: {
  7230:     mNumAttributes = 0;
  7230:     delete[] mAttributes;
  7230:     mAttributes = nsnull;
  7230: }
  7230: 
     1: //----------------------------------------------------------------------
     1: //
     1: // nsXULPrototypeScript
     1: //
     1: 
 96831: nsXULPrototypeScript::nsXULPrototypeScript(PRUint32 aLineNo, PRUint32 aVersion)
     1:     : nsXULPrototypeNode(eType_Script),
     1:       mLineNo(aLineNo),
 80486:       mSrcLoading(false),
 80486:       mOutOfLine(true),
     1:       mSrcLoadWaiters(nsnull),
     1:       mLangVersion(aVersion),
 96831:       mScriptObject()
     1: {
     1: }
     1: 
     1: 
     1: nsXULPrototypeScript::~nsXULPrototypeScript()
     1: {
 10981:     UnlinkJSObjects();
     1: }
     1: 
     1: nsresult
     1: nsXULPrototypeScript::Serialize(nsIObjectOutputStream* aStream,
     1:                                 nsIScriptGlobalObject* aGlobal,
 94340:                                 const nsCOMArray<nsINodeInfo> *aNodeInfos)
     1: {
 93911:     nsIScriptContext *context = aGlobal->GetScriptContext();
     1:     NS_ASSERTION(!mSrcLoading || mSrcLoadWaiters != nsnull ||
     1:                  !mScriptObject.mObject,
     1:                  "script source still loading when serializing?!");
     1:     if (!mScriptObject.mObject)
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     // Write basic prototype data
     1:     nsresult rv;
     1:     rv = aStream->Write32(mLineNo);
     1:     if (NS_FAILED(rv)) return rv;
     1:     rv = aStream->Write32(mLangVersion);
     1:     if (NS_FAILED(rv)) return rv;
     1:     // And delegate the writing to the nsIScriptContext
     1:     rv = context->Serialize(aStream, mScriptObject.mObject);
     1:     if (NS_FAILED(rv)) return rv;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsXULPrototypeScript::SerializeOutOfLine(nsIObjectOutputStream* aStream,
     1:                                          nsIScriptGlobalObject* aGlobal)
     1: {
 71883:     nsresult rv = NS_ERROR_NOT_IMPLEMENTED;
 71883: 
 79445:     bool isChrome = false;
 71883:     if (NS_FAILED(mSrcURI->SchemeIs("chrome", &isChrome)) || !isChrome)
 71883:        // Don't cache scripts that don't come from chrome uris.
 71883:        return rv;
 71883: 
     1:     nsXULPrototypeCache* cache = nsXULPrototypeCache::GetInstance();
     1:     if (!cache)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     NS_ASSERTION(cache->IsEnabled(),
 71883:                  "writing to the cache file, but the XUL cache is off?");
 79445:     bool exists;
 71883:     cache->HasData(mSrcURI, &exists);
 71883:     
 71883:     
     1:     /* return will be NS_OK from GetAsciiSpec.
     1:      * that makes no sense.
     1:      * nor does returning NS_OK from HasMuxedDocument.
     1:      * XXX return something meaningful.
     1:      */
     1:     if (exists)
     1:         return NS_OK;
     1: 
 71883:     nsCOMPtr<nsIObjectOutputStream> oos;
 71883:     rv = cache->GetOutputStream(mSrcURI, getter_AddRefs(oos));
 71883:     NS_ENSURE_SUCCESS(rv, rv);
 71883:     
 71883:     rv |= Serialize(oos, aGlobal, nsnull);
 71883:     rv |= cache->FinishOutputStream(mSrcURI);
     1: 
     1:     if (NS_FAILED(rv))
 71883:         cache->AbortCaching();
     1:     return rv;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsXULPrototypeScript::Deserialize(nsIObjectInputStream* aStream,
     1:                                   nsIScriptGlobalObject* aGlobal,
     1:                                   nsIURI* aDocumentURI,
 94340:                                   const nsCOMArray<nsINodeInfo> *aNodeInfos)
     1: {
     1:     nsresult rv;
     1: 
     1:     NS_ASSERTION(!mSrcLoading || mSrcLoadWaiters != nsnull ||
     1:                  !mScriptObject.mObject,
     1:                  "prototype script not well-initialized when deserializing?!");
     1: 
     1:     // Read basic prototype data
     1:     aStream->Read32(&mLineNo);
     1:     aStream->Read32(&mLangVersion);
     1: 
 93911:     nsIScriptContext *context = aGlobal->GetScriptContext();
     1:     NS_ASSERTION(context != nsnull, "Have no context for deserialization");
     1:     NS_ENSURE_TRUE(context, NS_ERROR_UNEXPECTED);
 84858:     nsScriptObjectHolder<JSScript> newScriptObject(context);
     1:     rv = context->Deserialize(aStream, newScriptObject);
     1:     if (NS_FAILED(rv)) {
     1:         NS_WARNING("Language deseralization failed");
     1:         return rv;
     1:     }
  7230:     Set(newScriptObject);
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsXULPrototypeScript::DeserializeOutOfLine(nsIObjectInputStream* aInput,
     1:                                            nsIScriptGlobalObject* aGlobal)
     1: {
 71883:     // Keep track of failure via rv, so we can
 71883:     // AbortCaching if things look bad.
     1:     nsresult rv = NS_OK;
     1:     nsXULPrototypeCache* cache = nsXULPrototypeCache::GetInstance();
 71883:   
     1:     nsCOMPtr<nsIObjectInputStream> objectInput = aInput;
 71883:     if (cache) {
 79445:         bool useXULCache = true;
     1:         if (mSrcURI) {
     1:             // NB: we must check the XUL script cache early, to avoid
 71883:             // multiple deserialization attempts for a given script.            
 71883:             // Note that nsXULDocument::LoadScript
     1:             // checks the XUL script cache too, in order to handle the
     1:             // serialization case.
     1:             //
     1:             // We need do this only for <script src='strres.js'> and the
     1:             // like, i.e., out-of-line scripts that are included by several
 71883:             // different XUL documents stored in the cache file.
     1:             useXULCache = cache->IsEnabled();
     1: 
     1:             if (useXULCache) {
 81048:                 JSScript* newScriptObject =
 96831:                     cache->GetScript(mSrcURI);
 96831:                 if (newScriptObject)
  7230:                     Set(newScriptObject);
     1:             }
     1:         }
     1: 
     1:         if (! mScriptObject.mObject) {
     1:             if (mSrcURI) {
 71883:                 rv = cache->GetInputStream(mSrcURI, getter_AddRefs(objectInput));
 71883:             } 
 71883:             // If !mSrcURI, we have an inline script. We shouldn't have 
 71883:             // to do anything else in that case, I think.
     1:  
     1:             // We do reflect errors into rv, but our caller may want to
     1:             // ignore our return value, because mScriptObject will be null
     1:             // after any error, and that suffices to cause the script to
     1:             // be reloaded (from the src= URI, if any) and recompiled.
     1:             // We're better off slow-loading than bailing out due to a
 71883:             // error.
     1:             if (NS_SUCCEEDED(rv))
     1:                 rv = Deserialize(objectInput, aGlobal, nsnull, nsnull);
     1: 
     1:             if (NS_SUCCEEDED(rv)) {
     1:                 if (useXULCache && mSrcURI) {
 79445:                     bool isChrome = false;
     1:                     mSrcURI->SchemeIs("chrome", &isChrome);
 96831:                     if (isChrome)
 96831:                         cache->PutScript(mSrcURI, mScriptObject.mObject);
     1:                 }
 71883:                 cache->FinishInputStream(mSrcURI);
     1:             } else {
 71883:                 // If mSrcURI is not in the cache,
     1:                 // rv will be NS_ERROR_NOT_AVAILABLE and we'll try to
 71883:                 // update the cache file to hold a serialization of
     1:                 // this script, once it has finished loading.
     1:                 if (rv != NS_ERROR_NOT_AVAILABLE)
 71883:                     cache->AbortCaching();
 71883:             }
 71883:         }
 71883:     }
     1:     return rv;
     1: }
     1: 
     1: nsresult
     1: nsXULPrototypeScript::Compile(const PRUnichar* aText,
     1:                               PRInt32 aTextLength,
     1:                               nsIURI* aURI,
     1:                               PRUint32 aLineNo,
     1:                               nsIDocument* aDocument,
     1:                               nsIScriptGlobalObjectOwner* aGlobalOwner)
     1: {
     1:     // We'll compile the script using the prototype document's special
     1:     // script object as the parent. This ensures that we won't end up
     1:     // with an uncollectable reference.
     1:     //
     1:     // Compiling it using (for example) the first document's global
     1:     // object would cause JS to keep a reference via the __proto__ or
 41968:     // parent pointer to the first document's global. If that happened,
 41968:     // our script object would reference the first document, and the
 41968:     // first document would indirectly reference the prototype document
 41968:     // because it keeps the prototype cache alive. Circularity!
     1:     nsresult rv;
     1: 
     1:     // Use the prototype document's special context
     1:     nsIScriptContext *context;
     1: 
     1:     {
     1:         nsIScriptGlobalObject* global = aGlobalOwner->GetScriptGlobalObject();
     1:         NS_ASSERTION(global != nsnull, "prototype doc has no script global");
     1:         if (! global)
     1:             return NS_ERROR_UNEXPECTED;
     1: 
 93911:         context = global->GetScriptContext();
     1:         NS_ASSERTION(context != nsnull, "no context for script global");
     1:         if (! context)
     1:             return NS_ERROR_UNEXPECTED;
     1:     }
     1: 
     1:     nsCAutoString urlspec;
 21636:     nsContentUtils::GetWrapperSafeScriptFilename(aDocument, aURI, urlspec);
     1: 
     1:     // Ok, compile it to create a prototype script object!
     1: 
 84858:     nsScriptObjectHolder<JSScript> newScriptObject(context);
     1:     rv = context->CompileScript(aText,
     1:                                 aTextLength,
     1:                                 // Use the enclosing document's principal
     1:                                 // XXX is this right? or should we use the
     1:                                 // protodoc's?
 13464:                                 // If we start using the protodoc's, make sure
 13464:                                 // the DowngradePrincipalIfNeeded stuff in
 13464:                                 // nsXULDocument::OnStreamComplete still works!
     1:                                 aDocument->NodePrincipal(),
     1:                                 urlspec.get(),
     1:                                 aLineNo,
     1:                                 mLangVersion,
     1:                                 newScriptObject);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
  7230:     Set(newScriptObject);
     1:     return rv;
     1: }
     1: 
 75263: void
 75263: nsXULPrototypeScript::UnlinkJSObjects()
 75263: {
 75263:     if (mScriptObject.mObject) {
 94361:         nsContentUtils::DropJSObjects(this);
 75263:         mScriptObject.mObject = nsnull;
 75263:     }
 75263: }
 75263: 
 75263: void
 81048: nsXULPrototypeScript::Set(JSScript* aObject)
 75263: {
 75263:     NS_ASSERTION(!mScriptObject.mObject, "Leaking script object.");
 75263:     if (!aObject) {
 75263:         mScriptObject.mObject = nsnull;
 75263:         return;
 75263:     }
 75263: 
 94361:     nsresult rv = nsContentUtils::HoldJSObjects(
102293:         this, NS_CYCLE_COLLECTION_PARTICIPANT(nsXULPrototypeNode));
 75263:     if (NS_SUCCEEDED(rv)) {
 81048:         mScriptObject.mObject = aObject;
 75263:     }
 75263: }
 75263: 
     1: //----------------------------------------------------------------------
     1: //
     1: // nsXULPrototypeText
     1: //
     1: 
     1: nsresult
     1: nsXULPrototypeText::Serialize(nsIObjectOutputStream* aStream,
     1:                               nsIScriptGlobalObject* aGlobal,
 94340:                               const nsCOMArray<nsINodeInfo> *aNodeInfos)
     1: {
     1:     nsresult rv;
     1: 
     1:     // Write basic prototype data
     1:     rv = aStream->Write32(mType);
     1: 
     1:     rv |= aStream->WriteWStringZ(mValue.get());
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult
     1: nsXULPrototypeText::Deserialize(nsIObjectInputStream* aStream,
     1:                                 nsIScriptGlobalObject* aGlobal,
     1:                                 nsIURI* aDocumentURI,
 94340:                                 const nsCOMArray<nsINodeInfo> *aNodeInfos)
     1: {
     1:     nsresult rv;
     1: 
     1:     rv = aStream->ReadString(mValue);
     1: 
     1:     return rv;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: //
     1: // nsXULPrototypePI
     1: //
     1: 
     1: nsresult
     1: nsXULPrototypePI::Serialize(nsIObjectOutputStream* aStream,
     1:                             nsIScriptGlobalObject* aGlobal,
 94340:                             const nsCOMArray<nsINodeInfo> *aNodeInfos)
     1: {
     1:     nsresult rv;
     1: 
     1:     // Write basic prototype data
     1:     rv = aStream->Write32(mType);
     1: 
     1:     rv |= aStream->WriteWStringZ(mTarget.get());
     1:     rv |= aStream->WriteWStringZ(mData.get());
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult
     1: nsXULPrototypePI::Deserialize(nsIObjectInputStream* aStream,
     1:                               nsIScriptGlobalObject* aGlobal,
     1:                               nsIURI* aDocumentURI,
 94340:                               const nsCOMArray<nsINodeInfo> *aNodeInfos)
     1: {
     1:     nsresult rv;
     1: 
     1:     rv = aStream->ReadString(mTarget);
     1:     rv |= aStream->ReadString(mData);
     1: 
     1:     return rv;
     1: }
