 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JavaScript API.
     1:  */
 95341: 
 95341: #include "mozilla/FloatingPoint.h"
 95341: 
     1: #include <ctype.h>
     1: #include <stdarg.h>
     1: #include <stdlib.h>
     1: #include <string.h>
 58990: #include <sys/stat.h>
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
     1: #include "jsclist.h"
     1: #include "jsprf.h"
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jsbool.h"
 54863: #include "jsclone.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsdate.h"
 88135: #include "jsdtoa.h"
     1: #include "jsexn.h"
     1: #include "jsfun.h"
     1: #include "jsgc.h"
     1: #include "jsinterp.h"
  6464: #include "jsiter.h"
     1: #include "jslock.h"
     1: #include "jsmath.h"
 88135: #include "jsnativestack.h"
     1: #include "jsnum.h"
 20092: #include "json.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
 73746: #include "jsprobes.h"
 42733: #include "jsproxy.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: #include "jsstr.h"
     1: #include "prmjtime.h"
 68911: #include "jsweakmap.h"
 47498: #include "jswrapper.h"
 37042: #include "jstypedarray.h"
 94006: #include "jsxml.h"
     1: 
103638: #include "builtin/Eval.h"
 87812: #include "builtin/MapObject.h"
 79981: #include "builtin/RegExp.h"
103638: #include "ds/LifoAlloc.h"
 80507: #include "frontend/BytecodeCompiler.h"
104045: #include "frontend/TreeContext.h"
 97569: #include "gc/Marking.h"
 89806: #include "gc/Memory.h"
 86104: #include "js/MemoryMetrics.h"
 97045: #include "vm/NumericConversions.h"
 93300: #include "vm/StringBuffer.h"
 94006: #include "vm/Xdr.h"
103638: #include "yarr/BumpPointerAllocator.h"
 79981: 
 34349: #include "jsatominlines.h"
 77343: #include "jsinferinlines.h"
 48470: #include "jsobjinlines.h"
 34349: #include "jsscopeinlines.h"
 59968: #include "jsscriptinlines.h"
 50493: 
 93701: #include "vm/ObjectImpl-inl.h"
 79981: #include "vm/RegExpObject-inl.h"
 82129: #include "vm/RegExpStatics-inl.h"
 69223: #include "vm/Stack-inl.h"
 72107: #include "vm/String-inl.h"
 69223: 
 50493: #if ENABLE_YARR_JIT
 50491: #include "assembler/jit/ExecutableAllocator.h"
 50491: #include "methodjit/Logging.h"
 50493: #endif
 34349: 
 37741: using namespace js;
 54707: using namespace js::gc;
 77343: using namespace js::types;
 37741: 
105479: bool
105479: JS::detail::CallMethodIfWrapped(JSContext *cx, IsAcceptableThis test, NativeImpl impl,
105479:                                CallArgs args)
105479: {
105479:     const Value &thisv = args.thisv();
105479:     JS_ASSERT(!test(thisv));
105479: 
105479:     if (thisv.isObject()) {
105479:         JSObject &thisObj = args.thisv().toObject();
105479:         if (thisObj.isProxy())
105479:             return Proxy::nativeCall(cx, test, impl, args);
105479:     }
105479: 
105479:     ReportIncompatible(cx, args);
105479:     return false;
105479: }
105479: 
105479: 
 61450: /*
 99821:  * This class is a version-establishing barrier at the head of a VM entry or
 61450:  * re-entry. It ensures that:
 61450:  *
 61450:  * - |newVersion| is the starting (default) version used for the context.
 61450:  * - The starting version state is not an override.
 61450:  * - Overrides in the VM session are not propagated to the caller.
 61450:  */
 53848: class AutoVersionAPI
 53848: {
 53848:     JSContext   * const cx;
 61450:     JSVersion   oldDefaultVersion;
 61450:     bool        oldHasVersionOverride;
 61450:     JSVersion   oldVersionOverride;
 61450: #ifdef DEBUG
 91237:     unsigned       oldCompileOptions;
 61450: #endif
 61450:     JSVersion   newVersion;
 53848: 
 53848:   public:
 99821:     AutoVersionAPI(JSContext *cx, JSVersion newVersion)
 61450:       : cx(cx),
 61450:         oldDefaultVersion(cx->getDefaultVersion()),
 61450:         oldHasVersionOverride(cx->isVersionOverridden()),
 61450:         oldVersionOverride(oldHasVersionOverride ? cx->findVersion() : JSVERSION_UNKNOWN)
 61450: #ifdef DEBUG
 61450:         , oldCompileOptions(cx->getCompileOptions())
 61450: #endif
 61450:     {
 99821: #if JS_HAS_XML_SUPPORT
 99821:         // For backward compatibility, AutoVersionAPI clobbers the
 99821:         // JSOPTION_MOAR_XML bit in cx, but not the JSOPTION_ALLOW_XML bit.
 99821:         newVersion = JSVersion(newVersion | (oldDefaultVersion & VersionFlags::ALLOW_XML));
 99821: #endif
 61450:         this->newVersion = newVersion;
 61450:         cx->clearVersionOverride();
 61450:         cx->setDefaultVersion(newVersion);
 61425:     }
 61425: 
 61425:     ~AutoVersionAPI() {
 61450:         cx->setDefaultVersion(oldDefaultVersion);
 61450:         if (oldHasVersionOverride)
 61450:             cx->overrideVersion(oldVersionOverride);
 61450:         else
 61424:             cx->clearVersionOverride();
 61450:         JS_ASSERT(oldCompileOptions == cx->getCompileOptions());
 61450:     }
 61450: 
 61450:     /* The version that this scoped-entity establishes. */
 61450:     JSVersion version() const { return newVersion; }
 53848: };
 53848: 
     1: #ifdef HAVE_VA_LIST_AS_ARRAY
     1: #define JS_ADDRESSOF_VA_LIST(ap) ((va_list *)(ap))
     1: #else
     1: #define JS_ADDRESSOF_VA_LIST(ap) (&(ap))
     1: #endif
     1: 
 78613: #ifdef JS_USE_JSID_STRUCT_TYPES
 78613: jsid JS_DEFAULT_XML_NAMESPACE_ID = { size_t(JSID_TYPE_DEFAULT_XML_NAMESPACE) };
 78613: jsid JSID_VOID  = { size_t(JSID_TYPE_VOID) };
 78613: jsid JSID_EMPTY = { size_t(JSID_TYPE_OBJECT) };
 48470: #endif
 48470: 
 78613: const jsval JSVAL_NULL  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_NULL,      0));
 78613: const jsval JSVAL_ZERO  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_INT32,     0));
 78613: const jsval JSVAL_ONE   = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_INT32,     1));
 78613: const jsval JSVAL_FALSE = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   JS_FALSE));
 78613: const jsval JSVAL_TRUE  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   JS_TRUE));
 78613: const jsval JSVAL_VOID  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_UNDEFINED, 0));
 25901: 
 48540: /* Make sure that jschar is two bytes unsigned integer */
 48540: JS_STATIC_ASSERT((jschar)-1 > 0);
 48540: JS_STATIC_ASSERT(sizeof(jschar) == 2);
 48540: 
 84755: JS_PUBLIC_API(int64_t)
     1: JS_Now()
     1: {
     1:     return PRMJ_Now();
     1: }
     1: 
     1: JS_PUBLIC_API(jsval)
     1: JS_GetNaNValue(JSContext *cx)
     1: {
 78614:     return cx->runtime->NaNValue;
     1: }
     1: 
     1: JS_PUBLIC_API(jsval)
     1: JS_GetNegativeInfinityValue(JSContext *cx)
     1: {
 78614:     return cx->runtime->negativeInfinityValue;
     1: }
     1: 
     1: JS_PUBLIC_API(jsval)
     1: JS_GetPositiveInfinityValue(JSContext *cx)
     1: {
 78614:     return cx->runtime->positiveInfinityValue;
     1: }
     1: 
     1: JS_PUBLIC_API(jsval)
     1: JS_GetEmptyStringValue(JSContext *cx)
     1: {
     1:     return STRING_TO_JSVAL(cx->runtime->emptyString);
     1: }
     1: 
 58976: JS_PUBLIC_API(JSString *)
 58976: JS_GetEmptyString(JSRuntime *rt)
 58976: {
 87611:     JS_ASSERT(rt->hasContexts());
 58976:     return rt->emptyString;
 58976: }
 58976: 
     1: static JSBool
 43229: TryArgumentFormatter(JSContext *cx, const char **formatp, JSBool fromJS, jsval **vpp, va_list *app)
     1: {
     1:     const char *format;
     1:     JSArgumentFormatMap *map;
     1: 
     1:     format = *formatp;
     1:     for (map = cx->argumentFormatMap; map; map = map->next) {
     1:         if (!strncmp(format, map->format, map->length)) {
     1:             *formatp = format + map->length;
     1:             return map->formatter(cx, format, fromJS, vpp, app);
     1:         }
     1:     }
     1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_CHAR, format);
     1:     return JS_FALSE;
     1: }
     1: 
 86458: static void
103783: AssertHeapIsIdle(JSRuntime *rt)
103783: {
103783:     JS_ASSERT(rt->heapState == JSRuntime::Idle);
 86458: }
 86458: 
 86458: static void
103783: AssertHeapIsIdle(JSContext *cx)
103783: {
103783:     AssertHeapIsIdle(cx->runtime);
 86458: }
 86458: 
 86458: static void
103785: AssertHeapIsIdleOrIterating(JSRuntime *rt)
103785: {
103785:     JS_ASSERT(rt->heapState != JSRuntime::Collecting);
103785: }
103785: 
103785: static void
103785: AssertHeapIsIdleOrIterating(JSContext *cx)
103785: {
103785:     AssertHeapIsIdleOrIterating(cx->runtime);
103785: }
103785: 
103785: static void
103783: AssertHeapIsIdleOrStringIsFlat(JSContext *cx, JSString *str)
 86458: {
 86458:     /*
 86458:      * We allow some functions to be called during a GC as long as the argument
 86458:      * is a flat string, since that will not cause allocation.
 86458:      */
103783:     JS_ASSERT_IF(cx->runtime->isHeapBusy(), str->isFlat());
 86458: }
 86458: 
     1: JS_PUBLIC_API(JSBool)
 91237: JS_ConvertArguments(JSContext *cx, unsigned argc, jsval *argv, const char *format, ...)
     1: {
     1:     va_list ap;
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
 86458: 
     1:     va_start(ap, format);
     1:     ok = JS_ConvertArgumentsVA(cx, argc, argv, format, ap);
     1:     va_end(ap);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 91237: JS_ConvertArgumentsVA(JSContext *cx, unsigned argc, jsval *argv, const char *format, va_list ap)
     1: {
     1:     jsval *sp;
     1:     JSBool required;
     1:     char c;
 90955:     double d;
     1:     JSString *str;
     1:     JSObject *obj;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 48470:     assertSameCompartment(cx, JSValueArray(argv - 2, argc + 2));
     1:     sp = argv;
     1:     required = JS_TRUE;
     1:     while ((c = *format++) != '\0') {
     1:         if (isspace(c))
     1:             continue;
     1:         if (c == '/') {
     1:             required = JS_FALSE;
     1:             continue;
     1:         }
     1:         if (sp == argv + argc) {
     1:             if (required) {
103274:                 if (JSFunction *fun = ReportIfNotFunction(cx, argv[-2])) {
     1:                     char numBuf[12];
     1:                     JS_snprintf(numBuf, sizeof numBuf, "%u", argc);
 57812:                     JSAutoByteString funNameBytes;
 57812:                     if (const char *name = GetFunctionNameBytes(cx, fun, &funNameBytes)) {
 57812:                         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
 57812:                                              name, numBuf, (argc == 1) ? "" : "s");
 57812:                     }
     1:                 }
     1:                 return JS_FALSE;
     1:             }
     1:             break;
     1:         }
     1:         switch (c) {
     1:           case 'b':
 78614:             *va_arg(ap, JSBool *) = js_ValueToBoolean(*sp);
     1:             break;
     1:           case 'c':
 84755:             if (!JS_ValueToUint16(cx, *sp, va_arg(ap, uint16_t *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'i':
 84755:             if (!JS_ValueToECMAInt32(cx, *sp, va_arg(ap, int32_t *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'u':
 84755:             if (!JS_ValueToECMAUint32(cx, *sp, va_arg(ap, uint32_t *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'j':
 84755:             if (!JS_ValueToInt32(cx, *sp, va_arg(ap, int32_t *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'd':
 90955:             if (!JS_ValueToNumber(cx, *sp, va_arg(ap, double *)))
     1:                 return JS_FALSE;
     1:             break;
     1:           case 'I':
 12694:             if (!JS_ValueToNumber(cx, *sp, &d))
     1:                 return JS_FALSE;
 97045:             *va_arg(ap, double *) = ToInteger(d);
     1:             break;
     1:           case 'S':
     1:           case 'W':
 84160:             str = ToString(cx, *sp);
     1:             if (!str)
     1:                 return JS_FALSE;
     1:             *sp = STRING_TO_JSVAL(str);
 57814:             if (c == 'W') {
 64345:                 JSFixedString *fixed = str->ensureFixed(cx);
 64345:                 if (!fixed)
     1:                     return JS_FALSE;
 64345:                 *va_arg(ap, const jschar **) = fixed->chars();
     1:             } else {
     1:                 *va_arg(ap, JSString **) = str;
     1:             }
     1:             break;
     1:           case 'o':
 78614:             if (!js_ValueToObjectOrNull(cx, *sp, &obj))
     1:                 return JS_FALSE;
     1:             *sp = OBJECT_TO_JSVAL(obj);
     1:             *va_arg(ap, JSObject **) = obj;
     1:             break;
     1:           case 'f':
103274:             obj = ReportIfNotFunction(cx, *sp);
     1:             if (!obj)
     1:                 return JS_FALSE;
 10574:             *sp = OBJECT_TO_JSVAL(obj);
 83234:             *va_arg(ap, JSFunction **) = obj->toFunction();
     1:             break;
     1:           case 'v':
     1:             *va_arg(ap, jsval *) = *sp;
     1:             break;
     1:           case '*':
     1:             break;
     1:           default:
     1:             format--;
     1:             if (!TryArgumentFormatter(cx, &format, JS_TRUE, &sp,
     1:                                       JS_ADDRESSOF_VA_LIST(ap))) {
     1:                 return JS_FALSE;
     1:             }
     1:             /* NB: the formatter already updated sp, so we continue here. */
     1:             continue;
     1:         }
     1:         sp++;
     1:     }
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 43229: JS_AddArgumentFormatter(JSContext *cx, const char *format, JSArgumentFormatter formatter)
     1: {
     1:     size_t length;
     1:     JSArgumentFormatMap **mpp, *map;
     1: 
     1:     length = strlen(format);
     1:     mpp = &cx->argumentFormatMap;
     1:     while ((map = *mpp) != NULL) {
     1:         /* Insert before any shorter string to match before prefixes. */
     1:         if (map->length < length)
     1:             break;
     1:         if (map->length == length && !strcmp(map->format, format))
     1:             goto out;
     1:         mpp = &map->next;
     1:     }
 64560:     map = (JSArgumentFormatMap *) cx->malloc_(sizeof *map);
     1:     if (!map)
     1:         return JS_FALSE;
     1:     map->format = format;
     1:     map->length = length;
     1:     map->next = *mpp;
     1:     *mpp = map;
     1: out:
     1:     map->formatter = formatter;
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_RemoveArgumentFormatter(JSContext *cx, const char *format)
     1: {
     1:     size_t length;
     1:     JSArgumentFormatMap **mpp, *map;
     1: 
     1:     length = strlen(format);
     1:     mpp = &cx->argumentFormatMap;
     1:     while ((map = *mpp) != NULL) {
     1:         if (map->length == length && !strcmp(map->format, format)) {
     1:             *mpp = map->next;
 64560:             cx->free_(map);
     1:             return;
     1:         }
     1:         mpp = &map->next;
     1:     }
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ConvertValue(JSContext *cx, jsval v, JSType type, jsval *vp)
     1: {
 10449:     JSBool ok;
     1:     JSObject *obj;
     1:     JSString *str;
 90955:     double d;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
     1:     switch (type) {
     1:       case JSTYPE_VOID:
     1:         *vp = JSVAL_VOID;
     1:         ok = JS_TRUE;
     1:         break;
     1:       case JSTYPE_OBJECT:
 78614:         ok = js_ValueToObjectOrNull(cx, v, &obj);
     1:         if (ok)
     1:             *vp = OBJECT_TO_JSVAL(obj);
     1:         break;
     1:       case JSTYPE_FUNCTION:
     1:         *vp = v;
103274:         obj = ReportIfNotFunction(cx, *vp);
     1:         ok = (obj != NULL);
     1:         break;
     1:       case JSTYPE_STRING:
 84160:         str = ToString(cx, v);
     1:         ok = (str != NULL);
     1:         if (ok)
     1:             *vp = STRING_TO_JSVAL(str);
     1:         break;
     1:       case JSTYPE_NUMBER:
 12694:         ok = JS_ValueToNumber(cx, v, &d);
     1:         if (ok)
 48470:             *vp = DOUBLE_TO_JSVAL(d);
     1:         break;
     1:       case JSTYPE_BOOLEAN:
 78614:         *vp = BOOLEAN_TO_JSVAL(js_ValueToBoolean(v));
 10449:         return JS_TRUE;
     1:       default: {
     1:         char numBuf[12];
     1:         JS_snprintf(numBuf, sizeof numBuf, "%d", (int)type);
 43229:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_TYPE, numBuf);
     1:         ok = JS_FALSE;
     1:         break;
     1:       }
     1:     }
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ValueToObject(JSContext *cx, jsval v, JSObject **objp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 78614:     return js_ValueToObjectOrNull(cx, v, objp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
     1: JS_ValueToFunction(JSContext *cx, jsval v)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
103274:     return ReportIfNotFunction(cx, v);
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
     1: JS_ValueToConstructor(JSContext *cx, jsval v)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
103274:     return ReportIfNotFunction(cx, v);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_ValueToString(JSContext *cx, jsval v)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 84160:     return ToString(cx, v);
     1: }
     1: 
 21482: JS_PUBLIC_API(JSString *)
 21482: JS_ValueToSource(JSContext *cx, jsval v)
 21482: {
103783:     AssertHeapIsIdle(cx);
 21482:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 78614:     return js_ValueToSource(cx, v);
 21482: }
 21482: 
     1: JS_PUBLIC_API(JSBool)
 90955: JS_ValueToNumber(JSContext *cx, jsval v, double *dp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 33178: 
 97353:     return ToNumber(cx, v, dp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 91450: JS_DoubleIsInt32(double d, int32_t *ip)
 91450: {
 95341:     return MOZ_DOUBLE_IS_INT32(d, ip);
 39905: }
 39905: 
 84755: JS_PUBLIC_API(int32_t)
 90955: JS_DoubleToInt32(double d)
 64550: {
 97045:     return ToInt32(d);
 64550: }
 64550: 
 84755: JS_PUBLIC_API(uint32_t)
 90955: JS_DoubleToUint32(double d)
 64550: {
 97045:     return ToUint32(d);
 64550: }
 64550: 
 39905: JS_PUBLIC_API(JSBool)
 84755: JS_ValueToECMAInt32(JSContext *cx, jsval v, int32_t *ip)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 33178: 
 99421:     RootedValue value(cx, v);
 97353:     return ToInt32(cx, value, ip);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 84755: JS_ValueToECMAUint32(JSContext *cx, jsval v, uint32_t *ip)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 33178: 
 97353:     return ToUint32(cx, v, (uint32_t *)ip);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 84755: JS_ValueToInt32(JSContext *cx, jsval v, int32_t *ip)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 33178: 
 98811:     if (v.isInt32()) {
 98811:         *ip = v.toInt32();
 98811:         return true;
 98811:     }
 98811: 
 98811:     double d;
 98811:     if (v.isDouble()) {
 98811:         d = v.toDouble();
 98811:     } else if (!ToNumberSlow(cx, v, &d)) {
 98811:         return false;
 98811:     }
 98811: 
 98811:     if (MOZ_DOUBLE_IS_NaN(d) || d <= -2147483649.0 || 2147483648.0 <= d) {
 98811:         js_ReportValueError(cx, JSMSG_CANT_CONVERT,
 98811:                             JSDVG_SEARCH_STACK, v, NULL);
 98811:         return false;
 98811:     }
 98811: 
 98811:     *ip = (int32_t) floor(d + 0.5);  /* Round to nearest */
 98811:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 84755: JS_ValueToUint16(JSContext *cx, jsval v, uint16_t *ip)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 33178: 
 97353:     return ValueToUint16(cx, v, (uint16_t *)ip);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ValueToBoolean(JSContext *cx, jsval v, JSBool *bp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 78614:     *bp = js_ValueToBoolean(v);
 10449:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSType)
     1: JS_TypeOfValue(JSContext *cx, jsval v)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 78614:     return TypeOfValue(cx, v);
     1: }
     1: 
     1: JS_PUBLIC_API(const char *)
     1: JS_GetTypeName(JSContext *cx, JSType type)
     1: {
 91237:     if ((unsigned)type >= (unsigned)JSTYPE_LIMIT)
     1:         return NULL;
  4342:     return JS_TYPE_STR(type);
     1: }
     1: 
 28408: JS_PUBLIC_API(JSBool)
 59889: JS_StrictlyEqual(JSContext *cx, jsval v1, jsval v2, JSBool *equal)
 28408: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v1, v2);
 88099:     bool eq;
 88099:     if (!StrictlyEqual(cx, v1, v2, &eq))
 88099:         return false;
 88099:     *equal = eq;
 88099:     return true;
 28408: }
 28408: 
 32760: JS_PUBLIC_API(JSBool)
 64551: JS_LooselyEqual(JSContext *cx, jsval v1, jsval v2, JSBool *equal)
 64551: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 64551:     assertSameCompartment(cx, v1, v2);
 88099:     bool eq;
 88099:     if (!LooselyEqual(cx, v1, v2, &eq))
 88099:         return false;
 88099:     *equal = eq;
 88099:     return true;
 64551: }
 64551: 
 64551: JS_PUBLIC_API(JSBool)
 59889: JS_SameValue(JSContext *cx, jsval v1, jsval v2, JSBool *same)
 32760: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v1, v2);
 88099:     bool s;
 88099:     if (!SameValue(cx, v1, v2, &s))
 88099:         return false;
 88099:     *same = s;
 88099:     return true;
 32760: }
 32760: 
 64210: JS_PUBLIC_API(JSBool)
 64210: JS_IsBuiltinEvalFunction(JSFunction *fun)
 64210: {
 64228:     return IsAnyBuiltinEval(fun);
 64210: }
 64210: 
 64210: JS_PUBLIC_API(JSBool)
 64210: JS_IsBuiltinFunctionConstructor(JSFunction *fun)
 64210: {
 64210:     return IsBuiltinFunctionConstructor(fun);
 64210: }
 64210: 
     1: /************************************************************************/
     1: 
  8893: /*
  8893:  * Has a new runtime ever been created?  This flag is used to detect unsafe
  8893:  * changes to js_CStringsAreUTF8 after a runtime has been created, and to
 73748:  * control things that should happen only once across all runtimes.
  8893:  */
  8893: static JSBool js_NewRuntimeWasCalled = JS_FALSE;
  8893: 
 91900: static const JSSecurityCallbacks NullSecurityCallbacks = { };
 91900: 
 34299: JSRuntime::JSRuntime()
 89261:   : atomsCompartment(NULL),
 88135: #ifdef JS_THREADSAFE
 88135:     ownerThread_(NULL),
 88135: #endif
 88135:     tempLifoAlloc(TEMP_LIFO_ALLOC_PRIMARY_CHUNK_SIZE),
 88135:     execAlloc_(NULL),
 88135:     bumpAlloc_(NULL),
 97464: #ifdef JS_METHODJIT
 97464:     jaegerRuntime_(NULL),
 97464: #endif
 89261:     nativeStackBase(0),
 89261:     nativeStackQuota(0),
 88135:     interpreterFrames(NULL),
 79507:     cxCallback(NULL),
 94740:     destroyCompartmentCallback(NULL),
 79507:     activityCallback(NULL),
 79507:     activityCallbackArg(NULL),
 88135: #ifdef JS_THREADSAFE
 88135:     suspendCount(0),
 88135:     requestDepth(0),
 88135: # ifdef DEBUG
 88135:     checkRequestDepth(0),
 88135: # endif
 88135: #endif
 79507:     gcSystemAvailableChunkListHead(NULL),
 79507:     gcUserAvailableChunkListHead(NULL),
 79507:     gcKeepAtoms(0),
 79507:     gcBytes(0),
 79507:     gcMaxBytes(0),
 79507:     gcMaxMallocBytes(0),
 85064:     gcNumArenasFreeCommitted(0),
 82130:     gcVerifyData(NULL),
 79507:     gcChunkAllocationSinceLastGC(false),
 79507:     gcNextFullGCTime(0),
104267:     gcLastGCTime(0),
 79507:     gcJitReleaseTime(0),
 79507:     gcMode(JSGC_MODE_GLOBAL),
104267:     gcHighFrequencyGC(false),
104267:     gcHighFrequencyTimeThreshold(1000),
104267:     gcHighFrequencyLowLimitBytes(100 * 1024 * 1024),
104267:     gcHighFrequencyHighLimitBytes(500 * 1024 * 1024),
104267:     gcHighFrequencyHeapGrowthMax(3.0),
104267:     gcHighFrequencyHeapGrowthMin(1.5),
104267:     gcLowFrequencyHeapGrowth(1.5),
104267:     gcDynamicHeapGrowth(false),
104267:     gcDynamicMarkSlice(false),
 99131:     gcShouldCleanUpEverything(false),
 79507:     gcIsNeeded(0),
 79507:     gcWeakMapList(NULL),
 80212:     gcStats(thisFromCtor()),
 90410:     gcNumber(0),
 90410:     gcStartNumber(0),
 95297:     gcIsFull(false),
 88182:     gcTriggerReason(gcreason::NO_REASON),
 94620:     gcStrictCompartmentChecking(false),
102262:     gcDisableStrictProxyCheckingCount(0),
 90410:     gcIncrementalState(gc::NO_INCREMENTAL),
 90410:     gcLastMarkSlice(false),
 90410:     gcInterFrameGC(0),
 90410:     gcSliceBudget(SliceBudget::Unlimited),
 90410:     gcIncrementalEnabled(true),
 97353:     gcExactScanningEnabled(true),
 79507:     gcPoke(false),
103783:     heapState(Idle),
 79507: #ifdef JS_GC_ZEAL
 79507:     gcZeal_(0),
 79507:     gcZealFrequency(0),
 79507:     gcNextScheduled(0),
 91660:     gcDeterministicOnly(false),
102693:     gcIncrementalLimit(0),
 79507: #endif
 79507:     gcCallback(NULL),
 90410:     gcSliceCallback(NULL),
 91339:     gcFinalizeCallback(NULL),
 99043:     gcMallocBytes(0),
 80159:     gcBlackRootsTraceOp(NULL),
 80159:     gcBlackRootsData(NULL),
 80159:     gcGrayRootsTraceOp(NULL),
 80159:     gcGrayRootsData(NULL),
 91250:     autoGCRooters(NULL),
 94574:     scriptAndCountsVector(NULL),
 79507:     NaNValue(UndefinedValue()),
 79507:     negativeInfinityValue(UndefinedValue()),
 79507:     positiveInfinityValue(UndefinedValue()),
 79507:     emptyString(NULL),
 79507:     debugMode(false),
104307:     spsProfiler(thisFromCtor()),
 84803:     profilingScripts(false),
 98147:     alwaysPreserveCode(false),
 79507:     hadOutOfMemory(false),
 98921:     debugScopes(NULL),
 79507:     data(NULL),
 79507:     gcLock(NULL),
 80215:     gcHelperThread(thisFromCtor()),
 94740:     defaultFreeOp_(thisFromCtor(), false, false),
 79507:     debuggerMutations(0),
 91900:     securityCallbacks(const_cast<JSSecurityCallbacks *>(&NullSecurityCallbacks)),
 91900:     destroyPrincipals(NULL),
 80748:     structuredCloneCallbacks(NULL),
 80213:     telemetryCallback(NULL),
 79507:     propertyRemovals(0),
 79507:     thousandsSeparator(0),
 79507:     decimalSeparator(0),
 79507:     numGrouping(0),
 88135:     waiveGCQuota(false),
 97464:     mathCache_(NULL),
 88135:     dtoaState(NULL),
 88135:     pendingProxyOperation(NULL),
 79507:     trustedPrincipals_(NULL),
 88135:     wrapObjectCallback(TransparentObjectWrapper),
 98430:     sameCompartmentWrapObjectCallback(NULL),
 79507:     preWrapObjectCallback(NULL),
 84729:     preserveWrapperCallback(NULL),
 88135: #ifdef DEBUG
 88135:     noGCOrAllocationCheck(0),
 88135: #endif
 90598:     inOOMReport(0),
 90598:     jitHardening(false)
 34299: {
 34299:     /* Initialize infallibly first, so we can goto bad and JS_DestroyRuntime. */
 34299:     JS_INIT_CLIST(&contextList);
 75451:     JS_INIT_CLIST(&debuggerList);
 79507: 
 91178:     PodZero(&debugHooks);
 79507:     PodZero(&atomState);
 89261: 
 89261: #if JS_STACK_GROWTH_DIRECTION > 0
 89261:     nativeStackLimit = UINTPTR_MAX;
 89261: #endif
 34299: }
 34299: 
 34299: bool
 84755: JSRuntime::init(uint32_t maxbytes)
 34299: {
 81562: #ifdef JS_THREADSAFE
 88135:     ownerThread_ = PR_GetCurrentThread();
 81562: #endif
 81562: 
 50491: #ifdef JS_METHODJIT_SPEW
 50491:     JMCheckLogging();
 50491: #endif
 50491: 
 64559:     if (!js_InitGC(this, maxbytes))
 64559:         return false;
 64559: 
 90410:     if (!gcMarker.init())
 90410:         return false;
 90410: 
 90934:     const char *size = getenv("JSGC_MARK_STACK_LIMIT");
 90934:     if (size)
 90934:         SetMarkStackLimit(this, atoi(size));
 90934: 
 64559:     if (!(atomsCompartment = this->new_<JSCompartment>(this)) ||
 77343:         !atomsCompartment->init(NULL) ||
 60584:         !compartments.append(atomsCompartment)) {
 64559:         Foreground::delete_(atomsCompartment);
 43286:         return false;
 47498:     }
 43286: 
 73901:     atomsCompartment->isSystemCompartment = true;
 91825:     atomsCompartment->setGCLastBytes(8192, 8192, GC_NORMAL);
 64559: 
 64559:     if (!js_InitAtomState(this))
 34299:         return false;
 40281: 
 72090:     if (!InitRuntimeNumberState(this))
 72090:         return false;
 72090: 
 88135:     dtoaState = js_NewDtoaState();
 88135:     if (!dtoaState)
 88135:         return false;
 88135: 
 88135:     if (!stackSpace.init())
 88135:         return false;
 88135: 
 97463:     if (!scriptFilenameTable.init())
 97463:         return false;
 97463: 
104377:     if (!evalCache.init())
104377:         return false;
104377: 
 98921:     debugScopes = this->new_<DebugScopes>(this);
 98921:     if (!debugScopes || !debugScopes->init()) {
 98921:         Foreground::delete_(debugScopes);
 98921:         return false;
 98921:     }
 98921: 
 89261:     nativeStackBase = GetNativeStackBase();
 72090:     return true;
 34299: }
 34299: 
 34299: JSRuntime::~JSRuntime()
 34299: {
 98921:     JS_ASSERT(onOwnerThread());
 98921: 
 98921:     delete_(debugScopes);
 98921: 
 97463:     /*
 97463:      * Even though all objects in the compartment are dead, we may have keep
 97463:      * some filenames around because of gcKeepAtoms.
 97463:      */
 97463:     FreeScriptFilenames(this);
 97463: 
 34299: #ifdef DEBUG
 34299:     /* Don't hurt everyone in leaky ol' Mozilla with a fatal JS_ASSERT! */
 34299:     if (!JS_CLIST_IS_EMPTY(&contextList)) {
 91237:         unsigned cxcount = 0;
 91250:         for (ContextIter acx(this); !acx.done(); acx.next()) {
 34299:             fprintf(stderr,
 34299: "JS API usage error: found live context at %p\n",
 91266:                     (void *) acx.get());
 34299:             cxcount++;
 34299:         }
 34299:         fprintf(stderr,
 34299: "JS API usage error: %u context%s left in runtime upon JS_DestroyRuntime.\n",
 34299:                 cxcount, (cxcount == 1) ? "" : "s");
 34299:     }
 34299: #endif
 34299: 
 72090:     FinishRuntimeNumberState(this);
 34299:     js_FinishAtomState(this);
 34299: 
 88135:     if (dtoaState)
 88135:         js_DestroyDtoaState(dtoaState);
 88135: 
 34299:     js_FinishGC(this);
 34299: #ifdef JS_THREADSAFE
 34299:     if (gcLock)
 88135:         PR_DestroyLock(gcLock);
 34299: #endif
 97464: 
 97464:     delete_(bumpAlloc_);
 97464:     delete_(mathCache_);
 97464: #ifdef JS_METHODJIT
 97464:     delete_(jaegerRuntime_);
 97464: #endif
 97464:     delete_(execAlloc_);  /* Delete after jaegerRuntime_. */
 34299: }
 34299: 
 81562: #ifdef JS_THREADSAFE
 81562: void
 81562: JSRuntime::setOwnerThread()
 81562: {
 88135:     JS_ASSERT(ownerThread_ == (void *)0xc1ea12);  /* "clear" */
 88135:     JS_ASSERT(requestDepth == 0);
 88135:     ownerThread_ = PR_GetCurrentThread();
 89261:     nativeStackBase = GetNativeStackBase();
 89261:     if (nativeStackQuota)
 89261:         JS_SetNativeStackQuota(this, nativeStackQuota);
 81562: }
 81562: 
 81562: void
 81562: JSRuntime::clearOwnerThread()
 81562: {
 81562:     JS_ASSERT(onOwnerThread());
 88135:     JS_ASSERT(requestDepth == 0);
 88135:     ownerThread_ = (void *)0xc1ea12;  /* "clear" */
 89261:     nativeStackBase = 0;
 89261: #if JS_STACK_GROWTH_DIRECTION > 0
 89261:     nativeStackLimit = UINTPTR_MAX;
 89261: #else
 89261:     nativeStackLimit = 0;
 89261: #endif
 81562: }
 81562: 
 81562: JS_FRIEND_API(bool)
 81562: JSRuntime::onOwnerThread() const
 81562: {
 88135:     return ownerThread_ == PR_GetCurrentThread();
 88135: }
 88135: #endif  /* JS_THREADSAFE */
 81562: 
     1: JS_PUBLIC_API(JSRuntime *)
 84755: JS_NewRuntime(uint32_t maxbytes)
     1: {
 73748:     if (!js_NewRuntimeWasCalled) {
     1: #ifdef DEBUG
     1:         /*
     1:          * This code asserts that the numbers associated with the error names
     1:          * in jsmsg.def are monotonically increasing.  It uses values for the
     1:          * error names enumerated in jscntxt.c.  It's not a compile-time check
     1:          * but it's better than nothing.
     1:          */
     1:         int errorNumber = 0;
     1: #define MSG_DEF(name, number, count, exception, format)                       \
     1:     JS_ASSERT(name == errorNumber++);
     1: #include "js.msg"
     1: #undef MSG_DEF
     1: 
     1: #define MSG_DEF(name, number, count, exception, format)                       \
     1:     JS_BEGIN_MACRO                                                            \
 91237:         unsigned numfmtspecs = 0;                                                \
     1:         const char *fmt;                                                      \
     1:         for (fmt = format; *fmt != '\0'; fmt++) {                             \
     1:             if (*fmt == '{' && isdigit(fmt[1]))                               \
     1:                 ++numfmtspecs;                                                \
     1:         }                                                                     \
     1:         JS_ASSERT(count == numfmtspecs);                                      \
     1:     JS_END_MACRO;
     1: #include "js.msg"
     1: #undef MSG_DEF
 73748: #endif /* DEBUG */
     1: 
 89806:         InitMemorySubsystem();
 89806: 
  8893:         js_NewRuntimeWasCalled = JS_TRUE;
     1:     }
     1: 
 79507:     JSRuntime *rt = OffTheBooks::new_<JSRuntime>();
 79507:     if (!rt)
     1:         return NULL;
     1: 
 34299:     if (!rt->init(maxbytes)) {
     1:         JS_DestroyRuntime(rt);
     1:         return NULL;
     1:     }
     1: 
 74651:     Probes::createRuntime(rt);
 34299:     return rt;
 34299: }
 34299: 
     1: JS_PUBLIC_API(void)
     1: JS_DestroyRuntime(JSRuntime *rt)
     1: {
 74651:     Probes::destroyRuntime(rt);
 64559:     Foreground::delete_(rt);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ShutDown(void)
     1: {
 74651:     Probes::shutdown();
  3531:     PRMJ_NowShutdown();
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
     1: JS_GetRuntimePrivate(JSRuntime *rt)
     1: {
     1:     return rt->data;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetRuntimePrivate(JSRuntime *rt, void *data)
     1: {
     1:     rt->data = data;
     1: }
     1: 
 11277: #ifdef JS_THREADSAFE
 53548: static void
 53548: StartRequest(JSContext *cx)
 53548: {
 88135:     JSRuntime *rt = cx->runtime;
 88135:     JS_ASSERT(rt->onOwnerThread());
 88135: 
 88135:     if (rt->requestDepth) {
 88135:         rt->requestDepth++;
 88128:     } else {
     1:         /* Indicate that a request is running. */
 88135:         rt->requestDepth = 1;
 50462: 
 88567:         if (rt->activityCallback)
 50462:             rt->activityCallback(rt->activityCallbackArg, true);
 48481:     }
 53548: }
 53548: 
 47439: static void
 47439: StopRequest(JSContext *cx)
 47439: {
 88135:     JSRuntime *rt = cx->runtime;
 88135:     JS_ASSERT(rt->onOwnerThread());
 88135:     JS_ASSERT(rt->requestDepth != 0);
 88135:     if (rt->requestDepth != 1) {
 88135:         rt->requestDepth--;
 88128:     } else {
 88135:         rt->conservativeGC.updateForRequestEnd(rt->suspendCount);
 88135:         rt->requestDepth = 0;
  3624: 
 50463:         if (rt->activityCallback)
 50462:             rt->activityCallback(rt->activityCallbackArg, false);
 50462:     }
 48481: }
 53548: #endif /* JS_THREADSAFE */
 53548: 
 53548: JS_PUBLIC_API(void)
 53548: JS_BeginRequest(JSContext *cx)
 53548: {
 53548: #ifdef JS_THREADSAFE
 53548:     cx->outstandingRequests++;
 53548:     StartRequest(cx);
 47439: #endif
 53548: }
 47439: 
 47439: JS_PUBLIC_API(void)
 47439: JS_EndRequest(JSContext *cx)
 47439: {
 47439: #ifdef JS_THREADSAFE
 53548:     JS_ASSERT(cx->outstandingRequests != 0);
 53548:     cx->outstandingRequests--;
 47439:     StopRequest(cx);
 11277: #endif
     1: }
     1: 
     1: /* Yield to pending GC operations, regardless of request depth */
     1: JS_PUBLIC_API(void)
     1: JS_YieldRequest(JSContext *cx)
     1: {
 11277: #ifdef JS_THREADSAFE
     1:     CHECK_REQUEST(cx);
 11716:     JS_ResumeRequest(cx, JS_SuspendRequest(cx));
 11277: #endif
     1: }
     1: 
 91392: JS_PUBLIC_API(unsigned)
     1: JS_SuspendRequest(JSContext *cx)
     1: {
 11277: #ifdef JS_THREADSAFE
 88135:     JSRuntime *rt = cx->runtime;
 88135:     JS_ASSERT(rt->onOwnerThread());
 88135: 
 91392:     unsigned saveDepth = rt->requestDepth;
 53548:     if (!saveDepth)
 47439:         return 0;
 47439: 
 88135:     rt->suspendCount++;
 88135:     rt->requestDepth = 1;
 47439:     StopRequest(cx);
     1:     return saveDepth;
 11277: #else
 11277:     return 0;
 11277: #endif
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 91392: JS_ResumeRequest(JSContext *cx, unsigned saveDepth)
     1: {
 11277: #ifdef JS_THREADSAFE
 88135:     JSRuntime *rt = cx->runtime;
 88135:     JS_ASSERT(rt->onOwnerThread());
 47439:     if (saveDepth == 0)
 47439:         return;
 53548:     JS_ASSERT(saveDepth >= 1);
 88135:     JS_ASSERT(!rt->requestDepth);
 88135:     JS_ASSERT(rt->suspendCount);
 53548:     StartRequest(cx);
 88135:     rt->requestDepth = saveDepth;
 88135:     rt->suspendCount--;
 11277: #endif
 11277: }
     1: 
 58977: JS_PUBLIC_API(JSBool)
 88135: JS_IsInRequest(JSRuntime *rt)
 58977: {
 58977: #ifdef JS_THREADSAFE
 88135:     JS_ASSERT(rt->onOwnerThread());
 88135:     return rt->requestDepth != 0;
 88135: #else
 88135:     return false;
 88135: #endif
 88135: }
 88135: 
 88135: JS_PUBLIC_API(JSBool)
 88135: JS_IsInSuspendedRequest(JSRuntime *rt)
 88135: {
 88135: #ifdef JS_THREADSAFE
 88135:     JS_ASSERT(rt->onOwnerThread());
 88135:     return rt->suspendCount != 0;
 58978: #else
 58978:     return false;
 58977: #endif
 58977: }
 58977: 
     1: JS_PUBLIC_API(JSContextCallback)
     1: JS_SetContextCallback(JSRuntime *rt, JSContextCallback cxCallback)
     1: {
     1:     JSContextCallback old;
     1: 
     1:     old = rt->cxCallback;
     1:     rt->cxCallback = cxCallback;
     1:     return old;
     1: }
     1: 
     1: JS_PUBLIC_API(JSContext *)
     1: JS_NewContext(JSRuntime *rt, size_t stackChunkSize)
     1: {
 94960:     return NewContext(rt, stackChunkSize);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_DestroyContext(JSContext *cx)
     1: {
 94960:     DestroyContext(cx, DCM_FORCE_GC);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_DestroyContextNoGC(JSContext *cx)
     1: {
 94960:     DestroyContext(cx, DCM_NO_GC);
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
     1: JS_GetContextPrivate(JSContext *cx)
     1: {
     1:     return cx->data;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetContextPrivate(JSContext *cx, void *data)
     1: {
     1:     cx->data = data;
     1: }
     1: 
 86983: JS_PUBLIC_API(void *)
 86983: JS_GetSecondContextPrivate(JSContext *cx)
 86983: {
 86983:     return cx->data2;
 86983: }
 86983: 
 86983: JS_PUBLIC_API(void)
 86983: JS_SetSecondContextPrivate(JSContext *cx, void *data)
 86983: {
 86983:     cx->data2 = data;
 86983: }
 86983: 
     1: JS_PUBLIC_API(JSRuntime *)
     1: JS_GetRuntime(JSContext *cx)
     1: {
     1:     return cx->runtime;
     1: }
     1: 
     1: JS_PUBLIC_API(JSContext *)
     1: JS_ContextIterator(JSRuntime *rt, JSContext **iterp)
     1: {
 91250:     JSContext *cx = *iterp;
 91250:     JSCList *next = cx ? cx->link.next : rt->contextList.next;
 91250:     cx = (next == &rt->contextList) ? NULL : JSContext::fromLinkField(next);
 91250:     *iterp = cx;
 91250:     return cx;
 83122: }
 83122: 
     1: JS_PUBLIC_API(JSVersion)
     1: JS_GetVersion(JSContext *cx)
     1: {
 53848:     return VersionNumber(cx->findVersion());
 53848: }
 53848: 
     1: JS_PUBLIC_API(JSVersion)
 53848: JS_SetVersion(JSContext *cx, JSVersion newVersion)
 53848: {
 53848:     JS_ASSERT(VersionIsKnown(newVersion));
 53848:     JS_ASSERT(!VersionHasFlags(newVersion));
 53848:     JSVersion newVersionNumber = newVersion;
 53848: 
 61450: #ifdef DEBUG
 91237:     unsigned coptsBefore = cx->getCompileOptions();
 61450: #endif
 53848:     JSVersion oldVersion = cx->findVersion();
 53848:     JSVersion oldVersionNumber = VersionNumber(oldVersion);
 53848:     if (oldVersionNumber == newVersionNumber)
 53848:         return oldVersionNumber; /* No override actually occurs! */
 53628: 
 53628:     /* We no longer support 1.4 or below. */
 53848:     if (newVersionNumber != JSVERSION_DEFAULT && newVersionNumber <= JSVERSION_1_4)
 53848:         return oldVersionNumber;
 53848: 
 61450:     VersionCopyFlags(&newVersion, oldVersion);
 53848:     cx->maybeOverrideVersion(newVersion);
 61450:     JS_ASSERT(cx->getCompileOptions() == coptsBefore);
 53848:     return oldVersionNumber;
     1: }
     1: 
     1: static struct v2smap {
     1:     JSVersion   version;
     1:     const char  *string;
     1: } v2smap[] = {
     1:     {JSVERSION_1_0,     "1.0"},
     1:     {JSVERSION_1_1,     "1.1"},
     1:     {JSVERSION_1_2,     "1.2"},
     1:     {JSVERSION_1_3,     "1.3"},
     1:     {JSVERSION_1_4,     "1.4"},
     1:     {JSVERSION_ECMA_3,  "ECMAv3"},
     1:     {JSVERSION_1_5,     "1.5"},
     1:     {JSVERSION_1_6,     "1.6"},
     1:     {JSVERSION_1_7,     "1.7"},
  1981:     {JSVERSION_1_8,     "1.8"},
 34362:     {JSVERSION_ECMA_5,  "ECMAv5"},
     1:     {JSVERSION_DEFAULT, js_default_str},
     1:     {JSVERSION_UNKNOWN, NULL},          /* must be last, NULL is sentinel */
     1: };
     1: 
     1: JS_PUBLIC_API(const char *)
     1: JS_VersionToString(JSVersion version)
     1: {
     1:     int i;
     1: 
     1:     for (i = 0; v2smap[i].string; i++)
     1:         if (v2smap[i].version == version)
     1:             return v2smap[i].string;
     1:     return "unknown";
     1: }
     1: 
     1: JS_PUBLIC_API(JSVersion)
     1: JS_StringToVersion(const char *string)
     1: {
     1:     int i;
     1: 
     1:     for (i = 0; v2smap[i].string; i++)
     1:         if (strcmp(v2smap[i].string, string) == 0)
     1:             return v2smap[i].version;
     1:     return JSVERSION_UNKNOWN;
     1: }
     1: 
 84755: JS_PUBLIC_API(uint32_t)
     1: JS_GetOptions(JSContext *cx)
     1: {
 53848:     /*
 53848:      * Can't check option/version synchronization here.
 53848:      * We may have been synchronized with a script version that was formerly on
 53848:      * the stack, but has now been popped.
 53848:      */
 61450:     return cx->allOptions();
 61450: }
 61450: 
 91237: static unsigned
 91237: SetOptionsCommon(JSContext *cx, unsigned options)
 61450: {
 61450:     JS_ASSERT((options & JSALLOPTION_MASK) == options);
 91237:     unsigned oldopts = cx->allOptions();
 91237:     unsigned newropts = options & JSRUNOPTION_MASK;
 91237:     unsigned newcopts = options & JSCOMPILEOPTION_MASK;
 61450:     cx->setRunOptions(newropts);
 61450:     cx->setCompileOptions(newcopts);
 61450:     cx->updateJITEnabled();
 61450:     return oldopts;
     1: }
     1: 
 84755: JS_PUBLIC_API(uint32_t)
 84755: JS_SetOptions(JSContext *cx, uint32_t options)
     1: {
 61450:     return SetOptionsCommon(cx, options);
     1: }
     1: 
 84755: JS_PUBLIC_API(uint32_t)
 84755: JS_ToggleOptions(JSContext *cx, uint32_t options)
     1: {
 91237:     unsigned oldopts = cx->allOptions();
 91237:     unsigned newopts = oldopts ^ options;
 61450:     return SetOptionsCommon(cx, newopts);
     1: }
     1: 
 90106: JS_PUBLIC_API(void)
 90106: JS_SetJitHardening(JSRuntime *rt, JSBool enabled)
 90106: {
 90106:     rt->setJitHardening(!!enabled);
 90106: }
 90106: 
     1: JS_PUBLIC_API(const char *)
     1: JS_GetImplementationVersion(void)
     1: {
 68908:     return "JavaScript-C 1.8.5+ 2011-04-16";
     1: }
     1: 
 94740: JS_PUBLIC_API(void)
 94740: JS_SetDestroyCompartmentCallback(JSRuntime *rt, JSDestroyCompartmentCallback callback)
 94740: {
 94740:     rt->destroyCompartmentCallback = callback;
 48503: }
 48503: 
 47516: JS_PUBLIC_API(JSWrapObjectCallback)
 55628: JS_SetWrapObjectCallbacks(JSRuntime *rt,
 55628:                           JSWrapObjectCallback callback,
 98430:                           JSSameCompartmentWrapObjectCallback sccallback,
 55628:                           JSPreWrapCallback precallback)
 55574: {
 47516:     JSWrapObjectCallback old = rt->wrapObjectCallback;
 47516:     rt->wrapObjectCallback = callback;
 98430:     rt->sameCompartmentWrapObjectCallback = sccallback;
 55628:     rt->preWrapObjectCallback = precallback;
 47516:     return old;
 47516: }
 47516: 
 47498: JS_PUBLIC_API(JSCrossCompartmentCall *)
 47498: JS_EnterCrossCompartmentCall(JSContext *cx, JSObject *target)
 47498: {
103783:     AssertHeapIsIdle(cx);
 47498:     CHECK_REQUEST(cx);
 47498: 
 48470:     JS_ASSERT(target);
 64559:     AutoCompartment *call = cx->new_<AutoCompartment>(cx, target);
 47498:     if (!call)
 47498:         return NULL;
 47498:     if (!call->enter()) {
 64559:         Foreground::delete_(call);
 47498:         return NULL;
 47498:     }
 47498:     return reinterpret_cast<JSCrossCompartmentCall *>(call);
 47498: }
 47498: 
 80803: namespace js {
 80803: 
 74466: // Declared in jscompartment.h
 80803: Class dummy_class = {
 64190:     "jdummy",
 64190:     JSCLASS_GLOBAL_FLAGS,
 64190:     JS_PropertyStub,  JS_PropertyStub,
 64190:     JS_PropertyStub,  JS_StrictPropertyStub,
 64190:     JS_EnumerateStub, JS_ResolveStub,
 80803:     JS_ConvertStub
 64190: };
 64190: 
 80803: } /*namespace js */
 80803: 
 74466: JS_PUBLIC_API(JSCrossCompartmentCall *)
 74466: JS_EnterCrossCompartmentCallScript(JSContext *cx, JSScript *target)
 74466: {
103783:     AssertHeapIsIdle(cx);
 59883:     CHECK_REQUEST(cx);
103784:     GlobalObject *global = target->compartment()->maybeGlobal();
103784:     return global ? JS_EnterCrossCompartmentCall(cx, global) : NULL;
 59883: }
 59883: 
 74466: JS_PUBLIC_API(JSCrossCompartmentCall *)
 74466: JS_EnterCrossCompartmentCallStackFrame(JSContext *cx, JSStackFrame *target)
 74466: {
103783:     AssertHeapIsIdle(cx);
 74466:     CHECK_REQUEST(cx);
 74466: 
 96793:     return JS_EnterCrossCompartmentCall(cx, &Valueify(target)->global());
 74466: }
 74466: 
 47498: JS_PUBLIC_API(void)
 47498: JS_LeaveCrossCompartmentCall(JSCrossCompartmentCall *call)
 47498: {
 47498:     AutoCompartment *realcall = reinterpret_cast<AutoCompartment *>(call);
103783:     AssertHeapIsIdle(realcall->context);
 47498:     CHECK_REQUEST(realcall->context);
 47498:     realcall->leave();
 64559:     Foreground::delete_(realcall);
 47498: }
 47498: 
 48503: bool
 54733: JSAutoEnterCompartment::enter(JSContext *cx, JSObject *target)
 48503: {
105483:     AssertHeapIsIdleOrIterating(cx);
 79782:     JS_ASSERT(state == STATE_UNENTERED);
 79771:     if (cx->compartment == target->compartment()) {
 79782:         state = STATE_SAME_COMPARTMENT;
 48503:         return true;
 55631:     }
 79782: 
 79782:     JS_STATIC_ASSERT(sizeof(bytes) == sizeof(AutoCompartment));
 79782:     CHECK_REQUEST(cx);
 79782:     AutoCompartment *call = new (bytes) AutoCompartment(cx, target);
 79782:     if (call->enter()) {
 79782:         state = STATE_OTHER_COMPARTMENT;
 79782:         return true;
 79782:     }
 79782:     return false;
 48503: }
 48503: 
 64190: void
 64190: JSAutoEnterCompartment::enterAndIgnoreErrors(JSContext *cx, JSObject *target)
 64190: {
 64190:     (void) enter(cx, target);
 64190: }
 64190: 
101863: void
101863: JSAutoEnterCompartment::leave()
101863: {
101863:     JS_ASSERT(entered());
 79782:     if (state == STATE_OTHER_COMPARTMENT) {
 94849:         AutoCompartment* ac = getAutoCompartment();
 79782:         CHECK_REQUEST(ac->context);
 79782:         ac->~AutoCompartment();
 79782:     }
101863:     state = STATE_UNENTERED;
101863: }
101863: 
101863: JSAutoEnterCompartment::~JSAutoEnterCompartment()
101863: {
101863:     if (entered())
101863:         leave();
 79782: }
 79782: 
 64190: namespace JS {
 64190: 
 59883: bool
 64190: AutoEnterScriptCompartment::enter(JSContext *cx, JSScript *target)
 59883: {
 59883:     JS_ASSERT(!call);
 77659:     if (cx->compartment == target->compartment()) {
 59883:         call = reinterpret_cast<JSCrossCompartmentCall*>(1);
 59883:         return true;
 59883:     }
 59883:     call = JS_EnterCrossCompartmentCallScript(cx, target);
 59883:     return call != NULL;
 59883: }
 59883: 
 74466: bool
 74466: AutoEnterFrameCompartment::enter(JSContext *cx, JSStackFrame *target)
 74466: {
 74466:     JS_ASSERT(!call);
 96793:     if (cx->compartment == Valueify(target)->scopeChain()->compartment()) {
 74466:         call = reinterpret_cast<JSCrossCompartmentCall*>(1);
 74466:         return true;
 74466:     }
 74466:     call = JS_EnterCrossCompartmentCallStackFrame(cx, target);
 74466:     return call != NULL;
 74466: }
 74466: 
 64190: } /* namespace JS */
 48503: 
 91250: JS_PUBLIC_API(void)
 91250: JS_SetCompartmentPrivate(JSCompartment *compartment, void *data)
 91250: {
 91250:     compartment->data = data;
 91250: }
 91250: 
 48503: JS_PUBLIC_API(void *)
 91250: JS_GetCompartmentPrivate(JSCompartment *compartment)
 91250: {
 91250:     return compartment->data;
 48503: }
 48503: 
 51450: JS_PUBLIC_API(JSBool)
 51450: JS_WrapObject(JSContext *cx, JSObject **objp)
 51450: {
103783:     AssertHeapIsIdle(cx);
 51450:     CHECK_REQUEST(cx);
 51450:     return cx->compartment->wrap(cx, objp);
 51450: }
 51450: 
 51450: JS_PUBLIC_API(JSBool)
 51450: JS_WrapValue(JSContext *cx, jsval *vp)
 51450: {
103783:     AssertHeapIsIdle(cx);
 51450:     CHECK_REQUEST(cx);
 78614:     return cx->compartment->wrap(cx, vp);
 51450: }
 51450: 
 98380: /*
 98380:  * Identity remapping. Not for casual consumers.
 98380:  *
 98380:  * Normally, an object's contents and its identity are inextricably linked.
 98380:  * Identity is determined by the address of the JSObject* in the heap, and
 98380:  * the contents are what is located at that address. Transplanting allows these
 98380:  * concepts to be separated through a combination of swapping (exchanging the
 98380:  * contents of two same-compartment objects) and remapping cross-compartment
 98380:  * identities by altering wrappers.
 98380:  *
 98380:  * The |origobj| argument should be the object whose identity needs to be
 98380:  * remapped, usually to another compartment. The contents of |origobj| are
 98380:  * destroyed.
 98380:  *
 98380:  * The |target| argument serves two purposes:
 98380:  *
 98380:  * First, |target| serves as a hint for the new identity of the object. The new
 98380:  * identity object will always be in the same compartment as |target|, but
 98380:  * if that compartment already had an object representing |origobj| (either a
 98380:  * cross-compartment wrapper for it, or |origobj| itself if the two arguments
 98380:  * are same-compartment), the existing object is used. Otherwise, |target|
 98380:  * itself is used. To avoid ambiguity, JS_TransplantObject always returns the
 98380:  * new identity.
 98380:  *
 98380:  * Second, the new identity object's contents will be those of |target|. A swap()
 98380:  * is used to make this happen if an object other than |target| is used.
 98380:  */
 98380: 
     1: JS_PUBLIC_API(JSObject *)
 58534: JS_TransplantObject(JSContext *cx, JSObject *origobj, JSObject *target)
 58534: {
103783:     AssertHeapIsIdle(cx);
 98380:     JS_ASSERT(origobj != target);
 99134:     JS_ASSERT(!IsCrossCompartmentWrapper(origobj));
 99134:     JS_ASSERT(!IsCrossCompartmentWrapper(target));
 98380: 
104658:     /*
104658:      * Transplantation typically allocates new wrappers in every compartment. If
104658:      * an incremental GC is active, this causes every compartment to be leaked
104658:      * for that GC. Hence, we finish any ongoing incremental GC before the
104658:      * transplant to avoid leaks.
104658:      */
104658:     if (cx->runtime->gcIncrementalState != NO_INCREMENTAL)
104658:         FinishIncrementalGC(cx->runtime, gcreason::TRANSPLANT);
104658: 
 79734:     JSCompartment *destination = target->compartment();
 62643:     WrapperMap &map = destination->crossCompartmentWrappers;
 62643:     Value origv = ObjectValue(*origobj);
 98381:     JSObject *newIdentity;
 62643: 
 79734:     if (origobj->compartment() == destination) {
 58534:         // If the original object is in the same compartment as the
 99134:         // destination, then we know that we won't find a wrapper in the
 62643:         // destination's cross compartment map and that the same
 98380:         // object will continue to work.
 98380:         if (!origobj->swap(cx, target))
 55746:             return NULL;
 98381:         newIdentity = origobj;
 62643:     } else if (WrapperMap::Ptr p = map.lookup(origv)) {
 62643:         // There might already be a wrapper for the original object in
 98380:         // the new compartment. If there is, we use its identity and swap
 98380:         // in the contents of |target|.
 98381:         newIdentity = &p->value.toObject();
 99134: 
 99134:         // When we remove origv from the wrapper map, its wrapper, newIdentity,
 99134:         // must immediately cease to be a cross-compartment wrapper. Neuter it.
 55574:         map.remove(p);
 99134:         NukeCrossCompartmentWrapper(newIdentity);
 99134: 
 98381:         if (!newIdentity->swap(cx, target))
 55746:             return NULL;
 55574:     } else {
 98380:         // Otherwise, we use |target| for the new identity object.
 98381:         newIdentity = target;
 98381:     }
 55574: 
 62643:     // Now, iterate through other scopes looking for references to the
 98380:     // old object, and update the relevant cross-compartment wrappers.
103588:     if (!RemapAllWrappersForObject(cx, origobj, newIdentity))
 64229:         return NULL;
 55751: 
 58534:     // Lastly, update the original object to point to the new one.
 79734:     if (origobj->compartment() != destination) {
 58534:         AutoCompartment ac(cx, origobj);
 98381:         JSObject *newIdentityWrapper = newIdentity;
 98381:         if (!ac.enter() || !JS_WrapObject(cx, &newIdentityWrapper))
 55610:             return NULL;
 98381:         if (!origobj->swap(cx, newIdentityWrapper))
 55746:             return NULL;
 99134:         origobj->compartment()->crossCompartmentWrappers.put(ObjectValue(*newIdentity), origv);
 55574:     }
 55574: 
 98380:     // The new identity object might be one of several things. Return it to avoid
 98380:     // ambiguity.
 98381:     return newIdentity;
 55574: }
 55574: 
 62975: /*
 62975:  * The location object is special. There is the location object itself and
 62975:  * then the location object wrapper. Because there are no direct references to
 62975:  * the location object itself, we don't want the old obj (|origobj| here) to
 62975:  * become the new wrapper but the wrapper itself instead. This leads to very
 62975:  * subtle differences between js_TransplantObjectWithWrapper and
 62975:  * JS_TransplantObject.
 62975:  */
 62975: JS_FRIEND_API(JSObject *)
 62975: js_TransplantObjectWithWrapper(JSContext *cx,
 62975:                                JSObject *origobj,
 62975:                                JSObject *origwrapper,
 62975:                                JSObject *targetobj,
 62975:                                JSObject *targetwrapper)
 62975: {
103783:     AssertHeapIsIdle(cx);
 99134:     JS_ASSERT(!IsCrossCompartmentWrapper(origobj));
 99134:     JS_ASSERT(!IsCrossCompartmentWrapper(origwrapper));
 99245:     JS_ASSERT(!IsCrossCompartmentWrapper(targetobj));
 99245:     JS_ASSERT(!IsCrossCompartmentWrapper(targetwrapper));
 86458: 
 98383:     JSObject *newWrapper;
 79734:     JSCompartment *destination = targetobj->compartment();
 62975:     WrapperMap &map = destination->crossCompartmentWrappers;
 62975: 
 62975:     // |origv| is the map entry we're looking up. The map entries are going to
 98383:     // be for |origobj|, not |origwrapper|.
 62975:     Value origv = ObjectValue(*origobj);
 62975: 
 62975:     // There might already be a wrapper for the original object in the new
 62975:     // compartment.
 62975:     if (WrapperMap::Ptr p = map.lookup(origv)) {
 98383:         // There is. Make the existing cross-compartment wrapper a same-
 98383:         // compartment wrapper.
 98383:         newWrapper = &p->value.toObject();
 99134: 
 99134:         // When we remove origv from the wrapper map, its wrapper, newWrapper,
 99134:         // must immediately cease to be a cross-compartment wrapper. Neuter it.
 62975:         map.remove(p);
 99134:         NukeCrossCompartmentWrapper(newWrapper);
 99134: 
 98383:         if (!newWrapper->swap(cx, targetwrapper))
 62975:             return NULL;
 62975:     } else {
 98383:         // Otherwise, use the passed-in wrapper as the same-compartment wrapper.
 98383:         newWrapper = targetwrapper;
 62975:     }
 62975: 
 62975:     // Now, iterate through other scopes looking for references to the old
 98383:     // object. Note that the entries in the maps are for |origobj| and not
 98383:     // |origwrapper|. They need to be updated to point at the new object.
103588:     if (!RemapAllWrappersForObject(cx, origobj, targetobj))
 64229:         return NULL;
 62975: 
 98383:     // Lastly, update things in the original compartment. Our invariants dictate
 98383:     // that the original compartment can only have one cross-compartment wrapper
 98383:     // to the new object. So we choose to update |origwrapper|, not |origobj|,
 98383:     // since theoretically there should have been no direct intra-compartment
 98383:     // references to |origobj|.
 62975:     {
 62975:         AutoCompartment ac(cx, origobj);
 98384:         JSObject *wrapperGuts = targetobj;
 98384:         if (!ac.enter() || !JS_WrapObject(cx, &wrapperGuts))
 62975:             return NULL;
 98384:         if (!origwrapper->swap(cx, wrapperGuts))
 62975:             return NULL;
 98382:         origwrapper->compartment()->crossCompartmentWrappers.put(ObjectValue(*targetobj),
 62975:                                                                  ObjectValue(*origwrapper));
 62975:     }
 62975: 
 98383:     return newWrapper;
 62975: }
 62975: 
 98380: /*
 98380:  * Recompute all cross-compartment wrappers for an object, resetting state.
 98380:  * Gecko uses this to clear Xray wrappers when doing a navigation that reuses
 98380:  * the inner window and global object.
 98380:  */
 98380: JS_PUBLIC_API(JSBool)
 98380: JS_RefreshCrossCompartmentWrappers(JSContext *cx, JSObject *obj)
 98380: {
103588:     return RemapAllWrappersForObject(cx, obj, obj);
 98380: }
 98380: 
 55574: JS_PUBLIC_API(JSObject *)
     1: JS_GetGlobalObject(JSContext *cx)
     1: {
     1:     return cx->globalObject;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetGlobalObject(JSContext *cx, JSObject *obj)
     1: {
103783:     AssertHeapIsIdle(cx);
 35586:     CHECK_REQUEST(cx);
 47517: 
     1:     cx->globalObject = obj;
 71696:     if (!cx->hasfp())
 55607:         cx->resetCompartment();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_InitStandardClasses(JSContext *cx, JSObject *obj)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
     1: 
 54154:     /*
 54154:      * JS_SetGlobalObject might or might not change cx's compartment, so call
 54154:      * it before assertSameCompartment. (The API contract is that *after* this,
 54154:      * cx and obj must be in the same compartment.)
 54154:      */
 54154:     if (!cx->globalObject)
 54154:         JS_SetGlobalObject(cx, obj);
 73906: 
 47485:     assertSameCompartment(cx, obj);
 43290: 
102586:     Rooted<GlobalObject*> global(cx, &obj->global());
102586:     return GlobalObject::initStandardClasses(cx, global);
     1: }
     1: 
 77817: #define CLASP(name)                 (&name##Class)
 97573: #define TYPED_ARRAY_CLASP(type)     (&TypedArray::classes[TypedArray::type])
 97886: #define EAGER_ATOM(name)            NAME_OFFSET(name)
 97886: #define EAGER_CLASS_ATOM(name)      CLASS_NAME_OFFSET(name)
     1: #define EAGER_ATOM_AND_CLASP(name)  EAGER_CLASS_ATOM(name), CLASP(name)
     1: 
     1: typedef struct JSStdName {
 98960:     JSClassInitializerOp init;
     1:     size_t      atomOffset;     /* offset of atom pointer in JSAtomState */
 48470:     Class       *clasp;
     1: } JSStdName;
     1: 
 97828: static PropertyName *
 97828: StdNameToPropertyName(JSContext *cx, JSStdName *stdn)
     1: {
 97886:     return OFFSET_TO_NAME(cx->runtime, stdn->atomOffset);
     1: }
     1: 
     1: /*
     1:  * Table of class initializers and their atom offsets in rt->atomState.
     1:  * If you add a "standard" class, remember to update this table.
     1:  */
     1: static JSStdName standard_class_atoms[] = {
 78468:     {js_InitFunctionClass,              EAGER_ATOM_AND_CLASP(Function)},
 78468:     {js_InitObjectClass,                EAGER_ATOM_AND_CLASP(Object)},
     1:     {js_InitArrayClass,                 EAGER_ATOM_AND_CLASP(Array)},
     1:     {js_InitBooleanClass,               EAGER_ATOM_AND_CLASP(Boolean)},
     1:     {js_InitDateClass,                  EAGER_ATOM_AND_CLASP(Date)},
     1:     {js_InitMathClass,                  EAGER_ATOM_AND_CLASP(Math)},
     1:     {js_InitNumberClass,                EAGER_ATOM_AND_CLASP(Number)},
     1:     {js_InitStringClass,                EAGER_ATOM_AND_CLASP(String)},
     1:     {js_InitExceptionClasses,           EAGER_ATOM_AND_CLASP(Error)},
     1:     {js_InitRegExpClass,                EAGER_ATOM_AND_CLASP(RegExp)},
     1: #if JS_HAS_XML_SUPPORT
     1:     {js_InitXMLClass,                   EAGER_ATOM_AND_CLASP(XML)},
 48622:     {js_InitNamespaceClass,             EAGER_ATOM_AND_CLASP(Namespace)},
 48622:     {js_InitQNameClass,                 EAGER_ATOM_AND_CLASP(QName)},
     1: #endif
     1: #if JS_HAS_GENERATORS
     1:     {js_InitIteratorClasses,            EAGER_ATOM_AND_CLASP(StopIteration)},
     1: #endif
 20092:     {js_InitJSONClass,                  EAGER_ATOM_AND_CLASP(JSON)},
 96828:     {js_InitTypedArrayClasses,          EAGER_CLASS_ATOM(ArrayBuffer), &js::ArrayBufferObject::protoClass},
 72067:     {js_InitWeakMapClass,               EAGER_CLASS_ATOM(WeakMap), &js::WeakMapClass},
 87812:     {js_InitMapClass,                   EAGER_CLASS_ATOM(Map), &js::MapObject::class_},
 87812:     {js_InitSetClass,                   EAGER_CLASS_ATOM(Set), &js::SetObject::class_},
 97886:     {NULL,                              0, NULL}
     1: };
     1: 
     1: /*
     1:  * Table of top-level function and constant names and their init functions.
     1:  * If you add a "standard" global function or property, remember to update
     1:  * this table.
     1:  */
     1: static JSStdName standard_class_names[] = {
 43236:     {js_InitObjectClass,        EAGER_ATOM(eval), CLASP(Object)},
     1: 
     1:     /* Global properties and functions defined by the Number class. */
 57823:     {js_InitNumberClass,        EAGER_ATOM(NaN), CLASP(Number)},
 57823:     {js_InitNumberClass,        EAGER_ATOM(Infinity), CLASP(Number)},
 97886:     {js_InitNumberClass,        EAGER_ATOM(isNaN), CLASP(Number)},
 97886:     {js_InitNumberClass,        EAGER_ATOM(isFinite), CLASP(Number)},
 97886:     {js_InitNumberClass,        EAGER_ATOM(parseFloat), CLASP(Number)},
 97886:     {js_InitNumberClass,        EAGER_ATOM(parseInt), CLASP(Number)},
     1: 
     1:     /* String global functions. */
 97886:     {js_InitStringClass,        EAGER_ATOM(escape), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(unescape), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(decodeURI), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(encodeURI), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(decodeURIComponent), CLASP(String)},
 97886:     {js_InitStringClass,        EAGER_ATOM(encodeURIComponent), CLASP(String)},
     1: #if JS_HAS_UNEVAL
 97886:     {js_InitStringClass,        EAGER_ATOM(uneval), CLASP(String)},
     1: #endif
     1: 
     1:     /* Exception constructors. */
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(Error), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(InternalError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(EvalError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(RangeError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(ReferenceError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(SyntaxError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(TypeError), CLASP(Error)},
     1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(URIError), CLASP(Error)},
     1: 
     1: #if JS_HAS_XML_SUPPORT
 97886:     {js_InitXMLClass,           EAGER_ATOM(XMLList), CLASP(XML)},
 97886:     {js_InitXMLClass,           EAGER_ATOM(isXMLName), CLASP(XML)},
     1: #endif
     1: 
103624: #if JS_HAS_GENERATORS
103627:     {js_InitIteratorClasses,    EAGER_ATOM_AND_CLASP(Iterator)},
103624: #endif
     1: 
 37042:     /* Typed Arrays */
 77817:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(ArrayBuffer),  &ArrayBufferClass},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Int8Array),    TYPED_ARRAY_CLASP(TYPE_INT8)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint8Array),   TYPED_ARRAY_CLASP(TYPE_UINT8)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Int16Array),   TYPED_ARRAY_CLASP(TYPE_INT16)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint16Array),  TYPED_ARRAY_CLASP(TYPE_UINT16)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Int32Array),   TYPED_ARRAY_CLASP(TYPE_INT32)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint32Array),  TYPED_ARRAY_CLASP(TYPE_UINT32)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Float32Array), TYPED_ARRAY_CLASP(TYPE_FLOAT32)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Float64Array), TYPED_ARRAY_CLASP(TYPE_FLOAT64)},
 48622:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(Uint8ClampedArray),
 48622:                                 TYPED_ARRAY_CLASP(TYPE_UINT8_CLAMPED)},
 97574:     {js_InitTypedArrayClasses,  EAGER_CLASS_ATOM(DataView),     &DataViewClass},
 43236: 
 87674:     {js_InitWeakMapClass,       EAGER_ATOM_AND_CLASP(WeakMap)},
 43236:     {js_InitProxyClass,         EAGER_ATOM_AND_CLASP(Proxy)},
 42733: 
 97886:     {NULL,                      0, NULL}
     1: };
     1: 
     1: static JSStdName object_prototype_names[] = {
     1:     /* Object.prototype properties (global delegates to Object.prototype). */
 43236:     {js_InitObjectClass,        EAGER_ATOM(proto), CLASP(Object)},
     1: #if JS_HAS_TOSOURCE
 43236:     {js_InitObjectClass,        EAGER_ATOM(toSource), CLASP(Object)},
     1: #endif
 43236:     {js_InitObjectClass,        EAGER_ATOM(toString), CLASP(Object)},
 43236:     {js_InitObjectClass,        EAGER_ATOM(toLocaleString), CLASP(Object)},
 43236:     {js_InitObjectClass,        EAGER_ATOM(valueOf), CLASP(Object)},
     1: #if JS_HAS_OBJ_WATCHPOINT
 97886:     {js_InitObjectClass,        EAGER_ATOM(watch), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(unwatch), CLASP(Object)},
     1: #endif
 97886:     {js_InitObjectClass,        EAGER_ATOM(hasOwnProperty), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(isPrototypeOf), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(propertyIsEnumerable), CLASP(Object)},
 40855: #if OLD_GETTER_SETTER_METHODS
 97886:     {js_InitObjectClass,        EAGER_ATOM(defineGetter), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(defineSetter), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(lookupGetter), CLASP(Object)},
 97886:     {js_InitObjectClass,        EAGER_ATOM(lookupSetter), CLASP(Object)},
     1: #endif
     1: 
 97886:     {NULL,                      0, NULL}
     1: };
     1: 
     1: JS_PUBLIC_API(JSBool)
 99364: JS_ResolveStandardClass(JSContext *cx, JSObject *obj_, jsid id, JSBool *resolved)
     1: {
     1:     JSString *idstr;
     1:     JSRuntime *rt;
     1:     JSAtom *atom;
     1:     JSStdName *stdnm;
 91237:     unsigned i;
     1: 
 99421:     RootedObject obj(cx, obj_);
 86437: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 99822:     *resolved = false;
     1: 
  4556:     rt = cx->runtime;
 87611:     if (!rt->hasContexts() || !JSID_IS_ATOM(id))
 99822:         return true;
  4556: 
 48470:     idstr = JSID_TO_STRING(id);
     1: 
     1:     /* Check whether we're resolving 'undefined', and define it if so. */
     1:     atom = rt->atomState.typeAtoms[JSTYPE_VOID];
 64345:     if (idstr == atom) {
 99822:         *resolved = true;
 80624:         return obj->defineProperty(cx, atom->asPropertyName(), UndefinedValue(),
 78614:                                    JS_PropertyStub, JS_StrictPropertyStub,
 37031:                                    JSPROP_PERMANENT | JSPROP_READONLY);
     1:     }
     1: 
     1:     /* Try for class constructors/prototypes named by well-known atoms. */
     1:     stdnm = NULL;
     1:     for (i = 0; standard_class_atoms[i].init; i++) {
 43236:         JS_ASSERT(standard_class_atoms[i].clasp);
 97828:         atom = OFFSET_TO_NAME(rt, standard_class_atoms[i].atomOffset);
 64345:         if (idstr == atom) {
     1:             stdnm = &standard_class_atoms[i];
     1:             break;
     1:         }
     1:     }
     1: 
     1:     if (!stdnm) {
     1:         /* Try less frequently used top-level functions and constants. */
     1:         for (i = 0; standard_class_names[i].init; i++) {
 43236:             JS_ASSERT(standard_class_names[i].clasp);
 97828:             atom = StdNameToPropertyName(cx, &standard_class_names[i]);
     1:             if (!atom)
 99822:                 return false;
 64345:             if (idstr == atom) {
     1:                 stdnm = &standard_class_names[i];
     1:                 break;
     1:             }
     1:         }
     1: 
 39928:         if (!stdnm && !obj->getProto()) {
     1:             /*
     1:              * Try even less frequently used names delegated from the global
     1:              * object to Object.prototype, but only if the Object class hasn't
     1:              * yet been initialized.
     1:              */
     1:             for (i = 0; object_prototype_names[i].init; i++) {
 43236:                 JS_ASSERT(object_prototype_names[i].clasp);
 97828:                 atom = StdNameToPropertyName(cx, &object_prototype_names[i]);
     1:                 if (!atom)
 99822:                     return false;
 64345:                 if (idstr == atom) {
 41243:                     stdnm = &object_prototype_names[i];
     1:                     break;
     1:                 }
     1:             }
     1:         }
     1:     }
     1: 
     1:     if (stdnm) {
     1:         /*
 43236:          * If this standard class is anonymous, then we don't want to resolve
 43236:          * by name.
     1:          */
 60566:         JS_ASSERT(obj->isGlobal());
 43236:         if (stdnm->clasp->flags & JSCLASS_IS_ANONYMOUS)
 99822:             return true;
 43236: 
 69232:         if (IsStandardClassResolved(obj, stdnm->clasp))
 99822:             return true;
 99822: 
 99822: #if JS_HAS_XML_SUPPORT
 99822:         if ((stdnm->init == js_InitXMLClass ||
 99822:              stdnm->init == js_InitNamespaceClass ||
 99822:              stdnm->init == js_InitQNameClass) &&
 99822:             !VersionHasAllowXML(cx->findVersion()))
 99822:         {
 99822:             return true;
 99822:         }
 99822: #endif
     1: 
     1:         if (!stdnm->init(cx, obj))
 99822:             return false;
 99822:         *resolved = true;
 99822:     }
 99822:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 97353: JS_EnumerateStandardClasses(JSContext *cx, JSObject *obj_)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 97353:     assertSameCompartment(cx, obj_);
     1: 
 99421:     RootedObject obj(cx, obj_);
 97353: 
 69232:     /*
 69232:      * Check whether we need to bind 'undefined' and define it if so.
 69232:      * Since ES5 15.1.1.3 undefined can't be deleted.
 69232:      */
104205:     RootedPropertyName undefinedName(cx, cx->runtime->atomState.typeAtoms[JSTYPE_VOID]);
104205:     RootedId undefinedId(cx, NameToId(undefinedName));
104205:     if (!obj->nativeContains(cx, undefinedId) &&
104205:         !obj->defineProperty(cx, undefinedName, UndefinedValue(),
 78614:                              JS_PropertyStub, JS_StrictPropertyStub,
 39915:                              JSPROP_PERMANENT | JSPROP_READONLY)) {
 99822:         return false;
     1:     }
     1: 
 69232:     /* Initialize any classes that have not been initialized yet. */
 99822:     for (unsigned i = 0; standard_class_atoms[i].init; i++) {
 99822:         const JSStdName &stdnm = standard_class_atoms[i];
 99945:         if (!js::IsStandardClassResolved(obj, stdnm.clasp)
 99822: #if JS_HAS_XML_SUPPORT
 99945:             && ((stdnm.init != js_InitXMLClass &&
 99822:                  stdnm.init != js_InitNamespaceClass &&
 99822:                  stdnm.init != js_InitQNameClass) ||
 99822:                 VersionHasAllowXML(cx->findVersion()))
 99822: #endif
 99822:             )
 99822:         {
 99822:             if (!stdnm.init(cx, obj))
 99822:                 return false;
 99822:         }
 99822:     }
 99822: 
 99822:     return true;
     1: }
     1: 
 82129: static JSIdArray *
 91450: NewIdArray(JSContext *cx, int length)
 67898: {
 67898:     JSIdArray *ida;
 67898: 
 67898:     ida = (JSIdArray *)
 67898:         cx->calloc_(offsetof(JSIdArray, vector) + length * sizeof(jsval));
 67898:     if (ida)
 67898:         ida->length = length;
 67898:     return ida;
 67898: }
 67898: 
 67898: /*
 67898:  * Unlike realloc(3), this function frees ida on failure.
 67898:  */
 67898: static JSIdArray *
 91450: SetIdArrayLength(JSContext *cx, JSIdArray *ida, int length)
 67898: {
 67898:     JSIdArray *rida;
 67898: 
 67898:     rida = (JSIdArray *)
 67898:            JS_realloc(cx, ida,
 67898:                       offsetof(JSIdArray, vector) + length * sizeof(jsval));
 67898:     if (!rida) {
 67898:         JS_DestroyIdArray(cx, ida);
 67898:     } else {
 67898:         rida->length = length;
 67898:     }
 67898:     return rida;
 67898: }
 67898: 
 67898: static JSIdArray *
 97828: AddNameToArray(JSContext *cx, PropertyName *name, JSIdArray *ida, int *ip)
 91450: {
 91450:     int i = *ip;
 91450:     int length = ida->length;
 67898:     if (i >= length) {
 67898:         ida = SetIdArrayLength(cx, ida, JS_MAX(length * 2, 8));
 67898:         if (!ida)
 67898:             return NULL;
 67898:         JS_ASSERT(i < ida->length);
 67898:     }
 97828:     ida->vector[i].init(NameToId(name));
 67898:     *ip = i + 1;
 67898:     return ida;
 67898: }
 67898: 
 67898: static JSIdArray *
 97828: EnumerateIfResolved(JSContext *cx, JSObject *obj, PropertyName *name, JSIdArray *ida,
 91450:                     int *ip, JSBool *foundp)
 67898: {
104205:     RootedId id(cx, NameToId(name));
104205:     *foundp = obj->nativeContains(cx, id);
 67898:     if (*foundp)
 97828:         ida = AddNameToArray(cx, name, ida, ip);
 67898:     return ida;
 67898: }
 67898: 
 67898: JS_PUBLIC_API(JSIdArray *)
 67898: JS_EnumerateResolvedStandardClasses(JSContext *cx, JSObject *obj, JSIdArray *ida)
 67898: {
 67898:     JSRuntime *rt;
 91450:     int i, j, k;
 97828:     PropertyName *name;
 67898:     JSBool found;
 98960:     JSClassInitializerOp init;
 67898: 
103783:     AssertHeapIsIdle(cx);
 67898:     CHECK_REQUEST(cx);
 67898:     assertSameCompartment(cx, obj, ida);
 67898:     rt = cx->runtime;
 67898:     if (ida) {
 67898:         i = ida->length;
 67898:     } else {
 67898:         ida = NewIdArray(cx, 8);
 67898:         if (!ida)
 67898:             return NULL;
 67898:         i = 0;
 67898:     }
 67898: 
 67898:     /* Check whether 'undefined' has been resolved and enumerate it if so. */
 97828:     name = rt->atomState.typeAtoms[JSTYPE_VOID];
 97828:     ida = EnumerateIfResolved(cx, obj, name, ida, &i, &found);
 67898:     if (!ida)
 67898:         return NULL;
 67898: 
 67898:     /* Enumerate only classes that *have* been resolved. */
 67898:     for (j = 0; standard_class_atoms[j].init; j++) {
 97828:         name = OFFSET_TO_NAME(rt, standard_class_atoms[j].atomOffset);
 97828:         ida = EnumerateIfResolved(cx, obj, name, ida, &i, &found);
 67898:         if (!ida)
 67898:             return NULL;
 67898: 
 67898:         if (found) {
 67898:             init = standard_class_atoms[j].init;
 67898: 
 67898:             for (k = 0; standard_class_names[k].init; k++) {
 67898:                 if (standard_class_names[k].init == init) {
 97828:                     name = StdNameToPropertyName(cx, &standard_class_names[k]);
 97828:                     ida = AddNameToArray(cx, name, ida, &i);
 67898:                     if (!ida)
 67898:                         return NULL;
 67898:                 }
 67898:             }
 67898: 
 67898:             if (init == js_InitObjectClass) {
 67898:                 for (k = 0; object_prototype_names[k].init; k++) {
 97828:                     name = StdNameToPropertyName(cx, &object_prototype_names[k]);
 97828:                     ida = AddNameToArray(cx, name, ida, &i);
 67898:                     if (!ida)
 67898:                         return NULL;
 67898:                 }
 67898:             }
 67898:         }
 67898:     }
 67898: 
 67898:     /* Trim to exact length. */
 67898:     return SetIdArrayLength(cx, ida, i);
 67898: }
 67898: 
     1: #undef CLASP
     1: #undef EAGER_ATOM
     1: #undef EAGER_CLASS_ATOM
     1: #undef EAGER_ATOM_CLASP
     1: 
     1: JS_PUBLIC_API(JSBool)
103636: JS_GetClassObject(JSContext *cx, JSObject *obj_, JSProtoKey key, JSObject **objp_)
103636: {
103783:     AssertHeapIsIdle(cx);
103636:     CHECK_REQUEST(cx);
103636:     RootedObject obj(cx, obj_);
103636:     RootedObject objp(cx);
 47485:     assertSameCompartment(cx, obj);
103636:     bool result = js_GetClassObject(cx, obj, key, &objp);
103636:     *objp_ = objp;
103636:     return result;
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
 89843: JS_GetObjectPrototype(JSContext *cx, JSObject *forObj)
 89843: {
 89843:     CHECK_REQUEST(cx);
 89843:     assertSameCompartment(cx, forObj);
 89843:     return forObj->global().getOrCreateObjectPrototype(cx);
 89843: }
 89843: 
 89843: JS_PUBLIC_API(JSObject *)
 90619: JS_GetFunctionPrototype(JSContext *cx, JSObject *forObj)
 90619: {
 90619:     CHECK_REQUEST(cx);
 90619:     assertSameCompartment(cx, forObj);
 90619:     return forObj->global().getOrCreateFunctionPrototype(cx);
 90619: }
 90619: 
 90619: JS_PUBLIC_API(JSObject *)
  4427: JS_GetGlobalForObject(JSContext *cx, JSObject *obj)
  4427: {
103783:     AssertHeapIsIdle(cx);
 47485:     assertSameCompartment(cx, obj);
 86483:     return &obj->global();
  4427: }
  4427: 
 42766: JS_PUBLIC_API(JSObject *)
103785: JS_GetGlobalForCompartmentOrNull(JSContext *cx, JSCompartment *c)
103785: {
103785:     AssertHeapIsIdleOrIterating(cx);
103785:     assertSameCompartment(cx, c);
103785:     return c->maybeGlobal();
103785: }
103785: 
103785: JS_PUBLIC_API(JSObject *)
 42766: JS_GetGlobalForScopeChain(JSContext *cx)
 42766: {
103783:     AssertHeapIsIdle(cx);
 56729:     CHECK_REQUEST(cx);
 62953:     return GetGlobalForScopeChain(cx);
 42766: }
 42766: 
 11809: JS_PUBLIC_API(jsval)
 11809: JS_ComputeThis(JSContext *cx, jsval *vp)
 11809: {
103783:     AssertHeapIsIdle(cx);
 48470:     assertSameCompartment(cx, JSValueArray(vp, 2));
 78614:     CallReceiver call = CallReceiverFromVp(vp);
 68904:     if (!BoxNonStrictThis(cx, call))
 68904:         return JSVAL_NULL;
 78614:     return call.thisv();
 11809: }
 11809: 
 91825: JS_PUBLIC_API(void)
 91825: JS_MallocInCompartment(JSCompartment *comp, size_t nbytes)
 91825: {
 91825:     comp->mallocInCompartment(nbytes);
 91825: }
 91825: 
 91825: JS_PUBLIC_API(void)
 91825: JS_FreeInCompartment(JSCompartment *comp, size_t nbytes)
 91825: {
 91825:     comp->freeInCompartment(nbytes);
 91825: }
 91825: 
     1: JS_PUBLIC_API(void *)
     1: JS_malloc(JSContext *cx, size_t nbytes)
     1: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 64560:     return cx->malloc_(nbytes);
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
     1: JS_realloc(JSContext *cx, void *p, size_t nbytes)
     1: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 64560:     return cx->realloc_(p, nbytes);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_free(JSContext *cx, void *p)
     1: {
 64560:     return cx->free_(p);
     1: }
     1: 
 34383: JS_PUBLIC_API(void)
 94738: JS_freeop(JSFreeOp *fop, void *p)
 94738: {
 94738:     return FreeOp::get(fop)->free_(p);
 94738: }
 94738: 
 94739: JS_PUBLIC_API(JSFreeOp *)
 94739: JS_GetDefaultFreeOp(JSRuntime *rt)
 94739: {
 94739:     return rt->defaultFreeOp();
 94739: }
 94739: 
 94738: JS_PUBLIC_API(void)
 34383: JS_updateMallocCounter(JSContext *cx, size_t nbytes)
 34383: {
 88570:     return cx->runtime->updateMallocCounter(cx, nbytes);
 34383: }
 34383: 
     1: JS_PUBLIC_API(char *)
     1: JS_strdup(JSContext *cx, const char *s)
     1: {
103783:     AssertHeapIsIdle(cx);
 87623:     size_t n = strlen(s) + 1;
 87623:     void *p = cx->malloc_(n);
     1:     if (!p)
     1:         return NULL;
 87623:     return (char *)js_memcpy(p, s, n);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 90955: JS_NewNumberValue(JSContext *cx, double d, jsval *rval)
     1: {
103783:     AssertHeapIsIdle(cx);
 49081:     d = JS_CANONICALIZE_NAN(d);
 78614:     rval->setNumber(d);
 48470:     return JS_TRUE;
     1: }
     1: 
     1: #undef JS_AddRoot
 47403: 
     1: JS_PUBLIC_API(JSBool)
 47403: JS_AddValueRoot(JSContext *cx, jsval *vp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 78614:     return js_AddRoot(cx, vp, NULL);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 47403: JS_AddStringRoot(JSContext *cx, JSString **rp)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, NULL);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 47403: JS_AddObjectRoot(JSContext *cx, JSObject **rp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, NULL);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 48470: JS_AddGCThingRoot(JSContext *cx, void **rp)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, NULL);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 48470: JS_AddNamedValueRoot(JSContext *cx, jsval *vp, const char *name)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 78614:     return js_AddRoot(cx, vp, name);
 47403: }
 47403: 
 47403: JS_PUBLIC_API(JSBool)
 47403: JS_AddNamedStringRoot(JSContext *cx, JSString **rp, const char *name)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, name);
 47403: }
 47403: 
 47403: JS_PUBLIC_API(JSBool)
 47403: JS_AddNamedObjectRoot(JSContext *cx, JSObject **rp, const char *name)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, name);
 47403: }
 47403: 
 47403: JS_PUBLIC_API(JSBool)
 78492: JS_AddNamedScriptRoot(JSContext *cx, JSScript **rp, const char *name)
 78492: {
103783:     AssertHeapIsIdle(cx);
 78492:     CHECK_REQUEST(cx);
 78492:     return js_AddGCThingRoot(cx, (void **)rp, name);
 78492: }
 78492: 
 78492: JS_PUBLIC_API(JSBool)
 48470: JS_AddNamedGCThingRoot(JSContext *cx, void **rp, const char *name)
 47403: {
103783:     AssertHeapIsIdle(cx);
 47403:     CHECK_REQUEST(cx);
 47403:     return js_AddGCThingRoot(cx, (void **)rp, name);
 47403: }
 47403: 
 86458: /* We allow unrooting from finalizers within the GC */
 86458: 
 94739: JS_PUBLIC_API(void)
 47403: JS_RemoveValueRoot(JSContext *cx, jsval *vp)
 47403: {
 47403:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)vp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 47403: JS_RemoveStringRoot(JSContext *cx, JSString **rp)
 47403: {
 47403:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 47403: JS_RemoveObjectRoot(JSContext *cx, JSObject **rp)
 47403: {
 47403:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 78492: JS_RemoveScriptRoot(JSContext *cx, JSScript **rp)
 78492: {
 78492:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 48470: JS_RemoveGCThingRoot(JSContext *cx, void **rp)
 47403: {
 47403:     CHECK_REQUEST(cx);
 94739:     js_RemoveRoot(cx->runtime, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 94739: JS_RemoveValueRootRT(JSRuntime *rt, jsval *vp)
 94739: {
 94739:     js_RemoveRoot(rt, (void *)vp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 94739: JS_RemoveStringRootRT(JSRuntime *rt, JSString **rp)
 94739: {
 94739:     js_RemoveRoot(rt, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 94739: JS_RemoveObjectRootRT(JSRuntime *rt, JSObject **rp)
 94739: {
 94739:     js_RemoveRoot(rt, (void *)rp);
 94739: }
 94739: 
 94739: JS_PUBLIC_API(void)
 94739: JS_RemoveScriptRoot(JSRuntime *rt, JSScript **rp)
 94739: {
 94739:     js_RemoveRoot(rt, (void *)rp);
 47403: }
 47403: 
 64190: JS_NEVER_INLINE JS_PUBLIC_API(void)
 64190: JS_AnchorPtr(void *p)
 64190: {
 64190: }
 64190: 
     1: #ifdef DEBUG
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_DumpNamedRoots(JSRuntime *rt,
 48470:                   void (*dump)(const char *name, void *rp, JSGCRootType type, void *data),
     1:                   void *data)
     1: {
     1:     js_DumpNamedRoots(rt, dump, data);
     1: }
     1: 
     1: #endif /* DEBUG */
     1: 
 84755: JS_PUBLIC_API(uint32_t)
     1: JS_MapGCRoots(JSRuntime *rt, JSGCRootMapFun map, void *data)
     1: {
     1:     return js_MapGCRoots(rt, map, data);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_LockGCThing(JSContext *cx, void *thing)
     1: {
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 12282:     ok = js_LockGCThingRT(cx->runtime, thing);
     1:     if (!ok)
 12282:         JS_ReportOutOfMemory(cx);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_LockGCThingRT(JSRuntime *rt, void *thing)
     1: {
     1:     return js_LockGCThingRT(rt, thing);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_UnlockGCThing(JSContext *cx, void *thing)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 36410:     js_UnlockGCThingRT(cx->runtime, thing);
 36410:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_UnlockGCThingRT(JSRuntime *rt, void *thing)
     1: {
 36410:     js_UnlockGCThingRT(rt, thing);
 36410:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 80159: JS_SetExtraGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data)
 80159: {
103783:     AssertHeapIsIdle(rt);
 80159:     rt->gcBlackRootsTraceOp = traceOp;
 80159:     rt->gcBlackRootsData = data;
   958: }
   958: 
   958: JS_PUBLIC_API(void)
 91339: JS_TracerInit(JSTracer *trc, JSRuntime *rt, JSTraceCallback callback)
 91339: {
 91339:     InitTracer(trc, rt, callback);
 87290: }
 87290: 
 87290: JS_PUBLIC_API(void)
   786: JS_TraceRuntime(JSTracer *trc)
   786: {
103783:     AssertHeapIsIdle(trc->runtime);
 53548:     TraceRuntime(trc);
   786: }
   786: 
 38595: JS_PUBLIC_API(void)
 82129: JS_TraceChildren(JSTracer *trc, void *thing, JSGCTraceKind kind)
 82129: {
 82129:     js::TraceChildren(trc, thing, kind);
 82129: }
 82129: 
 82129: JS_PUBLIC_API(void)
 77715: JS_CallTracer(JSTracer *trc, void *thing, JSGCTraceKind kind)
 38595: {
 82129:     js::CallTracer(trc, thing, kind);
 38595: }
 38595: 
   786: JS_PUBLIC_API(void)
101990: JS_GetTraceThingInfo(char *buf, size_t bufsize, JSTracer *trc, void *thing,
 77715:                      JSGCTraceKind kind, JSBool details)
 77715: {
 77715:     const char *name = NULL; /* silence uninitialized warning */
   786:     size_t n;
   786: 
   786:     if (bufsize == 0)
   786:         return;
   786: 
   786:     switch (kind) {
   786:       case JSTRACE_OBJECT:
   786:       {
 90876:         name = static_cast<JSObject *>(thing)->getClass()->name;
   786:         break;
   786:       }
   786: 
   786:       case JSTRACE_STRING:
 29366:         name = ((JSString *)thing)->isDependent()
   786:                ? "substring"
   786:                : "string";
   786:         break;
   786: 
 77659:       case JSTRACE_SCRIPT:
 77659:         name = "script";
 77659:         break;
 77659: 
 64360:       case JSTRACE_SHAPE:
 64360:         name = "shape";
 64360:         break;
 64360: 
 83221:       case JSTRACE_BASE_SHAPE:
 83221:         name = "base_shape";
 83221:         break;
 83221: 
 77659:       case JSTRACE_TYPE_OBJECT:
 77659:         name = "type_object";
 77659:         break;
 77659: 
   786: #if JS_HAS_XML_SUPPORT
   786:       case JSTRACE_XML:
   786:         name = "xml";
   786:         break;
   786: #endif
   786:     }
   786: 
   786:     n = strlen(name);
   786:     if (n > bufsize - 1)
   786:         n = bufsize - 1;
 87623:     js_memcpy(buf, name, n + 1);
   786:     buf += n;
   786:     bufsize -= n;
 90876:     *buf = '\0';
   786: 
   786:     if (details && bufsize > 2) {
   786:         switch (kind) {
   786:           case JSTRACE_OBJECT:
   786:           {
   786:             JSObject *obj = (JSObject *)thing;
 48470:             Class *clasp = obj->getClass();
 77817:             if (clasp == &FunctionClass) {
 83234:                 JSFunction *fun = obj->toFunction();
 13824:                 if (!fun) {
 13824:                     JS_snprintf(buf, bufsize, " <newborn>");
 76812:                 } else if (fun != obj) {
 13824:                     JS_snprintf(buf, bufsize, " %p", fun);
 13824:                 } else {
 90876:                     if (fun->atom) {
 90876:                         *buf++ = ' ';
 90876:                         bufsize--;
 64345:                         PutEscapedString(buf, bufsize, fun->atom, 0);
 13824:                     }
 90876:                 }
 13824:             } else if (clasp->flags & JSCLASS_HAS_PRIVATE) {
 31452:                 JS_snprintf(buf, bufsize, " %p", obj->getPrivate());
 11846:             } else {
 11846:                 JS_snprintf(buf, bufsize, " <no private>");
 11846:             }
   786:             break;
   786:           }
   786: 
   786:           case JSTRACE_STRING:
 59890:           {
 90876:             *buf++ = ' ';
 90876:             bufsize--;
 59890:             JSString *str = (JSString *)thing;
 59890:             if (str->isLinear())
 64345:                 PutEscapedString(buf, bufsize, &str->asLinear(), 0);
 59890:             else
 59890:                 JS_snprintf(buf, bufsize, "<rope: length %d>", (int)str->length());
   786:             break;
 59890:           }
   786: 
 77659:           case JSTRACE_SCRIPT:
 77659:           {
 77659:             JSScript *script = static_cast<JSScript *>(thing);
 77659:             JS_snprintf(buf, bufsize, " %s:%u", script->filename, unsigned(script->lineno));
 77659:             break;
 77659:           }
 77659: 
 64360:           case JSTRACE_SHAPE:
 83221:           case JSTRACE_BASE_SHAPE:
 77659:           case JSTRACE_TYPE_OBJECT:
 64360:             break;
 64360: 
   786: #if JS_HAS_XML_SUPPORT
  4529:           case JSTRACE_XML:
   786:           {
   786:             extern const char *js_xml_class_str[];
   786:             JSXML *xml = (JSXML *)thing;
   786: 
   786:             JS_snprintf(buf, bufsize, " %s", js_xml_class_str[xml->xml_class]);
   786:             break;
   786:           }
   786: #endif
   786:         }
   786:     }
   786:     buf[bufsize - 1] = '\0';
   786: }
   786: 
 80670: extern JS_PUBLIC_API(const char *)
 80670: JS_GetTraceEdgeName(JSTracer *trc, char *buffer, int bufferSize)
 80670: {
 80670:     if (trc->debugPrinter) {
 80670:         trc->debugPrinter(trc, buffer, bufferSize);
 80670:         return buffer;
 80670:     }
 80670:     if (trc->debugPrintIndex != (size_t) - 1) {
 80670:         JS_snprintf(buffer, bufferSize, "%s[%lu]",
 80670:                     (const char *)trc->debugPrintArg,
 80670:                     trc->debugPrintIndex);
 80670:         return buffer;
 80670:     }
 80670:     return (const char*)trc->debugPrintArg;
 80670: }
 80670: 
101990: #ifdef DEBUG
101990: 
   786: typedef struct JSHeapDumpNode JSHeapDumpNode;
   786: 
   786: struct JSHeapDumpNode {
   786:     void            *thing;
 77715:     JSGCTraceKind   kind;
   786:     JSHeapDumpNode  *next;          /* next sibling */
   786:     JSHeapDumpNode  *parent;        /* node with the thing that refer to thing
   786:                                        from this node */
   786:     char            edgeName[1];    /* name of the edge from parent->thing
   786:                                        into thing */
   786: };
   786: 
 94610: typedef HashSet<void *, PointerHasher<void *, 3>, SystemAllocPolicy> VisitedSet;
 94610: 
   786: typedef struct JSDumpingTracer {
   786:     JSTracer            base;
 94610:     VisitedSet          visited;
 91339:     bool                ok;
   786:     void                *startThing;
   786:     void                *thingToFind;
   786:     void                *thingToIgnore;
   786:     JSHeapDumpNode      *parentNode;
   786:     JSHeapDumpNode      **lastNodep;
   786:     char                buffer[200];
   786: } JSDumpingTracer;
   786: 
   786: static void
 90232: DumpNotify(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 90232: {
 94610:     JS_ASSERT(trc->callback == DumpNotify);
 94610: 
 94610:     JSDumpingTracer *dtrc = (JSDumpingTracer *)trc;
 94416:     void *thing = *thingp;
   786: 
   786:     if (!dtrc->ok || thing == dtrc->thingToIgnore)
   786:         return;
   786: 
   786:     /*
   786:      * Check if we have already seen thing unless it is thingToFind to include
   786:      * it to the graph each time we reach it and print all live things that
   786:      * refer to thingToFind.
   786:      *
   786:      * This does not print all possible paths leading to thingToFind since
   786:      * when a thing A refers directly or indirectly to thingToFind and A is
   786:      * present several times in the graph, we will print only the first path
   786:      * leading to A and thingToFind, other ways to reach A will be ignored.
   786:      */
   786:     if (dtrc->thingToFind != thing) {
   786:         /*
   786:          * The startThing check allows to avoid putting startThing into the
   786:          * hash table before tracing startThing in JS_DumpHeap.
   786:          */
   786:         if (thing == dtrc->startThing)
   786:             return;
 94610:         VisitedSet::AddPtr p = dtrc->visited.lookupForAdd(thing);
 94610:         if (p)
 94610:             return;
 94610:         if (!dtrc->visited.add(p, thing)) {
 91339:             dtrc->ok = false;
   786:             return;
   786:         }
   786:     }
   786: 
 87623:     const char *edgeName = JS_GetTraceEdgeName(&dtrc->base, dtrc->buffer, sizeof(dtrc->buffer));
 87623:     size_t edgeNameSize = strlen(edgeName) + 1;
 71352:     size_t bytes = offsetof(JSHeapDumpNode, edgeName) + edgeNameSize;
 87623:     JSHeapDumpNode *node = (JSHeapDumpNode *) OffTheBooks::malloc_(bytes);
   786:     if (!node) {
 91339:         dtrc->ok = false;
   786:         return;
   786:     }
   786: 
   786:     node->thing = thing;
   786:     node->kind = kind;
   786:     node->next = NULL;
   786:     node->parent = dtrc->parentNode;
 87623:     js_memcpy(node->edgeName, edgeName, edgeNameSize);
   786: 
   786:     JS_ASSERT(!*dtrc->lastNodep);
   786:     *dtrc->lastNodep = node;
   786:     dtrc->lastNodep = &node->next;
   786: }
   786: 
   786: /* Dump node and the chain that leads to thing it contains. */
   786: static JSBool
   917: DumpNode(JSDumpingTracer *dtrc, FILE* fp, JSHeapDumpNode *node)
   786: {
   786:     JSHeapDumpNode *prev, *following;
   786:     size_t chainLimit;
   786:     enum { MAX_PARENTS_TO_PRINT = 10 };
   786: 
101990:     JS_GetTraceThingInfo(dtrc->buffer, sizeof dtrc->buffer,
   786:                          &dtrc->base, node->thing, node->kind, JS_TRUE);
   917:     if (fprintf(fp, "%p %-22s via ", node->thing, dtrc->buffer) < 0)
   786:         return JS_FALSE;
   786: 
   786:     /*
   786:      * We need to print the parent chain in the reverse order. To do it in
   786:      * O(N) time where N is the chain length we first reverse the chain while
   786:      * searching for the top and then print each node while restoring the
   786:      * chain order.
   786:      */
   786:     chainLimit = MAX_PARENTS_TO_PRINT;
   786:     prev = NULL;
   786:     for (;;) {
   786:         following = node->parent;
   786:         node->parent = prev;
   786:         prev = node;
   786:         node = following;
   786:         if (!node)
   786:             break;
   786:         if (chainLimit == 0) {
   917:             if (fputs("...", fp) < 0)
   786:                 return JS_FALSE;
   786:             break;
   786:         }
   786:         --chainLimit;
   786:     }
   786: 
   786:     node = prev;
   786:     prev = following;
 91339:     bool ok = true;
   786:     do {
   786:         /* Loop must continue even when !ok to restore the parent chain. */
   786:         if (ok) {
   786:             if (!prev) {
   786:                 /* Print edge from some runtime root or startThing. */
   917:                 if (fputs(node->edgeName, fp) < 0)
 91339:                     ok = false;
   786:             } else {
101990:                 JS_GetTraceThingInfo(dtrc->buffer, sizeof dtrc->buffer,
   786:                                      &dtrc->base, prev->thing, prev->kind,
   786:                                      JS_FALSE);
   917:                 if (fprintf(fp, "(%p %s).%s",
   786:                            prev->thing, dtrc->buffer, node->edgeName) < 0) {
 91339:                     ok = false;
   786:                 }
   786:             }
   786:         }
   786:         following = node->parent;
   786:         node->parent = prev;
   786:         prev = node;
   786:         node = following;
   786:     } while (node);
   786: 
   917:     return ok && putc('\n', fp) >= 0;
   786: }
   786: 
   786: JS_PUBLIC_API(JSBool)
 91339: JS_DumpHeap(JSRuntime *rt, FILE *fp, void* startThing, JSGCTraceKind startKind,
   917:             void *thingToFind, size_t maxDepth, void *thingToIgnore)
   786: {
 94610:     if (maxDepth == 0)
 94610:         return true;
 94610: 
 94416:     JSDumpingTracer dtrc;
 94610:     if (!dtrc.visited.init())
 94610:         return false;
 94416:     JS_TracerInit(&dtrc.base, rt, DumpNotify);
 94610:     dtrc.ok = true;
   786:     dtrc.startThing = startThing;
   786:     dtrc.thingToFind = thingToFind;
   786:     dtrc.thingToIgnore = thingToIgnore;
   786:     dtrc.parentNode = NULL;
 94610:     JSHeapDumpNode *node = NULL;
   786:     dtrc.lastNodep = &node;
   786:     if (!startThing) {
 77715:         JS_ASSERT(startKind == JSTRACE_OBJECT);
 53548:         TraceRuntime(&dtrc.base);
   786:     } else {
   786:         JS_TraceChildren(&dtrc.base, startThing, startKind);
   786:     }
   786: 
   786:     if (!node)
 94610:         return dtrc.ok;
 94610: 
 94610:     size_t depth = 1;
 94610:     JSHeapDumpNode *children, *next, *parent;
 94610:     bool thingToFindWasTraced = thingToFind && thingToFind == startThing;
   786:     for (;;) {
   786:         /*
   786:          * Loop must continue even when !dtrc.ok to free all nodes allocated
   786:          * so far.
   786:          */
   786:         if (dtrc.ok) {
   786:             if (thingToFind == NULL || thingToFind == node->thing)
   917:                 dtrc.ok = DumpNode(&dtrc, fp, node);
   786: 
   786:             /* Descend into children. */
   786:             if (dtrc.ok &&
   786:                 depth < maxDepth &&
   786:                 (thingToFind != node->thing || !thingToFindWasTraced)) {
   786:                 dtrc.parentNode = node;
   786:                 children = NULL;
   786:                 dtrc.lastNodep = &children;
   786:                 JS_TraceChildren(&dtrc.base, node->thing, node->kind);
   786:                 if (thingToFind == node->thing)
   786:                     thingToFindWasTraced = JS_TRUE;
   786:                 if (children != NULL) {
   786:                     ++depth;
   786:                     node = children;
   786:                     continue;
   786:                 }
   786:             }
   786:         }
   786: 
   786:         /* Move to next or parents next and free the node. */
   786:         for (;;) {
   786:             next = node->next;
   786:             parent = node->parent;
 71352:             Foreground::free_(node);
   786:             node = next;
   786:             if (node)
   786:                 break;
   786:             if (!parent)
 94610:                 return dtrc.ok;
   786:             JS_ASSERT(depth > 1);
   786:             --depth;
   786:             node = parent;
   786:         }
   786:     }
   786: 
   786:     JS_ASSERT(depth == 1);
   786:     return dtrc.ok;
   786: }
   786: 
   786: #endif /* DEBUG */
   786: 
   583: extern JS_PUBLIC_API(JSBool)
   583: JS_IsGCMarkingTracer(JSTracer *trc)
   583: {
   583:     return IS_GC_MARKING_TRACER(trc);
   583: }
   583: 
 94871: JS_PUBLIC_API(void)
 94960: JS_GC(JSRuntime *rt)
 94960: {
103783:     AssertHeapIsIdle(rt);
 94960:     PrepareForFullGC(rt);
 94960:     GC(rt, GC_NORMAL, gcreason::API);
 94620: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_MaybeGC(JSContext *cx)
     1: {
 60258:     MaybeGC(cx);
     1: }
     1: 
 91339: JS_PUBLIC_API(void)
 91339: JS_SetGCCallback(JSRuntime *rt, JSGCCallback cb)
 91339: {
103783:     AssertHeapIsIdle(rt);
     1:     rt->gcCallback = cb;
 91339: }
 91339: 
 91339: JS_PUBLIC_API(void)
 91339: JS_SetFinalizeCallback(JSRuntime *rt, JSFinalizeCallback cb)
 91339: {
103783:     AssertHeapIsIdle(rt);
 91339:     rt->gcFinalizeCallback = cb;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 89658: JS_IsAboutToBeFinalized(void *thing)
 89658: {
 89658:     gc::Cell *t = static_cast<gc::Cell *>(thing);
 99246:     bool isMarked = IsCellMarked(&t);
 99246:     JS_ASSERT(t == thing);
 99246:     return !isMarked;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 84755: JS_SetGCParameter(JSRuntime *rt, JSGCParamKey key, uint32_t value)
     1: {
     1:     switch (key) {
 86796:       case JSGC_MAX_BYTES: {
 86796:         JS_ASSERT(value >= rt->gcBytes);
     1:         rt->gcMaxBytes = value;
     1:         break;
 86796:       }
 32553:       case JSGC_MAX_MALLOC_BYTES:
 34288:         rt->setGCMaxMallocBytes(value);
 32553:         break;
 90410:       case JSGC_SLICE_TIME_BUDGET:
 90410:         rt->gcSliceBudget = SliceBudget::TimeBudget(value);
 90410:         break;
 90934:       case JSGC_MARK_STACK_LIMIT:
 90934:         js::SetMarkStackLimit(rt, value);
 90934:         break;
104267:       case JSGC_HIGH_FREQUENCY_TIME_LIMIT:
104267:         rt->gcHighFrequencyTimeThreshold = value;
104267:         break;
104267:       case JSGC_HIGH_FREQUENCY_LOW_LIMIT:
104267:         rt->gcHighFrequencyLowLimitBytes = value * 1024 * 1024;
104267:         break;
104267:       case JSGC_HIGH_FREQUENCY_HIGH_LIMIT:
104267:         rt->gcHighFrequencyHighLimitBytes = value * 1024 * 1024;
104267:         break;
104267:       case JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX:
104267:         rt->gcHighFrequencyHeapGrowthMax = value / 100.0;
104267:         break;
104267:       case JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN:
104267:         rt->gcHighFrequencyHeapGrowthMin = value / 100.0;
104267:         break;
104267:       case JSGC_LOW_FREQUENCY_HEAP_GROWTH:
104267:         rt->gcLowFrequencyHeapGrowth = value / 100.0;
104267:         break;
104267:       case JSGC_DYNAMIC_HEAP_GROWTH:
104267:         rt->gcDynamicHeapGrowth = value;
104267:         break;
104267:       case JSGC_DYNAMIC_MARK_SLICE:
104267:         rt->gcDynamicMarkSlice = value;
104267:         break;
 69836:       default:
 69836:         JS_ASSERT(key == JSGC_MODE);
 60531:         rt->gcMode = JSGCMode(value);
 60531:         JS_ASSERT(rt->gcMode == JSGC_MODE_GLOBAL ||
 90410:                   rt->gcMode == JSGC_MODE_COMPARTMENT ||
 90410:                   rt->gcMode == JSGC_MODE_INCREMENTAL);
 32553:         return;
 24313:     }
 24313: }
 24313: 
 84755: JS_PUBLIC_API(uint32_t)
 24313: JS_GetGCParameter(JSRuntime *rt, JSGCParamKey key)
 24313: {
 24313:     switch (key) {
 24313:       case JSGC_MAX_BYTES:
 86796:         return uint32_t(rt->gcMaxBytes);
 32553:       case JSGC_MAX_MALLOC_BYTES:
 32553:         return rt->gcMaxMallocBytes;
 24313:       case JSGC_BYTES:
 86796:         return uint32_t(rt->gcBytes);
 60531:       case JSGC_MODE:
 84755:         return uint32_t(rt->gcMode);
 62964:       case JSGC_UNUSED_CHUNKS:
 84755:         return uint32_t(rt->gcChunkPool.getEmptyCount());
 74782:       case JSGC_TOTAL_CHUNKS:
 84755:         return uint32_t(rt->gcChunkSet.count() + rt->gcChunkPool.getEmptyCount());
 90410:       case JSGC_SLICE_TIME_BUDGET:
 90410:         return uint32_t(rt->gcSliceBudget > 0 ? rt->gcSliceBudget / PRMJ_USEC_PER_MSEC : 0);
 90934:       case JSGC_MARK_STACK_LIMIT:
 90934:         return rt->gcMarker.sizeLimit();
104267:       case JSGC_HIGH_FREQUENCY_TIME_LIMIT:
104267:         return rt->gcHighFrequencyTimeThreshold;
104267:       case JSGC_HIGH_FREQUENCY_LOW_LIMIT:
104267:         return rt->gcHighFrequencyLowLimitBytes / 1024 / 1024;
104267:       case JSGC_HIGH_FREQUENCY_HIGH_LIMIT:
104267:         return rt->gcHighFrequencyHighLimitBytes / 1024 / 1024;
104267:       case JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX:
104267:         return uint32_t(rt->gcHighFrequencyHeapGrowthMax * 100);
104267:       case JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN:
104267:         return uint32_t(rt->gcHighFrequencyHeapGrowthMin * 100);
104267:       case JSGC_LOW_FREQUENCY_HEAP_GROWTH:
104267:         return uint32_t(rt->gcLowFrequencyHeapGrowth * 100);
104267:       case JSGC_DYNAMIC_HEAP_GROWTH:
104267:         return rt->gcDynamicHeapGrowth;
104267:       case JSGC_DYNAMIC_MARK_SLICE:
104267:         return rt->gcDynamicMarkSlice;
 24313:       default:
 24313:         JS_ASSERT(key == JSGC_NUMBER);
 90410:         return uint32_t(rt->gcNumber);
     1:     }
     1: }
     1: 
 27884: JS_PUBLIC_API(void)
 84755: JS_SetGCParameterForThread(JSContext *cx, JSGCParamKey key, uint32_t value)
 27884: {
 27884:     JS_ASSERT(key == JSGC_MAX_CODE_CACHE_BYTES);
 27884: }
 27884: 
 84755: JS_PUBLIC_API(uint32_t)
 27884: JS_GetGCParameterForThread(JSContext *cx, JSGCParamKey key)
 27884: {
 27884:     JS_ASSERT(key == JSGC_MAX_CODE_CACHE_BYTES);
 27885:     return 0;
 27884: }
 27884: 
     1: JS_PUBLIC_API(JSString *)
 89632: JS_NewExternalString(JSContext *cx, const jschar *chars, size_t length,
 89632:                      const JSStringFinalizer *fin)
 89632: {
103783:     AssertHeapIsIdle(cx);
 89632:     CHECK_REQUEST(cx);
 89632:     JSString *s = JSExternalString::new_(cx, chars, length, fin);
 73746:     Probes::createString(cx, s, length);
 73746:     return s;
 68942: }
 68942: 
 68942: extern JS_PUBLIC_API(JSBool)
 89632: JS_IsExternalString(JSString *str)
 89632: {
 68942:     return str->isExternal();
 68942: }
 68942: 
 89632: extern JS_PUBLIC_API(const JSStringFinalizer *)
 89632: JS_GetExternalStringFinalizer(JSString *str)
 89632: {
 89632:     return str->asExternal().externalFinalizer();
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 89261: JS_SetNativeStackQuota(JSRuntime *rt, size_t stackSize)
 89261: {
 89261:     rt->nativeStackQuota = stackSize;
 89261:     if (!rt->nativeStackBase)
 89261:         return;
 89261: 
 42740: #if JS_STACK_GROWTH_DIRECTION > 0
 42740:     if (stackSize == 0) {
 89261:         rt->nativeStackLimit = UINTPTR_MAX;
 42740:     } else {
 89261:         JS_ASSERT(rt->nativeStackBase <= size_t(-1) - stackSize);
 89261:         rt->nativeStackLimit = rt->nativeStackBase + stackSize - 1;
 42740:     }
 42740: #else
 42740:     if (stackSize == 0) {
 89261:         rt->nativeStackLimit = 0;
 42740:     } else {
 89261:         JS_ASSERT(rt->nativeStackBase >= stackSize);
 89261:         rt->nativeStackLimit = rt->nativeStackBase - (stackSize - 1);
 42740:     }
 42740: #endif
 42740: }
 42740: 
     1: /************************************************************************/
     1: 
 91450: JS_PUBLIC_API(int)
 82129: JS_IdArrayLength(JSContext *cx, JSIdArray *ida)
 82129: {
 82129:     return ida->length;
 82129: }
 82129: 
 82129: JS_PUBLIC_API(jsid)
 91450: JS_IdArrayGet(JSContext *cx, JSIdArray *ida, int index)
 82129: {
 82129:     JS_ASSERT(index >= 0 && index < ida->length);
 82129:     return ida->vector[index];
 82129: }
 82129: 
 67898: JS_PUBLIC_API(void)
 67898: JS_DestroyIdArray(JSContext *cx, JSIdArray *ida)
 67898: {
 94740:     DestroyIdArray(cx->runtime->defaultFreeOp(), ida);
 67898: }
 67898: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ValueToId(JSContext *cx, jsval v, jsid *idp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 78614:     return ValueToId(cx, v, idp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_IdToValue(JSContext *cx, jsid id, jsval *vp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 48470:     *vp = IdToJsval(id);
 47485:     assertSameCompartment(cx, *vp);
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 80466: JS_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp)
 80466: {
103783:     AssertHeapIsIdle(cx);
 80466:     CHECK_REQUEST(cx);
 80466:     JS_ASSERT(obj != NULL);
 80466:     JS_ASSERT(hint == JSTYPE_VOID || hint == JSTYPE_STRING || hint == JSTYPE_NUMBER);
 80466:     return obj->defaultValue(cx, hint, vp);
 80466: }
 80466: 
 80466: JS_PUBLIC_API(JSBool)
 98960: JS_PropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, jsval *vp)
     1: {
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 98960: JS_StrictPropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, JSBool strict, jsval *vp)
 62395: {
 62395:     return JS_TRUE;
 62395: }
 62395: 
 62395: JS_PUBLIC_API(JSBool)
 98960: JS_EnumerateStub(JSContext *cx, JSHandleObject obj)
     1: {
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 98960: JS_ResolveStub(JSContext *cx, JSHandleObject obj, JSHandleId id)
     1: {
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 98960: JS_ConvertStub(JSContext *cx, JSHandleObject obj, JSType type, jsval *vp)
     1: {
 40867:     JS_ASSERT(type != JSTYPE_OBJECT && type != JSTYPE_FUNCTION);
 72054:     JS_ASSERT(obj);
102586:     return DefaultValue(cx, obj, type, vp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
 99364: JS_InitClass(JSContext *cx, JSObject *obj_, JSObject *parent_proto,
 91237:              JSClass *clasp, JSNative constructor, unsigned nargs,
     1:              JSPropertySpec *ps, JSFunctionSpec *fs,
     1:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
     1: {
 99421:     RootedObject obj(cx, obj_);
 99364: 
103783:     AssertHeapIsIdle(cx);
 25897:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, parent_proto);
 99364:     return js_InitClass(cx, obj, parent_proto, Valueify(clasp), constructor,
 78614:                         nargs, ps, fs, static_ps, static_fs);
 25887: }
 25887: 
 89207: JS_PUBLIC_API(JSBool)
 89207: JS_LinkConstructorAndPrototype(JSContext *cx, JSObject *ctor, JSObject *proto)
 89207: {
 89207:     return LinkConstructorAndPrototype(cx, ctor, proto);
 89207: }
 89207: 
     1: JS_PUBLIC_API(JSClass *)
     1: JS_GetClass(JSObject *obj)
     1: {
 78614:     return obj->getJSClass();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_InstanceOf(JSContext *cx, JSObject *obj, JSClass *clasp, jsval *argv)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 67947: #ifdef DEBUG
 67947:     if (argv) {
 47485:         assertSameCompartment(cx, obj);
 67947:         assertSameCompartment(cx, JSValueArray(argv - 2, 2));
 67947:     }
 67947: #endif
 67947:     if (!obj || obj->getJSClass() != clasp) {
 67943:         if (argv)
 79387:             ReportIncompatibleMethod(cx, CallReceiverFromArgv(argv), Valueify(clasp));
 67943:         return false;
 67943:     }
 67943:     return true;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 98960: JS_HasInstance(JSContext *cx, JSObject *obj_, jsval v, JSBool *bp)
 98960: {
 99421:     RootedObject obj(cx, obj_);
 98960: 
103783:     AssertHeapIsIdle(cx);
 47485:     assertSameCompartment(cx, obj, v);
 78614:     return HasInstance(cx, obj, &v, bp);
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
 89826: JS_GetPrivate(JSObject *obj)
     1: {
 86458:     /* This function can be called by a finalizer. */
 31452:     return obj->getPrivate();
     1: }
     1: 
 89826: JS_PUBLIC_API(void)
 89826: JS_SetPrivate(JSObject *obj, void *data)
     1: {
 86458:     /* This function can be called by a finalizer. */
 32684:     obj->setPrivate(data);
     1: }
     1: 
     1: JS_PUBLIC_API(void *)
 43229: JS_GetInstancePrivate(JSContext *cx, JSObject *obj, JSClass *clasp, jsval *argv)
     1: {
 67944:     if (!JS_InstanceOf(cx, obj, clasp, argv))
     1:         return NULL;
 32684:     return obj->getPrivate();
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
 89826: JS_GetPrototype(JSObject *obj)
 89826: {
 83275:     return obj->getProto();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
102586: JS_SetPrototype(JSContext *cx, JSObject *obj_, JSObject *proto_)
102586: {
103783:     AssertHeapIsIdle(cx);
102586:     CHECK_REQUEST(cx);
102586:     assertSameCompartment(cx, obj_, proto_);
102586: 
102586:     Rooted<JSObject*> obj(cx, obj_);
102586:     Rooted<JSObject*> proto(cx, proto_);
102586:     return SetProto(cx, obj, proto, JS_FALSE);
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
 89826: JS_GetParent(JSObject *obj)
     1: {
 86483:     JS_ASSERT(!obj->isScope());
 83275:     return obj->getParent();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
102586: JS_SetParent(JSContext *cx, JSObject *obj_, JSObject *parent_)
102586: {
103783:     AssertHeapIsIdle(cx);
102586:     CHECK_REQUEST(cx);
102586:     JS_ASSERT(!obj_->isScope());
102586:     JS_ASSERT(parent_ || !obj_->getParent());
102586:     assertSameCompartment(cx, obj_, parent_);
102586: 
102586:     Rooted<JSObject*> obj(cx, obj_);
102586:     Rooted<JSObject*> parent(cx, parent_);
102586:     return JSObject::setParent(cx, obj, parent);
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
     1: JS_GetConstructor(JSContext *cx, JSObject *proto)
     1: {
 48470:     Value cval;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, proto);
 19712:     {
 19712:         JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 19712: 
 78675:         if (!proto->getProperty(cx, cx->runtime->atomState.constructorAtom, &cval))
     1:             return NULL;
     1:     }
 83234:     if (!IsFunctionObject(cval)) {
     1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR,
 40826:                              proto->getClass()->name);
     1:         return NULL;
     1:     }
 48470:     return &cval.toObject();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_GetObjectId(JSContext *cx, JSObject *obj, jsid *idp)
     1: {
103783:     AssertHeapIsIdle(cx);
 47485:     assertSameCompartment(cx, obj);
     1:     *idp = OBJECT_TO_JSID(obj);
     1:     return JS_TRUE;
     1: }
     1: 
 64258: class AutoHoldCompartment {
 64258:   public:
 64258:     explicit AutoHoldCompartment(JSCompartment *compartment JS_GUARD_OBJECT_NOTIFIER_PARAM)
 64258:       : holdp(&compartment->hold)
 64258:     {
 64258:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 64258:         *holdp = true;
 64258:     }
 64258: 
 64258:     ~AutoHoldCompartment() {
 64258:         *holdp = false;
 64258:     }
 64258:   private:
 64258:     bool *holdp;
 64258:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 64258: };
 64258: 
 43286: JS_PUBLIC_API(JSObject *)
102756: JS_NewGlobalObject(JSContext *cx, JSClass *clasp, JSPrincipals *principals)
 47498: {
103783:     AssertHeapIsIdle(cx);
 47498:     CHECK_REQUEST(cx);
102755:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
102755: 
 47516:     JSCompartment *compartment = NewCompartment(cx, principals);
 47498:     if (!compartment)
 47498:         return NULL;
 47498: 
 64258:     AutoHoldCompartment hold(compartment);
 64258: 
 47498:     JSCompartment *saved = cx->compartment;
 77343:     cx->setCompartment(compartment);
102755:     GlobalObject *global = GlobalObject::create(cx, Valueify(clasp));
 77343:     cx->setCompartment(saved);
 47498: 
102755:     return global;
 47498: }
 47498: 
 47498: JS_PUBLIC_API(JSObject *)
103320: JS_NewObject(JSContext *cx, JSClass *jsclasp, JSObject *proto_, JSObject *parent_)
103320: {
103320:     RootedObject proto(cx, proto_);
103320:     RootedObject parent(cx, parent_);
103320: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, proto, parent);
 50450: 
 48470:     Class *clasp = Valueify(jsclasp);
     1:     if (!clasp)
 77817:         clasp = &ObjectClass;    /* default class is Object */
 77817: 
 77817:     JS_ASSERT(clasp != &FunctionClass);
 43286:     JS_ASSERT(!(clasp->flags & JSCLASS_IS_GLOBAL));
 50450: 
 83275:     JSObject *obj = NewObjectWithClassProto(cx, clasp, proto, parent);
103320:     AssertRootingUnnecessary safe(cx);
 77343:     if (obj) {
 77343:         if (clasp->ext.equality)
 77353:             MarkTypeObjectFlags(cx, obj, OBJECT_FLAG_SPECIAL_EQUALITY);
 77343:     }
 50450: 
 43286:     JS_ASSERT_IF(obj, obj->getParent());
 43286:     return obj;
  3624: }
  3624: 
 11700: JS_PUBLIC_API(JSObject *)
 48470: JS_NewObjectWithGivenProto(JSContext *cx, JSClass *jsclasp, JSObject *proto, JSObject *parent)
 11700: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 11700:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, proto, parent);
 50450: 
 48470:     Class *clasp = Valueify(jsclasp);
 11700:     if (!clasp)
 77817:         clasp = &ObjectClass;    /* default class is Object */
 77817: 
 77817:     JS_ASSERT(clasp != &FunctionClass);
 43286:     JS_ASSERT(!(clasp->flags & JSCLASS_IS_GLOBAL));
 50450: 
 83275:     JSObject *obj = NewObjectWithGivenProto(cx, clasp, proto, parent);
103320:     AssertRootingUnnecessary safe(cx);
 83248:     if (obj)
 77353:         MarkTypeObjectUnknownProperties(cx, obj->type());
 57806:     return obj;
     1: }
     1: 
 53557: JS_PUBLIC_API(JSObject *)
 94094: JS_NewObjectForConstructor(JSContext *cx, JSClass *clasp, const jsval *vp)
 53557: {
103783:     AssertHeapIsIdle(cx);
 53557:     CHECK_REQUEST(cx);
 53557:     assertSameCompartment(cx, *vp);
 53557: 
104205:     RootedObject obj(cx, JSVAL_TO_OBJECT(*vp));
104205:     return js_CreateThis(cx, Valueify(clasp), obj);
 53557: }
 53557: 
     1: JS_PUBLIC_API(JSBool)
 54565: JS_IsExtensible(JSObject *obj)
 54565: {
 54565:     return obj->isExtensible();
 54565: }
 54565: 
 54565: JS_PUBLIC_API(JSBool)
 68935: JS_IsNative(JSObject *obj)
 68935: {
 68935:     return obj->isNative();
 68935: }
 68935: 
 91339: JS_PUBLIC_API(JSRuntime *)
 91339: JS_GetObjectRuntime(JSObject *obj)
 91339: {
 91339:     return obj->compartment()->rt;
 91339: }
 91339: 
 68935: JS_PUBLIC_API(JSBool)
 54563: JS_FreezeObject(JSContext *cx, JSObject *obj)
     1: {
103783:     AssertHeapIsIdle(cx);
 47485:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 47485: 
 54563:     return obj->freeze(cx);
 54563: }
 54563: 
 54563: JS_PUBLIC_API(JSBool)
103320: JS_DeepFreezeObject(JSContext *cx, JSObject *obj_)
103320: {
103320:     RootedObject obj(cx, obj_);
103783:     AssertHeapIsIdle(cx);
 54563:     CHECK_REQUEST(cx);
 54563:     assertSameCompartment(cx, obj);
 54563: 
 54563:     /* Assume that non-extensible objects are already deep-frozen, to avoid divergence. */
 58681:     if (!obj->isExtensible())
 52503:         return true;
     1: 
 54563:     if (!obj->freeze(cx))
 52503:         return false;
 22452: 
     1:     /* Walk slots in obj and if any value is a non-null object, seal it. */
 84755:     for (uint32_t i = 0, n = obj->slotSpan(); i < n; ++i) {
 48470:         const Value &v = obj->getSlot(i);
 48470:         if (v.isPrimitive())
     1:             continue;
 54563:         if (!JS_DeepFreezeObject(cx, &v.toObject()))
 52503:             return false;
 52503:     }
 54563: 
 52503:     return true;
     1: }
     1: 
     1: static JSBool
103320: LookupPropertyById(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
103716:                    MutableHandleObject objp, MutableHandleShape propp)
 43228: {
103783:     AssertHeapIsIdle(cx);
 43231:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 43231: 
 43228:     JSAutoResolveFlags rf(cx, flags);
 80442:     return obj->lookupGeneric(cx, id, objp, propp);
 43228: }
 43228: 
 43228: #define AUTO_NAMELEN(s,n)   (((n) == (size_t)-1) ? js_strlen(s) : (n))
 43228: 
 43228: static JSBool
103320: LookupResult(JSContext *cx, HandleObject obj, HandleObject obj2, jsid id,
103716:              HandleShape shape, Value *vp)
103716: {
103716:     if (!shape) {
 43228:         /* XXX bad API: no way to tell "not defined" from "void value" */
 48470:         vp->setUndefined();
 43228:         return JS_TRUE;
 43228:     }
 43228: 
 43228:     if (obj2->isNative()) {
 43228:         /* Peek at the native property's slot value, without doing a Get. */
 83221:         if (shape->hasSlot()) {
 83221:             *vp = obj2->nativeGetSlot(shape->slot());
 57180:             return true;
 57180:         }
 57180:     } else {
 57180:         if (obj2->isDenseArray())
 48470:             return js_GetDenseArrayElementValue(cx, obj2, id, vp);
 57180:         if (obj2->isProxy()) {
 57180:             AutoPropertyDescriptorRooter desc(cx);
 79386:             if (!Proxy::getPropertyDescriptor(cx, obj2, id, false, &desc))
 57180:                 return false;
 57180:             if (!(desc.attrs & JSPROP_SHARED)) {
 57180:                 *vp = desc.value;
 57180:                 return true;
 57180:             }
 57180:         }
 57180:     }
 57180: 
 43228:     /* XXX bad API: no way to return "defined but value unknown" */
 48470:     vp->setBoolean(true);
 43290:     return true;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
103320: JS_LookupPropertyById(JSContext *cx, JSObject *obj_, jsid id_, jsval *vp)
 98960: {
 99421:     RootedId id(cx, id_);
103320:     RootedObject obj(cx, obj_);
103320:     RootedObject obj2(cx);
103716:     RootedShape prop(cx);
103320: 
103636:     return LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop) &&
 78614:            LookupResult(cx, obj, obj2, id, prop, vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 84755: JS_LookupElement(JSContext *cx, JSObject *obj, uint32_t index, jsval *vp)
 75052: {
 75052:     CHECK_REQUEST(cx);
 75052:     jsid id;
 75052:     if (!IndexToId(cx, index, &id))
 75052:         return false;
 75052:     return JS_LookupPropertyById(cx, obj, id, vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 43228: JS_LookupProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp)
 43228: {
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_LookupPropertyById(cx, obj, AtomToId(atom), vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
103320: JS_LookupUCProperty(JSContext *cx, JSObject *obj_, const jschar *name, size_t namelen, jsval *vp)
103320: {
103320:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_LookupPropertyById(cx, obj, AtomToId(atom), vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 98960: JS_LookupPropertyWithFlagsById(JSContext *cx, JSObject *obj_, jsid id_, unsigned flags,
103320:                                JSObject **objp_, jsval *vp)
 43228: {
 99421:     RootedObject obj(cx, obj_);
103320:     RootedObject objp(cx, *objp_);
 99421:     RootedId id(cx, id_);
103716:     RootedShape prop(cx);
 43228: 
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
103320:     if (!(obj->isNative()
103636:           ? LookupPropertyWithFlags(cx, obj, id, flags, &objp, &prop)
103636:           : obj->lookupGeneric(cx, id, &objp, &prop)))
103320:         return false;
103320: 
103320:     if (!LookupResult(cx, obj, objp, id, prop, vp))
103320:         return false;
103320: 
103320:     *objp_ = objp;
103320:     return true;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 91237: JS_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, const char *name, unsigned flags, jsval *vp)
 43228: {
 43228:     JSObject *obj2;
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_LookupPropertyWithFlagsById(cx, obj, AtomToId(atom), flags, &obj2, vp);
 43231: }
 43231: 
 43231: JS_PUBLIC_API(JSBool)
103320: JS_HasPropertyById(JSContext *cx, JSObject *obj_, jsid id_, JSBool *foundp)
103320: {
103320:     RootedObject obj(cx, obj_);
 99421:     RootedId id(cx, id_);
103320:     RootedObject obj2(cx);
103716:     RootedShape prop(cx);
 56567:     JSBool ok = LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
103636:                                    &obj2, &prop);
 56567:     *foundp = (prop != NULL);
 56567:     return ok;
 43229: }
 43229: 
 43229: JS_PUBLIC_API(JSBool)
 84755: JS_HasElement(JSContext *cx, JSObject *obj, uint32_t index, JSBool *foundp)
 75051: {
103783:     AssertHeapIsIdle(cx);
 75051:     CHECK_REQUEST(cx);
 75051:     jsid id;
 75051:     if (!IndexToId(cx, index, &id))
 75051:         return false;
 75051:     return JS_HasPropertyById(cx, obj, id, foundp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 43229: JS_HasProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp)
 43228: {
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_HasPropertyById(cx, obj, AtomToId(atom), foundp);
 43231: }
 43231: 
 43231: JS_PUBLIC_API(JSBool)
103320: JS_HasUCProperty(JSContext *cx, JSObject *obj_, const jschar *name, size_t namelen, JSBool *foundp)
103320: {
103320:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_HasPropertyById(cx, obj, AtomToId(atom), foundp);
 43231: }
 43231: 
 43231: JS_PUBLIC_API(JSBool)
103320: JS_AlreadyHasOwnPropertyById(JSContext *cx, JSObject *obj_, jsid id_, JSBool *foundp)
 98960: {
 99421:     RootedId id(cx, id_);
103320:     RootedObject obj(cx, obj_);
 98960: 
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 43228: 
 43228:     if (!obj->isNative()) {
103636:         RootedObject obj2(cx);
103716:         RootedShape prop(cx);
 43228: 
 43229:         if (!LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
 43228:                                 &obj2, &prop)) {
 43228:             return JS_FALSE;
 43228:         }
 43228:         *foundp = (obj == obj2);
 43228:         return JS_TRUE;
 43228:     }
 43228: 
 78194:     *foundp = obj->nativeContains(cx, id);
 43228:     return JS_TRUE;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 84755: JS_AlreadyHasOwnElement(JSContext *cx, JSObject *obj, uint32_t index, JSBool *foundp)
 75050: {
103783:     AssertHeapIsIdle(cx);
 75050:     CHECK_REQUEST(cx);
 75050:     jsid id;
 75050:     if (!IndexToId(cx, index, &id))
 75050:         return false;
 75050:     return JS_AlreadyHasOwnPropertyById(cx, obj, id, foundp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 43229: JS_AlreadyHasOwnProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp)
 43228: {
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_AlreadyHasOwnPropertyById(cx, obj, AtomToId(atom), foundp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
103320: JS_AlreadyHasOwnUCProperty(JSContext *cx, JSObject *obj_, const jschar *name, size_t namelen,
 43228:                            JSBool *foundp)
 43228: {
103320:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_AlreadyHasOwnPropertyById(cx, obj, AtomToId(atom), foundp);
 43228: }
 43228: 
 43228: static JSBool
 97353: DefinePropertyById(JSContext *cx, HandleObject obj, HandleId id, HandleValue value,
 91237:                    PropertyOp getter, StrictPropertyOp setter, unsigned attrs,
 91237:                    unsigned flags, int tinyid)
 20964: {
 84680:     /*
 84680:      * JSPROP_READONLY has no meaning when accessors are involved. Ideally we'd
 84680:      * throw if this happens, but we've accepted it for long enough that it's
 84680:      * not worth trying to make callers change their ways. Just flip it off on
 84680:      * its way through the API layer so that we can enforce this internally.
 84680:      */
 84680:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER))
 84680:         attrs &= ~JSPROP_READONLY;
 84680: 
 94398:     /*
 94398:      * When we use DefineProperty, we need full scriptable Function objects rather
 94398:      * than JSNatives. However, we might be pulling this property descriptor off
 94398:      * of something with JSNative property descriptors. If we are, wrap them in
 94398:      * JS Function objects.
 94398:      */
 94398:     if (attrs & JSPROP_NATIVE_ACCESSORS) {
 94398:         JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
 94398:         attrs &= ~JSPROP_NATIVE_ACCESSORS;
 94398:         if (getter) {
 94398:             JSObject *getobj = JS_NewFunction(cx, (Native) getter, 0, 0, &obj->global(), NULL);
 94398:             if (!getobj)
 94398:                 return false;
 94398:             getter = JS_DATA_TO_FUNC_PTR(PropertyOp, getobj);
 94398:             attrs |= JSPROP_GETTER;
 94398:         }
 94398:         if (setter) {
 99364:             // Root just the getter, since the setter is not yet a JSObject.
 99364:             AutoRooterGetterSetter getRoot(cx, JSPROP_GETTER, &getter, NULL);
 94398:             JSObject *setobj = JS_NewFunction(cx, (Native) setter, 1, 0, &obj->global(), NULL);
 94398:             if (!setobj)
 94398:                 return false;
 94398:             setter = JS_DATA_TO_FUNC_PTR(StrictPropertyOp, setobj);
 94398:             attrs |= JSPROP_SETTER;
 94398:         }
 94398:     }
 94398: 
 94398: 
103783:     AssertHeapIsIdle(cx);
 43232:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id, value,
 47485:                             (attrs & JSPROP_GETTER)
 47485:                             ? JS_FUNC_TO_DATA_PTR(JSObject *, getter)
 47485:                             : NULL,
 47485:                             (attrs & JSPROP_SETTER)
 47485:                             ? JS_FUNC_TO_DATA_PTR(JSObject *, setter)
 47485:                             : NULL);
 43232: 
103344:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 40430:     if (flags != 0 && obj->isNative()) {
 69855:         return !!DefineNativeProperty(cx, obj, id, value, getter, setter,
 69855:                                       attrs, flags, tinyid);
 20964:     }
 80624:     return obj->defineGeneric(cx, id, value, getter, setter, attrs);
 20964: }
 20964: 
 43228: JS_PUBLIC_API(JSBool)
 97353: JS_DefinePropertyById(JSContext *cx, JSObject *obj_, jsid id_, jsval value_,
 91237:                       JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 43228: {
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedId id(cx, id_);
 99421:     RootedValue value(cx, value_);
 78614:     return DefinePropertyById(cx, obj, id, value, getter, setter, attrs, 0, 0);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 97353: JS_DefineElement(JSContext *cx, JSObject *obj_, uint32_t index, jsval value_,
 91237:                  JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 43228: {
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedValue value(cx, value_);
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
103783:     AssertHeapIsIdle(cx);
 97353:     CHECK_REQUEST(cx);
 99421:     RootedId id(cx);
 97353:     if (!IndexToId(cx, index, id.address()))
 75049:         return false;
 78614:     return DefinePropertyById(cx, obj, id, value, getter, setter, attrs, 0, 0);
 43228: }
 43228: 
 20964: static JSBool
 95355: DefineProperty(JSContext *cx, JSObject *obj_, const char *name, const Value &value_,
 91237:                PropertyOp getter, StrictPropertyOp setter, unsigned attrs,
 91237:                unsigned flags, int tinyid)
     1: {
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedValue value(cx, value_);
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
 99421:     RootedId id(cx);
 86437: 
     1:     if (attrs & JSPROP_INDEX) {
 40292:         id = INT_TO_JSID(intptr_t(name));
     1:         attrs &= ~JSPROP_INDEX;
     1:     } else {
 97353:         JSAtom *atom = js_Atomize(cx, name, strlen(name));
     1:         if (!atom)
     1:             return JS_FALSE;
 97828:         id = AtomToId(atom);
     1:     }
 75402: 
 43229:     return DefinePropertyById(cx, obj, id, value, getter, setter, attrs, flags, tinyid);
     1: }
     1: 
 43228: JS_PUBLIC_API(JSBool)
 43228: JS_DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
 91237:                   PropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 78614: {
 78614:     return DefineProperty(cx, obj, name, value, getter, setter, attrs, 0, 0);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 84755: JS_DefinePropertyWithTinyId(JSContext *cx, JSObject *obj, const char *name, int8_t tinyid,
 91237:                             jsval value, PropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 78614: {
 78614:     return DefineProperty(cx, obj, name, value, getter, setter, attrs, Shape::HAS_SHORTID, tinyid);
 43228: }
     1: 
     1: static JSBool
 95355: DefineUCProperty(JSContext *cx, JSObject *obj_, const jschar *name, size_t namelen,
 97353:                  const Value &value_, PropertyOp getter, StrictPropertyOp setter, unsigned attrs,
 91237:                  unsigned flags, int tinyid)
     1: {
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedValue value(cx, value_);
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97353:     if (!atom)
 97353:         return false;
 99421:     RootedId id(cx, AtomToId(atom));
 97353:     return DefinePropertyById(cx, obj, id, value, getter, setter, attrs, flags, tinyid);
     1: }
     1: 
 43228: JS_PUBLIC_API(JSBool)
 43229: JS_DefineUCProperty(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen,
 91237:                     jsval value, JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 43228: {
 78614:     return DefineUCProperty(cx, obj, name, namelen, value, getter, setter, attrs, 0, 0);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 43229: JS_DefineUCPropertyWithTinyId(JSContext *cx, JSObject *obj, const jschar *name, size_t namelen,
 84755:                               int8_t tinyid, jsval value,
 91237:                               JSPropertyOp getter, JSStrictPropertyOp setter, unsigned attrs)
 43228: {
 78614:     return DefineUCProperty(cx, obj, name, namelen, value, getter, setter, attrs,
 78614:                             Shape::HAS_SHORTID, tinyid);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
102586: JS_DefineOwnProperty(JSContext *cx, JSObject *obj_, jsid id_, jsval descriptor, JSBool *bp)
102586: {
103783:     AssertHeapIsIdle(cx);
102586:     CHECK_REQUEST(cx);
102586:     assertSameCompartment(cx, obj_, id_, descriptor);
102586: 
102586:     Rooted<JSObject*> obj(cx, obj_);
102586:     Rooted<jsid> id(cx, id_);
102586:     return js_DefineOwnProperty(cx, obj, id, descriptor, bp);
 43228: }
 43228: 
     1: JS_PUBLIC_API(JSObject *)
 99364: JS_DefineObject(JSContext *cx, JSObject *obj_, const char *name, JSClass *jsclasp,
 91237:                 JSObject *proto, unsigned attrs)
     1: {
 99421:     RootedObject obj(cx, obj_), nobj(cx);
 99364: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, proto);
 50450: 
 48470:     Class *clasp = Valueify(jsclasp);
     1:     if (!clasp)
 77817:         clasp = &ObjectClass;    /* default class is Object */
 50450: 
 86437:     nobj = NewObjectWithClassProto(cx, clasp, proto, obj);
     1:     if (!nobj)
     1:         return NULL;
 50450: 
 48470:     if (!DefineProperty(cx, obj, name, ObjectValue(*nobj), NULL, NULL, attrs, 0, 0))
     1:         return NULL;
 50450: 
     1:     return nobj;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 95355: JS_DefineConstDoubles(JSContext *cx, JSObject *obj_, JSConstDoubleSpec *cds)
 95355: {
 99421:     RootedObject obj(cx, obj_);
 95355: 
     1:     JSBool ok;
 91237:     unsigned attrs;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
     1:     for (ok = JS_TRUE; cds->name; cds++) {
 48470:         Value value = DoubleValue(cds->dval);
 19712:         attrs = cds->flags;
 19712:         if (!attrs)
 19712:             attrs = JSPROP_READONLY | JSPROP_PERMANENT;
 19712:         ok = DefineProperty(cx, obj, cds->name, value, NULL, NULL, attrs, 0, 0);
     1:         if (!ok)
     1:             break;
     1:     }
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 99364: JS_DefineProperties(JSContext *cx, JSObject *obj_, JSPropertySpec *ps)
     1: {
     1:     JSBool ok;
 99421:     RootedObject obj(cx, obj_);
     1: 
 43232:     for (ok = true; ps->name; ps++) {
 78614:         ok = DefineProperty(cx, obj, ps->name, UndefinedValue(), ps->getter, ps->setter,
 52503:                             ps->flags, Shape::HAS_SHORTID, ps->tinyid);
     1:         if (!ok)
     1:             break;
     1:     }
     1:     return ok;
     1: }
     1: 
     1: static JSBool
103320: GetPropertyDescriptorById(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
 48470:                           JSBool own, PropertyDescriptor *desc)
     1: {
103320:     RootedObject obj2(cx);
103716:     RootedShape shape(cx);
103716: 
103716:     if (!LookupPropertyById(cx, obj, id, flags, &obj2, &shape))
     1:         return JS_FALSE;
 26022: 
103716:     if (!shape || (own && obj != obj2)) {
 26022:         desc->obj = NULL;
 26022:         desc->attrs = 0;
 26022:         desc->getter = NULL;
 26022:         desc->setter = NULL;
 48470:         desc->value.setUndefined();
     1:         return JS_TRUE;
     1:     }
     1: 
 26022:     desc->obj = obj2;
 40430:     if (obj2->isNative()) {
 52503:         desc->attrs = shape->attributes();
 52503:         desc->getter = shape->getter();
 52503:         desc->setter = shape->setter();
 83221:         if (shape->hasSlot())
 83221:             desc->value = obj2->nativeGetSlot(shape->slot());
 48470:         else
 48470:             desc->value.setUndefined();
 52503:     } else {
 52503:         if (obj2->isProxy()) {
 42733:             JSAutoResolveFlags rf(cx, flags);
 42733:             return own
 79386:                    ? Proxy::getOwnPropertyDescriptor(cx, obj2, id, false, desc)
 79386:                    : Proxy::getPropertyDescriptor(cx, obj2, id, false, desc);
 52503:         }
 80622:         if (!obj2->getGenericAttributes(cx, id, &desc->attrs))
 43290:             return false;
 26022:         desc->getter = NULL;
 26022:         desc->setter = NULL;
 48470:         desc->value.setUndefined();
 26022:     }
 43290:     return true;
     1: }
     1: 
 43228: JS_PUBLIC_API(JSBool)
103320: JS_GetPropertyDescriptorById(JSContext *cx, JSObject *obj_, jsid id_, unsigned flags,
 43228:                              JSPropertyDescriptor *desc)
 43228: {
 99421:     RootedId id(cx, id_);
103320:     RootedObject obj(cx, obj_);
 78614:     return GetPropertyDescriptorById(cx, obj, id, flags, JS_FALSE, desc);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
103320: JS_GetPropertyAttrsGetterAndSetterById(JSContext *cx, JSObject *obj_, jsid id_,
 91237:                                        unsigned *attrsp, JSBool *foundp,
 62395:                                        JSPropertyOp *getterp, JSStrictPropertyOp *setterp)
 43228: {
103320:     RootedObject obj(cx, obj_);
 99421:     RootedId id(cx, id_);
 48470:     PropertyDescriptor desc;
 43233:     if (!GetPropertyDescriptorById(cx, obj, id, JSRESOLVE_QUALIFIED, JS_FALSE, &desc))
 43233:         return false;
 26022: 
 26022:     *attrsp = desc.attrs;
 26022:     *foundp = (desc.obj != NULL);
 26022:     if (getterp)
 78614:         *getterp = desc.getter;
 26022:     if (setterp)
 78614:         *setterp = desc.setter;
 43233:     return true;
 24145: }
 24145: 
 24145: JS_PUBLIC_API(JSBool)
 43228: JS_GetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
 91237:                          unsigned *attrsp, JSBool *foundp)
 43228: {
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, AtomToId(atom),
 43228:                                                           attrsp, foundp, NULL, NULL);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
103320: JS_GetUCPropertyAttributes(JSContext *cx, JSObject *obj_, const jschar *name, size_t namelen,
 91237:                            unsigned *attrsp, JSBool *foundp)
 43228: {
103320:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, AtomToId(atom),
 43228:                                                           attrsp, foundp, NULL, NULL);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 43229: JS_GetPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj, const char *name,
 91237:                                    unsigned *attrsp, JSBool *foundp,
 62395:                                    JSPropertyOp *getterp, JSStrictPropertyOp *setterp)
 43228: {
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, AtomToId(atom),
 43228:                                                           attrsp, foundp, getterp, setterp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
103320: JS_GetUCPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj_,
 43228:                                      const jschar *name, size_t namelen,
 91237:                                      unsigned *attrsp, JSBool *foundp,
 62395:                                      JSPropertyOp *getterp, JSStrictPropertyOp *setterp)
 43228: {
103320:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_GetPropertyAttrsGetterAndSetterById(cx, obj, AtomToId(atom),
 43228:                                                           attrsp, foundp, getterp, setterp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
102586: JS_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj_, jsid id_, jsval *vp)
102586: {
103783:     AssertHeapIsIdle(cx);
102586:     CHECK_REQUEST(cx);
102586: 
102586:     Rooted<JSObject*> obj(cx, obj_);
102586:     Rooted<jsid> id(cx, id_);
102586:     return GetOwnPropertyDescriptor(cx, obj, id, vp);
 43228: }
 43228: 
 43228: static JSBool
103320: SetPropertyAttributesById(JSContext *cx, HandleObject obj, HandleId id, unsigned attrs, JSBool *foundp)
103320: {
103320:     RootedObject obj2(cx);
103716:     RootedShape shape(cx);
103716: 
103716:     if (!LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &shape))
 43290:         return false;
103716:     if (!shape || obj != obj2) {
 43290:         *foundp = false;
 43290:         return true;
 43290:     }
 43290:     JSBool ok = obj->isNative()
 94227:                 ? obj->changePropertyAttributes(cx, shape, attrs)
 80622:                 : obj->setGenericAttributes(cx, id, &attrs);
 43290:     if (ok)
 43290:         *foundp = true;
 43228:     return ok;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
103320: JS_SetPropertyAttributes(JSContext *cx, JSObject *obj_, const char *name,
 91237:                          unsigned attrs, JSBool *foundp)
     1: {
103320:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
102586:     Rooted<jsid> id(cx, AtomToId(atom));
102586:     return atom && SetPropertyAttributesById(cx, obj, id, attrs, foundp);
     1: }
     1: 
  7927: JS_PUBLIC_API(JSBool)
103320: JS_SetUCPropertyAttributes(JSContext *cx, JSObject *obj_, const jschar *name, size_t namelen,
 91237:                            unsigned attrs, JSBool *foundp)
 43228: {
103320:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
102586:     Rooted<jsid> id(cx, AtomToId(atom));
102586:     return atom && SetPropertyAttributesById(cx, obj, id, attrs, foundp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 43228: JS_GetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
 43228: {
 81415:     return JS_ForwardGetPropertyTo(cx, obj, id, obj, vp);
 81415: }
 81415: 
 81415: JS_PUBLIC_API(JSBool)
 98960: JS_ForwardGetPropertyTo(JSContext *cx, JSObject *obj, jsid id_, JSObject *onBehalfOf_, jsval *vp)
 98960: {
 99421:     RootedId id(cx, id_);
 99421:     RootedObject onBehalfOf(cx, onBehalfOf_);
 98960: 
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 81415:     assertSameCompartment(cx, onBehalfOf);
 43228:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 81415:     return obj->getGeneric(cx, onBehalfOf, id, vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
102586: JS_GetPropertyByIdDefault(JSContext *cx, JSObject *obj_, jsid id_, jsval def, jsval *vp)
102586: {
102586:     Rooted<JSObject*> obj(cx, obj_);
102586:     Rooted<jsid> id(cx, id_);
102586:     return baseops::GetPropertyDefault(cx, obj, id, def, vp);
 56211: }
 56211: 
 56211: JS_PUBLIC_API(JSBool)
 84755: JS_GetElement(JSContext *cx, JSObject *obj, uint32_t index, jsval *vp)
 75055: {
 81415:     return JS_ForwardGetElementTo(cx, obj, index, obj, vp);
 81415: }
 81415: 
 81415: JS_PUBLIC_API(JSBool)
 98960: JS_ForwardGetElementTo(JSContext *cx, JSObject *obj, uint32_t index, JSObject *onBehalfOf_, jsval *vp)
 98960: {
 99421:     RootedObject onBehalfOf(cx, onBehalfOf_);
 98960: 
103783:     AssertHeapIsIdle(cx);
 81415:     CHECK_REQUEST(cx);
 81415:     assertSameCompartment(cx, obj);
 81415:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 81415:     return obj->getElement(cx, onBehalfOf, index, vp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 98960: JS_GetElementIfPresent(JSContext *cx, JSObject *obj, uint32_t index, JSObject *onBehalfOf_, jsval *vp, JSBool* present)
 98960: {
 99421:     RootedObject onBehalfOf(cx, onBehalfOf_);
 98960: 
103783:     AssertHeapIsIdle(cx);
 81419:     CHECK_REQUEST(cx);
 81419:     assertSameCompartment(cx, obj);
 81419:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 81419:     bool isPresent;
 81419:     if (!obj->getElementIfPresent(cx, onBehalfOf, index, vp, &isPresent))
 81419:         return false;
 81419:     *present = isPresent;
 81419:     return true;
 81419: }
 81419: 
 81419: JS_PUBLIC_API(JSBool)
 97353: JS_GetProperty(JSContext *cx, JSObject *obj_, const char *name, jsval *vp)
 97353: {
 99421:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_GetPropertyById(cx, obj, AtomToId(atom), vp);
  7927: }
  7927: 
     1: JS_PUBLIC_API(JSBool)
 97353: JS_GetPropertyDefault(JSContext *cx, JSObject *obj_, const char *name, jsval def, jsval *vp)
 97353: {
 99421:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_GetPropertyByIdDefault(cx, obj, AtomToId(atom), def, vp);
 56211: }
 56211: 
 56211: JS_PUBLIC_API(JSBool)
 97353: JS_GetUCProperty(JSContext *cx, JSObject *obj_, const jschar *name, size_t namelen, jsval *vp)
 97353: {
 99421:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_GetPropertyById(cx, obj, AtomToId(atom), vp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 98960: JS_GetMethodById(JSContext *cx, JSObject *obj_, jsid id_, JSObject **objp, jsval *vp)
 98960: {
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedId id(cx, id_);
 98960: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 98960:     if (!GetMethod(cx, obj, id, 0, vp))
     1:         return JS_FALSE;
 26187:     if (objp)
     1:         *objp = obj;
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 43229: JS_GetMethod(JSContext *cx, JSObject *obj, const char *name, JSObject **objp, jsval *vp)
     1: {
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_GetMethodById(cx, obj, AtomToId(atom), objp, vp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
103345: JS_SetPropertyById(JSContext *cx, JSObject *objArg, jsid id_, jsval *vp)
 98960: {
 99421:     RootedId id(cx, id_);
103345:     Rooted<JSObject*> obj(cx, objArg);
 98960: 
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 43228:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
103345:     return obj->setGeneric(cx, obj, id, vp, false);
103345: }
103345: 
103345: JS_PUBLIC_API(JSBool)
103345: JS_SetElement(JSContext *cx, JSObject *obj_, uint32_t index, jsval *vp)
103345: {
103345:     RootedObject obj(cx, obj_);
103345: 
103783:     AssertHeapIsIdle(cx);
 98960:     CHECK_REQUEST(cx);
 98960:     assertSameCompartment(cx, obj, *vp);
 81415:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
103345:     return obj->setElement(cx, obj, index, vp, false);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 97353: JS_SetProperty(JSContext *cx, JSObject *obj_, const char *name, jsval *vp)
 97353: {
 99421:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 97828:     return atom && JS_SetPropertyById(cx, obj, AtomToId(atom), vp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
103320: JS_SetUCProperty(JSContext *cx, JSObject *obj_, const jschar *name, size_t namelen, jsval *vp)
103320: {
103320:     RootedObject obj(cx, obj_);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 97828:     return atom && JS_SetPropertyById(cx, obj, AtomToId(atom), vp);
 20964: }
 20964: 
 20964: JS_PUBLIC_API(JSBool)
 43228: JS_DeletePropertyById2(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
 43228: {
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 43228:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 86790: 
102586:     if (JSID_IS_SPECIAL(id)) {
102586:         Rooted<SpecialId> sid(cx, JSID_TO_SPECIALID(id));
102586:         return obj->deleteSpecial(cx, sid, rval, false);
102586:     }
 86790: 
 86790:     return obj->deleteByValue(cx, IdToValue(id), rval, false);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 84755: JS_DeleteElement2(JSContext *cx, JSObject *obj, uint32_t index, jsval *rval)
 75053: {
103783:     AssertHeapIsIdle(cx);
 75053:     CHECK_REQUEST(cx);
 86790:     assertSameCompartment(cx, obj);
 86790:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 86790:     return obj->deleteElement(cx, index, rval, false);
 86790: }
 86790: 
 86790: JS_PUBLIC_API(JSBool)
103320: JS_DeleteProperty2(JSContext *cx, JSObject *obj_, const char *name, jsval *rval)
103320: {
103320:     RootedObject obj(cx, obj_);
103320: 
 86790:     CHECK_REQUEST(cx);
 86790:     assertSameCompartment(cx, obj);
 86790:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 86790: 
 86790:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 86790:     if (!atom)
 75053:         return false;
 86790: 
 86790:     return obj->deleteByValue(cx, StringValue(atom), rval, false);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
103320: JS_DeleteUCProperty2(JSContext *cx, JSObject *obj_, const jschar *name, size_t namelen, jsval *rval)
103320: {
103320:     RootedObject obj(cx, obj_);
103320: 
 86790:     CHECK_REQUEST(cx);
 86790:     assertSameCompartment(cx, obj);
 86790:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
 86790: 
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 86790:     if (!atom)
 86790:         return false;
 86790: 
 86790:     return obj->deleteByValue(cx, StringValue(atom), rval, false);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 43228: JS_DeletePropertyById(JSContext *cx, JSObject *obj, jsid id)
 43228: {
 43228:     jsval junk;
 43228:     return JS_DeletePropertyById2(cx, obj, id, &junk);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 84755: JS_DeleteElement(JSContext *cx, JSObject *obj, uint32_t index)
     1: {
     1:     jsval junk;
     1:     return JS_DeleteElement2(cx, obj, index, &junk);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 43228: JS_DeleteProperty(JSContext *cx, JSObject *obj, const char *name)
 43228: {
 43228:     jsval junk;
 43228:     return JS_DeleteProperty2(cx, obj, name, &junk);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
 98960: JS_ClearScope(JSContext *cx, JSObject *obj_)
 98960: {
 99421:     RootedObject obj(cx, obj_);
 98960: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
     1: 
 94738:     ClearOp clearOp = obj->getOps()->clear;
 48622:     if (clearOp)
 48622:         clearOp(cx, obj);
 48622: 
 48622:     if (obj->isNative())
 48622:         js_ClearNative(cx, obj);
     1: 
     1:     /* Clear cached class objects on the global object. */
 68955:     if (obj->isGlobal())
 86483:         obj->asGlobal().clear(cx);
 47602: 
 47602:     js_InitRandom(cx);
     1: }
     1: 
     1: JS_PUBLIC_API(JSIdArray *)
     1: JS_Enumerate(JSContext *cx, JSObject *obj)
     1: {
103783:     AssertHeapIsIdle(cx);
 42641:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 43290: 
 48470:     AutoIdVector props(cx);
     1:     JSIdArray *ida;
 54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY, &props) || !VectorToIdArray(cx, props, &ida))
 68902:         return NULL;
 42641:     return ida;
     1: }
     1: 
     1: /*
     1:  * XXX reverse iterator for properties, unreverse and meld with jsinterp.c's
     1:  *     prop_iterator_class somehow...
 31501:  * + preserve the obj->enumerate API while optimizing the native object case
 52503:  * + native case here uses a Shape *, but that iterates in reverse!
     1:  * + so we make non-native match, by reverse-iterating after JS_Enumerating
     1:  */
 84755: const uint32_t JSSLOT_ITER_INDEX = 0;
     1: 
     1: static void
 94738: prop_iter_finalize(FreeOp *fop, JSObject *obj)
     1: {
 31452:     void *pdata = obj->getPrivate();
 31452:     if (!pdata)
     1:         return;
     1: 
 55746:     if (obj->getSlot(JSSLOT_ITER_INDEX).toInt32() >= 0) {
     1:         /* Non-native case: destroy the ida enumerated when obj was created. */
 31452:         JSIdArray *ida = (JSIdArray *) pdata;
 94740:         DestroyIdArray(fop, ida);
     1:     }
     1: }
     1: 
   583: static void
   583: prop_iter_trace(JSTracer *trc, JSObject *obj)
     1: {
 31452:     void *pdata = obj->getPrivate();
 31452:     if (!pdata)
 31452:         return;
 31452: 
 55746:     if (obj->getSlot(JSSLOT_ITER_INDEX).toInt32() < 0) {
 82129:         /*
 82129:          * Native case: just mark the next property to visit. We don't need a
 82129:          * barrier here because the pointer is updated via setPrivate, which
 82129:          * always takes a barrier.
 82129:          */
 91557:         Shape *tmp = (Shape *)pdata;
 91557:         MarkShapeUnbarriered(trc, &tmp, "prop iter shape");
 91849:         obj->setPrivateUnbarriered(tmp);
     1:     } else {
     1:         /* Non-native case: mark each id in the JSIdArray private. */
 31452:         JSIdArray *ida = (JSIdArray *) pdata;
 90129:         MarkIdRange(trc, ida->length, ida->vector, "prop iter");
 48470:     }
 48470: }
 48470: 
 48470: static Class prop_iter_class = {
     1:     "PropertyIterator",
 92217:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS | JSCLASS_HAS_RESERVED_SLOTS(1),
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub,
 48622:     prop_iter_finalize,
 48622:     NULL,           /* checkAccess */
 48622:     NULL,           /* call        */
 48622:     NULL,           /* construct   */
 48622:     NULL,           /* hasInstance */
 64218:     prop_iter_trace
     1: };
     1: 
     1: JS_PUBLIC_API(JSObject *)
103320: JS_NewPropertyIterator(JSContext *cx, JSObject *obj_)
103320: {
103320:     RootedObject obj(cx, obj_);
     1:     JSObject *iterobj;
 82129:     void *pdata;
 91450:     int index;
     1:     JSIdArray *ida;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 83275:     iterobj = NewObjectWithClassProto(cx, &prop_iter_class, NULL, obj);
103320:     AssertRootingUnnecessary safe(cx);
     1:     if (!iterobj)
     1:         return NULL;
     1: 
 40430:     if (obj->isNative()) {
 52503:         /* Native case: start with the last property in obj. */
 82129:         pdata = (void *)obj->lastProperty();
     1:         index = -1;
     1:     } else {
     1:         /*
     1:          * Non-native case: enumerate a JSIdArray and keep it via private.
     1:          *
     1:          * Note: we have to make sure that we root obj around the call to
     1:          * JS_Enumerate to protect against multiple allocations under it.
     1:          */
     1:         ida = JS_Enumerate(cx, obj);
     1:         if (!ida)
 31452:             return NULL;
     1:         pdata = ida;
     1:         index = ida->length;
     1:     }
     1: 
     1:     /* iterobj cannot escape to other threads here. */
 82129:     iterobj->setPrivate(pdata);
 74457:     iterobj->setSlot(JSSLOT_ITER_INDEX, Int32Value(index));
     1:     return iterobj;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_NextProperty(JSContext *cx, JSObject *iterobj, jsid *idp)
     1: {
103320:     AssertRootingUnnecessary safe(cx);
 91450:     int32_t i;
103639:     Shape *shape;
     1:     JSIdArray *ida;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, iterobj);
 55746:     i = iterobj->getSlot(JSSLOT_ITER_INDEX).toInt32();
     1:     if (i < 0) {
     1:         /* Native case: private data is a property tree node pointer. */
 58687:         JS_ASSERT(iterobj->getParent()->isNative());
 52503:         shape = (Shape *) iterobj->getPrivate();
     1: 
 74907:         while (shape->previous() && !shape->enumerable())
 52503:             shape = shape->previous();
 52503: 
 52503:         if (!shape->previous()) {
 83221:             JS_ASSERT(shape->isEmptyShape());
 48470:             *idp = JSID_VOID;
     1:         } else {
 84173:             iterobj->setPrivate(const_cast<Shape *>(shape->previous().get()));
 83221:             *idp = shape->propid();
     1:         }
     1:     } else {
     1:         /* Non-native case: use the ida enumerated when iterobj was created. */
 32684:         ida = (JSIdArray *) iterobj->getPrivate();
     1:         JS_ASSERT(i <= ida->length);
 55479:         STATIC_ASSUME(i <= ida->length);
     1:         if (i == 0) {
 48470:             *idp = JSID_VOID;
     1:         } else {
     1:             *idp = ida->vector[--i];
 48470:             iterobj->setSlot(JSSLOT_ITER_INDEX, Int32Value(i));
     1:         }
     1:     }
     1:     return JS_TRUE;
     1: }
     1: 
103626: JS_PUBLIC_API(JSObject *)
103626: JS_NewElementIterator(JSContext *cx, JSObject *obj_)
103626: {
103783:     AssertHeapIsIdle(cx);
103626:     CHECK_REQUEST(cx);
103626:     assertSameCompartment(cx, obj_);
103626: 
103626:     Rooted<JSObject*> obj(cx, obj_);
103626:     return ElementIteratorObject::create(cx, obj);
103626: }
103626: 
103626: JS_PUBLIC_API(JSObject *)
103626: JS_ElementIteratorStub(JSContext *cx, JSHandleObject obj, JSBool keysonly)
103626: {
103626:     JS_ASSERT(!keysonly);
103626:     return JS_NewElementIterator(cx, obj);
 89625: }
 89625: 
 89826: JS_PUBLIC_API(jsval)
 89826: JS_GetReservedSlot(JSObject *obj, uint32_t index)
 89826: {
 90279:     return obj->getReservedSlot(index);
 89826: }
 89826: 
 89826: JS_PUBLIC_API(void)
 89826: JS_SetReservedSlot(JSObject *obj, uint32_t index, jsval v)
 89826: {
 90279:     obj->setReservedSlot(index, v);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSObject *)
 91450: JS_NewArrayObject(JSContext *cx, int length, jsval *vector)
 43228: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 91612: 
 91688:     assertSameCompartment(cx, JSValueArray(vector, vector ? (uint32_t)length : 0));
 91688:     return NewDenseCopiedArray(cx, (uint32_t)length, vector);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 43228: JS_IsArrayObject(JSContext *cx, JSObject *obj)
 43228: {
 47485:     assertSameCompartment(cx, obj);
 79390:     return ObjectClassIs(*obj, ESClass_Array, cx);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 91688: JS_GetArrayLength(JSContext *cx, JSObject *obj, uint32_t *lengthp)
 43228: {
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 43228:     return js_GetLengthProperty(cx, obj, lengthp);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 91688: JS_SetArrayLength(JSContext *cx, JSObject *obj, uint32_t length)
 43228: {
103783:     AssertHeapIsIdle(cx);
 43228:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 43228:     return js_SetLengthProperty(cx, obj, length);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 98960: JS_CheckAccess(JSContext *cx, JSObject *obj, jsid id_, JSAccessMode mode,
 91237:                jsval *vp, unsigned *attrsp)
     1: {
 99421:     RootedId id(cx, id_);
 98960: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, id);
 78614:     return CheckAccess(cx, obj, id, mode, vp, attrsp);
     1: }
     1: 
 91900: JS_PUBLIC_API(void)
 91900: JS_HoldPrincipals(JSPrincipals *principals)
 91900: {
104326:     JS_ATOMIC_INCREMENT(&principals->refcount);
 91900: }
 91900: 
 91900: JS_PUBLIC_API(void)
 91900: JS_DropPrincipals(JSRuntime *rt, JSPrincipals *principals)
     1: {
104326:     int rc = JS_ATOMIC_DECREMENT(&principals->refcount);
104326:     if (rc == 0)
 91900:         rt->destroyPrincipals(principals);
 91900: }
 91900: 
 91900: JS_PUBLIC_API(void)
 91900: JS_SetSecurityCallbacks(JSRuntime *rt, const JSSecurityCallbacks *scb)
 91900: {
 91900:     JS_ASSERT(scb != &NullSecurityCallbacks);
 91900:     rt->securityCallbacks = scb ? scb : &NullSecurityCallbacks;
 91900: }
 91900: 
 91900: JS_PUBLIC_API(const JSSecurityCallbacks *)
 91900: JS_GetSecurityCallbacks(JSRuntime *rt)
 91900: {
 91900:     return (rt->securityCallbacks != &NullSecurityCallbacks) ? rt->securityCallbacks : NULL;
     1: }
     1: 
 73495: JS_PUBLIC_API(void)
 73495: JS_SetTrustedPrincipals(JSRuntime *rt, JSPrincipals *prin)
 73495: {
 73495:     rt->setTrustedPrincipals(prin);
 73495: }
 73495: 
 91900: extern JS_PUBLIC_API(void)
 91900: JS_InitDestroyPrincipalsCallback(JSRuntime *rt, JSDestroyPrincipalsOp destroyPrincipals)
 91900: {
 91900:     JS_ASSERT(destroyPrincipals);
 91900:     JS_ASSERT(!rt->destroyPrincipals);
 91900:     rt->destroyPrincipals = destroyPrincipals;
 91900: }
 91900: 
     1: JS_PUBLIC_API(JSFunction *)
 91237: JS_NewFunction(JSContext *cx, JSNative native, unsigned nargs, unsigned flags,
 99364:                JSObject *parent_, const char *name)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
     1:     JSAtom *atom;
     1: 
 99421:     RootedObject parent(cx, parent_);
 99364: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, parent);
     1: 
     1:     if (!name) {
     1:         atom = NULL;
     1:     } else {
 70270:         atom = js_Atomize(cx, name, strlen(name));
     1:         if (!atom)
     1:             return NULL;
     1:     }
 86437: 
 99364:     return js_NewFunction(cx, NULL, native, nargs, flags, parent, atom);
     1: }
     1: 
 57721: JS_PUBLIC_API(JSFunction *)
 99364: JS_NewFunctionById(JSContext *cx, JSNative native, unsigned nargs, unsigned flags, JSObject *parent_,
 57721:                    jsid id)
 57721: {
 99421:     RootedObject parent(cx, parent_);
 99364: 
 57721:     JS_ASSERT(JSID_IS_STRING(id));
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 57721:     CHECK_REQUEST(cx);
 57721:     assertSameCompartment(cx, parent);
 57721: 
 99364:     return js_NewFunction(cx, NULL, native, nargs, flags, parent, JSID_TO_ATOM(id));
 57721: }
 57721: 
     1: JS_PUBLIC_API(JSObject *)
 95355: JS_CloneFunctionObject(JSContext *cx, JSObject *funobj, JSObject *parent_)
 95355: {
103783:     AssertHeapIsIdle(cx);
 95355:     CHECK_REQUEST(cx);
 95355:     assertSameCompartment(cx, parent_);  // XXX no funobj for now
 95355: 
 99421:     RootedObject parent(cx, parent_);
 95355: 
 38604:     if (!parent) {
 71696:         if (cx->hasfp())
 96793:             parent = cx->fp()->scopeChain();
 38604:         if (!parent)
 38604:             parent = cx->globalObject;
 38604:         JS_ASSERT(parent);
 38604:     }
 38604: 
 77817:     if (!funobj->isFunction()) {
103274:         ReportIsNotFunction(cx, ObjectValue(*funobj));
 27012:         return NULL;
 27012:     }
 27012: 
104378:     /*
104378:      * If a function was compiled as compile-and-go or was compiled to be
104378:      * lexically nested inside some other script, we cannot clone it without
104378:      * breaking the compiler's assumptions.
104378:      */
 99421:     RootedFunction fun(cx, funobj->toFunction());
104378:     if (fun->isInterpreted() &&
104378:         (fun->script()->compileAndGo || fun->script()->enclosingStaticScope()))
104378:     {
 77343:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 77343:                              JSMSG_BAD_CLONE_FUNOBJ_SCOPE);
 77343:         return NULL;
 77343:     }
 77343: 
 98316:     if (fun->isBoundFunction()) {
 98316:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 98316:                              JSMSG_CANT_CLONE_OBJECT);
 98316:         return NULL;
 98316:     }
 93245: 
 83258:     return CloneFunctionObject(cx, fun, parent, fun->getAllocKind());
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
     1: JS_GetFunctionObject(JSFunction *fun)
     1: {
 76812:     return fun;
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_GetFunctionId(JSFunction *fun)
     1: {
 64345:     return fun->atom;
     1: }
     1: 
 91237: JS_PUBLIC_API(unsigned)
     1: JS_GetFunctionFlags(JSFunction *fun)
     1: {
     1:     return fun->flags;
     1: }
     1: 
 84755: JS_PUBLIC_API(uint16_t)
     1: JS_GetFunctionArity(JSFunction *fun)
     1: {
     1:     return fun->nargs;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ObjectIsFunction(JSContext *cx, JSObject *obj)
     1: {
 77817:     return obj->isFunction();
     1: }
     1: 
 60563: JS_PUBLIC_API(JSBool)
 60563: JS_ObjectIsCallable(JSContext *cx, JSObject *obj)
 60563: {
 60563:     return obj->isCallable();
 60563: }
 60563: 
 80059: JS_PUBLIC_API(JSBool)
 80059: JS_IsNativeFunction(JSObject *funobj, JSNative call)
 80059: {
 80059:     if (!funobj->isFunction())
 80059:         return false;
 83252:     JSFunction *fun = funobj->toFunction();
 80059:     return fun->isNative() && fun->native() == call;
 80059: }
 80059: 
 94831: JS_PUBLIC_API(JSObject*)
 94831: JS_BindCallable(JSContext *cx, JSObject *callable, JSObject *newThis)
 94831: {
 99421:     RootedObject target(cx, callable);
 99421:     RootedValue thisArg(cx, ObjectValue(*newThis));
 97353:     return js_fun_bind(cx, target, thisArg, NULL, 0);
 94831: }
 94831: 
 80157: JSBool
 91237: js_generic_native_method_dispatcher(JSContext *cx, unsigned argc, Value *vp)
 48470: {
 83258:     JSFunctionSpec *fs = (JSFunctionSpec *)
 83301:         vp->toObject().toFunction()->getExtendedSlot(0).toPrivate();
 53557:     JS_ASSERT((fs->flags & JSFUN_GENERIC_NATIVE) != 0);
  4127: 
 41988:     if (argc < 1) {
 48470:         js_ReportMissingArg(cx, *vp, 0);
 41988:         return JS_FALSE;
 41988:     }
 41988: 
  4127:     /*
  4127:      * Copy all actual (argc) arguments down over our |this| parameter, vp[1],
  4127:      * which is almost always the class constructor object, e.g. Array.  Then
  4127:      * call the corresponding prototype native method with our first argument
  4127:      * passed as |this|.
  4127:      */
  4127:     memmove(vp + 1, vp + 2, argc * sizeof(jsval));
  4127: 
 25712:     /* Clear the last parameter in case too few arguments were passed. */
 48470:     vp[2 + --argc].setUndefined();
  4127: 
 82643:     return fs->call(cx, argc, vp);
  4127: }
  4127: 
     1: JS_PUBLIC_API(JSBool)
 99364: JS_DefineFunctions(JSContext *cx, JSObject *obj_, JSFunctionSpec *fs)
 99364: {
 99421:     RootedObject obj(cx, obj_);
 86437: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 91237:     unsigned flags;
 99421:     RootedObject ctor(cx);
     1:     JSFunction *fun;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
     1:     for (; fs->name; fs++) {
     1:         flags = fs->flags;
     1: 
 99421:         RootedAtom atom(cx, js_Atomize(cx, fs->name, strlen(fs->name)));
 77343:         if (!atom)
 77343:             return JS_FALSE;
 77343: 
102586:         Rooted<jsid> id(cx, AtomToId(atom));
102586: 
     1:         /*
     1:          * Define a generic arity N+1 static method for the arity N prototype
     1:          * method if flags contains JSFUN_GENERIC_NATIVE.
     1:          */
     1:         if (flags & JSFUN_GENERIC_NATIVE) {
     1:             if (!ctor) {
     1:                 ctor = JS_GetConstructor(cx, obj);
     1:                 if (!ctor)
     1:                     return JS_FALSE;
     1:             }
     1: 
     1:             flags &= ~JSFUN_GENERIC_NATIVE;
102586:             fun = js_DefineFunction(cx, ctor, id, js_generic_native_method_dispatcher,
102586:                                     fs->nargs + 1, flags, JSFunction::ExtendedFinalizeKind);
     1:             if (!fun)
     1:                 return JS_FALSE;
     1: 
     1:             /*
     1:              * As jsapi.h notes, fs must point to storage that lives as long
     1:              * as fun->object lives.
     1:              */
 83301:             fun->setExtendedSlot(0, PrivateValue(fs));
     1:         }
     1: 
102586:         fun = js_DefineFunction(cx, obj, id, fs->call, fs->nargs, flags);
     1:         if (!fun)
     1:             return JS_FALSE;
     1:     }
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
 99364: JS_DefineFunction(JSContext *cx, JSObject *obj_, const char *name, JSNative call,
 91237:                   unsigned nargs, unsigned attrs)
     1: {
 99421:     RootedObject obj(cx, obj_);
 86437: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 57721:     if (!atom)
 57721:         return NULL;
102586:     Rooted<jsid> id(cx, AtomToId(atom));
102586:     return js_DefineFunction(cx, obj, id, call, nargs, attrs);
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
 99364: JS_DefineUCFunction(JSContext *cx, JSObject *obj_,
     1:                     const jschar *name, size_t namelen, JSNative call,
 91237:                     unsigned nargs, unsigned attrs)
     1: {
 99421:     RootedObject obj(cx, obj_);
 86437: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 40340:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 70270:     JSAtom *atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
 57721:     if (!atom)
 57721:         return NULL;
102586:     Rooted<jsid> id(cx, AtomToId(atom));
102586:     return js_DefineFunction(cx, obj, id, call, nargs, attrs);
 57721: }
 57721: 
 57721: extern JS_PUBLIC_API(JSFunction *)
 98960: JS_DefineFunctionById(JSContext *cx, JSObject *obj_, jsid id_, JSNative call,
 91237:                       unsigned nargs, unsigned attrs)
 57721: {
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedId id(cx, id_);
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 57721:     CHECK_REQUEST(cx);
 57721:     assertSameCompartment(cx, obj);
 98960:     return js_DefineFunction(cx, obj, id, call, nargs, attrs);
 43235: }
 43235: 
 77180: struct AutoLastFrameCheck {
 77180:     AutoLastFrameCheck(JSContext *cx JS_GUARD_OBJECT_NOTIFIER_PARAM)
 77180:       : cx(cx) {
 77180:         JS_ASSERT(cx);
 77180:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 77180:     }
 77180: 
 77180:     ~AutoLastFrameCheck() {
 77180:         if (cx->isExceptionPending() &&
 77180:             !JS_IsRunning(cx) &&
 77180:             !cx->hasRunOption(JSOPTION_DONT_REPORT_UNCAUGHT)) {
 43235:             js_ReportUncaughtException(cx);
 43235:         }
 77180:     }
 77180: 
 77180:   private:
 77180:     JSContext       *cx;
 77180:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 77180: };
 43235: 
 78492: static JSScript *
103320: CompileUCScriptForPrincipalsCommon(JSContext *cx, JSObject *obj_,
 90856:                                    JSPrincipals *principals, JSPrincipals *originPrincipals,
 61450:                                    const jschar *chars, size_t length,
 91237:                                    const char *filename, unsigned lineno, JSVersion version)
 61450: {
103320:     RootedObject obj(cx, obj_);
 61450:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 61450:     CHECK_REQUEST(cx);
 61450:     assertSameCompartment(cx, obj, principals);
 77180:     AutoLastFrameCheck lfc(cx);
 61450: 
 98463:     bool compileAndGo = cx->hasRunOption(JSOPTION_COMPILE_N_GO);
 98463:     bool noScriptRval = cx->hasRunOption(JSOPTION_NO_SCRIPT_RVAL);
 98463:     return frontend::CompileScript(cx, obj, NULL, principals, originPrincipals,
104376:                                    compileAndGo, noScriptRval, chars, length,
104376:                                    filename, lineno, version);
 78492: }
 78492: 
 78492: extern JS_PUBLIC_API(JSScript *)
 53848: JS_CompileUCScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
 53848:                                        JSPrincipals *principals,
 53848:                                        const jschar *chars, size_t length,
 91237:                                        const char *filename, unsigned lineno,
 53848:                                        JSVersion version)
 53848: {
 53848:     AutoVersionAPI avi(cx, version);
 90856:     return CompileUCScriptForPrincipalsCommon(cx, obj, principals, NULL, chars, length,
 90856:                                               filename, lineno, avi.version());
 90856: }
 90856: 
 90856: extern JS_PUBLIC_API(JSScript *)
 90856: JS_CompileUCScriptForPrincipalsVersionOrigin(JSContext *cx, JSObject *obj,
 90856:                                              JSPrincipals *principals,
 90856:                                              JSPrincipals *originPrincipals,
 90856:                                              const jschar *chars, size_t length,
 91237:                                              const char *filename, unsigned lineno,
 90856:                                              JSVersion version)
 90856: {
 90856:     AutoVersionAPI avi(cx, version);
 90856:     return CompileUCScriptForPrincipalsCommon(cx, obj, principals, originPrincipals,
 90856:                                               chars, length, filename, lineno, avi.version());
 53848: }
 53848: 
 78492: JS_PUBLIC_API(JSScript *)
 43229: JS_CompileUCScriptForPrincipals(JSContext *cx, JSObject *obj, JSPrincipals *principals,
 43228:                                 const jschar *chars, size_t length,
 91237:                                 const char *filename, unsigned lineno)
     1: {
 90856:     return CompileUCScriptForPrincipalsCommon(cx, obj, principals, NULL, chars, length,
 90856:                                               filename, lineno, cx->findVersion());
     1: }
     1: 
 78492: JS_PUBLIC_API(JSScript *)
 43229: JS_CompileUCScript(JSContext *cx, JSObject *obj, const jschar *chars, size_t length,
 91237:                    const char *filename, unsigned lineno)
 43228: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 43235:     return JS_CompileUCScriptForPrincipals(cx, obj, NULL, chars, length, filename, lineno);
 43228: }
 43228: 
 78492: JS_PUBLIC_API(JSScript *)
 57678: JS_CompileScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
 57678:                                      JSPrincipals *principals,
 57678:                                      const char *bytes, size_t length,
 91237:                                      const char *filename, unsigned lineno,
 57678:                                      JSVersion version)
 57678: {
 57678:     AutoVersionAPI ava(cx, version);
 57678:     return JS_CompileScriptForPrincipals(cx, obj, principals, bytes, length, filename, lineno);
 57678: }
 57678: 
 78492: JS_PUBLIC_API(JSScript *)
103320: JS_CompileScriptForPrincipals(JSContext *cx, JSObject *obj_,
     1:                               JSPrincipals *principals,
     1:                               const char *bytes, size_t length,
 91237:                               const char *filename, unsigned lineno)
     1: {
103320:     RootedObject obj(cx, obj_);
103320: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 43235: 
 71337:     jschar *chars = InflateString(cx, bytes, &length);
     1:     if (!chars)
     1:         return NULL;
 78492:     JSScript *script =
 64190:         JS_CompileUCScriptForPrincipals(cx, obj, principals, chars, length, filename, lineno);
 64560:     cx->free_(chars);
 78492:     return script;
 78492: }
 78492: 
 78492: JS_PUBLIC_API(JSScript *)
 43229: JS_CompileScript(JSContext *cx, JSObject *obj, const char *bytes, size_t length,
 91237:                  const char *filename, unsigned lineno)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 43235:     return JS_CompileScriptForPrincipals(cx, obj, NULL, bytes, length, filename, lineno);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
103320: JS_BufferIsCompilableUnit(JSContext *cx, JSBool bytes_are_utf8, JSObject *obj_, const char *bytes, size_t length)
103320: {
103320:     RootedObject obj(cx, obj_);
103320: 
     1:     jschar *chars;
     1:     JSBool result;
     1:     JSExceptionState *exnState;
     1:     JSErrorReporter older;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 68907:     if (bytes_are_utf8)
 71337:         chars = InflateString(cx, bytes, &length, CESU8Encoding);
 68907:     else
 71337:         chars = InflateString(cx, bytes, &length);
     1:     if (!chars)
     1:         return JS_TRUE;
     1: 
     1:     /*
     1:      * Return true on any out-of-memory error, so our caller doesn't try to
     1:      * collect more buffered source.
     1:      */
     1:     result = JS_TRUE;
     1:     exnState = JS_SaveExceptionState(cx);
 27012:     {
 99261:         Parser parser(cx, /* prin = */ NULL, /* originPrin = */ NULL,
 99261:                       chars, length, /* filename = */ NULL, /* lineno = */ 1, cx->findVersion(), 
102617:                       /* foldConstants = */ true, /* compileAndGo = */ false);
 99261:         if (parser.init()) {
     1:             older = JS_SetErrorReporter(cx, NULL);
 40860:             if (!parser.parse(obj) &&
 40860:                 parser.tokenStream.isUnexpectedEOF()) {
     1:                 /*
 27012:                  * We ran into an error. If it was because we ran out of
 27012:                  * source, we return false so our caller knows to try to
 27012:                  * collect more buffered source.
     1:                  */
     1:                 result = JS_FALSE;
     1:             }
  6561:             JS_SetErrorReporter(cx, older);
 27012:         }
  6561:     }
 64560:     cx->free_(chars);
     1:     JS_RestoreExceptionState(cx, exnState);
     1:     return result;
     1: }
     1: 
 58990: /* Use the fastest available getc. */
 58990: #if defined(HAVE_GETC_UNLOCKED)
 58990: # define fast_getc getc_unlocked
 58990: #elif defined(HAVE__GETC_NOLOCK)
 58990: # define fast_getc _getc_nolock
 58990: #else
 58990: # define fast_getc getc
 58990: #endif
 58990: 
 78492: static JSScript *
103320: CompileUTF8FileHelper(JSContext *cx, JSObject *obj_, JSPrincipals *principals,
 58990:                       const char* filename, FILE *fp)
 58990: {
103320:     RootedObject obj(cx, obj_);
103320: 
 58990:     struct stat st;
 58990:     int ok = fstat(fileno(fp), &st);
 58990:     if (ok != 0)
 58990:         return NULL;
 58990: 
 84856:     char *buf = NULL;
 58990:     size_t len = st.st_size;
 58990:     size_t i = 0;
 58990:     JSScript *script;
 58990: 
 58990:     /* Read in the whole file, then compile it. */
 58990:     if (fp == stdin) {
 73906:         if (len == 0)
 58990:             len = 8;  /* start with a small buffer, expand as necessary */
 73906: 
 58990:         int c;
 58990:         bool hitEOF = false;
 58990:         while (!hitEOF) {
 58990:             len *= 2;
 84856:             char* tmpbuf = (char *) cx->realloc_(buf, len * sizeof(char));
 58990:             if (!tmpbuf) {
 64560:                 cx->free_(buf);
 58990:                 return NULL;
 58990:             }
 58990:             buf = tmpbuf;
 58990: 
 58990:             while (i < len) {
 58990:                 c = fast_getc(fp);
 58990:                 if (c == EOF) {
 58990:                     hitEOF = true;
 58990:                     break;
 58990:                 }
 84856:                 buf[i++] = c;
 58990:             }
 58990:         }
 58990:     } else {
 84856:         buf = (char *) cx->malloc_(len * sizeof(char));
 58990:         if (!buf)
 58990:             return NULL;
 58990: 
 58990:         int c;
 73906:         // The |i < len| is necessary for files that lie about their length,
 73906:         // e.g. /dev/zero and /dev/random.  See bug 669434.
 73906:         while (i < len && (c = fast_getc(fp)) != EOF)
 84856:             buf[i++] = c;
 58990:     }
 58990: 
 58990:     JS_ASSERT(i <= len);
 58990:     len = i;
 84856:     size_t decodelen = len;
 84856:     jschar *decodebuf = (jschar *)cx->malloc_(decodelen * sizeof(jschar));
 84856:     if (JS_DecodeUTF8(cx, buf, len, decodebuf, &decodelen)) {
 98463:         bool compileAndGo = cx->hasRunOption(JSOPTION_COMPILE_N_GO);
 98463:         bool noScriptRval = cx->hasRunOption(JSOPTION_NO_SCRIPT_RVAL);
 84856:         script = frontend::CompileScript(cx, obj, NULL, principals, NULL,
104376:                                          compileAndGo, noScriptRval, decodebuf, decodelen,
104376:                                          filename, 1, cx->findVersion());
 84856:     } else {
 84856:         script = NULL;
 84856:     }
 64560:     cx->free_(buf);
 84856:     cx->free_(decodebuf);
 78492:     return script;
 78492: }
 78492: 
 78492: JS_PUBLIC_API(JSScript *)
103320: JS_CompileUTF8File(JSContext *cx, JSObject *obj_, const char *filename)
103320: {
103320:     RootedObject obj(cx, obj_);
103320: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj);
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 64190:     FILE *fp;
  6561:     if (!filename || strcmp(filename, "-") == 0) {
  6561:         fp = stdin;
  6561:     } else {
  6561:         fp = fopen(filename, "r");
  6561:         if (!fp) {
  6561:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_OPEN,
  6561:                                  filename, "No such file or directory");
 77180:             return NULL;
 77180:         }
 77180:     }
 77180: 
 84856:     JSScript *script = CompileUTF8FileHelper(cx, obj, NULL, filename, fp);
  6561:     if (fp != stdin)
  6561:         fclose(fp);
 78492:     return script;
 78492: }
 78492: 
 78492: JS_PUBLIC_API(JSScript *)
 84856: JS_CompileUTF8FileHandleForPrincipals(JSContext *cx, JSObject *obj, const char *filename,
 64190:                                       FILE *file, JSPrincipals *principals)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, principals);
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 84856:     return CompileUTF8FileHelper(cx, obj, principals, filename, file);
 64190: }
 64190: 
 78492: JS_PUBLIC_API(JSScript *)
 84856: JS_CompileUTF8FileHandleForPrincipalsVersion(JSContext *cx, JSObject *obj, const char *filename,
 57678:                                              FILE *file, JSPrincipals *principals, JSVersion version)
 57678: {
 57678:     AutoVersionAPI ava(cx, version);
 84856:     return JS_CompileUTF8FileHandleForPrincipals(cx, obj, filename, file, principals);
 57678: }
 57678: 
 78492: JS_PUBLIC_API(JSScript *)
 84856: JS_CompileUTF8FileHandle(JSContext *cx, JSObject *obj, const char *filename, FILE *file)
 43228: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 84856:     return JS_CompileUTF8FileHandleForPrincipals(cx, obj, filename, file, NULL);
 43228: }
 43228: 
 78492: JS_PUBLIC_API(JSObject *)
 80803: JS_GetGlobalFromScript(JSScript *script)
 80803: {
 80803:     JS_ASSERT(!script->isCachedEval);
104376:     return &script->global();
     1: }
     1: 
 61450: static JSFunction *
 99364: CompileUCFunctionForPrincipalsCommon(JSContext *cx, JSObject *obj_,
 53848:                                      JSPrincipals *principals, const char *name,
 91237:                                      unsigned nargs, const char **argnames,
 53848:                                      const jschar *chars, size_t length,
 91237:                                      const char *filename, unsigned lineno, JSVersion version)
     1: {
 99421:     RootedObject obj(cx, obj_);
 86437: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, obj, principals);
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 99421:     RootedAtom funAtom(cx);
 95355:     if (name) {
 70270:         funAtom = js_Atomize(cx, name, strlen(name));
 77180:         if (!funAtom)
 77180:             return NULL;
 77180:     }
 77180: 
102615:     Bindings bindings;
 91237:     for (unsigned i = 0; i < nargs; i++) {
 84755:         uint16_t dummy;
 99421:         RootedAtom argAtom(cx, js_Atomize(cx, argnames[i], strlen(argnames[i])));
 77180:         if (!argAtom || !bindings.addArgument(cx, argAtom, &dummy))
 77180:             return NULL;
 77180:     }
 77180: 
103320:     RootedFunction fun(cx, js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, obj, funAtom));
 77180:     if (!fun)
 77180:         return NULL;
 43228: 
 84691:     if (!frontend::CompileFunctionBody(cx, fun, principals, NULL, &bindings,
 84691:                                        chars, length, filename, lineno, version))
 80634:     {
 77180:         return NULL;
 43228:     }
 43228: 
102586:     if (obj && funAtom) {
102586:         Rooted<jsid> id(cx, AtomToId(funAtom));
102586:         if (!obj->defineGeneric(cx, id, ObjectValue(*fun), NULL, NULL, JSPROP_ENUMERATE))
 77180:             return NULL;
 77180:     }
 77180: 
 43228:     return fun;
 43228: }
 76812: 
 61450: JS_PUBLIC_API(JSFunction *)
 61450: JS_CompileUCFunctionForPrincipalsVersion(JSContext *cx, JSObject *obj,
 61450:                                          JSPrincipals *principals, const char *name,
 91237:                                          unsigned nargs, const char **argnames,
 61450:                                          const jschar *chars, size_t length,
 91237:                                          const char *filename, unsigned lineno,
 61450:                                          JSVersion version)
 61450: {
 61450:     AutoVersionAPI avi(cx, version);
 61450:     return CompileUCFunctionForPrincipalsCommon(cx, obj, principals, name, nargs, argnames, chars,
 61450:                                                 length, filename, lineno, avi.version());
 61450: }
 61450: 
 61450: JS_PUBLIC_API(JSFunction *)
 61450: JS_CompileUCFunctionForPrincipals(JSContext *cx, JSObject *obj,
 61450:                                   JSPrincipals *principals, const char *name,
 91237:                                   unsigned nargs, const char **argnames,
 61450:                                   const jschar *chars, size_t length,
 91237:                                   const char *filename, unsigned lineno)
 61450: {
 61450:     return CompileUCFunctionForPrincipalsCommon(cx, obj, principals, name, nargs, argnames, chars,
 61450:                                                 length, filename, lineno, cx->findVersion());
 61450: }
 43228: 
 43228: JS_PUBLIC_API(JSFunction *)
 43228: JS_CompileUCFunction(JSContext *cx, JSObject *obj, const char *name,
 91237:                      unsigned nargs, const char **argnames,
 43228:                      const jschar *chars, size_t length,
 91237:                      const char *filename, unsigned lineno)
 43228: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 43235:     return JS_CompileUCFunctionForPrincipals(cx, obj, NULL, name, nargs, argnames,
 43235:                                              chars, length, filename, lineno);
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
103320: JS_CompileFunctionForPrincipals(JSContext *cx, JSObject *obj_,
     1:                                 JSPrincipals *principals, const char *name,
 91237:                                 unsigned nargs, const char **argnames,
     1:                                 const char *bytes, size_t length,
 91237:                                 const char *filename, unsigned lineno)
     1: {
103320:     RootedObject obj(cx, obj_);
103320: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 71337:     jschar *chars = InflateString(cx, bytes, &length);
     1:     if (!chars)
     1:         return NULL;
 43235:     JSFunction *fun = JS_CompileUCFunctionForPrincipals(cx, obj, principals, name,
     1:                                                         nargs, argnames, chars, length,
     1:                                                         filename, lineno);
 64560:     cx->free_(chars);
     1:     return fun;
     1: }
     1: 
     1: JS_PUBLIC_API(JSFunction *)
 43228: JS_CompileFunction(JSContext *cx, JSObject *obj, const char *name,
 91237:                    unsigned nargs, const char **argnames,
 43228:                    const char *bytes, size_t length,
 91237:                    const char *filename, unsigned lineno)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 43235:     return JS_CompileFunctionForPrincipals(cx, obj, NULL, name, nargs, argnames, bytes, length,
     1:                                            filename, lineno);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
 91237: JS_DecompileScript(JSContext *cx, JSScript *script, const char *name, unsigned indent)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
     1:     JSPrinter *jp;
     1:     JSString *str;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 56852: #ifdef DEBUG
 77659:     if (cx->compartment != script->compartment())
 77659:         CompartmentChecker::fail(cx->compartment, script->compartment());
 56852: #endif
 35112:     jp = js_NewPrinter(cx, name, NULL,
     1:                        indent & ~JS_DONT_PRETTY_PRINT,
 35040:                        !(indent & JS_DONT_PRETTY_PRINT),
 35113:                        false, false);
     1:     if (!jp)
     1:         return NULL;
     1:     if (js_DecompileScript(jp, script))
     1:         str = js_GetPrinterOutput(jp);
     1:     else
     1:         str = NULL;
 61225:     js_DestroyPrinter(jp);
     1:     return str;
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
 91237: JS_DecompileFunction(JSContext *cx, JSFunction *fun, unsigned indent)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, fun);
 35040:     return js_DecompileToString(cx, "JS_DecompileFunction", fun,
     1:                                 indent & ~JS_DONT_PRETTY_PRINT,
 35040:                                 !(indent & JS_DONT_PRETTY_PRINT),
 35113:                                 false, false, js_DecompileFunction);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
 91237: JS_DecompileFunctionBody(JSContext *cx, JSFunction *fun, unsigned indent)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, fun);
 35040:     return js_DecompileToString(cx, "JS_DecompileFunctionBody", fun,
     1:                                 indent & ~JS_DONT_PRETTY_PRINT,
 35040:                                 !(indent & JS_DONT_PRETTY_PRINT),
 35113:                                 false, false, js_DecompileFunctionBody);
     1: }
     1: 
 97069: JS_NEVER_INLINE JS_PUBLIC_API(JSBool)
103320: JS_ExecuteScript(JSContext *cx, JSObject *obj, JSScript *scriptArg_, jsval *rval)
103320: {
103320:     RootedScript scriptArg(cx, scriptArg_);
103320: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 94867:     assertSameCompartment(cx, obj);
 97069:     if (cx->compartment != obj->compartment())
 97182:         *(volatile int *) 0 = 0xf0;
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
101829:     JS::Anchor<JSScript *> script(NULL);
 94867: 
 94867:     /*
 94867:      * Mozilla caches pre-compiled scripts (e.g., in the XUL prototype cache)
 94867:      * and runs them against multiple globals. With a compartment per global,
 94867:      * this requires cloning the pre-compiled script into each new global.
 94867:      * Since each script gets run once, there is no point in trying to cache
 94867:      * this clone. Ideally, this would be handled at some pinch point in
 94867:      * mozilla, but there doesn't seem to be one, so we handle it here.
 94867:      */
 94867:     if (scriptArg->compartment() != obj->compartment()) {
104378:         script = CloneScript(cx, NullPtr(), NullPtr(), scriptArg);
 94867:         if (!script.get())
 94867:             return false;
 94867:     } else {
 94867:         script = scriptArg;
 94867:     }
 94867: 
 94867:     return Execute(cx, script.get(), *obj, rval);
 78492: }
 78492: 
 78492: JS_PUBLIC_API(JSBool)
 78492: JS_ExecuteScriptVersion(JSContext *cx, JSObject *obj, JSScript *script, jsval *rval,
 57678:                         JSVersion version)
 57678: {
 57678:     AutoVersionAPI ava(cx, version);
 78492:     return JS_ExecuteScript(cx, obj, script, rval);
 57678: }
 57678: 
 61450: bool
 95355: EvaluateUCScriptForPrincipalsCommon(JSContext *cx, JSObject *obj_,
 84691:                                     JSPrincipals *principals, JSPrincipals *originPrincipals,
 91237:                                     const jschar *chars, unsigned length,
 91237:                                     const char *filename, unsigned lineno,
 84691:                                     jsval *rval, JSVersion compileVersion)
 84691: {
 84691:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 84691: 
 99421:     RootedObject obj(cx, obj_);
 95355: 
 98463:     bool compileAndGo = true;
 98463:     bool noScriptRval = !rval;
 84691: 
 84691:     CHECK_REQUEST(cx);
 84691:     AutoLastFrameCheck lfc(cx);
 84691:     JSScript *script = frontend::CompileScript(cx, obj, NULL, principals, originPrincipals,
104376:                                                compileAndGo, noScriptRval, chars, length,
104376:                                                filename, lineno, compileVersion);
 84691:     if (!script)
 84691:         return false;
 84691: 
 84691:     JS_ASSERT(script->getVersion() == compileVersion);
 84691: 
 84691:     return Execute(cx, script, *obj, rval);
 84691: }
 84691: 
 84691: JS_PUBLIC_API(JSBool)
 84691: JS_EvaluateUCScriptForPrincipals(JSContext *cx, JSObject *obj,
 61450:                                  JSPrincipals *principals,
 91237:                                  const jschar *chars, unsigned length,
 91237:                                  const char *filename, unsigned lineno,
 84691:                                  jsval *rval)
 84691: {
 84691:     return EvaluateUCScriptForPrincipalsCommon(cx, obj, principals, NULL, chars, length,
 84691:                                                filename, lineno, rval, cx->findVersion());
 61450: }
 57678: 
 57678: JS_PUBLIC_API(JSBool)
 53848: JS_EvaluateUCScriptForPrincipalsVersion(JSContext *cx, JSObject *obj,
 53848:                                         JSPrincipals *principals,
 91237:                                         const jschar *chars, unsigned length,
 91237:                                         const char *filename, unsigned lineno,
 53848:                                         jsval *rval, JSVersion version)
 53848: {
 53848:     AutoVersionAPI avi(cx, version);
 84691:     return EvaluateUCScriptForPrincipalsCommon(cx, obj, principals, NULL, chars, length,
 61450:                                                filename, lineno, rval, avi.version());
 53848: }
 53848: 
 84691: extern JS_PUBLIC_API(JSBool)
 84691: JS_EvaluateUCScriptForPrincipalsVersionOrigin(JSContext *cx, JSObject *obj,
     1:                                               JSPrincipals *principals,
 84691:                                               JSPrincipals *originPrincipals,
 91237:                                               const jschar *chars, unsigned length,
 91237:                                               const char *filename, unsigned lineno,
 84691:                                               jsval *rval, JSVersion version)
 84691: {
 84691:     AutoVersionAPI avi(cx, version);
 84691:     return EvaluateUCScriptForPrincipalsCommon(cx, obj, principals, originPrincipals,
 84691:                                                chars, length, filename, lineno, rval,
 84691:                                                avi.version());
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 91237: JS_EvaluateUCScript(JSContext *cx, JSObject *obj, const jschar *chars, unsigned length,
 91237:                     const char *filename, unsigned lineno, jsval *rval)
 43228: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 43235:     return JS_EvaluateUCScriptForPrincipals(cx, obj, NULL, chars, length, filename, lineno, rval);
 43228: }
 43228: 
 91237: /* Ancient unsigned nbytes is part of API/ABI, so use size_t length local. */
 43228: JS_PUBLIC_API(JSBool)
103320: JS_EvaluateScriptForPrincipals(JSContext *cx, JSObject *obj_, JSPrincipals *principals,
 91237:                                const char *bytes, unsigned nbytes,
 91237:                                const char *filename, unsigned lineno, jsval *rval)
 43228: {
103320:     RootedObject obj(cx, obj_);
103320: 
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 43228:     size_t length = nbytes;
 71337:     jschar *chars = InflateString(cx, bytes, &length);
 43228:     if (!chars)
 43228:         return JS_FALSE;
 43235:     JSBool ok = JS_EvaluateUCScriptForPrincipals(cx, obj, principals, chars, length,
 43228:                                                  filename, lineno, rval);
 64560:     cx->free_(chars);
 43228:     return ok;
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 57692: JS_EvaluateScriptForPrincipalsVersion(JSContext *cx, JSObject *obj, JSPrincipals *principals,
 91237:                                       const char *bytes, unsigned nbytes,
 91237:                                       const char *filename, unsigned lineno, jsval *rval, JSVersion version)
 57692: {
 57692:     AutoVersionAPI avi(cx, version);
 57692:     return JS_EvaluateScriptForPrincipals(cx, obj, principals, bytes, nbytes, filename, lineno,
 57692:                                           rval);
 57692: }
 57692: 
 57692: JS_PUBLIC_API(JSBool)
 91237: JS_EvaluateScript(JSContext *cx, JSObject *obj, const char *bytes, unsigned nbytes,
 91237:                   const char *filename, unsigned lineno, jsval *rval)
 43228: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 43235:     return JS_EvaluateScriptForPrincipals(cx, obj, NULL, bytes, nbytes, filename, lineno, rval);
 43228: }
 43228: 
 43228: JS_PUBLIC_API(JSBool)
 91237: JS_CallFunction(JSContext *cx, JSObject *obj, JSFunction *fun, unsigned argc, jsval *argv,
 43229:                 jsval *rval)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 48470:     assertSameCompartment(cx, obj, fun, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 78614:     return Invoke(cx, ObjectOrNullValue(obj), ObjectValue(*fun), argc, argv, rval);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 95355: JS_CallFunctionName(JSContext *cx, JSObject *obj_, const char *name, unsigned argc, jsval *argv,
 43229:                     jsval *rval)
     1: {
 60584:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 95355:     assertSameCompartment(cx, obj_, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 99421:     RootedObject obj(cx, obj_);
 95355: 
 77180:     Value v;
 70270:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
102586:     if (!atom)
102586:         return false;
102586: 
102586:     Rooted<jsid> id(cx, AtomToId(atom));
102586:     return GetMethod(cx, obj, id, 0, &v) &&
 78614:            Invoke(cx, ObjectOrNullValue(obj), v, argc, argv, rval);
 76829: }
 76829: 
 76829: JS_PUBLIC_API(JSBool)
 91237: JS_CallFunctionValue(JSContext *cx, JSObject *obj, jsval fval, unsigned argc, jsval *argv,
 76829:                      jsval *rval)
 76829: {
 76829:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
103783:     AssertHeapIsIdle(cx);
 76829:     CHECK_REQUEST(cx);
 76829:     assertSameCompartment(cx, obj, fval, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 78614:     return Invoke(cx, ObjectOrNullValue(obj), fval, argc, argv, rval);
     1: }
     1: 
 55717: namespace JS {
 55717: 
 55717: JS_PUBLIC_API(bool)
 91237: Call(JSContext *cx, jsval thisv, jsval fval, unsigned argc, jsval *argv, jsval *rval)
 55717: {
103783:     AssertHeapIsIdle(cx);
 55717:     CHECK_REQUEST(cx);
 55717:     assertSameCompartment(cx, thisv, fval, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 77180: 
 78614:     return Invoke(cx, thisv, fval, argc, argv, rval);
 55717: }
 55717: 
 55717: } // namespace JS
 55717: 
 40293: JS_PUBLIC_API(JSObject *)
 91237: JS_New(JSContext *cx, JSObject *ctor, unsigned argc, jsval *argv)
 40293: {
103783:     AssertHeapIsIdle(cx);
 40293:     CHECK_REQUEST(cx);
 48470:     assertSameCompartment(cx, ctor, JSValueArray(argv, argc));
 77180:     AutoLastFrameCheck lfc(cx);
 40293: 
 40293:     // This is not a simple variation of JS_CallFunctionValue because JSOP_NEW
 40293:     // is not a simple variation of JSOP_CALL. We have to determine what class
 40293:     // of object to create, create it, and clamp the return value to an object,
 76829:     // among other details. InvokeConstructor does the hard work.
 42714:     InvokeArgsGuard args;
 69223:     if (!cx->stack.pushInvokeArgs(cx, argc, &args))
 40293:         return NULL;
 42714: 
 68893:     args.calleev().setObject(*ctor);
 50468:     args.thisv().setNull();
 87623:     PodCopy(args.array(), argv, argc);
 40293: 
 77180:     if (!InvokeConstructor(cx, args))
 77180:         return NULL;
 77180: 
 77180:     if (!args.rval().isObject()) {
 57687:         /*
 57687:          * Although constructors may return primitives (via proxies), this
 57687:          * API is asking for an object, so we report an error.
 57687:          */
 57812:         JSAutoByteString bytes;
 57812:         if (js_ValueToPrintable(cx, args.rval(), &bytes)) {
 57687:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_NEW_RESULT,
 57812:                                  bytes.ptr());
 57812:         }
 77180:         return NULL;
 77180:     }
 77180: 
 77180:     return &args.rval().toObject();
 40293: }
 40293: 
 25087: JS_PUBLIC_API(JSOperationCallback)
 25087: JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback)
 25087: {
 25087:     JSOperationCallback old = cx->operationCallback;
 23726:     cx->operationCallback = callback;
 25087:     return old;
 23726: }
 23726: 
 23726: JS_PUBLIC_API(JSOperationCallback)
 23726: JS_GetOperationCallback(JSContext *cx)
 23726: {
 23726:     return cx->operationCallback;
 23726: }
 23726: 
 23726: JS_PUBLIC_API(void)
 91846: JS_TriggerOperationCallback(JSRuntime *rt)
 91846: {
 88135:     rt->triggerOperationCallback();
 25472: }
 25472: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_IsRunning(JSContext *cx)
     1: {
 69223:     StackFrame *fp = cx->maybefp();
 47498:     while (fp && fp->isDummyFrame())
 53840:         fp = fp->prev();
 47498:     return fp != NULL;
 47498: }
 37739: 
 71697: JS_PUBLIC_API(JSBool)
   520: JS_SaveFrameChain(JSContext *cx)
   520: {
103785:     AssertHeapIsIdleOrIterating(cx);
 37912:     CHECK_REQUEST(cx);
 71697:     return cx->stack.saveFrameChain();
   520: }
   520: 
   520: JS_PUBLIC_API(void)
 71697: JS_RestoreFrameChain(JSContext *cx)
   520: {
103785:     AssertHeapIsIdleOrIterating(cx);
 37912:     CHECK_REQUEST(cx);
 71697:     cx->stack.restoreFrameChain();
   520: }
   520: 
 83205: #ifdef MOZ_TRACE_JSCALLS
 83205: JS_PUBLIC_API(void)
 83205: JS_SetFunctionCallback(JSContext *cx, JSFunctionCallback fcb)
 83205: {
 83205:     cx->functionCallback = fcb;
 83205: }
 83205: 
 83205: JS_PUBLIC_API(JSFunctionCallback)
 83205: JS_GetFunctionCallback(JSContext *cx)
 83205: {
 83205:     return cx->functionCallback;
 83205: }
 83205: #endif
 83205: 
     1: /************************************************************************/
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewStringCopyN(JSContext *cx, const char *s, size_t n)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 59890:     return js_NewStringCopyN(cx, s, n);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewStringCopyZ(JSContext *cx, const char *s)
     1: {
     1:     size_t n;
     1:     jschar *js;
     1:     JSString *str;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 87952:     if (!s || !*s)
     1:         return cx->runtime->emptyString;
     1:     n = strlen(s);
 71337:     js = InflateString(cx, s, &n);
     1:     if (!js)
     1:         return NULL;
  4718:     str = js_NewString(cx, js, n);
     1:     if (!str)
 64560:         cx->free_(js);
     1:     return str;
     1: }
     1: 
 48470: JS_PUBLIC_API(JSBool)
 70270: JS_StringHasBeenInterned(JSContext *cx, JSString *str)
 70270: {
103783:     AssertHeapIsIdle(cx);
 70270:     CHECK_REQUEST(cx);
 70270: 
 70270:     if (!str->isAtom())
 70270:         return false;
 70270: 
 70270:     return AtomIsInterned(cx, &str->asAtom());
 48470: }
 48470: 
 97828: JS_PUBLIC_API(jsid)
 97828: INTERNED_STRING_TO_JSID(JSContext *cx, JSString *str)
 97828: {
 97828:     JS_ASSERT(str);
 97828:     JS_ASSERT(((size_t)str & JSID_TYPE_MASK) == 0);
 97828:     JS_ASSERT_IF(cx, JS_StringHasBeenInterned(cx, str));
 97828:     return AtomToId(&str->asAtom());
 97828: }
 97828: 
     1: JS_PUBLIC_API(JSString *)
 59889: JS_InternJSString(JSContext *cx, JSString *str)
 59889: {
103783:     AssertHeapIsIdle(cx);
 59889:     CHECK_REQUEST(cx);
 70270:     JSAtom *atom = js_AtomizeString(cx, str, InternAtom);
 70270:     JS_ASSERT_IF(atom, JS_StringHasBeenInterned(cx, atom));
 70270:     return atom;
 59889: }
 59889: 
 59889: JS_PUBLIC_API(JSString *)
     1: JS_InternString(JSContext *cx, const char *s)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 70270:     JSAtom *atom = js_Atomize(cx, s, strlen(s), InternAtom);
 70270:     JS_ASSERT_IF(atom, JS_StringHasBeenInterned(cx, atom));
 70270:     return atom;
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewUCString(JSContext *cx, jschar *chars, size_t length)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
  4718:     return js_NewString(cx, chars, length);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewUCStringCopyN(JSContext *cx, const jschar *s, size_t n)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
  4076:     return js_NewStringCopyN(cx, s, n);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewUCStringCopyZ(JSContext *cx, const jschar *s)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
     1:     if (!s)
     1:         return cx->runtime->emptyString;
  4076:     return js_NewStringCopyZ(cx, s);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_InternUCStringN(JSContext *cx, const jschar *s, size_t length)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 70270:     JSAtom *atom = js_AtomizeChars(cx, s, length, InternAtom);
 70270:     JS_ASSERT_IF(atom, JS_StringHasBeenInterned(cx, atom));
 70270:     return atom;
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_InternUCString(JSContext *cx, const jschar *s)
     1: {
     1:     return JS_InternUCStringN(cx, s, js_strlen(s));
     1: }
     1: 
     1: JS_PUBLIC_API(size_t)
     1: JS_GetStringLength(JSString *str)
     1: {
 29366:     return str->length();
     1: }
     1: 
 33583: JS_PUBLIC_API(const jschar *)
 59889: JS_GetStringCharsZ(JSContext *cx, JSString *str)
 59889: {
103783:     AssertHeapIsIdleOrStringIsFlat(cx, str);
 59889:     CHECK_REQUEST(cx);
 59889:     assertSameCompartment(cx, str);
 59889:     return str->getCharsZ(cx);
 59234: }
 59234: 
 59234: JS_PUBLIC_API(const jschar *)
 59889: JS_GetStringCharsZAndLength(JSContext *cx, JSString *str, size_t *plength)
 59889: {
103783:     AssertHeapIsIdleOrStringIsFlat(cx, str);
 59889:     CHECK_REQUEST(cx);
 59234:     assertSameCompartment(cx, str);
 59889:     *plength = str->length();
 59889:     return str->getCharsZ(cx);
 59889: }
 59889: 
 59889: JS_PUBLIC_API(const jschar *)
 59889: JS_GetStringCharsAndLength(JSContext *cx, JSString *str, size_t *plength)
 59889: {
103783:     AssertHeapIsIdleOrStringIsFlat(cx, str);
 59889:     CHECK_REQUEST(cx);
 59889:     assertSameCompartment(cx, str);
 59890:     *plength = str->length();
 59890:     return str->getChars(cx);
 59889: }
 59889: 
 59889: JS_PUBLIC_API(const jschar *)
 59889: JS_GetInternedStringChars(JSString *str)
 59889: {
 64345:     return str->asAtom().chars();
 59889: }
 59889: 
 59889: JS_PUBLIC_API(const jschar *)
 59889: JS_GetInternedStringCharsAndLength(JSString *str, size_t *plength)
 59889: {
 64345:     JSAtom &atom = str->asAtom();
 64345:     *plength = atom.length();
 64345:     return atom.chars();
 59889: }
 59889: 
 59889: extern JS_PUBLIC_API(JSFlatString *)
 59889: JS_FlattenString(JSContext *cx, JSString *str)
 59889: {
103783:     AssertHeapIsIdle(cx);
 59889:     CHECK_REQUEST(cx);
 59889:     assertSameCompartment(cx, str);
 59889:     return str->getCharsZ(cx) ? (JSFlatString *)str : NULL;
 59889: }
 59889: 
 59889: extern JS_PUBLIC_API(const jschar *)
 59889: JS_GetFlatStringChars(JSFlatString *str)
 59889: {
 57721:     return str->chars();
 57721: }
 57721: 
 57721: JS_PUBLIC_API(JSBool)
 84755: JS_CompareStrings(JSContext *cx, JSString *str1, JSString *str2, int32_t *result)
 59889: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 81562: 
 59890:     return CompareStrings(cx, str1, str2, result);
 59889: }
 59889: 
 59889: JS_PUBLIC_API(JSBool)
 59889: JS_StringEqualsAscii(JSContext *cx, JSString *str, const char *asciiBytes, JSBool *match)
 59234: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 81562: 
 59890:     JSLinearString *linearStr = str->ensureLinear(cx);
 59890:     if (!linearStr)
 59890:         return false;
 59890:     *match = StringEqualsAscii(linearStr, asciiBytes);
 59890:     return true;
 59234: }
 59234: 
 59889: JS_PUBLIC_API(JSBool)
 59889: JS_FlatStringEqualsAscii(JSFlatString *str, const char *asciiBytes)
 59889: {
 59890:     return StringEqualsAscii(str, asciiBytes);
 57721: }
 57721: 
 57721: JS_PUBLIC_API(size_t)
 59889: JS_PutEscapedFlatString(char *buffer, size_t size, JSFlatString *str, char quote)
 57721: {
 57721:     return PutEscapedString(buffer, size, str, quote);
 57721: }
 57721: 
 59889: JS_PUBLIC_API(size_t)
 59889: JS_PutEscapedString(JSContext *cx, char *buffer, size_t size, JSString *str, char quote)
 59234: {
103783:     AssertHeapIsIdle(cx);
 59890:     JSLinearString *linearStr = str->ensureLinear(cx);
 59890:     if (!linearStr)
 59890:         return size_t(-1);
 59890:     return PutEscapedString(buffer, size, linearStr, quote);
 59234: }
 59234: 
 57721: JS_PUBLIC_API(JSBool)
 57721: JS_FileEscapedString(FILE *fp, JSString *str, char quote)
 57721: {
 59890:     JSLinearString *linearStr = str->ensureLinear(NULL);
 59890:     return linearStr && FileEscapedString(fp, linearStr, quote);
 57721: }
 57721: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_NewGrowableString(JSContext *cx, jschar *chars, size_t length)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 48491:     return js_NewString(cx, chars, length);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
 43229: JS_NewDependentString(JSContext *cx, JSString *str, size_t start, size_t length)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
  4076:     return js_NewDependentString(cx, str, start, length);
     1: }
     1: 
     1: JS_PUBLIC_API(JSString *)
     1: JS_ConcatStrings(JSContext *cx, JSString *left, JSString *right)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
102586:     Rooted<JSString*> lstr(cx, left);
102586:     Rooted<JSString*> rstr(cx, right);
102586:     return js_ConcatStrings(cx, lstr, rstr);
     1: }
     1: 
     1: JS_PUBLIC_API(const jschar *)
     1: JS_UndependString(JSContext *cx, JSString *str)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 59889:     return str->getCharsZ(cx);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_MakeStringImmutable(JSContext *cx, JSString *str)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 64345:     return !!str->ensureFixed(cx);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 43229: JS_EncodeCharacters(JSContext *cx, const jschar *src, size_t srclen, char *dst, size_t *dstlenp)
     1: {
103783:     AssertHeapIsIdle(cx);
 86458:     CHECK_REQUEST(cx);
 86458: 
     1:     size_t n;
     1:     if (!dst) {
 71337:         n = GetDeflatedStringLength(cx, src, srclen);
     1:         if (n == (size_t)-1) {
     1:             *dstlenp = 0;
     1:             return JS_FALSE;
     1:         }
     1:         *dstlenp = n;
     1:         return JS_TRUE;
     1:     }
     1: 
 71337:     return DeflateStringToBuffer(cx, src, srclen, dst, dstlenp);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 43229: JS_DecodeBytes(JSContext *cx, const char *src, size_t srclen, jschar *dst, size_t *dstlenp)
     1: {
103783:     AssertHeapIsIdle(cx);
 86458:     CHECK_REQUEST(cx);
 71337:     return InflateStringToBuffer(cx, src, srclen, dst, dstlenp);
     1: }
     1: 
 68907: JS_PUBLIC_API(JSBool)
 68907: JS_DecodeUTF8(JSContext *cx, const char *src, size_t srclen, jschar *dst,
 68907:               size_t *dstlenp)
 68907: {
103783:     AssertHeapIsIdle(cx);
 86458:     CHECK_REQUEST(cx);
 71337:     return InflateUTF8StringToBuffer(cx, src, srclen, dst, dstlenp);
 68907: }
 68907: 
  8893: JS_PUBLIC_API(char *)
  8893: JS_EncodeString(JSContext *cx, JSString *str)
  8893: {
103783:     AssertHeapIsIdle(cx);
 86458:     CHECK_REQUEST(cx);
 86458: 
 59890:     const jschar *chars = str->getChars(cx);
 59890:     if (!chars)
 59890:         return NULL;
 71337:     return DeflateString(cx, chars, str->length());
  8893: }
  8893: 
 57814: JS_PUBLIC_API(size_t)
 57814: JS_GetStringEncodingLength(JSContext *cx, JSString *str)
 57814: {
 86458:     /* jsd calls us with a NULL cx. Ugh. */
 86458:     if (cx) {
103783:         AssertHeapIsIdle(cx);
 86458:         CHECK_REQUEST(cx);
 86458:     }
 86458: 
 59890:     const jschar *chars = str->getChars(cx);
 59890:     if (!chars)
 59890:         return size_t(-1);
 71337:     return GetDeflatedStringLength(cx, chars, str->length());
 57814: }
 57814: 
 57814: JS_PUBLIC_API(size_t)
 57814: JS_EncodeStringToBuffer(JSString *str, char *buffer, size_t length)
 57814: {
 57814:     /*
 71337:      * FIXME bug 612141 - fix DeflateStringToBuffer interface so the result
 57814:      * would allow to distinguish between insufficient buffer and encoding
 57814:      * error.
 57814:      */
 57814:     size_t writtenLength = length;
 59890:     const jschar *chars = str->getChars(NULL);
 59890:     if (!chars)
 59890:         return size_t(-1);
 71337:     if (DeflateStringToBuffer(NULL, chars, str->length(), buffer, &writtenLength)) {
 57814:         JS_ASSERT(writtenLength <= length);
 57814:         return writtenLength;
 57814:     }
 57814:     JS_ASSERT(writtenLength <= length);
 71337:     size_t necessaryLength = GetDeflatedStringLength(NULL, chars, str->length());
 57814:     if (necessaryLength == size_t(-1))
 57814:         return size_t(-1);
 57814:     if (writtenLength != length) {
 57814:         /* Make sure that the buffer contains only valid UTF-8 sequences. */
 57814:         JS_ASSERT(js_CStringsAreUTF8);
 57814:         PodZero(buffer + writtenLength, length - writtenLength);
 57814:     }
 57814:     return necessaryLength;
 57814: }
 57814: 
 20092: JS_PUBLIC_API(JSBool)
 28100: JS_Stringify(JSContext *cx, jsval *vp, JSObject *replacer, jsval space,
 20092:              JSONWriteCallback callback, void *data)
 20092: {
104205:     RootedValue value(cx, *vp);
104205: 
103783:     AssertHeapIsIdle(cx);
 20092:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, replacer, space);
 60571:     StringBuffer sb(cx);
104205:     if (!js_Stringify(cx, &value, replacer, space, sb))
 31819:         return false;
104205:     *vp = value;
 73060:     if (sb.empty()) {
 73060:         JSAtom *nullAtom = cx->runtime->atomState.nullAtom;
 73060:         return callback(nullAtom->chars(), nullAtom->length(), data);
 73060:     }
 60571:     return callback(sb.begin(), sb.length(), data);
 20092: }
 20092: 
 20092: JS_PUBLIC_API(JSBool)
 84755: JS_ParseJSON(JSContext *cx, const jschar *chars, uint32_t len, jsval *vp)
 67923: {
103783:     AssertHeapIsIdle(cx);
 67923:     CHECK_REQUEST(cx);
 67923: 
 78614:     return ParseJSONWithReviver(cx, chars, len, NullValue(), vp);
 67923: }
 67923: 
 67923: JS_PUBLIC_API(JSBool)
 84755: JS_ParseJSONWithReviver(JSContext *cx, const jschar *chars, uint32_t len, jsval reviver, jsval *vp)
 67923: {
103783:     AssertHeapIsIdle(cx);
 67923:     CHECK_REQUEST(cx);
 67923: 
 78614:     return ParseJSONWithReviver(cx, chars, len, reviver, vp);
 67923: }
 67923: 
 67923: JS_PUBLIC_API(JSBool)
 84755: JS_ReadStructuredClone(JSContext *cx, const uint64_t *buf, size_t nbytes,
 84755:                        uint32_t version, jsval *vp,
 60105:                        const JSStructuredCloneCallbacks *optionalCallbacks,
 60105:                        void *closure)
 58294: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 81562: 
 58294:     if (version > JS_STRUCTURED_CLONE_VERSION) {
 58294:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_CLONE_VERSION);
 58294:         return false;
 58294:     }
 60105:     const JSStructuredCloneCallbacks *callbacks =
 60105:         optionalCallbacks ?
 60105:         optionalCallbacks :
 60105:         cx->runtime->structuredCloneCallbacks;
 78614:     return ReadStructuredClone(cx, buf, nbytes, vp, callbacks, closure);
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 84755: JS_WriteStructuredClone(JSContext *cx, jsval v, uint64_t **bufp, size_t *nbytesp,
 60105:                         const JSStructuredCloneCallbacks *optionalCallbacks,
 60105:                         void *closure)
 60105: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 94180:     assertSameCompartment(cx, v);
 81562: 
 60105:     const JSStructuredCloneCallbacks *callbacks =
 60105:         optionalCallbacks ?
 60105:         optionalCallbacks :
 60105:         cx->runtime->structuredCloneCallbacks;
 78614:     return WriteStructuredClone(cx, v, (uint64_t **) bufp, nbytesp, callbacks, closure);
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 60105: JS_StructuredClone(JSContext *cx, jsval v, jsval *vp,
 60105:                    const JSStructuredCloneCallbacks *optionalCallbacks,
 60105:                    void *closure)
 60105: {
103783:     AssertHeapIsIdle(cx);
 81562:     CHECK_REQUEST(cx);
 94180:     assertSameCompartment(cx, v);
 81562: 
 60105:     const JSStructuredCloneCallbacks *callbacks =
 60105:         optionalCallbacks ?
 60105:         optionalCallbacks :
 60105:         cx->runtime->structuredCloneCallbacks;
 59556:     JSAutoStructuredCloneBuffer buf;
 60105:     return buf.write(cx, v, callbacks, closure) &&
 74542:            buf.read(cx, vp, callbacks, closure);
 74542: }
 74542: 
 74542: void
 74542: JSAutoStructuredCloneBuffer::clear()
 74542: {
 74542:     if (data_) {
 74542:         Foreground::free_(data_);
 74542:         data_ = NULL;
 74542:         nbytes_ = 0;
 74542:         version_ = 0;
 74542:     }
 74542: }
 74542: 
 74542: void
 84755: JSAutoStructuredCloneBuffer::adopt(uint64_t *data, size_t nbytes, uint32_t version)
 74542: {
 74542:     clear();
 74542:     data_ = data;
 74542:     nbytes_ = nbytes;
 74542:     version_ = version;
 74542: }
 74542: 
 74542: bool
 84755: JSAutoStructuredCloneBuffer::copy(const uint64_t *srcData, size_t nbytes, uint32_t version)
 84755: {
 84755:     uint64_t *newData = static_cast<uint64_t *>(OffTheBooks::malloc_(nbytes));
 74542:     if (!newData)
 74542:         return false;
 74542: 
 87623:     js_memcpy(newData, srcData, nbytes);
 74542: 
 74542:     clear();
 74542:     data_ = newData;
 74542:     nbytes_ = nbytes;
 74542:     version_ = version;
 74542:     return true;
 74542: }
 74542: void
 84755: JSAutoStructuredCloneBuffer::steal(uint64_t **datap, size_t *nbytesp, uint32_t *versionp)
 74542: {
 74542:     *datap = data_;
 74542:     *nbytesp = nbytes_;
 74542:     if (versionp)
 74542:         *versionp = version_;
 74542: 
 74542:     data_ = NULL;
 74542:     nbytes_ = 0;
 74542:     version_ = 0;
 74542: }
 74542: 
 74542: bool
 74542: JSAutoStructuredCloneBuffer::read(JSContext *cx, jsval *vp,
 74542:                                   const JSStructuredCloneCallbacks *optionalCallbacks,
 74542:                                   void *closure) const
 74542: {
 74542:     JS_ASSERT(cx);
 74542:     JS_ASSERT(data_);
 74542:     return !!JS_ReadStructuredClone(cx, data_, nbytes_, version_, vp,
 74542:                                     optionalCallbacks, closure);
 74542: }
 74542: 
 74542: bool
 74542: JSAutoStructuredCloneBuffer::write(JSContext *cx, jsval v,
 74542:                                    const JSStructuredCloneCallbacks *optionalCallbacks,
 74542:                                    void *closure)
 74542: {
 74542:     clear();
 74542:     bool ok = !!JS_WriteStructuredClone(cx, v, &data_, &nbytes_,
 74542:                                         optionalCallbacks, closure);
 74542:     if (!ok) {
 74542:         data_ = NULL;
 74542:         nbytes_ = 0;
 74542:         version_ = JS_STRUCTURED_CLONE_VERSION;
 74542:     }
 74542:     return ok;
 74542: }
 74542: 
 74542: void
 74542: JSAutoStructuredCloneBuffer::swap(JSAutoStructuredCloneBuffer &other)
 74542: {
 84755:     uint64_t *data = other.data_;
 74542:     size_t nbytes = other.nbytes_;
 84755:     uint32_t version = other.version_;
 74542: 
 74542:     other.data_ = this->data_;
 74542:     other.nbytes_ = this->nbytes_;
 74542:     other.version_ = this->version_;
 74542: 
 74542:     this->data_ = data;
 74542:     this->nbytes_ = nbytes;
 74542:     this->version_ = version;
 54863: }
 54863: 
 54863: JS_PUBLIC_API(void)
 54863: JS_SetStructuredCloneCallbacks(JSRuntime *rt, const JSStructuredCloneCallbacks *callbacks)
 54863: {
 54863:     rt->structuredCloneCallbacks = callbacks;
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 84755: JS_ReadUint32Pair(JSStructuredCloneReader *r, uint32_t *p1, uint32_t *p2)
 54863: {
 54863:     return r->input().readPair((uint32_t *) p1, (uint32_t *) p2);
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 54863: JS_ReadBytes(JSStructuredCloneReader *r, void *p, size_t len)
 54863: {
 54863:     return r->input().readBytes(p, len);
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 84755: JS_WriteUint32Pair(JSStructuredCloneWriter *w, uint32_t tag, uint32_t data)
 54863: {
 54863:     return w->output().writePair(tag, data);
 54863: }
 54863: 
 54863: JS_PUBLIC_API(JSBool)
 54863: JS_WriteBytes(JSStructuredCloneWriter *w, const void *p, size_t len)
 54863: {
 54863:     return w->output().writeBytes(p, len);
 54863: }
 54863: 
  8893: /*
  8893:  * The following determines whether C Strings are to be treated as UTF-8
  8893:  * or ISO-8859-1.  For correct operation, it must be set prior to the
  8893:  * first call to JS_NewRuntime.
  8893:  */
  8893: #ifndef JS_C_STRINGS_ARE_UTF8
  8893: JSBool js_CStringsAreUTF8 = JS_FALSE;
  8893: #endif
  8893: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_CStringsAreUTF8()
     1: {
  8893:     return js_CStringsAreUTF8;
  8893: }
  8893: 
  8893: JS_PUBLIC_API(void)
  8893: JS_SetCStringsAreUTF8()
  8893: {
  8893:     JS_ASSERT(!js_NewRuntimeWasCalled);
  8893: 
  8893: #ifndef JS_C_STRINGS_ARE_UTF8
  8893:     js_CStringsAreUTF8 = JS_TRUE;
     1: #endif
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ReportError(JSContext *cx, const char *format, ...)
     1: {
     1:     va_list ap;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, format);
     1:     js_ReportErrorVA(cx, JSREPORT_ERROR, format, ap);
     1:     va_end(ap);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ReportErrorNumber(JSContext *cx, JSErrorCallback errorCallback,
 91237:                      void *userRef, const unsigned errorNumber, ...)
     1: {
     1:     va_list ap;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, errorNumber);
     1:     js_ReportErrorNumberVA(cx, JSREPORT_ERROR, errorCallback, userRef,
     1:                            errorNumber, JS_TRUE, ap);
     1:     va_end(ap);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ReportErrorNumberUC(JSContext *cx, JSErrorCallback errorCallback,
 91237:                      void *userRef, const unsigned errorNumber, ...)
     1: {
     1:     va_list ap;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, errorNumber);
     1:     js_ReportErrorNumberVA(cx, JSREPORT_ERROR, errorCallback, userRef,
     1:                            errorNumber, JS_FALSE, ap);
     1:     va_end(ap);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ReportWarning(JSContext *cx, const char *format, ...)
     1: {
     1:     va_list ap;
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, format);
     1:     ok = js_ReportErrorVA(cx, JSREPORT_WARNING, format, ap);
     1:     va_end(ap);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 91237: JS_ReportErrorFlagsAndNumber(JSContext *cx, unsigned flags,
     1:                              JSErrorCallback errorCallback, void *userRef,
 91237:                              const unsigned errorNumber, ...)
     1: {
     1:     va_list ap;
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, errorNumber);
     1:     ok = js_ReportErrorNumberVA(cx, flags, errorCallback, userRef,
     1:                                 errorNumber, JS_TRUE, ap);
     1:     va_end(ap);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
 91237: JS_ReportErrorFlagsAndNumberUC(JSContext *cx, unsigned flags,
     1:                                JSErrorCallback errorCallback, void *userRef,
 91237:                                const unsigned errorNumber, ...)
     1: {
     1:     va_list ap;
     1:     JSBool ok;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     va_start(ap, errorNumber);
     1:     ok = js_ReportErrorNumberVA(cx, flags, errorCallback, userRef,
     1:                                 errorNumber, JS_FALSE, ap);
     1:     va_end(ap);
     1:     return ok;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ReportOutOfMemory(JSContext *cx)
     1: {
     1:     js_ReportOutOfMemory(cx);
     1: }
     1: 
 12983: JS_PUBLIC_API(void)
 12983: JS_ReportAllocationOverflow(JSContext *cx)
 12983: {
 12983:     js_ReportAllocationOverflow(cx);
 12983: }
 12983: 
     1: JS_PUBLIC_API(JSErrorReporter)
 87280: JS_GetErrorReporter(JSContext *cx)
 87280: {
 87280:     return cx->errorReporter;
 87280: }
 87280: 
 87280: JS_PUBLIC_API(JSErrorReporter)
     1: JS_SetErrorReporter(JSContext *cx, JSErrorReporter er)
     1: {
     1:     JSErrorReporter older;
     1: 
     1:     older = cx->errorReporter;
     1:     cx->errorReporter = er;
     1:     return older;
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: /*
 61050:  * Dates.
 61050:  */
 61050: JS_PUBLIC_API(JSObject *)
 61050: JS_NewDateObject(JSContext *cx, int year, int mon, int mday, int hour, int min, int sec)
 61050: {
103783:     AssertHeapIsIdle(cx);
 61050:     CHECK_REQUEST(cx);
 61050:     return js_NewDateObject(cx, year, mon, mday, hour, min, sec);
 61050: }
 61050: 
 61050: JS_PUBLIC_API(JSObject *)
 90955: JS_NewDateObjectMsec(JSContext *cx, double msec)
 61050: {
103783:     AssertHeapIsIdle(cx);
 61050:     CHECK_REQUEST(cx);
 61050:     return js_NewDateObjectMsec(cx, msec);
 61050: }
 61050: 
 61050: JS_PUBLIC_API(JSBool)
 61050: JS_ObjectIsDate(JSContext *cx, JSObject *obj)
 61050: {
103783:     AssertHeapIsIdle(cx);
 61050:     JS_ASSERT(obj);
 61050:     return obj->isDate();
 61050: }
 61050: 
104532: JS_PUBLIC_API(void)
104532: JS_ClearDateCaches(JSContext *cx)
104532: {
104532:     AssertHeapIsIdle(cx);
104532:     CHECK_REQUEST(cx);
104532:     js_ClearDateCaches();
104532: }
104532: 
 61050: /************************************************************************/
 61050: 
 61050: /*
     1:  * Regular Expressions.
     1:  */
     1: JS_PUBLIC_API(JSObject *)
103320: JS_NewRegExpObject(JSContext *cx, JSObject *obj_, char *bytes, size_t length, unsigned flags)
103320: {
103320:     RootedObject obj(cx, obj_);
103320: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 71337:     jschar *chars = InflateString(cx, bytes, &length);
     1:     if (!chars)
     1:         return NULL;
 79981: 
 86483:     RegExpStatics *res = obj->asGlobal().getRegExpStatics();
 79981:     RegExpObject *reobj = RegExpObject::create(cx, res, chars, length, RegExpFlag(flags), NULL);
 64560:     cx->free_(chars);
 53858:     return reobj;
 53858: }
 53858: 
 53858: JS_PUBLIC_API(JSObject *)
 91237: JS_NewUCRegExpObject(JSContext *cx, JSObject *obj, jschar *chars, size_t length, unsigned flags)
 53858: {
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 86483:     RegExpStatics *res = obj->asGlobal().getRegExpStatics();
 79981:     return RegExpObject::create(cx, res, chars, length, RegExpFlag(flags), NULL);
 53858: }
 53858: 
 53858: JS_PUBLIC_API(void)
 53858: JS_SetRegExpInput(JSContext *cx, JSObject *obj, JSString *input, JSBool multiline)
 53858: {
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 53858:     assertSameCompartment(cx, input);
 53858: 
 86483:     obj->asGlobal().getRegExpStatics()->reset(cx, input, !!multiline);
 53858: }
 53858: 
 53858: JS_PUBLIC_API(void)
 53858: JS_ClearRegExpStatics(JSContext *cx, JSObject *obj)
 53858: {
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 53858:     JS_ASSERT(obj);
 53858: 
 86483:     obj->asGlobal().getRegExpStatics()->clear();
 53858: }
 53858: 
 53858: JS_PUBLIC_API(JSBool)
 53858: JS_ExecuteRegExp(JSContext *cx, JSObject *obj, JSObject *reobj, jschar *chars, size_t length,
 53858:                  size_t *indexp, JSBool test, jsval *rval)
 53858: {
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 53858: 
 86483:     RegExpStatics *res = obj->asGlobal().getRegExpStatics();
 89918:     return ExecuteRegExp(cx, res, reobj->asRegExp(), NULL, chars, length,
 80378:                          indexp, test ? RegExpTest : RegExpExec, rval);
 53858: }
 53858: 
 53858: JS_PUBLIC_API(JSObject *)
 91237: JS_NewRegExpObjectNoStatics(JSContext *cx, char *bytes, size_t length, unsigned flags)
 53858: {
103783:     AssertHeapIsIdle(cx);
 53858:     CHECK_REQUEST(cx);
 71337:     jschar *chars = InflateString(cx, bytes, &length);
 53858:     if (!chars)
 53858:         return NULL;
 79981:     RegExpObject *reobj = RegExpObject::createNoStatics(cx, chars, length, RegExpFlag(flags), NULL);
 64560:     cx->free_(chars);
 79981:     return reobj;
     1: }
     1: 
     1: JS_PUBLIC_API(JSObject *)
 91237: JS_NewUCRegExpObjectNoStatics(JSContext *cx, jschar *chars, size_t length, unsigned flags)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 79981:     return RegExpObject::createNoStatics(cx, chars, length, RegExpFlag(flags), NULL);
 53858: }
 53858: 
 53858: JS_PUBLIC_API(JSBool)
 53858: JS_ExecuteRegExpNoStatics(JSContext *cx, JSObject *obj, jschar *chars, size_t length,
 53858:                           size_t *indexp, JSBool test, jsval *rval)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 50911: 
 89918:     return ExecuteRegExp(cx, NULL, obj->asRegExp(), NULL, chars, length, indexp,
 80378:                          test ? RegExpTest : RegExpExec, rval);
 53858: }
     1: 
 70279: JS_PUBLIC_API(JSBool)
 70279: JS_ObjectIsRegExp(JSContext *cx, JSObject *obj)
 70279: {
103783:     AssertHeapIsIdle(cx);
 70279:     JS_ASSERT(obj);
 70279:     return obj->isRegExp();
 70279: }
 70279: 
 91237: JS_PUBLIC_API(unsigned)
 70281: JS_GetRegExpFlags(JSContext *cx, JSObject *obj)
 70281: {
103783:     AssertHeapIsIdle(cx);
 70281:     CHECK_REQUEST(cx);
 70281: 
 86483:     return obj->asRegExp().getFlags();
 70281: }
 70281: 
 70281: JS_PUBLIC_API(JSString *)
 70281: JS_GetRegExpSource(JSContext *cx, JSObject *obj)
 70281: {
103783:     AssertHeapIsIdle(cx);
 70281:     CHECK_REQUEST(cx);
 70281: 
 86483:     return obj->asRegExp().getSource();
 70281: }
 70281: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetLocaleCallbacks(JSContext *cx, JSLocaleCallbacks *callbacks)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     cx->localeCallbacks = callbacks;
     1: }
     1: 
     1: JS_PUBLIC_API(JSLocaleCallbacks *)
     1: JS_GetLocaleCallbacks(JSContext *cx)
     1: {
 86458:     /* This function can be called by a finalizer. */
     1:     return cx->localeCallbacks;
     1: }
     1: 
     1: /************************************************************************/
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_IsExceptionPending(JSContext *cx)
     1: {
 86458:     /* This function can be called by a finalizer. */
 60211:     return (JSBool) cx->isExceptionPending();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_GetPendingException(JSContext *cx, jsval *vp)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 60211:     if (!cx->isExceptionPending())
     1:         return JS_FALSE;
 78614:     *vp = cx->getPendingException();
 60211:     assertSameCompartment(cx, *vp);
     1:     return JS_TRUE;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_SetPendingException(JSContext *cx, jsval v)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
 78614:     cx->setPendingException(v);
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_ClearPendingException(JSContext *cx)
     1: {
103783:     AssertHeapIsIdle(cx);
 60211:     cx->clearPendingException();
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ReportPendingException(JSContext *cx)
     1: {
103783:     AssertHeapIsIdle(cx);
 92711:     CHECK_REQUEST(cx);
 92711: 
 92711:     return js_ReportUncaughtException(cx);
     1: }
     1: 
     1: struct JSExceptionState {
     1:     JSBool throwing;
     1:     jsval  exception;
     1: };
     1: 
     1: JS_PUBLIC_API(JSExceptionState *)
     1: JS_SaveExceptionState(JSContext *cx)
     1: {
     1:     JSExceptionState *state;
     1: 
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 64560:     state = (JSExceptionState *) cx->malloc_(sizeof(JSExceptionState));
     1:     if (state) {
     1:         state->throwing = JS_GetPendingException(cx, &state->exception);
     1:         if (state->throwing && JSVAL_IS_GCTHING(state->exception))
 78614:             js_AddRoot(cx, &state->exception, "JSExceptionState.exception");
     1:     }
     1:     return state;
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_RestoreExceptionState(JSContext *cx, JSExceptionState *state)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
     1:     if (state) {
     1:         if (state->throwing)
     1:             JS_SetPendingException(cx, state->exception);
     1:         else
     1:             JS_ClearPendingException(cx);
     1:         JS_DropExceptionState(cx, state);
     1:     }
     1: }
     1: 
     1: JS_PUBLIC_API(void)
     1: JS_DropExceptionState(JSContext *cx, JSExceptionState *state)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
     1:     if (state) {
 47485:         if (state->throwing && JSVAL_IS_GCTHING(state->exception)) {
 47485:             assertSameCompartment(cx, state->exception);
 47403:             JS_RemoveValueRoot(cx, &state->exception);
 47485:         }
 64560:         cx->free_(state);
     1:     }
     1: }
     1: 
     1: JS_PUBLIC_API(JSErrorReport *)
     1: JS_ErrorFromException(JSContext *cx, jsval v)
     1: {
103783:     AssertHeapIsIdle(cx);
     1:     CHECK_REQUEST(cx);
 47485:     assertSameCompartment(cx, v);
     1:     return js_ErrorFromException(cx, v);
     1: }
     1: 
     1: JS_PUBLIC_API(JSBool)
     1: JS_ThrowReportedError(JSContext *cx, const char *message,
     1:                       JSErrorReport *reportp)
     1: {
103783:     AssertHeapIsIdle(cx);
 36234:     return JS_IsRunning(cx) &&
 36234:            js_ErrorToException(cx, message, reportp, NULL, NULL);
     1: }
     1: 
  6464: JS_PUBLIC_API(JSBool)
  6464: JS_ThrowStopIteration(JSContext *cx)
  6464: {
103783:     AssertHeapIsIdle(cx);
  6464:     return js_ThrowStopIteration(cx);
  6464: }
  6464: 
 86984: JS_PUBLIC_API(intptr_t)
 86984: JS_GetCurrentThread()
 86984: {
 11941: #ifdef JS_THREADSAFE
 88135:     return reinterpret_cast<intptr_t>(PR_GetCurrentThread());
 11941: #else
 11941:     return 0;
 11941: #endif
     1: }
     1: 
 81562: extern JS_PUBLIC_API(void)
 81562: JS_ClearRuntimeThread(JSRuntime *rt)
 81562: {
103783:     AssertHeapIsIdle(rt);
 81562: #ifdef JS_THREADSAFE
 81562:     rt->clearOwnerThread();
 81562: #endif
 81562: }
 81562: 
 81562: extern JS_PUBLIC_API(void)
 81562: JS_SetRuntimeThread(JSRuntime *rt)
 81562: {
103783:     AssertHeapIsIdle(rt);
 81562: #ifdef JS_THREADSAFE
 81562:     rt->setOwnerThread();
 81562: #endif
 81562: }
 81562: 
 81562: extern JS_NEVER_INLINE JS_PUBLIC_API(void)
 81562: JS_AbortIfWrongThread(JSRuntime *rt)
 81562: {
 81562: #ifdef JS_THREADSAFE
 81562:     if (!rt->onOwnerThread())
102242:         MOZ_CRASH();
 81562: #endif
 81562: }
 81562: 
  1492: #ifdef JS_GC_ZEAL
  1492: JS_PUBLIC_API(void)
 94870: JS_SetGCZeal(JSContext *cx, uint8_t zeal, uint32_t frequency)
 71353: {
 90410:     const char *env = getenv("JS_GC_ZEAL");
 90410:     if (env) {
 98072:         if (0 == strcmp(env, "help")) {
 98072:             printf("Format: JS_GC_ZEAL=N[,F]\n"
 98072:                    "N indicates \"zealousness\":\n"
 98072:                    "  0: no additional GCs\n"
 98072:                    "  1: additional GCs at common danger points\n"
 98072:                    "  2: GC every F allocations (default: 100)\n"
 98072:                    "  3: GC when the window paints (browser only)\n"
 98072:                    "  4: Verify write barriers between instructions\n"
102161:                    "  5: Verify write barriers between paints\n"
102161:                    "  6: Verify stack rooting (ignoring XML and Reflect)\n"
102693:                    "  7: Verify stack rooting (all roots)\n"
102693:                    "  8: Incremental GC in two slices: 1) mark roots 2) finish collection\n"
102693:                    "  9: Incremental GC in two slices: 1) mark all 2) new marking and finish\n"
102693:                    " 10: Incremental GC in multiple slices\n");
 98072:         }
 98072:         const char *p = strchr(env, ',');
 90410:         zeal = atoi(env);
 98072:         frequency = p ? atoi(p + 1) : JS_DEFAULT_ZEAL_FREQ;
 98072:     }
 90410: 
102261:     if (zeal == 0 && cx->runtime->gcVerifyData)
102261:         VerifyBarriers(cx->runtime);
102261: 
 90410:     bool schedule = zeal >= js::gc::ZealAllocValue;
 71353:     cx->runtime->gcZeal_ = zeal;
 71353:     cx->runtime->gcZealFrequency = frequency;
 82130:     cx->runtime->gcNextScheduled = schedule ? frequency : 0;
 71353: }
 71353: 
 71353: JS_PUBLIC_API(void)
 94870: JS_ScheduleGC(JSContext *cx, uint32_t count)
 71353: {
 71353:     cx->runtime->gcNextScheduled = count;
  1492: }
  1492: #endif
  1492: 
     1: /************************************************************************/
     1: 
 67939: #if !defined(STATIC_EXPORTABLE_JS_API) && !defined(STATIC_JS_API) && defined(XP_WIN)
 11461: 
 52897: #include "jswin.h"
 11461: 
     1: /*
 11461:  * Initialization routine for the JS DLL.
     1:  */
     1: BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
     1: {
     1:     return TRUE;
     1: }
     1: 
 11461: #endif
 81418: 
 81418: JS_PUBLIC_API(JSBool)
 84755: JS_IndexToId(JSContext *cx, uint32_t index, jsid *id)
 81418: {
 81418:     return IndexToId(cx, index, id);
 81418: }
 81457: 
 82522: JS_PUBLIC_API(JSBool)
 82522: JS_IsIdentifier(JSContext *cx, JSString *str, JSBool *isIdentifier)
 82522: {
 82522:     assertSameCompartment(cx, str);
 82522: 
 82522:     JSLinearString* linearStr = str->ensureLinear(cx);
 82522:     if (!linearStr)
 82522:         return false;
 82522: 
104046:     *isIdentifier = js::IsIdentifier(linearStr);
 82522:     return true;
 82522: }
 82522: 
 92133: JS_PUBLIC_API(JSBool)
 92133: JS_DescribeScriptedCaller(JSContext *cx, JSScript **script, unsigned *lineno)
 92133: {
 92133:     if (script)
 92133:         *script = NULL;
 92133:     if (lineno)
 92133:         *lineno = 0;
 92133: 
 97161:     ScriptFrameIter i(cx);
 92133:     if (i.done())
 92133:         return JS_FALSE;
 92133: 
 92133:     if (script)
 92133:         *script = i.script();
 92133:     if (lineno)
 92133:         *lineno = js::PCToLineNumber(i.script(), i.pc());
 92133:     return JS_TRUE;
 92133: }
 92133: 
 81457: #ifdef JS_THREADSAFE
 81457: static PRStatus
 81457: CallOnce(void *func)
 81457: {
 81457:     JSInitCallback init = JS_DATA_TO_FUNC_PTR(JSInitCallback, func);
 81457:     return init() ? PR_SUCCESS : PR_FAILURE;
 81457: }
 81457: #endif
 81457: 
 81457: JS_PUBLIC_API(JSBool)
 81457: JS_CallOnce(JSCallOnceType *once, JSInitCallback func)
 81457: {
 81457: #ifdef JS_THREADSAFE
 81457:     return PR_CallOnceWithArg(once, CallOnce, JS_FUNC_TO_DATA_PTR(void *, func)) == PR_SUCCESS;
 81457: #else
 81457:     if (!*once) {
 81457:         *once = true;
 81457:         return func();
 81457:     } else {
 81457:         return JS_TRUE;
 81457:     }
 81457: #endif
 81457: }
 86988: 
 86988: namespace JS {
 86988: 
 86988: AutoGCRooter::AutoGCRooter(JSContext *cx, ptrdiff_t tag)
 91250:   : down(cx->runtime->autoGCRooters), tag(tag), stackTop(&cx->runtime->autoGCRooters)
 91250: {
 91250:     JS_ASSERT(this != *stackTop);
 91250:     *stackTop = this;
 86988: }
 86988: 
 86995: AutoEnumStateRooter::~AutoEnumStateRooter()
 86995: {
 91250:     if (!stateValue.isNull())
 91250:         MOZ_ALWAYS_TRUE(obj->enumerate(context, JSENUMERATE_DESTROY, &stateValue, 0));
 86995: }
 86995: 
 94326: #ifdef DEBUG
 94326: JS_PUBLIC_API(void)
 94326: AssertArgumentsAreSane(JSContext *cx, const JS::Value &v)
 94326: {
103783:     AssertHeapIsIdle(cx);
 94326:     CHECK_REQUEST(cx);
 94326:     assertSameCompartment(cx, v);
 94326: }
 94326: #endif /* DEBUG */
 94326: 
 86988: } // namespace JS
 94006: 
 94006: JS_PUBLIC_API(void *)
 94006: JS_EncodeScript(JSContext *cx, JSScript *script, uint32_t *lengthp)
 94006: {
 94006:     XDREncoder encoder(cx);
 94006:     if (!encoder.codeScript(&script))
 94006:         return NULL;
 94006:     return encoder.forgetData(lengthp);
 94006: }
 94006: 
 94006: JS_PUBLIC_API(void *)
 94006: JS_EncodeInterpretedFunction(JSContext *cx, JSObject *funobj, uint32_t *lengthp)
 94006: {
 94006:     XDREncoder encoder(cx);
 94006:     if (!encoder.codeFunction(&funobj))
 94006:         return NULL;
 94006:     return encoder.forgetData(lengthp);
 94006: }
 94006: 
 94006: JS_PUBLIC_API(JSScript *)
 94006: JS_DecodeScript(JSContext *cx, const void *data, uint32_t length,
 94006:                 JSPrincipals *principals, JSPrincipals *originPrincipals)
 94006: {
 94006:     XDRDecoder decoder(cx, data, length, principals, originPrincipals);
 94006:     JSScript *script;
 94006:     if (!decoder.codeScript(&script))
 94006:         return NULL;
 94006:     return script;
 94006: }
 94006: 
 94006: JS_PUBLIC_API(JSObject *)
 94006: JS_DecodeInterpretedFunction(JSContext *cx, const void *data, uint32_t length,
 94006:                              JSPrincipals *principals, JSPrincipals *originPrincipals)
 94006: {
 94006:     XDRDecoder decoder(cx, data, length, principals, originPrincipals);
 94006:     JSObject *funobj;
 94006:     if (!decoder.codeFunction(&funobj))
 94006:         return NULL;
 94006:     return funobj;
 94006: }
 95519: 
 95519: JS_PUBLIC_API(JSObject *)
 95519: JS_GetScriptedGlobal(JSContext *cx)
 95519: {
 97161:     ScriptFrameIter i(cx);
 95519:     if (i.done())
 95519:         return JS_GetGlobalForScopeChain(cx);
 95519: 
 95519:     return JS_GetGlobalForFrame(Jsvalify(i.fp()));
 95519: }
 95519: 
