    1: /* vim:set ts=4 sw=4 sts=4 et cindent: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the SSPI NegotiateAuth Module
    1:  *
    1:  * The Initial Developer of the Original Code is IBM Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2004
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Darin Fisher <darin@meer.net>
35150:  *   Jim Mathies <jmathies@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: //
    1: // Negotiate Authentication Support Module
    1: //
    1: // Described by IETF Internet draft: draft-brezak-kerberos-http-00.txt
    1: // (formerly draft-brezak-spnego-http-04.txt)
    1: //
    1: // Also described here:
    1: // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnsecure/html/http-sso-1.asp
    1: //
    1: 
    1: #include "nsAuthSSPI.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIDNSService.h"
    1: #include "nsIDNSRecord.h"
    1: #include "nsNetCID.h"
    1: #include "nsCOMPtr.h"
    1: 
18479: #include <windows.h>
18479: 
    1: #define SEC_SUCCESS(Status) ((Status) >= 0)
    1: 
    1: #ifndef KERB_WRAP_NO_ENCRYPT
    1: #define KERB_WRAP_NO_ENCRYPT 0x80000001
    1: #endif
    1: 
    1: #ifndef SECBUFFER_PADDING
    1: #define SECBUFFER_PADDING 9
    1: #endif
    1: 
    1: #ifndef SECBUFFER_STREAM
    1: #define SECBUFFER_STREAM 10
    1: #endif
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
18860: static const PRUnichar *const pTypeName [] = {
18860:     L"Kerberos",
18860:     L"Negotiate",
18860:     L"NTLM"
    1: };
    1: 
    1: #ifdef DEBUG
    1: #define CASE_(_x) case _x: return # _x;
    1: static const char *MapErrorCode(int rc)
    1: {
    1:     switch (rc) {
    1:     CASE_(SEC_E_OK)
    1:     CASE_(SEC_I_CONTINUE_NEEDED)
    1:     CASE_(SEC_I_COMPLETE_NEEDED)
    1:     CASE_(SEC_I_COMPLETE_AND_CONTINUE)
    1:     CASE_(SEC_E_INCOMPLETE_MESSAGE)
    1:     CASE_(SEC_I_INCOMPLETE_CREDENTIALS)
    1:     CASE_(SEC_E_INVALID_HANDLE)
    1:     CASE_(SEC_E_TARGET_UNKNOWN)
    1:     CASE_(SEC_E_LOGON_DENIED)
    1:     CASE_(SEC_E_INTERNAL_ERROR)
    1:     CASE_(SEC_E_NO_CREDENTIALS)
    1:     CASE_(SEC_E_NO_AUTHENTICATING_AUTHORITY)
    1:     CASE_(SEC_E_INSUFFICIENT_MEMORY)
    1:     CASE_(SEC_E_INVALID_TOKEN)
    1:     }
    1:     return "<unknown>";
    1: }
    1: #else
    1: #define MapErrorCode(_rc) ""
    1: #endif
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: static HINSTANCE                 sspi_lib; 
18479: static PSecurityFunctionTableW   sspi;
    1: 
    1: static nsresult
    1: InitSSPI()
    1: {
18479:     PSecurityFunctionTableW (*initFun)(void);
    1: 
    1:     LOG(("  InitSSPI\n"));
    1: 
18479:     sspi_lib = LoadLibraryW(L"secur32.dll");
    1:     if (!sspi_lib) {
18479:         sspi_lib = LoadLibraryW(L"security.dll");
    1:         if (!sspi_lib) {
    1:             LOG(("SSPI library not found"));
    1:             return NS_ERROR_UNEXPECTED;
    1:         }
    1:     }
    1: 
18479:     initFun = (PSecurityFunctionTableW (*)(void))
18479:             GetProcAddress(sspi_lib, "InitSecurityInterfaceW");
    1:     if (!initFun) {
18479:         LOG(("InitSecurityInterfaceW not found"));
    1:         return NS_ERROR_UNEXPECTED;
    1:     }
    1: 
    1:     sspi = initFun();
    1:     if (!sspi) {
18479:         LOG(("InitSecurityInterfaceW failed"));
    1:         return NS_ERROR_UNEXPECTED;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: static nsresult
    1: MakeSN(const char *principal, nsCString &result)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCAutoString buf(principal);
    1: 
    1:     // The service name looks like "protocol@hostname", we need to map
    1:     // this to a value that SSPI expects.  To be consistent with IE, we
    1:     // need to map '@' to '/' and canonicalize the hostname.
    1:     PRInt32 index = buf.FindChar('@');
    1:     if (index == kNotFound)
    1:         return NS_ERROR_UNEXPECTED;
    1:     
    1:     nsCOMPtr<nsIDNSService> dns = do_GetService(NS_DNSSERVICE_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // This could be expensive if our DNS cache cannot satisfy the request.
    1:     // However, we should have at least hit the OS resolver once prior to
    1:     // reaching this code, so provided the OS resolver has this information
    1:     // cached, we should not have to worry about blocking on this function call
    1:     // for very long.  NOTE: because we ask for the canonical hostname, we
    1:     // might end up requiring extra network activity in cases where the OS
    1:     // resolver might not have enough information to satisfy the request from
    1:     // its cache.  This is not an issue in versions of Windows up to WinXP.
    1:     nsCOMPtr<nsIDNSRecord> record;
    1:     rv = dns->Resolve(Substring(buf, index + 1),
    1:                       nsIDNSService::RESOLVE_CANONICAL_NAME,
    1:                       getter_AddRefs(record));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCAutoString cname;
    1:     rv = record->GetCanonicalName(cname);
    1:     if (NS_SUCCEEDED(rv)) {
    1:         result = StringHead(buf, index) + NS_LITERAL_CSTRING("/") + cname;
    1:         LOG(("Using SPN of [%s]\n", result.get()));
    1:     }
    1:     return rv;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsAuthSSPI::nsAuthSSPI(pType package)
    1:     : mServiceFlags(REQ_DEFAULT)
    1:     , mMaxTokenLen(0)
    1:     , mPackage(package)
    1: {
    1:     memset(&mCred, 0, sizeof(mCred));
    1:     memset(&mCtxt, 0, sizeof(mCtxt));
    1: }
    1: 
    1: nsAuthSSPI::~nsAuthSSPI()
    1: {
    1:     Reset();
    1: 
    1:     if (mCred.dwLower || mCred.dwUpper) {
    1: #ifdef __MINGW32__
    1:         (sspi->FreeCredentialsHandle)(&mCred);
    1: #else
    1:         (sspi->FreeCredentialHandle)(&mCred);
    1: #endif
    1:         memset(&mCred, 0, sizeof(mCred));
    1:     }
    1: }
    1: 
    1: void
    1: nsAuthSSPI::Reset()
    1: {
    1:     if (mCtxt.dwLower || mCtxt.dwUpper) {
    1:         (sspi->DeleteSecurityContext)(&mCtxt);
    1:         memset(&mCtxt, 0, sizeof(mCtxt));
    1:     }
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsAuthSSPI, nsIAuthModule)
    1: 
    1: NS_IMETHODIMP
    1: nsAuthSSPI::Init(const char *serviceName,
    1:                  PRUint32    serviceFlags,
    1:                  const PRUnichar *domain,
    1:                  const PRUnichar *username,
    1:                  const PRUnichar *password)
    1: {
    1:     LOG(("  nsAuthSSPI::Init\n"));
    1: 
35150:     // The caller must supply a service name to be used. (For why we now require
35150:     // a service name for NTLM, see bug 487872.)
    1:     NS_ENSURE_TRUE(serviceName && *serviceName, NS_ERROR_INVALID_ARG);
    1: 
    1:     nsresult rv;
    1: 
    1:     // XXX lazy initialization like this assumes that we are single threaded
    1:     if (!sspi) {
    1:         rv = InitSSPI();
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
18479:     SEC_WCHAR *package;
    1: 
18479:     package = (SEC_WCHAR *) pTypeName[(int)mPackage];
    1:     rv = MakeSN(serviceName, mServiceName);
    1:     if (NS_FAILED(rv))
    1:         return rv;
34544: 
    1:     mServiceFlags = serviceFlags;
    1: 
    1:     SECURITY_STATUS rc;
    1: 
18479:     PSecPkgInfoW pinfo;
18479:     rc = (sspi->QuerySecurityPackageInfoW)(package, &pinfo);
    1:     if (rc != SEC_E_OK) {
    1:         LOG(("%s package not found\n", package));
    1:         return NS_ERROR_UNEXPECTED;
    1:     }
    1:     mMaxTokenLen = pinfo->cbMaxToken;
    1:     (sspi->FreeContextBuffer)(pinfo);
    1: 
    1:     TimeStamp useBefore;
    1: 
35150:     SEC_WINNT_AUTH_IDENTITY_W ai;
35150:     SEC_WINNT_AUTH_IDENTITY_W *pai = nsnull;
35150:     
35150:     // domain, username, and password will be null if nsHttpNTLMAuth's ChallengeReceived
35150:     // returns false for identityInvalid. Use default credentials in this case by passing
35150:     // null for pai.
35150:     if (username && password) {
35416:         // Keep a copy of these strings for the duration
35416:         mUsername.Assign(username);
35416:         mPassword.Assign(password);
35416:         mDomain.Assign(domain);
35416:         ai.Domain = reinterpret_cast<unsigned short*>(mDomain.BeginWriting());
35416:         ai.DomainLength = mDomain.Length();
35416:         ai.User = reinterpret_cast<unsigned short*>(mUsername.BeginWriting());
35416:         ai.UserLength = mUsername.Length();
35416:         ai.Password = reinterpret_cast<unsigned short*>(mPassword.BeginWriting());
35416:         ai.PasswordLength = mPassword.Length();
35150:         ai.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
35150:         pai = &ai;
35150:     }
35150: 
18479:     rc = (sspi->AcquireCredentialsHandleW)(NULL,
    1:                                            package,
    1:                                            SECPKG_CRED_OUTBOUND,
    1:                                            NULL,
35150:                                            pai,
    1:                                            NULL,
    1:                                            NULL,
    1:                                            &mCred,
    1:                                            &useBefore);
    1:     if (rc != SEC_E_OK)
    1:         return NS_ERROR_UNEXPECTED;
35150:     LOG(("AcquireCredentialsHandle() succeeded.\n"));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAuthSSPI::GetNextToken(const void *inToken,
    1:                          PRUint32    inTokenLen,
    1:                          void      **outToken,
    1:                          PRUint32   *outTokenLen)
    1: {
    1:     SECURITY_STATUS rc;
    1:     TimeStamp ignored;
    1: 
    1:     DWORD ctxAttr, ctxReq = 0;
    1:     CtxtHandle *ctxIn;
    1:     SecBufferDesc ibd, obd;
    1:     SecBuffer ib, ob;
    1: 
    1:     LOG(("entering nsAuthSSPI::GetNextToken()\n"));
    1: 
    1:     if (mServiceFlags & REQ_DELEGATE)
    1:         ctxReq |= ISC_REQ_DELEGATE;
    1:     if (mServiceFlags & REQ_MUTUAL_AUTH)
    1:         ctxReq |= ISC_REQ_MUTUAL_AUTH;
    1: 
    1:     if (inToken) {
    1:         ib.BufferType = SECBUFFER_TOKEN;
    1:         ib.cbBuffer = inTokenLen;
    1:         ib.pvBuffer = (void *) inToken;
    1:         ibd.ulVersion = SECBUFFER_VERSION;
    1:         ibd.cBuffers = 1;
    1:         ibd.pBuffers = &ib;
    1:         ctxIn = &mCtxt;
    1:     }
    1:     else {
    1:         // If there is no input token, then we are starting a new
    1:         // authentication sequence.  If we have already initialized our
    1:         // security context, then we're in trouble because it means that the
    1:         // first sequence failed.  We need to bail or else we might end up in
    1:         // an infinite loop.
    1:         if (mCtxt.dwLower || mCtxt.dwUpper) {
    1:             LOG(("Cannot restart authentication sequence!"));
    1:             return NS_ERROR_UNEXPECTED;
    1:         }
    1: 
    1:         ctxIn = NULL;
    1:     }
    1: 
    1:     obd.ulVersion = SECBUFFER_VERSION;
    1:     obd.cBuffers = 1;
    1:     obd.pBuffers = &ob;
    1:     ob.BufferType = SECBUFFER_TOKEN;
    1:     ob.cbBuffer = mMaxTokenLen;
    1:     ob.pvBuffer = nsMemory::Alloc(ob.cbBuffer);
    1:     if (!ob.pvBuffer)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     memset(ob.pvBuffer, 0, ob.cbBuffer);
18860: 
18860:     NS_ConvertUTF8toUTF16 wSN(mServiceName);
34544:     SEC_WCHAR *sn = (SEC_WCHAR *) wSN.get();
    1: 
18479:     rc = (sspi->InitializeSecurityContextW)(&mCred,
    1:                                             ctxIn,
    1:                                             sn,
    1:                                             ctxReq,
    1:                                             0,
    1:                                             SECURITY_NATIVE_DREP,
    1:                                             inToken ? &ibd : NULL,
    1:                                             0,
    1:                                             &mCtxt,
    1:                                             &obd,
    1:                                             &ctxAttr,
    1:                                             &ignored);
    1:     if (rc == SEC_I_CONTINUE_NEEDED || rc == SEC_E_OK) {
35150: 
35150: #ifdef PR_LOGGING
35150:         if (rc == SEC_E_OK)
35150:             LOG(("InitializeSecurityContext: succeeded.\n"));
35150:         else
35150:             LOG(("InitializeSecurityContext: continue.\n"));
35150: #endif
35150: 
    1:         if (!ob.cbBuffer) {
    1:             nsMemory::Free(ob.pvBuffer);
    1:             ob.pvBuffer = NULL;
    1:         }
    1:         *outToken = ob.pvBuffer;
    1:         *outTokenLen = ob.cbBuffer;
    1: 
    1:         if (rc == SEC_E_OK)
    1:             return NS_SUCCESS_AUTH_FINISHED;
    1: 
    1:         return NS_OK;
    1:     }
    1: 
    1:     LOG(("InitializeSecurityContext failed [rc=%d:%s]\n", rc, MapErrorCode(rc)));
    1:     Reset();
    1:     nsMemory::Free(ob.pvBuffer);
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAuthSSPI::Unwrap(const void *inToken,
    1:                    PRUint32    inTokenLen,
    1:                    void      **outToken,
    1:                    PRUint32   *outTokenLen)
    1: {
    1:     SECURITY_STATUS rc;
    1:     SecBufferDesc ibd;
    1:     SecBuffer ib[2];
    1: 
    1:     ibd.cBuffers = 2;
    1:     ibd.pBuffers = ib;
    1:     ibd.ulVersion = SECBUFFER_VERSION; 
    1: 
    1:     // SSPI Buf
    1:     ib[0].BufferType = SECBUFFER_STREAM;
    1:     ib[0].cbBuffer = inTokenLen;
    1:     ib[0].pvBuffer = nsMemory::Alloc(ib[0].cbBuffer);
    1:     if (!ib[0].pvBuffer)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     
    1:     memcpy(ib[0].pvBuffer, inToken, inTokenLen);
    1: 
    1:     // app data
    1:     ib[1].BufferType = SECBUFFER_DATA;
    1:     ib[1].cbBuffer = 0;
    1:     ib[1].pvBuffer = NULL;
    1: 
    1:     rc = (sspi->DecryptMessage)(
    1:                                 &mCtxt,
    1:                                 &ibd,
    1:                                 0, // no sequence numbers
    1:                                 NULL
    1:                                 );
    1: 
    1:     if (SEC_SUCCESS(rc)) {
32284:         // check if ib[1].pvBuffer is really just ib[0].pvBuffer, in which
32284:         // case we can let the caller free it. Otherwise, we need to
32284:         // clone it, and free the original
32284:         if (ib[0].pvBuffer == ib[1].pvBuffer) {
    1:             *outToken = ib[1].pvBuffer;
32284:         }
32284:         else {
32284:             *outToken = nsMemory::Clone(ib[1].pvBuffer, ib[1].cbBuffer);
32284:             nsMemory::Free(ib[0].pvBuffer);
32284:             if (!*outToken)
32284:                 return NS_ERROR_OUT_OF_MEMORY;
32284:         }
    1:         *outTokenLen = ib[1].cbBuffer;
    1:     }
    1:     else
    1:         nsMemory::Free(ib[0].pvBuffer);
    1: 
    1:     if (!SEC_SUCCESS(rc))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: // utility class used to free memory on exit
    1: class secBuffers
    1: {
    1: public:
    1: 
    1:     SecBuffer ib[3];
    1: 
    1:     secBuffers() { memset(&ib, 0, sizeof(ib)); }
    1: 
    1:     ~secBuffers() 
    1:     {
    1:         if (ib[0].pvBuffer)
    1:             nsMemory::Free(ib[0].pvBuffer);
    1: 
    1:         if (ib[1].pvBuffer)
    1:             nsMemory::Free(ib[1].pvBuffer);
    1: 
    1:         if (ib[2].pvBuffer)
    1:             nsMemory::Free(ib[2].pvBuffer);
    1:     }
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsAuthSSPI::Wrap(const void *inToken,
    1:                  PRUint32    inTokenLen,
    1:                  PRBool      confidential,
    1:                  void      **outToken,
    1:                  PRUint32   *outTokenLen)
    1: {
    1:     SECURITY_STATUS rc;
    1: 
    1:     SecBufferDesc ibd;
    1:     secBuffers bufs;
    1:     SecPkgContext_Sizes sizes;
    1: 
18479:     rc = (sspi->QueryContextAttributesW)(
    1:          &mCtxt,
    1:          SECPKG_ATTR_SIZES,
    1:          &sizes);
    1: 
    1:     if (!SEC_SUCCESS(rc))  
    1:         return NS_ERROR_FAILURE;
    1:     
    1:     ibd.cBuffers = 3;
    1:     ibd.pBuffers = bufs.ib;
    1:     ibd.ulVersion = SECBUFFER_VERSION;
    1:     
    1:     // SSPI
    1:     bufs.ib[0].cbBuffer = sizes.cbSecurityTrailer;
    1:     bufs.ib[0].BufferType = SECBUFFER_TOKEN;
    1:     bufs.ib[0].pvBuffer = nsMemory::Alloc(sizes.cbSecurityTrailer);
    1: 
    1:     if (!bufs.ib[0].pvBuffer)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // APP Data
    1:     bufs.ib[1].BufferType = SECBUFFER_DATA;
    1:     bufs.ib[1].pvBuffer = nsMemory::Alloc(inTokenLen);
    1:     bufs.ib[1].cbBuffer = inTokenLen;
    1:     
    1:     if (!bufs.ib[1].pvBuffer)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     memcpy(bufs.ib[1].pvBuffer, inToken, inTokenLen);
    1: 
    1:     // SSPI
    1:     bufs.ib[2].BufferType = SECBUFFER_PADDING;
    1:     bufs.ib[2].cbBuffer = sizes.cbBlockSize;
    1:     bufs.ib[2].pvBuffer = nsMemory::Alloc(bufs.ib[2].cbBuffer);
    1: 
    1:     if (!bufs.ib[2].pvBuffer)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     rc = (sspi->EncryptMessage)(&mCtxt,
    1:           confidential ? 0 : KERB_WRAP_NO_ENCRYPT,
    1:          &ibd, 0);
    1: 
    1:     if (SEC_SUCCESS(rc)) {
    1:         int len  = bufs.ib[0].cbBuffer + bufs.ib[1].cbBuffer + bufs.ib[2].cbBuffer;
    1:         char *p = (char *) nsMemory::Alloc(len);
    1: 
    1:         if (!p)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 				
    1:         *outToken = (void *) p;
    1:         *outTokenLen = len;
    1: 
    1:         memcpy(p, bufs.ib[0].pvBuffer, bufs.ib[0].cbBuffer);
    1:         p += bufs.ib[0].cbBuffer;
    1: 
    1:         memcpy(p,bufs.ib[1].pvBuffer, bufs.ib[1].cbBuffer);
    1:         p += bufs.ib[1].cbBuffer;
    1: 
    1:         memcpy(p,bufs.ib[2].pvBuffer, bufs.ib[2].cbBuffer);
    1:         
    1:         return NS_OK;
    1:     }
    1: 
    1:     return NS_ERROR_FAILURE;
    1: }
