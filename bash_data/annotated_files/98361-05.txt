58638: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
58638: /* ***** BEGIN LICENSE BLOCK *****
43628:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43628:  *
43628:  * The contents of this file are subject to the Mozilla Public License Version
43628:  * 1.1 (the "License"); you may not use this file except in compliance with
43628:  * the License. You may obtain a copy of the License at
43628:  * http://www.mozilla.org/MPL/
43628:  *
43628:  * Software distributed under the License is distributed on an "AS IS" basis,
43628:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43628:  * for the specific language governing rights and limitations under the
43628:  * License.
43628:  *
43628:  * The Initial Developer of the Original Code is Mozilla Foundation.
43628:  * Portions created by the Initial Developer are Copyright (C) 2010
43628:  * the Initial Developer. All Rights Reserved.
43628:  *
43628:  * Contributor(s):
43628:  *   Matt Woodrow <mwoodrow@mozilla.com>
43628:  *   Bas Schouten <bschouten@mozilla.com>
43628:  *
43628:  * Alternatively, the contents of this file may be used under the terms of
43628:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43628:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43628:  * in which case the provisions of the GPL or the LGPL are applicable instead
43628:  * of those above. If you wish to allow use of your version of this file only
43628:  * under the terms of either the GPL or the LGPL, and not to allow others to
43628:  * use your version of this file under the terms of the MPL, indicate your
43628:  * decision by deleting the provisions above and replace them with the notice
43628:  * and other provisions required by the GPL or the LGPL. If you do not delete
43628:  * the provisions above, a recipient may use your version of this file under
43628:  * the terms of any one of the MPL, the GPL or the LGPL.
43628:  *
43628:  * ***** END LICENSE BLOCK ***** */
43628: 
43628: #ifdef MOZ_WIDGET_GTK2
43628: #include <gdk/gdk.h>
43628: #include <gdk/gdkx.h>
43628: #define GET_NATIVE_WINDOW(aWidget) GDK_WINDOW_XID((GdkWindow *) aWidget->GetNativeData(NS_NATIVE_WINDOW))
43628: #elif defined(MOZ_WIDGET_QT)
43628: #include <QWidget>
94111: #define GET_NATIVE_WINDOW(aWidget) static_cast<QWidget*>(aWidget->GetNativeData(NS_NATIVE_SHELLWIDGET))->winId()
43628: #endif
43628: 
43628: #include <X11/Xlib.h>
43628: #include <X11/Xutil.h>
43628: 
46140: #include "mozilla/X11Util.h"
46140: 
60261: #include "prenv.h"
43628: #include "GLContextProvider.h"
93376: #include "GLLibraryLoader.h"
43628: #include "nsDebug.h"
43628: #include "nsIWidget.h"
43628: #include "GLXLibrary.h"
47908: #include "gfxXlibSurface.h"
46979: #include "gfxContext.h"
46979: #include "gfxImageSurface.h"
95378: #include "gfxPlatform.h"
57246: #include "GLContext.h"
67636: #include "gfxUtils.h"
43628: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
97344: #ifdef MOZ_WIDGET_GTK2
97344: #include "gfxPlatformGtk.h"
97344: #endif
97344: 
43628: namespace mozilla {
43628: namespace gl {
43628: 
79445: static bool gIsATI = false;
79445: static bool gIsChromium = false;
57247: static int gGLXMajorVersion = 0, gGLXMinorVersion = 0;
57247: 
57247: // Check that we have at least version aMajor.aMinor .
57247: static inline bool
57247: GLXVersionCheck(int aMajor, int aMinor)
57247: {
57247:     return aMajor < gGLXMajorVersion ||
57247:            (aMajor == gGLXMajorVersion && aMinor <= gGLXMinorVersion);
57247: }
47908: 
57246: static inline bool
57246: HasExtension(const char* aExtensions, const char* aRequiredExtension)
57246: {
57246:     return GLContext::ListHasExtension(
57246:         reinterpret_cast<const GLubyte*>(aExtensions), aRequiredExtension);
57246: }
57246: 
79445: bool
43628: GLXLibrary::EnsureInitialized()
43628: {
43628:     if (mInitialized) {
80486:         return true;
43628:     }
43628: 
57245:     // Don't repeatedly try to initialize.
57245:     if (mTriedInitializing) {
80486:         return false;
57245:     }
80486:     mTriedInitializing = true;
57245: 
43628:     if (!mOGLLibrary) {
63285:         // see e.g. bug 608526: it is intrinsically interesting to know whether we have dynamically linked to libGL.so.1
63285:         // because at least the NVIDIA implementation requires an executable stack, which causes mprotect calls,
63285:         // which trigger glibc bug http://sourceware.org/bugzilla/show_bug.cgi?id=12225
80840: #ifdef __OpenBSD__
80840:         const char *libGLfilename = "libGL.so";
80840: #else
63285:         const char *libGLfilename = "libGL.so.1";
80840: #endif
63285:         ScopedGfxFeatureReporter reporter(libGLfilename);
63285:         mOGLLibrary = PR_LoadLibrary(libGLfilename);
43628:         if (!mOGLLibrary) {
43628:             NS_WARNING("Couldn't load OpenGL shared library.");
80486:             return false;
43628:         }
63285:         reporter.SetSuccessful();
43628:     }
43628: 
77099:     if (PR_GetEnv("MOZ_GLX_DEBUG")) {
80486:         mDebug = true;
77099:     }
77099: 
93376:     GLLibraryLoader::SymLoadStruct symbols[] = {
57246:         /* functions that were in GLX 1.0 */
77099:         { (PRFuncPtr*) &xDestroyContextInternal, { "glXDestroyContext", NULL } },
77099:         { (PRFuncPtr*) &xMakeCurrentInternal, { "glXMakeCurrent", NULL } },
77099:         { (PRFuncPtr*) &xSwapBuffersInternal, { "glXSwapBuffers", NULL } },
77099:         { (PRFuncPtr*) &xQueryVersionInternal, { "glXQueryVersion", NULL } },
77099:         { (PRFuncPtr*) &xGetCurrentContextInternal, { "glXGetCurrentContext", NULL } },
77099:         { (PRFuncPtr*) &xWaitGLInternal, { "glXWaitGL", NULL } },
77100:         { (PRFuncPtr*) &xWaitXInternal, { "glXWaitX", NULL } },
57246:         /* functions introduced in GLX 1.1 */
77099:         { (PRFuncPtr*) &xQueryExtensionsStringInternal, { "glXQueryExtensionsString", NULL } },
77099:         { (PRFuncPtr*) &xGetClientStringInternal, { "glXGetClientString", NULL } },
77099:         { (PRFuncPtr*) &xQueryServerStringInternal, { "glXQueryServerString", NULL } },
57246:         { NULL, { NULL } }
57246:     };
57246: 
93376:     GLLibraryLoader::SymLoadStruct symbols13[] = {
57246:         /* functions introduced in GLX 1.3 */
77099:         { (PRFuncPtr*) &xChooseFBConfigInternal, { "glXChooseFBConfig", NULL } },
77099:         { (PRFuncPtr*) &xGetFBConfigAttribInternal, { "glXGetFBConfigAttrib", NULL } },
57246:         // WARNING: xGetFBConfigs not set in symbols13_ext
77099:         { (PRFuncPtr*) &xGetFBConfigsInternal, { "glXGetFBConfigs", NULL } },
77099:         { (PRFuncPtr*) &xGetVisualFromFBConfigInternal, { "glXGetVisualFromFBConfig", NULL } },
57246:         // WARNING: symbols13_ext sets xCreateGLXPixmapWithConfig instead
77099:         { (PRFuncPtr*) &xCreatePixmapInternal, { "glXCreatePixmap", NULL } },
77099:         { (PRFuncPtr*) &xDestroyPixmapInternal, { "glXDestroyPixmap", NULL } },
77099:         { (PRFuncPtr*) &xCreateNewContextInternal, { "glXCreateNewContext", NULL } },
57246:         { NULL, { NULL } }
57246:     };
57246: 
93376:     GLLibraryLoader::SymLoadStruct symbols13_ext[] = {
57246:         /* extension equivalents for functions introduced in GLX 1.3 */
57246:         // GLX_SGIX_fbconfig extension
77099:         { (PRFuncPtr*) &xChooseFBConfigInternal, { "glXChooseFBConfigSGIX", NULL } },
77099:         { (PRFuncPtr*) &xGetFBConfigAttribInternal, { "glXGetFBConfigAttribSGIX", NULL } },
57246:         // WARNING: no xGetFBConfigs equivalent in extensions
77099:         { (PRFuncPtr*) &xGetVisualFromFBConfigInternal, { "glXGetVisualFromFBConfig", NULL } },
57246:         // WARNING: different from symbols13:
77099:         { (PRFuncPtr*) &xCreateGLXPixmapWithConfigInternal, { "glXCreateGLXPixmapWithConfigSGIX", NULL } },
77099:         { (PRFuncPtr*) &xDestroyPixmapInternal, { "glXDestroyGLXPixmap", NULL } }, // not from ext
77099:         { (PRFuncPtr*) &xCreateNewContextInternal, { "glXCreateContextWithConfigSGIX", NULL } },
57246:         { NULL, { NULL } }
57246:     };
57246: 
93376:     GLLibraryLoader::SymLoadStruct symbols14[] = {
57246:         /* functions introduced in GLX 1.4 */
77099:         { (PRFuncPtr*) &xGetProcAddressInternal, { "glXGetProcAddress", NULL } },
57246:         { NULL, { NULL } }
57246:     };
57246: 
93376:     GLLibraryLoader::SymLoadStruct symbols14_ext[] = {
57246:         /* extension equivalents for functions introduced in GLX 1.4 */
57246:         // GLX_ARB_get_proc_address extension
77099:         { (PRFuncPtr*) &xGetProcAddressInternal, { "glXGetProcAddressARB", NULL } },
43628:         { NULL, { NULL } }
43628:     };
43628: 
93376:     GLLibraryLoader::SymLoadStruct symbols_texturefrompixmap[] = {
77099:         { (PRFuncPtr*) &xBindTexImageInternal, { "glXBindTexImageEXT", NULL } },
77099:         { (PRFuncPtr*) &xReleaseTexImageInternal, { "glXReleaseTexImageEXT", NULL } },
67633:         { NULL, { NULL } }
67633:     };
67633: 
93376:     GLLibraryLoader::SymLoadStruct symbols_robustness[] = {
80903:         { (PRFuncPtr*) &xCreateContextAttribsInternal, { "glXCreateContextAttribsARB", NULL } },
80903:         { NULL, { NULL } }
80903:     };
80903: 
93376:     if (!GLLibraryLoader::LoadSymbols(mOGLLibrary, &symbols[0])) {
43628:         NS_WARNING("Couldn't find required entry point in OpenGL shared library");
80486:         return false;
43628:     }
43628: 
57246:     Display *display = DefaultXDisplay();
63995: 
57246:     int screen = DefaultScreen(display);
67644:     const char *serverVendor = NULL;
67644:     const char *serverVersionStr = NULL;
67644:     const char *extensionsStr = NULL;
62486: 
57247:     if (!xQueryVersion(display, &gGLXMajorVersion, &gGLXMinorVersion)) {
57247:         gGLXMajorVersion = 0;
57247:         gGLXMinorVersion = 0;
80486:         return false;
57247:     }
57247: 
63995:     serverVendor = xQueryServerString(display, screen, GLX_VENDOR);
62486:     serverVersionStr = xQueryServerString(display, screen, GLX_VERSION);
62486: 
57247:     if (!GLXVersionCheck(1, 1))
57246:         // Not possible to query for extensions.
80486:         return false;
47908: 
70246:     extensionsStr = xQueryExtensionsString(display, screen);
70246: 
93376:     GLLibraryLoader::SymLoadStruct *sym13;
57247:     if (!GLXVersionCheck(1, 3)) {
57246:         // Even if we don't have 1.3, we might have equivalent extensions
57246:         // (as on the Intel X server).
57246:         if (!HasExtension(extensionsStr, "GLX_SGIX_fbconfig")) {
80486:             return false;
57246:         }
57246:         sym13 = symbols13_ext;
57246:     } else {
57246:         sym13 = symbols13;
57246:     }
93376:     if (!GLLibraryLoader::LoadSymbols(mOGLLibrary, sym13)) {
57246:         NS_WARNING("Couldn't find required entry point in OpenGL shared library");
80486:         return false;
57246:     }
57246: 
93376:     GLLibraryLoader::SymLoadStruct *sym14;
57247:     if (!GLXVersionCheck(1, 4)) {
57246:         // Even if we don't have 1.4, we might have equivalent extensions
57246:         // (as on the Intel X server).
57246:         if (!HasExtension(extensionsStr, "GLX_ARB_get_proc_address")) {
80486:             return false;
57246:         }
57246:         sym14 = symbols14_ext;
57246:     } else {
57246:         sym14 = symbols14;
57246:     }
93376:     if (!GLLibraryLoader::LoadSymbols(mOGLLibrary, sym14)) {
57246:         NS_WARNING("Couldn't find required entry point in OpenGL shared library");
80486:         return false;
57246:     }
57246: 
67633:     if (HasExtension(extensionsStr, "GLX_EXT_texture_from_pixmap") &&
93376:         GLLibraryLoader::LoadSymbols(mOGLLibrary, symbols_texturefrompixmap, 
93376:                                          (GLLibraryLoader::PlatformLookupFunction)&xGetProcAddress))
67633:     {
97344: #ifdef MOZ_WIDGET_GTK2
97344:         mUseTextureFromPixmap = gfxPlatformGtk::UseXRender();
97344: #else
97344:         mUseTextureFromPixmap = true;
97344: #endif
73892:     } else {
97344:         mUseTextureFromPixmap = false;
73892:         NS_WARNING("Texture from pixmap disabled");
67633:     }
67633: 
82479:     if (HasExtension(extensionsStr, "GLX_ARB_create_context_robustness") &&
93376:         GLLibraryLoader::LoadSymbols(mOGLLibrary, symbols_robustness)) {
80903:         mHasRobustness = true;
80903:     }
80903: 
89416:     gIsATI = serverVendor && DoesStringMatch(serverVendor, "ATI");
63995:     gIsChromium = (serverVendor &&
89416:                    DoesStringMatch(serverVendor, "Chromium")) ||
63995:         (serverVersionStr &&
89416:          DoesStringMatch(serverVersionStr, "Chromium"));
47908: 
80486:     mInitialized = true;
80486:     return true;
43628: }
43628: 
79445: bool
73893: GLXLibrary::SupportsTextureFromPixmap(gfxASurface* aSurface)
73893: {
73893:     if (!EnsureInitialized()) {
80486:         return false;
73893:     }
73893:     
97344:     if (aSurface->GetType() != gfxASurface::SurfaceTypeXlib || !mUseTextureFromPixmap) {
80486:         return false;
73893:     }
73893: 
80486:     return true;
73893: }
73893: 
67633: GLXPixmap 
67633: GLXLibrary::CreatePixmap(gfxASurface* aSurface)
67633: {
73893:     if (!SupportsTextureFromPixmap(aSurface)) {
67633:         return 0;
67633:     }
67633: 
67633:     int attribs[] = { GLX_DOUBLEBUFFER, False,
67633:                       GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
67633:                       GLX_BIND_TO_TEXTURE_RGBA_EXT, True,
67633:                       None };
67633: 
67633:     int numFormats;
67633:     Display *display = DefaultXDisplay();
67633:     int xscreen = DefaultScreen(display);
67633: 
67633:     ScopedXFree<GLXFBConfig> cfg(xChooseFBConfig(display,
67633:                                                  xscreen,
67633:                                                  attribs,
67633:                                                  &numFormats));
67633:     if (!cfg) {
67633:         return 0;
67633:     }
67633:     NS_ABORT_IF_FALSE(numFormats > 0,
67633:                  "glXChooseFBConfig() failed to match our requested format and violated its spec (!)");
67633: 
67633:     gfxXlibSurface *xs = static_cast<gfxXlibSurface*>(aSurface);
67633: 
67633:     int pixmapAttribs[] = { GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
67633:                             GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGBA_EXT,
67633:                             None};
67633: 
67633:     GLXPixmap glxpixmap = xCreatePixmap(display,
67633:                                         cfg[0],
67633:                                         xs->XDrawable(),
67633:                                         pixmapAttribs);
67633: 
67633:     return glxpixmap;
67633: }
67633: 
67633: void
67633: GLXLibrary::DestroyPixmap(GLXPixmap aPixmap)
67633: {
97344:     if (!mUseTextureFromPixmap) {
67633:         return;
67633:     }
67633: 
67633:     Display *display = DefaultXDisplay();
67633:     xDestroyPixmap(display, aPixmap);
67633: }
67633: 
67633: void
67633: GLXLibrary::BindTexImage(GLXPixmap aPixmap)
67633: {    
97344:     if (!mUseTextureFromPixmap) {
67633:         return;
67633:     }
67633: 
67633:     Display *display = DefaultXDisplay();
67633:     // Make sure all X drawing to the surface has finished before binding to a texture.
77100:     xWaitX();
67633:     xBindTexImage(display, aPixmap, GLX_FRONT_LEFT_EXT, NULL);
67633: }
67633: 
67633: void
67633: GLXLibrary::ReleaseTexImage(GLXPixmap aPixmap)
67633: {
97344:     if (!mUseTextureFromPixmap) {
67633:         return;
67633:     }
67633: 
67633:     Display *display = DefaultXDisplay();
67633:     xReleaseTexImage(display, aPixmap, GLX_FRONT_LEFT_EXT);
67633: }
67633: 
77099: #ifdef DEBUG
77099: 
77099: static int (*sOldErrorHandler)(Display *, XErrorEvent *);
77099: ScopedXErrorHandler::ErrorEvent sErrorEvent;
77099: static int GLXErrorHandler(Display *display, XErrorEvent *ev)
77099: {
77099:     if (!sErrorEvent.mError.error_code) {
77099:         sErrorEvent.mError = *ev;
77099:     }
77099:     return 0;
77099: }
77099: 
77099: void
77099: GLXLibrary::BeforeGLXCall()
77099: {
77099:     if (mDebug) {
77099:         sOldErrorHandler = XSetErrorHandler(GLXErrorHandler);
77099:     }
77099: }
77099: 
77099: void
77099: GLXLibrary::AfterGLXCall()
77099: {
77099:     if (mDebug) {
77099:         XSync(DefaultXDisplay(), False);
77099:         if (sErrorEvent.mError.error_code) {
77099:             char buffer[2048];
77099:             XGetErrorText(DefaultXDisplay(), sErrorEvent.mError.error_code, buffer, sizeof(buffer));
77099:             printf_stderr("X ERROR: %s (%i) - Request: %i.%i, Serial: %i",
77099:                           buffer,
77099:                           sErrorEvent.mError.error_code,
77099:                           sErrorEvent.mError.request_code,
77099:                           sErrorEvent.mError.minor_code,
77099:                           sErrorEvent.mError.serial);
77099:             NS_ABORT();
77099:         }
77099:         XSetErrorHandler(sOldErrorHandler);
77099:     }
77099: }
77099: 
77099: #define BEFORE_GLX_CALL do {                     \
77099:     sGLXLibrary.BeforeGLXCall();                 \
77099: } while (0)
77099:     
77099: #define AFTER_GLX_CALL do {                      \
77099:     sGLXLibrary.AfterGLXCall();                  \
77099: } while (0)
77099: 
77099: #else
77099: 
77099: #define BEFORE_GLX_CALL do { } while(0)
77099: #define AFTER_GLX_CALL do { } while(0)
77099: 
77099: #endif
77099:     
77099: void 
77099: GLXLibrary::xDestroyContext(Display* display, GLXContext context)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     xDestroyContextInternal(display, context);
77099:     AFTER_GLX_CALL;
77099: }
77099: 
77099: Bool 
77099: GLXLibrary::xMakeCurrent(Display* display, 
77099:                          GLXDrawable drawable, 
77099:                          GLXContext context)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     Bool result = xMakeCurrentInternal(display, drawable, context);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: GLXContext 
77099: GLXLibrary::xGetCurrentContext()
77099: {
77099:     BEFORE_GLX_CALL;
77099:     GLXContext result = xGetCurrentContextInternal();
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: /* static */ void* 
77099: GLXLibrary::xGetProcAddress(const char *procName)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     void* result = sGLXLibrary.xGetProcAddressInternal(procName);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: GLXFBConfig*
77099: GLXLibrary::xChooseFBConfig(Display* display, 
77099:                             int screen, 
77099:                             const int *attrib_list, 
77099:                             int *nelements)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     GLXFBConfig* result = xChooseFBConfigInternal(display, screen, attrib_list, nelements);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: GLXFBConfig* 
77099: GLXLibrary::xGetFBConfigs(Display* display, 
77099:                           int screen, 
77099:                           int *nelements)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     GLXFBConfig* result = xGetFBConfigsInternal(display, screen, nelements);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099:     
77099: GLXContext
77099: GLXLibrary::xCreateNewContext(Display* display, 
77099:                               GLXFBConfig config, 
77099:                               int render_type, 
77099:                               GLXContext share_list, 
77099:                               Bool direct)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     GLXContext result = xCreateNewContextInternal(display, config, 
77099: 	                                              render_type,
77099: 	                                              share_list, direct);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: XVisualInfo*
77099: GLXLibrary::xGetVisualFromFBConfig(Display* display, 
77099:                                    GLXFBConfig config)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     XVisualInfo* result = xGetVisualFromFBConfigInternal(display, config);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: int
77099: GLXLibrary::xGetFBConfigAttrib(Display *display,
77099:                                GLXFBConfig config,
77099:                                int attribute,
77099:                                int *value)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     int result = xGetFBConfigAttribInternal(display, config,
77099:                                             attribute, value);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: void
77099: GLXLibrary::xSwapBuffers(Display *display, GLXDrawable drawable)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     xSwapBuffersInternal(display, drawable);
77099:     AFTER_GLX_CALL;
77099: }
77099: 
77099: const char *
77099: GLXLibrary::xQueryExtensionsString(Display *display,
77099:                                    int screen)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     const char *result = xQueryExtensionsStringInternal(display, screen);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: const char *
77099: GLXLibrary::xGetClientString(Display *display,
77099:                              int screen)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     const char *result = xGetClientStringInternal(display, screen);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: const char *
77099: GLXLibrary::xQueryServerString(Display *display,
77099:                                int screen, int name)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     const char *result = xQueryServerStringInternal(display, screen, name);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: GLXPixmap
77099: GLXLibrary::xCreatePixmap(Display *display, 
77099:                           GLXFBConfig config,
77099:                           Pixmap pixmap,
77099:                           const int *attrib_list)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     GLXPixmap result = xCreatePixmapInternal(display, config,
77099:                                              pixmap, attrib_list);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: GLXPixmap
77099: GLXLibrary::xCreateGLXPixmapWithConfig(Display *display,
77099:                                        GLXFBConfig config,
77099:                                        Pixmap pixmap)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     GLXPixmap result = xCreateGLXPixmapWithConfigInternal(display, config, pixmap);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: void
77099: GLXLibrary::xDestroyPixmap(Display *display, GLXPixmap pixmap)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     xDestroyPixmapInternal(display, pixmap);
77099:     AFTER_GLX_CALL;
77099: }
77099: 
77099: GLXContext
77099: GLXLibrary::xCreateContext(Display *display,
77099:                            XVisualInfo *vis,
77099:                            GLXContext shareList,
77099:                            Bool direct)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     GLXContext result = xCreateContextInternal(display, vis, shareList, direct);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: Bool
77099: GLXLibrary::xQueryVersion(Display *display,
77099:                           int *major,
77099:                           int *minor)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     Bool result = xQueryVersionInternal(display, major, minor);
77099:     AFTER_GLX_CALL;
77099:     return result;
77099: }
77099: 
77099: void
77099: GLXLibrary::xBindTexImage(Display *display,
77099:                           GLXDrawable drawable,
77099:                           int buffer,
77099:                           const int *attrib_list)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     xBindTexImageInternal(display, drawable, buffer, attrib_list);
77099:     AFTER_GLX_CALL;
77099: }
77099: 
77099: void
77099: GLXLibrary::xReleaseTexImage(Display *display,
77099:                              GLXDrawable drawable,
77099:                              int buffer)
77099: {
77099:     BEFORE_GLX_CALL;
77099:     xReleaseTexImageInternal(display, drawable, buffer);
77099:     AFTER_GLX_CALL;
77099: }
77099: 
77099: void 
77099: GLXLibrary::xWaitGL()
77099: {
77099:     BEFORE_GLX_CALL;
77099:     xWaitGLInternal();
77099:     AFTER_GLX_CALL;
77099: }
77099: 
77100: void
77100: GLXLibrary::xWaitX()
77100: {
77100:     BEFORE_GLX_CALL;
77100:     xWaitXInternal();
77100:     AFTER_GLX_CALL;
77100: }
77100: 
80903: GLXContext
80903: GLXLibrary::xCreateContextAttribs(Display* display, 
80903:                                   GLXFBConfig config, 
80903:                                   GLXContext share_list, 
80903:                                   Bool direct,
80903:                                   const int* attrib_list)
80903: {
80903:     BEFORE_GLX_CALL;
80903:     GLXContext result = xCreateContextAttribsInternal(display, 
80903:                                                       config, 
80903:                                                       share_list, 
80903:                                                       direct,
80903:                                                       attrib_list);
80903:     AFTER_GLX_CALL;
80903:     return result;
80903: }
80903: 
43628: GLXLibrary sGLXLibrary;
43628: 
43628: class GLContextGLX : public GLContext
43628: {
43628: public:
46140:     static already_AddRefed<GLContextGLX>
47908:     CreateGLContext(const ContextFormat& format,
47908:                     Display *display,
47908:                     GLXDrawable drawable,
47908:                     GLXFBConfig cfg,
47908:                     XVisualInfo *vinfo,
47908:                     GLContextGLX *shareContext,
79445:                     bool deleteDrawable,
47908:                     gfxXlibSurface *pixmap = nsnull)
43628:     {
44139:         int db = 0, err;
44139:         err = sGLXLibrary.xGetFBConfigAttrib(display, cfg,
44139:                                              GLX_DOUBLEBUFFER, &db);
44139:         if (GLX_BAD_ATTRIBUTE != err) {
44139: #ifdef DEBUG
44139:             printf("[GLX] FBConfig is %sdouble-buffered\n", db ? "" : "not ");
44139: #endif
44139:         }
44139: 
47908:         GLXContext context;
58663:         nsRefPtr<GLContextGLX> glContext;
62483:         bool error;
58663: 
58663:         ScopedXErrorHandler xErrorHandler;
43628: 
47908: TRY_AGAIN_NO_SHARING:
47908: 
62483:         error = false;
62483: 
80903:         if (sGLXLibrary.HasRobustness()) {
80903:             int attrib_list[] = {
80903:                 LOCAL_GL_CONTEXT_FLAGS_ARB, LOCAL_GL_CONTEXT_ROBUST_ACCESS_BIT_ARB,
80903:                 LOCAL_GL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB, LOCAL_GL_LOSE_CONTEXT_ON_RESET_ARB,
80903:                 0,
80903:             };
80903: 
80903:             context = sGLXLibrary.xCreateContextAttribs(display,
80903:                                                         cfg,
80903:                                                         shareContext ? shareContext->mContext : NULL,
80903:                                                         True,
80903:                                                         attrib_list);
80903:         } else {
47908:             context = sGLXLibrary.xCreateNewContext(display,
43628:                                                     cfg,
43628:                                                     GLX_RGBA_TYPE,
47908:                                                     shareContext ? shareContext->mContext : NULL,
43628:                                                     True);
80903:         }
43628: 
58663:         if (context) {
58663:             glContext = new GLContextGLX(format,
47908:                                         shareContext,
47908:                                         display,
43628:                                         drawable,
43628:                                         context,
47908:                                         deleteDrawable,
47908:                                         db,
58663:                                         pixmap);
58663:             if (!glContext->Init())
58663:                 error = true;
58663:         } else {
58663:             error = true;
58663:         }
58663: 
62485:         error |= xErrorHandler.SyncAndGetError(display);
62485: 
62485:         if (error) {
58663:             if (shareContext) {
58663:                 shareContext = nsnull;
58663:                 goto TRY_AGAIN_NO_SHARING;
58663:             }
58663: 
58663:             NS_WARNING("Failed to create GLXContext!");
58663:             glContext = nsnull; // note: this must be done while the graceful X error handler is set,
58663:                                 // because glxMakeCurrent can give a GLXBadDrawable error
58663:         }
43628: 
46140:         return glContext.forget();
43628:     }
43628: 
43628:     ~GLContextGLX()
43628:     {
54505:         MarkDestroyed();
49071: 
71948:         // see bug 659842 comment 76
71952: #ifdef DEBUG
71952:         bool success =
71952: #endif
71952:         sGLXLibrary.xMakeCurrent(mDisplay, None, nsnull);
71948:         NS_ABORT_IF_FALSE(success,
71948:             "glXMakeCurrent failed to release GL context before we call glXDestroyContext!");
71948: 
57241:         sGLXLibrary.xDestroyContext(mDisplay, mContext);
47908: 
47908:         if (mDeleteDrawable) {
47908:             sGLXLibrary.xDestroyPixmap(mDisplay, mDrawable);
47908:         }
43628:     }
43628: 
47908:     GLContextType GetContextType() {
47908:         return ContextTypeGLX;
43628:     }
43628: 
79445:     bool Init()
43628:     {
43628:         MakeCurrent();
43628:         SetupLookupFunction();
80486:         if (!InitWithPrefix("gl", true)) {
80486:             return false;
43628:         }
43628: 
94795:         if (!IsExtensionSupported(EXT_framebuffer_object))
92137:             return false;
92137: 
92137:         InitFramebuffers();
92137: 
92137:         return true;
43628:     }
43628: 
98361:     bool MakeCurrentImpl(bool aForce = false)
43628:     {
98361:         bool succeeded = true;
98361: 
98361:         // With the ATI FGLRX driver, glxMakeCurrent is very slow even when the context doesn't change.
98361:         // (This is not the case with other drivers such as NVIDIA).
98361:         // So avoid calling it more than necessary. Since GLX documentation says that:
98361:         //     "glXGetCurrentContext returns client-side information.
98361:         //      It does not make a round trip to the server."
98361:         // I assume that it's not worth using our own TLS slot here.
98361:         if (aForce || sGLXLibrary.xGetCurrentContext() != mContext) {
98361:             succeeded = sGLXLibrary.xMakeCurrent(mDisplay, mDrawable, mContext);
43628:             NS_ASSERTION(succeeded, "Failed to make GL context current!");
98361:         }
54359: 
43628:         return succeeded;
43628:     }
43628: 
79445:     bool SetupLookupFunction()
43628:     {
77099:         mLookupFunc = (PlatformLookupFunction)&GLXLibrary::xGetProcAddress;
80486:         return true;
43628:     }
43628: 
43628:     void *GetNativeData(NativeDataType aType)
43628:     {
43628:         switch(aType) {
43628:         case NativeGLContext:
43628:             return mContext;
43628:  
47908:         case NativeThebesSurface:
47908:             return mPixmap;
43628: 
43628:         default:
43628:             return nsnull;
43628:         }
43628:     }
43628: 
79445:     bool IsDoubleBuffered()
44139:     {
47908:         return mDoubleBuffered;
47908:     }
47908: 
82479:     bool SupportsRobustness()
82479:     {
82479:         return sGLXLibrary.HasRobustness();
82479:     }
82479: 
79445:     bool SwapBuffers()
47908:     {
47908:         if (!mDoubleBuffered)
80486:             return false;
47908:         sGLXLibrary.xSwapBuffers(mDisplay, mDrawable);
67633:         sGLXLibrary.xWaitGL();
80486:         return true;
44139:     }
44139: 
79445:     bool TextureImageSupportsGetBackingSurface()
67636:     {
97344:         return sGLXLibrary.UseTextureFromPixmap();
67636:     }
67636: 
67636:     virtual already_AddRefed<TextureImage>
67636:     CreateTextureImage(const nsIntSize& aSize,
67636:                        TextureImage::ContentType aContentType,
67636:                        GLenum aWrapMode,
98144:                        TextureImage::Flags aFlags = TextureImage::NoFlags);
67636: 
43628: private:
47908:     friend class GLContextProviderGLX;
47908: 
47908:     GLContextGLX(const ContextFormat& aFormat,
47908:                  GLContext *aShareContext,
47908:                  Display *aDisplay,
47908:                  GLXDrawable aDrawable,
47908:                  GLXContext aContext,
79445:                  bool aDeleteDrawable,
79445:                  bool aDoubleBuffered,
47908:                  gfxXlibSurface *aPixmap)
80486:         : GLContext(aFormat, aDeleteDrawable ? true : false, aShareContext),
47908:           mContext(aContext),
43628:           mDisplay(aDisplay),
47908:           mDrawable(aDrawable),
47908:           mDeleteDrawable(aDeleteDrawable),
47908:           mDoubleBuffered(aDoubleBuffered),
47908:           mPixmap(aPixmap)
47908:     { }
43628: 
43628:     GLXContext mContext;
43628:     Display *mDisplay;
47908:     GLXDrawable mDrawable;
79445:     bool mDeleteDrawable;
79445:     bool mDoubleBuffered;
47908: 
47908:     nsRefPtr<gfxXlibSurface> mPixmap;
43628: };
43628: 
67636: class TextureImageGLX : public TextureImage
67636: {
67636:     friend already_AddRefed<TextureImage>
67636:     GLContextGLX::CreateTextureImage(const nsIntSize&,
67636:                                      ContentType,
67636:                                      GLenum,
98144:                                      TextureImage::Flags);
67636: 
67636: public:
67636:     virtual ~TextureImageGLX()
67636:     {
67636:         mGLContext->MakeCurrent();
67636:         mGLContext->fDeleteTextures(1, &mTexture);
67636:         sGLXLibrary.DestroyPixmap(mPixmap);
67636:     }
67636: 
67636:     virtual gfxASurface* BeginUpdate(nsIntRegion& aRegion)
67636:     {
80486:         mInUpdate = true;
67636:         return mUpdateSurface;
67636:     }
67636: 
67636:     virtual void EndUpdate()
67636:     {
80486:         mInUpdate = false;
67636:     }
67636: 
73465: 
73465:     virtual bool DirectUpdate(gfxASurface* aSurface, const nsIntRegion& aRegion, const nsIntPoint& aFrom)
67636:     {
67636:         nsRefPtr<gfxContext> ctx = new gfxContext(mUpdateSurface);
67636:         gfxUtils::ClipToRegion(ctx, aRegion);
73465:         ctx->SetSource(aSurface, aFrom);
67636:         ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
67636:         ctx->Paint();
67636:         return true;
67636:     }
67636: 
67636:     virtual void BindTexture(GLenum aTextureUnit)
67636:     {
67636:         mGLContext->fActiveTexture(aTextureUnit);
73465:         mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
67636:         sGLXLibrary.BindTexImage(mPixmap);
68003:         mGLContext->fActiveTexture(LOCAL_GL_TEXTURE0);
67636:     }
67636: 
67636:     virtual void ReleaseTexture()
67636:     {
67636:         sGLXLibrary.ReleaseTexImage(mPixmap);
67636:     }
67636: 
67636:     virtual already_AddRefed<gfxASurface> GetBackingSurface()
67636:     {
78894:         nsRefPtr<gfxASurface> copy = mUpdateSurface;
78894:         return copy.forget();
67636:     }
67636: 
79445:     virtual bool InUpdate() const { return mInUpdate; }
67636: 
73465:     virtual GLuint GetTextureID() {
73465:         return mTexture;
73465:     };
73465: 
67636: private:
67636:    TextureImageGLX(GLuint aTexture,
67636:                    const nsIntSize& aSize,
67636:                    GLenum aWrapMode,
67636:                    ContentType aContentType,
67636:                    GLContext* aContext,
67636:                    gfxASurface* aSurface,
98144:                    GLXPixmap aPixmap,
98144:                    TextureImage::Flags aFlags = TextureImage::NoFlags)
98144:         : TextureImage(aSize, aWrapMode, aContentType, aFlags)
67636:         , mGLContext(aContext)
67636:         , mUpdateSurface(aSurface)
67636:         , mPixmap(aPixmap)
80486:         , mInUpdate(false)
73465:         , mTexture(aTexture)
67636:     {
67636:         if (aSurface->GetContentType() == gfxASurface::CONTENT_COLOR_ALPHA) {
67636:             mShaderType = gl::RGBALayerProgramType;
67636:         } else {
67636:             mShaderType = gl::RGBXLayerProgramType;
67636:         }
67636:     }
67636: 
67636:     GLContext* mGLContext;
67636:     nsRefPtr<gfxASurface> mUpdateSurface;
67636:     GLXPixmap mPixmap;
79445:     bool mInUpdate;
73465:     GLuint mTexture;
79815: 
79815:     virtual void ApplyFilter()
79815:     {
79815:         mGLContext->ApplyFilterToBoundTexture(mFilter);
79815:     }
67636: };
67636: 
67636: already_AddRefed<TextureImage>
67636: GLContextGLX::CreateTextureImage(const nsIntSize& aSize,
67636:                                  TextureImage::ContentType aContentType,
67636:                                  GLenum aWrapMode,
98144:                                  TextureImage::Flags aFlags)
67636: {
67636:     if (!TextureImageSupportsGetBackingSurface()) {
67636:         return GLContext::CreateTextureImage(aSize, 
67636:                                              aContentType, 
67636:                                              aWrapMode, 
98144:                                              aFlags);
67636:     }
67636: 
67636:     Display *display = DefaultXDisplay();
67636:     int xscreen = DefaultScreen(display);
67636:     gfxASurface::gfxImageFormat imageFormat = gfxASurface::FormatFromContent(aContentType);
67636: 
67636:     XRenderPictFormat* xrenderFormat =
67636:         gfxXlibSurface::FindRenderFormat(display, imageFormat);
67636:     NS_ASSERTION(xrenderFormat, "Could not find a render format for our display!");
67636: 
67636: 
67636:     nsRefPtr<gfxXlibSurface> surface =
67636:         gfxXlibSurface::Create(ScreenOfDisplay(display, xscreen),
67636:                                xrenderFormat,
67636:                                gfxIntSize(aSize.width, aSize.height));
67636:     NS_ASSERTION(surface, "Failed to create xlib surface!");
67636: 
67636:     if (aContentType == gfxASurface::CONTENT_COLOR_ALPHA) {
67636:         nsRefPtr<gfxContext> ctx = new gfxContext(surface);
67636:         ctx->SetOperator(gfxContext::OPERATOR_CLEAR);
67636:         ctx->Paint();
67636:     }
67636: 
67636:     MakeCurrent();
67636:     GLXPixmap pixmap = sGLXLibrary.CreatePixmap(surface);
67636:     NS_ASSERTION(pixmap, "Failed to create pixmap!");
67636: 
67636:     GLuint texture;
67636:     fGenTextures(1, &texture);
67636: 
67636:     fActiveTexture(LOCAL_GL_TEXTURE0);
67636:     fBindTexture(LOCAL_GL_TEXTURE_2D, texture);
67636: 
67636:     nsRefPtr<TextureImageGLX> teximage =
98144:         new TextureImageGLX(texture, aSize, aWrapMode, aContentType, this, surface, pixmap, aFlags);
67636: 
98144:     GLint texfilter = aFlags & TextureImage::UseNearestFilter ? LOCAL_GL_NEAREST : LOCAL_GL_LINEAR;
67636:     fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER, texfilter);
67636:     fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER, texfilter);
67636:     fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_S, aWrapMode);
67636:     fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_T, aWrapMode);
67636: 
67636:     return teximage.forget();
67636: }
67636: 
47908: static GLContextGLX *
47908: GetGlobalContextGLX()
47908: {
47908:     return static_cast<GLContextGLX*>(GLContextProviderGLX::GetGlobalContext());
47908: }
47908: 
79445: static bool
47908: AreCompatibleVisuals(XVisualInfo *one, XVisualInfo *two)
44139: {
44139:     if (one->c_class != two->c_class) {
80486:         return false;
44139:     }
44139: 
44139:     if (one->depth != two->depth) {
80486:         return false;
44139:     }	
44139: 
44139:     if (one->red_mask != two->red_mask ||
44139:         one->green_mask != two->green_mask ||
44139:         one->blue_mask != two->blue_mask) {
80486:         return false;
44139:     }
44139: 
44139:     if (one->bits_per_rgb != two->bits_per_rgb) {
80486:         return false;
44139:     }
44139: 
80486:     return true;
44139: }
44139: 
43628: already_AddRefed<GLContext>
47907: GLContextProviderGLX::CreateForWindow(nsIWidget *aWidget)
43628: {
44139:     if (!sGLXLibrary.EnsureInitialized()) {
43628:         return nsnull;
43628:     }
43628: 
44139:     // Currently, we take whatever Visual the window already has, and
44139:     // try to create an fbconfig for that visual.  This isn't
44139:     // necessarily what we want in the long run; an fbconfig may not
44139:     // be available for the existing visual, or if it is, the GL
44139:     // performance might be suboptimal.  But using the existing visual
44139:     // is a relatively safe intermediate step.
44139: 
44139:     Display *display = (Display*)aWidget->GetNativeData(NS_NATIVE_DISPLAY); 
44139:     int xscreen = DefaultScreen(display);
44139:     Window window = GET_NATIVE_WINDOW(aWidget);
44139: 
44139:     int numConfigs;
46140:     ScopedXFree<GLXFBConfig> cfgs;
57247:     if (gIsATI || !GLXVersionCheck(1, 3)) {
44139:         const int attribs[] = {
44139:             GLX_DOUBLEBUFFER, False,
44139:             0
44139:         };
44139:         cfgs = sGLXLibrary.xChooseFBConfig(display,
44139:                                            xscreen,
44139:                                            attribs,
44139:                                            &numConfigs);
44139:     } else {
44139:         cfgs = sGLXLibrary.xGetFBConfigs(display,
44139:                                          xscreen,
44139:                                          &numConfigs);
44139:     }
44139: 
44139:     if (!cfgs) {
44139:         NS_WARNING("[GLX] glXGetFBConfigs() failed");
44139:         return nsnull;
44139:     }
44139:     NS_ASSERTION(numConfigs > 0, "No FBConfigs found!");
44139: 
44139:     // XXX the visual ID is almost certainly the GLX_FBCONFIG_ID, so
44139:     // we could probably do this first and replace the glXGetFBConfigs
44139:     // with glXChooseConfigs.  Docs are sparklingly clear as always.
44139:     XWindowAttributes widgetAttrs;
44139:     if (!XGetWindowAttributes(display, window, &widgetAttrs)) {
44139:         NS_WARNING("[GLX] XGetWindowAttributes() failed");
44139:         return nsnull;
44139:     }
44139:     const VisualID widgetVisualID = XVisualIDFromVisual(widgetAttrs.visual);
44139: #ifdef DEBUG
44139:     printf("[GLX] widget has VisualID 0x%lx\n", widgetVisualID);
44139: #endif
44139: 
46140:     ScopedXFree<XVisualInfo> vi;
47908:     if (gIsATI) {
44139:         XVisualInfo vinfo_template;
44139:         int nvisuals;
44139:         vinfo_template.visual   = widgetAttrs.visual;
44139:         vinfo_template.visualid = XVisualIDFromVisual(vinfo_template.visual);
44139:         vinfo_template.depth    = widgetAttrs.depth;
44139:         vinfo_template.screen   = xscreen;
44139:         vi = XGetVisualInfo(display, VisualIDMask|VisualDepthMask|VisualScreenMask,
44139:                             &vinfo_template, &nvisuals);
44139:         NS_ASSERTION(vi && nvisuals == 1, "Could not locate unique matching XVisualInfo for Visual");
44139:     }
44139: 
44139:     int matchIndex = -1;
47908:     ScopedXFree<XVisualInfo> vinfo;
47908: 
44139:     for (int i = 0; i < numConfigs; i++) {
47908:         vinfo = sGLXLibrary.xGetVisualFromFBConfig(display, cfgs[i]);
47908:         if (!vinfo) {
44160:             continue;
44160:         }
47908:         if (gIsATI) {
47908:             if (AreCompatibleVisuals(vi, vinfo)) {
44139:                 matchIndex = i;
44139:                 break;
44139:             }
44139:         } else {
47908:             if (widgetVisualID == vinfo->visualid) {
44139:                 matchIndex = i;
44139:                 break;
44139:             }
44139:         }
44139:     }
44139: 
44139:     if (matchIndex == -1) {
44139:         NS_WARNING("[GLX] Couldn't find a FBConfig matching widget visual");
44139:         return nsnull;
44139:     }
44139: 
47908:     GLContextGLX *shareContext = GetGlobalContextGLX();
47908: 
47908:     nsRefPtr<GLContextGLX> glContext = GLContextGLX::CreateGLContext(ContextFormat(ContextFormat::BasicRGB24),
47908:                                                                      display,
44139:                                                                      window,
44139:                                                                      cfgs[matchIndex],
47908:                                                                      vinfo,
47908:                                                                      shareContext,
80486:                                                                      false);
92137: 
46140:     return glContext.forget();
44139: }
44139: 
47908: static already_AddRefed<GLContextGLX>
47908: CreateOffscreenPixmapContext(const gfxIntSize& aSize,
47908:                              const ContextFormat& aFormat,
79445:                              bool aShare)
43628: {
43628:     if (!sGLXLibrary.EnsureInitialized()) {
43628:         return nsnull;
43628:     }
43628: 
47908:     Display *display = DefaultXDisplay();
47908:     int xscreen = DefaultScreen(display);
47908: 
47908:     int attribs[] = {
47908:         GLX_DOUBLEBUFFER, False,
47908:         GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
47908:         GLX_X_RENDERABLE, True,
47908:         GLX_RED_SIZE, 1,
47908:         GLX_GREEN_SIZE, 1,
47908:         GLX_BLUE_SIZE, 1,
47908:         GLX_ALPHA_SIZE, 0,
47908:         GLX_DEPTH_SIZE, 0,
47908:         0
47908:     };
47908:     int numConfigs = 0;
47908: 
47908:     ScopedXFree<GLXFBConfig> cfgs;
47908:     cfgs = sGLXLibrary.xChooseFBConfig(display,
47908:                                        xscreen,
47908:                                        attribs,
47908:                                        &numConfigs);
47908:     if (!cfgs) {
47908:         return nsnull;
47908:     }
47908: 
47908:     NS_ASSERTION(numConfigs > 0,
47908:                  "glXChooseFBConfig() failed to match our requested format and violated its spec (!)");
47908: 
47908:     ScopedXFree<XVisualInfo> vinfo;
58638:     int chosenIndex = 0;
47908: 
47908:     for (int i = 0; i < numConfigs; ++i) {
47908:         int dtype, visid;
47908: 
47908:         if (sGLXLibrary.xGetFBConfigAttrib(display, cfgs[i], GLX_DRAWABLE_TYPE, &dtype) != Success
47908:             || !(dtype & GLX_PIXMAP_BIT))
47908:         {
47908:             continue;
47908:         }
47908:         if (sGLXLibrary.xGetFBConfigAttrib(display, cfgs[i], GLX_VISUAL_ID, &visid) != Success
47908:             || visid == 0)
47908:         {
47908:             continue;
47908:         }
47908: 
47908:         vinfo = sGLXLibrary.xGetVisualFromFBConfig(display, cfgs[i]);
47908: 
47908:         if (vinfo) {
47908:             chosenIndex = i;
47908:             break;
47908:         }
47908:     }
47908: 
47908:     if (!vinfo) {
47908:         NS_WARNING("glXChooseFBConfig() didn't give us any configs with visuals!");
47908:         return nsnull;
47908:     }
47908: 
58663:     ScopedXErrorHandler xErrorHandler;
60113:     GLXPixmap glxpixmap = 0;
58663:     bool error = false;
58663: 
47908:     nsRefPtr<gfxXlibSurface> xsurface = gfxXlibSurface::Create(DefaultScreenOfDisplay(display),
47908:                                                                vinfo->visual,
47908:                                                                gfxIntSize(16, 16));
47908:     if (xsurface->CairoStatus() != 0) {
58663:         error = true;
58663:         goto DONE_CREATING_PIXMAP;
47908:     }
47908: 
57246:     // Handle slightly different signature between glXCreatePixmap and
57246:     // its pre-GLX-1.3 extension equivalent (though given the ABI, we
57246:     // might not need to).
57247:     if (GLXVersionCheck(1, 3)) {
57246:         glxpixmap = sGLXLibrary.xCreatePixmap(display,
47908:                                               cfgs[chosenIndex],
47908:                                               xsurface->XDrawable(),
47908:                                               NULL);
57246:     } else {
57246:         glxpixmap = sGLXLibrary.xCreateGLXPixmapWithConfig(display,
57246:                                                            cfgs[chosenIndex],
57246:                                                            xsurface->
57246:                                                              XDrawable());
57246:     }
47908:     if (glxpixmap == 0) {
58663:         error = true;
47908:     }
47908: 
58663: DONE_CREATING_PIXMAP:
47908: 
58663:     nsRefPtr<GLContextGLX> glContext;
58663:     bool serverError = xErrorHandler.SyncAndGetError(display);
58663: 
58663:     if (!error && // earlier recorded error
58663:         !serverError)
58663:     {
58663:         glContext = GLContextGLX::CreateGLContext(
58663:                         aFormat,
47908:                         display,
47908:                         glxpixmap,
47908:                         cfgs[chosenIndex],
47908:                         vinfo,
58663:                         aShare ? GetGlobalContextGLX() : nsnull,
80486:                         true,
47908:                         xsurface);
58663:     }
47908: 
47908:     return glContext.forget();
47908: }
47908: 
47908: already_AddRefed<GLContext>
47908: GLContextProviderGLX::CreateOffscreen(const gfxIntSize& aSize,
93720:                                       const ContextFormat& aFormat,
93720:                                       const ContextFlags)
47908: {
47908:     nsRefPtr<GLContextGLX> glContext =
80900:         CreateOffscreenPixmapContext(aSize, aFormat, true);
47908: 
47908:     if (!glContext) {
47908:         return nsnull;
47908:     }
47908: 
47908:     if (!glContext->GetSharedContext()) {
47908:         // no point in returning anything if sharing failed, we can't
47908:         // render from this
47908:         return nsnull;
47908:     }
47908: 
96935:     if (!glContext->ResizeOffscreenFBOs(aSize, true)) {
47908:         // we weren't able to create the initial
47908:         // offscreen FBO, so this is dead
47908:         return nsnull;
47908:     }
47908: 
47908:     return glContext.forget();
47908: }
47908: 
47908: already_AddRefed<GLContext>
47908: GLContextProviderGLX::CreateForNativePixmapSurface(gfxASurface *aSurface)
47908: {
47908:     if (!sGLXLibrary.EnsureInitialized()) {
47908:         return nsnull;
47908:     }
47908: 
47908:     if (aSurface->GetType() != gfxASurface::SurfaceTypeXlib) {
47908:         NS_WARNING("GLContextProviderGLX::CreateForNativePixmapSurface called with non-Xlib surface");
47908:         return nsnull;
47908:     }
47908: 
47908:     nsAutoTArray<int, 20> attribs;
43628: 
43628: #define A1_(_x)  do { attribs.AppendElement(_x); } while(0)
43628: #define A2_(_x,_y)  do {                                                \
43628:         attribs.AppendElement(_x);                                      \
43628:         attribs.AppendElement(_y);                                      \
43628:     } while(0)
43628: 
47908:     A2_(GLX_DOUBLEBUFFER, False);
47908:     A2_(GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT);
47908:     A1_(0);
47908: 
43628:     int numFormats;
46140:     Display *display = DefaultXDisplay();
43628:     int xscreen = DefaultScreen(display);
43628: 
46140:     ScopedXFree<GLXFBConfig> cfg(sGLXLibrary.xChooseFBConfig(display,
43628:                                                              xscreen,
43628:                                                              attribs.Elements(),
46140:                                                              &numFormats));
43628:     if (!cfg) {
43628:         return nsnull;
43628:     }
46140:     NS_ASSERTION(numFormats > 0,
46140:                  "glXChooseFBConfig() failed to match our requested format and violated its spec (!)");
43628: 
47908:     gfxXlibSurface *xs = static_cast<gfxXlibSurface*>(aSurface);
43628: 
47908:     GLXPixmap glxpixmap = sGLXLibrary.xCreatePixmap(display,
43628:                                                     cfg[0],
47908:                                                     xs->XDrawable(),
47908:                                                     NULL);
43628: 
47908:     nsRefPtr<GLContextGLX> glContext = GLContextGLX::CreateGLContext(ContextFormat(ContextFormat::BasicRGB24),
47908:                                                                      display,
47908:                                                                      glxpixmap,
47908:                                                                      cfg[0],
47908:                                                                      NULL,
47908:                                                                      NULL,
80486:                                                                      false,
47908:                                                                      xs);
47908: 
46140:     return glContext.forget();
43628: }
43628: 
47908: static nsRefPtr<GLContext> gGlobalContext;
47908: 
47908: GLContext *
47908: GLContextProviderGLX::GetGlobalContext()
44173: {
47908:     static bool triedToCreateContext = false;
47908:     if (!triedToCreateContext && !gGlobalContext) {
47908:         triedToCreateContext = true;
47908:         gGlobalContext = CreateOffscreenPixmapContext(gfxIntSize(1, 1),
47908:                                                       ContextFormat(ContextFormat::BasicRGB24),
80486:                                                       false);
49071:         if (gGlobalContext)
80486:             gGlobalContext->SetIsGlobalSharedContext(true);
47908:     }
47908: 
47908:     return gGlobalContext;
44173: }
44173: 
47967: void
47967: GLContextProviderGLX::Shutdown()
47967: {
47967:     gGlobalContext = nsnull;
47967: }
47967: 
43628: } /* namespace gl */
43628: } /* namespace mozilla */
77099: 
