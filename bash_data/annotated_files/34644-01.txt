    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* vim: set ts=4 sw=4 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Chris Waterson <waterson@netscape.com>
    1:  *   Ben Goodger <ben@netscape.com>
    1:  *   Pete Collins <petejc@collab.net>
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Johnny Stenback <jst@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1: 
    1:   An implementation for the XUL document. This implementation serves
    1:   as the basis for generating an NGLayout content model.
    1: 
    1:   Notes
    1:   -----
    1: 
    1:   1. We do some monkey business in the document observer methods to`
    1:      keep the element map in sync for HTML elements. Why don't we just
    1:      do it for _all_ elements? Well, in the case of XUL elements,
    1:      which may be lazily created during frame construction, the
    1:      document observer methods will never be called because we'll be
    1:      adding the XUL nodes into the content model "quietly".
    1: 
    1: */
    1: 
    1: // Note the ALPHABETICAL ORDERING
    1: #include "nsXULDocument.h"
    1: 
    1: #include "nsDOMError.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsIChromeRegistry.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIDOMNSUIEvent.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIRDFNode.h"
    1: #include "nsIRDFRemoteDataSource.h"
    1: #include "nsIRDFService.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsITimer.h"
    1: #include "nsIDocShell.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsXMLContentSink.h"
   64: #include "nsXULContentSink.h"
    1: #include "nsXULContentUtils.h"
    1: #include "nsIXULOverlayProvider.h"
    1: #include "nsNetUtil.h"
    1: #include "nsParserUtils.h"
    1: #include "nsParserCIID.h"
    1: #include "nsPIBoxObject.h"
    1: #include "nsRDFCID.h"
    1: #include "nsILocalStore.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsXULCommandDispatcher.h"
    1: #include "nsXULDocument.h"
    1: #include "nsXULElement.h"
    1: #include "prlog.h"
    1: #include "rdf.h"
    1: #include "nsIFrame.h"
    1: #include "nsIXBLService.h"
    1: #include "nsCExternalHandlerService.h"
    1: #include "nsMimeTypes.h"
    1: #include "nsIObjectInputStream.h"
    1: #include "nsIObjectOutputStream.h"
    1: #include "nsIFocusController.h"
    1: #include "nsContentList.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptGlobalObjectOwner.h"
    1: #include "nsIScriptRuntime.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIParser.h"
    1: #include "nsIParserService.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIStyleSheetLinkingElement.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsContentErrors.h"
    1: #include "nsIObserverService.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsIXULWindow.h"
 3129: #include "nsXULPopupManager.h"
20136: #include "nsCCUncollectableMarker.h"
25034: #include "nsURILoader.h"
30836: #include "nsCSSFrameConstructor.h"
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // CIDs
    1: //
    1: 
    1: static NS_DEFINE_CID(kParserCID,                 NS_PARSER_CID);
    1: 
    1: static PRBool IsChromeURI(nsIURI* aURI)
    1: {
    1:     // why is this check a member function of nsXULDocument? -gagan
    1:     PRBool isChrome = PR_FALSE;
    1:     if (NS_SUCCEEDED(aURI->SchemeIs("chrome", &isChrome)) && isChrome)
    1:         return PR_TRUE;
    1:     return PR_FALSE;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // Miscellaneous Constants
    1: //
    1: 
    1: const nsForwardReference::Phase nsForwardReference::kPasses[] = {
    1:     nsForwardReference::eConstruction,
    1:     nsForwardReference::eHookup,
    1:     nsForwardReference::eDone
    1: };
    1: 
    1: const PRUint32 kMaxAttrNameLength = 512;
    1: const PRUint32 kMaxAttributeLength = 4096;
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // Statics
    1: //
    1: 
    1: PRInt32 nsXULDocument::gRefCnt = 0;
    1: 
    1: nsIRDFService* nsXULDocument::gRDFService;
    1: nsIRDFResource* nsXULDocument::kNC_persist;
    1: nsIRDFResource* nsXULDocument::kNC_attribute;
    1: nsIRDFResource* nsXULDocument::kNC_value;
    1: 
    1: PRLogModuleInfo* nsXULDocument::gXULLog;
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: struct BroadcasterMapEntry : public PLDHashEntryHdr {
    1:     nsIDOMElement*   mBroadcaster; // [WEAK]
    1:     nsSmallVoidArray mListeners;   // [OWNING] of BroadcastListener objects
    1: };
    1: 
    1: struct BroadcastListener {
11220:     nsWeakPtr mListener;
    1:     nsCOMPtr<nsIAtom> mAttribute;
    1: };
    1: 
15475: nsIContent*
15475: nsRefMapEntry::GetFirstContent()
15475: {
15475:     return static_cast<nsIContent*>(mRefContentList.SafeElementAt(0));
15475: }
15475: 
15475: void
15475: nsRefMapEntry::AppendAll(nsCOMArray<nsIContent>* aElements)
15475: {
15475:     for (PRInt32 i = 0; i < mRefContentList.Count(); ++i) {
15475:         aElements->AppendObject(static_cast<nsIContent*>(mRefContentList[i]));
15475:     }
15475: }
15475: 
15475: PRBool
15475: nsRefMapEntry::AddContent(nsIContent* aContent)
15475: {
15475:     if (mRefContentList.IndexOf(aContent) >= 0)
15475:         return PR_TRUE;
15475:     return mRefContentList.AppendElement(aContent);
15475: }
15475: 
15475: PRBool
15475: nsRefMapEntry::RemoveContent(nsIContent* aContent)
15475: {
15475:     mRefContentList.RemoveElement(aContent);
15475:     return mRefContentList.Count() == 0;
15475: }
15475: 
    1: //----------------------------------------------------------------------
    1: //
    1: // ctors & dtors
    1: //
    1: 
    1:     // NOTE! nsDocument::operator new() zeroes out all members, so
    1:     // don't bother initializing members to 0.
    1: 
    1: nsXULDocument::nsXULDocument(void)
    1:     : nsXMLDocument("application/vnd.mozilla.xul+xml"),
30836:       mDocDirection(Direction_Uninitialized),
34010:       mDocLWTheme(Doc_Theme_Uninitialized),
 3349:       mState(eState_Master),
34010:       mResolutionPhase(nsForwardReference::eStart)
    1: {
    1: 
    1:     // NOTE! nsDocument::operator new() zeroes out all members, so don't
    1:     // bother initializing members to 0.
    1: 
    1:     // Override the default in nsDocument
    1:     mCharacterSet.AssignLiteral("UTF-8");
    1: 
    1:     mDefaultElementType = kNameSpaceID_XUL;
14464: 
14464:     mDelayFrameLoaderInitialization = PR_TRUE;
    1: }
    1: 
    1: nsXULDocument::~nsXULDocument()
    1: {
    1:     NS_ASSERTION(mNextSrcLoadWaiter == nsnull,
    1:         "unreferenced document still waiting for script source to load?");
    1: 
    1:     // In case we failed somewhere early on and the forward observer
    1:     // decls never got resolved.
  873:     mForwardReferences.Clear();
    1: 
    1:     // Destroy our broadcaster map.
    1:     if (mBroadcasterMap) {
    1:         PL_DHashTableDestroy(mBroadcasterMap);
    1:     }
    1: 
    1:     if (mLocalStore) {
    1:         nsCOMPtr<nsIRDFRemoteDataSource> remote =
    1:             do_QueryInterface(mLocalStore);
    1:         if (remote)
    1:             remote->Flush();
    1:     }
    1: 
    1:     delete mTemplateBuilderTable;
    1: 
30836:     nsContentUtils::UnregisterPrefCallback("intl.uidirection.",
30836:                                            nsXULDocument::DirectionChanged,
30836:                                            this);
30836: 
    1:     if (--gRefCnt == 0) {
    1:         NS_IF_RELEASE(gRDFService);
    1: 
    1:         NS_IF_RELEASE(kNC_persist);
    1:         NS_IF_RELEASE(kNC_attribute);
    1:         NS_IF_RELEASE(kNC_value);
    1: 
    1:         // Remove the current document here from the FastLoad table in
    1:         // case the document did not make it past StartLayout in
    1:         // ResumeWalk. The FastLoad table must be clear of entries so
    1:         // that the FastLoad file footer can be properly written.
    1:         if (mDocumentURI)
    1:             nsXULPrototypeCache::GetInstance()->RemoveFromFastLoadSet(mDocumentURI);
    1:     }
    1: }
    1: 
    1: nsresult
    1: NS_NewXULDocument(nsIXULDocument** result)
    1: {
    1:     NS_PRECONDITION(result != nsnull, "null ptr");
    1:     if (! result)
    1:         return NS_ERROR_NULL_POINTER;
    1: 
    1:     nsXULDocument* doc = new nsXULDocument();
    1:     if (! doc)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ADDREF(doc);
    1: 
    1:     nsresult rv;
    1:     if (NS_FAILED(rv = doc->Init())) {
    1:         NS_RELEASE(doc);
    1:         return rv;
    1:     }
    1: 
    1:     *result = doc;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsISupports interface
    1: //
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULDocument)
    1: 
20261: static PLDHashOperator
    1: TraverseTemplateBuilders(nsISupports* aKey, nsIXULTemplateBuilder* aData,
    1:                          void* aContext)
    1: {
    1:     nsCycleCollectionTraversalCallback *cb =
 3233:         static_cast<nsCycleCollectionTraversalCallback*>(aContext);
    1: 
18993:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mTemplateBuilderTable key");
    1:     cb->NoteXPCOMChild(aKey);
18993:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mTemplateBuilderTable value");
    1:     cb->NoteXPCOMChild(aData);
    1: 
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
    1: TraverseObservers(nsIURI* aKey, nsIObserver* aData, void* aContext)
    1: {
    1:     nsCycleCollectionTraversalCallback *cb =
 3233:         static_cast<nsCycleCollectionTraversalCallback*>(aContext);
    1: 
18993:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mOverlayLoadObservers/mPendingOverlayLoadNotifications value");
    1:     cb->NoteXPCOMChild(aData);
    1: 
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXULDocument, nsXMLDocument)
30096:     NS_ASSERTION(!nsCCUncollectableMarker::InGeneration(cb, tmp->GetMarkedCCGeneration()),
25691:                  "Shouldn't traverse nsXULDocument!");
    1:     // XXX tmp->mForwardReferences?
    1:     // XXX tmp->mContextStack?
    1: 
    1:     // An element will only have a template builder as long as it's in the
    1:     // document, so we'll traverse the table here instead of from the element.
    1:     if (tmp->mTemplateBuilderTable)
    1:         tmp->mTemplateBuilderTable->EnumerateRead(TraverseTemplateBuilders, &cb);
    1:         
    1:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mCurrentPrototype,
    1:                                                      nsIScriptGlobalObjectOwner)
    1:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mMasterPrototype,
    1:                                                      nsIScriptGlobalObjectOwner)
   59:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mCommandDispatcher,
   59:                                                      nsIDOMXULCommandDispatcher)
   59: 
    1:     PRUint32 i, count = tmp->mPrototypes.Length();
    1:     for (i = 0; i < count; ++i) {
18993:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mPrototypes[i]");
 3233:         cb.NoteXPCOMChild(static_cast<nsIScriptGlobalObjectOwner*>(tmp->mPrototypes[i]));
    1:     }
    1: 
    1:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTooltipNode)
12609:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLocalStore)
    1: 
    1:     if (tmp->mOverlayLoadObservers.IsInitialized())
    1:         tmp->mOverlayLoadObservers.EnumerateRead(TraverseObservers, &cb);
    1:     if (tmp->mPendingOverlayLoadNotifications.IsInitialized())
    1:         tmp->mPendingOverlayLoadNotifications.EnumerateRead(TraverseObservers, &cb);
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
16588: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXULDocument, nsXMLDocument)
16588:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTooltipNode)
16588: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16588: 
    1: NS_IMPL_ADDREF_INHERITED(nsXULDocument, nsXMLDocument)
    1: NS_IMPL_RELEASE_INHERITED(nsXULDocument, nsXMLDocument)
    1: 
12033: 
12033: // QueryInterface implementation for nsXULDocument
12033: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsXULDocument)
21218:     NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsXULDocument)
21218:       NS_INTERFACE_TABLE_ENTRY(nsXULDocument, nsIXULDocument)
21218:       NS_INTERFACE_TABLE_ENTRY(nsXULDocument, nsIDOMXULDocument)
21218:       NS_INTERFACE_TABLE_ENTRY(nsXULDocument, nsIStreamLoaderObserver)
21218:       NS_INTERFACE_TABLE_ENTRY(nsXULDocument, nsICSSLoaderObserver)
21218:     NS_OFFSET_AND_INTERFACE_TABLE_END
21218:     NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
12033:     NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(XULDocument)
12033: NS_INTERFACE_MAP_END_INHERITING(nsXMLDocument)
12033: 
12033: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsIDocument interface
    1: //
    1: 
    1: void
    1: nsXULDocument::Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup)
    1: {
    1:     NS_NOTREACHED("Reset");
    1: }
    1: 
    1: void
    1: nsXULDocument::ResetToURI(nsIURI* aURI, nsILoadGroup* aLoadGroup,
    1:                           nsIPrincipal* aPrincipal)
    1: {
    1:     NS_NOTREACHED("ResetToURI");
    1: }
    1: 
    1: // Override the nsDocument.cpp method to keep from returning the
    1: // "cached XUL" type which is completely internal and may confuse
    1: // people
    1: NS_IMETHODIMP
    1: nsXULDocument::GetContentType(nsAString& aContentType)
    1: {
    1:     aContentType.AssignLiteral("application/vnd.mozilla.xul+xml");
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsXULDocument::SetContentType(const nsAString& aContentType)
    1: {
    1:     NS_ASSERTION(aContentType.EqualsLiteral("application/vnd.mozilla.xul+xml"),
    1:                  "xul-documents always has content-type application/vnd.mozilla.xul+xml");
    1:     // Don't do anything, xul always has the mimetype
    1:     // application/vnd.mozilla.xul+xml
    1: }
    1: 
    1: // This is called when the master document begins loading, whether it's
    1: // fastloaded or not.
    1: nsresult
    1: nsXULDocument::StartDocumentLoad(const char* aCommand, nsIChannel* aChannel,
    1:                                  nsILoadGroup* aLoadGroup,
    1:                                  nsISupports* aContainer,
    1:                                  nsIStreamListener **aDocListener,
    1:                                  PRBool aReset, nsIContentSink* aSink)
    1: {
    1:     // NOTE: If this ever starts calling nsDocument::StartDocumentLoad
    1:     // we'll possibly need to reset our content type afterwards.
    1:     mStillWalking = PR_TRUE;
10474:     mMayStartLayout = PR_FALSE;
    1:     mDocumentLoadGroup = do_GetWeakReference(aLoadGroup);
    1: 
    1:     mChannel = aChannel;
    1: 
16447:     mHaveInputEncoding = PR_TRUE;
16447: 
    1:     // Get the URI.  Note that this should match nsDocShell::OnLoadingSite
 7109:     nsresult rv =
 7109:         NS_GetFinalChannelURI(aChannel, getter_AddRefs(mDocumentURI));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     rv = ResetStylesheetsToURI(mDocumentURI);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     RetrieveRelevantHeaders(aChannel);
    1: 
    1:     // Look in the chrome cache: we've got this puppy loaded
    1:     // already.
    1:     nsXULPrototypeDocument* proto = IsChromeURI(mDocumentURI) ?
    1:             nsXULPrototypeCache::GetInstance()->GetPrototype(mDocumentURI) :
    1:             nsnull;
    1: 
    1:     // Same comment as nsChromeProtocolHandler::NewChannel and
    1:     // nsXULDocument::ResumeWalk
    1:     // - Ben Goodger
    1:     //
    1:     // We don't abort on failure here because there are too many valid
    1:     // cases that can return failure, and the null-ness of |proto| is enough
    1:     // to trigger the fail-safe parse-from-disk solution. Example failure cases
    1:     // (for reference) include:
    1:     //
    1:     // NS_ERROR_NOT_AVAILABLE: the URI cannot be found in the FastLoad cache,
    1:     //                         parse from disk
    1:     // other: the FastLoad cache file, XUL.mfl, could not be found, probably
    1:     //        due to being accessed before a profile has been selected (e.g.
    1:     //        loading chrome for the profile manager itself). This must be
    1:     //        parsed from disk.
    1: 
    1:     if (proto) {
    1:         // If we're racing with another document to load proto, wait till the
    1:         // load has finished loading before trying to add cloned style sheets.
    1:         // nsXULDocument::EndLoad will call proto->NotifyLoadDone, which will
    1:         // find all racing documents and notify them via OnPrototypeLoadDone,
    1:         // which will add style sheet clones to each document.
    1:         PRBool loaded;
    1:         rv = proto->AwaitLoadDone(this, &loaded);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         mMasterPrototype = mCurrentPrototype = proto;
    1: 
    1:         // Set up the right principal on ourselves.
    1:         SetPrincipal(proto->DocumentPrincipal());
    1: 
    1:         // We need a listener, even if proto is not yet loaded, in which
    1:         // event the listener's OnStopRequest method does nothing, and all
    1:         // the interesting work happens below nsXULDocument::EndLoad, from
    1:         // the call there to mCurrentPrototype->NotifyLoadDone().
    1:         *aDocListener = new CachedChromeStreamListener(this, loaded);
    1:         if (! *aDocListener)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     else {
    1:         PRBool useXULCache = nsXULPrototypeCache::GetInstance()->IsEnabled();
    1:         PRBool fillXULCache = (useXULCache && IsChromeURI(mDocumentURI));
    1: 
    1: 
    1:         // It's just a vanilla document load. Create a parser to deal
    1:         // with the stream n' stuff.
    1: 
    1:         nsCOMPtr<nsIParser> parser;
    1:         rv = PrepareToLoad(aContainer, aCommand, aChannel, aLoadGroup,
    1:                            getter_AddRefs(parser));
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         // Predicate mIsWritingFastLoad on the XUL cache being enabled,
    1:         // so we don't have to re-check whether the cache is enabled all
    1:         // the time.
    1:         mIsWritingFastLoad = useXULCache;
    1: 
    1:         nsCOMPtr<nsIStreamListener> listener = do_QueryInterface(parser, &rv);
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "parser doesn't support nsIStreamListener");
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         *aDocListener = listener;
    1: 
    1:         parser->Parse(mDocumentURI);
    1: 
    1:         // Put the current prototype, created under PrepareToLoad, into the
    1:         // XUL prototype cache now.  We can't do this under PrepareToLoad or
    1:         // overlay loading will break; search for PutPrototype in ResumeWalk
    1:         // and see the comment there.
    1:         if (fillXULCache) {
    1:             nsXULPrototypeCache::GetInstance()->PutPrototype(mCurrentPrototype);
    1:         }
    1:     }
    1: 
    1:     NS_IF_ADDREF(*aDocListener);
    1:     return NS_OK;
    1: }
    1: 
    1: // This gets invoked after a prototype for this document or one of
    1: // its overlays is fully built in the content sink.
    1: void
    1: nsXULDocument::EndLoad()
    1: {
    1:     // This can happen if an overlay fails to load
    1:     if (!mCurrentPrototype)
    1:         return;
    1: 
    1:     nsresult rv;
    1: 
    1:     // Whack the prototype document into the cache so that the next
    1:     // time somebody asks for it, they don't need to load it by hand.
    1: 
    1:     nsCOMPtr<nsIURI> uri = mCurrentPrototype->GetURI();
    1:     PRBool isChrome = IsChromeURI(uri);
    1: 
    1:     // Remember if the XUL cache is on
    1:     PRBool useXULCache = nsXULPrototypeCache::GetInstance()->IsEnabled();
    1: 
    1:     // If the current prototype is an overlay document (non-master prototype)
    1:     // and we're filling the FastLoad disk cache, tell the cache we're done
    1:     // loading it, and write the prototype. The master prototype is put into
    1:     // the cache earlier in nsXULDocument::StartDocumentLoad.
    1:     if (useXULCache && mIsWritingFastLoad && isChrome &&
    1:         mMasterPrototype != mCurrentPrototype) {
    1:         nsXULPrototypeCache::GetInstance()->WritePrototype(mCurrentPrototype);
    1:     }
    1: 
    1:     if (isChrome) {
    1:         nsCOMPtr<nsIXULOverlayProvider> reg =
    1:             do_GetService(NS_CHROMEREGISTRY_CONTRACTID);
    1: 
    1:         if (reg) {
    1:             nsCOMPtr<nsISimpleEnumerator> overlays;
    1:             rv = reg->GetStyleOverlays(uri, getter_AddRefs(overlays));
    1:             if (NS_FAILED(rv)) return;
    1: 
    1:             PRBool moreSheets;
    1:             nsCOMPtr<nsISupports> next;
    1:             nsCOMPtr<nsIURI> sheetURI;
    1: 
    1:             while (NS_SUCCEEDED(rv = overlays->HasMoreElements(&moreSheets)) &&
    1:                    moreSheets) {
    1:                 overlays->GetNext(getter_AddRefs(next));
    1: 
    1:                 sheetURI = do_QueryInterface(next);
    1:                 if (!sheetURI) {
    1:                     NS_ERROR("Chrome registry handed me a non-nsIURI object!");
    1:                     continue;
    1:                 }
    1: 
    1:                 if (IsChromeURI(sheetURI)) {
    1:                     mCurrentPrototype->AddStyleSheetReference(sheetURI);
    1:                 }
    1:             }
    1:         }
    1: 
    1:         if (useXULCache) {
    1:             // If it's a chrome prototype document, then notify any
    1:             // documents that raced to load the prototype, and awaited
    1:             // its load completion via proto->AwaitLoadDone().
    1:             rv = mCurrentPrototype->NotifyLoadDone();
    1:             if (NS_FAILED(rv)) return;
    1:         }
    1:     }
    1: 
    1:     OnPrototypeLoadDone(PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::OnPrototypeLoadDone(PRBool aResumeWalk)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Add the style overlays from chrome registry, if any.
    1:     rv = AddPrototypeSheets();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = PrepareToWalk();
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "unable to prepare for walk");
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     if (aResumeWalk) {
    1:         rv = ResumeWalk();
    1:     }
    1:     return rv;
    1: }
    1: 
    1: // called when an error occurs parsing a document
    1: PRBool
    1: nsXULDocument::OnDocumentParserError()
    1: {
    1:   // don't report errors that are from overlays
    1:   if (mCurrentPrototype && mMasterPrototype != mCurrentPrototype) {
    1:     nsCOMPtr<nsIURI> uri = mCurrentPrototype->GetURI();
    1:     if (IsChromeURI(uri)) {
    1:       nsCOMPtr<nsIObserverService> os(
    1:         do_GetService("@mozilla.org/observer-service;1"));
    1:       if (os)
    1:         os->NotifyObservers(uri, "xul-overlay-parsererror",
    1:                             EmptyString().get());
    1:     }
    1: 
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
20261: static void
    1: ClearBroadcasterMapEntry(PLDHashTable* aTable, PLDHashEntryHdr* aEntry)
    1: {
    1:     BroadcasterMapEntry* entry =
 3233:         static_cast<BroadcasterMapEntry*>(aEntry);
    1:     for (PRInt32 i = entry->mListeners.Count() - 1; i >= 0; --i) {
    1:         delete (BroadcastListener*)entry->mListeners[i];
    1:     }
    1: 
    1:     // N.B. that we need to manually run the dtor because we
    1:     // constructed the nsSmallVoidArray object in-place.
    1:     entry->mListeners.~nsSmallVoidArray();
    1: }
    1: 
    1: static PRBool
    1: CanBroadcast(PRInt32 aNameSpaceID, nsIAtom* aAttribute)
    1: {
 4737:     // Don't push changes to the |id|, |ref|, |persist|, |command| or
 4737:     // |observes| attribute.
    1:     if (aNameSpaceID == kNameSpaceID_None) {
    1:         if ((aAttribute == nsGkAtoms::id) ||
    1:             (aAttribute == nsGkAtoms::ref) ||
 4737:             (aAttribute == nsGkAtoms::persist) ||
 4737:             (aAttribute == nsGkAtoms::command) ||
 4737:             (aAttribute == nsGkAtoms::observes)) {
    1:             return PR_FALSE;
    1:         }
    1:     }
    1:     return PR_TRUE;
    1: }
    1: 
22225: struct nsAttrNameInfo
22225: {
22225:   nsAttrNameInfo(PRInt32 aNamespaceID, nsIAtom* aName, nsIAtom* aPrefix) :
22225:     mNamespaceID(aNamespaceID), mName(aName), mPrefix(aPrefix) {}
22225:   nsAttrNameInfo(const nsAttrNameInfo& aOther) :
22225:     mNamespaceID(aOther.mNamespaceID), mName(aOther.mName),
22225:     mPrefix(aOther.mPrefix) {}
22225:   PRInt32           mNamespaceID;
22225:   nsCOMPtr<nsIAtom> mName;
22225:   nsCOMPtr<nsIAtom> mPrefix;
22225: };
22225: 
    1: void
    1: nsXULDocument::SynchronizeBroadcastListener(nsIDOMElement   *aBroadcaster,
    1:                                             nsIDOMElement   *aListener,
11481:                                             const nsAString &aAttr)
    1: {
24483:     if (!nsContentUtils::IsSafeToRunScript()) {
19296:         nsDelayedBroadcastUpdate delayedUpdate(aBroadcaster, aListener,
19296:                                                aAttr);
19296:         mDelayedBroadcasters.AppendElement(delayedUpdate);
24483:         MaybeBroadcast();
19296:         return;
19296:     }
    1:     nsCOMPtr<nsIContent> broadcaster = do_QueryInterface(aBroadcaster);
    1:     nsCOMPtr<nsIContent> listener = do_QueryInterface(aListener);
32080:     PRBool notify = mInitialLayoutComplete || mHandlingDelayedBroadcasters;
    1: 
    1:     // We may be copying event handlers etc, so we must also copy
    1:     // the script-type to the listener.
    1:     listener->SetScriptTypeID(broadcaster->GetScriptTypeID());
    1: 
    1:     if (aAttr.EqualsLiteral("*")) {
    1:         PRUint32 count = broadcaster->GetAttrCount();
22225:         nsTArray<nsAttrNameInfo> attributes(count);
22225:         for (PRUint32 i = 0; i < count; ++i) {
22225:             const nsAttrName* attrName = broadcaster->GetAttrNameAt(i);
    1:             PRInt32 nameSpaceID = attrName->NamespaceID();
    1:             nsIAtom* name = attrName->LocalName();
    1: 
    1:             // _Don't_ push the |id|, |ref|, or |persist| attribute's value!
    1:             if (! CanBroadcast(nameSpaceID, name))
    1:                 continue;
    1: 
22225:             attributes.AppendElement(nsAttrNameInfo(nameSpaceID, name,
22225:                                                     attrName->GetPrefix()));
22225:         }
22225: 
22225:         count = attributes.Length();
22225:         while (count-- > 0) {
22225:             PRInt32 nameSpaceID = attributes[count].mNamespaceID;
22225:             nsIAtom* name = attributes[count].mName;
    1:             nsAutoString value;
22225:             if (broadcaster->GetAttr(nameSpaceID, name, value)) {
22225:               listener->SetAttr(nameSpaceID, name, attributes[count].mPrefix,
32080:                                 value, notify);
22225:             }
    1: 
    1: #if 0
    1:             // XXX we don't fire the |onbroadcast| handler during
    1:             // initial hookup: doing so would potentially run the
    1:             // |onbroadcast| handler before the |onload| handler,
    1:             // which could define JS properties that mask XBL
    1:             // properties, etc.
    1:             ExecuteOnBroadcastHandlerFor(broadcaster, aListener, name);
    1: #endif
    1:         }
    1:     }
    1:     else {
    1:         // Find out if the attribute is even present at all.
    1:         nsCOMPtr<nsIAtom> name = do_GetAtom(aAttr);
    1: 
    1:         nsAutoString value;
11481:         if (broadcaster->GetAttr(kNameSpaceID_None, name, value)) {
32080:             listener->SetAttr(kNameSpaceID_None, name, value, notify);
12191:         } else {
32080:             listener->UnsetAttr(kNameSpaceID_None, name, notify);
    1:         }
    1: 
    1: #if 0
    1:         // XXX we don't fire the |onbroadcast| handler during initial
    1:         // hookup: doing so would potentially run the |onbroadcast|
    1:         // handler before the |onload| handler, which could define JS
    1:         // properties that mask XBL properties, etc.
    1:         ExecuteOnBroadcastHandlerFor(broadcaster, aListener, name);
    1: #endif
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::AddBroadcastListenerFor(nsIDOMElement* aBroadcaster,
    1:                                        nsIDOMElement* aListener,
    1:                                        const nsAString& aAttr)
    1: {
    1:     NS_ENSURE_ARG(aBroadcaster && aListener);
    1:     
    1:     nsresult rv =
 3233:         nsContentUtils::CheckSameOrigin(static_cast<nsDocument *>(this),
    1:                                         aBroadcaster);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:         return rv;
    1:     }
    1: 
 3233:     rv = nsContentUtils::CheckSameOrigin(static_cast<nsDocument *>(this),
    1:                                          aListener);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:         return rv;
    1:     }
    1: 
    1:     static PLDHashTableOps gOps = {
    1:         PL_DHashAllocTable,
    1:         PL_DHashFreeTable,
    1:         PL_DHashVoidPtrKeyStub,
    1:         PL_DHashMatchEntryStub,
    1:         PL_DHashMoveEntryStub,
    1:         ClearBroadcasterMapEntry,
    1:         PL_DHashFinalizeStub,
    1:         nsnull
    1:     };
    1: 
    1:     if (! mBroadcasterMap) {
    1:         mBroadcasterMap =
    1:             PL_NewDHashTable(&gOps, nsnull, sizeof(BroadcasterMapEntry),
    1:                              PL_DHASH_MIN_SIZE);
    1: 
    1:         if (! mBroadcasterMap)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     BroadcasterMapEntry* entry =
 3233:         static_cast<BroadcasterMapEntry*>
 3233:                    (PL_DHashTableOperate(mBroadcasterMap, aBroadcaster,
    1:                                             PL_DHASH_LOOKUP));
    1: 
    1:     if (PL_DHASH_ENTRY_IS_FREE(entry)) {
    1:         entry =
 3233:             static_cast<BroadcasterMapEntry*>
 3233:                        (PL_DHashTableOperate(mBroadcasterMap, aBroadcaster,
    1:                                                 PL_DHASH_ADD));
    1: 
    1:         if (! entry)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         entry->mBroadcaster = aBroadcaster;
    1: 
    1:         // N.B. placement new to construct the nsSmallVoidArray object
    1:         // in-place
    1:         new (&entry->mListeners) nsSmallVoidArray();
    1:     }
    1: 
    1:     // Only add the listener if it's not there already!
    1:     nsCOMPtr<nsIAtom> attr = do_GetAtom(aAttr);
    1: 
    1:     BroadcastListener* bl;
    1:     for (PRInt32 i = entry->mListeners.Count() - 1; i >= 0; --i) {
 3233:         bl = static_cast<BroadcastListener*>(entry->mListeners[i]);
    1: 
11220:         nsCOMPtr<nsIDOMElement> blListener = do_QueryReferent(bl->mListener);
11220: 
11220:         if ((blListener == aListener) && (bl->mAttribute == attr))
    1:             return NS_OK;
    1:     }
    1: 
    1:     bl = new BroadcastListener;
    1:     if (! bl)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
11220:     bl->mListener  = do_GetWeakReference(aListener);
    1:     bl->mAttribute = attr;
    1: 
    1:     entry->mListeners.AppendElement(bl);
    1: 
11481:     SynchronizeBroadcastListener(aBroadcaster, aListener, aAttr);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::RemoveBroadcastListenerFor(nsIDOMElement* aBroadcaster,
    1:                                           nsIDOMElement* aListener,
    1:                                           const nsAString& aAttr)
    1: {
    1:     // If we haven't added any broadcast listeners, then there sure
    1:     // aren't any to remove.
    1:     if (! mBroadcasterMap)
    1:         return NS_OK;
    1: 
    1:     BroadcasterMapEntry* entry =
 3233:         static_cast<BroadcasterMapEntry*>
 3233:                    (PL_DHashTableOperate(mBroadcasterMap, aBroadcaster,
    1:                                             PL_DHASH_LOOKUP));
    1: 
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:         nsCOMPtr<nsIAtom> attr = do_GetAtom(aAttr);
    1:         for (PRInt32 i = entry->mListeners.Count() - 1; i >= 0; --i) {
    1:             BroadcastListener* bl =
 3233:                 static_cast<BroadcastListener*>(entry->mListeners[i]);
    1: 
11220:             nsCOMPtr<nsIDOMElement> blListener = do_QueryReferent(bl->mListener);
11220: 
11220:             if ((blListener == aListener) && (bl->mAttribute == attr)) {
    1:                 entry->mListeners.RemoveElementAt(i);
    1:                 delete bl;
    1: 
    1:                 if (entry->mListeners.Count() == 0)
    1:                     PL_DHashTableOperate(mBroadcasterMap, aBroadcaster,
    1:                                          PL_DHASH_REMOVE);
    1: 
    1:                 break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::ExecuteOnBroadcastHandlerFor(nsIContent* aBroadcaster,
    1:                                             nsIDOMElement* aListener,
    1:                                             nsIAtom* aAttr)
    1: {
    1:     // Now we execute the onchange handler in the context of the
    1:     // observer. We need to find the observer in order to
    1:     // execute the handler.
    1: 
    1:     nsCOMPtr<nsIContent> listener = do_QueryInterface(aListener);
    1:     PRUint32 count = listener->GetChildCount();
    1:     for (PRUint32 i = 0; i < count; ++i) {
    1:         // Look for an <observes> element beneath the listener. This
    1:         // ought to have an |element| attribute that refers to
    1:         // aBroadcaster, and an |attribute| element that tells us what
    1:         // attriubtes we're listening for.
    1:         nsIContent *child = listener->GetChildAt(i);
    1: 
    1:         if (!child->NodeInfo()->Equals(nsGkAtoms::observes, kNameSpaceID_XUL))
    1:             continue;
    1: 
    1:         // Is this the element that was listening to us?
    1:         nsAutoString listeningToID;
    1:         child->GetAttr(kNameSpaceID_None, nsGkAtoms::element, listeningToID);
    1: 
    1:         nsAutoString broadcasterID;
    1:         aBroadcaster->GetAttr(kNameSpaceID_None, nsGkAtoms::id, broadcasterID);
    1: 
    1:         if (listeningToID != broadcasterID)
    1:             continue;
    1: 
    1:         // We are observing the broadcaster, but is this the right
    1:         // attribute?
    1:         nsAutoString listeningToAttribute;
    1:         child->GetAttr(kNameSpaceID_None, nsGkAtoms::attribute,
    1:                        listeningToAttribute);
    1: 
    1:         if (!aAttr->Equals(listeningToAttribute) &&
    1:             !listeningToAttribute.EqualsLiteral("*")) {
    1:             continue;
    1:         }
    1: 
    1:         // This is the right <observes> element. Execute the
    1:         // |onbroadcast| event handler
    1:         nsEvent event(PR_TRUE, NS_XUL_BROADCAST);
    1: 
 1722:         nsPresShellIterator iter(this);
 1722:         nsCOMPtr<nsIPresShell> shell;
 1722:         while ((shell = iter.GetNextShell())) {
    1: 
    1:             nsCOMPtr<nsPresContext> aPresContext = shell->GetPresContext();
    1: 
    1:             // Handle the DOM event
    1:             nsEventStatus status = nsEventStatus_eIgnore;
    1:             nsEventDispatcher::Dispatch(child, aPresContext, &event, nsnull,
    1:                                         &status);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
29833: nsXULDocument::AttributeWillChange(nsIDocument* aDocument,
29833:                                    nsIContent* aContent, PRInt32 aNameSpaceID,
29833:                                    nsIAtom* aAttribute, PRInt32 aModType)
15475: {
15475:     NS_ABORT_IF_FALSE(aContent, "Null content!");
15475:     NS_PRECONDITION(aAttribute, "Must have an attribute that's changing!");
15475: 
15475:     // XXXbz check aNameSpaceID, dammit!
15475:     // See if we need to update our ref map.
15475:     if (aAttribute == nsGkAtoms::ref ||
15475:         (aAttribute == nsGkAtoms::id && !aContent->GetIDAttributeName())) {
15475:         RemoveElementFromRefMap(aContent);
15475:     }
15475:     
29833:     nsXMLDocument::AttributeWillChange(aDocument, aContent, aNameSpaceID,
29833:                                        aAttribute, aModType);
15475: }
15475: 
15475: void
    1: nsXULDocument::AttributeChanged(nsIDocument* aDocument,
    1:                                 nsIContent* aElement, PRInt32 aNameSpaceID,
 3410:                                 nsIAtom* aAttribute, PRInt32 aModType,
 3410:                                 PRUint32 aStateMask)
    1: {
    1:     NS_ASSERTION(aDocument == this, "unexpected doc");
    1: 
15475:     // Do this here so that all the exit paths below don't leave this undone
15475:     nsXMLDocument::AttributeChanged(aDocument, aElement, aNameSpaceID,
15475:             aAttribute, aModType, aStateMask);
15475: 
15475:     // XXXbz check aNameSpaceID, dammit!
15475:     // See if we need to update our ref map.
15475:     if (aAttribute == nsGkAtoms::ref ||
15475:         (aAttribute == nsGkAtoms::id && !aElement->GetIDAttributeName())) {
15475:         AddElementToRefMap(aElement);
15475:     }
15475:     
    1:     nsresult rv;
    1: 
    1:     // Synchronize broadcast listeners
    1:     nsCOMPtr<nsIDOMElement> domele = do_QueryInterface(aElement);
22228:     if (domele && mBroadcasterMap &&
22228:         CanBroadcast(aNameSpaceID, aAttribute)) {
    1:         BroadcasterMapEntry* entry =
 3233:             static_cast<BroadcasterMapEntry*>
 3233:                        (PL_DHashTableOperate(mBroadcasterMap, domele.get(),
    1:                                                 PL_DHASH_LOOKUP));
    1: 
    1:         if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:             // We've got listeners: push the value.
    1:             nsAutoString value;
    1:             PRBool attrSet = aElement->GetAttr(kNameSpaceID_None, aAttribute, value);
    1: 
 3196:             PRInt32 i;
 3196:             for (i = entry->mListeners.Count() - 1; i >= 0; --i) {
    1:                 BroadcastListener* bl =
 3233:                     static_cast<BroadcastListener*>(entry->mListeners[i]);
    1: 
    1:                 if ((bl->mAttribute == aAttribute) ||
    1:                     (bl->mAttribute == nsGkAtoms::_asterix)) {
22228:                     nsCOMPtr<nsIDOMElement> listenerEl
11220:                         = do_QueryReferent(bl->mListener);
22938:                     nsCOMPtr<nsIContent> l = do_QueryInterface(listenerEl);
22938:                     if (l) {
22938:                         nsAutoString currentValue;
22938:                         PRBool hasAttr = l->GetAttr(kNameSpaceID_None,
22938:                                                     aAttribute,
22938:                                                     currentValue);
22938:                         // We need to update listener only if we're
22938:                         // (1) removing an existing attribute,
22938:                         // (2) adding a new attribute or
22938:                         // (3) changing the value of an attribute.
22938:                         PRBool needsAttrChange =
22938:                             attrSet != hasAttr || !value.Equals(currentValue);
22228:                         nsDelayedBroadcastUpdate delayedUpdate(domele,
22228:                                                                listenerEl,
22228:                                                                aAttribute,
22228:                                                                value,
22938:                                                                attrSet,
22938:                                                                needsAttrChange);
33788: 
33788:                         PRUint32 index =
33788:                             mDelayedAttrChangeBroadcasts.IndexOf(delayedUpdate,
33788:                                 0, nsDelayedBroadcastUpdate::Comparator());
33788:                         if (index != mDelayedAttrChangeBroadcasts.NoIndex) {
33788:                             if (mHandlingDelayedAttrChange) {
33788:                                 NS_WARNING("Broadcasting loop!");
33788:                                 continue;
33788:                             }
33788:                             mDelayedAttrChangeBroadcasts.RemoveElementAt(index);
33788:                         }
33788: 
22228:                         mDelayedAttrChangeBroadcasts.AppendElement(delayedUpdate);
22228:                     }
22228:                 }
    1:             }
    1:         }
    1:     }
    1: 
10912:     // checks for modifications in broadcasters
10912:     PRBool listener, resolved;
10912:     CheckBroadcasterHookup(aElement, &listener, &resolved);
10912: 
    1:     // See if there is anything we need to persist in the localstore.
    1:     //
    1:     // XXX Namespace handling broken :-(
    1:     nsAutoString persist;
    1:     aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::persist, persist);
    1:     if (!persist.IsEmpty()) {
    1:         nsAutoString attr;
    1:         rv = aAttribute->ToString(attr);
    1:         if (NS_FAILED(rv)) return;
    1: 
    1:         // XXXldb This should check that it's a token, not just a substring.
    1:         if (persist.Find(attr) >= 0) {
    1:             rv = Persist(aElement, kNameSpaceID_None, aAttribute);
    1:             if (NS_FAILED(rv)) return;
    1:         }
    1:     }
    1: }
    1: 
    1: void
    1: nsXULDocument::ContentAppended(nsIDocument* aDocument,
    1:                                nsIContent* aContainer,
    1:                                PRInt32 aNewIndexInContainer)
    1: {
    1:     NS_ASSERTION(aDocument == this, "unexpected doc");
    1:     
    1:     // Update our element map
    1:     PRUint32 count = aContainer->GetChildCount();
    1: 
    1:     nsresult rv = NS_OK;
    1:     for (PRUint32 i = aNewIndexInContainer; i < count && NS_SUCCEEDED(rv);
    1:          ++i) {
    1:         rv = AddSubtreeToDocument(aContainer->GetChildAt(i));
    1:     }
15475: 
15475:     nsXMLDocument::ContentAppended(aDocument, aContainer, aNewIndexInContainer);
    1: }
    1: 
    1: void
    1: nsXULDocument::ContentInserted(nsIDocument* aDocument,
    1:                                nsIContent* aContainer,
    1:                                nsIContent* aChild,
    1:                                PRInt32 aIndexInContainer)
    1: {
    1:     NS_ASSERTION(aDocument == this, "unexpected doc");
    1: 
    1:     AddSubtreeToDocument(aChild);
15475: 
15475:     nsXMLDocument::ContentInserted(aDocument, aContainer, aChild, aIndexInContainer);
    1: }
    1: 
    1: void
    1: nsXULDocument::ContentRemoved(nsIDocument* aDocument,
    1:                               nsIContent* aContainer,
    1:                               nsIContent* aChild,
    1:                               PRInt32 aIndexInContainer)
    1: {
    1:     NS_ASSERTION(aDocument == this, "unexpected doc");
    1: 
    1:     RemoveSubtreeFromDocument(aChild);
15475: 
15475:     nsXMLDocument::ContentRemoved(aDocument, aContainer, aChild, aIndexInContainer);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsIXULDocument interface
    1: //
    1: 
    1: NS_IMETHODIMP
15475: nsXULDocument::AddElementForID(nsIContent* aElement)
    1: {
    1:     NS_PRECONDITION(aElement != nsnull, "null ptr");
    1:     if (! aElement)
    1:         return NS_ERROR_NULL_POINTER;
    1: 
15475:     UpdateIdTableEntry(aElement);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetElementsForID(const nsAString& aID,
    1:                                 nsCOMArray<nsIContent>& aElements)
    1: {
15475:     aElements.Clear();
15475: 
15475:     nsCOMPtr<nsIAtom> atom = do_GetAtom(aID);
15475:     if (!atom)
15475:         return NS_ERROR_OUT_OF_MEMORY;
15475:     nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(atom);
15475:     if (entry) {
15475:         entry->AppendAllIdContent(&aElements);
15475:     }
15475:     nsRefMapEntry *refEntry = mRefMap.GetEntry(atom);
15475:     if (refEntry) {
15475:         refEntry->AppendAll(&aElements);
15475:     }
    1:     return NS_OK;
    1: }
    1: 
  873: nsresult
    1: nsXULDocument::AddForwardReference(nsForwardReference* aRef)
    1: {
    1:     if (mResolutionPhase < aRef->GetPhase()) {
  873:         if (!mForwardReferences.AppendElement(aRef)) {
  873:             delete aRef;
  873:             return NS_ERROR_OUT_OF_MEMORY;
  873:         }
    1:     }
    1:     else {
    1:         NS_ERROR("forward references have already been resolved");
    1:         delete aRef;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
  873: nsresult
    1: nsXULDocument::ResolveForwardReferences()
    1: {
    1:     if (mResolutionPhase == nsForwardReference::eDone)
    1:         return NS_OK;
    1: 
32929:     NS_ASSERTION(mResolutionPhase == nsForwardReference::eStart,
32929:                  "nested ResolveForwardReferences()");
32929:         
    1:     // Resolve each outstanding 'forward' reference. We iterate
    1:     // through the list of forward references until no more forward
    1:     // references can be resolved. This annealing process is
    1:     // guaranteed to converge because we've "closed the gate" to new
    1:     // forward references.
    1: 
    1:     const nsForwardReference::Phase* pass = nsForwardReference::kPasses;
    1:     while ((mResolutionPhase = *pass) != nsForwardReference::eDone) {
  873:         PRUint32 previous = 0;
  873:         while (mForwardReferences.Length() &&
  873:                mForwardReferences.Length() != previous) {
  873:             previous = mForwardReferences.Length();
  873: 
  873:             for (PRUint32 i = 0; i < mForwardReferences.Length(); ++i) {
  873:                 nsForwardReference* fwdref = mForwardReferences[i];
    1: 
    1:                 if (fwdref->GetPhase() == *pass) {
    1:                     nsForwardReference::Result result = fwdref->Resolve();
    1: 
    1:                     switch (result) {
    1:                     case nsForwardReference::eResolve_Succeeded:
    1:                     case nsForwardReference::eResolve_Error:
    1:                         mForwardReferences.RemoveElementAt(i);
    1: 
    1:                         // fixup because we removed from list
    1:                         --i;
    1:                         break;
    1: 
    1:                     case nsForwardReference::eResolve_Later:
    1:                         // do nothing. we'll try again later
    1:                         ;
    1:                     }
32929: 
32929:                     if (mResolutionPhase == nsForwardReference::eStart) {
32929:                         // Resolve() loaded a dynamic overlay,
32929:                         // (see nsXULDocument::LoadOverlayInternal()).
32929:                         // Return for now, we will be called again.
32929:                         return NS_OK;
32929:                     }
    1:                 }
    1:             }
    1:         }
    1: 
    1:         ++pass;
    1:     }
    1: 
  873:     mForwardReferences.Clear();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetScriptGlobalObjectOwner(nsIScriptGlobalObjectOwner** aGlobalOwner)
    1: {
    1:     NS_IF_ADDREF(*aGlobalOwner = mMasterPrototype);
    1:     return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsIDOMDocument interface
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetElementsByAttribute(const nsAString& aAttribute,
    1:                                       const nsAString& aValue,
    1:                                       nsIDOMNodeList** aReturn)
    1: {
    1:     nsCOMPtr<nsIAtom> attrAtom(do_GetAtom(aAttribute));
    1:     NS_ENSURE_TRUE(attrAtom, NS_ERROR_OUT_OF_MEMORY);
    1:     void* attrValue = new nsString(aValue);
    1:     NS_ENSURE_TRUE(attrValue, NS_ERROR_OUT_OF_MEMORY);
    1:     nsContentList *list = new nsContentList(this,
    1:                                             MatchAttribute,
    1:                                             nsContentUtils::DestroyMatchString,
    1:                                             attrValue,
    1:                                             PR_TRUE,
    1:                                             attrAtom,
    1:                                             kNameSpaceID_Unknown);
    1:     NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1:     
    1:     NS_ADDREF(*aReturn = list);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetElementsByAttributeNS(const nsAString& aNamespaceURI,
    1:                                         const nsAString& aAttribute,
    1:                                         const nsAString& aValue,
    1:                                         nsIDOMNodeList** aReturn)
    1: {
    1:     nsCOMPtr<nsIAtom> attrAtom(do_GetAtom(aAttribute));
    1:     NS_ENSURE_TRUE(attrAtom, NS_ERROR_OUT_OF_MEMORY);
    1:     void* attrValue = new nsString(aValue);
    1:     NS_ENSURE_TRUE(attrValue, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
    1:     if (!aNamespaceURI.EqualsLiteral("*")) {
    1:       nsresult rv =
    1:         nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
    1:                                                               nameSpaceId);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     nsContentList *list = new nsContentList(this,
    1:                                             MatchAttribute,
    1:                                             nsContentUtils::DestroyMatchString,
    1:                                             attrValue,
    1:                                             PR_TRUE,
    1:                                             attrAtom,
    1:                                             nameSpaceId);
    1:     NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     NS_ADDREF(*aReturn = list);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::Persist(const nsAString& aID,
    1:                        const nsAString& aAttr)
    1: {
    1:     // If we're currently reading persisted attributes out of the
    1:     // localstore, _don't_ re-enter and try to set them again!
    1:     if (mApplyingPersistedAttrs)
    1:         return NS_OK;
    1: 
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIDOMElement> domelement;
    1:     rv = GetElementById(aID, getter_AddRefs(domelement));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     if (! domelement)
    1:         return NS_OK;
    1: 
    1:     nsCOMPtr<nsIContent> element = do_QueryInterface(domelement);
    1:     NS_ASSERTION(element != nsnull, "null ptr");
    1:     if (! element)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     nsCOMPtr<nsIAtom> tag;
    1:     PRInt32 nameSpaceID;
    1: 
    1:     nsCOMPtr<nsINodeInfo> ni = element->GetExistingAttrNameFromQName(aAttr);
    1:     if (ni) {
    1:         tag = ni->NameAtom();
    1:         nameSpaceID = ni->NamespaceID();
    1:     }
    1:     else {
    1:         // Make sure that this QName is going to be valid.
    1:         nsIParserService *parserService = nsContentUtils::GetParserService();
    1:         NS_ASSERTION(parserService, "Running scripts during shutdown?");
    1: 
    1:         const PRUnichar *colon;
    1:         rv = parserService->CheckQName(PromiseFlatString(aAttr), PR_TRUE, &colon);
    1:         if (NS_FAILED(rv)) {
    1:             // There was an invalid character or it was malformed.
    1:             return NS_ERROR_INVALID_ARG;
    1:         }
    1: 
    1:         if (colon) {
    1:             // We don't really handle namespace qualifiers in attribute names.
    1:             return NS_ERROR_NOT_IMPLEMENTED;
    1:         }
    1: 
    1:         tag = do_GetAtom(aAttr);
    1:         NS_ENSURE_TRUE(tag, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:         nameSpaceID = kNameSpaceID_None;
    1:     }
    1: 
    1:     rv = Persist(element, nameSpaceID, tag);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
20622: PRBool
20622: nsXULDocument::IsCapabilityEnabled(const char* aCapabilityLabel)
20622: {
20622:     nsresult rv;
20622: 
20622:     // NodePrincipal is guarantied to be non-null
20622:     PRBool enabled = PR_FALSE;
20622:     rv = NodePrincipal()->IsCapabilityEnabled(aCapabilityLabel, nsnull, &enabled);
20622:     if (NS_FAILED(rv))
20622:         return PR_FALSE;
20622:  
20622:     return enabled;
20622: }
20622: 
20622: 
    1: nsresult
    1: nsXULDocument::Persist(nsIContent* aElement, PRInt32 aNameSpaceID,
    1:                        nsIAtom* aAttribute)
    1: {
20622:     // For non-chrome documents, persistance is simply broken
20622:     if (!IsCapabilityEnabled("UniversalBrowserWrite"))
20622:         return NS_ERROR_NOT_AVAILABLE;
20622: 
    1:     // First make sure we _have_ a local store to stuff the persisted
    1:     // information into. (We might not have one if profile information
    1:     // hasn't been loaded yet...)
    1:     if (!mLocalStore)
    1:         return NS_OK;
    1: 
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIRDFResource> element;
    1:     rv = nsXULContentUtils::GetElementResource(aElement, getter_AddRefs(element));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // No ID, so nothing to persist.
    1:     if (! element)
    1:         return NS_OK;
    1: 
    1:     // Ick. Construct a property from the attribute. Punt on
    1:     // namespaces for now.
    1:     const char* attrstr;
    1:     rv = aAttribute->GetUTF8String(&attrstr);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Don't bother with unreasonable attributes. We clamp long values,
    1:     // but truncating attribute names turns it into a different attribute
    1:     // so there's no point in persisting anything at all
    1:     if (!attrstr || strlen(attrstr) > kMaxAttrNameLength) {
    1:         NS_WARNING("Can't persist, Attribute name too long");
    1:         return NS_ERROR_ILLEGAL_VALUE;
    1:     }
    1: 
    1:     nsCOMPtr<nsIRDFResource> attr;
    1:     rv = gRDFService->GetResource(nsDependentCString(attrstr),
    1:                                   getter_AddRefs(attr));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Turn the value into a literal
    1:     nsAutoString valuestr;
    1:     aElement->GetAttr(kNameSpaceID_None, aAttribute, valuestr);
    1: 
    1:     // prevent over-long attributes that choke the parser (bug 319846)
    1:     // (can't simply Truncate without testing, it's implemented
    1:     // using SetLength and will grow a short string)
    1:     if (valuestr.Length() > kMaxAttributeLength) {
    1:         NS_WARNING("Truncating persisted attribute value");
    1:         valuestr.Truncate(kMaxAttributeLength);
    1:     }
    1: 
    1:     // See if there was an old value...
    1:     nsCOMPtr<nsIRDFNode> oldvalue;
    1:     rv = mLocalStore->GetTarget(element, attr, PR_TRUE, getter_AddRefs(oldvalue));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     if (oldvalue && valuestr.IsEmpty()) {
    1:         // ...there was an oldvalue, and they've removed it. XXXThis
    1:         // handling isn't quite right...
    1:         rv = mLocalStore->Unassert(element, attr, oldvalue);
    1:     }
    1:     else {
    1:         // Now either 'change' or 'assert' based on whether there was
    1:         // an old value.
    1:         nsCOMPtr<nsIRDFLiteral> newvalue;
    1:         rv = gRDFService->GetLiteral(valuestr.get(), getter_AddRefs(newvalue));
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         if (oldvalue) {
    1:             if (oldvalue != newvalue)
    1:                 rv = mLocalStore->Change(element, attr, oldvalue, newvalue);
    1:             else
    1:                 rv = NS_OK;
    1:         }
    1:         else {
    1:             rv = mLocalStore->Assert(element, attr, newvalue, PR_TRUE);
    1:         }
    1:     }
    1: 
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Add it to the persisted set for this document (if it's not
    1:     // there already).
    1:     {
    1:         nsCAutoString docurl;
    1:         rv = mDocumentURI->GetSpec(docurl);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         nsCOMPtr<nsIRDFResource> doc;
    1:         rv = gRDFService->GetResource(docurl, getter_AddRefs(doc));
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         PRBool hasAssertion;
    1:         rv = mLocalStore->HasAssertion(doc, kNC_persist, element, PR_TRUE, &hasAssertion);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         if (! hasAssertion) {
    1:             rv = mLocalStore->Assert(doc, kNC_persist, element, PR_TRUE);
    1:             if (NS_FAILED(rv)) return rv;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
 1750: nsXULDocument::GetViewportSize(PRInt32* aWidth,
    1:                                PRInt32* aHeight)
    1: {
 1750:     *aWidth = *aHeight = 0;
    1: 
    1:     FlushPendingNotifications(Flush_Layout);
    1: 
 1750:     nsIPresShell *shell = GetPrimaryShell();
 1750:     NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
 1750: 
 1750:     nsIFrame* frame = shell->GetRootFrame();
 1750:     NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 1750: 
 1750:     nsSize size = frame->GetSize();
    1: 
    1:     *aWidth = nsPresContext::AppUnitsToIntCSSPixels(size.width);
    1:     *aHeight = nsPresContext::AppUnitsToIntCSSPixels(size.height);
 1750: 
 1750:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetWidth(PRInt32* aWidth)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aWidth);
    1: 
 1750:     PRInt32 height;
 1750:     return GetViewportSize(aWidth, &height);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetHeight(PRInt32* aHeight)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aHeight);
    1: 
 1750:     PRInt32 width;
 1750:     return GetViewportSize(&width, aHeight);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsIDOMXULDocument interface
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetPopupNode(nsIDOMNode** aNode)
    1: {
    1:     // Get popup node.
    1:     nsresult rv = TrustedGetPopupNode(aNode); // addref happens here
    1: 
    1:     if (NS_SUCCEEDED(rv) && *aNode && !nsContentUtils::CanCallerAccess(*aNode)) {
    1:         NS_RELEASE(*aNode);
    1:         return NS_ERROR_DOM_SECURITY_ERR;
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::TrustedGetPopupNode(nsIDOMNode** aNode)
    1: {
    1:     // Get the focus controller.
    1:     nsCOMPtr<nsIFocusController> focusController;
    1:     GetFocusController(getter_AddRefs(focusController));
    1:     NS_ENSURE_TRUE(focusController, NS_ERROR_FAILURE);
    1: 
    1:     // Get the popup node.
    1:     return focusController->GetPopupNode(aNode); // addref happens here
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::SetPopupNode(nsIDOMNode* aNode)
    1: {
    1:     nsresult rv;
    1: 
    1:     // get focus controller
    1:     nsCOMPtr<nsIFocusController> focusController;
    1:     GetFocusController(getter_AddRefs(focusController));
    1:     NS_ENSURE_TRUE(focusController, NS_ERROR_FAILURE);
    1:     // set popup node
    1:     rv = focusController->SetPopupNode(aNode);
    1: 
    1:     return rv;
    1: }
    1: 
 3129: // Returns the rangeOffset element from the XUL Popup Manager. This is for
 3129: // chrome callers only.
    1: NS_IMETHODIMP
    1: nsXULDocument::GetPopupRangeParent(nsIDOMNode** aRangeParent)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aRangeParent);
    1:     *aRangeParent = nsnull;
    1: 
 3129:     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:     if (!pm)
 3129:         return NS_ERROR_FAILURE;
 3129: 
 3129:     PRInt32 offset;
 3129:     pm->GetMouseLocation(aRangeParent, &offset);
 3129: 
 3129:     if (*aRangeParent && !nsContentUtils::CanCallerAccess(*aRangeParent)) {
    1:         NS_RELEASE(*aRangeParent);
    1:         return NS_ERROR_DOM_SECURITY_ERR;
    1:     }
 3129: 
 3129:     return NS_OK;
 3129: }
 3129: 
 3129: // Returns the rangeOffset element from the XUL Popup Manager. We check the
 3129: // rangeParent to determine if the caller has rights to access to the data.
    1: NS_IMETHODIMP
    1: nsXULDocument::GetPopupRangeOffset(PRInt32* aRangeOffset)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aRangeOffset);
    1: 
 3129:     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:     if (!pm)
 3129:         return NS_ERROR_FAILURE;
 3129: 
 3129:     PRInt32 offset;
    1:     nsCOMPtr<nsIDOMNode> parent;
 3129:     pm->GetMouseLocation(getter_AddRefs(parent), &offset);
    1: 
    1:     if (parent && !nsContentUtils::CanCallerAccess(parent))
    1:         return NS_ERROR_DOM_SECURITY_ERR;
    1: 
 3129:     *aRangeOffset = offset;
 3129:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetTooltipNode(nsIDOMNode** aNode)
    1: {
    1:     if (mTooltipNode && !nsContentUtils::CanCallerAccess(mTooltipNode)) {
    1:         return NS_ERROR_DOM_SECURITY_ERR;
    1:     }
    1:     *aNode = mTooltipNode;
    1:     NS_IF_ADDREF(*aNode);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::TrustedGetTooltipNode(nsIDOMNode** aNode)
    1: {
    1:     NS_IF_ADDREF(*aNode = mTooltipNode);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::SetTooltipNode(nsIDOMNode* aNode)
    1: {
    1:     mTooltipNode = aNode;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetCommandDispatcher(nsIDOMXULCommandDispatcher** aTracker)
    1: {
    1:     *aTracker = mCommandDispatcher;
    1:     NS_IF_ADDREF(*aTracker);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetElementById(const nsAString& aId,
    1:                               nsIDOMElement** aReturn)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aReturn);
    1:     *aReturn = nsnull;
    1: 
15475:     nsCOMPtr<nsIAtom> atom = do_GetAtom(aId);
15475:     if (!atom)
15475:         return NS_ERROR_OUT_OF_MEMORY;
15515: 
15515:     if (!CheckGetElementByIdArg(atom))
15515:         return NS_OK;
15515: 
15475:     nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(atom);
15475:     if (entry) {
15475:         nsIContent* content = entry->GetIdContent();
15475:         if (content)
15475:             return CallQueryInterface(content, aReturn);
15475:     }
15475:     nsRefMapEntry* refEntry = mRefMap.GetEntry(atom);
15475:     if (refEntry) {
15475:         NS_ASSERTION(refEntry->GetFirstContent(),
15475:                      "nsRefMapEntries should have nonempty content lists");
15475:         return CallQueryInterface(refEntry->GetFirstContent(), aReturn);
15475:     }
15475:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::AddElementToDocumentPre(nsIContent* aElement)
    1: {
    1:     // Do a bunch of work that's necessary when an element gets added
    1:     // to the XUL Document.
    1:     nsresult rv;
    1: 
15475:     // 1. Add the element to the resource-to-element map. Also add it to
15475:     // the id map, since it seems this can be called when creating
15475:     // elements from prototypes.
15475:     UpdateIdTableEntry(aElement);
15475:     rv = AddElementToRefMap(aElement);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // 2. If the element is a 'command updater' (i.e., has a
    1:     // "commandupdater='true'" attribute), then add the element to the
    1:     // document's command dispatcher
    1:     if (aElement->AttrValueIs(kNameSpaceID_None, nsGkAtoms::commandupdater,
    1:                               nsGkAtoms::_true, eCaseMatters)) {
    1:         rv = nsXULContentUtils::SetCommandUpdater(this, aElement);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     // 3. Check for a broadcaster hookup attribute, in which case
    1:     // we'll hook the node up as a listener on a broadcaster.
    1:     PRBool listener, resolved;
    1:     rv = CheckBroadcasterHookup(aElement, &listener, &resolved);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // If it's not there yet, we may be able to defer hookup until
    1:     // later.
    1:     if (listener && !resolved && (mResolutionPhase != nsForwardReference::eDone)) {
    1:         BroadcasterHookup* hookup = new BroadcasterHookup(this, aElement);
    1:         if (! hookup)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         rv = AddForwardReference(hookup);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::AddElementToDocumentPost(nsIContent* aElement)
    1: {
    1:     // We need to pay special attention to the keyset tag to set up a listener
    1:     if (aElement->NodeInfo()->Equals(nsGkAtoms::keyset, kNameSpaceID_XUL)) {
    1:         // Create our XUL key listener and hook it up.
    1:         nsCOMPtr<nsIXBLService> xblService(do_GetService("@mozilla.org/xbl;1"));
    1:         if (xblService) {
 1418:             nsCOMPtr<nsPIDOMEventTarget> piTarget(do_QueryInterface(aElement));
 1418:             xblService->AttachGlobalKeyHandler(piTarget);
    1:         }
    1:     }
    1: 
    1:     // See if we need to attach a XUL template to this node
    1:     PRBool needsHookup;
    1:     nsresult rv = CheckTemplateBuilderHookup(aElement, &needsHookup);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (needsHookup) {
    1:         if (mResolutionPhase == nsForwardReference::eDone) {
    1:             rv = CreateTemplateBuilder(aElement);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
    1:         else {
    1:             TemplateBuilderHookup* hookup = new TemplateBuilderHookup(aElement);
    1:             if (! hookup)
    1:                 return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:             rv = AddForwardReference(hookup);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::AddSubtreeToDocument(nsIContent* aElement)
    1: {
28875:     NS_ASSERTION(aElement->GetCurrentDoc() == this, "Element not in doc!");
    1:     // From here on we only care about elements.
    1:     if (!aElement->IsNodeOfType(nsINode::eELEMENT)) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Do pre-order addition magic
    1:     nsresult rv = AddElementToDocumentPre(aElement);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Recurse to children
20665:     PRUint32 count = aElement->GetChildCount();
    1: 
    1:     while (count-- > 0) {
    1:         rv = AddSubtreeToDocument(aElement->GetChildAt(count));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     // Do post-order addition magic
    1:     return AddElementToDocumentPost(aElement);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::RemoveSubtreeFromDocument(nsIContent* aElement)
    1: {
    1:     // From here on we only care about elements.
    1:     if (!aElement->IsNodeOfType(nsINode::eELEMENT)) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Do a bunch of cleanup to remove an element from the XUL
    1:     // document.
    1:     nsresult rv;
    1: 
16430:     if (aElement->NodeInfo()->Equals(nsGkAtoms::keyset, kNameSpaceID_XUL)) {
16430:         nsCOMPtr<nsIXBLService> xblService(do_GetService("@mozilla.org/xbl;1"));
16430:         if (xblService) {
16430:             nsCOMPtr<nsPIDOMEventTarget> piTarget(do_QueryInterface(aElement));
16430:             xblService->DetachGlobalKeyHandler(piTarget);
16430:         }
16430:     }
16430: 
    1:     // 1. Remove any children from the document.
    1:     PRUint32 count = aElement->GetChildCount();
    1: 
    1:     while (count-- > 0) {
    1:         rv = RemoveSubtreeFromDocument(aElement->GetChildAt(count));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
15562:     // 2. Remove the element from the resource-to-element map.
15562:     // Also remove it from the id map, since we added it in
15562:     // AddElementToDocumentPre().
15475:     RemoveElementFromRefMap(aElement);
15562:     RemoveFromIdTable(aElement);
    1: 
    1:     // 3. If the element is a 'command updater', then remove the
    1:     // element from the document's command dispatcher.
    1:     if (aElement->AttrValueIs(kNameSpaceID_None, nsGkAtoms::commandupdater,
    1:                               nsGkAtoms::_true, eCaseMatters)) {
    1:         nsCOMPtr<nsIDOMElement> domelement = do_QueryInterface(aElement);
    1:         NS_ASSERTION(domelement != nsnull, "not a DOM element");
    1:         if (! domelement)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         rv = mCommandDispatcher->RemoveCommandUpdater(domelement);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     // 4. Remove the element from our broadcaster map, since it is no longer
    1:     // in the document.
    1:     nsCOMPtr<nsIDOMElement> broadcaster, listener;
    1:     nsAutoString attribute, broadcasterID;
    1:     rv = FindBroadcaster(aElement, getter_AddRefs(listener),
    1:                          broadcasterID, attribute, getter_AddRefs(broadcaster));
    1:     if (rv == NS_FINDBROADCASTER_FOUND) {
    1:         RemoveBroadcastListenerFor(broadcaster, listener, attribute);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::SetTemplateBuilderFor(nsIContent* aContent,
    1:                                      nsIXULTemplateBuilder* aBuilder)
    1: {
    1:     if (! mTemplateBuilderTable) {
    1:         mTemplateBuilderTable = new BuilderTable;
    1:         if (! mTemplateBuilderTable || !mTemplateBuilderTable->Init()) {
    1:             mTemplateBuilderTable = nsnull;
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:     }
    1: 
    1:     if (aBuilder) {
    1:         mTemplateBuilderTable->Put(aContent, aBuilder);
    1:     }
    1:     else {
    1:         mTemplateBuilderTable->Remove(aContent);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::GetTemplateBuilderFor(nsIContent* aContent,
    1:                                      nsIXULTemplateBuilder** aResult)
    1: {
    1:     if (mTemplateBuilderTable) {
    1:         mTemplateBuilderTable->Get(aContent, aResult);
    1:     }
    1:     else
    1:         *aResult = nsnull;
    1: 
    1:     return NS_OK;
    1: }
    1: 
15475: static void
15475: GetRefMapAttribute(nsIContent* aElement, nsAutoString* aValue)
 4036: {
15475:     aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::ref, *aValue);
15475:     if (aValue->IsEmpty() && !aElement->GetIDAttributeName()) {
15475:         aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::id, *aValue);
15475:     }
15475: }
 4036: 
    1: nsresult
15475: nsXULDocument::AddElementToRefMap(nsIContent* aElement)
    1: {
15475:     // Look at the element's 'ref' attribute, and if set,
15475:     // add an entry in the resource-to-element map to the element.
 4036:     nsAutoString value;
15475:     GetRefMapAttribute(aElement, &value);
 4036:     if (!value.IsEmpty()) {
15475:         nsCOMPtr<nsIAtom> atom = do_GetAtom(value);
15475:         if (!atom)
15475:             return NS_ERROR_OUT_OF_MEMORY;
15475:         nsRefMapEntry *entry = mRefMap.PutEntry(atom);
15475:         if (!entry)
15475:             return NS_ERROR_OUT_OF_MEMORY;
15475:         if (!entry->AddContent(aElement))
15475:             return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
15475: void
15475: nsXULDocument::RemoveElementFromRefMap(nsIContent* aElement)
    1: {
    1:     // Remove the element from the resource-to-element map.
 4036:     nsAutoString value;
15475:     GetRefMapAttribute(aElement, &value);
 4036:     if (!value.IsEmpty()) {
15475:         nsCOMPtr<nsIAtom> atom = do_GetAtom(value);
15475:         if (!atom)
15475:             return;
15475:         nsRefMapEntry *entry = mRefMap.GetEntry(atom);
15475:         if (!entry)
15475:             return;
15475:         if (entry->RemoveContent(aElement)) {
15475:             mRefMap.RemoveEntry(atom);
15475:         }
15475:     }
15475: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsIDOMNode interface
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::CloneNode(PRBool aDeep, nsIDOMNode** aReturn)
    1: {
    1:     // We don't allow cloning of a document
    1:     *aReturn = nsnull;
    1:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // Implementation methods
    1: //
    1: 
    1: nsresult
    1: nsXULDocument::Init()
    1: {
15475:     mRefMap.Init();
15475: 
    1:     nsresult rv = nsXMLDocument::Init();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Create our command dispatcher and hook it up.
   59:     mCommandDispatcher = new nsXULCommandDispatcher(this);
   59:     NS_ENSURE_TRUE(mCommandDispatcher, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     // this _could_ fail; e.g., if we've tried to grab the local store
    1:     // before profiles have initialized. If so, no big deal; nothing
    1:     // will persist.
 5691:     mLocalStore = do_GetService(NS_LOCALSTORE_CONTRACTID);
    1: 
    1:     if (gRefCnt++ == 0) {
    1:         // Keep the RDF service cached in a member variable to make using
    1:         // it a bit less painful
 5691:         rv = CallGetService("@mozilla.org/rdf/rdf-service;1", &gRDFService);
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "unable to get RDF Service");
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "persist"),
    1:                                  &kNC_persist);
    1:         gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "attribute"),
    1:                                  &kNC_attribute);
    1:         gRDFService->GetResource(NS_LITERAL_CSTRING(NC_NAMESPACE_URI "value"),
    1:                                  &kNC_value);
    1: 
    1:         // ensure that the XUL prototype cache is instantiated successfully,
    1:         // so that we can use nsXULPrototypeCache::GetInstance() without
    1:         // null-checks in the rest of the class.
    1:         nsXULPrototypeCache* cache = nsXULPrototypeCache::GetInstance();
    1:         if (!cache) {
    1:           NS_ERROR("Could not instantiate nsXULPrototypeCache");
    1:           return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1: 
30836:     nsContentUtils::RegisterPrefCallback("intl.uidirection.",
30836:                                          nsXULDocument::DirectionChanged,
30836:                                          this);
30836: 
    1: #ifdef PR_LOGGING
    1:     if (! gXULLog)
    1:         gXULLog = PR_NewLogModule("nsXULDocument");
    1: #endif
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::StartLayout(void)
    1: {
 1722:     nsPresShellIterator iter(this);
 1722:     nsCOMPtr<nsIPresShell> shell;
 1722:     while ((shell = iter.GetNextShell())) {
    1: 
    1:         // Resize-reflow this time
    1:         nsPresContext *cx = shell->GetPresContext();
    1:         NS_ASSERTION(cx != nsnull, "no pres context");
    1:         if (! cx)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         nsCOMPtr<nsISupports> container = cx->GetContainer();
    1:         NS_ASSERTION(container != nsnull, "pres context has no container");
    1:         if (! container)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(container));
    1:         NS_ASSERTION(docShell != nsnull, "container is not a docshell");
    1:         if (! docShell)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         // Trigger a refresh before the call to InitialReflow(),
    1:         // because the view manager's UpdateView() function is
    1:         // dropping dirty rects if refresh is disabled rather than
    1:         // accumulating them until refresh is enabled and then
    1:         // triggering a repaint...
 1416:         // XXXbz Is that still the case?
    1:         nsresult rv = NS_OK;
    1:         nsIViewManager* vm = shell->GetViewManager();
    1:         if (vm) {
    1:             nsCOMPtr<nsIContentViewer> contentViewer;
    1:             rv = docShell->GetContentViewer(getter_AddRefs(contentViewer));
    1:             if (NS_SUCCEEDED(rv) && (contentViewer != nsnull)) {
    1:                 PRBool enabled;
    1:                 contentViewer->GetEnableRendering(&enabled);
    1:                 if (enabled) {
    1:                     vm->EnableRefresh(NS_VMREFRESH_IMMEDIATE);
    1:                 }
    1:             }
    1:         }
    1: 
10474:         mMayStartLayout = PR_TRUE;
10474: 
22888:         // Don't try to call GetVisibleArea earlier than this --- the EnableRefresh call
22888:         // above can flush reflows, which can cause a parent document to be flushed,
22888:         // calling ResizeReflow on our document which does SetVisibleArea.
22888:         nsRect r = cx->GetVisibleArea();
 1416:         // Make sure we're holding a strong ref to |shell| before we call
 1416:         // InitialReflow()
 1416:         nsCOMPtr<nsIPresShell> shellGrip = shell;
    1:         rv = shell->InitialReflow(r.width, r.height);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* static */
    1: PRBool
    1: nsXULDocument::MatchAttribute(nsIContent* aContent,
    1:                               PRInt32 aNamespaceID,
    1:                               nsIAtom* aAttrName,
    1:                               void* aData)
    1: {
    1:     NS_PRECONDITION(aContent, "Must have content node to work with!");
 3233:     nsString* attrValue = static_cast<nsString*>(aData);
    1:     if (aNamespaceID != kNameSpaceID_Unknown &&
    1:         aNamespaceID != kNameSpaceID_Wildcard) {
    1:         return attrValue->EqualsLiteral("*") ?
    1:             aContent->HasAttr(aNamespaceID, aAttrName) :
    1:             aContent->AttrValueIs(aNamespaceID, aAttrName, *attrValue,
    1:                                   eCaseMatters);
    1:     }
    1: 
    1:     // Qualified name match. This takes more work.
    1: 
    1:     PRUint32 count = aContent->GetAttrCount();
    1:     for (PRUint32 i = 0; i < count; ++i) {
    1:         const nsAttrName* name = aContent->GetAttrNameAt(i);
    1:         PRBool nameMatch;
    1:         if (name->IsAtom()) {
    1:             nameMatch = name->Atom() == aAttrName;
    1:         } else if (aNamespaceID == kNameSpaceID_Wildcard) {
    1:             nameMatch = name->NodeInfo()->Equals(aAttrName);
    1:         } else {
    1:             nameMatch = name->NodeInfo()->QualifiedNameEquals(aAttrName);
    1:         }
    1: 
    1:         if (nameMatch) {
    1:             return attrValue->EqualsLiteral("*") ||
    1:                 aContent->AttrValueIs(name->NamespaceID(), name->LocalName(),
    1:                                       *attrValue, eCaseMatters);
    1:         }
    1:     }
    1: 
    1:     return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::PrepareToLoad(nsISupports* aContainer,
    1:                              const char* aCommand,
    1:                              nsIChannel* aChannel,
    1:                              nsILoadGroup* aLoadGroup,
    1:                              nsIParser** aResult)
    1: {
    1:     // Get the document's principal
    1:     nsCOMPtr<nsIPrincipal> principal;
    1:     nsContentUtils::GetSecurityManager()->
    1:         GetChannelPrincipal(aChannel, getter_AddRefs(principal));
    1:     return PrepareToLoadPrototype(mDocumentURI, aCommand, principal, aResult);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::PrepareToLoadPrototype(nsIURI* aURI, const char* aCommand,
    1:                                       nsIPrincipal* aDocumentPrincipal,
    1:                                       nsIParser** aResult)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Create a new prototype document.
    1:     rv = NS_NewXULPrototypeDocument(getter_AddRefs(mCurrentPrototype));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = mCurrentPrototype->InitPrincipal(aURI, aDocumentPrincipal);
    1:     if (NS_FAILED(rv)) {
    1:         mCurrentPrototype = nsnull;
    1:         return rv;
    1:     }    
    1: 
    1:     // Bootstrap the master document prototype.
    1:     if (! mMasterPrototype) {
    1:         mMasterPrototype = mCurrentPrototype;
    1:         // Set our principal based on the master proto.
    1:         SetPrincipal(aDocumentPrincipal);
    1:     }
    1: 
    1:     // Create a XUL content sink, a parser, and kick off a load for
    1:     // the overlay.
   64:     nsRefPtr<XULContentSinkImpl> sink = new XULContentSinkImpl();
   64:     if (!sink) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     rv = sink->Init(this, mCurrentPrototype);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Unable to initialize datasource sink");
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsCOMPtr<nsIParser> parser = do_CreateInstance(kParserCID, &rv);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "unable to create parser");
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     parser->SetCommand(nsCRT::strcmp(aCommand, "view-source") ? eViewNormal :
    1:                        eViewSource);
    1: 
    1:     parser->SetDocumentCharset(NS_LITERAL_CSTRING("UTF-8"),
    1:                                kCharsetFromDocTypeDefault);
    1:     parser->SetContentSink(sink); // grabs a reference to the parser
    1: 
    1:     *aResult = parser;
    1:     NS_ADDREF(*aResult);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::ApplyPersistentAttributes()
    1: {
20622:     // For non-chrome documents, persistance is simply broken
20622:     if (!IsCapabilityEnabled("UniversalBrowserRead"))
20622:         return NS_ERROR_NOT_AVAILABLE;
20622: 
    1:     // Add all of the 'persisted' attributes into the content
    1:     // model.
    1:     if (!mLocalStore)
    1:         return NS_OK;
    1: 
    1:     mApplyingPersistedAttrs = PR_TRUE;
20622:     ApplyPersistentAttributesInternal();
20622:     mApplyingPersistedAttrs = PR_FALSE;
20622: 
20622:     return NS_OK;
20622: }
20622: 
20622: 
20622: nsresult 
20622: nsXULDocument::ApplyPersistentAttributesInternal()
20622: {
    1:     nsCOMArray<nsIContent> elements;
    1: 
    1:     nsCAutoString docurl;
    1:     mDocumentURI->GetSpec(docurl);
    1: 
    1:     nsCOMPtr<nsIRDFResource> doc;
    1:     gRDFService->GetResource(docurl, getter_AddRefs(doc));
    1: 
    1:     nsCOMPtr<nsISimpleEnumerator> persisted;
    1:     mLocalStore->GetTargets(doc, kNC_persist, PR_TRUE, getter_AddRefs(persisted));
    1: 
    1:     while (1) {
    1:         PRBool hasmore = PR_FALSE;
    1:         persisted->HasMoreElements(&hasmore);
    1:         if (! hasmore)
    1:             break;
    1: 
    1:         nsCOMPtr<nsISupports> isupports;
    1:         persisted->GetNext(getter_AddRefs(isupports));
    1: 
    1:         nsCOMPtr<nsIRDFResource> resource = do_QueryInterface(isupports);
    1:         if (! resource) {
    1:             NS_WARNING("expected element to be a resource");
    1:             continue;
    1:         }
    1: 
    1:         const char *uri;
    1:         resource->GetValueConst(&uri);
    1:         if (! uri)
    1:             continue;
    1: 
    1:         nsAutoString id;
    1:         nsXULContentUtils::MakeElementID(this, nsDependentCString(uri), id);
    1: 
    1:         if (id.IsEmpty())
    1:             continue;
    1: 
    1:         // This will clear the array if there are no elements.
    1:         GetElementsForID(id, elements);
    1: 
    1:         if (!elements.Count())
    1:             continue;
    1: 
    1:         ApplyPersistentAttributesToElements(resource, elements);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::ApplyPersistentAttributesToElements(nsIRDFResource* aResource,
    1:                                                    nsCOMArray<nsIContent>& aElements)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsISimpleEnumerator> attrs;
    1:     rv = mLocalStore->ArcLabelsOut(aResource, getter_AddRefs(attrs));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     while (1) {
    1:         PRBool hasmore;
    1:         rv = attrs->HasMoreElements(&hasmore);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         if (! hasmore)
    1:             break;
    1: 
    1:         nsCOMPtr<nsISupports> isupports;
    1:         rv = attrs->GetNext(getter_AddRefs(isupports));
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         nsCOMPtr<nsIRDFResource> property = do_QueryInterface(isupports);
    1:         if (! property) {
    1:             NS_WARNING("expected a resource");
    1:             continue;
    1:         }
    1: 
    1:         const char* attrname;
    1:         rv = property->GetValueConst(&attrname);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         nsCOMPtr<nsIAtom> attr = do_GetAtom(attrname);
    1:         if (! attr)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         // XXX could hang namespace off here, as well...
    1: 
    1:         nsCOMPtr<nsIRDFNode> node;
    1:         rv = mLocalStore->GetTarget(aResource, property, PR_TRUE,
    1:                                     getter_AddRefs(node));
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         nsCOMPtr<nsIRDFLiteral> literal = do_QueryInterface(node);
    1:         if (! literal) {
    1:             NS_WARNING("expected a literal");
    1:             continue;
    1:         }
    1: 
    1:         const PRUnichar* value;
    1:         rv = literal->GetValueConst(&value);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         nsDependentString wrapper(value);
    1: 
    1:         PRUint32 cnt = aElements.Count();
    1: 
    1:         for (PRInt32 i = PRInt32(cnt) - 1; i >= 0; --i) {
    1:             nsCOMPtr<nsIContent> element = aElements.SafeObjectAt(i);
    1:             if (!element)
    1:                 continue;
    1: 
    1:             rv = element->SetAttr(/* XXX */ kNameSpaceID_None,
    1:                                   attr,
    1:                                   wrapper,
    1:                                   PR_TRUE);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULDocument::ContextStack
    1: //
    1: 
    1: nsXULDocument::ContextStack::ContextStack()
    1:     : mTop(nsnull), mDepth(0)
    1: {
    1: }
    1: 
    1: nsXULDocument::ContextStack::~ContextStack()
    1: {
    1:     while (mTop) {
    1:         Entry* doomed = mTop;
    1:         mTop = mTop->mNext;
    1:         NS_IF_RELEASE(doomed->mElement);
    1:         delete doomed;
    1:     }
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::ContextStack::Push(nsXULPrototypeElement* aPrototype,
    1:                                   nsIContent* aElement)
    1: {
    1:     Entry* entry = new Entry;
    1:     if (! entry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     entry->mPrototype = aPrototype;
    1:     entry->mElement   = aElement;
    1:     NS_IF_ADDREF(entry->mElement);
    1:     entry->mIndex     = 0;
    1: 
    1:     entry->mNext = mTop;
    1:     mTop = entry;
    1: 
    1:     ++mDepth;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::ContextStack::Pop()
    1: {
    1:     if (mDepth == 0)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     Entry* doomed = mTop;
    1:     mTop = mTop->mNext;
    1:     --mDepth;
    1: 
    1:     NS_IF_RELEASE(doomed->mElement);
    1:     delete doomed;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::ContextStack::Peek(nsXULPrototypeElement** aPrototype,
    1:                                            nsIContent** aElement,
    1:                                            PRInt32* aIndex)
    1: {
    1:     if (mDepth == 0)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     *aPrototype = mTop->mPrototype;
    1:     *aElement   = mTop->mElement;
    1:     NS_IF_ADDREF(*aElement);
    1:     *aIndex     = mTop->mIndex;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::ContextStack::SetTopIndex(PRInt32 aIndex)
    1: {
    1:     if (mDepth == 0)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     mTop->mIndex = aIndex;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsXULDocument::ContextStack::IsInsideXULTemplate()
    1: {
    1:     if (mDepth) {
    1:         for (nsIContent* element = mTop->mElement; element;
    1:              element = element->GetParent()) {
    1: 
    1:             if (element->NodeInfo()->Equals(nsGkAtoms::_template,
    1:                                             kNameSpaceID_XUL)) {
    1:                 return PR_TRUE;
    1:             }
    1:         }
    1:     }
    1:     return PR_FALSE;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // Content model walking routines
    1: //
    1: 
    1: nsresult
    1: nsXULDocument::PrepareToWalk()
    1: {
    1:     // Prepare to walk the mCurrentPrototype
    1:     nsresult rv;
    1: 
    1:     // Keep an owning reference to the prototype document so that its
    1:     // elements aren't yanked from beneath us.
    1:     mPrototypes.AppendElement(mCurrentPrototype);
    1: 
    1:     // Get the prototype's root element and initialize the context
    1:     // stack for the prototype walk.
    1:     nsXULPrototypeElement* proto = mCurrentPrototype->GetRootElement();
    1: 
    1:     if (! proto) {
    1: #ifdef PR_LOGGING
    1:         if (PR_LOG_TEST(gXULLog, PR_LOG_ERROR)) {
    1:             nsCOMPtr<nsIURI> url = mCurrentPrototype->GetURI();
    1: 
    1:             nsCAutoString urlspec;
    1:             rv = url->GetSpec(urlspec);
    1:             if (NS_FAILED(rv)) return rv;
    1: 
    1:             PR_LOG(gXULLog, PR_LOG_ERROR,
    1:                    ("xul: error parsing '%s'", urlspec.get()));
    1:         }
    1: #endif
    1: 
    1:         return NS_OK;
    1:     }
    1: 
    1:     PRUint32 piInsertionPoint = 0;
    1:     if (mState != eState_Master) {
    1:         piInsertionPoint = IndexOf(GetRootContent());
    1:         NS_ASSERTION(piInsertionPoint >= 0,
    1:                      "No root content when preparing to walk overlay!");
    1:     }
    1: 
20136:     const nsTArray<nsRefPtr<nsXULPrototypePI> >& processingInstructions =
    1:         mCurrentPrototype->GetProcessingInstructions();
    1: 
    1:     PRUint32 total = processingInstructions.Length();
    1:     for (PRUint32 i = 0; i < total; ++i) {
    1:         rv = CreateAndInsertPI(processingInstructions[i],
    1:                                this, piInsertionPoint + i);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     // Now check the chrome registry for any additional overlays.
    1:     rv = AddChromeOverlays();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Do one-time initialization if we're preparing to walk the
    1:     // master document's prototype.
    1:     nsCOMPtr<nsIContent> root;
    1: 
    1:     if (mState == eState_Master) {
    1:         // Add the root element
    1:         rv = CreateElementFromPrototype(proto, getter_AddRefs(root));
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         rv = AppendChildTo(root, PR_FALSE);
    1:         if (NS_FAILED(rv)) return rv;
    1:         
    1:         // Add the root element to the XUL document's ID-to-element map.
15475:         UpdateIdTableEntry(root);
15475:         rv = AddElementToRefMap(root);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         // Block onload until we've finished building the complete
    1:         // document content model.
    1:         BlockOnload();
    1:     }
    1: 
    1:     // There'd better not be anything on the context stack at this
    1:     // point! This is the basis case for our "induction" in
    1:     // ResumeWalk(), below, which'll assume that there's always a
    1:     // content element on the context stack if either 1) we're in the
    1:     // "master" document, or 2) we're in an overlay, and we've got
    1:     // more than one prototype element (the single, root "overlay"
    1:     // element) on the stack.
    1:     NS_ASSERTION(mContextStack.Depth() == 0, "something's on the context stack already");
    1:     if (mContextStack.Depth() != 0)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     rv = mContextStack.Push(proto, root);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::CreateAndInsertPI(const nsXULPrototypePI* aProtoPI,
    1:                                  nsINode* aParent, PRUint32 aIndex)
    1: {
    1:     NS_PRECONDITION(aProtoPI, "null ptr");
    1:     NS_PRECONDITION(aParent, "null ptr");
    1: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsIContent> node;
    1: 
    1:     rv = NS_NewXMLProcessingInstruction(getter_AddRefs(node),
    1:                                         mNodeInfoManager,
    1:                                         aProtoPI->mTarget,
    1:                                         aProtoPI->mData);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     if (aProtoPI->mTarget.EqualsLiteral("xml-stylesheet")) {
    1:         rv = InsertXMLStylesheetPI(aProtoPI, aParent, aIndex, node);
    1:     } else if (aProtoPI->mTarget.EqualsLiteral("xul-overlay")) {
    1:         rv = InsertXULOverlayPI(aProtoPI, aParent, aIndex, node);
    1:     } else {
    1:         // No special processing, just add the PI to the document.
    1:         rv = aParent->InsertChildAt(node, aIndex, PR_FALSE);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::InsertXMLStylesheetPI(const nsXULPrototypePI* aProtoPI,
    1:                                      nsINode* aParent,
    1:                                      PRUint32 aIndex,
    1:                                      nsIContent* aPINode)
    1: {
    1:     nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(aPINode));
    1:     NS_ASSERTION(ssle, "passed XML Stylesheet node does not "
    1:                        "implement nsIStyleSheetLinkingElement!");
    1: 
    1:     nsresult rv;
    1: 
  681:     ssle->InitStyleLinkElement(PR_FALSE);
    1:     // We want to be notified when the style sheet finishes loading, so
    1:     // disable style sheet loading for now.
    1:     ssle->SetEnableUpdates(PR_FALSE);
    1:     ssle->OverrideBaseURI(mCurrentPrototype->GetURI());
    1: 
    1:     rv = aParent->InsertChildAt(aPINode, aIndex, PR_FALSE);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     ssle->SetEnableUpdates(PR_TRUE);
    1: 
    1:     // load the stylesheet if necessary, passing ourselves as
    1:     // nsICSSObserver
  681:     PRBool willNotify;
  681:     PRBool isAlternate;
  681:     rv = ssle->UpdateStyleSheet(this, &willNotify, &isAlternate);
  681:     if (NS_SUCCEEDED(rv) && willNotify && !isAlternate) {
    1:         ++mPendingSheets;
    1:     }
    1: 
  682:     // Ignore errors from UpdateStyleSheet; we don't want failure to
  682:     // do that to break the XUL document load.  But do propagate out
  682:     // NS_ERROR_OUT_OF_MEMORY.
  682:     if (rv == NS_ERROR_OUT_OF_MEMORY) {
    1:         return rv;
    1:     }
    1:     
  682:     return NS_OK;
  682: }
  682: 
    1: nsresult
    1: nsXULDocument::InsertXULOverlayPI(const nsXULPrototypePI* aProtoPI,
    1:                                   nsINode* aParent,
    1:                                   PRUint32 aIndex,
    1:                                   nsIContent* aPINode)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = aParent->InsertChildAt(aPINode, aIndex, PR_FALSE);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // xul-overlay PI is special only in prolog
    1:     if (!nsContentUtils::InProlog(aPINode)) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsAutoString href;
    1:     nsParserUtils::GetQuotedAttributeValue(aProtoPI->mData,
    1:                                            nsGkAtoms::href,
    1:                                            href);
    1: 
    1:     // If there was no href, we can't do anything with this PI
    1:     if (href.IsEmpty()) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Add the overlay to our list of overlays that need to be processed.
    1:     nsCOMPtr<nsIURI> uri;
    1: 
    1:     rv = NS_NewURI(getter_AddRefs(uri), href, nsnull,
    1:                    mCurrentPrototype->GetURI());
    1:     if (NS_SUCCEEDED(rv)) {
    1:         // We insert overlays into mUnloadedOverlays at the same index in
    1:         // document order, so they end up in the reverse of the document
    1:         // order in mUnloadedOverlays.
    1:         // This is needed because the code in ResumeWalk loads the overlays
    1:         // by processing the last item of mUnloadedOverlays and removing it
    1:         // from the array.
    1:         rv = mUnloadedOverlays.InsertObjectAt(uri, 0);
    1:     } else if (rv == NS_ERROR_MALFORMED_URI) {
    1:         // The URL is bad, move along. Don't propagate for now.
    1:         // XXX report this to the Error Console (bug 359846)
    1:         rv = NS_OK;
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::AddChromeOverlays()
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIURI> docUri = mCurrentPrototype->GetURI();
    1: 
    1:     /* overlays only apply to chrome, skip all content URIs */
    1:     if (!IsChromeURI(docUri)) return NS_OK;
    1: 
    1:     nsCOMPtr<nsIXULOverlayProvider> chromeReg(do_GetService(NS_CHROMEREGISTRY_CONTRACTID));
    1:     // In embedding situations, the chrome registry may not provide overlays,
    1:     // or even exist at all; that's OK.
    1:     NS_ENSURE_TRUE(chromeReg, NS_OK);
    1: 
    1:     nsCOMPtr<nsISimpleEnumerator> overlays;
    1:     rv = chromeReg->GetXULOverlays(docUri, getter_AddRefs(overlays));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRBool moreOverlays;
    1:     nsCOMPtr<nsISupports> next;
    1:     nsCOMPtr<nsIURI> uri;
    1: 
    1:     while (NS_SUCCEEDED(rv = overlays->HasMoreElements(&moreOverlays)) &&
    1:            moreOverlays) {
    1: 
    1:         rv = overlays->GetNext(getter_AddRefs(next));
    1:         if (NS_FAILED(rv) || !next) break;
    1: 
    1:         uri = do_QueryInterface(next);
    1:         if (!uri) {
    1:             NS_ERROR("Chrome registry handed me a non-nsIURI object!");
    1:             continue;
    1:         }
    1: 
    1:         // Same comment as in nsXULDocument::InsertXULOverlayPI
    1:         rv = mUnloadedOverlays.InsertObjectAt(uri, 0);
    1:         if (NS_FAILED(rv)) break;
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::LoadOverlay(const nsAString& aURL, nsIObserver* aObserver)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     rv = NS_NewURI(getter_AddRefs(uri), aURL, nsnull);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     if (aObserver) {
    1:         nsIObserver* obs = nsnull;
    1:         NS_ENSURE_TRUE(mOverlayLoadObservers.IsInitialized() || mOverlayLoadObservers.Init(), 
    1:                        NS_ERROR_OUT_OF_MEMORY);
    1:         
    1:         obs = mOverlayLoadObservers.GetWeak(uri);
    1: 
    1:         if (obs) {
    1:             // We don't support loading the same overlay twice into the same
    1:             // document - that doesn't make sense anyway.
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:         mOverlayLoadObservers.Put(uri, aObserver);
    1:     }
    1:     PRBool shouldReturn, failureFromContent;
    1:     rv = LoadOverlayInternal(uri, PR_TRUE, &shouldReturn, &failureFromContent);
    1:     if (NS_FAILED(rv) && mOverlayLoadObservers.IsInitialized())
    1:         mOverlayLoadObservers.Remove(uri); // remove the observer if LoadOverlayInternal generated an error
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::LoadOverlayInternal(nsIURI* aURI, PRBool aIsDynamic,
    1:                                    PRBool* aShouldReturn,
    1:                                    PRBool* aFailureFromContent)
    1: {
    1:     nsresult rv;
    1: 
    1:     *aShouldReturn = PR_FALSE;
    1:     *aFailureFromContent = PR_FALSE;
    1: 
    1: #ifdef PR_LOGGING
    1:     if (PR_LOG_TEST(gXULLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString urlspec;
    1:         aURI->GetSpec(urlspec);
    1: 
    1:         PR_LOG(gXULLog, PR_LOG_DEBUG,
    1:                 ("xul: loading overlay %s", urlspec.get()));
    1:     }
    1: #endif
    1: 
    1:     if (aIsDynamic)
    1:         mResolutionPhase = nsForwardReference::eStart;
    1: 
    1:     // Chrome documents are allowed to load overlays from anywhere.
    1:     // In all other cases, the overlay is only allowed to load if
    1:     // the master document and prototype document have the same origin.
    1: 
11882:     if (!IsChromeURI(mDocumentURI)) {
    1:         // Make sure we're allowed to load this overlay.
12321:         rv = NodePrincipal()->CheckMayLoad(aURI, PR_TRUE);
    1:         if (NS_FAILED(rv)) {
    1:             *aFailureFromContent = PR_TRUE;
    1:             return rv;
    1:         }
    1:     }
    1: 
    1:     // Look in the prototype cache for the prototype document with
    1:     // the specified overlay URI.
11882:     PRBool overlayIsChrome = IsChromeURI(aURI);
    1:     mCurrentPrototype = overlayIsChrome ?
    1:         nsXULPrototypeCache::GetInstance()->GetPrototype(aURI) : nsnull;
    1: 
    1:     // Same comment as nsChromeProtocolHandler::NewChannel and
    1:     // nsXULDocument::StartDocumentLoad
    1:     // - Ben Goodger
    1:     //
    1:     // We don't abort on failure here because there are too many valid
    1:     // cases that can return failure, and the null-ness of |proto| is
    1:     // enough to trigger the fail-safe parse-from-disk solution.
    1:     // Example failure cases (for reference) include:
    1:     //
    1:     // NS_ERROR_NOT_AVAILABLE: the URI was not found in the FastLoad file,
    1:     //                         parse from disk
    1:     // other: the FastLoad file, XUL.mfl, could not be found, probably
    1:     //        due to being accessed before a profile has been selected
    1:     //        (e.g. loading chrome for the profile manager itself).
    1:     //        The .xul file must be parsed from disk.
    1: 
    1:     PRBool useXULCache = nsXULPrototypeCache::GetInstance()->IsEnabled();
    1:     if (aIsDynamic)
    1:         mIsWritingFastLoad = useXULCache;
    1: 
    1:     if (useXULCache && mCurrentPrototype) {
    1:         PRBool loaded;
    1:         rv = mCurrentPrototype->AwaitLoadDone(this, &loaded);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         if (! loaded) {
    1:             // Return to the main event loop and eagerly await the
    1:             // prototype overlay load's completion. When the content
    1:             // sink completes, it will trigger an EndLoad(), which'll
    1:             // wind us back up here, in ResumeWalk().
    1:             *aShouldReturn = PR_TRUE;
    1:             return NS_OK;
    1:         }
    1: 
    1:         PR_LOG(gXULLog, PR_LOG_DEBUG, ("xul: overlay was cached"));
    1: 
    1:         // Found the overlay's prototype in the cache, fully loaded. If
    1:         // this is a dynamic overlay, this will call ResumeWalk.
    1:         // Otherwise, we'll return to ResumeWalk, which called us.
    1:         return OnPrototypeLoadDone(aIsDynamic);
    1:     }
    1:     else {
    1:         // Not there. Initiate a load.
    1:         PR_LOG(gXULLog, PR_LOG_DEBUG, ("xul: overlay was not cached"));
    1: 
 3349:         // We'll set the right principal on the proto doc when we get
 3349:         // OnStartRequest from the parser, so just pass in a null principal for
 3349:         // now.
    1:         nsCOMPtr<nsIParser> parser;
    1:         rv = PrepareToLoadPrototype(aURI, "view", nsnull, getter_AddRefs(parser));
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         // Predicate mIsWritingFastLoad on the XUL cache being enabled,
    1:         // so we don't have to re-check whether the cache is enabled all
    1:         // the time.
    1:         mIsWritingFastLoad = useXULCache;
    1: 
    1:         nsCOMPtr<nsIStreamListener> listener = do_QueryInterface(parser);
    1:         if (! listener)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         // Add an observer to the parser; this'll get called when
    1:         // Necko fires its On[Start|Stop]Request() notifications,
    1:         // and will let us recover from a missing overlay.
 3349:         ParserObserver* parserObserver =
 3349:             new ParserObserver(this, mCurrentPrototype);
    1:         if (! parserObserver)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         NS_ADDREF(parserObserver);
    1:         parser->Parse(aURI, parserObserver);
    1:         NS_RELEASE(parserObserver);
    1: 
    1:         nsCOMPtr<nsILoadGroup> group = do_QueryReferent(mDocumentLoadGroup);
    1:         rv = NS_OpenURI(listener, nsnull, aURI, nsnull, group);
    1:         if (NS_FAILED(rv)) {
    1:             // Abandon this prototype
    1:             mCurrentPrototype = nsnull;
    1: 
    1:             // The parser won't get an OnStartRequest and
    1:             // OnStopRequest, so it needs a Terminate.
    1:             parser->Terminate();
    1: 
    1:             // Just move on to the next overlay.  NS_OpenURI could fail
    1:             // just because a channel could not be opened, which can happen
    1:             // if a file or chrome package does not exist.
    1:             ReportMissingOverlay(aURI);
    1:             
    1:             // XXX the error could indicate an internal error as well...
    1:             *aFailureFromContent = PR_TRUE;
    1:             return rv;
    1:         }
    1: 
    1:         // If it's a 'chrome:' prototype document, then put it into
    1:         // the prototype cache; other XUL documents will be reloaded
    1:         // each time.  We must do this after NS_OpenURI and AsyncOpen,
    1:         // or chrome code will wrongly create a cached chrome channel
    1:         // instead of a real one.
    1:         if (useXULCache && overlayIsChrome) {
    1:             nsXULPrototypeCache::GetInstance()->PutPrototype(mCurrentPrototype);
    1:         }
    1: 
    1:         // Return to the main event loop and eagerly await the
    1:         // overlay load's completion. When the content sink
    1:         // completes, it will trigger an EndLoad(), which'll wind
    1:         // us back in ResumeWalk().
    1:         if (!aIsDynamic)
    1:             *aShouldReturn = PR_TRUE;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
20261: static PLDHashOperator
    1: FirePendingMergeNotification(nsIURI* aKey, nsCOMPtr<nsIObserver>& aObserver, void* aClosure)
    1: {
    1:     aObserver->Observe(aKey, "xul-overlay-merged", EmptyString().get());
    1: 
    1:     typedef nsInterfaceHashtable<nsURIHashKey,nsIObserver> table;
 3233:     table* observers = static_cast<table*>(aClosure);
    1:     observers->Remove(aKey);
    1: 
    1:     return PL_DHASH_REMOVE;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::ResumeWalk()
    1: {
    1:     // Walk the prototype and build the delegate content model. The
    1:     // walk is performed in a top-down, left-to-right fashion. That
    1:     // is, a parent is built before any of its children; a node is
    1:     // only built after all of its siblings to the left are fully
    1:     // constructed.
    1:     //
    1:     // It is interruptable so that transcluded documents (e.g.,
    1:     // <html:script src="..." />) can be properly re-loaded if the
    1:     // cached copy of the document becomes stale.
    1:     nsresult rv;
34644:     nsCOMPtr<nsIURI> overlayURI =
34644:         mCurrentPrototype ? mCurrentPrototype->GetURI() : nsnull;
    1: 
    1:     while (1) {
    1:         // Begin (or resume) walking the current prototype.
    1: 
    1:         while (mContextStack.Depth() > 0) {
    1:             // Look at the top of the stack to determine what we're
    1:             // currently working on.
    1:             // This will always be a node already constructed and
    1:             // inserted to the actual document.
    1:             nsXULPrototypeElement* proto;
    1:             nsCOMPtr<nsIContent> element;
    1:             PRInt32 indx; // all children of proto before indx (not
    1:                           // inclusive) have already been constructed
    1:             rv = mContextStack.Peek(&proto, getter_AddRefs(element), &indx);
    1:             if (NS_FAILED(rv)) return rv;
    1: 
20136:             if (indx >= (PRInt32)proto->mChildren.Length()) {
    1:                 if (element) {
    1:                     // We've processed all of the prototype's children. If
    1:                     // we're in the master prototype, do post-order
    1:                     // document-level hookup. (An overlay will get its
    1:                     // document hookup done when it's successfully
    1:                     // resolved.)
    1:                     if (mState == eState_Master) {
    1:                         AddElementToDocumentPost(element);
   65: 
   65:                         if (element->NodeInfo()->Equals(nsGkAtoms::style,
   65:                                                         kNameSpaceID_XHTML) ||
   65:                             element->NodeInfo()->Equals(nsGkAtoms::style,
   65:                                                         kNameSpaceID_SVG)) {
   65:                             // XXX sucks that we have to do this -
   65:                             // see bug 370111
   65:                             nsCOMPtr<nsIStyleSheetLinkingElement> ssle =
   65:                                 do_QueryInterface(element);
   65:                             NS_ASSERTION(ssle, "<html:style> doesn't implement "
   65:                                                "nsIStyleSheetLinkingElement?");
  681:                             PRBool willNotify;
  681:                             PRBool isAlternate;
  681:                             ssle->UpdateStyleSheet(nsnull, &willNotify,
  681:                                                    &isAlternate);
   65:                         }
    1:                     }
    1: 
    1: #ifdef MOZ_XTF
    1:                     if (element->GetNameSpaceID() > kNameSpaceID_LastBuiltin) {
    1:                         element->DoneAddingChildren(PR_FALSE);
    1:                     }
    1: #endif
    1:                 }
    1:                 // Now pop the context stack back up to the parent
    1:                 // element and continue the prototype walk.
    1:                 mContextStack.Pop();
    1:                 continue;
    1:             }
    1: 
    1:             // Grab the next child, and advance the current context stack
    1:             // to the next sibling to our right.
    1:             nsXULPrototypeNode* childproto = proto->mChildren[indx];
    1:             mContextStack.SetTopIndex(++indx);
    1: 
    1:             // Whether we're in the "first ply" of an overlay:
    1:             // the "hookup" nodes. In the case !processingOverlayHookupNodes,
    1:             // we're in the master document -or- we're in an overlay, and far
    1:             // enough down into the overlay's content that we can simply build
    1:             // the delegates and attach them to the parent node.
    1:             PRBool processingOverlayHookupNodes = (mState == eState_Overlay) && 
    1:                                                   (mContextStack.Depth() == 1);
    1: 
    1:             NS_ASSERTION(element || processingOverlayHookupNodes,
    1:                          "no element on context stack");
    1: 
    1:             switch (childproto->mType) {
    1:             case nsXULPrototypeNode::eType_Element: {
    1:                 // An 'element', which may contain more content.
    1:                 nsXULPrototypeElement* protoele =
 3233:                     static_cast<nsXULPrototypeElement*>(childproto);
    1: 
    1:                 nsCOMPtr<nsIContent> child;
    1: 
    1:                 if (!processingOverlayHookupNodes) {
    1:                     rv = CreateElementFromPrototype(protoele,
    1:                                                     getter_AddRefs(child));
    1:                     if (NS_FAILED(rv)) return rv;
    1: 
    1:                     // ...and append it to the content model.
    1:                     rv = element->AppendChildTo(child, PR_FALSE);
    1:                     if (NS_FAILED(rv)) return rv;
    1: 
    1:                     // do pre-order document-level hookup, but only if
    1:                     // we're in the master document. For an overlay,
    1:                     // this will happen when the overlay is
    1:                     // successfully resolved.
    1:                     if (mState == eState_Master)
    1:                         AddElementToDocumentPre(child);
    1:                 }
    1:                 else {
    1:                     // We're in the "first ply" of an overlay: the
    1:                     // "hookup" nodes. Create an 'overlay' element so
    1:                     // that we can continue to build content, and
    1:                     // enter a forward reference so we can hook it up
    1:                     // later.
    1:                     rv = CreateOverlayElement(protoele, getter_AddRefs(child));
    1:                     if (NS_FAILED(rv)) return rv;
    1:                 }
    1: 
    1:                 // If it has children, push the element onto the context
    1:                 // stack and begin to process them.
20136:                 if (protoele->mChildren.Length() > 0) {
    1:                     rv = mContextStack.Push(protoele, child);
    1:                     if (NS_FAILED(rv)) return rv;
    1:                 }
    1:                 else {
    1:                     if (mState == eState_Master) {
    1:                         // If there are no children, and we're in the
    1:                         // master document, do post-order document hookup
    1:                         // immediately.
    1:                         AddElementToDocumentPost(child);
    1:                     }
    1: #ifdef MOZ_XTF
    1:                     if (child &&
    1:                         child->GetNameSpaceID() > kNameSpaceID_LastBuiltin) {
    1:                         child->DoneAddingChildren(PR_FALSE);
    1:                     }
    1: #endif
    1:                 }
    1:             }
    1:             break;
    1: 
    1:             case nsXULPrototypeNode::eType_Script: {
    1:                 // A script reference. Execute the script immediately;
    1:                 // this may have side effects in the content model.
    1:                 nsXULPrototypeScript* scriptproto =
 3233:                     static_cast<nsXULPrototypeScript*>(childproto);
    1: 
    1:                 if (scriptproto->mSrcURI) {
    1:                     // A transcluded script reference; this may
    1:                     // "block" our prototype walk if the script isn't
    1:                     // cached, or the cached copy of the script is
    1:                     // stale and must be reloaded.
    1:                     PRBool blocked;
    1:                     rv = LoadScript(scriptproto, &blocked);
    1:                     // If the script cannot be loaded, just keep going!
    1: 
    1:                     if (NS_SUCCEEDED(rv) && blocked)
    1:                         return NS_OK;
    1:                 }
    1:                 else if (scriptproto->mScriptObject.mObject) {
    1:                     // An inline script
    1:                     rv = ExecuteScript(scriptproto);
    1:                     if (NS_FAILED(rv)) return rv;
    1:                 }
    1:             }
    1:             break;
    1: 
    1:             case nsXULPrototypeNode::eType_Text: {
    1:                 // A simple text node.
    1: 
    1:                 if (!processingOverlayHookupNodes) {
    1:                     // This does mean that text nodes that are direct children
    1:                     // of <overlay> get ignored.
    1: 
    1:                     nsCOMPtr<nsIContent> text;
    1:                     rv = NS_NewTextNode(getter_AddRefs(text),
    1:                                         mNodeInfoManager);
    1:                     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:                     nsXULPrototypeText* textproto =
 3233:                         static_cast<nsXULPrototypeText*>(childproto);
    1:                     text->SetText(textproto->mValue, PR_FALSE);
    1: 
    1:                     rv = element->AppendChildTo(text, PR_FALSE);
    1:                     NS_ENSURE_SUCCESS(rv, rv);
    1:                 }
    1:             }
    1:             break;
    1: 
    1:             case nsXULPrototypeNode::eType_PI: {
    1:                 nsXULPrototypePI* piProto =
 3233:                     static_cast<nsXULPrototypePI*>(childproto);
    1: 
    1:                 // <?xul-overlay?> and <?xml-stylesheet?> don't have effect
    1:                 // outside the prolog, like they used to. Issue a warning.
    1: 
    1:                 if (piProto->mTarget.EqualsLiteral("xml-stylesheet") ||
    1:                     piProto->mTarget.EqualsLiteral("xul-overlay")) {
    1: 
    1:                     const PRUnichar* params[] = { piProto->mTarget.get() };
    1: 
    1:                     nsContentUtils::ReportToConsole(
    1:                                         nsContentUtils::eXUL_PROPERTIES,
    1:                                         "PINotInProlog",
    1:                                         params, NS_ARRAY_LENGTH(params),
    1:                                         overlayURI,
    1:                                         EmptyString(), /* source line */
    1:                                         0, /* line number */
    1:                                         0, /* column number */
    1:                                         nsIScriptError::warningFlag,
    1:                                         "XUL Document");
    1:                 }
    1: 
    1:                 nsIContent* parent = processingOverlayHookupNodes ?
    1:                     GetRootContent() : element.get();
    1: 
    1:                 if (parent) {
    1:                     // an inline script could have removed the root element
    1:                     rv = CreateAndInsertPI(piProto, parent,
    1:                                            parent->GetChildCount());
    1:                     NS_ENSURE_SUCCESS(rv, rv);
    1:                 }
    1:             }
    1:             break;
    1: 
    1:             default:
    1:                 NS_NOTREACHED("Unexpected nsXULPrototypeNode::Type value");
    1:             }
    1:         }
    1: 
    1:         // Once we get here, the context stack will have been
    1:         // depleted. That means that the entire prototype has been
    1:         // walked and content has been constructed.
    1: 
    1:         // If we're not already, mark us as now processing overlays.
    1:         mState = eState_Overlay;
    1: 
    1:         // If there are no overlay URIs, then we're done.
    1:         PRUint32 count = mUnloadedOverlays.Count();
    1:         if (! count)
    1:             break;
    1: 
    1:         nsCOMPtr<nsIURI> uri = mUnloadedOverlays[count-1];
    1:         mUnloadedOverlays.RemoveObjectAt(count-1);
    1: 
    1:         PRBool shouldReturn, failureFromContent;
    1:         rv = LoadOverlayInternal(uri, PR_FALSE, &shouldReturn,
    1:                                  &failureFromContent);
    1:         if (failureFromContent)
    1:             // The failure |rv| was the result of a problem in the content
    1:             // rather than an unexpected problem in our implementation, so
    1:             // just continue with the next overlay.
    1:             continue;
    1:         if (NS_FAILED(rv))
    1:             return rv;
12618:         if (mOverlayLoadObservers.IsInitialized()) {
12618:             nsIObserver *obs = mOverlayLoadObservers.GetWeak(overlayURI);
12618:             if (obs) {
12618:                 // This overlay has an unloaded overlay, so it will never
12618:                 // notify. The best we can do is to notify for the unloaded
12618:                 // overlay instead, assuming nobody is already notifiable
12618:                 // for it. Note that this will confuse the observer.
12618:                 if (!mOverlayLoadObservers.GetWeak(uri))
12618:                     mOverlayLoadObservers.Put(uri, obs);
12618:                 mOverlayLoadObservers.Remove(overlayURI);
12618:             }
12618:         }
12460:         if (shouldReturn)
    1:             return NS_OK;
12618:         overlayURI.swap(uri);
    1:     }
    1: 
    1:     // If we get here, there is nothing left for us to walk. The content
    1:     // model is built and ready for layout.
    1:     rv = ResolveForwardReferences();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
20622:     ApplyPersistentAttributes();
    1: 
    1:     mStillWalking = PR_FALSE;
    1:     if (mPendingSheets == 0) {
    1:         rv = DoneWalking();
    1:     }
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::DoneWalking()
    1: {
    1:     NS_PRECONDITION(mPendingSheets == 0, "there are sheets to be loaded");
    1:     NS_PRECONDITION(!mStillWalking, "walk not done");
    1: 
    1:     // XXXldb This is where we should really be setting the chromehidden
    1:     // attribute.
    1: 
    1:     PRUint32 count = mOverlaySheets.Count();
    1:     for (PRUint32 i = 0; i < count; ++i) {
    1:         AddStyleSheet(mOverlaySheets[i]);
    1:     }
    1:     mOverlaySheets.Clear();
    1: 
    1:     if (!mDocumentLoaded) {
    1:         // Make sure we don't reenter here from StartLayout().  Note that
    1:         // setting mDocumentLoaded to true here means that if StartLayout()
    1:         // causes ResumeWalk() to be reentered, we'll take the other branch of
    1:         // the |if (!mDocumentLoaded)| check above and since
    1:         // mInitialLayoutComplete will be false will follow the else branch
    1:         // there too.  See the big comment there for how such reentry can
    1:         // happen.
    1:         mDocumentLoaded = PR_TRUE;
    1: 
16977:         NotifyPossibleTitleChange(PR_FALSE);
    1: 
    1:         // Before starting layout, check whether we're a toplevel chrome
    1:         // window.  If we are, set our chrome flags now, so that we don't have
    1:         // to restyle the whole frame tree after StartLayout.
    1:         nsCOMPtr<nsISupports> container = GetContainer();
    1:         nsCOMPtr<nsIDocShellTreeItem> item = do_QueryInterface(container);
    1:         if (item) {
    1:             nsCOMPtr<nsIDocShellTreeOwner> owner;
    1:             item->GetTreeOwner(getter_AddRefs(owner));
    1:             nsCOMPtr<nsIXULWindow> xulWin = do_GetInterface(owner);
    1:             if (xulWin) {
    1:                 nsCOMPtr<nsIDocShell> xulWinShell;
    1:                 xulWin->GetDocShell(getter_AddRefs(xulWinShell));
    1:                 if (SameCOMIdentity(xulWinShell, container)) {
    1:                     // We're the chrome document!  Apply our chrome flags now.
    1:                     xulWin->ApplyChromeFlags();
    1:                 }
    1:             }
    1:         }
    1: 
    1:         StartLayout();
    1: 
    1:         if (mIsWritingFastLoad && IsChromeURI(mDocumentURI))
    1:             nsXULPrototypeCache::GetInstance()->WritePrototype(mMasterPrototype);
    1: 
14464:         NS_ASSERTION(mDelayFrameLoaderInitialization,
14464:                      "mDelayFrameLoaderInitialization should be true!");
14464:         mDelayFrameLoaderInitialization = PR_FALSE;
14464:         NS_WARN_IF_FALSE(mUpdateNestLevel == 0,
14464:                          "Constructing XUL document in middle of an update?");
14464:         if (mUpdateNestLevel == 0) {
24482:             MaybeInitializeFinalizeFrameLoaders();
14464:         }
14464: 
    1:         NS_DOCUMENT_NOTIFY_OBSERVERS(EndLoad, (this));
    1: 
 6205:         // DispatchContentLoadedEvents undoes the onload-blocking we
 6205:         // did in PrepareToWalk().
    1:         DispatchContentLoadedEvents();
    1: 
    1:         mInitialLayoutComplete = PR_TRUE;
    1: 
    1:         // Walk the set of pending load notifications and notify any observers.
    1:         // See below for detail.
    1:         if (mPendingOverlayLoadNotifications.IsInitialized())
    1:             mPendingOverlayLoadNotifications.Enumerate(FirePendingMergeNotification, (void*)&mOverlayLoadObservers);
    1:     }
    1:     else {
    1:         if (mOverlayLoadObservers.IsInitialized()) {
    1:             nsCOMPtr<nsIURI> overlayURI = mCurrentPrototype->GetURI();
    1:             nsCOMPtr<nsIObserver> obs;
    1:             if (mInitialLayoutComplete) {
    1:                 // We have completed initial layout, so just send the notification.
    1:                 mOverlayLoadObservers.Get(overlayURI, getter_AddRefs(obs));
    1:                 if (obs)
    1:                     obs->Observe(overlayURI, "xul-overlay-merged", EmptyString().get());
    1:                 mOverlayLoadObservers.Remove(overlayURI);
    1:             }
    1:             else {
    1:                 // If we have not yet displayed the document for the first time 
    1:                 // (i.e. we came in here as the result of a dynamic overlay load
    1:                 // which was spawned by a binding-attached event caused by 
    1:                 // StartLayout() on the master prototype - we must remember that
    1:                 // this overlay has been merged and tell the listeners after 
    1:                 // StartLayout() is completely finished rather than doing so 
    1:                 // immediately - otherwise we may be executing code that needs to
    1:                 // access XBL Binding implementations on nodes for which frames 
    1:                 // have not yet been constructed because their bindings have not
    1:                 // yet been attached. This can be a race condition because dynamic
    1:                 // overlay loading can take varying amounts of time depending on
    1:                 // whether or not the overlay prototype is in the XUL cache. The
    1:                 // most likely effect of this bug is odd UI initialization due to
    1:                 // methods and properties that do not work.
    1:                 // XXXbz really, we shouldn't be firing binding constructors
    1:                 // until after StartLayout returns!
    1: 
    1:                 NS_ENSURE_TRUE(mPendingOverlayLoadNotifications.IsInitialized() || mPendingOverlayLoadNotifications.Init(), 
    1:                                NS_ERROR_OUT_OF_MEMORY);
    1:                 
    1:                 mPendingOverlayLoadNotifications.Get(overlayURI, getter_AddRefs(obs));
    1:                 if (!obs) {
    1:                     mOverlayLoadObservers.Get(overlayURI, getter_AddRefs(obs));
    1:                     NS_ASSERTION(obs, "null overlay load observer?");
    1:                     mPendingOverlayLoadNotifications.Put(overlayURI, obs);
    1:                 }
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::StyleSheetLoaded(nsICSSStyleSheet* aSheet,
    1:                                 PRBool aWasAlternate,
    1:                                 nsresult aStatus)
    1: {
    1:     if (!aWasAlternate) {
    1:         // Don't care about when alternate sheets finish loading
    1: 
    1:         NS_ASSERTION(mPendingSheets > 0,
    1:             "Unexpected StyleSheetLoaded notification");
    1: 
    1:         --mPendingSheets;
    1: 
    1:         if (!mStillWalking && mPendingSheets == 0) {
    1:             return DoneWalking();
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
24482: nsXULDocument::MaybeBroadcast()
19296: {
24482:     // Only broadcast when not in an update and when safe to run scripts.
24482:     if (mUpdateNestLevel == 0 &&
24482:         (mDelayedAttrChangeBroadcasts.Length() ||
24482:          mDelayedBroadcasters.Length())) {
24482:         if (!nsContentUtils::IsSafeToRunScript()) {
24482:             if (!mInDestructor) {
24482:                 nsContentUtils::AddScriptRunner(
24482:                   NS_NEW_RUNNABLE_METHOD(nsXULDocument, this, MaybeBroadcast));
24482:             }
24482:             return;
24482:         }
23408:         if (!mHandlingDelayedAttrChange) {
23408:             mHandlingDelayedAttrChange = PR_TRUE;
23408:             for (PRUint32 i = 0; i < mDelayedAttrChangeBroadcasts.Length(); ++i) {
23408:                 nsIAtom* attrName = mDelayedAttrChangeBroadcasts[i].mAttrName;
23408:                 if (mDelayedAttrChangeBroadcasts[i].mNeedsAttrChange) {
22228:                     nsCOMPtr<nsIContent> listener =
23408:                         do_QueryInterface(mDelayedAttrChangeBroadcasts[i].mListener);
23408:                     nsString value = mDelayedAttrChangeBroadcasts[i].mAttr;
23408:                     if (mDelayedAttrChangeBroadcasts[i].mSetAttr) {
22228:                         listener->SetAttr(kNameSpaceID_None, attrName, value,
22228:                                           PR_TRUE);
22938:                     } else {
22228:                         listener->UnsetAttr(kNameSpaceID_None, attrName,
22228:                                             PR_TRUE);
22228:                     }
22938:                 }
22228:                 nsCOMPtr<nsIContent> broadcaster =
23408:                     do_QueryInterface(mDelayedAttrChangeBroadcasts[i].mBroadcaster);
22228:                 ExecuteOnBroadcastHandlerFor(broadcaster,
23408:                                              mDelayedAttrChangeBroadcasts[i].mListener,
22228:                                              attrName);
22228:             }
23408:             mDelayedAttrChangeBroadcasts.Clear();
23408:             mHandlingDelayedAttrChange = PR_FALSE;
23408:         }
23408: 
23408:         PRUint32 length = mDelayedBroadcasters.Length();
19296:         if (length) {
32080:             PRBool oldValue = mHandlingDelayedBroadcasters;
32080:             mHandlingDelayedBroadcasters = PR_TRUE;
19296:             nsTArray<nsDelayedBroadcastUpdate> delayedBroadcasters;
19296:             mDelayedBroadcasters.SwapElements(delayedBroadcasters);
19296:             for (PRUint32 i = 0; i < length; ++i) {
19296:                 SynchronizeBroadcastListener(delayedBroadcasters[i].mBroadcaster,
19296:                                              delayedBroadcasters[i].mListener,
19296:                                              delayedBroadcasters[i].mAttr);
19296:             }
32080:             mHandlingDelayedBroadcasters = oldValue;
19296:         }
19296:     }
19296: }
19296: 
19296: void
24482: nsXULDocument::EndUpdate(nsUpdateType aUpdateType)
24482: {
24482:     nsXMLDocument::EndUpdate(aUpdateType);
24482: 
24482:     MaybeBroadcast();
24482: }
24482: 
24482: void
    1: nsXULDocument::ReportMissingOverlay(nsIURI* aURI)
    1: {
    1:     NS_PRECONDITION(aURI, "Must have a URI");
    1:     
    1:     nsCAutoString spec;
    1:     aURI->GetSpec(spec);
    1: 
    1:     NS_ConvertUTF8toUTF16 utfSpec(spec);
    1:     const PRUnichar* params[] = { utfSpec.get() };
    1: 
    1:     nsContentUtils::ReportToConsole(nsContentUtils::eXUL_PROPERTIES,
    1:                                     "MissingOverlay",
    1:                                     params, NS_ARRAY_LENGTH(params),
    1:                                     mDocumentURI,
    1:                                     EmptyString(), /* source line */
    1:                                     0, /* line number */
    1:                                     0, /* column number */
    1:                                     nsIScriptError::warningFlag,
    1:                                     "XUL Document");
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::LoadScript(nsXULPrototypeScript* aScriptProto, PRBool* aBlock)
    1: {
    1:     // Load a transcluded script
    1:     nsresult rv;
    1: 
13034:     PRBool isChromeDoc = IsChromeURI(mDocumentURI);
13034: 
13034:     if (isChromeDoc && aScriptProto->mScriptObject.mObject) {
    1:         rv = ExecuteScript(aScriptProto);
    1: 
    1:         // Ignore return value from execution, and don't block
    1:         *aBlock = PR_FALSE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Try the XUL script cache, in case two XUL documents source the same
    1:     // .js file (e.g., strres.js from navigator.xul and utilityOverlay.xul).
    1:     // XXXbe the cache relies on aScriptProto's GC root!
    1:     PRBool useXULCache = nsXULPrototypeCache::GetInstance()->IsEnabled();
    1: 
13034:     if (isChromeDoc && useXULCache) {
    1:         PRUint32 fetchedLang = nsIProgrammingLanguage::UNKNOWN;
    1:         void *newScriptObject =
    1:             nsXULPrototypeCache::GetInstance()->GetScript(
    1:                                    aScriptProto->mSrcURI,
    1:                                    &fetchedLang);
    1:         if (newScriptObject) {
    1:             // The script language for a proto must remain constant - we
    1:             // can't just change it for this unexpected language.
    1:             if (aScriptProto->mScriptObject.mLangID != fetchedLang) {
    1:                 NS_ERROR("XUL cache gave me an incorrect script language");
    1:                 return NS_ERROR_UNEXPECTED;
    1:             }
 7230:             aScriptProto->Set(newScriptObject);
    1:         }
    1: 
    1:         if (aScriptProto->mScriptObject.mObject) {
    1:             rv = ExecuteScript(aScriptProto);
    1: 
    1:             // Ignore return value from execution, and don't block
    1:             *aBlock = PR_FALSE;
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
26472:     // Allow security manager and content policies to veto the load. Note that
26472:     // at this point we already lost context information of the script.
26472:     rv = nsScriptLoader::ShouldLoadScript(
26472:                             this,
26472:                             static_cast<nsIDocument*>(this),
26472:                             aScriptProto->mSrcURI,
26472:                             NS_LITERAL_STRING("application/x-javascript"));
26472:     if (NS_FAILED(rv)) {
26472:       *aBlock = PR_FALSE;
26472:       return rv;
26472:     }
26472: 
    1:     // Set the current script prototype so that OnStreamComplete can report
    1:     // the right file if there are errors in the script.
    1:     NS_ASSERTION(!mCurrentScriptProto,
    1:                  "still loading a script when starting another load?");
    1:     mCurrentScriptProto = aScriptProto;
    1: 
    1:     if (aScriptProto->mSrcLoading) {
    1:         // Another XULDocument load has started, which is still in progress.
    1:         // Remember to ResumeWalk this document when the load completes.
    1:         mNextSrcLoadWaiter = aScriptProto->mSrcLoadWaiters;
    1:         aScriptProto->mSrcLoadWaiters = this;
    1:         NS_ADDREF_THIS();
    1:     }
    1:     else {
    1:         nsCOMPtr<nsILoadGroup> group = do_QueryReferent(mDocumentLoadGroup);
    1: 
    1:         // Note: the loader will keep itself alive while it's loading.
    1:         nsCOMPtr<nsIStreamLoader> loader;
    1:         rv = NS_NewStreamLoader(getter_AddRefs(loader), aScriptProto->mSrcURI,
    1:                                 this, nsnull, group);
    1:         if (NS_FAILED(rv)) {
    1:             mCurrentScriptProto = nsnull;
    1:             return rv;
    1:         }
    1: 
    1:         aScriptProto->mSrcLoading = PR_TRUE;
    1:     }
    1: 
    1:     // Block until OnStreamComplete resumes us.
    1:     *aBlock = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::OnStreamComplete(nsIStreamLoader* aLoader,
    1:                                 nsISupports* context,
    1:                                 nsresult aStatus,
    1:                                 PRUint32 stringLen,
    1:                                 const PRUint8* string)
    1: {
    1:     nsCOMPtr<nsIRequest> request;
    1:     aLoader->GetRequest(getter_AddRefs(request));
    1:     nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
    1: 
    1: #ifdef DEBUG
    1:     // print a load error on bad status
    1:     if (NS_FAILED(aStatus)) {
    1:         if (channel) {
    1:             nsCOMPtr<nsIURI> uri;
    1:             channel->GetURI(getter_AddRefs(uri));
    1:             if (uri) {
    1:                 nsCAutoString uriSpec;
    1:                 uri->GetSpec(uriSpec);
    1:                 printf("Failed to load %s\n", uriSpec.get());
    1:             }
    1:         }
    1:     }
    1: #endif
    1: 
    1:     // This is the completion routine that will be called when a
    1:     // transcluded script completes. Compile and execute the script
    1:     // if the load was successful, then continue building content
    1:     // from the prototype.
    1:     nsresult rv;
    1: 
    1:     NS_ASSERTION(mCurrentScriptProto && mCurrentScriptProto->mSrcLoading,
    1:                  "script source not loading on unichar stream complete?");
34203:     if (!mCurrentScriptProto) {
34203:         // XXX Wallpaper for bug 270042
34203:         return NS_OK;
34203:     }
    1: 
    1:     // Clear mCurrentScriptProto now, but save it first for use below in
    1:     // the compile/execute code, and in the while loop that resumes walks
    1:     // of other documents that raced to load this script
    1:     nsXULPrototypeScript* scriptProto = mCurrentScriptProto;
    1:     mCurrentScriptProto = nsnull;
    1: 
    1:     // Clear the prototype's loading flag before executing the script or
    1:     // resuming document walks, in case any of those control flows starts a
    1:     // new script load.
    1:     scriptProto->mSrcLoading = PR_FALSE;
    1: 
    1:     if (NS_SUCCEEDED(aStatus)) {
    1:         // If the including XUL document is a FastLoad document, and we're
    1:         // compiling an out-of-line script (one with src=...), then we must
    1:         // be writing a new FastLoad file.  If we were reading this script
    1:         // from the FastLoad file, XULContentSinkImpl::OpenScript (over in
    1:         // nsXULContentSink.cpp) would have already deserialized a non-null
    1:         // script->mScriptObject, causing control flow at the top of LoadScript
    1:         // not to reach here.
    1:         nsCOMPtr<nsIURI> uri = scriptProto->mSrcURI;
    1: 
    1:         // XXX should also check nsIHttpChannel::requestSucceeded
    1: 
    1:         nsString stringStr;
    1:         rv = nsScriptLoader::ConvertToUTF16(channel, string, stringLen,
    1:                                             EmptyString(), this, stringStr);
13464:         if (NS_SUCCEEDED(rv)) {
13464:             rv = scriptProto->Compile(stringStr.get(), stringStr.Length(),
13464:                                       uri, 1, this, mCurrentPrototype);
13464:         }
    1: 
    1:         aStatus = rv;
    1:         if (NS_SUCCEEDED(rv)) {
13511:             if (nsScriptLoader::ShouldExecuteScript(this, channel)) {
    1:                 rv = ExecuteScript(scriptProto);
13511:             }
    1: 
    1:             // If the XUL cache is enabled, save the script object there in
    1:             // case different XUL documents source the same script.
    1:             //
    1:             // But don't save the script in the cache unless the master XUL
    1:             // document URL is a chrome: URL.  It is valid for a URL such as
    1:             // about:config to translate into a master document URL, whose
    1:             // prototype document nodes -- including prototype scripts that
    1:             // hold GC roots protecting their mJSObject pointers -- are not
    1:             // cached in the XUL prototype cache.  See StartDocumentLoad,
    1:             // the fillXULCache logic.
    1:             //
    1:             // A document such as about:config is free to load a script via
    1:             // a URL such as chrome://global/content/config.js, and we must
    1:             // not cache that script object without a prototype cache entry
    1:             // containing a companion nsXULPrototypeScript node that owns a
    1:             // GC root protecting the script object.  Otherwise, the script
    1:             // cache entry will dangle once the uncached prototype document
    1:             // is released when its owning nsXULDocument is unloaded.
    1:             //
    1:             // (See http://bugzilla.mozilla.org/show_bug.cgi?id=98207 for
    1:             // the true crime story.)
    1:             PRBool useXULCache = nsXULPrototypeCache::GetInstance()->IsEnabled();
    1:   
    1:             if (useXULCache && IsChromeURI(mDocumentURI)) {
    1:                 nsXULPrototypeCache::GetInstance()->PutScript(
    1:                                    scriptProto->mSrcURI,
    1:                                    scriptProto->mScriptObject.mLangID,
    1:                                    scriptProto->mScriptObject.mObject);
    1:             }
    1: 
    1:             if (mIsWritingFastLoad && mCurrentPrototype != mMasterPrototype) {
    1:                 // If we are loading an overlay script, try to serialize
    1:                 // it to the FastLoad file here.  Master scripts will be
    1:                 // serialized when the master prototype document gets
    1:                 // written, at the bottom of ResumeWalk.  That way, master
    1:                 // out-of-line scripts are serialized in the same order that
    1:                 // they'll be read, in the FastLoad file, which reduces the
    1:                 // number of seeks that dump the underlying stream's buffer.
    1:                 //
    1:                 // Ignore the return value, as we don't need to propagate
    1:                 // a failure to write to the FastLoad file, because this
    1:                 // method aborts that whole process on error.
    1:                 nsIScriptGlobalObject* global =
    1:                     mCurrentPrototype->GetScriptGlobalObject();
    1: 
    1:                 NS_ASSERTION(global != nsnull, "master prototype w/o global?!");
    1:                 if (global) {
    1:                     PRUint32 stid = scriptProto->mScriptObject.mLangID;
    1:                     nsIScriptContext *scriptContext = \
    1:                           global->GetScriptContext(stid);
    1:                     NS_ASSERTION(scriptContext != nsnull,
    1:                                  "Failed to get script context for language");
    1:                     if (scriptContext)
    1:                         scriptProto->SerializeOutOfLine(nsnull, global);
    1:                 }
    1:             }
    1:         }
    1:         // ignore any evaluation errors
    1:     }
    1: 
    1:     rv = ResumeWalk();
    1: 
    1:     // Load a pointer to the prototype-script's list of nsXULDocuments who
    1:     // raced to load the same script
    1:     nsXULDocument** docp = &scriptProto->mSrcLoadWaiters;
    1: 
    1:     // Resume walking other documents that waited for this one's load, first
    1:     // executing the script we just compiled, in each doc's script context
    1:     nsXULDocument* doc;
    1:     while ((doc = *docp) != nsnull) {
    1:         NS_ASSERTION(doc->mCurrentScriptProto == scriptProto,
    1:                      "waiting for wrong script to load?");
    1:         doc->mCurrentScriptProto = nsnull;
    1: 
    1:         // Unlink doc from scriptProto's list before executing and resuming
    1:         *docp = doc->mNextSrcLoadWaiter;
    1:         doc->mNextSrcLoadWaiter = nsnull;
    1: 
    1:         // Execute only if we loaded and compiled successfully, then resume
13464:         if (NS_SUCCEEDED(aStatus) && scriptProto->mScriptObject.mObject &&
13511:             nsScriptLoader::ShouldExecuteScript(doc, channel)) {
    1:             doc->ExecuteScript(scriptProto);
    1:         }
    1:         doc->ResumeWalk();
    1:         NS_RELEASE(doc);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::ExecuteScript(nsIScriptContext * aContext, void * aScriptObject)
    1: {
    1:     NS_PRECONDITION(aScriptObject != nsnull && aContext != nsnull, "null ptr");
    1:     if (! aScriptObject || ! aContext)
    1:         return NS_ERROR_NULL_POINTER;
    1: 
    1:     NS_ENSURE_TRUE(mScriptGlobalObject, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     // Execute the precompiled script with the given version
    1:     nsresult rv;
    1:     void *global = mScriptGlobalObject->GetScriptGlobal(
    1:                                             aContext->GetScriptTypeID());
    1:     rv = aContext->ExecuteScript(aScriptObject,
    1:                                  global,
    1:                                  nsnull, nsnull);
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::ExecuteScript(nsXULPrototypeScript *aScript)
    1: {
    1:     NS_PRECONDITION(aScript != nsnull, "null ptr");
    1:     NS_ENSURE_TRUE(aScript, NS_ERROR_NULL_POINTER);
    1:     NS_ENSURE_TRUE(mScriptGlobalObject, NS_ERROR_NOT_INITIALIZED);
    1:     PRUint32 stid = aScript->mScriptObject.mLangID;
    1: 
    1:     nsresult rv;
    1:     rv = mScriptGlobalObject->EnsureScriptEnvironment(stid);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIScriptContext> context =
    1:       mScriptGlobalObject->GetScriptContext(stid);
    1:     // failure getting a script context is fatal.
    1:     NS_ENSURE_TRUE(context != nsnull, NS_ERROR_UNEXPECTED);
    1: 
    1:     if (aScript->mScriptObject.mObject)
    1:         rv = ExecuteScript(context, aScript->mScriptObject.mObject);
    1:     else
    1:         rv = NS_ERROR_UNEXPECTED;
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::CreateElementFromPrototype(nsXULPrototypeElement* aPrototype,
    1:                                           nsIContent** aResult)
    1: {
    1:     // Create a content model element from a prototype element.
    1:     NS_PRECONDITION(aPrototype != nsnull, "null ptr");
    1:     if (! aPrototype)
    1:         return NS_ERROR_NULL_POINTER;
    1: 
    1:     *aResult = nsnull;
    1:     nsresult rv = NS_OK;
    1: 
    1: #ifdef PR_LOGGING
    1:     if (PR_LOG_TEST(gXULLog, PR_LOG_NOTICE)) {
    1:         nsAutoString tagstr;
    1:         aPrototype->mNodeInfo->GetQualifiedName(tagstr);
    1: 
    1:         nsCAutoString tagstrC;
    1:         tagstrC.AssignWithConversion(tagstr);
    1:         PR_LOG(gXULLog, PR_LOG_NOTICE,
    1:                ("xul: creating <%s> from prototype",
    1:                 tagstrC.get()));
    1:     }
    1: #endif
    1: 
    1:     nsCOMPtr<nsIContent> result;
    1: 
    1:     if (aPrototype->mNodeInfo->NamespaceEquals(kNameSpaceID_XUL)) {
    1:         // If it's a XUL element, it'll be lightweight until somebody
    1:         // monkeys with it.
    1:         rv = nsXULElement::Create(aPrototype, this, PR_TRUE, getter_AddRefs(result));
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1:     else {
    1:         // If it's not a XUL element, it's gonna be heavyweight no matter
    1:         // what. So we need to copy everything out of the prototype
    1:         // into the element.  Get a nodeinfo from our nodeinfo manager
    1:         // for this node.
    1:         nsCOMPtr<nsINodeInfo> newNodeInfo;
19197:         newNodeInfo = mNodeInfoManager->GetNodeInfo(aPrototype->mNodeInfo->NameAtom(),
    1:                                                     aPrototype->mNodeInfo->GetPrefixAtom(),
19197:                                                     aPrototype->mNodeInfo->NamespaceID());
19747:         if (!newNodeInfo) return NS_ERROR_OUT_OF_MEMORY;
    1:         rv = NS_NewElement(getter_AddRefs(result), newNodeInfo->NamespaceID(),
14437:                            newNodeInfo, PR_FALSE);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1: #ifdef MOZ_XTF
    1:         if (result && newNodeInfo->NamespaceID() > kNameSpaceID_LastBuiltin) {
    1:             result->BeginAddingChildren();
    1:         }
    1: #endif
    1: 
    1:         rv = AddAttributes(aPrototype, result);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     result.swap(*aResult);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::CreateOverlayElement(nsXULPrototypeElement* aPrototype,
    1:                                     nsIContent** aResult)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIContent> element;
    1:     rv = CreateElementFromPrototype(aPrototype, getter_AddRefs(element));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     OverlayForwardReference* fwdref =
    1:         new OverlayForwardReference(this, element);
    1:     if (! fwdref)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // transferring ownership to ya...
    1:     rv = AddForwardReference(fwdref);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     NS_ADDREF(*aResult = element);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::AddAttributes(nsXULPrototypeElement* aPrototype,
    1:                              nsIContent* aElement)
    1: {
    1:     nsresult rv;
    1: 
    1:     for (PRUint32 i = 0; i < aPrototype->mNumAttributes; ++i) {
    1:         nsXULPrototypeAttribute* protoattr = &(aPrototype->mAttributes[i]);
    1:         nsAutoString  valueStr;
    1:         protoattr->mValue.ToString(valueStr);
    1: 
    1:         rv = aElement->SetAttr(protoattr->mName.NamespaceID(),
    1:                                protoattr->mName.LocalName(),
    1:                                protoattr->mName.GetPrefix(),
    1:                                valueStr,
    1:                                PR_FALSE);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::CheckTemplateBuilderHookup(nsIContent* aElement,
    1:                                           PRBool* aNeedsHookup)
    1: {
    1:     // See if the element already has a `database' attribute. If it
    1:     // does, then the template builder has already been created.
    1:     //
    1:     // XXX This approach will crash and burn (well, maybe not _that_
    1:     // bad) if aElement is not a XUL element.
    1:     //
    1:     // XXXvarga Do we still want to support non XUL content?
    1:     nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(aElement);
    1:     if (xulElement) {
    1:         nsCOMPtr<nsIRDFCompositeDataSource> ds;
    1:         xulElement->GetDatabase(getter_AddRefs(ds));
    1:         if (ds) {
    1:             *aNeedsHookup = PR_FALSE;
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     // Check aElement for a 'datasources' attribute, if it has
    1:     // one a XUL template builder needs to be hooked up.
    1:     *aNeedsHookup = aElement->HasAttr(kNameSpaceID_None,
    1:                                       nsGkAtoms::datasources);
    1:     return NS_OK;
    1: }
    1: 
    1: /* static */ nsresult
    1: nsXULDocument::CreateTemplateBuilder(nsIContent* aElement)
    1: {
    1:     // Check if need to construct a tree builder or content builder.
    1:     PRBool isTreeBuilder = PR_FALSE;
    1: 
27619:     // return successful if the element is not is a document, as an inline
27619:     // script could have removed it
27619:     nsIDocument *document = aElement->GetCurrentDoc();
27619:     NS_ENSURE_TRUE(document, NS_OK);
    1: 
    1:     PRInt32 nameSpaceID;
    1:     nsIAtom* baseTag = document->BindingManager()->
    1:       ResolveTag(aElement, &nameSpaceID);
    1: 
    1:     if ((nameSpaceID == kNameSpaceID_XUL) && (baseTag == nsGkAtoms::tree)) {
    1:         // By default, we build content for a tree and then we attach
    1:         // the tree content view. However, if the `dont-build-content'
    1:         // flag is set, then we we'll attach a tree builder which
    1:         // directly implements the tree view.
    1: 
    1:         nsAutoString flags;
    1:         aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::flags, flags);
    1:         if (flags.Find(NS_LITERAL_STRING("dont-build-content")) >= 0) {
    1:             isTreeBuilder = PR_TRUE;
    1:         }
    1:     }
    1: 
    1:     if (isTreeBuilder) {
    1:         // Create and initialize a tree builder.
    1:         nsCOMPtr<nsIXULTemplateBuilder> builder =
    1:             do_CreateInstance("@mozilla.org/xul/xul-tree-builder;1");
    1: 
    1:         if (! builder)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         builder->Init(aElement);
    1: 
    1:         // Create a <treechildren> if one isn't there already.
    1:         // XXXvarga what about attributes?
    1:         nsCOMPtr<nsIContent> bodyContent;
    1:         nsXULContentUtils::FindChildByTag(aElement, kNameSpaceID_XUL,
    1:                                           nsGkAtoms::treechildren,
    1:                                           getter_AddRefs(bodyContent));
    1: 
    1:         if (! bodyContent) {
    1:             nsresult rv = document->CreateElem(nsGkAtoms::treechildren,
    1:                                                nsnull, kNameSpaceID_XUL,
    1:                                                PR_FALSE,
    1:                                                getter_AddRefs(bodyContent));
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             aElement->AppendChildTo(bodyContent, PR_FALSE);
    1:         }
    1:     }
    1:     else {
    1:         // Create and initialize a content builder.
    1:         nsCOMPtr<nsIXULTemplateBuilder> builder
    1:             = do_CreateInstance("@mozilla.org/xul/xul-template-builder;1");
    1: 
    1:         if (! builder)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         builder->Init(aElement);
12021:         builder->CreateContents(aElement, PR_FALSE);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::AddPrototypeSheets()
    1: {
    1:     nsresult rv;
    1: 
    1:     const nsCOMArray<nsIURI>& sheets = mCurrentPrototype->GetStyleSheetReferences();
    1: 
    1:     for (PRInt32 i = 0; i < sheets.Count(); i++) {
    1:         nsCOMPtr<nsIURI> uri = sheets[i];
    1: 
    1:         nsCOMPtr<nsICSSStyleSheet> incompleteSheet;
 4367:         rv = CSSLoader()->LoadSheet(uri,
 3349:                                     mCurrentPrototype->DocumentPrincipal(),
27188:                                     EmptyCString(), this,
27188:                                     getter_AddRefs(incompleteSheet));
    1: 
    1:         // XXXldb We need to prevent bogus sheets from being held in the
    1:         // prototype's list, but until then, don't propagate the failure
    1:         // from LoadSheet (and thus exit the loop).
    1:         if (NS_SUCCEEDED(rv)) {
    1:             ++mPendingSheets;
    1:             if (!mOverlaySheets.AppendObject(incompleteSheet)) {
    1:                 return NS_ERROR_OUT_OF_MEMORY;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULDocument::OverlayForwardReference
    1: //
    1: 
    1: nsForwardReference::Result
    1: nsXULDocument::OverlayForwardReference::Resolve()
    1: {
    1:     // Resolve a forward reference from an overlay element; attempt to
    1:     // hook it up into the main document.
    1:     nsresult rv;
    1:     nsCOMPtr<nsIContent> target;
    1: 
  981:     nsIPresShell *shell = mDocument->GetPrimaryShell();
23164:     PRBool notify = shell && shell->DidInitialReflow();
    1: 
    1:     nsAutoString id;
    1:     mOverlay->GetAttr(kNameSpaceID_None, nsGkAtoms::id, id);
    1:     if (id.IsEmpty()) {
    1:         // mOverlay is a direct child of <overlay> and has no id.
    1:         // Insert it under the root element in the base document.
 8938:         nsIContent* root = mDocument->GetRootContent();
 8938:         if (!root) {
    1:             return eResolve_Error;
    1:         }
    1: 
 8938:         rv = mDocument->InsertElement(root, mOverlay, notify);
    1:         if (NS_FAILED(rv)) return eResolve_Error;
    1: 
    1:         target = mOverlay;
    1:     }
    1:     else {
    1:         // The hook-up element has an id, try to match it with an element
    1:         // with the same id in the base document.
    1:         nsCOMPtr<nsIDOMElement> domtarget;
    1:         rv = mDocument->GetElementById(id, getter_AddRefs(domtarget));
    1:         if (NS_FAILED(rv)) return eResolve_Error;
    1: 
    1:         // If we can't find the element in the document, defer the hookup
    1:         // until later.
    1:         target = do_QueryInterface(domtarget);
    1:         NS_ASSERTION(!domtarget || target, "not an nsIContent");
    1:         if (!target)
    1:             return eResolve_Later;
    1: 
    1:         // While merging, set the default script language of the element to be
    1:         // the language from the overlay - attributes will then be correctly
    1:         // hooked up with the appropriate language (while child nodes ignore
    1:         // the default language - they have it in their proto.
    1:         PRUint32 oldDefLang = target->GetScriptTypeID();
    1:         target->SetScriptTypeID(mOverlay->GetScriptTypeID());
    1:         rv = Merge(target, mOverlay, notify);
    1:         target->SetScriptTypeID(oldDefLang);
    1:         if (NS_FAILED(rv)) return eResolve_Error;
    1:     }
    1: 
28875:     // Check if 'target' is still in our document --- it might not be!
28875:     if (!notify && target->GetCurrentDoc() == mDocument) {
    1:         // Add child and any descendants to the element map
28875:         // XXX this is bogus, the content in 'target' might already be
28875:         // in the document
    1:         rv = mDocument->AddSubtreeToDocument(target);
    1:         if (NS_FAILED(rv)) return eResolve_Error;
    1:     }
    1: 
    1: #ifdef PR_LOGGING
    1:     if (PR_LOG_TEST(gXULLog, PR_LOG_NOTICE)) {
    1:         nsCAutoString idC;
    1:         idC.AssignWithConversion(id);
    1:         PR_LOG(gXULLog, PR_LOG_NOTICE,
    1:                ("xul: overlay resolved '%s'",
    1:                 idC.get()));
    1:     }
    1: #endif
    1: 
    1:     mResolved = PR_TRUE;
    1:     return eResolve_Succeeded;
    1: }
    1: 
    1: 
    1: 
    1: nsresult
    1: nsXULDocument::OverlayForwardReference::Merge(nsIContent* aTargetNode,
    1:                                               nsIContent* aOverlayNode, 
    1:                                               PRBool aNotify)
    1: {
    1:     // This function is given:
    1:     // aTargetNode:  the node in the document whose 'id' attribute
    1:     //               matches a toplevel node in our overlay.
    1:     // aOverlayNode: the node in the overlay document that matches
    1:     //               a node in the actual document.
    1:     // aNotify:      whether or not content manipulation methods should
    1:     //               use the aNotify parameter. After the initial 
    1:     //               reflow (i.e. in the dynamic overlay merge case),
    1:     //               we want all the content manipulation methods we
    1:     //               call to notify so that frames are constructed 
    1:     //               etc. Otherwise do not, since that's during initial
    1:     //               document construction before StartLayout has been
    1:     //               called which will do everything for us.
    1:     //
    1:     // This function merges the tree from the overlay into the tree in
    1:     // the document, overwriting attributes and appending child content
    1:     // nodes appropriately. (See XUL overlay reference for details)
    1: 
    1:     nsresult rv;
    1: 
    1:     // Merge attributes from the overlay content node to that of the
    1:     // actual document.
    1:     PRUint32 i;
    1:     const nsAttrName* name;
    1:     for (i = 0; (name = aOverlayNode->GetAttrNameAt(i)); ++i) {
    1:         // We don't want to swap IDs, they should be the same.
 4667:         if (name->Equals(nsGkAtoms::id))
    1:             continue;
    1: 
 4737:         // In certain cases merging command or observes is unsafe, so don't.
 4737:         if (!aNotify) {
 4737:             if (aTargetNode->NodeInfo()->Equals(nsGkAtoms::observes,
 4737:                                                 kNameSpaceID_XUL))
 4737:                 continue;
 4737: 
 4737:             if (name->Equals(nsGkAtoms::observes) &&
 4737:                 aTargetNode->HasAttr(kNameSpaceID_None, nsGkAtoms::observes))
 4737:                 continue;
 4737: 
 4737:             if (name->Equals(nsGkAtoms::command) &&
 4737:                 aTargetNode->HasAttr(kNameSpaceID_None, nsGkAtoms::command) &&
 4737:                 !aTargetNode->NodeInfo()->Equals(nsGkAtoms::key,
 4737:                                                  kNameSpaceID_XUL) &&
 4737:                 !aTargetNode->NodeInfo()->Equals(nsGkAtoms::menuitem,
 4737:                                                  kNameSpaceID_XUL))
 4737:                 continue;
 4737:         }
 4737: 
    1:         PRInt32 nameSpaceID = name->NamespaceID();
    1:         nsIAtom* attr = name->LocalName();
    1:         nsIAtom* prefix = name->GetPrefix();
    1: 
    1:         nsAutoString value;
    1:         aOverlayNode->GetAttr(nameSpaceID, attr, value);
    1: 
    1:         // Element in the overlay has the 'removeelement' attribute set
    1:         // so remove it from the actual document.
    1:         if (attr == nsGkAtoms::removeelement &&
    1:             value.EqualsLiteral("true")) {
    1: 
    1:             rv = RemoveElement(aTargetNode->GetParent(), aTargetNode);
    1:             if (NS_FAILED(rv)) return rv;
    1: 
    1:             return NS_OK;
    1:         }
    1: 
    1:         rv = aTargetNode->SetAttr(nameSpaceID, attr, prefix, value, aNotify);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1: 
    1:     // Walk our child nodes, looking for elements that have the 'id'
    1:     // attribute set. If we find any, we must do a parent check in the
    1:     // actual document to ensure that the structure matches that of
    1:     // the actual document. If it does, we can call ourselves and attempt
    1:     // to merge inside that subtree. If not, we just append the tree to
    1:     // the parent like any other.
    1: 
    1:     PRUint32 childCount = aOverlayNode->GetChildCount();
    1: 
    1:     // This must be a strong reference since it will be the only
    1:     // reference to a content object during part of this loop.
    1:     nsCOMPtr<nsIContent> currContent;
    1: 
    1:     for (i = 0; i < childCount; ++i) {
    1:         currContent = aOverlayNode->GetChildAt(0);
    1: 
    1:         nsAutoString id;
    1:         currContent->GetAttr(kNameSpaceID_None, nsGkAtoms::id, id);
    1: 
    1:         nsCOMPtr<nsIDOMElement> nodeInDocument;
    1:         if (!id.IsEmpty()) {
    1:             nsCOMPtr<nsIDOMDocument> domDocument(
    1:                         do_QueryInterface(aTargetNode->GetDocument()));
    1:             if (!domDocument) return NS_ERROR_FAILURE;
    1: 
    1:             rv = domDocument->GetElementById(id, getter_AddRefs(nodeInDocument));
    1:             if (NS_FAILED(rv)) return rv;
    1:         }
    1: 
    1:         // The item has an 'id' attribute set, and we need to check with
    1:         // the actual document to see if an item with this id exists at
    1:         // this locale. If so, we want to merge the subtree under that
    1:         // node. Otherwise, we just do an append as if the element had
    1:         // no id attribute.
    1:         if (nodeInDocument) {
    1:             // Given two parents, aTargetNode and aOverlayNode, we want
    1:             // to call merge on currContent if we find an associated
    1:             // node in the document with the same id as currContent that
    1:             // also has aTargetNode as its parent.
    1: 
    1:             nsCOMPtr<nsIDOMNode> nodeParent;
    1:             rv = nodeInDocument->GetParentNode(getter_AddRefs(nodeParent));
    1:             if (NS_FAILED(rv)) return rv;
    1:             nsCOMPtr<nsIDOMElement> elementParent(do_QueryInterface(nodeParent));
    1: 
    1:             nsAutoString parentID;
    1:             elementParent->GetAttribute(NS_LITERAL_STRING("id"), parentID);
    1:             if (aTargetNode->AttrValueIs(kNameSpaceID_None, nsGkAtoms::id,
    1:                                          parentID, eCaseMatters)) {
    1:                 // The element matches. "Go Deep!"
    1:                 nsCOMPtr<nsIContent> childDocumentContent(do_QueryInterface(nodeInDocument));
    1:                 rv = Merge(childDocumentContent, currContent, aNotify);
    1:                 if (NS_FAILED(rv)) return rv;
    1:                 rv = aOverlayNode->RemoveChildAt(0, PR_FALSE);
    1:                 if (NS_FAILED(rv)) return rv;
    1: 
    1:                 continue;
    1:             }
    1:         }
    1: 
    1:         rv = aOverlayNode->RemoveChildAt(0, PR_FALSE);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         rv = InsertElement(aTargetNode, currContent, aNotify);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: nsXULDocument::OverlayForwardReference::~OverlayForwardReference()
    1: {
    1: #ifdef PR_LOGGING
    1:     if (PR_LOG_TEST(gXULLog, PR_LOG_WARNING) && !mResolved) {
    1:         nsAutoString id;
    1:         mOverlay->GetAttr(kNameSpaceID_None, nsGkAtoms::id, id);
    1: 
    1:         nsCAutoString idC;
    1:         idC.AssignWithConversion(id);
    1:         PR_LOG(gXULLog, PR_LOG_WARNING,
    1:                ("xul: overlay failed to resolve '%s'",
    1:                 idC.get()));
    1:     }
    1: #endif
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULDocument::BroadcasterHookup
    1: //
    1: 
    1: nsForwardReference::Result
    1: nsXULDocument::BroadcasterHookup::Resolve()
    1: {
    1:     nsresult rv;
    1: 
    1:     PRBool listener;
    1:     rv = mDocument->CheckBroadcasterHookup(mObservesElement, &listener, &mResolved);
    1:     if (NS_FAILED(rv)) return eResolve_Error;
    1: 
    1:     return mResolved ? eResolve_Succeeded : eResolve_Later;
    1: }
    1: 
    1: 
    1: nsXULDocument::BroadcasterHookup::~BroadcasterHookup()
    1: {
    1: #ifdef PR_LOGGING
    1:     if (PR_LOG_TEST(gXULLog, PR_LOG_WARNING) && !mResolved) {
    1:         // Tell the world we failed
    1:         nsresult rv;
    1: 
    1:         nsIAtom *tag = mObservesElement->Tag();
    1: 
    1:         nsAutoString broadcasterID;
    1:         nsAutoString attribute;
    1: 
    1:         if (tag == nsGkAtoms::observes) {
    1:             mObservesElement->GetAttr(kNameSpaceID_None, nsGkAtoms::element, broadcasterID);
    1:             mObservesElement->GetAttr(kNameSpaceID_None, nsGkAtoms::attribute, attribute);
    1:         }
    1:         else {
    1:             mObservesElement->GetAttr(kNameSpaceID_None, nsGkAtoms::observes, broadcasterID);
    1:             attribute.AssignLiteral("*");
    1:         }
    1: 
    1:         nsAutoString tagStr;
    1:         rv = tag->ToString(tagStr);
    1:         if (NS_FAILED(rv)) return;
    1: 
    1:         nsCAutoString tagstrC, attributeC,broadcasteridC;
    1:         tagstrC.AssignWithConversion(tagStr);
    1:         attributeC.AssignWithConversion(attribute);
    1:         broadcasteridC.AssignWithConversion(broadcasterID);
    1:         PR_LOG(gXULLog, PR_LOG_WARNING,
    1:                ("xul: broadcaster hookup failed <%s attribute='%s'> to %s",
    1:                 tagstrC.get(),
    1:                 attributeC.get(),
    1:                 broadcasteridC.get()));
    1:     }
    1: #endif
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULDocument::TemplateBuilderHookup
    1: //
    1: 
    1: nsForwardReference::Result
    1: nsXULDocument::TemplateBuilderHookup::Resolve()
    1: {
    1:     PRBool needsHookup;
    1:     nsresult rv = CheckTemplateBuilderHookup(mElement, &needsHookup);
    1:     if (NS_FAILED(rv))
    1:         return eResolve_Error;
    1: 
    1:     if (needsHookup) {
    1:         rv = CreateTemplateBuilder(mElement);
    1:         if (NS_FAILED(rv))
    1:             return eResolve_Error;
    1:     }
    1: 
    1:     return eResolve_Succeeded;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsXULDocument::FindBroadcaster(nsIContent* aElement,
    1:                                nsIDOMElement** aListener,
    1:                                nsString& aBroadcasterID,
    1:                                nsString& aAttribute,
    1:                                nsIDOMElement** aBroadcaster)
    1: {
    1:     NS_ASSERTION(aElement->IsNodeOfType(nsINode::eELEMENT),
    1:                  "Only pass elements into FindBroadcaster!");
    1: 
    1:     nsresult rv;
    1:     nsINodeInfo *ni = aElement->NodeInfo();
    1:     *aListener = nsnull;
    1:     *aBroadcaster = nsnull;
    1: 
    1:     if (ni->Equals(nsGkAtoms::observes, kNameSpaceID_XUL)) {
    1:         // It's an <observes> element, which means that the actual
    1:         // listener is the _parent_ node. This element should have an
    1:         // 'element' attribute that specifies the ID of the
    1:         // broadcaster element, and an 'attribute' element, which
    1:         // specifies the name of the attribute to observe.
    1:         nsIContent* parent = aElement->GetParent();
 7068:         if (!parent) {
 7068:              // <observes> is the root element
 7068:             return NS_FINDBROADCASTER_NOT_FOUND;
 7068:         }
    1: 
    1:         // If we're still parented by an 'overlay' tag, then we haven't
    1:         // made it into the real document yet. Defer hookup.
    1:         if (parent->NodeInfo()->Equals(nsGkAtoms::overlay,
    1:                                        kNameSpaceID_XUL)) {
    1:             return NS_FINDBROADCASTER_AWAIT_OVERLAYS;
    1:         }
    1: 
    1:         if (NS_FAILED(CallQueryInterface(parent, aListener)))
    1:             *aListener = nsnull;
    1: 
    1:         aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::element, aBroadcasterID);
    1:         if (aBroadcasterID.IsEmpty()) {
    1:             return NS_FINDBROADCASTER_NOT_FOUND;
    1:         }
    1:         aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::attribute, aAttribute);
    1:     }
    1:     else {
    1:         // It's a generic element, which means that we'll use the
    1:         // value of the 'observes' attribute to determine the ID of
    1:         // the broadcaster element, and we'll watch _all_ of its
    1:         // values.
    1:         aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::observes, aBroadcasterID);
    1: 
    1:         // Bail if there's no aBroadcasterID
    1:         if (aBroadcasterID.IsEmpty()) {
    1:             // Try the command attribute next.
    1:             aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::command, aBroadcasterID);
    1:             if (!aBroadcasterID.IsEmpty()) {
    1:                 // We've got something in the command attribute.  We
    1:                 // only treat this as a normal broadcaster if we are
    1:                 // not a menuitem or a key.
    1: 
    1:                 if (ni->Equals(nsGkAtoms::menuitem, kNameSpaceID_XUL) ||
    1:                     ni->Equals(nsGkAtoms::key, kNameSpaceID_XUL)) {
    1:                 return NS_FINDBROADCASTER_NOT_FOUND;
    1:               }
    1:             }
    1:             else {
    1:               return NS_FINDBROADCASTER_NOT_FOUND;
    1:             }
    1:         }
    1: 
    1:         if (NS_FAILED(CallQueryInterface(aElement, aListener)))
    1:             *aListener = nsnull;
    1: 
    1:         aAttribute.AssignLiteral("*");
    1:     }
    1: 
    1:     // Make sure we got a valid listener.
    1:     NS_ENSURE_TRUE(*aListener, NS_ERROR_UNEXPECTED);
    1: 
    1:     // Try to find the broadcaster element in the document.
    1:     rv = GetElementById(aBroadcasterID, aBroadcaster);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // If we can't find the broadcaster, then we'll need to defer the
    1:     // hookup. We may need to resolve some of the other overlays
    1:     // first.
    1:     if (! *aBroadcaster) {
    1:         return NS_FINDBROADCASTER_AWAIT_OVERLAYS;
    1:     }
    1: 
    1:     return NS_FINDBROADCASTER_FOUND;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::CheckBroadcasterHookup(nsIContent* aElement,
    1:                                       PRBool* aNeedsHookup,
    1:                                       PRBool* aDidResolve)
    1: {
    1:     // Resolve a broadcaster hookup. Look at the element that we're
    1:     // trying to resolve: it could be an '<observes>' element, or just
    1:     // a vanilla element with an 'observes' attribute on it.
    1:     nsresult rv;
    1: 
    1:     *aDidResolve = PR_FALSE;
    1: 
    1:     nsCOMPtr<nsIDOMElement> listener;
    1:     nsAutoString broadcasterID;
    1:     nsAutoString attribute;
    1:     nsCOMPtr<nsIDOMElement> broadcaster;
    1: 
    1:     rv = FindBroadcaster(aElement, getter_AddRefs(listener),
    1:                          broadcasterID, attribute, getter_AddRefs(broadcaster));
    1:     switch (rv) {
    1:         case NS_FINDBROADCASTER_NOT_FOUND:
    1:             *aNeedsHookup = PR_FALSE;
    1:             return NS_OK;
    1:         case NS_FINDBROADCASTER_AWAIT_OVERLAYS:
    1:             *aNeedsHookup = PR_TRUE;
    1:             return NS_OK;
    1:         case NS_FINDBROADCASTER_FOUND:
    1:             break;
    1:         default:
    1:             return rv;
    1:     }
    1: 
    1:     rv = AddBroadcastListenerFor(broadcaster, listener, attribute);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1: #ifdef PR_LOGGING
    1:     // Tell the world we succeeded
    1:     if (PR_LOG_TEST(gXULLog, PR_LOG_NOTICE)) {
    1:         nsCOMPtr<nsIContent> content =
    1:             do_QueryInterface(listener);
    1: 
    1:         NS_ASSERTION(content != nsnull, "not an nsIContent");
    1:         if (! content)
    1:             return rv;
    1: 
    1:         nsAutoString tagStr;
    1:         rv = content->Tag()->ToString(tagStr);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         nsCAutoString tagstrC, attributeC,broadcasteridC;
    1:         tagstrC.AssignWithConversion(tagStr);
    1:         attributeC.AssignWithConversion(attribute);
    1:         broadcasteridC.AssignWithConversion(broadcasterID);
    1:         PR_LOG(gXULLog, PR_LOG_NOTICE,
    1:                ("xul: broadcaster hookup <%s attribute='%s'> to %s",
    1:                 tagstrC.get(),
    1:                 attributeC.get(),
    1:                 broadcasteridC.get()));
    1:     }
    1: #endif
    1: 
    1:     *aNeedsHookup = PR_FALSE;
    1:     *aDidResolve = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::InsertElement(nsIContent* aParent, nsIContent* aChild, PRBool aNotify)
    1: {
    1:     // Insert aChild appropriately into aParent, accounting for a
    1:     // 'pos' attribute set on aChild.
    1:     nsresult rv;
    1: 
    1:     nsAutoString posStr;
    1:     PRBool wasInserted = PR_FALSE;
    1: 
    1:     // insert after an element of a given id
    1:     aChild->GetAttr(kNameSpaceID_None, nsGkAtoms::insertafter, posStr);
    1:     PRBool isInsertAfter = PR_TRUE;
    1: 
    1:     if (posStr.IsEmpty()) {
    1:         aChild->GetAttr(kNameSpaceID_None, nsGkAtoms::insertbefore, posStr);
    1:         isInsertAfter = PR_FALSE;
    1:     }
    1: 
    1:     if (!posStr.IsEmpty()) {
    1:         nsCOMPtr<nsIDOMDocument> domDocument(
    1:                do_QueryInterface(aParent->GetDocument()));
23783:         if (!domDocument) return NS_ERROR_FAILURE;
23783: 
    1:         nsCOMPtr<nsIDOMElement> domElement;
    1: 
    1:         char* str = ToNewCString(posStr);
    1:         char* rest;
    1:         char* token = nsCRT::strtok(str, ", ", &rest);
    1: 
    1:         while (token) {
    1:             rv = domDocument->GetElementById(NS_ConvertASCIItoUTF16(token),
    1:                                              getter_AddRefs(domElement));
    1:             if (domElement)
    1:                 break;
    1: 
    1:             token = nsCRT::strtok(rest, ", ", &rest);
    1:         }
    1:         nsMemory::Free(str);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         if (domElement) {
    1:             nsCOMPtr<nsIContent> content(do_QueryInterface(domElement));
    1:             NS_ASSERTION(content != nsnull, "null ptr");
    1:             if (!content)
    1:                 return NS_ERROR_UNEXPECTED;
    1: 
    1:             PRInt32 pos = aParent->IndexOf(content);
    1: 
    1:             if (pos != -1) {
    1:                 pos = isInsertAfter ? pos + 1 : pos;
    1:                 rv = aParent->InsertChildAt(aChild, pos, aNotify);
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1: 
    1:                 wasInserted = PR_TRUE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (!wasInserted) {
    1: 
    1:         aChild->GetAttr(kNameSpaceID_None, nsGkAtoms::position, posStr);
    1:         if (!posStr.IsEmpty()) {
    1:             // Positions are one-indexed.
 3233:             PRInt32 pos = posStr.ToInteger(reinterpret_cast<PRInt32*>(&rv));
    1:             // Note: if the insertion index (which is |pos - 1|) would be less
    1:             // than 0 or greater than the number of children aParent has, then
    1:             // don't insert, since the position is bogus.  Just skip on to
    1:             // appending.
    1:             if (NS_SUCCEEDED(rv) && pos > 0 &&
    1:                 PRUint32(pos - 1) <= aParent->GetChildCount()) {
    1:                 rv = aParent->InsertChildAt(aChild, pos - 1, aNotify);
    1:                 if (NS_SUCCEEDED(rv))
    1:                     wasInserted = PR_TRUE;
    1:                 // If the insertion fails, then we should still
    1:                 // attempt an append.  Thus, rather than returning rv
    1:                 // immediately, we fall through to the final
    1:                 // "catch-all" case that just does an AppendChildTo.
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (! wasInserted) {
    1:         rv = aParent->AppendChildTo(aChild, aNotify);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULDocument::RemoveElement(nsIContent* aParent, nsIContent* aChild)
    1: {
    1:     PRInt32 nodeOffset = aParent->IndexOf(aChild);
    1: 
    1:     return aParent->RemoveChildAt(nodeOffset, PR_TRUE);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // CachedChromeStreamListener
    1: //
    1: 
    1: nsXULDocument::CachedChromeStreamListener::CachedChromeStreamListener(nsXULDocument* aDocument, PRBool aProtoLoaded)
    1:     : mDocument(aDocument),
    1:       mProtoLoaded(aProtoLoaded)
    1: {
    1:     NS_ADDREF(mDocument);
    1: }
    1: 
    1: 
    1: nsXULDocument::CachedChromeStreamListener::~CachedChromeStreamListener()
    1: {
    1:     NS_RELEASE(mDocument);
    1: }
    1: 
    1: 
    1: NS_IMPL_ISUPPORTS2(nsXULDocument::CachedChromeStreamListener,
    1:                    nsIRequestObserver, nsIStreamListener)
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::CachedChromeStreamListener::OnStartRequest(nsIRequest *request,
    1:                                                           nsISupports* acontext)
    1: {
25034:     return NS_ERROR_PARSED_DATA_CACHED;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::CachedChromeStreamListener::OnStopRequest(nsIRequest *request,
    1:                                                          nsISupports* aContext,
    1:                                                          nsresult aStatus)
    1: {
    1:     if (! mProtoLoaded)
    1:         return NS_OK;
    1: 
    1:     return mDocument->OnPrototypeLoadDone(PR_TRUE);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::CachedChromeStreamListener::OnDataAvailable(nsIRequest *request,
    1:                                                            nsISupports* aContext,
    1:                                                            nsIInputStream* aInStr,
    1:                                                            PRUint32 aSourceOffset,
    1:                                                            PRUint32 aCount)
    1: {
    1:     NS_NOTREACHED("CachedChromeStream doesn't receive data");
    1:     return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // ParserObserver
    1: //
    1: 
 3349: nsXULDocument::ParserObserver::ParserObserver(nsXULDocument* aDocument,
 3349:                                               nsXULPrototypeDocument* aPrototype)
 3349:     : mDocument(aDocument), mPrototype(aPrototype)
    1: {
    1: }
    1: 
    1: nsXULDocument::ParserObserver::~ParserObserver()
    1: {
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsXULDocument::ParserObserver, nsIRequestObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::ParserObserver::OnStartRequest(nsIRequest *request,
    1:                                               nsISupports* aContext)
    1: {
 3349:     // Guard against buggy channels calling OnStartRequest multiple times.
 3349:     if (mPrototype) {
 3349:         nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
 3349:         nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 3349:         if (channel && secMan) {
 3349:             nsCOMPtr<nsIPrincipal> principal;
 3349:             secMan->GetChannelPrincipal(channel, getter_AddRefs(principal));
 3349: 
 3349:             // Failure there is ok -- it'll just set a (safe) null principal
 3349:             mPrototype->SetDocumentPrincipal(principal);            
 3349:         }
 3349: 
 3349:         // Make sure to avoid cycles
 3349:         mPrototype = nsnull;
 3349:     }
 3349:         
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULDocument::ParserObserver::OnStopRequest(nsIRequest *request,
    1:                                              nsISupports* aContext,
    1:                                              nsresult aStatus)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     if (NS_FAILED(aStatus)) {
    1:         // If an overlay load fails, we need to nudge the prototype
    1:         // walk along.
    1:         nsCOMPtr<nsIChannel> aChannel = do_QueryInterface(request);
    1:         if (aChannel) {
    1:             nsCOMPtr<nsIURI> uri;
    1:             aChannel->GetOriginalURI(getter_AddRefs(uri));
    1:             if (uri) {
    1:                 mDocument->ReportMissingOverlay(uri);
    1:             }
    1:         }
    1: 
    1:         rv = mDocument->ResumeWalk();
    1:     }
    1: 
    1:     // Drop the reference to the document to break cycle between the
    1:     // document, the parser, the content sink, and the parser
    1:     // observer.
 3349:     mDocument = nsnull;
    1: 
    1:     return rv;
    1: }
    1: 
    1: void
    1: nsXULDocument::GetFocusController(nsIFocusController** aFocusController)
    1: {
    1:     nsCOMPtr<nsIInterfaceRequestor> ir = do_QueryReferent(mDocumentContainer);
    1:     nsCOMPtr<nsPIDOMWindow> windowPrivate = do_GetInterface(ir);
    1:     if (windowPrivate) {
    1:         NS_IF_ADDREF(*aFocusController = windowPrivate->GetRootFocusController());
    1:     } else
    1:         *aFocusController = nsnull;
    1: }
26701: 
30836: PRBool
30836: nsXULDocument::IsDocumentRightToLeft()
30836: {
30836:     if (mDocDirection == Direction_Uninitialized) {
30836:         mDocDirection = Direction_LeftToRight; // default to ltr on failure
30836: 
30836:         // setting the localedir attribute on the root element forces a
30836:         // specific direction for the document.
30836:         nsIContent* content = GetRootContent();
30836:         if (content) {
30836:             static nsIContent::AttrValuesArray strings[] =
30836:                 {&nsGkAtoms::ltr, &nsGkAtoms::rtl, nsnull};
30836:             switch (content->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::localedir,
30836:                                              strings, eCaseMatters)) {
30836:                 case 0: mDocDirection = Direction_LeftToRight; return PR_FALSE;
30836:                 case 1: mDocDirection = Direction_RightToLeft; return PR_TRUE;
30836:                 default: break;// otherwise, not a valid value, so fall through
30836:             }
30836:         }
30836: 
30836:         // otherwise, get the locale from the chrome registry and
30836:         // look up the intl.uidirection.<locale> preference
30836:         nsCOMPtr<nsIXULChromeRegistry> reg =
30836:             do_GetService(NS_CHROMEREGISTRY_CONTRACTID);
30836:         if (reg) {
30836:             nsCAutoString package;
30836:             PRBool isChrome;
30836:             if (NS_SUCCEEDED(mDocumentURI->SchemeIs("chrome", &isChrome)) &&
30836:                 isChrome) {
30836:                 mDocumentURI->GetHostPort(package);
30836:             }
30836:             else {
30836:                 // use the 'global' package for about and resource uris.
30836:                 // otherwise, just default to left-to-right.
30836:                 PRBool isAbout, isResource;
30836:                 if (NS_SUCCEEDED(mDocumentURI->SchemeIs("about", &isAbout)) &&
30836:                     isAbout) {
30836:                     package.AssignLiteral("global");
30836:                 }
30836:                 else if (NS_SUCCEEDED(mDocumentURI->SchemeIs("resource", &isResource)) &&
30836:                     isResource) {
30836:                     package.AssignLiteral("global");
30836:                 }
30836:                 else {
30836:                     return PR_FALSE;
30836:                 }
30836:             }
30836: 
30836:             nsCAutoString locale;
30836:             reg->GetSelectedLocale(package, locale);
30836:             if (locale.Length() >= 2) {
30836:                 // first check the intl.uidirection.<locale> preference,
30836:                 // and if that is not set, check the same preference but
30836:                 // with just the first two characters of the locale. If
30836:                 // that isn't set, default to left-to-right.
30836:                 nsCAutoString prefString =
30836:                     NS_LITERAL_CSTRING("intl.uidirection.") + locale;
30836:                 nsAdoptingCString dir = nsContentUtils::GetCharPref(prefString.get());
30836:                 if (dir.IsEmpty()) {
30836:                     PRInt32 hyphen = prefString.FindChar('-');
30836:                     if (hyphen >= 1) {
30836:                         nsCAutoString shortPref(Substring(prefString, 0, hyphen));
30836:                         dir = nsContentUtils::GetCharPref(shortPref.get());
30836:                     }
30836:                 }
30836: 
30836:                 mDocDirection = dir.EqualsLiteral("rtl") ?
30836:                                 Direction_RightToLeft : Direction_LeftToRight;
30836:             }
30836:         }
30836:     }
30836: 
30836:     return (mDocDirection == Direction_RightToLeft);
30836: }
30836: 
30836: int
30836: nsXULDocument::DirectionChanged(const char* aPrefName, void* aData)
30836: {
30836:   // reset the direction and reflow the document. This will happen if
30836:   // the direction isn't actually being used, but that doesn't really
30836:   // matter too much
30836:   nsXULDocument* doc = (nsXULDocument *)aData;
30836:   if (doc)
30836:       doc->ResetDocumentDirection();
30836: 
30836:   nsIPresShell *shell = doc->GetPrimaryShell();
30836:   if (shell) {
30836:       shell->FrameConstructor()->
30836:           PostRestyleEvent(doc->GetRootContent(), eReStyle_Self, NS_STYLE_HINT_NONE);
30836:   }
30836: 
30836:   return 0;
30836: }
30836: 
33380: int
33380: nsXULDocument::GetDocumentLWTheme()
33380: {
33380:     if (mDocLWTheme == Doc_Theme_Uninitialized) {
33380:         mDocLWTheme = Doc_Theme_None; // No lightweight theme by default
33380: 
33380:         nsIContent* content = GetRootContent();
33380:         nsAutoString hasLWTheme;
33380:         if (content &&
33380:             content->GetAttr(kNameSpaceID_None, nsGkAtoms::lwtheme, hasLWTheme) &&
33380:             !(hasLWTheme.IsEmpty()) &&
33380:             hasLWTheme.EqualsLiteral("true")) {
33380:             nsAutoString lwTheme;
33380:             content->GetAttr(kNameSpaceID_None, nsGkAtoms::lwthemetextcolor, lwTheme);
33380:             if (!(lwTheme.IsEmpty())) {
33380:                 if (lwTheme.EqualsLiteral("dark"))
33380:                     mDocLWTheme = Doc_Theme_Dark;
33380:                 else if (lwTheme.EqualsLiteral("bright"))
33380:                     mDocLWTheme = Doc_Theme_Bright;
33380:             }
33380:         }
33380:     }
33380:     return mDocLWTheme;
33380: }
33380: 
26701: NS_IMETHODIMP
26701: nsXULDocument::GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult)
26701: {
26701:     return nsDocument::GetBoxObjectFor(aElement, aResult);
26701: }
