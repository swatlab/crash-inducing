80063: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
80063:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
80063:  *
80063:  * ***** BEGIN LICENSE BLOCK *****
80063:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
80063:  *
80063:  * The contents of this file are subject to the Mozilla Public License Version
80063:  * 1.1 (the "License"); you may not use this file except in compliance with
80063:  * the License. You may obtain a copy of the License at
80063:  * http://www.mozilla.org/MPL/
80063:  *
80063:  * Software distributed under the License is distributed on an "AS IS" basis,
80063:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
80063:  * for the specific language governing rights and limitations under the
80063:  * License.
80063:  *
80063:  * The Original Code is mozilla.org code, released
80063:  * June 24, 2010.
80063:  *
80063:  * The Initial Developer of the Original Code is
80063:  *    The Mozilla Foundation
80063:  *
80063:  * Contributor(s):
80063:  *    Andreas Gal <gal@mozilla.com>
80063:  *
80063:  * Alternatively, the contents of this file may be used under the terms of
80063:  * either of the GNU General Public License Version 2 or later (the "GPL"),
80063:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
80063:  * in which case the provisions of the GPL or the LGPL are applicable instead
80063:  * of those above. If you wish to allow use of your version of this file only
80063:  * under the terms of either the GPL or the LGPL, and not to allow others to
80063:  * use your version of this file under the terms of the MPL, indicate your
80063:  * decision by deleting the provisions above and replace them with the notice
80063:  * and other provisions required by the GPL or the LGPL. If you do not delete
80063:  * the provisions above, a recipient may use your version of this file under
80063:  * the terms of any one of the MPL, the GPL or the LGPL.
80063:  *
80063:  * ***** END LICENSE BLOCK ***** */
80063: 
80064: #ifndef dombindings_h
80064: #define dombindings_h
80064: 
80063: #include "jsapi.h"
80063: #include "jsproxy.h"
80074: #include "xpcpublic.h"
80063: 
80092: namespace mozilla {
80063: namespace dom {
80092: namespace binding {
80063: 
80081: inline nsWrapperCache*
80081: GetWrapperCache(nsWrapperCache *cache)
80081: {
80081:     return cache;
80081: }
80081: 
80081: // nsGlobalWindow implements nsWrapperCache, but doesn't always use it. Don't
80081: // try to use it without fixing that first.
80081: class nsGlobalWindow;
80081: inline nsWrapperCache*
80081: GetWrapperCache(nsGlobalWindow *not_allowed);
80081: 
80081: inline nsWrapperCache*
80081: GetWrapperCache(void *p)
80081: {
80081:     return nsnull;
80081: }
80081: 
80098: 
80079: class ProxyHandler : public js::ProxyHandler {
80079: protected:
80079:     ProxyHandler() : js::ProxyHandler(ProxyFamily())
80079:     {
80079:     }
80079: 
80068: public:
80079:     virtual bool isInstanceOf(JSObject *prototype) = 0;
80079: };
80079: 
80095: class NoType;
80095: class NoOp {
80095: public:
80095:     typedef NoType* T;
80095:     enum {
80095:         hasOp = 0
80095:     };
80095: };
80095: 
80095: template<typename Type>
80095: class Op {
80095: public:
80095:     typedef Type T;
80095:     enum {
80095:         hasOp = 1
80095:     };
80095: };
80095: 
80095: template<typename Type>
80095: class Getter : public Op<Type>
80095: {
80095: };
80095: 
80097: template<typename Type>
80097: class Setter : public Op<Type>
80097: {
80097: };
80097: 
80097: template<class Getter, class Setter=NoOp>
80095: class Ops
80095: {
80095: public:
80095:     typedef Getter G;
80097:     typedef Setter S;
80095: };
80095: 
80097: typedef Ops<NoOp, NoOp> NoOps;
80095: 
80096: template<class ListType, class Base, class IndexOps, class NameOps=NoOps>
80096: class DerivedListClass {
80095: public:
80095:     typedef ListType LT;
80096:     typedef Base B;
80095:     typedef IndexOps IO;
80095:     typedef NameOps NO;
80095: };
80095: 
80096: class NoBase {
80096: public:
80096:     static JSObject *getPrototype(JSContext *cx, XPCWrappedNativeScope *scope);
80096:     static bool shouldCacheProtoShape(JSContext *cx, JSObject *proto, bool *shouldCache)
80096:     {
80096:         *shouldCache = true;
80096:         return true;
80096:     }
80096:     static bool resolveNativeName(JSContext *cx, JSObject *proxy, jsid id, js::PropertyDescriptor *desc)
80096:     {
80096:         return true;
80096:     }
80096:     static bool nativeGet(JSContext *cx, JSObject *proxy, JSObject *proto, jsid id, bool *found,
80096:                           js::Value *vp)
80096:     {
80096:         *found = false;
80096:         return true;
80096:     }
80096: };
80096: 
80096: template<class ListType, class IndexOps, class NameOps=NoOps>
80096: class ListClass : public DerivedListClass<ListType, NoBase, IndexOps, NameOps> {
80096: };
80096: 
80095: template<class LC>
80093: class ListBase : public ProxyHandler {
80095: protected:
80095:     typedef typename LC::LT ListType;
80096:     typedef typename LC::B Base;
80095:     typedef typename LC::IO::G::T IndexGetterType;
80097:     typedef typename LC::IO::S::T IndexSetterType;
80095:     typedef typename LC::NO::G::T NameGetterType;
80097:     typedef typename LC::NO::S::T NameSetterType;
80095:     enum {
80095:         hasIndexGetter = LC::IO::G::hasOp,
80097:         hasIndexSetter = LC::IO::S::hasOp,
80097:         hasNameGetter = LC::NO::G::hasOp,
80097:         hasNameSetter = LC::NO::S::hasOp
80095:     };
80095: 
80095: private:
80079:     friend void Register(nsDOMClassInfoData *aData);
80079: 
80095:     static ListBase<LC> instance;
80063: 
80079:     static js::Class sInterfaceClass;
80070: 
80087:     struct Properties {
80087:         jsid &id;
80087:         JSPropertyOp getter;
80087:         JSStrictPropertyOp setter;
80087:     };
80070:     struct Methods {
80070:         jsid &id;
80070:         JSNative native;
80070:         uintN nargs;
80070:     };
80070: 
80087:     static Properties sProtoProperties[];
80070:     static Methods sProtoMethods[];
80068: 
80074:     static JSObject *ensureExpandoObject(JSContext *cx, JSObject *obj);
80074: 
80063:     static uint32 getProtoShape(JSObject *obj);
80063:     static void setProtoShape(JSObject *obj, uint32 shape);
80063: 
80087:     static JSBool length_getter(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
80066: 
80095:     static inline bool getItemAt(ListType *list, uint32 i, IndexGetterType &item);
81554:     static inline bool setItemAt(JSContext *cx, ListType *list, uint32 i, IndexSetterType item);
80076: 
80095:     static inline bool namedItem(JSContext *cx, JSObject *obj, jsval *name, NameGetterType &result,
80095:                                  bool *hasResult);
80095: 
80095:     static inline bool getNamedItem(ListType *list, const nsAString& aName, NameGetterType &item);
81554:     static inline bool setNamedItem(JSContext *cx, ListType *list, const nsAString& aName,
81554:                                     NameSetterType item);
80078: 
80100:     static bool getPropertyOnPrototype(JSContext *cx, JSObject *proxy, jsid id, bool *found,
80100:                                        js::Value *vp);
80100:     static bool hasPropertyOnPrototype(JSContext *cx, JSObject *proxy, jsid id);
80095: 
80098: public:
80096:     static JSObject *create(JSContext *cx, XPCWrappedNativeScope *scope, ListType *list,
80096:                             nsWrapperCache* cache, bool *triedToWrap);
80093: 
80096:     static JSObject *getPrototype(JSContext *cx, XPCWrappedNativeScope *scope, bool *enabled);
80096: 
80063:     bool getPropertyDescriptor(JSContext *cx, JSObject *proxy, jsid id, bool set,
80063:                                js::PropertyDescriptor *desc);
80063:     bool getOwnPropertyDescriptor(JSContext *cx, JSObject *proxy, jsid id, bool set,
80063:                                   js::PropertyDescriptor *desc);
80063:     bool defineProperty(JSContext *cx, JSObject *proxy, jsid id,
80063:                         js::PropertyDescriptor *desc);
80063:     bool getOwnPropertyNames(JSContext *cx, JSObject *proxy, js::AutoIdVector &props);
80063:     bool delete_(JSContext *cx, JSObject *proxy, jsid id, bool *bp);
80063:     bool enumerate(JSContext *cx, JSObject *proxy, js::AutoIdVector &props);
80063:     bool fix(JSContext *cx, JSObject *proxy, js::Value *vp);
80063: 
80063:     bool has(JSContext *cx, JSObject *proxy, jsid id, bool *bp);
80063:     bool hasOwn(JSContext *cx, JSObject *proxy, jsid id, bool *bp);
80063:     bool get(JSContext *cx, JSObject *proxy, JSObject *receiver, jsid id, js::Value *vp);
81420:     bool getElementIfPresent(JSContext *cx, JSObject *proxy, JSObject *receiver,
81420:                              uint32 index, js::Value *vp, bool *present);
80063:     bool set(JSContext *cx, JSObject *proxy, JSObject *receiver, jsid id, bool strict,
80063:              js::Value *vp);
80063:     bool keys(JSContext *cx, JSObject *proxy, js::AutoIdVector &props);
80063:     bool iterate(JSContext *cx, JSObject *proxy, uintN flags, js::Value *vp);
80063: 
80063:     /* Spidermonkey extensions. */
80063:     bool hasInstance(JSContext *cx, JSObject *proxy, const js::Value *vp, bool *bp);
80063:     JSString *obj_toString(JSContext *cx, JSObject *proxy);
80063:     void finalize(JSContext *cx, JSObject *proxy);
80063: 
80096:     static bool proxyHandlerIsList(js::ProxyHandler *handler) {
80096:         return handler == &instance;
80096:     }
80093:     static bool objIsList(JSObject *obj) {
80096:         return js::IsProxy(obj) && proxyHandlerIsList(js::GetProxyHandler(obj));
80064:     }
80095:     static bool instanceIsListObject(JSContext *cx, JSObject *obj, JSObject *callee);
80079:     virtual bool isInstanceOf(JSObject *prototype)
80079:     {
80079:         return js::GetObjectClass(prototype) == &sInterfaceClass;
80079:     }
80095:     static ListType *getListObject(JSObject *obj);
80095: 
80096:     static JSObject *getPrototype(JSContext *cx, XPCWrappedNativeScope *scope);
80096:     static bool shouldCacheProtoShape(JSContext *cx, JSObject *proto, bool *shouldCache);
80096:     static bool resolveNativeName(JSContext *cx, JSObject *proxy, jsid id,
80096:                                   js::PropertyDescriptor *desc);
80095:     static bool nativeGet(JSContext *cx, JSObject *proxy, JSObject *proto, jsid id, bool *found,
80095:                           js::Value *vp);
80096:     static ListType *getNative(JSObject *proxy);
80093: };
80093: 
80095: struct nsISupportsResult
80093: {
80095:     nsISupportsResult()
80095:     {
80095:     }
80095:     nsISupports *mResult;
80095:     nsWrapperCache *mCache;
80093: };
80095: 
80063: }
80063: }
80092: }
80064: 
80098: #include "dombindings_gen.h"
80098: 
80064: #endif /* dombindings_h */
