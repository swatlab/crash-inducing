16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: channel mapping 0 implementation
31034:  last mod: $Id: mapping0.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: #include <stdlib.h>
16295: #include <stdio.h>
16295: #include <string.h>
16295: #include <math.h>
16295: #include <ogg/ogg.h>
16295: #include "vorbis/codec.h"
16295: #include "codec_internal.h"
16295: #include "codebook.h"
16295: #include "window.h"
16295: #include "registry.h"
16295: #include "psy.h"
16295: #include "misc.h"
16295: 
16295: /* simplistic, wasteful way of doing this (unique lookup for each
16295:    mode/submapping); there should be a central repository for
16295:    identical lookups.  That will require minor work, so I'm putting it
16295:    off as low priority.
16295: 
16295:    Why a lookup for each backend in a given mode?  Because the
16295:    blocksize is set by the mode, and low backend lookups may require
16295:    parameters from other areas of the mode/mapping */
16295: 
16295: static void mapping0_free_info(vorbis_info_mapping *i){
16295:   vorbis_info_mapping0 *info=(vorbis_info_mapping0 *)i;
16295:   if(info){
16295:     memset(info,0,sizeof(*info));
16295:     _ogg_free(info);
16295:   }
16295: }
16295: 
16295: static int ilog(unsigned int v){
16295:   int ret=0;
16295:   if(v)--v;
16295:   while(v){
16295:     ret++;
16295:     v>>=1;
16295:   }
16295:   return(ret);
16295: }
16295: 
16295: static void mapping0_pack(vorbis_info *vi,vorbis_info_mapping *vm,
16295:                           oggpack_buffer *opb){
16295:   int i;
16295:   vorbis_info_mapping0 *info=(vorbis_info_mapping0 *)vm;
16295: 
16295:   /* another 'we meant to do it this way' hack...  up to beta 4, we
16295:      packed 4 binary zeros here to signify one submapping in use.  We
16295:      now redefine that to mean four bitflags that indicate use of
16295:      deeper features; bit0:submappings, bit1:coupling,
16295:      bit2,3:reserved. This is backward compatable with all actual uses
16295:      of the beta code. */
16295: 
16295:   if(info->submaps>1){
16295:     oggpack_write(opb,1,1);
16295:     oggpack_write(opb,info->submaps-1,4);
16295:   }else
16295:     oggpack_write(opb,0,1);
16295: 
16295:   if(info->coupling_steps>0){
16295:     oggpack_write(opb,1,1);
16295:     oggpack_write(opb,info->coupling_steps-1,8);
16295: 
16295:     for(i=0;i<info->coupling_steps;i++){
16295:       oggpack_write(opb,info->coupling_mag[i],ilog(vi->channels));
16295:       oggpack_write(opb,info->coupling_ang[i],ilog(vi->channels));
16295:     }
16295:   }else
16295:     oggpack_write(opb,0,1);
16295: 
16295:   oggpack_write(opb,0,2); /* 2,3:reserved */
16295: 
16295:   /* we don't write the channel submappings if we only have one... */
16295:   if(info->submaps>1){
16295:     for(i=0;i<vi->channels;i++)
16295:       oggpack_write(opb,info->chmuxlist[i],4);
16295:   }
16295:   for(i=0;i<info->submaps;i++){
16295:     oggpack_write(opb,0,8); /* time submap unused */
16295:     oggpack_write(opb,info->floorsubmap[i],8);
16295:     oggpack_write(opb,info->residuesubmap[i],8);
16295:   }
16295: }
16295: 
16295: /* also responsible for range checking */
16295: static vorbis_info_mapping *mapping0_unpack(vorbis_info *vi,oggpack_buffer *opb){
31034:   int i,b;
16295:   vorbis_info_mapping0 *info=_ogg_calloc(1,sizeof(*info));
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   memset(info,0,sizeof(*info));
16295: 
31034:   b=oggpack_read(opb,1);
31034:   if(b<0)goto err_out;
31034:   if(b){
16295:     info->submaps=oggpack_read(opb,4)+1;
31034:     if(info->submaps<=0)goto err_out;
31034:   }else
16295:     info->submaps=1;
16295: 
31034:   b=oggpack_read(opb,1);
31034:   if(b<0)goto err_out;
31034:   if(b){
16295:     info->coupling_steps=oggpack_read(opb,8)+1;
31034:     if(info->coupling_steps<=0)goto err_out;
16295:     for(i=0;i<info->coupling_steps;i++){
16295:       int testM=info->coupling_mag[i]=oggpack_read(opb,ilog(vi->channels));
16295:       int testA=info->coupling_ang[i]=oggpack_read(opb,ilog(vi->channels));
16295: 
16295:       if(testM<0 ||
16295:          testA<0 ||
16295:          testM==testA ||
16295:          testM>=vi->channels ||
16295:          testA>=vi->channels) goto err_out;
16295:     }
16295: 
16295:   }
16295: 
31034:   if(oggpack_read(opb,2)!=0)goto err_out; /* 2,3:reserved */
16295: 
16295:   if(info->submaps>1){
16295:     for(i=0;i<vi->channels;i++){
16295:       info->chmuxlist[i]=oggpack_read(opb,4);
31034:       if(info->chmuxlist[i]>=info->submaps || info->chmuxlist[i]<0)goto err_out;
16295:     }
16295:   }
16295:   for(i=0;i<info->submaps;i++){
16295:     oggpack_read(opb,8); /* time submap unused */
16295:     info->floorsubmap[i]=oggpack_read(opb,8);
31034:     if(info->floorsubmap[i]>=ci->floors || info->floorsubmap[i]<0)goto err_out;
16295:     info->residuesubmap[i]=oggpack_read(opb,8);
31034:     if(info->residuesubmap[i]>=ci->residues || info->residuesubmap[i]<0)goto err_out;
16295:   }
16295: 
16295:   return info;
16295: 
16295:  err_out:
16295:   mapping0_free_info(info);
16295:   return(NULL);
16295: }
16295: 
16295: #include "os.h"
16295: #include "lpc.h"
16295: #include "lsp.h"
16295: #include "envelope.h"
16295: #include "mdct.h"
16295: #include "psy.h"
16295: #include "scales.h"
16295: 
16295: #if 0
16295: static long seq=0;
16295: static ogg_int64_t total=0;
16295: static float FLOOR1_fromdB_LOOKUP[256]={
16295:   1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
16295:   1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
16295:   1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
16295:   2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
16295:   2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
16295:   3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
16295:   4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
16295:   6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
16295:   7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
16295:   1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
16295:   1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
16295:   1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
16295:   2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
16295:   2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
16295:   3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
16295:   4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
16295:   5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
16295:   7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
16295:   9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
16295:   1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
16295:   1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
16295:   2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
16295:   2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
16295:   3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
16295:   4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
16295:   5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
16295:   7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
16295:   9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
16295:   0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
16295:   0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
16295:   0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
16295:   0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
16295:   0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
16295:   0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
16295:   0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
16295:   0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
16295:   0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F,
16295:   0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F,
16295:   0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F,
16295:   0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F,
16295:   0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F,
16295:   0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F,
16295:   0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F,
16295:   0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F,
16295:   0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F,
16295:   0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F,
16295:   0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F,
16295:   0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F,
16295:   0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F,
16295:   0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F,
16295:   0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F,
16295:   0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F,
16295:   0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F,
16295:   0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F,
16295:   0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F,
16295:   0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F,
16295:   0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F,
16295:   0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F,
16295:   0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F,
16295:   0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F,
16295:   0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F,
16295:   0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F,
16295:   0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F,
16295:   0.82788260F, 0.88168307F, 0.9389798F, 1.F,
16295: };
16295: 
16295: #endif
16295: 
16295: 
16295: static int mapping0_forward(vorbis_block *vb){
16295:   vorbis_dsp_state      *vd=vb->vd;
16295:   vorbis_info           *vi=vd->vi;
16295:   codec_setup_info      *ci=vi->codec_setup;
16295:   private_state         *b=vb->vd->backend_state;
16295:   vorbis_block_internal *vbi=(vorbis_block_internal *)vb->internal;
16295:   int                    n=vb->pcmend;
16295:   int i,j,k;
16295: 
16295:   int    *nonzero    = alloca(sizeof(*nonzero)*vi->channels);
16295:   float  **gmdct     = _vorbis_block_alloc(vb,vi->channels*sizeof(*gmdct));
16295:   int    **ilogmaskch= _vorbis_block_alloc(vb,vi->channels*sizeof(*ilogmaskch));
16295:   int ***floor_posts = _vorbis_block_alloc(vb,vi->channels*sizeof(*floor_posts));
16295: 
16295:   float global_ampmax=vbi->ampmax;
16295:   float *local_ampmax=alloca(sizeof(*local_ampmax)*vi->channels);
16295:   int blocktype=vbi->blocktype;
16295: 
16295:   int modenumber=vb->W;
16295:   vorbis_info_mapping0 *info=ci->map_param[modenumber];
16295:   vorbis_look_psy *psy_look=
16295:     b->psy+blocktype+(vb->W?2:0);
16295: 
16295:   vb->mode=modenumber;
16295: 
16295:   for(i=0;i<vi->channels;i++){
16295:     float scale=4.f/n;
16295:     float scale_dB;
16295: 
16295:     float *pcm     =vb->pcm[i];
16295:     float *logfft  =pcm;
16295: 
16295:     gmdct[i]=_vorbis_block_alloc(vb,n/2*sizeof(**gmdct));
16295: 
16295:     scale_dB=todB(&scale) + .345; /* + .345 is a hack; the original
16295:                                      todB estimation used on IEEE 754
16295:                                      compliant machines had a bug that
16295:                                      returned dB values about a third
16295:                                      of a decibel too high.  The bug
16295:                                      was harmless because tunings
16295:                                      implicitly took that into
16295:                                      account.  However, fixing the bug
16295:                                      in the estimator requires
16295:                                      changing all the tunings as well.
16295:                                      For now, it's easier to sync
16295:                                      things back up here, and
16295:                                      recalibrate the tunings in the
16295:                                      next major model upgrade. */
16295: 
16295: #if 0
30043:     if(vi->channels==2){
16295:       if(i==0)
16295:         _analysis_output("pcmL",seq,pcm,n,0,0,total-n/2);
16295:       else
16295:         _analysis_output("pcmR",seq,pcm,n,0,0,total-n/2);
30043:     }else{
30043:       _analysis_output("pcm",seq,pcm,n,0,0,total-n/2);
30043:     }
16295: #endif
16295: 
16295:     /* window the PCM data */
16295:     _vorbis_apply_window(pcm,b->window,ci->blocksizes,vb->lW,vb->W,vb->nW);
16295: 
16295: #if 0
30043:     if(vi->channels==2){
16295:       if(i==0)
16295:         _analysis_output("windowedL",seq,pcm,n,0,0,total-n/2);
16295:       else
16295:         _analysis_output("windowedR",seq,pcm,n,0,0,total-n/2);
30043:     }else{
30043:       _analysis_output("windowed",seq,pcm,n,0,0,total-n/2);
30043:     }
16295: #endif
16295: 
16295:     /* transform the PCM data */
16295:     /* only MDCT right now.... */
16295:     mdct_forward(b->transform[vb->W][0],pcm,gmdct[i]);
16295: 
16295:     /* FFT yields more accurate tonal estimation (not phase sensitive) */
16295:     drft_forward(&b->fft_look[vb->W],pcm);
16295:     logfft[0]=scale_dB+todB(pcm)  + .345; /* + .345 is a hack; the
16295:                                      original todB estimation used on
16295:                                      IEEE 754 compliant machines had a
16295:                                      bug that returned dB values about
16295:                                      a third of a decibel too high.
16295:                                      The bug was harmless because
16295:                                      tunings implicitly took that into
16295:                                      account.  However, fixing the bug
16295:                                      in the estimator requires
16295:                                      changing all the tunings as well.
16295:                                      For now, it's easier to sync
16295:                                      things back up here, and
16295:                                      recalibrate the tunings in the
16295:                                      next major model upgrade. */
16295:     local_ampmax[i]=logfft[0];
16295:     for(j=1;j<n-1;j+=2){
16295:       float temp=pcm[j]*pcm[j]+pcm[j+1]*pcm[j+1];
16295:       temp=logfft[(j+1)>>1]=scale_dB+.5f*todB(&temp)  + .345; /* +
16295:                                      .345 is a hack; the original todB
16295:                                      estimation used on IEEE 754
16295:                                      compliant machines had a bug that
16295:                                      returned dB values about a third
16295:                                      of a decibel too high.  The bug
16295:                                      was harmless because tunings
16295:                                      implicitly took that into
16295:                                      account.  However, fixing the bug
16295:                                      in the estimator requires
16295:                                      changing all the tunings as well.
16295:                                      For now, it's easier to sync
16295:                                      things back up here, and
16295:                                      recalibrate the tunings in the
16295:                                      next major model upgrade. */
16295:       if(temp>local_ampmax[i])local_ampmax[i]=temp;
16295:     }
16295: 
16295:     if(local_ampmax[i]>0.f)local_ampmax[i]=0.f;
16295:     if(local_ampmax[i]>global_ampmax)global_ampmax=local_ampmax[i];
16295: 
16295: #if 0
16295:     if(vi->channels==2){
16295:       if(i==0){
16295:         _analysis_output("fftL",seq,logfft,n/2,1,0,0);
16295:       }else{
16295:         _analysis_output("fftR",seq,logfft,n/2,1,0,0);
16295:       }
30043:     }else{
30043:       _analysis_output("fft",seq,logfft,n/2,1,0,0);
16295:     }
16295: #endif
16295: 
16295:   }
16295: 
16295:   {
16295:     float   *noise        = _vorbis_block_alloc(vb,n/2*sizeof(*noise));
16295:     float   *tone         = _vorbis_block_alloc(vb,n/2*sizeof(*tone));
16295: 
16295:     for(i=0;i<vi->channels;i++){
16295:       /* the encoder setup assumes that all the modes used by any
16295:          specific bitrate tweaking use the same floor */
16295: 
16295:       int submap=info->chmuxlist[i];
16295: 
16295:       /* the following makes things clearer to *me* anyway */
16295:       float *mdct    =gmdct[i];
16295:       float *logfft  =vb->pcm[i];
16295: 
16295:       float *logmdct =logfft+n/2;
16295:       float *logmask =logfft;
16295: 
16295:       vb->mode=modenumber;
16295: 
16295:       floor_posts[i]=_vorbis_block_alloc(vb,PACKETBLOBS*sizeof(**floor_posts));
16295:       memset(floor_posts[i],0,sizeof(**floor_posts)*PACKETBLOBS);
16295: 
16295:       for(j=0;j<n/2;j++)
16295:         logmdct[j]=todB(mdct+j)  + .345; /* + .345 is a hack; the original
16295:                                      todB estimation used on IEEE 754
16295:                                      compliant machines had a bug that
16295:                                      returned dB values about a third
16295:                                      of a decibel too high.  The bug
16295:                                      was harmless because tunings
16295:                                      implicitly took that into
16295:                                      account.  However, fixing the bug
16295:                                      in the estimator requires
16295:                                      changing all the tunings as well.
16295:                                      For now, it's easier to sync
16295:                                      things back up here, and
16295:                                      recalibrate the tunings in the
16295:                                      next major model upgrade. */
16295: 
16295: #if 0
16295:       if(vi->channels==2){
16295:         if(i==0)
16295:           _analysis_output("mdctL",seq,logmdct,n/2,1,0,0);
16295:         else
16295:           _analysis_output("mdctR",seq,logmdct,n/2,1,0,0);
16295:       }else{
16295:         _analysis_output("mdct",seq,logmdct,n/2,1,0,0);
16295:       }
16295: #endif
16295: 
16295:       /* first step; noise masking.  Not only does 'noise masking'
16295:          give us curves from which we can decide how much resolution
16295:          to give noise parts of the spectrum, it also implicitly hands
16295:          us a tonality estimate (the larger the value in the
16295:          'noise_depth' vector, the more tonal that area is) */
16295: 
16295:       _vp_noisemask(psy_look,
16295:                     logmdct,
16295:                     noise); /* noise does not have by-frequency offset
16295:                                bias applied yet */
16295: #if 0
16295:       if(vi->channels==2){
16295:         if(i==0)
16295:           _analysis_output("noiseL",seq,noise,n/2,1,0,0);
16295:         else
16295:           _analysis_output("noiseR",seq,noise,n/2,1,0,0);
30043:       }else{
30043:         _analysis_output("noise",seq,noise,n/2,1,0,0);
16295:       }
16295: #endif
16295: 
16295:       /* second step: 'all the other crap'; all the stuff that isn't
16295:          computed/fit for bitrate management goes in the second psy
16295:          vector.  This includes tone masking, peak limiting and ATH */
16295: 
16295:       _vp_tonemask(psy_look,
16295:                    logfft,
16295:                    tone,
16295:                    global_ampmax,
16295:                    local_ampmax[i]);
16295: 
16295: #if 0
16295:       if(vi->channels==2){
16295:         if(i==0)
16295:           _analysis_output("toneL",seq,tone,n/2,1,0,0);
16295:         else
16295:           _analysis_output("toneR",seq,tone,n/2,1,0,0);
30043:       }else{
30043:         _analysis_output("tone",seq,tone,n/2,1,0,0);
16295:       }
16295: #endif
16295: 
16295:       /* third step; we offset the noise vectors, overlay tone
16295:          masking.  We then do a floor1-specific line fit.  If we're
16295:          performing bitrate management, the line fit is performed
16295:          multiple times for up/down tweakage on demand. */
16295: 
16295: #if 0
16295:       {
16295:       float aotuv[psy_look->n];
16295: #endif
16295: 
16295:         _vp_offset_and_mix(psy_look,
16295:                            noise,
16295:                            tone,
16295:                            1,
16295:                            logmask,
16295:                            mdct,
16295:                            logmdct);
16295: 
16295: #if 0
16295:         if(vi->channels==2){
16295:           if(i==0)
16295:             _analysis_output("aotuvM1_L",seq,aotuv,psy_look->n,1,1,0);
16295:           else
16295:             _analysis_output("aotuvM1_R",seq,aotuv,psy_look->n,1,1,0);
30043:         }else{
30043:           _analysis_output("aotuvM1",seq,aotuv,psy_look->n,1,1,0);
16295:         }
16295:       }
16295: #endif
16295: 
16295: 
16295: #if 0
16295:       if(vi->channels==2){
16295:         if(i==0)
16295:           _analysis_output("mask1L",seq,logmask,n/2,1,0,0);
16295:         else
16295:           _analysis_output("mask1R",seq,logmask,n/2,1,0,0);
30043:       }else{
30043:         _analysis_output("mask1",seq,logmask,n/2,1,0,0);
16295:       }
16295: #endif
16295: 
16295:       /* this algorithm is hardwired to floor 1 for now; abort out if
16295:          we're *not* floor1.  This won't happen unless someone has
16295:          broken the encode setup lib.  Guard it anyway. */
16295:       if(ci->floor_type[info->floorsubmap[submap]]!=1)return(-1);
16295: 
16295:       floor_posts[i][PACKETBLOBS/2]=
16295:         floor1_fit(vb,b->flr[info->floorsubmap[submap]],
16295:                    logmdct,
16295:                    logmask);
16295: 
16295:       /* are we managing bitrate?  If so, perform two more fits for
16295:          later rate tweaking (fits represent hi/lo) */
16295:       if(vorbis_bitrate_managed(vb) && floor_posts[i][PACKETBLOBS/2]){
16295:         /* higher rate by way of lower noise curve */
16295: 
16295:         _vp_offset_and_mix(psy_look,
16295:                            noise,
16295:                            tone,
16295:                            2,
16295:                            logmask,
16295:                            mdct,
16295:                            logmdct);
16295: 
16295: #if 0
16295:         if(vi->channels==2){
16295:           if(i==0)
16295:             _analysis_output("mask2L",seq,logmask,n/2,1,0,0);
16295:           else
16295:             _analysis_output("mask2R",seq,logmask,n/2,1,0,0);
30043:         }else{
30043:           _analysis_output("mask2",seq,logmask,n/2,1,0,0);
16295:         }
16295: #endif
16295: 
16295:         floor_posts[i][PACKETBLOBS-1]=
16295:           floor1_fit(vb,b->flr[info->floorsubmap[submap]],
16295:                      logmdct,
16295:                      logmask);
16295: 
16295:         /* lower rate by way of higher noise curve */
16295:         _vp_offset_and_mix(psy_look,
16295:                            noise,
16295:                            tone,
16295:                            0,
16295:                            logmask,
16295:                            mdct,
16295:                            logmdct);
16295: 
16295: #if 0
30043:         if(vi->channels==2){
16295:           if(i==0)
16295:             _analysis_output("mask0L",seq,logmask,n/2,1,0,0);
16295:           else
16295:             _analysis_output("mask0R",seq,logmask,n/2,1,0,0);
30043:         }else{
30043:           _analysis_output("mask0",seq,logmask,n/2,1,0,0);
30043:         }
16295: #endif
16295: 
16295:         floor_posts[i][0]=
16295:           floor1_fit(vb,b->flr[info->floorsubmap[submap]],
16295:                      logmdct,
16295:                      logmask);
16295: 
16295:         /* we also interpolate a range of intermediate curves for
16295:            intermediate rates */
16295:         for(k=1;k<PACKETBLOBS/2;k++)
16295:           floor_posts[i][k]=
16295:             floor1_interpolate_fit(vb,b->flr[info->floorsubmap[submap]],
16295:                                    floor_posts[i][0],
16295:                                    floor_posts[i][PACKETBLOBS/2],
16295:                                    k*65536/(PACKETBLOBS/2));
16295:         for(k=PACKETBLOBS/2+1;k<PACKETBLOBS-1;k++)
16295:           floor_posts[i][k]=
16295:             floor1_interpolate_fit(vb,b->flr[info->floorsubmap[submap]],
16295:                                    floor_posts[i][PACKETBLOBS/2],
16295:                                    floor_posts[i][PACKETBLOBS-1],
16295:                                    (k-PACKETBLOBS/2)*65536/(PACKETBLOBS/2));
16295:       }
16295:     }
16295:   }
16295:   vbi->ampmax=global_ampmax;
16295: 
16295:   /*
16295:     the next phases are performed once for vbr-only and PACKETBLOB
16295:     times for bitrate managed modes.
16295: 
16295:     1) encode actual mode being used
16295:     2) encode the floor for each channel, compute coded mask curve/res
16295:     3) normalize and couple.
16295:     4) encode residue
16295:     5) save packet bytes to the packetblob vector
16295: 
16295:   */
16295: 
16295:   /* iterate over the many masking curve fits we've created */
16295: 
16295:   {
16295:     float **res_bundle=alloca(sizeof(*res_bundle)*vi->channels);
16295:     float **couple_bundle=alloca(sizeof(*couple_bundle)*vi->channels);
16295:     int *zerobundle=alloca(sizeof(*zerobundle)*vi->channels);
16295:     int **sortindex=alloca(sizeof(*sortindex)*vi->channels);
30043:     float **mag_memo=NULL;
30043:     int **mag_sort=NULL;
16295: 
16295:     if(info->coupling_steps){
16295:       mag_memo=_vp_quantize_couple_memo(vb,
16295:                                         &ci->psy_g_param,
16295:                                         psy_look,
16295:                                         info,
16295:                                         gmdct);
16295: 
16295:       mag_sort=_vp_quantize_couple_sort(vb,
16295:                                         psy_look,
16295:                                         info,
16295:                                         mag_memo);
16295: 
16295:       hf_reduction(&ci->psy_g_param,
16295:                    psy_look,
16295:                    info,
16295:                    mag_memo);
16295:     }
16295: 
16295:     memset(sortindex,0,sizeof(*sortindex)*vi->channels);
16295:     if(psy_look->vi->normal_channel_p){
16295:       for(i=0;i<vi->channels;i++){
16295:         float *mdct    =gmdct[i];
16295:         sortindex[i]=alloca(sizeof(**sortindex)*n/2);
16295:         _vp_noise_normalize_sort(psy_look,mdct,sortindex[i]);
16295:       }
16295:     }
16295: 
16295:     for(k=(vorbis_bitrate_managed(vb)?0:PACKETBLOBS/2);
16295:         k<=(vorbis_bitrate_managed(vb)?PACKETBLOBS-1:PACKETBLOBS/2);
16295:         k++){
16295:       oggpack_buffer *opb=vbi->packetblob[k];
16295: 
16295:       /* start out our new packet blob with packet type and mode */
16295:       /* Encode the packet type */
16295:       oggpack_write(opb,0,1);
16295:       /* Encode the modenumber */
16295:       /* Encode frame mode, pre,post windowsize, then dispatch */
16295:       oggpack_write(opb,modenumber,b->modebits);
16295:       if(vb->W){
16295:         oggpack_write(opb,vb->lW,1);
16295:         oggpack_write(opb,vb->nW,1);
16295:       }
16295: 
16295:       /* encode floor, compute masking curve, sep out residue */
16295:       for(i=0;i<vi->channels;i++){
16295:         int submap=info->chmuxlist[i];
16295:         float *mdct    =gmdct[i];
16295:         float *res     =vb->pcm[i];
16295:         int   *ilogmask=ilogmaskch[i]=
16295:           _vorbis_block_alloc(vb,n/2*sizeof(**gmdct));
16295: 
16295:         nonzero[i]=floor1_encode(opb,vb,b->flr[info->floorsubmap[submap]],
16295:                                  floor_posts[i][k],
16295:                                  ilogmask);
16295: #if 0
16295:         {
16295:           char buf[80];
16295:           sprintf(buf,"maskI%c%d",i?'R':'L',k);
16295:           float work[n/2];
16295:           for(j=0;j<n/2;j++)
16295:             work[j]=FLOOR1_fromdB_LOOKUP[ilogmask[j]];
16295:           _analysis_output(buf,seq,work,n/2,1,1,0);
16295:         }
16295: #endif
16295:         _vp_remove_floor(psy_look,
16295:                          mdct,
16295:                          ilogmask,
16295:                          res,
16295:                          ci->psy_g_param.sliding_lowpass[vb->W][k]);
16295: 
16295:         _vp_noise_normalize(psy_look,res,res+n/2,sortindex[i]);
16295: 
16295: 
16295: #if 0
16295:         {
16295:           char buf[80];
16295:           float work[n/2];
16295:           for(j=0;j<n/2;j++)
16295:             work[j]=FLOOR1_fromdB_LOOKUP[ilogmask[j]]*(res+n/2)[j];
16295:           sprintf(buf,"resI%c%d",i?'R':'L',k);
16295:           _analysis_output(buf,seq,work,n/2,1,1,0);
16295: 
16295:         }
16295: #endif
16295:       }
16295: 
16295:       /* our iteration is now based on masking curve, not prequant and
16295:          coupling.  Only one prequant/coupling step */
16295: 
16295:       /* quantize/couple */
16295:       /* incomplete implementation that assumes the tree is all depth
16295:          one, or no tree at all */
16295:       if(info->coupling_steps){
16295:         _vp_couple(k,
16295:                    &ci->psy_g_param,
16295:                    psy_look,
16295:                    info,
16295:                    vb->pcm,
16295:                    mag_memo,
16295:                    mag_sort,
16295:                    ilogmaskch,
16295:                    nonzero,
16295:                    ci->psy_g_param.sliding_lowpass[vb->W][k]);
16295:       }
16295: 
16295:       /* classify and encode by submap */
16295:       for(i=0;i<info->submaps;i++){
16295:         int ch_in_bundle=0;
16295:         long **classifications;
16295:         int resnum=info->residuesubmap[i];
16295: 
16295:         for(j=0;j<vi->channels;j++){
16295:           if(info->chmuxlist[j]==i){
16295:             zerobundle[ch_in_bundle]=0;
16295:             if(nonzero[j])zerobundle[ch_in_bundle]=1;
16295:             res_bundle[ch_in_bundle]=vb->pcm[j];
16295:             couple_bundle[ch_in_bundle++]=vb->pcm[j]+n/2;
16295:           }
16295:         }
16295: 
16295:         classifications=_residue_P[ci->residue_type[resnum]]->
16295:           class(vb,b->residue[resnum],couple_bundle,zerobundle,ch_in_bundle);
16295: 
30043:         /* couple_bundle is destructively overwritten by
30043:            the class function if some but not all of the channels are
30043:            marked as silence; build a fresh copy */
30043:         ch_in_bundle=0;
30043:         for(j=0;j<vi->channels;j++)
30043:           if(info->chmuxlist[j]==i)
30043:             couple_bundle[ch_in_bundle++]=vb->pcm[j]+n/2;
30043: 
16295:         _residue_P[ci->residue_type[resnum]]->
16295:           forward(opb,vb,b->residue[resnum],
16295:                   couple_bundle,NULL,zerobundle,ch_in_bundle,classifications);
16295:       }
16295: 
16295:       /* ok, done encoding.  Next protopacket. */
16295:     }
16295: 
16295:   }
16295: 
16295: #if 0
16295:   seq++;
16295:   total+=ci->blocksizes[vb->W]/4+ci->blocksizes[vb->nW]/4;
16295: #endif
16295:   return(0);
16295: }
16295: 
16295: static int mapping0_inverse(vorbis_block *vb,vorbis_info_mapping *l){
16295:   vorbis_dsp_state     *vd=vb->vd;
16295:   vorbis_info          *vi=vd->vi;
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   private_state        *b=vd->backend_state;
16295:   vorbis_info_mapping0 *info=(vorbis_info_mapping0 *)l;
16295: 
16295:   int                   i,j;
16295:   long                  n=vb->pcmend=ci->blocksizes[vb->W];
16295: 
16295:   float **pcmbundle=alloca(sizeof(*pcmbundle)*vi->channels);
16295:   int    *zerobundle=alloca(sizeof(*zerobundle)*vi->channels);
16295: 
16295:   int   *nonzero  =alloca(sizeof(*nonzero)*vi->channels);
16295:   void **floormemo=alloca(sizeof(*floormemo)*vi->channels);
16295: 
16295:   /* recover the spectral envelope; store it in the PCM vector for now */
16295:   for(i=0;i<vi->channels;i++){
16295:     int submap=info->chmuxlist[i];
16295:     floormemo[i]=_floor_P[ci->floor_type[info->floorsubmap[submap]]]->
16295:       inverse1(vb,b->flr[info->floorsubmap[submap]]);
16295:     if(floormemo[i])
16295:       nonzero[i]=1;
16295:     else
16295:       nonzero[i]=0;
16295:     memset(vb->pcm[i],0,sizeof(*vb->pcm[i])*n/2);
16295:   }
16295: 
16295:   /* channel coupling can 'dirty' the nonzero listing */
16295:   for(i=0;i<info->coupling_steps;i++){
16295:     if(nonzero[info->coupling_mag[i]] ||
16295:        nonzero[info->coupling_ang[i]]){
16295:       nonzero[info->coupling_mag[i]]=1;
16295:       nonzero[info->coupling_ang[i]]=1;
16295:     }
16295:   }
16295: 
16295:   /* recover the residue into our working vectors */
16295:   for(i=0;i<info->submaps;i++){
16295:     int ch_in_bundle=0;
16295:     for(j=0;j<vi->channels;j++){
16295:       if(info->chmuxlist[j]==i){
16295:         if(nonzero[j])
16295:           zerobundle[ch_in_bundle]=1;
16295:         else
16295:           zerobundle[ch_in_bundle]=0;
16295:         pcmbundle[ch_in_bundle++]=vb->pcm[j];
16295:       }
16295:     }
16295: 
16295:     _residue_P[ci->residue_type[info->residuesubmap[i]]]->
16295:       inverse(vb,b->residue[info->residuesubmap[i]],
16295:               pcmbundle,zerobundle,ch_in_bundle);
16295:   }
16295: 
16295:   /* channel coupling */
16295:   for(i=info->coupling_steps-1;i>=0;i--){
16295:     float *pcmM=vb->pcm[info->coupling_mag[i]];
16295:     float *pcmA=vb->pcm[info->coupling_ang[i]];
16295: 
16295:     for(j=0;j<n/2;j++){
16295:       float mag=pcmM[j];
16295:       float ang=pcmA[j];
16295: 
16295:       if(mag>0)
16295:         if(ang>0){
16295:           pcmM[j]=mag;
16295:           pcmA[j]=mag-ang;
16295:         }else{
16295:           pcmA[j]=mag;
16295:           pcmM[j]=mag+ang;
16295:         }
16295:       else
16295:         if(ang>0){
16295:           pcmM[j]=mag;
16295:           pcmA[j]=mag+ang;
16295:         }else{
16295:           pcmA[j]=mag;
16295:           pcmM[j]=mag-ang;
16295:         }
16295:     }
16295:   }
16295: 
16295:   /* compute and apply spectral envelope */
16295:   for(i=0;i<vi->channels;i++){
16295:     float *pcm=vb->pcm[i];
16295:     int submap=info->chmuxlist[i];
16295:     _floor_P[ci->floor_type[info->floorsubmap[submap]]]->
16295:       inverse2(vb,b->flr[info->floorsubmap[submap]],
16295:                floormemo[i],pcm);
16295:   }
16295: 
16295:   /* transform the PCM data; takes PCM vector, vb; modifies PCM vector */
16295:   /* only MDCT right now.... */
16295:   for(i=0;i<vi->channels;i++){
16295:     float *pcm=vb->pcm[i];
16295:     mdct_backward(b->transform[vb->W][0],pcm,pcm);
16295:   }
16295: 
16295:   /* all done! */
16295:   return(0);
16295: }
16295: 
16295: /* export hooks */
30043: const vorbis_func_mapping mapping0_exportbundle={
16295:   &mapping0_pack,
16295:   &mapping0_unpack,
16295:   &mapping0_free_info,
16295:   &mapping0_forward,
16295:   &mapping0_inverse
16295: };
