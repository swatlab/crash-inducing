70456: //
70456: // Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
70456: // Use of this source code is governed by a BSD-style license that can be
70456: // found in the LICENSE file.
70456: //
70456: 
70456: // VertexDataManager.h: Defines the VertexDataManager, a class that
70456: // runs the Buffer translation process.
70456: 
70456: #include "libGLESv2/VertexDataManager.h"
70456: 
70456: #include "common/debug.h"
70456: 
70456: #include "libGLESv2/Buffer.h"
70456: #include "libGLESv2/Program.h"
70456: #include "libGLESv2/main.h"
70456: 
70456: #include "libGLESv2/vertexconversion.h"
70456: #include "libGLESv2/IndexDataManager.h"
70456: 
70456: namespace
70456: {
70456:     enum { INITIAL_STREAM_BUFFER_SIZE = 1024*1024 };
70456: }
70456: 
70456: namespace gl
70456: {
70456: 
70456: VertexDataManager::VertexDataManager(Context *context, IDirect3DDevice9 *device) : mContext(context), mDevice(device)
70456: {
70456:     for (int i = 0; i < MAX_VERTEX_ATTRIBS; i++)
70456:     {
70456:         mDirtyCurrentValue[i] = true;
70456:         mCurrentValueBuffer[i] = NULL;
70456:     }
70456: 
70456:     const D3DCAPS9 &caps = context->getDeviceCaps();
70456:     checkVertexCaps(caps.DeclTypes);
70456: 
70456:     mStreamingBuffer = new StreamingVertexBuffer(mDevice, INITIAL_STREAM_BUFFER_SIZE);
70456: 
70456:     if (!mStreamingBuffer)
70456:     {
70456:         ERR("Failed to allocate the streaming vertex buffer.");
70456:     }
70456: }
70456: 
70456: VertexDataManager::~VertexDataManager()
70456: {
70456:     delete mStreamingBuffer;
70456: 
70456:     for (int i = 0; i < MAX_VERTEX_ATTRIBS; i++)
70456:     {
70456:         delete mCurrentValueBuffer[i];
70456:     }
70456: }
70456: 
70456: UINT VertexDataManager::writeAttributeData(ArrayVertexBuffer *vertexBuffer, GLint start, GLsizei count, const VertexAttribute &attribute)
70456: {
70456:     Buffer *buffer = attribute.mBoundBuffer.get();
70456: 
70456:     int inputStride = attribute.stride();
70456:     int elementSize = attribute.typeSize();
70456:     const FormatConverter &converter = formatConverter(attribute);
70456:     UINT streamOffset = 0;
70456: 
70456:     void *output = NULL;
70456:     
70456:     if (vertexBuffer)
70456:     {
70456:         output = vertexBuffer->map(attribute, spaceRequired(attribute, count), &streamOffset);
70456:     }
70456: 
70456:     if (output == NULL)
70456:     {
70456:         ERR("Failed to map vertex buffer.");
70456:         return -1;
70456:     }
70456: 
70456:     const char *input = NULL;
70456: 
70456:     if (buffer)
70456:     {
70456:         int offset = attribute.mOffset;
70456: 
70456:         input = static_cast<const char*>(buffer->data()) + offset;
70456:     }
70456:     else
70456:     {
70456:         input = static_cast<const char*>(attribute.mPointer);
70456:     }
70456: 
70456:     input += inputStride * start;
70456: 
70456:     if (converter.identity && inputStride == elementSize)
70456:     {
70456:         memcpy(output, input, count * inputStride);
70456:     }
70456:     else
70456:     {
70456:         converter.convertArray(input, inputStride, count, output);
70456:     }
70456: 
70456:     vertexBuffer->unmap();
70456: 
70456:     return streamOffset;
70456: }
70456: 
70456: GLenum VertexDataManager::prepareVertexData(GLint start, GLsizei count, TranslatedAttribute *translated)
70456: {
70456:     if (!mStreamingBuffer)
70456:     {
70456:         return GL_OUT_OF_MEMORY;
70456:     }
70456: 
70456:     const VertexAttributeArray &attribs = mContext->getVertexAttributes();
70456:     Program *program = mContext->getCurrentProgram();
70456: 
70456:     for (int attributeIndex = 0; attributeIndex < MAX_VERTEX_ATTRIBS; attributeIndex++)
70456:     {
70456:         translated[attributeIndex].active = (program->getSemanticIndex(attributeIndex) != -1);
70456:     }
70456: 
70456:     // Determine the required storage size per used buffer, and invalidate static buffers that don't contain matching attributes
70456:     for (int i = 0; i < MAX_VERTEX_ATTRIBS; i++)
70456:     {
70456:         if (translated[i].active && attribs[i].mArrayEnabled)
70456:         {
70456:             Buffer *buffer = attribs[i].mBoundBuffer.get();
70456:             StaticVertexBuffer *staticBuffer = buffer ? buffer->getStaticVertexBuffer() : NULL;
70456: 
70456:             if (staticBuffer)
70456:             {
70456:                 if (staticBuffer->size() == 0)
70456:                 {
70456:                     int totalCount = buffer->size() / attribs[i].stride();
70456:                     staticBuffer->addRequiredSpace(spaceRequired(attribs[i], totalCount));
70456:                 }
70456:                 else if (staticBuffer->lookupAttribute(attribs[i]) == -1)
70456:                 {
70456:                     // This static buffer doesn't have matching attributes, so fall back to using the streaming buffer
74346:                     // Add the space of all previous attributes belonging to the invalidated static buffer to the streaming buffer
74346:                     for (int previous = 0; previous < i; previous++)
74346:                     {
74346:                         if (translated[previous].active && attribs[previous].mArrayEnabled)
74346:                         {
74346:                             Buffer *previousBuffer = attribs[previous].mBoundBuffer.get();
74346:                             StaticVertexBuffer *previousStaticBuffer = previousBuffer ? previousBuffer->getStaticVertexBuffer() : NULL;
74346: 
74346:                             if (staticBuffer == previousStaticBuffer)
74346:                             {
74346:                                 mStreamingBuffer->addRequiredSpace(spaceRequired(attribs[previous], count));
74346:                             }
74346:                         }
74346:                     }
74346: 
70456:                     mStreamingBuffer->addRequiredSpace(spaceRequired(attribs[i], count));
74709: 
74709:                     buffer->invalidateStaticData();
70456:                 }    
70456:             }
70456:             else
70456:             {
70456:                 mStreamingBuffer->addRequiredSpace(spaceRequired(attribs[i], count));
70456:             }
70456:         }
70456:     }
70456: 
70456:     // Reserve the required space per used buffer
70456:     for (int i = 0; i < MAX_VERTEX_ATTRIBS; i++)
70456:     {
70456:         if (translated[i].active && attribs[i].mArrayEnabled)
70456:         {
70456:             Buffer *buffer = attribs[i].mBoundBuffer.get();
70456:             ArrayVertexBuffer *staticBuffer = buffer ? buffer->getStaticVertexBuffer() : NULL;
70456:             ArrayVertexBuffer *vertexBuffer = staticBuffer ? staticBuffer : mStreamingBuffer;
70456: 
70456:             if (vertexBuffer)
70456:             {
70456:                 vertexBuffer->reserveRequiredSpace();
70456:             }
70456:         }
70456:     }
70456: 
70456:     // Perform the vertex data translations
70456:     for (int i = 0; i < MAX_VERTEX_ATTRIBS; i++)
70456:     {
70456:         if (translated[i].active)
70456:         {
70456:             if (attribs[i].mArrayEnabled)
70456:             {
70456:                 Buffer *buffer = attribs[i].mBoundBuffer.get();
70456: 
70456:                 if (!buffer && attribs[i].mPointer == NULL)
70456:                 {
70456:                     // This is an application error that would normally result in a crash, but we catch it and return an error
70456:                     ERR("An enabled vertex array has no buffer and no pointer.");
70456:                     return GL_INVALID_OPERATION;
70456:                 }
70456: 
70456:                 const FormatConverter &converter = formatConverter(attribs[i]);
70456: 
70456:                 StaticVertexBuffer *staticBuffer = buffer ? buffer->getStaticVertexBuffer() : NULL;
70456:                 ArrayVertexBuffer *vertexBuffer = staticBuffer ? staticBuffer : static_cast<ArrayVertexBuffer*>(mStreamingBuffer);
70456: 
70456:                 UINT streamOffset = -1;
70456: 
70456:                 if (staticBuffer)
70456:                 {
70456:                     streamOffset = staticBuffer->lookupAttribute(attribs[i]);
70456: 
70456:                     if (streamOffset == -1)
70456:                     {
70456:                         // Convert the entire buffer
70456:                         int totalCount = buffer->size() / attribs[i].stride();
70456:                         int startIndex = attribs[i].mOffset / attribs[i].stride();
70456: 
70456:                         streamOffset = writeAttributeData(staticBuffer, -startIndex, totalCount, attribs[i]);
70456:                     }
70456: 
70456:                     if (streamOffset != -1)
70456:                     {
70456:                         streamOffset += (start + attribs[i].mOffset / attribs[i].stride()) * converter.outputElementSize;
70456:                     }
70456:                 }
70456:                 else
70456:                 {
70456:                     streamOffset = writeAttributeData(mStreamingBuffer, start, count, attribs[i]);
70456:                 }
70456: 
70456:                 if (streamOffset == -1)
70456:                 {
70456:                     return GL_OUT_OF_MEMORY;
70456:                 }
70456: 
70456:                 translated[i].vertexBuffer = vertexBuffer->getBuffer();
70456:                 translated[i].type = converter.d3dDeclType;
70456:                 translated[i].stride = converter.outputElementSize;
70456:                 translated[i].offset = streamOffset;
70456:             }
70456:             else
70456:             {
70456:                 if (mDirtyCurrentValue[i])
70456:                 {
70456:                     delete mCurrentValueBuffer[i];
70456:                     mCurrentValueBuffer[i] = new ConstantVertexBuffer(mDevice, attribs[i].mCurrentValue[0], attribs[i].mCurrentValue[1], attribs[i].mCurrentValue[2], attribs[i].mCurrentValue[3]);
70456:                     mDirtyCurrentValue[i] = false;
70456:                 }
70456: 
70456:                 translated[i].vertexBuffer = mCurrentValueBuffer[i]->getBuffer();
70456: 
70456:                 translated[i].type = D3DDECLTYPE_FLOAT4;
70456:                 translated[i].stride = 0;
70456:                 translated[i].offset = 0;
70456:             }
70456:         }
70456:     }
70456: 
70456:     for (int i = 0; i < MAX_VERTEX_ATTRIBS; i++)
70456:     {
70456:         if (translated[i].active && attribs[i].mArrayEnabled)
70456:         {
70456:             Buffer *buffer = attribs[i].mBoundBuffer.get();
70456: 
70456:             if (buffer)
70456:             {
70456:                 buffer->promoteStaticUsage(count * attribs[i].typeSize());
70456:             }
70456:         }
70456:     }
70456: 
70456:     return GL_NO_ERROR;
70456: }
70456: 
70456: std::size_t VertexDataManager::spaceRequired(const VertexAttribute &attrib, std::size_t count) const
70456: {
70456:     return formatConverter(attrib).outputElementSize * count;
70456: }
70456: 
70456: // Mapping from OpenGL-ES vertex attrib type to D3D decl type:
70456: //
70456: // BYTE                 SHORT (Cast)
70456: // BYTE-norm            FLOAT (Normalize) (can't be exactly represented as SHORT-norm)
70456: // UNSIGNED_BYTE        UBYTE4 (Identity) or SHORT (Cast)
70456: // UNSIGNED_BYTE-norm   UBYTE4N (Identity) or FLOAT (Normalize)
70456: // SHORT                SHORT (Identity)
70456: // SHORT-norm           SHORT-norm (Identity) or FLOAT (Normalize)
70456: // UNSIGNED_SHORT       FLOAT (Cast)
70456: // UNSIGNED_SHORT-norm  USHORT-norm (Identity) or FLOAT (Normalize)
70456: // FIXED (not in WebGL) FLOAT (FixedToFloat)
70456: // FLOAT                FLOAT (Identity)
70456: 
70456: // GLToCType maps from GL type (as GLenum) to the C typedef. 
70456: template <GLenum GLType> struct GLToCType { };
70456: 
70456: template <> struct GLToCType<GL_BYTE> { typedef GLbyte type; };
70456: template <> struct GLToCType<GL_UNSIGNED_BYTE> { typedef GLubyte type; };
70456: template <> struct GLToCType<GL_SHORT> { typedef GLshort type; };
70456: template <> struct GLToCType<GL_UNSIGNED_SHORT> { typedef GLushort type; };
70456: template <> struct GLToCType<GL_FIXED> { typedef GLuint type; };
70456: template <> struct GLToCType<GL_FLOAT> { typedef GLfloat type; };
70456: 
70456: // This differs from D3DDECLTYPE in that it is unsized. (Size expansion is applied last.)
70456: enum D3DVertexType
70456: {
70456:     D3DVT_FLOAT,
70456:     D3DVT_SHORT,
70456:     D3DVT_SHORT_NORM,
70456:     D3DVT_UBYTE,
70456:     D3DVT_UBYTE_NORM,
70456:     D3DVT_USHORT_NORM
70456: };
70456: 
70456: // D3DToCType maps from D3D vertex type (as enum D3DVertexType) to the corresponding C type.
70456: template <unsigned int D3DType> struct D3DToCType { };
70456: 
70456: template <> struct D3DToCType<D3DVT_FLOAT> { typedef float type; };
70456: template <> struct D3DToCType<D3DVT_SHORT> { typedef short type; };
70456: template <> struct D3DToCType<D3DVT_SHORT_NORM> { typedef short type; };
70456: template <> struct D3DToCType<D3DVT_UBYTE> { typedef unsigned char type; };
70456: template <> struct D3DToCType<D3DVT_UBYTE_NORM> { typedef unsigned char type; };
70456: template <> struct D3DToCType<D3DVT_USHORT_NORM> { typedef unsigned short type; };
70456: 
70456: // Encode the type/size combinations that D3D permits. For each type/size it expands to a widener that will provide the appropriate final size.
70456: template <unsigned int type, int size>
70456: struct WidenRule
70456: {
70456: };
70456: 
70456: template <int size> struct WidenRule<D3DVT_FLOAT, size>          : gl::NoWiden<size> { };
70456: template <int size> struct WidenRule<D3DVT_SHORT, size>          : gl::WidenToEven<size> { };
70456: template <int size> struct WidenRule<D3DVT_SHORT_NORM, size>     : gl::WidenToEven<size> { };
70456: template <int size> struct WidenRule<D3DVT_UBYTE, size>          : gl::WidenToFour<size> { };
70456: template <int size> struct WidenRule<D3DVT_UBYTE_NORM, size>     : gl::WidenToFour<size> { };
70456: template <int size> struct WidenRule<D3DVT_USHORT_NORM, size>    : gl::WidenToEven<size> { };
70456: 
70456: // VertexTypeFlags encodes the D3DCAPS9::DeclType flag and vertex declaration flag for each D3D vertex type & size combination.
70456: template <unsigned int d3dtype, int size>
70456: struct VertexTypeFlags
70456: {
70456: };
70456: 
70456: template <unsigned int capflag, unsigned int declflag>
70456: struct VertexTypeFlagsHelper
70456: {
70456:     enum { capflag = capflag };
70456:     enum { declflag = declflag };
70456: };
70456: 
70456: template <> struct VertexTypeFlags<D3DVT_FLOAT, 1> : VertexTypeFlagsHelper<0, D3DDECLTYPE_FLOAT1> { };
70456: template <> struct VertexTypeFlags<D3DVT_FLOAT, 2> : VertexTypeFlagsHelper<0, D3DDECLTYPE_FLOAT2> { };
70456: template <> struct VertexTypeFlags<D3DVT_FLOAT, 3> : VertexTypeFlagsHelper<0, D3DDECLTYPE_FLOAT3> { };
70456: template <> struct VertexTypeFlags<D3DVT_FLOAT, 4> : VertexTypeFlagsHelper<0, D3DDECLTYPE_FLOAT4> { };
70456: template <> struct VertexTypeFlags<D3DVT_SHORT, 2> : VertexTypeFlagsHelper<0, D3DDECLTYPE_SHORT2> { };
70456: template <> struct VertexTypeFlags<D3DVT_SHORT, 4> : VertexTypeFlagsHelper<0, D3DDECLTYPE_SHORT4> { };
70456: template <> struct VertexTypeFlags<D3DVT_SHORT_NORM, 2> : VertexTypeFlagsHelper<D3DDTCAPS_SHORT2N, D3DDECLTYPE_SHORT2N> { };
70456: template <> struct VertexTypeFlags<D3DVT_SHORT_NORM, 4> : VertexTypeFlagsHelper<D3DDTCAPS_SHORT4N, D3DDECLTYPE_SHORT4N> { };
70456: template <> struct VertexTypeFlags<D3DVT_UBYTE, 4> : VertexTypeFlagsHelper<D3DDTCAPS_UBYTE4, D3DDECLTYPE_UBYTE4> { };
70456: template <> struct VertexTypeFlags<D3DVT_UBYTE_NORM, 4> : VertexTypeFlagsHelper<D3DDTCAPS_UBYTE4N, D3DDECLTYPE_UBYTE4N> { };
70456: template <> struct VertexTypeFlags<D3DVT_USHORT_NORM, 2> : VertexTypeFlagsHelper<D3DDTCAPS_USHORT2N, D3DDECLTYPE_USHORT2N> { };
70456: template <> struct VertexTypeFlags<D3DVT_USHORT_NORM, 4> : VertexTypeFlagsHelper<D3DDTCAPS_USHORT4N, D3DDECLTYPE_USHORT4N> { };
70456: 
70456: 
70456: // VertexTypeMapping maps GL type & normalized flag to preferred and fallback D3D vertex types (as D3DVertexType enums).
70456: template <GLenum GLtype, bool normalized>
70456: struct VertexTypeMapping
70456: {
70456: };
70456: 
70456: template <D3DVertexType Preferred, D3DVertexType Fallback = Preferred>
70456: struct VertexTypeMappingBase
70456: {
70456:     enum { preferred = Preferred };
70456:     enum { fallback = Fallback };
70456: };
70456: 
70456: template <> struct VertexTypeMapping<GL_BYTE, false>                        : VertexTypeMappingBase<D3DVT_SHORT> { };                       // Cast
70456: template <> struct VertexTypeMapping<GL_BYTE, true>                         : VertexTypeMappingBase<D3DVT_FLOAT> { };                       // Normalize
70456: template <> struct VertexTypeMapping<GL_UNSIGNED_BYTE, false>               : VertexTypeMappingBase<D3DVT_UBYTE, D3DVT_FLOAT> { };          // Identity, Cast
70456: template <> struct VertexTypeMapping<GL_UNSIGNED_BYTE, true>                : VertexTypeMappingBase<D3DVT_UBYTE_NORM, D3DVT_FLOAT> { };     // Identity, Normalize
70456: template <> struct VertexTypeMapping<GL_SHORT, false>                       : VertexTypeMappingBase<D3DVT_SHORT> { };                       // Identity
70456: template <> struct VertexTypeMapping<GL_SHORT, true>                        : VertexTypeMappingBase<D3DVT_SHORT_NORM, D3DVT_FLOAT> { };     // Cast, Normalize
70456: template <> struct VertexTypeMapping<GL_UNSIGNED_SHORT, false>              : VertexTypeMappingBase<D3DVT_FLOAT> { };                       // Cast
70456: template <> struct VertexTypeMapping<GL_UNSIGNED_SHORT, true>               : VertexTypeMappingBase<D3DVT_USHORT_NORM, D3DVT_FLOAT> { };    // Cast, Normalize
70456: template <bool normalized> struct VertexTypeMapping<GL_FIXED, normalized>   : VertexTypeMappingBase<D3DVT_FLOAT> { };                       // FixedToFloat
70456: template <bool normalized> struct VertexTypeMapping<GL_FLOAT, normalized>   : VertexTypeMappingBase<D3DVT_FLOAT> { };                       // Identity
70456: 
70456: 
70456: // Given a GL type & norm flag and a D3D type, ConversionRule provides the type conversion rule (Cast, Normalize, Identity, FixedToFloat).
70456: // The conversion rules themselves are defined in vertexconversion.h.
70456: 
70456: // Almost all cases are covered by Cast (including those that are actually Identity since Cast<T,T> knows it's an identity mapping).
70456: template <GLenum fromType, bool normalized, unsigned int toType>
70456: struct ConversionRule : gl::Cast<typename GLToCType<fromType>::type, typename D3DToCType<toType>::type>
70456: {
70456: };
70456: 
70456: // All conversions from normalized types to float use the Normalize operator.
70456: template <GLenum fromType> struct ConversionRule<fromType, true, D3DVT_FLOAT> : gl::Normalize<typename GLToCType<fromType>::type> { };
70456: 
70456: // Use a full specialisation for this so that it preferentially matches ahead of the generic normalize-to-float rules.
70456: template <> struct ConversionRule<GL_FIXED, true, D3DVT_FLOAT> : gl::FixedToFloat<GLuint, 16> { };
70456: template <> struct ConversionRule<GL_FIXED, false, D3DVT_FLOAT> : gl::FixedToFloat<GLuint, 16> { };
70456: 
70456: // A 2-stage construction is used for DefaultVertexValues because float must use SimpleDefaultValues (i.e. 0/1)
70456: // whether it is normalized or not.
70456: template <class T, bool normalized>
70456: struct DefaultVertexValuesStage2
70456: {
70456: };
70456: 
70456: template <class T> struct DefaultVertexValuesStage2<T, true>  : gl::NormalizedDefaultValues<T> { };
70456: template <class T> struct DefaultVertexValuesStage2<T, false> : gl::SimpleDefaultValues<T> { };
70456: 
70456: // Work out the default value rule for a D3D type (expressed as the C type) and 
70456: template <class T, bool normalized>
70456: struct DefaultVertexValues : DefaultVertexValuesStage2<T, normalized>
70456: {
70456: };
70456: 
70456: template <bool normalized> struct DefaultVertexValues<float, normalized> : gl::SimpleDefaultValues<float> { };
70456: 
70456: // Policy rules for use with Converter, to choose whether to use the preferred or fallback conversion.
70456: // The fallback conversion produces an output that all D3D9 devices must support.
70456: template <class T> struct UsePreferred { enum { type = T::preferred }; };
70456: template <class T> struct UseFallback { enum { type = T::fallback }; };
70456: 
70456: // Converter ties it all together. Given an OpenGL type/norm/size and choice of preferred/fallback conversion,
70456: // it provides all the members of the appropriate VertexDataConverter, the D3DCAPS9::DeclTypes flag in cap flag
70456: // and the D3DDECLTYPE member needed for the vertex declaration in declflag.
70456: template <GLenum fromType, bool normalized, int size, template <class T> class PreferenceRule>
70456: struct Converter
70456:     : gl::VertexDataConverter<typename GLToCType<fromType>::type,
70456:                               WidenRule<PreferenceRule< VertexTypeMapping<fromType, normalized> >::type, size>,
70456:                               ConversionRule<fromType,
70456:                                              normalized,
70456:                                              PreferenceRule< VertexTypeMapping<fromType, normalized> >::type>,
70456:                               DefaultVertexValues<typename D3DToCType<PreferenceRule< VertexTypeMapping<fromType, normalized> >::type>::type, normalized > >
70456: {
70456: private:
70456:     enum { d3dtype = PreferenceRule< VertexTypeMapping<fromType, normalized> >::type };
70456:     enum { d3dsize = WidenRule<d3dtype, size>::finalWidth };
70456: 
70456: public:
70456:     enum { capflag = VertexTypeFlags<d3dtype, d3dsize>::capflag };
70456:     enum { declflag = VertexTypeFlags<d3dtype, d3dsize>::declflag };
70456: };
70456: 
70456: // Initialise a TranslationInfo
70456: #define TRANSLATION(type, norm, size, preferred)                                    \
70456:     {                                                                               \
70456:         Converter<type, norm, size, preferred>::identity,                           \
70456:         Converter<type, norm, size, preferred>::finalSize,                          \
70456:         Converter<type, norm, size, preferred>::convertArray,                       \
70456:         static_cast<D3DDECLTYPE>(Converter<type, norm, size, preferred>::declflag)  \
70456:     }
70456: 
70456: #define TRANSLATION_FOR_TYPE_NORM_SIZE(type, norm, size)    \
70456:     {                                                       \
70456:         Converter<type, norm, size, UsePreferred>::capflag, \
70456:         TRANSLATION(type, norm, size, UsePreferred),        \
70456:         TRANSLATION(type, norm, size, UseFallback)          \
70456:     }
70456: 
70456: #define TRANSLATIONS_FOR_TYPE(type)                                                                                                                                                                         \
70456:     {                                                                                                                                                                                                       \
70456:         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, false, 4) }, \
70456:         { TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 1), TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 2), TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 3), TRANSLATION_FOR_TYPE_NORM_SIZE(type, true, 4) },     \
70456:     }
70456: 
70456: const VertexDataManager::TranslationDescription VertexDataManager::mPossibleTranslations[NUM_GL_VERTEX_ATTRIB_TYPES][2][4] = // [GL types as enumerated by typeIndex()][normalized][size-1]
70456: {
70456:     TRANSLATIONS_FOR_TYPE(GL_BYTE),
70456:     TRANSLATIONS_FOR_TYPE(GL_UNSIGNED_BYTE),
70456:     TRANSLATIONS_FOR_TYPE(GL_SHORT),
70456:     TRANSLATIONS_FOR_TYPE(GL_UNSIGNED_SHORT),
70456:     TRANSLATIONS_FOR_TYPE(GL_FIXED),
70456:     TRANSLATIONS_FOR_TYPE(GL_FLOAT)
70456: };
70456: 
70456: void VertexDataManager::checkVertexCaps(DWORD declTypes)
70456: {
70456:     for (unsigned int i = 0; i < NUM_GL_VERTEX_ATTRIB_TYPES; i++)
70456:     {
70456:         for (unsigned int j = 0; j < 2; j++)
70456:         {
70456:             for (unsigned int k = 0; k < 4; k++)
70456:             {
70456:                 if (mPossibleTranslations[i][j][k].capsFlag == 0 || (declTypes & mPossibleTranslations[i][j][k].capsFlag) != 0)
70456:                 {
70456:                     mAttributeTypes[i][j][k] = mPossibleTranslations[i][j][k].preferredConversion;
70456:                 }
70456:                 else
70456:                 {
70456:                     mAttributeTypes[i][j][k] = mPossibleTranslations[i][j][k].fallbackConversion;
70456:                 }
70456:             }
70456:         }
70456:     }
70456: }
70456: 
70456: // This is used to index mAttributeTypes and mPossibleTranslations.
70456: unsigned int VertexDataManager::typeIndex(GLenum type) const
70456: {
70456:     switch (type)
70456:     {
70456:       case GL_BYTE: return 0;
70456:       case GL_UNSIGNED_BYTE: return 1;
70456:       case GL_SHORT: return 2;
70456:       case GL_UNSIGNED_SHORT: return 3;
70456:       case GL_FIXED: return 4;
70456:       case GL_FLOAT: return 5;
70456: 
70456:       default: UNREACHABLE(); return 5;
70456:     }
70456: }
70456: 
70456: VertexBuffer::VertexBuffer(IDirect3DDevice9 *device, std::size_t size, DWORD usageFlags) : mDevice(device), mVertexBuffer(NULL)
70456: {
70456:     if (size > 0)
70456:     {
70456:         D3DPOOL pool = getDisplay()->getBufferPool(usageFlags);
70456:         HRESULT result = device->CreateVertexBuffer(size, usageFlags, 0, pool, &mVertexBuffer, NULL);
70456:         
70456:         if (FAILED(result))
70456:         {
70456:             ERR("Out of memory allocating a vertex buffer of size %lu.", size);
70456:         }
70456:     }
70456: }
70456: 
70456: VertexBuffer::~VertexBuffer()
70456: {
70456:     if (mVertexBuffer)
70456:     {
70456:         mVertexBuffer->Release();
70456:     }
70456: }
70456: 
70456: void VertexBuffer::unmap()
70456: {
70456:     if (mVertexBuffer)
70456:     {
70456:         mVertexBuffer->Unlock();
70456:     }
70456: }
70456: 
70456: IDirect3DVertexBuffer9 *VertexBuffer::getBuffer() const
70456: {
70456:     return mVertexBuffer;
70456: }
70456: 
70456: ConstantVertexBuffer::ConstantVertexBuffer(IDirect3DDevice9 *device, float x, float y, float z, float w) : VertexBuffer(device, 4 * sizeof(float), D3DUSAGE_WRITEONLY)
70456: {
70456:     void *buffer = NULL;
70456: 
70456:     if (mVertexBuffer)
70456:     {
70456:         HRESULT result = mVertexBuffer->Lock(0, 0, &buffer, 0);
70456:      
70456:         if (FAILED(result))
70456:         {
70456:             ERR("Lock failed with error 0x%08x", result);
70456:         }
70456:     }
70456: 
70456:     if (buffer)
70456:     {
70456:         float *vector = (float*)buffer;
70456: 
70456:         vector[0] = x;
70456:         vector[1] = y;
70456:         vector[2] = z;
70456:         vector[3] = w;
70456: 
70456:         mVertexBuffer->Unlock();
70456:     }
70456: }
70456: 
70456: ConstantVertexBuffer::~ConstantVertexBuffer()
70456: {
70456: }
70456: 
70456: ArrayVertexBuffer::ArrayVertexBuffer(IDirect3DDevice9 *device, std::size_t size, DWORD usageFlags) : VertexBuffer(device, size, usageFlags)
70456: {
70456:     mBufferSize = size;
70456:     mWritePosition = 0;
70456:     mRequiredSpace = 0;
70456: }
70456: 
70456: ArrayVertexBuffer::~ArrayVertexBuffer()
70456: {
70456: }
70456: 
70456: void ArrayVertexBuffer::addRequiredSpace(UINT requiredSpace)
70456: {
70456:     mRequiredSpace += requiredSpace;
70456: }
70456: 
70456: StreamingVertexBuffer::StreamingVertexBuffer(IDirect3DDevice9 *device, std::size_t initialSize) : ArrayVertexBuffer(device, initialSize, D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY)
70456: {
70456: }
70456: 
70456: StreamingVertexBuffer::~StreamingVertexBuffer()
70456: {
70456: }
70456: 
70456: void *StreamingVertexBuffer::map(const VertexAttribute &attribute, std::size_t requiredSpace, std::size_t *offset)
70456: {
70456:     void *mapPtr = NULL;
70456: 
70456:     if (mVertexBuffer)
70456:     {
70456:         HRESULT result = mVertexBuffer->Lock(mWritePosition, requiredSpace, &mapPtr, D3DLOCK_NOOVERWRITE);
70456:         
70456:         if (FAILED(result))
70456:         {
70456:             ERR("Lock failed with error 0x%08x", result);
70456:             return NULL;
70456:         }
70456: 
70456:         *offset = mWritePosition;
70456:         mWritePosition += requiredSpace;
70456:     }
70456: 
70456:     return mapPtr;
70456: }
70456: 
70456: void StreamingVertexBuffer::reserveRequiredSpace()
70456: {
70456:     if (mRequiredSpace > mBufferSize)
70456:     {
70456:         if (mVertexBuffer)
70456:         {
70456:             mVertexBuffer->Release();
70456:             mVertexBuffer = NULL;
70456:         }
70456: 
70456:         mBufferSize = std::max(mRequiredSpace, 3 * mBufferSize / 2);   // 1.5 x mBufferSize is arbitrary and should be checked to see we don't have too many reallocations.
70456: 
70456:         D3DPOOL pool = getDisplay()->getBufferPool(D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY);
70456:         HRESULT result = mDevice->CreateVertexBuffer(mBufferSize, D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, 0, pool, &mVertexBuffer, NULL);
70456:     
70456:         if (FAILED(result))
70456:         {
70456:             ERR("Out of memory allocating a vertex buffer of size %lu.", mBufferSize);
70456:         }
70456: 
70456:         mWritePosition = 0;
70456:     }
70456:     else if (mWritePosition + mRequiredSpace > mBufferSize)   // Recycle
70456:     {
70456:         if (mVertexBuffer)
70456:         {
70456:             void *dummy;
70456:             mVertexBuffer->Lock(0, 1, &dummy, D3DLOCK_DISCARD);
70456:             mVertexBuffer->Unlock();
70456:         }
70456: 
70456:         mWritePosition = 0;
70456:     }
70456: 
70456:     mRequiredSpace = 0;
70456: }
70456: 
70456: StaticVertexBuffer::StaticVertexBuffer(IDirect3DDevice9 *device) : ArrayVertexBuffer(device, 0, D3DUSAGE_WRITEONLY)
70456: {
70456: }
70456: 
70456: StaticVertexBuffer::~StaticVertexBuffer()
70456: {
70456: }
70456: 
70456: void *StaticVertexBuffer::map(const VertexAttribute &attribute, std::size_t requiredSpace, UINT *streamOffset)
70456: {
70456:     void *mapPtr = NULL;
70456: 
70456:     if (mVertexBuffer)
70456:     {
70456:         HRESULT result = mVertexBuffer->Lock(mWritePosition, requiredSpace, &mapPtr, 0);
70456:         
70456:         if (FAILED(result))
70456:         {
70456:             ERR("Lock failed with error 0x%08x", result);
70456:             return NULL;
70456:         }
70456: 
70456:         int attributeOffset = attribute.mOffset % attribute.stride();
70456:         VertexElement element = {attribute.mType, attribute.mSize, attribute.mNormalized, attributeOffset, mWritePosition};
70456:         mCache.push_back(element);
70456: 
70456:         *streamOffset = mWritePosition;
70456:         mWritePosition += requiredSpace;
70456:     }
70456: 
70456:     return mapPtr;
70456: }
70456: 
70456: void StaticVertexBuffer::reserveRequiredSpace()
70456: {
70456:     if (!mVertexBuffer && mBufferSize == 0)
70456:     {
70456:         D3DPOOL pool = getDisplay()->getBufferPool(D3DUSAGE_WRITEONLY);
70456:         HRESULT result = mDevice->CreateVertexBuffer(mRequiredSpace, D3DUSAGE_WRITEONLY, 0, pool, &mVertexBuffer, NULL);
70456:     
70456:         if (FAILED(result))
70456:         {
70456:             ERR("Out of memory allocating a vertex buffer of size %lu.", mRequiredSpace);
70456:         }
70456: 
70456:         mBufferSize = mRequiredSpace;
70456:     }
70456:     else if (mVertexBuffer && mBufferSize >= mRequiredSpace)
70456:     {
70456:         // Already allocated
70456:     }
70456:     else UNREACHABLE();   // Static vertex buffers can't be resized
70456: 
70456:     mRequiredSpace = 0;
70456: }
70456: 
70456: UINT StaticVertexBuffer::lookupAttribute(const VertexAttribute &attribute)
70456: {
70456:     for (unsigned int element = 0; element < mCache.size(); element++)
70456:     {
70456:         if (mCache[element].type == attribute.mType &&  mCache[element].size == attribute.mSize && mCache[element].normalized == attribute.mNormalized)
70456:         {
70456:             if (mCache[element].attributeOffset == attribute.mOffset % attribute.stride())
70456:             {
70456:                 return mCache[element].streamOffset;
70456:             }
70456:         }
70456:     }
70456: 
70456:     return -1;
70456: }
70456: 
70456: const VertexDataManager::FormatConverter &VertexDataManager::formatConverter(const VertexAttribute &attribute) const
70456: {
70456:     return mAttributeTypes[typeIndex(attribute.mType)][attribute.mNormalized][attribute.mSize - 1];
70456: }
70456: }
