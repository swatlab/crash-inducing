32917: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
32917: /* vim: set sw=2 ts=2 et tw=79: */
32917: /* ***** BEGIN LICENSE BLOCK *****
32917:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32917:  *
32917:  * The contents of this file are subject to the Mozilla Public License Version
32917:  * 1.1 (the "License"); you may not use this file except in compliance with
32917:  * the License. You may obtain a copy of the License at
32917:  * http://www.mozilla.org/MPL/
32917:  *
32917:  * Software distributed under the License is distributed on an "AS IS" basis,
32917:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32917:  * for the specific language governing rights and limitations under the
32917:  * License.
32917:  *
32917:  * The Original Code is mozilla.org code.
32917:  *
32917:  * The Initial Developer of the Original Code is
32917:  * Netscape Communications Corporation.
32917:  * Portions created by the Initial Developer are Copyright (C) 1998
32917:  * the Initial Developer. All Rights Reserved.
32917:  *
32917:  * Contributor(s):
32917:  *   Pierre Phaneuf <pp@ludusdesign.com>
32917:  *   Henri Sivonen <hsivonen@iki.fi>
32917:  *
32917:  * Alternatively, the contents of this file may be used under the terms of
32917:  * either of the GNU General Public License Version 2 or later (the "GPL"),
32917:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32917:  * in which case the provisions of the GPL or the LGPL are applicable instead
32917:  * of those above. If you wish to allow use of your version of this file only
32917:  * under the terms of either the GPL or the LGPL, and not to allow others to
32917:  * use your version of this file under the terms of the MPL, indicate your
32917:  * decision by deleting the provisions above and replace them with the notice
32917:  * and other provisions required by the GPL or the LGPL. If you do not delete
32917:  * the provisions above, a recipient may use your version of this file under
32917:  * the terms of any one of the MPL, the GPL or the LGPL.
32917:  *
32917:  * ***** END LICENSE BLOCK ***** */
32917: 
32917: #include "nsHtml5TreeOpExecutor.h"
32917: #include "nsScriptLoader.h"
32917: #include "nsIMarkupDocumentViewer.h"
32917: #include "nsIContentViewer.h"
32917: #include "nsIDocShellTreeItem.h"
32917: #include "nsIStyleSheetLinkingElement.h"
38740: #include "nsStyleLinkElement.h"
32917: #include "nsIDocShell.h"
32917: #include "nsIScriptGlobalObject.h"
32917: #include "nsIScriptGlobalObjectOwner.h"
32917: #include "nsIScriptSecurityManager.h"
32917: #include "nsIWebShellServices.h"
32917: #include "nsContentUtils.h"
32917: #include "mozAutoDocUpdate.h"
32917: #include "nsNetUtil.h"
32917: #include "nsHtml5Parser.h"
32917: #include "nsHtml5Tokenizer.h"
32917: #include "nsHtml5TreeBuilder.h"
32917: #include "nsHtml5StreamParser.h"
32917: 
32917: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHtml5TreeOpExecutor)
32917: 
32917: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHtml5TreeOpExecutor)
32917:   NS_INTERFACE_TABLE_INHERITED1(nsHtml5TreeOpExecutor, 
32917:                                 nsIContentSink)
32917: NS_INTERFACE_TABLE_TAIL_INHERITING(nsContentSink)
32917: 
32917: NS_IMPL_ADDREF_INHERITED(nsHtml5TreeOpExecutor, nsContentSink)
32917: 
32917: NS_IMPL_RELEASE_INHERITED(nsHtml5TreeOpExecutor, nsContentSink)
32917: 
32917: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHtml5TreeOpExecutor, nsContentSink)
34978:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mOwnedElements)
32917: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
32917: 
32917: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsHtml5TreeOpExecutor, nsContentSink)
34978:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mOwnedElements)
32917: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
32917: 
39737: class nsHtml5ExecutorReflusher : public nsRunnable
37622: {
39737:   private:
39737:     nsRefPtr<nsHtml5TreeOpExecutor> mExecutor;
39737:   public:
39737:     nsHtml5ExecutorReflusher(nsHtml5TreeOpExecutor* aExecutor)
39737:       : mExecutor(aExecutor)
39737:     {}
39737:     NS_IMETHODIMP Run()
39737:     {
39737:       mExecutor->RunFlushLoop();
39737:       return NS_OK;
37622:     }
39737: };
37622: 
32917: nsHtml5TreeOpExecutor::nsHtml5TreeOpExecutor()
32917: {
39737:   mPreloadedURLs.Init(23); // Mean # of preloadable resources per page on dmoz
39737:   // zeroing operator new for everything else
32917: }
32917: 
32917: nsHtml5TreeOpExecutor::~nsHtml5TreeOpExecutor()
32917: {
32917:   NS_ASSERTION(mOpQueue.IsEmpty(), "Somehow there's stuff in the op queue.");
32917: }
32917: 
32917: // nsIContentSink
32917: NS_IMETHODIMP
32917: nsHtml5TreeOpExecutor::WillParse()
32917: {
32917:   NS_NOTREACHED("No one should call this");
32917:   return NS_ERROR_NOT_IMPLEMENTED;
32917: }
32917: 
32917: // This is called when the tree construction has ended
32917: NS_IMETHODIMP
33527: nsHtml5TreeOpExecutor::DidBuildModel(PRBool aTerminated)
32917: {
35590:   NS_PRECONDITION(mStarted, "Bad life cycle.");
35590: 
37179:   if (!aTerminated) {
40913:     // This is needed to avoid unblocking loads too many times on one hand
40913:     // and on the other hand to avoid destroying the frame constructor from
40913:     // within an update batch. See bug 537683.
35590:     EndDocUpdate();
35590:     
35590:     // If the above caused a call to nsIParser::Terminate(), let that call
35590:     // win.
35590:     if (!mParser) {
35590:       return NS_OK;
35590:     }
37179:   }
35590:   
36204:   static_cast<nsHtml5Parser*> (mParser.get())->DropStreamParser();
36204: 
40913:   // This comes from nsXMLContentSink and nsHTMLContentSink
33527:   DidBuildModelImpl(aTerminated);
39513: 
39513:   if (!mLayoutStarted) {
39513:     // We never saw the body, and layout never got started. Force
39513:     // layout *now*, to get an initial reflow.
39513: 
39513:     // NOTE: only force the layout if we are NOT destroying the
39513:     // docshell. If we are destroying it, then starting layout will
39513:     // likely cause us to crash, or at best waste a lot of time as we
39513:     // are just going to tear it down anyway.
39513:     PRBool destroying = PR_TRUE;
39513:     if (mDocShell) {
39513:       mDocShell->IsBeingDestroyed(&destroying);
39513:     }
39513: 
39513:     if (!destroying) {
39513:       nsContentSink::StartLayout(PR_FALSE);
39513:     }
39513:   }
39513: 
39513:   ScrollToRef();
32917:   mDocument->ScriptLoader()->RemoveObserver(this);
32917:   mDocument->RemoveObserver(this);
36204:   if (!mParser) {
36204:     // DidBuildModelImpl may cause mParser to be nulled out
36204:     // Return early to avoid unblocking the onload event too many times.
36204:     return NS_OK;
36204:   }
32917:   mDocument->EndLoad();
32917:   DropParserAndPerfHint();
32917: #ifdef GATHER_DOCWRITE_STATISTICS
32917:   printf("UNSAFE SCRIPTS: %d\n", sUnsafeDocWrites);
32917:   printf("TOKENIZER-SAFE SCRIPTS: %d\n", sTokenSafeDocWrites);
32917:   printf("TREEBUILDER-SAFE SCRIPTS: %d\n", sTreeSafeDocWrites);
32917: #endif
37622: #ifdef DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
32917:   printf("MAX NOTIFICATION BATCH LEN: %d\n", sAppendBatchMaxSize);
32917:   if (sAppendBatchExaminations != 0) {
32917:     printf("AVERAGE SLOTS EXAMINED: %d\n", sAppendBatchSlotsExamined / sAppendBatchExaminations);
32917:   }
32917: #endif
32917:   return NS_OK;
32917: }
32917: 
32917: NS_IMETHODIMP
32917: nsHtml5TreeOpExecutor::WillInterrupt()
32917: {
39737:   NS_NOTREACHED("Don't call. For interface compat only.");
39737:   return NS_ERROR_NOT_IMPLEMENTED;
32917: }
32917: 
32917: NS_IMETHODIMP
32917: nsHtml5TreeOpExecutor::WillResume()
32917: {
39737:   NS_NOTREACHED("Don't call. For interface compat only.");
39737:   return NS_ERROR_NOT_IMPLEMENTED;
32917: }
32917: 
32917: NS_IMETHODIMP
32917: nsHtml5TreeOpExecutor::SetParser(nsIParser* aParser)
32917: {
32917:   mParser = aParser;
32917:   return NS_OK;
32917: }
32917: 
32917: void
32917: nsHtml5TreeOpExecutor::FlushPendingNotifications(mozFlushType aType)
32917: {
52259:   if (aType >= Flush_InterruptibleLayout) {
52259:     // Bug 577508 / 253951
59787:     nsContentSink::StartLayout(PR_TRUE);
52259:   }
32917: }
32917: 
39511: void
39511: nsHtml5TreeOpExecutor::SetDocumentCharsetAndSource(nsACString& aCharset, PRInt32 aCharsetSource)
32917: {
39511:   if (mDocument) {
39511:     mDocument->SetDocumentCharacterSetSource(aCharsetSource);
39511:     mDocument->SetDocumentCharacterSet(aCharset);
39511:   }
32917:   if (mDocShell) {
32917:     // the following logic to get muCV is copied from
32917:     // nsHTMLDocument::StartDocumentLoad
32917:     // We need to call muCV->SetPrevDocCharacterSet here in case
32917:     // the charset is detected by parser DetectMetaTag
40913:     nsCOMPtr<nsIMarkupDocumentViewer> mucv;
32917:     nsCOMPtr<nsIContentViewer> cv;
32917:     mDocShell->GetContentViewer(getter_AddRefs(cv));
32917:     if (cv) {
40913:       mucv = do_QueryInterface(cv);
32917:     } else {
32917:       // in this block of code, if we get an error result, we return
32917:       // it but if we get a null pointer, that's perfectly legal for
32917:       // parent and parentContentViewer
32917:       nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
32917:         do_QueryInterface(mDocShell);
39511:       if (!docShellAsItem) {
39511:     	  return;
39511:       }
32917:       nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
32917:       docShellAsItem->GetSameTypeParent(getter_AddRefs(parentAsItem));
32917:       nsCOMPtr<nsIDocShell> parent(do_QueryInterface(parentAsItem));
32917:       if (parent) {
32917:         nsCOMPtr<nsIContentViewer> parentContentViewer;
32917:         nsresult rv =
32917:           parent->GetContentViewer(getter_AddRefs(parentContentViewer));
32917:         if (NS_SUCCEEDED(rv) && parentContentViewer) {
40913:           mucv = do_QueryInterface(parentContentViewer);
32917:         }
32917:       }
32917:     }
40913:     if (mucv) {
40913:       mucv->SetPrevDocCharacterSet(aCharset);
32917:     }
32917:   }
32917: }
32917: 
32917: nsISupports*
32917: nsHtml5TreeOpExecutor::GetTarget()
32917: {
32917:   return mDocument;
32917: }
32917: 
32917: // nsContentSink overrides
32917: 
32917: void
32917: nsHtml5TreeOpExecutor::UpdateChildCounts()
32917: {
32917:   // No-op
32917: }
32917: 
32917: nsresult
32917: nsHtml5TreeOpExecutor::FlushTags()
32917: {
32917:     return NS_OK;
32917: }
32917: 
32917: void
32917: nsHtml5TreeOpExecutor::PostEvaluateScript(nsIScriptElement *aElement)
32917: {
32917:   nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(mDocument);
32917:   NS_ASSERTION(htmlDocument, "Document didn't QI into HTML document.");
32917:   htmlDocument->ScriptExecuted(aElement);
32917: }
32917: 
32917: void
39737: nsHtml5TreeOpExecutor::ContinueInterruptedParsingAsync()
39737: {
39737:   nsCOMPtr<nsIRunnable> flusher = new nsHtml5ExecutorReflusher(this);  
39737:   if (NS_FAILED(NS_DispatchToMainThread(flusher))) {
39737:     NS_WARNING("failed to dispatch executor flush event");
39737:   }          
39737: }
39737: 
39737: void
32917: nsHtml5TreeOpExecutor::UpdateStyleSheet(nsIContent* aElement)
32917: {
34991:   // Break out of the doc update created by Flush() to zap a runnable 
34991:   // waiting to call UpdateStyleSheet without the right observer
34991:   EndDocUpdate();
34991: 
34991:   if (NS_UNLIKELY(!mParser)) {
34991:     // EndDocUpdate ran stuff that called nsIParser::Terminate()
34991:     return;
34991:   }
34991: 
32917:   nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(aElement));
34991:   NS_ASSERTION(ssle, "Node didn't QI to style.");
34991: 
32917:   ssle->SetEnableUpdates(PR_TRUE);
34991: 
32917:   PRBool willNotify;
32917:   PRBool isAlternate;
32917:   nsresult rv = ssle->UpdateStyleSheet(this, &willNotify, &isAlternate);
32917:   if (NS_SUCCEEDED(rv) && willNotify && !isAlternate) {
32917:     ++mPendingSheetCount;
32917:     mScriptLoader->AddExecuteBlocker();
32917:   }
34991: 
38740:   if (aElement->IsHTML() && aElement->Tag() == nsGkAtoms::link) {
38740:     // look for <link rel="next" href="url">
38740:     nsAutoString relVal;
38740:     aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::rel, relVal);
38740:     if (!relVal.IsEmpty()) {
38740:       // XXX seems overkill to generate this string array
38740:       nsAutoTArray<nsString, 4> linkTypes;
38740:       nsStyleLinkElement::ParseLinkTypes(relVal, linkTypes);
38740:       PRBool hasPrefetch = linkTypes.Contains(NS_LITERAL_STRING("prefetch"));
38740:       if (hasPrefetch || linkTypes.Contains(NS_LITERAL_STRING("next"))) {
38740:         nsAutoString hrefVal;
38740:         aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::href, hrefVal);
38740:         if (!hrefVal.IsEmpty()) {
38740:           PrefetchHref(hrefVal, aElement, hasPrefetch);
38740:         }
38740:       }
38740:       if (linkTypes.Contains(NS_LITERAL_STRING("dns-prefetch"))) {
38740:         nsAutoString hrefVal;
38740:         aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::href, hrefVal);
38740:         if (!hrefVal.IsEmpty()) {
38740:           PrefetchDNS(hrefVal);
38740:         }
38740:       }
38740:     }
38740:   }
38740: 
34991:   // Re-open update
34991:   BeginDocUpdate();
32917: }
32917: 
39737: void
39737: nsHtml5TreeOpExecutor::FlushSpeculativeLoads()
39737: {
39737:   if (NS_UNLIKELY(!mParser)) {
39737:     return;
39737:   }
39737:   nsTArray<nsHtml5SpeculativeLoad> speculativeLoadQueue;
39737:   mStage.MoveSpeculativeLoadsTo(speculativeLoadQueue);
39737:   const nsHtml5SpeculativeLoad* start = speculativeLoadQueue.Elements();
39737:   const nsHtml5SpeculativeLoad* end = start + speculativeLoadQueue.Length();
39737:   for (nsHtml5SpeculativeLoad* iter = (nsHtml5SpeculativeLoad*)start;
39737:        iter < end; 
39737:        ++iter) {
39737:     iter->Perform(this);
39737:   }
39737: }
39737: 
39737: class nsHtml5FlushLoopGuard
37622: {
37622:   private:
37622:     nsRefPtr<nsHtml5TreeOpExecutor> mExecutor;
39737:     #ifdef DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
39737:     PRUint32 mStartTime;
39737:     #endif
37622:   public:
39737:     nsHtml5FlushLoopGuard(nsHtml5TreeOpExecutor* aExecutor)
37622:       : mExecutor(aExecutor)
39737:     #ifdef DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
39737:       , mStartTime(PR_IntervalToMilliseconds(PR_IntervalNow()))
39737:     #endif
37622:     {
39737:       mExecutor->mRunFlushLoopOnStack = PR_TRUE;
39737:     }
39737:     ~nsHtml5FlushLoopGuard()
39737:     {
39737:       #ifdef DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
39737:         PRUint32 timeOffTheEventLoop = 
39737:           PR_IntervalToMilliseconds(PR_IntervalNow()) - mStartTime;
39737:         if (timeOffTheEventLoop > 
39737:             nsHtml5TreeOpExecutor::sLongestTimeOffTheEventLoop) {
39737:           nsHtml5TreeOpExecutor::sLongestTimeOffTheEventLoop = 
39737:             timeOffTheEventLoop;
39737:         }
39737:         printf("Longest time off the event loop: %d\n", 
39737:           nsHtml5TreeOpExecutor::sLongestTimeOffTheEventLoop);
39737:       #endif
39737: 
39737:       mExecutor->mRunFlushLoopOnStack = PR_FALSE;
37622:     }
37622: };
37622: 
39737: /**
39737:  * The purpose of the loop here is to avoid returning to the main event loop
39737:  */
32917: void
39737: nsHtml5TreeOpExecutor::RunFlushLoop()
32917: {
39737:   if (mRunFlushLoopOnStack) {
39737:     // There's already a RunFlushLoop() on the call stack.
39737:     return;
39737:   }
39737:   
39737:   nsHtml5FlushLoopGuard guard(this); // this is also the self-kungfu!
39737:   
39737:   nsCOMPtr<nsIParser> parserKungFuDeathGrip(mParser);
39737: 
39737:   // Remember the entry time
39737:   (void) nsContentSink::WillParseImpl();
39737: 
39737:   for (;;) {
34981:     if (!mParser) {
39737:       // Parse has terminated.
37179:       mOpQueue.Clear(); // clear in order to be able to assert in destructor
34979:       return;
34979:     }
39737: 
39737:     if (!mParser->IsParserEnabled()) {
39737:       // The parser is blocked.
39737:       return;
39737:     }
39737:   
35590:     if (mFlushState != eNotFlushing) {
39737:       // XXX Can this happen? In case it can, let's avoid crashing.
39737:       return;
39737:     }
39737:     
39737:     // If there are scripts executing, then the content sink is jumping the gun
39737:     // (probably due to a synchronous XMLHttpRequest) and will re-enable us
39737:     // later, see bug 460706.
39737:     if (IsScriptExecuting()) {
39737:       return;
39737:     }
39737: 
39737:     if (mReadingFromStage) {
39737:       nsTArray<nsHtml5SpeculativeLoad> speculativeLoadQueue;
39737:       mStage.MoveOpsAndSpeculativeLoadsTo(mOpQueue, speculativeLoadQueue);
39737:       // Make sure speculative loads never start after the corresponding
39737:       // normal loads for the same URLs.
39737:       const nsHtml5SpeculativeLoad* start = speculativeLoadQueue.Elements();
39737:       const nsHtml5SpeculativeLoad* end = start + speculativeLoadQueue.Length();
39737:       for (nsHtml5SpeculativeLoad* iter = (nsHtml5SpeculativeLoad*)start;
39737:            iter < end;
39737:            ++iter) {
39737:         iter->Perform(this);
39737:       }
39737:     } else {
39737:       FlushSpeculativeLoads(); // Make sure speculative loads never start after
39737:                                // the corresponding normal loads for the same
39737:                                // URLs.
39737:       // Not sure if this grip is still needed, but previously, the code
39737:       // gripped before calling ParseUntilBlocked();
39737:       nsRefPtr<nsHtml5StreamParser> streamKungFuDeathGrip = 
39737:         static_cast<nsHtml5Parser*> (mParser.get())->GetStreamParser();
39737:       // Now parse content left in the document.write() buffer queue if any.
39737:       // This may generate tree ops on its own or dequeue a speculation.
39737:       static_cast<nsHtml5Parser*> (mParser.get())->ParseUntilBlocked();
39737:     }
39737: 
39737:     if (mOpQueue.IsEmpty()) {
39737:       // Avoid bothering the rest of the engine with a doc update if there's 
39737:       // nothing to do.
34983:       return;
34983:     }
34983: 
35590:     mFlushState = eInFlush;
34979: 
35590:     nsIContent* scriptElement = nsnull;
35590:     
34991:     BeginDocUpdate();
34991: 
37622:     PRUint32 numberOfOpsToFlush = mOpQueue.Length();
37622: 
37622:     mElementsSeenInThisAppendBatch.SetCapacity(numberOfOpsToFlush * 2);
37622: 
39737:     const nsHtml5TreeOperation* first = mOpQueue.Elements();
39737:     const nsHtml5TreeOperation* last = first + numberOfOpsToFlush - 1;
39737:     for (nsHtml5TreeOperation* iter = (nsHtml5TreeOperation*)first;;) {
34985:       if (NS_UNLIKELY(!mParser)) {
39737:         // The previous tree op caused a call to nsIParser::Terminate().
34985:         break;
34985:       }
39737:       NS_ASSERTION(mFlushState == eInDocUpdate, 
39737:         "Tried to perform tree op outside update batch.");
35590:       iter->Perform(this, &scriptElement);
39737: 
39737:       // Be sure not to check the deadline if the last op was just performed.
39737:       if (NS_UNLIKELY(iter == last)) {
39737:         break;
39737:       } else if (NS_UNLIKELY(nsContentSink::DidProcessATokenImpl() == 
39737:                              NS_ERROR_HTMLPARSER_INTERRUPTED)) {
39737:         mOpQueue.RemoveElementsAt(0, (iter - first) + 1);
39737:         
39737:         EndDocUpdate();
39737: 
39737:         mFlushState = eNotFlushing;
39737: 
39737:         #ifdef DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
39737:           printf("REFLUSH SCHEDULED (executing ops): %d\n", 
39737:             ++sTimesFlushLoopInterrupted);
39737:         #endif
39737:         nsHtml5TreeOpExecutor::ContinueInterruptedParsingAsync();
39737:         return;
39737:       }
39737:       ++iter;
34991:     }
34991:     
39737:     mOpQueue.Clear();
34991:     
34991:     EndDocUpdate();
34983: 
35590:     mFlushState = eNotFlushing;
34983: 
37622:     if (NS_UNLIKELY(!mParser)) {
39737:       // The parse ended already.
34985:       return;
34985:     }
34985: 
35590:     if (scriptElement) {
39737:       // must be tail call when mFlushState is eNotFlushing
39737:       RunScript(scriptElement);
39737:       
39737:       // The script execution machinery makes sure this doesn't get deflected.
39737:       if (nsContentSink::DidProcessATokenImpl() == 
39737:           NS_ERROR_HTMLPARSER_INTERRUPTED) {
37622:         #ifdef DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
39737:           printf("REFLUSH SCHEDULED (after script): %d\n", 
39737:             ++sTimesFlushLoopInterrupted);
37622:         #endif
39737:         nsHtml5TreeOpExecutor::ContinueInterruptedParsingAsync();
39737:         return;      
37622:       }
34979:     }
34979:   }
39737: }
39737: 
39737: void
39737: nsHtml5TreeOpExecutor::FlushDocumentWrite()
39737: {
39737:   if (!mParser) {
39737:     // The parse has ended.
39737:     mOpQueue.Clear(); // clear in order to be able to assert in destructor
39737:     return;
39737:   }
39737:   
39737:   FlushSpeculativeLoads(); // Make sure speculative loads never start after the 
39737:                 // corresponding normal loads for the same URLs.
39737: 
39737:   if (mFlushState != eNotFlushing) {
39737:     // XXX Can this happen? In case it can, let's avoid crashing.
39737:     return;
39737:   }
39737: 
39737:   mFlushState = eInFlush;
39737: 
39737:   // avoid crashing near EOF
39737:   nsRefPtr<nsHtml5TreeOpExecutor> kungFuDeathGrip(this);
39737:   nsCOMPtr<nsIParser> parserKungFuDeathGrip(mParser);
39737: 
39737:   NS_ASSERTION(!mReadingFromStage,
39737:     "Got doc write flush when reading from stage");
39737: 
39737: #ifdef DEBUG
39737:   mStage.AssertEmpty();
39737: #endif
39737:   
39737:   nsIContent* scriptElement = nsnull;
39737:   
39737:   BeginDocUpdate();
39737: 
39737:   PRUint32 numberOfOpsToFlush = mOpQueue.Length();
39737: 
39737:   mElementsSeenInThisAppendBatch.SetCapacity(numberOfOpsToFlush * 2);
39737: 
39737:   const nsHtml5TreeOperation* start = mOpQueue.Elements();
39737:   const nsHtml5TreeOperation* end = start + numberOfOpsToFlush;
39737:   for (nsHtml5TreeOperation* iter = (nsHtml5TreeOperation*)start;
39737:        iter < end; 
39737:        ++iter) {
39737:     if (NS_UNLIKELY(!mParser)) {
39737:       // The previous tree op caused a call to nsIParser::Terminate().
39737:       break;
39737:     }
39737:     NS_ASSERTION(mFlushState == eInDocUpdate, 
39737:       "Tried to perform tree op outside update batch.");
39737:     iter->Perform(this, &scriptElement);
39737:   }
39737: 
39737:   mOpQueue.Clear();
39737:   
39737:   EndDocUpdate();
39737: 
39737:   mFlushState = eNotFlushing;
39737: 
39737:   if (NS_UNLIKELY(!mParser)) {
39737:     // Ending the doc update caused a call to nsIParser::Terminate().
39737:     return;
39737:   }
39737: 
39737:   if (scriptElement) {
39737:     // must be tail call when mFlushState is eNotFlushing
39737:     RunScript(scriptElement);
39737:   }
39737: }
34979: 
32917: // copied from HTML content sink
32917: PRBool
32917: nsHtml5TreeOpExecutor::IsScriptEnabled()
32917: {
43097:   if (!mDocument || !mDocShell)
43097:     return PR_TRUE;
32917:   nsCOMPtr<nsIScriptGlobalObject> globalObject = mDocument->GetScriptGlobalObject();
32917:   // Getting context is tricky if the document hasn't had its
32917:   // GlobalObject set yet
32917:   if (!globalObject) {
32917:     nsCOMPtr<nsIScriptGlobalObjectOwner> owner = do_GetInterface(mDocShell);
32917:     NS_ENSURE_TRUE(owner, PR_TRUE);
32917:     globalObject = owner->GetScriptGlobalObject();
32917:     NS_ENSURE_TRUE(globalObject, PR_TRUE);
32917:   }
32917:   nsIScriptContext *scriptContext = globalObject->GetContext();
32917:   NS_ENSURE_TRUE(scriptContext, PR_TRUE);
32917:   JSContext* cx = (JSContext *) scriptContext->GetNativeContext();
32917:   NS_ENSURE_TRUE(cx, PR_TRUE);
32917:   PRBool enabled = PR_TRUE;
32917:   nsContentUtils::GetSecurityManager()->
32917:     CanExecuteScripts(cx, mDocument->NodePrincipal(), &enabled);
32917:   return enabled;
32917: }
32917: 
32917: void
40913: nsHtml5TreeOpExecutor::SetDocumentMode(nsHtml5DocumentMode m)
32917: {
32917:   nsCompatibility mode = eCompatibility_NavQuirks;
32917:   switch (m) {
32917:     case STANDARDS_MODE:
32917:       mode = eCompatibility_FullStandards;
32917:       break;
32917:     case ALMOST_STANDARDS_MODE:
32917:       mode = eCompatibility_AlmostStandards;
32917:       break;
32917:     case QUIRKS_MODE:
32917:       mode = eCompatibility_NavQuirks;
32917:       break;
32917:   }
32917:   nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(mDocument);
32917:   NS_ASSERTION(htmlDocument, "Document didn't QI into HTML document.");
32917:   htmlDocument->SetCompatibilityMode(mode);
32917: }
32917: 
39513: void
39513: nsHtml5TreeOpExecutor::StartLayout() {
39513:   if (mLayoutStarted || !mDocument) {
39513:     return;
39513:   }
39513: 
39513:   EndDocUpdate();
39513: 
39513:   if(NS_UNLIKELY(!mParser)) {
39513:     // got terminate
39513:     return;
39513:   }
39513: 
39513:   nsContentSink::StartLayout(PR_FALSE);
39513: 
39513:   BeginDocUpdate();
39513: }
39513: 
32917: /**
34979:  * The reason why this code is here and not in the tree builder even in the 
34979:  * main-thread case is to allow the control to return from the tokenizer 
34979:  * before scripts run. This way, the tokenizer is not invoked re-entrantly 
34979:  * although the parser is.
35590:  *
35590:  * The reason why this is called as a tail call when mFlushState is set to
35590:  * eNotFlushing is to allow re-entry to Flush() but only after the current 
35590:  * Flush() has cleared the op queue and is otherwise done cleaning up after 
35590:  * itself.
32917:  */
32917: void
35590: nsHtml5TreeOpExecutor::RunScript(nsIContent* aScriptElement)
32917: {
35590:   NS_ASSERTION(aScriptElement, "No script to run");
35590:   nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(aScriptElement);
35590:   
34981:   if (!mParser) {
34979:     NS_ASSERTION(sele->IsMalformed(), "Script wasn't marked as malformed.");
34979:     // We got here not because of an end tag but because the tree builder
34979:     // popped an incomplete script element on EOF. Returning here to avoid
35590:     // calling back into mParser anymore.
34979:     return;
32917:   }
35590:   
35590:   if (mFragmentMode) {
57328:     if (mPreventScriptExecution) {
35590:       sele->PreventExecution();
57328:     }
35590:     return;
35590:   }
35590: 
35607:   if (sele->GetScriptDeferred() || sele->GetScriptAsync()) {
35607:     #ifdef DEBUG
35607:     nsresult rv = 
35607:     #endif
35607:     aScriptElement->DoneAddingChildren(PR_TRUE); // scripts ignore the argument
35607:     NS_ASSERTION(rv != NS_ERROR_HTMLPARSER_BLOCK, 
35607:                  "Defer or async script tried to block.");
35607:     return;
35607:   }
35607:   
35607:   NS_ASSERTION(mFlushState == eNotFlushing, "Tried to run script when flushing.");
35607: 
35607:   mReadingFromStage = PR_FALSE;
35607:   
34983:   sele->SetCreatorParser(mParser);
35607: 
32917:   // Notify our document that we're loading this script.
32917:   nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(mDocument);
32917:   NS_ASSERTION(htmlDocument, "Document didn't QI into HTML document.");
32917:   htmlDocument->ScriptLoading(sele);
35607: 
32917:   // Copied from nsXMLContentSink
32917:   // Now tell the script that it's ready to go. This may execute the script
32917:   // or return NS_ERROR_HTMLPARSER_BLOCK. Or neither if the script doesn't
32917:   // need executing.
35590:   nsresult rv = aScriptElement->DoneAddingChildren(PR_TRUE);
35607: 
32917:   // If the act of insertion evaluated the script, we're fine.
32917:   // Else, block the parser till the script has loaded.
32917:   if (rv == NS_ERROR_HTMLPARSER_BLOCK) {
32917:     mScriptElements.AppendObject(sele);
62663:     if (mParser) {
32917:       mParser->BlockParser();
62663:     }
34981:   } else {
32917:     // This may have already happened if the script executed, but in case
32917:     // it didn't then remove the element so that it doesn't get stuck forever.
32917:     htmlDocument->ScriptExecuted(sele);
39737:     
39737:     // mParser may have been nulled out by now, but the flusher deals
39737: 
39737:     // If this event isn't needed, it doesn't do anything. It is sometimes
39737:     // necessary for the parse to continue after complex situations.
39737:     nsHtml5TreeOpExecutor::ContinueInterruptedParsingAsync();
32917:   }
32917: }
32917: 
32917: nsresult
32917: nsHtml5TreeOpExecutor::Init(nsIDocument* aDoc,
32917:                             nsIURI* aURI,
32917:                             nsISupports* aContainer,
32917:                             nsIChannel* aChannel)
32917: {
39737:   return nsContentSink::Init(aDoc, aURI, aContainer, aChannel);
32917: }
32917: 
32917: void
32917: nsHtml5TreeOpExecutor::Start()
32917: {
34981:   NS_PRECONDITION(!mStarted, "Tried to start when already started.");
34981:   mStarted = PR_TRUE;
32917: }
32917: 
32917: void
62346: nsHtml5TreeOpExecutor::NeedsCharsetSwitchTo(const char* aEncoding,
62346:                                             PRInt32 aSource)
32917: {
35590:   EndDocUpdate();
35590: 
35590:   if(NS_UNLIKELY(!mParser)) {
35590:     // got terminate
35590:     return;
34986:   }
34986:   
34979:   nsCOMPtr<nsIWebShellServices> wss = do_QueryInterface(mDocShell);
34979:   if (!wss) {
34979:     return;
32917:   }
38273: 
34979:   // ask the webshellservice to load the URL
38273:   if (NS_SUCCEEDED(wss->StopDocumentLoad())) {
62346:     wss->ReloadDocument(aEncoding, aSource);
34979:   }
34979:   // if the charset switch was accepted, wss has called Terminate() on the
34979:   // parser by now
35590: 
35590:   if (!mParser) {
35590:     // success
35590:     return;
35590:   }
35590: 
35590:   (static_cast<nsHtml5Parser*> (mParser.get()))->ContinueAfterFailedCharsetSwitch();
35590: 
35590:   BeginDocUpdate();
32917: }
32917: 
32917: nsHtml5Tokenizer*
32917: nsHtml5TreeOpExecutor::GetTokenizer()
32917: {
32917:   return (static_cast<nsHtml5Parser*> (mParser.get()))->GetTokenizer();
32917: }
32917: 
32917: void
34979: nsHtml5TreeOpExecutor::Reset() {
41067:   DropHeldElements();
34979:   mReadingFromStage = PR_FALSE;
34979:   mOpQueue.Clear();
34981:   mStarted = PR_FALSE;
35590:   mFlushState = eNotFlushing;
39737:   mRunFlushLoopOnStack = PR_FALSE;
35590:   mFragmentMode = PR_FALSE;
32917: }
32917: 
32917: void
35600: nsHtml5TreeOpExecutor::MoveOpsFrom(nsTArray<nsHtml5TreeOperation>& aOpQueue)
34979: {
35590:   NS_PRECONDITION(mFlushState == eNotFlushing, "mOpQueue modified during tree op execution.");
34979:   if (mOpQueue.IsEmpty()) {
34979:     mOpQueue.SwapElements(aOpQueue);
34979:     return;
32917:   }
34979:   mOpQueue.MoveElementsFrom(aOpQueue);
32917: }
32917: 
32917: void
35294: nsHtml5TreeOpExecutor::InitializeDocWriteParserState(nsAHtml5TreeBuilderState* aState, PRInt32 aLine)
34979: {
35294:   static_cast<nsHtml5Parser*> (mParser.get())->InitializeDocWriteParserState(aState, aLine);
32917: }
32917: 
39737: // Speculative loading
39737: 
39737: already_AddRefed<nsIURI>
39737: nsHtml5TreeOpExecutor::ConvertIfNotPreloadedYet(const nsAString& aURL)
39737: {
48403:   // The URL of the document without <base>
48403:   nsIURI* documentURI = mDocument->GetDocumentURI();
48403:   // The URL of the document with non-speculative <base>
48403:   nsIURI* documentBaseURI = mDocument->GetDocBaseURI();
48403: 
48403:   // If the two above are different, use documentBaseURI. If they are the
48403:   // same, the document object isn't aware of a <base>, so attempt to use the
48403:   // mSpeculationBaseURI or, failing, that, documentURI.
48403:   nsIURI* base = (documentURI == documentBaseURI) ?
48403:                   (mSpeculationBaseURI ?
48403:                    mSpeculationBaseURI.get() : documentURI)
48403:                  : documentBaseURI;
39737:   const nsCString& charset = mDocument->GetDocumentCharacterSet();
39737:   nsCOMPtr<nsIURI> uri;
39737:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURL, charset.get(), base);
39737:   if (NS_FAILED(rv)) {
39737:     NS_WARNING("Failed to create a URI");
39737:     return nsnull;
39737:   }
39737:   nsCAutoString spec;
39737:   uri->GetSpec(spec);
39737:   if (mPreloadedURLs.Contains(spec)) {
39737:     return nsnull;
39737:   }
39737:   mPreloadedURLs.Put(spec);
39737:   nsIURI* retURI = uri;
39737:   NS_ADDREF(retURI);
39737:   return retURI;
39737: }
39737: 
39737: void
39737: nsHtml5TreeOpExecutor::PreloadScript(const nsAString& aURL,
39737:                                      const nsAString& aCharset,
39737:                                      const nsAString& aType)
39737: {
39737:   nsCOMPtr<nsIURI> uri = ConvertIfNotPreloadedYet(aURL);
39737:   if (!uri) {
39737:     return;
39737:   }
39737:   mDocument->ScriptLoader()->PreloadURI(uri, aCharset, aType);
39737: }
39737: 
39737: void
39737: nsHtml5TreeOpExecutor::PreloadStyle(const nsAString& aURL,
39737:                                     const nsAString& aCharset)
39737: {
39737:   nsCOMPtr<nsIURI> uri = ConvertIfNotPreloadedYet(aURL);
39737:   if (!uri) {
39737:     return;
39737:   }
39737:   mDocument->PreloadStyle(uri, aCharset);
39737: }
39737: 
39737: void
39737: nsHtml5TreeOpExecutor::PreloadImage(const nsAString& aURL)
39737: {
39737:   nsCOMPtr<nsIURI> uri = ConvertIfNotPreloadedYet(aURL);
39737:   if (!uri) {
39737:     return;
39737:   }
39737:   mDocument->MaybePreLoadImage(uri);
39737: }
39737: 
48403: void
48403: nsHtml5TreeOpExecutor::SetSpeculationBase(const nsAString& aURL)
48403: {
48403:   if (mSpeculationBaseURI) {
48403:     // the first one wins
48403:     return;
48403:   }
48403:   const nsCString& charset = mDocument->GetDocumentCharacterSet();
48403:   nsresult rv = NS_NewURI(getter_AddRefs(mSpeculationBaseURI), aURL,
48403:       charset.get(), mDocument->GetDocumentURI());
48403:   if (NS_FAILED(rv)) {
48403:     NS_WARNING("Failed to create a URI");
48403:   }
48403: }
48403: 
37622: #ifdef DEBUG_NS_HTML5_TREE_OP_EXECUTOR_FLUSH
32917: PRUint32 nsHtml5TreeOpExecutor::sAppendBatchMaxSize = 0;
32917: PRUint32 nsHtml5TreeOpExecutor::sAppendBatchSlotsExamined = 0;
32917: PRUint32 nsHtml5TreeOpExecutor::sAppendBatchExaminations = 0;
39737: PRUint32 nsHtml5TreeOpExecutor::sLongestTimeOffTheEventLoop = 0;
39737: PRUint32 nsHtml5TreeOpExecutor::sTimesFlushLoopInterrupted = 0;
32917: #endif
