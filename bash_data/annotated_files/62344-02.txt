    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for DOM Core's nsIDOMComment, nsIDOMDocumentType, nsIDOMText,
    1:  * nsIDOMCDATASection, and nsIDOMProcessingInstruction nodes.
    1:  */
    1: 
    1: #include "nsGenericDOMDataNode.h"
    1: #include "nsGenericElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsMutationEvent.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOM3Node.h"
    1: #include "nsIURI.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIDOMText.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsDOMString.h"
    1: #include "nsIDOMUserDataHandler.h"
    1: #include "nsChangeHint.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsCOMArray.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsBindingManager.h"
13669: #include "nsCCUncollectableMarker.h"
14228: #include "mozAutoDocUpdate.h"
    1: 
    1: #include "pldhash.h"
    1: #include "prprf.h"
    1: 
48124: nsGenericDOMDataNode::nsGenericDOMDataNode(already_AddRefed<nsINodeInfo> aNodeInfo)
11169:   : nsIContent(aNodeInfo)
    1: {
    1: }
    1: 
    1: nsGenericDOMDataNode::~nsGenericDOMDataNode()
    1: {
    1:   NS_PRECONDITION(!IsInDoc(),
    1:                   "Please remove this from the document properly");
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGenericDOMDataNode)
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsGenericDOMDataNode)
30001:   NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_END
30001: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGenericDOMDataNode)
30001:   // Always need to traverse script objects, so do that before we check
30001:   // if we're uncollectable.
30001:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
30001: 
13669:   nsIDocument* currentDoc = tmp->GetCurrentDoc();
13669:   if (currentDoc && nsCCUncollectableMarker::InGeneration(
30096:                       cb, currentDoc->GetMarkedCCGeneration())) {
25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
13669:   }
13669: 
13669:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
13669: 
13669:   nsIDocument* ownerDoc = tmp->GetOwnerDoc();
13669:   if (ownerDoc) {
13669:     ownerDoc->BindingManager()->Traverse(tmp, cb);
13669:   }
13669: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_LISTENERMANAGER
 1391:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsGenericDOMDataNode)
30001:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_END
30001: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGenericDOMDataNode)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_LISTENERMANAGER
 1391:   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
21618: NS_INTERFACE_MAP_BEGIN(nsGenericDOMDataNode)
21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
21618:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsGenericDOMDataNode)
    1:   NS_INTERFACE_MAP_ENTRY(nsIContent)
    1:   NS_INTERFACE_MAP_ENTRY(nsINode)
    1:   NS_INTERFACE_MAP_ENTRY(nsPIDOMEventTarget)
    1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMEventTarget,
    1:                                  nsDOMEventRTTearoff::Create(this))
    1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3EventTarget,
    1:                                  nsDOMEventRTTearoff::Create(this))
    1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNSEventTarget,
    1:                                  nsDOMEventRTTearoff::Create(this))
    1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsISupportsWeakReference,
    1:                                  new nsNodeSupportsWeakRefTearoff(this))
    1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3Node, new nsNode3Tearoff(this))
29215:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMXPathNSResolver,
29215:                                  new nsNode3Tearoff(this))
 8856:   // nsNodeSH::PreCreate() depends on the identity pointer being the
 8856:   // same as nsINode (which nsIContent inherits), so if you change the
 8856:   // below line, make sure nsNodeSH::PreCreate() still does the right
 8856:   // thing!
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContent)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsGenericDOMDataNode, nsIContent)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_FULL(nsGenericDOMDataNode, nsIContent,
 1391:                                       nsNodeUtils::LastRelease(this))
    1: 
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetNodeValue(nsAString& aNodeValue)
    1: {
    1:   return GetData(aNodeValue);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetNodeValue(const nsAString& aNodeValue)
    1: {
    1:   return SetTextInternal(0, mText.GetLength(), aNodeValue.BeginReading(),
    1:                          aNodeValue.Length(), PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetNamespaceURI(nsAString& aNamespaceURI)
    1: {
    1:   SetDOMStringToNull(aNamespaceURI);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetPrefix(nsAString& aPrefix)
    1: {
    1:   SetDOMStringToNull(aPrefix);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetPrefix(const nsAString& aPrefix)
    1: {
    1:   return NS_ERROR_DOM_NAMESPACE_ERR;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetLocalName(nsAString& aLocalName)
    1: {
    1:   SetDOMStringToNull(aLocalName);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::Normalize()
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::IsSupported(const nsAString& aFeature,
    1:                                   const nsAString& aVersion,
    1:                                   PRBool* aReturn)
    1: {
 3233:   return nsGenericElement::InternalIsSupported(static_cast<nsIContent*>(this),
    1:                                                aFeature, aVersion, aReturn);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Implementation of nsIDOMCharacterData
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetData(nsAString& aData) const
    1: {
    1:   if (mText.Is2b()) {
    1:     aData.Assign(mText.Get2b(), mText.GetLength());
    1:   } else {
    1:     // Must use Substring() since nsDependentCString() requires null
    1:     // terminated strings.
    1: 
    1:     const char *data = mText.Get1b();
    1: 
    1:     if (data) {
    1:       CopyASCIItoUTF16(Substring(data, data + mText.GetLength()), aData);
    1:     } else {
    1:       aData.Truncate();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetData(const nsAString& aData)
    1: {
    1:   return SetTextInternal(0, mText.GetLength(), aData.BeginReading(),
    1:                          aData.Length(), PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetLength(PRUint32* aLength)
    1: {
    1:   *aLength = mText.GetLength();
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SubstringData(PRUint32 aStart, PRUint32 aCount,
    1:                                     nsAString& aReturn)
    1: {
    1:   aReturn.Truncate();
    1: 
40638:   PRUint32 textLength = mText.GetLength();
    1:   if (aStart > textLength) {
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1:   }
    1: 
    1:   PRUint32 amount = aCount;
    1:   if (amount > textLength - aStart) {
    1:     amount = textLength - aStart;
    1:   }
    1: 
    1:   if (mText.Is2b()) {
    1:     aReturn.Assign(mText.Get2b() + aStart, amount);
    1:   } else {
    1:     // Must use Substring() since nsDependentCString() requires null
    1:     // terminated strings.
    1: 
    1:     const char *data = mText.Get1b() + aStart;
    1:     CopyASCIItoUTF16(Substring(data, data + amount), aReturn);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::AppendData(const nsAString& aData)
    1: {
    1:   return SetTextInternal(mText.GetLength(), 0, aData.BeginReading(),
    1:                          aData.Length(), PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::InsertData(PRUint32 aOffset,
    1:                                  const nsAString& aData)
    1: {
    1:   return SetTextInternal(aOffset, 0, aData.BeginReading(),
    1:                          aData.Length(), PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::DeleteData(PRUint32 aOffset, PRUint32 aCount)
    1: {
    1:   return SetTextInternal(aOffset, aCount, nsnull, 0, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::ReplaceData(PRUint32 aOffset, PRUint32 aCount,
    1:                                   const nsAString& aData)
    1: {
    1:   return SetTextInternal(aOffset, aCount, aData.BeginReading(),
    1:                          aData.Length(), PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetTextInternal(PRUint32 aOffset, PRUint32 aCount,
    1:                                       const PRUnichar* aBuffer,
    1:                                       PRUint32 aLength, PRBool aNotify)
    1: {
    1:   NS_PRECONDITION(aBuffer || !aLength,
    1:                   "Null buffer passed to SetTextInternal!");
    1: 
    1:   // sanitize arguments
    1:   PRUint32 textLength = mText.GetLength();
    1:   if (aOffset > textLength) {
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1:   }
    1: 
40638:   if (aCount > textLength - aOffset) {
40638:     aCount = textLength - aOffset;
40638:   }
40638: 
40638:   PRUint32 endOffset = aOffset + aCount;
40638: 
40638:   // Make sure the text fragment can hold the new data.
40638:   if (aLength > aCount && !mText.CanGrowBy(aLength - aCount)) {
40638:     // This exception isn't per spec, but the spec doesn't actually
40638:     // say what to do here.
40638: 
40638:     return NS_ERROR_DOM_DOMSTRING_SIZE_ERR;
40638:   }
40638: 
    1:   nsIDocument *document = GetCurrentDoc();
    1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
    1: 
    1:   PRBool haveMutationListeners = aNotify &&
    1:     nsContentUtils::HasMutationListeners(this,
 3137:       NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED,
 3137:       this);
    1: 
    1:   nsCOMPtr<nsIAtom> oldValue;
    1:   if (haveMutationListeners) {
    1:     oldValue = GetCurrentValueAtom();
    1:   }
    1:     
 5681:   if (aNotify) {
 5681:     CharacterDataChangeInfo info = {
 5681:       aOffset == textLength,
 5681:       aOffset,
 5681:       endOffset,
 5681:       aLength
 5681:     };
 5681:     nsNodeUtils::CharacterDataWillChange(this, &info);
 5681:   }
 5681: 
    1:   if (aOffset == 0 && endOffset == textLength) {
    1:     // Replacing whole text or old text was empty
    1:     mText.SetTo(aBuffer, aLength);
    1:   }
    1:   else if (aOffset == textLength) {
    1:     // Appending to existing
    1:     mText.Append(aBuffer, aLength);
    1:   }
    1:   else {
    1:     // Merging old and new
    1: 
    1:     // Allocate new buffer
    1:     PRInt32 newLength = textLength - aCount + aLength;
    1:     PRUnichar* to = new PRUnichar[newLength];
    1:     NS_ENSURE_TRUE(to, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     // Copy over appropriate data
40638:     if (aOffset) {
    1:       mText.CopyTo(to, 0, aOffset);
    1:     }
40638:     if (aLength) {
    1:       memcpy(to + aOffset, aBuffer, aLength * sizeof(PRUnichar));
    1:     }
    1:     if (endOffset != textLength) {
    1:       mText.CopyTo(to + aOffset + aLength, endOffset, textLength - endOffset);
    1:     }
    1: 
    1:     // XXX Add OOM checking to this
    1:     mText.SetTo(to, newLength);
    1: 
    1:     delete [] to;
    1:   }
    1: 
53733:   UpdateBidiStatus(aBuffer, aLength);
    1: 
    1:   // Notify observers
    1:   if (aNotify) {
 5845:     CharacterDataChangeInfo info = {
 5845:       aOffset == textLength,
 5845:       aOffset,
 5845:       endOffset,
 5845:       aLength
 5845:     };
 5845:     nsNodeUtils::CharacterDataChanged(this, &info);
 5845: 
    1:     if (haveMutationListeners) {
34394:       mozAutoRemovableBlockerRemover blockerRemover(GetOwnerDoc());
14319: 
    1:       nsMutationEvent mutation(PR_TRUE, NS_MUTATION_CHARACTERDATAMODIFIED);
    1: 
    1:       mutation.mPrevAttrValue = oldValue;
    1:       if (aLength > 0) {
    1:         nsAutoString val;
    1:         mText.AppendTo(val);
    1:         mutation.mNewAttrValue = do_GetAtom(val);
    1:       }
    1: 
   62:       mozAutoSubtreeModified subtree(GetOwnerDoc(), this);
    1:       nsEventDispatcher::Dispatch(this, nsnull, &mutation);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Implementation of nsIContent
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsGenericDOMDataNode::ToCString(nsAString& aBuf, PRInt32 aOffset,
    1:                                 PRInt32 aLen) const
    1: {
    1:   if (mText.Is2b()) {
    1:     const PRUnichar* cp = mText.Get2b() + aOffset;
    1:     const PRUnichar* end = cp + aLen;
    1: 
    1:     while (cp < end) {
    1:       PRUnichar ch = *cp++;
    1:       if (ch == '&') {
    1:         aBuf.AppendLiteral("&amp;");
    1:       } else if (ch == '<') {
    1:         aBuf.AppendLiteral("&lt;");
    1:       } else if (ch == '>') {
    1:         aBuf.AppendLiteral("&gt;");
    1:       } else if ((ch < ' ') || (ch >= 127)) {
    1:         char buf[10];
    1:         PR_snprintf(buf, sizeof(buf), "\\u%04x", ch);
    1:         AppendASCIItoUTF16(buf, aBuf);
    1:       } else {
    1:         aBuf.Append(ch);
    1:       }
    1:     }
    1:   } else {
    1:     unsigned char* cp = (unsigned char*)mText.Get1b() + aOffset;
    1:     const unsigned char* end = cp + aLen;
    1: 
    1:     while (cp < end) {
    1:       PRUnichar ch = *cp++;
    1:       if (ch == '&') {
    1:         aBuf.AppendLiteral("&amp;");
    1:       } else if (ch == '<') {
    1:         aBuf.AppendLiteral("&lt;");
    1:       } else if (ch == '>') {
    1:         aBuf.AppendLiteral("&gt;");
    1:       } else if ((ch < ' ') || (ch >= 127)) {
    1:         char buf[10];
    1:         PR_snprintf(buf, sizeof(buf), "\\u%04x", ch);
    1:         AppendASCIItoUTF16(buf, aBuf);
    1:       } else {
    1:         aBuf.Append(ch);
    1:       }
    1:     }
    1:   }
    1: }
    1: #endif
    1: 
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                                  nsIContent* aBindingParent,
    1:                                  PRBool aCompileEventHandlers)
    1: {
    1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
    1:   NS_PRECONDITION(HasSameOwnerDoc(NODE_FROM(aParent, aDocument)),
    1:                   "Must have the same owner document");
 1498:   NS_PRECONDITION(!aParent || aDocument == aParent->GetCurrentDoc(),
    1:                   "aDocument must be current doc of aParent");
    1:   NS_PRECONDITION(!GetCurrentDoc() && !IsInDoc(),
    1:                   "Already have a document.  Unbind first!");
    1:   // Note that as we recurse into the kids, they'll have a non-null parent.  So
    1:   // only assert if our parent is _changing_ while we have a parent.
    1:   NS_PRECONDITION(!GetParent() || aParent == GetParent(),
    1:                   "Already have a parent.  Unbind first!");
    1:   NS_PRECONDITION(!GetBindingParent() ||
    1:                   aBindingParent == GetBindingParent() ||
    1:                   (!aBindingParent && aParent &&
    1:                    aParent->GetBindingParent() == GetBindingParent()),
    1:                   "Already have a binding parent.  Unbind first!");
16126:   NS_PRECONDITION(aBindingParent != this,
16126:                   "Content must not be its own binding parent");
16126:   NS_PRECONDITION(!IsRootOfNativeAnonymousSubtree() || 
16126:                   aBindingParent == aParent,
16126:                   "Native anonymous content must have its parent as its "
 1111:                   "own binding parent");
    1: 
    1:   if (!aBindingParent && aParent) {
    1:     aBindingParent = aParent->GetBindingParent();
    1:   }
    1: 
    1:   // First set the binding parent
    1:   if (aBindingParent) {
    1:     nsDataSlots *slots = GetDataSlots();
    1:     NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
    1: 
16126:     NS_ASSERTION(IsRootOfNativeAnonymousSubtree() ||
16126:                  !HasFlag(NODE_IS_IN_ANONYMOUS_SUBTREE) ||
22217:                  (aParent && aParent->IsInNativeAnonymousSubtree()),
14239:                  "Trying to re-bind content from native anonymous subtree to "
14239:                  "non-native anonymous parent!");
    1:     slots->mBindingParent = aBindingParent; // Weak, so no addref happens.
25511:     if (aParent->IsInNativeAnonymousSubtree()) {
14239:       SetFlags(NODE_IS_IN_ANONYMOUS_SUBTREE);
14239:     }
    1:   }
    1: 
    1:   // Set parent
    1:   if (aParent) {
    1:     mParentPtrBits =
 3233:       reinterpret_cast<PtrBits>(aParent) | PARENT_BIT_PARENT_IS_CONTENT;
    1:   }
    1:   else {
 3233:     mParentPtrBits = reinterpret_cast<PtrBits>(aDocument);
    1:   }
    1: 
    1:   // XXXbz sXBL/XBL2 issue!
    1: 
    1:   // Set document
    1:   if (aDocument) {
    1:     // XXX See the comment in nsGenericElement::BindToTree
    1:     mParentPtrBits |= PARENT_BIT_INDOCUMENT;
    1:     if (mText.IsBidi()) {
15376:       aDocument->SetBidiEnabled();
    1:     }
40938:     // Clear the lazy frame construction bits.
40938:     UnsetFlags(NODE_NEEDS_FRAME | NODE_DESCENDANTS_NEED_FRAMES);
    1:   }
    1: 
    1:   nsNodeUtils::ParentChainChanged(this);
    1: 
 2896:   UpdateEditableState();
 2896: 
    1:   NS_POSTCONDITION(aDocument == GetCurrentDoc(), "Bound to wrong document");
    1:   NS_POSTCONDITION(aParent == GetParent(), "Bound to wrong parent");
    1:   NS_POSTCONDITION(aBindingParent == GetBindingParent(),
    1:                    "Bound to wrong binding parent");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGenericDOMDataNode::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
    1: {
29809:   // Unset frame flags; if we need them again later, they'll get set again.
29809:   UnsetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE |
29809:              NS_REFRAME_IF_WHITESPACE);
27311:   
    1:   nsIDocument *document = GetCurrentDoc();
    1:   if (document) {
    1:     // Notify XBL- & nsIAnonymousContentCreator-generated
    1:     // anonymous content that the document is changing.
    1:     // This is needed to update the insertion point.
43087:     document->BindingManager()->RemovedFromDocument(this, document);
    1:   }
    1: 
    1:   mParentPtrBits = aNullParent ? 0 : mParentPtrBits & ~PARENT_BIT_INDOCUMENT;
    1: 
    1:   nsDataSlots *slots = GetExistingDataSlots();
    1:   if (slots) {
    1:     slots->mBindingParent = nsnull;
    1:   }
    1: 
    1:   nsNodeUtils::ParentChainChanged(this);
    1: }
    1: 
38069: already_AddRefed<nsINodeList>
55877: nsGenericDOMDataNode::GetChildren(PRUint32 aFilter)
38069: {
38069:   return nsnull;
38069: }
38069: 
    1: nsIAtom *
 4036: nsGenericDOMDataNode::GetIDAttributeName() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: already_AddRefed<nsINodeInfo>
    1: nsGenericDOMDataNode::GetExistingAttrNameFromQName(const nsAString& aStr) const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttr,
    1:                               nsIAtom* aPrefix, const nsAString& aValue,
    1:                               PRBool aNotify)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttr,
    1:                                 PRBool aNotify)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsGenericDOMDataNode::GetAttr(PRInt32 aNameSpaceID, nsIAtom *aAttr,
    1:                               nsAString& aResult) const
    1: {
    1:   aResult.Truncate();
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsGenericDOMDataNode::HasAttr(PRInt32 aNameSpaceID, nsIAtom *aAttribute) const
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: const nsAttrName*
    1: nsGenericDOMDataNode::GetAttrNameAt(PRUint32 aIndex) const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: PRUint32
    1: nsGenericDOMDataNode::GetAttrCount() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
    1:   return nsGenericElement::doPreHandleEvent(this, aVisitor);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::PostHandleEvent(nsEventChainPostVisitor& /*aVisitor*/)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::DispatchDOMEvent(nsEvent* aEvent,
    1:                                        nsIDOMEvent* aDOMEvent,
    1:                                        nsPresContext* aPresContext,
    1:                                        nsEventStatus* aEventStatus)
    1: {
 3233:   return nsEventDispatcher::DispatchDOMEvent(static_cast<nsINode*>(this),
    1:                                              aEvent, aDOMEvent,
    1:                                              aPresContext, aEventStatus);
    1: }
    1: 
29474: nsIEventListenerManager*
29474: nsGenericDOMDataNode::GetListenerManager(PRBool aCreateIfNotFound)
    1: {
29474:   return nsContentUtils::GetListenerManager(this, aCreateIfNotFound);
    1: }
    1: 
 1418: nsresult
 1418: nsGenericDOMDataNode::AddEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                             const nsIID& aIID)
 1418: {
29474:   nsIEventListenerManager* elm = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(elm);
 1418:   return elm->AddEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE);
 1418: }
 1418: 
 1418: nsresult
 1418: nsGenericDOMDataNode::RemoveEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                                const nsIID& aIID)
 1418: {
29474:   nsIEventListenerManager* elm = GetListenerManager(PR_FALSE);
29474:   return elm ?
29474:     elm->RemoveEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE) :
29474:     NS_OK;
 1418: }
 1418: 
 1418: nsresult
 1418: nsGenericDOMDataNode::GetSystemEventGroup(nsIDOMEventGroup** aGroup)
 1418: {
29474:   nsIEventListenerManager* elm = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(elm);
 1418:   return elm->GetSystemEventGroupLM(aGroup);
 1418: }
 1418: 
    1: PRUint32
    1: nsGenericDOMDataNode::GetChildCount() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: nsIContent *
    1: nsGenericDOMDataNode::GetChildAt(PRUint32 aIndex) const
    1: {
    1:   return nsnull;
    1: }
    1: 
15810: nsIContent * const *
22251: nsGenericDOMDataNode::GetChildArray(PRUint32* aChildCount) const
15810: {
22251:   *aChildCount = 0;
15810:   return nsnull;
15810: }
15810: 
    1: PRInt32
    1: nsGenericDOMDataNode::IndexOf(nsINode* aPossibleChild) const
    1: {
    1:   return -1;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                                     PRBool aNotify)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
29805: nsGenericDOMDataNode::RemoveChildAt(PRUint32 aIndex, PRBool aNotify, PRBool aMutationEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsIContent *
    1: nsGenericDOMDataNode::GetBindingParent() const
    1: {
    1:   nsDataSlots *slots = GetExistingDataSlots();
    1:   return slots ? slots->mBindingParent : nsnull;
    1: }
    1: 
    1: PRBool
    1: nsGenericDOMDataNode::IsNodeOfType(PRUint32 aFlags) const
    1: {
    1:   return !(aFlags & ~(eCONTENT | eDATA_NODE));
    1: }
    1: 
 8462: void
14188: nsGenericDOMDataNode::SaveSubtreeState()
14188: {
14188: }
14188: 
14188: void
 8462: nsGenericDOMDataNode::DestroyContent()
 8462: {
21618:   // XXX We really should let cycle collection do this, but that currently still
21618:   //     leaks (see https://bugzilla.mozilla.org/show_bug.cgi?id=406684).
30001:   nsContentUtils::ReleaseWrapper(this, this);
 8462: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsGenericDOMDataNode::List(FILE* out, PRInt32 aIndent) const
    1: {
    1: }
    1: 
    1: void
    1: nsGenericDOMDataNode::DumpContent(FILE* out, PRInt32 aIndent,
    1:                                   PRBool aDumpAll) const 
    1: {
    1: }
    1: #endif
    1: 
    1: PRBool
    1: nsGenericDOMDataNode::IsLink(nsIURI** aURI) const
    1: {
    1:   *aURI = nsnull;
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsINode::nsSlots*
    1: nsGenericDOMDataNode::CreateSlots()
    1: {
11169:   return new nsDataSlots(mFlagsOrSlots);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Implementation of the nsIDOMText interface
    1: 
    1: nsresult
16205: nsGenericDOMDataNode::SplitData(PRUint32 aOffset, nsIContent** aReturn,
16205:                                 PRBool aCloneAfterOriginal)
    1: {
16205:   *aReturn = nsnull;
    1:   nsresult rv = NS_OK;
    1:   nsAutoString cutText;
    1:   PRUint32 length = TextLength();
    1: 
    1:   if (aOffset > length) {
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1:   }
    1: 
16205:   PRUint32 cutStartOffset = aCloneAfterOriginal ? aOffset : 0;
16205:   PRUint32 cutLength = aCloneAfterOriginal ? length - aOffset : aOffset;
16205:   rv = SubstringData(cutStartOffset, cutLength, cutText);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
16205:   rv = DeleteData(cutStartOffset, cutLength);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   /*
    1:    * Use Clone for creating the new node so that the new node is of same class
    1:    * as this node!
    1:    */
    1: 
    1:   nsCOMPtr<nsIContent> newContent = CloneDataNode(mNodeInfo, PR_FALSE);
    1:   if (!newContent) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   newContent->SetText(cutText, PR_TRUE);
    1: 
16205:   nsCOMPtr<nsINode> parent = GetNodeParent();
    1: 
    1:   if (parent) {
16205:     PRInt32 insertionIndex = parent->IndexOf(this);
16205:     if (aCloneAfterOriginal) {
16205:       ++insertionIndex;
16205:     }
16205:     parent->InsertChildAt(newContent, insertionIndex, PR_TRUE);
    1:   }
    1: 
16205:   newContent.swap(*aReturn);
16205:   return rv;
16205: }
    1: 
16205: nsresult
16205: nsGenericDOMDataNode::SplitText(PRUint32 aOffset, nsIDOMText** aReturn)
16205: {
16205:   nsCOMPtr<nsIContent> newChild;
16205:   nsresult rv = SplitData(aOffset, getter_AddRefs(newChild));
16205:   if (NS_SUCCEEDED(rv)) {
16205:     rv = CallQueryInterface(newChild, aReturn);
16205:   }
16205:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
15250: // Implementation of the nsGenericDOMDataNode nsIDOM3Text tearoff
15250: 
15250: NS_IMPL_CYCLE_COLLECTION_CLASS(nsText3Tearoff)
15250: 
15250: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsText3Tearoff)
15250:   NS_INTERFACE_MAP_ENTRY(nsIDOM3Text)
15250: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
15250: 
15250: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsText3Tearoff)
15250:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mNode)
15250: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
15250: 
15250: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsText3Tearoff)
15250:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mNode, nsIContent)
15250: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
15250: 
15250: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsText3Tearoff)
15250: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsText3Tearoff)
15250: 
15250: NS_IMETHODIMP
15250: nsText3Tearoff::GetIsElementContentWhitespace(PRBool *aReturn)
15250: {
41903:   *aReturn = mNode->IsElementContentWhitespace();
20525:   return NS_OK;
15250: }
15250: 
15250: NS_IMETHODIMP
15250: nsText3Tearoff::GetWholeText(nsAString& aWholeText)
15250: {
15250:   return mNode->GetWholeText(aWholeText);
15250: }
15250: 
15250: NS_IMETHODIMP
15250: nsText3Tearoff::ReplaceWholeText(const nsAString& aContent,
15250:                                  nsIDOMText **aReturn)
15250: {
41903:   nsresult rv;
41903:   nsIContent* result = mNode->ReplaceWholeText(PromiseFlatString(aContent),
41903:                                                &rv);
41903:   return result ? CallQueryInterface(result, aReturn) : rv;
15250: }
15250: 
15250: // Implementation of the nsIDOM3Text interface
15250: 
15899: /* static */ PRInt32
15250: nsGenericDOMDataNode::FirstLogicallyAdjacentTextNode(nsIContent* aParent,
15899:                                                      PRInt32 aIndex)
15250: {
15250:   while (aIndex-- > 0) {
15250:     nsIContent* sibling = aParent->GetChildAt(aIndex);
15250:     if (!sibling->IsNodeOfType(nsINode::eTEXT))
15250:       return aIndex + 1;
15250:   }
15250:   return 0;
15250: }
15250: 
15899: /* static */ PRInt32
15250: nsGenericDOMDataNode::LastLogicallyAdjacentTextNode(nsIContent* aParent,
15899:                                                     PRInt32 aIndex,
15250:                                                     PRUint32 aCount)
15250: {
15899:   while (++aIndex < PRInt32(aCount)) {
15250:     nsIContent* sibling = aParent->GetChildAt(aIndex);
15250:     if (!sibling->IsNodeOfType(nsINode::eTEXT))
15250:       return aIndex - 1;
15250:   }
15250:   return aCount - 1;
15250: }
15250: 
15250: nsresult
41903: nsGenericTextNode::GetWholeText(nsAString& aWholeText)
15250: {
15250:   nsIContent* parent = GetParent();
15250: 
15250:   // Handle parent-less nodes
15250:   if (!parent)
15250:     return GetData(aWholeText);
15250: 
15899:   PRInt32 index = parent->IndexOf(this);
15899:   NS_WARN_IF_FALSE(index >= 0,
15899:                    "Trying to use .wholeText with an anonymous"
15899:                     "text node child of a binding parent?");
15899:   NS_ENSURE_TRUE(index >= 0, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
15899:   PRInt32 first =
15250:     FirstLogicallyAdjacentTextNode(parent, index);
15899:   PRInt32 last =
15250:     LastLogicallyAdjacentTextNode(parent, index, parent->GetChildCount());
15250: 
15250:   aWholeText.Truncate();
15250: 
15250:   nsCOMPtr<nsIDOMText> node;
15250:   nsAutoString tmp;
15250:   do {
15250:     node = do_QueryInterface(parent->GetChildAt(first));
15250:     node->GetData(tmp);
15250:     aWholeText.Append(tmp);
15250:   } while (first++ < last);
15250: 
15250:   return NS_OK;
15250: }
15250: 
41903: nsIContent*
41903: nsGenericTextNode::ReplaceWholeText(const nsAFlatString& aContent,
41903:                                     nsresult* aResult)
15250: {
41903:   *aResult = NS_OK;
41903: 
15250:   // Batch possible DOMSubtreeModified events.
15250:   mozAutoSubtreeModified subtree(GetOwnerDoc(), nsnull);
15250:   mozAutoDocUpdate updateBatch(GetCurrentDoc(), UPDATE_CONTENT_MODEL, PR_TRUE);
15250: 
15250:   nsCOMPtr<nsIContent> parent = GetParent();
15250: 
15250:   // Handle parent-less nodes
15250:   if (!parent) {
15250:     if (aContent.IsEmpty()) {
41903:       return nsnull;
15250:     }
15250: 
15250:     SetText(aContent.get(), aContent.Length(), PR_TRUE);
41903:     return this;
15250:   }
15250: 
15899:   PRInt32 index = parent->IndexOf(this);
41903:   if (index < 0) {
41903:     NS_WARNING("Trying to use .replaceWholeText with an anonymous text node "
41903:                "child of a binding parent?");
41903:     *aResult = NS_ERROR_DOM_NOT_SUPPORTED_ERR;
41903:     return nsnull;
41903:   }
15899: 
15250:   // We don't support entity references or read-only nodes, so remove the
15250:   // logically adjacent text nodes (which therefore must all be siblings of
15250:   // this) and set this one to the provided text, if that text isn't empty.
15899:   PRInt32 first =
15250:     FirstLogicallyAdjacentTextNode(parent, index);
15899:   PRInt32 last =
15250:     LastLogicallyAdjacentTextNode(parent, index, parent->GetChildCount());
15250: 
15250:   do {
15250:     if (last == index && !aContent.IsEmpty())
15250:       continue;
15250: 
15250:     parent->RemoveChildAt(last, PR_TRUE);
15250:   } while (last-- > first);
15250: 
15250:   // Empty string means we removed this node too.
15250:   if (aContent.IsEmpty()) {
41903:     return nsnull;
15250:   }
15250: 
15250:   SetText(aContent.get(), aContent.Length(), PR_TRUE);
41903:   return this;
15250: }
15250: 
15250: //----------------------------------------------------------------------
15250: 
    1: // Implementation of the nsIContent interface text functions
    1: 
    1: const nsTextFragment *
    1: nsGenericDOMDataNode::GetText()
    1: {
    1:   return &mText;
    1: }
    1: 
    1: PRUint32
    1: nsGenericDOMDataNode::TextLength()
    1: {
    1:   return mText.GetLength();
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetText(const PRUnichar* aBuffer,
    1:                               PRUint32 aLength,
    1:                               PRBool aNotify)
    1: {
    1:   return SetTextInternal(0, mText.GetLength(), aBuffer, aLength, aNotify);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::AppendText(const PRUnichar* aBuffer,
    1:                                  PRUint32 aLength,
    1:                                  PRBool aNotify)
    1: {
    1:   return SetTextInternal(mText.GetLength(), 0, aBuffer, aLength, aNotify);
    1: }
    1: 
    1: PRBool
    1: nsGenericDOMDataNode::TextIsOnlyWhitespace()
    1: {
    1:   if (mText.Is2b()) {
    1:     // The fragment contains non-8bit characters and such characters
    1:     // are never considered whitespace.
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   const char* cp = mText.Get1b();
    1:   const char* end = cp + mText.GetLength();
    1: 
    1:   while (cp < end) {
    1:     char ch = *cp;
    1: 
    1:     if (!XP_IS_SPACE(ch)) {
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     ++cp;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsGenericDOMDataNode::AppendTextTo(nsAString& aResult)
    1: {
    1:   mText.AppendTo(aResult);
    1: }
    1: 
53733: void nsGenericDOMDataNode::UpdateBidiStatus(const PRUnichar* aBuffer, PRUint32 aLength)
    1: {
    1:   nsIDocument *document = GetCurrentDoc();
    1:   if (document && document->GetBidiEnabled()) {
    1:     // OK, we already know it's Bidi, so we won't test again
    1:     return;
    1:   }
    1: 
53733:   mText.UpdateBidiFlag(aBuffer, aLength);
    1: 
    1:   if (document && mText.IsBidi()) {
15376:     document->SetBidiEnabled();
    1:   }
    1: }
    1: 
    1: already_AddRefed<nsIAtom>
    1: nsGenericDOMDataNode::GetCurrentValueAtom()
    1: {
    1:   nsAutoString val;
    1:   GetData(val);
    1:   return NS_NewAtom(val);
    1: }
    1: 
    1: nsIAtom*
43079: nsGenericDOMDataNode::DoGetID() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: const nsAttrValue*
19132: nsGenericDOMDataNode::DoGetClasses() const
    1: {
19132:   NS_NOTREACHED("Shouldn't ever be called");
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericDOMDataNode::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
    1: {
    1:   return NS_OK;
    1: }
    1: 
32193: #ifdef MOZ_SMIL
32193: nsresult
32193: nsGenericDOMDataNode::GetSMILOverrideStyle(nsIDOMCSSStyleDeclaration** aStyle)
32193: {
32193:   *aStyle = nsnull;
32193:   return NS_ERROR_NOT_IMPLEMENTED;
32193: }
32193: 
32193: nsICSSStyleRule*
32193: nsGenericDOMDataNode::GetSMILOverrideStyleRule()
32193: {
32193:   return nsnull;
32193: }
32193: 
32193: nsresult
32193: nsGenericDOMDataNode::SetSMILOverrideStyleRule(nsICSSStyleRule* aStyleRule,
32193:                                                PRBool aNotify)
32193: {
32193:   NS_NOTREACHED("How come we're setting SMILOverrideStyle on a non-element?");
32193:   return NS_ERROR_UNEXPECTED;
32193: }
32193: #endif // MOZ_SMIL
32193: 
    1: nsICSSStyleRule*
    1: nsGenericDOMDataNode::GetInlineStyleRule()
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericDOMDataNode::SetInlineStyleRule(nsICSSStyleRule* aStyleRule,
    1:                                          PRBool aNotify)
    1: {
    1:   NS_NOTREACHED("How come we're setting inline style on a non-element?");
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsGenericDOMDataNode::IsAttributeMapped(const nsIAtom* aAttribute) const
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsChangeHint
    1: nsGenericDOMDataNode::GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                              PRInt32 aModType) const
    1: {
    1:   NS_NOTREACHED("Shouldn't be calling this!");
    1:   return nsChangeHint(0);
    1: }
    1: 
    1: nsIAtom*
    1: nsGenericDOMDataNode::GetClassAttributeName() const
    1: {
    1:   return nsnull;
    1: }
