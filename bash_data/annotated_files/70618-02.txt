    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is TransforMiiX XSLT processor code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Jonas Sicking.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Jonas Sicking <jonas@sicking.cc>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef TRANSFRMX_TXEXECUTIONSTATE_H
    1: #define TRANSFRMX_TXEXECUTIONSTATE_H
    1: 
    1: #include "txCore.h"
    1: #include "txStack.h"
    1: #include "txXMLUtils.h"
    1: #include "txIXPathContext.h"
    1: #include "txVariableMap.h"
    1: #include "nsTHashtable.h"
    1: #include "nsHashKeys.h"
    1: #include "txKey.h"
    1: #include "txStylesheet.h"
    1: #include "txXPathTreeWalker.h"
    1: #include "nsTArray.h"
    1: 
    1: class txAOutputHandlerFactory;
    1: class txAXMLEventHandler;
    1: class txInstruction;
    1: class txIOutputHandlerFactory;
    1: 
    1: class txLoadedDocumentEntry : public nsStringHashKey
    1: {
    1: public:
39583:     txLoadedDocumentEntry(KeyTypePointer aStr) : nsStringHashKey(aStr),
39583:                                                  mLoadResult(NS_OK)
    1:     {
    1:     }
    1:     txLoadedDocumentEntry(const txLoadedDocumentEntry& aToCopy)
    1:         : nsStringHashKey(aToCopy)
    1:     {
    1:         NS_ERROR("We're horked.");
    1:     }
    1:     ~txLoadedDocumentEntry()
    1:     {
    1:         if (mDocument) {
    1:             txXPathNodeUtils::release(mDocument);
    1:         }
    1:     }
39583:     PRBool LoadingFailed()
39583:     {
39583:         NS_ASSERTION(NS_SUCCEEDED(mLoadResult) || !mDocument,
39583:                      "Load failed but we still got a document?");
39583: 
39583:         return NS_FAILED(mLoadResult);
39583:     }
    1: 
    1:     nsAutoPtr<txXPathNode> mDocument;
39583:     nsresult mLoadResult;
    1: };
    1: 
    1: class txLoadedDocumentsHash : public nsTHashtable<txLoadedDocumentEntry>
    1: {
    1: public:
    1:     ~txLoadedDocumentsHash();
    1:     nsresult init(txXPathNode* aSourceDocument);
    1: 
    1: private:
    1:     friend class txExecutionState;
    1:     txXPathNode* mSourceDocument;
    1: };
    1: 
    1: 
    1: class txExecutionState : public txIMatchContext
    1: {
    1: public:
    1:     txExecutionState(txStylesheet* aStylesheet, PRBool aDisableLoads);
    1:     ~txExecutionState();
    1:     nsresult init(const txXPathNode& aNode,
    1:                   txOwningExpandedNameMap<txIGlobalParameter>* aGlobalParams);
    1:     nsresult end(nsresult aResult);
    1: 
    1:     TX_DECL_MATCH_CONTEXT;
    1: 
    1:     /**
    1:      * Struct holding information about a current template rule
    1:      */
59163:     class TemplateRule {
59163:     public:
    1:         txStylesheet::ImportFrame* mFrame;
    1:         PRInt32 mModeNsId;
59163:         nsCOMPtr<nsIAtom> mModeLocalName;
    1:         txVariableMap* mParams;
    1:     };
    1: 
    1:     // Stack functions
    1:     nsresult pushEvalContext(txIEvalContext* aContext);
    1:     txIEvalContext* popEvalContext();
    1:     nsresult pushBool(PRBool aBool);
    1:     PRBool popBool();
    1:     nsresult pushResultHandler(txAXMLEventHandler* aHandler);
    1:     txAXMLEventHandler* popResultHandler();
59163:     void pushTemplateRule(txStylesheet::ImportFrame* aFrame,
    1:                           const txExpandedName& aMode,
    1:                           txVariableMap* aParams);
    1:     void popTemplateRule();
    1:     nsresult pushParamMap(txVariableMap* aParams);
    1:     txVariableMap* popParamMap();
    1: 
    1:     // state-getting functions
    1:     txIEvalContext* getEvalContext();
    1:     const txXPathNode* retrieveDocument(const nsAString& aUri);
    1:     nsresult getKeyNodes(const txExpandedName& aKeyName,
    1:                          const txXPathNode& aRoot,
    1:                          const nsAString& aKeyValue, PRBool aIndexIfNotFound,
    1:                          txNodeSet** aResult);
    1:     TemplateRule* getCurrentTemplateRule();
    1:     const txXPathNode& getSourceDocument()
    1:     {
    1:         NS_ASSERTION(mLoadedDocuments.mSourceDocument,
    1:                      "Need a source document!");
    1: 
    1:         return *mLoadedDocuments.mSourceDocument;
    1:     }
    1: 
    1:     // state-modification functions
    1:     txInstruction* getNextInstruction();
    1:     nsresult runTemplate(txInstruction* aInstruction);
    1:     nsresult runTemplate(txInstruction* aInstruction,
    1:                          txInstruction* aReturnTo);
    1:     void gotoInstruction(txInstruction* aNext);
    1:     void returnFromTemplate();
    1:     nsresult bindVariable(const txExpandedName& aName,
    1:                           txAExprResult* aValue);
    1:     void removeVariable(const txExpandedName& aName);
    1: 
    1:     txAXMLEventHandler* mOutputHandler;
    1:     txAXMLEventHandler* mResultHandler;
70618:     nsAutoPtr<txAXMLEventHandler> mObsoleteHandler;
    1:     txAOutputHandlerFactory* mOutputHandlerFactory;
    1: 
    1:     nsAutoPtr<txVariableMap> mTemplateParams;
    1: 
    1:     nsRefPtr<txStylesheet> mStylesheet;
    1: 
    1: private:
    1:     txStack mReturnStack;
    1:     txStack mLocalVarsStack;
    1:     txStack mEvalContextStack;
    1:     nsTArray<PRPackedBool> mBoolStack;
    1:     txStack mResultHandlerStack;
    1:     txStack mParamStack;
    1:     txInstruction* mNextInstruction;
    1:     txVariableMap* mLocalVariables;
    1:     txVariableMap mGlobalVariableValues;
    1:     nsRefPtr<txAExprResult> mGlobalVarPlaceholderValue;
    1:     PRInt32 mRecursionDepth;
    1: 
59163:     AutoInfallibleTArray<TemplateRule, 10> mTemplateRules;
    1: 
    1:     txIEvalContext* mEvalContext;
    1:     txIEvalContext* mInitialEvalContext;
    1:     //Document* mRTFDocument;
    1:     txOwningExpandedNameMap<txIGlobalParameter>* mGlobalParams;
    1: 
    1:     txLoadedDocumentsHash mLoadedDocuments;
    1:     txKeyHash mKeyHash;
    1:     nsRefPtr<txResultRecycler> mRecycler;
    1:     PRPackedBool mDisableLoads;
    1: 
    1:     static const PRInt32 kMaxRecursionDepth;
    1: };
    1: 
    1: #endif
