43425: /* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40; -*- */
41369: /* ***** BEGIN LICENSE BLOCK *****
41369:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
41369:  *
41369:  * The contents of this file are subject to the Mozilla Public License Version
41369:  * 1.1 (the "License"); you may not use this file except in compliance with
41369:  * the License. You may obtain a copy of the License at
41369:  * http://www.mozilla.org/MPL/
41369:  *
41369:  * Software distributed under the License is distributed on an "AS IS" basis,
41369:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
41369:  * for the specific language governing rights and limitations under the
41369:  * License.
41369:  *
41369:  * The Original Code is mozilla.org code.
41369:  *
41369:  * The Initial Developer of the Original Code is
41369:  *   Mozilla Corporation.
41369:  * Portions created by the Initial Developer are Copyright (C) 2010
41369:  * the Initial Developer. All Rights Reserved.
41369:  *
41369:  * Contributor(s):
41369:  *   Vladimir Vukicevic <vladimir@pobox.com>
41369:  *   Mark Steele <mwsteele@gmail.com>
41369:  *   Bas Schouten <bschouten@mozilla.com>
92137:  *   Jeff Gilbert <jgilbert@mozilla.com>
41369:  *
41369:  * Alternatively, the contents of this file may be used under the terms of
41369:  * either the GNU General Public License Version 2 or later (the "GPL"), or
41369:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
41369:  * in which case the provisions of the GPL or the LGPL are applicable instead
41369:  * of those above. If you wish to allow use of your version of this file only
41369:  * under the terms of either the GPL or the LGPL, and not to allow others to
41369:  * use your version of this file under the terms of the MPL, indicate your
41369:  * decision by deleting the provisions above and replace them with the notice
41369:  * and other provisions required by the GPL or the LGPL. If you do not delete
41369:  * the provisions above, a recipient may use your version of this file under
41369:  * the terms of any one of the MPL, the GPL or the LGPL.
41369:  *
41369:  * ***** END LICENSE BLOCK ***** */
41369: 
41369: #ifndef GLCONTEXT_H_
41369: #define GLCONTEXT_H_
41369: 
46975: #include <stdio.h>
68457: #if defined(XP_UNIX)
68457: #include <stdint.h>
68457: #endif
54959: #include <string.h>
54959: #include <ctype.h>
46975: 
41369: #ifdef WIN32
41369: #include <windows.h>
41369: #endif
41369: 
41369: #include "GLDefs.h"
93376: #include "GLLibraryLoader.h"
46976: #include "gfxASurface.h"
57350: #include "gfxImageSurface.h"
46976: #include "gfxContext.h"
43425: #include "gfxRect.h"
41369: #include "nsISupportsImpl.h"
41369: #include "prlink.h"
41369: 
42791: #include "nsDataHashtable.h"
42791: #include "nsHashKeys.h"
46976: #include "nsRegion.h"
47908: #include "nsAutoPtr.h"
55380: #include "nsThreadUtils.h"
41369: 
41369: typedef char realGLboolean;
41369: 
55380: #include "GLContextSymbols.h"
55380: 
95498: #include "mozilla/mozalloc.h"
95498: 
41369: namespace mozilla {
73465:   namespace layers {
73465:     class LayerManagerOGL;
73465:     class ColorTextureLayerProgram;
83364:   }
73465: 
41369: namespace gl {
46976: class GLContext;
46976: 
41369: 
59439: enum ShaderProgramType {
59439:     RGBALayerProgramType,
59439:     BGRALayerProgramType,
59439:     RGBXLayerProgramType,
59439:     BGRXLayerProgramType,
59439:     RGBARectLayerProgramType,
59439:     ColorLayerProgramType,
59439:     YCbCrLayerProgramType,
60740:     ComponentAlphaPass1ProgramType,
60740:     ComponentAlphaPass2ProgramType,
59439:     Copy2DProgramType,
59439:     Copy2DRectProgramType,
59439:     NumProgramTypes
59439: };
59439: 
41369: 
46976: /**
46976:  * A TextureImage encapsulates a surface that can be drawn to by a
46976:  * Thebes gfxContext and (hopefully efficiently!) synchronized to a
46976:  * texture in the server.  TextureImages are associated with one and
46976:  * only one GLContext.
46976:  *
46976:  * Implementation note: TextureImages attempt to unify two categories
46976:  * of backends
46976:  *
46976:  *  (1) proxy to server-side object that can be bound to a texture;
46976:  *      e.g. Pixmap on X11.
46976:  *
46976:  *  (2) efficient manager of texture memory; e.g. by having clients draw
46976:  *      into a scratch buffer which is then uploaded with
46976:  *      glTexSubImage2D().
46976:  */
46976: class TextureImage
46976: {
46976:     NS_INLINE_DECL_REFCOUNTING(TextureImage)
46976: public:
73465:     enum TextureState
73465:     {
73465:       Created, // Texture created, but has not had glTexImage called to initialize it.
73465:       Allocated,  // Texture memory exists, but contents are invalid.
73465:       Valid  // Texture fully ready to use.
73465:     };
73465: 
98144:     enum Flags {
98144:         NoFlags          = 0x0,
98144:         UseNearestFilter = 0x1,
98144:         NeedsYFlip       = 0x2
98144:     };
98144: 
46976:     typedef gfxASurface::gfxContentType ContentType;
46976: 
46976:     virtual ~TextureImage() {}
46976: 
46976:     /**
60739:      * Returns a gfxASurface for updating |aRegion| of the client's
46976:      * image if successul, NULL if not.  |aRegion|'s bounds must fit
46976:      * within Size(); its coordinate space (if any) is ignored.  If
60739:      * the update begins successfully, the returned gfxASurface is
46976:      * owned by this.  Otherwise, NULL is returned.
46976:      *
46976:      * |aRegion| is an inout param: the returned region is what the
46976:      * client must repaint.  Category (1) regions above can
46976:      * efficiently handle repaints to "scattered" regions, while (2)
46976:      * can only efficiently handle repaints to rects.
46976:      *
60739:      * Painting the returned surface outside of |aRegion| results 
60739:      * in undefined behavior.
46976:      *
46976:      * BeginUpdate() calls cannot be "nested", and each successful
46976:      * BeginUpdate() must be followed by exactly one EndUpdate() (see
46976:      * below).  Failure to do so can leave this in a possibly
46976:      * inconsistent state.  Unsuccessful BeginUpdate()s must not be
46976:      * followed by EndUpdate().
46976:      */
60739:     virtual gfxASurface* BeginUpdate(nsIntRegion& aRegion) = 0;
46976:     /**
77141:      * Retrieves the region that will require updating, given a
77141:      * region that needs to be updated. This can be used for
77141:      * making decisions about updating before calling BeginUpdate().
77141:      *
77141:      * |aRegion| is an inout param.
77141:      */
77141:     virtual void GetUpdateRegion(nsIntRegion& aForRegion) {
77141:     };
77141:     /**
46976:      * Finish the active update and synchronize with the server, if
60740:      * necessary.
46976:      *
46976:      * BeginUpdate() must have been called exactly once before
46976:      * EndUpdate().
46976:      */
60740:     virtual void EndUpdate() = 0;
46976: 
46976:     /**
73465:      * The Image may contain several textures for different regions (tiles).
73465:      * These functions iterate over each sub texture image tile.
73465:      */
73465:     virtual void BeginTileIteration() {
73465:     };
73465: 
79445:     virtual bool NextTile() {
80486:         return false;
73465:     };
73465: 
93391:     // Function prototype for a tile iteration callback. Returning false will
93391:     // cause iteration to be interrupted (i.e. the corresponding NextTile call
93391:     // will return false).
93391:     typedef bool (* TileIterationCallback)(TextureImage* aImage,
93391:                                            int aTileNumber,
93391:                                            void* aCallbackData);
93391: 
93391:     // Sets a callback to be called every time NextTile is called.
93391:     virtual void SetIterationCallback(TileIterationCallback aCallback,
93391:                                       void* aCallbackData) {
93391:     };
93391: 
73465:     virtual nsIntRect GetTileRect() {
73465:         return nsIntRect(nsIntPoint(0,0), mSize);
73465:     };
73465: 
73465:     virtual GLuint GetTextureID() = 0;
77132: 
77132:     virtual PRUint32 GetTileCount() {
77132:         return 1;
77132:     };
77132: 
73465:     /**
54505:      * Set this TextureImage's size, and ensure a texture has been
54505:      * allocated.  Must not be called between BeginUpdate and EndUpdate.
54505:      * After a resize, the contents are undefined.
54505:      *
54505:      * If this isn't implemented by a subclass, it will just perform
54505:      * a dummy BeginUpdate/EndUpdate pair.
54505:      */
54505:     virtual void Resize(const nsIntSize& aSize) {
56953:         mSize = aSize;
54505:         nsIntRegion r(nsIntRect(0, 0, aSize.width, aSize.height));
55143:         BeginUpdate(r);
54505:         EndUpdate();
54505:     }
54505: 
73465:     /**
90154:      * Mark this texture as having valid contents. Call this after modifying
90154:      * the texture contents externally.
90154:      */
90154:     virtual void MarkValid() {}
90154: 
90154:     /**
73465:      * aSurf - the source surface to update from
73465:      * aRegion - the region in this image to update
73465:      * aFrom - offset in the source to update from
73465:      */
73465:     virtual bool DirectUpdate(gfxASurface *aSurf, const nsIntRegion& aRegion, const nsIntPoint& aFrom = nsIntPoint(0,0)) = 0;
59443: 
67635:     virtual void BindTexture(GLenum aTextureUnit) = 0;
67635:     virtual void ReleaseTexture() {};
67635: 
79815:     void BindTextureAndApplyFilter(GLenum aTextureUnit) {
79815:         BindTexture(aTextureUnit);
79815:         ApplyFilter();
79815:     }
79815: 
67635:     class ScopedBindTexture
67635:     {
67635:     public:
67635:         ScopedBindTexture(TextureImage *aTexture, GLenum aTextureUnit) :
67635:           mTexture(aTexture)
67635:         {
67635:             if (mTexture) {
67635:                 mTexture->BindTexture(aTextureUnit);
67635:             }
67635:         }
67635: 
67635:         ~ScopedBindTexture()
67635:         {
67635:             if (mTexture) {
67635:                 mTexture->ReleaseTexture();
67635:             }       
67635:         }
67635: 
79815:     protected:
67635:         TextureImage *mTexture;
67635:     };
67635: 
79815:     class ScopedBindTextureAndApplyFilter
79815:         : public ScopedBindTexture
79815:     {
79815:     public:
79815:         ScopedBindTextureAndApplyFilter(TextureImage *aTexture, GLenum aTextureUnit) :
79815:           ScopedBindTexture(aTexture, aTextureUnit)
79815:         {
79815:             if (mTexture) {
79815:                 mTexture->ApplyFilter();
79815:             }
79815:         }
79815:     };
46976: 
59439:     /**
59439:      * Returns the shader program type that should be used to render
59439:      * this texture. Only valid after a matching BeginUpdate/EndUpdate
59439:      * pair have been called.
59439:      */
59439:     virtual ShaderProgramType GetShaderProgramType()
59439:     {
59439:          return mShaderType;
59439:     }
59439: 
46976:     /** Can be called safely at any time. */
48091: 
48091:     /**
48091:      * If this TextureImage has a permanent gfxASurface backing,
48091:      * return it.  Otherwise return NULL.
48091:      */
48091:     virtual already_AddRefed<gfxASurface> GetBackingSurface()
48091:     { return NULL; }
48091: 
46976:     const nsIntSize& GetSize() const { return mSize; }
46976:     ContentType GetContentType() const { return mContentType; }
79445:     virtual bool InUpdate() const = 0;
57421:     GLenum GetWrapMode() const { return mWrapMode; }
46976: 
79815:     void SetFilter(gfxPattern::GraphicsFilter aFilter) { mFilter = aFilter; }
79815: 
80472:     /**
80472:      * Applies this TextureImage's filter, assuming that its texture is
80472:      * the currently bound texture.
80472:      */
80472:     virtual void ApplyFilter() = 0;
80472: 
46976: protected:
54505:     friend class GLContext;
54505: 
46976:     /**
46976:      * After the ctor, the TextureImage is invalid.  Implementations
46976:      * must allocate resources successfully before returning the new
46976:      * TextureImage from GLContext::CreateTextureImage().  That is,
46976:      * clients must not be given partially-constructed TextureImages.
46976:      */
73465:     TextureImage(const nsIntSize& aSize,
57421:                  GLenum aWrapMode, ContentType aContentType,
98144:                  Flags aFlags = NoFlags)
73465:         : mSize(aSize)
57421:         , mWrapMode(aWrapMode)
46976:         , mContentType(aContentType)
94407:         , mFilter(gfxPattern::FILTER_GOOD)
98144:         , mFlags(aFlags)
46976:     {}
46976: 
98144:     virtual nsIntRect GetSrcTileRect() {
98144:         return nsIntRect(nsIntPoint(0,0), mSize);
98144:     };
98144: 
46976:     nsIntSize mSize;
57421:     GLenum mWrapMode;
46976:     ContentType mContentType;
59439:     ShaderProgramType mShaderType;
79815:     gfxPattern::GraphicsFilter mFilter;
98144:     Flags mFlags;
46976: };
46976: 
46977: /**
46977:  * BasicTextureImage is the baseline TextureImage implementation ---
46977:  * it updates its texture by allocating a scratch buffer for the
46977:  * client to draw into, then using glTexSubImage2D() to upload the new
46977:  * pixels.  Platforms must provide the code to create a new surface
46977:  * into which the updated pixels will be drawn, and the code to
46977:  * convert the update surface's pixels into an image on which we can
46977:  * glTexSubImage2D().
46977:  */
46977: class BasicTextureImage
46977:     : public TextureImage
46977: {
46977: public:
59442:     typedef gfxASurface::gfxImageFormat ImageFormat;
46977:     virtual ~BasicTextureImage();
46977: 
46977:     BasicTextureImage(GLuint aTexture,
46977:                       const nsIntSize& aSize,
57421:                       GLenum aWrapMode,
46977:                       ContentType aContentType,
98144:                       GLContext* aContext,
98144:                       TextureImage::Flags aFlags = TextureImage::NoFlags)
98144:         : TextureImage(aSize, aWrapMode, aContentType, aFlags)
73465:         , mTexture(aTexture)
63843:         , mTextureState(Created)
46977:         , mGLContext(aContext)
57351:         , mUpdateOffset(0, 0)
46977:     {}
46977: 
67635:     virtual void BindTexture(GLenum aTextureUnit);
67635: 
60739:     virtual gfxASurface* BeginUpdate(nsIntRegion& aRegion);
77141:     virtual void GetUpdateRegion(nsIntRegion& aForRegion);
60740:     virtual void EndUpdate();
73465:     virtual bool DirectUpdate(gfxASurface* aSurf, const nsIntRegion& aRegion, const nsIntPoint& aFrom = nsIntPoint(0,0));
73465:     virtual GLuint GetTextureID() { return mTexture; };
59442:     // Returns a surface to draw into
46977:     virtual already_AddRefed<gfxASurface>
59442:       GetSurfaceForUpdate(const gfxIntSize& aSize, ImageFormat aFmt);
59442: 
90154:     virtual void MarkValid() { mTextureState = Valid; }
90154: 
59442:     // Call when drawing into the update surface is complete.
59442:     // Returns true if textures should be upload with a relative 
59442:     // offset - See UploadSurfaceToTexture.
59442:     virtual bool FinishedSurfaceUpdate();
59442: 
59442:     // Call after surface data has been uploaded to a texture.
59442:     virtual void FinishedSurfaceUpload();
59442: 
79445:     virtual bool InUpdate() const { return !!mUpdateSurface; }
59442: 
59442:     virtual void Resize(const nsIntSize& aSize);
80472: 
80472:     virtual void ApplyFilter();
59442: protected:
46977: 
73465:     GLuint mTexture;
63843:     TextureState mTextureState;
46977:     GLContext* mGLContext;
60739:     nsRefPtr<gfxASurface> mUpdateSurface;
60728:     nsIntRegion mUpdateRegion;
57351: 
57351:     // The offset into the update surface at which the update rect is located.
57351:     nsIntPoint mUpdateOffset;
46977: };
46977: 
73465: /**
73465:  * A container class that complements many sub TextureImages into a big TextureImage.
73465:  * Aims to behave just like the real thing.
73465:  */
73465: 
73465: class TiledTextureImage
73465:     : public TextureImage
73465: {
73465: public:
73465:     TiledTextureImage(GLContext* aGL, nsIntSize aSize,
98144:         TextureImage::ContentType, TextureImage::Flags aFlags = TextureImage::NoFlags);
73465:     ~TiledTextureImage();
73465:     void DumpDiv();
73465:     virtual gfxASurface* BeginUpdate(nsIntRegion& aRegion);
77141:     virtual void GetUpdateRegion(nsIntRegion& aForRegion);
73465:     virtual void EndUpdate();
73465:     virtual void Resize(const nsIntSize& aSize);
77132:     virtual PRUint32 GetTileCount();
73465:     virtual void BeginTileIteration();
79445:     virtual bool NextTile();
93391:     virtual void SetIterationCallback(TileIterationCallback aCallback,
93391:                                       void* aCallbackData);
73465:     virtual nsIntRect GetTileRect();
73465:     virtual GLuint GetTextureID() {
73465:         return mImages[mCurrentImage]->GetTextureID();
73465:     };
73465:     virtual bool DirectUpdate(gfxASurface* aSurf, const nsIntRegion& aRegion, const nsIntPoint& aFrom = nsIntPoint(0,0));
79445:     virtual bool InUpdate() const { return mInUpdate; };
73465:     virtual void BindTexture(GLenum);
80472:     virtual void ApplyFilter();
98144: 
73465: protected:
98144:     virtual nsIntRect GetSrcTileRect();
98144: 
73465:     unsigned int mCurrentImage;
93391:     TileIterationCallback mIterationCallback;
93391:     void* mIterationCallbackData;
73465:     nsTArray< nsRefPtr<TextureImage> > mImages;
73465:     bool mInUpdate;
73465:     nsIntSize mSize;
73465:     unsigned int mTileSize;
73465:     unsigned int mRows, mColumns;
73465:     GLContext* mGL;
73465:     // A temporary surface to faciliate cross-tile updates.
73465:     nsRefPtr<gfxASurface> mUpdateSurface;
73465:     // The region of update requested
73465:     nsIntRegion mUpdateRegion;
73465:     TextureState mTextureState;
73465: };
73465: 
55380: struct THEBES_API ContextFormat
55380: {
47908:     static const ContextFormat BasicRGBA32Format;
47908: 
47908:     enum StandardContextFormat {
47908:         Empty,
47908:         BasicRGBA32,
47908:         StrictBasicRGBA32,
47908:         BasicRGB24,
47908:         StrictBasicRGB24,
47908:         BasicRGB16_565,
47908:         StrictBasicRGB16_565
47908:     };
47908: 
47908:     ContextFormat() {
80615:         memset(this, 0, sizeof(ContextFormat));
47908:     }
47908: 
47908:     ContextFormat(const StandardContextFormat cf) {
80615:         memset(this, 0, sizeof(ContextFormat));
47908:         switch (cf) {
47908:         case BasicRGBA32:
47908:             red = green = blue = alpha = 8;
47908:             minRed = minGreen = minBlue = minAlpha = 1;
47908:             break;
47908: 
47908:         case StrictBasicRGBA32:
47908:             red = green = blue = alpha = 8;
47908:             minRed = minGreen = minBlue = minAlpha = 8;
47908:             break;
47908: 
47908:         case BasicRGB24:
47908:             red = green = blue = 8;
47908:             minRed = minGreen = minBlue = 1;
47908:             break;
47908: 
47908:         case StrictBasicRGB24:
47908:             red = green = blue = 8;
47908:             minRed = minGreen = minBlue = 8;
47908:             break;
47908: 
47908:         case StrictBasicRGB16_565:
47908:             red = minRed = 5;
47908:             green = minGreen = 6;
47908:             blue = minBlue = 5;
47908:             break;
47908: 
47908:         default:
47908:             break;
47908:         }
47908:     }
47908: 
47908:     int depth, minDepth;
47908:     int stencil, minStencil;
47908:     int red, minRed;
47908:     int green, minGreen;
47908:     int blue, minBlue;
47908:     int alpha, minAlpha;
80615:     int samples;
47908: 
47908:     int colorBits() const { return red + green + blue; }
47908: };
47908: 
55286: class GLContext
93376:     : public GLLibraryLoader
41369: {
84622:     NS_INLINE_DECL_THREADSAFE_REFCOUNTING(GLContext)
41369: public:
47908:     GLContext(const ContextFormat& aFormat,
79445:               bool aIsOffscreen = false,
47908:               GLContext *aSharedContext = nsnull)
84817:       : mFlushGuaranteesResolve(false),
90331:         mUserBoundDrawFBO(0),
90331:         mUserBoundReadFBO(0),
90331:         mInternalBoundDrawFBO(0),
90331:         mInternalBoundReadFBO(0),
92137: #ifdef DEBUG
92137:         mInInternalBindingMode_DrawFBO(true),
92137:         mInInternalBindingMode_ReadFBO(true),
92137: #endif
84817:         mOffscreenFBOsDirty(false),
80900:         mInitialized(false),
48309:         mIsOffscreen(aIsOffscreen),
80486:         mIsGLES2(false),
80486:         mIsGlobalSharedContext(false),
82479:         mHasRobustness(false),
83211:         mContextLost(false),
54959:         mVendor(-1),
89416:         mRenderer(-1),
47908:         mCreationFormat(aFormat),
47908:         mSharedContext(aSharedContext),
47908:         mOffscreenTexture(0),
80486:         mFlipped(false),
54505:         mBlitProgram(0),
54505:         mBlitFramebuffer(0),
80614:         mOffscreenDrawFBO(0),
80614:         mOffscreenReadFBO(0),
80617:         mOffscreenColorRB(0),
47908:         mOffscreenDepthRB(0),
94059:         mOffscreenStencilRB(0),
94059:         mMaxTextureSize(0),
94059:         mMaxCubeMapTextureSize(0),
94059:         mMaxTextureImageSize(0),
95058:         mMaxRenderbufferSize(0),
95058:         mWorkAroundDriverBugs(true)
55380: #ifdef DEBUG
55380:         , mGLError(LOCAL_GL_NO_ERROR)
55380: #endif
42791:     {
42791:         mUserData.Init();
95097:         mOwningThread = NS_GetCurrentThread();
42791:     }
41369: 
47908:     virtual ~GLContext() {
98361:         NS_ASSERTION(IsDestroyed(), "GLContext implementation must call MarkDestroyed in destructor!");
47908: #ifdef DEBUG
47908:         if (mSharedContext) {
47908:             GLContext *tip = mSharedContext;
47908:             while (tip->mSharedContext)
47908:                 tip = tip->mSharedContext;
47908:             tip->SharedContextDestroyed(this);
47908:             tip->ReportOutstandingNames();
47908:         }
47908: #endif
47908:     }
41369: 
93720:     enum ContextFlags {
93720:         ContextFlagsNone = 0x0,
93720:         ContextFlagsGlobal = 0x1
93720:     };
93720: 
47908:     enum GLContextType {
47908:         ContextTypeUnknown,
47908:         ContextTypeWGL,
47908:         ContextTypeCGL,
47908:         ContextTypeGLX,
47908:         ContextTypeEGL,
47908:         ContextTypeOSMesa
47908:     };
47908: 
47908:     virtual GLContextType GetContextType() { return ContextTypeUnknown; }
55380: 
98361:     virtual bool MakeCurrentImpl(bool aForce = false) = 0;
98361: 
98006: #ifdef DEBUG
98361:     static void StaticInit() {
98361:         PR_NewThreadPrivateIndex(&sCurrentGLContextTLS, NULL);
98006:     }
98006: #endif
98006: 
98003:     bool MakeCurrent(bool aForce = false) {
98361: #ifdef DEBUG
98361:         PR_SetThreadPrivate(sCurrentGLContextTLS, this);
98361: #endif
98361:         return MakeCurrentImpl(aForce);
55380:     }
55380: 
83211:     bool IsContextLost() { return mContextLost; }
83211: 
79445:     virtual bool SetupLookupFunction() = 0;
41369: 
46205:     virtual void WindowDestroyed() {}
46205: 
77086:     virtual void ReleaseSurface() {}
77086: 
42791:     void *GetUserData(void *aKey) {
42791:         void *result = nsnull;
42791:         mUserData.Get(aKey, &result);
42791:         return result;
42791:     }
42791: 
42791:     void SetUserData(void *aKey, void *aValue) {
42791:         mUserData.Put(aKey, aValue);
42791:     }
42791: 
49071:     // Mark this context as destroyed.  This will NULL out all
49071:     // the GL function pointers!
49137:     void THEBES_API MarkDestroyed();
49071: 
79445:     bool IsDestroyed() {
53690:         // MarkDestroyed will mark all these as null.
55380:         return mSymbols.fUseProgram == nsnull;
53690:     }
53690: 
42402:     enum NativeDataType {
42402:       NativeGLContext,
42474:       NativeImageSurface,
47908:       NativeThebesSurface,
42402:       NativeDataTypeMax
42402:     };
42402: 
42402:     virtual void *GetNativeData(NativeDataType aType) { return NULL; }
47908:     GLContext *GetSharedContext() { return mSharedContext; }
43425: 
79445:     bool IsGlobalSharedContext() { return mIsGlobalSharedContext; }
79445:     void SetIsGlobalSharedContext(bool aIsOne) { mIsGlobalSharedContext = aIsOne; }
49071: 
95097:     /**
95097:      * Returns true if the thread on which this context was created is the currently
95097:      * executing thread.
95097:      */
95097:     bool IsOwningThreadCurrent() { return NS_GetCurrentThread() == mOwningThread; }
95097: 
95097:     void DispatchToOwningThread(nsIRunnable *event) {
95097:         // Before dispatching, we need to ensure we're not in the middle of
95097:         // shutting down. Dispatching runnables in the middle of shutdown
95097:         // (that is, when the main thread is no longer get-able) can cause them
95097:         // to leak. See Bug 741319, and Bug 744115.
95097:         nsCOMPtr<nsIThread> mainThread;
95097:         if (NS_SUCCEEDED(NS_GetMainThread(getter_AddRefs(mainThread)))) {
95097:             mOwningThread->Dispatch(event, NS_DISPATCH_NORMAL);
95097:         }
95097:     }
95097: 
47908:     const ContextFormat& CreationFormat() { return mCreationFormat; }
47908:     const ContextFormat& ActualFormat() { return mActualFormat; }
47908: 
47908:     /**
60089:      * If this GL context has a D3D texture share handle, returns non-null.
60089:      */
60089:     virtual void *GetD3DShareHandle() { return nsnull; }
60089: 
60089:     /**
47908:      * If this context is double-buffered, returns TRUE.
43425:      */
79445:     virtual bool IsDoubleBuffered() { return false; }
43425: 
44139:     /**
48309:      * If this context is the GLES2 API, returns TRUE.
48309:      * This means that various GLES2 restrictions might be in effect (modulo
48309:      * extensions).
48309:      */
79445:     bool IsGLES2() const {
48309:         return mIsGLES2;
48309:     }
48309:     
62529:     /**
80486:      * Returns true if either this is the GLES2 API, or had the GL_ARB_ES2_compatibility extension
62529:      */
79445:     bool HasES2Compatibility() {
62529:         return mIsGLES2 || IsExtensionSupported(ARB_ES2_compatibility);
62529:     }
62529: 
82479:     /**
84592:      * Returns true if the context is using ANGLE. This should only be overridden for an ANGLE
84592:      * implementation.
84592:      */
84592:     virtual bool IsANGLE() {
84592:         return false;
84592:     }
84592: 
84592:     /**
82479:      * The derived class is expected to provide information on whether or not it
82479:      * supports robustness.
82479:      */
82479:     virtual bool SupportsRobustness() = 0;
82479: 
57418:     enum {
57418:         VendorIntel,
57418:         VendorNVIDIA,
57418:         VendorATI,
57418:         VendorQualcomm,
92901:         VendorImagination,
57418:         VendorOther
57418:     };
54959: 
89416:     enum {
89416:         RendererAdreno200,
92920:         RendererAdreno205,
93707:         RendererSGX530,
92901:         RendererSGX540,
89416:         RendererOther
89416:     };
89416: 
57418:     int Vendor() const {
54959:         return mVendor;
54959:     }
54959: 
89416:     int Renderer() const {
89416:         return mRenderer;
89416:     }
89416: 
89416:     bool CanUploadSubTextures();
92920:     bool CanUploadNonPowerOfTwo();
92901:     bool WantsSmallTiles();
97184:     virtual bool HasLockSurface() { return false; }
89416: 
48309:     /**
44139:      * If this context wraps a double-buffered target, swap the back
44139:      * and front buffers.  It should be assumed that after a swap, the
44139:      * contents of the new back buffer are undefined.
44139:      */
79445:     virtual bool SwapBuffers() { return false; }
44139: 
44173:     /**
44173:      * Defines a two-dimensional texture image for context target surface
44173:      */
79445:     virtual bool BindTexImage() { return false; }
44173:     /*
44173:      * Releases a color buffer that is being used as a texture
44173:      */
79445:     virtual bool ReleaseTexImage() { return false; }
46205: 
79815:     /**
79815:      * Applies aFilter to the texture currently bound to GL_TEXTURE_2D.
79815:      */
79815:     void ApplyFilterToBoundTexture(gfxPattern::GraphicsFilter aFilter);
79815: 
79815: 
47908:     /*
47908:      * Offscreen support API
47908:      */
47908: 
47908:     /*
47908:      * Bind aOffscreen's color buffer as a texture to the TEXTURE_2D
47908:      * target.  Returns TRUE on success, otherwise FALSE.  If
47908:      * aOffscreen is not an offscreen context, returns FALSE.  If
47908:      * BindOffscreenNeedsTexture() returns TRUE, then you should have
47908:      * a 2D texture name bound whose image will be replaced by the
47908:      * contents of the offscreen context.  If it returns FALSE,
47908:      * the current 2D texture binding will be replaced.
47908:      *
47908:      * After a successul call to BindTex2DOffscreen, UnbindTex2DOffscreen
47908:      * *must* be called once rendering is complete.
47908:      *
47908:      * The same texture unit must be active for Bind/Unbind of a given
47908:      * context.
47908:      */
79445:     virtual bool BindOffscreenNeedsTexture(GLContext *aOffscreen) {
47908:         return aOffscreen->mOffscreenTexture == 0;
47908:     }
47908: 
79445:     virtual bool BindTex2DOffscreen(GLContext *aOffscreen) {
47908:         if (aOffscreen->GetContextType() != GetContextType()) {
80486:           return false;
47908:         }
47908: 
47908:         if (!aOffscreen->mSharedContext ||
47908:             aOffscreen->mSharedContext != mSharedContext)
47908:         {
80486:             return false;
47908:         }
47908: 
85066:         if (!aOffscreen->mOffscreenTexture) {
85066:             return false;
85066:         }
85066: 
47908:         fBindTexture(LOCAL_GL_TEXTURE_2D, aOffscreen->mOffscreenTexture);
47908: 
80486:         return true;
47908:     }
47908: 
47908:     virtual void UnbindTex2DOffscreen(GLContext *aOffscreen) { }
47908: 
79445:     bool IsOffscreen() {
47908:         return mIsOffscreen;
47908:     }
47908: 
89744: private:
84817:     bool mFlushGuaranteesResolve;
84817: 
84817: public:
84817:     void SetFlushGuaranteesResolve(bool aFlushGuaranteesResolve) {
84817:         mFlushGuaranteesResolve = aFlushGuaranteesResolve;
84817:     }
84817:     
85066:     // Before reads from offscreen texture
84817:     void GuaranteeResolve() {
84817:         if (mFlushGuaranteesResolve) {
84817:             BlitDirtyFBOs();
84817:             fFlush();
84817:         } else {
84817:             fFinish();
84817:         }
84817:     }
84817: 
47908:     /*
47908:      * Resize the current offscreen buffer.  Returns true on success.
47908:      * If it returns false, the context should be treated as unusable
47908:      * and should be recreated.  After the resize, the viewport is not
47908:      * changed; glViewport should be called as appropriate.
54505:      *
54505:      * Only valid if IsOffscreen() returns true.
47908:      */
79445:     virtual bool ResizeOffscreen(const gfxIntSize& aNewSize) {
80614:         if (mOffscreenDrawFBO || mOffscreenReadFBO)
96935:             return ResizeOffscreenFBOs(aNewSize, mOffscreenReadFBO != 0);
80486:         return false;
47908:     }
47908: 
47908:     /*
47908:      * Return size of this offscreen context.
54505:      *
54505:      * Only valid if IsOffscreen() returns true.
47908:      */
47908:     gfxIntSize OffscreenSize() {
47908:         return mOffscreenSize;
47908:     }
47908: 
47908:     /*
47908:      * In some cases, we have to allocate a bigger offscreen buffer
47908:      * than what's requested.  This is the bigger size.
54505:      *
54505:      * Only valid if IsOffscreen() returns true.
47908:      */
47908:     gfxIntSize OffscreenActualSize() {
47908:         return mOffscreenActualSize;
47908:     }
47908: 
47908:     /*
47908:      * If this context is FBO-backed, return the FBO or the color
47908:      * buffer texture.  If the context is not FBO-backed, 0 is
47908:      * returned (which is also a valid FBO binding).
54505:      *
54505:      * Only valid if IsOffscreen() returns true.
47908:      */
47908:     GLuint GetOffscreenFBO() {
80614:         // 0 is interpreted as (off)screen, whether for read or draw operations
80614:         return 0;
47908:     }
80614: 
47908:     GLuint GetOffscreenTexture() {
47908:         return mOffscreenTexture;
47908:     }
47908: 
80616:     virtual bool SupportsFramebufferMultisample() {
80616:         return IsExtensionSupported(EXT_framebuffer_multisample) || IsExtensionSupported(ANGLE_framebuffer_multisample);
80616:     }
80616: 
80614:     virtual bool SupportsOffscreenSplit() {
80614:         return IsExtensionSupported(EXT_framebuffer_blit) || IsExtensionSupported(ANGLE_framebuffer_blit);
80614:     }
80614: 
89744: 
89744: 
89744: private:
90331:     GLuint mUserBoundDrawFBO;
90331:     GLuint mUserBoundReadFBO;
90331:     GLuint mInternalBoundDrawFBO;
90331:     GLuint mInternalBoundReadFBO;
89744: 
89744: public:
89744:     void fBindFramebuffer(GLenum target, GLuint framebuffer) {
89744:         switch (target) {
90331:           case LOCAL_GL_DRAW_FRAMEBUFFER_EXT:
90331:             mUserBoundDrawFBO = framebuffer;
90331: 
90331:             if (framebuffer == 0) {
90331:                 mInternalBoundDrawFBO = mOffscreenDrawFBO;
90331:             } else {
90331:                 mInternalBoundDrawFBO = mUserBoundDrawFBO;
90331:             }
90331: 
90331:             raw_fBindFramebuffer(LOCAL_GL_DRAW_FRAMEBUFFER_EXT,
90331:                                  mInternalBoundDrawFBO);
90331:             break;
90331: 
90331:           case LOCAL_GL_READ_FRAMEBUFFER_EXT:
90331:             mUserBoundReadFBO = framebuffer;
90331: 
90331:             if (framebuffer == 0) {
90331:                 mInternalBoundReadFBO = mOffscreenReadFBO;
90331:             } else {
90331:                 mInternalBoundReadFBO = mUserBoundReadFBO;
90331:             }
90331: 
90331:             raw_fBindFramebuffer(LOCAL_GL_READ_FRAMEBUFFER_EXT,
90331:                                  mInternalBoundReadFBO);
90331:             break;
90331: 
89744:           case LOCAL_GL_FRAMEBUFFER:
90331:             mUserBoundDrawFBO = mUserBoundReadFBO = framebuffer;
90331: 
90331:             if (framebuffer == 0) {
90331:                 mInternalBoundDrawFBO = mOffscreenDrawFBO;
90331:                 mInternalBoundReadFBO = mOffscreenReadFBO;
90331:             } else {
90331:                 mInternalBoundDrawFBO = mUserBoundDrawFBO;
90331:                 mInternalBoundReadFBO = mUserBoundReadFBO;
90331:             }
90331: 
90331:             if (SupportsOffscreenSplit()) {
90331:                 raw_fBindFramebuffer(LOCAL_GL_DRAW_FRAMEBUFFER_EXT,
90331:                                      mInternalBoundDrawFBO);
90331:                 raw_fBindFramebuffer(LOCAL_GL_READ_FRAMEBUFFER_EXT,
90331:                                      mInternalBoundReadFBO);
90331:             } else {
90331:                 raw_fBindFramebuffer(LOCAL_GL_FRAMEBUFFER,
90331:                                      mInternalBoundDrawFBO);
90331:             }
90331: 
89744:             break;
90331: 
90331:           default:
90331:             raw_fBindFramebuffer(target, framebuffer);
89744:             break;
89744:         }
89744:     }
89744: 
92137: #ifdef DEBUG
92137:     // See comment near BindInternalDrawFBO()
92137:     bool mInInternalBindingMode_DrawFBO;
92137:     bool mInInternalBindingMode_ReadFBO;
92137: #endif
92137: 
92137:     GLuint GetUserBoundDrawFBO() {
89744: #ifdef DEBUG
89743:         GLint ret = 0;
89744:         // Don't need a branch here, because:
89744:         // LOCAL_GL_DRAW_FRAMEBUFFER_BINDING_EXT == LOCAL_GL_FRAMEBUFFER_BINDING == 0x8CA6
90331:         // We use raw_ here because this is debug code and we need to see what
90331:         // the driver thinks.
90331:         raw_fGetIntegerv(LOCAL_GL_DRAW_FRAMEBUFFER_BINDING_EXT, &ret);
90331: 
92137:         bool abort = false;
92137: 
92137:         if (mInInternalBindingMode_DrawFBO) {
92137:             NS_ERROR("Draw FBO still bound internally!");
92137:             printf_stderr("Current internal draw FBO: %d, user: %d)\n", ret, mUserBoundDrawFBO);
92137:             abort = true;
92137:         }
92137: 
90331:         if (mInternalBoundDrawFBO != (GLuint)ret) {
92137:             NS_ERROR("Draw FBO binding misprediction!");
92137:             printf_stderr("Bound draw FBO was: %d, Expected: %d\n", ret, mInternalBoundDrawFBO);
92137:             abort = true;
92137:         }
92137: 
92137:         if (abort)
89744:             NS_ABORT();
89744: #endif
89744: 
90331:         // We only ever expose the user's bound FBOs
90331:         return mUserBoundDrawFBO;
89744:     }
80614: 
92137:     GLuint GetUserBoundReadFBO() {
89744: #ifdef DEBUG
80614:         GLint ret = 0;
90331:         // We use raw_ here because this is debug code and we need to see what
90331:         // the driver thinks.
80614:         if (SupportsOffscreenSplit())
90331:             raw_fGetIntegerv(LOCAL_GL_READ_FRAMEBUFFER_BINDING_EXT, &ret);
80614:         else
90331:             raw_fGetIntegerv(LOCAL_GL_FRAMEBUFFER_BINDING, &ret);
90331: 
92137:         bool abort = false;
92137: 
92137:         if (mInInternalBindingMode_ReadFBO) {
92137:             NS_ERROR("Read FBO still bound internally!");
92137:             printf_stderr("Current internal read FBO: %d, user: %d)\n", ret, mUserBoundReadFBO);
92137:             abort = true;
92137:         }
92137: 
90331:         if (mInternalBoundReadFBO != (GLuint)ret) {
92137:             NS_ERROR("Read FBO binding misprediction!");
92137:             printf_stderr("Bound read FBO was: %d, Expected: %d\n", ret, mInternalBoundReadFBO);
92137:             abort = true;
92137:         }
92137: 
92137:         if (abort)
89744:             NS_ABORT();
89744: #endif
89744: 
90331:         // We only ever expose the user's bound FBOs
90331:         return mUserBoundReadFBO;
80614:     }
80614: 
92137:     void BindUserDrawFBO(GLuint name) {
80614:         if (SupportsOffscreenSplit())
80614:             fBindFramebuffer(LOCAL_GL_DRAW_FRAMEBUFFER_EXT, name);
80614:         else
80614:             fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, name);
92137: #ifdef DEBUG
92137:         mInInternalBindingMode_DrawFBO = false;
92137: #endif
80614:     }
80614: 
92137:     void BindUserReadFBO(GLuint name) {
80614:         if (SupportsOffscreenSplit())
80614:             fBindFramebuffer(LOCAL_GL_READ_FRAMEBUFFER_EXT, name);
80614:         else
80614:             fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, name);
92137: #ifdef DEBUG
92137:         mInInternalBindingMode_ReadFBO = false;
92137: #endif
80614:     }
80614: 
92137:     // BindInternalDraw/ReadFBO() switch us over into 'internal binding mode'
92137:     //   for the corresponding Draw or Read binding.
92137:     // To exit internal binding mode, use BindUserDraw/ReadFBO().
92137:     // While in internal binding mode for Draw/Read, the corresponding
92137:     //   GetBoundUserDraw/ReadFBO() is undefined, and will trigger ABORT in DEBUG builds.
92137:     void BindInternalDrawFBO(GLuint name) {
92137: #ifdef DEBUG
92137:       mInInternalBindingMode_DrawFBO = true;
92137: #endif
92137:         if (SupportsOffscreenSplit())
92137:             raw_fBindFramebuffer(LOCAL_GL_DRAW_FRAMEBUFFER_EXT, name);
92137:         else
92137:             raw_fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, name);
92137: 
92137:         mInternalBoundDrawFBO = name;
92137:     }
92137: 
92137:     void BindInternalReadFBO(GLuint name) {
92137: #ifdef DEBUG
92137:       mInInternalBindingMode_ReadFBO = true;
92137: #endif
92137:         if (SupportsOffscreenSplit())
92137:             raw_fBindFramebuffer(LOCAL_GL_READ_FRAMEBUFFER_EXT, name);
92137:         else
92137:             raw_fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, name);
92137: 
92137:         mInternalBoundReadFBO = name;
92137:     }
92137: 
92137:     void BindInternalFBO(GLuint name) {
92137:         BindInternalDrawFBO(name);
92137:         BindInternalReadFBO(name);
92137:     }
92137: 
92137:     void InitFramebuffers() {
92137:         MakeCurrent();
92137:         BindUserDrawFBO(0);
92137:         BindUserReadFBO(0);
92137:     }
92137: 
92137:     GLuint SwapUserDrawFBO(GLuint name) {
92137:         GLuint prev = GetUserBoundDrawFBO();
92137:         BindUserDrawFBO(name);
80614:         return prev;
80614:     }
80614: 
92137:     GLuint SwapUserReadFBO(GLuint name) {
92137:         GLuint prev = GetUserBoundReadFBO();
92137:         BindUserReadFBO(name);
80614:         return prev;
80614:     }
80614: 
80614: private:
80614:     bool mOffscreenFBOsDirty;
80614: 
84804:     void GetShaderPrecisionFormatNonES2(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision) {
84804:         switch (precisiontype) {
84804:             case LOCAL_GL_LOW_FLOAT:
84804:             case LOCAL_GL_MEDIUM_FLOAT:
84804:             case LOCAL_GL_HIGH_FLOAT:
84804:                 // Assume IEEE 754 precision
84804:                 range[0] = 127;
84804:                 range[1] = 127;
84804:                 *precision = 0;
84804:                 break;
84804:             case LOCAL_GL_LOW_INT:
84804:             case LOCAL_GL_MEDIUM_INT:
84804:             case LOCAL_GL_HIGH_INT:
84804:                 // Some (most) hardware only supports single-precision floating-point numbers,
84804:                 // which can accurately represent integers up to +/-16777216
84804:                 range[0] = 24;
84804:                 range[1] = 24;
84804:                 *precision = 0;
84804:                 break;
84804:         }
84804:     }
84804: 
90331:     // Do whatever setup is necessary to draw to our offscreen FBO, if it's
90331:     // bound.
80614:     void BeforeGLDrawCall() {
90331:         if (mInternalBoundDrawFBO != mOffscreenDrawFBO)
80614:             return;
80614: 
80614:         if (mOffscreenDrawFBO == mOffscreenReadFBO)
80614:             return;
80614: 
80614:         mOffscreenFBOsDirty = true;
80614:     }
80614: 
90331:     // Do whatever tear-down is necessary after drawing to our offscreen FBO,
90331:     // if it's bound.
80614:     void AfterGLDrawCall() {
80614:     }
90331: 
90331:     // Do whatever setup is necessary to read from our offscreen FBO, if it's
90331:     // bound.
80614:     void BeforeGLReadCall() {
90331:         if (mInternalBoundReadFBO != mOffscreenReadFBO)
80614:             return;
80614: 
80614:         if (mOffscreenDrawFBO == mOffscreenReadFBO)
80614:             return;
80614: 
80614:         // If we're not dirty, there's no need to blit
80614:         if (!mOffscreenFBOsDirty)
80614:             return;
80614: 
80614:         const bool scissor = fIsEnabled(LOCAL_GL_SCISSOR_TEST);
80614:         if (scissor)
80614:             fDisable(LOCAL_GL_SCISSOR_TEST);
80614: 
92137:         // Store current bindings for restoring later
92137:         GLuint prevDraw = GetUserBoundDrawFBO();
92137:         GLuint prevRead = GetUserBoundReadFBO();
92137: 
92137:         NS_ABORT_IF_FALSE(SupportsOffscreenSplit(), "Doesn't support offscreen split?");
92137: 
92137:         // Manually setting internal bindings, entering internal mode
92137:         // Flip read/draw for blitting
92137:         BindInternalDrawFBO(mOffscreenReadFBO);
92137:         BindInternalReadFBO(mOffscreenDrawFBO);
80614: 
80614:         GLint width = mOffscreenActualSize.width;
80614:         GLint height = mOffscreenActualSize.height;
80614:         raw_fBlitFramebuffer(0, 0, width, height,
80614:                              0, 0, width, height,
80614:                              LOCAL_GL_COLOR_BUFFER_BIT,
80614:                              LOCAL_GL_NEAREST);
80614: 
92137:         // Reset to emulated user binding, exiting internal mode
92137:         BindUserDrawFBO(prevDraw);
92137:         BindUserReadFBO(prevRead);
80614: 
80614:         if (scissor)
80614:             fEnable(LOCAL_GL_SCISSOR_TEST);
80614: 
80614:         mOffscreenFBOsDirty = false;
80614:     }
80614: 
90331:     // Do whatever tear-down is necessary after reading from our offscreen FBO,
90331:     // if it's bound.
80614:     void AfterGLReadCall() {
80614:     }
80614: 
80614: public:
80614:     // Draw call hooks:
80614:     void fClear(GLbitfield mask) {
80614:         BeforeGLDrawCall();
80614:         raw_fClear(mask);
80614:         AfterGLDrawCall();
80614:     }
80614: 
80614:     void fDrawArrays(GLenum mode, GLint first, GLsizei count) {
80614:         BeforeGLDrawCall();
80614:         raw_fDrawArrays(mode, first, count);
80614:         AfterGLDrawCall();
80614:     }
80614: 
80614:     void fDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) {
80614:         BeforeGLDrawCall();
80614:         raw_fDrawElements(mode, count, type, indices);
80614:         AfterGLDrawCall();
80614:     }
80614: 
80614:     // Read call hooks:
80614:     void fReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {
80614:         BeforeGLReadCall();
80614:         raw_fReadPixels(x, y, width, height, format, type, pixels);
80614:         AfterGLReadCall();
80614:     }
80614: 
80614:     void fCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
80614:         BeforeGLReadCall();
80614:         raw_fCopyTexImage2D(target, level, internalformat,
80614:                             x, y, width, height, border);
80614:         AfterGLReadCall();
80614:     }
80614: 
80614:     void fCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
80614:         BeforeGLReadCall();
80614:         raw_fCopyTexSubImage2D(target, level, xoffset, yoffset,
80614:                                x, y, width, height);
80614:         AfterGLReadCall();
80614:     }
80614: 
80614:     void ForceDirtyFBOs() {
92137:         GLuint draw = SwapUserDrawFBO(0);
80614: 
80614:         BeforeGLDrawCall();
80614:         // no-op; just pretend we did something
80614:         AfterGLDrawCall();
80614: 
92137:         BindUserDrawFBO(draw);
80614:     }
80614: 
80614:     void BlitDirtyFBOs() {
92137:         GLuint read = SwapUserReadFBO(0);
80614: 
80614:         BeforeGLReadCall();
80614:         // no-op; we just want to make sure the Read FBO is updated if it needs to be
80614:         AfterGLReadCall();
80614: 
92137:         BindUserReadFBO(read);
80614:     }
80614: 
80614:     void fFinish() {
80614:         BeforeGLReadCall();
80614:         raw_fFinish();
80614:         AfterGLReadCall();
80614:     }
80614: 
80614:     // Draw/Read
80614:     void fBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
80614:         BeforeGLDrawCall();
80614:         BeforeGLReadCall();
80614:         raw_fBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
80614:         AfterGLReadCall();
80614:         AfterGLDrawCall();
80614:     }
80614: 
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436:     virtual gfxASurface* GetOffscreenPixmapSurface()
74436:     {
74436:       return 0;
74436:     };
74436:     
79445:     virtual bool WaitNative() { return false; }
74436: #endif
74436: 
79445:     virtual bool TextureImageSupportsGetBackingSurface() {
80486:         return false;
54505:     }
54505: 
79445:     virtual bool RenewSurface() { return false; }
59165: 
54505:     /**`
46976:      * Return a valid, allocated TextureImage of |aSize| with
46976:      * |aContentType|.  The TextureImage's texture is configured to
46976:      * use |aWrapMode| (usually GL_CLAMP_TO_EDGE or GL_REPEAT) and by
46976:      * default, GL_LINEAR filtering.  Specify
98144:      * |aFlags=UseNearestFilter| for GL_NEAREST filtering. Specify
98144:      * |aFlags=NeedsYFlip| if the image is flipped. Return
46976:      * NULL if creating the TextureImage fails.
46976:      *
46976:      * The returned TextureImage may only be used with this GLContext.
46976:      * Attempting to use the returned TextureImage after this
46976:      * GLContext is destroyed will result in undefined (and likely
46976:      * crashy) behavior.
46976:      */
46976:     virtual already_AddRefed<TextureImage>
46976:     CreateTextureImage(const nsIntSize& aSize,
46976:                        TextureImage::ContentType aContentType,
57421:                        GLenum aWrapMode,
98144:                        TextureImage::Flags aFlags = TextureImage::NoFlags);
46976: 
49071:     /**
73465:      * In EGL we want to use Tiled Texture Images, which we return
73465:      * from CreateTextureImage above.
73465:      * Inside TiledTextureImage we need to create actual images and to
73465:      * prevent infinite recursion we need to differentiate the two
73465:      * functions.
73465:      **/
73465:     virtual already_AddRefed<TextureImage>
73465:     TileGenFunc(const nsIntSize& aSize,
73465:                 TextureImage::ContentType aContentType,
98144:                 TextureImage::Flags aFlags = TextureImage::NoFlags)
73465:     {
73465:         return nsnull;
73465:     };
73465: 
73465:     /**
49071:      * Read the image data contained in aTexture, and return it as an ImageSurface.
49071:      * If GL_RGBA is given as the format, a ImageFormatARGB32 surface is returned.
49071:      * Not implemented yet:
49071:      * If GL_RGB is given as the format, a ImageFormatRGB24 surface is returned.
49071:      * If GL_LUMINANCE is given as the format, a ImageFormatA8 surface is returned.
49071:      *
49071:      * THIS IS EXPENSIVE.  It is ridiculously expensive.  Only do this
49071:      * if you absolutely positively must, and never in any performance
49071:      * critical path.
49071:      */
49071:     already_AddRefed<gfxImageSurface> ReadTextureImage(GLuint aTexture,
49071:                                                        const gfxIntSize& aSize,
91338:                                                        GLenum aTextureFormat,
91338:                                                        bool aYInvert = false);
91338: 
91338:     already_AddRefed<gfxImageSurface> GetTexImage(GLuint aTexture, bool aYInvert, ShaderProgramType aShader);
49071: 
49076:     /**
49076:      * Call ReadPixels into an existing gfxImageSurface for the given bounds.
49076:      * The image surface must be using image format RGBA32 or RGB24.
49076:      */
55317:     void THEBES_API ReadPixelsIntoImageSurface(GLint aX, GLint aY,
55317:                                     GLsizei aWidth, GLsizei aHeight,
49076:                                     gfxImageSurface *aDest);
49076: 
49076:     /**
54505:      * Copy a rectangle from one TextureImage into another.  The
54505:      * source and destination are given in integer coordinates, and
54505:      * will be converted to texture coordinates.
54505:      *
54505:      * For the source texture, the wrap modes DO apply -- it's valid
54505:      * to use REPEAT or PAD and expect appropriate behaviour if the source
54505:      * rectangle extends beyond its bounds.
54505:      *
54505:      * For the destination texture, the wrap modes DO NOT apply -- the
54505:      * destination will be clipped by the bounds of the texture.
54505:      *
54505:      * Note: calling this function will cause the following OpenGL state
54505:      * to be changed:
54505:      *
54505:      *   - current program
54505:      *   - framebuffer binding
54505:      *   - viewport
54505:      *   - blend state (will be enabled at end)
54505:      *   - scissor state (will be enabled at end)
54505:      *   - vertex attrib 0 and 1 (pointer and enable state [enable state will be disabled at exit])
54505:      *   - array buffer binding (will be 0)
54505:      *   - active texture (will be 0)
54505:      *   - texture 0 binding
54505:      */
54505:     void BlitTextureImage(TextureImage *aSrc, const nsIntRect& aSrcRect,
54505:                           TextureImage *aDst, const nsIntRect& aDstRect);
54505: 
59436:     /**
59436:      * Creates a RGB/RGBA texture (or uses one provided) and uploads the surface
59436:      * contents to it within aSrcRect.
59436:      *
59436:      * aSrcRect.x/y will be uploaded to 0/0 in the texture, and the size
59436:      * of the texture with be aSrcRect.width/height.
59436:      *
59436:      * If an existing texture is passed through aTexture, it is assumed it
59436:      * has already been initialised with glTexImage2D (or this function),
59436:      * and that its size is equal to or greater than aSrcRect + aDstPoint.
59436:      * You can alternatively set the overwrite flag to true and have a new
59436:      * texture memory block allocated.
59436:      *
59436:      * The aDstPoint parameter is ignored if no texture was provided
59436:      * or aOverwrite is true.
59436:      *
59436:      * \param aSurface Surface to upload. 
60728:      * \param aDstRegion Region of texture to upload to.
59436:      * \param aTexture Texture to use, or 0 to have one created for you.
59436:      * \param aOverwrite Over an existing texture with a new one.
60728:      * \param aSrcPoint Offset into aSrc where the region's bound's 
60728:      *  TopLeft() sits.
59442:      * \param aPixelBuffer Pass true to upload texture data with an
59442:      *  offset from the base data (generally for pixel buffer objects), 
59442:      *  otherwise textures are upload with an absolute pointer to the data.
97443:      * \param aTextureUnit, the texture unit used temporarily to upload the
97443:      *  surface. This testure may be overridden, clients should not rely on
97443:      *  the contents of this texture after this call or even on this
97443:      *  texture unit being active.
59436:      * \return Shader program needed to render this texture.
59436:      */
59436:     ShaderProgramType UploadSurfaceToTexture(gfxASurface *aSurface, 
60728:                                              const nsIntRegion& aDstRegion,
59436:                                              GLuint& aTexture,
59436:                                              bool aOverwrite = false,
60728:                                              const nsIntPoint& aSrcPoint = nsIntPoint(0, 0),
97443:                                              bool aPixelBuffer = false,
97443:                                              GLenum aTextureUnit = LOCAL_GL_TEXTURE0);
59436: 
74304:     
74304:     void TexImage2D(GLenum target, GLint level, GLint internalformat, 
74304:                     GLsizei width, GLsizei height, GLsizei stride,
74304:                     GLint pixelsize, GLint border, GLenum format, 
74304:                     GLenum type, const GLvoid *pixels);
74304: 
74304:     void TexSubImage2D(GLenum target, GLint level, 
74304:                        GLint xoffset, GLint yoffset, 
74304:                        GLsizei width, GLsizei height, GLsizei stride,
74304:                        GLint pixelsize, GLenum format, 
74304:                        GLenum type, const GLvoid* pixels);
74304: 
81648:     /**
81648:      * Uses the Khronos GL_EXT_unpack_subimage extension, working around
81648:      * quirks in the Tegra implementation of this extension.
81648:      */
81648:     void TexSubImage2DWithUnpackSubimageGLES(GLenum target, GLint level,
81648:                                              GLint xoffset, GLint yoffset,
81648:                                              GLsizei width, GLsizei height,
81648:                                              GLsizei stride, GLint pixelsize,
81648:                                              GLenum format, GLenum type,
81648:                                              const GLvoid* pixels);
81648: 
81648:     void TexSubImage2DWithoutUnpackSubimage(GLenum target, GLint level,
81648:                                             GLint xoffset, GLint yoffset,
81648:                                             GLsizei width, GLsizei height,
81648:                                             GLsizei stride, GLint pixelsize,
81648:                                             GLenum format, GLenum type,
81648:                                             const GLvoid* pixels);
81648: 
57420:     /** Helper for DecomposeIntoNoRepeatTriangles
57420:      */
57420:     struct RectTriangles {
70073:         RectTriangles() { }
57420: 
93025:         // Always pass texture coordinates upright. If you want to flip the
93025:         // texture coordinates emitted to the tex_coords array, set flip_y to
93025:         // true.
57420:         void addRect(GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1,
93025:                      GLfloat tx0, GLfloat ty0, GLfloat tx1, GLfloat ty1,
93025:                      bool flip_y = false);
57420: 
70073:         /**
70073:          * these return a float pointer to the start of each array respectively.
70073:          * Use it for glVertexAttribPointer calls.
70073:          * We can return NULL if we choose to use Vertex Buffer Objects here.
70073:          */
70073:         float* vertexPointer() {
70073:             return &vertexCoords[0].x;
70073:         };
70073: 
70073:         float* texCoordPointer() {
70073:             return &texCoords[0].u;
70073:         };
70073: 
70073:         unsigned int elements() {
70073:             return vertexCoords.Length();
70073:         };
70073: 
70073:         typedef struct { GLfloat x,y; } vert_coord;
70073:         typedef struct { GLfloat u,v; } tex_coord;
70073:     private:
70073:         // default is 4 rectangles, each made up of 2 triangles (3 coord vertices each)
70073:         nsAutoTArray<vert_coord, 6> vertexCoords;
70073:         nsAutoTArray<tex_coord, 6>  texCoords;
57420:     };
57420: 
57420:     /**
57420:      * Decompose drawing the possibly-wrapped aTexCoordRect rectangle
57420:      * of a texture of aTexSize into one or more rectangles (represented
57420:      * as 2 triangles) and associated tex coordinates, such that
93025:      * we don't have to use the REPEAT wrap mode. If aFlipY is true, the
93025:      * texture coordinates will be specified vertically flipped.
57420:      *
57420:      * The resulting triangle vertex coordinates will be in the space of
57420:      * (0.0, 0.0) to (1.0, 1.0) -- transform the coordinates appropriately
57420:      * if you need a different space.
57420:      *
57420:      * The resulting vertex coordinates should be drawn using GL_TRIANGLES,
57420:      * and rects.numRects * 3 * 6
57420:      */
57420:     static void DecomposeIntoNoRepeatTriangles(const nsIntRect& aTexCoordRect,
57420:                                                const nsIntSize& aTexSize,
93025:                                                RectTriangles& aRects,
93025:                                                bool aFlipY = false);
57420: 
54505:     /**
49076:      * Known GL extensions that can be queried by
49076:      * IsExtensionSupported.  The results of this are cached, and as
49076:      * such it's safe to use this even in performance critical code.
49076:      * If you add to this array, remember to add to the string names
49076:      * in GLContext.cpp.
49076:      */
49076:     enum GLExtensions {
49076:         EXT_framebuffer_object,
49076:         ARB_framebuffer_object,
49077:         ARB_texture_rectangle,
49076:         EXT_bgra,
49076:         EXT_texture_format_BGRA8888,
49076:         OES_depth24,
49076:         OES_depth32,
49076:         OES_stencil8,
49076:         OES_texture_npot,
49076:         OES_depth_texture,
49076:         OES_packed_depth_stencil,
49076:         IMG_read_format,
49076:         EXT_read_format_bgra,
57349:         APPLE_client_storage,
57421:         ARB_texture_non_power_of_two,
59442:         ARB_pixel_buffer_object,
62529:         ARB_ES2_compatibility,
76318:         OES_texture_float,
76318:         ARB_texture_float,
78135:         EXT_unpack_subimage,
79603:         OES_standard_derivatives,
90800:         EXT_texture_filter_anisotropic,
98021:         EXT_texture_compression_s3tc,
80614:         EXT_framebuffer_blit,
80614:         ANGLE_framebuffer_blit,
80616:         EXT_framebuffer_multisample,
80616:         ANGLE_framebuffer_multisample,
80617:         OES_rgb8_rgba8,
80903:         ARB_robustness,
84592:         EXT_robustness,
94950:         ARB_sync,
49076:         Extensions_Max
49076:     };
49076: 
96943:     bool IsExtensionSupported(GLExtensions aKnownExtension) {
49076:         return mAvailableExtensions[aKnownExtension];
49076:     }
49076: 
94795:     void MarkExtensionUnsupported(GLExtensions aKnownExtension) {
94795:         mAvailableExtensions[aKnownExtension] = 0;
94795:     }
70163: 
57246:     // Shared code for GL extensions and GLX extensions.
79445:     static bool ListHasExtension(const GLubyte *extensions,
57246:                                  const char *extension);
57246: 
59435:     GLint GetMaxTextureSize() { return mMaxTextureSize; }
81033:     GLint GetMaxTextureImageSize() { return mMaxTextureImageSize; }
79445:     void SetFlipped(bool aFlipped) { mFlipped = aFlipped; }
59435: 
70163:     // this should just be a std::bitset, but that ended up breaking
70163:     // MacOS X builds; see bug 584919.  We can replace this with one
70163:     // later on.  This is handy to use in WebGL contexts as well,
70163:     // so making it public.
70163:     template<size_t setlen>
70163:     struct ExtensionBitset {
70163:         ExtensionBitset() {
70163:             for (size_t i = 0; i < setlen; ++i)
70163:                 values[i] = false;
70163:         }
70163: 
70163:         bool& operator[](size_t index) {
96943:             NS_ASSERTION(index < setlen, "out of range");
70163:             return values[index];
70163:         }
70163: 
70163:         bool values[setlen];
70163:     };
70163: 
80903:     /**
80903:      * Context reset constants.
80903:      * These are used to determine who is guilty when a context reset
80903:      * happens.
80903:      */
80903:     enum ContextResetARB {
80903:         CONTEXT_NO_ERROR = 0,
80903:         CONTEXT_GUILTY_CONTEXT_RESET_ARB = 0x8253,
80903:         CONTEXT_INNOCENT_CONTEXT_RESET_ARB = 0x8254,
82940:         CONTEXT_UNKNOWN_CONTEXT_RESET_ARB = 0x8255
80903:     };
80903: 
82479:     bool HasRobustness() {
82479:         return mHasRobustness;
82479:     }
82479: 
41369: protected:
79445:     bool mInitialized;
79445:     bool mIsOffscreen;
79445:     bool mIsGLES2;
79445:     bool mIsGlobalSharedContext;
80903:     bool mHasRobustness;
83211:     bool mContextLost;
54505: 
57418:     PRInt32 mVendor;
89416:     PRInt32 mRenderer;
54959: 
89810: public:
55380:     enum {
55380:         DebugEnabled = 1 << 0,
55380:         DebugTrace = 1 << 1,
55380:         DebugAbortOnError = 1 << 2
55380:     };
55380: 
89810:     static PRUint32 sDebugMode;
89810: 
89810:     static PRUint32 DebugMode() {
84816: #ifdef DEBUG
89810:         return sDebugMode;
84816: #else
84816:         return 0;
84816: #endif
84816:     }
84816: 
89810: protected:
89810: 
47908:     ContextFormat mCreationFormat;
47908:     nsRefPtr<GLContext> mSharedContext;
41369: 
95097:     // The thread on which this context was created.
95097:     nsCOMPtr<nsIThread> mOwningThread;
95097: 
55380:     GLContextSymbols mSymbols;
55380: 
98361: #ifdef DEBUG
98361:     // GLDebugMode will check that we don't send call
98361:     // to a GLContext that isn't current on the current
98361:     // thread.
98361:     // Store the current context when binding to thread local
98361:     // storage to support DebugMode on an arbitrary thread.
98361:     static PRUintn sCurrentGLContextTLS;
98361: #endif
98361: 
47908:     void UpdateActualFormat();
47908:     ContextFormat mActualFormat;
47908: 
47908:     gfxIntSize mOffscreenSize;
47908:     gfxIntSize mOffscreenActualSize;
47908:     GLuint mOffscreenTexture;
79445:     bool mFlipped;
47908: 
54505:     // lazy-initialized things
54505:     GLuint mBlitProgram, mBlitFramebuffer;
54505:     void UseBlitProgram();
54505:     void SetBlitFramebufferForDestTexture(GLuint aTexture);
54505: 
85066:     // Helper to create/resize an offscreen FBO,
47908:     // for offscreen implementations that use FBOs.
85066:     // Note that it does -not- clear the resized buffers.
96935:     bool ResizeOffscreenFBOs(const ContextFormat& aCF, const gfxIntSize& aSize, const bool aNeedsReadBuffer);
96935:     bool ResizeOffscreenFBOs(const gfxIntSize& aSize, const bool aNeedsReadBuffer) {
96935:         if (!IsOffscreenSizeAllowed(aSize))
96935:             return false;
96935: 
96935:         ContextFormat format(mCreationFormat);
96935: 
96935:         if (format.samples) {
96935:             // AA path
96935:             if (ResizeOffscreenFBOs(format, aSize, aNeedsReadBuffer))
80621:                 return true;
80621: 
96935:             NS_WARNING("ResizeOffscreenFBOs failed to resize an AA context! Falling back to no AA...");
96935:             format.samples = 0;
92137:         }
80651: 
96935:         if (ResizeOffscreenFBOs(format, aSize, aNeedsReadBuffer))
92137:             return true;
92137: 
96935:         NS_WARNING("ResizeOffscreenFBOs failed to resize non-AA context!");
92137:         return false;
80621:     }
92137: 
96935:     struct GLFormats {
96935:         GLFormats()
96935:             : texColor(0)
96935:             , texColorType(0)
96935:             , rbColor(0)
96935:             , depthStencil(0)
96935:             , depth(0)
96935:             , stencil(0)
96935:             , samples(0)
96935:         {}
96935: 
96935:         GLenum texColor;
96935:         GLenum texColorType;
96935:         GLenum rbColor;
96935:         GLenum depthStencil;
96935:         GLenum depth;
96935:         GLenum stencil;
96935:         GLsizei samples;
96935:     };
96935: 
96935:     GLFormats ChooseGLFormats(ContextFormat& aCF);
96935:     void CreateTextureForOffscreen(const GLFormats& aFormats, const gfxIntSize& aSize,
96935:                                    GLuint& texture);
96935:     void CreateRenderbuffersForOffscreen(const GLContext::GLFormats& aFormats, const gfxIntSize& aSize,
96935:                                          GLuint& colorMSRB, GLuint& depthRB, GLuint& stencilRB);
96935:     bool AssembleOffscreenFBOs(const GLuint colorMSRB,
96935:                                const GLuint depthRB,
96935:                                const GLuint stencilRB,
96935:                                const GLuint texture,
96935:                                GLuint& drawFBO,
96935:                                GLuint& readFBO);
96935: 
96935:     void DeleteOffscreenFBOs();
92137: 
80614:     GLuint mOffscreenDrawFBO;
80614:     GLuint mOffscreenReadFBO;
80617:     GLuint mOffscreenColorRB;
47908:     GLuint mOffscreenDepthRB;
47908:     GLuint mOffscreenStencilRB;
47908: 
49076:     ExtensionBitset<Extensions_Max> mAvailableExtensions;
49076: 
47908:     // Clear to transparent black, with 0 depth and stencil,
47908:     // while preserving current ClearColor etc. values.
47908:     // Useful for resizing offscreen buffers.
85066: public:
47908:     void ClearSafely();
47908: 
95058:     bool WorkAroundDriverBugs() const { return mWorkAroundDriverBugs; }
95058: 
85066: protected:
85066: 
93686:     nsDataHashtable<nsPtrHashKey<void>, void*> mUserData;
41369: 
79445:     void SetIsGLES2(bool aIsGLES2) {
48309:         NS_ASSERTION(!mInitialized, "SetIsGLES2 can only be called before initialization!");
48309:         mIsGLES2 = aIsGLES2;
48309:     }
48309: 
79445:     bool InitWithPrefix(const char *prefix, bool trygl);
41369: 
49076:     void InitExtensions();
43628: 
46977:     virtual already_AddRefed<TextureImage>
46977:     CreateBasicTextureImage(GLuint aTexture,
46977:                             const nsIntSize& aSize,
57421:                             GLenum aWrapMode,
46977:                             TextureImage::ContentType aContentType,
98144:                             GLContext* aContext,
98144:                             TextureImage::Flags aFlags = TextureImage::NoFlags)
59442:     {
59442:         nsRefPtr<BasicTextureImage> teximage(
98144:             new BasicTextureImage(aTexture, aSize, aWrapMode, aContentType, aContext, aFlags));
59442:         return teximage.forget();
59442:     }
46977: 
70172:     bool IsOffscreenSizeAllowed(const gfxIntSize& aSize) const {
70172:         PRInt32 biggerDimension = NS_MAX(aSize.width, aSize.height);
70172:         PRInt32 maxAllowed = NS_MIN(mMaxRenderbufferSize, mMaxTextureSize);
70172:         return biggerDimension <= maxAllowed;
70172:     }
70172: 
55380:     nsTArray<nsIntRect> mViewportStack;
55380:     nsTArray<nsIntRect> mScissorStack;
55380: 
59435:     GLint mMaxTextureSize;
94059:     GLint mMaxCubeMapTextureSize;
81033:     GLint mMaxTextureImageSize;
70172:     GLint mMaxRenderbufferSize;
95058:     bool mWorkAroundDriverBugs;
59435: 
94059:     bool IsTextureSizeSafeToPassToDriver(GLenum target, GLsizei width, GLsizei height) const {
94059: #ifdef XP_MACOSX
95058:         if (mWorkAroundDriverBugs &&
95058:             mVendor == VendorIntel) {
94059:             // see bug 737182 for 2D textures, bug 684822 for cube map textures.
94059:             // some drivers handle incorrectly some large texture sizes that are below the
94059:             // max texture size that they report. So we check ourselves against our own values
94059:             // (mMax[CubeMap]TextureSize).
94059:             GLsizei maxSize = target == LOCAL_GL_TEXTURE_CUBE_MAP ||
94059:                                 (target >= LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
94059:                                 target <= LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z)
94059:                               ? mMaxCubeMapTextureSize
94059:                               : mMaxTextureSize;
94059:             return width <= maxSize && height <= maxSize;
94059:         }
94059: #endif
94059:         return true;
94059:     }
94059: 
41369: public:
49071:  
73519:     /** \returns the first GL error, and guarantees that all GL error flags are cleared,
73519:       * i.e. that a subsequent GetError call will return NO_ERROR
73519:       */
73519:     GLenum GetAndClearError() {
73519:         // the first error is what we want to return
73519:         GLenum error = fGetError();
73519:         
73519:         if (error) {
73519:             // clear all pending errors
73519:             while(fGetError()) {}
73519:         }
73519:         
73519:         return error;
73519:     }
73519: 
55380: #ifdef DEBUG
41369: 
55380: #ifndef MOZ_FUNCTION_NAME
55380: # ifdef __GNUC__
55380: #  define MOZ_FUNCTION_NAME __PRETTY_FUNCTION__
55380: # elif defined(_MSC_VER)
55380: #  define MOZ_FUNCTION_NAME __FUNCTION__
55380: # else
55380: #  define MOZ_FUNCTION_NAME __func__  // defined in C99, supported in various C++ compilers. Just raw function name.
55380: # endif
55380: #endif
41369: 
55380: protected:
55380:     GLenum mGLError;
49071: 
55380: public:
73519: 
55380:     void BeforeGLCall(const char* glFunction) {
84816:         if (DebugMode()) {
98361:             GLContext *currentGLContext = NULL;
98361: 
98361:             currentGLContext = (GLContext*)PR_GetThreadPrivate(sCurrentGLContextTLS);
98361: 
84816:             if (DebugMode() & DebugTrace)
55380:                 printf_stderr("[gl:%p] > %s\n", this, glFunction);
98361:             if (this != currentGLContext) {
55380:                 printf_stderr("Fatal: %s called on non-current context %p. "
55380:                               "The current context for this thread is %p.\n",
98361:                                glFunction, this, currentGLContext);
55380:                 NS_ABORT();
55380:             }
48309:         }
48309:     }
48309: 
55380:     void AfterGLCall(const char* glFunction) {
84816:         if (DebugMode()) {
55380:             // calling fFinish() immediately after every GL call makes sure that if this GL command crashes,
55380:             // the stack trace will actually point to it. Otherwise, OpenGL being an asynchronous API, stack traces
55380:             // tend to be meaningless
55380:             mSymbols.fFinish();
55380:             mGLError = mSymbols.fGetError();
84816:             if (DebugMode() & DebugTrace)
55380:                 printf_stderr("[gl:%p] < %s [0x%04x]\n", this, glFunction, mGLError);
55380:             if (mGLError != LOCAL_GL_NO_ERROR) {
68623:                 printf_stderr("GL ERROR: %s generated GL error %s(0x%04x)\n", 
68623:                               glFunction,
68623:                               GLErrorToString(mGLError),
68623:                               mGLError);
84816:                 if (DebugMode() & DebugAbortOnError)
55380:                     NS_ABORT();
55380:             }
48309:         }
48309:     }
48309: 
68623:     const char* GLErrorToString(GLenum aError)
68623:     {
68623:         switch (aError) {
68623:             case LOCAL_GL_INVALID_ENUM:
68623:                 return "GL_INVALID_ENUM";
68623:             case LOCAL_GL_INVALID_VALUE:
68623:                 return "GL_INVALID_VALUE";
68623:             case LOCAL_GL_INVALID_OPERATION:
68623:                 return "GL_INVALID_OPERATION";
68623:             case LOCAL_GL_STACK_OVERFLOW:
68623:                 return "GL_STACK_OVERFLOW";
68623:             case LOCAL_GL_STACK_UNDERFLOW:
68623:                 return "GL_STACK_UNDERFLOW";
68623:             case LOCAL_GL_OUT_OF_MEMORY:
68623:                 return "GL_OUT_OF_MEMORY";
68623:             case LOCAL_GL_TABLE_TOO_LARGE:
68623:                 return "GL_TABLE_TOO_LARGE";
68623:             case LOCAL_GL_INVALID_FRAMEBUFFER_OPERATION:
68623:                 return "GL_INVALID_FRAMEBUFFER_OPERATION";
68623:             default:
68623:                 return "";
68623:         }
68623:      }
68623: 
55380: #define BEFORE_GL_CALL do {                     \
55380:     BeforeGLCall(MOZ_FUNCTION_NAME);            \
55380: } while (0)
55380:     
55380: #define AFTER_GL_CALL do {                      \
55380:     AfterGLCall(MOZ_FUNCTION_NAME);             \
55380: } while (0)
55380: 
55380: #else
55380: 
55380: #define BEFORE_GL_CALL do { } while (0)
55380: #define AFTER_GL_CALL do { } while (0)
55380: 
55380: #endif
55380: 
55380:     /*** In GL debug mode, we completely override glGetError ***/
55380: 
55380:     GLenum fGetError() {
55380: #ifdef DEBUG
55380:         // debug mode ends up eating the error in AFTER_GL_CALL
84816:         if (DebugMode()) {
55380:             GLenum err = mGLError;
55380:             mGLError = LOCAL_GL_NO_ERROR;
55380:             return err;
55380:         }
55380: #endif
55380: 
55380:         return mSymbols.fGetError();
55380:     }
55380: 
55380: 
55380:     /*** Scissor functions ***/
55380: 
55380: protected:
55380: 
63845:     GLint FixYValue(GLint y, GLint height)
63845:     {
63845:         return mFlipped ? ViewportRect().height - (height + y) : y;
63845:     }
63845: 
55380:     // only does the glScissor call, no ScissorRect business
55380:     void raw_fScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
55380:         BEFORE_GL_CALL;
63845:         // GL's coordinate system is flipped compared to ours (in the Y axis),
63845:         // so we may need to flip our rectangle.
63845:         mSymbols.fScissor(x, 
63845:                           FixYValue(y, height),
63845:                           width, 
63845:                           height);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380: public:
55380: 
55380:     // but let GL-using code use that instead, updating the ScissorRect
54505:     void fScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
54505:         ScissorRect().SetRect(x, y, width, height);
55380:         raw_fScissor(x, y, width, height);
54505:     }
54505: 
54505:     nsIntRect& ScissorRect() {
54505:         return mScissorStack[mScissorStack.Length()-1];
54505:     }
54505: 
54505:     void PushScissorRect() {
55896:         nsIntRect copy(ScissorRect());
55896:         mScissorStack.AppendElement(copy);
54505:     }
54505: 
54505:     void PushScissorRect(const nsIntRect& aRect) {
54505:         mScissorStack.AppendElement(aRect);
55380:         raw_fScissor(aRect.x, aRect.y, aRect.width, aRect.height);
54505:     }
54505: 
54505:     void PopScissorRect() {
54505:         if (mScissorStack.Length() < 2) {
54505:             NS_WARNING("PopScissorRect with Length < 2!");
54505:             return;
54505:         }
54505: 
54505:         nsIntRect thisRect = ScissorRect();
54505:         mScissorStack.TruncateLength(mScissorStack.Length() - 1);
68638:         if (!thisRect.IsEqualInterior(ScissorRect())) {
55380:             raw_fScissor(ScissorRect().x, ScissorRect().y,
54505:                               ScissorRect().width, ScissorRect().height);
54505:         }
54505:     }
54505: 
55380:     /*** Viewport functions ***/
55380: 
55380: protected:
55380: 
55380:     // only does the glViewport call, no ViewportRect business
55380:     void raw_fViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
55380:         BEFORE_GL_CALL;
63845:         // XXX: Flipping should really happen using the destination height, but
63845:         // we use viewport instead and assume viewport size matches the
63845:         // destination. If we ever try use partial viewports for layers we need
63845:         // to fix this, and remove the assertion.
63845:         NS_ASSERTION(!mFlipped || (x == 0 && y == 0), "TODO: Need to flip the viewport rect"); 
55380:         mSymbols.fViewport(x, y, width, height);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380: public:
55380: 
54505:     void fViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
54505:         ViewportRect().SetRect(x, y, width, height);
55380:         raw_fViewport(x, y, width, height);
54505:     }
54505: 
54505:     nsIntRect& ViewportRect() {
54505:         return mViewportStack[mViewportStack.Length()-1];
54505:     }
54505: 
54505:     void PushViewportRect() {
55896:         nsIntRect copy(ViewportRect());
55896:         mViewportStack.AppendElement(copy);
54505:     }
54505: 
54505:     void PushViewportRect(const nsIntRect& aRect) {
54505:         mViewportStack.AppendElement(aRect);
55380:         raw_fViewport(aRect.x, aRect.y, aRect.width, aRect.height);
54505:     }
54505: 
54505:     void PopViewportRect() {
54505:         if (mViewportStack.Length() < 2) {
54505:             NS_WARNING("PopViewportRect with Length < 2!");
54505:             return;
54505:         }
54505: 
54505:         nsIntRect thisRect = ViewportRect();
54505:         mViewportStack.TruncateLength(mViewportStack.Length() - 1);
68638:         if (!thisRect.IsEqualInterior(ViewportRect())) {
55380:             raw_fViewport(ViewportRect().x, ViewportRect().y,
54505:                           ViewportRect().width, ViewportRect().height);
54505:         }
54505:     }
54505: 
55380:     /*** other GL functions ***/
54505: 
55380:     void fActiveTexture(GLenum texture) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fActiveTexture(texture);
55380:         AFTER_GL_CALL;
55380:     }
48309: 
55380:     void fAttachShader(GLuint program, GLuint shader) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fAttachShader(program, shader);
55380:         AFTER_GL_CALL;
55380:     }
48309: 
55380:     void fBindAttribLocation(GLuint program, GLuint index, const GLchar* name) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBindAttribLocation(program, index, name);
55380:         AFTER_GL_CALL;
55380:     }
54505: 
55380:     void fBindBuffer(GLenum target, GLuint buffer) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBindBuffer(target, buffer);
55380:         AFTER_GL_CALL;
55380:     }
54505: 
55380:     void fBindTexture(GLenum target, GLuint texture) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBindTexture(target, texture);
55380:         AFTER_GL_CALL;
55380:     }
54505: 
55380:     void fBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBlendColor(red, green, blue, alpha);
55380:         AFTER_GL_CALL;
55380:     }
47908: 
55380:     void fBlendEquation(GLenum mode) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBlendEquation(mode);
55380:         AFTER_GL_CALL;
55380:     }
47908: 
55380:     void fBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBlendEquationSeparate(modeRGB, modeAlpha);
55380:         AFTER_GL_CALL;
55380:     }
47908: 
55380:     void fBlendFunc(GLenum sfactor, GLenum dfactor) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBlendFunc(sfactor, dfactor);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBufferData(target, size, data, usage);
95498: 
95498:         // bug 744888
95498:         if (WorkAroundDriverBugs() &&
95498:             !data &&
95498:             Vendor() == VendorNVIDIA)
95498:         {
95498:             char c = 0;
95498:             mSymbols.fBufferSubData(target, size-1, 1, &c);
95498:         }
95498: 
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBufferSubData(target, offset, size, data);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
80614:     void raw_fClear(GLbitfield mask) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fClear(mask);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fClearColor(GLclampf r, GLclampf g, GLclampf b, GLclampf a) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fClearColor(r, g, b, a);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fClearStencil(GLint s) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fClearStencil(s);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fColorMask(realGLboolean red, realGLboolean green, realGLboolean blue, realGLboolean alpha) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fColorMask(red, green, blue, alpha);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
98021:     void fCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *pixels) {
98021:         BEFORE_GL_CALL;
98021:         mSymbols.fCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, pixels);
98021:         AFTER_GL_CALL;
98021:     }
98021: 
98021:     void fCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *pixels) {
98021:         BEFORE_GL_CALL;
98021:         mSymbols.fCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, pixels);
98021:         AFTER_GL_CALL;
98021:     }
98021: 
55380:     void fCullFace(GLenum mode) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fCullFace(mode);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fDetachShader(GLuint program, GLuint shader) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fDetachShader(program, shader);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fDepthFunc(GLenum func) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fDepthFunc(func);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fDepthMask(realGLboolean flag) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fDepthMask(flag);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fDisable(GLenum capability) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fDisable(capability);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fDisableVertexAttribArray(GLuint index) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fDisableVertexAttribArray(index);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
80614:     void raw_fDrawArrays(GLenum mode, GLint first, GLsizei count) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fDrawArrays(mode, first, count);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
80614:     void raw_fDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fDrawElements(mode, count, type, indices);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fEnable(GLenum capability) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fEnable(capability);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fEnableVertexAttribArray(GLuint index) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fEnableVertexAttribArray(index);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
80614:     void raw_fFinish() {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fFinish();
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fFlush() {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fFlush();
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fFrontFace(GLenum face) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fFrontFace(face);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetActiveAttrib(GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetActiveAttrib(program, index, maxLength, length, size, type, name);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetActiveUniform(GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetActiveUniform(program, index, maxLength, length, size, type, name);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetAttachedShaders(program, maxCount, count, shaders);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     GLint fGetAttribLocation (GLuint program, const GLchar* name) {
55380:         BEFORE_GL_CALL;
55380:         GLint retval = mSymbols.fGetAttribLocation(program, name);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
90331: private:
90331:     void raw_fGetIntegerv(GLenum pname, GLint *params) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetIntegerv(pname, params);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
90331: public:
90331:     void fGetIntegerv(GLenum pname, GLint *params) {
90331:         switch (pname)
90331:         {
90331:             // LOCAL_GL_FRAMEBUFFER_BINDING is equal to
90331:             // LOCAL_GL_DRAW_FRAMEBUFFER_BINDING_EXT, so we don't need two
90331:             // cases.
90331:             case LOCAL_GL_FRAMEBUFFER_BINDING:
92137:                 *params = GetUserBoundDrawFBO();
90331:                 break;
90331: 
90331:             case LOCAL_GL_READ_FRAMEBUFFER_BINDING_EXT:
92137:                 *params = GetUserBoundReadFBO();
90331:                 break;
90331: 
90331:             default:
90331:                 raw_fGetIntegerv(pname, params);
90331:                 break;
90331:         }
90331:     }
90331: 
55380:     void fGetFloatv(GLenum pname, GLfloat *params) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetFloatv(pname, params);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetBooleanv(GLenum pname, realGLboolean *params) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetBooleanv(pname, params);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetBufferParameteriv(GLenum target, GLenum pname, GLint* params) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetBufferParameteriv(target, pname, params);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGenerateMipmap(GLenum target) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGenerateMipmap(target);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetProgramiv(GLuint program, GLenum pname, GLint* param) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetProgramiv(program, pname, param);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetProgramInfoLog(program, bufSize, length, infoLog);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fTexParameteri(GLenum target, GLenum pname, GLint param) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fTexParameteri(target, pname, param);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fTexParameterf(GLenum target, GLenum pname, GLfloat param) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fTexParameterf(target, pname, param);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     const GLubyte* fGetString(GLenum name) {
55380:         BEFORE_GL_CALL;
55380:         const GLubyte *result = mSymbols.fGetString(name);
55380:         AFTER_GL_CALL;
55380:         return result;
55380:     }
55380: 
91338:     void fGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *img) {
91338:         if (!mSymbols.fGetTexImage) {
91338:           return;
91338:         }
91338:         BEFORE_GL_CALL;
91338:         mSymbols.fGetTexImage(target, level, format, type, img);
91338:         AFTER_GL_CALL;
91338:     };
91338: 
91338:     void fGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
91338:     {  
91458:         if (!mSymbols.fGetTexLevelParameteriv) {
91458:           *params = 0;
91458:           return;
91458:         }
91338:         BEFORE_GL_CALL;
91338:         mSymbols.fGetTexLevelParameteriv(target, level, pname, params);
91338:         AFTER_GL_CALL;
91338:     }
91338: 
55380:     void fGetTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetTexParameterfv(target, pname, params);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetTexParameteriv(GLenum target, GLenum pname, const GLint *params) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetTexParameteriv(target, pname, params);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetUniformfv(GLuint program, GLint location, GLfloat* params) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetUniformfv(program, location, params);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetUniformiv(GLuint program, GLint location, GLint* params) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetUniformiv(program, location, params);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     GLint fGetUniformLocation (GLint programObj, const GLchar* name) {
55380:         BEFORE_GL_CALL;
55380:         GLint retval = mSymbols.fGetUniformLocation(programObj, name);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
55380:     void fGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* retval) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetVertexAttribfv(index, pname, retval);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetVertexAttribiv(GLuint index, GLenum pname, GLint* retval) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetVertexAttribiv(index, pname, retval);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fHint(GLenum target, GLenum mode) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fHint(target, mode);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     realGLboolean fIsBuffer(GLuint buffer) {
55380:         BEFORE_GL_CALL;
55380:         realGLboolean retval = mSymbols.fIsBuffer(buffer);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
55380:     realGLboolean fIsEnabled (GLenum capability) {
55380:         BEFORE_GL_CALL;
55380:         realGLboolean retval = mSymbols.fIsEnabled(capability);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
55380:     realGLboolean fIsProgram (GLuint program) {
55380:         BEFORE_GL_CALL;
55380:         realGLboolean retval = mSymbols.fIsProgram(program);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
55380:     realGLboolean fIsShader (GLuint shader) {
55380:         BEFORE_GL_CALL;
55380:         realGLboolean retval = mSymbols.fIsShader(shader);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
55380:     realGLboolean fIsTexture (GLuint texture) {
55380:         BEFORE_GL_CALL;
55380:         realGLboolean retval = mSymbols.fIsTexture(texture);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
55380:     void fLineWidth(GLfloat width) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fLineWidth(width);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fLinkProgram(GLuint program) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fLinkProgram(program);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fPixelStorei(GLenum pname, GLint param) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fPixelStorei(pname, param);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fPolygonOffset(GLfloat factor, GLfloat bias) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fPolygonOffset(factor, bias);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fReadBuffer(GLenum mode) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fReadBuffer(mode);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
80614:     void raw_fReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fReadPixels(x, y, width, height, format, type, pixels);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fSampleCoverage(GLclampf value, realGLboolean invert) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fSampleCoverage(value, invert);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fStencilFunc(GLenum func, GLint ref, GLuint mask) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fStencilFunc(func, ref, mask);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fStencilFuncSeparate(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fStencilFuncSeparate(frontfunc, backfunc, ref, mask);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fStencilMask(GLuint mask) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fStencilMask(mask);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fStencilMaskSeparate(GLenum face, GLuint mask) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fStencilMaskSeparate(face, mask);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fStencilOp(fail, zfail, zpass);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fStencilOpSeparate(face, sfail, dpfail, dppass);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
55380:         BEFORE_GL_CALL;
94059:         if (IsTextureSizeSafeToPassToDriver(target, width, height)) {
55380:           mSymbols.fTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
94059:         } else {
94059:           // pass wrong values to cause the GL to generate GL_INVALID_VALUE.
94059:           // See bug 737182 and the comment in IsTextureSizeSafeToPassToDriver.
94059:           mSymbols.fTexImage2D(target, -1, internalformat, -1, -1, -1, format, type, nsnull);
94059:         }
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform1f(GLint location, GLfloat v0) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform1f(location, v0);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform1fv(GLint location, GLsizei count, const GLfloat* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform1fv(location, count, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform1i(GLint location, GLint v0) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform1i(location, v0);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform1iv(GLint location, GLsizei count, const GLint* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform1iv(location, count, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform2f(GLint location, GLfloat v0, GLfloat v1) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform2f(location, v0, v1);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform2fv(GLint location, GLsizei count, const GLfloat* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform2fv(location, count, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform2i(GLint location, GLint v0, GLint v1) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform2i(location, v0, v1);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform2iv(GLint location, GLsizei count, const GLint* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform2iv(location, count, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform3f(location, v0, v1, v2);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform3fv(GLint location, GLsizei count, const GLfloat* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform3fv(location, count, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform3i(GLint location, GLint v0, GLint v1, GLint v2) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform3i(location, v0, v1, v2);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform3iv(GLint location, GLsizei count, const GLint* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform3iv(location, count, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform4f(location, v0, v1, v2, v3);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform4fv(GLint location, GLsizei count, const GLfloat* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform4fv(location, count, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform4i(location, v0, v1, v2, v3);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniform4iv(GLint location, GLsizei count, const GLint* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniform4iv(location, count, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniformMatrix2fv(GLint location, GLsizei count, realGLboolean transpose, const GLfloat* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniformMatrix2fv(location, count, transpose, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniformMatrix3fv(GLint location, GLsizei count, realGLboolean transpose, const GLfloat* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniformMatrix3fv(location, count, transpose, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUniformMatrix4fv(GLint location, GLsizei count, realGLboolean transpose, const GLfloat* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUniformMatrix4fv(location, count, transpose, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fUseProgram(GLuint program) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fUseProgram(program);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fValidateProgram(GLuint program) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fValidateProgram(program);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fVertexAttribPointer(GLuint index, GLint size, GLenum type, realGLboolean normalized, GLsizei stride, const GLvoid* pointer) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fVertexAttribPointer(index, size, type, normalized, stride, pointer);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fVertexAttrib1f(GLuint index, GLfloat x) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fVertexAttrib1f(index, x);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fVertexAttrib2f(GLuint index, GLfloat x, GLfloat y) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fVertexAttrib2f(index, x, y);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fVertexAttrib3f(index, x, y, z);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fVertexAttrib4f(index, x, y, z, w);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fVertexAttrib1fv(GLuint index, const GLfloat* v) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fVertexAttrib1fv(index, v);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fVertexAttrib2fv(GLuint index, const GLfloat* v) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fVertexAttrib2fv(index, v);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fVertexAttrib3fv(GLuint index, const GLfloat* v) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fVertexAttrib3fv(index, v);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fVertexAttrib4fv(GLuint index, const GLfloat* v) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fVertexAttrib4fv(index, v);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fCompileShader(GLuint shader) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fCompileShader(shader);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
80614:     void raw_fCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
55380:         BEFORE_GL_CALL;
94059:         if (IsTextureSizeSafeToPassToDriver(target, width, height)) {
63845:           mSymbols.fCopyTexImage2D(target, level, internalformat, 
63845:                                    x, FixYValue(y, height),
63845:                                    width, height, border);
94059: 
94059:         } else {
94059:           // pass wrong values to cause the GL to generate GL_INVALID_VALUE.
94059:           // See bug 737182 and the comment in IsTextureSizeSafeToPassToDriver.
94059:           mSymbols.fCopyTexImage2D(target, -1, internalformat, 
94059:                                    x, FixYValue(y, height),
94059:                                    -1, -1, -1);
94059: 
94059:         }
55380:         AFTER_GL_CALL;
55380:     }
55380: 
80614:     void raw_fCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
55380:         BEFORE_GL_CALL;
63845:         mSymbols.fCopyTexSubImage2D(target, level, xoffset, yoffset, 
63845:                                     x, FixYValue(y, height),
63845:                                     width, height);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetShaderiv(GLuint shader, GLenum pname, GLint* param) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetShaderiv(shader, pname, param);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetShaderInfoLog(shader, bufSize, length, infoLog);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
84804:     void fGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision) {
84804:         BEFORE_GL_CALL;
84804:         if (mIsGLES2) {
84804:             mSymbols.fGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
84804:         } else {
84804:             // Fall back to automatic values because almost all desktop hardware supports the OpenGL standard precisions.
84804:             GetShaderPrecisionFormatNonES2(shadertype, precisiontype, range, precision);
84804:         }
84804:         AFTER_GL_CALL;
84804:     }
84804: 
55380:     void fGetShaderSource(GLint obj, GLsizei maxLength, GLsizei* length, GLchar* source) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetShaderSource(obj, maxLength, length, source);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fShaderSource(GLuint shader, GLsizei count, const GLchar** strings, const GLint* lengths) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fShaderSource(shader, count, strings, lengths);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
89744: private:
89744:     void raw_fBindFramebuffer(GLenum target, GLuint framebuffer) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBindFramebuffer(target, framebuffer);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
89744: public:
55380:     void fBindRenderbuffer(GLenum target, GLuint renderbuffer) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fBindRenderbuffer(target, renderbuffer);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     GLenum fCheckFramebufferStatus (GLenum target) {
55380:         BEFORE_GL_CALL;
55380:         GLenum retval = mSymbols.fCheckFramebufferStatus(target);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
55380:     void fFramebufferRenderbuffer(GLenum target, GLenum attachmentPoint, GLenum renderbufferTarget, GLuint renderbuffer) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fFramebufferRenderbuffer(target, attachmentPoint, renderbufferTarget, renderbuffer);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fFramebufferTexture2D(GLenum target, GLenum attachmentPoint, GLenum textureTarget, GLuint texture, GLint level) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fFramebufferTexture2D(target, attachmentPoint, textureTarget, texture, level);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetFramebufferAttachmentParameteriv(target, attachment, pname, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* value) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fGetRenderbufferParameteriv(target, pname, value);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     realGLboolean fIsFramebuffer (GLuint framebuffer) {
55380:         BEFORE_GL_CALL;
55380:         realGLboolean retval = mSymbols.fIsFramebuffer(framebuffer);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
80614:     void raw_fBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
80614:         BEFORE_GL_CALL;
80614:         mSymbols.fBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
80614:         AFTER_GL_CALL;
80614:     }
80614: 
55380:     realGLboolean fIsRenderbuffer (GLuint renderbuffer) {
55380:         BEFORE_GL_CALL;
55380:         realGLboolean retval = mSymbols.fIsRenderbuffer(renderbuffer);
55380:         AFTER_GL_CALL;
55380:         return retval;
55380:     }
55380: 
55380:     void fRenderbufferStorage(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height) {
55380:         BEFORE_GL_CALL;
55380:         mSymbols.fRenderbufferStorage(target, internalFormat, width, height);
55380:         AFTER_GL_CALL;
55380:     }
55380: 
80616:     void fRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height) {
80616:         BEFORE_GL_CALL;
80616:         mSymbols.fRenderbufferStorageMultisample(target, samples, internalFormat, width, height);
80616:         AFTER_GL_CALL;
80616:     }
80616: 
55380:     void fDepthRange(GLclampf a, GLclampf b) {
55380:         BEFORE_GL_CALL;
55380:         if (mIsGLES2) {
55380:             mSymbols.fDepthRangef(a, b);
55380:         } else {
55380:             mSymbols.fDepthRange(a, b);
55380:         }
55380:         AFTER_GL_CALL;
55380:     }
55380: 
55380:     void fClearDepth(GLclampf v) {
55380:         BEFORE_GL_CALL;
55380:         if (mIsGLES2) {
55380:             mSymbols.fClearDepthf(v);
55380:         } else {
55380:             mSymbols.fClearDepth(v);
55380:         }
55380:         AFTER_GL_CALL;
55380:     }
55380: 
59442:     void* fMapBuffer(GLenum target, GLenum access) {
59442:         BEFORE_GL_CALL;
59442:         void *ret = mSymbols.fMapBuffer(target, access);
59442:         AFTER_GL_CALL;
59442:         return ret;
59442:     }
59442: 
59442:     realGLboolean fUnmapBuffer(GLenum target) {
59442:         BEFORE_GL_CALL;
59442:         realGLboolean ret = mSymbols.fUnmapBuffer(target);
59442:         AFTER_GL_CALL;
59442:         return ret;
59442:     }
59442: 
55380: 
60066: #ifdef DEBUG
49071:      GLContext *TrackingContext() {
49071:          GLContext *tip = this;
49071:          while (tip->mSharedContext)
49071:              tip = tip->mSharedContext;
49071:          return tip;
49071:      }
49071: 
60066: #define TRACKING_CONTEXT(a) do { TrackingContext()->a; } while (0)
60066: #else
60066: #define TRACKING_CONTEXT(a) do {} while (0)
60066: #endif
60066: 
47908:      GLuint GLAPIENTRY fCreateProgram() {
55380:          BEFORE_GL_CALL;
55380:          GLuint ret = mSymbols.fCreateProgram();
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(CreatedProgram(this, ret));
47908:          return ret;
47908:      }
47908: 
47908:      GLuint GLAPIENTRY fCreateShader(GLenum t) {
55380:          BEFORE_GL_CALL;
55380:          GLuint ret = mSymbols.fCreateShader(t);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(CreatedShader(this, ret));
47908:          return ret;
47908:      }
47908: 
47908:      void GLAPIENTRY fGenBuffers(GLsizei n, GLuint* names) {
55380:          BEFORE_GL_CALL;
55380:          mSymbols.fGenBuffers(n, names);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(CreatedBuffers(this, n, names));
47908:      }
47908: 
47908:      void GLAPIENTRY fGenTextures(GLsizei n, GLuint* names) {
55380:          BEFORE_GL_CALL;
55380:          mSymbols.fGenTextures(n, names);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(CreatedTextures(this, n, names));
47908:      }
47908: 
47908:      void GLAPIENTRY fGenFramebuffers(GLsizei n, GLuint* names) {
55380:          BEFORE_GL_CALL;
55380:          mSymbols.fGenFramebuffers(n, names);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(CreatedFramebuffers(this, n, names));
47908:      }
47908: 
47908:      void GLAPIENTRY fGenRenderbuffers(GLsizei n, GLuint* names) {
55380:          BEFORE_GL_CALL;
55380:          mSymbols.fGenRenderbuffers(n, names);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(CreatedRenderbuffers(this, n, names));
47908:      }
47908: 
47908:      void GLAPIENTRY fDeleteProgram(GLuint program) {
55380:          BEFORE_GL_CALL;
55380:          mSymbols.fDeleteProgram(program);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(DeletedProgram(this, program));
47908:      }
47908: 
47908:      void GLAPIENTRY fDeleteShader(GLuint shader) {
55380:          BEFORE_GL_CALL;
55380:          mSymbols.fDeleteShader(shader);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(DeletedShader(this, shader));
47908:      }
47908: 
47908:      void GLAPIENTRY fDeleteBuffers(GLsizei n, GLuint *names) {
55380:          BEFORE_GL_CALL;
55380:          mSymbols.fDeleteBuffers(n, names);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(DeletedBuffers(this, n, names));
47908:      }
47908: 
47908:      void GLAPIENTRY fDeleteTextures(GLsizei n, GLuint *names) {
55380:          BEFORE_GL_CALL;
55380:          mSymbols.fDeleteTextures(n, names);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(DeletedTextures(this, n, names));
47908:      }
47908: 
47908:      void GLAPIENTRY fDeleteFramebuffers(GLsizei n, GLuint *names) {
55380:          BEFORE_GL_CALL;
60067:          if (n == 1 && *names == 0) {
60067:             /* Deleting framebuffer 0 causes hangs on the DROID. See bug 623228 */
60067:          } else {
55380:             mSymbols.fDeleteFramebuffers(n, names);
60067:          }
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(DeletedFramebuffers(this, n, names));
47908:      }
47908: 
47908:      void GLAPIENTRY fDeleteRenderbuffers(GLsizei n, GLuint *names) {
55380:          BEFORE_GL_CALL;
55380:          mSymbols.fDeleteRenderbuffers(n, names);
55380:          AFTER_GL_CALL;
60066:          TRACKING_CONTEXT(DeletedRenderbuffers(this, n, names));
47908:      }
80903: 
80903:      GLenum GLAPIENTRY fGetGraphicsResetStatus() {
80903:          BEFORE_GL_CALL;
80903:          GLenum ret = mHasRobustness ? mSymbols.fGetGraphicsResetStatus() : 0;
80903:          AFTER_GL_CALL;
80903:          return ret;
80903:      }
80903: 
94950:      GLsync GLAPIENTRY fFenceSync(GLenum condition, GLbitfield flags) {
94950:          BEFORE_GL_CALL;
94950:          GLsync ret = mSymbols.fFenceSync(condition, flags);
94950:          AFTER_GL_CALL;
94950:          return ret;
94950:      }
94950: 
94950:      realGLboolean GLAPIENTRY fIsSync(GLsync sync) {
94950:          BEFORE_GL_CALL;
94950:          realGLboolean ret = mSymbols.fIsSync(sync);
94950:          AFTER_GL_CALL;
94950:          return ret;
94950:      }
94950: 
94950:      void GLAPIENTRY fDeleteSync(GLsync sync) {
94950:          BEFORE_GL_CALL;
94950:          mSymbols.fDeleteSync(sync);
94950:          AFTER_GL_CALL;
94950:      }
94950: 
94950:      GLenum GLAPIENTRY fClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
94950:          BEFORE_GL_CALL;
94950:          GLenum ret = mSymbols.fClientWaitSync(sync, flags, timeout);
94950:          AFTER_GL_CALL;
94950:          return ret;
94950:      }
94950: 
94950:      void GLAPIENTRY fWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
94950:          BEFORE_GL_CALL;
94950:          mSymbols.fWaitSync(sync, flags, timeout);
94950:          AFTER_GL_CALL;
94950:      }
94950: 
94950:      void GLAPIENTRY fGetInteger64v(GLenum pname, GLint64 *params) {
94950:          BEFORE_GL_CALL;
94950:          mSymbols.fGetInteger64v(pname, params);
94950:          AFTER_GL_CALL;
94950:      }
94950: 
94950:      void GLAPIENTRY fGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values) {
94950:          BEFORE_GL_CALL;
94950:          mSymbols.fGetSynciv(sync, pname, bufSize, length, values);
94950:          AFTER_GL_CALL;
94950:      }
94950: 
60066: #ifdef DEBUG
47947:     void THEBES_API CreatedProgram(GLContext *aOrigin, GLuint aName);
47947:     void THEBES_API CreatedShader(GLContext *aOrigin, GLuint aName);
47947:     void THEBES_API CreatedBuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames);
47947:     void THEBES_API CreatedTextures(GLContext *aOrigin, GLsizei aCount, GLuint *aNames);
47947:     void THEBES_API CreatedFramebuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames);
47947:     void THEBES_API CreatedRenderbuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames);
47947:     void THEBES_API DeletedProgram(GLContext *aOrigin, GLuint aName);
47947:     void THEBES_API DeletedShader(GLContext *aOrigin, GLuint aName);
47947:     void THEBES_API DeletedBuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames);
47947:     void THEBES_API DeletedTextures(GLContext *aOrigin, GLsizei aCount, GLuint *aNames);
47947:     void THEBES_API DeletedFramebuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames);
47947:     void THEBES_API DeletedRenderbuffers(GLContext *aOrigin, GLsizei aCount, GLuint *aNames);
47908: 
47908:     void SharedContextDestroyed(GLContext *aChild);
47908:     void ReportOutstandingNames();
47908: 
47908:     struct NamedResource {
47908:         NamedResource()
80486:             : origin(nsnull), name(0), originDeleted(false)
47908:         { }
47908: 
47908:         NamedResource(GLContext *aOrigin, GLuint aName)
80486:             : origin(aOrigin), name(aName), originDeleted(false)
47908:         { }
47908: 
47908:         GLContext *origin;
47908:         GLuint name;
79445:         bool originDeleted;
47908: 
47908:         // for sorting
47908:         bool operator<(const NamedResource& aOther) const {
47908:             if (intptr_t(origin) < intptr_t(aOther.origin))
47908:                 return true;
47908:             if (name < aOther.name)
47908:                 return true;
47908:             return false;
47908:         }
47908:         bool operator==(const NamedResource& aOther) const {
47908:             return origin == aOther.origin &&
47908:                 name == aOther.name &&
47908:                 originDeleted == aOther.originDeleted;
47908:         }
47908:     };
47908: 
47908:     nsTArray<NamedResource> mTrackedPrograms;
47908:     nsTArray<NamedResource> mTrackedShaders;
47908:     nsTArray<NamedResource> mTrackedTextures;
47908:     nsTArray<NamedResource> mTrackedFramebuffers;
47908:     nsTArray<NamedResource> mTrackedRenderbuffers;
47908:     nsTArray<NamedResource> mTrackedBuffers;
47908: #endif
47908: 
41369: };
41369: 
79445: inline bool
89416: DoesStringMatch(const char* aString, const char *aWantedString)
54959: {
89416:     if (!aString || !aWantedString)
80486:         return false;
64628: 
89416:     const char *occurrence = strstr(aString, aWantedString);
89416: 
89416:     // aWanted not found
54959:     if (!occurrence)
80486:         return false;
54959: 
89416:     // aWantedString preceded by alpha character
89416:     if (occurrence != aString && isalpha(*(occurrence-1)))
80486:         return false;
54959: 
54959:     // aWantedVendor followed by alpha character
89416:     const char *afterOccurrence = occurrence + strlen(aWantedString);
54959:     if (isalpha(*afterOccurrence))
80486:         return false;
54959: 
80486:     return true;
54959: }
54959: 
41369: } /* namespace gl */
41369: } /* namespace mozilla */
41369: 
42402: #endif /* GLCONTEXT_H_ */
