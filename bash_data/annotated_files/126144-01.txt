     1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 80946: #include "nsNavBookmarks.h"
 80946: 
 80946: #include "nsNavHistory.h"
 80946: #include "nsAnnotationService.h"
 80946: #include "nsPlacesMacros.h"
 80946: #include "Helpers.h"
 80946: 
     1: #include "nsAppDirectoryServiceDefs.h"
     1: #include "nsNetUtil.h"
     1: #include "nsUnicharUtils.h"
   338: #include "nsPrintfCString.h"
  4004: #include "prprf.h"
 80946: #include "mozilla/storage.h"
 69981: #include "mozilla/Util.h"
 42480: 
 87692: #include "sampler.h"
 87692: 
 50437: #define BOOKMARKS_TO_KEYWORDS_INITIAL_CACHE_SIZE 64
 69986: #define RECENT_BOOKMARKS_INITIAL_CACHE_SIZE 10
 69986: // Threashold to expire old bookmarks if the initial cache size is exceeded.
108991: #define RECENT_BOOKMARKS_THRESHOLD PRTime((int64_t)1 * 60 * PR_USEC_PER_SEC)
 69986: 
 76962: #define BEGIN_CRITICAL_BOOKMARK_CACHE_SECTION(_itemId_) \
 87168:   mUncachableBookmarks.PutEntry(_itemId_); \
 76962:   mRecentBookmarksCache.RemoveEntry(_itemId_)
 76962: 
 76962: #define END_CRITICAL_BOOKMARK_CACHE_SECTION(_itemId_) \
 87168:   MOZ_ASSERT(!mRecentBookmarksCache.GetEntry(_itemId_)); \
 87168:   MOZ_ASSERT(mUncachableBookmarks.GetEntry(_itemId_)); \
 87168:   mUncachableBookmarks.RemoveEntry(_itemId_)
 87168: 
 87168: #define ADD_TO_BOOKMARK_CACHE(_itemId_, _data_) \
 87168:   PR_BEGIN_MACRO \
 87168:   ExpireNonrecentBookmarks(&mRecentBookmarksCache); \
 87168:   if (!mUncachableBookmarks.GetEntry(_itemId_)) { \
 87168:     BookmarkKeyClass* key = mRecentBookmarksCache.PutEntry(_itemId_); \
 87168:     if (key) { \
 87168:       key->bookmark = _data_; \
 87168:     } \
 87168:   } \
 87168:   PR_END_MACRO
 76962: 
 69986: #define TOPIC_PLACES_MAINTENANCE "places-maintenance-finished"
 50437: 
 80467: using namespace mozilla;
 80467: 
     1: // These columns sit to the right of the kGetInfoIndex_* columns.
108991: const int32_t nsNavBookmarks::kGetChildrenIndex_Position = 14;
108991: const int32_t nsNavBookmarks::kGetChildrenIndex_Type = 15;
108991: const int32_t nsNavBookmarks::kGetChildrenIndex_PlaceID = 16;
108991: const int32_t nsNavBookmarks::kGetChildrenIndex_Guid = 17;
 69981: 
 41402: using namespace mozilla::places;
 29518: 
 35298: PLACES_FACTORY_SINGLETON_IMPLEMENTATION(nsNavBookmarks, gBookmarksService)
     1: 
     1: #define BOOKMARKS_ANNO_PREFIX "bookmarks/"
  2049: #define BOOKMARKS_TOOLBAR_FOLDER_ANNO NS_LITERAL_CSTRING(BOOKMARKS_ANNO_PREFIX "toolbarFolder")
  4179: #define READ_ONLY_ANNO NS_LITERAL_CSTRING("placesInternal/READ_ONLY")
     1: 
 50437: 
 50437: namespace {
 50437: 
 50437: struct keywordSearchData
 50437: {
108991:   int64_t itemId;
 50437:   nsString keyword;
 50437: };
 50437: 
 50437: PLDHashOperator
 50437: SearchBookmarkForKeyword(nsTrimInt64HashKey::KeyType aKey,
 50437:                          const nsString aValue,
 50437:                          void* aUserArg)
 50437: {
 50437:   keywordSearchData* data = reinterpret_cast<keywordSearchData*>(aUserArg);
 50437:   if (data->keyword.Equals(aValue)) {
 50437:     data->itemId = aKey;
 50437:     return PL_DHASH_STOP;
 50437:   }
 50437:   return PL_DHASH_NEXT;
 50437: }
 50437: 
 60944: template<typename Method, typename DataType>
 60944: class AsyncGetBookmarksForURI : public AsyncStatementCallback
 60944: {
 60944: public:
 60944:   AsyncGetBookmarksForURI(nsNavBookmarks* aBookmarksSvc,
 60944:                           Method aCallback,
 61984:                           const DataType& aData)
 60944:   : mBookmarksSvc(aBookmarksSvc)
 60944:   , mCallback(aCallback)
 60944:   , mData(aData)
 60944:   {
 61984:   }
 61984: 
 61984:   void Init()
 61984:   {
 80946:     nsRefPtr<Database> DB = Database::GetDatabase();
 80946:     if (DB) {
 80946:       nsCOMPtr<mozIStorageAsyncStatement> stmt = DB->GetAsyncStatement(
 80946:         "SELECT b.id, b.guid, b.parent, b.lastModified, t.guid, t.parent "
 80946:         "FROM moz_bookmarks b "
 80946:         "JOIN moz_bookmarks t on t.id = b.parent "
 80946:         "WHERE b.fk = (SELECT id FROM moz_places WHERE url = :page_url) "
 80946:         "ORDER BY b.lastModified DESC, b.id DESC "
 80946:       );
 60944:       if (stmt) {
 69981:         (void)URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"),
 69981:                               mData.bookmark.url);
 60944:         nsCOMPtr<mozIStoragePendingStatement> pendingStmt;
 60944:         (void)stmt->ExecuteAsync(this, getter_AddRefs(pendingStmt));
 60944:       }
 60944:     }
 80946:   }
 60944: 
 60944:   NS_IMETHOD HandleResult(mozIStorageResultSet* aResultSet)
 60944:   {
 60944:     nsCOMPtr<mozIStorageRow> row;
 60944:     while (NS_SUCCEEDED(aResultSet->GetNextRow(getter_AddRefs(row))) && row) {
 69683:       // Skip tags, for the use-cases of this async getter they are useless.
108991:       int64_t grandParentId, tagsFolderId;
 69981:       nsresult rv = row->GetInt64(5, &grandParentId);
 69683:       NS_ENSURE_SUCCESS(rv, rv);
 69683:       rv = mBookmarksSvc->GetTagsFolder(&tagsFolderId);
 69683:       NS_ENSURE_SUCCESS(rv, rv);
 69683:       if (grandParentId == tagsFolderId) {
 69683:         continue;
 69683:       }
 69981: 
 69981:       mData.bookmark.grandParentId = grandParentId;
 69981:       rv = row->GetInt64(0, &mData.bookmark.id);
 60944:       NS_ENSURE_SUCCESS(rv, rv);
 69981:       rv = row->GetUTF8String(1, mData.bookmark.guid);
 69981:       NS_ENSURE_SUCCESS(rv, rv);
 69981:       rv = row->GetInt64(2, &mData.bookmark.parentId);
 69981:       NS_ENSURE_SUCCESS(rv, rv);
 69981:       // lastModified (3) should not be set for the use-cases of this getter.
 69981:       rv = row->GetUTF8String(4, mData.bookmark.parentGuid);
 69981:       NS_ENSURE_SUCCESS(rv, rv);
 69981: 
 60944:       if (mCallback) {
 60944:         ((*mBookmarksSvc).*mCallback)(mData);
 60944:       }
 60944:     }
 60944:     return NS_OK;
 60944:   }
 60944: 
 60944: private:
 60944:   nsRefPtr<nsNavBookmarks> mBookmarksSvc;
 60944:   Method mCallback;
 60944:   DataType mData;
 60944: };
 60944: 
 69986: static PLDHashOperator
 69986: ExpireNonrecentBookmarksCallback(BookmarkKeyClass* aKey,
 69986:                                  void* userArg)
 69986: {
108991:   int64_t* threshold = reinterpret_cast<int64_t*>(userArg);
 69986:   if (aKey->creationTime < *threshold) {
 69986:     return PL_DHASH_REMOVE;
 69986:   }
 69986:   return PL_DHASH_NEXT;
 69986: }
 69986: 
 69986: static void
 69986: ExpireNonrecentBookmarks(nsTHashtable<BookmarkKeyClass>* hashTable)
 69986: {
 69986:   if (hashTable->Count() > RECENT_BOOKMARKS_INITIAL_CACHE_SIZE) {
108991:     int64_t threshold = PR_Now() - RECENT_BOOKMARKS_THRESHOLD;
 69986:     (void)hashTable->EnumerateEntries(ExpireNonrecentBookmarksCallback,
 69986:                                       reinterpret_cast<void*>(&threshold));
 69986:   }
 69986: }
 69986: 
 69986: static PLDHashOperator
 69986: ExpireRecentBookmarksByParentCallback(BookmarkKeyClass* aKey,
 69986:                                       void* userArg)
 69986: {
108991:   int64_t* parentId = reinterpret_cast<int64_t*>(userArg);
 69986:   if (aKey->bookmark.parentId == *parentId) {
 69986:     return PL_DHASH_REMOVE;
 69986:   }
 69986:   return PL_DHASH_NEXT;
 69986: }
 69986: 
 69986: static void
 69986: ExpireRecentBookmarksByParent(nsTHashtable<BookmarkKeyClass>* hashTable,
108991:                               int64_t aParentId)
 69986: {
 69986:   (void)hashTable->EnumerateEntries(ExpireRecentBookmarksByParentCallback,
 69986:                                     reinterpret_cast<void*>(&aParentId));
 69986: }
 69986: 
 50437: } // Anonymous namespace.
 50437: 
 50437: 
 33458: nsNavBookmarks::nsNavBookmarks() : mItemCount(0)
 33458:                                  , mRoot(0)
 59312:                                  , mMenuRoot(0)
 59312:                                  , mTagsRoot(0)
 59312:                                  , mUnfiledRoot(0)
 59312:                                  , mToolbarRoot(0)
 33458:                                  , mCanNotify(false)
 33458:                                  , mCacheObservers("bookmark-observers")
 59379:                                  , mBatching(false)
     1: {
 35298:   NS_ASSERTION(!gBookmarksService,
 35298:                "Attempting to create two instances of the service!");
 35298:   gBookmarksService = this;
     1: }
     1: 
 37340: 
     1: nsNavBookmarks::~nsNavBookmarks()
     1: {
 35298:   NS_ASSERTION(gBookmarksService == this,
 35298:                "Deleting a non-singleton instance of the service");
 35298:   if (gBookmarksService == this)
106838:     gBookmarksService = nullptr;
     1: }
     1: 
 37340: 
 80946: NS_IMPL_ISUPPORTS5(nsNavBookmarks
 80946: , nsINavBookmarksService
 80946: , nsINavHistoryObserver
 80946: , nsIAnnotationObserver
 80946: , nsIObserver
 80946: , nsISupportsWeakReference
 80946: )
     1: 
 37340: 
     1: nsresult
     1: nsNavBookmarks::Init()
     1: {
 80946:   mDB = Database::GetDatabase();
 80946:   NS_ENSURE_STATE(mDB);
 59362: 
 69986:   mRecentBookmarksCache.Init(RECENT_BOOKMARKS_INITIAL_CACHE_SIZE);
 87168:   mUncachableBookmarks.Init(RECENT_BOOKMARKS_INITIAL_CACHE_SIZE);
 87168: 
 69986:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
 69986:   if (os) {
 80946:     (void)os->AddObserver(this, TOPIC_PLACES_MAINTENANCE, true);
 80946:     (void)os->AddObserver(this, TOPIC_PLACES_SHUTDOWN, true);
 80946:     (void)os->AddObserver(this, TOPIC_PLACES_CONNECTION_CLOSED, true);
 69986:   }
 69986: 
 84844:   nsresult rv = ReadRoots();
 20874:   NS_ENSURE_SUCCESS(rv, rv);
 20874: 
 30050:   mCanNotify = true;
 30050: 
 37341:   // Observe annotations.
 20874:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 20874:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 20874:   annosvc->AddObserver(this);
 20874: 
 37341:   // Allows us to notify on title changes. MUST BE LAST so it is impossible
 20874:   // to fail after this call, or the history service will have a reference to
 20874:   // us and we won't go away.
 80946:   nsNavHistory* history = nsNavHistory::GetHistoryService();
 80946:   NS_ENSURE_STATE(history);
 80946:   history->AddObserver(this, true);
 20874: 
 20874:   // DO NOT PUT STUFF HERE that can fail. See observer comment above.
 20874: 
 20874:   return NS_OK;
 20874: }
 20874: 
     1: nsresult
 84844: nsNavBookmarks::ReadRoots()
     1: {
 59312:   nsCOMPtr<mozIStorageStatement> stmt;
 80948:   nsresult rv = mDB->MainConn()->CreateStatement(NS_LITERAL_CSTRING(
 59312:     "SELECT root_name, folder_id FROM moz_bookmarks_roots"
 59312:   ), getter_AddRefs(stmt));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 79445:   bool hasResult;
 59312:   while (NS_SUCCEEDED(stmt->ExecuteStep(&hasResult)) && hasResult) {
110974:     nsAutoCString rootName;
 59312:     rv = stmt->GetUTF8String(0, rootName);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
108991:     int64_t rootId;
 59312:     rv = stmt->GetInt64(1, &rootId);
     1:     NS_ENSURE_SUCCESS(rv, rv);
 59312:     NS_ABORT_IF_FALSE(rootId != 0, "Root id is 0, that is an invalid value.");
 59312: 
 59312:     if (rootName.EqualsLiteral("places")) {
 59312:       mRoot = rootId;
  8193:     }
 59312:     else if (rootName.EqualsLiteral("menu")) {
 59312:       mMenuRoot = rootId;
  8193:     }
 59312:     else if (rootName.EqualsLiteral("toolbar")) {
 59312:       mToolbarRoot = rootId;
     1:     }
 59312:     else if (rootName.EqualsLiteral("tags")) {
 59312:       mTagsRoot = rootId;
     1:     }
 59312:     else if (rootName.EqualsLiteral("unfiled")) {
 59312:       mUnfiledRoot = rootId;
 59312:     }
 59312:   }
 59312: 
 84844:   if (!mRoot || !mMenuRoot || !mToolbarRoot || !mTagsRoot || !mUnfiledRoot)
 84844:     return NS_ERROR_FAILURE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // nsNavBookmarks::IsBookmarkedInDatabase
     1: //
 24324: //    This checks to see if the specified place_id is actually bookmarked.
     1: 
     1: nsresult
108991: nsNavBookmarks::IsBookmarkedInDatabase(int64_t aPlaceId,
 79445:                                        bool* aIsBookmarked)
     1: {
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "SELECT 1 FROM moz_bookmarks WHERE fk = :page_id"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), aPlaceId);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341:   rv = stmt->ExecuteStep(aIsBookmarked);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 37340:   return NS_OK;
 37259: }
 37259: 
 37259: 
 37259: nsresult
108991: nsNavBookmarks::AdjustIndices(int64_t aFolderId,
108991:                               int32_t aStartIndex,
108991:                               int32_t aEndIndex,
108991:                               int32_t aDelta)
 37259: {
115367:   NS_ASSERTION(aStartIndex >= 0 && aEndIndex <= INT32_MAX &&
 37340:                aStartIndex <= aEndIndex, "Bad indices");
 37340: 
 69986:   // Expire all cached items for this parent, since all positions are going to
 69986:   // change.
 69986:   ExpireRecentBookmarksByParent(&mRecentBookmarksCache, aFolderId);
 69986: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "UPDATE moz_bookmarks SET position = position + :delta "
 80946:       "WHERE parent = :parent "
 80946:         "AND position BETWEEN :from_index AND :to_index"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:   nsresult rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("delta"), aDelta);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 41402:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("from_index"), aStartIndex);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("to_index"), aEndIndex);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 37340: 
 37340:   rv = stmt->Execute();
 37245:   NS_ENSURE_SUCCESS(rv, rv);
 37259:  
 37245:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetPlacesRoot(int64_t* aRoot)
     1: {
     1:   *aRoot = mRoot;
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetBookmarksMenuFolder(int64_t* aRoot)
     1: {
 59312:   *aRoot = mMenuRoot;
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetToolbarFolder(int64_t* aFolderId)
     1: {
 59312:   *aFolderId = mToolbarRoot;
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetTagsFolder(int64_t* aRoot)
     1: {
 59312:   *aRoot = mTagsRoot;
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetUnfiledBookmarksFolder(int64_t* aRoot)
  5930: {
  5930:   *aRoot = mUnfiledRoot;
  5930:   return NS_OK;
  5930: }
  5930: 
 37340: 
 29518: nsresult
108991: nsNavBookmarks::InsertBookmarkInDB(int64_t aPlaceId,
 29518:                                    enum ItemType aItemType,
108991:                                    int64_t aParentId,
108991:                                    int32_t aIndex,
 29518:                                    const nsACString& aTitle,
 29518:                                    PRTime aDateAdded,
 29518:                                    PRTime aLastModified,
 84189:                                    const nsACString& aParentGuid,
108991:                                    int64_t aGrandParentId,
 84189:                                    nsIURI* aURI,
108991:                                    int64_t* _itemId,
 69981:                                    nsACString& _guid)
 29518: {
 69981:   // Check for a valid itemId.
 69981:   MOZ_ASSERT(_itemId && (*_itemId == -1 || *_itemId > 0));
 69981:   // Check for a valid placeId.
 69981:   MOZ_ASSERT(aPlaceId && (aPlaceId == -1 || aPlaceId > 0));
 29518: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "INSERT INTO moz_bookmarks "
 82903:       "(id, fk, type, parent, position, title, "
 80946:        "dateAdded, lastModified, guid) "
 80946:     "VALUES (:item_id, :page_id, :item_type, :parent, :item_index, "
 82903:             ":item_title, :date_added, :last_modified, "
 80946:             "GENERATE_GUID())"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 69981: 
 29518:   nsresult rv;
 69981:   if (*_itemId != -1)
 69981:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), *_itemId);
 29518:   else
 41402:     rv = stmt->BindNullByName(NS_LITERAL_CSTRING("item_id"));
 29518:   NS_ENSURE_SUCCESS(rv, rv);
 29518: 
 69981:   if (aPlaceId != -1)
 41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), aPlaceId);
 29518:   else
 41402:     rv = stmt->BindNullByName(NS_LITERAL_CSTRING("page_id"));
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
 41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_type"), aItemType);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 41402:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aParentId);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_index"), aIndex);
 29518:   NS_ENSURE_SUCCESS(rv, rv);
 29518: 
 29518:   // Support NULL titles.
 29518:   if (aTitle.IsVoid())
 41402:     rv = stmt->BindNullByName(NS_LITERAL_CSTRING("item_title"));
 29518:   else
 41402:     rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("item_title"), aTitle);
 29518:   NS_ENSURE_SUCCESS(rv, rv);
 29518: 
 41402:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("date_added"), aDateAdded);
 29518:   NS_ENSURE_SUCCESS(rv, rv);
 29518: 
 41402:   if (aLastModified) {
 41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("last_modified"),
 41402:                                aLastModified);
 41402:   }
 41402:   else {
 41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("last_modified"), aDateAdded);
 41402:   }
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
 37341:   rv = stmt->Execute();
 29518:   NS_ENSURE_SUCCESS(rv, rv);
 29518: 
 69981:   if (*_itemId == -1) {
 69981:     // Get the newly inserted item id and GUID.
 80946:     nsCOMPtr<mozIStorageStatement> lastInsertIdStmt = mDB->GetStatement(
 80946:       "SELECT id, guid "
 80946:       "FROM moz_bookmarks "
 80946:       "ORDER BY ROWID DESC "
 80946:       "LIMIT 1"
 80946:     );
 80946:     NS_ENSURE_STATE(lastInsertIdStmt);
 80946:     mozStorageStatementScoper lastInsertIdScoper(lastInsertIdStmt);
 80946: 
 79445:     bool hasResult;
 37341:     rv = lastInsertIdStmt->ExecuteStep(&hasResult);
 29518:     NS_ENSURE_SUCCESS(rv, rv);
 29518:     NS_ENSURE_TRUE(hasResult, NS_ERROR_UNEXPECTED);
 69981:     rv = lastInsertIdStmt->GetInt64(0, _itemId);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 69981:     rv = lastInsertIdStmt->GetUTF8String(1, _guid);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 29518:   }
 69981: 
 69981:   if (aParentId > 0) {
 69981:     // Update last modified date of the ancestors.
 69981:     // TODO (bug 408991): Doing this for all ancestors would be slow without a
 69981:     //                    nested tree, so for now update only the parent.
 80946:     rv = SetItemDateInternal(LAST_MODIFIED, aParentId, aDateAdded);
 29518:     NS_ENSURE_SUCCESS(rv, rv);
 69981:   }
 29518: 
 84189:   // Add a cache entry since we know everything about this bookmark.
 84189:   BookmarkData bookmark;
 84189:   bookmark.id = *_itemId;
 84189:   bookmark.guid.Assign(_guid);
 84189:   if (aTitle.IsVoid()) {
 84189:     bookmark.title.SetIsVoid(true);
 84189:   }
 84189:   else {
 84189:     bookmark.title.Assign(aTitle);
 84189:   }
 84189:   bookmark.position = aIndex;
 84189:   bookmark.placeId = aPlaceId;
 84189:   bookmark.parentId = aParentId;
 84189:   bookmark.type = aItemType;
 84189:   bookmark.dateAdded = aDateAdded;
 84189:   if (aLastModified)
 84189:     bookmark.lastModified = aLastModified;
 84189:   else
 84189:     bookmark.lastModified = aDateAdded;
 84189:   if (aURI) {
 84189:     rv = aURI->GetSpec(bookmark.url);
 84189:     NS_ENSURE_SUCCESS(rv, rv);
 84189:   }
 84189:   bookmark.parentGuid = aParentGuid;
 84189:   bookmark.grandParentId = aGrandParentId;
 84189: 
 87168:   ADD_TO_BOOKMARK_CACHE(*_itemId, bookmark);
 84189: 
 29518:   return NS_OK;
 29518: }
 29518: 
 37340: 
  5930: NS_IMETHODIMP
108991: nsNavBookmarks::InsertBookmark(int64_t aFolder,
 29123:                                nsIURI* aURI,
108991:                                int32_t aIndex,
 10046:                                const nsACString& aTitle,
108991:                                int64_t* aNewBookmarkId)
     1: {
 29123:   NS_ENSURE_ARG(aURI);
 29123:   NS_ENSURE_ARG_POINTER(aNewBookmarkId);
 69981:   NS_ENSURE_ARG_MIN(aIndex, nsINavBookmarksService::DEFAULT_INDEX);
     1: 
 80946:   mozStorageTransaction transaction(mDB->MainConn(), false);
     1: 
 35298:   nsNavHistory* history = nsNavHistory::GetHistoryService();
 35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
108991:   int64_t placeId;
110974:   nsAutoCString placeGuid;
 72845:   nsresult rv = history->GetOrCreateIdForPage(aURI, &placeId, placeGuid);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 69981:   // Get the correct index for insertion.  This also ensures the parent exists.
108991:   int32_t index, folderCount;
108991:   int64_t grandParentId;
110974:   nsAutoCString folderGuid;
 69981:   rv = FetchFolderInfo(aFolder, &folderCount, folderGuid, &grandParentId);
 31729:   NS_ENSURE_SUCCESS(rv, rv);
 31729:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
 31729:       aIndex >= folderCount) {
 31729:     index = folderCount;
 31729:   }
 31729:   else {
  8275:     index = aIndex;
 69981:     // Create space for the insertion.
115367:     rv = AdjustIndices(aFolder, index, INT32_MAX, 1);
     1:     NS_ENSURE_SUCCESS(rv, rv);
  8275:   }
     1: 
 69981:   *aNewBookmarkId = -1;
 69981:   PRTime dateAdded = PR_Now();
110974:   nsAutoCString guid;
 81038:   nsCString title;
 81038:   TruncateTitle(aTitle, title);
 81038: 
 82903:   rv = InsertBookmarkInDB(placeId, BOOKMARK, aFolder, index, title, dateAdded,
106118:                           0, folderGuid, grandParentId, aURI,
 84189:                           aNewBookmarkId, guid);
  1738:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 84188:   // If not a tag, recalculate frecency for this entry, since it changed.
 84188:   if (grandParentId != mTagsRoot) {
 69981:     rv = history->UpdateFrecency(placeId);
 10669:     NS_ENSURE_SUCCESS(rv, rv);
 84188:   }
 10669: 
     1:   rv = transaction.Commit();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 56524:                    OnItemAdded(*aNewBookmarkId, aFolder, index, TYPE_BOOKMARK,
 81038:                                aURI, title, dateAdded, guid, folderGuid));
     1: 
  9553:   // If the bookmark has been added to a tag container, notify all
  9553:   // bookmark-folder result nodes which contain a bookmark for the new
 69981:   // bookmark's url.
 69981:   if (grandParentId == mTagsRoot) {
 69981:     // Notify a tags change to all bookmarks for this URI.
 69981:     nsTArray<BookmarkData> bookmarks;
 69981:     rv = GetBookmarksForURI(aURI, bookmarks);
  9553:     NS_ENSURE_SUCCESS(rv, rv);
 69981: 
108991:     for (uint32_t i = 0; i < bookmarks.Length(); ++i) {
 69981:       // Check that bookmarks doesn't include the current tag itemId.
 69981:       MOZ_ASSERT(bookmarks[i].id != *aNewBookmarkId);
 61371: 
 37343:       NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                        nsINavBookmarkObserver,
 69981:                        OnItemChanged(bookmarks[i].id,
 69981:                                      NS_LITERAL_CSTRING("tags"),
 80486:                                      false,
 69981:                                      EmptyCString(),
 69981:                                      bookmarks[i].lastModified,
 69981:                                      TYPE_BOOKMARK,
 69981:                                      bookmarks[i].parentId,
 69981:                                      bookmarks[i].guid,
 69981:                                      bookmarks[i].parentGuid));
  9553:     }
  9553:   }
 69981: 
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::RemoveItem(int64_t aItemId)
     1: {
 87692:   SAMPLE_LABEL("bookmarks", "RemoveItem");
126144:   NS_ENSURE_ARG(!IsRoot(aItemId));
 69981: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 69981:                    OnBeforeItemRemoved(bookmark.id,
 69981:                                        bookmark.type,
 69981:                                        bookmark.parentId,
 69981:                                        bookmark.guid,
 69981:                                        bookmark.parentGuid));
 26383: 
 80946:   mozStorageTransaction transaction(mDB->MainConn(), false);
 14272: 
 84189:   // First, if not a tag, remove item annotations.
 84189:   if (bookmark.parentId != mTagsRoot &&
 84189:       bookmark.grandParentId != mTagsRoot) {
 14272:     nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 14272:     NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 69981:     rv = annosvc->RemoveItemAnnotations(bookmark.id);
 14272:     NS_ENSURE_SUCCESS(rv, rv);
 84189:   }
 14272: 
 69981:   if (bookmark.type == TYPE_FOLDER) {
 69981:     // Remove all of the folder's children.
 69981:     rv = RemoveFolderChildren(bookmark.id);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 69981:   }
 69981: 
 76962:   BEGIN_CRITICAL_BOOKMARK_CACHE_SECTION(bookmark.id);
 76962: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "DELETE FROM moz_bookmarks WHERE id = :item_id"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 69981:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), bookmark.id);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 37340:   rv = stmt->Execute();
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 69981: 
 69981:   // Fix indices in the parent.
 69981:   if (bookmark.position != DEFAULT_INDEX) {
 69981:     rv = AdjustIndices(bookmark.parentId,
115367:                        bookmark.position + 1, INT32_MAX, -1);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
 69981:   bookmark.lastModified = PR_Now();
 80946:   rv = SetItemDateInternal(LAST_MODIFIED, bookmark.parentId,
 80946:                            bookmark.lastModified);
  3360:   NS_ENSURE_SUCCESS(rv, rv);
  3360: 
     1:   rv = transaction.Commit();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 76962:   END_CRITICAL_BOOKMARK_CACHE_SECTION(bookmark.id);
 76962: 
 69981:   nsCOMPtr<nsIURI> uri;
 69981:   if (bookmark.type == TYPE_BOOKMARK) {
 84188:     // If not a tag, recalculate frecency for this entry, since it changed.
 84188:     if (bookmark.grandParentId != mTagsRoot) {
 35298:       nsNavHistory* history = nsNavHistory::GetHistoryService();
 35298:       NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
 69981:       rv = history->UpdateFrecency(bookmark.placeId);
 10669:       NS_ENSURE_SUCCESS(rv, rv);
 84188:     }
 50437: 
 50437:     rv = UpdateKeywordsHashForRemovedBookmark(aItemId);
 50437:     NS_ENSURE_SUCCESS(rv, rv);
 69981: 
 69981:     // A broken url should not interrupt the removal process.
 69981:     (void)NS_NewURI(getter_AddRefs(uri), bookmark.url);
 61371:   }
 61371: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 69981:                    OnItemRemoved(bookmark.id,
 69981:                                  bookmark.parentId,
 69981:                                  bookmark.position,
 69981:                                  bookmark.type,
 69981:                                  uri,
 69981:                                  bookmark.guid,
 69981:                                  bookmark.parentGuid));
 69981: 
 69981:   if (bookmark.type == TYPE_BOOKMARK && bookmark.grandParentId == mTagsRoot &&
 69981:       uri) {
 69981:     // If the removed bookmark was child of a tag container, notify a tags
 69981:     // change to all bookmarks for this URI.
 69981:     nsTArray<BookmarkData> bookmarks;
 69981:     rv = GetBookmarksForURI(uri, bookmarks);
  9553:     NS_ENSURE_SUCCESS(rv, rv);
 69981: 
108991:     for (uint32_t i = 0; i < bookmarks.Length(); ++i) {
 37343:       NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                        nsINavBookmarkObserver,
 69981:                        OnItemChanged(bookmarks[i].id,
 69981:                                      NS_LITERAL_CSTRING("tags"),
 80486:                                      false,
 69981:                                      EmptyCString(),
 69981:                                      bookmarks[i].lastModified,
 69981:                                      TYPE_BOOKMARK,
 69981:                                      bookmarks[i].parentId,
 69981:                                      bookmarks[i].guid,
 69981:                                      bookmarks[i].parentGuid));
  9553:     }
 69981: 
  9553:   }
 61371: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::CreateFolder(int64_t aParent, const nsACString& aName,
108991:                              int32_t aIndex, int64_t* aNewFolder)
     1: {
 29123:   // NOTE: aParent can be null for root creation, so not checked
 29123:   NS_ENSURE_ARG_POINTER(aNewFolder);
 29123: 
  4179:   // CreateContainerWithID returns the index of the new folder, but that's not
     1:   // used here.  To avoid any risk of corrupting data should this function
 80486:   // be changed, we'll use a local variable to hold it.  The true argument
     1:   // will cause notifications to be sent to bookmark observers.
108991:   int32_t localIndex = aIndex;
 82903:   nsresult rv = CreateContainerWithID(-1, aParent, aName, true, &localIndex,
 82903:                                       aNewFolder);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 37340:   return NS_OK;
     1: }
     1: 
  4179: NS_IMETHODIMP
108991: nsNavBookmarks::GetFolderReadonly(int64_t aFolder, bool* aResult)
  4179: {
 29123:   NS_ENSURE_ARG_MIN(aFolder, 1);
 29123:   NS_ENSURE_ARG_POINTER(aResult);
 29123: 
  4179:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
  4179:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 37340:   nsresult rv = annosvc->ItemHasAnnotation(aFolder, READ_ONLY_ANNO, aResult);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 37340:   return NS_OK;
  4179: }
  4179: 
 37340: 
  4179: NS_IMETHODIMP
108991: nsNavBookmarks::SetFolderReadonly(int64_t aFolder, bool aReadOnly)
  4179: {
 29123:   NS_ENSURE_ARG_MIN(aFolder, 1);
 29123: 
  4179:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
  4179:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 37340:   nsresult rv;
  4179:   if (aReadOnly) {
 37340:     rv = annosvc->SetItemAnnotationInt32(aFolder, READ_ONLY_ANNO, 1, 0,
  4179:                                          nsAnnotationService::EXPIRE_NEVER);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
  4179:   }
  4179:   else {
 79445:     bool hasAnno;
 37340:     rv = annosvc->ItemHasAnnotation(aFolder, READ_ONLY_ANNO, &hasAnno);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 37340:     if (hasAnno) {
 37340:       rv = annosvc->RemoveItemAnnotation(aFolder, READ_ONLY_ANNO);
 37340:       NS_ENSURE_SUCCESS(rv, rv);
 37340:     }
  4179:   }
  4179:   return NS_OK;
  4179: }
  4179: 
 37340: 
     1: nsresult
108991: nsNavBookmarks::CreateContainerWithID(int64_t aItemId,
108991:                                       int64_t aParent,
 69981:                                       const nsACString& aTitle,
 79445:                                       bool aIsBookmarkFolder,
108991:                                       int32_t* aIndex,
108991:                                       int64_t* aNewFolder)
     1: {
 69981:   NS_ENSURE_ARG_MIN(*aIndex, nsINavBookmarksService::DEFAULT_INDEX);
 69981: 
 69981:   // Get the correct index for insertion.  This also ensures the parent exists.
108991:   int32_t index, folderCount;
108991:   int64_t grandParentId;
110974:   nsAutoCString folderGuid;
 69981:   nsresult rv = FetchFolderInfo(aParent, &folderCount, folderGuid, &grandParentId);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 80946:   mozStorageTransaction transaction(mDB->MainConn(), false);
     1: 
 31729:   if (*aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
 31729:       *aIndex >= folderCount) {
 31729:     index = folderCount;
  8275:   } else {
  8275:     index = *aIndex;
 69981:     // Create space for the insertion.
115367:     rv = AdjustIndices(aParent, index, INT32_MAX, 1);
     1:     NS_ENSURE_SUCCESS(rv, rv);
  8275:   }
     1: 
 69981:   *aNewFolder = aItemId;
 69981:   PRTime dateAdded = PR_Now();
110974:   nsAutoCString guid;
 81038:   nsCString title;
 81038:   TruncateTitle(aTitle, title);
 81038: 
 82903:   rv = InsertBookmarkInDB(-1, FOLDER, aParent, index,
106118:                           title, dateAdded, 0, folderGuid, grandParentId,
106838:                           nullptr, aNewFolder, guid);
  3360:   NS_ENSURE_SUCCESS(rv, rv);
  3360: 
     1:   rv = transaction.Commit();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 82903:                    OnItemAdded(*aNewFolder, aParent, index, FOLDER,
106838:                                nullptr, title, dateAdded, guid, folderGuid));
     1: 
     1:   *aIndex = index;
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::InsertSeparator(int64_t aParent,
108991:                                 int32_t aIndex,
108991:                                 int64_t* aNewItemId)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aParent, 1);
 69981:   NS_ENSURE_ARG_MIN(aIndex, nsINavBookmarksService::DEFAULT_INDEX);
 29123:   NS_ENSURE_ARG_POINTER(aNewItemId);
 29123: 
 69981:   // Get the correct index for insertion.  This also ensures the parent exists.
108991:   int32_t index, folderCount;
108991:   int64_t grandParentId;
110974:   nsAutoCString folderGuid;
 69981:   nsresult rv = FetchFolderInfo(aParent, &folderCount, folderGuid, &grandParentId);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 69981: 
 80946:   mozStorageTransaction transaction(mDB->MainConn(), false);
     1: 
 31729:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
 31729:       aIndex >= folderCount) {
 31729:     index = folderCount;
 34632:   }
 34632:   else {
  8275:     index = aIndex;
 69981:     // Create space for the insertion.
115367:     rv = AdjustIndices(aParent, index, INT32_MAX, 1);
     1:     NS_ENSURE_SUCCESS(rv, rv);
  8275:   }
     1: 
 69981:   *aNewItemId = -1;
 69981:   // Set a NULL title rather than an empty string.
 29518:   nsCString voidString;
 80486:   voidString.SetIsVoid(true);
110974:   nsAutoCString guid;
 69981:   PRTime dateAdded = PR_Now();
 69981:   rv = InsertBookmarkInDB(-1, SEPARATOR, aParent, index, voidString, dateAdded,
106838:                           0, folderGuid, grandParentId, nullptr,
 84189:                           aNewItemId, guid);
  3360:   NS_ENSURE_SUCCESS(rv, rv);
  3360: 
     1:   rv = transaction.Commit();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 56524:                    OnItemAdded(*aNewItemId, aParent, index, TYPE_SEPARATOR,
106838:                                nullptr, voidString, dateAdded, guid, folderGuid));
     1: 
     1:   return NS_OK;
     1: }
     1: 
 37340: 
 11268: nsresult
108991: nsNavBookmarks::GetLastChildId(int64_t aFolderId, int64_t* aItemId)
 11268: {
 37340:   NS_ASSERTION(aFolderId > 0, "Invalid folder id");
 34632:   *aItemId = -1;
 34632: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "SELECT id FROM moz_bookmarks WHERE parent = :parent "
 80946:     "ORDER BY position DESC LIMIT 1"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 79445:   bool found;
 37340:   rv = stmt->ExecuteStep(&found);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 37340:   if (found) {
 37340:     rv = stmt->GetInt64(0, aItemId);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 37340:   }
 24787: 
 11268:   return NS_OK;
 11268: }
 11268: 
 37340: 
 11268: NS_IMETHODIMP
108991: nsNavBookmarks::GetIdForItemAt(int64_t aFolder,
108991:                                int32_t aIndex,
108991:                                int64_t* aItemId)
 11268: {
 29123:   NS_ENSURE_ARG_MIN(aFolder, 1);
 29123:   NS_ENSURE_ARG_POINTER(aItemId);
 29123: 
 34632:   *aItemId = -1;
 34632: 
 11268:   nsresult rv;
 11268:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX) {
 34632:     // Get last item within aFolder.
 24787:     rv = GetLastChildId(aFolder, aItemId);
 24787:     NS_ENSURE_SUCCESS(rv, rv);
 34632:   }
 34632:   else {
 34632:     // Get the item in aFolder with position aIndex.
 80946:     nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:       "SELECT id, fk, type FROM moz_bookmarks "
 80946:       "WHERE parent = :parent AND position = :item_index"
 80946:     );
 80946:     NS_ENSURE_STATE(stmt);
 80946:     mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolder);
 37341:     NS_ENSURE_SUCCESS(rv, rv);
 41402:     rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_index"), aIndex);
 11268:     NS_ENSURE_SUCCESS(rv, rv);
 11268: 
 79445:     bool found;
 37341:     rv = stmt->ExecuteStep(&found);
 11268:     NS_ENSURE_SUCCESS(rv, rv);
 37340:     if (found) {
 37341:       rv = stmt->GetInt64(0, aItemId);
 37340:       NS_ENSURE_SUCCESS(rv, rv);
 37340:     }
 11268:   }
 11268:   return NS_OK;
 11268: }
 11268: 
     1: NS_IMPL_ISUPPORTS1(nsNavBookmarks::RemoveFolderTransaction, nsITransaction)
     1: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetRemoveFolderTransaction(int64_t aFolderId, nsITransaction** aResult)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aFolderId, 1);
 29123:   NS_ENSURE_ARG_POINTER(aResult);
 29123: 
     1:   // Create and initialize a RemoveFolderTransaction object that can be used to
     1:   // recreate the folder safely later. 
     1: 
     1:   RemoveFolderTransaction* rft = 
 29123:     new RemoveFolderTransaction(aFolderId);
     1:   if (!rft)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   NS_ADDREF(*aResult = rft);
     1:   return NS_OK;
     1: }
     1: 
 37340: 
 21350: nsresult
108991: nsNavBookmarks::GetDescendantFolders(int64_t aFolderId,
108991:                                      nsTArray<int64_t>& aDescendantFoldersArray) {
 90949:   nsresult rv;
 90949:   // New descendant folders will be added from this index on.
108991:   uint32_t startIndex = aDescendantFoldersArray.Length();
 90949:   {
 90949:     nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 90949:       "SELECT id "
 90949:       "FROM moz_bookmarks "
 90949:       "WHERE parent = :parent "
 90949:       "AND type = :item_type "
 90949:     );
 90949:     NS_ENSURE_STATE(stmt);
 90949:     mozStorageStatementScoper scoper(stmt);
 90949: 
 90949:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
 90949:     NS_ENSURE_SUCCESS(rv, rv);
 90949:     rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_type"), TYPE_FOLDER);
 90949:     NS_ENSURE_SUCCESS(rv, rv);
 90949: 
 90949:     bool hasMore = false;
 90949:     while (NS_SUCCEEDED(stmt->ExecuteStep(&hasMore)) && hasMore) {
108991:       int64_t itemId;
 90949:       rv = stmt->GetInt64(0, &itemId);
 90949:       NS_ENSURE_SUCCESS(rv, rv);
 90949:       aDescendantFoldersArray.AppendElement(itemId);
 90949:     }
 90949:   }
 90949: 
 90949:   // Recursively call GetDescendantFolders for added folders.
 90949:   // We start at startIndex since previous folders are checked
 90949:   // by previous calls to this method.
108991:   uint32_t childCount = aDescendantFoldersArray.Length();
108991:   for (uint32_t i = startIndex; i < childCount; ++i) {
 90949:     GetDescendantFolders(aDescendantFoldersArray[i], aDescendantFoldersArray);
 90949:   }
 90949: 
 90949:   return NS_OK;
 90949: }
 90949: 
 90949: 
 90949: nsresult
108991: nsNavBookmarks::GetDescendantChildren(int64_t aFolderId,
 69981:                                       const nsACString& aFolderGuid,
108991:                                       int64_t aGrandParentId,
 69981:                                       nsTArray<BookmarkData>& aFolderChildrenArray) {
 21350:   // New children will be added from this index on.
108991:   uint32_t startIndex = aFolderChildrenArray.Length();
     1:   nsresult rv;
     1:   {
 21350:     // Collect children informations.
 80946:     // Select all children of a given folder, sorted by position.
 80946:     // This is a LEFT JOIN because not all bookmarks types have a place.
 80946:     // We construct a result where the first columns exactly match
 80946:     // kGetInfoIndex_* order, and additionally contains columns for position,
 80946:     // item_child, and folder_child from moz_bookmarks.
 80946:     nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:       "SELECT h.id, h.url, IFNULL(b.title, h.title), h.rev_host, h.visit_count, "
 80946:              "h.last_visit_date, f.url, null, b.id, b.dateAdded, b.lastModified, "
 82903:              "b.parent, null, h.frecency, b.position, b.type, b.fk, b.guid "
 80946:       "FROM moz_bookmarks b "
 80946:       "LEFT JOIN moz_places h ON b.fk = h.id "
 80946:       "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
 80946:       "WHERE b.parent = :parent "
 80946:       "ORDER BY b.position ASC"
 80946:     );
 80946:     NS_ENSURE_STATE(stmt);
 80946:     mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
 79445:     bool hasMore;
 37341:     while (NS_SUCCEEDED(stmt->ExecuteStep(&hasMore)) && hasMore) {
 69981:       BookmarkData child;
 69981:       rv = stmt->GetInt64(nsNavHistory::kGetInfoIndex_ItemId, &child.id);
 37340:       NS_ENSURE_SUCCESS(rv, rv);
 21350:       child.parentId = aFolderId;
 21350:       child.grandParentId = aGrandParentId;
 69981:       child.parentGuid = aFolderGuid;
 69981:       rv = stmt->GetInt32(kGetChildrenIndex_Type, &child.type);
 37340:       NS_ENSURE_SUCCESS(rv, rv);
 37341:       rv = stmt->GetInt64(kGetChildrenIndex_PlaceID, &child.placeId);
 37341:       NS_ENSURE_SUCCESS(rv, rv);
 69981:       rv = stmt->GetInt32(kGetChildrenIndex_Position, &child.position);
 37340:       NS_ENSURE_SUCCESS(rv, rv);
 69981:       rv = stmt->GetUTF8String(kGetChildrenIndex_Guid, child.guid);
 21350:       NS_ENSURE_SUCCESS(rv, rv);
 69981: 
 69981:       if (child.type == TYPE_BOOKMARK) {
 69981:         rv = stmt->GetUTF8String(nsNavHistory::kGetInfoIndex_URL, child.url);
 69981:         NS_ENSURE_SUCCESS(rv, rv);
     1:       }
 82903: 
 21350:       // Append item to children's array.
 21350:       aFolderChildrenArray.AppendElement(child);
     1:     }
 21350:   }
 21350: 
 21350:   // Recursively call GetDescendantChildren for added folders.
 21350:   // We start at startIndex since previous folders are checked
 21350:   // by previous calls to this method.
108991:   uint32_t childCount = aFolderChildrenArray.Length();
108991:   for (uint32_t i = startIndex; i < childCount; ++i) {
 69981:     if (aFolderChildrenArray[i].type == TYPE_FOLDER) {
 69984:       // nsTarray assumes that all children can be memmove()d, thus we can't
 69984:       // just pass aFolderChildrenArray[i].guid to a method that will change
 69984:       // the array itself.  Otherwise, since it's passed by reference, after a
 69984:       // memmove() it could point to garbage and cause intermittent crashes.
 69984:       nsCString guid = aFolderChildrenArray[i].guid;
 69981:       GetDescendantChildren(aFolderChildrenArray[i].id,
 69984:                             guid,
 21350:                             aFolderId,
 21350:                             aFolderChildrenArray);
 21350:     }
 21350:   }
 21350: 
 21350:   return NS_OK;
 21350: }
 21350: 
 37340: 
 21350: NS_IMETHODIMP
108991: nsNavBookmarks::RemoveFolderChildren(int64_t aFolderId)
 21350: {
 87692:   SAMPLE_LABEL("bookmarks", "RemoveFolderChilder");
 37340:   NS_ENSURE_ARG_MIN(aFolderId, 1);
126144:   NS_ENSURE_ARG(aFolderId != mRoot);
 37340: 
 69981:   BookmarkData folder;
 76962:   nsresult rv = FetchItemInfo(aFolderId, folder);
 21350:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   NS_ENSURE_ARG(folder.type == TYPE_FOLDER);
 21350: 
 21350:   // Fill folder children array recursively.
 69981:   nsTArray<BookmarkData> folderChildrenArray;
 69981:   rv = GetDescendantChildren(folder.id, folder.guid, folder.parentId,
 69981:                              folderChildrenArray);
 21350:   NS_ENSURE_SUCCESS(rv, rv);
 21350: 
 21350:   // Build a string of folders whose children will be removed.
 21350:   nsCString foldersToRemove;
108991:   for (uint32_t i = 0; i < folderChildrenArray.Length(); ++i) {
 69981:     BookmarkData& child = folderChildrenArray[i];
 26383: 
 26383:     // Notify observers that we are about to remove this child.
 37343:     NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                      nsINavBookmarkObserver,
 69981:                      OnBeforeItemRemoved(child.id,
 69981:                                          child.type,
 69981:                                          child.parentId,
 69981:                                          child.guid,
 69981:                                          child.parentGuid));
 69981: 
 69981:     if (child.type == TYPE_FOLDER) {
 21350:       foldersToRemove.AppendLiteral(",");
 69981:       foldersToRemove.AppendInt(child.id);
 21350:     }
 76962: 
 76962:     BEGIN_CRITICAL_BOOKMARK_CACHE_SECTION(child.id);
 21350:   }
 21350: 
 21350:   // Delete items from the database now.
 80946:   mozStorageTransaction transaction(mDB->MainConn(), false);
 80946: 
 80946:   nsCOMPtr<mozIStorageStatement> deleteStatement = mDB->GetStatement(
 80946:     NS_LITERAL_CSTRING(
 21350:       "DELETE FROM moz_bookmarks "
 80946:       "WHERE parent IN (:parent") + foldersToRemove + NS_LITERAL_CSTRING(")")
 80946:   );
 80946:   NS_ENSURE_STATE(deleteStatement);
 80946:   mozStorageStatementScoper deleteStatementScoper(deleteStatement);
 80946: 
 69981:   rv = deleteStatement->BindInt64ByName(NS_LITERAL_CSTRING("parent"), folder.id);
 24948:   NS_ENSURE_SUCCESS(rv, rv);
 24948:   rv = deleteStatement->Execute();
 21350:   NS_ENSURE_SUCCESS(rv, rv);
 21350: 
 21350:   // Clean up orphan items annotations.
 80946:   rv = mDB->MainConn()->ExecuteSimpleSQL(
 21350:     NS_LITERAL_CSTRING(
 21350:       "DELETE FROM moz_items_annos "
 21350:       "WHERE id IN ("
 21350:         "SELECT a.id from moz_items_annos a "
 21350:         "LEFT JOIN moz_bookmarks b ON a.item_id = b.id "
 21350:         "WHERE b.id ISNULL)"));
 21350:   NS_ENSURE_SUCCESS(rv, rv);
 21350: 
 21350:   // Set the lastModified date.
 80946:   rv = SetItemDateInternal(LAST_MODIFIED, folder.id, PR_Now());
 21350:   NS_ENSURE_SUCCESS(rv, rv);
 21350: 
108991:   for (uint32_t i = 0; i < folderChildrenArray.Length(); i++) {
 69981:     BookmarkData& child = folderChildrenArray[i];
 69981:     if (child.type == TYPE_BOOKMARK) {
 84188:       // If not a tag, recalculate frecency for this entry, since it changed.
 84188:       if (child.grandParentId != mTagsRoot) {
 35298:         nsNavHistory* history = nsNavHistory::GetHistoryService();
 35298:         NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
 69981:         rv = history->UpdateFrecency(child.placeId);
     1:         NS_ENSURE_SUCCESS(rv, rv);
 84188:       }
 50437: 
 69981:       rv = UpdateKeywordsHashForRemovedBookmark(child.id);
 50437:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
 76962:     END_CRITICAL_BOOKMARK_CACHE_SECTION(child.id);
 21350:   }
 21350: 
 21350:   rv = transaction.Commit();
     1:   NS_ENSURE_SUCCESS(rv, rv);
 21350: 
 21350:   // Call observers in reverse order to serve children before their parent.
108991:   for (int32_t i = folderChildrenArray.Length() - 1; i >= 0; --i) {
 69981:     BookmarkData& child = folderChildrenArray[i];
 69981:     nsCOMPtr<nsIURI> uri;
 69981:     if (child.type == TYPE_BOOKMARK) {
 69981:       // A broken url should not interrupt the removal process.
 69981:       (void)NS_NewURI(getter_AddRefs(uri), child.url);
 69981:     }
 21350: 
 37343:     NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                      nsINavBookmarkObserver,
 69981:                      OnItemRemoved(child.id,
 69981:                                    child.parentId,
 69981:                                    child.position,
 69981:                                    child.type,
 69981:                                    uri,
 69981:                                    child.guid,
 69981:                                    child.parentGuid));
 69981: 
 69981:     if (child.type == TYPE_BOOKMARK && child.grandParentId == mTagsRoot &&
 69981:         uri) {
 21350:       // If the removed bookmark was a child of a tag container, notify all
 21350:       // bookmark-folder result nodes which contain a bookmark for the removed
 21350:       // bookmark's url.
 69981:       nsTArray<BookmarkData> bookmarks;
 69981:       rv = GetBookmarksForURI(uri, bookmarks);
 21350:       NS_ENSURE_SUCCESS(rv, rv);
 21350: 
108991:       for (uint32_t i = 0; i < bookmarks.Length(); ++i) {
 37343:         NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                          nsINavBookmarkObserver,
 69981:                          OnItemChanged(bookmarks[i].id,
 69981:                                        NS_LITERAL_CSTRING("tags"),
 80486:                                        false,
 69981:                                        EmptyCString(),
 69981:                                        bookmarks[i].lastModified,
 69981:                                        TYPE_BOOKMARK,
 69981:                                        bookmarks[i].parentId,
 69981:                                        bookmarks[i].guid,
 69981:                                        bookmarks[i].parentGuid));
 21350:       }
 21350:     }
 21350:   }
 21350: 
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::MoveItem(int64_t aItemId, int64_t aNewParent, int32_t aIndex)
     1: {
126144:   NS_ENSURE_ARG(!IsRoot(aItemId));
 37340:   NS_ENSURE_ARG_MIN(aItemId, 1);
 37340:   NS_ENSURE_ARG_MIN(aNewParent, 1);
 37340:   // -1 is append, but no other negative number is allowed.
 37340:   NS_ENSURE_ARG_MIN(aIndex, -1);
  7122:   // Disallow making an item its own parent.
126144:   NS_ENSURE_ARG(aItemId != aNewParent);
  1297: 
 80946:   mozStorageTransaction transaction(mDB->MainConn(), false);
     1: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
  1297:   // if parent and index are the same, nothing to do
 69981:   if (bookmark.parentId == aNewParent && bookmark.position == aIndex)
  1297:     return NS_OK;
  1297: 
 69981:   // Make sure aNewParent is not aFolder or a subfolder of aFolder.
 69981:   // TODO: make this performant, maybe with a nested tree (bug 408991).
 69981:   if (bookmark.type == TYPE_FOLDER) {
108991:     int64_t ancestorId = aNewParent;
 37340: 
 37340:     while (ancestorId) {
 69981:       if (ancestorId == bookmark.id) {
     1:         return NS_ERROR_INVALID_ARG;
     1:       }
 69981:       rv = GetFolderIdForItem(ancestorId, &ancestorId);
 69981:       if (NS_FAILED(rv)) {
 37340:         break;
 37340:       }
     1:     }
     1:   }
     1: 
  1297:   // calculate new index
108991:   int32_t newIndex, folderCount;
108991:   int64_t grandParentId;
110974:   nsAutoCString newParentGuid;
 69981:   rv = FetchFolderInfo(aNewParent, &folderCount, newParentGuid, &grandParentId);
 31729:   NS_ENSURE_SUCCESS(rv, rv);
 31729:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
 31729:       aIndex >= folderCount) {
 31729:     newIndex = folderCount;
     1:     // If the parent remains the same, then the folder is really being moved
     1:     // to count - 1 (since it's being removed from the old position)
 69981:     if (bookmark.parentId == aNewParent) {
     1:       --newIndex;
     1:     }
     1:   } else {
     1:     newIndex = aIndex;
     1: 
 69981:     if (bookmark.parentId == aNewParent && newIndex > bookmark.position) {
     1:       // when an item is being moved lower in the same folder, the new index
     1:       // refers to the index before it was removed. Removal causes everything
     1:       // to shift up.
     1:       --newIndex;
     1:     }
     1:   }
     1: 
  1297:   // this is like the previous check, except this covers if
  1297:   // the specified index was -1 (append), and the calculated
  1297:   // new index is the same as the existing index
 69981:   if (aNewParent == bookmark.parentId && newIndex == bookmark.position) {
     1:     // Nothing to do!
     1:     return NS_OK;
     1:   }
     1: 
  1297:   // adjust indices to account for the move
  2019:   // do this before we update the parent/index fields
  2019:   // or we'll re-adjust the index for the item we are moving
 69981:   if (bookmark.parentId == aNewParent) {
     1:     // We can optimize the updates if moving within the same container.
     1:     // We only shift the items between the old and new positions, since the
     1:     // insertion will offset the deletion.
 69981:     if (bookmark.position > newIndex) {
 69981:       rv = AdjustIndices(bookmark.parentId, newIndex, bookmark.position - 1, 1);
 37340:     }
 37340:     else {
 69981:       rv = AdjustIndices(bookmark.parentId, bookmark.position + 1, newIndex, -1);
     1:     }
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 37340:   }
 37340:   else {
     1:     // We're moving between containers, so this happens in two steps.
  1297:     // First, fill the hole from the removal from the old parent.
115367:     rv = AdjustIndices(bookmark.parentId, bookmark.position + 1, INT32_MAX, -1);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     // Now, make room in the new parent for the insertion.
115367:     rv = AdjustIndices(aNewParent, newIndex, INT32_MAX, 1);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 37259:   }
 37340: 
 76962:   BEGIN_CRITICAL_BOOKMARK_CACHE_SECTION(bookmark.id);
 76962: 
 37340:   {
 37340:     // Update parent and position.
 80946:     nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:       "UPDATE moz_bookmarks SET parent = :parent, position = :item_index "
 80946:       "WHERE id = :item_id "
 80946:     );
 80946:     NS_ENSURE_STATE(stmt);
 80946:     mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aNewParent);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 41402:     rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_index"), newIndex);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 69981:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), bookmark.id);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 37340:     rv = stmt->Execute();
 37340:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
  2019: 
  3360:   PRTime now = PR_Now();
 80946:   rv = SetItemDateInternal(LAST_MODIFIED, bookmark.parentId, now);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 80946:   rv = SetItemDateInternal(LAST_MODIFIED, aNewParent, now);
  3360:   NS_ENSURE_SUCCESS(rv, rv);
  3360: 
     1:   rv = transaction.Commit();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 76962:   END_CRITICAL_BOOKMARK_CACHE_SECTION(bookmark.id);
 76962: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 69981:                    OnItemMoved(bookmark.id,
 69981:                                bookmark.parentId,
 69981:                                bookmark.position,
 69981:                                aNewParent,
 69981:                                newIndex,
 69981:                                bookmark.type,
 69981:                                bookmark.guid,
 69981:                                bookmark.parentGuid,
 69981:                                newParentGuid));
     1:   return NS_OK;
     1: }
     1: 
 69981: nsresult
108991: nsNavBookmarks::FetchItemInfo(int64_t aItemId,
 76962:                               BookmarkData& _bookmark)
 69981: {
 69986:   // Check if the requested id is in the recent cache and avoid the database
 69986:   // lookup if so.  Invalidate the cache after getting data if requested.
 69986:   BookmarkKeyClass* key = mRecentBookmarksCache.GetEntry(aItemId);
 69986:   if (key) {
 69986:     _bookmark = key->bookmark;
 69986:     return NS_OK;
 69986:   }
 69986: 
 80946:   // LEFT JOIN since not all bookmarks have an associated place.
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "SELECT b.id, h.url, b.title, b.position, b.fk, b.parent, b.type, "
 82903:            "b.dateAdded, b.lastModified, b.guid, t.guid, t.parent "
 80946:     "FROM moz_bookmarks b "
 80946:     "LEFT JOIN moz_bookmarks t ON t.id = b.parent "
 80946:     "LEFT JOIN moz_places h ON h.id = b.fk "
 80946:     "WHERE b.id = :item_id"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 69981:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 69981: 
 79445:   bool hasResult;
 69981:   rv = stmt->ExecuteStep(&hasResult);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 82736:   if (!hasResult) {
 82736:     return NS_ERROR_INVALID_ARG;
 82736:   }
 69981: 
 69981:   _bookmark.id = aItemId;
 80946:   rv = stmt->GetUTF8String(1, _bookmark.url);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 79445:   bool isNull;
 80946:   rv = stmt->GetIsNull(2, &isNull);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   if (isNull) {
 80486:     _bookmark.title.SetIsVoid(true);
 69981:   }
 69981:   else {
 80946:     rv = stmt->GetUTF8String(2, _bookmark.title);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 69981:   }
 80946:   rv = stmt->GetInt32(3, &_bookmark.position);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 80946:   rv = stmt->GetInt64(4, &_bookmark.placeId);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 80946:   rv = stmt->GetInt64(5, &_bookmark.parentId);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 80946:   rv = stmt->GetInt32(6, &_bookmark.type);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
110765:   rv = stmt->GetInt64(7, reinterpret_cast<int64_t*>(&_bookmark.dateAdded));
 69981:   NS_ENSURE_SUCCESS(rv, rv);
110765:   rv = stmt->GetInt64(8, reinterpret_cast<int64_t*>(&_bookmark.lastModified));
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 82903:   rv = stmt->GetUTF8String(9, _bookmark.guid);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   // Getting properties of the root would show no parent.
 82903:   rv = stmt->GetIsNull(10, &isNull);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   if (!isNull) {
 82903:     rv = stmt->GetUTF8String(10, _bookmark.parentGuid);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 82903:     rv = stmt->GetInt64(11, &_bookmark.grandParentId);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 69981:   }
 69981:   else {
 69981:     _bookmark.grandParentId = -1;
 69981:   }
 69981: 
 87168:   ADD_TO_BOOKMARK_CACHE(aItemId, _bookmark);
 76962: 
 69981:   return NS_OK;
 69981: }
 37340: 
 13203: nsresult
 80946: nsNavBookmarks::SetItemDateInternal(enum BookmarkDate aDateType,
108991:                                     int64_t aItemId,
 37340:                                     PRTime aValue)
 13203: {
 80946:   nsCOMPtr<mozIStorageStatement> stmt;
 80946:   if (aDateType == DATE_ADDED) {
 80946:     // lastModified is set to the same value as dateAdded.  We do this for
 80946:     // performance reasons, since it will allow us to use an index to sort items
 80946:     // by date.
 80946:     stmt = mDB->GetStatement(
 80946:       "UPDATE moz_bookmarks SET dateAdded = :date, lastModified = :date "
 80946:       "WHERE id = :item_id"
 80946:     );
 80946:   }
 80946:   else {
 80946:     stmt = mDB->GetStatement(
 80946:       "UPDATE moz_bookmarks SET lastModified = :date WHERE id = :item_id"
 80946:     );
 80946:   }
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 80946:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("date"), aValue);
 13203:   NS_ENSURE_SUCCESS(rv, rv);
 80946:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
 13203:   NS_ENSURE_SUCCESS(rv, rv);
 13203: 
 80946:   rv = stmt->Execute();
 13203:   NS_ENSURE_SUCCESS(rv, rv);
 13203: 
 84189:   // Update the cache entry, if needed.
 84189:   BookmarkKeyClass* key = mRecentBookmarksCache.GetEntry(aItemId);
 84189:   if (key) {
 84189:     if (aDateType == DATE_ADDED) {
 84189:       key->bookmark.dateAdded = aValue;
 84189:     }
 84189:     // Set lastModified in both cases.
 84189:     key->bookmark.lastModified = aValue;
 84189:   }
 76962: 
 13203:   // note, we are not notifying the observers
 13203:   // that the item has changed.
 13203: 
 13203:   return NS_OK;
 13203: }
 13203: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::SetItemDateAdded(int64_t aItemId, PRTime aDateAdded)
  1604: {
 69981:   NS_ENSURE_ARG_MIN(aItemId, 1);
 69981: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
  1604:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   bookmark.dateAdded = aDateAdded;
 13203: 
 80946:   rv = SetItemDateInternal(DATE_ADDED, bookmark.id, bookmark.dateAdded);
 33340:   NS_ENSURE_SUCCESS(rv, rv);
 33340: 
 33340:   // Note: mDBSetItemDateAdded also sets lastModified to aDateAdded.
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 69981:                    OnItemChanged(bookmark.id,
 69981:                                  NS_LITERAL_CSTRING("dateAdded"),
 80486:                                  false,
 96873:                                  nsPrintfCString("%lld", bookmark.dateAdded),
 69981:                                  bookmark.dateAdded,
 69981:                                  bookmark.type,
 69981:                                  bookmark.parentId,
 69981:                                  bookmark.guid,
 69981:                                  bookmark.parentGuid));
  1604:   return NS_OK;
  1604: }
  1604: 
 37340: 
  1604: NS_IMETHODIMP
108991: nsNavBookmarks::GetItemDateAdded(int64_t aItemId, PRTime* _dateAdded)
  1604: {
 29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 37340:   NS_ENSURE_ARG_POINTER(_dateAdded);
  1604: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
  1604:   NS_ENSURE_SUCCESS(rv, rv);
  1604: 
 69981:   *_dateAdded = bookmark.dateAdded;
 37340:   return NS_OK;
  1604: }
  1604: 
 37340: 
  1604: NS_IMETHODIMP
108991: nsNavBookmarks::SetItemLastModified(int64_t aItemId, PRTime aLastModified)
  1604: {
 69981:   NS_ENSURE_ARG_MIN(aItemId, 1);
 69981: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
  1604:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   bookmark.lastModified = aLastModified;
 13203: 
 80946:   rv = SetItemDateInternal(LAST_MODIFIED, bookmark.id, bookmark.lastModified);
 33340:   NS_ENSURE_SUCCESS(rv, rv);
 33340: 
 69981:   // Note: mDBSetItemDateAdded also sets lastModified to aDateAdded.
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 69981:                    OnItemChanged(bookmark.id,
 69981:                                  NS_LITERAL_CSTRING("lastModified"),
 80486:                                  false,
 96873:                                  nsPrintfCString("%lld", bookmark.lastModified),
 69981:                                  bookmark.lastModified,
 69981:                                  bookmark.type,
 69981:                                  bookmark.parentId,
 69981:                                  bookmark.guid,
 69981:                                  bookmark.parentGuid));
  1604:   return NS_OK;
  1604: }
  1604: 
 37340: 
  1604: NS_IMETHODIMP
108991: nsNavBookmarks::GetItemLastModified(int64_t aItemId, PRTime* _lastModified)
  1604: {
 29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 69981:   NS_ENSURE_ARG_POINTER(_lastModified);
 69981: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
 69981:   *_lastModified = bookmark.lastModified;
 37341:   return NS_OK;
  1604: }
  1604: 
 37340: 
  4004: NS_IMETHODIMP
108991: nsNavBookmarks::SetItemTitle(int64_t aItemId, const nsACString& aTitle)
     1: {
 69981:   NS_ENSURE_ARG_MIN(aItemId, 1);
 69981: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 33340:   NS_ENSURE_SUCCESS(rv, rv);
 29123: 
 80946:   nsCOMPtr<mozIStorageStatement> statement = mDB->GetStatement(
 80946:     "UPDATE moz_bookmarks SET title = :item_title, lastModified = :date "
 80946:     "WHERE id = :item_id "
 80946:   );
 80946:   NS_ENSURE_STATE(statement);
 80946:   mozStorageStatementScoper scoper(statement);
 80946: 
 81038:   nsCString title;
 81038:   TruncateTitle(aTitle, title);
 81038: 
 27919:   // Support setting a null title, we support this in insertBookmark.
 81038:   if (title.IsVoid()) {
 41402:     rv = statement->BindNullByName(NS_LITERAL_CSTRING("item_title"));
 69981:   }
 69981:   else {
 69981:     rv = statement->BindUTF8StringByName(NS_LITERAL_CSTRING("item_title"),
 81038:                                          title);
 69981:   }
     1:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   bookmark.lastModified = PR_Now();
 69981:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("date"),
 69981:                                   bookmark.lastModified);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), bookmark.id);
 14289:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   rv = statement->Execute();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 84189:   // Update the cache entry, if needed.
 84189:   BookmarkKeyClass* key = mRecentBookmarksCache.GetEntry(aItemId);
 84189:   if (key) {
 84189:     if (title.IsVoid()) {
 84189:       key->bookmark.title.SetIsVoid(true);
 84189:     }
 84189:     else {
 84189:       key->bookmark.title.Assign(title);
 84189:     }
 84189:     key->bookmark.lastModified = bookmark.lastModified;
 84189:   }
 76962: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 69981:                    OnItemChanged(bookmark.id,
 69981:                                  NS_LITERAL_CSTRING("title"),
 80486:                                  false,
 81038:                                  title,
 69981:                                  bookmark.lastModified,
 69981:                                  bookmark.type,
 69981:                                  bookmark.parentId,
 69981:                                  bookmark.guid,
 69981:                                  bookmark.parentGuid));
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetItemTitle(int64_t aItemId,
 69981:                              nsACString& _title)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 29123: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
 69981:   _title = bookmark.title;
 37340:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetBookmarkURI(int64_t aItemId,
 69981:                                nsIURI** _URI)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 69981:   NS_ENSURE_ARG_POINTER(_URI);
 69981: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
 69981:   rv = NS_NewURI(_URI, bookmark.url);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetItemType(int64_t aItemId, uint16_t* _type)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 37340:   NS_ENSURE_ARG_POINTER(_type);
 29123: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
108991:   *_type = static_cast<uint16_t>(bookmark.type);
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: nsresult
108991: nsNavBookmarks::ResultNodeForContainer(int64_t aItemId,
     1:                                        nsNavHistoryQueryOptions* aOptions,
     1:                                        nsNavHistoryResultNode** aNode)
     1: {
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
 82903:   if (bookmark.type == TYPE_FOLDER) { // TYPE_FOLDER
 69981:     *aNode = new nsNavHistoryFolderResultNode(bookmark.title,
 69981:                                               aOptions,
 82903:                                               bookmark.id);
  4179:   }
 69981:   else {
 69981:     return NS_ERROR_INVALID_ARG;
 69981:   }
 69981: 
 69981:   (*aNode)->mDateAdded = bookmark.dateAdded;
 69981:   (*aNode)->mLastModified = bookmark.lastModified;
  1635: 
     1:   NS_ADDREF(*aNode);
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: nsresult
 40626: nsNavBookmarks::QueryFolderChildren(
108991:   int64_t aFolderId,
     1:   nsNavHistoryQueryOptions* aOptions,
     1:   nsCOMArray<nsNavHistoryResultNode>* aChildren)
     1: {
 40626:   NS_ENSURE_ARG_POINTER(aOptions);
 40626:   NS_ENSURE_ARG_POINTER(aChildren);
 40626: 
 80946:   // Select all children of a given folder, sorted by position.
 80946:   // This is a LEFT JOIN because not all bookmarks types have a place.
 80946:   // We construct a result where the first columns exactly match those returned
 80946:   // by mDBGetURLPageInfo, and additionally contains columns for position,
 80946:   // item_child, and folder_child from moz_bookmarks.
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "SELECT h.id, h.url, IFNULL(b.title, h.title), h.rev_host, h.visit_count, "
 80946:            "h.last_visit_date, f.url, null, b.id, b.dateAdded, b.lastModified, "
 80946:            "b.parent, null, h.frecency, b.position, b.type, b.fk, "
 82903:            "b.guid "
 80946:     "FROM moz_bookmarks b "
 80946:     "LEFT JOIN moz_places h ON b.fk = h.id "
 80946:     "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
 80946:     "WHERE b.parent = :parent "
 80946:     "ORDER BY b.position ASC"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 40626:   nsCOMPtr<mozIStorageValueArray> row = do_QueryInterface(stmt, &rv);
 20374:   NS_ENSURE_SUCCESS(rv, rv);
 20374: 
108991:   int32_t index = -1;
 79445:   bool hasResult;
 37341:   while (NS_SUCCEEDED(stmt->ExecuteStep(&hasResult)) && hasResult) {
 40626:     rv = ProcessFolderNodeRow(row, aOptions, aChildren, index);
 40626:     NS_ENSURE_SUCCESS(rv, rv);
 40626:   }
 40626: 
 40626:   return NS_OK;
 40626: }
 40626: 
 40626: 
 40626: nsresult
 40626: nsNavBookmarks::ProcessFolderNodeRow(
 40626:   mozIStorageValueArray* aRow,
 40626:   nsNavHistoryQueryOptions* aOptions,
 40626:   nsCOMArray<nsNavHistoryResultNode>* aChildren,
108991:   int32_t& aCurrentIndex)
 40626: {
 40626:   NS_ENSURE_ARG_POINTER(aRow);
 40626:   NS_ENSURE_ARG_POINTER(aOptions);
 40626:   NS_ENSURE_ARG_POINTER(aChildren);
 40626: 
 40626:   // The results will be in order of aCurrentIndex. Even if we don't add a node
 40626:   // because it was excluded, we need to count its index, so do that before
 40626:   // doing anything else.
 40626:   aCurrentIndex++;
     1: 
108991:   int32_t itemType;
 40626:   nsresult rv = aRow->GetInt32(kGetChildrenIndex_Type, &itemType);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
108991:   int64_t id;
 40626:   rv = aRow->GetInt64(nsNavHistory::kGetInfoIndex_ItemId, &id);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 84190: 
  7025:   nsRefPtr<nsNavHistoryResultNode> node;
 84190: 
 11421:   if (itemType == TYPE_BOOKMARK) {
 35298:     nsNavHistory* history = nsNavHistory::GetHistoryService();
 35298:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
 40626:     rv = history->RowToResult(aRow, aOptions, getter_AddRefs(node));
 11421:     NS_ENSURE_SUCCESS(rv, rv);
 11421: 
108991:     uint32_t nodeType;
 11421:     node->GetType(&nodeType);
 11421:     if ((nodeType == nsINavHistoryResultNode::RESULT_TYPE_QUERY &&
 11421:          aOptions->ExcludeQueries()) ||
 11421:         (nodeType != nsINavHistoryResultNode::RESULT_TYPE_QUERY &&
 11421:          nodeType != nsINavHistoryResultNode::RESULT_TYPE_FOLDER_SHORTCUT &&
 11421:          aOptions->ExcludeItems())) {
 40626:       return NS_OK;
 11421:     }
 40626:   }
 82903:   else if (itemType == TYPE_FOLDER) {
 40626:     if (aOptions->ExcludeReadOnlyFolders()) {
 40626:       // If the folder is read-only, skip it.
 82903:       bool readOnly = false;
  1297:       GetFolderReadonly(id, &readOnly);
     1:       if (readOnly)
 40626:         return NS_OK;
     1:     }
 84190: 
110974:     nsAutoCString title;
 84190:     rv = aRow->GetUTF8String(nsNavHistory::kGetInfoIndex_Title, title);
 84190:     NS_ENSURE_SUCCESS(rv, rv);
 84190: 
 84190:     node = new nsNavHistoryFolderResultNode(title, aOptions, id);
 84190: 
 84190:     rv = aRow->GetInt64(nsNavHistory::kGetInfoIndex_ItemDateAdded,
110765:                         reinterpret_cast<int64_t*>(&node->mDateAdded));
 84190:     NS_ENSURE_SUCCESS(rv, rv);
 84190:     rv = aRow->GetInt64(nsNavHistory::kGetInfoIndex_ItemLastModified,
110765:                         reinterpret_cast<int64_t*>(&node->mLastModified));
 40626:     NS_ENSURE_SUCCESS(rv, rv);
 40626:   }
 40626:   else {
 40626:     // This is a separator.
     1:     if (aOptions->ExcludeItems()) {
 40626:       return NS_OK;
     1:     }
     1:     node = new nsNavHistorySeparatorResultNode();
 84190: 
 84190:     node->mItemId = id;
 40626:     rv = aRow->GetInt64(nsNavHistory::kGetInfoIndex_ItemDateAdded,
110765:                         reinterpret_cast<int64_t*>(&node->mDateAdded));
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 40626:     rv = aRow->GetInt64(nsNavHistory::kGetInfoIndex_ItemLastModified,
110765:                         reinterpret_cast<int64_t*>(&node->mLastModified));
 37340:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
 40626:   // Store the index of the node within this container.  Note that this is not
 40626:   // moz_bookmarks.position.
 40626:   node->mBookmarkIndex = aCurrentIndex;
     1: 
     1:   NS_ENSURE_TRUE(aChildren->AppendObject(node), NS_ERROR_OUT_OF_MEMORY);
 40626: 
 40626:   return NS_OK;
     1: }
 40626: 
 40626: 
 40626: nsresult
 40626: nsNavBookmarks::QueryFolderChildrenAsync(
 40626:   nsNavHistoryFolderResultNode* aNode,
108991:   int64_t aFolderId,
 40626:   mozIStoragePendingStatement** _pendingStmt)
 40626: {
 40626:   NS_ENSURE_ARG_POINTER(aNode);
 40626:   NS_ENSURE_ARG_POINTER(_pendingStmt);
 40626: 
 80946:   // Select all children of a given folder, sorted by position.
 80946:   // This is a LEFT JOIN because not all bookmarks types have a place.
 80946:   // We construct a result where the first columns exactly match those returned
 80946:   // by mDBGetURLPageInfo, and additionally contains columns for position,
 80946:   // item_child, and folder_child from moz_bookmarks.
 80946:   nsCOMPtr<mozIStorageAsyncStatement> stmt = mDB->GetAsyncStatement(
 80946:     "SELECT h.id, h.url, IFNULL(b.title, h.title), h.rev_host, h.visit_count, "
 80946:            "h.last_visit_date, f.url, null, b.id, b.dateAdded, b.lastModified, "
 80946:            "b.parent, null, h.frecency, b.position, b.type, b.fk, "
 82903:            "b.guid "
 80946:     "FROM moz_bookmarks b "
 80946:     "LEFT JOIN moz_places h ON b.fk = h.id "
 80946:     "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
 80946:     "WHERE b.parent = :parent "
 80946:     "ORDER BY b.position ASC"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946: 
 80946:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
 40626:   NS_ENSURE_SUCCESS(rv, rv);
 40626: 
 40626:   nsCOMPtr<mozIStoragePendingStatement> pendingStmt;
 80946:   rv = stmt->ExecuteAsync(aNode, getter_AddRefs(pendingStmt));
 40626:   NS_ENSURE_SUCCESS(rv, rv);
 40626: 
 40626:   NS_IF_ADDREF(*_pendingStmt = pendingStmt);
     1:   return NS_OK;
     1: }
     1: 
 37340: 
 31729: nsresult
108991: nsNavBookmarks::FetchFolderInfo(int64_t aFolderId,
108991:                                 int32_t* _folderCount,
 69981:                                 nsACString& _guid,
108991:                                 int64_t* _parentId)
     1: {
 37340:   *_folderCount = 0;
 69981:   *_parentId = -1;
 69981: 
 80946:   // This query has to always return results, so it can't be written as a join,
 80946:   // though a left join of 2 subqueries would have the same cost.
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "SELECT count(*), "
 80946:             "(SELECT guid FROM moz_bookmarks WHERE id = :parent), "
 80946:             "(SELECT parent FROM moz_bookmarks WHERE id = :parent) "
 80946:     "FROM moz_bookmarks "
 80946:     "WHERE parent = :parent"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
 31729:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 79445:   bool hasResult;
 37341:   rv = stmt->ExecuteStep(&hasResult);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 37340:   NS_ENSURE_TRUE(hasResult, NS_ERROR_UNEXPECTED);
     1: 
 31729:   // Ensure that the folder we are looking for exists.
 69981:   // Can't rely only on parent, since the root has parent 0, that doesn't exist.
 79445:   bool isNull;
 69981:   rv = stmt->GetIsNull(2, &isNull);
 69981:   NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && (!isNull || aFolderId == 0),
 69981:                  NS_ERROR_INVALID_ARG);
 37340: 
 37341:   rv = stmt->GetInt32(0, _folderCount);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   if (!isNull) {
 69981:     rv = stmt->GetUTF8String(1, _guid);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 69981:     rv = stmt->GetInt64(2, _parentId);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 69981:   }
 31729: 
 31729:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
 79445: nsNavBookmarks::IsBookmarked(nsIURI* aURI, bool* aBookmarked)
     1: {
 14272:   NS_ENSURE_ARG(aURI);
 29123:   NS_ENSURE_ARG_POINTER(aBookmarked);
 14272: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "SELECT 1 FROM moz_bookmarks b "
 80946:     "JOIN moz_places h ON b.fk = h.id "
 80946:     "WHERE h.url = :page_url"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:   nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), aURI);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 39203:   rv = stmt->ExecuteStep(aBookmarked);
 39203:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
     1: nsNavBookmarks::GetBookmarkedURIFor(nsIURI* aURI, nsIURI** _retval)
     1: {
 29123:   NS_ENSURE_ARG(aURI);
 29123:   NS_ENSURE_ARG_POINTER(_retval);
 29123: 
106838:   *_retval = nullptr;
     1: 
 35298:   nsNavHistory* history = nsNavHistory::GetHistoryService();
 35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
108991:   int64_t placeId;
110974:   nsAutoCString placeGuid;
 72845:   nsresult rv = history->GetIdForPage(aURI, &placeId, placeGuid);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 39203:   if (!placeId) {
 39203:     // This URI is unknown, just return null.
     1:     return NS_OK;
     1:   }
     1: 
 39203:   // Check if a bookmark exists in the redirects chain for this URI.
 39203:   // The query will also check if the page is directly bookmarked, and return
 39203:   // the first found bookmark in case.  The check is directly on moz_bookmarks
 39203:   // without special filtering.
 80946:   // The next query finds the bookmarked ancestors in a redirects chain.
 80946:   // It won't go further than 3 levels of redirects (a->b->c->your_place_id).
 80946:   // To make this path 100% correct (up to any level) we would need either:
 80946:   //  - A separate hash, build through recursive querying of the database.
 80946:   //    This solution was previously implemented, but it had a negative effect
 80946:   //    on startup since at each startup we have to recursively query the
 80946:   //    database to rebuild a hash that is always the same across sessions.
 80946:   //    It must be updated at each visit and bookmarks change too.  The code to
 80946:   //    manage it is complex and prone to errors, sometimes causing incorrect
 80946:   //    data fetches (for example wrong favicon for a redirected bookmark).
 80946:   //  - A better way to track redirects for a visit.
 80946:   //    We would need a separate table to track redirects, in the table we would
 80946:   //    have visit_id, redirect_session.  To get all sources for
 80946:   //    a visit then we could just join this table and get all visit_id that
 80946:   //    are in the same redirect_session as our visit.  This has the drawback
 80946:   //    that we can't ensure data integrity in the downgrade -> upgrade path,
 80946:   //    since an old version would not update the table on new visits.
 80946:   //
 80946:   // For most cases these levels of redirects should be fine though, it's hard
 80946:   // to hit a page that is 4 or 5 levels of redirects below a bookmarked page.
 80946:   //
 80946:   // As a bonus the query also checks first if place_id is already a bookmark,
 80946:   // so you don't have to check that apart.
 80946: 
 96873:   nsCString query = nsPrintfCString(
 94613:     "SELECT url FROM moz_places WHERE id = ( "
 94613:       "SELECT :page_id FROM moz_bookmarks WHERE fk = :page_id "
 94613:       "UNION ALL "
 94613:       "SELECT COALESCE(grandparent.place_id, parent.place_id) AS r_place_id "
 94613:       "FROM moz_historyvisits dest "
 94613:       "LEFT JOIN moz_historyvisits parent ON parent.id = dest.from_visit " 
 94613:                                         "AND dest.visit_type IN (%d, %d) "
 94613:       "LEFT JOIN moz_historyvisits grandparent ON parent.from_visit = grandparent.id "
 94613:                                              "AND parent.visit_type IN (%d, %d) "
 94613:       "WHERE dest.place_id = :page_id "
 94613:       "AND EXISTS(SELECT 1 FROM moz_bookmarks WHERE fk = r_place_id) "
 94613:       "LIMIT 1 "
 94613:     ")",
 80946:     nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
 94613:     nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY,
 94613:     nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
 94613:     nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY
 94613:   );
 94613: 
 94613:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(query);
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41401:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), placeId);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 79445:   bool hasBookmarkedOrigin;
 39203:   if (NS_SUCCEEDED(stmt->ExecuteStep(&hasBookmarkedOrigin)) &&
 39203:       hasBookmarkedOrigin) {
110974:     nsAutoCString spec;
 39203:     rv = stmt->GetUTF8String(0, spec);
 39203:     NS_ENSURE_SUCCESS(rv, rv);
 39203:     rv = NS_NewURI(_retval, spec);
 39203:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
 39203: 
 39203:   // If there is no bookmarked origin, we will just return null.
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::ChangeBookmarkURI(int64_t aBookmarkId, nsIURI* aNewURI)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aBookmarkId, 1);
  1337:   NS_ENSURE_ARG(aNewURI);
  1337: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aBookmarkId, bookmark);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   NS_ENSURE_ARG(bookmark.type == TYPE_BOOKMARK);
 69981: 
 80946:   mozStorageTransaction transaction(mDB->MainConn(), false);
     1: 
 35298:   nsNavHistory* history = nsNavHistory::GetHistoryService();
 35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
108991:   int64_t newPlaceId;
110974:   nsAutoCString newPlaceGuid;
 72845:   rv = history->GetOrCreateIdForPage(aNewURI, &newPlaceId, newPlaceGuid);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   if (!newPlaceId)
     1:     return NS_ERROR_INVALID_ARG;
     1: 
 76962:   BEGIN_CRITICAL_BOOKMARK_CACHE_SECTION(bookmark.id);
 76962: 
 80946:   nsCOMPtr<mozIStorageStatement> statement = mDB->GetStatement(
 80946:     "UPDATE moz_bookmarks SET fk = :page_id, lastModified = :date "
 80946:     "WHERE id = :item_id "
 80946:   );
 80946:   NS_ENSURE_STATE(statement);
 80946:   mozStorageStatementScoper scoper(statement);
 80946: 
 69981:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), newPlaceId);
 23593:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   bookmark.lastModified = PR_Now();
 69981:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("date"),
 69981:                                   bookmark.lastModified);
 23593:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), bookmark.id);
 29518:   NS_ENSURE_SUCCESS(rv, rv);
     1:   rv = statement->Execute();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   rv = transaction.Commit();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 76962:   END_CRITICAL_BOOKMARK_CACHE_SECTION(bookmark.id);
 76962: 
 69981:   rv = history->UpdateFrecency(newPlaceId);
 10669:   NS_ENSURE_SUCCESS(rv, rv);
 10669: 
 59298:   // Upon changing the URI for a bookmark, update the frecency for the old
 59298:   // place as well.
 69981:   rv = history->UpdateFrecency(bookmark.placeId);
 23593:   NS_ENSURE_SUCCESS(rv, rv);
 10669: 
110974:   nsAutoCString spec;
  1337:   rv = aNewURI->GetSpec(spec);
  1337:   NS_ENSURE_SUCCESS(rv, rv);
  1337: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 69981:                    OnItemChanged(bookmark.id,
 69981:                                  NS_LITERAL_CSTRING("uri"),
 80486:                                  false,
 69981:                                  spec,
 69981:                                  bookmark.lastModified,
 69981:                                  bookmark.type,
 69981:                                  bookmark.parentId,
 69981:                                  bookmark.guid,
 69981:                                  bookmark.parentGuid));
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetFolderIdForItem(int64_t aItemId, int64_t* _parentId)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 69981:   NS_ENSURE_ARG_POINTER(_parentId);
 69981: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
  7122:   // this should not happen, but see bug #400448 for details
 69981:   NS_ENSURE_TRUE(bookmark.id != bookmark.parentId, NS_ERROR_UNEXPECTED);
 69981: 
 69981:   *_parentId = bookmark.parentId;
  7122:   return NS_OK;
     1: }
     1: 
 37340: 
 34260: nsresult
     1: nsNavBookmarks::GetBookmarkIdsForURITArray(nsIURI* aURI,
108991:                                            nsTArray<int64_t>& aResult,
 69683:                                            bool aSkipTags)
     1: {
 29123:   NS_ENSURE_ARG(aURI);
 29123: 
 80946:   // Double ordering covers possible lastModified ties, that could happen when
 80946:   // importing, syncing or due to extensions.
 80946:   // Note: not using a JOIN is cheaper in this case.
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "SELECT b.id, b.guid, b.parent, b.lastModified, t.guid, t.parent "
 80946:     "FROM moz_bookmarks b "
 80946:     "JOIN moz_bookmarks t on t.id = b.parent "
 80946:     "WHERE b.fk = (SELECT id FROM moz_places WHERE url = :page_url) "
 80946:     "ORDER BY b.lastModified DESC, b.id DESC "
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:   nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), aURI);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 79445:   bool more;
 37341:   while (NS_SUCCEEDED((rv = stmt->ExecuteStep(&more))) && more) {
 69683:     if (aSkipTags) {
 69683:       // Skip tags, for the use-cases of this async getter they are useless.
108991:       int64_t grandParentId;
 80946:       nsresult rv = stmt->GetInt64(5, &grandParentId);
 69683:       NS_ENSURE_SUCCESS(rv, rv);
 69683:       if (grandParentId == mTagsRoot) {
 69683:         continue;
 69683:       }
 69683:     }
108991:     int64_t bookmarkId;
 80946:     rv = stmt->GetInt64(0, &bookmarkId);
 37340:     NS_ENSURE_SUCCESS(rv, rv);
 37340:     NS_ENSURE_TRUE(aResult.AppendElement(bookmarkId), NS_ERROR_OUT_OF_MEMORY);
 37259:   }
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 37340: 
 11421:   return NS_OK;
     1: }
     1: 
 69981: nsresult
 69981: nsNavBookmarks::GetBookmarksForURI(nsIURI* aURI,
 69981:                                    nsTArray<BookmarkData>& aBookmarks)
 69981: {
 69981:   NS_ENSURE_ARG(aURI);
 69981: 
 80946:   // Double ordering covers possible lastModified ties, that could happen when
 80946:   // importing, syncing or due to extensions.
 80946:   // Note: not using a JOIN is cheaper in this case.
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "SELECT b.id, b.guid, b.parent, b.lastModified, t.guid, t.parent "
 80946:     "FROM moz_bookmarks b "
 80946:     "JOIN moz_bookmarks t on t.id = b.parent "
 80946:     "WHERE b.fk = (SELECT id FROM moz_places WHERE url = :page_url) "
 80946:     "ORDER BY b.lastModified DESC, b.id DESC "
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 69981:   nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), aURI);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 69981: 
 79445:   bool more;
 69981:   nsAutoString tags;
 69981:   while (NS_SUCCEEDED((rv = stmt->ExecuteStep(&more))) && more) {
 69981:     // Skip tags.
108991:     int64_t grandParentId;
 80946:     nsresult rv = stmt->GetInt64(5, &grandParentId);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 69981:     if (grandParentId == mTagsRoot) {
 69981:       continue;
 69981:     }
 69981: 
 69981:     BookmarkData bookmark;
 69981:     bookmark.grandParentId = grandParentId;
 80946:     rv = stmt->GetInt64(0, &bookmark.id);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 80946:     rv = stmt->GetUTF8String(1, bookmark.guid);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 80946:     rv = stmt->GetInt64(2, &bookmark.parentId);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
110765:     rv = stmt->GetInt64(3, reinterpret_cast<int64_t*>(&bookmark.lastModified));
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 80946:     rv = stmt->GetUTF8String(4, bookmark.parentGuid);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 69981: 
 69981:     NS_ENSURE_TRUE(aBookmarks.AppendElement(bookmark), NS_ERROR_OUT_OF_MEMORY);
 69981:   }
 69981: 
 69981:   return NS_OK;
 69981: }
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetBookmarkIdsForURI(nsIURI* aURI, uint32_t* aCount,
108991:                                      int64_t** aBookmarks)
     1: {
 29123:   NS_ENSURE_ARG(aURI);
 29123:   NS_ENSURE_ARG_POINTER(aCount);
 29123:   NS_ENSURE_ARG_POINTER(aBookmarks);
 29123: 
     1:   *aCount = 0;
106838:   *aBookmarks = nullptr;
108991:   nsTArray<int64_t> bookmarks;
     1: 
     1:   // Get the information from the DB as a TArray
 69683:   // TODO (bug 653816): make this API skip tags by default.
 69683:   nsresult rv = GetBookmarkIdsForURITArray(aURI, bookmarks, false);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // Copy the results into a new array for output
     1:   if (bookmarks.Length()) {
 37340:     *aBookmarks =
108991:       static_cast<int64_t*>(nsMemory::Alloc(sizeof(int64_t) * bookmarks.Length()));
     1:     if (!*aBookmarks)
     1:       return NS_ERROR_OUT_OF_MEMORY;
108991:     for (uint32_t i = 0; i < bookmarks.Length(); i ++)
     1:       (*aBookmarks)[i] = bookmarks[i];
     1:   }
 69981: 
     1:   *aCount = bookmarks.Length();
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetItemIndex(int64_t aItemId, int32_t* _index)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 37340:   NS_ENSURE_ARG_POINTER(_index);
 37340: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 69981:   // With respect to the API.
 69981:   if (NS_FAILED(rv)) {
 37340:     *_index = -1;
 37340:     return NS_OK;
 69981:   }
 69981: 
 69981:   *_index = bookmark.position;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::SetItemIndex(int64_t aItemId, int32_t aNewIndex)
  1377: {
 29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 31729:   NS_ENSURE_ARG_MIN(aNewIndex, 0);
 29123: 
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
 31729:   // Ensure we are not going out of range.
108991:   int32_t folderCount;
108991:   int64_t grandParentId;
110974:   nsAutoCString folderGuid;
 69981:   rv = FetchFolderInfo(bookmark.parentId, &folderCount, folderGuid, &grandParentId);
 31729:   NS_ENSURE_SUCCESS(rv, rv);
 31729:   NS_ENSURE_TRUE(aNewIndex < folderCount, NS_ERROR_INVALID_ARG);
 69981:   // Check the parent's guid is the expected one.
 69981:   MOZ_ASSERT(bookmark.parentGuid == folderGuid);
 31729: 
 76962:   BEGIN_CRITICAL_BOOKMARK_CACHE_SECTION(bookmark.id);
 76962: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "UPDATE moz_bookmarks SET position = :item_index WHERE id = :item_id"
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_index"), aNewIndex);
 37341:   NS_ENSURE_SUCCESS(rv, rv);
 37341: 
 37341:   rv = stmt->Execute();
  1377:   NS_ENSURE_SUCCESS(rv, rv);
  1377: 
 76962:   END_CRITICAL_BOOKMARK_CACHE_SECTION(bookmark.id);
 76962: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 69981:                    OnItemMoved(bookmark.id,
 69981:                                bookmark.parentId,
 69981:                                bookmark.position,
 69981:                                bookmark.parentId,
 69981:                                aNewIndex,
 69981:                                bookmark.type,
 69981:                                bookmark.guid,
 69981:                                bookmark.parentGuid,
 69981:                                bookmark.parentGuid));
  1377: 
  1377:   return NS_OK;
  1377: }
  1377: 
 37340: 
 50437: nsresult
108991: nsNavBookmarks::UpdateKeywordsHashForRemovedBookmark(int64_t aItemId)
 50437: {
 84191:   nsAutoString keyword;
 84191:   if (NS_SUCCEEDED(GetKeywordForBookmark(aItemId, keyword)) &&
 84191:       !keyword.IsEmpty()) {
 50437:     nsresult rv = EnsureKeywordsHash();
 50437:     NS_ENSURE_SUCCESS(rv, rv);
 50437:     mBookmarkToKeywordHash.Remove(aItemId);
 84191: 
 84191:     // If the keyword is unused, remove it from the database.
 84191:     keywordSearchData searchData;
 84191:     searchData.keyword.Assign(keyword);
 84191:     searchData.itemId = -1;
 84191:     mBookmarkToKeywordHash.EnumerateRead(SearchBookmarkForKeyword, &searchData);
 84191:     if (searchData.itemId == -1) {
 84191:       nsCOMPtr<mozIStorageAsyncStatement> stmt = mDB->GetAsyncStatement(
 84191:         "DELETE FROM moz_keywords "
 84191:         "WHERE keyword = :keyword "
 84191:         "AND NOT EXISTS ( "
 84191:           "SELECT id "
 84191:           "FROM moz_bookmarks "
 84191:           "WHERE keyword_id = moz_keywords.id "
 84191:         ")"
 84191:       );
 84191:       NS_ENSURE_STATE(stmt);
 84191: 
 84191:       rv = stmt->BindStringByName(NS_LITERAL_CSTRING("keyword"), keyword);
 84191:       NS_ENSURE_SUCCESS(rv, rv);
 84191:       nsCOMPtr<mozIStoragePendingStatement> pendingStmt;
106838:       rv = stmt->ExecuteAsync(nullptr, getter_AddRefs(pendingStmt));
 84191:       NS_ENSURE_SUCCESS(rv, rv);
 84191:     }
 50437:   }
 50437:   return NS_OK;
 50437: }
 50437: 
 50437: 
  1377: NS_IMETHODIMP
108991: nsNavBookmarks::SetKeywordForBookmark(int64_t aBookmarkId,
 51666:                                       const nsAString& aUserCasedKeyword)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aBookmarkId, 1);
     1: 
 69981:   // This also ensures the bookmark is valid.
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aBookmarkId, bookmark);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 69981: 
 69981:   rv = EnsureKeywordsHash();
 50437:   NS_ENSURE_SUCCESS(rv, rv);
 50437: 
 50437:   // Shortcuts are always lowercased internally.
 51666:   nsAutoString keyword(aUserCasedKeyword);
 50437:   ToLowerCase(keyword);
 50437: 
 50437:   // Check if bookmark was already associated to a keyword.
 50437:   nsAutoString oldKeyword;
 69981:   rv = GetKeywordForBookmark(bookmark.id, oldKeyword);
 50437:   NS_ENSURE_SUCCESS(rv, rv);
 50437: 
 50437:   // Trying to set the same value or to remove a nonexistent keyword is a no-op.
 50437:   if (keyword.Equals(oldKeyword) || (keyword.IsEmpty() && oldKeyword.IsEmpty()))
 50437:     return NS_OK;
 50437: 
 80946:   mozStorageTransaction transaction(mDB->MainConn(), false);
 80946: 
 80946:   nsCOMPtr<mozIStorageStatement> updateBookmarkStmt = mDB->GetStatement(
 50437:     "UPDATE moz_bookmarks "
 50437:     "SET keyword_id = (SELECT id FROM moz_keywords WHERE keyword = :keyword), "
 50437:         "lastModified = :date "
 50437:     "WHERE id = :item_id "
 80946:   );
 80946:   NS_ENSURE_STATE(updateBookmarkStmt);
 80946:   mozStorageStatementScoper updateBookmarkScoper(updateBookmarkStmt);
 50437: 
 50437:   if (keyword.IsEmpty()) {
 50437:     // Remove keyword association from the hash.
 69981:     mBookmarkToKeywordHash.Remove(bookmark.id);
 50437:     rv = updateBookmarkStmt->BindNullByName(NS_LITERAL_CSTRING("keyword"));
     1:   }
     1:    else {
 50437:     // We are associating bookmark to a new keyword. Create a new keyword
 50437:     // record if needed.
 80946:     nsCOMPtr<mozIStorageStatement> newKeywordStmt = mDB->GetStatement(
 50437:       "INSERT OR IGNORE INTO moz_keywords (keyword) VALUES (:keyword)"
 80946:     );
 80946:     NS_ENSURE_STATE(newKeywordStmt);
 80946:     mozStorageStatementScoper newKeywordScoper(newKeywordStmt);
 80946: 
 50437:     rv = newKeywordStmt->BindStringByName(NS_LITERAL_CSTRING("keyword"),
 50437:                                           keyword);
     1:     NS_ENSURE_SUCCESS(rv, rv);
 50437:     rv = newKeywordStmt->Execute();
     1:     NS_ENSURE_SUCCESS(rv, rv);
 16751: 
 50437:     // Add new keyword association to the hash, removing the old one if needed.
 50437:     if (!oldKeyword.IsEmpty())
 69981:       mBookmarkToKeywordHash.Remove(bookmark.id);
 69981:     mBookmarkToKeywordHash.Put(bookmark.id, keyword);
 50437:     rv = updateBookmarkStmt->BindStringByName(NS_LITERAL_CSTRING("keyword"), keyword);
 41402:   }
     1:   NS_ENSURE_SUCCESS(rv, rv);
 69981:   bookmark.lastModified = PR_Now();
 50437:   rv = updateBookmarkStmt->BindInt64ByName(NS_LITERAL_CSTRING("date"),
 69981:                                            bookmark.lastModified);
 29518:   NS_ENSURE_SUCCESS(rv, rv);
 50437:   rv = updateBookmarkStmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"),
 69981:                                            bookmark.id);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 50437:   rv = updateBookmarkStmt->Execute();
     1:   NS_ENSURE_SUCCESS(rv, rv);
  1429: 
 29518:   rv = transaction.Commit();
  1604:   NS_ENSURE_SUCCESS(rv, rv);
  1604: 
 84189:   // Update the cache entry, if needed.
 84189:   BookmarkKeyClass* key = mRecentBookmarksCache.GetEntry(aBookmarkId);
 84189:   if (key) {
 84189:     key->bookmark.lastModified = bookmark.lastModified;
 84189:   }
 76962: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 37343:                    nsINavBookmarkObserver,
 69981:                    OnItemChanged(bookmark.id,
 69981:                                  NS_LITERAL_CSTRING("keyword"),
 80486:                                  false,
 69981:                                  NS_ConvertUTF16toUTF8(keyword),
 69981:                                  bookmark.lastModified,
 69981:                                  bookmark.type,
 69981:                                  bookmark.parentId,
 69981:                                  bookmark.guid,
 69981:                                  bookmark.parentGuid));
  1604: 
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
     1: nsNavBookmarks::GetKeywordForURI(nsIURI* aURI, nsAString& aKeyword)
     1: {
 29123:   NS_ENSURE_ARG(aURI);
     1:   aKeyword.Truncate(0);
     1: 
 80946:   nsCOMPtr<mozIStorageStatement> stmt = mDB->GetStatement(
 80946:     "SELECT k.keyword "
 80946:     "FROM moz_places h "
 80946:     "JOIN moz_bookmarks b ON b.fk = h.id "
 80946:     "JOIN moz_keywords k ON k.id = b.keyword_id "
 80946:     "WHERE h.url = :page_url "
 80946:   );
 80946:   NS_ENSURE_STATE(stmt);
 80946:   mozStorageStatementScoper scoper(stmt);
 80946: 
 41402:   nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), aURI);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 79445:   bool hasMore = false;
 37341:   rv = stmt->ExecuteStep(&hasMore);
     1:   if (NS_FAILED(rv) || !hasMore) {
 80486:     aKeyword.SetIsVoid(true);
     1:     return NS_OK; // not found: return void keyword string
     1:   }
     1: 
     1:   // found, get the keyword
 37341:   rv = stmt->GetString(0, aKeyword);
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 37340:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::GetKeywordForBookmark(int64_t aBookmarkId, nsAString& aKeyword)
     1: {
 29123:   NS_ENSURE_ARG_MIN(aBookmarkId, 1);
     1:   aKeyword.Truncate(0);
     1: 
 50437:   nsresult rv = EnsureKeywordsHash();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 50437:   nsAutoString keyword;
 50437:   if (!mBookmarkToKeywordHash.Get(aBookmarkId, &keyword)) {
 80486:     aKeyword.SetIsVoid(true);
     1:   }
 50437:   else {
 50437:     aKeyword.Assign(keyword);
 50437:   }
 50437: 
 37341:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
 51666: nsNavBookmarks::GetURIForKeyword(const nsAString& aUserCasedKeyword,
 51666:                                  nsIURI** aURI)
     1: {
 29123:   NS_ENSURE_ARG_POINTER(aURI);
 51666:   NS_ENSURE_TRUE(!aUserCasedKeyword.IsEmpty(), NS_ERROR_INVALID_ARG);
106838:   *aURI = nullptr;
     1: 
     1:   // Shortcuts are always lowercased internally.
 51666:   nsAutoString keyword(aUserCasedKeyword);
 50437:   ToLowerCase(keyword);
 50437: 
 50437:   nsresult rv = EnsureKeywordsHash();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 50437:   keywordSearchData searchData;
 51666:   searchData.keyword.Assign(keyword);
 50437:   searchData.itemId = -1;
 50437:   mBookmarkToKeywordHash.EnumerateRead(SearchBookmarkForKeyword, &searchData);
 50437: 
 50437:   if (searchData.itemId == -1) {
 50437:     // Not found.
 50437:     return NS_OK;
 50437:   }
 50437: 
 50437:   rv = GetBookmarkURI(searchData.itemId, aURI);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 50437: 
 50437:   return NS_OK;
 50437: }
 50437: 
 50437: 
 50437: nsresult
 50437: nsNavBookmarks::EnsureKeywordsHash() {
 50437:   if (mBookmarkToKeywordHash.IsInitialized())
 50437:     return NS_OK;
 50437: 
 50437:   mBookmarkToKeywordHash.Init(BOOKMARKS_TO_KEYWORDS_INITIAL_CACHE_SIZE);
 50437: 
 50437:   nsCOMPtr<mozIStorageStatement> stmt;
 80946:   nsresult rv = mDB->MainConn()->CreateStatement(NS_LITERAL_CSTRING(
 50437:     "SELECT b.id, k.keyword "
 50437:     "FROM moz_bookmarks b "
 50437:     "JOIN moz_keywords k ON k.id = b.keyword_id "
 50437:   ), getter_AddRefs(stmt));
 37340:   NS_ENSURE_SUCCESS(rv, rv);
 50437: 
 79445:   bool hasMore;
 50437:   while (NS_SUCCEEDED(stmt->ExecuteStep(&hasMore)) && hasMore) {
108991:     int64_t itemId;
 50437:     rv = stmt->GetInt64(0, &itemId);
 50437:     NS_ENSURE_SUCCESS(rv, rv);
 50437:     nsAutoString keyword;
 50437:     rv = stmt->GetString(1, keyword);
 50437:     NS_ENSURE_SUCCESS(rv, rv);
 50437: 
 98908:     mBookmarkToKeywordHash.Put(itemId, keyword);
 50437:   }
 50437: 
 37340:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
  2051: nsNavBookmarks::RunInBatchMode(nsINavHistoryBatchCallback* aCallback,
  2051:                                nsISupports* aUserData) {
 87692:   SAMPLE_LABEL("bookmarks", "RunInBatchMode");
 29123:   NS_ENSURE_ARG(aCallback);
  2051: 
 59379:   mBatching = true;
 59379: 
 57427:   // Just forward the request to history.  History service must exist for
 57427:   // bookmarks to work and we are observing it, thus batch notifications will be
 57427:   // forwarded to bookmarks observers.
 57427:   nsNavHistory* history = nsNavHistory::GetHistoryService();
 57427:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
 57427:   nsresult rv = history->RunInBatchMode(aCallback, aUserData);
 57427:   NS_ENSURE_SUCCESS(rv, rv);
 57427: 
 57427:   return NS_OK;
  2051: }
  2051: 
 37340: 
  2051: NS_IMETHODIMP
     1: nsNavBookmarks::AddObserver(nsINavBookmarkObserver* aObserver,
 79445:                             bool aOwnsWeak)
     1: {
 29123:   NS_ENSURE_ARG(aObserver);
     1:   return mObservers.AppendWeakElement(aObserver, aOwnsWeak);
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
     1: nsNavBookmarks::RemoveObserver(nsINavBookmarkObserver* aObserver)
     1: {
     1:   return mObservers.RemoveWeakElement(aObserver);
     1: }
     1: 
 60944: void
 61984: nsNavBookmarks::NotifyItemVisited(const ItemVisitData& aData)
 60944: {
 69981:   nsCOMPtr<nsIURI> uri;
 69981:   (void)NS_NewURI(getter_AddRefs(uri), aData.bookmark.url);
 69981:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 69981:                    nsINavBookmarkObserver,
 69981:                    OnItemVisited(aData.bookmark.id,
 69981:                                  aData.visitId,
 69981:                                  aData.time,
 69981:                                  aData.transitionType,
 69981:                                  uri,
 69981:                                  aData.bookmark.parentId,
 69981:                                  aData.bookmark.guid,
 69981:                                  aData.bookmark.parentGuid));
 60944: }
 60944: 
 60944: void
 61984: nsNavBookmarks::NotifyItemChanged(const ItemChangeData& aData)
 60944: {
 69981:   // A guid must always be defined.
 69981:   MOZ_ASSERT(!aData.bookmark.guid.IsEmpty());
 69981:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 69981:                    nsINavBookmarkObserver,
 69981:                    OnItemChanged(aData.bookmark.id,
 69981:                                  aData.property,
 69981:                                  aData.isAnnotation,
 69981:                                  aData.newValue,
 69981:                                  aData.bookmark.lastModified,
 69981:                                  aData.bookmark.type,
 69981:                                  aData.bookmark.parentId,
 69981:                                  aData.bookmark.guid,
 69981:                                  aData.bookmark.parentGuid));
 60944: }
 60944: 
 60944: ////////////////////////////////////////////////////////////////////////////////
 69986: //// nsIObserver
 69986: 
 69986: NS_IMETHODIMP
 69986: nsNavBookmarks::Observe(nsISupports *aSubject, const char *aTopic,
 69986:                         const PRUnichar *aData)
 69986: {
 69986:   NS_ASSERTION(NS_IsMainThread(), "This can only be called on the main thread");
 69986: 
 69986:   if (strcmp(aTopic, TOPIC_PLACES_MAINTENANCE) == 0) {
 69986:     // Maintenance can execute direct writes to the database, thus clear all
 69986:     // the cached bookmarks.
 69986:     mRecentBookmarksCache.Clear();
 69986:   }
 69986:   else if (strcmp(aTopic, TOPIC_PLACES_SHUTDOWN) == 0) {
 80946:     // Stop Observing annotations.
 80946:     nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 80946:     if (annosvc) {
 80946:       annosvc->RemoveObserver(this);
 69986:     }
 69986:   }
 80946:   else if (strcmp(aTopic, TOPIC_PLACES_CONNECTION_CLOSED) == 0) {
 80946:     // Don't even try to notify observers from this point on, the category
 80946:     // cache would init services that could try to use our APIs.
 80946:     mCanNotify = false;
 80946:   }
 69986: 
 69986:   return NS_OK;
 69986: }
 69986: 
 69986: ////////////////////////////////////////////////////////////////////////////////
 69986: //// nsINavHistoryObserver
     1: 
     1: NS_IMETHODIMP
     1: nsNavBookmarks::OnBeginUpdateBatch()
     1: {
 57427:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 57427:                    nsINavBookmarkObserver, OnBeginUpdateBatch());
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
     1: nsNavBookmarks::OnEndUpdateBatch()
     1: {
 59379:   if (mBatching) {
 59379:     mBatching = false;
 59379:   }
 59379: 
 57427:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 57427:                    nsINavBookmarkObserver, OnEndUpdateBatch());
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
108991: nsNavBookmarks::OnVisit(nsIURI* aURI, int64_t aVisitId, PRTime aTime,
108991:                         int64_t aSessionID, int64_t aReferringID,
108991:                         uint32_t aTransitionType, const nsACString& aGUID,
108991:                         uint32_t* aAdded)
     1: {
 60944:   // If the page is bookmarked, notify observers for each associated bookmark.
 60944:   ItemVisitData visitData;
 69981:   nsresult rv = aURI->GetSpec(visitData.bookmark.url);
 69981:   NS_ENSURE_SUCCESS(rv, rv);
 60944:   visitData.visitId = aVisitId;
 60944:   visitData.time = aTime;
 69981:   visitData.transitionType = aTransitionType;
 60944: 
 60944:   nsRefPtr< AsyncGetBookmarksForURI<ItemVisitMethod, ItemVisitData> > notifier =
 60944:     new AsyncGetBookmarksForURI<ItemVisitMethod, ItemVisitData>(this, &nsNavBookmarks::NotifyItemVisited, visitData);
 61984:   notifier->Init();
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
 72841: nsNavBookmarks::OnBeforeDeleteURI(nsIURI* aURI,
 72841:                                   const nsACString& aGUID,
108991:                                   uint16_t aReason)
 27196: {
 27196:   return NS_OK;
 27196: }
 27196: 
 37340: 
 27196: NS_IMETHODIMP
 72841: nsNavBookmarks::OnDeleteURI(nsIURI* aURI,
 72841:                             const nsACString& aGUID,
108991:                             uint16_t aReason)
     1: {
 69200: #ifdef DEBUG
 69200:   nsNavHistory* history = nsNavHistory::GetHistoryService();
108991:   int64_t placeId;
110974:   nsAutoCString placeGuid;
 69200:   NS_ABORT_IF_FALSE(
 72845:     history && NS_SUCCEEDED(history->GetIdForPage(aURI, &placeId, placeGuid)) && !placeId,
 69200:     "OnDeleteURI was notified for a page that still exists?"
 69200:   );
 69200: #endif
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
     1: nsNavBookmarks::OnClearHistory()
     1: {
     1:   // TODO(bryner): we should notify on visited-time change for all URIs
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
 72844: nsNavBookmarks::OnTitleChanged(nsIURI* aURI,
 72844:                                const nsAString& aPageTitle,
 72844:                                const nsACString& aGUID)
     1: {
     1:   // NOOP. We don't consume page titles from moz_places anymore.
     1:   // Title-change notifications are sent from SetItemTitle.
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
 72845: nsNavBookmarks::OnPageChanged(nsIURI* aURI,
108991:                               uint32_t aChangedAttribute,
 72845:                               const nsAString& aNewValue,
 72845:                               const nsACString& aGUID)
     1: {
  1905:   nsresult rv;
 72845:   if (aChangedAttribute == nsINavHistoryObserver::ATTRIBUTE_FAVICON) {
 60944:     ItemChangeData changeData;
 69981:     rv = aURI->GetSpec(changeData.bookmark.url);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 60944:     changeData.property = NS_LITERAL_CSTRING("favicon");
 80486:     changeData.isAnnotation = false;
 72845:     changeData.newValue = NS_ConvertUTF16toUTF8(aNewValue);
 69981:     changeData.bookmark.lastModified = 0;
 69981:     changeData.bookmark.type = TYPE_BOOKMARK;
 60944: 
  1905:     // Favicons may be set to either pure URIs or to folder URIs
 79445:     bool isPlaceURI;
  1905:     rv = aURI->SchemeIs("place", &isPlaceURI);
  1905:     NS_ENSURE_SUCCESS(rv, rv);
  1905:     if (isPlaceURI) {
 35298:       nsNavHistory* history = nsNavHistory::GetHistoryService();
 35298:       NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
  1905:   
  1905:       nsCOMArray<nsNavHistoryQuery> queries;
  1905:       nsCOMPtr<nsNavHistoryQueryOptions> options;
 69981:       rv = history->QueryStringToQueryArray(changeData.bookmark.url,
 69981:                                             &queries, getter_AddRefs(options));
  1905:       NS_ENSURE_SUCCESS(rv, rv);
  1905: 
 60944:       if (queries.Count() == 1 && queries[0]->Folders().Length() == 1) {
 69981:         // Fetch missing data.
 76962:         rv = FetchItemInfo(queries[0]->Folders()[0], changeData.bookmark);
 69981:         NS_ENSURE_SUCCESS(rv, rv);        
 60944:         NotifyItemChanged(changeData);
 60944:       }
  1905:     }
  1905:     else {
 60944:       nsRefPtr< AsyncGetBookmarksForURI<ItemChangeMethod, ItemChangeData> > notifier =
 60944:         new AsyncGetBookmarksForURI<ItemChangeMethod, ItemChangeData>(this, &nsNavBookmarks::NotifyItemChanged, changeData);
 61984:       notifier->Init();
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 37340: 
     1: NS_IMETHODIMP
 71492: nsNavBookmarks::OnDeleteVisits(nsIURI* aURI, PRTime aVisitTime,
 72841:                                const nsACString& aGUID,
108991:                                uint16_t aReason)
     1: {
 69200:   // Notify "cleartime" only if all visits to the page have been removed.
 69200:   if (!aVisitTime) {
 69200:     // If the page is bookmarked, notify observers for each associated bookmark.
 69200:     ItemChangeData changeData;
 69981:     nsresult rv = aURI->GetSpec(changeData.bookmark.url);
 69981:     NS_ENSURE_SUCCESS(rv, rv);
 69200:     changeData.property = NS_LITERAL_CSTRING("cleartime");
 80486:     changeData.isAnnotation = false;
 69981:     changeData.bookmark.lastModified = 0;
 69981:     changeData.bookmark.type = TYPE_BOOKMARK;
 69200: 
 69200:     nsRefPtr< AsyncGetBookmarksForURI<ItemChangeMethod, ItemChangeData> > notifier =
 69200:       new AsyncGetBookmarksForURI<ItemChangeMethod, ItemChangeData>(this, &nsNavBookmarks::NotifyItemChanged, changeData);
 69200:     notifier->Init();
 69200:   }
     1:   return NS_OK;
     1: }
  1337: 
 37340: 
  1337: // nsIAnnotationObserver
  1337: 
  1337: NS_IMETHODIMP
  1337: nsNavBookmarks::OnPageAnnotationSet(nsIURI* aPage, const nsACString& aName)
  1337: {
  1337:   return NS_OK;
  1337: }
  1337: 
 37340: 
  1337: NS_IMETHODIMP
108991: nsNavBookmarks::OnItemAnnotationSet(int64_t aItemId, const nsACString& aName)
  1337: {
 69981:   BookmarkData bookmark;
 76962:   nsresult rv = FetchItemInfo(aItemId, bookmark);
  1604:   NS_ENSURE_SUCCESS(rv, rv);
  1604: 
 69981:   bookmark.lastModified = PR_Now();
 80946:   rv = SetItemDateInternal(LAST_MODIFIED, bookmark.id, bookmark.lastModified);
 33340:   NS_ENSURE_SUCCESS(rv, rv);
 33340: 
 37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
 33340:                    nsINavBookmarkObserver,
 69981:                    OnItemChanged(bookmark.id,
 69981:                                  aName,
 80486:                                  true,
 69981:                                  EmptyCString(),
 69981:                                  bookmark.lastModified,
 69981:                                  bookmark.type,
 69981:                                  bookmark.parentId,
 69981:                                  bookmark.guid,
 69981:                                  bookmark.parentGuid));
  1337:   return NS_OK;
  1337: }
  1337: 
  1337: 
  1337: NS_IMETHODIMP
  1337: nsNavBookmarks::OnPageAnnotationRemoved(nsIURI* aPage, const nsACString& aName)
  1337: {
  1337:   return NS_OK;
  1337: }
  1337: 
 37340: 
  1337: NS_IMETHODIMP
108991: nsNavBookmarks::OnItemAnnotationRemoved(int64_t aItemId, const nsACString& aName)
  1337: {
 69981:   // As of now this is doing the same as OnItemAnnotationSet, so just forward
 69981:   // the call.
 69981:   nsresult rv = OnItemAnnotationSet(aItemId, aName);
  1604:   NS_ENSURE_SUCCESS(rv, rv);
  1337:   return NS_OK;
  1337: }
