    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is 
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Josh Aas <josh@mozilla.com>
    1:  *   Sylvain Pasche <sylvain.pasche@gmail.com>
 4864:  *   Stuart Morgan <stuart.morgan@alumni.case.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
39278: #include "gfxImageSurface.h"
    1: #include "nsCocoaUtils.h"
13608: #include "nsMenuBarX.h"
13608: #include "nsCocoaWindow.h"
13608: #include "nsCOMPtr.h"
13608: #include "nsIInterfaceRequestorUtils.h"
13608: #include "nsIAppShellService.h"
13608: #include "nsIXULWindow.h"
13608: #include "nsIBaseWindow.h"
13608: #include "nsIServiceManager.h"
15578: #include "nsMenuUtilsX.h"
19704: #include "nsToolkit.h"
 8779: 
 8779: float nsCocoaUtils::MenuBarScreenHeight()
    1: {
11831:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11831: 
    1:   NSArray* allScreens = [NSScreen screens];
 4864:   if ([allScreens count])
 4864:     return [[allScreens objectAtIndex:0] frame].size.height;
 4864:   else
11831:     return 0.0; // If there are no screens, there's not much we can say.
11831: 
11831:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0.0);
    1: }
 4864: 
 8779: float nsCocoaUtils::FlippedScreenY(float y)
 4864: {
 4864:   return MenuBarScreenHeight() - y;
    1: }
    1: 
23738: NSRect nsCocoaUtils::GeckoRectToCocoaRect(const nsIntRect &geckoRect)
    1: {
11831:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11831: 
 4864:   // We only need to change the Y coordinate by starting with the primary screen
    1:   // height, subtracting the gecko Y coordinate, and subtracting the height.
    1:   return NSMakeRect(geckoRect.x,
 4864:                     MenuBarScreenHeight() - (geckoRect.y + geckoRect.height),
    1:                     geckoRect.width,
    1:                     geckoRect.height);
11831: 
11831:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakeRect(0.0, 0.0, 0.0, 0.0));
    1: }
    1: 
23738: nsIntRect nsCocoaUtils::CocoaRectToGeckoRect(const NSRect &cocoaRect)
    1: {
 4864:   // We only need to change the Y coordinate by starting with the primary screen
    1:   // height and subtracting both the cocoa y origin and the height of the
    1:   // cocoa rect.
23738:   nsIntRect rect;
23738:   rect.x = NSToIntRound(cocoaRect.origin.x);
23738:   rect.y = NSToIntRound(FlippedScreenY(cocoaRect.origin.y + cocoaRect.size.height));
23738:   rect.width = NSToIntRound(cocoaRect.origin.x + cocoaRect.size.width) - rect.x;
23738:   rect.height = NSToIntRound(FlippedScreenY(cocoaRect.origin.y)) - rect.y;
23738:   return rect;
    1: }
 8779: 
 8779: NSPoint nsCocoaUtils::ScreenLocationForEvent(NSEvent* anEvent)
 8779: {
11831:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11831: 
31655:   // Don't trust mouse locations of mouse move events, see bug 443178.
35621:   if (!anEvent || [anEvent type] == NSMouseMoved)
31655:     return [NSEvent mouseLocation];
31655: 
 8779:   return [[anEvent window] convertBaseToScreen:[anEvent locationInWindow]];
11831: 
11831:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakePoint(0.0, 0.0));
 8779: }
 8779: 
 8779: BOOL nsCocoaUtils::IsEventOverWindow(NSEvent* anEvent, NSWindow* aWindow)
 8779: {
11831:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11831: 
 8779:   return NSPointInRect(ScreenLocationForEvent(anEvent), [aWindow frame]);
11831: 
11831:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 8779: }
 8779: 
 8779: NSPoint nsCocoaUtils::EventLocationForWindow(NSEvent* anEvent, NSWindow* aWindow)
 8779: {
11831:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11831: 
 8779:   return [aWindow convertScreenToBase:ScreenLocationForEvent(anEvent)];
11831: 
11831:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NSMakePoint(0.0, 0.0));
 8779: }
 8779: 
30550: void nsCocoaUtils::HideOSChromeOnScreen(PRBool aShouldHide, NSScreen* aScreen)
30550: {
30550:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
30550: 
30550:   // Keep track of how many hiding requests have been made, so that they can
30550:   // be nested.
30550:   static int sMenuBarHiddenCount = 0, sDockHiddenCount = 0;
30550: 
30550:   // Always hide the Dock, since it's not necessarily on the primary screen.
30550:   sDockHiddenCount += aShouldHide ? 1 : -1;
30550:   NS_ASSERTION(sMenuBarHiddenCount >= 0, "Unbalanced HideMenuAndDockForWindow calls");
30550: 
30550:   // Only hide the menu bar if the window is on the same screen.
30550:   // The menu bar is always on the first screen in the screen list.
30550:   if (aScreen == [[NSScreen screens] objectAtIndex:0]) {
30550:     sMenuBarHiddenCount += aShouldHide ? 1 : -1;
30550:     NS_ASSERTION(sDockHiddenCount >= 0, "Unbalanced HideMenuAndDockForWindow calls");
30550:   }
30550: 
30550:   if (sMenuBarHiddenCount > 0) {
30550:     ::SetSystemUIMode(kUIModeAllHidden, 0);
30550:   } else if (sDockHiddenCount > 0) {
30550:     ::SetSystemUIMode(kUIModeContentHidden, 0);
30550:   } else {
30550:     ::SetSystemUIMode(kUIModeNormal, 0);
30550:   }
30550: 
30550:   NS_OBJC_END_TRY_ABORT_BLOCK;
30550: }
30550: 
30550: 
13608: #define NS_APPSHELLSERVICE_CONTRACTID "@mozilla.org/appshell/appShellService;1"
13608: nsIWidget* nsCocoaUtils::GetHiddenWindowWidget()
13608: {
13608:   nsCOMPtr<nsIAppShellService> appShell(do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
13608:   if (!appShell) {
13608:     NS_WARNING("Couldn't get AppShellService in order to get hidden window ref");
13608:     return nsnull;
13608:   }
13608:   
13608:   nsCOMPtr<nsIXULWindow> hiddenWindow;
13608:   appShell->GetHiddenWindow(getter_AddRefs(hiddenWindow));
13608:   if (!hiddenWindow) {
13608:     // Don't warn, this happens during shutdown, bug 358607.
13608:     return nsnull;
13608:   }
13608:   
13608:   nsCOMPtr<nsIBaseWindow> baseHiddenWindow;
13608:   baseHiddenWindow = do_GetInterface(hiddenWindow);
13608:   if (!baseHiddenWindow) {
13608:     NS_WARNING("Couldn't get nsIBaseWindow from hidden window (nsIXULWindow)");
13608:     return nsnull;
13608:   }
13608:   
13608:   nsCOMPtr<nsIWidget> hiddenWindowWidget;
13608:   if (NS_FAILED(baseHiddenWindow->GetMainWidget(getter_AddRefs(hiddenWindowWidget)))) {
13608:     NS_WARNING("Couldn't get nsIWidget from hidden window (nsIBaseWindow)");
13608:     return nsnull;
13608:   }
13608:   
13608:   return hiddenWindowWidget;
13608: }
13608: 
13608: void nsCocoaUtils::PrepareForNativeAppModalDialog()
13608: {
13608:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
13608: 
13854:   // Don't do anything if this is embedding. We'll assume that if there is no hidden
13854:   // window we shouldn't do anything, and that should cover the embedding case.
15578:   nsMenuBarX* hiddenWindowMenuBar = nsMenuUtilsX::GetHiddenWindowMenuBar();
13854:   if (!hiddenWindowMenuBar)
13854:     return;
13854: 
13608:   // First put up the hidden window menu bar so that app menu event handling is correct.
13608:   hiddenWindowMenuBar->Paint();
13608: 
13608:   NSMenu* mainMenu = [NSApp mainMenu];
13608:   NS_ASSERTION([mainMenu numberOfItems] > 0, "Main menu does not have any items, something is terribly wrong!");
13608:   
13608:   // Create new menu bar for use with modal dialog
13608:   NSMenu* newMenuBar = [[NSMenu alloc] initWithTitle:@""];
13608:   
13608:   // Swap in our app menu. Note that the event target is whatever window is up when
13608:   // the app modal dialog goes up.
13608:   NSMenuItem* firstMenuItem = [[mainMenu itemAtIndex:0] retain];
13608:   [mainMenu removeItemAtIndex:0];
13608:   [newMenuBar insertItem:firstMenuItem atIndex:0];
13608:   [firstMenuItem release];
13608:   
13608:   // Add standard edit menu
15578:   [newMenuBar addItem:nsMenuUtilsX::GetStandardEditMenuItem()];
13608:   
13608:   // Show the new menu bar
13608:   [NSApp setMainMenu:newMenuBar];
13608:   [newMenuBar release];
13608:   
13608:   NS_OBJC_END_TRY_ABORT_BLOCK;
13608: }
13608: 
13608: void nsCocoaUtils::CleanUpAfterNativeAppModalDialog()
13608: {
13608:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
13608: 
13854:   // Don't do anything if this is embedding. We'll assume that if there is no hidden
13854:   // window we shouldn't do anything, and that should cover the embedding case.
15578:   nsMenuBarX* hiddenWindowMenuBar = nsMenuUtilsX::GetHiddenWindowMenuBar();
13854:   if (!hiddenWindowMenuBar)
13854:     return;
13854: 
13608:   NSWindow* mainWindow = [NSApp mainWindow];
13854:   if (!mainWindow)
13608:     hiddenWindowMenuBar->Paint();
13854:   else
13608:     [WindowDelegate paintMenubarForWindow:mainWindow];
13608: 
13608:   NS_OBJC_END_TRY_ABORT_BLOCK;
13608: }
39278: 
39829: nsresult nsCocoaUtils::CreateCGImageFromSurface(gfxImageSurface *aFrame, CGImageRef *aResult)
39278: {
39278: 
39829:   PRInt32 width = aFrame->Width();
39829:   PRInt32 stride = aFrame->Stride();
39829:   PRInt32 height = aFrame->Height();
39278:   if ((stride % 4 != 0) || (height < 1) || (width < 1)) {
39278:     return NS_ERROR_FAILURE;
39278:   }
39278: 
39278:   // Create a CGImageRef with the bits from the image, taking into account
39278:   // the alpha ordering and endianness of the machine so we don't have to
39278:   // touch the bits ourselves.
39278:   CGDataProviderRef dataProvider = ::CGDataProviderCreateWithData(NULL,
39829:                                                                   aFrame->Data(),
39278:                                                                   stride * height,
39278:                                                                   NULL);
39278:   CGColorSpaceRef colorSpace = ::CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
39278:   *aResult = ::CGImageCreate(width,
39278:                              height,
39278:                              8,
39278:                              32,
39278:                              stride,
39278:                              colorSpace,
39278:                              kCGBitmapByteOrder32Host | kCGImageAlphaFirst,
39278:                              dataProvider,
39278:                              NULL,
39278:                              0,
39278:                              kCGRenderingIntentDefault);
39278:   ::CGColorSpaceRelease(colorSpace);
39278:   ::CGDataProviderRelease(dataProvider);
39278:   return *aResult ? NS_OK : NS_ERROR_FAILURE;
39278: }
39278: 
39278: nsresult nsCocoaUtils::CreateNSImageFromCGImage(CGImageRef aInputImage, NSImage **aResult)
39278: {
39278:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
39278: 
39278:   PRInt32 width = ::CGImageGetWidth(aInputImage);
39278:   PRInt32 height = ::CGImageGetHeight(aInputImage);
39278:   NSRect imageRect = ::NSMakeRect(0.0, 0.0, width, height);
39278: 
39278:   // Create a new image to receive the Quartz image data.
39278:   *aResult = [[NSImage alloc] initWithSize:imageRect.size];
39278: 
39278:   [*aResult lockFocus];
39278: 
39278:   // Get the Quartz context and draw.
39278:   CGContextRef imageContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
39278:   ::CGContextDrawImage(imageContext, *(CGRect*)&imageRect, aInputImage);
39278: 
39278:   [*aResult unlockFocus];
39278:   return NS_OK;
39278: 
39278:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
39278: }
39278: 
39278: nsresult nsCocoaUtils::CreateNSImageFromImageContainer(imgIContainer *aImage, PRUint32 aWhichFrame, NSImage **aResult)
39278: {
39829:   nsRefPtr<gfxImageSurface> frame;
39829:   nsresult rv = aImage->CopyFrame(aWhichFrame,
39829:                                   imgIContainer::FLAG_SYNC_DECODE,
39829:                                   getter_AddRefs(frame));
39829:   if (NS_FAILED(rv) || !frame) {
39829:     return NS_ERROR_FAILURE;
39829:   }
39278:   CGImageRef imageRef = NULL;
39829:   rv = nsCocoaUtils::CreateCGImageFromSurface(frame, &imageRef);
39278:   if (NS_FAILED(rv) || !imageRef) {
39278:     return NS_ERROR_FAILURE;
39278:   }
39278: 
39278:   rv = nsCocoaUtils::CreateNSImageFromCGImage(imageRef, aResult);
39278:   if (NS_FAILED(rv) || !aResult) {
39278:     return NS_ERROR_FAILURE;
39278:   }
39278:   ::CGImageRelease(imageRef);
39278:   return NS_OK;
39278: }
39278: 
