    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
    1: 
    1: #ifndef nsDOMStorage_h___
    1: #define nsDOMStorage_h___
    1: 
    1: #include "nscore.h"
    1: #include "nsAutoPtr.h"
28438: #include "nsIDOMStorageObsolete.h"
    1: #include "nsIDOMStorage.h"
    1: #include "nsIDOMStorageItem.h"
34057: #include "nsIPermissionManager.h"
    1: #include "nsInterfaceHashtable.h"
29263: #include "nsVoidArray.h"
23904: #include "nsTArray.h"
    1: #include "nsPIDOMStorage.h"
    1: #include "nsIDOMToString.h"
    1: #include "nsDOMEvent.h"
    1: #include "nsIDOMStorageEvent.h"
 6643: #include "nsIDOMStorageManager.h"
 6773: #include "nsCycleCollectionParticipant.h"
40660: #include "nsIObserver.h"
56436: #include "nsITimer.h"
56436: #include "nsWeakReference.h"
56436: 
28495: #include "nsDOMStorageDBWrapper.h"
    1: 
34057: #define IS_PERMISSION_ALLOWED(perm) \
34057:       ((perm) != nsIPermissionManager::UNKNOWN_ACTION && \
34057:       (perm) != nsIPermissionManager::DENY_ACTION)
34057: 
    1: class nsDOMStorage;
28438: class nsIDOMStorage;
    1: class nsDOMStorageItem;
60667: class nsDOMStoragePersistentDB;
56436: 
58092: namespace mozilla {
58092: namespace dom {
58092: class StorageParent;
58092: }
58092: }
58092: using mozilla::dom::StorageParent;
58092: 
58092: class DOMStorageImpl;
58092: 
93686: class nsDOMStorageEntry : public nsPtrHashKey<const void>
    1: {
    1: public:
    1:   nsDOMStorageEntry(KeyTypePointer aStr);
    1:   nsDOMStorageEntry(const nsDOMStorageEntry& aToCopy);
    1:   ~nsDOMStorageEntry();
    1: 
    1:   // weak reference so that it can be deleted when no longer used
58092:   DOMStorageImpl* mStorage;
    1: };
    1: 
    1: class nsSessionStorageEntry : public nsStringHashKey
    1: {
    1: public:
    1:   nsSessionStorageEntry(KeyTypePointer aStr);
    1:   nsSessionStorageEntry(const nsSessionStorageEntry& aToCopy);
    1:   ~nsSessionStorageEntry();
    1: 
    1:   nsRefPtr<nsDOMStorageItem> mItem;
    1: };
    1: 
 6643: class nsDOMStorageManager : public nsIDOMStorageManager
 6643:                           , public nsIObserver
83036:                           , public nsSupportsWeakReference
    1: {
    1: public:
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS
    1: 
 6643:   // nsIDOMStorageManager
 6643:   NS_DECL_NSIDOMSTORAGEMANAGER
 6643: 
    1:   // nsIObserver
    1:   NS_DECL_NSIOBSERVER
    1: 
25361:   nsDOMStorageManager();
25361: 
58092:   void AddToStoragesHash(DOMStorageImpl* aStorage);
58092:   void RemoveFromStoragesHash(DOMStorageImpl* aStorage);
    1: 
    1:   nsresult ClearAllStorages();
    1: 
99466:   bool InPrivateBrowsingMode() { return mInPrivateBrowsing; }
99466: 
    1:   static nsresult Initialize();
 6643:   static nsDOMStorageManager* GetInstance();
    1:   static void Shutdown();
83067:   static void ShutdownDB();
    1: 
59411:   /**
59411:    * Checks whether there is any data waiting to be flushed from a temp table.
59411:    */
79445:   bool UnflushedDataExists();
59411: 
    1:   static nsDOMStorageManager* gStorageManager;
    1: 
    1: protected:
    1: 
    1:   nsTHashtable<nsDOMStorageEntry> mStorages;
99466:   bool mInPrivateBrowsing;
    1: };
    1: 
99466: class DOMStorageBase : public nsISupports
58092: {
58092: public:
58092:   DOMStorageBase();
58092:   DOMStorageBase(DOMStorageBase&);
58092: 
99466:   virtual void InitAsSessionStorage(nsIURI* aDomainURI);
99466:   virtual void InitAsLocalStorage(nsIURI* aDomainURI, bool aCanUseChromePersist);
58092: 
58092:   virtual nsTArray<nsString>* GetKeys(bool aCallerSecure) = 0;
58092:   virtual nsresult GetLength(bool aCallerSecure, PRUint32* aLength) = 0;
58092:   virtual nsresult GetKey(bool aCallerSecure, PRUint32 aIndex, nsAString& aKey) = 0;
58092:   virtual nsIDOMStorageItem* GetValue(bool aCallerSecure, const nsAString& aKey,
58092:                                       nsresult* rv) = 0;
58092:   virtual nsresult SetValue(bool aCallerSecure, const nsAString& aKey,
58092:                             const nsAString& aData, nsAString& aOldValue) = 0;
58092:   virtual nsresult RemoveValue(bool aCallerSecure, const nsAString& aKey,
58092:                                nsAString& aOldValue) = 0;
58092:   virtual nsresult Clear(bool aCallerSecure, PRInt32* aOldCount) = 0;
58092:   
58092:   // If true, the contents of the storage should be stored in the
58092:   // database, otherwise this storage should act like a session
58092:   // storage.
58092:   // This call relies on mSessionOnly, and should only be used
58092:   // after a CacheStoragePermissions() call.  See the comments
58092:   // for mSessionOnly below.
79445:   bool UseDB() {
58092:     return mUseDB;
58092:   }
58092: 
58092:   // retrieve the value and secure state corresponding to a key out of storage.
58092:   virtual nsresult
58092:   GetDBValue(const nsAString& aKey,
58092:              nsAString& aValue,
79445:              bool* aSecure) = 0;
58092: 
58092:   // set the value corresponding to a key in the storage. If
58092:   // aSecure is false, then attempts to modify a secure value
58092:   // throw NS_ERROR_DOM_INVALID_ACCESS_ERR
58092:   virtual nsresult
58092:   SetDBValue(const nsAString& aKey,
58092:              const nsAString& aValue,
79445:              bool aSecure) = 0;
58092: 
58092:   // set the value corresponding to a key as secure.
58092:   virtual nsresult
79445:   SetSecure(const nsAString& aKey, bool aSecure) = 0;
58092: 
58092:   virtual nsresult
58092:   CloneFrom(bool aCallerSecure, DOMStorageBase* aThat) = 0;
58092: 
58092:   // e.g. "moc.rab.oof.:" or "moc.rab.oof.:http:80" depending
58092:   // on association with a domain (globalStorage) or
58092:   // an origin (localStorage).
58092:   nsCString& GetScopeDBKey() {return mScopeDBKey;}
58092: 
58092:   // e.g. "moc.rab.%" - reversed eTLD+1 subpart of the domain or
58092:   // reversed offline application allowed domain.
79445:   nsCString& GetQuotaDomainDBKey(bool aOfflineAllowed)
58092:   {
58092:     return aOfflineAllowed ? mQuotaDomainDBKey : mQuotaETLDplus1DomainDBKey;
58092:   }
58092: 
58092:   virtual bool CacheStoragePermissions() = 0;
58092: 
58092: protected:
58092:   friend class nsDOMStorageManager;
58092:   friend class nsDOMStorage;
58092: 
58092:   nsPIDOMStorage::nsDOMStorageType mStorageType;
58092:   
58092:   // true if the storage database should be used for values
79445:   bool mUseDB;
58092: 
58092:   // true if the preferences indicates that this storage should be
58092:   // session only. This member is updated by
58092:   // CacheStoragePermissions(), using the current principal.
58092:   // CacheStoragePermissions() must be called at each entry point to
58092:   // make sure this stays up to date.
79445:   bool mSessionOnly;
58092: 
58092:   // domain this store is associated with
58092:   nsCString mDomain;
58092: 
58092:   // keys are used for database queries.
58092:   // see comments of the getters bellow.
58092:   nsCString mScopeDBKey;
58092:   nsCString mQuotaETLDplus1DomainDBKey;
58092:   nsCString mQuotaDomainDBKey;
58092: 
58092:   bool mCanUseChromePersist;
58092: };
58092: 
58092: class DOMStorageImpl : public DOMStorageBase
99466: 
58092: {
58092: public:
99466:   NS_DECL_CYCLE_COLLECTION_CLASS(DOMStorageImpl)
58092:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
58092: 
58092:   DOMStorageImpl(nsDOMStorage*);
58092:   DOMStorageImpl(nsDOMStorage*, DOMStorageImpl&);
58092:   ~DOMStorageImpl();
58092: 
99466:   virtual void InitAsSessionStorage(nsIURI* aDomainURI);
99466:   virtual void InitAsLocalStorage(nsIURI* aDomainURI, bool aCanUseChromePersist);
58092: 
79445:   bool SessionOnly() {
58092:     return mSessionOnly;
58092:   }
58092: 
58092:   virtual nsTArray<nsString>* GetKeys(bool aCallerSecure);
58092:   virtual nsresult GetLength(bool aCallerSecure, PRUint32* aLength);
58092:   virtual nsresult GetKey(bool aCallerSecure, PRUint32 aIndex, nsAString& aKey);
58092:   virtual nsIDOMStorageItem* GetValue(bool aCallerSecure, const nsAString& aKey,
58092:                                       nsresult* rv);
58092:   virtual nsresult SetValue(bool aCallerSecure, const nsAString& aKey,
58092:                             const nsAString& aData, nsAString& aOldValue);
58092:   virtual nsresult RemoveValue(bool aCallerSecure, const nsAString& aKey,
58092:                                nsAString& aOldValue);
58092:   virtual nsresult Clear(bool aCallerSecure, PRInt32* aOldCount);
58092: 
58092:   // cache the keys from the database for faster lookup
58092:   nsresult CacheKeysFromDB();
58092: 
78721:   PRUint64 CachedVersion() { return mItemsCachedVersion; }
78721:   void SetCachedVersion(PRUint64 version) { mItemsCachedVersion = version; }
78721:   
58092:   // Some privileged internal pages can use a persistent storage even in
58092:   // session-only or private-browsing modes.
58092:   bool CanUseChromePersist();
58092: 
58092:   // retrieve the value and secure state corresponding to a key out of storage
58092:   // that has been cached in mItems hash table.
58092:   nsresult
58092:   GetCachedValue(const nsAString& aKey,
58092:                  nsAString& aValue,
79445:                  bool* aSecure);
58092: 
58092:   // retrieve the value and secure state corresponding to a key out of storage.
58092:   virtual nsresult
58092:   GetDBValue(const nsAString& aKey,
58092:              nsAString& aValue,
79445:              bool* aSecure);
58092: 
58092:   // set the value corresponding to a key in the storage. If
58092:   // aSecure is false, then attempts to modify a secure value
58092:   // throw NS_ERROR_DOM_INVALID_ACCESS_ERR
58092:   virtual nsresult
58092:   SetDBValue(const nsAString& aKey,
58092:              const nsAString& aValue,
79445:              bool aSecure);
58092: 
58092:   // set the value corresponding to a key as secure.
58092:   virtual nsresult
79445:   SetSecure(const nsAString& aKey, bool aSecure);
58092: 
58092:   // clear all values from the store
58092:   void ClearAll();
58092: 
58092:   virtual nsresult
58092:   CloneFrom(bool aCallerSecure, DOMStorageBase* aThat);
58092: 
58092:   virtual bool CacheStoragePermissions();
58092: 
58092: private:
58092:   static nsDOMStorageDBWrapper* gStorageDB;
58092:   friend class nsDOMStorageManager;
60667:   friend class nsDOMStoragePersistentDB;
58092:   friend class StorageParent;
58092: 
58092:   void Init(nsDOMStorage*);
58092: 
60073:   // Cross-process storage implementations never have InitAs(Session|Local|Global)Storage
60073:   // called, so the appropriate initialization needs to happen from the child.
60073:   void InitFromChild(bool aUseDB, bool aCanUseChromePersist, bool aSessionOnly,
99466:                      const nsACString& aDomain,
60073:                      const nsACString& aScopeDBKey,
60073:                      const nsACString& aQuotaDomainDBKey,
60073:                      const nsACString& aQuotaETLDplus1DomainDBKey,
60073:                      PRUint32 aStorageType);
60073:   void SetSessionOnly(bool aSessionOnly);
60073: 
58092:   static nsresult InitDB();
58092: 
78721:   // 0 initially or a positive data version number assigned by gStorageDB
78721:   // after keys have been cached from the database
78721:   PRUint64 mItemsCachedVersion;
58092: 
58092:   // the key->value item pairs
58092:   nsTHashtable<nsSessionStorageEntry> mItems;
58092: 
58092:   // Weak reference to the owning storage instance
58092:   nsDOMStorage* mOwner;
58092: };
58092: 
95448: class nsDOMStorage2;
95448: 
28438: class nsDOMStorage : public nsIDOMStorageObsolete,
99466:                      public nsPIDOMStorage
    1: {
    1: public:
    1:   nsDOMStorage();
26323:   nsDOMStorage(nsDOMStorage& aThat);
    1:   virtual ~nsDOMStorage();
    1: 
 6773:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
28438:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsDOMStorage, nsIDOMStorageObsolete)
    1: 
28438:   NS_DECL_NSIDOMSTORAGEOBSOLETE
    1: 
28438:   // Helpers for implementing nsIDOMStorage
26323:   nsresult GetItem(const nsAString& key, nsAString& aData);
26323:   nsresult Clear();
26323: 
    1:   // nsPIDOMStorage
99466:   virtual nsresult InitAsSessionStorage(nsIPrincipal *aPrincipal, const nsSubstring &aDocumentURI);
99466:   virtual nsresult InitAsLocalStorage(nsIPrincipal *aPrincipal, const nsSubstring &aDocumentURI);
28676:   virtual already_AddRefed<nsIDOMStorage> Clone();
37608:   virtual already_AddRefed<nsIDOMStorage> Fork(const nsSubstring &aDocumentURI);
79445:   virtual bool IsForkOf(nsIDOMStorage* aThat);
    1:   virtual nsTArray<nsString> *GetKeys();
28676:   virtual nsIPrincipal* Principal();
79445:   virtual bool CanAccess(nsIPrincipal *aPrincipal);
37608:   virtual nsDOMStorageType StorageType();
    1: 
23579:   // Check whether storage may be used by the caller, and whether it
23579:   // is session only.  Returns true if storage may be used.
79445:   static bool
99466:   CanUseStorage(bool* aSessionOnly);
    1: 
55087:   // Check whether this URI can use chrome persist storage.  This kind of
55087:   // storage can bypass cookies limits, private browsing and uses the offline
55087:   // apps quota.
79445:   static bool
55087:   URICanUseChromePersist(nsIURI* aURI);
55087:   
23579:   // Check whether storage may be used.  Updates mSessionOnly based on
23579:   // the result of CanUseStorage.
79445:   bool
23579:   CacheStoragePermissions();
    1: 
21159:   nsIDOMStorageItem* GetNamedItem(const nsAString& aKey, nsresult* aResult);
21159: 
79445:   nsresult SetSecure(const nsAString& aKey, bool aSecure)
58092:   {
58092:     return mStorageImpl->SetSecure(aKey, aSecure);
58092:   }
56436: 
58092:   nsresult CloneFrom(nsDOMStorage* aThat);
56436: 
    1:  protected:
26323:   friend class nsDOMStorage2;
56436:   friend class nsDOMStoragePersistentDB;
    1: 
58092:   nsRefPtr<DOMStorageBase> mStorageImpl;
    1: 
79445:   bool CanAccessSystem(nsIPrincipal *aPrincipal);
26323: 
37608:   // document URI of the document this storage is bound to
37608:   nsString mDocumentURI;
37608: 
26323:   // true if this storage was initialized as a localStorage object.  localStorage
26323:   // objects are scoped to scheme/host/port in the database, while globalStorage
26323:   // objects are scoped just to host.  this flag also tells the manager to map
26323:   // this storage also in mLocalStorages hash table.
37608:   nsDOMStorageType mStorageType;
26323: 
28820:   friend class nsIDOMStorage2;
94224:   nsCOMPtr<nsIPrincipal> mPrincipal;
95448:   nsDOMStorage2* mEventBroadcaster;
    1: };
    1: 
28438: class nsDOMStorage2 : public nsIDOMStorage,
99466:                       public nsPIDOMStorage
26323: {
26323: public:
26323:   // nsISupports
26323:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
28438:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsDOMStorage2, nsIDOMStorage)
26323: 
28676:   nsDOMStorage2(nsDOMStorage2& aThat);
28676:   nsDOMStorage2();
28676: 
28438:   NS_DECL_NSIDOMSTORAGE
26323: 
26323:   // nsPIDOMStorage
99466:   virtual nsresult InitAsSessionStorage(nsIPrincipal *aPrincipal, const nsSubstring &aDocumentURI);
99466:   virtual nsresult InitAsLocalStorage(nsIPrincipal *aPrincipal, const nsSubstring &aDocumentURI);
28676:   virtual already_AddRefed<nsIDOMStorage> Clone();
37608:   virtual already_AddRefed<nsIDOMStorage> Fork(const nsSubstring &aDocumentURI);
79445:   virtual bool IsForkOf(nsIDOMStorage* aThat);
26323:   virtual nsTArray<nsString> *GetKeys();
28676:   virtual nsIPrincipal* Principal();
79445:   virtual bool CanAccess(nsIPrincipal *aPrincipal);
37608:   virtual nsDOMStorageType StorageType();
95448: 
95448:   void BroadcastChangeNotification(const nsSubstring &aKey,
37608:                                    const nsSubstring &aOldValue,
37608:                                    const nsSubstring &aNewValue);
97753:   void InitAsSessionStorageFork(nsIPrincipal *aPrincipal,
37608:                                 const nsSubstring &aDocumentURI,
97753:                                 nsDOMStorage* aStorage);
26323: 
26323: private:
26323:   // storages bound to an origin hold the principal to
26323:   // make security checks against it
26323:   nsCOMPtr<nsIPrincipal> mPrincipal;
26323: 
37608:   // Needed for the storage event, this is address of the document this storage
37608:   // is bound to
37608:   nsString mDocumentURI;
26323:   nsRefPtr<nsDOMStorage> mStorage;
26323: };
26323: 
    1: class nsDOMStorageItem : public nsIDOMStorageItem,
    1:                          public nsIDOMToString
    1: {
    1: public:
58092:   nsDOMStorageItem(DOMStorageBase* aStorage,
    1:                    const nsAString& aKey,
    1:                    const nsAString& aValue,
79445:                    bool aSecure);
    1:   virtual ~nsDOMStorageItem();
    1: 
    1:   // nsISupports
 6773:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 6773:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsDOMStorageItem, nsIDOMStorageItem)
    1: 
28438:   // nsIDOMStorageObsolete
    1:   NS_DECL_NSIDOMSTORAGEITEM
    1: 
    1:   // nsIDOMToString
    1:   NS_DECL_NSIDOMTOSTRING
    1: 
79445:   bool IsSecure()
    1:   {
    1:     return mSecure;
    1:   }
    1: 
79445:   void SetSecureInternal(bool aSecure)
    1:   {
    1:     mSecure = aSecure;
    1:   }
    1: 
    1:   const nsAString& GetValueInternal()
    1:   {
    1:     return mValue;
    1:   }
    1: 
    1:   const void SetValueInternal(const nsAString& aValue)
    1:   {
    1:     mValue = aValue;
    1:   }
    1: 
    1:   void ClearValue()
    1:   {
    1:     mValue.Truncate();
    1:   }
    1: 
    1: protected:
    1: 
    1:   // true if this value is for secure sites only
79445:   bool mSecure;
    1: 
    1:   // key for the item
    1:   nsString mKey;
    1: 
    1:   // value of the item
    1:   nsString mValue;
    1: 
    1:   // If this item came from the db, mStorage points to the storage
    1:   // object where this item came from.
58092:   nsRefPtr<DOMStorageBase> mStorage;
    1: };
    1: 
    1: class nsDOMStorageEvent : public nsDOMEvent,
    1:                           public nsIDOMStorageEvent
    1: {
    1: public:
37608:   nsDOMStorageEvent()
37608:     : nsDOMEvent(nsnull, nsnull)
    1:   {
    1:   }
    1: 
    1:   virtual ~nsDOMStorageEvent()
    1:   {
    1:   }
    1: 
    1:   nsresult Init();
    1: 
42550:   NS_DECL_ISUPPORTS_INHERITED
42550:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsDOMStorageEvent, nsDOMEvent)
42550: 
    1:   NS_DECL_NSIDOMSTORAGEEVENT
    1:   NS_FORWARD_NSIDOMEVENT(nsDOMEvent::)
    1: 
91788:   virtual nsresult InitFromCtor(const nsAString& aType,
91788:                                 JSContext* aCx, jsval* aVal);
    1: protected:
37608:   nsString mKey;
37608:   nsString mOldValue;
37608:   nsString mNewValue;
37608:   nsString mUrl;
37608:   nsCOMPtr<nsIDOMStorage> mStorageArea;
37608: };
37608: 
46997: nsresult
28676: NS_NewDOMStorage2(nsISupports* aOuter, REFNSIID aIID, void** aResult);
28676: 
34057: PRUint32
34057: GetOfflinePermission(const nsACString &aDomain);
34057: 
79445: bool
34057: IsOfflineAllowed(const nsACString &aDomain);
34057: 
    1: #endif /* nsDOMStorage_h___ */
