61944: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
38801:  * ***** BEGIN LICENSE BLOCK *****
38801:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
38801:  *
38801:  * The contents of this file are subject to the Mozilla Public License Version
38801:  * 1.1 (the "License"); you may not use this file except in compliance with
38801:  * the License. You may obtain a copy of the License at
38801:  * http://www.mozilla.org/MPL/
38801:  *
38801:  * Software distributed under the License is distributed on an "AS IS" basis,
38801:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
38801:  * for the specific language governing rights and limitations under the
38801:  * License.
38801:  *
38801:  * The Original Code is Mozilla Corporation code.
38801:  *
38801:  * The Initial Developer of the Original Code is Mozilla Foundation.
38801:  * Portions created by the Initial Developer are Copyright (C) 2009
38801:  * the Initial Developer. All Rights Reserved.
38801:  *
38801:  * Contributor(s):
38801:  *   Robert O'Callahan <robert@ocallahan.org>
48140:  *   Chris Jones <jones.chris.g@gmail.com>
38801:  *
38801:  * Alternatively, the contents of this file may be used under the terms of
38801:  * either the GNU General Public License Version 2 or later (the "GPL"), or
38801:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
38801:  * in which case the provisions of the GPL or the LGPL are applicable instead
38801:  * of those above. If you wish to allow use of your version of this file only
38801:  * under the terms of either the GPL or the LGPL, and not to allow others to
38801:  * use your version of this file under the terms of the MPL, indicate your
38801:  * decision by deleting the provisions above and replace them with the notice
38801:  * and other provisions required by the GPL or the LGPL. If you do not delete
38801:  * the provisions above, a recipient may use your version of this file under
38801:  * the terms of any one of the MPL, the GPL or the LGPL.
38801:  *
38801:  * ***** END LICENSE BLOCK ***** */
38801: 
48141: #include "gfxSharedImageSurface.h"
48141: 
48140: #include "mozilla/layers/PLayerChild.h"
48140: #include "mozilla/layers/PLayersChild.h"
48141: #include "mozilla/layers/PLayersParent.h"
72427: #include "mozilla/gfx/2D.h"
72427: 
48141: #include "ipc/ShadowLayerChild.h"
48140: 
38801: #include "BasicLayers.h"
39498: #include "ImageLayers.h"
39498: 
38801: #include "nsTArray.h"
38801: #include "nsGUIEvent.h"
39498: #include "gfxContext.h"
42402: #include "gfxImageSurface.h"
39498: #include "gfxPattern.h"
47108: #include "gfxPlatform.h"
42402: #include "gfxUtils.h"
47108: #include "ThebesLayerBuffer.h"
47767: #include "nsIWidget.h"
62698: #include "ReadbackProcessor.h"
69106: #ifdef MOZ_X11
69106: #include "gfxXlibSurface.h"
69106: #endif
42402: 
42402: #include "GLContext.h"
77289: #include "pixman.h"
38801: 
38801: namespace mozilla {
38801: namespace layers {
38801: 
38801: class BasicContainerLayer;
48140: class ShadowableLayer;
38801: 
38801: /**
38801:  * This is the ImplData for all Basic layers. It also exposes methods
39498:  * private to the Basic implementation that are common to all Basic layer types.
39498:  * In particular, there is an internal Paint() method that we can use
39498:  * to paint the contents of non-Thebes layers.
39498:  *
39498:  * The class hierarchy for Basic layers is like this:
39498:  *                                 BasicImplData
39498:  * Layer                            |   |   |
39498:  *  |                               |   |   |
39498:  *  +-> ContainerLayer              |   |   |
39498:  *  |    |                          |   |   |
39498:  *  |    +-> BasicContainerLayer <--+   |   |
39498:  *  |                                   |   |
39498:  *  +-> ThebesLayer                     |   |
39498:  *  |    |                              |   |
39498:  *  |    +-> BasicThebesLayer <---------+   |
39498:  *  |                                       |
39498:  *  +-> ImageLayer                          |
39498:  *       |                                  |
39498:  *       +-> BasicImageLayer <--------------+
38801:  */
38801: class BasicImplData {
38801: public:
80486:   BasicImplData() : mHidden(false),
80486:     mClipToVisibleRegion(false), mOperator(gfxContext::OPERATOR_OVER)
38801:   {
38801:     MOZ_COUNT_CTOR(BasicImplData);
38801:   }
48140:   virtual ~BasicImplData()
38801:   {
38801:     MOZ_COUNT_DTOR(BasicImplData);
38801:   }
38801: 
39498:   /**
39498:    * Layers that paint themselves, such as ImageLayers, should paint
39498:    * in response to this method call. aContext will already have been
39498:    * set up to account for all the properties of the layer (transform,
39498:    * opacity, etc).
39498:    */
62698:   virtual void Paint(gfxContext* aContext) {}
62698: 
62698:   /**
62698:    * Like Paint() but called for ThebesLayers with the additional parameters
62698:    * they need.
75305:    * If mClipToVisibleRegion is set, then the layer must clip to its
75305:    * effective visible region (snapped or unsnapped, it doesn't matter).
62698:    */
62698:   virtual void PaintThebes(gfxContext* aContext,
42593:                            LayerManager::DrawThebesLayerCallback aCallback,
62698:                            void* aCallbackData,
62698:                            ReadbackProcessor* aReadback) {}
48140: 
48142:   virtual ShadowableLayer* AsShadowableLayer() { return nsnull; }
50999: 
50999:   /**
55433:    * Implementations return true here if they *must* retain their
55433:    * layer contents.  This is true of shadowable layers with shadows,
55433:    * because there's no target on which to composite directly in the
55433:    * layer-publishing child process.
55433:    */
55433:   virtual bool MustRetainContent() { return false; }
55433: 
55433:   /**
50999:    * Layers will get this call when their layer manager is destroyed, this
50999:    * indicates they should clear resources they don't really need after their
50999:    * LayerManager ceases to exist.
50999:    */
50999:   virtual void ClearCachedResources() {}
57615: 
57615:   /**
71025:    * This variable is set by MarkLayersHidden() before painting. It indicates
71025:    * that the layer should not be composited during this transaction.
57615:    */
79445:   void SetHidden(bool aCovered) { mHidden = aCovered; }
79445:   bool IsHidden() const { return false; }
71025:   /**
71025:    * This variable is set by MarkLayersHidden() before painting. This is
71025:    * the operator to be used when compositing the layer in this transaction. It must
71025:    * be OVER or SOURCE.
71025:    */
71025:   void SetOperator(gfxContext::GraphicsOperator aOperator)
71025:   {
71025:     NS_ASSERTION(aOperator == gfxContext::OPERATOR_OVER ||
71025:                  aOperator == gfxContext::OPERATOR_SOURCE,
71025:                  "Bad composition operator");
71025:     mOperator = aOperator;
71025:   }
71025:   gfxContext::GraphicsOperator GetOperator() const { return mOperator; }
57615: 
79445:   bool GetClipToVisibleRegion() { return mClipToVisibleRegion; }
79445:   void SetClipToVisibleRegion(bool aClip) { mClipToVisibleRegion = aClip; }
75305: 
57615: protected:
79445:   bool mHidden;
79445:   bool mClipToVisibleRegion;
71025:   gfxContext::GraphicsOperator mOperator;
71025: };
71025: 
71025: class AutoSetOperator {
71025: public:
71025:   AutoSetOperator(gfxContext* aContext, gfxContext::GraphicsOperator aOperator) {
71025:     if (aOperator != gfxContext::OPERATOR_OVER) {
71025:       aContext->SetOperator(aOperator);
71025:       mContext = aContext;
71025:     }
71025:   }
71025:   ~AutoSetOperator() {
71025:     if (mContext) {
71025:       mContext->SetOperator(gfxContext::OPERATOR_OVER);
71025:     }
71025:   }
71025: private:
71025:   nsRefPtr<gfxContext> mContext;
38801: };
38801: 
38801: static BasicImplData*
38801: ToData(Layer* aLayer)
38801: {
38801:   return static_cast<BasicImplData*>(aLayer->ImplData());
38801: }
38801: 
55445: template<class Container>
55445: static void ContainerInsertAfter(Layer* aChild, Layer* aAfter, Container* aContainer);
55445: template<class Container>
55445: static void ContainerRemoveChild(Layer* aChild, Container* aContainer);
55445: 
71025: class BasicContainerLayer : public ContainerLayer, public BasicImplData {
55445:   template<class Container>
55445:   friend void ContainerInsertAfter(Layer* aChild, Layer* aAfter, Container* aContainer);
55445:   template<class Container>
55445:   friend void ContainerRemoveChild(Layer* aChild, Container* aContainer);
55445: 
38801: public:
38801:   BasicContainerLayer(BasicLayerManager* aManager) :
38801:     ContainerLayer(aManager, static_cast<BasicImplData*>(this))
38801:   {
38801:     MOZ_COUNT_CTOR(BasicContainerLayer);
80486:     mSupportsComponentAlphaChildren = true;
38801:   }
38801:   virtual ~BasicContainerLayer();
38801: 
38801:   virtual void SetVisibleRegion(const nsIntRegion& aRegion)
38801:   {
38801:     NS_ASSERTION(BasicManager()->InConstruction(),
38801:                  "Can only set properties in construction phase");
42956:     ContainerLayer::SetVisibleRegion(aRegion);
38801:   }
55445:   virtual void InsertAfter(Layer* aChild, Layer* aAfter)
55445:   {
55445:     NS_ASSERTION(BasicManager()->InConstruction(),
55445:                  "Can only set properties in construction phase");
55445:     ContainerInsertAfter(aChild, aAfter, this);
55445:   }
55445: 
55445:   virtual void RemoveChild(Layer* aChild)
55445:   { 
55445:     NS_ASSERTION(BasicManager()->InConstruction(),
55445:                  "Can only set properties in construction phase");
55445:     ContainerRemoveChild(aChild, this);
55445:   }
38801: 
57097:   virtual void ComputeEffectiveTransforms(const gfx3DMatrix& aTransformToSurface)
57097:   {
57097:     // We push groups for container layers if we need to, which always
57097:     // are aligned in device space, so it doesn't really matter how we snap
57097:     // containers.
77289:     gfxMatrix residual;
57097:     gfx3DMatrix idealTransform = GetLocalTransform()*aTransformToSurface;
77289: 
77289:     if (!idealTransform.CanDraw2D()) {
77289:       mEffectiveTransform = idealTransform;
77289:       ComputeEffectiveTransformsForChildren(gfx3DMatrix());
80486:       mUseIntermediateSurface = true;
77289:       return;
77289:     }
77289: 
77289:     mEffectiveTransform = SnapTransform(idealTransform, gfxRect(0, 0, 0, 0), &residual);
57097:     // We always pass the ideal matrix down to our children, so there is no
57097:     // need to apply any compensation using the residual from SnapTransform.
57097:     ComputeEffectiveTransformsForChildren(idealTransform);
57097: 
57097:     /* If we have a single child, it can just inherit our opacity,
57097:      * otherwise we need a PushGroup and we need to mark ourselves as using
57097:      * an intermediate surface so our children don't inherit our opacity
57097:      * via GetEffectiveOpacity.
57097:      */
57097:     mUseIntermediateSurface = GetEffectiveOpacity() != 1.0 && HasMultipleChildren();
57097:   }
57097: 
71026:   /**
71026:    * Returns true when:
71026:    * a) no (non-hidden) childrens' visible areas overlap in
71026:    * (aInRect intersected with this layer's visible region).
71026:    * b) the (non-hidden) childrens' visible areas cover
71026:    * (aInRect intersected with this layer's visible region).
71026:    * c) this layer and all (non-hidden) children have transforms that are translations
71026:    * by integers.
71026:    * aInRect is in the root coordinate system.
71026:    * Child layers with opacity do not contribute to the covered area in check b).
71026:    * This method can be conservative; it's OK to return false under any
71026:    * circumstances.
71026:    */
79445:   bool ChildrenPartitionVisibleRegion(const nsIntRect& aInRect);
71026: 
80486:   void ForceIntermediateSurface() { mUseIntermediateSurface = true; }
71026: 
38801: protected:
38801:   BasicLayerManager* BasicManager()
38801:   {
38801:     return static_cast<BasicLayerManager*>(mManager);
38801:   }
38801: };
38801: 
38801: BasicContainerLayer::~BasicContainerLayer()
38801: {
38801:   while (mFirstChild) {
55445:     ContainerRemoveChild(mFirstChild, this);
38801:   }
38801: 
38801:   MOZ_COUNT_DTOR(BasicContainerLayer);
38801: }
38801: 
79445: bool
71026: BasicContainerLayer::ChildrenPartitionVisibleRegion(const nsIntRect& aInRect)
71026: {
71026:   gfxMatrix transform;
77289:   if (!GetEffectiveTransform().CanDraw2D(&transform) ||
71026:       transform.HasNonIntegerTranslation())
80486:     return false;
71026: 
71026:   nsIntPoint offset(PRInt32(transform.x0), PRInt32(transform.y0));
71026:   nsIntRect rect = aInRect.Intersect(GetEffectiveVisibleRegion().GetBounds() + offset);
71026:   nsIntRegion covered;
71026: 
71026:   for (Layer* l = mFirstChild; l; l = l->GetNextSibling()) {
71026:     if (ToData(l)->IsHidden())
71026:       continue;
71026: 
71026:     gfxMatrix childTransform;
77289:     if (!l->GetEffectiveTransform().CanDraw2D(&childTransform) ||
71026:         childTransform.HasNonIntegerTranslation() ||
71026:         l->GetEffectiveOpacity() != 1.0)
80486:       return false;
71026:     nsIntRegion childRegion = l->GetEffectiveVisibleRegion();
71026:     childRegion.MoveBy(PRInt32(childTransform.x0), PRInt32(childTransform.y0));
71026:     childRegion.And(childRegion, rect);
71026:     if (l->GetClipRect()) {
71026:       childRegion.And(childRegion, *l->GetClipRect() + offset);
71026:     }
71026:     nsIntRegion intersection;
71026:     intersection.And(covered, childRegion);
71026:     if (!intersection.IsEmpty())
80486:       return false;
71026:     covered.Or(covered, childRegion);
71026:   }
71026: 
71026:   return covered.Contains(rect);
71026: }
71026: 
55445: template<class Container>
55445: static void
55445: ContainerInsertAfter(Layer* aChild, Layer* aAfter, Container* aContainer)
38801: {
55445:   NS_ASSERTION(aChild->Manager() == aContainer->Manager(),
38801:                "Child has wrong manager");
38801:   NS_ASSERTION(!aChild->GetParent(),
38801:                "aChild already in the tree");
38801:   NS_ASSERTION(!aChild->GetNextSibling() && !aChild->GetPrevSibling(),
38801:                "aChild already has siblings?");
38801:   NS_ASSERTION(!aAfter ||
55445:                (aAfter->Manager() == aContainer->Manager() &&
55445:                 aAfter->GetParent() == aContainer),
38801:                "aAfter is not our child");
38801: 
55445:   aChild->SetParent(aContainer);
57614:   if (aAfter == aContainer->mLastChild) {
57614:     aContainer->mLastChild = aChild;
57614:   }
38801:   if (!aAfter) {
55445:     aChild->SetNextSibling(aContainer->mFirstChild);
55445:     if (aContainer->mFirstChild) {
55445:       aContainer->mFirstChild->SetPrevSibling(aChild);
38801:     }
55445:     aContainer->mFirstChild = aChild;
62199:     NS_ADDREF(aChild);
62199:     aContainer->DidInsertChild(aChild);
38801:     return;
38801:   }
38801: 
38801:   Layer* next = aAfter->GetNextSibling();
38801:   aChild->SetNextSibling(next);
38801:   aChild->SetPrevSibling(aAfter);
38801:   if (next) {
38801:     next->SetPrevSibling(aChild);
38801:   }
38801:   aAfter->SetNextSibling(aChild);
62199:   NS_ADDREF(aChild);
62199:   aContainer->DidInsertChild(aChild);
38801: }
38801: 
55445: template<class Container>
55445: static void
55445: ContainerRemoveChild(Layer* aChild, Container* aContainer)
38801: {
55445:   NS_ASSERTION(aChild->Manager() == aContainer->Manager(),
38801:                "Child has wrong manager");
55445:   NS_ASSERTION(aChild->GetParent() == aContainer,
38801:                "aChild not our child");
38801: 
38801:   Layer* prev = aChild->GetPrevSibling();
38801:   Layer* next = aChild->GetNextSibling();
38801:   if (prev) {
38801:     prev->SetNextSibling(next);
38801:   } else {
55445:     aContainer->mFirstChild = next;
38801:   }
38801:   if (next) {
38801:     next->SetPrevSibling(prev);
57614:   } else {
57614:     aContainer->mLastChild = prev;
38801:   }
38801: 
38801:   aChild->SetNextSibling(nsnull);
38801:   aChild->SetPrevSibling(nsnull);
38801:   aChild->SetParent(nsnull);
38801: 
62199:   aContainer->DidRemoveChild(aChild);
38801:   NS_RELEASE(aChild);
38801: }
38801: 
48143: class BasicThebesLayer;
48143: class BasicThebesLayerBuffer : public ThebesLayerBuffer {
48143:   typedef ThebesLayerBuffer Base;
48143: 
48143: public:
48143:   BasicThebesLayerBuffer(BasicThebesLayer* aLayer)
48143:     : Base(ContainsVisibleBounds)
48143:     , mLayer(aLayer)
63213:   {
63213:   }
48143: 
48143:   virtual ~BasicThebesLayerBuffer()
48143:   {}
48143: 
48143:   using Base::BufferRect;
48143:   using Base::BufferRotation;
48143: 
48143:   /**
48143:    * Complete the drawing operation. The region to draw must have been
48143:    * drawn before this is called. The contents of the buffer are drawn
48143:    * to aTarget.
48143:    */
57385:   void DrawTo(ThebesLayer* aLayer, gfxContext* aTarget, float aOpacity);
48143: 
48143:   virtual already_AddRefed<gfxASurface>
64538:   CreateBuffer(ContentType aType, const nsIntSize& aSize, PRUint32 aFlags);
48143: 
54101:   /**
54109:    * Swap out the old backing buffer for |aBuffer| and attributes.
54101:    */
54109:   void SetBackingBuffer(gfxASurface* aBuffer,
54109:                         const nsIntRect& aRect, const nsIntPoint& aRotation)
54101:   {
72234:     gfxIntSize prevSize = gfxIntSize(BufferRect().width, BufferRect().height);
54109:     gfxIntSize newSize = aBuffer->GetSize();
54109:     NS_ABORT_IF_FALSE(newSize == prevSize,
54101:                       "Swapped-in buffer size doesn't match old buffer's!");
56932:     nsRefPtr<gfxASurface> oldBuffer;
72234:     oldBuffer = SetBuffer(aBuffer, aRect, aRotation);
54101:   }
54101: 
56903:   void SetBackingBufferAndUpdateFrom(
56903:     gfxASurface* aBuffer,
56903:     gfxASurface* aSource, const nsIntRect& aRect, const nsIntPoint& aRotation,
72234:     const nsIntRegion& aUpdateRegion);
56903: 
48143: private:
56903:   BasicThebesLayerBuffer(gfxASurface* aBuffer,
56903:                          const nsIntRect& aRect, const nsIntPoint& aRotation)
56903:     // The size policy doesn't really matter here; this constructor is
56903:     // intended to be used for creating temporaries
56903:     : ThebesLayerBuffer(ContainsVisibleBounds)
56903:   {
72234:     SetBuffer(aBuffer, aRect, aRotation);
56903:   }
56903: 
48143:   BasicThebesLayer* mLayer;
48143: };
48143: 
71025: class BasicThebesLayer : public ThebesLayer, public BasicImplData {
38801: public:
48143:   typedef BasicThebesLayerBuffer Buffer;
48143: 
38801:   BasicThebesLayer(BasicLayerManager* aLayerManager) :
48026:     ThebesLayer(aLayerManager, static_cast<BasicImplData*>(this)),
48026:     mBuffer(this)
38801:   {
38801:     MOZ_COUNT_CTOR(BasicThebesLayer);
38801:   }
38801:   virtual ~BasicThebesLayer()
38801:   {
38801:     MOZ_COUNT_DTOR(BasicThebesLayer);
38801:   }
38801: 
38801:   virtual void SetVisibleRegion(const nsIntRegion& aRegion)
38801:   {
38801:     NS_ASSERTION(BasicManager()->InConstruction(),
38801:                  "Can only set properties in construction phase");
42956:     ThebesLayer::SetVisibleRegion(aRegion);
38801:   }
38801:   virtual void InvalidateRegion(const nsIntRegion& aRegion)
38801:   {
38801:     NS_ASSERTION(BasicManager()->InConstruction(),
38801:                  "Can only set properties in construction phase");
47108:     mValidRegion.Sub(mValidRegion, aRegion);
38801:   }
38801: 
62698:   virtual void PaintThebes(gfxContext* aContext,
42593:                            LayerManager::DrawThebesLayerCallback aCallback,
62698:                            void* aCallbackData,
62698:                            ReadbackProcessor* aReadback);
38801: 
50999:   virtual void ClearCachedResources() { mBuffer.Clear(); mValidRegion.SetEmpty(); }
50999:   
48026:   virtual already_AddRefed<gfxASurface>
48026:   CreateBuffer(Buffer::ContentType aType, const nsIntSize& aSize)
48026:   {
48026:     nsRefPtr<gfxASurface> referenceSurface = mBuffer.GetBuffer();
48026:     if (!referenceSurface) {
48026:       gfxContext* defaultTarget = BasicManager()->GetDefaultTarget();
48026:       if (defaultTarget) {
48026:         referenceSurface = defaultTarget->CurrentSurface();
48026:       } else {
48026:         nsIWidget* widget = BasicManager()->GetRetainerWidget();
48026:         if (widget) {
48026:           referenceSurface = widget->GetThebesSurface();
48026:         } else {
48026:           referenceSurface = BasicManager()->GetTarget()->CurrentSurface();
48026:         }
48026:       }
48026:     }
48026:     return referenceSurface->CreateSimilarSurface(
48026:       aType, gfxIntSize(aSize.width, aSize.height));
48026:   }
48026: 
72226:   virtual void ComputeEffectiveTransforms(const gfx3DMatrix& aTransformToSurface)
72226:   {
72226:     if (!BasicManager()->IsRetained()) {
72226:       // Don't do any snapping of our transform, since we're just going to
72226:       // draw straight through without intermediate buffers.
72226:       mEffectiveTransform = GetLocalTransform()*aTransformToSurface;
72243:       if (gfxPoint(0,0) != mResidualTranslation) {
72243:         mResidualTranslation = gfxPoint(0,0);
72243:         mValidRegion.SetEmpty();
72243:       }
72226:       return;
72226:     }
72226:     ThebesLayer::ComputeEffectiveTransforms(aTransformToSurface);
72226:   }
72226: 
80169:   // Sync front/back buffers content
80169:   virtual void SyncFrontBufferToBackBuffer() {}
80169: 
48143: protected:
48143:   BasicLayerManager* BasicManager()
48143:   {
48143:     return static_cast<BasicLayerManager*>(mManager);
48143:   }
48143: 
48143:   virtual void
48143:   PaintBuffer(gfxContext* aContext,
48143:               const nsIntRegion& aRegionToDraw,
63366:               const nsIntRegion& aExtendedRegionToDraw,
48143:               const nsIntRegion& aRegionToInvalidate,
79445:               bool aDidSelfCopy,
48143:               LayerManager::DrawThebesLayerCallback aCallback,
48143:               void* aCallbackData)
48143:   {
59683:     if (!aCallback) {
59683:       BasicManager()->SetTransactionIncomplete();
59683:       return;
59683:     }
63366:     aCallback(this, aContext, aExtendedRegionToDraw, aRegionToInvalidate,
48143:               aCallbackData);
63213:     // Everything that's visible has been validated. Do this instead of just
60673:     // OR-ing with aRegionToDraw, since that can lead to a very complex region
60673:     // here (OR doesn't automatically simplify to the simplest possible
60673:     // representation of a region.)
63213:     nsIntRegion tmp;
63366:     tmp.Or(mVisibleRegion, aExtendedRegionToDraw);
63213:     mValidRegion.Or(mValidRegion, tmp);
48143:   }
48143: 
48026:   Buffer mBuffer;
38801: };
38801: 
60026: /**
60026:  * Clips to the smallest device-pixel-aligned rectangle containing aRect
60026:  * in user space.
60026:  * Returns true if the clip is "perfect", i.e. we actually clipped exactly to
60026:  * aRect.
60026:  */
79445: static bool
47748: ClipToContain(gfxContext* aContext, const nsIntRect& aRect)
47748: {
60026:   gfxRect userRect(aRect.x, aRect.y, aRect.width, aRect.height);
60026:   gfxRect deviceRect = aContext->UserToDevice(userRect);
47748:   deviceRect.RoundOut();
47748: 
47748:   gfxMatrix currentMatrix = aContext->CurrentMatrix();
47748:   aContext->IdentityMatrix();
47748:   aContext->NewPath();
47748:   aContext->Rectangle(deviceRect);
47748:   aContext->Clip();
47748:   aContext->SetMatrix(currentMatrix);
60026: 
68638:   return aContext->DeviceToUser(deviceRect).IsEqualInterior(userRect);
47748: }
47748: 
52055: static nsIntRegion
52055: IntersectWithClip(const nsIntRegion& aRegion, gfxContext* aContext)
52055: {
52055:   gfxRect clip = aContext->GetClipExtents();
52055:   clip.RoundOut();
52055:   nsIntRect r(clip.X(), clip.Y(), clip.Width(), clip.Height());
52055:   nsIntRegion result;
52055:   result.And(aRegion, r);
52055:   return result;
52055: }
52055: 
59764: static void
59764: SetAntialiasingFlags(Layer* aLayer, gfxContext* aTarget)
59764: {
59764:   nsRefPtr<gfxASurface> surface = aTarget->CurrentSurface();
59764:   if (surface->GetContentType() != gfxASurface::CONTENT_COLOR_ALPHA) {
59764:     // Destination doesn't have alpha channel; no need to set any special flags
59764:     return;
59764:   }
59764: 
63214:   const nsIntRect& bounds = aLayer->GetVisibleRegion().GetBounds();
59764:   surface->SetSubpixelAntialiasingEnabled(
63214:       !(aLayer->GetContentFlags() & Layer::CONTENT_COMPONENT_ALPHA) ||
63214:       surface->GetOpaqueRect().Contains(
63214:         aTarget->UserToDevice(gfxRect(bounds.x, bounds.y, bounds.width, bounds.height))));
59764: }
59764: 
71027: already_AddRefed<gfxContext>
71027: BasicLayerManager::PushGroupForLayer(gfxContext* aContext, Layer* aLayer,
71027:                                      const nsIntRegion& aRegion,
79445:                                      bool* aNeedsClipToVisibleRegion)
60026: {
60026:   // If we need to call PushGroup, we should clip to the smallest possible
60026:   // area first to minimize the size of the temporary surface.
79445:   bool didCompleteClip = ClipToContain(aContext, aRegion.GetBounds());
60026: 
71027:   nsRefPtr<gfxContext> result;
60026:   if (aLayer->CanUseOpaqueSurface() &&
60026:       ((didCompleteClip && aRegion.GetNumRects() == 1) ||
60026:        !aContext->CurrentMatrix().HasNonIntegerTranslation())) {
60026:     // If the layer is opaque in its visible region we can push a CONTENT_COLOR
60026:     // group. We need to make sure that only pixels inside the layer's visible
60026:     // region are copied back to the destination. Remember if we've already
60026:     // clipped precisely to the visible region.
71027:     *aNeedsClipToVisibleRegion = !didCompleteClip || aRegion.GetNumRects() > 1;
71027:     result = PushGroupWithCachedSurface(aContext, gfxASurface::CONTENT_COLOR);
71027:   } else {
80486:     *aNeedsClipToVisibleRegion = false;
71027:     result = aContext;
71027:     aContext->PushGroupAndCopyBackground(gfxASurface::CONTENT_COLOR_ALPHA);
71027:   }
71027:   return result.forget();
60026: }
60026: 
42593: void
62698: BasicThebesLayer::PaintThebes(gfxContext* aContext,
42593:                               LayerManager::DrawThebesLayerCallback aCallback,
62698:                               void* aCallbackData,
62698:                               ReadbackProcessor* aReadback)
42591: {
42591:   NS_ASSERTION(BasicManager()->InDrawing(),
42591:                "Can only draw in drawing phase");
51953:   nsRefPtr<gfxASurface> targetSurface = aContext->CurrentSurface();
42591: 
62698:   nsTArray<ReadbackProcessor::Update> readbackUpdates;
62698:   if (aReadback && UsedForReadback()) {
62698:     aReadback->GetThebesLayerUpdates(this, &readbackUpdates);
62698:   }
80169:   SyncFrontBufferToBackBuffer();
62698: 
79445:   bool canUseOpaqueSurface = CanUseOpaqueSurface();
51958:   Buffer::ContentType contentType =
57383:     canUseOpaqueSurface ? gfxASurface::CONTENT_COLOR :
51958:                           gfxASurface::CONTENT_COLOR_ALPHA;
57097:   float opacity = GetEffectiveOpacity();
51958: 
51953:   if (!BasicManager()->IsRetained() ||
59480:       (!canUseOpaqueSurface &&
59482:        (mContentFlags & CONTENT_COMPONENT_ALPHA) &&
55433:        !MustRetainContent())) {
62698:     NS_ASSERTION(readbackUpdates.IsEmpty(), "Can't do readback for non-retained layer");
62698: 
51953:     mValidRegion.SetEmpty();
51953:     mBuffer.Clear();
51953: 
71025:     nsIntRegion toDraw = IntersectWithClip(GetEffectiveVisibleRegion(), aContext);
70052:     if (!toDraw.IsEmpty() && !IsHidden()) {
59683:       if (!aCallback) {
59683:         BasicManager()->SetTransactionIncomplete();
59683:         return;
59683:       }
59683: 
60026:       aContext->Save();
60026: 
79445:       bool needsClipToVisibleRegion = GetClipToVisibleRegion();
79445:       bool needsGroup =
71025:           opacity != 1.0 || GetOperator() != gfxContext::OPERATOR_OVER;
71027:       nsRefPtr<gfxContext> groupContext;
71025:       if (needsGroup) {
71027:         groupContext =
71027:           BasicManager()->PushGroupForLayer(aContext, this, toDraw,
71027:                                             &needsClipToVisibleRegion);
71027:         if (GetOperator() != gfxContext::OPERATOR_OVER) {
80486:           needsClipToVisibleRegion = true;
71027:         }
71027:       } else {
71027:         groupContext = aContext;
71027:       }
71027:       SetAntialiasingFlags(this, groupContext);
71027:       aCallback(this, groupContext, toDraw, nsIntRegion(), aCallbackData);
71025:       if (needsGroup) {
71027:         BasicManager()->PopGroupToSourceWithCachedSurface(aContext, groupContext);
60026:         if (needsClipToVisibleRegion) {
60026:           gfxUtils::ClipToRegion(aContext, toDraw);
51957:         }
71025:         AutoSetOperator setOperator(aContext, GetOperator());
60026:         aContext->Paint(opacity);
60026:       }
60026: 
60026:       aContext->Restore();
52055:     }
47108:     return;
47108:   }
47108: 
47108:   {
63213:     PRUint32 flags = 0;
77500: #ifndef MOZ_GFX_OPTIMIZE_MOBILE
63213:     gfxMatrix transform;
77289:     if (!GetEffectiveTransform().CanDraw2D(&transform) ||
77500:         transform.HasNonIntegerTranslation()) {
63213:       flags |= ThebesLayerBuffer::PAINT_WILL_RESAMPLE;
63213:     }
77500: #endif
54083:     Buffer::PaintState state =
72234:       mBuffer.BeginPaint(this, contentType, flags);
47108:     mValidRegion.Sub(mValidRegion, state.mRegionToInvalidate);
47108: 
47108:     if (state.mContext) {
47108:       // The area that became invalid and is visible needs to be repainted
47108:       // (this could be the whole visible area if our buffer switched
47108:       // from RGB to RGBA, because we might need to repaint with
47108:       // subpixel AA)
71025:       state.mRegionToInvalidate.And(state.mRegionToInvalidate,
71025:                                     GetEffectiveVisibleRegion());
63366:       nsIntRegion extendedDrawRegion = state.mRegionToDraw;
59764:       SetAntialiasingFlags(this, state.mContext);
48143:       PaintBuffer(state.mContext,
63366:                   state.mRegionToDraw, extendedDrawRegion, state.mRegionToInvalidate,
63397:                   state.mDidSelfCopy,
48143:                   aCallback, aCallbackData);
54083:       Mutated();
47108:     } else {
47765:       // It's possible that state.mRegionToInvalidate is nonempty here,
47765:       // if we are shrinking the valid region to nothing.
47765:       NS_ASSERTION(state.mRegionToDraw.IsEmpty(),
47108:                    "If we need to draw, we should have a context");
47108:     }
47108:   }
47108: 
70052:   if (!IsHidden()) {
71025:     AutoSetOperator setOperator(aContext, GetOperator());
60026:     mBuffer.DrawTo(this, aContext, opacity);
70052:   }
62698: 
62698:   for (PRUint32 i = 0; i < readbackUpdates.Length(); ++i) {
62698:     ReadbackProcessor::Update& update = readbackUpdates[i];
62698:     nsIntPoint offset = update.mLayer->GetBackgroundLayerOffset();
62698:     nsRefPtr<gfxContext> ctx =
62698:       update.mLayer->GetSink()->BeginUpdate(update.mUpdateRect + offset,
62698:                                             update.mSequenceCounter);
62698:     if (ctx) {
62698:       NS_ASSERTION(opacity == 1.0, "Should only read back opaque layers");
62698:       ctx->Translate(gfxPoint(offset.x, offset.y));
62698:       mBuffer.DrawTo(this, ctx, 1.0);
62698:       update.mLayer->GetSink()->EndUpdate(ctx, update.mUpdateRect + offset);
62698:     }
62698:   }
48026: }
48026: 
79445: static bool
54269: IsClippingCheap(gfxContext* aTarget, const nsIntRegion& aRegion)
54269: {
54269:   // Assume clipping is cheap if the context just has an integer
54269:   // translation, and the visible region is simple.
54269:   return !aTarget->CurrentMatrix().HasNonIntegerTranslation() &&
54269:          aRegion.GetNumRects() <= 1; 
54269: }
54269: 
48026: void
48143: BasicThebesLayerBuffer::DrawTo(ThebesLayer* aLayer,
48026:                                gfxContext* aTarget,
48026:                                float aOpacity)
48026: {
48026:   aTarget->Save();
54269:   // If the entire buffer is valid, we can just draw the whole thing,
54269:   // no need to clip. But we'll still clip if clipping is cheap ---
54269:   // that might let us copy a smaller region of the buffer.
75305:   // Also clip to the visible region if we're told to.
54269:   if (!aLayer->GetValidRegion().Contains(BufferRect()) ||
75305:       (ToData(aLayer)->GetClipToVisibleRegion() &&
75305:        !aLayer->GetVisibleRegion().Contains(BufferRect())) ||
71025:       IsClippingCheap(aTarget, aLayer->GetEffectiveVisibleRegion())) {
54269:     // We don't want to draw invalid stuff, so we need to clip. Might as
54269:     // well clip to the smallest area possible --- the visible region.
54597:     // Bug 599189 if there is a non-integer-translation transform in aTarget,
71025:     // we might sample pixels outside GetEffectiveVisibleRegion(), which is wrong
54597:     // and may cause gray lines.
71025:     gfxUtils::ClipToRegionSnapped(aTarget, aLayer->GetEffectiveVisibleRegion());
54269:   }
72234:   DrawBufferWithRotation(aTarget, aOpacity);
48026:   aTarget->Restore();
38801: }
38801: 
48143: already_AddRefed<gfxASurface>
48143: BasicThebesLayerBuffer::CreateBuffer(ContentType aType, 
64538:                                      const nsIntSize& aSize, PRUint32 aFlags)
48143: {
48143:   return mLayer->CreateBuffer(aType, aSize);
48143: }
48143: 
56903: void
56903: BasicThebesLayerBuffer::SetBackingBufferAndUpdateFrom(
56903:   gfxASurface* aBuffer,
56903:   gfxASurface* aSource, const nsIntRect& aRect, const nsIntPoint& aRotation,
72234:   const nsIntRegion& aUpdateRegion)
56903: {
56903:   SetBackingBuffer(aBuffer, aRect, aRotation);
56903:   nsRefPtr<gfxContext> destCtx =
72234:     GetContextForQuadrantUpdate(aUpdateRegion.GetBounds());
56903:   destCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
56903:   if (IsClippingCheap(destCtx, aUpdateRegion)) {
56903:     gfxUtils::ClipToRegion(destCtx, aUpdateRegion);
56903:   }
56903: 
56903:   BasicThebesLayerBuffer srcBuffer(aSource, aRect, aRotation);
72234:   srcBuffer.DrawBufferWithRotation(destCtx, 1.0);
56903: }
56903: 
71025: class BasicImageLayer : public ImageLayer, public BasicImplData {
39498: public:
39498:   BasicImageLayer(BasicLayerManager* aLayerManager) :
54469:     ImageLayer(aLayerManager, static_cast<BasicImplData*>(this)),
54469:     mSize(-1, -1)
39498:   {
39498:     MOZ_COUNT_CTOR(BasicImageLayer);
39498:   }
39498:   virtual ~BasicImageLayer()
39498:   {
39498:     MOZ_COUNT_DTOR(BasicImageLayer);
39498:   }
39498: 
39498:   virtual void SetVisibleRegion(const nsIntRegion& aRegion)
39498:   {
39498:     NS_ASSERTION(BasicManager()->InConstruction(),
39498:                  "Can only set properties in construction phase");
47108:     ImageLayer::SetVisibleRegion(aRegion);
39498:   }
39498: 
62698:   virtual void Paint(gfxContext* aContext);
39498: 
48142:   static void PaintContext(gfxPattern* aPattern,
61312:                            const nsIntRegion& aVisible,
61312:                            const nsIntRect* aTileSourceRect,
48142:                            float aOpacity,
48142:                            gfxContext* aContext);
48142: 
39498: protected:
39498:   BasicLayerManager* BasicManager()
39498:   {
39498:     return static_cast<BasicLayerManager*>(mManager);
39498:   }
48142: 
48142:   already_AddRefed<gfxPattern>
48142:   GetAndPaintCurrentImage(gfxContext* aContext,
48142:                           float aOpacity);
48142: 
48142:   gfxIntSize mSize;
39498: };
39498: 
39498: void
62698: BasicImageLayer::Paint(gfxContext* aContext)
39498: {
70052:   if (IsHidden())
70052:     return;
57097:   nsRefPtr<gfxPattern> dontcare =
57097:       GetAndPaintCurrentImage(aContext, GetEffectiveOpacity());
48142: }
48142: 
48142: already_AddRefed<gfxPattern>
48142: BasicImageLayer::GetAndPaintCurrentImage(gfxContext* aContext,
48142:                                          float aOpacity)
48142: {
39498:   if (!mContainer)
48142:     return nsnull;
39498: 
63615:   nsRefPtr<Image> image = mContainer->GetCurrentImage();
63615: 
48142:   nsRefPtr<gfxASurface> surface = mContainer->GetCurrentAsSurface(&mSize);
39498:   if (!surface) {
48142:     return nsnull;
39498:   }
39498: 
39498:   nsRefPtr<gfxPattern> pat = new gfxPattern(surface);
39498:   if (!pat) {
48142:     return nsnull;
39498:   }
39498: 
39498:   pat->SetFilter(mFilter);
39498: 
61347:   // The visible region can extend outside the image.  If we're not
61347:   // tiling, we don't want to draw into that area, so just draw within
61347:   // the image bounds.
61347:   const nsIntRect* tileSrcRect = GetTileSourceRect();
71025:   AutoSetOperator setOperator(aContext, GetOperator());
61347:   PaintContext(pat,
61347:                tileSrcRect ? GetVisibleRegion() : nsIntRegion(nsIntRect(0, 0, mSize.width, mSize.height)),
61347:                tileSrcRect,
61339:                aOpacity, aContext);
63615: 
63615:   GetContainer()->NotifyPaintedImage(image);
63615: 
48142:   return pat.forget();
48142: }
48142: 
48142: /*static*/ void
48142: BasicImageLayer::PaintContext(gfxPattern* aPattern,
61312:                               const nsIntRegion& aVisible,
61312:                               const nsIntRect* aTileSourceRect,
48142:                               float aOpacity,
48142:                               gfxContext* aContext)
48142: {
39498:   // Set PAD mode so that when the video is being scaled, we do not sample
39498:   // outside the bounds of the video image.
39498:   gfxPattern::GraphicsExtend extend = gfxPattern::EXTEND_PAD;
39498: 
39498:   // PAD is slow with X11 and Quartz surfaces, so prefer speed over correctness
39498:   // and use NONE.
39498:   nsRefPtr<gfxASurface> target = aContext->CurrentSurface();
39498:   gfxASurface::gfxSurfaceType type = target->GetType();
39498:   if (type == gfxASurface::SurfaceTypeXlib ||
39498:       type == gfxASurface::SurfaceTypeXcb ||
39498:       type == gfxASurface::SurfaceTypeQuartz) {
39498:     extend = gfxPattern::EXTEND_NONE;
39498:   }
39498: 
61312:   if (!aTileSourceRect) {
39498:     aContext->NewPath();
57097:     // No need to snap here; our transform has already taken care of it.
61312:     // XXX true for arbitrary regions?  Don't care yet though
61312:     gfxUtils::PathFromRegion(aContext, aVisible);
61312:     aPattern->SetExtend(extend);
57097:     aContext->SetPattern(aPattern);
61311:     aContext->FillWithOpacity(aOpacity);
61312:   } else {
61312:     nsRefPtr<gfxASurface> source = aPattern->GetSurface();
61312:     NS_ABORT_IF_FALSE(source, "Expecting a surface pattern");
61312:     gfxIntSize sourceSize = source->GetSize();
61312:     nsIntRect sourceRect(0, 0, sourceSize.width, sourceSize.height);
61312:     NS_ABORT_IF_FALSE(sourceRect == *aTileSourceRect,
61312:                       "Cowardly refusing to create a temporary surface for tiling");
61312: 
61312:     gfxContextAutoSaveRestore saveRestore(aContext);
61312: 
61312:     aContext->NewPath();
61312:     gfxUtils::PathFromRegion(aContext, aVisible);
61312: 
61312:     aPattern->SetExtend(gfxPattern::EXTEND_REPEAT);
61312:     aContext->SetPattern(aPattern);
61312:     aContext->FillWithOpacity(aOpacity);
61312:   }
61312: 
61312:   // Reset extend mode for callers that need to reuse the pattern
61312:   aPattern->SetExtend(extend);
47748: }
39498: 
71025: class BasicColorLayer : public ColorLayer, public BasicImplData {
42249: public:
42249:   BasicColorLayer(BasicLayerManager* aLayerManager) :
42249:     ColorLayer(aLayerManager, static_cast<BasicImplData*>(this))
42249:   {
42249:     MOZ_COUNT_CTOR(BasicColorLayer);
42249:   }
42249:   virtual ~BasicColorLayer()
42249:   {
42249:     MOZ_COUNT_DTOR(BasicColorLayer);
42249:   }
42249: 
42249:   virtual void SetVisibleRegion(const nsIntRegion& aRegion)
42249:   {
42249:     NS_ASSERTION(BasicManager()->InConstruction(),
42249:                  "Can only set properties in construction phase");
47108:     ColorLayer::SetVisibleRegion(aRegion);
42249:   }
42249: 
62698:   virtual void Paint(gfxContext* aContext)
55444:   {
70052:     if (IsHidden())
70052:       return;
71025:     AutoSetOperator setOperator(aContext, GetOperator());
57097:     PaintColorTo(mColor, GetEffectiveOpacity(), aContext);
55444:   }
55444: 
55444:   static void PaintColorTo(gfxRGBA aColor, float aOpacity,
55444:                            gfxContext* aContext);
42249: 
42249: protected:
42249:   BasicLayerManager* BasicManager()
42249:   {
42249:     return static_cast<BasicLayerManager*>(mManager);
42249:   }
42249: };
42249: 
55444: /*static*/ void
55444: BasicColorLayer::PaintColorTo(gfxRGBA aColor, float aOpacity,
55444:                               gfxContext* aContext)
42249: {
55444:   aContext->SetColor(aColor);
47748:   aContext->Paint(aOpacity);
42249: }
42249: 
42402: class BasicCanvasLayer : public CanvasLayer,
71025:                          public BasicImplData
42402: {
42402: public:
42402:   BasicCanvasLayer(BasicLayerManager* aLayerManager) :
42402:     CanvasLayer(aLayerManager, static_cast<BasicImplData*>(this))
42402:   {
42402:     MOZ_COUNT_CTOR(BasicCanvasLayer);
42402:   }
42402:   virtual ~BasicCanvasLayer()
42402:   {
42402:     MOZ_COUNT_DTOR(BasicCanvasLayer);
42402:   }
42402: 
47748:   virtual void SetVisibleRegion(const nsIntRegion& aRegion)
47748:   {
47748:     NS_ASSERTION(BasicManager()->InConstruction(),
47748:                  "Can only set properties in construction phase");
47748:     CanvasLayer::SetVisibleRegion(aRegion);
47748:   }
47748: 
42402:   virtual void Initialize(const Data& aData);
62698:   virtual void Paint(gfxContext* aContext);
42402: 
61293:   virtual void PaintWithOpacity(gfxContext* aContext,
61293:                                 float aOpacity);
61293: 
42402: protected:
47748:   BasicLayerManager* BasicManager()
47748:   {
47748:     return static_cast<BasicLayerManager*>(mManager);
47748:   }
71550:   void UpdateSurface(gfxASurface* aDestSurface = nsnull);
47748: 
42402:   nsRefPtr<gfxASurface> mSurface;
42402:   nsRefPtr<mozilla::gl::GLContext> mGLContext;
72427:   mozilla::RefPtr<mozilla::gfx::DrawTarget> mDrawTarget;
72427:   
47909:   PRUint32 mCanvasFramebuffer;
42402: 
79445:   bool mGLBufferIsPremultiplied;
79445:   bool mNeedsYFlip;
42402: };
42402: 
42402: void
42402: BasicCanvasLayer::Initialize(const Data& aData)
42402: {
42402:   NS_ASSERTION(mSurface == nsnull, "BasicCanvasLayer::Initialize called twice!");
42402: 
42402:   if (aData.mSurface) {
42402:     mSurface = aData.mSurface;
42402:     NS_ASSERTION(aData.mGLContext == nsnull,
42402:                  "CanvasLayer can't have both surface and GLContext");
80486:     mNeedsYFlip = false;
42402:   } else if (aData.mGLContext) {
47909:     NS_ASSERTION(aData.mGLContext->IsOffscreen(), "canvas gl context isn't offscreen");
42402:     mGLContext = aData.mGLContext;
42402:     mGLBufferIsPremultiplied = aData.mGLBufferIsPremultiplied;
47909:     mCanvasFramebuffer = mGLContext->GetOffscreenFBO();
80486:     mNeedsYFlip = true;
72427:   } else if (aData.mDrawTarget) {
72427:     mDrawTarget = aData.mDrawTarget;
72427:     mSurface = gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mDrawTarget);
80486:     mNeedsYFlip = false;
42402:   } else {
72427:     NS_ERROR("CanvasLayer created without mSurface, mDrawTarget or mGLContext?");
42402:   }
42402: 
42402:   mBounds.SetRect(0, 0, aData.mSize.width, aData.mSize.height);
42402: }
42402: 
42402: void
71550: BasicCanvasLayer::UpdateSurface(gfxASurface* aDestSurface)
42402: {
72427:   if (mDrawTarget) {
72427:     mDrawTarget->Flush();
72427:   }
72427: 
71550:   if (!mGLContext && aDestSurface) {
71550:     nsRefPtr<gfxContext> tmpCtx = new gfxContext(aDestSurface);
71550:     tmpCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
71550:     BasicCanvasLayer::PaintWithOpacity(tmpCtx, 1.0f);
71550:     return;
71550:   }
71550: 
64540:   if (!mDirty)
64540:     return;
80486:   mDirty = false;
42402: 
42402:   if (mGLContext) {
71550:     if (aDestSurface && aDestSurface->GetType() != gfxASurface::SurfaceTypeImage) {
71550:       NS_ASSERTION(aDestSurface->GetType() == gfxASurface::SurfaceTypeImage,
71550:                    "Destination surface must be ImageSurface type");
71550:       return;
71550:     }
71550: 
74436:     // We need to read from the GLContext
74436:     mGLContext->MakeCurrent();
74436: 
74436: #if defined (MOZ_X11) && defined (MOZ_EGL_XRENDER_COMPOSITE)
80617:     mGLContext->Finish();
74436:     gfxASurface* offscreenSurface = mGLContext->GetOffscreenPixmapSurface();
74436: 
74436:     // XRender can only blend premuliplied alpha, so only allow xrender
74436:     // path if we have premultiplied alpha or opaque content.
74436:     if (offscreenSurface && (mGLBufferIsPremultiplied || (GetContentFlags() & CONTENT_OPAQUE))) {  
74436:         mSurface = offscreenSurface;
74436:         mNeedsYFlip = false;
74436:     }
74436:     else
74436: #endif
74436:     {
71550:     nsRefPtr<gfxImageSurface> isurf = aDestSurface ?
71550:         static_cast<gfxImageSurface*>(aDestSurface) :
42402:         new gfxImageSurface(gfxIntSize(mBounds.width, mBounds.height),
51950:                             (GetContentFlags() & CONTENT_OPAQUE)
42402:                               ? gfxASurface::ImageFormatRGB24
42402:                               : gfxASurface::ImageFormatARGB32);
71550: 
42402:     if (!isurf || isurf->CairoStatus() != 0) {
42402:       return;
42402:     }
42402: 
42402:     NS_ASSERTION(isurf->Stride() == mBounds.width * 4, "gfxImageSurface stride isn't what we expect!");
42402: 
42402:     // We have to flush to ensure that any buffered GL operations are
42402:     // in the framebuffer before we read.
42402:     mGLContext->fFlush();
42402: 
47909:     PRUint32 currentFramebuffer = 0;
47909: 
47909:     mGLContext->fGetIntegerv(LOCAL_GL_FRAMEBUFFER_BINDING, (GLint*)&currentFramebuffer);
47909: 
47909:     // Make sure that we read pixels from the correct framebuffer, regardless
47909:     // of what's currently bound.
47909:     if (currentFramebuffer != mCanvasFramebuffer)
47909:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mCanvasFramebuffer);
47909: 
49076:     mGLContext->ReadPixelsIntoImageSurface(0, 0,
49076:                                            mBounds.width, mBounds.height,
49076:                                            isurf);
42402: 
47909:     // Put back the previous framebuffer binding.
47909:     if (currentFramebuffer != mCanvasFramebuffer)
47909:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, currentFramebuffer);
47909: 
42402:     // If the underlying GLContext doesn't have a framebuffer into which
42402:     // premultiplied values were written, we have to do this ourselves here.
42402:     // Note that this is a WebGL attribute; GL itself has no knowledge of
42402:     // premultiplied or unpremultiplied alpha.
42402:     if (!mGLBufferIsPremultiplied)
42402:       gfxUtils::PremultiplyImageSurface(isurf);
42402: 
42402:     // stick our surface into mSurface, so that the Paint() path is the same
71550:     if (!aDestSurface) {
42402:       mSurface = isurf;
42402:     }
42402:   }
71550: }
74436: }
42402: 
42402: void
62698: BasicCanvasLayer::Paint(gfxContext* aContext)
42402: {
70052:   if (IsHidden())
70052:     return;
64540:   UpdateSurface();
64541:   FireDidTransactionCallback();
61293:   PaintWithOpacity(aContext, GetEffectiveOpacity());
61293: }
61293: 
61293: void
61293: BasicCanvasLayer::PaintWithOpacity(gfxContext* aContext,
61293:                                    float aOpacity)
61293: {
48140:   NS_ASSERTION(BasicManager()->InDrawing(),
48140:                "Can only draw in drawing phase");
48140: 
42402:   nsRefPtr<gfxPattern> pat = new gfxPattern(mSurface);
42402: 
42404:   pat->SetFilter(mFilter);
42435:   pat->SetExtend(gfxPattern::EXTEND_PAD);
42404: 
42403:   gfxMatrix m;
42403:   if (mNeedsYFlip) {
42403:     m = aContext->CurrentMatrix();
42403:     aContext->Translate(gfxPoint(0.0, mBounds.height));
42403:     aContext->Scale(1.0, -1.0);
42403:   }
42403: 
74436:   // If content opaque, then save off current operator and set to source.
74436:   // This ensures that alpha is not applied even if the source surface
74436:   // has an alpha channel
74436:   gfxContext::GraphicsOperator savedOp;
74436:   if (GetContentFlags() & CONTENT_OPAQUE) {
74436:     savedOp = aContext->CurrentOperator();
74436:     aContext->SetOperator(gfxContext::OPERATOR_SOURCE);
74436:   }
74436: 
71025:   AutoSetOperator setOperator(aContext, GetOperator());
42402:   aContext->NewPath();
57097:   // No need to snap here; our transform is already set up to snap our rect
57097:   aContext->Rectangle(gfxRect(0, 0, mBounds.width, mBounds.height));
57097:   aContext->SetPattern(pat);
61311:   aContext->FillWithOpacity(aOpacity);
42402: 
74436: #if defined (MOZ_X11) && defined (MOZ_EGL_XRENDER_COMPOSITE)
74436:   if (mGLContext) {
74436:     // Wait for X to complete all operations before continuing
74436:     // Otherwise gl context could get cleared before X is done.
74436:     mGLContext->WaitNative();
74436:   }
74436: #endif
74436: 
74436:   // Restore surface operator
74436:   if (GetContentFlags() & CONTENT_OPAQUE) {
74436:     aContext->SetOperator(savedOp);
74436:   }  
74436: 
42403:   if (mNeedsYFlip) {
42403:     aContext->SetMatrix(m);
42403:   }
42402: }
42402: 
62698: class BasicReadbackLayer : public ReadbackLayer,
71025:                            public BasicImplData
62698: {
62698: public:
62698:   BasicReadbackLayer(BasicLayerManager* aLayerManager) :
62698:     ReadbackLayer(aLayerManager, static_cast<BasicImplData*>(this))
62698:   {
62698:     MOZ_COUNT_CTOR(BasicReadbackLayer);
62698:   }
62698:   virtual ~BasicReadbackLayer()
62698:   {
62698:     MOZ_COUNT_DTOR(BasicReadbackLayer);
62698:   }
62698: 
62698:   virtual void SetVisibleRegion(const nsIntRegion& aRegion)
62698:   {
62698:     NS_ASSERTION(BasicManager()->InConstruction(),
62698:                  "Can only set properties in construction phase");
62698:     ReadbackLayer::SetVisibleRegion(aRegion);
62698:   }
62698: 
62698: protected:
62698:   BasicLayerManager* BasicManager()
62698:   {
62698:     return static_cast<BasicLayerManager*>(mManager);
62698:   }
62698: };
62698: 
47749: static nsIntRect
47749: ToOutsideIntRect(const gfxRect &aRect)
47749: {
47749:   gfxRect r = aRect;
47749:   r.RoundOut();
68632:   return nsIntRect(r.X(), r.Y(), r.Width(), r.Height());
47749: }
47749: 
57615: static nsIntRect
57615: ToInsideIntRect(const gfxRect& aRect)
57615: {
57615:   gfxRect r = aRect;
57615:   r.RoundIn();
68632:   return nsIntRect(r.X(), r.Y(), r.Width(), r.Height());
57615: }
57615: 
47767: BasicLayerManager::BasicLayerManager(nsIWidget* aWidget) :
48140: #ifdef DEBUG
48140:   mPhase(PHASE_NONE),
48140: #endif
72234:   mWidget(aWidget)
80486:   , mDoubleBuffering(BUFFER_NONE), mUsingDefaultTarget(false)
80486:   , mCachedSurfaceInUse(false)
59683:   , mTransactionIncomplete(false)
47767: {
47767:   MOZ_COUNT_CTOR(BasicLayerManager);
47767:   NS_ASSERTION(aWidget, "Must provide a widget");
47767: }
47767: 
47767: BasicLayerManager::BasicLayerManager() :
48140: #ifdef DEBUG
48140:   mPhase(PHASE_NONE),
48140: #endif
47767:   mWidget(nsnull)
80486:   , mDoubleBuffering(BUFFER_NONE), mUsingDefaultTarget(false)
38801: {
38801:   MOZ_COUNT_CTOR(BasicLayerManager);
38801: }
38801: 
38801: BasicLayerManager::~BasicLayerManager()
38801: {
47108:   NS_ASSERTION(!InTransaction(), "Died during transaction?");
48141: 
50999:   ClearCachedResources();
50999: 
48141:   mRoot = nsnull;
48141: 
38801:   MOZ_COUNT_DTOR(BasicLayerManager);
38801: }
38801: 
38801: void
47746: BasicLayerManager::SetDefaultTarget(gfxContext* aContext,
47746:                                     BufferMode aDoubleBuffering)
38801: {
47108:   NS_ASSERTION(!InTransaction(),
38801:                "Must set default target outside transaction");
38801:   mDefaultTarget = aContext;
47746:   mDoubleBuffering = aDoubleBuffering;
38801: }
38801: 
38801: void
38801: BasicLayerManager::BeginTransaction()
38801: {
80486:   mUsingDefaultTarget = true;
47746:   BeginTransactionWithTarget(mDefaultTarget);
38801: }
38801: 
47747: already_AddRefed<gfxContext>
47747: BasicLayerManager::PushGroupWithCachedSurface(gfxContext *aTarget,
71027:                                               gfxASurface::gfxContentType aContent)
47747: {
71027:   if (mCachedSurfaceInUse) {
71027:     aTarget->PushGroup(aContent);
71027:     nsRefPtr<gfxContext> result = aTarget;
71027:     return result.forget();
71027:   }
80486:   mCachedSurfaceInUse = true;
71027: 
47747:   gfxContextMatrixAutoSaveRestore saveMatrix(aTarget);
47747:   aTarget->IdentityMatrix();
47747: 
47747:   nsRefPtr<gfxASurface> currentSurf = aTarget->CurrentSurface();
47747:   gfxRect clip = aTarget->GetClipExtents();
47747:   clip.RoundOut();
47747: 
71027:   nsRefPtr<gfxContext> ctx = mCachedSurface.Get(aContent, clip, currentSurf);
47747:   /* Align our buffer for the original surface */
71027:   ctx->SetMatrix(saveMatrix.Matrix());
47747:   return ctx.forget();
47747: }
47747: 
47747: void
71027: BasicLayerManager::PopGroupToSourceWithCachedSurface(gfxContext *aTarget, gfxContext *aPushed)
47747: {
71027:   if (!aTarget)
47747:     return;
71027:   nsRefPtr<gfxASurface> current = aPushed->CurrentSurface();
71027:   if (mCachedSurface.IsSurface(current)) {
47747:     gfxContextMatrixAutoSaveRestore saveMatrix(aTarget);
47747:     aTarget->IdentityMatrix();
71027:     aTarget->SetSource(current);
80486:     mCachedSurfaceInUse = false;
71027:   } else {
71027:     aTarget->PopGroupToSource();
71027:   }
47747: }
47747: 
38801: void
38801: BasicLayerManager::BeginTransactionWithTarget(gfxContext* aTarget)
38801: {
48025: #ifdef MOZ_LAYERS_HAVE_LOG
48025:   MOZ_LAYERS_LOG(("[----- BeginTransaction"));
48025:   Log();
48025: #endif
48025: 
47108:   NS_ASSERTION(!InTransaction(), "Nested transactions not allowed");
38801: #ifdef DEBUG
38801:   mPhase = PHASE_CONSTRUCTION;
38801: #endif
38801:   mTarget = aTarget;
38801: }
38801: 
57615: static void
57615: TransformIntRect(nsIntRect& aRect, const gfxMatrix& aMatrix,
57615:                  nsIntRect (*aRoundMethod)(const gfxRect&))
57615: {
57615:   gfxRect gr = gfxRect(aRect.x, aRect.y, aRect.width, aRect.height);
57615:   gr = aMatrix.TransformBounds(gr);
57615:   aRect = (*aRoundMethod)(gr);
57615: }
57615: 
70052: /**
70052:  * This function assumes that GetEffectiveTransform transforms
70052:  * all layers to the same coordinate system (the "root coordinate system").
70052:  * It can't be used as is by accelerated layers because of intermediate surfaces.
70052:  * This must set the hidden flag to true or false on *all* layers in the subtree.
71026:  * It also sets the operator for all layers to "OVER".
75305:  * It clears mClipToVisibleRegion on all layers.
70052:  * @param aClipRect the cliprect, in the root coordinate system. We assume
70052:  * that any layer drawing is clipped to this rect. It is therefore not
70052:  * allowed to add to the opaque region outside that rect.
70052:  * @param aDirtyRect the dirty rect that will be painted, in the root
70052:  * coordinate system. Layers outside this rect should be hidden.
70052:  * @param aOpaqueRegion the opaque region covering aLayer, in the
70052:  * root coordinate system.
70052:  */
71024: enum {
71024:     ALLOW_OPAQUE = 0x01,
71024: };
57615: static void
71024: MarkLayersHidden(Layer* aLayer, const nsIntRect& aClipRect,
70052:                  const nsIntRect& aDirtyRect,
71024:                  nsIntRegion& aOpaqueRegion,
71024:                  PRUint32 aFlags)
57615: {
57615:   nsIntRect newClipRect(aClipRect);
71024:   PRUint32 newFlags = aFlags;
57615: 
57615:   // Allow aLayer or aLayer's descendants to cover underlying layers
71024:   // only if it's opaque.
57615:   if (aLayer->GetOpacity() != 1.0f) {
71024:     newFlags &= ~ALLOW_OPAQUE;
57615:   }
57615: 
64532:   {
64532:     const nsIntRect* clipRect = aLayer->GetEffectiveClipRect();
57615:     if (clipRect) {
57615:       nsIntRect cr = *clipRect;
64532:       // clipRect is in the container's coordinate system. Get it into the
64532:       // global coordinate system.
64532:       if (aLayer->GetParent()) {
57615:         gfxMatrix tr;
77289:         if (aLayer->GetParent()->GetEffectiveTransform().CanDraw2D(&tr)) {
70052:           // Clip rect is applied after aLayer's transform, i.e., in the coordinate
70052:           // system of aLayer's parent.
57615:           TransformIntRect(cr, tr, ToInsideIntRect);
64532:         } else {
64532:           cr.SetRect(0, 0, 0, 0);
64532:         }
64532:       }
57615:       newClipRect.IntersectRect(newClipRect, cr);
57615:     }
57615:   }
57615: 
71024:   BasicImplData* data = ToData(aLayer);
71026:   data->SetOperator(gfxContext::OPERATOR_OVER);
80486:   data->SetClipToVisibleRegion(false);
71026: 
71026:   if (!aLayer->AsContainerLayer()) {
57615:     gfxMatrix transform;
77289:     if (!aLayer->GetEffectiveTransform().CanDraw2D(&transform)) {
80486:       data->SetHidden(false);
57615:       return;
57615:     }
57615: 
57615:     nsIntRegion region = aLayer->GetEffectiveVisibleRegion();
57615:     nsIntRect r = region.GetBounds();
57615:     TransformIntRect(r, transform, ToOutsideIntRect);
70052:     r.IntersectRect(r, aDirtyRect);
70052:     data->SetHidden(aOpaqueRegion.Contains(r));
57615: 
57615:     // Allow aLayer to cover underlying layers only if aLayer's
57615:     // content is opaque
71024:     if ((aLayer->GetContentFlags() & Layer::CONTENT_OPAQUE) &&
71024:         (newFlags & ALLOW_OPAQUE)) {
57615:       nsIntRegionRectIterator it(region);
57615:       while (const nsIntRect* sr = it.Next()) {
57615:         r = *sr;
57615:         TransformIntRect(r, transform, ToInsideIntRect);
57615: 
57615:         r.IntersectRect(r, newClipRect);
70052:         aOpaqueRegion.Or(aOpaqueRegion, r);
57615:       }
57615:     }
57615:   } else {
71026:     Layer* child = aLayer->GetLastChild();
79445:     bool allHidden = true;
57615:     for (; child; child = child->GetPrevSibling()) {
71024:       MarkLayersHidden(child, newClipRect, aDirtyRect, aOpaqueRegion, newFlags);
71024:       if (!ToData(child)->IsHidden()) {
80486:         allHidden = false;
70055:       }
70055:     }
71024:     data->SetHidden(allHidden);
71024:   }
70055: }
70055: 
71026: /**
71026:  * This function assumes that GetEffectiveTransform transforms
71026:  * all layers to the same coordinate system (the "root coordinate system").
71026:  * MarkLayersHidden must be called before calling this.
71026:  * @param aVisibleRect the rectangle of aLayer that is visible (i.e. not
71026:  * clipped and in the dirty rect), in the root coordinate system.
71026:  */
71026: static void
71026: ApplyDoubleBuffering(Layer* aLayer, const nsIntRect& aVisibleRect)
71026: {
71026:   BasicImplData* data = ToData(aLayer);
71026:   if (data->IsHidden())
71026:     return;
71026: 
71026:   nsIntRect newVisibleRect(aVisibleRect);
71026: 
71026:   {
71026:     const nsIntRect* clipRect = aLayer->GetEffectiveClipRect();
71026:     if (clipRect) {
71026:       nsIntRect cr = *clipRect;
71026:       // clipRect is in the container's coordinate system. Get it into the
71026:       // global coordinate system.
71026:       if (aLayer->GetParent()) {
71026:         gfxMatrix tr;
77289:         if (aLayer->GetParent()->GetEffectiveTransform().CanDraw2D(&tr)) {
71026:           NS_ASSERTION(!tr.HasNonIntegerTranslation(),
71026:                        "Parent can only have an integer translation");
71026:           cr += nsIntPoint(PRInt32(tr.x0), PRInt32(tr.y0));
71026:         } else {
71026:           NS_ERROR("Parent can only have an integer translation");
71026:         }
71026:       }
71026:       newVisibleRect.IntersectRect(newVisibleRect, cr);
71026:     }
71026:   }
71026: 
71026:   BasicContainerLayer* container =
71026:     static_cast<BasicContainerLayer*>(aLayer->AsContainerLayer());
71026:   // Layers that act as their own backbuffers should be drawn to the destination
71026:   // using OPERATOR_SOURCE to ensure that alpha values in a transparent window
71026:   // are cleared. This can also be faster than OPERATOR_OVER.
71026:   if (!container) {
71026:     data->SetOperator(gfxContext::OPERATOR_SOURCE);
71026:   } else {
71026:     if (container->UseIntermediateSurface() ||
71026:         !container->ChildrenPartitionVisibleRegion(newVisibleRect)) {
71026:       // We need to double-buffer this container.
71026:       data->SetOperator(gfxContext::OPERATOR_SOURCE);
71026:       container->ForceIntermediateSurface();
71026:     } else {
75305:       // Tell the children to clip to their visible regions so our assumption
75305:       // that they don't paint outside their visible regions is valid!
71026:       for (Layer* child = aLayer->GetFirstChild(); child;
71026:            child = child->GetNextSibling()) {
80486:         ToData(child)->SetClipToVisibleRegion(true);
71026:         ApplyDoubleBuffering(child, newVisibleRect);
71026:       }
71026:     }
71026:   }
71026: }
71026: 
59171: void
42593: BasicLayerManager::EndTransaction(DrawThebesLayerCallback aCallback,
78887:                                   void* aCallbackData,
78887:                                   EndTransactionFlags aFlags)
38801: {
78887:   EndTransactionInternal(aCallback, aCallbackData, aFlags);
59683: }
59683: 
59683: bool
59683: BasicLayerManager::EndTransactionInternal(DrawThebesLayerCallback aCallback,
78887:                                           void* aCallbackData,
78887:                                           EndTransactionFlags aFlags)
59683: {
48025: #ifdef MOZ_LAYERS_HAVE_LOG
48140:   MOZ_LAYERS_LOG(("  ----- (beginning paint)"));
48025:   Log();
48025: #endif
48025: 
47108:   NS_ASSERTION(InConstruction(), "Should be in construction phase");
38801: #ifdef DEBUG
38801:   mPhase = PHASE_DRAWING;
38801: #endif
42593: 
59683:   mTransactionIncomplete = false;
59683: 
78887:   if (mTarget && mRoot && !(aFlags & END_NO_IMMEDIATE_REDRAW)) {
70052:     nsIntRect clipRect;
70052:     if (HasShadowManager()) {
70052:       // If this has a shadow manager, the clip extents of mTarget are meaningless.
70052:       // So instead just use the root layer's visible region bounds.
70052:       const nsIntRect& bounds = mRoot->GetVisibleRegion().GetBounds();
70052:       gfxRect deviceRect =
70052:           mTarget->UserToDevice(gfxRect(bounds.x, bounds.y, bounds.width, bounds.height));
70052:       clipRect = ToOutsideIntRect(deviceRect);
70052:     } else {
70052:       gfxContextMatrixAutoSaveRestore save(mTarget);
70052:       mTarget->SetMatrix(gfxMatrix());
70052:       clipRect = ToOutsideIntRect(mTarget->GetClipExtents());
70052:     }
70052: 
71026:     // Need to do this before we call ApplyDoubleBuffering,
70052:     // which depends on correct effective transforms
70052:     mSnapEffectiveTransforms =
70052:       !(mTarget->GetFlags() & gfxContext::FLAG_DISABLE_SNAPPING);
70052:     mRoot->ComputeEffectiveTransforms(gfx3DMatrix::From2D(mTarget->CurrentMatrix()));
70052: 
70052:     if (IsRetained()) {
70052:       nsIntRegion region;
71024:       MarkLayersHidden(mRoot, clipRect, clipRect, region, ALLOW_OPAQUE);
71026:       if (mUsingDefaultTarget && mDoubleBuffering != BUFFER_NONE) {
71026:         ApplyDoubleBuffering(mRoot, clipRect);
71026:       }
70056:     }
70056: 
71027:     PaintLayer(mTarget, mRoot, aCallback, aCallbackData, nsnull);
70128: 
61069:     if (!mTransactionIncomplete) {
61069:       // Clear out target if we have a complete transaction.
42593:       mTarget = nsnull;
61069:     }
38801:   }
38801: 
48140: #ifdef MOZ_LAYERS_HAVE_LOG
48140:   Log();
48140:   MOZ_LAYERS_LOG(("]----- EndTransaction"));
48140: #endif
48140: 
38801: #ifdef DEBUG
60857:   // Go back to the construction phase if the transaction isn't complete.
60857:   // Layout will update the layer tree and call EndTransaction().
60857:   mPhase = mTransactionIncomplete ? PHASE_CONSTRUCTION : PHASE_NONE;
38801: #endif
61069: 
61069:   if (!mTransactionIncomplete) {
61069:     // This is still valid if the transaction was incomplete.
80486:     mUsingDefaultTarget = false;
61069:   }
59683: 
59683:   NS_ASSERTION(!aCallback || !mTransactionIncomplete,
59683:                "If callback is not null, transaction must be complete");
60857: 
61069:   // XXX - We should probably assert here that for an incomplete transaction
61069:   // out target is the default target.
61069: 
59683:   return !mTransactionIncomplete;
59683: }
59683: 
59683: bool
60857: BasicLayerManager::EndEmptyTransaction()
59683: {
59683:   if (!mRoot) {
59683:     return false;
59683:   }
59683: 
59683:   return EndTransactionInternal(nsnull, nsnull);
38801: }
38801: 
38801: void
38801: BasicLayerManager::SetRoot(Layer* aLayer)
38801: {
38801:   NS_ASSERTION(aLayer, "Root can't be null");
38801:   NS_ASSERTION(aLayer->Manager() == this, "Wrong manager");
38801:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
38801:   mRoot = aLayer;
38801: }
38801: 
77289: static pixman_transform
77289: Matrix3DToPixman(const gfx3DMatrix& aMatrix)
77289: {
77289:   pixman_f_transform transform;
77289: 
77289:   transform.m[0][0] = aMatrix._11;
77289:   transform.m[0][1] = aMatrix._21;
77289:   transform.m[0][2] = aMatrix._41;
77289:   transform.m[1][0] = aMatrix._12;
77289:   transform.m[1][1] = aMatrix._22;
77289:   transform.m[1][2] = aMatrix._42;
77289:   transform.m[2][0] = aMatrix._14;
77289:   transform.m[2][1] = aMatrix._24;
77289:   transform.m[2][2] = aMatrix._44;
77289: 
77289:   pixman_transform result;
77289:   pixman_transform_from_pixman_f_transform(&result, &transform);
77289: 
77289:   return result;
77289: }
77289: 
77289: static void
77289: PixmanTransform(const gfxImageSurface *aDest, 
77289:                 const gfxImageSurface *aSrc, 
77289:                 const gfx3DMatrix& aTransform, 
77289:                 gfxPoint aDestOffset)
77289: {
77289:   gfxIntSize destSize = aDest->GetSize();
77289:   pixman_image_t* dest = pixman_image_create_bits(aDest->Format() == gfxASurface::ImageFormatARGB32 ? PIXMAN_a8r8g8b8 : PIXMAN_x8r8g8b8,
77289:                                                   destSize.width,
77289:                                                   destSize.height,
77289:                                                   (uint32_t*)aDest->Data(),
77289:                                                   aDest->Stride());
77289: 
77289:   gfxIntSize srcSize = aSrc->GetSize();
77289:   pixman_image_t* src = pixman_image_create_bits(aSrc->Format() == gfxASurface::ImageFormatARGB32 ? PIXMAN_a8r8g8b8 : PIXMAN_x8r8g8b8,
77289:                                                  srcSize.width,
77289:                                                  srcSize.height,
77289:                                                  (uint32_t*)aSrc->Data(),
77289:                                                  aSrc->Stride());
77289: 
77289:   NS_ABORT_IF_FALSE(src && dest, "Failed to create pixman images?");
77289: 
77289:   pixman_transform pixTransform = Matrix3DToPixman(aTransform);
77289:   pixman_transform pixTransformInverted;
77289: 
77289:   // If the transform is singular then nothing would be drawn anyway, return here
77289:   if (!pixman_transform_invert(&pixTransformInverted, &pixTransform)) {
77289:     return;
77289:   }
77289:   pixman_image_set_transform(src, &pixTransformInverted);
77289: 
77289:   pixman_image_composite32(PIXMAN_OP_SRC,
77289:                            src,
77289:                            nsnull,
77289:                            dest,
77289:                            aDestOffset.x,
77289:                            aDestOffset.y,
77289:                            0,
77289:                            0,
77289:                            0,
77289:                            0,
77289:                            destSize.width,
77289:                            destSize.height);
77289: 
77289:   pixman_image_unref(dest);
77289:   pixman_image_unref(src);
77289: }
77289: 
77289: /**
77289:  * Transform a surface using a gfx3DMatrix and blit to the destination if
77289:  * it is efficient to do so.
77289:  *
77289:  * @param aSource       Source surface.
77289:  * @param aDest         Desintation context.
77289:  * @param aBounds       Area represented by aSource.
77289:  * @param aTransform    Transformation matrix.
77289:  * @param aDrawOffset   Location to draw returned surface on aDest.
77289:  * @param aDontBlit     Never draw to aDest if this is true.
77289:  * @return              Transformed surface, or nsnull if it has been drawn to aDest.
77289:  */
77289: static already_AddRefed<gfxASurface> 
77289: Transform3D(gfxASurface* aSource, gfxContext* aDest, 
77289:             const gfxRect& aBounds, const gfx3DMatrix& aTransform, 
79445:             gfxPoint& aDrawOffset, bool aDontBlit)
77289: {
77289:   nsRefPtr<gfxImageSurface> sourceImage = aSource->GetAsImageSurface();
77289:   if (!sourceImage) {
77289:     sourceImage = new gfxImageSurface(gfxIntSize(aBounds.width, aBounds.height), gfxASurface::FormatFromContent(aSource->GetContentType()));
77289:     nsRefPtr<gfxContext> ctx = new gfxContext(sourceImage);
77289: 
77289:     aSource->SetDeviceOffset(gfxPoint(0, 0));
77289:     ctx->SetSource(aSource);
77289:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
77289:     ctx->Paint();
77289:   }
77289: 
77289:   // Find the transformed rectangle of our layer.
77289:   gfxRect offsetRect = aTransform.TransformBounds(aBounds);
77289: 
77289:   // Intersect the transformed layer with the destination rectangle.
77289:   // This is in device space since we have an identity transform set on aTarget.
77289:   gfxRect destRect = aDest->GetClipExtents();
77289:   destRect.IntersectRect(destRect, offsetRect);
77289: 
77289:   // Create a surface the size of the transformed object.
77289:   nsRefPtr<gfxASurface> dest = aDest->CurrentSurface();
77289:   nsRefPtr<gfxImageSurface> destImage = dest->GetAsImageSurface();
77289:   destImage = nsnull;
77289:   gfxPoint offset;
79445:   bool blitComplete;
77289:   if (!destImage || aDontBlit || !aDest->ClipContainsRect(destRect)) {
77289:     destImage = new gfxImageSurface(gfxIntSize(destRect.width, destRect.height),
77289:                                     gfxASurface::ImageFormatARGB32);
77289:     offset = destRect.TopLeft();
80486:     blitComplete = false;
77289:   } else {
77289:     offset = -dest->GetDeviceOffset();
80486:     blitComplete = true;
77289:   }
77289: 
77289:   // Include a translation to the correct origin.
77289:   gfx3DMatrix translation = gfx3DMatrix::Translation(aBounds.x, aBounds.y, 0);
77289: 
77289:   // Transform the content and offset it such that the content begins at the origin.
77289:   PixmanTransform(destImage, sourceImage, translation * aTransform, offset);
77289: 
77289:   if (blitComplete) {
77289:     return nsnull;
77289:   }
77289: 
77289:   // If we haven't actually drawn to aDest then return our temporary image so that
77289:   // the caller can do this.
77289:   aDrawOffset = destRect.TopLeft();
77289:   return destImage.forget(); 
77289: }
77289: 
38801: void
71027: BasicLayerManager::PaintLayer(gfxContext* aTarget,
71027:                               Layer* aLayer,
42593:                               DrawThebesLayerCallback aCallback,
62698:                               void* aCallbackData,
62698:                               ReadbackProcessor* aReadback)
38801: {
57097:   const nsIntRect* clipRect = aLayer->GetEffectiveClipRect();
57097:   const gfx3DMatrix& effectiveTransform = aLayer->GetEffectiveTransform();
71025:   BasicContainerLayer* container = static_cast<BasicContainerLayer*>(aLayer);
79445:   bool needsGroup = aLayer->GetFirstChild() &&
71025:     container->UseIntermediateSurface();
75305:   BasicImplData* data = ToData(aLayer);
79445:   bool needsClipToVisibleRegion =
75305:     data->GetClipToVisibleRegion() && !aLayer->AsThebesLayer();
71025:   NS_ASSERTION(needsGroup || !aLayer->GetFirstChild() ||
71025:                container->GetOperator() == gfxContext::OPERATOR_OVER,
71025:                "non-OVER operator should have forced UseIntermediateSurface");
71025: 
57097:   // If needsSaveRestore is false, we should still save and restore
57097:   // the CTM
79445:   bool needsSaveRestore = needsGroup || clipRect || needsClipToVisibleRegion;
57097:   gfxMatrix savedMatrix;
42593:   if (needsSaveRestore) {
71027:     aTarget->Save();
39496: 
57097:     if (clipRect) {
71027:       aTarget->NewPath();
80486:       aTarget->Rectangle(gfxRect(clipRect->x, clipRect->y, clipRect->width, clipRect->height), true);
71027:       aTarget->Clip();
39496:     }
57097:   } else {
71027:     savedMatrix = aTarget->CurrentMatrix();
57097:   }
39496: 
39496:   gfxMatrix transform;
77289:   // Will return an identity matrix for 3d transforms, and is handled separately below.
79445:   bool is2D = effectiveTransform.CanDraw2D(&transform);
77289:   NS_ABORT_IF_FALSE(is2D || needsGroup || !aLayer->GetFirstChild(), "Must PushGroup for 3d transforms!");
77289:   if (is2D) {
71027:     aTarget->SetMatrix(transform);
77289:   } else {
77289:     aTarget->SetMatrix(gfxMatrix());
77289:   }
39496: 
75305:   const nsIntRegion& visibleRegion = aLayer->GetEffectiveVisibleRegion();
75305:   // If needsGroup is true, we'll clip to the visible region after we've popped the group
75305:   if (needsClipToVisibleRegion && !needsGroup) {
75305:     gfxUtils::ClipToRegion(aTarget, visibleRegion);
75305:     // Don't need to clip to visible region again
80486:     needsClipToVisibleRegion = false;
75305:   }
75305: 
79445:   bool pushedTargetOpaqueRect = false;
71027:   nsRefPtr<gfxASurface> currentSurface = aTarget->CurrentSurface();
59765:   const gfxRect& targetOpaqueRect = currentSurface->GetOpaqueRect();
59765: 
59765:   // Try to annotate currentSurface with a region of pixels that have been
59765:   // (or will be) painted opaque, if no such region is currently set.
79544:   const nsIntRect& bounds = visibleRegion.GetBounds();
59765:   if (targetOpaqueRect.IsEmpty() && visibleRegion.GetNumRects() == 1 &&
59765:       (aLayer->GetContentFlags() & Layer::CONTENT_OPAQUE) &&
59765:       !transform.HasNonAxisAlignedTransform()) {
59765:     currentSurface->SetOpaqueRect(
71027:         aTarget->UserToDevice(gfxRect(bounds.x, bounds.y, bounds.width, bounds.height)));
80486:     pushedTargetOpaqueRect = true;
59765:   }
59765: 
71027:   nsRefPtr<gfxContext> groupTarget;
79544:   nsRefPtr<gfxASurface> untransformedSurface;
79544:   if (!is2D) {
79544:     untransformedSurface = 
79544:       gfxPlatform::GetPlatform()->CreateOffscreenSurface(gfxIntSize(bounds.width, bounds.height), 
79544:                                                          gfxASurface::CONTENT_COLOR_ALPHA);
80871:     if (!untransformedSurface) {
80871:       if (pushedTargetOpaqueRect) {
80871:         currentSurface->SetOpaqueRect(gfxRect(0, 0, 0, 0));
80871:       }
80871:       NS_ASSERTION(needsSaveRestore, "Should always need to restore with 3d transforms!");
80871:       aTarget->Restore();
80871:       return;
80871:     }
79544:     untransformedSurface->SetDeviceOffset(gfxPoint(-bounds.x, -bounds.y));
79544:     groupTarget = new gfxContext(untransformedSurface);
79544:   } else if (needsGroup) {
71027:     groupTarget = PushGroupForLayer(aTarget, aLayer, aLayer->GetEffectiveVisibleRegion(),
71027:                                     &needsClipToVisibleRegion);
71027:   } else {
71027:     groupTarget = aTarget;
38801:   }
57097: 
57097:   /* Only paint ourself, or our children - This optimization relies on this! */
57097:   Layer* child = aLayer->GetFirstChild();
57097:   if (!child) {
57615: #ifdef MOZ_LAYERS_HAVE_LOG
57615:     MOZ_LAYERS_LOG(("%s (0x%p) is covered: %i\n", __FUNCTION__,
70052:                    (void*)aLayer, data->IsHidden()));
57615: #endif
62698:     if (aLayer->AsThebesLayer()) {
71027:       data->PaintThebes(groupTarget, aCallback, aCallbackData, aReadback);
62698:     } else {
71027:       data->Paint(groupTarget);
69973:     }
57097:   } else {
62698:     ReadbackProcessor readback;
79927:     ContainerLayer* container = static_cast<ContainerLayer*>(aLayer);
62698:     if (IsRetained()) {
62698:       readback.BuildUpdates(container);
62698:     }
62698:   
79927:     nsAutoTArray<Layer*, 12> children;
79927:     container->SortChildrenBy3DZOrder(children);
79927: 
79927:     for (PRUint32 i = 0; i < children.Length(); i++) {
79927:       PaintLayer(groupTarget, children.ElementAt(i), aCallback, aCallbackData, &readback);
59683:       if (mTransactionIncomplete)
59683:         break;
57097:     }
38801:   }
38801: 
57097:   if (needsGroup) {
79445:     bool blitComplete = false;
77289:     if (is2D) {
71027:       PopGroupToSourceWithCachedSurface(aTarget, groupTarget);
77289:     } else {
79544:       NS_ABORT_IF_FALSE(untransformedSurface, 
79544:                         "We should always allocate an untransformed surface with 3d transforms!");
77289: 
77289:       gfxPoint offset;
79445:       bool dontBlit = needsClipToVisibleRegion || mTransactionIncomplete || 
77289:                         aLayer->GetEffectiveOpacity() != 1.0f;
77289:       nsRefPtr<gfxASurface> result = 
79544:         Transform3D(untransformedSurface, aTarget, bounds,
77289:                     effectiveTransform, offset, dontBlit);
77289: 
77289:       blitComplete = !result;
77289:       if (result) {
77289:         aTarget->SetSource(result, offset);
77289:       }
77289:     }
71026:     // If we're doing our own double-buffering, we need to avoid drawing
71026:     // the results of an incomplete transaction to the destination surface ---
71026:     // that could cause flicker. Double-buffering is implemented using a
71026:     // temporary surface for one or more container layers, so we need to stop
71027:     // those temporary surfaces from being composited to aTarget.
71026:     // ApplyDoubleBuffering guarantees that this container layer can't
71026:     // intersect any other leaf layers, so if the transaction is not yet marked
71026:     // incomplete, the contents of this container layer are the final contents
71026:     // for the window.
77289:     if (!mTransactionIncomplete && !blitComplete) {
60026:       if (needsClipToVisibleRegion) {
71027:         gfxUtils::ClipToRegion(aTarget, aLayer->GetEffectiveVisibleRegion());
71027:       }
71027:       AutoSetOperator setOperator(aTarget, container->GetOperator());
71027:       aTarget->Paint(aLayer->GetEffectiveOpacity());
70055:     }
71026:   }
38801: 
59765:   if (pushedTargetOpaqueRect) {
59765:     currentSurface->SetOpaqueRect(gfxRect(0, 0, 0, 0));
59765:   }
59765: 
42593:   if (needsSaveRestore) {
71027:     aTarget->Restore();
57097:   } else {
71027:     aTarget->SetMatrix(savedMatrix);
38801:   }
38801: }
38801: 
50999: void
50999: BasicLayerManager::ClearCachedResources()
50999: {
50999:   if (mRoot) {
50999:     ClearLayer(mRoot);
50999:   }
50999: 
50999:   mCachedSurface.Expire();
50999: }
50999: void
50999: BasicLayerManager::ClearLayer(Layer* aLayer)
50999: {
51001:   ToData(aLayer)->ClearCachedResources();
50999:   for (Layer* child = aLayer->GetFirstChild(); child;
50999:        child = child->GetNextSibling()) {
50999:     ClearLayer(child);
50999:   }
50999: }
50999: 
38801: already_AddRefed<ThebesLayer>
38801: BasicLayerManager::CreateThebesLayer()
38801: {
38801:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
38801:   nsRefPtr<ThebesLayer> layer = new BasicThebesLayer(this);
38801:   return layer.forget();
38801: }
38801: 
38801: already_AddRefed<ContainerLayer>
38801: BasicLayerManager::CreateContainerLayer()
38801: {
38801:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
38801:   nsRefPtr<ContainerLayer> layer = new BasicContainerLayer(this);
38801:   return layer.forget();
38801: }
38801: 
39498: already_AddRefed<ImageLayer>
39498: BasicLayerManager::CreateImageLayer()
39498: {
39498:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
39498:   nsRefPtr<ImageLayer> layer = new BasicImageLayer(this);
39498:   return layer.forget();
39498: }
39498: 
42249: already_AddRefed<ColorLayer>
42249: BasicLayerManager::CreateColorLayer()
42249: {
42249:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
42249:   nsRefPtr<ColorLayer> layer = new BasicColorLayer(this);
42249:   return layer.forget();
42249: }
42249: 
42402: already_AddRefed<CanvasLayer>
42402: BasicLayerManager::CreateCanvasLayer()
42402: {
42402:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
42402:   nsRefPtr<CanvasLayer> layer = new BasicCanvasLayer(this);
42402:   return layer.forget();
42402: }
42402: 
62698: already_AddRefed<ReadbackLayer>
62698: BasicLayerManager::CreateReadbackLayer()
62698: {
62698:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
62698:   nsRefPtr<ReadbackLayer> layer = new BasicReadbackLayer(this);
62698:   return layer.forget();
62698: }
48140: 
54109: class BasicShadowableThebesLayer;
48140: class BasicShadowableLayer : public ShadowableLayer
48140: {
48140: public:
48140:   BasicShadowableLayer()
48140:   {
48140:     MOZ_COUNT_CTOR(BasicShadowableLayer);
38801:   }
48140: 
48140:   ~BasicShadowableLayer()
48140:   {
48140:     if (HasShadow()) {
48140:       PLayerChild::Send__delete__(GetShadow());
38801:     }
48140:     MOZ_COUNT_DTOR(BasicShadowableLayer);
48140:   }
48140: 
48140:   void SetShadow(PLayerChild* aShadow)
48140:   {
48140:     NS_ABORT_IF_FALSE(!mShadow, "can't have two shadows (yet)");
48140:     mShadow = aShadow;
48140:   }
48141: 
54105:   virtual void SetBackBuffer(const SurfaceDescriptor& aBuffer)
48141:   {
48141:     NS_RUNTIMEABORT("if this default impl is called, |aBuffer| leaks");
48141:   }
54013:   
69765:   virtual void SetBackBufferYUVImage(gfxSharedImageSurface* aYBuffer,
69765:                                      gfxSharedImageSurface* aUBuffer,
69765:                                      gfxSharedImageSurface* aVBuffer)
69765:   {
69765:     NS_RUNTIMEABORT("if this default impl is called, |aBuffer| leaks");
69765:   }
69765: 
54013:   virtual void Disconnect()
54013:   {
54013:     // This is an "emergency Disconnect()", called when the compositing
54013:     // process has died.  |mShadow| and our Shmem buffers are
54013:     // automatically managed by IPDL, so we don't need to explicitly
54013:     // free them here (it's hard to get that right on emergency
54013:     // shutdown anyway).
54013:     mShadow = nsnull;
54013:   }
54109: 
54109:   virtual BasicShadowableThebesLayer* AsThebes() { return nsnull; }
48140: };
48140: 
48140: static ShadowableLayer*
48140: ToShadowable(Layer* aLayer)
48140: {
48140:   return ToData(aLayer)->AsShadowableLayer();
48140: }
48140: 
62698: // Some layers, like ReadbackLayers, can't be shadowed and shadowing
62698: // them doesn't make sense anyway
62698: static bool
62698: ShouldShadow(Layer* aLayer)
62698: {
62698:   if (!ToShadowable(aLayer)) {
62698:     NS_ABORT_IF_FALSE(aLayer->GetType() == Layer::TYPE_READBACK,
62698:                       "Only expect not to shadow ReadbackLayers");
62698:     return false;
62698:   }
62698:   return true;
62698: }
62698: 
48141: template<class OpT>
48141: static BasicShadowableLayer*
48141: GetBasicShadowable(const OpT& op)
48141: {
48141:   return static_cast<BasicShadowableLayer*>(
48141:     static_cast<const ShadowLayerChild*>(op.layerChild())->layer());
48141: }
48141: 
48140: class BasicShadowableContainerLayer : public BasicContainerLayer,
48140:                                       public BasicShadowableLayer {
48140: public:
48140:   BasicShadowableContainerLayer(BasicShadowLayerManager* aManager) :
48140:     BasicContainerLayer(aManager)
48140:   {
48140:     MOZ_COUNT_CTOR(BasicShadowableContainerLayer);
48140:   }
48140:   virtual ~BasicShadowableContainerLayer()
48140:   {
48140:     MOZ_COUNT_DTOR(BasicShadowableContainerLayer);
48140:   }
48140: 
48140:   virtual void InsertAfter(Layer* aChild, Layer* aAfter);
48140:   virtual void RemoveChild(Layer* aChild);
48140: 
48140:   virtual Layer* AsLayer() { return this; }
48140:   virtual ShadowableLayer* AsShadowableLayer() { return this; }
48140: 
54013:   virtual void Disconnect()
54013:   {
54013:     BasicShadowableLayer::Disconnect();
54013:   }
54013: 
48140: private:
48140:   BasicShadowLayerManager* ShadowManager()
48140:   {
48140:     return static_cast<BasicShadowLayerManager*>(mManager);
48140:   }
48140: };
48140: 
48140: void
48140: BasicShadowableContainerLayer::InsertAfter(Layer* aChild, Layer* aAfter)
48140: {
62698:   if (HasShadow() && ShouldShadow(aChild)) {
62698:     while (aAfter && !ShouldShadow(aAfter)) {
62698:       aAfter = aAfter->GetPrevSibling();
62698:     }
48140:     ShadowManager()->InsertAfter(ShadowManager()->Hold(this),
48140:                                  ShadowManager()->Hold(aChild),
48142:                                  aAfter ? ShadowManager()->Hold(aAfter) : nsnull);
48140:   }
48140:   BasicContainerLayer::InsertAfter(aChild, aAfter);
48140: }
48140: 
48140: void
48140: BasicShadowableContainerLayer::RemoveChild(Layer* aChild)
48140: {
62698:   if (HasShadow() && ShouldShadow(aChild)) {
48140:     ShadowManager()->RemoveChild(ShadowManager()->Hold(this),
48140:                                  ShadowManager()->Hold(aChild));
48140:   }
48140:   BasicContainerLayer::RemoveChild(aChild);
48140: }
48140: 
48140: class BasicShadowableThebesLayer : public BasicThebesLayer,
48140:                                    public BasicShadowableLayer
48140: {
48143:   typedef BasicThebesLayer Base;
48143: 
48140: public:
57430:   BasicShadowableThebesLayer(BasicShadowLayerManager* aManager)
57430:     : BasicThebesLayer(aManager)
57430:     , mIsNewBuffer(false)
80169:     , mFrontAndBackBufferDiffer(false)
48140:   {
48140:     MOZ_COUNT_CTOR(BasicShadowableThebesLayer);
48140:   }
48140:   virtual ~BasicShadowableThebesLayer()
48140:   {
80169:     DestroyBackBuffer();
48140:     MOZ_COUNT_DTOR(BasicShadowableThebesLayer);
48140:   }
48140: 
48140:   virtual void FillSpecificAttributes(SpecificLayerAttributes& aAttrs)
48140:   {
72234:     aAttrs = ThebesLayerAttributes(GetValidRegion());
48140:   }
48140: 
48140:   virtual Layer* AsLayer() { return this; }
48140:   virtual ShadowableLayer* AsShadowableLayer() { return this; }
55433:   virtual bool MustRetainContent() { return HasShadow(); }
48143: 
80169:   void SetBackBufferAndAttrs(const OptionalThebesBuffer& aBuffer,
54109:                              const nsIntRegion& aValidRegion,
56899:                              const OptionalThebesBuffer& aReadOnlyFrontBuffer,
56899:                              const nsIntRegion& aFrontUpdatedRegion);
48143: 
54013:   virtual void Disconnect()
54013:   {
54105:     mBackBuffer = SurfaceDescriptor();
54013:     BasicShadowableLayer::Disconnect();
54013:   }
54013: 
54109:   virtual BasicShadowableThebesLayer* AsThebes() { return this; }
54109: 
80169:   virtual void SyncFrontBufferToBackBuffer();
80169: 
48143: private:
48143:   BasicShadowLayerManager* BasicManager()
48143:   {
48143:     return static_cast<BasicShadowLayerManager*>(mManager);
48143:   }
48143: 
48143:   NS_OVERRIDE virtual void
48143:   PaintBuffer(gfxContext* aContext,
48143:               const nsIntRegion& aRegionToDraw,
63366:               const nsIntRegion& aExtendedRegionToDraw,
48143:               const nsIntRegion& aRegionToInvalidate,
79445:               bool aDidSelfCopy,
48143:               LayerManager::DrawThebesLayerCallback aCallback,
48143:               void* aCallbackData);
48143: 
48143:   NS_OVERRIDE virtual already_AddRefed<gfxASurface>
48143:   CreateBuffer(Buffer::ContentType aType, const nsIntSize& aSize);
48143: 
80169:   void DestroyBackBuffer()
80169:   {
80169:     if (IsSurfaceDescriptorValid(mBackBuffer)) {
80169:       BasicManager()->ShadowLayerForwarder::DestroySharedSurface(&mBackBuffer);
80169:     }
80169:   }
80169: 
54105:   // This describes the gfxASurface we hand to mBuffer.  We keep a
54105:   // copy of the descriptor here so that we can call
54105:   // DestroySharedSurface() on the descriptor.
54105:   SurfaceDescriptor mBackBuffer;
80169:   nsIntRect mBackBufferRect;
80169:   nsIntPoint mBackBufferRectRotation;
57430: 
79445:   bool mIsNewBuffer;
80169:   OptionalThebesBuffer mROFrontBuffer;
80169:   nsIntRegion mFrontUpdatedRegion;
80169:   nsIntRegion mFrontValidRegion;
80169:   PRPackedBool mFrontAndBackBufferDiffer;
48140: };
48140: 
48143: void
80169: BasicShadowableThebesLayer::SetBackBufferAndAttrs(const OptionalThebesBuffer& aBuffer,
56898:                                                   const nsIntRegion& aValidRegion,
56899:                                                   const OptionalThebesBuffer& aReadOnlyFrontBuffer,
56899:                                                   const nsIntRegion& aFrontUpdatedRegion)
56898: {
80169:   if (OptionalThebesBuffer::Tnull_t == aBuffer.type()) {
80169:     mBackBuffer = SurfaceDescriptor();
80169:   } else {
80169:     mBackBuffer = aBuffer.get_ThebesBuffer().buffer();
80169:     mBackBufferRect = aBuffer.get_ThebesBuffer().rect();
80169:     mBackBufferRectRotation = aBuffer.get_ThebesBuffer().rotation();
80169:   }
80169:   mFrontAndBackBufferDiffer = true;
80169:   mROFrontBuffer = aReadOnlyFrontBuffer;
80169:   mFrontUpdatedRegion = aFrontUpdatedRegion;
80169:   mFrontValidRegion = aValidRegion;
80463:   if (OptionalThebesBuffer::Tnull_t == mROFrontBuffer.type()) {
80463:     // For null readonly front, we have single buffer mode
80463:     // so we can do sync right now, because it does not create new buffer and
80463:     // don't do any graphic operations
80463:     SyncFrontBufferToBackBuffer();
80463:   }
80169: }
80169: 
80169: void
80169: BasicShadowableThebesLayer::SyncFrontBufferToBackBuffer()
80169: {
80169:   if (!mFrontAndBackBufferDiffer) {
80169:     return;
80169:   }
80169: 
80169:   nsRefPtr<gfxASurface> backBuffer;
80169:   if (!IsSurfaceDescriptorValid(mBackBuffer)) {
80169:     NS_ABORT_IF_FALSE(mROFrontBuffer.type() == OptionalThebesBuffer::TThebesBuffer,
80169:                       "should have a front RO buffer by now");
80169:     const ThebesBuffer roFront = mROFrontBuffer.get_ThebesBuffer();
80169:     nsRefPtr<gfxASurface> roFrontBuffer = BasicManager()->OpenDescriptor(roFront.buffer());
80169:     backBuffer = CreateBuffer(roFrontBuffer->GetContentType(), roFrontBuffer->GetSize());
80169:   } else {
80169:     backBuffer = BasicManager()->OpenDescriptor(mBackBuffer);
80169:   }
80169:   mFrontAndBackBufferDiffer = false;
80169: 
80169:   if (OptionalThebesBuffer::Tnull_t == mROFrontBuffer.type()) {
56899:     // We didn't get back a read-only ref to our old back buffer (the
56899:     // parent's new front buffer).  If the parent is pushing updates
56899:     // to a texture it owns, then we probably got back the same buffer
56899:     // we pushed in the update and all is well.  If not, ...
80169:     mValidRegion = mFrontValidRegion;
80169:     mBuffer.SetBackingBuffer(backBuffer, mBackBufferRect, mBackBufferRectRotation);
56899:     return;
56899:   }
56903: 
56905:   MOZ_LAYERS_LOG(("BasicShadowableThebes(%p): reading back <x=%d,y=%d,w=%d,h=%d>",
56905:                   this,
80169:                   mFrontUpdatedRegion.GetBounds().x,
80169:                   mFrontUpdatedRegion.GetBounds().y,
80169:                   mFrontUpdatedRegion.GetBounds().width,
80169:                   mFrontUpdatedRegion.GetBounds().height));
80169: 
80169:   const ThebesBuffer roFront = mROFrontBuffer.get_ThebesBuffer();
56903:   nsRefPtr<gfxASurface> roFrontBuffer = BasicManager()->OpenDescriptor(roFront.buffer());
56903:   mBuffer.SetBackingBufferAndUpdateFrom(
56903:     backBuffer,
56903:     roFrontBuffer, roFront.rect(), roFront.rotation(),
80169:     mFrontUpdatedRegion);
80169:   mIsNewBuffer = false;
56903:   // Now the new back buffer has the same (interesting) pixels as the
56903:   // new front buffer, and mValidRegion et al. are correct wrt the new
56903:   // back buffer (i.e. as they were for the old back buffer)
56898: }
56898: 
56898: void
48143: BasicShadowableThebesLayer::PaintBuffer(gfxContext* aContext,
48143:                                         const nsIntRegion& aRegionToDraw,
63366:                                         const nsIntRegion& aExtendedRegionToDraw,
48143:                                         const nsIntRegion& aRegionToInvalidate,
79445:                                         bool aDidSelfCopy,
48143:                                         LayerManager::DrawThebesLayerCallback aCallback,
48143:                                         void* aCallbackData)
48143: {
63366:   Base::PaintBuffer(aContext,
63366:                     aRegionToDraw, aExtendedRegionToDraw, aRegionToInvalidate,
63397:                     aDidSelfCopy,
48143:                     aCallback, aCallbackData);
56898:   if (!HasShadow()) {
56898:     return;
56898:   }
48143: 
57430:   nsIntRegion updatedRegion;
63397:   if (mIsNewBuffer || aDidSelfCopy) {
57430:     // A buffer reallocation clears both buffers. The front buffer has all the
57430:     // content by now, but the back buffer is still clear. Here, in effect, we
57430:     // are saying to copy all of the pixels of the front buffer to the back.
63397:     // Also when we self-copied in the buffer, the buffer space
63397:     // changes and some changed buffer content isn't reflected in the
63397:     // draw or invalidate region (on purpose!).  When this happens, we
63397:     // need to read back the entire buffer too.
57430:     updatedRegion = mVisibleRegion;
57430:     mIsNewBuffer = false;
57430:   } else {
57430:     updatedRegion = aRegionToDraw;
57430:   }
57430: 
63366:   NS_ASSERTION(mBuffer.BufferRect().Contains(aRegionToDraw.GetBounds()),
63366:                "Update outside of buffer rect!");
54105:   NS_ABORT_IF_FALSE(IsSurfaceDescriptorValid(mBackBuffer),
54105:                     "should have a back buffer by now");
48143:   BasicManager()->PaintedThebesBuffer(BasicManager()->Hold(this),
57430:                                       updatedRegion,
48143:                                       mBuffer.BufferRect(),
48143:                                       mBuffer.BufferRotation(),
48143:                                       mBackBuffer);
48143: }
48143: 
48143: already_AddRefed<gfxASurface>
48143: BasicShadowableThebesLayer::CreateBuffer(Buffer::ContentType aType,
48143:                                          const nsIntSize& aSize)
48143: {
54101:   if (!HasShadow()) {
54101:     return BasicThebesLayer::CreateBuffer(aType, aSize);
54071:   }
54071: 
56905:   MOZ_LAYERS_LOG(("BasicShadowableThebes(%p): creating %d x %d buffer(x2)",
56905:                   this,
56905:                   aSize.width, aSize.height));
56905: 
54105:   if (IsSurfaceDescriptorValid(mBackBuffer)) {
80172:     BasicManager()->DestroyedThebesBuffer(BasicManager()->Hold(this),
80172:                                           mBackBuffer);
54105:     mBackBuffer = SurfaceDescriptor();
54101:   }
54101: 
48143:   // XXX error handling
59744:   if (!BasicManager()->AllocBuffer(gfxIntSize(aSize.width, aSize.height),
59744:                                    aType,
59744:                                    &mBackBuffer)) {
59744:       NS_RUNTIMEABORT("creating ThebesLayer 'back buffer' failed!");
59744:   }
56904: 
57430:   NS_ABORT_IF_FALSE(!mIsNewBuffer,
57430:                     "Bad! Did we create a buffer twice without painting?");
80169: 
57430:   mIsNewBuffer = true;
57430: 
54105:   return BasicManager()->OpenDescriptor(mBackBuffer);
48143: }
48143: 
48143: 
48140: class BasicShadowableImageLayer : public BasicImageLayer,
48140:                                   public BasicShadowableLayer
48140: {
48140: public:
48140:   BasicShadowableImageLayer(BasicShadowLayerManager* aManager) :
80708:     BasicImageLayer(aManager),
80708:     mBufferIsOpaque(false)
48140:   {
48140:     MOZ_COUNT_CTOR(BasicShadowableImageLayer);
48140:   }
48140:   virtual ~BasicShadowableImageLayer()
48140:   {
79425:     DestroyBackBuffer();
48140:     MOZ_COUNT_DTOR(BasicShadowableImageLayer);
48140:   }
48140: 
62698:   virtual void Paint(gfxContext* aContext);
48142: 
48140:   virtual void FillSpecificAttributes(SpecificLayerAttributes& aAttrs)
48140:   {
48140:     aAttrs = ImageLayerAttributes(mFilter);
48140:   }
48140: 
48140:   virtual Layer* AsLayer() { return this; }
48140:   virtual ShadowableLayer* AsShadowableLayer() { return this; }
48142: 
69106:   virtual void SetBackBuffer(const SurfaceDescriptor& aBuffer)
48142:   {
69106:     mBackBuffer = aBuffer;
48142:   }
48142: 
69765:   virtual void SetBackBufferYUVImage(gfxSharedImageSurface* aYBuffer,
69765:                                      gfxSharedImageSurface* aUBuffer,
69765:                                      gfxSharedImageSurface* aVBuffer)
69765:   {
69765:     mBackBufferY = aYBuffer;
69765:     mBackBufferU = aUBuffer;
69765:     mBackBufferV = aVBuffer;
69765:   }
69765: 
54013:   virtual void Disconnect()
54013:   {
79425:     mBackBufferY = mBackBufferU = mBackBufferV = nsnull;
69106:     mBackBuffer = SurfaceDescriptor();
54013:     BasicShadowableLayer::Disconnect();
54013:   }
54013: 
79425:   void DestroyBackBuffer()
79425:   {
79425:     if (IsSurfaceDescriptorValid(mBackBuffer)) {
79425:       BasicManager()->ShadowLayerForwarder::DestroySharedSurface(&mBackBuffer);
79425:     }
79425:     if (mBackBufferY) {
79425:       BasicManager()->ShadowLayerForwarder::DestroySharedSurface(mBackBufferY);
79425:       BasicManager()->ShadowLayerForwarder::DestroySharedSurface(mBackBufferU);
79425:       BasicManager()->ShadowLayerForwarder::DestroySharedSurface(mBackBufferV);
79425:     }
79425:   }
79425: 
48142: private:
48142:   BasicShadowLayerManager* BasicManager()
48142:   {
48142:     return static_cast<BasicShadowLayerManager*>(mManager);
48142:   }
48142: 
69765:   // For YUV Images these are the 3 planes (Y, Cb and Cr),
69765:   // for RGB images only mBackSurface is used.
69106:   SurfaceDescriptor mBackBuffer;
80708:   bool mBufferIsOpaque;
69765:   nsRefPtr<gfxSharedImageSurface> mBackBufferY;
69765:   nsRefPtr<gfxSharedImageSurface> mBackBufferU;
69765:   nsRefPtr<gfxSharedImageSurface> mBackBufferV;
69765:   gfxIntSize mCbCrSize;
48140: };
48140:  
48142: void
62698: BasicShadowableImageLayer::Paint(gfxContext* aContext)
48142: {
69768:   if (!mContainer) {
69768:     return;
69768:   }
69768: 
69765:   nsRefPtr<Image> image = mContainer->GetCurrentImage();
69768:   if (!image) {
69768:     return;
69768:   }
69765: 
69765:   if (image->GetFormat() == Image::PLANAR_YCBCR && BasicManager()->IsCompositingCheap()) {
69765:     PlanarYCbCrImage *YCbCrImage = static_cast<PlanarYCbCrImage*>(image.get());
69765:     const PlanarYCbCrImage::Data *data = YCbCrImage->GetData();
69765:     NS_ASSERTION(data, "Must be able to retrieve yuv data from image!");
69765: 
79425:     if (mSize != data->mYSize || mCbCrSize != data->mCbCrSize || !mBackBufferY) {
79425:       DestroyBackBuffer();
69765:       mSize = data->mYSize;
69765:       mCbCrSize = data->mCbCrSize;
69765: 
79425:       if (!BasicManager()->AllocBuffer(mSize, gfxASurface::CONTENT_ALPHA,
79425:                                        getter_AddRefs(mBackBufferY)) ||
79425:           !BasicManager()->AllocBuffer(mCbCrSize, gfxASurface::CONTENT_ALPHA,
79425:                                        getter_AddRefs(mBackBufferU)) ||
79425:           !BasicManager()->AllocBuffer(mCbCrSize, gfxASurface::CONTENT_ALPHA,
79425:                                        getter_AddRefs(mBackBufferV))) {
69765:         NS_RUNTIMEABORT("creating ImageLayer 'front buffer' failed!");
79425:       }
69765:     }
69765: 
73014:     for (int i = 0; i < data->mYSize.height; i++) {
73014:       memcpy(mBackBufferY->Data() + i * mBackBufferY->Stride(),
73014:              data->mYChannel + i * data->mYStride,
73014:              data->mYSize.width);
73014:     }
73014:     for (int i = 0; i < data->mCbCrSize.height; i++) {
73014:       memcpy(mBackBufferU->Data() + i * mBackBufferU->Stride(),
73014:              data->mCbChannel + i * data->mCbCrStride,
73014:              data->mCbCrSize.width);
73014:       memcpy(mBackBufferV->Data() + i * mBackBufferV->Stride(),
73014:              data->mCrChannel + i * data->mCbCrStride,
73014:              data->mCbCrSize.width);
73014:     }
69765: 
69765:     YUVImage yuv(mBackBufferY->GetShmem(),
69765:                  mBackBufferU->GetShmem(),
73014:                  mBackBufferV->GetShmem(),
73014:                  data->GetPictureRect());
69765: 
69765:     BasicManager()->PaintedImage(BasicManager()->Hold(this),
69765:                                  yuv);
69765:     return;
69765:   }
69765: 
48142:   gfxIntSize oldSize = mSize;
57097:   nsRefPtr<gfxPattern> pat = GetAndPaintCurrentImage(aContext, GetEffectiveOpacity());
48142:   if (!pat || !HasShadow())
48142:     return;
48142: 
80708:   bool isOpaque = (GetContentFlags() & CONTENT_OPAQUE);
80708:   if (oldSize != mSize || 
80708:       !IsSurfaceDescriptorValid(mBackBuffer) ||
80708:       isOpaque != mBufferIsOpaque) {
79425:     DestroyBackBuffer();
80708:     mBufferIsOpaque = isOpaque;
79425: 
79425:     if (!BasicManager()->AllocBuffer(
54285:           mSize,
80708:           isOpaque ?
54285:             gfxASurface::CONTENT_COLOR : gfxASurface::CONTENT_COLOR_ALPHA,
79425:           &mBackBuffer))
48142:       NS_RUNTIMEABORT("creating ImageLayer 'front buffer' failed!");
48142:   }
48142: 
69106:   nsRefPtr<gfxASurface> backSurface =
69106:     BasicManager()->OpenDescriptor(mBackBuffer);
69106:   nsRefPtr<gfxContext> tmpCtx = new gfxContext(backSurface);
78248:   tmpCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
61312:   PaintContext(pat,
61312:                nsIntRegion(nsIntRect(0, 0, mSize.width, mSize.height)),
61312:                nsnull, 1.0, tmpCtx);
48142: 
48142:   BasicManager()->PaintedImage(BasicManager()->Hold(this),
69106:                                mBackBuffer);
48142: }
48142: 
48142: 
48140: class BasicShadowableColorLayer : public BasicColorLayer,
48140:                                   public BasicShadowableLayer
48140: {
48140: public:
48140:   BasicShadowableColorLayer(BasicShadowLayerManager* aManager) :
48140:     BasicColorLayer(aManager)
48140:   {
48140:     MOZ_COUNT_CTOR(BasicShadowableColorLayer);
48140:   }
48140:   virtual ~BasicShadowableColorLayer()
48140:   {
48140:     MOZ_COUNT_DTOR(BasicShadowableColorLayer);
48140:   }
48140: 
48140:   virtual void FillSpecificAttributes(SpecificLayerAttributes& aAttrs)
48140:   {
48140:     aAttrs = ColorLayerAttributes(GetColor());
48140:   }
48140: 
48140:   virtual Layer* AsLayer() { return this; }
48140:   virtual ShadowableLayer* AsShadowableLayer() { return this; }
54013: 
54013:   virtual void Disconnect()
54013:   {
54013:     BasicShadowableLayer::Disconnect();
54013:   }
48140: };
48140: 
48140: class BasicShadowableCanvasLayer : public BasicCanvasLayer,
48140:                                    public BasicShadowableLayer
48140: {
48140: public:
48140:   BasicShadowableCanvasLayer(BasicShadowLayerManager* aManager) :
80708:     BasicCanvasLayer(aManager),
80708:     mBufferIsOpaque(false)
48140:   {
48140:     MOZ_COUNT_CTOR(BasicShadowableCanvasLayer);
48140:   }
48140:   virtual ~BasicShadowableCanvasLayer()
48140:   {
79426:     DestroyBackBuffer();
48140:     MOZ_COUNT_DTOR(BasicShadowableCanvasLayer);
48140:   }
48140: 
48141:   virtual void Initialize(const Data& aData);
62698:   virtual void Paint(gfxContext* aContext);
48141: 
48140:   virtual void FillSpecificAttributes(SpecificLayerAttributes& aAttrs)
48140:   {
48140:     aAttrs = CanvasLayerAttributes(mFilter);
48140:   }
48140: 
48140:   virtual Layer* AsLayer() { return this; }
48140:   virtual ShadowableLayer* AsShadowableLayer() { return this; }
48141: 
69106:   virtual void SetBackBuffer(const SurfaceDescriptor& aBuffer)
48141:   {
48141:     mBackBuffer = aBuffer;
48141:   }
48141: 
54013:   virtual void Disconnect()
54013:   {
69106:     mBackBuffer = SurfaceDescriptor();
54013:     BasicShadowableLayer::Disconnect();
54013:   }
54013: 
79426:   void DestroyBackBuffer()
79426:   {
79426:     if (IsSurfaceDescriptorValid(mBackBuffer)) {
79426:       BasicManager()->ShadowLayerForwarder::DestroySharedSurface(&mBackBuffer);
79426:       mBackBuffer = SurfaceDescriptor();
79426:     }
79426:   }
79426: 
48141: private:
48141:   BasicShadowLayerManager* BasicManager()
48141:   {
48141:     return static_cast<BasicShadowLayerManager*>(mManager);
48141:   }
48141: 
69106:   SurfaceDescriptor mBackBuffer;
80708:   bool mBufferIsOpaque;
48140: };
48140: 
48141: void
48141: BasicShadowableCanvasLayer::Initialize(const Data& aData)
48141: {
48141:   BasicCanvasLayer::Initialize(aData);
48141:   if (!HasShadow())
48141:       return;
48141: 
54071:   // XXX won't get here currently; need to figure out what to do on
54071:   // canvas resizes
69106: 
69106:   if (IsSurfaceDescriptorValid(mBackBuffer)) {
79426:     nsRefPtr<gfxASurface> backSurface =
79426:       BasicManager()->OpenDescriptor(mBackBuffer);
79426:     if (gfxIntSize(mBounds.width, mBounds.height) != backSurface->GetSize()) {
79426:       DestroyBackBuffer();
79426:     }
79426:   }
48141: }
48141: 
48141: void
62698: BasicShadowableCanvasLayer::Paint(gfxContext* aContext)
48141: {
71550:   if (!HasShadow()) {
62698:     BasicCanvasLayer::Paint(aContext);
48141:     return;
71550:   }
71550: 
80708:   bool isOpaque = (GetContentFlags() & CONTENT_OPAQUE);
80708:   if (!IsSurfaceDescriptorValid(mBackBuffer) ||
80708:       isOpaque != mBufferIsOpaque) {
80708:     DestroyBackBuffer();
80708:     mBufferIsOpaque = isOpaque;
79426:     if (!BasicManager()->AllocBuffer(
79426:         gfxIntSize(mBounds.width, mBounds.height),
80708:         isOpaque ?
79426:           gfxASurface::CONTENT_COLOR : gfxASurface::CONTENT_COLOR_ALPHA,
79426:         &mBackBuffer))
79426:     NS_RUNTIMEABORT("creating CanvasLayer back buffer failed!");
79426:   }
79426: 
69106:   nsRefPtr<gfxASurface> backSurface =
69106:     BasicManager()->OpenDescriptor(mBackBuffer);
71550: 
71550:   UpdateSurface(backSurface);
71550:   FireDidTransactionCallback();
48141: 
48141:   BasicManager()->PaintedCanvas(BasicManager()->Hold(this),
79426:                                 mNeedsYFlip ? true : false,
48141:                                 mBackBuffer);
48141: }
48141: 
48143: class ShadowThebesLayerBuffer : public BasicThebesLayerBuffer
48143: {
48143:   typedef BasicThebesLayerBuffer Base;
48143: 
48143: public:
48143:   ShadowThebesLayerBuffer()
48143:     : Base(NULL)
48143:   {
48143:     MOZ_COUNT_CTOR(ShadowThebesLayerBuffer);
48143:   }
48143: 
48143:   ~ShadowThebesLayerBuffer()
48143:   {
48143:     MOZ_COUNT_DTOR(ShadowThebesLayerBuffer);
48143:   }
48143: 
54109:   void Swap(gfxASurface* aNewBuffer,
54109:             const nsIntRect& aNewRect, const nsIntPoint& aNewRotation,
54109:             gfxASurface** aOldBuffer,
54109:             nsIntRect* aOldRect, nsIntPoint* aOldRotation)
48143:   {
54109:     *aOldRect = BufferRect();
54109:     *aOldRotation = BufferRotation();
54109: 
54109:     nsRefPtr<gfxASurface> oldBuffer;
54109:     oldBuffer = SetBuffer(aNewBuffer,
54109:                           aNewRect, aNewRotation);
54109:     oldBuffer.forget(aOldBuffer);
48143:   }
48143: 
48143: protected:
48143:   virtual already_AddRefed<gfxASurface>
78821:   CreateBuffer(ContentType, const nsIntSize&, PRUint32)
48143:   {
48143:     NS_RUNTIMEABORT("ShadowThebesLayer can't paint content");
48143:     return nsnull;
48143:   }
48143: };
48141: 
54109: 
71025: class BasicShadowThebesLayer : public ShadowThebesLayer, public BasicImplData {
48140: public:
54109:   BasicShadowThebesLayer(BasicShadowLayerManager* aLayerManager)
54109:     : ShadowThebesLayer(aLayerManager, static_cast<BasicImplData*>(this))
48140:   {
48140:     MOZ_COUNT_CTOR(BasicShadowThebesLayer);
48140:   }
54013:   virtual ~BasicShadowThebesLayer()
54013:   {
54013:     // If Disconnect() wasn't called on us, then we assume that the
54013:     // remote side shut down and IPC is disconnected, so we let IPDL
54013:     // clean up our front surface Shmem.
54013:     MOZ_COUNT_DTOR(BasicShadowThebesLayer);
54013:   }
54013: 
54109:   virtual void SetValidRegion(const nsIntRegion& aRegion)
54109:   {
54109:     mOldValidRegion = mValidRegion;
54109:     ShadowThebesLayer::SetValidRegion(aRegion);
54109:   }
54109: 
54071:   virtual void Disconnect()
54071:   {
54071:     DestroyFrontBuffer();
54071:     ShadowThebesLayer::Disconnect();
54071:   }
48140: 
54109:   virtual void
54109:   Swap(const ThebesBuffer& aNewFront, const nsIntRegion& aUpdatedRegion,
80169:        OptionalThebesBuffer* aNewBack, nsIntRegion* aNewBackValidRegion,
56899:        OptionalThebesBuffer* aReadOnlyFront, nsIntRegion* aFrontUpdatedRegion);
48140: 
54071:   virtual void DestroyFrontBuffer()
54071:   {
54109:     mFrontBuffer.Clear();
54113:     mValidRegion.SetEmpty();
54109:     mOldValidRegion.SetEmpty();
54109: 
54105:     if (IsSurfaceDescriptorValid(mFrontBufferDescriptor)) {
79425:       mAllocator->DestroySharedSurface(&mFrontBufferDescriptor);
80169:       mFrontBufferDescriptor = SurfaceDescriptor();
54071:     }
54071:   }
54071: 
62698:   virtual void PaintThebes(gfxContext* aContext,
48140:                            LayerManager::DrawThebesLayerCallback aCallback,
62698:                            void* aCallbackData,
62698:                            ReadbackProcessor* aReadback);
48140: 
48143: private:
48143:   BasicShadowLayerManager* BasicManager()
48143:   {
48143:     return static_cast<BasicShadowLayerManager*>(mManager);
48143:   }
48143: 
48143:   ShadowThebesLayerBuffer mFrontBuffer;
54105:   // Describes the gfxASurface we hand out to |mFrontBuffer|.
54105:   SurfaceDescriptor mFrontBufferDescriptor;
54109:   // When we receive an update from our remote partner, we stow away
54109:   // our previous parameters that described our previous front buffer.
54109:   // Then when we Swap() back/front buffers, we can return these
54109:   // parameters to our partner (adjusted as needed).
54109:   nsIntRegion mOldValidRegion;
48140: };
48140: 
54109: void
54109: BasicShadowThebesLayer::Swap(const ThebesBuffer& aNewFront,
54109:                              const nsIntRegion& aUpdatedRegion,
80169:                              OptionalThebesBuffer* aNewBack,
54109:                              nsIntRegion* aNewBackValidRegion,
56899:                              OptionalThebesBuffer* aReadOnlyFront,
56899:                              nsIntRegion* aFrontUpdatedRegion)
54105: {
80169:   nsRefPtr<gfxASurface> newFrontBuffer =
80169:     BasicManager()->OpenDescriptor(aNewFront.buffer());
80169: 
80169:   if (IsSurfaceDescriptorValid(mFrontBufferDescriptor)) {
80169:     nsRefPtr<gfxASurface> currentFront = BasicManager()->OpenDescriptor(mFrontBufferDescriptor);
80169:     if (currentFront->GetSize() != newFrontBuffer->GetSize()) {
80169:       // Current front buffer is obsolete
80169:       DestroyFrontBuffer();
80169:     }
80169:   }
54113:   // This code relies on Swap() arriving *after* attribute mutations.
80169:   if (IsSurfaceDescriptorValid(mFrontBufferDescriptor)) {
80169:     *aNewBack = ThebesBuffer();
80169:     aNewBack->get_ThebesBuffer().buffer() = mFrontBufferDescriptor;
80169:   } else {
80169:     *aNewBack = null_t();
80169:   }
54109:   // We have to invalidate the pixels painted into the new buffer.
54109:   // They might overlap with our old pixels.
54701:   aNewBackValidRegion->Sub(mOldValidRegion, aUpdatedRegion);
54109: 
54109:   nsRefPtr<gfxASurface> unused;
80169:   nsIntRect backRect;
80169:   nsIntPoint backRotation;
54109:   mFrontBuffer.Swap(
54109:     newFrontBuffer, aNewFront.rect(), aNewFront.rotation(),
80169:     getter_AddRefs(unused), &backRect, &backRotation);
80169: 
80169:   if (aNewBack->type() != OptionalThebesBuffer::Tnull_t) {
80169:     aNewBack->get_ThebesBuffer().rect() = backRect;
80169:     aNewBack->get_ThebesBuffer().rotation() = backRotation;
80169:   }
54105: 
54109:   mFrontBufferDescriptor = aNewFront.buffer();
56899: 
56903:   *aReadOnlyFront = aNewFront;
56903:   *aFrontUpdatedRegion = aUpdatedRegion;
54105: }
54105: 
48143: void
62698: BasicShadowThebesLayer::PaintThebes(gfxContext* aContext,
48143:                                     LayerManager::DrawThebesLayerCallback aCallback,
62698:                                     void* aCallbackData,
62698:                                     ReadbackProcessor* aReadback)
48143: {
48143:   NS_ASSERTION(BasicManager()->InDrawing(),
48143:                "Can only draw in drawing phase");
48143:   NS_ASSERTION(BasicManager()->IsRetained(),
48143:                "ShadowThebesLayer makes no sense without retained mode");
48143: 
54013:   if (!mFrontBuffer.GetBuffer()) {
54013:     return;
54013:   }
54013: 
71023:   mFrontBuffer.DrawTo(this, aContext, GetEffectiveOpacity());
48143: }
48143: 
71025: class BasicShadowContainerLayer : public ShadowContainerLayer, public BasicImplData {
55445:   template<class Container>
55445:   friend void ContainerInsertAfter(Layer* aChild, Layer* aAfter, Container* aContainer);
55445:   template<class Container>
55445:   friend void ContainerRemoveChild(Layer* aChild, Container* aContainer);
55445: 
55445: public:
55445:   BasicShadowContainerLayer(BasicShadowLayerManager* aLayerManager) :
55445:     ShadowContainerLayer(aLayerManager, static_cast<BasicImplData*>(this))
55445:   {
55445:     MOZ_COUNT_CTOR(BasicShadowContainerLayer);
55445:   }
55445:   virtual ~BasicShadowContainerLayer()
55445:   {
55445:     while (mFirstChild) {
55445:       ContainerRemoveChild(mFirstChild, this);
55445:     }
55445: 
55445:     MOZ_COUNT_DTOR(BasicShadowContainerLayer);
55445:   }
55445: 
55445:   virtual void InsertAfter(Layer* aChild, Layer* aAfter)
55445:   { ContainerInsertAfter(aChild, aAfter, this); }
55445:   virtual void RemoveChild(Layer* aChild)
55445:   { ContainerRemoveChild(aChild, this); }
57097: 
57097:   virtual void ComputeEffectiveTransforms(const gfx3DMatrix& aTransformToSurface)
57097:   {
57097:     // We push groups for container layers if we need to, which always
57097:     // are aligned in device space, so it doesn't really matter how we snap
57097:     // containers.
77289:     gfxMatrix residual;
57097:     gfx3DMatrix idealTransform = GetLocalTransform()*aTransformToSurface;
77289: 
77289:     if (!idealTransform.CanDraw2D()) {
77289:       mEffectiveTransform = idealTransform;
77289:       ComputeEffectiveTransformsForChildren(gfx3DMatrix());
80486:       mUseIntermediateSurface = true;
77289:       return;
77289:     }
77289: 
77289:     mEffectiveTransform = SnapTransform(idealTransform, gfxRect(0, 0, 0, 0), &residual);
57097:     // We always pass the ideal matrix down to our children, so there is no
57097:     // need to apply any compensation using the residual from SnapTransform.
57097:     ComputeEffectiveTransformsForChildren(idealTransform);
57097: 
57097:     /* If we have a single child, it can just inherit our opacity,
57097:      * otherwise we need a PushGroup and we need to mark ourselves as using
57097:      * an intermediate surface so our children don't inherit our opacity
57097:      * via GetEffectiveOpacity.
57097:      */
57097:     mUseIntermediateSurface = GetEffectiveOpacity() != 1.0 && HasMultipleChildren();
57097:   }
55445: };
48143: 
71025: class BasicShadowImageLayer : public ShadowImageLayer, public BasicImplData {
48140: public:
48140:   BasicShadowImageLayer(BasicShadowLayerManager* aLayerManager) :
48140:     ShadowImageLayer(aLayerManager, static_cast<BasicImplData*>(this))
48140:   {
48140:     MOZ_COUNT_CTOR(BasicShadowImageLayer);
48140:   }
48140:   virtual ~BasicShadowImageLayer()
48140:   {
51001:     MOZ_COUNT_DTOR(BasicShadowImageLayer);
48142:   }
51001: 
54071:   virtual void Disconnect()
54071:   {
79425:     mFrontBuffer = SurfaceDescriptor();
54071:     ShadowImageLayer::Disconnect();
48140:   }
48140: 
79425:   virtual void Swap(const SharedImage& aNewFront,
79425:                     SharedImage* aNewBack);
48140: 
54071:   virtual void DestroyFrontBuffer()
54071:   {
79425:     if (mAllocator && IsSurfaceDescriptorValid(mFrontBuffer)) {
79425:       mAllocator->DestroySharedSurface(&mFrontBuffer);
54071:     }
54071:   }
54071: 
62698:   virtual void Paint(gfxContext* aContext);
48140: 
48142: protected:
48142:   BasicShadowLayerManager* BasicManager()
48142:   {
48142:     return static_cast<BasicShadowLayerManager*>(mManager);
48142:   }
48142: 
69106:   SurfaceDescriptor mFrontBuffer;
48142:   gfxIntSize mSize;
48140: };
48140: 
79425: void
79425: BasicShadowImageLayer::Swap(const SharedImage& aNewFront,
79425:                             SharedImage* aNewBack)
48142: {
79425:   nsRefPtr<gfxASurface> surface =
79425:     BasicManager()->OpenDescriptor(aNewFront);
79425:   // Destroy mFrontBuffer if size different
80708:   bool needDrop = false;
80708:   if (IsSurfaceDescriptorValid(mFrontBuffer)) {
80708:     nsRefPtr<gfxASurface> front = BasicManager()->OpenDescriptor(mFrontBuffer);
80708:     needDrop = surface->GetSize() != mSize ||
80708:                surface->GetContentType() != front->GetContentType();
80708:   }
80708:   if (needDrop) {
79425:     DestroyFrontBuffer();
79425:     mSize = surface->GetSize();
79425:   }
79425: 
79425:   // If mFrontBuffer
79425:   if (IsSurfaceDescriptorValid(mFrontBuffer)) {
69106:     *aNewBack = mFrontBuffer;
79425:   } else {
79425:     *aNewBack = null_t();
79425:   }
69764:   mFrontBuffer = aNewFront.get_SurfaceDescriptor();
48142: }
48142: 
48142: void
62698: BasicShadowImageLayer::Paint(gfxContext* aContext)
48142: {
69106:   if (!IsSurfaceDescriptorValid(mFrontBuffer)) {
54013:     return;
54013:   }
54013: 
69106:   nsRefPtr<gfxASurface> surface =
69106:     BasicManager()->OpenDescriptor(mFrontBuffer);
69106:   nsRefPtr<gfxPattern> pat = new gfxPattern(surface);
48142:   pat->SetFilter(mFilter);
62452: 
62452:   // The visible region can extend outside the image.  If we're not
62452:   // tiling, we don't want to draw into that area, so just draw within
62452:   // the image bounds.
62452:   const nsIntRect* tileSrcRect = GetTileSourceRect();
71025:   AutoSetOperator setOperator(aContext, GetOperator());
62452:   BasicImageLayer::PaintContext(pat,
62452:                                 tileSrcRect ? GetEffectiveVisibleRegion() : nsIntRegion(nsIntRect(0, 0, mSize.width, mSize.height)),
62452:                                 tileSrcRect,
62452:                                 GetEffectiveOpacity(), aContext);
48142: }
48142: 
55444: class BasicShadowColorLayer : public ShadowColorLayer,
71025:                               public BasicImplData
55444: {
55444: public:
55444:   BasicShadowColorLayer(BasicShadowLayerManager* aLayerManager) :
55444:     ShadowColorLayer(aLayerManager, static_cast<BasicImplData*>(this))
55444:   {
55444:     MOZ_COUNT_CTOR(BasicShadowColorLayer);
55444:   }
55444:   virtual ~BasicShadowColorLayer()
55444:   {
55444:     MOZ_COUNT_DTOR(BasicShadowColorLayer);
55444:   }
55444: 
62698:   virtual void Paint(gfxContext* aContext)
55444:   {
71025:     AutoSetOperator setOperator(aContext, GetOperator());
57097:     BasicColorLayer::PaintColorTo(mColor, GetEffectiveOpacity(), aContext);
55444:   }
55444: };
55444: 
48140: class BasicShadowCanvasLayer : public ShadowCanvasLayer,
71025:                                public BasicImplData
48140: {
48140: public:
48140:   BasicShadowCanvasLayer(BasicShadowLayerManager* aLayerManager) :
48140:     ShadowCanvasLayer(aLayerManager, static_cast<BasicImplData*>(this))
48140:   {
48140:     MOZ_COUNT_CTOR(BasicShadowCanvasLayer);
48140:   }
48140:   virtual ~BasicShadowCanvasLayer()
48140:   {
79426:     DestroyFrontBuffer();
51001:     MOZ_COUNT_DTOR(BasicShadowCanvasLayer);
48142:   }
51001: 
54071:   virtual void Disconnect()
54071:   {
79426:     mFrontSurface = SurfaceDescriptor();
54071:     ShadowCanvasLayer::Disconnect();
48140:   }
48140: 
48141:   virtual void Initialize(const Data& aData);
79426:   void Swap(const CanvasSurface& aNewFront, bool needYFlip, CanvasSurface* aNewBack);
48140: 
54071:   virtual void DestroyFrontBuffer()
54071:   {
69106:     if (IsSurfaceDescriptorValid(mFrontSurface)) {
79425:       mAllocator->DestroySharedSurface(&mFrontSurface);
54071:     }
54071:   }
54071: 
62698:   virtual void Paint(gfxContext* aContext);
48140: 
48141: private:
48141:   BasicShadowLayerManager* BasicManager()
48141:   {
48141:     return static_cast<BasicShadowLayerManager*>(mManager);
48141:   }
48141: 
69106:   SurfaceDescriptor mFrontSurface;
79445:   bool mNeedsYFlip;
48140: };
48140: 
54013: 
48141: void
48141: BasicShadowCanvasLayer::Initialize(const Data& aData)
48141: {
69106:   NS_RUNTIMEABORT("Incompatibe surface type");
48141: }
48141: 
69106: void
79426: BasicShadowCanvasLayer::Swap(const CanvasSurface& aNewFront, bool needYFlip,
79426:                              CanvasSurface* aNewBack)
48141: {
79426:   nsRefPtr<gfxASurface> surface =
79426:     BasicManager()->OpenDescriptor(aNewFront);
79426:   // Destroy mFrontBuffer if size different
79426:   gfxIntSize sz = surface->GetSize();
80708:   bool needDrop = false;
80708:   if (IsSurfaceDescriptorValid(mFrontSurface)) {
80708:     nsRefPtr<gfxASurface> front = BasicManager()->OpenDescriptor(mFrontSurface);
80708:     needDrop = sz != gfxIntSize(mBounds.width, mBounds.height) ||
80708:                surface->GetContentType() != front->GetContentType();
80708:   }
80708:   if (needDrop) {
79426:     DestroyFrontBuffer();
79426:     mBounds.SetRect(0, 0, sz.width, sz.height);
79426:   }
79426: 
71550:   mNeedsYFlip = needYFlip;
79426:   // If mFrontBuffer
79426:   if (IsSurfaceDescriptorValid(mFrontSurface)) {
69106:     *aNewBack = mFrontSurface;
79426:   } else {
79426:     *aNewBack = null_t();
79426:   }
79426:   mFrontSurface = aNewFront.get_SurfaceDescriptor();
48141: }
48141: 
48141: void
62698: BasicShadowCanvasLayer::Paint(gfxContext* aContext)
48141: {
48141:   NS_ASSERTION(BasicManager()->InDrawing(),
48141:                "Can only draw in drawing phase");
48141: 
69106:   if (!IsSurfaceDescriptorValid(mFrontSurface)) {
54013:     return;
54013:   }
54013: 
69106:   nsRefPtr<gfxASurface> surface =
69106:     BasicManager()->OpenDescriptor(mFrontSurface);
69106:   nsRefPtr<gfxPattern> pat = new gfxPattern(surface);
48141: 
48141:   pat->SetFilter(mFilter);
48141:   pat->SetExtend(gfxPattern::EXTEND_PAD);
48141: 
48141:   gfxRect r(0, 0, mBounds.width, mBounds.height);
71550: 
71550:   gfxMatrix m;
71550:   if (mNeedsYFlip) {
71550:     m = aContext->CurrentMatrix();
71550:     aContext->Translate(gfxPoint(0.0, mBounds.height));
71550:     aContext->Scale(1.0, -1.0);
71550:   }
71550: 
71550:   AutoSetOperator setOperator(aContext, GetOperator());
48141:   aContext->NewPath();
57097:   // No need to snap here; our transform has already taken care of it
57097:   aContext->Rectangle(r);
57097:   aContext->SetPattern(pat);
61311:   aContext->FillWithOpacity(GetEffectiveOpacity());
71550: 
71550:   if (mNeedsYFlip) {
71550:     aContext->SetMatrix(m);
71550:   }
48141: }
48141: 
48140: // Create a shadow layer (PLayerChild) for aLayer, if we're forwarding
48140: // our layer tree to a parent process.  Record the new layer creation
48140: // in the current open transaction as a side effect.
48140: template<typename CreatedMethod>
48140: static void
48140: MaybeCreateShadowFor(BasicShadowableLayer* aLayer,
48140:                      BasicShadowLayerManager* aMgr,
48140:                      CreatedMethod aMethod)
48140: {
48140:   if (!aMgr->HasShadowManager()) {
48140:     return;
48140:   }
48140: 
48140:   PLayerChild* shadow = aMgr->ConstructShadowFor(aLayer);
48140:   // XXX error handling
48140:   NS_ABORT_IF_FALSE(shadow, "failed to create shadow");
48140: 
48140:   aLayer->SetShadow(shadow);
48140:   (aMgr->*aMethod)(aLayer);
54126:   aMgr->Hold(aLayer->AsLayer());
48140: }
48140: #define MAYBE_CREATE_SHADOW(_type)                                      \
48140:   MaybeCreateShadowFor(layer, this,                                     \
48140:                        &ShadowLayerForwarder::Created ## _type ## Layer)
48140: 
48140: already_AddRefed<ThebesLayer>
48140: BasicShadowLayerManager::CreateThebesLayer()
48140: {
48140:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
48140:   nsRefPtr<BasicShadowableThebesLayer> layer =
48140:     new BasicShadowableThebesLayer(this);
48140:   MAYBE_CREATE_SHADOW(Thebes);
48140:   return layer.forget();
48140: }
48140: 
48140: already_AddRefed<ContainerLayer>
48140: BasicShadowLayerManager::CreateContainerLayer()
48140: {
48140:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
48140:   nsRefPtr<BasicShadowableContainerLayer> layer =
48140:     new BasicShadowableContainerLayer(this);
48140:   MAYBE_CREATE_SHADOW(Container);
48140:   return layer.forget();
48140: }
48140: 
48140: already_AddRefed<ImageLayer>
48140: BasicShadowLayerManager::CreateImageLayer()
48140: {
48140:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
48140:   nsRefPtr<BasicShadowableImageLayer> layer =
48140:     new BasicShadowableImageLayer(this);
48140:   MAYBE_CREATE_SHADOW(Image);
48140:   return layer.forget();
48140: }
48140: 
48140: already_AddRefed<ColorLayer>
48140: BasicShadowLayerManager::CreateColorLayer()
48140: {
48140:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
48140:   nsRefPtr<BasicShadowableColorLayer> layer =
48140:     new BasicShadowableColorLayer(this);
48140:   MAYBE_CREATE_SHADOW(Color);
48140:   return layer.forget();
48140: }
48140: 
48140: already_AddRefed<CanvasLayer>
48140: BasicShadowLayerManager::CreateCanvasLayer()
48140: {
48140:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
48140:   nsRefPtr<BasicShadowableCanvasLayer> layer =
48140:     new BasicShadowableCanvasLayer(this);
48140:   MAYBE_CREATE_SHADOW(Canvas);
48140:   return layer.forget();
48140: }
48140: already_AddRefed<ShadowThebesLayer>
48140: BasicShadowLayerManager::CreateShadowThebesLayer()
48140: {
48140:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
48140:   nsRefPtr<ShadowThebesLayer> layer = new BasicShadowThebesLayer(this);
48140:   return layer.forget();
48140: }
48140: 
55445: already_AddRefed<ShadowContainerLayer>
55445: BasicShadowLayerManager::CreateShadowContainerLayer()
55445: {
55445:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
55445:   nsRefPtr<ShadowContainerLayer> layer = new BasicShadowContainerLayer(this);
55445:   return layer.forget();
55445: }
55445: 
48140: already_AddRefed<ShadowImageLayer>
48140: BasicShadowLayerManager::CreateShadowImageLayer()
48140: {
48140:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
48140:   nsRefPtr<ShadowImageLayer> layer = new BasicShadowImageLayer(this);
48140:   return layer.forget();
48140: }
48140: 
55444: already_AddRefed<ShadowColorLayer>
55444: BasicShadowLayerManager::CreateShadowColorLayer()
55444: {
55444:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
55444:   nsRefPtr<ShadowColorLayer> layer = new BasicShadowColorLayer(this);
55444:   return layer.forget();
55444: }
55444: 
48140: already_AddRefed<ShadowCanvasLayer>
48140: BasicShadowLayerManager::CreateShadowCanvasLayer()
48140: {
48140:   NS_ASSERTION(InConstruction(), "Only allowed in construction phase");
48140:   nsRefPtr<ShadowCanvasLayer> layer = new BasicShadowCanvasLayer(this);
48140:   return layer.forget();
48140: }
48140: 
48140: BasicShadowLayerManager::BasicShadowLayerManager(nsIWidget* aWidget) :
48140:   BasicLayerManager(aWidget)
48140: {
48140:   MOZ_COUNT_CTOR(BasicShadowLayerManager);
48140: }
48140: 
48140: BasicShadowLayerManager::~BasicShadowLayerManager()
48140: {
48140:   MOZ_COUNT_DTOR(BasicShadowLayerManager);
48140: }
48140: 
48140: void
48140: BasicShadowLayerManager::SetRoot(Layer* aLayer)
48140: {
48140:   if (mRoot != aLayer) {
48140:     if (HasShadowManager()) {
58210:       // Have to hold the old root and its children in order to
58210:       // maintain the same view of the layer tree in this process as
58210:       // the parent sees.  Otherwise layers can be destroyed
58210:       // mid-transaction and bad things can happen (v. bug 612573)
58210:       if (mRoot) {
58210:         Hold(mRoot);
58210:       }
48140:       ShadowLayerForwarder::SetRoot(Hold(aLayer));
48140:     }
48140:     BasicLayerManager::SetRoot(aLayer);
48140:   }
48140: }
48140: 
48140: void
48140: BasicShadowLayerManager::Mutated(Layer* aLayer)
48140: {
61312:   BasicLayerManager::Mutated(aLayer);
61312: 
48140:   NS_ASSERTION(InConstruction() || InDrawing(), "wrong phase");
62698:   if (HasShadowManager() && ShouldShadow(aLayer)) {
48140:     ShadowLayerForwarder::Mutated(Hold(aLayer));
48140:   }
48140: }
48140: 
48140: void
48140: BasicShadowLayerManager::BeginTransactionWithTarget(gfxContext* aTarget)
48140: {
48140:   NS_ABORT_IF_FALSE(mKeepAlive.IsEmpty(), "uncommitted txn?");
59683:   // If the last transaction was incomplete (a failed DoEmptyTransaction),
59683:   // don't signal a new transaction to ShadowLayerForwarder. Carry on adding
59683:   // to the previous transaction.
60857:   if (HasShadowManager()) {
48140:     ShadowLayerForwarder::BeginTransaction();
48140:   }
48140:   BasicLayerManager::BeginTransactionWithTarget(aTarget);
48140: }
48140: 
59171: void
48140: BasicShadowLayerManager::EndTransaction(DrawThebesLayerCallback aCallback,
78887:                                         void* aCallbackData,
78887:                                         EndTransactionFlags aFlags)
48140: {
78887:   BasicLayerManager::EndTransaction(aCallback, aCallbackData, aFlags);
59683:   ForwardTransaction();
59683: }
59683: 
59683: bool
60857: BasicShadowLayerManager::EndEmptyTransaction()
59683: {
60857:   if (!BasicLayerManager::EndEmptyTransaction()) {
59683:     // Return without calling ForwardTransaction. This leaves the
59683:     // ShadowLayerForwarder transaction open; the following
60857:     // EndTransaction will complete it.
59683:     return false;
59683:   }
59683:   ForwardTransaction();
59683:   return true;
59683: }
59683: 
59683: void
59683: BasicShadowLayerManager::ForwardTransaction()
59683: {
48140: #ifdef DEBUG
48140:   mPhase = PHASE_FORWARD;
48140: #endif
48140: 
48140:   // forward this transaction's changeset to our ShadowLayerManager
57141:   AutoInfallibleTArray<EditReply, 10> replies;
48141:   if (HasShadowManager() && ShadowLayerForwarder::EndTransaction(&replies)) {
48141:     for (nsTArray<EditReply>::size_type i = 0; i < replies.Length(); ++i) {
48141:       const EditReply& reply = replies[i];
48141: 
48141:       switch (reply.type()) {
54109:       case EditReply::TOpThebesBufferSwap: {
54109:         MOZ_LAYERS_LOG(("[LayersForwarder] ThebesBufferSwap"));
54109: 
54109:         const OpThebesBufferSwap& obs = reply.get_OpThebesBufferSwap();
54109:         BasicShadowableThebesLayer* thebes = GetBasicShadowable(obs)->AsThebes();
54109:         thebes->SetBackBufferAndAttrs(
72234:           obs.newBackBuffer(), obs.newValidRegion(),
56899:           obs.readOnlyFrontBuffer(), obs.frontUpdatedRegion());
54109:         break;
54109:       }
48141:       case EditReply::TOpBufferSwap: {
48141:         MOZ_LAYERS_LOG(("[LayersForwarder] BufferSwap"));
48141: 
48141:         const OpBufferSwap& obs = reply.get_OpBufferSwap();
79426:         const CanvasSurface& newBack = obs.newBackBuffer();
79426:         if (newBack.type() == CanvasSurface::TSurfaceDescriptor) {
79426:           GetBasicShadowable(obs)->SetBackBuffer(newBack.get_SurfaceDescriptor());
79426:         } else if (newBack.type() == CanvasSurface::Tnull_t) {
79426:           GetBasicShadowable(obs)->SetBackBuffer(SurfaceDescriptor());
79426:         } else {
79426:           NS_RUNTIMEABORT("Unknown back image type");
79426:         }
48141:         break;
48141:       }
48141: 
69765:       case EditReply::TOpImageSwap: {
69765:         MOZ_LAYERS_LOG(("[LayersForwarder] YUVBufferSwap"));
69765: 
69765:         const OpImageSwap& ois = reply.get_OpImageSwap();
69765:         BasicShadowableLayer* layer = GetBasicShadowable(ois);
69765:         const SharedImage& newBack = ois.newBackImage();
69765: 
69765:         if (newBack.type() == SharedImage::TSurfaceDescriptor) {
69765:           layer->SetBackBuffer(newBack.get_SurfaceDescriptor());
79425:         } else if (newBack.type() == SharedImage::TYUVImage) {
69765:           const YUVImage& yuv = newBack.get_YUVImage();
69765:           nsRefPtr<gfxSharedImageSurface> YSurf = gfxSharedImageSurface::Open(yuv.Ydata());
69765:           nsRefPtr<gfxSharedImageSurface> USurf = gfxSharedImageSurface::Open(yuv.Udata());
69765:           nsRefPtr<gfxSharedImageSurface> VSurf = gfxSharedImageSurface::Open(yuv.Vdata());
69765:           layer->SetBackBufferYUVImage(YSurf, USurf, VSurf);
79425:         } else {
79425:           layer->SetBackBuffer(SurfaceDescriptor());
79425:           layer->SetBackBufferYUVImage(nsnull, nsnull, nsnull);
69765:         }
69765: 
69765:         break;
69765:       }
69765: 
48141:       default:
48141:         NS_RUNTIMEABORT("not reached");
48141:       }
48141:     }
48141:   } else if (HasShadowManager()) {
48140:     NS_WARNING("failed to forward Layers transaction");
48140:   }
48140: 
58210: #ifdef DEBUG
58210:   mPhase = PHASE_NONE;
58210: #endif
58210: 
48140:   // this may result in Layers being deleted, which results in
48141:   // PLayer::Send__delete__() and DeallocShmem()
48140:   mKeepAlive.Clear();
48140: }
48140: 
48140: ShadowableLayer*
48140: BasicShadowLayerManager::Hold(Layer* aLayer)
48140: {
48140:   NS_ABORT_IF_FALSE(HasShadowManager(),
48140:                     "top-level tree, no shadow tree to remote to");
48140: 
48140:   ShadowableLayer* shadowable = ToShadowable(aLayer);
48140:   NS_ABORT_IF_FALSE(shadowable, "trying to remote an unshadowable layer");
48140: 
48140:   mKeepAlive.AppendElement(aLayer);
48140:   return shadowable;
48140: }
61944: 
79445: bool
61944: BasicShadowLayerManager::IsCompositingCheap()
61944: {
61944:   // Whether compositing is cheap depends on the parent backend.
61944:   return mShadowManager &&
61944:          LayerManager::IsCompositingCheap(GetParentBackendType());
61944: }
48140: 
48140: }
48140: }
