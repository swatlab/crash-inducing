 84871: /* -*- Mode: IDL; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1:     
     1: #include "nsISupports.idl"
     1: 
     1: %{ C++
     1: #include "jsdebug.h"
     1: #include "nsAString.h"
     1: %}
     1:     
     1: [ptr] native JSDContext(JSDContext);
     1: [ptr] native JSDObject(JSDObject);
     1: [ptr] native JSDProperty(JSDProperty);
     1: [ptr] native JSDScript(JSDScript);
     1: [ptr] native JSDStackFrameInfo(JSDStackFrameInfo);
     1: [ptr] native JSDThreadState(JSDThreadState);
     1: [ptr] native JSDValue(JSDValue);
     1: [ptr] native JSRuntime(JSRuntime);
     1: [ptr] native JSContext(JSContext);
 62057: [ptr] native JSCompartment(JSCompartment);
     1: 
     1: /* interfaces we declare in this file */
     1: interface jsdIDebuggerService;
     1: interface jsdIFilter;
     1: interface jsdINestCallback;
     1: interface jsdIFilterEnumerator;
     1: interface jsdIContextEnumerator;
     1: interface jsdIScriptEnumerator;
     1: interface jsdIScriptHook;
     1: interface jsdIErrorHook;
     1: interface jsdIExecutionHook;
     1: interface jsdICallHook;
     1: interface jsdIEphemeral;
     1: interface jsdIContext;
     1: interface jsdIStackFrame;
     1: interface jsdIScript;
     1: interface jsdIValue;
     1: interface jsdIObject;
     1: interface jsdIProperty;
 56783: interface jsdIActivationCallback;
     1: 
     1: /**
 67895:  * Debugger service. It is not a good idea to have more than one active client
 67895:  * of the debugger service.
     1:  */
 84871: [scriptable, uuid(9be5b327-6818-464d-9695-f33885fd8377)]
     1: interface jsdIDebuggerService : nsISupports
     1: {
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDContext        JSDContext;
     1: 
     1:     /**
     1:      * Called when an error or warning occurs.
     1:      */
     1:     attribute jsdIErrorHook     errorHook;
     1:     /**
     1:      * Called when a jsdIScript is created or destroyed.
     1:      */
     1:     attribute jsdIScriptHook    scriptHook;
     1:     /**
     1:      * Called when the engine encounters a breakpoint.
     1:      */
     1:     attribute jsdIExecutionHook breakpointHook;
     1:     /**
     1:      * Called when the engine encounters the debugger keyword.
     1:      */
     1:     attribute jsdIExecutionHook debuggerHook;
     1:     /**
     1:      * Called when the errorHook returns false.
     1:      */
     1:     attribute jsdIExecutionHook debugHook;
     1:     /**
     1:      * Called before the next PC is executed.
     1:      */
     1:     attribute jsdIExecutionHook interruptHook;
     1:     /**
     1:      * Called when an exception is thrown (even if it will be caught.)
     1:      */
     1:     attribute jsdIExecutionHook throwHook;
     1:     /**
     1:      * Called before and after a toplevel script is evaluated.
     1:      */
     1:     attribute jsdICallHook      topLevelHook;
     1:     /**
     1:      * Called before and after a function is called.
     1:      */
     1:     attribute jsdICallHook      functionHook;
     1: 
     1: 
     1:     /**
     1:      * VERSION_* values must be kept in sync with the JSVersion enumeration in
     1:      * jspubtd.h.
     1:      */
     1: 
     1:     /**
     1:      * Possible values for jsdIScript::version and jsdIContext::version.
     1:      */
     1:     const long VERSION_1_0     = 100;
     1:     const long VERSION_1_1     = 110;
     1:     const long VERSION_1_2     = 120;
     1:     const long VERSION_1_3     = 130;
     1:     const long VERSION_1_4     = 140;
     1:     const long VERSION_1_5     = 150;
     1:     const long VERSION_DEFAULT = 0;
     1:     const long VERSION_UNKNOWN = -1;
     1: 
     1:     /**
     1:      * These flags need to be kept in sync with the context flags defined in
     1:      * jsdebug.h
     1:      */
     1: 
     1:     /**
     1:      * Link native frames in call stacks.
     1:      */
     1:     const unsigned long ENABLE_NATIVE_FRAMES     = 0x01;
     1:     /**
     1:      * Normally, if a script has a 0 in JSD_SCRIPT_PROFILE_BIT it is included in
     1:      * profile data, otherwise it is not profiled. Setting the
     1:      * PROFILE_WHEN_SET flag reverses this convention.
     1:      */
     1:     const unsigned long PROFILE_WHEN_SET         = 0x02;
     1:     /**
     1:      * Normally, when the script in the top frame of a thread state has a 1 in
     1:      * JSD_SCRIPT_DEBUG_BIT, the execution hook is ignored. Setting the
     1:      * DEBUG_WHEN_SET flag reverses this convention.
     1:      */
     1:     const unsigned long DEBUG_WHEN_SET           = 0x04;
     1:     /**
     1:      * When this flag is set the internal call hook will collect profile data.
     1:      */
     1:     const unsigned long COLLECT_PROFILE_DATA     = 0x08;
     1:     /**
     1:      * When this flag is set, stack frames that are disabled for debugging
     1:      * will not appear in the call stack chain.
     1:      */
     1:     const unsigned long HIDE_DISABLED_FRAMES     = 0x10;
     1:     /**
     1:      * When this flag is set, the debugger will only check the
     1:      * JSD_SCRIPT_DEBUG_BIT on the top (most recent) stack frame. This
     1:      * makes it possible to stop in an enabled frame which was called from
     1:      * a stack that contains a disabled frame.
     1:      *
     1:      * When this flag is *not* set, any stack that contains a disabled frame
     1:      * will not be debugged (the execution hook will not be invoked.)
     1:      *
     1:      * This only applies when the reason for calling the hook would have
     1:      * been TYPE_INTERRUPTED or TYPE_THROW. TYPE_BREAKPOINT,
     1:      * TYPE_DEBUG_REQUESTED, and TYPE_DEBUGGER_KEYWORD always stop, regardless
     1:      * of this setting, as long as the top frame is not disabled.
     1:      *
     1:      * If HIDE_DISABLED_FRAMES is set, this is effectively set as well.
     1:      */
     1:     const unsigned long MASK_TOP_FRAME_ONLY     = 0x20;
     1:     /**
 48556:      * This flag has been retired, do not re-use. It previously provided a hook
 48556:      * for object allocation.
     1:      */
 48556:     const unsigned long DISABLE_OBJECT_TRACE_RETIRED = 0x40;
     1: 
     1:     /**
     1:      * Debugger service flags.
     1:      */
     1:     attribute unsigned long flags;
     1:     
     1:     /**
     1:      * Major version number of implementation.
     1:      */
     1:     readonly attribute unsigned long implementationMajor;
     1:     /**
     1:      * Minor version number of implementation.
     1:      */
     1:     readonly attribute unsigned long implementationMinor;
     1:     /**
 23431:      * Free form AUTF8String identifier for implementation.
     1:      */
 23431:     readonly attribute AUTF8String implementationString;
     1:     
     1:     /**
     1:      * |true| if the debugger service has been turned on. This does not
     1:      * necessarily mean another app is actively using the service, as the 
     1:      * autostart pref may have turned the service on.
     1:      */
     1:     readonly attribute boolean isOn;
     1: 
 56783: 
 56783:     /**
 56783:      * Synchronous activation of the debugger is no longer supported,
 56783:      * and will throw an exception.
 56783:      */
 56783:     void on();
 56783: 
     1:     /**
 67895:      * Turn on the debugger. This function should only be called from
 67895:      * JavaScript code. The debugger will be enabled on the runtime the call is
 67895:      * made on, as determined by nsIXPCNativeCallContext.
 56783:      *
 67895:      * The debugger will be activated asynchronously, because there can be no
 67895:      * JS on the stack when code is to be re-compiled for debug mode.
 56776:      */
 56783:     void asyncOn(in jsdIActivationCallback callback);
 56783:     
 56776:     /**
 56783:      * Called by nsIXPConnect after it's had a chance to recompile for
 56783:      * debug mode.
     1:      */
 56783:     [noscript] void activateDebugger(in JSRuntime rt);
 56783: 
 56783:     /**
 62057:      * Called by nsIXPConnect to deactivate debugger on setup failure.
 62057:      */
 62057:     [noscript] void deactivateDebugger();
 62057: 
 62057:     /**
 56783:      * Recompile all active scripts in the runtime for debugMode.
 56783:      */
 74991:     [noscript] void recompileForDebugMode(in JSContext cx, in JSCompartment comp, in boolean mode);
 56783: 
     1:     /**
     1:      * Turn the debugger off. This will invalidate all of your jsdIEphemeral
 67895:      * derived objects, and clear all of your breakpoints.
     1:      */
     1:     void off ();
     1: 
     1:     /**
     1:      * Peek at the current pause depth of the debugger.
     1:      *
     1:      * @return depth Number of pause() calls still waiting to be unPause()d.
     1:      */
     1:     readonly attribute unsigned long pauseDepth;
     1:     /**
     1:      * Temporarily disable the debugger. Hooks will not be called while the
     1:      * debugger is paused. Multiple calls to pause will increase the "pause
     1:      * depth", and equal number of unPause calles must be made to resume
     1:      * normal debugging.
     1:      *
     1:      * @return depth Number of times pause has been called since the debugger
     1:      *               has been unpaused.
     1:      */
     1:     unsigned long pause();
     1:     /**
 82093:      * Undo a pause.  Once this is called, the debugger won't start
 82093:      * getting execution callbacks until the stack is fully unwound so
 82093:      * that no JS scripts are live.  There is no way to query whether
 82093:      * there are such scripts left to unwind at a given point in time.
     1:      *
     1:      * @return depth The number of remaining pending pause calls.
     1:      */
     1:     unsigned long unPause();
     1:     
     1:     /**
     1:      * Force the engine to perform garbage collection.
     1:      */
     1:     void GC();
     1:     
     1:     /**
     1:      * Clear profile data for all scripts.
     1:      */
     1:     void clearProfileData();
     1:     
     1:     /**
     1:      * Adds an execution hook filter. These filters are consulted each time one
     1:      * of the jsdIExecutionHooks is about to be called. Filters are matched in
     1:      * a first in, first compared fashion. The first filter to match determines
     1:      * whether or not the hook is called. Use swapFilter to reorder existing
     1:      * filters, and removeFilter to remove them.
     1:      *
     1:      * If |filter| is already present this method throws NS_ERROR_INVALID_ARG.
     1:      *
     1:      * @param filter Object representing the filter to add.
     1:      * @param after  Insert |filter| after this one. Pass null to insert at
     1:      *               the beginning.
     1:      */
     1:     void insertFilter(in jsdIFilter filter, in jsdIFilter after);
     1:     /**
     1:      * Same as insertFilter, except always add to the end of the list.
     1:      */
     1:     void appendFilter(in jsdIFilter filter);
     1:     /**
     1:      * Remove a filter.
     1:      *
     1:      * If |filter| is not present this method throws NS_ERROR_INVALID_ARG.
     1:      *
     1:      * @param filter Object representing the filter to remove. Must be the exact
     1:      * object passed to addFilter, not just a new object with the same
     1:      * properties.
     1:      */
     1:     void removeFilter(in jsdIFilter filter);
     1:     /**
     1:      * Swap position of two filters.
     1:      * 
     1:      * If |filter_a| is not present, this method throws NS_ERROR_INVALID_ARG.
     1:      * If |filter_b| is not present, filter_a is replaced by filter_b.
     1:      * If |filter_a| == |filter_b|, then filter is refreshed.
     1:      */
     1:     void swapFilters(in jsdIFilter filter_a, in jsdIFilter filter_b);
     1:     /**
     1:      * Enumerate registered filters. This routine refreshes each filter before
     1:      * passing them on to the enumeration function. Calling this with a null
     1:      * |enumerator| is equivalent to jsdIService::refreshFilters.
     1:      *
     1:      * @param enumerator jsdIFilterEnumerator instance to be called back for the
     1:      *                   enumeration.
     1:      */
     1:     void enumerateFilters(in jsdIFilterEnumerator enumerator);
     1:     /**
     1:      * Force the debugger to resync its internal filter cache with the
     1:      * actual values in the jsdIFilter objects. To refresh a single filter
     1:      * use jsdIService::swapFilters. This method is equivalent to
     1:      * jsdIService::enumerateFilters with a null enumerator.
     1:      */
     1:     void refreshFilters();
     1:     /**
     1:      * Clear the list of filters.
     1:      */
     1:     void clearFilters();
     1: 
     1:     /**
     1:      * Enumerate all known contexts.
     1:      */
     1:     void enumerateContexts(in jsdIContextEnumerator enumerator);
     1:     
     1:     /**
     1:      * Enumerate all scripts the debugger knows about. Any scripts created
     1:      * before you turned the debugger on, or after turning the debugger off
     1:      * will not be available unless the autostart perf is set.
     1:      *
     1:      * @param enumerator jsdIScriptEnumerator instance to be called back for
     1:      *                   the enumeration.
     1:      */
     1:     void enumerateScripts(in jsdIScriptEnumerator enumerator);
     1:     /**
     1:      * Clear all breakpoints in all scripts.
     1:      */
     1:     void clearAllBreakpoints();
     1: 
     1:     /**
     1:      * When called from JavaScript, this method returns the jsdIValue wrapper
     1:      * for the given value. If a wrapper does not exist one will be created.
     1:      * When called from another language this method returns an xpconnect
     1:      * defined error code.
     1:      */
 84871:     jsdIValue wrapValue(in jsval value);
 33989: 
     1:     /* XXX these two routines are candidates for refactoring. The only problem
     1:      * is that it is not clear where and how they should land.
     1:      */
     1: 
     1:     /**
     1:      * Push a new network queue, and enter a new UI event loop.
     1:      * @param callback jsdINestCallback instance to be called back after the
     1:      *                 network queue has been pushed, but before the
     1:      *                 UI loop starts.
     1:      * @return depth returns the current number of times the event loop has been
     1:      *               nested. your code can use it for sanity checks.
     1:      */
     1:     unsigned long enterNestedEventLoop(in jsdINestCallback callback);
     1:     /**
     1:      * Exit the current nested event loop after the current iteration completes,
     1:      * and pop the network event queue.
     1:      *
     1:      * @return depth returns the current number of times the event loop has been
     1:      *               nested. your code can use it for sanity checks.
     1:      */
     1:     unsigned long exitNestedEventLoop();
 24694: 
 24694:     /**
 24694:      * Output dump of JS heap.
 24694:      *
 24694:      * @param fileName Filename to dump the heap into.
 24694:      */
 24694:     void dumpHeap(in AUTF8String fileName);
     1: };
     1: 
     1: /* callback interfaces */
     1: 
     1: /**
     1:  * Object representing a pattern of global object and/or url the debugger should
     1:  * ignore. The debugger service itself will not modify properties of these
     1:  * objects.
     1:  */
 23431: [scriptable, uuid(0c9189d9-4287-47a4-bca6-6ed65aaf737f)]
     1: interface jsdIFilter : nsISupports
     1: {
     1:     /**
     1:      * These two bytes of the flags attribute are reserved for interpretation
     1:      * by the jsdService implementation. You can do what you like with the
     1:      * remaining flags.
     1:      */
     1:     const unsigned long FLAG_RESERVED_MASK = 0xFF;
     1:     /**
     1:      * Filters without this flag set are ignored.
     1:      */
     1:     const unsigned long FLAG_ENABLED       = 0x01;
     1:     /**
     1:      * Filters with this flag set are "pass" filters, they allow matching hooks
     1:      * to continue. Filters without this flag block matching hooks.
     1:      */
     1:     const unsigned long FLAG_PASS          = 0x02;
     1: 
     1:     /**
     1:      * FLAG_* values from above, OR'd together.
     1:      */
     1:     attribute unsigned long flags;
     1:     
     1:     /**
     1:      * An nsISupports version of the global object to be filtered. A null glob
     1:      * matches all hooks. This attribute must be QI'able to the
     1:      * (non-scriptable) nsIScriptGlobalObject interface.
     1:      *
     1:      * The jsdIService caches this value internally, so if it changes you must
     1:      * swap the filter with itself using jsdIService::swapFilters.
     1:      */
     1:     attribute nsISupports globalObject;
     1:     
     1:     /**
     1:      * String representing the url pattern to be filtered. Supports limited
     1:      * glob matching, at the beginning and end of the pattern only. For example,
     1:      * "chrome://venkman*" filters all urls that start with chrome/venkman,
     1:      * "*.cgi" filters all cgi's, and "http://myserver/utils.js" filters only
     1:      * the utils.js file on "myserver". A null urlPattern matches all urls.
     1:      *
     1:      * The jsdIService caches this value internally, to if it changes you must
     1:      * swap the filter with itself using jsdIService::swapFilters.
     1:      */
 23431:     attribute AUTF8String urlPattern;
     1: 
     1:     /**
     1:      * Line number for the start of this filter. Line numbers are one based.
     1:      * Assigning a 0 to this attribute will tell the debugger to ignore the
     1:      * entire file.
     1:      */
     1:     attribute unsigned long startLine;
     1: 
     1:     /**
     1:      * Line number for the end of this filter. Line numbers are one based.
     1:      * Assigning a 0 to this attribute will tell the debugger to ignore from
     1:      * |startLine| to the end of the file.
     1:      */
     1:     attribute unsigned long endLine;
     1: };
     1: 
     1: /**
 56783:  * Notify client code that debugMode has been activated.
 56783:  */
 62511: [scriptable, function, uuid(6da7f5fb-3a84-4abe-9e23-8b2045960732)]
 56783: interface jsdIActivationCallback : nsISupports
 56783: {
 56783:     void onDebuggerActivated();
 56783: };
 56783: 
 56783: /**
     1:  * Pass an instance of one of these to jsdIDebuggerService::enterNestedEventLoop.
     1:  */
 62511: [scriptable, function, uuid(88bea60f-9b5d-4b39-b08b-1c3a278782c6)]
     1: interface jsdINestCallback : nsISupports
     1: {
     1:     /**
     1:      * This method will be called after pre-nesting work has completed, such
     1:      * as pushing the js context and network event queue, but before the new
     1:      * event loop starts.
     1:      */
     1:     void onNest();
     1: };
     1: 
     1: /**
     1:  * Pass an instance of one of these to jsdIDebuggerService::enumerateFilters.
     1:  */
 62511: [scriptable, function, uuid(e391ba85-9379-4762-b387-558e38db730f)]
     1: interface jsdIFilterEnumerator : nsISupports
     1: {
     1:     /**
     1:      * The enumerateFilter method will be called once for every filter the
     1:      * debugger knows about.
     1:      */
     1:     void enumerateFilter(in jsdIFilter filter);
     1: };
     1: 
     1: /**
     1:  * Pass an instance of one of these to jsdIDebuggerService::enumerateScripts.
     1:  */
 62511: [scriptable, function, uuid(4eef60c2-9bbc-48fa-b196-646a832c6c81)]
     1: interface jsdIScriptEnumerator : nsISupports
     1: {
     1:     /**
     1:      * The enumerateScript method will be called once for every script the
     1:      * debugger knows about.
     1:      */
     1:     void enumerateScript(in jsdIScript script);
     1: };
     1: 
     1: /**
     1:  * Pass an instance of one of these to jsdIDebuggerService::enumerateContexts.
     1:  */
 62511: [scriptable, function, uuid(57d18286-550c-4ca9-ac33-56f12ebba91e)]
     1: interface jsdIContextEnumerator : nsISupports
     1: {
     1:     /**
     1:      * The enumerateContext method will be called once for every context
     1:      * currently in use.
     1:      */
     1:     void enumerateContext(in jsdIContext executionContext);
     1: };
     1: 
     1: /**
     1:  * Set jsdIDebuggerService::scriptHook to an instance of one of these.
     1:  */
 71318: [scriptable, uuid(d030d1a2-a58a-4f19-b9e3-96da4e2cdd09)]
     1: interface jsdIScriptHook : nsISupports
     1: {
     1:     /**
     1:      * Called when scripts are created.
     1:      */
     1:     void onScriptCreated(in jsdIScript script);
     1:     /**
     1:      * Called when the JavaScript engine destroys a script. The jsdIScript
     1:      * object passed in will already be invalidated.
     1:      */
     1:     void onScriptDestroyed(in jsdIScript script);
     1: };
     1: 
     1: /**
     1:  * Hook instances of this interface up to the
     1:  * jsdIDebuggerService::functionHook and toplevelHook properties.
     1:  */
 62511: [scriptable, function, uuid(3eff1314-7ae3-4cf8-833b-c33c24a55633)]
     1: interface jsdICallHook : nsISupports
     1: {
     1:     /**
     1:      * TYPE_* values must be kept in sync with the JSD_HOOK_* #defines
     1:      * in jsdebug.h.
     1:      */
     1: 
     1:     /**
     1:      * Toplevel script is starting.
     1:      */
     1:     const unsigned long TYPE_TOPLEVEL_START  = 0;
     1:     /**
     1:      * Toplevel script has completed.
     1:      */
     1:     const unsigned long TYPE_TOPLEVEL_END    = 1;
     1:     /**
     1:      * Function is being called.
     1:      */
     1:     const unsigned long TYPE_FUNCTION_CALL   = 2;
     1:     /**
     1:      * Function is returning.
     1:      */
     1:     const unsigned long TYPE_FUNCTION_RETURN = 3;
     1:     
     1:     /**
     1:      * Called before the JavaScript engine executes a top level script or calls
     1:      * a function.
     1:      */
     1:     void onCall(in jsdIStackFrame frame, in unsigned long type);
     1: };
     1: 
 62511: [scriptable, function, uuid(e6b45eee-d974-4d85-9d9e-f5a67218deb4)]
     1: interface jsdIErrorHook : nsISupports
     1: {
     1:     /**
     1:      * REPORT_* values must be kept in sync with JSREPORT_* #defines in
     1:      * jsapi.h
     1:      */
     1:     
     1:     /**
     1:      * Report is an error.
     1:      */
     1:     const unsigned long REPORT_ERROR     = 0x00;
     1:     /**
     1:      * Report is only a warning.
     1:      */
     1:     const unsigned long REPORT_WARNING   = 0x01;
     1:     /**
     1:      * Report represents an uncaught exception.
     1:      */
     1:     const unsigned long REPORT_EXCEPTION = 0x02;
     1:     /**
     1:      * Report is due to strict mode.
     1:      */
     1:     const unsigned long REPORT_STRICT    = 0x04;
     1: 
     1:     /**
     1:      * Called when the JavaScript engine encounters an error. Return |true|
     1:      * to pass the error along, |false| to invoke the debugHook.
     1:      */
 23431:     boolean onError(in AUTF8String message, in AUTF8String fileName,
     1:                     in unsigned long line, in unsigned long pos,
     1:                     in unsigned long flags, in unsigned long errnum,
     1:                     in jsdIValue exc);
     1: };
     1: 
     1: /**
     1:  * Hook instances of this interface up to the
     1:  * jsdIDebuggerService::breakpointHook, debuggerHook, errorHook, interruptHook,
     1:  * and throwHook properties.
     1:  */
 62511: [scriptable, function, uuid(3a722496-9d78-4f0a-a797-293d9e8cb8d2)]
     1: interface jsdIExecutionHook : nsISupports
     1: {
     1:     /**
     1:      * TYPE_* values must be kept in sync with JSD_HOOK_* #defines in jsdebug.h.
     1:      */
     1: 
     1:     /**
     1:      * Execution stopped because we're in single step mode.
     1:      */
     1:     const unsigned long TYPE_INTERRUPTED      = 0;
     1:     /**
     1:      * Execution stopped by a trap instruction (i.e. breakoint.)
     1:      */
     1:     const unsigned long TYPE_BREAKPOINT       = 1;
     1:     /**
     1:      * Error handler returned an "invoke debugger" value.
     1:      */
     1:     const unsigned long TYPE_DEBUG_REQUESTED  = 2;
     1:     /**
     1:      * Debugger keyword encountered.
     1:      */
     1:     const unsigned long TYPE_DEBUGGER_KEYWORD = 3;
     1:     /**
     1:      * Exception was thrown.
     1:      */
     1:     const unsigned long TYPE_THROW            = 4;
     1: 
     1:     /**
     1:      * RETURN_* values must be kept in sync with JSD_HOOK_RETURN_* #defines in
     1:      * jsdebug.h.
     1:      */
     1: 
     1:     /**
     1:      * Indicates unrecoverable error processing the hook. This will cause
     1:      * the script being executed to be aborted without raising a JavaScript
     1:      * exception.
     1:      */
     1:     const unsigned long RETURN_HOOK_ERROR     = 0;
     1:     /**
     1:      * Continue processing normally. This is the "do nothing special" return
     1:      * value for all hook types *except* TYPE_THROW. Returning RETURN_CONTINUE
     1:      * from TYPE_THROW cause the exception to be ignored. Return
     1:      * RETURN_CONTINUE_THROW to continue exception processing from TYPE_THROW
     1:      * hooks.
     1:      */
     1:     const unsigned long RETURN_CONTINUE       = 1;
     1:     /**
     1:      * Same effect as RETURN_HOOK_ERROR.
     1:      */
     1:     const unsigned long RETURN_ABORT          = 2;
     1:     /**
     1:      * Return the value of the |val| parameter.
     1:      */
     1:     const unsigned long RETURN_RET_WITH_VAL   = 3;
     1:     /**
     1:      * Throw the value of the |val| parameter.
     1:      */
     1:     const unsigned long RETURN_THROW_WITH_VAL = 4;
     1:     /**
     1:      * Continue the current throw.
     1:      */
     1:     const unsigned long RETURN_CONTINUE_THROW = 5;
     1: 
     1:     /**
     1:      * @param frame A jsdIStackFrame object representing the bottom stack frame.
     1:      * @param type  One of the jsdIExecutionHook::TYPE_ constants.
     1:      * @param val   in  - Current exception (if any) when this method is called.
     1:      *              out - If you return RETURN_THROW_WITH_VAL, value to be
     1:      *                    thrown.
     1:      *                    If you return RETURN_RET_WITH_VAL, value to return.
     1:      *                    All other return values, not significant.
     1:      * @retval      One of the jsdIExecutionHook::RETURN_* constants.
     1:      */
     1:     unsigned long onExecute(in jsdIStackFrame frame, 
     1:                             in unsigned long type, inout jsdIValue val);
     1: };
     1: 
     1: /**
     1:  * Objects which inherit this interface may go away, with (jsdIScript) or
     1:  * without (all others) notification. These objects are generally wrappers
     1:  * around JSD structures that go away when you call jsdService::Off().
     1:  */
     1: [scriptable, uuid(46f1e23e-1dd2-11b2-9ceb-8285f2e95e69)]
     1: interface jsdIEphemeral : nsISupports
     1: {
     1:     /**
     1:      * |true| if this object is still valid. If not, many or all of the methods
     1:      * and/or properties of the inheritor may no longer be callable.
     1:      */
     1:     readonly attribute boolean isValid;
     1:     /**
     1:      * Mark this instance as invalid.
     1:      */
     1:     [noscript] void invalidate(); 
     1: };    
     1: 
     1: /* handle objects */
     1: 
     1: /**
     1:  * Context object. Only context's which are also nsISupports objects can be
     1:  * reflected by this interface.
     1:  */
 23431: [scriptable, uuid(3e5c934d-6863-4d81-96f5-76a3b962fc2b)]
     1: interface jsdIContext : jsdIEphemeral
     1: {
     1:     /* Internal use only. */
     1:     [noscript] readonly attribute JSContext   JSContext;
     1: 
     1:     /**
     1:      * OPT_* values must be kept in sync with JSOPTION_* #defines in jsapi.h.
     1:      */
     1: 
     1:     /**
     1:      * Strict mode is on.
     1:      */
     1:     const long OPT_STRICT      = 0x01;
     1:     /**
     1:      * Warnings reported as errors.
     1:      */
     1:     const long OPT_WERR        = 0x02;
     1:     /**
     1:      * Makes eval() use the last object on its 'obj' param's scope chain as the
     1:      * ECMA 'variables object'.
     1:      */
     1:     const long OPT_VAROBJFIX   = 0x04;
     1:     /**
     1:      * Private data for this object is an nsISupports object. Attempting to
     1:      * alter this bit will result in an NS_ERROR_ILLEGAL_VALUE.
     1:      */
     1:     const long OPT_ISUPPORTS   = 0x08;
     1:     /**
     1:      * OPT_* values above, OR'd together.
     1:      */
     1:     attribute unsigned long          options;
     1: 
     1:     /**
     1:      * Last version set on this context.
     1:      * Scripts typically select this with the "language" attribute.
     1:      * See the VERSION_* consts on jsdIDebuggerService.
     1:      */
     1:     attribute long                   version;
     1: 
     1:     /**
     1:      * Unique tag among all valid jsdIContext objects, useful as a hash key.
     1:      */
     1:     readonly attribute unsigned long tag;
     1: 
     1:     /**
     1:      * Private data for this context, if it is an nsISupports, |null| otherwise.
     1:      */
     1:     readonly attribute nsISupports   privateData;
     1:     
     1:     /**
     1:      * Retrieve the underlying context wrapped by this jsdIContext.
     1:      */
     1:     readonly attribute nsISupports   wrappedContext;
     1: 
     1:     /**
     1:      * Top of the scope chain for this context.
     1:      */
     1:     readonly attribute jsdIValue     globalObject;
     1: 
     1:     /**
     1:      * |true| if this context should be allowed to run scripts, |false|
     1:      * otherwise. This attribute is only valid for contexts which implement
     1:      * nsIScriptContext. Setting or getting this attribute on any other
     1:      * context will throw a NS_ERROR_NO_INTERFACE exception.
     1:      */
     1:     attribute boolean                scriptsEnabled;
     1: };
     1: 
     1: /**
     1:  * Stack frame objects. These are only valid inside the jsdIExecutionHook which
     1:  * gave it to you. After you return from that handler the bottom frame, and any
     1:  * frame you found attached through it, are invalidated via the jsdIEphemeral
     1:  * interface. Once a jsdIStackFrame has been invalidated all method and
     1:  * property accesses will throw a NS_ERROR_NOT_AVAILABLE exception.
     1:  */
 71318: [scriptable, uuid(7c95422c-7579-4a6f-8ef7-e5b391552ee5)]
     1: interface jsdIStackFrame : jsdIEphemeral
     1: {
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDContext        JSDContext;
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDThreadState    JSDThreadState;
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDStackFrameInfo JSDStackFrameInfo;
     1:    
     1:     /**
     1:      * True if stack frame represents a frame created as a result of a debugger
     1:      * evaluation.
     1:      */
     1:     readonly attribute boolean isDebugger;
     1:     /**
     1:      * True if stack frame is constructing a new object.
     1:      */
     1:     readonly attribute boolean isConstructing;
     1: 
     1:     /**
     1:      * Link to the caller's stack frame.
     1:      */
     1:     readonly attribute jsdIStackFrame callingFrame;
     1:     /**
     1:      * Executon context.
     1:      */
     1:     readonly attribute jsdIContext    executionContext;
     1:     /**
     1:      * Function name executing in this stack frame.
     1:      */
 23431:     readonly attribute AUTF8String    functionName;
     1:     /**
     1:      * Script running in this stack frame, null for native frames.
     1:      */
     1:     readonly attribute jsdIScript     script;
     1:     /**
     1:      * Current program counter in this stack frame.
     1:      */
     1:     readonly attribute unsigned long  pc;
     1:     /**
     1:      * Current line number (using the script's pc to line map.)
     1:      */
     1:     readonly attribute unsigned long  line;
     1:     /**
     1:      * Function object running in this stack frame.
     1:      */
     1:     readonly attribute jsdIValue      callee;
     1:     /**
     1:      * Top object in the scope chain.
     1:      */
     1:     readonly attribute jsdIValue      scope;
     1:     /**
     1:      * |this| object for this stack frame.
     1:      */
     1:     readonly attribute jsdIValue      thisValue;
     1:     /**
     1:      * Evaluate arbitrary JavaScript in this stack frame.
     1:      * @param bytes    Script to be evaluated.
     1:      * @param fileName Filename to compile this script under. This is the
     1:      *                 filename you'll see in error messages, etc.
     1:      * @param line     Starting line number for this script. One based.
     1:      * @retval         Result of evaluating the script.
     1:      */
 23431:     boolean eval(in AString bytes, in AUTF8String fileName,
     1:                  in unsigned long line, out jsdIValue result);
     1:     
     1: };
     1: 
     1: /**
     1:  * Script object. In JavaScript engine terms, there's a single script for each
     1:  * function, and one for the top level script.
     1:  */
108663: [scriptable, uuid(8ce9b2a2-cc33-48a8-9f47-8696186ed9a5)]
     1: interface jsdIScript : jsdIEphemeral
     1: {
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDContext JSDContext;
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDScript  JSDScript;
     1:     
     1:     /**
     1:      * Last version set on this context.
     1:      * Scripts typically select this with the "language" attribute.
     1:      * See the VERSION_* consts on jsdIDebuggerService.
     1:      */
     1:     readonly attribute long          version;
     1: 
     1:     /**
     1:      * Tag value guaranteed unique among jsdIScript objects. Useful as a
     1:      * hash key in script.
     1:      */
     1:     readonly attribute unsigned long tag;
     1: 
     1:     /**
     1:      * FLAG_* values need to be kept in sync with JSD_SCRIPT_* #defines in
     1:      * jsdebug.h.
     1:      */
     1: 
     1:     /**
     1:      * Determines whether or not to collect profile information for this
     1:      * script. The context flag FLAG_PROFILE_WHEN_SET decides the logic.
     1:      */
     1:     const unsigned long FLAG_PROFILE = 0x01;
     1:     /**
     1:      * Determines whether or not to ignore breakpoints, etc. in this script.
     1:      * The context flag JSD_DEBUG_WHEN_SET decides the logic.
     1:      */
     1:     const unsigned long FLAG_DEBUG   = 0x02;
108663:     /**
108663:      * Determines whether to invoke the onScriptDestroy callback for this
108663:      * script. The default is for this to be true if the onScriptCreated
108663:      * callback was invoked for this script.
108663:      */
108663:     const unsigned long FLAG_CALL_DESTROY_HOOK = 0x04;
     1:     
     1:     /**
     1:      * FLAG_* attributes from above, OR'd together.
     1:      */
     1:     attribute unsigned long flags;
     1: 
     1:     /**
     1:      * Filename given for this script when it was compiled.
     1:      * This data is copied from the underlying structure when the jsdIScript
     1:      * instance is created and is therefore available even after the script is
     1:      * invalidated.
     1:      */
 23431:     readonly attribute AUTF8String   fileName;
     1:     /**
     1:      * Function name for this script. "anonymous" for unnamed functions (or
     1:      * a function actually named anonymous), empty for top level scripts.
     1:      * This data is copied from the underlying structure when the jsdIScript
     1:      * instance is created and is therefore available even after the script is
     1:      * invalidated.
     1:      */
 23431:     readonly attribute AUTF8String   functionName;
     1:     /**
 34186:      * The names of the arguments for this function; empty if this is
 34186:      * not a function.
 34186:      */
 34186:     void getParameterNames([optional] out unsigned long count,
 34186:                            [array, size_is(count), retval] out wstring paramNames);
 34186:     /**
     1:      * Fetch the function object as a jsdIValue.
     1:      */
     1:     readonly attribute jsdIValue     functionObject;
     1:     /**
     1:      * Source code for this script, without function declaration.
     1:      */
     1:     readonly attribute AString functionSource;
     1:     /**
     1:      * Line number in source file containing the first line of this script.
     1:      * This data is copied from the underlying structure when the jsdIScript
     1:      * instance is created and is therefore available even after the script is
     1:      * invalidated.
     1:      */
     1:     readonly attribute unsigned long baseLineNumber;
     1:     /**
     1:      * Total number of lines in this script.
     1:      * This data is copied from the underlying structure when the jsdIScript
     1:      * instance is created and is therefore available even after the script is
     1:      * invalidated.
     1:      */
     1:     readonly attribute unsigned long lineExtent;
     1: 
     1:     /**
     1:      * Number of times this script has been called.
     1:      */
     1:     readonly attribute unsigned long callCount;
     1:     /**
     1:      * Number of times this script called itself, directly or indirectly.
     1:      */
     1:     readonly attribute unsigned long maxRecurseDepth;
     1:     /**
     1:      * Shortest execution time recorded, in milliseconds.
     1:      */
     1:     readonly attribute double minExecutionTime;
     1:     /**
     1:      * Longest execution time recorded, in milliseconds.
     1:      */
     1:     readonly attribute double maxExecutionTime;
     1:     /**
     1:      * Total time spent in this function, in milliseconds.
     1:      */
     1:     readonly attribute double totalExecutionTime;
     1:     /**
     1:      * Shortest execution time recorded, in milliseconds, excluding time spent
     1:      * in other called code.
     1:      */
     1:     readonly attribute double minOwnExecutionTime;
     1:     /**
     1:      * Longest execution time recorded, in milliseconds, excluding time spent
     1:      * in other called code.
     1:      */
     1:     readonly attribute double maxOwnExecutionTime;
     1:     /**
     1:      * Total time spent in this function, in milliseconds, excluding time spent
     1:      * in other called code.
     1:      */
     1:     readonly attribute double totalOwnExecutionTime;
     1:     
     1:     /**
     1:      * Clear profile data for this script.
     1:      */
     1:     void clearProfileData();
     1:     
     1:     const unsigned long PCMAP_SOURCETEXT  = 1; /* map to actual source text    */
     1:     const unsigned long PCMAP_PRETTYPRINT = 2; /* map to pretty printed source */
     1: 
     1:     /**
     1:      * Get the closest line number to a given PC.
     1:      * The |pcmap| argument specifies which pc to source line map to use.
     1:      */
     1:     unsigned long pcToLine(in unsigned long pc, in unsigned long pcmap);
     1:     /**
     1:      * Get the first PC associated with a line.
     1:      * The |pcmap| argument specifies which pc to source line map to use.
     1:      */
     1:     unsigned long lineToPc(in unsigned long line, in unsigned long pcmap);
     1:     /**
     1:      * Determine is a particular line is executable, like checking that
     1:      * lineToPc == pcToLine, except in one call.
     1:      * The |pcmap| argument specifies which pc to source line map to use.
     1:      */
     1:     boolean isLineExecutable(in unsigned long line, in unsigned long pcmap);
 71318: 
 71318:     /**
 71318:      * Return a list of all executable lines in a script.
 71318:      * |pcmap| specifies which pc to source line map to use.
 71318:      * |startLine| and |maxLines| may be used to retrieve a chunk at a time.
 71318:      */
 71318:     void getExecutableLines(in unsigned long pcmap,
 71318:                             in unsigned long startLine, in unsigned long maxLines,
 71319:                             [optional] out unsigned long count,
 71318:                             [array, size_is(count), retval] out unsigned long executableLines);
 71318:  
     1:     /**
     1:      * Set a breakpoint at a PC in this script.
     1:      */
     1:     void setBreakpoint(in unsigned long pc);
     1:     /**
     1:      * Clear a breakpoint at a PC in this script.
     1:      */
     1:     void clearBreakpoint(in unsigned long pc);
     1:     /**
     1:      * Clear all breakpoints set in this script.
     1:      */
     1:     void clearAllBreakpoints();
 59882:     /**
 59882:      * Call interrupt hook at least once per source line
 59882:      */
 74991:     void enableSingleStepInterrupts(in boolean mode);
     1: };
     1: 
     1: /**
     1:  * Value objects. Represents typeless JavaScript values (jsval in SpiderMonkey
     1:  * terminology.)  These are valid until the debugger is turned off. Holding a
     1:  * jsdIValue adds a root for the underlying JavaScript value, so don't keep it
     1:  * if you don't need to.
     1:  */
 84862: [scriptable, uuid(1cd3535b-4ddb-4202-9053-e0ec88f5c82b)]
     1: interface jsdIValue : jsdIEphemeral
     1: {
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDContext JSDContext;
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDValue   JSDValue;
     1: 
     1:     /**
     1:      * |false| unless the value is a function declared in script.
     1:      */
     1:     readonly attribute boolean isNative;
     1:     /**
     1:      * |true| if the value represents a number, either double or integer.
     1:      * |false| for all other values, including numbers assigned as strings
     1:      * (eg. x = "1";)
     1:      */
     1:     readonly attribute boolean isNumber;
     1:     /**
 23431:      * |true| if the value represents a JavaScript primitive number or AUTF8String
     1:      */
     1:     readonly attribute boolean isPrimitive;
     1:     
     1:     /** Value is either |true| or |false|. */
     1:     const unsigned long TYPE_BOOLEAN  = 0;
     1:     /** Value is a primitive number that is too large to fit in an integer. */
     1:     const unsigned long TYPE_DOUBLE   = 1;
     1:     /** Value is a primitive number that fits into an integer. */
     1:     const unsigned long TYPE_INT      = 2;
     1:     /** Value is a function. */
     1:     const unsigned long TYPE_FUNCTION = 3;
     1:     /** Value is |null|. */
     1:     const unsigned long TYPE_NULL     = 4;
     1:     /** Value is an object. */
     1:     const unsigned long TYPE_OBJECT   = 5;
 23431:     /** Value is a primitive AUTF8String. */
     1:     const unsigned long TYPE_STRING   = 6;
     1:     /** Value is void. */
     1:     const unsigned long TYPE_VOID     = 7;
     1:     
     1:     /**
     1:      * One of the TYPE_* values above.
     1:      */
     1:     readonly attribute unsigned long jsType;
     1:     /**
     1:      * Prototype value if this value represents an object, null if the value is
     1:      * not an object or the object has no prototype.
     1:      */
     1:     readonly attribute jsdIValue     jsPrototype;
     1:     /**
     1:      * Parent value if this value represents an object, null if the value is not
     1:      * an object or the object has no parent.
     1:      */    
     1:     readonly attribute jsdIValue     jsParent;
     1:     /**
 23431:      * Class name if this value represents an object. Empty AUTF8String if the value
     1:      * is not an object.
     1:      */
 23431:     readonly attribute AUTF8String   jsClassName;
     1:     /**
 23431:      * Constructor name if this value represents an object. Empty AUTF8String if the
     1:      * value is not an object.
     1:      */
     1:     readonly attribute jsdIValue     jsConstructor;
     1:     /**
 23431:      * Function name if this value represents a function. Empty AUTF8String if the
     1:      * value is not a function.
     1:      */
 23431:     readonly attribute AUTF8String   jsFunctionName;
     1:     
     1:     /**
     1:      * Value if interpreted as a boolean. Converts if necessary.
     1:      */
     1:     readonly attribute boolean       booleanValue;
     1:     /**
     1:      * Value if interpreted as a double. Converts if necessary.
     1:      */
     1:     readonly attribute double        doubleValue;
     1:     /**
     1:      * Value if interpreted as an integer. Converts if necessary.
     1:      */
     1:     readonly attribute long          intValue;
     1:     /**
     1:      * Value if interpreted as an object.
     1:      */
     1:     readonly attribute jsdIObject    objectValue;
     1:     /**
 23431:      * Value if interpreted as a AUTF8String. Converts if necessary.
     1:      */
 23431:     readonly attribute AUTF8String   stringValue;
     1: 
     1:     /**
     1:      * Number of properties. 0 if the value is not an object, or the value is
     1:      * an object but has no properties.
     1:      */
     1:     readonly attribute long propertyCount;
     1:     
     1:     /**
     1:      * Retrieves all properties if this value represents an object. If this
     1:      * value is not an object a 0 element array is returned.
     1:      * @param propArray Array of jsdIProperty values for this value.
     1:      * @param length    Size of array.
     1:      */
     1:     void getProperties([array, size_is(length)] out jsdIProperty propArray,
     1:                        out unsigned long length);
     1:     /**
     1:      * Retrieves a single property from the value. Only valid if the value
     1:      * represents an object.
     1:      * @param name Name of the property to retrieve.
     1:      * @retval     jsdIProperty for the requested property name or null if no
     1:      *             property exists for the requested name.
     1:      */
 23431:     jsdIProperty getProperty(in AUTF8String name);
     1: 
     1:     /**
     1:      * jsdIValues are wrappers around JavaScript engine structures. Much of the
     1:      * data is copied instead of shared. The refresh method is used to resync
     1:      * the jsdIValue with the underlying structure.
     1:      */
     1:     void refresh();
     1: 
     1:     /**
     1:      * When called from JavaScript, this method returns the JavaScript value
     1:      * wrapped by this jsdIValue. The calling script is free to use the result
     1:      * as it would any other JavaScript value.
     1:      * When called from another language this method returns an xpconnect
     1:      * defined error code.
     1:      */
 84862:     [implicit_jscontext] jsval getWrappedValue();
 33644: 
 33644:     /**
 33644:      * If this is a function value, return its associated jsdIScript.
 33644:      * Otherwise, return null.
 33644:      */
 33644:     readonly attribute jsdIScript script;
     1: };
     1: 
     1: /**
     1:  * Properties specific to values which are also objects.
     1:  * XXX We don't add roots for these yet, so make sure you hold on to the
     1:  * jsdIValue from whence your jsdIObject instance came for at least as long as
     1:  * you hold the jsdIObject.
     1:  * XXX Maybe the jsClassName, jsConstructorName, and property related attribute/
     1:  * functions from jsdIValue should move to this interface. We could inherit from
     1:  * jsdIValue or use interface flattening or something.
     1:  */
 59882: [scriptable, uuid(87d86308-7a27-4255-b23c-ce2394f02473)]
     1: interface jsdIObject : nsISupports
     1: {
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDContext JSDContext;
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDObject  JSDObject;
     1: 
     1:     /**
     1:      * The URL (filename) that contains the script which caused this object
     1:      * to be created.
     1:      */
 23431:     readonly attribute AUTF8String   creatorURL;
     1:     /**
     1:      * Line number in the creatorURL where this object was created.
     1:      */
     1:     readonly attribute unsigned long creatorLine;
     1:     /**
     1:      * The URL (filename) that contains the script which defined the constructor
     1:      * used to create this object.
     1:      */
 23431:     readonly attribute AUTF8String   constructorURL;
     1:     /**
     1:      * Line number in the creatorURL where this object was created.
     1:      */
     1:     readonly attribute unsigned long constructorLine;
     1:     /**
     1:      * jsdIValue for this object.
     1:      */
     1:     readonly attribute jsdIValue     value;
     1: };
     1: 
     1: /**
     1:  * Representation of a property of an object. When an instance is invalid, all
     1:  * method and property access will result in a NS_UNAVAILABLE error.
     1:  */
104201: [scriptable, uuid(acf1329e-aaf6-4d6a-a1eb-f75858566f09)]
     1: interface jsdIProperty : jsdIEphemeral
     1: {
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDContext  JSDContext;
     1:     /** Internal use only. */
     1:     [noscript] readonly attribute JSDProperty JSDProperty;
     1: 
     1:     /**
     1:      * FLAG_* values must be kept in sync with JSDPD_* #defines in jsdebug.h.
     1:      */
     1: 
     1:     /** visible to for/in loop */
     1:     const unsigned long FLAG_ENUMERATE = 0x01;
     1:     /** assignment is error */    
     1:     const unsigned long FLAG_READONLY  = 0x02;
     1:     /** property cannot be deleted */
     1:     const unsigned long FLAG_PERMANENT = 0x04;
     1:     /** property has an alias id */
     1:     const unsigned long FLAG_ALIAS     = 0x08;
     1:     /** argument to function */
     1:     const unsigned long FLAG_ARGUMENT  = 0x10;
     1:     /** local variable in function */
     1:     const unsigned long FLAG_VARIABLE  = 0x20;
     1:     /** exception occurred looking up property, value is exception */
     1:     const unsigned long FLAG_EXCEPTION = 0x40;
     1:     /** native getter returned JS_FALSE without throwing an exception */
     1:     const unsigned long FLAG_ERROR     = 0x80;
     1:     /** found via explicit lookup (property defined elsewhere.) */
     1:     const unsigned long FLAG_HINTED    = 0x800;
     1: 
     1:     /** FLAG_* values OR'd together, representing the flags for this property. */
     1:     readonly attribute unsigned long flags;
     1:     /** jsdIValue representing the alias for this property. */
     1:     readonly attribute jsdIValue     alias;
     1:     /** name for this property. */
     1:     readonly attribute jsdIValue     name;
     1:     /** value of this property. */
     1:     readonly attribute jsdIValue     value;
     1: };
