    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsXMLHttpRequest.h"
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsICharsetConverterManager.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIURI.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsNetUtil.h"
32329: #include "nsStreamUtils.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsIUploadChannel.h"
32329: #include "nsIUploadChannel2.h"
    1: #include "nsIDOMSerializer.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "prprf.h"
    1: #include "nsIDOMEventListener.h"
    1: #include "nsIJSContextStack.h"
 7093: #include "nsJSEnvironment.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsWeakPtr.h"
    1: #include "nsICharsetAlias.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIDOMClassInfo.h"
    1: #include "nsIDOMElement.h"
32329: #include "nsIDOMFileInternal.h"
    1: #include "nsIDOMWindow.h"
32329: #include "nsIMIMEService.h"
32329: #include "nsCExternalHandlerService.h"
    1: #include "nsIVariant.h"
 3941: #include "nsVariant.h"
    1: #include "nsIParser.h"
    1: #include "nsLoadListenerProxy.h"
    1: #include "nsStringStream.h"
    1: #include "nsIStreamConverterService.h"
    1: #include "nsICachingChannel.h"
    1: #include "nsContentUtils.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsDOMJSUtils.h"
    1: #include "nsCOMArray.h"
    1: #include "nsDOMClassInfo.h"
    1: #include "nsIScriptableUConv.h"
    1: #include "nsCycleCollectionParticipant.h"
   68: #include "nsIContentPolicy.h"
   68: #include "nsContentPolicyUtils.h"
   68: #include "nsContentErrors.h"
 1526: #include "nsLayoutStatics.h"
19951: #include "nsCrossSiteListenerProxy.h"
 3941: #include "nsDOMError.h"
 4064: #include "nsIHTMLDocument.h"
16447: #include "nsIDOM3Document.h"
 4106: #include "nsIMultiPartChannel.h"
 8947: #include "nsIScriptObjectPrincipal.h"
13258: #include "nsIStorageStream.h"
14092: #include "nsIPromptFactory.h"
14092: #include "nsIWindowWatcher.h"
19952: #include "nsCommaSeparatedTokenizer.h"
35023: #include "nsIConsoleService.h"
    1: 
    1: #define LOAD_STR "load"
    1: #define ERROR_STR "error"
16665: #define ABORT_STR "abort"
16665: #define LOADSTART_STR "loadstart"
    1: #define PROGRESS_STR "progress"
    1: #define UPLOADPROGRESS_STR "uploadprogress"
    1: #define READYSTATE_STR "readystatechange"
    1: 
    1: // CIDs
    1: 
    1: // State
    1: #define XML_HTTP_REQUEST_UNINITIALIZED  (1 << 0)  // 0
    1: #define XML_HTTP_REQUEST_OPENED         (1 << 1)  // 1 aka LOADING
    1: #define XML_HTTP_REQUEST_LOADED         (1 << 2)  // 2
    1: #define XML_HTTP_REQUEST_INTERACTIVE    (1 << 3)  // 3
    1: #define XML_HTTP_REQUEST_COMPLETED      (1 << 4)  // 4
    1: #define XML_HTTP_REQUEST_SENT           (1 << 5)  // Internal, LOADING in IE and external view
    1: #define XML_HTTP_REQUEST_STOPPED        (1 << 6)  // Internal, INTERACTIVE in IE and external view
    1: // The above states are mutually exclusive, change with ChangeState() only.
    1: // The states below can be combined.
    1: #define XML_HTTP_REQUEST_ABORTED        (1 << 7)  // Internal
    1: #define XML_HTTP_REQUEST_ASYNC          (1 << 8)  // Internal
    1: #define XML_HTTP_REQUEST_PARSEBODY      (1 << 9)  // Internal
 4064: #define XML_HTTP_REQUEST_XSITEENABLED   (1 << 10) // Internal, Is any cross-site request allowed?
 4064:                                                   //           Even if this is false the
 4064:                                                   //           access-control spec is supported
    1: #define XML_HTTP_REQUEST_SYNCLOOPING    (1 << 11) // Internal
    1: #define XML_HTTP_REQUEST_MULTIPART      (1 << 12) // Internal
13557: #define XML_HTTP_REQUEST_GOT_FINAL_STOP (1 << 13) // Internal
13557: #define XML_HTTP_REQUEST_BACKGROUND     (1 << 14) // Internal
19152: // This is set when we've got the headers for a multipart XMLHttpRequest,
19152: // but haven't yet started to process the first part.
19152: #define XML_HTTP_REQUEST_MPART_HEADERS  (1 << 15) // Internal
19951: #define XML_HTTP_REQUEST_USE_XSITE_AC   (1 << 16) // Internal
19952: #define XML_HTTP_REQUEST_NEED_AC_PREFLIGHT (1 << 17) // Internal
19954: #define XML_HTTP_REQUEST_AC_WITH_CREDENTIALS (1 << 18) // Internal
    1: 
    1: #define XML_HTTP_REQUEST_LOADSTATES         \
    1:   (XML_HTTP_REQUEST_UNINITIALIZED |         \
    1:    XML_HTTP_REQUEST_OPENED |                \
    1:    XML_HTTP_REQUEST_LOADED |                \
    1:    XML_HTTP_REQUEST_INTERACTIVE |           \
    1:    XML_HTTP_REQUEST_COMPLETED |             \
    1:    XML_HTTP_REQUEST_SENT |                  \
    1:    XML_HTTP_REQUEST_STOPPED)
    1: 
20560: #define ACCESS_CONTROL_CACHE_SIZE 100
20560: 
13282: #define NS_BADCERTHANDLER_CONTRACTID \
13282:   "@mozilla.org/content/xmlhttprequest-bad-cert-handler;1"
13282: 
23607: #define NS_PROGRESS_EVENT_INTERVAL 50
20640: 
25722: class nsResumeTimeoutsEvent : public nsRunnable
25722: {
25722: public:
25722:   nsResumeTimeoutsEvent(nsPIDOMWindow* aWindow) : mWindow(aWindow) {}
25722: 
25722:   NS_IMETHOD Run()
25722:   {
25722:     mWindow->ResumeTimeouts(PR_FALSE);
25722:     return NS_OK;
25722:   }
25722: 
25722: private:
25722:   nsCOMPtr<nsPIDOMWindow> mWindow;
25722: };
25722: 
16664: 
    1: // This helper function adds the given load flags to the request's existing
    1: // load flags.
    1: static void AddLoadFlags(nsIRequest *request, nsLoadFlags newFlags)
    1: {
    1:   nsLoadFlags flags;
    1:   request->GetLoadFlags(&flags);
    1:   flags |= newFlags;
    1:   request->SetLoadFlags(flags);
    1: }
    1: 
13282: static nsresult IsCapabilityEnabled(const char *capability, PRBool *enabled)
13282: {
13282:   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
13282:   if (!secMan)
13282:     return NS_ERROR_FAILURE;
13282: 
13282:   return secMan->IsCapabilityEnabled(capability, enabled);
13282: }
13282: 
    1: // Helper proxy class to be used when expecting an
    1: // multipart/x-mixed-replace stream of XML documents.
    1: 
    1: class nsMultipartProxyListener : public nsIStreamListener
    1: {
    1: public:
    1:   nsMultipartProxyListener(nsIStreamListener *dest);
    1:   virtual ~nsMultipartProxyListener();
    1: 
    1:   /* additional members */
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSISTREAMLISTENER
    1:   NS_DECL_NSIREQUESTOBSERVER
    1: 
    1: private:
    1:   nsCOMPtr<nsIStreamListener> mDestListener;
    1: };
    1: 
    1: 
    1: nsMultipartProxyListener::nsMultipartProxyListener(nsIStreamListener *dest)
    1:   : mDestListener(dest)
    1: {
    1: }
    1: 
    1: nsMultipartProxyListener::~nsMultipartProxyListener()
    1: {
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS2(nsMultipartProxyListener, nsIStreamListener,
    1:                    nsIRequestObserver)
    1: 
    1: /** nsIRequestObserver methods **/
    1: 
    1: NS_IMETHODIMP
    1: nsMultipartProxyListener::OnStartRequest(nsIRequest *aRequest,
    1:                                          nsISupports *ctxt)
    1: {
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
    1: 
    1:   nsCAutoString contentType;
    1:   nsresult rv = channel->GetContentType(contentType);
    1: 
    1:   if (!contentType.EqualsLiteral("multipart/x-mixed-replace")) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   // If multipart/x-mixed-replace content, we'll insert a MIME
    1:   // decoder in the pipeline to handle the content and pass it along
    1:   // to our original listener.
    1: 
19152:   nsCOMPtr<nsIXMLHttpRequest> xhr = do_QueryInterface(mDestListener);
19152: 
    1:   nsCOMPtr<nsIStreamConverterService> convServ =
    1:     do_GetService("@mozilla.org/streamConverters;1", &rv);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIStreamListener> toListener(mDestListener);
    1:     nsCOMPtr<nsIStreamListener> fromListener;
    1: 
    1:     rv = convServ->AsyncConvertData("multipart/x-mixed-replace",
    1:                                     "*/*",
    1:                                     toListener,
    1:                                     nsnull,
    1:                                     getter_AddRefs(fromListener));
    1:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && fromListener, NS_ERROR_UNEXPECTED);
    1: 
    1:     mDestListener = fromListener;
    1:   }
    1: 
19152:   if (xhr) {
19152:     static_cast<nsXMLHttpRequest*>(xhr.get())->mState |=
19152:       XML_HTTP_REQUEST_MPART_HEADERS;
19152:    }
19152: 
    1:   return mDestListener->OnStartRequest(aRequest, ctxt);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMultipartProxyListener::OnStopRequest(nsIRequest *aRequest,
    1:                                         nsISupports *ctxt,
    1:                                         nsresult status)
    1: {
    1:   return mDestListener->OnStopRequest(aRequest, ctxt, status);
    1: }
    1: 
    1: /** nsIStreamListener methods **/
    1: 
    1: NS_IMETHODIMP
    1: nsMultipartProxyListener::OnDataAvailable(nsIRequest *aRequest,
    1:                                           nsISupports *ctxt,
    1:                                           nsIInputStream *inStr,
    1:                                           PRUint32 sourceOffset,
    1:                                           PRUint32 count)
    1: {
    1:   return mDestListener->OnDataAvailable(aRequest, ctxt, inStr, sourceOffset,
    1:                                         count);
    1: }
    1: 
20560: // Class used as streamlistener and notification callback when
20560: // doing the initial GET request for an access-control check
20560: class nsACProxyListener : public nsIStreamListener,
20560:                           public nsIInterfaceRequestor,
20560:                           public nsIChannelEventSink
20560: {
20560: public:
20560:   nsACProxyListener(nsIChannel* aOuterChannel,
20560:                     nsIStreamListener* aOuterListener,
20560:                     nsISupports* aOuterContext,
20560:                     nsIPrincipal* aReferrerPrincipal,
20560:                     const nsACString& aRequestMethod,
20560:                     PRBool aWithCredentials)
20560:    : mOuterChannel(aOuterChannel), mOuterListener(aOuterListener),
20560:      mOuterContext(aOuterContext), mReferrerPrincipal(aReferrerPrincipal),
20560:      mRequestMethod(aRequestMethod), mWithCredentials(aWithCredentials)
20560:   { }
20560: 
20560:   NS_DECL_ISUPPORTS
20560:   NS_DECL_NSISTREAMLISTENER
20560:   NS_DECL_NSIREQUESTOBSERVER
20560:   NS_DECL_NSIINTERFACEREQUESTOR
20560:   NS_DECL_NSICHANNELEVENTSINK
20560: 
20560: private:
20560:   void AddResultToCache(nsIRequest* aRequest);
20560: 
20560:   nsCOMPtr<nsIChannel> mOuterChannel;
20560:   nsCOMPtr<nsIStreamListener> mOuterListener;
20560:   nsCOMPtr<nsISupports> mOuterContext;
20560:   nsCOMPtr<nsIPrincipal> mReferrerPrincipal;
20560:   nsCString mRequestMethod;
20560:   PRBool mWithCredentials;
20560: };
20560: 
20560: NS_IMPL_ISUPPORTS4(nsACProxyListener, nsIStreamListener, nsIRequestObserver,
20560:                    nsIInterfaceRequestor, nsIChannelEventSink)
20560: 
20560: void
20560: nsACProxyListener::AddResultToCache(nsIRequest *aRequest)
20560: {
20560:   nsCOMPtr<nsIHttpChannel> http = do_QueryInterface(aRequest);
20560:   NS_ASSERTION(http, "Request was not http");
20560: 
20560:   // The "Access-Control-Max-Age" header should return an age in seconds.
20560:   nsCAutoString headerVal;
20560:   http->GetResponseHeader(NS_LITERAL_CSTRING("Access-Control-Max-Age"),
20560:                           headerVal);
20560:   if (headerVal.IsEmpty()) {
20560:     return;
20560:   }
20560: 
20560:   // Sanitize the string. We only allow 'delta-seconds' as specified by
20560:   // http://dev.w3.org/2006/waf/access-control (digits 0-9 with no leading or
20560:   // trailing non-whitespace characters).
20560:   PRUint32 age = 0;
20560:   nsCSubstring::const_char_iterator iter, end;
20560:   headerVal.BeginReading(iter);
20560:   headerVal.EndReading(end);
20560:   while (iter != end) {
20560:     if (*iter < '0' || *iter > '9') {
20560:       return;
20560:     }
20560:     age = age * 10 + (*iter - '0');
20560:     // Cap at 24 hours. This also avoids overflow
20560:     age = PR_MIN(age, 86400);
20560:     ++iter;
20560:   }
20560: 
20560:   if (!age || !nsXMLHttpRequest::EnsureACCache()) {
20560:     return;
20560:   }
20560: 
20560: 
20560:   // String seems fine, go ahead and cache.
20560:   // Note that we have already checked that these headers follow the correct
20560:   // syntax.
20560: 
20560:   nsCOMPtr<nsIURI> uri;
20560:   http->GetURI(getter_AddRefs(uri));
20560: 
20560:   // PR_Now gives microseconds
20560:   PRTime expirationTime = PR_Now() + (PRUint64)age * PR_USEC_PER_SEC;
20560: 
20560:   nsAccessControlLRUCache::CacheEntry* entry =
20560:     nsXMLHttpRequest::sAccessControlCache->
20560:     GetEntry(uri, mReferrerPrincipal, mWithCredentials, PR_TRUE);
20560:   if (!entry) {
20560:     return;
20560:   }
20560: 
20560:   // The "Access-Control-Allow-Methods" header contains a comma separated
20560:   // list of method names.
20560:   http->GetResponseHeader(NS_LITERAL_CSTRING("Access-Control-Allow-Methods"),
20560:                           headerVal);
20560: 
20560:   nsCCommaSeparatedTokenizer methods(headerVal);
20560:   while(methods.hasMoreTokens()) {
20560:     const nsDependentCSubstring& method = methods.nextToken();
20560:     if (method.IsEmpty()) {
20560:       continue;
20560:     }
20560:     PRUint32 i;
20560:     for (i = 0; i < entry->mMethods.Length(); ++i) {
20560:       if (entry->mMethods[i].token.Equals(method)) {
20560:         entry->mMethods[i].expirationTime = expirationTime;
20560:         break;
20560:       }
20560:     }
20560:     if (i == entry->mMethods.Length()) {
20560:       nsAccessControlLRUCache::TokenTime* newMethod =
20560:         entry->mMethods.AppendElement();
20560:       if (!newMethod) {
20560:         return;
20560:       }
20560: 
20560:       newMethod->token = method;
20560:       newMethod->expirationTime = expirationTime;
20560:     }
20560:   }
20560: 
20560:   // The "Access-Control-Allow-Headers" header contains a comma separated
20560:   // list of method names.
20560:   http->GetResponseHeader(NS_LITERAL_CSTRING("Access-Control-Allow-Headers"),
20560:                           headerVal);
20560: 
20560:   nsCCommaSeparatedTokenizer headers(headerVal);
20560:   while(headers.hasMoreTokens()) {
20560:     const nsDependentCSubstring& header = headers.nextToken();
20560:     if (header.IsEmpty()) {
20560:       continue;
20560:     }
20560:     PRUint32 i;
20560:     for (i = 0; i < entry->mHeaders.Length(); ++i) {
20560:       if (entry->mHeaders[i].token.Equals(header)) {
20560:         entry->mHeaders[i].expirationTime = expirationTime;
20560:         break;
20560:       }
20560:     }
20560:     if (i == entry->mHeaders.Length()) {
20560:       nsAccessControlLRUCache::TokenTime* newHeader =
20560:         entry->mHeaders.AppendElement();
20560:       if (!newHeader) {
20560:         return;
20560:       }
20560: 
20560:       newHeader->token = header;
20560:       newHeader->expirationTime = expirationTime;
20560:     }
20560:   }
20560: }
20560: 
20560: NS_IMETHODIMP
20560: nsACProxyListener::OnStartRequest(nsIRequest *aRequest, nsISupports *aContext)
20560: {
20560:   nsresult status;
20560:   nsresult rv = aRequest->GetStatus(&status);
20560: 
20560:   if (NS_SUCCEEDED(rv)) {
20560:     rv = status;
20560:   }
20560: 
20560:   if (NS_SUCCEEDED(rv)) {
20560:     // Everything worked, try to cache and then fire off the actual request.
20560:     AddResultToCache(aRequest);
20560: 
20560:     rv = mOuterChannel->AsyncOpen(mOuterListener, mOuterContext);
20560:   }
20560: 
20560:   if (NS_FAILED(rv)) {
20560:     mOuterChannel->Cancel(rv);
20560:     mOuterListener->OnStartRequest(mOuterChannel, mOuterContext);
20560:     mOuterListener->OnStopRequest(mOuterChannel, mOuterContext, rv);
20560:     
20560:     return rv;
20560:   }
20560: 
20560:   return NS_OK;
20560: }
20560: 
20560: NS_IMETHODIMP
20560: nsACProxyListener::OnStopRequest(nsIRequest *aRequest, nsISupports *aContext,
20560:                                  nsresult aStatus)
20560: {
20560:   return NS_OK;
20560: }
20560: 
20560: /** nsIStreamListener methods **/
20560: 
20560: NS_IMETHODIMP
20560: nsACProxyListener::OnDataAvailable(nsIRequest *aRequest,
20560:                                    nsISupports *ctxt,
20560:                                    nsIInputStream *inStr,
20560:                                    PRUint32 sourceOffset,
20560:                                    PRUint32 count)
20560: {
20560:   return NS_OK;
20560: }
20560: 
20560: NS_IMETHODIMP
20560: nsACProxyListener::OnChannelRedirect(nsIChannel *aOldChannel,
20560:                                      nsIChannel *aNewChannel,
20560:                                      PRUint32 aFlags)
20560: {
24084:   // Only internal redirects allowed for now.
24084:   return NS_IsInternalSameURIRedirect(aOldChannel, aNewChannel, aFlags) ?
24084:          NS_OK : NS_ERROR_DOM_BAD_URI;
20560: }
20560: 
20560: NS_IMETHODIMP
20560: nsACProxyListener::GetInterface(const nsIID & aIID, void **aResult)
20560: {
20560:   return QueryInterface(aIID, aResult);
20560: }
20560: 
    1: /////////////////////////////////////////////
16665: 
30001: nsXHREventTarget::~nsXHREventTarget()
30001: {
30001:   nsISupports *supports = static_cast<nsIXMLHttpRequestEventTarget*>(this);
30001:   nsContentUtils::ReleaseWrapper(supports, this);
30001: }
30001: 
16665: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXHREventTarget)
16665: 
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsXHREventTarget)
30001:   NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_END
30001: 
29226: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXHREventTarget,
29226:                                                   nsDOMEventTargetHelper)
30001:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnLoadListener)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnErrorListener)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnAbortListener)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnLoadStartListener)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnProgressListener)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsXHREventTarget)
30001:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_END
30001: 
29226: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXHREventTarget,
29226:                                                 nsDOMEventTargetHelper)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnLoadListener)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnErrorListener)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnAbortListener)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnLoadStartListener)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnProgressListener)
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
29226: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXHREventTarget)
21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
16665:   NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestEventTarget)
29226: NS_INTERFACE_MAP_END_INHERITING(nsDOMEventTargetHelper)
29226: 
29226: NS_IMPL_ADDREF_INHERITED(nsXHREventTarget, nsDOMEventTargetHelper)
29226: NS_IMPL_RELEASE_INHERITED(nsXHREventTarget, nsDOMEventTargetHelper)
    1: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::GetOnload(nsIDOMEventListener** aOnLoad)
16665: {
16665:   return GetInnerEventListener(mOnLoadListener, aOnLoad);
16665: }
16665: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::SetOnload(nsIDOMEventListener* aOnLoad)
16665: {
16665:   return RemoveAddEventListener(NS_LITERAL_STRING(LOAD_STR),
16665:                                 mOnLoadListener, aOnLoad);
16665: }
16665: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::GetOnerror(nsIDOMEventListener** aOnerror)
16665: {
16665:   return GetInnerEventListener(mOnErrorListener, aOnerror);
16665: }
16665: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::SetOnerror(nsIDOMEventListener* aOnerror)
16665: {
16665:   return RemoveAddEventListener(NS_LITERAL_STRING(ERROR_STR),
16665:                                 mOnErrorListener, aOnerror);
16665: }
16665: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::GetOnabort(nsIDOMEventListener** aOnabort)
16665: {
16665:   return GetInnerEventListener(mOnAbortListener, aOnabort);
16665: }
16665: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::SetOnabort(nsIDOMEventListener* aOnabort)
16665: {
16665:   return RemoveAddEventListener(NS_LITERAL_STRING(ABORT_STR),
16665:                                 mOnAbortListener, aOnabort);
16665: }
16665: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::GetOnloadstart(nsIDOMEventListener** aOnloadstart)
16665: {
16665:   return GetInnerEventListener(mOnLoadStartListener, aOnloadstart);
16665: }
16665: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::SetOnloadstart(nsIDOMEventListener* aOnloadstart)
16665: {
16665:   return RemoveAddEventListener(NS_LITERAL_STRING(LOADSTART_STR),
16665:                                 mOnLoadStartListener, aOnloadstart);
16665: }
16665: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::GetOnprogress(nsIDOMEventListener** aOnprogress)
16665: {
16665:   return GetInnerEventListener(mOnProgressListener, aOnprogress);
16665: }
16665: 
16665: NS_IMETHODIMP
16665: nsXHREventTarget::SetOnprogress(nsIDOMEventListener* aOnprogress)
16665: {
16665:   return RemoveAddEventListener(NS_LITERAL_STRING(PROGRESS_STR),
16665:                                 mOnProgressListener, aOnprogress);
16665: }
16665: 
16665: /////////////////////////////////////////////
19701: 
20195: nsXMLHttpRequestUpload::~nsXMLHttpRequestUpload()
20195: {
20195:   if (mListenerManager) {
20195:     mListenerManager->Disconnect();
20195:   }
20195: }
20195: 
19701: NS_INTERFACE_MAP_BEGIN(nsXMLHttpRequestUpload)
16665:   NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestUpload)
16665:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(XMLHttpRequestUpload)
16665: NS_INTERFACE_MAP_END_INHERITING(nsXHREventTarget)
16665: 
16665: NS_IMPL_ADDREF_INHERITED(nsXMLHttpRequestUpload, nsXHREventTarget)
16665: NS_IMPL_RELEASE_INHERITED(nsXMLHttpRequestUpload, nsXHREventTarget)
16665: 
20560: void
20560: nsAccessControlLRUCache::CacheEntry::PurgeExpired(PRTime now)
20560: {
20560:   PRUint32 i;
20560:   for (i = 0; i < mMethods.Length(); ++i) {
20560:     if (now >= mMethods[i].expirationTime) {
20560:       mMethods.RemoveElementAt(i--);
20560:     }
20560:   }
20560:   for (i = 0; i < mHeaders.Length(); ++i) {
20560:     if (now >= mHeaders[i].expirationTime) {
20560:       mHeaders.RemoveElementAt(i--);
20560:     }
20560:   }
20560: }
20560: 
20560: PRBool
20560: nsAccessControlLRUCache::CacheEntry::CheckRequest(const nsCString& aMethod,
20560:                                                   const nsTArray<nsCString>& aHeaders)
20560: {
20560:   PurgeExpired(PR_Now());
20560: 
20560:   if (!aMethod.EqualsLiteral("GET") && !aMethod.EqualsLiteral("POST")) {
20560:     PRUint32 i;
20560:     for (i = 0; i < mMethods.Length(); ++i) {
20560:       if (aMethod.Equals(mMethods[i].token))
20560:         break;
20560:     }
20560:     if (i == mMethods.Length()) {
20560:       return PR_FALSE;
20560:     }
20560:   }
20560: 
20560:   for (PRUint32 i = 0; i < aHeaders.Length(); ++i) {
20560:     PRUint32 j;
20560:     for (j = 0; j < mHeaders.Length(); ++j) {
20560:       if (aHeaders[i].Equals(mHeaders[j].token,
20560:                              nsCaseInsensitiveCStringComparator())) {
20560:         break;
20560:       }
20560:     }
20560:     if (j == mHeaders.Length()) {
20560:       return PR_FALSE;
20560:     }
20560:   }
20560: 
20560:   return PR_TRUE;
20560: }
20560: 
20560: nsAccessControlLRUCache::CacheEntry*
20560: nsAccessControlLRUCache::GetEntry(nsIURI* aURI,
20560:                                   nsIPrincipal* aPrincipal,
20560:                                   PRBool aWithCredentials,
20560:                                   PRBool aCreate)
20560: {
20560:   nsCString key;
20560:   if (!GetCacheKey(aURI, aPrincipal, aWithCredentials, key)) {
20560:     NS_WARNING("Invalid cache key!");
20560:     return nsnull;
20560:   }
20560: 
20560:   CacheEntry* entry;
20560: 
20560:   if (mTable.Get(key, &entry)) {
20560:     // Entry already existed so just return it. Also update the LRU list.
20560: 
20560:     // Move to the head of the list.
20560:     PR_REMOVE_LINK(entry);
20560:     PR_INSERT_LINK(entry, &mList);
20560: 
20560:     return entry;
20560:   }
20560: 
20560:   if (!aCreate) {
20560:     return nsnull;
20560:   }
20560: 
20560:   // This is a new entry, allocate and insert into the table now so that any
20560:   // failures don't cause items to be removed from a full cache.
20560:   entry = new CacheEntry(key);
20560:   if (!entry) {
20560:     NS_WARNING("Failed to allocate new cache entry!");
20560:     return nsnull;
20560:   }
20560: 
20560:   if (!mTable.Put(key, entry)) {
20560:     // Failed, clean up the new entry.
20560:     delete entry;
20560: 
20560:     NS_WARNING("Failed to add entry to the access control cache!");
20560:     return nsnull;
20560:   }
20560: 
20560:   PR_INSERT_LINK(entry, &mList);
20560: 
20560:   NS_ASSERTION(mTable.Count() <= ACCESS_CONTROL_CACHE_SIZE + 1,
20560:                "Something is borked, too many entries in the cache!");
20560: 
20560:   // Now enforce the max count.
20560:   if (mTable.Count() > ACCESS_CONTROL_CACHE_SIZE) {
20560:     // Try to kick out all the expired entries.
20560:     PRTime now = PR_Now();
20560:     mTable.Enumerate(RemoveExpiredEntries, &now);
20560: 
20560:     // If that didn't remove anything then kick out the least recently used
20560:     // entry.
20560:     if (mTable.Count() > ACCESS_CONTROL_CACHE_SIZE) {
20560:       CacheEntry* lruEntry = static_cast<CacheEntry*>(PR_LIST_TAIL(&mList));
20560:       PR_REMOVE_LINK(lruEntry);
20560: 
20560:       // This will delete 'lruEntry'.
20560:       mTable.Remove(lruEntry->mKey);
20560: 
25081:       NS_ASSERTION(mTable.Count() == ACCESS_CONTROL_CACHE_SIZE,
20560:                    "Somehow tried to remove an entry that was never added!");
20560:     }
20560:   }
20560:   
20560:   return entry;
20560: }
20560: 
20560: void
25081: nsAccessControlLRUCache::RemoveEntries(nsIURI* aURI, nsIPrincipal* aPrincipal)
25081: {
25081:   CacheEntry* entry;
25081:   nsCString key;
25081:   if (GetCacheKey(aURI, aPrincipal, PR_TRUE, key) &&
25081:       mTable.Get(key, &entry)) {
25081:     PR_REMOVE_LINK(entry);
25081:     mTable.Remove(key);
25081:   }
25081: 
25081:   if (GetCacheKey(aURI, aPrincipal, PR_FALSE, key) &&
25081:       mTable.Get(key, &entry)) {
25081:     PR_REMOVE_LINK(entry);
25081:     mTable.Remove(key);
25081:   }
25081: }
25081: 
25081: void
20560: nsAccessControlLRUCache::Clear()
20560: {
20560:   PR_INIT_CLIST(&mList);
20560:   mTable.Clear();
20560: }
20560: 
20705: /* static */ PLDHashOperator
20560: nsAccessControlLRUCache::RemoveExpiredEntries(const nsACString& aKey,
20560:                                               nsAutoPtr<CacheEntry>& aValue,
20560:                                               void* aUserData)
20560: {
20560:   PRTime* now = static_cast<PRTime*>(aUserData);
20560:   
20560:   aValue->PurgeExpired(*now);
20560:   
20560:   if (aValue->mHeaders.IsEmpty() &&
20560:       aValue->mHeaders.IsEmpty()) {
20560:     // Expired, remove from the list as well as the hash table.
20560:     PR_REMOVE_LINK(aValue);
20560:     return PL_DHASH_REMOVE;
20560:   }
20560:   
20560:   return PL_DHASH_NEXT;
20560: }
20560: 
20560: /* static */ PRBool
20560: nsAccessControlLRUCache::GetCacheKey(nsIURI* aURI,
20560:                                      nsIPrincipal* aPrincipal,
20560:                                      PRBool aWithCredentials,
20560:                                      nsACString& _retval)
20560: {
20560:   NS_ASSERTION(aURI, "Null uri!");
20560:   NS_ASSERTION(aPrincipal, "Null principal!");
20560:   
20560:   NS_NAMED_LITERAL_CSTRING(space, " ");
20560: 
20560:   nsCOMPtr<nsIURI> uri;
20560:   nsresult rv = aPrincipal->GetURI(getter_AddRefs(uri));
20560:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
20560:   
20560:   nsCAutoString scheme, host, port;
20560:   if (uri) {
20560:     uri->GetScheme(scheme);
20560:     uri->GetHost(host);
20560:     port.AppendInt(NS_GetRealPort(uri));
20560:   }
20560: 
20560:   nsCAutoString cred;
20560:   if (aWithCredentials) {
20560:     _retval.AssignLiteral("cred");
20560:   }
20560:   else {
20560:     _retval.AssignLiteral("nocred");
20560:   }
20560: 
20560:   nsCAutoString spec;
20560:   rv = aURI->GetSpec(spec);
20560:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
20560: 
20560:   _retval.Assign(cred + space + scheme + space + host + space + port + space +
20560:                  spec);
20560: 
20560:   return PR_TRUE;
20560: }
19951: 
16665: /////////////////////////////////////////////
16665: //
16665: //
16665: /////////////////////////////////////////////
16665: 
20560: // Will be initialized in nsXMLHttpRequest::EnsureACCache.
20560: nsAccessControlLRUCache* nsXMLHttpRequest::sAccessControlCache = nsnull;
20560: 
16665: nsXMLHttpRequest::nsXMLHttpRequest()
19944:   : mRequestObserver(nsnull), mState(XML_HTTP_REQUEST_UNINITIALIZED),
19944:     mUploadTransferred(0), mUploadTotal(0), mUploadComplete(PR_TRUE),
20640:     mUploadProgress(0), mUploadProgressMax(0),
20640:     mErrorLoad(PR_FALSE), mTimerIsActive(PR_FALSE),
20640:     mProgressEventWasDelayed(PR_FALSE),
20640:     mLoadLengthComputable(PR_FALSE), mLoadTotal(0),
20640:     mFirstStartRequestSeen(PR_FALSE)
16665: {
16665:   nsLayoutStatics::AddRef();
16665: }
16665: 
16665: nsXMLHttpRequest::~nsXMLHttpRequest()
16665: {
16665:   if (mListenerManager) {
16665:     mListenerManager->Disconnect();
16665:   }
16665: 
16665:   if (mState & (XML_HTTP_REQUEST_STOPPED |
16665:                 XML_HTTP_REQUEST_SENT |
16665:                 XML_HTTP_REQUEST_INTERACTIVE)) {
16665:     Abort();
16665:   }
16665: 
16665:   NS_ABORT_IF_FALSE(!(mState & XML_HTTP_REQUEST_SYNCLOOPING), "we rather crash than hang");
16665:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
16665: 
16665:   nsLayoutStatics::Release();
16665: }
16665: 
16665: /**
16665:  * This Init method is called from the factory constructor.
16665:  */
16665: nsresult
16665: nsXMLHttpRequest::Init()
16665: {
16665:   // Set the original mScriptContext and mPrincipal, if available.
16665:   // Get JSContext from stack.
16665:   nsCOMPtr<nsIJSContextStack> stack =
16665:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
16665: 
16665:   if (!stack) {
16665:     return NS_OK;
16665:   }
16665: 
16665:   JSContext *cx;
16665: 
16665:   if (NS_FAILED(stack->Peek(&cx)) || !cx) {
16665:     return NS_OK;
16665:   }
16665: 
16665:   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
16665:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
16665:   if (secMan) {
16665:     secMan->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
16665:   }
16665:   NS_ENSURE_STATE(subjectPrincipal);
16665:   mPrincipal = subjectPrincipal;
16665: 
16665:   nsIScriptContext* context = GetScriptContextFromJSContext(cx);
16665:   if (context) {
16665:     mScriptContext = context;
16665:     nsCOMPtr<nsPIDOMWindow> window =
16665:       do_QueryInterface(context->GetGlobalObject());
16665:     if (window) {
16665:       mOwner = window->GetCurrentInnerWindow();
16665:     }
16665:   }
16665: 
16665:   return NS_OK;
16665: }
16665: /**
16665:  * This Init method should only be called by C++ consumers.
16665:  */
16665: NS_IMETHODIMP
16665: nsXMLHttpRequest::Init(nsIPrincipal* aPrincipal,
16665:                        nsIScriptContext* aScriptContext,
23201:                        nsPIDOMWindow* aOwnerWindow,
23201:                        nsIURI* aBaseURI)
16665: {
16665:   NS_ENSURE_ARG_POINTER(aPrincipal);
16665: 
16665:   // This object may have already been initialized in the other Init call above
16665:   // if JS was on the stack. Clear the old values for mScriptContext and mOwner
16665:   // if new ones are not supplied here.
16665: 
16665:   mPrincipal = aPrincipal;
16665:   mScriptContext = aScriptContext;
16665:   if (aOwnerWindow) {
16665:     mOwner = aOwnerWindow->GetCurrentInnerWindow();
16665:   }
16665:   else {
16665:     mOwner = nsnull;
16665:   }
23201:   mBaseURI = aBaseURI;
16665: 
16665:   return NS_OK;
16665: }
16665: 
16665: /**
16665:  * This Initialize method is called from XPConnect via nsIJSNativeInitializer.
16665:  */
16665: NS_IMETHODIMP
16665: nsXMLHttpRequest::Initialize(nsISupports* aOwner, JSContext* cx, JSObject* obj,
16665:                              PRUint32 argc, jsval *argv)
16665: {
16665:   mOwner = do_QueryInterface(aOwner);
16665:   if (!mOwner) {
16665:     NS_WARNING("Unexpected nsIJSNativeInitializer owner");
16665:     return NS_OK;
16665:   }
16665: 
16665:   // This XHR object is bound to a |window|,
16665:   // so re-set principal and script context.
16665:   nsCOMPtr<nsIScriptObjectPrincipal> scriptPrincipal = do_QueryInterface(aOwner);
16665:   NS_ENSURE_STATE(scriptPrincipal);
16665:   mPrincipal = scriptPrincipal->GetPrincipal();
16665:   nsCOMPtr<nsIScriptGlobalObject> sgo = do_QueryInterface(aOwner);
16665:   NS_ENSURE_STATE(sgo);
16665:   mScriptContext = sgo->GetContext();
16665:   NS_ENSURE_STATE(mScriptContext);
16665:   return NS_OK; 
16665: }
16665: 
19944: void
19944: nsXMLHttpRequest::SetRequestObserver(nsIRequestObserver* aObserver)
19944: {
19944:   mRequestObserver = aObserver;
19944: }
19944: 
16665: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLHttpRequest)
16665: 
16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXMLHttpRequest,
16665:                                                   nsXHREventTarget)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannel)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mReadRequest)
21005:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mResponseXML)
21005:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mACGetChannel)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnUploadProgressListener)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnReadystatechangeListener)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mXMLParserStreamListener)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannelEventSink)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mProgressEventSink)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mUpload,
16665:                                                        nsIXMLHttpRequestUpload)
16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
16665: 
16665: 
16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXMLHttpRequest,
16665:                                                 nsXHREventTarget)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContext)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChannel)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mReadRequest)
21005:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mResponseXML)
21005:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mACGetChannel)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnUploadProgressListener)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnReadystatechangeListener)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mXMLParserStreamListener)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChannelEventSink)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mProgressEventSink)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mUpload)
16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16665: 
16665: 
16665: // QueryInterface implementation for nsXMLHttpRequest
16665: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXMLHttpRequest)
16665:   NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequest)
16665:   NS_INTERFACE_MAP_ENTRY(nsIJSXMLHttpRequest)
16665:   NS_INTERFACE_MAP_ENTRY(nsIDOMLoadListener)
16665:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventListener)
16665:   NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
16665:   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
16665:   NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
16665:   NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
16665:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
16665:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
16665:   NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
20640:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
16665:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(XMLHttpRequest)
16665: NS_INTERFACE_MAP_END_INHERITING(nsXHREventTarget)
16665: 
16665: NS_IMPL_ADDREF_INHERITED(nsXMLHttpRequest, nsXHREventTarget)
16665: NS_IMPL_RELEASE_INHERITED(nsXMLHttpRequest, nsXHREventTarget)
16665: 
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetOnreadystatechange(nsIDOMEventListener * *aOnreadystatechange)
    1: {
16665:   return
16665:     nsXHREventTarget::GetInnerEventListener(mOnReadystatechangeListener,
16664:                                             aOnreadystatechange);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::SetOnreadystatechange(nsIDOMEventListener * aOnreadystatechange)
    1: {
16665:   return
16665:     nsXHREventTarget::RemoveAddEventListener(NS_LITERAL_STRING(READYSTATE_STR),
16664:                                              mOnReadystatechangeListener,
16664:                                              aOnreadystatechange);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetOnuploadprogress(nsIDOMEventListener * *aOnuploadprogress)
    1: {
16665:   return
16665:     nsXHREventTarget::GetInnerEventListener(mOnUploadProgressListener,
16665:                                             aOnuploadprogress);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::SetOnuploadprogress(nsIDOMEventListener * aOnuploadprogress)
    1: {
16665:   return
16665:     nsXHREventTarget::RemoveAddEventListener(NS_LITERAL_STRING(UPLOADPROGRESS_STR),
16664:                                              mOnUploadProgressListener,
16664:                                              aOnuploadprogress);
    1: }
    1: 
    1: /* readonly attribute nsIChannel channel; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetChannel(nsIChannel **aChannel)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aChannel);
    1:   NS_IF_ADDREF(*aChannel = mChannel);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIDOMDocument responseXML; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetResponseXML(nsIDOMDocument **aResponseXML)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResponseXML);
    1:   *aResponseXML = nsnull;
20331:   if ((XML_HTTP_REQUEST_COMPLETED & mState) && mResponseXML) {
20331:     *aResponseXML = mResponseXML;
    1:     NS_ADDREF(*aResponseXML);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * This piece copied from nsXMLDocument, we try to get the charset
    1:  * from HTTP headers.
    1:  */
    1: nsresult
    1: nsXMLHttpRequest::DetectCharset(nsACString& aCharset)
    1: {
    1:   aCharset.Truncate();
    1:   nsresult rv;
    1:   nsCAutoString charsetVal;
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(mReadRequest));
    1:   if (!channel) {
    1:     channel = mChannel;
    1:     if (!channel) {
    1:       // There will be no mChannel when we got a necko error in
    1:       // OnStopRequest or if we were never sent.
    1:       return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1:   }
    1: 
    1:   rv = channel->GetContentCharset(charsetVal);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsICharsetAlias> calias(do_GetService(NS_CHARSETALIAS_CONTRACTID,&rv));
    1:     if(NS_SUCCEEDED(rv) && calias) {
    1:       rv = calias->GetPreferred(charsetVal, aCharset);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsXMLHttpRequest::ConvertBodyToText(nsAString& aOutBuffer)
    1: {
    1:   // This code here is basically a copy of a similar thing in
    1:   // nsScanner::Append(const char* aBuffer, PRUint32 aLen).
    1:   // If we get illegal characters in the input we replace
    1:   // them and don't just fail.
    1: 
    1:   PRInt32 dataLen = mResponseBody.Length();
    1:   if (!dataLen)
    1:     return NS_OK;
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsCAutoString dataCharset;
20331:   nsCOMPtr<nsIDocument> document(do_QueryInterface(mResponseXML));
    1:   if (document) {
18503:     dataCharset = document->GetDocumentCharacterSet();
    1:   } else {
    1:     if (NS_FAILED(DetectCharset(dataCharset)) || dataCharset.IsEmpty()) {
    1:       // MS documentation states UTF-8 is default for responseText
    1:       dataCharset.AssignLiteral("UTF-8");
    1:     }
    1:   }
    1: 
    1:   if (dataCharset.EqualsLiteral("ASCII")) {
    1:     CopyASCIItoUTF16(mResponseBody, aOutBuffer);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsICharsetConverterManager> ccm =
    1:     do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIUnicodeDecoder> decoder;
    1:   rv = ccm->GetUnicodeDecoderRaw(dataCharset.get(),
    1:                                  getter_AddRefs(decoder));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   const char * inBuffer = mResponseBody.get();
    1:   PRInt32 outBufferLength;
    1:   rv = decoder->GetMaxLength(inBuffer, dataLen, &outBufferLength);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   PRUnichar * outBuffer =
 3233:     static_cast<PRUnichar*>(nsMemory::Alloc((outBufferLength + 1) *
    1:                                                sizeof(PRUnichar)));
    1:   if (!outBuffer) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   PRInt32 totalChars = 0,
    1:           outBufferIndex = 0,
    1:           outLen = outBufferLength;
    1: 
    1:   do {
    1:     PRInt32 inBufferLength = dataLen;
    1:     rv = decoder->Convert(inBuffer,
    1:                           &inBufferLength,
    1:                           &outBuffer[outBufferIndex],
    1:                           &outLen);
    1:     totalChars += outLen;
    1:     if (NS_FAILED(rv)) {
    1:       // We consume one byte, replace it with U+FFFD
    1:       // and try the conversion again.
    1:       outBuffer[outBufferIndex + outLen++] = (PRUnichar)0xFFFD;
    1:       outBufferIndex += outLen;
    1:       outLen = outBufferLength - (++totalChars);
    1: 
    1:       decoder->Reset();
    1: 
    1:       if((inBufferLength + 1) > dataLen) {
    1:         inBufferLength = dataLen;
    1:       } else {
    1:         inBufferLength++;
    1:       }
    1: 
    1:       inBuffer = &inBuffer[inBufferLength];
    1:       dataLen -= inBufferLength;
    1:     }
    1:   } while ( NS_FAILED(rv) && (dataLen > 0) );
    1: 
    1:   aOutBuffer.Assign(outBuffer, totalChars);
    1:   nsMemory::Free(outBuffer);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute AString responseText; */
    1: NS_IMETHODIMP nsXMLHttpRequest::GetResponseText(nsAString& aResponseText)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   aResponseText.Truncate();
    1: 
    1:   if (mState & (XML_HTTP_REQUEST_COMPLETED |
    1:                 XML_HTTP_REQUEST_INTERACTIVE)) {
    1:     rv = ConvertBodyToText(aResponseText);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* readonly attribute unsigned long status; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetStatus(PRUint32 *aStatus)
    1: {
19952:   *aStatus = 0;
19952: 
19952:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
19952:     // Make sure we don't leak status information from denied cross-site
19952:     // requests.
19952:     if (mChannel) {
19952:       nsresult status;
19952:       mChannel->GetStatus(&status);
19952:       if (NS_FAILED(status)) {
19952:         return NS_OK;
19952:       }
19952:     }
19952:   }
19952: 
    1:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
    1: 
    1:   if (httpChannel) {
    1:     nsresult rv = httpChannel->GetResponseStatus(aStatus);
    1:     if (rv == NS_ERROR_NOT_AVAILABLE) {
    1:       // Someone's calling this before we got a response... Check our
    1:       // ReadyState.  If we're at 3 or 4, then this means the connection
13465:       // errored before we got any data; return 0 in that case.
    1:       PRInt32 readyState;
    1:       GetReadyState(&readyState);
    1:       if (readyState >= 3) {
13465:         *aStatus = 0;
    1:         return NS_OK;
    1:       }
    1:     }
    1: 
    1:     return rv;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute AUTF8String statusText; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetStatusText(nsACString& aStatusText)
    1: {
    1:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
    1: 
    1:   aStatusText.Truncate();
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (httpChannel) {
    1:     rv = httpChannel->GetResponseStatusText(aStatusText);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* void abort (); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::Abort()
    1: {
    1:   if (mReadRequest) {
    1:     mReadRequest->Cancel(NS_BINDING_ABORTED);
    1:   }
    1:   if (mChannel) {
    1:     mChannel->Cancel(NS_BINDING_ABORTED);
    1:   }
20560:   if (mACGetChannel) {
20560:     mACGetChannel->Cancel(NS_BINDING_ABORTED);
19951:   }
20331:   mResponseXML = nsnull;
20640:   PRUint32 responseLength = mResponseBody.Length();
11304:   mResponseBody.Truncate();
    1:   mState |= XML_HTTP_REQUEST_ABORTED;
    1: 
11304:   if (!(mState & (XML_HTTP_REQUEST_UNINITIALIZED |
11304:                   XML_HTTP_REQUEST_OPENED |
11304:                   XML_HTTP_REQUEST_COMPLETED))) {
16664:     ChangeState(XML_HTTP_REQUEST_COMPLETED, PR_TRUE);
11304:   }
    1: 
16665:   if (!(mState & XML_HTTP_REQUEST_SYNCLOOPING)) {
16665:     NS_NAMED_LITERAL_STRING(abortStr, ABORT_STR);
20640:     DispatchProgressEvent(this, abortStr, mLoadLengthComputable, responseLength,
20640:                           mLoadTotal);
16665:     if (mUpload && !mUploadComplete) {
16665:       mUploadComplete = PR_TRUE;
16665:       DispatchProgressEvent(mUpload, abortStr, PR_TRUE, mUploadTransferred,
16665:                             mUploadTotal);
16665:     }
16665:   }
16665: 
    1:   // The ChangeState call above calls onreadystatechange handlers which
    1:   // if they load a new url will cause nsXMLHttpRequest::OpenRequest to clear
    1:   // the abort state bit. If this occurs we're not uninitialized (bug 361773).
    1:   if (mState & XML_HTTP_REQUEST_ABORTED) {
    1:     ChangeState(XML_HTTP_REQUEST_UNINITIALIZED, PR_FALSE);  // IE seems to do it
    1:   }
    1: 
18378:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
18378: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* string getAllResponseHeaders (); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetAllResponseHeaders(char **_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1:   *_retval = nsnull;
    1: 
19951:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
19951:     return NS_OK;
19951:   }
19951: 
    1:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
    1: 
    1:   if (httpChannel) {
    1:     nsHeaderVisitor *visitor = nsnull;
    1:     NS_NEWXPCOM(visitor, nsHeaderVisitor);
    1:     if (!visitor)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(visitor);
    1: 
    1:     nsresult rv = httpChannel->VisitResponseHeaders(visitor);
    1:     if (NS_SUCCEEDED(rv))
    1:       *_retval = ToNewCString(visitor->Headers());
    1: 
    1:     NS_RELEASE(visitor);
    1:     return rv;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* ACString getResponseHeader (in AUTF8String header); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetResponseHeader(const nsACString& header,
    1:                                     nsACString& _retval)
    1: {
    1:   nsresult rv = NS_OK;
    1:   _retval.Truncate();
    1: 
21639:   // See bug #380418. Hide "Set-Cookie" headers from non-chrome scripts.
21639:   PRBool chrome = PR_FALSE; // default to false in case IsCapabilityEnabled fails
21639:   IsCapabilityEnabled("UniversalXPConnect", &chrome);
21639:   if (!chrome &&
21639:        (header.LowerCaseEqualsASCII("set-cookie") ||
21639:         header.LowerCaseEqualsASCII("set-cookie2"))) {
21639:     NS_WARNING("blocked access to response header");
21639:     _retval.SetIsVoid(PR_TRUE);
21639:     return NS_OK;
21639:   }
21639: 
19951:   // Check for dangerous headers
19951:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
19951:     
19951:     // Make sure we don't leak header information from denied cross-site
19951:     // requests.
19951:     if (mChannel) {
19951:       nsresult status;
19951:       mChannel->GetStatus(&status);
19951:       if (NS_FAILED(status)) {
19951:         return NS_OK;
19951:       }
19951:     }
19951: 
19951:     const char *kCrossOriginSafeHeaders[] = {
19951:       "cache-control", "content-language", "content-type", "expires",
19951:       "last-modified", "pragma"
19951:     };
19951:     PRBool safeHeader = PR_FALSE;
19951:     PRUint32 i;
19951:     for (i = 0; i < NS_ARRAY_LENGTH(kCrossOriginSafeHeaders); ++i) {
19951:       if (header.LowerCaseEqualsASCII(kCrossOriginSafeHeaders[i])) {
19951:         safeHeader = PR_TRUE;
19951:         break;
19951:       }
19951:     }
19951: 
19951:     if (!safeHeader) {
19951:       return NS_OK;
19951:     }
19951:   }
19951: 
    1:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
    1: 
    1:   if (httpChannel) {
    1:     rv = httpChannel->GetResponseHeader(header, _retval);
    1:   }
    1: 
    1:   if (rv == NS_ERROR_NOT_AVAILABLE) {
    1:     // Means no header
    1:     _retval.SetIsVoid(PR_TRUE);
    1:     rv = NS_OK;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
20560: nsXMLHttpRequest::GetLoadGroup(nsILoadGroup **aLoadGroup)
20560: {
20560:   NS_ENSURE_ARG_POINTER(aLoadGroup);
20560:   *aLoadGroup = nsnull;
20560: 
20560:   if (mState & XML_HTTP_REQUEST_BACKGROUND) {
20560:     return NS_OK;
20560:   }
20560: 
29226:   nsCOMPtr<nsIDocument> doc =
29226:     nsContentUtils::GetDocumentFromScriptContext(mScriptContext);
20560:   if (doc) {
20560:     *aLoadGroup = doc->GetDocumentLoadGroup().get();  // already_AddRefed
20560:   }
20560: 
20560:   return NS_OK;
20560: }
20560: 
20560: nsresult
16665: nsXMLHttpRequest::CreateReadystatechangeEvent(nsIDOMEvent** aDOMEvent)
    1: {
    1:   nsresult rv = nsEventDispatcher::CreateEvent(nsnull, nsnull,
    1:                                                NS_LITERAL_STRING("Events"),
    1:                                                aDOMEvent);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privevent(do_QueryInterface(*aDOMEvent));
    1:   if (!privevent) {
    1:     NS_IF_RELEASE(*aDOMEvent);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
16665:   (*aDOMEvent)->InitEvent(NS_LITERAL_STRING(READYSTATE_STR),
16665:                           PR_FALSE, PR_FALSE);
16665: 
16665:   // We assume anyone who managed to call CreateReadystatechangeEvent is trusted
16665:   privevent->SetTrusted(PR_TRUE);
16665: 
16665:   return NS_OK;
    1: }
    1: 
16665: void
16665: nsXMLHttpRequest::DispatchProgressEvent(nsPIDOMEventTarget* aTarget,
16665:                                         const nsAString& aType,
16665:                                         PRBool aUseLSEventWrapper,
16665:                                         PRBool aLengthComputable,
16665:                                         PRUint64 aLoaded, PRUint64 aTotal,
16665:                                         PRUint64 aPosition, PRUint64 aTotalSize)
16665: {
19953:   NS_ASSERTION(aTarget, "null target");
19953:   if (aType.IsEmpty() ||
19953:       (!AllowUploadProgress() &&
19953:        (aTarget == mUpload || aType.EqualsLiteral(UPLOADPROGRESS_STR)))) {
16665:     return;
16665:   }
16665: 
16665:   nsCOMPtr<nsIDOMEvent> event;
16665:   nsresult rv = nsEventDispatcher::CreateEvent(nsnull, nsnull,
16665:                                                NS_LITERAL_STRING("ProgressEvent"),
16665:                                                getter_AddRefs(event));
16665:   if (NS_FAILED(rv)) {
16665:     return;
16665:   }
16665: 
16665:   nsCOMPtr<nsIPrivateDOMEvent> privevent(do_QueryInterface(event));
16665:   if (!privevent) {
16665:     return;
16665:   }
    1:   privevent->SetTrusted(PR_TRUE);
    1: 
16665:   nsCOMPtr<nsIDOMProgressEvent> progress = do_QueryInterface(event);
16665:   if (!progress) {
16665:     return;
16665:   }
16665: 
16665:   progress->InitProgressEvent(aType, PR_FALSE, PR_FALSE, aLengthComputable,
16665:                               aLoaded, (aTotal == LL_MAXUINT) ? 0 : aTotal);
16665: 
16665:   if (aUseLSEventWrapper) {
16665:     nsCOMPtr<nsIDOMProgressEvent> xhrprogressEvent =
16665:       new nsXMLHttpProgressEvent(progress, aPosition, aTotalSize);
16665:     if (!xhrprogressEvent) {
16665:       return;
16665:     }
16665:     event = xhrprogressEvent;
16665:   }
16665:   aTarget->DispatchDOMEvent(nsnull, event, nsnull, nsnull);
    1: }
    1: 
    1: already_AddRefed<nsIHttpChannel>
    1: nsXMLHttpRequest::GetCurrentHttpChannel()
    1: {
    1:   nsIHttpChannel *httpChannel = nsnull;
    1: 
    1:   if (mReadRequest) {
    1:     CallQueryInterface(mReadRequest, &httpChannel);
    1:   }
    1: 
    1:   if (!httpChannel && mChannel) {
    1:     CallQueryInterface(mChannel, &httpChannel);
    1:   }
    1: 
    1:   return httpChannel;
    1: }
    1: 
11887: inline PRBool
11887: IsSystemPrincipal(nsIPrincipal* aPrincipal)
11887: {
11887:   PRBool isSystem = PR_FALSE;
11887:   nsContentUtils::GetSecurityManager()->
11887:     IsSystemPrincipal(aPrincipal, &isSystem);
11887:   return isSystem;
11887: }
11887: 
 4064: static PRBool
19951: CheckMayLoad(nsIPrincipal* aPrincipal, nsIChannel* aChannel)
 4064: {
11887:   NS_ASSERTION(!IsSystemPrincipal(aPrincipal), "Shouldn't get here!");
 4106: 
21937:   nsCOMPtr<nsIURI> channelURI, originalURI;
19951:   nsresult rv = aChannel->GetURI(getter_AddRefs(channelURI));
11494:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
21937:   rv = aChannel->GetOriginalURI(getter_AddRefs(originalURI));
21937:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
 4064: 
19951:   rv = aPrincipal->CheckMayLoad(channelURI, PR_FALSE);
21937:   if (NS_SUCCEEDED(rv) && originalURI != channelURI) {
21937:     rv = aPrincipal->CheckMayLoad(originalURI, PR_FALSE);
21937:   }
 4064:   return NS_SUCCEEDED(rv);
 4064: }
 4064: 
19951: nsresult
19951: nsXMLHttpRequest::CheckChannelForCrossSiteRequest(nsIChannel* aChannel)
19951: {
25455:   nsresult rv;
25455: 
19951:   // First check if this is a same-origin request, or if cross-site requests
19951:   // are enabled.
19951:   if ((mState & XML_HTTP_REQUEST_XSITEENABLED) ||
19951:       CheckMayLoad(mPrincipal, aChannel)) {
19951:     return NS_OK;
19951:   }
19951: 
19951:   // This is a cross-site request
19951:   mState |= XML_HTTP_REQUEST_USE_XSITE_AC;
19951: 
25455:   // Check if we need to do a preflight request.
25455:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aChannel);
25455:   NS_ENSURE_TRUE(httpChannel, NS_ERROR_DOM_BAD_URI);
25455:     
25455:   nsCAutoString method;
25455:   httpChannel->GetRequestMethod(method);
25455:   if (!mACUnsafeHeaders.IsEmpty() ||
25455:       HasListenersFor(NS_LITERAL_STRING(UPLOADPROGRESS_STR)) ||
25455:       (mUpload && mUpload->HasListeners())) {
25455:     mState |= XML_HTTP_REQUEST_NEED_AC_PREFLIGHT;
25455:   }
25455:   else if (method.LowerCaseEqualsLiteral("post")) {
25455:     nsCAutoString contentTypeHeader;
25455:     httpChannel->GetRequestHeader(NS_LITERAL_CSTRING("Content-Type"),
25455:                                   contentTypeHeader);
25455: 
25455:     nsCAutoString contentType, charset;
25455:     rv = NS_ParseContentType(contentTypeHeader, contentType, charset);
25455:     NS_ENSURE_SUCCESS(rv, rv);
25455: 
25455:     if (!contentType.LowerCaseEqualsLiteral("text/plain")) {
25455:       mState |= XML_HTTP_REQUEST_NEED_AC_PREFLIGHT;
25455:     }
25455:   }
25455:   else if (!method.LowerCaseEqualsLiteral("get") &&
25455:            !method.LowerCaseEqualsLiteral("head")) {
25455:     mState |= XML_HTTP_REQUEST_NEED_AC_PREFLIGHT;
25455:   }
25455: 
19951:   return NS_OK;
19951: }
19951: 
    1: /* noscript void openRequest (in AUTF8String method, in AUTF8String url, in boolean async, in AString user, in AString password); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OpenRequest(const nsACString& method,
    1:                               const nsACString& url,
    1:                               PRBool async,
    1:                               const nsAString& user,
    1:                               const nsAString& password)
    1: {
    1:   NS_ENSURE_ARG(!method.IsEmpty());
    1:   NS_ENSURE_ARG(!url.IsEmpty());
    1: 
11887:   NS_ENSURE_TRUE(mPrincipal, NS_ERROR_NOT_INITIALIZED);
11887: 
 2795:   // Disallow HTTP/1.1 TRACE method (see bug 302489)
 2795:   // and MS IIS equivalent TRACK (see bug 381264)
 4064:   if (method.LowerCaseEqualsLiteral("trace") ||
 4064:       method.LowerCaseEqualsLiteral("track")) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIURI> uri;
    1:   PRBool authp = PR_FALSE;
    1: 
 8067:   if (mState & (XML_HTTP_REQUEST_OPENED |
    1:                 XML_HTTP_REQUEST_LOADED |
    1:                 XML_HTTP_REQUEST_INTERACTIVE |
    1:                 XML_HTTP_REQUEST_SENT |
    1:                 XML_HTTP_REQUEST_STOPPED)) {
    1:     // IE aborts as well
    1:     Abort();
    1: 
    1:     // XXX We should probably send a warning to the JS console
    1:     //     that load was aborted and event listeners were cleared
    1:     //     since this looks like a situation that could happen
    1:     //     by accident and you could spend a lot of time wondering
    1:     //     why things didn't work.
 8067:   }
 8067: 
 8067:   if (mState & XML_HTTP_REQUEST_ABORTED) {
 8067:     // Something caused this request to abort (e.g the current request
 8067:     // was caceled, channels closed etc), most likely the abort()
 8067:     // function was called by script. Unset our aborted state, and
 8067:     // proceed as normal
 8067: 
 8067:     mState &= ~XML_HTTP_REQUEST_ABORTED;
    1:   }
    1: 
    1:   if (async) {
    1:     mState |= XML_HTTP_REQUEST_ASYNC;
    1:   } else {
    1:     mState &= ~XML_HTTP_REQUEST_ASYNC;
    1:   }
    1: 
19152:   mState &= ~XML_HTTP_REQUEST_MPART_HEADERS;
19152: 
29226:   nsCOMPtr<nsIDocument> doc =
29226:     nsContentUtils::GetDocumentFromScriptContext(mScriptContext);
20331:   
20331:   nsCOMPtr<nsIURI> baseURI;
23201:   if (mBaseURI) {
23201:     baseURI = mBaseURI;
23201:   }
23201:   else if (doc) {
20331:     baseURI = doc->GetBaseURI();
20331:   }
20331: 
20331:   rv = NS_NewURI(getter_AddRefs(uri), url, nsnull, baseURI);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
   68:   // mScriptContext should be initialized because of GetBaseURI() above.
   68:   // Still need to consider the case that doc is nsnull however.
 8947:   rv = CheckInnerWindowCorrectness();
 8947:   NS_ENSURE_SUCCESS(rv, rv);
   68:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
 2501:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_XMLHTTPREQUEST,
   68:                                  uri,
 8947:                                  mPrincipal,
   68:                                  doc,
   68:                                  EmptyCString(), //mime guess
   68:                                  nsnull,         //extra
 4367:                                  &shouldLoad,
 4367:                                  nsContentUtils::GetContentPolicy(),
 4367:                                  nsContentUtils::GetSecurityManager());
   68:   if (NS_FAILED(rv)) return rv;
   68:   if (NS_CP_REJECTED(shouldLoad)) {
   68:     // Disallowed by content policy
   68:     return NS_ERROR_CONTENT_BLOCKED;
   68:   }
   68: 
    1:   if (!user.IsEmpty()) {
    1:     nsCAutoString userpass;
    1:     CopyUTF16toUTF8(user, userpass);
    1:     if (!password.IsEmpty()) {
    1:       userpass.Append(':');
    1:       AppendUTF16toUTF8(password, userpass);
    1:     }
    1:     uri->SetUserPass(userpass);
    1:     authp = PR_TRUE;
    1:   }
    1: 
20560:   // When we are called from JS we can find the load group for the page,
20560:   // and add ourselves to it. This way any pending requests
20560:   // will be automatically aborted if the user leaves the page.
    1:   nsCOMPtr<nsILoadGroup> loadGroup;
20560:   GetLoadGroup(getter_AddRefs(loadGroup));
    1: 
    1:   // nsIRequest::LOAD_BACKGROUND prevents throbber from becoming active, which
    1:   // in turn keeps STOP button from becoming active.  If the consumer passed in
    1:   // a progress event handler we must load with nsIRequest::LOAD_NORMAL or
    1:   // necko won't generate any progress notifications
    1:   nsLoadFlags loadFlags;
16665:   if (HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR)) ||
16665:       HasListenersFor(NS_LITERAL_STRING(UPLOADPROGRESS_STR)) ||
16665:       (mUpload && mUpload->HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR)))) {
    1:     loadFlags = nsIRequest::LOAD_NORMAL;
    1:   } else {
    1:     loadFlags = nsIRequest::LOAD_BACKGROUND;
    1:   }
    1:   rv = NS_NewChannel(getter_AddRefs(mChannel), uri, nsnull, loadGroup, nsnull,
    1:                      loadFlags);
20560:   if (NS_FAILED(rv)) return rv;
    1: 
 4064:   // Check if we're doing a cross-origin request.
11887:   if (IsSystemPrincipal(mPrincipal)) {
11887:     // Chrome callers are always allowed to read from different origins.
11887:     mState |= XML_HTTP_REQUEST_XSITEENABLED;
11887:   }
 4064: 
25455:   mState &= ~(XML_HTTP_REQUEST_USE_XSITE_AC |
25455:               XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
25455: 
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
    1:   if (httpChannel) {
    1:     rv = httpChannel->SetRequestMethod(method);
 4064:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   ChangeState(XML_HTTP_REQUEST_OPENED);
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* void open (in AUTF8String method, in AUTF8String url); */
    1: NS_IMETHODIMP
34226: nsXMLHttpRequest::Open(const nsACString& method, const nsACString& url,
34226:                        PRBool async, const nsAString& user,
34226:                        const nsAString& password, PRUint8 optional_argc)
    1: {
34226:   if (nsContentUtils::GetCurrentJSContext()) {
34226:     // We're (likely) called from JS
    1: 
    1:     // Find out if UniversalBrowserRead privileges are enabled
14095:     if (nsContentUtils::IsCallerTrustedForRead()) {
    1:       mState |= XML_HTTP_REQUEST_XSITEENABLED;
    1:     } else {
    1:       mState &= ~XML_HTTP_REQUEST_XSITEENABLED;
    1:     }
34226:   }
34226: 
34226:   if (!optional_argc) {
34226:     // No optional arguments were passed in. Default async to true.
34226:     async = PR_TRUE;
    1:   }
    1: 
    1:   return OpenRequest(method, url, async, user, password);
    1: }
    1: 
    1: /*
    1:  * "Copy" from a stream.
    1:  */
    1: NS_METHOD
    1: nsXMLHttpRequest::StreamReaderFunc(nsIInputStream* in,
    1:                                    void* closure,
    1:                                    const char* fromRawSegment,
    1:                                    PRUint32 toOffset,
    1:                                    PRUint32 count,
    1:                                    PRUint32 *writeCount)
    1: {
 3233:   nsXMLHttpRequest* xmlHttpRequest = static_cast<nsXMLHttpRequest*>(closure);
    1:   if (!xmlHttpRequest || !writeCount) {
    1:     NS_WARNING("XMLHttpRequest cannot read from stream: no closure or writeCount");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Copy for our own use
    1:   xmlHttpRequest->mResponseBody.Append(fromRawSegment,count);
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (xmlHttpRequest->mState & XML_HTTP_REQUEST_PARSEBODY) {
    1:     // Give the same data to the parser.
    1: 
    1:     // We need to wrap the data in a new lightweight stream and pass that
    1:     // to the parser, because calling ReadSegments() recursively on the same
    1:     // stream is not supported.
    1:     nsCOMPtr<nsIInputStream> copyStream;
    1:     rv = NS_NewByteInputStream(getter_AddRefs(copyStream), fromRawSegment, count);
    1: 
29232:     if (NS_SUCCEEDED(rv) && xmlHttpRequest->mXMLParserStreamListener) {
    1:       NS_ASSERTION(copyStream, "NS_NewByteInputStream lied");
    1:       nsresult parsingResult = xmlHttpRequest->mXMLParserStreamListener
    1:                                   ->OnDataAvailable(xmlHttpRequest->mReadRequest,
    1:                                                     xmlHttpRequest->mContext,
    1:                                                     copyStream, toOffset, count);
    1: 
    1:       // No use to continue parsing if we failed here, but we
    1:       // should still finish reading the stream
    1:       if (NS_FAILED(parsingResult)) {
    1:         xmlHttpRequest->mState &= ~XML_HTTP_REQUEST_PARSEBODY;
    1:       }
    1:     }
    1:   }
    1: 
    1:   xmlHttpRequest->ChangeState(XML_HTTP_REQUEST_INTERACTIVE);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     *writeCount = count;
    1:   } else {
    1:     *writeCount = 0;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* void onDataAvailable (in nsIRequest request, in nsISupports ctxt, in nsIInputStream inStr, in unsigned long sourceOffset, in unsigned long count); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnDataAvailable(nsIRequest *request, nsISupports *ctxt, nsIInputStream *inStr, PRUint32 sourceOffset, PRUint32 count)
    1: {
    1:   NS_ENSURE_ARG_POINTER(inStr);
    1: 
    1:   NS_ABORT_IF_FALSE(mContext.get() == ctxt,"start context different from OnDataAvailable context");
    1: 
    1:   PRUint32 totalRead;
    1:   return inStr->ReadSegments(nsXMLHttpRequest::StreamReaderFunc, (void*)this, count, &totalRead);
    1: }
    1: 
 5746: PRBool
 5746: IsSameOrBaseChannel(nsIRequest* aPossibleBase, nsIChannel* aChannel)
 5746: {
 5746:   nsCOMPtr<nsIMultiPartChannel> mpChannel = do_QueryInterface(aPossibleBase);
 5746:   if (mpChannel) {
 5746:     nsCOMPtr<nsIChannel> baseChannel;
 5746:     nsresult rv = mpChannel->GetBaseChannel(getter_AddRefs(baseChannel));
 5746:     NS_ENSURE_SUCCESS(rv, PR_FALSE);
 5746:     
 5746:     return baseChannel == aChannel;
 5746:   }
 5746: 
 5746:   return aPossibleBase == aChannel;
 5746: }
 5746: 
    1: /* void onStartRequest (in nsIRequest request, in nsISupports ctxt); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
    1: {
20640:   nsresult rv = NS_OK;
19944:   if (!mFirstStartRequestSeen && mRequestObserver) {
19944:     mFirstStartRequestSeen = PR_TRUE;
19944:     mRequestObserver->OnStartRequest(request, ctxt);
19944:   }
19944: 
 5746:   if (!IsSameOrBaseChannel(request, mChannel)) {
 5746:     return NS_OK;
 5746:   }
 5746: 
    1:   // Don't do anything if we have been aborted
    1:   if (mState & XML_HTTP_REQUEST_UNINITIALIZED)
    1:     return NS_OK;
    1: 
    1:   if (mState & XML_HTTP_REQUEST_ABORTED) {
    1:     NS_ERROR("Ugh, still getting data on an aborted XMLHttpRequest!");
    1: 
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
    1:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
    1: 
13653:   nsCOMPtr<nsIPrincipal> documentPrincipal = mPrincipal;
13653:   if (IsSystemPrincipal(documentPrincipal)) {
13653:     // Don't give this document the system principal.  We need to keep track of
13653:     // mPrincipal being system because we use it for various security checks
13653:     // that should be passing, but the document data shouldn't get a system
13653:     // principal.
13653:     nsresult rv;
13653:     documentPrincipal = do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
13653:     NS_ENSURE_SUCCESS(rv, rv);
13653:   }
13653: 
13653:   channel->SetOwner(documentPrincipal);
 3028: 
    1:   mReadRequest = request;
    1:   mContext = ctxt;
    1:   mState |= XML_HTTP_REQUEST_PARSEBODY;
19152:   mState &= ~XML_HTTP_REQUEST_MPART_HEADERS;
    1:   ChangeState(XML_HTTP_REQUEST_LOADED);
    1: 
    1:   nsresult status;
    1:   request->GetStatus(&status);
16665:   mErrorLoad = mErrorLoad || NS_FAILED(status);
16665: 
25722:   if (mUpload && !mUploadComplete && !mErrorLoad &&
25722:       (mState & XML_HTTP_REQUEST_ASYNC)) {
16665:     mUploadComplete = PR_TRUE;
16665:     DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOAD_STR),
16665:                           PR_TRUE, mUploadTotal, mUploadTotal);
16665:   }
    1: 
20331:   // Reset responseBody
20331:   mResponseBody.Truncate();
20331: 
20331:   // Set up responseXML
    1:   PRBool parseBody = PR_TRUE;
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
    1:   if (httpChannel) {
    1:     nsCAutoString method;
    1:     httpChannel->GetRequestMethod(method);
    1:     parseBody = !method.EqualsLiteral("HEAD");
    1:   }
    1: 
    1:   if (parseBody && NS_SUCCEEDED(status)) {
    1:     if (!mOverrideMimeType.IsEmpty()) {
    1:       channel->SetContentType(mOverrideMimeType);
    1:     }
    1: 
    1:     // We can gain a huge performance win by not even trying to
    1:     // parse non-XML data. This also protects us from the situation
    1:     // where we have an XML document and sink, but HTML (or other)
    1:     // parser, which can produce unreliable results.
    1:     nsCAutoString type;
    1:     channel->GetContentType(type);
    1: 
    1:     if (type.Find("xml") == kNotFound) {
    1:       mState &= ~XML_HTTP_REQUEST_PARSEBODY;
    1:     }
    1:   } else {
    1:     // The request failed, so we shouldn't be parsing anyway
    1:     mState &= ~XML_HTTP_REQUEST_PARSEBODY;
    1:   }
    1: 
    1:   if (mState & XML_HTTP_REQUEST_PARSEBODY) {
20331:     nsCOMPtr<nsIURI> baseURI, docURI;
29226:     nsCOMPtr<nsIDocument> doc =
29226:       nsContentUtils::GetDocumentFromScriptContext(mScriptContext);
20331: 
20331:     if (doc) {
20331:       docURI = doc->GetDocumentURI();
20331:       baseURI = doc->GetBaseURI();
20331:     }
20331: 
20331:     // Create an empty document from it.  Here we have to cheat a little bit...
20331:     // Setting the base URI to |baseURI| won't work if the document has a null
20331:     // principal, so use mPrincipal when creating the document, then reset the
20331:     // principal.
20331:     const nsAString& emptyStr = EmptyString();
20331:     nsCOMPtr<nsIScriptGlobalObject> global = do_QueryInterface(mOwner);
20331:     rv = nsContentUtils::CreateDocument(emptyStr, emptyStr, nsnull, docURI,
20331:                                         baseURI, mPrincipal, global,
20331:                                         getter_AddRefs(mResponseXML));
20331:     NS_ENSURE_SUCCESS(rv, rv);
20331:     nsCOMPtr<nsIDocument> responseDoc = do_QueryInterface(mResponseXML);
20331:     responseDoc->SetPrincipal(documentPrincipal);
20331: 
20331:     if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
20331:       nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mResponseXML);
20331:       if (htmlDoc) {
20331:         htmlDoc->DisableCookieAccess();
20331:       }
20331:     }
20331: 
20331:     // Register as a load listener on the document
20331:     nsCOMPtr<nsPIDOMEventTarget> target(do_QueryInterface(mResponseXML));
20331:     if (target) {
20331:       nsWeakPtr requestWeak =
20331:         do_GetWeakReference(static_cast<nsIXMLHttpRequest*>(this));
20331:       nsCOMPtr<nsIDOMEventListener> proxy = new nsLoadListenerProxy(requestWeak);
20331:       if (!proxy) return NS_ERROR_OUT_OF_MEMORY;
20331: 
20331:       // This will addref the proxy
20331:       rv = target->AddEventListenerByIID(static_cast<nsIDOMEventListener*>
20331:                                                     (proxy),
20331:                                          NS_GET_IID(nsIDOMLoadListener));
20331:       NS_ENSURE_SUCCESS(rv, rv);
20331:     }
20331: 
20331: 
20331: 
    1:     nsCOMPtr<nsIStreamListener> listener;
    1:     nsCOMPtr<nsILoadGroup> loadGroup;
    1:     channel->GetLoadGroup(getter_AddRefs(loadGroup));
    1: 
20331:     rv = responseDoc->StartDocumentLoad(kLoadAsData, channel, loadGroup,
20331:                                         nsnull, getter_AddRefs(listener),
20331:                                         !(mState & XML_HTTP_REQUEST_USE_XSITE_AC));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     mXMLParserStreamListener = listener;
20331:     rv = mXMLParserStreamListener->OnStartRequest(request, ctxt);
20331:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
20640:   // We won't get any progress events anyway if we didn't have progress
20640:   // events when starting the request - so maybe no need to start timer here.
20640:   if (NS_SUCCEEDED(rv) &&
20640:       (mState & XML_HTTP_REQUEST_ASYNC) &&
20640:       HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR))) {
20640:     StartProgressEventTimer();
20640:   }
20640: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onStopRequest (in nsIRequest request, in nsISupports ctxt, in nsresult status, in wstring statusArg); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult status)
    1: {
 5746:   if (!IsSameOrBaseChannel(request, mChannel)) {
 5746:     return NS_OK;
 5746:   }
 5746: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // If we're loading a multipart stream of XML documents, we'll get
    1:   // an OnStopRequest() for the last part in the stream, and then
    1:   // another one for the end of the initiating
    1:   // "multipart/x-mixed-replace" stream too. So we must check that we
    1:   // still have an xml parser stream listener before accessing it
    1:   // here.
 4106:   nsCOMPtr<nsIMultiPartChannel> mpChannel = do_QueryInterface(request);
 4106:   if (mpChannel) {
 4106:     PRBool last;
 4106:     rv = mpChannel->GetIsLastPart(&last);
 4106:     NS_ENSURE_SUCCESS(rv, rv);
 4106:     if (last) {
 4106:       mState |= XML_HTTP_REQUEST_GOT_FINAL_STOP;
 4106:     }
 4106:   }
 4106:   else {
 4106:     mState |= XML_HTTP_REQUEST_GOT_FINAL_STOP;
 4106:   }
 4106: 
22035:   if (mRequestObserver && mState & XML_HTTP_REQUEST_GOT_FINAL_STOP) {
22035:     NS_ASSERTION(mFirstStartRequestSeen, "Inconsistent state!");
22035:     mFirstStartRequestSeen = PR_FALSE;
22035:     mRequestObserver->OnStopRequest(request, ctxt, status);
22035:   }
22035: 
22035:   // Don't do anything if we have been aborted
22035:   if (mState & XML_HTTP_REQUEST_UNINITIALIZED)
22035:     return NS_OK;
22035: 
22035:   nsCOMPtr<nsIParser> parser;
22035: 
22035:   // Is this good enough here?
22035:   if (mState & XML_HTTP_REQUEST_PARSEBODY && mXMLParserStreamListener) {
22035:     parser = do_QueryInterface(mXMLParserStreamListener);
22035:     NS_ABORT_IF_FALSE(parser, "stream listener was expected to be a parser");
22035:     rv = mXMLParserStreamListener->OnStopRequest(request, ctxt, status);
22035:   }
22035: 
    1:   mXMLParserStreamListener = nsnull;
    1:   mReadRequest = nsnull;
    1:   mContext = nsnull;
    1: 
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
    1:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
    1: 
    1:   channel->SetNotificationCallbacks(nsnull);
    1:   mNotificationCallbacks = nsnull;
    1:   mChannelEventSink = nsnull;
    1:   mProgressEventSink = nsnull;
    1: 
    1:   if (NS_FAILED(status)) {
    1:     // This can happen if the server is unreachable. Other possible
    1:     // reasons are that the user leaves the page or hits the ESC key.
    1:     Error(nsnull);
    1: 
    1:     // By nulling out channel here we make it so that Send() can test
    1:     // for that and throw. Also calling the various status
    1:     // methods/members will not throw.
    1:     // This matches what IE does.
    1:     mChannel = nsnull;
    1:   } else if (!parser || parser->IsParserEnabled()) {
    1:     // If we don't have a parser, we never attempted to parse the
    1:     // incoming data, and we can proceed to call RequestCompleted().
    1:     // Alternatively, if we do have a parser, its possible that we
    1:     // have given it some data and this caused it to block e.g. by a
    1:     // by a xml-stylesheet PI. In this case, we will have to wait till
    1:     // it gets enabled again and RequestCompleted() must be called
    1:     // later, when we get the load event from the document. If the
    1:     // parser is enabled, it is not blocked and we can still go ahead
    1:     // and call RequestCompleted() and expect everything to get
    1:     // cleaned up immediately.
    1:     RequestCompleted();
    1:   } else {
    1:     ChangeState(XML_HTTP_REQUEST_STOPPED, PR_FALSE);
    1:   }
    1: 
    1:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsXMLHttpRequest::RequestCompleted()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
    1: 
    1:   // If we're uninitialized at this point, we encountered an error
    1:   // earlier and listeners have already been notified. Also we do
    1:   // not want to do this if we already completed.
    1:   if (mState & (XML_HTTP_REQUEST_UNINITIALIZED |
    1:                 XML_HTTP_REQUEST_COMPLETED)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // We might have been sent non-XML data. If that was the case,
    1:   // we should null out the document member. The idea in this
    1:   // check here is that if there is no document element it is not
    1:   // an XML document. We might need a fancier check...
20331:   if (mResponseXML) {
    1:     nsCOMPtr<nsIDOMElement> root;
20331:     mResponseXML->GetDocumentElement(getter_AddRefs(root));
    1:     if (!root) {
20331:       mResponseXML = nsnull;
    1:     }
    1:   }
    1: 
16664:   ChangeState(XML_HTTP_REQUEST_COMPLETED, PR_TRUE);
    1: 
16665:   PRUint32 responseLength = mResponseBody.Length();
16665:   NS_NAMED_LITERAL_STRING(errorStr, ERROR_STR);
16665:   NS_NAMED_LITERAL_STRING(loadStr, LOAD_STR);
16665:   DispatchProgressEvent(this,
16665:                         mErrorLoad ? errorStr : loadStr,
16665:                         !mErrorLoad,
16665:                         responseLength,
16665:                         mErrorLoad ? 0 : responseLength);
16665:   if (mErrorLoad && mUpload && !mUploadComplete) {
16665:     DispatchProgressEvent(mUpload, errorStr, PR_TRUE,
16665:                           mUploadTransferred, mUploadTotal);
    1:   }
    1: 
 4106:   if (!(mState & XML_HTTP_REQUEST_GOT_FINAL_STOP)) {
    1:     // We're a multipart request, so we're not done. Reset to opened.
    1:     ChangeState(XML_HTTP_REQUEST_OPENED);
    1:   }
    1: 
 7093:   nsJSContext::MaybeCC(PR_FALSE);
    1:   return rv;
    1: }
    1: 
 3941: NS_IMETHODIMP
 3941: nsXMLHttpRequest::SendAsBinary(const nsAString &aBody)
 3941: {
 3941:   char *data = static_cast<char*>(NS_Alloc(aBody.Length() + 1));
 3941:   if (!data)
 3941:     return NS_ERROR_OUT_OF_MEMORY;
 3941: 
 3941:   nsAString::const_iterator iter, end;
 3941:   aBody.BeginReading(iter);
 3941:   aBody.EndReading(end);
 3941:   char *p = data;
 3941:   while (iter != end) {
 3941:     if (*iter & 0xFF00) {
 3941:       NS_Free(data);
 3941:       return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
 3941:     }
 3941:     *p++ = static_cast<char>(*iter++);
 3941:   }
 3941:   *p = '\0';
 3941: 
 3941:   nsCOMPtr<nsIInputStream> stream;
 3941:   nsresult rv = NS_NewByteInputStream(getter_AddRefs(stream), data,
 3941:                                       aBody.Length(), NS_ASSIGNMENT_ADOPT);
 3941:   if (NS_FAILED(rv))
 3941:     NS_Free(data);
 3941:   NS_ENSURE_SUCCESS(rv, rv);
 3941: 
 3941:   nsCOMPtr<nsIWritableVariant> variant = new nsVariant();
 3941:   if (!variant) return NS_ERROR_OUT_OF_MEMORY;
 3941: 
 3941:   rv = variant->SetAsISupports(stream);
 3941:   NS_ENSURE_SUCCESS(rv, rv);
 3941: 
 3941:   return Send(variant);
 3941: }
 3941: 
20556: /* void send (in nsIVariant aBody); */
20556: NS_IMETHODIMP
20556: nsXMLHttpRequest::Send(nsIVariant *aBody)
    1: {
20556:   NS_ENSURE_TRUE(mPrincipal, NS_ERROR_NOT_INITIALIZED);
20556: 
20556:   nsresult rv = CheckInnerWindowCorrectness();
20556:   NS_ENSURE_SUCCESS(rv, rv);
20556: 
20556:   // Return error if we're already processing a request
20556:   if (XML_HTTP_REQUEST_SENT & mState) {
20556:     return NS_ERROR_FAILURE;
20556:   }
20556: 
20556:   // Make sure we've been opened
20556:   if (!mChannel || !(XML_HTTP_REQUEST_OPENED & mState)) {
20556:     return NS_ERROR_NOT_INITIALIZED;
20556:   }
20556: 
20556:   // XXX We should probably send a warning to the JS console
20556:   //     if there are no event listeners set and we are doing
20556:   //     an asynchronous call.
20556: 
20556:   // Ignore argument if method is GET, there is no point in trying to
20556:   // upload anything
20556:   nsCAutoString method;
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
20556: 
20556:   if (httpChannel) {
20556:     httpChannel->GetRequestMethod(method); // If GET, method name will be uppercase
20556: 
20556:     if (!IsSystemPrincipal(mPrincipal)) {
20556:       nsCOMPtr<nsIURI> codebase;
20556:       mPrincipal->GetURI(getter_AddRefs(codebase));
20556: 
20556:       httpChannel->SetReferrer(codebase);
20556:     }
35023: 
35023:     // Some extensions override the http protocol handler and provide their own
35023:     // implementation. The channels returned from that implementation doesn't
35023:     // seem to always implement the nsIUploadChannel2 interface, presumably
35023:     // because it's a new interface.
35023:     // Eventually we should remove this and simply require that http channels
35023:     // implement the new interface.
35023:     // See bug 529041
35023:     nsCOMPtr<nsIUploadChannel2> uploadChannel2 =
35023:       do_QueryInterface(httpChannel);
35023:     if (!uploadChannel2) {
35023:       nsCOMPtr<nsIConsoleService> consoleService =
35023:         do_GetService(NS_CONSOLESERVICE_CONTRACTID);
35023:       if (consoleService) {
35023:         consoleService->LogStringMessage(NS_LITERAL_STRING(
35023:           "Http channel implementation doesn't support nsIUploadChannel2. "
35023:           "An extension has supplied a non-functional http protocol handler. "
35023:           "This will break behavior and in future releases not work at all.")
35023:                                          .get());
35023:       }
35023:     }
20556:   }
20556: 
20556:   mUploadTransferred = 0;
20556:   mUploadTotal = 0;
20556:   // By default we don't have any upload, so mark upload complete.
20556:   mUploadComplete = PR_TRUE;
20556:   mErrorLoad = PR_FALSE;
20640:   mLoadLengthComputable = PR_FALSE;
20640:   mLoadTotal = 0;
20640:   mUploadProgress = 0;
20640:   mUploadProgressMax = 0;
20556:   if (aBody && httpChannel && !method.EqualsLiteral("GET")) {
    1:     nsXPIDLString serial;
    1:     nsCOMPtr<nsIInputStream> postDataStream;
 1407:     nsCAutoString charset(NS_LITERAL_CSTRING("UTF-8"));
23635:     nsCAutoString defaultContentType(NS_LITERAL_CSTRING("text/plain"));
    1: 
    1:     PRUint16 dataType;
20556:     rv = aBody->GetDataType(&dataType);
20556:     if (NS_FAILED(rv))
20556:       return rv;
    1: 
    1:     switch (dataType) {
    1:     case nsIDataType::VTYPE_INTERFACE:
    1:     case nsIDataType::VTYPE_INTERFACE_IS:
    1:       {
    1:         nsCOMPtr<nsISupports> supports;
    1:         nsID *iid;
    1:         rv = aBody->GetAsInterface(&iid, getter_AddRefs(supports));
    1:         if (NS_FAILED(rv))
    1:           return rv;
    1:         if (iid)
    1:           nsMemory::Free(iid);
    1: 
    1:         // document?
    1:         nsCOMPtr<nsIDOMDocument> doc(do_QueryInterface(supports));
    1:         if (doc) {
23635:           defaultContentType.AssignLiteral("application/xml");
23635: 
20556:           nsCOMPtr<nsIDOMSerializer> serializer(do_CreateInstance(NS_XMLSERIALIZER_CONTRACTID, &rv));
20556:           if (NS_FAILED(rv)) return rv;
    1: 
18503:           nsCOMPtr<nsIDOM3Document> dom3doc(do_QueryInterface(doc));
18503:           if (dom3doc) {
18503:             nsAutoString inputEncoding;
18503:             dom3doc->GetInputEncoding(inputEncoding);
23635:             if (!DOMStringIsNull(inputEncoding)) {
18503:               CopyUTF16toUTF8(inputEncoding, charset);
18503:             }
 1407:           }
 1407: 
    1:           // Serialize to a stream so that the encoding used will
    1:           // match the document's.
13258:           nsCOMPtr<nsIStorageStream> storStream;
20556:           rv = NS_NewStorageStream(4096, PR_UINT32_MAX, getter_AddRefs(storStream));
13258:           NS_ENSURE_SUCCESS(rv, rv);
13258: 
    1:           nsCOMPtr<nsIOutputStream> output;
13258:           rv = storStream->GetOutputStream(0, getter_AddRefs(output));
    1:           NS_ENSURE_SUCCESS(rv, rv);
    1: 
21987:           // Make sure to use the encoding we'll send
21987:           rv = serializer->SerializeToStream(doc, output, charset);
    1:           NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:           output->Close();
13258:           rv = storStream->NewInputStream(0, getter_AddRefs(postDataStream));
13258:           NS_ENSURE_SUCCESS(rv, rv);
    1:         } else {
    1:           // nsISupportsString?
    1:           nsCOMPtr<nsISupportsString> wstr(do_QueryInterface(supports));
    1:           if (wstr) {
    1:             wstr->GetData(serial);
    1:           } else {
    1:             // stream?
    1:             nsCOMPtr<nsIInputStream> stream(do_QueryInterface(supports));
    1:             if (stream) {
    1:               postDataStream = stream;
 3251:               charset.Truncate();
    1:             }
32329:             else {
32329:               // nsIDOMFile?
32329:               nsCOMPtr<nsIDOMFileInternal> file(do_QueryInterface(supports));
32329: 
32329:               if (file) {
32329:                 nsCOMPtr<nsIFile> internalFile;
32329:                 rv = file->GetInternalFile(getter_AddRefs(internalFile));
32329:                 NS_ENSURE_SUCCESS(rv, rv);
32329: 
32329:                 nsCOMPtr<nsIInputStream> stream;
32329:                 rv = NS_NewLocalFileInputStream(getter_AddRefs(stream), internalFile); 
32329:                 NS_ENSURE_SUCCESS(rv, rv);
32329: 
32329:                 // Feed local file input stream into our upload channel
32329:                 if (stream) {
32329:                   postDataStream = stream;
32329:                   charset.Truncate();
32329:                   defaultContentType.Truncate();
32329: 
32329:                   nsCOMPtr<nsIMIMEService> mimeService =
32329:                       do_GetService(NS_MIMESERVICE_CONTRACTID, &rv);
32329:                   NS_ENSURE_SUCCESS(rv, rv);
32329: 
32329:                   nsCAutoString mediaType;
32329:                   rv = mimeService->GetTypeFromFile(internalFile, mediaType);
32329:                   if (NS_SUCCEEDED(rv)) {
32329:                     defaultContentType = mediaType;
32329:                   }
32329:                 }
32329:               }
32329:             }
    1:           }
    1:         }
    1:       }
    1:       break;
    1:     case nsIDataType::VTYPE_VOID:
    1:     case nsIDataType::VTYPE_EMPTY:
    1:       // Makes us act as if !aBody, don't upload anything
    1:       break;
    1:     default:
    1:       // try variant string
    1:       rv = aBody->GetAsWString(getter_Copies(serial));
23635:       NS_ENSURE_SUCCESS(rv, rv);
    1:       break;
    1:     }
    1: 
    1:     if (serial) {
    1:       // Convert to a byte stream
    1:       nsCOMPtr<nsIScriptableUnicodeConverter> converter =
    1:         do_CreateInstance("@mozilla.org/intl/scriptableunicodeconverter", &rv);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       rv = converter->SetCharset("UTF-8");
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       rv = converter->ConvertToInputStream(serial,
    1:                                            getter_AddRefs(postDataStream));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     if (postDataStream) {
    1:       // If no content type header was set by the client, we set it to
    1:       // application/xml.
    1:       nsCAutoString contentType;
    1:       if (NS_FAILED(httpChannel->
    1:                       GetRequestHeader(NS_LITERAL_CSTRING("Content-Type"),
    1:                                        contentType)) ||
    1:           contentType.IsEmpty()) {
23635:         contentType = defaultContentType;
    1:       }
    1: 
 3251:       // We don't want to set a charset for streams.
 3251:       if (!charset.IsEmpty()) {
 8603:         nsCAutoString specifiedCharset;
 8603:         PRBool haveCharset;
 8603:         PRInt32 charsetStart, charsetEnd;
 8603:         rv = NS_ExtractCharsetFromContentType(contentType, specifiedCharset,
 8603:                                               &haveCharset, &charsetStart,
 8603:                                               &charsetEnd);
23635:         if (NS_SUCCEEDED(rv)) {
 8603:           // If the content-type the page set already has a charset parameter,
 8603:           // and it's the same charset, up to case, as |charset|, just send the
 8603:           // page-set content-type header.  Apparently at least
 8603:           // google-web-toolkit is broken and relies on the exact case of its
 8603:           // charset parameter, which makes things break if we use |charset|
 8603:           // (which is always a fully resolved charset per our charset alias
 8603:           // table, hence might be differently cased).
 8603:           if (!specifiedCharset.Equals(charset,
 8603:                                        nsCaseInsensitiveCStringComparator())) {
 8603:             nsCAutoString newCharset("; charset=");
 8603:             newCharset.Append(charset);
 8603:             contentType.Replace(charsetStart, charsetEnd - charsetStart,
 8603:                                 newCharset);
 8603:           }
 3251:         }
23635:       }
 1407: 
32329:       // If necessary, wrap the stream in a buffered stream so as to guarantee
32329:       // support for our upload when calling ExplicitSetUploadStream.
32329:       if (!NS_InputStreamIsBuffered(postDataStream)) {
32329:         nsCOMPtr<nsIInputStream> bufferedStream;
32329:         rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedStream),
32329:                                        postDataStream, 
32329:                                        4096);
32329:         NS_ENSURE_SUCCESS(rv, rv);
32329: 
32329:         postDataStream = bufferedStream;
32329:       }
32329: 
16665:       mUploadComplete = PR_FALSE;
20714:       PRUint32 uploadTotal = 0;
20714:       postDataStream->Available(&uploadTotal);
20714:       mUploadTotal = uploadTotal;
32329: 
32329:       // We want to use a newer version of the upload channel that won't
32329:       // ignore the necessary headers for an empty Content-Type.
35023:       nsCOMPtr<nsIUploadChannel2> uploadChannel2(do_QueryInterface(httpChannel));
35023:       // This assertion will fire if buggy extensions are installed
35023:       NS_ASSERTION(uploadChannel2, "http must support nsIUploadChannel");
35023:       if (uploadChannel2) {
35023:           uploadChannel2->ExplicitSetUploadStream(postDataStream, contentType,
35023:                                                  -1, method, PR_FALSE);
35023:       }
35023:       else {
35023:         // http channel doesn't support the new nsIUploadChannel2. Emulate
35023:         // as best we can using nsIUploadChannel
35023:         if (contentType.IsEmpty()) {
35023:           contentType.AssignLiteral("application/octet-stream");
35023:         }
35023:         nsCOMPtr<nsIUploadChannel> uploadChannel =
35023:           do_QueryInterface(httpChannel);
35023:         uploadChannel->SetUploadStream(postDataStream, contentType, -1);
35023:         // Reset the method to its original value
35023:         httpChannel->SetRequestMethod(method);
35023:       }
20556:     }
20556:   }
20556: 
20560:   // Reset responseBody
20560:   mResponseBody.Truncate();
20560: 
20560:   // Reset responseXML
20560:   mResponseXML = nsnull;
20560: 
20560:   rv = CheckChannelForCrossSiteRequest(mChannel);
20560:   NS_ENSURE_SUCCESS(rv, rv);
20560: 
20560:   PRBool withCredentials = !!(mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS);
20560: 
20560:   // If so, set up the preflight
20560:   if (mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT) {
20560:     // Check to see if this initial OPTIONS request has already been cached
20560:     // in our special Access Control Cache.
20560:     nsCOMPtr<nsIURI> uri;
20560:     rv = mChannel->GetURI(getter_AddRefs(uri));
20560:     NS_ENSURE_SUCCESS(rv, rv);
20560: 
20560:     nsAccessControlLRUCache::CacheEntry* entry =
20560:       sAccessControlCache ?
20560:       sAccessControlCache->GetEntry(uri, mPrincipal, withCredentials, PR_FALSE) :
20560:       nsnull;
20560: 
20560:     if (!entry || !entry->CheckRequest(method, mACUnsafeHeaders)) {
20560:       // Either it wasn't cached or the cached result has expired. Build a
20560:       // channel for the OPTIONS request.
20560:       nsCOMPtr<nsILoadGroup> loadGroup;
20560:       GetLoadGroup(getter_AddRefs(loadGroup));
20560: 
20560:       nsLoadFlags loadFlags;
20560:       rv = mChannel->GetLoadFlags(&loadFlags);
20560:       NS_ENSURE_SUCCESS(rv, rv);
20560: 
20560:       rv = NS_NewChannel(getter_AddRefs(mACGetChannel), uri, nsnull,
20560:                          loadGroup, nsnull, loadFlags);
20560:       NS_ENSURE_SUCCESS(rv, rv);
20560: 
20560:       nsCOMPtr<nsIHttpChannel> acHttp = do_QueryInterface(mACGetChannel);
20560:       NS_ASSERTION(acHttp, "Failed to QI to nsIHttpChannel!");
20560: 
20560:       rv = acHttp->SetRequestMethod(NS_LITERAL_CSTRING("OPTIONS"));
20560:       NS_ENSURE_SUCCESS(rv, rv);
20560:     }
20560:   }
20560: 
20560:   // Hook us up to listen to redirects and the like
20560:   mChannel->GetNotificationCallbacks(getter_AddRefs(mNotificationCallbacks));
20560:   mChannel->SetNotificationCallbacks(this);
20560: 
20560:   // Create our listener
20560:   nsCOMPtr<nsIStreamListener> listener = this;
20560:   if (mState & XML_HTTP_REQUEST_MULTIPART) {
20560:     listener = new nsMultipartProxyListener(listener);
20560:     if (!listener) {
20560:       return NS_ERROR_OUT_OF_MEMORY;
20560:     }
20560:   }
20560: 
20560:   if (!(mState & XML_HTTP_REQUEST_XSITEENABLED)) {
20560:     // Always create a nsCrossSiteListenerProxy here even if it's
20560:     // a same-origin request right now, since it could be redirected.
20560:     listener = new nsCrossSiteListenerProxy(listener, mPrincipal, mChannel,
20560:                                             withCredentials, &rv);
20560:     NS_ENSURE_TRUE(listener, NS_ERROR_OUT_OF_MEMORY);
20560:     NS_ENSURE_SUCCESS(rv, rv);
20560:   }
20560: 
    1:   // Bypass the network cache in cases where it makes no sense:
    1:   // 1) Multipart responses are very large and would likely be doomed by the
    1:   //    cache once they grow too large, so they are not worth caching.
    1:   // 2) POST responses are always unique, and we provide no API that would
    1:   //    allow our consumers to specify a "cache key" to access old POST
    1:   //    responses, so they are not worth caching.
    1:   if ((mState & XML_HTTP_REQUEST_MULTIPART) || method.EqualsLiteral("POST")) {
    1:     AddLoadFlags(mChannel,
    1:         nsIRequest::LOAD_BYPASS_CACHE | nsIRequest::INHIBIT_CACHING);
    1:   }
    1:   // When we are sync loading, we need to bypass the local cache when it would
    1:   // otherwise block us waiting for exclusive access to the cache.  If we don't
    1:   // do this, then we could dead lock in some cases (see bug 309424).
20133:   else if (!(mState & XML_HTTP_REQUEST_ASYNC)) {
    1:     AddLoadFlags(mChannel,
    1:         nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY);
20560:     if (mACGetChannel) {
20560:       AddLoadFlags(mACGetChannel,
20560:           nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY);
20560:     }
    1:   }
    1: 
    1:   // Since we expect XML data, set the type hint accordingly
    1:   // This means that we always try to parse local files as XML
    1:   // ignoring return value, as this is not critical
    1:   mChannel->SetContentType(NS_LITERAL_CSTRING("application/xml"));
    1: 
20560:   // If we're doing a cross-site non-GET request we need to first do
20560:   // a GET request to the same URI. Set that up if needed
20560:   if (mACGetChannel) {
20560:     nsCOMPtr<nsIStreamListener> acProxyListener =
20560:       new nsACProxyListener(mChannel, listener, nsnull, mPrincipal, method,
20560:                             withCredentials);
20560:     NS_ENSURE_TRUE(acProxyListener, NS_ERROR_OUT_OF_MEMORY);
20560: 
20560:     acProxyListener =
20560:       new nsCrossSiteListenerProxy(acProxyListener, mPrincipal, mACGetChannel,
20560:                                    withCredentials, method, mACUnsafeHeaders,
20560:                                    &rv);
20560:     NS_ENSURE_TRUE(acProxyListener, NS_ERROR_OUT_OF_MEMORY);
19951:     NS_ENSURE_SUCCESS(rv, rv);
19951: 
20560:     rv = mACGetChannel->AsyncOpen(acProxyListener, nsnull);
19951:   }
19951:   else {
    1:     // Start reading from the channel
    1:     rv = mChannel->AsyncOpen(listener, nsnull);
19951:   }
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     // Drop our ref to the channel to avoid cycles
    1:     mChannel = nsnull;
20560:     mACGetChannel = nsnull;
    1:     return rv;
    1:   }
    1: 
32499:   // Now that we've successfully opened the channel, we can change state.  Note
32499:   // that this needs to come after the AsyncOpen() and rv check, because this
32499:   // can run script that would try to restart this request, and that could end
32499:   // up doing our AsyncOpen on a null channel if the reentered AsyncOpen fails.
32499:   ChangeState(XML_HTTP_REQUEST_SENT);
32499: 
    1:   // If we're synchronous, spin an event loop here and wait
    1:   if (!(mState & XML_HTTP_REQUEST_ASYNC)) {
20133:     mState |= XML_HTTP_REQUEST_SYNCLOOPING;
25074: 
25722:     nsCOMPtr<nsIDocument> suspendedDoc;
25074:     nsCOMPtr<nsIRunnable> resumeTimeoutRunnable;
25074:     if (mOwner) {
25074:       nsCOMPtr<nsIDOMWindow> topWindow;
25074:       if (NS_SUCCEEDED(mOwner->GetTop(getter_AddRefs(topWindow)))) {
25074:         nsCOMPtr<nsPIDOMWindow> suspendedWindow(do_QueryInterface(topWindow));
25722:         if (suspendedWindow &&
25722:             (suspendedWindow = suspendedWindow->GetCurrentInnerWindow())) {
25722:           suspendedDoc = do_QueryInterface(suspendedWindow->GetExtantDocument());
25722:           if (suspendedDoc) {
25722:             suspendedDoc->SuppressEventHandling();
25722:           }
25722:           suspendedWindow->SuspendTimeouts(1, PR_FALSE);
25722:           resumeTimeoutRunnable = new nsResumeTimeoutsEvent(suspendedWindow);
25074:         }
25074:       }
25074:     }
25074: 
    1:     nsIThread *thread = NS_GetCurrentThread();
    1:     while (mState & XML_HTTP_REQUEST_SYNCLOOPING) {
    1:       if (!NS_ProcessNextEvent(thread)) {
    1:         rv = NS_ERROR_UNEXPECTED;
    1:         break;
    1:       }
    1:     }
25074: 
25722:     if (suspendedDoc) {
26591:       suspendedDoc->UnsuppressEventHandlingAndFireEvents(PR_TRUE);
25722:     }
25722: 
25074:     if (resumeTimeoutRunnable) {
25074:       NS_DispatchToCurrentThread(resumeTimeoutRunnable);
25074:     }
16665:   } else {
20640:     if (!mUploadComplete &&
20640:         HasListenersFor(NS_LITERAL_STRING(UPLOADPROGRESS_STR)) ||
20640:         (mUpload && mUpload->HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR)))) {
20640:       StartProgressEventTimer();
20640:     }
16665:     DispatchProgressEvent(this, NS_LITERAL_STRING(LOADSTART_STR), PR_FALSE,
16665:                           0, 0);
16665:     if (mUpload && !mUploadComplete) {
16665:       DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOADSTART_STR), PR_TRUE,
16665:                             0, mUploadTotal);
16665:     }
    1:   }
    1: 
    1:   if (!mChannel) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* void setRequestHeader (in AUTF8String header, in AUTF8String value); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::SetRequestHeader(const nsACString& header,
    1:                                    const nsACString& value)
    1: {
 4064:   nsresult rv;
 4064: 
19952:   // Make sure we don't store an invalid header name in mACUnsafeHeaders
19952:   if (!IsValidHTTPToken(header)) {
19952:     return NS_ERROR_FAILURE;
19952:   }
19952: 
19951:   // Check that we haven't already opened the channel. We can't rely on
19951:   // the channel throwing from mChannel->SetRequestHeader since we might
20560:   // still be waiting for mACGetChannel to actually open mChannel
20560:   if (mACGetChannel) {
19951:     PRBool pending;
20560:     rv = mACGetChannel->IsPending(&pending);
19951:     NS_ENSURE_SUCCESS(rv, rv);
19951:     
19951:     if (pending) {
19951:       return NS_ERROR_IN_PROGRESS;
19951:     }
19951:   }
19951: 
 4106:   if (!mChannel)             // open() initializes mChannel, and open()
 4106:     return NS_ERROR_FAILURE; // must be called before first setRequestHeader()
 4106: 
 4064:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
 4106:   if (!httpChannel) {
 4106:     return NS_OK;
 4106:   }
    1: 
    1:   // Prevent modification to certain HTTP headers (see bug 302263), unless
    1:   // the executing script has UniversalBrowserWrite permission.
    1: 
    1:   PRBool privileged;
13282:   rv = IsCapabilityEnabled("UniversalBrowserWrite", &privileged);
    1:   if (NS_FAILED(rv))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!privileged) {
 4064:     // Check for dangerous headers
    1:     const char *kInvalidHeaders[] = {
 4064:       "accept-charset", "accept-encoding", "connection", "content-length",
 4064:       "content-transfer-encoding", "date", "expect", "host", "keep-alive",
19952:       "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"
    1:     };
 4064:     PRUint32 i;
 4064:     for (i = 0; i < NS_ARRAY_LENGTH(kInvalidHeaders); ++i) {
    1:       if (header.LowerCaseEqualsASCII(kInvalidHeaders[i])) {
    1:         NS_WARNING("refusing to set request header");
    1:         return NS_OK;
    1:       }
    1:     }
15889:     if (StringBeginsWith(header, NS_LITERAL_CSTRING("proxy-"),
15889:                          nsCaseInsensitiveCStringComparator()) ||
15889:         StringBeginsWith(header, NS_LITERAL_CSTRING("sec-"),
15889:                          nsCaseInsensitiveCStringComparator())) {
15889:       NS_WARNING("refusing to set request header");
15889:       return NS_OK;
15889:     }
19951: 
19951:     // Check for dangerous cross-site headers
19951:     PRBool safeHeader = !!(mState & XML_HTTP_REQUEST_XSITEENABLED);
19951:     if (!safeHeader) {
19951:       const char *kCrossOriginSafeHeaders[] = {
19952:         "accept", "accept-language", "content-type"
19951:       };
19951:       for (i = 0; i < NS_ARRAY_LENGTH(kCrossOriginSafeHeaders); ++i) {
19951:         if (header.LowerCaseEqualsASCII(kCrossOriginSafeHeaders[i])) {
19951:           safeHeader = PR_TRUE;
19951:           break;
19951:         }
19951:       }
19951:     }
19951: 
19951:     if (!safeHeader) {
19952:       mACUnsafeHeaders.AppendElement(header);
19951:     }
 4064:   }
 4064: 
 4054:   // We need to set, not add to, the header.
 4054:   return httpChannel->SetRequestHeader(header, value, PR_FALSE);
 4051: }
 4051: 
    1: /* readonly attribute long readyState; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetReadyState(PRInt32 *aState)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aState);
    1:   // Translate some of our internal states for external consumers
    1:   if (mState & XML_HTTP_REQUEST_UNINITIALIZED) {
    1:     *aState = 0; // UNINITIALIZED
    1:   } else  if (mState & (XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT)) {
    1:     *aState = 1; // LOADING
    1:   } else if (mState & XML_HTTP_REQUEST_LOADED) {
    1:     *aState = 2; // LOADED
    1:   } else if (mState & (XML_HTTP_REQUEST_INTERACTIVE | XML_HTTP_REQUEST_STOPPED)) {
    1:     *aState = 3; // INTERACTIVE
    1:   } else if (mState & XML_HTTP_REQUEST_COMPLETED) {
    1:     *aState = 4; // COMPLETED
    1:   } else {
    1:     NS_ERROR("Should not happen");
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* void   overrideMimeType(in AUTF8String mimetype); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OverrideMimeType(const nsACString& aMimeType)
    1: {
    1:   // XXX Should we do some validation here?
    1:   mOverrideMimeType.Assign(aMimeType);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: /* attribute boolean multipart; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetMultipart(PRBool *_retval)
    1: {
11494:   *_retval = !!(mState & XML_HTTP_REQUEST_MULTIPART);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* attribute boolean multipart; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::SetMultipart(PRBool aMultipart)
    1: {
    1:   if (!(mState & XML_HTTP_REQUEST_UNINITIALIZED)) {
    1:     // Can't change this while we're in the middle of something.
    1:     return NS_ERROR_IN_PROGRESS;
    1:   }
    1: 
    1:   if (aMultipart) {
    1:     mState |= XML_HTTP_REQUEST_MULTIPART;
    1:   } else {
    1:     mState &= ~XML_HTTP_REQUEST_MULTIPART;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
13282: /* attribute boolean mozBackgroundRequest; */
13282: NS_IMETHODIMP
13282: nsXMLHttpRequest::GetMozBackgroundRequest(PRBool *_retval)
13282: {
13282:   *_retval = !!(mState & XML_HTTP_REQUEST_BACKGROUND);
13282: 
13282:   return NS_OK;
13282: }
13282: 
13282: /* attribute boolean mozBackgroundRequest; */
13282: NS_IMETHODIMP
13282: nsXMLHttpRequest::SetMozBackgroundRequest(PRBool aMozBackgroundRequest)
13282: {
13282:   PRBool privileged;
13282: 
13282:   nsresult rv = IsCapabilityEnabled("UniversalXPConnect", &privileged);
13282:   NS_ENSURE_SUCCESS(rv, rv);
13282: 
13282:   if (!privileged)
13282:     return NS_ERROR_DOM_SECURITY_ERR;
13282: 
13282:   if (!(mState & XML_HTTP_REQUEST_UNINITIALIZED)) {
13282:     // Can't change this while we're in the middle of something.
13282:     return NS_ERROR_IN_PROGRESS;
13282:   }
13282: 
13282:   if (aMozBackgroundRequest) {
13282:     mState |= XML_HTTP_REQUEST_BACKGROUND;
13282:   } else {
13282:     mState &= ~XML_HTTP_REQUEST_BACKGROUND;
13282:   }
13282: 
13282:   return NS_OK;
13282: }
13282: 
19954: /* attribute boolean withCredentials; */
19954: NS_IMETHODIMP
19954: nsXMLHttpRequest::GetWithCredentials(PRBool *_retval)
19954: {
19954:   *_retval = !!(mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS);
19954: 
19954:   return NS_OK;
19954: }
19954: 
19954: /* attribute boolean withCredentials; */
19954: NS_IMETHODIMP
19954: nsXMLHttpRequest::SetWithCredentials(PRBool aWithCredentials)
19954: {
19954:   // Return error if we're already processing a request
19954:   if (XML_HTTP_REQUEST_SENT & mState) {
19954:     return NS_ERROR_FAILURE;
19954:   }
19954:   
19954:   if (aWithCredentials) {
19954:     mState |= XML_HTTP_REQUEST_AC_WITH_CREDENTIALS;
19954:   }
19954:   else {
19954:     mState &= ~XML_HTTP_REQUEST_AC_WITH_CREDENTIALS;
19954:   }
19954:   return NS_OK;
19954: }
19954: 
    1: 
    1: // nsIDOMEventListener
    1: nsresult
    1: nsXMLHttpRequest::HandleEvent(nsIDOMEvent* aEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsIDOMLoadListener
    1: nsresult
    1: nsXMLHttpRequest::Load(nsIDOMEvent* aEvent)
    1: {
    1:   // If we had an XML error in the data, the parser terminated and
    1:   // we received the load event, even though we might still be
    1:   // loading data into responseBody/responseText. We will delay
    1:   // sending the load event until OnStopRequest(). In normal case
    1:   // there is no harm done, we will get OnStopRequest() immediately
    1:   // after the load event.
    1:   //
    1:   // However, if the data we were loading caused the parser to stop,
    1:   // for example when loading external stylesheets, we can receive
    1:   // the OnStopRequest() call before the parser has finished building
    1:   // the document. In that case, we obviously should not fire the event
    1:   // in OnStopRequest(). For those documents, we must wait for the load
    1:   // event from the document to fire our RequestCompleted().
    1:   if (mState & XML_HTTP_REQUEST_STOPPED) {
    1:     RequestCompleted();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXMLHttpRequest::Unload(nsIDOMEvent* aEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXMLHttpRequest::BeforeUnload(nsIDOMEvent* aEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXMLHttpRequest::Abort(nsIDOMEvent* aEvent)
    1: {
    1:   Abort();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXMLHttpRequest::Error(nsIDOMEvent* aEvent)
    1: {
20331:   mResponseXML = nsnull;
    1:   ChangeState(XML_HTTP_REQUEST_COMPLETED);
    1: 
    1:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
    1: 
16665:   DispatchProgressEvent(this, NS_LITERAL_STRING(ERROR_STR), PR_FALSE,
16665:                         mResponseBody.Length(), 0);
16665:   if (mUpload && !mUploadComplete) {
16665:     mUploadComplete = PR_TRUE;
16665:     DispatchProgressEvent(mUpload, NS_LITERAL_STRING(ERROR_STR), PR_TRUE,
16665:                           mUploadTransferred, mUploadTotal);
    1:   }
    1: 
 7093:   nsJSContext::MaybeCC(PR_FALSE);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
16664: nsXMLHttpRequest::ChangeState(PRUint32 aState, PRBool aBroadcast)
    1: {
    1:   // If we are setting one of the mutually exclusive states,
    1:   // unset those state bits first.
    1:   if (aState & XML_HTTP_REQUEST_LOADSTATES) {
    1:     mState &= ~XML_HTTP_REQUEST_LOADSTATES;
    1:   }
    1:   mState |= aState;
    1:   nsresult rv = NS_OK;
    1: 
20640:   if (mProgressNotifier &&
20640:       !(aState & (XML_HTTP_REQUEST_LOADED | XML_HTTP_REQUEST_INTERACTIVE))) {
20640:     mTimerIsActive = PR_FALSE;
20640:     mProgressNotifier->Cancel();
20640:   }
20640: 
32499:   if ((mState & XML_HTTP_REQUEST_ASYNC) &&
32499:       (aState & XML_HTTP_REQUEST_LOADSTATES) && // Broadcast load states only
32499:       aBroadcast) {
    1:     nsCOMPtr<nsIDOMEvent> event;
16665:     rv = CreateReadystatechangeEvent(getter_AddRefs(event));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
16664:     DispatchDOMEvent(nsnull, event, nsnull, nsnull);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /////////////////////////////////////////////////////
    1: // nsIChannelEventSink methods:
    1: //
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnChannelRedirect(nsIChannel *aOldChannel,
    1:                                     nsIChannel *aNewChannel,
    1:                                     PRUint32    aFlags)
    1: {
    1:   NS_PRECONDITION(aNewChannel, "Redirect without a channel?");
    1: 
 4064:   nsresult rv;
 4054: 
24084:   if (!NS_IsInternalSameURIRedirect(aOldChannel, aNewChannel, aFlags)) {
19951:     rv = CheckChannelForCrossSiteRequest(aNewChannel);
 4064:     NS_ENSURE_SUCCESS(rv, rv);
 4064: 
19952:     // Disable redirects for preflighted cross-site requests entirely for now
19951:     // Note, do this after the call to CheckChannelForCrossSiteRequest
19951:     // to make sure that XML_HTTP_REQUEST_USE_XSITE_AC is up-to-date
19952:     if ((mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT)) {
19951:        return NS_ERROR_DOM_BAD_URI;
13898:     }
24084:   }
13898: 
13898:   if (mChannelEventSink) {
13898:     rv =
13898:       mChannelEventSink->OnChannelRedirect(aOldChannel, aNewChannel, aFlags);
16665:     if (NS_FAILED(rv)) {
16665:       mErrorLoad = PR_TRUE;
16665:       return rv;
16665:     }
13898:   }
13557: 
13557:   mChannel = aNewChannel;
 4051: 
    1:   return NS_OK;
    1: }
    1: 
    1: /////////////////////////////////////////////////////
    1: // nsIProgressEventSink methods:
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnProgress(nsIRequest *aRequest, nsISupports *aContext, PRUint64 aProgress, PRUint64 aProgressMax)
    1: {
19152:   // We're in middle of processing multipart headers and we don't want to report
19152:   // any progress because upload's 'load' is dispatched when we start to load
19152:   // the first response.
19152:   if (XML_HTTP_REQUEST_MPART_HEADERS & mState) {
19152:     return NS_OK;
19152:   }
19152: 
    1:   // We're uploading if our state is XML_HTTP_REQUEST_OPENED or
    1:   // XML_HTTP_REQUEST_SENT
16665:   PRBool upload = !!((XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT) & mState);
16665:   PRUint64 loaded = aProgress;
16665:   PRUint64 total = aProgressMax;
16665:   // When uploading, OnProgress reports also headers in aProgress and aProgressMax.
16665:   // So, try to remove the headers, if possible.
16665:   PRBool lengthComputable = (aProgressMax != LL_MAXUINT);
16665:   if (upload) {
16665:    if (lengthComputable) {
20714:       PRUint64 headerSize = aProgressMax - mUploadTotal;
16665:       loaded -= headerSize;
16665:       total -= headerSize;
16665:     }
16665:     mUploadTransferred = loaded;
20640:     mUploadProgress = aProgress;
20640:     mUploadProgressMax = aProgressMax;
20640:   } else {
20640:     mLoadLengthComputable = lengthComputable;
20640:     mLoadTotal = mLoadLengthComputable ? total : 0;
20640:   }
20640: 
20640:   if (mTimerIsActive) {
20640:     // The progress event will be dispatched when the notifier calls Notify().
20640:     mProgressEventWasDelayed = PR_TRUE;
20640:     return NS_OK;
16665:   }
16665: 
25722:   if (!mErrorLoad && (mState & XML_HTTP_REQUEST_ASYNC)) {
20640:     StartProgressEventTimer();
16665:     NS_NAMED_LITERAL_STRING(progress, PROGRESS_STR);
16665:     NS_NAMED_LITERAL_STRING(uploadprogress, UPLOADPROGRESS_STR);
16665:     DispatchProgressEvent(this, upload ? uploadprogress : progress, PR_TRUE,
16665:                           lengthComputable, loaded, lengthComputable ? total : 0,
16665:                           aProgress, aProgressMax);
16665: 
20640:     if (upload && mUpload && !mUploadComplete) {
20714:       NS_WARN_IF_FALSE(mUploadTotal == total, "Wrong upload total?");
16665:       DispatchProgressEvent(mUpload, progress,  PR_TRUE, lengthComputable, loaded,
16665:                             lengthComputable ? total : 0, aProgress, aProgressMax);
16665:     }
16665:   }
    1: 
    1:   if (mProgressEventSink) {
    1:     mProgressEventSink->OnProgress(aRequest, aContext, aProgress,
    1:                                    aProgressMax);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnStatus(nsIRequest *aRequest, nsISupports *aContext, nsresult aStatus, const PRUnichar *aStatusArg)
    1: {
    1:   if (mProgressEventSink) {
    1:     mProgressEventSink->OnStatus(aRequest, aContext, aStatus, aStatusArg);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
19953: PRBool
19953: nsXMLHttpRequest::AllowUploadProgress()
19953: {
19953:   return !(mState & XML_HTTP_REQUEST_USE_XSITE_AC) ||
19953:     (mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
19953: }
19953: 
    1: /////////////////////////////////////////////////////
    1: // nsIInterfaceRequestor methods:
    1: //
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetInterface(const nsIID & aIID, void **aResult)
    1: {
14092:   nsresult rv;
14092: 
    1:   // Make sure to return ourselves for the channel event sink interface and
    1:   // progress event sink interface, no matter what.  We can forward these to
    1:   // mNotificationCallbacks if it wants to get notifications for them.  But we
    1:   // need to see these notifications for proper functioning.
    1:   if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
    1:     mChannelEventSink = do_GetInterface(mNotificationCallbacks);
 3233:     *aResult = static_cast<nsIChannelEventSink*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   } else if (aIID.Equals(NS_GET_IID(nsIProgressEventSink))) {
    1:     mProgressEventSink = do_GetInterface(mNotificationCallbacks);
 3233:     *aResult = static_cast<nsIProgressEventSink*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Now give mNotificationCallbacks (if non-null) a chance to return the
13239:   // desired interface.
    1:   if (mNotificationCallbacks) {
14092:     rv = mNotificationCallbacks->GetInterface(aIID, aResult);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       NS_ASSERTION(*aResult, "Lying nsIInterfaceRequestor implementation!");
    1:       return rv;
    1:     }
    1:   }
    1: 
13282:   if (mState & XML_HTTP_REQUEST_BACKGROUND) {
13282:     nsCOMPtr<nsIInterfaceRequestor> badCertHandler(do_CreateInstance(NS_BADCERTHANDLER_CONTRACTID, &rv));
13282: 
13282:     // Ignore failure to get component, we may not have all its dependencies
13282:     // available
13282:     if (NS_SUCCEEDED(rv)) {
13282:       rv = badCertHandler->GetInterface(aIID, aResult);
13282:       if (NS_SUCCEEDED(rv))
13282:         return rv;
13282:     }
13282:   }
14092:   else if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
14092:            aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
14092:     nsCOMPtr<nsIPromptFactory> wwatch =
14092:       do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
14092:     NS_ENSURE_SUCCESS(rv, rv);
14092: 
14092:     // Get the an auth prompter for our window so that the parenting
14092:     // of the dialogs works as it should when using tabs.
14092: 
14092:     nsCOMPtr<nsIDOMWindow> window;
14092:     if (mOwner) {
14092:       window = mOwner->GetOuterWindow();
14092:     }
14092: 
14092:     return wwatch->GetPrompt(window, aIID,
14092:                              reinterpret_cast<void**>(aResult));
14092: 
14092:   }
13282: 
    1:   return QueryInterface(aIID, aResult);
    1: }
    1: 
16665: NS_IMETHODIMP
16665: nsXMLHttpRequest::GetUpload(nsIXMLHttpRequestUpload** aUpload)
16665: {
16665:   *aUpload = nsnull;
27700: 
27700:   nsresult rv;
27700:   nsIScriptContext* scriptContext =
27700:     GetContextForEventHandlers(&rv);
19701:   NS_ENSURE_SUCCESS(rv, rv);
16665:   if (!mUpload) {
19701:     mUpload = new nsXMLHttpRequestUpload(mOwner, scriptContext);
16665:     NS_ENSURE_TRUE(mUpload, NS_ERROR_OUT_OF_MEMORY);
16665:   }
16665:   NS_ADDREF(*aUpload = mUpload);
16665:   return NS_OK;
16665: }
16665: 
20640: NS_IMETHODIMP
20640: nsXMLHttpRequest::Notify(nsITimer* aTimer)
20640: {
20640:   mTimerIsActive = PR_FALSE;
25722:   if (NS_SUCCEEDED(CheckInnerWindowCorrectness()) && !mErrorLoad &&
25722:       (mState & XML_HTTP_REQUEST_ASYNC)) {
20640:     if (mProgressEventWasDelayed) {
20640:       mProgressEventWasDelayed = PR_FALSE;
20640:       if (!(XML_HTTP_REQUEST_MPART_HEADERS & mState)) {
20640:         StartProgressEventTimer();
20640:         // We're uploading if our state is XML_HTTP_REQUEST_OPENED or
20640:         // XML_HTTP_REQUEST_SENT
20640:         if ((XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT) & mState) {
20640:           DispatchProgressEvent(this, NS_LITERAL_STRING(UPLOADPROGRESS_STR),
20640:                                 PR_TRUE, PR_TRUE, mUploadTransferred,
20640:                                 mUploadTotal, mUploadProgress,
20640:                                 mUploadProgressMax);
20640:           if (mUpload && !mUploadComplete) {
20640:             DispatchProgressEvent(mUpload, NS_LITERAL_STRING(PROGRESS_STR),
20640:                                   PR_TRUE, PR_TRUE, mUploadTransferred,
20640:                                   mUploadTotal, mUploadProgress,
20640:                                   mUploadProgressMax);
20640:           }
20640:         } else {
20640:           DispatchProgressEvent(this, NS_LITERAL_STRING(PROGRESS_STR),
20640:                                 mLoadLengthComputable, mResponseBody.Length(),
20640:                                 mLoadTotal);
20640:         }
20640:       }
20640:     }
20640:   } else if (mProgressNotifier) {
20640:     mProgressNotifier->Cancel();
20640:   }
20640:   return NS_OK;
20640: }
20640: 
20640: void
20640: nsXMLHttpRequest::StartProgressEventTimer()
20640: {
20640:   if (!mProgressNotifier) {
20640:     mProgressNotifier = do_CreateInstance(NS_TIMER_CONTRACTID);
20640:   }
20640:   if (mProgressNotifier) {
20640:     mProgressEventWasDelayed = PR_FALSE;
20640:     mTimerIsActive = PR_TRUE;
20640:     mProgressNotifier->Cancel();
20640:     mProgressNotifier->InitWithCallback(this, NS_PROGRESS_EVENT_INTERVAL,
20640:                                         nsITimer::TYPE_ONE_SHOT);
20640:   }
20640: }
20640: 
    1: NS_IMPL_ISUPPORTS1(nsXMLHttpRequest::nsHeaderVisitor, nsIHttpHeaderVisitor)
    1: 
    1: NS_IMETHODIMP nsXMLHttpRequest::
    1: nsHeaderVisitor::VisitHeader(const nsACString &header, const nsACString &value)
    1: {
21639:     // See bug #380418. Hide "Set-Cookie" headers from non-chrome scripts.
21639:     PRBool chrome = PR_FALSE; // default to false in case IsCapabilityEnabled fails
21639:     IsCapabilityEnabled("UniversalXPConnect", &chrome);
21639:     if (!chrome &&
21639:          (header.LowerCaseEqualsASCII("set-cookie") ||
21639:           header.LowerCaseEqualsASCII("set-cookie2"))) {
21639:         NS_WARNING("blocked access to response header");
21639:     } else {
    1:         mHeaders.Append(header);
    1:         mHeaders.Append(": ");
    1:         mHeaders.Append(value);
    1:         mHeaders.Append('\n');
21639:     }
    1:     return NS_OK;
    1: }
    1: 
    1: // DOM event class to handle progress notifications
16665: nsXMLHttpProgressEvent::nsXMLHttpProgressEvent(nsIDOMProgressEvent* aInner,
16665:                                                PRUint64 aCurrentProgress,
16665:                                                PRUint64 aMaxProgress)
    1: {
16665:   mInner = static_cast<nsDOMProgressEvent*>(aInner);
    1:   mCurProgress = aCurrentProgress;
    1:   mMaxProgress = aMaxProgress;
    1: }
    1: 
    1: nsXMLHttpProgressEvent::~nsXMLHttpProgressEvent()
    1: {}
    1: 
16665: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLHttpProgressEvent)
16665: 
16665: // QueryInterface implementation for nsXMLHttpProgressEvent
16665: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXMLHttpProgressEvent)
16665:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMProgressEvent)
16665:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEvent, nsIDOMProgressEvent)
16665:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSEvent)
16665:   NS_INTERFACE_MAP_ENTRY(nsIPrivateDOMEvent)
16665:   NS_INTERFACE_MAP_ENTRY(nsIDOMProgressEvent)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMLSProgressEvent)
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(XMLHttpProgressEvent)
    1: NS_INTERFACE_MAP_END
    1: 
16665: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXMLHttpProgressEvent)
16665: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXMLHttpProgressEvent)
16665: 
16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsXMLHttpProgressEvent)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mInner);
16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16665: 
16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsXMLHttpProgressEvent)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mInner,
16665:                                                        nsIDOMProgressEvent)
16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: NS_IMETHODIMP nsXMLHttpProgressEvent::GetInput(nsIDOMLSInput * *aInput)
    1: {
    1:   *aInput = nsnull;
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsXMLHttpProgressEvent::GetPosition(PRUint32 *aPosition)
    1: {
    1:   // XXX can we change the iface?
    1:   LL_L2UI(*aPosition, mCurProgress);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXMLHttpProgressEvent::GetTotalSize(PRUint32 *aTotalSize)
    1: {
    1:   // XXX can we change the iface?
    1:   LL_L2UI(*aTotalSize, mMaxProgress);
    1:   return NS_OK;
    1: }
16665: 
