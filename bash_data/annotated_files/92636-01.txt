    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:set et cin sw=2 sts=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla <object> loading code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Christian Biesinger <cbiesinger@web.de>.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
40610:  *   Justin Dolske <dolske@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
 3642:  * A base class implementing nsIObjectLoadingContent for use by
    1:  * various content nodes that want to provide plugin/document/image
    1:  * loading functionality (eg <embed>, <object>, <applet>, etc).
    1:  */
    1: 
    1: // Interface headers
    1: #include "imgILoader.h"
38026: #include "nsEventDispatcher.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocument.h"
38026: #include "nsIDOMDataContainerEvent.h"
70359: #include "nsIDOMDocument.h"
38026: #include "nsIDOMEventTarget.h"
    1: #include "nsIExternalProtocolHandler.h"
68780: #include "nsEventStates.h"
    1: #include "nsIObjectFrame.h"
    1: #include "nsIPluginDocument.h"
70007: #include "nsPluginHost.h"
    1: #include "nsIPresShell.h"
38026: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIStreamConverterService.h"
    1: #include "nsIURILoader.h"
    1: #include "nsIURL.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIWebNavigationInfo.h"
 8608: #include "nsIScriptChannel.h"
33384: #include "nsIBlocklistService.h"
48889: #include "nsIAsyncVerifyRedirectCallback.h"
89114: #include "nsIAppShell.h"
    1: 
    1: #include "nsPluginError.h"
    1: 
    1: // Util headers
    1: #include "prlog.h"
    1: 
    1: #include "nsAutoPtr.h"
    1: #include "nsCURILoader.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDocShellCID.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsNetUtil.h"
 4849: #include "nsMimeTypes.h"
13583: #include "nsStyleUtil.h"
38026: #include "nsGUIEvent.h"
62136: #include "nsUnicharUtils.h"
    1: 
    1: // Concrete classes
    1: #include "nsFrameLoader.h"
    1: 
    1: #include "nsObjectLoadingContent.h"
14228: #include "mozAutoDocUpdate.h"
41208: #include "nsIContentSecurityPolicy.h"
41208: #include "nsIChannelPolicy.h"
41208: #include "nsChannelPolicy.h"
74131: #include "mozilla/dom/Element.h"
88104: #include "sampler.h"
89114: #include "nsObjectFrame.h"
89114: #include "nsDOMClassInfo.h"
89114: 
89114: #include "nsWidgetsCID.h"
89114: #include "nsContentCID.h"
89114: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
    1: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo* gObjectLog = PR_NewLogModule("objlc");
    1: #endif
    1: 
    1: #define LOG(args) PR_LOG(gObjectLog, PR_LOG_DEBUG, args)
    1: #define LOG_ENABLED() PR_LOG_TEST(gObjectLog, PR_LOG_DEBUG)
    1: 
82502: #include "mozilla/Preferences.h"
80300: 
    1: class nsAsyncInstantiateEvent : public nsRunnable {
    1: public:
    1:   nsObjectLoadingContent *mContent;
89114:   nsAsyncInstantiateEvent(nsObjectLoadingContent* aContent)
89114:   : mContent(aContent)
    1:   {
 3233:     static_cast<nsIObjectLoadingContent *>(mContent)->AddRef();
    1:   }
    1: 
    1:   ~nsAsyncInstantiateEvent()
    1:   {
 3233:     static_cast<nsIObjectLoadingContent *>(mContent)->Release();
    1:   }
    1: 
    1:   NS_IMETHOD Run();
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsAsyncInstantiateEvent::Run()
    1: {
89114:   // do nothing if we've been revoked
89114:   if (mContent->mPendingInstantiateEvent != this) {
    1:     return NS_OK;
89114:   }
    1:   mContent->mPendingInstantiateEvent = nsnull;
    1: 
89114:   return mContent->SyncStartPluginInstance();
77476: }
77476: 
89114: // Checks to see if the content for a plugin instance has a parent.
89114: // The plugin instance is stopped if there is no parent.
89114: class InDocCheckEvent : public nsRunnable {
89114: public:
89114:   nsCOMPtr<nsIContent> mContent;
89114: 
89114:   InDocCheckEvent(nsIContent* aContent)
89114:   : mContent(aContent)
89114:   {
    1:   }
    1: 
89114:   ~InDocCheckEvent()
89114:   {
    1:   }
    1: 
89114:   NS_IMETHOD Run();
89114: };
89114: 
89114: NS_IMETHODIMP
89114: InDocCheckEvent::Run()
89114: {
89114:   if (!mContent->IsInDoc()) {
89114:     nsCOMPtr<nsIObjectLoadingContent> olc = do_QueryInterface(mContent);
89114:     if (olc) {
89114:       olc->StopPluginInstance();
89114:     }
89114:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /**
 3464:  * A task for firing PluginNotFound and PluginBlocklisted DOM Events.
    1:  */
 3464: class nsPluginErrorEvent : public nsRunnable {
    1: public:
    1:   nsCOMPtr<nsIContent> mContent;
19014:   PluginSupportState mState;
    1: 
19014:   nsPluginErrorEvent(nsIContent* aContent, PluginSupportState aState)
 3464:     : mContent(aContent),
19014:       mState(aState)
    1:   {}
    1: 
 3464:   ~nsPluginErrorEvent() {}
    1: 
    1:   NS_IMETHOD Run();
    1: };
    1: 
    1: NS_IMETHODIMP
 3464: nsPluginErrorEvent::Run()
    1: {
    1:   LOG(("OBJLC []: Firing plugin not found event for content %p\n",
    1:        mContent.get()));
19014:   nsString type;
19014:   switch (mState) {
80300:     case ePluginClickToPlay:
80300:       type = NS_LITERAL_STRING("PluginClickToPlay");
80300:       break;
19014:     case ePluginUnsupported:
19014:       type = NS_LITERAL_STRING("PluginNotFound");
19014:       break;
19014:     case ePluginDisabled:
19014:       type = NS_LITERAL_STRING("PluginDisabled");
19014:       break;
19014:     case ePluginBlocklisted:
19014:       type = NS_LITERAL_STRING("PluginBlocklisted");
19014:       break;
33384:     case ePluginOutdated:
33384:       type = NS_LITERAL_STRING("PluginOutdated");
33384:       break;
19014:     default:
19014:       return NS_OK;
19014:   }
 3464:   nsContentUtils::DispatchTrustedEvent(mContent->GetDocument(), mContent,
80486:                                        type, true, true);
 3464: 
    1:   return NS_OK;
    1: }
    1: 
38026: /**
38026:  * A task for firing PluginCrashed DOM Events.
38026:  */
38026: class nsPluginCrashedEvent : public nsRunnable {
38026: public:
38026:   nsCOMPtr<nsIContent> mContent;
39794:   nsString mPluginDumpID;
39794:   nsString mBrowserDumpID;
38026:   nsString mPluginName;
40610:   nsString mPluginFilename;
79445:   bool mSubmittedCrashReport;
38026: 
38026:   nsPluginCrashedEvent(nsIContent* aContent,
39794:                        const nsAString& aPluginDumpID,
39794:                        const nsAString& aBrowserDumpID,
38026:                        const nsAString& aPluginName,
40610:                        const nsAString& aPluginFilename,
79445:                        bool submittedCrashReport)
38026:     : mContent(aContent),
39794:       mPluginDumpID(aPluginDumpID),
39794:       mBrowserDumpID(aBrowserDumpID),
38026:       mPluginName(aPluginName),
40610:       mPluginFilename(aPluginFilename),
38026:       mSubmittedCrashReport(submittedCrashReport)
38026:   {}
38026: 
38026:   ~nsPluginCrashedEvent() {}
38026: 
38026:   NS_IMETHOD Run();
38026: };
38026: 
38026: NS_IMETHODIMP
38026: nsPluginCrashedEvent::Run()
38026: {
38026:   LOG(("OBJLC []: Firing plugin crashed event for content %p\n",
38026:        mContent.get()));
38026: 
70359:   nsCOMPtr<nsIDOMDocument> domDoc =
38026:     do_QueryInterface(mContent->GetDocument());
70359:   if (!domDoc) {
38026:     NS_WARNING("Couldn't get document for PluginCrashed event!");
38026:     return NS_OK;
38026:   }
38026: 
38026:   nsCOMPtr<nsIDOMEvent> event;
70359:   domDoc->CreateEvent(NS_LITERAL_STRING("datacontainerevents"),
38026:                       getter_AddRefs(event));
38026:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
38026:   nsCOMPtr<nsIDOMDataContainerEvent> containerEvent(do_QueryInterface(event));
38026:   if (!privateEvent || !containerEvent) {
38026:     NS_WARNING("Couldn't QI event for PluginCrashed event!");
38026:     return NS_OK;
38026:   }
38026: 
80486:   event->InitEvent(NS_LITERAL_STRING("PluginCrashed"), true, true);
80486:   privateEvent->SetTrusted(true);
38026:   privateEvent->GetInternalNSEvent()->flags |= NS_EVENT_FLAG_ONLY_CHROME_DISPATCH;
38026:   
38026:   nsCOMPtr<nsIWritableVariant> variant;
38026: 
39794:   // add a "pluginDumpID" property to this event
39501:   variant = do_CreateInstance("@mozilla.org/variant;1");
39501:   if (!variant) {
39794:     NS_WARNING("Couldn't create pluginDumpID variant for PluginCrashed event!");
39501:     return NS_OK;
39501:   }
39794:   variant->SetAsAString(mPluginDumpID);
39794:   containerEvent->SetData(NS_LITERAL_STRING("pluginDumpID"), variant);
39794: 
39794:   // add a "browserDumpID" property to this event
39794:   variant = do_CreateInstance("@mozilla.org/variant;1");
39794:   if (!variant) {
39794:     NS_WARNING("Couldn't create browserDumpID variant for PluginCrashed event!");
39794:     return NS_OK;
39794:   }
39794:   variant->SetAsAString(mBrowserDumpID);
39794:   containerEvent->SetData(NS_LITERAL_STRING("browserDumpID"), variant);
39501: 
38026:   // add a "pluginName" property to this event
38026:   variant = do_CreateInstance("@mozilla.org/variant;1");
38026:   if (!variant) {
38026:     NS_WARNING("Couldn't create pluginName variant for PluginCrashed event!");
38026:     return NS_OK;
38026:   }
38026:   variant->SetAsAString(mPluginName);
38026:   containerEvent->SetData(NS_LITERAL_STRING("pluginName"), variant);
38026: 
40610:   // add a "pluginFilename" property to this event
40610:   variant = do_CreateInstance("@mozilla.org/variant;1");
40610:   if (!variant) {
40610:     NS_WARNING("Couldn't create pluginFilename variant for PluginCrashed event!");
40610:     return NS_OK;
40610:   }
40610:   variant->SetAsAString(mPluginFilename);
40610:   containerEvent->SetData(NS_LITERAL_STRING("pluginFilename"), variant);
40610: 
38026:   // add a "submittedCrashReport" property to this event
38026:   variant = do_CreateInstance("@mozilla.org/variant;1");
38026:   if (!variant) {
38026:     NS_WARNING("Couldn't create crashSubmit variant for PluginCrashed event!");
38026:     return NS_OK;
38026:   }
38026:   variant->SetAsBool(mSubmittedCrashReport);
38026:   containerEvent->SetData(NS_LITERAL_STRING("submittedCrashReport"), variant);
38026: 
38026:   nsEventDispatcher::DispatchDOMEvent(mContent, nsnull, event, nsnull, nsnull);
38026:   return NS_OK;
38026: }
38026: 
89114: class nsStopPluginRunnable : public nsRunnable, public nsITimerCallback
89114: {
89114: public:
89114:   NS_DECL_ISUPPORTS_INHERITED
89114: 
89114:   nsStopPluginRunnable(nsPluginInstanceOwner *aInstanceOwner)
89114:   : mInstanceOwner(aInstanceOwner)
89114:   {
89114:     NS_ASSERTION(aInstanceOwner, "need an owner");
89114:   }
89114: 
89114:   // nsRunnable
89114:   NS_IMETHOD Run();
89114: 
89114:   // nsITimerCallback
89114:   NS_IMETHOD Notify(nsITimer *timer);
89114: 
89114: private:
89114:   nsCOMPtr<nsITimer> mTimer;
89114:   nsRefPtr<nsPluginInstanceOwner> mInstanceOwner;
89114: };
89114: 
89114: NS_IMPL_ISUPPORTS_INHERITED1(nsStopPluginRunnable, nsRunnable, nsITimerCallback)
89114: 
89114: NS_IMETHODIMP
89114: nsStopPluginRunnable::Notify(nsITimer *aTimer)
89114: {
89114:   return Run();
89114: }
89114: 
89114: NS_IMETHODIMP
89114: nsStopPluginRunnable::Run()
89114: {
89114:   // InitWithCallback calls Release before AddRef so we need to hold a
89114:   // strong ref on 'this' since we fall through to this scope if it fails.
89114:   nsCOMPtr<nsITimerCallback> kungFuDeathGrip = this;
89114:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
89114:   if (appShell) {
89114:     PRUint32 currentLevel = 0;
89114:     appShell->GetEventloopNestingLevel(&currentLevel);
89114:     if (currentLevel > mInstanceOwner->GetLastEventloopNestingLevel()) {
89114:       if (!mTimer)
89114:         mTimer = do_CreateInstance("@mozilla.org/timer;1");
89114:       if (mTimer) {
89114:         // Fire 100ms timer to try to tear down this plugin as quickly as
89114:         // possible once the nesting level comes back down.
89114:         nsresult rv = mTimer->InitWithCallback(this, 100, nsITimer::TYPE_ONE_SHOT);
89114:         if (NS_SUCCEEDED(rv)) {
89114:           return rv;
89114:         }
89114:       }
89114:       NS_ERROR("Failed to setup a timer to stop the plugin later (at a safe "
89114:                "time). Stopping the plugin now, this might crash.");
89114:     }
89114:   }
89114: 
89114:   mTimer = nsnull;
89114: 
89114:   nsObjectLoadingContent::DoStopPlugin(mInstanceOwner, false);
89114: 
89114:   return NS_OK;
89114: }
89114: 
    1: class AutoNotifier {
    1:   public:
79445:     AutoNotifier(nsObjectLoadingContent* aContent, bool aNotify) :
    1:       mContent(aContent), mNotify(aNotify) {
    1:         mOldType = aContent->Type();
    1:         mOldState = aContent->ObjectState();
    1:     }
    1:     ~AutoNotifier() {
80486:       mContent->NotifyStateChanged(mOldType, mOldState, false, mNotify);
    1:     }
    1: 
    1:     /**
    1:      * Send notifications now, ignoring the value of mNotify. The new type and
    1:      * state is saved, and the destructor will notify again if mNotify is true
    1:      * and the values changed.
    1:      */
    1:     void Notify() {
    1:       NS_ASSERTION(mNotify, "Should not notify when notify=false");
    1: 
80486:       mContent->NotifyStateChanged(mOldType, mOldState, true, true);
    1:       mOldType = mContent->Type();
    1:       mOldState = mContent->ObjectState();
    1:     }
    1: 
    1:   private:
    1:     nsObjectLoadingContent*            mContent;
79445:     bool                               mNotify;
    1:     nsObjectLoadingContent::ObjectType mOldType;
56168:     nsEventStates                      mOldState;
    1: };
    1: 
    1: /**
    1:  * A class that will automatically fall back if a |rv| variable has a failure
    1:  * code when this class is destroyed. It does not notify.
    1:  */
    1: class AutoFallback {
    1:   public:
    1:     AutoFallback(nsObjectLoadingContent* aContent, const nsresult* rv)
19014:       : mContent(aContent), mResult(rv), mPluginState(ePluginOtherState) {}
    1:     ~AutoFallback() {
    1:       if (NS_FAILED(*mResult)) {
    1:         LOG(("OBJLC [%p]: rv=%08x, falling back\n", mContent, *mResult));
80486:         mContent->Fallback(false);
19014:         if (mPluginState != ePluginOtherState) {
37151:           mContent->mFallbackReason = mPluginState;
    1:         }
    1:       }
    1:     }
    1: 
    1:     /**
19014:      * This should be set to something other than ePluginOtherState to indicate
19014:      * a specific failure that should be passed on.
    1:      */
19014:      void SetPluginState(PluginSupportState aState) {
19014:        NS_ASSERTION(aState != ePluginOtherState, "Should not be setting ePluginOtherState");
19014:        mPluginState = aState;
    1:      }
    1:   private:
    1:     nsObjectLoadingContent* mContent;
    1:     const nsresult* mResult;
19014:     PluginSupportState mPluginState;
    1: };
    1: 
    1: /**
    1:  * A class that automatically sets mInstantiating to false when it goes
    1:  * out of scope.
    1:  */
    1: class AutoSetInstantiatingToFalse {
    1:   public:
    1:     AutoSetInstantiatingToFalse(nsObjectLoadingContent* objlc) : mContent(objlc) {}
80486:     ~AutoSetInstantiatingToFalse() { mContent->mInstantiating = false; }
    1:   private:
    1:     nsObjectLoadingContent* mContent;
    1: };
    1: 
    1: // helper functions
79445: static bool
    1: IsSupportedImage(const nsCString& aMimeType)
    1: {
    1:   imgILoader* loader = nsContentUtils::GetImgLoader();
    1:   if (!loader) {
80486:     return false;
    1:   }
    1: 
79445:   bool supported;
    1:   nsresult rv = loader->SupportImageWithMimeType(aMimeType.get(), &supported);
    1:   return NS_SUCCEEDED(rv) && supported;
    1: }
    1: 
89887: nsresult nsObjectLoadingContent::IsPluginEnabledForType(const nsCString& aMIMEType)
    1: {
89887:   if (!mShouldPlay) {
89887:     return NS_ERROR_PLUGIN_CLICKTOPLAY;
89887:   }
89887: 
70185:   nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
70185:   nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
70185:   if (!pluginHost) {
80486:     return false;
    1:   }
89887:   return pluginHost->IsPluginEnabledForType(aMIMEType.get());
    1: }
    1: 
 3642: static void
 3642: GetExtensionFromURI(nsIURI* uri, nsCString& ext)
 3642: {
 3642:   nsCOMPtr<nsIURL> url(do_QueryInterface(uri));
 3642:   if (url) {
 3642:     url->GetFileExtension(ext);
 3642:   } else {
 3642:     nsCString spec;
 3642:     uri->GetSpec(spec);
 3642: 
 3642:     PRInt32 offset = spec.RFindChar('.');
 3642:     if (offset != kNotFound) {
 3642:       ext = Substring(spec, offset + 1, spec.Length());
 3642:     }
 3642:   }
 3642: }
 3642: 
 3642: /**
 3642:  * Checks whether a plugin exists and is enabled for the extension
 3642:  * in the given URI. The MIME type is returned in the mimeType out parameter.
 3642:  */
89887: bool nsObjectLoadingContent::IsPluginEnabledByExtension(nsIURI* uri, nsCString& mimeType)
 3642: {
89887:   if (!mShouldPlay) {
89887:     return false;
89887:   }
89887: 
 3642:   nsCAutoString ext;
 3642:   GetExtensionFromURI(uri, ext);
 3642: 
70185:   if (ext.IsEmpty()) {
80486:     return false;
70185:   }
 4315: 
70185:   nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
70185:   nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
70185:   if (!pluginHost) {
80486:     return false;
70185:   }
70185: 
 3642:   const char* typeFromExt;
89887:   if (NS_SUCCEEDED(pluginHost->IsPluginEnabledForExtension(ext.get(), typeFromExt))) {
 3642:     mimeType = typeFromExt;
80486:     return true;
 3642:   }
80486:   return false;
 3642: }
 3642: 
    1: nsObjectLoadingContent::nsObjectLoadingContent()
 3176:   : mPendingInstantiateEvent(nsnull)
 3176:   , mChannel(nsnull)
    1:   , mType(eType_Loading)
80486:   , mInstantiating(false)
80486:   , mUserDisabled(false)
80486:   , mSuppressed(false)
80486:   , mNetworkCreated(true)
84557:   // If plugins.click_to_play is false, plugins should always play
84557:   , mShouldPlay(!mozilla::Preferences::GetBool("plugins.click_to_play", false))
91089:   , mSrcStreamLoading(false)
37151:   , mFallbackReason(ePluginOtherState)
    1: {
    1: }
    1: 
    1: nsObjectLoadingContent::~nsObjectLoadingContent()
    1: {
    1:   DestroyImageLoadingContent();
    1:   if (mFrameLoader) {
    1:     mFrameLoader->Destroy();
    1:   }
    1: }
    1: 
89114: nsresult
89114: nsObjectLoadingContent::InstantiatePluginInstance(const char* aMimeType, nsIURI* aURI)
89114: {
89887:   if (!mShouldPlay) {
89887:     return NS_ERROR_PLUGIN_CLICKTOPLAY;
89887:   }
89887: 
89114:   // Don't do anything if we already have an active instance.
89114:   if (mInstanceOwner) {
89114:     return NS_OK;
89114:   }
89114: 
89114:   // Don't allow re-entry into initialization code.
89114:   if (mInstantiating) {
89114:     return NS_OK;
89114:   }
89114:   mInstantiating = true;
89114:   AutoSetInstantiatingToFalse autoInstantiating(this);
89114: 
89114:   // Instantiating an instance can result in script execution, which
89114:   // can destroy this DOM object. Don't allow that for the scope
89114:   // of this method.
89114:   nsCOMPtr<nsIObjectLoadingContent> kungFuDeathGrip = this;
89114:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
89114: 
89114:   nsCOMPtr<nsIURI> baseURI;
89114:   if (!aURI) {
89114:     // We need some URI. If we have nothing else, use the base URI.
89114:     // XXX(biesi): The code used to do this. Not sure why this is correct...
92488:     GetObjectBaseURI(thisContent, getter_AddRefs(baseURI));
89114:     aURI = baseURI;
89114:   }
89114: 
89114:   // Flush layout so that the plugin is initialized with the latest information.
89114:   nsIDocument* doc = thisContent->GetCurrentDoc();
89114:   if (!doc) {
89114:     return NS_ERROR_FAILURE;
89114:   }
89114:   doc->FlushPendingNotifications(Flush_Layout);
89114: 
89114:   nsresult rv = NS_ERROR_FAILURE;
89114:   nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID, &rv));
89114:   nsPluginHost* pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
89114:   if (NS_FAILED(rv)) {
89114:     return rv;
89114:   }
89114: 
89114:   // If you add early return(s), be sure to balance this call to
89114:   // appShell->SuspendNative() with additional call(s) to
89114:   // appShell->ReturnNative().
89114:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
89114:   if (appShell) {
89114:     appShell->SuspendNative();
89114:   }
89114: 
89114:   nsCOMPtr<nsIPluginDocument> pDoc(do_QueryInterface(doc));
89114:   bool fullPageMode = false;
89114:   if (pDoc) {
89114:     pDoc->GetWillHandleInstantiation(&fullPageMode);
89114:   }
89114: 
89114:   if (fullPageMode) {
89114:     nsCOMPtr<nsIStreamListener> stream;
89114:     rv = pluginHost->InstantiateFullPagePlugin(aMimeType, aURI, this, getter_AddRefs(mInstanceOwner), getter_AddRefs(stream));
89114:     if (NS_SUCCEEDED(rv)) {
89114:       pDoc->SetStreamListener(stream);
89114:     }
89114:   } else {
89114:     rv = pluginHost->InstantiateEmbeddedPlugin(aMimeType, aURI, this, getter_AddRefs(mInstanceOwner));
89114:   }
89114: 
89114:   if (appShell) {
89114:     appShell->ResumeNative();
89114:   }
89114: 
89114:   if (NS_FAILED(rv)) {
89114:     return rv;
89114:   }
89114: 
89114:   // Set up scripting interfaces.
89114:   NotifyContentObjectWrapper();
89114: 
89114:   nsRefPtr<nsNPAPIPluginInstance> pluginInstance;
89114:   GetPluginInstance(getter_AddRefs(pluginInstance));
89114:   if (pluginInstance) {
89114:     nsCOMPtr<nsIPluginTag> pluginTag;
89114:     pluginHost->GetPluginTagForInstance(pluginInstance, getter_AddRefs(pluginTag));
89114:     
89114:     nsCOMPtr<nsIBlocklistService> blocklist =
89114:     do_GetService("@mozilla.org/extensions/blocklist;1");
89114:     if (blocklist) {
89114:       PRUint32 blockState = nsIBlocklistService::STATE_NOT_BLOCKED;
89114:       blocklist->GetPluginBlocklistState(pluginTag, EmptyString(),
89114:                                          EmptyString(), &blockState);
89114:       if (blockState == nsIBlocklistService::STATE_OUTDATED)
89114:         FirePluginError(thisContent, ePluginOutdated);
89114:     }
89114:   }
89114: 
89114:   return NS_OK;
89114: }
89114: 
89114: void
89114: nsObjectLoadingContent::NotifyOwnerDocumentActivityChanged()
89114: {
89114:   if (!mInstanceOwner) {
89114:     return;
89114:   }
89114: 
89114:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
89114:   nsIDocument* ownerDoc = thisContent->OwnerDoc();
89114:   if (!ownerDoc->IsActive()) {
89114:     StopPluginInstance();
89114:   }
89114: }
89114: 
    1: // nsIRequestObserver
    1: NS_IMETHODIMP
13648: nsObjectLoadingContent::OnStartRequest(nsIRequest *aRequest,
13648:                                        nsISupports *aContext)
    1: {
88104:   SAMPLE_LABEL("nsObjectLoadingContent", "OnStartRequest");
89114: 
81385:   if (aRequest != mChannel || !aRequest) {
    1:     // This is a bit of an edge case - happens when a new load starts before the
    1:     // previous one got here
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
80486:   AutoNotifier notifier(this, true);
    1: 
    1:   if (!IsSuccessfulRequest(aRequest)) {
    1:     LOG(("OBJLC [%p]: OnStartRequest: Request failed\n", this));
80486:     Fallback(false);
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
    1:   NS_ASSERTION(chan, "Why is our request not a channel?");
    1: 
    1:   nsresult rv = NS_ERROR_UNEXPECTED;
    1:   // This fallback variable MUST be declared after the notifier variable. Do NOT
    1:   // change the order of the declarations!
    1:   AutoFallback fallback(this, &rv);
    1: 
 4849:   nsCString channelType;
 4849:   rv = chan->GetContentType(channelType);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 4849:   if (channelType.EqualsASCII(APPLICATION_GUESS_FROM_EXT)) {
 4849:     channelType = APPLICATION_OCTET_STREAM;
 4849:     chan->SetContentType(channelType);
 4849:   }
 4849: 
89114:   // We want to use the channel type unless one of the following is true:
13204:   //
13204:   // 1) The channel type is application/octet-stream and we have a
35425:   //    type hint and the type hint is not a document type.
13204:   // 2) Our type hint is a type that we support with a plugin.
13204:   if ((channelType.EqualsASCII(APPLICATION_OCTET_STREAM) && 
35425:        !mContentType.IsEmpty() &&
35425:        GetTypeOfContent(mContentType) != eType_Document) ||
89887:       // Need to check IsPluginEnabledForType() in addition to GetTypeOfContent()
35425:       // because otherwise the default plug-in's catch-all behavior would
35425:       // confuse things.
89887:       (NS_SUCCEEDED(IsPluginEnabledForType(mContentType)) && 
13204:        GetTypeOfContent(mContentType) == eType_Plugin)) {
 4849:     // Set the type we'll use for dispatch on the channel.  Otherwise we could
 4849:     // end up trying to dispatch to a nsFrameLoader, which will complain that
 4849:     // it couldn't find a way to handle application/octet-stream
48102:     nsCAutoString typeHint, dummy;
48102:     NS_ParseContentType(mContentType, typeHint, dummy);
48102:     if (!typeHint.IsEmpty()) {
48102:       chan->SetContentType(typeHint);
48102:     }
13204:   } else {
13204:     mContentType = channelType;
 4849:   }
 4849: 
13648:   nsCOMPtr<nsIURI> uri;
13648:   chan->GetURI(getter_AddRefs(uri));
13648: 
13648:   if (mContentType.EqualsASCII(APPLICATION_OCTET_STREAM)) {
13648:     nsCAutoString extType;
89887:     if (IsPluginEnabledByExtension(uri, extType)) {
13648:       mContentType = extType;
13648:       chan->SetContentType(extType);
13648:     }
13648:   }
13648: 
    1:   // Now find out what type the content is
    1:   // UnloadContent will set our type to null; need to be sure to only set it to
    1:   // the real value on success
    1:   ObjectType newType = GetTypeOfContent(mContentType);
    1:   LOG(("OBJLC [%p]: OnStartRequest: Content Type=<%s> Old type=%u New Type=%u\n",
    1:        this, mContentType.get(), mType, newType));
 5870: 
 5870:   // Now do a content policy check
 5870:   // XXXbz this duplicates some code in nsContentBlocker::ShouldLoad  
 5870:   PRInt32 contentPolicyType;
 5870:   switch (newType) {
 5870:     case eType_Image:
 5870:       contentPolicyType = nsIContentPolicy::TYPE_IMAGE;
 5870:       break;
 5870:     case eType_Document:
 5870:       contentPolicyType = nsIContentPolicy::TYPE_SUBDOCUMENT;
 5870:       break;
 5870:     default:
 5870:       contentPolicyType = nsIContentPolicy::TYPE_OBJECT;
 5870:       break;
 5870:   }
 5870:   nsCOMPtr<nsIContent> thisContent = 
 5870:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
 5870:   NS_ASSERTION(thisContent, "must be a content");
 5870: 
80526:   nsIDocument* doc = thisContent->OwnerDoc();
 5870: 
 5870:   PRInt16 shouldProcess = nsIContentPolicy::ACCEPT;
 5870:   rv =
 5870:     NS_CheckContentProcessPolicy(contentPolicyType,
 5870:                                  uri,
 5870:                                  doc->NodePrincipal(),
 5870:                                  static_cast<nsIImageLoadingContent*>(this),
 5870:                                  mContentType,
 5870:                                  nsnull, //extra
 5870:                                  &shouldProcess,
 5870:                                  nsContentUtils::GetContentPolicy(),
 5870:                                  nsContentUtils::GetSecurityManager());
 5870:   if (NS_FAILED(rv) || NS_CP_REJECTED(shouldProcess)) {
 5870:     HandleBeingBlockedByContentPolicy(rv, shouldProcess);
 5870:     rv = NS_OK; // otherwise, the AutoFallback will make us fall back
 5870:     return NS_BINDING_ABORTED;
 5870:   }  
 5870:   
    1:   if (mType != newType) {
    1:     UnloadContent();
    1:   }
    1: 
    1:   switch (newType) {
    1:     case eType_Image:
    1:       rv = LoadImageWithChannel(chan, getter_AddRefs(mFinalListener));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       // If we have a success result but no final listener, then the image is
    1:       // cached. In that case, we can just return: No need to try to call the
    1:       // final listener.
    1:       if (!mFinalListener) {
    1:         mType = newType;
    1:         return NS_BINDING_ABORTED;
    1:       }
    1:       break;
    1:     case eType_Document: {
    1:       if (!mFrameLoader) {
79617:         mFrameLoader = nsFrameLoader::Create(thisContent->AsElement(),
79617:                                              mNetworkCreated);
31661:         if (!mFrameLoader) {
80486:           Fallback(false);
    1:           return NS_ERROR_UNEXPECTED;
    1:         }
    1:       }
    1: 
 3556:       rv = mFrameLoader->CheckForRecursiveLoad(uri);
 3556:       if (NS_FAILED(rv)) {
80486:         Fallback(false);
 3556:         return rv;
 3556:       }
 3556: 
    1:       if (mType != newType) {
    1:         // XXX We must call this before getting the docshell to work around
    1:         // bug 300540; when that's fixed, this if statement can be removed.
    1:         mType = newType;
    1:         notifier.Notify();
33385: 
33385:         if (!mFrameLoader) {
33385:           // mFrameLoader got nulled out when we notified, which most
33385:           // likely means the node was removed from the
33385:           // document. Abort the load that just started.
33385:           return NS_BINDING_ABORTED;
33385:         }
    1:       }
    1: 
 2708:       // We're loading a document, so we have to set LOAD_DOCUMENT_URI
 2708:       // (especially important for firing onload)
 2708:       nsLoadFlags flags = 0;
 2708:       chan->GetLoadFlags(&flags);
 2708:       flags |= nsIChannel::LOAD_DOCUMENT_URI;
 2708:       chan->SetLoadFlags(flags);
 2708: 
    1:       nsCOMPtr<nsIDocShell> docShell;
    1:       rv = mFrameLoader->GetDocShell(getter_AddRefs(docShell));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(docShell));
    1:       NS_ASSERTION(req, "Docshell must be an ifreq");
    1: 
    1:       nsCOMPtr<nsIURILoader>
    1:         uriLoader(do_GetService(NS_URI_LOADER_CONTRACTID, &rv));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:       rv = uriLoader->OpenChannel(chan, nsIURILoader::DONT_RETARGET, req,
    1:                                   getter_AddRefs(mFinalListener));
    1:       break;
    1:     }
89114:     case eType_Plugin: {
89647:       if (mType != newType) {
89647:         mType = newType;
89647:         notifier.Notify();
89647:       }
89114:       nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
89114:       nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
89114:       if (!pluginHost) {
89114:         return NS_ERROR_NOT_AVAILABLE;
77476:       }
91089:       pluginHost->CreateListenerForChannel(chan, this, getter_AddRefs(mFinalListener));
89114:       break;
77476:     }
    1:     case eType_Loading:
    1:       NS_NOTREACHED("Should not have a loading type here!");
    1:     case eType_Null:
    1:       // Need to fallback here (instead of using the case below), so that we can
37151:       // set mFallbackReason without it being overwritten. This is also why we
    1:       // return early.
80486:       Fallback(false);
    1: 
    1:       PluginSupportState pluginState = GetPluginSupportState(thisContent,
    1:                                                              mContentType);
    1:       // Do nothing, but fire the plugin not found event if needed
19014:       if (pluginState != ePluginOtherState) {
37151:         mFallbackReason = pluginState;
19014:         FirePluginError(thisContent, pluginState);
    1:       }
    1:       return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   if (mFinalListener) {
    1:     mType = newType;
91099: 
91089:     mSrcStreamLoading = true;
    1:     rv = mFinalListener->OnStartRequest(aRequest, aContext);
91089:     mSrcStreamLoading = false;
91099: 
91099:     if (NS_SUCCEEDED(rv)) {
91099:       // Plugins need to set up for NPRuntime.
91099:       if (mType == eType_Plugin) {
91099:         NotifyContentObjectWrapper();
91099:       }
91099:     } else {
91099:       // Plugins don't fall back if there is an error here.
91099:       if (mType == eType_Plugin) {
91099:         rv = NS_OK; // this is necessary to avoid auto-fallback
 4178:         return NS_BINDING_ABORTED;
 4178:       }
80486:       Fallback(false);
    1:     }
91099: 
    1:     return rv;
    1:   }
    1: 
80486:   Fallback(false);
    1:   return NS_BINDING_ABORTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::OnStopRequest(nsIRequest *aRequest,
    1:                                       nsISupports *aContext,
    1:                                       nsresult aStatusCode)
    1: {
81385:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
81385: 
    1:   if (aRequest != mChannel) {
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   mChannel = nsnull;
    1: 
    1:   if (mFinalListener) {
    1:     mFinalListener->OnStopRequest(aRequest, aContext, aStatusCode);
    1:     mFinalListener = nsnull;
    1:   }
    1: 
    1:   // Return value doesn't matter
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsIStreamListener
    1: NS_IMETHODIMP
81385: nsObjectLoadingContent::OnDataAvailable(nsIRequest *aRequest,
81385:                                         nsISupports *aContext,
81385:                                         nsIInputStream *aInputStream,
81385:                                         PRUint32 aOffset, PRUint32 aCount)
    1: {
81385:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
81385: 
    1:   if (aRequest != mChannel) {
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   if (mFinalListener) {
    1:     return mFinalListener->OnDataAvailable(aRequest, aContext, aInputStream, aOffset, aCount);
    1:   }
    1: 
    1:   // Abort this load if we have no listener here
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: // nsIFrameLoaderOwner
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetFrameLoader(nsIFrameLoader** aFrameLoader)
    1: {
    1:   *aFrameLoader = mFrameLoader;
    1:   NS_IF_ADDREF(*aFrameLoader);
    1:   return NS_OK;
    1: }
    1: 
34076: NS_IMETHODIMP_(already_AddRefed<nsFrameLoader>)
34076: nsObjectLoadingContent::GetFrameLoader()
34076: {
34076:   nsFrameLoader* loader = mFrameLoader;
34076:   NS_IF_ADDREF(loader);
34076:   return loader;
34076: }
34076: 
16549: NS_IMETHODIMP
16549: nsObjectLoadingContent::SwapFrameLoaders(nsIFrameLoaderOwner* aOtherLoader)
16549: {
16549:   return NS_ERROR_NOT_IMPLEMENTED;
16549: }
16549: 
    1: // nsIObjectLoadingContent
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetActualType(nsACString& aType)
    1: {
    1:   aType = mContentType;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetDisplayedType(PRUint32* aType)
    1: {
    1:   *aType = mType;
    1:   return NS_OK;
    1: }
    1: 
77476: NS_IMETHODIMP
89114: nsObjectLoadingContent::HasNewFrame(nsIObjectFrame* aFrame)
77476: {
89114:   // Not having an instance yet is OK, but try to start one now that
89114:   // we have a frame.
89114:   if (!mInstanceOwner) {
89114:     AsyncStartPluginInstance();
77476:     return NS_OK;
77476:   }
77476: 
89114:   // Disconnect any existing frame
89114:   DisconnectFrame();
77476: 
89114:   // Set up relationship between instance owner and frame.
89114:   nsObjectFrame *objFrame = static_cast<nsObjectFrame*>(aFrame);
89114:   mInstanceOwner->SetFrame(objFrame);
77476: 
89114:   // Set up new frame to draw.
89114:   objFrame->FixupWindow(objFrame->GetContentRectRelativeToSelf().Size());
89114:   objFrame->Invalidate(objFrame->GetContentRectRelativeToSelf());
15571: 
15571:   return NS_OK;
15571: }
15571: 
89114: NS_IMETHODIMP
89114: nsObjectLoadingContent::DisconnectFrame()
89114: {
89114:   if (mInstanceOwner) {
89114:     mInstanceOwner->SetFrame(nsnull);
77476:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
70007: nsObjectLoadingContent::GetPluginInstance(nsNPAPIPluginInstance** aInstance)
13098: {
13098:   *aInstance = nsnull;
13098: 
89114:   if (!mInstanceOwner) {
13098:     return NS_OK;
13098:   }
13098: 
89114:   return mInstanceOwner->GetInstance(aInstance);
13098: }
13098: 
13098: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetContentTypeForMIMEType(const nsACString& aMIMEType,
    1:                                                   PRUint32* aType)
    1: {
    1:   *aType = GetTypeOfContent(PromiseFlatCString(aMIMEType));
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIInterfaceRequestor
    1: NS_IMETHODIMP
    1: nsObjectLoadingContent::GetInterface(const nsIID & aIID, void **aResult)
    1: {
    1:   if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
    1:     nsIChannelEventSink* sink = this;
    1:     *aResult = sink;
    1:     NS_ADDREF(sink);
    1:     return NS_OK;
    1:   }
    1:   return NS_NOINTERFACE;
    1: }
    1: 
    1: // nsIChannelEventSink
    1: NS_IMETHODIMP
48889: nsObjectLoadingContent::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
    1:                                                nsIChannel *aNewChannel,
48889:                                                PRUint32 aFlags,
48889:                                                nsIAsyncVerifyRedirectCallback *cb)
    1: {
63181:   // If we're already busy with a new load, or have no load at all,
63181:   // cancel the redirect.
63181:   if (!mChannel || aOldChannel != mChannel) {
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   mChannel = aNewChannel;
48889:   cb->OnRedirectVerifyCallback(NS_OK);
    1:   return NS_OK;
    1: }
    1: 
    1: // <public>
56168: nsEventStates
    1: nsObjectLoadingContent::ObjectState() const
    1: {
    1:   switch (mType) {
    1:     case eType_Loading:
    1:       return NS_EVENT_STATE_LOADING;
    1:     case eType_Image:
    1:       return ImageState();
    1:     case eType_Plugin:
    1:     case eType_Document:
    1:       // These are OK. If documents start to load successfully, they display
    1:       // something, and are thus not broken in this sense. The same goes for
    1:       // plugins.
56168:       return nsEventStates();
    1:     case eType_Null:
    1:       if (mSuppressed)
    1:         return NS_EVENT_STATE_SUPPRESSED;
    1:       if (mUserDisabled)
    1:         return NS_EVENT_STATE_USERDISABLED;
    1: 
    1:       // Otherwise, broken
56168:       nsEventStates state = NS_EVENT_STATE_BROKEN;
37151:       switch (mFallbackReason) {
80300:         case ePluginClickToPlay:
80300:           return NS_EVENT_STATE_TYPE_CLICK_TO_PLAY;
19014:         case ePluginDisabled:
19014:           state |= NS_EVENT_STATE_HANDLER_DISABLED;
19014:           break;
19014:         case ePluginBlocklisted:
19014:           state |= NS_EVENT_STATE_HANDLER_BLOCKED;
19014:           break;
38025:         case ePluginCrashed:
38025:           state |= NS_EVENT_STATE_HANDLER_CRASHED;
38025:           break;
19014:         case ePluginUnsupported:
    1:           state |= NS_EVENT_STATE_TYPE_UNSUPPORTED;
19014:           break;
68468:         case ePluginOutdated:
68468:         case ePluginOtherState:
68468:           // Do nothing, but avoid a compile warning
68468:           break;
    1:       }
    1:       return state;
    1:   };
    1:   NS_NOTREACHED("unknown type?");
    1:   // this return statement only exists to avoid a compile warning
56168:   return nsEventStates();
    1: }
    1: 
    1: // <protected>
    1: nsresult
    1: nsObjectLoadingContent::LoadObject(const nsAString& aURI,
79445:                                    bool aNotify,
    1:                                    const nsCString& aTypeHint,
79445:                                    bool aForceLoad)
    1: {
    1:   LOG(("OBJLC [%p]: Loading object: URI string=<%s> notify=%i type=<%s> forceload=%i\n",
    1:        this, NS_ConvertUTF16toUTF8(aURI).get(), aNotify, aTypeHint.get(), aForceLoad));
    1: 
    1:   // Avoid StringToURI in order to use the codebase attribute as base URI
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
80526:   nsIDocument* doc = thisContent->OwnerDoc();
    1:   nsCOMPtr<nsIURI> baseURI;
92488:   GetObjectBaseURI(thisContent, getter_AddRefs(baseURI));
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(uri),
    1:                                             aURI, doc,
    1:                                             baseURI);
    1:   // If URI creation failed, fallback immediately - this only happens for
    1:   // malformed URIs
    1:   if (!uri) {
    1:     Fallback(aNotify);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_TryToSetImmutable(uri);
    1: 
    1:   return LoadObject(uri, aNotify, aTypeHint, aForceLoad);
    1: }
    1: 
12297: void
12297: nsObjectLoadingContent::UpdateFallbackState(nsIContent* aContent,
12297:                                             AutoFallback& fallback,
12297:                                             const nsCString& aTypeHint)
12297: {
19014:   // Notify the UI and update the fallback state
19014:   PluginSupportState state = GetPluginSupportState(aContent, aTypeHint);
19014:   if (state != ePluginOtherState) {
19014:     fallback.SetPluginState(state);
19014:     FirePluginError(aContent, state);
12297:   }
12297: }
12297: 
    1: nsresult
    1: nsObjectLoadingContent::LoadObject(nsIURI* aURI,
79445:                                    bool aNotify,
    1:                                    const nsCString& aTypeHint,
79445:                                    bool aForceLoad)
    1: {
89114:   // Only do a URI equality check for things that aren't stopped plugins.
89114:   // This is because we still need to load again if the plugin has been stopped.
89114:   if (mType == eType_Document || mType == eType_Image || mInstanceOwner) {
92359:     if (mURI && aURI) {
79445:       bool equal;
    1:       nsresult rv = mURI->Equals(aURI, &equal);
92359:       if (NS_SUCCEEDED(rv) && equal && !aForceLoad) {
    1:         // URI didn't change, do nothing
    1:         return NS_OK;
    1:       }
92359:       StopPluginInstance();
    1:     }
89114:   }
    1: 
    1:   // Need to revoke any potentially pending instantiate events
    1:   if (mType == eType_Plugin && mPendingInstantiateEvent) {
    1:     mPendingInstantiateEvent = nsnull;
    1:   }
    1: 
    1:   AutoNotifier notifier(this, aNotify);
    1: 
80486:   mUserDisabled = mSuppressed = false;
    1: 
    1:   mURI = aURI;
    1:   mContentType = aTypeHint;
    1: 
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
80526:   nsIDocument* doc = thisContent->OwnerDoc();
80527:   if (doc->IsBeingUsedAsImage()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // From here on, we will always change the content. This means that a
    1:   // possibly-loading channel should be aborted.
    1:   if (mChannel) {
    1:     LOG(("OBJLC [%p]: Cancelling existing load\n", this));
12968: 
    1:     // These three statements are carefully ordered:
    1:     // - onStopRequest should get a channel whose status is the same as the
    1:     //   status argument
    1:     // - onStopRequest must get a non-null channel
    1:     mChannel->Cancel(NS_BINDING_ABORTED);
    1:     if (mFinalListener) {
    1:       // NOTE: Since mFinalListener is only set in onStartRequest, which takes
    1:       // care of calling mFinalListener->OnStartRequest, mFinalListener is only
    1:       // non-null here if onStartRequest was already called.
    1:       mFinalListener->OnStopRequest(mChannel, nsnull, NS_BINDING_ABORTED);
    1:       mFinalListener = nsnull;
    1:     }
    1:     mChannel = nsnull;
    1:   }
    1: 
    1:   // Security checks
 4064:   if (doc->IsLoadedAsData()) {
35581:     if (!doc->IsStaticDocument()) {
80486:       Fallback(false);
35581:     }
 4064:     return NS_OK;
 4064:   }
 4064: 
    1:   // Can't do security checks without a URI - hopefully the plugin will take
    1:   // care of that
    1:   // Null URIs happen when the URL to load is specified via other means than the
    1:   // data/src attribute, for example via custom <param> elements.
    1:   if (aURI) {
    1:     nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
    1:     NS_ASSERTION(secMan, "No security manager!?");
    1:     nsresult rv =
    1:       secMan->CheckLoadURIWithPrincipal(thisContent->NodePrincipal(), aURI, 0);
    1:     if (NS_FAILED(rv)) {
80486:       Fallback(false);
    1:       return NS_OK;
    1:     }
    1: 
    1:     PRInt16 shouldLoad = nsIContentPolicy::ACCEPT; // default permit
    1:     rv =
    1:       NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT,
    1:                                 aURI,
 4367:                                 doc->NodePrincipal(),
 3233:                                 static_cast<nsIImageLoadingContent*>(this),
    1:                                 aTypeHint,
    1:                                 nsnull, //extra
    1:                                 &shouldLoad,
 4367:                                 nsContentUtils::GetContentPolicy(),
 5870:                                 secMan);
    1:     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
 5870:       HandleBeingBlockedByContentPolicy(rv, shouldLoad);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   nsresult rv = NS_ERROR_UNEXPECTED;
    1:   // This fallback variable MUST be declared after the notifier variable. Do NOT
    1:   // change the order of the declarations!
    1:   AutoFallback fallback(this, &rv);
    1: 
    1:   PRUint32 caps = GetCapabilities();
    1:   LOG(("OBJLC [%p]: Capabilities: %04x\n", this, caps));
    1: 
 3642:   nsCAutoString overrideType;
 3642:   if ((caps & eOverrideServerType) &&
89887:       ((!aTypeHint.IsEmpty() && NS_SUCCEEDED(IsPluginEnabledForType(aTypeHint))) ||
89887:        (aURI && IsPluginEnabledByExtension(aURI, overrideType)))) {
 3642:     ObjectType newType;
 3642:     if (overrideType.IsEmpty()) {
 3642:       newType = GetTypeOfContent(aTypeHint);
 3642:     } else {
 4329:       mContentType = overrideType;
 3642:       newType = eType_Plugin;
 3642:     }
 3642: 
    1:     if (newType != mType) {
    1:       LOG(("OBJLC [%p]: (eOverrideServerType) Changing type from %u to %u\n", this, mType, newType));
    1: 
    1:       UnloadContent();
    1: 
    1:       // Must have a frameloader before creating a frame, or the frame will
    1:       // create its own.
    1:       if (!mFrameLoader && newType == eType_Document) {
79617:         mFrameLoader = nsFrameLoader::Create(thisContent->AsElement(),
79617:                                              mNetworkCreated);
31661:         if (!mFrameLoader) {
    1:           mURI = nsnull;
    1:           return NS_OK;
    1:         }
    1:       }
    1: 
    1:       // Must notify here for plugins
    1:       // If aNotify is false, we'll just wait until we get a frame and use the
    1:       // async instantiate path.
 4329:       // XXX is this still needed? (for documents?)
    1:       mType = newType;
    1:       if (aNotify)
    1:         notifier.Notify();
    1:     }
    1:     switch (newType) {
    1:       case eType_Image:
    1:         // Don't notify, because we will take care of that ourselves.
 7660:         if (aURI) {
80486:           rv = LoadImage(aURI, aForceLoad, false);
 7660:         } else {
 7660:           rv = NS_ERROR_NOT_AVAILABLE;
 7660:         }
    1:         break;
    1:       case eType_Plugin:
89114:         rv = AsyncStartPluginInstance();
    1:         break;
    1:       case eType_Document:
 7660:         if (aURI) {
    1:           rv = mFrameLoader->LoadURI(aURI);
 7660:         } else {
 7660:           rv = NS_ERROR_NOT_AVAILABLE;
 7660:         }
    1:         break;
    1:       case eType_Loading:
    1:         NS_NOTREACHED("Should not have a loading type here!");
    1:       case eType_Null:
12297:         // No need to load anything, notify of the failure.
12297:         UpdateFallbackState(thisContent, fallback, aTypeHint);
    1:         break;
    1:     };
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If the class ID specifies a supported plugin, or if we have no explicit URI
    1:   // but a type, immediately instantiate the plugin.
79445:   bool isSupportedClassID = false;
80486:   nsCAutoString typeForID; // Will be set iff isSupportedClassID == true
79445:   bool hasID = false;
    1:   if (caps & eSupportClassID) {
    1:     nsAutoString classid;
    1:     thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::classid, classid);
    1:     if (!classid.IsEmpty()) {
80486:       hasID = true;
    1:       isSupportedClassID = NS_SUCCEEDED(TypeForClassID(classid, typeForID));
    1:     }
    1:   }
    1: 
    1:   if (hasID && !isSupportedClassID) {
    1:     // We have a class ID and it's unsupported.  Fallback in that case.
    1:     rv = NS_ERROR_NOT_AVAILABLE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (isSupportedClassID ||
    1:       (!aURI && !aTypeHint.IsEmpty() &&
    1:        GetTypeOfContent(aTypeHint) == eType_Plugin)) {
    1:     // No URI, but we have a type. The plugin will handle the load.
    1:     // Or: supported class id, plugin will handle the load.
    1:     mType = eType_Plugin;
    1: 
    1:     // At this point, the stored content type
    1:     // must be equal to our type hint. Similar,
    1:     // our URI must be the requested URI.
    1:     // (->Equals would suffice, but == is cheaper
    1:     // and handles NULL)
    1:     NS_ASSERTION(mContentType.Equals(aTypeHint), "mContentType wrong!");
    1:     NS_ASSERTION(mURI == aURI, "mURI wrong!");
    1: 
    1:     if (isSupportedClassID) {
    1:       // Use the classid's type
    1:       NS_ASSERTION(!typeForID.IsEmpty(), "Must have a real type!");
    1:       mContentType = typeForID;
    1:       // XXX(biesi). The plugin instantiation code used to pass the base URI
    1:       // here instead of the plugin URI for instantiation via class ID, so I
    1:       // continue to do so. Why that is, no idea...
92488:       GetObjectBaseURI(thisContent, getter_AddRefs(mURI));
    1:       if (!mURI) {
    1:         mURI = aURI;
    1:       }
    1:     }
    1: 
89114:     // rv is references by a stack-based object, need to assign here
89114:     rv = AsyncStartPluginInstance();
89114: 
89114:     return rv;
    1:   }
    1: 
    1:   if (!aURI) {
12297:     // No URI and if we have got this far no enabled plugin supports the type
    1:     rv = NS_ERROR_NOT_AVAILABLE;
12297: 
12297:     // We should only notify the UI if there is at least a type to go on for
14391:     // finding a plugin to use, unless it's a supported image or document type.
14391:     if (!aTypeHint.IsEmpty() && GetTypeOfContent(aTypeHint) == eType_Null) {
12297:       UpdateFallbackState(thisContent, fallback, aTypeHint);
12297:     }
12297: 
    1:     return NS_OK;
    1:   }
    1: 
12297:   // E.g. mms://
    1:   if (!CanHandleURI(aURI)) {
 4315:     if (aTypeHint.IsEmpty()) {
 4315:       rv = NS_ERROR_NOT_AVAILABLE;
 4315:       return NS_OK;
 4315:     }
12297: 
89887:     if (NS_SUCCEEDED(IsPluginEnabledForType(aTypeHint))) {
    1:       mType = eType_Plugin;
12297:     } else {
12297:       rv = NS_ERROR_NOT_AVAILABLE;
12297:       // No plugin to load, notify of the failure.
12297:       UpdateFallbackState(thisContent, fallback, aTypeHint);
12297:     }
12297: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsILoadGroup> group = doc->GetDocumentLoadGroup();
    1:   nsCOMPtr<nsIChannel> chan;
41208:   nsCOMPtr<nsIChannelPolicy> channelPolicy;
41208:   nsCOMPtr<nsIContentSecurityPolicy> csp;
41208:   rv = doc->NodePrincipal()->GetCsp(getter_AddRefs(csp));
41208:   NS_ENSURE_SUCCESS(rv, rv);
41208:   if (csp) {
41208:     channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
41208:     channelPolicy->SetContentSecurityPolicy(csp);
41208:     channelPolicy->SetLoadType(nsIContentPolicy::TYPE_OBJECT);
41208:   }
 4849:   rv = NS_NewChannel(getter_AddRefs(chan), aURI, nsnull, group, this,
42552:                      nsIChannel::LOAD_CALL_CONTENT_SNIFFERS |
42552:                      nsIChannel::LOAD_CLASSIFY_URI,
41208:                      channelPolicy);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Referrer
    1:   nsCOMPtr<nsIHttpChannel> httpChan(do_QueryInterface(chan));
    1:   if (httpChan) {
    1:     httpChan->SetReferrer(doc->GetDocumentURI());
    1:   }
    1: 
    1:   // MIME Type hint
    1:   if (!aTypeHint.IsEmpty()) {
48102:     nsCAutoString typeHint, dummy;
48102:     NS_ParseContentType(aTypeHint, typeHint, dummy);
48102:     if (!typeHint.IsEmpty()) {
48102:       chan->SetContentType(typeHint);
48102:     }
    1:   }
    1: 
 8608:   // Set up the channel's principal and such, like nsDocShell::DoURILoad does
78531:   nsContentUtils::SetUpChannelOwner(thisContent->NodePrincipal(),
80486:                                     chan, aURI, true);
 8608: 
 8608:   nsCOMPtr<nsIScriptChannel> scriptChannel = do_QueryInterface(chan);
 8608:   if (scriptChannel) {
 8608:     // Allow execution against our context if the principals match
 8608:     scriptChannel->
 8608:       SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
 8608:   }
 8608: 
    1:   // AsyncOpen can fail if a file does not exist.
    1:   // Show fallback content in that case.
    1:   rv = chan->AsyncOpen(this, nsnull);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     LOG(("OBJLC [%p]: Channel opened.\n", this));
12968: 
    1:     mChannel = chan;
    1:     mType = eType_Loading;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: PRUint32
    1: nsObjectLoadingContent::GetCapabilities() const
    1: {
    1:   return eSupportImages |
    1:          eSupportPlugins |
71013:          eSupportDocuments |
71013:          eSupportSVG;
    1: }
    1: 
    1: void
79445: nsObjectLoadingContent::Fallback(bool aNotify)
    1: {
    1:   AutoNotifier notifier(this, aNotify);
    1: 
    1:   UnloadContent();
    1: }
    1: 
    1: void
    1: nsObjectLoadingContent::RemovedFromDocument()
    1: {
    1:   if (mFrameLoader) {
    1:     // XXX This is very temporary and must go away
    1:     mFrameLoader->Destroy();
    1:     mFrameLoader = nsnull;
    1: 
    1:     // Clear the current URI, so that LoadObject doesn't think that we
    1:     // have already loaded the content.
    1:     mURI = nsnull;
    1:   }
89114: 
89114:   // When a plugin instance node is removed from the document we'll
89114:   // let the plugin continue to run at least until we get back to
89114:   // the event loop. If we get back to the event loop and the node
89114:   // has still not been added back to the document then we stop
89114:   // the plugin.
89114:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
89114:   nsCOMPtr<nsIRunnable> event = new InDocCheckEvent(thisContent);
89114: 
89114:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
89114:   if (appShell) {
89114:     appShell->RunInStableState(event);
89114:   }
    1: }
    1: 
77323: /* static */
    1: void
77323: nsObjectLoadingContent::Traverse(nsObjectLoadingContent *tmp,
77323:                                  nsCycleCollectionTraversalCallback &cb)
    1: {
77323:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mFrameLoader");
77323:   cb.NoteXPCOMChild(static_cast<nsIFrameLoader*>(tmp->mFrameLoader));
    1: }
    1: 
    1: // <private>
79445: /* static */ bool
    1: nsObjectLoadingContent::IsSuccessfulRequest(nsIRequest* aRequest)
    1: {
    1:   nsresult status;
    1:   nsresult rv = aRequest->GetStatus(&status);
    1:   if (NS_FAILED(rv) || NS_FAILED(status)) {
80486:     return false;
    1:   }
    1: 
    1:   // This may still be an error page or somesuch
    1:   nsCOMPtr<nsIHttpChannel> httpChan(do_QueryInterface(aRequest));
    1:   if (httpChan) {
79445:     bool success;
    1:     rv = httpChan->GetRequestSucceeded(&success);
    1:     if (NS_FAILED(rv) || !success) {
80486:       return false;
    1:     }
    1:   }
    1: 
    1:   // Otherwise, the request is successful
80486:   return true;
    1: }
    1: 
79445: /* static */ bool
    1: nsObjectLoadingContent::CanHandleURI(nsIURI* aURI)
    1: {
    1:   nsCAutoString scheme;
    1:   if (NS_FAILED(aURI->GetScheme(scheme))) {
80486:     return false;
    1:   }
    1: 
    1:   nsIIOService* ios = nsContentUtils::GetIOService();
    1:   if (!ios)
80486:     return false;
    1:   
    1:   nsCOMPtr<nsIProtocolHandler> handler;
    1:   ios->GetProtocolHandler(scheme.get(), getter_AddRefs(handler));
    1:   if (!handler) {
80486:     return false;
    1:   }
    1:   
    1:   nsCOMPtr<nsIExternalProtocolHandler> extHandler =
    1:     do_QueryInterface(handler);
    1:   // We can handle this URI if its protocol handler is not the external one
    1:   return extHandler == nsnull;
    1: }
    1: 
79445: bool
    1: nsObjectLoadingContent::IsSupportedDocument(const nsCString& aMimeType)
    1: {
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIWebNavigationInfo> info(
    1:     do_GetService(NS_WEBNAVIGATION_INFO_CONTRACTID, &rv));
    1:   PRUint32 supported;
    1:   if (info) {
    1:     nsCOMPtr<nsIWebNavigation> webNav;
    1:     nsIDocument* currentDoc = thisContent->GetCurrentDoc();
    1:     if (currentDoc) {
    1:       webNav = do_GetInterface(currentDoc->GetScriptGlobalObject());
    1:     }
    1:     rv = info->IsTypeSupported(aMimeType, webNav, &supported);
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     if (supported == nsIWebNavigationInfo::UNSUPPORTED) {
    1:       // Try a stream converter
    1:       // NOTE: We treat any type we can convert from as a supported type. If a
    1:       // type is not actually supported, the URI loader will detect that and
    1:       // return an error, and we'll fallback.
    1:       nsCOMPtr<nsIStreamConverterService> convServ =
    1:         do_GetService("@mozilla.org/streamConverters;1");
79445:       bool canConvert = false;
    1:       if (convServ) {
    1:         rv = convServ->CanConvert(aMimeType.get(), "*/*", &canConvert);
    1:       }
    1: 
    1:       return NS_SUCCEEDED(rv) && canConvert;
    1:     }
    1: 
    1:     // Don't want to support plugins as documents
    1:     return supported != nsIWebNavigationInfo::PLUGIN;
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: void
    1: nsObjectLoadingContent::UnloadContent()
    1: {
    1:   // Don't notify in CancelImageRequests. We do it ourselves.
80486:   CancelImageRequests(false);
    1:   if (mFrameLoader) {
    1:     mFrameLoader->Destroy();
    1:     mFrameLoader = nsnull;
    1:   }
    1:   mType = eType_Null;
80486:   mUserDisabled = mSuppressed = false;
37151:   mFallbackReason = ePluginOtherState;
    1: }
    1: 
    1: void
    1: nsObjectLoadingContent::NotifyStateChanged(ObjectType aOldType,
71121:                                            nsEventStates aOldState,
79445:                                            bool aSync,
79445:                                            bool aNotify)
    1: {
56291:   LOG(("OBJLC [%p]: Notifying about state change: (%u, %llx) -> (%u, %llx) (sync=%i)\n",
56168:        this, aOldType, aOldState.GetInternalValue(), mType,
56168:        ObjectState().GetInternalValue(), aSync));
    1: 
    1:   nsCOMPtr<nsIContent> thisContent = 
 3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
    1:   NS_ASSERTION(thisContent, "must be a content");
    1: 
71121:   NS_ASSERTION(thisContent->IsElement(), "Not an element?");
71121: 
71121:   // Unfortunately, we do some state changes without notifying
71121:   // (e.g. in Fallback when canceling image requests), so we have to
71121:   // manually notify object state changes.
71121:   thisContent->AsElement()->UpdateState(false);
71121: 
71121:   if (!aNotify) {
71121:     // We're done here
71121:     return;
71121:   }
71121: 
    1:   nsIDocument* doc = thisContent->GetCurrentDoc();
    1:   if (!doc) {
    1:     return; // Nothing to do
    1:   }
    1: 
56168:   nsEventStates newState = ObjectState();
    1: 
    1:   if (newState != aOldState) {
    1:     // This will trigger frame construction
    1:     NS_ASSERTION(thisContent->IsInDoc(), "Something is confused");
56168:     nsEventStates changedBits = aOldState ^ newState;
    1: 
    1:     {
71103:       nsAutoScriptBlocker scriptBlocker;
64120:       doc->ContentStateChanged(thisContent, changedBits);
    1:     }
    1:     if (aSync) {
71121:       // Make sure that frames are actually constructed immediately.
    1:       doc->FlushPendingNotifications(Flush_Frames);
    1:     }
    1:   } else if (aOldType != mType) {
    1:     // If our state changed, then we already recreated frames
    1:     // Otherwise, need to do that here
46225:     nsCOMPtr<nsIPresShell> shell = doc->GetShell();
36917:     if (shell) {
    1:       shell->RecreateFramesFor(thisContent);
    1:     }
    1:   }
    1: }
    1: 
    1: /* static */ void
 3464: nsObjectLoadingContent::FirePluginError(nsIContent* thisContent,
19014:                                         PluginSupportState state)
    1: {
 3464:   LOG(("OBJLC []: Dispatching nsPluginErrorEvent for content %p\n",
    1:        thisContent));
    1: 
19014:   nsCOMPtr<nsIRunnable> ev = new nsPluginErrorEvent(thisContent, state);
    1:   nsresult rv = NS_DispatchToCurrentThread(ev);
    1:   if (NS_FAILED(rv)) {
 3464:     NS_WARNING("failed to dispatch nsPluginErrorEvent");
    1:   }
    1: }
    1: 
    1: nsObjectLoadingContent::ObjectType
    1: nsObjectLoadingContent::GetTypeOfContent(const nsCString& aMIMEType)
    1: {
    1:   PRUint32 caps = GetCapabilities();
    1: 
    1:   if ((caps & eSupportImages) && IsSupportedImage(aMIMEType)) {
    1:     return eType_Image;
    1:   }
    1: 
79445:   bool isSVG = aMIMEType.LowerCaseEqualsLiteral("image/svg+xml");
79445:   bool supportedSVG = isSVG && (caps & eSupportSVG);
    1:   if (((caps & eSupportDocuments) || supportedSVG) &&
    1:       IsSupportedDocument(aMIMEType)) {
    1:     return eType_Document;
    1:   }
    1: 
89887:   if ((caps & eSupportPlugins) && NS_SUCCEEDED(IsPluginEnabledForType(aMIMEType))) {
    1:     return eType_Plugin;
    1:   }
    1: 
    1:   return eType_Null;
    1: }
    1: 
    1: nsresult
    1: nsObjectLoadingContent::TypeForClassID(const nsAString& aClassID,
    1:                                        nsACString& aType)
    1: {
    1:   if (StringBeginsWith(aClassID, NS_LITERAL_STRING("java:"))) {
    1:     // Supported if we have a java plugin
    1:     aType.AssignLiteral("application/x-java-vm");
89887:     nsresult rv = IsPluginEnabledForType(NS_LITERAL_CSTRING("application/x-java-vm"));
    1:     return NS_SUCCEEDED(rv) ? NS_OK : NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   // If it starts with "clsid:", this is ActiveX content
62136:   if (StringBeginsWith(aClassID, NS_LITERAL_STRING("clsid:"), nsCaseInsensitiveStringComparator())) {
    1:     // Check if we have a plugin for that
    1: 
89887:     if (NS_SUCCEEDED(IsPluginEnabledForType(NS_LITERAL_CSTRING("application/x-oleobject")))) {
    1:       aType.AssignLiteral("application/x-oleobject");
    1:       return NS_OK;
    1:     }
89887:     if (NS_SUCCEEDED(IsPluginEnabledForType(NS_LITERAL_CSTRING("application/oleobject")))) {
    1:       aType.AssignLiteral("application/oleobject");
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
92488: void
92488: nsObjectLoadingContent::GetObjectBaseURI(nsIContent* thisContent, nsIURI** aURI)
    1: {
92488:   // We want to use swap(); since this is just called from this file,
92488:   // we can assert this (callers use comptrs)
92488:   NS_PRECONDITION(*aURI == nsnull, "URI must be inited to zero");
    1: 
    1:   // For plugins, the codebase attribute is the base URI
    1:   nsCOMPtr<nsIURI> baseURI = thisContent->GetBaseURI();
    1:   nsAutoString codebase;
    1:   thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::codebase,
    1:                        codebase);
91451:   if (!codebase.IsEmpty()) {
92488:     nsContentUtils::NewURIWithDocumentCharset(aURI, codebase,
80526:                                               thisContent->OwnerDoc(),
    1:                                               baseURI);
92488:   } else {
92488:     baseURI.swap(*aURI);
91451:   }
    1: }
    1: 
89114: nsObjectFrame*
89114: nsObjectLoadingContent::GetExistingFrame()
    1: {
89114:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
89114:   nsIFrame* frame = thisContent->GetPrimaryFrame();
23554:   nsIObjectFrame* objFrame = do_QueryFrame(frame);
89114:   return static_cast<nsObjectFrame*>(objFrame);
    1: }
    1: 
 5870: void
 5870: nsObjectLoadingContent::HandleBeingBlockedByContentPolicy(nsresult aStatus,
 5870:                                                           PRInt16 aRetval)
 5870: {
 5870:   // Must call UnloadContent first, as it overwrites
 5870:   // mSuppressed/mUserDisabled. It also takes care of setting the type to
 5870:   // eType_Null.
 5870:   UnloadContent();
 5870:   if (NS_SUCCEEDED(aStatus)) {
 5870:     if (aRetval == nsIContentPolicy::REJECT_TYPE) {
80486:       mUserDisabled = true;
 5870:     } else if (aRetval == nsIContentPolicy::REJECT_SERVER) {
80486:       mSuppressed = true;
 5870:     }
 5870:   }
 5870: }
 5870: 
89887: PluginSupportState
    1: nsObjectLoadingContent::GetPluginSupportState(nsIContent* aContent,
    1:                                               const nsCString& aContentType)
    1: {
33329:   if (!aContent->IsHTML()) {
    1:     return ePluginOtherState;
    1:   }
    1: 
    1:   if (aContent->Tag() == nsGkAtoms::embed ||
    1:       aContent->Tag() == nsGkAtoms::applet) {
    1:     return GetPluginDisabledState(aContentType);
    1:   }
    1: 
79445:   bool hasAlternateContent = false;
13583: 
    1:   // Search for a child <param> with a pluginurl name
78992:   for (nsIContent* child = aContent->GetFirstChild();
78992:        child;
78992:        child = child->GetNextSibling()) {
78992:     if (child->IsHTML(nsGkAtoms::param)) {
13583:       if (child->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
    1:                              NS_LITERAL_STRING("pluginurl"), eIgnoreCase)) {
    1:         return GetPluginDisabledState(aContentType);
    1:       }
13583:     } else if (!hasAlternateContent) {
13583:       hasAlternateContent =
80486:         nsStyleUtil::IsSignificantChild(child, true, false);
    1:     }
13583:   }
13583: 
13583:   return hasAlternateContent ? ePluginOtherState :
13583:     GetPluginDisabledState(aContentType);
    1: }
    1: 
89887: PluginSupportState
    1: nsObjectLoadingContent::GetPluginDisabledState(const nsCString& aContentType)
    1: {
89887:   nsresult rv = IsPluginEnabledForType(aContentType);
 3464:   if (rv == NS_ERROR_PLUGIN_DISABLED)
 3464:     return ePluginDisabled;
84557:   if (rv == NS_ERROR_PLUGIN_CLICKTOPLAY)
84557:     return ePluginClickToPlay;
 3464:   if (rv == NS_ERROR_PLUGIN_BLOCKLISTED)
 3464:     return ePluginBlocklisted;
 3464:   return ePluginUnsupported;
    1: }
35171: 
35581: void
35581: nsObjectLoadingContent::CreateStaticClone(nsObjectLoadingContent* aDest) const
35581: {
35581:   nsImageLoadingContent::CreateStaticImageClone(aDest);
35581: 
35581:   aDest->mType = mType;
35581:   nsObjectLoadingContent* thisObj = const_cast<nsObjectLoadingContent*>(this);
35581:   if (thisObj->mPrintFrame.IsAlive()) {
35581:     aDest->mPrintFrame = thisObj->mPrintFrame;
35581:   } else {
89114:     aDest->mPrintFrame = const_cast<nsObjectLoadingContent*>(this)->GetExistingFrame();
35581:   }
35581: 
35581:   if (mFrameLoader) {
35581:     nsCOMPtr<nsIContent> content =
79617:       do_QueryInterface(static_cast<nsIImageLoadingContent*>(aDest));
80486:     nsFrameLoader* fl = nsFrameLoader::Create(content->AsElement(), false);
35581:     if (fl) {
35581:       aDest->mFrameLoader = fl;
35581:       mFrameLoader->CreateStaticClone(fl);
35581:     }
35581:   }
35581: }
35581: 
35581: NS_IMETHODIMP
35581: nsObjectLoadingContent::GetPrintFrame(nsIFrame** aFrame)
35581: {
35581:   *aFrame = mPrintFrame.GetFrame();
35581:   return NS_OK;
35581: }
35581: 
35171: NS_IMETHODIMP
39501: nsObjectLoadingContent::PluginCrashed(nsIPluginTag* aPluginTag,
39794:                                       const nsAString& pluginDumpID,
39794:                                       const nsAString& browserDumpID,
79445:                                       bool submittedCrashReport)
37151: {
80486:   AutoNotifier notifier(this, true);
37151:   UnloadContent();
37151:   mFallbackReason = ePluginCrashed;
37151:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
39501: 
39501:   // Note that aPluginTag in invalidated after we're called, so copy 
39501:   // out any data we need now.
39501:   nsCAutoString pluginName;
39501:   aPluginTag->GetName(pluginName);
40610:   nsCAutoString pluginFilename;
40610:   aPluginTag->GetFilename(pluginFilename);
39501: 
38026:   nsCOMPtr<nsIRunnable> ev = new nsPluginCrashedEvent(thisContent,
39794:                                                       pluginDumpID,
39794:                                                       browserDumpID,
39501:                                                       NS_ConvertUTF8toUTF16(pluginName),
40610:                                                       NS_ConvertUTF8toUTF16(pluginFilename),
38026:                                                       submittedCrashReport);
38026:   nsresult rv = NS_DispatchToCurrentThread(ev);
38026:   if (NS_FAILED(rv)) {
38026:     NS_WARNING("failed to dispatch nsPluginCrashedEvent");
38026:   }
37151:   return NS_OK;
37151: }
84557: 
84557: NS_IMETHODIMP
89114: nsObjectLoadingContent::SyncStartPluginInstance()
89114: {
89114:   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
89114:                "Must be able to run script in order to instantiate a plugin instance!");
89114: 
89980:   // Don't even attempt to start an instance unless the content is in
89980:   // the document.
89980:   nsCOMPtr<nsIContent> thisContent =
89980:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
89114:   if (!thisContent->IsInDoc()) {
89114:     return NS_ERROR_FAILURE;
89114:   }
89114: 
89690:   nsCOMPtr<nsIURI> kungFuURIGrip(mURI);
89980:   nsCString contentType(mContentType);
89980:   return InstantiatePluginInstance(contentType.get(), mURI.get());
89114: }
89114: 
89114: NS_IMETHODIMP
89114: nsObjectLoadingContent::AsyncStartPluginInstance()
89114: {
89114:   // OK to have an instance already.
89114:   if (mInstanceOwner) {
89114:     return NS_OK;
89114:   }
89114: 
89114:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
89114:   nsIDocument* doc = thisContent->OwnerDoc();
89114:   if (doc->IsStaticDocument() || doc->IsBeingUsedAsImage()) {
89114:     return NS_OK;
89114:   }
89114: 
89114:   // We always start plugins on a runnable.
89114:   // We don't want a script blocker on the stack during instantiation.
89114:   nsCOMPtr<nsIRunnable> event = new nsAsyncInstantiateEvent(this);
89114:   if (!event) {
89114:     return NS_ERROR_OUT_OF_MEMORY;
89114:   }
89114:   nsresult rv = NS_DispatchToCurrentThread(event);
89114:   if (NS_SUCCEEDED(rv)) {
89114:     // Remember this event.  This is a weak reference that will be cleared
89114:     // when the event runs.
89114:     mPendingInstantiateEvent = event;
89114:   }
89114: 
89114:   return rv;
89114: }
89114: 
92097: NS_IMETHODIMP
92097: nsObjectLoadingContent::GetSrcURI(nsIURI** aURI)
92097: {
92097:   NS_IF_ADDREF(*aURI = mURI);
92097:   return NS_OK;
92097: }
92097: 
89114: static bool
89114: DoDelayedStop(nsPluginInstanceOwner *aInstanceOwner, bool aDelayedStop)
89114: {
89114: #if (MOZ_PLATFORM_MAEMO==5)
89114:   // Don't delay stop on Maemo/Hildon (bug 530739).
89114:   if (aDelayedStop && aInstanceOwner->MatchPluginName("Shockwave Flash"))
89114:     return false;
89114: #endif
89114:   
89114:   // Don't delay stopping QuickTime (bug 425157), Flip4Mac (bug 426524),
89114:   // XStandard (bug 430219), CMISS Zinc (bug 429604).
89114:   if (aDelayedStop
89114: #if !(defined XP_WIN || defined MOZ_X11)
89114:       && !aInstanceOwner->MatchPluginName("QuickTime")
89114:       && !aInstanceOwner->MatchPluginName("Flip4Mac")
89114:       && !aInstanceOwner->MatchPluginName("XStandard plugin")
89114:       && !aInstanceOwner->MatchPluginName("CMISS Zinc Plugin")
89114: #endif
89114:       ) {
89114:     nsCOMPtr<nsIRunnable> evt = new nsStopPluginRunnable(aInstanceOwner);
89114:     NS_DispatchToCurrentThread(evt);
89114:     return true;
89114:   }
89114:   return false;
89114: }
89114: 
89114: void
89114: nsObjectLoadingContent::DoStopPlugin(nsPluginInstanceOwner *aInstanceOwner, bool aDelayedStop)
89114: {
89114:   nsRefPtr<nsNPAPIPluginInstance> inst;
89114:   aInstanceOwner->GetInstance(getter_AddRefs(inst));
89114:   if (inst) {
89114:     if (DoDelayedStop(aInstanceOwner, aDelayedStop)) {
89114:       return;
89114:     }
89114: 
89114: #if defined(XP_MACOSX)
89114:     aInstanceOwner->HidePluginWindow();
89114: #endif
89114: 
89114:     nsCOMPtr<nsIPluginHost> pluginHost = do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
89114:     NS_ASSERTION(pluginHost, "Without a pluginHost, how can we have an instance to destroy?");
89114:     static_cast<nsPluginHost*>(pluginHost.get())->StopPluginInstance(inst);
89114:   }
89114:   
89114:   aInstanceOwner->Destroy();
89114: }
89114: 
89114: NS_IMETHODIMP
89114: nsObjectLoadingContent::StopPluginInstance()
89114: {
89114:   if (!mInstanceOwner) {
89114:     return NS_OK;
89114:   }
89114: 
89114:   DisconnectFrame();
89114: 
89114:   bool delayedStop = false;
89114: #ifdef XP_WIN
89114:   // Force delayed stop for Real plugin only; see bug 420886, 426852.
89114:   nsRefPtr<nsNPAPIPluginInstance> inst;
89114:   mInstanceOwner->GetInstance(getter_AddRefs(inst));
89114:   if (inst) {
89114:     const char* mime = nsnull;
89114:     if (NS_SUCCEEDED(inst->GetMIMEType(&mime)) && mime) {
89114:       if (strcmp(mime, "audio/x-pn-realaudio-plugin") == 0) {
89114:         delayedStop = true;
89114:       }      
89114:     }
89114:   }
89114: #endif
89114: 
92636:   DoStopPlugin(mInstanceOwner, delayedStop);
92636: 
89114:   mInstanceOwner = nsnull;
92636: 
89114:   return NS_OK;
89114: }
89114: 
89114: void
89114: nsObjectLoadingContent::NotifyContentObjectWrapper()
89114: {
89114:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
89114: 
89114:   nsCOMPtr<nsIDocument> doc = thisContent->GetDocument();
89114:   if (!doc)
89114:     return;
89114:   
89114:   nsIScriptGlobalObject *sgo = doc->GetScopeObject();
89114:   if (!sgo)
89114:     return;
89114:   
89114:   nsIScriptContext *scx = sgo->GetContext();
89114:   if (!scx)
89114:     return;
89114:   
89114:   JSContext *cx = scx->GetNativeContext();
89114:   
89114:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
89114:   nsContentUtils::XPConnect()->
89114:   GetWrappedNativeOfNativeObject(cx, sgo->GetGlobalJSObject(), thisContent,
89114:                                  NS_GET_IID(nsISupports),
89114:                                  getter_AddRefs(wrapper));
89114:   
89114:   if (!wrapper) {
89114:     // Nothing to do here if there's no wrapper for mContent. The proto
89114:     // chain will be fixed appropriately when the wrapper is created.
89114:     return;
89114:   }
89114:   
89114:   JSObject *obj = nsnull;
89114:   nsresult rv = wrapper->GetJSObject(&obj);
89114:   if (NS_FAILED(rv))
89114:     return;
89114:   
89114:   nsHTMLPluginObjElementSH::SetupProtoChain(wrapper, cx, obj);
89114: }
89114: 
89114: NS_IMETHODIMP
84557: nsObjectLoadingContent::PlayPlugin()
84557: {
84557:   if (!nsContentUtils::IsCallerChrome())
84557:     return NS_OK;
84557: 
84557:   mShouldPlay = true;
84557:   return LoadObject(mURI, true, mContentType, true);
84557: }
