    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark (buster@netscape.com)
    1:  *   Ilya Konstantinov (mozilla-code@future.shiny.co.il)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsDOMMouseEvent.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIContent.h"
    1: #include "nsContentUtils.h"
    1: 
    1: nsDOMMouseEvent::nsDOMMouseEvent(nsPresContext* aPresContext,
    1:                                  nsInputEvent* aEvent)
    1:   : nsDOMUIEvent(aPresContext, aEvent ? aEvent :
    1:                  new nsMouseEvent(PR_FALSE, 0, nsnull,
    1:                                   nsMouseEvent::eReal))
    1: {
    1:   // There's no way to make this class' ctor allocate an nsMouseScrollEvent.
    1:   // It's not that important, though, since a scroll event is not a real
    1:   // DOM event.
    1:   
    1:   if (aEvent) {
    1:     mEventIsInternal = PR_FALSE;
    1:   }
    1:   else {
    1:     mEventIsInternal = PR_TRUE;
    1:     mEvent->time = PR_Now();
    1:     mEvent->refPoint.x = mEvent->refPoint.y = 0;
40485:     static_cast<nsMouseEvent*>(mEvent)->inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_UNKNOWN;
    1:   }
    1: 
    1:   switch (mEvent->eventStructType)
    1:   {
    1:     case NS_MOUSE_EVENT:
41050:       NS_ASSERTION(static_cast<nsMouseEvent*>(mEvent)->reason
41050:                    != nsMouseEvent::eSynthesized,
41050:                    "Don't dispatch DOM events from synthesized mouse events");
 3233:       mDetail = static_cast<nsMouseEvent*>(mEvent)->clickCount;
    1:       break;
    1:     default:
    1:       break;
    1:   }
    1: }
    1: 
    1: nsDOMMouseEvent::~nsDOMMouseEvent()
    1: {
16604:   if (mEventIsInternal && mEvent) {
    1:     switch (mEvent->eventStructType)
    1:     {
    1:       case NS_MOUSE_EVENT:
 3233:         delete static_cast<nsMouseEvent*>(mEvent);
    1:         break;
    1:       default:
    1:         delete mEvent;
    1:         break;
    1:     }
    1:     mEvent = nsnull;
    1:   }
    1: }
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsDOMMouseEvent, nsDOMUIEvent)
    1: NS_IMPL_RELEASE_INHERITED(nsDOMMouseEvent, nsDOMUIEvent)
    1: 
40490: DOMCI_DATA(MouseEvent, nsDOMMouseEvent)
40490: 
    1: NS_INTERFACE_MAP_BEGIN(nsDOMMouseEvent)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseEvent)
22684:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSMouseEvent)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MouseEvent)
    1: NS_INTERFACE_MAP_END_INHERITING(nsDOMUIEvent)
    1: 
    1: NS_IMETHODIMP
    1: nsDOMMouseEvent::InitMouseEvent(const nsAString & aType, PRBool aCanBubble, PRBool aCancelable,
68870:                                 nsIDOMAbstractView *aView, PRInt32 aDetail, PRInt32 aScreenX, 
    1:                                 PRInt32 aScreenY, PRInt32 aClientX, PRInt32 aClientY, 
    1:                                 PRBool aCtrlKey, PRBool aAltKey, PRBool aShiftKey, 
    1:                                 PRBool aMetaKey, PRUint16 aButton, nsIDOMEventTarget *aRelatedTarget)
    1: {
    1:   nsresult rv = nsDOMUIEvent::InitUIEvent(aType, aCanBubble, aCancelable, aView, aDetail);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   switch(mEvent->eventStructType)
    1:   {
    1:     case NS_MOUSE_EVENT:
    1:     case NS_MOUSE_SCROLL_EVENT:
22943:     case NS_DRAG_EVENT:
25058:     case NS_SIMPLE_GESTURE_EVENT:
48711:     case NS_MOZTOUCH_EVENT:
    1:     {
 3233:        static_cast<nsMouseEvent_base*>(mEvent)->relatedTarget = aRelatedTarget;
 3233:        static_cast<nsMouseEvent_base*>(mEvent)->button = aButton;
 3233:        nsInputEvent* inputEvent = static_cast<nsInputEvent*>(mEvent);
    1:        inputEvent->isControl = aCtrlKey;
    1:        inputEvent->isAlt = aAltKey;
    1:        inputEvent->isShift = aShiftKey;
    1:        inputEvent->isMeta = aMetaKey;
    1:        mClientPoint.x = aClientX;
    1:        mClientPoint.y = aClientY;
    1:        inputEvent->refPoint.x = aScreenX;
    1:        inputEvent->refPoint.y = aScreenY;
    1: 
16604:        if (mEvent->eventStructType == NS_MOUSE_EVENT) {
 3233:          nsMouseEvent* mouseEvent = static_cast<nsMouseEvent*>(mEvent);
    1:          mouseEvent->clickCount = aDetail;
    1:        }
    1:        break;
    1:     }
    1:     default:
    1:        break;
    1:   }
    1: 
    1:   return NS_OK;
    1: }   
    1: 
    1: NS_IMETHODIMP
22684: nsDOMMouseEvent::InitNSMouseEvent(const nsAString & aType, PRBool aCanBubble, PRBool aCancelable,
68870:                                   nsIDOMAbstractView *aView, PRInt32 aDetail, PRInt32 aScreenX,
22684:                                   PRInt32 aScreenY, PRInt32 aClientX, PRInt32 aClientY,
22684:                                   PRBool aCtrlKey, PRBool aAltKey, PRBool aShiftKey,
22684:                                   PRBool aMetaKey, PRUint16 aButton, nsIDOMEventTarget *aRelatedTarget,
40485:                                   float aPressure, PRUint16 aInputSource)
22684: {
22684:   nsresult rv = nsDOMMouseEvent::InitMouseEvent(aType, aCanBubble, aCancelable,
22684:                                                 aView, aDetail, aScreenX, aScreenY,
22684:                                                 aClientX, aClientY, aCtrlKey, aAltKey, aShiftKey,
22684:                                                 aMetaKey, aButton, aRelatedTarget);
22684:   NS_ENSURE_SUCCESS(rv, rv);
22684: 
22684:   static_cast<nsMouseEvent_base*>(mEvent)->pressure = aPressure;
40485:   static_cast<nsMouseEvent_base*>(mEvent)->inputSource = aInputSource;
22684:   return NS_OK;
22684: }
22684: 
22684: NS_IMETHODIMP
    1: nsDOMMouseEvent::GetButton(PRUint16* aButton)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aButton);
    1:   switch(mEvent->eventStructType)
    1:   {
    1:     case NS_MOUSE_EVENT:
    1:     case NS_MOUSE_SCROLL_EVENT:
22943:     case NS_DRAG_EVENT:
25058:     case NS_SIMPLE_GESTURE_EVENT:
48711:     case NS_MOZTOUCH_EVENT:
 3233:       *aButton = static_cast<nsMouseEvent_base*>(mEvent)->button;
    1:       break;
    1:     default:
    1:       NS_WARNING("Tried to get mouse button for non-mouse event!");
    1:       *aButton = nsMouseEvent::eLeftButton;
    1:       break;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMMouseEvent::GetRelatedTarget(nsIDOMEventTarget** aRelatedTarget)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aRelatedTarget);
    1:   *aRelatedTarget = nsnull;
    1:   nsISupports* relatedTarget = nsnull;
    1:   switch(mEvent->eventStructType)
    1:   {
    1:     case NS_MOUSE_EVENT:
    1:     case NS_MOUSE_SCROLL_EVENT:
22943:     case NS_DRAG_EVENT:
25058:     case NS_SIMPLE_GESTURE_EVENT:
48711:     case NS_MOZTOUCH_EVENT:
 3233:       relatedTarget = static_cast<nsMouseEvent_base*>(mEvent)->relatedTarget;
    1:       break;
    1:     default:
    1:       break;
    1:   }
    1: 
    1:   if (relatedTarget) {
29802:     nsCOMPtr<nsIContent> content = do_QueryInterface(relatedTarget);
29802:     if (content && content->IsInNativeAnonymousSubtree() &&
29802:         !nsContentUtils::CanAccessNativeAnon()) {
29802:       relatedTarget = content->FindFirstNonNativeAnonymous();
29802:       if (!relatedTarget) {
29802:         return NS_OK;
29802:       }
29802:     }
29802: 
    1:     CallQueryInterface(relatedTarget, aRelatedTarget);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_METHOD nsDOMMouseEvent::GetScreenX(PRInt32* aScreenX)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScreenX);
    1:   *aScreenX = GetScreenPoint().x;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMMouseEvent::GetScreenY(PRInt32* aScreenY)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScreenY);
    1:   *aScreenY = GetScreenPoint().y;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_METHOD nsDOMMouseEvent::GetClientX(PRInt32* aClientX)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aClientX);
    1:   *aClientX = GetClientPoint().x;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMMouseEvent::GetClientY(PRInt32* aClientY)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aClientY);
    1:   *aClientY = GetClientPoint().y;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMMouseEvent::GetAltKey(PRBool* aIsDown)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDown);
    1:   *aIsDown = ((nsInputEvent*)mEvent)->isAlt;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMMouseEvent::GetCtrlKey(PRBool* aIsDown)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDown);
    1:   *aIsDown = ((nsInputEvent*)mEvent)->isControl;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMMouseEvent::GetShiftKey(PRBool* aIsDown)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDown);
    1:   *aIsDown = ((nsInputEvent*)mEvent)->isShift;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMMouseEvent::GetMetaKey(PRBool* aIsDown)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDown);
    1:   *aIsDown = ((nsInputEvent*)mEvent)->isMeta;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMMouseEvent::GetWhich(PRUint32* aWhich)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aWhich);
    1:   PRUint16 button;
    1:   (void) GetButton(&button);
    1:   *aWhich = button + 1;
    1:   return NS_OK;
    1: }
    1: 
22684: NS_IMETHODIMP
22684: nsDOMMouseEvent::GetMozPressure(float* aPressure)
22684: {
22684:   NS_ENSURE_ARG_POINTER(aPressure);
22684:   *aPressure = static_cast<nsMouseEvent_base*>(mEvent)->pressure;
22684:   return NS_OK;
22684: }
22684: 
40485: NS_IMETHODIMP
40485: nsDOMMouseEvent::GetMozInputSource(PRUint16* aInputSource)
40485: {
40485:   NS_ENSURE_ARG_POINTER(aInputSource);
40485:   *aInputSource = static_cast<nsMouseEvent_base*>(mEvent)->inputSource;
40485:   return NS_OK;
40485: }
40485: 
    1: nsresult NS_NewDOMMouseEvent(nsIDOMEvent** aInstancePtrResult,
    1:                              nsPresContext* aPresContext,
    1:                              nsInputEvent *aEvent) 
    1: {
    1:   nsDOMMouseEvent* it = new nsDOMMouseEvent(aPresContext, aEvent);
68870:   if (nsnull == it) {
68870:     return NS_ERROR_OUT_OF_MEMORY;
68870:   }
68870: 
    1:   return CallQueryInterface(it, aInstancePtrResult);
    1: }
