42611: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2009
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Bas Schouten <bschouten@mozilla.com>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
42611: #ifndef GFX_LAYERMANAGERD3D9_H
42611: #define GFX_LAYERMANAGERD3D9_H
42611: 
42611: #include "Layers.h"
42611: 
72995: #include "mozilla/layers/ShadowLayers.h"
72995: 
42611: #include <windows.h>
42611: #include <d3d9.h>
42611: 
42611: #include "gfxContext.h"
42611: #include "nsIWidget.h"
42611: 
49316: #include "DeviceManagerD3D9.h"
49316: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
42611: class LayerD3D9;
42611: class ThebesLayerD3D9;
42611: 
52176: /**
52176:  * This structure is used to pass rectangles to our shader constant. We can use
52176:  * this for passing rectangular areas to SetVertexShaderConstant. In the format
52176:  * of a 4 component float(x,y,width,height). Our vertex shader can then use
52176:  * this to construct rectangular positions from the 0,0-1,1 quad that we source
52176:  * it with.
52176:  */
52176: struct ShaderConstantRect
52176: {
52176:   float mX, mY, mWidth, mHeight;
54880: 
54880:   // Provide all the commonly used argument types to prevent all the local
54880:   // casts in the code.
52176:   ShaderConstantRect(float aX, float aY, float aWidth, float aHeight)
52176:     : mX(aX), mY(aY), mWidth(aWidth), mHeight(aHeight)
52176:   { }
52176: 
54880:   ShaderConstantRect(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight)
54880:     : mX((float)aX), mY((float)aY)
54880:     , mWidth((float)aWidth), mHeight((float)aHeight)
54880:   { }
54880: 
54880:   ShaderConstantRect(PRInt32 aX, PRInt32 aY, float aWidth, float aHeight)
54880:     : mX((float)aX), mY((float)aY), mWidth(aWidth), mHeight(aHeight)
54880:   { }
54880: 
52176:   // For easy passing to SetVertexShaderConstantF.
52176:   operator float* () { return &mX; }
52176: };
52176: 
42611: /*
42611:  * This is the LayerManager used for Direct3D 9. For now this will render on
42611:  * the main thread.
42611:  */
72995: class THEBES_API LayerManagerD3D9 : public ShadowLayerManager {
42611: public:
42611:   LayerManagerD3D9(nsIWidget *aWidget);
42611:   virtual ~LayerManagerD3D9();
42611: 
42611:   /*
42611:    * Initializes the layer manager, this is when the layer manager will
42611:    * actually access the device and attempt to create the swap chain used
42611:    * to draw to the window. If this method fails the device cannot be used.
42611:    * This function is not threadsafe.
42611:    *
42611:    * \return True is initialization was succesful, false when it was not.
42611:    */
91135:   bool Initialize(bool force = false);
42611: 
42611:   /*
42611:    * Sets the clipping region for this layer manager. This is important on
42611:    * windows because using OGL we no longer have GDI's native clipping. Therefor
42611:    * widget must tell us what part of the screen is being invalidated,
42611:    * and we should clip to this.
42611:    *
42611:    * \param aClippingRegion Region to clip to. Setting an empty region
42611:    * will disable clipping.
42611:    */
42611:   void SetClippingRegion(const nsIntRegion& aClippingRegion);
42611: 
42611:   /*
42611:    * LayerManager implementation.
42611:    */
53979:   virtual void Destroy();
53979: 
75160:   virtual ShadowLayerManager* AsShadowManager()
75160:   { return this; }
75160: 
60858:   virtual void BeginTransaction();
42611: 
60858:   virtual void BeginTransactionWithTarget(gfxContext* aTarget);
42611: 
42611:   void EndConstruction();
42611: 
60858:   virtual bool EndEmptyTransaction();
60858: 
42611:   struct CallbackInfo {
42611:     DrawThebesLayerCallback Callback;
42611:     void *CallbackData;
42611:   };
42611: 
60858:   virtual void EndTransaction(DrawThebesLayerCallback aCallback,
78887:                               void* aCallbackData,
78887:                               EndTransactionFlags aFlags = END_DEFAULT);
42611: 
42611:   const CallbackInfo &GetCallbackInfo() { return mCurrentCallbackInfo; }
42611: 
42611:   void SetRoot(Layer* aLayer);
42611: 
73612:   virtual bool CanUseCanvasLayerForSize(const gfxIntSize &aSize)
73612:   {
73612:     if (!mDeviceManager)
73612:       return false;
73612:     PRInt32 maxSize = mDeviceManager->GetMaxTextureSize();
73612:     return aSize <= gfxIntSize(maxSize, maxSize);
73612:   }
73612: 
42611:   virtual already_AddRefed<ThebesLayer> CreateThebesLayer();
42611: 
42611:   virtual already_AddRefed<ContainerLayer> CreateContainerLayer();
42611: 
42611:   virtual already_AddRefed<ImageLayer> CreateImageLayer();
42611: 
42611:   virtual already_AddRefed<ColorLayer> CreateColorLayer();
42611: 
42611:   virtual already_AddRefed<CanvasLayer> CreateCanvasLayer();
42611: 
62701:   virtual already_AddRefed<ReadbackLayer> CreateReadbackLayer();
62701: 
72995:   virtual already_AddRefed<ShadowThebesLayer> CreateShadowThebesLayer();
72995:   virtual already_AddRefed<ShadowContainerLayer> CreateShadowContainerLayer();
72995:   virtual already_AddRefed<ShadowImageLayer> CreateShadowImageLayer();
72995:   virtual already_AddRefed<ShadowColorLayer> CreateShadowColorLayer();
72995:   virtual already_AddRefed<ShadowCanvasLayer> CreateShadowCanvasLayer();
72995: 
42611:   virtual LayersBackend GetBackendType() { return LAYERS_D3D9; }
51975:   virtual void GetBackendName(nsAString& name) { name.AssignLiteral("Direct3D 9"); }
53982:   bool DeviceWasRemoved() { return deviceManager()->DeviceWasRemoved(); }
42611: 
42611:   /*
42611:    * Helper methods.
42611:    */
79445:   void SetClippingEnabled(bool aEnabled);
42611: 
49316:   void SetShaderMode(DeviceManagerD3D9::ShaderMode aMode)
49316:     { mDeviceManager->SetShaderMode(aMode); }
42611: 
49316:   IDirect3DDevice9 *device() const { return mDeviceManager->device(); }
49316:   DeviceManagerD3D9 *deviceManager() const { return mDeviceManager; }
42611: 
51527:   /** 
51527:    * Return pointer to the Nv3DVUtils instance. Re-direct to mDeviceManager.
51527:    */ 
51527:   Nv3DVUtils *GetNv3DVUtils()  { return mDeviceManager ? mDeviceManager->GetNv3DVUtils() : NULL; } 
51527: 
50600:   static void OnDeviceManagerDestroy(DeviceManagerD3D9 *aDeviceManager) {
53980:     if(aDeviceManager == mDefaultDeviceManager)
53980:       mDefaultDeviceManager = nsnull;
50600:   }
50600: 
51960: #ifdef MOZ_LAYERS_HAVE_LOG
51960:   virtual const char* Name() const { return "D3D9"; }
51960: #endif // MOZ_LAYERS_HAVE_LOG
51960: 
55203:   void ReportFailure(const nsACString &aMsg, HRESULT aCode);
55203: 
42611: private:
53980:   /* Default device manager instance */
53980:   static DeviceManagerD3D9 *mDefaultDeviceManager;
53980: 
53980:   /* Device manager instance for this layer manager */
53980:   nsRefPtr<DeviceManagerD3D9> mDeviceManager;
49316: 
49316:   /* Swap chain associated with this layer manager */
49316:   nsRefPtr<SwapChainD3D9> mSwapChain;
42611: 
42611:   /* Widget associated with this layer manager */
42611:   nsIWidget *mWidget;
49316: 
42611:   /*
42611:    * Context target, NULL when drawing directly to our swap chain.
42611:    */
42611:   nsRefPtr<gfxContext> mTarget;
42611: 
42611:   /* Callback info for current transaction */
42611:   CallbackInfo mCurrentCallbackInfo;
42611: 
42611:   /*
42611:    * Region we're clipping our current drawing to.
42611:    */
42611:   nsIntRegion mClippingRegion;
49316: 
42611:   /*
60858:    * Device reset count at last paint. Whenever this changes, we need to
60858:    * do a full layer tree update.
60858:    */
60858:   PRUint32 mDeviceResetCount;
60858: 
60858:   /*
42611:    * Render the current layer tree to the active target.
42611:    */
42611:   void Render();
49316: 
42611:   /*
42611:    * Setup the pipeline.
42611:    */
42611:   void SetupPipeline();
49316: 
42611:   /*
42611:    * Copies the content of our backbuffer to the set transaction target.
42611:    */
42611:   void PaintToTarget();
42611: 
42611: };
42611: 
42611: /*
42611:  * General information and tree management for OGL layers.
42611:  */
42611: class LayerD3D9
42611: {
42611: public:
42611:   LayerD3D9(LayerManagerD3D9 *aManager);
42611: 
42611:   virtual LayerD3D9 *GetFirstChildD3D9() { return nsnull; }
42611: 
42611:   void SetFirstChild(LayerD3D9 *aParent);
42611: 
42611:   virtual Layer* GetLayer() = 0;
42611: 
57097:   virtual void RenderLayer() = 0;
42611: 
57097:   /**
53783:   /* This function may be used on device resets to clear all VRAM resources
53783:    * that a layer might be using.
53783:    */
53783:   virtual void CleanResources() {}
53783: 
42611:   IDirect3DDevice9 *device() const { return mD3DManager->device(); }
53979: 
53979:   /* Called by the layer manager when it's destroyed */
53979:   virtual void LayerManagerDestroyed() {}
55203: 
55203:   void ReportFailure(const nsACString &aMsg, HRESULT aCode) {
55203:     return mD3DManager->ReportFailure(aMsg, aCode);
55203:   }
57097: 
57097:   void SetShaderTransformAndOpacity()
57097:   {
57097:     Layer* layer = GetLayer();
57097:     const gfx3DMatrix& transform = layer->GetEffectiveTransform();
57097:     device()->SetVertexShaderConstantF(CBmLayerTransform, &transform._11, 4);
57097: 
57097:     float opacity[4];
57097:     /*
57097:      * We always upload a 4 component float, but the shader will use only the
57097:      * first component since it's declared as a 'float'.
57097:      */
57097:     opacity[0] = layer->GetEffectiveOpacity();
57097:     device()->SetPixelShaderConstantF(CBfLayerOpacity, opacity, 1);
57097:   }
57097: 
42611: protected:
42611:   LayerManagerD3D9 *mD3DManager;
42611: };
42611: 
72995: /*
72995:  * RAII helper for locking D3D9 textures.
72995:  */
72995: class LockTextureRectD3D9 
72995: {
72995: public:
72995:   LockTextureRectD3D9(IDirect3DTexture9* aTexture) 
72995:     : mTexture(aTexture)
72995:   {
72995:     mLockResult = mTexture->LockRect(0, &mR, NULL, 0);
72995:   }
72995: 
72995:   ~LockTextureRectD3D9()
72995:   {
72995:     mTexture->UnlockRect(0);
72995:   }
72995: 
72995:   bool HasLock() {
72995:     return SUCCEEDED(mLockResult);
72995:   }
72995: 
72995:   D3DLOCKED_RECT GetLockRect() 
72995:   {
72995:     return mR;
72995:   }
72995: private:
72995:   LockTextureRectD3D9 (const LockTextureRectD3D9&);
72995:   LockTextureRectD3D9& operator= (const LockTextureRectD3D9&);
72995: 
72995:   IDirect3DTexture9* mTexture;
72995:   D3DLOCKED_RECT mR;
72995:   HRESULT mLockResult;
72995: };
72995: 
42611: } /* layers */
42611: } /* mozilla */
42611: 
42611: #endif /* GFX_LAYERMANAGERD3D9_H */
