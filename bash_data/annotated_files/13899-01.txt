    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 9531: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
    1:  *   Gagan Saksena <gagan@netscape.com>
    1:  *   Benjamin Smedberg <benjamin@smedbergs.us>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsChromeRegistry.h"
    1: 
    1: #include <string.h>
    1: 
    1: #include "prio.h"
    1: #include "prprf.h"
 7902: #if defined(XP_WIN)
 7902: #include <windows.h>
 7902: #elif defined(XP_MACOSX)
 7902: #include <Carbon/Carbon.h>
 8425: #elif defined(MOZ_WIDGET_GTK2)
 8425: #include <gtk/gtk.h>
 7902: #endif
    1: 
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsArrayEnumerator.h"
    1: #include "nsStringEnumerator.h"
    1: #include "nsEnumeratorUtils.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsDOMError.h"
    1: #include "nsEscape.h"
    1: #include "nsInt64.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsNetCID.h"
    1: #include "nsNetUtil.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsStaticAtom.h"
    1: #include "nsString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsXULAppAPI.h"
 7902: #include "nsTextFormatter.h"
    1: 
    1: #include "nsIAtom.h"
    1: #include "nsICommandLine.h"
    1: #include "nsICSSLoader.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsIDirectoryService.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocumentObserver.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMLocation.h"
    1: #include "nsIDOMWindowCollection.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIFileChannel.h"
    1: #include "nsIFileURL.h"
    1: #include "nsIIOService.h"
13899: #include "nsIJARProtocolHandler.h"
    1: #include "nsIJARURI.h"
    1: #include "nsILocalFile.h"
    1: #include "nsILocaleService.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIPresShell.h"
 9606: #include "nsIProtocolHandler.h"
 9606: #include "nsIResProtocolHandler.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsIStyleSheet.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsIVersionComparator.h"
    1: #include "nsIWindowMediator.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIXULAppInfo.h"
    1: #include "nsIXULRuntime.h"
 1722: #include "nsPresShellIterator.h"
    1: 
    1: #ifdef MOZ_XUL
    1: // keep all the RDF stuff together, in case we can remove it in the far future
    1: #include "rdf.h"
    1: #include "nsRDFCID.h"
    1: #include "nsIRDFService.h"
    1: #include "nsIRDFDataSource.h"
    1: #include "nsIRDFObserver.h"
    1: #include "nsIRDFRemoteDataSource.h"
    1: #include "nsIRDFXMLSink.h"
    1: #include "nsIRDFResource.h"
    1: #include "nsIRDFDataSource.h"
    1: #include "nsIRDFContainer.h"
    1: #include "nsIRDFContainerUtils.h"
    1: 
    1: #define CHROME_URI "http://www.mozilla.org/rdf/chrome#"
    1: 
    1: DEFINE_RDF_VOCAB(CHROME_URI, CHROME, packages);
    1: DEFINE_RDF_VOCAB(CHROME_URI, CHROME, package);
    1: DEFINE_RDF_VOCAB(CHROME_URI, CHROME, name);
    1: DEFINE_RDF_VOCAB(CHROME_URI, CHROME, platformPackage);
    1: 
    1: #endif
    1: 
    1: #define UILOCALE_CMD_LINE_ARG "UILocale"
    1: 
    1: #define MATCH_OS_LOCALE_PREF "intl.locale.matchOS"
    1: #define SELECTED_LOCALE_PREF "general.useragent.locale"
    1: #define SELECTED_SKIN_PREF   "general.skins.selectedSkin"
    1: 
    1: static NS_DEFINE_CID(kCSSLoaderCID, NS_CSS_LOADER_CID);
    1: static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
    1: 
    1: nsChromeRegistry* nsChromeRegistry::gChromeRegistry;
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: 
    1: static void
    1: LogMessage(const char* aMsg, ...)
    1: {
    1:   nsCOMPtr<nsIConsoleService> console 
    1:     (do_GetService(NS_CONSOLESERVICE_CONTRACTID));
    1:   if (!console)
    1:     return;
    1: 
    1:   va_list args;
    1:   va_start(args, aMsg);
    1:   char* formatted = PR_vsmprintf(aMsg, args);
    1:   va_end(args);
    1:   if (!formatted)
    1:     return;
    1: 
    1:   console->LogStringMessage(NS_ConvertUTF8toUTF16(formatted).get());
    1:   PR_smprintf_free(formatted);
    1: }
    1: 
    1: static void
    1: LogMessageWithContext(nsIURI* aURL, PRUint32 aLineNumber, PRUint32 flags,
    1:                       const char* aMsg, ...)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIConsoleService> console 
    1:     (do_GetService(NS_CONSOLESERVICE_CONTRACTID));
    1: 
    1:   nsCOMPtr<nsIScriptError> error
    1:     (do_CreateInstance(NS_SCRIPTERROR_CONTRACTID));
    1:   if (!console || !error)
    1:     return;
    1: 
    1:   va_list args;
    1:   va_start(args, aMsg);
    1:   char* formatted = PR_vsmprintf(aMsg, args);
    1:   va_end(args);
    1:   if (!formatted)
    1:     return;
    1: 
    1:   nsCString spec;
    1:   if (aURL)
    1:     aURL->GetSpec(spec);
    1: 
    1:   rv = error->Init(NS_ConvertUTF8toUTF16(formatted).get(),
    1:                    NS_ConvertUTF8toUTF16(spec).get(),
    1:                    nsnull,
    1:                    aLineNumber, 0, flags, "chrome registration");
    1:   PR_smprintf_free(formatted);
    1: 
    1:   if (NS_FAILED(rv))
    1:     return;
    1: 
    1:   console->LogMessage(error);
    1: }
    1: 
    1: // We use a "best-fit" algorithm for matching locales and themes. 
    1: // 1) the exact selected locale/theme
    1: // 2) (locales only) same language, different country
    1: //    e.g. en-GB is the selected locale, only en-US is available
    1: // 3) any available locale/theme
    1: 
    1: /**
    1:  * Match the language-part of two lang-COUNTRY codes, hopefully but
    1:  * not guaranteed to be in the form ab-CD or abz-CD. "ab" should also
    1:  * work, any other garbage-in will produce undefined results as long
    1:  * as it does not crash.
    1:  */
    1: static PRBool
    1: LanguagesMatch(const nsACString& a, const nsACString& b)
    1: {
    1:   if (a.Length() < 2 || b.Length() < 2)
    1:     return PR_FALSE;
    1: 
    1:   nsACString::const_iterator as, ae, bs, be;
    1:   a.BeginReading(as);
    1:   a.EndReading(ae);
    1:   b.BeginReading(bs);
    1:   b.EndReading(be);
    1: 
    1:   while (*as == *bs) {
    1:     if (*as == '-')
    1:       return PR_TRUE;
    1:  
    1:     ++as; ++bs;
    1: 
    1:     // reached the end
    1:     if (as == ae && bs == be)
    1:       return PR_TRUE;
    1: 
    1:     // "a" is short
    1:     if (as == ae)
    1:       return (*bs == '-');
    1: 
    1:     // "b" is short
    1:     if (bs == be)
    1:       return (*as == '-');
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsChromeRegistry::ProviderEntry*
    1: nsChromeRegistry::nsProviderArray::GetProvider(const nsACString& aPreferred, MatchType aType)
    1: {
    1:   PRInt32 i = mArray.Count();
    1:   if (!i)
    1:     return nsnull;
    1: 
    1:   ProviderEntry* found = nsnull;  // Only set if we find a partial-match locale
    1:   ProviderEntry* entry;
    1: 
    1:   while (i--) {
 3233:     entry = reinterpret_cast<ProviderEntry*>(mArray[i]);
    1:     if (aPreferred.Equals(entry->provider))
    1:       return entry;
    1: 
    1:     if (aType != LOCALE)
    1:       continue;
    1: 
    1:     if (LanguagesMatch(aPreferred, entry->provider)) {
    1:       found = entry;
    1:       continue;
    1:     }
    1: 
    1:     if (!found && entry->provider.EqualsLiteral("en-US"))
    1:       found = entry;
    1:   }
    1: 
    1:   if (!found && aType != EXACT)
    1:     return entry;
    1: 
    1:   return found;
    1: }
    1: 
    1: nsIURI*
    1: nsChromeRegistry::nsProviderArray::GetBase(const nsACString& aPreferred, MatchType aType)
    1: {
    1:   ProviderEntry* provider = GetProvider(aPreferred, aType);
    1: 
    1:   if (!provider)
    1:     return nsnull;
    1: 
    1:   return provider->baseURI;
    1: }
    1: 
    1: const nsACString&
    1: nsChromeRegistry::nsProviderArray::GetSelected(const nsACString& aPreferred, MatchType aType)
    1: {
    1:   ProviderEntry* entry = GetProvider(aPreferred, aType);
    1: 
    1:   if (entry)
    1:     return entry->provider;
    1: 
    1:   return EmptyCString();
    1: }
    1: 
    1: void
    1: nsChromeRegistry::nsProviderArray::SetBase(const nsACString& aProvider, nsIURI* aBaseURL)
    1: {
    1:   ProviderEntry* provider = GetProvider(aProvider, EXACT);
    1: 
    1:   if (provider) {
    1:     provider->baseURI = aBaseURL;
    1:     return;
    1:   }
    1: 
    1:   // no existing entries, add a new one
    1:   provider = new ProviderEntry(aProvider, aBaseURL);
    1:   if (!provider)
    1:     return; // It's safe to silently fail on OOM
    1: 
    1:   mArray.AppendElement(provider);
    1: }
    1: 
    1: void
    1: nsChromeRegistry::nsProviderArray::EnumerateToArray(nsCStringArray *a)
    1: {
    1:   PRInt32 i = mArray.Count();
    1:   while (i--) {
 3233:     ProviderEntry *entry = reinterpret_cast<ProviderEntry*>(mArray[i]);
    1:     a->AppendCString(entry->provider);
    1:   }
    1: }
    1: 
    1: void
    1: nsChromeRegistry::nsProviderArray::Clear()
    1: {
    1:   PRInt32 i = mArray.Count();
    1:   while (i--) {
 3233:     ProviderEntry* entry = reinterpret_cast<ProviderEntry*>(mArray[i]);
    1:     delete entry;
    1:   }
    1: 
    1:   mArray.Clear();
    1: }
    1: 
    1: nsChromeRegistry::PackageEntry::PackageEntry(const nsACString& aPackage) :
    1:   package(aPackage), flags(0)
    1: {
    1: }
    1: 
    1: PLHashNumber
    1: nsChromeRegistry::HashKey(PLDHashTable *table, const void *key)
    1: {
 3233:   const nsACString& str = *reinterpret_cast<const nsACString*>(key);
    1:   return HashString(str);
    1: }
    1: 
    1: PRBool
    1: nsChromeRegistry::MatchKey(PLDHashTable *table, const PLDHashEntryHdr *entry,
    1:                            const void *key)
    1: {
 3233:   const nsACString& str = *reinterpret_cast<const nsACString*>(key);
 3233:   const PackageEntry* pentry = static_cast<const PackageEntry*>(entry);
    1:   return str.Equals(pentry->package);
    1: }
    1: 
    1: void
    1: nsChromeRegistry::ClearEntry(PLDHashTable *table, PLDHashEntryHdr *entry)
    1: {
 3233:   PackageEntry* pentry = static_cast<PackageEntry*>(entry);
    1:   pentry->~PackageEntry();
    1: }
    1: 
    1: PRBool
    1: nsChromeRegistry::InitEntry(PLDHashTable *table, PLDHashEntryHdr *entry,
    1:                             const void *key)
    1: {
 3233:   const nsACString& str = *reinterpret_cast<const nsACString*>(key);
    1: 
    1:   new (entry) PackageEntry(str);
    1:   return PR_TRUE;
    1: }
    1: 
    1: const PLDHashTableOps
    1: nsChromeRegistry::kTableOps = {
    1:   PL_DHashAllocTable,
    1:   PL_DHashFreeTable,
    1:   HashKey,
    1:   MatchKey,
    1:   PL_DHashMoveEntryStub,
    1:   ClearEntry,
    1:   PL_DHashFinalizeStub,
    1:   InitEntry
    1: };
    1: 
    1: void
    1: nsChromeRegistry::OverlayListEntry::AddURI(nsIURI* aURI)
    1: {
    1:   PRInt32 i = mArray.Count();
    1:   while (i--) {
    1:     PRBool equals;
    1:     if (NS_SUCCEEDED(aURI->Equals(mArray[i], &equals)) && equals)
    1:         return;
    1:   }
    1: 
    1:   mArray.AppendObject(aURI);
    1: }
    1: 
    1: void
    1: nsChromeRegistry::OverlayListHash::Add(nsIURI* aBase, nsIURI* aOverlay)
    1: {
    1:   OverlayListEntry* entry = mTable.PutEntry(aBase);
    1:   if (entry)
    1:     entry->AddURI(aOverlay);
    1: }
    1: 
    1: const nsCOMArray<nsIURI>*
    1: nsChromeRegistry::OverlayListHash::GetArray(nsIURI* aBase)
    1: {
    1:   OverlayListEntry* entry = mTable.GetEntry(aBase);
    1:   if (!entry)
    1:     return nsnull;
    1: 
    1:   return &entry->mArray;
    1: }
    1: 
    1: nsChromeRegistry::~nsChromeRegistry()
    1: {
    1:   PL_DHashTableFinish(&mPackagesHash);
    1:   gChromeRegistry = nsnull;
    1: }
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsChromeRegistry)
    1:   NS_INTERFACE_MAP_ENTRY(nsIChromeRegistry)
    1:   NS_INTERFACE_MAP_ENTRY(nsIXULChromeRegistry)
    1:   NS_INTERFACE_MAP_ENTRY(nsIToolkitChromeRegistry)
    1: #ifdef MOZ_XUL
    1:   NS_INTERFACE_MAP_ENTRY(nsIXULOverlayProvider)
    1: #endif
    1:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIChromeRegistry)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMPL_ADDREF(nsChromeRegistry)
    1: NS_IMPL_RELEASE(nsChromeRegistry)
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: // nsIChromeRegistry methods:
    1: 
    1: static nsresult
    1: getUILangCountry(nsACString& aUILang)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsILocaleService> localeService = do_GetService(NS_LOCALESERVICE_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString uiLang;
    1:   rv = localeService->GetLocaleComponentForUserAgent(uiLang);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   CopyUTF16toUTF8(uiLang, aUILang);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsChromeRegistry::Init()
    1: {
    1:   nsresult rv;
    1: 
    1:   // these atoms appear in almost every chrome registry contents.rdf
    1:   // in some form or another. making static atoms prevents the atoms
    1:   // from constantly being created/destroyed during parsing
    1:   
    1:   static const nsStaticAtom atoms[] = {
    1:     { "chrome",        nsnull },
    1:     { "NC",            nsnull },
    1:     { "allowScripts",  nsnull },
    1:     { "package",       nsnull },
    1:     { "packages",      nsnull },
    1:     { "hasOverlays",   nsnull },
    1:   };
    1: 
    1:   NS_RegisterStaticAtoms(atoms, NS_ARRAY_LENGTH(atoms));
    1:   
13899:   // Check to see if necko and the JAR protocol handler are registered yet
13899:   // if not, somebody is doing work during XPCOM registration that they
13899:   // shouldn't be doing. See bug 292549, where JS components are trying
13899:   // to call Components.utils.import("chrome:///") early in registration
13899: 
13899:   nsCOMPtr<nsIIOService> io (do_GetIOService());
13899:   if (!io) return NS_ERROR_FAILURE;
13899: 
13899:   nsCOMPtr<nsIProtocolHandler> ph;
13899:   rv = io->GetProtocolHandler("jar", getter_AddRefs(ph));
13899:   NS_ENSURE_SUCCESS(rv, rv);
13899: 
13899:   nsCOMPtr<nsIJARProtocolHandler> jph = do_QueryInterface(ph);
13899:   if (!jph)
13899:     return NS_ERROR_NOT_INITIALIZED;
13899: 
    1:   if (!PL_DHashTableInit(&mPackagesHash, &kTableOps,
    1:                          nsnull, sizeof(PackageEntry), 16))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!mOverlayHash.Init() ||
    1:       !mStyleHash.Init() ||
    1:       !mOverrideTable.Init())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mSelectedLocale = NS_LITERAL_CSTRING("en-US");
    1:   mSelectedSkin = NS_LITERAL_CSTRING("classic/1.0");
    1: 
    1:   // This initialization process is fairly complicated and may cause reentrant
    1:   // getservice calls to resolve chrome URIs (especially locale files). We
    1:   // don't want that, so we inform the protocol handler about our existence
    1:   // before we are actually fully initialized.
    1:   gChromeRegistry = this;
    1: 
    1:   PRBool safeMode = PR_FALSE;
    1:   nsCOMPtr<nsIXULRuntime> xulrun (do_GetService(XULAPPINFO_SERVICE_CONTRACTID));
    1:   if (xulrun)
    1:     xulrun->GetInSafeMode(&safeMode);
    1:   
    1:   nsCOMPtr<nsIPrefService> prefserv (do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:   nsCOMPtr<nsIPrefBranch> prefs;
    1: 
    1:   if (safeMode)
    1:     prefserv->GetDefaultBranch(nsnull, getter_AddRefs(prefs));
    1:   else
    1:     prefs = do_QueryInterface(prefserv);
    1: 
    1:   if (!prefs) {
    1:     NS_WARNING("Could not get pref service!");
    1:   }
    1: 
    1:   PRBool useLocalePref = PR_TRUE;
    1: 
    1:   if (prefs) {
    1:     // check the pref first
    1:     PRBool matchOS = PR_FALSE;
    1:     rv = prefs->GetBoolPref(MATCH_OS_LOCALE_PREF, &matchOS);
    1: 
    1:     // match os locale
    1:     if (NS_SUCCEEDED(rv) && matchOS) {
    1:       // compute lang and region code only when needed!
    1:       nsCAutoString uiLocale;
    1:       rv = getUILangCountry(uiLocale);
    1:       if (NS_SUCCEEDED(rv)) {
    1:         useLocalePref = PR_FALSE;
    1:         mSelectedLocale = uiLocale;
    1:       }
    1:     }
    1:   }
    1:       
    1:   if (prefs) {
    1:     nsXPIDLCString provider;
    1: 
    1:     rv = prefs->GetCharPref(SELECTED_SKIN_PREF, getter_Copies(provider));
    1:     if (NS_SUCCEEDED(rv))
    1:       mSelectedSkin = provider;
    1: 
    1:     nsCOMPtr<nsIPrefBranch2> prefs2 (do_QueryInterface(prefs));
    1: 
    1:     if (prefs2)
    1:       rv = prefs2->AddObserver(SELECTED_SKIN_PREF, this, PR_TRUE);
    1: 
    1:     if (useLocalePref) {
    1:       rv = prefs->GetCharPref(SELECTED_LOCALE_PREF, getter_Copies(provider));
    1:       if (NS_SUCCEEDED(rv))
    1:         mSelectedLocale = provider;
    1:       
    1:       if (prefs2)
    1:         prefs2->AddObserver(SELECTED_LOCALE_PREF, this, PR_TRUE);
    1:     }
    1:   }
    1: 
    1:   CheckForNewChrome();
    1: 
    1:   mInitialized = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsChromeRegistry::CheckForOSAccessibility()
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsILookAndFeel> lookAndFeel (do_GetService(kLookAndFeelCID));
    1:   if (lookAndFeel) {
    1:     PRInt32 useAccessibilityTheme = 0;
    1: 
    1:     rv = lookAndFeel->GetMetric(nsILookAndFeel::eMetric_UseAccessibilityTheme,
    1:                                 useAccessibilityTheme);
    1: 
    1:     if (NS_SUCCEEDED(rv) && useAccessibilityTheme) {
    1:       /* Set the skin to classic and remove pref observers */
    1:       if (!mSelectedSkin.EqualsLiteral("classic/1.0")) {
    1:         mSelectedSkin.AssignLiteral("classic/1.0");
    1:         RefreshSkins();
    1:       }
    1: 
    1:       nsCOMPtr<nsIPrefBranch2> prefs (do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:       if (prefs) {
    1:         prefs->RemoveObserver(SELECTED_SKIN_PREF, this);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsChromeRegistry::GetProviderAndPath(nsIURL* aChromeURL,
    1:                                      nsACString& aProvider, nsACString& aPath)
    1: {
    1:   nsresult rv;
    1: 
    1: #ifdef DEBUG
    1:   PRBool isChrome;
    1:   aChromeURL->SchemeIs("chrome", &isChrome);
    1:   NS_ASSERTION(isChrome, "Non-chrome URI?");
    1: #endif
    1: 
    1:   nsCAutoString path;
    1:   rv = aChromeURL->GetPath(path);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (path.Length() < 3) {
    1:     LogMessage("Invalid chrome URI: %s", path.get());
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   path.SetLength(nsUnescapeCount(path.BeginWriting()));
    1:   NS_ASSERTION(path.First() == '/', "Path should always begin with a slash!");
    1: 
    1:   PRInt32 slash = path.FindChar('/', 1);
    1:   if (slash == 1) {
    1:     LogMessage("Invalid chrome URI: %s", path.get());
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (slash == -1) {
    1:     aPath.Truncate();
    1:   }
    1:   else {
    1:     if (slash == (PRInt32) path.Length() - 1)
    1:       aPath.Truncate();
    1:     else
    1:       aPath.Assign(path.get() + slash + 1, path.Length() - slash - 1);
    1: 
    1:     --slash;
    1:   }
    1: 
    1:   aProvider.Assign(path.get() + 1, slash);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsChromeRegistry::Canonify(nsIURL* aChromeURL)
    1: {
    1:   NS_NAMED_LITERAL_CSTRING(kSlash, "/");
    1: 
    1:   nsresult rv;
    1: 
    1:   nsCAutoString provider, path;
    1:   rv = GetProviderAndPath(aChromeURL, provider, path);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (path.IsEmpty()) {
    1:     nsCAutoString package;
    1:     rv = aChromeURL->GetHost(package);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // we re-use the "path" local string to build a new URL path
    1:     path.Assign(kSlash + provider + kSlash + package);
    1:     if (provider.EqualsLiteral("content")) {
    1:       path.AppendLiteral(".xul");
    1:     }
    1:     else if (provider.EqualsLiteral("locale")) {
    1:       path.AppendLiteral(".dtd");
    1:     }
    1:     else if (provider.EqualsLiteral("skin")) {
    1:       path.AppendLiteral(".css");
    1:     }
    1:     else {
    1:       return NS_ERROR_INVALID_ARG;
    1:     }
    1:     aChromeURL->SetPath(path);
    1:   }
    1:   else {
11131:     // prevent directory traversals ("..")
11131:     // path is already unescaped once, but uris can get unescaped twice
11166:     const char* pos = path.BeginReading();
11131:     const char* end = path.EndReading();
11166:     while (pos < end) {
11166:       switch (*pos) {
11131:         case ':':
    1:           return NS_ERROR_DOM_BAD_URI;
11131:         case '.':
11166:           if (pos[1] == '.')
11131:             return NS_ERROR_DOM_BAD_URI;
11166:           break;
11131:         case '%':
11131:           // chrome: URIs with double-escapes are trying to trick us.
11131:           // watch for %2e, and %25 in case someone triple unescapes
11166:           if (pos[1] == '2' &&
11166:                ( pos[2] == 'e' || pos[2] == 'E' || 
11166:                  pos[2] == '5' ))
11131:             return NS_ERROR_DOM_BAD_URI;
11166:           break;
11166:         case '?':
12699:         case '#':
11166:           pos = end;
11166:           continue;
11131:       }
11166:       ++pos;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsChromeRegistry::ConvertChromeURL(nsIURI* aChromeURI, nsIURI* *aResult)
    1: {
    1:   nsresult rv;
    1:   NS_ASSERTION(aChromeURI, "null url!");
    1: 
    1:   if (mOverrideTable.Get(aChromeURI, aResult))
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIURL> chromeURL (do_QueryInterface(aChromeURI));
    1:   NS_ENSURE_TRUE(chromeURL, NS_NOINTERFACE);
    1: 
    1:   nsCAutoString package, provider, path;
    1:   rv = chromeURL->GetHostPort(package);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = GetProviderAndPath(chromeURL, provider, path);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PackageEntry* entry =
 3233:     static_cast<PackageEntry*>(PL_DHashTableOperate(&mPackagesHash,
    1:                                                        & (nsACString&) package,
    1:                                                        PL_DHASH_LOOKUP));
    1: 
    1:   if (PL_DHASH_ENTRY_IS_FREE(entry)) {
    1:     if (!mInitialized)
    1:       return NS_ERROR_NOT_INITIALIZED;
    1: 
 7934:     LogMessage("No chrome package registered for chrome://%s/%s/%s",
    1:                package.get(), provider.get(), path.get());
    1: 
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (entry->flags & PackageEntry::PLATFORM_PACKAGE) {
    1: #if defined(XP_WIN) || defined(XP_OS2)
    1:     path.Insert("win/", 0);
    1: #elif defined(XP_MACOSX)
    1:     path.Insert("mac/", 0);
    1: #else
    1:     path.Insert("unix/", 0);
    1: #endif
    1:   }
    1: 
    1:   nsIURI* baseURI = nsnull;
    1:   if (provider.EqualsLiteral("locale")) {
    1:     baseURI = entry->locales.GetBase(mSelectedLocale, nsProviderArray::LOCALE);
    1:   }
    1:   else if (provider.EqualsLiteral("skin")) {
    1:     baseURI = entry->skins.GetBase(mSelectedSkin, nsProviderArray::ANY);
    1:   }
11131:   else if (provider.EqualsLiteral("content")) {
    1:     baseURI = entry->baseURI;
    1:   }
    1: 
    1:   if (!baseURI) {
 7934:     LogMessage("No chrome package registered for chrome://%s/%s/%s",
    1:                package.get(), provider.get(), path.get());
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return NS_NewURI(aResult, path, nsnull, baseURI);
    1: }
    1: 
    1: nsresult
    1: nsChromeRegistry::GetSelectedLocale(const nsACString& aPackage, nsACString& aLocale)
    1: {
    1:   PackageEntry* entry =
 3233:     static_cast<PackageEntry*>(PL_DHashTableOperate(&mPackagesHash,
    1:                                                        & aPackage,
    1:                                                        PL_DHASH_LOOKUP));
    1: 
    1:   if (PL_DHASH_ENTRY_IS_FREE(entry))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   aLocale = entry->locales.GetSelected(mSelectedLocale, nsProviderArray::LOCALE);
    1:   if (aLocale.IsEmpty())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsChromeRegistry::GetLocalesForPackage(const nsACString& aPackage,
    1:                                        nsIUTF8StringEnumerator* *aResult)
    1: {
    1:   nsCStringArray *a = new nsCStringArray;
    1:   if (!a)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   PackageEntry* entry =
 3233:     static_cast<PackageEntry*>(PL_DHashTableOperate(&mPackagesHash,
    1:                                                        & aPackage,
    1:                                                        PL_DHASH_LOOKUP));
    1: 
    1:   if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:     entry->locales.EnumerateToArray(a);
    1:   }
    1: 
    1:   nsresult rv = NS_NewAdoptingUTF8StringEnumerator(aResult, a);
    1:   if (NS_FAILED(rv))
    1:     delete a;
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef MOZ_XUL
    1: NS_IMETHODIMP
    1: nsChromeRegistry::GetStyleOverlays(nsIURI *aChromeURL,
    1:                                    nsISimpleEnumerator **aResult)
    1: {
    1:   const nsCOMArray<nsIURI>* parray = mStyleHash.GetArray(aChromeURL);
    1:   if (!parray)
    1:     return NS_NewEmptyEnumerator(aResult);
    1: 
    1:   return NS_NewArrayEnumerator(aResult, *parray);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsChromeRegistry::GetXULOverlays(nsIURI *aChromeURL, nsISimpleEnumerator **aResult)
    1: {
    1:   const nsCOMArray<nsIURI>* parray = mOverlayHash.GetArray(aChromeURL);
    1:   if (!parray)
    1:     return NS_NewEmptyEnumerator(aResult);
    1: 
    1:   return NS_NewArrayEnumerator(aResult, *parray);
    1: }
    1: #endif // MOZ_XUL
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: 
    1: // theme stuff
    1: 
    1: 
    1: static void FlushSkinBindingsForWindow(nsIDOMWindowInternal* aWindow)
    1: {
    1:   // Get the DOM document.
    1:   nsCOMPtr<nsIDOMDocument> domDocument;
    1:   aWindow->GetDocument(getter_AddRefs(domDocument));
    1:   if (!domDocument)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
    1:   if (!document)
    1:     return;
    1: 
    1:   // Annihilate all XBL bindings.
    1:   document->FlushSkinBindings();
    1: }
    1: 
    1: // XXXbsmedberg: move this to nsIWindowMediator
    1: NS_IMETHODIMP nsChromeRegistry::RefreshSkins()
    1: {
    1:   nsCOMPtr<nsICSSLoader> cssLoader(do_CreateInstance(kCSSLoaderCID));
    1:   if (!cssLoader)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIWindowMediator> windowMediator
    1:     (do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:   if (!windowMediator)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> windowEnumerator;
    1:   windowMediator->GetEnumerator(nsnull, getter_AddRefs(windowEnumerator));
    1:   PRBool more;
    1:   windowEnumerator->HasMoreElements(&more);
    1:   while (more) {
    1:     nsCOMPtr<nsISupports> protoWindow;
    1:     windowEnumerator->GetNext(getter_AddRefs(protoWindow));
    1:     if (protoWindow) {
    1:       nsCOMPtr<nsIDOMWindowInternal> domWindow = do_QueryInterface(protoWindow);
    1:       if (domWindow)
    1:         FlushSkinBindingsForWindow(domWindow);
    1:     }
    1:     windowEnumerator->HasMoreElements(&more);
    1:   }
    1: 
    1:   FlushSkinCaches();
    1:   
    1:   windowMediator->GetEnumerator(nsnull, getter_AddRefs(windowEnumerator));
    1:   windowEnumerator->HasMoreElements(&more);
    1:   while (more) {
    1:     nsCOMPtr<nsISupports> protoWindow;
    1:     windowEnumerator->GetNext(getter_AddRefs(protoWindow));
    1:     if (protoWindow) {
    1:       nsCOMPtr<nsIDOMWindowInternal> domWindow = do_QueryInterface(protoWindow);
    1:       if (domWindow)
    1:         RefreshWindow(domWindow, cssLoader);
    1:     }
    1:     windowEnumerator->HasMoreElements(&more);
    1:   }
    1:    
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsChromeRegistry::FlushSkinCaches()
    1: {
    1:   nsCOMPtr<nsIObserverService> obsSvc =
    1:     do_GetService("@mozilla.org/observer-service;1");
    1:   NS_ASSERTION(obsSvc, "Couldn't get observer service.");
    1: 
 3233:   obsSvc->NotifyObservers(static_cast<nsIChromeRegistry*>(this),
    1:                           NS_CHROME_FLUSH_SKINS_TOPIC, nsnull);
    1: }
    1: 
    1: static PRBool IsChromeURI(nsIURI* aURI)
    1: {
    1:     PRBool isChrome=PR_FALSE;
    1:     if (NS_SUCCEEDED(aURI->SchemeIs("chrome", &isChrome)) && isChrome)
    1:         return PR_TRUE;
    1:     return PR_FALSE;
    1: }
    1: 
    1: // XXXbsmedberg: move this to windowmediator
    1: nsresult nsChromeRegistry::RefreshWindow(nsIDOMWindowInternal* aWindow,
    1:                                          nsICSSLoader* aCSSLoader)
    1: {
    1:   // Deal with our subframes first.
    1:   nsCOMPtr<nsIDOMWindowCollection> frames;
    1:   aWindow->GetFrames(getter_AddRefs(frames));
    1:   PRUint32 length;
    1:   frames->GetLength(&length);
    1:   PRUint32 j;
    1:   for (j = 0; j < length; j++) {
    1:     nsCOMPtr<nsIDOMWindow> childWin;
    1:     frames->Item(j, getter_AddRefs(childWin));
    1:     nsCOMPtr<nsIDOMWindowInternal> childInt(do_QueryInterface(childWin));
    1:     RefreshWindow(childInt, aCSSLoader);
    1:   }
    1: 
    1:   nsresult rv;
    1:   // Get the DOM document.
    1:   nsCOMPtr<nsIDOMDocument> domDocument;
    1:   aWindow->GetDocument(getter_AddRefs(domDocument));
    1:   if (!domDocument)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
    1:   if (!document)
    1:     return NS_OK;
    1: 
    1:   // Deal with the agent sheets first.  Have to do all the style sets by hand.
 1722:   nsPresShellIterator iter(document);
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell())) {
    1:     // Reload only the chrome URL agent style sheets.
    1:     nsCOMArray<nsIStyleSheet> agentSheets;
    1:     rv = shell->GetAgentStyleSheets(agentSheets);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMArray<nsIStyleSheet> newAgentSheets;
    1:     for (PRInt32 l = 0; l < agentSheets.Count(); ++l) {
    1:       nsIStyleSheet *sheet = agentSheets[l];
    1: 
    1:       nsCOMPtr<nsIURI> uri;
    1:       rv = sheet->GetSheetURI(getter_AddRefs(uri));
    1:       if (NS_FAILED(rv)) return rv;
    1: 
    1:       if (IsChromeURI(uri)) {
    1:         // Reload the sheet.
    1:         nsCOMPtr<nsICSSStyleSheet> newSheet;
    1:         rv = aCSSLoader->LoadSheetSync(uri, PR_TRUE, getter_AddRefs(newSheet));
    1:         if (NS_FAILED(rv)) return rv;
    1:         if (newSheet) {
    1:           rv = newAgentSheets.AppendObject(newSheet) ? NS_OK : NS_ERROR_FAILURE;
    1:           if (NS_FAILED(rv)) return rv;
    1:         }
    1:       }
    1:       else {  // Just use the same sheet.
    1:         rv = newAgentSheets.AppendObject(sheet) ? NS_OK : NS_ERROR_FAILURE;
    1:         if (NS_FAILED(rv)) return rv;
    1:       }
    1:     }
    1: 
    1:     rv = shell->SetAgentStyleSheets(newAgentSheets);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // Build an array of nsIURIs of style sheets we need to load.
    1:   nsCOMArray<nsIStyleSheet> oldSheets;
    1:   nsCOMArray<nsIStyleSheet> newSheets;
    1: 
    1:   PRInt32 count = document->GetNumberOfStyleSheets();
    1: 
    1:   // Iterate over the style sheets.
    1:   PRInt32 i;
    1:   for (i = 0; i < count; i++) {
    1:     // Get the style sheet
    1:     nsIStyleSheet *styleSheet = document->GetStyleSheetAt(i);
    1:     
    1:     if (!oldSheets.AppendObject(styleSheet)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   // Iterate over our old sheets and kick off a sync load of the new 
    1:   // sheet if and only if it's a chrome URL.
    1:   for (i = 0; i < count; i++) {
    1:     nsCOMPtr<nsIStyleSheet> sheet = oldSheets[i];
    1:     nsCOMPtr<nsIURI> uri;
    1:     rv = sheet->GetSheetURI(getter_AddRefs(uri));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     if (IsChromeURI(uri)) {
    1:       // Reload the sheet.
    1: #ifdef DEBUG
    1:       nsCOMPtr<nsICSSStyleSheet> oldCSSSheet = do_QueryInterface(sheet);
    1:       NS_ASSERTION(oldCSSSheet, "Don't know how to reload a non-CSS sheet");
    1: #endif
    1:       nsCOMPtr<nsICSSStyleSheet> newSheet;
    1:       // XXX what about chrome sheets that have a title or are disabled?  This
    1:       // only works by sheer dumb luck.
    1:       // XXXbz this should really use the document's CSSLoader!
    1:       aCSSLoader->LoadSheetSync(uri, getter_AddRefs(newSheet));
    1:       // Even if it's null, we put in in there.
    1:       newSheets.AppendObject(newSheet);
    1:     }
    1:     else {
    1:       // Just use the same sheet.
    1:       newSheets.AppendObject(sheet);
    1:     }
    1:   }
    1: 
    1:   // Now notify the document that multiple sheets have been added and removed.
    1:   document->UpdateStyleSheets(oldSheets, newSheets);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsChromeRegistry::FlushAllCaches()
    1: {
    1:   nsCOMPtr<nsIObserverService> obsSvc =
    1:     do_GetService("@mozilla.org/observer-service;1");
    1:   NS_ASSERTION(obsSvc, "Couldn't get observer service.");
    1: 
    1:   obsSvc->NotifyObservers((nsIChromeRegistry*) this,
    1:                           NS_CHROME_FLUSH_TOPIC, nsnull);
    1: }  
    1: 
    1: // xxxbsmedberg Move me to nsIWindowMediator
    1: NS_IMETHODIMP
    1: nsChromeRegistry::ReloadChrome()
    1: {
    1:   FlushAllCaches();
    1:   // Do a reload of all top level windows.
    1:   nsresult rv = NS_OK;
    1: 
    1:   // Get the window mediator
    1:   nsCOMPtr<nsIWindowMediator> windowMediator
    1:     (do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:   if (windowMediator) {
    1:     nsCOMPtr<nsISimpleEnumerator> windowEnumerator;
    1: 
    1:     rv = windowMediator->GetEnumerator(nsnull, getter_AddRefs(windowEnumerator));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       // Get each dom window
    1:       PRBool more;
    1:       rv = windowEnumerator->HasMoreElements(&more);
    1:       if (NS_FAILED(rv)) return rv;
    1:       while (more) {
    1:         nsCOMPtr<nsISupports> protoWindow;
    1:         rv = windowEnumerator->GetNext(getter_AddRefs(protoWindow));
    1:         if (NS_SUCCEEDED(rv)) {
    1:           nsCOMPtr<nsIDOMWindowInternal> domWindow =
    1:             do_QueryInterface(protoWindow);
    1:           if (domWindow) {
    1:             nsCOMPtr<nsIDOMLocation> location;
    1:             domWindow->GetLocation(getter_AddRefs(location));
    1:             if (location) {
    1:               rv = location->Reload(PR_FALSE);
    1:               if (NS_FAILED(rv)) return rv;
    1:             }
    1:           }
    1:         }
    1:         rv = windowEnumerator->HasMoreElements(&more);
    1:         if (NS_FAILED(rv)) return rv;
    1:       }
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsChromeRegistry::AllowScriptsForPackage(nsIURI* aChromeURI, PRBool *aResult)
    1: {
    1:   nsresult rv;
    1:   *aResult = PR_FALSE;
    1: 
    1: #ifdef DEBUG
    1:   PRBool isChrome;
    1:   aChromeURI->SchemeIs("chrome", &isChrome);
    1:   NS_ASSERTION(isChrome, "Non-chrome URI passed to AllowScriptsForPackage!");
    1: #endif
    1: 
    1:   nsCOMPtr<nsIURL> url (do_QueryInterface(aChromeURI));
    1:   NS_ENSURE_TRUE(url, NS_NOINTERFACE);
    1: 
    1:   nsCAutoString provider, file;
    1:   rv = GetProviderAndPath(url, provider, file);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!provider.EqualsLiteral("skin"))
    1:     *aResult = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static PLDHashOperator
    1: RemoveAll(PLDHashTable *table, PLDHashEntryHdr *entry, PRUint32 number, void *arg)
    1: {
    1:   return (PLDHashOperator) (PL_DHASH_NEXT | PL_DHASH_REMOVE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsChromeRegistry::CheckForNewChrome()
    1: {
    1:   nsresult rv;
    1: 
    1:   PL_DHashTableEnumerate(&mPackagesHash, RemoveAll, nsnull);
    1:   mOverlayHash.Clear();
    1:   mStyleHash.Clear();
    1:   mOverrideTable.Clear();
    1: 
    1:   nsCOMPtr<nsIURI> manifestURI;
    1:   rv = NS_NewURI(getter_AddRefs(manifestURI),
    1:                  NS_LITERAL_CSTRING("resource:///chrome/app-chrome.manifest"));
    1: 
    1:   // this is the main manifest; if it doesn't exist we generate it from
    1:   // installed-chrome.txt. When the build system learns about the new system,
    1:   // this code can go away.
    1: 
    1:   nsCOMPtr<nsIFileURL> manifestFileURL (do_QueryInterface(manifestURI));
    1:   NS_ASSERTION(manifestFileURL, "Not a nsIFileURL!");
13899:   NS_ENSURE_TRUE(manifestFileURL, NS_ERROR_UNEXPECTED);
    1: 
    1:   nsCOMPtr<nsIFile> manifest;
    1:   manifestFileURL->GetFile(getter_AddRefs(manifest));
    1:   NS_ENSURE_TRUE(manifest, NS_ERROR_FAILURE);
    1: 
    1:   PRBool exists;
    1:   rv = manifest->Exists(&exists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1: #ifdef DEBUG
    1:   // In debug builds, installed-chrome.txt may change during development;
    1:   // we just rebuild it every time because we're not worried about startup
    1:   // time or other bad/goodness.
    1:   if (exists) {
    1:     manifest->Remove(PR_FALSE);
    1:     exists = PR_FALSE;
    1:   }
    1: #endif
    1: 
    1:   if (!exists) {
    1:     nsCOMPtr<nsIFile> installed;
    1:     manifest->Clone(getter_AddRefs(installed));
    1:     if (!installed)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     nsCOMPtr<nsILocalFile> linstalled (do_QueryInterface(installed));
    1:     NS_ENSURE_TRUE(linstalled, NS_NOINTERFACE);
    1: 
    1:     linstalled->SetNativeLeafName(NS_LITERAL_CSTRING("installed-chrome.txt"));
    1: 
 3491:     rv = linstalled->Exists(&exists);
 3491:     NS_ENSURE_SUCCESS(rv, rv);
 3491: 
    1:     // process installed-chrome.txt into app-chrome.manifest
 3491:     if (exists)
    1:       ProcessNewChromeFile(linstalled, manifestURI);
    1:   }
    1: 
    1:   nsCOMPtr<nsIProperties> dirSvc (do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
    1:   NS_ENSURE_TRUE(dirSvc, NS_ERROR_FAILURE);
    1: 
    1:   // check the extra chrome directories
    1:   nsCOMPtr<nsISimpleEnumerator> chromeML;
    1:   rv = dirSvc->Get(NS_CHROME_MANIFESTS_FILE_LIST, NS_GET_IID(nsISimpleEnumerator),
    1:                    getter_AddRefs(chromeML));
    1:   if (NS_FAILED(rv)) {
    1:     // ok, then simply load all .manifest files in the app chrome dir.
    1:     nsCOMPtr<nsIFile> chromeDir;
    1:     rv = dirSvc->Get(NS_APP_CHROME_DIR, NS_GET_IID(nsIFile),
    1:                      getter_AddRefs(chromeDir));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     rv = NS_NewSingletonEnumerator(getter_AddRefs(chromeML), chromeDir);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsISupports> next;
    1:   while (NS_SUCCEEDED(chromeML->HasMoreElements(&exists)) && exists) {
    1:     chromeML->GetNext(getter_AddRefs(next));
    1:     nsCOMPtr<nsILocalFile> lmanifest = do_QueryInterface(next);
    1:     if (!lmanifest) {
    1:       NS_ERROR("Directory enumerator returned a non-nsILocalFile");
    1:       continue;
    1:     }
    1: 
    1:     PRBool isDir;
    1:     if (NS_SUCCEEDED(lmanifest->IsDirectory(&isDir)) && isDir) {
    1:       nsCOMPtr<nsISimpleEnumerator> entries;
    1:       rv = lmanifest->GetDirectoryEntries(getter_AddRefs(entries));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1: 
    1:       while (NS_SUCCEEDED(entries->HasMoreElements(&exists)) && exists) {
    1:         entries->GetNext(getter_AddRefs(next));
    1:         lmanifest = do_QueryInterface(next);
    1:         if (lmanifest) {
    1:           nsCAutoString leafName;
    1:           lmanifest->GetNativeLeafName(leafName);
    1:           if (StringEndsWith(leafName, NS_LITERAL_CSTRING(".manifest"))) {
    1:             rv = ProcessManifest(lmanifest, PR_FALSE);
    1:             if (NS_FAILED(rv)) {
    1:               nsCAutoString path;
    1:               lmanifest->GetNativePath(path);
    1:               LogMessage("Failed to process chrome manifest '%s'.",
    1:                          path.get());
    1: 
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:     else {
    1:       rv = ProcessManifest(lmanifest, PR_FALSE);
    1:       if (NS_FAILED(rv)) {
    1:         nsCAutoString path;
    1:         lmanifest->GetNativePath(path);
    1:         LogMessage("Failed to process chrome manifest: '%s'.",
    1:                    path.get());
    1:       }
    1:     }
    1:   }
    1: 
    1:   rv = dirSvc->Get(NS_SKIN_MANIFESTS_FILE_LIST, NS_GET_IID(nsISimpleEnumerator),
    1:                    getter_AddRefs(chromeML));
    1:   if (NS_FAILED(rv))
    1:     return NS_OK;
    1: 
    1:   while (NS_SUCCEEDED(chromeML->HasMoreElements(&exists)) && exists) {
    1:     chromeML->GetNext(getter_AddRefs(next));
    1:     nsCOMPtr<nsILocalFile> lmanifest = do_QueryInterface(next);
    1:     if (!lmanifest) {
    1:       NS_ERROR("Directory enumerator returned a non-nsILocalFile");
    1:       continue;
    1:     }
    1: 
    1:     rv = ProcessManifest(lmanifest, PR_TRUE);
    1:     if (NS_FAILED(rv)) {
    1:       nsCAutoString path;
    1:       lmanifest->GetNativePath(path);
    1:       LogMessage("Failed to process chrome manifest: '%s'.",
    1:                  path.get());
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsChromeRegistry::ProcessNewChromeFile(nsILocalFile *aListFile, nsIURI* aManifest)
    1: {
    1:   nsresult rv;
    1: 
    1:   PRFileDesc *file;
    1:   rv = aListFile->OpenNSPRFileDesc(PR_RDONLY, 0, &file);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt32 n, size;
    1:   char *buf;
    1: 
    1:   size = PR_Available(file);
    1:   if (size == -1) {
    1:     rv = NS_ERROR_UNEXPECTED;
    1:     goto end;
    1:   }
    1: 
    1:   buf = (char *) malloc(size + 1);
    1:   if (!buf) {
    1:     rv = NS_ERROR_OUT_OF_MEMORY;
    1:     goto end;
    1:   }
    1: 
    1:   n = PR_Read(file, buf, size);
    1:   if (n > 0)
    1:     rv = ProcessNewChromeBuffer(buf, size, aManifest);
    1:   free(buf);
    1: 
    1: end:
    1:   PR_Close(file);
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsChromeRegistry::ProcessNewChromeBuffer(char *aBuffer, PRInt32 aLength,
    1:                                          nsIURI* aManifest)
    1: {
    1:   nsresult rv = NS_OK;
    1:   char   *bufferEnd = aBuffer + aLength;
    1:   char   *chromeType,      // "content", "locale" or "skin"
    1:          *chromeProfile,   // "install" or "profile"
    1:          *chromeLocType,   // type of location (local path or URL)
    1:          *chromeLocation;  // base location of chrome (jar file)
    1: 
    1:   nsCOMPtr<nsIURI> baseURI;
    1: 
    1:   // process chromeType, chromeProfile, chromeLocType, chromeLocation
    1:   while (aBuffer < bufferEnd) {
    1:     // parse one line of installed-chrome.txt
    1:     chromeType = aBuffer;
    1:     while (aBuffer < bufferEnd && *aBuffer != ',')
    1:       ++aBuffer;
    1:     *aBuffer = '\0';
    1: 
    1:     chromeProfile = ++aBuffer;
    1:     if (aBuffer >= bufferEnd)
    1:       break;
    1: 
    1:     while (aBuffer < bufferEnd && *aBuffer != ',')
    1:       ++aBuffer;
    1:     *aBuffer = '\0';
    1: 
    1:     chromeLocType = ++aBuffer;
    1:     if (aBuffer >= bufferEnd)
    1:       break;
    1: 
    1:     while (aBuffer < bufferEnd && *aBuffer != ',')
    1:       ++aBuffer;
    1:     *aBuffer = '\0';
    1: 
    1:     chromeLocation = ++aBuffer;
    1:     if (aBuffer >= bufferEnd)
    1:       break;
    1: 
    1:     while (aBuffer < bufferEnd &&
    1:            (*aBuffer != '\r' && *aBuffer != '\n' && *aBuffer != ' '))
    1:       ++aBuffer;
    1:     *aBuffer = '\0';
    1: 
    1:     // process the line
    1:     // We don't do skin or locale selection from installed-chrome.txt since
    1:     // ffox 0.9. Just ignore the "select" lines.
    1:     if (strcmp(chromeLocType,"select")) {
    1:       if (!strcmp(chromeLocType, "path")) {
    1:         // location is a (full) path. convert it to an URL.
    1: 
    1:         /* this is some convoluted shit... this creates a file, inits it with
    1:          * the path parsed above (chromeLocation), makes a url, and inits it
    1:          * with the file created. the purpose of this is just to have the
    1:          * canonical url of the stupid thing.
    1:          */
    1:         nsCOMPtr<nsILocalFile> chromeFile;
    1:         rv = NS_NewNativeLocalFile(nsDependentCString(chromeLocation),
    1:                                    PR_TRUE, getter_AddRefs(chromeFile));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         /* 
    1:          * all we want here is the canonical url
    1:          */
    1:         rv = NS_NewFileURI(getter_AddRefs(baseURI), chromeFile);
    1:         if (NS_FAILED(rv)) return rv;
    1:       }
    1:       else {
    1:         rv = NS_NewURI(getter_AddRefs(baseURI), chromeLocation);
    1:         if (NS_FAILED(rv)) return rv;
    1:       }
    1: 
    1:       ProcessContentsManifest(baseURI, aManifest, baseURI, PR_TRUE,
    1:                               strcmp(chromeType, "skin") == 0);
    1:     }
    1:     
    1:     while (aBuffer < bufferEnd && (*aBuffer == '\0' || *aBuffer == ' ' || *aBuffer == '\r' || *aBuffer == '\n'))
    1:       ++aBuffer;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsChromeRegistry::Observe(nsISupports *aSubject, const char *aTopic, const PRUnichar *someData)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!strcmp(NS_PREFBRANCH_PREFCHANGE_TOPIC_ID, aTopic)) {
    1:     nsCOMPtr<nsIPrefBranch> prefs (do_QueryInterface(aSubject));
    1:     NS_ASSERTION(prefs, "Bad observer call!");
    1: 
    1:     NS_ConvertUTF16toUTF8 pref(someData);
    1: 
    1:     nsXPIDLCString provider;
    1:     rv = prefs->GetCharPref(pref.get(), getter_Copies(provider));
    1:     if (NS_FAILED(rv)) {
    1:       NS_ERROR("Couldn't get new locale or skin pref!");
    1:       return rv;
    1:     }
    1: 
    1:     if (pref.EqualsLiteral(SELECTED_SKIN_PREF)) {
    1:       mSelectedSkin = provider;
    1:       RefreshSkins();
    1:     }
    1:     else if (pref.EqualsLiteral(SELECTED_LOCALE_PREF)) {
    1:       mSelectedLocale = provider;
    1:       FlushAllCaches();
    1:     } else {
    1:       NS_ERROR("Unexpected pref!");
    1:     }
    1:   }
    1:   else if (!strcmp("command-line-startup", aTopic)) {
    1:     nsCOMPtr<nsICommandLine> cmdLine (do_QueryInterface(aSubject));
    1:     if (cmdLine) {
    1:       nsAutoString uiLocale;
    1:       rv = cmdLine->HandleFlagWithParam(NS_LITERAL_STRING(UILOCALE_CMD_LINE_ARG),
    1:                                         PR_FALSE, uiLocale);
    1:       if (NS_SUCCEEDED(rv) && !uiLocale.IsEmpty()) {
    1:         CopyUTF16toUTF8(uiLocale, mSelectedLocale);
    1:         nsCOMPtr<nsIPrefBranch2> prefs (do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:         if (prefs) {
    1:           prefs->RemoveObserver(SELECTED_LOCALE_PREF, this);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     NS_ERROR("Unexpected observer topic!");
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef MOZ_XUL
    1: static nsresult
    1: GetContainerEnumerator(nsIRDFDataSource* ds, nsIRDFResource* res,
    1:                        nsISimpleEnumerator* *aResult, PRInt32 *aCountResult = nsnull)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIRDFContainer> container
    1:     (do_CreateInstance("@mozilla.org/rdf/container;1"));
    1:   NS_ENSURE_TRUE(container, NS_ERROR_FAILURE);
    1: 
    1:   rv = container->Init(ds, res);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   if (aCountResult)
    1:     container->GetCount(aCountResult);
    1: 
    1:   return container->GetElements(aResult);
    1: }
    1: 
    1: static void
    1: FollowLiteral(nsIRDFDataSource* ds, nsIRDFResource* res,
    1:               nsIRDFResource* arc, nsACString& result)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIRDFNode> node;
    1:   rv = ds->GetTarget(res, arc, PR_TRUE, getter_AddRefs(node));
    1:   if (NS_FAILED(rv) || !node) {
    1:     result.Truncate();
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIRDFLiteral> literal (do_QueryInterface(node));
    1:   if (!literal) {
    1:     NS_ERROR("Arc found, but doesn't point to expected literal!");
    1:     result.Truncate();
    1:     return;
    1:   }
    1: 
    1:   const PRUnichar* value;
    1:   literal->GetValueConst(&value);
    1:   CopyUTF16toUTF8(value, result);
    1: }
    1: 
    1: static void
    1: FollowResource(nsIRDFDataSource* ds, nsIRDFResource* res, nsIRDFResource* arc,
    1:                nsIRDFResource* *result)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIRDFNode> node;
    1:   rv = ds->GetTarget(res, arc, PR_TRUE, getter_AddRefs(node));
    1:   if (NS_FAILED(rv) || !node) {
    1:     *result = nsnull;
    1:     return;
    1:   }
    1: 
    1:   CallQueryInterface(node, result);
    1: }
    1: 
    1: static void
    1: GetRelativePath(nsIURI* base, nsIURI* relative, nsACString& result)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIJARURI> jarrelative (do_QueryInterface(relative));
    1:   if (jarrelative) {
    1:     nsCOMPtr<nsIURI> jarbase;
    1:     jarrelative->GetJARFile(getter_AddRefs(jarbase));
    1: 
    1:     nsCAutoString relativeBase;
    1:     GetRelativePath(base, jarbase, relativeBase);
    1: 
    1:     nsCAutoString jarEntry;
    1:     jarrelative->GetJAREntry(jarEntry);
    1: 
    1:     result.Assign(NS_LITERAL_CSTRING("jar:"));
    1:     result.Append(relativeBase);
    1:     result.Append(NS_LITERAL_CSTRING("!/"));
    1:     result.Append(jarEntry);
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURL> baseURL (do_QueryInterface(base));
    1:   if (!baseURL) {
    1:     relative->GetSpec(result);
    1:     return;
    1:   }
    1: 
    1:   rv = baseURL->GetRelativeSpec(relative, result);
    1:   if (NS_FAILED(rv)) {
    1:     relative->GetSpec(result);
    1:   }
    1: }
    1: 
    1: static const PRInt32 kNSPR_APPEND_FLAGS = PR_WRONLY | PR_CREATE_FILE | PR_APPEND;
    1: static const PRInt32 kNSPR_TRUNCATE_FLAGS = PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE;
    1: 
    1: NS_IMETHODIMP
    1: nsChromeRegistry::ProcessContentsManifest(nsIURI* aOldManifest, nsIURI* aFile,
    1:                                           nsIURI* aBaseURI, PRBool aAppend,
    1:                                           PRBool aSkinOnly)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCAutoString relativePath;
    1:   GetRelativePath(aFile, aBaseURI, relativePath);
    1: 
    1:   nsCAutoString spec;
    1:   aOldManifest->GetSpec(spec);
    1: 
    1:   NS_ASSERTION(spec.Last() == '/', "installed-chrome manifest URI doesn't end in a slash! It probably won't work.");
    1: 
    1:   spec.AppendLiteral("contents.rdf");
    1: 
    1:   nsCOMPtr<nsIRDFService> rdfs (do_GetService("@mozilla.org/rdf/rdf-service;1"));
    1:   NS_ENSURE_TRUE(rdfs, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIRDFResource> namearc, platformarc;
    1:   rdfs->GetResource(NS_LITERAL_CSTRING(kURICHROME_name),
    1:                     getter_AddRefs(namearc));
    1:   rdfs->GetResource(NS_LITERAL_CSTRING(kURICHROME_platformPackage),
    1:                     getter_AddRefs(platformarc));
    1:   if (!(namearc && platformarc))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIRDFDataSource> ds;
    1:   rv = rdfs->GetDataSourceBlocking(spec.get(), getter_AddRefs(ds));
    1:   if (NS_FAILED(rv)) {
    1:     LogMessage("Failed to load old-style contents.rdf at '%s'.",
    1:                spec.get());
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIFileURL> fileURL (do_QueryInterface(aFile));
    1:   NS_ENSURE_TRUE(fileURL, NS_ERROR_INVALID_ARG);
    1: 
    1:   nsCOMPtr<nsIFile> file;
    1:   rv = fileURL->GetFile(getter_AddRefs(file));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsILocalFile> lfile (do_QueryInterface(file));
    1:   NS_ENSURE_TRUE(lfile, NS_ERROR_NO_INTERFACE);
    1: 
    1:   PRFileDesc* fd;
    1:   rv = lfile->OpenNSPRFileDesc(aAppend ? kNSPR_APPEND_FLAGS : kNSPR_TRUNCATE_FLAGS,
    1:                                0664, &fd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aAppend)
    1:     PR_Write(fd, "\n", 1);
    1: 
    1:   nsCOMPtr<nsIRDFResource> root;
    1:   rv = rdfs->GetResource(NS_LITERAL_CSTRING("urn:mozilla:skin:root"),
    1:                          getter_AddRefs(root));
    1:   if (NS_SUCCEEDED(rv))
    1:     ProcessProvider(fd, rdfs, ds, root, PR_FALSE, relativePath);
    1: 
    1:   rv = rdfs->GetResource(NS_LITERAL_CSTRING("urn:mozilla:stylesheets"),
    1:                          getter_AddRefs(root));
    1:   if (NS_SUCCEEDED(rv))
    1:     ProcessOverlays(fd, ds, root, NS_LITERAL_CSTRING("style"));
    1: 
    1:   if (!aSkinOnly) {
    1:     rv = rdfs->GetResource(NS_LITERAL_CSTRING("urn:mozilla:locale:root"),
    1:                            getter_AddRefs(root));
    1:     if (NS_SUCCEEDED(rv))
    1:       ProcessProvider(fd, rdfs, ds, root, PR_TRUE, relativePath);
    1: 
    1:     rv = rdfs->GetResource(NS_LITERAL_CSTRING("urn:mozilla:overlays"),
    1:                          getter_AddRefs(root));
    1:     if (NS_SUCCEEDED(rv))
    1:       ProcessOverlays(fd, ds, root, NS_LITERAL_CSTRING("overlay"));
    1: 
    1:     /* content packages are easier, but different */
    1: 
    1:     rv = rdfs->GetResource(NS_LITERAL_CSTRING("urn:mozilla:package:root"),
    1:                            getter_AddRefs(root));
    1: 
    1:     nsCOMPtr<nsISimpleEnumerator> packages;
    1:     if (NS_SUCCEEDED(rv))
    1:       rv = GetContainerEnumerator(ds, root, getter_AddRefs(packages));
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:       PRBool more;
    1:       nsCOMPtr<nsISupports> next;
    1:       nsCOMPtr<nsIRDFResource> package;
    1: 
    1:       while (NS_SUCCEEDED(packages->HasMoreElements(&more)) && more) {
    1:         packages->GetNext(getter_AddRefs(next));
    1: 
    1:         package = do_QueryInterface(next);
    1:         if (!package) {
    1:           NS_WARNING("Arc from urn:mozilla:package:root points to non-resource node.");
    1:           continue;
    1:         }
    1: 
    1:         nsCAutoString name;
    1:         FollowLiteral(ds, package, namearc, name);
    1:         if (name.IsEmpty())
    1:           continue;
    1: 
    1:         nsCAutoString isPlatform;
    1:         FollowLiteral(ds, package, platformarc, isPlatform);
    1:         name.Insert(NS_LITERAL_CSTRING("content\t"), 0);
    1:         name.Append('\t');
    1:         name.Append(relativePath);
    1:         if (!isPlatform.IsEmpty())
    1:           name.AppendLiteral("\tplatform");
    1: 
    1:         name.AppendLiteral(NS_LINEBREAK);
    1:         PR_Write(fd, name.get(), name.Length());
    1:       }
    1:     }
    1:   }
    1: 
    1:   PR_Close(fd);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: GetResourceName(nsIRDFResource* res, nsACString& result)
    1: {
    1:   // we need to get the provider name. Instead of doing something sane,
    1:   // we munge the resource URI, looking from the right for colons.
    1: 
    1:   nsCAutoString providerURI;
    1:   res->GetValueUTF8(providerURI);
    1: 
    1:   PRInt32 found = providerURI.RFindChar(':');
    1:   if (found == kNotFound) {
    1:     result.Truncate();
    1:     return;
    1:   }
    1: 
    1:   result.Assign(Substring(providerURI, found + 1));
    1: }
    1: 
    1: 
    1: void
    1: nsChromeRegistry::ProcessProvider(PRFileDesc *fd, nsIRDFService* aRDFs,
    1:                                   nsIRDFDataSource* aDS, nsIRDFResource* aRoot,
    1:                                   PRBool aIsLocale, const nsACString& aBaseURL)
    1: {
    1:   NS_NAMED_LITERAL_CSTRING(kSlash, "/");
    1:   NS_NAMED_LITERAL_CSTRING(kTab, "\t");
    1: 
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIRDFResource> packagesarc;
    1:   aRDFs->GetResource(NS_LITERAL_CSTRING(kURICHROME_packages),
    1:                     getter_AddRefs(packagesarc));
    1:   if (!packagesarc) return;
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> providers;
    1:   rv = GetContainerEnumerator(aDS, aRoot, getter_AddRefs(providers));
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsISupports> next;
    1: 
    1:   PRBool more;
    1:   while (NS_SUCCEEDED(providers->HasMoreElements(&more)) && more) {
    1:     providers->GetNext(getter_AddRefs(next));
    1:     NS_ASSERTION(next, "GetNext failed after HasMoreElements succeeded.");
    1: 
    1:     nsCOMPtr<nsIRDFResource> provider (do_QueryInterface(next));
    1:     if (!provider) {
    1:       NS_WARNING("Provider isn't a nsIRDFResource.");
    1:       continue;
    1:     }
    1: 
    1:     nsCAutoString providerName;
    1:     GetResourceName(provider, providerName);
    1:     if (providerName.IsEmpty()) {
    1:       NS_WARNING("Couldn't calculate resource name.");
    1:       continue;
    1:     }
    1: 
    1:     nsCOMPtr<nsIRDFResource> packages;
    1:     FollowResource(aDS, provider, packagesarc, getter_AddRefs(packages));
    1:     if (!packages) {
    1:       NS_WARNING("No chrome:packages arc found!");
    1:       continue;
    1:     }
    1: 
    1:     PRInt32 count;
    1:     nsCOMPtr<nsISimpleEnumerator> packageList;
    1:     rv = GetContainerEnumerator(aDS, packages, getter_AddRefs(packageList), &count);
    1:     if (NS_FAILED(rv)) {
    1:       NS_WARNING("chrome:packages was not a sequence.");
    1:       continue;
    1:     }
    1: 
    1:     nsCOMPtr<nsISupports> nextPackage;
    1: 
    1:     PRBool morePackages;
    1:     while (NS_SUCCEEDED(packageList->HasMoreElements(&morePackages)) &&
    1:            morePackages) {
    1:       packageList->GetNext(getter_AddRefs(nextPackage));
    1: 
    1:       nsCOMPtr<nsIRDFResource> packageRes (do_QueryInterface(nextPackage));
    1:       if (!packageRes) {
    1:         NS_WARNING("chrome:packages Seq points to a non-resource!");
    1:         continue;
    1:       }
    1: 
    1:       nsCAutoString packageName;
    1:       GetResourceName(packageRes, packageName);
    1:       if (packageName.IsEmpty()) {
    1:         NS_WARNING("couldn't extract a package name.");
    1:         continue;
    1:       }
    1: 
    1:       nsCAutoString line;
    1: 
    1:       if (aIsLocale)
    1:         line.AppendLiteral("locale\t");
    1:       else
    1:         line.AppendLiteral("skin\t");
    1: 
    1:       line += packageName + kTab + providerName + kTab + aBaseURL;
    1:       if (count > 1) {
    1:         line += packageName + kSlash;
    1:       }
    1:       line.AppendLiteral(NS_LINEBREAK);
    1:       PR_Write(fd, line.get(), line.Length());
    1:     }
    1:   }
    1: }
    1: 
    1: static void
    1: GetLiteralText(nsIRDFLiteral* lit, nsACString& result)
    1: {
    1:   const PRUnichar* value;
    1:   lit->GetValueConst(&value);
    1:   CopyUTF16toUTF8(value, result);
    1: }
    1: 
    1: void
    1: nsChromeRegistry::ProcessOverlays(PRFileDesc *fd, nsIRDFDataSource* aDS,
    1:                                   nsIRDFResource* aRoot,
    1:                                   const nsCSubstring& aType)
    1: {
    1:   NS_NAMED_LITERAL_CSTRING(kTab, "\t");
    1:   NS_NAMED_LITERAL_CSTRING(kLinebreak, NS_LINEBREAK);
    1: 
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> overlaids;
    1:   rv = GetContainerEnumerator(aDS, aRoot, getter_AddRefs(overlaids));
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsISupports> next;
    1:   PRBool more;
    1:   while (NS_SUCCEEDED(overlaids->HasMoreElements(&more)) && more) {
    1:     overlaids->GetNext(getter_AddRefs(next));
    1:     NS_ASSERTION(next, "GetNext failed after HasMoreElements succeeded.");
    1: 
    1:     nsCOMPtr<nsIRDFResource> overlaid (do_QueryInterface(next));
    1:     if (!overlaid) {
    1:       NS_WARNING("Overlay arc is not a nsIRDFResource.");
    1:       continue;
    1:     }
    1: 
    1:     nsCAutoString overlaidName;
    1:     overlaid->GetValueUTF8(overlaidName);
    1: 
    1:     nsCOMPtr<nsISimpleEnumerator> overlays;
    1:     rv = GetContainerEnumerator(aDS, overlaid, getter_AddRefs(overlays));
    1:     if (NS_FAILED(rv))
    1:       continue;
    1: 
    1:     while (NS_SUCCEEDED(overlays->HasMoreElements(&more)) && more) {
    1:       overlays->GetNext(getter_AddRefs(next));
    1:       NS_ASSERTION(next, "GetNext failed after HasMoreElements succeeded.");
    1: 
    1:       nsCOMPtr<nsIRDFLiteral> overlay (do_QueryInterface(next));
    1:       if (!overlay) {
    1:         NS_WARNING("Overlay was not an RDF literal.");
    1:         continue;
    1:       }
    1: 
    1:       nsCAutoString overlayName;
    1:       GetLiteralText(overlay, overlayName);
    1: 
    1:       overlayName.Insert(aType + kTab + overlaidName + kTab, 0);
    1:       overlayName.Append(kLinebreak);
    1:       PR_Write(fd, overlayName.get(), overlayName.Length());
    1:     }
    1:   }
    1: }
    1: 
    1: #else // MOZ_XUL
    1: 
    1: NS_IMETHODIMP
    1: nsChromeRegistry::ProcessContentsManifest(nsIURI* aOldManifest, nsIURI* aFile,
    1:                                           nsIURI* aBaseURI, PRBool aAppend,
    1:                                           PRBool aSkinOnly)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: #endif // MOZ_XUL
    1: 
    1: nsresult
    1: nsChromeRegistry::ProcessManifest(nsILocalFile* aManifest, PRBool aSkinOnly)
    1: {
    1:   nsresult rv;
    1: 
    1:   PRFileDesc* fd;
    1:   rv = aManifest->OpenNSPRFileDesc(PR_RDONLY, 0, &fd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt32 n, size;
    1:   char *buf;
    1: 
    1:   size = PR_Available(fd);
    1:   if (size == -1) {
    1:     rv = NS_ERROR_UNEXPECTED;
    1:     goto mend;
    1:   }
    1: 
    1:   buf = (char *) malloc(size + 1);
    1:   if (!buf) {
    1:     rv = NS_ERROR_OUT_OF_MEMORY;
    1:     goto mend;
    1:   }
    1: 
    1:   n = PR_Read(fd, buf, size);
    1:   if (n > 0) {
    1:     buf[size] = '\0';
    1:     rv = ProcessManifestBuffer(buf, size, aManifest, aSkinOnly);
    1:   }
    1:   free(buf);
    1: 
    1: mend:
    1:   PR_Close(fd);
    1:   return rv;
    1: }
    1: 
    1: static const char kWhitespace[] = "\t ";
    1: static const char kNewlines[]   = "\r\n";
    1: 
    1: /**
    1:  * Check for a modifier flag of the following forms:
    1:  *   "flag"   (same as "true")
    1:  *   "flag=yes|true|1"
    1:  *   "flag="no|false|0"
    1:  * @param aFlag The flag to compare.
    1:  * @param aData The tokenized data to check; this is lowercased
    1:  *              before being passed in.
    1:  * @param aResult If the flag is found, the value is assigned here.
    1:  * @return Whether the flag was handled.
    1:  */
    1: static PRBool
    1: CheckFlag(const nsSubstring& aFlag, const nsSubstring& aData, PRBool& aResult)
    1: {
    1:   if (!StringBeginsWith(aData, aFlag))
    1:     return PR_FALSE;
    1: 
    1:   if (aFlag.Length() == aData.Length()) {
    1:     // the data is simply "flag", which is the same as "flag=yes"
    1:     aResult = PR_TRUE;
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (aData.CharAt(aFlag.Length()) != '=') {
    1:     // the data is "flag2=", which is not anything we care about
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   if (aData.Length() == aFlag.Length() + 1) {
    1:     aResult = PR_FALSE;
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   switch (aData.CharAt(aFlag.Length() + 1)) {
    1:   case '1':
    1:   case 't': //true
    1:   case 'y': //yes
    1:     aResult = PR_TRUE;
    1:     return PR_TRUE;
    1: 
    1:   case '0':
    1:   case 'f': //false
    1:   case 'n': //no
    1:     aResult = PR_FALSE;
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: enum TriState {
    1:   eUnspecified,
    1:   eBad,
    1:   eOK
    1: };
    1: 
    1: /**
    1:  * Check for a modifier flag of the following form:
    1:  *   "flag=string"
 7899:  *   "flag!=string"
    1:  * @param aFlag The flag to compare.
    1:  * @param aData The tokenized data to check; this is lowercased
    1:  *              before being passed in.
    1:  * @param aValue The value that is expected.
    1:  * @param aResult If this is "ok" when passed in, this is left alone.
    1:  *                Otherwise if the flag is found it is set to eBad or eOK.
    1:  * @return Whether the flag was handled.
    1:  */
    1: static PRBool
    1: CheckStringFlag(const nsSubstring& aFlag, const nsSubstring& aData,
    1:                 const nsSubstring& aValue, TriState& aResult)
    1: {
    1:   if (aData.Length() < aFlag.Length() + 1)
    1:     return PR_FALSE;
    1: 
    1:   if (!StringBeginsWith(aData, aFlag))
    1:     return PR_FALSE;
    1: 
 7899:   PRBool comparison = PR_TRUE;
 7899:   if (aData[aFlag.Length()] != '=') {
 7899:     if (aData[aFlag.Length()] == '!' &&
 7899:         aData.Length() >= aFlag.Length() + 2 &&
 7899:         aData[aFlag.Length() + 1] == '=')
 7899:       comparison = PR_FALSE;
 7899:     else
    1:       return PR_FALSE;
 7899:   }
    1: 
    1:   if (aResult != eOK) {
 7899:     nsDependentSubstring testdata = Substring(aData, aFlag.Length() + (comparison ? 1 : 2));
    1:     if (testdata.Equals(aValue))
 7899:       aResult = comparison ? eOK : eBad;
    1:     else
 7899:       aResult = comparison ? eBad : eOK;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: /**
    1:  * Check for a modifier flag of the following form:
    1:  *   "flag=version"
    1:  *   "flag<=version"
    1:  *   "flag<version"
    1:  *   "flag>=version"
    1:  *   "flag>version"
    1:  * @param aFlag The flag to compare.
    1:  * @param aData The tokenized data to check; this is lowercased
    1:  *              before being passed in.
 7902:  * @param aValue The value that is expected. If this is empty then no
 7902:  *               comparison will match.
    1:  * @param aChecker the version checker to use. If null, aResult will always
    1:  *                 be eBad.
    1:  * @param aResult If this is eOK when passed in, this is left alone.
    1:  *                Otherwise if the flag is found it is set to eBad or eOK.
    1:  * @return Whether the flag was handled.
    1:  */
    1: 
    1: #define COMPARE_EQ    1 << 0
    1: #define COMPARE_LT    1 << 1
    1: #define COMPARE_GT    1 << 2
    1: 
    1: static PRBool
    1: CheckVersionFlag(const nsSubstring& aFlag, const nsSubstring& aData,
    1:                  const nsSubstring& aValue, nsIVersionComparator* aChecker,
    1:                  TriState& aResult)
    1: {
 1595:   if (aData.Length() < aFlag.Length() + 2)
    1:     return PR_FALSE;
    1: 
    1:   if (!StringBeginsWith(aData, aFlag))
    1:     return PR_FALSE;
    1: 
 7902:   if (aValue.Length() == 0) {
 7902:     if (aResult != eOK)
 7902:       aResult = eBad;
 7902:     return PR_TRUE;
 7902:   }
 7902: 
    1:   PRUint32 comparison;
    1:   nsAutoString testdata;
    1: 
    1:   switch (aData[aFlag.Length()]) {
    1:   case '=':
    1:     comparison = COMPARE_EQ;
    1:     testdata = Substring(aData, aFlag.Length() + 1);
    1:     break;
    1: 
    1:   case '<':
    1:     if (aData[aFlag.Length() + 1] == '=') {
    1:       comparison = COMPARE_EQ | COMPARE_LT;
    1:       testdata = Substring(aData, aFlag.Length() + 2);
    1:     }
    1:     else {
    1:       comparison = COMPARE_LT;
    1:       testdata = Substring(aData, aFlag.Length() + 1);
    1:     }
    1:     break;
    1: 
    1:   case '>':
    1:     if (aData[aFlag.Length() + 1] == '=') {
    1:       comparison = COMPARE_EQ | COMPARE_GT;
    1:       testdata = Substring(aData, aFlag.Length() + 2);
    1:     }
    1:     else {
    1:       comparison = COMPARE_GT;
    1:       testdata = Substring(aData, aFlag.Length() + 1);
    1:     }
    1:     break;
    1: 
    1:   default:
    1:     return PR_FALSE;
    1:   }
    1: 
 1595:   if (testdata.Length() == 0)
 1595:     return PR_FALSE;
 1595: 
    1:   if (aResult != eOK) {
    1:     if (!aChecker) {
    1:       aResult = eBad;
    1:     }
    1:     else {
    1:       PRInt32 c;
    1:       nsresult rv = aChecker->Compare(NS_ConvertUTF16toUTF8(aValue),
    1:                                       NS_ConvertUTF16toUTF8(testdata), &c);
    1:       if (NS_FAILED(rv)) {
    1:         aResult = eBad;
    1:       }
    1:       else {
    1:         if ((c == 0 && comparison & COMPARE_EQ) ||
    1:             (c < 0 && comparison & COMPARE_LT) ||
    1:             (c > 0 && comparison & COMPARE_GT))
    1:           aResult = eOK;
    1:         else
    1:           aResult = eBad;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: static void
    1: EnsureLowerCase(char *aBuf)
    1: {
    1:   for (; *aBuf; ++aBuf) {
    1:     char ch = *aBuf;
    1:     if (ch >= 'A' && ch <= 'Z')
    1:       *aBuf = ch + 'a' - 'A';
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsChromeRegistry::ProcessManifestBuffer(char *buf, PRInt32 length,
    1:                                         nsILocalFile* aManifest,
    1:                                         PRBool aSkinOnly)
    1: {
    1:   nsresult rv;
    1: 
    1:   NS_NAMED_LITERAL_STRING(kPlatform, "platform");
    1:   NS_NAMED_LITERAL_STRING(kXPCNativeWrappers, "xpcnativewrappers");
    1:   NS_NAMED_LITERAL_STRING(kApplication, "application");
    1:   NS_NAMED_LITERAL_STRING(kAppVersion, "appversion");
 7902:   NS_NAMED_LITERAL_STRING(kOs, "os");
 7902:   NS_NAMED_LITERAL_STRING(kOsVersion, "osversion");
    1: 
    1:   nsCOMPtr<nsIIOService> io (do_GetIOService());
    1:   if (!io) return NS_ERROR_FAILURE;
    1: 
 9606:   nsCOMPtr<nsIProtocolHandler> ph;
 9606:   rv = io->GetProtocolHandler("resource", getter_AddRefs(ph));
 9606:   NS_ENSURE_SUCCESS(rv, rv);
 9606:   
 9606:   nsCOMPtr<nsIResProtocolHandler> rph (do_QueryInterface(ph));
 9606:   if (!rph) return NS_ERROR_FAILURE;
 9606: 
    1:   nsCOMPtr<nsIURI> manifestURI;
    1:   rv = io->NewFileURI(aManifest, getter_AddRefs(manifestURI));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIXPConnect> xpc (do_GetService("@mozilla.org/js/xpc/XPConnect;1"));
    1:   nsCOMPtr<nsIVersionComparator> vc (do_GetService("@mozilla.org/xpcom/version-comparator;1"));
    1: 
    1:   nsAutoString appID;
    1:   nsAutoString appVersion;
 7902:   nsAutoString osTarget;
    1:   nsCOMPtr<nsIXULAppInfo> xapp (do_GetService(XULAPPINFO_SERVICE_CONTRACTID));
    1:   if (xapp) {
    1:     nsCAutoString s;
    1:     rv = xapp->GetID(s);
    1:     if (NS_SUCCEEDED(rv))
    1:       CopyUTF8toUTF16(s, appID);
    1: 
    1:     rv = xapp->GetVersion(s);
    1:     if (NS_SUCCEEDED(rv))
    1:       CopyUTF8toUTF16(s, appVersion);
 7902:     
 7902:     nsCOMPtr<nsIXULRuntime> xruntime (do_QueryInterface(xapp));
 7902:     if (xruntime) {
 7902:       rv = xruntime->GetOS(s);
 7902:       if (NS_SUCCEEDED(rv)) {
 7902:         CopyUTF8toUTF16(s, osTarget);
 7902:         ToLowerCase(osTarget);
    1:       }
 7902:     }
 7902:   }
 7902:   
 7902:   nsAutoString osVersion;
 7902: #if defined(XP_WIN)
 7902:   OSVERSIONINFO info = { sizeof(OSVERSIONINFO) };
 7902:   if (GetVersionEx(&info)) {
 7902:     nsTextFormatter::ssprintf(osVersion, NS_LITERAL_STRING("%ld.%ld").get(),
 7902:                                          info.dwMajorVersion,
 7902:                                          info.dwMinorVersion);
 7902:   }
 7902: #elif defined(XP_MACOSX)
 7902:   long majorVersion, minorVersion;
 7902:   if ((Gestalt(gestaltSystemVersionMajor, &majorVersion) == noErr) &&
 7902:       (Gestalt(gestaltSystemVersionMinor, &minorVersion) == noErr)) {
 7902:     nsTextFormatter::ssprintf(osVersion, NS_LITERAL_STRING("%ld.%ld").get(),
 7902:                                          majorVersion,
 7902:                                          minorVersion);
 7902:   }
 8425: #elif defined(MOZ_WIDGET_GTK2)
 8425:   nsTextFormatter::ssprintf(osVersion, NS_LITERAL_STRING("%ld.%ld").get(),
 8425:                                        gtk_major_version,
 8425:                                        gtk_minor_version);
 7902: #endif
    1: 
    1:   char *token;
    1:   char *newline = buf;
    1:   PRUint32 line = 0;
    1: 
    1:   // outer loop tokenizes by newline
    1:   while (nsnull != (token = nsCRT::strtok(newline, kNewlines, &newline))) {
    1:     ++line;
    1: 
    1:     if (*token == '#') // ignore lines that begin with # as comments
    1:       continue;
    1: 
    1:     char *whitespace = token;
    1:     token = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:     if (!token) continue;
    1: 
    1:     if (!strcmp(token, "content")) {
    1:       if (aSkinOnly) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Ignoring content registration in skin-only manifest.");
    1:         continue;
    1:       }
    1:       char *package = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       char *uri     = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       if (!package || !uri) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Malformed content registration.");
    1:         continue;
    1:       }
    1: 
    1:       EnsureLowerCase(package);
    1: 
    1:       // NOTE: We check for platform and xpcnativewrappers modifiers on
    1:       // content packages, but they are *applied* to content|skin|locale.
    1: 
    1:       PRBool platform = PR_FALSE;
    1:       PRBool xpcNativeWrappers = PR_TRUE;
    1:       TriState stAppVersion = eUnspecified;
    1:       TriState stApp = eUnspecified;
 7902:       TriState stOsVersion = eUnspecified;
 7902:       TriState stOs = eUnspecified;
    1: 
    1:       PRBool badFlag = PR_FALSE;
    1: 
    1:       while (nsnull != (token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
    1:              !badFlag) {
    1:         NS_ConvertASCIItoUTF16 wtoken(token);
    1:         ToLowerCase(wtoken);
    1: 
    1:         if (CheckFlag(kPlatform, wtoken, platform) ||
    1:             CheckFlag(kXPCNativeWrappers, wtoken, xpcNativeWrappers) ||
    1:             CheckStringFlag(kApplication, wtoken, appID, stApp) ||
 7902:             CheckStringFlag(kOs, wtoken, osTarget, stOs) ||
 7902:             CheckVersionFlag(kOsVersion, wtoken, osVersion, vc, stOsVersion) ||
    1:             CheckVersionFlag(kAppVersion, wtoken, appVersion, vc, stAppVersion))
    1:           continue;
    1: 
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Unrecognized chrome registration modifier '%s'.",
    1:                               token);
    1:         badFlag = PR_TRUE;
    1:       }
    1: 
 7902:       if (badFlag || stApp == eBad || stAppVersion == eBad || 
 7902:           stOs == eBad || stOsVersion == eBad)
    1:         continue;
    1: 
    1:       nsCOMPtr<nsIURI> resolved;
    1:       rv = io->NewURI(nsDependentCString(uri), nsnull, manifestURI,
    1:                       getter_AddRefs(resolved));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1: 
    1:       PackageEntry* entry =
 3233:         static_cast<PackageEntry*>(PL_DHashTableOperate(&mPackagesHash,
    1:                                                             & (const nsACString&) nsDependentCString(package),
    1:                                                             PL_DHASH_ADD));
    1:       if (!entry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       entry->baseURI = resolved;
    1: 
    1:       if (platform)
    1:         entry->flags |= PackageEntry::PLATFORM_PACKAGE;
 9531:       if (xpcNativeWrappers)
    1:         entry->flags |= PackageEntry::XPCNATIVEWRAPPERS;
    1:       if (xpc) {
    1:         nsCAutoString urlp("chrome://");
    1:         urlp.Append(package);
    1:         urlp.Append('/');
    1: 
 9531:         rv = xpc->FlagSystemFilenamePrefix(urlp.get(), xpcNativeWrappers);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1:     }
    1:     else if (!strcmp(token, "locale")) {
    1:       if (aSkinOnly) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Ignoring locale registration in skin-only manifest.");
    1:         continue;
    1:       }
    1:       char *package  = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       char *provider = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       char *uri      = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       if (!package || !provider || !uri) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Malformed locale registration.");
    1:         continue;
    1:       }
    1: 
    1:       EnsureLowerCase(package);
    1: 
    1:       TriState stAppVersion = eUnspecified;
    1:       TriState stApp = eUnspecified;
 7902:       TriState stOs = eUnspecified;
 7902:       TriState stOsVersion = eUnspecified;
    1: 
    1:       PRBool badFlag = PR_FALSE;
    1: 
    1:       while (nsnull != (token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
    1:              !badFlag) {
    1:         NS_ConvertASCIItoUTF16 wtoken(token);
    1:         ToLowerCase(wtoken);
    1: 
    1:         if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
 7902:             CheckStringFlag(kOs, wtoken, osTarget, stOs) ||
 7902:             CheckVersionFlag(kOsVersion, wtoken, osVersion, vc, stOsVersion) ||
    1:             CheckVersionFlag(kAppVersion, wtoken, appVersion, vc, stAppVersion))
    1:           continue;
    1: 
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Unrecognized chrome registration modifier '%s'.",
    1:                               token);
    1:         badFlag = PR_TRUE;
    1:       }
    1: 
 7902:       if (badFlag || stApp == eBad || stAppVersion == eBad ||
 7902:           stOs == eBad || stOsVersion == eBad)
    1:         continue;
    1: 
    1:       nsCOMPtr<nsIURI> resolved;
    1:       rv = io->NewURI(nsDependentCString(uri), nsnull, manifestURI,
    1:                       getter_AddRefs(resolved));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1: 
    1:       PackageEntry* entry =
 3233:         static_cast<PackageEntry*>(PL_DHashTableOperate(&mPackagesHash,
    1:                                                             & (const nsACString&) nsDependentCString(package),
    1:                                                             PL_DHASH_ADD));
    1:       if (!entry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       entry->locales.SetBase(nsDependentCString(provider), resolved);
    1:     }
    1:     else if (!strcmp(token, "skin")) {
    1:       char *package  = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       char *provider = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       char *uri      = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       if (!package || !provider || !uri) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Malformed skin registration.");
    1:         continue;
    1:       }
    1: 
    1:       EnsureLowerCase(package);
    1: 
    1:       TriState stAppVersion = eUnspecified;
    1:       TriState stApp = eUnspecified;
 7902:       TriState stOs = eUnspecified;
 7902:       TriState stOsVersion = eUnspecified;
    1: 
    1:       PRBool badFlag = PR_FALSE;
    1: 
    1:       while (nsnull != (token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
    1:              !badFlag) {
    1:         NS_ConvertASCIItoUTF16 wtoken(token);
    1:         ToLowerCase(wtoken);
    1: 
    1:         if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
 7902:             CheckStringFlag(kOs, wtoken, osTarget, stOs) ||
 7902:             CheckVersionFlag(kOsVersion, wtoken, osVersion, vc, stOsVersion) ||
    1:             CheckVersionFlag(kAppVersion, wtoken, appVersion, vc, stAppVersion))
    1:           continue;
    1: 
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Unrecognized chrome registration modifier '%s'.",
    1:                               token);
    1:         badFlag = PR_TRUE;
    1:       }
    1: 
 7902:       if (badFlag || stApp == eBad || stAppVersion == eBad ||
 7902:           stOs == eBad || stOsVersion == eBad)
    1:         continue;
    1: 
    1:       nsCOMPtr<nsIURI> resolved;
    1:       rv = io->NewURI(nsDependentCString(uri), nsnull, manifestURI,
    1:                       getter_AddRefs(resolved));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1: 
    1:       PackageEntry* entry =
 3233:         static_cast<PackageEntry*>(PL_DHashTableOperate(&mPackagesHash,
    1:                                                             & (const nsACString&) nsDependentCString(package),
    1:                                                             PL_DHASH_ADD));
    1:       if (!entry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       entry->skins.SetBase(nsDependentCString(provider), resolved);
    1:     }
    1:     else if (!strcmp(token, "overlay")) {
    1:       if (aSkinOnly) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Ignoring overlay registration in skin-only manifest.");
    1:         continue;
    1:       }
    1:       char *base    = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       char *overlay = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       if (!base || !overlay) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: malformed chrome overlay instruction.");
    1:         continue;
    1:       }
    1: 
    1:       TriState stAppVersion = eUnspecified;
    1:       TriState stApp = eUnspecified;
 7902:       TriState stOs = eUnspecified;
 7902:       TriState stOsVersion = eUnspecified;
    1: 
    1:       PRBool badFlag = PR_FALSE;
    1: 
    1:       while (nsnull != (token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
    1:              !badFlag) {
    1:         NS_ConvertASCIItoUTF16 wtoken(token);
    1:         ToLowerCase(wtoken);
    1: 
    1:         if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
 7902:             CheckStringFlag(kOs, wtoken, osTarget, stOs) ||
 7902:             CheckVersionFlag(kOsVersion, wtoken, osVersion, vc, stOsVersion) ||
    1:             CheckVersionFlag(kAppVersion, wtoken, appVersion, vc, stAppVersion))
    1:           continue;
    1: 
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Unrecognized chrome registration modifier '%s'.",
    1:                               token);
    1:         badFlag = PR_TRUE;
    1:       }
    1: 
 7902:       if (badFlag || stApp == eBad || stAppVersion == eBad ||
 7902:           stOs == eBad || stOsVersion == eBad)
    1:         continue;
    1: 
    1:       nsCOMPtr<nsIURI> baseuri, overlayuri;
    1:       rv  = io->NewURI(nsDependentCString(base), nsnull, nsnull,
    1:                        getter_AddRefs(baseuri));
    1:       rv |= io->NewURI(nsDependentCString(overlay), nsnull, nsnull,
    1:                        getter_AddRefs(overlayuri));
    1:       if (NS_FAILED(rv)) {
    1:         NS_WARNING("Could not make URIs for overlay directive. Ignoring.");
    1:         continue;
    1:       }
    1: 
    1:       mOverlayHash.Add(baseuri, overlayuri);
    1:     }
    1:     else if (!strcmp(token, "style")) {
    1:       char *base    = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       char *overlay = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       if (!base || !overlay) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: malformed chrome style instruction.");
    1:         continue;
    1:       }
    1: 
    1:       TriState stAppVersion = eUnspecified;
    1:       TriState stApp = eUnspecified;
 7902:       TriState stOs = eUnspecified;
 7902:       TriState stOsVersion = eUnspecified;
    1: 
    1:       PRBool badFlag = PR_FALSE;
    1: 
    1:       while (nsnull != (token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
    1:              !badFlag) {
    1:         NS_ConvertASCIItoUTF16 wtoken(token);
    1:         ToLowerCase(wtoken);
    1: 
    1:         if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
 7902:             CheckStringFlag(kOs, wtoken, osTarget, stOs) ||
 7902:             CheckVersionFlag(kOsVersion, wtoken, osVersion, vc, stOsVersion) ||
    1:             CheckVersionFlag(kAppVersion, wtoken, appVersion, vc, stAppVersion))
    1:           continue;
    1: 
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Unrecognized chrome registration modifier '%s'.",
    1:                               token);
    1:         badFlag = PR_TRUE;
    1:       }
    1: 
 7902:       if (badFlag || stApp == eBad || stAppVersion == eBad ||
 7902:           stOs == eBad || stOsVersion == eBad)
    1:         continue;
    1: 
    1:       nsCOMPtr<nsIURI> baseuri, overlayuri;
    1:       rv  = io->NewURI(nsDependentCString(base), nsnull, nsnull,
    1:                       getter_AddRefs(baseuri));
    1:       rv |= io->NewURI(nsDependentCString(overlay), nsnull, nsnull,
    1:                        getter_AddRefs(overlayuri));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1: 
    1:       mStyleHash.Add(baseuri, overlayuri);
    1:     }
    1:     else if (!strcmp(token, "override")) {
    1:       if (aSkinOnly) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Ignoring override registration in skin-only manifest.");
    1:         continue;
    1:       }
    1: 
    1:       char *chrome    = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       char *resolved  = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
    1:       if (!chrome || !resolved) {
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: malformed chrome override instruction.");
    1:         continue;
    1:       }
    1: 
    1:       TriState stAppVersion = eUnspecified;
    1:       TriState stApp = eUnspecified;
 7902:       TriState stOs = eUnspecified;
 7902:       TriState stOsVersion = eUnspecified;
    1: 
    1:       PRBool badFlag = PR_FALSE;
    1: 
    1:       while (nsnull != (token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
    1:              !badFlag) {
    1:         NS_ConvertASCIItoUTF16 wtoken(token);
    1:         ToLowerCase(wtoken);
    1: 
    1:         if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
 7902:             CheckStringFlag(kOs, wtoken, osTarget, stOs) ||
 7902:             CheckVersionFlag(kOsVersion, wtoken, osVersion, vc, stOsVersion) ||
    1:             CheckVersionFlag(kAppVersion, wtoken, appVersion, vc, stAppVersion))
    1:           continue;
    1: 
    1:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                               "Warning: Unrecognized chrome registration modifier '%s'.",
    1:                               token);
    1:         badFlag = PR_TRUE;
    1:       }
    1: 
 7902:       if (badFlag || stApp == eBad || stAppVersion == eBad ||
 7902:           stOs == eBad || stOsVersion == eBad)
    1:         continue;
    1: 
    1:       nsCOMPtr<nsIURI> chromeuri, resolveduri;
    1:       rv  = io->NewURI(nsDependentCString(chrome), nsnull, nsnull,
    1:                       getter_AddRefs(chromeuri));
    1:       rv |= io->NewURI(nsDependentCString(resolved), nsnull, manifestURI,
    1:                        getter_AddRefs(resolveduri));
    1:       if (NS_FAILED(rv))
    1:         continue;
    1: 
    1:       mOverrideTable.Put(chromeuri, resolveduri);
    1:     }
 9606:     else if (!strcmp(token, "resource")) {
 9606:       if (aSkinOnly) {
 9606:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
 9606:                               "Warning: Ignoring resource registration in skin-only manifest.");
 9606:         continue;
 9606:       }
 9606: 
 9606:       char *package = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
 9606:       char *uri     = nsCRT::strtok(whitespace, kWhitespace, &whitespace);
 9606:       if (!package || !uri) {
 9606:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
 9606:                               "Warning: Malformed resource registration.");
 9606:         continue;
 9606:       }
 9606: 
 9606:       EnsureLowerCase(package);
 9606: 
 9606:       TriState stAppVersion = eUnspecified;
 9606:       TriState stApp = eUnspecified;
 9606:       TriState stOsVersion = eUnspecified;
 9606:       TriState stOs = eUnspecified;
 9606: 
 9606:       PRBool badFlag = PR_FALSE;
 9606: 
 9606:       while (nsnull != (token = nsCRT::strtok(whitespace, kWhitespace, &whitespace)) &&
 9606:              !badFlag) {
 9606:         NS_ConvertASCIItoUTF16 wtoken(token);
 9606:         ToLowerCase(wtoken);
 9606: 
 9606:         if (CheckStringFlag(kApplication, wtoken, appID, stApp) ||
 9606:             CheckStringFlag(kOs, wtoken, osTarget, stOs) ||
 9606:             CheckVersionFlag(kOsVersion, wtoken, osVersion, vc, stOsVersion) ||
 9606:             CheckVersionFlag(kAppVersion, wtoken, appVersion, vc, stAppVersion))
 9606:           continue;
 9606: 
 9606:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
 9606:                               "Warning: Unrecognized chrome registration modifier '%s'.",
 9606:                               token);
 9606:         badFlag = PR_TRUE;
 9606:       }
 9606: 
 9606:       if (badFlag || stApp == eBad || stAppVersion == eBad || 
 9606:           stOs == eBad || stOsVersion == eBad)
 9606:         continue;
 9606:       
 9606:       nsDependentCString host(package);
 9606: 
 9606:       PRBool exists;
 9606:       rv = rph->HasSubstitution(host, &exists);
 9606:       NS_ENSURE_SUCCESS(rv, rv);
 9606:       if (exists) {
 9606:         LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
 9606:                               "Warning: Duplicate resource declaration for '%s' ignored.",
 9606:                               package);
 9606:         continue;
 9606:       }
 9606: 
 9606:       nsCOMPtr<nsIURI> resolved;
 9606:       rv = io->NewURI(nsDependentCString(uri), nsnull, manifestURI,
 9606:                       getter_AddRefs(resolved));
 9606:       if (NS_FAILED(rv))
 9606:         continue;
 9606: 
 9606:       rv = rph->SetSubstitution(host, resolved);
 9606:       NS_ENSURE_SUCCESS(rv, rv);
 9606:     }
    1:     else {
    1:       LogMessageWithContext(manifestURI, line, nsIScriptError::warningFlag,
    1:                             "Warning: Ignoring unrecognized chrome manifest instruction.");
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
