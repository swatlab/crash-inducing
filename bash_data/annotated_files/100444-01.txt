     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 80467: 
 80467: #include "mozilla/Util.h"
 80467: 
 41899: #include "xpcprivate.h"
 98833: #include "XPCWrapper.h"
     1: #include "nsScriptSecurityManager.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIScriptObjectPrincipal.h"
     1: #include "nsIScriptContext.h"
     1: #include "nsIURL.h"
     1: #include "nsINestedURI.h"
     1: #include "nspr.h"
     1: #include "nsJSPrincipals.h"
     1: #include "nsSystemPrincipal.h"
     1: #include "nsPrincipal.h"
     1: #include "nsNullPrincipal.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsCRT.h"
     1: #include "nsCRTGlue.h"
     1: #include "nsIJSContextStack.h"
     1: #include "nsDOMError.h"
     1: #include "nsDOMCID.h"
     1: #include "jsdbgapi.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsIXPCSecurityManager.h"
     1: #include "nsTextFormatter.h"
     1: #include "nsIStringBundle.h"
     1: #include "nsNetUtil.h"
     1: #include "nsIProperties.h"
     1: #include "nsDirectoryServiceDefs.h"
     1: #include "nsIFile.h"
  5766: #include "nsIFileURL.h"
     1: #include "nsIZipReader.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIPrompt.h"
     1: #include "nsIWindowWatcher.h"
     1: #include "nsIConsoleService.h"
     1: #include "nsISecurityCheckedComponent.h"
     1: #include "nsIJSRuntimeService.h"
     1: #include "nsIObserverService.h"
     1: #include "nsIContent.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsDOMJSUtils.h"
     1: #include "nsAboutProtocolUtils.h"
     1: #include "nsIClassInfo.h"
     1: #include "nsIURIFixup.h"
     1: #include "nsCDefaultURIFixup.h"
 14262: #include "nsIChromeRegistry.h"
 39061: #include "nsIContentSecurityPolicy.h"
 48889: #include "nsIAsyncVerifyRedirectCallback.h"
 72017: #include "mozilla/Preferences.h"
 97422: #include "mozilla/dom/BindingUtils.h"
 95340: #include "mozilla/StandardInteger.h"
100444: #include "mozilla/ClearOnShutdown.h"
 72017: 
 72017: using namespace mozilla;
 94512: using namespace mozilla::dom;
     1: 
     1: static NS_DEFINE_CID(kZipReaderCID, NS_ZIPREADER_CID);
     1: 
     1: nsIIOService    *nsScriptSecurityManager::sIOService = nsnull;
     1: nsIXPConnect    *nsScriptSecurityManager::sXPConnect = nsnull;
 20462: nsIThreadJSContextStack *nsScriptSecurityManager::sJSContextStack = nsnull;
     1: nsIStringBundle *nsScriptSecurityManager::sStrBundle = nsnull;
     1: JSRuntime       *nsScriptSecurityManager::sRuntime   = 0;
 79445: bool nsScriptSecurityManager::sStrictFileOriginPolicy = true;
     1: 
     1: ///////////////////////////
     1: // Convenience Functions //
     1: ///////////////////////////
     1: // Result of this function should not be freed.
     1: static inline const PRUnichar *
 48470: IDToString(JSContext *cx, jsid id)
     1: {
 48470:     if (JSID_IS_STRING(id))
 59889:         return JS_GetInternedStringChars(JSID_TO_STRING(id));
 48470: 
     1:     JSAutoRequest ar(cx);
 48470:     jsval idval;
 48470:     if (!JS_IdToValue(cx, id, &idval))
 48470:         return nsnull;
     1:     JSString *str = JS_ValueToString(cx, idval);
     1:     if(!str)
     1:         return nsnull;
 59889:     return JS_GetStringCharsZ(cx, str);
     1: }
     1: 
 28684: class nsAutoInPrincipalDomainOriginSetter {
 28684: public:
 28684:     nsAutoInPrincipalDomainOriginSetter() {
 28684:         ++sInPrincipalDomainOrigin;
 28684:     }
 28684:     ~nsAutoInPrincipalDomainOriginSetter() {
 28684:         --sInPrincipalDomainOrigin;
 28684:     }
 28684:     static PRUint32 sInPrincipalDomainOrigin;
 28684: };
 28684: PRUint32 nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin;
 28684: 
 16273: static
 16273: nsresult
 30838: GetOriginFromURI(nsIURI* aURI, nsACString& aOrigin)
 16273: {
 28713:   if (nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin > 1) {
 28713:       // Allow a single recursive call to GetPrincipalDomainOrigin, since that
 28713:       // might be happening on a different principal from the first call.  But
 28713:       // after that, cut off the recursion; it just indicates that something
 28713:       // we're doing in this method causes us to reenter a security check here.
 28713:       return NS_ERROR_NOT_AVAILABLE;
 28713:   }
 28713: 
 28684:   nsAutoInPrincipalDomainOriginSetter autoSetter;
 30838: 
 30838:   nsCOMPtr<nsIURI> uri = NS_GetInnermostURI(aURI);
 16273:   NS_ENSURE_TRUE(uri, NS_ERROR_UNEXPECTED);
 16273: 
 16273:   nsCAutoString hostPort;
 16273: 
 16273:   nsresult rv = uri->GetHostPort(hostPort);
 16273:   if (NS_SUCCEEDED(rv)) {
 16273:     nsCAutoString scheme;
 16273:     rv = uri->GetScheme(scheme);
 16273:     NS_ENSURE_SUCCESS(rv, rv);
 16273:     aOrigin = scheme + NS_LITERAL_CSTRING("://") + hostPort;
 16273:   }
 16273:   else {
 16273:     // Some URIs (e.g., nsSimpleURI) don't support host. Just
 16273:     // get the full spec.
 16273:     rv = uri->GetSpec(aOrigin);
 16273:     NS_ENSURE_SUCCESS(rv, rv);
 16273:   }
 16273: 
 16273:   return NS_OK;
 16273: }
 16273: 
 30838: static
 30838: nsresult
 30838: GetPrincipalDomainOrigin(nsIPrincipal* aPrincipal,
 30838:                          nsACString& aOrigin)
 30838: {
 30838: 
 30838:   nsCOMPtr<nsIURI> uri;
 30838:   aPrincipal->GetDomain(getter_AddRefs(uri));
 30838:   if (!uri) {
 30838:     aPrincipal->GetURI(getter_AddRefs(uri));
 30838:   }
 30838:   NS_ENSURE_TRUE(uri, NS_ERROR_UNEXPECTED);
 30838: 
 30838:   return GetOriginFromURI(uri, aOrigin);
 30838: }
 30838: 
     1: static nsIScriptContext *
     1: GetScriptContext(JSContext *cx)
     1: {
     1:     return GetScriptContextFromJSContext(cx);
     1: }
     1: 
 94849: // Callbacks for the JS engine to use to push/pop context principals.
 94849: static JSBool
 94849: PushPrincipalCallback(JSContext *cx, JSPrincipals *principals)
 94849: {
 94849:     // We should already be in the compartment of the given principal.
 94849:     MOZ_ASSERT(principals ==
 94849:                JS_GetCompartmentPrincipals((js::GetContextCompartment(cx))));
 94849: 
 94849:     // Get the security manager.
 94849:     nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
 94849:     if (!ssm) {
 94849:         return true;
 94849:     }
 94849: 
 94849:     // Push the principal.
 94849:     JSStackFrame *fp = NULL;
 94849:     nsresult rv = ssm->PushContextPrincipal(cx, JS_FrameIterator(cx, &fp),
 94849:                                             nsJSPrincipals::get(principals));
 94849:     if (NS_FAILED(rv)) {
 94849:         JS_ReportOutOfMemory(cx);
 94849:         return false;
 94849:     }
 94849: 
 94849:     return true;
 94849: }
 94849: 
 94849: static JSBool
 94849: PopPrincipalCallback(JSContext *cx)
 94849: {
 94849:     nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
 94849:     if (ssm) {
 94849:         ssm->PopContextPrincipal(cx);
 94849:     }
 94849: 
 94849:     return true;
 94849: }
 94849: 
 94849: 
     1: inline void SetPendingException(JSContext *cx, const char *aMsg)
     1: {
     1:     JSAutoRequest ar(cx);
 13379:     JS_ReportError(cx, "%s", aMsg);
     1: }
     1: 
     1: inline void SetPendingException(JSContext *cx, const PRUnichar *aMsg)
     1: {
     1:     JSAutoRequest ar(cx);
 13379:     JS_ReportError(cx, "%hs", aMsg);
     1: }
     1: 
     1: // DomainPolicy members
     1: #ifdef DEBUG_CAPS_DomainPolicyLifeCycle
     1: PRUint32 DomainPolicy::sObjects=0;
     1: void DomainPolicy::_printPopulationInfo()
     1: {
     1:     printf("CAPS.DomainPolicy: Gen. %d, %d DomainPolicy objects.\n",
     1:         sGeneration, sObjects);
     1: }
     1: #endif
     1: PRUint32 DomainPolicy::sGeneration = 0;
     1: 
     1: // Helper class to get stuff from the ClassInfo and not waste extra time with
     1: // virtual method calls for things it has already gotten
     1: class ClassInfoData
     1: {
     1: public:
     1:     ClassInfoData(nsIClassInfo *aClassInfo, const char *aName)
     1:         : mClassInfo(aClassInfo),
  3233:           mName(const_cast<char *>(aName)),
 80486:           mDidGetFlags(false),
 80486:           mMustFreeName(false)
     1:     {
     1:     }
     1: 
     1:     ~ClassInfoData()
     1:     {
     1:         if (mMustFreeName)
     1:             nsMemory::Free(mName);
     1:     }
     1: 
     1:     PRUint32 GetFlags()
     1:     {
     1:         if (!mDidGetFlags) {
     1:             if (mClassInfo) {
     1:                 nsresult rv = mClassInfo->GetFlags(&mFlags);
     1:                 if (NS_FAILED(rv)) {
     1:                     mFlags = 0;
     1:                 }
     1:             } else {
     1:                 mFlags = 0;
     1:             }
     1: 
 80486:             mDidGetFlags = true;
     1:         }
     1: 
     1:         return mFlags;
     1:     }
     1: 
 79445:     bool IsDOMClass()
     1:     {
  7870:         return !!(GetFlags() & nsIClassInfo::DOM_OBJECT);
     1:     }
     1: 
     1:     const char* GetName()
     1:     {
     1:         if (!mName) {
     1:             if (mClassInfo) {
     1:                 mClassInfo->GetClassDescription(&mName);
     1:             }
     1: 
     1:             if (mName) {
 80486:                 mMustFreeName = true;
     1:             } else {
  3233:                 mName = const_cast<char *>("UnnamedClass");
     1:             }
     1:         }
     1: 
     1:         return mName;
     1:     }
     1: 
     1: private:
     1:     nsIClassInfo *mClassInfo; // WEAK
     1:     PRUint32 mFlags;
     1:     char *mName;
 79445:     bool mDidGetFlags;
 79445:     bool mMustFreeName;
     1: };
     1: 
 20175: class AutoCxPusher {
 20175: public:
 20175:     AutoCxPusher(nsIJSContextStack *aStack, JSContext *cx)
 20175:         : mStack(aStack), mContext(cx)
 20175:     {
 20175:         if (NS_FAILED(mStack->Push(mContext))) {
 20175:             mStack = nsnull;
 20175:         }
 20175:     }
 20175: 
 20175:     ~AutoCxPusher()
 20175:     {
 20175:         if (mStack) {
 20175:             mStack->Pop(nsnull);
 20175:         }
 20175:     }
 20175: 
 20175: private:
 20175:     nsCOMPtr<nsIJSContextStack> mStack;
 20175:     JSContext *mContext;
 20175: };
 20175: 
     1: JSContext *
     1: nsScriptSecurityManager::GetCurrentJSContext()
     1: {
     1:     // Get JSContext from stack.
     1:     JSContext *cx;
 20462:     if (NS_FAILED(sJSContextStack->Peek(&cx)))
     1:         return nsnull;
     1:     return cx;
     1: }
     1: 
     1: JSContext *
     1: nsScriptSecurityManager::GetSafeJSContext()
     1: {
     1:     // Get JSContext from stack.
 97744:     return sJSContextStack->GetSafeJSContext();
     1: }
     1: 
 12321: /* static */
 79445: bool
     1: nsScriptSecurityManager::SecurityCompareURIs(nsIURI* aSourceURI,
     1:                                              nsIURI* aTargetURI)
     1: {
 18488:     return NS_SecurityCompareURIs(aSourceURI, aTargetURI, sStrictFileOriginPolicy);
     1: }
     1: 
 20149: // SecurityHashURI is consistent with SecurityCompareURIs because NS_SecurityHashURI
 20149: // is consistent with NS_SecurityCompareURIs.  See nsNetUtil.h.
 20149: PRUint32
 20149: nsScriptSecurityManager::SecurityHashURI(nsIURI* aURI)
 20149: {
 20149:     return NS_SecurityHashURI(aURI);
 20149: }
 20149: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::GetChannelPrincipal(nsIChannel* aChannel,
     1:                                              nsIPrincipal** aPrincipal)
     1: {
     1:     NS_PRECONDITION(aChannel, "Must have channel!");
     1:     nsCOMPtr<nsISupports> owner;
     1:     aChannel->GetOwner(getter_AddRefs(owner));
     1:     if (owner) {
     1:         CallQueryInterface(owner, aPrincipal);
     1:         if (*aPrincipal) {
     1:             return NS_OK;
     1:         }
     1:     }
     1: 
     1:     // OK, get the principal from the URI.  Make sure this does the same thing
     1:     // as nsDocument::Reset and nsXULDocument::StartDocumentLoad.
     1:     nsCOMPtr<nsIURI> uri;
  7109:     nsresult rv = NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
  7109:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     return GetCodebasePrincipal(uri, aPrincipal);
     1: }
     1: 
  2524: NS_IMETHODIMP
  2524: nsScriptSecurityManager::IsSystemPrincipal(nsIPrincipal* aPrincipal,
 79445:                                            bool* aIsSystem)
  2524: {
  2524:     *aIsSystem = (aPrincipal == mSystemPrincipal);
  2524:     return NS_OK;
  2524: }
  2524: 
  9825: NS_IMETHODIMP_(nsIPrincipal *)
  9825: nsScriptSecurityManager::GetCxSubjectPrincipal(JSContext *cx)
  9825: {
  9825:     NS_ASSERTION(cx == GetCurrentJSContext(),
  9825:                  "Uh, cx is not the current JS context!");
  9825: 
  9825:     nsresult rv = NS_ERROR_FAILURE;
  9825:     nsIPrincipal *principal = GetSubjectPrincipal(cx, &rv);
  9825:     if (NS_FAILED(rv))
  9825:         return nsnull;
  9825: 
  9825:     return principal;
  9825: }
  9825: 
 20761: NS_IMETHODIMP_(nsIPrincipal *)
 20761: nsScriptSecurityManager::GetCxSubjectPrincipalAndFrame(JSContext *cx, JSStackFrame **fp)
 20761: {
 20761:     NS_ASSERTION(cx == GetCurrentJSContext(),
 20761:                  "Uh, cx is not the current JS context!");
 20761: 
 20761:     nsresult rv = NS_ERROR_FAILURE;
 20761:     nsIPrincipal *principal = GetPrincipalAndFrame(cx, fp, &rv);
 20761:     if (NS_FAILED(rv))
 20761:         return nsnull;
 20761: 
 20761:     return principal;
 20761: }
 20761: 
 33308: NS_IMETHODIMP
 33308: nsScriptSecurityManager::PushContextPrincipal(JSContext *cx,
 33308:                                               JSStackFrame *fp,
 33308:                                               nsIPrincipal *principal)
 33308: {
 60475:     NS_ASSERTION(principal, "Must pass a non-null principal");
 60475: 
 33308:     ContextPrincipal *cp = new ContextPrincipal(mContextPrincipals, cx, fp,
 33308:                                                 principal);
 33308:     if (!cp)
 33308:         return NS_ERROR_OUT_OF_MEMORY;
 33308: 
 33308:     mContextPrincipals = cp;
 33308:     return NS_OK;
 33308: }
 33308: 
 33308: NS_IMETHODIMP
 33308: nsScriptSecurityManager::PopContextPrincipal(JSContext *cx)
 33308: {
 33308:     NS_ASSERTION(mContextPrincipals->mCx == cx, "Mismatched push/pop");
 33308: 
 33308:     ContextPrincipal *next = mContextPrincipals->mNext;
 33308:     delete mContextPrincipals;
 33308:     mContextPrincipals = next;
 33308: 
 33308:     return NS_OK;
 33308: }
 33308: 
     1: ////////////////////
     1: // Policy Storage //
     1: ////////////////////
     1: 
     1: // Table of security levels
 79445: static bool
     1: DeleteCapability(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     NS_Free(aData);
 80486:     return true;
     1: }
     1: 
     1: //-- Per-Domain Policy - applies to one or more protocols or hosts
     1: struct DomainEntry
     1: {
     1:     DomainEntry(const char* aOrigin,
     1:                 DomainPolicy* aDomainPolicy) : mOrigin(aOrigin),
     1:                                                mDomainPolicy(aDomainPolicy),
     1:                                                mNext(nsnull)
     1:     {
     1:         mDomainPolicy->Hold();
     1:     }
     1: 
     1:     ~DomainEntry()
     1:     {
     1:         mDomainPolicy->Drop();
     1:     }
     1: 
 79445:     bool Matches(const char *anOrigin)
     1:     {
     1:         int len = strlen(anOrigin);
     1:         int thisLen = mOrigin.Length();
     1:         if (len < thisLen)
 80486:             return false;
     1:         if (mOrigin.RFindChar(':', thisLen-1, 1) != -1)
     1:         //-- Policy applies to all URLs of this scheme, compare scheme only
     1:             return mOrigin.EqualsIgnoreCase(anOrigin, thisLen);
     1: 
     1:         //-- Policy applies to a particular host; compare domains
     1:         if (!mOrigin.Equals(anOrigin + (len - thisLen)))
 80486:             return false;
     1:         if (len == thisLen)
 80486:             return true;
     1:         char charBefore = anOrigin[len-thisLen-1];
     1:         return (charBefore == '.' || charBefore == ':' || charBefore == '/');
     1:     }
     1: 
     1:     nsCString         mOrigin;
     1:     DomainPolicy*     mDomainPolicy;
     1:     DomainEntry*      mNext;
     1: #if defined(DEBUG) || defined(DEBUG_CAPS_HACKER)
     1:     nsCString         mPolicyName_DEBUG;
     1: #endif
     1: };
     1: 
 79445: static bool
     1: DeleteDomainEntry(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     DomainEntry *entry = (DomainEntry*) aData;
     1:     do
     1:     {
     1:         DomainEntry *next = entry->mNext;
     1:         delete entry;
     1:         entry = next;
     1:     } while (entry);
 80486:     return true;
     1: }
     1: 
     1: /////////////////////////////
     1: // nsScriptSecurityManager //
     1: /////////////////////////////
     1: 
     1: ////////////////////////////////////
     1: // Methods implementing ISupports //
     1: ////////////////////////////////////
 43345: NS_IMPL_ISUPPORTS4(nsScriptSecurityManager,
     1:                    nsIScriptSecurityManager,
     1:                    nsIXPCSecurityManager,
     1:                    nsIChannelEventSink,
     1:                    nsIObserver)
     1: 
     1: ///////////////////////////////////////////////////
     1: // Methods implementing nsIScriptSecurityManager //
     1: ///////////////////////////////////////////////////
     1: 
     1: ///////////////// Security Checks /////////////////
 91900: 
 91900: /* static */ JSPrincipals *
 91900: nsScriptSecurityManager::ObjectPrincipalFinder(JSObject *aObj)
 91900: {
 91900:     return nsJSPrincipals::get(doGetObjectPrincipal(aObj));
 91900: }
 91900: 
 18907: JSBool
 39061: nsScriptSecurityManager::ContentSecurityPolicyPermitsJSAction(JSContext *cx)
 39061: {
 39061:     // Get the security manager
 39061:     nsScriptSecurityManager *ssm =
 39061:         nsScriptSecurityManager::GetScriptSecurityManager();
 39061: 
 39061:     NS_ASSERTION(ssm, "Failed to get security manager service");
 39061:     if (!ssm)
 39061:         return JS_FALSE;
 39061: 
 39061:     nsresult rv;
 39061:     nsIPrincipal* subjectPrincipal = ssm->GetSubjectPrincipal(cx, &rv);
 39061: 
 39061:     NS_ASSERTION(NS_SUCCEEDED(rv), "CSP: Failed to get nsIPrincipal from js context");
 39061:     if (NS_FAILED(rv))
 39061:         return JS_FALSE; // Not just absence of principal, but failure.
 39061: 
 39649:     if (!subjectPrincipal) {
 39649:         // See bug 553448 for discussion of this case.
 91900:         NS_ASSERTION(!JS_GetSecurityCallbacks(js::GetRuntime(cx))->findObjectPrincipals,
 39649:                      "CSP: Should have been able to find subject principal. "
 39649:                      "Reluctantly granting access.");
 39649:         return JS_TRUE;
 39649:     }
 39061: 
 39061:     nsCOMPtr<nsIContentSecurityPolicy> csp;
 39061:     rv = subjectPrincipal->GetCsp(getter_AddRefs(csp));
 39061:     NS_ASSERTION(NS_SUCCEEDED(rv), "CSP: Failed to get CSP from principal.");
 39061: 
 39061:     // don't do anything unless there's a CSP
 39061:     if (!csp)
 39061:         return JS_TRUE;
 39061: 
 79445:     bool evalOK = true;
 39061:     rv = csp->GetAllowsEval(&evalOK);
 39061: 
 39061:     if (NS_FAILED(rv))
 39061:     {
 39061:         NS_WARNING("CSP: failed to get allowsEval");
 39061:         return JS_TRUE; // fail open to not break sites.
 39061:     }
 39061: 
 61654:     if (!evalOK) {
 61654:         // get the script filename, script sample, and line number
 61654:         // to log with the violation
 61654:         nsAutoString fileName;
 95518:         unsigned lineNum = 0;
 61654:         NS_NAMED_LITERAL_STRING(scriptSample, "call to eval() or related function blocked by CSP");
 61654: 
 95518:         JSScript *script;
 95518:         if (JS_DescribeScriptedCaller(cx, &script, &lineNum)) {
 95518:             if (const char *file = JS_GetScriptFilename(cx, script)) {
 61654:                 CopyUTF8toUTF16(nsDependentCString(file), fileName);
 61654:             }
 61654:         }
 61654: 
 61654:         csp->LogViolationDetails(nsIContentSecurityPolicy::VIOLATION_TYPE_EVAL,
 61654:                                  fileName,
 61654:                                  scriptSample,
 61654:                                  lineNum);
 61654:     }
 61654: 
 39061:     return evalOK;
 39061: }
 39061: 
 39061: 
 39061: JSBool
 98960: nsScriptSecurityManager::CheckObjectAccess(JSContext *cx, JSHandleObject obj,
 98960:                                            JSHandleId id, JSAccessMode mode,
     1:                                            jsval *vp)
     1: {
     1:     // Get the security manager
     1:     nsScriptSecurityManager *ssm =
     1:         nsScriptSecurityManager::GetScriptSecurityManager();
     1: 
     1:     NS_ASSERTION(ssm, "Failed to get security manager service");
     1:     if (!ssm)
     1:         return JS_FALSE;
     1: 
     1:     // Get the object being accessed.  We protect these cases:
     1:     // 1. The Function.prototype.caller property's value, which might lead
     1:     //    an attacker up a call-stack to a function or another object from
     1:     //    a different trust domain.
     1:     // 2. A user-defined getter or setter function accessible on another
     1:     //    trust domain's window or document object.
     1:     // *vp can be a primitive, in that case, we use obj as the target
     1:     // object.
     1:     JSObject* target = JSVAL_IS_PRIMITIVE(*vp) ? obj : JSVAL_TO_OBJECT(*vp);
     1: 
     1:     // Do the same-origin check -- this sets a JS exception if the check fails.
     1:     // Pass the parent object's class name, as we have no class-info for it.
  5491:     nsresult rv =
 79734:         ssm->CheckPropertyAccess(cx, target, js::GetObjectClass(obj)->name, id,
  5491:                                  (mode & JSACC_WRITE) ?
 20175:                                  (PRInt32)nsIXPCSecurityManager::ACCESS_SET_PROPERTY :
 20175:                                  (PRInt32)nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
     1: 
     1:     if (NS_FAILED(rv))
     1:         return JS_FALSE; // Security check failed (XXX was an error reported?)
     1: 
     1:     return JS_TRUE;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CheckPropertyAccess(JSContext* cx,
     1:                                              JSObject* aJSObject,
     1:                                              const char* aClassName,
 48470:                                              jsid aProperty,
     1:                                              PRUint32 aAction)
     1: {
     1:     return CheckPropertyAccessImpl(aAction, nsnull, cx, aJSObject,
 14480:                                    nsnull, nsnull, nsnull,
     1:                                    aClassName, aProperty, nsnull);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CheckSameOrigin(JSContext* cx,
     1:                                          nsIURI* aTargetURI)
     1: {
     1:     nsresult rv;
     1: 
     1:     // Get a context if necessary
     1:     if (!cx)
     1:     {
     1:         cx = GetCurrentJSContext();
     1:         if (!cx)
     1:             return NS_OK; // No JS context, so allow access
     1:     }
     1: 
     1:     // Get a principal from the context
     1:     nsIPrincipal* sourcePrincipal = GetSubjectPrincipal(cx, &rv);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
     1:     if (!sourcePrincipal)
     1:     {
     1:         NS_WARNING("CheckSameOrigin called on script w/o principals; should this happen?");
     1:         return NS_OK;
     1:     }
     1: 
     1:     if (sourcePrincipal == mSystemPrincipal)
     1:     {
     1:         // This is a system (chrome) script, so allow access
     1:         return NS_OK;
     1:     }
     1: 
     1:     // Get the original URI from the source principal.
     1:     // This has the effect of ignoring any change to document.domain
     1:     // which must be done to avoid DNS spoofing (bug 154930)
     1:     nsCOMPtr<nsIURI> sourceURI;
     1:     sourcePrincipal->GetDomain(getter_AddRefs(sourceURI));
     1:     if (!sourceURI) {
     1:       sourcePrincipal->GetURI(getter_AddRefs(sourceURI));
     1:       NS_ENSURE_TRUE(sourceURI, NS_ERROR_FAILURE);
     1:     }
     1: 
     1:     // Compare origins
     1:     if (!SecurityCompareURIs(sourceURI, aTargetURI))
     1:     {
     1:          ReportError(cx, NS_LITERAL_STRING("CheckSameOriginError"), sourceURI, aTargetURI);
 13172:          return NS_ERROR_DOM_BAD_URI;
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CheckSameOriginURI(nsIURI* aSourceURI,
  7219:                                             nsIURI* aTargetURI,
 79445:                                             bool reportError)
     1: {
     1:     if (!SecurityCompareURIs(aSourceURI, aTargetURI))
     1:     {
  7219:          if (reportError) {
     1:             ReportError(nsnull, NS_LITERAL_STRING("CheckSameOriginError"),
     1:                      aSourceURI, aTargetURI);
  7219:          }
     1:          return NS_ERROR_DOM_BAD_URI;
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsScriptSecurityManager::CheckPropertyAccessImpl(PRUint32 aAction,
 10286:                                                  nsAXPCNativeCallContext* aCallContext,
     1:                                                  JSContext* cx, JSObject* aJSObject,
 14480:                                                  nsISupports* aObj, nsIURI* aTargetURI,
     1:                                                  nsIClassInfo* aClassInfo,
 48470:                                                  const char* aClassName, jsid aProperty,
     1:                                                  void** aCachedClassPolicy)
     1: {
     1:     nsresult rv;
     1:     nsIPrincipal* subjectPrincipal = GetSubjectPrincipal(cx, &rv);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
     1:     if (!subjectPrincipal || subjectPrincipal == mSystemPrincipal)
     1:         // We have native code or the system principal: just allow access
     1:         return NS_OK;
     1: 
 16268:     nsCOMPtr<nsIPrincipal> objectPrincipal;
 16268: 
     1:     // Hold the class info data here so we don't have to go back to virtual
     1:     // methods all the time
     1:     ClassInfoData classInfoData(aClassInfo, aClassName);
     1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     1:     nsCAutoString propertyName;
 48470:     propertyName.AssignWithConversion((PRUnichar*)IDToString(cx, aProperty));
     1:     printf("### CanAccess(%s.%s, %i) ", classInfoData.GetName(), 
     1:            propertyName.get(), aAction);
     1: #endif
     1: 
     1:     //-- Look up the security policy for this class and subject domain
     1:     SecurityLevel securityLevel;
     1:     rv = LookupPolicy(subjectPrincipal, classInfoData, aProperty, aAction, 
     1:                       (ClassPolicy**)aCachedClassPolicy, &securityLevel);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
     1:     if (securityLevel.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
     1:     {   
     1:         // No policy found for this property so use the default of last resort.
     1:         // If we were called from somewhere other than XPConnect
     1:         // (no XPC call context), assume this is a DOM class. Otherwise,
     1:         // ask the ClassInfo.
     1:         if (!aCallContext || classInfoData.IsDOMClass())
     1:             securityLevel.level = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;
     1:         else
     1:             securityLevel.level = SCRIPT_SECURITY_NO_ACCESS;
     1:     }
     1: 
     1:     if (SECURITY_ACCESS_LEVEL_FLAG(securityLevel))
     1:     // This flag means securityLevel is allAccess, noAccess, or sameOrigin
     1:     {
     1:         switch (securityLevel.level)
     1:         {
     1:         case SCRIPT_SECURITY_NO_ACCESS:
     1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     1:             printf("noAccess ");
     1: #endif
     1:             rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
     1:             break;
     1: 
     1:         case SCRIPT_SECURITY_ALL_ACCESS:
     1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     1:             printf("allAccess ");
     1: #endif
     1:             rv = NS_OK;
     1:             break;
     1: 
     1:         case SCRIPT_SECURITY_SAME_ORIGIN_ACCESS:
     1:             {
     1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     1:                 printf("sameOrigin ");
     1: #endif
 10341:                 nsCOMPtr<nsIPrincipal> principalHolder;
     1:                 if(aJSObject)
     1:                 {
 10939:                     objectPrincipal = doGetObjectPrincipal(aJSObject);
     1:                     if (!objectPrincipal)
  9830:                         rv = NS_ERROR_DOM_SECURITY_ERR;
     1:                 }
 14480:                 else if(aTargetURI)
 14480:                 {
 14480:                     if (NS_FAILED(GetCodebasePrincipal(
 16268:                           aTargetURI, getter_AddRefs(objectPrincipal))))
 14480:                         return NS_ERROR_FAILURE;
 14480:                 }
     1:                 else
     1:                 {
 14480:                     NS_ERROR("CheckPropertyAccessImpl called without a target object or URL");
     1:                     return NS_ERROR_FAILURE;
     1:                 }
  9830:                 if(NS_SUCCEEDED(rv))
     1:                     rv = CheckSameOriginDOMProp(subjectPrincipal, objectPrincipal,
 37831:                                                 aAction);
     1:                 break;
     1:             }
     1:         default:
     1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     1:                 printf("ERROR ");
     1: #endif
     1:             NS_ERROR("Bad Security Level Value");
     1:             return NS_ERROR_FAILURE;
     1:         }
     1:     }
     1:     else // if SECURITY_ACCESS_LEVEL_FLAG is false, securityLevel is a capability
     1:     {
     1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     1:         printf("Cap:%s ", securityLevel.capability);
     1: #endif
 79445:         bool capabilityEnabled = false;
     1:         rv = IsCapabilityEnabled(securityLevel.capability, &capabilityEnabled);
     1:         if (NS_FAILED(rv) || !capabilityEnabled)
     1:             rv = NS_ERROR_DOM_SECURITY_ERR;
     1:         else
     1:             rv = NS_OK;
     1:     }
     1: 
     1:     if (NS_SUCCEEDED(rv))
     1:     {
     1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     1:     printf(" GRANTED.\n");
     1: #endif
     1:         return rv;
     1:     }
     1: 
     1:     //--See if the object advertises a non-default level of access
     1:     //  using nsISecurityCheckedComponent
     1:     nsCOMPtr<nsISecurityCheckedComponent> checkedComponent =
     1:         do_QueryInterface(aObj);
     1: 
     1:     nsXPIDLCString objectSecurityLevel;
     1:     if (checkedComponent)
     1:     {
     1:         nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
     1:         nsCOMPtr<nsIInterfaceInfo> interfaceInfo;
 39724:         const nsIID* objIID = nsnull;
     1:         rv = aCallContext->GetCalleeWrapper(getter_AddRefs(wrapper));
 39724:         if (NS_SUCCEEDED(rv) && wrapper)
     1:             rv = wrapper->FindInterfaceWithMember(aProperty, getter_AddRefs(interfaceInfo));
 39724:         if (NS_SUCCEEDED(rv) && interfaceInfo)
     1:             rv = interfaceInfo->GetIIDShared(&objIID);
 39724:         if (NS_SUCCEEDED(rv) && objIID)
     1:         {
     1:             switch (aAction)
     1:             {
     1:             case nsIXPCSecurityManager::ACCESS_GET_PROPERTY:
     1:                 checkedComponent->CanGetProperty(objIID,
 48470:                                                  IDToString(cx, aProperty),
     1:                                                  getter_Copies(objectSecurityLevel));
     1:                 break;
     1:             case nsIXPCSecurityManager::ACCESS_SET_PROPERTY:
     1:                 checkedComponent->CanSetProperty(objIID,
 48470:                                                  IDToString(cx, aProperty),
     1:                                                  getter_Copies(objectSecurityLevel));
     1:                 break;
     1:             case nsIXPCSecurityManager::ACCESS_CALL_METHOD:
     1:                 checkedComponent->CanCallMethod(objIID,
 48470:                                                 IDToString(cx, aProperty),
     1:                                                 getter_Copies(objectSecurityLevel));
     1:             }
     1:         }
     1:     }
 31205:     rv = CheckXPCPermissions(cx, aObj, aJSObject, subjectPrincipal,
 28292:                              objectSecurityLevel);
     1: #ifdef DEBUG_CAPS_CheckPropertyAccessImpl
     1:     if(NS_SUCCEEDED(rv))
     1:         printf("CheckXPCPerms GRANTED.\n");
     1:     else
     1:         printf("CheckXPCPerms DENIED.\n");
     1: #endif
     1: 
     1:     if (NS_FAILED(rv)) //-- Security tests failed, access is denied, report error
     1:     {
     1:         nsAutoString stringName;
     1:         switch(aAction)
     1:         {
     1:         case nsIXPCSecurityManager::ACCESS_GET_PROPERTY:
 16268:             stringName.AssignLiteral("GetPropertyDeniedOrigins");
     1:             break;
     1:         case nsIXPCSecurityManager::ACCESS_SET_PROPERTY:
 16268:             stringName.AssignLiteral("SetPropertyDeniedOrigins");
     1:             break;
     1:         case nsIXPCSecurityManager::ACCESS_CALL_METHOD:
 16268:             stringName.AssignLiteral("CallMethodDeniedOrigins");
     1:         }
     1: 
 59627:         // Null out objectPrincipal for now, so we don't leak information about
 59627:         // it.  Whenever we can report different error strings to content and
 59627:         // the UI we can take this out again.
 59627:         objectPrincipal = nsnull;
 59627: 
     1:         NS_ConvertUTF8toUTF16 className(classInfoData.GetName());
 16268:         nsCAutoString subjectOrigin;
 30838:         nsCAutoString subjectDomain;
 28684:         if (!nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin) {
 30838:             nsCOMPtr<nsIURI> uri, domain;
 30838:             subjectPrincipal->GetURI(getter_AddRefs(uri));
 30838:             // Subject can't be system if we failed the security
 30838:             // check, so |uri| is non-null.
 30838:             NS_ASSERTION(uri, "How did that happen?");
 30838:             GetOriginFromURI(uri, subjectOrigin);
 30838:             subjectPrincipal->GetDomain(getter_AddRefs(domain));
 30838:             if (domain) {
 30838:                 GetOriginFromURI(domain, subjectDomain);
 30838:             }
 28684:         } else {
 28684:             subjectOrigin.AssignLiteral("the security manager");
 28684:         }
 16268:         NS_ConvertUTF8toUTF16 subjectOriginUnicode(subjectOrigin);
 30838:         NS_ConvertUTF8toUTF16 subjectDomainUnicode(subjectDomain);
 16268: 
 16268:         nsCAutoString objectOrigin;
 30838:         nsCAutoString objectDomain;
 28684:         if (!nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin &&
 28684:             objectPrincipal) {
 30838:             nsCOMPtr<nsIURI> uri, domain;
 30838:             objectPrincipal->GetURI(getter_AddRefs(uri));
 30838:             if (uri) { // Object principal might be system
 30838:                 GetOriginFromURI(uri, objectOrigin);
 30838:             }
 30838:             objectPrincipal->GetDomain(getter_AddRefs(domain));
 30838:             if (domain) {
 30838:                 GetOriginFromURI(domain, objectDomain);
 30838:             }
 16268:         }
 16268:         NS_ConvertUTF8toUTF16 objectOriginUnicode(objectOrigin);
 30838:         NS_ConvertUTF8toUTF16 objectDomainUnicode(objectDomain);
 16268: 
 16268:         nsXPIDLString errorMsg;
     1:         const PRUnichar *formatStrings[] =
     1:         {
 16268:             subjectOriginUnicode.get(),
     1:             className.get(),
 48470:             IDToString(cx, aProperty),
 30838:             objectOriginUnicode.get(),
 30838:             subjectDomainUnicode.get(),
 30838:             objectDomainUnicode.get()
     1:         };
     1: 
 80467:         PRUint32 length = ArrayLength(formatStrings);
 16268: 
 30838:         // XXXbz Our localization system is stupid and can't handle not showing
 30838:         // some strings that get passed in.  Which means that we have to get
 30838:         // our length precisely right: it has to be exactly the number of
 30838:         // strings our format string wants.  This means we'll have to move
 30838:         // strings in the array as needed, sadly...
 28684:         if (nsAutoInPrincipalDomainOriginSetter::sInPrincipalDomainOrigin ||
 28684:             !objectPrincipal) {
 16268:             stringName.AppendLiteral("OnlySubject");
 30838:             length -= 3;
 30838:         } else {
 30838:             // default to a length that doesn't include the domains, then
 30838:             // increase it as needed.
 30838:             length -= 2;
 30838:             if (!subjectDomainUnicode.IsEmpty()) {
 30838:                 stringName.AppendLiteral("SubjectDomain");
 30838:                 length += 1;
 30838:             }
 30838:             if (!objectDomainUnicode.IsEmpty()) {
 30838:                 stringName.AppendLiteral("ObjectDomain");
 30838:                 length += 1;
 80467:                 if (length != ArrayLength(formatStrings)) {
 30838:                     // We have an object domain but not a subject domain.
 30838:                     // Scoot our string over one slot.  See the XXX comment
 30838:                     // above for why we need to do this.
 30838:                     formatStrings[length-1] = formatStrings[length];
 30838:                 }
 30838:             }
 16268:         }
 16268:         
     1:         // We need to keep our existing failure rv and not override it
     1:         // with a likely success code from the following string bundle
     1:         // call in order to throw the correct security exception later.
     1:         nsresult rv2 = sStrBundle->FormatStringFromName(stringName.get(),
     1:                                                         formatStrings,
 16268:                                                         length,
     1:                                                         getter_Copies(errorMsg));
 16268:         if (NS_FAILED(rv2)) {
 16268:             // Might just be missing the string...  Do our best
 16268:             errorMsg = stringName;
 16268:         }
     1: 
     1:         SetPendingException(cx, errorMsg.get());
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
 13269: /* static */
     1: nsresult
 13269: nsScriptSecurityManager::CheckSameOriginPrincipal(nsIPrincipal* aSubject,
 37831:                                                   nsIPrincipal* aObject)
     1: {
     1:     /*
     1:     ** Get origin of subject and object and compare.
     1:     */
     1:     if (aSubject == aObject)
     1:         return NS_OK;
     1: 
 37831:     // Default to false, and change if that turns out wrong.
 79445:     bool subjectSetDomain = false;
 79445:     bool objectSetDomain = false;
     1:     
     1:     nsCOMPtr<nsIURI> subjectURI;
     1:     nsCOMPtr<nsIURI> objectURI;
     1: 
     1:     aSubject->GetDomain(getter_AddRefs(subjectURI));
     1:     if (!subjectURI) {
     1:         aSubject->GetURI(getter_AddRefs(subjectURI));
     1:     } else {
 80486:         subjectSetDomain = true;
     1:     }
     1: 
     1:     aObject->GetDomain(getter_AddRefs(objectURI));
     1:     if (!objectURI) {
     1:         aObject->GetURI(getter_AddRefs(objectURI));
     1:     } else {
 80486:         objectSetDomain = true;
     1:     }
     1: 
     1:     if (SecurityCompareURIs(subjectURI, objectURI))
     1:     {   // If either the subject or the object has changed its principal by
     1:         // explicitly setting document.domain then the other must also have
     1:         // done so in order to be considered the same origin. This prevents
     1:         // DNS spoofing based on document.domain (154930)
     1: 
     1:         // If both or neither explicitly set their domain, allow the access
     1:         if (subjectSetDomain == objectSetDomain)
     1:             return NS_OK;
     1:     }
     1: 
     1:     /*
     1:     ** Access tests failed, so now report error.
     1:     */
     1:     return NS_ERROR_DOM_PROP_ACCESS_DENIED;
     1: }
     1: 
 20149: // It's important that
 20149: //
 37831: //   CheckSameOriginPrincipal(A, B) == NS_OK
 20149: //
 20149: // imply
 20149: //
 20149: //   HashPrincipalByOrigin(A) == HashPrincipalByOrigin(B)
 20149: //
 20149: // if principals A and B could ever be used as keys in a hashtable.
 20149: // Violation of this invariant leads to spurious failures of hashtable
 20149: // lookups.  See bug 454850.
 20149: 
 20149: /*static*/ PRUint32
 20149: nsScriptSecurityManager::HashPrincipalByOrigin(nsIPrincipal* aPrincipal)
 20149: {
 20149:     nsCOMPtr<nsIURI> uri;
 20149:     aPrincipal->GetDomain(getter_AddRefs(uri));
 20149:     if (!uri)
 20149:         aPrincipal->GetURI(getter_AddRefs(uri));
 20149:     return SecurityHashURI(uri);
 20149: }
     1: 
     1: nsresult
     1: nsScriptSecurityManager::CheckSameOriginDOMProp(nsIPrincipal* aSubject,
     1:                                                 nsIPrincipal* aObject,
 37831:                                                 PRUint32 aAction)
     1: {
 13269:     nsresult rv;
 79445:     bool subsumes;
 13269:     rv = aSubject->Subsumes(aObject, &subsumes);
 13269:     if (NS_SUCCEEDED(rv) && !subsumes) {
 13269:         rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
 13269:     }
     1:     
     1:     if (NS_SUCCEEDED(rv))
     1:         return NS_OK;
     1: 
     1:     /*
     1:     * Content can't ever touch chrome (we check for UniversalXPConnect later)
     1:     */
     1:     if (aObject == mSystemPrincipal)
     1:         return NS_ERROR_DOM_PROP_ACCESS_DENIED;
     1: 
     1:     /*
     1:     ** Access tests failed, so now report error.
     1:     */
     1:     return NS_ERROR_DOM_PROP_ACCESS_DENIED;
     1: }
     1: 
     1: nsresult
     1: nsScriptSecurityManager::LookupPolicy(nsIPrincipal* aPrincipal,
     1:                                       ClassInfoData& aClassData,
 48470:                                       jsid aProperty,
     1:                                       PRUint32 aAction,
     1:                                       ClassPolicy** aCachedClassPolicy,
     1:                                       SecurityLevel* result)
     1: {
     1:     nsresult rv;
     1:     result->level = SCRIPT_SECURITY_UNDEFINED_ACCESS;
     1: 
     1:     DomainPolicy* dpolicy = nsnull;
     1:     //-- Initialize policies if necessary
     1:     if (mPolicyPrefsChanged)
     1:     {
 72017:         if (!mPrefInitialized) {
 23434:             rv = InitPrefs();
 23434:             NS_ENSURE_SUCCESS(rv, rv);
 23434:         }
     1:         rv = InitPolicies();
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1:     }
     1:     else
     1:     {
     1:         aPrincipal->GetSecurityPolicy((void**)&dpolicy);
     1:     }
     1: 
     1:     if (!dpolicy && mOriginToPolicyMap)
     1:     {
     1:         //-- Look up the relevant domain policy, if any
     1: #ifdef DEBUG_CAPS_LookupPolicy
     1:         printf("DomainLookup ");
     1: #endif
     1: 
 13284:         nsCAutoString origin;
 13284:         rv = GetPrincipalDomainOrigin(aPrincipal, origin);
 13284:         NS_ENSURE_SUCCESS(rv, rv);
     1:  
     1:         char *start = origin.BeginWriting();
     1:         const char *nextToLastDot = nsnull;
     1:         const char *lastDot = nsnull;
     1:         const char *colon = nsnull;
     1:         char *p = start;
     1: 
     1:         //-- search domain (stop at the end of the string or at the 3rd slash)
     1:         for (PRUint32 slashes=0; *p; p++)
     1:         {
     1:             if (*p == '/' && ++slashes == 3) 
     1:             {
     1:                 *p = '\0'; // truncate at 3rd slash
     1:                 break;
     1:             }
     1:             if (*p == '.')
     1:             {
     1:                 nextToLastDot = lastDot;
     1:                 lastDot = p;
     1:             } 
     1:             else if (!colon && *p == ':')
     1:                 colon = p;
     1:         }
     1: 
     1:         nsCStringKey key(nextToLastDot ? nextToLastDot+1 : start);
     1:         DomainEntry *de = (DomainEntry*) mOriginToPolicyMap->Get(&key);
     1:         if (!de)
     1:         {
     1:             nsCAutoString scheme(start, colon-start+1);
     1:             nsCStringKey schemeKey(scheme);
     1:             de = (DomainEntry*) mOriginToPolicyMap->Get(&schemeKey);
     1:         }
     1: 
     1:         while (de)
     1:         {
     1:             if (de->Matches(start))
     1:             {
     1:                 dpolicy = de->mDomainPolicy;
     1:                 break;
     1:             }
     1:             de = de->mNext;
     1:         }
     1: 
     1:         if (!dpolicy)
     1:             dpolicy = mDefaultPolicy;
     1: 
     1:         aPrincipal->SetSecurityPolicy((void*)dpolicy);
     1:     }
     1: 
     1:     ClassPolicy* cpolicy = nsnull;
     1: 
     1:     if ((dpolicy == mDefaultPolicy) && aCachedClassPolicy)
     1:     {
     1:         // No per-domain policy for this principal (the more common case)
     1:         // so look for a cached class policy from the object wrapper
     1:         cpolicy = *aCachedClassPolicy;
     1:     }
     1: 
     1:     if (!cpolicy)
     1:     { //-- No cached policy for this class, need to look it up
     1: #ifdef DEBUG_CAPS_LookupPolicy
     1:         printf("ClassLookup ");
     1: #endif
     1: 
  3233:         cpolicy = static_cast<ClassPolicy*>
  3233:                              (PL_DHashTableOperate(dpolicy,
     1:                                                       aClassData.GetName(),
     1:                                                       PL_DHASH_LOOKUP));
     1: 
     1:         if (PL_DHASH_ENTRY_IS_FREE(cpolicy))
     1:             cpolicy = NO_POLICY_FOR_CLASS;
     1: 
     1:         if ((dpolicy == mDefaultPolicy) && aCachedClassPolicy)
     1:             *aCachedClassPolicy = cpolicy;
     1:     }
     1: 
 48470:     NS_ASSERTION(JSID_IS_INT(aProperty) || JSID_IS_OBJECT(aProperty) ||
 48470:                  JSID_IS_STRING(aProperty), "Property must be a valid id");
 48470: 
 48470:     // Only atomized strings are stored in the policies' hash tables.
 48470:     if (!JSID_IS_STRING(aProperty))
 48470:         return NS_OK;
 48470: 
 48470:     JSString *propertyKey = JSID_TO_STRING(aProperty);
 48470: 
     1:     // We look for a PropertyPolicy in the following places:
     1:     // 1)  The ClassPolicy for our class we got from our DomainPolicy
     1:     // 2)  The mWildcardPolicy of our DomainPolicy
     1:     // 3)  The ClassPolicy for our class we got from mDefaultPolicy
     1:     // 4)  The mWildcardPolicy of our mDefaultPolicy
     1:     PropertyPolicy* ppolicy = nsnull;
     1:     if (cpolicy != NO_POLICY_FOR_CLASS)
     1:     {
  3233:         ppolicy = static_cast<PropertyPolicy*>
  3233:                              (PL_DHashTableOperate(cpolicy->mPolicy,
 48470:                                                       propertyKey,
     1:                                                       PL_DHASH_LOOKUP));
     1:     }
     1: 
     1:     // If there is no class policy for this property, and we have a wildcard
     1:     // policy, try that.
     1:     if (dpolicy->mWildcardPolicy &&
     1:         (!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy)))
     1:     {
     1:         ppolicy =
  3233:             static_cast<PropertyPolicy*>
  3233:                        (PL_DHashTableOperate(dpolicy->mWildcardPolicy->mPolicy,
 48470:                                                 propertyKey,
     1:                                                 PL_DHASH_LOOKUP));
     1:     }
     1: 
     1:     // If dpolicy is not the defauly policy and there's no class or wildcard
     1:     // policy for this property, check the default policy for this class and
     1:     // the default wildcard policy
     1:     if (dpolicy != mDefaultPolicy &&
     1:         (!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy)))
     1:     {
  3233:         cpolicy = static_cast<ClassPolicy*>
  3233:                              (PL_DHashTableOperate(mDefaultPolicy,
     1:                                                       aClassData.GetName(),
     1:                                                       PL_DHASH_LOOKUP));
     1: 
     1:         if (PL_DHASH_ENTRY_IS_BUSY(cpolicy))
     1:         {
     1:             ppolicy =
  3233:                 static_cast<PropertyPolicy*>
  3233:                            (PL_DHashTableOperate(cpolicy->mPolicy,
 48470:                                                     propertyKey,
     1:                                                     PL_DHASH_LOOKUP));
     1:         }
     1: 
     1:         if ((!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy)) &&
     1:             mDefaultPolicy->mWildcardPolicy)
     1:         {
     1:             ppolicy =
  3233:               static_cast<PropertyPolicy*>
  3233:                          (PL_DHashTableOperate(mDefaultPolicy->mWildcardPolicy->mPolicy,
 48470:                                                   propertyKey,
     1:                                                   PL_DHASH_LOOKUP));
     1:         }
     1:     }
     1: 
     1:     if (!ppolicy || PL_DHASH_ENTRY_IS_FREE(ppolicy))
     1:         return NS_OK;
     1: 
     1:     // Get the correct security level from the property policy
     1:     if (aAction == nsIXPCSecurityManager::ACCESS_SET_PROPERTY)
     1:         *result = ppolicy->mSet;
     1:     else
     1:         *result = ppolicy->mGet;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CheckLoadURIFromScript(JSContext *cx, nsIURI *aURI)
     1: {
     1:     // Get principal of currently executing script.
     1:     nsresult rv;
     1:     nsIPrincipal* principal = GetSubjectPrincipal(cx, &rv);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
     1:     // Native code can load all URIs.
     1:     if (!principal)
     1:         return NS_OK;
     1: 
     1:     rv = CheckLoadURIWithPrincipal(principal, aURI,
     1:                                    nsIScriptSecurityManager::STANDARD);
     1:     if (NS_SUCCEEDED(rv)) {
     1:         // OK to load
     1:         return NS_OK;
     1:     }
     1: 
     1:     // See if we're attempting to load a file: URI. If so, let a
 86400:     // UniversalXPConnect capability trump the above check.
 79445:     bool isFile = false;
 79445:     bool isRes = false;
     1:     if (NS_FAILED(aURI->SchemeIs("file", &isFile)) ||
     1:         NS_FAILED(aURI->SchemeIs("resource", &isRes)))
     1:         return NS_ERROR_FAILURE;
     1:     if (isFile || isRes)
     1:     {
 79445:         bool enabled;
 86400:         if (NS_FAILED(IsCapabilityEnabled("UniversalXPConnect", &enabled)))
     1:             return NS_ERROR_FAILURE;
     1:         if (enabled)
     1:             return NS_OK;
     1:     }
     1: 
     1:     // Report error.
     1:     nsCAutoString spec;
     1:     if (NS_FAILED(aURI->GetAsciiSpec(spec)))
     1:         return NS_ERROR_FAILURE;
 28616:     nsCAutoString msg("Access to '");
 28616:     msg.Append(spec);
 28616:     msg.AppendLiteral("' from script denied");
 28616:     SetPendingException(cx, msg.get());
 13172:     return NS_ERROR_DOM_BAD_URI;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CheckLoadURI(nsIURI *aSourceURI, nsIURI *aTargetURI,
     1:                                       PRUint32 aFlags)
     1: {
     1:     // FIXME: bug 327244 -- this function should really die...  Really truly.
     1:     NS_PRECONDITION(aSourceURI, "CheckLoadURI called with null source URI");
     1:     NS_ENSURE_ARG_POINTER(aSourceURI);
     1: 
     1:     // Note: this is not _quite_ right if aSourceURI has
     1:     // NS_NULLPRINCIPAL_SCHEME, but we'll just extract the scheme in
     1:     // CheckLoadURIWithPrincipal anyway, so this is good enough.  This method
     1:     // really needs to go away....
     1:     nsCOMPtr<nsIPrincipal> sourcePrincipal;
     1:     nsresult rv = CreateCodebasePrincipal(aSourceURI,
     1:                                           getter_AddRefs(sourcePrincipal));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     return CheckLoadURIWithPrincipal(sourcePrincipal, aTargetURI, aFlags);
     1: }
     1: 
     1: /**
     1:  * Helper method to handle cases where a flag passed to
     1:  * CheckLoadURIWithPrincipal means denying loading if the given URI has certain
     1:  * nsIProtocolHandler flags set.
     1:  * @return if success, access is allowed. Otherwise, deny access
     1:  */
     1: static nsresult
     1: DenyAccessIfURIHasFlags(nsIURI* aURI, PRUint32 aURIFlags)
     1: {
     1:     NS_PRECONDITION(aURI, "Must have URI!");
     1:     
 79445:     bool uriHasFlags;
     1:     nsresult rv =
     1:         NS_URIChainHasFlags(aURI, aURIFlags, &uriHasFlags);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     if (uriHasFlags) {
     1:         return NS_ERROR_DOM_BAD_URI;
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CheckLoadURIWithPrincipal(nsIPrincipal* aPrincipal,
     1:                                                    nsIURI *aTargetURI,
     1:                                                    PRUint32 aFlags)
     1: {
     1:     NS_PRECONDITION(aPrincipal, "CheckLoadURIWithPrincipal must have a principal");
     1:     // If someone passes a flag that we don't understand, we should
     1:     // fail, because they may need a security check that we don't
     1:     // provide.
     1:     NS_ENSURE_FALSE(aFlags & ~(nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT |
     1:                                nsIScriptSecurityManager::ALLOW_CHROME |
     1:                                nsIScriptSecurityManager::DISALLOW_SCRIPT |
     1:                                nsIScriptSecurityManager::DISALLOW_INHERIT_PRINCIPAL),
     1:                     NS_ERROR_UNEXPECTED);
     1:     NS_ENSURE_ARG_POINTER(aPrincipal);
 23241:     NS_ENSURE_ARG_POINTER(aTargetURI);
     1: 
 93536:     // If DISALLOW_INHERIT_PRINCIPAL is set, we prevent loading of URIs which
 93536:     // would do such inheriting. That would be URIs that do not have their own
 93536:     // security context. We do this even for the system principal.
 93536:     if (aFlags & nsIScriptSecurityManager::DISALLOW_INHERIT_PRINCIPAL) {
 93536:         nsresult rv =
 93536:             DenyAccessIfURIHasFlags(aTargetURI,
 93536:                                     nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT);
 93536:         NS_ENSURE_SUCCESS(rv, rv);
 93536:     }
 93536: 
     1:     if (aPrincipal == mSystemPrincipal) {
     1:         // Allow access
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIURI> sourceURI;
     1:     aPrincipal->GetURI(getter_AddRefs(sourceURI));
  4337:     if (!sourceURI) {
  4337:         NS_ERROR("Non-system principals passed to CheckLoadURIWithPrincipal "
  4337:                  "must have a URI!");
  4337:         return NS_ERROR_UNEXPECTED;
  4337:     }
     1:     
     1:     // Automatic loads are not allowed from certain protocols.
     1:     if (aFlags & nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT) {
     1:         nsresult rv =
     1:             DenyAccessIfURIHasFlags(sourceURI,
     1:                                     nsIProtocolHandler::URI_FORBIDS_AUTOMATIC_DOCUMENT_REPLACEMENT);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1: 
     1:     // If either URI is a nested URI, get the base URI
     1:     nsCOMPtr<nsIURI> sourceBaseURI = NS_GetInnermostURI(sourceURI);
     1:     nsCOMPtr<nsIURI> targetBaseURI = NS_GetInnermostURI(aTargetURI);
     1: 
     1:     //-- get the target scheme
     1:     nsCAutoString targetScheme;
     1:     nsresult rv = targetBaseURI->GetScheme(targetScheme);
     1:     if (NS_FAILED(rv)) return rv;
     1: 
     1:     //-- Some callers do not allow loading javascript:
     1:     if ((aFlags & nsIScriptSecurityManager::DISALLOW_SCRIPT) &&
     1:          targetScheme.EqualsLiteral("javascript"))
     1:     {
     1:        return NS_ERROR_DOM_BAD_URI;
     1:     }
     1: 
 38871:     NS_NAMED_LITERAL_STRING(errorTag, "CheckLoadURIError");
 38871: 
 38871:     // Check for uris that are only loadable by principals that subsume them
 79445:     bool hasFlags;
 38871:     rv = NS_URIChainHasFlags(targetBaseURI,
 38871:                              nsIProtocolHandler::URI_LOADABLE_BY_SUBSUMERS,
 38871:                              &hasFlags);
 38871:     NS_ENSURE_SUCCESS(rv, rv);
 38871: 
 38871:     if (hasFlags) {
 80486:         return aPrincipal->CheckMayLoad(targetBaseURI, true);
 38871:     }
 38871: 
     1:     //-- get the source scheme
     1:     nsCAutoString sourceScheme;
     1:     rv = sourceBaseURI->GetScheme(sourceScheme);
     1:     if (NS_FAILED(rv)) return rv;
     1: 
 13653:     if (sourceScheme.LowerCaseEqualsLiteral(NS_NULLPRINCIPAL_SCHEME)) {
 13653:         // A null principal can target its own URI.
 13653:         if (sourceURI == aTargetURI) {
 13653:             return NS_OK;
 13653:         }
 13653:     }
 13653:     else if (targetScheme.Equals(sourceScheme,
 13653:                                  nsCaseInsensitiveCStringComparator()))
     1:     {
     1:         // every scheme can access another URI from the same scheme,
     1:         // as long as they don't represent null principals.
     1:         return NS_OK;
     1:     }
     1: 
     1:     // If the schemes don't match, the policy is specified by the protocol
     1:     // flags on the target URI.  Note that the order of policy checks here is
     1:     // very important!  We start from most restrictive and work our way down.
     1:     // Note that since we're working with the innermost URI, we can just use
     1:     // the methods that work on chains of nested URIs and they will only look
     1:     // at the flags for our one URI.
     1: 
     1:     // Check for system target URI
     1:     rv = DenyAccessIfURIHasFlags(targetBaseURI,
     1:                                  nsIProtocolHandler::URI_DANGEROUS_TO_LOAD);
     1:     if (NS_FAILED(rv)) {
     1:         // Deny access, since the origin principal is not system
     1:         ReportError(nsnull, errorTag, sourceURI, aTargetURI);
     1:         return rv;
     1:     }
     1: 
     1:     // Check for chrome target URI
     1:     rv = NS_URIChainHasFlags(targetBaseURI,
     1:                              nsIProtocolHandler::URI_IS_UI_RESOURCE,
     1:                              &hasFlags);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     if (hasFlags) {
     1:         if (aFlags & nsIScriptSecurityManager::ALLOW_CHROME) {
 14262:             if (!targetScheme.EqualsLiteral("chrome")) {
 14262:                 // for now don't change behavior for resource: or moz-icon:
     1:                 return NS_OK;
     1:             }
     1: 
 14262:             // allow load only if chrome package is whitelisted
 14262:             nsCOMPtr<nsIXULChromeRegistry> reg(do_GetService(
 14262:                                                  NS_CHROMEREGISTRY_CONTRACTID));
 14262:             if (reg) {
 79445:                 bool accessAllowed = false;
 14262:                 reg->AllowContentToAccess(targetBaseURI, &accessAllowed);
 14262:                 if (accessAllowed) {
 14262:                     return NS_OK;
 14262:                 }
 14262:             }
 14262:         }
 14262: 
     1:         // resource: and chrome: are equivalent, securitywise
     1:         // That's bogus!!  Fix this.  But watch out for
     1:         // the view-source stylesheet?
 79445:         bool sourceIsChrome;
     1:         rv = NS_URIChainHasFlags(sourceBaseURI,
     1:                                  nsIProtocolHandler::URI_IS_UI_RESOURCE,
     1:                                  &sourceIsChrome);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:         if (sourceIsChrome) {
     1:             return NS_OK;
     1:         }
     1:         ReportError(nsnull, errorTag, sourceURI, aTargetURI);
     1:         return NS_ERROR_DOM_BAD_URI;
     1:     }
     1: 
     1:     // Check for target URI pointing to a file
     1:     rv = NS_URIChainHasFlags(targetBaseURI,
     1:                              nsIProtocolHandler::URI_IS_LOCAL_FILE,
     1:                              &hasFlags);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     if (hasFlags) {
     1:         // resource: and chrome: are equivalent, securitywise
     1:         // That's bogus!!  Fix this.  But watch out for
     1:         // the view-source stylesheet?
 79445:         bool sourceIsChrome;
     1:         rv = NS_URIChainHasFlags(sourceURI,
     1:                                  nsIProtocolHandler::URI_IS_UI_RESOURCE,
     1:                                  &sourceIsChrome);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:         if (sourceIsChrome) {
     1:             return NS_OK;
     1:         }
     1: 
     1:         // Now check capability policies
     1:         static const char loadURIPrefGroup[] = "checkloaduri";
     1:         ClassInfoData nameData(nsnull, loadURIPrefGroup);
     1: 
     1:         SecurityLevel secLevel;
     1:         rv = LookupPolicy(aPrincipal, nameData, sEnabledID,
     1:                           nsIXPCSecurityManager::ACCESS_GET_PROPERTY, 
     1:                           nsnull, &secLevel);
     1:         if (NS_SUCCEEDED(rv) && secLevel.level == SCRIPT_SECURITY_ALL_ACCESS)
     1:         {
     1:             // OK for this site!
     1:             return NS_OK;
     1:         }
     1: 
     1:         ReportError(nsnull, errorTag, sourceURI, aTargetURI);
     1:         return NS_ERROR_DOM_BAD_URI;
     1:     }
     1: 
     1:     // OK, everyone is allowed to load this, since unflagged handlers are
     1:     // deprecated but treated as URI_LOADABLE_BY_ANYONE.  But check whether we
     1:     // need to warn.  At some point we'll want to make this warning into an
     1:     // error and treat unflagged handlers as URI_DANGEROUS_TO_LOAD.
     1:     rv = NS_URIChainHasFlags(targetBaseURI,
     1:                              nsIProtocolHandler::URI_LOADABLE_BY_ANYONE,
     1:                              &hasFlags);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     if (!hasFlags) {
     1:         nsXPIDLString message;
     1:         NS_ConvertASCIItoUTF16 ucsTargetScheme(targetScheme);
     1:         const PRUnichar* formatStrings[] = { ucsTargetScheme.get() };
     1:         rv = sStrBundle->
     1:             FormatStringFromName(NS_LITERAL_STRING("ProtocolFlagError").get(),
     1:                                  formatStrings,
 80467:                                  ArrayLength(formatStrings),
     1:                                  getter_Copies(message));
     1:         if (NS_SUCCEEDED(rv)) {
     1:             nsCOMPtr<nsIConsoleService> console(
     1:               do_GetService("@mozilla.org/consoleservice;1"));
     1:             NS_ENSURE_TRUE(console, NS_ERROR_FAILURE);
     1: 
     1:             console->LogStringMessage(message.get());
     1: #ifdef DEBUG
     1:             fprintf(stderr, "%s\n", NS_ConvertUTF16toUTF8(message).get());
     1: #endif
     1:         }
     1:     }
     1:     
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsScriptSecurityManager::ReportError(JSContext* cx, const nsAString& messageTag,
     1:                                      nsIURI* aSource, nsIURI* aTarget)
     1: {
     1:     nsresult rv;
     1:     NS_ENSURE_TRUE(aSource && aTarget, NS_ERROR_NULL_POINTER);
     1: 
     1:     // Get the source URL spec
     1:     nsCAutoString sourceSpec;
     1:     rv = aSource->GetAsciiSpec(sourceSpec);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Get the target URL spec
     1:     nsCAutoString targetSpec;
     1:     rv = aTarget->GetAsciiSpec(targetSpec);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Localize the error message
     1:     nsXPIDLString message;
     1:     NS_ConvertASCIItoUTF16 ucsSourceSpec(sourceSpec);
     1:     NS_ConvertASCIItoUTF16 ucsTargetSpec(targetSpec);
     1:     const PRUnichar *formatStrings[] = { ucsSourceSpec.get(), ucsTargetSpec.get() };
     1:     rv = sStrBundle->FormatStringFromName(PromiseFlatString(messageTag).get(),
     1:                                           formatStrings,
 80467:                                           ArrayLength(formatStrings),
     1:                                           getter_Copies(message));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // If a JS context was passed in, set a JS exception.
     1:     // Otherwise, print the error message directly to the JS console
     1:     // and to standard output
     1:     if (cx)
     1:     {
     1:         SetPendingException(cx, message.get());
     1:     }
     1:     else // Print directly to the console
     1:     {
     1:         nsCOMPtr<nsIConsoleService> console(
     1:             do_GetService("@mozilla.org/consoleservice;1"));
     1:         NS_ENSURE_TRUE(console, NS_ERROR_FAILURE);
     1: 
     1:         console->LogStringMessage(message.get());
     1: #ifdef DEBUG
     1:         fprintf(stderr, "%s\n", NS_LossyConvertUTF16toASCII(message).get());
     1: #endif
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CheckLoadURIStr(const nsACString& aSourceURIStr,
     1:                                          const nsACString& aTargetURIStr,
     1:                                          PRUint32 aFlags)
     1: {
     1:     // FIXME: bug 327244 -- this function should really die...  Really truly.
     1:     nsCOMPtr<nsIURI> source;
     1:     nsresult rv = NS_NewURI(getter_AddRefs(source), aSourceURIStr,
     1:                             nsnull, nsnull, sIOService);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Note: this is not _quite_ right if aSourceURI has
     1:     // NS_NULLPRINCIPAL_SCHEME, but we'll just extract the scheme in
     1:     // CheckLoadURIWithPrincipal anyway, so this is good enough.  This method
     1:     // really needs to go away....
     1:     nsCOMPtr<nsIPrincipal> sourcePrincipal;
     1:     rv = CreateCodebasePrincipal(source,
     1:                                  getter_AddRefs(sourcePrincipal));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     return CheckLoadURIStrWithPrincipal(sourcePrincipal, aTargetURIStr,
     1:                                         aFlags);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CheckLoadURIStrWithPrincipal(nsIPrincipal* aPrincipal,
     1:                                                       const nsACString& aTargetURIStr,
     1:                                                       PRUint32 aFlags)
     1: {
     1:     nsresult rv;
     1:     nsCOMPtr<nsIURI> target;
     1:     rv = NS_NewURI(getter_AddRefs(target), aTargetURIStr,
     1:                    nsnull, nsnull, sIOService);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     rv = CheckLoadURIWithPrincipal(aPrincipal, target, aFlags);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Now start testing fixup -- since aTargetURIStr is a string, not
     1:     // an nsIURI, we may well end up fixing it up before loading.
     1:     // Note: This needs to stay in sync with the nsIURIFixup api.
     1:     nsCOMPtr<nsIURIFixup> fixup = do_GetService(NS_URIFIXUP_CONTRACTID);
     1:     if (!fixup) {
     1:         return rv;
     1:     }
     1: 
     1:     PRUint32 flags[] = {
     1:         nsIURIFixup::FIXUP_FLAG_NONE,
     1:         nsIURIFixup::FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP,
     1:         nsIURIFixup::FIXUP_FLAGS_MAKE_ALTERNATE_URI,
     1:         nsIURIFixup::FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP |
     1:         nsIURIFixup::FIXUP_FLAGS_MAKE_ALTERNATE_URI
     1:     };
     1: 
 80467:     for (PRUint32 i = 0; i < ArrayLength(flags); ++i) {
     1:         rv = fixup->CreateFixupURI(aTargetURIStr, flags[i],
     1:                                    getter_AddRefs(target));
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:         rv = CheckLoadURIWithPrincipal(aPrincipal, target, aFlags);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CheckFunctionAccess(JSContext *aCx, void *aFunObj,
     1:                                              void *aTargetObj)
     1: {
     1:     // This check is called for event handlers
     1:     nsresult rv;
     1:     nsIPrincipal* subject =
     1:         GetFunctionObjectPrincipal(aCx, (JSObject *)aFunObj, nsnull, &rv);
     1: 
     1:     // If subject is null, get a principal from the function object's scope.
     1:     if (NS_SUCCEEDED(rv) && !subject)
     1:     {
     1: #ifdef DEBUG
     1:         {
 76811:             JS_ASSERT(JS_ObjectIsFunction(aCx, (JSObject *)aFunObj));
 83236:             JSFunction *fun = JS_GetObjectFunction((JSObject *)aFunObj);
     1:             JSScript *script = JS_GetFunctionScript(aCx, fun);
     1: 
     1:             NS_ASSERTION(!script, "Null principal for non-native function!");
     1:         }
     1: #endif
     1: 
 10939:         subject = doGetObjectPrincipal((JSObject*)aFunObj);
     1:     }
     1: 
     1:     if (!subject)
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     if (subject == mSystemPrincipal)
     1:         // This is the system principal: just allow access
     1:         return NS_OK;
     1: 
     1:     // Check if the principal the function was compiled under is
     1:     // allowed to execute scripts.
     1: 
 79445:     bool result;
     1:     rv = CanExecuteScripts(aCx, subject, &result);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
     1:     if (!result)
     1:       return NS_ERROR_DOM_SECURITY_ERR;
     1: 
     1:     /*
     1:     ** Get origin of subject and object and compare.
     1:     */
     1:     JSObject* obj = (JSObject*)aTargetObj;
 10939:     nsIPrincipal* object = doGetObjectPrincipal(obj);
     1: 
     1:     if (!object)
     1:         return NS_ERROR_FAILURE;        
     1: 
 79445:     bool subsumes;
 13269:     rv = subject->Subsumes(object, &subsumes);
 13269:     if (NS_SUCCEEDED(rv) && !subsumes) {
 13269:         rv = NS_ERROR_DOM_PROP_ACCESS_DENIED;
 13269:     }
 13269:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CanExecuteScripts(JSContext* cx,
     1:                                            nsIPrincipal *aPrincipal,
 79445:                                            bool *result)
     1: {
 80486:     *result = false; 
     1: 
     1:     if (aPrincipal == mSystemPrincipal)
     1:     {
     1:         // Even if JavaScript is disabled, we must still execute system scripts
 80486:         *result = true;
     1:         return NS_OK;
     1:     }
     1: 
     1:     //-- See if the current window allows JS execution
     1:     nsIScriptContext *scriptContext = GetScriptContext(cx);
     1:     if (!scriptContext) return NS_ERROR_FAILURE;
     1: 
     1:     if (!scriptContext->GetScriptsEnabled()) {
     1:         // No scripting on this context, folks
 80486:         *result = false;
     1:         return NS_OK;
     1:     }
     1:     
     1:     nsIScriptGlobalObject *sgo = scriptContext->GetGlobalObject();
     1: 
     1:     if (!sgo) {
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     // window can be null here if we're running with a non-DOM window
     1:     // as the script global (i.e. a XUL prototype document).
     1:     nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(sgo);
     1:     nsCOMPtr<nsIDocShell> docshell;
     1:     nsresult rv;
     1: 
     1:     if (window) {
     1:         docshell = window->GetDocShell();
     1:     }
     1: 
 46407:     if (docshell) {
 46407:       rv = docshell->GetCanExecuteScripts(result);
     1:       if (NS_FAILED(rv)) return rv;
 46407:       if (!*result) return NS_OK;
 46365:     }
     1: 
     1:     // OK, the docshell doesn't have script execution explicitly disabled.
     1:     // Check whether our URI is an "about:" URI that allows scripts.  If it is,
     1:     // we need to allow JS to run.  In this case, don't apply the JS enabled
     1:     // pref or policies.  On failures, just press on and don't do this special
     1:     // case.
     1:     nsCOMPtr<nsIURI> principalURI;
     1:     aPrincipal->GetURI(getter_AddRefs(principalURI));
  4337:     if (!principalURI) {
  4337:         // Broken principal of some sort.  Disallow.
 80486:         *result = false;
  4337:         return NS_ERROR_UNEXPECTED;
  4337:     }
  4337:         
 79445:     bool isAbout;
     1:     rv = principalURI->SchemeIs("about", &isAbout);
     1:     if (NS_SUCCEEDED(rv) && isAbout) {
     1:         nsCOMPtr<nsIAboutModule> module;
     1:         rv = NS_GetAboutModule(principalURI, getter_AddRefs(module));
     1:         if (NS_SUCCEEDED(rv)) {
     1:             PRUint32 flags;
     1:             rv = module->GetURIFlags(principalURI, &flags);
     1:             if (NS_SUCCEEDED(rv) &&
     1:                 (flags & nsIAboutModule::ALLOW_SCRIPT)) {
 80486:                 *result = true;
     1:                 return NS_OK;              
     1:             }
     1:         }
     1:     }
     1: 
     1:     *result = mIsJavaScriptEnabled;
     1:     if (!*result)
     1:         return NS_OK; // Do not run scripts
     1: 
     1:     //-- Check for a per-site policy
     1:     static const char jsPrefGroupName[] = "javascript";
     1:     ClassInfoData nameData(nsnull, jsPrefGroupName);
     1: 
     1:     SecurityLevel secLevel;
     1:     rv = LookupPolicy(aPrincipal, nameData, sEnabledID,
     1:                       nsIXPCSecurityManager::ACCESS_GET_PROPERTY, 
     1:                       nsnull, &secLevel);
     1:     if (NS_FAILED(rv) || secLevel.level == SCRIPT_SECURITY_NO_ACCESS)
     1:     {
 80486:         *result = false;
     1:         return rv;
     1:     }
     1: 
     1:     //-- Nobody vetoed, so allow the JS to run.
 80486:     *result = true;
     1:     return NS_OK;
     1: }
     1: 
     1: ///////////////// Principals ///////////////////////
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::GetSubjectPrincipal(nsIPrincipal **aSubjectPrincipal)
     1: {
     1:     nsresult rv;
     1:     *aSubjectPrincipal = doGetSubjectPrincipal(&rv);
     1:     if (NS_SUCCEEDED(rv))
     1:         NS_IF_ADDREF(*aSubjectPrincipal);
     1:     return rv;
     1: }
     1: 
     1: nsIPrincipal*
     1: nsScriptSecurityManager::doGetSubjectPrincipal(nsresult* rv)
     1: {
     1:     NS_PRECONDITION(rv, "Null out param");
     1:     JSContext *cx = GetCurrentJSContext();
     1:     if (!cx)
     1:     {
     1:         *rv = NS_OK;
     1:         return nsnull;
     1:     }
     1:     return GetSubjectPrincipal(cx, rv);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::GetSystemPrincipal(nsIPrincipal **result)
     1: {
     1:     NS_ADDREF(*result = mSystemPrincipal);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsScriptSecurityManager::SubjectPrincipalIsSystem(bool* aIsSystem)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aIsSystem);
 80486:     *aIsSystem = false;
     1: 
     1:     if (!mSystemPrincipal)
     1:         return NS_OK;
     1: 
     1:     nsCOMPtr<nsIPrincipal> subject;
     1:     nsresult rv = GetSubjectPrincipal(getter_AddRefs(subject));
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
     1:     if(!subject)
     1:     {
     1:         // No subject principal means no JS is running;
     1:         // this is the equivalent of system principal code
 80486:         *aIsSystem = true;
     1:         return NS_OK;
     1:     }
     1: 
     1:     return mSystemPrincipal->Equals(subject, aIsSystem);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::GetCertificatePrincipal(const nsACString& aCertFingerprint,
     1:                                                  const nsACString& aSubjectName,
     1:                                                  const nsACString& aPrettyName,
     1:                                                  nsISupports* aCertificate,
     1:                                                  nsIURI* aURI,
     1:                                                  nsIPrincipal **result)
     1: {
     1:     *result = nsnull;
     1:     
     1:     NS_ENSURE_ARG(!aCertFingerprint.IsEmpty() &&
     1:                   !aSubjectName.IsEmpty() &&
     1:                   aCertificate);
     1: 
     1:     return DoGetCertificatePrincipal(aCertFingerprint, aSubjectName,
 80486:                                      aPrettyName, aCertificate, aURI, true,
     1:                                      result);
     1: }
     1: 
     1: nsresult
     1: nsScriptSecurityManager::DoGetCertificatePrincipal(const nsACString& aCertFingerprint,
     1:                                                    const nsACString& aSubjectName,
     1:                                                    const nsACString& aPrettyName,
     1:                                                    nsISupports* aCertificate,
     1:                                                    nsIURI* aURI,
 79445:                                                    bool aModifyTable,
     1:                                                    nsIPrincipal **result)
     1: {
     1:     NS_ENSURE_ARG(!aCertFingerprint.IsEmpty());
     1:     
     1:     // Create a certificate principal out of the certificate ID
     1:     // and URI given to us.  We will use this principal to test
     1:     // equality when doing our hashtable lookups below.
     1:     nsRefPtr<nsPrincipal> certificate = new nsPrincipal();
     1:     if (!certificate)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     nsresult rv = certificate->Init(aCertFingerprint, aSubjectName,
     1:                                     aPrettyName, aCertificate, aURI);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Check to see if we already have this principal.
     1:     nsCOMPtr<nsIPrincipal> fromTable;
     1:     mPrincipals.Get(certificate, getter_AddRefs(fromTable));
     1:     if (fromTable) {
     1:         // Bingo.  We found the certificate in the table, which means
     1:         // that it has escalated privileges.
     1: 
     1:         if (aModifyTable) {
     1:             // Make sure this principal has names, so if we ever go to save it
     1:             // we'll save them.  If we get a name mismatch here we'll throw,
     1:             // but that's desirable.
  3233:             rv = static_cast<nsPrincipal*>
  3233:                             (static_cast<nsIPrincipal*>(fromTable))
     1:                 ->EnsureCertData(aSubjectName, aPrettyName, aCertificate);
     1:             if (NS_FAILED(rv)) {
     1:                 // We have a subject name mismatch for the same cert id.
     1:                 // Hand back the |certificate| object we created and don't give
     1:                 // it any rights from the table.
     1:                 NS_ADDREF(*result = certificate);
     1:                 return NS_OK;
     1:             }                
     1:         }
     1:         
     1:         if (!aURI) {
     1:             // We were asked to just get the base certificate, so output
     1:             // what we have in the table.
  3233:             certificate = static_cast<nsPrincipal*>
  3233:                                      (static_cast<nsIPrincipal*>
  3233:                                                  (fromTable));
     1:         } else {
     1:             // We found a certificate and now need to install a codebase
     1:             // on it.  We don't want to modify the principal in the hash
     1:             // table, so create a new principal and clone the pertinent
     1:             // things.
     1:             nsXPIDLCString prefName;
     1:             nsXPIDLCString id;
     1:             nsXPIDLCString subjectName;
     1:             nsXPIDLCString granted;
     1:             nsXPIDLCString denied;
 79445:             bool isTrusted;
     1:             rv = fromTable->GetPreferences(getter_Copies(prefName),
     1:                                            getter_Copies(id),
     1:                                            getter_Copies(subjectName),
     1:                                            getter_Copies(granted),
     1:                                            getter_Copies(denied),
     1:                                            &isTrusted);
     1:             // XXXbz assert something about subjectName and aSubjectName here?
     1:             if (NS_SUCCEEDED(rv)) {
     1:                 NS_ASSERTION(!isTrusted, "Shouldn't have isTrusted true here");
     1:                 
     1:                 certificate = new nsPrincipal();
     1:                 if (!certificate)
     1:                     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:                 rv = certificate->InitFromPersistent(prefName, id,
     1:                                                      subjectName, aPrettyName,
     1:                                                      granted, denied,
     1:                                                      aCertificate,
 80486:                                                      true, false);
     1:                 if (NS_FAILED(rv))
     1:                     return rv;
     1:                 
     1:                 certificate->SetURI(aURI);
     1:             }
     1:         }
     1:     }
     1: 
     1:     NS_ADDREF(*result = certificate);
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult
     1: nsScriptSecurityManager::CreateCodebasePrincipal(nsIURI* aURI, nsIPrincipal **result)
     1: {
     1:     // I _think_ it's safe to not create null principals here based on aURI.
     1:     // At least all the callers would do the right thing in those cases, as far
     1:     // as I can tell.  --bz
 38871: 
 38871:     nsCOMPtr<nsIURIWithPrincipal> uriPrinc = do_QueryInterface(aURI);
 38871:     if (uriPrinc) {
 38871:         nsCOMPtr<nsIPrincipal> principal;
 38871:         uriPrinc->GetPrincipal(getter_AddRefs(principal));
 38871:         if (!principal || principal == mSystemPrincipal) {
 38871:             return CallCreateInstance(NS_NULLPRINCIPAL_CONTRACTID, result);
 38871:         }
 38871: 
 38871:         principal.forget(result);
 38871: 
 38871:         return NS_OK;
 38871:     }
 38871: 
     1:     nsRefPtr<nsPrincipal> codebase = new nsPrincipal();
     1:     if (!codebase)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     nsresult rv = codebase->Init(EmptyCString(), EmptyCString(),
     1:                                  EmptyCString(), nsnull, aURI);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
     1:     NS_ADDREF(*result = codebase);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::GetCodebasePrincipal(nsIURI *aURI,
     1:                                               nsIPrincipal **result)
     1: {
  4337:     NS_ENSURE_ARG(aURI);
  4337:     
 79445:     bool inheritsPrincipal;
     1:     nsresult rv =
     1:         NS_URIChainHasFlags(aURI,
     1:                             nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
     1:                             &inheritsPrincipal);
     1:     if (NS_FAILED(rv) || inheritsPrincipal) {
     1:         return CallCreateInstance(NS_NULLPRINCIPAL_CONTRACTID, result);
     1:     }
     1:     
     1:     nsCOMPtr<nsIPrincipal> principal;
     1:     rv = CreateCodebasePrincipal(aURI, getter_AddRefs(principal));
     1:     if (NS_FAILED(rv)) return rv;
     1: 
     1:     if (mPrincipals.Count() > 0)
     1:     {
     1:         //-- Check to see if we already have this principal.
     1:         nsCOMPtr<nsIPrincipal> fromTable;
     1:         mPrincipals.Get(principal, getter_AddRefs(fromTable));
     1:         if (fromTable) {
     1:             // We found an existing codebase principal.  But it might have a
     1:             // generic codebase for this origin on it.  Install our particular
     1:             // codebase.
     1:             // XXXbz this is kinda similar to the code in
     1:             // GetCertificatePrincipal, but just ever so slightly different.
     1:             // Oh, well.
     1:             nsXPIDLCString prefName;
     1:             nsXPIDLCString id;
     1:             nsXPIDLCString subjectName;
     1:             nsXPIDLCString granted;
     1:             nsXPIDLCString denied;
 79445:             bool isTrusted;
     1:             rv = fromTable->GetPreferences(getter_Copies(prefName),
     1:                                            getter_Copies(id),
     1:                                            getter_Copies(subjectName),
     1:                                            getter_Copies(granted),
     1:                                            getter_Copies(denied),
     1:                                            &isTrusted);
     1:             if (NS_SUCCEEDED(rv)) {
     1:                 nsRefPtr<nsPrincipal> codebase = new nsPrincipal();
     1:                 if (!codebase)
     1:                     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:                 rv = codebase->InitFromPersistent(prefName, id,
     1:                                                   subjectName, EmptyCString(),
     1:                                                   granted, denied,
 80486:                                                   nsnull, false,
     1:                                                   isTrusted);
     1:                 if (NS_FAILED(rv))
     1:                     return rv;
     1:                 
     1:                 codebase->SetURI(aURI);
     1:                 principal = codebase;
     1:             }
     1: 
     1:         }
     1:     }
     1: 
     1:     NS_IF_ADDREF(*result = principal);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::GetPrincipalFromContext(JSContext *cx,
     1:                                                  nsIPrincipal **result)
     1: {
     1:     *result = nsnull;
     1: 
 42412:     nsIScriptContextPrincipal* scp =
 42412:         GetScriptContextPrincipalFromJSContext(cx);
 42412: 
 42412:     if (!scp)
     1:     {
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
 42412:     nsIScriptObjectPrincipal* globalData = scp->GetObjectPrincipal();
     1:     if (globalData)
     1:         NS_IF_ADDREF(*result = globalData->GetPrincipal());
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: // static
     1: nsIPrincipal*
 93548: nsScriptSecurityManager::GetScriptPrincipal(JSScript *script,
     1:                                             nsresult* rv)
     1: {
     1:     NS_PRECONDITION(rv, "Null out param");
     1:     *rv = NS_OK;
     1:     if (!script)
     1:     {
     1:         return nsnull;
     1:     }
 93548:     JSPrincipals *jsp = JS_GetScriptPrincipals(script);
     1:     if (!jsp) {
     1:         *rv = NS_ERROR_FAILURE;
 18821:         NS_ERROR("Script compiled without principals!");
     1:         return nsnull;
     1:     }
 91900:     return nsJSPrincipals::get(jsp);
     1: }
     1: 
     1: // static
     1: nsIPrincipal*
     1: nsScriptSecurityManager::GetFunctionObjectPrincipal(JSContext *cx,
     1:                                                     JSObject *obj,
     1:                                                     JSStackFrame *fp,
     1:                                                     nsresult *rv)
     1: {
     1:     NS_PRECONDITION(rv, "Null out param");
 59842: 
 59842:     *rv = NS_OK;
 59842: 
 29162:     if (!JS_ObjectIsFunction(cx, obj))
 29162:     {
 29162:         // Protect against pseudo-functions (like SJOWs).
 29162:         nsIPrincipal *result = doGetObjectPrincipal(obj);
 29162:         if (!result)
 29162:             *rv = NS_ERROR_FAILURE;
 29162:         return result;
 29162:     }
 29162: 
 83236:     JSFunction *fun = JS_GetObjectFunction(obj);
     1:     JSScript *script = JS_GetFunctionScript(cx, fun);
     1: 
     1:     if (!script)
     1:     {
     1:         // A native function: skip it in order to find its scripted caller.
     1:         return nsnull;
     1:     }
     1: 
     1:     JSScript *frameScript = fp ? JS_GetFrameScript(cx, fp) : nsnull;
     1: 
     1:     if (frameScript && frameScript != script)
     1:     {
     1:         // There is a frame script, and it's different from the
     1:         // function script. In this case we're dealing with either
     1:         // an eval or a Script object, and in these cases the
     1:         // principal we want is in the frame's script, not in the
     1:         // function's script. The function's script is where the
     1:         // eval-calling code came from, not where the eval or new
     1:         // Script object came from, and we want the principal of
     1:         // the eval function object or new Script object.
     1: 
 13691:         script = frameScript;
 13691:     }
 83256:     else if (!js::IsOriginalScriptFunction(fun))
 13691:     {
 13691:         // Here, obj is a cloned function object.  In this case, the
 13691:         // clone's prototype may have been precompiled from brutally
 13691:         // shared chrome, or else it is a lambda or nested function.
 13691:         // The general case here is a function compiled against a
 13691:         // different scope than the one it is parented by at runtime,
 13691:         // hence the creation of a clone to carry the correct scope
 13691:         // chain linkage.
 13691:         //
     1:         // Since principals follow scope, we must get the object
 13691:         // principal from the clone's scope chain. There are no
     1:         // reliable principals compiled into the function itself.
     1: 
 10939:         nsIPrincipal *result = doGetObjectPrincipal(obj);
     1:         if (!result)
     1:             *rv = NS_ERROR_FAILURE;
     1:         return result;
     1:     }
     1: 
 93548:     return GetScriptPrincipal(script, rv);
 13691: }
 13691: 
     1: nsIPrincipal*
     1: nsScriptSecurityManager::GetFramePrincipal(JSContext *cx,
     1:                                            JSStackFrame *fp,
     1:                                            nsresult *rv)
     1: {
     1:     NS_PRECONDITION(rv, "Null out param");
     1:     JSObject *obj = JS_GetFrameFunctionObject(cx, fp);
     1:     if (!obj)
     1:     {
     1:         // Must be in a top-level script. Get principal from the script.
     1:         JSScript *script = JS_GetFrameScript(cx, fp);
 93548:         return GetScriptPrincipal(script, rv);
     1:     }
     1: 
     1:     nsIPrincipal* result = GetFunctionObjectPrincipal(cx, obj, fp, rv);
     1: 
     1: #ifdef DEBUG
     1:     if (NS_SUCCEEDED(*rv) && !result)
     1:     {
 83236:         JSFunction *fun = JS_GetObjectFunction(obj);
     1:         JSScript *script = JS_GetFunctionScript(cx, fun);
     1: 
     1:         NS_ASSERTION(!script, "Null principal for non-native function!");
     1:     }
     1: #endif
     1: 
     1:     return result;
     1: }
     1: 
     1: nsIPrincipal*
     1: nsScriptSecurityManager::GetPrincipalAndFrame(JSContext *cx,
     1:                                               JSStackFrame **frameResult,
     1:                                               nsresult* rv)
     1: {
     1:     NS_PRECONDITION(rv, "Null out param");
     1:     //-- If there's no principal on the stack, look at the global object
     1:     //   and return the innermost frame for annotations.
     1:     *rv = NS_OK;
 33308: 
     1:     if (cx)
     1:     {
 33308:         JSStackFrame *target = nsnull;
 33308:         nsIPrincipal *targetPrincipal = nsnull;
 33308:         for (ContextPrincipal *cp = mContextPrincipals; cp; cp = cp->mNext)
 33308:         {
 33308:             if (cp->mCx == cx)
 33308:             {
 33308:                 target = cp->mFp;
 33308:                 targetPrincipal = cp->mPrincipal;
 33308:                 break;
 33308:             }
 33308:         }
 33308: 
 33308:         // Get principals from innermost JavaScript frame.
     1:         JSStackFrame *fp = nsnull; // tell JS_FrameIterator to start at innermost
     1:         for (fp = JS_FrameIterator(cx, &fp); fp; fp = JS_FrameIterator(cx, &fp))
     1:         {
 33308:             if (fp == target)
 33308:                 break;
     1:             nsIPrincipal* result = GetFramePrincipal(cx, fp, rv);
     1:             if (result)
     1:             {
     1:                 NS_ASSERTION(NS_SUCCEEDED(*rv), "Weird return");
     1:                 *frameResult = fp;
     1:                 return result;
     1:             }
     1:         }
     1: 
 33308:         // If targetPrincipal is non-null, then it means that someone wants to
 33308:         // clamp the principals on this context to this principal. Note that
 33308:         // fp might not equal target here (fp might be null) because someone
 33308:         // could have set aside the frame chain in the meantime.
 33308:         if (targetPrincipal)
 33308:         {
 33308:             if (fp && fp == target)
 33308:             {
 33308:                 *frameResult = fp;
 33308:             }
 33308:             else
 33308:             {
 33308:                 JSStackFrame *inner = nsnull;
 33308:                 *frameResult = JS_FrameIterator(cx, &inner);
 33308:             }
 33308: 
 33308:             return targetPrincipal;
 33308:         }
 33308: 
 42412:         nsIScriptContextPrincipal* scp =
 42412:             GetScriptContextPrincipalFromJSContext(cx);
 42412:         if (scp)
     1:         {
 42412:             nsIScriptObjectPrincipal* globalData = scp->GetObjectPrincipal();
     1:             if (!globalData)
     1:             {
     1:                 *rv = NS_ERROR_FAILURE;
     1:                 return nsnull;
     1:             }
     1: 
     1:             // Note that we're not in a loop or anything, and nothing comes
     1:             // after this point in the function, so we can just return here.
     1:             nsIPrincipal* result = globalData->GetPrincipal();
     1:             if (result)
     1:             {
     1:                 JSStackFrame *inner = nsnull;
     1:                 *frameResult = JS_FrameIterator(cx, &inner);
     1:                 return result;
     1:             }
     1:         }
     1:     }
     1: 
     1:     return nsnull;
     1: }
     1: 
     1: nsIPrincipal*
     1: nsScriptSecurityManager::GetSubjectPrincipal(JSContext *cx,
     1:                                              nsresult* rv)
     1: {
     1:     NS_PRECONDITION(rv, "Null out param");
     1:     JSStackFrame *fp;
     1:     return GetPrincipalAndFrame(cx, &fp, rv);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::GetObjectPrincipal(JSContext *aCx, JSObject *aObj,
     1:                                             nsIPrincipal **result)
     1: {
 10939:     *result = doGetObjectPrincipal(aObj);
     1:     if (!*result)
     1:         return NS_ERROR_FAILURE;
     1:     NS_ADDREF(*result);
     1:     return NS_OK;
     1: }
     1: 
     1: // static
     1: nsIPrincipal*
 10939: nsScriptSecurityManager::doGetObjectPrincipal(JSObject *aObj
  8990: #ifdef DEBUG
 79445:                                               , bool aAllowShortCircuit
  8990: #endif
  8990:                                               )
     1: {
 10942:     NS_ASSERTION(aObj, "Bad call to doGetObjectPrincipal()!");
     1:     nsIPrincipal* result = nsnull;
     1: 
     1: #ifdef DEBUG
     1:     JSObject* origObj = aObj;
     1: #endif
     1:     
 79734:     js::Class *jsClass = js::GetObjectClass(aObj);
  8990: 
  8990:     // A common case seen in this code is that we enter this function
  8990:     // with aObj being a Function object, whose parent is a Call
  8990:     // object. Neither of those have object principals, so we can skip
  8990:     // those objects here before we enter the below loop. That way we
  8990:     // avoid wasting time checking properties of their classes etc in
  8990:     // the loop.
  8990: 
 77817:     if (jsClass == &js::FunctionClass) {
 79734:         aObj = js::GetObjectParent(aObj);
  8990: 
  8990:         if (!aObj)
  8990:             return nsnull;
  8990: 
 79734:         jsClass = js::GetObjectClass(aObj);
  8990: 
 77817:         if (jsClass == &js::CallClass) {
 83239:             aObj = js::GetObjectParentMaybeScope(aObj);
  8990: 
  8990:             if (!aObj)
  8990:                 return nsnull;
  8990: 
 79734:             jsClass = js::GetObjectClass(aObj);
  8990:         }
  8990:     }
  8990: 
  8990:     do {
  8990:         // Note: jsClass is set before this loop, and also at the
  8990:         // *end* of this loop.
  8990:         
 57854:         if (IS_WRAPPER_CLASS(jsClass)) {
 30001:             result = sXPConnect->GetPrincipal(aObj,
  8990: #ifdef DEBUG
 30001:                                               aAllowShortCircuit
 30001: #else
 80486:                                               true
  8990: #endif
 30001:                                               );
 10834:             if (result) {
  8990:                 break;
  8990:             }
 94512:         } else {
 94512:             nsISupports *priv;
 94512:             if (!(~jsClass->flags & (JSCLASS_HAS_PRIVATE |
  8990:                                      JSCLASS_PRIVATE_IS_NSISUPPORTS))) {
 94512:                 priv = (nsISupports *) js::GetObjectPrivate(aObj);
 94512:             } else if ((jsClass->flags & JSCLASS_IS_DOMJSCLASS) &&
 97422:                        DOMJSClass::FromJSClass(jsClass)->mDOMObjectIsISupports) {
 97422:                 priv = UnwrapDOMObject<nsISupports>(aObj, jsClass);
 94512:             } else {
 94512:                 priv = nsnull;
 94512:             }
     1: 
  8990: #ifdef DEBUG
  8990:             if (aAllowShortCircuit) {
     1:                 nsCOMPtr<nsIXPConnectWrappedNative> xpcWrapper =
     1:                     do_QueryInterface(priv);
     1: 
  9603:                 NS_ASSERTION(!xpcWrapper ||
  9603:                              !strcmp(jsClass->name, "XPCNativeWrapper"),
  8990:                              "Uh, an nsIXPConnectWrappedNative with the "
  8990:                              "wrong JSClass or getObjectOps hooks!");
  8990:             }
  8990: #endif
  8990: 
  8990:             nsCOMPtr<nsIScriptObjectPrincipal> objPrin =
  8990:                 do_QueryInterface(priv);
  8990: 
  8990:             if (objPrin) {
     1:                 result = objPrin->GetPrincipal();
  8990: 
  8990:                 if (result) {
     1:                     break;
     1:                 }
     1:             }
  8990:         }
     1: 
 83239:         aObj = js::GetObjectParentMaybeScope(aObj);
  8990: 
  8990:         if (!aObj)
  8990:             break;
  8990: 
 79734:         jsClass = js::GetObjectClass(aObj);
  8990:     } while (1);
     1: 
 55617: #ifdef DEBUG
 55617:     if (aAllowShortCircuit) {
 80486:         nsIPrincipal *principal = doGetObjectPrincipal(origObj, false);
 55617: 
 90436:         // Because of inner window reuse, we can have objects with one principal
 90436:         // living in a scope with a different (but same-origin) principal. So
 90436:         // just check same-origin here.
 90436:         NS_ASSERTION(NS_SUCCEEDED(CheckSameOriginPrincipal(result, principal)),
     1:                      "Principal mismatch.  Not good");
 55617:     }
 55617: #endif
     1: 
     1:     return result;
     1: }
     1: 
     1: ///////////////// Capabilities API /////////////////////
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::IsCapabilityEnabled(const char *capability,
 79445:                                              bool *result)
     1: {
     1:     nsresult rv;
     1:     JSStackFrame *fp = nsnull;
     1:     JSContext *cx = GetCurrentJSContext();
     1:     fp = cx ? JS_FrameIterator(cx, &fp) : nsnull;
 60475: 
 60475:     JSStackFrame *target = nsnull;
 60475:     nsIPrincipal *targetPrincipal = nsnull;
 60475:     for (ContextPrincipal *cp = mContextPrincipals; cp; cp = cp->mNext)
 60475:     {
 60475:         if (cp->mCx == cx)
 60475:         {
 60475:             target = cp->mFp;
 60475:             targetPrincipal = cp->mPrincipal;
 60475:             break;
 60475:         }
 60475:     }
 60475: 
     1:     if (!fp)
     1:     {
 60475:         // No script code on stack. If we had a principal pushed for this
 60475:         // context and fp is null, then we use that principal. Otherwise, we
 60475:         // don't have enough information and have to allow execution.
 60475: 
 60475:         *result = (targetPrincipal && !target)
 60475:                   ? (targetPrincipal == mSystemPrincipal)
 80486:                   : true;
 60475: 
     1:         return NS_OK;
     1:     }
 60475: 
 80486:     *result = false;
     1:     nsIPrincipal* previousPrincipal = nsnull;
     1:     do
     1:     {
     1:         nsIPrincipal* principal = GetFramePrincipal(cx, fp, &rv);
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1:         if (!principal)
     1:             continue;
     1:         // If caller has a different principal, stop looking up the stack.
     1:         if(previousPrincipal)
     1:         {
 79445:             bool isEqual = false;
     1:             if(NS_FAILED(previousPrincipal->Equals(principal, &isEqual)) || !isEqual)
     1:                 break;
     1:         }
     1:         else
     1:             previousPrincipal = principal;
     1: 
     1:         // First check if the principal is even able to enable the
     1:         // given capability. If not, don't look any further.
     1:         PRInt16 canEnable;
     1:         rv = principal->CanEnableCapability(capability, &canEnable);
     1:         if (NS_FAILED(rv)) return rv;
     1:         if (canEnable != nsIPrincipal::ENABLE_GRANTED &&
     1:             canEnable != nsIPrincipal::ENABLE_WITH_USER_PERMISSION)
     1:             return NS_OK;
     1: 
     1:         // Now see if the capability is enabled.
     1:         void *annotation = JS_GetFrameAnnotation(cx, fp);
     1:         rv = principal->IsCapabilityEnabled(capability, annotation, result);
     1:         if (NS_FAILED(rv)) return rv;
     1:         if (*result)
     1:             return NS_OK;
 69704: 
 69704:         // Capabilities do not extend to calls into C/C++ and then back into
 69704:         // the JS engine via JS_EvaluateScript or similar APIs.
 69704:         if (JS_IsGlobalFrame(cx, fp))
 69704:             break;
 74465:     } while (fp != target && (fp = JS_FrameIterator(cx, &fp)) != nsnull);
     1: 
     1:     if (!previousPrincipal)
     1:     {
     1:         // No principals on the stack, all native code.  Allow
     1:         // execution if the subject principal is the system principal.
     1: 
     1:         return SubjectPrincipalIsSystem(result);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: void
     1: nsScriptSecurityManager::FormatCapabilityString(nsAString& aCapability)
     1: {
     1:     nsAutoString newcaps;
     1:     nsAutoString rawcap;
     1:     NS_NAMED_LITERAL_STRING(capdesc, "capdesc.");
     1:     PRInt32 pos;
     1:     PRInt32 index = kNotFound;
     1:     nsresult rv;
     1: 
     1:     NS_ASSERTION(kNotFound == -1, "Basic constant changed, algorithm broken!");
     1: 
     1:     do {
     1:         pos = index+1;
     1:         index = aCapability.FindChar(' ', pos);
     1:         rawcap = Substring(aCapability, pos,
     1:                            (index == kNotFound) ? index : index - pos);
     1: 
     1:         nsXPIDLString capstr;
     1:         rv = sStrBundle->GetStringFromName(
     1:                             nsPromiseFlatString(capdesc+rawcap).get(),
     1:                             getter_Copies(capstr));
     1:         if (NS_SUCCEEDED(rv))
     1:             newcaps += capstr;
     1:         else
     1:         {
     1:             nsXPIDLString extensionCap;
     1:             const PRUnichar* formatArgs[] = { rawcap.get() };
     1:             rv = sStrBundle->FormatStringFromName(
     1:                                 NS_LITERAL_STRING("ExtensionCapability").get(),
     1:                                 formatArgs,
 80467:                                 ArrayLength(formatArgs),
     1:                                 getter_Copies(extensionCap));
     1:             if (NS_SUCCEEDED(rv))
     1:                 newcaps += extensionCap;
     1:             else
     1:                 newcaps += rawcap;
     1:         }
     1: 
     1:         newcaps += NS_LITERAL_STRING("\n");
     1:     } while (index != kNotFound);
     1: 
     1:     aCapability = newcaps;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::RequestCapability(nsIPrincipal* aPrincipal,
     1:                                            const char *capability, PRInt16* canEnable)
     1: {
     1:     if (NS_FAILED(aPrincipal->CanEnableCapability(capability, canEnable)))
     1:         return NS_ERROR_FAILURE;
 97395:     // The confirm dialog is no longer supported. All of this stuff is going away
 97395:     // real soon now anyhow.
     1:     if (*canEnable == nsIPrincipal::ENABLE_WITH_USER_PERMISSION)
     1:         *canEnable = nsIPrincipal::ENABLE_DENIED;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::EnableCapability(const char *capability)
     1: {
     1:     JSContext *cx = GetCurrentJSContext();
     1:     JSStackFrame *fp;
     1: 
     1:     //-- Error checks for capability string length (200)
     1:     if(PL_strlen(capability)>200)
     1:     {
     1:         static const char msg[] = "Capability name too long";
     1:         SetPendingException(cx, msg);
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     //-- Check capability string for valid characters
     1:     //
     1:     //   Logically we might have wanted this in nsPrincipal, but performance
     1:     //   worries dictate it can't go in IsCapabilityEnabled() and we may have
     1:     //   to show the capability on a dialog before we call the principal's
     1:     //   EnableCapability().
     1:     //
     1:     //   We don't need to validate the capability string on the other APIs
     1:     //   available to web content. Without the ability to enable junk then
     1:     //   isPrivilegeEnabled, disablePrivilege, and revertPrivilege all do
     1:     //   the right thing (effectively nothing) when passed unallowed chars.
     1:     for (const char *ch = capability; *ch; ++ch)
     1:     {
     1:         if (!NS_IS_ALPHA(*ch) && *ch != ' ' && !NS_IS_DIGIT(*ch)
     1:             && *ch != '_' && *ch != '-' && *ch != '.')
     1:         {
     1:             static const char msg[] = "Invalid character in capability name";
     1:             SetPendingException(cx, msg);
     1:             return NS_ERROR_FAILURE;
     1:         }
     1:     }
     1: 
     1:     nsresult rv;
     1:     nsIPrincipal* principal = GetPrincipalAndFrame(cx, &fp, &rv);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1:     if (!principal)
     1:         return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:     void *annotation = JS_GetFrameAnnotation(cx, fp);
 79445:     bool enabled;
     1:     if (NS_FAILED(principal->IsCapabilityEnabled(capability, annotation,
     1:                                                  &enabled)))
     1:         return NS_ERROR_FAILURE;
     1:     if (enabled)
     1:         return NS_OK;
     1: 
     1:     PRInt16 canEnable;
     1:     if (NS_FAILED(RequestCapability(principal, capability, &canEnable)))
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     if (canEnable != nsIPrincipal::ENABLE_GRANTED)
     1:     {
 13284:         nsCAutoString val;
 79445:         bool hasCert;
     1:         nsresult rv;
     1:         principal->GetHasCertificate(&hasCert);
     1:         if (hasCert)
     1:             rv = principal->GetPrettyName(val);
     1:         else
 13284:             rv = GetPrincipalDomainOrigin(principal, val);
     1: 
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1: 
     1:         NS_ConvertUTF8toUTF16 location(val);
     1:         NS_ConvertUTF8toUTF16 cap(capability);
     1:         const PRUnichar *formatStrings[] = { location.get(), cap.get() };
     1: 
     1:         nsXPIDLString message;
     1:         rv = sStrBundle->FormatStringFromName(NS_LITERAL_STRING("EnableCapabilityDenied").get(),
     1:                                               formatStrings,
 80467:                                               ArrayLength(formatStrings),
     1:                                               getter_Copies(message));
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1: 
     1:         SetPendingException(cx, message.get());
     1: 
     1:         return NS_ERROR_FAILURE; // XXX better error code?
     1:     }
     1:     if (NS_FAILED(principal->EnableCapability(capability, &annotation)))
     1:         return NS_ERROR_FAILURE;
     1:     JS_SetFrameAnnotation(cx, fp, annotation);
     1:     return NS_OK;
     1: }
     1: 
     1: ////////////////////////////////////////////////
     1: // Methods implementing nsIXPCSecurityManager //
     1: ////////////////////////////////////////////////
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CanCreateWrapper(JSContext *cx,
     1:                                           const nsIID &aIID,
     1:                                           nsISupports *aObj,
     1:                                           nsIClassInfo *aClassInfo,
     1:                                           void **aPolicy)
     1: {
     1: #ifdef DEBUG_CAPS_CanCreateWrapper
     1:     char* iidStr = aIID.ToString();
     1:     printf("### CanCreateWrapper(%s) ", iidStr);
 30833:     NS_Free(iidStr);
     1: #endif
     1: // XXX Special case for nsIXPCException ?
     1:     ClassInfoData objClassInfo = ClassInfoData(aClassInfo, nsnull);
     1:     if (objClassInfo.IsDOMClass())
     1:     {
     1: #ifdef DEBUG_CAPS_CanCreateWrapper
     1:         printf("DOM class - GRANTED.\n");
     1: #endif
     1:         return NS_OK;
     1:     }
     1: 
     1:     //--See if the object advertises a non-default level of access
     1:     //  using nsISecurityCheckedComponent
     1:     nsCOMPtr<nsISecurityCheckedComponent> checkedComponent =
     1:         do_QueryInterface(aObj);
     1: 
     1:     nsXPIDLCString objectSecurityLevel;
     1:     if (checkedComponent)
     1:         checkedComponent->CanCreateWrapper((nsIID *)&aIID, getter_Copies(objectSecurityLevel));
     1: 
 31205:     nsresult rv = CheckXPCPermissions(cx, aObj, nsnull, nsnull, objectSecurityLevel);
     1:     if (NS_FAILED(rv))
     1:     {
     1:         //-- Access denied, report an error
 16268:         NS_ConvertUTF8toUTF16 strName("CreateWrapperDenied");
 16268:         nsCAutoString origin;
 16268:         nsresult rv2;
 16268:         nsIPrincipal* subjectPrincipal = doGetSubjectPrincipal(&rv2);
 16268:         if (NS_SUCCEEDED(rv2) && subjectPrincipal) {
 16268:             GetPrincipalDomainOrigin(subjectPrincipal, origin);
 16268:         }
 16268:         NS_ConvertUTF8toUTF16 originUnicode(origin);
     1:         NS_ConvertUTF8toUTF16 className(objClassInfo.GetName());
 16268:         const PRUnichar* formatStrings[] = {
 16268:             className.get(),
 16268:             originUnicode.get()
 16268:         };
 80467:         PRUint32 length = ArrayLength(formatStrings);
 16268:         if (originUnicode.IsEmpty()) {
 16268:             --length;
 16268:         } else {
 16268:             strName.AppendLiteral("ForOrigin");
 16268:         }
     1:         nsXPIDLString errorMsg;
     1:         // We need to keep our existing failure rv and not override it
     1:         // with a likely success code from the following string bundle
     1:         // call in order to throw the correct security exception later.
 16268:         rv2 = sStrBundle->FormatStringFromName(strName.get(),
     1:                                                formatStrings,
 16268:                                                length,
     1:                                                getter_Copies(errorMsg));
     1:         NS_ENSURE_SUCCESS(rv2, rv2);
     1: 
     1:         SetPendingException(cx, errorMsg.get());
     1: 
     1: #ifdef DEBUG_CAPS_CanCreateWrapper
     1:         printf("DENIED.\n");
     1:     }
     1:     else
     1:     {
     1:         printf("GRANTED.\n");
     1: #endif
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CanCreateInstance(JSContext *cx,
     1:                                            const nsCID &aCID)
     1: {
     1: #ifdef DEBUG_CAPS_CanCreateInstance
     1:     char* cidStr = aCID.ToString();
     1:     printf("### CanCreateInstance(%s) ", cidStr);
 30833:     NS_Free(cidStr);
     1: #endif
     1: 
 31205:     nsresult rv = CheckXPCPermissions(nsnull, nsnull, nsnull, nsnull, nsnull);
     1:     if (NS_FAILED(rv))
     1:     {
     1:         //-- Access denied, report an error
     1:         nsCAutoString errorMsg("Permission denied to create instance of class. CID=");
 10204:         char cidStr[NSID_LENGTH];
 10204:         aCID.ToProvidedString(cidStr);
     1:         errorMsg.Append(cidStr);
     1:         SetPendingException(cx, errorMsg.get());
     1: 
     1: #ifdef DEBUG_CAPS_CanCreateInstance
     1:         printf("DENIED\n");
     1:     }
     1:     else
     1:     {
     1:         printf("GRANTED\n");
     1: #endif
     1:     }
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CanGetService(JSContext *cx,
     1:                                        const nsCID &aCID)
     1: {
     1: #ifdef DEBUG_CAPS_CanGetService
     1:     char* cidStr = aCID.ToString();
     1:     printf("### CanGetService(%s) ", cidStr);
 30833:     NS_Free(cidStr);
     1: #endif
     1: 
 31205:     nsresult rv = CheckXPCPermissions(nsnull, nsnull, nsnull, nsnull, nsnull);
     1:     if (NS_FAILED(rv))
     1:     {
     1:         //-- Access denied, report an error
     1:         nsCAutoString errorMsg("Permission denied to get service. CID=");
 10204:         char cidStr[NSID_LENGTH];
 10204:         aCID.ToProvidedString(cidStr);
     1:         errorMsg.Append(cidStr);
     1:         SetPendingException(cx, errorMsg.get());
     1: 
     1: #ifdef DEBUG_CAPS_CanGetService
     1:         printf("DENIED\n");
     1:     }
     1:     else
     1:     {
     1:         printf("GRANTED\n");
     1: #endif
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::CanAccess(PRUint32 aAction,
 10286:                                    nsAXPCNativeCallContext* aCallContext,
     1:                                    JSContext* cx,
     1:                                    JSObject* aJSObject,
     1:                                    nsISupports* aObj,
     1:                                    nsIClassInfo* aClassInfo,
 48470:                                    jsid aPropertyName,
     1:                                    void** aPolicy)
     1: {
     1:     return CheckPropertyAccessImpl(aAction, aCallContext, cx,
 14480:                                    aJSObject, aObj, nsnull, aClassInfo,
     1:                                    nsnull, aPropertyName, aPolicy);
     1: }
     1: 
     1: nsresult
 31205: nsScriptSecurityManager::CheckXPCPermissions(JSContext* cx,
 31205:                                              nsISupports* aObj, JSObject* aJSObject,
 28292:                                              nsIPrincipal* aSubjectPrincipal,
     1:                                              const char* aObjectSecurityLevel)
     1: {
     1:     //-- Check for the all-powerful UniversalXPConnect privilege
 79445:     bool ok = false;
     1:     if (NS_SUCCEEDED(IsCapabilityEnabled("UniversalXPConnect", &ok)) && ok)
     1:         return NS_OK;
     1: 
     1:     //-- If the object implements nsISecurityCheckedComponent, it has a non-default policy.
     1:     if (aObjectSecurityLevel)
     1:     {
     1:         if (PL_strcasecmp(aObjectSecurityLevel, "allAccess") == 0)
     1:             return NS_OK;
 31205:         if (cx && PL_strcasecmp(aObjectSecurityLevel, "sameOrigin") == 0)
 31205:         {
 31205:             nsresult rv;
 31205:             if (!aJSObject)
 31205:             {
 31205:                 nsCOMPtr<nsIXPConnectWrappedJS> xpcwrappedjs =
 31205:                     do_QueryInterface(aObj);
 31205:                 if (xpcwrappedjs)
 31205:                 {
 31205:                     rv = xpcwrappedjs->GetJSObject(&aJSObject);
 31205:                     NS_ENSURE_SUCCESS(rv, rv);
 31205:                 }
 31205:             }
 31205: 
 31205:             if (!aSubjectPrincipal)
 31205:             {
 31205:                 // No subject principal passed in. Compute it.
 31205:                 aSubjectPrincipal = GetSubjectPrincipal(cx, &rv);
 31205:                 NS_ENSURE_SUCCESS(rv, rv);
 31205:             }
 31205:             if (aSubjectPrincipal && aJSObject)
 28292:             {
 28292:                 nsIPrincipal* objectPrincipal = doGetObjectPrincipal(aJSObject);
 28292: 
 28292:                 // Only do anything if we have both a subject and object
 28292:                 // principal.
 28292:                 if (objectPrincipal)
 28292:                 {
 79445:                     bool subsumes;
 31205:                     rv = aSubjectPrincipal->Subsumes(objectPrincipal, &subsumes);
 28292:                     NS_ENSURE_SUCCESS(rv, rv);
 28292:                     if (subsumes)
 28292:                         return NS_OK;
 28292:                 }
 28292:             }
 31205:         }
     1:         else if (PL_strcasecmp(aObjectSecurityLevel, "noAccess") != 0)
     1:         {
 79445:             bool canAccess = false;
     1:             if (NS_SUCCEEDED(IsCapabilityEnabled(aObjectSecurityLevel, &canAccess)) &&
     1:                 canAccess)
     1:                 return NS_OK;
     1:         }
     1:     }
     1: 
     1:     //-- Access tests failed
     1:     return NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED;
     1: }
     1: 
     1: /////////////////////////////////////////////
     1: // Method implementing nsIChannelEventSink //
     1: /////////////////////////////////////////////
     1: NS_IMETHODIMP
 48889: nsScriptSecurityManager::AsyncOnChannelRedirect(nsIChannel* oldChannel, 
     1:                                                 nsIChannel* newChannel,
 48889:                                                 PRUint32 redirFlags,
 48889:                                                 nsIAsyncVerifyRedirectCallback *cb)
     1: {
     1:     nsCOMPtr<nsIPrincipal> oldPrincipal;
     1:     GetChannelPrincipal(oldChannel, getter_AddRefs(oldPrincipal));
     1: 
     1:     nsCOMPtr<nsIURI> newURI;
     1:     newChannel->GetURI(getter_AddRefs(newURI));
 21937:     nsCOMPtr<nsIURI> newOriginalURI;
 21937:     newChannel->GetOriginalURI(getter_AddRefs(newOriginalURI));
 21937: 
 21937:     NS_ENSURE_STATE(oldPrincipal && newURI && newOriginalURI);
     1: 
     1:     const PRUint32 flags =
     1:         nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT |
     1:         nsIScriptSecurityManager::DISALLOW_SCRIPT;
 21937:     nsresult rv = CheckLoadURIWithPrincipal(oldPrincipal, newURI, flags);
 21937:     if (NS_SUCCEEDED(rv) && newOriginalURI != newURI) {
 21937:         rv = CheckLoadURIWithPrincipal(oldPrincipal, newOriginalURI, flags);
 21937:     }
 48889: 
 48889:     if (NS_FAILED(rv))
 21937:         return rv;
 48889: 
 48889:     cb->OnRedirectVerifyCallback(NS_OK);
 48889:     return NS_OK;
     1: }
     1: 
     1: 
     1: /////////////////////////////////////
     1: // Method implementing nsIObserver //
     1: /////////////////////////////////////
 72017: const char sJSEnabledPrefName[] = "javascript.enabled";
 72017: const char sFileOriginPolicyPrefName[] =
 72017:     "security.fileuri.strict_origin_policy";
     1: static const char sPrincipalPrefix[] = "capability.principal";
     1: static const char sPolicyPrefix[] = "capability.policy.";
     1: 
 72017: static const char* kObservedPrefs[] = {
 72017:   sJSEnabledPrefName,
 72017:   sFileOriginPolicyPrefName,
 72017:   sPolicyPrefix,
 72017:   sPrincipalPrefix,
 72017:   nsnull
 72017: };
 72017: 
 72017: 
     1: NS_IMETHODIMP
     1: nsScriptSecurityManager::Observe(nsISupports* aObject, const char* aTopic,
     1:                                  const PRUnichar* aMessage)
     1: {
     1:     nsresult rv = NS_OK;
     1:     NS_ConvertUTF16toUTF8 messageStr(aMessage);
     1:     const char *message = messageStr.get();
     1: 
     1:     static const char jsPrefix[] = "javascript.";
  5766:     static const char securityPrefix[] = "security.";
  5766:     if ((PL_strncmp(message, jsPrefix, sizeof(jsPrefix)-1) == 0) ||
  5766:         (PL_strncmp(message, securityPrefix, sizeof(securityPrefix)-1) == 0) )
  5766:     {
  5766:         ScriptSecurityPrefChanged();
  5766:     }
  5766:     else if (PL_strncmp(message, sPolicyPrefix, sizeof(sPolicyPrefix)-1) == 0)
  5766:     {
  5766:         // This will force re-initialization of the pref table
 80486:         mPolicyPrefsChanged = true;
  5766:     }
     1:     else if ((PL_strncmp(message, sPrincipalPrefix, sizeof(sPrincipalPrefix)-1) == 0) &&
     1:              !mIsWritingPrefs)
     1:     {
     1:         static const char id[] = "id";
     1:         char* lastDot = PL_strrchr(message, '.');
     1:         //-- This check makes sure the string copy below doesn't overwrite its bounds
     1:         if(PL_strlen(lastDot) >= sizeof(id))
     1:         {
     1:             PL_strcpy(lastDot + 1, id);
     1:             const char** idPrefArray = (const char**)&message;
 43345:             rv = InitPrincipals(1, idPrefArray);
     1:         }
     1:     }
     1:     return rv;
     1: }
     1: 
     1: /////////////////////////////////////////////
     1: // Constructor, Destructor, Initialization //
     1: /////////////////////////////////////////////
     1: nsScriptSecurityManager::nsScriptSecurityManager(void)
     1:     : mOriginToPolicyMap(nsnull),
     1:       mDefaultPolicy(nsnull),
     1:       mCapabilities(nsnull),
 33308:       mContextPrincipals(nsnull),
 80486:       mPrefInitialized(false),
 80486:       mIsJavaScriptEnabled(false),
 80486:       mIsWritingPrefs(false),
 80486:       mPolicyPrefsChanged(true)
     1: {
 95340:     MOZ_STATIC_ASSERT(sizeof(intptr_t) == sizeof(void*),
 95340:                       "intptr_t and void* have different lengths on this platform. "
 25554:                       "This may cause a security failure with the SecurityLevel union.");
     1:     mPrincipals.Init(31);
     1: }
     1: 
     1: nsresult nsScriptSecurityManager::Init()
     1: {
 41899:     nsXPConnect* xpconnect = nsXPConnect::GetXPConnect();
 41899:      if (!xpconnect)
 41899:         return NS_ERROR_FAILURE;
 41899: 
 41899:     NS_ADDREF(sXPConnect = xpconnect);
 41899:     NS_ADDREF(sJSContextStack = xpconnect);
 20462: 
     1:     JSContext* cx = GetSafeJSContext();
     1:     if (!cx) return NS_ERROR_FAILURE;   // this can happen of xpt loading fails
     1:     
     1:     ::JS_BeginRequest(cx);
 48470:     if (sEnabledID == JSID_VOID)
 70270:         sEnabledID = INTERNED_STRING_TO_JSID(cx, ::JS_InternString(cx, "enabled"));
     1:     ::JS_EndRequest(cx);
     1: 
 23434:     InitPrefs();
     1: 
 41899:     nsresult rv = CallGetService(NS_IOSERVICE_CONTRACTID, &sIOService);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
 42314:     nsCOMPtr<nsIStringBundleService> bundleService =
 42314:         mozilla::services::GetStringBundleService();
 42314:     if (!bundleService)
 42314:         return NS_ERROR_FAILURE;
     1: 
     1:     rv = bundleService->CreateBundle("chrome://global/locale/security/caps.properties", &sStrBundle);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Create our system principal singleton
     1:     nsRefPtr<nsSystemPrincipal> system = new nsSystemPrincipal();
     1:     NS_ENSURE_TRUE(system, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:     mSystemPrincipal = system;
     1: 
     1:     //-- Register security check callback in the JS engine
     1:     //   Currently this is used to control access to function.caller
     1:     nsCOMPtr<nsIJSRuntimeService> runtimeService =
 41899:         do_QueryInterface(sXPConnect, &rv);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     rv = runtimeService->GetRuntime(&sRuntime);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
 91900:     static const JSSecurityCallbacks securityCallbacks = {
 18871:         CheckObjectAccess,
 91900:         nsJSPrincipals::Subsume,
 91900:         ObjectPrincipalFinder,
 94849:         ContentSecurityPolicyPermitsJSAction,
 94849:         PushPrincipalCallback,
 94849:         PopPrincipalCallback
 18871:     };
 18871: 
 91900:     MOZ_ASSERT(!JS_GetSecurityCallbacks(sRuntime));
 91900:     JS_SetSecurityCallbacks(sRuntime, &securityCallbacks);
 91900:     JS_InitDestroyPrincipalsCallback(sRuntime, nsJSPrincipals::Destroy);
 91900: 
 91900:     JS_SetTrustedPrincipals(sRuntime, system);
 73495: 
     1:     return NS_OK;
     1: }
     1: 
100444: static nsRefPtr<nsScriptSecurityManager> gScriptSecMan;
     1: 
 48470: jsid nsScriptSecurityManager::sEnabledID   = JSID_VOID;
     1: 
     1: nsScriptSecurityManager::~nsScriptSecurityManager(void)
     1: {
 72017:     Preferences::RemoveObservers(this, kObservedPrefs);
 33308:     NS_ASSERTION(!mContextPrincipals, "Leaking mContextPrincipals");
     1:     delete mOriginToPolicyMap;
     1:     if(mDefaultPolicy)
     1:         mDefaultPolicy->Drop();
     1:     delete mCapabilities;
     1: }
     1: 
     1: void
     1: nsScriptSecurityManager::Shutdown()
     1: {
     1:     if (sRuntime) {
 91900:         JS_SetSecurityCallbacks(sRuntime, NULL);
 73495:         JS_SetTrustedPrincipals(sRuntime, NULL);
     1:         sRuntime = nsnull;
     1:     }
 48470:     sEnabledID = JSID_VOID;
     1: 
     1:     NS_IF_RELEASE(sIOService);
     1:     NS_IF_RELEASE(sXPConnect);
 20462:     NS_IF_RELEASE(sJSContextStack);
     1:     NS_IF_RELEASE(sStrBundle);
     1: }
     1: 
     1: nsScriptSecurityManager *
     1: nsScriptSecurityManager::GetScriptSecurityManager()
     1: {
     1:     if (!gScriptSecMan)
     1:     {
100444:         nsRefPtr<nsScriptSecurityManager> ssManager = new nsScriptSecurityManager();
100444: 
     1:         nsresult rv;
     1:         rv = ssManager->Init();
     1:         NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to initialize nsScriptSecurityManager");
     1:         if (NS_FAILED(rv)) {
     1:             return nsnull;
     1:         }
     1:  
     1:         rv = sXPConnect->SetDefaultSecurityManager(ssManager,
     1:                                                    nsIXPCSecurityManager::HOOK_ALL);
     1:         if (NS_FAILED(rv)) {
     1:             NS_WARNING("Failed to install xpconnect security manager!");
     1:             return nsnull;
     1:         }
     1: 
100444:         ClearOnShutdown(&gScriptSecMan);
     1:         gScriptSecMan = ssManager;
     1:     }
     1:     return gScriptSecMan;
     1: }
     1: 
     1: // Currently this nsGenericFactory constructor is used only from FastLoad
     1: // (XPCOM object deserialization) code, when "creating" the system principal
     1: // singleton.
     1: nsSystemPrincipal *
     1: nsScriptSecurityManager::SystemPrincipalSingletonConstructor()
     1: {
     1:     nsIPrincipal *sysprin = nsnull;
     1:     if (gScriptSecMan)
     1:         NS_ADDREF(sysprin = gScriptSecMan->mSystemPrincipal);
  3233:     return static_cast<nsSystemPrincipal*>(sysprin);
     1: }
     1: 
     1: nsresult
     1: nsScriptSecurityManager::InitPolicies()
     1: {
     1:     // Clear any policies cached on XPConnect wrappers
     1:     NS_ENSURE_STATE(sXPConnect);
     1:     nsresult rv = sXPConnect->ClearAllWrappedNativeSecurityPolicies();
     1:     if (NS_FAILED(rv)) return rv;
     1: 
     1:     //-- Clear mOriginToPolicyMap: delete mapped DomainEntry items,
     1:     //-- whose dtor decrements refcount of stored DomainPolicy object
     1:     delete mOriginToPolicyMap;
     1:     
     1:     //-- Marks all the survivor DomainPolicy objects (those cached
     1:     //-- by nsPrincipal objects) as invalid: they will be released
     1:     //-- on first nsPrincipal::GetSecurityPolicy() attempt.
     1:     DomainPolicy::InvalidateAll();
     1:     
     1:     //-- Release old default policy
     1:     if(mDefaultPolicy) {
     1:         mDefaultPolicy->Drop();
     1:         mDefaultPolicy = nsnull;
     1:     }
     1:     
     1:     //-- Initialize a new mOriginToPolicyMap
     1:     mOriginToPolicyMap =
     1:       new nsObjectHashtable(nsnull, nsnull, DeleteDomainEntry, nsnull);
     1:     if (!mOriginToPolicyMap)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     //-- Create, refcount and initialize a new default policy 
     1:     mDefaultPolicy = new DomainPolicy();
     1:     if (!mDefaultPolicy)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     mDefaultPolicy->Hold();
     1:     if (!mDefaultPolicy->Init())
     1:         return NS_ERROR_UNEXPECTED;
     1: 
     1:     //-- Initialize the table of security levels
     1:     if (!mCapabilities)
     1:     {
     1:         mCapabilities = 
     1:           new nsObjectHashtable(nsnull, nsnull, DeleteCapability, nsnull);
     1:         if (!mCapabilities)
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
     1:     // Get a JS context - we need it to create internalized strings later.
     1:     JSContext* cx = GetSafeJSContext();
     1:     NS_ASSERTION(cx, "failed to get JS context");
 20462:     AutoCxPusher autoPusher(sJSContextStack, cx);
     1:     rv = InitDomainPolicy(cx, "default", mDefaultPolicy);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
 72017:     nsAdoptingCString policyNames =
 72017:         Preferences::GetCString("capability.policy.policynames");
 72017: 
 72017:     nsAdoptingCString defaultPolicyNames =
 72017:         Preferences::GetCString("capability.policy.default_policynames");
     1:     policyNames += NS_LITERAL_CSTRING(" ") + defaultPolicyNames;
     1: 
     1:     //-- Initialize domain policies
     1:     char* policyCurrent = policyNames.BeginWriting();
 79445:     bool morePolicies = true;
     1:     while (morePolicies)
     1:     {
     1:         while(*policyCurrent == ' ' || *policyCurrent == ',')
     1:             policyCurrent++;
     1:         if (*policyCurrent == '\0')
     1:             break;
     1:         char* nameBegin = policyCurrent;
     1: 
     1:         while(*policyCurrent != '\0' && *policyCurrent != ' ' && *policyCurrent != ',')
     1:             policyCurrent++;
     1: 
     1:         morePolicies = (*policyCurrent != '\0');
     1:         *policyCurrent = '\0';
     1:         policyCurrent++;
     1: 
     1:         nsCAutoString sitesPrefName(
     1:             NS_LITERAL_CSTRING(sPolicyPrefix) +
     1:             nsDependentCString(nameBegin) +
     1:             NS_LITERAL_CSTRING(".sites"));
 72017:         nsAdoptingCString domainList =
 72017:             Preferences::GetCString(sitesPrefName.get());
 72017:         if (!domainList) {
     1:             continue;
 72017:         }
     1: 
     1:         DomainPolicy* domainPolicy = new DomainPolicy();
     1:         if (!domainPolicy)
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:         if (!domainPolicy->Init())
     1:         {
     1:             delete domainPolicy;
     1:             return NS_ERROR_UNEXPECTED;
     1:         }
     1:         domainPolicy->Hold();
     1:         //-- Parse list of sites and create an entry in mOriginToPolicyMap for each
     1:         char* domainStart = domainList.BeginWriting();
     1:         char* domainCurrent = domainStart;
     1:         char* lastDot = nsnull;
     1:         char* nextToLastDot = nsnull;
 79445:         bool moreDomains = true;
     1:         while (moreDomains)
     1:         {
     1:             if (*domainCurrent == ' ' || *domainCurrent == '\0')
     1:             {
     1:                 moreDomains = (*domainCurrent != '\0');
     1:                 *domainCurrent = '\0';
     1:                 nsCStringKey key(nextToLastDot ? nextToLastDot+1 : domainStart);
     1:                 DomainEntry *newEntry = new DomainEntry(domainStart, domainPolicy);
     1:                 if (!newEntry)
     1:                 {
     1:                     domainPolicy->Drop();
     1:                     return NS_ERROR_OUT_OF_MEMORY;
     1:                 }
     1: #ifdef DEBUG
     1:                 newEntry->mPolicyName_DEBUG = nameBegin;
     1: #endif
     1:                 DomainEntry *existingEntry = (DomainEntry *)
     1:                     mOriginToPolicyMap->Get(&key);
     1:                 if (!existingEntry)
     1:                     mOriginToPolicyMap->Put(&key, newEntry);
     1:                 else
     1:                 {
     1:                     if (existingEntry->Matches(domainStart))
     1:                     {
     1:                         newEntry->mNext = existingEntry;
     1:                         mOriginToPolicyMap->Put(&key, newEntry);
     1:                     }
     1:                     else
     1:                     {
     1:                         while (existingEntry->mNext)
     1:                         {
     1:                             if (existingEntry->mNext->Matches(domainStart))
     1:                             {
     1:                                 newEntry->mNext = existingEntry->mNext;
     1:                                 existingEntry->mNext = newEntry;
     1:                                 break;
     1:                             }
     1:                             existingEntry = existingEntry->mNext;
     1:                         }
     1:                         if (!existingEntry->mNext)
     1:                             existingEntry->mNext = newEntry;
     1:                     }
     1:                 }
     1:                 domainStart = domainCurrent + 1;
     1:                 lastDot = nextToLastDot = nsnull;
     1:             }
     1:             else if (*domainCurrent == '.')
     1:             {
     1:                 nextToLastDot = lastDot;
     1:                 lastDot = domainCurrent;
     1:             }
     1:             domainCurrent++;
     1:         }
     1: 
     1:         rv = InitDomainPolicy(cx, nameBegin, domainPolicy);
     1:         domainPolicy->Drop();
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1:     }
     1: 
     1:     // Reset the "dirty" flag
 80486:     mPolicyPrefsChanged = false;
     1: 
     1: #ifdef DEBUG_CAPS_HACKER
     1:     PrintPolicyDB();
     1: #endif
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsScriptSecurityManager::InitDomainPolicy(JSContext* cx,
     1:                                           const char* aPolicyName,
     1:                                           DomainPolicy* aDomainPolicy)
     1: {
     1:     nsresult rv;
     1:     nsCAutoString policyPrefix(NS_LITERAL_CSTRING(sPolicyPrefix) +
     1:                                nsDependentCString(aPolicyName) +
     1:                                NS_LITERAL_CSTRING("."));
     1:     PRUint32 prefixLength = policyPrefix.Length() - 1; // subtract the '.'
     1: 
     1:     PRUint32 prefCount;
     1:     char** prefNames;
 72017:     nsIPrefBranch* branch = Preferences::GetRootBranch();
 72017:     NS_ASSERTION(branch, "failed to get the root pref branch");
 72017:     rv = branch->GetChildList(policyPrefix.get(), &prefCount, &prefNames);
     1:     if (NS_FAILED(rv)) return rv;
     1:     if (prefCount == 0)
     1:         return NS_OK;
     1: 
     1:     //-- Populate the policy
     1:     PRUint32 currentPref = 0;
     1:     for (; currentPref < prefCount; currentPref++)
     1:     {
     1:         // Get the class name
     1:         const char* start = prefNames[currentPref] + prefixLength + 1;
     1:         char* end = PL_strchr(start, '.');
     1:         if (!end) // malformed pref, bail on this one
     1:             continue;
     1:         static const char sitesStr[] = "sites";
     1: 
     1:         // We dealt with "sites" in InitPolicies(), so no need to do
     1:         // that again...
     1:         if (PL_strncmp(start, sitesStr, sizeof(sitesStr)-1) == 0)
     1:             continue;
     1: 
     1:         // Get the pref value
 72017:         nsAdoptingCString prefValue =
 72017:             Preferences::GetCString(prefNames[currentPref]);
 72017:         if (!prefValue) {
     1:             continue;
 72017:         }
     1: 
     1:         SecurityLevel secLevel;
     1:         if (PL_strcasecmp(prefValue, "noAccess") == 0)
     1:             secLevel.level = SCRIPT_SECURITY_NO_ACCESS;
     1:         else if (PL_strcasecmp(prefValue, "allAccess") == 0)
     1:             secLevel.level = SCRIPT_SECURITY_ALL_ACCESS;
     1:         else if (PL_strcasecmp(prefValue, "sameOrigin") == 0)
     1:             secLevel.level = SCRIPT_SECURITY_SAME_ORIGIN_ACCESS;
     1:         else 
     1:         {  //-- pref value is the name of a capability
     1:             nsCStringKey secLevelKey(prefValue);
     1:             secLevel.capability =
  3233:                 reinterpret_cast<char*>(mCapabilities->Get(&secLevelKey));
     1:             if (!secLevel.capability)
     1:             {
     1:                 secLevel.capability = NS_strdup(prefValue);
     1:                 if (!secLevel.capability)
     1:                     break;
     1:                 mCapabilities->Put(&secLevelKey, 
     1:                                    secLevel.capability);
     1:             }
     1:         }
     1: 
     1:         *end = '\0';
     1:         // Find or store this class in the classes table
     1:         ClassPolicy* cpolicy = 
  3233:           static_cast<ClassPolicy*>
  3233:                      (PL_DHashTableOperate(aDomainPolicy, start,
     1:                                               PL_DHASH_ADD));
     1:         if (!cpolicy)
     1:             break;
     1: 
     1:         // If this is the wildcard class (class '*'), save it in mWildcardPolicy
     1:         // (we leave it stored in the hashtable too to take care of the cleanup)
     1:         if ((*start == '*') && (end == start + 1)) {
     1:             aDomainPolicy->mWildcardPolicy = cpolicy;
     1: 
     1:             // Make sure that cpolicy knows about aDomainPolicy so it can reset
     1:             // the mWildcardPolicy pointer as needed if it gets moved in the
     1:             // hashtable.
     1:             cpolicy->mDomainWeAreWildcardFor = aDomainPolicy;
     1:         }
     1: 
     1:         // Get the property name
     1:         start = end + 1;
     1:         end = PL_strchr(start, '.');
     1:         if (end)
     1:             *end = '\0';
     1: 
     1:         JSAutoRequest ar(cx);
     1: 
     1:         JSString* propertyKey = ::JS_InternString(cx, start);
     1:         if (!propertyKey)
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:         // Store this property in the class policy
     1:         PropertyPolicy* ppolicy = 
  3233:           static_cast<PropertyPolicy*>
 48470:                      (PL_DHashTableOperate(cpolicy->mPolicy, propertyKey,
     1:                                               PL_DHASH_ADD));
     1:         if (!ppolicy)
     1:             break;
     1: 
     1:         if (end) // The pref specifies an access mode
     1:         {
     1:             start = end + 1;
     1:             if (PL_strcasecmp(start, "set") == 0)
     1:                 ppolicy->mSet = secLevel;
     1:             else
     1:                 ppolicy->mGet = secLevel;
     1:         }
     1:         else
     1:         {
     1:             if (ppolicy->mGet.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
     1:                 ppolicy->mGet = secLevel;
     1:             if (ppolicy->mSet.level == SCRIPT_SECURITY_UNDEFINED_ACCESS)
     1:                 ppolicy->mSet = secLevel;
     1:         }
     1:     }
     1: 
     1:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);
     1:     if (currentPref < prefCount) // Loop exited early because of out-of-memory error
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: // XXXbz We should really just get a prefbranch to handle this...
     1: nsresult
     1: nsScriptSecurityManager::GetPrincipalPrefNames(const char* prefBase,
     1:                                                nsCString& grantedPref,
     1:                                                nsCString& deniedPref,
     1:                                                nsCString& subjectNamePref)
     1: {
     1:     char* lastDot = PL_strrchr(prefBase, '.');
     1:     if (!lastDot) return NS_ERROR_FAILURE;
     1:     PRInt32 prefLen = lastDot - prefBase + 1;
     1: 
     1:     grantedPref.Assign(prefBase, prefLen);
     1:     deniedPref.Assign(prefBase, prefLen);
     1:     subjectNamePref.Assign(prefBase, prefLen);
     1: 
     1: #define GRANTED "granted"
     1: #define DENIED "denied"
     1: #define SUBJECTNAME "subjectName"
     1: 
     1:     grantedPref.AppendLiteral(GRANTED);
     1:     if (grantedPref.Length() != prefLen + sizeof(GRANTED) - 1) {
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
     1:     deniedPref.AppendLiteral(DENIED);
     1:     if (deniedPref.Length() != prefLen + sizeof(DENIED) - 1) {
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
     1:     subjectNamePref.AppendLiteral(SUBJECTNAME);
     1:     if (subjectNamePref.Length() != prefLen + sizeof(SUBJECTNAME) - 1) {
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
     1: #undef SUBJECTNAME
     1: #undef DENIED
     1: #undef GRANTED
     1:     
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
 43345: nsScriptSecurityManager::InitPrincipals(PRUint32 aPrefCount, const char** aPrefNames)
     1: {
     1:     /* This is the principal preference syntax:
     1:      * capability.principal.[codebase|codebaseTrusted|certificate].<name>.[id|granted|denied]
     1:      * For example:
     1:      * user_pref("capability.principal.certificate.p1.id","12:34:AB:CD");
     1:      * user_pref("capability.principal.certificate.p1.granted","Capability1 Capability2");
     1:      * user_pref("capability.principal.certificate.p1.denied","Capability3");
     1:      */
     1: 
     1:     /* codebaseTrusted means a codebase principal that can enable capabilities even if
     1:      * codebase principals are disabled. Don't use trustedCodebase except with unspoofable
     1:      * URLs such as HTTPS URLs.
     1:      */
     1: 
     1:     static const char idSuffix[] = ".id";
     1:     for (PRUint32 c = 0; c < aPrefCount; c++)
     1:     {
     1:         PRInt32 prefNameLen = PL_strlen(aPrefNames[c]) - 
 80467:             (ArrayLength(idSuffix) - 1);
     1:         if (PL_strcasecmp(aPrefNames[c] + prefNameLen, idSuffix) != 0)
     1:             continue;
     1: 
 72017:         nsAdoptingCString id = Preferences::GetCString(aPrefNames[c]);
 72017:         if (!id) {
     1:             return NS_ERROR_FAILURE;
 72017:         }
     1: 
     1:         nsCAutoString grantedPrefName;
     1:         nsCAutoString deniedPrefName;
     1:         nsCAutoString subjectNamePrefName;
     1:         nsresult rv = GetPrincipalPrefNames(aPrefNames[c],
     1:                                             grantedPrefName,
     1:                                             deniedPrefName,
     1:                                             subjectNamePrefName);
     1:         if (rv == NS_ERROR_OUT_OF_MEMORY)
     1:             return rv;
     1:         if (NS_FAILED(rv))
     1:             continue;
     1: 
 72017:         nsAdoptingCString grantedList =
 72017:             Preferences::GetCString(grantedPrefName.get());
 72017:         nsAdoptingCString deniedList =
 72017:             Preferences::GetCString(deniedPrefName.get());
 72017:         nsAdoptingCString subjectName =
 72017:             Preferences::GetCString(subjectNamePrefName.get());
     1: 
     1:         //-- Delete prefs if their value is the empty string
     1:         if (id.IsEmpty() || (grantedList.IsEmpty() && deniedList.IsEmpty()))
     1:         {
 72017:             Preferences::ClearUser(aPrefNames[c]);
 72017:             Preferences::ClearUser(grantedPrefName.get());
 72017:             Preferences::ClearUser(deniedPrefName.get());
 72017:             Preferences::ClearUser(subjectNamePrefName.get());
     1:             continue;
     1:         }
     1: 
     1:         //-- Create a principal based on the prefs
     1:         static const char certificateName[] = "capability.principal.certificate";
     1:         static const char codebaseName[] = "capability.principal.codebase";
     1:         static const char codebaseTrustedName[] = "capability.principal.codebaseTrusted";
     1: 
 79445:         bool isCert = false;
 79445:         bool isTrusted = false;
     1:         
     1:         if (PL_strncmp(aPrefNames[c], certificateName,
     1:                        sizeof(certificateName) - 1) == 0)
     1:         {
 80486:             isCert = true;
     1:         }
     1:         else if (PL_strncmp(aPrefNames[c], codebaseName,
     1:                             sizeof(codebaseName) - 1) == 0)
     1:         {
     1:             isTrusted = (PL_strncmp(aPrefNames[c], codebaseTrustedName,
     1:                                     sizeof(codebaseTrustedName) - 1) == 0);
     1:         }
     1:         else
     1:         {
     1:           NS_ERROR("Not a codebase or a certificate?!");
     1:         }
     1: 
     1:         nsRefPtr<nsPrincipal> newPrincipal = new nsPrincipal();
     1:         if (!newPrincipal)
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:         rv = newPrincipal->InitFromPersistent(aPrefNames[c], id, subjectName,
     1:                                               EmptyCString(),
     1:                                               grantedList, deniedList, nsnull, 
     1:                                               isCert, isTrusted);
     1:         if (NS_SUCCEEDED(rv))
     1:             mPrincipals.Put(newPrincipal, newPrincipal);
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: inline void
  5766: nsScriptSecurityManager::ScriptSecurityPrefChanged()
     1: {
 23434:     // JavaScript defaults to enabled in failure cases.
 80486:     mIsJavaScriptEnabled = true;
 80486: 
 80486:     sStrictFileOriginPolicy = true;
 23434: 
 23434:     nsresult rv;
 72017:     if (!mPrefInitialized) {
 23434:         rv = InitPrefs();
 23434:         if (NS_FAILED(rv))
 23434:             return;
 23434:     }
 23434: 
 72017:     mIsJavaScriptEnabled =
 72017:         Preferences::GetBool(sJSEnabledPrefName, mIsJavaScriptEnabled);
 72017: 
 72017:     sStrictFileOriginPolicy =
 79445:         Preferences::GetBool(sFileOriginPolicyPrefName, false);
     1: }
     1: 
     1: nsresult
     1: nsScriptSecurityManager::InitPrefs()
     1: {
     1:     nsresult rv;
 72017:     nsIPrefBranch* branch = Preferences::GetRootBranch();
 72017:     NS_ENSURE_TRUE(branch, NS_ERROR_FAILURE);
 72017: 
 80486:     mPrefInitialized = true;
     1: 
     1:     // Set the initial value of the "javascript.enabled" prefs
  5766:     ScriptSecurityPrefChanged();
 72017: 
     1:     // set observer callbacks in case the value of the prefs change
 72017:     Preferences::AddStrongObservers(this, kObservedPrefs);
 72017: 
     1:     PRUint32 prefCount;
     1:     char** prefNames;
     1:     //-- Initialize the principals database from prefs
 72017:     rv = branch->GetChildList(sPrincipalPrefix, &prefCount, &prefNames);
     1:     if (NS_SUCCEEDED(rv) && prefCount > 0)
     1:     {
 43345:         rv = InitPrincipals(prefCount, (const char**)prefNames);
     1:         NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: ///////////////////////////////////////////////////////////////////////////////
     1: // The following code prints the contents of the policy DB to the console.
     1: #ifdef DEBUG_CAPS_HACKER
     1: 
     1: //typedef PLDHashOperator
 20261: //(* PLDHashEnumerator)(PLDHashTable *table, PLDHashEntryHdr *hdr,
     1: //                      PRUint32 number, void *arg);
 20261: static PLDHashOperator
     1: PrintPropertyPolicy(PLDHashTable *table, PLDHashEntryHdr *entry,
     1:                     PRUint32 number, void *arg)
     1: {
     1:     PropertyPolicy* pp = (PropertyPolicy*)entry;
     1:     nsCAutoString prop("        ");
     1:     JSContext* cx = (JSContext*)arg;
     1:     prop.AppendInt((PRUint32)pp->key);
     1:     prop += ' ';
 48470:     prop.AppendWithConversion((PRUnichar*)JS_GetStringChars(pp->key));
     1:     prop += ": Get=";
     1:     if (SECURITY_ACCESS_LEVEL_FLAG(pp->mGet))
     1:         prop.AppendInt(pp->mGet.level);
     1:     else
     1:         prop += pp->mGet.capability;
     1: 
     1:     prop += " Set=";
     1:     if (SECURITY_ACCESS_LEVEL_FLAG(pp->mSet))
     1:         prop.AppendInt(pp->mSet.level);
     1:     else
     1:         prop += pp->mSet.capability;
     1:         
     1:     printf("%s.\n", prop.get());
     1:     return PL_DHASH_NEXT;
     1: }
     1: 
 20261: static PLDHashOperator
     1: PrintClassPolicy(PLDHashTable *table, PLDHashEntryHdr *entry,
     1:                  PRUint32 number, void *arg)
     1: {
     1:     ClassPolicy* cp = (ClassPolicy*)entry;
     1:     printf("    %s\n", cp->key);
     1: 
     1:     PL_DHashTableEnumerate(cp->mPolicy, PrintPropertyPolicy, arg);
     1:     return PL_DHASH_NEXT;
     1: }
     1: 
 79445: // typedef bool
 20261: // (* nsHashtableEnumFunc)(nsHashKey *aKey, void *aData, void* aClosure);
 79445: static bool
     1: PrintDomainPolicy(nsHashKey *aKey, void *aData, void* aClosure)
     1: {
     1:     DomainEntry* de = (DomainEntry*)aData;
     1:     printf("----------------------------\n");
     1:     printf("Domain: %s Policy Name: %s.\n", de->mOrigin.get(),
     1:            de->mPolicyName_DEBUG.get());
     1:     PL_DHashTableEnumerate(de->mDomainPolicy, PrintClassPolicy, aClosure);
 80486:     return true;
     1: }
     1: 
 79445: static bool
     1: PrintCapability(nsHashKey *aKey, void *aData, void* aClosure)
     1: {
     1:     char* cap = (char*)aData;
     1:     printf("    %s.\n", cap);
 80486:     return true;
     1: }
     1: 
     1: void
     1: nsScriptSecurityManager::PrintPolicyDB()
     1: {
     1:     printf("############## Security Policies ###############\n");
     1:     if(mOriginToPolicyMap)
     1:     {
     1:         JSContext* cx = GetCurrentJSContext();
     1:         if (!cx)
     1:             cx = GetSafeJSContext();
     1:         printf("----------------------------\n");
     1:         printf("Domain: Default.\n");
     1:         PL_DHashTableEnumerate(mDefaultPolicy, PrintClassPolicy, (void*)cx);
     1:         mOriginToPolicyMap->Enumerate(PrintDomainPolicy, (void*)cx);
     1:     }
     1:     printf("############ End Security Policies #############\n\n");
     1:     printf("############## Capabilities ###############\n");
     1:     mCapabilities->Enumerate(PrintCapability);
     1:     printf("############## End Capabilities ###############\n");
     1: }
     1: #endif
