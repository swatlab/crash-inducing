    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Alex Fritze <alex.fritze@crocodile-clips.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsSVGElement.h"
    1: #include "nsSVGSVGElement.h"
15895: #include "nsSVGSwitchElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsRange.h"
    1: #include "nsIDOMAttr.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsMutationEvent.h"
 8335: #include "nsXBLPrototypeBinding.h"
    1: #include "nsBindingManager.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsDOMError.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIDOMViewCSS.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIXBLService.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsICSSStyleRule.h"
    1: #include "nsRuleWalker.h"
    1: #include "nsCSSDeclaration.h"
    1: #include "nsCSSProps.h"
    1: #include "nsICSSParser.h"
    1: #include "nsICSSLoader.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsSVGUtils.h"
    1: #include "nsSVGLength2.h"
    1: #include "nsSVGNumber2.h"
 6045: #include "nsSVGInteger.h"
 6788: #include "nsSVGAngle.h"
 6325: #include "nsSVGBoolean.h"
 5347: #include "nsSVGEnum.h"
15353: #include "nsSVGString.h"
 5347: #include "nsIDOMSVGUnitTypes.h"
 5729: #include "nsIDOMSVGLengthList.h"
 5729: #include "nsIDOMSVGAnimatedLengthList.h"
 5729: #include "nsIDOMSVGNumberList.h"
 5729: #include "nsIDOMSVGAnimatedNumberList.h"
 5729: #include "nsIDOMSVGPointList.h"
 5729: #include "nsIDOMSVGAnimatedPoints.h"
 5729: #include "nsIDOMSVGPresAspectRatio.h"
 5729: #include "nsIDOMSVGAnimPresAspRatio.h"
 5729: #include "nsIDOMSVGTransformList.h"
 5729: #include "nsIDOMSVGAnimTransformList.h"
 5729: #include "nsIDOMSVGAnimatedRect.h"
 5729: #include "nsSVGRect.h"
 6944: #include "prdtoa.h"
    1: #include <stdarg.h>
    1: 
 5347: nsSVGEnumMapping nsSVGElement::sSVGUnitTypesMap[] = {
 5347:   {&nsGkAtoms::userSpaceOnUse, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_USERSPACEONUSE},
 5347:   {&nsGkAtoms::objectBoundingBox, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX},
 5347:   {nsnull, 0}
 5347: };
 5347: 
    1: nsSVGElement::nsSVGElement(nsINodeInfo *aNodeInfo)
11169:   : nsSVGElementBase(aNodeInfo), mSuppressNotification(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsresult
    1: nsSVGElement::Init()
    1: {
    1:   // Set up length attributes - can't do this in the constructor
    1:   // because we can't do a virtual call at that point
    1: 
    1:   LengthAttributesInfo lengthInfo = GetLengthInfo();
    1: 
    1:   PRUint32 i;
    1:   for (i = 0; i < lengthInfo.mLengthCount; i++) {
 8288:     lengthInfo.Reset(i);
    1:   }
    1: 
    1:   NumberAttributesInfo numberInfo = GetNumberInfo();
    1: 
    1:   for (i = 0; i < numberInfo.mNumberCount; i++) {
 8288:     numberInfo.Reset(i);
    1:   }
    1: 
 6045:   IntegerAttributesInfo integerInfo = GetIntegerInfo();
 6045: 
 6045:   for (i = 0; i < integerInfo.mIntegerCount; i++) {
 8288:     integerInfo.Reset(i);
 6045:   }
 6045: 
 6788:   AngleAttributesInfo angleInfo = GetAngleInfo();
 6788: 
 6788:   for (i = 0; i < angleInfo.mAngleCount; i++) {
 8288:     angleInfo.Reset(i);
 6788:   }
 6788: 
 6325:   BooleanAttributesInfo booleanInfo = GetBooleanInfo();
 6325: 
 6325:   for (i = 0; i < booleanInfo.mBooleanCount; i++) {
 8288:     booleanInfo.Reset(i);
 6325:   }
 6325: 
 5347:   EnumAttributesInfo enumInfo = GetEnumInfo();
 5347: 
 5347:   for (i = 0; i < enumInfo.mEnumCount; i++) {
 8288:     enumInfo.Reset(i);
 5347:   }
 5347: 
15353:   StringAttributesInfo stringInfo = GetStringInfo();
15353: 
15353:   for (i = 0; i < stringInfo.mStringCount; i++) {
15353:     stringInfo.Reset(i);
15353:   }
15353: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsSVGElement::~nsSVGElement()
    1: {
    1:   PRUint32 i, count = mMappedAttributes.AttrCount();
    1:   for (i = 0; i < count; ++i) {
    1:     mMappedAttributes.AttrAt(i)->GetSVGValue()->RemoveObserver(this);
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsISupports methods
    1: 
 4306: NS_IMPL_ADDREF_INHERITED(nsSVGElement, nsSVGElementBase)
 4306: NS_IMPL_RELEASE_INHERITED(nsSVGElement, nsSVGElementBase)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsSVGElement)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:   NS_INTERFACE_MAP_ENTRY(nsISVGValueObserver)
    1: // provided by nsGenericElement:
    1: //  NS_INTERFACE_MAP_ENTRY(nsIContent)
 4306: NS_INTERFACE_MAP_END_INHERITING(nsSVGElementBase)
    1: 
    1: //----------------------------------------------------------------------
    1: // Implementation
    1:   
    1: //----------------------------------------------------------------------
    1: // nsIContent methods
    1: 
    1: nsresult
 9755: nsSVGElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
 9755:                          nsIContent* aBindingParent,
 9755:                          PRBool aCompileEventHandlers)
 9755: {
 9755:   nsresult rv = nsSVGElementBase::BindToTree(aDocument, aParent,
 9755:                                              aBindingParent,
 9755:                                              aCompileEventHandlers);
 9755:   NS_ENSURE_SUCCESS(rv, rv);
 9755: 
 9755:   if (!HasFlag(NODE_MAY_HAVE_STYLE)) {
 9755:     return NS_OK;
 9755:   }
 9755:   const nsAttrValue* oldVal = mAttrsAndChildren.GetAttr(nsGkAtoms::style);
 9755: 
 9755:   if (oldVal && oldVal->Type() == nsAttrValue::eCSSStyleRule) {
 9755:     // we need to force a reparse because the baseURI of the document
 9755:     // may have changed
 9755:     nsAttrValue attrValue;
 9755:     nsAutoString stringValue;
 9755:     oldVal->ToString(stringValue);
11871:     // Force in data doc, since we already have a style rule
11871:     ParseStyleAttribute(this, stringValue, attrValue, PR_TRUE);
 9755:     // Don't bother going through SetInlineStyleRule, we don't want to fire off
 9755:     // mutation events or document notifications anyway
 9755:     rv = mAttrsAndChildren.SetAndTakeAttr(nsGkAtoms::style, attrValue);
 9755:     NS_ENSURE_SUCCESS(rv, rv);
 9755:   }
 9755: 
 9755:   return NS_OK;
 9755: }
 9755: 
 9755: nsresult
    1: nsSVGElement::BeforeSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                             const nsAString* aValue, PRBool aNotify)
    1: {
    1:   // If this is an svg presentation attribute we need to map it into
    1:   // the content stylerule.
    1:   // XXX For some reason incremental mapping doesn't work, so for now
    1:   // just delete the style rule and lazily reconstruct it in
    1:   // GetContentStyleRule()
    1:   if (aNamespaceID == kNameSpaceID_None && IsAttributeMapped(aName)) {
    1:     mContentStyleRule = nsnull;
    1:   }
    1: 
 4306:   return nsSVGElementBase::BeforeSetAttr(aNamespaceID, aName, aValue, aNotify);
    1: }
    1: 
    1: nsresult
    1: nsSVGElement::AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                            const nsAString* aValue, PRBool aNotify)
    1: {  
    1:   if (IsEventName(aName) && aValue) {
    1:     nsresult rv = AddScriptEventListener(GetEventNameForAttr(aName), *aValue);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
15895:   if (aNamespaceID == kNameSpaceID_None &&
15895:       (aName == nsGkAtoms::requiredFeatures ||
15895:        aName == nsGkAtoms::requiredExtensions ||
15895:        aName == nsGkAtoms::systemLanguage)) {
15895: 
15895:     nsIContent* parent = nsnull;
15895:   
15895:     nsIContent* bindingParent = GetBindingParent();
15895:     if (bindingParent) {
15895:       nsIDocument* doc = bindingParent->GetOwnerDoc();
15895:       if (doc) {
15895:         parent = doc->BindingManager()->GetInsertionParent(bindingParent);
15895:       }
15895:     }
15895: 
15895:     if (!parent) {
15895:       // if we didn't find an anonymous parent, use the explicit one,
15895:       // whether it's null or not...
15895:       parent = GetParent();
15895:     }
15895: 
15895:     if (parent &&
15895:         parent->NodeInfo()->Equals(nsGkAtoms::svgSwitch, kNameSpaceID_SVG)) {
15895:       static_cast<nsSVGSwitchElement*>(parent)->MaybeInvalidate();
15895:     }
15895:   }
15895: 
 4306:   return nsSVGElementBase::AfterSetAttr(aNamespaceID, aName, aValue, aNotify);
    1: }
    1: 
    1: PRBool
    1: nsSVGElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                              nsIAtom* aAttribute,
    1:                              const nsAString& aValue,
    1:                              nsAttrValue& aResult)
    1: {
    1:   // Parse value
    1:   nsCOMPtr<nsISVGValue> svg_value;
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aAttribute, aNamespaceID);
    1:   if (val) {
    1:     // Found the attr in the list.
    1:     if (val->Type() == nsAttrValue::eSVGValue) {
    1:       svg_value = val->GetSVGValue();
    1:     }
    1:   }
    1:   else {
    1:     // Could be a mapped attribute.
    1:     svg_value = GetMappedAttribute(aNamespaceID, aAttribute);
    1:   }
    1:   
    1:   if (svg_value) {
    1:     // We want to prevent DidModifySVGObservable from running if we
    1:     // come in this route, otherwise AttributeChanged() gets called
    1:     // twice (once through DidMOdifySVGObservable, once through SetAttr).
    1:     mSuppressNotification = PR_TRUE;
    1: 
    1:     if (NS_FAILED(svg_value->SetValueString(aValue))) {
    1:       // The value was rejected. This happens e.g. in a XUL template
    1:       // when trying to set a value like "?x" on a value object that
    1:       // expects a length.
16188:       // To accommodate this "erroneous" value, we'll insert a proxy
    1:       // object between ourselves and the actual value object:
    1:       ReportAttributeParseFailure(GetOwnerDoc(), aAttribute, aValue);
    1:       nsCOMPtr<nsISVGValue> proxy;
    1:       nsresult rv =
    1:         NS_CreateSVGStringProxyValue(svg_value, getter_AddRefs(proxy));
    1:       // Failure means we'll store this attr as a string, not an SVGValue, but
    1:       // that's the best we can do short of throwing outright.
    1:       NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:       svg_value->RemoveObserver(this);
 8288:       ResetOldStyleBaseType(svg_value);
    1:       proxy->SetValueString(aValue);
    1:       proxy->AddObserver(this);
    1:       aResult.SetTo(proxy);
    1:     }
    1:     else {
    1:       aResult.SetTo(svg_value);
    1:     }
    1:     mSuppressNotification = PR_FALSE;
    1:     return PR_TRUE;
    1:   }
    1: 
15353:   PRBool foundMatch = PR_FALSE;
    1:   if (aNamespaceID == kNameSpaceID_None) {
 5347:     nsresult rv;
 5347: 
    1:     // Check for nsSVGLength2 attribute
    1:     LengthAttributesInfo lengthInfo = GetLengthInfo();
 6788: 
 6788:     PRUint32 i;
15353:     for (i = 0; i < lengthInfo.mLengthCount; i++) {
    1:       if (aAttribute == *lengthInfo.mLengthInfo[i].mName) {
 5347:         rv = lengthInfo.mLengths[i].SetBaseValueString(aValue, this, PR_FALSE);
 8288:         if (NS_FAILED(rv)) {
 8288:           lengthInfo.Reset(i);
 8288:         }
 5347:         foundMatch = PR_TRUE;
15353:         break;
 5347:       }
 5347:     }
 5347: 
15353:     if (!foundMatch) {
 5347:       // Check for nsSVGNumber2 attribute
 5347:       NumberAttributesInfo numberInfo = GetNumberInfo();
15353:       for (i = 0; i < numberInfo.mNumberCount; i++) {
 5347:         if (aAttribute == *numberInfo.mNumberInfo[i].mName) {
15523:           if (i + 1 < numberInfo.mNumberCount &&
15523:               aAttribute == *numberInfo.mNumberInfo[i + 1].mName) {
15523:             rv = ParseNumberOptionalNumber(aValue, i, i + 1);
15523:             if (NS_FAILED(rv)) {
15523:               numberInfo.Reset(i + 1);
15523:             }
15523:           } else {
 5347:             rv = numberInfo.mNumbers[i].SetBaseValueString(aValue, this, PR_FALSE);
15523:           }
 8288:           if (NS_FAILED(rv)) {
 8288:             numberInfo.Reset(i);
 8288:           }
 5347:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 5347:       }
 5347:     }
 5347: 
15353:     if (!foundMatch) {
 6045:       // Check for nsSVGInteger attribute
 6045:       IntegerAttributesInfo integerInfo = GetIntegerInfo();
15353:       for (i = 0; i < integerInfo.mIntegerCount; i++) {
 6045:         if (aAttribute == *integerInfo.mIntegerInfo[i].mName) {
15523:           if (i + 1 < integerInfo.mIntegerCount &&
15523:               aAttribute == *integerInfo.mIntegerInfo[i + 1].mName) {
15523:             rv = ParseIntegerOptionalInteger(aValue, i, i + 1);
15523:             if (NS_FAILED(rv)) {
15523:               integerInfo.Reset(i + 1);
15523:             }
15523:           } else {
 6045:             rv = integerInfo.mIntegers[i].SetBaseValueString(aValue, this, PR_FALSE);
15523:           }
 8288:           if (NS_FAILED(rv)) {
 8288:             integerInfo.Reset(i);
 8288:           }
 6045:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 6045:       }
 6045:     }
 6045: 
15353:     if (!foundMatch) {
 6788:       // Check for nsSVGAngle attribute
 6788:       AngleAttributesInfo angleInfo = GetAngleInfo();
15353:       for (i = 0; i < angleInfo.mAngleCount; i++) {
 6788:         if (aAttribute == *angleInfo.mAngleInfo[i].mName) {
 6788:           rv = angleInfo.mAngles[i].SetBaseValueString(aValue, this, PR_FALSE);
 8288:           if (NS_FAILED(rv)) {
 8288:             angleInfo.Reset(i);
 8288:           }
 6788:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 6788:       }
 6788:     }
 6788: 
15353:     if (!foundMatch) {
 6325:       // Check for nsSVGBoolean attribute
 6325:       BooleanAttributesInfo booleanInfo = GetBooleanInfo();
15353:       for (i = 0; i < booleanInfo.mBooleanCount; i++) {
 6325:         if (aAttribute == *booleanInfo.mBooleanInfo[i].mName) {
 6325:           rv = booleanInfo.mBooleans[i].SetBaseValueString(aValue, this, PR_FALSE);
 8288:           if (NS_FAILED(rv)) {
 8288:             booleanInfo.Reset(i);
 8288:           }
 6325:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 6325:       }
 6325:     }
 6325: 
15353:     if (!foundMatch) {
 5347:       // Check for nsSVGEnum attribute
 5347:       EnumAttributesInfo enumInfo = GetEnumInfo();
15353:       for (i = 0; i < enumInfo.mEnumCount; i++) {
 5347:         if (aAttribute == *enumInfo.mEnumInfo[i].mName) {
 5347:           rv = enumInfo.mEnums[i].SetBaseValueString(aValue, this, PR_FALSE);
 8288:           if (NS_FAILED(rv)) {
 8288:             enumInfo.Reset(i);
 8288:           }
 5347:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 5347:       }
 5347:     }
 5347: 
 5347:     if (foundMatch) {
    1:       if (NS_FAILED(rv)) {
    1:         ReportAttributeParseFailure(GetOwnerDoc(), aAttribute, aValue);
    1:         return PR_FALSE;
    1:       }
    1:       aResult.SetTo(aValue);
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
15353:   if (!foundMatch) {
15353:     // Check for nsSVGString attribute
15353:     StringAttributesInfo stringInfo = GetStringInfo();
15353:     for (PRUint32 i = 0; i < stringInfo.mStringCount; i++) {
15353:       if (aNamespaceID == stringInfo.mStringInfo[i].mNamespaceID &&
15353:           aAttribute == *stringInfo.mStringInfo[i].mName) {
15353:         stringInfo.mStrings[i].SetBaseValue(aValue, this, PR_FALSE);
15353:         foundMatch = PR_TRUE;
15353:         break;
15353:       }
15353:     }
15353:   }
15353: 
 4306:   return nsSVGElementBase::ParseAttribute(aNamespaceID, aAttribute, aValue,
    1:                                           aResult);
    1: }
    1: 
    1: nsresult
    1: nsSVGElement::UnsetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                         PRBool aNotify)
    1: {
15353:   PRBool foundMatch = PR_FALSE;
15353: 
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     // If this is an svg presentation attribute, remove rule to force an update
    1:     if (IsAttributeMapped(aName))
    1:       mContentStyleRule = nsnull;
    1: 
    1:     if (IsEventName(aName)) {
    1:       nsCOMPtr<nsIEventListenerManager> manager;
    1:       GetListenerManager(PR_FALSE, getter_AddRefs(manager));
    1:       if (manager) {
    1:         nsIAtom* eventName = GetEventNameForAttr(aName);
    1:         manager->RemoveScriptEventListener(eventName);
    1:       }
15353:       foundMatch = PR_TRUE;
15353:     }
15353:     
15353:     if (!foundMatch) {
    1:       // Check if this is a length attribute going away
    1:       LengthAttributesInfo lenInfo = GetLengthInfo();
    1: 
15353:       for (PRUint32 i = 0; i < lenInfo.mLengthCount; i++) {
    1:         if (aName == *lenInfo.mLengthInfo[i].mName) {
 8288:           lenInfo.Reset(i);
    1:           DidChangeLength(i, PR_FALSE);
15353:           foundMatch = PR_TRUE;
15523:           break;
    1:         }
    1:       }
15353:     }
15353: 
15353:     if (!foundMatch) {
    1:       // Check if this is a number attribute going away
    1:       NumberAttributesInfo numInfo = GetNumberInfo();
    1: 
15353:       for (PRUint32 i = 0; i < numInfo.mNumberCount; i++) {
    1:         if (aName == *numInfo.mNumberInfo[i].mName) {
15523:           if (i + 1 < numInfo.mNumberCount &&
15523:               aName == *numInfo.mNumberInfo[i + 1].mName) {
15523:             // found a number-optional-number
15523:             numInfo.Reset(i + 1);
15523:             DidChangeNumber(i + 1, PR_FALSE);
15523:           }
 8288:           numInfo.Reset(i);
    1:           DidChangeNumber(i, PR_FALSE);
15353:           foundMatch = PR_TRUE;
15523:           break;
15353:         }
    1:       }
    1:     }
 5347: 
15353:     if (!foundMatch) {
 6045:       // Check if this is an integer attribute going away
 6045:       IntegerAttributesInfo intInfo = GetIntegerInfo();
 6045: 
15353:       for (PRUint32 i = 0; i < intInfo.mIntegerCount; i++) {
 6045:         if (aName == *intInfo.mIntegerInfo[i].mName) {
15523:           if (i + 1 < intInfo.mIntegerCount &&
15523:               aName == *intInfo.mIntegerInfo[i + 1].mName) {
15523:             // found a number-optional-number
15523:             intInfo.Reset(i + 1);
15523:             DidChangeNumber(i + 1, PR_FALSE);
15523:           }
 8288:           intInfo.Reset(i);
 6045:           DidChangeInteger(i, PR_FALSE);
15353:           foundMatch = PR_TRUE;
15523:           break;
15353:         }
 6045:       }
 6045:     }
 6045: 
15353:     if (!foundMatch) {
 6788:       // Check if this is an angle attribute going away
 6788:       AngleAttributesInfo angleInfo = GetAngleInfo();
 6788: 
15353:       for (PRUint32 i = 0; i < angleInfo.mAngleCount; i++) {
 6788:         if (aName == *angleInfo.mAngleInfo[i].mName) {
 8288:           angleInfo.Reset(i);
 6788:           DidChangeAngle(i, PR_FALSE);
15353:           foundMatch = PR_TRUE;
15523:           break;
15353:         }
 6788:       }
 6788:     }
 6788: 
15353:     if (!foundMatch) {
 6325:       // Check if this is a boolean attribute going away
 6325:       BooleanAttributesInfo boolInfo = GetBooleanInfo();
 6325: 
15353:       for (PRUint32 i = 0; i < boolInfo.mBooleanCount; i++) {
 6325:         if (aName == *boolInfo.mBooleanInfo[i].mName) {
 8288:           boolInfo.Reset(i);
 6325:           DidChangeBoolean(i, PR_FALSE);
15353:           foundMatch = PR_TRUE;
15353:         }
 6325:       }
 6325:     }
 6325: 
15353:     if (!foundMatch) {
 6045:       // Check if this is an enum attribute going away
 5347:       EnumAttributesInfo enumInfo = GetEnumInfo();
 5347: 
15353:       for (PRUint32 i = 0; i < enumInfo.mEnumCount; i++) {
 5347:         if (aName == *enumInfo.mEnumInfo[i].mName) {
 8288:           enumInfo.Reset(i);
 5347:           DidChangeEnum(i, PR_FALSE);
15353:           foundMatch = PR_TRUE;
15523:           break;
15353:         }
15353:       }
 5347:     }
 5347:   }
 5729: 
15353:   if (!foundMatch) {
15353:     // Check if this is a string attribute going away
15353:     StringAttributesInfo stringInfo = GetStringInfo();
15353: 
15353:     for (PRUint32 i = 0; i < stringInfo.mStringCount; i++) {
15353:       if (aNamespaceID == stringInfo.mStringInfo[i].mNamespaceID &&
15353:           aName == *stringInfo.mStringInfo[i].mName) {
15353:         stringInfo.Reset(i);
15353:         DidChangeString(i, PR_FALSE);
15353:         foundMatch = PR_TRUE;
15523:         break;
15353:       }
15353:     }
15353:   }
15353: 
15353:   if (!foundMatch) {
 5729:     // Now check for one of the old style basetypes going away
 5729:     nsCOMPtr<nsISVGValue> svg_value = GetMappedAttribute(aNamespaceID, aName);
 5729: 
 5729:     if (svg_value) {
 8288:       ResetOldStyleBaseType(svg_value);
 8288:     }
 8288:   }
 8288: 
 8288:   return nsSVGElementBase::UnsetAttr(aNamespaceID, aName, aNotify);
 8288: }
 8288: 
 8288: void
 8288: nsSVGElement::ResetOldStyleBaseType(nsISVGValue *svg_value)
 8288: {
 5729:   nsCOMPtr<nsIDOMSVGAnimatedRect> r = do_QueryInterface(svg_value);
 5729:   if (r) {
 6538:     nsCOMPtr<nsIDOMSVGRect> rect;
 6538:     r->GetBaseVal(getter_AddRefs(rect));
 6538:     static_cast<nsSVGRect*>(rect.get())->Clear();
 5729:   }
 5729:   nsCOMPtr<nsIDOMSVGAnimatedPreserveAspectRatio> ar = do_QueryInterface(svg_value);
 5729:   if (ar) {
 6538:     nsCOMPtr<nsIDOMSVGPreserveAspectRatio> par;
 6538:     ar->GetBaseVal(getter_AddRefs(par));
 5729:     par->SetAlign(nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID);
 5729:     par->SetMeetOrSlice(nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_MEET);
 5729:   }
 5729:   nsCOMPtr<nsIDOMSVGPointList> pl = do_QueryInterface(svg_value);
 5729:   if (pl) {
 5729:     pl->Clear();
 5729:   }
 5729:   nsCOMPtr<nsIDOMSVGAnimatedLengthList> ll = do_QueryInterface(svg_value);
 5729:   if (ll) {
 6538:     nsCOMPtr<nsIDOMSVGLengthList> lengthlist;
 6538:     ll->GetBaseVal(getter_AddRefs(lengthlist));
 5729:     lengthlist->Clear();
 5729:   }
 5729:   nsCOMPtr<nsIDOMSVGAnimatedNumberList> nl = do_QueryInterface(svg_value);
 5729:   if (nl) {
 6538:     nsCOMPtr<nsIDOMSVGNumberList> numberlist;
 6538:     nl->GetBaseVal(getter_AddRefs(numberlist));
 5729:     numberlist->Clear();
 5729:   }
 5729:   nsCOMPtr<nsIDOMSVGAnimatedTransformList> tl = do_QueryInterface(svg_value);
 5729:   if (tl) {
 6538:     nsCOMPtr<nsIDOMSVGTransformList> transform;
 6538:     tl->GetBaseVal(getter_AddRefs(transform));
 5729:     transform->Clear();
 5729:   }
 5729: }
    1: 
16389: nsChangeHint
16389: nsSVGElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
16389:                                      PRInt32 aModType) const
16389: {
16389:   nsChangeHint retval =
16389:     nsSVGElementBase::GetAttributeChangeHint(aAttribute, aModType);
16389: 
16389:   if (aAttribute == nsGkAtoms::requiredFeatures ||
16389:       aAttribute == nsGkAtoms::requiredExtensions ||
16389:       aAttribute == nsGkAtoms::systemLanguage) {
16389:     // It would be nice to only reconstruct the frame if the value returned by
16389:     // NS_SVG_PassesConditionalProcessingTests has changed, but we don't know
16389:     // that
16389:     NS_UpdateHint(retval, nsChangeHint_ReconstructFrame);
16389:   }
16389:   return retval;
16389: }
16389: 
    1: PRBool
    1: nsSVGElement::IsNodeOfType(PRUint32 aFlags) const
    1: {
    1:   return !(aFlags & ~(eCONTENT | eELEMENT | eSVG));
    1: }
    1: 
 9755: already_AddRefed<nsIURI>
 9755: nsSVGElement::GetBaseURI() const
 9755: {
 9755:   nsCOMPtr<nsIURI> baseURI = nsSVGElementBase::GetBaseURI();
 9755: 
 9755:   nsIContent* bindingParent = GetBindingParent();
 9755:   if (bindingParent) {
 9755:     nsIDocument* doc = bindingParent->GetOwnerDoc();
 9755:     if (doc) {
 9755:       nsXBLBinding* binding = doc->BindingManager()->GetBinding(bindingParent);
 9755:       if (binding) {
 9755:         // XXX sXBL/XBL2 issue
 9755:         // If this is an anonymous XBL element use the binding
 9755:         // document for the base URI. 
 9755:         // XXX Will fail with xml:base
 9755:         baseURI = binding->PrototypeBinding()->DocURI();
 9755:       }
 9755:     }
 9755:   }
 9755:   return baseURI.forget();
 9755: }
 9755: 
    1: NS_IMETHODIMP
    1: nsSVGElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
    1: {
    1: #ifdef DEBUG
    1: //  printf("nsSVGElement(%p)::WalkContentStyleRules()\n", this);
    1: #endif
    1:   if (!mContentStyleRule)
    1:     UpdateContentStyleRule();
    1: 
    1:   if (mContentStyleRule)  
    1:     aRuleWalker->Forward(mContentStyleRule);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // PresentationAttributes-FillStroke
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFillStrokeMap[] = {
    1:   { &nsGkAtoms::fill },
    1:   { &nsGkAtoms::fill_opacity },
    1:   { &nsGkAtoms::fill_rule },
    1:   { &nsGkAtoms::stroke },
    1:   { &nsGkAtoms::stroke_dasharray },
    1:   { &nsGkAtoms::stroke_dashoffset },
    1:   { &nsGkAtoms::stroke_linecap },
    1:   { &nsGkAtoms::stroke_linejoin },
    1:   { &nsGkAtoms::stroke_miterlimit },
    1:   { &nsGkAtoms::stroke_opacity },
    1:   { &nsGkAtoms::stroke_width },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Graphics
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sGraphicsMap[] = {
    1:   { &nsGkAtoms::clip_path },
    1:   { &nsGkAtoms::clip_rule },
    1:   { &nsGkAtoms::colorInterpolation },
    1:   { &nsGkAtoms::cursor },
    1:   { &nsGkAtoms::display },
    1:   { &nsGkAtoms::filter },
    1:   { &nsGkAtoms::image_rendering },
    1:   { &nsGkAtoms::mask },
    1:   { &nsGkAtoms::opacity },
    1:   { &nsGkAtoms::pointer_events },
    1:   { &nsGkAtoms::shape_rendering },
    1:   { &nsGkAtoms::text_rendering },
    1:   { &nsGkAtoms::visibility },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-TextContentElements
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sTextContentElementsMap[] = {
    1:   { &nsGkAtoms::alignment_baseline },
    1:   { &nsGkAtoms::baseline_shift },
    1:   { &nsGkAtoms::direction },
    1:   { &nsGkAtoms::dominant_baseline },
    1:   { &nsGkAtoms::glyph_orientation_horizontal },
    1:   { &nsGkAtoms::glyph_orientation_vertical },
    1:   { &nsGkAtoms::kerning },
    1:   { &nsGkAtoms::letter_spacing },
    1:   { &nsGkAtoms::text_anchor },
    1:   { &nsGkAtoms::text_decoration },
    1:   { &nsGkAtoms::unicode_bidi },
    1:   { &nsGkAtoms::word_spacing },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-FontSpecification
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFontSpecificationMap[] = {
    1:   { &nsGkAtoms::font_family },
    1:   { &nsGkAtoms::font_size },
    1:   { &nsGkAtoms::font_size_adjust },
    1:   { &nsGkAtoms::font_stretch },
    1:   { &nsGkAtoms::font_style },
    1:   { &nsGkAtoms::font_variant },
    1:   { &nsGkAtoms::fontWeight },  
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-GradientStop
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sGradientStopMap[] = {
    1:   { &nsGkAtoms::stop_color },
    1:   { &nsGkAtoms::stop_opacity },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Viewports
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sViewportsMap[] = {
    1:   { &nsGkAtoms::overflow },
    1:   { &nsGkAtoms::clip },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Makers
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sMarkersMap[] = {
    1:   { &nsGkAtoms::marker_end },
    1:   { &nsGkAtoms::marker_mid },
    1:   { &nsGkAtoms::marker_start },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Color
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sColorMap[] = {
    1:   { &nsGkAtoms::color },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Filters
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFiltersMap[] = {
    1:   { &nsGkAtoms::colorInterpolationFilters },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-feFlood
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFEFloodMap[] = {
    1:   { &nsGkAtoms::flood_color },
    1:   { &nsGkAtoms::flood_opacity },
    1:   { nsnull }
    1: };
    1: 
 4029: // PresentationAttributes-LightingEffects
 4029: /* static */ const nsGenericElement::MappedAttributeEntry
 4029: nsSVGElement::sLightingEffectsMap[] = {
 4029:   { &nsGkAtoms::lighting_color },
 4029:   { nsnull }
 4029: };
 4029: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMNode methods
    1: 
    1: NS_IMETHODIMP
    1: nsSVGElement::IsSupported(const nsAString& aFeature, const nsAString& aVersion, PRBool* aReturn)
    1: {
    1:   NS_NOTYETIMPLEMENTED("nsSVGElement::IsSupported");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMElement methods
    1: 
    1: // forwarded to nsGenericElement implementations
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMSVGElement methods
    1: 
    1: /* attribute DOMString id; */
    1: NS_IMETHODIMP nsSVGElement::GetId(nsAString & aId)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::id, aId);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSVGElement::SetId(const nsAString & aId)
    1: {
    1:   return SetAttr(kNameSpaceID_None, nsGkAtoms::id, aId, PR_TRUE);
    1: }
    1: 
    1: /* readonly attribute nsIDOMSVGSVGElement ownerSVGElement; */
    1: NS_IMETHODIMP
    1: nsSVGElement::GetOwnerSVGElement(nsIDOMSVGSVGElement * *aOwnerSVGElement)
    1: {
    1:   *aOwnerSVGElement = nsnull;
    1: 
    1:   nsBindingManager *bindingManager = nsnull;
    1:   // XXXbz I _think_ this is right.  We want to be using the binding manager
    1:   // that would have attached the binding that gives us our anonymous parent.
    1:   // That's the binding manager for the document we actually belong to, which
    1:   // is our owner doc.
    1:   nsIDocument* ownerDoc = GetOwnerDoc();
    1:   if (ownerDoc) {
    1:     bindingManager = ownerDoc->BindingManager();
    1:   }
    1: 
    1:   nsIContent* parent = nsnull;
    1:   
    1:   if (bindingManager) {
    1:     // we have a binding manager -- do we have an anonymous parent?
    1:     parent = bindingManager->GetInsertionParent(this);
    1:   }
    1: 
    1:   if (!parent) {
    1:     // if we didn't find an anonymous parent, use the explicit one,
    1:     // whether it's null or not...
    1:     parent = GetParent();
    1:   }
    1: 
10072:   while (parent && parent->GetNameSpaceID() == kNameSpaceID_SVG) {
10072:     nsIAtom* tag = parent->Tag();
10072:     if (tag == nsGkAtoms::foreignObject) {
10072:       // SVG in a foreignObject must have its own <svg> (nsSVGOuterSVGFrame).
10072:       // Leave *aOwnerSVGElement nulled out, but don't throw.
10072:       return NS_OK;
10072:     }
10072:     if (tag == nsGkAtoms::svg) {
10072:       *aOwnerSVGElement = static_cast<nsSVGSVGElement*>(parent);
    1:       NS_ADDREF(*aOwnerSVGElement);
    1:       return NS_OK;
    1:     }
    1:     nsIContent* next = nsnull;
    1: 
    1:     if (bindingManager) {
    1:       next = bindingManager->GetInsertionParent(parent);
    1:     }
    1:     if (!next) {
    1:       // no anonymous parent, so use explicit one
    1:       next = parent->GetParent();
    1:     }
    1:     
    1:     parent = next;
    1:   }
    1: 
    1:   // we don't have a parent SVG element...
    1: 
    1:   // are _we_ the outermost SVG element? If yes, return nsnull, but don't fail
10072:   if (Tag() == nsGkAtoms::svg) {
10072:     return NS_OK;
10072:   }
    1:   
    1:   // no owner found and we aren't the outermost SVG element either.
    1:   // this situation can e.g. occur during content tree teardown. 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* readonly attribute nsIDOMSVGElement viewportElement; */
    1: NS_IMETHODIMP
    1: nsSVGElement::GetViewportElement(nsIDOMSVGElement * *aViewportElement)
    1: {
    1:   *aViewportElement = nsnull;
    1:   nsCOMPtr<nsIDOMSVGSVGElement> SVGSVGElement;
    1:   nsresult rv = GetOwnerSVGElement(getter_AddRefs(SVGSVGElement));
    1:   NS_ENSURE_SUCCESS(rv,rv);
    1:   if (SVGSVGElement) {
    1:     nsCOMPtr<nsIDOMSVGElement> SVGElement = do_QueryInterface(SVGSVGElement);
    1:     *aViewportElement = SVGElement;
    1:     NS_IF_ADDREF(*aViewportElement);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsISVGValueObserver methods:
    1: 
    1: NS_IMETHODIMP
    1: nsSVGElement::WillModifySVGObservable(nsISVGValue* observable,
    1:                                       nsISVGValue::modificationType aModType)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSVGElement::DidModifySVGObservable(nsISVGValue* aObservable,
    1:                                      nsISVGValue::modificationType aModType)
    1: {
    1:   // Return without setting DOM attributes as markup attributes if the
    1:   // attribute's element is being inserted into an SVG document fragment,
    1:   // which provides a context which percentage lengths are relative to.
    1:   // Bug 274886
    1:   if (aModType == nsISVGValue::mod_context)
    1:     return NS_OK;
    1: 
    1:   // Return without setting DOM attribute 
    1:   if (mSuppressNotification)
    1:     return NS_OK;
    1: 
    1:   PRUint32 i, count = mMappedAttributes.AttrCount();
    1:   const nsAttrValue* attrValue = nsnull;
    1:   for (i = 0; i < count; ++i) {
    1:     attrValue = mMappedAttributes.AttrAt(i);
    1:     if (attrValue->GetSVGValue() == aObservable) {
    1:       break;
    1:     }
    1:   }
    1: 
    1:   if (i == count) {
    1:     NS_NOTREACHED("unknown nsISVGValue");
    1: 
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   const nsAttrName* attrName = mMappedAttributes.AttrNameAt(i);
    1:   PRBool modification = PR_FALSE;
    1:   PRBool hasListeners =
    1:     nsContentUtils::HasMutationListeners(this,
 3137:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
 3137:                                          this);
    1: 
    1:   if (hasListeners || IsInDoc()) {
    1:     modification = !!mAttrsAndChildren.GetAttr(attrName->LocalName(),
    1:                                                attrName->NamespaceID());
    1:   }
    1: 
    1:   nsAttrValue newValue(aObservable);
    1: 
    1:   return SetAttrAndNotify(attrName->NamespaceID(), attrName->LocalName(),
    1:                           attrName->GetPrefix(), EmptyString(), newValue,
22222:                           modification, hasListeners, PR_TRUE, nsnull);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // Implementation Helpers:
    1: 
    1: PRBool
    1: nsSVGElement::IsEventName(nsIAtom* aName)
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsSVGElement::UpdateContentStyleRule()
    1: {
    1:   NS_ASSERTION(!mContentStyleRule, "we already have a content style rule");
    1:   
    1:   nsIDocument* doc = GetOwnerDoc();
    1:   if (!doc) {
    1:     NS_ERROR("SVG element without owner document");
    1:     return;
    1:   }
    1:   
    1:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
    1:   nsIURI *docURI = doc->GetDocumentURI();
    1:   nsICSSLoader* cssLoader = doc->CSSLoader();
    1: 
    1:   nsCSSDeclaration* declaration = nsnull;
    1:   nsCOMPtr<nsICSSParser> parser;
    1: 
    1:   nsresult rv = NS_OK; 
    1: 
    1:   PRUint32 attrCount = mAttrsAndChildren.AttrCount();
    1:   for (PRUint32 i = 0; i < attrCount; ++i) {
    1:     const nsAttrName* attrName = mAttrsAndChildren.AttrNameAt(i);
    1:     if (!attrName->IsAtom() || !IsAttributeMapped(attrName->Atom()))
    1:       continue;
    1: 
    1:     if (!declaration) {
    1:       // Create the nsCSSDeclaration.
    1:       declaration = new nsCSSDeclaration();
    1:       if (!declaration) {
    1:         NS_WARNING("Failed to allocate nsCSSDeclaration");
    1:         return;
    1:       }
    1:       if (!declaration->InitializeEmpty()) {
    1:         NS_WARNING("could not initialize nsCSSDeclaration");
    1:         declaration->RuleAbort();  // deletes declaration
    1:         return;
    1:       }
    1: 
    1:       // Try to fetch the CSS Parser from the document.
    1:       rv = cssLoader->GetParserFor(nsnull, getter_AddRefs(parser));
    1:       if (NS_FAILED(rv)) {
    1:         NS_WARNING("failed to get a css parser");
    1:         declaration->RuleAbort();  // deletes declaration
    1:         return;
    1:       }
    1: 
    1:       // SVG and CSS differ slightly in their interpretation of some of
    1:       // the attributes.  SVG allows attributes of the form: font-size="5" 
    1:       // (style="font-size: 5" if using a style attribute)
    1:       // where CSS requires units: font-size="5pt" (style="font-size: 5pt")
    1:       // Set a flag to pass information to the parser so that we can use
    1:       // the CSS parser to parse the font-size attribute.  Note that this
15717:       // does *not* affect the use of CSS stylesheets, which will still
15717:       // require units.
    1:       parser->SetSVGMode(PR_TRUE);
    1:     }
    1: 
    1:     nsAutoString name;
    1:     attrName->Atom()->ToString(name);
    1: 
    1:     nsAutoString value;
    1:     mAttrsAndChildren.AttrAt(i)->ToString(value);
    1: 
    1:     PRBool changed;
    1:     parser->ParseProperty(nsCSSProps::LookupProperty(name), value,
 1036:                           docURI, baseURI, NodePrincipal(),
    1:                           declaration, &changed);
    1:   }
    1: 
    1:   if (declaration) {
    1:     rv = NS_NewCSSStyleRule(getter_AddRefs(mContentStyleRule), nsnull, declaration);
    1:     if (NS_FAILED(rv)) {
    1:       NS_WARNING("could not create contentstylerule");
    1:       declaration->RuleAbort();  // deletes declaration
    1:     }
    1: 
    1:     // Recycle the parser
    1:     parser->SetSVGMode(PR_FALSE);
    1:     cssLoader->RecycleParser(parser);
    1:   }
    1: }
    1: 
    1: nsISVGValue*
    1: nsSVGElement::GetMappedAttribute(PRInt32 aNamespaceID, nsIAtom* aName)
    1: {
    1:   const nsAttrValue* attrVal = mMappedAttributes.GetAttr(aName, aNamespaceID);
    1:   if (!attrVal)
    1:     return nsnull;
    1: 
    1:   return attrVal->GetSVGValue();
    1: }
    1: 
    1: nsresult
    1: nsSVGElement::AddMappedSVGValue(nsIAtom* aName, nsISupports* aValue,
    1:                                 PRInt32 aNamespaceID)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsISVGValue> svg_value = do_QueryInterface(aValue);
    1:   svg_value->AddObserver(this);
    1:   nsAttrValue attrVal(svg_value);
    1: 
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     rv = mMappedAttributes.SetAndTakeAttr(aName, attrVal);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   else {
    1:     nsCOMPtr<nsINodeInfo> ni;
19197:     ni = mNodeInfo->NodeInfoManager()->GetNodeInfo(aName, nsnull,
19197:                                                    aNamespaceID);
19747:     NS_ENSURE_TRUE(ni, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     rv = mMappedAttributes.SetAndTakeAttr(ni, attrVal);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsIAtom* nsSVGElement::GetEventNameForAttr(nsIAtom* aAttr)
    1: {
    1:   if (aAttr == nsGkAtoms::onload)
    1:     return nsGkAtoms::onSVGLoad;
    1:   if (aAttr == nsGkAtoms::onunload)
    1:     return nsGkAtoms::onSVGUnload;
    1:   if (aAttr == nsGkAtoms::onabort)
    1:     return nsGkAtoms::onSVGAbort;
    1:   if (aAttr == nsGkAtoms::onerror)
    1:     return nsGkAtoms::onSVGError;
    1:   if (aAttr == nsGkAtoms::onresize)
    1:     return nsGkAtoms::onSVGResize;
    1:   if (aAttr == nsGkAtoms::onscroll)
    1:     return nsGkAtoms::onSVGScroll;
    1:   if (aAttr == nsGkAtoms::onzoom)
    1:     return nsGkAtoms::onSVGZoom;
    1: 
    1:   return aAttr;
    1: }
    1: 
    1: nsSVGSVGElement *
    1: nsSVGElement::GetCtx()
    1: {
    1:   nsCOMPtr<nsIDOMSVGSVGElement> svg;
    1:   GetOwnerSVGElement(getter_AddRefs(svg));
 3233:   return static_cast<nsSVGSVGElement*>(svg.get());
    1: }
    1: 
    1: nsSVGElement::LengthAttributesInfo
    1: nsSVGElement::GetLengthInfo()
    1: {
    1:   return LengthAttributesInfo(nsnull, nsnull, 0);
    1: }
    1: 
 8288: void nsSVGElement::LengthAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mLengths[aAttrEnum].Init(mLengthInfo[aAttrEnum].mCtxType,
 8288:                            aAttrEnum,
 8288:                            mLengthInfo[aAttrEnum].mDefaultValue,
 8288:                            mLengthInfo[aAttrEnum].mDefaultUnitType);
 8288: }
 8288: 
    1: void
    1: nsSVGElement::DidChangeLength(PRUint8 aAttrEnum, PRBool aDoSetAttr)
    1: {
    1:   if (!aDoSetAttr)
    1:     return;
    1: 
    1:   LengthAttributesInfo info = GetLengthInfo();
    1: 
    1:   NS_ASSERTION(info.mLengthCount > 0,
    1:                "DidChangeLength on element with no length attribs");
    1: 
    1:   NS_ASSERTION(aAttrEnum < info.mLengthCount, "aAttrEnum out of range");
    1: 
    1:   nsAutoString newStr;
    1:   info.mLengths[aAttrEnum].GetBaseValueString(newStr);
    1: 
    1:   SetAttr(kNameSpaceID_None, *info.mLengthInfo[aAttrEnum].mName,
    1:           newStr, PR_TRUE);
    1: }
    1: 
    1: void
    1: nsSVGElement::GetAnimatedLengthValues(float *aFirst, ...)
    1: {
    1:   LengthAttributesInfo info = GetLengthInfo();
    1: 
    1:   NS_ASSERTION(info.mLengthCount > 0,
    1:                "GetAnimatedLengthValues on element with no length attribs");
    1: 
    1:   nsSVGSVGElement *ctx = nsnull;
    1: 
    1:   float *f = aFirst;
    1:   PRUint32 i = 0;
    1: 
    1:   va_list args;
    1:   va_start(args, aFirst);
    1: 
    1:   while (f && i < info.mLengthCount) {
 2755:     PRUint8 type = info.mLengths[i].GetSpecifiedUnitType();
    1:     if (!ctx) {
    1:       if (type != nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER &&
    1:           type != nsIDOMSVGLength::SVG_LENGTHTYPE_PX)
    1:         ctx = GetCtx();
    1:     }
 2755:     if (type == nsIDOMSVGLength::SVG_LENGTHTYPE_EMS ||
 2755:         type == nsIDOMSVGLength::SVG_LENGTHTYPE_EXS)
 2755:       *f = info.mLengths[i++].GetAnimValue(this);
 2755:     else
    1:       *f = info.mLengths[i++].GetAnimValue(ctx);
    1:     f = va_arg(args, float*);
    1:   }
    1: 
    1:   va_end(args);
    1: }
    1: 
    1: nsSVGElement::NumberAttributesInfo
    1: nsSVGElement::GetNumberInfo()
    1: {
    1:   return NumberAttributesInfo(nsnull, nsnull, 0);
    1: }
    1: 
 8288: void nsSVGElement::NumberAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mNumbers[aAttrEnum].Init(aAttrEnum,
 8288:                            mNumberInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
    1: void
    1: nsSVGElement::DidChangeNumber(PRUint8 aAttrEnum, PRBool aDoSetAttr)
    1: {
    1:   if (!aDoSetAttr)
    1:     return;
    1: 
    1:   NumberAttributesInfo info = GetNumberInfo();
    1: 
    1:   NS_ASSERTION(info.mNumberCount > 0,
    1:                "DidChangeNumber on element with no number attribs");
    1: 
    1:   NS_ASSERTION(aAttrEnum < info.mNumberCount, "aAttrEnum out of range");
    1: 
    1:   nsAutoString newStr;
    1:   info.mNumbers[aAttrEnum].GetBaseValueString(newStr);
    1: 
    1:   SetAttr(kNameSpaceID_None, *info.mNumberInfo[aAttrEnum].mName,
    1:           newStr, PR_TRUE);
    1: }
    1: 
    1: void
    1: nsSVGElement::GetAnimatedNumberValues(float *aFirst, ...)
    1: {
    1:   NumberAttributesInfo info = GetNumberInfo();
    1: 
    1:   NS_ASSERTION(info.mNumberCount > 0,
    1:                "GetAnimatedNumberValues on element with no number attribs");
    1: 
    1:   float *f = aFirst;
    1:   PRUint32 i = 0;
    1: 
    1:   va_list args;
    1:   va_start(args, aFirst);
    1: 
    1:   while (f && i < info.mNumberCount) {
    1:     *f = info.mNumbers[i++].GetAnimValue();
    1:     f = va_arg(args, float*);
    1:   }
    1:   va_end(args);
    1: }
    1: 
 6045: nsSVGElement::IntegerAttributesInfo
 6045: nsSVGElement::GetIntegerInfo()
 6045: {
 6045:   return IntegerAttributesInfo(nsnull, nsnull, 0);
 6045: }
 6045: 
 8288: void nsSVGElement::IntegerAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mIntegers[aAttrEnum].Init(aAttrEnum,
 8288:                             mIntegerInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
 6045: void
 6045: nsSVGElement::DidChangeInteger(PRUint8 aAttrEnum, PRBool aDoSetAttr)
 6045: {
 6045:   if (!aDoSetAttr)
 6045:     return;
 6045: 
 6045:   IntegerAttributesInfo info = GetIntegerInfo();
 6045: 
 6045:   NS_ASSERTION(info.mIntegerCount > 0,
 6045:                "DidChangeInteger on element with no integer attribs");
 6045: 
 6045:   NS_ASSERTION(aAttrEnum < info.mIntegerCount, "aAttrEnum out of range");
 6045: 
 6045:   nsAutoString newStr;
 6045:   info.mIntegers[aAttrEnum].GetBaseValueString(newStr);
 6045: 
 6045:   SetAttr(kNameSpaceID_None, *info.mIntegerInfo[aAttrEnum].mName,
 6045:           newStr, PR_TRUE);
 6045: }
 6045: 
 6045: void
 6045: nsSVGElement::GetAnimatedIntegerValues(PRInt32 *aFirst, ...)
 6045: {
 6045:   IntegerAttributesInfo info = GetIntegerInfo();
 6045: 
 6045:   NS_ASSERTION(info.mIntegerCount > 0,
 6045:                "GetAnimatedIntegerValues on element with no integer attribs");
 6045: 
 6045:   PRInt32 *n = aFirst;
 6045:   PRUint32 i = 0;
 6045: 
 6045:   va_list args;
 6045:   va_start(args, aFirst);
 6045: 
 6045:   while (n && i < info.mIntegerCount) {
 6045:     *n = info.mIntegers[i++].GetAnimValue();
 6045:     n = va_arg(args, PRInt32*);
 6045:   }
 6045:   va_end(args);
 6045: }
 6045: 
 6788: nsSVGElement::AngleAttributesInfo
 6788: nsSVGElement::GetAngleInfo()
 6788: {
 6788:   return AngleAttributesInfo(nsnull, nsnull, 0);
 6788: }
 6788: 
 8288: void nsSVGElement::AngleAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mAngles[aAttrEnum].Init(aAttrEnum, 
 8288:                           mAngleInfo[aAttrEnum].mDefaultValue,
 8288:                           mAngleInfo[aAttrEnum].mDefaultUnitType);
 8288: }
 8288: 
 6788: void
 6788: nsSVGElement::DidChangeAngle(PRUint8 aAttrEnum, PRBool aDoSetAttr)
 6788: {
 6788:   if (!aDoSetAttr)
 6788:     return;
 6788: 
 6788:   AngleAttributesInfo info = GetAngleInfo();
 6788: 
 6788:   NS_ASSERTION(info.mAngleCount > 0,
 6788:                "DidChangeAngle on element with no angle attribs");
 6788: 
 6788:   NS_ASSERTION(aAttrEnum < info.mAngleCount, "aAttrEnum out of range");
 6788: 
 6788:   nsAutoString newStr;
 6788:   info.mAngles[aAttrEnum].GetBaseValueString(newStr);
 6788: 
 6788:   SetAttr(kNameSpaceID_None, *info.mAngleInfo[aAttrEnum].mName,
 6788:           newStr, PR_TRUE);
 6788: }
 6788: 
 6325: nsSVGElement::BooleanAttributesInfo
 6325: nsSVGElement::GetBooleanInfo()
 6325: {
 6325:   return BooleanAttributesInfo(nsnull, nsnull, 0);
 6325: }
 6325: 
 8288: void nsSVGElement::BooleanAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mBooleans[aAttrEnum].Init(aAttrEnum,
 8288:                             mBooleanInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
 6325: void
 6325: nsSVGElement::DidChangeBoolean(PRUint8 aAttrEnum, PRBool aDoSetAttr)
 6325: {
 6325:   if (!aDoSetAttr)
 6325:     return;
 6325: 
 6325:   BooleanAttributesInfo info = GetBooleanInfo();
 6325: 
 6325:   NS_ASSERTION(info.mBooleanCount > 0,
 6788:                "DidChangeBoolean on element with no boolean attribs");
 6325: 
 6325:   NS_ASSERTION(aAttrEnum < info.mBooleanCount, "aAttrEnum out of range");
 6325: 
 6325:   nsAutoString newStr;
 6325:   info.mBooleans[aAttrEnum].GetBaseValueString(newStr);
 6325: 
 6325:   SetAttr(kNameSpaceID_None, *info.mBooleanInfo[aAttrEnum].mName,
 6325:           newStr, PR_TRUE);
 6325: }
 6325: 
 5347: nsSVGElement::EnumAttributesInfo
 5347: nsSVGElement::GetEnumInfo()
 5347: {
 5347:   return EnumAttributesInfo(nsnull, nsnull, 0);
 5347: }
 5347: 
 8288: void nsSVGElement::EnumAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mEnums[aAttrEnum].Init(aAttrEnum,
 8288:                          mEnumInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
 5347: void
 5347: nsSVGElement::DidChangeEnum(PRUint8 aAttrEnum, PRBool aDoSetAttr)
 5347: {
 5347:   if (!aDoSetAttr)
 5347:     return;
 5347: 
 5347:   EnumAttributesInfo info = GetEnumInfo();
 5347: 
 5347:   NS_ASSERTION(info.mEnumCount > 0,
 6045:                "DidChangeEnum on element with no enum attribs");
 5347: 
 5347:   NS_ASSERTION(aAttrEnum < info.mEnumCount, "aAttrEnum out of range");
 5347: 
 5347:   nsAutoString newStr;
 5347:   info.mEnums[aAttrEnum].GetBaseValueString(newStr, this);
 5347: 
 5347:   SetAttr(kNameSpaceID_None, *info.mEnumInfo[aAttrEnum].mName,
 5347:           newStr, PR_TRUE);
 5347: }
 5347: 
15353: nsSVGElement::StringAttributesInfo
15353: nsSVGElement::GetStringInfo()
15353: {
15353:   return StringAttributesInfo(nsnull, nsnull, 0);
15353: }
15353: 
15353: void nsSVGElement::StringAttributesInfo::Reset(PRUint8 aAttrEnum)
15353: {
15353:   mStrings[aAttrEnum].Init(aAttrEnum);
15353: }
15353: 
15353: void
15353: nsSVGElement::DidChangeString(PRUint8 aAttrEnum, PRBool aDoSetAttr)
15353: {
15353:   if (!aDoSetAttr)
15353:     return;
15353: 
15353:   StringAttributesInfo info = GetStringInfo();
15353: 
15353:   NS_ASSERTION(info.mStringCount > 0,
15353:                "DidChangeString on element with no string attribs");
15353: 
15353:   NS_ASSERTION(aAttrEnum < info.mStringCount, "aAttrEnum out of range");
15353: 
15353:   SetAttr(info.mStringInfo[aAttrEnum].mNamespaceID,
15353:           *info.mStringInfo[aAttrEnum].mName,
15353:           info.mStrings[aAttrEnum].GetBaseValue(), PR_TRUE);
15353: }
15353: 
15523: nsresult
15523: nsSVGElement::ParseNumberOptionalNumber(const nsAString& aValue,
15523:                                         PRUint32 aIndex1, PRUint32 aIndex2)
 6944: {
 6944:   NS_ConvertUTF16toUTF8 value(aValue);
 6944:   const char *str = value.get();
 6944: 
15523:   if (NS_IsAsciiWhitespace(*str))
15523:     return NS_ERROR_FAILURE;
 6944: 
 6944:   char *rest;
15523:   float x = float(PR_strtod(str, &rest));
15523:   float y = x;
 6944: 
 6944:   if (str == rest) {
 6944:     //first value was illformed
15523:     return NS_ERROR_FAILURE;
15523:   }
15523:   
15523:   if (*rest != '\0') {
 6944:     while (NS_IsAsciiWhitespace(*rest)) {
 6944:       ++rest;
 6944:     }
 6944:     if (*rest == ',') {
 6944:       ++rest;
 6944:     }
 6944: 
 6944:     y = float(PR_strtod(rest, &rest));
 6944:     if (*rest != '\0') {
 6944:       //second value was illformed or there was trailing content
15523:       return NS_ERROR_FAILURE;
 6944:     }
 6944:   }
 6944: 
 6944:   NumberAttributesInfo numberInfo = GetNumberInfo();
 6944: 
15523:   numberInfo.mNumbers[aIndex1].SetBaseValue(x, this, PR_FALSE);
15523:   numberInfo.mNumbers[aIndex2].SetBaseValue(y, this, PR_FALSE);
15523:   return NS_OK;
 6944: }
 6944: 
15523: nsresult
15523: nsSVGElement::ParseIntegerOptionalInteger(const nsAString& aValue,
15523:                                           PRUint32 aIndex1, PRUint32 aIndex2)
 6944: {
 6944:   NS_ConvertUTF16toUTF8 value(aValue);
 6944:   const char *str = value.get();
 6944: 
15523:   if (NS_IsAsciiWhitespace(*str))
15523:     return NS_ERROR_FAILURE;
 6944: 
 6944:   char *rest;
15523:   PRInt32 x = strtol(str, &rest, 10);
15523:   PRInt32 y = x;
 6944: 
 6944:   if (str == rest) {
 6944:     //first value was illformed
15523:     return NS_ERROR_FAILURE;
15523:   }
15523:   
15523:   if (*rest != '\0') {
 6944:     while (NS_IsAsciiWhitespace(*rest)) {
 6944:       ++rest;
 6944:     }
 6944:     if (*rest == ',') {
 6944:       ++rest;
 6944:     }
 6944: 
 6944:     y = strtol(rest, &rest, 10);
 6944:     if (*rest != '\0') {
 6944:       //second value was illformed or there was trailing content
15523:       return NS_ERROR_FAILURE;
 6944:     }
 6944:   }
 6944: 
 6944:   IntegerAttributesInfo integerInfo = GetIntegerInfo();
 6944: 
 6944:   integerInfo.mIntegers[aIndex1].SetBaseValue(x, this, PR_FALSE);
 6944:   integerInfo.mIntegers[aIndex2].SetBaseValue(y, this, PR_FALSE);
 6944: 
15523:   return NS_OK;
 6944: }
 6944: 
    1: nsresult
    1: nsSVGElement::ReportAttributeParseFailure(nsIDocument* aDocument,
    1:                                           nsIAtom* aAttribute,
    1:                                           const nsAString& aValue)
    1: {
    1:   nsAutoString attributeName;
    1:   aAttribute->ToString(attributeName);
    1:   const nsAFlatString& attributeValue = PromiseFlatString(aValue);
    1:   const PRUnichar *strings[] = { attributeName.get(), attributeValue.get() };
    1:   return nsSVGUtils::ReportToConsole(aDocument,
    1:                                      "AttributeParseWarning",
    1:                                      strings, NS_ARRAY_LENGTH(strings));
    1: }
    1: 
    1: void
    1: nsSVGElement::RecompileScriptEventListeners()
    1: {
    1:   PRInt32 i, count = mAttrsAndChildren.AttrCount();
    1:   for (i = 0; i < count; ++i) {
    1:     const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
    1: 
    1:     // Eventlistenener-attributes are always in the null namespace
    1:     if (!name->IsAtom()) {
    1:         continue;
    1:     }
    1: 
    1:     nsIAtom *attr = name->Atom();
    1:     if (!IsEventName(attr)) {
    1:       continue;
    1:     }
    1: 
    1:     nsAutoString value;
    1:     GetAttr(kNameSpaceID_None, attr, value);
    1:     AddScriptEventListener(GetEventNameForAttr(attr), value, PR_TRUE);
    1:   }
    1: }
