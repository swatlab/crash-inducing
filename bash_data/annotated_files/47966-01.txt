37530: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
37530: /* ***** BEGIN LICENSE BLOCK *****
37530:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
37530:  *
37530:  * The contents of this file are subject to the Mozilla Public License Version
37530:  * 1.1 (the "License"); you may not use this file except in compliance with
37530:  * the License. You may obtain a copy of the License at
37530:  * http://www.mozilla.org/MPL/
37530:  *
37530:  * Software distributed under the License is distributed on an "AS IS" basis,
37530:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
37530:  * for the specific language governing rights and limitations under the
37530:  * License.
37530:  *
37530:  * The Original Code is mozilla.org code.
37530:  *
37530:  * The Initial Developer of the Original Code is
37530:  * Netscape Communications Corporation.
37530:  * Portions created by the Initial Developer are Copyright (C) 1998
37530:  * the Initial Developer. All Rights Reserved.
37530:  *
37530:  * Contributor(s):
37530:  *   Josh Aas <josh@mozilla.com>
37530:  *   Thomas K. Dyas <tom.dyas@gmail.com>
37530:  *
37530:  * Alternatively, the contents of this file may be used under the terms of
37530:  * either the GNU General Public License Version 2 or later (the "GPL"), or
37530:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
37530:  * in which case the provisions of the GPL or the LGPL are applicable instead
37530:  * of those above. If you wish to allow use of your version of this file only
37530:  * under the terms of either the GPL or the LGPL, and not to allow others to
37530:  * use your version of this file under the terms of the MPL, indicate your
37530:  * decision by deleting the provisions above and replace them with the notice
37530:  * and other provisions required by the GPL or the LGPL. If you do not delete
37530:  * the provisions above, a recipient may use your version of this file under
37530:  * the terms of any one of the MPL, the GPL or the LGPL.
37530:  *
37530:  * ***** END LICENSE BLOCK ***** */
37530: 
37530: #include "nsMenuGroupOwnerX.h"
37530: #include "nsMenuBarX.h"
37530: #include "nsMenuX.h"
37530: #include "nsMenuItemX.h"
37530: #include "nsMenuUtilsX.h"
37530: #include "nsCocoaUtils.h"
37530: #include "nsCocoaWindow.h"
37530: 
37530: #include "nsCOMPtr.h"
37530: #include "nsString.h"
37530: #include "nsWidgetAtoms.h"
37530: #include "nsGUIEvent.h"
37530: #include "nsObjCExceptions.h"
37530: #include "nsHashtable.h"
37530: #include "nsThreadUtils.h"
37530: 
37530: #include "nsIContent.h"
37530: #include "nsIWidget.h"
37530: #include "nsIDocument.h"
37530: #include "nsIDOMDocument.h"
37530: #include "nsIDOMElement.h"
37530: 
37530: #include "nsINode.h"
37530: 
37530: NS_IMPL_ISUPPORTS1(nsMenuGroupOwnerX, nsIMutationObserver)
37530: 
37530: 
37530: nsMenuGroupOwnerX::nsMenuGroupOwnerX()
37530: : mCurrentCommandID(eCommand_ID_Last),
37530:   mDocument(nsnull)
37530: {
37530:   mContentToObserverTable.Init();
37530:   mCommandToMenuObjectTable.Init();
37530: }
37530: 
37530: 
37530: nsMenuGroupOwnerX::~nsMenuGroupOwnerX()
37530: {
37530:   // make sure we unregister ourselves as a document observer
37530:   if (mDocument)
37530:     mDocument->RemoveMutationObserver(this);
37530: }
37530: 
37530: 
37530: nsresult nsMenuGroupOwnerX::Create(nsIContent* aContent)
37530: {
37530:   if (!aContent)
37530:     return NS_ERROR_INVALID_ARG;
37530: 
37530:   mContent = aContent;
37530: 
37530:   nsIDocument* doc = aContent->GetOwnerDoc();
37530:   if (!doc)
37530:     return NS_ERROR_FAILURE;
37530:   doc->AddMutationObserver(this);
37530:   mDocument = doc;
37530: 
37530:   return NS_OK;
37530: }
37530: 
37530: 
37530: //
37530: // nsIMutationObserver
37530: //
37530: 
37530: 
37530: void nsMenuGroupOwnerX::CharacterDataWillChange(nsIDocument* aDocument,
37530:                                                 nsIContent* aContent,
37530:                                                 CharacterDataChangeInfo* aInfo)
37530: {
37530: }
37530: 
37530: 
37530: void nsMenuGroupOwnerX::CharacterDataChanged(nsIDocument* aDocument,
37530:                                              nsIContent* aContent,
37530:                                              CharacterDataChangeInfo* aInfo)
37530: {
37530: }
37530: 
37530: 
37530: void nsMenuGroupOwnerX::ContentAppended(nsIDocument* aDocument,
37530:                                         nsIContent* aContainer,
42107:                                         nsIContent* aFirstNewContent,
37530:                                         PRInt32 aNewIndexInContainer)
37530: {
42107:   for (nsIContent* cur = aFirstNewContent; cur; cur = cur->GetNextSibling()) {
42107:     ContentInserted(aDocument, aContainer, cur, aNewIndexInContainer);
37530:     aNewIndexInContainer++;
37530:   }
37530: }
37530: 
37530: 
37530: void nsMenuGroupOwnerX::NodeWillBeDestroyed(const nsINode * aNode)
37530: {
37530:   // our menu bar node is being destroyed
37530:   mDocument = nsnull;
37530: }
37530: 
37530: 
37530: void nsMenuGroupOwnerX::AttributeWillChange(nsIDocument* aDocument,
37530:                                             nsIContent* aContent,
37530:                                             PRInt32 aNameSpaceID,
37530:                                             nsIAtom* aAttribute,
37530:                                             PRInt32 aModType)
37530: {
37530: }
37530: 
37530: 
37530: void nsMenuGroupOwnerX::AttributeChanged(nsIDocument * aDocument,
37530:                                          nsIContent * aContent,
37530:                                          PRInt32 aNameSpaceID,
37530:                                          nsIAtom * aAttribute,
37530:                                          PRInt32 aModType)
37530: {
37530:   nsChangeObserver* obs = LookupContentChangeObserver(aContent);
37530:   if (obs)
37530:     obs->ObserveAttributeChanged(aDocument, aContent, aAttribute);
37530: }
37530: 
37530: 
37530: void nsMenuGroupOwnerX::ContentRemoved(nsIDocument * aDocument,
37530:                                        nsIContent * aContainer,
37530:                                        nsIContent * aChild,
37530:                                        PRInt32 aIndexInContainer)
37530: {
37530:   nsChangeObserver* obs = LookupContentChangeObserver(aContainer);
37617:   if (obs)
37530:     obs->ObserveContentRemoved(aDocument, aChild, aIndexInContainer);
47966:   else if (aContainer && (aContainer != mContent)) {
37530:     // We do a lookup on the parent container in case things were removed
37530:     // under a "menupopup" item. That is basically a wrapper for the contents
37530:     // of a "menu" node.
37530:     nsCOMPtr<nsIContent> parent = aContainer->GetParent();
37530:     if (parent) {
37530:       obs = LookupContentChangeObserver(parent);
37530:       if (obs)
37530:         obs->ObserveContentRemoved(aDocument, aChild, aIndexInContainer);
37530:     }
37530:   }
37530: }
37530: 
37530: 
37530: void nsMenuGroupOwnerX::ContentInserted(nsIDocument * aDocument,
37530:                                         nsIContent * aContainer,
37530:                                         nsIContent * aChild,
37530:                                         PRInt32 aIndexInContainer)
37530: {
37530:   nsChangeObserver* obs = LookupContentChangeObserver(aContainer);
37530:   if (obs)
37530:     obs->ObserveContentInserted(aDocument, aChild, aIndexInContainer);
37617:   else if (aContainer != mContent) {
37530:     // We do a lookup on the parent container in case things were removed
37530:     // under a "menupopup" item. That is basically a wrapper for the contents
37530:     // of a "menu" node.
37530:     nsCOMPtr<nsIContent> parent = aContainer->GetParent();
37530:     if (parent) {
37530:       obs = LookupContentChangeObserver(parent);
37530:       if (obs)
37530:         obs->ObserveContentInserted(aDocument, aChild, aIndexInContainer);
37530:     }
37530:   }
37530: }
37530: 
37530: 
37530: void nsMenuGroupOwnerX::ParentChainChanged(nsIContent *aContent)
37530: {
37530: }
37530: 
37530: 
37530: // For change management, we don't use a |nsSupportsHashtable| because
37530: // we know that the lifetime of all these items is bounded by the
37530: // lifetime of the menubar. No need to add any more strong refs to the
37530: // picture because the containment hierarchy already uses strong refs.
37530: void nsMenuGroupOwnerX::RegisterForContentChanges(nsIContent *aContent,
37530:                                                   nsChangeObserver *aMenuObject)
37530: {
37530:   mContentToObserverTable.Put(aContent, aMenuObject);
37530: }
37530: 
37530: 
37530: void nsMenuGroupOwnerX::UnregisterForContentChanges(nsIContent *aContent)
37530: {
37530:   mContentToObserverTable.Remove(aContent);
37530: }
37530: 
37530: 
37530: nsChangeObserver* nsMenuGroupOwnerX::LookupContentChangeObserver(nsIContent* aContent)
37530: {
37530:   nsChangeObserver * result;
37530:   if (mContentToObserverTable.Get(aContent, &result))
37530:     return result;
37530:   else
37530:     return nsnull;
37530: }
37530: 
37530: 
37530: // Given a menu item, creates a unique 4-character command ID and
37530: // maps it to the item. Returns the id for use by the client.
37530: PRUint32 nsMenuGroupOwnerX::RegisterForCommand(nsMenuItemX* inMenuItem)
37530: {
37530:   // no real need to check for uniqueness. We always start afresh with each
37530:   // window at 1. Even if we did get close to the reserved Apple command id's,
37530:   // those don't start until at least '    ', which is integer 538976288. If
37530:   // we have that many menu items in one window, I think we have other
37530:   // problems.
37530: 
37530:   // make id unique
37530:   ++mCurrentCommandID;
37530: 
37530:   mCommandToMenuObjectTable.Put(mCurrentCommandID, inMenuItem);
37530: 
37530:   return mCurrentCommandID;
37530: }
37530: 
37530: 
37530: // Removes the mapping between the given 4-character command ID
37530: // and its associated menu item.
37530: void nsMenuGroupOwnerX::UnregisterCommand(PRUint32 inCommandID)
37530: {
37530:   mCommandToMenuObjectTable.Remove(inCommandID);
37530: }
37530: 
37530: 
37530: nsMenuItemX* nsMenuGroupOwnerX::GetMenuItemForCommandID(PRUint32 inCommandID)
37530: {
37530:   nsMenuItemX * result;
37530:   if (mCommandToMenuObjectTable.Get(inCommandID, &result))
37530:     return result;
37530:   else
37530:     return nsnull;
37530: }
