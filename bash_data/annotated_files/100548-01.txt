     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "windows.h"
     1: #include "windowsx.h"
     1: 
     1: // XXXbz windowsx.h defines GetFirstChild, GetNextSibling,
     1: // GetPrevSibling are macros, apparently... Eeevil.  We have functions
     1: // called that on some classes, so undef them.
     1: #undef GetFirstChild
     1: #undef GetNextSibling
     1: #undef GetPrevSibling
     1: 
     1: #include "nsDebug.h"
     1: 
     1: #include "nsGUIEvent.h"
 56342: #include "nsWindowsDllInterceptor.h"
     1: #include "nsPluginSafety.h"
     1: #include "nsPluginNativeWindow.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsTWeakRef.h"
 62476: #include "nsCrashOnException.h"
 62476: 
 95091: using namespace mozilla;
 95091: 
 32799: #define NP_POPUP_API_VERSION 16
 32799: 
 32799: #define nsMajorVersion(v)       (((PRInt32)(v) >> 16) & 0xffff)
 32799: #define nsMinorVersion(v)       ((PRInt32)(v) & 0xffff)
 32799: #define versionOK(suppliedV, requiredV)                   \
 32799:   (nsMajorVersion(suppliedV) == nsMajorVersion(requiredV) \
 32799:    && nsMinorVersion(suppliedV) >= nsMinorVersion(requiredV))
 32799: 
 32799: 
 25861: #define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION TEXT("MozillaPluginWindowPropertyAssociation")
 29473: #define NS_PLUGIN_CUSTOM_MSG_ID TEXT("MozFlashUserRelay")
 29473: #define WM_USER_FLASH WM_USER+1
 29473: static UINT sWM_FLASHBOUNCEMSG = 0;
     1: 
     1: typedef nsTWeakRef<class nsPluginNativeWindowWin> PluginWindowWeakRef;
     1: 
     1: /**
     1:  *  PLEvent handling code
     1:  */
     1: class PluginWindowEvent : public nsRunnable {
     1: public:
     1:   PluginWindowEvent();
     1:   void Init(const PluginWindowWeakRef &ref, HWND hWnd, UINT msg, WPARAM wParam,
     1:             LPARAM lParam);
     1:   void Clear();
     1:   HWND   GetWnd()    { return mWnd; };
     1:   UINT   GetMsg()    { return mMsg; };
     1:   WPARAM GetWParam() { return mWParam; };
     1:   LPARAM GetLParam() { return mLParam; };
 79445:   bool InUse()     { return (mWnd!=NULL); };
     1: 
     1:   NS_DECL_NSIRUNNABLE
     1: 
     1: protected:
     1:   PluginWindowWeakRef mPluginWindowRef;
     1:   HWND   mWnd;
     1:   UINT   mMsg;
     1:   WPARAM mWParam;
     1:   LPARAM mLParam;
     1: };
     1: 
     1: PluginWindowEvent::PluginWindowEvent()
     1: {
     1:   Clear();
     1: }
     1: 
     1: void PluginWindowEvent::Clear()
     1: {
     1:   mWnd    = NULL;
     1:   mMsg    = 0;
     1:   mWParam = 0;
     1:   mLParam = 0;
     1: }
     1: 
     1: void PluginWindowEvent::Init(const PluginWindowWeakRef &ref, HWND aWnd,
     1:                              UINT aMsg, WPARAM aWParam, LPARAM aLParam)
     1: {
  2437:   NS_ASSERTION(aWnd != NULL, "invalid plugin event value");
  2437:   NS_ASSERTION(mWnd == NULL, "event already in use");
     1:   mPluginWindowRef = ref;
     1:   mWnd    = aWnd;
     1:   mMsg    = aMsg;
     1:   mWParam = aWParam;
     1:   mLParam = aLParam;
     1: }
     1: 
     1: /**
     1:  *  nsPluginNativeWindow Windows specific class declaration
     1:  */
     1: 
     1: typedef enum {
     1:   nsPluginType_Unknown = 0,
     1:   nsPluginType_Flash,
     1:   nsPluginType_Real,
 52098:   nsPluginType_PDF,
     1:   nsPluginType_Other
     1: } nsPluginType;
     1: 
     1: class nsPluginNativeWindowWin : public nsPluginNativeWindow {
     1: public: 
     1:   nsPluginNativeWindowWin();
     1:   virtual ~nsPluginNativeWindowWin();
     1: 
 70007:   virtual nsresult CallSetWindow(nsRefPtr<nsNPAPIPluginInstance> &aPluginInstance);
     1: 
     1: private:
     1:   nsresult SubclassAndAssociateWindow();
     1:   nsresult UndoSubclassAndAssociateWindow();
     1: 
     1: public:
     1:   // locals
     1:   WNDPROC GetPrevWindowProc();
 56342:   void SetPrevWindowProc(WNDPROC proc) { mPluginWinProc = proc; }
     1:   WNDPROC GetWindowProc();
  2437:   PluginWindowEvent * GetPluginWindowEvent(HWND aWnd,
  2437:                                            UINT aMsg,
  2206:                                            WPARAM aWParam,
  2206:                                            LPARAM aLParam);
     1: 
     1: private:
 56342:   WNDPROC mPluginWinProc;
     1:   WNDPROC mPrevWinProc;
     1:   PluginWindowWeakRef mWeakRef;
     1:   nsRefPtr<PluginWindowEvent> mCachedPluginWindowEvent;
     1: 
 52098:   HWND mParentWnd;
 52098:   LONG_PTR mParentProc;
     1: public:
     1:   nsPluginType mPluginType;
     1: };
     1: 
 79445: static bool sInMessageDispatch = false;
 79445: static bool sInPreviousMessageDispatch = false;
     1: static UINT sLastMsg = 0;
     1: 
 79445: static bool ProcessFlashMessageDelayed(nsPluginNativeWindowWin * aWin, nsNPAPIPluginInstance * aInst,
     1:                                          HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
     1: {
 89711:   NS_ENSURE_TRUE(aWin, false);
 89711:   NS_ENSURE_TRUE(aInst, false);
     1: 
 29473:   if (msg == sWM_FLASHBOUNCEMSG) {
 29473:     // See PluginWindowEvent::Run() below.
 29473:     NS_ASSERTION((sWM_FLASHBOUNCEMSG != 0), "RegisterWindowMessage failed in flash plugin WM_USER message handling!");
 78430:     ::CallWindowProc((WNDPROC)aWin->GetWindowProc(), hWnd, WM_USER_FLASH, wParam, lParam);
 89711:     return true;
 29473:   }
 29473: 
 29473:   if (msg != WM_USER_FLASH)
 79533:     return false; // no need to delay
     1: 
     1:   // do stuff
     1:   nsCOMPtr<nsIRunnable> pwe = aWin->GetPluginWindowEvent(hWnd, msg, wParam, lParam);
     1:   if (pwe) {
     1:     NS_DispatchToCurrentThread(pwe);
 79533:     return true;  
     1:   }
 79533:   return false;
     1: }
     1: 
     1: class nsDelayedPopupsEnabledEvent : public nsRunnable
     1: {
     1: public:
 70007:   nsDelayedPopupsEnabledEvent(nsNPAPIPluginInstance *inst)
     1:     : mInst(inst)
     1:   {}
     1: 
     1:   NS_DECL_NSIRUNNABLE
     1: 
     1: private:
 70007:   nsRefPtr<nsNPAPIPluginInstance> mInst;
     1: };
     1: 
     1: NS_IMETHODIMP nsDelayedPopupsEnabledEvent::Run()
     1: {
 79533:   mInst->PushPopupsEnabledState(false);
     1:   return NS_OK;	
     1: }
     1: 
100548: static LRESULT CALLBACK PluginWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
100548: 
     1: /**
     1:  *   New plugin window procedure
     1:  */
 62476: static LRESULT CALLBACK PluginWndProcInternal(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
     1: {
 12902:   nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
     1:   if (!win)
     1:     return TRUE;
     1: 
    56:   // The DispatchEvent(NS_PLUGIN_ACTIVATE) below can trigger a reentrant focus
    56:   // event which might destroy us.  Hold a strong ref on the plugin instance
    56:   // to prevent that, bug 374229.
 70007:   nsRefPtr<nsNPAPIPluginInstance> inst;
    56:   win->GetPluginInstance(inst);
    56: 
     1:   // Real may go into a state where it recursivly dispatches the same event
     1:   // when subclassed. If this is Real, lets examine the event and drop it
     1:   // on the floor if we get into this recursive situation. See bug 192914.
     1:   if (win->mPluginType == nsPluginType_Real) {
 56340:     if (sInMessageDispatch && msg == sLastMsg)
 79533:       return true;
 56340:     // Cache the last message sent
 56340:     sLastMsg = msg;
     1:   }
     1: 
 79445:   bool enablePopups = false;
     1: 
     1:   // Activate/deactivate mouse capture on the plugin widget
     1:   // here, before we pass the Windows event to the plugin
     1:   // because its possible our widget won't get paired events
     1:   // (see bug 131007) and we'll look frozen. Note that this
     1:   // is also done in ChildWindow::DispatchMouseEvent.
     1:   switch (msg) {
     1:     case WM_LBUTTONDOWN:
     1:     case WM_MBUTTONDOWN:
     1:     case WM_RBUTTONDOWN: {
     1:       nsCOMPtr<nsIWidget> widget;
     1:       win->GetPluginWidget(getter_AddRefs(widget));
     1:       if (widget)
 79533:         widget->CaptureMouse(true);
     1:       break;
     1:     }
     1:     case WM_LBUTTONUP:
 79533:       enablePopups = true;
     1: 
     1:       // fall through
     1:     case WM_MBUTTONUP:
     1:     case WM_RBUTTONUP: {
     1:       nsCOMPtr<nsIWidget> widget;
     1:       win->GetPluginWidget(getter_AddRefs(widget));
     1:       if (widget)
 79533:         widget->CaptureMouse(false);
     1:       break;
     1:     }
     1:     case WM_KEYDOWN:
     1:       // Ignore repeating keydown messages...
     1:       if ((lParam & 0x40000000) != 0) {
     1:         break;
     1:       }
     1: 
     1:       // fall through
     1:     case WM_KEYUP:
 79533:       enablePopups = true;
     1: 
     1:       break;
     1: 
     1:     case WM_MOUSEACTIVATE: {
     1:       // If a child window of this plug-in is already focused,
 37550:       // don't focus the parent to avoid focus dance. We'll 
 37550:       // receive a follow up WM_SETFOCUS which will notify
 37550:       // the appropriate window anyway.
     1:       HWND focusedWnd = ::GetFocus();
     1:       if (!::IsChild((HWND)win->window, focusedWnd)) {
 37550:         // Notify the dom / focus manager the plugin has focus when one of
 37550:         // it's child windows receives it. OOPP specific - this code is
 37550:         // critical in notifying the dom of focus changes when the plugin
 37550:         // window in the child process receives focus via a mouse click.
 37550:         // WM_MOUSEACTIVATE is sent by nsWindow via a custom window event
 37550:         // sent from PluginInstanceParent in response to focus events sent
 37550:         // from the child. (bug 540052) Note, this gui event could also be
 37550:         // sent directly from widget.
     1:         nsCOMPtr<nsIWidget> widget;
     1:         win->GetPluginWidget(getter_AddRefs(widget));
     1:         if (widget) {
 79533:           nsGUIEvent event(true, NS_PLUGIN_ACTIVATE, widget);
     1:           nsEventStatus status;
     1:           widget->DispatchEvent(&event, status);
     1:         }
     1:       }
     1:     }
     1:     break;
     1: 
     1:     case WM_SETFOCUS:
     1:     case WM_KILLFOCUS: {
 56341:       // RealPlayer can crash, don't process the message for those,
 56341:       // see bug 328675.
 12327:       if (win->mPluginType == nsPluginType_Real && msg == sLastMsg)
 12327:         return TRUE;
 56341:       // Make sure setfocus and killfocus get through to the widget procedure
 56341:       // even if they are eaten by the plugin. Also make sure we aren't calling
 56341:       // recursively.
     1:       WNDPROC prevWndProc = win->GetPrevWindowProc();
 56341:       if (prevWndProc && !sInPreviousMessageDispatch) {
 79533:         sInPreviousMessageDispatch = true;
     1:         ::CallWindowProc(prevWndProc, hWnd, msg, wParam, lParam);
 79533:         sInPreviousMessageDispatch = false;
 56341:       }
     1:       break;
     1:     }
     1:   }
     1: 
     1:   // Macromedia Flash plugin may flood the message queue with some special messages
     1:   // (WM_USER+1) causing 100% CPU consumption and GUI freeze, see mozilla bug 132759;
     1:   // we can prevent this from happening by delaying the processing such messages;
     1:   if (win->mPluginType == nsPluginType_Flash) {
 29473:     if (ProcessFlashMessageDelayed(win, inst, hWnd, msg, wParam, lParam))
     1:       return TRUE;
     1:   }
     1: 
 29953:   if (enablePopups && inst) {
 29953:     PRUint16 apiVersion;
 29953:     if (NS_SUCCEEDED(inst->GetPluginAPIVersion(&apiVersion)) &&
 32799:         !versionOK(apiVersion, NP_POPUP_API_VERSION)) {
 79533:       inst->PushPopupsEnabledState(true);
     1:     }
     1:   }
     1: 
 79533:   sInMessageDispatch = true;
100548:   LRESULT res;
100548:   WNDPROC proc = (WNDPROC)win->GetWindowProc();
100548:   if (PluginWndProc == proc) {
100548:     NS_WARNING("Previous plugin window procedure references PluginWndProc! "
100548:                "Report this bug!");
100548:     res = CallWindowProc(DefWindowProc, hWnd, msg, wParam, lParam);
100548:   } else {
100548:     res = CallWindowProc(proc, hWnd, msg, wParam, lParam);
100548:   }
 79533:   sInMessageDispatch = false;
     1: 
 29953:   if (inst) {
     1:     // Popups are enabled (were enabled before the call to
     1:     // CallWindowProc()). Some plugins (at least the flash player)
     1:     // post messages from their key handlers etc that delay the actual
     1:     // processing, so we need to delay the disabling of popups so that
     1:     // popups remain enabled when the flash player ends up processing
     1:     // the actual key handlers. We do this by posting an event that
     1:     // does the disabling, this way our disabling will happen after
     1:     // the handlers in the plugin are done.
     1: 
     1:     // Note that it's not fatal if any of this fails (which won't
     1:     // happen unless we're out of memory anyways) since the plugin
     1:     // code will pop any popup state pushed by this plugin on
     1:     // destruction.
     1: 
 29953:     nsCOMPtr<nsIRunnable> event = new nsDelayedPopupsEnabledEvent(inst);
 29953:     if (event)
     1:       NS_DispatchToCurrentThread(event);
     1:   }
     1: 
     1:   return res;
     1: }
     1: 
 62476: static LRESULT CALLBACK PluginWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 62476: {
 62476:   return mozilla::CallWindowProcCrashProtected(PluginWndProcInternal, hWnd, msg, wParam, lParam);
 62476: }
 62476: 
 56342: /*
 56342:  * Flash will reset the subclass of our widget at various times.
 56342:  * (Notably when entering and exiting full screen mode.) This
 56342:  * occurs independent of the main plugin window event procedure.
 56342:  * We trap these subclass calls to prevent our subclass hook from
 56342:  * getting dropped.
 56342:  * Note, ascii versions can be nixed once flash versions < 10.1
 56342:  * are considered obsolete.
 56342:  */
 56342: static WindowsDllInterceptor sUser32Intercept;
 56342: 
 56342: #ifdef _WIN64
 56342: typedef LONG_PTR
 56342:   (WINAPI *User32SetWindowLongPtrA)(HWND hWnd,
 56342:                                     int nIndex,
 56342:                                     LONG_PTR dwNewLong);
 56342: typedef LONG_PTR
 56342:   (WINAPI *User32SetWindowLongPtrW)(HWND hWnd,
 56342:                                     int nIndex,
 56342:                                     LONG_PTR dwNewLong);
 56342: static User32SetWindowLongPtrA sUser32SetWindowLongAHookStub = NULL;
 56342: static User32SetWindowLongPtrW sUser32SetWindowLongWHookStub = NULL;
 56342: #else
 56342: typedef LONG
 56342: (WINAPI *User32SetWindowLongA)(HWND hWnd,
 56342:                                int nIndex,
 56342:                                LONG dwNewLong);
 56342: typedef LONG
 56342: (WINAPI *User32SetWindowLongW)(HWND hWnd,
 56342:                                int nIndex,
 56342:                                LONG dwNewLong);
 56342: static User32SetWindowLongA sUser32SetWindowLongAHookStub = NULL;
 56342: static User32SetWindowLongW sUser32SetWindowLongWHookStub = NULL;
 56342: #endif
 79445: static inline bool
 56342: SetWindowLongHookCheck(HWND hWnd,
 56342:                        int nIndex,
 56342:                        LONG_PTR newLong)
 56342: {
 56342:   nsPluginNativeWindowWin * win =
 56342:     (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 56342:   if (!win || (win && win->mPluginType != nsPluginType_Flash) ||
 56342:       (nIndex == GWLP_WNDPROC &&
 56342:        newLong == reinterpret_cast<LONG_PTR>(PluginWndProc)))
 79533:     return true;
 79533:   return false;
 56342: }
 56342: 
 56342: #ifdef _WIN64
 56342: LONG_PTR WINAPI
 56342: SetWindowLongPtrAHook(HWND hWnd,
 56342:                       int nIndex,
 56342:                       LONG_PTR newLong)
 56342: #else
 56342: LONG WINAPI
 56342: SetWindowLongAHook(HWND hWnd,
 56342:                    int nIndex,
 56342:                    LONG newLong)
 56342: #endif
 56342: {
 56342:   if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
 56342:       return sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
 56342: 
 56342:   // Set flash's new subclass to get the result. 
 56342:   LONG_PTR proc = sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
 56342: 
 56342:   // We already checked this in SetWindowLongHookCheck
 56342:   nsPluginNativeWindowWin * win =
 56342:     (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 56342: 
 56342:   // Hook our subclass back up, just like we do on setwindow.
 56342:   win->SetPrevWindowProc(
100548:     reinterpret_cast<WNDPROC>(sUser32SetWindowLongWHookStub(hWnd, nIndex,
 56342:       reinterpret_cast<LONG_PTR>(PluginWndProc))));
 56342:   return proc;
 56342: }
 56342: 
 56342: #ifdef _WIN64
 56342: LONG_PTR WINAPI
 56342: SetWindowLongPtrWHook(HWND hWnd,
 56342:                       int nIndex,
 56342:                       LONG_PTR newLong)
 56342: #else
 56342: LONG WINAPI
 56342: SetWindowLongWHook(HWND hWnd,
 56342:                    int nIndex,
 56342:                    LONG newLong)
 56342: #endif
 56342: {
 56342:   if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
 56342:       return sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
 56342: 
 56342:   // Set flash's new subclass to get the result. 
 56342:   LONG_PTR proc = sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
 56342: 
 56342:   // We already checked this in SetWindowLongHookCheck
 56342:   nsPluginNativeWindowWin * win =
 56342:     (nsPluginNativeWindowWin *)GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
 56342: 
 56342:   // Hook our subclass back up, just like we do on setwindow.   
 56342:   win->SetPrevWindowProc(
 56342:     reinterpret_cast<WNDPROC>(sUser32SetWindowLongWHookStub(hWnd, nIndex,
 56342:       reinterpret_cast<LONG_PTR>(PluginWndProc))));
 56342:   return proc;
 56342: }
 56342: 
 56342: static void
 56342: HookSetWindowLongPtr()
 56342: {
 56342:   sUser32Intercept.Init("user32.dll");
 56342: #ifdef _WIN64
 77706:   if (!sUser32SetWindowLongAHookStub)
 77706:     sUser32Intercept.AddHook("SetWindowLongPtrA",
 77706:                              reinterpret_cast<intptr_t>(SetWindowLongPtrAHook),
 56342:                              (void**) &sUser32SetWindowLongAHookStub);
 77706:   if (!sUser32SetWindowLongWHookStub)
 77706:     sUser32Intercept.AddHook("SetWindowLongPtrW",
 77706:                              reinterpret_cast<intptr_t>(SetWindowLongPtrWHook),
 56342:                              (void**) &sUser32SetWindowLongWHookStub);
 56342: #else
 77706:   if (!sUser32SetWindowLongAHookStub)
 77706:     sUser32Intercept.AddHook("SetWindowLongA",
 77706:                              reinterpret_cast<intptr_t>(SetWindowLongAHook),
 56342:                              (void**) &sUser32SetWindowLongAHookStub);
 77706:   if (!sUser32SetWindowLongWHookStub)
 77706:     sUser32Intercept.AddHook("SetWindowLongW",
 77706:                              reinterpret_cast<intptr_t>(SetWindowLongWHook),
 56342:                              (void**) &sUser32SetWindowLongWHookStub);
 56342: #endif
 56342: }
 56342: 
     1: /**
     1:  *   nsPluginNativeWindowWin implementation
     1:  */
     1: nsPluginNativeWindowWin::nsPluginNativeWindowWin() : nsPluginNativeWindow()
     1: {
     1:   // initialize the struct fields
     1:   window = nsnull; 
     1:   x = 0; 
     1:   y = 0; 
     1:   width = 0; 
     1:   height = 0; 
     1: 
     1:   mPrevWinProc = NULL;
     1:   mPluginWinProc = NULL;
     1:   mPluginType = nsPluginType_Unknown;
 29473: 
 52098:   mParentWnd = NULL;
 57016:   mParentProc = 0;
 52098: 
 56340:   if (!sWM_FLASHBOUNCEMSG) {
 29473:     sWM_FLASHBOUNCEMSG = ::RegisterWindowMessage(NS_PLUGIN_CUSTOM_MSG_ID);
 56340:   }
     1: }
     1: 
     1: nsPluginNativeWindowWin::~nsPluginNativeWindowWin()
     1: {
     1:   // clear weak reference to self to prevent any pending events from
     1:   // dereferencing this.
     1:   mWeakRef.forget();
     1: }
     1: 
     1: WNDPROC nsPluginNativeWindowWin::GetPrevWindowProc()
     1: {
     1:   return mPrevWinProc;
     1: }
     1: 
     1: WNDPROC nsPluginNativeWindowWin::GetWindowProc()
     1: {
     1:   return mPluginWinProc;
     1: }
     1: 
     1: NS_IMETHODIMP PluginWindowEvent::Run()
     1: {
     1:   nsPluginNativeWindowWin *win = mPluginWindowRef.get();
     1:   if (!win)
     1:     return NS_OK;
     1: 
     1:   HWND hWnd = GetWnd();
     1:   if (!hWnd)
     1:     return NS_OK;
     1: 
 70007:   nsRefPtr<nsNPAPIPluginInstance> inst;
     1:   win->GetPluginInstance(inst);
 29473: 
 29473:   if (GetMsg() == WM_USER_FLASH) {
 29473:     // XXX Unwind issues related to runnable event callback depth for this
 29473:     // event and destruction of the plugin. (Bug 493601)
 29473:     ::PostMessage(hWnd, sWM_FLASHBOUNCEMSG, GetWParam(), GetLParam());
 29473:   }
 29473:   else {
 29473:     // Currently not used, but added so that processing events here
 29473:     // is more generic.
 78430:     ::CallWindowProc(win->GetWindowProc(), 
     1:                      hWnd, 
     1:                      GetMsg(), 
     1:                      GetWParam(), 
 78430:                      GetLParam());
 29473:   }
 29473: 
     1:   Clear();
     1:   return NS_OK;
     1: }
     1: 
  2437: PluginWindowEvent * 
     1: nsPluginNativeWindowWin::GetPluginWindowEvent(HWND aWnd, UINT aMsg, WPARAM aWParam, LPARAM aLParam)
     1: {
     1:   if (!mWeakRef) {
     1:     mWeakRef = this;
     1:     if (!mWeakRef)
     1:       return nsnull;
     1:   }
     1: 
     1:   PluginWindowEvent *event;
  2437: 
     1:   // We have the ability to alloc if needed in case in the future some plugin
     1:   // should post multiple PostMessages. However, this could lead to many
  2437:   // alloc's per second which could become a performance issue. See bug 169247.
  2437:   if (!mCachedPluginWindowEvent) 
  2437:   {
     1:     event = new PluginWindowEvent();
  2437:     if (!event) return nsnull;
  2437:     mCachedPluginWindowEvent = event;
     1:   }
  2437:   else if (mCachedPluginWindowEvent->InUse())
  2437:   {
  2437:     event = new PluginWindowEvent();
  2437:     if (!event) return nsnull;
  2437:   }
  2437:   else
  2437:   {
     1:     event = mCachedPluginWindowEvent;
     1:   }
     1: 
     1:   event->Init(mWeakRef, aWnd, aMsg, aWParam, aLParam);
     1:   return event;
     1: }
     1: 
 70007: nsresult nsPluginNativeWindowWin::CallSetWindow(nsRefPtr<nsNPAPIPluginInstance> &aPluginInstance)
     1: {
 56342:   // Note, 'window' can be null
 56342: 
     1:   // check the incoming instance, null indicates that window is going away and we are
     1:   // not interested in subclassing business any more, undo and don't subclass
 56340:   if (!aPluginInstance) {
 56340:     UndoSubclassAndAssociateWindow();
 56340:     nsPluginNativeWindow::CallSetWindow(aPluginInstance);
 56340:     return NS_OK;
 56340:   }
     1: 
 52098:   // check plugin mime type and cache it if it will need special treatment later
 52098:   if (mPluginType == nsPluginType_Unknown) {
 52098:     const char* mimetype = nsnull;
 52098:     aPluginInstance->GetMIMEType(&mimetype);
 52098:     if (mimetype) { 
 52098:       if (!strcmp(mimetype, "application/x-shockwave-flash"))
 52098:         mPluginType = nsPluginType_Flash;
 52098:       else if (!strcmp(mimetype, "audio/x-pn-realaudio-plugin"))
 52098:         mPluginType = nsPluginType_Real;
 52098:       else if (!strcmp(mimetype, "application/pdf"))
 52098:         mPluginType = nsPluginType_PDF;
 52098:       else
 52098:         mPluginType = nsPluginType_Other;
 52098:     }
 52098:   }
 52098: 
 56342:   if (window) {
 56340:     // grab the widget procedure before the plug-in does a subclass in
 56340:     // setwindow. We'll use this in PluginWndProc for forwarding focus
 56340:     // events to the widget.
 56340:     WNDPROC currentWndProc =
 56340:       (WNDPROC)::GetWindowLongPtr((HWND)window, GWLP_WNDPROC);
 56340:     if (!mPrevWinProc && currentWndProc != PluginWndProc)
     1:       mPrevWinProc = currentWndProc;
 52098: 
 52098:     // PDF plugin v7.0.9, v8.1.3, and v9.0 subclass parent window, bug 531551
 52098:     // V8.2.2 and V9.1 don't have such problem.
 52098:     if (mPluginType == nsPluginType_PDF) {
 52098:       HWND parent = ::GetParent((HWND)window);
 52098:       if (mParentWnd != parent) {
 52098:         NS_ASSERTION(!mParentWnd, "Plugin's parent window changed");
 52098:         mParentWnd = parent;
 52098:         mParentProc = ::GetWindowLongPtr(mParentWnd, GWLP_WNDPROC);
 52098:       }
 52098:     }
 56342:   }
     1: 
     1:   nsPluginNativeWindow::CallSetWindow(aPluginInstance);
     1: 
     1:   SubclassAndAssociateWindow();
 56342: 
 56342:   if (window && mPluginType == nsPluginType_Flash &&
 56342:       !GetPropW((HWND)window, L"PluginInstanceParentProperty")) {
 56342:     HookSetWindowLongPtr();
 56342:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult nsPluginNativeWindowWin::SubclassAndAssociateWindow()
     1: {
 56340:   if (type != NPWindowTypeWindow || !window)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   HWND hWnd = (HWND)window;
     1: 
 56340:   // check if we need to subclass
 23614:   WNDPROC currentWndProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_WNDPROC);
 56340:   if (currentWndProc == PluginWndProc)
     1:     return NS_OK;
     1: 
 56340:   // If the plugin reset the subclass, set it back.
 56340:   if (mPluginWinProc) {
 56340: #ifdef DEBUG
 56340:     NS_WARNING("A plugin cleared our subclass - resetting.");
 56340:     if (currentWndProc != mPluginWinProc) {
 56340:       NS_WARNING("Procedures do not match up, discarding old subclass value.");
 56340:     }
 56340:     if (mPrevWinProc && currentWndProc == mPrevWinProc) {
 56340:       NS_WARNING("The new procedure is our widget procedure?");
 56340:     }
 56340: #endif
 56340:     SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)PluginWndProc);
 56340:     return NS_OK;
 56340:   }
 56340: 
 47318:   LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
 37613:   // Out of process plugins must not have the WS_CLIPCHILDREN style set on their
 37613:   // parent windows or else synchronous paints (via UpdateWindow() and others)
 37613:   // will cause deadlocks.
 37614:   if (::GetPropW(hWnd, L"PluginInstanceParentProperty"))
 37613:     style &= ~WS_CLIPCHILDREN;
 37614:   else
 37614:     style |= WS_CLIPCHILDREN;
 35747:   SetWindowLongPtr(hWnd, GWL_STYLE, style);
 35747: 
 56340:   mPluginWinProc = (WNDPROC)SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)PluginWndProc);
     1:   if (!mPluginWinProc)
     1:     return NS_ERROR_FAILURE;
     1: 
 12902:   nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
     1:   NS_ASSERTION(!win || (win == this), "plugin window already has property and this is not us");
     1:   
 12902:   if (!::SetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION, (HANDLE)this))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult nsPluginNativeWindowWin::UndoSubclassAndAssociateWindow()
     1: {
     1:   // release plugin instance
     1:   SetPluginInstance(nsnull);
     1: 
     1:   // remove window property
     1:   HWND hWnd = (HWND)window;
     1:   if (IsWindow(hWnd))
 12902:     ::RemoveProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
     1: 
     1:   // restore the original win proc
     1:   // but only do this if this were us last time
     1:   if (mPluginWinProc) {
 23614:     WNDPROC currentWndProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_WNDPROC);
     1:     if (currentWndProc == PluginWndProc)
 56340:       SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)mPluginWinProc);
 56340:     mPluginWinProc = NULL;
 35747: 
 47318:     LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
 35747:     style &= ~WS_CLIPCHILDREN;
 35747:     SetWindowLongPtr(hWnd, GWL_STYLE, style);
     1:   }
     1: 
 52098:   if (mPluginType == nsPluginType_PDF && mParentWnd) {
 52098:     ::SetWindowLongPtr(mParentWnd, GWLP_WNDPROC, mParentProc);
 52098:     mParentWnd = NULL;
 57016:     mParentProc = 0;
 52098:   }
 52098: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult PLUG_NewPluginNativeWindow(nsPluginNativeWindow ** aPluginNativeWindow)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
     1: 
     1:   *aPluginNativeWindow = new nsPluginNativeWindowWin();
     1: 
     1:   return *aPluginNativeWindow ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: nsresult PLUG_DeletePluginNativeWindow(nsPluginNativeWindow * aPluginNativeWindow)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
     1:   nsPluginNativeWindowWin *p = (nsPluginNativeWindowWin *)aPluginNativeWindow;
     1:   delete p;
     1:   return NS_OK;
     1: }
