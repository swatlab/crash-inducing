   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   8:  *   Robert O'Callahan <robert@ocallahan.org>
   1:  *   Roger B. Sidje <rbs@maths.uq.edu.au>
   1:  *   Pierre Phaneuf <pp@ludusdesign.com>
   1:  *   Prabhat Hegde <prabhat.hegde@sun.com>
   1:  *   Tomi Leppikangas <tomi.leppikangas@oulu.fi>
   1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
   1:  *   Daniel Glazman <glazman@netscape.com>
   1:  *   Neil Deakin <neil@mozdevgroup.com>
   1:  *   Masayuki Nakano <masayuki@d-toybox.com>
   1:  *   Mats Palmgren <mats.palmgren@bredband.net>
   1:  *   Uri Bernstein <uriber@gmail.com>
   1:  *   Stephen Blackheath <entangled.mooched.stephen@blacksapphire.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /* rendering object for textual content of elements */
   1: 
   1: #include "nsCOMPtr.h"
   1: #include "nsHTMLParts.h"
   1: #include "nsCRT.h"
   1: #include "nsSplittableFrame.h"
   1: #include "nsLineLayout.h"
   1: #include "nsString.h"
   1: #include "nsUnicharUtils.h"
   1: #include "nsPresContext.h"
   1: #include "nsIContent.h"
   1: #include "nsStyleConsts.h"
   1: #include "nsStyleContext.h"
   1: #include "nsCoord.h"
   1: #include "nsIFontMetrics.h"
   1: #include "nsIRenderingContext.h"
   1: #include "nsIPresShell.h"
   1: #include "nsITimer.h"
   1: #include "nsVoidArray.h"
   1: #include "nsIDOMText.h"
   1: #include "nsIDocument.h"
   1: #include "nsIDeviceContext.h"
   1: #include "nsICaret.h"
   1: #include "nsCSSPseudoElements.h"
   1: #include "nsCompatibility.h"
   1: #include "nsCSSColorUtils.h"
   1: #include "nsLayoutUtils.h"
   1: #include "nsDisplayList.h"
   1: #include "nsFrame.h"
   1: #include "nsTextFrameUtils.h"
   1: #include "nsTextRunTransformations.h"
  60: #include "nsFrameManager.h"
1328: #include "nsTextFrameTextRunCache.h"
1328: #include "nsExpirationTracker.h"
6247: #include "nsTextFrame.h"
4261: #include "nsICaseConversion.h"
5453: #include "nsIUGenCategory.h"
5453: #include "nsUnicharUtilCIID.h"
   1: 
   1: #include "nsTextFragment.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsFrameSelection.h"
   1: #include "nsISelection.h"
   1: #include "nsIDOMRange.h"
   1: #include "nsILookAndFeel.h"
   1: #include "nsCSSRendering.h"
   1: #include "nsContentUtils.h"
   1: #include "nsLineBreaker.h"
2319: #include "nsIWordBreaker.h"
   1: 
   1: #include "nsILineIterator.h"
   1: 
   1: #include "nsIServiceManager.h"
   1: #ifdef ACCESSIBILITY
   1: #include "nsIAccessible.h"
   1: #include "nsIAccessibilityService.h"
   1: #endif
   1: #include "nsAutoPtr.h"
   1: #include "nsStyleSet.h"
   1: 
   1: #include "nsBidiFrames.h"
   1: #include "nsBidiPresUtils.h"
   1: #include "nsBidiUtils.h"
   1: 
   1: #include "nsIThebesFontMetrics.h"
   1: #include "gfxFont.h"
   1: #include "gfxContext.h"
2319: #include "gfxTextRunWordCache.h"
   1: 
   1: #ifdef NS_DEBUG
   1: #undef NOISY_BLINK
   1: #undef NOISY_REFLOW
   1: #undef NOISY_TRIM
   1: #else
   1: #undef NOISY_BLINK
   1: #undef NOISY_REFLOW
   1: #undef NOISY_TRIM
   1: #endif
   1: 
   1: // The following flags are set during reflow
   1: 
   1: // This bit is set on the first frame in a continuation indicating
   1: // that it was chopped short because of :first-letter style.
   8: #define TEXT_FIRST_LETTER    0x00100000
   1: // This bit is set on frames that are logically adjacent to the start of the
   1: // line (i.e. no prior frame on line with actual displayed in-flow content).
   8: #define TEXT_START_OF_LINE   0x00200000
   1: // This bit is set on frames that are logically adjacent to the end of the
   1: // line (i.e. no following on line with actual displayed in-flow content).
   8: #define TEXT_END_OF_LINE     0x00400000
   1: // This bit is set on frames that end with a hyphenated break.
   8: #define TEXT_HYPHEN_BREAK    0x00800000
   8: // This bit is set on frames that trimmed trailing whitespace characters when
   8: // calculating their width during reflow.
   8: #define TEXT_TRIMMED_TRAILING_WHITESPACE 0x01000000
   1: 
   1: #define TEXT_REFLOW_FLAGS    \
   8:   (TEXT_FIRST_LETTER|TEXT_START_OF_LINE|TEXT_END_OF_LINE|TEXT_HYPHEN_BREAK| \
4678:    TEXT_TRIMMED_TRAILING_WHITESPACE)
   1: 
   1: // Cache bits for IsEmpty().
   1: // Set this bit if the textframe is known to be only collapsible whitespace.
   1: #define TEXT_IS_ONLY_WHITESPACE    0x08000000
   1: // Set this bit if the textframe is known to be not only collapsible whitespace.
   1: #define TEXT_ISNOT_ONLY_WHITESPACE 0x10000000
   1: 
   1: #define TEXT_WHITESPACE_FLAGS      0x18000000
   1: 
   1: // This bit is set while the frame is registered as a blinking frame.
   1: #define TEXT_BLINK_ON              0x80000000
   1: 
   1: /*
   1:  * Some general notes
   1:  * 
   1:  * Text frames delegate work to gfxTextRun objects. The gfxTextRun object
   1:  * transforms text to positioned glyphs. It can report the geometry of the
   1:  * glyphs and paint them. Text frames configure gfxTextRuns by providing text,
   1:  * spacing, language, and other information.
   1:  * 
   1:  * A gfxTextRun can cover more than one DOM text node. This is necessary to
   1:  * get kerning, ligatures and shaping for text that spans multiple text nodes
   1:  * but is all the same font. The userdata for a gfxTextRun object is a
   1:  * TextRunUserData* or an nsIFrame*.
   1:  * 
   1:  * We go to considerable effort to make sure things work even if in-flow
   1:  * siblings have different style contexts (i.e., first-letter and first-line).
   1:  * 
   1:  * Our convention is that unsigned integer character offsets are offsets into
   1:  * the transformed string. Signed integer character offsets are offsets into
   1:  * the DOM string.
   1:  * 
   1:  * XXX currently we don't handle hyphenated breaks between text frames where the
   1:  * hyphen occurs at the end of the first text frame, e.g.
   1:  *   <b>Kit&shy;</b>ty
   1:  */
   1: 
   1: /**
   1:  * We use an array of these objects to record which text frames
   1:  * are associated with the textrun. mStartFrame is the start of a list of
   1:  * text frames. Some sequence of its continuations are covered by the textrun.
   1:  * A content textnode can have at most one TextRunMappedFlow associated with it
   1:  * for a given textrun.
   1:  * 
   1:  * mDOMOffsetToBeforeTransformOffset is added to DOM offsets for those frames to obtain
   1:  * the offset into the before-transformation text of the textrun. It can be
   1:  * positive (when a text node starts in the middle of a text run) or
2344:  * negative (when a text run starts in the middle of a text node). Of course
2344:  * it can also be zero.
   1:  */
   1: struct TextRunMappedFlow {
   1:   nsTextFrame* mStartFrame;
   1:   PRInt32      mDOMOffsetToBeforeTransformOffset;
   1:   // The text mapped starts at mStartFrame->GetContentOffset() and is this long
   1:   PRUint32     mContentLength;
   1: };
   1: 
   1: /**
2344:  * This is our user data for the textrun, when textRun->GetFlags() does not
2344:  * have TEXT_SIMPLE_FLOW set. When TEXT_SIMPLE_FLOW is set, there is just one
2344:  * flow, the textrun's user data pointer is a pointer to mStartFrame
2344:  * for that flow, mDOMOffsetToBeforeTransformOffset is zero, and mContentLength
2344:  * is the length of the text node.
   1:  */
   1: struct TextRunUserData {
   1:   TextRunMappedFlow* mMappedFlows;
   1:   PRInt32            mMappedFlowCount;
   1: 
   1:   PRUint32           mLastFlowIndex;
   1: };
   1: 
   1: /**
   1:  * This helper object computes colors used for painting, and also IME
   1:  * underline information. The data is computed lazily and cached as necessary.
   1:  * These live for just the duration of one paint operation.
   1:  */
   1: class nsTextPaintStyle {
   1: public:
   1:   nsTextPaintStyle(nsTextFrame* aFrame);
   1: 
   1:   nscolor GetTextColor();
   1:   /**
   1:    * Compute the colors for normally-selected text. Returns false if
   1:    * the normal selection is not being displayed.
   1:    */
   1:   PRBool GetSelectionColors(nscolor* aForeColor,
   1:                             nscolor* aBackColor);
   1:   void GetIMESelectionColors(PRInt32  aIndex,
   1:                              nscolor* aForeColor,
   1:                              nscolor* aBackColor);
   1:   // if this returns PR_FALSE, we don't need to draw underline.
   1:   PRBool GetIMEUnderline(PRInt32  aIndex,
   1:                          nscolor* aLineColor,
4728:                          float*   aRelativeSize,
4728:                          PRUint8* aStyle);
   1: 
 280:   nsPresContext* PresContext() { return mPresContext; }
   1: 
   1:   enum {
   1:     eIndexRawInput = 0,
   1:     eIndexSelRawText,
   1:     eIndexConvText,
   1:     eIndexSelConvText
   1:   };
   1: 
   1: protected:
   1:   nsTextFrame*   mFrame;
   1:   nsPresContext* mPresContext;
   1:   PRPackedBool   mInitCommonColors;
   1:   PRPackedBool   mInitSelectionColors;
   1: 
   1:   // Selection data
   1: 
   1:   PRInt16      mSelectionStatus; // see nsIDocument.h SetDisplaySelection()
   1:   nscolor      mSelectionTextColor;
   1:   nscolor      mSelectionBGColor;
   1: 
   1:   // Common data
   1: 
   1:   PRInt32 mSufficientContrast;
   1:   nscolor mFrameBackgroundColor;
   1: 
   1:   // IME selection colors and underline info
4728:   struct nsIMEStyle {
   1:     PRBool mInit;
   1:     nscolor mTextColor;
   1:     nscolor mBGColor;
   1:     nscolor mUnderlineColor;
4728:     PRUint8 mUnderlineStyle;
   1:   };
4728:   nsIMEStyle mIMEStyle[4];
   1:   // indices
   1:   float mIMEUnderlineRelativeSize;
   1: 
   1:   // Color initializations
   1:   void InitCommonColors();
   1:   PRBool InitSelectionColors();
   1: 
4728:   nsIMEStyle* GetIMEStyle(PRInt32 aIndex);
4728:   void InitIMEStyle(PRInt32 aIndex);
   1: 
   1:   PRBool EnsureSufficientContrast(nscolor *aForeColor, nscolor *aBackColor);
   1: 
   1:   nscolor GetResolvedForeColor(nscolor aColor, nscolor aDefaultForeColor,
   1:                                nscolor aBackColor);
   1: };
   1: 
1328: static void
1328: DestroyUserData(void* aUserData)
1328: {
3233:   TextRunUserData* userData = static_cast<TextRunUserData*>(aUserData);
1328:   if (userData) {
1328:     nsMemory::Free(userData);
1328:   }
1328: }
1328: 
2344: // Remove the textrun from the frame continuation chain starting at aFrame,
2344: // which should be marked as a textrun owner.
1328: static void
1328: ClearAllTextRunReferences(nsTextFrame* aFrame, gfxTextRun* aTextRun)
1328: {
1328:   while (aFrame) {
1328:     if (aFrame->GetTextRun() != aTextRun)
1328:       break;
1328:     aFrame->SetTextRun(nsnull);
3233:     aFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());
1328:   }
1328: }
1328: 
2344: // Figure out which frames 
1328: static void
1328: UnhookTextRunFromFrames(gfxTextRun* aTextRun)
1328: {
1328:   if (!aTextRun->GetUserData())
1328:     return;
1328: 
1328:   // Kill all references to the textrun. It could be referenced by any of its
1328:   // owners, and all their in-flows.
1328:   if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
3233:     nsIFrame* firstInFlow = static_cast<nsIFrame*>(aTextRun->GetUserData());
3233:     ClearAllTextRunReferences(static_cast<nsTextFrame*>(firstInFlow), aTextRun);
1328:   } else {
1328:     TextRunUserData* userData =
3233:       static_cast<TextRunUserData*>(aTextRun->GetUserData());
1328:     PRInt32 i;
1328:     for (i = 0; i < userData->mMappedFlowCount; ++i) {
1328:       ClearAllTextRunReferences(userData->mMappedFlows[i].mStartFrame, aTextRun);
1328:     }
1328:     DestroyUserData(userData);
1328:   }
1328:   aTextRun->SetUserData(nsnull);  
1328: }
1328: 
1328: class FrameTextRunCache;
1328: 
1328: static FrameTextRunCache *gTextRuns = nsnull;
1328: 
1328: /*
1328:  * Cache textruns and expire them after 3*10 seconds of no use.
1328:  */
1328: class FrameTextRunCache : public nsExpirationTracker<gfxTextRun,3> {
1328: public:
1328:   enum { TIMEOUT_SECONDS = 10 };
1328:   FrameTextRunCache()
1328:       : nsExpirationTracker<gfxTextRun,3>(TIMEOUT_SECONDS*1000) {}
1328:   ~FrameTextRunCache() {
1328:     AgeAllGenerations();
1328:   }
1328: 
1328:   void RemoveFromCache(gfxTextRun* aTextRun) {
2319:     if (aTextRun->GetExpirationState()->IsTracked()) {
1328:       RemoveObject(aTextRun);
2319:     }
3118:     if (aTextRun->GetFlags() & gfxTextRunWordCache::TEXT_IN_CACHE) {
3118:       gfxTextRunWordCache::RemoveTextRun(aTextRun);
1328:     }
1328:   }
1328: 
1328:   // This gets called when the timeout has expired on a gfxTextRun
1328:   virtual void NotifyExpired(gfxTextRun* aTextRun) {
1328:     UnhookTextRunFromFrames(aTextRun);
1328:     RemoveFromCache(aTextRun);
1328:     delete aTextRun;
1328:   }
1328: };
1328: 
1328: static gfxTextRun *
1328: MakeTextRun(const PRUnichar *aText, PRUint32 aLength,
1328:             gfxFontGroup *aFontGroup, const gfxFontGroup::Parameters* aParams,
1328:             PRUint32 aFlags)
1328: {
1328:     nsAutoPtr<gfxTextRun> textRun;
1328:     if (aLength == 0) {
3118:         textRun = aFontGroup->MakeEmptyTextRun(aParams, aFlags);
1328:     } else if (aLength == 1 && aText[0] == ' ') {
3118:         textRun = aFontGroup->MakeSpaceTextRun(aParams, aFlags);
1328:     } else {
3118:         textRun = gfxTextRunWordCache::MakeTextRun(aText, aLength, aFontGroup,
3118:             aParams, aFlags);
1328:     }
1328:     if (!textRun)
1328:         return nsnull;
1328:     nsresult rv = gTextRuns->AddObject(textRun);
2319:     if (NS_FAILED(rv)) {
2319:         gTextRuns->RemoveFromCache(textRun);
1328:         return nsnull;
2319:     }
1328:     return textRun.forget();
1328: }
1328: 
1328: static gfxTextRun *
1328: MakeTextRun(const PRUint8 *aText, PRUint32 aLength,
1328:             gfxFontGroup *aFontGroup, const gfxFontGroup::Parameters* aParams,
1328:             PRUint32 aFlags)
1328: {
1328:     nsAutoPtr<gfxTextRun> textRun;
1328:     if (aLength == 0) {
3118:         textRun = aFontGroup->MakeEmptyTextRun(aParams, aFlags);
1328:     } else if (aLength == 1 && aText[0] == ' ') {
3118:         textRun = aFontGroup->MakeSpaceTextRun(aParams, aFlags);
1328:     } else {
3118:         textRun = gfxTextRunWordCache::MakeTextRun(aText, aLength, aFontGroup,
3118:             aParams, aFlags);
1328:     }
1328:     if (!textRun)
1328:         return nsnull;
1328:     nsresult rv = gTextRuns->AddObject(textRun);
2319:     if (NS_FAILED(rv)) {
2319:         gTextRuns->RemoveFromCache(textRun);
1328:         return nsnull;
2319:     }
1328:     return textRun.forget();
1328: }
1328: 
1328: nsresult
1328: nsTextFrameTextRunCache::Init() {
1328:     gTextRuns = new FrameTextRunCache();
1328:     return gTextRuns ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
1328: }
1328: 
1328: void
1328: nsTextFrameTextRunCache::Shutdown() {
1328:     delete gTextRuns;
1328:     gTextRuns = nsnull;
1328: }
1328: 
4678: PRInt32 nsTextFrame::GetContentEnd() const {
4678:   nsTextFrame* next = static_cast<nsTextFrame*>(GetNextContinuation());
4678:   return next ? next->GetContentOffset() : mContent->GetText()->GetLength();
4678: }
4678: 
   1: PRInt32 nsTextFrame::GetInFlowContentLength() {
   1: #ifdef IBMBIDI
   1:   nsTextFrame* nextBidi = nsnull;
   1:   PRInt32      start = -1, end;
   1: 
   1:   if (mState & NS_FRAME_IS_BIDI) {
3233:     nextBidi = static_cast<nsTextFrame*>(GetLastInFlow()->GetNextContinuation());
   1:     if (nextBidi) {
   1:       nextBidi->GetOffsets(start, end);
   1:       return start - mContentOffset;
   1:     }
   1:   }
   1: #endif //IBMBIDI
   1:   return mContent->TextLength() - mContentOffset;
   1: }
   1: 
   1: // Smarter versions of XP_IS_SPACE.
   1: // Unicode is really annoying; sometimes a space character isn't whitespace ---
   1: // when it combines with another character
   1: // So we have several versions of IsSpace for use in different contexts.
   1: 
2344: static PRBool IsSpaceCombiningSequenceTail(const nsTextFragment* aFrag, PRUint32 aPos)
2344: {
2344:   NS_ASSERTION(aPos <= aFrag->GetLength(), "Bad offset");
2344:   if (!aFrag->Is2b())
2344:     return PR_FALSE;
2344:   return nsTextFrameUtils::IsSpaceCombiningSequenceTail(
2344:     aFrag->Get2b() + aPos, aFrag->GetLength() - aPos);
2344: }
2344: 
2344: // Check whether aPos is a space for CSS 'word-spacing' purposes
   1: static PRBool IsCSSWordSpacingSpace(const nsTextFragment* aFrag, PRUint32 aPos)
   1: {
   1:   NS_ASSERTION(aPos < aFrag->GetLength(), "No text for IsSpace!");
   1:   PRUnichar ch = aFrag->CharAt(aPos);
3049:   if (ch == ' ' || ch == CH_CJKSP)
2344:     return !IsSpaceCombiningSequenceTail(aFrag, aPos + 1);
   8:   return ch == '\t' || ch == '\n' || ch == '\f';
   1: }
2344: 
2344: // Check whether the string aChars/aLength starts with a space that's
2344: // trimmable according to CSS 'white-space'.
2344: static PRBool IsTrimmableSpace(const PRUnichar* aChars, PRUint32 aLength)
   1: {
   1:   NS_ASSERTION(aLength > 0, "No text for IsSpace!");
   1:   PRUnichar ch = *aChars;
2344:   if (ch == ' ')
   1:     return !nsTextFrameUtils::IsSpaceCombiningSequenceTail(aChars + 1, aLength - 1);
   8:   return ch == '\t' || ch == '\n' || ch == '\f';
   1: }
2344: 
2344: // Check whether the character aCh is trimmable according to CSS 'white-space'
2344: static PRBool IsTrimmableSpace(char aCh)
   1: {
   8:   return aCh == ' ' || aCh == '\t' || aCh == '\n' || aCh == '\f';
   1: }
   1: 
2344: static PRBool IsTrimmableSpace(const nsTextFragment* aFrag, PRUint32 aPos)
   1: {
   1:   NS_ASSERTION(aPos < aFrag->GetLength(), "No text for IsSpace!");
   1:   PRUnichar ch = aFrag->CharAt(aPos);
2344:   if (ch == ' ')
2344:     return !IsSpaceCombiningSequenceTail(aFrag, aPos + 1);
   8:   return ch == '\t' || ch == '\n' || ch == '\f';
   1: }
   1: 
6529: static PRBool IsTrimmableSpace(const nsTextFragment* aFrag,
6529:                                const nsStyleText* aText, PRUint32 aPos)
6529: {
6529:   if (aText->WhiteSpaceIsSignificant())
6529:     return PR_FALSE;
6529:   return IsTrimmableSpace(aFrag, aPos);
6529: }
6529: 
2319: static PRBool IsSelectionSpace(const nsTextFragment* aFrag, PRUint32 aPos)
2319: {
2319:   NS_ASSERTION(aPos < aFrag->GetLength(), "No text for IsSpace!");
2319:   PRUnichar ch = aFrag->CharAt(aPos);
3049:   if (ch == ' ' || ch == CH_NBSP)
2344:     return !IsSpaceCombiningSequenceTail(aFrag, aPos + 1);
2319:   return ch == '\t' || ch == '\n' || ch == '\f';
2319: }
2344: 
2344: // Count the amount of trimmable whitespace in a text fragment. The first
2344: // character is at offset aStartOffset; the maximum number of characters
2344: // to check is aLength. aDirection is -1 or 1 depending on whether we should
2344: // progress backwards or forwards.
2344: static PRUint32
2344: GetTrimmableWhitespaceCount(const nsTextFragment* aFrag, PRInt32 aStartOffset,
   1:                             PRInt32 aLength, PRInt32 aDirection)
   1: {
   1:   PRInt32 count = 0;
2344:   if (aFrag->Is2b()) {
2344:     const PRUnichar* str = aFrag->Get2b() + aStartOffset;
2344:     PRInt32 fragLen = aFrag->GetLength() - aStartOffset;
   1:     for (; count < aLength; ++count) {
2344:       if (!IsTrimmableSpace(str, fragLen))
   1:         break;
   1:       str += aDirection;
   1:       fragLen -= aDirection;
   1:     }
   1:   } else {
2344:     const char* str = aFrag->Get1b() + aStartOffset;
   1:     for (; count < aLength; ++count) {
2344:       if (!IsTrimmableSpace(*str))
   1:         break;
   1:       str += aDirection;
   1:     }
   1:   }
   1:   return count;
   1: }
   1: 
   1: /**
   1:  * This class accumulates state as we scan a paragraph of text. It detects
   1:  * textrun boundaries (changes from text to non-text, hard
   1:  * line breaks, and font changes) and builds a gfxTextRun at each boundary.
   1:  * It also detects linebreaker run boundaries (changes from text to non-text,
   1:  * and hard line breaks) and at each boundary runs the linebreaker to compute
   1:  * potential line breaks. It also records actual line breaks to store them in
   1:  * the textruns.
   1:  */
   1: class BuildTextRunsScanner {
   1: public:
2319:   BuildTextRunsScanner(nsPresContext* aPresContext, gfxContext* aContext,
2319:       nsIFrame* aLineContainer) :
1817:     mCurrentFramesAllSameTextRun(nsnull),
2319:     mContext(aContext),
2319:     mLineContainer(aLineContainer),
2319:     mBidiEnabled(aPresContext->BidiEnabled()),    
2319:     mTrimNextRunLeadingWhitespace(PR_FALSE), mSkipIncompleteTextRuns(PR_FALSE) {
   1:     ResetRunInfo();
   1:   }
   1: 
   1:   void SetAtStartOfLine() {
   1:     mStartOfLine = PR_TRUE;
7722:     mCanStopOnThisLine = PR_FALSE;
   1:   }
2319:   void SetSkipIncompleteTextRuns(PRBool aSkip) {
2319:     mSkipIncompleteTextRuns = aSkip;
2319:   }
   1:   void SetCommonAncestorWithLastFrame(nsIFrame* aFrame) {
   1:     mCommonAncestorWithLastFrame = aFrame;
   1:   }
7722:   PRBool CanStopOnThisLine() {
7722:     return mCanStopOnThisLine;
7722:   }
   1:   nsIFrame* GetCommonAncestorWithLastFrame() {
   1:     return mCommonAncestorWithLastFrame;
   1:   }
   8:   void LiftCommonAncestorWithLastFrameToParent(nsIFrame* aFrame) {
   8:     if (mCommonAncestorWithLastFrame &&
   8:         mCommonAncestorWithLastFrame->GetParent() == aFrame) {
   8:       mCommonAncestorWithLastFrame = aFrame;
   8:     }
   8:   }
   1:   void ScanFrame(nsIFrame* aFrame);
6033:   PRBool IsTextRunValidForMappedFlows(gfxTextRun* aTextRun);
8857:   void FlushFrames(PRBool aFlushLineBreaks, PRBool aSuppressTrailingBreak);
   1:   void ResetRunInfo() {
   1:     mLastFrame = nsnull;
   1:     mMappedFlows.Clear();
   8:     mLineBreakBeforeFrames.Clear();
   1:     mMaxTextLength = 0;
   1:     mDoubleByteText = PR_FALSE;
   1:   }
7724:   void ResetLineBreaker() {
8573:     PRBool trailingBreak;
8573:     mLineBreaker.Reset(&trailingBreak);
7724:   }
   1:   void AccumulateRunInfo(nsTextFrame* aFrame);
8573:   /**
8573:    * @return null to indicate either textrun construction failed or
8573:    * we constructed just a partial textrun to set up linebreaker and other
8573:    * state for following textruns.
8573:    */
8573:   gfxTextRun* BuildTextRunForFrames(void* aTextBuffer);
   1:   void AssignTextRun(gfxTextRun* aTextRun);
   1:   nsTextFrame* GetNextBreakBeforeFrame(PRUint32* aIndex);
2319:   void SetupBreakSinksForTextRun(gfxTextRun* aTextRun, PRBool aIsExistingTextRun,
2319:                                  PRBool aSuppressSink);
2319:   struct FindBoundaryState {
2319:     nsIFrame*    mStopAtFrame;
2319:     nsTextFrame* mFirstTextFrame;
2319:     nsTextFrame* mLastTextFrame;
2319:     PRPackedBool mSeenTextRunBoundaryOnLaterLine;
2319:     PRPackedBool mSeenTextRunBoundaryOnThisLine;
2319:     PRPackedBool mSeenSpaceForLineBreakingOnThisLine;
2319:   };
2319:   enum FindBoundaryResult {
2319:     FB_CONTINUE,
2319:     FB_STOPPED_AT_STOP_FRAME,
2319:     FB_FOUND_VALID_TEXTRUN_BOUNDARY
2319:   };
2319:   FindBoundaryResult FindBoundaries(nsIFrame* aFrame, FindBoundaryState* aState);
   1: 
3009:   PRBool ContinueTextRunAcrossFrames(nsTextFrame* aFrame1, nsTextFrame* aFrame2);
   1: 
   1:   // Like TextRunMappedFlow but with some differences. mStartFrame to mEndFrame
6033:   // (exclusive) are a sequence of in-flow frames (if mEndFrame is null, then
6033:   // continuations starting from mStartFrame are a sequence of in-flow frames).
   1:   struct MappedFlow {
   1:     nsTextFrame* mStartFrame;
   1:     nsTextFrame* mEndFrame;
2013:     // When we consider breaking between elements, the nearest common
2013:     // ancestor of the elements containing the characters is the one whose
   1:     // CSS 'white-space' property governs. So this records the nearest common
   1:     // ancestor of mStartFrame and the previous text frame, or null if there
   1:     // was no previous text frame on this line.
   1:     nsIFrame*    mAncestorControllingInitialBreak;
6033:     
6033:     PRInt32 GetContentEnd() {
6033:       return mEndFrame ? mEndFrame->GetContentOffset()
6033:           : mStartFrame->GetContent()->GetText()->GetLength();
6033:     }
   1:   };
   1: 
   1:   class BreakSink : public nsILineBreakSink {
   1:   public:
2834:     BreakSink(gfxTextRun* aTextRun, gfxContext* aContext, PRUint32 aOffsetIntoTextRun,
   1:               PRBool aExistingTextRun) :
2834:                 mTextRun(aTextRun), mContext(aContext),
2834:                 mOffsetIntoTextRun(aOffsetIntoTextRun),
   1:                 mChangedBreaks(PR_FALSE), mExistingTextRun(aExistingTextRun) {}
   1: 
   1:     virtual void SetBreaks(PRUint32 aOffset, PRUint32 aLength,
   1:                            PRPackedBool* aBreakBefore) {
   1:       if (mTextRun->SetPotentialLineBreaks(aOffset + mOffsetIntoTextRun, aLength,
2834:                                            aBreakBefore, mContext)) {
   1:         mChangedBreaks = PR_TRUE;
7069:         // Be conservative and assume that some breaks have been set
7069:         mTextRun->ClearFlagBits(nsTextFrameUtils::TEXT_NO_BREAKS);
   1:       }
   1:     }
   1:     
7832:     virtual void SetCapitalization(PRUint32 aOffset, PRUint32 aLength,
7832:                                    PRPackedBool* aCapitalize) {
7832:       NS_ASSERTION(mTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_TRANSFORMED,
7832:                    "Text run should be transformed!");
7832:       nsTransformedTextRun* transformedTextRun =
7832:         static_cast<nsTransformedTextRun*>(mTextRun);
7832:       transformedTextRun->SetCapitalization(aOffset + mOffsetIntoTextRun, aLength,
7832:                                             aCapitalize, mContext);
7832:     }
7832: 
   1:     gfxTextRun*  mTextRun;
2834:     gfxContext*  mContext;
   1:     PRUint32     mOffsetIntoTextRun;
   1:     PRPackedBool mChangedBreaks;
   1:     PRPackedBool mExistingTextRun;
   1:   };
   1: 
   1: private:
   1:   nsAutoTArray<MappedFlow,10>   mMappedFlows;
   1:   nsAutoTArray<nsTextFrame*,50> mLineBreakBeforeFrames;
  60:   nsAutoTArray<nsAutoPtr<BreakSink>,10> mBreakSinks;
   1:   nsLineBreaker                 mLineBreaker;
   1:   gfxTextRun*                   mCurrentFramesAllSameTextRun;
   1:   gfxContext*                   mContext;
2319:   nsIFrame*                     mLineContainer;
   1:   nsTextFrame*                  mLastFrame;
8573:   // The common ancestor of the current frame and the previous leaf frame
8573:   // on the line, or null if there was no previous leaf frame.
   1:   nsIFrame*                     mCommonAncestorWithLastFrame;
   1:   // mMaxTextLength is an upper bound on the size of the text in all mapped frames
   1:   PRUint32                      mMaxTextLength;
   1:   PRPackedBool                  mDoubleByteText;
   1:   PRPackedBool                  mBidiEnabled;
   1:   PRPackedBool                  mStartOfLine;
   1:   PRPackedBool                  mTrimNextRunLeadingWhitespace;
   8:   PRPackedBool                  mCurrentRunTrimLeadingWhitespace;
2319:   PRPackedBool                  mSkipIncompleteTextRuns;
7722:   PRPackedBool                  mCanStopOnThisLine;
   1: };
   1: 
1817: static nsIFrame*
1817: FindLineContainer(nsIFrame* aFrame)
1817: {
1817:   while (aFrame && aFrame->IsFrameOfType(nsIFrame::eLineParticipant)) {
1817:     aFrame = aFrame->GetParent();
1817:   }
1817:   return aFrame;
1817: }
1817: 
2319: static PRBool
2319: TextContainsLineBreakerWhiteSpace(const void* aText, PRUint32 aLength,
2319:                                   PRBool aIsDoubleByte)
2319: {
2319:   PRUint32 i;
2319:   if (aIsDoubleByte) {
3233:     const PRUnichar* chars = static_cast<const PRUnichar*>(aText);
2319:     for (i = 0; i < aLength; ++i) {
2319:       if (nsLineBreaker::IsSpace(chars[i]))
2319:         return PR_TRUE;
2319:     }
2319:     return PR_FALSE;
2319:   } else {
3233:     const PRUint8* chars = static_cast<const PRUint8*>(aText);
2319:     for (i = 0; i < aLength; ++i) {
2319:       if (nsLineBreaker::IsSpace(chars[i]))
2319:         return PR_TRUE;
2319:     }
2319:     return PR_FALSE;
2319:   }
2319: }
2319: 
2742: static PRBool
2742: CanTextRunCrossFrameBoundary(nsIFrame* aFrame)
2742: {
2742:   // placeholders are "invisible", so a text run should be able to span
2742:   // across one. The text in the out-of-flow, if any, will not be included
2742:   // in this textrun of course.
2742:   return aFrame->CanContinueTextRun() ||
2742:     aFrame->GetType() == nsGkAtoms::placeholderFrame;
2742: }
2742: 
2319: BuildTextRunsScanner::FindBoundaryResult
2319: BuildTextRunsScanner::FindBoundaries(nsIFrame* aFrame, FindBoundaryState* aState)
2319: {
2319:   nsTextFrame* textFrame = aFrame->GetType() == nsGkAtoms::textFrame
3233:     ? static_cast<nsTextFrame*>(aFrame) : nsnull;
2319:   if (textFrame) {
2319:     if (aState->mLastTextFrame &&
2319:         textFrame != aState->mLastTextFrame->GetNextInFlow() &&
3009:         !ContinueTextRunAcrossFrames(aState->mLastTextFrame, textFrame)) {
2319:       aState->mSeenTextRunBoundaryOnThisLine = PR_TRUE;
2319:       if (aState->mSeenSpaceForLineBreakingOnThisLine)
2319:         return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
2319:     }
2319:     if (!aState->mFirstTextFrame) {
2319:       aState->mFirstTextFrame = textFrame;
2319:     }
2319:     aState->mLastTextFrame = textFrame;
2319:   }
2319:   
2319:   if (aFrame == aState->mStopAtFrame)
2319:     return FB_STOPPED_AT_STOP_FRAME;
2319: 
2319:   if (textFrame) {
2319:     if (!aState->mSeenSpaceForLineBreakingOnThisLine) {
2319:       const nsTextFragment* frag = textFrame->GetContent()->GetText();
2319:       PRUint32 start = textFrame->GetContentOffset();
2319:       const void* text = frag->Is2b()
3233:           ? static_cast<const void*>(frag->Get2b() + start)
3233:           : static_cast<const void*>(frag->Get1b() + start);
2319:       if (TextContainsLineBreakerWhiteSpace(text, textFrame->GetContentLength(),
2319:                                             frag->Is2b())) {
2319:         aState->mSeenSpaceForLineBreakingOnThisLine = PR_TRUE;
2319:         if (aState->mSeenTextRunBoundaryOnLaterLine)
2319:           return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
2319:       }
2319:     }
2319:     return FB_CONTINUE; 
2319:   }
2319: 
2742:   PRBool continueTextRun = CanTextRunCrossFrameBoundary(aFrame);
2319:   PRBool descendInto = PR_TRUE;
2319:   if (!continueTextRun) {
2319:     // XXX do we need this? are there frames we need to descend into that aren't
2319:     // float-containing-blocks?
2319:     descendInto = !aFrame->IsFloatContainingBlock();
2319:     aState->mSeenTextRunBoundaryOnThisLine = PR_TRUE;
2319:     if (aState->mSeenSpaceForLineBreakingOnThisLine)
2319:       return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
2319:   }
2319:   
2319:   if (descendInto) {
2319:     nsIFrame* child = aFrame->GetFirstChild(nsnull);
2319:     while (child) {
2319:       FindBoundaryResult result = FindBoundaries(child, aState);
2319:       if (result != FB_CONTINUE)
2319:         return result;
2319:       child = child->GetNextSibling();
2319:     }
2319:   }
2319: 
2319:   if (!continueTextRun) {
2319:     aState->mSeenTextRunBoundaryOnThisLine = PR_TRUE;
2319:     if (aState->mSeenSpaceForLineBreakingOnThisLine)
2319:       return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
2319:   }
2319: 
2319:   return FB_CONTINUE;
2319: }
2319: 
7722: // build text runs for the 200 lines following aForFrame, and stop after that
7722: // when we get a chance.
7722: #define NUM_LINES_TO_BUILD_TEXT_RUNS 200
7722: 
   1: /**
   1:  * General routine for building text runs. This is hairy because of the need
2319:  * to build text runs that span content nodes.
   1:  * 
   1:  * @param aForFrameLine the line containing aForFrame; if null, we'll figure
   1:  * out the line (slowly)
   1:  * @param aBlockFrame the block containing aForFrame; if null, we'll figure
   1:  * out the block (slowly)
   1:  */
   1: static void
6862: BuildTextRuns(gfxContext* aContext, nsTextFrame* aForFrame,
1817:               nsIFrame* aLineContainer, const nsLineList::iterator* aForFrameLine)
   1: {
1817:   if (!aLineContainer) {
1817:     aLineContainer = FindLineContainer(aForFrame);
1817:   } else {
2319:     NS_ASSERTION(!aForFrame || aLineContainer == FindLineContainer(aForFrame), "Wrong line container hint");
2319:   }
2319: 
2319:   nsPresContext* presContext = aLineContainer->PresContext();
6862:   BuildTextRunsScanner scanner(presContext, aContext, aLineContainer);
1817: 
1817:   nsBlockFrame* block = nsnull;
1817:   aLineContainer->QueryInterface(kBlockFrameCID, (void**)&block);
1817: 
1817:   if (!block) {
5145:     NS_ASSERTION(!aLineContainer->GetPrevInFlow() && !aLineContainer->GetNextInFlow(),
5145:                  "Breakable non-block line containers not supported");
1817:     // Just loop through all the children of the linecontainer ... it's really
1817:     // just one line
2319:     scanner.SetAtStartOfLine();
2319:     scanner.SetCommonAncestorWithLastFrame(nsnull);
1817:     nsIFrame* child = aLineContainer->GetFirstChild(nsnull);
1817:     while (child) {
1817:       scanner.ScanFrame(child);
1817:       child = child->GetNextSibling();
1817:     }
1817:     // Set mStartOfLine so FlushFrames knows its textrun ends a line
1817:     scanner.SetAtStartOfLine();
8857:     scanner.FlushFrames(PR_TRUE, PR_FALSE);
1817:     return;
1817:   }
   1: 
2319:   // Find the line containing aForFrame
7722:   nsBlockFrame::line_iterator startLine;
   1:   if (aForFrameLine) {
7722:     startLine = *aForFrameLine;
   1:   } else {
2319:     NS_ASSERTION(aForFrame, "One of aForFrame or aForFrameLine must be set!");
   1:     nsIFrame* immediateChild =
1817:       nsLayoutUtils::FindChildContainingDescendant(block, aForFrame);
  60:     // This may be a float e.g. for a floated first-letter
  60:     if (immediateChild->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
  60:       immediateChild =
1817:         nsLayoutUtils::FindChildContainingDescendant(block,
  60:           presContext->FrameManager()->GetPlaceholderFrameFor(immediateChild));
  60:     }
7722:     startLine = block->FindLineFor(immediateChild);
7722:     NS_ASSERTION(startLine != block->end_lines(),
   1:                  "Frame is not in the block!!!");
   1:   }
2319: 
2319:   // Find a line where we can start building text runs. We choose the last line
2319:   // where:
2319:   // -- there is a textrun boundary between the start of the line and the
2319:   // start of aForFrame
2319:   // -- there is a space between the start of the line and the textrun boundary
2319:   // (this is so we can be sure the line breaks will be set properly
2319:   // on the textruns we construct).
2319:   // The possibly-partial text runs up to and including the first space
2319:   // are not reconstructed. We construct partial text runs for that text ---
2319:   // for the sake of simplifying the code and feeding the linebreaker ---
2319:   // but we discard them instead of assigning them to frames.
2319:   // This is a little awkward because we traverse lines in the reverse direction
2319:   // but we traverse the frames in each line in the forward direction.
7722:   nsBlockInFlowLineIterator backIterator(block, startLine, PR_FALSE);
2319:   nsTextFrame* stopAtFrame = aForFrame;
2319:   nsTextFrame* nextLineFirstTextFrame = nsnull;
2319:   PRBool seenTextRunBoundaryOnLaterLine = PR_FALSE;
2319:   PRBool mayBeginInTextRun = PR_TRUE;
5145:   PRBool inOverflow = PR_FALSE;
7722:   nsBlockFrame::line_iterator line;
2319:   while (PR_TRUE) {
5145:     line = backIterator.GetLine();
5145:     block = backIterator.GetContainer();
5145:     inOverflow = backIterator.GetInOverflow();
5145:     if (!backIterator.Prev() || backIterator.GetLine()->IsBlock()) {
2319:       mayBeginInTextRun = PR_FALSE;
   1:       break;
   1:     }
2319: 
2319:     BuildTextRunsScanner::FindBoundaryState state = { stopAtFrame, nsnull, nsnull,
2319:       seenTextRunBoundaryOnLaterLine, PR_FALSE, PR_FALSE };
2319:     nsIFrame* child = line->mFirstChild;
2319:     PRBool foundBoundary = PR_FALSE;
2319:     PRInt32 i;
2319:     for (i = line->GetChildCount() - 1; i >= 0; --i) {
2319:       BuildTextRunsScanner::FindBoundaryResult result =
2319:           scanner.FindBoundaries(child, &state);
2319:       if (result == BuildTextRunsScanner::FB_FOUND_VALID_TEXTRUN_BOUNDARY) {
2319:         foundBoundary = PR_TRUE;
2319:         break;
2319:       } else if (result == BuildTextRunsScanner::FB_STOPPED_AT_STOP_FRAME) {
2319:         break;
2319:       }
2319:       child = child->GetNextSibling();
2319:     }
2319:     if (foundBoundary)
2319:       break;
2319:     if (!stopAtFrame && state.mLastTextFrame && nextLineFirstTextFrame &&
3009:         !scanner.ContinueTextRunAcrossFrames(state.mLastTextFrame, nextLineFirstTextFrame)) {
3009:       // Found a usable textrun boundary at the end of the line
2319:       if (state.mSeenSpaceForLineBreakingOnThisLine)
2319:         break;
2319:       seenTextRunBoundaryOnLaterLine = PR_TRUE;
2319:     } else if (state.mSeenTextRunBoundaryOnThisLine) {
2319:       seenTextRunBoundaryOnLaterLine = PR_TRUE;
2319:     }
2319:     stopAtFrame = nsnull;
2319:     if (state.mFirstTextFrame) {
2319:       nextLineFirstTextFrame = state.mFirstTextFrame;
2319:     }
2319:   }
2319:   scanner.SetSkipIncompleteTextRuns(mayBeginInTextRun);
   1: 
   1:   // Now iterate over all text frames starting from the current line. First-in-flow
   1:   // text frames will be accumulated into textRunFrames as we go. When a
   1:   // text run boundary is required we flush textRunFrames ((re)building their
   1:   // gfxTextRuns as necessary).
5145:   nsBlockInFlowLineIterator forwardIterator(block, line, inOverflow);
7722:   PRBool seenStartLine = PR_FALSE;
7722:   PRUint32 linesAfterStartLine = 0;
   1:   do {
5145:     line = forwardIterator.GetLine();
5145:     if (line->IsBlock())
5145:       break;
6029:     line->SetInvalidateTextRuns(PR_FALSE);
   1:     scanner.SetAtStartOfLine();
   1:     scanner.SetCommonAncestorWithLastFrame(nsnull);
5145:     nsIFrame* child = line->mFirstChild;
   1:     PRInt32 i;
   1:     for (i = line->GetChildCount() - 1; i >= 0; --i) {
   1:       scanner.ScanFrame(child);
   1:       child = child->GetNextSibling();
   1:     }
8006:     if (forwardIterator.GetContainer() == aLineContainer && line == startLine) {
7722:       seenStartLine = PR_TRUE;
7722:     }
7722:     if (seenStartLine) {
7722:       ++linesAfterStartLine;
7722:       if (linesAfterStartLine >= NUM_LINES_TO_BUILD_TEXT_RUNS && scanner.CanStopOnThisLine()) {
7722:         // Don't flush; we may be in the middle of a textrun that we can't
7722:         // end here. That's OK, we just won't build it.
7722:         // Note that we must already have finished the textrun for aForFrame,
7722:         // because we've seen the end of a textrun in a line after the line
7722:         // containing aForFrame.
7724:         scanner.ResetLineBreaker();
7722:         return;
7722:       }
7722:     }
5145:   } while (forwardIterator.Next());
   1: 
   1:   // Set mStartOfLine so FlushFrames knows its textrun ends a line
   1:   scanner.SetAtStartOfLine();
8857:   scanner.FlushFrames(PR_TRUE, PR_FALSE);
   1: }
   1: 
   1: static PRUnichar*
   1: ExpandBuffer(PRUnichar* aDest, PRUint8* aSrc, PRUint32 aCount)
   1: {
   1:   while (aCount) {
   1:     *aDest = *aSrc;
   1:     ++aDest;
   1:     ++aSrc;
   1:     --aCount;
   1:   }
   1:   return aDest;
   1: }
   1: 
6033: PRBool BuildTextRunsScanner::IsTextRunValidForMappedFlows(gfxTextRun* aTextRun)
6033: {
6033:   if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW)
6033:     return mMappedFlows.Length() == 1 &&
6033:       mMappedFlows[0].mStartFrame == static_cast<nsTextFrame*>(aTextRun->GetUserData()) &&
6033:       mMappedFlows[0].mEndFrame == nsnull;
6033: 
6033:   TextRunUserData* userData = static_cast<TextRunUserData*>(aTextRun->GetUserData());
6033:   if (userData->mMappedFlowCount != PRInt32(mMappedFlows.Length()))
6033:     return PR_FALSE;
6033:   PRUint32 i;
6033:   for (i = 0; i < mMappedFlows.Length(); ++i) {
6033:     if (userData->mMappedFlows[i].mStartFrame != mMappedFlows[i].mStartFrame ||
6033:         PRInt32(userData->mMappedFlows[i].mContentLength) !=
6033:             mMappedFlows[i].GetContentEnd() - mMappedFlows[i].mStartFrame->GetContentOffset())
6033:       return PR_FALSE;
6033:   }
6033:   return PR_TRUE;
6033: }
6033: 
   1: /**
   1:  * This gets called when we need to make a text run for the current list of
   1:  * frames.
   1:  */
8857: void BuildTextRunsScanner::FlushFrames(PRBool aFlushLineBreaks, PRBool aSuppressTrailingBreak)
   1: {
   1:   if (mMappedFlows.Length() == 0)
   1:     return;
   1: 
8573:   gfxTextRun* textRun;
2319:   if (!mSkipIncompleteTextRuns && mCurrentFramesAllSameTextRun &&
   1:       ((mCurrentFramesAllSameTextRun->GetFlags() & nsTextFrameUtils::TEXT_INCOMING_WHITESPACE) != 0) ==
6033:       mCurrentRunTrimLeadingWhitespace &&
6033:       IsTextRunValidForMappedFlows(mCurrentFramesAllSameTextRun)) {
2319:     // Optimization: We do not need to (re)build the textrun.
8573:     textRun = mCurrentFramesAllSameTextRun;
   1: 
   1:     // Feed this run's text into the linebreaker to provide context. This also
   1:     // updates mTrimNextRunLeadingWhitespace appropriately.
8573:     SetupBreakSinksForTextRun(textRun, PR_TRUE, PR_FALSE);
1328:     mTrimNextRunLeadingWhitespace =
8573:       (textRun->GetFlags() & nsTextFrameUtils::TEXT_TRAILING_WHITESPACE) != 0;
   1:   } else {
   1:     nsAutoTArray<PRUint8,BIG_TEXT_NODE_SIZE> buffer;
   1:     if (!buffer.AppendElements(mMaxTextLength*(mDoubleByteText ? 2 : 1)))
   1:       return;
8573:     textRun = BuildTextRunForFrames(buffer.Elements());
   1:   }
   1: 
   1:   if (aFlushLineBreaks) {
8573:     PRBool trailingLineBreak;
8573:     nsresult rv = mLineBreaker.Reset(&trailingLineBreak);
8573:     // textRun may be null for various reasons, including because we constructed
8573:     // a partial textrun just to get the linebreaker and other state set up
8573:     // to build the next textrun.
8857:     if (NS_SUCCEEDED(rv) && trailingLineBreak && textRun && !aSuppressTrailingBreak) {
8573:       textRun->SetFlagBits(nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK);
8573:     }
   1:     PRUint32 i;
   1:     for (i = 0; i < mBreakSinks.Length(); ++i) {
  60:       if (!mBreakSinks[i]->mExistingTextRun || mBreakSinks[i]->mChangedBreaks) {
   1:         // TODO cause frames associated with the textrun to be reflowed, if they
   1:         // aren't being reflowed already!
   1:       }
   1:     }
   1:     mBreakSinks.Clear();
   1:   }
   1: 
7722:   mCanStopOnThisLine = PR_TRUE;
   1:   ResetRunInfo();
   1: }
   1: 
   1: void BuildTextRunsScanner::AccumulateRunInfo(nsTextFrame* aFrame)
   1: {
   1:   mMaxTextLength += aFrame->GetContentLength();
   1:   mDoubleByteText |= aFrame->GetContent()->GetText()->Is2b();
   1:   mLastFrame = aFrame;
8573:   mCommonAncestorWithLastFrame = aFrame->GetParent();
   1: 
6033:   MappedFlow* mappedFlow = &mMappedFlows[mMappedFlows.Length() - 1];
6033:   NS_ASSERTION(mappedFlow->mStartFrame == aFrame ||
6033:                mappedFlow->GetContentEnd() == aFrame->GetContentOffset(),
6033:                "Overlapping or discontiguous frames => BAD");
6033:   mappedFlow->mEndFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());
6033:   if (mCurrentFramesAllSameTextRun != aFrame->GetTextRun()) {
6033:     mCurrentFramesAllSameTextRun = nsnull;
6033:   }
6033: 
   1:   if (mStartOfLine) {
   1:     mLineBreakBeforeFrames.AppendElement(aFrame);
   1:     mStartOfLine = PR_FALSE;
   1:   }
   1: }
   1: 
2027: static nscoord StyleToCoord(const nsStyleCoord& aCoord)
2027: {
2027:   if (eStyleUnit_Coord == aCoord.GetUnit()) {
2027:     return aCoord.GetCoordValue();
2027:   } else {
2027:     return 0;
2027:   }
2027: }
2027: 
2027: static PRBool
3009: HasTerminalNewline(const nsTextFrame* aFrame)
3009: {
3009:   if (aFrame->GetContentLength() == 0)
3009:     return PR_FALSE;
3009:   const nsTextFragment* frag = aFrame->GetContent()->GetText();
3009:   return frag->CharAt(aFrame->GetContentEnd() - 1) == '\n';
3009: }
3009: 
   1: PRBool
3009: BuildTextRunsScanner::ContinueTextRunAcrossFrames(nsTextFrame* aFrame1, nsTextFrame* aFrame2)
   1: {
   1:   if (mBidiEnabled &&
   1:       NS_GET_EMBEDDING_LEVEL(aFrame1) != NS_GET_EMBEDDING_LEVEL(aFrame2))
   1:     return PR_FALSE;
   1: 
   1:   nsStyleContext* sc1 = aFrame1->GetStyleContext();
3009:   const nsStyleText* textStyle1 = sc1->GetStyleText();
3009:   // If the first frame ends in a preformatted newline, then we end the textrun
3009:   // here. This avoids creating giant textruns for an entire plain text file.
3009:   // Note that we create a single text frame for a preformatted text node,
3009:   // even if it has newlines in it, so typically we won't see trailing newlines
3009:   // until after reflow has broken up the frame into one (or more) frames per
3009:   // line. That's OK though.
3009:   if (textStyle1->WhiteSpaceIsSignificant() && HasTerminalNewline(aFrame1))
3009:     return PR_FALSE;
3009: 
7012:   if (aFrame1->GetContent() == aFrame2->GetContent() &&
7012:       aFrame1->GetNextInFlow() != aFrame2) {
7012:     // aFrame2 must be a non-fluid continuation of aFrame1. This can happen
7012:     // sometimes when the unicode-bidi property is used; the bidi resolver
7012:     // breaks text into different frames even though the text has the same
7012:     // direction. We can't allow these two frames to share the same textrun
7012:     // because that would violate our invariant that two flows in the same
7012:     // textrun have different content elements.
7012:     return PR_FALSE;
7012:   }
7012: 
   1:   nsStyleContext* sc2 = aFrame2->GetStyleContext();
   1:   if (sc1 == sc2)
   1:     return PR_TRUE;
4032:   const nsStyleFont* fontStyle1 = sc1->GetStyleFont();
4032:   const nsStyleFont* fontStyle2 = sc2->GetStyleFont();
4032:   const nsStyleText* textStyle2 = sc2->GetStyleText();
4032:   return fontStyle1->mFont.BaseEquals(fontStyle2->mFont) &&
2027:     sc1->GetStyleVisibility()->mLangGroup == sc2->GetStyleVisibility()->mLangGroup &&
4032:     nsLayoutUtils::GetTextRunFlagsForStyle(sc1, textStyle1, fontStyle1) ==
4032:       nsLayoutUtils::GetTextRunFlagsForStyle(sc2, textStyle2, fontStyle2);
   1: }
   1: 
   1: void BuildTextRunsScanner::ScanFrame(nsIFrame* aFrame)
   1: {
   1:   // First check if we can extend the current mapped frame block. This is common.
   1:   if (mMappedFlows.Length() > 0) {
   1:     MappedFlow* mappedFlow = &mMappedFlows[mMappedFlows.Length() - 1];
6033:     if (mappedFlow->mEndFrame == aFrame &&
6033:         (aFrame->GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION)) {
   1:       NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame,
   1:                    "Flow-sibling of a text frame is not a text frame?");
   1: 
3009:       // Don't do this optimization if mLastFrame has a terminal newline...
3009:       // it's quite likely preformatted and we might want to end the textrun here.
3009:       // This is almost always true:
3009:       if (mLastFrame->GetStyleContext() == aFrame->GetStyleContext() &&
3009:           !HasTerminalNewline(mLastFrame)) {
6033:         AccumulateRunInfo(static_cast<nsTextFrame*>(aFrame));
   1:         return;
   1:       }
   1:     }
   1:   }
   1: 
8857:   nsIAtom* frameType = aFrame->GetType();
   1:   // Now see if we can add a new set of frames to the current textrun
8857:   if (frameType == nsGkAtoms::textFrame) {
3233:     nsTextFrame* frame = static_cast<nsTextFrame*>(aFrame);
   1: 
6033:     if (mLastFrame) {
6033:       if (!ContinueTextRunAcrossFrames(mLastFrame, frame)) {
8857:         FlushFrames(PR_FALSE, PR_FALSE);
6033:       } else {
6033:         if (mLastFrame->GetContent() == frame->GetContent()) {
6033:           AccumulateRunInfo(frame);
6033:           return;
6033:         }
6033:       }
   1:     }
   1: 
   1:     MappedFlow* mappedFlow = mMappedFlows.AppendElement();
   1:     if (!mappedFlow)
   1:       return;
   1: 
   1:     mappedFlow->mStartFrame = frame;
   1:     mappedFlow->mAncestorControllingInitialBreak = mCommonAncestorWithLastFrame;
   1: 
   1:     AccumulateRunInfo(frame);
   1:     if (mMappedFlows.Length() == 1) {
   1:       mCurrentFramesAllSameTextRun = frame->GetTextRun();
   8:       mCurrentRunTrimLeadingWhitespace = mTrimNextRunLeadingWhitespace;
   1:     }
   1:     return;
   1:   }
   1: 
2742:   PRBool continueTextRun = CanTextRunCrossFrameBoundary(aFrame);
   1:   PRBool descendInto = PR_TRUE;
8857:   PRBool isBR = frameType == nsGkAtoms::brFrame;
   1:   if (!continueTextRun) {
8857:     // BR frames are special. We do not need or want to record a break opportunity
8857:     // before a BR frame.
8857:     FlushFrames(PR_TRUE, isBR);
8573:     mCommonAncestorWithLastFrame = aFrame;
8573:     mTrimNextRunLeadingWhitespace = PR_FALSE;
   1:     // XXX do we need this? are there frames we need to descend into that aren't
   1:     // float-containing-blocks?
   1:     descendInto = !aFrame->IsFloatContainingBlock();
   1:     mStartOfLine = PR_FALSE;
   1:   }
   1: 
   1:   if (descendInto) {
   1:     nsIFrame* f;
   1:     for (f = aFrame->GetFirstChild(nsnull); f; f = f->GetNextSibling()) {
   1:       ScanFrame(f);
   1:     }
   1:   }
   1: 
   1:   if (!continueTextRun) {
8857:     // Really if we're a BR frame this is unnecessary since descendInto will be
8857:     // false. In fact this whole "if" statement should move into the descendInto.
8857:     FlushFrames(PR_TRUE, isBR);
8573:     mCommonAncestorWithLastFrame = aFrame;
   1:     mTrimNextRunLeadingWhitespace = PR_FALSE;
   1:   }
2319: 
2319:   LiftCommonAncestorWithLastFrameToParent(aFrame->GetParent());
   1: }
   1: 
   1: nsTextFrame*
   1: BuildTextRunsScanner::GetNextBreakBeforeFrame(PRUint32* aIndex)
   1: {
   1:   PRUint32 index = *aIndex;
   1:   if (index >= mLineBreakBeforeFrames.Length())
   1:     return nsnull;
   1:   *aIndex = index + 1;
3233:   return static_cast<nsTextFrame*>(mLineBreakBeforeFrames.ElementAt(index));
   1: }
   1: 
   1: static PRUint32
   1: GetSpacingFlags(const nsStyleCoord& aStyleCoord)
   1: {
   1:   nscoord spacing = StyleToCoord(aStyleCoord);
   1:   if (!spacing)
   1:     return 0;
   1:   if (spacing > 0)
   1:     return gfxTextRunFactory::TEXT_ENABLE_SPACING;
   1:   return gfxTextRunFactory::TEXT_ENABLE_SPACING |
   1:          gfxTextRunFactory::TEXT_ENABLE_NEGATIVE_SPACING;
   1: }
   1: 
   1: static gfxFontGroup*
   1: GetFontGroupForFrame(nsIFrame* aFrame)
   1: {
   1:   nsCOMPtr<nsIFontMetrics> metrics;
4353:   nsLayoutUtils::GetFontMetricsForFrame(aFrame, getter_AddRefs(metrics));
4353: 
   1:   if (!metrics)
   1:     return nsnull;
   1: 
   1:   nsIFontMetrics* metricsRaw = metrics;
3233:   nsIThebesFontMetrics* fm = static_cast<nsIThebesFontMetrics*>(metricsRaw);
6247:   // XXX this is a bit bogus, we're releasing 'metrics' so the returned font-group
6247:   // might actually be torn down, although because of the way the device context
6247:   // caches font metrics, this seems to not actually happen. But we should fix
6247:   // this.
   1:   return fm->GetThebesFontGroup();
   1: }
   1: 
6862: static already_AddRefed<gfxContext>
6862: GetReferenceRenderingContext(nsTextFrame* aTextFrame, nsIRenderingContext* aRC)
6862: {
6862:   nsCOMPtr<nsIRenderingContext> tmp = aRC;
6862:   if (!tmp) {
6862:     nsresult rv = aTextFrame->PresContext()->PresShell()->
6862:       CreateRenderingContext(aTextFrame, getter_AddRefs(tmp));
6862:     if (NS_FAILED(rv))
6862:       return nsnull;
6862:   }
6862: 
9438:   gfxContext* ctx = tmp->ThebesContext();
6862:   NS_ADDREF(ctx);
6862:   return ctx;
6862: }
6862: 
5724: /**
5724:  * The returned textrun must be released via gfxTextRunCache::ReleaseTextRun
5724:  * or gfxTextRunCache::AutoTextRun.
5724:  */
   1: static gfxTextRun*
6862: GetHyphenTextRun(gfxTextRun* aTextRun, gfxContext* aContext, nsTextFrame* aTextFrame)
6862: {
6862:   nsRefPtr<gfxContext> ctx = aContext;
6862:   if (!ctx) {
6862:     ctx = GetReferenceRenderingContext(aTextFrame, nsnull);
6862:   }
6862:   if (!ctx)
1563:     return nsnull;
6862: 
1328:   gfxFontGroup* fontGroup = aTextRun->GetFontGroup();
1328:   PRUint32 flags = gfxFontGroup::TEXT_IS_PERSISTENT;
1328: 
1328:   static const PRUnichar unicodeHyphen = 0x2010;
1328:   gfxTextRun* textRun =
3118:     gfxTextRunCache::MakeTextRun(&unicodeHyphen, 1, fontGroup, ctx,
1328:                                  aTextRun->GetAppUnitsPerDevUnit(), flags);
1328:   if (textRun && textRun->CountMissingGlyphs() == 0)
1328:     return textRun;
1328: 
7729:   gfxTextRunCache::ReleaseTextRun(textRun);
7729: 
1328:   static const PRUint8 dash = '-';
3118:   return gfxTextRunCache::MakeTextRun(&dash, 1, fontGroup, ctx,
1328:                                       aTextRun->GetAppUnitsPerDevUnit(),
1328:                                       flags);
   1: }
   1: 
   1: static gfxFont::Metrics
   1: GetFontMetrics(gfxFontGroup* aFontGroup)
   1: {
   1:   if (!aFontGroup)
   1:     return gfxFont::Metrics();
   1:   gfxFont* font = aFontGroup->GetFontAt(0);
   1:   if (!font)
   1:     return gfxFont::Metrics();
   1:   return font->GetMetrics();
   1: }
   1: 
8573: gfxTextRun*
   1: BuildTextRunsScanner::BuildTextRunForFrames(void* aTextBuffer)
   1: {
   1:   gfxSkipCharsBuilder builder;
   1: 
   1:   const void* textPtr = aTextBuffer;
   1:   PRBool anySmallcapsStyle = PR_FALSE;
   1:   PRBool anyTextTransformStyle = PR_FALSE;
   1:   nsIContent* lastContent = nsnull;
   1:   PRInt32 endOfLastContent = 0;
6513:   PRUint32 textFlags = nsTextFrameUtils::TEXT_NO_BREAKS;
   8: 
   8:   if (mCurrentRunTrimLeadingWhitespace) {
   8:     textFlags |= nsTextFrameUtils::TEXT_INCOMING_WHITESPACE;
   8:   }
   1: 
5800:   nsAutoTArray<PRInt32,50> textBreakPoints;
   1:   TextRunUserData dummyData;
   1:   TextRunMappedFlow dummyMappedFlow;
   1: 
   1:   TextRunUserData* userData;
   1:   // If the situation is particularly simple (and common) we don't need to
   1:   // allocate userData.
   1:   if (mMappedFlows.Length() == 1 && !mMappedFlows[0].mEndFrame &&
6033:       mMappedFlows[0].mStartFrame->GetContentOffset() == 0) {
   1:     userData = &dummyData;
   1:     dummyData.mMappedFlows = &dummyMappedFlow;
   1:   } else {
3233:     userData = static_cast<TextRunUserData*>
3233:       (nsMemory::Alloc(sizeof(TextRunUserData) + mMappedFlows.Length()*sizeof(TextRunMappedFlow)));
3233:     userData->mMappedFlows = reinterpret_cast<TextRunMappedFlow*>(userData + 1);
   1:   }
6033:   userData->mMappedFlowCount = mMappedFlows.Length();
   1:   userData->mLastFlowIndex = 0;
   1: 
   1:   PRUint32 currentTransformedTextOffset = 0;
   1: 
   1:   PRUint32 nextBreakIndex = 0;
   1:   nsTextFrame* nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
   1: 
   1:   PRUint32 i;
4032:   const nsStyleText* textStyle = nsnull;
4032:   const nsStyleFont* fontStyle = nsnull;
4032:   nsStyleContext* lastStyleContext = nsnull;
   1:   for (i = 0; i < mMappedFlows.Length(); ++i) {
   1:     MappedFlow* mappedFlow = &mMappedFlows[i];
   1:     nsTextFrame* f = mappedFlow->mStartFrame;
   1: 
4032:     lastStyleContext = f->GetStyleContext();
   1:     // Detect use of text-transform or font-variant anywhere in the run
4032:     textStyle = f->GetStyleText();
   1:     if (NS_STYLE_TEXT_TRANSFORM_NONE != textStyle->mTextTransform) {
   1:       anyTextTransformStyle = PR_TRUE;
   1:     }
   1:     textFlags |= GetSpacingFlags(textStyle->mLetterSpacing);
   1:     textFlags |= GetSpacingFlags(textStyle->mWordSpacing);
   1:     PRBool compressWhitespace = !textStyle->WhiteSpaceIsSignificant();
   1:     if (NS_STYLE_TEXT_ALIGN_JUSTIFY == textStyle->mTextAlign && compressWhitespace) {
   1:       textFlags |= gfxTextRunFactory::TEXT_ENABLE_SPACING;
   1:     }
4032:     fontStyle = f->GetStyleFont();
   1:     if (NS_STYLE_FONT_VARIANT_SMALL_CAPS == fontStyle->mFont.variant) {
   1:       anySmallcapsStyle = PR_TRUE;
   1:     }
   1: 
   1:     // Figure out what content is included in this flow.
   1:     nsIContent* content = f->GetContent();
   1:     const nsTextFragment* frag = content->GetText();
6033:     PRInt32 contentStart = mappedFlow->mStartFrame->GetContentOffset();
6033:     PRInt32 contentEnd = mappedFlow->GetContentEnd();
   1:     PRInt32 contentLength = contentEnd - contentStart;
   1: 
6033:     TextRunMappedFlow* newFlow = &userData->mMappedFlows[i];
   1:     newFlow->mStartFrame = mappedFlow->mStartFrame;
6033:     newFlow->mDOMOffsetToBeforeTransformOffset = builder.GetCharCount() -
6033:       mappedFlow->mStartFrame->GetContentOffset();
   1:     newFlow->mContentLength = contentLength;
   1: 
   1:     while (nextBreakBeforeFrame && nextBreakBeforeFrame->GetContent() == content) {
5800:       textBreakPoints.AppendElement(
5800:           nextBreakBeforeFrame->GetContentOffset() + newFlow->mDOMOffsetToBeforeTransformOffset);
   1:       nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
   1:     }
   1: 
   1:     PRUint32 analysisFlags;
   1:     if (frag->Is2b()) {
   1:       NS_ASSERTION(mDoubleByteText, "Wrong buffer char size!");
3233:       PRUnichar* bufStart = static_cast<PRUnichar*>(aTextBuffer);
   1:       PRUnichar* bufEnd = nsTextFrameUtils::TransformText(
   1:           frag->Get2b() + contentStart, contentLength, bufStart,
   1:           compressWhitespace, &mTrimNextRunLeadingWhitespace, &builder, &analysisFlags);
   1:       aTextBuffer = bufEnd;
   1:     } else {
   1:       if (mDoubleByteText) {
   1:         // Need to expand the text. First transform it into a temporary buffer,
   1:         // then expand.
   1:         nsAutoTArray<PRUint8,BIG_TEXT_NODE_SIZE> tempBuf;
   1:         if (!tempBuf.AppendElements(contentLength)) {
   1:           DestroyUserData(userData);
8573:           return nsnull;
   1:         }
   1:         PRUint8* bufStart = tempBuf.Elements();
   1:         PRUint8* end = nsTextFrameUtils::TransformText(
3233:             reinterpret_cast<const PRUint8*>(frag->Get1b()) + contentStart, contentLength,
   1:             bufStart, compressWhitespace, &mTrimNextRunLeadingWhitespace,
   1:             &builder, &analysisFlags);
3233:         aTextBuffer = ExpandBuffer(static_cast<PRUnichar*>(aTextBuffer),
   1:                                    tempBuf.Elements(), end - tempBuf.Elements());
   1:       } else {
3233:         PRUint8* bufStart = static_cast<PRUint8*>(aTextBuffer);
   1:         PRUint8* end = nsTextFrameUtils::TransformText(
3233:             reinterpret_cast<const PRUint8*>(frag->Get1b()) + contentStart, contentLength,
   1:             bufStart,
   1:             compressWhitespace, &mTrimNextRunLeadingWhitespace, &builder, &analysisFlags);
   1:         aTextBuffer = end;
   1:       }
   1:     }
1911:     // In CSS 2.1, we do not compress a space that is preceded by a non-compressible
1911:     // space.
1911:     if (!compressWhitespace) {
1911:       mTrimNextRunLeadingWhitespace = PR_FALSE;
1911:     }
   1:     textFlags |= analysisFlags;
   1: 
   1:     currentTransformedTextOffset =
3233:       (static_cast<const PRUint8*>(aTextBuffer) - static_cast<const PRUint8*>(textPtr)) >> mDoubleByteText;
   1: 
   1:     lastContent = content;
   1:     endOfLastContent = contentEnd;
   1:   }
   1: 
   1:   // Check for out-of-memory in gfxSkipCharsBuilder
   1:   if (!builder.IsOK()) {
   1:     DestroyUserData(userData);
8573:     return nsnull;
   1:   }
   1: 
   1:   void* finalUserData;
   1:   if (userData == &dummyData) {
   1:     textFlags |= nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW;
   1:     userData = nsnull;
   1:     finalUserData = mMappedFlows[0].mStartFrame;
   1:   } else {
   1:     finalUserData = userData;
   1:   }
   1: 
   1:   PRUint32 transformedLength = currentTransformedTextOffset;
   1: 
2319: //  Disable this because it breaks the word cache. Disable at least until
2319: //  we have a CharacterDataWillChange notification.
2319: //
2319: //  if (!(textFlags & nsTextFrameUtils::TEXT_WAS_TRANSFORMED) &&
2319: //      mMappedFlows.Length() == 1) {
2319: //    // The textrun maps one continuous, unmodified run of DOM text. It can
2319: //    // point to the DOM text directly.
2319: //    const nsTextFragment* frag = lastContent->GetText();
2319: //    if (frag->Is2b()) {
2319: //      textPtr = frag->Get2b() + mMappedFlows[0].mContentOffset;
2319: //    } else {
2319: //      textPtr = frag->Get1b() + mMappedFlows[0].mContentOffset;
2319: //    }
2319: //    textFlags |= gfxTextRunFactory::TEXT_IS_PERSISTENT;
2319: //  }
2319: //
   1:   // Now build the textrun
   1:   nsTextFrame* firstFrame = mMappedFlows[0].mStartFrame;
   1:   gfxFontGroup* fontGroup = GetFontGroupForFrame(firstFrame);
   1:   if (!fontGroup) {
   1:     DestroyUserData(userData);
8573:     return nsnull;
   1:   }
   1: 
   1:   if (textFlags & nsTextFrameUtils::TEXT_HAS_TAB) {
   1:     textFlags |= gfxTextRunFactory::TEXT_ENABLE_SPACING;
   1:   }
   1:   if (textFlags & nsTextFrameUtils::TEXT_HAS_SHY) {
   1:     textFlags |= gfxTextRunFactory::TEXT_ENABLE_HYPHEN_BREAKS;
   1:   }
   1:   if (mBidiEnabled && (NS_GET_EMBEDDING_LEVEL(firstFrame) & 1)) {
   1:     textFlags |= gfxTextRunFactory::TEXT_IS_RTL;
   1:   }
1328:   if (mTrimNextRunLeadingWhitespace) {
1328:     textFlags |= nsTextFrameUtils::TEXT_TRAILING_WHITESPACE;
1328:   }
4032:   // ContinueTextRunAcrossFrames guarantees that it doesn't matter which
4032:   // frame's style is used, so use the last frame's
4032:   textFlags |= nsLayoutUtils::GetTextRunFlagsForStyle(lastStyleContext,
4032:       textStyle, fontStyle);
6513:   // XXX this is a bit of a hack. For performance reasons, if we're favouring
6513:   // performance over quality, don't try to get accurate glyph extents.
6513:   if (!(textFlags & gfxTextRunFactory::TEXT_OPTIMIZE_SPEED)) {
6513:     textFlags |= gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX;
6513:   }
   1: 
   1:   gfxSkipChars skipChars;
   1:   skipChars.TakeFrom(&builder);
   1:   // Convert linebreak coordinates to transformed string offsets
   1:   NS_ASSERTION(nextBreakIndex == mLineBreakBeforeFrames.Length(),
   1:                "Didn't find all the frames to break-before...");
   1:   gfxSkipCharsIterator iter(skipChars);
5800:   nsAutoTArray<PRUint32,50> textBreakPointsAfterTransform;
5800:   for (i = 0; i < textBreakPoints.Length(); ++i) {
8330:     nsTextFrameUtils::AppendLineBreakOffset(&textBreakPointsAfterTransform, 
5800:             iter.ConvertOriginalToSkipped(textBreakPoints[i]));
   1:   }
   1:   if (mStartOfLine) {
8330:     nsTextFrameUtils::AppendLineBreakOffset(&textBreakPointsAfterTransform,
8330:                                             transformedLength);
   1:   }
   1: 
7114:   // Setup factory chain
7114:   nsAutoPtr<nsTransformingTextRunFactory> transformingFactory;
7114:   if (anySmallcapsStyle) {
7114:     transformingFactory = new nsFontVariantTextRunFactory();
7114:   }
7114:   if (anyTextTransformStyle) {
7114:     transformingFactory =
7114:       new nsCaseTransformTextRunFactory(transformingFactory.forget());
7114:   }
7114:   nsTArray<nsStyleContext*> styles;
7114:   if (transformingFactory) {
7114:     iter.SetOriginalOffset(0);
7114:     for (i = 0; i < mMappedFlows.Length(); ++i) {
7114:       MappedFlow* mappedFlow = &mMappedFlows[i];
7673:       nsTextFrame* f;
7673:       for (f = mappedFlow->mStartFrame; f != mappedFlow->mEndFrame;
7695:            f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
7114:         PRUint32 offset = iter.GetSkippedOffset();
7673:         iter.AdvanceOriginal(f->GetContentLength());
7114:         PRUint32 end = iter.GetSkippedOffset();
7673:         nsStyleContext* sc = f->GetStyleContext();
7114:         PRUint32 j;
7114:         for (j = offset; j < end; ++j) {
7114:           styles.AppendElement(sc);
7114:         }
7114:       }
7114:     }
7832:     textFlags |= nsTextFrameUtils::TEXT_IS_TRANSFORMED;
7673:     NS_ASSERTION(iter.GetSkippedOffset() == transformedLength,
7673:                  "We didn't cover all the characters in the text run!");
7673:   }
7114: 
2319:   gfxTextRun* textRun;
   1:   gfxTextRunFactory::Parameters params =
1328:       { mContext, finalUserData, &skipChars,
5800:         textBreakPointsAfterTransform.Elements(), textBreakPointsAfterTransform.Length(),
1328:         firstFrame->PresContext()->AppUnitsPerDevPixel() };
   1: 
   1:   if (mDoubleByteText) {
3233:     const PRUnichar* text = static_cast<const PRUnichar*>(textPtr);
   8:     if (transformingFactory) {
   8:       textRun = transformingFactory->MakeTextRun(text, transformedLength, &params,
1328:                                                  fontGroup, textFlags, styles.Elements());
   8:       if (textRun) {
1435:         // ownership of the factory has passed to the textrun
   8:         transformingFactory.forget();
   8:       }
   8:     } else {
1328:       textRun = MakeTextRun(text, transformedLength, fontGroup, &params, textFlags);
   8:     }
   1:   } else {
3233:     const PRUint8* text = static_cast<const PRUint8*>(textPtr);
1328:     textFlags |= gfxFontGroup::TEXT_IS_8BIT;
   8:     if (transformingFactory) {
   8:       textRun = transformingFactory->MakeTextRun(text, transformedLength, &params,
1328:                                                  fontGroup, textFlags, styles.Elements());
   8:       if (textRun) {
1435:         // ownership of the factory has passed to the textrun
   8:         transformingFactory.forget();
   8:       }
   8:     } else {
1328:       textRun = MakeTextRun(text, transformedLength, fontGroup, &params, textFlags);
   8:     }
2319:   }
   1:   if (!textRun) {
   1:     DestroyUserData(userData);
8573:     return nsnull;
   1:   }
2319: 
   1:   // We have to set these up after we've created the textrun, because
   1:   // the breaks may be stored in the textrun during this very call.
   1:   // This is a bit annoying because it requires another loop over the frames
   1:   // making up the textrun, but I don't see a way to avoid this.
2319:   SetupBreakSinksForTextRun(textRun, PR_FALSE, mSkipIncompleteTextRuns);
2319: 
2319:   if (mSkipIncompleteTextRuns) {
2319:     mSkipIncompleteTextRuns = !TextContainsLineBreakerWhiteSpace(textPtr,
2319:         transformedLength, mDoubleByteText);
2319:     
2319:     // Nuke the textrun
2319:     gTextRuns->RemoveFromCache(textRun);
2319:     delete textRun;
2319:     DestroyUserData(userData);
8573:     return nsnull;
2319:   }
   1: 
   1:   // Actually wipe out the textruns associated with the mapped frames and associate
   1:   // those frames with this text run.
   1:   AssignTextRun(textRun);
8573:   return textRun;
   1: }
   1: 
2013: static PRBool
2013: HasCompressedLeadingWhitespace(nsTextFrame* aFrame, PRInt32 aContentEndOffset,
3006:                                const gfxSkipCharsIterator& aIterator)
3006: {
3006:   if (!aIterator.IsOriginalCharSkipped())
2013:     return PR_FALSE;
2013: 
3006:   gfxSkipCharsIterator iter = aIterator;
2013:   PRInt32 frameContentOffset = aFrame->GetContentOffset();
2013:   const nsTextFragment* frag = aFrame->GetContent()->GetText();
3006:   while (frameContentOffset < aContentEndOffset && iter.IsOriginalCharSkipped()) {
3006:     if (IsTrimmableSpace(frag, frameContentOffset))
3006:       return PR_TRUE;
2013:     ++frameContentOffset;
3006:     iter.AdvanceOriginal(1);
3006:   }
3006:   return PR_FALSE;
2013: }
2013: 
   1: void
1328: BuildTextRunsScanner::SetupBreakSinksForTextRun(gfxTextRun* aTextRun,
2319:                                                 PRBool aIsExistingTextRun,
2319:                                                 PRBool aSuppressSink)
   1: {
   1:   // textruns have uniform language
   1:   nsIAtom* lang = mMappedFlows[0].mStartFrame->GetStyleVisibility()->mLangGroup;
2013:   // We keep this pointed at the skip-chars data for the current mappedFlow.
2013:   // This lets us cheaply check whether the flow has compressed initial
2013:   // whitespace...
2013:   gfxSkipCharsIterator iter(aTextRun->GetSkipChars());
2013: 
   1:   PRUint32 i;
   1:   for (i = 0; i < mMappedFlows.Length(); ++i) {
   1:     MappedFlow* mappedFlow = &mMappedFlows[i];
7114:     PRUint32 offset = iter.GetSkippedOffset();
7114:     gfxSkipCharsIterator iterNext = iter;
7114:     iterNext.AdvanceOriginal(mappedFlow->GetContentEnd() -
7114:             mappedFlow->mStartFrame->GetContentOffset());
7114: 
  60:     nsAutoPtr<BreakSink>* breakSink = mBreakSinks.AppendElement(
7114:       new BreakSink(aTextRun, mContext, offset, aIsExistingTextRun));
  60:     if (!breakSink || !*breakSink)
   1:       return;
7114: 
7114:     PRUint32 length = iterNext.GetSkippedOffset() - offset;
   1:     PRUint32 flags = 0;
2319:     nsIFrame* initialBreakController = mappedFlow->mAncestorControllingInitialBreak;
2319:     if (!initialBreakController) {
2319:       initialBreakController = mLineContainer;
2319:     }
7069:     if (!initialBreakController->GetStyleText()->WhiteSpaceCanWrap()) {
7069:       flags |= nsLineBreaker::BREAK_SUPPRESS_INITIAL;
7069:     }
7069:     nsTextFrame* startFrame = mappedFlow->mStartFrame;
2013:     const nsStyleText* textStyle = startFrame->GetStyleText();
7069:     if (!textStyle->WhiteSpaceCanWrap()) {
7069:       flags |= nsLineBreaker::BREAK_SUPPRESS_INSIDE;
7069:     }
7069:     if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_NO_BREAKS) {
7069:       flags |= nsLineBreaker::BREAK_SKIP_SETTING_NO_BREAKS;
7069:     }
7832:     if (textStyle->mTextTransform == NS_STYLE_TEXT_TRANSFORM_CAPITALIZE) {
7832:       flags |= nsLineBreaker::BREAK_NEED_CAPITALIZATION;
7832:     }
7069: 
7069:     if (HasCompressedLeadingWhitespace(startFrame, mappedFlow->GetContentEnd(), iter)) {
7069:       mLineBreaker.AppendInvisibleWhitespace(flags);
7069:     }
7069: 
7069:     if (length > 0) {
7069:       BreakSink* sink = aSuppressSink ? nsnull : (*breakSink).get();
1328:       if (aTextRun->GetFlags() & gfxFontGroup::TEXT_IS_8BIT) {
1328:         mLineBreaker.AppendText(lang, aTextRun->GetText8Bit() + offset,
2319:                                 length, flags, sink);
   1:       } else {
1328:         mLineBreaker.AppendText(lang, aTextRun->GetTextUnicode() + offset,
2319:                                 length, flags, sink);
   1:       }
   1:     }
2013:     
7114:     iter = iterNext;
2013:   }
   1: }
   1: 
   1: void
   1: BuildTextRunsScanner::AssignTextRun(gfxTextRun* aTextRun)
   1: {
   1:   nsIContent* lastContent = nsnull;
   1:   PRUint32 i;
   1:   for (i = 0; i < mMappedFlows.Length(); ++i) {
   1:     MappedFlow* mappedFlow = &mMappedFlows[i];
   8:     nsTextFrame* startFrame = mappedFlow->mStartFrame;
   8:     nsTextFrame* endFrame = mappedFlow->mEndFrame;
   8:     nsTextFrame* f;
   8:     for (f = startFrame; f != endFrame;
6033:          f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
2828: #ifdef DEBUG_roc
   8:       if (f->GetTextRun()) {
   8:         gfxTextRun* textRun = f->GetTextRun();
   8:         if (textRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
3233:           if (mMappedFlows[0].mStartFrame != static_cast<nsTextFrame*>(textRun->GetUserData())) {
   8:             NS_WARNING("REASSIGNING SIMPLE FLOW TEXT RUN!");
   8:           }
   8:         } else {
   8:           TextRunUserData* userData =
3233:             static_cast<TextRunUserData*>(textRun->GetUserData());
   8:          
   8:           if (PRUint32(userData->mMappedFlowCount) >= mMappedFlows.Length() ||
   8:               userData->mMappedFlows[userData->mMappedFlowCount - 1].mStartFrame !=
   8:               mMappedFlows[userData->mMappedFlowCount - 1].mStartFrame) {
   8:             NS_WARNING("REASSIGNING MULTIFLOW TEXT RUN (not append)!");
   8:           }
   8:         }
   8:       }
   8: #endif
   1:       f->ClearTextRun();
   1:       f->SetTextRun(aTextRun);
   1:     }
3009:     // BuildTextRunForFrames mashes together mapped flows for the same element,
3009:     // so we do that here too.
5728:     lastContent = startFrame->GetContent();
   1:   }
   1: }
   1: 
   1: gfxSkipCharsIterator
6862: nsTextFrame::EnsureTextRun(gfxContext* aReferenceContext, nsIFrame* aLineContainer,
   1:                            const nsLineList::iterator* aLine,
4672:                            PRUint32* aFlowEndInTextRun)
4672: {
6029:   if (mTextRun && (!aLine || !(*aLine)->GetInvalidateTextRuns())) {
1328:     if (mTextRun->GetExpirationState()->IsTracked()) {
1328:       gTextRuns->MarkUsed(mTextRun);
1328:     }
1328:   } else {
6862:     nsRefPtr<gfxContext> ctx = aReferenceContext;
6862:     if (!ctx) {
6862:       ctx = GetReferenceRenderingContext(this, nsnull);
6862:     }
6862:     if (ctx) {
6862:       BuildTextRuns(ctx, this, aLineContainer, aLine);
1563:     }
   1:     if (!mTextRun) {
   1:       // A text run was not constructed for this frame. This is bad. The caller
   1:       // will check mTextRun.
   1:       static const gfxSkipChars emptySkipChars;
   1:       return gfxSkipCharsIterator(emptySkipChars, 0);
   1:     }
   1:   }
   1: 
   1:   if (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
   1:     if (aFlowEndInTextRun) {
   1:       *aFlowEndInTextRun = mTextRun->GetLength();
   1:     }
   1:     return gfxSkipCharsIterator(mTextRun->GetSkipChars(), 0, mContentOffset);
   1:   }
   1: 
3233:   TextRunUserData* userData = static_cast<TextRunUserData*>(mTextRun->GetUserData());
   1:   // Find the flow that contains us
   1:   PRInt32 direction;
   1:   PRInt32 startAt = userData->mLastFlowIndex;
   1:   // Search first forward and then backward from the current position
   1:   for (direction = 1; direction >= -1; direction -= 2) {
   1:     PRInt32 i;
   1:     for (i = startAt; 0 <= i && i < userData->mMappedFlowCount; i += direction) {
   1:       TextRunMappedFlow* flow = &userData->mMappedFlows[i];
   1:       if (flow->mStartFrame->GetContent() == mContent) {
7012:         // Since textruns can only contain one flow for a given content element,
7012:         // this must be our flow.
   1:         userData->mLastFlowIndex = i;
   1:         gfxSkipCharsIterator iter(mTextRun->GetSkipChars(),
   1:                                   flow->mDOMOffsetToBeforeTransformOffset, mContentOffset);
   1:         if (aFlowEndInTextRun) {
   1:           if (i + 1 < userData->mMappedFlowCount) {
   1:             gfxSkipCharsIterator end(mTextRun->GetSkipChars());
   1:             *aFlowEndInTextRun = end.ConvertOriginalToSkipped(
   1:                 flow[1].mStartFrame->GetContentOffset() + flow[1].mDOMOffsetToBeforeTransformOffset);
   1:           } else {
   1:             *aFlowEndInTextRun = mTextRun->GetLength();
   1:           }
   1:         }
   1:         return iter;
   1:       }
   1:       ++flow;
   1:     }
   1:     startAt = userData->mLastFlowIndex - 1;
   1:   }
   1:   NS_ERROR("Can't find flow containing this frame???");
   1:   static const gfxSkipChars emptySkipChars;
   1:   return gfxSkipCharsIterator(emptySkipChars, 0);
   1: }
   1: 
   8: static PRUint32
2013: GetEndOfTrimmedText(const nsTextFragment* aFrag,
   8:                     PRUint32 aStart, PRUint32 aEnd,
   8:                     gfxSkipCharsIterator* aIterator)
   8: {
   8:   aIterator->SetSkippedOffset(aEnd);
   8:   while (aIterator->GetSkippedOffset() > aStart) {
   8:     aIterator->AdvanceSkipped(-1);
2344:     if (!IsTrimmableSpace(aFrag, aIterator->GetOriginalOffset()))
2013:       return aIterator->GetSkippedOffset() + 1;
2013:   }
2013:   return aStart;
   8: }
   8: 
   8: nsTextFrame::TrimmedOffsets
   8: nsTextFrame::GetTrimmedOffsets(const nsTextFragment* aFrag,
   8:                                PRBool aTrimAfter)
   1: {
   1:   NS_ASSERTION(mTextRun, "Need textrun here");
   1: 
4678:   TrimmedOffsets offsets = { GetContentOffset(), GetContentLength() };
1912:   const nsStyleText* textStyle = GetStyleText();
1912:   if (textStyle->WhiteSpaceIsSignificant())
   8:     return offsets;
   8: 
   8:   if (GetStateBits() & TEXT_START_OF_LINE) {
   8:     PRInt32 whitespaceCount =
2344:       GetTrimmableWhitespaceCount(aFrag, offsets.mStart, offsets.mLength, 1);
   8:     offsets.mStart += whitespaceCount;
   8:     offsets.mLength -= whitespaceCount;
   8:   }
   8: 
7069:   if (aTrimAfter && (GetStateBits() & TEXT_END_OF_LINE)) {
   8:     PRInt32 whitespaceCount =
4261:       GetTrimmableWhitespaceCount(aFrag, offsets.GetEnd() - 1,
2344:                                   offsets.mLength, -1);
   8:     offsets.mLength -= whitespaceCount;
   8:   }
   8:   return offsets;
   1: }
   1: 
   1: /*
   1:  * Currently only Unicode characters below 0x10000 have their spacing modified
   1:  * by justification. If characters above 0x10000 turn out to need
   1:  * justification spacing, that will require extra work. Currently,
   1:  * this function must not include 0xd800 to 0xdbff because these characters
   1:  * are surrogates.
   1:  */
   1: static PRBool IsJustifiableCharacter(const nsTextFragment* aFrag, PRInt32 aPos,
   1:                                      PRBool aLangIsCJ)
   1: {
   1:   PRUnichar ch = aFrag->CharAt(aPos);
 202:   if (ch == '\n' || ch == '\t')
 202:     return PR_TRUE;
 202:   if (ch == ' ') {
   1:     // Don't justify spaces that are combined with diacriticals
   1:     if (!aFrag->Is2b())
   1:       return PR_TRUE;
   1:     return !nsTextFrameUtils::IsSpaceCombiningSequenceTail(
   1:         aFrag->Get2b() + aPos + 1, aFrag->GetLength() - (aPos + 1));
   1:   }
   1:   if (ch < 0x2150u)
   1:     return PR_FALSE;
   1:   if (aLangIsCJ && (
   1:        (0x2150u <= ch && ch <= 0x22ffu) || // Number Forms, Arrows, Mathematical Operators
   1:        (0x2460u <= ch && ch <= 0x24ffu) || // Enclosed Alphanumerics
   1:        (0x2580u <= ch && ch <= 0x27bfu) || // Block Elements, Geometric Shapes, Miscellaneous Symbols, Dingbats
   1:        (0x27f0u <= ch && ch <= 0x2bffu) || // Supplemental Arrows-A, Braille Patterns, Supplemental Arrows-B,
   1:                                            // Miscellaneous Mathematical Symbols-B, Supplemental Mathematical Operators,
   1:                                            // Miscellaneous Symbols and Arrows
   1:        (0x2e80u <= ch && ch <= 0x312fu) || // CJK Radicals Supplement, CJK Radicals Supplement,
   1:                                            // Ideographic Description Characters, CJK Symbols and Punctuation,
   1:                                            // Hiragana, Katakana, Bopomofo
   1:        (0x3190u <= ch && ch <= 0xabffu) || // Kanbun, Bopomofo Extended, Katakana Phonetic Extensions,
   1:                                            // Enclosed CJK Letters and Months, CJK Compatibility,
   1:                                            // CJK Unified Ideographs Extension A, Yijing Hexagram Symbols,
   1:                                            // CJK Unified Ideographs, Yi Syllables, Yi Radicals
   1:        (0xf900u <= ch && ch <= 0xfaffu) || // CJK Compatibility Ideographs
   1:        (0xff5eu <= ch && ch <= 0xff9fu)    // Halfwidth and Fullwidth Forms(a part)
   1:      ))
   1:     return PR_TRUE;
   1:   return PR_FALSE;
   1: }
   1: 
   1: static void ClearMetrics(nsHTMLReflowMetrics& aMetrics)
   1: {
   1:   aMetrics.width = 0;
   1:   aMetrics.height = 0;
   1:   aMetrics.ascent = 0;
   1: }
   1: 
   1: static PRInt32 FindChar(const nsTextFragment* frag,
   1:                         PRInt32 aOffset, PRInt32 aLength, PRUnichar ch)
   1: {
   1:   PRInt32 i = 0;
   1:   if (frag->Is2b()) {
   1:     const PRUnichar* str = frag->Get2b() + aOffset;
   1:     for (; i < aLength; ++i) {
   1:       if (*str == ch)
   1:         return i + aOffset;
   1:       ++str;
   1:     }
   1:   } else {
   1:     if (PRUint16(ch) <= 0xFF) {
   1:       const char* str = frag->Get1b() + aOffset;
1344:       const void* p = memchr(str, ch, aLength);
   1:       if (p)
3233:         return (static_cast<const char*>(p) - str) + aOffset;
   1:     }
   1:   }
   1:   return -1;
   1: }
   1: 
   1: static PRBool IsChineseJapaneseLangGroup(nsIFrame* aFrame)
   1: {
   1:   nsIAtom* langGroup = aFrame->GetStyleVisibility()->mLangGroup;
   1:   return langGroup == nsGkAtoms::Japanese
   1:       || langGroup == nsGkAtoms::Chinese
   1:       || langGroup == nsGkAtoms::Taiwanese
   1:       || langGroup == nsGkAtoms::HongKongChinese;
   1: }
   1: 
   1: #ifdef DEBUG
   1: static PRBool IsInBounds(const gfxSkipCharsIterator& aStart, PRInt32 aContentLength,
   1:                          PRUint32 aOffset, PRUint32 aLength) {
   1:   if (aStart.GetSkippedOffset() > aOffset)
   1:     return PR_FALSE;
8556:   if (aContentLength == PR_INT32_MAX)
8556:     return PR_TRUE;
   1:   gfxSkipCharsIterator iter(aStart);
1756:   iter.AdvanceOriginal(aContentLength);
1756:   return iter.GetSkippedOffset() >= aOffset + aLength;
   1: }
   1: #endif
   1: 
   1: class PropertyProvider : public gfxTextRun::PropertyProvider {
   1: public:
   1:   /**
   1:    * Use this constructor for reflow, when we don't know what text is
   1:    * really mapped by the frame and we have a lot of other data around.
8556:    * 
8556:    * @param aLength can be PR_INT32_MAX to indicate we cover all the text
8556:    * associated with aFrame up to where its flow chain ends in the given
8556:    * textrun. If PR_INT32_MAX is passed, justification and hyphen-related methods
8556:    * cannot be called, nor can GetOriginalLength().
   1:    */
   1:   PropertyProvider(gfxTextRun* aTextRun, const nsStyleText* aTextStyle,
   1:                    const nsTextFragment* aFrag, nsTextFrame* aFrame,
1732:                    const gfxSkipCharsIterator& aStart, PRInt32 aLength,
1732:                    nsIFrame* aLineContainer,
1732:                    nscoord aOffsetFromBlockOriginForTabs)
   1:     : mTextRun(aTextRun), mFontGroup(nsnull), mTextStyle(aTextStyle), mFrag(aFrag),
1732:       mLineContainer(aLineContainer),
2013:       mFrame(aFrame), mStart(aStart), mTempIterator(aStart),
2013:       mTabWidths(nsnull), mLength(aLength),
   1:       mWordSpacing(StyleToCoord(mTextStyle->mWordSpacing)),
   1:       mLetterSpacing(StyleToCoord(mTextStyle->mLetterSpacing)),
   1:       mJustificationSpacing(0),
1732:       mHyphenWidth(-1),
1732:       mOffsetFromBlockOriginForTabs(aOffsetFromBlockOriginForTabs),
1732:       mReflowing(PR_TRUE)
   1:   {
   1:     NS_ASSERTION(mStart.IsInitialized(), "Start not initialized?");
   1:   }
   1: 
   1:   /**
   1:    * Use this constructor after the frame has been reflowed and we don't
   1:    * have other data around. Gets everything from the frame. EnsureTextRun
   1:    * *must* be called before this!!!
   1:    */
   1:   PropertyProvider(nsTextFrame* aFrame, const gfxSkipCharsIterator& aStart)
1732:     : mTextRun(aFrame->GetTextRun()), mFontGroup(nsnull),
1732:       mTextStyle(aFrame->GetStyleText()),
   1:       mFrag(aFrame->GetContent()->GetText()),
1732:       mLineContainer(nsnull),
2013:       mFrame(aFrame), mStart(aStart), mTempIterator(aStart),
2013:       mTabWidths(nsnull),
1732:       mLength(aFrame->GetContentLength()),
   1:       mWordSpacing(StyleToCoord(mTextStyle->mWordSpacing)),
   1:       mLetterSpacing(StyleToCoord(mTextStyle->mLetterSpacing)),
   1:       mJustificationSpacing(0),
1732:       mHyphenWidth(-1),
1732:       mOffsetFromBlockOriginForTabs(0),
1732:       mReflowing(PR_FALSE)
   1:   {
   1:     NS_ASSERTION(mTextRun, "Textrun not initialized!");
   1:   }
   1: 
   1:   // Call this after construction if you're not going to reflow the text
   1:   void InitializeForDisplay(PRBool aTrimAfter);
   1: 
   1:   virtual void GetSpacing(PRUint32 aStart, PRUint32 aLength, Spacing* aSpacing);
   1:   virtual gfxFloat GetHyphenWidth();
   1:   virtual void GetHyphenationBreaks(PRUint32 aStart, PRUint32 aLength,
   1:                                     PRPackedBool* aBreakBefore);
   1: 
1732:   void GetSpacingInternal(PRUint32 aStart, PRUint32 aLength, Spacing* aSpacing,
1732:                           PRBool aIgnoreTabs);
1732: 
   1:   /**
   1:    * Count the number of justifiable characters in the given DOM range
   1:    */
   1:   PRUint32 ComputeJustifiableCharacters(PRInt32 aOffset, PRInt32 aLength);
8514:   /**
8514:    * Find the start and end of the justifiable characters. Does not depend on the
8514:    * position of aStart or aEnd, although it's most efficient if they are near the
8514:    * start and end of the text frame.
8514:    */
7076:   void FindJustificationRange(gfxSkipCharsIterator* aStart,
7076:                               gfxSkipCharsIterator* aEnd);
   1: 
   8:   const nsStyleText* GetStyleText() { return mTextStyle; }
   1:   nsTextFrame* GetFrame() { return mFrame; }
   1:   // This may not be equal to the frame offset/length in because we may have
   1:   // adjusted for whitespace trimming according to the state bits set in the frame
   1:   // (for the static provider)
   1:   const gfxSkipCharsIterator& GetStart() { return mStart; }
8474:   // May return PR_INT32_MAX if that was given to the constructor
8556:   PRUint32 GetOriginalLength() {
8556:     NS_ASSERTION(mLength != PR_INT32_MAX, "Length not known");
8556:     return mLength;
8556:   }
   1:   const nsTextFragment* GetFragment() { return mFrag; }
   1: 
   1:   gfxFontGroup* GetFontGroup() {
   1:     if (!mFontGroup) {
   1:       mFontGroup = GetFontGroupForFrame(mFrame);
   1:     }
   1:     return mFontGroup;
   1:   }
   1: 
1732:   gfxFloat* GetTabWidths(PRUint32 aTransformedStart, PRUint32 aTransformedLength);
1732: 
2013:   const gfxSkipCharsIterator& GetEndHint() { return mTempIterator; }
2013: 
   1: protected:
   1:   void SetupJustificationSpacing();
   1:   
   1:   gfxTextRun*           mTextRun;
   1:   gfxFontGroup*         mFontGroup;
   1:   const nsStyleText*    mTextStyle;
   1:   const nsTextFragment* mFrag;
1732:   nsIFrame*             mLineContainer;
   1:   nsTextFrame*          mFrame;
   1:   gfxSkipCharsIterator  mStart;  // Offset in original and transformed string
2013:   gfxSkipCharsIterator  mTempIterator;
1732:   nsTArray<gfxFloat>*   mTabWidths;  // widths for each transformed string character
8556:   PRInt32               mLength; // DOM string length, may be PR_INT32_MAX
   1:   gfxFloat              mWordSpacing;     // space for each whitespace char
   1:   gfxFloat              mLetterSpacing;   // space for each letter
   1:   gfxFloat              mJustificationSpacing;
   1:   gfxFloat              mHyphenWidth;
1732:   gfxFloat              mOffsetFromBlockOriginForTabs;
1732:   PRPackedBool          mReflowing;
   1: };
   1: 
   1: PRUint32
   1: PropertyProvider::ComputeJustifiableCharacters(PRInt32 aOffset, PRInt32 aLength)
   1: {
   1:   // Scan non-skipped characters and count justifiable chars.
   1:   nsSkipCharsRunIterator
   1:     run(mStart, nsSkipCharsRunIterator::LENGTH_INCLUDES_SKIPPED, aLength);
   1:   run.SetOriginalOffset(aOffset);
   1:   PRUint32 justifiableChars = 0;
   1:   PRBool isCJK = IsChineseJapaneseLangGroup(mFrame);
   1:   while (run.NextRun()) {
   1:     PRInt32 i;
   1:     for (i = 0; i < run.GetRunLength(); ++i) {
   1:       justifiableChars +=
   1:         IsJustifiableCharacter(mFrag, run.GetOriginalOffset() + i, isCJK);
   1:     }
   1:   }
   1:   return justifiableChars;
   1: }
   1: 
   1: /**
   1:  * Finds the offset of the first character of the cluster containing aPos
   1:  */
   1: static void FindClusterStart(gfxTextRun* aTextRun,
   1:                              gfxSkipCharsIterator* aPos)
   1: {
   1:   while (aPos->GetOriginalOffset() > 0) {
   1:     if (aPos->IsOriginalCharSkipped() ||
   8:         aTextRun->IsClusterStart(aPos->GetSkippedOffset())) {
   1:       break;
   1:     }
   1:     aPos->AdvanceOriginal(-1);
   1:   }
   1: }
   1: 
   1: /**
   1:  * Finds the offset of the last character of the cluster containing aPos
   1:  */
   1: static void FindClusterEnd(gfxTextRun* aTextRun, PRInt32 aOriginalEnd,
   1:                            gfxSkipCharsIterator* aPos)
   1: {
   1:   NS_PRECONDITION(aPos->GetOriginalOffset() < aOriginalEnd,
   1:                   "character outside string");
   1:   aPos->AdvanceOriginal(1);
   1:   while (aPos->GetOriginalOffset() < aOriginalEnd) {
   1:     if (aPos->IsOriginalCharSkipped() ||
   8:         aTextRun->IsClusterStart(aPos->GetSkippedOffset())) {
   1:       break;
   1:     }
   1:     aPos->AdvanceOriginal(1);
   1:   }
   1:   aPos->AdvanceOriginal(-1);
   1: }
   1: 
   1: // aStart, aLength in transformed string offsets
   1: void
   1: PropertyProvider::GetSpacing(PRUint32 aStart, PRUint32 aLength,
   1:                              Spacing* aSpacing)
   1: {
1732:   GetSpacingInternal(aStart, aLength, aSpacing,
1732:                      (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TAB) == 0);
1732: }
1732: 
2027: static PRBool
2027: CanAddSpacingAfter(gfxTextRun* aTextRun, PRUint32 aOffset)
2027: {
2027:   if (aOffset + 1 >= aTextRun->GetLength())
2027:     return PR_TRUE;
2027:   return aTextRun->IsClusterStart(aOffset + 1) &&
7715:     aTextRun->IsLigatureGroupStart(aOffset + 1);
2027: }
2027: 
1732: void
1732: PropertyProvider::GetSpacingInternal(PRUint32 aStart, PRUint32 aLength,
1732:                                      Spacing* aSpacing, PRBool aIgnoreTabs)
1732: {
   1:   NS_PRECONDITION(IsInBounds(mStart, mLength, aStart, aLength), "Range out of bounds");
   1: 
   1:   PRUint32 index;
   1:   for (index = 0; index < aLength; ++index) {
   1:     aSpacing[index].mBefore = 0.0;
   1:     aSpacing[index].mAfter = 0.0;
   1:   }
   1: 
   1:   // Find our offset into the original+transformed string
   1:   gfxSkipCharsIterator start(mStart);
   1:   start.SetSkippedOffset(aStart);
   1: 
   1:   // First, compute the word and letter spacing
   1:   if (mWordSpacing || mLetterSpacing) {
   1:     // Iterate over non-skipped characters
   1:     nsSkipCharsRunIterator
   1:       run(start, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
   1:     while (run.NextRun()) {
   1:       PRUint32 runOffsetInSubstring = run.GetSkippedOffset() - aStart;
   1:       PRInt32 i;
   8:       gfxSkipCharsIterator iter = run.GetPos();
   1:       for (i = 0; i < run.GetRunLength(); ++i) {
2027:         if (CanAddSpacingAfter(mTextRun, run.GetSkippedOffset() + i)) {
2027:           // End of a cluster, not in a ligature: put letter-spacing after it
   1:           aSpacing[runOffsetInSubstring + i].mAfter += mLetterSpacing;
   1:         }
   1:         if (IsCSSWordSpacingSpace(mFrag, i + run.GetOriginalOffset())) {
   1:           // It kinda sucks, but space characters can be part of clusters,
   1:           // and even still be whitespace (I think!)
   8:           iter.SetSkippedOffset(run.GetSkippedOffset() + i);
   8:           FindClusterEnd(mTextRun, run.GetOriginalOffset() + run.GetRunLength(),
   8:                          &iter);
   8:           aSpacing[iter.GetSkippedOffset() - aStart].mAfter += mWordSpacing;
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   // Now add tab spacing, if there is any
1732:   if (!aIgnoreTabs) {
1732:     gfxFloat* tabs = GetTabWidths(aStart, aLength);
1732:     if (tabs) {
   1:       for (index = 0; index < aLength; ++index) {
1732:         aSpacing[index].mAfter += tabs[index];
1732:       }
   1:     }
   1:   }
   1: 
   1:   // Now add in justification spacing
   1:   if (mJustificationSpacing) {
   1:     gfxFloat halfJustificationSpace = mJustificationSpacing/2;
   1:     // Scan non-skipped characters and adjust justifiable chars, adding
   1:     // justification space on either side of the cluster
   1:     PRBool isCJK = IsChineseJapaneseLangGroup(mFrame);
7076:     gfxSkipCharsIterator justificationStart(mStart), justificationEnd(mStart);
7076:     FindJustificationRange(&justificationStart, &justificationEnd);
   1: 
   1:     nsSkipCharsRunIterator
   1:       run(start, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
   1:     while (run.NextRun()) {
   1:       PRInt32 i;
   8:       gfxSkipCharsIterator iter = run.GetPos();
   1:       for (i = 0; i < run.GetRunLength(); ++i) {
   8:         PRInt32 originalOffset = run.GetOriginalOffset() + i;
   8:         if (IsJustifiableCharacter(mFrag, originalOffset, isCJK)) {
   8:           iter.SetOriginalOffset(originalOffset);
   8:           FindClusterStart(mTextRun, &iter);
   8:           PRUint32 clusterFirstChar = iter.GetSkippedOffset();
   8:           FindClusterEnd(mTextRun, run.GetOriginalOffset() + run.GetRunLength(), &iter);
   8:           PRUint32 clusterLastChar = iter.GetSkippedOffset();
   1:           // Only apply justification to characters before justificationEnd
7076:           if (clusterFirstChar >= justificationStart.GetSkippedOffset() &&
7076:               clusterLastChar < justificationEnd.GetSkippedOffset()) {
   8:             aSpacing[clusterFirstChar - aStart].mBefore += halfJustificationSpace;
   8:             aSpacing[clusterLastChar - aStart].mAfter += halfJustificationSpace;
   1:           }
   1:         }
   1:       }
   1:     }
   1:   }
   1: }
   1: 
1732: static void TabWidthDestructor(void* aObject, nsIAtom* aProp, void* aValue,
1732:                                void* aData)
   1: {
3233:   delete static_cast<nsTArray<gfxFloat>*>(aValue);
1732: }
1732: 
1732: gfxFloat*
1732: PropertyProvider::GetTabWidths(PRUint32 aStart, PRUint32 aLength)
1732: {
1732:   if (!mTabWidths) {
1732:     if (!mReflowing) {
3233:       mTabWidths = static_cast<nsTArray<gfxFloat>*>
3233:                               (mFrame->GetProperty(nsGkAtoms::tabWidthProperty));
1732:       if (!mTabWidths) {
1732:         NS_WARNING("We need precomputed tab widths, but they're not here...");
1732:         return nsnull;
1732:       }
1732:     } else {
1732:       nsAutoPtr<nsTArray<gfxFloat> > tabs(new nsTArray<gfxFloat>());
1732:       if (!tabs)
1732:         return nsnull;
1732:       nsresult rv = mFrame->SetProperty(nsGkAtoms::tabWidthProperty, tabs,
1732:                                         TabWidthDestructor, nsnull);
1732:       if (NS_FAILED(rv))
1732:         return nsnull;
1732:       mTabWidths = tabs.forget();
1732:     }
1732:   }
1732: 
1732:   PRUint32 startOffset = mStart.GetSkippedOffset();
1732:   PRUint32 tabsEnd = startOffset + mTabWidths->Length();
1732:   if (tabsEnd < aStart + aLength) {
1732:     if (!mReflowing) {
1732:       NS_WARNING("We need precomputed tab widths, but we don't have enough...");
1732:       return nsnull;
1732:     }
1732:     
1732:     if (!mTabWidths->AppendElements(aStart + aLength - tabsEnd))
1732:       return nsnull;
1732:     
   1:     PRUint32 i;
1732:     if (!mLineContainer) {
1732:       NS_WARNING("Tabs encountered in a situation where we don't support tabbing");
1732:       for (i = tabsEnd; i < aStart + aLength; ++i) {
1732:         (*mTabWidths)[i - startOffset] = 0;
1732:       }
1732:     } else {
1732:       gfxFloat tabWidth = NS_round(8*mTextRun->GetAppUnitsPerDevUnit()*
1732:         GetFontMetrics(GetFontGroupForFrame(mLineContainer)).spaceWidth);
1732:       
1732:       for (i = tabsEnd; i < aStart + aLength; ++i) {
1732:         Spacing spacing;
1732:         GetSpacingInternal(i, 1, &spacing, PR_TRUE);
1732:         mOffsetFromBlockOriginForTabs += spacing.mBefore;
1732:   
1732:         if (mTextRun->GetChar(i) != '\t') {
1732:           (*mTabWidths)[i - startOffset] = 0;
1732:           if (mTextRun->IsClusterStart(i)) {
1732:             PRUint32 clusterEnd = i + 1;
1732:             while (clusterEnd < mTextRun->GetLength() &&
1732:                    !mTextRun->IsClusterStart(clusterEnd)) {
1732:               ++clusterEnd;
1732:             }
1732:             mOffsetFromBlockOriginForTabs +=
1732:               mTextRun->GetAdvanceWidth(i, clusterEnd - i, nsnull);
1732:           }
1732:         } else {
1732:           // Advance mOffsetFromBlockOriginForTabs to the next multiple of tabWidth
1732:           // Ensure that if it's just epsilon less than a multiple of tabWidth, we still
1732:           // advance by tabWidth.
1732:           static const double EPSILON = 0.000001;
1732:           double nextTab = NS_ceil(mOffsetFromBlockOriginForTabs/tabWidth)*tabWidth;
1732:           if (nextTab < mOffsetFromBlockOriginForTabs + EPSILON) {
1732:             nextTab += tabWidth;
1732:           }
1732:           (*mTabWidths)[i - startOffset] = nextTab - mOffsetFromBlockOriginForTabs;
1732:           mOffsetFromBlockOriginForTabs = nextTab;
1732:         }
1732:   
1732:         mOffsetFromBlockOriginForTabs += spacing.mAfter;
1732:       }
1732:     }
1732:   }
1732: 
1732:   return mTabWidths->Elements() + aStart - startOffset;
   1: }
   1: 
   1: gfxFloat
   1: PropertyProvider::GetHyphenWidth()
   1: {
   1:   if (mHyphenWidth < 0) {
6862:     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, mFrame));
   1:     mHyphenWidth = mLetterSpacing;
5724:     if (hyphenTextRun.get()) {
   1:       mHyphenWidth += hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull);
   1:     }
   1:   }
   1:   return mHyphenWidth;
   1: }
   1: 
   1: void
   1: PropertyProvider::GetHyphenationBreaks(PRUint32 aStart, PRUint32 aLength,
   1:                                        PRPackedBool* aBreakBefore)
   1: {
   1:   NS_PRECONDITION(IsInBounds(mStart, mLength, aStart, aLength), "Range out of bounds");
8556:   NS_PRECONDITION(mLength != PR_INT32_MAX, "Can't call this with undefined length");
   1: 
   1:   if (!mTextStyle->WhiteSpaceCanWrap()) {
   1:     memset(aBreakBefore, PR_FALSE, aLength);
   1:     return;
   1:   }
   1: 
   1:   // Iterate through the original-string character runs
   1:   nsSkipCharsRunIterator
 202:     run(mStart, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
   1:   run.SetSkippedOffset(aStart);
   1:   // We need to visit skipped characters so that we can detect SHY
   1:   run.SetVisitSkipped();
   1: 
5422:   PRInt32 prevTrailingCharOffset = run.GetPos().GetOriginalOffset() - 1;
   1:   PRBool allowHyphenBreakBeforeNextChar =
5422:     prevTrailingCharOffset >= mStart.GetOriginalOffset() &&
5422:     prevTrailingCharOffset < mStart.GetOriginalOffset() + mLength &&
5422:     mFrag->CharAt(prevTrailingCharOffset) == CH_SHY;
   1: 
   1:   while (run.NextRun()) {
   1:     NS_ASSERTION(run.GetRunLength() > 0, "Shouldn't return zero-length runs");
   1:     if (run.IsSkipped()) {
   1:       // Check if there's a soft hyphen which would let us hyphenate before
   1:       // the next non-skipped character. Don't look at soft hyphens followed
   1:       // by other skipped characters, we won't use them.
   1:       allowHyphenBreakBeforeNextChar =
   1:         mFrag->CharAt(run.GetOriginalOffset() + run.GetRunLength() - 1) == CH_SHY;
   1:     } else {
   1:       PRInt32 runOffsetInSubstring = run.GetSkippedOffset() - aStart;
   1:       memset(aBreakBefore + runOffsetInSubstring, 0, run.GetRunLength());
3006:       // Don't allow hyphen breaks at the start of the line
3006:       aBreakBefore[runOffsetInSubstring] = allowHyphenBreakBeforeNextChar &&
3006:           (!(mFrame->GetStateBits() & TEXT_START_OF_LINE) ||
3006:            run.GetSkippedOffset() > mStart.GetSkippedOffset());
   1:       allowHyphenBreakBeforeNextChar = PR_FALSE;
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: PropertyProvider::InitializeForDisplay(PRBool aTrimAfter)
   1: {
   8:   nsTextFrame::TrimmedOffsets trimmed =
   8:     mFrame->GetTrimmedOffsets(mFrag, aTrimAfter);
   8:   mStart.SetOriginalOffset(trimmed.mStart);
   8:   mLength = trimmed.mLength;
   1:   SetupJustificationSpacing();
   1: }
   1: 
   1: static PRUint32 GetSkippedDistance(const gfxSkipCharsIterator& aStart,
   1:                                    const gfxSkipCharsIterator& aEnd)
   1: {
   1:   return aEnd.GetSkippedOffset() - aStart.GetSkippedOffset();
   1: }
   1: 
   1: void
7076: PropertyProvider::FindJustificationRange(gfxSkipCharsIterator* aStart,
7076:                                          gfxSkipCharsIterator* aEnd)
7076: {
8556:   NS_PRECONDITION(mLength != PR_INT32_MAX, "Can't call this with undefined length");
7076:   NS_ASSERTION(aStart && aEnd, "aStart or/and aEnd is null");
8556: 
7076:   aStart->SetOriginalOffset(mStart.GetOriginalOffset());
7076:   aEnd->SetOriginalOffset(mStart.GetOriginalOffset() + mLength);
7076: 
7076:   // Ignore first cluster at start of line for justification purposes
7076:   if (mFrame->GetStateBits() & TEXT_START_OF_LINE) {
7076:     while (aStart->GetOriginalOffset() < aEnd->GetOriginalOffset()) {
7076:       aStart->AdvanceOriginal(1);
7076:       if (!aStart->IsOriginalCharSkipped() &&
7076:           mTextRun->IsClusterStart(aStart->GetSkippedOffset()))
7076:         break;
7076:     }
7076:   }
7002: 
7002:   // Ignore trailing cluster at end of line for justification purposes
7076:   if (mFrame->GetStateBits() & TEXT_END_OF_LINE) {
7076:     while (aEnd->GetOriginalOffset() > aStart->GetOriginalOffset()) {
7076:       aEnd->AdvanceOriginal(-1);
7076:       if (!aEnd->IsOriginalCharSkipped() &&
7076:           mTextRun->IsClusterStart(aEnd->GetSkippedOffset()))
6947:         break;
6947:     }
6947:   }
7076: }
1320: 
   1: void
   1: PropertyProvider::SetupJustificationSpacing()
   1: {
8556:   NS_PRECONDITION(mLength != PR_INT32_MAX, "Can't call this with undefined length");
8556: 
   1:   if (NS_STYLE_TEXT_ALIGN_JUSTIFY != mTextStyle->mTextAlign ||
   1:       mTextStyle->WhiteSpaceIsSignificant())
   1:     return;
   1: 
7076:   gfxSkipCharsIterator start(mStart), end(mStart);
   1:   end.AdvanceOriginal(mLength);
   1:   gfxSkipCharsIterator realEnd(end);
7076:   FindJustificationRange(&start, &end);
   1: 
   1:   PRInt32 justifiableCharacters =
7076:     ComputeJustifiableCharacters(start.GetOriginalOffset(),
7076:                                  end.GetOriginalOffset() - start.GetOriginalOffset());
   1:   if (justifiableCharacters == 0) {
   1:     // Nothing to do, nothing is justifiable and we shouldn't have any
   1:     // justification space assigned
   1:     return;
   1:   }
   1: 
   1:   gfxFloat naturalWidth =
   1:     mTextRun->GetAdvanceWidth(mStart.GetSkippedOffset(),
   1:                               GetSkippedDistance(mStart, realEnd), this);
 202:   if (mFrame->GetStateBits() & TEXT_HYPHEN_BREAK) {
6862:     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, mFrame));
5724:     if (hyphenTextRun.get()) {
 202:       naturalWidth +=
1328:         hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull);
 202:     }
 202:   }
   1:   gfxFloat totalJustificationSpace = mFrame->GetSize().width - naturalWidth;
   1:   if (totalJustificationSpace <= 0) {
   1:     // No space available
   1:     return;
   1:   }
   1:   
   1:   mJustificationSpacing = totalJustificationSpace/justifiableCharacters;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: // Helper class for managing blinking text
   1: 
   1: class nsBlinkTimer : public nsITimerCallback
   1: {
   1: public:
   1:   nsBlinkTimer();
   1:   virtual ~nsBlinkTimer();
   1: 
   1:   NS_DECL_ISUPPORTS
   1: 
   1:   void AddFrame(nsPresContext* aPresContext, nsIFrame* aFrame);
   1: 
   1:   PRBool RemoveFrame(nsIFrame* aFrame);
   1: 
   1:   PRInt32 FrameCount();
   1: 
   1:   void Start();
   1: 
   1:   void Stop();
   1: 
   1:   NS_DECL_NSITIMERCALLBACK
   1: 
   1:   static nsresult AddBlinkFrame(nsPresContext* aPresContext, nsIFrame* aFrame);
   1:   static nsresult RemoveBlinkFrame(nsIFrame* aFrame);
   1:   
   1:   static PRBool   GetBlinkIsOff() { return sState == 3; }
   1:   
   1: protected:
   1: 
   1:   struct FrameData {
   1:     nsPresContext* mPresContext;  // pres context associated with the frame
   1:     nsIFrame*       mFrame;
   1: 
   1: 
   1:     FrameData(nsPresContext* aPresContext,
   1:               nsIFrame*       aFrame)
   1:       : mPresContext(aPresContext), mFrame(aFrame) {}
   1:   };
   1: 
   1:   nsCOMPtr<nsITimer> mTimer;
   1:   nsVoidArray     mFrames;
   1:   nsPresContext* mPresContext;
   1: 
   1: protected:
   1: 
   1:   static nsBlinkTimer* sTextBlinker;
   1:   static PRUint32      sState; // 0-2 == on; 3 == off
   1:   
   1: };
   1: 
   1: nsBlinkTimer* nsBlinkTimer::sTextBlinker = nsnull;
   1: PRUint32      nsBlinkTimer::sState = 0;
   1: 
   1: #ifdef NOISY_BLINK
   1: static PRTime gLastTick;
   1: #endif
   1: 
   1: nsBlinkTimer::nsBlinkTimer()
   1: {
   1: }
   1: 
   1: nsBlinkTimer::~nsBlinkTimer()
   1: {
   1:   Stop();
   1:   sTextBlinker = nsnull;
   1: }
   1: 
   1: void nsBlinkTimer::Start()
   1: {
   1:   nsresult rv;
   1:   mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
   1:   if (NS_OK == rv) {
   1:     mTimer->InitWithCallback(this, 250, nsITimer::TYPE_REPEATING_PRECISE);
   1:   }
   1: }
   1: 
   1: void nsBlinkTimer::Stop()
   1: {
   1:   if (nsnull != mTimer) {
   1:     mTimer->Cancel();
5854:     mTimer = nsnull;
   1:   }
   1: }
   1: 
   1: NS_IMPL_ISUPPORTS1(nsBlinkTimer, nsITimerCallback)
   1: 
   1: void nsBlinkTimer::AddFrame(nsPresContext* aPresContext, nsIFrame* aFrame) {
   1:   FrameData* frameData = new FrameData(aPresContext, aFrame);
   1:   mFrames.AppendElement(frameData);
   1:   if (1 == mFrames.Count()) {
   1:     Start();
   1:   }
   1: }
   1: 
   1: PRBool nsBlinkTimer::RemoveFrame(nsIFrame* aFrame) {
   1:   PRInt32 i, n = mFrames.Count();
   1:   PRBool rv = PR_FALSE;
   1:   for (i = 0; i < n; i++) {
   1:     FrameData* frameData = (FrameData*) mFrames.ElementAt(i);
   1: 
   1:     if (frameData->mFrame == aFrame) {
   1:       rv = mFrames.RemoveElementAt(i);
   1:       delete frameData;
   1:       break;
   1:     }
   1:   }
   1:   
   1:   if (0 == mFrames.Count()) {
   1:     Stop();
   1:   }
   1:   return rv;
   1: }
   1: 
   1: PRInt32 nsBlinkTimer::FrameCount() {
   1:   return mFrames.Count();
   1: }
   1: 
   1: NS_IMETHODIMP nsBlinkTimer::Notify(nsITimer *timer)
   1: {
   1:   // Toggle blink state bit so that text code knows whether or not to
   1:   // render. All text code shares the same flag so that they all blink
   1:   // in unison.
   1:   sState = (sState + 1) % 4;
   1:   if (sState == 1 || sState == 2)
   1:     // States 0, 1, and 2 are all the same.
   1:     return NS_OK;
   1: 
   1: #ifdef NOISY_BLINK
   1:   PRTime now = PR_Now();
   1:   char buf[50];
   1:   PRTime delta;
   1:   LL_SUB(delta, now, gLastTick);
   1:   gLastTick = now;
   1:   PR_snprintf(buf, sizeof(buf), "%lldusec", delta);
   1:   printf("%s\n", buf);
   1: #endif
   1: 
   1:   PRInt32 i, n = mFrames.Count();
   1:   for (i = 0; i < n; i++) {
   1:     FrameData* frameData = (FrameData*) mFrames.ElementAt(i);
   1: 
   1:     // Determine damaged area and tell view manager to redraw it
   1:     // blink doesn't blink outline ... I hope
   1:     nsRect bounds(nsPoint(0, 0), frameData->mFrame->GetSize());
   1:     frameData->mFrame->Invalidate(bounds, PR_FALSE);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // static
   1: nsresult nsBlinkTimer::AddBlinkFrame(nsPresContext* aPresContext, nsIFrame* aFrame)
   1: {
   1:   if (!sTextBlinker)
   1:   {
   1:     sTextBlinker = new nsBlinkTimer;
   1:     if (!sTextBlinker) return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   
   1:   NS_ADDREF(sTextBlinker);
   1: 
   1:   sTextBlinker->AddFrame(aPresContext, aFrame);
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // static
   1: nsresult nsBlinkTimer::RemoveBlinkFrame(nsIFrame* aFrame)
   1: {
   1:   NS_ASSERTION(sTextBlinker, "Should have blink timer here");
   1:   
   1:   nsBlinkTimer* blinkTimer = sTextBlinker;    // copy so we can call NS_RELEASE on it
   1:   if (!blinkTimer) return NS_OK;
   1:   
   1:   blinkTimer->RemoveFrame(aFrame);  
   1:   NS_RELEASE(blinkTimer);
   1:   
   1:   return NS_OK;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: static nscolor
   1: EnsureDifferentColors(nscolor colorA, nscolor colorB)
   1: {
   1:   if (colorA == colorB) {
   1:     nscolor res;
   1:     res = NS_RGB(NS_GET_R(colorA) ^ 0xff,
   1:                  NS_GET_G(colorA) ^ 0xff,
   1:                  NS_GET_B(colorA) ^ 0xff);
   1:     return res;
   1:   }
   1:   return colorA;
   1: }
   1: 
   1: //-----------------------------------------------------------------------------
   1: 
   1: // TODO delete nsCSSRendering::TransformColor because we're moving it here
   1: static nscolor
   1: DarkenColor(nscolor aColor)
   1: {
   1:   PRUint16  hue,sat,value;
   1: 
   1:   // convert the RBG to HSV so we can get the lightness (which is the v)
   1:   NS_RGB2HSV(aColor,hue,sat,value);
   1: 
   1:   // The goal here is to send white to black while letting colored
   1:   // stuff stay colored... So we adopt the following approach.
   1:   // Something with sat = 0 should end up with value = 0.  Something
   1:   // with a high sat can end up with a high value and it's ok.... At
   1:   // the same time, we don't want to make things lighter.  Do
   1:   // something simple, since it seems to work.
   1:   if (value > sat) {
   1:     value = sat;
   1:     // convert this color back into the RGB color space.
   1:     NS_HSV2RGB(aColor,hue,sat,value);
   1:   }
   1:   return aColor;
   1: }
   1: 
   1: // Check whether we should darken text colors. We need to do this if
   1: // background images and colors are being suppressed, because that means
   1: // light text will not be visible against the (presumed light-colored) background.
   1: static PRBool
   1: ShouldDarkenColors(nsPresContext* aPresContext)
   1: {
   1:   return !aPresContext->GetBackgroundColorDraw() &&
   1:     !aPresContext->GetBackgroundImageDraw();
   1: }
   1: 
   1: nsTextPaintStyle::nsTextPaintStyle(nsTextFrame* aFrame)
   1:   : mFrame(aFrame),
 280:     mPresContext(aFrame->PresContext()),
   1:     mInitCommonColors(PR_FALSE),
   1:     mInitSelectionColors(PR_FALSE)
   1: {
   1:   for (int i = 0; i < 4; i++)
4728:     mIMEStyle[i].mInit = PR_FALSE;
   1:   mIMEUnderlineRelativeSize = -1.0f;
   1: }
   1: 
   1: PRBool
   1: nsTextPaintStyle::EnsureSufficientContrast(nscolor *aForeColor, nscolor *aBackColor)
   1: {
   1:   InitCommonColors();
   1: 
   1:   // If the combination of selection background color and frame background color
   1:   // is sufficient contrast, don't exchange the selection colors.
   1:   PRInt32 backLuminosityDifference =
   1:             NS_LUMINOSITY_DIFFERENCE(*aBackColor, mFrameBackgroundColor);
   1:   if (backLuminosityDifference >= mSufficientContrast)
   1:     return PR_FALSE;
   1: 
   1:   // Otherwise, we should use the higher-contrast color for the selection
   1:   // background color.
   1:   PRInt32 foreLuminosityDifference =
   1:             NS_LUMINOSITY_DIFFERENCE(*aForeColor, mFrameBackgroundColor);
   1:   if (backLuminosityDifference < foreLuminosityDifference) {
   1:     nscolor tmpColor = *aForeColor;
   1:     *aForeColor = *aBackColor;
   1:     *aBackColor = tmpColor;
   1:     return PR_TRUE;
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: nscolor
   1: nsTextPaintStyle::GetTextColor()
   1: {
   1:   nscolor color = mFrame->GetStyleColor()->mColor;
   1:   if (ShouldDarkenColors(mPresContext)) {
   1:     color = DarkenColor(color);
   1:   }
   1:   return color;
   1: }
   1: 
   1: PRBool
   1: nsTextPaintStyle::GetSelectionColors(nscolor* aForeColor,
   1:                                      nscolor* aBackColor)
   1: {
   1:   NS_ASSERTION(aForeColor, "aForeColor is null");
   1:   NS_ASSERTION(aBackColor, "aBackColor is null");
   1: 
   1:   if (!InitSelectionColors())
   1:     return PR_FALSE;
   1: 
   1:   *aForeColor = mSelectionTextColor;
   1:   *aBackColor = mSelectionBGColor;
   1:   return PR_TRUE;
   1: }
   1: 
   1: void
   1: nsTextPaintStyle::GetIMESelectionColors(PRInt32  aIndex,
   1:                                         nscolor* aForeColor,
   1:                                         nscolor* aBackColor)
   1: {
   1:   NS_ASSERTION(aForeColor, "aForeColor is null");
   1:   NS_ASSERTION(aBackColor, "aBackColor is null");
   1:   NS_ASSERTION(aIndex >= 0 && aIndex < 4, "Index out of range");
   1: 
4728:   nsIMEStyle* IMEStyle = GetIMEStyle(aIndex);
4728:   *aForeColor = IMEStyle->mTextColor;
4728:   *aBackColor = IMEStyle->mBGColor;
   1: }
   1: 
   1: PRBool
   1: nsTextPaintStyle::GetIMEUnderline(PRInt32  aIndex,
   1:                                   nscolor* aLineColor,
4728:                                   float*   aRelativeSize,
4728:                                   PRUint8* aStyle)
   1: {
   1:   NS_ASSERTION(aLineColor, "aLineColor is null");
   1:   NS_ASSERTION(aRelativeSize, "aRelativeSize is null");
   1:   NS_ASSERTION(aIndex >= 0 && aIndex < 4, "Index out of range");
   1: 
4728:   nsIMEStyle* IMEStyle = GetIMEStyle(aIndex);
4728:   if (IMEStyle->mUnderlineStyle == NS_STYLE_BORDER_STYLE_NONE ||
4728:       IMEStyle->mUnderlineColor == NS_TRANSPARENT ||
   1:       mIMEUnderlineRelativeSize <= 0.0f)
   1:     return PR_FALSE;
   1: 
4728:   *aLineColor = IMEStyle->mUnderlineColor;
   1:   *aRelativeSize = mIMEUnderlineRelativeSize;
4728:   *aStyle = IMEStyle->mUnderlineStyle;
   1:   return PR_TRUE;
   1: }
   1: 
   1: void
   1: nsTextPaintStyle::InitCommonColors()
   1: {
   1:   if (mInitCommonColors)
   1:     return;
   1: 
   1:   nsStyleContext* sc = mFrame->GetStyleContext();
   1: 
   1:   const nsStyleBackground* bg =
   1:     nsCSSRendering::FindNonTransparentBackground(sc);
   1:   NS_ASSERTION(bg, "Cannot find NonTransparentBackground.");
   1:   mFrameBackgroundColor = bg->mBackgroundColor;
   1: 
   1:   nsILookAndFeel* look = mPresContext->LookAndFeel();
   1:   nscolor defaultWindowBackgroundColor, selectionTextColor, selectionBGColor;
   1:   look->GetColor(nsILookAndFeel::eColor_TextSelectBackground,
   1:                  selectionBGColor);
   1:   look->GetColor(nsILookAndFeel::eColor_TextSelectForeground,
   1:                  selectionTextColor);
   1:   look->GetColor(nsILookAndFeel::eColor_WindowBackground,
   1:                  defaultWindowBackgroundColor);
   1: 
   1:   mSufficientContrast =
   1:     PR_MIN(PR_MIN(NS_SUFFICIENT_LUMINOSITY_DIFFERENCE,
   1:                   NS_LUMINOSITY_DIFFERENCE(selectionTextColor,
   1:                                            selectionBGColor)),
   1:                   NS_LUMINOSITY_DIFFERENCE(defaultWindowBackgroundColor,
   1:                                            selectionBGColor));
   1: 
   1:   mInitCommonColors = PR_TRUE;
   1: }
   1: 
   1: static nsIFrame* GetNonGeneratedAncestor(nsIFrame* f) {
   1:   while (f->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
   1:     f = f->GetParent();
   1:   }
   1:   return f;
   1: }
   1: 
   1: static nsIContent*
   1: FindElementAncestor(nsINode* aNode)
   1: {
   1:   while (aNode && !aNode->IsNodeOfType(nsINode::eELEMENT)) {
   1:     aNode = aNode->GetParent();
   1:   }
3233:   return static_cast<nsIContent*>(aNode);
   1: }
   1: 
   1: PRBool
   1: nsTextPaintStyle::InitSelectionColors()
   1: {
   1:   if (mInitSelectionColors)
   1:     return PR_TRUE;
   1: 
   1:   PRInt16 selectionFlags;
   1:   PRInt16 selectionStatus = mFrame->GetSelectionStatus(&selectionFlags);
   1:   if (!(selectionFlags & nsISelectionDisplay::DISPLAY_TEXT) ||
   1:       selectionStatus < nsISelectionController::SELECTION_ON) {
   1:     // Not displaying the normal selection.
   1:     // We're not caching this fact, so every call to GetSelectionColors
   1:     // will come through here. We could avoid this, but it's not really worth it.
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   mInitSelectionColors = PR_TRUE;
   1: 
   1:   nsIFrame* nonGeneratedAncestor = GetNonGeneratedAncestor(mFrame);
   1:   nsIContent* selectionContent = FindElementAncestor(nonGeneratedAncestor->GetContent());
   1: 
   1:   if (selectionContent &&
   1:       selectionStatus == nsISelectionController::SELECTION_ON) {
   1:     nsRefPtr<nsStyleContext> sc = nsnull;
   1:     sc = mPresContext->StyleSet()->
   1:       ProbePseudoStyleFor(selectionContent, nsCSSPseudoElements::mozSelection,
   1:                           mFrame->GetStyleContext());
   1:     // Use -moz-selection pseudo class.
   1:     if (sc) {
   1:       const nsStyleBackground* bg = sc->GetStyleBackground();
   1:       mSelectionBGColor = bg->mBackgroundColor;
   1:       if (bg->mBackgroundFlags & NS_STYLE_BG_COLOR_TRANSPARENT) {
   1:         mSelectionBGColor = NS_RGBA(0,0,0,0);
   1:       }
   1:       mSelectionTextColor = sc->GetStyleColor()->mColor;
   1:       return PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   nsILookAndFeel* look = mPresContext->LookAndFeel();
   1: 
   1:   nscolor selectionBGColor;
   1:   look->GetColor(nsILookAndFeel::eColor_TextSelectBackground,
   1:                  selectionBGColor);
   1: 
   1:   if (selectionStatus == nsISelectionController::SELECTION_ATTENTION) {
   1:     look->GetColor(nsILookAndFeel::eColor_TextSelectBackgroundAttention,
   1:                    mSelectionBGColor);
   1:     mSelectionBGColor  = EnsureDifferentColors(mSelectionBGColor,
   1:                                                selectionBGColor);
   1:   } else if (selectionStatus != nsISelectionController::SELECTION_ON) {
   1:     look->GetColor(nsILookAndFeel::eColor_TextSelectBackgroundDisabled,
   1:                    mSelectionBGColor);
   1:     mSelectionBGColor  = EnsureDifferentColors(mSelectionBGColor,
   1:                                                selectionBGColor);
   1:   } else {
   1:     mSelectionBGColor = selectionBGColor;
   1:   }
   1: 
   1:   look->GetColor(nsILookAndFeel::eColor_TextSelectForeground,
   1:                  mSelectionTextColor);
   1: 
   1:   // On MacOS X, we don't exchange text color and BG color.
   1:   if (mSelectionTextColor == NS_DONT_CHANGE_COLOR) {
   1:     mSelectionTextColor = EnsureDifferentColors(mFrame->GetStyleColor()->mColor,
   1:                                                 mSelectionBGColor);
   1:   } else {
   1:     EnsureSufficientContrast(&mSelectionTextColor, &mSelectionBGColor);
   1:   }
   1:   return PR_TRUE;
   1: }
   1: 
4728: nsTextPaintStyle::nsIMEStyle*
4728: nsTextPaintStyle::GetIMEStyle(PRInt32 aIndex)
4728: {
4728:   InitIMEStyle(aIndex);
4728:   return &mIMEStyle[aIndex];
4728: }
4728: 
4728: struct StyleIDs {
   1:   nsILookAndFeel::nsColorID mForeground, mBackground, mLine;
4728:   nsILookAndFeel::nsMetricID mLineStyle;
   1: };
4728: static StyleIDs IMEStyleIDs[] = {
   1:   { nsILookAndFeel::eColor_IMERawInputForeground,
   1:     nsILookAndFeel::eColor_IMERawInputBackground,
4728:     nsILookAndFeel::eColor_IMERawInputUnderline,
4728:     nsILookAndFeel::eMetric_IMERawInputUnderlineStyle },
   1:   { nsILookAndFeel::eColor_IMESelectedRawTextForeground,
   1:     nsILookAndFeel::eColor_IMESelectedRawTextBackground,
4728:     nsILookAndFeel::eColor_IMESelectedRawTextUnderline,
4728:     nsILookAndFeel::eMetric_IMESelectedRawTextUnderlineStyle },
   1:   { nsILookAndFeel::eColor_IMEConvertedTextForeground,
   1:     nsILookAndFeel::eColor_IMEConvertedTextBackground,
4728:     nsILookAndFeel::eColor_IMEConvertedTextUnderline,
4728:     nsILookAndFeel::eMetric_IMEConvertedTextUnderlineStyle },
   1:   { nsILookAndFeel::eColor_IMESelectedConvertedTextForeground,
   1:     nsILookAndFeel::eColor_IMESelectedConvertedTextBackground,
4728:     nsILookAndFeel::eColor_IMESelectedConvertedTextUnderline,
4728:     nsILookAndFeel::eMetric_IMESelectedConvertedTextUnderline }
   1: };
   1: 
4728: static PRUint8 sUnderlineStyles[] = {
4728:   NS_STYLE_BORDER_STYLE_NONE,   // NS_UNDERLINE_STYLE_NONE   0
4728:   NS_STYLE_BORDER_STYLE_DOTTED, // NS_UNDERLINE_STYLE_DOTTED 1
4728:   NS_STYLE_BORDER_STYLE_DASHED, // NS_UNDERLINE_STYLE_DASHED 2
4728:   NS_STYLE_BORDER_STYLE_SOLID,  // NS_UNDERLINE_STYLE_SOLID  3
4728:   NS_STYLE_BORDER_STYLE_DOUBLE  // NS_UNDERLINE_STYLE_DOUBLE 4
4728: };
4728: 
   1: void
4728: nsTextPaintStyle::InitIMEStyle(PRInt32 aIndex)
4728: {
4728:   nsIMEStyle* IMEStyle = &mIMEStyle[aIndex];
4728:   if (IMEStyle->mInit)
   1:     return;
   1: 
4728:   StyleIDs* styleIDs = &IMEStyleIDs[aIndex];
   1: 
   1:   nsILookAndFeel* look = mPresContext->LookAndFeel();
   1:   nscolor foreColor, backColor, lineColor;
4728:   PRInt32 lineStyle;
4728:   look->GetColor(styleIDs->mForeground, foreColor);
4728:   look->GetColor(styleIDs->mBackground, backColor);
4728:   look->GetColor(styleIDs->mLine, lineColor);
4728:   look->GetMetric(styleIDs->mLineStyle, lineStyle);
   1: 
   1:   // Convert special color to actual color
   1:   NS_ASSERTION(foreColor != NS_TRANSPARENT,
   1:                "foreColor cannot be NS_TRANSPARENT");
   1:   NS_ASSERTION(backColor != NS_SAME_AS_FOREGROUND_COLOR,
   1:                "backColor cannot be NS_SAME_AS_FOREGROUND_COLOR");
   1:   NS_ASSERTION(backColor != NS_40PERCENT_FOREGROUND_COLOR,
   1:                "backColor cannot be NS_40PERCENT_FOREGROUND_COLOR");
   1: 
   1:   foreColor = GetResolvedForeColor(foreColor, GetTextColor(), backColor);
   1: 
   1:   if (NS_GET_A(backColor) > 0)
   1:     EnsureSufficientContrast(&foreColor, &backColor);
   1: 
   1:   lineColor = GetResolvedForeColor(lineColor, foreColor, backColor);
   1: 
4728:   if (!NS_IS_VALID_UNDERLINE_STYLE(lineStyle))
4728:     lineStyle = NS_UNDERLINE_STYLE_SOLID;
4728: 
4728:   IMEStyle->mTextColor       = foreColor;
4728:   IMEStyle->mBGColor         = backColor;
4728:   IMEStyle->mUnderlineColor  = lineColor;
4728:   IMEStyle->mUnderlineStyle  = sUnderlineStyles[lineStyle];
4728:   IMEStyle->mInit            = PR_TRUE;
   1: 
   1:   if (mIMEUnderlineRelativeSize == -1.0f) {
   1:     look->GetMetric(nsILookAndFeel::eMetricFloat_IMEUnderlineRelativeSize,
   1:                     mIMEUnderlineRelativeSize);
   1:     NS_ASSERTION(mIMEUnderlineRelativeSize >= 0.0f,
   1:                  "underline size must be larger than 0");
   1:   }
   1: }
   1: 
   1: inline nscolor Get40PercentColor(nscolor aForeColor, nscolor aBackColor)
   1: {
   1:   nscolor foreColor = NS_RGBA(NS_GET_R(aForeColor),
   1:                               NS_GET_G(aForeColor),
   1:                               NS_GET_B(aForeColor),
   1:                               (PRUint8)(255 * 0.4f));
4728:   // Don't use true alpha color for readability.
   1:   return NS_ComposeColors(aBackColor, foreColor);
   1: }
   1: 
   1: nscolor
   1: nsTextPaintStyle::GetResolvedForeColor(nscolor aColor,
   1:                                        nscolor aDefaultForeColor,
   1:                                        nscolor aBackColor)
   1: {
   1:   if (aColor == NS_SAME_AS_FOREGROUND_COLOR)
   1:     return aDefaultForeColor;
   1: 
   1:   if (aColor != NS_40PERCENT_FOREGROUND_COLOR)
   1:     return aColor;
   1: 
   1:   // Get actual background color
   1:   nscolor actualBGColor = aBackColor;
   1:   if (actualBGColor == NS_TRANSPARENT) {
   1:     InitCommonColors();
   1:     actualBGColor = mFrameBackgroundColor;
   1:   }
   1:   return Get40PercentColor(aDefaultForeColor, actualBGColor);
   1: }
   1: 
   1: //-----------------------------------------------------------------------------
   1: 
   1: #ifdef ACCESSIBILITY
   1: NS_IMETHODIMP nsTextFrame::GetAccessible(nsIAccessible** aAccessible)
   1: {
9480:   if (IsEmpty()) {
9480:     nsAutoString renderedWhitespace;
9480:     GetRenderedText(&renderedWhitespace, nsnull, nsnull, 0, 1);
9480:     if (renderedWhitespace.IsEmpty()) {
9480:       return NS_ERROR_FAILURE;
9480:     }
9480:   }
   1: 
   1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
   1: 
   1:   if (accService) {
3233:     return accService->CreateHTMLTextAccessible(static_cast<nsIFrame*>(this), aAccessible);
   1:   }
   1:   return NS_ERROR_FAILURE;
   1: }
   1: #endif
   1: 
   1: 
   1: //-----------------------------------------------------------------------------
   1: NS_IMETHODIMP
   1: nsTextFrame::Init(nsIContent*      aContent,
   1:                   nsIFrame*        aParent,
   1:                   nsIFrame*        aPrevInFlow)
   1: {
   1:   NS_ASSERTION(!aPrevInFlow, "Can't be a continuation!");
   8:   NS_PRECONDITION(aContent->IsNodeOfType(nsINode::eTEXT),
   8:                   "Bogus content!");
   1:   // We're not a continuing frame.
   1:   // mContentOffset = 0; not necessary since we get zeroed out at init
4678:   return nsFrame::Init(aContent, aParent, aPrevInFlow);
   1: }
   1: 
   1: void
   1: nsTextFrame::Destroy()
   1: {
5728:   ClearTextRun();
   1:   if (mNextContinuation) {
   1:     mNextContinuation->SetPrevInFlow(nsnull);
   1:   }
   1:   // Let the base class destroy the frame
   1:   nsFrame::Destroy();
   1: }
   1: 
   1: class nsContinuingTextFrame : public nsTextFrame {
   1: public:
   1:   friend nsIFrame* NS_NewContinuingTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1:   NS_IMETHOD Init(nsIContent*      aContent,
   1:                   nsIFrame*        aParent,
   1:                   nsIFrame*        aPrevInFlow);
   1: 
   1:   virtual void Destroy();
   1: 
   1:   virtual nsIFrame* GetPrevContinuation() const {
   1:     return mPrevContinuation;
   1:   }
   1:   NS_IMETHOD SetPrevContinuation(nsIFrame* aPrevContinuation) {
   1:     NS_ASSERTION (!aPrevContinuation || GetType() == aPrevContinuation->GetType(),
   1:                   "setting a prev continuation with incorrect type!");
   1:     NS_ASSERTION (!nsSplittableFrame::IsInPrevContinuationChain(aPrevContinuation, this),
   1:                   "creating a loop in continuation chain!");
   1:     mPrevContinuation = aPrevContinuation;
   1:     RemoveStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
   1:     return NS_OK;
   1:   }
   1:   virtual nsIFrame* GetPrevInFlowVirtual() const { return GetPrevInFlow(); }
   1:   nsIFrame* GetPrevInFlow() const {
   1:     return (GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION) ? mPrevContinuation : nsnull;
   1:   }
   1:   NS_IMETHOD SetPrevInFlow(nsIFrame* aPrevInFlow) {
   1:     NS_ASSERTION (!aPrevInFlow || GetType() == aPrevInFlow->GetType(),
   1:                   "setting a prev in flow with incorrect type!");
   1:     NS_ASSERTION (!nsSplittableFrame::IsInPrevContinuationChain(aPrevInFlow, this),
   1:                   "creating a loop in continuation chain!");
   1:     mPrevContinuation = aPrevInFlow;
   1:     AddStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
   1:     return NS_OK;
   1:   }
   1:   virtual nsIFrame* GetFirstInFlow() const;
   1:   virtual nsIFrame* GetFirstContinuation() const;
   1: 
   1:   virtual void AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
   1:                                  InlineMinWidthData *aData);
   1:   virtual void AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
   1:                                   InlinePrefWidthData *aData);
   1:   
4261:   virtual nsresult GetRenderedText(nsAString* aString = nsnull,
4261:                                    gfxSkipChars* aSkipChars = nsnull,
4261:                                    gfxSkipCharsIterator* aSkipIter = nsnull,
4261:                                    PRUint32 aSkippedStartOffset = 0,
4261:                                    PRUint32 aSkippedMaxLength = PR_UINT32_MAX)
4261:   { return NS_ERROR_NOT_IMPLEMENTED; } // Call on a primary text frame only
4261: 
   1: protected:
   1:   nsContinuingTextFrame(nsStyleContext* aContext) : nsTextFrame(aContext) {}
   1:   nsIFrame* mPrevContinuation;
   1: };
   1: 
   1: NS_IMETHODIMP
   1: nsContinuingTextFrame::Init(nsIContent* aContent,
   1:                             nsIFrame*   aParent,
   1:                             nsIFrame*   aPrevInFlow)
   1: {
   1:   NS_ASSERTION(aPrevInFlow, "Must be a continuation!");
   1:   // NOTE: bypassing nsTextFrame::Init!!!
   1:   nsresult rv = nsFrame::Init(aContent, aParent, aPrevInFlow);
   1: 
4104:   nsIFrame* nextContinuation = aPrevInFlow->GetNextContinuation();
   1:   // Hook the frame into the flow
4104:   SetPrevInFlow(aPrevInFlow);
4104:   aPrevInFlow->SetNextInFlow(this);
3233:   nsTextFrame* prev = static_cast<nsTextFrame*>(aPrevInFlow);
4678:   mContentOffset = prev->GetContentOffset() + prev->GetContentLengthHint();
9001:   NS_ASSERTION(mContentOffset < aContent->GetText()->GetLength(),
9001:                "Creating ContinuingTextFrame, but there is no more content");
4678:   if (prev->GetStyleContext() != GetStyleContext()) {
4678:     // We're taking part of prev's text, and its style may be different
4678:     // so clear its textrun which may no longer be valid (and don't set ours)
4678:     prev->ClearTextRun();
4678:   } else {
   1:     mTextRun = prev->GetTextRun();
4678:   }
   1: #ifdef IBMBIDI
4104:   if (aPrevInFlow->GetStateBits() & NS_FRAME_IS_BIDI) {
9735:     PRInt32 start, end;
9735:     aPrevInFlow->GetOffsets(start, mContentOffset);
9735: 
 280:     nsPropertyTable *propTable = PresContext()->PropertyTable();
   1:     propTable->SetProperty(this, nsGkAtoms::embeddingLevel,
   1:           propTable->GetProperty(aPrevInFlow, nsGkAtoms::embeddingLevel),
   1:                            nsnull, nsnull);
   1:     propTable->SetProperty(this, nsGkAtoms::baseLevel,
   1:               propTable->GetProperty(aPrevInFlow, nsGkAtoms::baseLevel),
   1:                            nsnull, nsnull);
   1:     propTable->SetProperty(this, nsGkAtoms::charType,
   1:                propTable->GetProperty(aPrevInFlow, nsGkAtoms::charType),
   1:                            nsnull, nsnull);
   1:     if (nextContinuation) {
   1:       SetNextContinuation(nextContinuation);
   1:       nextContinuation->SetPrevContinuation(this);
9735:       nextContinuation->GetOffsets(start, end);
   1:     }
   1:     mState |= NS_FRAME_IS_BIDI;
   1:   } // prev frame is bidi
   1: #endif // IBMBIDI
   1: 
   1:   return rv;
   1: }
   1: 
   1: void
   1: nsContinuingTextFrame::Destroy()
   1: {
5728:   ClearTextRun();
   1:   if (mPrevContinuation || mNextContinuation) {
   1:     nsSplittableFrame::RemoveFromFlow(this);
   1:   }
   1:   // Let the base class destroy the frame
   1:   nsFrame::Destroy();
   1: }
   1: 
   1: nsIFrame*
   1: nsContinuingTextFrame::GetFirstInFlow() const
   1: {
   1:   // Can't cast to |nsContinuingTextFrame*| because the first one isn't.
   1:   nsIFrame *firstInFlow,
3233:            *previous = const_cast<nsIFrame*>
3233:                                  (static_cast<const nsIFrame*>(this));
   1:   do {
   1:     firstInFlow = previous;
   1:     previous = firstInFlow->GetPrevInFlow();
   1:   } while (previous);
   1:   return firstInFlow;
   1: }
   1: 
   1: nsIFrame*
   1: nsContinuingTextFrame::GetFirstContinuation() const
   1: {
   1:   // Can't cast to |nsContinuingTextFrame*| because the first one isn't.
   1:   nsIFrame *firstContinuation,
3233:   *previous = const_cast<nsIFrame*>
3233:                         (static_cast<const nsIFrame*>(mPrevContinuation));
   1:   do {
   1:     firstContinuation = previous;
   1:     previous = firstContinuation->GetPrevContinuation();
   1:   } while (previous);
   1:   return firstContinuation;
   1: }
   1: 
   1: // XXX Do we want to do all the work for the first-in-flow or do the
   1: // work for each part?  (Be careful of first-letter / first-line, though,
   1: // especially first-line!)  Doing all the work on the first-in-flow has
   1: // the advantage of avoiding the potential for incremental reflow bugs,
   1: // but depends on our maintining the frame tree in reasonable ways even
   1: // for edge cases (block-within-inline splits, nextBidi, etc.)
   1: 
   1: // XXX We really need to make :first-letter happen during frame
   1: // construction.
   1: 
   1: // Needed for text frames in XUL.
   1: /* virtual */ nscoord
   1: nsTextFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
   1: {
   1:   return nsLayoutUtils::MinWidthFromInline(this, aRenderingContext);
   1: }
   1: 
   1: // Needed for text frames in XUL.
   1: /* virtual */ nscoord
   1: nsTextFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
   1: {
   1:   return nsLayoutUtils::PrefWidthFromInline(this, aRenderingContext);
   1: }
   1: 
   1: /* virtual */ void
   1: nsContinuingTextFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
   1:                                          InlineMinWidthData *aData)
   1: {
   1:   // Do nothing, since the first-in-flow accounts for everything.
   1:   return;
   1: }
   1: 
   1: /* virtual */ void
   1: nsContinuingTextFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
   1:                                           InlinePrefWidthData *aData)
   1: {
   1:   // Do nothing, since the first-in-flow accounts for everything.
   1:   return;
   1: }
   1: 
   1: static void 
   1: DestroySelectionDetails(SelectionDetails* aDetails)
   1: {
   1:   while (aDetails) {
   1:     SelectionDetails* next = aDetails->mNext;
   1:     delete aDetails;
   1:     aDetails = next;
   1:   }
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: #if defined(DEBUG_rbs) || defined(DEBUG_bzbarsky)
   1: static void
   1: VerifyNotDirty(nsFrameState state)
   1: {
   1:   PRBool isZero = state & NS_FRAME_FIRST_REFLOW;
   1:   PRBool isDirty = state & NS_FRAME_IS_DIRTY;
   1:   if (!isZero && isDirty)
   1:     NS_WARNING("internal offsets may be out-of-sync");
   1: }
   1: #define DEBUG_VERIFY_NOT_DIRTY(state) \
   1: VerifyNotDirty(state)
   1: #else
   1: #define DEBUG_VERIFY_NOT_DIRTY(state)
   1: #endif
   1: 
   1: nsIFrame*
   1: NS_NewTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsTextFrame(aContext);
   1: }
   1: 
   1: nsIFrame*
   1: NS_NewContinuingTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsContinuingTextFrame(aContext);
   1: }
   1: 
   1: nsTextFrame::~nsTextFrame()
   1: {
   1:   if (0 != (mState & TEXT_BLINK_ON))
   1:   {
   1:     nsBlinkTimer::RemoveBlinkFrame(this);
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTextFrame::GetCursor(const nsPoint& aPoint,
   1:                        nsIFrame::Cursor& aCursor)
   1: {
   1:   FillCursorInformationFromStyle(GetStyleUserInterface(), aCursor);  
   1:   if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
   1:     aCursor.mCursor = NS_STYLE_CURSOR_TEXT;
   1: 
   1:     // If tabindex >= 0, use default cursor to indicate it's not selectable
   1:     nsIFrame *ancestorFrame = this;
   1:     while ((ancestorFrame = ancestorFrame->GetParent()) != nsnull) {
   1:       nsIContent *ancestorContent = ancestorFrame->GetContent();
   1:       if (ancestorContent && ancestorContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
   1:         nsAutoString tabIndexStr;
   1:         ancestorContent->GetAttr(kNameSpaceID_None, nsGkAtoms::tabindex, tabIndexStr);
   1:         if (!tabIndexStr.IsEmpty()) {
   1:           PRInt32 rv, tabIndexVal = tabIndexStr.ToInteger(&rv);
   1:           if (NS_SUCCEEDED(rv) && tabIndexVal >= 0) {
   1:             aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
   1:             break;
   1:           }
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsIFrame*
   1: nsTextFrame::GetLastInFlow() const
   1: {
3233:   nsTextFrame* lastInFlow = const_cast<nsTextFrame*>(this);
   1:   while (lastInFlow->GetNextInFlow())  {
3233:     lastInFlow = static_cast<nsTextFrame*>(lastInFlow->GetNextInFlow());
   1:   }
   1:   NS_POSTCONDITION(lastInFlow, "illegal state in flow chain.");
   1:   return lastInFlow;
   1: }
   1: nsIFrame*
   1: nsTextFrame::GetLastContinuation() const
   1: {
3233:   nsTextFrame* lastInFlow = const_cast<nsTextFrame*>(this);
   1:   while (lastInFlow->mNextContinuation)  {
3233:     lastInFlow = static_cast<nsTextFrame*>(lastInFlow->mNextContinuation);
   1:   }
   1:   NS_POSTCONDITION(lastInFlow, "illegal state in continuation chain.");
   1:   return lastInFlow;
   1: }
   1: 
   1: void
   1: nsTextFrame::ClearTextRun()
   1: {
   1:   // save textrun because ClearAllTextRunReferences will clear ours
   1:   gfxTextRun* textRun = mTextRun;
   1:   
5728:   if (!textRun)
   1:     return;
   1: 
1328:   UnhookTextRunFromFrames(textRun);
2319:   // see comments in BuildTextRunForFrames...
2319: //  if (textRun->GetFlags() & gfxFontGroup::TEXT_IS_PERSISTENT) {
2319: //    NS_ERROR("Shouldn't reach here for now...");
2319: //    // the textrun's text may be referencing a DOM node that has changed,
2319: //    // so we'd better kill this textrun now.
2319: //    if (textRun->GetExpirationState()->IsTracked()) {
2319: //      gTextRuns->RemoveFromCache(textRun);
2319: //    }
2319: //    delete textRun;
2319: //    return;
2319: //  }
2319: 
3118:   if (!(textRun->GetFlags() & gfxTextRunWordCache::TEXT_IN_CACHE)) {
2319:     // Remove it now because it's not doing anything useful
1328:     gTextRuns->RemoveFromCache(textRun);
1328:     delete textRun;
1328:   }
   1: }
   1: 
3009: static void
3009: ClearTextRunsInFlowChain(nsTextFrame* aFrame)
3009: {
3009:   nsTextFrame* f;
3233:   for (f = aFrame; f; f = static_cast<nsTextFrame*>(f->GetNextInFlow())) {
3009:     f->ClearTextRun();
3009:   }
3009: }
3009: 
   1: NS_IMETHODIMP
   1: nsTextFrame::CharacterDataChanged(nsPresContext* aPresContext,
   1:                                   nsIContent*     aChild,
   1:                                   PRBool          aAppend)
   1: {
3009:   ClearTextRunsInFlowChain(this);
   1: 
   1:   nsTextFrame* targetTextFrame;
   1:   PRInt32 nodeLength = mContent->GetText()->GetLength();
   1: 
   1:   if (aAppend) {
4678:     targetTextFrame = static_cast<nsTextFrame*>(GetLastContinuation());
4678:     targetTextFrame->mState &= ~TEXT_WHITESPACE_FLAGS;
   1:   } else {
4678:     // Mark all the continuation frames as dirty, and fix up content offsets to
1158:     // be valid.
1158:     // Don't set NS_FRAME_IS_DIRTY on |this|, since we call FrameNeedsReflow
1158:     // below.
   1:     nsTextFrame* textFrame = this;
   1:     PRInt32 newLength = nodeLength;
   1:     do {
   1:       textFrame->mState &= ~TEXT_WHITESPACE_FLAGS;
   1:       // If the text node has shrunk, clip the frame contentlength as necessary
2319:       if (textFrame->mContentOffset > newLength) {
2319:         textFrame->mContentOffset = newLength;
2319:       }
3233:       textFrame = static_cast<nsTextFrame*>(textFrame->GetNextContinuation());
1158:       if (!textFrame) {
1158:         break;
1158:       }
1158:       textFrame->mState |= NS_FRAME_IS_DIRTY;
1158:     } while (1);
   1:     targetTextFrame = this;
   1:   }
   1: 
   1:   // Ask the parent frame to reflow me.
   1:   aPresContext->GetPresShell()->FrameNeedsReflow(targetTextFrame,
1158:                                                  nsIPresShell::eStyleChange,
1158:                                                  NS_FRAME_IS_DIRTY);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTextFrame::DidSetStyleContext()
   1: {
   1:   ClearTextRun();
   1:   return NS_OK;
   1: } 
   1: 
   1: class nsDisplayText : public nsDisplayItem {
   1: public:
   1:   nsDisplayText(nsTextFrame* aFrame) : nsDisplayItem(aFrame) {
   1:     MOZ_COUNT_CTOR(nsDisplayText);
   1:   }
   1: #ifdef NS_BUILD_REFCNT_LOGGING
   1:   virtual ~nsDisplayText() {
   1:     MOZ_COUNT_DTOR(nsDisplayText);
   1:   }
   1: #endif
   1: 
   1:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
   1:     return mFrame->GetOverflowRect() + aBuilder->ToReferenceFrame(mFrame);
   1:   }
6247:   virtual nsIFrame* HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt) {
6247:     return nsRect(aBuilder->ToReferenceFrame(mFrame), mFrame->GetSize()).Contains(aPt) ? mFrame : nsnull;
6247:   }
   1:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
   1:      const nsRect& aDirtyRect);
   1:   NS_DISPLAY_DECL_NAME("Text")
   1: };
   1: 
   1: void
   1: nsDisplayText::Paint(nsDisplayListBuilder* aBuilder,
   1:      nsIRenderingContext* aCtx, const nsRect& aDirtyRect) {
3233:   static_cast<nsTextFrame*>(mFrame)->
   1:     PaintText(aCtx, aBuilder->ToReferenceFrame(mFrame), aDirtyRect);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTextFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                               const nsRect&           aDirtyRect,
   1:                               const nsDisplayListSet& aLists)
   1: {
   1:   if (!IsVisibleForPainting(aBuilder))
   1:     return NS_OK;
   1:   
   1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsTextFrame");
   1: 
   1:   if ((0 != (mState & TEXT_BLINK_ON)) && nsBlinkTimer::GetBlinkIsOff())
   1:     return NS_OK;
   1:     
   1:   return aLists.Content()->AppendNewToTop(new (aBuilder) nsDisplayText(this));
   1: }
   1: 
   8: static nsIFrame*
   8: GetGeneratedContentOwner(nsIFrame* aFrame, PRBool* aIsBefore)
   1: {
   8:   *aIsBefore = PR_FALSE;
   8:   while (aFrame && (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT)) {
   8:     if (aFrame->GetStyleContext()->GetPseudoType() == nsCSSPseudoElements::before) {
   8:       *aIsBefore = PR_TRUE;
   8:     }
   8:     aFrame = aFrame->GetParent();
   8:   }
   8:   return aFrame;
   1: }
   1: 
   1: SelectionDetails*
   1: nsTextFrame::GetSelectionDetails()
   1: {
8295:   const nsFrameSelection* frameSelection = GetConstFrameSelection();
   8:   if (!(GetStateBits() & NS_FRAME_GENERATED_CONTENT)) {
   8:     SelectionDetails* details =
8295:       frameSelection->LookUpSelection(mContent, GetContentOffset(),
4678:                                       GetContentLength(), PR_FALSE);
   8:     SelectionDetails* sd;
   8:     for (sd = details; sd; sd = sd->mNext) {
   8:       sd->mStart += mContentOffset;
   8:       sd->mEnd += mContentOffset;
   8:     }
   8:     return details;
   8:   }
   8: 
   8:   // Check if the beginning or end of the element is selected, depending on
   8:   // whether we're :before content or :after content.
   8:   PRBool isBefore;
   8:   nsIFrame* owner = GetGeneratedContentOwner(this, &isBefore);
   8:   if (!owner || !owner->GetContent())
   8:     return nsnull;
   8: 
   8:   SelectionDetails* details =
8295:     frameSelection->LookUpSelection(owner->GetContent(),
   8:         isBefore ? 0 : owner->GetContent()->GetChildCount(), 0, PR_FALSE);
   8:   SelectionDetails* sd;
   8:   for (sd = details; sd; sd = sd->mNext) {
   8:     // The entire text is selected!
3118:     sd->mStart = GetContentOffset();
3118:     sd->mEnd = GetContentEnd();
   8:   }
   8:   return details;
   1: }
   1: 
   1: static void
   1: FillClippedRect(gfxContext* aCtx, nsPresContext* aPresContext,
   1:                 nscolor aColor, const gfxRect& aDirtyRect, const gfxRect& aRect)
   1: {
   1:   gfxRect r = aRect.Intersect(aDirtyRect);
   1:   // For now, we need to put this in pixel coordinates
5147:   PRInt32 app = aPresContext->AppUnitsPerDevPixel();
   1:   aCtx->NewPath();
   1:   // pixel-snap
5147:   aCtx->Rectangle(gfxRect(r.X() / app, r.Y() / app,
5147:                           r.Width() / app, r.Height() / app), PR_TRUE);
   1:   aCtx->SetColor(gfxRGBA(aColor));
   1:   aCtx->Fill();
   1: }
   1: 
8698: void 
8698: nsTextFrame::PaintTextDecorations(gfxContext* aCtx, const gfxRect& aDirtyRect,
8698:                                   const gfxPoint& aFramePt,
8698:                                   const gfxPoint& aTextBaselinePt,
8698:                                   nsTextPaintStyle& aTextPaintStyle,
8698:                                   PropertyProvider& aProvider)
8698: {
   1:   // Quirks mode text decoration are rendered by children; see bug 1777
   1:   // In non-quirks mode, nsHTMLContainer::Paint and nsBlockFrame::Paint
   1:   // does the painting of text decorations.
8698:   if (eCompatibility_NavQuirks != aTextPaintStyle.PresContext()->CompatibilityMode())
8698:     return;
   1: 
   1:   PRBool useOverride = PR_FALSE;
   1:   nscolor overrideColor;
   1: 
8698:   PRUint8 decorations = NS_STYLE_TEXT_DECORATION_NONE;
   1:   // A mask of all possible decorations.
   1:   PRUint8 decorMask = NS_STYLE_TEXT_DECORATION_UNDERLINE | 
   1:                       NS_STYLE_TEXT_DECORATION_OVERLINE |
   1:                       NS_STYLE_TEXT_DECORATION_LINE_THROUGH;    
8698:   nscolor overColor, underColor, strikeColor;
8698:   nsStyleContext* context = GetStyleContext();
8698:   PRBool hasDecorations = context->HasTextDecorations();
8698: 
8698:   while (hasDecorations) {
   1:     const nsStyleTextReset* styleText = context->GetStyleTextReset();
   1:     if (!useOverride && 
   1:         (NS_STYLE_TEXT_DECORATION_OVERRIDE_ALL & styleText->mTextDecoration)) {
   1:       // This handles the <a href="blah.html"><font color="green">La 
   1:       // la la</font></a> case. The link underline should be green.
   1:       useOverride = PR_TRUE;
   1:       overrideColor = context->GetStyleColor()->mColor;          
   1:     }
   1: 
   1:     PRUint8 useDecorations = decorMask & styleText->mTextDecoration;
   1:     if (useDecorations) {// a decoration defined here
   1:       nscolor color = context->GetStyleColor()->mColor;
   1:   
   1:       if (NS_STYLE_TEXT_DECORATION_UNDERLINE & useDecorations) {
8698:         underColor = useOverride ? overrideColor : color;
   1:         decorMask &= ~NS_STYLE_TEXT_DECORATION_UNDERLINE;
8698:         decorations |= NS_STYLE_TEXT_DECORATION_UNDERLINE;
   1:       }
   1:       if (NS_STYLE_TEXT_DECORATION_OVERLINE & useDecorations) {
8698:         overColor = useOverride ? overrideColor : color;
   1:         decorMask &= ~NS_STYLE_TEXT_DECORATION_OVERLINE;
8698:         decorations |= NS_STYLE_TEXT_DECORATION_OVERLINE;
   1:       }
   1:       if (NS_STYLE_TEXT_DECORATION_LINE_THROUGH & useDecorations) {
8698:         strikeColor = useOverride ? overrideColor : color;
   1:         decorMask &= ~NS_STYLE_TEXT_DECORATION_LINE_THROUGH;
8698:         decorations |= NS_STYLE_TEXT_DECORATION_LINE_THROUGH;
8698:       }
8698:     }
8698:     if (0 == decorMask)
8698:       break;
8698:     context = context->GetParent();
8698:     if (!context)
8698:       break;
8698:     hasDecorations = context->HasTextDecorations();
8698:   }
8698: 
8698:   if (!decorations)
   1:     return;
   1: 
   1:   gfxFont::Metrics fontMetrics = GetFontMetrics(aProvider.GetFontGroup());
6027:   gfxFloat app = aTextPaintStyle.PresContext()->AppUnitsPerDevPixel();
4302: 
4302:   // XXX aFramePt is in AppUnits, shouldn't it be nsFloatPoint?
5601:   gfxPoint pt(aFramePt.x / app, (aTextBaselinePt.y - mAscent) / app);
6121:   gfxSize size(GetRect().width / app, 0);
6027:   gfxFloat ascent = gfxFloat(mAscent) / app;
   1: 
8698:   if (decorations & NS_FONT_DECORATION_OVERLINE) {
4302:     size.height = fontMetrics.underlineSize;
4302:     nsCSSRendering::PaintDecorationLine(
8698:       aCtx, overColor, pt, size, ascent, ascent, size.height,
4302:       NS_STYLE_TEXT_DECORATION_OVERLINE, NS_STYLE_BORDER_STYLE_SOLID,
4302:       mTextRun->IsRightToLeft());
   1:   }
8698:   if (decorations & NS_FONT_DECORATION_UNDERLINE) {
4302:     size.height = fontMetrics.underlineSize;
4302:     gfxFloat offset = fontMetrics.underlineOffset;
4302:     nsCSSRendering::PaintDecorationLine(
8698:       aCtx, underColor, pt, size, ascent, offset, size.height,
4302:       NS_STYLE_TEXT_DECORATION_UNDERLINE, NS_STYLE_BORDER_STYLE_SOLID,
4302:       mTextRun->IsRightToLeft());
   1:   }
8698:   if (decorations & NS_FONT_DECORATION_LINE_THROUGH) {
4302:     size.height = fontMetrics.strikeoutSize;
4302:     gfxFloat offset = fontMetrics.strikeoutOffset;
4302:     nsCSSRendering::PaintDecorationLine(
8698:       aCtx, strikeColor, pt, size, ascent, offset, size.height,
4302:       NS_STYLE_TEXT_DECORATION_UNDERLINE, NS_STYLE_BORDER_STYLE_SOLID,
4302:       mTextRun->IsRightToLeft());
   1:   }
   1: }
   1: 
   1: // Make sure this stays in sync with DrawSelectionDecorations below
   1: static const SelectionType SelectionTypesWithDecorations =
   1:   nsISelectionController::SELECTION_SPELLCHECK |
   1:   nsISelectionController::SELECTION_IME_RAWINPUT |
   1:   nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT |
   1:   nsISelectionController::SELECTION_IME_CONVERTEDTEXT |
   1:   nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT;
   1: 
   1: static void DrawIMEUnderline(gfxContext* aContext, PRInt32 aIndex,
4302:     nsTextPaintStyle& aTextPaintStyle, const gfxPoint& aPt, gfxFloat aWidth,
4302:     gfxFloat aAscent, gfxFloat aSize, gfxFloat aOffset, PRBool aIsRTL)
4302: {
   1:   nscolor color;
   1:   float relativeSize;
4728:   PRUint8 style;
4728:   if (!aTextPaintStyle.GetIMEUnderline(aIndex, &color, &relativeSize, &style))
   1:     return;
   1: 
4302:   gfxFloat actualSize = relativeSize * aSize;
4302:   gfxFloat width = PR_MAX(0, aWidth - 2.0 * aSize);
4302:   gfxPoint pt(aPt.x + 1.0, aPt.y);
4302:   nsCSSRendering::PaintDecorationLine(
8698:     aContext, color, pt, gfxSize(width, actualSize), aAscent, aOffset, aSize,
4728:     NS_STYLE_TEXT_DECORATION_UNDERLINE, style, aIsRTL);
   1: }
   1: 
   1: /**
   1:  * This, plus SelectionTypesWithDecorations, encapsulates all knowledge about
   1:  * drawing text decoration for selections.
   1:  */
   1: static void DrawSelectionDecorations(gfxContext* aContext, SelectionType aType,
4302:     nsTextPaintStyle& aTextPaintStyle, const gfxPoint& aPt, gfxFloat aWidth,
4302:     gfxFloat aAscent, const gfxFont::Metrics& aFontMetrics, PRBool aIsRTL)
4302: {
4302:   gfxSize size(aWidth, aFontMetrics.underlineSize);
   1: 
   1:   switch (aType) {
   1:     case nsISelectionController::SELECTION_SPELLCHECK: {
4302:       nsCSSRendering::PaintDecorationLine(
4302:         aContext, NS_RGB(255,0,0),
8698:         aPt, size, aAscent, aFontMetrics.underlineOffset, size.height,
4302:         NS_STYLE_TEXT_DECORATION_UNDERLINE, NS_STYLE_BORDER_STYLE_DOTTED,
4302:         aIsRTL);
   1:       break;
   1:     }
   1: 
   1:     case nsISelectionController::SELECTION_IME_RAWINPUT:
4302:       DrawIMEUnderline(aContext, nsTextPaintStyle::eIndexRawInput,
4302:                        aTextPaintStyle, aPt, aWidth, aAscent, size.height,
4302:                        aFontMetrics.underlineOffset, aIsRTL);
   1:       break;
   1:     case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
4302:       DrawIMEUnderline(aContext, nsTextPaintStyle::eIndexSelRawText,
4302:                        aTextPaintStyle, aPt, aWidth, aAscent, size.height,
4302:                        aFontMetrics.underlineOffset, aIsRTL);
   1:       break;
   1:     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
4302:       DrawIMEUnderline(aContext, nsTextPaintStyle::eIndexConvText,
4302:                        aTextPaintStyle, aPt, aWidth, aAscent, size.height,
4302:                        aFontMetrics.underlineOffset, aIsRTL);
   1:       break;
   1:     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT:
4302:       DrawIMEUnderline(aContext, nsTextPaintStyle::eIndexSelConvText,
4302:                        aTextPaintStyle, aPt, aWidth, aAscent, size.height,
4302:                        aFontMetrics.underlineOffset, aIsRTL);
   1:       break;
   1: 
   1:     default:
   1:       NS_WARNING("Requested selection decorations when there aren't any");
   1:       break;
   1:   }
   1: }
   1: 
   1: /**
   1:  * This function encapsulates all knowledge of how selections affect foreground
   1:  * and background colors.
   1:  * @return true if the selection affects colors, false otherwise
   1:  * @param aForeground the foreground color to use
   1:  * @param aBackground the background color to use, or RGBA(0,0,0,0) if no
   1:  * background should be painted
   1:  */
   1: static PRBool GetSelectionTextColors(SelectionType aType, nsTextPaintStyle& aTextPaintStyle,
   1:                                      nscolor* aForeground, nscolor* aBackground)
   1: {
   1:   switch (aType) {
   1:     case nsISelectionController::SELECTION_NORMAL:
   1:       return aTextPaintStyle.GetSelectionColors(aForeground, aBackground);
   1: 
   1:     case nsISelectionController::SELECTION_IME_RAWINPUT:
   1:       aTextPaintStyle.GetIMESelectionColors(nsTextPaintStyle::eIndexRawInput,
   1:                                             aForeground, aBackground);
   1:       return PR_TRUE;
   1:     case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
   1:       aTextPaintStyle.GetIMESelectionColors(nsTextPaintStyle::eIndexSelRawText,
   1:                                             aForeground, aBackground);
   1:       return PR_TRUE;
   1:     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
   1:       aTextPaintStyle.GetIMESelectionColors(nsTextPaintStyle::eIndexConvText,
   1:                                             aForeground, aBackground);
   1:       return PR_TRUE;
   1:     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT:
   1:       aTextPaintStyle.GetIMESelectionColors(nsTextPaintStyle::eIndexSelConvText,
   1:                                             aForeground, aBackground);
   1:       return PR_TRUE;
   1:       
   1:     default:
   1:       *aForeground = aTextPaintStyle.GetTextColor();
   1:       *aBackground = NS_RGBA(0,0,0,0);
   1:       return PR_FALSE;
   1:   }
   1: }
   1: 
   1: /**
   1:  * This class lets us iterate over chunks of text in a uniform selection state,
   1:  * observing cluster boundaries, in content order, maintaining the current
   1:  * x-offset as we go, and telling whether the text chunk has a hyphen after
   1:  * it or not. The caller is responsible for actually computing the advance
   1:  * width of each chunk.
   1:  */
   1: class SelectionIterator {
   1: public:
   1:   /**
   1:    * aStart and aLength are in the original string. aSelectionBuffer is
   1:    * according to the original string.
   1:    */
   1:   SelectionIterator(SelectionType* aSelectionBuffer, PRInt32 aStart,
   1:                     PRInt32 aLength, PropertyProvider& aProvider,
   1:                     gfxTextRun* aTextRun);
   1:   
   1:   /**
   1:    * Returns the next segment of uniformly selected (or not) text.
   1:    * @param aXOffset the offset from the origin of the frame to the start
   1:    * of the text (the left baseline origin for LTR, the right baseline origin
   1:    * for RTL)
   1:    * @param aOffset the transformed string offset of the text for this segment
   1:    * @param aLength the transformed string length of the text for this segment
   1:    * @param aHyphenWidth if a hyphen is to be rendered after the text, the
   1:    * width of the hyphen, otherwise zero
   1:    * @param aType the selection type for this segment
   1:    * @return false if there are no more segments
   1:    */
   1:   PRBool GetNextSegment(gfxFloat* aXOffset, PRUint32* aOffset, PRUint32* aLength,
   1:                         gfxFloat* aHyphenWidth, SelectionType* aType);
   1:   void UpdateWithAdvance(gfxFloat aAdvance) {
   1:     mXOffset += aAdvance*mTextRun->GetDirection();
   1:   }
   1: 
   1: private:
   1:   SelectionType*          mSelectionBuffer;
   1:   PropertyProvider&       mProvider;
   1:   gfxTextRun*             mTextRun;
   1:   gfxSkipCharsIterator    mIterator;
   1:   PRInt32                 mOriginalStart;
   1:   PRInt32                 mOriginalEnd;
   1:   gfxFloat                mXOffset;
   1: };
   1: 
   1: SelectionIterator::SelectionIterator(SelectionType* aSelectionBuffer,
   1:     PRInt32 aStart, PRInt32 aLength, PropertyProvider& aProvider,
   1:     gfxTextRun* aTextRun)
   1:   : mSelectionBuffer(aSelectionBuffer), mProvider(aProvider),
   1:     mTextRun(aTextRun), mIterator(aProvider.GetStart()),
   1:     mOriginalStart(aStart), mOriginalEnd(aStart + aLength),
   1:     mXOffset(mTextRun->IsRightToLeft() ? aProvider.GetFrame()->GetSize().width : 0)
   1: {
   1:   mIterator.SetOriginalOffset(aStart);
   1: }
   1: 
   1: PRBool SelectionIterator::GetNextSegment(gfxFloat* aXOffset,
   1:     PRUint32* aOffset, PRUint32* aLength, gfxFloat* aHyphenWidth, SelectionType* aType)
   1: {
   1:   if (mIterator.GetOriginalOffset() >= mOriginalEnd)
   1:     return PR_FALSE;
   1:   
   1:   // save offset into transformed string now
   1:   PRUint32 runOffset = mIterator.GetSkippedOffset();
   1:   
   1:   PRInt32 index = mIterator.GetOriginalOffset() - mOriginalStart;
   1:   SelectionType type = mSelectionBuffer[index];
1380:   for (++index; mOriginalStart + index < mOriginalEnd; ++index) {
   1:     if (mSelectionBuffer[index] != type)
   1:       break;
1380:   }
   1:   mIterator.SetOriginalOffset(index + mOriginalStart);
   1:   
   1:   // Advance to the next cluster boundary
   1:   while (mIterator.GetOriginalOffset() < mOriginalEnd &&
   1:          !mIterator.IsOriginalCharSkipped() &&
   8:          !mTextRun->IsClusterStart(mIterator.GetSkippedOffset())) {
   1:     mIterator.AdvanceOriginal(1);
   1:   }
   1: 
 202:   PRBool haveHyphenBreak =
 202:     (mProvider.GetFrame()->GetStateBits() & TEXT_HYPHEN_BREAK) != 0;
   1:   *aOffset = runOffset;
   1:   *aLength = mIterator.GetSkippedOffset() - runOffset;
   1:   *aXOffset = mXOffset;
   1:   *aHyphenWidth = 0;
 202:   if (mIterator.GetOriginalOffset() == mOriginalEnd && haveHyphenBreak) {
   1:     *aHyphenWidth = mProvider.GetHyphenWidth();
   1:   }
   1:   *aType = type;
   1:   return PR_TRUE;
   1: }
   1: 
   1: // Paints selection backgrounds and text in the correct colors. Also computes
   1: // aAllTypes, the union of all selection types that are applying to this text.
   1: void
   1: nsTextFrame::PaintTextWithSelectionColors(gfxContext* aCtx,
   1:     const gfxPoint& aFramePt,
   1:     const gfxPoint& aTextBaselinePt, const gfxRect& aDirtyRect,
   1:     PropertyProvider& aProvider, nsTextPaintStyle& aTextPaintStyle,
   1:     SelectionDetails* aDetails, SelectionType* aAllTypes)
   1: {
   1:   PRInt32 contentOffset = aProvider.GetStart().GetOriginalOffset();
   1:   PRInt32 contentLength = aProvider.GetOriginalLength();
   1: 
   1:   // Figure out which selections control the colors to use for each character.
   1:   nsAutoTArray<SelectionType,BIG_TEXT_NODE_SIZE> prevailingSelectionsBuffer;
   1:   if (!prevailingSelectionsBuffer.AppendElements(contentLength))
   1:     return;
   1:   SelectionType* prevailingSelections = prevailingSelectionsBuffer.Elements();
   1:   PRInt32 i;
   1:   SelectionType allTypes = 0;
   1:   for (i = 0; i < contentLength; ++i) {
   1:     prevailingSelections[i] = nsISelectionController::SELECTION_NONE;
   1:   }
   1: 
   1:   SelectionDetails *sdptr = aDetails;
   1:   PRBool anyBackgrounds = PR_FALSE;
   1:   while (sdptr) {
   1:     PRInt32 start = PR_MAX(0, sdptr->mStart - contentOffset);
   1:     PRInt32 end = PR_MIN(contentLength, sdptr->mEnd - contentOffset);
   1:     SelectionType type = sdptr->mType;
   1:     if (start < end) {
   1:       allTypes |= type;
   1:       // Ignore selections that don't set colors
   1:       nscolor foreground, background;
   1:       if (GetSelectionTextColors(type, aTextPaintStyle, &foreground, &background)) {
   1:         if (NS_GET_A(background) > 0) {
   1:           anyBackgrounds = PR_TRUE;
   1:         }
   1:         for (i = start; i < end; ++i) {
   1:           PRInt16 currentPrevailingSelection = prevailingSelections[i];
   1:           // Favour normal selection over IME selections
   1:           if (currentPrevailingSelection == nsISelectionController::SELECTION_NONE ||
   1:               type < currentPrevailingSelection) {
   1:             prevailingSelections[i] = type;
   1:           }
   1:         }
   1:       }
   1:     }
   1:     sdptr = sdptr->mNext;
   1:   }
   1:   *aAllTypes = allTypes;
   1: 
   1:   gfxFloat xOffset, hyphenWidth;
   1:   PRUint32 offset, length; // in transformed string
   1:   SelectionType type;
   1:   // Draw background colors
   1:   if (anyBackgrounds) {
   1:     SelectionIterator iterator(prevailingSelections, contentOffset, contentLength,
   1:                                aProvider, mTextRun);
   1:     while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth, &type)) {
   1:       nscolor foreground, background;
   1:       GetSelectionTextColors(type, aTextPaintStyle, &foreground, &background);
   1:       // Draw background color
   1:       gfxFloat advance = hyphenWidth +
   1:         mTextRun->GetAdvanceWidth(offset, length, &aProvider);
   1:       if (NS_GET_A(background) > 0) {
   1:         gfxFloat x = xOffset - (mTextRun->IsRightToLeft() ? advance : 0);
 280:         FillClippedRect(aCtx, aTextPaintStyle.PresContext(),
   1:                         background, aDirtyRect,
   1:                         gfxRect(aFramePt.x + x, aFramePt.y, advance, GetSize().height));
   1:       }
   1:       iterator.UpdateWithAdvance(advance);
   1:     }
   1:   }
   1:   
   1:   // Draw text
   1:   SelectionIterator iterator(prevailingSelections, contentOffset, contentLength,
   1:                              aProvider, mTextRun);
   1:   while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth, &type)) {
   1:     nscolor foreground, background;
   1:     GetSelectionTextColors(type, aTextPaintStyle, &foreground, &background);
   1:     // Draw text segment
   1:     aCtx->SetColor(gfxRGBA(foreground));
   1:     gfxFloat advance;
   1:     mTextRun->Draw(aCtx, gfxPoint(aFramePt.x + xOffset, aTextBaselinePt.y), offset, length,
   1:                    &aDirtyRect, &aProvider, &advance);
   1:     if (hyphenWidth) {
   1:       // Draw the hyphen
   1:       gfxFloat hyphenBaselineX = aFramePt.x + xOffset + mTextRun->GetDirection()*advance;
1328:       // Get a reference rendering context because aCtx might not have the
1328:       // reference matrix currently set
6862:       gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, this));
5724:       if (hyphenTextRun.get()) {
   1:         hyphenTextRun->Draw(aCtx, gfxPoint(hyphenBaselineX, aTextBaselinePt.y),
   1:                             0, hyphenTextRun->GetLength(), &aDirtyRect, nsnull, nsnull);
   1:       }
   1:       advance += hyphenWidth;
   1:     }
   1:     iterator.UpdateWithAdvance(advance);
   1:   }
   1: }
   1: 
   1: void
   1: nsTextFrame::PaintTextSelectionDecorations(gfxContext* aCtx,
   1:     const gfxPoint& aFramePt,
   1:     const gfxPoint& aTextBaselinePt, const gfxRect& aDirtyRect,
   1:     PropertyProvider& aProvider, nsTextPaintStyle& aTextPaintStyle,
   1:     SelectionDetails* aDetails, SelectionType aSelectionType)
   1: {
   1:   PRInt32 contentOffset = aProvider.GetStart().GetOriginalOffset();
   1:   PRInt32 contentLength = aProvider.GetOriginalLength();
   1: 
   1:   // Figure out which characters will be decorated for this selection. Here
   1:   // we just fill the buffer with either SELECTION_NONE or aSelectionType.
   1:   nsAutoTArray<SelectionType,BIG_TEXT_NODE_SIZE> selectedCharsBuffer;
   1:   if (!selectedCharsBuffer.AppendElements(contentLength))
   1:     return;
   1:   SelectionType* selectedChars = selectedCharsBuffer.Elements();
   1:   PRInt32 i;
   1:   for (i = 0; i < contentLength; ++i) {
   1:     selectedChars[i] = nsISelectionController::SELECTION_NONE;
   1:   }
   1: 
   1:   SelectionDetails *sdptr = aDetails;
   1:   while (sdptr) {
   1:     if (sdptr->mType == aSelectionType) {
   1:       PRInt32 start = PR_MAX(0, sdptr->mStart - contentOffset);
   1:       PRInt32 end = PR_MIN(contentLength, sdptr->mEnd - contentOffset);
   1:       for (i = start; i < end; ++i) {
   1:         selectedChars[i] = aSelectionType;
   1:       }
   1:     }
   1:     sdptr = sdptr->mNext;
   1:   }
   1: 
   1:   gfxFont::Metrics decorationMetrics = GetFontMetrics(aProvider.GetFontGroup());
   1: 
   1:   SelectionIterator iterator(selectedChars, contentOffset, contentLength,
   1:                              aProvider, mTextRun);
   1:   gfxFloat xOffset, hyphenWidth;
   1:   PRUint32 offset, length;
5601:   PRInt32 app = aTextPaintStyle.PresContext()->AppUnitsPerDevPixel();
5601:   // XXX aTextBaselinePt is in AppUnits, shouldn't it be nsFloatPoint?
5601:   gfxPoint pt(0.0, (aTextBaselinePt.y - mAscent) / app);
   1:   SelectionType type;
   1:   while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth, &type)) {
   1:     gfxFloat advance = hyphenWidth +
   1:       mTextRun->GetAdvanceWidth(offset, length, &aProvider);
   1:     if (type == aSelectionType) {
5601:       pt.x = (aTextBaselinePt.x + xOffset) / app;
5147:       gfxFloat width = PR_ABS(advance) / app;
   1:       DrawSelectionDecorations(aCtx, aSelectionType, aTextPaintStyle,
5147:                                pt, width, mAscent / app, decorationMetrics,
4302:                                mTextRun->IsRightToLeft());
   1:     }
   1:     iterator.UpdateWithAdvance(advance);
   1:   }
   1: }
   1: 
   1: PRBool
   1: nsTextFrame::PaintTextWithSelection(gfxContext* aCtx,
   1:     const gfxPoint& aFramePt,
   1:     const gfxPoint& aTextBaselinePt, const gfxRect& aDirtyRect,
   1:     PropertyProvider& aProvider, nsTextPaintStyle& aTextPaintStyle)
   1: {
   1:   SelectionDetails* details = GetSelectionDetails();
   1:   if (!details)
   1:     return PR_FALSE;
   1: 
   1:   SelectionType allTypes;
   1:   PaintTextWithSelectionColors(aCtx, aFramePt, aTextBaselinePt, aDirtyRect,
   1:                                aProvider, aTextPaintStyle, details, &allTypes);
5601:   PaintTextDecorations(aCtx, aDirtyRect, aFramePt, aTextBaselinePt,
5601:                        aTextPaintStyle, aProvider);
   1:   PRInt32 i;
   1:   // Iterate through just the selection types that paint decorations and
   1:   // paint decorations for any that actually occur in this frame. Paint
   1:   // higher-numbered selection types below lower-numered ones on the
   1:   // general principal that lower-numbered selections are higher priority.
   1:   allTypes &= SelectionTypesWithDecorations;
   1:   for (i = nsISelectionController::NUM_SELECTIONTYPES - 1; i >= 1; --i) {
   1:     SelectionType type = 1 << (i - 1);
   1:     if (allTypes & type) {
   1:       // There is some selection of this type. Try to paint its decorations
   1:       // (there might not be any for this type but that's OK,
   1:       // PaintTextSelectionDecorations will exit early).
   1:       PaintTextSelectionDecorations(aCtx, aFramePt, aTextBaselinePt, aDirtyRect,
   1:                                     aProvider, aTextPaintStyle, details, type);
   1:     }
   1:   }
   1: 
   1:   DestroySelectionDetails(details);
   1:   return PR_TRUE;
   1: }
   1: 
   1: static PRUint32
   1: ComputeTransformedLength(PropertyProvider& aProvider)
   1: {
   1:   gfxSkipCharsIterator iter(aProvider.GetStart());
   1:   PRUint32 start = iter.GetSkippedOffset();
   1:   iter.AdvanceOriginal(aProvider.GetOriginalLength());
   1:   return iter.GetSkippedOffset() - start;
   1: }
   1: 
1508: gfxFloat
1508: nsTextFrame::GetSnappedBaselineY(gfxContext* aContext, gfxFloat aY)
1508: {
1508:   gfxFloat appUnitsPerDevUnit = mTextRun->GetAppUnitsPerDevUnit();
1508:   gfxFloat baseline = aY + mAscent;
1508:   gfxRect putativeRect(0, baseline/appUnitsPerDevUnit, 1, 1);
1508:   if (!aContext->UserToDevicePixelSnapped(putativeRect))
1508:     return baseline;
1508:   return aContext->DeviceToUser(putativeRect.pos).y*appUnitsPerDevUnit;
1508: }
1508: 
   1: void
   1: nsTextFrame::PaintText(nsIRenderingContext* aRenderingContext, nsPoint aPt,
   1:                        const nsRect& aDirtyRect)
   1: {
6862:   // Don't pass in aRenderingContext here, because we need a *reference*
6862:   // context and aRenderingContext might have some transform in it
   1:   // XXX get the block and line passed to us somehow! This is slow!
6862:   gfxSkipCharsIterator iter = EnsureTextRun();
   1:   if (!mTextRun)
   1:     return;
   1: 
   1:   nsTextPaintStyle textPaintStyle(this);
   1:   PropertyProvider provider(this, iter);
   1:   // Trim trailing whitespace
   1:   provider.InitializeForDisplay(PR_TRUE);
   1: 
9438:   gfxContext* ctx = aRenderingContext->ThebesContext();
   1: 
   1:   gfxPoint framePt(aPt.x, aPt.y);
   1:   gfxPoint textBaselinePt(
   1:       mTextRun->IsRightToLeft() ? gfxFloat(aPt.x + GetSize().width) : framePt.x,
1508:       GetSnappedBaselineY(ctx, aPt.y));
   1: 
   1:   gfxRect dirtyRect(aDirtyRect.x, aDirtyRect.y,
   1:                     aDirtyRect.width, aDirtyRect.height);
   1: 
   1:   // Fork off to the (slower) paint-with-selection path if necessary.
   1:   if (GetNonGeneratedAncestor(this)->GetStateBits() & NS_FRAME_SELECTED_CONTENT) {
   1:     if (PaintTextWithSelection(ctx, framePt, textBaselinePt,
   1:                                dirtyRect, provider, textPaintStyle))
   1:       return;
   1:   }
   1: 
   1:   gfxFloat advanceWidth;
   1:   gfxFloat* needAdvanceWidth =
   1:     (GetStateBits() & TEXT_HYPHEN_BREAK) ? &advanceWidth : nsnull;
   1:   ctx->SetColor(gfxRGBA(textPaintStyle.GetTextColor()));
   1:   
   1:   mTextRun->Draw(ctx, textBaselinePt,
   1:                  provider.GetStart().GetSkippedOffset(),
   1:                  ComputeTransformedLength(provider),
   1:                  &dirtyRect, &provider, needAdvanceWidth);
   1:   if (GetStateBits() & TEXT_HYPHEN_BREAK) {
   1:     gfxFloat hyphenBaselineX = textBaselinePt.x + mTextRun->GetDirection()*advanceWidth;
6862:     // Don't use ctx as the context, because we need a reference context here,
6862:     // ctx may be transformed.
6862:     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, this));
5724:     if (hyphenTextRun.get()) {
   1:       hyphenTextRun->Draw(ctx, gfxPoint(hyphenBaselineX, textBaselinePt.y),
   1:                           0, hyphenTextRun->GetLength(), &dirtyRect, nsnull, nsnull);
   1:     }
   1:   }
5601:   PaintTextDecorations(ctx, dirtyRect, framePt, textBaselinePt,
5601:                        textPaintStyle, provider);
   1: }
   1: 
   1: PRInt16
   1: nsTextFrame::GetSelectionStatus(PRInt16* aSelectionFlags)
   1: {
   1:   // get the selection controller
   1:   nsCOMPtr<nsISelectionController> selectionController;
 280:   nsresult rv = GetSelectionController(PresContext(),
   1:                                        getter_AddRefs(selectionController));
   1:   if (NS_FAILED(rv) || !selectionController)
   1:     return nsISelectionController::SELECTION_OFF;
   1: 
   1:   selectionController->GetSelectionFlags(aSelectionFlags);
   1: 
   1:   PRInt16 selectionValue;
   1:   selectionController->GetDisplaySelection(&selectionValue);
   1: 
   1:   return selectionValue;
   1: }
   1: 
   1: PRBool
   1: nsTextFrame::IsVisibleInSelection(nsISelection* aSelection)
   1: {
   1:   // Check the quick way first
   1:   PRBool isSelected = (mState & NS_FRAME_SELECTED_CONTENT) == NS_FRAME_SELECTED_CONTENT;
   1:   if (!isSelected)
   1:     return PR_FALSE;
   1:     
   1:   SelectionDetails* details = GetSelectionDetails();
   1:   PRBool found = PR_FALSE;
   1:     
   1:   // where are the selection points "really"
   1:   SelectionDetails *sdptr = details;
   1:   while (sdptr) {
3118:     if (sdptr->mEnd > GetContentOffset() &&
3118:         sdptr->mStart < GetContentEnd() &&
   1:         sdptr->mType == nsISelectionController::SELECTION_NORMAL) {
   1:       found = PR_TRUE;
   1:       break;
   1:     }
   1:     sdptr = sdptr->mNext;
   1:   }
   1:   DestroySelectionDetails(details);
   1: 
   1:   return found;
   1: }
   1: 
1443: /**
1443:  * Compute the longest prefix of text whose width is <= aWidth. Return
1443:  * the length of the prefix. Also returns the width of the prefix in aFitWidth.
1443:  */
   1: static PRUint32
   1: CountCharsFit(gfxTextRun* aTextRun, PRUint32 aStart, PRUint32 aLength,
   8:               gfxFloat aWidth, PropertyProvider* aProvider,
   8:               gfxFloat* aFitWidth)
   1: {
   1:   PRUint32 last = 0;
1443:   gfxFloat width = 0;
   1:   PRUint32 i;
   1:   for (i = 1; i <= aLength; ++i) {
   8:     if (i == aLength || aTextRun->IsClusterStart(aStart + i)) {
1443:       gfxFloat nextWidth = width +
1443:           aTextRun->GetAdvanceWidth(aStart + last, i - last, aProvider);
1443:       if (nextWidth > aWidth)
1443:         break;
1443:       last = i;
1443:       width = nextWidth;
1443:     }
1443:   }
1443:   *aFitWidth = width;
   1:   return last;
   8: }
   1: 
   1: nsIFrame::ContentOffsets
   1: nsTextFrame::CalcContentOffsetsFromFramePoint(nsPoint aPoint) {
   1:   ContentOffsets offsets;
   1:   
   1:   gfxSkipCharsIterator iter = EnsureTextRun();
   1:   if (!mTextRun)
   1:     return offsets;
   1:   
   1:   PropertyProvider provider(this, iter);
   1:   // Trim leading but not trailing whitespace if possible
   1:   provider.InitializeForDisplay(PR_FALSE);
   1:   gfxFloat width = mTextRun->IsRightToLeft() ? mRect.width - aPoint.x : aPoint.x;
   8:   gfxFloat fitWidth;
   1:   PRUint32 skippedLength = ComputeTransformedLength(provider);
   1: 
   1:   PRUint32 charsFit = CountCharsFit(mTextRun,
   8:       provider.GetStart().GetSkippedOffset(), skippedLength, width, &provider, &fitWidth);
   1: 
   1:   PRInt32 selectedOffset;
   1:   if (charsFit < skippedLength) {
   1:     // charsFit characters fitted, but no more could fit. See if we're
   1:     // more than halfway through the cluster.. If we are, choose the next
   1:     // cluster.
   1:     gfxSkipCharsIterator extraCluster(provider.GetStart());
   1:     extraCluster.AdvanceSkipped(charsFit);
   1:     gfxSkipCharsIterator extraClusterLastChar(extraCluster);
   1:     FindClusterEnd(mTextRun,
   1:                    provider.GetStart().GetOriginalOffset() + provider.GetOriginalLength(),
   1:                    &extraClusterLastChar);
   1:     gfxFloat charWidth =
   1:         mTextRun->GetAdvanceWidth(extraCluster.GetSkippedOffset(),
   1:                                   GetSkippedDistance(extraCluster, extraClusterLastChar) + 1,
   1:                                   &provider);
   8:     selectedOffset = width <= fitWidth + charWidth/2
   1:         ? extraCluster.GetOriginalOffset()
   1:         : extraClusterLastChar.GetOriginalOffset() + 1;
   1:   } else {
   1:     // All characters fitted, we're at (or beyond) the end of the text.
   1:     // XXX This could be some pathological situation where negative spacing
   1:     // caused characters to move backwards. We can't really handle that
   1:     // in the current frame system because frames can't have negative
   1:     // intrinsic widths.
   1:     selectedOffset =
   1:         provider.GetStart().GetOriginalOffset() + provider.GetOriginalLength();
   1:   }
   1: 
   1:   offsets.content = GetContent();
   1:   offsets.offset = offsets.secondaryOffset = selectedOffset;
   1:   offsets.associateWithNext = mContentOffset == offsets.offset;
   1:   return offsets;
   1: }
   1: 
   1: //null range means the whole thing
   1: NS_IMETHODIMP
   1: nsTextFrame::SetSelected(nsPresContext* aPresContext,
   1:                          nsIDOMRange *aRange,
   1:                          PRBool aSelected,
   1:                          nsSpread aSpread)
   1: {
   1:   DEBUG_VERIFY_NOT_DIRTY(mState);
   1: #if 0 //XXXrbs disable due to bug 310318
   1:   if (mState & NS_FRAME_IS_DIRTY)
   1:     return NS_ERROR_UNEXPECTED;
   1: #endif
   1: 
   1:   if (aSelected && ParentDisablesSelection())
   1:     return NS_OK;
   1: 
   1:   // check whether style allows selection
   1:   PRBool selectable;
   1:   IsSelectable(&selectable, nsnull);
   1:   if (!selectable)
   1:     return NS_OK;//do not continue no selection for this frame.
   1: 
   1:   PRBool found = PR_FALSE;
   1:   if (aRange) {
   1:     //lets see if the range contains us, if so we must redraw!
   1:     nsCOMPtr<nsIDOMNode> endNode;
   1:     PRInt32 endOffset;
   1:     nsCOMPtr<nsIDOMNode> startNode;
   1:     PRInt32 startOffset;
   1:     aRange->GetEndContainer(getter_AddRefs(endNode));
   1:     aRange->GetEndOffset(&endOffset);
   1:     aRange->GetStartContainer(getter_AddRefs(startNode));
   1:     aRange->GetStartOffset(&startOffset);
   1:     nsCOMPtr<nsIDOMNode> thisNode = do_QueryInterface(GetContent());
   1: 
   1:     if (thisNode == startNode)
   1:     {
3118:       if (GetContentEnd() >= startOffset)
   1:       {
   1:         found = PR_TRUE;
   1:         if (thisNode == endNode)
   1:         { //special case
   1:           if (endOffset == startOffset) //no need to redraw since drawing takes place with cursor
   1:             found = PR_FALSE;
   1: 
   1:           if (mContentOffset > endOffset)
   1:             found = PR_FALSE;
   1:         }
   1:       }
   1:     }
   1:     else if (thisNode == endNode)
   1:     {
   1:       if (mContentOffset < endOffset)
   1:         found = PR_TRUE;
   1:       else
   1:       {
   1:         found = PR_FALSE;
   1:       }
   1:     }
   1:     else
   1:     {
   1:       found = PR_TRUE;
   1:     }
   1:   }
   1:   else {
   1:     // null range means the whole thing
   1:     found = PR_TRUE;
   1:   }
   1: 
   1:   if ( aSelected )
   1:     AddStateBits(NS_FRAME_SELECTED_CONTENT);
   1:   else
   1:   { //we need to see if any other selection is available.
   1:     SelectionDetails *details = GetSelectionDetails();
   1:     if (!details) {
   1:       RemoveStateBits(NS_FRAME_SELECTED_CONTENT);
   1:     } else {
   1:       DestroySelectionDetails(details);
   1:     }
   1:   }
   1:   if (found) {
   1:     // Selection might change anything. Invalidate the overflow area.
   1:     Invalidate(GetOverflowRect(), PR_FALSE);
   1:   }
   1:   if (aSpread == eSpreadDown)
   1:   {
   1:     nsIFrame* frame = GetPrevContinuation();
   1:     while(frame){
   1:       frame->SetSelected(aPresContext, aRange,aSelected,eSpreadNone);
   1:       frame = frame->GetPrevContinuation();
   1:     }
   1:     frame = GetNextContinuation();
   1:     while (frame){
   1:       frame->SetSelected(aPresContext, aRange,aSelected,eSpreadNone);
   1:       frame = frame->GetNextContinuation();
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
4741: nsTextFrame::GetPointFromOffset(PRInt32 inOffset,
   1:                                 nsPoint* outPoint)
   1: {
4741:   if (!outPoint)
   1:     return NS_ERROR_NULL_POINTER;
   1: 
   1:   outPoint->x = 0;
   1:   outPoint->y = 0;
   1: 
   1:   DEBUG_VERIFY_NOT_DIRTY(mState);
   1:   if (mState & NS_FRAME_IS_DIRTY)
   1:     return NS_ERROR_UNEXPECTED;
   1: 
4678:   if (GetContentLength() <= 0) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   gfxSkipCharsIterator iter = EnsureTextRun();
   1:   if (!mTextRun)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   PropertyProvider properties(this, iter);
   1:   // Don't trim trailing whitespace, we want the caret to appear in the right
   1:   // place if it's positioned there
   1:   properties.InitializeForDisplay(PR_FALSE);  
   1: 
3118:   if (inOffset < GetContentOffset()){
   1:     NS_WARNING("offset before this frame's content");
3118:     inOffset = GetContentOffset();
3118:   } else if (inOffset > GetContentEnd()) {
   1:     NS_WARNING("offset after this frame's content");
3118:     inOffset = GetContentEnd();
   1:   }
   1:   PRInt32 trimmedOffset = properties.GetStart().GetOriginalOffset();
   1:   PRInt32 trimmedEnd = trimmedOffset + properties.GetOriginalLength();
   1:   inOffset = PR_MAX(inOffset, trimmedOffset);
   1:   inOffset = PR_MIN(inOffset, trimmedEnd);
   1: 
   1:   iter.SetOriginalOffset(inOffset);
   1: 
   1:   if (inOffset < trimmedEnd &&
   1:       !iter.IsOriginalCharSkipped() &&
   8:       !mTextRun->IsClusterStart(iter.GetSkippedOffset())) {
   1:     NS_WARNING("GetPointFromOffset called for non-cluster boundary");
   1:     FindClusterStart(mTextRun, &iter);
   1:   }
   1: 
   1:   gfxFloat advanceWidth =
   1:     mTextRun->GetAdvanceWidth(properties.GetStart().GetSkippedOffset(),
   1:                               GetSkippedDistance(properties.GetStart(), iter),
   1:                               &properties);
   1:   nscoord width = NSToCoordCeil(advanceWidth);
   1: 
   1:   if (mTextRun->IsRightToLeft()) {
   1:     outPoint->x = mRect.width - width;
   1:   } else {
   1:     outPoint->x = width;
   1:   }
   1:   outPoint->y = 0;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
1732: nsTextFrame::GetChildFrameContainingOffset(PRInt32   aContentOffset,
1732:                                            PRBool    aHint,
1732:                                            PRInt32*  aOutOffset,
1732:                                            nsIFrame**aOutFrame)
   1: {
   1:   DEBUG_VERIFY_NOT_DIRTY(mState);
   1: #if 0 //XXXrbs disable due to bug 310227
   1:   if (mState & NS_FRAME_IS_DIRTY)
   1:     return NS_ERROR_UNEXPECTED;
   1: #endif
   1: 
1732:   NS_ASSERTION(aOutOffset && aOutFrame, "Bad out parameters");
1732:   NS_ASSERTION(aContentOffset >= 0, "Negative content offset, existing code was very broken!");
1732: 
1732:   nsTextFrame* f = this;
1732:   if (aContentOffset >= mContentOffset) {
1732:     while (PR_TRUE) {
3233:       nsTextFrame* next = static_cast<nsTextFrame*>(f->GetNextContinuation());
1732:       if (!next || aContentOffset < next->GetContentOffset())
1732:         break;
1732:       if (aContentOffset == next->GetContentOffset()) {
1732:         if (aHint) {
1732:           f = next;
1732:         }
1732:         break;
1732:       }
1732:       f = next;
1732:     }
1732:   } else {
1732:     while (PR_TRUE) {
3233:       nsTextFrame* prev = static_cast<nsTextFrame*>(f->GetPrevContinuation());
1732:       if (!prev || aContentOffset > f->GetContentOffset())
1732:         break;
1732:       if (aContentOffset == f->GetContentOffset()) {
1732:         if (!aHint) {
1732:           f = prev;
1732:         }
1732:         break;
1732:       }
1732:       f = prev;
1732:     }
1732:   }
1732:   
1732:   *aOutOffset = aContentOffset - f->GetContentOffset();
1732:   *aOutFrame = f;
   1:   return NS_OK;
   1: }
   1: 
   1: PRBool
   1: nsTextFrame::PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset)
   1: {
4678:   NS_ASSERTION(aOffset && *aOffset <= GetContentLength(), "aOffset out of range");
   1: 
   1:   gfxSkipCharsIterator iter = EnsureTextRun();
   1:   if (!mTextRun)
   1:     return PR_FALSE;
   1: 
   8:   TrimmedOffsets trimmed = GetTrimmedOffsets(mContent->GetText(), PR_TRUE);
   1:   // Check whether there are nonskipped characters in the trimmmed range
4261:   return iter.ConvertOriginalToSkipped(trimmed.GetEnd()) >
   8:          iter.ConvertOriginalToSkipped(trimmed.mStart);
   1: }
   1: 
2319: /**
2319:  * This class iterates through the clusters before or after the given
2319:  * aPosition (which is a content offset). You can test each cluster
2319:  * to see if it's whitespace (as far as selection/caret movement is concerned),
2319:  * or punctuation, or if there is a word break before the cluster. ("Before"
2319:  * is interpreted according to aDirection, so if aDirection is -1, "before"
2319:  * means actually *after* the cluster content.)
2319:  */
2319: class ClusterIterator {
2319: public:
7679:   ClusterIterator(nsTextFrame* aTextFrame, PRInt32 aPosition, PRInt32 aDirection,
7679:                   nsString& aContext);
2319: 
2319:   PRBool NextCluster();
2319:   PRBool IsWhitespace();
2319:   PRBool IsPunctuation();
6802:   PRBool HaveWordBreakBefore() { return mHaveWordBreak; }
2319:   PRInt32 GetAfterOffset();
2319:   PRInt32 GetBeforeOffset();
2319: 
2319: private:
5453:   nsCOMPtr<nsIUGenCategory>   mCategories;
2319:   gfxSkipCharsIterator        mIterator;
2319:   const nsTextFragment*       mFrag;
2319:   nsTextFrame*                mTextFrame;
2319:   PRInt32                     mDirection;
2319:   PRInt32                     mCharIndex;
2319:   nsTextFrame::TrimmedOffsets mTrimmed;
2319:   nsTArray<PRPackedBool>      mWordBreaks;
6802:   PRPackedBool                mHaveWordBreak;
2319: };
2319: 
8085: static PRBool
8085: IsAcceptableCaretPosition(const gfxSkipCharsIterator& aIter, gfxTextRun* aTextRun,
8085:                           nsIFrame* aFrame)
8085: {
8085:   if (aIter.IsOriginalCharSkipped())
8085:     return PR_FALSE;
8085:   PRUint32 index = aIter.GetSkippedOffset();
8085:   if (!aTextRun->IsClusterStart(index))
8085:     return PR_FALSE;
8085:   return !(aFrame->GetStyleText()->WhiteSpaceIsSignificant() &&
8085:            aTextRun->GetChar(index) == '\n');
8085: }
8085: 
   1: PRBool
   1: nsTextFrame::PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset)
   1: {
4678:   PRInt32 contentLength = GetContentLength();
4678:   NS_ASSERTION(aOffset && *aOffset <= contentLength, "aOffset out of range");
   1: 
   1:   PRBool selectable;
   1:   PRUint8 selectStyle;  
   1:   IsSelectable(&selectable, &selectStyle);
   1:   if (selectStyle == NS_STYLE_USER_SELECT_ALL)
   1:     return PR_FALSE;
   1: 
   1:   gfxSkipCharsIterator iter = EnsureTextRun();
   1:   if (!mTextRun)
   1:     return PR_FALSE;
   1: 
7677:   TrimmedOffsets trimmed = GetTrimmedOffsets(mContent->GetText(), PR_FALSE);
   1: 
   1:   // A negative offset means "end of frame".
4678:   PRInt32 startOffset = GetContentOffset() + (*aOffset < 0 ? contentLength : *aOffset);
   1: 
   1:   if (!aForward) {
   1:     PRInt32 i;
4261:     for (i = PR_MIN(trimmed.GetEnd(), startOffset) - 1;
   8:          i >= trimmed.mStart; --i) {
   1:       iter.SetOriginalOffset(i);
8085:       if (IsAcceptableCaretPosition(iter, mTextRun, this)) {
   1:         *aOffset = i - mContentOffset;
   1:         return PR_TRUE;
   1:       }
   1:     }
 202:     *aOffset = 0;
   1:   } else {
   1:     PRInt32 i;
4261:     for (i = startOffset + 1; i <= trimmed.GetEnd(); ++i) {
   1:       iter.SetOriginalOffset(i);
 202:       // XXX we can't necessarily stop at the end of this frame,
 202:       // but we really have no choice right now. We need to do a deeper
 202:       // fix/restructuring of PeekOffsetCharacter
4261:       if (i == trimmed.GetEnd() ||
8085:           IsAcceptableCaretPosition(iter, mTextRun, this)) {
   1:         *aOffset = i - mContentOffset;
   1:         return PR_TRUE;
   1:       }
   1:     }
4678:     *aOffset = contentLength;
   1:   }
   1:   
   1:   return PR_FALSE;
   1: }
   1: 
   1: PRBool
2319: ClusterIterator::IsWhitespace()
2319: {
2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
2319:   return IsSelectionSpace(mFrag, mCharIndex);
2319: }
2319: 
2319: PRBool
2319: ClusterIterator::IsPunctuation()
2319: {
2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
5453:   if (!mCategories)
5453:     return PR_FALSE;
5453:   nsIUGenCategory::nsUGenCategory c = mCategories->Get(mFrag->CharAt(mCharIndex));
5453:   return c == nsIUGenCategory::kPunctuation || c == nsIUGenCategory::kSymbol;
2319: }
2319: 
2319: PRInt32
2319: ClusterIterator::GetBeforeOffset()
2319: {
2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
2319:   return mCharIndex + (mDirection > 0 ? 0 : 1);
2319: }
2319: 
2319: PRInt32
2319: ClusterIterator::GetAfterOffset()
2319: {
2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
2319:   return mCharIndex + (mDirection > 0 ? 1 : 0);
2319: }
2319: 
2319: PRBool
2319: ClusterIterator::NextCluster()
2319: {
2319:   if (!mDirection)
2319:     return PR_FALSE;
2319:   gfxTextRun* textRun = mTextFrame->GetTextRun();
2319: 
6802:   mHaveWordBreak = PR_FALSE;
2319:   while (PR_TRUE) {
6802:     PRBool keepGoing = PR_FALSE;
2319:     if (mDirection > 0) {
4261:       if (mIterator.GetOriginalOffset() >= mTrimmed.GetEnd())
2319:         return PR_FALSE;
6802:       keepGoing = mIterator.IsOriginalCharSkipped() ||
2319:           mIterator.GetOriginalOffset() < mTrimmed.mStart ||
6802:           !textRun->IsClusterStart(mIterator.GetSkippedOffset());
2319:       mCharIndex = mIterator.GetOriginalOffset();
2319:       mIterator.AdvanceOriginal(1);
2319:     } else {
2319:       if (mIterator.GetOriginalOffset() <= mTrimmed.mStart)
2319:         return PR_FALSE;
2319:       mIterator.AdvanceOriginal(-1);
6802:       keepGoing = mIterator.IsOriginalCharSkipped() ||
4261:           mIterator.GetOriginalOffset() >= mTrimmed.GetEnd() ||
6802:           !textRun->IsClusterStart(mIterator.GetSkippedOffset());
2319:       mCharIndex = mIterator.GetOriginalOffset();
2319:     }
2319: 
6802:     if (mWordBreaks[GetBeforeOffset() - mTextFrame->GetContentOffset()]) {
6802:       mHaveWordBreak = PR_TRUE;
6802:     }
6802:     if (!keepGoing)
2319:       return PR_TRUE;
2319:   }
2319: }
2319: 
2319: ClusterIterator::ClusterIterator(nsTextFrame* aTextFrame, PRInt32 aPosition,
7679:                                  PRInt32 aDirection, nsString& aContext)
2319:   : mTextFrame(aTextFrame), mDirection(aDirection), mCharIndex(-1)
2319: {
2319:   mIterator = aTextFrame->EnsureTextRun();
2319:   if (!aTextFrame->GetTextRun()) {
2319:     mDirection = 0; // signal failure
2319:     return;
2319:   }
2319:   mIterator.SetOriginalOffset(aPosition);
2319: 
5453:   mCategories = do_GetService(NS_UNICHARCATEGORY_CONTRACTID);
5453:   
2319:   mFrag = aTextFrame->GetContent()->GetText();
2319:   mTrimmed = aTextFrame->GetTrimmedOffsets(mFrag, PR_TRUE);
2319: 
6802:   PRInt32 textOffset = aTextFrame->GetContentOffset();
3438:   PRInt32 textLen = aTextFrame->GetContentLength();
5453:   if (!mWordBreaks.AppendElements(textLen + 1)) {
2319:     mDirection = 0; // signal failure
2319:     return;
2319:   }
5453:   memset(mWordBreaks.Elements(), PR_FALSE, textLen + 1);
7679:   PRInt32 textStart;
7679:   if (aDirection > 0) {
7679:     if (aContext.IsEmpty()) {
7679:       // No previous context, so it must be the start of a line or text run
7679:       mWordBreaks[0] = PR_TRUE;
7679:     }
7679:     textStart = aContext.Length();
7679:     mFrag->AppendTo(aContext, textOffset, textLen);
7679:   } else {
7679:     if (aContext.IsEmpty()) {
7679:       // No following context, so it must be the end of a line or text run
7679:       mWordBreaks[textLen] = PR_TRUE;
7679:     }
7679:     textStart = 0;
7679:     nsAutoString str;
7679:     mFrag->AppendTo(str, textOffset, textLen);
7679:     aContext.Insert(str, 0);
7679:   }
2319:   nsIWordBreaker* wordBreaker = nsContentUtils::WordBreaker();
7679:   PRInt32 i;
7679:   for (i = 0; i <= textLen; ++i) {
7679:     PRInt32 indexInText = i + textStart;
7679:     mWordBreaks[i] |=
7679:       wordBreaker->BreakInBetween(aContext.get(), indexInText,
7679:                                   aContext.get() + indexInText,
7679:                                   aContext.Length() - indexInText);
6802:   }
5453: }
2319: 
2319: PRBool
   1: nsTextFrame::PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,
5453:                             PRInt32* aOffset, PeekWordState* aState)
   1: {
4678:   PRInt32 contentLength = GetContentLength();
4678:   NS_ASSERTION (aOffset && *aOffset <= contentLength, "aOffset out of range");
   1: 
   1:   PRBool selectable;
   1:   PRUint8 selectStyle;
   1:   IsSelectable(&selectable, &selectStyle);
   1:   if (selectStyle == NS_STYLE_USER_SELECT_ALL)
   1:     return PR_FALSE;
   1: 
4678:   PRInt32 offset = GetContentOffset() + (*aOffset < 0 ? contentLength : *aOffset);
7679:   ClusterIterator cIter(this, offset, aForward ? 1 : -1, aState->mContext);
2678: 
2678:   if (!cIter.NextCluster())
2678:     return PR_FALSE;
2678:   
2678:   do {
5453:     PRBool isPunctuation = cIter.IsPunctuation();
8807:     if (aWordSelectEatSpace == cIter.IsWhitespace() && !aState->mSawBeforeType) {
5453:       aState->SetSawBeforeType();
8807:       aState->Update(isPunctuation);
2678:       continue;
2678:     }
5453:     // See if we can break before the current cluster
5453:     if (!aState->mAtStart) {
5453:       PRBool canBreak = isPunctuation != aState->mLastCharWasPunctuation
8807:         ? BreakWordBetweenPunctuation(aForward ? aState->mLastCharWasPunctuation : isPunctuation,
8807:                                       aIsKeyboardSelect)
5453:         : cIter.HaveWordBreakBefore() && aState->mSawBeforeType;
5453:       if (canBreak) {
2319:         *aOffset = cIter.GetBeforeOffset() - mContentOffset;
2319:         return PR_TRUE;
2319:       }
5453:     }
8807:     aState->Update(isPunctuation);
2678:   } while (cIter.NextCluster());
2678: 
2319:   *aOffset = cIter.GetAfterOffset() - mContentOffset;
   8:   return PR_FALSE;
   1: }
   1: 
   1:  // TODO this needs to be deCOMtaminated with the interface fixed in
   1: // nsIFrame.h, but we won't do that until the old textframe is gone.
   1: NS_IMETHODIMP
   1: nsTextFrame::CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex,
   1:     PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *aRetval)
   1: {
   1:   if (!aRetval)
   1:     return NS_ERROR_NULL_POINTER;
   1: 
   1:   // Text in the range is visible if there is at least one character in the range
   1:   // that is not skipped and is mapped by this frame (which is the primary frame)
   1:   // or one of its continuations.
   1:   for (nsTextFrame* f = this; f;
3233:        f = static_cast<nsTextFrame*>(GetNextContinuation())) {
   1:     if (f->PeekOffsetNoAmount(PR_TRUE, nsnull)) {
   1:       *aRetval = PR_TRUE;
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   *aRetval = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTextFrame::GetOffsets(PRInt32 &start, PRInt32 &end) const
   1: {
3118:   start = GetContentOffset();
3118:   end = GetContentEnd();
   1:   return NS_OK;
   1: }
   1: 
3118: /**
3118:  * Returns PR_TRUE if this text frame completes the first-letter, PR_FALSE
3118:  * if it does not contain a true "letter".
3118:  * If returns PR_TRUE, then it also updates aLength to cover just the first-letter
3118:  * text.
3118:  *
3118:  * XXX :first-letter should be handled during frame construction
3118:  * (and it has a good bit in common with nextBidi)
3118:  * 
3118:  * @param aLength an in/out parameter: on entry contains the maximum length to
3118:  * return, on exit returns length of the first-letter fragment (which may
3118:  * include leading punctuation, for example)
3118:  */
   1: static PRBool
   1: FindFirstLetterRange(const nsTextFragment* aFrag,
   1:                      gfxTextRun* aTextRun,
3417:                      PRInt32 aOffset, const gfxSkipCharsIterator& aIter,
3417:                      PRInt32* aLength)
   1: {
   1:   // Find first non-whitespace, non-punctuation cluster, and stop after it
   1:   PRInt32 i;
   1:   PRInt32 length = *aLength;
   1:   for (i = 0; i < length; ++i) {
2344:     if (!IsTrimmableSpace(aFrag, aOffset + i) &&
7832:         !nsContentUtils::IsPunctuationMark(aFrag->CharAt(aOffset + i)))
   1:       break;
   1:   }
   1: 
   1:   if (i == length)
   1:     return PR_FALSE;
   1: 
3417:   // Advance to the end of the cluster
3417:   gfxSkipCharsIterator iter(aIter);
3417:   PRInt32 nextClusterStart;
3417:   for (nextClusterStart = i + 1; nextClusterStart < length; ++nextClusterStart) {
5727:     iter.SetOriginalOffset(aOffset + nextClusterStart);
3417:     if (iter.IsOriginalCharSkipped() ||
3417:         aTextRun->IsClusterStart(iter.GetSkippedOffset()))
   1:       break;
   1:   }
3417:   *aLength = nextClusterStart;
   1:   return PR_TRUE;
   1: }
   1: 
   1: static nsRect ConvertGfxRectOutward(const gfxRect& aRect)
   1: {
   1:   nsRect r;
   1:   r.x = NSToCoordFloor(aRect.X());
   1:   r.y = NSToCoordFloor(aRect.Y());
   1:   r.width = NSToCoordCeil(aRect.XMost()) - r.x;
   1:   r.height = NSToCoordCeil(aRect.YMost()) - r.y;
   1:   return r;
   1: }
   1: 
   1: static PRUint32
   8: FindStartAfterSkippingWhitespace(PropertyProvider* aProvider,
   8:                                  nsIFrame::InlineIntrinsicWidthData* aData,
   8:                                  PRBool aCollapseWhitespace,
   8:                                  gfxSkipCharsIterator* aIterator,
   8:                                  PRUint32 aFlowEndInTextRun)
   1: {
   8:   if (aData->skipWhitespace && aCollapseWhitespace) {
   8:     while (aIterator->GetSkippedOffset() < aFlowEndInTextRun &&
2344:            IsTrimmableSpace(aProvider->GetFragment(), aIterator->GetOriginalOffset())) {
2013:       aIterator->AdvanceOriginal(1);
   8:     }
   8:   }
   8:   return aIterator->GetSkippedOffset();
   1: }
   1: 
1284: /* virtual */ 
1284: void nsTextFrame::MarkIntrinsicWidthsDirty()
1284: {
1284:   ClearTextRun();
1284:   nsFrame::MarkIntrinsicWidthsDirty();
1284: }
1284: 
   1: // XXX this doesn't handle characters shaped by line endings. We need to
   1: // temporarily override the "current line ending" settings.
   1: void
   1: nsTextFrame::AddInlineMinWidthForFlow(nsIRenderingContext *aRenderingContext,
   1:                                       nsIFrame::InlineMinWidthData *aData)
   1: {
   1:   PRUint32 flowEndInTextRun;
9438:   gfxContext* ctx = aRenderingContext->ThebesContext();
   1:   gfxSkipCharsIterator iter =
6862:     EnsureTextRun(ctx, nsnull, aData->line, &flowEndInTextRun);
   1:   if (!mTextRun)
   1:     return;
   1: 
1732:   // Pass null for the line container. This will disable tab spacing, but that's
1732:   // OK since we can't really handle tabs for intrinsic sizing anyway.
2013:   const nsTextFragment* frag = mContent->GetText();
2013:   PropertyProvider provider(mTextRun, GetStyleText(), frag, this,
8556:                             iter, PR_INT32_MAX, nsnull, 0);
   8: 
  60:   PRBool collapseWhitespace = !provider.GetStyleText()->WhiteSpaceIsSignificant();
   8:   PRUint32 start =
   8:     FindStartAfterSkippingWhitespace(&provider, aData, collapseWhitespace,
   8:                                      &iter, flowEndInTextRun);
   1:   if (start >= flowEndInTextRun)
   1:     return;
   8: 
   1:   // XXX Should we consider hyphenation here?
2668:   for (PRUint32 i = start, wordStart = start; i <= flowEndInTextRun; ++i) {
2668:     PRBool preformattedNewline = PR_FALSE;
2668:     if (i < flowEndInTextRun) {
2668:       // XXXldb Shouldn't we be including the newline as part of the
2668:       // segment that it ends rather than part of the segment that it
2668:       // starts?
2742:       preformattedNewline = !collapseWhitespace && mTextRun->GetChar(i) == '\n';
2668:       if (!mTextRun->CanBreakLineBefore(i) && !preformattedNewline) {
2668:         // we can't break here (and it's not the end of the flow)
   8:         continue;
2347:       }
2347:     }
   8: 
2668:     if (i > wordStart) {
   8:       nscoord width =
   8:         NSToCoordCeil(mTextRun->GetAdvanceWidth(wordStart, i - wordStart, &provider));
   8:       aData->currentLine += width;
2668:       aData->atStartOfLine = PR_FALSE;
   8: 
   8:       if (collapseWhitespace) {
2013:         PRUint32 trimStart = GetEndOfTrimmedText(frag, wordStart, i, &iter);
2013:         if (trimStart == start) {
6529:           // This is *all* trimmable whitespace, so whatever trailingWhitespace
6529:           // we saw previously is still trailing...
6529:           aData->trailingWhitespace += width;
   8:         } else {
6529:           // Some non-whitespace so the old trailingWhitespace is no longer trailing
6529:           aData->trailingWhitespace =
   8:             NSToCoordCeil(mTextRun->GetAdvanceWidth(trimStart, i - trimStart, &provider));
   8:         }
   8:       } else {
   1:         aData->trailingWhitespace = 0;
   8:       }
2668:     }
2668: 
8803:     if (i < flowEndInTextRun ||
8803:         (i == mTextRun->GetLength() &&
8803:          (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK))) {
2668:       if (preformattedNewline) {
2668:         aData->ForceBreak(aRenderingContext);
2668:       } else {
2668:         aData->OptionallyBreak(aRenderingContext);
2668:       }
   1:       wordStart = i;
   1:     }
   1:   }
   1: 
6529:   // Check if we have collapsible whitespace at the end
   8:   aData->skipWhitespace =
6529:     IsTrimmableSpace(provider.GetFragment(), provider.GetStyleText(),
   8:                      iter.ConvertSkippedToOriginal(flowEndInTextRun - 1));
   1: }
   1: 
   1: // XXX Need to do something here to avoid incremental reflow bugs due to
   1: // first-line and first-letter changing min-width
   1: /* virtual */ void
   1: nsTextFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
   1:                                nsIFrame::InlineMinWidthData *aData)
   1: {
2679:   nsTextFrame* f;
2679:   gfxTextRun* lastTextRun = nsnull;
2679:   // nsContinuingTextFrame does nothing for AddInlineMinWidth; all text frames
2679:   // in the flow are handled right here.
3233:   for (f = this; f; f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
2679:     // f->mTextRun could be null if we haven't set up textruns yet for f.
2679:     // Except in OOM situations, lastTextRun will only be null for the first
2679:     // text frame.
2679:     if (f == this || f->mTextRun != lastTextRun) {
2679:       // This will process all the text frames that share the same textrun as f.
   1:       f->AddInlineMinWidthForFlow(aRenderingContext, aData);
2679:       lastTextRun = f->mTextRun;
   1:     }
   1:   }
   1: }
   1: 
   1: // XXX this doesn't handle characters shaped by line endings. We need to
   1: // temporarily override the "current line ending" settings.
   1: void
   1: nsTextFrame::AddInlinePrefWidthForFlow(nsIRenderingContext *aRenderingContext,
   1:                                        nsIFrame::InlinePrefWidthData *aData)
   1: {
   1:   PRUint32 flowEndInTextRun;
9438:   gfxContext* ctx = aRenderingContext->ThebesContext();
   1:   gfxSkipCharsIterator iter =
6862:     EnsureTextRun(ctx, nsnull, aData->line, &flowEndInTextRun);
   1:   if (!mTextRun)
   1:     return;
   1: 
1732:   // Pass null for the line container. This will disable tab spacing, but that's
1732:   // OK since we can't really handle tabs for intrinsic sizing anyway.
   8:   PropertyProvider provider(mTextRun, GetStyleText(), mContent->GetText(), this,
8556:                             iter, PR_INT32_MAX, nsnull, 0);
   8: 
  60:   PRBool collapseWhitespace = !provider.GetStyleText()->WhiteSpaceIsSignificant();
   8:   PRUint32 start =
   8:     FindStartAfterSkippingWhitespace(&provider, aData, collapseWhitespace,
   8:                                      &iter, flowEndInTextRun);
   1:   if (start >= flowEndInTextRun)
   1:     return;
   8: 
   8:   if (collapseWhitespace) {
   8:     // \n line breaks are not honoured, so everything would like to go
   8:     // onto one line, so just measure it
6529:     nscoord width =
  60:       NSToCoordCeil(mTextRun->GetAdvanceWidth(start, flowEndInTextRun - start, &provider));
7750:     aData->currentLine = NSCoordSaturatingAdd(aData->currentLine, width);
   8: 
2013:     PRUint32 trimStart = GetEndOfTrimmedText(provider.GetFragment(), start,
2013:                                              flowEndInTextRun, &iter);
2013:     if (trimStart == start) {
   8:       // This is *all* trimmable whitespace, so whatever trailingWhitespace
   8:       // we saw previously is still trailing...
6529:       aData->trailingWhitespace += width;
   1:     } else {
   8:       // Some non-whitespace so the old trailingWhitespace is no longer trailing
6529:       aData->trailingWhitespace =
6529:         NSToCoordCeil(mTextRun->GetAdvanceWidth(trimStart, flowEndInTextRun - trimStart, &provider));
   1:     }
   1:   } else {
   1:     // We respect line breaks, so measure off each line (or part of line).
2742:     aData->trailingWhitespace = 0;
2742:     PRUint32 i;
   8:     PRUint32 startRun = start;
2742:     for (i = start; i <= flowEndInTextRun; ++i) {
2742:       if (i < flowEndInTextRun && mTextRun->GetChar(i) != '\n')
2742:         continue;
2742:         
   1:       aData->currentLine +=
2742:         NSToCoordCeil(mTextRun->GetAdvanceWidth(startRun, i - startRun, &provider));
2742:       if (i < flowEndInTextRun) {
2668:         aData->ForceBreak(aRenderingContext);
2742:         startRun = i;
2742:       }
2742:     }
   8:   }
   8: 
6529:   // Check if we have collapsible whitespace at the end
   8:   aData->skipWhitespace =
6529:     IsTrimmableSpace(provider.GetFragment(), provider.GetStyleText(),
   8:                      iter.ConvertSkippedToOriginal(flowEndInTextRun - 1));
   1: }
   1: 
   1: // XXX Need to do something here to avoid incremental reflow bugs due to
   1: // first-line and first-letter changing pref-width
   1: /* virtual */ void
   1: nsTextFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
   1:                                 nsIFrame::InlinePrefWidthData *aData)
   1: {
2679:   nsTextFrame* f;
2679:   gfxTextRun* lastTextRun = nsnull;
2679:   // nsContinuingTextFrame does nothing for AddInlineMinWidth; all text frames
2679:   // in the flow are handled right here.
3233:   for (f = this; f; f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
2679:     // f->mTextRun could be null if we haven't set up textruns yet for f.
2679:     // Except in OOM situations, lastTextRun will only be null for the first
2679:     // text frame.
2679:     if (f == this || f->mTextRun != lastTextRun) {
2679:       // This will process all the text frames that share the same textrun as f.
   1:       f->AddInlinePrefWidthForFlow(aRenderingContext, aData);
2679:       lastTextRun = f->mTextRun;
   1:     }
   1:   }
   1: }
   1: 
   1: /* virtual */ nsSize
   1: nsTextFrame::ComputeSize(nsIRenderingContext *aRenderingContext,
   1:                          nsSize aCBSize, nscoord aAvailableWidth,
   1:                          nsSize aMargin, nsSize aBorder, nsSize aPadding,
   1:                          PRBool aShrinkWrap)
   1: {
   1:   // Inlines and text don't compute size before reflow.
   1:   return nsSize(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
   1: }
   1: 
6862: static nsRect
6862: RoundOut(const gfxRect& aRect)
6862: {
6862:   nsRect r;
6862:   r.x = NSToCoordFloor(aRect.X());
6862:   r.y = NSToCoordFloor(aRect.Y());
6862:   r.width = NSToCoordCeil(aRect.XMost()) - r.x;
6862:   r.height = NSToCoordCeil(aRect.YMost()) - r.y;
6862:   return r;
6862: }
6862: 
6862: nsRect
6862: nsTextFrame::ComputeTightBounds(gfxContext* aContext) const
6862: {
6862:   if ((GetStyleContext()->HasTextDecorations() &&
6862:        eCompatibility_NavQuirks == PresContext()->CompatibilityMode()) ||
6862:       (GetStateBits() & TEXT_HYPHEN_BREAK)) {
6862:     // This is conservative, but OK.
6862:     return GetOverflowRect();
6862:   }
6862: 
6862:   gfxSkipCharsIterator iter = const_cast<nsTextFrame*>(this)->EnsureTextRun();
6862:   if (!mTextRun)
6862:     return nsRect(0, 0, 0, 0);
6862: 
6862:   PropertyProvider provider(const_cast<nsTextFrame*>(this), iter);
6862:   // Trim trailing whitespace
6862:   provider.InitializeForDisplay(PR_TRUE);
6862: 
6862:   gfxTextRun::Metrics metrics =
6862:         mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
6862:                               ComputeTransformedLength(provider), PR_TRUE,
6862:                               aContext, &provider);
6862:   // mAscent should be the same as metrics.mAscent, but it's what we use to
6862:   // paint so that's the one we'll use.
6862:   return RoundOut(metrics.mBoundingBox) + nsPoint(0, mAscent);
6862: }
6862: 
 202: static void
1328: AddCharToMetrics(gfxTextRun* aCharTextRun, gfxTextRun* aBaseTextRun,
6247:                  gfxTextRun::Metrics* aMetrics, PRBool aTightBoundingBox,
6247:                  gfxContext* aContext)
 202: {
 202:   gfxRect charRect;
1328:   // assume char does not overflow font metrics!!!
1328:   gfxFloat width = aCharTextRun->GetAdvanceWidth(0, aCharTextRun->GetLength(), nsnull);
 202:   if (aTightBoundingBox) {
1328:     gfxTextRun::Metrics charMetrics =
6247:         aCharTextRun->MeasureText(0, aCharTextRun->GetLength(), PR_TRUE, aContext, nsnull);
 202:     charRect = charMetrics.mBoundingBox;
 202:   } else {
1328:     charRect = gfxRect(0, -aMetrics->mAscent, width,
 202:                        aMetrics->mAscent + aMetrics->mDescent);
 202:   }
1328:   if (aBaseTextRun->IsRightToLeft()) {
 202:     // Char comes before text, so the bounding box is moved to the
 202:     // right by aWidth
1328:     aMetrics->mBoundingBox.MoveBy(gfxPoint(width, 0));
 202:   } else {
 202:     // char is moved to the right by mAdvanceWidth
1328:     charRect.MoveBy(gfxPoint(width, 0));
 202:   }
 202:   aMetrics->mBoundingBox = aMetrics->mBoundingBox.Union(charRect);
 202: 
1328:   aMetrics->mAdvanceWidth += width;
 202: }
 202: 
3006: static PRBool
3006: HasSoftHyphenBefore(const nsTextFragment* aFrag, gfxTextRun* aTextRun,
3006:                     PRInt32 aStartOffset, const gfxSkipCharsIterator& aIter)
3006: {
3006:   if (!(aTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_SHY))
3006:     return PR_FALSE;
3006:   gfxSkipCharsIterator iter = aIter;
3006:   while (iter.GetOriginalOffset() > aStartOffset) {
3006:     iter.AdvanceOriginal(-1);
3006:     if (!iter.IsOriginalCharSkipped())
3006:       break;
3006:     if (aFrag->CharAt(iter.GetOriginalOffset()) == CH_SHY)
3006:       return PR_TRUE;
3006:   }
3006:   return PR_FALSE;
3006: }
3006: 
4678: void
4678: nsTextFrame::SetLength(PRInt32 aLength)
4678: {
4678:   mContentLengthHint = aLength;
4678:   PRInt32 end = GetContentOffset() + aLength;
9735:   nsTextFrame* f = static_cast<nsTextFrame*>(GetNextInFlow());
9735:   if (!f)
4678:     return;
9735:   if (end < f->mContentOffset) {
9735:     // Our frame is shrinking. Give the text to our next in flow.
9735:     f->mContentOffset = end;
9735:     if (f->GetTextRun() != mTextRun) {
4678:       ClearTextRun();
9735:       f->ClearTextRun();
4678:     }
4678:     return;
4678:   }
9735:   while (f && f->mContentOffset < end) {
9735:     // Our frame is growing. Take text from our in-flow.
9735:     f->mContentOffset = end;
9735:     if (f->GetTextRun() != mTextRun) {
4678:       ClearTextRun();
9735:       f->ClearTextRun();
9735:     }
9735:     f = static_cast<nsTextFrame*>(f->GetNextInFlow());
9735:   }
4678: }
4678: 
   1: NS_IMETHODIMP
   1: nsTextFrame::Reflow(nsPresContext*           aPresContext,
   1:                     nsHTMLReflowMetrics&     aMetrics,
   1:                     const nsHTMLReflowState& aReflowState,
   1:                     nsReflowStatus&          aStatus)
   1: {
   1:   DO_GLOBAL_REFLOW_COUNT("nsTextFrame");
   1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
   1: #ifdef NOISY_REFLOW
   1:   ListTag(stdout);
   1:   printf(": BeginReflow: availableSize=%d,%d\n",
   1:          aReflowState.availableWidth, aReflowState.availableHeight);
   1: #endif
   1: 
   1:   /////////////////////////////////////////////////////////////////////
   1:   // Set up flags and clear out state
   1:   /////////////////////////////////////////////////////////////////////
   1: 
   1:   // Clear out the reflow state flags in mState (without destroying
   1:   // the TEXT_BLINK_ON bit). We also clear the whitespace flags because this
   1:   // can change whether the frame maps whitespace-only text or not.
   1:   RemoveStateBits(TEXT_REFLOW_FLAGS | TEXT_WHITESPACE_FLAGS);
   1: 
4104:   // Temporarily map all possible content while we construct our new textrun.
4104:   // so that when doing reflow our styles prevail over any part of the
4104:   // textrun we look at. Note that next-in-flows may be mapping the same
4104:   // content; gfxTextRun construction logic will ensure that we take priority.
   1:   PRInt32 maxContentLength = GetInFlowContentLength();
   1: 
   1:   // XXX If there's no line layout, we shouldn't even have created this
   1:   // frame. This may happen if, for example, this is text inside a table
   1:   // but not inside a cell. For now, just don't reflow. We also don't need to
   1:   // reflow if there is no content.
4678:   if (!aReflowState.mLineLayout || !maxContentLength) {
   1:     ClearMetrics(aMetrics);
   1:     aStatus = NS_FRAME_COMPLETE;
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsLineLayout& lineLayout = *aReflowState.mLineLayout;
   1: 
   1:   if (aPresContext->BidiEnabled()) {
   1:     // SetIsBidiSystem should go away at some point since we're going to require
   1:     // it to be effectively always true
   1:     aPresContext->SetIsBidiSystem(PR_TRUE);
   1:   }
   1: 
   1:   if (aReflowState.mFlags.mBlinks) {
   1:     if (0 == (mState & TEXT_BLINK_ON)) {
   1:       mState |= TEXT_BLINK_ON;
   1:       nsBlinkTimer::AddBlinkFrame(aPresContext, this);
   1:     }
   1:   }
   1:   else {
   1:     if (0 != (mState & TEXT_BLINK_ON)) {
   1:       mState &= ~TEXT_BLINK_ON;
   1:       nsBlinkTimer::RemoveBlinkFrame(this);
   1:     }
   1:   }
   1: 
   1:   const nsStyleText* textStyle = GetStyleText();
   1: 
   1:   PRBool atStartOfLine = lineLayout.CanPlaceFloatNow();
   1:   if (atStartOfLine) {
   1:     AddStateBits(TEXT_START_OF_LINE);
   1:   }
   1: 
   1:   // Layout dependent styles are a problem because we need to reconstruct
   1:   // the gfxTextRun based on our layout.
   1:   PRBool layoutDependentTextRun =
   1:     lineLayout.GetFirstLetterStyleOK() || lineLayout.GetInFirstLine();
   1:   if (layoutDependentTextRun) {
4678:     SetLength(maxContentLength);
  60:   }
  60: 
   1:   const nsTextFragment* frag = mContent->GetText();
   1:   // DOM offsets of the text range we need to measure, after trimming
   1:   // whitespace, restricting to first-letter, and restricting preformatted text
   1:   // to nearest newline
4678:   PRInt32 length = maxContentLength;
4678:   PRInt32 offset = GetContentOffset();
   1: 
   1:   // Restrict preformatted text to the nearest newline
   1:   PRInt32 newLineOffset = -1;
   1:   if (textStyle->WhiteSpaceIsSignificant()) {
   1:     newLineOffset = FindChar(frag, offset, length, '\n');
   1:     if (newLineOffset >= 0) {
   1:       length = newLineOffset + 1 - offset;
1732:       newLineOffset -= mContentOffset;
   1:     }
   8:   } else {
   8:     if (atStartOfLine) {
   8:       // Skip leading whitespace
2344:       PRInt32 whitespaceCount = GetTrimmableWhitespaceCount(frag, offset, length, 1);
   8:       offset += whitespaceCount;
   8:       length -= whitespaceCount;
   8:     }
   1:   }
   1: 
6779:   PRUint32 flowEndInTextRun;
6779:   nsIFrame* lineContainer = lineLayout.GetLineContainerFrame();
9438:   gfxContext* ctx = aReflowState.rendContext->ThebesContext();
6779:   gfxSkipCharsIterator iter =
6862:     EnsureTextRun(ctx, lineContainer, lineLayout.GetLine(), &flowEndInTextRun);
6779: 
6779:   PRInt32 skippedRunLength;
6779:   if (mTextRun && mTextRun->GetLength() == iter.GetSkippedOffset() &&
6779:       length > 0 &&
6779:       (!iter.IsOriginalCharSkipped(&skippedRunLength) || skippedRunLength < length)) {
6779:     // The textrun does not map enough text for this frame. This can happen
6779:     // when the textrun was ended in the middle of a text node because a
6779:     // preformatted newline was encountered, and prev-in-flow frames have
6779:     // consumed all the text of the textrun. We need a new textrun.
6779:     ClearTextRun();
6862:     iter = EnsureTextRun(ctx, lineContainer,
6779:                          lineLayout.GetLine(), &flowEndInTextRun);
6779:   }
6779:   
6779:   if (!mTextRun) {
6779:     ClearMetrics(aMetrics);
6779:     aStatus = NS_FRAME_COMPLETE;
6779:     return NS_OK;
6779:   }
6779: 
6779:   NS_ASSERTION(gfxSkipCharsIterator(iter).ConvertOriginalToSkipped(offset + length)
6779:                     <= mTextRun->GetLength(),
6779:                "Text run does not map enough text for our reflow");
6779: 
   1:   // Restrict to just the first-letter if necessary
   1:   PRBool completedFirstLetter = PR_FALSE;
   1:   if (lineLayout.GetFirstLetterStyleOK()) {
   1:     AddStateBits(TEXT_FIRST_LETTER);
3417:     completedFirstLetter = FindFirstLetterRange(frag, mTextRun, offset, iter, &length);
   1:   }
   1: 
   1:   /////////////////////////////////////////////////////////////////////
   1:   // See how much text should belong to this text frame, and measure it
   1:   /////////////////////////////////////////////////////////////////////
   1:   
   1:   iter.SetOriginalOffset(offset);
1732:   nscoord xOffsetForTabs = (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TAB) ?
1732:          lineLayout.GetCurrentFrameXDistanceFromBlock() : -1;
1732:   PropertyProvider provider(mTextRun, textStyle, frag, this, iter, length,
1732:       lineContainer, xOffsetForTabs);
   1: 
   1:   PRUint32 transformedOffset = provider.GetStart().GetSkippedOffset();
   1: 
   1:   // The metrics for the text go in here
   1:   gfxTextRun::Metrics textMetrics;
   1:   PRBool needTightBoundingBox = (GetStateBits() & TEXT_FIRST_LETTER) != 0;
   1: #ifdef MOZ_MATHML
6862:   NS_ASSERTION(!(NS_REFLOW_CALC_BOUNDING_METRICS & aMetrics.mFlags),
6862:                "We shouldn't be passed NS_REFLOW_CALC_BOUNDING_METRICS anymore");
   1: #endif
   1: 
   8:   PRInt32 limitLength = length;
   8:   PRInt32 forceBreak = lineLayout.GetForcedBreakPosition(mContent);
8780:   PRBool forceBreakAfter = PR_FALSE;
3055:   if (forceBreak >= offset + length) {
8780:     forceBreakAfter = forceBreak == offset + length;
3055:     // The break is not within the text considered for this textframe.
3055:     forceBreak = -1;
3055:   }
   8:   if (forceBreak >= 0) {
   8:     limitLength = forceBreak - offset;
   8:     NS_ASSERTION(limitLength >= 0, "Weird break found!");
   8:   }
   1:   // This is the heart of text reflow right here! We don't know where
   1:   // to break, so we need to see how much text fits in the available width.
   1:   PRUint32 transformedLength;
   8:   if (offset + limitLength >= PRInt32(frag->GetLength())) {
   8:     NS_ASSERTION(offset + limitLength == PRInt32(frag->GetLength()),
   1:                  "Content offset/length out of bounds");
   1:     NS_ASSERTION(flowEndInTextRun >= transformedOffset,
   1:                  "Negative flow length?");
   1:     transformedLength = flowEndInTextRun - transformedOffset;
   1:   } else {
   1:     // we're not looking at all the content, so we need to compute the
   1:     // length of the transformed substring we're looking at
   1:     gfxSkipCharsIterator iter(provider.GetStart());
   8:     iter.SetOriginalOffset(offset + limitLength);
   1:     transformedLength = iter.GetSkippedOffset() - transformedOffset;
   1:   }
   1:   PRUint32 transformedLastBreak = 0;
   8:   PRBool usedHyphenation;
1732:   gfxFloat trimmedWidth = 0;
1732:   gfxFloat availWidth = aReflowState.availableWidth;
7069:   PRBool canTrimTrailingWhitespace = !textStyle->WhiteSpaceIsSignificant();
   1:   PRUint32 transformedCharsFit =
   1:     mTextRun->BreakAndMeasureText(transformedOffset, transformedLength,
   1:                                   (GetStateBits() & TEXT_START_OF_LINE) != 0,
1732:                                   availWidth,
7069:                                   &provider, !lineLayout.LineIsBreakable(),
1732:                                   canTrimTrailingWhitespace ? &trimmedWidth : nsnull,
6247:                                   &textMetrics, needTightBoundingBox, ctx,
   1:                                   &usedHyphenation, &transformedLastBreak);
2013:   // The "end" iterator points to the first character after the string mapped
3006:   // by this frame. Basically, its original-string offset is offset+charsFit
2013:   // after we've computed charsFit.
2013:   gfxSkipCharsIterator end(provider.GetEndHint());
   1:   end.SetSkippedOffset(transformedOffset + transformedCharsFit);
   8:   PRInt32 charsFit = end.GetOriginalOffset() - offset;
1732:   // That might have taken us beyond our assigned content range (because
1732:   // we might have advanced over some skipped chars that extend outside
1732:   // this frame), so get back in.
   8:   PRInt32 lastBreak = -1;
   8:   if (charsFit >= limitLength) {
   8:     charsFit = limitLength;
   1:     if (transformedLastBreak != PR_UINT32_MAX) {
3006:       // lastBreak is needed.
   1:       // This may set lastBreak greater than 'length', but that's OK
3006:       lastBreak = end.ConvertSkippedToOriginal(transformedOffset + transformedLastBreak);
3006:     }
   1:     end.SetOriginalOffset(offset + charsFit);
3006:     // If we were forced to fit, and the break position is after a soft hyphen,
3006:     // note that this is a hyphenation break.
3006:     if (forceBreak >= 0 && HasSoftHyphenBefore(frag, mTextRun, offset, end)) {
3006:       usedHyphenation = PR_TRUE;
   1:     }
   1:   }
   1:   if (usedHyphenation) {
   1:     // Fix up metrics to include hyphen
6862:     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, ctx, this));
5724:     if (hyphenTextRun.get()) {
5724:       AddCharToMetrics(hyphenTextRun.get(),
6247:                        mTextRun, &textMetrics, needTightBoundingBox, ctx);
1563:     }
   1:     AddStateBits(TEXT_HYPHEN_BREAK);
   1:   }
   1: 
7069:   gfxFloat trimmableWidth = 0;
8083:   PRBool brokeText = forceBreak >= 0 || transformedCharsFit < transformedLength;
7069:   if (canTrimTrailingWhitespace) {
7069:     // Optimization: if we trimmed trailing whitespace, and we can be sure
7069:     // this frame will be at the end of the line, then leave it trimmed off.
7069:     // Otherwise we have to undo the trimming, in case we're not at the end of
7069:     // the line. (If we actually do end up at the end of the line, we'll have
7069:     // to trim it off again in TrimTrailingWhiteSpace, and we'd like to avoid
7069:     // having to re-do it.)
8083:     if (brokeText) {
7069:       // We're definitely going to break so our trailing whitespace should
7069:       // definitely be timmed. Record that we've already done it.
7069:       AddStateBits(TEXT_TRIMMED_TRAILING_WHITESPACE);
7069:     } else {
7069:       // We might not be at the end of the line. (Note that even if this frame
7069:       // ends in breakable whitespace, it might not be at the end of the line
7069:       // because it might be followed by breakable, but preformatted, whitespace.)
7069:       // Undo the trimming.
1732:       textMetrics.mAdvanceWidth += trimmedWidth;
7069:       trimmableWidth = trimmedWidth;
1732:       if (mTextRun->IsRightToLeft()) {
1732:         // Space comes before text, so the bounding box is moved to the
1732:         // right by trimmdWidth
1732:         textMetrics.mBoundingBox.MoveBy(gfxPoint(trimmedWidth, 0));
1732:       }
8083:     }
8083:   }
8083: 
8083:   if (!brokeText && lastBreak >= 0) {
7069:     // Since everything fit and no break was forced,
7069:     // record the last break opportunity
8083:     NS_ASSERTION(textMetrics.mAdvanceWidth - trimmableWidth <= aReflowState.availableWidth,
8083:                  "If the text doesn't fit, and we have a break opportunity, why didn't MeasureText use it?");
8083:     lineLayout.NotifyOptionalBreakPosition(mContent, lastBreak, PR_TRUE);
8083:   }
8083: 
4678:   PRInt32 contentLength = offset + charsFit - GetContentOffset();
   1: 
   1:   /////////////////////////////////////////////////////////////////////
   1:   // Compute output metrics
   1:   /////////////////////////////////////////////////////////////////////
   1: 
   1:   // first-letter frames should use the tight bounding box metrics for ascent/descent
   1:   // for good drop-cap effects
   1:   if (GetStateBits() & TEXT_FIRST_LETTER) {
   1:     textMetrics.mAscent = PR_MAX(0, -textMetrics.mBoundingBox.Y());
   1:     textMetrics.mDescent = PR_MAX(0, textMetrics.mBoundingBox.YMost());
   1:   }
   1:   
   1:   // Setup metrics for caller
   1:   // Disallow negative widths
   1:   aMetrics.width = NSToCoordCeil(PR_MAX(0, textMetrics.mAdvanceWidth));
   1:   aMetrics.ascent = NSToCoordCeil(textMetrics.mAscent);
   1:   aMetrics.height = aMetrics.ascent + NSToCoordCeil(textMetrics.mDescent);
   1:   NS_ASSERTION(aMetrics.ascent >= 0, "Negative ascent???");
   1:   NS_ASSERTION(aMetrics.height - aMetrics.ascent >= 0, "Negative descent???");
   1: 
   1:   mAscent = aMetrics.ascent;
   1: 
   1:   // Handle text that runs outside its normal bounds.
   1:   nsRect boundingBox =
   1:     ConvertGfxRectOutward(textMetrics.mBoundingBox + gfxPoint(0, textMetrics.mAscent));
   1:   aMetrics.mOverflowArea.UnionRect(boundingBox,
   1:                                    nsRect(0, 0, aMetrics.width, aMetrics.height));
   1: 
   1:   /////////////////////////////////////////////////////////////////////
   1:   // Clean up, update state
   1:   /////////////////////////////////////////////////////////////////////
   1: 
7069:   // If all our characters are discarded or collapsed, then trimmable width
7069:   // from the last textframe should be preserved. Otherwise the trimmable width
7069:   // from this textframe overrides. (Currently in CSS trimmable width can be
7069:   // at most one space so there's no way for trimmable width from a previous
7069:   // frame to accumulate with trimmable width from this frame.)
7069:   if (transformedCharsFit > 0) {
7069:     lineLayout.SetTrimmableWidth(NSToCoordFloor(trimmableWidth));
7069:   }
7069:   if (charsFit > 0 && charsFit == length &&
7069:       HasSoftHyphenBefore(frag, mTextRun, offset, end)) {
3006:     // Record a potential break after final soft hyphen
3006:     lineLayout.NotifyOptionalBreakPosition(mContent, offset + length,
3006:         textMetrics.mAdvanceWidth + provider.GetHyphenWidth() <= availWidth);
3006:   }
8780:   PRBool breakAfter = forceBreakAfter;
8780:   if (!breakAfter && charsFit == length &&
8780:       transformedOffset + transformedLength == mTextRun->GetLength() &&
8780:       (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK)) {
8780:     // We placed all the text in the textrun and we have a break opportunity at
8780:     // the end of the textrun. We need to record it because the following
8780:     // content may not care about nsLineBreaker.
8780: 
8573:     // Note that because we didn't break, we can be sure that (thanks to the
8573:     // code up above) textMetrics.mAdvanceWidth includes the width of any
8573:     // trailing whitespace. So we need to subtract trimmableWidth here
8573:     // because if we did break at this point, that much width would be trimmed.
8573:     if (textMetrics.mAdvanceWidth - trimmableWidth > availWidth) {
8573:       breakAfter = PR_TRUE;
8573:     } else {
8573:       lineLayout.NotifyOptionalBreakPosition(mContent, offset + length, PR_TRUE);
8573:     }
8573:   }
   1:   if (completedFirstLetter) {
   1:     lineLayout.SetFirstLetterStyleOK(PR_FALSE);
   1:   }
   1: 
   1:   // Compute reflow status
4678:   aStatus = contentLength == maxContentLength
   1:     ? NS_FRAME_COMPLETE : NS_FRAME_NOT_COMPLETE;
   1: 
   1:   if (charsFit == 0 && length > 0) {
   1:     // Couldn't place any text
   1:     aStatus = NS_INLINE_LINE_BREAK_BEFORE();
4678:   } else if (contentLength > 0 && contentLength - 1 == newLineOffset) {
   1:     // Ends in \n
   1:     aStatus = NS_INLINE_LINE_BREAK_AFTER(aStatus);
   1:     lineLayout.SetLineEndsInBR(PR_TRUE);
8573:   } else if (breakAfter) {
8573:     aStatus = NS_INLINE_LINE_BREAK_AFTER(aStatus);
   1:   }
   1: 
   1:   // Compute space and letter counts for justification, if required
   1:   if (NS_STYLE_TEXT_ALIGN_JUSTIFY == textStyle->mTextAlign &&
   1:       !textStyle->WhiteSpaceIsSignificant()) {
   1:     // This will include a space for trailing whitespace, if any is present.
   1:     // This is corrected for in nsLineLayout::TrimWhiteSpaceIn.
   1:     PRInt32 numJustifiableCharacters =
   1:       provider.ComputeJustifiableCharacters(offset, charsFit);
1764: 
4435:     NS_ASSERTION(numJustifiableCharacters <= charsFit,
5618:                  "Bad justifiable character count");
   1:     lineLayout.SetTextJustificationWeights(numJustifiableCharacters,
4435:         charsFit - numJustifiableCharacters);
   1:   }
   1: 
4678:   SetLength(contentLength);
   1: 
   1:   Invalidate(nsRect(nsPoint(0, 0), GetSize()));
   1: 
   1: #ifdef NOISY_REFLOW
   1:   ListTag(stdout);
   1:   printf(": desiredSize=%d,%d(b=%d) status=%x\n",
   1:          aMetrics.width, aMetrics.height, aMetrics.ascent,
   1:          aStatus);
   1: #endif
   1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
   1:   return NS_OK;
   1: }
   1: 
   1: /* virtual */ PRBool
   1: nsTextFrame::CanContinueTextRun() const
   1: {
   1:   // We can continue a text run through a text frame
   1:   return PR_TRUE;
   1: }
   1: 
8514: nsTextFrame::TrimOutput
8514: nsTextFrame::TrimTrailingWhiteSpace(nsIRenderingContext* aRC)
8514: {
8514:   TrimOutput result;
8514:   result.mChanged = PR_FALSE;
8514:   result.mLastCharIsJustifiable = PR_FALSE;
8514:   result.mDeltaWidth = 0;
   1: 
   1:   AddStateBits(TEXT_END_OF_LINE);
   1: 
4678:   PRInt32 contentLength = GetContentLength();
4678:   if (!contentLength)
8514:     return result;
   1: 
9438:   gfxContext* ctx = aRC->ThebesContext();
6862:   gfxSkipCharsIterator start = EnsureTextRun(ctx);
8514:   NS_ENSURE_TRUE(mTextRun, result);
8514: 
2319:   PRUint32 trimmedStart = start.GetSkippedOffset();
   1: 
   1:   const nsTextFragment* frag = mContent->GetText();
   8:   TrimmedOffsets trimmed = GetTrimmedOffsets(frag, PR_TRUE);
8514:   gfxSkipCharsIterator trimmedEndIter = start;
   1:   const nsStyleText* textStyle = GetStyleText();
   1:   gfxFloat delta = 0;
8514:   PRUint32 trimmedEnd = trimmedEndIter.ConvertOriginalToSkipped(trimmed.GetEnd());
   8:   
   8:   if (GetStateBits() & TEXT_TRIMMED_TRAILING_WHITESPACE) {
8514:     // We pre-trimmed this frame, so the last character is justifiable
8514:     result.mLastCharIsJustifiable = PR_TRUE;
4261:   } else if (trimmed.GetEnd() < GetContentEnd()) {
8514:     gfxSkipCharsIterator end = trimmedEndIter;
4678:     PRUint32 endOffset = end.ConvertOriginalToSkipped(GetContentOffset() + contentLength);
   8:     if (trimmedEnd < endOffset) {
1732:       // We can't be dealing with tabs here ... they wouldn't be trimmed. So it's
1732:       // OK to pass null for the line container.
4678:       PropertyProvider provider(mTextRun, textStyle, frag, this, start, contentLength,
1732:                                 nsnull, 0);
   8:       delta = mTextRun->GetAdvanceWidth(trimmedEnd, endOffset - trimmedEnd, &provider);
   1:       // non-compressed whitespace being skipped at end of line -> justifiable
   1:       // XXX should we actually *count* justifiable characters that should be
   8:       // removed from the overall count? I think so...
8514:       result.mLastCharIsJustifiable = PR_TRUE;
8514:       result.mChanged = PR_TRUE;
8514:     }
8514:   }
8514: 
8514:   if (trimmed.GetEnd() == GetContentEnd() &&
8514:       HasSoftHyphenBefore(frag, mTextRun, trimmed.mStart, trimmedEndIter)) {
8514:     // This is a soft hyphen break.
8514:     // Fix up metrics to include hyphen
8514:     result.mChanged = PR_TRUE;
8514:     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, ctx, this));
8514:     if (hyphenTextRun.get()) {
8514:       delta = -hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull);
8514:     }
8514:     AddStateBits(TEXT_HYPHEN_BREAK);
8514:   }
8514: 
8514:   if (!result.mLastCharIsJustifiable &&
   1:       NS_STYLE_TEXT_ALIGN_JUSTIFY == textStyle->mTextAlign) {
   1:     // Check if any character in the last cluster is justifiable
4678:     PropertyProvider provider(mTextRun, textStyle, frag, this, start, contentLength,
1732:                               nsnull, 0);
   1:     PRBool isCJK = IsChineseJapaneseLangGroup(this);
8514:     gfxSkipCharsIterator justificationStart(start), justificationEnd(trimmedEndIter);
7076:     provider.FindJustificationRange(&justificationStart, &justificationEnd);
   1: 
   1:     PRInt32 i;
4261:     for (i = justificationEnd.GetOriginalOffset(); i < trimmed.GetEnd(); ++i) {
   1:       if (IsJustifiableCharacter(frag, i, isCJK)) {
8514:         result.mLastCharIsJustifiable = PR_TRUE;
   1:       }
   1:     }
   1:   }
   1: 
   1:   gfxFloat advanceDelta;
   1:   mTextRun->SetLineBreaks(trimmedStart, trimmedEnd - trimmedStart,
   1:                           (GetStateBits() & TEXT_START_OF_LINE) != 0, PR_TRUE,
2834:                           &advanceDelta, ctx);
8514:   if (advanceDelta != 0) {
8514:     result.mChanged = PR_TRUE;
8514:   }
   1: 
   1:   // aDeltaWidth is *subtracted* from our width.
   1:   // If advanceDelta is positive then setting the line break made us longer,
   1:   // so aDeltaWidth could go negative.
8514:   result.mDeltaWidth = NSToCoordFloor(delta - advanceDelta);
8514:   // If aDeltaWidth goes negative, that means this frame might not actually fit
8514:   // anymore!!! We need higher level line layout to recover somehow.
8514:   // If it's because the frame has a soft hyphen that is now being displayed,
8514:   // this should actually be OK, because our reflow recorded the break
8514:   // opportunity that allowed the soft hyphen to be used, and we wouldn't
8514:   // have recorded the opportunity unless the hyphen fit (or was the first
8514:   // opportunity on the line).
8514:   // Otherwise this can/ really only happen when we have glyphs with special
8514:   // shapes at the end of lines, I think. Breaking inside a kerning pair won't
8514:   // do it because that would mean we broke inside this textrun, and
8514:   // BreakAndMeasureText should make sure the resulting shaped substring fits.
8514:   // Maybe if we passed a maxTextLength? But that only happens at direction
8514:   // changes (so we wouldn't kern across the boundary) or for first-letter
8514:   // (which always fits because it starts the line!).
8514:   NS_WARN_IF_FALSE(result.mDeltaWidth >= 0 || (GetStateBits() & TEXT_HYPHEN_BREAK),
8514:                    "Negative deltawidth in a non-hyphen case, something odd is happening");
   1: 
   1: #ifdef NOISY_TRIM
   1:   ListTag(stdout);
8514:   printf(": trim => %d\n", result.mDeltaWidth);
   1: #endif
8514:   return result;
   1: }
   1: 
6247: nsRect
6247: nsTextFrame::RecomputeOverflowRect()
6247: {
6247:   gfxSkipCharsIterator iter = EnsureTextRun();
6247:   if (!mTextRun)
6247:     return nsRect(nsPoint(0,0), GetSize());
6247: 
6247:   PropertyProvider provider(this, iter);
6247:   provider.InitializeForDisplay(PR_TRUE);
6247: 
6247:   gfxTextRun::Metrics textMetrics =
6247:     mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
6247:                           ComputeTransformedLength(provider), PR_FALSE, nsnull,
6247:                           &provider);
6247: 
6247:   nsRect boundingBox =
6247:     ConvertGfxRectOutward(textMetrics.mBoundingBox + gfxPoint(0, textMetrics.mAscent));
6247:   boundingBox.UnionRect(boundingBox,
6247:                         nsRect(nsPoint(0,0), GetSize()));
6247:   return boundingBox;
6247: }
6247: 
4261: static PRUnichar TransformChar(const nsStyleText* aStyle, gfxTextRun* aTextRun,
4261:                                PRUint32 aSkippedOffset, PRUnichar aChar)
4261: {
4261:   if (aChar == '\n' || aChar == '\r') {
4261:     return aStyle->WhiteSpaceIsSignificant() ? aChar : ' ';
4261:   }
4261:   switch (aStyle->mTextTransform) {
4261:   case NS_STYLE_TEXT_TRANSFORM_LOWERCASE:
4261:     nsContentUtils::GetCaseConv()->ToLower(aChar, &aChar);
4261:     break;
4261:   case NS_STYLE_TEXT_TRANSFORM_UPPERCASE:
4261:     nsContentUtils::GetCaseConv()->ToUpper(aChar, &aChar);
4261:     break;
4261:   case NS_STYLE_TEXT_TRANSFORM_CAPITALIZE:
4261:     if (aTextRun->CanBreakLineBefore(aSkippedOffset)) {
4261:       nsContentUtils::GetCaseConv()->ToTitle(aChar, &aChar);
4261:     }
4261:     break;
4261:   }
4261: 
4261:   return aChar;
4261: }
4261: 
4261: nsresult nsTextFrame::GetRenderedText(nsAString* aAppendToString,
4261:                                       gfxSkipChars* aSkipChars,
4261:                                       gfxSkipCharsIterator* aSkipIter,
4261:                                       PRUint32 aSkippedStartOffset,
4261:                                       PRUint32 aSkippedMaxLength)
4261: {
4261:   // The handling of aSkippedStartOffset and aSkippedMaxLength could be more efficient...
4261:   gfxSkipCharsBuilder skipCharsBuilder;
4261:   nsTextFrame* textFrame;
4261:   const nsTextFragment* textFrag = mContent->GetText();
4678:   PRUint32 keptCharsLength = 0;
4678:   PRUint32 validCharsLength = 0;
4261: 
4261:   // Build skipChars and copy text, for each text frame in this continuation block
4261:   for (textFrame = this; textFrame;
4261:        textFrame = static_cast<nsTextFrame*>(textFrame->GetNextContinuation())) {
4261:     // For each text frame continuation in this block ...
4261: 
4261:     // Ensure the text run and grab the gfxSkipCharsIterator for it
4261:     gfxSkipCharsIterator iter = textFrame->EnsureTextRun();
4261:     if (!textFrame->mTextRun)
4261:       return NS_ERROR_FAILURE;
4261: 
4261:     // Skip to the start of the text run, past ignored chars at start of line
4261:     // XXX In the future we may decide to trim extra spaces before a hard line
4261:     // break, in which case we need to accurately detect those sitations and 
4261:     // call GetTrimmedOffsets() with PR_TRUE to trim whitespace at the line's end
4261:     TrimmedOffsets trimmedContentOffsets = textFrame->GetTrimmedOffsets(textFrag, PR_FALSE);
4261:     PRInt32 startOfLineSkipChars = trimmedContentOffsets.mStart - textFrame->mContentOffset;
4261:     if (startOfLineSkipChars > 0) {
4261:       skipCharsBuilder.SkipChars(startOfLineSkipChars);
4261:       iter.SetOriginalOffset(trimmedContentOffsets.mStart);
4261:     }
4261: 
4261:     // Keep and copy the appropriate chars withing the caller's requested range
4261:     const nsStyleText* textStyle = textFrame->GetStyleText();
4261:     while (iter.GetOriginalOffset() < trimmedContentOffsets.GetEnd() &&
4261:            keptCharsLength < aSkippedMaxLength) {
4261:       // For each original char from content text
4261:       if (iter.IsOriginalCharSkipped() || ++validCharsLength <= aSkippedStartOffset) {
4261:         skipCharsBuilder.SkipChar();
4261:       } else {
4261:         ++keptCharsLength;
4261:         skipCharsBuilder.KeepChar();
4261:         if (aAppendToString) {
4261:           aAppendToString->Append(
4261:               TransformChar(textStyle, textFrame->mTextRun, iter.GetSkippedOffset(),
4261:                             textFrag->CharAt(iter.GetOriginalOffset())));
4261:         }
4261:       }
4261:       iter.AdvanceOriginal(1);
4261:     }
4261:     if (keptCharsLength >= aSkippedMaxLength) {
4261:       break; // Already past the end, don't build string or gfxSkipCharsIter anymore
4261:     }
4261:   }
4261:   
4261:   if (aSkipChars) {
4261:     aSkipChars->TakeFrom(&skipCharsBuilder); // Copy skipChars into aSkipChars
4261:     if (aSkipIter) {
4261:       // Caller must provide both pointers in order to retrieve a gfxSkipCharsIterator,
4261:       // because the gfxSkipCharsIterator holds a weak pointer to the gfxSkipCars.
4261:       *aSkipIter = gfxSkipCharsIterator(*aSkipChars, GetContentLength());
4261:     }
4261:   }
4261: 
4261:   return NS_OK;
4261: }
4261: 
   1: #ifdef DEBUG
   1: // Translate the mapped content into a string that's printable
   1: void
8252: nsTextFrame::ToCString(nsCString& aBuf, PRInt32* aTotalContentLength) const
   1: {
   1:   // Get the frames text content
   1:   const nsTextFragment* frag = mContent->GetText();
   1:   if (!frag) {
   1:     return;
   1:   }
   1: 
   1:   // Compute the total length of the text content.
   1:   *aTotalContentLength = frag->GetLength();
   1: 
4678:   PRInt32 contentLength = GetContentLength();
   1:   // Set current fragment and current fragment offset
4678:   if (0 == contentLength) {
   1:     return;
   1:   }
4678:   PRInt32 fragOffset = GetContentOffset();
4678:   PRInt32 n = fragOffset + contentLength;
   1:   while (fragOffset < n) {
   1:     PRUnichar ch = frag->CharAt(fragOffset++);
   1:     if (ch == '\r') {
   1:       aBuf.AppendLiteral("\\r");
   1:     } else if (ch == '\n') {
   1:       aBuf.AppendLiteral("\\n");
   1:     } else if (ch == '\t') {
   1:       aBuf.AppendLiteral("\\t");
   1:     } else if ((ch < ' ') || (ch >= 127)) {
8252:       aBuf.Append(nsPrintfCString("\\u%04x", ch));
   1:     } else {
   1:       aBuf.Append(ch);
   1:     }
   1:   }
   1: }
   1: #endif
   1: 
   1: nsIAtom*
   1: nsTextFrame::GetType() const
   1: {
   1:   return nsGkAtoms::textFrame;
   1: } 
   1: 
   1: /* virtual */ PRBool
   1: nsTextFrame::IsEmpty()
   1: {
   1:   NS_ASSERTION(!(mState & TEXT_IS_ONLY_WHITESPACE) ||
   1:                !(mState & TEXT_ISNOT_ONLY_WHITESPACE),
   1:                "Invalid state");
   1:   
   1:   // XXXldb Should this check compatibility mode as well???
   1:   if (GetStyleText()->WhiteSpaceIsSignificant()) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   if (mState & TEXT_ISNOT_ONLY_WHITESPACE) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   if (mState & TEXT_IS_ONLY_WHITESPACE) {
   1:     return PR_TRUE;
   1:   }
   1:   
   1:   PRBool isEmpty = mContent->TextIsOnlyWhitespace();
   1:   mState |= (isEmpty ? TEXT_IS_ONLY_WHITESPACE : TEXT_ISNOT_ONLY_WHITESPACE);
   1:   return isEmpty;
   1: }
   1: 
   1: #ifdef DEBUG
   1: NS_IMETHODIMP
   1: nsTextFrame::GetFrameName(nsAString& aResult) const
   1: {
   1:   return MakeFrameName(NS_LITERAL_STRING("Text"), aResult);
   1: }
   1: 
   1: NS_IMETHODIMP_(nsFrameState)
   1: nsTextFrame::GetDebugStateBits() const
   1: {
   1:   // mask out our emptystate flags; those are just caches
   1:   return nsFrame::GetDebugStateBits() &
   1:     ~(TEXT_WHITESPACE_FLAGS | TEXT_REFLOW_FLAGS);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTextFrame::List(FILE* out, PRInt32 aIndent) const
   1: {
   1:   // Output the tag
   1:   IndentBy(out, aIndent);
   1:   ListTag(out);
   1: #ifdef DEBUG_waterson
   1:   fprintf(out, " [parent=%p]", mParent);
   1: #endif
   1:   if (HasView()) {
3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
   1:   }
   1: 
   1:   PRInt32 totalContentLength;
8252:   nsCAutoString tmp;
   1:   ToCString(tmp, &totalContentLength);
   1: 
   1:   // Output the first/last content offset and prev/next in flow info
3118:   PRBool isComplete = GetContentEnd() == totalContentLength;
   1:   fprintf(out, "[%d,%d,%c] ", 
4678:           GetContentOffset(), GetContentLength(),
   1:           isComplete ? 'T':'F');
   1:   
   1:   if (nsnull != mNextSibling) {
3233:     fprintf(out, " next=%p", static_cast<void*>(mNextSibling));
   1:   }
   1:   nsIFrame* prevContinuation = GetPrevContinuation();
   1:   if (nsnull != prevContinuation) {
3233:     fprintf(out, " prev-continuation=%p", static_cast<void*>(prevContinuation));
   1:   }
   1:   if (nsnull != mNextContinuation) {
3233:     fprintf(out, " next-continuation=%p", static_cast<void*>(mNextContinuation));
   1:   }
   1: 
   1:   // Output the rect and state
   1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
   1:   if (0 != mState) {
   1:     if (mState & NS_FRAME_SELECTED_CONTENT) {
   1:       fprintf(out, " [state=%08x] SELECTED", mState);
   1:     } else {
   1:       fprintf(out, " [state=%08x]", mState);
   1:     }
   1:   }
3233:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
6247:   nsRect* overflowArea = const_cast<nsTextFrame*>(this)->GetOverflowAreaProperty(PR_FALSE);
6247:   if (overflowArea) {
6247:     fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea->x, overflowArea->y,
6247:             overflowArea->width, overflowArea->height);
6247:   }
3233:   fprintf(out, " sc=%p", static_cast<void*>(mStyleContext));
   1:   nsIAtom* pseudoTag = mStyleContext->GetPseudoType();
   1:   if (pseudoTag) {
   1:     nsAutoString atomString;
   1:     pseudoTag->ToString(atomString);
   1:     fprintf(out, " pst=%s",
   1:             NS_LossyConvertUTF16toASCII(atomString).get());
   1:   }
   1:   fputs("<\n", out);
   1: 
   1:   // Output the text
   1:   aIndent++;
   1: 
   1:   IndentBy(out, aIndent);
   1:   fputs("\"", out);
8252:   fputs(tmp.get(), out);
   1:   fputs("\"\n", out);
   1: 
   1:   aIndent--;
   1:   IndentBy(out, aIndent);
   1:   fputs(">\n", out);
   1: 
   1:   return NS_OK;
   1: }
   1: #endif
   1: 
   1: void nsTextFrame::AdjustSelectionPointsForBidi(SelectionDetails *sdptr,
   1:                                                PRInt32 textLength,
   1:                                                PRBool isRTLChars,
   1:                                                PRBool isOddLevel,
   1:                                                PRBool isBidiSystem)
   1: {
   1:   /* This adjustment is required whenever the text has been reversed by
   1:    * Mozilla before rendering.
   1:    *
   1:    * In theory this means any text whose Bidi embedding level has been
   1:    * set by the Unicode Bidi algorithm to an odd value, but this is
   1:    * only true in practice on a non-Bidi platform.
   1:    * 
   1:    * On a Bidi platform the situation is more complicated because the
   1:    * platform will automatically reverse right-to-left characters; so
   1:    * Mozilla reverses text whose natural directionality is the opposite
   1:    * of its embedding level: right-to-left characters whose Bidi
   1:    * embedding level is even (e.g. Visual Hebrew) or left-to-right and
   1:    * neutral characters whose Bidi embedding level is odd (e.g. English
   1:    * text with <bdo dir="rtl">).
   1:    *
   1:    * The following condition is accordingly an optimization of
   1:    *  if ( (!isBidiSystem && isOddLevel) ||
   1:    *       (isBidiSystem &&
   1:    *        ((isRTLChars && !isOddLevel) ||
   1:    *         (!isRTLChars && isOddLevel))))
   1:    */
   1:   if (isOddLevel ^ (isRTLChars && isBidiSystem)) {
   1: 
   1:     PRInt32 swap  = sdptr->mStart;
   1:     sdptr->mStart = textLength - sdptr->mEnd;
   1:     sdptr->mEnd   = textLength - swap;
   1: 
   1:     // temp fix for 75026 crasher until we fix the bidi code
   1:     // the above bidi code cause mStart < 0 in some case
   1:     // the problem is we have whitespace compression code in 
   1:     // nsTextTransformer which cause mEnd > textLength
   1:     NS_ASSERTION((sdptr->mStart >= 0) , "mStart >= 0");
   1:     if(sdptr->mStart < 0 )
   1:       sdptr->mStart = 0;
   1: 
   1:     NS_ASSERTION((sdptr->mEnd >= 0) , "mEnd >= 0");
   1:     if(sdptr->mEnd < 0 )
   1:       sdptr->mEnd = 0;
   1: 
   1:     NS_ASSERTION((sdptr->mStart <= sdptr->mEnd), "mStart <= mEnd");
   1:     if(sdptr->mStart > sdptr->mEnd)
   1:       sdptr->mEnd = sdptr->mStart;
   1:   }
   1:   
   1:   return;
   1: }
   1: 
   1: void
   1: nsTextFrame::AdjustOffsetsForBidi(PRInt32 aStart, PRInt32 aEnd)
   1: {
   1:   AddStateBits(NS_FRAME_IS_BIDI);
4678: 
5307:   /*
5307:    * After Bidi resolution we may need to reassign text runs.
5307:    * This is called during bidi resolution from the block container, so we
5307:    * shouldn't be holding a local reference to a textrun anywhere.
5307:    */
5307:   ClearTextRun();
5307: 
6383:   nsTextFrame* prev = static_cast<nsTextFrame*>(GetPrevContinuation());
4678:   if (prev) {
4678:     // the bidi resolver can be very evil when columns/pages are involved. Don't
4678:     // let it violate our invariants.
4678:     PRInt32 prevOffset = prev->GetContentOffset();
4678:     aStart = PR_MAX(aStart, prevOffset);
4678:     aEnd = PR_MAX(aEnd, prevOffset);
5307:     prev->ClearTextRun();
4678:   }
9735:   if (mContentOffset != aStart) {
4678:     mContentOffset = aStart;
9735:   }
9735: 
4678:   SetLength(aEnd - aStart);
   1: }
   1: 
   1: /**
   1:  * @return PR_TRUE if this text frame ends with a newline character.  It should return
   1:  * PR_FALSE if it is not a text frame.
   1:  */
   1: PRBool
   1: nsTextFrame::HasTerminalNewline() const
   1: {
3009:   return ::HasTerminalNewline(this);
3009: }
7677: 
7677: PRBool
7677: nsTextFrame::IsAtEndOfLine() const
7677: {
7677:   return (GetStateBits() & TEXT_END_OF_LINE) != 0;
7677: }
