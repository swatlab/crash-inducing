 3863: // Copyright (c) 2006, Google Inc.
 3863: // All rights reserved.
 3863: //
 3863: // Redistribution and use in source and binary forms, with or without
 3863: // modification, are permitted provided that the following conditions are
 3863: // met:
 3863: //
 3863: //     * Redistributions of source code must retain the above copyright
 3863: // notice, this list of conditions and the following disclaimer.
 3863: //     * Redistributions in binary form must reproduce the above
 3863: // copyright notice, this list of conditions and the following disclaimer
 3863: // in the documentation and/or other materials provided with the
 3863: // distribution.
 3863: //     * Neither the name of Google Inc. nor the names of its
 3863: // contributors may be used to endorse or promote products derived from
 3863: // this software without specific prior written permission.
 3863: //
 3863: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 3863: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 3863: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 3863: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 3863: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 3863: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 3863: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 3863: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 3863: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 3863: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 3863: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 3863: 
 3863: // ExceptionHandler can write a minidump file when an exception occurs,
 3863: // or when WriteMinidump() is called explicitly by your program.
 3863: //
 3863: // To have the exception handler write minidumps when an uncaught exception
 3863: // (crash) occurs, you should create an instance early in the execution
 3863: // of your program, and keep it around for the entire time you want to
 3863: // have crash handling active (typically, until shutdown).
 3863: //
 3863: // If you want to write minidumps without installing the exception handler,
 3863: // you can create an ExceptionHandler with install_handler set to false,
 3863: // then call WriteMinidump.  You can also use this technique if you want to
 3863: // use different minidump callbacks for different call sites.
 3863: //
 3863: // In either case, a callback function is called when a minidump is written,
 3863: // which receives the unqiue id of the minidump.  The caller can use this
 3863: // id to collect and write additional application state, and to launch an
 3863: // external crash-reporting application.
 3863: //
 3863: // It is important that creation and destruction of ExceptionHandler objects
 3863: // be nested cleanly, when using install_handler = true.
 3863: // Avoid the following pattern:
 3863: //   ExceptionHandler *e = new ExceptionHandler(...);
 3863: //   ExceptionHandler *f = new ExceptionHandler(...);
 3863: //   delete e;
 3863: // This will put the exception filter stack into an inconsistent state.
 3863: 
 3863: #ifndef CLIENT_WINDOWS_HANDLER_EXCEPTION_HANDLER_H__
 3863: #define CLIENT_WINDOWS_HANDLER_EXCEPTION_HANDLER_H__
 3863: 
 3869: #include <stdlib.h>
 3863: #include <Windows.h>
 3863: #include <DbgHelp.h>
12202: #include <rpc.h>
 3863: 
 3863: #pragma warning( push )
 3868: // Disable exception handler warnings.
 3863: #pragma warning( disable : 4530 )
 3868: 
 3863: #include <string>
 3869: #include <vector>
73558: #include <list>
 3863: 
22509: #include "client/windows/common/ipc_protocol.h"
22509: #include "client/windows/crash_generation/crash_generation_client.h"
 3869: #include "google_breakpad/common/minidump_format.h"
22509: #include "processor/scoped_ptr.h"
 3863: 
 3869: namespace google_breakpad {
 3869: 
 3869: using std::vector;
 3863: using std::wstring;
 3863: 
73558: // These entries store a list of memory regions that the client wants included
73558: // in the minidump.
73558: struct AppMemory {
73558:   AppMemory(ULONG64 ptr, ULONG length) : ptr(ptr), length(length) {}
73558: 
73558:   ULONG64 ptr;
73558:   ULONG length;
73558: };
73558: typedef std::list<AppMemory> AppMemoryList;
73558: 
 3863: class ExceptionHandler {
 3863:  public:
 3869:   // A callback function to run before Breakpad performs any substantial
 3869:   // processing of an exception.  A FilterCallback is called before writing
 3869:   // a minidump.  context is the parameter supplied by the user as
 3869:   // callback_context when the handler was created.  exinfo points to the
 3869:   // exception record, if any; assertion points to assertion information,
 3869:   // if any.
 3869:   //
 3869:   // If a FilterCallback returns true, Breakpad will continue processing,
 3869:   // attempting to write a minidump.  If a FilterCallback returns false, Breakpad
 3869:   // will immediately report the exception as unhandled without writing a
 3869:   // minidump, allowing another handler the opportunity to handle it.
 3869:   typedef bool (*FilterCallback)(void* context, EXCEPTION_POINTERS* exinfo,
 3869:                                  MDRawAssertionInfo* assertion);
 3869: 
 3863:   // A callback function to run after the minidump has been written.
 3863:   // minidump_id is a unique id for the dump, so the minidump
 3869:   // file is <dump_path>\<minidump_id>.dmp.  context is the parameter supplied
 3869:   // by the user as callback_context when the handler was created.  exinfo
 3869:   // points to the exception record, or NULL if no exception occurred.
 3869:   // succeeded indicates whether a minidump file was successfully written.
 3869:   // assertion points to information about an assertion if the handler was
 3869:   // invoked by an assertion.
 3869:   //
 3869:   // If an exception occurred and the callback returns true, Breakpad will treat
 3869:   // the exception as fully-handled, suppressing any other handlers from being
 3869:   // notified of the exception.  If the callback returns false, Breakpad will
 3869:   // treat the exception as unhandled, and allow another handler to handle it.
 3869:   // If there are no other handlers, Breakpad will report the exception to the
 3869:   // system as unhandled, allowing a debugger or native crash dialog the
 3869:   // opportunity to handle the exception.  Most callback implementations
 3869:   // should normally return the value of |succeeded|, or when they wish to
 3869:   // not report an exception of handled, false.  Callbacks will rarely want to
 3869:   // return true directly (unless |succeeded| is true).
22509:   //
22509:   // For out-of-process dump generation, dump path and minidump ID will always
22509:   // be NULL. In case of out-of-process dump generation, the dump path and
22509:   // minidump id are controlled by the server process and are not communicated
22509:   // back to the crashing process.
 3869:   typedef bool (*MinidumpCallback)(const wchar_t* dump_path,
 3869:                                    const wchar_t* minidump_id,
 3869:                                    void* context,
 3869:                                    EXCEPTION_POINTERS* exinfo,
 3869:                                    MDRawAssertionInfo* assertion,
 3869:                                    bool succeeded);
 3863: 
 3915:   // HandlerType specifies which types of handlers should be installed, if
 3915:   // any.  Use HANDLER_NONE for an ExceptionHandler that remains idle,
 3915:   // without catching any failures on its own.  This type of handler may
 3915:   // still be triggered by calling WriteMinidump.  Otherwise, use a
 3915:   // combination of the other HANDLER_ values, or HANDLER_ALL to install
 3915:   // all handlers.
 3915:   enum HandlerType {
 3915:     HANDLER_NONE = 0,
 3915:     HANDLER_EXCEPTION = 1 << 0,          // SetUnhandledExceptionFilter
 3915:     HANDLER_INVALID_PARAMETER = 1 << 1,  // _set_invalid_parameter_handler
 3915:     HANDLER_PURECALL = 1 << 2,           // _set_purecall_handler
 3915:     HANDLER_ALL = HANDLER_EXCEPTION |
 3915:                   HANDLER_INVALID_PARAMETER |
 3915:                   HANDLER_PURECALL
 3915:   };
 3915: 
 3863:   // Creates a new ExceptionHandler instance to handle writing minidumps.
 3869:   // Before writing a minidump, the optional filter callback will be called.
 3915:   // Its return value determines whether or not Breakpad should write a
 3915:   // minidump.  Minidump files will be written to dump_path, and the optional
 3915:   // callback is called after writing the dump file, as described above.
 3915:   // handler_types specifies the types of handlers that should be installed.
 3869:   ExceptionHandler(const wstring& dump_path,
 3915:                    FilterCallback filter,
 3915:                    MinidumpCallback callback,
 3915:                    void* callback_context,
 3915:                    int handler_types);
22509: 
22509:   // Creates a new ExcetpionHandler instance that can attempt to perform
22509:   // out-of-process dump generation if pipe_name is not NULL. If pipe_name is
22509:   // NULL, or if out-of-process dump generation registration step fails,
22509:   // in-process dump generation will be used. This also allows specifying
22509:   // the dump type to generate.
22509:   ExceptionHandler(const wstring& dump_path,
22509:                    FilterCallback filter,
22509:                    MinidumpCallback callback,
22509:                    void* callback_context,
22509:                    int handler_types,
22509:                    MINIDUMP_TYPE dump_type,
22509:                    const wchar_t* pipe_name,
22509:                    const CustomClientInfo* custom_info);
22509: 
 3863:   ~ExceptionHandler();
 3863: 
 3868:   // Get and set the minidump path.
 3863:   wstring dump_path() const { return dump_path_; }
 3869:   void set_dump_path(const wstring &dump_path) {
 3869:     dump_path_ = dump_path;
 3869:     dump_path_c_ = dump_path_.c_str();
 3869:     UpdateNextID();  // Necessary to put dump_path_ in next_minidump_path_.
 3869:   }
 3863: 
 3863:   // Writes a minidump immediately.  This can be used to capture the
 3863:   // execution state independently of a crash.  Returns true on success.
 3863:   bool WriteMinidump();
 3863: 
 3915:   // Writes a minidump immediately, with the user-supplied exception
 3915:   // information.
 3915:   bool WriteMinidumpForException(EXCEPTION_POINTERS* exinfo);
 3915: 
 3863:   // Convenience form of WriteMinidump which does not require an
 3863:   // ExceptionHandler instance.
 3863:   static bool WriteMinidump(const wstring &dump_path,
 3863:                             MinidumpCallback callback, void* callback_context);
 3863: 
40025:   // Variant of WriteMinidump() above that optionally allows writing
40025:   // an artificial exception stream in the minidump.
40025:   static bool WriteMinidump(const wstring &dump_path,
40025:                             bool write_exception_stream,
40025:                             MinidumpCallback callback, void* callback_context);
40025: 
39790:   // Write a minidump of |child| immediately.  This can be used to
39790:   // capture the execution state of |child| independently of a crash.
40023:   // Pass a meaningful |child_blamed_thread| to make that thread in
40023:   // the child process the one from which a crash signature is
40023:   // extracted.
39790:   static bool WriteMinidumpForChild(HANDLE child,
40023:                                     DWORD child_blamed_thread,
39790:                                     const wstring &dump_path,
39790:                                     MinidumpCallback callback,
39790:                                     void *callback_context);
39790: 
 7079:   // Get the thread ID of the thread requesting the dump (either the exception
 7079:   // thread or any other thread that called WriteMinidump directly).  This
 7079:   // may be useful if you want to include additional thread state in your
 7079:   // dumps.
 7079:   DWORD get_requesting_thread_id() const { return requesting_thread_id_; }
 7079: 
 8662:   // Controls behavior of EXCEPTION_BREAKPOINT and EXCEPTION_SINGLE_STEP.
 8662:   bool get_handle_debug_exceptions() const { return handle_debug_exceptions_; }
 8662:   void set_handle_debug_exceptions(bool handle_debug_exceptions) {
 8662:     handle_debug_exceptions_ = handle_debug_exceptions;
 8662:   }
 8662: 
22509:   // Returns whether out-of-process dump generation is used or not.
22509:   bool IsOutOfProcess() const { return crash_generation_client_.get() != NULL; }
22509: 
73558:   // Calling RegisterAppMemory(p, len) causes len bytes starting
73558:   // at address p to be copied to the minidump when a crash happens.
73558:   void RegisterAppMemory(void *ptr, size_t length);
73558:   void UnregisterAppMemory(void *ptr);
73558: 
97427:   // Called on the exception thread when an unhandled exception occurs.
97427:   // Signals the exception handler thread to handle the exception.
97427:   static LONG WINAPI HandleException(EXCEPTION_POINTERS* exinfo);
97427: 
 3863:  private:
 3869:   friend class AutoExceptionHandler;
 3869: 
22509:   // Initializes the instance with given values.
22509:   void Initialize(const wstring& dump_path,
22509:                   FilterCallback filter,
22509:                   MinidumpCallback callback,
22509:                   void* callback_context,
22509:                   int handler_types,
22509:                   MINIDUMP_TYPE dump_type,
22509:                   const wchar_t* pipe_name,
22509:                   const CustomClientInfo* custom_info);
22509: 
 3863:   // Function pointer type for MiniDumpWriteDump, which is looked up
 3863:   // dynamically.
 3863:   typedef BOOL (WINAPI *MiniDumpWriteDump_type)(
 3863:       HANDLE hProcess,
 3863:       DWORD dwPid,
 3863:       HANDLE hFile,
 3863:       MINIDUMP_TYPE DumpType,
 3863:       CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
 3863:       CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
 3863:       CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam);
 3863: 
12202:   // Function pointer type for UuidCreate, which is looked up dynamically.
12202:   typedef RPC_STATUS (RPC_ENTRY *UuidCreate_type)(UUID* Uuid);
12202: 
 3868:   // Runs the main loop for the exception handler thread.
 3868:   static DWORD WINAPI ExceptionHandlerThreadMain(void* lpParameter);
 3863: 
 3869: #if _MSC_VER >= 1400  // MSVC 2005/8
 3869:   // This function will be called by some CRT functions when they detect
 3869:   // that they were passed an invalid parameter.  Note that in _DEBUG builds,
 3869:   // the CRT may display an assertion dialog before calling this function,
 3869:   // and the function will not be called unless the assertion dialog is
 3869:   // dismissed by clicking "Ignore."
 3869:   static void HandleInvalidParameter(const wchar_t* expression,
 3869:                                      const wchar_t* function,
 3869:                                      const wchar_t* file,
 3869:                                      unsigned int line,
 3869:                                      uintptr_t reserved);
 3869: #endif  // _MSC_VER >= 1400
 3869: 
 3897:   // This function will be called by the CRT when a pure virtual
 3897:   // function is called.
 3897:   static void HandlePureVirtualCall();
 3897: 
 3868:   // This is called on the exception thread or on another thread that
 3868:   // the user wishes to produce a dump from.  It calls
 3868:   // WriteMinidumpWithException on the handler thread, avoiding stack
 3868:   // overflows and inconsistent dumps due to writing the dump from
 3868:   // the exception thread.  If the dump is requested as a result of an
 3868:   // exception, exinfo contains exception information, otherwise, it
 3869:   // is NULL.  If the dump is requested as a result of an assertion
 3869:   // (such as an invalid parameter being passed to a CRT function),
 3869:   // assertion contains data about the assertion, otherwise, it is NULL.
 3869:   bool WriteMinidumpOnHandlerThread(EXCEPTION_POINTERS* exinfo,
 3869:                                     MDRawAssertionInfo* assertion);
 3868: 
39790:   // This function is called on the handler thread.  It calls into
39790:   // WriteMinidumpWithExceptionForProcess() with a handle to the
39790:   // current process.  requesting_thread_id is the ID of the thread
 3868:   // that requested the dump.  If the dump is requested as a result of
 3868:   // an exception, exinfo contains exception information, otherwise,
 3868:   // it is NULL.
 3868:   bool WriteMinidumpWithException(DWORD requesting_thread_id,
 3869:                                   EXCEPTION_POINTERS* exinfo,
 3869:                                   MDRawAssertionInfo* assertion);
 3868: 
61551:   // This function is used as a callback when calling MinidumpWriteDump,
61551:   // in order to add additional memory regions to the dump.
61551:   static BOOL CALLBACK MinidumpWriteDumpCallback(
61551:       PVOID context,
61551:       const PMINIDUMP_CALLBACK_INPUT callback_input,
61551:       PMINIDUMP_CALLBACK_OUTPUT callback_output);
61551: 
39790:   // This function does the actual writing of a minidump.  It is
39790:   // called on the handler thread.  requesting_thread_id is the ID of
39790:   // the thread that requested the dump, if that information is
39790:   // meaningful.  If the dump is requested as a result of an
39790:   // exception, exinfo contains exception information, otherwise, it
39790:   // is NULL.  process is the one that will be dumped.  If
39790:   // requesting_thread_id is meaningful and should be added to the
39790:   // minidump, write_requester_stream is |true|.
39790:   bool WriteMinidumpWithExceptionForProcess(DWORD requesting_thread_id,
39790:                                             EXCEPTION_POINTERS* exinfo,
39790:                                             MDRawAssertionInfo* assertion,
39790:                                             HANDLE process,
39790:                                             DWORD processId,
39790:                                             bool write_requester_stream);
39790: 
 3869:   // Generates a new ID and stores it in next_minidump_id_, and stores the
 3869:   // path of the next minidump to be written in next_minidump_path_.
 3863:   void UpdateNextID();
 3863: 
 3869:   FilterCallback filter_;
 3863:   MinidumpCallback callback_;
 3863:   void* callback_context_;
 3863: 
22509:   scoped_ptr<CrashGenerationClient> crash_generation_client_;
22509: 
 3869:   // The directory in which a minidump will be written, set by the dump_path
 3869:   // argument to the constructor, or set_dump_path.
 3863:   wstring dump_path_;
 3869: 
 3869:   // The basename of the next minidump to be written, without the extension.
 3863:   wstring next_minidump_id_;
 3863: 
 3869:   // The full pathname of the next minidump to be written, including the file
 3869:   // extension.
 3869:   wstring next_minidump_path_;
 3869: 
 3869:   // Pointers to C-string representations of the above.  These are set when
 3869:   // the above wstring versions are set in order to avoid calling c_str during
 3869:   // an exception, as c_str may attempt to allocate heap memory.  These
 3869:   // pointers are not owned by the ExceptionHandler object, but their lifetimes
 3869:   // should be equivalent to the lifetimes of the associated wstring, provided
 3869:   // that the wstrings are not altered.
 3869:   const wchar_t* dump_path_c_;
 3869:   const wchar_t* next_minidump_id_c_;
 3869:   const wchar_t* next_minidump_path_c_;
 3869: 
 3863:   HMODULE dbghelp_module_;
 3863:   MiniDumpWriteDump_type minidump_write_dump_;
22509:   MINIDUMP_TYPE dump_type_;
 3863: 
12202:   HMODULE rpcrt4_module_;
12202:   UuidCreate_type uuid_create_;
12202: 
 3915:   // Tracks the handler types that were installed according to the
 3915:   // handler_types constructor argument.
 3915:   int handler_types_;
 3869: 
 3869:   // When installed_handler_ is true, previous_filter_ is the unhandled
 3869:   // exception filter that was set prior to installing ExceptionHandler as
 3869:   // the unhandled exception filter and pointing it to |this|.  NULL indicates
 3869:   // that there is no previous unhandled exception filter.
 3863:   LPTOP_LEVEL_EXCEPTION_FILTER previous_filter_;
 3863: 
 3869: #if _MSC_VER >= 1400  // MSVC 2005/8
 3869:   // Beginning in VC 8, the CRT provides an invalid parameter handler that will
 3869:   // be called when some CRT functions are passed invalid parameters.  In
 3869:   // earlier CRTs, the same conditions would cause unexpected behavior or
 3869:   // crashes.
 3869:   _invalid_parameter_handler previous_iph_;
 3869: #endif  // _MSC_VER >= 1400
 3863: 
 3897:   // The CRT allows you to override the default handler for pure
 3897:   // virtual function calls.
 3897:   _purecall_handler previous_pch_;
 3897: 
 3869:   // The exception handler thread.
 3869:   HANDLE handler_thread_;
 3868: 
32241:   // True if the exception handler is being destroyed.
32241:   // Starting with MSVC 2005, Visual C has stronger guarantees on volatile vars.
32241:   // It has release semantics on write and acquire semantics on reads.
32241:   // See the msdn documentation.
32241:   volatile bool is_shutdown_;
32241: 
 3868:   // The critical section enforcing the requirement that only one exception be
 3869:   // handled by a handler at a time.
 3869:   CRITICAL_SECTION handler_critical_section_;
 3868: 
 3868:   // Semaphores used to move exception handling between the exception thread
 3868:   // and the handler thread.  handler_start_semaphore_ is signalled by the
 3868:   // exception thread to wake up the handler thread when an exception occurs.
 3868:   // handler_finish_semaphore_ is signalled by the handler thread to wake up
 3868:   // the exception thread when handling is complete.
 3869:   HANDLE handler_start_semaphore_;
 3869:   HANDLE handler_finish_semaphore_;
 3868: 
 3869:   // The next 2 fields contain data passed from the requesting thread to
 3868:   // the handler thread.
 3868: 
 3868:   // The thread ID of the thread requesting the dump (either the exception
 3868:   // thread or any other thread that called WriteMinidump directly).
 3869:   DWORD requesting_thread_id_;
 3868: 
 3868:   // The exception info passed to the exception handler on the exception
 3868:   // thread, if an exception occurred.  NULL for user-requested dumps.
 3869:   EXCEPTION_POINTERS* exception_info_;
 3869: 
 3869:   // If the handler is invoked due to an assertion, this will contain a
 3869:   // pointer to the assertion information.  It is NULL at other times.
 3869:   MDRawAssertionInfo* assertion_;
 3868: 
 3868:   // The return value of the handler, passed from the handler thread back to
 3868:   // the requesting thread.
 3869:   bool handler_return_value_;
 3869: 
 8662:   // If true, the handler will intercept EXCEPTION_BREAKPOINT and
 8662:   // EXCEPTION_SINGLE_STEP exceptions.  Leave this false (the default)
 8662:   // to not interfere with debuggers.
 8662:   bool handle_debug_exceptions_;
 8662: 
73558:   // Callers can request additional memory regions to be included in
73558:   // the dump.
73558:   AppMemoryList app_memory_info_;
73558: 
 3869:   // A stack of ExceptionHandler objects that have installed unhandled
 3869:   // exception filters.  This vector is used by HandleException to determine
 3869:   // which ExceptionHandler object to route an exception to.  When an
 3869:   // ExceptionHandler is created with install_handler true, it will append
 3869:   // itself to this list.
 3869:   static vector<ExceptionHandler*>* handler_stack_;
 3869: 
 3869:   // The index of the ExceptionHandler in handler_stack_ that will handle the
 3869:   // next exception.  Note that 0 means the last entry in handler_stack_, 1
 3869:   // means the next-to-last entry, and so on.  This is used by HandleException
 3869:   // to support multiple stacked Breakpad handlers.
 3869:   static LONG handler_stack_index_;
 3869: 
 3869:   // handler_stack_critical_section_ guards operations on handler_stack_ and
32241:   // handler_stack_index_. The critical section is initialized by the
32241:   // first instance of the class and destroyed by the last instance of it.
 3869:   static CRITICAL_SECTION handler_stack_critical_section_;
 3869: 
32241:   // The number of instances of this class.
32241:   volatile static LONG instance_count_;
 3868: 
 3863:   // disallow copy ctor and operator=
 3863:   explicit ExceptionHandler(const ExceptionHandler &);
 3863:   void operator=(const ExceptionHandler &);
 3863: };
 3863: 
 3869: }  // namespace google_breakpad
 3863: 
 3863: #pragma warning( pop )
 3868: 
 3863: #endif  // CLIENT_WINDOWS_HANDLER_EXCEPTION_HANDLER_H__
