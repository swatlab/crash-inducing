    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Masatoshi Kimura <VYV03354@nifty.ne.jp>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "gfxWindowsPlatform.h"
    1: 
    1: #include "gfxImageSurface.h"
    1: #include "gfxWindowsSurface.h"
    1: 
    1: #include "nsUnicharUtils.h"
    1: 
71640: #include "mozilla/Preferences.h"
    1: #include "nsServiceManagerUtils.h"
23904: #include "nsTArray.h"
    1: 
    1: #include "nsIWindowsRegKey.h"
19962: #include "nsILocalFile.h"
19962: #include "plbase64.h"
51658: #include "nsIXULRuntime.h"
    1: 
51736: #include "nsIGfxInfo.h"
51736: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
36949: #include "gfxGDIFontList.h"
39447: #include "gfxGDIFont.h"
71958: 
38782: #ifdef CAIRO_HAS_DWRITE_FONT
38727: #include "gfxDWriteFontList.h"
38727: #include "gfxDWriteFonts.h"
38727: #include "gfxDWriteCommon.h"
38727: #include <dwrite.h>
24104: #endif
24104: 
71986: #include "gfxUserFontSet.h"
71986: 
71986: #include <string>
71838: 
80467: using namespace mozilla;
72424: using namespace mozilla::gfx;
72424: 
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727: #include "gfxD2DSurface.h"
46438: 
50585: #include <d3d10_1.h>
75151: #include <dxgi.h>
50585: 
72424: #include "mozilla/gfx/2D.h"
72424: 
89828: #include "nsMemory.h"
89828: #endif
89828: 
89828: /**
89828:  * XXX below should be >= MOZ_NTDDI_WIN8 or such which is not defined yet
89828:  */
89828: #if MOZ_WINSDK_TARGETVER > MOZ_NTDDI_WIN7
89828: #define ENABLE_GPU_MEM_REPORTER
89828: #endif
89828: 
89828: #if defined CAIRO_HAS_D2D_SURFACE || defined ENABLE_GPU_MEM_REPORTER
46438: #include "nsIMemoryReporter.h"
89828: #endif
89828: 
89828: #ifdef ENABLE_GPU_MEM_REPORTER
89828: #include <winternl.h>
89828: 
89828: /**
89828:  * XXX need to check that extern C is really needed with Win8 SDK.
89828:  *     It was required for files I had available at push time.
89828:  */
89828: extern "C" {
89828: #include <d3dkmthk.h>
89828: }
71986: #endif
46438: 
71986: using namespace mozilla;
71986: 
71986: #ifdef CAIRO_HAS_D2D_SURFACE
72640: 
72640: NS_MEMORY_REPORTER_IMPLEMENT(
72640:     D2DCache,
72640:     "gfx-d2d-surfacecache",
72640:     KIND_OTHER,
72640:     UNITS_BYTES,
72640:     cairo_d2d_get_image_surface_cache_usage,
72640:     "Memory used by the Direct2D internal surface cache.")
72640: 
72640: namespace
46438: {
46438: 
72640: PRInt64 GetD2DSurfaceVramUsage() {
50875:   cairo_device_t *device =
50875:       gfxWindowsPlatform::GetPlatform()->GetD2DDevice();
50875:   if (device) {
72640:       return cairo_d2d_get_surface_vram_usage(device);
50875:   }
72640:   return 0;
50776: }
50776: 
72640: } // anonymous namespace
72640: 
72640: NS_MEMORY_REPORTER_IMPLEMENT(
72640:     D2DVram,
72640:     "gfx-d2d-surfacevram",
72640:     KIND_OTHER,
72640:     UNITS_BYTES,
72640:     GetD2DSurfaceVramUsage,
72640:     "Video memory used by D2D surfaces")
72640: 
38727: #endif
30086: 
42854: #define GFX_USE_CLEARTYPE_ALWAYS "gfx.font_rendering.cleartype.always_use_for_content"
42854: #define GFX_DOWNLOADABLE_FONTS_USE_CLEARTYPE "gfx.font_rendering.cleartype.use_for_downloadable_fonts"
42854: 
68738: #define GFX_CLEARTYPE_PARAMS           "gfx.font_rendering.cleartype_params."
68738: #define GFX_CLEARTYPE_PARAMS_GAMMA     "gfx.font_rendering.cleartype_params.gamma"
68738: #define GFX_CLEARTYPE_PARAMS_CONTRAST  "gfx.font_rendering.cleartype_params.enhanced_contrast"
68738: #define GFX_CLEARTYPE_PARAMS_LEVEL     "gfx.font_rendering.cleartype_params.cleartype_level"
68738: #define GFX_CLEARTYPE_PARAMS_STRUCTURE "gfx.font_rendering.cleartype_params.pixel_structure"
68738: #define GFX_CLEARTYPE_PARAMS_MODE      "gfx.font_rendering.cleartype_params.rendering_mode"
68738: 
38727: #ifdef CAIRO_HAS_DWRITE_FONT
38727: // DirectWrite is not available on all platforms, we need to use the function
38727: // pointer.
38727: typedef HRESULT (WINAPI*DWriteCreateFactoryFunc)(
81641:   DWRITE_FACTORY_TYPE factoryType,
81641:   REFIID iid,
81641:   IUnknown **factory
38727: );
38727: #endif
38727: 
50585: #ifdef CAIRO_HAS_D2D_SURFACE
50585: typedef HRESULT (WINAPI*D3D10CreateDevice1Func)(
50585:   IDXGIAdapter *pAdapter,
50585:   D3D10_DRIVER_TYPE DriverType,
50585:   HMODULE Software,
50585:   UINT Flags,
50585:   D3D10_FEATURE_LEVEL1 HardwareLevel,
50585:   UINT SDKVersion,
50585:   ID3D10Device1 **ppDevice
50585: );
75151: 
75151: typedef HRESULT(WINAPI*CreateDXGIFactory1Func)(
75151:   REFIID riid,
75151:   void **ppFactory
75151: );
50585: #endif
50585: 
89828: #ifdef ENABLE_GPU_MEM_REPORTER
89828: class GPUAdapterMultiReporter : public nsIMemoryMultiReporter {
89828: 
89828:     // Callers must Release the DXGIAdapter after use or risk mem-leak
89828:     static bool GetDXGIAdapter(__out IDXGIAdapter **DXGIAdapter)
89828:     {
89828:         ID3D10Device1 *D2D10Device;
89828:         IDXGIDevice *DXGIDevice;
89828:         bool result = false;
89828:         
89828:         if (D2D10Device = mozilla::gfx::Factory::GetDirect3D10Device()) {
89828:             if (D2D10Device->QueryInterface(__uuidof(IDXGIDevice), (void **)&DXGIDevice) == S_OK) {
89828:                 result = (DXGIDevice->GetAdapter(DXGIAdapter) == S_OK);
89828:                 DXGIDevice->Release();
89828:             }
89828:         }
89828:         
89828:         return result;
89828:     }
89828:     
89828: public:
89828:     NS_DECL_ISUPPORTS
89828:     
89828:     // nsIMemoryMultiReporter abstract method implementation
89828:     NS_IMETHOD
89828:     CollectReports(nsIMemoryMultiReporterCallback* aCb,
89828:                    nsISupports* aClosure)
89828:     {
89828:         PRInt32 winVers, buildNum;
89828:         HANDLE ProcessHandle = GetCurrentProcess();
89828:         
89828:         PRInt64 dedicatedBytesUsed = 0;
89828:         PRInt64 sharedBytesUsed = 0;
89828:         PRInt64 committedBytesUsed = 0;
89828:         IDXGIAdapter *DXGIAdapter;
89828:         
89828:         HMODULE gdi32Handle;
89828:         PFND3DKMT_QUERYSTATISTICS queryD3DKMTStatistics;
89828:         
89828:         winVers = gfxWindowsPlatform::WindowsOSVersion(&buildNum);
89828:         
89828:         // GPU memory reporting is not available before Windows 7
89828:         if (winVers < gfxWindowsPlatform::kWindows7) 
89828:             return NS_OK;
89828:         
89828:         if (gdi32Handle = LoadLibrary(TEXT("gdi32.dll")))
89828:             queryD3DKMTStatistics = (PFND3DKMT_QUERYSTATISTICS)GetProcAddress(gdi32Handle, "D3DKMTQueryStatistics");
89828:         
89828:         if (queryD3DKMTStatistics && GetDXGIAdapter(&DXGIAdapter)) {
89828:             // Most of this block is understood thanks to wj32's work on Process Hacker
89828:             
89828:             DXGI_ADAPTER_DESC adapterDesc;
89828:             D3DKMT_QUERYSTATISTICS queryStatistics;
89828:             
89828:             DXGIAdapter->GetDesc(&adapterDesc);
89828:             DXGIAdapter->Release();
89828:             
89828:             memset(&queryStatistics, 0, sizeof(D3DKMT_QUERYSTATISTICS));
89828:             queryStatistics.Type = D3DKMT_QUERYSTATISTICS_PROCESS;
89828:             queryStatistics.AdapterLuid = adapterDesc.AdapterLuid;
89828:             queryStatistics.hProcess = ProcessHandle;
89828:             if (NT_SUCCESS(queryD3DKMTStatistics(&queryStatistics))) {
89828:                 committedBytesUsed = queryStatistics.QueryResult.ProcessInformation.SystemMemory.BytesAllocated;
89828:             }
89828:             
89828:             memset(&queryStatistics, 0, sizeof(D3DKMT_QUERYSTATISTICS));
89828:             queryStatistics.Type = D3DKMT_QUERYSTATISTICS_ADAPTER;
89828:             queryStatistics.AdapterLuid = adapterDesc.AdapterLuid;
89828:             if (NT_SUCCESS(queryD3DKMTStatistics(&queryStatistics))) {
89828:                 ULONG i;
89828:                 ULONG segmentCount = queryStatistics.QueryResult.AdapterInformation.NbSegments;
89828:                 
89828:                 for (i = 0; i < segmentCount; i++) {
89828:                     memset(&queryStatistics, 0, sizeof(D3DKMT_QUERYSTATISTICS));
89828:                     queryStatistics.Type = D3DKMT_QUERYSTATISTICS_SEGMENT;
89828:                     queryStatistics.AdapterLuid = adapterDesc.AdapterLuid;
89828:                     queryStatistics.QuerySegment.SegmentId = i;
89828:                     
89828:                     if (NT_SUCCESS(queryD3DKMTStatistics(&queryStatistics))) {
89828:                         bool aperture;
89828:                         
89828:                         // SegmentInformation has a different definition in Win7 than later versions
89828:                         if (winVers > gfxWindowsPlatform::kWindows7)
89828:                             aperture = queryStatistics.QueryResult.SegmentInformation.Aperture;
89828:                         else
89828:                             aperture = queryStatistics.QueryResult.SegmentInformationV1.Aperture;
89828:                         
89828:                         memset(&queryStatistics, 0, sizeof(D3DKMT_QUERYSTATISTICS));
89828:                         queryStatistics.Type = D3DKMT_QUERYSTATISTICS_PROCESS_SEGMENT;
89828:                         queryStatistics.AdapterLuid = adapterDesc.AdapterLuid;
89828:                         queryStatistics.hProcess = ProcessHandle;
89828:                         queryStatistics.QueryProcessSegment.SegmentId = i;
89828:                         if (NT_SUCCESS(queryD3DKMTStatistics(&queryStatistics))) {
89828:                             if (aperture)
89828:                                 sharedBytesUsed += queryStatistics.QueryResult
89828:                                                                   .ProcessSegmentInformation
89828:                                                                   .BytesCommitted;
89828:                             else
89828:                                 dedicatedBytesUsed += queryStatistics.QueryResult
89828:                                                                      .ProcessSegmentInformation
89828:                                                                      .BytesCommitted;
89828:                         }
89828:                     }
89828:                 }
89828:             }
89828:         }
89828:         
89828:         FreeLibrary(gdi32Handle);
89828:         
91899: #define REPORT(_path, _amount, _desc)                                         \
91899:     do {                                                                      \
91899:       nsresult rv;                                                            \
91899:       rv = aCb->Callback(EmptyCString(), NS_LITERAL_CSTRING(_path),           \
91899:                          nsIMemoryReporter::KIND_OTHER,                       \
91899:                          nsIMemoryReporter::UNITS_BYTES, _amount,             \
91899:                          NS_LITERAL_CSTRING(_desc), aClosure);                \
91899:       NS_ENSURE_SUCCESS(rv, rv);                                              \
91899:     } while (0)
91899: 
91899:         REPORT("gpu-committed", committedBytesUsed,
91899:                "Memory committed by the Windows graphics system.");
91899: 
91899:         REPORT("gpu-dedicated", dedicatedBytesUsed,
91899:                "Out-of-process memory allocated for this process in a "
91899:                "physical GPU adapter's memory.");
91899: 
91899:         REPORT("gpu-shared", sharedBytesUsed,
91899:                "In-process memory that is shared with the GPU.");
91899:         
91899: #undef REPORT
89828: 
89828:         return NS_OK;
89828:     }
89828: 
89828:     // nsIMemoryMultiReporter abstract method implementation
89828:     NS_IMETHOD
89828:     GetExplicitNonHeap(PRInt64 *aExplicitNonHeap)
89828:     {
89828:         // This reporter doesn't do any non-heap measurements.
89828:         *aExplicitNonHeap = 0;
89828:         return NS_OK;
89828:     }
89828: };
89828: NS_IMPL_ISUPPORTS1(GPUAdapterMultiReporter, nsIMemoryMultiReporter)
89828: #endif // ENABLE_GPU_MEM_REPORTER
89828: 
13578: static __inline void
13578: BuildKeyNameFromFontName(nsAString &aName)
13578: {
13578:     if (aName.Length() >= LF_FACESIZE)
13578:         aName.Truncate(LF_FACESIZE - 1);
13578:     ToLowerCase(aName);
13578: }
13280: 
36949: gfxWindowsPlatform::gfxWindowsPlatform()
 5254: {
36949:     mPrefFonts.Init(50);
 5254: 
42854:     mUseClearTypeForDownloadableFonts = UNINITIALIZED_VALUE;
42854:     mUseClearTypeAlways = UNINITIALIZED_VALUE;
42854: 
80486:     mUsingGDIFonts = false;
57104: 
51527:     /* 
51527:      * Initialize COM 
51527:      */ 
51527:     CoInitialize(NULL); 
51527: 
51035:     mScreenDC = GetDC(NULL);
51035: 
53984: #ifdef CAIRO_HAS_D2D_SURFACE
72640:     NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(D2DCache));
72640:     NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(D2DVram));
53984:     mD2DDevice = nsnull;
53984: #endif
53984: 
53984:     UpdateRenderMode();
89828: 
89828: #ifdef ENABLE_GPU_MEM_REPORTER
89828:     mGPUAdapterMultiReporter = new GPUAdapterMultiReporter();
89828:     NS_RegisterMemoryMultiReporter(mGPUAdapterMultiReporter);
89828: #endif
53984: }
53984: 
53984: gfxWindowsPlatform::~gfxWindowsPlatform()
53984: {
89828: #ifdef ENABLE_GPU_MEM_REPORTER
89828:     NS_UnregisterMemoryMultiReporter(mGPUAdapterMultiReporter);
89828: #endif
89828:     
53984:     ::ReleaseDC(NULL, mScreenDC);
53984:     // not calling FT_Done_FreeType because cairo may still hold references to
53984:     // these FT_Faces.  See bug 458169.
53984: #ifdef CAIRO_HAS_D2D_SURFACE
53984:     if (mD2DDevice) {
53984:         cairo_release_device(mD2DDevice);
53984:     }
53984: #endif
53984: 
53984:     /* 
53984:      * Uninitialize COM 
53984:      */ 
53984:     CoUninitialize();
53984: }
53984: 
53984: void
53984: gfxWindowsPlatform::UpdateRenderMode()
53984: {
71589: /* Pick the default render mode for
71589:  * desktop.
30087:  */
30087:     mRenderMode = RENDER_GDI;
30087: 
50585:     OSVERSIONINFOA versionInfo;
50585:     versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
50585:     ::GetVersionExA(&versionInfo);
50585:     bool isVistaOrHigher = versionInfo.dwMajorVersion >= 6;
50585: 
79445:     bool safeMode = false;
51751:     nsCOMPtr<nsIXULRuntime> xr = do_GetService("@mozilla.org/xre/runtime;1");
51751:     if (xr)
51751:       xr->GetInSafeMode(&safeMode);
51751: 
79445:     mUseDirectWrite = Preferences::GetBool("gfx.font_rendering.directwrite.enabled", false);
53984: 
51736: #ifdef CAIRO_HAS_D2D_SURFACE
79445:     bool d2dDisabled = false;
79445:     bool d2dForceEnabled = false;
79445:     bool d2dBlocked = false;
51736: 
51736:     nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
51736:     if (gfxInfo) {
51736:         PRInt32 status;
51736:         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_DIRECT2D, &status))) {
55059:             if (status != nsIGfxInfo::FEATURE_NO_INFO) {
80486:                 d2dBlocked = true;
51736:             }
51736:         }
51736:     }
51736: 
79445:     d2dDisabled = Preferences::GetBool("gfx.direct2d.disabled", false);
79445:     d2dForceEnabled = Preferences::GetBool("gfx.direct2d.force-enabled", false);
51656: 
53984:     bool tryD2D = !d2dBlocked || d2dForceEnabled;
53984:     
57104:     // Do not ever try if d2d is explicitly disabled,
57104:     // or if we're not using DWrite fonts.
57104:     if (d2dDisabled || mUsingGDIFonts) {
53984:         tryD2D = false;
53984:     }
53984: 
53984:     if (isVistaOrHigher  && !safeMode && tryD2D) {
53984:         VerifyD2DDevice(d2dForceEnabled);
53984:         if (mD2DDevice) {
53984:             mRenderMode = RENDER_DIRECT2D;
80486:             mUseDirectWrite = true;
53984:         }
53984:     } else {
53984:         mD2DDevice = nsnull;
53984:     }
53984: #endif
53984: 
53984: #ifdef CAIRO_HAS_DWRITE_FONT
53984:     // Enable when it's preffed on -and- we're using Vista or higher. Or when
53984:     // we're going to use D2D.
53984:     if (!mDWriteFactory && (mUseDirectWrite && isVistaOrHigher)) {
63285:         mozilla::ScopedGfxFeatureReporter reporter("DWrite");
53984:         DWriteCreateFactoryFunc createDWriteFactory = (DWriteCreateFactoryFunc)
53984:             GetProcAddress(LoadLibraryW(L"dwrite.dll"), "DWriteCreateFactory");
53984: 
53984:         if (createDWriteFactory) {
53984:             /**
53984:              * I need a direct pointer to be able to cast to IUnknown**, I also
53984:              * need to remember to release this because the nsRefPtr will
53984:              * AddRef it.
53984:              */
53984:             IDWriteFactory *factory;
53984:             HRESULT hr = createDWriteFactory(
53984:                 DWRITE_FACTORY_TYPE_SHARED,
53984:                 __uuidof(IDWriteFactory),
53984:                 reinterpret_cast<IUnknown**>(&factory));
53984:             mDWriteFactory = factory;
53984:             factory->Release();
63285: 
86693:             if (SUCCEEDED(hr)) {
86693:                 hr = mDWriteFactory->CreateTextAnalyzer(
86693:                     getter_AddRefs(mDWriteAnalyzer));
86693:             }
86693: 
71640:             SetupClearTypeParams();
68738: 
63285:             if (hr == S_OK)
63285:               reporter.SetSuccessful();
53984:         }
53984:     }
53984: #endif
53984: }
53984: 
53984: void
79445: gfxWindowsPlatform::VerifyD2DDevice(bool aAttemptForce)
53984: {
53984: #ifdef CAIRO_HAS_D2D_SURFACE
53984:     if (mD2DDevice) {
53984:         ID3D10Device1 *device = cairo_d2d_device_get_device(mD2DDevice);
53984: 
53984:         if (SUCCEEDED(device->GetDeviceRemovedReason())) {
53984:             return;
53984:         }
53984:         mD2DDevice = nsnull;
53984:     }
53984: 
91135:     mozilla::ScopedGfxFeatureReporter reporter("D2D", aAttemptForce);
63285: 
50585:     HMODULE d3d10module = LoadLibraryA("d3d10_1.dll");
50585:     D3D10CreateDevice1Func createD3DDevice = (D3D10CreateDevice1Func)
50585:         GetProcAddress(d3d10module, "D3D10CreateDevice1");
50585:     nsRefPtr<ID3D10Device1> device;
50585: 
50585:     if (createD3DDevice) {
75151:         HMODULE dxgiModule = LoadLibraryA("dxgi.dll");
75151:         CreateDXGIFactory1Func createDXGIFactory1 = (CreateDXGIFactory1Func)
75151:             GetProcAddress(dxgiModule, "CreateDXGIFactory1");
75151: 
75151:         // Try to use a DXGI 1.1 adapter in order to share resources
75151:         // across processes.
75151:         nsRefPtr<IDXGIAdapter1> adapter1;
75151:         if (createDXGIFactory1) {
75151:             nsRefPtr<IDXGIFactory1> factory1;
75151:             HRESULT hr = createDXGIFactory1(__uuidof(IDXGIFactory1),
75151:                                             getter_AddRefs(factory1));
75151: 
88624:             if (FAILED(hr) || !factory1) {
88624:               // This seems to happen with some people running the iZ3D driver.
88624:               // They won't get acceleration.
88624:               return;
88624:             }
88624:     
75151:             nsRefPtr<IDXGIAdapter1> adapter1; 
75151:             hr = factory1->EnumAdapters1(0, getter_AddRefs(adapter1));
75151: 
75151:             if (SUCCEEDED(hr) && adapter1) {
75151:                 hr = adapter1->CheckInterfaceSupport(__uuidof(ID3D10Device1),
75151:                                                      nsnull);
75151:                 if (FAILED(hr)) {
75151:                     adapter1 = nsnull;
75151:                 }
75151:             }
75151:         }
75151: 
89807:         // It takes a lot of time (5-10% of startup time or ~100ms) to do both
89807:         // a createD3DDevice on D3D10_FEATURE_LEVEL_10_0 and 
89807:         // D3D10_FEATURE_LEVEL_10_1.  Therefore we set a pref if we ever get
89807:         // 10.1 to work and we use that first if the pref is set.
89807:         // Going direct to a 10.1 check only takes 20-30ms.
89807:         // The initialization of hr doesn't matter here because it will get
89807:         // overwritten whether or not the preference is set.
89807:         //   - If the preferD3D10_1 pref is set it gets overwritten immediately.
89807:         //   - If the preferD3D10_1 pref is not set, the if condition after
89807:         //     the one that follows us immediately will short circuit before 
89807:         //     checking FAILED(hr) and will again get overwritten immediately.
89807:         // We initialize it here just so it does not appear to be an
89807:         // uninitialized value.
89807:         HRESULT hr = E_FAIL;
89807:         bool preferD3D10_1 = 
89807:           Preferences::GetBool("gfx.direct3d.prefer_10_1", false);
89807:         if (preferD3D10_1) {
89807:             hr = createD3DDevice(
89807:                   adapter1, 
89807:                   D3D10_DRIVER_TYPE_HARDWARE,
89807:                   NULL,
89807:                   D3D10_CREATE_DEVICE_BGRA_SUPPORT |
89807:                   D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
89807:                   D3D10_FEATURE_LEVEL_10_1,
89807:                   D3D10_1_SDK_VERSION,
89807:                   getter_AddRefs(device));
89807: 
89807:             // If we fail here, the DirectX version or video card probably
89807:             // changed.  We previously could use 10.1 but now we can't
89807:             // anymore.  Revert back to doing a 10.0 check first before
89807:             // the 10.1 check.
89807:             if (FAILED(hr)) {
89807:                 Preferences::SetBool("gfx.direct3d.prefer_10_1", false);
89807:             } else {
89807:                 mD2DDevice = cairo_d2d_create_device_from_d3d10device(device);
89807:             }
89807:         }
89807: 
89807:         if (!preferD3D10_1 || FAILED(hr)) {
89807:             // If preferD3D10_1 is set and 10.1 failed, fall back to 10.0.
89807:             // if preferD3D10_1 is not yet set, then first try to create
89807:             // a 10.0 D3D device, then try to see if 10.1 works.
89807:             nsRefPtr<ID3D10Device1> device1;
89807:             hr = createD3DDevice(
75151:                   adapter1, 
50585:                   D3D10_DRIVER_TYPE_HARDWARE,
50585:                   NULL,
50585:                   D3D10_CREATE_DEVICE_BGRA_SUPPORT |
50585:                   D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
50585:                   D3D10_FEATURE_LEVEL_10_0,
50585:                   D3D10_1_SDK_VERSION,
89807:                   getter_AddRefs(device1));
50585: 
50585:             if (SUCCEEDED(hr)) {
89807:                 device = device1;
89807:                 if (preferD3D10_1) {
89807:                   mD2DDevice = 
89807:                     cairo_d2d_create_device_from_d3d10device(device);
89807:                 }
89807:             }
89807:         }
89807: 
89807:         // If preferD3D10_1 is not yet set and 10.0 succeeded
89807:         if (!preferD3D10_1 && SUCCEEDED(hr)) {
89807:             // We have 10.0, let's try 10.1.  This second check will only
89807:             // ever be done once if it succeeds.  After that an option
89807:             // will be set to prefer using 10.1 before trying 10.0.
89807:             // In the case that 10.1 fails, it won't be a long operation
89807:             // like it is when 10.1 succeeds, so we don't need to optimize
89807:             // the case where 10.1 is not supported, but 10.0 is supported.
50585:             nsRefPtr<ID3D10Device1> device1;
50585:             hr = createD3DDevice(
75151:                   adapter1, 
50585:                   D3D10_DRIVER_TYPE_HARDWARE,
50585:                   NULL,
50585:                   D3D10_CREATE_DEVICE_BGRA_SUPPORT |
50585:                   D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
50585:                   D3D10_FEATURE_LEVEL_10_1,
50585:                   D3D10_1_SDK_VERSION,
50585:                   getter_AddRefs(device1));
50585: 
50585:             if (SUCCEEDED(hr)) {
50585:                 device = device1;
89807:                 Preferences::SetBool("gfx.direct3d.prefer_10_1", true);
50585:             }
50585:             mD2DDevice = cairo_d2d_create_device_from_d3d10device(device);
50585:         }
50585:     }
53984: 
53984:     if (!mD2DDevice && aAttemptForce) {
53984:         mD2DDevice = cairo_d2d_create_device();
50585:     }
63285: 
72424:     if (mD2DDevice) {
63285:         reporter.SetSuccessful();
72424:         mozilla::gfx::Factory::SetDirect3D10Device(cairo_d2d_device_get_device(mD2DDevice));
72424:     }
46438: #endif
38727: }
57104: 
63075: // bug 630201 - older pre-RTM versions of Direct2D/DirectWrite cause odd
63075: // crashers so blacklist them altogether
63075: 
63075: #ifdef CAIRO_HAS_DWRITE_FONT
63075: #define WINDOWS7_RTM_BUILD 7600
63075: 
79445: static bool
63075: AllowDirectWrite()
63075: {
63075:     PRInt32 winVers, buildNum;
63075: 
63075:     winVers = gfxWindowsPlatform::WindowsOSVersion(&buildNum);
63075:     if (winVers == gfxWindowsPlatform::kWindows7 &&
63075:         buildNum < WINDOWS7_RTM_BUILD)
63075:     {
63075:         // don't use Direct2D/DirectWrite on older versions of Windows 7
80486:         return false;
63075:     }
63075: 
80486:     return true;
63075: }
63075: #endif
63075: 
36949: gfxPlatformFontList*
36949: gfxWindowsPlatform::CreatePlatformFontList()
36949: {
80486:     mUsingGDIFonts = false;
57104:     gfxPlatformFontList *pfl;
38727: #ifdef CAIRO_HAS_DWRITE_FONT
63075:     if (AllowDirectWrite() && GetDWriteFactory()) {
57104:         pfl = new gfxDWriteFontList();
57104:         if (NS_SUCCEEDED(pfl->InitFontList())) {
57104:             return pfl;
57104:         }
57104:         // DWrite font initialization failed! Don't know why this would happen,
57104:         // but apparently it can - see bug 594865.
57104:         // So we're going to fall back to GDI fonts & rendering.
57104:         gfxPlatformFontList::Shutdown();
57104:         SetRenderMode(RENDER_GDI);
38727:     }
38727: #endif
57104:     pfl = new gfxGDIFontList();
80486:     mUsingGDIFonts = true;
57104: 
57104:     if (NS_SUCCEEDED(pfl->InitFontList())) {
57104:         return pfl;
57104:     }
57104: 
57104:     gfxPlatformFontList::Shutdown();
57104:     return nsnull;
36949: }
36949: 
    1: already_AddRefed<gfxASurface>
    1: gfxWindowsPlatform::CreateOffscreenSurface(const gfxIntSize& size,
54253:                                            gfxASurface::gfxContentType contentType)
    1: {
30087:     gfxASurface *surf = nsnull;
30087: 
30087: #ifdef CAIRO_HAS_WIN32_SURFACE
30087:     if (mRenderMode == RENDER_GDI)
54253:         surf = new gfxWindowsSurface(size, gfxASurface::FormatFromContent(contentType));
30086: #endif
30087: 
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:     if (mRenderMode == RENDER_DIRECT2D)
54253:         surf = new gfxD2DSurface(size, gfxASurface::FormatFromContent(contentType));
38727: #endif
38727: 
30087:     if (surf == nsnull)
54253:         surf = new gfxImageSurface(size, gfxASurface::FormatFromContent(contentType));
30087: 
    1:     NS_IF_ADDREF(surf);
30087: 
    1:     return surf;
    1: }
    1: 
72424: RefPtr<ScaledFont>
72424: gfxWindowsPlatform::GetScaledFontForFont(gfxFont *aFont)
72424: {
72424:   if(mUseDirectWrite) {
72424:     gfxDWriteFont *font = static_cast<gfxDWriteFont*>(aFont);
72424: 
72424:     NativeFont nativeFont;
72424:     nativeFont.mType = NATIVE_FONT_DWRITE_FONT_FACE;
72424:     nativeFont.mFont = font->GetFontFace();
72424:     RefPtr<ScaledFont> scaledFont =
72424:       mozilla::gfx::Factory::CreateScaledFontForNativeFont(nativeFont, font->GetAdjustedSize());
72424: 
72424:     return scaledFont;
72424:   }
72863: 
82414:   NativeFont nativeFont;
82414:   nativeFont.mType = NATIVE_FONT_GDI_FONT_FACE;
82414:   nativeFont.mFont = aFont;
82414:   RefPtr<ScaledFont> scaledFont =
82414:     Factory::CreateScaledFontForNativeFont(nativeFont, aFont->GetAdjustedSize());
82414: 
82414:   return scaledFont;
72424: }
72424: 
72424: already_AddRefed<gfxASurface>
72424: gfxWindowsPlatform::GetThebesSurfaceForDrawTarget(DrawTarget *aTarget)
72424: {
72424: #ifdef XP_WIN
72424:   if (aTarget->GetType() == BACKEND_DIRECT2D) {
88427:     void *surface = aTarget->GetUserData(&kThebesSurfaceKey);
87515:     if (surface) {
87515:       nsRefPtr<gfxASurface> surf = static_cast<gfxASurface*>(surface);
87515:       return surf.forget();
87515:     } else {
89584:       if (!GetD2DDevice()) {
89584:         // We no longer have a D2D device, can't do this.
89584:         return NULL;
89584:       }
89584: 
72424:       RefPtr<ID3D10Texture2D> texture =
72424:         static_cast<ID3D10Texture2D*>(aTarget->GetNativeSurface(NATIVE_SURFACE_D3D10_TEXTURE));
72424: 
72424:       if (!texture) {
72424:         return gfxPlatform::GetThebesSurfaceForDrawTarget(aTarget);
72424:       }
72424: 
72424:       aTarget->Flush();
72424: 
72424:       nsRefPtr<gfxASurface> surf =
72424:         new gfxD2DSurface(texture, ContentForFormat(aTarget->GetFormat()));
72424: 
87515:       // add a reference to be held by the drawTarget
87515:       surf->AddRef();
88427:       aTarget->AddUserData(&kThebesSurfaceKey, surf.get(), DestroyThebesSurface);
87515:       /* "It might be worth it to clear cairo surfaces associated with a drawtarget.
87515: 	  The strong reference means for example for D2D that cairo's scratch surface
87515: 	  will be kept alive (well after a user being done) and consume extra VRAM.
87515: 	  We can deal with this in a follow-up though." */
87515: 
87511:       // shouldn't this hold a reference?
87507:       surf->SetData(&kDrawTarget, aTarget, NULL);
72424:       return surf.forget();
72424:     }
87515:   }
72424: #endif
72424: 
72424:   return gfxPlatform::GetThebesSurfaceForDrawTarget(aTarget);
72424: }
72424: 
82417: bool
82417: gfxWindowsPlatform::SupportsAzure(BackendType& aBackend)
82417: {
82417: #ifdef CAIRO_HAS_D2D_SURFACE
82417:   if (mRenderMode == RENDER_DIRECT2D) {
82417:       aBackend = BACKEND_DIRECT2D;
82417:       return true;
82417:   }
82417: #endif
82417:   
88510:   if (mPreferredDrawTargetBackend != BACKEND_NONE) {
88510:     aBackend = mPreferredDrawTargetBackend;
82417:     return true;
82417:   }
88510: 
82417:   return false;
82417: }
82417: 
    1: nsresult
38493: gfxWindowsPlatform::GetFontList(nsIAtom *aLangGroup,
    1:                                 const nsACString& aGenericFamily,
23904:                                 nsTArray<nsString>& aListOfFonts)
    1: {
36949:     gfxPlatformFontList::PlatformFontList()->GetFontList(aLangGroup, aGenericFamily, aListOfFonts);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: static void
    1: RemoveCharsetFromFontSubstitute(nsAString &aName)
    1: {
    1:     PRInt32 comma = aName.FindChar(PRUnichar(','));
    1:     if (comma >= 0)
    1:         aName.Truncate(comma);
    1: }
    1: 
    1: nsresult
    1: gfxWindowsPlatform::UpdateFontList()
    1: {
36949:     gfxPlatformFontList::PlatformFontList()->UpdateFontList();
12989: 
    1:     return NS_OK;
    1: }
    1: 
91870: static const char kFontArabicTypesetting[] = "Arabic Typesetting";
91870: static const char kFontArial[] = "Arial";
91870: static const char kFontArialUnicodeMS[] = "Arial Unicode MS";
91870: static const char kFontCambria[] = "Cambria";
91870: static const char kFontCambriaMath[] = "Cambria Math";
91870: static const char kFontEbrima[] = "Ebrima";
91870: static const char kFontEstrangeloEdessa[] = "Estrangelo Edessa";
91870: static const char kFontEuphemia[] = "Euphemia";
91870: static const char kFontGabriola[] = "Gabriola";
91870: static const char kFontKhmerUI[] = "Khmer UI";
91870: static const char kFontLaoUI[] = "Lao UI";
91870: static const char kFontMVBoli[] = "MV Boli";
91870: static const char kFontMalgunGothic[] = "Malgun Gothic";
91870: static const char kFontMicrosoftJhengHei[] = "Microsoft JhengHei";
91870: static const char kFontMicrosoftNewTaiLue[] = "Microsoft New Tai Lue";
91870: static const char kFontMicrosoftPhagsPa[] = "Microsoft PhagsPa";
91870: static const char kFontMicrosoftTaiLe[] = "Microsoft Tai Le";
91870: static const char kFontMicrosoftUighur[] = "Microsoft Uighur";
91870: static const char kFontMicrosoftYaHei[] = "Microsoft YaHei";
91870: static const char kFontMicrosoftYiBaiti[] = "Microsoft Yi Baiti";
91870: static const char kFontMeiryo[] = "Meiryo";
91870: static const char kFontMongolianBaiti[] = "Mongolian Baiti";
91870: static const char kFontNyala[] = "Nyala";
91870: static const char kFontPlantagenetCherokee[] = "Plantagenet Cherokee";
91874: static const char kFontSegoeUI[] = "Segoe UI";
91870: static const char kFontSegoeUISymbol[] = "Segoe UI Symbol";
91870: static const char kFontSylfaen[] = "Sylfaen";
91870: static const char kFontTraditionalArabic[] = "Traditional Arabic";
91870: 
91870: void
91870: gfxWindowsPlatform::GetCommonFallbackFonts(const PRUint32 aCh,
91870:                                            PRInt32 aRunScript,
91870:                                            nsTArray<const char*>& aFontList)
91870: {
91874:     // Arial is used as the default fallback for system fallback
91874:     aFontList.AppendElement(kFontArial);
91874: 
91870:     if (!IS_IN_BMP(aCh)) {
91870:         PRUint32 p = aCh >> 16;
91870:         if (p == 1) { // SMP plane
91870:             aFontList.AppendElement(kFontCambriaMath);
91870:             aFontList.AppendElement(kFontSegoeUISymbol);
91870:             aFontList.AppendElement(kFontEbrima);
91870:         }
91870:     } else {
91870:         PRUint32 b = (aCh >> 8) & 0xff;
91870: 
91870:         switch (b) {
91870:         case 0x05:
91870:             aFontList.AppendElement(kFontEstrangeloEdessa);
91870:             aFontList.AppendElement(kFontCambria);
91870:             break;
91870:         case 0x06:
91870:             aFontList.AppendElement(kFontMicrosoftUighur);
91870:             break;
91870:         case 0x07:
91870:             aFontList.AppendElement(kFontEstrangeloEdessa);
91870:             aFontList.AppendElement(kFontMVBoli);
91870:             aFontList.AppendElement(kFontEbrima);
91870:             break;
91870:         case 0x0e:
91870:             aFontList.AppendElement(kFontLaoUI);
91870:             break;
91870:         case 0x12:
91870:         case 0x13:
91870:             aFontList.AppendElement(kFontNyala);
91870:             aFontList.AppendElement(kFontPlantagenetCherokee);
91870:             break;
91870:         case 0x14:
91870:         case 0x15:
91870:         case 0x16:
91870:             aFontList.AppendElement(kFontEuphemia);
91870:             aFontList.AppendElement(kFontSegoeUISymbol);
91870:             break;
91870:         case 0x17:
91870:             aFontList.AppendElement(kFontKhmerUI);
91870:             break;
91870:         case 0x18:  // Mongolian
91870:             aFontList.AppendElement(kFontMongolianBaiti);
91870:             break;
91870:         case 0x19:
91870:             aFontList.AppendElement(kFontMicrosoftTaiLe);
91870:             aFontList.AppendElement(kFontMicrosoftNewTaiLue);
91870:             aFontList.AppendElement(kFontKhmerUI);
91870:             break;
91870:             break;
91870:         case 0x20:  // Symbol ranges
91870:         case 0x21:
91870:         case 0x22:
91870:         case 0x23:
91870:         case 0x24:
91870:         case 0x25:
91870:         case 0x26:
91870:         case 0x27:
91870:         case 0x29:
91870:         case 0x2a:
91870:         case 0x2b:
91870:         case 0x2c:
91874:             aFontList.AppendElement(kFontSegoeUI);
91874:             aFontList.AppendElement(kFontSegoeUISymbol);
91870:             aFontList.AppendElement(kFontCambria);
91870:             aFontList.AppendElement(kFontCambriaMath);
91870:             aFontList.AppendElement(kFontMeiryo);
91870:             aFontList.AppendElement(kFontArial);
91870:             aFontList.AppendElement(kFontEbrima);
91870:             break;
91870:         case 0x2d:
91870:         case 0x2e:
91870:         case 0x2f:
91870:             aFontList.AppendElement(kFontEbrima);
91870:             aFontList.AppendElement(kFontNyala);
91870:             aFontList.AppendElement(kFontMeiryo);
91870:             break;
91870:         case 0x28:  // Braille
91870:             aFontList.AppendElement(kFontSegoeUISymbol);
91870:             break;
91870:         case 0x30:
91870:         case 0x31:
91870:             aFontList.AppendElement(kFontMicrosoftYaHei);
91870:             break;
91870:         case 0x32:
91870:             aFontList.AppendElement(kFontMalgunGothic);
91870:             break;
91870:         case 0x4d:
91870:             aFontList.AppendElement(kFontSegoeUISymbol);
91870:             break;
91870:         case 0xa0:  // Yi
91870:         case 0xa1:
91870:         case 0xa2:
91870:         case 0xa3:
91870:         case 0xa4:
91870:             aFontList.AppendElement(kFontMicrosoftYiBaiti);
91870:             break;
91870:         case 0xa5:
91870:         case 0xa6:
91870:         case 0xa7:
91870:             aFontList.AppendElement(kFontEbrima);
91870:             aFontList.AppendElement(kFontCambriaMath);
91870:             break;
91870:         case 0xa8:
91870:              aFontList.AppendElement(kFontMicrosoftPhagsPa);
91870:              break;
91870:         case 0xfb:
91870:             aFontList.AppendElement(kFontMicrosoftUighur);
91870:             aFontList.AppendElement(kFontGabriola);
91870:             aFontList.AppendElement(kFontSylfaen);
91870:             break;
91870:         case 0xfc:
91870:         case 0xfd:
91874:             aFontList.AppendElement(kFontTraditionalArabic);
91870:             aFontList.AppendElement(kFontArabicTypesetting);
91870:             break;
91870:         case 0xfe:
91870:             aFontList.AppendElement(kFontTraditionalArabic);
91870:             aFontList.AppendElement(kFontMicrosoftJhengHei);
91870:            break;
91870:        case 0xff:
91870:             aFontList.AppendElement(kFontMicrosoftJhengHei);
91870:             break;
91870:         default:
91870:             break;
91870:         }
91870:     }
91870: 
91870:     // Arial Unicode MS has lots of glyphs for obscure characters,
91870:     // use it as a last resort
91870:     aFontList.AppendElement(kFontArialUnicodeMS);
91870: }
91870: 
    1: struct ResolveData {
    1:     ResolveData(gfxPlatform::FontResolverCallback aCallback,
    1:                 gfxWindowsPlatform *aCaller, const nsAString *aFontName,
    1:                 void *aClosure) :
    1:         mFoundCount(0), mCallback(aCallback), mCaller(aCaller),
    1:         mFontName(aFontName), mClosure(aClosure) {}
    1:     PRUint32 mFoundCount;
    1:     gfxPlatform::FontResolverCallback mCallback;
    1:     gfxWindowsPlatform *mCaller;
    1:     const nsAString *mFontName;
    1:     void *mClosure;
    1: };
    1: 
    1: nsresult
    1: gfxWindowsPlatform::ResolveFontName(const nsAString& aFontName,
    1:                                     FontResolverCallback aCallback,
38727:                                     void *aClosure,
79445:                                     bool& aAborted)
    1: {
36949:     nsAutoString resolvedName;
36949:     if (!gfxPlatformFontList::PlatformFontList()->
36949:              ResolveFontName(aFontName, resolvedName)) {
80486:         aAborted = false;
36949:         return NS_OK;
36949:     }
36949:     aAborted = !(*aCallback)(resolvedName, aClosure);
    1:     return NS_OK;
    1: }
    1: 
36949: nsresult
36949: gfxWindowsPlatform::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
36949: {
36949:     gfxPlatformFontList::PlatformFontList()->GetStandardFamilyName(aFontName, aFamilyName);
    1:     return NS_OK;
    1: }
    1: 
  270: gfxFontGroup *
  270: gfxWindowsPlatform::CreateFontGroup(const nsAString &aFamilies,
19962:                                     const gfxFontStyle *aStyle,
19962:                                     gfxUserFontSet *aUserFontSet)
  270: {
39447:     return new gfxFontGroup(aFamilies, aStyle, aUserFontSet);
19962: }
19962: 
19962: gfxFontEntry* 
23273: gfxWindowsPlatform::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
23273:                                     const nsAString& aFontName)
19962: {
36949:     return gfxPlatformFontList::PlatformFontList()->LookupLocalFont(aProxyEntry, 
36949:                                                                     aFontName);
19962: }
19962: 
19962: gfxFontEntry* 
22397: gfxWindowsPlatform::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
21067:                                      const PRUint8 *aFontData, PRUint32 aLength)
19962: {
36949:     return gfxPlatformFontList::PlatformFontList()->MakePlatformFont(aProxyEntry,
36949:                                                                      aFontData,
36949:                                                                      aLength);
19962: }
19962: 
79445: bool
19962: gfxWindowsPlatform::IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags)
19962: {
23576:     // check for strange format flags
23576:     NS_ASSERTION(!(aFormatFlags & gfxUserFontSet::FLAG_FORMAT_NOT_USED),
23576:                  "strange font format hint set");
23576: 
23576:     // accept supported formats
32809:     if (aFormatFlags & (gfxUserFontSet::FLAG_FORMAT_WOFF     |
32809:                         gfxUserFontSet::FLAG_FORMAT_OPENTYPE | 
23576:                         gfxUserFontSet::FLAG_FORMAT_TRUETYPE)) {
80486:         return true;
23576:     }
23576: 
23576:     // reject all other formats, known and unknown
23576:     if (aFormatFlags != 0) {
80486:         return false;
19962:     }
19962: 
23576:     // no format hint set, need to look at data
80486:     return true;
  270: }
 1959: 
36949: gfxFontFamily *
13280: gfxWindowsPlatform::FindFontFamily(const nsAString& aName)
 1959: {
36949:     return gfxPlatformFontList::PlatformFontList()->FindFamily(aName);
13280: }
13280: 
36949: gfxFontEntry *
13578: gfxWindowsPlatform::FindFontEntry(const nsAString& aName, const gfxFontStyle& aFontStyle)
13280: {
36949:     nsRefPtr<gfxFontFamily> ff = FindFontFamily(aName);
13280:     if (!ff)
13280:         return nsnull;
13280: 
79445:     bool aNeedsBold;
36949:     return ff->FindFontForStyle(aFontStyle, aNeedsBold);
 1959: }
 3787: 
27035: qcms_profile*
 3787: gfxWindowsPlatform::GetPlatformCMSOutputProfile()
 3787: {
37454:     WCHAR str[MAX_PATH];
37454:     DWORD size = MAX_PATH;
37454:     BOOL res;
 3787: 
 3787:     HDC dc = GetDC(nsnull);
36860:     if (!dc)
36860:         return nsnull;
36860: 
37454: #if _MSC_VER
36860:     __try {
37454:         res = GetICMProfileW(dc, &size, (LPWSTR)&str);
36860:     } __except(GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION) {
37454:         res = FALSE;
36860:     }
37454: #else
37454:     res = GetICMProfileW(dc, &size, (LPWSTR)&str);
37454: #endif
36860: 
 3787:     ReleaseDC(nsnull, dc);
37454:     if (!res)
37454:         return nsnull;
 3787: 
64485:     qcms_profile* profile = qcms_profile_from_unicode_path(str);
 3787: #ifdef DEBUG_tor
 3787:     if (profile)
 3787:         fprintf(stderr,
 3787:                 "ICM profile read from %s successfully\n",
 3787:                 NS_ConvertUTF16toUTF8(str).get());
 3787: #endif
 3787:     return profile;
 3787: }
 5254: 
79445: bool
36949: gfxWindowsPlatform::GetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<gfxFontEntry> > *array)
 5254: {
13280:     return mPrefFonts.Get(aKey, array);
 5254: }
 5254: 
 5254: void
36949: gfxWindowsPlatform::SetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<gfxFontEntry> >& array)
 5254: {
13280:     mPrefFonts.Put(aKey, array);
 5254: }
13877: 
79445: bool
42854: gfxWindowsPlatform::UseClearTypeForDownloadableFonts()
42854: {
42854:     if (mUseClearTypeForDownloadableFonts == UNINITIALIZED_VALUE) {
79445:         mUseClearTypeForDownloadableFonts = Preferences::GetBool(GFX_DOWNLOADABLE_FONTS_USE_CLEARTYPE, true);
42854:     }
42854: 
42854:     return mUseClearTypeForDownloadableFonts;
42854: }
42854: 
79445: bool
42854: gfxWindowsPlatform::UseClearTypeAlways()
42854: {
42854:     if (mUseClearTypeAlways == UNINITIALIZED_VALUE) {
79445:         mUseClearTypeAlways = Preferences::GetBool(GFX_USE_CLEARTYPE_ALWAYS, false);
42854:     }
42854: 
42854:     return mUseClearTypeAlways;
42854: }
42854: 
42854: PRInt32
63075: gfxWindowsPlatform::WindowsOSVersion(PRInt32 *aBuildNum)
42854: {
42854:     static PRInt32 winVersion = UNINITIALIZED_VALUE;
63075:     static PRInt32 buildNum = UNINITIALIZED_VALUE;
42854: 
42854:     OSVERSIONINFO vinfo;
42854: 
42854:     if (winVersion == UNINITIALIZED_VALUE) {
42854:         vinfo.dwOSVersionInfoSize = sizeof (vinfo);
42854:         if (!GetVersionEx(&vinfo)) {
42854:             winVersion = kWindowsUnknown;
63075:             buildNum = 0;
42854:         } else {
42854:             winVersion = PRInt32(vinfo.dwMajorVersion << 16) + vinfo.dwMinorVersion;
63075:             buildNum = PRInt32(vinfo.dwBuildNumber);
42854:         }
42854:     }
63075: 
63075:     if (aBuildNum) {
63075:         *aBuildNum = buildNum;
63075:     }
63075: 
42854:     return winVersion;
42854: }
42854: 
32950: void 
61526: gfxWindowsPlatform::GetDLLVersion(const PRUnichar *aDLLPath, nsAString& aVersion)
60493: {
60493:     DWORD versInfoSize, vers[4] = {0};
60493:     // version info not available case
60493:     aVersion.Assign(NS_LITERAL_STRING("0.0.0.0"));
60493:     versInfoSize = GetFileVersionInfoSizeW(aDLLPath, NULL);
60493:     nsAutoTArray<BYTE,512> versionInfo;
60493:     
62539:     if (versInfoSize == 0 ||
62539:         !versionInfo.AppendElements(PRUint32(versInfoSize)))
62539:     {
60493:         return;
60493:     }
60493: 
62539:     if (!GetFileVersionInfoW(aDLLPath, 0, versInfoSize, 
62539:            LPBYTE(versionInfo.Elements())))
62539:     {
62539:         return;
62539:     } 
62539: 
62539:     UINT len = 0;
62539:     VS_FIXEDFILEINFO *fileInfo = nsnull;
60493:     if (!VerQueryValue(LPBYTE(versionInfo.Elements()), TEXT("\\"),
62539:            (LPVOID *)&fileInfo, &len) ||
62539:         len == 0 ||
62539:         fileInfo == nsnull)
62539:     {
60493:         return;
60493:     }
60493: 
60493:     DWORD fileVersMS = fileInfo->dwFileVersionMS; 
60493:     DWORD fileVersLS = fileInfo->dwFileVersionLS;
60493: 
60493:     vers[0] = HIWORD(fileVersMS);
60493:     vers[1] = LOWORD(fileVersMS);
60493:     vers[2] = HIWORD(fileVersLS);
60493:     vers[3] = LOWORD(fileVersLS);
60493: 
60493:     char buf[256];
60493:     sprintf(buf, "%d.%d.%d.%d", vers[0], vers[1], vers[2], vers[3]);
60493:     aVersion.Assign(NS_ConvertUTF8toUTF16(buf));
60493: }
60493: 
60493: void 
69664: gfxWindowsPlatform::GetCleartypeParams(nsTArray<ClearTypeParameterInfo>& aParams)
69664: {
69664:     HKEY  hKey, subKey;
69664:     DWORD i, rv, size, type;
69664:     WCHAR displayName[256], subkeyName[256];
69664: 
69664:     aParams.Clear();
69664: 
69664:     // construct subkeys based on HKLM subkeys, assume they are same for HKCU
69664:     rv = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
69664:                        L"Software\\Microsoft\\Avalon.Graphics",
69664:                        0, KEY_READ, &hKey);
69664: 
69664:     if (rv != ERROR_SUCCESS) {
69664:         return;
69664:     }
69664: 
69664:     // enumerate over subkeys
69664:     for (i = 0, rv = ERROR_SUCCESS; rv != ERROR_NO_MORE_ITEMS; i++) {
80467:         size = ArrayLength(displayName);
69664:         rv = RegEnumKeyExW(hKey, i, displayName, &size, NULL, NULL, NULL, NULL);
69664:         if (rv != ERROR_SUCCESS) {
69664:             continue;
69664:         }
69664: 
69664:         ClearTypeParameterInfo ctinfo;
69664:         ctinfo.displayName.Assign(displayName);
69664: 
69664:         DWORD subrv, value;
69664:         bool foundData = false;
69664: 
80467:         swprintf_s(subkeyName, ArrayLength(subkeyName),
69664:                    L"Software\\Microsoft\\Avalon.Graphics\\%s", displayName);
69664: 
69664:         // subkey for gamma, pixel structure
69664:         subrv = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
69664:                               subkeyName, 0, KEY_QUERY_VALUE, &subKey);
69664: 
69664:         if (subrv == ERROR_SUCCESS) {
69664:             size = sizeof(value);
69664:             subrv = RegQueryValueExW(subKey, L"GammaLevel", NULL, &type,
69664:                                      (LPBYTE)&value, &size);
69664:             if (subrv == ERROR_SUCCESS && type == REG_DWORD) {
69664:                 foundData = true;
69664:                 ctinfo.gamma = value;
69664:             }
69664: 
69664:             size = sizeof(value);
69664:             subrv = RegQueryValueExW(subKey, L"PixelStructure", NULL, &type,
69664:                                      (LPBYTE)&value, &size);
69664:             if (subrv == ERROR_SUCCESS && type == REG_DWORD) {
69664:                 foundData = true;
69664:                 ctinfo.pixelStructure = value;
69664:             }
69664: 
69664:             RegCloseKey(subKey);
69664:         }
69664: 
69664:         // subkey for cleartype level, enhanced contrast
69664:         subrv = RegOpenKeyExW(HKEY_CURRENT_USER,
69664:                               subkeyName, 0, KEY_QUERY_VALUE, &subKey);
69664: 
69664:         if (subrv == ERROR_SUCCESS) {
69664:             size = sizeof(value);
69664:             subrv = RegQueryValueExW(subKey, L"ClearTypeLevel", NULL, &type,
69664:                                      (LPBYTE)&value, &size);
69664:             if (subrv == ERROR_SUCCESS && type == REG_DWORD) {
69664:                 foundData = true;
69664:                 ctinfo.clearTypeLevel = value;
69664:             }
69664:       
69664:             size = sizeof(value);
69664:             subrv = RegQueryValueExW(subKey, L"EnhancedContrastLevel",
69664:                                      NULL, &type, (LPBYTE)&value, &size);
69664:             if (subrv == ERROR_SUCCESS && type == REG_DWORD) {
69664:                 foundData = true;
69664:                 ctinfo.enhancedContrast = value;
69664:             }
69664: 
69664:             RegCloseKey(subKey);
69664:         }
69664: 
69664:         if (foundData) {
69664:             aParams.AppendElement(ctinfo);
69664:         }
69664:     }
69664: 
69664:     RegCloseKey(hKey);
69664: }
69664: 
69664: void
71640: gfxWindowsPlatform::FontsPrefsChanged(const char *aPref)
42854: {
79445:     bool clearTextFontCaches = true;
42854: 
71640:     gfxPlatform::FontsPrefsChanged(aPref);
42854: 
42854:     if (!aPref) {
42854:         mUseClearTypeForDownloadableFonts = UNINITIALIZED_VALUE;
42854:         mUseClearTypeAlways = UNINITIALIZED_VALUE;
42854:     } else if (!strcmp(GFX_DOWNLOADABLE_FONTS_USE_CLEARTYPE, aPref)) {
42854:         mUseClearTypeForDownloadableFonts = UNINITIALIZED_VALUE;
42854:     } else if (!strcmp(GFX_USE_CLEARTYPE_ALWAYS, aPref)) {
42854:         mUseClearTypeAlways = UNINITIALIZED_VALUE;
68738:     } else if (!strncmp(GFX_CLEARTYPE_PARAMS, aPref, strlen(GFX_CLEARTYPE_PARAMS))) {
71640:         SetupClearTypeParams();
42854:     } else {
80486:         clearTextFontCaches = false;
42854:     }
42854: 
43347:     if (clearTextFontCaches) {    
42854:         gfxFontCache *fc = gfxFontCache::GetCache();
43347:         if (fc) {
43347:             fc->Flush();
43347:         }
42854:     }
50598: }
63228: 
68738: void
71640: gfxWindowsPlatform::SetupClearTypeParams()
68738: {
68738: #if CAIRO_HAS_DWRITE_FONT
68738:     if (GetDWriteFactory()) {
68738:         // any missing prefs will default to invalid (-1) and be ignored;
68738:         // out-of-range values will also be ignored
68738:         FLOAT gamma = -1.0;
68738:         FLOAT contrast = -1.0;
68738:         FLOAT level = -1.0;
68738:         int geometry = -1;
68738:         int mode = -1;
68738:         PRInt32 value;
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_GAMMA, &value))) {
68738:             if (value >= 1000 && value <= 2200) {
69664:                 gamma = FLOAT(value / 1000.0);
68738:             }
68738:         }
71640: 
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_CONTRAST, &value))) {
68738:             if (value >= 0 && value <= 1000) {
69664:                 contrast = FLOAT(value / 100.0);
68738:             }
68738:         }
71640: 
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_LEVEL, &value))) {
68738:             if (value >= 0 && value <= 100) {
69664:                 level = FLOAT(value / 100.0);
68738:             }
68738:         }
71640: 
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_STRUCTURE, &value))) {
68738:             if (value >= 0 && value <= 2) {
68738:                 geometry = value;
68738:             }
68738:         }
71640: 
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_MODE, &value))) {
68738:             if (value >= 0 && value <= 5) {
68738:                 mode = value;
68738:             }
68738:         }
71640: 
68738:         cairo_dwrite_set_cleartype_params(gamma, contrast, level, geometry, mode);
68738: 
68738:         switch (mode) {
68738:         case DWRITE_RENDERING_MODE_ALIASED:
68738:         case DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC:
68738:             mMeasuringMode = DWRITE_MEASURING_MODE_GDI_CLASSIC;
68738:             break;
68738:         case DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL:
68738:             mMeasuringMode = DWRITE_MEASURING_MODE_GDI_NATURAL;
68738:             break;
68738:         default:
68738:             mMeasuringMode = DWRITE_MEASURING_MODE_NATURAL;
68738:             break;
68738:         }
68738:     }
68738: #endif
68738: }
68738: 
63228: bool
63228: gfxWindowsPlatform::IsOptimus()
63228: {
63228:   return GetModuleHandleA("nvumdshim.dll");
63228: }
