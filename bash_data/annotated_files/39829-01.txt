    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Mozilla Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *    Josh Aas <josh@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsClipboard.h"
    1: #include "nsString.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsPrimitiveHelpers.h"
    1: #include "nsMemory.h"
 2842: #include "nsILocalFile.h"
 5955: #include "nsStringStream.h"
 6263: #include "nsDragService.h"
 6263: #include "nsEscape.h"
 7101: #include "nsPrintfCString.h"
11831: #include "nsObjCExceptions.h"
30479: #include "imgIContainer.h"
39390: #include "nsCocoaUtils.h"
 5955: 
 5955: // Screenshots use the (undocumented) png pasteboard type.
 5955: #define IMAGE_PASTEBOARD_TYPES NSTIFFPboardType, @"Apple PNG pasteboard type", nil
    1: 
 5676: #ifdef MOZ_LOGGING
 5676: #define FORCE_PR_LOG
 5676: #endif
 5676: #include "prlog.h"
 5676: 
 5676: #ifdef PR_LOGGING
 5676: extern PRLogModuleInfo* sCocoaLog;
 5676: #endif
 5676: 
    1: nsClipboard::nsClipboard() : nsBaseClipboard()
    1: {
 3066:   mChangeCount = 0;
    1: }
    1: 
    1: nsClipboard::~nsClipboard()
    1: {
    1: }
    1: 
 7101: // We separate this into its own function because after an @try, all local
 7101: // variables within that function get marked as volatile, and our C++ type 
 7101: // system doesn't like volatile things.
 7101: static NSData* 
 7101: GetDataFromPasteboard(NSPasteboard* aPasteboard, NSString* aType)
 7101: {
 7101:   NSData *data = nil;
 7101:   @try {
 7101:     data = [aPasteboard dataForType:aType];
 7101:   } @catch (NSException* e) {
 7101:     NS_WARNING(nsPrintfCString(256, "Exception raised while getting data from the pasteboard: \"%s - %s\"", 
 7101:                                [[e name] UTF8String], [[e reason] UTF8String]).get());
 7101:   }
 7101:   return data;
 7101: }
 7101: 
    1: NS_IMETHODIMP
    1: nsClipboard::SetNativeClipboardData(PRInt32 aWhichClipboard)
    1: {
11831:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11831: 
    1:   if ((aWhichClipboard != kGlobalClipboard) || !mTransferable)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mIgnoreEmptyNotification = PR_TRUE;
    1: 
 2842:   NSDictionary* pasteboardOutputDict = PasteboardDictFromTransferable(mTransferable);
 2842:   if (!pasteboardOutputDict)
 2842:     return NS_ERROR_FAILURE;
 2842: 
 2842:   // write everything out to the general pasteboard
 2842:   unsigned int outputCount = [pasteboardOutputDict count];
 2842:   NSArray* outputKeys = [pasteboardOutputDict allKeys];
 2842:   NSPasteboard* generalPBoard = [NSPasteboard generalPasteboard];
 2842:   [generalPBoard declareTypes:outputKeys owner:nil];
 2842:   for (unsigned int i = 0; i < outputCount; i++) {
 2842:     NSString* currentKey = [outputKeys objectAtIndex:i];
 2842:     id currentValue = [pasteboardOutputDict valueForKey:currentKey];
 7006:     if (currentKey == NSStringPboardType ||
 7006:         currentKey == kCorePboardType_url ||
 7006:         currentKey == kCorePboardType_urld ||
23217:         currentKey == kCorePboardType_urln) {
 2842:       [generalPBoard setString:currentValue forType:currentKey];
23217:     } else if (currentKey == NSHTMLPboardType) {
23217:       [generalPBoard setString:(nsClipboard::WrapHtmlForSystemPasteboard(currentValue))
23217:                        forType:currentKey];
23217:     } else {
 2842:       [generalPBoard setData:currentValue forType:currentKey];
 2842:     }
23217:   }
 2842: 
 3066:   mChangeCount = [generalPBoard changeCount];
 3066: 
 2842:   mIgnoreEmptyNotification = PR_FALSE;
 2842: 
 2842:   return NS_OK;
11831: 
11831:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 2842: }
 2842: 
36983: nsresult
36983: nsClipboard::TransferableFromPasteboard(nsITransferable *aTransferable, NSPasteboard *cocoaPasteboard)
 2842: {
11831:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11831: 
 3066:   // get flavor list that includes all acceptable flavors (including ones obtained through conversion)
 3066:   nsCOMPtr<nsISupportsArray> flavorList;
 3066:   nsresult rv = aTransferable->FlavorsTransferableCanImport(getter_AddRefs(flavorList));
 3066:   if (NS_FAILED(rv))
 3066:     return NS_ERROR_FAILURE;
 3066: 
 3066:   PRUint32 flavorCount;
 3066:   flavorList->Count(&flavorCount);
 3066: 
 3066:   for (PRUint32 i = 0; i < flavorCount; i++) {
 3066:     nsCOMPtr<nsISupports> genericFlavor;
 3066:     flavorList->GetElementAt(i, getter_AddRefs(genericFlavor));
 3066:     nsCOMPtr<nsISupportsCString> currentFlavor(do_QueryInterface(genericFlavor));
 3066:     if (!currentFlavor)
 3066:       continue;
 3066: 
 3066:     nsXPIDLCString flavorStr;
 3066:     currentFlavor->ToString(getter_Copies(flavorStr)); // i has a flavr
 3066: 
 3066:     // printf("looking for clipboard data of type %s\n", flavorStr.get());
 3066: 
21404:     const NSString *pboardType;
21404:     if (nsClipboard::IsStringType(flavorStr, &pboardType)) {
21404:       NSString* pString = [cocoaPasteboard stringForType:pboardType];
 3066:       if (!pString)
 3066:         continue;
 3066: 
 3066:       NSData* stringData = [pString dataUsingEncoding:NSUnicodeStringEncoding];
 3066:       unsigned int dataLength = [stringData length];
 3066:       void* clipboardDataPtr = malloc(dataLength);
 3066:       if (!clipboardDataPtr)
 3066:         return NS_ERROR_OUT_OF_MEMORY;
 3066:       [stringData getBytes:clipboardDataPtr];
 3066: 
 3066:       // The DOM only wants LF, so convert from MacOS line endings to DOM line endings.
 3066:       PRInt32 signedDataLength = dataLength;
 3066:       nsLinebreakHelpers::ConvertPlatformToDOMLinebreaks(flavorStr, &clipboardDataPtr, &signedDataLength);
 3066:       dataLength = signedDataLength;
 3066: 
 3066:       // skip BOM (Byte Order Mark to distinguish little or big endian)      
 3066:       PRUnichar* clipboardDataPtrNoBOM = (PRUnichar*)clipboardDataPtr;
 3066:       if ((dataLength > 2) &&
 3066:           ((clipboardDataPtrNoBOM[0] == 0xFEFF) ||
 3066:            (clipboardDataPtrNoBOM[0] == 0xFFFE))) {
 3066:         dataLength -= sizeof(PRUnichar);
 3066:         clipboardDataPtrNoBOM += 1;
 3066:       }
 3066: 
 3066:       nsCOMPtr<nsISupports> genericDataWrapper;
 3066:       nsPrimitiveHelpers::CreatePrimitiveForData(flavorStr, clipboardDataPtrNoBOM, dataLength,
 3066:                                                  getter_AddRefs(genericDataWrapper));
 3066:       aTransferable->SetTransferData(flavorStr, genericDataWrapper, dataLength);
 3066:       free(clipboardDataPtr);
 3066:       break;
 3066:     }
 5955:     else if (flavorStr.EqualsLiteral(kJPEGImageMime) ||
 5955:              flavorStr.EqualsLiteral(kPNGImageMime) ||
 5955:              flavorStr.EqualsLiteral(kGIFImageMime)) {
 5955:       // Figure out if there's data on the pasteboard we can grab (sanity check)
 5955:       NSString *type = [cocoaPasteboard availableTypeFromArray:[NSArray arrayWithObjects:IMAGE_PASTEBOARD_TYPES]];
 5955:       if (!type)
 5955:         continue;
 3066: 
 7101:       // Read data off the clipboard
 7101:       NSData *pasteboardData = GetDataFromPasteboard(cocoaPasteboard, type);
 6879:       if (!pasteboardData)
 6879:         continue;
 6879: 
 5955:       // Figure out what type we're converting to
 5955:       CFStringRef outputType = NULL; 
 5955:       if (flavorStr.EqualsLiteral(kJPEGImageMime))
 5955:         outputType = CFSTR("public.jpeg");
 5955:       else if (flavorStr.EqualsLiteral(kPNGImageMime))
 5955:         outputType = CFSTR("public.png");
 5955:       else if (flavorStr.EqualsLiteral(kGIFImageMime))
 5955:         outputType = CFSTR("com.compuserve.gif");
 5955:       else
 5955:         continue;
 5955: 
 5955:       // Use ImageIO to interpret the data on the clipboard and transcode.
 5955:       // Note that ImageIO, like all CF APIs, allows NULLs to propagate freely
 5955:       // and safely in most cases (like ObjC). A notable exception is CFRelease.
 5955:       NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:
 5955:                                 (NSNumber*)kCFBooleanTrue, kCGImageSourceShouldAllowFloat,
 5955:                                 (type == NSTIFFPboardType ? @"public.tiff" : @"public.png"),
 5955:                                 kCGImageSourceTypeIdentifierHint, nil];
 5955: 
 5955:       CGImageSourceRef source = CGImageSourceCreateWithData((CFDataRef)pasteboardData, 
 5955:                                                             (CFDictionaryRef)options);
 5955:       NSMutableData *encodedData = [NSMutableData data];
 5955:       CGImageDestinationRef dest = CGImageDestinationCreateWithData((CFMutableDataRef)encodedData,
 5955:                                                                     outputType,
 5955:                                                                     1, NULL);
 5955:       CGImageDestinationAddImageFromSource(dest, source, 0, NULL);
 5955:       PRBool successfullyConverted = CGImageDestinationFinalize(dest);
 5955: 
 5955:       if (successfullyConverted) {
 5955:         // Put the converted data in a form Gecko can understand
 5955:         nsCOMPtr<nsIInputStream> byteStream;
 5955:         NS_NewByteInputStream(getter_AddRefs(byteStream), (const char*)[encodedData bytes],
 5955:                                    [encodedData length], NS_ASSIGNMENT_COPY);
 5955:   
 6879:         aTransferable->SetTransferData(flavorStr, byteStream, sizeof(nsIInputStream*));
 5955:       }
 5955: 
 5955:       if (dest)
 5955:         CFRelease(dest);
 5955:       if (source)
 5955:         CFRelease(source);
 5955:       
 5955:       if (successfullyConverted)
 3066:         break;
 5955:       else
 5955:         continue;
 3066:     }
 3066:   }
 3066: 
 3066:   return NS_OK;
11831: 
11831:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 2842: }
 2842: 
36983: NS_IMETHODIMP
36983: nsClipboard::GetNativeClipboardData(nsITransferable* aTransferable, PRInt32 aWhichClipboard)
36983: {
36983:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
36983: 
36983:   if ((aWhichClipboard != kGlobalClipboard) || !aTransferable)
36983:     return NS_ERROR_FAILURE;
36983: 
36983:   NSPasteboard* cocoaPasteboard = [NSPasteboard generalPasteboard];
36983:   if (!cocoaPasteboard)
36983:     return NS_ERROR_FAILURE;
36983: 
36983:   // get flavor list that includes all acceptable flavors (including ones obtained through conversion)
36983:   nsCOMPtr<nsISupportsArray> flavorList;
36983:   nsresult rv = aTransferable->FlavorsTransferableCanImport(getter_AddRefs(flavorList));
36983:   if (NS_FAILED(rv))
36983:     return NS_ERROR_FAILURE;
36983: 
36983:   PRUint32 flavorCount;
36983:   flavorList->Count(&flavorCount);
36983: 
36983:   // If we were the last ones to put something on the pasteboard, then just use the cached
36983:   // transferable. Otherwise clear it because it isn't relevant any more.
36983:   if (mChangeCount == [cocoaPasteboard changeCount]) {
36983:     if (mTransferable) {
36983:       for (PRUint32 i = 0; i < flavorCount; i++) {
36983:         nsCOMPtr<nsISupports> genericFlavor;
36983:         flavorList->GetElementAt(i, getter_AddRefs(genericFlavor));
36983:         nsCOMPtr<nsISupportsCString> currentFlavor(do_QueryInterface(genericFlavor));
36983:         if (!currentFlavor)
36983:           continue;
36983: 
36983:         nsXPIDLCString flavorStr;
36983:         currentFlavor->ToString(getter_Copies(flavorStr));
36983: 
36983:         nsCOMPtr<nsISupports> dataSupports;
36983:         PRUint32 dataSize = 0;
36983:         rv = mTransferable->GetTransferData(flavorStr, getter_AddRefs(dataSupports), &dataSize);
36983:         if (NS_SUCCEEDED(rv)) {
36983:           aTransferable->SetTransferData(flavorStr, dataSupports, dataSize);
36983:           return NS_OK; // maybe try to fill in more types? Is there a point?
36983:         }
36983:       }
36983:     }
36983:   }
36983:   else {
36983:     nsBaseClipboard::EmptyClipboard(kGlobalClipboard);
36983:   }
36983: 
36983:   // at this point we can't satisfy the request from cache data so let's look
36983:   // for things other people put on the system clipboard
36983: 
36983:   return nsClipboard::TransferableFromPasteboard(aTransferable, cocoaPasteboard);
36983: 
36983:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
36983: }
36983: 
 3109: // returns true if we have *any* of the passed in flavors available for pasting
 2842: NS_IMETHODIMP
 8229: nsClipboard::HasDataMatchingFlavors(const char** aFlavorList, PRUint32 aLength,
 8229:                                     PRInt32 aWhichClipboard, PRBool* outResult)
 2842: {
11831:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11831: 
 2842:   *outResult = PR_FALSE;
 2842: 
 2842:   if ((aWhichClipboard != kGlobalClipboard) || !aFlavorList)
 2842:     return NS_OK;
 2842: 
 3109:   // first see if we have data for this in our cached transferable
 3109:   if (mTransferable) {    
 3109:     nsCOMPtr<nsISupportsArray> transferableFlavorList;
 3109:     nsresult rv = mTransferable->FlavorsTransferableCanImport(getter_AddRefs(transferableFlavorList));
 3109:     if (NS_SUCCEEDED(rv)) {
 3109:       PRUint32 transferableFlavorCount;
 3109:       transferableFlavorList->Count(&transferableFlavorCount);
 3109:       for (PRUint32 j = 0; j < transferableFlavorCount; j++) {
 3109:         nsCOMPtr<nsISupports> transferableFlavorSupports;
 3109:         transferableFlavorList->GetElementAt(j, getter_AddRefs(transferableFlavorSupports));
 3109:         nsCOMPtr<nsISupportsCString> currentTransferableFlavor(do_QueryInterface(transferableFlavorSupports));
 3109:         if (!currentTransferableFlavor)
 3109:           continue;
 3109:         nsXPIDLCString transferableFlavorStr;
 3109:         currentTransferableFlavor->ToString(getter_Copies(transferableFlavorStr));
 3109: 
 8229:         for (PRUint32 k = 0; k < aLength; k++) {
 8229:           if (transferableFlavorStr.Equals(aFlavorList[k])) {
 3109:             *outResult = PR_TRUE;
 3109:             return NS_OK;
 3109:           }
 3109:         }
 3109:       }      
 3109:     }    
 3109:   }
 3109: 
 2842:   NSPasteboard* generalPBoard = [NSPasteboard generalPasteboard];
 2842: 
 8229:   for (PRUint32 i = 0; i < aLength; i++) {
21404:     nsDependentCString mimeType(aFlavorList[i]);
21404:     const NSString *pboardType;
21404: 
21404:     if (nsClipboard::IsStringType(mimeType, &pboardType)) {
21404:       NSString* availableType = [generalPBoard availableTypeFromArray:[NSArray arrayWithObject:pboardType]];
21404:       if (availableType && [availableType isEqualToString:pboardType]) {
 2842:         *outResult = PR_TRUE;
 2842:         break;
 2842:       }
 8229:     } else if (!strcmp(aFlavorList[i], kJPEGImageMime) ||
 8229:                !strcmp(aFlavorList[i], kPNGImageMime) ||
 8229:                !strcmp(aFlavorList[i], kGIFImageMime)) {
 5955:       NSString* availableType = [generalPBoard availableTypeFromArray:
 5955:                                   [NSArray arrayWithObjects:IMAGE_PASTEBOARD_TYPES]];
 5955:       if (availableType) {
 5955:         *outResult = PR_TRUE;
 5955:         break;
 5955:       }
 2842:     }
 2842:   }
 2842: 
 2842:   return NS_OK;
11831: 
11831:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 2842: }
 2842: 
 3066: // This function converts anything that other applications might understand into the system format
 3066: // and puts it into a dictionary which it returns.
 2842: // static
 2842: NSDictionary* 
 2842: nsClipboard::PasteboardDictFromTransferable(nsITransferable* aTransferable)
 2842: {
11831:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11831: 
 2842:   if (!aTransferable)
 2842:     return nil;
 2842: 
 2842:   NSMutableDictionary* pasteboardOutputDict = [NSMutableDictionary dictionary];
    1: 
    1:   nsCOMPtr<nsISupportsArray> flavorList;
 2842:   nsresult rv = aTransferable->FlavorsTransferableCanExport(getter_AddRefs(flavorList));
    1:   if (NS_FAILED(rv))
 2842:     return nil;
    1: 
    1:   PRUint32 flavorCount;
    1:   flavorList->Count(&flavorCount);
    1:   for (PRUint32 i = 0; i < flavorCount; i++) {
    1:     nsCOMPtr<nsISupports> genericFlavor;
    1:     flavorList->GetElementAt(i, getter_AddRefs(genericFlavor));
    1:     nsCOMPtr<nsISupportsCString> currentFlavor(do_QueryInterface(genericFlavor));
    1:     if (!currentFlavor)
    1:       continue;
    1: 
    1:     nsXPIDLCString flavorStr;
    1:     currentFlavor->ToString(getter_Copies(flavorStr));
    1: 
 3545:     PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("writing out clipboard data of type %s (%d)\n", flavorStr.get(), i));
    1: 
21404:     const NSString *pboardType;
21404: 
21404:     if (nsClipboard::IsStringType(flavorStr, &pboardType)) {
 3066:       void* data = nsnull;
 3066:       PRUint32 dataSize = 0;
 3066:       nsCOMPtr<nsISupports> genericDataWrapper;
 3066:       rv = aTransferable->GetTransferData(flavorStr, getter_AddRefs(genericDataWrapper), &dataSize);
 3066:       nsPrimitiveHelpers::CreateDataFromPrimitive(flavorStr, genericDataWrapper, &data, dataSize);
 3066:       
 3066:       NSString* nativeString = [NSString stringWithCharacters:(const unichar*)data length:(dataSize / sizeof(PRUnichar))];
 3066:       // be nice to Carbon apps, normalize the receiver's contents using Form C.
 3066:       nativeString = [nativeString precomposedStringWithCanonicalMapping];
21404: 
21404:       [pasteboardOutputDict setObject:nativeString forKey:pboardType];
 3066:       
 3066:       nsMemory::Free(data);
 3066:     }
 3066:     else if (flavorStr.EqualsLiteral(kPNGImageMime) || flavorStr.EqualsLiteral(kJPEGImageMime) ||
 3066:              flavorStr.EqualsLiteral(kGIFImageMime) || flavorStr.EqualsLiteral(kNativeImageMime)) {
    1:       PRUint32 dataSize = 0;
    1:       nsCOMPtr<nsISupports> transferSupports;
 2842:       aTransferable->GetTransferData(flavorStr, getter_AddRefs(transferSupports), &dataSize);
    1:       nsCOMPtr<nsISupportsInterfacePointer> ptrPrimitive(do_QueryInterface(transferSupports));
    1:       if (!ptrPrimitive)
    1:         continue;
    1: 
    1:       nsCOMPtr<nsISupports> primitiveData;
    1:       ptrPrimitive->GetData(getter_AddRefs(primitiveData));
    1: 
30479:       nsCOMPtr<imgIContainer> image(do_QueryInterface(primitiveData));
    1:       if (!image) {
30479:         NS_WARNING("Image isn't an imgIContainer in transferable");
    1:         continue;
    1:       }
    1: 
39829:       nsRefPtr<gfxImageSurface> frame;
39829:       rv = image->CopyFrame(  imgIContainer::FRAME_CURRENT,
39829:                               imgIContainer::FLAG_SYNC_DECODE,
39829:                               getter_AddRefs(frame));
39829:       if (NS_FAILED(rv) || !frame) {
39829:         continue;
39829:       }      
39390:       CGImageRef imageRef = NULL;
39829:       nsresult rv = nsCocoaUtils::CreateCGImageFromSurface(frame, &imageRef);
39390:       if (NS_FAILED(rv) || !imageRef) {
    1:         continue;
39390:       }
    1:       
11241:       // Convert the CGImageRef to TIFF data.
11241:       CFMutableDataRef tiffData = CFDataCreateMutable(kCFAllocatorDefault, 0);
11241:       CGImageDestinationRef destRef = CGImageDestinationCreateWithData(tiffData,
11241:                                                                        CFSTR("public.tiff"),
11241:                                                                        1,
11241:                                                                        NULL);
11241:       CGImageDestinationAddImage(destRef, imageRef, NULL);
11241:       PRBool successfullyConverted = CGImageDestinationFinalize(destRef);
11241: 
 7753:       CGImageRelease(imageRef);
11241:       if (destRef)
11241:         CFRelease(destRef);
 5451: 
30479:       if (!successfullyConverted) {
11241:         if (tiffData)
11241:           CFRelease(tiffData);
11241:         continue;
11241:       }
11241: 
11241:       [pasteboardOutputDict setObject:(NSMutableData*)tiffData forKey:NSTIFFPboardType];
11241:       if (tiffData)
11241:         CFRelease(tiffData);
    1:     }
 3680:     else if (flavorStr.EqualsLiteral(kFilePromiseMime)) {
 3680:       [pasteboardOutputDict setObject:[NSArray arrayWithObject:@""] forKey:NSFilesPromisePboardType];      
 3680:     }
 6263:     else if (flavorStr.EqualsLiteral(kURLMime)) {
 6263:       PRUint32 len = 0;
 6263:       nsCOMPtr<nsISupports> genericURL;
 6263:       rv = aTransferable->GetTransferData(flavorStr, getter_AddRefs(genericURL), &len);
 6263:       nsCOMPtr<nsISupportsString> urlObject(do_QueryInterface(genericURL));
    1: 
 6263:       nsAutoString url;
 6263:       urlObject->GetData(url);
 6263: 
 6263:       // A newline embedded in the URL means that the form is actually URL + title.
 6263:       PRInt32 newlinePos = url.FindChar(PRUnichar('\n'));
 6263:       if (newlinePos >= 0) {
 6263:         url.Truncate(newlinePos);
 6263: 
 6263:         nsAutoString urlTitle;
 6263:         urlObject->GetData(urlTitle);
 6263:         urlTitle.Mid(urlTitle, newlinePos + 1, len - (newlinePos + 1));
 6263: 
 6263:         NSString *nativeTitle = [[NSString alloc] initWithCharacters:urlTitle.get() length:urlTitle.Length()];
 6263:         // be nice to Carbon apps, normalize the receiver's contents using Form C.
 6273:         [pasteboardOutputDict setObject:[nativeTitle precomposedStringWithCanonicalMapping] forKey:kCorePboardType_urln];
 6387:         // Also put the title out as 'urld', since some recipients will look for that.
 6387:         [pasteboardOutputDict setObject:[nativeTitle precomposedStringWithCanonicalMapping] forKey:kCorePboardType_urld];
 6263:         [nativeTitle release];
 6263:       }
 6263: 
 6263:       // The Finder doesn't like getting random binary data aka
 6263:       // Unicode, so change it into an escaped URL containing only
 6263:       // ASCII.
 6263:       nsCAutoString utf8Data = NS_ConvertUTF16toUTF8(url.get(), url.Length());
 6263:       nsCAutoString escData;
 6263:       NS_EscapeURL(utf8Data.get(), utf8Data.Length(), esc_OnlyNonASCII|esc_AlwaysCopy, escData);
 6263: 
 6263:       // printf("Escaped url is %s, length %d\n", escData.get(), escData.Length());
 6263: 
 6263:       NSString *nativeURL = [NSString stringWithUTF8String:escData.get()];
 6273:       [pasteboardOutputDict setObject:nativeURL forKey:kCorePboardType_url];
 6263:     }
 3066:     // If it wasn't a type that we recognize as exportable we don't put it on the system
 3066:     // clipboard. We'll just access it from our cached transferable when we need it.
    1:   }
    1: 
 2842:   return pasteboardOutputDict;
11831: 
11831:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
21404: 
21404: PRBool nsClipboard::IsStringType(const nsCString& aMIMEType, const NSString** aPasteboardType)
21404: {
21404:   if (aMIMEType.EqualsLiteral(kUnicodeMime) ||
21404:       aMIMEType.EqualsLiteral(kHTMLMime)) {
21404:     if (aMIMEType.EqualsLiteral(kUnicodeMime))
21404:       *aPasteboardType = NSStringPboardType;
21404:     else
21404:       *aPasteboardType = NSHTMLPboardType;
21404:     return PR_TRUE;
21404:   } else {
21404:     return PR_FALSE;
21404:   }
21404: }
23217: 
23217: NSString* nsClipboard::WrapHtmlForSystemPasteboard(NSString* aString)
23217: {
23217:   NSString* wrapped =
23217:     [NSString stringWithFormat:
23217:       @"<html>"
23217:          "<head>"
23217:            "<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">"
23217:          "</head>"
23217:          "<body>"
23217:            "%@"
23217:          "</body>"
23217:        "</html>", aString];
23217:   return wrapped;
23217: }
