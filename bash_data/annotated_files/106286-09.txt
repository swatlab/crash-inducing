     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef __selectionstate_h__
     1: #define __selectionstate_h__
     1: 
     1: #include "nsCOMPtr.h"
104487: #include "nsIDOMNode.h"
104487: #include "nsINode.h"
 27986: #include "nsTArray.h"
104487: #include "nscore.h"
104487: #include "prtypes.h"
     1: 
104487: class nsCycleCollectionTraversalCallback;
     1: class nsIDOMCharacterData;
104487: class nsIDOMRange;
     1: class nsISelection;
 86939: class nsRange;
106286: namespace mozilla {
106286: class Selection;
106286: }
     1: 
     1: /***************************************************************************
     1:  * class for recording selection info.  stores selection as collection of
     1:  * { {startnode, startoffset} , {endnode, endoffset} } tuples.  Can't store
     1:  * ranges since dom gravity will possibly change the ranges.
     1:  */
     1: 
     1: // first a helper struct for saving/setting ranges
     1: struct nsRangeStore 
     1: {
     1:   nsRangeStore();
     1:   ~nsRangeStore();
     1:   nsresult StoreRange(nsIDOMRange *aRange);
 86939:   nsresult GetRange(nsRange** outRange);
     1: 
104447:   NS_INLINE_DECL_REFCOUNTING(nsRangeStore)
104447:         
     1:   nsCOMPtr<nsIDOMNode> startNode;
     1:   PRInt32              startOffset;
     1:   nsCOMPtr<nsIDOMNode> endNode;
     1:   PRInt32              endOffset;
     1:   // DEBUG:   static PRInt32 n;
     1: };
     1: 
     1: class nsSelectionState
     1: {
     1:   public:
     1:       
     1:     nsSelectionState();
     1:     ~nsSelectionState();
     1: 
 28154:     void DoTraverse(nsCycleCollectionTraversalCallback &cb);
 28154:     void DoUnlink() { MakeEmpty(); }
 28154:   
106286:     void     SaveSelection(mozilla::Selection *aSel);
     1:     nsresult RestoreSelection(nsISelection *aSel);
 79445:     bool     IsCollapsed();
 79445:     bool     IsEqual(nsSelectionState *aSelState);
     1:     void     MakeEmpty();
 79445:     bool     IsEmpty();
     1:   protected:    
104447:     nsTArray<nsRefPtr<nsRangeStore> > mArray;
     1:     
     1:     friend class nsRangeUpdater;
     1: };
     1: 
     1: class nsRangeUpdater
     1: {
     1:   public:    
     1:   
     1:     nsRangeUpdater();
     1:     ~nsRangeUpdater();
     1:   
     1:     void RegisterRangeItem(nsRangeStore *aRangeItem);
     1:     void DropRangeItem(nsRangeStore *aRangeItem);
     1:     nsresult RegisterSelectionState(nsSelectionState &aSelState);
     1:     nsresult DropSelectionState(nsSelectionState &aSelState);
     1:     
     1:     // editor selection gravity routines.  Note that we can't always depend on
     1:     // DOM Range gravity to do what we want to the "real" selection.  For instance,
     1:     // if you move a node, that corresponds to deleting it and reinserting it.
     1:     // DOM Range gravity will promote the selection out of the node on deletion,
     1:     // which is not what you want if you know you are reinserting it.
     1:     nsresult SelAdjCreateNode(nsIDOMNode *aParent, PRInt32 aPosition);
     1:     nsresult SelAdjInsertNode(nsIDOMNode *aParent, PRInt32 aPosition);
103678:     void     SelAdjDeleteNode(nsIDOMNode *aNode);
     1:     nsresult SelAdjSplitNode(nsIDOMNode *aOldRightNode, PRInt32 aOffset, nsIDOMNode *aNewLeftNode);
     1:     nsresult SelAdjJoinNodes(nsIDOMNode *aLeftNode, 
     1:                              nsIDOMNode *aRightNode, 
     1:                              nsIDOMNode *aParent, 
     1:                              PRInt32 aOffset,
     1:                              PRInt32 aOldLeftNodeLength);
     1:     nsresult SelAdjInsertText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, const nsAString &aString);
     1:     nsresult SelAdjDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, PRInt32 aLength);
     1:     // the following gravity routines need will/did sandwiches, because the other gravity
     1:     // routines will be called inside of these sandwiches, but should be ignored.
     1:     nsresult WillReplaceContainer();
     1:     nsresult DidReplaceContainer(nsIDOMNode *aOriginalNode, nsIDOMNode *aNewNode);
     1:     nsresult WillRemoveContainer();
     1:     nsresult DidRemoveContainer(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aOffset, PRUint32 aNodeOrigLen);
     1:     nsresult WillInsertContainer();
     1:     nsresult DidInsertContainer();
     1:     nsresult WillMoveNode();
     1:     nsresult DidMoveNode(nsIDOMNode *aOldParent, PRInt32 aOldOffset, nsIDOMNode *aNewParent, PRInt32 aNewOffset);
     1:   protected:    
104447:     nsTArray<nsRefPtr<nsRangeStore> > mArray;
 79445:     bool mLock;
     1: };
     1: 
     1: 
     1: /***************************************************************************
     1:  * helper class for using nsSelectionState.  stack based class for doing
     1:  * preservation of dom points across editor actions
     1:  */
     1: 
 15596: class NS_STACK_CLASS nsAutoTrackDOMPoint
     1: {
     1:   private:
     1:     nsRangeUpdater &mRU;
     1:     nsCOMPtr<nsIDOMNode> *mNode;
     1:     PRInt32 *mOffset;
104447:     nsRefPtr<nsRangeStore> mRangeItem;
     1:   public:
     1:     nsAutoTrackDOMPoint(nsRangeUpdater &aRangeUpdater, nsCOMPtr<nsIDOMNode> *aNode, PRInt32 *aOffset) :
     1:     mRU(aRangeUpdater)
     1:     ,mNode(aNode)
     1:     ,mOffset(aOffset)
     1:     {
104447:       mRangeItem = new nsRangeStore();
104447:       mRangeItem->startNode = *mNode;
104447:       mRangeItem->endNode = *mNode;
104447:       mRangeItem->startOffset = *mOffset;
104447:       mRangeItem->endOffset = *mOffset;
104447:       mRU.RegisterRangeItem(mRangeItem);
     1:     }
     1:     
     1:     ~nsAutoTrackDOMPoint()
     1:     {
104447:       mRU.DropRangeItem(mRangeItem);
104447:       *mNode  = mRangeItem->startNode;
104447:       *mOffset = mRangeItem->startOffset;
     1:     }
     1: };
     1: 
     1: 
     1: 
     1: /***************************************************************************
     1:  * another helper class for nsSelectionState.  stack based class for doing
     1:  * Will/DidReplaceContainer()
     1:  */
     1: 
 15596: class NS_STACK_CLASS nsAutoReplaceContainerSelNotify
     1: {
     1:   private:
     1:     nsRangeUpdater &mRU;
     1:     nsIDOMNode *mOriginalNode;
     1:     nsIDOMNode *mNewNode;
     1: 
     1:   public:
     1:     nsAutoReplaceContainerSelNotify(nsRangeUpdater &aRangeUpdater, nsIDOMNode *aOriginalNode, nsIDOMNode *aNewNode) :
     1:     mRU(aRangeUpdater)
     1:     ,mOriginalNode(aOriginalNode)
     1:     ,mNewNode(aNewNode)
     1:     {
     1:       mRU.WillReplaceContainer();
     1:     }
     1:     
     1:     ~nsAutoReplaceContainerSelNotify()
     1:     {
     1:       mRU.DidReplaceContainer(mOriginalNode, mNewNode);
     1:     }
     1: };
     1: 
     1: 
     1: /***************************************************************************
     1:  * another helper class for nsSelectionState.  stack based class for doing
     1:  * Will/DidRemoveContainer()
     1:  */
     1: 
 15596: class NS_STACK_CLASS nsAutoRemoveContainerSelNotify
     1: {
     1:   private:
     1:     nsRangeUpdater &mRU;
     1:     nsIDOMNode *mNode;
     1:     nsIDOMNode *mParent;
     1:     PRInt32    mOffset;
     1:     PRUint32   mNodeOrigLen;
     1: 
     1:   public:
     1:     nsAutoRemoveContainerSelNotify(nsRangeUpdater& aRangeUpdater,
101121:                                    nsINode* aNode,
101121:                                    nsINode* aParent,
     1:                                    PRInt32 aOffset,
101121:                                    PRUint32 aNodeOrigLen)
101121:       : mRU(aRangeUpdater)
101121:       , mNode(aNode->AsDOMNode())
101121:       , mParent(aParent->AsDOMNode())
     1:       , mOffset(aOffset)
     1:       , mNodeOrigLen(aNodeOrigLen)
     1:     {
     1:       mRU.WillRemoveContainer();
     1:     }
     1:     
     1:     ~nsAutoRemoveContainerSelNotify()
     1:     {
     1:       mRU.DidRemoveContainer(mNode, mParent, mOffset, mNodeOrigLen);
     1:     }
     1: };
     1: 
     1: /***************************************************************************
     1:  * another helper class for nsSelectionState.  stack based class for doing
     1:  * Will/DidInsertContainer()
     1:  */
     1: 
 15596: class NS_STACK_CLASS nsAutoInsertContainerSelNotify
     1: {
     1:   private:
     1:     nsRangeUpdater &mRU;
     1: 
     1:   public:
     1:     nsAutoInsertContainerSelNotify(nsRangeUpdater &aRangeUpdater) :
     1:     mRU(aRangeUpdater)
     1:     {
     1:       mRU.WillInsertContainer();
     1:     }
     1:     
     1:     ~nsAutoInsertContainerSelNotify()
     1:     {
     1:       mRU.DidInsertContainer();
     1:     }
     1: };
     1: 
     1: 
     1: /***************************************************************************
     1:  * another helper class for nsSelectionState.  stack based class for doing
     1:  * Will/DidMoveNode()
     1:  */
     1: 
 15596: class NS_STACK_CLASS nsAutoMoveNodeSelNotify
     1: {
     1:   private:
     1:     nsRangeUpdater &mRU;
     1:     nsIDOMNode *mOldParent;
     1:     nsIDOMNode *mNewParent;
     1:     PRInt32    mOldOffset;
     1:     PRInt32    mNewOffset;
     1: 
     1:   public:
     1:     nsAutoMoveNodeSelNotify(nsRangeUpdater &aRangeUpdater, 
     1:                             nsIDOMNode *aOldParent, 
     1:                             PRInt32 aOldOffset, 
     1:                             nsIDOMNode *aNewParent, 
     1:                             PRInt32 aNewOffset) :
     1:     mRU(aRangeUpdater)
     1:     ,mOldParent(aOldParent)
     1:     ,mNewParent(aNewParent)
     1:     ,mOldOffset(aOldOffset)
     1:     ,mNewOffset(aNewOffset)
     1:     {
     1:       mRU.WillMoveNode();
     1:     }
     1:     
     1:     ~nsAutoMoveNodeSelNotify()
     1:     {
     1:       mRU.DidMoveNode(mOldParent, mOldOffset, mNewParent, mNewOffset);
     1:     }
     1: };
     1: 
     1: #endif
     1: 
     1: 
