52880: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52880:  * vim: set ts=4 sw=4 et tw=99:
52880:  *
52880:  * ***** BEGIN LICENSE BLOCK *****
52880:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52880:  *
52880:  * The contents of this file are subject to the Mozilla Public License Version
52880:  * 1.1 (the "License"); you may not use this file except in compliance with
52880:  * the License. You may obtain a copy of the License at
52880:  * http://www.mozilla.org/MPL/
52880:  *
52880:  * Software distributed under the License is distributed on an "AS IS" basis,
52880:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52880:  * for the specific language governing rights and limitations under the
52880:  * License.
52880:  *
52880:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52880:  * May 28, 2008.
52880:  *
52880:  * The Initial Developer of the Original Code is
52880:  *   Brendan Eich <brendan@mozilla.org>
52880:  *
52880:  * Contributor(s):
52880:  *   David Mandelin <dmandelin@mozilla.com>
52880:  *
52880:  * Alternatively, the contents of this file may be used under the terms of
52880:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52880:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52880:  * in which case the provisions of the GPL or the LGPL are applicable instead
52880:  * of those above. If you wish to allow use of your version of this file only
52880:  * under the terms of either the GPL or the LGPL, and not to allow others to
52880:  * use your version of this file under the terms of the MPL, indicate your
52880:  * decision by deleting the provisions above and replace them with the notice
52880:  * and other provisions required by the GPL or the LGPL. If you do not delete
52880:  * the provisions above, a recipient may use your version of this file under
52880:  * the terms of any one of the MPL, the GPL or the LGPL.
52880:  *
52880:  * ***** END LICENSE BLOCK ***** */
52880: #include "PolyIC.h"
52880: #include "StubCalls.h"
52880: #include "CodeGenIncludes.h"
52880: #include "StubCalls-inl.h"
52880: #include "assembler/assembler/LinkBuffer.h"
52880: #include "jsscope.h"
52880: #include "jsnum.h"
53081: #include "jsobjinlines.h"
52880: #include "jsscopeinlines.h"
52896: #include "jspropertycache.h"
52896: #include "jspropertycacheinlines.h"
53089: #include "jsautooplen.h"
52880: 
53270: #if defined JS_POLYIC
53270: 
52880: using namespace js;
52880: using namespace js::mjit;
53270: using namespace js::mjit::ic;
52880: 
52880: /* Rough over-estimate of how much memory we need to unprotect. */
52880: static const uint32 INLINE_PATH_LENGTH = 64;
52880: 
52880: typedef JSC::FunctionPtr FunctionPtr;
52880: typedef JSC::RepatchBuffer RepatchBuffer;
52880: typedef JSC::CodeBlock CodeBlock;
52880: typedef JSC::CodeLocationLabel CodeLocationLabel;
52880: typedef JSC::JITCode JITCode;
52880: typedef JSC::MacroAssembler::Jump Jump;
52880: typedef JSC::MacroAssembler::RegisterID RegisterID;
52880: typedef JSC::MacroAssembler::Label Label;
52880: typedef JSC::MacroAssembler::Imm32 Imm32;
52884: typedef JSC::MacroAssembler::ImmPtr ImmPtr;
52880: typedef JSC::MacroAssembler::Address Address;
52880: typedef JSC::ReturnAddressPtr ReturnAddressPtr;
52880: typedef JSC::MacroAssemblerCodePtr MacroAssemblerCodePtr;
52880: 
53137: class AutoPropertyDropper
52880: {
52880:     JSContext *cx;
52880:     JSObject *holder;
52880:     JSProperty *prop;
52880: 
52880:   public:
52880:     AutoPropertyDropper(JSContext *cx, JSObject *obj, JSProperty *prop)
52880:       : cx(cx), holder(obj), prop(prop)
52880:     {
52880:         JS_ASSERT(prop);
52880:     }
52880: 
52880:     ~AutoPropertyDropper()
52880:     {
52880:         holder->dropProperty(cx, prop);
52880:     }
52880: };
52880: 
52880: class PICStubCompiler
52880: {
52906:   protected:
52880:     const char *type;
52880:     VMFrame &f;
52880:     JSScript *script;
52880:     ic::PICInfo &pic;
52880: 
52880:   public:
52880:     PICStubCompiler(const char *type, VMFrame &f, JSScript *script, ic::PICInfo &pic)
52880:       : type(type), f(f), script(script), pic(pic)
52880:     { }
52880: 
52880:     bool disable(const char *reason, VoidStub stub)
52880:     {
52880:         return disable(reason, JS_FUNC_TO_DATA_PTR(void *, stub));
52880:     }
52880: 
52887:     bool disable(const char *reason, VoidStubUInt32 stub)
52887:     {
52887:         return disable(reason, JS_FUNC_TO_DATA_PTR(void *, stub));
52887:     }
52887: 
52880:     bool disable(const char *reason, void *stub)
52880:     {
52880:         spew("disabled", reason);
52880:         JITCode jitCode(pic.slowPathStart.executableAddress(), INLINE_PATH_LENGTH);
52880:         CodeBlock codeBlock(jitCode);
52880:         RepatchBuffer repatcher(&codeBlock);
52880:         ReturnAddressPtr retPtr(pic.slowPathStart.callAtOffset(pic.callReturn).executableAddress());
52880:         MacroAssemblerCodePtr target(stub);
52880:         repatcher.relinkCallerToTrampoline(retPtr, target);
52880:         return true;
52880:     }
52880: 
52880:     JSC::ExecutablePool *getExecPool(size_t size)
52880:     {
53377:         mjit::ThreadData *jd = &JS_METHODJIT_DATA(f.cx);
53377:         return jd->execPool->poolForSize(size);
52880:     }
52880: 
52880:   protected:
52880:     void spew(const char *event, const char *op)
52880:     {
53487: #ifdef JS_METHODJIT_SPEW
52880:         JaegerSpew(JSpew_PICs, "%s %s: %s (%s: %d)\n",
52880:                    type, event, op, script->filename,
53482:                    js_FramePCToLineNumber(f.cx, f.fp()));
53487: #endif
52880:     }
52880: };
52880: 
52880: class PICRepatchBuffer : public JSC::RepatchBuffer
52880: {
52880:     ic::PICInfo &pic;
52889:     JSC::CodeLocationLabel label;
52880: 
52880:   public:
52889:     PICRepatchBuffer(ic::PICInfo &ic, JSC::CodeLocationLabel path)
52889:       : JSC::RepatchBuffer(path.executableAddress(), INLINE_PATH_LENGTH),
52889:         pic(ic), label(path)
52880:     { }
52880: 
52880:     void relink(int32 offset, JSC::CodeLocationLabel target) {
52889:         JSC::RepatchBuffer::relink(label.jumpAtOffset(offset), target);
52880:     }
52880: };
52880: 
52887: class SetPropCompiler : public PICStubCompiler
52887: {
52887:     JSObject *obj;
52887:     JSAtom *atom;
52887:     VoidStubUInt32 stub;
52887: 
52887:     static int32 dslotsLoadOffset(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
52887:         if (pic.u.vr.isConstant)
53270:             return SETPROP_DSLOTS_BEFORE_CONSTANT;
52887:         if (pic.u.vr.u.s.isTypeKnown)
53270:             return SETPROP_DSLOTS_BEFORE_KTYPE;
53270:         return SETPROP_DSLOTS_BEFORE_DYNAMIC;
53315: #elif defined JS_PUNBOX64
53315:         return pic.labels.setprop.dslotsLoadOffset;
53315: #endif
52887:     }
52887: 
53315: #if defined JS_NUNBOX32
52887:     inline int32 inlineTypeOffset() {
52887:         if (pic.u.vr.isConstant)
53270:             return SETPROP_INLINE_STORE_CONST_TYPE;
52887:         if (pic.u.vr.u.s.isTypeKnown)
53270:             return SETPROP_INLINE_STORE_KTYPE_TYPE;
53270:         return SETPROP_INLINE_STORE_DYN_TYPE;
52887:     }
53315: #endif
52887: 
53315: #if defined JS_NUNBOX32
52887:     inline int32 inlineDataOffset() {
52887:         if (pic.u.vr.isConstant)
53270:             return SETPROP_INLINE_STORE_CONST_DATA;
52887:         if (pic.u.vr.u.s.isTypeKnown)
53270:             return SETPROP_INLINE_STORE_KTYPE_DATA;
53270:         return SETPROP_INLINE_STORE_DYN_DATA;
52887:     }
53315: #endif
53315: 
53315:     static int32 inlineShapeOffset(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return SETPROP_INLINE_SHAPE_OFFSET;
53315: #elif defined JS_PUNBOX64
53315:         return pic.labels.setprop.inlineShapeOffset;
53315: #endif
53315:     }
53315: 
53315:     static int32 inlineShapeJump(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return SETPROP_INLINE_SHAPE_JUMP;
53315: #elif defined JS_PUNBOX64
53315:         return inlineShapeOffset(pic) + SETPROP_INLINE_SHAPE_JUMP;
53315: #endif
53315:     }
53315: 
53315:     inline int32 dslotsLoadOffset() {
53315:         return dslotsLoadOffset(pic);
53315:     }
53315: 
53315:     inline int32 inlineShapeOffset() {
53315:         return inlineShapeOffset(pic);
53315:     }
53315: 
53315:     inline int32 inlineShapeJump() {
53315:         return inlineShapeJump(pic);
53315:     }
52887: 
52887:   public:
52887:     SetPropCompiler(VMFrame &f, JSScript *script, JSObject *obj, ic::PICInfo &pic, JSAtom *atom,
52887:                     VoidStubUInt32 stub)
52887:       : PICStubCompiler("setprop", f, script, pic), obj(obj), atom(atom), stub(stub)
52887:     { }
52887: 
52887:     bool disable(const char *reason)
52887:     {
52887:         return PICStubCompiler::disable(reason, stub);
52887:     }
52887: 
52887:     static void reset(ic::PICInfo &pic)
52887:     {
52887:         RepatchBuffer repatcher(pic.fastPathStart.executableAddress(), INLINE_PATH_LENGTH);
52887:         repatcher.repatchLEAToLoadPtr(pic.storeBack.instructionAtOffset(dslotsLoadOffset(pic)));
53270:         repatcher.repatch(pic.fastPathStart.dataLabel32AtOffset(
53315:                            pic.shapeGuard + inlineShapeOffset(pic)),
53531:                           int32(JSObjectMap::INVALID_SHAPE));
53270:         repatcher.relink(pic.fastPathStart.jumpAtOffset(
53315:                           pic.shapeGuard + inlineShapeJump(pic)),
52887:                          pic.slowPathStart);
52887: 
52887:         RepatchBuffer repatcher2(pic.slowPathStart.executableAddress(), INLINE_PATH_LENGTH);
52887:         ReturnAddressPtr retPtr(pic.slowPathStart.callAtOffset(pic.callReturn).executableAddress());
52887:         MacroAssemblerCodePtr target(JS_FUNC_TO_DATA_PTR(void *, ic::SetProp));
52887:         repatcher.relinkCallerToTrampoline(retPtr, target);
52887:     }
52887: 
53531:     bool patchInline(const Shape *shape)
52887:     {
52889:         JS_ASSERT(!pic.inlinePathPatched);
52887:         JaegerSpew(JSpew_PICs, "patch setprop inline at %p\n", pic.fastPathStart.executableAddress());
52887: 
52889:         PICRepatchBuffer repatcher(pic, pic.fastPathStart);
52887: 
52887:         int32 offset;
53531:         if (shape->slot < JS_INITIAL_NSLOTS) {
52887:             JSC::CodeLocationInstruction istr;
52887:             istr = pic.storeBack.instructionAtOffset(dslotsLoadOffset());
52887:             repatcher.repatchLoadPtrToLEA(istr);
52887: 
52887:             // 
52887:             // We've patched | mov dslots, [obj + DSLOTS_OFFSET]
52887:             // To:           | lea fslots, [obj + DSLOTS_OFFSET]
52887:             //
52887:             // Because the offset is wrong, it's necessary to correct it
52887:             // below.
52887:             //
52887:             int32 diff = int32(offsetof(JSObject, fslots)) -
52887:                          int32(offsetof(JSObject, dslots));
52887:             JS_ASSERT(diff != 0);
53531:             offset  = (int32(shape->slot) * sizeof(Value)) + diff;
52887:         } else {
53531:             offset = (shape->slot - JS_INITIAL_NSLOTS) * sizeof(Value);
52887:         }
52887: 
53315:         uint32 shapeOffs = pic.shapeGuard + inlineShapeOffset();
53275:         repatcher.repatch(pic.fastPathStart.dataLabel32AtOffset(shapeOffs), obj->shape());
53315: #if defined JS_NUNBOX32
53275:         repatcher.repatch(pic.storeBack.dataLabel32AtOffset(inlineTypeOffset()), offset + 4);
53275:         repatcher.repatch(pic.storeBack.dataLabel32AtOffset(inlineDataOffset()), offset);
53315: #elif defined JS_PUNBOX64
53315:         repatcher.repatch(pic.storeBack.dataLabel32AtOffset(SETPROP_INLINE_STORE_VALUE), offset);
53315: #endif
52887: 
52887:         pic.inlinePathPatched = true;
52887: 
52887:         return true;
52887:     }
52887: 
52887:     void patchPreviousToHere(PICRepatchBuffer &repatcher, CodeLocationLabel cs)
52887:     {
52887:         // Patch either the inline fast path or a generated stub. The stub
52887:         // omits the prefix of the inline fast path that loads the shape, so
52887:         // the offsets are different.
52887:         int shapeGuardJumpOffset;
52887:         if (pic.stubsGenerated)
53315: #if defined JS_NUNBOX32
53270:             shapeGuardJumpOffset = SETPROP_STUB_SHAPE_JUMP;
53315: #elif defined JS_PUNBOX64
53315:             shapeGuardJumpOffset = pic.labels.setprop.stubShapeJump;
53315: #endif
52887:         else
53315:             shapeGuardJumpOffset = pic.shapeGuard + inlineShapeJump();
52887:         repatcher.relink(shapeGuardJumpOffset, cs);
52887:     }
52887: 
53315:     // :TODO: x64 -- implement more efficient version.
53054:     void emitStore(Assembler &masm, Address address)
53054:     {
53054:         if (pic.u.vr.isConstant) {
53054:             masm.storeValue(Valueify(pic.u.vr.u.v), address);
53054:         } else {
53054:             if (pic.u.vr.u.s.isTypeKnown)
53144:                 masm.storeTypeTag(ImmType(pic.u.vr.u.s.type.knownType), address);
53054:             else
53054:                 masm.storeTypeTag(pic.u.vr.u.s.type.reg, address);
53144:             masm.storePayload(pic.u.vr.u.s.data, address);
53054:         }
53054:     }
53054: 
53650:     bool generateStub(uint32 initialShape, const Shape *shape, bool adding)
52887:     {
53620:         /* Exits to the slow path. */
53620:         Vector<Jump, 8> slowExits(f.cx);
53620: 
52887:         Assembler masm;
52887: 
52887:         // Shape guard.
53054:         if (pic.shapeNeedsRemat()) {
53054:             masm.loadShape(pic.objReg, pic.shapeReg);
53054:             pic.shapeRegHasBaseShape = true;
53054:         }
53054: 
53054:         Label start = masm.label();
53620:         Jump shapeGuard = masm.branch32_force32(Assembler::NotEqual, pic.shapeReg,
53620:                                                 Imm32(initialShape));
53620:         if (!slowExits.append(shapeGuard))
53620:             return false;
53315: 
53315: #if defined JS_NUNBOX32
53270:         DBGLABEL(dbgStubShapeJump);
53270:         JS_ASSERT(masm.differenceBetween(start, dbgStubShapeJump) == SETPROP_STUB_SHAPE_JUMP);
53315: #elif defined JS_PUNBOX64
53315:         Label stubShapeJumpLabel = masm.label();
53315: #endif
52887: 
53531:         JS_ASSERT_IF(!shape->hasDefaultSetter(), obj->getClass() == &js_CallClass);
53054: 
53054:         Jump rebrand;
53057:         Jump skipOver;
53620: 
53620:         if (adding) {
53620:             JS_ASSERT(shape->hasSlot());
53620:             pic.shapeRegHasBaseShape = false;
53620: 
53620: #ifdef JS_THREADSAFE
53620:             /* Check that the object isn't shared, so no locking needed. */
53620:             masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), pic.shapeReg);
53620:             Jump sharedObject = masm.branchPtr(Assembler::NotEqual,
53620:                                                Address(pic.objReg, offsetof(JSObject, title.ownercx)),
53620:                                                pic.shapeReg);
53620:             if (!slowExits.append(sharedObject))
53620:                 return false;
53620: #endif
53620: 
53620:             /* Emit shape guards for the object's prototype chain. */
53620:             size_t chainLength = 0;
53620:             JSObject *proto = obj->getProto();
53620:             while (proto) {
53620:                 masm.loadPtr(Address(pic.objReg, offsetof(JSObject, proto)), pic.shapeReg);
53620:                 for (size_t i = 0; i < chainLength; i++)
53620:                     masm.loadPtr(Address(pic.shapeReg, offsetof(JSObject, proto)), pic.shapeReg);
53620:                 masm.loadShape(pic.shapeReg, pic.shapeReg);
53620: 
53620:                 Jump protoGuard = masm.branch32(Assembler::NotEqual, pic.shapeReg,
53620:                                                 Imm32(proto->shape()));
53620:                 if (!slowExits.append(protoGuard))
53620:                     return false;
53620: 
53620:                 proto = proto->getProto();
53620:                 chainLength++;
53620:             }
53620: 
53620:             if (pic.kind == ic::PICInfo::SETMETHOD) {
53620:                 /*
53620:                  * Guard that the value is equal to the shape's method.
53620:                  * We already know it is a function, so test the payload.
53620:                  */
53620:                 JS_ASSERT(shape->isMethod());
53620:                 JSObject *funobj = &shape->methodObject();
53620:                 if (pic.u.vr.isConstant) {
53620:                     JS_ASSERT(funobj == &Valueify(pic.u.vr.u.v).toObject());
53620:                 } else {
53620:                     Jump mismatchedFunction =
53620:                         masm.branchPtr(Assembler::NotEqual, pic.u.vr.u.s.data, ImmPtr(funobj));
53620:                     if (!slowExits.append(mismatchedFunction))
53620:                         return false;
53620:                 }
53620:             }
53620: 
53620:             if (shape->slot < JS_INITIAL_NSLOTS) {
53620:                 Address address(pic.objReg,
53620:                                 offsetof(JSObject, fslots) + shape->slot * sizeof(Value));
53620:                 emitStore(masm, address);
53620:             } else {
53620:                 /* Check dslots non-zero. */
53620:                 masm.loadPtr(Address(pic.objReg, offsetof(JSObject, dslots)), pic.shapeReg);
53620:                 Jump emptyDslots = masm.branchPtr(Assembler::Equal, pic.shapeReg, ImmPtr(0));
53620:                 if (!slowExits.append(emptyDslots))
53620:                     return false;
53620: 
53620:                 /* Check capacity. */
53650:                 Address capacity(pic.shapeReg, -ptrdiff_t(sizeof(Value)));
53620:                 masm.load32(masm.payloadOf(capacity), pic.shapeReg);
53620:                 Jump overCapacity = masm.branch32(Assembler::LessThanOrEqual, pic.shapeReg,
53620:                                                   Imm32(shape->slot));
53620:                 if (!slowExits.append(overCapacity))
53620:                     return false;
53620: 
53620:                 masm.loadPtr(Address(pic.objReg, offsetof(JSObject, dslots)), pic.shapeReg);
53620:                 Address address(pic.shapeReg,
53620:                                 (shape->slot - JS_INITIAL_NSLOTS) * sizeof(Value));
53620:                 emitStore(masm, address);
53620:             }
53620: 
53620:             uint32 newShape = obj->shape();
53620:             JS_ASSERT(newShape != initialShape);
53620: 
53620:             /* Write the object's new shape. */
53620:             masm.storePtr(ImmPtr(shape), Address(pic.objReg, offsetof(JSObject, lastProp)));
53620:             masm.store32(Imm32(newShape), Address(pic.objReg, offsetof(JSObject, objShape)));
53620: 
53650:             /* If this is a method shape, update the object's flags. */
53650:             if (shape->isMethod()) {
53650:                 Address flags(pic.objReg, offsetof(JSObject, flags));
53650: 
53650:                 /* Use shapeReg to load, bitwise-or, and store flags. */
53650:                 masm.load32(flags, pic.shapeReg);
53650:                 masm.or32(Imm32(JSObject::METHOD_BARRIER), pic.shapeReg);
53650:                 masm.store32(pic.shapeReg, flags);
53650:             }
53620:         } else if (shape->hasDefaultSetter()) {
53531:             Address address(pic.objReg, offsetof(JSObject, fslots) + shape->slot * sizeof(Value));
53531:             if (shape->slot >= JS_INITIAL_NSLOTS) {
52887:                 masm.loadPtr(Address(pic.objReg, offsetof(JSObject, dslots)), pic.objReg);
53531:                 address = Address(pic.objReg, (shape->slot - JS_INITIAL_NSLOTS) * sizeof(Value));
52887:             }
52887: 
52890:             // If the scope is branded, or has a method barrier. It's now necessary
52890:             // to guard that we're not overwriting a function-valued property.
53531:             if (obj->brandedOrHasMethodBarrier()) {
52890:                 masm.loadTypeTag(address, pic.shapeReg);
53023:                 Jump skip = masm.testObject(Assembler::NotEqual, pic.shapeReg);
53315:                 masm.loadPayload(address, pic.shapeReg);
53023:                 rebrand = masm.testFunction(Assembler::Equal, pic.shapeReg);
53023:                 skip.linkTo(masm.label(), &masm);
53054:                 pic.shapeRegHasBaseShape = false;
52890:             }
52890: 
53054:             emitStore(masm, address);
52887:         } else {
53840:             //   \ /        In general, two function objects with different JSFunctions
53840:             //    #         can have the same shape, thus we must not rely on the identity
53840:             // >--+--<      of 'fun' remaining the same. However, since:
53840:             //   |||         1. the shape includes all arguments and locals and their setters
53840:             //    \\     V     and getters, and
53840:             //      \===/    2. arguments and locals have different getters
53840:             //              then we can rely on fun->nargs remaining invariant.
53840:             JSFunction *fun = obj->getCallObjCalleeFunction();
53531:             uint16 slot = uint16(shape->shortid);
53054: 
53054:             /* Guard that the call object has a frame. */
53157:             masm.loadFunctionPrivate(pic.objReg, pic.shapeReg);
53057:             Jump escapedFrame = masm.branchTestPtr(Assembler::Zero, pic.shapeReg, pic.shapeReg);
53054: 
53057:             {
53840:                 Address addr(pic.shapeReg, shape->setterOp() == SetCallArg
53840:                                            ? JSStackFrame::offsetOfFormalArg(fun, slot)
53840:                                            : JSStackFrame::offsetOfFixed(slot));
53840:                 emitStore(masm, addr);
53057:                 skipOver = masm.jump();
53057:             }
53057: 
53057:             escapedFrame.linkTo(masm.label(), &masm);
53057:             {
53840:                 if (shape->setterOp() == SetCallVar)
53057:                     slot += fun->nargs;
53057:                 masm.loadPtr(Address(pic.objReg, offsetof(JSObject, dslots)), pic.objReg);
53057: 
53057:                 Address dslot(pic.objReg, slot * sizeof(Value));
53057:                 emitStore(masm, dslot);
53057:             }
53057: 
53054:             pic.shapeRegHasBaseShape = false;
52887:         }
52887:         Jump done = masm.jump();
52887: 
52887:         JSC::ExecutablePool *ep = getExecPool(masm.size());
52887:         if (!ep || !pic.execPools.append(ep)) {
52887:             if (ep)
52887:                 ep->release();
52887:             js_ReportOutOfMemory(f.cx);
52887:             return false;
52887:         }
52887: 
52887:         JSC::LinkBuffer buffer(&masm, ep);
53620:         for (Jump *pj = slowExits.begin(); pj != slowExits.end(); ++pj)
53620:             buffer.link(*pj, pic.slowPathStart);
52887:         buffer.link(done, pic.storeBack);
53620:         if (!adding && shape->hasDefaultSetter() && (obj->brandedOrHasMethodBarrier()))
52890:             buffer.link(rebrand, pic.slowPathStart);
53531:         if (!shape->hasDefaultSetter())
53057:             buffer.link(skipOver, pic.storeBack);
52887:         CodeLocationLabel cs = buffer.finalizeCodeAddendum();
52887:         JaegerSpew(JSpew_PICs, "generate setprop stub %p %d %d at %p\n",
52887:                    (void*)&pic,
53620:                    initialShape,
52887:                    pic.stubsGenerated,
52887:                    cs.executableAddress());
52887: 
52889:         PICRepatchBuffer repatcher(pic, pic.lastPathStart());
52887: 
52887:         // This function can patch either the inline fast path for a generated
52887:         // stub. The stub omits the prefix of the inline fast path that loads
52887:         // the shape, so the offsets are different.
52887:         patchPreviousToHere(repatcher, cs);
52887: 
52887:         pic.stubsGenerated++;
52887:         pic.lastStubStart = buffer.locationOf(start);
52887: 
53315: #if defined JS_PUNBOX64
53315:         pic.labels.setprop.stubShapeJump = masm.differenceBetween(start, stubShapeJumpLabel);
53426:         JS_ASSERT(pic.labels.setprop.stubShapeJump == masm.differenceBetween(start, stubShapeJumpLabel));
53315: #endif
53315: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
52887:             disable("max stubs reached");
52887: 
52887:         return true;
52887:     }
52887: 
52887:     bool update()
52887:     {
52887:         if (!pic.hit) {
52887:             spew("first hit", "nop");
52887:             pic.hit = true;
52887:             return true;
52887:         }
52887: 
53620:         if (obj->isDenseArray())
53620:             return disable("dense array");
53620:         if (!obj->isNative())
52887:             return disable("non-native");
53620:         if (obj->sealed())
53620:             return disable("sealed");
53620: 
53865:         Class *clasp = obj->getClass();
53865: 
53865:         if (clasp->setProperty != PropertyStub)
53865:             return disable("set property hook");
53865:         if (clasp->ops.lookupProperty)
53865:             return disable("ops lookup property hook");
53865:         if (clasp->ops.setProperty)
53865:             return disable("ops set property hook");
53865: 
53620: #ifdef JS_THREADSAFE
53620:         if (!CX_OWNS_OBJECT_TITLE(f.cx, obj))
53620:             return disable("shared object");
53620: #endif
53620: 
53620:         jsid id = ATOM_TO_JSID(atom);
52887: 
52887:         JSObject *holder;
52887:         JSProperty *prop = NULL;
53620:         if (!obj->lookupProperty(f.cx, id, &holder, &prop))
52887:             return false;
53620: 
53620:         /* If the property exists but is on a prototype, treat as addprop. */
53620:         if (prop && holder != obj) {
53620:             AutoPropertyDropper dropper(f.cx, holder, prop);
53620:             const Shape *shape = (const Shape *) prop;
53620: 
53620:             if (!holder->isNative())
53620:                 return disable("non-native holder");
53620:             if (holder->sealed())
53620:                 return disable("sealed holder");
53620: 
53620:             if (!shape->writable())
53620:                 return disable("readonly");
53620:             if (!shape->hasDefaultSetter() || !shape->hasDefaultGetter())
53620:                 return disable("getter/setter in prototype");
53620:             if (shape->hasShortID())
53620:                 return disable("short ID in prototype");
53620:             if (!shape->hasSlot())
53620:                 return disable("missing slot");
53620: 
53620:             prop = NULL;
53620:         }
53620: 
53620:         if (!prop) {
53620:             /* Adding a property to the object. */
53620:             if (obj->isDelegate())
53620:                 return disable("delegate");
53620: 
53620:             if (clasp->addProperty != PropertyStub)
53620:                 return disable("add property hook");
53865:             if (clasp->ops.defineProperty)
53865:                 return disable("ops define property hook");
53620: 
53620:             uint32 index;
53620:             if (js_IdIsIndex(id, &index))
53620:                 return disable("index");
53620: 
53620:             uint32 initialShape = obj->shape();
53620: 
53620:             if (!obj->ensureClassReservedSlots(f.cx))
53620:                 return false;
53620: 
53620:             uint32 slots = obj->numSlots();
53620:             uintN flags = 0;
53620:             PropertyOp getter = clasp->getProperty;
53620: 
53620:             if (pic.kind == ic::PICInfo::SETMETHOD) {
53620:                 if (!obj->canHaveMethodBarrier())
53620:                     return disable("can't have method barrier");
53620: 
53620:                 JSObject *funobj = &f.regs.sp[-1].toObject();
53620:                 if (funobj != GET_FUNCTION_PRIVATE(cx, funobj))
53620:                     return disable("mismatched function");
53620: 
53620:                 flags |= Shape::METHOD;
53620:                 getter = CastAsPropertyOp(funobj);
53620:             }
53620: 
53620:             const Shape *shape =
53620:                 obj->putProperty(f.cx, id, getter, clasp->setProperty,
53620:                                  SHAPE_INVALID_SLOT, JSPROP_ENUMERATE, flags, 0);
53620: 
53620:             if (!shape)
53620:                 return false;
53620: 
53889:             /*
53889:              * Test after calling putProperty since it can switch obj into
53889:              * dictionary mode, specifically if the shape tree ancestor line
53889:              * exceeds PropertyTree::MAX_HEIGHT.
53889:              */
53889:             if (obj->inDictionaryMode())
53889:                 return disable("dictionary");
53889: 
53620:             if (!shape->hasDefaultSetter())
53620:                 return disable("adding non-default setter");
53620:             if (!shape->hasSlot())
53620:                 return disable("adding invalid slot");
53620: 
53620:             /*
53620:              * Watch for cases where the object reallocated its slots when
53620:              * adding the property, and disable the PIC.  Otherwise we will
53620:              * keep generating identical PICs as side exits are taken on the
53620:              * capacity checks.  Alternatively, we could avoid the disable
53620:              * and just not generate a stub in case there are multiple shapes
53620:              * that can flow here which don't all require reallocation.
53620:              * Doing this would cause us to walk down this same update path
53620:              * every time a reallocation is needed, however, which will
53620:              * usually be a slowdown even if there *are* other shapes that
53620:              * don't realloc.
53620:              */
53620:             if (obj->numSlots() != slots)
53620:                 return disable("insufficient slot capacity");
53620: 
53650:             return generateStub(initialShape, shape, true);
53620:         }
53582: 
53582:         AutoPropertyDropper dropper(f.cx, holder, prop);
53584: 
53582:         const Shape *shape = (const Shape *) prop;
53620:         if (pic.kind == ic::PICInfo::SETMETHOD && !shape->isMethod())
53620:             return disable("set method on non-method shape");
53582:         if (!shape->writable())
53582:             return disable("readonly");
52887: 
53531:         if (shape->hasDefaultSetter()) {
53531:             if (!shape->hasSlot())
52887:                 return disable("invalid slot");
53054:         } else {
53531:             if (shape->hasSetterValue())
53054:                 return disable("scripted setter");
53531:             if (shape->setterOp() != SetCallArg &&
53531:                 shape->setterOp() != SetCallVar) {
53054:                 return disable("setter");
53054:             }
53054:         }
52887: 
52887:         JS_ASSERT(obj == holder);
52895:         if (!pic.inlinePathPatched &&
53531:             !obj->brandedOrHasMethodBarrier() &&
53531:             shape->hasDefaultSetter() &&
52895:             !obj->isDenseArray()) {
53531:             return patchInline(shape);
52895:         } 
52895: 
53650:         return generateStub(obj->shape(), shape, false);
52887:     }
52887: };
52887: 
52880: class GetPropCompiler : public PICStubCompiler
52880: {
52880:     JSObject *obj;
52880:     JSAtom *atom;
52896:     void   *stub;
52884:     int lastStubSecondShapeGuard;
52880: 
53315:     static int32 inlineShapeOffset(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return GETPROP_INLINE_SHAPE_OFFSET;
53315: #elif defined JS_PUNBOX64
53315:         return pic.labels.getprop.inlineShapeOffset;
53315: #endif
53315:     }
53315: 
53315:     inline int32 inlineShapeOffset() {
53315:         return inlineShapeOffset(pic);
53315:     }
53315: 
53315:     static int32 inlineShapeJump(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return GETPROP_INLINE_SHAPE_JUMP;
53315: #elif defined JS_PUNBOX64
53315:         return inlineShapeOffset(pic) + GETPROP_INLINE_SHAPE_JUMP;
53315: #endif
53315:     }
53315: 
53315:     inline int32 inlineShapeJump() {
53315:         return inlineShapeJump(pic);
53315:     }
53315: 
53315:     static int32 dslotsLoad(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return GETPROP_DSLOTS_LOAD;
53315: #elif defined JS_PUNBOX64
53315:         return pic.labels.getprop.dslotsLoadOffset;
53315: #endif
53315:     }
53315: 
53315:     inline int32 dslotsLoad() {
53315:         return dslotsLoad(pic);
53315:     }
53315: 
52880:   public:
52880:     GetPropCompiler(VMFrame &f, JSScript *script, JSObject *obj, ic::PICInfo &pic, JSAtom *atom,
52880:                     VoidStub stub)
52896:       : PICStubCompiler("getprop", f, script, pic), obj(obj), atom(atom),
52896:         stub(JS_FUNC_TO_DATA_PTR(void *, stub)),
52896:         lastStubSecondShapeGuard(pic.u.get.secondShapeGuard)
52896:     { }
52896: 
52896:     GetPropCompiler(VMFrame &f, JSScript *script, JSObject *obj, ic::PICInfo &pic, JSAtom *atom,
52896:                     VoidStubUInt32 stub)
52896:       : PICStubCompiler("callprop", f, script, pic), obj(obj), atom(atom),
52896:         stub(JS_FUNC_TO_DATA_PTR(void *, stub)),
52887:         lastStubSecondShapeGuard(pic.u.get.secondShapeGuard)
52880:     { }
52880: 
52880:     static void reset(ic::PICInfo &pic)
52880:     {
52880:         RepatchBuffer repatcher(pic.fastPathStart.executableAddress(), INLINE_PATH_LENGTH);
53315:         repatcher.repatchLEAToLoadPtr(pic.storeBack.instructionAtOffset(dslotsLoad(pic)));
53270:         repatcher.repatch(pic.fastPathStart.dataLabel32AtOffset(
53315:                            pic.shapeGuard + inlineShapeOffset(pic)),
53531:                           int32(JSObjectMap::INVALID_SHAPE));
53315:         repatcher.relink(pic.fastPathStart.jumpAtOffset(pic.shapeGuard + inlineShapeJump(pic)),
52880:                          pic.slowPathStart);
53353: 
53353:         if (pic.hasTypeCheck()) {
53353:             repatcher.relink(pic.fastPathStart.jumpAtOffset(GETPROP_INLINE_TYPE_GUARD),
53479:                              pic.slowPathStart.labelAtOffset(pic.u.get.typeCheckOffset));
53353:         }
52884: 
52884:         RepatchBuffer repatcher2(pic.slowPathStart.executableAddress(), INLINE_PATH_LENGTH);
52884:         ReturnAddressPtr retPtr(pic.slowPathStart.callAtOffset(pic.callReturn).executableAddress());
53261: 
53261:         VoidStubUInt32 stub;
53298:         switch (pic.kind) {
53298:           case ic::PICInfo::GET:
53261:             stub = ic::GetProp;
53298:             break;
53298:           case ic::PICInfo::CALL:
53261:             stub = ic::CallProp;
53298:             break;
53298:           default:
53261:             JS_NOT_REACHED("invalid pic kind for GetPropCompiler::reset");
53298:             return;
53298:         }
53261: 
53261:         MacroAssemblerCodePtr target(JS_FUNC_TO_DATA_PTR(void *, stub));
52884:         repatcher.relinkCallerToTrampoline(retPtr, target);
52884:     }
52884: 
53123:     bool generateArgsLengthStub()
53123:     {
53123:         Assembler masm;
53123: 
53123:         Address clasp(pic.objReg, offsetof(JSObject, clasp));
53857:         Jump notArgs = masm.branchPtr(Assembler::NotEqual, clasp, ImmPtr(obj->getClass()));
53123: 
53650:         masm.load32(Address(pic.objReg,
53650:                             offsetof(JSObject, fslots)
53650:                             + JSObject::JSSLOT_ARGS_LENGTH * sizeof(Value)),
53123:                     pic.objReg);
53123:         masm.move(pic.objReg, pic.shapeReg);
53841:         Jump overridden = masm.branchTest32(Assembler::NonZero, pic.shapeReg, Imm32(1));
53857:         masm.rshift32(Imm32(JSObject::ARGS_PACKED_BITS_COUNT), pic.objReg);
53123:         
53315:         masm.move(ImmType(JSVAL_TYPE_INT32), pic.shapeReg);
53123:         Jump done = masm.jump();
53123: 
53123:         JSC::ExecutablePool *ep = getExecPool(masm.size());
53123:         if (!ep || !pic.execPools.append(ep)) {
53123:             if (ep)
53123:                 ep->release();
53123:             js_ReportOutOfMemory(f.cx);
53123:             return false;
53123:         }
53123: 
53123:         JSC::LinkBuffer buffer(&masm, ep);
53123:         buffer.link(notArgs, pic.slowPathStart);
53123:         buffer.link(overridden, pic.slowPathStart);
53123:         buffer.link(done, pic.storeBack);
53123: 
53123:         CodeLocationLabel start = buffer.finalizeCodeAddendum();
53123:         JaegerSpew(JSpew_PICs, "generate args length stub at %p\n",
53123:                    start.executableAddress());
53123: 
53123:         PICRepatchBuffer repatcher(pic, pic.lastPathStart());
53123:         patchPreviousToHere(repatcher, start);
53123: 
53123:         disable("args length done");
53123: 
53123:         return true;
53123:     }
53123: 
52884:     bool generateArrayLengthStub()
52884:     {
52884:         Assembler masm;
52884: 
52884:         masm.loadPtr(Address(pic.objReg, offsetof(JSObject, clasp)), pic.shapeReg);
52884:         Jump isDense = masm.branchPtr(Assembler::Equal, pic.shapeReg, ImmPtr(&js_ArrayClass));
52884:         Jump notArray = masm.branchPtr(Assembler::NotEqual, pic.shapeReg,
52884:                                        ImmPtr(&js_SlowArrayClass));
52884: 
52884:         isDense.linkTo(masm.label(), &masm);
53650:         masm.load32(Address(pic.objReg,
53650:                             offsetof(JSObject, fslots)
53650:                             + JSObject::JSSLOT_ARRAY_LENGTH * sizeof(Value)),
52884:                     pic.objReg);
52884:         Jump oob = masm.branch32(Assembler::Above, pic.objReg, Imm32(JSVAL_INT_MAX));
53315:         masm.move(ImmType(JSVAL_TYPE_INT32), pic.shapeReg);
52884:         Jump done = masm.jump();
52884: 
52884:         JSC::ExecutablePool *ep = getExecPool(masm.size());
52884:         if (!ep || !pic.execPools.append(ep)) {
52884:             if (ep)
52884:                 ep->release();
52884:             js_ReportOutOfMemory(f.cx);
52884:             return false;
52884:         }
52884: 
52884:         JSC::LinkBuffer buffer(&masm, ep);
52884:         buffer.link(notArray, pic.slowPathStart);
52884:         buffer.link(oob, pic.slowPathStart);
52884:         buffer.link(done, pic.storeBack);
52884: 
52884:         CodeLocationLabel start = buffer.finalizeCodeAddendum();
52884:         JaegerSpew(JSpew_PICs, "generate array length stub at %p\n",
52884:                    start.executableAddress());
52884: 
52889:         PICRepatchBuffer repatcher(pic, pic.lastPathStart());
52884:         patchPreviousToHere(repatcher, start);
52884: 
52884:         disable("array length done");
52884: 
52884:         return true;
52884:     }
52884: 
52907:     bool generateStringCallStub()
52907:     {
52907:         JS_ASSERT(pic.hasTypeCheck());
52907:         JS_ASSERT(pic.kind == ic::PICInfo::CALL);
52907: 
53840:         if (!f.fp()->script()->compileAndGo)
52907:             return disable("String.prototype without compile-and-go");
52907: 
52907:         JSObject *holder;
52907:         JSProperty *prop;
52907:         if (!obj->lookupProperty(f.cx, ATOM_TO_JSID(atom), &holder, &prop))
52907:             return false;
52907:         if (!prop)
52907:             return disable("property not found");
52907: 
52907:         AutoPropertyDropper dropper(f.cx, holder, prop);
53531:         const Shape *shape = (const Shape *)prop;
52907:         if (holder != obj)
52907:             return disable("proto walk on String.prototype");
53531:         if (!shape->hasDefaultGetterOrIsMethod())
52907:             return disable("getter");
53531:         if (!shape->hasSlot())
52907:             return disable("invalid slot");
52907: 
52907:         JS_ASSERT(holder->isNative());
52907: 
52907:         Assembler masm;
52907: 
52907:         /* Only strings are allowed. */
53315:         Jump notString = masm.branchPtr(Assembler::NotEqual, pic.typeReg(),
53315:                                         ImmType(JSVAL_TYPE_STRING));
52907: 
52907:         /*
52907:          * Sink pic.objReg, since we're about to lose it. This is optimistic,
52907:          * we could reload it from objRemat if we wanted.
52907:          *
52907:          * Note: This is really hacky, and relies on f.regs.sp being set
52907:          * correctly in ic::CallProp. Should we just move the store higher
52907:          * up in the fast path, or put this offset in PICInfo?
52907:          */
53482:         uint32 thisvOffset = uint32(f.regs.sp - f.fp()->slots()) - 1;
52907:         Address thisv(JSFrameReg, sizeof(JSStackFrame) + thisvOffset * sizeof(Value));
53144:         masm.storeTypeTag(ImmType(JSVAL_TYPE_STRING), thisv);
53144:         masm.storePayload(pic.objReg, thisv);
52907: 
52907:         /*
52907:          * Clobber objReg with String.prototype and do some PIC stuff. Well,
52907:          * really this is now a MIC, except it won't ever be patched, so we
52907:          * just disable the PIC at the end. :FIXME:? String.prototype probably
52907:          * does not get random shape changes.
52907:          */
52907:         masm.move(ImmPtr(obj), pic.objReg);
52907:         masm.loadShape(pic.objReg, pic.shapeReg);
52907:         Jump shapeMismatch = masm.branch32(Assembler::NotEqual, pic.shapeReg,
52907:                                            Imm32(obj->shape()));
53531:         masm.loadSlot(pic.objReg, pic.objReg, shape->slot, pic.shapeReg, pic.objReg);
52907: 
52907:         Jump done = masm.jump();
52907: 
52907:         JSC::ExecutablePool *ep = getExecPool(masm.size());
52907:         if (!ep || !pic.execPools.append(ep)) {
52907:             if (ep)
52907:                 ep->release();
52907:             js_ReportOutOfMemory(f.cx);
52907:             return false;
52907:         }
52907: 
52907:         JSC::LinkBuffer patchBuffer(&masm, ep);
52907: 
53264:         patchBuffer.link(notString, pic.slowPathStart.labelAtOffset(pic.u.get.typeCheckOffset));
52907:         patchBuffer.link(shapeMismatch, pic.slowPathStart);
52907:         patchBuffer.link(done, pic.storeBack);
52907: 
52907:         CodeLocationLabel cs = patchBuffer.finalizeCodeAddendum();
52907:         JaegerSpew(JSpew_PICs, "generate string call stub at %p\n",
52907:                    cs.executableAddress());
52907: 
52907:         /* Patch the type check to jump here. */
53353:         if (pic.hasTypeCheck()) {
52907:             RepatchBuffer repatcher(pic.fastPathStart.executableAddress(), INLINE_PATH_LENGTH);
53270:             repatcher.relink(pic.fastPathStart.jumpAtOffset(GETPROP_INLINE_TYPE_GUARD), cs);
53353:         }
52907: 
52907:         /* Disable the PIC so we don't keep generating stubs on the above shape mismatch. */
52907:         disable("generated string call stub");
52907: 
52907:         return true;
52907:     }
52907: 
52884:     bool generateStringLengthStub()
52884:     {
52887:         JS_ASSERT(pic.hasTypeCheck());
52884: 
52884:         Assembler masm;
53315:         Jump notString = masm.branchPtr(Assembler::NotEqual, pic.typeReg(),
53315:                                         ImmType(JSVAL_TYPE_STRING));
53125:         masm.loadPtr(Address(pic.objReg, offsetof(JSString, mLengthAndFlags)), pic.objReg);
53216:         // String length is guaranteed to be no more than 2**28, so the 32-bit operation is OK.
53216:         masm.urshift32(Imm32(JSString::FLAGS_LENGTH_SHIFT), pic.objReg);
53315:         masm.move(ImmType(JSVAL_TYPE_INT32), pic.shapeReg);
52884:         Jump done = masm.jump();
52884: 
52884:         JSC::ExecutablePool *ep = getExecPool(masm.size());
52884:         if (!ep || !pic.execPools.append(ep)) {
52884:             if (ep)
52884:                 ep->release();
52884:             js_ReportOutOfMemory(f.cx);
52884:             return false;
52884:         }
52884: 
52884:         JSC::LinkBuffer patchBuffer(&masm, ep);
53264:         patchBuffer.link(notString, pic.slowPathStart.labelAtOffset(pic.u.get.typeCheckOffset));
52884:         patchBuffer.link(done, pic.storeBack);
52884: 
52884:         CodeLocationLabel start = patchBuffer.finalizeCodeAddendum();
52884:         JaegerSpew(JSpew_PICs, "generate string length stub at %p\n",
52884:                    start.executableAddress());
52884: 
53353:         if (pic.hasTypeCheck()) {
52884:             RepatchBuffer repatcher(pic.fastPathStart.executableAddress(), INLINE_PATH_LENGTH);
53353:             repatcher.relink(pic.fastPathStart.jumpAtOffset(GETPROP_INLINE_TYPE_GUARD), start);
53353:         }
52884: 
53311:         disable("generated string length stub");
53311: 
52884:         return true;
52880:     }
52880: 
53531:     bool patchInline(JSObject *holder, const Shape *shape)
52880:     {
52880:         spew("patch", "inline");
52889:         PICRepatchBuffer repatcher(pic, pic.fastPathStart);
52880: 
52880:         int32 offset;
53531:         if (shape->slot < JS_INITIAL_NSLOTS) {
52880:             JSC::CodeLocationInstruction istr;
53315:             istr = pic.storeBack.instructionAtOffset(dslotsLoad());
52880:             repatcher.repatchLoadPtrToLEA(istr);
52880: 
52880:             // 
52880:             // We've patched | mov dslots, [obj + DSLOTS_OFFSET]
52880:             // To:           | lea fslots, [obj + DSLOTS_OFFSET]
52880:             //
52880:             // Because the offset is wrong, it's necessary to correct it
52880:             // below.
52880:             //
52880:             int32 diff = int32(offsetof(JSObject, fslots)) -
52880:                          int32(offsetof(JSObject, dslots));
52880:             JS_ASSERT(diff != 0);
53531:             offset  = (int32(shape->slot) * sizeof(Value)) + diff;
52880:         } else {
53531:             offset = (shape->slot - JS_INITIAL_NSLOTS) * sizeof(Value);
52880:         }
52880: 
53315:         uint32 shapeOffs = pic.shapeGuard + inlineShapeOffset();
53270:         repatcher.repatch(pic.fastPathStart.dataLabel32AtOffset(shapeOffs), obj->shape());
53315: #if defined JS_NUNBOX32
53270:         repatcher.repatch(pic.storeBack.dataLabel32AtOffset(GETPROP_TYPE_LOAD), offset + 4);
53270:         repatcher.repatch(pic.storeBack.dataLabel32AtOffset(GETPROP_DATA_LOAD), offset);
53315: #elif defined JS_PUNBOX64
53315:         repatcher.repatch(pic.storeBack.dataLabel32AtOffset(pic.labels.getprop.inlineValueOffset), offset);
53315: #endif
52880: 
52880:         pic.inlinePathPatched = true;
52880: 
52880:         return true;
52880:     }
52880: 
53531:     bool generateStub(JSObject *holder, const Shape *shape)
52880:     {
52880:         Vector<Jump, 8> shapeMismatches(f.cx);
52880: 
52880:         Assembler masm;
52880: 
52887:         if (pic.objNeedsRemat()) {
52887:             if (pic.objRemat() >= sizeof(JSStackFrame))
53444:                 masm.loadPayload(Address(JSFrameReg, pic.objRemat()), pic.objReg);
52884:             else
52887:                 masm.move(RegisterID(pic.objRemat()), pic.objReg);
52887:             pic.u.get.objNeedsRemat = false;
52880:         }
52895: 
52895:         Label start;
52895:         Jump shapeGuard;
53123:         Jump argsLenGuard;
52895:         if (obj->isDenseArray()) {
52895:             start = masm.label();
52895:             shapeGuard = masm.branchPtr(Assembler::NotEqual,
52895:                                         Address(pic.objReg, offsetof(JSObject, clasp)),
52895:                                         ImmPtr(obj->getClass()));
53270:             /* 
53270:              * No need to assert validity of GETPROP_STUB_SHAPE_JUMP in this case:
53270:              * the IC is disabled after a dense array hit, so no patching can occur.
53270:              */
52895:         } else {
52887:             if (pic.shapeNeedsRemat()) {
52880:                 masm.loadShape(pic.objReg, pic.shapeReg);
53054:                 pic.shapeRegHasBaseShape = true;
52880:             }
52880: 
52895:             start = masm.label();
52895:             shapeGuard = masm.branch32_force32(Assembler::NotEqual, pic.shapeReg,
52880:                                                Imm32(obj->shape()));
53315: #if defined JS_NUNBOX32
53270:             JS_ASSERT(masm.differenceBetween(start, shapeGuard) == GETPROP_STUB_SHAPE_JUMP);
53315: #endif
52895:         }
52895: 
53315: #if defined JS_PUNBOX64
53315:         Label stubShapeJumpLabel = masm.label();
53315: #endif
53315: 
53270: 
52880:         if (!shapeMismatches.append(shapeGuard))
52880:             return false;
52880: 
52880:         if (obj != holder) {
52880:             // Emit code that walks the prototype chain.
52880:             JSObject *tempObj = obj;
53081:             Address proto(pic.objReg, offsetof(JSObject, proto));
52880:             do {
52880:                 tempObj = tempObj->getProto();
53017:                 // FIXME: we should find out why this condition occurs. It is probably
53017:                 // related to PICs on globals.
53017:                 if (!tempObj)
53241:                     return disable("null object in prototype chain");
52880:                 JS_ASSERT(tempObj);
53241: 
53241:                 /* 
53241:                  * If there is a non-native along the prototype chain the shape is technically
53241:                  * invalid.
53241:                  */
53241:                 if (!tempObj->isNative())
53241:                     return disable("non-JS-native in prototype chain");
52880: 
53137:                 masm.loadPtr(proto, pic.objReg);
53054:                 pic.shapeRegHasBaseShape = false;
52887:                 pic.u.get.objNeedsRemat = true;
52880: 
52880:                 Jump j = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
52880:                 if (!shapeMismatches.append(j))
52880:                     return false;
52880:             } while (tempObj != holder);
52880: 
52880:             // Load the shape out of the holder and check it.
52880:             masm.loadShape(pic.objReg, pic.shapeReg);
52880:             Jump j = masm.branch32_force32(Assembler::NotEqual, pic.shapeReg,
52880:                                            Imm32(holder->shape()));
52880:             if (!shapeMismatches.append(j))
52880:                 return false;
52887:             pic.u.get.secondShapeGuard = masm.distanceOf(masm.label()) - masm.distanceOf(start);
52880:         } else {
53241:             JS_ASSERT(holder->isNative()); /* Precondition: already checked. */
52887:             pic.u.get.secondShapeGuard = 0;
52880:         }
52906: 
52906:         /* Load the value out of the object. */
53531:         masm.loadSlot(pic.objReg, pic.objReg, shape->slot, pic.shapeReg, pic.objReg);
52880:         Jump done = masm.jump();
52880: 
52880:         JSC::ExecutablePool *ep = getExecPool(masm.size());
52880:         if (!ep) {
52880:             js_ReportOutOfMemory(f.cx);
52880:             return false;
52880:         }
52880: 
52880:         // :TODO: this can OOM 
52880:         JSC::LinkBuffer buffer(&masm, ep);
52880: 
52880:         if (!pic.execPools.append(ep)) {
52880:             ep->release();
52880:             js_ReportOutOfMemory(f.cx);
52880:             return false;
52880:         }
52880: 
52880:         // The guard exit jumps to the original slow case.
52880:         for (Jump *pj = shapeMismatches.begin(); pj != shapeMismatches.end(); ++pj)
52880:             buffer.link(*pj, pic.slowPathStart);
52880: 
52880:         // The final exit jumps to the store-back in the inline stub.
52880:         buffer.link(done, pic.storeBack);
52880:         CodeLocationLabel cs = buffer.finalizeCodeAddendum();
52906:         JaegerSpew(JSpew_PICs, "generated %s stub at %p\n", type, cs.executableAddress());
52880: 
52889:         PICRepatchBuffer repatcher(pic, pic.lastPathStart()); 
52884:         patchPreviousToHere(repatcher, cs);
52884: 
52884:         pic.stubsGenerated++;
52884:         pic.lastStubStart = buffer.locationOf(start);
52884: 
53315: #if defined JS_PUNBOX64
53315:         pic.labels.getprop.stubShapeJump = masm.differenceBetween(start, stubShapeJumpLabel);
53426:         JS_ASSERT(pic.labels.getprop.stubShapeJump == masm.differenceBetween(start, stubShapeJumpLabel));
53315: #endif
53315: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
52884:             disable("max stubs reached");
52895:         if (obj->isDenseArray())
52895:             disable("dense array");
52884: 
52884:         return true;
52884:     }
52884: 
52884:     void patchPreviousToHere(PICRepatchBuffer &repatcher, CodeLocationLabel cs)
52884:     {
52880:         // Patch either the inline fast path or a generated stub. The stub
52880:         // omits the prefix of the inline fast path that loads the shape, so
52880:         // the offsets are different.
52880:         int shapeGuardJumpOffset;
52880:         if (pic.stubsGenerated)
53315: #if defined JS_NUNBOX32
53270:             shapeGuardJumpOffset = GETPROP_STUB_SHAPE_JUMP;
53315: #elif defined JS_PUNBOX64
53315:             shapeGuardJumpOffset = pic.labels.getprop.stubShapeJump;
53315: #endif
52880:         else
53315:             shapeGuardJumpOffset = pic.shapeGuard + inlineShapeJump();
52880:         repatcher.relink(shapeGuardJumpOffset, cs);
52880:         if (lastStubSecondShapeGuard)
52880:             repatcher.relink(lastStubSecondShapeGuard, cs);
52880:     }
52880: 
52880:     bool update()
52880:     {
52880:         if (!pic.hit) {
52880:             spew("first hit", "nop");
52880:             pic.hit = true;
52880:             return true;
52880:         }
52880: 
52880:         JSObject *aobj = js_GetProtoIfDenseArray(obj);
52880:         if (!aobj->isNative())
52880:             return disable("non-native");
52880: 
52880:         JSObject *holder;
52880:         JSProperty *prop;
52880:         if (!aobj->lookupProperty(f.cx, ATOM_TO_JSID(atom), &holder, &prop))
52880:             return false;
52880: 
52880:         if (!prop)
52880:             return disable("lookup failed");
52880: 
52880:         AutoPropertyDropper dropper(f.cx, holder, prop);
52880: 
52884:         if (!holder->isNative())
52884:             return disable("non-native holder");
52884: 
53531:         const Shape *shape = (const Shape *)prop;
53531:         if (!shape->hasDefaultGetterOrIsMethod())
52880:             return disable("getter");
53531:         if (!shape->hasSlot())
52880:             return disable("invalid slot");
52880: 
52889:         if (obj == holder && !pic.inlinePathPatched)
53531:             return patchInline(holder, shape);
53339:         
53531:         return generateStub(holder, shape);
53137:     }
53137: 
53137:     bool disable(const char *reason)
53137:     {
53137:         return PICStubCompiler::disable(reason, stub);
53137:     }
53137: };
53137: 
53137: class GetElemCompiler : public PICStubCompiler
53137: {
53137:     JSObject *obj;
53137:     JSString *id;
53137:     void *stub;
53137:     int lastStubSecondShapeGuard;
53137: 
53315:     static int32 dslotsLoad(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return GETELEM_DSLOTS_LOAD;
53315: #elif defined JS_PUNBOX64
53315:         return pic.labels.getelem.dslotsLoadOffset;
53315: #endif
53315:     }
53315: 
53315:     inline int32 dslotsLoad() {
53315:         return dslotsLoad(pic);
53315:     }
53315: 
53315:     static int32 inlineShapeOffset(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return GETELEM_INLINE_SHAPE_OFFSET;
53315: #elif defined JS_PUNBOX64
53315:         return pic.labels.getelem.inlineShapeOffset;
53315: #endif
53315:     }
53315: 
53315:     inline int32 inlineShapeOffset() {
53315:         return inlineShapeOffset(pic);
53315:     }
53315: 
53315:     static int32 inlineShapeJump(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return GETELEM_INLINE_SHAPE_JUMP;
53315: #elif defined JS_PUNBOX64
53315:         return inlineShapeOffset(pic) + GETELEM_INLINE_SHAPE_JUMP;
53315: #endif
53315:     }
53315: 
53315:     inline int32 inlineShapeJump() {
53315:         return inlineShapeJump(pic);
53315:     }
53315: 
53315:     static int32 inlineAtomOffset(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return GETELEM_INLINE_ATOM_OFFSET;
53315: #elif defined JS_PUNBOX64
53315:         return pic.labels.getelem.inlineAtomOffset;
53315: #endif
53315:     }
53315: 
53315:     inline int32 inlineAtomOffset() {
53315:         return inlineAtomOffset(pic);
53315:     }
53315: 
53315:     static int32 inlineAtomJump(ic::PICInfo &pic) {
53315: #if defined JS_NUNBOX32
53315:         return GETELEM_INLINE_ATOM_JUMP;
53315: #elif defined JS_PUNBOX64
53315:         return inlineAtomOffset(pic) + GETELEM_INLINE_ATOM_JUMP;
53315: #endif
53315:     }
53315: 
53315:     inline int32 inlineAtomJump() {
53315:         return inlineAtomJump(pic);
53315:     }
53315: 
53137:   public:
53137:     GetElemCompiler(VMFrame &f, JSScript *script, JSObject *obj, ic::PICInfo &pic, JSString *id,
53137:                     VoidStub stub)
53137:       : PICStubCompiler("getelem", f, script, pic), obj(obj), id(id),
53137:         stub(JS_FUNC_TO_DATA_PTR(void *, stub)),
53137:         lastStubSecondShapeGuard(pic.u.get.secondShapeGuard)
53137:     {}
53137: 
53353:     static void reset(ic::PICInfo &pic)
53353:     {
53353:         JS_ASSERT(pic.kind == ic::PICInfo::GETELEM);
53353: 
53353:         RepatchBuffer repatcher(pic.fastPathStart.executableAddress(), INLINE_PATH_LENGTH);
53353:         repatcher.repatchLEAToLoadPtr(pic.storeBack.instructionAtOffset(dslotsLoad(pic)));
53353: 
53353:         /* Only the shape needs to be patched to fail -- atom jump will never be taken. */
53353:         repatcher.repatch(pic.fastPathStart.dataLabel32AtOffset(
53353:                            pic.shapeGuard + inlineShapeOffset(pic)),
53531:                           int32(JSObjectMap::INVALID_SHAPE));
53353:         repatcher.relink(pic.fastPathStart.jumpAtOffset(pic.shapeGuard + inlineShapeJump(pic)),
53353:                          pic.slowPathStart);
53551:         repatcher.relink(pic.fastPathStart.jumpAtOffset(pic.shapeGuard + inlineAtomJump(pic)),
53551:                          pic.slowPathStart);
53353: 
53353:         RepatchBuffer repatcher2(pic.slowPathStart.executableAddress(), INLINE_PATH_LENGTH);
53353:         ReturnAddressPtr retPtr(pic.slowPathStart.callAtOffset(pic.callReturn).executableAddress());
53353: 
53353:         MacroAssemblerCodePtr target(JS_FUNC_TO_DATA_PTR(void *, ic::GetElem));
53353:         repatcher.relinkCallerToTrampoline(retPtr, target);
53353:     }
53353: 
53531:     bool patchInline(JSObject *holder, const Shape *shape)
53137:     {
53137:         spew("patch", "inline");
53137:         PICRepatchBuffer repatcher(pic, pic.fastPathStart);
53137: 
53137:         int32 offset;
53531:         if (shape->slot < JS_INITIAL_NSLOTS) {
53315:             JSC::CodeLocationInstruction istr = pic.storeBack.instructionAtOffset(dslotsLoad());
53137:             repatcher.repatchLoadPtrToLEA(istr);
53137: 
53137:             // 
53137:             // We've patched | mov dslots, [obj + DSLOTS_OFFSET]
53137:             // To:           | lea fslots, [obj + DSLOTS_OFFSET]
53137:             //
53137:             // Because the offset is wrong, it's necessary to correct it
53137:             // below.
53137:             //
53137:             int32 diff = int32(offsetof(JSObject, fslots)) - int32(offsetof(JSObject, dslots));
53137:             JS_ASSERT(diff != 0);
53531:             offset  = (int32(shape->slot) * sizeof(Value)) + diff;
53137:         } else {
53531:             offset = (shape->slot - JS_INITIAL_NSLOTS) * sizeof(Value);
53137:         }
53137:         
53315:         uint32 shapeOffset = pic.shapeGuard + inlineShapeOffset();
53137:         repatcher.repatch(pic.fastPathStart.dataLabel32AtOffset(shapeOffset), obj->shape());
53315:         uint32 idOffset = pic.shapeGuard + inlineAtomOffset();
53315:         repatcher.repatch(pic.fastPathStart.dataLabelPtrAtOffset(idOffset), id);
53315: #if defined JS_NUNBOX32
53270:         repatcher.repatch(pic.storeBack.dataLabel32AtOffset(GETELEM_TYPE_LOAD), offset + 4);
53270:         repatcher.repatch(pic.storeBack.dataLabel32AtOffset(GETELEM_DATA_LOAD), offset);
53315: #elif defined JS_PUNBOX64
53315:         repatcher.repatch(pic.storeBack.dataLabel32AtOffset(pic.labels.getelem.inlineValueOffset), offset);
53315: #endif
53137:         pic.inlinePathPatched = true;
52880: 
52880:         return true;
52880:     }
52880: 
53137:     void patchPreviousToHere(PICRepatchBuffer &repatcher, CodeLocationLabel cs)
53137:     {
53137:         // Patch either the inline fast path or a generated stub. The stub
53137:         // omits the prefix of the inline fast path that loads the shape, so
53137:         // the offsets are different.
53137:         int shapeGuardJumpOffset;
53137:         int atomGuardJumpOffset;
53137:         if (pic.stubsGenerated) {
53315: #if defined JS_NUNBOX32
53270:             shapeGuardJumpOffset = GETELEM_STUB_SHAPE_JUMP;
53315: #elif defined JS_PUNBOX64
53315:             shapeGuardJumpOffset = pic.labels.getelem.stubShapeJump;
53315: #endif
53270:             atomGuardJumpOffset = GETELEM_STUB_ATOM_JUMP;
53137:         } else {
53315:             shapeGuardJumpOffset = pic.shapeGuard + inlineShapeJump();
53315:             atomGuardJumpOffset = pic.shapeGuard + inlineAtomJump();
53137:         }
53137:         repatcher.relink(shapeGuardJumpOffset, cs);
53137:         repatcher.relink(atomGuardJumpOffset, cs);
53137:         if (lastStubSecondShapeGuard)
53137:             repatcher.relink(lastStubSecondShapeGuard, cs);
53137:     }
53137: 
53531:     bool generateStub(JSObject *holder, const Shape *shape)
53137:     {
53137:         JS_ASSERT(pic.u.get.idReg != pic.shapeReg);
53137:         Vector<Jump, 8> shapeMismatches(f.cx);
53137: 
53137:         Assembler masm;
53137: 
53137:         if (pic.objNeedsRemat()) {
53137:             if (pic.objRemat() >= sizeof(JSStackFrame))
53444:                 masm.loadPayload(Address(JSFrameReg, pic.objRemat()), pic.objReg);
53137:             else
53137:                 masm.move(RegisterID(pic.objRemat()), pic.objReg);
53137:             pic.u.get.objNeedsRemat = false;
53137:         }
53137: 
53137:         if (pic.idNeedsRemat()) {
53137:             if (pic.idRemat() >= sizeof(JSStackFrame))
53445:                 masm.loadPayload(Address(JSFrameReg, pic.idRemat()), pic.u.get.idReg);
53137:             else
53137:                 masm.move(RegisterID(pic.idRemat()), pic.u.get.idReg);
53137:             pic.u.get.idNeedsRemat = false;
53137:         }
53137: 
53137:         if (pic.shapeNeedsRemat()) {
53137:             masm.loadShape(pic.objReg, pic.shapeReg);
53137:             pic.shapeRegHasBaseShape = true;
53137:         }
53137: 
53314:         Label start = masm.label();
53314:         Jump atomGuard = masm.branchPtr(Assembler::NotEqual, pic.u.get.idReg, ImmPtr(id));
53315:         DBGLABEL(dbgStubAtomJump);
53314:         Jump shapeGuard = masm.branch32_force32(Assembler::NotEqual, pic.shapeReg,
53137:                                            Imm32(obj->shape()));
53315: 
53315: #if (defined JS_NUNBOX32 && defined DEBUG) || defined JS_PUNBOX64
53315:         Label stubShapeJump = masm.label();
53315: #endif
53137: 
53270:         JS_ASSERT(masm.differenceBetween(start, dbgStubAtomJump)  == GETELEM_STUB_ATOM_JUMP);
53315: #if defined JS_NUNBOX32
53315:         JS_ASSERT(masm.differenceBetween(start, stubShapeJump) == GETELEM_STUB_SHAPE_JUMP);
53315: #endif
53270: 
53137:         if (!(shapeMismatches.append(shapeGuard) && shapeMismatches.append(atomGuard)))
53137:             return false;
53137: 
53137:         if (obj != holder) {
53137:             // Emit code that walks the prototype chain.
53137:             JSObject *tempObj = obj;
53137:             Address proto(pic.objReg, offsetof(JSObject, proto));
53137:             do {
53137:                 tempObj = tempObj->getProto();
53137:                 // FIXME: we should find out why this condition occurs. It is probably
53137:                 // related to PICs on globals.
53137:                 if (!tempObj)
53241:                     return disable("null object in prototype chain");
53137:                 JS_ASSERT(tempObj);
53137: 
53137:                 /* 
53241:                  * If there is a non-native along the prototype chain the shape is technically
53137:                  * invalid.
53137:                  */
53137:                 if (!tempObj->isNative())
53241:                     return disable("non-JS-native in prototype chain");
53137: 
53137:                 masm.loadPtr(proto, pic.objReg);
53137:                 pic.shapeRegHasBaseShape = false;
53137:                 pic.u.get.objNeedsRemat = true;
53137: 
53137:                 Jump j = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
53137:                 if (!shapeMismatches.append(j))
53137:                     return false;
53137:             } while (tempObj != holder);
53137: 
53137:             // Load the shape out of the holder and check it.
53137:             masm.loadShape(pic.objReg, pic.shapeReg);
53137:             Jump j = masm.branch32_force32(Assembler::NotEqual, pic.shapeReg,
53137:                                            Imm32(holder->shape()));
53137:             if (!shapeMismatches.append(j))
53137:                 return false;
53137:             pic.u.get.secondShapeGuard = masm.distanceOf(masm.label()) - masm.distanceOf(start);
53137:         } else {
53137:             JS_ASSERT(holder->isNative()); /* Precondition: already checked. */
53137:             pic.u.get.secondShapeGuard = 0;
53137:         }
53137: 
53137:         /* Load the value out of the object. */
53531:         masm.loadSlot(pic.objReg, pic.objReg, shape->slot, pic.shapeReg, pic.objReg);
53137:         Jump done = masm.jump();
53137: 
53137:         JSC::ExecutablePool *ep = getExecPool(masm.size());
53137:         if (!ep) {
53137:             js_ReportOutOfMemory(f.cx);
53137:             return false;
53137:         }
53137: 
53137:         // :TODO: this can OOM 
53137:         JSC::LinkBuffer buffer(&masm, ep);
53137: 
53137:         if (!pic.execPools.append(ep)) {
53137:             ep->release();
53137:             js_ReportOutOfMemory(f.cx);
53137:             return false;
53137:         }
53137: 
53137:         // The guard exit jumps to the original slow case.
53137:         for (Jump *pj = shapeMismatches.begin(); pj != shapeMismatches.end(); ++pj)
53137:             buffer.link(*pj, pic.slowPathStart);
53137: 
53137:         // The final exit jumps to the store-back in the inline stub.
53137:         buffer.link(done, pic.storeBack);
53137:         CodeLocationLabel cs = buffer.finalizeCodeAddendum();
53137: #if DEBUG
53137:         char *chars = js_DeflateString(f.cx, id->chars(), id->length());
53137:         JaegerSpew(JSpew_PICs, "generated %s stub at %p for atom 0x%x (\"%s\") shape 0x%x (%s: %d)\n",
53137:                    type, cs.executableAddress(), id, chars, holder->shape(), script->filename,
53482:                    js_FramePCToLineNumber(f.cx, f.fp()));
53137:         f.cx->free(chars);
53137: #endif
53137: 
53137:         PICRepatchBuffer repatcher(pic, pic.lastPathStart()); 
53137:         patchPreviousToHere(repatcher, cs);
53137: 
53137:         pic.stubsGenerated++;
53137:         pic.lastStubStart = buffer.locationOf(start);
53137: 
53315: #if defined JS_PUNBOX64
53315:         pic.labels.getelem.stubShapeJump = masm.differenceBetween(start, stubShapeJump);
53426:         JS_ASSERT(pic.labels.getelem.stubShapeJump == masm.differenceBetween(start, stubShapeJump));
53315: #endif
53315: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
53137:             disable("max stubs reached");
53137:         if (obj->isDenseArray())
53137:             disable("dense array");
53137: 
53137:         return true;
53137:     }
53137: 
53137:     bool update()
53137:     {
53137:         if (!pic.hit) {
53137:             spew("first hit", "nop");
53137:             pic.hit = true;
53137:             return true;
53137:         }
53137: 
53137:         JSAtom *atom = js_AtomizeString(f.cx, id, 0);
53137:         if (!atom)
53137:             return false;
53137:         JSObject *holder;
53137:         JSProperty *prop;
53137:         if (!obj->lookupProperty(f.cx, ATOM_TO_JSID(atom), &holder, &prop))
53137:             return false;
53137: 
53137:         if (!prop)
53137:             return disable("lookup failed");
53137: 
53137:         AutoPropertyDropper dropper(f.cx, holder, prop);
53137: 
53314:         if (!obj->isNative())
53314:             return disable("non-native obj");
53137:         if (!holder->isNative())
53137:             return disable("non-native holder");
53137: 
53531:         const Shape *shape = (const Shape *)prop;
53531:         if (!shape->hasDefaultGetterOrIsMethod())
53137:             return disable("getter");
53531:         if (!shape->hasSlot())
53137:             return disable("invalid slot");
53137: 
53137:         if (obj == holder && !pic.inlinePathPatched)
53531:             return patchInline(holder, shape);
53339: 
53531:         return generateStub(holder, shape);
53137:     }
53137: 
52880:     bool disable(const char *reason)
52880:     {
52880:         return PICStubCompiler::disable(reason, stub);
52880:     }
52880: };
52880: 
53054: class ScopeNameCompiler : public PICStubCompiler
53054: {
53054:     JSObject *scopeChain;
53054:     JSAtom *atom;
53054:     void   *stub;
53054: 
53054:   public:
53054:     JSObject *obj;
53054:     JSObject *holder;
53054:     JSProperty *prop;
53531:     const Shape *shape;
53054: 
53054:   public:
53054:     ScopeNameCompiler(VMFrame &f, JSScript *script, JSObject *scopeChain, ic::PICInfo &pic,
53054:                       JSAtom *atom, VoidStubUInt32 stub)
53054:       : PICStubCompiler("name", f, script, pic), scopeChain(scopeChain), atom(atom),
53054:         stub(JS_FUNC_TO_DATA_PTR(void *, stub)), obj(NULL), holder(NULL), prop(NULL)
53054:     { }
53054: 
53054:     bool disable(const char *reason)
53054:     {
53054:         return PICStubCompiler::disable(reason, stub);
53054:     }
53054: 
53054:     static void reset(ic::PICInfo &pic)
53054:     {
53054:         RepatchBuffer repatcher(pic.fastPathStart.executableAddress(), INLINE_PATH_LENGTH);
53270:         repatcher.relink(pic.fastPathStart.jumpAtOffset(SCOPENAME_JUMP_OFFSET),
53054:                          pic.slowPathStart);
53054: 
53054:         RepatchBuffer repatcher2(pic.slowPathStart.executableAddress(), INLINE_PATH_LENGTH);
53054:         ReturnAddressPtr retPtr(pic.slowPathStart.callAtOffset(pic.callReturn).executableAddress());
53054:         MacroAssemblerCodePtr target(JS_FUNC_TO_DATA_PTR(void *, ic::Name));
53054:         repatcher.relinkCallerToTrampoline(retPtr, target);
53054:     }
53054: 
53164:     typedef Vector<Jump, 8, ContextAllocPolicy> JumpList;
53054: 
53164:     bool walkScopeChain(Assembler &masm, JumpList &fails, bool &found)
53054:     {
53054:         /* Walk the scope chain. */
53054:         JSObject *tobj = scopeChain;
53164: 
53054:         while (tobj && tobj != holder) {
53054:             if (!js_IsCacheableNonGlobalScope(tobj))
53054:                 return disable("non-cacheable scope chain object");
53054:             JS_ASSERT(tobj->isNative());
53054: 
53054:             if (tobj != scopeChain) {
53054:                 /* scopeChain will never be NULL, but parents can be NULL. */
53054:                 Jump j = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
53054:                 if (!fails.append(j))
53054:                     return false;
53054:             }
53054:             
53054:             /* Guard on intervening shapes. */
53054:             masm.loadShape(pic.objReg, pic.shapeReg);
53054:             Jump j = masm.branch32(Assembler::NotEqual, pic.shapeReg, Imm32(tobj->shape()));
53054:             if (!fails.append(j))
53054:                 return false;
53054: 
53054:             /* Load the next link in the scope chain. */
53244:             Address parent(pic.objReg, offsetof(JSObject, parent));
53315:             masm.loadPtr(parent, pic.objReg);
53054: 
53054:             tobj = tobj->getParent();
53054:         }
53054: 
53164:         found = tobj == holder;
53164: 
53164:         return true;
53164:     }
53164: 
53164:     bool generateGlobalStub()
53164:     {
53164:         Assembler masm;
53164:         JumpList fails(f.cx);
53164: 
53840:         masm.loadPtr(Address(JSFrameReg, JSStackFrame::offsetOfScopeChain()), pic.objReg);
53164: 
53164:         JS_ASSERT(obj == holder);
53164:         JS_ASSERT(holder == scopeChain->getGlobal());
53164: 
53164:         bool found = false;
53164:         if (!walkScopeChain(masm, fails, found))
53164:             return false;
53164:         if (!found)
53164:             return disable("scope chain walk terminated early");
53164: 
53164:         Jump finalNull = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
53164:         masm.loadShape(pic.objReg, pic.shapeReg);
53164:         Jump finalShape = masm.branch32(Assembler::NotEqual, pic.shapeReg, Imm32(holder->shape()));
53164: 
53531:         masm.loadSlot(pic.objReg, pic.objReg, shape->slot, pic.shapeReg, pic.objReg);
53164: 
53164:         Jump done = masm.jump();
53164: 
53164:         // All failures flow to here, so there is a common point to patch.
53164:         for (Jump *pj = fails.begin(); pj != fails.end(); ++pj)
53164:             pj->linkTo(masm.label(), &masm);
53164:         finalNull.linkTo(masm.label(), &masm);
53164:         finalShape.linkTo(masm.label(), &masm);
53164:         Label failLabel = masm.label();
53164:         Jump failJump = masm.jump();
53270:         DBGLABEL(dbgJumpOffset);
53270: 
53270:         JS_ASSERT(masm.differenceBetween(failLabel, dbgJumpOffset) == SCOPENAME_JUMP_OFFSET);
53164: 
53164:         JSC::ExecutablePool *ep = getExecPool(masm.size());
53164:         if (!ep) {
53164:             js_ReportOutOfMemory(f.cx);
53164:             return false;
53164:         }
53164: 
53164:         // :TODO: this can OOM 
53164:         JSC::LinkBuffer buffer(&masm, ep);
53164: 
53164:         if (!pic.execPools.append(ep)) {
53164:             ep->release();
53164:             js_ReportOutOfMemory(f.cx);
53164:             return false;
53164:         }
53164: 
53164:         buffer.link(failJump, pic.slowPathStart);
53164:         buffer.link(done, pic.storeBack);
53164:         CodeLocationLabel cs = buffer.finalizeCodeAddendum();
53164:         JaegerSpew(JSpew_PICs, "generated %s global stub at %p\n", type, cs.executableAddress());
53164:         spew("NAME stub", "global");
53164: 
53164:         PICRepatchBuffer repatcher(pic, pic.lastPathStart()); 
53270:         repatcher.relink(SCOPENAME_JUMP_OFFSET, cs);
53164: 
53164:         pic.stubsGenerated++;
53164:         pic.lastStubStart = buffer.locationOf(failLabel);
53164: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
53164:             disable("max stubs reached");
53164: 
53164:         return true;
53164:     }
53164: 
53164:     enum CallObjPropKind {
53164:         ARG,
53164:         VAR
53164:     };
53164: 
53164:     bool generateCallStub()
53164:     {
53164:         Assembler masm;
53164:         Vector<Jump, 8, ContextAllocPolicy> fails(f.cx);
53164: 
53840:         masm.loadPtr(Address(JSFrameReg, JSStackFrame::offsetOfScopeChain()), pic.objReg);
53164: 
53164:         JS_ASSERT(obj == holder);
53164:         JS_ASSERT(holder != scopeChain->getGlobal());
53164: 
53164:         CallObjPropKind kind;
53531:         if (shape->getterOp() == js_GetCallArg) {
53164:             kind = ARG;
53531:         } else if (shape->getterOp() == js_GetCallVar) {
53164:             kind = VAR;
53164:         } else {
53164:             return disable("unhandled callobj sprop getter");
53164:         }
53164: 
53164:         bool found = false;
53164:         if (!walkScopeChain(masm, fails, found))
53164:             return false;
53164:         if (!found)
53164:             return disable("scope chain walk terminated early");
53054: 
53054:         Jump finalNull = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
53054:         masm.loadShape(pic.objReg, pic.shapeReg);
53054:         Jump finalShape = masm.branch32(Assembler::NotEqual, pic.shapeReg, Imm32(holder->shape()));
53054: 
53054:         /* Get callobj's stack frame. */
53157:         masm.loadFunctionPrivate(pic.objReg, pic.shapeReg);
53054: 
53840:         JSFunction *fun = holder->getCallObjCalleeFunction();
53531:         uint16 slot = uint16(shape->shortid);
53054: 
53054:         Jump skipOver;
53054:         Jump escapedFrame = masm.branchTestPtr(Assembler::Zero, pic.shapeReg, pic.shapeReg);
53054: 
53054:         /* Not-escaped case. */
53054:         {
53840:             Address addr(pic.shapeReg, kind == ARG ? JSStackFrame::offsetOfFormalArg(fun, slot)
53840:                                                    : JSStackFrame::offsetOfFixed(slot));
53144:             masm.loadPayload(addr, pic.objReg);
53054:             masm.loadTypeTag(addr, pic.shapeReg);
53054:             skipOver = masm.jump();
53054:         }
53054: 
53056:         escapedFrame.linkTo(masm.label(), &masm);
53056: 
53056:         {
53056:             masm.loadPtr(Address(pic.objReg, offsetof(JSObject, dslots)), pic.objReg);
53056: 
53056:             if (kind == VAR)
53056:                 slot += fun->nargs;
53056:             Address dslot(pic.objReg, slot * sizeof(Value));
53056:             masm.loadTypeTag(dslot, pic.shapeReg);
53144:             masm.loadPayload(dslot, pic.objReg);
53056:         }
53056: 
53056:         skipOver.linkTo(masm.label(), &masm);
53056:         Jump done = masm.jump();
53056: 
53054:         // All failures flow to here, so there is a common point to patch.
53054:         for (Jump *pj = fails.begin(); pj != fails.end(); ++pj)
53054:             pj->linkTo(masm.label(), &masm);
53054:         finalNull.linkTo(masm.label(), &masm);
53054:         finalShape.linkTo(masm.label(), &masm);
53054:         Label failLabel = masm.label();
53054:         Jump failJump = masm.jump();
53054: 
53054:         JSC::ExecutablePool *ep = getExecPool(masm.size());
53054:         if (!ep) {
53054:             js_ReportOutOfMemory(f.cx);
53054:             return false;
53054:         }
53054: 
53054:         // :TODO: this can OOM 
53054:         JSC::LinkBuffer buffer(&masm, ep);
53054: 
53054:         if (!pic.execPools.append(ep)) {
53054:             ep->release();
53054:             js_ReportOutOfMemory(f.cx);
53054:             return false;
53054:         }
53054: 
53054:         buffer.link(failJump, pic.slowPathStart);
53056:         buffer.link(done, pic.storeBack);
53054:         CodeLocationLabel cs = buffer.finalizeCodeAddendum();
53164:         JaegerSpew(JSpew_PICs, "generated %s call stub at %p\n", type, cs.executableAddress());
53054: 
53054:         PICRepatchBuffer repatcher(pic, pic.lastPathStart()); 
53270:         repatcher.relink(SCOPENAME_JUMP_OFFSET, cs);
53054: 
53054:         pic.stubsGenerated++;
53054:         pic.lastStubStart = buffer.locationOf(failLabel);
53054: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
53054:             disable("max stubs reached");
53054: 
53054:         return true;
53054:     }
53054: 
53054:     bool update()
53054:     {
53054:         JSContext *cx = f.cx;
53054: 
53054:         if (!js_FindProperty(cx, ATOM_TO_JSID(atom), &obj, &holder, &prop))
53054:             return false;
53054: 
53054:         if (!pic.hit) {
53054:             spew("first hit", "nop");
53054:             pic.hit = true;
53054:             return true;
53054:         }
53054: 
53296:         if (!prop)
53296:             return disable("property not found");
53054:         if (!obj->isNative() || !holder->isNative())
53054:             return disable("non-native scope object");
53054:         if (obj != holder)
53054:             return disable("property is on proto of a scope object");
53054:         
53531:         shape = (const Shape *)prop;
53397: 
53397:         if (obj->getClass() == &js_CallClass)
53397:             return generateCallStub();
53397: 
53531:         if (!shape->hasDefaultGetterOrIsMethod())
53287:             return disable("getter");
53531:         if (!shape->hasSlot())
53287:             return disable("invalid slot");
53164: 
53164:         if (!obj->getParent())
53164:             return generateGlobalStub();
53164: 
53054:         return disable("scope object not handled yet");
53054:     }
53054: };
53054: 
53055: class BindNameCompiler : public PICStubCompiler
53055: {
53055:     JSObject *scopeChain;
53055:     JSAtom *atom;
53055:     void   *stub;
53055: 
53317:     static int32 inlineJumpOffset(ic::PICInfo &pic) {
53317: #if defined JS_NUNBOX32
53317:         return BINDNAME_INLINE_JUMP_OFFSET;
53317: #elif defined JS_PUNBOX64
53317:         return pic.labels.bindname.inlineJumpOffset;
53317: #endif
53317:     }
53317: 
53317:     inline int32 inlineJumpOffset() {
53317:         return inlineJumpOffset(pic);
53317:     }
53317: 
53055:   public:
53055:     BindNameCompiler(VMFrame &f, JSScript *script, JSObject *scopeChain, ic::PICInfo &pic,
53055:                       JSAtom *atom, VoidStubUInt32 stub)
53055:       : PICStubCompiler("bind", f, script, pic), scopeChain(scopeChain), atom(atom),
53055:         stub(JS_FUNC_TO_DATA_PTR(void *, stub))
53055:     { }
53055: 
53339:     bool disable(const char *reason)
53055:     {
53339:         return PICStubCompiler::disable(reason, stub);
53055:     }
53055: 
53055:     static void reset(ic::PICInfo &pic)
53055:     {
53351:         PICRepatchBuffer repatcher(pic, pic.fastPathStart); 
53351:         repatcher.relink(pic.shapeGuard + inlineJumpOffset(pic), pic.slowPathStart);
53055: 
53055:         RepatchBuffer repatcher2(pic.slowPathStart.executableAddress(), INLINE_PATH_LENGTH);
53055:         ReturnAddressPtr retPtr(pic.slowPathStart.callAtOffset(pic.callReturn).executableAddress());
53055:         MacroAssemblerCodePtr target(JS_FUNC_TO_DATA_PTR(void *, ic::BindName));
53055:         repatcher.relinkCallerToTrampoline(retPtr, target);
53055:     }
53055: 
53055:     bool generateStub(JSObject *obj)
53055:     {
53055:         Assembler masm;
53055:         js::Vector<Jump, 8, ContextAllocPolicy> fails(f.cx);
53055: 
53055:         /* Guard on the shape of the scope chain. */
53840:         masm.loadPtr(Address(JSFrameReg, JSStackFrame::offsetOfScopeChain()), pic.objReg);
53055:         masm.loadShape(pic.objReg, pic.shapeReg);
53055:         Jump firstShape = masm.branch32(Assembler::NotEqual, pic.shapeReg,
53055:                                         Imm32(scopeChain->shape()));
53055: 
53055:         /* Walk up the scope chain. */
53055:         JSObject *tobj = scopeChain;
53244:         Address parent(pic.objReg, offsetof(JSObject, parent));
53055:         while (tobj && tobj != obj) {
53055:             if (!js_IsCacheableNonGlobalScope(tobj))
53055:                 return disable("non-cacheable obj in scope chain");
53315:             masm.loadPtr(parent, pic.objReg);
53055:             Jump nullTest = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
53055:             if (!fails.append(nullTest))
53055:                 return false;
53055:             masm.loadShape(pic.objReg, pic.shapeReg);
53055:             Jump shapeTest = masm.branch32(Assembler::NotEqual, pic.shapeReg,
53055:                                            Imm32(tobj->shape()));
53055:             tobj = tobj->getParent();
53055:         }
53055:         if (tobj != obj)
53055:             return disable("indirect hit");
53055: 
53055:         Jump done = masm.jump();
53055: 
53055:         // All failures flow to here, so there is a common point to patch.
53055:         for (Jump *pj = fails.begin(); pj != fails.end(); ++pj)
53055:             pj->linkTo(masm.label(), &masm);
53055:         firstShape.linkTo(masm.label(), &masm);
53055:         Label failLabel = masm.label();
53055:         Jump failJump = masm.jump();
53270:         DBGLABEL(dbgStubJumpOffset);
53270: 
53270:         JS_ASSERT(masm.differenceBetween(failLabel, dbgStubJumpOffset) == BINDNAME_STUB_JUMP_OFFSET);
53055: 
53055:         JSC::ExecutablePool *ep = getExecPool(masm.size());
53055:         if (!ep) {
53055:             js_ReportOutOfMemory(f.cx);
53055:             return false;
53055:         }
53055: 
53055:         // :TODO: this can OOM 
53055:         JSC::LinkBuffer buffer(&masm, ep);
53055: 
53055:         if (!pic.execPools.append(ep)) {
53055:             ep->release();
53055:             js_ReportOutOfMemory(f.cx);
53055:             return false;
53055:         }
53055: 
53055:         buffer.link(failJump, pic.slowPathStart);
53055:         buffer.link(done, pic.storeBack);
53055:         CodeLocationLabel cs = buffer.finalizeCodeAddendum();
53055:         JaegerSpew(JSpew_PICs, "generated %s stub at %p\n", type, cs.executableAddress());
53055: 
53055:         PICRepatchBuffer repatcher(pic, pic.lastPathStart()); 
53055:         if (!pic.stubsGenerated)
53317:             repatcher.relink(pic.shapeGuard + inlineJumpOffset(), cs);
53055:         else
53270:             repatcher.relink(BINDNAME_STUB_JUMP_OFFSET, cs);
53055: 
53055:         pic.stubsGenerated++;
53055:         pic.lastStubStart = buffer.locationOf(failLabel);
53055: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
53055:             disable("max stubs reached");
53055: 
53055:         return true;
53055:     }
53055: 
53055:     JSObject *update()
53055:     {
53055:         JS_ASSERT(scopeChain->getParent());
53055: 
53055:         JSObject *obj = js_FindIdentifierBase(f.cx, scopeChain, ATOM_TO_JSID(atom));
53055:         if (!obj)
53055:             return obj;
53055: 
53055:         if (!pic.hit) {
53055:             spew("first hit", "nop");
53055:             pic.hit = true;
53055:             return obj;
53055:         }
53055: 
53055:         if (!generateStub(obj))
53055:             return NULL;
53055: 
53055:         return obj;
53055:     }
53055: };
53055: 
52880: void JS_FASTCALL
52880: ic::GetProp(VMFrame &f, uint32 index)
52880: {
53840:     JSScript *script = f.fp()->script();
52880:     PICInfo &pic = script->pics[index];
52880: 
52892:     JSAtom *atom = pic.atom;
52892:     if (atom == f.cx->runtime->atomState.lengthAtom) {
52884:         if (f.regs.sp[-1].isString()) {
52884:             GetPropCompiler cc(f, script, NULL, pic, NULL, stubs::Length);
52884:             if (!cc.generateStringLengthStub()) {
52884:                 cc.disable("error");
52884:                 THROW();
52884:             }
53081:             JSString *str = f.regs.sp[-1].toString();
52884:             f.regs.sp[-1].setInt32(str->length());
52884:             return;
52884:         } else if (!f.regs.sp[-1].isPrimitive()) {
53081:             JSObject *obj = &f.regs.sp[-1].toObject();
53123:             if (obj->isArray() || (obj->isArguments() && !obj->isArgsLengthOverridden())) {
53123:                 GetPropCompiler cc(f, script, obj, pic, NULL, stubs::Length);
52884:                 if (obj->isArray()) {
52884:                     if (!cc.generateArrayLengthStub()) {
52884:                         cc.disable("error");
52884:                         THROW();
52884:                     }
52884:                     f.regs.sp[-1].setNumber(obj->getArrayLength());
53123:                 } else if (obj->isArguments()) {
53123:                     if (!cc.generateArgsLengthStub()) {
53123:                         cc.disable("error");
53123:                         THROW();
53123:                     }
53446:                     f.regs.sp[-1].setInt32(int32_t(obj->getArgsInitialLength()));
53123:                 }
52884:                 return;
52884:             }
52884:         }
52884:         atom = f.cx->runtime->atomState.lengthAtom;
52884:     }
52880: 
52880:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52880:     if (!obj)
52880:         THROW();
52880: 
52880:     if (pic.shouldGenerate()) {
52880:         GetPropCompiler cc(f, script, obj, pic, atom, stubs::GetProp);
52880:         if (!cc.update()) {
52880:             cc.disable("error");
52880:             THROW();
52880:         }
52880:     }
52880: 
52880:     Value v;
52880:     if (!obj->getProperty(f.cx, ATOM_TO_JSID(atom), &v))
52880:         THROW();
52880:     f.regs.sp[-1] = v;
52880: }
52880: 
53137: void JS_FASTCALL
53137: ic::GetElem(VMFrame &f, uint32 picIndex)
53137: {
53840:     JSScript *script = f.fp()->script();
53137:     PICInfo &pic = script->pics[picIndex];
53137: 
53137:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
53137:     if (!obj)
53137:         THROW();
53137: 
53137:     Value idval = f.regs.sp[-1];
53137:     JS_ASSERT(idval.isString());
53137:     JSString *id = idval.toString();
53356:     if (pic.shouldGenerate()) {
53137:         GetElemCompiler cc(f, script, obj, pic, id, stubs::GetElem);
53137:         if (!cc.update()) {
53137:             cc.disable("error");
53137:             THROW();
53137:         }
53137:     }
53137: 
53137:     JSAtom *atom = js_AtomizeString(f.cx, id, 0);
53137:     if (!atom)
53137:         THROW();
53137:     Value v;
53137:     if (!obj->getProperty(f.cx, ATOM_TO_JSID(atom), &v))
53137:         THROW();
53137:     f.regs.sp[-2] = v;
53137: }
53137: 
53492: void JS_FASTCALL
53492: ic::SetPropDumb(VMFrame &f, uint32 index)
52916: {
53840:     JSScript *script = f.fp()->script();
52916:     ic::PICInfo &pic = script->pics[index];
53620:     JS_ASSERT(pic.isSet());
52916:     JSAtom *atom = pic.atom;
52916: 
52916:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52916:     if (!obj)
52916:         THROW();
52916:     Value rval = f.regs.sp[-1];
52916:     if (!obj->setProperty(f.cx, ATOM_TO_JSID(atom), &f.regs.sp[-1]))
52916:         THROW();
52916:     f.regs.sp[-2] = rval;
52916: }
52916: 
52916: static void JS_FASTCALL
52887: SetPropSlow(VMFrame &f, uint32 index)
52887: {
53840:     JSScript *script = f.fp()->script();
52887:     ic::PICInfo &pic = script->pics[index];
53620:     JS_ASSERT(pic.isSet());
52887: 
52892:     JSAtom *atom = pic.atom;
52888:     stubs::SetName(f, atom);
52887: }
52887: 
52897: void JS_FASTCALL
52886: ic::SetProp(VMFrame &f, uint32 index)
52886: {
52887:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52887:     if (!obj)
52887:         THROW();
52887: 
53840:     JSScript *script = f.fp()->script();
52887:     ic::PICInfo &pic = script->pics[index];
52892:     JSAtom *atom = pic.atom;
53620:     JS_ASSERT(pic.isSet());
52887: 
52916:     //
52887:     // Important: We update the PIC before looking up the property so that the
52887:     // PIC is updated only if the property already exists. The PIC doesn't try
52887:     // to optimize adding new properties; that is for the slow case.
52916:     //
52916:     // Also note, we can't use SetName for PROPINC PICs because the property
52916:     // cache can't handle a GET and SET from the same scripted PC.
52916:     //
52916: 
52916:     VoidStubUInt32 stub;
52916:     switch (JSOp(*f.regs.pc)) {
52916:       case JSOP_PROPINC:
52916:       case JSOP_PROPDEC:
52916:       case JSOP_INCPROP:
52916:       case JSOP_DECPROP:
53118:       case JSOP_NAMEINC:
53118:       case JSOP_NAMEDEC:
53118:       case JSOP_INCNAME:
53118:       case JSOP_DECNAME:
52916:         stub = SetPropDumb;
52916:         break;
52916:       default:
52916:         stub = SetPropSlow;
52916:         break;
52916:     }
52916: 
52916:     SetPropCompiler cc(f, script, obj, pic, atom, stub);
52887:     if (!cc.update()) {
52887:         cc.disable("error");
52887:         THROW();
52887:     }
52887:     
52887:     Value rval = f.regs.sp[-1];
53249:     stub(f, index);
52886: }
52880: 
52896: static void JS_FASTCALL
52896: CallPropSlow(VMFrame &f, uint32 index)
52896: {
53840:     JSScript *script = f.fp()->script();
52896:     ic::PICInfo &pic = script->pics[index];
52896:     stubs::CallProp(f, pic.atom);
52896: }
52896: 
52896: void JS_FASTCALL
52896: ic::CallProp(VMFrame &f, uint32 index)
52896: {
52896:     JSContext *cx = f.cx;
52896:     JSFrameRegs &regs = f.regs;
52896: 
53840:     JSScript *script = f.fp()->script();
52896:     ic::PICInfo &pic = script->pics[index];
52896:     JSAtom *origAtom = pic.atom;
52896: 
52896:     Value lval;
52896:     lval = regs.sp[-1];
52896: 
52896:     Value objv;
52896:     if (lval.isObject()) {
52896:         objv = lval;
52896:     } else {
52896:         JSProtoKey protoKey;
52896:         if (lval.isString()) {
52896:             protoKey = JSProto_String;
52896:         } else if (lval.isNumber()) {
52896:             protoKey = JSProto_Number;
52896:         } else if (lval.isBoolean()) {
52896:             protoKey = JSProto_Boolean;
52896:         } else {
52896:             JS_ASSERT(lval.isNull() || lval.isUndefined());
52896:             js_ReportIsNullOrUndefined(cx, -1, lval, NULL);
52896:             THROW();
52896:         }
52896:         JSObject *pobj;
52896:         if (!js_GetClassPrototype(cx, NULL, protoKey, &pobj))
52896:             THROW();
53023:         objv.setObject(*pobj);
52896:     }
52896: 
53081:     JSObject *aobj = js_GetProtoIfDenseArray(&objv.toObject());
52896:     Value rval;
52896: 
52896:     bool usePIC = true;
52896: 
52896:     PropertyCacheEntry *entry;
52896:     JSObject *obj2;
52896:     JSAtom *atom;
52896:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
52896:     if (!atom) {
52896:         if (entry->vword.isFunObj()) {
53023:             rval.setObject(entry->vword.toFunObj());
52896:         } else if (entry->vword.isSlot()) {
52896:             uint32 slot = entry->vword.toSlot();
53650:             JS_ASSERT(obj2->containsSlot(slot));
52896:             rval = obj2->lockedGetSlot(slot);
52896:         } else {
53531:             JS_ASSERT(entry->vword.isShape());
53531:             const Shape *shape = entry->vword.toShape();
53531:             NATIVE_GET(cx, &objv.toObject(), obj2, shape, JSGET_NO_METHOD_BARRIER, &rval,
52896:                        THROW());
52896:         }
52896:         regs.sp++;
52896:         regs.sp[-2] = rval;
52896:         regs.sp[-1] = lval;
52896:         goto end_callprop;
52896:     }
52896: 
52896:     /*
52896:      * Cache miss: use the immediate atom that was loaded for us under
52896:      * PropertyCache::test.
52896:      */
52896:     jsid id;
52896:     id = ATOM_TO_JSID(origAtom);
52896: 
52896:     regs.sp++;
52896:     regs.sp[-1].setNull();
52896:     if (lval.isObject()) {
53081:         if (!js_GetMethod(cx, &objv.toObject(), id,
53261:                           JS_LIKELY(!objv.toObject().getOps()->getProperty)
52896:                           ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
52896:                           : JSGET_NO_METHOD_BARRIER,
52896:                           &rval)) {
52896:             THROW();
52896:         }
52896:         regs.sp[-1] = objv;
52896:         regs.sp[-2] = rval;
52896:     } else {
53244:         JS_ASSERT(!objv.toObject().getOps()->getProperty);
53081:         if (!js_GetPropertyHelper(cx, &objv.toObject(), id,
52896:                                   JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER,
52896:                                   &rval)) {
52896:             THROW();
52896:         }
52896:         regs.sp[-1] = lval;
52896:         regs.sp[-2] = rval;
52896:     }
52896: 
52896:   end_callprop:
52896:     /* Wrap primitive lval in object clothing if necessary. */
52896:     if (lval.isPrimitive()) {
52896:         /* FIXME: https://bugzilla.mozilla.org/show_bug.cgi?id=412571 */
53023:         JSObject *funobj;
53023:         if (!IsFunctionObject(rval, &funobj) ||
53023:             !PrimitiveThisTest(GET_FUNCTION_PRIVATE(cx, funobj), lval)) {
52896:             if (!js_PrimitiveToObject(cx, &regs.sp[-1]))
52896:                 THROW();
52896:             usePIC = false;
52896:         }
52896:     }
52896: 
53081:     GetPropCompiler cc(f, script, &objv.toObject(), pic, origAtom, CallPropSlow);
52896:     if (usePIC) {
52907:         if (lval.isObject()) {
52896:             if (!cc.update()) {
52896:                 cc.disable("error");
52896:                 THROW();
52896:             }
52907:         } else if (lval.isString()) {
52907:             if (!cc.generateStringCallStub()) {
52907:                 cc.disable("error");
52907:                 THROW();
52907:             }
52906:         } else {
52907:             cc.disable("non-string primitive");
52896:         }
52906:     } else {
52906:         cc.disable("wrapped primitive");
52896:     }
52896: 
52896: #if JS_HAS_NO_SUCH_METHOD
52896:     if (JS_UNLIKELY(rval.isUndefined())) {
52896:         regs.sp[-2].setString(ATOM_TO_STRING(origAtom));
52896:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
52896:             THROW();
52896:     }
52896: #endif
52896: }
52896: 
53054: static void JS_FASTCALL
53054: SlowName(VMFrame &f, uint32 index)
53054: {
53054:     stubs::Name(f);
53054: }
53054: 
53109: void JS_FASTCALL
53054: ic::Name(VMFrame &f, uint32 index)
53054: {
53840:     JSScript *script = f.fp()->script();
53054:     ic::PICInfo &pic = script->pics[index];
53054:     JSAtom *atom = pic.atom;
53054: 
53840:     ScopeNameCompiler cc(f, script, &f.fp()->scopeChain(), pic, atom, SlowName);
53054: 
53054:     if (!cc.update()) {
53054:         cc.disable("error");
53054:         THROW();
53054:     }
53054: 
53054:     Value rval;
53089:     if (cc.prop && (!cc.obj->isNative() || !cc.holder->isNative())) {
53054:         cc.holder->dropProperty(f.cx, cc.prop);
53054:         if (!cc.obj->getProperty(f.cx, ATOM_TO_JSID(atom), &rval))
53054:             THROW();
53054:     } else {
53089:         if (!cc.prop) {
53089:             /* Kludge to allow (typeof foo == "undefined") tests. */
53089:             cc.disable("property not found");
53840:             JSOp op2 = js_GetOpcode(f.cx, f.fp()->script(), f.regs.pc + JSOP_NAME_LENGTH);
53089:             if (op2 == JSOP_TYPEOF) {
53089:                 f.regs.sp[0].setUndefined();
53089:                 return;
53089:             }
53089:             ReportAtomNotDefined(f.cx, atom);
53089:             THROW();
53089:         }
53531:         const Shape *shape = (const Shape *)cc.prop;
53360:         JSObject *normalized = cc.obj;
53531:         if (cc.obj->getClass() == &js_WithClass && !shape->hasDefaultGetter())
53360:             normalized = js_UnwrapWithObject(f.cx, cc.obj);
53531:         NATIVE_GET(f.cx, normalized, cc.holder, shape, JSGET_METHOD_BARRIER, &rval,
53054:                    THROW());
53054:         JS_UNLOCK_OBJ(f.cx, cc.holder);
53054:     }
53054: 
53054:     f.regs.sp[0] = rval;
53054: }
53054: 
53055: static void JS_FASTCALL
53055: SlowBindName(VMFrame &f, uint32 index)
53055: {
53055:     stubs::BindName(f);
53055: }
53055: 
53055: void JS_FASTCALL
53055: ic::BindName(VMFrame &f, uint32 index)
53055: {
53840:     JSScript *script = f.fp()->script();
53055:     ic::PICInfo &pic = script->pics[index];
53055:     JSAtom *atom = pic.atom;
53055: 
53840:     BindNameCompiler cc(f, script, &f.fp()->scopeChain(), pic, atom, SlowBindName);
53055: 
53055:     JSObject *obj = cc.update();
53055:     if (!obj) {
53055:         cc.disable("error");
53055:         THROW();
53055:     }
53055: 
53055:     f.regs.sp[0].setObject(*obj);
53055: }
53055: 
53083: void
52880: ic::PurgePICs(JSContext *cx, JSScript *script)
52880: {
53498:     uint32 npics = script->jit->nPICs;
52880:     for (uint32 i = 0; i < npics; i++) {
52880:         ic::PICInfo &pic = script->pics[i];
53055:         switch (pic.kind) {
53055:           case ic::PICInfo::SET:
53620:           case ic::PICInfo::SETMETHOD:
52896:             SetPropCompiler::reset(pic);
53055:             break;
53055:           case ic::PICInfo::NAME:
53054:             ScopeNameCompiler::reset(pic);
53055:             break;
53055:           case ic::PICInfo::BIND:
53055:             BindNameCompiler::reset(pic);
53055:             break;
53353:           case ic::PICInfo::CALL: /* fall-through */
53307:           case ic::PICInfo::GET:
52880:             GetPropCompiler::reset(pic);
53055:             break;
53353:           case ic::PICInfo::GETELEM:
53353:             GetElemCompiler::reset(pic);
53353:             break;
53353:           default:
53353:             JS_NOT_REACHED("Unhandled PIC kind");
53353:             break;
53055:         }
52880:         pic.reset();
52880:     }
52880: }
52880: 
53119: #endif /* JS_POLYIC */
53119: 
