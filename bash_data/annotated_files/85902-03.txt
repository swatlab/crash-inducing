60068: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
60068: /* ***** BEGIN LICENSE BLOCK *****
60068:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
60068:  *
60068:  * The contents of this file are subject to the Mozilla Public License Version
60068:  * 1.1 (the "License"); you may not use this file except in compliance with
60068:  * the License. You may obtain a copy of the License at
60068:  * http://www.mozilla.org/MPL/
60068:  *
60068:  * Software distributed under the License is distributed on an "AS IS" basis,
60068:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
60068:  * for the specific language governing rights and limitations under the
60068:  * License.
60068:  *
60068:  * The Original Code is mozilla.org code.
60068:  *
60068:  * The Initial Developer of the Original Code is
60068:  * Mozilla Foundation.
60068:  * Portions created by the Initial Developer are Copyright (C) 2010
60068:  * the Initial Developer. All Rights Reserved.
60068:  *
60068:  * Alternatively, the contents of this file may be used under the terms of
60068:  * either the GNU General Public License Version 2 or later (the "GPL"), or
60068:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
60068:  * in which case the provisions of the GPL or the LGPL are applicable instead
60068:  * of those above. If you wish to allow use of your version of this file only
60068:  * under the terms of either the GPL or the LGPL, and not to allow others to
60068:  * use your version of this file under the terms of the MPL, indicate your
60068:  * decision by deleting the provisions above and replace them with the notice
60068:  * and other provisions required by the GPL or the LGPL. If you do not delete
60068:  * the provisions above, a recipient may use your version of this file under
60068:  * the terms of any one of the MPL, the GPL or the LGPL.
60068:  *
60068:  * ***** END LICENSE BLOCK ***** */
60068: 
60068: #include "GfxInfo.h"
60068: #include "nsUnicharUtils.h"
60068: #include "mozilla/FunctionTimer.h"
60068: #include "prenv.h"
60068: #include "prprf.h"
60068: #include "EGLUtils.h"
81328: #include "nsHashKeys.h"
60068: 
60069: #include "AndroidBridge.h"
60069: 
70361: #if defined(MOZ_CRASHREPORTER)
60068: #include "nsExceptionHandler.h"
60068: #include "nsICrashReporter.h"
60068: #define NS_CRASHREPORTER_CONTRACTID "@mozilla.org/toolkit/crash-reporter;1"
60068: #endif
60068: 
60068: using namespace mozilla::widget;
60068: 
60068: /* GetD2DEnabled and GetDwriteEnabled shouldn't be called until after gfxPlatform initialization
60068:  * has occurred because they depend on it for information. (See bug 591561) */
60068: nsresult
79445: GfxInfo::GetD2DEnabled(bool *aEnabled)
60068: {
60068:   return NS_ERROR_FAILURE;
60068: }
60068: 
60068: nsresult
79445: GfxInfo::GetDWriteEnabled(bool *aEnabled)
60068: {
60068:   return NS_ERROR_FAILURE;
60068: }
60068: 
72430: nsresult
79445: GfxInfo::GetAzureEnabled(bool *aEnabled)
72430: {
72430:   return NS_ERROR_FAILURE;
72430: }
72430: 
60493: /* readonly attribute DOMString DWriteVersion; */
60493: NS_IMETHODIMP
60493: GfxInfo::GetDWriteVersion(nsAString & aDwriteVersion)
60493: {
60493:   return NS_ERROR_FAILURE;
60493: }
60493: 
69664: /* readonly attribute DOMString cleartypeParameters; */
69664: NS_IMETHODIMP
69664: GfxInfo::GetCleartypeParameters(nsAString & aCleartypeParams)
69664: {
69664:   return NS_ERROR_FAILURE;
69664: }
69664: 
60893: nsresult
60068: GfxInfo::Init()
60068: {
85898:   mSetCrashReportAnnotations = false;
60893:   return GfxInfoBase::Init();
60068: }
60068: 
60068: /* readonly attribute DOMString adapterDescription; */
60068: NS_IMETHODIMP
60068: GfxInfo::GetAdapterDescription(nsAString & aAdapterDescription)
60068: {
85901:   aAdapterDescription.AssignASCII(mozilla::gl::GetVendor());
85901:   if (mozilla::AndroidBridge::Bridge()) {
85901:       nsAutoString str;
85901:       aAdapterDescription.Append(NS_LITERAL_STRING(", Model: '"));
85901:       if (mozilla::AndroidBridge::Bridge()->GetStaticStringField("android/os/Build", "MODEL", str))
85901:         aAdapterDescription.Append(str);
85901:       aAdapterDescription.Append(NS_LITERAL_STRING("', Product: '"));
85901:       if (mozilla::AndroidBridge::Bridge()->GetStaticStringField("android/os/Build", "PRODUCT", str))
85901:         aAdapterDescription.Append(str);
85901:       aAdapterDescription.Append(NS_LITERAL_STRING("', Manufacturer: '"));
85901:       if (mozilla::AndroidBridge::Bridge()->GetStaticStringField("android/os/Build", "MANUFACTURER", str))
85901:         aAdapterDescription.Append(str);
85901:       aAdapterDescription.Append(NS_LITERAL_STRING("', Hardware: '"));
85901:       PRInt32 version; // the HARDWARE field isn't available on Android SDK < 8
85901:       if (!mozilla::AndroidBridge::Bridge()->GetStaticIntField("android/os/Build$VERSION", "SDK_INT", &version))
85901:         version = 0;
85901:       if (version >= 8 && mozilla::AndroidBridge::Bridge()->GetStaticStringField("android/os/Build", "HARDWARE", str))
85901:       if (mozilla::AndroidBridge::Bridge()->GetStaticStringField("android/os/Build", "HARDWARE", str))
85901:         aAdapterDescription.Append(str);
85901:       aAdapterDescription.Append(NS_LITERAL_STRING("'"));
85901:   }
85901: 
60068:   return NS_OK;
60068: }
60068: 
76321: /* readonly attribute DOMString adapterDescription2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDescription2(nsAString & aAdapterDescription)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
60068: /* readonly attribute DOMString adapterRAM; */
60068: NS_IMETHODIMP
60068: GfxInfo::GetAdapterRAM(nsAString & aAdapterRAM)
60068: {
60068:   aAdapterRAM.AssignLiteral("");
60068:   return NS_OK;
60068: }
60068: 
76321: /* readonly attribute DOMString adapterRAM2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterRAM2(nsAString & aAdapterRAM)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
60068: /* readonly attribute DOMString adapterDriver; */
60068: NS_IMETHODIMP
60068: GfxInfo::GetAdapterDriver(nsAString & aAdapterDriver)
60068: {
60068:   aAdapterDriver.AssignLiteral("");
60068:   return NS_OK;
60068: }
60068: 
76321: /* readonly attribute DOMString adapterDriver2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriver2(nsAString & aAdapterDriver)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
60068: /* readonly attribute DOMString adapterDriverVersion; */
60068: NS_IMETHODIMP
60068: GfxInfo::GetAdapterDriverVersion(nsAString & aAdapterDriverVersion)
60068: {
85901:   aAdapterDriverVersion.AssignLiteral("");
60068:   return NS_OK;
60068: }
60068: 
76321: /* readonly attribute DOMString adapterDriverVersion2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriverVersion2(nsAString & aAdapterDriverVersion)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
60068: /* readonly attribute DOMString adapterDriverDate; */
60068: NS_IMETHODIMP
60068: GfxInfo::GetAdapterDriverDate(nsAString & aAdapterDriverDate)
60068: {
60068:   aAdapterDriverDate.AssignLiteral("");
60068:   return NS_OK;
60068: }
60068: 
76321: /* readonly attribute DOMString adapterDriverDate2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriverDate2(nsAString & aAdapterDriverDate)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
85902: /* readonly attribute unsigned long adapterVendorID; */
60068: NS_IMETHODIMP
85902: GfxInfo::GetAdapterVendorID(PRUint32 *aAdapterVendorID)
60068: {
85901:   nsAutoString str;
85901:   PRInt32 version; // the HARDWARE field isn't available on Android SDK < 8
85901:   if (!mozilla::AndroidBridge::Bridge()->GetStaticIntField("android/os/Build$VERSION", "SDK_INT", &version))
85901:     version = 0;
85901:   if (version >= 8 && mozilla::AndroidBridge::Bridge()->GetStaticStringField("android/os/Build", "HARDWARE", str)) {
85902:     *aAdapterVendorID = HashString(str);
85901:     return NS_OK;
85901:   }
85901: 
85902:   *aAdapterVendorID = 0;
60068:   return NS_OK;
60068: }
60068: 
85902: /* readonly attribute unsigned long adapterVendorID2; */
76321: NS_IMETHODIMP
85902: GfxInfo::GetAdapterVendorID2(PRUint32 *aAdapterVendorID)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
85902: /* readonly attribute unsigned long adapterDeviceID; */
60068: NS_IMETHODIMP
85902: GfxInfo::GetAdapterDeviceID(PRUint32 *aAdapterDeviceID)
60068: {
85901:   nsAutoString str;
85901:   if (mozilla::AndroidBridge::Bridge()->GetStaticStringField("android/os/Build", "MODEL", str)) {
85902:     *aAdapterDeviceID = HashString(str);
85901:     return NS_OK;
85901:   }
85901: 
85902:   *aAdapterDeviceID = 0;
60068:   return NS_OK;
60068: }
60068: 
85902: /* readonly attribute unsigned long adapterDeviceID2; */
76321: NS_IMETHODIMP
85902: GfxInfo::GetAdapterDeviceID2(PRUint32 *aAdapterDeviceID)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
76321: /* readonly attribute boolean isGPU2Active; */
76321: NS_IMETHODIMP
79445: GfxInfo::GetIsGPU2Active(bool* aIsGPU2Active)
76321: {
76321:   return NS_ERROR_FAILURE;
76321: }
76321: 
60068: void
81263: GfxInfo::AddOpenGLCrashReportAnnotations()
60068: {
70361: #if defined(MOZ_CRASHREPORTER)
85902:   nsCAutoString deviceIDString, vendorIDString;
85902:   nsAutoString adapterDescriptionString;
85902:   PRUint32 deviceID, vendorID;
60068: 
85902:   GetAdapterDeviceID(&deviceID);
85902:   GetAdapterVendorID(&vendorID);
81263:   GetAdapterDescription(adapterDescriptionString);
60068: 
85902:   deviceIDString.AppendPrintf("%04x", deviceID);
85902:   vendorIDString.AppendPrintf("%04x", vendorID);
60068: 
60068:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterVendorID"),
85902:       vendorIDString);
60068:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterDeviceID"),
85902:       deviceIDString);
60068: 
60068:   /* Add an App Note for now so that we get the data immediately. These
60068:    * can go away after we store the above in the socorro db */
60068:   nsCAutoString note;
60068:   /* AppendPrintf only supports 32 character strings, mrghh. */
85902:   note.AppendPrintf("AdapterVendorID: %04x, ", vendorID);
85902:   note.AppendPrintf("AdapterDeviceID: %04x.", deviceID);
85902:   note.Append("\n");
81263:   note.AppendPrintf("AdapterDescription: '%s'.", NS_ConvertUTF16toUTF8(adapterDescriptionString).get());
60068:   note.Append("\n");
60068: 
60068:   CrashReporter::AppendAppNotesToCrashReport(note);
60068: #endif
60068: }
60068: 
84603: const nsTArray<GfxDriverInfo>&
81328: GfxInfo::GetGfxDriverInfo()
81328: {
85900:   // Nothing here yet.
85900:   //if (!mDriverInfo->Length()) {
85900:   //
85900:   //}
84603:   return *mDriverInfo;
81328: }
81328: 
60891: nsresult
81328: GfxInfo::GetFeatureStatusImpl(PRInt32 aFeature, 
81328:                               PRInt32 *aStatus, 
81328:                               nsAString & aSuggestedDriverVersion,
84603:                               const nsTArray<GfxDriverInfo>& aDriverInfo, 
81328:                               OperatingSystem* aOS /* = nsnull */)
60068: {
85899:   PRInt32 status = nsIGfxInfo::FEATURE_STATUS_UNKNOWN;
85899: 
84607:   aSuggestedDriverVersion.SetIsVoid(true);
85899: 
85901:   // For now, we don't implement the downloaded blacklist.
85901:   if (aDriverInfo.Length()) {
85901:     *aStatus = nsIGfxInfo::FEATURE_NO_INFO;
85901:     return NS_OK;
85901:   }
85901: 
84607:   OperatingSystem os = DRIVER_OS_ANDROID;
60362: 
60362:   if (aFeature == FEATURE_OPENGL_LAYERS) {
85898:     if (!mSetCrashReportAnnotations) {
85898:       AddOpenGLCrashReportAnnotations();
85898:       mSetCrashReportAnnotations = true;
85898:     }
85898: 
85900:     /* XXX: Use this code when we're ready to whitelist devices. */
77922:     // nsAutoString str;
77922:     // /* Whitelist Galaxy S phones */
77922:     // if (mozilla::AndroidBridge::Bridge()->GetStaticStringField("android/os/Build", "HARDWARE", str)) {
77922:     //   if (str != NS_LITERAL_STRING("smdkc110")) {
77922:     //     status = FEATURE_BLOCKED_DEVICE;
77922:     //   }
77922:     // }
85900: 
85900:     status = FEATURE_BLOCKED_DEVICE;
60362:   }
85899: 
85899:   *aStatus = status;
85899:   if (aOS)
85899:     *aOS = os;
81328: 
85901:   // XXX disabled for now as this calls GetAdapterVendorID and friends, which currently crash on Android, see bug 700124
85901:   // FIXME: if this gets fixed, the line setting *aStatus must be removed
85901: #if 0
84603:   return GfxInfoBase::GetFeatureStatusImpl(aFeature, aStatus, aSuggestedDriverVersion, aDriverInfo, &os);
85901: #else
85901:   if (status == nsIGfxInfo::FEATURE_STATUS_UNKNOWN)
85901:     *aStatus = nsIGfxInfo::FEATURE_NO_INFO;
85901: #endif
85901:   return NS_OK;
60068: }
