    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Joe Hewitt <hewitt@netscape.com> (Original Author)
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsFormFillController.h"
    1: 
29403: #include "nsIFormAutoComplete.h"
52364: #include "nsIInputListAutoComplete.h"
    1: #include "nsIAutoCompleteSimpleResult.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMKeyEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
42192: #include "nsIFormControl.h"
    1: #include "nsIDocument.h"
    1: #include "nsIContent.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIFrame.h"
    1: #include "nsRect.h"
    1: #include "nsIDOMHTMLFormElement.h"
 1511: #include "nsILoginManager.h"
    1: #include "nsIDOMMouseEvent.h"
46998: #include "mozilla/ModuleUtils.h"
    1: #include "nsToolkitCompsCID.h"
    1: #include "nsEmbedCID.h"
 6544: #include "nsIDOMNSEditableElement.h"
32980: #include "nsIDOMNSEvent.h"
52365: #include "mozilla/dom/Element.h"
82525: #include "nsContentUtils.h"
    1: 
72597: NS_IMPL_ISUPPORTS5(nsFormFillController,
72597:                    nsIFormFillController,
72597:                    nsIAutoCompleteInput,
72597:                    nsIAutoCompleteSearch,
72597:                    nsIDOMEventListener,
72597:                    nsIMutationObserver)
    1: 
    1: nsFormFillController::nsFormFillController() :
90586:   mFocusedInput(nsnull),
90586:   mFocusedInputNode(nsnull),
90586:   mListNode(nsnull),
    1:   mTimeout(50),
    1:   mMinResultsForPopup(1),
    1:   mMaxRows(0),
80486:   mDisableAutoComplete(false),
80486:   mCompleteDefaultIndex(false),
80486:   mCompleteSelectedIndex(false),
80486:   mForceComplete(false),
80486:   mSuppressOnInput(false)
    1: {
    1:   mController = do_GetService("@mozilla.org/autocomplete/controller;1");
    1:   mDocShells = do_CreateInstance("@mozilla.org/supports-array;1");
    1:   mPopups = do_CreateInstance("@mozilla.org/supports-array;1");
 1511:   mPwmgrInputs.Init();
    1: }
    1: 
90586: struct PwmgrInputsEnumData
90586: {
91090:   PwmgrInputsEnumData(nsFormFillController* aFFC, nsIDocument* aDoc)
91090:   : mFFC(aFFC), mDoc(aDoc) {}
90586: 
91090:   nsFormFillController* mFFC;
90586:   nsCOMPtr<nsIDocument> mDoc;
90586: };
90586: 
    1: nsFormFillController::~nsFormFillController()
    1: {
90586:   if (mListNode) {
90586:     mListNode->RemoveMutationObserver(this);
90586:     mListNode = nsnull;
90586:   }
90586:   if (mFocusedInputNode) {
91090:     MaybeRemoveMutationObserver(mFocusedInputNode);
90586:     mFocusedInputNode = nsnull;
90586:     mFocusedInput = nsnull;
90586:   }
91090:   PwmgrInputsEnumData ed(this, nsnull);
91090:   mPwmgrInputs.Enumerate(RemoveForDocumentEnumerator, &ed);
91090: 
    1:   // Remove ourselves as a focus listener from all cached docShells
    1:   PRUint32 count;
    1:   mDocShells->Count(&count);
    1:   for (PRUint32 i = 0; i < count; ++i) {
    1:     nsCOMPtr<nsIDocShell> docShell;
    1:     mDocShells->GetElementAt(i, getter_AddRefs(docShell));
    1:     nsCOMPtr<nsIDOMWindow> domWindow = GetWindowForDocShell(docShell);
    1:     RemoveWindowListeners(domWindow);
    1:   }
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
52365: //// nsIMutationObserver
52365: //
52365: 
52365: void
52365: nsFormFillController::AttributeChanged(nsIDocument* aDocument,
52365:                                        mozilla::dom::Element* aElement,
52365:                                        PRInt32 aNameSpaceID,
52365:                                        nsIAtom* aAttribute, PRInt32 aModType)
52365: {
90586:   if (mListNode && mListNode->Contains(aElement)) {
52365:     RevalidateDataList();
52365:   }
90586: }
52365: 
52365: void
52365: nsFormFillController::ContentAppended(nsIDocument* aDocument,
52365:                                       nsIContent* aContainer,
52365:                                       nsIContent* aChild,
52365:                                       PRInt32 aIndexInContainer)
52365: {
90586:   if (mListNode && mListNode->Contains(aContainer)) {
52365:     RevalidateDataList();
52365:   }
90586: }
52365: 
52365: void
52365: nsFormFillController::ContentInserted(nsIDocument* aDocument,
52365:                                       nsIContent* aContainer,
52365:                                       nsIContent* aChild,
52365:                                       PRInt32 aIndexInContainer)
52365: {
90586:   if (mListNode && mListNode->Contains(aContainer)) {
52365:     RevalidateDataList();
52365:   }
90586: }
52365: 
52365: void
52365: nsFormFillController::ContentRemoved(nsIDocument* aDocument,
52365:                                      nsIContent* aContainer,
52365:                                      nsIContent* aChild,
52365:                                      PRInt32 aIndexInContainer,
52365:                                      nsIContent* aPreviousSibling)
52365: {
90586:   if (mListNode && mListNode->Contains(aContainer)) {
52365:     RevalidateDataList();
52365:   }
90586: }
52365: 
52365: void
52365: nsFormFillController::CharacterDataWillChange(nsIDocument* aDocument,
52365:                                               nsIContent* aContent,
52365:                                               CharacterDataChangeInfo* aInfo)
52365: {
52365: }
52365: 
52365: void
52365: nsFormFillController::CharacterDataChanged(nsIDocument* aDocument,
52365:                                            nsIContent* aContent,
52365:                                            CharacterDataChangeInfo* aInfo)
52365: {
52365: }
52365: 
52365: void
52365: nsFormFillController::AttributeWillChange(nsIDocument* aDocument,
52365:                                           mozilla::dom::Element* aElement,
52365:                                           PRInt32 aNameSpaceID,
52365:                                           nsIAtom* aAttribute, PRInt32 aModType)
52365: {
52365: }
52365: 
52365: void
52365: nsFormFillController::ParentChainChanged(nsIContent* aContent)
52365: {
52365: }
52365: 
52365: void
52365: nsFormFillController::NodeWillBeDestroyed(const nsINode* aNode)
52365: {
90586:   mPwmgrInputs.Remove(aNode);
90586:   if (aNode == mListNode) {
90586:     mListNode = nsnull;
90586:     RevalidateDataList();
90586:   } else if (aNode == mFocusedInputNode) {
90586:     mFocusedInputNode = nsnull;
90586:     mFocusedInput = nsnull;
90586:   }
52365: }
52365: 
91090: void
91090: nsFormFillController::MaybeRemoveMutationObserver(nsINode* aNode)
91090: {
91090:   // Nodes being tracked in mPwmgrInputs will have their observers removed when
91090:   // they stop being tracked. 
91090:   bool dummy;
91090:   if (!mPwmgrInputs.Get(aNode, &dummy)) {
91090:     aNode->RemoveMutationObserver(this);
91090:   }
91090: }
91090: 
52365: ////////////////////////////////////////////////////////////////////////
    1: //// nsIFormFillController
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::AttachToBrowser(nsIDocShell *aDocShell, nsIAutoCompletePopup *aPopup)
    1: {
    1:   NS_ENSURE_TRUE(aDocShell && aPopup, NS_ERROR_ILLEGAL_VALUE);
    1: 
    1:   mDocShells->AppendElement(aDocShell);
    1:   mPopups->AppendElement(aPopup);
    1: 
    1:   // Listen for focus events on the domWindow of the docShell
    1:   nsCOMPtr<nsIDOMWindow> domWindow = GetWindowForDocShell(aDocShell);
    1:   AddWindowListeners(domWindow);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::DetachFromBrowser(nsIDocShell *aDocShell)
    1: {
    1:   PRInt32 index = GetIndexOfDocShell(aDocShell);
    1:   NS_ENSURE_TRUE(index >= 0, NS_ERROR_FAILURE);
    1: 
    1:   // Stop listening for focus events on the domWindow of the docShell
    1:   nsCOMPtr<nsIDocShell> docShell;
    1:   mDocShells->GetElementAt(index, getter_AddRefs(docShell));
    1:   nsCOMPtr<nsIDOMWindow> domWindow = GetWindowForDocShell(docShell);
    1:   RemoveWindowListeners(domWindow);
    1: 
    1:   mDocShells->RemoveElementAt(index);
    1:   mPopups->RemoveElementAt(index);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 1511: 
 1511: NS_IMETHODIMP
 1511: nsFormFillController::MarkAsLoginManagerField(nsIDOMHTMLInputElement *aInput)
 1511: {
 1511:   /*
 1511:    * The Login Manager can supply autocomplete results for username fields,
 1511:    * when a user has multiple logins stored for a site. It uses this
 1511:    * interface to indicate that the form manager shouldn't handle the
 1511:    * autocomplete. The form manager also checks for this tag when saving
 1511:    * form history (so it doesn't save usernames).
 1511:    */
90586:   nsCOMPtr<nsINode> node = do_QueryInterface(aInput);
90586:   NS_ENSURE_STATE(node);
90586:   mPwmgrInputs.Put(node, true);
90586:   node->AddMutationObserverUnlessExists(this);
 1511: 
 6842:   if (!mLoginManager)
 6842:     mLoginManager = do_GetService("@mozilla.org/login-manager;1");
 6842: 
 1511:   return NS_OK;
 1511: }
 1511: 
 1511: 
    1: ////////////////////////////////////////////////////////////////////////
    1: //// nsIAutoCompleteInput
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetPopup(nsIAutoCompletePopup **aPopup)
    1: {
    1:   *aPopup = mFocusedPopup;
    1:   NS_IF_ADDREF(*aPopup);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetController(nsIAutoCompleteController **aController)
    1: {
    1:   *aController = mController;
    1:   NS_IF_ADDREF(*aController);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::GetPopupOpen(bool *aPopupOpen)
    1: {
    1:   if (mFocusedPopup)
    1:     mFocusedPopup->GetPopupOpen(aPopupOpen);
33455:   else
80486:     *aPopupOpen = false;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::SetPopupOpen(bool aPopupOpen)
    1: {
    1:   if (mFocusedPopup) {
    1:     if (aPopupOpen) {
    1:       // make sure input field is visible before showing popup (bug 320938)
    1:       nsCOMPtr<nsIContent> content = do_QueryInterface(mFocusedInput);
    1:       NS_ENSURE_STATE(content);
    1:       nsCOMPtr<nsIDocShell> docShell = GetDocShellForInput(mFocusedInput);
    1:       NS_ENSURE_STATE(docShell);
    1:       nsCOMPtr<nsIPresShell> presShell;
    1:       docShell->GetPresShell(getter_AddRefs(presShell));
    1:       NS_ENSURE_STATE(presShell);
    1:       presShell->ScrollContentIntoView(content,
    1:                                        NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
56647:                                        NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
56647:                                        nsIPresShell::SCROLL_OVERFLOW_HIDDEN);
27255:       // mFocusedPopup can be destroyed after ScrollContentIntoView, see bug 420089
27255:       if (mFocusedPopup)
 6458:         mFocusedPopup->OpenAutocompletePopup(this, mFocusedInput);
    1:     } else
    1:       mFocusedPopup->ClosePopup();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::GetDisableAutoComplete(bool *aDisableAutoComplete)
    1: {
    1:   *aDisableAutoComplete = mDisableAutoComplete;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::SetDisableAutoComplete(bool aDisableAutoComplete)
    1: {
    1:   mDisableAutoComplete = aDisableAutoComplete;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::GetCompleteDefaultIndex(bool *aCompleteDefaultIndex)
    1: {
    1:   *aCompleteDefaultIndex = mCompleteDefaultIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::SetCompleteDefaultIndex(bool aCompleteDefaultIndex)
    1: {
    1:   mCompleteDefaultIndex = aCompleteDefaultIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::GetCompleteSelectedIndex(bool *aCompleteSelectedIndex)
    1: {
    1:   *aCompleteSelectedIndex = mCompleteSelectedIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::SetCompleteSelectedIndex(bool aCompleteSelectedIndex)
    1: {
    1:   mCompleteSelectedIndex = aCompleteSelectedIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::GetForceComplete(bool *aForceComplete)
    1: {
    1:   *aForceComplete = mForceComplete;
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsFormFillController::SetForceComplete(bool aForceComplete)
    1: {
    1:   mForceComplete = aForceComplete;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetMinResultsForPopup(PRUint32 *aMinResultsForPopup)
    1: {
    1:   *aMinResultsForPopup = mMinResultsForPopup;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsFormFillController::SetMinResultsForPopup(PRUint32 aMinResultsForPopup)
    1: {
    1:   mMinResultsForPopup = aMinResultsForPopup;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetMaxRows(PRUint32 *aMaxRows)
    1: {
    1:   *aMaxRows = mMaxRows;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::SetMaxRows(PRUint32 aMaxRows)
    1: {
    1:   mMaxRows = aMaxRows;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::GetShowImageColumn(bool *aShowImageColumn)
 7358: {
80486:   *aShowImageColumn = false;
 7358:   return NS_OK;
 7358: }
 7358: 
79445: NS_IMETHODIMP nsFormFillController::SetShowImageColumn(bool aShowImageColumn)
 7358: {
 7358:   return NS_ERROR_NOT_IMPLEMENTED;
 7358: }
 7358: 
 7358: 
 7358: NS_IMETHODIMP
79445: nsFormFillController::GetShowCommentColumn(bool *aShowCommentColumn)
    1: {
80486:   *aShowCommentColumn = false;
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsFormFillController::SetShowCommentColumn(bool aShowCommentColumn)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetTimeout(PRUint32 *aTimeout)
    1: {
    1:   *aTimeout = mTimeout;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsFormFillController::SetTimeout(PRUint32 aTimeout)
    1: {
    1:   mTimeout = aTimeout;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::SetSearchParam(const nsAString &aSearchParam)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetSearchParam(nsAString &aSearchParam)
    1: {
    1:   if (!mFocusedInput) {
    1:     NS_WARNING("mFocusedInput is null for some reason! avoiding a crash. should find out why... - ben");
    1:     return NS_ERROR_FAILURE; // XXX why? fix me.
    1:   }
    1: 
    1:   mFocusedInput->GetName(aSearchParam);
    1:   if (aSearchParam.IsEmpty())
    1:     mFocusedInput->GetId(aSearchParam);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetSearchCount(PRUint32 *aSearchCount)
    1: {
    1:   *aSearchCount = 1;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetSearchAt(PRUint32 index, nsACString & _retval)
    1: {
    1:   _retval.Assign("form-history");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetTextValue(nsAString & aTextValue)
    1: {
    1:   if (mFocusedInput) {
    1:     mFocusedInput->GetValue(aTextValue);
    1:   } else {
    1:     aTextValue.Truncate();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::SetTextValue(const nsAString & aTextValue)
    1: {
 6544:   nsCOMPtr<nsIDOMNSEditableElement> editable = do_QueryInterface(mFocusedInput);
 6544:   if (editable) {
80486:     mSuppressOnInput = true;
18432:     editable->SetUserInput(aTextValue);
80486:     mSuppressOnInput = false;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetSelectionStart(PRInt32 *aSelectionStart)
    1: {
48892:   if (mFocusedInput)
48892:     mFocusedInput->GetSelectionStart(aSelectionStart);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::GetSelectionEnd(PRInt32 *aSelectionEnd)
    1: {
48892:   if (mFocusedInput)
48892:     mFocusedInput->GetSelectionEnd(aSelectionEnd);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::SelectTextRange(PRInt32 aStartIndex, PRInt32 aEndIndex)
    1: {
48892:  if (mFocusedInput)
74528:     mFocusedInput->SetSelectionRange(aStartIndex, aEndIndex, EmptyString());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
12047: nsFormFillController::OnSearchBegin()
12047: {
12047:   return NS_OK;
12047: }
12047: 
12047: NS_IMETHODIMP
    1: nsFormFillController::OnSearchComplete()
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::OnTextEntered(bool* aPrevent)
    1: {
    1:   NS_ENSURE_ARG(aPrevent);
    1:   NS_ENSURE_TRUE(mFocusedInput, NS_OK);
    1:   // Fire off a DOMAutoComplete event
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   mFocusedInput->GetOwnerDocument(getter_AddRefs(domDoc));
70359:   NS_ENSURE_STATE(domDoc);
    1: 
    1:   nsCOMPtr<nsIDOMEvent> event;
70359:   domDoc->CreateEvent(NS_LITERAL_STRING("Events"), getter_AddRefs(event));
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
    1:   NS_ENSURE_STATE(privateEvent);
    1: 
80486:   event->InitEvent(NS_LITERAL_STRING("DOMAutoComplete"), true, true);
    1: 
    1:   // XXXjst: We mark this event as a trusted event, it's up to the
    1:   // callers of this to ensure that it's only called from trusted
    1:   // code.
80486:   privateEvent->SetTrusted(true);
    1: 
    1:   nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(mFocusedInput);
    1: 
79445:   bool defaultActionEnabled;
    1:   targ->DispatchEvent(event, &defaultActionEnabled);
    1:   *aPrevent = !defaultActionEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::OnTextReverted(bool *_retval)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFormFillController::GetConsumeRollupEvent(bool *aConsumeRollupEvent)
    1: {
80486:   *aConsumeRollupEvent = false;
    1:   return NS_OK;
    1: }
    1: 
 1511: 
    1: ////////////////////////////////////////////////////////////////////////
    1: //// nsIAutoCompleteSearch
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::StartSearch(const nsAString &aSearchString, const nsAString &aSearchParam,
    1:                                   nsIAutoCompleteResult *aPreviousResult, nsIAutoCompleteObserver *aListener)
    1: {
29403:   nsresult rv;
    1:   nsCOMPtr<nsIAutoCompleteResult> result;
    1: 
 1511:   // If the login manager has indicated it's responsible for this field, let it
 1511:   // handle the autocomplete. Otherwise, handle with form history.
90586:   bool dummy;
90586:   if (mPwmgrInputs.Get(mFocusedInputNode, &dummy)) {
 1511:     // XXX aPreviousResult shouldn't ever be a historyResult type, since we're not letting
 1511:     // satchel manage the field?
29403:     rv = mLoginManager->AutoCompleteSearch(aSearchString,
 1511:                                          aPreviousResult,
 1511:                                          mFocusedInput,
 1511:                                          getter_AddRefs(result));
 1511:   } else {
52364:     nsCOMPtr<nsIAutoCompleteResult> formHistoryResult;
82525: 
83376:     // It appears that mFocusedInput is always null when we are focusing a XUL
83376:     // element. Scary :)
83376:     if (!mFocusedInput || nsContentUtils::IsAutocompleteEnabled(mFocusedInput)) {
29403:       nsCOMPtr <nsIFormAutoComplete> formAutoComplete =
29403:         do_GetService("@mozilla.org/satchel/form-autocomplete;1", &rv);
29403:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
29403:       rv = formAutoComplete->AutoCompleteSearch(aSearchParam,
    1:                                                 aSearchString,
31008:                                                 mFocusedInput,
29403:                                                 aPreviousResult,
52364:                                                 getter_AddRefs(formHistoryResult));
52364: 
52364:       NS_ENSURE_SUCCESS(rv, rv);
52364:     }
52364: 
52365:     mLastSearchResult = formHistoryResult;
52365:     mLastListener = aListener;
52365:     mLastSearchString = aSearchString;
52365: 
52364:     nsCOMPtr <nsIInputListAutoComplete> inputListAutoComplete =
52364:       do_GetService("@mozilla.org/satchel/inputlist-autocomplete;1", &rv);
52364:     NS_ENSURE_SUCCESS(rv, rv);
52364: 
52364:     rv = inputListAutoComplete->AutoCompleteSearch(formHistoryResult,
52364:                                                    aSearchString,
52364:                                                    mFocusedInput,
    1:                                                    getter_AddRefs(result));
52365: 
52365:     if (mFocusedInput) {
52365:       nsCOMPtr<nsIDOMHTMLElement> list;
52365:       mFocusedInput->GetList(getter_AddRefs(list));
52365: 
52365:       nsCOMPtr<nsINode> node = do_QueryInterface(list);
90586:       if (mListNode != node) {
90586:         if (mListNode) {
90586:           mListNode->RemoveMutationObserver(this);
90586:           mListNode = nsnull;
90586:         }
52365:         if (node) {
52365:           node->AddMutationObserverUnlessExists(this);
90586:           mListNode = node;
90586:         }
52365:       }
52365:     }
    1:   }
29403:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   aListener->OnSearchResult(this, result);
    1: 
    1:   return NS_OK;
    1: }
    1: 
62324: class UpdateSearchResultRunnable : public nsRunnable
62324: {
62324: public:
62324:   UpdateSearchResultRunnable(nsIAutoCompleteObserver* aObserver,
62324:                              nsIAutoCompleteSearch* aSearch,
62324:                              nsIAutoCompleteResult* aResult)
62324:     : mObserver(aObserver)
62324:     , mSearch(aSearch)
62324:     , mResult(aResult)
62324:   {}
62324: 
62324:   NS_IMETHOD Run() {
62324:     NS_ASSERTION(mObserver, "You shouldn't call this runnable with a null observer!");
62324: 
62324:     mObserver->OnUpdateSearchResult(mSearch, mResult);
62324:     return NS_OK;
62324:   }
62324: 
62324: private:
62324:   nsCOMPtr<nsIAutoCompleteObserver> mObserver;
62324:   nsCOMPtr<nsIAutoCompleteSearch> mSearch;
62324:   nsCOMPtr<nsIAutoCompleteResult> mResult;
62324: };
62324: 
52365: void nsFormFillController::RevalidateDataList()
52365: {
90586:   if (!mLastListener) {
90586:     return;
90586:   }
52365:   nsresult rv;
52365:   nsCOMPtr <nsIInputListAutoComplete> inputListAutoComplete =
52365:     do_GetService("@mozilla.org/satchel/inputlist-autocomplete;1", &rv);
52365: 
52365:   nsCOMPtr<nsIAutoCompleteResult> result;
52365: 
52365:   rv = inputListAutoComplete->AutoCompleteSearch(mLastSearchResult,
52365:                                                  mLastSearchString,
52365:                                                  mFocusedInput,
52365:                                                  getter_AddRefs(result));
62324: 
62324:   nsCOMPtr<nsIRunnable> event =
62324:     new UpdateSearchResultRunnable(mLastListener, this, result);
62324:   NS_DispatchToCurrentThread(event);
52365: }
52365: 
    1: NS_IMETHODIMP
    1: nsFormFillController::StopSearch()
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: //// nsIDOMEventListener
    1: 
    1: NS_IMETHODIMP
    1: nsFormFillController::HandleEvent(nsIDOMEvent* aEvent)
    1: {
 1511:   nsAutoString type;
 1511:   aEvent->GetType(type);
 1511: 
72597:   if (type.EqualsLiteral("focus")) {
72597:     return Focus(aEvent);
72597:   }
72597:   if (type.EqualsLiteral("mousedown")) {
72597:     return MouseDown(aEvent);
72597:   }
72597:   if (type.EqualsLiteral("keypress")) {
72597:     return KeyPress(aEvent);
72597:   }
72597:   if (type.EqualsLiteral("input")) {
72597:     return (!mSuppressOnInput && mController && mFocusedInput) ?
72597:            mController->HandleText() : NS_OK;
72597:   }
72597:   if (type.EqualsLiteral("blur")) {
72597:     if (mFocusedInput)
72597:       StopControllingInput();
72597:     return NS_OK;
72597:   }
72597:   if (type.EqualsLiteral("compositionstart")) {
72597:     NS_ASSERTION(mController, "should have a controller!");
72597:     if (mController && mFocusedInput)
72597:       mController->HandleStartComposition();
72597:     return NS_OK;
72597:   }
72597:   if (type.EqualsLiteral("compositionend")) {
72597:     NS_ASSERTION(mController, "should have a controller!");
72597:     if (mController && mFocusedInput)
72597:       mController->HandleEndComposition();
72597:     return NS_OK;
72597:   }
72597:   if (type.EqualsLiteral("contextmenu")) {
72597:     if (mFocusedPopup)
72597:       mFocusedPopup->ClosePopup();
72597:     return NS_OK;
72597:   }
 1511:   if (type.EqualsLiteral("pagehide")) {
 1511:     nsCOMPtr<nsIDOMEventTarget> target;
 1511:     aEvent->GetTarget(getter_AddRefs(target));
 1511: 
 1511:     nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(target);
 1511:     if (!domDoc)
 1511:       return NS_OK;
 1511: 
12331:     if (mFocusedInput) {
12331:       nsCOMPtr<nsIDOMDocument> inputDoc;
12331:       mFocusedInput->GetOwnerDocument(getter_AddRefs(inputDoc));
12331:       if (domDoc == inputDoc)
12331:         StopControllingInput();
12331:     }
12331: 
90586:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
90586:     PwmgrInputsEnumData ed(this, doc);
90586:     mPwmgrInputs.Enumerate(RemoveForDocumentEnumerator, &ed);
 1511:   }
 1511: 
    1:   return NS_OK;
    1: }
    1: 
 1511: 
20261: /* static */ PLDHashOperator
90586: nsFormFillController::RemoveForDocumentEnumerator(const nsINode* aKey,
90586:                                                   bool& aEntry,
 1511:                                                   void* aUserData)
 1511: {
90586:   PwmgrInputsEnumData* ed = static_cast<PwmgrInputsEnumData*>(aUserData);
90586:   if (aKey && (!ed->mDoc || aKey->OwnerDoc() == ed->mDoc)) {
91090:     // mFocusedInputNode's observer is tracked separately, don't remove it here.
91090:     if (aKey != ed->mFFC->mFocusedInputNode) {
91090:       const_cast<nsINode*>(aKey)->RemoveMutationObserver(ed->mFFC);
91090:     }
 1511:     return PL_DHASH_REMOVE;
90586:   }
 1511:   return PL_DHASH_NEXT;
 1511: }
 1511: 
72597: nsresult
    1: nsFormFillController::Focus(nsIDOMEvent* aEvent)
    1: {
    1:   nsCOMPtr<nsIDOMEventTarget> target;
    1:   aEvent->GetTarget(getter_AddRefs(target));
    1: 
    1:   nsCOMPtr<nsIDOMHTMLInputElement> input = do_QueryInterface(target);
90586:   nsCOMPtr<nsINode> inputNode = do_QueryInterface(input); 
90586:   if (!inputNode)
    1:     return NS_OK;
    1: 
79445:   bool isReadOnly = false;
    1:   input->GetReadOnly(&isReadOnly);
    1: 
82525:   bool autocomplete = nsContentUtils::IsAutocompleteEnabled(input);
82525: 
82525:   nsCOMPtr<nsIDOMHTMLElement> datalist;
82525:   input->GetList(getter_AddRefs(datalist));
82525:   bool hasList = datalist != nsnull;
15083: 
90586:   bool dummy;
79445:   bool isPwmgrInput = false;
90586:   if (mPwmgrInputs.Get(inputNode, &dummy))
80486:       isPwmgrInput = true;
15083: 
42192:   nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(input);
82525:   if (isPwmgrInput || (formControl &&
82525:                        formControl->IsSingleLineTextControl(PR_TRUE) &&
82525:                        (hasList || autocomplete) && !isReadOnly)) {
    1:     StartControllingInput(input);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
72597: nsresult
    1: nsFormFillController::KeyPress(nsIDOMEvent* aEvent)
    1: {
    1:   NS_ASSERTION(mController, "should have a controller!");
    1:   if (!mFocusedInput || !mController)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
    1:   if (!keyEvent)
    1:     return NS_ERROR_FAILURE;
    1: 
79445:   bool cancel = false;
    1: 
    1:   PRUint32 k;
    1:   keyEvent->GetKeyCode(&k);
    1:   switch (k) {
    1:   case nsIDOMKeyEvent::DOM_VK_DELETE:
    1: #ifndef XP_MACOSX
    1:     mController->HandleDelete(&cancel);
    1:     break;
    1:   case nsIDOMKeyEvent::DOM_VK_BACK_SPACE:
30200:     mController->HandleText();
    1:     break;
    1: #else
    1:   case nsIDOMKeyEvent::DOM_VK_BACK_SPACE:
    1:     {
79445:       bool isShift = false;
    1:       keyEvent->GetShiftKey(&isShift);
    1: 
    1:       if (isShift)
    1:         mController->HandleDelete(&cancel);
    1:       else
30200:         mController->HandleText();
    1: 
    1:       break;
    1:     }
    1: #endif
 9407:   case nsIDOMKeyEvent::DOM_VK_PAGE_UP:
 9407:   case nsIDOMKeyEvent::DOM_VK_PAGE_DOWN:
 9407:     {
79445:       bool isCtrl, isAlt, isMeta;
 9407:       keyEvent->GetCtrlKey(&isCtrl);
 9407:       keyEvent->GetAltKey(&isAlt);
 9407:       keyEvent->GetMetaKey(&isMeta);
 9407:       if (isCtrl || isAlt || isMeta)
 9407:         break;
 9407:     }
 9407:     /* fall through */
    1:   case nsIDOMKeyEvent::DOM_VK_UP:
    1:   case nsIDOMKeyEvent::DOM_VK_DOWN:
    1:   case nsIDOMKeyEvent::DOM_VK_LEFT:
    1:   case nsIDOMKeyEvent::DOM_VK_RIGHT:
    1:     mController->HandleKeyNavigation(k, &cancel);
    1:     break;
    1:   case nsIDOMKeyEvent::DOM_VK_ESCAPE:
    1:     mController->HandleEscape(&cancel);
    1:     break;
    1:   case nsIDOMKeyEvent::DOM_VK_TAB:
    1:     mController->HandleTab();
80486:     cancel = false;
    1:     break;
    1:   case nsIDOMKeyEvent::DOM_VK_RETURN:
80486:     mController->HandleEnter(false, &cancel);
    1:     break;
    1:   }
    1: 
    1:   if (cancel) {
    1:     aEvent->PreventDefault();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
72597: nsresult
72597: nsFormFillController::MouseDown(nsIDOMEvent* aEvent)
    1: {
72597:   nsCOMPtr<nsIDOMMouseEvent> mouseEvent(do_QueryInterface(aEvent));
    1:   if (!mouseEvent)
    1:     return NS_ERROR_FAILURE;
    1: 
 6537:   nsCOMPtr<nsIDOMEventTarget> target;
72597:   aEvent->GetTarget(getter_AddRefs(target));
 6537:   nsCOMPtr<nsIDOMHTMLInputElement> targetInput = do_QueryInterface(target);
 6537:   if (!targetInput)
 6537:     return NS_OK;
 6537: 
    1:   PRUint16 button;
    1:   mouseEvent->GetButton(&button);
    1:   if (button != 0)
    1:     return NS_OK;
    1: 
79445:   bool isOpen = false;
    1:   GetPopupOpen(&isOpen);
    1:   if (isOpen)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIAutoCompleteInput> input;
    1:   mController->GetInput(getter_AddRefs(input));
    1:   if (!input)
    1:     return NS_OK;
    1: 
    1:   nsAutoString value;
    1:   input->GetTextValue(value);
    1:   if (value.Length() > 0) {
    1:     // Show the popup with a filtered result set
    1:     mController->SetSearchString(EmptyString());
30200:     mController->HandleText();
    1:   } else {
    1:     // Show the popup with the complete result set.  Can't use HandleText()
    1:     // because it doesn't display the popup if the input is blank.
79445:     bool cancel = false;
    1:     mController->HandleKeyNavigation(nsIDOMKeyEvent::DOM_VK_DOWN, &cancel);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: //// nsFormFillController
    1: 
    1: void
    1: nsFormFillController::AddWindowListeners(nsIDOMWindow *aWindow)
    1: {
    1:   if (!aWindow)
    1:     return;
    1: 
    1:   nsCOMPtr<nsPIDOMWindow> privateDOMWindow(do_QueryInterface(aWindow));
72327:   nsIDOMEventTarget* target = nsnull;
    1:   if (privateDOMWindow)
72327:     target = privateDOMWindow->GetChromeEventHandler();
    1: 
    1:   if (!target)
    1:     return;
    1: 
72597:   target->AddEventListener(NS_LITERAL_STRING("focus"), this,
80486:                            true, false);
72597:   target->AddEventListener(NS_LITERAL_STRING("blur"), this,
80486:                            true, false);
72597:   target->AddEventListener(NS_LITERAL_STRING("pagehide"), this,
80486:                            true, false);
72597:   target->AddEventListener(NS_LITERAL_STRING("mousedown"), this,
80486:                            true, false);
72597:   target->AddEventListener(NS_LITERAL_STRING("input"), this,
80486:                            true, false);
72597:   target->AddEventListener(NS_LITERAL_STRING("compositionstart"), this,
80486:                            true, false);
72597:   target->AddEventListener(NS_LITERAL_STRING("compositionend"), this,
80486:                            true, false);
72597:   target->AddEventListener(NS_LITERAL_STRING("contextmenu"), this,
80486:                            true, false);
32980: 
32980:   // Note that any additional listeners added should ensure that they ignore
32980:   // untrusted events, which might be sent by content that's up to no good.
    1: }
    1: 
    1: void
    1: nsFormFillController::RemoveWindowListeners(nsIDOMWindow *aWindow)
    1: {
    1:   if (!aWindow)
    1:     return;
    1: 
    1:   StopControllingInput();
    1: 
12331:   nsCOMPtr<nsIDOMDocument> domDoc;
12331:   aWindow->GetDocument(getter_AddRefs(domDoc));
90586:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
90586:   PwmgrInputsEnumData ed(this, doc);
90586:   mPwmgrInputs.Enumerate(RemoveForDocumentEnumerator, &ed);
12331: 
    1:   nsCOMPtr<nsPIDOMWindow> privateDOMWindow(do_QueryInterface(aWindow));
72327:   nsIDOMEventTarget* target = nsnull;
    1:   if (privateDOMWindow)
72327:     target = privateDOMWindow->GetChromeEventHandler();
    1: 
    1:   if (!target)
    1:     return;
    1: 
80486:   target->RemoveEventListener(NS_LITERAL_STRING("focus"), this, true);
80486:   target->RemoveEventListener(NS_LITERAL_STRING("blur"), this, true);
80486:   target->RemoveEventListener(NS_LITERAL_STRING("pagehide"), this, true);
80486:   target->RemoveEventListener(NS_LITERAL_STRING("mousedown"), this, true);
80486:   target->RemoveEventListener(NS_LITERAL_STRING("input"), this, true);
72597:   target->RemoveEventListener(NS_LITERAL_STRING("compositionstart"), this,
80486:                               true);
72597:   target->RemoveEventListener(NS_LITERAL_STRING("compositionend"), this,
80486:                               true);
80486:   target->RemoveEventListener(NS_LITERAL_STRING("contextmenu"), this, true);
  345: }
  345: 
  345: void
  345: nsFormFillController::AddKeyListener(nsIDOMHTMLInputElement *aInput)
  345: {
  345:   if (!aInput)
  345:     return;
  345: 
  345:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(aInput);
  345: 
72597:   target->AddEventListener(NS_LITERAL_STRING("keypress"), this,
80486:                            true, false);
  345: }
  345: 
  345: void
  345: nsFormFillController::RemoveKeyListener()
  345: {
  345:   if (!mFocusedInput)
  345:     return;
  345: 
  345:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(mFocusedInput);
80486:   target->RemoveEventListener(NS_LITERAL_STRING("keypress"), this, true);
    1: }
    1: 
    1: void
    1: nsFormFillController::StartControllingInput(nsIDOMHTMLInputElement *aInput)
    1: {
    1:   // Make sure we're not still attached to an input
    1:   StopControllingInput();
    1: 
    1:   // Find the currently focused docShell
    1:   nsCOMPtr<nsIDocShell> docShell = GetDocShellForInput(aInput);
    1:   PRInt32 index = GetIndexOfDocShell(docShell);
    1:   if (index < 0)
    1:     return;
    1: 
    1:   // Cache the popup for the focused docShell
    1:   mPopups->GetElementAt(index, getter_AddRefs(mFocusedPopup));
    1: 
90586:   nsCOMPtr<nsINode> node = do_QueryInterface(aInput);
90586:   if (!node) {
90586:     return;
90586:   }
90586: 
  345:   AddKeyListener(aInput);
90586:   
90586:   node->AddMutationObserverUnlessExists(this);
90586:   mFocusedInputNode = node;
    1:   mFocusedInput = aInput;
    1: 
90586:   nsCOMPtr<nsIDOMHTMLElement> list;
90586:   mFocusedInput->GetList(getter_AddRefs(list));
90586:   nsCOMPtr<nsINode> listNode = do_QueryInterface(list);
90586:   if (listNode) {
90586:     listNode->AddMutationObserverUnlessExists(this);
90586:     mListNode = listNode;
90586:   }
90586: 
    1:   // Now we are the autocomplete controller's bitch
    1:   mController->SetInput(this);
    1: }
    1: 
    1: void
    1: nsFormFillController::StopControllingInput()
    1: {
  345:   RemoveKeyListener();
  345: 
90586:   if (mListNode) {
90586:     mListNode->RemoveMutationObserver(this);
90586:     mListNode = nsnull;
52365:   }
52365: 
    1:   // Reset the controller's input, but not if it has been switched
    1:   // to another input already, which might happen if the user switches
    1:   // focus by clicking another autocomplete textbox
    1:   nsCOMPtr<nsIAutoCompleteInput> input;
    1:   mController->GetInput(getter_AddRefs(input));
    1:   if (input == this)
    1:     mController->SetInput(nsnull);
    1: 
90586:   if (mFocusedInputNode) {
91090:     MaybeRemoveMutationObserver(mFocusedInputNode);
90586:     mFocusedInputNode = nsnull;
    1:     mFocusedInput = nsnull;
90586:   }
    1:   mFocusedPopup = nsnull;
    1: }
    1: 
    1: nsIDocShell *
    1: nsFormFillController::GetDocShellForInput(nsIDOMHTMLInputElement *aInput)
    1: {
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   aInput->GetOwnerDocument(getter_AddRefs(domDoc));
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:   NS_ENSURE_TRUE(doc, nsnull);
    1:   nsCOMPtr<nsIWebNavigation> webNav = do_GetInterface(doc->GetWindow());
    1:   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(webNav);
    1:   return docShell;
    1: }
    1: 
    1: nsIDOMWindow *
    1: nsFormFillController::GetWindowForDocShell(nsIDocShell *aDocShell)
    1: {
    1:   nsCOMPtr<nsIContentViewer> contentViewer;
    1:   aDocShell->GetContentViewer(getter_AddRefs(contentViewer));
    1:   NS_ENSURE_TRUE(contentViewer, nsnull);
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   contentViewer->GetDOMDocument(getter_AddRefs(domDoc));
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:   NS_ENSURE_TRUE(doc, nsnull);
    1: 
    1:   return doc->GetWindow();
    1: }
    1: 
    1: PRInt32
    1: nsFormFillController::GetIndexOfDocShell(nsIDocShell *aDocShell)
    1: {
    1:   if (!aDocShell)
    1:     return -1;
    1: 
    1:   // Loop through our cached docShells looking for the given docShell
    1:   PRUint32 count;
    1:   mDocShells->Count(&count);
    1:   for (PRUint32 i = 0; i < count; ++i) {
    1:     nsCOMPtr<nsIDocShell> docShell;
    1:     mDocShells->GetElementAt(i, getter_AddRefs(docShell));
    1:     if (docShell == aDocShell)
    1:       return i;
    1:   }
    1: 
    1:   // Recursively check the parent docShell of this one
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(aDocShell);
    1:   nsCOMPtr<nsIDocShellTreeItem> parentItem;
    1:   treeItem->GetParent(getter_AddRefs(parentItem));
    1:   if (parentItem) {
    1:     nsCOMPtr<nsIDocShell> parentShell = do_QueryInterface(parentItem);
    1:     return GetIndexOfDocShell(parentShell);
    1:   }
    1: 
    1:   return -1;
    1: }
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsFormFillController)
    1: 
46998: NS_DEFINE_NAMED_CID(NS_FORMFILLCONTROLLER_CID);
    1: 
46998: static const mozilla::Module::CIDEntry kSatchelCIDs[] = {
46998:   { &kNS_FORMFILLCONTROLLER_CID, false, NULL, nsFormFillControllerConstructor },
46998:   { NULL }
    1: };
    1: 
46998: static const mozilla::Module::ContractIDEntry kSatchelContracts[] = {
46998:   { "@mozilla.org/satchel/form-fill-controller;1", &kNS_FORMFILLCONTROLLER_CID },
46998:   { NS_FORMHISTORYAUTOCOMPLETE_CONTRACTID, &kNS_FORMFILLCONTROLLER_CID },
46998:   { NULL }
46998: };
    1: 
46998: static const mozilla::Module kSatchelModule = {
46998:   mozilla::Module::kVersion,
46998:   kSatchelCIDs,
46998:   kSatchelContracts
46998: };
46998: 
46998: NSMODULE_DEFN(satchel) = &kSatchelModule;
46998: 
