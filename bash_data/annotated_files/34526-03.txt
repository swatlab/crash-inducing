    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIAtom.h"
    1: #include "nsIXBLDocumentInfo.h"
    1: #include "nsIInputStream.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIURI.h"
    1: #include "nsIURL.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIChannel.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIParser.h"
    1: #include "nsParserCIID.h"
    1: #include "nsNetUtil.h"
    1: #include "plstr.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsIDocument.h"
    1: #include "nsIXMLContentSink.h"
    1: #include "nsContentCID.h"
    1: #include "nsXMLDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMText.h"
    1: #include "nsXBLService.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsXBLInsertionPoint.h"
    1: #include "nsXBLPrototypeBinding.h"
    1: #include "nsFixedSizeAllocator.h"
    1: #include "xptinfo.h"
    1: #include "nsIInterfaceInfoManager.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIDocumentObserver.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsXBLProtoImpl.h"
    1: #include "nsCRT.h"
    1: #include "nsContentUtils.h"
    1: 
    1: #include "nsIScriptContext.h"
    1: 
    1: #include "nsICSSLoader.h"
    1: #include "nsIStyleRuleProcessor.h"
    1: #include "nsXBLResourceLoader.h"
    1: 
    1: // Helper Classes =====================================================================
    1: 
    1: // nsXBLAttributeEntry and helpers.  This class is used to efficiently handle
    1: // attribute changes in anonymous content.
    1: 
    1: class nsXBLAttributeEntry {
    1: public:
    1:   nsIAtom* GetSrcAttribute() { return mSrcAttribute; }
    1:   nsIAtom* GetDstAttribute() { return mDstAttribute; }
    1:   PRInt32 GetDstNameSpace() { return mDstNameSpace; }
    1:   
    1:   nsIContent* GetElement() { return mElement; }
    1: 
    1:   nsXBLAttributeEntry* GetNext() { return mNext; }
    1:   void SetNext(nsXBLAttributeEntry* aEntry) { mNext = aEntry; }
    1: 
    1:   static nsXBLAttributeEntry*
    1:   Create(nsIAtom* aSrcAtom, nsIAtom* aDstAtom, PRInt32 aDstNameSpace, nsIContent* aContent) {
    1:     void* place = nsXBLPrototypeBinding::kAttrPool->Alloc(sizeof(nsXBLAttributeEntry));
    1:     return place ? ::new (place) nsXBLAttributeEntry(aSrcAtom, aDstAtom, aDstNameSpace, 
    1:                                                      aContent) : nsnull;
    1:   }
    1: 
    1:   static void
    1:   Destroy(nsXBLAttributeEntry* aSelf) {
    1:     aSelf->~nsXBLAttributeEntry();
    1:     nsXBLPrototypeBinding::kAttrPool->Free(aSelf, sizeof(*aSelf));
    1:   }
    1: 
    1: protected:
    1:   nsIContent* mElement;
    1: 
    1:   nsCOMPtr<nsIAtom> mSrcAttribute;
    1:   nsCOMPtr<nsIAtom> mDstAttribute;
    1:   PRInt32 mDstNameSpace;
    1:   nsXBLAttributeEntry* mNext;
    1: 
    1:   nsXBLAttributeEntry(nsIAtom* aSrcAtom, nsIAtom* aDstAtom, PRInt32 aDstNameSpace,
    1:                       nsIContent* aContent)
    1:     : mElement(aContent),
    1:       mSrcAttribute(aSrcAtom),
    1:       mDstAttribute(aDstAtom),
    1:       mDstNameSpace(aDstNameSpace),
    1:       mNext(nsnull) { }
    1: 
22801:   ~nsXBLAttributeEntry() {
22801:     NS_CONTENT_DELETE_LIST_MEMBER(nsXBLAttributeEntry, this, mNext);
22801:   }
    1: 
    1: private:
    1:   // Hide so that only Create() and Destroy() can be used to
    1:   // allocate and deallocate from the heap
    1:   static void* operator new(size_t) CPP_THROW_NEW { return 0; }
    1:   static void operator delete(void*, size_t) {}
    1: };
    1: 
    1: // nsXBLInsertionPointEntry and helpers.  This class stores all the necessary
    1: // info to figure out the position of an insertion point.
    1: // The same insertion point may be in the insertion point table for multiple
    1: // keys, so we refcount the entries.
    1: 
    1: class nsXBLInsertionPointEntry {
    1: public:
    1:   ~nsXBLInsertionPointEntry() {
    1:     if (mDefaultContent) {
14228:       nsAutoScriptBlocker scriptBlocker;
    1:       // mDefaultContent is a sort of anonymous content within the XBL
    1:       // document, and we own and manage it.  Unhook it here, since we're going
    1:       // away.
    1:       mDefaultContent->UnbindFromTree();
    1:     }      
    1:   }
    1: 
 1829:   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(nsXBLInsertionPointEntry)
 1829: 
    1:   nsIContent* GetInsertionParent() { return mInsertionParent; }
    1:   PRUint32 GetInsertionIndex() { return mInsertionIndex; }
    1:   void SetInsertionIndex(PRUint32 aIndex) { mInsertionIndex = aIndex; }
    1: 
    1:   nsIContent* GetDefaultContent() { return mDefaultContent; }
    1:   void SetDefaultContent(nsIContent* aChildren) { mDefaultContent = aChildren; }
    1: 
    1: 
 1835:   // We keep kPool alive as long as there is at least either a
 1835:   // nsXBLPrototypeBinding or a nsXBLInsertionPointEntry alive.
 1835:   // nsXBLPrototypeBinding has its own global refcount so it only adds 1 to
 1835:   // nsXBLInsertionPointEntry::gRefCnt as long as there's at least one
 1835:   // nsXBLPrototypeBinding alive.
 1835: 
 1835:   static void InitPool(PRInt32 aInitialSize)
 1835:   {
 1835:     if (++gRefCnt == 1) {
 1835:       kPool = new nsFixedSizeAllocator();
 1835:       if (kPool) {
 1835:         static const size_t kBucketSizes[] = {
 1835:           sizeof(nsXBLInsertionPointEntry)
 1835:         };
 1835:         kPool->Init("XBL Insertion Point Entries", kBucketSizes,
 1835:                     NS_ARRAY_LENGTH(kBucketSizes), aInitialSize);
 1835:       }
 1835:     }
 1835:   }
 1835:   static PRBool PoolInited()
 1835:   {
 1835:     return kPool != nsnull;
 1835:   }
 1835:   static void ReleasePool()
 1835:   {
 1835:     if (--gRefCnt == 0) {
 1835:       delete kPool;
 1835:     }
 1835:   }
 1835: 
    1:   static nsXBLInsertionPointEntry*
    1:   Create(nsIContent* aParent) {
 1835:     void* place = kPool->Alloc(sizeof(nsXBLInsertionPointEntry));
 1835:     if (!place) {
 1835:       return nsnull;
 1835:     }
 1835:     ++gRefCnt;
 1835:     return ::new (place) nsXBLInsertionPointEntry(aParent);
    1:   }
    1: 
    1:   static void
    1:   Destroy(nsXBLInsertionPointEntry* aSelf) {
    1:     aSelf->~nsXBLInsertionPointEntry();
 1835:     kPool->Free(aSelf, sizeof(*aSelf));
 1835:     nsXBLInsertionPointEntry::ReleasePool();
    1:   }
    1: 
    1:   nsrefcnt AddRef() {
    1:     ++mRefCnt;
    1:     NS_LOG_ADDREF(this, mRefCnt, "nsXBLInsertionPointEntry", sizeof(nsXBLInsertionPointEntry));
    1:     return mRefCnt;
    1:   }
    1: 
    1:   nsrefcnt Release() {
    1:     --mRefCnt;
    1:     NS_LOG_RELEASE(this, mRefCnt, "nsXBLInsertionPointEntry");
    1:     if (mRefCnt == 0) {
    1:       Destroy(this);
    1:       return 0;
    1:     }
    1:     return mRefCnt;
    1:   }
    1: 
    1: protected:
    1:   nsCOMPtr<nsIContent> mInsertionParent;
    1:   nsCOMPtr<nsIContent> mDefaultContent;
    1:   PRUint32 mInsertionIndex;
 1829:   nsAutoRefCnt mRefCnt;
    1: 
    1:   nsXBLInsertionPointEntry(nsIContent* aParent)
    1:     : mInsertionParent(aParent),
 1829:       mInsertionIndex(0) { }
    1: 
    1: private:
    1:   // Hide so that only Create() and Destroy() can be used to
    1:   // allocate and deallocate from the heap
    1:   static void* operator new(size_t) CPP_THROW_NEW { return 0; }
    1:   static void operator delete(void*, size_t) {}
 1835: 
 1835:   static nsFixedSizeAllocator* kPool;
 1835:   static PRUint32 gRefCnt;
    1: };
    1: 
 1835: PRUint32 nsXBLInsertionPointEntry::gRefCnt = 0;
 1835: nsFixedSizeAllocator* nsXBLInsertionPointEntry::kPool;
 1835: 
 7230: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXBLInsertionPointEntry)
 1829: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_NATIVE(nsXBLInsertionPointEntry)
 1829:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mInsertionParent)
 1829:   if (tmp->mDefaultContent) {
14228:     nsAutoScriptBlocker scriptBlocker;
 1829:     // mDefaultContent is a sort of anonymous content within the XBL
 1829:     // document, and we own and manage it.  Unhook it here, since we're going
 1829:     // away.
 1829:     tmp->mDefaultContent->UnbindFromTree();
 1829:     tmp->mDefaultContent = nsnull;
 1829:   }      
 1829: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsXBLInsertionPointEntry)
 1829:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInsertionParent)
 1829:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDefaultContent)
 1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 1829: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsXBLInsertionPointEntry, AddRef)
 1829: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsXBLInsertionPointEntry, Release)
 1829: 
    1: // =============================================================================
    1: 
    1: // Static initialization
    1: PRUint32 nsXBLPrototypeBinding::gRefCnt = 0;
    1: 
    1: nsFixedSizeAllocator* nsXBLPrototypeBinding::kAttrPool;
    1: 
    1: static const PRInt32 kNumElements = 128;
    1: 
    1: static const size_t kAttrBucketSizes[] = {
    1:   sizeof(nsXBLAttributeEntry)
    1: };
    1: 
    1: static const PRInt32 kAttrNumBuckets = sizeof(kAttrBucketSizes)/sizeof(size_t);
    1: static const PRInt32 kAttrInitialSize = (NS_SIZE_IN_HEAP(sizeof(nsXBLAttributeEntry))) * kNumElements;
    1: 
    1: static const PRInt32 kInsInitialSize = (NS_SIZE_IN_HEAP(sizeof(nsXBLInsertionPointEntry))) * kNumElements;
    1: 
    1: // Implementation /////////////////////////////////////////////////////////////////
    1: 
    1: // Constructors/Destructors
    1: nsXBLPrototypeBinding::nsXBLPrototypeBinding()
    1: : mImplementation(nsnull),
    1:   mBaseBinding(nsnull),
    1:   mInheritStyle(PR_TRUE), 
    1:   mHasBaseProto(PR_TRUE),
    1:   mKeyHandlersRegistered(PR_FALSE),
    1:   mResources(nsnull),
    1:   mAttributeTable(nsnull),
    1:   mInsertionPointTable(nsnull),
    1:   mInterfaceTable(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsXBLPrototypeBinding);
    1:   gRefCnt++;
    1: 
    1:   if (gRefCnt == 1) {
    1:     kAttrPool = new nsFixedSizeAllocator();
    1:     if (kAttrPool) {
    1:       kAttrPool->Init("XBL Attribute Entries", kAttrBucketSizes, kAttrNumBuckets, kAttrInitialSize);
    1:     }
 1835:     nsXBLInsertionPointEntry::InitPool(kInsInitialSize);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::Init(const nsACString& aID,
    1:                             nsIXBLDocumentInfo* aInfo,
34526:                             nsIContent* aElement,
34526:                             PRBool aFirstBinding)
    1: {
 1835:   if (!kAttrPool || !nsXBLInsertionPointEntry::PoolInited()) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   nsresult rv = aInfo->DocumentURI()->Clone(getter_AddRefs(mBindingURI));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // The binding URI might not be a nsIURL (e.g. for data: URIs). In that case,
    1:   // we always use the first binding, so we don't need to keep track of the ID.
    1:   nsCOMPtr<nsIURL> bindingURL = do_QueryInterface(mBindingURI);
34526:   if (bindingURL) {
34526:     if (aFirstBinding) {
34526:       rv = mBindingURI->Clone(getter_AddRefs(mAlternateBindingURI));
34526:       NS_ENSURE_SUCCESS(rv, rv);
34526:     }
    1:     bindingURL->SetRef(aID);
34526:   }
    1: 
    1:   mXBLDocInfoWeak = aInfo;
    1: 
    1:   SetBindingElement(aElement);
    1:   return NS_OK;
    1: }
    1: 
34526: PRBool nsXBLPrototypeBinding::CompareBindingURI(nsIURI* aURI) const
34526: {
34526:   PRBool equal;
34526:   mBindingURI->Equals(aURI, &equal);
34526:   if (!equal && mAlternateBindingURI) {
34526:     mAlternateBindingURI->Equals(aURI, &equal);
34526:   }
34526:   return equal;
34526: }
34526: 
20261: static PRIntn
 1829: TraverseInsertionPoint(nsHashKey* aKey, void* aData, void* aClosure)
 1829: {
 1829:   nsCycleCollectionTraversalCallback &cb = 
 3233:     *static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 1829:   nsXBLInsertionPointEntry* entry =
 3233:     static_cast<nsXBLInsertionPointEntry*>(aData);
 1829:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(entry,
13202:                                                nsXBLInsertionPointEntry,
13202:                                                "[insertion point table] value")
 1829:   return kHashEnumerateNext;
 1829: }
 1829: 
20261: static PRBool
 1829: TraverseBinding(nsHashKey *aKey, void *aData, void* aClosure)
 1829: {
 1829:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 3233:   cb->NoteXPCOMChild(static_cast<nsISupports*>(aData));
 1829:   return kHashEnumerateNext;
 1829: }
 1829: 
    1: void
    1: nsXBLPrototypeBinding::Traverse(nsCycleCollectionTraversalCallback &cb) const
    1: {
    1:   cb.NoteXPCOMChild(mBinding);
    1:   if (mResources)
    1:     cb.NoteXPCOMChild(mResources->mLoader);
 1829:   if (mInsertionPointTable)
 1829:     mInsertionPointTable->Enumerate(TraverseInsertionPoint, &cb);
 1829:   if (mInterfaceTable)
 1829:     mInterfaceTable->Enumerate(TraverseBinding, &cb);
    1: }
    1: 
    1: void
10981: nsXBLPrototypeBinding::UnlinkJSObjects()
 6392: {
 6392:   if (mImplementation)
10981:     mImplementation->UnlinkJSObjects();
 6392: }
 6392: 
 6392: void
 7230: nsXBLPrototypeBinding::Trace(TraceCallback aCallback, void *aClosure) const
 7230: {
 7230:   if (mImplementation)
 7230:     mImplementation->Trace(aCallback, aClosure);
 7230: }
 7230: 
 7230: void
    1: nsXBLPrototypeBinding::Initialize()
    1: {
    1:   nsIContent* content = GetImmediateChild(nsGkAtoms::content);
    1:   if (content) {
    1:     // Make sure to construct the attribute table first, since constructing the
    1:     // insertion point table removes some of the subtrees, which makes them
    1:     // unreachable by walking our DOM.
    1:     ConstructAttributeTable(content);
    1:     ConstructInsertionTable(content);
    1:   }
    1: }
    1: 
    1: nsXBLPrototypeBinding::~nsXBLPrototypeBinding(void)
    1: {
    1:   delete mResources;
    1:   delete mAttributeTable;
    1:   delete mInsertionPointTable;
    1:   delete mInterfaceTable;
    1:   delete mImplementation;
    1:   gRefCnt--;
    1:   if (gRefCnt == 0) {
    1:     delete kAttrPool;
 1835:     nsXBLInsertionPointEntry::ReleasePool();
    1:   }
    1:   MOZ_COUNT_DTOR(nsXBLPrototypeBinding);
    1: }
    1: 
    1: void
    1: nsXBLPrototypeBinding::SetBasePrototype(nsXBLPrototypeBinding* aBinding)
    1: {
    1:   if (mBaseBinding == aBinding)
    1:     return;
    1: 
    1:   if (mBaseBinding) {
    1:     NS_ERROR("Base XBL prototype binding is already defined!");
    1:     return;
    1:   }
    1: 
    1:   mBaseBinding = aBinding;
    1: }
    1: 
    1: already_AddRefed<nsIContent>
    1: nsXBLPrototypeBinding::GetBindingElement()
    1: {
    1:   nsIContent* result = mBinding;
    1:   NS_IF_ADDREF(result);
    1:   return result;
    1: }
    1: 
    1: void
    1: nsXBLPrototypeBinding::SetBindingElement(nsIContent* aElement)
    1: {
    1:   mBinding = aElement;
    1:   if (mBinding->AttrValueIs(kNameSpaceID_None, nsGkAtoms::inheritstyle,
    1:                             nsGkAtoms::_false, eCaseMatters))
    1:     mInheritStyle = PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::GetAllowScripts(PRBool* aResult)
    1: {
    1:   return mXBLDocInfoWeak->GetScriptAccess(aResult);
    1: }
    1: 
    1: PRBool
    1: nsXBLPrototypeBinding::LoadResources()
    1: {
    1:   if (mResources) {
    1:     PRBool result;
    1:     mResources->LoadResources(&result);
    1:     return result;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::AddResource(nsIAtom* aResourceType, const nsAString& aSrc)
    1: {
    1:   if (!mResources) {
    1:     mResources = new nsXBLPrototypeResources(this);
    1:     if (!mResources)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   mResources->AddResource(aResourceType, aSrc);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::FlushSkinSheets()
    1: {
    1:   if (mResources)
    1:     return mResources->FlushSkinSheets();
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::BindingAttached(nsIContent* aBoundElement)
    1: {
 6687:   if (mImplementation && mImplementation->CompiledMembers() &&
 6687:       mImplementation->mConstructor)
    1:     return mImplementation->mConstructor->Execute(aBoundElement);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::BindingDetached(nsIContent* aBoundElement)
    1: {
 6687:   if (mImplementation && mImplementation->CompiledMembers() &&
 6687:       mImplementation->mDestructor)
    1:     return mImplementation->mDestructor->Execute(aBoundElement);
    1:   return NS_OK;
    1: }
    1: 
    1: nsXBLProtoImplAnonymousMethod*
    1: nsXBLPrototypeBinding::GetConstructor()
    1: {
    1:   if (mImplementation)
    1:     return mImplementation->mConstructor;
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsXBLProtoImplAnonymousMethod*
    1: nsXBLPrototypeBinding::GetDestructor()
    1: {
    1:   if (mImplementation)
    1:     return mImplementation->mDestructor;
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::SetConstructor(nsXBLProtoImplAnonymousMethod* aMethod)
    1: {
    1:   if (!mImplementation)
    1:     return NS_ERROR_FAILURE;
    1:   mImplementation->mConstructor = aMethod;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::SetDestructor(nsXBLProtoImplAnonymousMethod* aMethod)
    1: {
    1:   if (!mImplementation)
    1:     return NS_ERROR_FAILURE;
    1:   mImplementation->mDestructor = aMethod;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::InstallImplementation(nsIContent* aBoundElement)
    1: {
    1:   if (mImplementation)
    1:     return mImplementation->InstallImplementation(this, aBoundElement);
    1:   return NS_OK;
    1: }
    1: 
    1: // XXXbz this duplicates lots of SetAttrs
    1: void
    1: nsXBLPrototypeBinding::AttributeChanged(nsIAtom* aAttribute,
    1:                                         PRInt32 aNameSpaceID,
    1:                                         PRBool aRemoveFlag, 
    1:                                         nsIContent* aChangedElement,
    1:                                         nsIContent* aAnonymousContent,
    1:                                         PRBool aNotify)
    1: {
    1:   if (!mAttributeTable)
    1:     return;
    1:   nsPRUint32Key nskey(aNameSpaceID);
 3233:   nsObjectHashtable *attributesNS = static_cast<nsObjectHashtable*>(mAttributeTable->Get(&nskey));
    1:   if (!attributesNS)
    1:     return;
    1: 
    1:   nsISupportsKey key(aAttribute);
 3233:   nsXBLAttributeEntry* xblAttr = static_cast<nsXBLAttributeEntry*>
 3233:                                             (attributesNS->Get(&key));
    1:   if (!xblAttr)
    1:     return;
    1: 
    1:   // Iterate over the elements in the array.
 2528:   nsCOMPtr<nsIContent> content = GetImmediateChild(nsGkAtoms::content);
    1:   while (xblAttr) {
    1:     nsIContent* element = xblAttr->GetElement();
    1: 
 2528:     nsCOMPtr<nsIContent> realElement = LocateInstance(aChangedElement, content,
 2528:                                                       aAnonymousContent,
 2528:                                                       element);
    1: 
    1:     if (realElement) {
13301:       // Hold a strong reference here so that the atom doesn't go away during
13301:       // UnsetAttr.
13301:       nsCOMPtr<nsIAtom> dstAttr = xblAttr->GetDstAttribute();
    1:       PRInt32 dstNs = xblAttr->GetDstNameSpace();
    1: 
    1:       if (aRemoveFlag)
    1:         realElement->UnsetAttr(dstNs, dstAttr, aNotify);
    1:       else {
    1:         PRBool attrPresent = PR_TRUE;
    1:         nsAutoString value;
    1:         // Check to see if the src attribute is xbl:text.  If so, then we need to obtain the 
    1:         // children of the real element and get the text nodes' values.
    1:         if (aAttribute == nsGkAtoms::text && aNameSpaceID == kNameSpaceID_XBL) {
    1:           nsContentUtils::GetNodeTextContent(aChangedElement, PR_FALSE, value);
    1:           value.StripChar(PRUnichar('\n'));
    1:           value.StripChar(PRUnichar('\r'));
    1:           nsAutoString stripVal(value);
    1:           stripVal.StripWhitespace();
    1:           if (stripVal.IsEmpty()) 
    1:             attrPresent = PR_FALSE;
    1:         }    
    1:         else {
    1:           attrPresent = aChangedElement->GetAttr(aNameSpaceID, aAttribute, value);
    1:         }
    1: 
    1:         if (attrPresent)
    1:           realElement->SetAttr(dstNs, dstAttr, value, aNotify);
    1:       }
    1: 
    1:       // See if we're the <html> tag in XUL, and see if value is being
    1:       // set or unset on us.  We may also be a tag that is having
    1:       // xbl:text set on us.
    1: 
    1:       if ((dstAttr == nsGkAtoms::text && dstNs == kNameSpaceID_XBL) ||
    1:           realElement->NodeInfo()->Equals(nsGkAtoms::html,
    1:                                           kNameSpaceID_XUL) &&
    1:           dstAttr == nsGkAtoms::value) {
    1:         // Flush out all our kids.
    1:         PRUint32 childCount = realElement->GetChildCount();
    1:         for (PRUint32 i = 0; i < childCount; i++)
    1:           realElement->RemoveChildAt(0, aNotify);
    1: 
    1:         if (!aRemoveFlag) {
    1:           // Construct a new text node and insert it.
    1:           nsAutoString value;
    1:           aChangedElement->GetAttr(aNameSpaceID, aAttribute, value);
    1:           if (!value.IsEmpty()) {
    1:             nsCOMPtr<nsIContent> textContent;
    1:             NS_NewTextNode(getter_AddRefs(textContent),
    1:                            realElement->NodeInfo()->NodeInfoManager());
    1:             if (!textContent) {
    1:               continue;
    1:             }
    1: 
    1:             textContent->SetText(value, PR_TRUE);
    1:             realElement->AppendChildTo(textContent, PR_TRUE);
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     xblAttr = xblAttr->GetNext();
    1:   }
    1: }
    1: 
    1: struct InsertionData {
    1:   nsXBLBinding* mBinding;
    1:   nsXBLPrototypeBinding* mPrototype;
    1: 
    1:   InsertionData(nsXBLBinding* aBinding,
    1:                 nsXBLPrototypeBinding* aPrototype) 
  731:     :mBinding(aBinding), mPrototype(aPrototype) {}
    1: };
    1: 
20261: PRBool InstantiateInsertionPoint(nsHashKey* aKey, void* aData, void* aClosure)
    1: {
 3233:   nsXBLInsertionPointEntry* entry = static_cast<nsXBLInsertionPointEntry*>(aData);
 3233:   InsertionData* data = static_cast<InsertionData*>(aClosure);
    1:   nsXBLBinding* binding = data->mBinding;
    1:   nsXBLPrototypeBinding* proto = data->mPrototype;
    1: 
    1:   // Get the insertion parent.
    1:   nsIContent* content = entry->GetInsertionParent();
    1:   PRUint32 index = entry->GetInsertionIndex();
    1:   nsIContent* defContent = entry->GetDefaultContent();
    1: 
    1:   // Locate the real content.
    1:   nsIContent *instanceRoot = binding->GetAnonymousContent();
    1:   nsIContent *templRoot = proto->GetImmediateChild(nsGkAtoms::content);
    1:   nsIContent *realContent = proto->LocateInstance(nsnull, templRoot,
    1:                                                   instanceRoot, content);
    1:   if (!realContent)
    1:     realContent = binding->GetBoundElement();
    1: 
    1:   // Now that we have the real content, look it up in our table.
    1:   nsInsertionPointList* points = nsnull;
    1:   binding->GetInsertionPointsFor(realContent, &points);
    1:   nsXBLInsertionPoint* insertionPoint = nsnull;
    1:   PRInt32 count = points->Length();
    1:   PRInt32 i = 0;
    1:   PRInt32 currIndex = 0;  
    1:   
    1:   for ( ; i < count; i++) {
    1:     nsXBLInsertionPoint* currPoint = points->ElementAt(i);
    1:     currIndex = currPoint->GetInsertionIndex();
    1:     if (currIndex == (PRInt32)index) {
    1:       // This is a match. Break out of the loop and set our variable.
    1:       insertionPoint = currPoint;
    1:       break;
    1:     }
    1:     
    1:     if (currIndex > (PRInt32)index)
    1:       // There was no match. Break.
    1:       break;
    1:   }
    1: 
    1:   if (!insertionPoint) {
    1:     // We need to make a new insertion point.
    1:     insertionPoint = new nsXBLInsertionPoint(realContent, index, defContent);
    1:     if (insertionPoint) {
    1:       points->InsertElementAt(i, insertionPoint);
    1:     }
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsXBLPrototypeBinding::InstantiateInsertionPoints(nsXBLBinding* aBinding)
    1: {
    1:   InsertionData data(aBinding, this);
    1:   if (mInsertionPointTable)
    1:     mInsertionPointTable->Enumerate(InstantiateInsertionPoint, &data);
    1: }
    1: 
    1: nsIContent*
    1: nsXBLPrototypeBinding::GetInsertionPoint(nsIContent* aBoundElement,
    1:                                          nsIContent* aCopyRoot,
    1:                                          nsIContent* aChild,
    1:                                          PRUint32* aIndex)
    1: {
    1:   if (!mInsertionPointTable)
    1:     return nsnull;
    1: 
    1:   nsISupportsKey key(aChild->Tag());
 3233:   nsXBLInsertionPointEntry* entry = static_cast<nsXBLInsertionPointEntry*>(mInsertionPointTable->Get(&key));
    1:   if (!entry) {
    1:     nsISupportsKey key2(nsGkAtoms::children);
 3233:     entry = static_cast<nsXBLInsertionPointEntry*>(mInsertionPointTable->Get(&key2));
    1:   }
    1: 
    1:   nsIContent *realContent = nsnull;
    1:   if (entry) {
    1:     nsIContent* content = entry->GetInsertionParent();
    1:     *aIndex = entry->GetInsertionIndex();
    1:     nsIContent* templContent = GetImmediateChild(nsGkAtoms::content);
    1:     realContent = LocateInstance(nsnull, templContent, aCopyRoot, content);
    1:   }
    1:   else {
    1:     // We got nothin'.  Bail.
    1:     return nsnull;
    1:   }
    1: 
    1:   return realContent ? realContent : aBoundElement;
    1: }
    1: 
    1: nsIContent*
    1: nsXBLPrototypeBinding::GetSingleInsertionPoint(nsIContent* aBoundElement,
    1:                                                nsIContent* aCopyRoot,
    1:                                                PRUint32* aIndex,
    1:                                                PRBool* aMultipleInsertionPoints)
    1: { 
    1:   *aMultipleInsertionPoints = PR_FALSE;
    1:   *aIndex = 0;
    1: 
    1:   if (!mInsertionPointTable)
    1:     return nsnull;
    1: 
    1:   if (mInsertionPointTable->Count() != 1) {
    1:     *aMultipleInsertionPoints = PR_TRUE;
    1:     return nsnull;
    1:   }
    1: 
    1:   nsISupportsKey key(nsGkAtoms::children);
    1:   nsXBLInsertionPointEntry* entry =
 3233:     static_cast<nsXBLInsertionPointEntry*>(mInsertionPointTable->Get(&key));
    1: 
    1:   if (!entry) {
    1:     // The only insertion point specified was actually a filtered insertion
    1:     // point. This means (strictly speaking) that we actually have multiple
    1:     // insertion points: the filtered one and a generic insertion point
    1:     // (content that doesn't match the filter will just go right underneath the
    1:     // bound element).
    1: 
    1:     *aMultipleInsertionPoints = PR_TRUE;
    1:     *aIndex = 0;
    1:     return nsnull;
    1:   }
    1: 
    1:   *aMultipleInsertionPoints = PR_FALSE;
    1:   *aIndex = entry->GetInsertionIndex();
    1: 
    1:   nsIContent* templContent = GetImmediateChild(nsGkAtoms::content);
    1:   nsIContent* content = entry->GetInsertionParent();
    1:   nsIContent *realContent = LocateInstance(nsnull, templContent, aCopyRoot,
    1:                                            content);
    1: 
    1:   return realContent ? realContent : aBoundElement;
    1: }
    1: 
    1: void
    1: nsXBLPrototypeBinding::SetBaseTag(PRInt32 aNamespaceID, nsIAtom* aTag)
    1: {
    1:   mBaseNameSpaceID = aNamespaceID;
    1:   mBaseTag = aTag;
    1: }
    1: 
    1: nsIAtom*
    1: nsXBLPrototypeBinding::GetBaseTag(PRInt32* aNamespaceID)
    1: {
    1:   if (mBaseTag) {
    1:     *aNamespaceID = mBaseNameSpaceID;
    1:     return mBaseTag;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsXBLPrototypeBinding::ImplementsInterface(REFNSIID aIID) const
    1: {
    1:   // Check our IID table.
    1:   if (mInterfaceTable) {
    1:     nsIIDKey key(aIID);
 3233:     nsCOMPtr<nsISupports> supports = getter_AddRefs(static_cast<nsISupports*>(mInterfaceTable->Get(&key)));
    1:     return supports != nsnull;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // Internal helpers ///////////////////////////////////////////////////////////////////////
    1: 
    1: nsIContent*
    1: nsXBLPrototypeBinding::GetImmediateChild(nsIAtom* aTag)
    1: {
    1:   PRUint32 childCount = mBinding->GetChildCount();
    1: 
    1:   for (PRUint32 i = 0; i < childCount; i++) {
    1:     nsIContent* child = mBinding->GetChildAt(i);
    1:     if (child->NodeInfo()->Equals(aTag, kNameSpaceID_XBL)) {
    1:       return child;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1:  
    1: nsresult
    1: nsXBLPrototypeBinding::InitClass(const nsCString& aClassName,
    1:                                  JSContext * aContext, JSObject * aGlobal,
    1:                                  JSObject * aScriptObject,
    1:                                  void ** aClassObject)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aClassObject); 
    1: 
    1:   *aClassObject = nsnull;
    1: 
    1:   return nsXBLBinding::DoInitJSClass(aContext, aGlobal, aScriptObject,
 6392:                                      aClassName, this, aClassObject);
    1: }
    1: 
    1: nsIContent*
    1: nsXBLPrototypeBinding::LocateInstance(nsIContent* aBoundElement,
    1:                                       nsIContent* aTemplRoot,
    1:                                       nsIContent* aCopyRoot, 
    1:                                       nsIContent* aTemplChild)
    1: {
    1:   // XXX We will get in trouble if the binding instantiation deviates from the template
    1:   // in the prototype.
    1:   if (aTemplChild == aTemplRoot || !aTemplChild)
    1:     return nsnull;
    1: 
    1:   nsCOMPtr<nsIContent> templParent = aTemplChild->GetParent();
    1:   nsCOMPtr<nsIContent> childPoint;
    1: 
    1:   // We may be disconnected from our parent during cycle collection.
    1:   if (!templParent)
    1:     return nsnull;
    1:   
    1:   if (aBoundElement) {
    1:     if (templParent->NodeInfo()->Equals(nsGkAtoms::children,
    1:                                         kNameSpaceID_XBL)) {
    1:       childPoint = templParent;
    1:       templParent = childPoint->GetParent();
    1:     }
    1:   }
    1: 
    1:   if (!templParent)
    1:     return nsnull;
    1: 
    1:   nsIContent* result = nsnull;
    1:   nsIContent *copyParent;
    1: 
    1:   if (templParent == aTemplRoot)
    1:     copyParent = aCopyRoot;
    1:   else
    1:     copyParent = LocateInstance(aBoundElement, aTemplRoot, aCopyRoot, templParent);
    1:   
    1:   if (childPoint && aBoundElement) {
    1:     // First we have to locate this insertion point and use its index and its
    1:     // count to detemine our precise position within the template.
    1:     nsIDocument* doc = aBoundElement->GetOwnerDoc();
    1:     nsXBLBinding *binding = doc->BindingManager()->GetBinding(aBoundElement);
    1:     nsIContent *anonContent = nsnull;
    1: 
    1:     while (binding) {
    1:       anonContent = binding->GetAnonymousContent();
    1:       if (anonContent)
    1:         break;
    1: 
    1:       binding = binding->GetBaseBinding();
    1:     }
    1: 
    1:     nsInsertionPointList* points = nsnull;
    1:     if (anonContent == copyParent)
    1:       binding->GetInsertionPointsFor(aBoundElement, &points);
    1:     else
    1:       binding->GetInsertionPointsFor(copyParent, &points);
    1:     PRInt32 count = points->Length();
    1:     for (PRInt32 i = 0; i < count; i++) {
    1:       // Next we have to find the real insertion point for this proto insertion
    1:       // point.  If it does not contain any default content, then we should 
    1:       // return null, since the content is not in the clone.
 3233:       nsXBLInsertionPoint* currPoint = static_cast<nsXBLInsertionPoint*>(points->ElementAt(i));
    1:       nsCOMPtr<nsIContent> defContent = currPoint->GetDefaultContentTemplate();
    1:       if (defContent == childPoint) {
    1:         // Now check to see if we even built default content at this
    1:         // insertion point.
    1:         defContent = currPoint->GetDefaultContent();
    1:         if (defContent) {
    1:           // Find out the index of the template element within the <children> elt.
    1:           PRInt32 index = childPoint->IndexOf(aTemplChild);
    1:           
    1:           // Now we just have to find the corresponding elt underneath the cloned
    1:           // default content.
    1:           result = defContent->GetChildAt(index);
    1:         } 
    1:         break;
    1:       }
    1:     }
    1:   }
    1:   else if (copyParent)
    1:   {
    1:     PRInt32 index = templParent->IndexOf(aTemplChild);
    1:     result = copyParent->GetChildAt(index);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: struct nsXBLAttrChangeData
    1: {
    1:   nsXBLPrototypeBinding* mProto;
    1:   nsIContent* mBoundElement;
    1:   nsIContent* mContent;
    1:   PRInt32 mSrcNamespace;
    1: 
    1:   nsXBLAttrChangeData(nsXBLPrototypeBinding* aProto,
    1:                       nsIContent* aElt, nsIContent* aContent) 
  731:   :mProto(aProto), mBoundElement(aElt), mContent(aContent) {}
    1: };
    1: 
    1: // XXXbz this duplicates lots of AttributeChanged
20261: PRBool SetAttrs(nsHashKey* aKey, void* aData, void* aClosure)
    1: {
 3233:   nsXBLAttributeEntry* entry = static_cast<nsXBLAttributeEntry*>(aData);
 3233:   nsXBLAttrChangeData* changeData = static_cast<nsXBLAttrChangeData*>(aClosure);
    1: 
    1:   nsIAtom* src = entry->GetSrcAttribute();
    1:   PRInt32 srcNs = changeData->mSrcNamespace;
    1:   nsAutoString value;
    1:   PRBool attrPresent = PR_TRUE;
    1: 
    1:   if (src == nsGkAtoms::text && srcNs == kNameSpaceID_XBL) {
    1:     nsContentUtils::GetNodeTextContent(changeData->mBoundElement, PR_FALSE,
    1:                                        value);
    1:     value.StripChar(PRUnichar('\n'));
    1:     value.StripChar(PRUnichar('\r'));
    1:     nsAutoString stripVal(value);
    1:     stripVal.StripWhitespace();
    1: 
    1:     if (stripVal.IsEmpty()) 
    1:       attrPresent = PR_FALSE;
    1:   }
    1:   else {
    1:     attrPresent = changeData->mBoundElement->GetAttr(srcNs, src, value);
    1:   }
    1: 
    1:   if (attrPresent) {
    1:     nsIContent* content =
    1:       changeData->mProto->GetImmediateChild(nsGkAtoms::content);
    1: 
    1:     nsXBLAttributeEntry* curr = entry;
    1:     while (curr) {
    1:       nsIAtom* dst = curr->GetDstAttribute();
    1:       PRInt32 dstNs = curr->GetDstNameSpace();
    1:       nsIContent* element = curr->GetElement();
    1: 
    1:       nsIContent *realElement =
    1:         changeData->mProto->LocateInstance(changeData->mBoundElement, content,
    1:                                            changeData->mContent, element);
    1: 
    1:       if (realElement) {
    1:         realElement->SetAttr(dstNs, dst, value, PR_FALSE);
    1: 
    1:         if ((dst == nsGkAtoms::text && dstNs == kNameSpaceID_XBL) ||
    1:             (realElement->NodeInfo()->Equals(nsGkAtoms::html,
    1:                                              kNameSpaceID_XUL) &&
    1:              dst == nsGkAtoms::value && !value.IsEmpty())) {
    1: 
    1:           nsCOMPtr<nsIContent> textContent;
    1:           NS_NewTextNode(getter_AddRefs(textContent),
    1:                          realElement->NodeInfo()->NodeInfoManager());
    1:           if (!textContent) {
    1:             continue;
    1:           }
    1: 
    1:           textContent->SetText(value, PR_FALSE);
    1:           realElement->AppendChildTo(textContent, PR_FALSE);
    1:         }
    1:       }
    1: 
    1:       curr = curr->GetNext();
    1:     }
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
20261: PRBool SetAttrsNS(nsHashKey* aKey, void* aData, void* aClosure)
    1: {
    1:   if (aData && aClosure) {
 3233:     nsPRUint32Key * key = static_cast<nsPRUint32Key*>(aKey);
    1:     nsObjectHashtable* xblAttributes =
 3233:       static_cast<nsObjectHashtable*>(aData);
 3233:     nsXBLAttrChangeData * changeData = static_cast<nsXBLAttrChangeData *>
 3233:                                                   (aClosure);
    1:     changeData->mSrcNamespace = key->GetValue();
    1:     xblAttributes->Enumerate(SetAttrs, (void*)changeData);
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsXBLPrototypeBinding::SetInitialAttributes(nsIContent* aBoundElement, nsIContent* aAnonymousContent)
    1: {
    1:   if (mAttributeTable) {
    1:     nsXBLAttrChangeData data(this, aBoundElement, aAnonymousContent);
    1:     mAttributeTable->Enumerate(SetAttrsNS, (void*)&data);
    1:   }
    1: }
    1: 
    1: nsIStyleRuleProcessor*
    1: nsXBLPrototypeBinding::GetRuleProcessor()
    1: {
    1:   if (mResources) {
    1:     return mResources->mRuleProcessor;
    1:   }
    1:   
    1:   return nsnull;
    1: }
    1: 
    1: nsCOMArray<nsICSSStyleSheet>*
    1: nsXBLPrototypeBinding::GetStyleSheets()
    1: {
    1:   if (mResources) {
    1:     return &mResources->mStyleSheetList;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
20261: static PRBool
    1: DeleteAttributeEntry(nsHashKey* aKey, void* aData, void* aClosure)
    1: {
 3233:   nsXBLAttributeEntry::Destroy(static_cast<nsXBLAttributeEntry*>(aData));
    1:   return PR_TRUE;
    1: }
    1: 
20261: static PRBool
    1: DeleteAttributeTable(nsHashKey* aKey, void* aData, void* aClosure)
    1: {
 3233:   delete static_cast<nsObjectHashtable*>(aData);
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsXBLPrototypeBinding::ConstructAttributeTable(nsIContent* aElement)
    1: {
    1:   // Don't add entries for <children> elements, since those will get
    1:   // removed from the DOM when we construct the insertion point table.
    1:   if (!aElement->NodeInfo()->Equals(nsGkAtoms::children, kNameSpaceID_XBL)) {
    1:     nsAutoString inherits;
    1:     aElement->GetAttr(kNameSpaceID_XBL, nsGkAtoms::inherits, inherits);
    1: 
    1:     if (!inherits.IsEmpty()) {
    1:       if (!mAttributeTable) {
    1:         mAttributeTable = new nsObjectHashtable(nsnull, nsnull,
    1:                                                 DeleteAttributeTable,
    1:                                                 nsnull, 4);
    1:         if (!mAttributeTable)
    1:           return;
    1:       }
    1: 
    1:       // The user specified at least one attribute.
    1:       char* str = ToNewCString(inherits);
    1:       char* newStr;
    1:       // XXX We should use a strtok function that tokenizes PRUnichars
    1:       // so that we don't have to convert from Unicode to ASCII and then back
    1: 
    1:       char* token = nsCRT::strtok( str, ", ", &newStr );
    1:       while( token != NULL ) {
    1:         // Build an atom out of this attribute.
    1:         nsCOMPtr<nsIAtom> atom;
    1:         PRInt32 atomNsID = kNameSpaceID_None;
    1:         nsCOMPtr<nsIAtom> attribute;
    1:         PRInt32 attributeNsID = kNameSpaceID_None;
    1: 
    1:         // Figure out if this token contains a :.
    1:         nsAutoString attrTok; attrTok.AssignWithConversion(token);
    1:         PRInt32 index = attrTok.Find("=", PR_TRUE);
    1:         nsresult rv;
    1:         if (index != -1) {
    1:           // This attribute maps to something different.
    1:           nsAutoString left, right;
    1:           attrTok.Left(left, index);
    1:           attrTok.Right(right, attrTok.Length()-index-1);
    1: 
    1:           rv = nsContentUtils::SplitQName(aElement, left, &attributeNsID,
    1:                                           getter_AddRefs(attribute));
    1:           if (NS_FAILED(rv))
    1:             return;
    1: 
    1:           rv = nsContentUtils::SplitQName(aElement, right, &atomNsID,
    1:                                           getter_AddRefs(atom));
    1:           if (NS_FAILED(rv))
    1:             return;
    1:         }
    1:         else {
    1:           nsAutoString tok;
    1:           tok.AssignWithConversion(token);
    1:           rv = nsContentUtils::SplitQName(aElement, tok, &atomNsID, 
    1:                                           getter_AddRefs(atom));
    1:           if (NS_FAILED(rv))
    1:             return;
    1:           attribute = atom;
    1:           attributeNsID = atomNsID;
    1:         }
    1: 
    1:         nsPRUint32Key nskey(atomNsID);
    1:         nsObjectHashtable* attributesNS =
 3233:           static_cast<nsObjectHashtable*>(mAttributeTable->Get(&nskey));
    1:         if (!attributesNS) {
    1:           attributesNS = new nsObjectHashtable(nsnull, nsnull,
    1:                                                DeleteAttributeEntry,
    1:                                                nsnull, 4);
    1:           if (!attributesNS)
    1:             return;
    1: 
    1:           mAttributeTable->Put(&nskey, attributesNS);
    1:         }
    1:       
    1:         // Create an XBL attribute entry.
    1:         nsXBLAttributeEntry* xblAttr =
    1:           nsXBLAttributeEntry::Create(atom, attribute, attributeNsID, aElement);
    1: 
    1:         // Now we should see if some element within our anonymous
    1:         // content is already observing this attribute.
    1:         nsISupportsKey key(atom);
 3233:         nsXBLAttributeEntry* entry = static_cast<nsXBLAttributeEntry*>
 3233:                                                 (attributesNS->Get(&key));
    1: 
    1:         if (!entry) {
    1:           // Put it in the table.
    1:           attributesNS->Put(&key, xblAttr);
    1:         } else {
    1:           while (entry->GetNext())
    1:             entry = entry->GetNext();
    1: 
    1:           entry->SetNext(xblAttr);
    1:         }
    1: 
    1:         // Now remove the inherits attribute from the element so that it doesn't
    1:         // show up on clones of the element.  It is used
    1:         // by the template only, and we don't need it anymore.
    1:         // XXXdwh Don't do this for XUL elements, since it faults them into heavyweight
    1:         // elements. Should nuke from the prototype instead.
    1:         // aElement->UnsetAttr(kNameSpaceID_XBL, nsGkAtoms::inherits, PR_FALSE);
    1: 
    1:         token = nsCRT::strtok( newStr, ", ", &newStr );
    1:       }
    1: 
    1:       nsMemory::Free(str);
    1:     }
    1:   }
    1: 
    1:   // Recur into our children.
    1:   PRUint32 childCount = aElement->GetChildCount();
    1:   for (PRUint32 i = 0; i < childCount; i++) {
    1:     ConstructAttributeTable(aElement->GetChildAt(i));
    1:   }
    1: }
    1: 
20261: static PRBool
    1: DeleteInsertionPointEntry(nsHashKey* aKey, void* aData, void* aClosure)
    1: {
 3233:   static_cast<nsXBLInsertionPointEntry*>(aData)->Release();
    1:   return PR_TRUE;
    1: }
    1: 
    1: void 
    1: nsXBLPrototypeBinding::ConstructInsertionTable(nsIContent* aContent)
    1: {
    1:   nsCOMArray<nsIContent> childrenElements;
    1:   GetNestedChildren(nsGkAtoms::children, kNameSpaceID_XBL, aContent,
    1:                     childrenElements);
    1: 
    1:   PRInt32 count = childrenElements.Count();
    1:   if (count == 0)
    1:     return;
    1: 
    1:   mInsertionPointTable = new nsObjectHashtable(nsnull, nsnull,
    1:                                                DeleteInsertionPointEntry,
    1:                                                nsnull, 4);
    1:   if (!mInsertionPointTable)
    1:     return;
    1: 
    1:   PRInt32 i;
    1:   for (i = 0; i < count; i++) {
    1:     nsIContent* child = childrenElements[i];
    1:     nsIContent* parent = child->GetParent(); 
    1: 
    1:     // Create an XBL insertion point entry.
    1:     nsXBLInsertionPointEntry* xblIns = nsXBLInsertionPointEntry::Create(parent);
    1: 
    1:     nsAutoString includes;
    1:     child->GetAttr(kNameSpaceID_None, nsGkAtoms::includes, includes);
    1:     if (includes.IsEmpty()) {
    1:       nsISupportsKey key(nsGkAtoms::children);
    1:       xblIns->AddRef();
    1:       mInsertionPointTable->Put(&key, xblIns);
    1:     }
    1:     else {
    1:       // The user specified at least one attribute.
    1:       char* str = ToNewCString(includes);
    1:       char* newStr;
    1:       // XXX We should use a strtok function that tokenizes PRUnichar's
    1:       // so that we don't have to convert from Unicode to ASCII and then back
    1: 
    1:       char* token = nsCRT::strtok( str, "| ", &newStr );
    1:       while( token != NULL ) {
    1:         nsAutoString tok;
    1:         tok.AssignWithConversion(token);
    1: 
    1:         // Build an atom out of this string.
    1:         nsCOMPtr<nsIAtom> atom = do_GetAtom(tok);
    1:            
    1:         nsISupportsKey key(atom);
    1:         xblIns->AddRef();
    1:         mInsertionPointTable->Put(&key, xblIns);
    1:           
    1:         token = nsCRT::strtok( newStr, "| ", &newStr );
    1:       }
    1: 
    1:       nsMemory::Free(str);
    1:     }
    1: 
    1:     // Compute the index of the <children> element.  This index is
    1:     // equal to the index of the <children> in the template minus the #
    1:     // of previous insertion point siblings removed.  Because our childrenElements
    1:     // array was built in a DFS that went from left-to-right through siblings,
    1:     // if we dynamically obtain our index each time, then the removals of previous
    1:     // siblings will cause the index to adjust (and we won't have to take that into
    1:     // account explicitly).
    1:     PRInt32 index = parent->IndexOf(child);
    1:     xblIns->SetInsertionIndex((PRUint32)index);
    1: 
    1:     // Now remove the <children> element from the template.  This ensures that the
    1:     // binding instantiation will not contain a clone of the <children> element when
    1:     // it clones the binding template.
    1:     parent->RemoveChildAt(index, PR_FALSE);
    1: 
    1:     // See if the insertion point contains default content.  Default content must
    1:     // be cached in our insertion point entry, since it will need to be cloned
    1:     // in situations where no content ends up being placed at the insertion point.
    1:     PRUint32 defaultCount = child->GetChildCount();
    1:     if (defaultCount > 0) {
14228:       nsAutoScriptBlocker scriptBlocker;
    1:       // Annotate the insertion point with our default content.
    1:       xblIns->SetDefaultContent(child);
    1: 
    1:       // Reconnect back to our parent for access later.  This makes "inherits" easier
    1:       // to work with on default content.
    1:       // XXXbz this is somewhat screwed up, since it's sort of like anonymous
    1:       // content... but not.
    1:       nsresult rv =
    1:         child->BindToTree(parent->GetCurrentDoc(), parent, nsnull, PR_FALSE);
    1:       if (NS_FAILED(rv)) {
    1:         // Well... now what?  Just unbind and bail out, I guess...
    1:         // XXXbz This really shouldn't be a void method!
    1:         child->UnbindFromTree();
    1:         return;
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::ConstructInterfaceTable(const nsAString& aImpls)
    1: {
    1:   if (!aImpls.IsEmpty()) {
    1:     // Obtain the interface info manager that can tell us the IID
    1:     // for a given interface name.
    1:     nsCOMPtr<nsIInterfaceInfoManager>
    1:       infoManager(do_GetService(NS_INTERFACEINFOMANAGER_SERVICE_CONTRACTID));
    1:     if (!infoManager)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     // Create the table.
    1:     if (!mInterfaceTable)
    1:       mInterfaceTable = new nsSupportsHashtable(4);
    1: 
    1:     // The user specified at least one attribute.
    1:     NS_ConvertUTF16toUTF8 utf8impl(aImpls);
    1:     char* str = utf8impl.BeginWriting();
    1:     char* newStr;
    1:     // XXX We should use a strtok function that tokenizes PRUnichars
    1:     // so that we don't have to convert from Unicode to ASCII and then back
    1: 
    1:     char* token = nsCRT::strtok( str, ", ", &newStr );
    1:     while( token != NULL ) {
    1:       // get the InterfaceInfo for the name
    1:       nsCOMPtr<nsIInterfaceInfo> iinfo;
    1:       infoManager->GetInfoForName(token, getter_AddRefs(iinfo));
    1: 
    1:       if (iinfo) {
    1:         // obtain an IID.
10204:         const nsIID* iid = nsnull;
10204:         iinfo->GetIIDShared(&iid);
    1: 
    1:         if (iid) {
    1:           // We found a valid iid.  Add it to our table.
    1:           nsIIDKey key(*iid);
    1:           mInterfaceTable->Put(&key, mBinding);
    1: 
    1:           // this block adds the parent interfaces of each interface
    1:           // defined in the xbl definition (implements="nsI...")
    1:           nsCOMPtr<nsIInterfaceInfo> parentInfo;
    1:           // if it has a parent, add it to the table
    1:           while (NS_SUCCEEDED(iinfo->GetParent(getter_AddRefs(parentInfo))) && parentInfo) {
    1:             // get the iid
10204:             parentInfo->GetIIDShared(&iid);
    1: 
    1:             // don't add nsISupports to the table
    1:             if (!iid || iid->Equals(NS_GET_IID(nsISupports)))
    1:               break;
    1: 
    1:             // add the iid to the table
    1:             nsIIDKey parentKey(*iid);
    1:             mInterfaceTable->Put(&parentKey, mBinding);
    1: 
    1:             // look for the next parent
    1:             iinfo = parentInfo;
    1:           }
    1:         }
    1:       }
    1: 
    1:       token = nsCRT::strtok( newStr, ", ", &newStr );
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsXBLPrototypeBinding::GetNestedChildren(nsIAtom* aTag, PRInt32 aNamespace,
    1:                                          nsIContent* aContent,
    1:                                          nsCOMArray<nsIContent> & aList)
    1: {
    1:   PRUint32 childCount = aContent->GetChildCount();
    1: 
    1:   for (PRUint32 i = 0; i < childCount; i++) {
    1:     nsIContent *child = aContent->GetChildAt(i);
    1: 
    1:     if (child->NodeInfo()->Equals(aTag, aNamespace)) {
    1:       aList.AppendObject(child);
    1:     }
    1:     else
    1:       GetNestedChildren(aTag, aNamespace, child, aList);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsXBLPrototypeBinding::AddResourceListener(nsIContent* aBoundElement)
    1: {
    1:   if (!mResources)
    1:     return NS_ERROR_FAILURE; // Makes no sense to add a listener when the binding
    1:                              // has no resources.
    1: 
    1:   mResources->AddResourceListener(aBoundElement);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsXBLPrototypeBinding::CreateKeyHandlers()
    1: {
    1:   nsXBLPrototypeHandler* curr = mPrototypeHandler;
    1:   while (curr) {
    1:     nsCOMPtr<nsIAtom> eventAtom = curr->GetEventName();
    1:     if (eventAtom == nsGkAtoms::keyup ||
    1:         eventAtom == nsGkAtoms::keydown ||
    1:         eventAtom == nsGkAtoms::keypress) {
    1:       PRUint8 phase = curr->GetPhase();
    1:       PRUint8 type = curr->GetType();
    1: 
    1:       PRInt32 count = mKeyHandlers.Count();
    1:       PRInt32 i;
    1:       nsXBLKeyEventHandler* handler = nsnull;
    1:       for (i = 0; i < count; ++i) {
    1:         handler = mKeyHandlers[i];
    1:         if (handler->Matches(eventAtom, phase, type))
    1:           break;
    1:       }
    1: 
    1:       if (i == count) {
    1:         nsRefPtr<nsXBLKeyEventHandler> newHandler;
    1:         NS_NewXBLKeyEventHandler(eventAtom, phase, type,
    1:                                  getter_AddRefs(newHandler));
    1:         if (newHandler)
    1:           mKeyHandlers.AppendObject(newHandler);
    1:         handler = newHandler;
    1:       }
    1: 
    1:       if (handler)
    1:         handler->AddProtoHandler(curr);
    1:     }
    1: 
    1:     curr = curr->GetNextHandler();
    1:   }
    1: }
