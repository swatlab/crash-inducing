    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Scott MacGregor <mscott@netscape.com>
    1:  *   Christian Biesinger <cbiesinger@web.de>
 1859:  *   Dan Mosedale <dmose@mozilla.org>
 4568:  *   Myk Melez <myk@mozilla.org>
21635:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsExternalHelperAppService_h__
    1: #define nsExternalHelperAppService_h__
    1: 
    1: #ifdef MOZ_LOGGING
    1: #define FORCE_PR_LOG
    1: #endif
    1: #include "prlog.h"
    1: #include "prtime.h"
    1: 
51739: #include "nsInt64.h"
51739: 
    1: #include "nsIExternalHelperAppService.h"
    1: #include "nsIExternalProtocolService.h"
    1: #include "nsIWebProgressListener2.h"
    1: #include "nsIHelperAppLauncherDialog.h"
    1: 
    1: #include "nsIMIMEInfo.h"
    1: #include "nsIMIMEService.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsIFile.h"
    1: #include "nsIFileStreams.h"
    1: #include "nsIOutputStream.h"
    1: #include "nsString.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsILocalFile.h"
    1: #include "nsIChannel.h"
    1: #include "nsITimer.h"
    1: 
 5657: #include "nsIHandlerService.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIObserver.h"
    1: #include "nsCOMArray.h"
    1: #include "nsWeakReference.h"
    1: #include "nsIPrompt.h"
    1: 
    1: class nsExternalAppHandler;
    1: class nsIMIMEInfo;
    1: class nsITransfer;
    1: class nsIDOMWindowInternal;
    1: 
    1: /**
    1:  * The helper app service. Responsible for handling content that Mozilla
    1:  * itself can not handle
    1:  */
    1: class nsExternalHelperAppService
    1: : public nsIExternalHelperAppService,
    1:   public nsPIExternalAppLauncher,
    1:   public nsIExternalProtocolService,
    1:   public nsIMIMEService,
    1:   public nsIObserver,
    1:   public nsSupportsWeakReference
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIEXTERNALHELPERAPPSERVICE
    1:   NS_DECL_NSPIEXTERNALAPPLAUNCHER
    1:   NS_DECL_NSIEXTERNALPROTOCOLSERVICE
    1:   NS_DECL_NSIMIMESERVICE
    1:   NS_DECL_NSIOBSERVER
    1: 
    1:   nsExternalHelperAppService();
    1:   virtual ~nsExternalHelperAppService();
    1: 
    1:   /**
    1:    * Initializes internal state. Will be called automatically when
    1:    * this service is first instantiated.
    1:    */
    1:   NS_HIDDEN_(nsresult) Init();
    1:  
    1:   /**
    1:    * Given a mimetype and an extension, looks up a mime info from the OS.
    1:    * The mime type is given preference. This function follows the same rules
    1:    * as nsIMIMEService::GetFromTypeAndExtension.
    1:    * This is supposed to be overridden by the platform-specific
    1:    * nsOSHelperAppService!
    1:    * @param aFileExt The file extension; may be empty. UTF-8 encoded.
    1:    * @param [out] aFound
    1:    *        Should be set to PR_TRUE if the os has a mapping, to
    1:    *        PR_FALSE otherwise. Must not be null.
    1:    * @return A MIMEInfo. This function must return a MIMEInfo object if it
    1:    *         can allocate one.  The only justifiable reason for not
    1:    *         returning one is an out-of-memory error.
    1:    *         If null, the value of aFound is unspecified.
    1:    */
    1:   virtual already_AddRefed<nsIMIMEInfo> GetMIMEInfoFromOS(const nsACString& aMIMEType,
    1:                                                           const nsACString& aFileExt,
    1:                                                           PRBool     * aFound) = 0;
    1: 
    1:   /**
    1:    * Given a string identifying an application, create an nsIFile representing
    1:    * it. This function should look in $PATH for the application.
    1:    * The base class implementation will first try to interpret platformAppPath
    1:    * as an absolute path, and if that fails it will look for a file next to the
    1:    * mozilla executable. Subclasses can override this method if they want a
    1:    * different behaviour.
    1:    * @param platformAppPath A platform specific path to an application that we
    1:    *                        got out of the rdf data source. This can be a mac
    1:    *                        file spec, a unix path or a windows path depending
    1:    *                        on the platform
    1:    * @param aFile           [out] An nsIFile representation of that platform
    1:    *                        application path.
    1:    */
    1:   virtual nsresult GetFileTokenForPath(const PRUnichar * platformAppPath,
    1:                                        nsIFile ** aFile);
    1: 
 1859:   virtual NS_HIDDEN_(nsresult) OSProtocolHandlerExists(const char *aScheme,
 1859:                                                        PRBool *aExists) = 0;
 1859: 
22086:   /**
22086:    * Simple accessor to let nsExternalAppHandler know if we are currently
22086:    * inside the private browsing mode.
22086:    */
22086:   PRBool InPrivateBrowsing() const { return mInPrivateBrowsing; }
22086: 
    1: protected:
    1:   /**
    1:    * Searches the "extra" array of MIMEInfo objects for an object
    1:    * with a specific type. If found, it will modify the passed-in
    1:    * MIMEInfo. Otherwise, it will return an error and the MIMEInfo
    1:    * will be untouched.
    1:    * @param aContentType The type to search for.
    1:    * @param aMIMEInfo    [inout] The mime info, if found
    1:    */
 3161:   NS_HIDDEN_(nsresult) FillMIMEInfoForMimeTypeFromExtras(
 3161:     const nsACString& aContentType, nsIMIMEInfo * aMIMEInfo);
    1:   /**
    1:    * Searches the "extra" array of MIMEInfo objects for an object
    1:    * with a specific extension.
    1:    *
    1:    * Does not change the MIME Type of the MIME Info.
    1:    *
 3161:    * @see FillMIMEInfoForMimeTypeFromExtras
    1:    */
 3161:   NS_HIDDEN_(nsresult) FillMIMEInfoForExtensionFromExtras(
 3161:     const nsACString& aExtension, nsIMIMEInfo * aMIMEInfo);
    1: 
    1:   /**
    1:    * Searches the "extra" array for a MIME type, and gets its extension.
    1:    * @param aExtension The extension to search for
    1:    * @param aMIMEType [out] The found MIME type.
    1:    * @return PR_TRUE if the extension was found, PR_FALSE otherwise.
    1:    */
    1:   NS_HIDDEN_(PRBool) GetTypeFromExtras(const nsACString& aExtension,
    1:                                        nsACString& aMIMEType);
    1: 
    1:   /**
    1:    * Fixes the file permissions to be correct. Base class has a no-op
    1:    * implementation, subclasses can use this to correctly inherit ACLs from the
    1:    * parent directory, to make the permissions obey the umask, etc.
    1:    */
    1:   virtual void FixFilePermissions(nsILocalFile* aFile);
    1: 
    1: #ifdef PR_LOGGING
    1:   /**
    1:    * NSPR Logging Module. Usage: set NSPR_LOG_MODULES=HelperAppService:level,
    1:    * where level should be 2 for errors, 3 for debug messages from the cross-
    1:    * platform nsExternalHelperAppService, and 4 for os-specific debug messages.
    1:    */
    1:   static PRLogModuleInfo* mLog;
    1: 
    1: #endif
    1:   // friend, so that it can access the nspr log module and FixFilePermissions
    1:   friend class nsExternalAppHandler;
    1:   friend class nsExternalLoadRequest;
    1: 
    1:   /**
21635:    * Helper function for ExpungeTemporaryFiles and ExpungeTemporaryPrivateFiles
21635:    */
21635:   static void ExpungeTemporaryFilesHelper(nsCOMArray<nsILocalFile> &fileList);
21635:   /**
    1:    * Functions related to the tempory file cleanup service provided by
    1:    * nsExternalHelperAppService
    1:    */
21635:   void ExpungeTemporaryFiles();
21635:   /**
21635:    * Functions related to the tempory file cleanup service provided by
21635:    * nsExternalHelperAppService (for the temporary files added during
21635:    * the private browsing mode)
21635:    */
21635:   void ExpungeTemporaryPrivateFiles();
    1:   /**
    1:    * Array for the files that should be deleted
    1:    */
    1:   nsCOMArray<nsILocalFile> mTemporaryFilesList;
21635:   /**
21635:    * Array for the files that should be deleted (for the temporary files
21635:    * added during the private browsing mode)
21635:    */
21635:   nsCOMArray<nsILocalFile> mTemporaryPrivateFilesList;
21635:   /**
21635:    * Whether we are in private browsing mode
21635:    */
21635:   PRBool mInPrivateBrowsing;
    1: };
    1: 
    1: /**
    1:  * An external app handler is just a small little class that presents itself as
    1:  * a nsIStreamListener. It saves the incoming data into a temp file. The handler
    1:  * is bound to an application when it is created. When it receives an
    1:  * OnStopRequest it launches the application using the temp file it has
    1:  * stored the data into.  We create a handler every time we have to process
    1:  * data using a helper app.
    1:  */
    1: class nsExternalAppHandler : public nsIStreamListener,
    1:                              public nsIHelperAppLauncher,
    1:                              public nsITimerCallback
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSISTREAMLISTENER
    1:   NS_DECL_NSIREQUESTOBSERVER
    1:   NS_DECL_NSIHELPERAPPLAUNCHER
    1:   NS_DECL_NSICANCELABLE
    1:   NS_DECL_NSITIMERCALLBACK
    1: 
    1:   /**
    1:    * @param aMIMEInfo      MIMEInfo object, representing the type of the
    1:    *                       content that should be handled
    1:    * @param aFileExtension The extension we need to append to our temp file,
    1:    *                       INCLUDING the ".". e.g. .mp3
    1:    * @param aWindowContext Window context, as passed to DoContent
    1:    * @param aFileName      The filename to use
    1:    * @param aReason        A constant from nsIHelperAppLauncherDialog indicating
    1:    *                       why the request is handled by a helper app.
    1:    */
    1:   nsExternalAppHandler(nsIMIMEInfo * aMIMEInfo, const nsCSubstring& aFileExtension,
    1:                        nsIInterfaceRequestor * aWindowContext,
    1:                        const nsAString& aFilename,
13848:                        PRUint32 aReason, PRBool aForceSave);
    1: 
    1:   ~nsExternalAppHandler();
    1: 
    1: protected:
    1:   nsCOMPtr<nsIFile> mTempFile;
    1:   nsCOMPtr<nsIURI> mSourceUrl;
    1:   nsString mTempFileExtension;
    1:   /**
    1:    * The MIME Info for this load. Will never be null.
    1:    */
    1:   nsCOMPtr<nsIMIMEInfo> mMimeInfo;
    1:   nsCOMPtr<nsIOutputStream> mOutStream; /**< output stream to the temp file */
    1:   nsCOMPtr<nsIInterfaceRequestor> mWindowContext;
    1: 
    1:   /**
    1:    * Used to close the window on a timer, to avoid any exceptions that are
    1:    * thrown if we try to close the window before it's fully loaded.
    1:    */
    1:   nsCOMPtr<nsIDOMWindowInternal> mWindowToClose;
    1:   nsCOMPtr<nsITimer> mTimer;
    1: 
    1:   /**
    1:    * The following field is set if we were processing an http channel that had
    1:    * a content disposition header which specified the SUGGESTED file name we
    1:    * should present to the user in the save to disk dialog. 
    1:    */
    1:   nsString mSuggestedFileName;
    1: 
    1:   /**
13848:    * If set, this handler should forcibly save the file to disk regardless of
13848:    * MIME info settings or anything else, without ever popping up the 
13848:    * unknown content type handling dialog.
13848:    */
13848:   PRPackedBool mForceSave;
13848:   
13848:   /**
    1:    * The canceled flag is set if the user canceled the launching of this
    1:    * application before we finished saving the data to a temp file.
    1:    */
    1:   PRPackedBool mCanceled;
    1: 
    1:   /**
    1:    * This is set based on whether the channel indicates that a new window
    1:    * was opened specifically for this download.  If so, then we
    1:    * close it.
    1:    */
    1:   PRPackedBool mShouldCloseWindow;
    1: 
    1:   /**
    1:    * have we received information from the user about how they want to
    1:    * dispose of this content
    1:    */
    1:   PRPackedBool mReceivedDispositionInfo;
    1:   PRPackedBool mStopRequestIssued; 
    1:   PRPackedBool mProgressListenerInitialized;
    1: 
    1:   PRPackedBool mIsFileChannel;
    1: 
    1:   /**
    1:    * One of the REASON_ constants from nsIHelperAppLauncherDialog. Indicates the
    1:    * reason the dialog was shown (unknown content type, server requested it,
    1:    * etc).
    1:    */
    1:   PRUint32 mReason;
    1: 
 7284:   /**
 7284:    * Track the executable-ness of the temporary file.
 7284:    */
 7284:   PRBool mTempFileIsExecutable;
 7284: 
    1:   PRTime mTimeDownloadStarted;
51739:   nsInt64 mContentLength;
51739:   nsInt64 mProgress; /**< Number of bytes received (for sending progress notifications). */
    1: 
    1:   /**
    1:    * When we are told to save the temp file to disk (in a more permament
    1:    * location) before we are done writing the content to a temp file, then
    1:    * we need to remember the final destination until we are ready to use it.
    1:    */
    1:   nsCOMPtr<nsIFile> mFinalFileDestination;
    1: 
41031:   PRUint32 mBufferSize;
41031:   char    *mDataBuffer;
    1: 
    1:   /**
    1:    * Creates the temporary file for the download and an output stream for it.
    1:    * Upon successful return, both mTempFile and mOutStream will be valid.
    1:    */
51739:   nsresult SetUpTempFile(nsIChannel * aChannel);
    1:   /**
    1:    * When we download a helper app, we are going to retarget all load
    1:    * notifications into our own docloader and load group instead of
    1:    * using the window which initiated the load....RetargetLoadNotifications
    1:    * contains that information...
    1:    */
    1:   void RetargetLoadNotifications(nsIRequest *request); 
    1:   /**
    1:    * If the user tells us how they want to dispose of the content and
    1:    * we still haven't finished downloading while they were deciding,
    1:    * then create a progress listener of some kind so they know
    1:    * what's going on...
    1:    */
    1:   nsresult CreateProgressListener();
    1:   nsresult PromptForSaveToFile(nsILocalFile ** aNewFile,
    1:                                const nsAFlatString &aDefaultFile,
    1:                                const nsAFlatString &aDefaultFileExt);
    1: 
    1:   /**
    1:    * After we're done prompting the user for any information, if the original
    1:    * channel had a refresh url associated with it (which might point to a
    1:    * "thank you for downloading" kind of page, then process that....It is safe
    1:    * to invoke this method multiple times. We'll clear mOriginalChannel after
    1:    * it's called and this ensures we won't call it again....
    1:    */
    1:   void ProcessAnyRefreshTags();
    1: 
    1:   /** 
    1:    * An internal method used to actually move the temp file to the final
    1:    * destination once we done receiving data AND have showed the progress dialog
    1:    */
    1:   nsresult MoveFile(nsIFile * aNewFileLocation);
    1:   /**
    1:    * An internal method used to actually launch a helper app given the temp file
    1:    * once we are done receiving data AND have showed the progress dialog.
    1:    * Uses the application specified in the mime info.
    1:    */
    1:   nsresult OpenWithApplication();
    1:   
    1:   /**
    1:    * Helper routine which peaks at the mime action specified by mMimeInfo
    1:    * and calls either MoveFile or OpenWithApplication
    1:    */
    1:   nsresult ExecuteDesiredAction();
    1:   /**
    1:    * Helper routine that searches a pref string for a given mime type
    1:    */
    1:   PRBool GetNeverAskFlagFromPref(const char * prefName, const char * aContentType);
    1: 
    1:   /**
    1:    * Initialize an nsITransfer object for use as a progress object
    1:    */
    1:   nsresult InitializeDownload(nsITransfer*);
    1:   
    1:   /**
    1:    * Helper routine to ensure mSuggestedFileName is "correct";
    1:    * this ensures that mTempFileExtension only contains an extension when it
    1:    * is different from mSuggestedFileName's extension.
    1:    */
    1:   void EnsureSuggestedFileName();
    1: 
    1:   typedef enum { kReadError, kWriteError, kLaunchError } ErrorType;
    1:   /**
    1:    * Utility function to send proper error notification to web progress listener
    1:    */
    1:   void SendStatusChange(ErrorType type, nsresult aStatus, nsIRequest *aRequest, const nsAFlatString &path);
    1: 
    1:   /**
    1:    * Closes the window context if it does not have a refresh header
    1:    * and it never displayed content before the external helper app
    1:    * service was invoked.
    1:    */
    1:   nsresult MaybeCloseWindow();
    1: 
    1:   nsCOMPtr<nsIWebProgressListener2> mWebProgressListener;
    1:   nsCOMPtr<nsIChannel> mOriginalChannel; /**< in the case of a redirect, this will be the pre-redirect channel. */
    1:   nsCOMPtr<nsIHelperAppLauncherDialog> mDialog;
    1: 
    1:   /**
63539:    * Keep request alive in case when helper non-modal dialog shown.
63539:    * Thus in OnStopRequest the mRequest will not be set to null (it will be set to null further).
63539:    */
63539:   PRBool mKeepRequestAlive;
63539: 
63539:   /**
63818:    * The request that's being loaded. Initialized in OnStartRequest.
63818:    * Nulled out in OnStopRequest or once we know what we're doing
63818:    * with the data, whichever happens later.
    1:    */
63818:   nsCOMPtr<nsIRequest> mRequest;
    1: };
    1: 
 1859: extern NS_HIDDEN_(nsExternalHelperAppService*) gExtProtSvc;
 1859: 
    1: #endif // nsExternalHelperAppService_h__
