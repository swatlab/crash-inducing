    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Brian Ryner <bryner@brianryner.com>
    1:  *  Benjamin Smedberg <bsmedberg@covad.net>
    1:  *  Ben Goodger <ben@mozilla.org>
    1:  *  Jens Bannmann <jens.b@web.de>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAppRunner.h"
    1: #include "nsXREDirProvider.h"
    1: 
    1: #include "jsapi.h"
    1: 
    1: #include "nsIJSContextStack.h"
 5629: #include "nsIDirectoryEnumerator.h"
    1: #include "nsILocalFile.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIProfileChangeStatus.h"
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsIToolkitChromeRegistry.h"
    1: 
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsDirectoryServiceUtils.h"
    1: #include "nsXULAppAPI.h"
18528: #include "nsCategoryManagerUtils.h"
    1: 
    1: #include "nsINIParser.h"
    1: #include "nsDependentString.h"
    1: #include "nsCOMArray.h"
    1: #include "nsArrayEnumerator.h"
    1: #include "nsEnumeratorUtils.h"
 6338: #include "nsReadableUtils.h"
    1: 
    1: #include <stdlib.h>
    1: 
    1: #ifdef XP_WIN
    1: #include <windows.h>
    1: #include <shlobj.h>
    1: // This is not defined by VC6.
    1: #ifndef CSIDL_LOCAL_APPDATA
    1: #define CSIDL_LOCAL_APPDATA             0x001C
    1: #endif
    1: #endif
    1: #ifdef XP_MACOSX
    1: #include "nsILocalFileMac.h"
    1: #endif
    1: #ifdef XP_BEOS
    1: #include <be/kernel/image.h>
    1: #include <FindDirectory.h>
    1: #endif
    1: #ifdef XP_UNIX
    1: #include <ctype.h>
    1: #endif
    1: #ifdef XP_OS2
    1: #define INCL_DOS
    1: #include <os2.h>
    1: #endif
    1: 
    1: #if defined(XP_MACOSX)
    1: #define APP_REGISTRY_NAME "Application Registry"
    1: #elif defined(XP_WIN) || defined(XP_OS2)
    1: #define APP_REGISTRY_NAME "registry.dat"
    1: #else
    1: #define APP_REGISTRY_NAME "appreg"
    1: #endif
    1: 
 1022: #define PREF_OVERRIDE_DIRNAME "preferences"
 1022: 
    1: nsXREDirProvider* gDirServiceProvider = nsnull;
    1: 
    1: nsXREDirProvider::nsXREDirProvider() :
 5629:   mProfileNotified(PR_FALSE),
 5629:   mExtensionsLoaded(PR_FALSE)
    1: {
    1:   gDirServiceProvider = this;
    1: }
    1: 
    1: nsXREDirProvider::~nsXREDirProvider()
    1: {
    1:   gDirServiceProvider = nsnull;
    1: }
    1: 
    1: nsresult
    1: nsXREDirProvider::Initialize(nsIFile *aXULAppDir,
    1:                              nsILocalFile *aGREDir,
    1:                              nsIDirectoryServiceProvider* aAppProvider)
    1: {
34542:   NS_ENSURE_ARG(aXULAppDir);
    1:   NS_ENSURE_ARG(aGREDir);
    1: 
    1:   mAppProvider = aAppProvider;
    1:   mXULAppDir = aXULAppDir;
    1:   mGREDir = aGREDir;
    1: 
16746:   if (!mProfileDir) {
16746:     nsCOMPtr<nsIDirectoryServiceProvider> app(do_QueryInterface(mAppProvider));
16746:     if (app) {
16746:       PRBool per = PR_FALSE;
16746:       app->GetFile(NS_APP_USER_PROFILE_50_DIR, &per, getter_AddRefs(mProfileDir));
27273:       NS_ASSERTION(per, "NS_APP_USER_PROFILE_50_DIR must be persistent!"); 
27273:       NS_ASSERTION(mProfileDir, "NS_APP_USER_PROFILE_50_DIR not defined! This shouldn't happen!"); 
16746:     }
16746:   }
16746: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXREDirProvider::SetProfile(nsIFile* aDir, nsIFile* aLocalDir)
    1: {
    1:   NS_ASSERTION(aDir && aLocalDir, "We don't support no-profile apps yet!");
    1: 
    1:   nsresult rv;
    1: 
    1:   rv = EnsureDirectoryExists(aDir);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = EnsureDirectoryExists(aLocalDir);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   mProfileDir = aDir;
    1:   mProfileLocalDir = aLocalDir;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMPL_QUERY_INTERFACE3(nsXREDirProvider,
    1:                          nsIDirectoryServiceProvider,
    1:                          nsIDirectoryServiceProvider2,
    1:                          nsIProfileStartup)
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsXREDirProvider::AddRef()
    1: {
    1:   return 1;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsrefcnt)
    1: nsXREDirProvider::Release()
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXREDirProvider::GetFile(const char* aProperty, PRBool* aPersistent,
    1: 			  nsIFile** aFile)
    1: {
    1:   nsresult rv;
    1: 
    1:   PRBool gettingProfile = PR_FALSE;
    1: 
    1:   if (!strcmp(aProperty, NS_APP_USER_PROFILE_LOCAL_50_DIR)) {
    1:     // If XRE_NotifyProfile hasn't been called, don't fall through to
    1:     // mAppProvider on the profile keys.
    1:     if (!mProfileNotified)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     if (mProfileLocalDir)
    1:       return mProfileLocalDir->Clone(aFile);
    1: 
    1:     if (mAppProvider)
    1:       return mAppProvider->GetFile(aProperty, aPersistent, aFile);
    1: 
    1:     // This falls through to the case below
    1:     gettingProfile = PR_TRUE;
    1:   }
    1:   if (!strcmp(aProperty, NS_APP_USER_PROFILE_50_DIR) || gettingProfile) {
    1:     if (!mProfileNotified)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     if (mProfileDir)
    1:       return mProfileDir->Clone(aFile);
    1: 
    1:     if (mAppProvider)
    1:       return mAppProvider->GetFile(aProperty, aPersistent, aFile);
    1: 
    1:     // If we don't succeed here, bail early so that we aren't reentrant
    1:     // through the "GetProfileDir" call below.
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (mAppProvider) {
    1:     rv = mAppProvider->GetFile(aProperty, aPersistent, aFile);
    1:     if (NS_SUCCEEDED(rv) && *aFile)
    1:       return rv;
    1:   }
    1: 
    1:   *aPersistent = PR_TRUE;
    1: 
    1:   if (!strcmp(aProperty, NS_GRE_DIR)) {
    1:     return mGREDir->Clone(aFile);
    1:   }
    1:   else if (!strcmp(aProperty, NS_OS_CURRENT_PROCESS_DIR) ||
    1:       !strcmp(aProperty, NS_APP_INSTALL_CLEANUP_DIR)) {
    1:     return GetAppDir()->Clone(aFile);
    1:   }
    1: 
    1:   rv = NS_ERROR_FAILURE;
    1:   nsCOMPtr<nsIFile> file;
    1: 
    1:   if (!strcmp(aProperty, NS_APP_PROFILE_DEFAULTS_50_DIR) ||
    1:            !strcmp(aProperty, NS_APP_PROFILE_DEFAULTS_NLOC_50_DIR)) {
    1:     return GetProfileDefaultsDir(aFile);
    1:   }
    1:   else if (!strcmp(aProperty, NS_APP_PREF_DEFAULTS_50_DIR))
    1:   {
    1:     // return the GRE default prefs directory here, and the app default prefs
    1:     // directory (if applicable) in NS_APP_PREFS_DEFAULTS_DIR_LIST.
    1:     rv = mGREDir->Clone(getter_AddRefs(file));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("defaults"));
    1:       if (NS_SUCCEEDED(rv))
    1:         rv = file->AppendNative(NS_LITERAL_CSTRING("pref"));
    1:     }
    1:   }
    1:   else if (!strcmp(aProperty, NS_APP_APPLICATION_REGISTRY_DIR) ||
    1:            !strcmp(aProperty, XRE_USER_APP_DATA_DIR)) {
    1:     rv = GetUserAppDataDirectory((nsILocalFile**)(nsIFile**) getter_AddRefs(file));
    1:   }
10123:   else if (!strcmp(aProperty, XRE_UPDATE_ROOT_DIR)) {
31329: #if defined(XP_WIN) && !defined(WINCE)
  676:     rv = GetUpdateRootDir(getter_AddRefs(file));
10123: #else
31329:     // Only supported on Windows other than WINCE, so just immediately fail.
10123:     return NS_ERROR_FAILURE;
10123: #endif
  676:   }
    1:   else if (!strcmp(aProperty, NS_APP_APPLICATION_REGISTRY_FILE)) {
    1:     rv = GetUserAppDataDirectory((nsILocalFile**)(nsIFile**) getter_AddRefs(file));
    1:     if (NS_SUCCEEDED(rv))
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING(APP_REGISTRY_NAME));
    1:   }
    1:   else if (!strcmp(aProperty, NS_APP_USER_PROFILES_ROOT_DIR)) {
    1:     rv = GetUserAppDataDirectory((nsILocalFile**)(nsIFile**) getter_AddRefs(file));
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1: #if !defined(XP_UNIX) || defined(XP_MACOSX)
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("Profiles"));
    1: #endif
    1: 
    1:       // We must create the profile directory here if it does not exist.
    1:       rv |= EnsureDirectoryExists(file);
    1:     }
    1:   }
    1:   else if (!strcmp(aProperty, NS_APP_USER_PROFILES_LOCAL_ROOT_DIR)) {
    1:     rv = GetUserLocalDataDirectory((nsILocalFile**)(nsIFile**) getter_AddRefs(file));
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1: #if !defined(XP_UNIX) || defined(XP_MACOSX)
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("Profiles"));
    1: #endif
    1: 
    1:       // We must create the profile directory here if it does not exist.
    1:       rv |= EnsureDirectoryExists(file);
    1:     }
    1:   }
    1:   else if (!strcmp(aProperty, XRE_EXECUTABLE_FILE) && gArgv[0]) {
    1:     nsCOMPtr<nsILocalFile> lf;
    1:     rv = XRE_GetBinaryPath(gArgv[0], getter_AddRefs(lf));
    1:     if (NS_SUCCEEDED(rv))
    1:       file = lf;
    1:   }
    1:   else if (!strcmp(aProperty, "resource:app")) {
    1:     rv = GetAppDir()->Clone(getter_AddRefs(file));
    1:   }
    1: 
    1:   else if (!strcmp(aProperty, NS_APP_PROFILE_DIR_STARTUP) && mProfileDir) {
    1:     return mProfileDir->Clone(aFile);
    1:   }
    1:   else if (!strcmp(aProperty, NS_APP_PROFILE_LOCAL_DIR_STARTUP)) {
    1:     if (mProfileLocalDir)
    1:       return mProfileLocalDir->Clone(aFile);
    1: 
    1:     if (mProfileDir)
    1:       return mProfileDir->Clone(aFile);
    1: 
    1:     if (mAppProvider)
    1:       return mAppProvider->GetFile(NS_APP_PROFILE_DIR_STARTUP, aPersistent,
    1:                                    aFile);
    1:   }
12702: #if defined(XP_UNIX) || defined(XP_MACOSX)
12702:   else if (!strcmp(aProperty, XRE_SYS_LOCAL_EXTENSION_PARENT_DIR)) {
12702:     return GetSystemExtensionsDirectory((nsILocalFile**)(nsIFile**) aFile);
12702:   }
12702: #endif
10285: #if defined(XP_UNIX) && !defined(XP_MACOSX)
10285:   else if (!strcmp(aProperty, XRE_SYS_SHARE_EXTENSION_PARENT_DIR)) {
10285:     static const char *const sysLExtDir = "/usr/share/mozilla/extensions";
10285:     return NS_NewNativeLocalFile(nsDependentCString(sysLExtDir),
10285:                                  PR_FALSE, (nsILocalFile**)(nsIFile**) aFile);
10285:   }
10285: #endif
10285:   else if (!strcmp(aProperty, XRE_USER_SYS_EXTENSION_DIR)) {
10285:     return GetSysUserExtensionsDirectory((nsILocalFile**)(nsIFile**) aFile);
10285:   }
    1:   else if (NS_SUCCEEDED(GetProfileStartupDir(getter_AddRefs(file)))) {
    1:     // We need to allow component, xpt, and chrome registration to
    1:     // occur prior to the profile-after-change notification.
    1:     if (!strcmp(aProperty, NS_XPCOM_COMPONENT_REGISTRY_FILE)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("compreg.dat"));
    1:     }
    1:     else if (!strcmp(aProperty, NS_XPCOM_XPTI_REGISTRY_FILE)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("xpti.dat"));
    1:     }
    1:     else if (!strcmp(aProperty, NS_APP_USER_CHROME_DIR)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("chrome"));
    1:     }
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv) && file) {
    1:     NS_ADDREF(*aFile = file);
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRBool ensureFilePermissions = PR_FALSE;
    1: 
    1:   if (NS_SUCCEEDED(GetProfileDir(getter_AddRefs(file)))) {
    1:     if (!strcmp(aProperty, NS_APP_PREFS_50_DIR)) {
    1:       rv = NS_OK;
    1:     }
    1:     else if (!strcmp(aProperty, NS_APP_PREFS_50_FILE)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("prefs.js"));
    1:     }
    1:     else if (!strcmp(aProperty, NS_LOCALSTORE_UNSAFE_FILE)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("localstore.rdf"));
    1:     }
    1:     else if (!strcmp(aProperty, NS_APP_LOCALSTORE_50_FILE)) {
    1:       if (gSafeMode) {
    1:         rv = file->AppendNative(NS_LITERAL_CSTRING("localstore-safe.rdf"));
    1:         file->Remove(PR_FALSE);
    1:       }
    1:       else {
    1:         rv = file->AppendNative(NS_LITERAL_CSTRING("localstore.rdf"));
    1:         EnsureProfileFileExists(file);
    1:         ensureFilePermissions = PR_TRUE;
    1:       }
    1:     }
    1:     else if (!strcmp(aProperty, NS_APP_HISTORY_50_FILE)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("history.dat"));
    1:     }
    1:     else if (!strcmp(aProperty, NS_APP_USER_MIMETYPES_50_FILE)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("mimeTypes.rdf"));
    1:       EnsureProfileFileExists(file);
    1:       ensureFilePermissions = PR_TRUE;
    1:     }
    1:     else if (!strcmp(aProperty, NS_APP_STORAGE_50_FILE)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("storage.sdb"));
    1:     }
    1:     else if (!strcmp(aProperty, NS_APP_DOWNLOADS_50_FILE)) {
    1:       rv = file->AppendNative(NS_LITERAL_CSTRING("downloads.rdf"));
    1:     }
 1022:     else if (!strcmp(aProperty, NS_APP_PREFS_OVERRIDE_DIR)) {
 1022:       rv = mProfileDir->Clone(getter_AddRefs(file));
 1022:       rv |= file->AppendNative(NS_LITERAL_CSTRING(PREF_OVERRIDE_DIRNAME));
 1022:       rv |= EnsureDirectoryExists(file);
 1022:     }
    1:   }
    1:   if (NS_FAILED(rv) || !file)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (ensureFilePermissions) {
    1:     PRBool fileToEnsureExists;
    1:     PRBool isWritable;
    1:     if (NS_SUCCEEDED(file->Exists(&fileToEnsureExists)) && fileToEnsureExists
    1:         && NS_SUCCEEDED(file->IsWritable(&isWritable)) && !isWritable) {
    1:       PRUint32 permissions;
    1:       if (NS_SUCCEEDED(file->GetPermissions(&permissions))) {
    1:         rv = file->SetPermissions(permissions | 0600);
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "failed to ensure file permissions");
    1:       }
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aFile = file);
    1:   return NS_OK;
    1: }
    1: 
    1: static void
 5629: LoadPlatformDirectory(nsIFile* aBundleDirectory,
 5629:                       nsCOMArray<nsIFile> &aDirectories)
 5629: {
 5629:   nsCOMPtr<nsIFile> platformDir;
 5629:   nsresult rv = aBundleDirectory->Clone(getter_AddRefs(platformDir));
 5629:   if (NS_FAILED(rv))
 5629:     return;
 5629: 
 5629:   platformDir->AppendNative(NS_LITERAL_CSTRING("platform"));
 5629: 
 5629: #ifdef TARGET_OS_ABI
 5629:   nsCOMPtr<nsIFile> platformABIDir;
 5629:   rv = platformDir->Clone(getter_AddRefs(platformABIDir));
 5629:   if (NS_FAILED(rv))
 5629:     return;
 5629: #endif
 5629: 
 5629:   platformDir->AppendNative(NS_LITERAL_CSTRING(OS_TARGET));
 5629: 
 5629:   PRBool exists;
 5629:   if (NS_SUCCEEDED(platformDir->Exists(&exists)) && exists)
 5629:     aDirectories.AppendObject(platformDir);
 5629: 
 5629: #ifdef TARGET_OS_ABI
 5629:   platformABIDir->AppendNative(NS_LITERAL_CSTRING(TARGET_OS_ABI));
 5629:   if (NS_SUCCEEDED(platformABIDir->Exists(&exists)) && exists)
 5629:     aDirectories.AppendObject(platformABIDir);
 5629: #endif
 5629: }
 5629: 
 5629: static void
 5632: LoadAppDirIntoArray(nsIFile* aXULAppDir,
 5632:                     const char *const *aAppendList,
 5632:                     nsCOMArray<nsIFile>& aDirectories)
 5632: {
 5632:   if (!aXULAppDir)
 5632:     return;
 5632: 
 5632:   nsCOMPtr<nsIFile> subdir;
 5632:   aXULAppDir->Clone(getter_AddRefs(subdir));
 5632:   if (!subdir)
 5632:     return;
 5632: 
 5632:   for (; *aAppendList; ++aAppendList)
 5632:     subdir->AppendNative(nsDependentCString(*aAppendList));
 5632: 
 5632:   PRBool exists;
 5632:   if (NS_SUCCEEDED(subdir->Exists(&exists)) && exists)
 5632:     aDirectories.AppendObject(subdir);
 5632: }
 5632: 
 5632: static void
 5629: LoadDirsIntoArray(nsCOMArray<nsIFile>& aSourceDirs,
 5524:                   const char *const* aAppendList,
 5515:                   nsCOMArray<nsIFile>& aDirectories)
 5515: {
 5629:   nsCOMPtr<nsIFile> appended;
 5629:   PRBool exists;
 5515: 
 5629:   for (PRInt32 i = 0; i < aSourceDirs.Count(); ++i) {
 5629:     aSourceDirs[i]->Clone(getter_AddRefs(appended));
 5629:     if (!appended)
 5524:       continue;
 5524: 
 5629:     for (const char *const *a = aAppendList; *a; ++a)
 5629:       appended->AppendNative(nsDependentCString(*a));
 5524: 
 5629:     if (NS_SUCCEEDED(appended->Exists(&exists)) && exists)
 5629:       aDirectories.AppendObject(appended);
 5524:   }
 4318: }
 4318: 
    1: static const char *const kAppendChromeManifests[] =
    1:   { "chrome.manifest", nsnull };
    1: 
    1: NS_IMETHODIMP
    1: nsXREDirProvider::GetFiles(const char* aProperty, nsISimpleEnumerator** aResult)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> appEnum;
    1:   nsCOMPtr<nsIDirectoryServiceProvider2>
    1:     appP2(do_QueryInterface(mAppProvider));
    1:   if (appP2) {
    1:     rv = appP2->GetFiles(aProperty, getter_AddRefs(appEnum));
    1:     if (NS_FAILED(rv)) {
    1:       appEnum = nsnull;
    1:     }
    1:     else if (rv != NS_SUCCESS_AGGREGATE_RESULT) {
    1:       NS_ADDREF(*aResult = appEnum);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> xreEnum;
    1:   rv = GetFilesInternal(aProperty, getter_AddRefs(xreEnum));
    1:   if (NS_FAILED(rv)) {
    1:     if (appEnum) {
    1:       NS_ADDREF(*aResult = appEnum);
    1:       return NS_SUCCESS_AGGREGATE_RESULT;
    1:     }
    1: 
    1:     return rv;
    1:   }
    1: 
    1:   rv = NS_NewUnionEnumerator(aResult, appEnum, xreEnum);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   return NS_SUCCESS_AGGREGATE_RESULT;
    1: }
    1: 
 5629: static void
 5629: LoadExtensionDirectories(nsINIParser &parser,
 5629:                          const char *aSection,
 5629:                          nsCOMArray<nsIFile> &aDirectories)
 5629: {
 5629:   nsresult rv;
 5629:   PRInt32 i = 0;
 5629:   do {
 5629:     nsCAutoString buf("Extension");
 5629:     buf.AppendInt(i++);
 5629: 
 5629:     nsCAutoString path;
 5629:     rv = parser.GetString(aSection, buf.get(), path);
 5629:     if (NS_FAILED(rv))
 5629:       return;
 5629: 
 5629:     nsCOMPtr<nsILocalFile> dir = do_CreateInstance("@mozilla.org/file/local;1", &rv);
 5629:     if (NS_FAILED(rv))
 5629:       continue;
 5629: 
 5629:     rv = dir->SetPersistentDescriptor(path);
 5629:     if (NS_FAILED(rv))
 5629:       continue;
 5629: 
 5629:     aDirectories.AppendObject(dir);
 5629:     LoadPlatformDirectory(dir, aDirectories);
 5629:   }
 5629:   while (PR_TRUE);
 5629: }
 5629: 
 5629: void
 5629: nsXREDirProvider::LoadBundleDirectories()
 5629: {
 5629:   if (mExtensionsLoaded)
 5629:     return;
 5629: 
 5629:   mExtensionsLoaded = PR_TRUE;
 5629: 
 5629:   // first load distribution/bundles
 5629:   LoadPlatformDirectory(mXULAppDir, mAppBundleDirectories);
 5629: 
 5629:   LoadAppBundleDirs();
 5629: 
 5629:   if (mProfileDir && !gSafeMode) {
 5629:     nsCOMPtr<nsIFile> extensionsINI;
 5629:     mProfileDir->Clone(getter_AddRefs(extensionsINI));
 5629:     if (!extensionsINI)
 5629:       return;
 5629: 
 5629:     extensionsINI->AppendNative(NS_LITERAL_CSTRING("extensions.ini"));
 5629: 
 5629:     nsCOMPtr<nsILocalFile> extensionsINILF =
 5629:       do_QueryInterface(extensionsINI);
 5629:     if (!extensionsINILF)
 5629:       return;
 5629: 
 5629:     nsINIParser parser;
 5629:     nsresult rv = parser.Init(extensionsINILF);
 5629:     if (NS_FAILED(rv))
 5629:       return;
 5629: 
 5629:     LoadExtensionDirectories(parser, "ExtensionDirs", mExtensionDirectories);
 5629:     LoadExtensionDirectories(parser, "ThemeDirs", mThemeDirectories);
 5629:   }
 5629: }
 5629: 
 5629: void
 5629: nsXREDirProvider::LoadAppBundleDirs()
 5629: {
 5629:   nsCOMPtr<nsIFile> dir;
 5629:   nsresult rv = mXULAppDir->Clone(getter_AddRefs(dir));
 5629:   if (NS_FAILED(rv))
 5629:     return;
 5629: 
 5629:   dir->AppendNative(NS_LITERAL_CSTRING("distribution"));
 5629:   dir->AppendNative(NS_LITERAL_CSTRING("bundles"));
 5629: 
 5629:   PRBool exists;
 5629:   if (NS_FAILED(dir->Exists(&exists)) || !exists)
 5629:     return;
 5629: 
 5629:   nsCOMPtr<nsISimpleEnumerator> e;
 5629:   rv = dir->GetDirectoryEntries(getter_AddRefs(e));
 5629:   if (NS_FAILED(rv))
 5629:     return;
 5629: 
 5629:   nsCOMPtr<nsIDirectoryEnumerator> files = do_QueryInterface(e);
 5629:   if (!files)
 5629:     return;
 5629: 
 5629:   nsCOMPtr<nsIFile> subdir;
 5629:   while (NS_SUCCEEDED(files->GetNextFile(getter_AddRefs(subdir))) && subdir) {
 5629:     mAppBundleDirectories.AppendObject(subdir);
 5629:     LoadPlatformDirectory(subdir, mAppBundleDirectories);
 5629:   }
 5629: }
 5629: 
 5629: static const char *const kAppendPrefDir[] = { "defaults", "preferences", nsnull };
 5629: 
 5632: #ifdef DEBUG_bsmedberg
 5632: static void
 5632: DumpFileArray(const char *key,
 5632:               nsCOMArray<nsIFile> dirs)
 5632: {
 5632:   fprintf(stderr, "nsXREDirProvider::GetFilesInternal(%s)\n", key);
 5632: 
 5632:   nsCAutoString path;
 5632:   for (PRInt32 i = 0; i < dirs.Count(); ++i) {
 5632:     dirs[i]->GetNativePath(path);
 5632:     fprintf(stderr, "  %s\n", path.get());
 5632:   }
 5632: }
 5632: #endif // DEBUG_bsmedberg
 5632: 
    1: nsresult
    1: nsXREDirProvider::GetFilesInternal(const char* aProperty,
    1:                                    nsISimpleEnumerator** aResult)
    1: {
    1:   nsresult rv = NS_OK;
    1:   *aResult = nsnull;
    1: 
    1:   if (!strcmp(aProperty, XRE_EXTENSIONS_DIR_LIST)) {
    1:     nsCOMArray<nsIFile> directories;
    1: 
    1:     static const char *const kAppendNothing[] = { nsnull };
    1: 
 5629:     LoadBundleDirectories();
 5629:     LoadDirsIntoArray(mAppBundleDirectories,
    1:                       kAppendNothing, directories);
 5629:     LoadDirsIntoArray(mExtensionDirectories,
 5629:                       kAppendNothing, directories);
    1: 
    1:     rv = NS_NewArrayEnumerator(aResult, directories);
    1:   }
    1:   else if (!strcmp(aProperty, NS_XPCOM_COMPONENT_DIR_LIST)) {
 4318:     static const char *const kAppendCompDir[] = { "components", nsnull };
    1:     nsCOMArray<nsIFile> directories;
    1: 
 5629:     LoadBundleDirectories();
 5629:     LoadDirsIntoArray(mAppBundleDirectories,
    1:                       kAppendCompDir, directories);
 5629:     LoadDirsIntoArray(mExtensionDirectories,
 5629:                       kAppendCompDir, directories);
    1: 
    1:     rv = NS_NewArrayEnumerator(aResult, directories);
    1:   }
    1:   else if (!strcmp(aProperty, NS_APP_PREFS_DEFAULTS_DIR_LIST)) {
    1:     nsCOMArray<nsIFile> directories;
    1: 
 5629:     LoadBundleDirectories();
 5632: 
 5632:     LoadAppDirIntoArray(mXULAppDir, kAppendPrefDir, directories);
 5629:     LoadDirsIntoArray(mAppBundleDirectories,
 5629:                       kAppendPrefDir, directories);
    1: 
 5534:     rv = NS_NewArrayEnumerator(aResult, directories);
 5534:   }
 5534:   else if (!strcmp(aProperty, NS_EXT_PREFS_DEFAULTS_DIR_LIST)) {
 5534:     nsCOMArray<nsIFile> directories;
 5629: 
 5629:     LoadBundleDirectories();
 5629:     LoadDirsIntoArray(mExtensionDirectories,
 5629:                       kAppendPrefDir, directories);
 5534: 
 1022:     if (mProfileDir) {
 1022:       nsCOMPtr<nsIFile> overrideFile;
 1022:       mProfileDir->Clone(getter_AddRefs(overrideFile));
 1022:       overrideFile->AppendNative(NS_LITERAL_CSTRING(PREF_OVERRIDE_DIRNAME));
 5629: 
 5629:       PRBool exists;
 1022:       if (NS_SUCCEEDED(overrideFile->Exists(&exists)) && exists)
 1022:         directories.AppendObject(overrideFile);
 1022:     }
    1: 
    1:     rv = NS_NewArrayEnumerator(aResult, directories);
    1:   }
    1:   else if (!strcmp(aProperty, NS_CHROME_MANIFESTS_FILE_LIST)) {
    1:     nsCOMArray<nsIFile> manifests;
    1: 
    1:     nsCOMPtr<nsIFile> manifest;
    1:     mGREDir->Clone(getter_AddRefs(manifest));
    1:     manifest->AppendNative(NS_LITERAL_CSTRING("chrome"));
    1:     manifests.AppendObject(manifest);
    1: 
33774:     PRBool eq;
33774:     if (NS_SUCCEEDED(mXULAppDir->Equals(mGREDir, &eq)) && !eq) {
    1:       nsCOMPtr<nsIFile> file;
    1:       mXULAppDir->Clone(getter_AddRefs(file));
    1:       file->AppendNative(NS_LITERAL_CSTRING("chrome"));
    1:       PRBool exists;
    1:       if (NS_SUCCEEDED(file->Exists(&exists)) && exists)
    1:         manifests.AppendObject(file);
    1:     }
    1: 
 5629:     LoadBundleDirectories();
 5629:     LoadDirsIntoArray(mAppBundleDirectories,
 5629:                       kAppendChromeManifests,
 5629:                       manifests);
 5629:     LoadDirsIntoArray(mExtensionDirectories,
 5629:                       kAppendChromeManifests,
 5629:                       manifests);
    1: 
    1:     rv = NS_NewArrayEnumerator(aResult, manifests);
    1:   }
    1:   else if (!strcmp(aProperty, NS_SKIN_MANIFESTS_FILE_LIST)) {
    1:     nsCOMArray<nsIFile> manifests;
 5629: 
 5629:     LoadBundleDirectories();
 5629:     LoadDirsIntoArray(mThemeDirectories,
    1:                       kAppendChromeManifests, manifests);
    1: 
    1:     rv = NS_NewArrayEnumerator(aResult, manifests);
    1:   }
    1:   else if (!strcmp(aProperty, NS_APP_CHROME_DIR_LIST)) {
    1:     // NS_APP_CHROME_DIR_LIST is only used to get default (native) icons
    1:     // for OS window decoration.
    1: 
 4318:     static const char *const kAppendChromeDir[] = { "chrome", nsnull };
    1:     nsCOMArray<nsIFile> directories;
 5629:     LoadBundleDirectories();
 5632:     LoadAppDirIntoArray(mXULAppDir,
 5632:                         kAppendChromeDir,
 5632:                         directories);
 5629:     LoadDirsIntoArray(mAppBundleDirectories,
 5629:                       kAppendChromeDir,
 5629:                       directories);
 5629:     LoadDirsIntoArray(mExtensionDirectories,
 5629:                       kAppendChromeDir,
 5629:                       directories);
    1: 
    1:     rv = NS_NewArrayEnumerator(aResult, directories);
    1:   }
    1:   else if (!strcmp(aProperty, NS_APP_PLUGINS_DIR_LIST)) {
 4318:     static const char *const kAppendPlugins[] = { "plugins", nsnull };
    1:     nsCOMArray<nsIFile> directories;
    1: 
    1:     // The root dirserviceprovider does quite a bit for us: we're mainly
    1:     // interested in xulapp and extension-provided plugins.
 5629:     LoadBundleDirectories();
 5629:     LoadDirsIntoArray(mAppBundleDirectories,
 5629:                       kAppendPlugins,
 5629:                       directories);
 5629:     LoadDirsIntoArray(mExtensionDirectories,
 5629:                       kAppendPlugins,
 5629:                       directories);
    1: 
24525:     if (mProfileDir) {
24525:       nsCOMArray<nsIFile> profileDir;
24525:       profileDir.AppendObject(mProfileDir);
24525:       LoadDirsIntoArray(profileDir,
24525:                         kAppendPlugins,
24525:                         directories);
24525:     }
24525: 
    1:     rv = NS_NewArrayEnumerator(aResult, directories);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = NS_SUCCESS_AGGREGATE_RESULT;
    1:   }
    1:   else
    1:     rv = NS_ERROR_FAILURE;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXREDirProvider::GetDirectory(nsIFile* *aResult)
    1: {
    1:   NS_ENSURE_TRUE(mProfileDir, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   return mProfileDir->Clone(aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXREDirProvider::DoStartup()
    1: {
    1:   if (!mProfileNotified) {
    1:     nsCOMPtr<nsIObserverService> obsSvc
    1:       (do_GetService("@mozilla.org/observer-service;1"));
    1:     if (!obsSvc) return NS_ERROR_FAILURE;
    1: 
    1:     mProfileNotified = PR_TRUE;
    1: 
    1:     static const PRUnichar kStartup[] = {'s','t','a','r','t','u','p','\0'};
    1:     obsSvc->NotifyObservers(nsnull, "profile-do-change", kStartup);
    1:     obsSvc->NotifyObservers(nsnull, "profile-after-change", kStartup);
18528: 
18528:     // Any component that has registered for the profile-after-change category
18528:     // should also be created at this time.
18528:     (void)NS_CreateServicesFromCategory("profile-after-change", nsnull,
18528:                                         "profile-after-change");
34473: 
34473:     obsSvc->NotifyObservers(nsnull, "profile-initial-state", nsnull);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: class ProfileChangeStatusImpl : public nsIProfileChangeStatus
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIPROFILECHANGESTATUS
    1:   ProfileChangeStatusImpl() { }
    1: private:
    1:   ~ProfileChangeStatusImpl() { }
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(ProfileChangeStatusImpl, nsIProfileChangeStatus)
    1: 
    1: NS_IMETHODIMP
    1: ProfileChangeStatusImpl::VetoChange()
    1: {
    1:   NS_ERROR("Can't veto change!");
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: ProfileChangeStatusImpl::ChangeFailed()
    1: {
    1:   NS_ERROR("Profile change cancellation.");
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: void
    1: nsXREDirProvider::DoShutdown()
    1: {
    1:   if (mProfileNotified) {
    1:     nsCOMPtr<nsIObserverService> obssvc
    1:       (do_GetService("@mozilla.org/observer-service;1"));
    1:     NS_ASSERTION(obssvc, "No observer service?");
    1:     if (obssvc) {
    1:       nsCOMPtr<nsIProfileChangeStatus> cs = new ProfileChangeStatusImpl();
    1:       static const PRUnichar kShutdownPersist[] =
    1:         {'s','h','u','t','d','o','w','n','-','p','e','r','s','i','s','t','\0'};
    1:       obssvc->NotifyObservers(cs, "profile-change-net-teardown", kShutdownPersist);
    1:       obssvc->NotifyObservers(cs, "profile-change-teardown", kShutdownPersist);
    1: 
    1:       // Phase 2c: Now that things are torn down, force JS GC so that things which depend on
    1:       // resources which are about to go away in "profile-before-change" are destroyed first.
    1:       nsCOMPtr<nsIThreadJSContextStack> stack
    1:         (do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
    1:       if (stack)
    1:       {
    1:         JSContext *cx = nsnull;
    1:         stack->GetSafeJSContext(&cx);
    1:         if (cx)
    1:           ::JS_GC(cx);
    1:       }
    1: 
    1:       // Phase 3: Notify observers of a profile change
    1:       obssvc->NotifyObservers(cs, "profile-before-change", kShutdownPersist);
    1:     }
    1:     mProfileNotified = PR_FALSE;
    1:   }
    1: }
    1: 
    1: #ifdef XP_WIN
    1: static nsresult
 6338: GetShellFolderPath(int folder, nsAString& _retval)
    1: {
30408:   PRUnichar* buf;
30408:   PRUint32 bufLength = _retval.GetMutableData(&buf, MAXPATHLEN + 3);
30408:   NS_ENSURE_TRUE(bufLength >= (MAXPATHLEN + 3), NS_ERROR_OUT_OF_MEMORY);
30408: 
30408:   nsresult rv = NS_OK;
30408: 
30408: #if defined(WINCE) && !defined(WINCE_WINDOWS_MOBILE)
30408:   if (folder == CSIDL_APPDATA || folder == CSIDL_LOCAL_APPDATA)
30408:     folder = CSIDL_PROFILE;
30408: 
30408:   BOOL ok = SHGetSpecialFolderPath(NULL, buf, folder, true);
30408:   if (!ok) {
30408:     _retval.SetLength(0);
30408:     return NS_ERROR_FAILURE;
30408:   }
30408: 
30408:   buf[bufLength - 1] = L'\0';
30408:   _retval.SetLength(wcslen(buf));
30408: 
30408:   // sometimes CSIDL_PROFILE shows up without a root slash
30408:   if (folder == CSIDL_PROFILE && buf[0] != '\\') {
30408:     _retval.Insert('\\', 0);
30408:   }
30408: #else
    1:   LPITEMIDLIST pItemIDList = NULL;
    1: 
    1:   if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, folder, &pItemIDList)) &&
 6338:       SHGetPathFromIDListW(pItemIDList, buf)) {
 6338:     // We're going to use wcslen (wcsnlen not available in msvc7.1) so make
 6338:     // sure to null terminate.
 6338:     buf[bufLength - 1] = L'\0';
 6338:     _retval.SetLength(wcslen(buf));
    1:   } else {
 6338:     _retval.SetLength(0);
    1:     rv = NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   CoTaskMemFree(pItemIDList);
30408: #endif
    1: 
    1:   return rv;
    1: }
  676: 
33695: #ifndef WINCE
33695: /**
33695:  * Provides a fallback for getting the path to APPDATA or LOCALAPPDATA by
33695:  * querying the registry when the call to SHGetSpecialFolderLocation or
33695:  * SHGetPathFromIDListW is unable to provide these paths (Bug 513958).
33695:  */
33695: static nsresult
33695: GetRegWindowsAppDataFolder(PRBool aLocal, nsAString& _retval)
33695: {
33695:   HKEY key;
33695:   NS_NAMED_LITERAL_STRING(keyName,
33695:   "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
33695:   DWORD res = ::RegOpenKeyExW(HKEY_CURRENT_USER, keyName.get(), 0, KEY_READ,
33695:                               &key);
33695:   if (res != ERROR_SUCCESS) {
33695:     _retval.SetLength(0);
33695:     return NS_ERROR_NOT_AVAILABLE;
33695:   }
33695: 
33695:   DWORD type, size;
33695:   res = RegQueryValueExW(key, (aLocal ? L"Local AppData" : L"AppData"), NULL,
33695:                          &type, NULL, &size);
33695:   // The call to RegQueryValueExW must succeed, the type must be REG_SZ, the
33695:   // buffer size must not equal 0, and the buffer size be a multiple of 2.
33695:   if (res != ERROR_SUCCESS || type != REG_SZ || size == 0 || size % 2 != 0) {
33695:     ::RegCloseKey(key);
33695:     _retval.SetLength(0);
33695:     return NS_ERROR_NOT_AVAILABLE;
33695:   }
33695: 
33695:   // |size| includes room for the terminating null character
33695:   DWORD resultLen = size / 2 - 1;
33695: 
33695:   _retval.SetLength(resultLen);
33695:   nsAString::iterator begin;
33695:   _retval.BeginWriting(begin);
33695:   if (begin.size_forward() != resultLen) {
33695:     ::RegCloseKey(key);
33695:     _retval.SetLength(0);
33695:     return NS_ERROR_NOT_AVAILABLE;
33695:   }
33695: 
33695:   res = RegQueryValueExW(key, (aLocal ? L"Local AppData" : L"AppData"), NULL,
33695:                          NULL, (LPBYTE) begin.get(), &size);
33695:   ::RegCloseKey(key);
33695:   if (res != ERROR_SUCCESS) {
33695:     _retval.SetLength(0);
33695:     return NS_ERROR_NOT_AVAILABLE;
33695:   }
33695: 
33695:   return NS_OK;
33695: }
33695: #endif
33695: 
  676: nsresult
  676: nsXREDirProvider::GetUpdateRootDir(nsIFile* *aResult)
  676: {
  676:   nsCOMPtr<nsIFile> appDir = GetAppDir();
 6338: 
 6338:   nsAutoString appPath;
 6338:   nsresult rv = appDir->GetPath(appPath);
  676:   NS_ENSURE_SUCCESS(rv, rv);
  676: 
  676:   // AppDir may be a short path. Convert to long path to make sure
  676:   // the consistency of the update folder location
 6338:   nsString longPath;
 6338:   PRUnichar* buf;
 6338: 
 6338:   PRUint32 bufLength = longPath.GetMutableData(&buf, MAXPATHLEN);
 6338:   NS_ENSURE_TRUE(bufLength >= MAXPATHLEN, NS_ERROR_OUT_OF_MEMORY);
 6338: 
22243: #ifdef WINCE
22243:   longPath.Assign(appPath);
22243: #else
 6338:   DWORD len = GetLongPathNameW(appPath.get(), buf, bufLength);
 6338: 
  676:   // Failing GetLongPathName() is not fatal.
 6338:   if (len <= 0 || len >= bufLength)
  676:     longPath.Assign(appPath);
  676:   else
  676:     longPath.SetLength(len);
22243: #endif
  676:   // Use <UserLocalDataDir>\updates\<relative path to app dir from
  676:   // Program Files> if app dir is under Program Files to avoid the
  676:   // folder virtualization mess on Windows Vista
 6338:   nsAutoString programFiles;
  676:   rv = GetShellFolderPath(CSIDL_PROGRAM_FILES, programFiles);
  676:   NS_ENSURE_SUCCESS(rv, rv);
  676: 
 6338:   programFiles.AppendLiteral("\\");
 6338:   PRUint32 programFilesLen = programFiles.Length();
  676: 
  676:   if (longPath.Length() < programFilesLen)
  676:     return NS_ERROR_FAILURE;
  676: 
 6338:   if (_wcsnicmp(programFiles.get(), longPath.get(), programFilesLen) != 0)
  676:     return NS_ERROR_FAILURE;
  676: 
  676:   nsCOMPtr<nsILocalFile> updRoot;
  676:   rv = GetUserLocalDataDirectory(getter_AddRefs(updRoot));
  676:   NS_ENSURE_SUCCESS(rv, rv);
  676: 
 6338:   rv = updRoot->AppendRelativePath(Substring(longPath, programFilesLen));
  676:   NS_ENSURE_SUCCESS(rv, rv);
  676: 
  676:   NS_ADDREF(*aResult = updRoot);
  676:   return NS_OK;
  676: }
    1: #endif
    1: 
    1: nsresult
    1: nsXREDirProvider::GetProfileStartupDir(nsIFile* *aResult)
    1: {
    1:   if (mProfileDir)
    1:     return mProfileDir->Clone(aResult);
    1: 
    1:   if (mAppProvider) {
    1:     nsCOMPtr<nsIFile> needsclone;
    1:     PRBool dummy;
    1:     nsresult rv = mAppProvider->GetFile(NS_APP_PROFILE_DIR_STARTUP,
    1:                                         &dummy,
    1:                                         getter_AddRefs(needsclone));
    1:     if (NS_SUCCEEDED(rv))
    1:       return needsclone->Clone(aResult);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsresult
    1: nsXREDirProvider::GetProfileDir(nsIFile* *aResult)
    1: {
    1:   if (mProfileDir) {
    1:     if (!mProfileNotified)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     return mProfileDir->Clone(aResult);
    1:   }
    1: 
    1:   if (mAppProvider) {
    1:     nsCOMPtr<nsIFile> needsclone;
    1:     PRBool dummy;
    1:     nsresult rv = mAppProvider->GetFile(NS_APP_USER_PROFILE_50_DIR,
    1:                                         &dummy,
    1:                                         getter_AddRefs(needsclone));
    1:     if (NS_SUCCEEDED(rv))
    1:       return needsclone->Clone(aResult);
    1:   }
    1: 
    1:   return NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, aResult);
    1: }
    1: 
    1: nsresult
10285: nsXREDirProvider::GetUserDataDirectoryHome(nsILocalFile** aFile, PRBool aLocal)
    1: {
    1:   // Copied from nsAppFileLocationProvider (more or less)
    1:   nsresult rv;
    1:   nsCOMPtr<nsILocalFile> localDir;
    1: 
    1: #if defined(XP_MACOSX)
    1:   FSRef fsRef;
    1:   OSType folderType;
    1:   if (aLocal) {
    1:     folderType = kCachedDataFolderType;
    1:   } else {
    1: #ifdef MOZ_THUNDERBIRD
    1:     folderType = kDomainLibraryFolderType;
    1: #else
    1:     folderType = kApplicationSupportFolderType;
    1: #endif
    1:   }
    1:   OSErr err = ::FSFindFolder(kUserDomain, folderType, kCreateFolder, &fsRef);
    1:   NS_ENSURE_FALSE(err, NS_ERROR_FAILURE);
    1: 
    1:   rv = NS_NewNativeLocalFile(EmptyCString(), PR_TRUE, getter_AddRefs(localDir));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsILocalFileMac> dirFileMac = do_QueryInterface(localDir);
    1:   NS_ENSURE_TRUE(dirFileMac, NS_ERROR_UNEXPECTED);
    1: 
    1:   rv = dirFileMac->InitWithFSRef(&fsRef);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6338:   localDir = do_QueryInterface(dirFileMac, &rv);
    1: #elif defined(XP_WIN)
 6338:   nsString path;
33695:   if (aLocal) {
    1:     rv = GetShellFolderPath(CSIDL_LOCAL_APPDATA, path);
33695: #ifndef WINCE
33695:     if (NS_FAILED(rv))
33695:       rv = GetRegWindowsAppDataFolder(aLocal, path);
33695: #endif
33695:   }
33695:   if (!aLocal || NS_FAILED(rv)) {
    1:     rv = GetShellFolderPath(CSIDL_APPDATA, path);
33695: #ifndef WINCE
33695:     if (NS_FAILED(rv)) {
33695:       if (!aLocal)
33695:         rv = GetRegWindowsAppDataFolder(aLocal, path);
33695:     }
33695: #endif
33695: 
33695:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6338:   rv = NS_NewLocalFile(path, PR_TRUE, getter_AddRefs(localDir));
    1: #elif defined(XP_OS2)
    1: #if 0 /* For OS/2 we want to always use MOZILLA_HOME */
    1:   // we want an environment variable of the form
    1:   // FIREFOX_HOME, etc
16742:   if (!gAppData)
16742:     return NS_ERROR_FAILURE;
    1:   nsDependentCString envVar(nsDependentCString(gAppData->name));
    1:   envVar.Append("_HOME");
    1:   char *pHome = getenv(envVar.get());
    1: #endif
    1:   char *pHome = getenv("MOZILLA_HOME");
    1:   if (pHome && *pHome) {
    1:     rv = NS_NewNativeLocalFile(nsDependentCString(pHome), PR_TRUE,
    1:                                getter_AddRefs(localDir));
    1:   } else {
    1:     PPIB ppib;
    1:     PTIB ptib;
    1:     char appDir[CCHMAXPATH];
    1: 
    1:     DosGetInfoBlocks(&ptib, &ppib);
    1:     DosQueryModuleName(ppib->pib_hmte, CCHMAXPATH, appDir);
    1:     *strrchr(appDir, '\\') = '\0';
    1:     rv = NS_NewNativeLocalFile(nsDependentCString(appDir), PR_TRUE, getter_AddRefs(localDir));
    1:   }
    1: #elif defined(XP_BEOS)
    1:   char appDir[MAXPATHLEN];
    1:   if (find_directory(B_USER_SETTINGS_DIRECTORY, NULL, true, appDir, MAXPATHLEN))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   int len = strlen(appDir);
    1:   appDir[len]   = '/';
    1:   appDir[len+1] = '\0';
    1: 
    1:   rv = NS_NewNativeLocalFile(nsDependentCString(appDir), PR_TRUE,
    1:                              getter_AddRefs(localDir));
    1: #elif defined(XP_UNIX)
    1:   const char* homeDir = getenv("HOME");
    1:   if (!homeDir || !*homeDir)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   rv = NS_NewNativeLocalFile(nsDependentCString(homeDir), PR_TRUE,
    1:                              getter_AddRefs(localDir));
 6338: #else
 6338: #error "Don't know how to get product dir on your platform"
 6338: #endif
10285: 
10285:   NS_IF_ADDREF(*aFile = localDir);
10285:   return rv;
10285: }
10285: 
10285: nsresult
10285: nsXREDirProvider::GetSysUserExtensionsDirectory(nsILocalFile** aFile)
10285: {
10285:   nsCOMPtr<nsILocalFile> localDir;
10285:   nsresult rv = GetUserDataDirectoryHome(getter_AddRefs(localDir), PR_FALSE);
10285:   NS_ENSURE_SUCCESS(rv, rv);
10285: 
10285:   rv = AppendSysUserExtensionPath(localDir);
10285:   NS_ENSURE_SUCCESS(rv, rv);
10285: 
10285:   rv = EnsureDirectoryExists(localDir);
10285:   NS_ENSURE_SUCCESS(rv, rv);
10285: 
10285:   NS_ADDREF(*aFile = localDir);
10285:   return NS_OK;
10285: }
10285: 
12702: #if defined(XP_UNIX) || defined(XP_MACOSX)
12702: nsresult
12702: nsXREDirProvider::GetSystemExtensionsDirectory(nsILocalFile** aFile)
12702: {
12702:   nsresult rv;
12702:   nsCOMPtr<nsILocalFile> localDir;
12702: #if defined(XP_MACOSX)
12702:   FSRef fsRef;
12702:   OSErr err = ::FSFindFolder(kOnSystemDisk, kApplicationSupportFolderType, kCreateFolder, &fsRef);
12702:   NS_ENSURE_FALSE(err, NS_ERROR_FAILURE);
12702: 
12702:   rv = NS_NewNativeLocalFile(EmptyCString(), PR_TRUE, getter_AddRefs(localDir));
12702:   NS_ENSURE_SUCCESS(rv, rv);
12702: 
12702:   nsCOMPtr<nsILocalFileMac> dirFileMac = do_QueryInterface(localDir);
12702:   NS_ENSURE_TRUE(dirFileMac, NS_ERROR_UNEXPECTED);
12702: 
12702:   rv = dirFileMac->InitWithFSRef(&fsRef);
12702:   NS_ENSURE_SUCCESS(rv, rv);
12702: 
12702:   localDir = do_QueryInterface(dirFileMac, &rv);
12702: 
12702:   static const char* const sXR = "Mozilla";
12702:   rv = localDir->AppendNative(nsDependentCString(sXR));
12702:   NS_ENSURE_SUCCESS(rv, rv);
12702: 
12702:   static const char* const sExtensions = "Extensions";
12702:   rv = localDir->AppendNative(nsDependentCString(sExtensions));
12702:   NS_ENSURE_SUCCESS(rv, rv);
12702: #elif defined(XP_UNIX)
12702:   static const char *const sysSExtDir = 
12702: #ifdef HAVE_USR_LIB64_DIR
12702:     "/usr/lib64/mozilla/extensions";
12702: #else
12702:     "/usr/lib/mozilla/extensions";
12702: #endif
12702: 
12702:   rv = NS_NewNativeLocalFile(nsDependentCString(sysSExtDir), PR_FALSE,
12702:                              getter_AddRefs(localDir));
12702:   NS_ENSURE_SUCCESS(rv, rv);
12702: #endif
12702: 
12702:   rv = EnsureDirectoryExists(localDir);
12702:   NS_ENSURE_SUCCESS(rv, rv);
12702: 
12702:   NS_ADDREF(*aFile = localDir);
12702:   return NS_OK;
12702: }
12702: #endif
12702: 
10285: nsresult
10285: nsXREDirProvider::GetUserDataDirectory(nsILocalFile** aFile, PRBool aLocal)
10285: {
10285:   nsCOMPtr<nsILocalFile> localDir;
10285:   nsresult rv = GetUserDataDirectoryHome(getter_AddRefs(localDir), aLocal);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6338:   rv = AppendProfilePath(localDir);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1: #ifdef DEBUG_jungshik
    1:   nsCAutoString cwd;
    1:   localDir->GetNativePath(cwd);
    1:   printf("nsXREDirProvider::GetUserDataDirectory: %s\n", cwd.get());
    1: #endif
    1:   rv = EnsureDirectoryExists(localDir);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6338:   NS_ADDREF(*aFile = localDir);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXREDirProvider::EnsureDirectoryExists(nsIFile* aDirectory)
    1: {
    1:   PRBool exists;
    1:   nsresult rv = aDirectory->Exists(&exists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: #ifdef DEBUG_jungshik
    1:   if (!exists) {
    1:     nsCAutoString cwd;
    1:     aDirectory->GetNativePath(cwd);
    1:     printf("nsXREDirProvider::EnsureDirectoryExists: %s does not\n", cwd.get());
    1:   }
    1: #endif
    1:   if (!exists)
    1:     rv = aDirectory->Create(nsIFile::DIRECTORY_TYPE, 0700);
    1: #ifdef DEBUG_jungshik
    1:   if (NS_FAILED(rv))
    1:     NS_WARNING("nsXREDirProvider::EnsureDirectoryExists: create failed");
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsXREDirProvider::EnsureProfileFileExists(nsIFile *aFile)
    1: {
    1:   nsresult rv;
    1:   PRBool exists;
    1: 
    1:   rv = aFile->Exists(&exists);
    1:   if (NS_FAILED(rv) || exists) return;
    1: 
    1:   nsCAutoString leafName;
    1:   rv = aFile->GetNativeLeafName(leafName);
    1:   if (NS_FAILED(rv)) return;
    1: 
    1:   nsCOMPtr<nsIFile> defaultsFile;
    1:   rv = GetProfileDefaultsDir(getter_AddRefs(defaultsFile));
    1:   if (NS_FAILED(rv)) return;
    1: 
    1:   rv = defaultsFile->AppendNative(leafName);
    1:   if (NS_FAILED(rv)) return;
    1: 
    1:   defaultsFile->CopyToNative(mProfileDir, EmptyCString());
    1: }
    1: 
    1: nsresult
    1: nsXREDirProvider::GetProfileDefaultsDir(nsIFile* *aResult)
    1: {
    1:   NS_ASSERTION(mGREDir, "nsXREDirProvider not initialized.");
    1:   NS_PRECONDITION(aResult, "Null out-param");
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIFile> defaultsDir;
    1: 
    1:   rv = GetAppDir()->Clone(getter_AddRefs(defaultsDir));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = defaultsDir->AppendNative(NS_LITERAL_CSTRING("defaults"));
 6338:   NS_ENSURE_SUCCESS(rv, rv);
 6338: 
 6338:   rv = defaultsDir->AppendNative(NS_LITERAL_CSTRING("profile"));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   NS_ADDREF(*aResult = defaultsDir);
    1:   return NS_OK;
    1: }
    1: 
 6338: nsresult
10285: nsXREDirProvider::AppendSysUserExtensionPath(nsIFile* aFile)
10285: {
10285:   NS_ASSERTION(aFile, "Null pointer!");
10285: 
10285:   nsresult rv;
10285: 
10285: #if defined (XP_MACOSX) || defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS)
10285: 
10285:   static const char* const sXR = "Mozilla";
10285:   rv = aFile->AppendNative(nsDependentCString(sXR));
10285:   NS_ENSURE_SUCCESS(rv, rv);
10285: 
10285:   static const char* const sExtensions = "Extensions";
10285:   rv = aFile->AppendNative(nsDependentCString(sExtensions));
10285:   NS_ENSURE_SUCCESS(rv, rv);
10285: 
10285: #elif defined(XP_UNIX)
10285: 
10285:   static const char* const sXR = ".mozilla";
10285:   rv = aFile->AppendNative(nsDependentCString(sXR));
10285:   NS_ENSURE_SUCCESS(rv, rv);
10285: 
10285:   static const char* const sExtensions = "extensions";
10285:   rv = aFile->AppendNative(nsDependentCString(sExtensions));
10285:   NS_ENSURE_SUCCESS(rv, rv);
10285: 
10285: #else
10285: #error "Don't know how to get XRE user extension path on your platform"
10285: #endif
10285:   return NS_OK;
10285: }
10285: 
10285: 
10285: nsresult
 6338: nsXREDirProvider::AppendProfilePath(nsIFile* aFile)
 6338: {
 6338:   NS_ASSERTION(aFile, "Null pointer!");
 6338: 
 6338:   nsresult rv;
 6338: 
19428:   if (!gAppData)
19428:     return NS_ERROR_FAILURE;
19428: 
 6338: #if defined (XP_MACOSX)
 6338:   if (gAppData->profile) {
 6338:     rv = AppendProfileString(aFile, gAppData->profile);
 6338:   }
 6338:   else {
 6338:     // Note that MacOS ignores the vendor when creating the profile hierarchy -
 6338:     // all application preferences directories live alongside one another in
 6338:     // ~/Library/Application Support/
 6338:     rv = aFile->AppendNative(nsDependentCString(gAppData->name));
 6338:   }
 6338:   NS_ENSURE_SUCCESS(rv, rv);
 6338: 
 6338: #elif defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS)
 6338:   if (gAppData->profile) {
 6338:     rv = AppendProfileString(aFile, gAppData->profile);
 6338:   }
 6338:   else {
 6338:     if (gAppData->vendor) {
 6338:       rv = aFile->AppendNative(nsDependentCString(gAppData->vendor));
 6338:       NS_ENSURE_SUCCESS(rv, rv);
 6338:     }
 6338:     rv = aFile->AppendNative(nsDependentCString(gAppData->name));
 6338:   }
 6338:   NS_ENSURE_SUCCESS(rv, rv);
 6338: 
 6338: #elif defined(XP_UNIX)
 6338:   // Make it hidden (i.e. using the ".")
 6338:   nsCAutoString folder(".");
 6338: 
 6338:   if (gAppData->profile) {
 6338:     // Skip any leading path characters
 6338:     const char* profileStart = gAppData->profile;
 6338:     while (*profileStart == '/' || *profileStart == '\\')
 6338:       profileStart++;
 6338: 
 6338:     // On the off chance that someone wanted their folder to be hidden don't
 6338:     // let it become ".."
 6338:     if (*profileStart == '.')
 6338:       profileStart++;
 6338: 
 6338:     folder.Append(profileStart);
 6338:     ToLowerCase(folder);
 6338: 
 6338:     rv = AppendProfileString(aFile, folder.BeginReading());
 6338:   }
 6338:   else {
 6338:     if (gAppData->vendor) {
 6338:       folder.Append(gAppData->vendor);
 6338:       ToLowerCase(folder);
 6338: 
 6338:       rv = aFile->AppendNative(folder);
 6338:       NS_ENSURE_SUCCESS(rv, rv);
 6338: 
 6338:       folder.Truncate();
 6338:     }
 6338: 
 6338:     folder.Append(gAppData->name);
 6338:     ToLowerCase(folder);
 6338: 
 6338:     rv = aFile->AppendNative(folder);
 6338:   }
 6338:   NS_ENSURE_SUCCESS(rv, rv);
 6338: 
 6338: #else
 6338: #error "Don't know how to get profile path on your platform"
 6338: #endif
 6338:   return NS_OK;
 6338: }
 6338: 
 6338: nsresult
 6338: nsXREDirProvider::AppendProfileString(nsIFile* aFile, const char* aPath)
 6338: {
 6338:   NS_ASSERTION(aFile, "Null file!");
 6338:   NS_ASSERTION(aPath, "Null path!");
 6338: 
 6338:   nsCAutoString pathDup(aPath);
 6338: 
 6338:   char* path = pathDup.BeginWriting();
 6338: 
 6338:   nsresult rv;
 6338:   char* subdir;
 6338:   while ((subdir = NS_strtok("/\\", &path))) {
 6338:     rv = aFile->AppendNative(nsDependentCString(subdir));
 6338:     NS_ENSURE_SUCCESS(rv, rv);
 6338:   }
 6338: 
 6338:   return NS_OK;
 6338: }
