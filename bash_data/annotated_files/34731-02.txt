    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef nscore_h___
    1: #define nscore_h___
    1: 
    1: /**
    1:  * Make sure that we have the proper platform specific
    1:  * c++ definitions needed by nscore.h
    1:  */
    1: #ifndef _XPCOM_CONFIG_H_
    1: #include "xpcom-config.h"
    1: #endif
    1: 
    1: /**
    1:  * Incorporate the core NSPR data types which XPCOM uses.
    1:  */
    1: #include "prtypes.h"
    1: 
    1: /* Core XPCOM declarations. */
    1: 
    1: /**
    1:  * Macros defining the target platform...
    1:  */
    1: #ifdef _WIN32
    1: #define NS_WIN32 1
    1: 
    1: #elif defined(__unix)
    1: #define NS_UNIX 1
    1: 
    1: #elif defined(XP_OS2)
    1: #define NS_OS2 1
    1: #endif
    1: /*----------------------------------------------------------------------*/
    1: /* Import/export defines */
    1: 
    1: /**
    1:  * Using the visibility("hidden") attribute allows the compiler to use
    1:  * PC-relative addressing to call this function.  If a function does not
    1:  * access any global data, and does not call any methods which are not either
    1:  * file-local or hidden, then on ELF systems we avoid loading the address of
    1:  * the PLT into a register at the start of the function, which reduces code
    1:  * size and frees up a register for general use.
    1:  *
    1:  * As a general rule, this should be used for any non-exported symbol
    1:  * (including virtual method implementations).  NS_IMETHOD uses this by
    1:  * default; if you need to have your NS_IMETHOD functions exported, you can
    1:  * wrap your class as follows:
    1:  *
    1:  * #undef  IMETHOD_VISIBILITY
    1:  * #define IMETHOD_VISIBILITY NS_VISIBILITY_DEFAULT
    1:  *
    1:  * class Foo {
    1:  * ...
    1:  * };
    1:  *
    1:  * #undef  IMETHOD_VISIBILITY
    1:  * #define IMETHOD_VISIBILITY NS_VISIBILITY_HIDDEN
    1:  *
    1:  * Don't forget to change the visibility back to hidden before the end
    1:  * of a header!
    1:  *
    1:  * Other examples:
    1:  *
    1:  * NS_HIDDEN_(int) someMethod();
    1:  * SomeCtor() NS_HIDDEN;
    1:  */
    1: 
    1: #ifdef HAVE_VISIBILITY_HIDDEN_ATTRIBUTE
    1: #define NS_VISIBILITY_HIDDEN   __attribute__ ((visibility ("hidden")))
    1: #else
    1: #define NS_VISIBILITY_HIDDEN
    1: #endif
    1: 
    1: #if defined(HAVE_VISIBILITY_ATTRIBUTE)
    1: #define NS_VISIBILITY_DEFAULT __attribute__ ((visibility ("default")))
18946: #elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
18946: #define NS_VISIBILITY_DEFAULT __global
    1: #else
    1: #define NS_VISIBILITY_DEFAULT
    1: #endif
    1: 
    1: #define NS_HIDDEN_(type)   NS_VISIBILITY_HIDDEN type
    1: #define NS_EXTERNAL_VIS_(type) NS_VISIBILITY_DEFAULT type
    1: 
    1: #define NS_HIDDEN           NS_VISIBILITY_HIDDEN
    1: #define NS_EXTERNAL_VIS     NS_VISIBILITY_DEFAULT
    1: 
    1: #undef  IMETHOD_VISIBILITY
    1: #define IMETHOD_VISIBILITY  NS_VISIBILITY_HIDDEN
    1: 
    1: /**
    1:  * Mark a function as using a potentially non-standard function calling
    1:  * convention.  This can be used on functions that are called very
    1:  * frequently, to reduce the overhead of the function call.  It is still worth
    1:  * using the macro for C++ functions which take no parameters since it allows
    1:  * passing |this| in a register.
    1:  *
    1:  *  - Do not use this on any scriptable interface method since xptcall won't be
    1:  *    aware of the different calling convention.
    1:  *  - This must appear on the declaration, not the definition.
    1:  *  - Adding this to a public function _will_ break binary compatibility.
    1:  *  - This may be used on virtual functions but you must ensure it is applied
    1:  *    to all implementations - the compiler will _not_ warn but it will crash.
    1:  *  - This has no effect for inline functions or functions which take a
    1:  *    variable number of arguments.
    1:  *  - __fastcall on windows should not be applied to class
    1:  *    constructors/destructors - use the NS_CONSTRUCTOR_FASTCALL macro for
    1:  *    constructors/destructors.
    1:  *
    1:  * Examples: int NS_FASTCALL func1(char *foo);
    1:  *           NS_HIDDEN_(int) NS_FASTCALL func2(char *foo);
    1:  */
    1: 
32423: #if defined(__i386__) && defined(__GNUC__) && \
32423:     (__GNUC__ >= 3) && !defined(XP_OS2)
    1: #define NS_FASTCALL __attribute__ ((regparm (3), stdcall))
    1: #define NS_CONSTRUCTOR_FASTCALL __attribute__ ((regparm (3), stdcall))
    1: #elif defined(XP_WIN)
    1: #define NS_FASTCALL __fastcall
    1: #define NS_CONSTRUCTOR_FASTCALL
    1: #else
    1: #define NS_FASTCALL
    1: #define NS_CONSTRUCTOR_FASTCALL
    1: #endif
    1: 
    1: /*
    1:  * NS_DEFCALL undoes the effect of a global regparm/stdcall setting
    1:  * so that xptcall works correctly.
    1:  */
32423: #if defined(__i386__) && defined(__GNUC__) && \
32423:     (__GNUC__ >= 3) && !defined(XP_OS2)
    1: #define NS_DEFCALL __attribute__ ((regparm (0), cdecl))
    1: #else
    1: #define NS_DEFCALL
    1: #endif
    1: 
    1: #ifdef NS_WIN32
    1: 
    1: #define NS_IMPORT __declspec(dllimport)
    1: #define NS_IMPORT_(type) __declspec(dllimport) type __stdcall
    1: #define NS_EXPORT __declspec(dllexport)
    1: #define NS_EXPORT_(type) __declspec(dllexport) type __stdcall
    1: #define NS_IMETHOD_(type) virtual type __stdcall
    1: #define NS_IMETHODIMP_(type) type __stdcall
    1: #define NS_METHOD_(type) type __stdcall
    1: #define NS_CALLBACK_(_type, _name) _type (__stdcall * _name)
    1: #define NS_STDCALL __stdcall
    1: #define NS_FROZENCALL __cdecl
    1: 
    1: /*
    1:   These are needed to mark static members in exported classes, due to
    1:   gcc bug XXX insert bug# here.
    1:  */
    1: 
    1: #define NS_EXPORT_STATIC_MEMBER_(type) type
    1: #define NS_IMPORT_STATIC_MEMBER_(type) type
    1: 
    1: #elif defined(XP_OS2) && defined(__declspec)
    1: 
    1: #define NS_IMPORT __declspec(dllimport)
    1: #define NS_IMPORT_(type) type __declspec(dllimport)
    1: #define NS_EXPORT __declspec(dllexport)
    1: #define NS_EXPORT_(type) type __declspec(dllexport)
    1: #define NS_IMETHOD_(type) virtual type
    1: #define NS_IMETHODIMP_(type) type
    1: #define NS_METHOD_(type) type
    1: #define NS_CALLBACK_(_type, _name) _type (* _name)
    1: #define NS_STDCALL
    1: #define NS_FROZENCALL
    1: #define NS_EXPORT_STATIC_MEMBER_(type) NS_EXTERNAL_VIS_(type)
    1: #define NS_IMPORT_STATIC_MEMBER_(type) NS_EXTERNAL_VIS_(type)
    1: 
    1: #else
    1: 
    1: #define NS_IMPORT NS_EXTERNAL_VIS
    1: #define NS_IMPORT_(type) NS_EXTERNAL_VIS_(type)
    1: #define NS_EXPORT NS_EXTERNAL_VIS
    1: #define NS_EXPORT_(type) NS_EXTERNAL_VIS_(type)
    1: #define NS_IMETHOD_(type) virtual IMETHOD_VISIBILITY type NS_DEFCALL
    1: #define NS_IMETHODIMP_(type) type
    1: #define NS_METHOD_(type) type
    1: #define NS_CALLBACK_(_type, _name) _type (* _name)
    1: #define NS_STDCALL
    1: #define NS_FROZENCALL
    1: #define NS_EXPORT_STATIC_MEMBER_(type) NS_EXTERNAL_VIS_(type)
    1: #define NS_IMPORT_STATIC_MEMBER_(type) NS_EXTERNAL_VIS_(type)
    1: 
    1: #endif
    1: 
    1: /**
    1:  * Macro for creating typedefs for pointer-to-member types which are
    1:  * declared with stdcall.  It is important to use this for any type which is
    1:  * declared as stdcall (i.e. NS_IMETHOD).  For example, instead of writing:
    1:  *
    1:  *  typedef nsresult (nsIFoo::*someType)(nsISupports* arg);
    1:  *
    1:  *  you should write:
    1:  *
    1:  *  typedef
    1:  *  NS_STDCALL_FUNCPROTO(nsresult, someType, nsIFoo, typeFunc, (nsISupports*));
    1:  *
    1:  *  where nsIFoo::typeFunc is any method declared as
    1:  *  NS_IMETHOD typeFunc(nsISupports*);
    1:  *
    1:  *  XXX this can be simplified to always use the non-typeof implementation
    1:  *  when http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11893 is fixed.
    1:  */
    1: 
    1: #ifdef __GNUC__
    1: #define NS_STDCALL_FUNCPROTO(ret, name, class, func, args) \
    1:   typeof(&class::func) name
    1: #else
    1: #define NS_STDCALL_FUNCPROTO(ret, name, class, func, args) \
    1:   ret (NS_STDCALL class::*name) args
    1: #endif
    1: 
    1: /**
12933:  * Deprecated declarations.
12933:  */
12933: #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))
12933: # define NS_DEPRECATED __attribute__((deprecated))
12933: #elif defined(_MSC_VER) && (_MSC_VER >= 1300)
12933: # define NS_DEPRECATED __declspec(deprecated)
12933: #else
12933: # define NS_DEPRECATED
12933: #endif
12933: 
12933: /**
    1:  * Generic API modifiers which return the standard XPCOM nsresult type
    1:  */
    1: #define NS_IMETHOD          NS_IMETHOD_(nsresult)
    1: #define NS_IMETHODIMP       NS_IMETHODIMP_(nsresult)
    1: #define NS_METHOD           NS_METHOD_(nsresult)
    1: #define NS_CALLBACK(_name)  NS_CALLBACK_(nsresult, _name)
    1: 
    1: /**
    1:  * Import/Export macros for XPCOM APIs
    1:  */
    1: 
    1: #ifdef __cplusplus
    1: #define NS_EXTERN_C extern "C"
    1: #else
    1: #define NS_EXTERN_C
    1: #endif
    1: 
    1: #define EXPORT_XPCOM_API(type) NS_EXTERN_C NS_EXPORT type NS_FROZENCALL
    1: #define IMPORT_XPCOM_API(type) NS_EXTERN_C NS_IMPORT type NS_FROZENCALL
    1: #define GLUE_XPCOM_API(type) NS_EXTERN_C NS_HIDDEN_(type) NS_FROZENCALL
    1: 
    1: #ifdef _IMPL_NS_COM
    1: #define XPCOM_API(type) EXPORT_XPCOM_API(type)
    1: #elif defined(XPCOM_GLUE)
    1: #define XPCOM_API(type) GLUE_XPCOM_API(type)
    1: #else
    1: #define XPCOM_API(type) IMPORT_XPCOM_API(type)
    1: #endif
    1: 
    1: #ifdef MOZ_ENABLE_LIBXUL
    1: #define NS_COM
    1: #elif defined(_IMPL_NS_COM)
    1: #define NS_COM NS_EXPORT
    1: #elif defined(XPCOM_GLUE)
    1: #define NS_COM
    1: #else
    1: #define NS_COM NS_IMPORT
    1: #endif
    1: 
    1: #ifdef MOZILLA_INTERNAL_API
    1: #  define NS_COM_GLUE NS_COM
    1:    /*
    1:      The frozen string API has different definitions of nsAC?String
    1:      classes than the internal API. On systems that explicitly declare
    1:      dllexport symbols this is not a problem, but on ELF systems
    1:      internal symbols can accidentally "shine through"; we rename the
    1:      internal classes to avoid symbol conflicts.
    1:    */
    1: #  define nsAString nsAString_internal
    1: #  define nsACString nsACString_internal
    1: #else
    1: #  ifdef HAVE_VISIBILITY_ATTRIBUTE
    1: #    define NS_COM_GLUE NS_VISIBILITY_HIDDEN
    1: #  else
    1: #    define NS_COM_GLUE
    1: #  endif
    1: #endif
    1: 
    1: 
    1: /**
    1:  * NS_NO_VTABLE is emitted by xpidl in interface declarations whenever
    1:  * xpidl can determine that the interface can't contain a constructor.
    1:  * This results in some space savings and possible runtime savings -
    1:  * see bug 49416.  We undefine it first, as xpidl-generated headers
    1:  * define it for IDL uses that don't include this file.
    1:  */
    1: #ifdef NS_NO_VTABLE
    1: #undef NS_NO_VTABLE
    1: #endif
    1: #if defined(_MSC_VER) && _MSC_VER >= 1100
    1: #define NS_NO_VTABLE __declspec(novtable)
    1: #else
    1: #define NS_NO_VTABLE
    1: #endif
    1: 
    1: 
    1: /**
    1:  * Generic XPCOM result data type
    1:  */
    1: typedef PRUint32 nsresult;
    1: 
    1: /**
    1:  * Reference count values
    1:  *
    1:  * This is the return type for AddRef() and Release() in nsISupports.
    1:  * IUnknown of COM returns an unsigned long from equivalent functions.
    1:  * The following ifdef exists to maintain binary compatibility with
    1:  * IUnknown.
    1:  */
    1: #if defined(XP_WIN) && PR_BYTES_PER_LONG == 4
    1: typedef unsigned long nsrefcnt;
    1: #else
    1: typedef PRUint32 nsrefcnt;
    1: #endif
    1: 
    1: /**
    1:  * The preferred symbol for null.
    1:  */
    1: #define nsnull 0
    1: 
    1: #include "nsError.h"
    1: 
    1: /* ------------------------------------------------------------------------ */
    1: /* Casting macros for hiding C++ features from older compilers */
    1: 
    1:   /*
    1:     All our compiler support template specialization, but not all support the
    1:     |template <>| notation.  The compiler that don't understand this notation
    1:     just omit it for specialization.
    1: 
    1:     Need to add an autoconf test for this.
    1:   */
    1: 
    1:   /* under VC++ (Windows), we don't have autoconf yet */
    1: #if defined(_MSC_VER) && (_MSC_VER>=1100)
    1:   #define HAVE_CPP_MODERN_SPECIALIZE_TEMPLATE_SYNTAX
    1: 
    1:   #define HAVE_CPP_EXPLICIT
    1:   #define HAVE_CPP_TYPENAME
    1:   #define HAVE_CPP_ACCESS_CHANGING_USING
    1: 
    1:   #define HAVE_CPP_NAMESPACE_STD
    1:   #define HAVE_CPP_UNAMBIGUOUS_STD_NOTEQUAL
    1:   #define HAVE_CPP_2BYTE_WCHAR_T
    1: #endif
    1: 
    1: #ifndef __PRUNICHAR__
    1: #define __PRUNICHAR__
    1:   /* For now, don't use wchar_t on Unix because it breaks the Netscape
    1:    * commercial build.  When this is fixed there will be no need for the
 3233:    * |reinterpret_cast| in nsLiteralString.h either.
    1:    */
    1:   #if defined(HAVE_CPP_2BYTE_WCHAR_T) && defined(NS_WIN32)
    1:     typedef wchar_t PRUnichar;
    1:   #else
    1:     typedef PRUint16 PRUnichar;
    1:   #endif
    1: #endif
    1: 
    1:   /*
32423:     If the compiler doesn't support |explicit|, we'll just make it go
32423:     away, trusting that the builds under compilers that do have it
32423:     will keep us on the straight and narrow.
    1:   */
    1: #ifndef HAVE_CPP_EXPLICIT
    1:   #define explicit
    1: #endif
    1: 
    1: #ifndef HAVE_CPP_TYPENAME
    1:   #define typename
    1: #endif
    1: 
    1: #ifdef HAVE_CPP_MODERN_SPECIALIZE_TEMPLATE_SYNTAX
    1:   #define NS_SPECIALIZE_TEMPLATE  template <>
    1: #else
    1:   #define NS_SPECIALIZE_TEMPLATE
    1: #endif
    1: 
    1: /*
    1:  * Use these macros to do 64bit safe pointer conversions.
    1:  */
    1: 
    1: #define NS_PTR_TO_INT32(x)  ((PRInt32)  (PRWord) (x))
    1: #define NS_PTR_TO_UINT32(x) ((PRUint32) (PRWord) (x))
    1: #define NS_INT32_TO_PTR(x)  ((void *)   (PRWord) (x))
    1: 
    1: /*
    1:  * Use NS_STRINGIFY to form a string literal from the value of a macro.
    1:  */
    1: #define NS_STRINGIFY_HELPER(x_) #x_
    1: #define NS_STRINGIFY(x_) NS_STRINGIFY_HELPER(x_)
    1: 
    1: /*
    1:  * These macros allow you to give a hint to the compiler about branch
    1:  * probability so that it can better optimize.  Use them like this:
    1:  *
    1:  *  if (NS_LIKELY(v == 1)) {
    1:  *    ... expected code path ...
    1:  *  }
    1:  *
    1:  *  if (NS_UNLIKELY(v == 0)) {
    1:  *    ... non-expected code path ...
    1:  *  }
    1:  *
    1:  * These macros are guaranteed to always return 0 or 1.
    1:  * The NS_FAILED/NS_SUCCEEDED macros depends on this.
    1:  * @return 0 or 1
    1:  */
    1: 
    1: #if defined(__GNUC__) && (__GNUC__ > 2)
    1: #define NS_LIKELY(x)    (__builtin_expect(!!(x), 1))
    1: #define NS_UNLIKELY(x)  (__builtin_expect(!!(x), 0))
    1: #else
    1: #define NS_LIKELY(x)    (!!(x))
    1: #define NS_UNLIKELY(x)  (!!(x))
    1: #endif
    1: 
 6409:  /*
32423:   * If we're being linked as standalone glue, we don't want a dynamic
32423:   * dependency on NSPR libs, so we skip the debug thread-safety
32423:   * checks, and we cannot use the THREADSAFE_ISUPPORTS macros.
 6409:   */
 6409: #if defined(XPCOM_GLUE) && !defined(XPCOM_GLUE_USE_NSPR)
 6409: #define XPCOM_GLUE_AVOID_NSPR
 6409: #endif
 6409: 
34731: #if defined(HAVE_THREAD_TLS_KEYWORD)
34250: #define NS_TLS __thread
34250: #endif
34250: 
12116: /**
12116:  * Static type annotations, enforced when static-checking is enabled:
12116:  *
12116:  * NS_STACK_CLASS: a class which must only be instantiated on the stack
12116:  * NS_FINAL_CLASS: a class which may not be subclassed
32423:  *
32423:  * NS_MUST_OVERRIDE:
32423:  *   a method which every immediate subclass of this class must
32423:  *   override.  A subclass override can itself be NS_MUST_OVERRIDE, in
32423:  *   which case its own subclasses must override the method as well.
32423:  *
32423:  *   This is similar to, but not the same as, marking a method pure
32423:  *   virtual.  It has no effect on the class in which the annotation
32423:  *   appears, you can still provide a definition for the method, and
32423:  *   it objects to the mere existence of a subclass that doesn't
32423:  *   override the method.  See examples in analysis/must-override.js.
12116:  */
12116: #ifdef NS_STATIC_CHECKING
12116: #define NS_STACK_CLASS __attribute__((user("NS_stack")))
18449: #define NS_OKONHEAP    __attribute__((user("NS_okonheap")))
18794: #define NS_SUPPRESS_STACK_CHECK __attribute__((user("NS_suppress_stackcheck")))
12116: #define NS_FINAL_CLASS __attribute__((user("NS_final")))
32423: #define NS_MUST_OVERRIDE __attribute__((user("NS_must_override")))
12116: #else
12116: #define NS_STACK_CLASS
18449: #define NS_OKONHEAP
18741: #define NS_SUPPRESS_STACK_CHECK
12116: #define NS_FINAL_CLASS
32423: #define NS_MUST_OVERRIDE
12116: #endif
12116: 
14838: /**
14838:  * Attributes defined to help Dehydra GCC analysis.
14838:  */
14838: #ifdef NS_STATIC_CHECKING
14838: # define NS_SCRIPTABLE __attribute__((user("NS_script")))
14893: # define NS_INPARAM __attribute__((user("NS_inparam")))
14838: # define NS_OUTPARAM  __attribute__((user("NS_outparam")))
14838: # define NS_INOUTPARAM __attribute__((user("NS_inoutparam")))
32868: # define NS_OVERRIDE __attribute__((user("NS_override")))
14838: #else
14838: # define NS_SCRIPTABLE
14893: # define NS_INPARAM
14838: # define NS_OUTPARAM
14838: # define NS_INOUTPARAM
32868: # define NS_OVERRIDE
14838: #endif
14838: 
    1: #endif /* nscore_h___ */
