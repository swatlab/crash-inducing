43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43113:  *
43113:  * ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is nsCacheEntry.cpp, released
43113:  * February 22, 2001.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Gordon Sheridan <gordon@netscape.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: 
43113: #include "nspr.h"
43113: #include "nsCacheEntry.h"
43113: #include "nsCacheEntryDescriptor.h"
43113: #include "nsCacheMetaData.h"
43113: #include "nsCacheRequest.h"
43113: #include "nsThreadUtils.h"
43113: #include "nsError.h"
43113: #include "nsICacheService.h"
43113: #include "nsCache.h"
43113: #include "nsCacheService.h"
43113: #include "nsCacheDevice.h"
43113: #include "nsCRT.h"
43113: 
43113: 
43113: nsCacheEntry::nsCacheEntry(nsCString *          key,
79445:                            bool                 streamBased,
43113:                            nsCacheStoragePolicy storagePolicy)
43113:     : mKey(key),
43113:       mFetchCount(0),
43113:       mLastFetched(0),
43113:       mLastModified(0),
46915:       mExpirationTime(nsICache::NO_EXPIRATION_TIME),
43113:       mFlags(0),
52144:       mPredictedDataSize(-1),
43113:       mDataSize(0),
43113:       mCacheDevice(nsnull),
43113:       mData(nsnull)
43113: {
43113:     MOZ_COUNT_CTOR(nsCacheEntry);
43113:     PR_INIT_CLIST(this);
43113:     PR_INIT_CLIST(&mRequestQ);
43113:     PR_INIT_CLIST(&mDescriptorQ);
43113: 
43113:     if (streamBased) MarkStreamBased();
43113:     SetStoragePolicy(storagePolicy);
43113: }
43113: 
43113: 
43113: nsCacheEntry::~nsCacheEntry()
43113: {
43113:     MOZ_COUNT_DTOR(nsCacheEntry);
43113:     delete mKey;
43113:     
43113:     if (mData)
43113:         nsCacheService::ReleaseObject_Locked(mData, mThread);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheEntry::Create( const char *          key,
79445:                       bool                  streamBased,
43113:                       nsCacheStoragePolicy  storagePolicy,
43113:                       nsCacheDevice *       device,
43113:                       nsCacheEntry **       result)
43113: {
43113:     nsCString* newKey = new nsCString(key);
43113:     if (!newKey) return NS_ERROR_OUT_OF_MEMORY;
43113:     
43113:     nsCacheEntry* entry = new nsCacheEntry(newKey, streamBased, storagePolicy);
43113:     if (!entry) { delete newKey; return NS_ERROR_OUT_OF_MEMORY; }
43113:     
43113:     entry->SetCacheDevice(device);
43113:     
43113:     *result = entry;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheEntry::Fetched()
43113: {
43113:     mLastFetched = SecondsFromPRTime(PR_Now());
43113:     ++mFetchCount;
43113:     MarkEntryDirty();
43113: }
43113: 
43113: 
43113: const char *
43113: nsCacheEntry::GetDeviceID()
43113: {
43113:     if (mCacheDevice)  return mCacheDevice->GetDeviceID();
43113:     return nsnull;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheEntry::TouchData()
43113: {
43113:     mLastModified = SecondsFromPRTime(PR_Now());
43113:     MarkDataDirty();
43113: }
43113: 
43113: 
43113: void
43113: nsCacheEntry::SetData(nsISupports * data)
43113: {
43113:     if (mData) {
43113:         nsCacheService::ReleaseObject_Locked(mData, mThread);
43113:         mData = nsnull;
43113:     }
43113: 
43113:     if (data) {
43113:         NS_ADDREF(mData = data);
43113:         mThread = do_GetCurrentThread();
43113:     }
43113: }
43113: 
43113: 
43113: void
43113: nsCacheEntry::TouchMetaData()
43113: {
43113:     mLastModified = SecondsFromPRTime(PR_Now());
43113:     MarkMetaDataDirty();
43113: }
43113: 
43113: 
43113: /**
43113:  *  cache entry states
43113:  *      0 descriptors (new entry)
43113:  *      0 descriptors (existing, bound entry)
43113:  *      n descriptors (existing, bound entry) valid
43113:  *      n descriptors (existing, bound entry) not valid (wait until valid or doomed)
43113:  */
43113: 
43113: nsresult
43113: nsCacheEntry::RequestAccess(nsCacheRequest * request, nsCacheAccessMode *accessGranted)
43113: {
43113:     nsresult  rv = NS_OK;
43113: 
56468:     if (IsDoomed()) return NS_ERROR_CACHE_ENTRY_DOOMED;
56468: 
43113:     if (!IsInitialized()) {
43113:         // brand new, unbound entry
43113:         request->mKey = nsnull;  // steal ownership of the key string
43113:         if (request->IsStreamBased())  MarkStreamBased();
43113:         MarkInitialized();
43113: 
43113:         *accessGranted = request->AccessRequested() & nsICache::ACCESS_WRITE;
43113:         NS_ASSERTION(*accessGranted, "new cache entry for READ-ONLY request");
43113:         PR_APPEND_LINK(request, &mRequestQ);
43113:         return rv;
43113:     }
43113: 
43113:     if (IsStreamData() != request->IsStreamBased()) {
43113:         *accessGranted = nsICache::ACCESS_NONE;
43113:         return request->IsStreamBased() ?
43113:             NS_ERROR_CACHE_DATA_IS_NOT_STREAM : NS_ERROR_CACHE_DATA_IS_STREAM;
43113:     }
43113: 
43113:     if (PR_CLIST_IS_EMPTY(&mDescriptorQ)) {
43113:         // 1st descriptor for existing bound entry
43113:         *accessGranted = request->AccessRequested();
43113:         if (*accessGranted & nsICache::ACCESS_WRITE) {
43113:             MarkInvalid();
43113:         } else {
43113:             MarkValid();
43113:         }
43113:     } else {
43113:         // nth request for existing, bound entry
43113:         *accessGranted = request->AccessRequested() & ~nsICache::ACCESS_WRITE;
43113:         if (!IsValid())
43113:             rv = NS_ERROR_CACHE_WAIT_FOR_VALIDATION;
43113:     }
43113:     PR_APPEND_LINK(request,&mRequestQ);
43113: 
43113:     return rv;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheEntry::CreateDescriptor(nsCacheRequest *           request,
43113:                                nsCacheAccessMode          accessGranted,
43113:                                nsICacheEntryDescriptor ** result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(request && result);
43113: 
43113:     nsCacheEntryDescriptor * descriptor =
43113:         new nsCacheEntryDescriptor(this, accessGranted);
43113: 
43113:     // XXX check request is on q
43113:     PR_REMOVE_AND_INIT_LINK(request); // remove request regardless of success
43113: 
43113:     if (descriptor == nsnull)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     PR_APPEND_LINK(descriptor, &mDescriptorQ);
43113: 
56468:     CACHE_LOG_DEBUG(("  descriptor %p created for request %p on entry %p\n",
56468:                     descriptor, request, this));
56468: 
43113:     NS_ADDREF(*result = descriptor);
43113:     return NS_OK;
43113: }
43113: 
43113: 
79445: bool
43113: nsCacheEntry::RemoveRequest(nsCacheRequest * request)
43113: {
43113:     // XXX if debug: verify this request belongs to this entry
43113:     PR_REMOVE_AND_INIT_LINK(request);
43113: 
43113:     // return true if this entry should stay active
43113:     return !((PR_CLIST_IS_EMPTY(&mRequestQ)) &&
43113:              (PR_CLIST_IS_EMPTY(&mDescriptorQ)));
43113: }
43113: 
43113: 
79445: bool
43113: nsCacheEntry::RemoveDescriptor(nsCacheEntryDescriptor * descriptor)
43113: {
43113:     NS_ASSERTION(descriptor->CacheEntry() == this, "### Wrong cache entry!!");
88288:     nsresult rv = descriptor->CloseOutput();
88288:     if (rv == NS_BASE_STREAM_WOULD_BLOCK)
88288:         return true;
88288: 
61410:     descriptor->ClearCacheEntry();
43113:     PR_REMOVE_AND_INIT_LINK(descriptor);
43113: 
88288:     // Doom entry if something bad happens while closing. See bug #673543
88288:     if (NS_FAILED(rv))
88288:         nsCacheService::DoomEntry(this);
88288: 
43113:     if (!PR_CLIST_IS_EMPTY(&mDescriptorQ))
80486:         return true;  // stay active if we still have open descriptors
43113: 
43113:     if (PR_CLIST_IS_EMPTY(&mRequestQ))
80486:         return false; // no descriptors or requests, we can deactivate
43113: 
80486:     return true;     // find next best request to give a descriptor to
43113: }
43113: 
43113: 
43113: void
43113: nsCacheEntry::DetachDescriptors(void)
43113: {
43113:     nsCacheEntryDescriptor * descriptor =
43113:         (nsCacheEntryDescriptor *)PR_LIST_HEAD(&mDescriptorQ);
43113: 
43113:     while (descriptor != &mDescriptorQ) {
43113:         nsCacheEntryDescriptor * nextDescriptor =
43113:             (nsCacheEntryDescriptor *)PR_NEXT_LINK(descriptor);
43113: 
88288:         // Doom entry if something bad happens while closing. See bug #673543
88288:         // Errors are handled different from RemoveDescriptor because this
88288:         // method is only called from ClearDoomList (in which case the entry is
88288:         // doomed anyway) and ClearActiveEntries (in which case we are shutting
88288:         // down and really want to get rid of the entry immediately)
88288:         if (NS_FAILED(descriptor->CloseOutput()))
88288:             nsCacheService::DoomEntry(this);
88288: 
43113:         descriptor->ClearCacheEntry();
43113:         PR_REMOVE_AND_INIT_LINK(descriptor);
43113:         descriptor = nextDescriptor;
43113:     }
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  * nsCacheEntryInfo - for implementing about:cache
43113:  *****************************************************************************/
43113: 
43113: NS_IMPL_ISUPPORTS1(nsCacheEntryInfo, nsICacheEntryInfo)
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryInfo::GetClientID(char ** clientID)
43113: {
43113:     NS_ENSURE_ARG_POINTER(clientID);
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     return ClientIDFromCacheKey(*mCacheEntry->Key(), clientID);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryInfo::GetDeviceID(char ** deviceID)
43113: {
43113:     NS_ENSURE_ARG_POINTER(deviceID);
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *deviceID = NS_strdup(mCacheEntry->GetDeviceID());
43113:     return *deviceID ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryInfo::GetKey(nsACString &key)
43113: {
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     return ClientKeyFromCacheKey(*mCacheEntry->Key(), key);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryInfo::GetFetchCount(PRInt32 * fetchCount)
43113: {
43113:     NS_ENSURE_ARG_POINTER(fetchCount);
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *fetchCount = mCacheEntry->FetchCount();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryInfo::GetLastFetched(PRUint32 * lastFetched)
43113: {
43113:     NS_ENSURE_ARG_POINTER(lastFetched);
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *lastFetched = mCacheEntry->LastFetched();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryInfo::GetLastModified(PRUint32 * lastModified)
43113: {
43113:     NS_ENSURE_ARG_POINTER(lastModified);
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *lastModified = mCacheEntry->LastModified();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryInfo::GetExpirationTime(PRUint32 * expirationTime)
43113: {
43113:     NS_ENSURE_ARG_POINTER(expirationTime);
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *expirationTime = mCacheEntry->ExpirationTime();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryInfo::GetDataSize(PRUint32 * dataSize)
43113: {
43113:     NS_ENSURE_ARG_POINTER(dataSize);
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *dataSize = mCacheEntry->DataSize();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
79445: nsCacheEntryInfo::IsStreamBased(bool * result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113:     
43113:     *result = mCacheEntry->IsStreamData();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  *  nsCacheEntryHashTable
43113:  *****************************************************************************/
43113: 
43113: PLDHashTableOps
43113: nsCacheEntryHashTable::ops =
43113: {
43113:     PL_DHashAllocTable,
43113:     PL_DHashFreeTable,
43113:     HashKey,
43113:     MatchEntry,
43113:     MoveEntry,
43113:     ClearEntry,
43113:     PL_DHashFinalizeStub
43113: };
43113: 
43113: 
43113: nsCacheEntryHashTable::nsCacheEntryHashTable()
80486:     : initialized(false)
43113: {
43113:     MOZ_COUNT_CTOR(nsCacheEntryHashTable);
43113: }
43113: 
43113: 
43113: nsCacheEntryHashTable::~nsCacheEntryHashTable()
43113: {
43113:     MOZ_COUNT_DTOR(nsCacheEntryHashTable);
43113:     if (initialized)
43113:         Shutdown();
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheEntryHashTable::Init()
43113: {
43113:     nsresult rv = NS_OK;
43113:     initialized = PL_DHashTableInit(&table, &ops, nsnull,
43113:                                            sizeof(nsCacheEntryHashTableEntry), 512);
43113: 
43113:     if (!initialized) rv = NS_ERROR_OUT_OF_MEMORY;
43113:     
43113:     return rv;
43113: }
43113: 
43113: void
43113: nsCacheEntryHashTable::Shutdown()
43113: {
43113:     if (initialized) {
43113:         PL_DHashTableFinish(&table);
80486:         initialized = false;
43113:     }
43113: }
43113: 
43113: 
43113: nsCacheEntry *
43113: nsCacheEntryHashTable::GetEntry( const nsCString * key)
43113: {
43113:     PLDHashEntryHdr *hashEntry;
43113:     nsCacheEntry    *result = nsnull;
43113: 
43113:     NS_ASSERTION(initialized, "nsCacheEntryHashTable not initialized");
43113:     if (!initialized)  return nsnull;
43113:     
43113:     hashEntry = PL_DHashTableOperate(&table, key, PL_DHASH_LOOKUP);
43113:     if (PL_DHASH_ENTRY_IS_BUSY(hashEntry)) {
43113:         result = ((nsCacheEntryHashTableEntry *)hashEntry)->cacheEntry;
43113:     }
43113:     return result;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheEntryHashTable::AddEntry( nsCacheEntry *cacheEntry)
43113: {
43113:     PLDHashEntryHdr    *hashEntry;
43113: 
43113:     NS_ASSERTION(initialized, "nsCacheEntryHashTable not initialized");
43113:     if (!initialized)  return NS_ERROR_NOT_INITIALIZED;
43113:     if (!cacheEntry)   return NS_ERROR_NULL_POINTER;
43113: 
43113:     hashEntry = PL_DHashTableOperate(&table, cacheEntry->mKey, PL_DHASH_ADD);
43113: #ifndef DEBUG_dougt
43113:     NS_ASSERTION(((nsCacheEntryHashTableEntry *)hashEntry)->cacheEntry == 0,
43113:                  "### nsCacheEntryHashTable::AddEntry - entry already used");
43113: #endif
43113:     ((nsCacheEntryHashTableEntry *)hashEntry)->cacheEntry = cacheEntry;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheEntryHashTable::RemoveEntry( nsCacheEntry *cacheEntry)
43113: {
43113:     NS_ASSERTION(initialized, "nsCacheEntryHashTable not initialized");
43113:     NS_ASSERTION(cacheEntry, "### cacheEntry == nsnull");
43113: 
43113:     if (!initialized)  return; // NS_ERROR_NOT_INITIALIZED
43113: 
43113: #if DEBUG
43113:     // XXX debug code to make sure we have the entry we're trying to remove
43113:     nsCacheEntry *check = GetEntry(cacheEntry->mKey);
43113:     NS_ASSERTION(check == cacheEntry, "### Attempting to remove unknown cache entry!!!");
43113: #endif
43113:     (void) PL_DHashTableOperate(&table, cacheEntry->mKey, PL_DHASH_REMOVE);
43113: }
43113: 
43113: 
43113: void
43113: nsCacheEntryHashTable::VisitEntries( PLDHashEnumerator etor, void *arg)
43113: {
43113:     NS_ASSERTION(initialized, "nsCacheEntryHashTable not initialized");
43113:     if (!initialized)  return; // NS_ERROR_NOT_INITIALIZED
43113:     PL_DHashTableEnumerate(&table, etor, arg);
43113: }
43113: 
43113: 
43113: /**
43113:  *  hash table operation callback functions
43113:  */
43113: 
43113: PLDHashNumber
43113: nsCacheEntryHashTable::HashKey( PLDHashTable *table, const void *key)
43113: {
43113:     return PL_DHashStringKey(table,((nsCString *)key)->get());
43113: }
43113: 
79445: bool
43113: nsCacheEntryHashTable::MatchEntry(PLDHashTable *       /* table */,
43113:                                   const PLDHashEntryHdr * hashEntry,
43113:                                   const void *            key)
43113: {
43113:     NS_ASSERTION(key !=  nsnull, "### nsCacheEntryHashTable::MatchEntry : null key");
43113:     nsCacheEntry *cacheEntry = ((nsCacheEntryHashTableEntry *)hashEntry)->cacheEntry;
43113: 
43113:     return cacheEntry->mKey->Equals(*(nsCString *)key);
43113: }
43113: 
43113: 
43113: void
43113: nsCacheEntryHashTable::MoveEntry(PLDHashTable * /* table */,
43113:                                  const PLDHashEntryHdr *from,
43113:                                  PLDHashEntryHdr       *to)
43113: {
43113:     ((nsCacheEntryHashTableEntry *)to)->cacheEntry =
43113:         ((nsCacheEntryHashTableEntry *)from)->cacheEntry;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheEntryHashTable::ClearEntry(PLDHashTable * /* table */,
43113:                                   PLDHashEntryHdr * hashEntry)
43113: {
43113:     ((nsCacheEntryHashTableEntry *)hashEntry)->cacheEntry = 0;
43113: }
