15273: /*
15273:  * NSS utility functions
15273:  *
15273:  * ***** BEGIN LICENSE BLOCK *****
15273:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
15273:  *
15273:  * The contents of this file are subject to the Mozilla Public License Version
15273:  * 1.1 (the "License"); you may not use this file except in compliance with
15273:  * the License. You may obtain a copy of the License at
15273:  * http://www.mozilla.org/MPL/
15273:  *
15273:  * Software distributed under the License is distributed on an "AS IS" basis,
15273:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
15273:  * for the specific language governing rights and limitations under the
15273:  * License.
15273:  *
15273:  * The Original Code is the Netscape security libraries.
15273:  *
15273:  * The Initial Developer of the Original Code is
15273:  * Netscape Communications Corporation.
15273:  * Portions created by the Initial Developer are Copyright (C) 1994-2000
15273:  * the Initial Developer. All Rights Reserved.
15273:  *
15273:  * Contributor(s):
15273:  *
15273:  * Alternatively, the contents of this file may be used under the terms of
15273:  * either the GNU General Public License Version 2 or later (the "GPL"), or
15273:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
15273:  * in which case the provisions of the GPL or the LGPL are applicable instead
15273:  * of those above. If you wish to allow use of your version of this file only
15273:  * under the terms of either the GPL or the LGPL, and not to allow others to
15273:  * use your version of this file under the terms of the MPL, indicate your
15273:  * decision by deleting the provisions above and replace them with the notice
15273:  * and other provisions required by the GPL or the LGPL. If you do not delete
15273:  * the provisions above, a recipient may use your version of this file under
15273:  * the terms of any one of the MPL, the GPL or the LGPL.
15273:  *
15273:  * ***** END LICENSE BLOCK ***** */
80630: /* $Id: nssinit.c,v 1.114 2011/10/18 19:03:31 wtc%google.com Exp $ */
15273: 
15273: #include <ctype.h>
30806: #include <string.h>
15273: #include "seccomon.h"
76874: #include "prerror.h"
15273: #include "prinit.h"
15273: #include "prprf.h"
15273: #include "prmem.h"
76874: #include "prtypes.h"
15273: #include "cert.h"
15273: #include "key.h"
15273: #include "secmod.h"
15273: #include "secoid.h"
15273: #include "nss.h"
15273: #include "pk11func.h"
15273: #include "secerr.h"
15273: #include "nssbase.h"
76874: #include "nssutil.h"
15273: #include "pkixt.h"
15273: #include "pkix.h"
15273: #include "pkix_tools.h"
15273: 
15273: #include "pki3hack.h"
15273: #include "certi.h"
15273: #include "secmodi.h"
15273: #include "ocspti.h"
15273: #include "ocspi.h"
15273: 
15273: /*
15273:  * On Windows nss3.dll needs to export the symbol 'mktemp' to be
15273:  * fully backward compatible with the nss3.dll in NSS 3.2.x and
15273:  * 3.3.x.  This symbol was unintentionally exported and its
15273:  * definition (in DBM) was moved from nss3.dll to softokn3.dll
15273:  * in NSS 3.4.  See bug 142575.
15273:  */
15273: #ifdef WIN32_NSS3_DLL_COMPAT
15273: #include <io.h>
15273: 
15273: /* exported as 'mktemp' */
15273: char *
15273: nss_mktemp(char *path)
15273: {
15273:     return _mktemp(path);
15273: }
15273: #endif
15273: 
15273: #define NSS_MAX_FLAG_SIZE  sizeof("readOnly")+sizeof("noCertDB")+ \
15273: 	sizeof("noModDB")+sizeof("forceOpen")+sizeof("passwordRequired")+ \
15273: 	sizeof ("optimizeSpace")
15273: #define NSS_DEFAULT_MOD_NAME "NSS Internal Module"
15273: 
15273: static char *
15273: nss_makeFlags(PRBool readOnly, PRBool noCertDB, 
15273: 				PRBool noModDB, PRBool forceOpen, 
15273: 				PRBool passwordRequired, PRBool optimizeSpace) 
15273: {
15273:     char *flags = (char *)PORT_Alloc(NSS_MAX_FLAG_SIZE);
15273:     PRBool first = PR_TRUE;
15273: 
15273:     PORT_Memset(flags,0,NSS_MAX_FLAG_SIZE);
15273:     if (readOnly) {
15273:         PORT_Strcat(flags,"readOnly");
15273:         first = PR_FALSE;
15273:     }
15273:     if (noCertDB) {
15273:         if (!first) PORT_Strcat(flags,",");
15273:         PORT_Strcat(flags,"noCertDB");
15273:         first = PR_FALSE;
15273:     }
15273:     if (noModDB) {
15273:         if (!first) PORT_Strcat(flags,",");
15273:         PORT_Strcat(flags,"noModDB");
15273:         first = PR_FALSE;
15273:     }
15273:     if (forceOpen) {
15273:         if (!first) PORT_Strcat(flags,",");
15273:         PORT_Strcat(flags,"forceOpen");
15273:         first = PR_FALSE;
15273:     }
15273:     if (passwordRequired) {
15273:         if (!first) PORT_Strcat(flags,",");
15273:         PORT_Strcat(flags,"passwordRequired");
15273:         first = PR_FALSE;
15273:     }
15273:     if (optimizeSpace) {
15273:         if (!first) PORT_Strcat(flags,",");
15273:         PORT_Strcat(flags,"optimizeSpace");
15273:         first = PR_FALSE;
15273:     }
15273:     return flags;
15273: }
15273: 
37961: 
37961: /*
37961:  * build config string from individual internationalized strings
37961:  */
37961: char *
37961: nss_MkConfigString(const char *man, const char *libdesc, const char *tokdesc,
37961: 	const char *ptokdesc, const char *slotdesc, const char *pslotdesc, 
37961: 	const char *fslotdesc, const char *fpslotdesc, int minPwd)
37961: {
37961:     char *strings = NULL;
37961:     char *newStrings;
37961: 
37961:     /* make sure the internationalization was done correctly... */
37961:     strings = PR_smprintf("");
37961:     if (strings == NULL) return NULL;
37961: 
37961:     if (man) {
37961:         newStrings = PR_smprintf("%s manufacturerID='%s'",strings,man);
37961: 	PR_smprintf_free(strings);
37961: 	strings = newStrings;
37961:     }
37961:     if (strings == NULL) return NULL;
37961: 
37961:     if (libdesc) {
37961:         newStrings = PR_smprintf("%s libraryDescription='%s'",strings,libdesc);
37961: 	PR_smprintf_free(strings);
37961: 	strings = newStrings;
37961:     }
37961:     if (strings == NULL) return NULL;
37961: 
37961:     if (tokdesc) {
37961:         newStrings = PR_smprintf("%s cryptoTokenDescription='%s'",strings,
37961: 								tokdesc);
37961: 	PR_smprintf_free(strings);
37961: 	strings = newStrings;
37961:     }
37961:     if (strings == NULL) return NULL;
37961: 
37961:     if (ptokdesc) {
37961:         newStrings = PR_smprintf("%s dbTokenDescription='%s'",strings,ptokdesc);
37961: 	PR_smprintf_free(strings);
37961: 	strings = newStrings;
37961:     }
37961:     if (strings == NULL) return NULL;
37961: 
37961:     if (slotdesc) {
37961:         newStrings = PR_smprintf("%s cryptoSlotDescription='%s'",strings,
37961: 								slotdesc);
37961: 	PR_smprintf_free(strings);
37961: 	strings = newStrings;
37961:     }
37961:     if (strings == NULL) return NULL;
37961: 
37961:     if (pslotdesc) {
37961:         newStrings = PR_smprintf("%s dbSlotDescription='%s'",strings,pslotdesc);
37961: 	PR_smprintf_free(strings);
37961: 	strings = newStrings;
37961:     }
37961:     if (strings == NULL) return NULL;
37961: 
37961:     if (fslotdesc) {
37961:         newStrings = PR_smprintf("%s FIPSSlotDescription='%s'",
37961: 							strings,fslotdesc);
37961: 	PR_smprintf_free(strings);
37961: 	strings = newStrings;
37961:     }
37961:     if (strings == NULL) return NULL;
37961: 
37961:     if (fpslotdesc) {
37961:         newStrings = PR_smprintf("%s FIPSTokenDescription='%s'",
37961: 							strings,fpslotdesc);
37961: 	PR_smprintf_free(strings);
37961: 	strings = newStrings;
37961:     }
37961:     if (strings == NULL) return NULL;
37961: 
37961:     newStrings = PR_smprintf("%s minPS=%d", strings, minPwd);
37961:     PR_smprintf_free(strings);
37961:     strings = newStrings;
37961: 
37961:     return(strings);
37961: }
37961: 
15273: /*
15273:  * statics to remember the PK11_ConfigurePKCS11()
15273:  * info.
15273:  */
15273: static char * pk11_config_strings = NULL;
15273: static char * pk11_config_name = NULL;
15273: static PRBool pk11_password_required = PR_FALSE;
15273: 
15273: /*
15273:  * this is a legacy configuration function which used to be part of
15273:  * the PKCS #11 internal token.
15273:  */
15273: void
37961: PK11_ConfigurePKCS11(const char *man, const char *libdesc, const char *tokdesc,
37961: 	const char *ptokdesc, const char *slotdesc, const char *pslotdesc, 
37961: 	const char *fslotdesc, const char *fpslotdesc, int minPwd, 
37961: 	int pwRequired)
15273: {
37961:     char * strings;
15273: 
37961:     strings = nss_MkConfigString(man,libdesc,tokdesc,ptokdesc,slotdesc,
37961: 	pslotdesc,fslotdesc,fpslotdesc,minPwd);
37961:     if (strings == NULL) {
37961: 	return;
37961:     }
15273: 
37961:     if (libdesc) {
15273: 	if (pk11_config_name != NULL) {
15273: 	    PORT_Free(pk11_config_name);
15273: 	}
37961: 	pk11_config_name = PORT_Strdup(libdesc);
15273:     }
15273: 
15273:     if (pk11_config_strings != NULL) {
15273: 	PR_smprintf_free(pk11_config_strings);
15273:     }
15273:     pk11_config_strings = strings;
15273:     pk11_password_required = pwRequired;
15273: 
15273:     return;
15273: }
15273: 
15273: void PK11_UnconfigurePKCS11(void)
15273: {
15273:     if (pk11_config_strings != NULL) {
15273: 	PR_smprintf_free(pk11_config_strings);
15273:         pk11_config_strings = NULL;
15273:     }
15273:     if (pk11_config_name) {
15273:         PORT_Free(pk11_config_name);
15273:         pk11_config_name = NULL;
15273:     }
15273: }
15273: 
15273: /*
15273:  * The following code is an attempt to automagically find the external root
20768:  * module.
15273:  * Note: Keep the #if-defined chunks in order. HPUX must select before UNIX.
15273:  */
15273: 
15273: static const char *dllname =
15273: #if defined(XP_WIN32) || defined(XP_OS2)
15273: 	"nssckbi.dll";
15273: #elif defined(HPUX) && !defined(__ia64)  /* HP-UX PA-RISC */
15273: 	"libnssckbi.sl";
15273: #elif defined(DARWIN)
15273: 	"libnssckbi.dylib";
15273: #elif defined(XP_UNIX) || defined(XP_BEOS)
15273: 	"libnssckbi.so";
15273: #else
15273: 	#error "Uh! Oh! I don't know about this platform."
15273: #endif
15273: 
15273: /* Should we have platform ifdefs here??? */
15273: #define FILE_SEP '/'
15273: 
15273: static void nss_FindExternalRootPaths(const char *dbpath, 
15273:                                       const char* secmodprefix,
15273:                               char** retoldpath, char** retnewpath)
15273: {
15273:     char *path, *oldpath = NULL, *lastsep;
15273:     int len, path_len, secmod_len, dll_len;
15273: 
15273:     path_len = PORT_Strlen(dbpath);
15273:     secmod_len = secmodprefix ? PORT_Strlen(secmodprefix) : 0;
15273:     dll_len = PORT_Strlen(dllname);
15273:     len = path_len + secmod_len + dll_len + 2; /* FILE_SEP + NULL */
15273: 
15273:     path = PORT_Alloc(len);
15273:     if (path == NULL) return;
15273: 
15273:     /* back up to the top of the directory */
15273:     PORT_Memcpy(path,dbpath,path_len);
15273:     if (path[path_len-1] != FILE_SEP) {
15273:         path[path_len++] = FILE_SEP;
15273:     }
15273:     PORT_Strcpy(&path[path_len],dllname);
15273:     if (secmod_len > 0) {
15273:         lastsep = PORT_Strrchr(secmodprefix, FILE_SEP);
15273:         if (lastsep) {
15273:             int secmoddir_len = lastsep-secmodprefix+1; /* FILE_SEP */
15273:             oldpath = PORT_Alloc(len);
15273:             if (oldpath == NULL) {
15273:                 PORT_Free(path);
15273:                 return;
15273:             }
15273:             PORT_Memcpy(oldpath,path,path_len);
15273:             PORT_Memcpy(&oldpath[path_len],secmodprefix,secmoddir_len);
15273:             PORT_Strcpy(&oldpath[path_len+secmoddir_len],dllname);
15273:         }
15273:     }
15273:     *retoldpath = oldpath;
15273:     *retnewpath = path;
15273:     return;
15273: }
15273: 
15273: static void nss_FreeExternalRootPaths(char* oldpath, char* path)
15273: {
15273:     if (path) {
15273:         PORT_Free(path);
15273:     }
15273:     if (oldpath) {
15273:         PORT_Free(oldpath);
15273:     }
15273: }
15273: 
15273: static void
15273: nss_FindExternalRoot(const char *dbpath, const char* secmodprefix)
15273: {
15273: 	char *path = NULL;
15273:         char *oldpath = NULL;
15273:         PRBool hasrootcerts = PR_FALSE;
15273: 
15273:         /*
15273:          * 'oldpath' is the external root path in NSS 3.3.x or older.
15273:          * For backward compatibility we try to load the root certs
15273:          * module with the old path first.
15273:          */
15273:         nss_FindExternalRootPaths(dbpath, secmodprefix, &oldpath, &path);
15273:         if (oldpath) {
15273:             (void) SECMOD_AddNewModule("Root Certs",oldpath, 0, 0);
15273:             hasrootcerts = SECMOD_HasRootCerts();
15273:         }
15273:         if (path && !hasrootcerts) {
15273: 	    (void) SECMOD_AddNewModule("Root Certs",path, 0, 0);
15273:         }
15273:         nss_FreeExternalRootPaths(oldpath, path);
15273: 	return;
15273: }
15273: 
15273: /*
37961:  * see nss_Init for definitions of the various options.
15273:  *
37961:  * this function builds a moduleSpec string from the options and previously
37961:  * set statics (from PKCS11_Configure, for instance), and uses it to kick off
37961:  * the loading of the various PKCS #11 modules.
15273:  */
15273: static SECStatus
37961: nss_InitModules(const char *configdir, const char *certPrefix, 
37961: 		const char *keyPrefix, const char *secmodName, 
37961: 		const char *updateDir, const char *updCertPrefix, 
37961: 		const char *updKeyPrefix, const char *updateID, 
37961: 		const char *updateName, char *configName, char *configStrings,
37961: 		PRBool pwRequired, PRBool readOnly, PRBool noCertDB,
37961: 		PRBool noModDB, PRBool forceOpen, PRBool optimizeSpace,
37961: 		PRBool isContextInit)
15273: {
37961:     SECStatus rv = SECFailure;
15273:     char *moduleSpec = NULL;
15273:     char *flags = NULL;
15273:     char *lconfigdir = NULL;
15273:     char *lcertPrefix = NULL;
15273:     char *lkeyPrefix = NULL;
15273:     char *lsecmodName = NULL;
15273:     char *lupdateDir = NULL;
15273:     char *lupdCertPrefix = NULL;
15273:     char *lupdKeyPrefix = NULL;
15273:     char *lupdateID = NULL;
15273:     char *lupdateName = NULL;
15273: 
79996:     if (NSS_InitializePRErrorTable() != SECSuccess) {
79996: 	PORT_SetError(SEC_ERROR_NO_MEMORY);
79996: 	return rv;
76874:     }
76874: 
15273:     flags = nss_makeFlags(readOnly,noCertDB,noModDB,forceOpen,
37961: 					pwRequired, optimizeSpace);
15273:     if (flags == NULL) return rv;
15273: 
15273:     /*
15273:      * configdir is double nested, and Windows uses the same character
15273:      * for file seps as we use for escapes! (sigh).
15273:      */
37961:     lconfigdir = secmod_DoubleEscape(configdir, '\'', '\"');
15273:     if (lconfigdir == NULL) {
15273: 	goto loser;
15273:     }
37961:     lcertPrefix = secmod_DoubleEscape(certPrefix, '\'', '\"');
15273:     if (lcertPrefix == NULL) {
15273: 	goto loser;
15273:     }
37961:     lkeyPrefix = secmod_DoubleEscape(keyPrefix, '\'', '\"');
15273:     if (lkeyPrefix == NULL) {
15273: 	goto loser;
15273:     }
37961:     lsecmodName = secmod_DoubleEscape(secmodName, '\'', '\"');
15273:     if (lsecmodName == NULL) {
15273: 	goto loser;
15273:     }
37961:     lupdateDir = secmod_DoubleEscape(updateDir, '\'', '\"');
15273:     if (lupdateDir == NULL) {
15273: 	goto loser;
15273:     }
37961:     lupdCertPrefix = secmod_DoubleEscape(updCertPrefix, '\'', '\"');
15273:     if (lupdCertPrefix == NULL) {
15273: 	goto loser;
15273:     }
37961:     lupdKeyPrefix = secmod_DoubleEscape(updKeyPrefix, '\'', '\"');
15273:     if (lupdKeyPrefix == NULL) {
15273: 	goto loser;
15273:     }
37961:     lupdateID = secmod_DoubleEscape(updateID, '\'', '\"');
15273:     if (lupdateID == NULL) {
15273: 	goto loser;
15273:     }
37961:     lupdateName = secmod_DoubleEscape(updateName, '\'', '\"');
15273:     if (lupdateName == NULL) {
15273: 	goto loser;
15273:     }
15273: 
15273:     moduleSpec = PR_smprintf(
15273:      "name=\"%s\" parameters=\"configdir='%s' certPrefix='%s' keyPrefix='%s' "
15273:      "secmod='%s' flags=%s updatedir='%s' updateCertPrefix='%s' "
15273:      "updateKeyPrefix='%s' updateid='%s' updateTokenDescription='%s' %s\" "
37961:      "NSS=\"flags=internal,moduleDB,moduleDBOnly,critical%s\"",
37961: 		configName ? configName : NSS_DEFAULT_MOD_NAME,
15273: 		lconfigdir,lcertPrefix,lkeyPrefix,lsecmodName,flags,
15273: 		lupdateDir, lupdCertPrefix, lupdKeyPrefix, lupdateID, 
37961: 		lupdateName, configStrings ? configStrings : "",
37961: 		isContextInit ? "" : ",defaultModDB,internalKeySlot");
15273: 
15273: loser:
15273:     PORT_Free(flags);
15273:     if (lconfigdir) PORT_Free(lconfigdir);
15273:     if (lcertPrefix) PORT_Free(lcertPrefix);
15273:     if (lkeyPrefix) PORT_Free(lkeyPrefix);
15273:     if (lsecmodName) PORT_Free(lsecmodName);
15273:     if (lupdateDir) PORT_Free(lupdateDir);
15273:     if (lupdCertPrefix) PORT_Free(lupdCertPrefix);
15273:     if (lupdKeyPrefix) PORT_Free(lupdKeyPrefix);
15273:     if (lupdateID) PORT_Free(lupdateID);
15273:     if (lupdateName) PORT_Free(lupdateName);
15273: 
15273:     if (moduleSpec) {
15273: 	SECMODModule *module = SECMOD_LoadModule(moduleSpec,NULL,PR_TRUE);
15273: 	PR_smprintf_free(moduleSpec);
15273: 	if (module) {
15273: 	    if (module->loaded) rv=SECSuccess;
15273: 	    SECMOD_DestroyModule(module);
15273: 	}
15273:     }
37961:     return rv;
37961: }
15273: 
37961: /*
37961:  * OK there are now lots of options here, lets go through them all:
37961:  *
37961:  * configdir - base directory where all the cert, key, and module datbases live.
37961:  * certPrefix - prefix added to the beginning of the cert database example: "
37961:  * 			"https-server1-"
37961:  * keyPrefix - prefix added to the beginning of the key database example: "
37961:  * 			"https-server1-"
37961:  * secmodName - name of the security module database (usually "secmod.db").
37961:  * updateDir - used in initMerge, old directory to update from.
37961:  * updateID - used in initMerge, unique ID to represent the updated directory.
37961:  * updateName - used in initMerge, token name when updating.
37961:  * initContextPtr -  used in initContext, pointer to return a unique context
37961:  *            value.
37961:  * readOnly - Boolean: true if the databases are to be opened read only.
37961:  * nocertdb - Don't open the cert DB and key DB's, just initialize the 
37961:  *			Volatile certdb.
37961:  * nomoddb - Don't open the security module DB, just initialize the 
37961:  *			PKCS #11 module.
37961:  * forceOpen - Continue to force initializations even if the databases cannot
37961:  * 			be opened.
37961:  * noRootInit - don't try to automatically load the root cert store if one is
37961:  *           not found.
37961:  * optimizeSpace - tell NSS to use fewer hash table buckets.
37961:  *
37961:  * The next three options are used in an attempt to share PKCS #11 modules
37961:  * with other loaded, running libraries. PKCS #11 was not designed with this
37961:  * sort of sharing in mind, so use of these options may lead to questionable
37961:  * results. These options are may be incompatible with NSS_LoadContext() calls.
37961:  *
37961:  * noSingleThreadedModules - don't load modules that are not thread safe (many
37961:  *           smart card tokens will not work).
37961:  * allowAlreadyInitializedModules - if a module has already been loaded and
37961:  *           initialize try to use it.
37961:  * don'tFinalizeModules -  dont shutdown modules we may have loaded.
37961:  */
37961: 
37961: static PRBool          nssIsInitted = PR_FALSE;
37961: static NSSInitContext *nssInitContextList = NULL;
37961: static void*           plContext = NULL;
37961: 
37961: struct NSSInitContextStr {
37961:     NSSInitContext *next;
37961:     PRUint32 magic;
37961: };
37961: 
37961: #define NSS_INIT_MAGIC 0x1413A91C
37961: static SECStatus nss_InitShutdownList(void);
37961: 
37961: #ifdef DEBUG
37961: static CERTCertificate dummyCert;
37961: #endif
37961: 
79996: /* All initialized to zero in BSS */
79996: static PRCallOnceType nssInitOnce;
79996: static PZLock *nssInitLock;
79996: static PZCondVar *nssInitCondition;
79996: static int nssIsInInit;
79996: 
79996: static PRStatus
79996: nss_doLockInit(void)
79996: {
79996:     nssInitLock = PZ_NewLock(nssILockOther);
79996:     if (nssInitLock == NULL) {
80630: 	return PR_FAILURE;
79996:     }
79996:     nssInitCondition = PZ_NewCondVar(nssInitLock);
79996:     if (nssInitCondition == NULL) {
80630: 	return PR_FAILURE;
79996:     }
80630:     return PR_SUCCESS;
79996: }
79996: 
79996: 
37961: static SECStatus
37961: nss_Init(const char *configdir, const char *certPrefix, const char *keyPrefix,
37961: 		 const char *secmodName, const char *updateDir, 
37961: 		 const char *updCertPrefix, const char *updKeyPrefix,
37961: 		 const char *updateID, const char *updateName,
37961: 		 NSSInitContext ** initContextPtr,
37961: 		 NSSInitParameters *initParams,
37961: 		 PRBool readOnly, PRBool noCertDB, 
37961: 		 PRBool noModDB, PRBool forceOpen, PRBool noRootInit,
37961: 		 PRBool optimizeSpace, PRBool noSingleThreadedModules,
37961: 		 PRBool allowAlreadyInitializedModules,
37961: 		 PRBool dontFinalizeModules)
37961: {
37961:     SECStatus rv = SECFailure;
37961:     PKIX_UInt32 actualMinorVersion = 0;
37961:     PKIX_Error *pkixError = NULL;
37961:     PRBool isReallyInitted;
37961:     char *configStrings = NULL;
37961:     char *configName = NULL;
37961:     PRBool passwordRequired = PR_FALSE;
37961: 
37961:     /* if we are trying to init with a traditional NSS_Init call, maintain
37961:      * the traditional idempotent behavior. */
37961:     if (!initContextPtr && nssIsInitted) {
37961: 	return SECSuccess;
37961:     }
37961:   
80630:     /* make sure our lock and condition variable are initialized one and only
80630:      * one time */ 
80630:     if (PR_CallOnce(&nssInitOnce, nss_doLockInit) != PR_SUCCESS) {
80630: 	return SECFailure;
79996:     }
79996: 
79996:     /*
79996:      * if we haven't done basic initialization, single thread the 
79996:      * initializations.
79996:      */
79996:     PZ_Lock(nssInitLock);
79996:     isReallyInitted = NSS_IsInitialized();
79996:     if (!isReallyInitted) {
79996: 	while (!isReallyInitted && nssIsInInit) {
79996: 	    PZ_WaitCondVar(nssInitCondition,PR_INTERVAL_NO_TIMEOUT);
79996: 	    isReallyInitted = NSS_IsInitialized();
79996:  	}
79996: 	/* once we've completed basic initialization, we can allow more than 
79996: 	 * one process initialize NSS at a time. */
79996:     }
79996:     nssIsInInit++;
79996:     PZ_Unlock(nssInitLock);
79996: 
37961:     /* this tells us whether or not some library has already initialized us.
37961:      * if so, we don't want to double call some of the basic initialization
37961:      * functions */
37961: 
37961:     if (!isReallyInitted) {
37961: 	/* New option bits must not change the size of CERTCertificate. */
37961: 	PORT_Assert(sizeof(dummyCert.options) == sizeof(void *));
37961: 
37961: 	if (SECSuccess != cert_InitLocks()) {
79996: 	    goto loser;
15273: 	}
37961: 
37961: 	if (SECSuccess != InitCRLCache()) {
79996: 	    goto loser;
15273: 	}
37961:     
37961: 	if (SECSuccess != OCSP_InitGlobal()) {
79996: 	    goto loser;
37961: 	}
37961:     }
37961: 
37961:     if (noSingleThreadedModules || allowAlreadyInitializedModules ||
37961:         dontFinalizeModules) {
37961:         pk11_setGlobalOptions(noSingleThreadedModules,
37961:                               allowAlreadyInitializedModules,
37961:                               dontFinalizeModules);
37961:     }
37961: 
37961:     if (initContextPtr) {
37961: 	*initContextPtr = PORT_ZNew(NSSInitContext);
37961: 	if (*initContextPtr == NULL) {
47913: 	    goto loser;
37961: 	}
37961: 	/*
37961: 	 * For traditional NSS_Init, we used the PK11_Configure() call to set
37961: 	 * globals. with InitContext, we pass those strings in as parameters.
37961: 	 *
37961: 	 * This allows old NSS_Init calls to work as before, while at the same
37961: 	 * time new calls and old calls will not interfere with each other.
37961: 	 */
37961:         if (initParams) {
37961: 	    if (initParams->length < sizeof(NSSInitParameters)) {
37961: 		PORT_SetError(SEC_ERROR_INVALID_ARGS);
47913: 		goto loser;
37961: 	    }
37961: 	    configStrings = nss_MkConfigString(initParams->manufactureID,
37961: 		initParams->libraryDescription,
37961: 		initParams->cryptoTokenDescription,
37961: 		initParams->dbTokenDescription,
37961: 		initParams->cryptoSlotDescription,
37961: 		initParams->dbSlotDescription,
37961: 		initParams->FIPSSlotDescription,
37961: 		initParams->FIPSTokenDescription,
37961: 		initParams->minPWLen);
37961: 	    if (configStrings == NULL) {
37961: 		PORT_SetError(SEC_ERROR_NO_MEMORY);
47913: 		goto loser;
37961: 	    }
37961: 	    configName = initParams->libraryDescription;
37961: 	    passwordRequired = initParams->passwordRequired;
37961: 	}
37961:     } else {
37961: 	configStrings = pk11_config_strings;
37961: 	configName = pk11_config_name;
37961: 	passwordRequired = pk11_password_required;
37961:     }
37961: 
37961:     /* we always try to initialize the modules */
37961:     rv = nss_InitModules(configdir, certPrefix, keyPrefix, secmodName, 
37961: 		updateDir, updCertPrefix, updKeyPrefix, updateID, 
37961: 		updateName, configName, configStrings, passwordRequired,
37961: 		readOnly, noCertDB, noModDB, forceOpen, optimizeSpace, 
37961: 		(initContextPtr != NULL));
37961: 
37961:     if (rv != SECSuccess) {
37961: 	goto loser;
37961:     }
37961: 
37961: 
37961:     /* finish up initialization */
37961:     if (!isReallyInitted) {
37961: 	if (SECOID_Init() != SECSuccess) {
37961: 	    goto loser;
37961: 	}
37961: 	if (STAN_LoadDefaultNSS3TrustDomain() != PR_SUCCESS) {
37961: 	    goto loser;
37961: 	}
15273: 	if (nss_InitShutdownList() != SECSuccess) {
37961: 	    goto loser;
15273: 	}
15273: 	CERT_SetDefaultCertDB((CERTCertDBHandle *)
15273: 				STAN_GetDefaultTrustDomain());
15273: 	if ((!noModDB) && (!noCertDB) && (!noRootInit)) {
15273: 	    if (!SECMOD_HasRootCerts()) {
30806: 		const char *dbpath = configdir;
37961: 		/* handle supported database modifiers */
30806: 		if (strncmp(dbpath, "sql:", 4) == 0) {
30806: 		    dbpath += 4;
37961: 		} else if(strncmp(dbpath, "dbm:", 4) == 0) {
37961: 		    dbpath += 4;
37961: 		} else if(strncmp(dbpath, "extern:", 7) == 0) {
37961: 		    dbpath += 7;
37961: 		} else if(strncmp(dbpath, "rdb:", 4) == 0) {
37961: 		    /* if rdb: is specified, the configdir isn't really a 
37961: 		     * path. Skip it */
37961: 		    dbpath = NULL;
30806: 		}
37961: 		if (dbpath) {
30806: 		    nss_FindExternalRoot(dbpath, secmodName);
15273: 		}
15273: 	    }
37961: 	}
37961: 
15273: 	pk11sdr_Init();
15273: 	cert_CreateSubjectKeyIDHashTable();
15273: 
15273: 	pkixError = PKIX_Initialize
15273: 	    (PKIX_FALSE, PKIX_MAJOR_VERSION, PKIX_MINOR_VERSION,
15273: 	    PKIX_MINOR_VERSION, &actualMinorVersion, &plContext);
15273: 
15273: 	if (pkixError != NULL) {
37961: 	    goto loser;
15273: 	} else {
15273:             char *ev = getenv("NSS_ENABLE_PKIX_VERIFY");
15273:             if (ev && ev[0]) {
15273:                 CERT_SetUsePKIXForValidation(PR_TRUE);
15273:             }
15273:         }
37961: 
37961: 
15273:     }
15273: 
37961:     /*
37961:      * Now mark the appropriate init state. If initContextPtr was passed
37961:      * in, then return the new context pointer and add it to the
37961:      * nssInitContextList. Otherwise set the global nss_isInitted flag
37961:      */
79996:     PZ_Lock(nssInitLock);
37961:     if (!initContextPtr) {
37961: 	nssIsInitted = PR_TRUE;
37961:     } else {
37961: 	(*initContextPtr)->magic = NSS_INIT_MAGIC;
37961: 	(*initContextPtr)->next = nssInitContextList;
37961: 	nssInitContextList = (*initContextPtr);
37961:     }
79996:     nssIsInInit--;
79996:     /* now that we are inited, all waiters can move forward */
79996:     PZ_NotifyAllCondVar(nssInitCondition);
79996:     PZ_Unlock(nssInitLock);
37961: 
37961:     return SECSuccess;
37961: 
37961: loser:
37961:     if (initContextPtr && *initContextPtr) {
37961: 	PORT_Free(*initContextPtr);
37961: 	*initContextPtr = NULL;
37961: 	if (configStrings) {
37961: 	   PR_smprintf_free(configStrings);
37961: 	}
37961:     }
80630:     PZ_Lock(nssInitLock);
80630:     nssIsInInit--;
80630:     /* We failed to init, allow one to move forward */
80630:     PZ_NotifyCondVar(nssInitCondition);
80630:     PZ_Unlock(nssInitLock);
37961:     return SECFailure;
15273: }
15273: 
15273: 
15273: SECStatus
15273: NSS_Init(const char *configdir)
15273: {
37961:     return nss_Init(configdir, "", "", SECMOD_DB, "", "", "", "", "", NULL,
37961: 		NULL, PR_TRUE, PR_FALSE, PR_FALSE, PR_FALSE, PR_FALSE, 
15273: 		PR_TRUE, PR_FALSE, PR_FALSE, PR_FALSE);
15273: }
15273: 
15273: SECStatus
15273: NSS_InitReadWrite(const char *configdir)
15273: {
37961:     return nss_Init(configdir, "", "", SECMOD_DB, "", "", "", "", "", NULL,
37961: 		NULL, PR_FALSE, PR_FALSE, PR_FALSE, PR_FALSE, PR_FALSE, 
15273: 		PR_TRUE, PR_FALSE, PR_FALSE, PR_FALSE);
15273: }
15273: 
15273: /*
15273:  * OK there are now lots of options here, lets go through them all:
15273:  *
15273:  * configdir - base directory where all the cert, key, and module datbases live.
15273:  * certPrefix - prefix added to the beginning of the cert database example: "
15273:  * 			"https-server1-"
15273:  * keyPrefix - prefix added to the beginning of the key database example: "
15273:  * 			"https-server1-"
15273:  * secmodName - name of the security module database (usually "secmod.db").
15273:  * flags - change the open options of NSS_Initialize as follows:
15273:  * 	NSS_INIT_READONLY - Open the databases read only.
15273:  * 	NSS_INIT_NOCERTDB - Don't open the cert DB and key DB's, just 
15273:  * 			initialize the volatile certdb.
15273:  * 	NSS_INIT_NOMODDB  - Don't open the security module DB, just 
15273:  *			initialize the 	PKCS #11 module.
15273:  *      NSS_INIT_FORCEOPEN - Continue to force initializations even if the 
15273:  * 			databases cannot be opened.
15273:  *      NSS_INIT_PK11THREADSAFE - only load PKCS#11 modules that are
15273:  *                      thread-safe, ie. that support locking - either OS
15273:  *                      locking or NSS-provided locks . If a PKCS#11
15273:  *                      module isn't thread-safe, don't serialize its
15273:  *                      calls; just don't load it instead. This is necessary
15273:  *                      if another piece of code is using the same PKCS#11
15273:  *                      modules that NSS is accessing without going through
15273:  *                      NSS, for example the Java SunPKCS11 provider.
15273:  *      NSS_INIT_PK11RELOAD - ignore the CKR_CRYPTOKI_ALREADY_INITIALIZED
15273:  *                      error when loading PKCS#11 modules. This is necessary
15273:  *                      if another piece of code is using the same PKCS#11
15273:  *                      modules that NSS is accessing without going through
15273:  *                      NSS, for example Java SunPKCS11 provider.
15273:  *      NSS_INIT_NOPK11FINALIZE - never call C_Finalize on any
15273:  *                      PKCS#11 module. This may be necessary in order to
15273:  *                      ensure continuous operation and proper shutdown
15273:  *                      sequence if another piece of code is using the same
15273:  *                      PKCS#11 modules that NSS is accessing without going
15273:  *                      through NSS, for example Java SunPKCS11 provider.
15273:  *                      The following limitation applies when this is set :
15273:  *                      SECMOD_WaitForAnyTokenEvent will not use
15273:  *                      C_WaitForSlotEvent, in order to prevent the need for
15273:  *                      C_Finalize. This call will be emulated instead.
15273:  *      NSS_INIT_RESERVED - Currently has no effect, but may be used in the
15273:  *                      future to trigger better cooperation between PKCS#11
15273:  *                      modules used by both NSS and the Java SunPKCS11
15273:  *                      provider. This should occur after a new flag is defined
15273:  *                      for C_Initialize by the PKCS#11 working group.
15273:  *      NSS_INIT_COOPERATE - Sets 4 recommended options for applications that
15273:  *                      use both NSS and the Java SunPKCS11 provider. 
15273:  */
15273: SECStatus
15273: NSS_Initialize(const char *configdir, const char *certPrefix, 
15273: 	const char *keyPrefix, const char *secmodName, PRUint32 flags)
15273: {
15273:     return nss_Init(configdir, certPrefix, keyPrefix, secmodName,
37961: 	"", "", "", "", "", NULL, NULL,
15273: 	((flags & NSS_INIT_READONLY) == NSS_INIT_READONLY),
15273: 	((flags & NSS_INIT_NOCERTDB) == NSS_INIT_NOCERTDB),
15273: 	((flags & NSS_INIT_NOMODDB) == NSS_INIT_NOMODDB),
15273: 	((flags & NSS_INIT_FORCEOPEN) == NSS_INIT_FORCEOPEN),
15273: 	((flags & NSS_INIT_NOROOTINIT) == NSS_INIT_NOROOTINIT),
15273: 	((flags & NSS_INIT_OPTIMIZESPACE) == NSS_INIT_OPTIMIZESPACE),
15273:         ((flags & NSS_INIT_PK11THREADSAFE) == NSS_INIT_PK11THREADSAFE),
15273:         ((flags & NSS_INIT_PK11RELOAD) == NSS_INIT_PK11RELOAD),
15273:         ((flags & NSS_INIT_NOPK11FINALIZE) == NSS_INIT_NOPK11FINALIZE));
15273: }
15273: 
37961: NSSInitContext *
37961: NSS_InitContext(const char *configdir, const char *certPrefix, 
37961: 	const char *keyPrefix, const char *secmodName, 
37961: 	NSSInitParameters *initParams, PRUint32 flags)
37961: {
37961:     SECStatus rv;
37961:     NSSInitContext *context;
37961: 
37961:     rv = nss_Init(configdir, certPrefix, keyPrefix, secmodName,
37961: 	"", "", "", "", "", &context, initParams,
37961: 	((flags & NSS_INIT_READONLY) == NSS_INIT_READONLY),
37961: 	((flags & NSS_INIT_NOCERTDB) == NSS_INIT_NOCERTDB),
37961: 	((flags & NSS_INIT_NOMODDB) == NSS_INIT_NOMODDB),
37961: 	((flags & NSS_INIT_FORCEOPEN) == NSS_INIT_FORCEOPEN), PR_TRUE,
37961: 	((flags & NSS_INIT_OPTIMIZESPACE) == NSS_INIT_OPTIMIZESPACE),
37961:         ((flags & NSS_INIT_PK11THREADSAFE) == NSS_INIT_PK11THREADSAFE),
37961:         ((flags & NSS_INIT_PK11RELOAD) == NSS_INIT_PK11RELOAD),
37961:         ((flags & NSS_INIT_NOPK11FINALIZE) == NSS_INIT_NOPK11FINALIZE));
37961:     return (rv == SECSuccess) ? context : NULL;
37961: }
37961: 
15273: SECStatus
15273: NSS_InitWithMerge(const char *configdir, const char *certPrefix, 
15273: 	const char *keyPrefix, const char *secmodName, 
15273: 	const char *updateDir, const char *updCertPrefix,
15273: 	const char *updKeyPrefix, const char *updateID, 
15273: 	const char *updateName, PRUint32 flags)
15273: {
15273:     return nss_Init(configdir, certPrefix, keyPrefix, secmodName,
15273: 	updateDir, updCertPrefix, updKeyPrefix, updateID, updateName, 
37961: 	NULL, NULL,
15273: 	((flags & NSS_INIT_READONLY) == NSS_INIT_READONLY),
15273: 	((flags & NSS_INIT_NOCERTDB) == NSS_INIT_NOCERTDB),
15273: 	((flags & NSS_INIT_NOMODDB) == NSS_INIT_NOMODDB),
15273: 	((flags & NSS_INIT_FORCEOPEN) == NSS_INIT_FORCEOPEN),
15273: 	((flags & NSS_INIT_NOROOTINIT) == NSS_INIT_NOROOTINIT),
15273: 	((flags & NSS_INIT_OPTIMIZESPACE) == NSS_INIT_OPTIMIZESPACE),
15273:         ((flags & NSS_INIT_PK11THREADSAFE) == NSS_INIT_PK11THREADSAFE),
15273:         ((flags & NSS_INIT_PK11RELOAD) == NSS_INIT_PK11RELOAD),
15273:         ((flags & NSS_INIT_NOPK11FINALIZE) == NSS_INIT_NOPK11FINALIZE));
15273: }
15273: 
15273: /*
15273:  * initialize NSS without a creating cert db's, key db's, or secmod db's.
15273:  */
15273: SECStatus
15273: NSS_NoDB_Init(const char * configdir)
15273: {
37961:       return nss_Init("","","","", "", "", "", "", "", NULL, NULL,
15273: 			PR_TRUE,PR_TRUE,PR_TRUE,PR_TRUE,PR_TRUE,PR_TRUE,
15273: 			PR_FALSE,PR_FALSE,PR_FALSE);
15273: }
15273: 
15273: 
15273: #define NSS_SHUTDOWN_STEP 10
15273: 
15273: struct NSSShutdownFuncPair {
15273:     NSS_ShutdownFunc	func;
15273:     void		*appData;
15273: };
15273: 
15273: static struct NSSShutdownListStr {
15273:     PZLock		*lock;
15273:     int			allocatedFuncs;
15273:     int			peakFuncs;
15273:     struct NSSShutdownFuncPair	*funcs;
15273: } nssShutdownList = { 0 };
15273: 
15273: /*
15273:  * find and existing shutdown function
15273:  */
15273: static int 
15273: nss_GetShutdownEntry(NSS_ShutdownFunc sFunc, void *appData)
15273: {
15273:     int count, i;
15273:     count = nssShutdownList.peakFuncs;
37961: 
15273:     for (i=0; i < count; i++) {
15273: 	if ((nssShutdownList.funcs[i].func == sFunc) &&
15273: 	    (nssShutdownList.funcs[i].appData == appData)){
15273: 	    return i;
15273: 	}
15273:     }
15273:     return -1;
15273: }
15273:     
15273: /*
15273:  * register a callback to be called when NSS shuts down
15273:  */
15273: SECStatus
15273: NSS_RegisterShutdown(NSS_ShutdownFunc sFunc, void *appData)
15273: {
15273:     int i;
15273: 
79996:     PZ_Lock(nssInitLock);
37961:     if (!NSS_IsInitialized()) {
79996: 	PZ_Unlock(nssInitLock);
37961: 	PORT_SetError(SEC_ERROR_NOT_INITIALIZED);
15273: 	return SECFailure;
15273:     }
79996:     PZ_Unlock(nssInitLock);
15273:     if (sFunc == NULL) {
15273: 	PORT_SetError(SEC_ERROR_INVALID_ARGS);
15273: 	return SECFailure;
15273:     }
15273: 
15273:     PORT_Assert(nssShutdownList.lock);
15273:     PZ_Lock(nssShutdownList.lock);
15273: 
15273:     /* make sure we don't have a duplicate */
15273:     i = nss_GetShutdownEntry(sFunc, appData);
15273:     if (i >= 0) {
15273: 	PZ_Unlock(nssShutdownList.lock);
15273: 	PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
15273: 	return SECFailure;
15273:     }
15273:     /* find an empty slot */
15273:     i = nss_GetShutdownEntry(NULL, NULL);
15273:     if (i >= 0) {
15273: 	nssShutdownList.funcs[i].func = sFunc;
15273: 	nssShutdownList.funcs[i].appData = appData;
15273: 	PZ_Unlock(nssShutdownList.lock);
15273: 	return SECSuccess;
15273:     }
15273:     if (nssShutdownList.allocatedFuncs == nssShutdownList.peakFuncs) {
15273: 	struct NSSShutdownFuncPair *funcs = 
15273: 		(struct NSSShutdownFuncPair *)PORT_Realloc
15273: 		(nssShutdownList.funcs, 
15273: 		(nssShutdownList.allocatedFuncs + NSS_SHUTDOWN_STEP) 
15273: 		*sizeof(struct NSSShutdownFuncPair));
15273: 	if (!funcs) {
31666: 	    PZ_Unlock(nssShutdownList.lock);
15273: 	    return SECFailure;
15273: 	}
15273: 	nssShutdownList.funcs = funcs;
15273: 	nssShutdownList.allocatedFuncs += NSS_SHUTDOWN_STEP;
15273:     }
15273:     nssShutdownList.funcs[nssShutdownList.peakFuncs].func = sFunc;
15273:     nssShutdownList.funcs[nssShutdownList.peakFuncs].appData = appData;
15273:     nssShutdownList.peakFuncs++;
15273:     PZ_Unlock(nssShutdownList.lock);
15273:     return SECSuccess;
15273: }
15273: 
15273: /*
15273:  * unregister a callback so it won't get called on shutdown.
15273:  */
15273: SECStatus
15273: NSS_UnregisterShutdown(NSS_ShutdownFunc sFunc, void *appData)
15273: {
15273:     int i;
79996: 
79996:     PZ_Lock(nssInitLock);
37961:     if (!NSS_IsInitialized()) {
79996: 	PZ_Unlock(nssInitLock);
37961: 	PORT_SetError(SEC_ERROR_NOT_INITIALIZED);
15273: 	return SECFailure;
15273:     }
79996:     PZ_Unlock(nssInitLock);
15273: 
15273:     PORT_Assert(nssShutdownList.lock);
15273:     PZ_Lock(nssShutdownList.lock);
15273:     i = nss_GetShutdownEntry(sFunc, appData);
15273:     if (i >= 0) {
15273: 	nssShutdownList.funcs[i].func = NULL;
15273: 	nssShutdownList.funcs[i].appData = NULL;
15273:     }
15273:     PZ_Unlock(nssShutdownList.lock);
15273: 
15273:     if (i < 0) {
15273: 	PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);
15273: 	return SECFailure;
15273:     }
15273:     return SECSuccess;
15273: }
15273: 
15273: /*
15273:  * bring up and shutdown the shutdown list
15273:  */
15273: static SECStatus
15273: nss_InitShutdownList(void)
15273: {
37961:     if (nssShutdownList.lock != NULL) {
37961: 	return SECSuccess;
37961:     }
15273:     nssShutdownList.lock = PZ_NewLock(nssILockOther);
15273:     if (nssShutdownList.lock == NULL) {
15273: 	return SECFailure;
15273:     }
15273:     nssShutdownList.funcs = PORT_ZNewArray(struct NSSShutdownFuncPair, 
15273: 				           NSS_SHUTDOWN_STEP);
15273:     if (nssShutdownList.funcs == NULL) {
15273: 	PZ_DestroyLock(nssShutdownList.lock);
15273:     	nssShutdownList.lock = NULL;
15273: 	return SECFailure;
15273:     }
15273:     nssShutdownList.allocatedFuncs = NSS_SHUTDOWN_STEP;
15273:     nssShutdownList.peakFuncs = 0;
15273: 
15273:     return SECSuccess;
15273: }
15273: 
15273: static SECStatus
15273: nss_ShutdownShutdownList(void)
15273: {
15273:     SECStatus rv = SECSuccess;
15273:     int i;
15273: 
15273:     /* call all the registerd functions first */
15273:     for (i=0; i < nssShutdownList.peakFuncs; i++) {
15273: 	struct NSSShutdownFuncPair *funcPair = &nssShutdownList.funcs[i];
15273: 	if (funcPair->func) {
15273: 	    if ((*funcPair->func)(funcPair->appData,NULL) != SECSuccess) {
15273: 		rv = SECFailure;
15273: 	    }
15273: 	}
15273:     }
15273: 
15273:     nssShutdownList.peakFuncs = 0;
15273:     nssShutdownList.allocatedFuncs = 0;
15273:     PORT_Free(nssShutdownList.funcs);
15273:     nssShutdownList.funcs = NULL;
15273:     if (nssShutdownList.lock) {
15273: 	PZ_DestroyLock(nssShutdownList.lock);
15273:     }
15273:     nssShutdownList.lock = NULL;
15273:     return rv;
15273: }
15273: 
15273: 
15273: extern const NSSError NSS_ERROR_BUSY;
15273: 
15273: SECStatus
37961: nss_Shutdown(void)
15273: {
15273:     SECStatus shutdownRV = SECSuccess;
15273:     SECStatus rv;
15273:     PRStatus status;
37961:     NSSInitContext *temp;
15273: 
15273:     rv = nss_ShutdownShutdownList();
15273:     if (rv != SECSuccess) {
15273: 	shutdownRV = SECFailure;
15273:     }
15273:     cert_DestroyLocks();
15273:     ShutdownCRLCache();
15273:     OCSP_ShutdownGlobal();
15273:     PKIX_Shutdown(plContext);
15273:     SECOID_Shutdown();
15273:     status = STAN_Shutdown();
15273:     cert_DestroySubjectKeyIDHashTable();
37961:     pk11_SetInternalKeySlot(NULL);
15273:     rv = SECMOD_Shutdown();
15273:     if (rv != SECSuccess) {
15273: 	shutdownRV = SECFailure;
15273:     }
15273:     pk11sdr_Shutdown();
16700:     /*
16700:      * A thread's error stack is automatically destroyed when the thread
16700:      * terminates, except for the primordial thread, whose error stack is
16700:      * destroyed by PR_Cleanup.  Since NSS is usually shut down by the
16700:      * primordial thread and many NSS-based apps don't call PR_Cleanup,
16700:      * we destroy the calling thread's error stack here.
16700:      */
16700:     nss_DestroyErrorStack();
15273:     nssArena_Shutdown();
15273:     if (status == PR_FAILURE) {
15273: 	if (NSS_GetError() == NSS_ERROR_BUSY) {
15273: 	    PORT_SetError(SEC_ERROR_BUSY);
15273: 	}
15273: 	shutdownRV = SECFailure;
15273:     }
37961:     nssIsInitted = PR_FALSE;
37961:     temp = nssInitContextList;
37961:     nssInitContextList = NULL;
37961:     /* free the old list. This is necessary when we are called from
37961:      * NSS_Shutdown(). */
37961:     while (temp) {
37961: 	NSSInitContext *next = temp->next;
37961: 	temp->magic = 0;
37961: 	PORT_Free(temp);
37961: 	temp = next;
37961:     }
15273:     return shutdownRV;
15273: }
15273: 
37961: SECStatus
37961: NSS_Shutdown(void)
37961: {
79996:     SECStatus rv;
79996:     PZ_Lock(nssInitLock);
79996: 
37961:     if (!nssIsInitted) {
79996: 	PZ_Unlock(nssInitLock);
37961: 	PORT_SetError(SEC_ERROR_NOT_INITIALIZED);
37961: 	return SECFailure;
37961:     }
37961: 
79996:     /* If one or more threads are in the middle of init, wait for them
79996:      * to complete */
79996:     while (nssIsInInit) {
79996: 	PZ_WaitCondVar(nssInitCondition,PR_INTERVAL_NO_TIMEOUT);
79996:     }
79996:     rv = nss_Shutdown();
79996:     PZ_Unlock(nssInitLock);
79996:     return rv;
37961: }
37961: 
37961: /*
37961:  * remove the context from a list. return true if found, false if not
37961:  */
37961: PRBool
37961: nss_RemoveList(NSSInitContext *context) {
37961:     NSSInitContext *this = nssInitContextList;
37961:     NSSInitContext **last = &nssInitContextList;
37961: 
37961:     while (this) {
37961: 	if (this == context) {
37961: 	    *last = this->next;
37961: 	    this->magic = 0;
37961: 	    PORT_Free(this);
37961: 	    return PR_TRUE;
37961: 	}
37961: 	last = &this->next;
37961: 	this=this->next;
37961:     }
37961:     return PR_FALSE;
37961: }
37961: 
37961: /*
37961:  * This form of shutdown is safe in the case where we may have multiple 
37961:  * entities using NSS in a single process. Each entity calls shutdown with
37961:  * it's own context. The application (which doesn't get a context), calls
37961:  * shutdown with NULL. Once all users have 'checked in' NSS will shutdown.
37961:  * This is different than NSS_Shutdown, where calling it will shutdown NSS
37961:  * irreguardless of who else may have NSS open.
37961:  */
37961: SECStatus
37961: NSS_ShutdownContext(NSSInitContext *context)
37961: {
79996:     SECStatus rv = SECSuccess;
79996: 
79996:     PZ_Lock(nssInitLock);
79996:     /* If one or more threads are in the middle of init, wait for them
79996:      * to complete */
79996:     while (nssIsInInit) {
79996: 	PZ_WaitCondVar(nssInitCondition,PR_INTERVAL_NO_TIMEOUT);
79996:     }
79996: 
79996:     /* OK, we are the only thread now either initializing or shutting down */
79996:     
37961:     if (!context) {
37961: 	if (!nssIsInitted) {
79996: 	    PZ_Unlock(nssInitLock);
37961: 	    PORT_SetError(SEC_ERROR_NOT_INITIALIZED);
37961: 	    return SECFailure;
37961: 	}
37961: 	nssIsInitted = 0;
37961:     } else if (! nss_RemoveList(context)) {
79996: 	PZ_Unlock(nssInitLock);
37961: 	/* context was already freed or wasn't valid */
37961: 	PORT_SetError(SEC_ERROR_NOT_INITIALIZED);
37961: 	return SECFailure;
37961:     }
37961:     if ((nssIsInitted == 0) && (nssInitContextList == NULL)) {
79996: 	rv = nss_Shutdown();
37961:     }
37961: 
79996:     /* NOTE: we don't try to free the nssInitLocks to prevent races against
79996:      * the locks. There may be a thread, right now, waiting in NSS_Init for us
79996:      * to free the lock below. If we delete the locks, bad things would happen
79996:      * to that thread */
79996:     PZ_Unlock(nssInitLock);
37961: 
79996:     return rv;
79996: }
37961: 
15273: PRBool
15273: NSS_IsInitialized(void)
15273: {
37961:     return (nssIsInitted) || (nssInitContextList != NULL);
15273: }
15273: 	
15273: 
15273: extern const char __nss_base_rcsid[];
15273: extern const char __nss_base_sccsid[];
15273: 
15273: PRBool
15273: NSS_VersionCheck(const char *importedVersion)
15273: {
15273:     /*
15273:      * This is the secret handshake algorithm.
15273:      *
15273:      * This release has a simple version compatibility
15273:      * check algorithm.  This release is not backward
15273:      * compatible with previous major releases.  It is
15273:      * not compatible with future major, minor, or
37961:      * patch releases or builds.
15273:      */
37961:     int vmajor = 0, vminor = 0, vpatch = 0, vbuild = 0;
15273:     const char *ptr = importedVersion;
15273:     volatile char c; /* force a reference that won't get optimized away */
15273: 
15273:     c = __nss_base_rcsid[0] + __nss_base_sccsid[0]; 
15273: 
15273:     while (isdigit(*ptr)) {
15273:         vmajor = 10 * vmajor + *ptr - '0';
15273:         ptr++;
15273:     }
15273:     if (*ptr == '.') {
15273:         ptr++;
15273:         while (isdigit(*ptr)) {
15273:             vminor = 10 * vminor + *ptr - '0';
15273:             ptr++;
15273:         }
15273:         if (*ptr == '.') {
15273:             ptr++;
15273:             while (isdigit(*ptr)) {
15273:                 vpatch = 10 * vpatch + *ptr - '0';
15273:                 ptr++;
15273:             }
37961:             if (*ptr == '.') {
37961:                 ptr++;
37961:                 while (isdigit(*ptr)) {
37961:                     vbuild = 10 * vbuild + *ptr - '0';
37961:                     ptr++;
37961:                 }
37961:             }
15273:         }
15273:     }
15273: 
15273:     if (vmajor != NSS_VMAJOR) {
15273:         return PR_FALSE;
15273:     }
15273:     if (vmajor == NSS_VMAJOR && vminor > NSS_VMINOR) {
15273:         return PR_FALSE;
15273:     }
15273:     if (vmajor == NSS_VMAJOR && vminor == NSS_VMINOR && vpatch > NSS_VPATCH) {
15273:         return PR_FALSE;
15273:     }
37961:     if (vmajor == NSS_VMAJOR && vminor == NSS_VMINOR &&
37961:         vpatch == NSS_VPATCH && vbuild > NSS_VBUILD) {
37961:         return PR_FALSE;
37961:     }
15273:     /* Check dependent libraries */
15273:     if (PR_VersionCheck(PR_VERSION) == PR_FALSE) {
15273:         return PR_FALSE;
15273:     }
15273:     return PR_TRUE;
15273: }
76874: 
76874: const char *
76874: NSS_GetVersion(void)
76874: {
76874:     return NSS_VERSION;
76874: }
